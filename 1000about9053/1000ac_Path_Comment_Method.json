[{
	"Path": "com.sun.enterprise.security.cli.DeletePasswordAlias.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        domainPasswordAliasStore.remove(aliasName);\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n        reportFailure(report, ex);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.pitest.aggregate.DataLoader.readDocument",
	"Comment": "reads the input stream into a document and closes the input stream whenfinished.",
	"Method": "Document readDocument(InputStream inputStream){\r\n    DocumentBuilder docBuilder;\r\n    try {\r\n        docBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\r\n        return docBuilder.parse(inputStream);\r\n    } catch (final IOException e) {\r\n        throw new ReportAggregationException(e.getMessage(), e);\r\n    } catch (final SAXException e) {\r\n        throw new ReportAggregationException(e.getMessage(), e);\r\n    } catch (final ParserConfigurationException e) {\r\n        throw new ReportAggregationException(e.getMessage(), e);\r\n    } finally {\r\n        try {\r\n            inputStream.close();\r\n        } catch (final IOException e) {\r\n            throw new ReportAggregationException(CANNOT_CLOSE_ERR, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.Array.set",
	"Comment": "replaces the value at the specified position in this array with the specified value.value can be null.",
	"Method": "Value set(int index,Value value){\r\n    return values.set(index, value);\r\n}"
}, {
	"Path": "io.advantageous.qbit.reactive.CallbackBuilder.delegateWithLogging",
	"Comment": "builder method to delegate timeout and error handling to other callback.",
	"Method": "CallbackBuilder delegateWithLogging(Callback<T> callback,Logger logger,String operationName){\r\n    this.withErrorHandler(throwable -> {\r\n        logger.error(operationName + \" ERROR \", throwable);\r\n        callback.onError(throwable);\r\n    });\r\n    this.withTimeoutHandler(() -> {\r\n        logger.error(operationName + \" TIMED OUT \");\r\n        callback.onTimeout();\r\n    });\r\n    return this;\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.ConnectedUsers.notifyRemoveUser",
	"Comment": "broadcast to all remaining users that a user has left. also logs for metrics.",
	"Method": "void notifyRemoveUser(User user,DisconnectReason reason){\r\n    final HashMap<ReturnableData, Object> data = new HashMap<ReturnableData, Object>();\r\n    data.put(LongPollResponse.EVENT, LongPollEvent.PLAYER_LEAVE.toString());\r\n    data.put(LongPollResponse.NICKNAME, user.getNickname());\r\n    data.put(LongPollResponse.REASON, reason.toString());\r\n    if (broadcastConnectsAndDisconnectsProvider.get() || reason == DisconnectReason.BANNED || reason == DisconnectReason.KICKED) {\r\n        broadcastToAll(MessageType.PLAYER_EVENT, data);\r\n    } else {\r\n        broadcastToList(getAdmins(), MessageType.PLAYER_EVENT, data);\r\n    }\r\n    metrics.userDisconnect(user.getSessionId());\r\n}"
}, {
	"Path": "org.pitest.classinfo.ComputeClassWriter.typeAncestors",
	"Comment": "returns the internal names of the ancestor classes of the given type.",
	"Method": "StringBuilder typeAncestors(String type,ClassReader info){\r\n    final StringBuilder b = new StringBuilder();\r\n    while (!\"java/lang/Object\".equals(type)) {\r\n        b.append(';').append(type);\r\n        type = info.getSuperName();\r\n        info = typeInfo(type);\r\n    }\r\n    return b;\r\n}"
}, {
	"Path": "org.pitest.mutationtest.config.ReportOptions.createMinionSettings",
	"Comment": "creates a serializable subset of data for use in child processes",
	"Method": "TestPluginArguments createMinionSettings(){\r\n    return new TestPluginArguments(getTestPlugin(), this.getGroupConfig(), this.getExcludedRunners(), this.getIncludedTestMethods(), this.skipFailingTests());\r\n}"
}, {
	"Path": "ro.pippo.session.xmemcached.XmemcachedSessionDataStorageTest.testGetExpired",
	"Comment": "test of get method, of class xmemcachedsessiondatastorage.",
	"Method": "void testGetExpired(){\r\n    System.out.println(\"get expired\");\r\n    XmemcachedSessionDataStorage instance = new XmemcachedSessionDataStorage(client, IDLE_TIME);\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    Thread.sleep(2000L);\r\n    SessionData deleted = instance.get(sessionId);\r\n    assertNull(deleted);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.chooseServerAlias",
	"Comment": "choose the server alias that will be used to select the server certificate for ssl server auth.",
	"Method": "String chooseServerAlias(String keyType,Principal[] issuers,Socket socket){\r\n    String serverAlias = null;\r\n    if (this.alias != null) {\r\n        serverAlias = this.alias;\r\n    } else {\r\n        serverAlias = x509KeyManager.chooseServerAlias(keyType, issuers, socket);\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"Choosing server alias :{0}\", serverAlias);\r\n    }\r\n    return serverAlias;\r\n}"
}, {
	"Path": "ro.pippo.core.PippoSettings.getBoolean",
	"Comment": "returns the boolean value for the specified name. if the name does notexist or the value for the name can not be interpreted as a boolean, thedefaultvalue is returned.",
	"Method": "boolean getBoolean(String name,boolean defaultValue){\r\n    String value = getString(name, null);\r\n    if (!StringUtils.isNullOrEmpty(value)) {\r\n        return Boolean.parseBoolean(value.trim());\r\n    }\r\n    return defaultValue;\r\n}"
}, {
	"Path": "org.pitest.mutationtest.engine.gregor.mutators.InlineConstantMutatorTest.preventSourceFormatingMakingFinal",
	"Comment": "eclipse source cleanup will make everything final if possible",
	"Method": "short preventSourceFormatingMakingFinal(short s,byte preventSourceFormatingMakingFinal,byte b,T preventSourceFormatingMakingFinal,T f){\r\n    return f;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreatePasswordAlias.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        if (domainPasswordAliasStore.containsKey(aliasName)) {\r\n            report.setMessage(localStrings.getLocalString(\"create.password.alias.alreadyexists\", \"Password alias with the specified name already exists. \" + \"Please use the update-password-alias command to change it\", aliasName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n        domainPasswordAliasStore.put(aliasName, aliasPassword.toCharArray());\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n        report.setMessage(localStrings.getLocalString(\"create.password.alias.fail\", \"Creation of Password Alias {0} failed\", aliasName) + \"  \" + ex.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(ex);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.pitest.bytecode.analysis.MethodMatchers.named",
	"Comment": "match a method based on its name, as methods can be overloadedthis should be used with caution.",
	"Method": "Predicate<MethodTree> named(String name){\r\n    return a -> a.rawNode().name.equals(name);\r\n}"
}, {
	"Path": "io.advantageous.qbit.admin.ManagedServiceBuilder.getServiceDiscoverySupplier",
	"Comment": "used to get access to the servicediscoverysupplier which could be null.",
	"Method": "Supplier<ServiceDiscovery> getServiceDiscoverySupplier(){\r\n    return serviceDiscoverySupplier;\r\n}"
}, {
	"Path": "org.pf4j.DependencyResolver.getDependents",
	"Comment": "retrieves the plugins ids that the given content is a direct dependency of.",
	"Method": "List<String> getDependents(String pluginId){\r\n    checkResolved();\r\n    return dependentsGraph.getNeighbors(pluginId);\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.getAttributeResolvers",
	"Comment": "determines the current list of attributeresolver instances,in execution order.",
	"Method": "List<AzAttributeResolver> getAttributeResolvers(){\r\n    return new ArrayList<AzAttributeResolver>(attributeResolvers);\r\n}"
}, {
	"Path": "io.advantageous.qbit.admin.ServiceManagementBundle.recordLevel",
	"Comment": "prefixes the stats key with the stat key prefix, and then calls statscollector.recordlevel.",
	"Method": "void recordLevel(String statKey,long level){\r\n    final String longKey = getActualStatKey(statKey);\r\n    stats.recordLevel(longKey, level);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.common.ServerLoginCallbackHandler.handle",
	"Comment": "this is the callback method called when authentication data is required. it either pops up a dialog box to requestauthentication data or use text input.",
	"Method": "void handle(Callback[] callbacks){\r\n    for (int i = 0; i < callbacks.length; i++) {\r\n        if (callbacks[i] instanceof NameCallback) {\r\n            NameCallback nme = (NameCallback) callbacks[i];\r\n            nme.setName(username);\r\n        } else if (callbacks[i] instanceof PasswordCallback) {\r\n            PasswordCallback pswd = (PasswordCallback) callbacks[i];\r\n            pswd.setPassword(password);\r\n        } else if (callbacks[i] instanceof CertificateRealm.AppContextCallback) {\r\n            ((CertificateRealm.AppContextCallback) callbacks[i]).setModuleID(moduleID);\r\n        } else if (GP_CB.equals(callbacks[i].getClass().getName())) {\r\n            processGroupPrincipal(callbacks[i]);\r\n        } else {\r\n            throw new UnsupportedCallbackException(callbacks[i]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.Factory.createRemoteProxyWithReturnAddress",
	"Comment": "create a remote proxy using a sender that knows how to forwardevent method body over wire",
	"Method": "T createRemoteProxyWithReturnAddress(Class<T> serviceInterface,String uri,String serviceName,String host,int port,AtomicBoolean connected,String returnAddressArg,Sender<String> sender,BeforeMethodCall beforeMethodCall,int requestBatchSize,BeforeMethodSent beforeMethodSent){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.glassfish.resourcebase.resources.listener.ResourceManager.getResourceDeployer",
	"Comment": "given a resource instance, appropriate deployer will be provided",
	"Method": "ResourceDeployer getResourceDeployer(Object resource){\r\n    return resourceManagerFactoryProvider.get().getResourceDeployer(resource);\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.CoreTagsTest.testIncludeOverridesVariable",
	"Comment": "ensures that an include with a variable override works even if a null value is passed.",
	"Method": "void testIncludeOverridesVariable(){\r\n    PebbleEngine pebble = new PebbleEngine.Builder().strictVariables(false).build();\r\n    PebbleTemplate template = pebble.getTemplate(\"templates/template.includeOverrideVariable1.peb\");\r\n    Writer writer = new StringWriter();\r\n    template.evaluate(writer);\r\n    assertEquals(\"One: one (overridden)\" + LINE_SEPARATOR + \"Two: \", writer.toString());\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.Primitive.getAsInt",
	"Comment": "convenience method to get this value as a primitive integer.",
	"Method": "int getAsInt(){\r\n    return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString());\r\n}"
}, {
	"Path": "io.advantageous.qbit.reakt.Reakt.convertCallback",
	"Comment": "converts a reakt callback into a qbit callback.reactor is used to manage timeouts and ensure callback happens on same thread as caller.",
	"Method": "Callback<T> convertCallback(io.advantageous.reakt.CallbackHandler<T> callback,Callback<T> convertCallback,Reactor reactor,io.advantageous.reakt.CallbackHandler<T> callback){\r\n    return convertReaktCallbackToQBitCallback(callback, reactor.callbackBuilder());\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.unsetClientSecurityContext",
	"Comment": "unsets the current appclient security context on the thread local storage",
	"Method": "void unsetClientSecurityContext(){\r\n    ClientSecurityContext.setCurrent(null);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.UsernamePasswordStore.reset",
	"Comment": "clears the username and password, that might have been previously stored, either globally or locally to each thread.",
	"Method": "void reset(){\r\n    if (isPerThreadAuth) {\r\n        localUpc.set(null);\r\n    } else {\r\n        synchronized (UsernamePasswordStore.class) {\r\n            sharedUpc = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ro.pippo.core.Languages.getLocaleOrDefault",
	"Comment": "returns the java locale for the specified language or the locale for thedefault language if the requested language can not be mapped to a locale.",
	"Method": "Locale getLocaleOrDefault(RouteContext routeContext,Locale getLocaleOrDefault,String language){\r\n    String lang = getLanguageOrDefault(language);\r\n    return Locale.forLanguageTag(lang);\r\n}"
}, {
	"Path": "org.pf4j.DefaultPluginDescriptor.getDependencies",
	"Comment": "returns all dependencies declared by this plugin.returns an empty array if this plugin does not declare any require.",
	"Method": "List<PluginDependency> getDependencies(){\r\n    return dependencies;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.common.PasswordCredential.equals",
	"Comment": "compare two instances of the credential and return true if they are the same and false otherwise.",
	"Method": "boolean equals(Object o){\r\n    if (o instanceof PasswordCredential) {\r\n        PasswordCredential pc = (PasswordCredential) o;\r\n        if (pc.getUser().equals(username) && Arrays.equals(pc.getPassword(), password) && pc.getRealm().equals(realm)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.UsernamePasswordStore.resetThreadLocalOnly",
	"Comment": "clears the username and password only is they were stored locally to each thread",
	"Method": "void resetThreadLocalOnly(){\r\n    if (isPerThreadAuth) {\r\n        localUpc.set(null);\r\n    }\r\n}"
}, {
	"Path": "ro.pippo.controller.util.ControllerUtils.getProduces",
	"Comment": "todo one controllermethod that takes annotation type as parameter",
	"Method": "List<String> getProduces(Method method){\r\n    Set<String> contentTypes = new LinkedHashSet();\r\n    Produces produces = ClassUtils.getAnnotation(method, Produces.class);\r\n    if (produces != null) {\r\n        for (String value : produces.value()) {\r\n            contentTypes.add(value.trim());\r\n        }\r\n    }\r\n    return new ArrayList(contentTypes);\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.Value.getAsFloat",
	"Comment": "convenience method to get this value as a primitive float value.",
	"Method": "float getAsFloat(){\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.WritingTest.testMultipleEvaluationsWithOneWriter",
	"Comment": "there was an issue where the pebble engine was closing the provided writer. this is wrong.",
	"Method": "void testMultipleEvaluationsWithOneWriter(){\r\n    PebbleEngine pebble = new PebbleEngine.Builder().loader(new StringLoader()).build();\r\n    PebbleTemplate template1 = pebble.getTemplate(\"first\");\r\n    PebbleTemplate template2 = pebble.getTemplate(\"second\");\r\n    Writer writer = new UncloseableWriter();\r\n    template1.evaluate(writer);\r\n    template2.evaluate(writer);\r\n    assertEquals(\"firstsecond\", writer.toString());\r\n}"
}, {
	"Path": "com.turo.pushy.apns.metrics.dropwizard.DropwizardApnsClientMetricsListener.handleConnectionAdded",
	"Comment": "records that the apns server added a new connection to its internal connection pool and updates metricsaccordingly.",
	"Method": "void handleConnectionAdded(ApnsClient apnsClient){\r\n    this.openConnections.incrementAndGet();\r\n}"
}, {
	"Path": "io.advantageous.qbit.reactive.Reactor.monitorCallbackCoordinators",
	"Comment": "monitors callback coordinators.trigger timeouts if needed and remove coordinators from list that timed out.",
	"Method": "void monitorCallbackCoordinators(){\r\n    if (coordinatorList.size() > 0) {\r\n        final List<CallbackCoordinator> removeList = new ArrayList(coordinatorList.size());\r\n        for (CallbackCoordinator callable : coordinatorList) {\r\n            if (callable.checkComplete()) {\r\n                callable.finished();\r\n                removeList.add(callable);\r\n            } else if (callable.timedOut(currentTime)) {\r\n                removeList.add(callable);\r\n            }\r\n        }\r\n        coordinatorList.removeAll(removeList);\r\n    }\r\n}"
}, {
	"Path": "com.rabbitmq.client.ConnectionFactory.isAutomaticRecoveryEnabled",
	"Comment": "returns true if automatic connection recoveryis enabled, false otherwise",
	"Method": "boolean isAutomaticRecoveryEnabled(){\r\n    return automaticRecovery;\r\n}"
}, {
	"Path": "io.advantageous.qbit.reactive.CallbackBuilder.wrap",
	"Comment": "builder method to wrap and delegate, timeout and error handling and callback itself.",
	"Method": "CallbackBuilder wrap(Callback<T> callback){\r\n    this.withErrorHandler(callback::onError);\r\n    this.withTimeoutHandler(callback::onTimeout);\r\n    this.withCallback(callback);\r\n    return this;\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.getReasonInitializationFailed",
	"Comment": "determines the reason why the service failed to initialize.",
	"Method": "String getReasonInitializationFailed(){\r\n    return reasonInitFailed;\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.PebbleEngine.getLiteralTemplate",
	"Comment": "loads, parses, and compiles a template using a stringloader into an instance of pebbletemplateand returns this instance.",
	"Method": "PebbleTemplate getLiteralTemplate(String templateName){\r\n    return this.getTemplate(templateName, new StringLoader());\r\n}"
}, {
	"Path": "io.advantageous.qbit.proxy.ProxyServiceImpl.trackTimeouts",
	"Comment": "tracks timeouts periodically if timeout tracking is enabled.",
	"Method": "void trackTimeouts(){\r\n    new ArrayList(httpRequestHolderList).forEach(httpRequestHolder -> {\r\n        if (httpRequestHolder.request.isHandled()) {\r\n            httpRequestHolderList.remove(httpRequestHolder);\r\n            return;\r\n        }\r\n        final long duration = time - httpRequestHolder.startTime;\r\n        if (duration > timeOutIntervalMS) {\r\n            httpRequestHolder.request.handled();\r\n            httpRequestHolder.request.getReceiver().timeoutWithMessage(String.format(\"\\\"TIMEOUT %s %s %s\\\"\", httpRequestHolder.request.address(), httpRequestHolder.request.getRemoteAddress(), httpRequestHolder.startTime));\r\n            httpRequestHolderList.remove(httpRequestHolder);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "ro.pippo.core.Application.registerTemplateEngine",
	"Comment": "registers a template engine if no other engine has been registered.",
	"Method": "void registerTemplateEngine(Class<? extends TemplateEngine> engineClass){\r\n    if (templateEngine != null) {\r\n        log.debug(\"Template engine already registered, ignoring '{}'\", engineClass.getName());\r\n        return;\r\n    }\r\n    try {\r\n        TemplateEngine engine = engineClass.newInstance();\r\n        setTemplateEngine(engine);\r\n    } catch (Exception e) {\r\n        throw new PippoRuntimeException(e, \"Failed to instantiate '{}'\", engineClass.getName());\r\n    }\r\n}"
}, {
	"Path": "ro.pippo.session.infinispan.InfinispanSessionDataStorageTest.testCreate",
	"Comment": "test of create method, of class infinispansessiondatastorage.",
	"Method": "void testCreate(){\r\n    System.out.println(\"create\");\r\n    InfinispanSessionDataStorage instance = new InfinispanSessionDataStorage(cacheManager);\r\n    SessionData sessionData = instance.create();\r\n    sessionData.put(KEY, VALUE);\r\n    assertNotNull(sessionData);\r\n    assertNotNull(sessionData.getId());\r\n    assertNotNull(sessionData.getCreationTime());\r\n    assertEquals(sessionData.get(KEY), VALUE);\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.ServiceContext.currentService",
	"Comment": "the only time this is valid is during queueinit.this allows a service to get at its service interface.",
	"Method": "ServiceQueue currentService(){\r\n    return BaseServiceQueueImpl.currentService();\r\n}"
}, {
	"Path": "co.yiiu.pybbs.util.HashUtil.generateSalt",
	"Comment": "md5 128bit 16bytessha1 160bit 20bytessha256 256bit 32bytessha384 384bit 48bitessha512 512bit 64bites",
	"Method": "String generateSalt(int numberOfBytes){\r\n    byte[] salt = new byte[numberOfBytes];\r\n    random.nextBytes(salt);\r\n    return toHex(salt);\r\n}"
}, {
	"Path": "net.socialgamer.cah.handlers.Handler.error",
	"Comment": "get a data set for an error response, with extra error information.",
	"Method": "Map<ReturnableData, Object> error(ErrorCode errorCode,Map<ReturnableData, Object> error,ErrorCode errorCode,Map<ReturnableData, Object> extraData){\r\n    final Map<ReturnableData, Object> data = error(errorCode);\r\n    data.putAll(extraData);\r\n    return data;\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.ConnectedUsers.removeUser",
	"Comment": "remove a user from the user list, and mark them as invalid so the next time they make a requestthey can be informed.",
	"Method": "void removeUser(User user,DisconnectReason reason){\r\n    synchronized (users) {\r\n        if (users.containsKey(user.getNickname().toLowerCase())) {\r\n            logger.info(String.format(\"Removing user %s because %s\", user.toString(), reason));\r\n            user.noLongerValid();\r\n            users.remove(user.getNickname().toLowerCase());\r\n            notifyRemoveUser(user, reason);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ro.pippo.session.hazelcast.HazelcastSessionDataStorageTest.testSave",
	"Comment": "test of save method, of class hazelcastsessiondatastorage.",
	"Method": "void testSave(){\r\n    HazelcastInstance hazelcastInstance1 = Hazelcast.newHazelcastInstance();\r\n    HazelcastInstance hazelcastInstance2 = Hazelcast.newHazelcastInstance();\r\n    System.out.println(\"save\");\r\n    HazelcastSessionDataStorage instance = new HazelcastSessionDataStorage(hazelcastInstance1);\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    SessionData saved = hazelcastInstance2.<String, SessionData>getMap(SESSION_NAME).get(sessionId);\r\n    assertEquals(sessionData, saved);\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.discovery.impl.ServiceDiscoveryImpl.loadHealthyServices",
	"Comment": "iterate through the health service queue and load the services.",
	"Method": "void loadHealthyServices(){\r\n    try {\r\n        String serviceName = doneQueue.poll();\r\n        while (serviceName != null) {\r\n            final String serviceNameToFetch = serviceName;\r\n            if (!serviceNamesBeingLoaded.contains(serviceNameToFetch)) {\r\n                serviceNamesBeingLoaded.add(serviceNameToFetch);\r\n                executorService.submit(() -> {\r\n                    doLoadHealthServices(serviceNameToFetch);\r\n                });\r\n            }\r\n            serviceName = doneQueue.poll();\r\n        }\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.turo.pushy.apns.metrics.micrometer.MicrometerApnsClientMetricsListener.handleConnectionAdded",
	"Comment": "records that the apns server added a new connection to its internal connection pool and updates metricsaccordingly.",
	"Method": "void handleConnectionAdded(ApnsClient apnsClient){\r\n    this.openConnections.incrementAndGet();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.postClientAuth",
	"Comment": "extract the relevant username and realm information from the subject and sets the correct state in the securitycontext. the relevant information is set into the thread local storage from which then is extracted to send over thewire.",
	"Method": "void postClientAuth(Subject subject,Class<?> clazz){\r\n    final Class<?> clas = clazz;\r\n    final Subject fs = subject;\r\n    Set credset = (Set) AppservAccessController.doPrivileged(new PrivilegedAction<Set>() {\r\n        public Set run() {\r\n            if (_logger.isLoggable(Level.FINEST)) {\r\n                _logger.log(Level.FINEST, \"LCD post login subject :{0}\", fs);\r\n            }\r\n            return fs.getPrivateCredentials(clas);\r\n        }\r\n    });\r\n    final Iterator iter = credset.iterator();\r\n    while (iter.hasNext()) {\r\n        Object obj = null;\r\n        try {\r\n            obj = AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n                public java.lang.Object run() {\r\n                    return iter.next();\r\n                }\r\n            });\r\n        } catch (Exception e) {\r\n            _logger.log(Level.SEVERE, SecurityLoggerInfo.securityAccessControllerActionError, e);\r\n        }\r\n        if (obj instanceof PasswordCredential) {\r\n            PasswordCredential p = (PasswordCredential) obj;\r\n            String user = p.getUser();\r\n            if (_logger.isLoggable(Level.FINEST)) {\r\n                String realm = p.getRealm();\r\n                _logger.log(Level.FINEST, \"In LCD user-pass login:{0} realm :{1}\", new Object[] { user, realm });\r\n            }\r\n            setClientSecurityContext(user, fs);\r\n            return;\r\n        } else if (obj instanceof X509CertificateCredential) {\r\n            X509CertificateCredential p = (X509CertificateCredential) obj;\r\n            String user = p.getAlias();\r\n            if (_logger.isLoggable(Level.FINEST)) {\r\n                String realm = p.getRealm();\r\n                _logger.log(Level.FINEST, \"In LCD cert-login::{0} realm :{1}\", new Object[] { user, realm });\r\n            }\r\n            setClientSecurityContext(user, fs);\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.postClientAuth",
	"Comment": "extract the relevant username and realm information from the subject and sets the correct state in the securitycontext. the relevant information is set into the thread local storage from which then is extracted to send over thewire.",
	"Method": "void postClientAuth(Subject subject,Class<?> clazz){\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.log(Level.FINEST, \"LCD post login subject :{0}\", fs);\r\n    }\r\n    return fs.getPrivateCredentials(clas);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.postClientAuth",
	"Comment": "extract the relevant username and realm information from the subject and sets the correct state in the securitycontext. the relevant information is set into the thread local storage from which then is extracted to send over thewire.",
	"Method": "void postClientAuth(Subject subject,Class<?> clazz){\r\n    return iter.next();\r\n}"
}, {
	"Path": "ro.pippo.controller.util.ClassUtils.getAnnotation",
	"Comment": "extract the annotation from the controllermethod or the declaring class.",
	"Method": "T getAnnotation(Method method,Class<T> annotationClass,T getAnnotation,Class<?> objectClass,Class<T> annotationClass){\r\n    if (objectClass == null || Object.class == objectClass) {\r\n        return null;\r\n    }\r\n    T annotation = objectClass.getAnnotation(annotationClass);\r\n    if (annotation != null) {\r\n        return annotation;\r\n    }\r\n    return getAnnotation(objectClass.getSuperclass(), annotationClass);\r\n}"
}, {
	"Path": "com.feth.play.module.pa.providers.password.UsernamePasswordAuthUser.checkPassword",
	"Comment": "provide your own implementation of this which implements your own security.",
	"Method": "boolean checkPassword(String hashed,String candidate){\r\n    if (hashed == null || candidate == null) {\r\n        return false;\r\n    }\r\n    return BCrypt.checkpw(candidate, hashed);\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.ObjectValue.getAsObject",
	"Comment": "convenience method to get the specified member as a objectvalue.",
	"Method": "ObjectValue getAsObject(String memberName){\r\n    if (isObject(memberName)) {\r\n        return (ObjectValue) members.get(memberName);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "ro.pippo.core.route.WebjarsResourceHandler.locatePomProperties",
	"Comment": "locate all webjars maven pom.properties files on the classpath.",
	"Method": "List<String> locatePomProperties(){\r\n    List<String> propertiesFiles = new ArrayList();\r\n    List<URL> packageUrls = ClasspathUtils.getResources(getResourceBasePath());\r\n    for (URL packageUrl : packageUrls) {\r\n        if (packageUrl.getProtocol().equals(\"jar\")) {\r\n            log.debug(\"Scanning {}\", packageUrl);\r\n            try {\r\n                String jar = packageUrl.toString().substring(\"jar:\".length()).split(\"!\")[0];\r\n                File file = new File(new URI(jar));\r\n                try (JarInputStream is = new JarInputStream(new FileInputStream(file))) {\r\n                    JarEntry entry = null;\r\n                    while ((entry = is.getNextJarEntry()) != null) {\r\n                        if (!entry.isDirectory() && entry.getName().endsWith(\"pom.properties\")) {\r\n                            propertiesFiles.add(entry.getName());\r\n                        }\r\n                    }\r\n                }\r\n            } catch (URISyntaxException | IOException e) {\r\n                throw new PippoRuntimeException(\"Failed to get classes for package '{}'\", packageUrl);\r\n            }\r\n        }\r\n    }\r\n    return propertiesFiles;\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.discovery.ServiceDiscovery.registerWithIdAndTimeToLive",
	"Comment": "register an end point given an id, and a ttl.this gets used if you want to be specific about what you call the service.",
	"Method": "EndpointDefinition registerWithIdAndTimeToLive(String serviceName,String serviceId,String host,int port,int timeToLiveSeconds){\r\n    return new EndpointDefinition(HealthStatus.PASS, serviceId, serviceName, host, port, timeToLiveSeconds);\r\n}"
}, {
	"Path": "ro.pippo.core.websocket.WebSocketHandler.onTimeout",
	"Comment": "a notification that the web socket does not receive any message for the specified timeout period.",
	"Method": "void onTimeout(WebSocketContext webSocketContext){\r\n    log.debug(\"Timeout websocket connection\");\r\n}"
}, {
	"Path": "org.pf4j.DefaultPluginDescriptor.getPluginClass",
	"Comment": "returns the name of the class that implements plugin interface.",
	"Method": "String getPluginClass(){\r\n    return pluginClass;\r\n}"
}, {
	"Path": "com.feth.play.module.pa.providers.oauth2.foursquare.FoursquareAuthUser.getEmail",
	"Comment": "it is not guaranteed that an email is present for foursquare",
	"Method": "String getEmail(){\r\n    return getContactDetail(CONTACT_DETAIL_EMAIL);\r\n}"
}, {
	"Path": "io.advantageous.qbit.admin.ManagedServiceBuilder.getServiceEndpointServer",
	"Comment": "get the serviceendpointserver constructed with all of the service endpionts thatyou registered",
	"Method": "ServiceEndpointServer getServiceEndpointServer(){\r\n    final ServiceEndpointServer serviceEndpointServer = getEndpointServerBuilder().build();\r\n    if (managedServiceDefinitionList != null) {\r\n        managedServiceDefinitionList.forEach(serviceDef -> {\r\n            if (serviceDef.getAlias() == null) {\r\n                serviceEndpointServer.addServiceWithQueueCallBackHandlers(serviceDef.getServiceObject(), serviceDef.getQueueCallBackHandlers());\r\n            } else {\r\n                serviceEndpointServer.addServiceObjectWithQueueCallBackHandlers(serviceDef.getAlias(), serviceDef.getServiceObject(), serviceDef.getQueueCallBackHandlers());\r\n            }\r\n        });\r\n    }\r\n    return serviceEndpointServer;\r\n}"
}, {
	"Path": "io.advantageous.qbit.reactive.CallbackBuilder.delegate",
	"Comment": "builder method to delegate timeout and error handling to other callback.",
	"Method": "CallbackBuilder delegate(Callback<T> callback){\r\n    this.withErrorHandler(callback::onError);\r\n    this.withTimeoutHandler(callback::onTimeout);\r\n    return this;\r\n}"
}, {
	"Path": "io.nayuki.qrcodegen.QrSegment.makeNumeric",
	"Comment": "returns a segment representing the specified string of decimal digits encoded in numeric mode.",
	"Method": "QrSegment makeNumeric(String digits){\r\n    Objects.requireNonNull(digits);\r\n    if (!NUMERIC_REGEX.matcher(digits).matches())\r\n        throw new IllegalArgumentException(\"String contains non-numeric characters\");\r\n    BitBuffer bb = new BitBuffer();\r\n    for (int i = 0; i < digits.length(); ) {\r\n        int n = Math.min(digits.length() - i, 3);\r\n        bb.appendBits(Integer.parseInt(digits.substring(i, i + n)), n * 3 + 1);\r\n        i += n;\r\n    }\r\n    return new QrSegment(Mode.NUMERIC, digits.length(), bb);\r\n}"
}, {
	"Path": "org.pitest.mutationtest.engine.MutationDetails.getHtmlSafeDescription",
	"Comment": "returns the mutation description with special characters escaped",
	"Method": "String getHtmlSafeDescription(){\r\n    return StringUtil.escapeBasicHtmlChars(this.description);\r\n}"
}, {
	"Path": "com.feth.play.module.pa.providers.wwwauth.negotiate.SpnegoAuthProvider.makeAuthUser",
	"Comment": "instantiate an authuser object for a successfully authenticated request.\toverride this in a subclass if your authuser needs more information than\tjust the principal name.",
	"Method": "AuthUser makeAuthUser(GSSContext gssContext){\r\n    try {\r\n        return new SpnegoAuthUser(gssContext);\r\n    } catch (GSSException e) {\r\n        Logger.warn(\"Error creating SpnegoAuthUser\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.file.FileRealm.authenticate",
	"Comment": "authenticates a user.this method is invoked by the fileloginmodule in order to authenticate a user in the file realm. the authenticationdecision is kept within the realm class implementation in order to keep the password cache in a single location withno public accessors, to simplify future improvements.",
	"Method": "String[] authenticate(String user,char[] password){\r\n    String[] groups = fileRealmStorageManager.authenticate(user, password);\r\n    if (groups != null) {\r\n        groups = addAssignGroups(groups);\r\n    }\r\n    return groups;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.ApnsClientBuilder.setConcurrentConnections",
	"Comment": "sets the maximum number of concurrent connections the client under construction may attempt to maintain to theapns server. by default, clients will attempt to maintain a single connection to the apns server.",
	"Method": "ApnsClientBuilder setConcurrentConnections(int concurrentConnections){\r\n    this.concurrentConnections = concurrentConnections;\r\n    return this;\r\n}"
}, {
	"Path": "org.glassfish.security.services.commands.LDAPAdminAccessConfigurator.deleteRealm",
	"Comment": "delete and create a new realm to replace it in a single transaction",
	"Method": "void deleteRealm(SecurityService w_ss,StringBuilder sb){\r\n    AuthRealm oldAdminRealm = getAdminRealm(w_ss);\r\n    w_ss.getAuthRealm().remove(oldAdminRealm);\r\n    appendNL(sb, \"...\");\r\n}"
}, {
	"Path": "com.rabbitmq.client.ConnectionFactory.getNetworkRecoveryInterval",
	"Comment": "returns automatic connection recovery interval in milliseconds.",
	"Method": "long getNetworkRecoveryInterval(){\r\n    return networkRecoveryInterval;\r\n}"
}, {
	"Path": "com.feth.play.module.pa.providers.password.DefaultUsernamePasswordAuthUser.createPassword",
	"Comment": "this must be overwritten by an extending class.\tthe default implementation stores a clear string, which is not recommended.\tshould return null if the clearstring given is null.",
	"Method": "String createPassword(String clearString){\r\n    return clearString;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.metrics.micrometer.MicrometerApnsClientMetricsListener.handleNotificationSent",
	"Comment": "records a successful attempt to send a notification and updates metrics accordingly.",
	"Method": "void handleNotificationSent(ApnsClient apnsClient,long notificationId){\r\n    this.notificationStartTimes.put(notificationId, System.nanoTime());\r\n    this.sentNotifications.increment();\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.template.Hierarchy.getChild",
	"Comment": "returns the child of the template currently being evaluated or null if there is no child.",
	"Method": "PebbleTemplateImpl getChild(){\r\n    if (this.current == 0) {\r\n        return null;\r\n    }\r\n    return this.hierarchy.get(this.current - 1);\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.ConnectedUsers.getUser",
	"Comment": "get the user for the specified nickname, or null if no such user exists.",
	"Method": "User getUser(String nickname){\r\n    return users.get(nickname.toLowerCase());\r\n}"
}, {
	"Path": "de.komoot.photon.utils.ConvertToGeoJson.doBackward",
	"Comment": "extracts the place information from a geojson object and returns a list of those places. does not validate that the geojson object is valid or that the contents areindeedplaces.",
	"Method": "List<JSONObject> doBackward(JSONObject jsonObject){\r\n    JSONArray features = jsonObject.getJSONArray(\"features\");\r\n    List<JSONObject> returnValue = new ArrayList<JSONObject>(features.length());\r\n    for (int i = 0; i < features.length(); i++) {\r\n        JSONObject aSearchHit = features.getJSONObject(i);\r\n        returnValue.add(aSearchHit);\r\n    }\r\n    return returnValue;\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.CoreTagsTest.testIncludeOverridesBlocks",
	"Comment": "ensures that when including a template it is safe to have conflicting block names.",
	"Method": "void testIncludeOverridesBlocks(){\r\n    PebbleEngine pebble = new PebbleEngine.Builder().strictVariables(false).build();\r\n    PebbleTemplate template = pebble.getTemplate(\"templates/template.includeOverrideBlock.peb\");\r\n    Writer writer = new StringWriter();\r\n    template.evaluate(writer);\r\n    assertEquals(\"TWO\" + LINE_SEPARATOR + \"ONE\" + LINE_SEPARATOR + \"TWO\" + LINE_SEPARATOR, writer.toString());\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.Game.startJudging",
	"Comment": "check to see if judging should begin, based on the number of players that have played and thenumber of cards they have played.",
	"Method": "boolean startJudging(){\r\n    if (state != GameState.PLAYING) {\r\n        return false;\r\n    }\r\n    if (playedCards.size() == roundPlayers.size()) {\r\n        boolean startJudging = true;\r\n        for (final List<WhiteCard> cards : playedCards.cards()) {\r\n            if (cards.size() != blackCard.getPick()) {\r\n                startJudging = false;\r\n                break;\r\n            }\r\n        }\r\n        return startJudging;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.discovery.EndpointDefinition.serviceDefinitionWithId",
	"Comment": "creates a endpointdefinition for a service, i.e., a servicedefinition.",
	"Method": "EndpointDefinition serviceDefinitionWithId(String name,String host,String id){\r\n    return new EndpointDefinition(HealthStatus.PASS, id, name, host, 0);\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.Array.remove",
	"Comment": "removes the first occurrence of the specified value from this array, if it is present.if the array does not contain the value, it is unchanged.",
	"Method": "boolean remove(Value value,Value remove,int index){\r\n    return values.remove(index);\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.attributes.MemberCacheUtils.findMethod",
	"Comment": "finds an appropriate method by comparing if parameter types are compatible. this is morerelaxed than class.getmethod.",
	"Method": "Method findMethod(Class<?> clazz,String name,Class<?>[] requiredTypes,String filename,int lineNumber,EvaluationOptions evaluationOptions){\r\n    if (!evaluationOptions.isAllowGetClass() && name.equals(\"getClass\")) {\r\n        throw new ClassAccessException(lineNumber, filename);\r\n    }\r\n    List<Method> candidates = this.getCandidates(clazz, name, requiredTypes);\r\n    Method bestMatch = null;\r\n    for (Method candidate : candidates) {\r\n        boolean compatibleTypes = true;\r\n        Class<?>[] types = candidate.getParameterTypes();\r\n        for (int i = 0; i < types.length; i++) {\r\n            if (requiredTypes[i] != null && !this.widen(types[i]).isAssignableFrom(requiredTypes[i])) {\r\n                compatibleTypes = false;\r\n                break;\r\n            }\r\n        }\r\n        if (compatibleTypes) {\r\n            if (bestMatch == null) {\r\n                bestMatch = candidate;\r\n            } else {\r\n                Class<?>[] bestMatchParamTypes = bestMatch.getParameterTypes();\r\n                for (int i = 0; i < types.length; i++) {\r\n                    Class<?> widened = this.widen(bestMatchParamTypes[i]);\r\n                    if (widened.isAssignableFrom(types[i]) && !widened.equals(types[i])) {\r\n                        bestMatch = candidate;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (bestMatch != null) {\r\n        return bestMatch;\r\n    }\r\n    if (evaluationOptions.isGreedyMatchMethod()) {\r\n        for (Method candidate : candidates) {\r\n            boolean compatibleTypes = true;\r\n            Class<?>[] types = candidate.getParameterTypes();\r\n            for (int i = 0; i < types.length; i++) {\r\n                if (requiredTypes[i] != null && !this.isCompatibleType(types[i], requiredTypes[i])) {\r\n                    compatibleTypes = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (compatibleTypes) {\r\n                return candidate;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.pitest.process.WrappingProcess.setClassPathInEnvironment",
	"Comment": "line increases the allowable size of the classpath, but this has not been confirmed",
	"Method": "void setClassPathInEnvironment(ProcessBuilder processBuilder){\r\n    if (!processArgs.useClasspathJar()) {\r\n        processBuilder.environment().put(\"CLASSPATH\", this.processArgs.getLaunchClassPath());\r\n    }\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.CompilerTest.testCompilationMutexIsAlwaysReleased",
	"Comment": "there was an issue where one failed template would prevent future templates from beingcompiled.",
	"Method": "void testCompilationMutexIsAlwaysReleased(){\r\n    PebbleEngine pebble = new PebbleEngine.Builder().strictVariables(false).build();\r\n    try {\r\n        pebble.getTemplate(\"non-existing\");\r\n    } catch (Exception e) {\r\n    }\r\n    PebbleTemplate template = pebble.getTemplate(\"templates/template.general.peb\");\r\n    Writer writer = new StringWriter();\r\n    template.evaluate(writer);\r\n    assertEquals(\"test\", writer.toString());\r\n}"
}, {
	"Path": "ro.pippo.core.PippoSettings.getLong",
	"Comment": "returns the long value for the specified name. if the name does notexist or the value for the name can not be interpreted as an long, thedefaultvalue is returned.",
	"Method": "long getLong(String name,long defaultValue){\r\n    try {\r\n        String value = getString(name, null);\r\n        if (!StringUtils.isNullOrEmpty(value)) {\r\n            return Long.parseLong(value.trim());\r\n        }\r\n    } catch (NumberFormatException e) {\r\n        log.warn(\"Failed to parse long for \" + name + USING_DEFAULT_OF + defaultValue);\r\n    }\r\n    return defaultValue;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.JarSigner.getExistingSignatureFile",
	"Comment": "if jar is signed, return existing signature file, else return null.",
	"Method": "byte[] getExistingSignatureFile(JarFile jf){\r\n    Enumeration<JarEntry> entries = jf.entries();\r\n    JarEntry je = null;\r\n    while (entries.hasMoreElements()) {\r\n        JarEntry cje = entries.nextElement();\r\n        if (cje.getName().startsWith(\"META-INF/\") && cje.getName().endsWith(\".SF\")) {\r\n            je = cje;\r\n            break;\r\n        }\r\n    }\r\n    return readJarEntry(jf, je);\r\n}"
}, {
	"Path": "org.pitest.mutationtest.engine.MutationDetails.getLocation",
	"Comment": "returns the method name in which this mutation is located as a string",
	"Method": "String getLocation(){\r\n    return this.id.getLocation().describe();\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.DataContext.createChild",
	"Comment": "a utility method to create a child data context, with its own scope and index from the dataof this data context.",
	"Method": "DataContext createChild(ProteusContext context,Map<String, Value> scope,int dataIndex){\r\n    return create(context, data, dataIndex, scope);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.Realm.init",
	"Comment": "initialize a realm with some properties. this can be used when instantiating realms from theirdescriptions. this method may only be called a single time.",
	"Method": "void init(Properties props){\r\n    String groupList = props.getProperty(PARAM_GROUPS);\r\n    if (groupList != null && groupList.length() > 0) {\r\n        this.setProperty(PARAM_GROUPS, groupList);\r\n        assignGroups = new ArrayList<String>();\r\n        StringTokenizer st = new StringTokenizer(groupList, GROUPS_SEP);\r\n        while (st.hasMoreTokens()) {\r\n            String grp = st.nextToken();\r\n            if (!assignGroups.contains(grp)) {\r\n                assignGroups.add(grp);\r\n            }\r\n        }\r\n    }\r\n    String groupMapping = props.getProperty(PARAM_GROUP_MAPPING);\r\n    if (groupMapping != null) {\r\n        groupMapper = new GroupMapper();\r\n        groupMapper.parse(groupMapping);\r\n    }\r\n    String defaultDigestAlgo = null;\r\n    if (_getRealmsManager() != null) {\r\n        defaultDigestAlgo = _getRealmsManager().getDefaultDigestAlgorithm();\r\n    }\r\n    this.defaultDigestAlgorithm = (defaultDigestAlgo == null) ? DEFAULT_DEF_DIG_ALGO_VAL : defaultDigestAlgo;\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.createJsonSendQueue",
	"Comment": "helper method to create sendqueue wrappers that do json encoding.",
	"Method": "SendQueue<T> createJsonSendQueue(SendQueue<String> sendQueue){\r\n    return new SendQueue<T>() {\r\n        @Override\r\n        public boolean send(T item) {\r\n            sendQueue.send(toJsonFunction.apply(item));\r\n            return false;\r\n        }\r\n        @Override\r\n        public void sendAndFlush(T item) {\r\n            sendQueue.sendAndFlush(toJsonFunction.apply(item));\r\n        }\r\n        @Override\r\n        public void sendMany(T... items) {\r\n            for (T item : items) {\r\n                sendQueue.send(toJsonFunction.apply(item));\r\n            }\r\n        }\r\n        @Override\r\n        public void sendBatch(Collection<T> items) {\r\n            for (T item : items) {\r\n                sendQueue.send(toJsonFunction.apply(item));\r\n            }\r\n        }\r\n        @Override\r\n        public void sendBatch(Iterable<T> items) {\r\n            for (T item : items) {\r\n                sendQueue.send(toJsonFunction.apply(item));\r\n            }\r\n        }\r\n        @Override\r\n        public boolean shouldBatch() {\r\n            return sendQueue.shouldBatch();\r\n        }\r\n        @Override\r\n        public void flushSends() {\r\n            sendQueue.flushSends();\r\n        }\r\n        @Override\r\n        public int size() {\r\n            return sendQueue.size();\r\n        }\r\n        @Override\r\n        public String name() {\r\n            return sendQueue.name();\r\n        }\r\n        @Override\r\n        public void stop() {\r\n            sendQueue.stop();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.createJsonSendQueue",
	"Comment": "helper method to create sendqueue wrappers that do json encoding.",
	"Method": "SendQueue<T> createJsonSendQueue(SendQueue<String> sendQueue){\r\n    sendQueue.send(toJsonFunction.apply(item));\r\n    return false;\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.createJsonSendQueue",
	"Comment": "helper method to create sendqueue wrappers that do json encoding.",
	"Method": "SendQueue<T> createJsonSendQueue(SendQueue<String> sendQueue){\r\n    sendQueue.sendAndFlush(toJsonFunction.apply(item));\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.createJsonSendQueue",
	"Comment": "helper method to create sendqueue wrappers that do json encoding.",
	"Method": "SendQueue<T> createJsonSendQueue(SendQueue<String> sendQueue){\r\n    for (T item : items) {\r\n        sendQueue.send(toJsonFunction.apply(item));\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.createJsonSendQueue",
	"Comment": "helper method to create sendqueue wrappers that do json encoding.",
	"Method": "SendQueue<T> createJsonSendQueue(SendQueue<String> sendQueue){\r\n    for (T item : items) {\r\n        sendQueue.send(toJsonFunction.apply(item));\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.createJsonSendQueue",
	"Comment": "helper method to create sendqueue wrappers that do json encoding.",
	"Method": "SendQueue<T> createJsonSendQueue(SendQueue<String> sendQueue){\r\n    for (T item : items) {\r\n        sendQueue.send(toJsonFunction.apply(item));\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.createJsonSendQueue",
	"Comment": "helper method to create sendqueue wrappers that do json encoding.",
	"Method": "SendQueue<T> createJsonSendQueue(SendQueue<String> sendQueue){\r\n    return sendQueue.shouldBatch();\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.createJsonSendQueue",
	"Comment": "helper method to create sendqueue wrappers that do json encoding.",
	"Method": "SendQueue<T> createJsonSendQueue(SendQueue<String> sendQueue){\r\n    sendQueue.flushSends();\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.createJsonSendQueue",
	"Comment": "helper method to create sendqueue wrappers that do json encoding.",
	"Method": "SendQueue<T> createJsonSendQueue(SendQueue<String> sendQueue){\r\n    return sendQueue.size();\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.createJsonSendQueue",
	"Comment": "helper method to create sendqueue wrappers that do json encoding.",
	"Method": "SendQueue<T> createJsonSendQueue(SendQueue<String> sendQueue){\r\n    return sendQueue.name();\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.createJsonSendQueue",
	"Comment": "helper method to create sendqueue wrappers that do json encoding.",
	"Method": "SendQueue<T> createJsonSendQueue(SendQueue<String> sendQueue){\r\n    sendQueue.stop();\r\n}"
}, {
	"Path": "ro.pippo.core.Request.getUrl",
	"Comment": "returns the url with the protocol, application path, & resource path. thequery string is omitted.",
	"Method": "String getUrl(){\r\n    return httpServletRequest.getRequestURL().toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.ldap.LDAPRealm.getGroupNames",
	"Comment": "returns the name of all the groups that this user belongs to. note that this information is only known after the userhas logged in. this is called from web path role verification, though it should not be.",
	"Method": "Enumeration getGroupNames(String username){\r\n    List<String> cachedGroups = groupCache.get(username);\r\n    if (cachedGroups == null) {\r\n        List<String> searchedGrps = getGroups(username);\r\n        if (searchedGrps != null) {\r\n            return Collections.enumeration(searchedGrps);\r\n        }\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"No groups available for: \" + username);\r\n        }\r\n        return Collections.emptyEnumeration();\r\n    } else {\r\n        if (groupMapper != null) {\r\n            List<String> result = new LinkedList(cachedGroups);\r\n            for (String grp : cachedGroups) {\r\n                result.addAll(this.getMappedGroupNames(grp));\r\n            }\r\n            return Collections.enumeration(result);\r\n        } else {\r\n            return Collections.enumeration(cachedGroups);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ro.pippo.core.Request.getUri",
	"Comment": "returns the container uri with the application path & resource path. theprotocol and query string are omitted.",
	"Method": "String getUri(){\r\n    return httpServletRequest.getRequestURI();\r\n}"
}, {
	"Path": "de.komoot.photon.utils.ConvertToGeoJson.doForward",
	"Comment": "converts a list of places to a geojson places. does not validate the list of places. in other words, if json list does not contain valid places, then resulting geojsonwill not be valid.",
	"Method": "JSONObject doForward(List<JSONObject> listOfPlaces){\r\n    final JSONObject collection = new JSONObject();\r\n    collection.put(\"type\", \"FeatureCollection\");\r\n    collection.put(\"features\", new JSONArray(listOfPlaces));\r\n    return collection;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.metrics.dropwizard.DropwizardApnsClientMetricsListener.handleConnectionRemoved",
	"Comment": "records that the apns server removed a connection from its internal connection pool and updates metricsaccordingly.",
	"Method": "void handleConnectionRemoved(ApnsClient apnsClient){\r\n    this.openConnections.decrementAndGet();\r\n}"
}, {
	"Path": "ro.pippo.session.spymemcached.SpymemcachedSessionDataStorageTest.testDelete",
	"Comment": "test of delete method, of class spymemcachedsessiondatastorage.",
	"Method": "void testDelete(){\r\n    System.out.println(\"delete\");\r\n    SpymemcachedSessionDataStorage instance = new SpymemcachedSessionDataStorage(client, IDLE_TIME);\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    instance.delete(sessionId);\r\n    SessionData deleted = instance.get(sessionId);\r\n    assertNull(deleted);\r\n}"
}, {
	"Path": "io.advantageous.qbit.boon.spi.BoonJsonMapper.fromJsonMap",
	"Comment": "converts from a json string using componentclasskey and componentclassvalue as a guide to a map.",
	"Method": "Map<K, V> fromJsonMap(String json,Class<K> componentClassKey,Class<V> componentClassValue){\r\n    Map map = (Map) parser.get().parse(json);\r\n    final Mapper mapper = this.mapper.get();\r\n    return extractMap(componentClassKey, componentClassValue, map, mapper);\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.CoreTagsTest.multipleForLoops",
	"Comment": "there were compilation issues when having two for loops in the same template due to the samevariable name being declared twice.",
	"Method": "void multipleForLoops(){\r\n    PebbleEngine pebble = new PebbleEngine.Builder().loader(new StringLoader()).strictVariables(false).build();\r\n    String source = \"\" + \"{% for user in users %}{{ user.username }}{% endfor %}\" + \"{% for user in users %}{{ user.username }}{% endfor %}\";\r\n    PebbleTemplate template = pebble.getTemplate(source);\r\n    Map<String, Object> context = new HashMap();\r\n    List<User> users = new ArrayList();\r\n    users.add(new User(\"Alex\"));\r\n    users.add(new User(\"Bob\"));\r\n    context.put(\"users\", users);\r\n    Writer writer = new StringWriter();\r\n    template.evaluate(writer, context);\r\n    assertEquals(\"AlexBobAlexBob\", writer.toString());\r\n}"
}, {
	"Path": "com.rabbitmq.client.impl.AMQChannel.wrapTimeoutException",
	"Comment": "cleans rpc channel state after a timeout and wraps the timeoutexception in a channelcontinuationtimeoutexception",
	"Method": "ChannelContinuationTimeoutException wrapTimeoutException(Method m,TimeoutException e){\r\n    cleanRpcChannelState();\r\n    return new ChannelContinuationTimeoutException(e, this, this._channelNumber, m);\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.lexer.LexerImpl.pushState",
	"Comment": "pushes the current state onto the stack and then updates the current state to the new state.",
	"Method": "void pushState(State state){\r\n    this.states.push(this.state);\r\n    this.state = state;\r\n}"
}, {
	"Path": "io.advantageous.qbit.proxy.ProxyServiceImpl.checkClient",
	"Comment": "checks client health periodically to see if we are connected. tries to reconnect if not connected.",
	"Method": "void checkClient(){\r\n    try {\r\n        if (errorCount.get() > 0) {\r\n            errorCount.set(0);\r\n            if (backendServiceHttpClient == null || backendServiceHttpClient.isClosed()) {\r\n                if (backendServiceHttpClient != null) {\r\n                    try {\r\n                        backendServiceHttpClient.stop();\r\n                    } catch (Exception ex) {\r\n                        logger.debug(\"Was unable to stop the client connection\", ex);\r\n                    }\r\n                }\r\n                backendServiceHttpClient = httpClientBuilder.buildAndStart();\r\n                lastHttpClientStart = time;\r\n            }\r\n        }\r\n        if (pingBuilder.isPresent()) {\r\n            if (backendServiceHttpClient != null) {\r\n                pingBuilder.get().setBinaryReceiver((code, contentType, body) -> {\r\n                    if (code >= 200 && code < 299) {\r\n                        pingCount.incrementAndGet();\r\n                    } else {\r\n                        errorCount.incrementAndGet();\r\n                    }\r\n                }).setErrorHandler(e -> {\r\n                    logger.error(\"Error doing ping operation\", e);\r\n                    errorCount.incrementAndGet();\r\n                });\r\n                final HttpRequest httpRequest = pingBuilder.get().build();\r\n                backendServiceHttpClient.sendHttpRequest(httpRequest);\r\n            }\r\n        }\r\n    } catch (Exception ex) {\r\n        errorHandler.accept(ex);\r\n        logger.error(\"Unable to check connection\");\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.AuthenticationServiceImpl.getLoginModuleControlFlag",
	"Comment": "convert the string setting to the jaas loginmodulecontrolflag.\tan unknown or null flag value is treated as loginmodulecontrolflag.required.",
	"Method": "LoginModuleControlFlag getLoginModuleControlFlag(String controlFlag){\r\n    LoginModuleControlFlag flag = LoginModuleControlFlag.REQUIRED;\r\n    if (controlFlag != null) {\r\n        if (\"required\".equalsIgnoreCase(controlFlag))\r\n            return flag;\r\n        if (\"sufficient\".equalsIgnoreCase(controlFlag))\r\n            flag = LoginModuleControlFlag.SUFFICIENT;\r\n        else if (\"optional\".equalsIgnoreCase(controlFlag))\r\n            flag = LoginModuleControlFlag.OPTIONAL;\r\n        else if (\"requisite\".equalsIgnoreCase(controlFlag))\r\n            flag = LoginModuleControlFlag.REQUISITE;\r\n    }\r\n    return flag;\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.template.ScopeChain.currentScopeContainsVariable",
	"Comment": "checks if the current scope contains a variable without then looking up the scope chain.",
	"Method": "boolean currentScopeContainsVariable(String variableName){\r\n    return this.stack.getFirst().containsKey(variableName);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginCallbackHandler.getCancelStatus",
	"Comment": "check whether the authentication was cancelled by the user.",
	"Method": "boolean getCancelStatus(){\r\n    boolean cancelled = cancelStatus.get();\r\n    cancelStatus.set(false);\r\n    return cancelled;\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.health.HealthServiceClient.ok",
	"Comment": "checks to see if all services registered with the health system are ok.",
	"Method": "Promise<Boolean> ok(){\r\n    return Promises.invokablePromise(callback -> callback.resolve(true));\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.removeAllAttributeResolvers",
	"Comment": "removes all attributeresolver instances from the currentinternal list of attributeresolver instances.",
	"Method": "boolean removeAllAttributeResolvers(){\r\n    synchronized (attributeResolvers) {\r\n        if (attributeResolvers.isEmpty()) {\r\n            return false;\r\n        } else {\r\n            attributeResolvers.clear();\r\n            return true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.WebAndEjbToJaasBridge.doX500Login",
	"Comment": "a special case login for x500name credentials. this is invoked for certificate login because thecontainers extract the x.500 name from the x.509 certificate before calling into this class.",
	"Method": "void doX500Login(Subject subject,String appModuleID){\r\n    _logger.fine(\"Processing X.500 name login.\");\r\n    String user = null;\r\n    String realmName = null;\r\n    try {\r\n        X500Principal x500principal = getPublicCredentials(subject, X500Principal.class);\r\n        user = x500principal.getName();\r\n        Realm realm = Realm.getInstance(CertificateRealm.AUTH_TYPE);\r\n        if (realm instanceof CertificateRealm) {\r\n            CertificateRealm certRealm = (CertificateRealm) realm;\r\n            String jaasCtx = certRealm.getJAASContext();\r\n            if (jaasCtx != null) {\r\n                LoginContext lg = new LoginContext(jaasCtx, subject, new ServerLoginCallbackHandler(user, null, appModuleID));\r\n                lg.login();\r\n            }\r\n            certRealm.authenticate(subject, x500principal);\r\n            realmName = CertificateRealm.AUTH_TYPE;\r\n            auditAuthenticate(user, realmName, true);\r\n        } else {\r\n            _logger.warning(certLoginBadRealmError);\r\n            realmName = realm.getName();\r\n            setSecurityContext(user, subject, realmName);\r\n        }\r\n        if (_logger.isLoggable(FINE)) {\r\n            _logger.fine(\"X.500 name login succeeded for : \" + user);\r\n        }\r\n    } catch (LoginException le) {\r\n        auditAuthenticate(user, realmName, false);\r\n        throw le;\r\n    } catch (Exception ex) {\r\n        throw (LoginException) new LoginException(ex.toString()).initCause(ex);\r\n    }\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.Value.getAsCharacter",
	"Comment": "convenience method to get this value as a primitive character value.",
	"Method": "char getAsCharacter(){\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}"
}, {
	"Path": "io.nayuki.qrcodegen.QrCodeGeneratorDemo.doVarietyDemo",
	"Comment": "creates a variety of qr codes that exercise different features of the library, and writes each one to file.",
	"Method": "void doVarietyDemo(){\r\n    QrCode qr;\r\n    qr = QrCode.encodeText(\"314159265358979323846264338327950288419716939937510\", QrCode.Ecc.MEDIUM);\r\n    writePng(qr.toImage(13, 1), \"pi-digits-QR.png\");\r\n    qr = QrCode.encodeText(\"DOLLAR-AMOUNT:$39.87 PERCENTAGE:100.00% OPERATIONS:+-*/\", QrCode.Ecc.HIGH);\r\n    writePng(qr.toImage(10, 2), \"alphanumeric-QR.png\");\r\n    qr = QrCode.encodeText(\"こんにちwa、世界！ αβγδ\", QrCode.Ecc.QUARTILE);\r\n    writePng(qr.toImage(10, 3), \"unicode-QR.png\");\r\n    qr = QrCode.encodeText(\"Alice was beginning to get very tired of sitting by her sister on the bank, \" + \"and of having nothing to do: once or twice she had peeped into the book her sister was reading, \" + \"but it had no pictures or conversations in it, 'and what is the use of a book,' thought Alice \" + \"'without pictures or conversations?' So she was considering in her own mind (as well as she could, \" + \"for the hot day made her feel very sleepy and stupid), whether the pleasure of making a \" + \"daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly \" + \"a White Rabbit with pink eyes ran close by her.\", QrCode.Ecc.HIGH);\r\n    writePng(qr.toImage(6, 10), \"alice-wonderland-QR.png\");\r\n}"
}, {
	"Path": "com.sun.enterprise.security.admin.cli.SecureAdminHelperImpl.isAnyAdminUserWithoutPassword",
	"Comment": "returns whether at least one admin user has an empty password.",
	"Method": "boolean isAnyAdminUserWithoutPassword(){\r\n    final FileRealm adminRealm = adminRealm();\r\n    if (adminRealm == null) {\r\n        return false;\r\n    }\r\n    for (final Enumeration<String> e = adminRealm.getUserNames(); e.hasMoreElements(); ) {\r\n        final String username = e.nextElement();\r\n        final String[] groupNames = adminRealm.authenticate(username, emptyPassword);\r\n        if (groupNames != null) {\r\n            for (String groupName : groupNames) {\r\n                if (DOMAIN_ADMIN_GROUP_NAME.equals(groupName)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.doClientLogin",
	"Comment": "perform login on the client side. it just simulates the login on the client side. the method uses the callbackhandlers and generates correct credential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,CallbackHandler jaasHandler){\r\n    final CallbackHandler handler = jaasHandler;\r\n    final Subject subject = new Subject();\r\n    if (type == SecurityConstants.USERNAME_PASSWORD) {\r\n        AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n            public java.lang.Object run() {\r\n                try {\r\n                    LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n                    lg.login();\r\n                } catch (javax.security.auth.login.LoginException e) {\r\n                    throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        postClientAuth(subject, PasswordCredential.class);\r\n        return subject;\r\n    } else if (type == SecurityConstants.CERTIFICATE) {\r\n        AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n            public java.lang.Object run() {\r\n                try {\r\n                    LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_CERTIFICATE, subject, handler);\r\n                    lg.login();\r\n                } catch (javax.security.auth.login.LoginException e) {\r\n                    throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        postClientAuth(subject, X509CertificateCredential.class);\r\n        return subject;\r\n    } else if (type == SecurityConstants.ALL) {\r\n        AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n            public java.lang.Object run() {\r\n                try {\r\n                    LoginContext lgup = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n                    LoginContext lgc = new LoginContext(SecurityConstants.CLIENT_JAAS_CERTIFICATE, subject, handler);\r\n                    lgup.login();\r\n                    postClientAuth(subject, PasswordCredential.class);\r\n                    lgc.login();\r\n                    postClientAuth(subject, X509CertificateCredential.class);\r\n                } catch (javax.security.auth.login.LoginException e) {\r\n                    throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        return subject;\r\n    } else {\r\n        AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n            public java.lang.Object run() {\r\n                try {\r\n                    LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n                    lg.login();\r\n                    postClientAuth(subject, PasswordCredential.class);\r\n                } catch (javax.security.auth.login.LoginException e) {\r\n                    throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        return subject;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.doClientLogin",
	"Comment": "perform login on the client side. it just simulates the login on the client side. the method uses the callbackhandlers and generates correct credential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,CallbackHandler jaasHandler){\r\n    try {\r\n        LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n        lg.login();\r\n    } catch (javax.security.auth.login.LoginException e) {\r\n        throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.doClientLogin",
	"Comment": "perform login on the client side. it just simulates the login on the client side. the method uses the callbackhandlers and generates correct credential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,CallbackHandler jaasHandler){\r\n    try {\r\n        LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_CERTIFICATE, subject, handler);\r\n        lg.login();\r\n    } catch (javax.security.auth.login.LoginException e) {\r\n        throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.doClientLogin",
	"Comment": "perform login on the client side. it just simulates the login on the client side. the method uses the callbackhandlers and generates correct credential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,CallbackHandler jaasHandler){\r\n    try {\r\n        LoginContext lgup = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n        LoginContext lgc = new LoginContext(SecurityConstants.CLIENT_JAAS_CERTIFICATE, subject, handler);\r\n        lgup.login();\r\n        postClientAuth(subject, PasswordCredential.class);\r\n        lgc.login();\r\n        postClientAuth(subject, X509CertificateCredential.class);\r\n    } catch (javax.security.auth.login.LoginException e) {\r\n        throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.doClientLogin",
	"Comment": "perform login on the client side. it just simulates the login on the client side. the method uses the callbackhandlers and generates correct credential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,CallbackHandler jaasHandler){\r\n    try {\r\n        LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n        lg.login();\r\n        postClientAuth(subject, PasswordCredential.class);\r\n    } catch (javax.security.auth.login.LoginException e) {\r\n        throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "ro.pippo.groovy.PippoGroovyTemplate.layout",
	"Comment": "imports a template and renders it using the specified model, allowingfine grained composition of templates and layouting. this workssimilarily to a template include but allows a distinct model to be used.if the layout inherits from the parent model, a new model is created,with the values from the parent model, eventually overriden with thoseprovided specifically for this layout.",
	"Method": "Object layout(Map model,String templateName,boolean inheritModel){\r\n    Map submodel = inheritModel ? forkModel(model) : model;\r\n    URL resource = engine.resolveTemplate(templateName);\r\n    PippoGroovyTemplate template = (PippoGroovyTemplate) engine.createTypeCheckedModelTemplate(resource, modelTypes).make(submodel);\r\n    template.setup(languages, messages, router);\r\n    template.writeTo(getOut());\r\n    return this;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.util.SimpleApnsPushNotification.getApnsId",
	"Comment": "returns the canonical identifier for this push notification. the apns server will include the given identifier inall responses related to this push notification. if no identifier is provided, the server will assign a uniqueidentifier automatically.",
	"Method": "UUID getApnsId(){\r\n    return this.apnsId;\r\n}"
}, {
	"Path": "ro.pippo.core.AbstractTemplateEngine.getFileExtension",
	"Comment": "returns the configured file extension for template resources.",
	"Method": "String getFileExtension(){\r\n    return fileExtension;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.metrics.micrometer.MicrometerApnsClientMetricsListener.handleWriteFailure",
	"Comment": "records a failed attempt to send a notification and updates metrics accordingly.",
	"Method": "void handleWriteFailure(ApnsClient apnsClient,long notificationId){\r\n    this.notificationStartTimes.remove(notificationId);\r\n    this.writeFailures.increment();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.BaseRealm.getUserNames",
	"Comment": "returns names of all the users in this particular realm.this method always throws a badrealmexception since by default this operation is not supported. subclasses whichsupport this method can override.",
	"Method": "Enumeration<String> getUserNames(){\r\n    throw new BadRealmException(sm.getString(\"iasrealm.notsupported\"));\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.UpdateFileUser.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names and thevalues the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    String fileRealmClassName = fileAuthRealm.getClassname();\r\n    if (fileRealmClassName != null && !fileRealmClassName.equals(\"com.sun.enterprise.security.auth.realm.file.FileRealm\")) {\r\n        report.setMessage(localStrings.getLocalString(\"update.file.user.realmnotsupported\", \"Configured file realm {0} is not supported.\", fileRealmClassName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String keyFile = null;\r\n    for (Property fileProp : fileAuthRealm.getProperty()) {\r\n        if (fileProp.getName().equals(\"file\"))\r\n            keyFile = fileProp.getValue();\r\n    }\r\n    if (keyFile == null) {\r\n        report.setMessage(localStrings.getLocalString(\"update.file.user.keyfilenotfound\", \"There is no physical file associated with file realm {0}\", authRealmName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    boolean exists = (new File(keyFile)).exists();\r\n    if (!exists) {\r\n        report.setMessage(localStrings.getLocalString(\"file.realm.keyfilenonexistent\", \"The specified physical file {0} associated with the file realm {1} does not exist.\", new Object[] { keyFile, authRealmName }));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String password = userpassword;\r\n    if (password == null && groups == null) {\r\n        report.setMessage(localStrings.getLocalString(\"update.file.user.keyfilenotreadable\", \"None of password or groups have been specified for update,\" + \"Password for user {0} has to be specified\" + \"through AS_ADMIN_USERPASSWORD property in the file specified \" + \"in --passwordfile option\", userName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (password != null) {\r\n        secureAdmin = domain.getSecureAdmin();\r\n        if ((SecureAdmin.Util.isEnabled(secureAdmin)) && (adminService.getAuthRealmName().equals(authRealmName))) {\r\n            if ((password.isEmpty())) {\r\n                report.setMessage(localStrings.getLocalString(\"null_empty_password\", \"The admin user password is empty\"));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    FileRealm fileRealm = null;\r\n    try {\r\n        realmsManager.createRealms(config);\r\n        fileRealm = (FileRealm) realmsManager.getFromLoadedRealms(config.getName(), authRealmName);\r\n        if (fileRealm == null) {\r\n            throw new NoSuchRealmException(authRealmName);\r\n        }\r\n    } catch (NoSuchRealmException e) {\r\n        report.setMessage(localStrings.getLocalString(\"update.file.user.realmnotsupported\", \"Configured file realm {0} does not exist.\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    try {\r\n        CreateFileUser.handleAdminGroup(authRealmName, groups);\r\n        String[] groups1 = (groups == null) ? null : groups.toArray(new String[groups.size()]);\r\n        fileRealm.updateUser(userName, userName, password, groups1);\r\n        fileRealm.persist();\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"update.file.user.userupdatefailed\", \"Updating user {0} in file realm {1} failed\", userName, authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "net.socialgamer.cah.metrics.KafkaMetrics.trace",
	"Comment": "helper method to log at trace level while only taking string format penalties if such loggingis enabled. includes the method name as well.",
	"Method": "void trace(String format,Object params){\r\n    if (LOG.isTraceEnabled()) {\r\n        final StackTraceElement[] stack = Thread.currentThread().getStackTrace();\r\n        final String message = String.format(format, params);\r\n        LOG.trace(String.format(\"%s: %s\", stack[2].getMethodName(), message));\r\n    }\r\n}"
}, {
	"Path": "ro.pippo.core.Application.getRuntimeMode",
	"Comment": "the runtime mode. must currently be either dev, test, or prod.",
	"Method": "RuntimeMode getRuntimeMode(){\r\n    return pippoSettings.getRuntimeMode();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.solaris.SolarisRealm.setGroupNames",
	"Comment": "set group membership info for a user.see bugs 4646133,4646270 on why this is here.",
	"Method": "void setGroupNames(String username,String[] groups){\r\n    Vector v = null;\r\n    if (groups == null) {\r\n        v = emptyVector;\r\n    } else {\r\n        v = new Vector(groups.length + 1);\r\n        for (int i = 0; i < groups.length; i++) {\r\n            v.add(groups[i]);\r\n        }\r\n    }\r\n    synchronized (this) {\r\n        groupCache.put(username, v);\r\n    }\r\n}"
}, {
	"Path": "ro.pippo.core.util.ClasspathUtils.hasClass",
	"Comment": "returns true if the specified class can be found on the classpath.",
	"Method": "boolean hasClass(String className){\r\n    try {\r\n        Class.forName(className);\r\n        return true;\r\n    } catch (Exception e) {\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "ro.pippo.controller.ControllerHandler.canConsume",
	"Comment": "determines if the incoming request is sending content this route understands.",
	"Method": "boolean canConsume(RouteContext routeContext){\r\n    Set<String> contentTypes = getContentTypes(routeContext.getRequest());\r\n    if (!declaredConsumes.isEmpty()) {\r\n        if (declaredConsumes.contains(Consumes.ALL)) {\r\n            log.debug(\"{} will handle Request because it consumes '{}'\", LangUtils.toString(controllerMethod), Consumes.ALL);\r\n            return true;\r\n        }\r\n        Set<String> types = new LinkedHashSet(contentTypes);\r\n        if (types.isEmpty()) {\r\n            types.addAll(getAcceptTypes(routeContext.getRequest()));\r\n            if (types.contains(\"*\") || types.contains(\"*/*\")) {\r\n                log.debug(\"{} will handle Request because it consumes '{}'\", LangUtils.toString(controllerMethod), \"*/*\");\r\n                return true;\r\n            }\r\n        }\r\n        for (String type : types) {\r\n            if (declaredConsumes.contains(type)) {\r\n                log.debug(\"{} will handle Request because it consumes '{}'\", LangUtils.toString(controllerMethod), type);\r\n                return true;\r\n            } else {\r\n                for (String declaredType : declaredConsumes) {\r\n                    int fuzz = declaredType.indexOf('*');\r\n                    if (fuzz > -1) {\r\n                        String fuzzyType = declaredType.substring(0, fuzz);\r\n                        if (type.startsWith(fuzzyType)) {\r\n                            log.debug(\"{} will handle Request because it consumes '{}'\", LangUtils.toString(controllerMethod), type);\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (types.isEmpty()) {\r\n            log.warn(\"{} can not handle Request because neither 'Accept' nor 'Content-Type' are set and Route @Consumes '{}'\", LangUtils.toString(controllerMethod), declaredConsumes);\r\n        } else {\r\n            log.warn(\"{} can not handle Request for '{}' because Route @Consumes '{}'\", LangUtils.toString(controllerMethod), types, declaredConsumes);\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.BaseService.recordLevel",
	"Comment": "prefixes the stats key with the stat key prefix, and then calls statscollector.recordlevel.",
	"Method": "void recordLevel(String statKey,long level){\r\n    final String longKey = getActualStatKey(statKey);\r\n    statsCollector.recordLevel(longKey, level);\r\n}"
}, {
	"Path": "com.turo.pushy.apns.metrics.dropwizard.DropwizardApnsClientMetricsListener.handleNotificationSent",
	"Comment": "records a successful attempt to send a notification and updates metrics accordingly.",
	"Method": "void handleNotificationSent(ApnsClient apnsClient,long notificationId){\r\n    this.sentNotifications.mark();\r\n    this.notificationTimerContexts.put(notificationId, this.notificationTimer.time());\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.ServiceBundle.addServiceObjectWithQueueCallBackHandlers",
	"Comment": "add a service to the bundle with an address and one or more queue callback handlers.",
	"Method": "ServiceBundle addServiceObjectWithQueueCallBackHandlers(String address,Object serviceObject,QueueCallBackHandler queueCallBackHandlers){\r\n    throw new IllegalStateException(\"Not implemented\");\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.solaris.SolarisRealm.getGroupNames",
	"Comment": "returns the name of all the groups that this user belongs to. this is called from web path roleverification, though it should not be.",
	"Method": "Enumeration getGroupNames(String username){\r\n    Vector v = (Vector) groupCache.get(username);\r\n    if (v == null) {\r\n        v = loadGroupNames(username);\r\n    }\r\n    return v.elements();\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.GameManager.broadcastGameListRefresh",
	"Comment": "broadcast an event to all users that they should refresh the game list.",
	"Method": "void broadcastGameListRefresh(){\r\n    broadcastUpdate.needsUpdate();\r\n}"
}, {
	"Path": "psiprobe.ProbeSecurityConfig.getJ2eeBasedPreAuthenticatedWebAuthenticationDetailsSource",
	"Comment": "gets the j 2 ee based pre authenticated web authentication details source.",
	"Method": "J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource getJ2eeBasedPreAuthenticatedWebAuthenticationDetailsSource(){\r\n    J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource source = new J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource();\r\n    source.setMappableRolesRetriever(getWebXmlMappableAttributesRetriever());\r\n    source.setUserRoles2GrantedAuthoritiesMapper(getSimpleAttributes2GrantedAuthoritiesMapper());\r\n    return source;\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.discovery.ServiceDiscovery.uniqueString",
	"Comment": "generates a unique string, used for generating unique service ids",
	"Method": "String uniqueString(int port){\r\n    try {\r\n        return port + \"-\" + InetAddress.getLocalHost().getHostName().replace('.', '-');\r\n    } catch (UnknownHostException e) {\r\n        return port + \"-\" + UUID.randomUUID().toString();\r\n    }\r\n}"
}, {
	"Path": "com.rabbitmq.client.Envelope.getExchange",
	"Comment": "get the name of the exchange included in this parameter envelope",
	"Method": "String getExchange(){\r\n    return _exchange;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.file.FileRealm.getRealmFileNames",
	"Comment": "return a list of the file names used by all file realms defined for the specified config.",
	"Method": "List<String> getRealmFileNames(Config config){\r\n    List<String> files = new ArrayList<String>();\r\n    SecurityService securityService = config.getSecurityService();\r\n    for (AuthRealm authRealm : securityService.getAuthRealm()) {\r\n        String fileRealmClassName = authRealm.getClassname();\r\n        if (fileRealmClassName == null || !fileRealmClassName.equals(FileRealm.class.getName())) {\r\n            continue;\r\n        }\r\n        String file = authRealm.getPropertyValue(\"file\");\r\n        if (file == null) {\r\n            continue;\r\n        }\r\n        if (file.contains(\"$\")) {\r\n            file = RelativePathResolver.resolvePath(file);\r\n        }\r\n        files.add(file);\r\n    }\r\n    return files;\r\n}"
}, {
	"Path": "ro.pippo.core.Response.resource",
	"Comment": "copies the input stream to the response output stream and closes the input stream upon completion.this method commits the response.",
	"Method": "void resource(InputStream input){\r\n    checkCommitted();\r\n    finalizeResponse();\r\n    if (getContentType() == null) {\r\n        contentType(HttpConstants.ContentType.APPLICATION_OCTET_STREAM);\r\n    }\r\n    try {\r\n        send(input);\r\n    } catch (IOException e) {\r\n        throw new PippoRuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.JarSigner.appendLine",
	"Comment": "process a long manifest line and add continuation if required",
	"Method": "StringBuilder appendLine(StringBuilder sb,StringBuilder line){\r\n    int begin = 0;\r\n    for (int end = 70; line.length() - begin > 70; end += 69) {\r\n        sb.append(line.subSequence(begin, end)).append(\"\\r\\n \");\r\n        begin = end;\r\n    }\r\n    return sb.append(line.subSequence(begin, line.length())).append(\"\\r\\n\");\r\n}"
}, {
	"Path": "ro.pippo.core.websocket.WebSocketHandler.onClose",
	"Comment": "a notification after the close of the web socket connection.the connection could be closed by either the client or the server",
	"Method": "void onClose(WebSocketContext webSocketContext,int closeCode,String message){\r\n    log.debug(\"Close websocket connection\");\r\n}"
}, {
	"Path": "com.rabbitmq.client.ConnectionFactory.setClientProperties",
	"Comment": "replace the table of client properties that will be sent to theserver during subsequent connection startups.",
	"Method": "void setClientProperties(Map<String, Object> clientProperties){\r\n    _clientProperties = clientProperties;\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.impl.BasicQueue.sendQueue",
	"Comment": "this returns a new instance of sendqueue every time you call itso call it only once per thread.",
	"Method": "SendQueue<T> sendQueue(){\r\n    if (debug)\r\n        logger.debug(\"SendQueue requested for {}\", name);\r\n    return sendQueueSupplier.get();\r\n}"
}, {
	"Path": "io.advantageous.qbit.reactive.CallbackBuilder.withCollectionCallback",
	"Comment": "builder method to set callback handler that takes a collection",
	"Method": "CallbackBuilder withCollectionCallback(Class<T> componentClass,Callback<Collection<T>> callback){\r\n    this.callback = callback;\r\n    return this;\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AzAttributesImpl.getName",
	"Comment": "determines a name to denote this collection of attributes.for example, this name may be used to qualify attributes by collectiontype in xacml.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "io.advantageous.qbit.admin.ManagedServiceBuilder.setEnableRequestChain",
	"Comment": "enable or disable request chain.there is overhead for this, but this allows rest and websocketservices to pass the originating request, methodcall, etc. to downstream services.where it will be available via the requestcontext.a methodcall, httprequest, websocketmessage are all requests in qbit.",
	"Method": "ManagedServiceBuilder setEnableRequestChain(boolean enableRequestChain){\r\n    this.enableRequestChain = enableRequestChain;\r\n    return this;\r\n}"
}, {
	"Path": "ro.pippo.controller.ControllerHandler.validateConsumes",
	"Comment": "validates that the declared consumes can actually be processed by pippo.",
	"Method": "void validateConsumes(Collection<String> contentTypes){\r\n    Set<String> ignoreConsumes = new TreeSet();\r\n    ignoreConsumes.add(Consumes.ALL);\r\n    ignoreConsumes.add(Consumes.HTML);\r\n    ignoreConsumes.add(Consumes.XHTML);\r\n    ignoreConsumes.add(Consumes.FORM);\r\n    ignoreConsumes.add(Consumes.MULTIPART);\r\n    for (String declaredConsume : declaredConsumes) {\r\n        if (ignoreConsumes.contains(declaredConsume)) {\r\n            continue;\r\n        }\r\n        String consume = declaredConsume;\r\n        int fuzz = consume.indexOf('*');\r\n        if (fuzz > -1) {\r\n            consume = consume.substring(0, fuzz);\r\n        }\r\n        if (!contentTypes.contains(consume)) {\r\n            if (consume.equals(declaredConsume)) {\r\n                throw new PippoRuntimeException(\"{} declares @{}(\\\"{}\\\") but there is no registered ContentTypeEngine for that type!\", LangUtils.toString(controllerMethod), Consumes.class.getSimpleName(), declaredConsume);\r\n            } else {\r\n                throw new PippoRuntimeException(\"{} declares @{}(\\\"{}\\\") but there is no registered ContentTypeEngine for \\\"{}\\\"!\", LangUtils.toString(controllerMethod), Consumes.class.getSimpleName(), declaredConsume, consume);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "psiprobe.Tomcat80ContainerAdapter.getNamingToken",
	"Comment": "returns the security token required to bind to a naming context.",
	"Method": "Object getNamingToken(Context context){\r\n    Object token = null;\r\n    if (!ContextAccessController.checkSecurityToken(context, token)) {\r\n        token = context.getNamingToken();\r\n        if (!ContextAccessController.checkSecurityToken(context, token)) {\r\n            logger.error(\"Couldn't get a valid security token. ClassLoader binding will fail.\");\r\n        }\r\n    }\r\n    return token;\r\n}"
}, {
	"Path": "io.advantageous.qbit.admin.MicroserviceConfig.readConfig",
	"Comment": "reads the readconfig file, which can be a classpath or file system resource.",
	"Method": "MicroserviceConfig readConfig(String serviceName){\r\n    final Logger logger = LoggerFactory.getLogger(MicroserviceConfig.class);\r\n    if (new File(resourceLocation).exists()) {\r\n        final String json = IO.read(resourceLocation);\r\n        return JsonFactory.fromJson(json, MicroserviceConfig.class);\r\n    } else if (resourceLocationEnv != null && new File(resourceLocationEnv).exists()) {\r\n        final String json = IO.read(resourceLocationEnv);\r\n        return JsonFactory.fromJson(json, MicroserviceConfig.class);\r\n    } else {\r\n        logger.info(\"Reading config from classpath as it is not found on file system\");\r\n        final String qbitEnv = System.getenv(\"QBIT_ENV\");\r\n        final String resourceLocationOnClasspath = qbitEnv != null && !qbitEnv.isEmpty() ? serviceName + \"_\" + qbitEnv + \".json\" : serviceName + \".json\";\r\n        final String json = IO.read(Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceLocationOnClasspath));\r\n        return JsonFactory.fromJson(json, MicroserviceConfig.class);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.file.FileRealmUser.getAttribute",
	"Comment": "return the requested attribute for the user.not really needed.",
	"Method": "Object getAttribute(String key){\r\n    return attributes.get(key);\r\n}"
}, {
	"Path": "org.pitest.bytecode.analysis.InstructionMatchers.recordTarget",
	"Comment": "records if a instruction matches the target, but always returns true",
	"Method": "Match<AbstractInsnNode> recordTarget(SlotRead<AbstractInsnNode> target,SlotWrite<Boolean> found){\r\n    return (c, t) -> {\r\n        if (c.retrieve(target).get() == t) {\r\n            c.store(found, true);\r\n        }\r\n        return true;\r\n    };\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.discovery.ServiceDiscovery.localDefinitions",
	"Comment": "this just loads the end points that were registered locally.these are the endpoints that this jvm and this servicediscovery is managing.",
	"Method": "Set<EndpointDefinition> localDefinitions(){\r\n    return Collections.emptySet();\r\n}"
}, {
	"Path": "com.rabbitmq.client.ConnectionFactory.setErrorOnWriteListener",
	"Comment": "set a listener to be called when connection gets an io error trying to write on the socket.default listener triggers connection recovery asynchronously and propagatesthe exception. override the default listener to disable orcustomise automatic connection triggering on write operations.",
	"Method": "void setErrorOnWriteListener(ErrorOnWriteListener errorOnWriteListener){\r\n    this.errorOnWriteListener = errorOnWriteListener;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.P12Util.getFirstPrivateKeyEntryFromP12InputStream",
	"Comment": "returns the first private key entry found in the given keystore. if more than one private key is present, thekey that is returned is undefined.",
	"Method": "PrivateKeyEntry getFirstPrivateKeyEntryFromP12InputStream(InputStream p12InputStream,String password){\r\n    Objects.requireNonNull(password, \"Password may be blank, but must not be null.\");\r\n    final KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\r\n    try {\r\n        keyStore.load(p12InputStream, password.toCharArray());\r\n    } catch (NoSuchAlgorithmException | CertificateException e) {\r\n        throw new KeyStoreException(e);\r\n    }\r\n    final Enumeration<String> aliases = keyStore.aliases();\r\n    final KeyStore.PasswordProtection passwordProtection = new KeyStore.PasswordProtection(password.toCharArray());\r\n    while (aliases.hasMoreElements()) {\r\n        final String alias = aliases.nextElement();\r\n        KeyStore.Entry entry;\r\n        try {\r\n            try {\r\n                entry = keyStore.getEntry(alias, passwordProtection);\r\n            } catch (final UnsupportedOperationException e) {\r\n                entry = keyStore.getEntry(alias, null);\r\n            }\r\n        } catch (final UnrecoverableEntryException | NoSuchAlgorithmException e) {\r\n            throw new KeyStoreException(e);\r\n        }\r\n        if (entry instanceof KeyStore.PrivateKeyEntry) {\r\n            return (PrivateKeyEntry) entry;\r\n        }\r\n    }\r\n    throw new KeyStoreException(\"Key store did not contain any private key entries.\");\r\n}"
}, {
	"Path": "ro.pippo.core.util.MimeTypes.isValidMimeType",
	"Comment": "check the mimetype is referenced in the mimetypes database.",
	"Method": "boolean isValidMimeType(String mimeType){\r\n    if (mimeType == null) {\r\n        return false;\r\n    } else if (mimeType.indexOf(\";\") != -1) {\r\n        return mimetypes.contains(mimeType.split(\";\")[0]);\r\n    } else {\r\n        return mimetypes.contains(mimeType);\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.logging.SetupMdcForHttpRequestInterceptor.extractRequestInfoAndPutItIntoMappedDiagnosticContext",
	"Comment": "extract request data and put it into the logging mapped diagnostic context.",
	"Method": "void extractRequestInfoAndPutItIntoMappedDiagnosticContext(HttpRequest httpRequest){\r\n    MDC.put(REQUEST_URI, httpRequest.getUri());\r\n    MDC.put(REQUEST_REMOTE_ADDRESS, httpRequest.getRemoteAddress());\r\n    MDC.put(REQUEST_HTTP_METHOD, httpRequest.getMethod());\r\n    MDC.put(REQUEST_ID, Long.toString(httpRequest.getMessageId()));\r\n    extractHeaders(httpRequest);\r\n}"
}, {
	"Path": "ro.pippo.core.PippoSettings.getDoubles",
	"Comment": "returns a list of doubles from the specified name using the specified delimiter.",
	"Method": "List<Double> getDoubles(String name,List<Double> getDoubles,String name,String delimiter){\r\n    List<String> strings = getStrings(name, delimiter);\r\n    List<Double> doubles = new ArrayList(strings.size());\r\n    for (String value : strings) {\r\n        try {\r\n            double i = Double.parseDouble(value);\r\n            doubles.add(i);\r\n        } catch (NumberFormatException e) {\r\n        }\r\n    }\r\n    return Collections.unmodifiableList(doubles);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.ldap.LDAPRealm.setGroupNames",
	"Comment": "set group membership info for a user.see bugs 4646133,4646270 on why this is here.",
	"Method": "void setGroupNames(String username,String[] groups){\r\n    groupCache.put(username, new LinkedList(Arrays.asList(groups)));\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.ListFileUser.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    String fileRealmClassName = fileAuthRealm.getClassname();\r\n    if (fileRealmClassName != null && !fileRealmClassName.equals(\"com.sun.enterprise.security.auth.realm.file.FileRealm\")) {\r\n        report.setMessage(localStrings.getLocalString(\"list.file.user.realmnotsupported\", \"Configured file realm {0} is not supported.\", fileRealmClassName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String keyFile = null;\r\n    for (Property fileProp : fileAuthRealm.getProperty()) {\r\n        if (fileProp.getName().equals(\"file\"))\r\n            keyFile = fileProp.getValue();\r\n    }\r\n    if (keyFile == null) {\r\n        report.setMessage(localStrings.getLocalString(\"list.file.user.keyfilenotfound\", \"There is no physical file associated with this file realm {0} \", authRealmName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    boolean exists = (new File(keyFile)).exists();\r\n    if (!exists) {\r\n        report.setMessage(localStrings.getLocalString(\"file.realm.keyfilenonexistent\", \"The specified physical file {0} associated with the file realm {1} does not exist.\", new Object[] { keyFile, authRealmName }));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    FileRealm fr = null;\r\n    try {\r\n        realmsManager.createRealms(config);\r\n        CreateFileUser.refreshRealm(config.getName(), authRealmName);\r\n        fr = (FileRealm) realmsManager.getFromLoadedRealms(config.getName(), authRealmName);\r\n        if (fr == null) {\r\n            throw new NoSuchRealmException(authRealmName);\r\n        }\r\n    } catch (NoSuchRealmException e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.file.user.realmnotsupported\", \"Configured file realm {0} is not supported.\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    try {\r\n        Enumeration users = fr.getUserNames();\r\n        List userList = new ArrayList();\r\n        while (users.hasMoreElements()) {\r\n            final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            String userName = (String) users.nextElement();\r\n            part.setMessage(userName);\r\n            Map userMap = new HashMap();\r\n            userMap.put(\"name\", userName);\r\n            try {\r\n                userMap.put(\"groups\", Collections.list(fr.getGroupNames(userName)));\r\n            } catch (NoSuchUserException ex) {\r\n            }\r\n            userList.add(userMap);\r\n        }\r\n        Properties extraProperties = new Properties();\r\n        extraProperties.put(\"users\", userList);\r\n        report.setExtraProperties(extraProperties);\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (BadRealmException e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.file.user.realmcorrupted\", \"Configured file realm {0} is corrupted.\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "net.socialgamer.cah.JsonWrapper.getValue",
	"Comment": "returns the value of a property as an object, or null if the property does not exist.",
	"Method": "Object getValue(Object key){\r\n    return json.get(key.toString());\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.JarSigner.getZipEntry",
	"Comment": "get the zipentry for the given jarentry. added in order to suppress the compressedsize field as it was causing errors",
	"Method": "ZipEntry getZipEntry(JarEntry je){\r\n    ZipEntry ze = new ZipEntry(je.getName());\r\n    ze.setComment(je.getComment());\r\n    ze.setCrc(je.getCrc());\r\n    ze.setExtra(je.getExtra());\r\n    ze.setMethod(je.getMethod());\r\n    ze.setSize(je.getSize());\r\n    ze.setTime(je.getTime());\r\n    return ze;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.BaseAuditModule.init",
	"Comment": "method is invoked at server startup, during auditmodule initialization. if method returns without any exception thenpayara assumes that the module is ready to serve any requests.",
	"Method": "void init(Properties props){\r\n    this.props = props;\r\n}"
}, {
	"Path": "co.yiiu.pybbs.util.bcrypt.BCrypt.checkpw",
	"Comment": "check that a plaintext password matches a previously hashed one",
	"Method": "boolean checkpw(String plaintext,String hashed){\r\n    return equalsNoEarlyReturn(hashed, hashpw(plaintext, hashed));\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.rest.endpoint.tests.services.EmployeeServiceSingleObjectTestService.addEmployeeAck",
	"Comment": "there has a return and the client can get notified of exceptions that this might throw.",
	"Method": "boolean addEmployeeAck(Employee employee){\r\n    puts(employee);\r\n    employeeList.add(employee);\r\n    return true;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.server.BaseHttp2Server.start",
	"Comment": "starts this mock server and listens for traffic on the given port.",
	"Method": "Future<Void> start(int port){\r\n    final ChannelFuture channelFuture = this.bootstrap.bind(port);\r\n    this.allChannels = new DefaultChannelGroup(channelFuture.channel().eventLoop(), true);\r\n    this.allChannels.add(channelFuture.channel());\r\n    return channelFuture;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.impl.SecuritySupportImpl.loadStores",
	"Comment": "this method will load keystore and truststore and add into corresponding list.",
	"Method": "void loadStores(String tokenName,Provider provider,String keyStoreFile,char[] keyStorePass,String keyStoreType,String trustStoreFile,char[] trustStorePass,String trustStoreType){\r\n    try {\r\n        keyStores.get(DEFAULT_MAP_KEY).add(loadStore(keyStoreType, provider, keyStoreFile, keyStorePass));\r\n        trustStores.get(DEFAULT_MAP_KEY).add(loadStore(trustStoreType, provider, trustStoreFile, trustStorePass));\r\n        keyStorePasswords.get(DEFAULT_MAP_KEY).add(Arrays.copyOf(keyStorePass, keyStorePass.length));\r\n        tokenNames.get(DEFAULT_MAP_KEY).add(tokenName);\r\n    } catch (Exception ex) {\r\n        _logger.severe(\"Failed to load key stores \" + ex.getMessage());\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.nucleus.admin.rest.RestTestBase.getEntityValues",
	"Comment": "this method will parse the provided xml document and return a map of the attributes and values on the rootelement",
	"Method": "Map<String, String> getEntityValues(Response response){\r\n    Map<String, String> map = new HashMap<String, String>();\r\n    String xml = response.readEntity(String.class);\r\n    Map responseMap = MarshallingUtils.buildMapFromDocument(xml);\r\n    Object obj = responseMap.get(\"extraProperties\");\r\n    if (obj != null) {\r\n        return (Map) ((Map) obj).get(\"entity\");\r\n    } else {\r\n        return map;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.nucleus.admin.OSGiCommandsTest.osgiCmdSession",
	"Comment": "tests functionality of session handling of osgi command.it creates sessions, lists them, executes commands against each session and finally stops them.",
	"Method": "void osgiCmdSession(){\r\n    Set<String> sessions = new HashSet<String>();\r\n    for (int i = 0; i < 3; ++i) {\r\n        sessions.add(newCmdSession());\r\n    }\r\n    final Set<String> actual = listCmdSessions();\r\n    assertEquals(\"listed sessions do not match with created sessions\", sessions, actual);\r\n    for (String sessionId : sessions) {\r\n        runCmd(\"osgi\", \"--session\", \"execute\", \"--session-id\", sessionId, \"var=\" + sessionId);\r\n    }\r\n    for (String sessionId : sessions) {\r\n        String value = runCmd(\"osgi\", \"--session\", \"execute\", \"--session-id\", sessionId, \"echo $var\").get(0);\r\n        assertEquals(sessionId, value);\r\n    }\r\n    for (String sessionId : sessions) {\r\n        runCmd(\"osgi\", \"--session\", \"stop\", \"--session-id\", sessionId);\r\n    }\r\n    sessions = listCmdSessions();\r\n    assertTrue(\"Not all sessions closed properly: \" + sessions, sessions.isEmpty());\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.Value.getAsLong",
	"Comment": "convenience method to get this value as a primitive long value.",
	"Method": "long getAsLong(){\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}"
}, {
	"Path": "ro.pippo.core.PippoSettings.getFloat",
	"Comment": "returns the float value for the specified name. if the name does notexist or the value for the name can not be interpreted as a float, thedefaultvalue is returned.",
	"Method": "float getFloat(String name,float defaultValue){\r\n    try {\r\n        String value = getString(name, null);\r\n        if (!StringUtils.isNullOrEmpty(value)) {\r\n            return Float.parseFloat(value.trim());\r\n        }\r\n    } catch (NumberFormatException e) {\r\n        log.warn(\"Failed to parse float for \" + name + USING_DEFAULT_OF + defaultValue);\r\n    }\r\n    return defaultValue;\r\n}"
}, {
	"Path": "io.nayuki.qrcodegen.QrSegmentAdvanced.makeSegmentsOptimally",
	"Comment": "returns a new list of segments that is optimal for the given text at the given version number.",
	"Method": "List<QrSegment> makeSegmentsOptimally(String text,QrCode.Ecc ecl,int minVersion,int maxVersion,List<QrSegment> makeSegmentsOptimally,int[] codePoints,int version){\r\n    if (codePoints.length == 0)\r\n        return new ArrayList();\r\n    Mode[] charModes = computeCharacterModes(codePoints, version);\r\n    return splitIntoSegments(codePoints, charModes);\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.template.EvaluationContextImpl.getHierarchy",
	"Comment": "returns the data structure representing the entire hierarchy of the template currently beingevaluated.",
	"Method": "Hierarchy getHierarchy(){\r\n    return this.hierarchy;\r\n}"
}, {
	"Path": "io.advantageous.consul.endpoints.AgentEndpoint.registerServiceWithRegistrationCheck",
	"Comment": "registers the client as a service with consul.registration enablesthe use of checks.",
	"Method": "void registerServiceWithRegistrationCheck(String host,int port,RegistrationCheck check,String name,String id,String tags){\r\n    Registration registration = new Registration();\r\n    registration.setHost(host);\r\n    registration.setPort(port);\r\n    registration.setCheck(check);\r\n    registration.setName(name);\r\n    registration.setId(id);\r\n    registration.setTags(tags);\r\n    register(registration);\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.template.Hierarchy.getParent",
	"Comment": "returns the parent of the template currently being evaluated or null if there is no parent.",
	"Method": "PebbleTemplateImpl getParent(){\r\n    if (this.current == this.hierarchy.size() - 1) {\r\n        return null;\r\n    }\r\n    return this.hierarchy.get(this.current + 1);\r\n}"
}, {
	"Path": "io.advantageous.qbit.http.HTTP.getWithContentTypeHeaders",
	"Comment": "get that expects contents back as a string and allows you to pass headers and content type.",
	"Method": "String getWithContentTypeHeaders(String url,Map<String, ?> headers,String contentType){\r\n    return Exceptions.tryIt(String.class, new Exceptions.TrialWithReturn<String>() {\r\n        @Override\r\n        public String tryIt() throws Exception {\r\n            URLConnection connection;\r\n            connection = doGet(url, headers, contentType, null);\r\n            return extractResponseString(connection);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.advantageous.qbit.http.HTTP.getWithContentTypeHeaders",
	"Comment": "get that expects contents back as a string and allows you to pass headers and content type.",
	"Method": "String getWithContentTypeHeaders(String url,Map<String, ?> headers,String contentType){\r\n    URLConnection connection;\r\n    connection = doGet(url, headers, contentType, null);\r\n    return extractResponseString(connection);\r\n}"
}, {
	"Path": "psiprobe.tools.logging.slf4jlogback.TomcatSlf4jLogbackAppenderAccessor.getLogType",
	"Comment": "returns the log type, to distinguish tomcatslf4jlogback appenders from other types like log4jappenders or jdk handlers.",
	"Method": "String getLogType(){\r\n    return \"tomcatSlf4jLogback\";\r\n}"
}, {
	"Path": "io.advantageous.qbit.Factory.createMethodCallToBeParsedFromBody",
	"Comment": "create a method call based on a body that we are parsing froma post body or websocket message for example.",
	"Method": "MethodCall<Object> createMethodCallToBeParsedFromBody(String address,String returnAddress,String objectName,String methodName,Object args,MultiMap<String, String> params,MethodCall<Object> createMethodCallToBeParsedFromBody,String addressPrefix,Object message,Request<Object> originatingRequest){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.pitest.bytecode.FrameOptions.pickFlags",
	"Comment": "java 7 and above require frame info for class version above 7. the asmcompute frame options does not support the jsr opcode used by some pre 7compilers when generating java 5 bytecode.we dodge this issue by only computing frames for classes with a versionabove 6.",
	"Method": "int pickFlags(byte[] bs){\r\n    if (needsFrames(bs)) {\r\n        return ClassWriter.COMPUTE_FRAMES;\r\n    }\r\n    return ClassWriter.COMPUTE_MAXS;\r\n}"
}, {
	"Path": "org.pitest.mutationtest.config.PluginServices.findClientClasspathPlugins",
	"Comment": "lists all plugin classes that must be present on the classpath of the codeunder test at runtime",
	"Method": "Iterable<? extends ClientClasspathPlugin> findClientClasspathPlugins(){\r\n    final List<ClientClasspathPlugin> l = new ArrayList();\r\n    l.addAll(findMutationEngines());\r\n    l.addAll(findTestFrameworkPlugins());\r\n    l.addAll(nullPlugins());\r\n    return l;\r\n}"
}, {
	"Path": "io.advantageous.qbit.server.HttpRequestServiceServerHandlerUsingMetaImpl.addRequestToCheckForTimeouts",
	"Comment": "add a request to the timeout queue. server checks for timeouts when it is idle or whenthe max outstanding outstandingrequests is met.",
	"Method": "boolean addRequestToCheckForTimeouts(Request<Object> request){\r\n    String key = Str.add(\"\" + request.id(), \"|\", request.returnAddress());\r\n    this.outstandingRequestMap.put(key, request);\r\n    return outstandingRequestMap.size() < numberOfOutstandingRequests;\r\n}"
}, {
	"Path": "ro.pippo.session.spymemcached.SpymemcachedSessionDataStorageTest.testSave",
	"Comment": "test of save method, of class spymemcachedsessiondatastorage.",
	"Method": "void testSave(){\r\n    System.out.println(\"save\");\r\n    SpymemcachedSessionDataStorage instance = new SpymemcachedSessionDataStorage(client, IDLE_TIME);\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    SessionData saved = instance.get(sessionId);\r\n    assertEquals(sessionData, saved);\r\n    String value1 = sessionData.get(KEY);\r\n    String value2 = saved.get(KEY);\r\n    assertEquals(value1, value2);\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.template.PebbleTemplateImpl.initContext",
	"Comment": "initializes the evaluation context with settings from the engine.",
	"Method": "EvaluationContextImpl initContext(Locale locale){\r\n    locale = locale == null ? this.engine.getDefaultLocale() : locale;\r\n    ScopeChain scopeChain = new ScopeChain();\r\n    Map<String, Object> globals = new HashMap();\r\n    globals.put(\"locale\", locale);\r\n    globals.put(\"template\", this);\r\n    globals.put(\"_context\", new GlobalContext(scopeChain));\r\n    scopeChain.pushScope(globals);\r\n    scopeChain.pushScope(this.engine.getExtensionRegistry().getGlobalVariables());\r\n    return new EvaluationContextImpl(this, this.engine.isStrictVariables(), locale, this.engine.getExtensionRegistry(), this.engine.getTagCache(), this.engine.getExecutorService(), new ArrayList(), new HashMap(), scopeChain, null, this.engine.getEvaluationOptions());\r\n}"
}, {
	"Path": "psiprobe.tools.logging.slf4jlogback.TomcatSlf4jLogbackFactoryAccessor.getAppenders",
	"Comment": "returns a list of wrappers for all tomcatslf4jlogback appenders that have an associated logger.",
	"Method": "List<TomcatSlf4jLogbackAppenderAccessor> getAppenders(){\r\n    List<TomcatSlf4jLogbackAppenderAccessor> appenders = new ArrayList();\r\n    try {\r\n        Class<? extends Object> clazz = getTarget().getClass();\r\n        Method getLoggerList = MethodUtils.getAccessibleMethod(clazz, \"getLoggerList\");\r\n        List<Object> loggers = (List<Object>) getLoggerList.invoke(getTarget());\r\n        for (Object logger : loggers) {\r\n            TomcatSlf4jLogbackLoggerAccessor accessor = new TomcatSlf4jLogbackLoggerAccessor();\r\n            accessor.setTarget(logger);\r\n            accessor.setApplication(getApplication());\r\n            appenders.addAll(accessor.getAppenders());\r\n        }\r\n    } catch (Exception e) {\r\n        logger.error(\"{}.getLoggerList() failed\", getTarget(), e);\r\n    }\r\n    return appenders;\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.discovery.impl.ServiceDiscoveryImpl.doFailOverHealthServicesLoad",
	"Comment": "if the primary load failed, we could have a backup provider registered.",
	"Method": "void doFailOverHealthServicesLoad(String serviceNameToFetch,Exception ex){\r\n    if (backupProvider != null) {\r\n        if (debug)\r\n            logger.debug(\"ServiceDiscoveryImpl::loadHealthyServices \" + \"Error while loading healthy\" + \" services for \" + serviceNameToFetch, ex);\r\n        final List<EndpointDefinition> healthyServices = backupProvider.loadServices(serviceNameToFetch);\r\n        populateServiceMap(serviceNameToFetch, healthyServices);\r\n        serviceNamesBeingLoaded.remove(serviceNameToFetch);\r\n    } else {\r\n        logger.error(\"ServiceDiscoveryImpl::loadHealthyServices \" + \"Error while loading healthy\" + \" services for \" + serviceNameToFetch, ex);\r\n    }\r\n    Sys.sleep(10_000);\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.rest.endpoint.tests.services.EmployeeServiceSingleObjectTestService.addEmployee",
	"Comment": "this is a fire and forget style.there is no return and the client cannot get any exception that this might throw.",
	"Method": "void addEmployee(Employee employee){\r\n    employeeList.add(employee);\r\n    puts(employee);\r\n}"
}, {
	"Path": "ro.pippo.core.Languages.getDefaultLanguage",
	"Comment": "returns the default language as derived from pipposettings.",
	"Method": "String getDefaultLanguage(List<String> applicationLanguages){\r\n    if (applicationLanguages.isEmpty()) {\r\n        String NO_LANGUAGES_TEXT = \"Please specify the supported languages in 'application.properties'.\" + \" For example 'application.languages=en, ro, de, pt-BR' makes 'en' your default language.\";\r\n        log.error(NO_LANGUAGES_TEXT);\r\n        return \"en\";\r\n    }\r\n    return applicationLanguages.get(0);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.audit.BaseAuditManager.loadAuditModule",
	"Comment": "this method return auditmodule with given classname and properties.",
	"Method": "BaseAuditModule loadAuditModule(String classname,Properties props){\r\n    BaseAuditModule auditModule;\r\n    ClassLoader loader = Thread.currentThread().getContextClassLoader();\r\n    Class am = Class.forName(classname, true, loader);\r\n    Object obj = am.newInstance();\r\n    auditModule = (BaseAuditModule) obj;\r\n    auditModule.init(props);\r\n    return auditModule;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.impl.SecuritySupportImpl.getTokenNames",
	"Comment": "this method returns an array of token names in order corresponding to array of keystores.",
	"Method": "String[] getTokenNames(){\r\n    List<String> tokenNamesList = tokenNames.get(DEFAULT_MAP_KEY);\r\n    return tokenNamesList.toArray(new String[tokenNamesList.size()]);\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.ConnectedUsers.checkForPingAndIdleTimeouts",
	"Comment": "check for any users that have not communicated with the server within the ping timeout delay,and remove users which have not so communicated. also remove clients which are still connected,but have not actually done anything for a long time.",
	"Method": "void checkForPingAndIdleTimeouts(){\r\n    final Map<User, DisconnectReason> removedUsers = new HashMap<User, DisconnectReason>();\r\n    synchronized (users) {\r\n        final Iterator<User> iterator = users.values().iterator();\r\n        while (iterator.hasNext()) {\r\n            final User u = iterator.next();\r\n            DisconnectReason reason = null;\r\n            if (System.nanoTime() - u.getLastHeardFrom() > PING_TIMEOUT) {\r\n                reason = DisconnectReason.PING_TIMEOUT;\r\n            } else if (!u.isAdmin() && System.nanoTime() - u.getLastUserAction() > IDLE_TIMEOUT) {\r\n                reason = DisconnectReason.IDLE_TIMEOUT;\r\n            }\r\n            if (null != reason) {\r\n                removedUsers.put(u, reason);\r\n                iterator.remove();\r\n            }\r\n        }\r\n    }\r\n    for (final Entry<User, DisconnectReason> entry : removedUsers.entrySet()) {\r\n        try {\r\n            entry.getKey().noLongerValid();\r\n            notifyRemoveUser(entry.getKey(), entry.getValue());\r\n            logger.info(String.format(\"Automatically kicking user %s due to %s\", entry.getKey(), entry.getValue()));\r\n        } catch (final Exception e) {\r\n            logger.error(\"Unable to remove pinged-out user\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ro.pippo.session.hazelcast.HazelcastSessionDataStorageTest.testDelete",
	"Comment": "test of delete method, of class hazelcastsessiondatastorage.",
	"Method": "void testDelete(){\r\n    System.out.println(\"delete\");\r\n    HazelcastSessionDataStorage instance = new HazelcastSessionDataStorage(Hazelcast.newHazelcastInstance());\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    instance.delete(sessionId);\r\n    SessionData deleted = instance.get(sessionId);\r\n    assertNull(deleted);\r\n}"
}, {
	"Path": "com.feth.play.module.pa.providers.password.UsernamePasswordAuthProvider.sendMail",
	"Comment": "called to send mails. you might want to override this in order to\tcustomize mail sending e.g. by using a different mailer service\timplementation.",
	"Method": "Cancellable sendMail(String subject,Body body,String recipient,Cancellable sendMail,Mail mail){\r\n    return mailer.sendMail(mail);\r\n}"
}, {
	"Path": "ro.pippo.session.spymemcached.SpymemcachedSessionDataStorageTest.testCreate",
	"Comment": "test of create method, of class spymemcachedsessiondatastorage.",
	"Method": "void testCreate(){\r\n    System.out.println(\"create\");\r\n    SpymemcachedSessionDataStorage instance = new SpymemcachedSessionDataStorage(client, IDLE_TIME);\r\n    SessionData sessionData = instance.create();\r\n    sessionData.put(KEY, VALUE);\r\n    assertNotNull(sessionData);\r\n    assertNotNull(sessionData.getId());\r\n    assertNotNull(sessionData.getCreationTime());\r\n    assertEquals(sessionData.get(KEY), VALUE);\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.AuthenticationServiceFactory.getAuthenticationServiceConfiguration",
	"Comment": "helper function to obtain the authentication service configuration from the domain.",
	"Method": "org.glassfish.security.services.config.AuthenticationService getAuthenticationServiceConfiguration(Domain domain){\r\n    org.glassfish.security.services.config.AuthenticationService atnConfiguration = ServiceFactory.getSecurityServiceConfiguration(domain, org.glassfish.security.services.config.AuthenticationService.class);\r\n    return atnConfiguration;\r\n}"
}, {
	"Path": "org.pitest.classpath.ClassPath.addEntriesFromClasspathManifest",
	"Comment": "because classpaths can become longer than the os supports pitest creates temporary jar files and places the classpathin the manifest where there is no size limit.we must therefore parse them out again here.",
	"Method": "void addEntriesFromClasspathManifest(Set<File> elements){\r\n    Optional<File> maybeJar = elements.stream().filter(f -> f.getName().startsWith(\"classpath\") && f.getName().endsWith(\".jar\")).findFirst();\r\n    maybeJar.ifPresent(file -> elements.addAll(ManifestUtils.readClasspathManifest(file)));\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.User.leaveGame",
	"Comment": "marks the user as no longer participating in a game.this should only be called from game itself.",
	"Method": "void leaveGame(Game game){\r\n    if (currentGame == game) {\r\n        currentGame = null;\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.admin.ManagedServiceBuilder.isEnableRequestChain",
	"Comment": "request call chain building enabled. this allows rest and websocketservices to pass the originating request, methodcall, etc. to downstream services.where it will be available via the requestcontext.a methodcall, httprequest, websocketmessage are all requests in qbit.",
	"Method": "boolean isEnableRequestChain(){\r\n    return enableRequestChain;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.GUIErrorDialog.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    okButton = new javax.swing.JButton();\r\n    errorLbl = new javax.swing.JLabel();\r\n    okButton.setAlignmentX(CENTER_ALIGNMENT);\r\n    errorLbl.setAlignmentX(CENTER_ALIGNMENT);\r\n    getContentPane().setLayout(new javax.swing.BoxLayout(getContentPane(), BoxLayout.Y_AXIS));\r\n    addWindowListener(new java.awt.event.WindowAdapter() {\r\n        public void windowClosing(java.awt.event.WindowEvent evt) {\r\n            closeDialog(evt);\r\n        }\r\n    });\r\n    okButton.setActionCommand(\"okButton\");\r\n    okButton.setText(\"OK\");\r\n    okButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            dispose();\r\n        }\r\n    });\r\n    super.addWindowListener(new WindowAdapter() {\r\n        public void windowClosing(WindowEvent we) {\r\n            dispose();\r\n        }\r\n    });\r\n    errorLbl.setText(\"Error : \" + message);\r\n    getContentPane().add(errorLbl);\r\n    getContentPane().add(okButton);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.GUIErrorDialog.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    closeDialog(evt);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.GUIErrorDialog.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    dispose();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.GUIErrorDialog.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    dispose();\r\n}"
}, {
	"Path": "de.komoot.photon.query.PhotonQueryBuilder.builder",
	"Comment": "create an instance of this builder which can then be embellished as needed.",
	"Method": "TagFilterQueryBuilder builder(String query,String language){\r\n    return new PhotonQueryBuilder(query, language);\r\n}"
}, {
	"Path": "ro.pippo.core.Messages.loadRegisteredMessageResources",
	"Comment": "loads pippo internal messages & application messages and returns the merger.",
	"Method": "Map<String, Properties> loadRegisteredMessageResources(Map<String, Properties> loadRegisteredMessageResources,String name){\r\n    Map<String, Properties> messageResources = new TreeMap();\r\n    Properties defaultMessages = loadMessages(String.format(name, \"\"));\r\n    if (defaultMessages == null) {\r\n        log.error(\"Could not locate the default messages resource '{}', please create it.\", String.format(name, \"\"));\r\n    } else {\r\n        messageResources.put(\"\", defaultMessages);\r\n    }\r\n    List<String> registeredLanguages = languages.getRegisteredLanguages();\r\n    for (String language : registeredLanguages) {\r\n        Properties messages = loadMessages(String.format(name, \"_\" + language));\r\n        Properties messagesLangOnly = null;\r\n        String langComponent = languages.getLanguageComponent(language);\r\n        if (!langComponent.equals(language)) {\r\n            messagesLangOnly = messageResources.get(langComponent);\r\n            if (messagesLangOnly == null) {\r\n                messagesLangOnly = loadMessages(String.format(name, \"_\" + langComponent));\r\n            }\r\n        }\r\n        if (messages == null) {\r\n            log.error(\"Could not locate the '{}' messages resource '{}' specified in '{}'.\", language, String.format(name, \"_\" + language), PippoConstants.SETTING_APPLICATION_LANGUAGES);\r\n        } else {\r\n            Properties compositeMessages = new Properties(defaultMessages);\r\n            if (messagesLangOnly != null) {\r\n                compositeMessages.putAll(messagesLangOnly);\r\n                if (!messageResources.containsKey(langComponent)) {\r\n                    Properties langResources = new Properties();\r\n                    langResources.putAll(compositeMessages);\r\n                    messageResources.put(langComponent, langResources);\r\n                }\r\n            }\r\n            compositeMessages.putAll(messages);\r\n            messageResources.put(language.toLowerCase(), compositeMessages);\r\n        }\r\n    }\r\n    return Collections.unmodifiableMap(messageResources);\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.lexer.LexerImpl.tokenize",
	"Comment": "this is the main method used to tokenize the raw contents of a template.",
	"Method": "TokenStream tokenize(Reader reader,String name){\r\n    this.buildOperatorRegex();\r\n    try {\r\n        this.source = new TemplateSource(reader, name);\r\n    } catch (IOException e) {\r\n        throw new ParserException(e, \"Can not convert template Reader into a String\", 0, name);\r\n    }\r\n    this.state = State.DATA;\r\n    this.tokens = new ArrayList();\r\n    this.states = new LinkedList();\r\n    this.brackets = new LinkedList();\r\n    while (this.source.length() > 0) {\r\n        switch(this.state) {\r\n            case DATA:\r\n                this.lexData();\r\n                break;\r\n            case EXECUTE:\r\n                this.lexExecute();\r\n                break;\r\n            case PRINT:\r\n                this.lexPrint();\r\n                break;\r\n            case COMMENT:\r\n                this.lexComment();\r\n                break;\r\n            case STRING:\r\n                this.lexString();\r\n                break;\r\n            case STRING_INTERPOLATION:\r\n                this.lexStringInterpolation();\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    this.pushToken(Token.Type.EOF);\r\n    if (!this.brackets.isEmpty()) {\r\n        String expected = this.brackets.pop().getLeft();\r\n        throw new ParserException(null, String.format(\"Unclosed \\\"%s\\\"\", expected), this.source.getLineNumber(), this.source.getFilename());\r\n    }\r\n    return new TokenStream(this.tokens, this.source.getFilename());\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.SimpleIdGenerator.getUnique",
	"Comment": "generates and returns a unique id, for the given key.if key exists, returns old value.ensure that all",
	"Method": "int getUnique(String idKey){\r\n    Integer existingId = idMap.get(idKey);\r\n    if (existingId == null) {\r\n        int newId = generateViewId();\r\n        idMap.put(idKey, newId);\r\n        existingId = newId;\r\n    }\r\n    return existingId;\r\n}"
}, {
	"Path": "net.socialgamer.cah.JsonWrapper.getInteger",
	"Comment": "returns the value of a property as an integer, or the default if the parameter does not exist.",
	"Method": "int getInteger(Object key,int defaultValue){\r\n    final Object value = getValue(key);\r\n    if (value instanceof Number) {\r\n        return ((Number) value).intValue();\r\n    }\r\n    return (value == null) ? defaultValue : Integer.parseInt(value.toString());\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.MacroTest.testMacroInvokedTwice",
	"Comment": "there was an issue where the second invokation of a macro did not have access to the originalarguments any more.",
	"Method": "void testMacroInvokedTwice(){\r\n    PebbleEngine pebble = new PebbleEngine.Builder().strictVariables(false).build();\r\n    PebbleTemplate template = pebble.getTemplate(\"templates/template.macroDouble.peb\");\r\n    Writer writer = new StringWriter();\r\n    template.evaluate(writer);\r\n    assertEquals(\"onetwo\", writer.toString());\r\n}"
}, {
	"Path": "ro.pippo.core.PippoSettings.getString",
	"Comment": "returns the string value for the specified name. if the name does not existor the value for the name can not be interpreted as a string, thedefaultvalue is returned.",
	"Method": "String getString(String name,String defaultValue){\r\n    String value = getProperties().getProperty(name, defaultValue);\r\n    value = overrides.getProperty(name, value);\r\n    return value;\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.PebbleEngine.getTemplate",
	"Comment": "loads, parses, and compiles a template into an instance of pebbletemplate and returns thisinstance.",
	"Method": "PebbleTemplate getTemplate(String templateName,PebbleTemplate getTemplate,String templateName,Loader loader){\r\n    if (templateName == null) {\r\n        return null;\r\n    }\r\n    if (loader == null) {\r\n        throw new LoaderException(null, \"Loader has not yet been specified.\");\r\n    }\r\n    Object cacheKey = loader.createCacheKey(templateName);\r\n    return this.templateCache.computeIfAbsent(cacheKey, k -> this.getPebbleTemplate(templateName, loader, cacheKey));\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.impl.BasicQueue.receiveQueue",
	"Comment": "this returns a new instance of receivequeue every time you call itso call it only once per thread.",
	"Method": "ReceiveQueue<T> receiveQueue(){\r\n    if (debug)\r\n        logger.debug(\"ReceiveQueue requested for {}\", name);\r\n    return new BasicReceiveQueue(queue, pollTimeWait, pollTimeTimeUnit, limit);\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.ServiceBundle.addServiceWithQueueCallBackHandlers",
	"Comment": "add a service with no alias address, and one or more queue callback handlers.",
	"Method": "ServiceBundle addServiceWithQueueCallBackHandlers(Object serviceObject,QueueCallBackHandler queueCallBackHandlers){\r\n    throw new IllegalStateException(\"Not implemented\");\r\n}"
}, {
	"Path": "psiprobe.tools.logging.log4j2.Log4J2WebLoggerContextUtilsAccessor.getWebLoggerContext",
	"Comment": "gets the logger context configured for the given servletcontext.",
	"Method": "Log4J2LoggerContextAccessor getWebLoggerContext(ServletContext ctx){\r\n    logger.debug(\"getWebLoggerContext(): IN: ctx={}\", ctx);\r\n    Log4J2LoggerContextAccessor result = null;\r\n    try {\r\n        Class<?> clazz = (Class<?>) getTarget();\r\n        Method getWebLoggerContext;\r\n        try {\r\n            getWebLoggerContext = MethodUtils.getAccessibleMethod(clazz, \"getWebLoggerContext\", ServletContext.class);\r\n        } catch (Exception e) {\r\n            logger.error(\"exception getting accessible method getWebLoggerContext\", e);\r\n            throw e;\r\n        }\r\n        Object loggerContext;\r\n        try {\r\n            loggerContext = getWebLoggerContext.invoke(null, ctx);\r\n        } catch (Exception e) {\r\n            logger.error(\"exception in getWebLoggerContext\", e);\r\n            throw e;\r\n        }\r\n        if (loggerContext == null) {\r\n            throw new NullPointerException(getTarget().getClass().getName() + \"#getWebLoggerContext(Ljavax/servlet/ServletContext) returned null\");\r\n        }\r\n        result = new Log4J2LoggerContextAccessor();\r\n        result.setTarget(loggerContext);\r\n        result.setApplication(getApplication());\r\n    } catch (Exception e) {\r\n        logger.error(\"{}#getWebLoggerContext(Ljavax/servlet/ServletContext) failed\", getTarget().getClass().getName(), e);\r\n    }\r\n    logger.debug(\"getWebLoggerContext(): OUT: result={}\", result);\r\n    return result;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.util.SimpleApnsPushNotification.getToken",
	"Comment": "returns the token of the device to which this push notification should be delivered.",
	"Method": "String getToken(){\r\n    return this.token;\r\n}"
}, {
	"Path": "com.hugnew.sps.services.pay.util.app.ali.global.sign.Base64.removeWhiteSpace",
	"Comment": "remove whitespace from mime containing encoded base64 data.",
	"Method": "int removeWhiteSpace(char[] data){\r\n    if (data == null) {\r\n        return 0;\r\n    }\r\n    int newSize = 0;\r\n    int len = data.length;\r\n    for (int i = 0; i < len; i++) {\r\n        if (!isWhiteSpace(data[i])) {\r\n            data[newSize++] = data[i];\r\n        }\r\n    }\r\n    return newSize;\r\n}"
}, {
	"Path": "ro.pippo.session.spymemcached.SpymemcachedSessionDataStorageTest.testGetExpired",
	"Comment": "test of get method, of class spymemcachedsessiondatastorage.",
	"Method": "void testGetExpired(){\r\n    System.out.println(\"get expired\");\r\n    SpymemcachedSessionDataStorage instance = new SpymemcachedSessionDataStorage(client, IDLE_TIME);\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    Thread.sleep(2000L);\r\n    SessionData deleted = instance.get(sessionId);\r\n    assertNull(deleted);\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.CaptureRequestInterceptor.before",
	"Comment": "captures the current method call and if originating as an httprequest,then we pass the httprequest into the the requestcontext.",
	"Method": "boolean before(MethodCall methodCall){\r\n    RequestContext.setRequest(methodCall);\r\n    return true;\r\n}"
}, {
	"Path": "com.rabbitmq.client.ConnectionFactory.useBlockingIo",
	"Comment": "use blocking io for communication with the server.with blocking io, each connection creates its own threadto read data from the server.",
	"Method": "void useBlockingIo(){\r\n    this.nio = false;\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.CoreTestsTest.testOddWithInteger",
	"Comment": "pebble parses numbers as longs so we want to make sure our numerical tests will work even if weforce it to take an int as an input.",
	"Method": "void testOddWithInteger(){\r\n    PebbleEngine pebble = new PebbleEngine.Builder().loader(new StringLoader()).strictVariables(false).build();\r\n    String source = \"{% if num is odd %}yes{% else %}no{% endif %}\";\r\n    PebbleTemplate template = pebble.getTemplate(source);\r\n    Map<String, Object> context = new HashMap();\r\n    context.put(\"num\", 3);\r\n    Writer writer = new StringWriter();\r\n    template.evaluate(writer, context);\r\n    assertEquals(\"yes\", writer.toString());\r\n}"
}, {
	"Path": "io.nayuki.qrcodegen.BitBuffer.appendData",
	"Comment": "appends the content of the specified bit buffer to this buffer.",
	"Method": "void appendData(BitBuffer bb){\r\n    Objects.requireNonNull(bb);\r\n    if (Integer.MAX_VALUE - bitLength < bb.bitLength)\r\n        throw new IllegalStateException(\"Maximum length reached\");\r\n    for (int i = 0; i < bb.bitLength; i++, bitLength++) data.set(bitLength, bb.data.get(i));\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.makeAzAction",
	"Comment": "convert an action, expressed as a string, into a typed attributes collection.",
	"Method": "AzAction makeAzAction(String action){\r\n    AzAction aza = new AzActionImpl(action);\r\n    return aza;\r\n}"
}, {
	"Path": "org.glassfish.tests.utils.NucleusTestUtils.nadminWithOutput",
	"Comment": "runs the command with the args givenreturns the precious output strings for further processing.",
	"Method": "NadminReturn nadminWithOutput(String args,NadminReturn nadminWithOutput,int timeout,String args){\r\n    File cmd = new File(nucleusRoot, isWindows() ? \"bin/nadmin.bat\" : \"bin/nadmin\");\r\n    if (!cmd.canExecute()) {\r\n        cmd = new File(nucleusRoot, isWindows() ? \"bin/asadmin.bat\" : \"bin/asadmin\");\r\n        if (!cmd.canExecute()) {\r\n            cmd = new File(nucleusRoot, isWindows() ? \"bin/padmin.bat\" : \"bin/padmin\");\r\n        }\r\n    }\r\n    return cmdWithOutput(cmd, timeout, args);\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.isAuthorized",
	"Comment": "determine whether the given subject is authorized to access the given resource,specified by a uri.",
	"Method": "boolean isAuthorized(Subject subject,URI resource,boolean isAuthorized,Subject subject,URI resource,String action){\r\n    checkServiceAvailability();\r\n    if (null == subject) {\r\n        throw new IllegalArgumentException(localStrings.getLocalString(\"service.subject_null\", \"The supplied Subject is null.\"));\r\n    }\r\n    if (null == resource) {\r\n        throw new IllegalArgumentException(localStrings.getLocalString(\"service.resource_null\", \"The supplied Resource is null.\"));\r\n    }\r\n    AzSubject azSubject = makeAzSubject(subject);\r\n    AzResource azResource = makeAzResource(resource);\r\n    AzAction azAction = makeAzAction(action);\r\n    AzResult azResult = getAuthorizationDecision(azSubject, azResource, azAction);\r\n    boolean result = AzResult.Status.OK.equals(azResult.getStatus()) && AzResult.Decision.PERMIT.equals(azResult.getDecision());\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginCallbackHandler.handle",
	"Comment": "this is the callback method called when authentication data is required. it either pops up a dialog box to requestauthentication data or use text input.",
	"Method": "void handle(Callback[] callbacks){\r\n    if (isGUI) {\r\n        String user = localStrings.getLocalString(\"login.user\", \"user\");\r\n        new GUILoginDialog(user, callbacks);\r\n        for (int i = 0; i < callbacks.length; i++) {\r\n            if (callbacks[i] instanceof NameCallback) {\r\n                cancelStatus.set(((NameCallback) callbacks[i]).getName() == null);\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        new TextLoginDialog(callbacks);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.setAttributeResolvers",
	"Comment": "replaces the internal list of attributeresolver instanceswith the given list. if multiple equivalent instances exist in the given list,only the first such instance will be inserted.",
	"Method": "void setAttributeResolvers(List<AzAttributeResolver> resolverList){\r\n    if (null == resolverList) {\r\n        throw new IllegalArgumentException(localStrings.getLocalString(\"service.resolver_null\", \"The supplied Attribute Resolver is null.\"));\r\n    }\r\n    synchronized (attributeResolvers) {\r\n        attributeResolvers.clear();\r\n        for (AzAttributeResolver ar : resolverList) {\r\n            if ((null != ar) && !attributeResolvers.contains(ar)) {\r\n                attributeResolvers.add(ar);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.pitest.PitMojoIT.shouldCorrectlyHandleOverrides",
	"Comment": "verifies that overriding defaults has the expected results",
	"Method": "void shouldCorrectlyHandleOverrides(){\r\n    File testDir = prepareSiteTest(\"/pit-site-custom-config\");\r\n    File targetDir = buildFilePath(testDir, \"target\");\r\n    File expectedSiteReportDir = buildFilePath(testDir, \"target\", \"site\", \"foobar\");\r\n    FileUtils.moveDirectory(buildFilePath(targetDir, \"pit-reports\"), buildFilePath(targetDir, \"new-report-location\"));\r\n    verifier.executeGoal(\"site\");\r\n    String projectReportsHtmlContents = FileUtils.readFileToString(buildFilePath(testDir, \"target\", \"site\", \"project-reports.html\"));\r\n    assertTrue(\"did not find expected anchor tag to pit site report\", projectReportsHtmlContents.contains(\"<a href=\\\"foobar/index.html\\\" title=\\\"my-test-pit-report-name\\\">my-test-pit-report-name<\/a>\"));\r\n    assertTrue(\"expected site report directory [\" + expectedSiteReportDir + \"] does not exist but should exist\", expectedSiteReportDir.exists());\r\n    assertFalse(\"expected default site report directory exists but should not exist since the report location parameter was overridden\", buildFilePath(testDir, \"target\", \"site\", \"pit-reports\").exists());\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.Game.getPlayerStatus",
	"Comment": "determine the player status for a given player, based on game state.",
	"Method": "GamePlayerStatus getPlayerStatus(Player player){\r\n    final GamePlayerStatus playerStatus;\r\n    switch(state) {\r\n        case LOBBY:\r\n            if (host == player) {\r\n                playerStatus = GamePlayerStatus.HOST;\r\n            } else {\r\n                playerStatus = GamePlayerStatus.IDLE;\r\n            }\r\n            break;\r\n        case PLAYING:\r\n            if (getJudge() == player) {\r\n                playerStatus = GamePlayerStatus.JUDGE;\r\n            } else {\r\n                if (!roundPlayers.contains(player)) {\r\n                    playerStatus = GamePlayerStatus.IDLE;\r\n                    break;\r\n                }\r\n                final List<WhiteCard> playerCards = playedCards.getCards(player);\r\n                if (playerCards != null && blackCard != null && playerCards.size() == blackCard.getPick()) {\r\n                    playerStatus = GamePlayerStatus.IDLE;\r\n                } else {\r\n                    playerStatus = GamePlayerStatus.PLAYING;\r\n                }\r\n            }\r\n            break;\r\n        case JUDGING:\r\n            if (getJudge() == player) {\r\n                playerStatus = GamePlayerStatus.JUDGING;\r\n            } else {\r\n                playerStatus = GamePlayerStatus.IDLE;\r\n            }\r\n            break;\r\n        case ROUND_OVER:\r\n            if (getJudge() == player) {\r\n                playerStatus = GamePlayerStatus.JUDGE;\r\n            } else if (player.getScore() >= options.scoreGoal) {\r\n                playerStatus = GamePlayerStatus.WINNER;\r\n            } else {\r\n                playerStatus = GamePlayerStatus.IDLE;\r\n            }\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Unknown GameState \" + state.toString());\r\n    }\r\n    return playerStatus;\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.User.contactedServer",
	"Comment": "update the timestamp that we have last heard from this user to the current time.",
	"Method": "void contactedServer(){\r\n    lastHeardFrom = System.nanoTime();\r\n}"
}, {
	"Path": "io.advantageous.qbit.admin.ManagedServiceBuilder.enableRequestChain",
	"Comment": "enable the request chain.there is overhead for this, but this allows rest and websocketservices to pass the originating request, methodcall, etc. to downstream services.where it will be available via the requestcontext.a methodcall, httprequest, websocketmessage are all requests in qbit.",
	"Method": "ManagedServiceBuilder enableRequestChain(){\r\n    this.enableRequestChain = true;\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.factory.SecurityManagerFactory.addManagerToApp",
	"Comment": "in id2smmap, maps manager to ctxid and name, and in app2idmap, includes ctxid in values mapped to appname.",
	"Method": "void addManagerToApp(Map<String, Map<String, T>> iD2sMmap,Map<String, ArrayList<String>> app2iDmap,String ctxId,String name,String appName,T manager){\r\n    synchronized (iD2sMmap) {\r\n        Map<String, T> managerMap = iD2sMmap.get(ctxId);\r\n        if (managerMap == null) {\r\n            managerMap = new HashMap<String, T>();\r\n            iD2sMmap.put(ctxId, managerMap);\r\n        }\r\n        managerMap.put(name, manager);\r\n    }\r\n    synchronized (app2iDmap) {\r\n        ArrayList<String> ctxList = app2iDmap.get(appName);\r\n        if (ctxList == null) {\r\n            ctxList = new ArrayList<String>();\r\n            app2iDmap.put(appName, ctxList);\r\n        }\r\n        if (!ctxList.contains(ctxId)) {\r\n            ctxList.add(ctxId);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.reactive.Reactor.removeCoordinator",
	"Comment": "remove a coordinator from the list of coordinators that we are managing.",
	"Method": "CallbackCoordinator removeCoordinator(CallbackCoordinator coordinator){\r\n    this.removeCoordinatorQueue.add(coordinator);\r\n    return coordinator;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.admin.cli.EnableSecureAdminCommand.ensureSecureAdminPrincipalForAlias",
	"Comment": "makes sure there is a secureadminprincipal entry for the specifiedalias.if not, one is added in the context of the currenttransaction.",
	"Method": "void ensureSecureAdminPrincipalForAlias(String alias,SecureAdmin secureAdmin_w){\r\n    SecureAdminPrincipal p = getSecureAdminPrincipalForAlias(alias, secureAdmin_w);\r\n    if (p != null) {\r\n        return;\r\n    }\r\n    try {\r\n        final String dn = secureAdminHelper.getDN(alias, true);\r\n        p = secureAdmin_w.createChild(SecureAdminPrincipal.class);\r\n        p.setDn(dn);\r\n        secureAdmin_w.getSecureAdminPrincipal().add(p);\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.RoleMappingServiceImpl.findOrCreateDeploymentContext",
	"Comment": "find an existing roledeploymentcontext, or create a new one if one does not\talready exist for the specified application context.",
	"Method": "RoleMappingService.RoleDeploymentContext findOrCreateDeploymentContext(String appContext){\r\n    checkServiceAvailability();\r\n    return provider.findOrCreateDeploymentContext(appContext);\r\n}"
}, {
	"Path": "org.pf4j.DefaultPluginFactory.create",
	"Comment": "creates a plugin instance. if an error occurs than that error is logged and the method returns null.",
	"Method": "Plugin create(PluginWrapper pluginWrapper){\r\n    String pluginClassName = pluginWrapper.getDescriptor().getPluginClass();\r\n    log.debug(\"Create instance for plugin '{}'\", pluginClassName);\r\n    Class<?> pluginClass;\r\n    try {\r\n        pluginClass = pluginWrapper.getPluginClassLoader().loadClass(pluginClassName);\r\n    } catch (ClassNotFoundException e) {\r\n        log.error(e.getMessage(), e);\r\n        return null;\r\n    }\r\n    int modifiers = pluginClass.getModifiers();\r\n    if (Modifier.isAbstract(modifiers) || Modifier.isInterface(modifiers) || (!Plugin.class.isAssignableFrom(pluginClass))) {\r\n        log.error(\"The plugin class '{}' is not valid\", pluginClassName);\r\n        return null;\r\n    }\r\n    try {\r\n        Constructor<?> constructor = pluginClass.getConstructor(PluginWrapper.class);\r\n        return (Plugin) constructor.newInstance(pluginWrapper);\r\n    } catch (Exception e) {\r\n        log.error(e.getMessage(), e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "ro.pippo.core.ContentTypeEngines.registerContentTypeEngine",
	"Comment": "registers a content type engine if no other engine has been registeredfor the content type.",
	"Method": "ContentTypeEngine registerContentTypeEngine(Class<? extends ContentTypeEngine> engineClass){\r\n    ContentTypeEngine engine;\r\n    try {\r\n        engine = engineClass.newInstance();\r\n    } catch (Exception e) {\r\n        throw new PippoRuntimeException(e, \"Failed to instantiate '{}'\", engineClass.getName());\r\n    }\r\n    if (!engines.containsKey(engine.getContentType())) {\r\n        setContentTypeEngine(engine);\r\n        return engine;\r\n    } else {\r\n        log.debug(\"'{}' content engine already registered, ignoring '{}'\", engine.getContentType(), engineClass.getName());\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.turo.pushy.apns.server.AcceptAllPushNotificationHandlerFactory.buildHandler",
	"Comment": "constructs a new push notification handler that unconditionally accepts all push notifications.",
	"Method": "PushNotificationHandler buildHandler(SSLSession sslSession){\r\n    return new PushNotificationHandler() {\r\n        @Override\r\n        public void handlePushNotification(final Http2Headers headers, final ByteBuf payload) {\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.turo.pushy.apns.server.AcceptAllPushNotificationHandlerFactory.buildHandler",
	"Comment": "constructs a new push notification handler that unconditionally accepts all push notifications.",
	"Method": "PushNotificationHandler buildHandler(SSLSession sslSession){\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.MacroTest.skipGenerationMacro",
	"Comment": "this ensures that macro inheritance works properly even if it skips a generation.",
	"Method": "void skipGenerationMacro(){\r\n    PebbleEngine pebble = new PebbleEngine.Builder().strictVariables(false).build();\r\n    PebbleTemplate template = pebble.getTemplate(\"templates/template.skipGenerationMacro1.peb\");\r\n    Writer writer = new StringWriter();\r\n    template.evaluate(writer);\r\n    assertEquals(\"success\", writer.toString());\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.ChangeAdminPassword.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    String fileRealmClassName = fileAuthRealm.getClassname();\r\n    if (fileRealmClassName != null && !fileRealmClassName.equals(\"com.sun.enterprise.security.auth.realm.file.FileRealm\")) {\r\n        report.setMessage(localStrings.getLocalString(\"change.admin.password.adminrealmnotsupported\", \"Configured admin realm is not supported.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String keyFile = null;\r\n    for (Property fileProp : fileAuthRealm.getProperty()) {\r\n        if (fileProp.getName().equals(\"file\"))\r\n            keyFile = fileProp.getValue();\r\n    }\r\n    if (keyFile == null) {\r\n        report.setMessage(localStrings.getLocalString(\"change.admin.password.keyfilenotfound\", \"There is no physical file associated with admin realm\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    FileRealm fr = null;\r\n    try {\r\n        realmsManager.createRealms(config);\r\n        fr = (FileRealm) realmsManager.getFromLoadedRealms(config.getName(), fileAuthRealm.getName());\r\n        if (fr == null) {\r\n            throw new NoSuchRealmException(fileAuthRealm.getName());\r\n        }\r\n    } catch (NoSuchRealmException e) {\r\n        report.setMessage(localStrings.getLocalString(\"change.admin.password.realmnotsupported\", \"Configured admin realm does not exist.\") + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    try {\r\n        Enumeration en = fr.getGroupNames(userName);\r\n        int size = 0;\r\n        while (en.hasMoreElements()) {\r\n            size++;\r\n            en.nextElement();\r\n        }\r\n        String[] groups = new String[size];\r\n        en = fr.getGroupNames(userName);\r\n        for (int i = 0; i < size; i++) {\r\n            groups[i] = (String) en.nextElement();\r\n        }\r\n        fr.updateUser(userName, userName, newpassword.toCharArray(), groups);\r\n        fr.persist();\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"change.admin.password.userupdatefailed\", \"Password change failed for user named {0}\", userName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.ldap.LDAPRealm.getLdapBindProps",
	"Comment": "get binding properties defined in server.xml for ldap server.",
	"Method": "Properties getLdapBindProps(){\r\n    return (Properties) ldapBindProps.clone();\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.CoreTestsTest.testEvenWithInteger",
	"Comment": "pebble parses numbers as longs so we want to make sure our numerical tests will work even if weforce it to take an int as an input.",
	"Method": "void testEvenWithInteger(){\r\n    PebbleEngine pebble = new PebbleEngine.Builder().loader(new StringLoader()).strictVariables(false).build();\r\n    String source = \"{% if num is even %}yes{% else %}no{% endif %}\";\r\n    PebbleTemplate template = pebble.getTemplate(source);\r\n    Map<String, Object> context = new HashMap();\r\n    context.put(\"num\", 2);\r\n    Writer writer = new StringWriter();\r\n    template.evaluate(writer, context);\r\n    assertEquals(\"yes\", writer.toString());\r\n}"
}, {
	"Path": "com.undefined.testing.OneLinerFormatter.setOutput",
	"Comment": "sets the stream the formatter is supposed to write its results to.",
	"Method": "void setOutput(OutputStream out){\r\n    this.out = out;\r\n    output = new PrintWriter(out);\r\n}"
}, {
	"Path": "ro.pippo.session.infinispan.InfinispanSessionDataStorageTest.testDelete",
	"Comment": "test of delete method, of class infinispansessiondatastorage.",
	"Method": "void testDelete(){\r\n    System.out.println(\"delete\");\r\n    InfinispanSessionDataStorage instance = new InfinispanSessionDataStorage(cacheManager);\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    instance.delete(sessionId);\r\n    SessionData deleted = instance.get(sessionId);\r\n    assertNull(deleted);\r\n}"
}, {
	"Path": "org.pitest.PitMojoIT.shouldGenerateSiteReportWithNonTimestampedHtmlReport",
	"Comment": "verifies that running pit with timestampedreports set to false willcorrectly copy the html report to the site reports directory.",
	"Method": "void shouldGenerateSiteReportWithNonTimestampedHtmlReport(){\r\n    File testDir = prepareSiteTest(\"/pit-site-non-timestamped\");\r\n    verifier.executeGoal(\"site\");\r\n    verifyPitReportTest(testDir);\r\n}"
}, {
	"Path": "ro.pippo.core.route.RouteGroup.bindAll",
	"Comment": "copies all of the attributes from the specified map to this route group.",
	"Method": "RouteGroup bindAll(Map<String, Object> attributes){\r\n    this.attributes.putAll(attributes);\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.getClientAliases",
	"Comment": "return all the available client aliases for the specified key type.",
	"Method": "String[] getClientAliases(String keyType,Principal[] issuers){\r\n    _logger.log(FINE, \"Getting client aliases\");\r\n    return x509KeyManager.getClientAliases(keyType, issuers);\r\n}"
}, {
	"Path": "org.pitest.classinfo.ComputeClassWriter.typeImplements",
	"Comment": "returns true if the given type implements the given interface.",
	"Method": "boolean typeImplements(String type,ClassReader info,String itf){\r\n    final String cleanItf = itf.replace(\".\", \"/\");\r\n    while (!\"java/lang/Object\".equals(type)) {\r\n        final String[] itfs = info.getInterfaces();\r\n        for (final String itf2 : itfs) {\r\n            if (itf2.equals(cleanItf)) {\r\n                return true;\r\n            }\r\n        }\r\n        for (final String itf2 : itfs) {\r\n            if (typeImplements(itf2, typeInfo(itf2), cleanItf)) {\r\n                return true;\r\n            }\r\n        }\r\n        type = info.getSuperName();\r\n        info = typeInfo(type);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.pf4j.util.DirectedGraph.addVertex",
	"Comment": "add a vertex to the graph. nothing happens if vertex is already in graph.",
	"Method": "void addVertex(V vertex){\r\n    if (containsVertex(vertex)) {\r\n        return;\r\n    }\r\n    neighbors.put(vertex, new ArrayList<V>());\r\n}"
}, {
	"Path": "io.advantageous.qbit.reactive.Reactor.wrapCallbackErrorWithTimeout",
	"Comment": "used for quickly delegating one callback to another when the return types are different.this is usually the case if you want to do some transformation of the object and not just return it.",
	"Method": "Callback<T> wrapCallbackErrorWithTimeout(String operationDescription,Callback<T> callback,Callback<?> errorHandler,Logger logger,TimeUnit timeUnit,long timeoutDuration){\r\n    return callbackBuilder().setCallback(new Callback<T>() {\r\n        @Override\r\n        public void accept(T t) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"{} returned {}\", operationDescription, t);\r\n            }\r\n            callback.resolve(t);\r\n        }\r\n    }).setOnError(error -> {\r\n        logger.error(String.format(\"ERROR calling %s\", operationDescription), error);\r\n        errorHandler.onError(error);\r\n    }).setOnTimeout(() -> {\r\n        logger.error(\"TIMEOUT calling {}\", operationDescription);\r\n        errorHandler.onTimeout();\r\n    }).withTimeoutTimeUnit(timeUnit).setTimeoutDuration(timeoutDuration).build();\r\n}"
}, {
	"Path": "io.advantageous.qbit.reactive.Reactor.wrapCallbackErrorWithTimeout",
	"Comment": "used for quickly delegating one callback to another when the return types are different.this is usually the case if you want to do some transformation of the object and not just return it.",
	"Method": "Callback<T> wrapCallbackErrorWithTimeout(String operationDescription,Callback<T> callback,Callback<?> errorHandler,Logger logger,TimeUnit timeUnit,long timeoutDuration){\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"{} returned {}\", operationDescription, t);\r\n    }\r\n    callback.resolve(t);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.common.PasswordCredential.hashCode",
	"Comment": "return the hashcode computed from the password and realm name.",
	"Method": "int hashCode(){\r\n    return username.hashCode() + Arrays.hashCode(password) + realm.hashCode();\r\n}"
}, {
	"Path": "org.pitest.mutationtest.MutationStatusTestPair.getSucceedingTests",
	"Comment": "get all succeeding tests. if the full mutation matrix is not enabled, this list will be empty.",
	"Method": "List<String> getSucceedingTests(){\r\n    return succeedingTests;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.audit.BaseAuditManager.addAuditModule",
	"Comment": "add the given audit module to the list of loaded audit module.adding the same name twice will override previous one.",
	"Method": "BaseAuditModule addAuditModule(String name,String classname,Properties props){\r\n    removeAuditModule(name);\r\n    BaseAuditModule am = loadAuditModule(classname, props);\r\n    moduleToNameMap.put(am, name);\r\n    nameToModuleMap.put(name, am);\r\n    instances = copyAndAdd(instances, am);\r\n    if (isAuditModuleOfParameterizedType(am)) {\r\n        typedModules = copyAndAdd(typedModules, (T) am);\r\n    }\r\n    return am;\r\n}"
}, {
	"Path": "ro.pippo.core.route.Route.bindAll",
	"Comment": "copies all of the attributes from the specified map to this route.",
	"Method": "Route bindAll(Map<String, Object> attributes){\r\n    this.attributes.putAll(attributes);\r\n    return this;\r\n}"
}, {
	"Path": "io.advantageous.qbit.boon.spi.BoonJsonMapper.fromJson",
	"Comment": "convert from json string using class as a suggestion for how to do the parse.",
	"Method": "Object fromJson(String json,T fromJson,String json,Class<T> cls){\r\n    return parser.get().parse(cls, json);\r\n}"
}, {
	"Path": "io.advantageous.qbit.events.EventBusQueueAdapter.process",
	"Comment": "process. this can be called periodically and it will check to see if there are messages on the queue.",
	"Method": "void process(){\r\n    if (!receiveQueue.isPresent()) {\r\n        initQueue();\r\n    }\r\n    receiveQueue.ifPresent(receiveQueue -> {\r\n        T item;\r\n        do {\r\n            try {\r\n                item = receiveQueue.poll();\r\n            } catch (Exception ex) {\r\n                logger.debug(\"Unable to receive message\", ex);\r\n                initQueue();\r\n                item = null;\r\n            }\r\n            if (item != null) {\r\n                sendToEventManager(item);\r\n            }\r\n        } while (item != null);\r\n    });\r\n}"
}, {
	"Path": "ro.pippo.session.infinispan.InfinispanSessionDataStorageTest.testSave",
	"Comment": "test of save method, of class infinispansessiondatastorage.",
	"Method": "void testSave(){\r\n    System.out.println(\"save\");\r\n    InfinispanSessionDataStorage instance = new InfinispanSessionDataStorage(cacheManager);\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    instance.save(sessionData);\r\n    SessionData saved = instance.get(sessionId);\r\n    assertEquals(sessionData, saved);\r\n    String value1 = sessionData.get(KEY);\r\n    String value2 = saved.get(KEY);\r\n    assertEquals(value1, value2);\r\n}"
}, {
	"Path": "com.rabbitmq.client.impl.ConnectionParams.getTopologyRecoveryExecutor",
	"Comment": "get the topology recovery executor. if null, the main connection thread should be used.",
	"Method": "ExecutorService getTopologyRecoveryExecutor(){\r\n    return topologyRecoveryExecutor;\r\n}"
}, {
	"Path": "picocli.groovy.PicocliBaseScript.printErrorMessage",
	"Comment": "error messages that arise from command line processing call this.the default is to print to system.err.if you want to use system.out, a logger, or something else, this is the method to override.",
	"Method": "void printErrorMessage(String message){\r\n    System.err.println(message);\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.Game.resetState",
	"Comment": "reset the game state to a lobby.todo change the message sent to the client if the game reset due to insufficient players.",
	"Method": "void resetState(boolean lostPlayer){\r\n    logger.info(String.format(\"Resetting game %d to lobby (lostPlayer=%b)\", id, lostPlayer));\r\n    killRoundTimer();\r\n    synchronized (players) {\r\n        for (final Player player : players) {\r\n            player.getHand().clear();\r\n            player.resetScore();\r\n        }\r\n    }\r\n    whiteDeck = null;\r\n    blackDeck = null;\r\n    synchronized (blackCardLock) {\r\n        blackCard = null;\r\n    }\r\n    playedCards.clear();\r\n    roundPlayers.clear();\r\n    state = GameState.LOBBY;\r\n    currentUniqueId = null;\r\n    final Player judge = getJudge();\r\n    judgeIndex = 0;\r\n    final HashMap<ReturnableData, Object> data = getEventMap();\r\n    data.put(LongPollResponse.EVENT, LongPollEvent.GAME_STATE_CHANGE.toString());\r\n    data.put(LongPollResponse.GAME_STATE, GameState.LOBBY.toString());\r\n    broadcastToPlayers(MessageType.GAME_EVENT, data);\r\n    if (host != null) {\r\n        notifyPlayerInfoChange(host);\r\n    }\r\n    if (judge != null) {\r\n        notifyPlayerInfoChange(judge);\r\n    }\r\n    gameManager.broadcastGameListRefresh();\r\n}"
}, {
	"Path": "io.advantageous.qbit.reactive.CallbackBuilder.withOptionalStringCallback",
	"Comment": "builder method to set callback handler that takes an optional string",
	"Method": "CallbackBuilder withOptionalStringCallback(Callback<Optional<String>> callback){\r\n    this.callback = callback;\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.BaseRealm.getGroupNames",
	"Comment": "returns names of all the groups in this particular realm.this method always throws a badrealmexception since by default this operation is not supported. subclasses whichsupport this method can override.",
	"Method": "Enumeration<String> getGroupNames(){\r\n    throw new BadRealmException(sm.getString(\"iasrealm.notsupported\"));\r\n}"
}, {
	"Path": "ro.pippo.core.websocket.AbstractWebSocketFilter.getTokensFromHeader",
	"Comment": "this only works for tokens. quoted strings need more sophisticated parsing.",
	"Method": "List<String> getTokensFromHeader(Request request,String headerName){\r\n    List<String> result = new ArrayList();\r\n    Enumeration<String> headers = request.getHeaders(headerName);\r\n    while (headers.hasMoreElements()) {\r\n        String header = headers.nextElement();\r\n        String[] tokens = header.split(\",\");\r\n        for (String token : tokens) {\r\n            result.add(token.trim());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.Value.isPrimitive",
	"Comment": "provides check for verifying if this value is a primitive or not.",
	"Method": "boolean isPrimitive(){\r\n    return this instanceof Primitive;\r\n}"
}, {
	"Path": "com.rabbitmq.client.ConnectionFactory.setCredentialsProvider",
	"Comment": "set a custom credentials provider.default implementation uses static username and password.",
	"Method": "void setCredentialsProvider(CredentialsProvider credentialsProvider){\r\n    this.credentialsProvider = credentialsProvider;\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.AuthenticationServiceImpl.setupPasswordCredential",
	"Comment": "a passwordcredential object is needed when using the existing realm loginmodules.\tunless the callbackhandler is from the authenticationservice obtain the name\tand password from the supplied jaas callbackhandler directly. establishing the\tpasswordcredential in the subject is determined by service configuration.",
	"Method": "void setupPasswordCredential(Subject subject,CallbackHandler callbackHandler){\r\n    String username = null;\r\n    char[] password = null;\r\n    if (callbackHandler instanceof AuthenticationCallbackHandler) {\r\n        username = ((AuthenticationCallbackHandler) callbackHandler).getUsername();\r\n        password = ((AuthenticationCallbackHandler) callbackHandler).getPassword();\r\n    } else {\r\n        Callback[] callbacks = new Callback[2];\r\n        callbacks[0] = new NameCallback(\"username: \");\r\n        callbacks[1] = new PasswordCallback(\"password: \", false);\r\n        try {\r\n            callbackHandler.handle(callbacks);\r\n            username = ((NameCallback) callbacks[0]).getName();\r\n            password = ((PasswordCallback) callbacks[1]).getPassword();\r\n        } catch (IOException ioe) {\r\n            throw (LoginException) new LoginException(\"AuthenticationService unable to create PasswordCredential: \" + ioe.getMessage()).initCause(ioe);\r\n        } catch (UnsupportedCallbackException uce) {\r\n            throw (LoginException) new LoginException(\"AuthenticationService unable to create PasswordCredential: \" + uce.getMessage()).initCause(uce);\r\n        }\r\n    }\r\n    final Subject s = subject;\r\n    final PasswordCredential pc = new PasswordCredential(username, password, realmName);\r\n    AppservAccessController.doPrivileged(new PrivilegedAction<Object>() {\r\n        public Object run() {\r\n            s.getPrivateCredentials().add(pc);\r\n            return null;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.AuthenticationServiceImpl.setupPasswordCredential",
	"Comment": "a passwordcredential object is needed when using the existing realm loginmodules.\tunless the callbackhandler is from the authenticationservice obtain the name\tand password from the supplied jaas callbackhandler directly. establishing the\tpasswordcredential in the subject is determined by service configuration.",
	"Method": "void setupPasswordCredential(Subject subject,CallbackHandler callbackHandler){\r\n    s.getPrivateCredentials().add(pc);\r\n    return null;\r\n}"
}, {
	"Path": "ro.pippo.core.PippoSettings.interpolateString",
	"Comment": "interpolates a string value using system properties and environment variables.",
	"Method": "String interpolateString(String value){\r\n    String interpolatedValue = value;\r\n    for (Map.Entry<String, String> entry : interpolationValues.entrySet()) {\r\n        interpolatedValue = interpolatedValue.replace(entry.getKey(), entry.getValue());\r\n    }\r\n    return interpolatedValue;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.impl.SecuritySupportImpl.getTrustStores",
	"Comment": "this method returns an array of truststores containing certificates.",
	"Method": "KeyStore[] getTrustStores(){\r\n    List<KeyStore> trustStoresList = trustStores.get(DEFAULT_MAP_KEY);\r\n    return trustStoresList.toArray(new KeyStore[trustStoresList.size()]);\r\n}"
}, {
	"Path": "ro.pippo.session.mongodb.MongoDBSessionDataStorageTest.testCreate",
	"Comment": "test of create method, of class mongodbsessiondatastorage.",
	"Method": "void testCreate(){\r\n    System.out.println(\"create\");\r\n    MongoDBSessionDataStorage instance = new MongoDBSessionDataStorage(mongoClient.getDatabase(DATABASE_NAME));\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    SessionData saved = instance.get(sessionId);\r\n    assertEquals(sessionData, saved);\r\n    String value1 = sessionData.get(KEY);\r\n    String value2 = saved.get(KEY);\r\n    assertEquals(value1, value2);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.common.ClientSecurityContext.getCallerPrincipal",
	"Comment": "this method returns the caller principal. this information may be redundant since the sameinformation can be inferred by inspecting the credentials of the caller.",
	"Method": "Principal getCallerPrincipal(){\r\n    return initiator;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.ApnsClientBuilder.setMetricsListener",
	"Comment": "sets the metrics listener for the client under construction. metrics listeners gather information that describesthe performance and behavior of a client, and are completely optional.",
	"Method": "ApnsClientBuilder setMetricsListener(ApnsClientMetricsListener metricsListener){\r\n    this.metricsListener = metricsListener;\r\n    return this;\r\n}"
}, {
	"Path": "io.advantageous.qbit.server.HttpRequestServiceServerHandlerUsingMetaImpl.handleResponseFromServiceToHttpResponse",
	"Comment": "2nd most important method for debugging why something is not called.",
	"Method": "void handleResponseFromServiceToHttpResponse(Response<Object> response,HttpRequest originatingRequest){\r\n    final String key = Str.add(\"\" + originatingRequest.id(), \"|\", originatingRequest.returnAddress());\r\n    this.outstandingRequestMap.remove(key);\r\n    if (response.wasErrors()) {\r\n        handleError(response, originatingRequest);\r\n    } else {\r\n        if (response.body() instanceof HttpResponse) {\r\n            writeHttpResponse(originatingRequest.getReceiver(), ((HttpResponse) response.body()));\r\n        } else {\r\n            final RequestMetaData requestMetaData = metaDataProviderMap.get(RequestMethod.valueOf(originatingRequest.getMethod())).get(originatingRequest.address());\r\n            final ServiceMethodMeta serviceMethodMeta = requestMetaData.getMethod();\r\n            final int responseCode = serviceMethodMeta.getResponseCode();\r\n            MultiMap<String, String> headers = response.headers();\r\n            if (requestMetaData.getRequest().hasResponseHeaders()) {\r\n                if (response.headers() == MultiMap.EMPTY) {\r\n                    headers = new MultiMapImpl();\r\n                } else {\r\n                    headers = response.headers();\r\n                }\r\n                headers.putAllCopyLists(requestMetaData.getRequest().getResponseHeaders());\r\n            }\r\n            writeResponse(originatingRequest.getReceiver(), responseCode == -1 ? HttpStatus.OK : responseCode, serviceMethodMeta.getContentType(), jsonMapper.toJson(response.body()), headers);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.ClientCertificateLoginModule.login",
	"Comment": "authenticate the user by prompting for a username and password.",
	"Method": "boolean login(){\r\n    if (callbackHandler == null) {\r\n        throw new LoginException(\"Error: no CallbackHandler available \" + \"to garner authentication information from the user\");\r\n    }\r\n    try {\r\n        String[] certificateNames = new String[keyStore.size()];\r\n        String[] aliasNames = new String[keyStore.size()];\r\n        Enumeration<String> aliases = keyStore.aliases();\r\n        for (int i = 0; i < keyStore.size(); i++) {\r\n            aliasNames[i] = aliases.nextElement();\r\n            certificateNames[i] = ((X509Certificate) keyStore.getCertificate(aliasNames[i])).getSubjectDN().getName();\r\n        }\r\n        Callback[] callbacks = new Callback[] { createChoiceCallback(certificateNames) };\r\n        callbackHandler.handle(callbacks);\r\n        int[] selectedIndexes = ((ChoiceCallback) callbacks[0]).getSelectedIndexes();\r\n        if (selectedIndexes == null) {\r\n            throw new LoginException(\"No certificate selected!\");\r\n        } else if (selectedIndexes[0] == -1) {\r\n            throw new LoginException(\"Incorrect keystore password\");\r\n        }\r\n        if (debug && _logger.isLoggable(FINE)) {\r\n            _logger.log(FINE, \"\\t\\t[ClientCertificateLoginModule] \" + \"user entered certificate: \");\r\n            for (int i = 0; i < selectedIndexes.length; i++) {\r\n                _logger.log(FINE, aliasNames[selectedIndexes[i]]);\r\n            }\r\n        }\r\n        alias = aliasNames[selectedIndexes[0]];\r\n        certificate = (X509Certificate) keyStore.getCertificate(alias);\r\n        if (debug && _logger.isLoggable(FINE)) {\r\n            _logger.log(FINE, \"\\t\\t[ClientCertificateLoginModule] \" + \"authentication succeeded\");\r\n        }\r\n        succeeded = true;\r\n        return true;\r\n    } catch (IOException ioe) {\r\n        throw new LoginException(ioe.toString());\r\n    } catch (UnsupportedCallbackException uce) {\r\n        throw new LoginException(\"Error: \" + uce.getCallback().toString() + \" not available to garner authentication information \" + \"from the user\");\r\n    } catch (Exception e) {\r\n        throw new LoginException(e.toString());\r\n    }\r\n}"
}, {
	"Path": "io.nayuki.qrcodegen.QrCodeGeneratorDemo.doBasicDemo",
	"Comment": "creates a single qr code, then writes it to a png file and an svg file.",
	"Method": "void doBasicDemo(){\r\n    String text = \"Hello, world!\";\r\n    QrCode.Ecc errCorLvl = QrCode.Ecc.LOW;\r\n    QrCode qr = QrCode.encodeText(text, errCorLvl);\r\n    BufferedImage img = qr.toImage(10, 4);\r\n    File imgFile = new File(\"hello-world-QR.png\");\r\n    ImageIO.write(img, \"png\", imgFile);\r\n    String svg = qr.toSvgString(4);\r\n    File svgFile = new File(\"hello-world-QR.svg\");\r\n    // Write image to file\r\n    Files.write(svgFile.toPath(), svg.getBytes(StandardCharsets.UTF_8));\r\n}"
}, {
	"Path": "io.advantageous.qbit.server.ServiceEndpointServer.addServiceWithQueueCallBackHandlers",
	"Comment": "add a service with no address but that has a one or more queue callback handlers.",
	"Method": "ServiceEndpointServer addServiceWithQueueCallBackHandlers(Object serviceObject,QueueCallBackHandler queueCallBackHandlers){\r\n    throw new IllegalStateException(\"Not implemented\");\r\n}"
}, {
	"Path": "ro.pippo.core.PippoSettings.getLongs",
	"Comment": "returns a list of longs from the specified name using the specified delimiter.",
	"Method": "List<Long> getLongs(String name,List<Long> getLongs,String name,String delimiter){\r\n    List<String> strings = getStrings(name, delimiter);\r\n    List<Long> longs = new ArrayList(strings.size());\r\n    for (String value : strings) {\r\n        try {\r\n            long i = Long.parseLong(value);\r\n            longs.add(i);\r\n        } catch (NumberFormatException e) {\r\n        }\r\n    }\r\n    return Collections.unmodifiableList(longs);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.ListMessageSecurityProvider.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    secService.getMessageSecurityConfig();\r\n    report.getTopMessagePart().setMessage(localStrings.getLocalString(\"list.message.security.provider.success\", \"list-message-security-providers successful\"));\r\n    report.getTopMessagePart().setChildrenType(\"\");\r\n    for (MessageSecurityConfig msc : secService.getMessageSecurityConfig()) {\r\n        if (authLayer == null) {\r\n            for (ProviderConfig pc : msc.getProviderConfig()) {\r\n                ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n                part.setMessage(pc.getProviderId());\r\n            }\r\n        } else {\r\n            if (msc.getAuthLayer().equals(authLayer)) {\r\n                for (ProviderConfig pc : msc.getProviderConfig()) {\r\n                    ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n                    part.setMessage(pc.getProviderId());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.server.HttpRequestServiceServerHandlerUsingMetaImpl.handleRestCall",
	"Comment": "most important method for debugging why something is not called.",
	"Method": "void handleRestCall(HttpRequest request){\r\n    final List<String> errorList = new ArrayList(0);\r\n    final MethodCall<Object> methodCall = standardRequestTransformer.transform(request, errorList);\r\n    if (methodCall != null && errorList.size() == 0) {\r\n        if (!addRequestToCheckForTimeouts(request)) {\r\n            handleOverflow(request);\r\n            return;\r\n        }\r\n        sendMethodToServiceBundle(methodCall);\r\n    } else {\r\n        if (!request.isHandled()) {\r\n            handleErrorConverting(request, errorList, methodCall);\r\n        }\r\n        return;\r\n    }\r\n    final RequestMetaData requestMetaData = metaDataProviderMap.get(RequestMethod.valueOf(request.getMethod())).get(request.address());\r\n    final ServiceMethodMeta serviceMethod = requestMetaData.getMethod();\r\n    if (serviceMethod.getMethodAccess().returnType() == void.class && !serviceMethod.hasCallBack()) {\r\n        request.handled();\r\n        final int responseCode = serviceMethod.getResponseCode();\r\n        writeResponse(request.getReceiver(), responseCode == -1 ? HttpStatus.ACCEPTED : responseCode, serviceMethod.getContentType(), \"\\\"success\\\"\", requestMetaData.getRequest().getResponseHeaders());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteMessageSecurityProvider.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ActionReport report = context.getActionReport();\r\n    List<ProviderConfig> pcs = msgSecCfg.getProviderConfig();\r\n    for (ProviderConfig pc : pcs) {\r\n        if (pc.getProviderId().equals(providerId)) {\r\n            thePC = pc;\r\n            try {\r\n                ConfigSupport.apply(new SingleConfigCode<MessageSecurityConfig>() {\r\n                    public Object run(MessageSecurityConfig param) throws PropertyVetoException, TransactionFailure {\r\n                        if ((param.getDefaultProvider() != null) && param.getDefaultProvider().equals(thePC.getProviderId())) {\r\n                            param.setDefaultProvider(null);\r\n                        }\r\n                        if ((param.getDefaultClientProvider() != null) && param.getDefaultClientProvider().equals(thePC.getProviderId())) {\r\n                            param.setDefaultClientProvider(null);\r\n                        }\r\n                        param.getProviderConfig().remove(thePC);\r\n                        return null;\r\n                    }\r\n                }, msgSecCfg);\r\n            } catch (TransactionFailure e) {\r\n                e.printStackTrace();\r\n                report.setMessage(localStrings.getLocalString(\"delete.message.security.provider.fail\", \"Deletion of message security provider named {0} failed\", providerId));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                report.setFailureCause(e);\r\n                return;\r\n            }\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteMessageSecurityProvider.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    if ((param.getDefaultProvider() != null) && param.getDefaultProvider().equals(thePC.getProviderId())) {\r\n        param.setDefaultProvider(null);\r\n    }\r\n    if ((param.getDefaultClientProvider() != null) && param.getDefaultClientProvider().equals(thePC.getProviderId())) {\r\n        param.setDefaultClientProvider(null);\r\n    }\r\n    param.getProviderConfig().remove(thePC);\r\n    return null;\r\n}"
}, {
	"Path": "io.advantageous.qbit.reakt.Reakt.convertPromise",
	"Comment": "converts a reakt promise into a qbit callback.reactor is used to manage timeouts and ensure callback happens on same thread as caller.",
	"Method": "Callback<T> convertPromise(Promise<T> promise,Callback<T> convertPromise,Reactor reactor,Promise<T> promise){\r\n    return convertPromiseToCallback(promise, reactor.callbackBuilder());\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.BaseService.recordCount",
	"Comment": "prefixes the stats key with the stat key prefix, and then calls statscollector.recordcount.",
	"Method": "void recordCount(String statKey,long count){\r\n    final String longKey = getActualStatKey(statKey);\r\n    statsCollector.recordCount(longKey, count);\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.lexer.LexerImpl.lexComment",
	"Comment": "tokenizes between comment delimiters.simply find the closing delimiter for the comment and move the cursor to that point.",
	"Method": "void lexComment(){\r\n    Matcher matcher = this.syntax.getRegexCommentClose().matcher(this.source);\r\n    boolean match = matcher.find(0);\r\n    if (!match) {\r\n        throw new ParserException(null, \"Unclosed comment.\", this.source.getLineNumber(), this.source.getFilename());\r\n    }\r\n    String comment = this.source.substring(matcher.start());\r\n    String reversedComment = new StringBuilder(comment).reverse().toString();\r\n    Matcher whitespaceTrimMatcher = this.syntax.getRegexLeadingWhitespaceTrim().matcher(reversedComment);\r\n    if (whitespaceTrimMatcher.lookingAt()) {\r\n        this.trimLeadingWhitespaceFromNextData = true;\r\n    }\r\n    this.source.advance(matcher.end());\r\n    this.popState();\r\n}"
}, {
	"Path": "psiprobe.beans.ContainerListenerBean.initialize",
	"Comment": "load objectnames for the relevant mbeans so they can be queried at a later stage withoutsearching mbean server over and over again.",
	"Method": "void initialize(){\r\n    MBeanServer server = getContainerWrapper().getResourceResolver().getMBeanServer();\r\n    String serverName = getContainerWrapper().getTomcatContainer().getName();\r\n    Set<ObjectInstance> threadPools = server.queryMBeans(new ObjectName(serverName + \":type=ThreadPool,*\"), null);\r\n    poolNames = new ArrayList(threadPools.size());\r\n    for (ObjectInstance threadPool : threadPools) {\r\n        ThreadPoolObjectName threadPoolObjectName = new ThreadPoolObjectName();\r\n        ObjectName threadPoolName = threadPool.getObjectName();\r\n        String name = threadPoolName.getKeyProperty(\"name\");\r\n        threadPoolObjectName.setThreadPoolName(threadPoolName);\r\n        ObjectName grpName = server.getObjectInstance(new ObjectName(threadPoolName.getDomain() + \":type=GlobalRequestProcessor,name=\" + name)).getObjectName();\r\n        threadPoolObjectName.setGlobalRequestProcessorName(grpName);\r\n        Set<ObjectInstance> workers = server.queryMBeans(new ObjectName(threadPoolName.getDomain() + \":type=RequestProcessor,*\"), null);\r\n        for (ObjectInstance worker : workers) {\r\n            ObjectName wrkName = worker.getObjectName();\r\n            if (name.equals(wrkName.getKeyProperty(\"worker\"))) {\r\n                threadPoolObjectName.getRequestProcessorNames().add(wrkName);\r\n            }\r\n        }\r\n        poolNames.add(threadPoolObjectName);\r\n    }\r\n    Set<ObjectInstance> executors = server.queryMBeans(new ObjectName(serverName + \":type=Executor,*\"), null);\r\n    executorNames = new ArrayList(executors.size());\r\n    for (ObjectInstance executor : executors) {\r\n        ObjectName executorName = executor.getObjectName();\r\n        executorNames.add(executorName);\r\n    }\r\n    server.addNotificationListener(new ObjectName(\"JMImplementation:type=MBeanServerDelegate\"), this, null, null);\r\n}"
}, {
	"Path": "io.advantageous.qbit.events.impl.ChannelManager.add",
	"Comment": "add an event listener to the channelthere can only be one consumer and many listeners.",
	"Method": "void add(EventListener<T> eventListener){\r\n    if (eventListener.subscriber()) {\r\n        if (debug)\r\n            logger.debug(\"subscription to channel <> from <> \", name, eventListener);\r\n        listeners.add(eventListener);\r\n        stats.recordLevel(eventBusName + \"::\" + name, listeners.size());\r\n    } else {\r\n        if (debug)\r\n            logger.debug(\"consumer to channel <> from <> \", name, eventListener);\r\n        consumer = eventListener;\r\n    }\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.WhiteDeck.reshuffle",
	"Comment": "shuffles the discard pile and puts the cards under the cards remaining in the deck.",
	"Method": "void reshuffle(){\r\n    Collections.shuffle(discard);\r\n    deck.addAll(0, discard);\r\n    discard.clear();\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.StrictModeTest.testComplexVariable",
	"Comment": "tests that the line number and file name is correctly passed to the exception in strict mode.",
	"Method": "void testComplexVariable(){\r\n    PebbleEngine pebble = new PebbleEngine.Builder().strictVariables(true).build();\r\n    PebbleTemplate template = pebble.getTemplate(\"templates/template.strictModeComplexExpression.peb\");\r\n    Map<String, Object> context = new HashMap();\r\n    Writer writer = new StringWriter();\r\n    try {\r\n        template.evaluate(writer, context);\r\n        Assert.fail(\"Exception \" + RootAttributeNotFoundException.class.getCanonicalName() + \" is expected.\");\r\n    } catch (RootAttributeNotFoundException e) {\r\n        Assert.assertEquals(e.getFileName(), \"templates/template.strictModeComplexExpression.peb\");\r\n        Assert.assertEquals(e.getLineNumber(), (Integer) 2);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.common.X509CertificateCredential.hashCode",
	"Comment": "return the hashcode computed from the certificate, realm and alias.",
	"Method": "int hashCode(){\r\n    return Arrays.hashCode(certChain) + realm.hashCode() + ((alias != null) ? alias.hashCode() : 0);\r\n}"
}, {
	"Path": "io.nayuki.qrcodegen.QrSegmentAdvanced.splitIntoSegments",
	"Comment": "consecutive code points in the same mode are put into the same segment.",
	"Method": "List<QrSegment> splitIntoSegments(int[] codePoints,Mode[] charModes){\r\n    if (codePoints.length == 0)\r\n        throw new IllegalArgumentException();\r\n    List<QrSegment> result = new ArrayList();\r\n    Mode curMode = charModes[0];\r\n    int start = 0;\r\n    for (int i = 1; ; i++) {\r\n        if (i < codePoints.length && charModes[i] == curMode)\r\n            continue;\r\n        String s = new String(codePoints, start, i - start);\r\n        if (curMode == Mode.BYTE)\r\n            result.add(QrSegment.makeBytes(s.getBytes(StandardCharsets.UTF_8)));\r\n        else if (curMode == Mode.NUMERIC)\r\n            result.add(QrSegment.makeNumeric(s));\r\n        else if (curMode == Mode.ALPHANUMERIC)\r\n            result.add(QrSegment.makeAlphanumeric(s));\r\n        else if (curMode == Mode.KANJI)\r\n            result.add(makeKanji(s));\r\n        else\r\n            throw new AssertionError();\r\n        if (i >= codePoints.length)\r\n            return result;\r\n        curMode = charModes[i];\r\n        start = i;\r\n    }\r\n}"
}, {
	"Path": "psiprobe.tools.logging.logback.LogbackFactoryAccessor.getAppenders",
	"Comment": "returns a list of wrappers for all logback appenders that have an associated logger.",
	"Method": "List<LogbackAppenderAccessor> getAppenders(){\r\n    List<LogbackAppenderAccessor> appenders = new ArrayList();\r\n    try {\r\n        Class<? extends Object> clazz = getTarget().getClass();\r\n        Method getLoggerList = MethodUtils.getAccessibleMethod(clazz, \"getLoggerList\");\r\n        List<Object> loggers = (List<Object>) getLoggerList.invoke(getTarget());\r\n        for (Object logger : loggers) {\r\n            LogbackLoggerAccessor accessor = new LogbackLoggerAccessor();\r\n            accessor.setTarget(logger);\r\n            accessor.setApplication(getApplication());\r\n            appenders.addAll(accessor.getAppenders());\r\n        }\r\n    } catch (Exception e) {\r\n        logger.error(\"{}.getLoggerList() failed\", getTarget(), e);\r\n    }\r\n    return appenders;\r\n}"
}, {
	"Path": "io.advantageous.qbit.boon.spi.BoonJsonMapper.convertToMap",
	"Comment": "helper method.converts a value map into a regular map of java basic types.",
	"Method": "V convertToMap(ValueMap valueMap){\r\n    final Map<String, Object> map = new LinkedHashMap(valueMap.size());\r\n    valueMap.entrySet().forEach(new Consumer<Map.Entry<String, Object>>() {\r\n        @Override\r\n        public void accept(Map.Entry<String, Object> entry) {\r\n            Object value = entry.getValue();\r\n            if (value instanceof ValueContainer) {\r\n                ValueContainer valueContainer = ((ValueContainer) entry.getValue());\r\n                value = valueContainer.toValue();\r\n            }\r\n            if (value instanceof Value) {\r\n                map.put(entry.getKey(), ((Value) value).toValue());\r\n            } else if (value instanceof ValueMap) {\r\n                map.put(entry.getKey(), convertToMap(((ValueMap) value)));\r\n            } else if (value instanceof List) {\r\n                map.put(entry.getKey(), convertList(value, mapper.get()));\r\n            } else {\r\n                map.put(entry.getKey(), value);\r\n            }\r\n        }\r\n    });\r\n    return (V) map;\r\n}"
}, {
	"Path": "io.advantageous.qbit.boon.spi.BoonJsonMapper.convertToMap",
	"Comment": "helper method.converts a value map into a regular map of java basic types.",
	"Method": "V convertToMap(ValueMap valueMap){\r\n    Object value = entry.getValue();\r\n    if (value instanceof ValueContainer) {\r\n        ValueContainer valueContainer = ((ValueContainer) entry.getValue());\r\n        value = valueContainer.toValue();\r\n    }\r\n    if (value instanceof Value) {\r\n        map.put(entry.getKey(), ((Value) value).toValue());\r\n    } else if (value instanceof ValueMap) {\r\n        map.put(entry.getKey(), convertToMap(((ValueMap) value)));\r\n    } else if (value instanceof List) {\r\n        map.put(entry.getKey(), convertList(value, mapper.get()));\r\n    } else {\r\n        map.put(entry.getKey(), value);\r\n    }\r\n}"
}, {
	"Path": "ro.pippo.core.Request.getApplicationUriWithQuery",
	"Comment": "returns the uri with the query string relative to the application root path.",
	"Method": "String getApplicationUriWithQuery(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(getApplicationUri());\r\n    if (getQuery() != null) {\r\n        sb.append('?').append(getQuery());\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.JarSigner.retrieveManifest",
	"Comment": "retrieve manifest from jar, create a default template if none exists.",
	"Method": "Manifest retrieveManifest(JarFile jf){\r\n    Manifest manifest = jf.getManifest();\r\n    if (manifest == null) {\r\n        manifest = new Manifest();\r\n        Attributes mainAttributes = manifest.getMainAttributes();\r\n        mainAttributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\r\n        mainAttributes.putValue(\"Created-By\", System.getProperty(\"java.version\") + \" (\" + System.getProperty(\"java.vendor\") + \")\");\r\n    }\r\n    Map<String, Attributes> entriesMap = manifest.getEntries();\r\n    for (Iterator<String> entries = entriesMap.keySet().iterator(); entries.hasNext(); ) {\r\n        if (jf.getJarEntry(entries.next()) == null) {\r\n            entries.remove();\r\n        }\r\n    }\r\n    return manifest;\r\n}"
}, {
	"Path": "org.pushtalk.android.service.TalkReceiver.unreadMessage",
	"Comment": "when received message, increase unread number for recent chat",
	"Method": "void unreadMessage(String friend,String channel){\r\n    new Thread() {\r\n        public void run() {\r\n            String chattingFriend = null;\r\n            if (StringUtils.isEmpty(channel)) {\r\n                chattingFriend = friend;\r\n            }\r\n            Map<String, String> params = new HashMap<String, String>();\r\n            params.put(\"udid\", Config.udid);\r\n            params.put(\"friend\", chattingFriend);\r\n            params.put(\"channel_name\", channel);\r\n            try {\r\n                HttpHelper.post(Constants.PATH_UNREAD, params);\r\n            } catch (Exception e) {\r\n                Logger.e(TAG, \"Call pushtalk api to report unread error\", e);\r\n            }\r\n        }\r\n    }.start();\r\n}"
}, {
	"Path": "org.pushtalk.android.service.TalkReceiver.unreadMessage",
	"Comment": "when received message, increase unread number for recent chat",
	"Method": "void unreadMessage(String friend,String channel){\r\n    String chattingFriend = null;\r\n    if (StringUtils.isEmpty(channel)) {\r\n        chattingFriend = friend;\r\n    }\r\n    Map<String, String> params = new HashMap<String, String>();\r\n    params.put(\"udid\", Config.udid);\r\n    params.put(\"friend\", chattingFriend);\r\n    params.put(\"channel_name\", channel);\r\n    try {\r\n        HttpHelper.post(Constants.PATH_UNREAD, params);\r\n    } catch (Exception e) {\r\n        Logger.e(TAG, \"Call pushtalk api to report unread error\", e);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.initialize",
	"Comment": "initialize the security service instance with the specific security service configuration.",
	"Method": "void initialize(SecurityConfiguration securityServiceConfiguration){\r\n    if (InitializationState.NOT_INITIALIZED != initialized) {\r\n        return;\r\n    }\r\n    try {\r\n        if (!(securityServiceConfiguration instanceof org.glassfish.security.services.config.AuthorizationService)) {\r\n            throw new IllegalStateException(localStrings.getLocalString(\"service.atz.not_config\", \"The Authorization service is not configured in the domain configuration file.\"));\r\n        }\r\n        atzSvCfg = (org.glassfish.security.services.config.AuthorizationService) securityServiceConfiguration;\r\n        List<SecurityProvider> providersConfig = atzSvCfg.getSecurityProviders();\r\n        if ((providersConfig == null) || ((atzPrvConfig = providersConfig.get(0)) == null)) {\r\n            throw new IllegalStateException(localStrings.getLocalString(\"service.atz.no_prov_config\", \"No provider configured for the Authorization service in the domain configuration file.\"));\r\n        }\r\n        final String providerName = atzPrvConfig.getName();\r\n        if (isDebug()) {\r\n            logger.log(DEBUG_LEVEL, \"Attempting to get Authorization provider \\\"{0}\\\".\", providerName);\r\n        }\r\n        provider = AccessController.doPrivileged(new PrivilegedLookup<AuthorizationProvider>(serviceLocator, AuthorizationProvider.class, providerName));\r\n        if (provider == null) {\r\n            throw new IllegalStateException(localStrings.getLocalString(\"service.atz.not_provider\", \"Authorization Provider {0} not found.\", providerName));\r\n        }\r\n        provider.initialize(atzPrvConfig);\r\n        initialized = InitializationState.SUCCESS_INIT;\r\n        reasonInitFailed = null;\r\n        logger.log(Level.FINE, ATZSVC_INITIALIZED);\r\n    } catch (Exception e) {\r\n        String eMsg = e.getMessage();\r\n        String eClass = e.getClass().getName();\r\n        reasonInitFailed = localStrings.getLocalString(\"service.atz.init_failed\", \"Authorization Service initialization failed, exception {0}, message {1}\", eClass, eMsg);\r\n        logger.log(Level.WARNING, ATZSVC_INIT_FAILED, new Object[] { eClass, eMsg });\r\n        throw new RuntimeException(reasonInitFailed, e);\r\n    } finally {\r\n        if (InitializationState.SUCCESS_INIT != initialized) {\r\n            initialized = InitializationState.FAILED_INIT;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.BlackDeck.reshuffle",
	"Comment": "shuffles the discard pile and puts the cards under the cards remaining in the deck.",
	"Method": "void reshuffle(){\r\n    Collections.shuffle(discard);\r\n    deck.addAll(0, discard);\r\n    discard.clear();\r\n}"
}, {
	"Path": "com.turo.pushy.apns.util.ApnsPayloadBuilder.setMutableContent",
	"Comment": "sets whether the receiving device may modify the content of the push notification before displaying it. requiresios 10 or newer.",
	"Method": "ApnsPayloadBuilder setMutableContent(boolean mutableContent){\r\n    this.mutableContent = mutableContent;\r\n    return this;\r\n}"
}, {
	"Path": "io.nayuki.qrcodegen.QrCode.drawCodewords",
	"Comment": "data area of this qr code. function modules need to be marked off before this is called.",
	"Method": "void drawCodewords(byte[] data){\r\n    Objects.requireNonNull(data);\r\n    if (data.length != getNumRawDataModules(version) / 8)\r\n        throw new IllegalArgumentException();\r\n    int i = 0;\r\n    for (int right = size - 1; right >= 1; right -= 2) {\r\n        if (right == 6)\r\n            right = 5;\r\n        for (int vert = 0; vert < size; vert++) {\r\n            for (int j = 0; j < 2; j++) {\r\n                int x = right - j;\r\n                boolean upward = ((right + 1) & 2) == 0;\r\n                int y = upward ? size - 1 - vert : vert;\r\n                if (!isFunction[y][x] && i < data.length * 8) {\r\n                    modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    assert i == data.length * 8;\r\n}"
}, {
	"Path": "io.advantageous.qbit.boon.client.BoonClient.createHandler",
	"Comment": "create an async handler. uses some generics reflection to see what the actual type is",
	"Method": "Callback createHandler(Class<T> serviceInterface,MethodCall call,Callback handler){\r\n    final ClassMeta<T> clsMeta = ClassMeta.classMeta(serviceInterface);\r\n    final MethodAccess method = clsMeta.method(call.name());\r\n    Class<?> returnType = null;\r\n    Class<?> compType = null;\r\n    if (Promise.class.isAssignableFrom(method.returnType())) {\r\n        Type t0 = method.method().getGenericReturnType();\r\n        if (t0 instanceof ParameterizedType) {\r\n            ParameterizedType parameterizedType = ((ParameterizedType) t0);\r\n            Type type = ((parameterizedType != null ? parameterizedType.getActualTypeArguments().length : 0) > 0 ? (parameterizedType != null ? parameterizedType.getActualTypeArguments() : new Type[0])[0] : null);\r\n            if (type instanceof ParameterizedType) {\r\n                returnType = (Class) ((ParameterizedType) type).getRawType();\r\n                final Type type1 = ((ParameterizedType) type).getActualTypeArguments()[0];\r\n                if (type1 instanceof Class) {\r\n                    compType = (Class) type1;\r\n                }\r\n            } else if (type instanceof Class) {\r\n                returnType = (Class<?>) type;\r\n            }\r\n        }\r\n    } else {\r\n        if (method.parameterTypes().length > 0) {\r\n            Type[] genericParameterTypes = method.getGenericParameterTypes();\r\n            ParameterizedType parameterizedType = genericParameterTypes.length > 0 ? (ParameterizedType) genericParameterTypes[0] : null;\r\n            Type type = ((parameterizedType != null ? parameterizedType.getActualTypeArguments().length : 0) > 0 ? (parameterizedType != null ? parameterizedType.getActualTypeArguments() : new Type[0])[0] : null);\r\n            if (type instanceof ParameterizedType) {\r\n                returnType = (Class) ((ParameterizedType) type).getRawType();\r\n                final Type type1 = ((ParameterizedType) type).getActualTypeArguments()[0];\r\n                if (type1 instanceof Class) {\r\n                    compType = (Class) type1;\r\n                }\r\n            } else if (type instanceof Class) {\r\n                returnType = (Class<?>) type;\r\n            }\r\n        }\r\n    }\r\n    final Class<?> actualReturnType = returnType;\r\n    final Class<?> componentClass = compType;\r\n    return new Callback<Object>() {\r\n        @Override\r\n        public void accept(Object event) {\r\n            if (actualReturnType != null) {\r\n                if (componentClass != null && actualReturnType == List.class) {\r\n                    try {\r\n                        event = MapObjectConversion.convertListOfMapsToObjects(componentClass, (List) event);\r\n                    } catch (Exception ex) {\r\n                        if (event instanceof CharSequence) {\r\n                            String errorMessage = event.toString();\r\n                            if (errorMessage.startsWith(\"java.lang.IllegalState\")) {\r\n                                handler.onError(new IllegalStateException(errorMessage));\r\n                                return;\r\n                            } else {\r\n                                handler.onError(new IllegalStateException(\"Conversion error\"));\r\n                                return;\r\n                            }\r\n                        } else {\r\n                            handler.onError(new IllegalStateException(\"Conversion error\"));\r\n                            return;\r\n                        }\r\n                    }\r\n                } else {\r\n                    switch(actualReturnType.getName()) {\r\n                        case \"java.lang.Boolean\":\r\n                            if (event instanceof Value) {\r\n                                event = ((Value) event).booleanValue();\r\n                            } else {\r\n                                event = Conversions.coerce(actualReturnType, event);\r\n                            }\r\n                            break;\r\n                        default:\r\n                            event = Conversions.coerce(actualReturnType, event);\r\n                    }\r\n                }\r\n                handler.accept(event);\r\n            }\r\n        }\r\n        @Override\r\n        public void onError(Throwable error) {\r\n            handler.onError(error);\r\n        }\r\n        @Override\r\n        public void onTimeout() {\r\n            handler.onTimeout();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.advantageous.qbit.boon.client.BoonClient.createHandler",
	"Comment": "create an async handler. uses some generics reflection to see what the actual type is",
	"Method": "Callback createHandler(Class<T> serviceInterface,MethodCall call,Callback handler){\r\n    if (actualReturnType != null) {\r\n        if (componentClass != null && actualReturnType == List.class) {\r\n            try {\r\n                event = MapObjectConversion.convertListOfMapsToObjects(componentClass, (List) event);\r\n            } catch (Exception ex) {\r\n                if (event instanceof CharSequence) {\r\n                    String errorMessage = event.toString();\r\n                    if (errorMessage.startsWith(\"java.lang.IllegalState\")) {\r\n                        handler.onError(new IllegalStateException(errorMessage));\r\n                        return;\r\n                    } else {\r\n                        handler.onError(new IllegalStateException(\"Conversion error\"));\r\n                        return;\r\n                    }\r\n                } else {\r\n                    handler.onError(new IllegalStateException(\"Conversion error\"));\r\n                    return;\r\n                }\r\n            }\r\n        } else {\r\n            switch(actualReturnType.getName()) {\r\n                case \"java.lang.Boolean\":\r\n                    if (event instanceof Value) {\r\n                        event = ((Value) event).booleanValue();\r\n                    } else {\r\n                        event = Conversions.coerce(actualReturnType, event);\r\n                    }\r\n                    break;\r\n                default:\r\n                    event = Conversions.coerce(actualReturnType, event);\r\n            }\r\n        }\r\n        handler.accept(event);\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.boon.client.BoonClient.createHandler",
	"Comment": "create an async handler. uses some generics reflection to see what the actual type is",
	"Method": "Callback createHandler(Class<T> serviceInterface,MethodCall call,Callback handler){\r\n    handler.onError(error);\r\n}"
}, {
	"Path": "io.advantageous.qbit.boon.client.BoonClient.createHandler",
	"Comment": "create an async handler. uses some generics reflection to see what the actual type is",
	"Method": "Callback createHandler(Class<T> serviceInterface,MethodCall call,Callback handler){\r\n    handler.onTimeout();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.SecurityContext.getCallerPrincipal",
	"Comment": "this method returns the caller principal. this information may be redundant since the same information can beinferred by inspecting the credentials of the caller.",
	"Method": "Principal getCallerPrincipal(){\r\n    return this == defaultSecurityContext ? getDefaultCallerPrincipal() : initiator;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.audit.BaseAuditManager.loadAuditModules",
	"Comment": "this method initializes baseauditmanager which load audit modules andaudit enabled flag",
	"Method": "void loadAuditModules(){\r\n    try {\r\n        SecurityService securityBean = serverContext.getDefaultServices().getService(SecurityService.class, ServerEnvironment.DEFAULT_INSTANCE_NAME);\r\n        assert (securityBean != null);\r\n        boolean auditFlag = Boolean.parseBoolean(securityBean.getAuditEnabled());\r\n        setAuditOn(auditFlag);\r\n        List<com.sun.enterprise.config.serverbeans.AuditModule> am = securityBean.getAuditModule();\r\n        for (com.sun.enterprise.config.serverbeans.AuditModule it : am) {\r\n            try {\r\n                String name = it.getName();\r\n                String classname = it.getClassname();\r\n                Properties p = new Properties();\r\n                p.setProperty(NAME, name);\r\n                p.setProperty(CLASSNAME, classname);\r\n                List<Property> ep = it.getProperty();\r\n                for (Property prop : ep) {\r\n                    p.setProperty(prop.getName(), prop.getValue());\r\n                }\r\n                BaseAuditModule auditModule = loadAuditModule(classname, p);\r\n                instances.add(auditModule);\r\n                moduleToNameMap.put(auditModule, name);\r\n                nameToModuleMap.put(name, auditModule);\r\n                if (isAuditModuleOfParameterizedType(auditModule)) {\r\n                    typedModules.add((T) auditModule);\r\n                }\r\n            } catch (Exception ex) {\r\n                String msg = _localStrings.getLocalString(\"auditmgr.loaderror\", \"Audit: Cannot load AuditModule = {0}\", new Object[] { it.getName() });\r\n                _logger.log(Level.WARNING, msg, ex);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        String msg = _localStrings.getLocalString(\"auditmgr.badinit\", \"Audit: Cannot load Audit Module Initialization information. AuditModules will not be loaded.\");\r\n        _logger.log(Level.WARNING, msg, e);\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.discovery.ServiceDiscovery.registerWithIdAndTTLAndTags",
	"Comment": "register an end point given an id, and a ttl with tags.this gets used if you want to be specific about what you call the service.",
	"Method": "EndpointDefinition registerWithIdAndTTLAndTags(String serviceName,String serviceId,String host,int port,int timeToLiveSeconds,List<String> endpointTags){\r\n    return new EndpointDefinition(HealthStatus.PASS, serviceId, serviceName, host, port, timeToLiveSeconds, endpointTags);\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.Value.isObject",
	"Comment": "provides check for verifying if this value is a object or not.",
	"Method": "boolean isObject(){\r\n    return this instanceof ObjectValue;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.getManagerFromToken",
	"Comment": "find the corresponding x509keymanager associated to token in alias. it returns null if there is n",
	"Method": "X509KeyManager getManagerFromToken(String tokenAlias){\r\n    X509KeyManager keyMgr = null;\r\n    int ind = -1;\r\n    if (supportTokenAlias && tokenAlias != null && (ind = tokenAlias.indexOf(':')) != -1) {\r\n        String tokenName = alias.substring(0, ind);\r\n        keyMgr = tokenName2MgrMap.get(tokenName);\r\n    }\r\n    return keyMgr;\r\n}"
}, {
	"Path": "com.rabbitmq.client.ConnectionFactory.getThreadFactory",
	"Comment": "retrieve the thread factory used to instantiate new threads.",
	"Method": "ThreadFactory getThreadFactory(){\r\n    return threadFactory;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.SSLUtils.isKeyAvailable",
	"Comment": "this method checks whether a private key is available or not.",
	"Method": "boolean isKeyAvailable(){\r\n    return hasKey;\r\n}"
}, {
	"Path": "ro.pippo.session.hazelcast.HazelcastSessionDataStorageTest.testGet",
	"Comment": "test of get method, of class hazelcastsessiondatastorage.",
	"Method": "void testGet(){\r\n    System.out.println(\"get\");\r\n    HazelcastSessionDataStorage instance = new HazelcastSessionDataStorage(Hazelcast.newHazelcastInstance());\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    SessionData saved = instance.get(sessionId);\r\n    assertEquals(sessionData, saved);\r\n    String value1 = sessionData.get(KEY);\r\n    String value2 = saved.get(KEY);\r\n    assertEquals(value1, value2);\r\n}"
}, {
	"Path": "io.nayuki.qrcodegen.QrSegmentAdvanced.computeCharacterModes",
	"Comment": "returns a new array representing the optimal mode per code point based on the given text and version.",
	"Method": "Mode[] computeCharacterModes(int[] codePoints,int version){\r\n    if (codePoints.length == 0)\r\n        throw new IllegalArgumentException();\r\n    final Mode[] modeTypes = { Mode.BYTE, Mode.ALPHANUMERIC, Mode.NUMERIC, Mode.KANJI };\r\n    final int numModes = modeTypes.length;\r\n    final int[] headCosts = new int[numModes];\r\n    for (int i = 0; i < numModes; i++) headCosts[i] = (4 + modeTypes[i].numCharCountBits(version)) * 6;\r\n    Mode[][] charModes = new Mode[codePoints.length][numModes];\r\n    int[] prevCosts = headCosts.clone();\r\n    for (int i = 0; i < codePoints.length; i++) {\r\n        int c = codePoints[i];\r\n        int[] curCosts = new int[numModes];\r\n        {\r\n            curCosts[0] = prevCosts[0] + countUtf8Bytes(c) * 8 * 6;\r\n            charModes[i][0] = modeTypes[0];\r\n        }\r\n        if (QrSegment.ALPHANUMERIC_CHARSET.indexOf(c) != -1) {\r\n            curCosts[1] = prevCosts[1] + 33;\r\n            charModes[i][1] = modeTypes[1];\r\n        }\r\n        if ('0' <= c && c <= '9') {\r\n            curCosts[2] = prevCosts[2] + 20;\r\n            charModes[i][2] = modeTypes[2];\r\n        }\r\n        if (isKanji(c)) {\r\n            curCosts[3] = prevCosts[3] + 78;\r\n            charModes[i][3] = modeTypes[3];\r\n        }\r\n        for (int j = 0; j < numModes; j++) {\r\n            for (int k = 0; k < numModes; k++) {\r\n                int newCost = (curCosts[k] + 5) / 6 * 6 + headCosts[j];\r\n                if (charModes[i][k] != null && (charModes[i][j] == null || newCost < curCosts[j])) {\r\n                    curCosts[j] = newCost;\r\n                    charModes[i][j] = modeTypes[k];\r\n                }\r\n            }\r\n        }\r\n        prevCosts = curCosts;\r\n    }\r\n    Mode curMode = null;\r\n    for (int i = 0, minCost = 0; i < numModes; i++) {\r\n        if (curMode == null || prevCosts[i] < minCost) {\r\n            minCost = prevCosts[i];\r\n            curMode = modeTypes[i];\r\n        }\r\n    }\r\n    Mode[] result = new Mode[charModes.length];\r\n    for (int i = result.length - 1; i >= 0; i--) {\r\n        for (int j = 0; j < numModes; j++) {\r\n            if (modeTypes[j] == curMode) {\r\n                curMode = charModes[i][j];\r\n                result[i] = curMode;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.advantageous.qbit.admin.ManagedServiceBuilder.setContextMetaBuilder",
	"Comment": "get the context meta builder. used for things like swagger generation.",
	"Method": "ManagedServiceBuilder setContextMetaBuilder(ContextMetaBuilder contextMetaBuilder){\r\n    this.contextMetaBuilder = contextMetaBuilder;\r\n    return this;\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.sendQueueWithAutoFlush",
	"Comment": "create a wrapper sendqueue that encoders the objects to jsonbefore putting them into the queue.",
	"Method": "SendQueue<T> sendQueueWithAutoFlush(int interval,TimeUnit timeUnit,SendQueue<T> sendQueueWithAutoFlush,PeriodicScheduler periodicScheduler,int interval,TimeUnit timeUnit){\r\n    final SendQueue<String> sendQueue = queue.sendQueueWithAutoFlush(periodicScheduler, interval, timeUnit);\r\n    return createJsonSendQueue(sendQueue);\r\n}"
}, {
	"Path": "ro.pippo.test.PippoRule.getApplication",
	"Comment": "useful in case that you want to mock some services via setters.",
	"Method": "Application getApplication(){\r\n    return pippo.getApplication();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.ClientCertificateLoginModule.logout",
	"Comment": "logout the user.this method removes the principalimpl that was added by the commitmethod.",
	"Method": "boolean logout(){\r\n    ssl = null;\r\n    sslUtils.setAppclientSsl(ssl);\r\n    subject.getPrincipals().remove(userPrincipal);\r\n    succeeded = false;\r\n    commitSucceeded = false;\r\n    alias = null;\r\n    userPrincipal = null;\r\n    return true;\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.TestParallelParsing.testParser",
	"Comment": "tests if the parse is working correctly within a multi threading environment.",
	"Method": "void testParser(){\r\n    final PebbleEngine pebble = new PebbleEngine.Builder().strictVariables(true).extension(new DelayExtension()).build();\r\n    final AtomicReference<String> resultThread1 = new AtomicReference();\r\n    final AtomicReference<String> resultThread2 = new AtomicReference();\r\n    Thread thread1 = new Thread(() -> {\r\n        try {\r\n            PebbleTemplate template = pebble.getTemplate(\"templates/template.parallelParsing1.peb\");\r\n            Writer writer = new StringWriter();\r\n            template.evaluate(writer);\r\n            resultThread1.set(writer.toString());\r\n        } catch (PebbleException | IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    });\r\n    Thread thread2 = new Thread(() -> {\r\n        try {\r\n            PebbleTemplate template = pebble.getTemplate(\"templates/template.parallelParsing2.peb\");\r\n            Writer writer = new StringWriter();\r\n            template.evaluate(writer);\r\n            resultThread2.set(writer.toString());\r\n        } catch (PebbleException | IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    });\r\n    thread1.start();\r\n    thread2.start();\r\n    thread1.join();\r\n    thread2.join();\r\n    assertEquals(\"output in 1: a|output in 1: b|output in 1: c\", resultThread1.get());\r\n    assertEquals(\"output in 2: a|output in 2: b|output in 2: c\", resultThread2.get());\r\n}"
}, {
	"Path": "io.advantageous.qbit.admin.ServiceManagementBundle.recordCount",
	"Comment": "prefixes the stats key with the stat key prefix, and then calls statscollector.recordcount.",
	"Method": "void recordCount(String statKey,long count){\r\n    final String longKey = getActualStatKey(statKey);\r\n    stats.recordCount(longKey, count);\r\n}"
}, {
	"Path": "ro.pippo.core.util.StringUtils.getFileExtension",
	"Comment": "returns the file extension of the value without the dot or an empty string.",
	"Method": "String getFileExtension(String value){\r\n    int index = value.lastIndexOf('.');\r\n    if (index > -1) {\r\n        return value.substring(index + 1);\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.CoreTagsTest.skipGenerationBlock",
	"Comment": "this ensures that block inheritance works properly even if it skips a generation.",
	"Method": "void skipGenerationBlock(){\r\n    PebbleEngine pebble = new PebbleEngine.Builder().strictVariables(false).build();\r\n    PebbleTemplate template = pebble.getTemplate(\"templates/template.skipGenerationBlock1.peb\");\r\n    Writer writer = new StringWriter();\r\n    template.evaluate(writer);\r\n    assertEquals(\"success\", writer.toString());\r\n}"
}, {
	"Path": "picocli.CommandLine.getSeparator",
	"Comment": "returns the string that separates option names from option values when parsing command line options.",
	"Method": "String getSeparator(){\r\n    return getCommandSpec().parser().separator();\r\n}"
}, {
	"Path": "picocli.CommandLine.getUsageHelpWidth",
	"Comment": "returns the maximum width of the usage help message. the default is 80.",
	"Method": "int getUsageHelpWidth(){\r\n    return getCommandSpec().usageMessage().width();\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.Game.maybeAddPermalinkToData",
	"Comment": "adds a permalink to this game to the client request response data, if said permalinks areenabled.",
	"Method": "void maybeAddPermalinkToData(Map<ReturnableData, Object> data){\r\n    if (showGameLinkProvider.get() && null != currentUniqueId) {\r\n        data.put(AjaxResponse.GAME_PERMALINK, String.format(gamePermalinkFormatProvider.get(), currentUniqueId));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteFileUser.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names and thevalues the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    String fileRealmClassName = fileAuthRealm.getClassname();\r\n    if (fileRealmClassName != null && !fileRealmClassName.equals(\"com.sun.enterprise.security.auth.realm.file.FileRealm\")) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.file.user.realmnotsupported\", \"Configured file realm {0} is not supported.\", fileRealmClassName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String keyFile = null;\r\n    for (Property fileProp : fileAuthRealm.getProperty()) {\r\n        if (fileProp.getName().equals(\"file\"))\r\n            keyFile = fileProp.getValue();\r\n    }\r\n    final String kFile = keyFile;\r\n    if (keyFile == null) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.file.user.keyfilenotfound\", \"There is no physical file associated with this file realm {0} \", authRealmName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    boolean exists = (new File(kFile)).exists();\r\n    if (!exists) {\r\n        report.setMessage(localStrings.getLocalString(\"file.realm.keyfilenonexistent\", \"The specified physical file {0} associated with the file realm {1} does not exist.\", new Object[] { kFile, authRealmName }));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<SecurityService>() {\r\n            public Object run(SecurityService param) throws PropertyVetoException, TransactionFailure {\r\n                try {\r\n                    realmsManager.createRealms(config);\r\n                    final FileRealm fr = (FileRealm) realmsManager.getFromLoadedRealms(config.getName(), authRealmName);\r\n                    fr.removeUser(userName);\r\n                    fr.persist();\r\n                    CreateFileUser.refreshRealm(config.getName(), authRealmName);\r\n                    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n                } catch (BadRealmException e) {\r\n                    report.setMessage(localStrings.getLocalString(\"delete.file.user.realmcorrupted\", \"Configured file realm {0} is corrupted.\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n                    report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                    report.setFailureCause(e);\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                    report.setMessage(localStrings.getLocalString(\"delete.file.user.userdeletefailed\", \"Removing User {0} from file realm {1} failed\", userName, authRealmName) + \"  \" + e.getLocalizedMessage());\r\n                    report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                    report.setFailureCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        }, securityService);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.file.user.userdeletefailed\", \"Removing User {0} from file realm {1} failed\", userName, authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteFileUser.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names and thevalues the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    try {\r\n        realmsManager.createRealms(config);\r\n        final FileRealm fr = (FileRealm) realmsManager.getFromLoadedRealms(config.getName(), authRealmName);\r\n        fr.removeUser(userName);\r\n        fr.persist();\r\n        CreateFileUser.refreshRealm(config.getName(), authRealmName);\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (BadRealmException e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.file.user.realmcorrupted\", \"Configured file realm {0} is corrupted.\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        report.setMessage(localStrings.getLocalString(\"delete.file.user.userdeletefailed\", \"Removing User {0} from file realm {1} failed\", userName, authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.advantageous.qbit.logging.SetupMdcForHttpRequestInterceptor.after",
	"Comment": "gets called after a method completes invocation on a service.used to clear the logging mapped diagnostic context.",
	"Method": "boolean after(MethodCall call,Response response){\r\n    MDC.clear();\r\n    return true;\r\n}"
}, {
	"Path": "io.advantageous.qbit.server.ServiceEndpointServerImpl.createResponseQueueListener",
	"Comment": "creates the queue listener for method call responses from the client bundle.",
	"Method": "ReceiveQueueListener<Response<Object>> createResponseQueueListener(){\r\n    return new ReceiveQueueListener<Response<Object>>() {\r\n        @Override\r\n        public void receive(final Response<Object> response) {\r\n            if (debug) {\r\n                logger.debug(\"createResponseQueueListener() Received a response: \" + response);\r\n            }\r\n            handleResponseFromServiceBundle(response, response.request().originatingRequest());\r\n        }\r\n        @Override\r\n        public void limit() {\r\n            httpRequestServerHandler.checkTimeoutsForRequests();\r\n            webSocketHandler.checkResponseBatchSend();\r\n        }\r\n        @Override\r\n        public void empty() {\r\n            httpRequestServerHandler.checkTimeoutsForRequests();\r\n            webSocketHandler.checkResponseBatchSend();\r\n        }\r\n        @Override\r\n        public void idle() {\r\n            httpRequestServerHandler.checkTimeoutsForRequests();\r\n            webSocketHandler.checkResponseBatchSend();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.advantageous.qbit.server.ServiceEndpointServerImpl.createResponseQueueListener",
	"Comment": "creates the queue listener for method call responses from the client bundle.",
	"Method": "ReceiveQueueListener<Response<Object>> createResponseQueueListener(){\r\n    if (debug) {\r\n        logger.debug(\"createResponseQueueListener() Received a response: \" + response);\r\n    }\r\n    handleResponseFromServiceBundle(response, response.request().originatingRequest());\r\n}"
}, {
	"Path": "io.advantageous.qbit.server.ServiceEndpointServerImpl.createResponseQueueListener",
	"Comment": "creates the queue listener for method call responses from the client bundle.",
	"Method": "ReceiveQueueListener<Response<Object>> createResponseQueueListener(){\r\n    httpRequestServerHandler.checkTimeoutsForRequests();\r\n    webSocketHandler.checkResponseBatchSend();\r\n}"
}, {
	"Path": "io.advantageous.qbit.server.ServiceEndpointServerImpl.createResponseQueueListener",
	"Comment": "creates the queue listener for method call responses from the client bundle.",
	"Method": "ReceiveQueueListener<Response<Object>> createResponseQueueListener(){\r\n    httpRequestServerHandler.checkTimeoutsForRequests();\r\n    webSocketHandler.checkResponseBatchSend();\r\n}"
}, {
	"Path": "io.advantageous.qbit.server.ServiceEndpointServerImpl.createResponseQueueListener",
	"Comment": "creates the queue listener for method call responses from the client bundle.",
	"Method": "ReceiveQueueListener<Response<Object>> createResponseQueueListener(){\r\n    httpRequestServerHandler.checkTimeoutsForRequests();\r\n    webSocketHandler.checkResponseBatchSend();\r\n}"
}, {
	"Path": "ro.pippo.session.infinispan.InfinispanSessionDataStorageTest.testGetExpired",
	"Comment": "test of get method, of class infinispansessiondatastorage.",
	"Method": "void testGetExpired(){\r\n    System.out.println(\"get expired\");\r\n    InfinispanSessionDataStorage instance = new InfinispanSessionDataStorage(cacheManager);\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    Thread.sleep(2000L);\r\n    SessionData deleted = instance.get(sessionId);\r\n    assertNull(deleted);\r\n}"
}, {
	"Path": "io.nayuki.qrcodegen.QrCode.getPenaltyScore",
	"Comment": "this is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.",
	"Method": "int getPenaltyScore(){\r\n    int result = 0;\r\n    for (int y = 0; y < size; y++) {\r\n        int[] runHistory = new int[7];\r\n        boolean color = false;\r\n        int runX = 0;\r\n        for (int x = 0; x < size; x++) {\r\n            if (modules[y][x] == color) {\r\n                runX++;\r\n                if (runX == 5)\r\n                    result += PENALTY_N1;\r\n                else if (runX > 5)\r\n                    result++;\r\n            } else {\r\n                addRunToHistory(runX, runHistory);\r\n                if (!color && hasFinderLikePattern(runHistory))\r\n                    result += PENALTY_N3;\r\n                color = modules[y][x];\r\n                runX = 1;\r\n            }\r\n        }\r\n        addRunToHistory(runX, runHistory);\r\n        if (color)\r\n            addRunToHistory(0, runHistory);\r\n        if (hasFinderLikePattern(runHistory))\r\n            result += PENALTY_N3;\r\n    }\r\n    for (int x = 0; x < size; x++) {\r\n        int[] runHistory = new int[7];\r\n        boolean color = false;\r\n        int runY = 0;\r\n        for (int y = 0; y < size; y++) {\r\n            if (modules[y][x] == color) {\r\n                runY++;\r\n                if (runY == 5)\r\n                    result += PENALTY_N1;\r\n                else if (runY > 5)\r\n                    result++;\r\n            } else {\r\n                addRunToHistory(runY, runHistory);\r\n                if (!color && hasFinderLikePattern(runHistory))\r\n                    result += PENALTY_N3;\r\n                color = modules[y][x];\r\n                runY = 1;\r\n            }\r\n        }\r\n        addRunToHistory(runY, runHistory);\r\n        if (color)\r\n            addRunToHistory(0, runHistory);\r\n        if (hasFinderLikePattern(runHistory))\r\n            result += PENALTY_N3;\r\n    }\r\n    for (int y = 0; y < size - 1; y++) {\r\n        for (int x = 0; x < size - 1; x++) {\r\n            boolean color = modules[y][x];\r\n            if (color == modules[y][x + 1] && color == modules[y + 1][x] && color == modules[y + 1][x + 1])\r\n                result += PENALTY_N2;\r\n        }\r\n    }\r\n    int black = 0;\r\n    for (boolean[] row : modules) {\r\n        for (boolean color : row) {\r\n            if (color)\r\n                black++;\r\n        }\r\n    }\r\n    int total = size * size;\r\n    int k = (Math.abs(black * 20 - total * 10) + total - 1) / total - 1;\r\n    result += k * PENALTY_N4;\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.resourcebase.resources.listener.ResourceManager.addListenerToResource",
	"Comment": "add listener to a generic resourceused in the case of create asadmin command when listeners have tobe added to the specific resource",
	"Method": "void addListenerToResource(Object instance){\r\n    ObservableBean bean = null;\r\n    if (instance instanceof Resource) {\r\n        bean = (ObservableBean) ConfigSupport.getImpl((ConfigBeanProxy) instance);\r\n        bean.addListener(this);\r\n    } else if (instance instanceof ResourceRef) {\r\n        bean = (ObservableBean) ConfigSupport.getImpl((ConfigBeanProxy) instance);\r\n        bean.addListener(this);\r\n    }\r\n}"
}, {
	"Path": "ro.pippo.session.EncryptedSessionDataTranscoderTest.test",
	"Comment": "test of encode and decode methods, of class encryptorsessiondatatranscoder.",
	"Method": "void test(){\r\n    System.out.println(\"encode\");\r\n    SessionData sessionData = new DefaultSessionData();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(\"KEY\", \"VALUE\");\r\n    EncryptedSessionDataTranscoder instance = new EncryptedSessionDataTranscoder.Builder().secretKey(\"PasswordPassword\").build();\r\n    String encrypted = instance.encode(sessionData);\r\n    SessionData sessionDataDescrypted = instance.decode(encrypted);\r\n    assertNotNull(sessionDataDescrypted);\r\n    assertEquals(sessionDataDescrypted.getId(), sessionId);\r\n    assertEquals(sessionDataDescrypted.get(\"KEY\"), \"VALUE\");\r\n}"
}, {
	"Path": "org.pitest.maven.ScmMojo.makeConcreteList",
	"Comment": "a bug in maven 2 requires that all list fields declare a concrete list type",
	"Method": "ArrayList<String> makeConcreteList(List<String> list){\r\n    return new ArrayList(list);\r\n}"
}, {
	"Path": "com.rabbitmq.client.impl.CommandAssembler.coalesceContentBody",
	"Comment": "stitches together a fragmented content body into a single byte array",
	"Method": "byte[] coalesceContentBody(){\r\n    if (this.bodyLength == 0)\r\n        return EMPTY_BYTE_ARRAY;\r\n    if (this.bodyN.size() == 1)\r\n        return this.bodyN.get(0);\r\n    byte[] body = new byte[bodyLength];\r\n    int offset = 0;\r\n    for (byte[] fragment : this.bodyN) {\r\n        System.arraycopy(fragment, 0, body, offset, fragment.length);\r\n        offset += fragment.length;\r\n    }\r\n    this.bodyN.clear();\r\n    this.bodyN.add(body);\r\n    return body;\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.Value.isArray",
	"Comment": "provides check for verifying if this value is an array or not.",
	"Method": "boolean isArray(){\r\n    return this instanceof Array;\r\n}"
}, {
	"Path": "ro.pippo.session.xmemcached.XmemcachedSessionDataStorageTest.testDelete",
	"Comment": "test of delete method, of class xmemcachedsessiondatastorage.",
	"Method": "void testDelete(){\r\n    System.out.println(\"delete\");\r\n    XmemcachedSessionDataStorage instance = new XmemcachedSessionDataStorage(client, IDLE_TIME);\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    instance.delete(sessionId);\r\n    SessionData deleted = instance.get(sessionId);\r\n    assertNull(deleted);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.BaseRealm.getUser",
	"Comment": "returns the information recorded about a particular named user.this method always throws a badrealmexception since by default this operation is not supported. subclasses whichsupport this method can override.",
	"Method": "User getUser(String name){\r\n    throw new BadRealmException(sm.getString(\"iasrealm.notsupported\"));\r\n}"
}, {
	"Path": "org.pitest.mutationtest.MutationStatusTestPair.getKillingTest",
	"Comment": "get the killing test.if the full mutation matrix is enabled, the first test will be returned.",
	"Method": "Optional<String> getKillingTest(){\r\n    if (this.killingTests.isEmpty()) {\r\n        return Optional.empty();\r\n    }\r\n    return Optional.of(this.killingTests.get(0));\r\n}"
}, {
	"Path": "com.turo.pushy.apns.server.ServerChannelClassUtil.getServerSocketChannelClass",
	"Comment": "returns a server socket channel class suitable for specified event loop group.",
	"Method": "Class<? extends ServerChannel> getServerSocketChannelClass(EventLoopGroup eventLoopGroup){\r\n    Objects.requireNonNull(eventLoopGroup);\r\n    final String serverSocketChannelClassName = SERVER_SOCKET_CHANNEL_CLASSES.get(eventLoopGroup.getClass().getName());\r\n    if (serverSocketChannelClassName == null) {\r\n        throw new IllegalArgumentException(\"No server socket channel class found for event loop group type: \" + eventLoopGroup.getClass().getName());\r\n    }\r\n    try {\r\n        return Class.forName(serverSocketChannelClassName).asSubclass(ServerChannel.class);\r\n    } catch (final ClassNotFoundException e) {\r\n        throw new IllegalArgumentException(e);\r\n    }\r\n}"
}, {
	"Path": "ro.pippo.session.spymemcached.SpymemcachedSessionDataStorageTest.testGet",
	"Comment": "test of get method, of class spymemcachedsessiondatastorage.",
	"Method": "void testGet(){\r\n    System.out.println(\"get\");\r\n    SpymemcachedSessionDataStorage instance = new SpymemcachedSessionDataStorage(client, IDLE_TIME);\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    SessionData saved = instance.get(sessionId);\r\n    assertEquals(sessionData, saved);\r\n    String value1 = sessionData.get(KEY);\r\n    String value2 = saved.get(KEY);\r\n    assertEquals(value1, value2);\r\n}"
}, {
	"Path": "io.advantageous.qbit.http.HTTP.getWithHeaders",
	"Comment": "get that expects contents back as a byte array and allows you to pass headers.",
	"Method": "String getWithHeaders(String url,Map<String, ?> headers){\r\n    return Exceptions.tryIt(String.class, new Exceptions.TrialWithReturn<String>() {\r\n        @Override\r\n        public String tryIt() throws Exception {\r\n            URLConnection connection;\r\n            connection = doGet(url, headers, null, null);\r\n            return extractResponseString(connection);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.advantageous.qbit.http.HTTP.getWithHeaders",
	"Comment": "get that expects contents back as a byte array and allows you to pass headers.",
	"Method": "String getWithHeaders(String url,Map<String, ?> headers){\r\n    URLConnection connection;\r\n    connection = doGet(url, headers, null, null);\r\n    return extractResponseString(connection);\r\n}"
}, {
	"Path": "org.glassfish.resourcebase.resources.api.ResourceProxy.getResourceDeployer",
	"Comment": "given a resource instance, appropriate deployer will be provided",
	"Method": "org.glassfish.resourcebase.resources.api.ResourceDeployer getResourceDeployer(Object resource){\r\n    return resourceManagerFactoryProvider.get().getResourceDeployer(resource);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.file.FileRealm.getUser",
	"Comment": "returns the information recorded about a particular named user.",
	"Method": "User getUser(String name){\r\n    FileRealmStorageManager.User user = fileRealmStorageManager.getUser(name);\r\n    if (user == null) {\r\n        throw new NoSuchUserException(sm.getString(\"filerealm.nouser\", name));\r\n    }\r\n    return new FileRealmUser(user, null);\r\n}"
}, {
	"Path": "org.pitest.mutationtest.engine.MutationDetails.getFirstIndex",
	"Comment": "returns the index to the first instruction on which this mutation occurs.this index is specific to how asm represents the bytecode.",
	"Method": "int getFirstIndex(){\r\n    return this.id.getFirstIndex();\r\n}"
}, {
	"Path": "com.turo.pushy.apns.server.MockApnsServerBuilder.setHandlerFactory",
	"Comment": "sets the handler factory to be used to construct push notification handlers for the server under construction.servers require a handler factory.",
	"Method": "MockApnsServerBuilder setHandlerFactory(PushNotificationHandlerFactory handlerFactory){\r\n    this.handlerFactory = handlerFactory;\r\n    return this;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.auth.AuthenticationToken.verifySignature",
	"Comment": "verifies the cryptographic signature of this authentication token.",
	"Method": "boolean verifySignature(ApnsVerificationKey verificationKey){\r\n    if (!this.header.getKeyId().equals(verificationKey.getKeyId())) {\r\n        return false;\r\n    }\r\n    if (!this.claims.getIssuer().equals(verificationKey.getTeamId())) {\r\n        return false;\r\n    }\r\n    final byte[] headerAndClaimsBytes;\r\n    final String headerJson = GSON.toJson(this.header);\r\n    final String claimsJson = GSON.toJson(this.claims);\r\n    final String encodedHeaderAndClaims = encodeUnpaddedBase64UrlString(headerJson.getBytes(StandardCharsets.US_ASCII)) + '.' + encodeUnpaddedBase64UrlString(claimsJson.getBytes(StandardCharsets.US_ASCII));\r\n    headerAndClaimsBytes = encodedHeaderAndClaims.getBytes(StandardCharsets.US_ASCII);\r\n    final Signature signature = Signature.getInstance(ApnsKey.APNS_SIGNATURE_ALGORITHM);\r\n    signature.initVerify(verificationKey);\r\n    signature.update(headerAndClaimsBytes);\r\n    return signature.verify(this.signatureBytes);\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.Array.iterator",
	"Comment": "returns an iterator to navigate the values of the array. since the array is an ordered list,the iterator navigates the values in the order they were inserted.",
	"Method": "Iterator<Value> iterator(){\r\n    return values.iterator();\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.Value.getAsInt",
	"Comment": "convenience method to get this value as a primitive integer value.",
	"Method": "int getAsInt(){\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.WebAndEjbToJaasBridge.loginPrincipal",
	"Comment": "this method is used for logging in a run as principal. it creates a jaas subject whose credentialis to type gssupname. this is used primarily for runas",
	"Method": "void loginPrincipal(String username,String realmName){\r\n    if (realmName == null || realmName.length() == 0) {\r\n        realmName = Realm.getDefaultRealm();\r\n    }\r\n    Subject subject = new Subject();\r\n    PrincipalImpl callerPrincipal = new PrincipalImpl(username);\r\n    GSSUPName name = new GSSUPName(username, realmName);\r\n    privileged(() -> {\r\n        subject.getPrincipals().add(callerPrincipal);\r\n        subject.getPublicCredentials().add(name);\r\n    });\r\n    try {\r\n        Enumeration<String> groupNames = Realm.getInstance(realmName).getGroupNames(username);\r\n        Set<Principal> principalSet = subject.getPrincipals();\r\n        while (groupNames.hasMoreElements()) {\r\n            principalSet.add(new Group(groupNames.nextElement()));\r\n        }\r\n    } catch (InvalidOperationException ex) {\r\n        _logger.log(WARNING, invalidOperationForRealmError, new Object[] { username, realmName, ex.toString() });\r\n    } catch (NoSuchUserException ex) {\r\n        _logger.log(WARNING, noSuchUserInRealmError, new Object[] { username, realmName, ex.toString() });\r\n    } catch (NoSuchRealmException ex) {\r\n        throw (LoginException) new LoginException(ex.toString()).initCause(ex);\r\n    }\r\n    setSecurityContext(username, subject, realmName);\r\n}"
}, {
	"Path": "de.komoot.photon.nominatim.NominatimResult.addHousenumbersFromString",
	"Comment": "adds house numbers from a house number string.this may either be a single house number or multiplehouse numbers delimited by a semicolon. all locationswill be set to the centroid of the doc geometry.",
	"Method": "void addHousenumbersFromString(String str){\r\n    if (str == null || str.isEmpty())\r\n        return;\r\n    if (housenumbers == null)\r\n        housenumbers = new HashMap<String, Point>();\r\n    String[] parts = str.split(\";\");\r\n    for (String part : parts) {\r\n        String h = part.trim();\r\n        if (!h.isEmpty())\r\n            housenumbers.put(h, doc.getCentroid());\r\n    }\r\n}"
}, {
	"Path": "org.pitest.mutationtest.tooling.EntryPoint.execute",
	"Comment": "convenient entry point for tools to run mutation analysis.the big grab bag of config stored in reportoptions must be setup correctlyfirst.",
	"Method": "AnalysisResult execute(File baseDir,ReportOptions data,PluginServices plugins,Map<String, String> environmentVariables,AnalysisResult execute,File baseDir,ReportOptions data,SettingsFactory settings,Map<String, String> environmentVariables){\r\n    if (data.isVerbose()) {\r\n        Log.getLogger().info(\"---------------------------------------------------------------------------\");\r\n        Log.getLogger().info(\"Enabled (+) and disabled (-) features.\");\r\n        Log.getLogger().info(\"-----------------------------------------\");\r\n        settings.describeFeatures(asInfo(\"+\"), asInfo(\"-\"));\r\n        Log.getLogger().info(\"---------------------------------------------------------------------------\");\r\n    }\r\n    checkMatrixMode(data);\r\n    selectTestPlugin(data);\r\n    final ClassPath cp = data.getClassPath();\r\n    final Optional<Reader> reader = data.createHistoryReader();\r\n    final WriterFactory historyWriter = data.createHistoryWriter();\r\n    final JavaAgent jac = new JarCreatingJarFinder(new ClassPathByteArraySource(cp));\r\n    final KnownLocationJavaAgentFinder ja = new KnownLocationJavaAgentFinder(jac.getJarLocation().get());\r\n    final ResultOutputStrategy reportOutput = settings.getOutputStrategy();\r\n    final MutationResultListenerFactory reportFactory = settings.createListener();\r\n    final CoverageOptions coverageOptions = settings.createCoverageOptions();\r\n    final LaunchOptions launchOptions = new LaunchOptions(ja, settings.getJavaExecutable(), data.getJvmArgs(), environmentVariables).usingClassPathJar(data.useClasspathJar());\r\n    final ProjectClassPaths cps = data.getMutationClassPaths();\r\n    final CodeSource code = new CodeSource(cps);\r\n    final Timings timings = new Timings();\r\n    final CoverageGenerator coverageDatabase = new DefaultCoverageGenerator(baseDir, coverageOptions, launchOptions, code, settings.createCoverageExporter(), timings, !data.isVerbose());\r\n    final HistoryStore history = new ObjectOutputStreamHistoryStore(historyWriter, reader);\r\n    final MutationStrategies strategies = new MutationStrategies(settings.createEngine(), history, coverageDatabase, reportFactory, reportOutput);\r\n    final MutationCoverage report = new MutationCoverage(strategies, baseDir, code, data, settings, timings);\r\n    try {\r\n        return AnalysisResult.success(report.runReport());\r\n    } catch (final IOException e) {\r\n        return AnalysisResult.fail(e);\r\n    } finally {\r\n        jac.close();\r\n        ja.close();\r\n        historyWriter.close();\r\n    }\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.User.noLongerValid",
	"Comment": "mark this user as no longer valid, probably because they pinged out.",
	"Method": "void noLongerValid(){\r\n    if (currentGame != null) {\r\n        final Game game = currentGame;\r\n        game.removePlayer(this);\r\n        game.removeSpectator(this);\r\n    }\r\n    valid = false;\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.ObjectValue.entrySet",
	"Comment": "returns a set of members of this object. the set is ordered, and the order is in which thevalues were added.",
	"Method": "Set<Map.Entry<String, Value>> entrySet(){\r\n    return members.entrySet();\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.postConstruct",
	"Comment": "called when the instance has been created and the component isabout to be place into commission.the component has been injected with any dependency andwill be placed into commission by the subsystem.hk2 will catch all unchecked exceptions,and will consequently cause the backing inhabitant to be released.",
	"Method": "void postConstruct(){\r\n    org.glassfish.security.services.config.AuthorizationService atzConfiguration = ServiceFactory.getSecurityServiceConfiguration(domain, org.glassfish.security.services.config.AuthorizationService.class);\r\n    initialize(atzConfiguration);\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.Value.isNull",
	"Comment": "provides check for verifying if this value represents a null value or not.",
	"Method": "boolean isNull(){\r\n    return this instanceof Null;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.util.SimpleApnsPushNotification.getExpiration",
	"Comment": "returns the time at which this push notification is no longer valid and should no longer be delivered.",
	"Method": "Date getExpiration(){\r\n    return this.invalidationTime;\r\n}"
}, {
	"Path": "psiprobe.Tomcat85ContainerAdapter.getNamingToken",
	"Comment": "returns the security token required to bind to a naming context.",
	"Method": "Object getNamingToken(Context context){\r\n    Object token = context.getNamingToken();\r\n    if (!ContextAccessController.checkSecurityToken(context, token)) {\r\n        logger.error(\"Couldn't get a valid security token. ClassLoader binding will fail.\");\r\n    }\r\n    return token;\r\n}"
}, {
	"Path": "ro.pippo.controller.util.ControllerUtils.getConsumes",
	"Comment": "todo one controllermethod that takes annotation type as parameter",
	"Method": "List<String> getConsumes(Method method){\r\n    Set<String> types = new LinkedHashSet();\r\n    Consumes consumes = ClassUtils.getAnnotation(method, Consumes.class);\r\n    if (consumes != null) {\r\n        for (String value : consumes.value()) {\r\n            types.add(value.trim());\r\n        }\r\n    }\r\n    return new ArrayList(types);\r\n}"
}, {
	"Path": "com.hugnew.sps.services.pay.util.app.ali.main.sign.Base64.removeWhiteSpace",
	"Comment": "remove whitespace from mime containing encoded base64 data.",
	"Method": "int removeWhiteSpace(char[] data){\r\n    if (data == null) {\r\n        return 0;\r\n    }\r\n    int newSize = 0;\r\n    int len = data.length;\r\n    for (int i = 0; i < len; i++) {\r\n        if (!isWhiteSpace(data[i])) {\r\n            data[newSize++] = data[i];\r\n        }\r\n    }\r\n    return newSize;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.metrics.micrometer.MicrometerApnsClientMetricsListener.handleConnectionRemoved",
	"Comment": "records that the apns server removed a connection from its internal connection pool and updates metricsaccordingly.",
	"Method": "void handleConnectionRemoved(ApnsClient apnsClient){\r\n    this.openConnections.decrementAndGet();\r\n}"
}, {
	"Path": "ro.pippo.session.hazelcast.HazelcastSessionDataStorageTest.testGetExpired",
	"Comment": "test of get method, of class hazelcastsessiondatastorage.",
	"Method": "void testGetExpired(){\r\n    System.out.println(\"get expired\");\r\n    HazelcastSessionDataStorage instance = new HazelcastSessionDataStorage(Hazelcast.newHazelcastInstance());\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    Thread.sleep(2000L);\r\n    SessionData deleted = instance.get(sessionId);\r\n    assertNull(deleted);\r\n}"
}, {
	"Path": "net.socialgamer.cah.JsonWrapper.getString",
	"Comment": "returns the value of a property as a string, or the default if the parameter does not exist.",
	"Method": "String getString(Object key,String defaultValue){\r\n    final Object value = getValue(key);\r\n    return (value == null) ? defaultValue : value.toString();\r\n}"
}, {
	"Path": "picocli.CommandLine.getUnmatchedArguments",
	"Comment": "returns the list of unmatched command line arguments, if any.",
	"Method": "List<String> getUnmatchedArguments(){\r\n    return interpreter.parseResult == null ? Collections.<String>emptyList() : Collections.unmodifiableList(interpreter.parseResult.unmatched);\r\n}"
}, {
	"Path": "com.turo.pushy.apns.util.SimpleApnsPushNotification.getTopic",
	"Comment": "returns the topic to which this push notification should be sent.",
	"Method": "String getTopic(){\r\n    return this.topic;\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.lexer.TemplateSource.grow",
	"Comment": "grow the internal array to at least the desired minimum capacity.",
	"Method": "void grow(int minCapacity){\r\n    int oldCapacity = source.length;\r\n    int newCapacity = Math.max(oldCapacity << 1, minCapacity);\r\n    this.source = Arrays.copyOf(source, newCapacity);\r\n}"
}, {
	"Path": "ro.pippo.core.FileItem.delete",
	"Comment": "deletes the underlying storage for a file item, including deleting anyassociated temporary disk file.",
	"Method": "void delete(){\r\n    part.delete();\r\n}"
}, {
	"Path": "org.pitest.mutationtest.engine.MutationDetails.getTestsInOrder",
	"Comment": "returns the tests that cover this mutation in optimised order",
	"Method": "List<TestInfo> getTestsInOrder(){\r\n    return this.testsInOrder;\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.discovery.ServiceDiscovery.registerWithTTL",
	"Comment": "register with the service discovery system and specify a ttl so that ifthe service does not send a checkin that it is marked down.ttl is time to live.",
	"Method": "EndpointDefinition registerWithTTL(String serviceName,String host,int port,int timeToLiveSeconds){\r\n    return new EndpointDefinition(HealthStatus.PASS, serviceName + \".\" + uniqueString(port), serviceName, host, port, timeToLiveSeconds);\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.ArgumentsNodeTest.testInvalidArgument",
	"Comment": "tests that the error description is clear when a invalid number of arguments are provided.",
	"Method": "void testInvalidArgument(){\r\n    try {\r\n        PebbleEngine pebble = new PebbleEngine.Builder().loader(new StringLoader()).strictVariables(false).build();\r\n        PebbleTemplate template = pebble.getTemplate(\"{{ 'This is a test of the abbreviate filter' | abbreviate(16, 10) }}\");\r\n        Writer writer = new StringWriter();\r\n        template.evaluate(writer);\r\n        Assert.fail(\"Should not be reached, because an exception is expected.\");\r\n    } catch (PebbleException e) {\r\n        Assert.assertEquals(\"{{ 'This is a test of the abbreviate filter' | abbreviate(16, 10) }}\", e.getFileName());\r\n        Assert.assertEquals((Integer) 1, e.getLineNumber());\r\n    }\r\n}"
}, {
	"Path": "ro.pippo.core.PippoSettings.getRequiredString",
	"Comment": "returns the string value for the specified name.if the name does notexist an exception is thrown.",
	"Method": "String getRequiredString(String name){\r\n    String value = getString(name, null);\r\n    if (value != null) {\r\n        return value.trim();\r\n    }\r\n    throw new PippoRuntimeException(\"Setting '{}' has not been configured!\", name);\r\n}"
}, {
	"Path": "io.advantageous.qbit.events.EventBusQueueAdapter.start",
	"Comment": "start listener. once this is called messages can come in on a foreign thread.",
	"Method": "void start(){\r\n    if (!queue.isPresent()) {\r\n        initQueue();\r\n    }\r\n    queue.ifPresent(actualQueue -> actualQueue.startListener(EventBusQueueAdapter.this::sendToEventManager));\r\n}"
}, {
	"Path": "org.pf4j.DefaultPluginManager.loadPluginFromPath",
	"Comment": "load a plugin from disk. if the path is a zip file, first unpack",
	"Method": "PluginWrapper loadPluginFromPath(Path pluginPath){\r\n    try {\r\n        pluginPath = FileUtils.expandIfZip(pluginPath);\r\n    } catch (Exception e) {\r\n        log.warn(\"Failed to unzip \" + pluginPath, e);\r\n        return null;\r\n    }\r\n    return super.loadPluginFromPath(pluginPath);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.impl.SecuritySupportImpl.getKeyStores",
	"Comment": "this method returns an array of keystores containing keys and certificates.",
	"Method": "KeyStore[] getKeyStores(){\r\n    List<KeyStore> keyStoresList = keyStores.get(DEFAULT_MAP_KEY);\r\n    return keyStoresList.toArray(new KeyStore[keyStoresList.size()]);\r\n}"
}, {
	"Path": "io.nayuki.qrcodegen.QrCode.hasFinderLikePattern",
	"Comment": "must only be called immediately after a run of white modules has ended.",
	"Method": "boolean hasFinderLikePattern(int[] runHistory){\r\n    int n = runHistory[1];\r\n    return n > 0 && runHistory[2] == n && runHistory[4] == n && runHistory[5] == n && runHistory[3] == n * 3 && Math.max(runHistory[0], runHistory[6]) >= n * 4;\r\n}"
}, {
	"Path": "com.feth.play.module.pa.providers.wwwauth.WWWAuthenticateProvider.unauthorized",
	"Comment": "the 401 page to return to the browser if authentication failed.\tthis could for example be a login form that submits to another\tauthentication method.",
	"Method": "Content unauthorized(Context context){\r\n    return new Content() {\r\n        @Override\r\n        public String body() {\r\n            return \"Go away, you don't exit.\";\r\n        }\r\n        @Override\r\n        public String contentType() {\r\n            return \"text/plain\";\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.feth.play.module.pa.providers.wwwauth.WWWAuthenticateProvider.unauthorized",
	"Comment": "the 401 page to return to the browser if authentication failed.\tthis could for example be a login form that submits to another\tauthentication method.",
	"Method": "Content unauthorized(Context context){\r\n    return \"Go away, you don't exit.\";\r\n}"
}, {
	"Path": "com.feth.play.module.pa.providers.wwwauth.WWWAuthenticateProvider.unauthorized",
	"Comment": "the 401 page to return to the browser if authentication failed.\tthis could for example be a login form that submits to another\tauthentication method.",
	"Method": "Content unauthorized(Context context){\r\n    return \"text/plain\";\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.BaseService.recordTiming",
	"Comment": "prefixes the stats key with the stat key prefix, and then calls statscollector.recordtiming.",
	"Method": "void recordTiming(String statKey,long timeSpan){\r\n    final String longKey = getActualStatKey(statKey);\r\n    statsCollector.recordTiming(longKey, timeSpan);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.UpdatePasswordAlias.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        if (!domainPasswordAliasStore.containsKey(aliasName)) {\r\n            report.setMessage(localStrings.getLocalString(\"update.password.alias.notfound\", \"Password alias for the alias {0} does not exist.\", aliasName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n        domainPasswordAliasStore.put(aliasName, aliasPassword.toCharArray());\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n        report.setMessage(localStrings.getLocalString(\"update.password.alias.fail\", \"Update of Password Alias {0} failed\", aliasName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(ex);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    report.setMessage(localStrings.getLocalString(\"update.password.alias.success\", \"Encrypted password for the alias {0} updated successfully\", aliasName));\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.lexer.LexerImpl.lexExpression",
	"Comment": "tokenizing an expression which can be found within both execute and print regions.",
	"Method": "void lexExpression(){\r\n    String token;\r\n    this.source.advanceThroughWhitespace();\r\n    Matcher matcher = this.regexOperators.matcher(this.source);\r\n    if (matcher.lookingAt()) {\r\n        token = this.source.substring(matcher.end());\r\n        this.pushToken(Token.Type.OPERATOR, token);\r\n        this.source.advance(matcher.end());\r\n        return;\r\n    }\r\n    matcher = REGEX_NAME.matcher(this.source);\r\n    if (matcher.lookingAt()) {\r\n        token = this.source.substring(matcher.end());\r\n        this.pushToken(Token.Type.NAME, token);\r\n        this.source.advance(matcher.end());\r\n        return;\r\n    }\r\n    matcher = REGEX_LONG.matcher(this.source);\r\n    if (matcher.lookingAt()) {\r\n        token = this.source.substring(matcher.end() - 1);\r\n        this.pushToken(Token.Type.LONG, token);\r\n        this.source.advance(matcher.end());\r\n        return;\r\n    }\r\n    matcher = REGEX_NUMBER.matcher(this.source);\r\n    if (matcher.lookingAt()) {\r\n        token = this.source.substring(matcher.end());\r\n        this.pushToken(Token.Type.NUMBER, token);\r\n        this.source.advance(matcher.end());\r\n        return;\r\n    }\r\n    if (PUNCTUATION.indexOf(this.source.charAt(0)) >= 0) {\r\n        String character = String.valueOf(this.source.charAt(0));\r\n        if (\"([{\".contains(character)) {\r\n            this.brackets.push(new Pair(character, this.source.getLineNumber()));\r\n        } else if (\")]}\".contains(character)) {\r\n            if (this.brackets.isEmpty()) {\r\n                throw new ParserException(null, \"Unexpected \\\"\" + character + \"\\\"\", this.source.getLineNumber(), this.source.getFilename());\r\n            } else {\r\n                HashMap<String, String> validPairs = new HashMap();\r\n                validPairs.put(\"(\", \")\");\r\n                validPairs.put(\"[\", \"]\");\r\n                validPairs.put(\"{\", \"}\");\r\n                String lastBracket = this.brackets.pop().getLeft();\r\n                String expected = validPairs.get(lastBracket);\r\n                if (!expected.equals(character)) {\r\n                    throw new ParserException(null, \"Unclosed \\\"\" + expected + \"\\\"\", this.source.getLineNumber(), this.source.getFilename());\r\n                }\r\n            }\r\n        }\r\n        this.pushToken(Token.Type.PUNCTUATION, character);\r\n        this.source.advance(1);\r\n        return;\r\n    }\r\n    matcher = REGEX_STRING_PLAIN.matcher(this.source);\r\n    if (matcher.lookingAt()) {\r\n        token = this.source.substring(matcher.end());\r\n        this.source.advance(matcher.end());\r\n        token = this.unquoteAndUnescape(token);\r\n        this.pushToken(Token.Type.STRING, token);\r\n        return;\r\n    }\r\n    matcher = REGEX_DOUBLEQUOTE.matcher(this.source);\r\n    if (matcher.lookingAt()) {\r\n        this.brackets.push(new Pair(\"\\\"\", this.source.getLineNumber()));\r\n        this.pushState(State.STRING);\r\n        this.source.advance(matcher.end());\r\n        return;\r\n    }\r\n    throw new ParserException(null, String.format(\"Unexpected character [%s]\", this.source.charAt(0)), this.source.getLineNumber(), this.source.getFilename());\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteAuthRealm.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ActionReport report = context.getActionReport();\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<SecurityService>() {\r\n            public Object run(SecurityService param) throws PropertyVetoException, TransactionFailure {\r\n                param.getAuthRealm().remove(authRealm);\r\n                SecurityConfigListener.authRealmDeleted(authRealm);\r\n                return null;\r\n            }\r\n        }, securityService);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.auth.realm.fail\", \"Deletion of Authrealm {0} failed\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteAuthRealm.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    param.getAuthRealm().remove(authRealm);\r\n    SecurityConfigListener.authRealmDeleted(authRealm);\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.tests.utils.NucleusTestUtils.getURL",
	"Comment": "this methods opens a connection to the given url andreturns the string that is returned from that url.thisis useful for simple servlet retrieval",
	"Method": "String getURL(String urlstr){\r\n    StringWriter ow = null;\r\n    BufferedReader ir = null;\r\n    try {\r\n        URL u = new URL(urlstr);\r\n        URLConnection urlc = u.openConnection();\r\n        ir = new BufferedReader(new InputStreamReader(urlc.getInputStream(), \"ISO-8859-1\"));\r\n        try {\r\n            ow = new StringWriter();\r\n            String line;\r\n            while ((line = ir.readLine()) != null) {\r\n                ow.write(line);\r\n                ow.write(\"\\n\");\r\n            }\r\n            return ow.getBuffer().toString();\r\n        } finally {\r\n            if (ow != null) {\r\n                ow.close();\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        System.out.println(\"unable to fetch URL:\" + urlstr + \", reason: \" + ex.getMessage());\r\n        return \"\";\r\n    } finally {\r\n        if (ir != null) {\r\n            try {\r\n                ir.close();\r\n            } catch (IOException ex) {\r\n                Logger.getLogger(NucleusTestUtils.class.getName()).log(Level.SEVERE, null, ex);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.pitest.mutationtest.MutationStatusTestPair.getKillingTests",
	"Comment": "get all killing tests. if the full mutation matrix is not enabled, this will only be the first killing test.",
	"Method": "List<String> getKillingTests(){\r\n    return killingTests;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.file.FileRealm.hasAuthenticatableUser",
	"Comment": "test whether their is a user in the filerealm that has a password that has been set, i.e., something other than theresetkey.",
	"Method": "boolean hasAuthenticatableUser(){\r\n    return fileRealmStorageManager.hasAuthenticatableUser();\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.Null.hashCode",
	"Comment": "all instances of null have the same hash codesince they are indistinguishable",
	"Method": "int hashCode(){\r\n    return Null.class.hashCode();\r\n}"
}, {
	"Path": "org.pf4j.util.DirectedGraph.removeEdge",
	"Comment": "remove an edge from the graph. nothing happens if no such edge.",
	"Method": "void removeEdge(V from,V to){\r\n    if (!containsVertex(from)) {\r\n        throw new IllegalArgumentException(\"Nonexistent vertex \" + from);\r\n    }\r\n    if (!containsVertex(to)) {\r\n        throw new IllegalArgumentException(\"Nonexistent vertex \" + to);\r\n    }\r\n    neighbors.get(from).remove(to);\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.makeAzResource",
	"Comment": "convert a resource, expressed as a uri, into a typed attributes collection.query parameters in the given uri are appended to thisazresource instance attributes collection.",
	"Method": "AzResource makeAzResource(URI resource){\r\n    AzResource azr = new AzResourceImpl(resource);\r\n    return azr;\r\n}"
}, {
	"Path": "io.advantageous.qbit.admin.ServiceManagementBundle.increment",
	"Comment": "prefixes the stats key with the stat key prefix, and then calls statscollector.recordcount.",
	"Method": "void increment(String statKey){\r\n    final String longKey = getActualStatKey(statKey);\r\n    stats.increment(longKey);\r\n}"
}, {
	"Path": "io.advantageous.qbit.logging.SetupMdcForHttpRequestInterceptor.extractHeaders",
	"Comment": "extract headerstoaddtologgingmappingdiagnosticscontext data and put them into the logging mapping diagnostics context.",
	"Method": "void extractHeaders(HttpRequest httpRequest){\r\n    if (headersToAddToLoggingMappingDiagnosticsContext.size() > 0) {\r\n        final MultiMap<String, String> headers = httpRequest.getHeaders();\r\n        headersToAddToLoggingMappingDiagnosticsContext.forEach(header -> {\r\n            String value = headers.getFirst(header);\r\n            if (!Str.isEmpty(value)) {\r\n                MDC.put(REQUEST_HEADER_PREFIX + header, value);\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.impl.ServiceBundleImpl.responses",
	"Comment": "returns a receive queue for all servicestostop managed by this bundle.",
	"Method": "Queue<Response<Object>> responses(){\r\n    return responseQueue;\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.ServiceFactory.getSecurityServiceConfiguration",
	"Comment": "get the security service configuration for the specified service type.\tattempt to obtain the service configuration marked as default\totherwise use the first configured service instance.",
	"Method": "T getSecurityServiceConfiguration(Domain domain,Class<T> type){\r\n    T config = null;\r\n    SecurityConfigurations secConfigs = domain.getExtensionByType(SecurityConfigurations.class);\r\n    if (secConfigs != null) {\r\n        config = secConfigs.getDefaultSecurityServiceByType(type);\r\n        if (config == null) {\r\n            List<T> configs = secConfigs.getSecurityServicesByType(type);\r\n            if (!configs.isEmpty())\r\n                config = configs.get(0);\r\n        }\r\n    }\r\n    return config;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.WebAndEjbToJaasBridge.doX509CertificateLogin",
	"Comment": "a special case login for handling x509certificatecredential. this does not get triggered based oncurrent ri code. see x500login.",
	"Method": "void doX509CertificateLogin(Subject subject){\r\n    _logger.log(FINE, \"Processing X509 certificate login.\");\r\n    String user = null;\r\n    String realm = CertificateRealm.AUTH_TYPE;\r\n    try {\r\n        user = getPublicCredentials(subject, X509CertificateCredential.class).getAlias();\r\n        if (_logger.isLoggable(FINE)) {\r\n            _logger.log(FINE, \"Set security context as user: \" + user);\r\n        }\r\n        setSecurityContext(user, subject, realm);\r\n        auditAuthenticate(user, realm, true);\r\n    } catch (LoginException le) {\r\n        auditAuthenticate(user, realm, false);\r\n        throw le;\r\n    }\r\n}"
}, {
	"Path": "psiprobe.Tomcat90ContainerAdapter.getNamingToken",
	"Comment": "returns the security token required to bind to a naming context.",
	"Method": "Object getNamingToken(Context context){\r\n    Object token = context.getNamingToken();\r\n    if (!ContextAccessController.checkSecurityToken(context, token)) {\r\n        logger.error(\"Couldn't get a valid security token. ClassLoader binding will fail.\");\r\n    }\r\n    return token;\r\n}"
}, {
	"Path": "org.pf4j.util.FileUtils.delete",
	"Comment": "delete a file or recursively delete a folder, do not follow symlinks.",
	"Method": "void delete(Path path){\r\n    Files.walkFileTree(path, new SimpleFileVisitor<Path>() {\r\n        @Override\r\n        public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {\r\n            if (!attrs.isSymbolicLink()) {\r\n                Files.delete(path);\r\n            }\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n        @Override\r\n        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\r\n            Files.delete(dir);\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.pf4j.util.FileUtils.delete",
	"Comment": "delete a file or recursively delete a folder, do not follow symlinks.",
	"Method": "void delete(Path path){\r\n    if (!attrs.isSymbolicLink()) {\r\n        Files.delete(path);\r\n    }\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "org.pf4j.util.FileUtils.delete",
	"Comment": "delete a file or recursively delete a folder, do not follow symlinks.",
	"Method": "void delete(Path path){\r\n    Files.delete(dir);\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "ro.pippo.core.PippoSettings.getStrings",
	"Comment": "returns a list of strings from the specified name using the specified delimiter.",
	"Method": "List<String> getStrings(String name,List<String> getStrings,String name,String delimiter){\r\n    String value = getString(name, null);\r\n    if (StringUtils.isNullOrEmpty(value)) {\r\n        return Collections.emptyList();\r\n    }\r\n    value = value.trim();\r\n    if (value.startsWith(\"[\") && value.endsWith(\"]\")) {\r\n        value = value.substring(1, value.length() - 1);\r\n    }\r\n    return StringUtils.getList(value, delimiter);\r\n}"
}, {
	"Path": "ro.pippo.core.util.PippoUtils.getPippoVersion",
	"Comment": "simply reads a property resource file that contains the version of thispippo build. helps to identify the pippo version currently running.",
	"Method": "String getPippoVersion(){\r\n    String pippoVersionPropertyKey = \"pippo.version\";\r\n    String pippoVersion;\r\n    try {\r\n        Properties prop = new Properties();\r\n        URL url = ClasspathUtils.locateOnClasspath(PippoConstants.LOCATION_OF_PIPPO_BUILTIN_PROPERTIES);\r\n        InputStream stream = url.openStream();\r\n        prop.load(stream);\r\n        pippoVersion = prop.getProperty(pippoVersionPropertyKey);\r\n    } catch (Exception e) {\r\n        throw new PippoRuntimeException(\"Something is wrong with your build. Cannot find resource {}\", PippoConstants.LOCATION_OF_PIPPO_BUILTIN_PROPERTIES);\r\n    }\r\n    return pippoVersion;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.ClientPasswordLoginModule.logout",
	"Comment": "logout the user.this method removes the principalimpl that was added by the commitmethod.",
	"Method": "boolean logout(){\r\n    subject.getPrincipals().remove(userPrincipal);\r\n    succeeded = commitSucceeded;\r\n    username = null;\r\n    if (password != null) {\r\n        for (int i = 0; i < password.length; i++) {\r\n            password[i] = ' ';\r\n        }\r\n        password = null;\r\n    }\r\n    userPrincipal = null;\r\n    return true;\r\n}"
}, {
	"Path": "com.rabbitmq.client.ConnectionFactory.setChannelRpcTimeout",
	"Comment": "set the continuation timeout for rpc calls in channels.default is 10 minutes. 0 means no timeout.",
	"Method": "void setChannelRpcTimeout(int channelRpcTimeout){\r\n    if (channelRpcTimeout < 0) {\r\n        throw new IllegalArgumentException(\"Timeout cannot be less than 0\");\r\n    }\r\n    this.channelRpcTimeout = channelRpcTimeout;\r\n}"
}, {
	"Path": "com.feth.play.module.pa.providers.password.UsernamePasswordAuthUser.createPassword",
	"Comment": "provide your own implementation of this which implements your own security.",
	"Method": "String createPassword(String clearString){\r\n    return BCrypt.hashpw(clearString, BCrypt.gensalt());\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.AuthenticationServiceImpl.initialize",
	"Comment": "initialize the authentication service configuration.\tcreate the jaas configuration using the specified loginmodule configurations",
	"Method": "void initialize(SecurityConfiguration securityServiceConfiguration){\r\n    config = (org.glassfish.security.services.config.AuthenticationService) securityServiceConfiguration;\r\n    if (config == null)\r\n        return;\r\n    name = config.getName();\r\n    usePasswordCredential = Boolean.valueOf(config.getUsePasswordCredential());\r\n    List<SecurityProvider> providers = config.getSecurityProviders();\r\n    if (providers != null) {\r\n        ArrayList<AppConfigurationEntry> lmEntries = new ArrayList<AppConfigurationEntry>();\r\n        for (SecurityProvider provider : providers) {\r\n            if (\"LoginModule\".equalsIgnoreCase(provider.getType())) {\r\n                List<SecurityProviderConfig> providerConfig = provider.getSecurityProviderConfig();\r\n                if ((providerConfig != null) && (!providerConfig.isEmpty())) {\r\n                    LoginModuleConfig lmConfig = (LoginModuleConfig) providerConfig.get(0);\r\n                    Map<String, ?> lmOptions = lmConfig.getModuleOptions();\r\n                    lmEntries.add(new AppConfigurationEntry(lmConfig.getModuleClass(), getLoginModuleControlFlag(lmConfig.getControlFlag()), lmOptions));\r\n                    if (usePasswordCredential && (realmName == null)) {\r\n                        String authRealm = (String) lmOptions.get(\"auth-realm\");\r\n                        if ((authRealm != null) && (!authRealm.isEmpty()))\r\n                            realmName = authRealm;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!lmEntries.isEmpty())\r\n            configuration = new AuthenticationJaasConfiguration(name, lmEntries);\r\n    }\r\n    if (usePasswordCredential && (realmName != null)) {\r\n        RealmsManager realmsManager = locator.getService(RealmsManager.class);\r\n        realmsManager.createRealms();\r\n    }\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.ConnectedUsers.broadcastToList",
	"Comment": "broadcast a message to a specified subset of connected players.",
	"Method": "void broadcastToList(Collection<User> broadcastTo,MessageType type,HashMap<ReturnableData, Object> masterData){\r\n    synchronized (users) {\r\n        for (final User u : broadcastTo) {\r\n            @SuppressWarnings(\"unchecked\")\r\n            final Map<ReturnableData, Object> data = (Map<ReturnableData, Object>) masterData.clone();\r\n            data.put(LongPollResponse.TIMESTAMP, System.currentTimeMillis());\r\n            final QueuedMessage qm = new QueuedMessage(type, data);\r\n            u.enqueueMessage(qm);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.rabbitmq.client.ConnectionFactory.isTopologyRecoveryEnabled",
	"Comment": "returns true if topology recovery is enabled, false otherwise",
	"Method": "boolean isTopologyRecoveryEnabled(){\r\n    return topologyRecovery;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.common.X509CertificateCredential.equals",
	"Comment": "compare two instances of the credential and return true if they are the same and false otherwise.",
	"Method": "boolean equals(Object o){\r\n    if (o instanceof X509CertificateCredential) {\r\n        X509CertificateCredential pc = (X509CertificateCredential) o;\r\n        if (pc.getRealm().equals(realm) && pc.getAlias().equals(alias)) {\r\n            X509Certificate[] certs = pc.getX509CertificateChain();\r\n            for (int i = 0; i < certs.length; i++) {\r\n                if (!certs[i].equals(certChain[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.flipkart.android.proteus.value.Value.getAsDouble",
	"Comment": "convenience method to get this value as a primitive double value.",
	"Method": "double getAsDouble(){\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.chooseClientAlias",
	"Comment": "choose the client alias that will be used to select the client certificate for ssl client auth.",
	"Method": "String chooseClientAlias(String[] keyType,Principal[] issuers,Socket socket){\r\n    String clientAlias = null;\r\n    if (this.alias == null) {\r\n        if (Util.getInstance().isNotServerOrACC()) {\r\n            clientAlias = x509KeyManager.chooseClientAlias(keyType, issuers, socket);\r\n        } else {\r\n            if (Util.getInstance().isACC()) {\r\n                ClientSecurityContext ctx = ClientSecurityContext.getCurrent();\r\n                Subject s = ctx.getSubject();\r\n                if (s == null) {\r\n                    doClientLogin(SecurityConstants.CERTIFICATE, Util.getInstance().getCallbackHandler());\r\n                    s = ctx.getSubject();\r\n                }\r\n                Iterator itr = s.getPrivateCredentials().iterator();\r\n                while (itr.hasNext()) {\r\n                    Object o = itr.next();\r\n                    if (o instanceof X509CertificateCredential) {\r\n                        X509CertificateCredential crt = (X509CertificateCredential) o;\r\n                        clientAlias = crt.getAlias();\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        clientAlias = this.alias;\r\n    }\r\n    _logger.log(FINE, \"Choose client Alias :{0}\", clientAlias);\r\n    return clientAlias;\r\n}"
}, {
	"Path": "ro.pippo.session.infinispan.InfinispanSessionDataStorageTest.testGet",
	"Comment": "test of get method, of class infinispansessiondatastorage.",
	"Method": "void testGet(){\r\n    System.out.println(\"get\");\r\n    InfinispanSessionDataStorage instance = new InfinispanSessionDataStorage(cacheManager);\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    SessionData saved = instance.get(sessionId);\r\n    assertEquals(sessionData, saved);\r\n    String value1 = sessionData.get(KEY);\r\n    String value2 = saved.get(KEY);\r\n    assertEquals(value1, value2);\r\n}"
}, {
	"Path": "psiprobe.tools.logging.logback.LogbackAppenderAccessor.getLogType",
	"Comment": "returns the log type, to distinguish logback appenders from other types like log4j appenders orjdk handlers.",
	"Method": "String getLogType(){\r\n    return \"logback\";\r\n}"
}, {
	"Path": "io.advantageous.qbit.events.impl.ChannelManager.remove",
	"Comment": "remove an event listener from the channel.there can only be one consumer and many listeners.",
	"Method": "void remove(EventListener<T> eventListener){\r\n    if (eventListener.subscriber()) {\r\n        logger.info(\"remove subscription to channel {} from {} \", name, eventListener);\r\n        listeners.remove(eventListener);\r\n        stats.recordLevel(eventBusName + \"::\" + name, listeners.size());\r\n    } else {\r\n        if (consumer == eventListener) {\r\n            logger.info(\"remove consumer to channel {} from {} \", name, eventListener);\r\n            consumer = new NoOpEventConsumer();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.discovery.ServiceDiscovery.register",
	"Comment": "register the service with the service discovery service if applicable.",
	"Method": "EndpointDefinition register(String serviceName,String host,int port){\r\n    return new EndpointDefinition(HealthStatus.PASS, serviceName + \".\" + uniqueString(port), serviceName, host, port);\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.discovery.dns.DnsSupport.findServiceName",
	"Comment": "looks up a service name based on its dns service name. the service part of the srv dns record.",
	"Method": "String findServiceName(String dnsServiceName){\r\n    String serviceName = dnsServiceNameToServiceName.get(dnsServiceName);\r\n    serviceName = serviceName == null ? dnsServiceName : serviceName;\r\n    if (debug)\r\n        logger.debug(\"FindServiceName dnsServiceName={} serviceName={}\", dnsServiceName, serviceName);\r\n    return serviceName;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateAuthRealm.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names and thevalues the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ActionReport report = context.getActionReport();\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<SecurityService>() {\r\n            public Object run(SecurityService param) throws PropertyVetoException, TransactionFailure {\r\n                AuthRealm newAuthRealm = param.createChild(AuthRealm.class);\r\n                populateAuthRealmElement(newAuthRealm);\r\n                param.getAuthRealm().add(newAuthRealm);\r\n                SecurityConfigListener.authRealmCreated(config, newAuthRealm);\r\n                return newAuthRealm;\r\n            }\r\n        }, securityService);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(localStrings.getLocalString(\"create.auth.realm.fail\", \"Creation of Authrealm {0} failed\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateAuthRealm.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names and thevalues the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    AuthRealm newAuthRealm = param.createChild(AuthRealm.class);\r\n    populateAuthRealmElement(newAuthRealm);\r\n    param.getAuthRealm().add(newAuthRealm);\r\n    SecurityConfigListener.authRealmCreated(config, newAuthRealm);\r\n    return newAuthRealm;\r\n}"
}, {
	"Path": "com.rabbitmq.client.ConnectionFactory.setConnectionRecoveryTriggeringCondition",
	"Comment": "allows to decide on automatic connection recovery is triggered.default is for shutdown not initiated by application or missed heartbeat errors.",
	"Method": "void setConnectionRecoveryTriggeringCondition(Predicate<ShutdownSignalException> connectionRecoveryTriggeringCondition){\r\n    this.connectionRecoveryTriggeringCondition = connectionRecoveryTriggeringCondition;\r\n}"
}, {
	"Path": "io.nayuki.qrcodegen.QrCodeGeneratorDemo.doSegmentDemo",
	"Comment": "creates qr codes with manually specified segments for better compactness.",
	"Method": "void doSegmentDemo(){\r\n    QrCode qr;\r\n    List<QrSegment> segs;\r\n    String silver0 = \"THE SQUARE ROOT OF 2 IS 1.\";\r\n    String silver1 = \"41421356237309504880168872420969807856967187537694807317667973799\";\r\n    qr = QrCode.encodeText(silver0 + silver1, QrCode.Ecc.LOW);\r\n    writePng(qr.toImage(10, 3), \"sqrt2-monolithic-QR.png\");\r\n    segs = Arrays.asList(QrSegment.makeAlphanumeric(silver0), QrSegment.makeNumeric(silver1));\r\n    qr = QrCode.encodeSegments(segs, QrCode.Ecc.LOW);\r\n    writePng(qr.toImage(10, 3), \"sqrt2-segmented-QR.png\");\r\n    String golden0 = \"Golden ratio φ = 1.\";\r\n    String golden1 = \"6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374\";\r\n    String golden2 = \"......\";\r\n    qr = QrCode.encodeText(golden0 + golden1 + golden2, QrCode.Ecc.LOW);\r\n    writePng(qr.toImage(8, 5), \"phi-monolithic-QR.png\");\r\n    segs = Arrays.asList(QrSegment.makeBytes(golden0.getBytes(StandardCharsets.UTF_8)), QrSegment.makeNumeric(golden1), QrSegment.makeAlphanumeric(golden2));\r\n    qr = QrCode.encodeSegments(segs, QrCode.Ecc.LOW);\r\n    writePng(qr.toImage(8, 5), \"phi-segmented-QR.png\");\r\n    String madoka = \"「魔法少女まどか☆マギカ」って�?��??ИАИ�?ｄｅｓｕ�?κα�?\";\r\n    qr = QrCode.encodeText(madoka, QrCode.Ecc.LOW);\r\n    writePng(qr.toImage(9, 4), \"madoka-utf8-QR.png\");\r\n    segs = Arrays.asList(QrSegmentAdvanced.makeKanji(madoka));\r\n    qr = QrCode.encodeSegments(segs, QrCode.Ecc.LOW);\r\n    writePng(qr.toImage(9, 4), \"madoka-kanji-QR.png\");\r\n}"
}, {
	"Path": "io.nayuki.qrcodegen.QrCode.setFunctionModule",
	"Comment": "only used by the constructor. coordinates must be in bounds.",
	"Method": "void setFunctionModule(int x,int y,boolean isBlack){\r\n    modules[y][x] = isBlack;\r\n    isFunction[y][x] = true;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.ldap.LDAPRealm.userSearch",
	"Comment": "do anonymous search for the user. should be unique if exists.",
	"Method": "String userSearch(DirContext ctx,String baseDN,String filter){\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.log(Level.FINE, \"search: baseDN: {0}  filter: {1}\", new Object[] { baseDN, filter });\r\n    }\r\n    String foundDN = null;\r\n    NamingEnumeration namingEnum = null;\r\n    SearchControls ctls = new SearchControls();\r\n    ctls.setReturningAttributes(_dnOnly);\r\n    ctls.setSearchScope(SearchControls.SUBTREE_SCOPE);\r\n    ctls.setCountLimit(1);\r\n    try {\r\n        namingEnum = ctx.search(baseDN, filter, ctls);\r\n        if (namingEnum.hasMore()) {\r\n            SearchResult res = (SearchResult) namingEnum.next();\r\n            StringBuilder sb = new StringBuilder();\r\n            CompositeName compDN = new CompositeName(res.getName());\r\n            String ldapDN = compDN.get(0);\r\n            sb.append(ldapDN);\r\n            if (res.isRelative()) {\r\n                sb.append(\",\");\r\n                sb.append(baseDN);\r\n            }\r\n            foundDN = sb.toString();\r\n            if (_logger.isLoggable(Level.FINEST)) {\r\n                _logger.log(Level.FINE, \"Found user DN: {0}\", foundDN);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        _logger.log(Level.WARNING, \"ldaprealm.searcherror\", filter);\r\n        _logger.log(Level.WARNING, \"security.exception\", e);\r\n    } finally {\r\n        if (namingEnum != null) {\r\n            try {\r\n                namingEnum.close();\r\n            } catch (Exception ex) {\r\n            }\r\n        }\r\n    }\r\n    return foundDN;\r\n}"
}, {
	"Path": "ro.pippo.core.route.Route.runAsFinally",
	"Comment": "mark this route to be invoked even when exceptions were raised in previous routes.this flag make sense only for an after filter.",
	"Method": "void runAsFinally(){\r\n    runAsFinally = true;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.solaris.SolarisRealm.init",
	"Comment": "initialize a realm with some properties. this can be used when instantiating realms from theirdescriptions. this method may only be called a single time.",
	"Method": "void init(Properties props){\r\n    super.init(props);\r\n    String jaasCtx = props.getProperty(JAAS_CONTEXT_PARAM);\r\n    if (jaasCtx == null) {\r\n        _logger.warning(\"realmconfig.noctx\");\r\n        throw new BadRealmException(sm.getString(\"solarisrealm.nojaas\"));\r\n    }\r\n    setProperty(JAAS_CONTEXT_PARAM, jaasCtx);\r\n    if (_logger.isLoggable(FINE)) {\r\n        _logger.fine(\"SolarisRealm : \" + JAAS_CONTEXT_PARAM + \"=\" + jaasCtx);\r\n    }\r\n    groupCache = new HashMap();\r\n    emptyVector = new Vector();\r\n}"
}, {
	"Path": "ro.pippo.core.websocket.AbstractWebSocketFilter.headerContainsToken",
	"Comment": "this only works for tokens. quoted strings need more sophisticated parsing.",
	"Method": "boolean headerContainsToken(Request request,String headerName,String target){\r\n    Enumeration<String> headers = request.getHeaders(headerName);\r\n    while (headers.hasMoreElements()) {\r\n        String header = headers.nextElement();\r\n        String[] tokens = header.split(\",\");\r\n        for (String token : tokens) {\r\n            if (target.equalsIgnoreCase(token.trim())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "ro.pippo.session.ehcache.EhcacheSessionDataStorageTest.testDelete",
	"Comment": "test of delete method, of class ehcachesessiondatastorage.",
	"Method": "void testDelete(){\r\n    System.out.println(\"delete\");\r\n    EhcacheSessionDataStorage instance = new EhcacheSessionDataStorage(cacheManager);\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    instance.delete(sessionId);\r\n    SessionData deleted = instance.get(sessionId);\r\n    assertNull(deleted);\r\n}"
}, {
	"Path": "ro.pippo.core.Languages.setLanguageCookie",
	"Comment": "sets the application language cookie.if the language does not match a registered language or languagecomponent an exception is thrown.",
	"Method": "void setLanguageCookie(String language,RouteContext routeContext){\r\n    String lang = getLanguageOrDefault(language);\r\n    if (lang.equals(language)) {\r\n        Cookie cookie = generateLanguageCookie(language);\r\n        routeContext.getResponse().cookie(cookie);\r\n    } else {\r\n        throw new PippoRuntimeException(\"'{}' is not a registered language!\", language);\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.reactive.CallbackBuilder.withOptionalCallback",
	"Comment": "builder method to set callback handler that takes an optional string",
	"Method": "CallbackBuilder withOptionalCallback(Class<T> cls,Callback<Optional<T>> callback){\r\n    this.callback = callback;\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.util.IASSecurityException.getMessage",
	"Comment": "returns a description of this exception. if a root cause was included during construction, itsmessage is also included.",
	"Method": "String getMessage(){\r\n    StringBuffer sb = new StringBuffer();\r\n    sb.append(super.getMessage());\r\n    Throwable cause = getCause();\r\n    if (!noMsg && cause != null) {\r\n        sb.append(\" [Cause: \");\r\n        sb.append(cause.toString());\r\n        sb.append(\"] \");\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.ListAuditModule.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    report.getTopMessagePart().setChildrenType(\"audit-module\");\r\n    for (AuditModule am : securityService.getAuditModule()) {\r\n        ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n        part.setMessage(am.getName());\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.events.impl.EventConnectorHub.flush",
	"Comment": "flushes the pool used to optimize flushing of io operations.",
	"Method": "void flush(){\r\n    for (int index = 0; index < eventConnectors.size(); index++) {\r\n        EventConnector eventConnector = null;\r\n        try {\r\n            eventConnector = eventConnectors.get(index);\r\n            if (eventConnector instanceof ClientProxy) {\r\n                ServiceProxyUtils.flushServiceProxy(eventConnector);\r\n            } else {\r\n                eventConnector.flush();\r\n            }\r\n        } catch (Exception ex) {\r\n            logger.debug(\"problem sending event to event connector\", ex);\r\n            if (eventConnector instanceof RemoteTCPClientProxy) {\r\n                if (!((RemoteTCPClientProxy) eventConnector).connected()) {\r\n                    eventConnectors.remove(eventConnector);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.pitest.mutationtest.commandline.OptionsParser.parseCommandLine",
	"Comment": "creates a new parseresult object using the command line arguments.",
	"Method": "ParseResult parseCommandLine(ReportOptions data,OptionSet userArgs){\r\n    data.setTestPlugin(userArgs.valueOf(this.testPluginSpec));\r\n    data.setReportDir(userArgs.valueOf(this.reportDirSpec));\r\n    data.setTargetClasses(this.targetClassesSpec.values(userArgs));\r\n    data.setTargetTests(FCollection.map(this.targetTestsSpec.values(userArgs), Glob.toGlobPredicate()));\r\n    data.setSourceDirs(this.sourceDirSpec.values(userArgs));\r\n    data.setMutators(this.mutators.values(userArgs));\r\n    data.setFeatures(this.features.values(userArgs));\r\n    data.setDependencyAnalysisMaxDistance(this.depth.value(userArgs));\r\n    data.addChildJVMArgs(this.jvmArgs.values(userArgs));\r\n    data.setFullMutationMatrix(this.fullMutationMatrixSpec.value(userArgs));\r\n    data.setDetectInlinedCode(userArgs.has(this.detectInlinedCode) && userArgs.valueOf(this.detectInlinedCode));\r\n    data.setIncludeLaunchClasspath(userArgs.valueOf(this.includeLaunchClasspathSpec));\r\n    data.setUseClasspathJar(userArgs.valueOf(useClasspathJarSpec));\r\n    data.setShouldCreateTimestampedReports(userArgs.valueOf(this.timestampedReportsSpec));\r\n    data.setNumberOfThreads(this.threadsSpec.value(userArgs));\r\n    data.setTimeoutFactor(this.timeoutFactorSpec.value(userArgs));\r\n    data.setTimeoutConstant(this.timeoutConstSpec.value(userArgs));\r\n    data.setLoggingClasses(this.avoidCallsSpec.values(userArgs));\r\n    data.setExcludedMethods(this.excludedMethodsSpec.values(userArgs));\r\n    data.setExcludedClasses(this.excludedClassesSpec.values(userArgs));\r\n    data.setExcludedTestClasses(FCollection.map(this.excludedTestClassesSpec.values(userArgs), Glob.toGlobPredicate()));\r\n    data.setVerbose(userArgs.has(this.verboseSpec) && userArgs.valueOf(this.verboseSpec));\r\n    data.addOutputFormats(this.outputFormatSpec.values(userArgs));\r\n    data.setFailWhenNoMutations(this.failWhenNoMutations.value(userArgs));\r\n    data.setCodePaths(this.codePaths.values(userArgs));\r\n    data.setMutationUnitSize(this.mutationUnitSizeSpec.value(userArgs));\r\n    data.setHistoryInputLocation(this.historyInputSpec.value(userArgs));\r\n    data.setHistoryOutputLocation(this.historyOutputSpec.value(userArgs));\r\n    data.setMutationThreshold(this.mutationThreshHoldSpec.value(userArgs));\r\n    data.setMaximumAllowedSurvivors(this.maxSurvivingSpec.value(userArgs));\r\n    data.setCoverageThreshold(this.coverageThreshHoldSpec.value(userArgs));\r\n    data.setMutationEngine(this.mutationEngine.value(userArgs));\r\n    data.setFreeFormProperties(listToProperties(this.pluginPropertiesSpec.values(userArgs)));\r\n    data.setExportLineCoverage(userArgs.has(this.exportLineCoverageSpec) && userArgs.valueOf(this.exportLineCoverageSpec));\r\n    setClassPath(userArgs, data);\r\n    setTestGroups(userArgs, data);\r\n    data.setIncludedTestMethods(this.includedTestMethodsSpec.values(userArgs));\r\n    data.setJavaExecutable(this.javaExecutable.value(userArgs));\r\n    if (userArgs.has(\"?\")) {\r\n        return new ParseResult(data, \"See above for supported parameters.\");\r\n    } else {\r\n        return new ParseResult(data, null);\r\n    }\r\n}"
}, {
	"Path": "com.turo.pushy.apns.ApnsClientBuilder.setConnectionTimeout",
	"Comment": "sets the maximum amount of time, in milliseconds, that the client under construction will wait to establish aconnection with the apns server before the connection attempt is considered a failure.",
	"Method": "ApnsClientBuilder setConnectionTimeout(long connectionTimeout,TimeUnit timeoutUnit){\r\n    this.connectionTimeoutMillis = (int) timeoutUnit.toMillis(connectionTimeout);\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.SSLUtils.getMergedTrustStore",
	"Comment": "this api is for temporary purpose. it will be removed once jsr 196 is updated.",
	"Method": "KeyStore getMergedTrustStore(){\r\n    return mergedTrustStore;\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.lexer.TemplateSource.advance",
	"Comment": "moves the start index a certain amount. while traversing this amount we will count how manynewlines have been encountered.",
	"Method": "void advance(int amount){\r\n    int index = 0;\r\n    while (index < amount) {\r\n        int sizeOfNewline = advanceThroughNewline(index);\r\n        if (sizeOfNewline > 0) {\r\n            index += sizeOfNewline;\r\n        } else {\r\n            index++;\r\n        }\r\n    }\r\n    this.size -= amount;\r\n    this.offset += amount;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.ClientChannelClassUtil.getSocketChannelClass",
	"Comment": "returns a socket channel class suitable for specified event loop group.",
	"Method": "Class<? extends SocketChannel> getSocketChannelClass(EventLoopGroup eventLoopGroup){\r\n    Objects.requireNonNull(eventLoopGroup);\r\n    final String socketChannelClassName = SOCKET_CHANNEL_CLASSES.get(eventLoopGroup.getClass().getName());\r\n    if (socketChannelClassName == null) {\r\n        throw new IllegalArgumentException(\"No socket channel class found for event loop group type: \" + eventLoopGroup.getClass().getName());\r\n    }\r\n    try {\r\n        return Class.forName(socketChannelClassName).asSubclass(SocketChannel.class);\r\n    } catch (final ClassNotFoundException e) {\r\n        throw new IllegalArgumentException(e);\r\n    }\r\n}"
}, {
	"Path": "ro.pippo.core.PippoSettings.getSettingNames",
	"Comment": "returns the list of settings whose name starts with the specified prefix. ifthe prefix is null or empty, all settings names are returned.",
	"Method": "List<String> getSettingNames(List<String> getSettingNames,String startingWith){\r\n    List<String> names = new ArrayList();\r\n    Properties props = getProperties();\r\n    if (StringUtils.isNullOrEmpty(startingWith)) {\r\n        names.addAll(props.stringPropertyNames());\r\n    } else {\r\n        startingWith = startingWith.toLowerCase();\r\n        for (Object o : props.keySet()) {\r\n            String name = o.toString();\r\n            if (name.toLowerCase().startsWith(startingWith)) {\r\n                names.add(name);\r\n            }\r\n        }\r\n    }\r\n    return names;\r\n}"
}, {
	"Path": "io.advantageous.qbit.admin.ServiceManagementBundle.recordTiming",
	"Comment": "prefixes the stats key with the stat key prefix, and then calls statscollector.recordtiming.",
	"Method": "void recordTiming(String statKey,long timeSpan){\r\n    final String longKey = getActualStatKey(statKey);\r\n    stats.recordTiming(longKey, timeSpan);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateFileUser.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names and thevalues the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    String fileRealmClassName = fileAuthRealm.getClassname();\r\n    if (fileRealmClassName != null && !fileRealmClassName.equals(\"com.sun.enterprise.security.auth.realm.file.FileRealm\")) {\r\n        report.setMessage(localStrings.getLocalString(\"create.file.user.realmnotsupported\", \"Configured file realm {0} is not supported.\", fileRealmClassName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String keyFile = null;\r\n    for (Property fileProp : fileAuthRealm.getProperty()) {\r\n        if (fileProp.getName().equals(\"file\"))\r\n            keyFile = fileProp.getValue();\r\n    }\r\n    final String kf = keyFile;\r\n    if (keyFile == null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.file.user.keyfilenotfound\", \"There is no physical file associated with this file realm {0} \", authRealmName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    boolean exists = (new File(kf)).exists();\r\n    if (!exists) {\r\n        report.setMessage(localStrings.getLocalString(\"file.realm.keyfilenonexistent\", \"The specified physical file {0} associated with the file realm {1} does not exist.\", new Object[] { kf, authRealmName }));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    final String password = userpassword;\r\n    if (password == null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.file.user.keyfilenotreadable\", \"Password for user {0} \" + \"has to be specified in --userpassword option or supplied \" + \"through AS_ADMIN_USERPASSWORD property in the file specified \" + \"in --passwordfile option\", userName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    secureAdmin = domain.getSecureAdmin();\r\n    if ((SecureAdmin.Util.isEnabled(secureAdmin)) && (authRealmName.equals(adminService.getAuthRealmName()))) {\r\n        if (password.isEmpty()) {\r\n            report.setMessage(localStrings.getLocalString(\"null_empty_password\", \"The admin user password is null or empty\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<SecurityService>() {\r\n            public Object run(SecurityService param) throws PropertyVetoException, TransactionFailure {\r\n                try {\r\n                    realmsManager.createRealms(config);\r\n                    refreshRealm(config.getName(), authRealmName);\r\n                    FileRealm fileRealm = (FileRealm) realmsManager.getFromLoadedRealms(config.getName(), authRealmName);\r\n                    CreateFileUser.handleAdminGroup(authRealmName, groups);\r\n                    String[] groups1 = groups.toArray(new String[groups.size()]);\r\n                    fileRealm.addUser(userName, password.toCharArray(), groups1);\r\n                    fileRealm.persist();\r\n                    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n                } catch (Exception e) {\r\n                    String localalizedErrorMsg = (e.getLocalizedMessage() == null) ? \"\" : e.getLocalizedMessage();\r\n                    report.setMessage(localStrings.getLocalString(\"create.file.user.useraddfailed\", \"Adding User {0} to the file realm {1} failed\", userName, authRealmName) + \"  \" + localalizedErrorMsg);\r\n                    report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                    report.setFailureCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        }, securityService);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"create.file.user.useraddfailed\", \"Adding User {0} to the file realm {1} failed\", userName, authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateFileUser.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names and thevalues the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    try {\r\n        realmsManager.createRealms(config);\r\n        refreshRealm(config.getName(), authRealmName);\r\n        FileRealm fileRealm = (FileRealm) realmsManager.getFromLoadedRealms(config.getName(), authRealmName);\r\n        CreateFileUser.handleAdminGroup(authRealmName, groups);\r\n        String[] groups1 = groups.toArray(new String[groups.size()]);\r\n        fileRealm.addUser(userName, password.toCharArray(), groups1);\r\n        fileRealm.persist();\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (Exception e) {\r\n        String localalizedErrorMsg = (e.getLocalizedMessage() == null) ? \"\" : e.getLocalizedMessage();\r\n        report.setMessage(localStrings.getLocalString(\"create.file.user.useraddfailed\", \"Adding User {0} to the file realm {1} failed\", userName, authRealmName) + \"  \" + localalizedErrorMsg);\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.lexer.LexerImpl.pushToken",
	"Comment": "create a token of a certain type but has no particular value. this will pass control to theoverloaded method that will push this token into a list of tokens that we are maintaining.",
	"Method": "Token pushToken(Token.Type type,Token pushToken,Token.Type type,String value){\r\n    if (type.equals(Token.Type.TEXT) && (value == null || \"\".equals(value))) {\r\n        return null;\r\n    }\r\n    Token result = new Token(type, value, this.source.getLineNumber());\r\n    this.tokens.add(result);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.admin.cli.SecureAdminHelperImpl.validateInternalUsernameAndPasswordAlias",
	"Comment": "makes sure the username is a valid admin username and that the passwordalias is defined.this method does not make sure that the passwordassociated with the username and the password associated with the password alias are the same.",
	"Method": "void validateInternalUsernameAndPasswordAlias(String username,String passwordAlias){\r\n    try {\r\n        validateUser(username);\r\n        validatePasswordAlias(passwordAlias);\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(Strings.get(\"errVal\"), ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.Realm._getInstance",
	"Comment": "this is a private method for getting realm instance. if realm does not exist, then it will notreturn null rather than throw exception.",
	"Method": "Realm _getInstance(String name,Realm _getInstance,String configName,String name){\r\n    RealmsManager mgr = getRealmsManager();\r\n    if (mgr != null) {\r\n        return mgr._getInstance(configName, name);\r\n    } else {\r\n        throw new RuntimeException(\"Unable to locate RealmsManager Service\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.ldap.LDAPRealm.init",
	"Comment": "initialize a realm with some properties. this can be used when instantiating realms from their descriptions. thismethod may only be called a single time.",
	"Method": "void init(Properties props){\r\n    super.init(props);\r\n    String url = props.getProperty(PARAM_DIRURL);\r\n    String dn = props.getProperty(PARAM_USERDN);\r\n    String jaasCtx = props.getProperty(JAAS_CONTEXT_PARAM);\r\n    if (url == null || dn == null || jaasCtx == null) {\r\n        throw new BadRealmException(sm.getString(\"ldaprealm.badconfig\", url, dn, jaasCtx));\r\n    }\r\n    this.setProperty(PARAM_DIRURL, url);\r\n    ldapBindProps.setProperty(Context.PROVIDER_URL, url);\r\n    this.setProperty(PARAM_USERDN, dn);\r\n    this.setProperty(JAAS_CONTEXT_PARAM, jaasCtx);\r\n    String mode = props.getProperty(PARAM_MODE, MODE_DEFAULT);\r\n    if (!MODE_DEFAULT.equals(mode)) {\r\n        throw new BadRealmException(sm.getString(\"ldaprealm.badmode\", mode));\r\n    }\r\n    this.setProperty(PARAM_MODE, mode);\r\n    String ctxF = props.getProperty(PARAM_JNDICF, JNDICF_DEFAULT);\r\n    this.setProperty(PARAM_JNDICF, ctxF);\r\n    ldapBindProps.setProperty(Context.INITIAL_CONTEXT_FACTORY, ctxF);\r\n    String searchFilter = props.getProperty(PARAM_SEARCH_FILTER, SEARCH_FILTER_DEFAULT);\r\n    this.setProperty(PARAM_SEARCH_FILTER, searchFilter);\r\n    String grpDN = props.getProperty(PARAM_GRPDN, dn);\r\n    this.setProperty(PARAM_GRPDN, grpDN);\r\n    String grpSearchFilter = props.getProperty(PARAM_GRP_SEARCH_FILTER, GRP_SEARCH_FILTER_DEFAULT);\r\n    this.setProperty(PARAM_GRP_SEARCH_FILTER, grpSearchFilter);\r\n    String dynGrpSearchFilter = props.getProperty(PARAM_DYNAMIC_GRP_FILTER, SEARCH_FILTER_DEFAULT);\r\n    this.setProperty(PARAM_DYNAMIC_GRP_FILTER, dynGrpSearchFilter);\r\n    String grpTarget = props.getProperty(PARAM_GRP_TARGET, GRP_TARGET_DEFAULT);\r\n    this.setProperty(PARAM_GRP_TARGET, grpTarget);\r\n    String dynGrpTarget = props.getProperty(PARAM_DYNAMIC_GRP_TARGET, DYNAMIC_GRP_TARGET_DEFAULT);\r\n    this.setProperty(PARAM_DYNAMIC_GRP_TARGET, dynGrpTarget);\r\n    String objectFactory = props.getProperty(DYNAMIC_GROUP_FACTORY_OBJECT_PROPERTY, DYNAMIC_GROUP_OBJECT_FACTORY);\r\n    this.setProperty(DYNAMIC_GROUP_FACTORY_OBJECT_PROPERTY, objectFactory);\r\n    ldapBindProps.setProperty(DYNAMIC_GROUP_FACTORY_OBJECT_PROPERTY, objectFactory);\r\n    String stateFactory = props.getProperty(DYNAMIC_GROUP_STATE_FACTORY_PROPERTY, DYNAMIC_GROUP_STATE_FACTORY);\r\n    this.setProperty(DYNAMIC_GROUP_STATE_FACTORY_PROPERTY, stateFactory);\r\n    ldapBindProps.setProperty(DYNAMIC_GROUP_STATE_FACTORY_PROPERTY, stateFactory);\r\n    String bindDN = props.getProperty(PARAM_BINDDN);\r\n    if (bindDN != null) {\r\n        this.setProperty(PARAM_BINDDN, bindDN);\r\n        ldapBindProps.setProperty(Context.SECURITY_PRINCIPAL, bindDN);\r\n    }\r\n    String bindPWD = props.getProperty(PARAM_BINDPWD);\r\n    if (bindPWD != null) {\r\n        try {\r\n            bindPWD = RelativePathResolver.getRealPasswordFromAlias(bindPWD);\r\n        } catch (Exception ex) {\r\n            _logger.log(Level.WARNING, \"ldaprealm.pwd.dealiasing.failed\", ex);\r\n        }\r\n        this.setProperty(PARAM_BINDPWD, bindPWD);\r\n        ldapBindProps.setProperty(Context.SECURITY_CREDENTIALS, bindPWD);\r\n    }\r\n    Enumeration penum = props.propertyNames();\r\n    while (penum.hasMoreElements()) {\r\n        String propName = (String) penum.nextElement();\r\n        if (propName.startsWith(\"java.naming.\") || propName.startsWith(\"javax.security.\") || propName.startsWith(\"com.sun.jndi.ldap.\")) {\r\n            ldapBindProps.setProperty(propName, props.getProperty(propName));\r\n        } else if (propName.startsWith(SUN_JNDI_POOL_) && !SUN_JNDI_POOL_MAXSIZE.equals(propName)) {\r\n            if (System.getProperty(propName) == null) {\r\n                System.setProperty(propName, props.getProperty(propName));\r\n            }\r\n        }\r\n    }\r\n    String poolSize = Integer.getInteger(PARAM_POOLSIZE, POOLSIZE_DEFAULT).toString();\r\n    String sunPoolSizeStr = props.getProperty(SUN_JNDI_POOL_MAXSIZE, poolSize);\r\n    try {\r\n        sunPoolSizeStr = Integer.valueOf(sunPoolSizeStr).toString();\r\n    } catch (Exception ex) {\r\n        sunPoolSizeStr = poolSize;\r\n    }\r\n    if (System.getProperty(SUN_JNDI_POOL_MAXSIZE) == null) {\r\n        System.setProperty(SUN_JNDI_POOL_MAXSIZE, sunPoolSizeStr);\r\n    }\r\n    this.setProperty(PARAM_POOLSIZE, sunPoolSizeStr);\r\n    String usePool = props.getProperty(SUN_JNDI_POOL, \"true\");\r\n    ldapBindProps.setProperty(SUN_JNDI_POOL, usePool);\r\n    if (url.startsWith(LDAPS_URL)) {\r\n        ldapBindProps.setProperty(LDAP_SOCKET_FACTORY, DEFAULT_SSL_LDAP_SOCKET_FACTORY);\r\n        if (System.getProperty(SUN_JNDI_POOL_PROTOCOL) == null) {\r\n            System.setProperty(SUN_JNDI_POOL_PROTOCOL, DEFAULT_POOL_PROTOCOL);\r\n        }\r\n        _logger.log(FINE, \"LDAPRealm : Using custom socket factory for SSL with pooling\");\r\n    }\r\n    if (_logger.isLoggable(FINE)) {\r\n        Properties tempProps = (Properties) ldapBindProps.clone();\r\n        tempProps.remove(Context.SECURITY_CREDENTIALS);\r\n        _logger.log(Level.FINE, \"LDAPRealm : {0}\", tempProps);\r\n    }\r\n    groupCache = new HashMap();\r\n}"
}, {
	"Path": "org.pitest.mutationtest.engine.MutationDetails.getDescription",
	"Comment": "returns the human readable description of the mutation. this may be aconstant string or may provide more contextual information depending on themutation operator.",
	"Method": "String getDescription(){\r\n    return this.description;\r\n}"
}, {
	"Path": "ro.pippo.core.util.StringUtils.getPrefix",
	"Comment": "returns the prefix of the input string from 0 to the first index of the delimiter or it returns the input string.",
	"Method": "String getPrefix(String input,char delimiter){\r\n    int index = input.indexOf(delimiter);\r\n    if (index > -1) {\r\n        return input.substring(0, index);\r\n    }\r\n    return input;\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.Game.notifyPlayerInfoChange",
	"Comment": "sends updated player information about a specific player to all players in the game.",
	"Method": "void notifyPlayerInfoChange(Player player){\r\n    final HashMap<ReturnableData, Object> data = getEventMap();\r\n    data.put(LongPollResponse.EVENT, LongPollEvent.GAME_PLAYER_INFO_CHANGE.toString());\r\n    data.put(LongPollResponse.PLAYER_INFO, getPlayerInfo(player));\r\n    broadcastToPlayers(MessageType.GAME_PLAYER_EVENT, data);\r\n}"
}, {
	"Path": "ro.pippo.core.AbstractTemplateEngine.getTemplatePathPrefix",
	"Comment": "returns the template path prefix to be used to load template resources.",
	"Method": "String getTemplatePathPrefix(){\r\n    return templatePathPrefix;\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.discovery.ServiceDiscovery.registerWithId",
	"Comment": "register with id. specify a unique id that is not autogenerated",
	"Method": "EndpointDefinition registerWithId(String serviceName,String serviceId,String host,int port){\r\n    return new EndpointDefinition(HealthStatus.PASS, serviceId, serviceName, host, port);\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.StrictModeTest.testSimpleVariable",
	"Comment": "tests that the line number and file name is correctly passed to the exception in strict mode.",
	"Method": "void testSimpleVariable(){\r\n    PebbleEngine pebble = new PebbleEngine.Builder().strictVariables(true).build();\r\n    PebbleTemplate template = pebble.getTemplate(\"templates/template.strictModeSimpleExpression.peb\");\r\n    Map<String, Object> context = new HashMap();\r\n    Writer writer = new StringWriter();\r\n    try {\r\n        template.evaluate(writer, context);\r\n        Assert.fail(\"Exception \" + RootAttributeNotFoundException.class.getCanonicalName() + \" is expected.\");\r\n    } catch (RootAttributeNotFoundException e) {\r\n        Assert.assertEquals(\"templates/template.strictModeSimpleExpression.peb\", e.getFileName());\r\n        Assert.assertEquals((Integer) 2, e.getLineNumber());\r\n    }\r\n}"
}, {
	"Path": "com.turo.pushy.apns.util.ApnsPayloadBuilder.setContentAvailable",
	"Comment": "sets whether the payload under construction should contain a flag that indicates that new content is availableto be downloaded in the background by the receiving app. by default, no content availability flag is includedin the payload.",
	"Method": "ApnsPayloadBuilder setContentAvailable(boolean contentAvailable){\r\n    this.contentAvailable = contentAvailable;\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.setClientSecurityContext",
	"Comment": "sets the security context on the appclient side. it sets the relevant information into the tls",
	"Method": "void setClientSecurityContext(String username,Subject subject){\r\n    ClientSecurityContext securityContext = new ClientSecurityContext(username, subject);\r\n    ClientSecurityContext.setCurrent(securityContext);\r\n}"
}, {
	"Path": "ro.pippo.core.Application.createRequestResponseFactory",
	"Comment": "override this method if you want a custom requestresponsefactory.",
	"Method": "RequestResponseFactory createRequestResponseFactory(){\r\n    return new GZipRequestResponseFactory(this);\r\n}"
}, {
	"Path": "ro.pippo.core.PippoSettings.getIntegers",
	"Comment": "returns a list of integers from the specified name using the specified delimiter.",
	"Method": "List<Integer> getIntegers(String name,List<Integer> getIntegers,String name,String delimiter){\r\n    List<String> strings = getStrings(name, delimiter);\r\n    List<Integer> ints = new ArrayList(strings.size());\r\n    for (String value : strings) {\r\n        try {\r\n            int i = Integer.parseInt(value);\r\n            ints.add(i);\r\n        } catch (NumberFormatException e) {\r\n        }\r\n    }\r\n    return Collections.unmodifiableList(ints);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.WebAndEjbToJaasBridge.logout",
	"Comment": "this method logs out the user by clearing the security context.",
	"Method": "void logout(){\r\n    unsetSecurityContext();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.file.FileRealm.init",
	"Comment": "initialize a realm with some properties. this can be used when instantiating realms from their descriptions. thismethod is invoked from realm during initialization.",
	"Method": "void init(Properties props){\r\n    super.init(props);\r\n    String file = props.getProperty(PARAM_KEYFILE);\r\n    if (file == null) {\r\n        throw new BadRealmException(sm.getString(\"filerealm.nofile\"));\r\n    }\r\n    if (file.contains(\"$\")) {\r\n        file = RelativePathResolver.resolvePath(file);\r\n    }\r\n    setProperty(PARAM_KEYFILE, file);\r\n    String jaasCtx = props.getProperty(JAAS_CONTEXT_PARAM);\r\n    if (jaasCtx == null) {\r\n        throw new BadRealmException(sm.getString(\"filerealm.nomodule\"));\r\n    }\r\n    setProperty(BaseRealm.JAAS_CONTEXT_PARAM, jaasCtx);\r\n    _logger.log(Level.FINE, \"FileRealm : \" + PARAM_KEYFILE + \"={0}\", file);\r\n    _logger.log(Level.FINE, \"FileRealm : \" + JAAS_CONTEXT_PARAM + \"={0}\", jaasCtx);\r\n    try {\r\n        if (isEmbeddedServer()) {\r\n            file = writeConfigFileToTempDir(file).getAbsolutePath();\r\n        }\r\n        fileRealmStorageManager = new FileRealmStorageManager(file);\r\n    } catch (IOException ioe) {\r\n        throw new BadRealmException(sm.getString(\"filerealm.noaccess\", ioe.toString()));\r\n    }\r\n}"
}, {
	"Path": "co.yiiu.pybbs.util.bcrypt.BCrypt.crypt_raw",
	"Comment": "perform the central password hashing step in the bcrypt scheme",
	"Method": "byte[] crypt_raw(byte password,byte salt,int log_rounds){\r\n    int[] cdata = (int[]) bf_crypt_ciphertext.clone();\r\n    int clen = cdata.length;\r\n    byte[] ret;\r\n    long rounds = roundsForLogRounds(log_rounds);\r\n    init_key();\r\n    ekskey(salt, password);\r\n    for (long i = 0; i < rounds; i++) {\r\n        key(password);\r\n        key(salt);\r\n    }\r\n    for (int i = 0; i < 64; i++) {\r\n        for (int j = 0; j < (clen >> 1); j++) {\r\n            encipher(cdata, j << 1);\r\n        }\r\n    }\r\n    ret = new byte[clen * 4];\r\n    for (int i = 0, j = 0; i < clen; i++) {\r\n        ret[j++] = (byte) ((cdata[i] >> 24) & 0xff);\r\n        ret[j++] = (byte) ((cdata[i] >> 16) & 0xff);\r\n        ret[j++] = (byte) ((cdata[i] >> 8) & 0xff);\r\n        ret[j++] = (byte) (cdata[i] & 0xff);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.certificate.CertificateRealm.init",
	"Comment": "initialize a realm with some properties. this can be used when instantiating realms from their descriptions. thismethod is invoked from realm during initialization.",
	"Method": "void init(Properties props){\r\n    super.init(props);\r\n    String[] groups = addAssignGroups(null);\r\n    if (groups != null && groups.length > 0) {\r\n        defaultGroups.addAll(Arrays.asList(groups));\r\n    }\r\n    String jaasCtx = props.getProperty(JAAS_CONTEXT_PARAM);\r\n    if (jaasCtx != null) {\r\n        setProperty(JAAS_CONTEXT_PARAM, jaasCtx);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.getServerAliases",
	"Comment": "return all the available server aliases for the specified key type.",
	"Method": "String[] getServerAliases(String keyType,Principal[] issuers){\r\n    _logger.log(FINE, \"Getting server aliases\");\r\n    return x509KeyManager.getServerAliases(keyType, issuers);\r\n}"
}, {
	"Path": "org.glassfish.tests.utils.NucleusTestUtils.matchString",
	"Comment": "returns true if string b contains string a.returns true if both strings are null.returns false if only one of the strings is null.",
	"Method": "boolean matchString(String a,String b){\r\n    if ((a == null) && (b == null))\r\n        return true;\r\n    if (a == null)\r\n        return false;\r\n    if (b == null)\r\n        return false;\r\n    return b.indexOf(a) != -1;\r\n}"
}, {
	"Path": "psiprobe.ProbeSecurityConfig.getPreAuthenticatedGrantedAuthoritiesUserDetailsService",
	"Comment": "gets the pre authenticated granted authorities user details service.",
	"Method": "PreAuthenticatedGrantedAuthoritiesUserDetailsService getPreAuthenticatedGrantedAuthoritiesUserDetailsService(){\r\n    return new PreAuthenticatedGrantedAuthoritiesUserDetailsService();\r\n}"
}, {
	"Path": "com.rabbitmq.client.ConnectionFactory.setExceptionHandler",
	"Comment": "set the exception handler to use for newly created connections.",
	"Method": "void setExceptionHandler(ExceptionHandler exceptionHandler){\r\n    if (exceptionHandler == null) {\r\n        throw new IllegalArgumentException(\"exception handler cannot be null!\");\r\n    }\r\n    this.exceptionHandler = exceptionHandler;\r\n}"
}, {
	"Path": "com.rabbitmq.client.ConnectionFactory.setTopologyRecoveryRetryHandler",
	"Comment": "set retry handler for topology recovery.default is no retry.",
	"Method": "void setTopologyRecoveryRetryHandler(RetryHandler topologyRecoveryRetryHandler){\r\n    this.topologyRecoveryRetryHandler = topologyRecoveryRetryHandler;\r\n}"
}, {
	"Path": "io.advantageous.qbit.reactive.Reactor.removeFuture",
	"Comment": "remove a callback from the list of callbacks that we are managing.",
	"Method": "AsyncFutureCallback<T> removeFuture(AsyncFutureCallback<T> asyncFutureCallback){\r\n    this.removeFutureQueue.offer(asyncFutureCallback);\r\n    return asyncFutureCallback;\r\n}"
}, {
	"Path": "org.pitest.mutationtest.engine.MutationDetails.getLineNumber",
	"Comment": "returns the line number on which the mutation occurs as reported within thejvm bytecode",
	"Method": "int getLineNumber(){\r\n    return this.lineNumber;\r\n}"
}, {
	"Path": "ro.pippo.session.xmemcached.XmemcachedSessionDataStorageTest.testGet",
	"Comment": "test of get method, of class xmemcachedsessiondatastorage.",
	"Method": "void testGet(){\r\n    System.out.println(\"get\");\r\n    XmemcachedSessionDataStorage instance = new XmemcachedSessionDataStorage(client, IDLE_TIME);\r\n    SessionData sessionData = instance.create();\r\n    String sessionId = sessionData.getId();\r\n    sessionData.put(KEY, VALUE);\r\n    instance.save(sessionData);\r\n    SessionData saved = instance.get(sessionId);\r\n    assertEquals(sessionData, saved);\r\n    String value1 = sessionData.get(KEY);\r\n    String value2 = saved.get(KEY);\r\n    assertEquals(value1, value2);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.WebAndEjbToJaasBridge.unsetSecurityContext",
	"Comment": "set the current security context on the thread local storage to null.",
	"Method": "void unsetSecurityContext(){\r\n    SecurityContext.setCurrent((SecurityContext) null);\r\n}"
}, {
	"Path": "com.turo.pushy.apns.ApnsChannelPool.close",
	"Comment": "shuts down this channel pool and releases all retained resources.",
	"Method": "Future<Void> close(){\r\n    return this.allChannels.close().addListener(new GenericFutureListener<Future<Void>>() {\r\n        @Override\r\n        public void operationComplete(final Future<Void> future) throws Exception {\r\n            ApnsChannelPool.this.isClosed = true;\r\n            if (ApnsChannelPool.this.channelFactory instanceof Closeable) {\r\n                ((Closeable) ApnsChannelPool.this.channelFactory).close();\r\n            }\r\n            for (final Promise<Channel> acquisitionPromise : ApnsChannelPool.this.pendingAcquisitionPromises) {\r\n                acquisitionPromise.tryFailure(POOL_CLOSED_EXCEPTION);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.turo.pushy.apns.ApnsChannelPool.close",
	"Comment": "shuts down this channel pool and releases all retained resources.",
	"Method": "Future<Void> close(){\r\n    ApnsChannelPool.this.isClosed = true;\r\n    if (ApnsChannelPool.this.channelFactory instanceof Closeable) {\r\n        ((Closeable) ApnsChannelPool.this.channelFactory).close();\r\n    }\r\n    for (final Promise<Channel> acquisitionPromise : ApnsChannelPool.this.pendingAcquisitionPromises) {\r\n        acquisitionPromise.tryFailure(POOL_CLOSED_EXCEPTION);\r\n    }\r\n}"
}, {
	"Path": "io.nayuki.qrcodegen.QrCode.encodeBinary",
	"Comment": "returns a qr code representing the specified binary data at the specified error correction level.\tthis function always encodes using the binary segment mode, not any text mode. the maximum number of\tbytes allowed is 2953. the smallest possible qr code version is automatically chosen for the output.\tthe ecc level of the result may be higher than the ecl argument if it can be done without increasing the version.",
	"Method": "QrCode encodeBinary(byte[] data,Ecc ecl){\r\n    Objects.requireNonNull(data);\r\n    Objects.requireNonNull(ecl);\r\n    QrSegment seg = QrSegment.makeBytes(data);\r\n    return encodeSegments(Arrays.asList(seg), ecl);\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.GetAttributeTest.testMethodAttributeWithDifferentObjects",
	"Comment": "the getattribute expression involves caching, we test with different objects to make sure thatthe caching doesnt have any negative side effects.",
	"Method": "void testMethodAttributeWithDifferentObjects(){\r\n    PebbleEngine pebble = new PebbleEngine.Builder().loader(new StringLoader()).strictVariables(true).build();\r\n    PebbleTemplate template = pebble.getTemplate(\"hello {{ object.name }}\");\r\n    Map<String, Object> context1 = new HashMap();\r\n    context1.put(\"object\", new CustomizableObject(\"Alex\"));\r\n    Writer writer1 = new StringWriter();\r\n    template.evaluate(writer1, context1);\r\n    assertEquals(\"hello Alex\", writer1.toString());\r\n    Map<String, Object> context2 = new HashMap();\r\n    context2.put(\"object\", new CustomizableObject(\"Steve\"));\r\n    Writer writer2 = new StringWriter();\r\n    template.evaluate(writer2, context2);\r\n    assertEquals(\"hello Steve\", writer2.toString());\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.ListPasswordAlias.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        final Iterator<String> it = domainPasswordAliasStore.keys();\r\n        if (!it.hasNext()) {\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n            report.setMessage(localStrings.getLocalString(\"list.password.alias.nothingtolist\", \"Nothing to list\"));\r\n        }\r\n        while (it.hasNext()) {\r\n            ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            part.setMessage(it.next());\r\n        }\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n        report.setMessage(localStrings.getLocalString(\"list.password.alias.fail\", \"Listing of Password Alias failed\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(ex);\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.sendQueue",
	"Comment": "create a wrapper sendqueue that encoders the objects to jsonbefore putting them into the queue.",
	"Method": "SendQueue<T> sendQueue(){\r\n    final SendQueue<String> sendQueue = queue.sendQueue();\r\n    return createJsonSendQueue(sendQueue);\r\n}"
}, {
	"Path": "com.feth.play.module.pa.providers.password.UsernamePasswordAuthProvider.getEmailName",
	"Comment": "you might overwrite this to provide your own recipient format\timplementation,\thowever the default should be fine for most cases",
	"Method": "String getEmailName(US user,String getEmailName,String email,String name){\r\n    return Mailer.getEmailName(email, name);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.ListFileGroup.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        FileRealm fr = getFileRealm(securityService, fileAuthRealm, report);\r\n        if (fr == null) {\r\n            return;\r\n        }\r\n        Enumeration groups = null;\r\n        if (fileUserName != null) {\r\n            fr.getUser(fileUserName);\r\n            groups = fr.getGroupNames(fileUserName);\r\n        } else {\r\n            groups = fr.getGroupNames();\r\n        }\r\n        report.getTopMessagePart().setMessage(localStrings.getLocalString(\"list.file.group.success\", \"list-file-groups successful\"));\r\n        report.getTopMessagePart().setChildrenType(\"file-group\");\r\n        while (groups.hasMoreElements()) {\r\n            final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            part.setMessage((String) groups.nextElement());\r\n        }\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (BadRealmException e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.file.group.realmcorrupted\", \"Configured file realm {0} is corrupted.\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    } catch (NoSuchUserException e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.file.group.usernotfound\", \"Specified file user {0} not found.\", fileUserName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.discovery.EndpointDefinition.serviceDefinition",
	"Comment": "creates a endpointdefinition for a service, i.e., a servicedefinition.",
	"Method": "EndpointDefinition serviceDefinition(String name,EndpointDefinition serviceDefinition,String name,int port,EndpointDefinition serviceDefinition,String id,String name,String host,int port,EndpointDefinition serviceDefinition,String id,String name,String host,int port,List<String> tags,EndpointDefinition serviceDefinition,String name,String host,int port,EndpointDefinition serviceDefinition,String name,String host){\r\n    return new EndpointDefinition(HealthStatus.PASS, name + \"-\" + uniqueString(0), name, host, 0);\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.receiveQueue",
	"Comment": "create a wrapper receivequeue that does decoding on the fly.",
	"Method": "ReceiveQueue<T> receiveQueue(){\r\n    final ReceiveQueue<String> receiveQueue = queue.receiveQueue();\r\n    return new ReceiveQueue<T>() {\r\n        @Override\r\n        public T pollWait() {\r\n            final String item = receiveQueue.pollWait();\r\n            return getParsedItem(item);\r\n        }\r\n        private T getParsedItem(String item) {\r\n            if (item != null) {\r\n                return fromJsonFunction.apply(item);\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        @Override\r\n        public T poll() {\r\n            final String item = receiveQueue.pollWait();\r\n            return getParsedItem(item);\r\n        }\r\n        @Override\r\n        public T take() {\r\n            final String item = receiveQueue.take();\r\n            return getParsedItem(item);\r\n        }\r\n        @Override\r\n        public Iterable<T> readBatch(int max) {\r\n            final Iterable<String> iterable = receiveQueue.readBatch(max);\r\n            return getParsedItems(iterable);\r\n        }\r\n        private Iterable<T> getParsedItems(Iterable<String> iterable) {\r\n            int size = 16;\r\n            if (iterable instanceof List) {\r\n                size = ((List) iterable).size();\r\n            }\r\n            final List<T> items = new ArrayList(size);\r\n            for (String item : iterable) {\r\n                items.add(getParsedItem(item));\r\n            }\r\n            return items;\r\n        }\r\n        @Override\r\n        public Iterable<T> readBatch() {\r\n            final Iterable<String> iterable = receiveQueue.readBatch();\r\n            return getParsedItems(iterable);\r\n        }\r\n        @Override\r\n        public void stop() {\r\n            receiveQueue.stop();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.receiveQueue",
	"Comment": "create a wrapper receivequeue that does decoding on the fly.",
	"Method": "ReceiveQueue<T> receiveQueue(){\r\n    final String item = receiveQueue.pollWait();\r\n    return getParsedItem(item);\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.receiveQueue",
	"Comment": "create a wrapper receivequeue that does decoding on the fly.",
	"Method": "ReceiveQueue<T> receiveQueue(){\r\n    if (item != null) {\r\n        return fromJsonFunction.apply(item);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.receiveQueue",
	"Comment": "create a wrapper receivequeue that does decoding on the fly.",
	"Method": "ReceiveQueue<T> receiveQueue(){\r\n    final String item = receiveQueue.pollWait();\r\n    return getParsedItem(item);\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.receiveQueue",
	"Comment": "create a wrapper receivequeue that does decoding on the fly.",
	"Method": "ReceiveQueue<T> receiveQueue(){\r\n    final String item = receiveQueue.take();\r\n    return getParsedItem(item);\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.receiveQueue",
	"Comment": "create a wrapper receivequeue that does decoding on the fly.",
	"Method": "ReceiveQueue<T> receiveQueue(){\r\n    final Iterable<String> iterable = receiveQueue.readBatch(max);\r\n    return getParsedItems(iterable);\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.receiveQueue",
	"Comment": "create a wrapper receivequeue that does decoding on the fly.",
	"Method": "ReceiveQueue<T> receiveQueue(){\r\n    int size = 16;\r\n    if (iterable instanceof List) {\r\n        size = ((List) iterable).size();\r\n    }\r\n    final List<T> items = new ArrayList(size);\r\n    for (String item : iterable) {\r\n        items.add(getParsedItem(item));\r\n    }\r\n    return items;\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.receiveQueue",
	"Comment": "create a wrapper receivequeue that does decoding on the fly.",
	"Method": "ReceiveQueue<T> receiveQueue(){\r\n    final Iterable<String> iterable = receiveQueue.readBatch();\r\n    return getParsedItems(iterable);\r\n}"
}, {
	"Path": "io.advantageous.qbit.queue.JsonQueue.receiveQueue",
	"Comment": "create a wrapper receivequeue that does decoding on the fly.",
	"Method": "ReceiveQueue<T> receiveQueue(){\r\n    receiveQueue.stop();\r\n}"
}, {
	"Path": "io.advantageous.qbit.service.impl.ServiceBundleImpl.createLocalProxy",
	"Comment": "creates a proxy interface to a particular client. given a particular address.",
	"Method": "T createLocalProxy(Class<T> serviceInterface,String myService){\r\n    final Consumer<MethodCall<Object>> callConsumer = this.serviceMapping.get(myService);\r\n    if (callConsumer == null) {\r\n        logger.error(\"Service requested does not exist \" + myService);\r\n    }\r\n    return factory.createLocalProxy(serviceInterface, myService, this, beforeMethodSent);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteAuditModule.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ActionReport report = context.getActionReport();\r\n    try {\r\n        if (auditModule == null) {\r\n            report.setMessage(localStrings.getLocalString(\"delete.audit.module.notfound\", \"Specified Audit Module {0} not found\", auditModuleName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n        ConfigSupport.apply(new SingleConfigCode<SecurityService>() {\r\n            public Object run(SecurityService param) throws PropertyVetoException, TransactionFailure {\r\n                param.getAuditModule().remove(auditModule);\r\n                return null;\r\n            }\r\n        }, securityService);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.audit.module.fail\", \"Deletion of Audit Module {0} failed\", auditModuleName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteAuditModule.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    param.getAuditModule().remove(auditModule);\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.Realm.addAssignGroups",
	"Comment": "add assign groups to given array of groups. to be used by getgroupnames.",
	"Method": "String[] addAssignGroups(String[] grps){\r\n    String[] resultGroups = grps;\r\n    if (assignGroups != null && assignGroups.size() > 0) {\r\n        List<String> groupList = new ArrayList<String>();\r\n        if (grps != null && grps.length > 0) {\r\n            for (String grp : grps) {\r\n                groupList.add(grp);\r\n            }\r\n        }\r\n        for (String agrp : assignGroups) {\r\n            if (!groupList.contains(agrp)) {\r\n                groupList.add(agrp);\r\n            }\r\n        }\r\n        resultGroups = groupList.toArray(new String[groupList.size()]);\r\n    }\r\n    return resultGroups;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateMessageSecurityProvider.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    List<MessageSecurityConfig> mscs = secService.getMessageSecurityConfig();\r\n    MessageSecurityConfig msgSecCfg = null;\r\n    for (MessageSecurityConfig msc : mscs) {\r\n        if (msc.getAuthLayer().equals(authLayer)) {\r\n            msgSecCfg = msc;\r\n        }\r\n    }\r\n    if (msgSecCfg != null) {\r\n        List<ProviderConfig> pcs = msgSecCfg.getProviderConfig();\r\n        for (ProviderConfig pc : pcs) {\r\n            if (pc.getProviderId().equals(providerId)) {\r\n                report.setMessage(localStrings.getLocalString(\"create.message.security.provider.duplicatefound\", \"Message security provider named {0} exists. \" + \"Cannot add duplicate.\", providerId));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n        try {\r\n            ConfigSupport.apply(new SingleConfigCode<MessageSecurityConfig>() {\r\n                public Object run(MessageSecurityConfig param) throws PropertyVetoException, TransactionFailure {\r\n                    ProviderConfig newPC = param.createChild(ProviderConfig.class);\r\n                    populateProviderConfigElement(newPC);\r\n                    param.getProviderConfig().add(newPC);\r\n                    if (isDefaultProvider) {\r\n                        if (providerType.equals(SERVER) || providerType.equals(CLIENT_SERVER))\r\n                            param.setDefaultProvider(providerId);\r\n                        if (providerType.equals(CLIENT) || providerType.equals(CLIENT_SERVER))\r\n                            param.setDefaultClientProvider(providerId);\r\n                    }\r\n                    return newPC;\r\n                }\r\n            }, msgSecCfg);\r\n        } catch (TransactionFailure e) {\r\n            report.setMessage(localStrings.getLocalString(\"create.message.security.provider.fail\", \"Creation of message security provider named {0} failed\", providerId));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setFailureCause(e);\r\n            return;\r\n        }\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        report.setMessage(localStrings.getLocalString(\"create.message.security.provider.success\", \"Creation of message security provider named {0} completed \" + \"successfully\", providerId));\r\n    } else {\r\n        try {\r\n            ConfigSupport.apply(new SingleConfigCode<SecurityService>() {\r\n                public Object run(SecurityService param) throws PropertyVetoException, TransactionFailure {\r\n                    MessageSecurityConfig newMSC = param.createChild(MessageSecurityConfig.class);\r\n                    newMSC.setAuthLayer(authLayer);\r\n                    param.getMessageSecurityConfig().add(newMSC);\r\n                    ProviderConfig newPC = newMSC.createChild(ProviderConfig.class);\r\n                    populateProviderConfigElement(newPC);\r\n                    newMSC.getProviderConfig().add(newPC);\r\n                    if (isDefaultProvider) {\r\n                        if (providerType.equals(SERVER) || providerType.equals(CLIENT_SERVER))\r\n                            newMSC.setDefaultProvider(providerId);\r\n                        if (providerType.equals(CLIENT) || providerType.equals(CLIENT_SERVER))\r\n                            newMSC.setDefaultClientProvider(providerId);\r\n                    }\r\n                    return newMSC;\r\n                }\r\n            }, secService);\r\n        } catch (TransactionFailure e) {\r\n            report.setMessage(localStrings.getLocalString(\"create.message.security.provider.fail\", \"Creation of message security provider named {0} failed\", providerId));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setFailureCause(e);\r\n            return;\r\n        }\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateMessageSecurityProvider.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ProviderConfig newPC = param.createChild(ProviderConfig.class);\r\n    populateProviderConfigElement(newPC);\r\n    param.getProviderConfig().add(newPC);\r\n    if (isDefaultProvider) {\r\n        if (providerType.equals(SERVER) || providerType.equals(CLIENT_SERVER))\r\n            param.setDefaultProvider(providerId);\r\n        if (providerType.equals(CLIENT) || providerType.equals(CLIENT_SERVER))\r\n            param.setDefaultClientProvider(providerId);\r\n    }\r\n    return newPC;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateMessageSecurityProvider.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    MessageSecurityConfig newMSC = param.createChild(MessageSecurityConfig.class);\r\n    newMSC.setAuthLayer(authLayer);\r\n    param.getMessageSecurityConfig().add(newMSC);\r\n    ProviderConfig newPC = newMSC.createChild(ProviderConfig.class);\r\n    populateProviderConfigElement(newPC);\r\n    newMSC.getProviderConfig().add(newPC);\r\n    if (isDefaultProvider) {\r\n        if (providerType.equals(SERVER) || providerType.equals(CLIENT_SERVER))\r\n            newMSC.setDefaultProvider(providerId);\r\n        if (providerType.equals(CLIENT) || providerType.equals(CLIENT_SERVER))\r\n            newMSC.setDefaultClientProvider(providerId);\r\n    }\r\n    return newMSC;\r\n}"
}, {
	"Path": "ro.pippo.session.hazelcast.HazelcastSessionDataStorageTest.testCreate",
	"Comment": "test of create method, of class hazelcastsessiondatastorage.",
	"Method": "void testCreate(){\r\n    System.out.println(\"create\");\r\n    HazelcastSessionDataStorage instance = new HazelcastSessionDataStorage(Hazelcast.newHazelcastInstance());\r\n    SessionData sessionData = instance.create();\r\n    sessionData.put(KEY, VALUE);\r\n    assertNotNull(sessionData);\r\n    assertNotNull(sessionData.getId());\r\n    assertNotNull(sessionData.getCreationTime());\r\n    assertEquals(sessionData.get(KEY), VALUE);\r\n}"
}, {
	"Path": "com.turo.pushy.apns.ApnsClientBuilder.setApnsServer",
	"Comment": "sets the hostname of the server to which the client under construction will connect. apple provides a productionand development environment.",
	"Method": "ApnsClientBuilder setApnsServer(String hostname,ApnsClientBuilder setApnsServer,String hostname,int port){\r\n    this.apnsServerAddress = InetSocketAddress.createUnresolved(hostname, port);\r\n    return this;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.metrics.dropwizard.DropwizardApnsClientMetricsListener.handleWriteFailure",
	"Comment": "records a failed attempt to send a notification and updates metrics accordingly.",
	"Method": "void handleWriteFailure(ApnsClient apnsClient,long notificationId){\r\n    this.stopTimerForNotification(notificationId);\r\n    this.writeFailures.mark();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.BaseCertificateLoginModule.getAppName",
	"Comment": "get the application name.this may be useful when a single loginmodule has to handle multiple applications that use certificates.",
	"Method": "String getAppName(){\r\n    return appName;\r\n}"
}, {
	"Path": "org.pf4j.AbstractPluginManager.isDevelopment",
	"Comment": "todo add this method in pluginmanager as default method for java 8.",
	"Method": "boolean isDevelopment(){\r\n    return RuntimeMode.DEVELOPMENT.equals(getRuntimeMode());\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.parser.ExpressionParser.parseNewVariableName",
	"Comment": "parses a new variable that will need to be initialized in the java code.this is used for the set tag, the for loop, and in named arguments.",
	"Method": "String parseNewVariableName(){\r\n    this.stream = this.parser.getStream();\r\n    Token token = stream.expect(Token.Type.NAME);\r\n    if (RESERVED_KEYWORDS.contains(token.getValue())) {\r\n        throw new ParserException(null, String.format(\"Can not assign a value to %s\", token.getValue()), token.getLineNumber(), this.stream.getFilename());\r\n    }\r\n    return token.getValue();\r\n}"
}, {
	"Path": "com.mitchellbosecke.pebble.MacroTest.testMacroBeingFiltered",
	"Comment": "i was once writing macro output directly to writer which was preventing output from beingfiltered. i have fixed this now.",
	"Method": "void testMacroBeingFiltered(){\r\n    PebbleEngine pebble = new PebbleEngine.Builder().strictVariables(false).build();\r\n    PebbleTemplate template = pebble.getTemplate(\"templates/template.macro3.peb\");\r\n    Writer writer = new StringWriter();\r\n    template.evaluate(writer);\r\n    assertEquals(\"HELLO\" + LINE_SEPARATOR, writer.toString());\r\n}"
}, {
	"Path": "ro.pippo.core.PippoSettings.getDouble",
	"Comment": "returns the double value for the specified name. if the name does notexist or the value for the name can not be interpreted as a double, thedefaultvalue is returned.",
	"Method": "double getDouble(String name,double defaultValue){\r\n    try {\r\n        String value = getString(name, null);\r\n        if (!StringUtils.isNullOrEmpty(value)) {\r\n            return Double.parseDouble(value.trim());\r\n        }\r\n    } catch (NumberFormatException e) {\r\n        log.warn(\"Failed to parse double for \" + name + USING_DEFAULT_OF + defaultValue);\r\n    }\r\n    return defaultValue;\r\n}"
}, {
	"Path": "net.socialgamer.cah.data.User.getNextQueuedMessage",
	"Comment": "this method blocks if there are no messages to return, or perhaps if the queue is beingmodified by another thread.",
	"Method": "QueuedMessage getNextQueuedMessage(){\r\n    try {\r\n        return queuedMessages.take();\r\n    } catch (final InterruptedException ie) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "ro.pippo.session.ehcache.EhcacheSessionDataStorageTest.testCreate",
	"Comment": "test of create method, of class ehcachesessiondatastorage.",
	"Method": "void testCreate(){\r\n    System.out.println(\"create\");\r\n    EhcacheSessionDataStorage instance = new EhcacheSessionDataStorage(cacheManager);\r\n    SessionData sessionData = instance.create();\r\n    sessionData.put(KEY, VALUE);\r\n    assertNotNull(sessionData);\r\n    assertNotNull(sessionData.getId());\r\n    assertNotNull(sessionData.getCreationTime());\r\n    assertEquals(sessionData.get(KEY), VALUE);\r\n}"
}, {
	"Path": "ro.pippo.core.util.ClasspathUtils.locateOnClasspath",
	"Comment": "tries to find a resource with the given name in the classpath.",
	"Method": "URL locateOnClasspath(String resourceName){\r\n    URL url = null;\r\n    ClassLoader loader = Thread.currentThread().getContextClassLoader();\r\n    if (loader != null) {\r\n        url = loader.getResource(resourceName);\r\n        if (url != null) {\r\n            log.debug(\"Located '{}' in the context classpath\", resourceName);\r\n        }\r\n    }\r\n    if (url == null) {\r\n        url = ClassLoader.getSystemResource(resourceName);\r\n        if (url != null) {\r\n            log.debug(\"Located '{}' in the system classpath\", resourceName);\r\n        }\r\n    }\r\n    return url;\r\n}"
}, {
	"Path": "com.turo.pushy.apns.util.SimpleApnsPushNotification.getPriority",
	"Comment": "returns the priority with which this push notification should be delivered to the receiving device.",
	"Method": "DeliveryPriority getPriority(){\r\n    return this.priority;\r\n}"
}, {
	"Path": "io.nayuki.qrcodegen.QrCodeGeneratorDemo.doMaskDemo",
	"Comment": "creates qr codes with the same size and contents but different mask patterns.",
	"Method": "void doMaskDemo(){\r\n    QrCode qr;\r\n    List<QrSegment> segs;\r\n    segs = QrSegment.makeSegments(\"https://www.nayuki.io/\");\r\n    qr = QrCode.encodeSegments(segs, QrCode.Ecc.HIGH, QrCode.MIN_VERSION, QrCode.MAX_VERSION, -1, true);\r\n    writePng(qr.toImage(8, 6), \"project-nayuki-automask-QR.png\");\r\n    qr = QrCode.encodeSegments(segs, QrCode.Ecc.HIGH, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 3, true);\r\n    writePng(qr.toImage(8, 6), \"project-nayuki-mask3-QR.png\");\r\n    segs = QrSegment.makeSegments(\"維基百科（Wikipedia，聆聽i/ˌwɪkᵻˈpiːdi.ə/）是�?個自由內容�?�公開編輯且多語�?的網路百科全書協作計�?\");\r\n    qr = QrCode.encodeSegments(segs, QrCode.Ecc.MEDIUM, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 0, true);\r\n    writePng(qr.toImage(10, 3), \"unicode-mask0-QR.png\");\r\n    qr = QrCode.encodeSegments(segs, QrCode.Ecc.MEDIUM, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 1, true);\r\n    writePng(qr.toImage(10, 3), \"unicode-mask1-QR.png\");\r\n    qr = QrCode.encodeSegments(segs, QrCode.Ecc.MEDIUM, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 5, true);\r\n    writePng(qr.toImage(10, 3), \"unicode-mask5-QR.png\");\r\n    qr = QrCode.encodeSegments(segs, QrCode.Ecc.MEDIUM, QrCode.MIN_VERSION, QrCode.MAX_VERSION, 7, true);\r\n    writePng(qr.toImage(10, 3), \"unicode-mask7-QR.png\");\r\n}"
}, {
	"Path": "ro.pippo.core.PippoSettings.getFloats",
	"Comment": "returns a list of floats from the specified name using the specified delimiter.",
	"Method": "List<Float> getFloats(String name,List<Float> getFloats,String name,String delimiter){\r\n    List<String> strings = getStrings(name, delimiter);\r\n    List<Float> floats = new ArrayList(strings.size());\r\n    for (String value : strings) {\r\n        try {\r\n            float i = Float.parseFloat(value);\r\n            floats.add(i);\r\n        } catch (NumberFormatException e) {\r\n        }\r\n    }\r\n    return Collections.unmodifiableList(floats);\r\n}"
}]