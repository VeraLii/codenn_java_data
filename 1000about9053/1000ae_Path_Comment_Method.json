[{
	"Path": "org.eclipse.smarthome.binding.hue.internal.Config.isLinkButtonPressed",
	"Comment": "returns if the link button has been pressed within the last 30 seconds.",
	"Method": "boolean isLinkButtonPressed(){\r\n    return linkbutton;\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.living.player.Player.isViewingInventory",
	"Comment": "returns whether this player has an open inventory at the momentor not.",
	"Method": "boolean isViewingInventory(){\r\n    return getOpenInventory().isPresent();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.State.getAlertMode",
	"Comment": "returns the last alert mode set.future firmware updates may change this to actually report the current alert mode.",
	"Method": "AlertMode getAlertMode(){\r\n    return AlertMode.valueOf(alert.toUpperCase());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.internal.i18n.ResourceBundleTracker.returnHostBundles",
	"Comment": "this method is used to get the host bundles of the parameter which is a fragment bundle.",
	"Method": "List<Bundle> returnHostBundles(Bundle fragment){\r\n    List<Bundle> hosts = new ArrayList<Bundle>();\r\n    Bundle[] bundles = pkgAdmin.getHosts(fragment);\r\n    if (bundles != null) {\r\n        for (int i = 0; i < bundles.length; i++) {\r\n            hosts.add(bundles[i]);\r\n        }\r\n    }\r\n    return hosts;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.transform.AbstractFileTransformationService.processFolderEvents",
	"Comment": "ensures that a modified or deleted cached files does not stay in the cache",
	"Method": "void processFolderEvents(WatchService watchService){\r\n    WatchKey key = watchService.poll();\r\n    if (key != null) {\r\n        for (WatchEvent<?> e : key.pollEvents()) {\r\n            if (e.kind() == OVERFLOW) {\r\n                continue;\r\n            }\r\n            @SuppressWarnings(\"unchecked\")\r\n            WatchEvent<Path> ev = (WatchEvent<Path>) e;\r\n            Path path = ev.context();\r\n            logger.debug(\"Refreshing transformation file '{}'\", path);\r\n            for (String fileEntry : cachedFiles.keySet()) {\r\n                if (fileEntry.endsWith(path.toString())) {\r\n                    cachedFiles.remove(fileEntry);\r\n                }\r\n            }\r\n        }\r\n        key.reset();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.common.registry.AbstractRegistry.getValueAndProvider",
	"Comment": "this method retrieves an entry with the provider and the element for the key from the registry.",
	"Method": "Entry<Provider<E>, E> getValueAndProvider(K key){\r\n    elementReadLock.lock();\r\n    try {\r\n        final E element = identifierToElement.get(key);\r\n        if (element == null) {\r\n            return null;\r\n        }\r\n        return new SimpleEntry<Provider<E>, E>(elementToProvider.get(element), element);\r\n    } finally {\r\n        elementReadLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "com.alipay.remoting.ProcessorManagerTest.testRegisterProcessor",
	"Comment": "test it should be override if register twice for the same command code",
	"Method": "void testRegisterProcessor(){\r\n    ProcessorManager processorManager = new ProcessorManager();\r\n    CommandCode cmd1 = RpcCommandCode.RPC_REQUEST;\r\n    CommandCode cmd2 = RpcCommandCode.RPC_REQUEST;\r\n    RpcRequestProcessor rpcRequestProcessor1 = new RpcRequestProcessor();\r\n    RpcRequestProcessor rpcRequestProcessor2 = new RpcRequestProcessor();\r\n    processorManager.registerProcessor(cmd1, rpcRequestProcessor1);\r\n    processorManager.registerProcessor(cmd2, rpcRequestProcessor2);\r\n    Assert.assertEquals(processorManager.getProcessor(cmd1), rpcRequestProcessor2);\r\n    Assert.assertEquals(processorManager.getProcessor(cmd2), rpcRequestProcessor2);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.AutomationCommandsPluggable.buildCommandUsage",
	"Comment": "build a command usage string.you should always use that function to use a usage string that compliesto a standard format.",
	"Method": "String buildCommandUsage(String description,String buildCommandUsage,String syntax,String description){\r\n    return String.format(\"%s %s - %s\", getCommand(), syntax, description);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.binding.ThingHandler.getServices",
	"Comment": "this method provides a list of classes which should be registered as services by the framework",
	"Method": "Collection<Class<? extends ThingHandlerService>> getServices(){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.notification.BluetoothScanNotification.setRssi",
	"Comment": "sets the receive signal strength rssi value for the scanparam rssi the rssi value for the scan packet in dbm",
	"Method": "void setRssi(int rssi){\r\n    this.rssi = rssi;\r\n}"
}, {
	"Path": "org.xerial.snappy.Snappy.rawCompress",
	"Comment": "compress the input data and produce a byte array of the uncompressed data",
	"Method": "long rawCompress(long inputAddr,long inputSize,long destAddr,byte[] rawCompress,Object data,int byteSize,int rawCompress,Object input,int inputOffset,int inputLength,byte[] output,int outputOffset){\r\n    if (input == null || output == null) {\r\n        throw new NullPointerException(\"input or output is null\");\r\n    }\r\n    int compressedSize = impl.rawCompress(input, inputOffset, inputLength, output, outputOffset);\r\n    return compressedSize;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.sample.extension.java.internal.WelcomeHomeRulesProvider.createLightsRule",
	"Comment": "this method creates a rule from scratch by using trigger, condition, action, configdescriptions andconfiguration, tags.",
	"Method": "Rule createLightsRule(){\r\n    String triggerId = \"LightsSwitchOnRuleTrigger\";\r\n    List<Trigger> triggers = new ArrayList<Trigger>();\r\n    triggers.add(ModuleBuilder.createTrigger().withId(triggerId).withTypeUID(LightsTriggerType.UID).build());\r\n    Configuration config = new Configuration();\r\n    config.put(StateConditionType.CONFIG_STATE, \"on\");\r\n    List<Condition> conditions = new ArrayList<Condition>();\r\n    Map<String, String> inputs = new HashMap<String, String>();\r\n    inputs.put(StateConditionType.INPUT_CURRENT_STATE, triggerId + \".\" + StateConditionType.INPUT_CURRENT_STATE);\r\n    conditions.add(ModuleBuilder.createCondition().withId(\"LightsStateCondition\").withTypeUID(StateConditionType.UID).withConfiguration(config).withInputs(inputs).build());\r\n    config = new Configuration();\r\n    config.put(WelcomeHomeActionType.CONFIG_DEVICE, \"Lights\");\r\n    config.put(WelcomeHomeActionType.CONFIG_RESULT, \"Lights are switched on\");\r\n    List<Action> actions = new ArrayList<Action>();\r\n    actions.add(ModuleBuilder.createAction().withId(\"LightsSwitchOnAction\").withTypeUID(WelcomeHomeActionType.UID).withConfiguration(config).build());\r\n    List<ConfigDescriptionParameter> configDescriptions = new ArrayList<ConfigDescriptionParameter>();\r\n    final ConfigDescriptionParameter device = ConfigDescriptionParameterBuilder.create(WelcomeHomeRulesProvider.CONFIG_UNIT, Type.TEXT).withRequired(true).withReadOnly(true).withMultiple(false).withLabel(\"Device\").withDescription(\"Device description\").build();\r\n    final ConfigDescriptionParameter result = ConfigDescriptionParameterBuilder.create(WelcomeHomeRulesProvider.CONFIG_EXPECTED_RESULT, Type.TEXT).withRequired(true).withReadOnly(true).withMultiple(false).withLabel(\"Result\").withDescription(\"Result description\").build();\r\n    configDescriptions.add(device);\r\n    configDescriptions.add(result);\r\n    config = new Configuration();\r\n    config.put(CONFIG_UNIT, \"Lights\");\r\n    config.put(CONFIG_EXPECTED_RESULT, \"The lights are switched on.\");\r\n    Rule lightsSwitchOn = RuleBuilder.create(L_UID).withTriggers(triggers).withConfigurationDescriptions(configDescriptions).withConditions(conditions).withActions(actions).withTags(\"lights\").build();\r\n    return lightsSwitchOn;\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.SlotIndex.lessThan",
	"Comment": "create a slotindex property which matches slotindex properties withvalue less than this value.",
	"Method": "SlotIndex lessThan(Object value){\r\n    return new SlotIndex(value, Operator.LESS);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.convention.homie300.Property.startChannel",
	"Comment": "subscribes to the state topic on the given connection and informs about updates on the given listener.",
	"Method": "CompletableFuture<@Nullable Void> startChannel(MqttBrokerConnection connection,ScheduledExecutorService scheduler,int timeout){\r\n    final ChannelState channelState = this.channelState;\r\n    if (channelState == null) {\r\n        CompletableFuture<@Nullable Void> f = new CompletableFuture();\r\n        f.completeExceptionally(new IllegalStateException(\"Attributes not yet received!\"));\r\n        return f;\r\n    }\r\n    return channelState.start(connection, scheduler, timeout);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.template.RuleTemplate.hashCode",
	"Comment": "returns the hash code of this object depends on the hash code of the uid that it owns.",
	"Method": "int hashCode(){\r\n    final int prime = 31;\r\n    int result = 1;\r\n    result = prime * result + uid.hashCode();\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.ConfigDescription.getParameterGroups",
	"Comment": "returns the list of configuration parameter groups associated with the parameters.the returned list is immutable.",
	"Method": "List<ConfigDescriptionParameterGroup> getParameterGroups(){\r\n    return this.parameterGroups;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.fsinternetradio.test.FSInternetRadioDiscoveryParticipantJavaTest.validDiscoveryResultWithComplete",
	"Comment": "verify valid discoveryresult with completefsinterntradiodevice.",
	"Method": "void validDiscoveryResultWithComplete(){\r\n    RemoteDevice completeFSInternetRadioDevice = createDefaultFSInternetRadioDevice(DEFAULT_RADIO_BASE_URL);\r\n    final DiscoveryResult result = discoveryParticipant.createResult(completeFSInternetRadioDevice);\r\n    assertEquals(new ThingUID(DEFAULT_RADIO_THING_UID), result.getThingUID());\r\n    assertEquals(FSInternetRadioBindingConstants.THING_TYPE_RADIO, result.getThingTypeUID());\r\n    assertEquals(DEFAULT_RADIO_MANIFACTURER, result.getProperties().get(FSInternetRadioBindingConstants.PROPERTY_MANUFACTURER));\r\n    assertEquals(DEFAULT_RADIO_MODEL_NUMBER, result.getProperties().get(FSInternetRadioBindingConstants.PROPERTY_MODEL));\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.Inventory.query",
	"Comment": "query this inventory for inventories matching any of the suppliedqueries. logical or is applied between operands.",
	"Method": "T query(Class<?> types,T query,ItemType types,T query,ItemStack types,T query,InventoryProperty<?, ?> props,T query,Translation names,T query,Object args,T query,QueryOperation<?> operations){\r\n    List<QueryOperation<?>> operations = new ArrayList(args.length);\r\n    for (Object arg : args) {\r\n        if (arg instanceof InventoryProperty) {\r\n            operations.add(QueryOperationTypes.INVENTORY_PROPERTY.of((InventoryProperty<?, ?>) arg));\r\n        } else if (arg instanceof Translation) {\r\n            operations.add(QueryOperationTypes.INVENTORY_TRANSLATION.of((Translation) arg));\r\n        } else if (arg instanceof Class && Inventory.class.isAssignableFrom((Class<?>) arg)) {\r\n            operations.add(QueryOperationTypes.INVENTORY_TYPE.of(((Class<?>) arg).asSubclass(Inventory.class)));\r\n        } else if (arg instanceof ItemStack) {\r\n            operations.add(QueryOperationTypes.ITEM_STACK_IGNORE_QUANTITY.of((ItemStack) arg));\r\n        } else if (arg instanceof ItemType) {\r\n            operations.add(QueryOperationTypes.ITEM_TYPE.of((ItemType) arg));\r\n        }\r\n    }\r\n    return query(operations.toArray(new QueryOperation<?>[operations.size()]));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.BluetoothCharacteristic.getInstanceId",
	"Comment": "returns the instance id for this characteristic.if a remote device offers multiple characteristics with the same uuid, the instance id is used to distinguishbetween characteristics.",
	"Method": "int getInstanceId(){\r\n    return instance;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.fsinternetradio.internal.radio.FrontierSiliconRadioApiResult.getCharacterDataFromElement",
	"Comment": "convert the value of a given xml element to a string for further processing",
	"Method": "String getCharacterDataFromElement(Element e){\r\n    final Node child = e.getFirstChild();\r\n    if (child instanceof CharacterData) {\r\n        final CharacterData cd = (CharacterData) child;\r\n        return cd.getData();\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.common.HomematicConfig.isFactoryResetOnDeletion",
	"Comment": "returns if devices are factory reset when their corresponding things are removed",
	"Method": "boolean isFactoryResetOnDeletion(){\r\n    return factoryResetOnDeletion;\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.timeout.ServerTimeoutSwitchTest.testServerOneway",
	"Comment": "the second request will not timeout in oneway process work queue",
	"Method": "void testServerOneway(){\r\n    for (int i = 0; i <= 1; ++i) {\r\n        new Thread() {\r\n            @Override\r\n            public void run() {\r\n                oneway(client, server.getRpcServer());\r\n            }\r\n        }.start();\r\n    }\r\n    try {\r\n        Thread.sleep(max_timeout * 2);\r\n    } catch (InterruptedException e) {\r\n        logger.error(\"\", e);\r\n    }\r\n    Assert.assertEquals(2, clientUserProcessor.getInvokeTimesEachCallType(RequestBody.InvokeType.ONEWAY));\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.timeout.ServerTimeoutSwitchTest.testServerOneway",
	"Comment": "the second request will not timeout in oneway process work queue",
	"Method": "void testServerOneway(){\r\n    oneway(client, server.getRpcServer());\r\n}"
}, {
	"Path": "org.spongepowered.api.data.property.AbstractProperty.getDefaultOperator",
	"Comment": "return the default operator to use, based on the supplied key and value.",
	"Method": "Operator getDefaultOperator(K key,V value){\r\n    return Operator.defaultOperator();\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.InventoryDimension.lessThanOrEqual",
	"Comment": "create an inventorydimension property which matches inventorydimensionproperties with value less than or equal to this value.",
	"Method": "InventoryDimension lessThanOrEqual(Object value){\r\n    return new InventoryDimension(value, Operator.LEQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.handler.BrokerHandlerTest.initializeHandlerWaitForTimeout",
	"Comment": "utility method for tests that need the handler to be initialized to go on.",
	"Method": "boolean initializeHandlerWaitForTimeout(){\r\n    MqttBrokerConnection c = connection;\r\n    MqttConnectionObserverEx o = new MqttConnectionObserverEx();\r\n    c.addConnectionObserver(o);\r\n    assertThat(connection.connectionState(), is(MqttConnectionState.DISCONNECTED));\r\n    handler.initialize();\r\n    verify(connection, times(2)).addConnectionObserver(any());\r\n    verify(connection, times(1)).start();\r\n    boolean s = o.semaphore.tryAcquire(300, TimeUnit.MILLISECONDS);\r\n    assertThat(o.counter, is(2));\r\n    verify(handler, times(3)).connectionStateChanged(any(), any());\r\n    return s;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.core.internal.thing.ThingResource.remove",
	"Comment": "delete a thing, if possible. thing deletion might be impossible if thething is not managed, will return conflict. thing deletion might happendelayed, will return accepted.",
	"Method": "Response remove(String language,String thingUID,boolean force){\r\n    final Locale locale = localeService.getLocale(language);\r\n    ThingUID thingUIDObject = new ThingUID(thingUID);\r\n    Thing thing = thingRegistry.get(thingUIDObject);\r\n    if (thing == null) {\r\n        logger.info(\"Received HTTP DELETE request for update at '{}' for the unknown thing '{}'.\", uriInfo.getPath(), thingUID);\r\n        return getThingNotFoundResponse(thingUID);\r\n    }\r\n    Thing managed = managedThingProvider.get(thingUIDObject);\r\n    if (null == managed) {\r\n        logger.info(\"Received HTTP DELETE request for update at '{}' for an unmanaged thing '{}'.\", uriInfo.getPath(), thingUID);\r\n        return getThingResponse(Status.CONFLICT, thing, locale, \"Cannot delete Thing \" + thingUID + \" as it is not editable.\");\r\n    }\r\n    if (force) {\r\n        if (null == thingRegistry.forceRemove(thingUIDObject)) {\r\n            return getThingResponse(Status.INTERNAL_SERVER_ERROR, thing, locale, \"Cannot delete Thing \" + thingUID + \" for unknown reasons.\");\r\n        }\r\n    } else {\r\n        if (null != thingRegistry.remove(thingUIDObject)) {\r\n            return getThingResponse(Status.ACCEPTED, thing, locale, null);\r\n        }\r\n    }\r\n    return Response.ok(null, MediaType.TEXT_PLAIN).build();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.openweathermap.internal.utils.ByteArrayFileCache.get",
	"Comment": "returns the content of the file associated with the given key, if it is present.",
	"Method": "byte[] get(String key){\r\n    return readFile(getUniqueFile(key));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.type.AbstractDescriptionType.getUID",
	"Comment": "returns the unique identifier which identifies the according type within the overall system.",
	"Method": "UID getUID(){\r\n    return this.uid;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.internal.validation.ConfigDescriptionValidatorImpl.validate",
	"Comment": "validates the given configuration parameters against the given configuration description having the given uri.",
	"Method": "void validate(Map<String, Object> configurationParameters,URI configDescriptionURI){\r\n    Objects.requireNonNull(configurationParameters, \"Configuration parameters must not be null\");\r\n    Objects.requireNonNull(configDescriptionURI, \"Config description URI must not be null\");\r\n    ConfigDescription configDescription = getConfigDescription(configDescriptionURI);\r\n    if (configDescription == null) {\r\n        logger.warn(\"Skipping config description validation because no config description found for URI '{}'\", configDescriptionURI);\r\n        return;\r\n    }\r\n    Map<String, ConfigDescriptionParameter> map = configDescription.toParametersMap();\r\n    Collection<ConfigValidationMessage> configDescriptionValidationMessages = new ArrayList();\r\n    for (String key : configurationParameters.keySet()) {\r\n        ConfigDescriptionParameter configDescriptionParameter = map.get(key);\r\n        if (configDescriptionParameter != null) {\r\n            if (configDescriptionParameter.isMultiple() && configurationParameters.get(key) instanceof List) {\r\n                for (Object value : (List<Object>) configurationParameters.get(key)) {\r\n                    ConfigValidationMessage message = validateParameter(configDescriptionParameter, value);\r\n                    if (message != null) {\r\n                        configDescriptionValidationMessages.add(message);\r\n                    }\r\n                }\r\n            } else {\r\n                ConfigValidationMessage message = validateParameter(configDescriptionParameter, configurationParameters.get(key));\r\n                if (message != null) {\r\n                    configDescriptionValidationMessages.add(message);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (!configDescriptionValidationMessages.isEmpty()) {\r\n        throw new ConfigValidationException(bundleContext.getBundle(), translationProvider, configDescriptionValidationMessages);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.discovery.dto.DiscoveryResultDTOMapper.map",
	"Comment": "maps discovery result data transfer object into discovery result.",
	"Method": "DiscoveryResultDTO map(DiscoveryResult discoveryResult,DiscoveryResult map,DiscoveryResultDTO discoveryResultDTO){\r\n    final ThingUID thingUID = new ThingUID(discoveryResultDTO.thingUID);\r\n    final String dtoThingTypeUID = discoveryResultDTO.thingTypeUID;\r\n    final ThingTypeUID thingTypeUID = dtoThingTypeUID != null ? new ThingTypeUID(dtoThingTypeUID) : null;\r\n    final String dtoBridgeUID = discoveryResultDTO.bridgeUID;\r\n    final ThingUID bridgeUID = dtoBridgeUID != null ? new ThingUID(dtoBridgeUID) : null;\r\n    return DiscoveryResultBuilder.create(thingUID).withThingType(thingTypeUID).withBridge(bridgeUID).withLabel(discoveryResultDTO.label).withRepresentationProperty(discoveryResultDTO.representationProperty).withProperties(discoveryResultDTO.properties).build();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.discovery.HueBridgeNupnpDiscovery.isReachableAndValidHueBridge",
	"Comment": "checks if the bridge is a reachable hue bridge with a valid id.",
	"Method": "boolean isReachableAndValidHueBridge(BridgeJsonParameters bridge){\r\n    String host = bridge.getInternalIpAddress();\r\n    String id = bridge.getId();\r\n    String description;\r\n    if (host == null) {\r\n        logger.debug(\"Bridge not discovered: ip is null\");\r\n        return false;\r\n    }\r\n    if (id == null) {\r\n        logger.debug(\"Bridge not discovered: id is null\");\r\n        return false;\r\n    }\r\n    if (id.length() < 10) {\r\n        logger.debug(\"Bridge not discovered: id {} is shorter then 10.\", id);\r\n        return false;\r\n    }\r\n    if (!id.substring(6, 10).equals(BRIDGE_INDICATOR)) {\r\n        logger.debug(\"Bridge not discovered: id {} does not contain bridge indicator {} or its at the wrong position.\", id, BRIDGE_INDICATOR);\r\n        return false;\r\n    }\r\n    try {\r\n        description = doGetRequest(DESC_URL_PATTERN.replace(\"HOST\", host));\r\n    } catch (IOException e) {\r\n        logger.debug(\"Bridge not discovered: Failure accessing description file for ip: {}\", host);\r\n        return false;\r\n    }\r\n    if (!description.contains(MODEL_NAME_PHILIPS_HUE)) {\r\n        logger.debug(\"Bridge not discovered: Description does not containing the model name: {}\", description);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.config.Config.setBinCheckTime",
	"Comment": "returns the milliseconds after the trash devices will be checked, if its time to delete.",
	"Method": "void setBinCheckTime(int binCheckTime){\r\n    this.binCheckTime = binCheckTime;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.virtual.InstallModeVirtualDatapoint.getDuration",
	"Comment": "returns the virtual datapoint value for install mode duration.",
	"Method": "Integer getDuration(HmChannel channel){\r\n    HmDatapoint dpDuration = channel.getDatapoint(HmDatapointInfo.createValuesInfo(channel, VIRTUAL_DATAPOINT_NAME_INSTALL_MODE_DURATION));\r\n    return dpDuration == null || dpDuration.getValue() == null || dpDuration.getType() != HmValueType.INTEGER ? 60 : ((Number) dpDuration.getValue()).intValue();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.handler.HomematicThingHandler.loadHomematicChannelValues",
	"Comment": "loads all values for the given homematic channel if it is not initialized.",
	"Method": "void loadHomematicChannelValues(HmChannel hmChannel){\r\n    if (!hmChannel.isInitialized()) {\r\n        synchronized (this) {\r\n            if (!hmChannel.isInitialized()) {\r\n                try {\r\n                    getHomematicGateway().loadChannelValues(hmChannel);\r\n                } catch (IOException ex) {\r\n                    if (hmChannel.getDevice().isOffline()) {\r\n                        logger.warn(\"Device '{}' is OFFLINE, can't update channel '{}'\", hmChannel.getDevice().getAddress(), hmChannel.getNumber());\r\n                    } else {\r\n                        throw ex;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.generic.ChannelState.addTransformation",
	"Comment": "add a transformation that is applied for each received mqtt topic value.the transformations are executed in order.",
	"Method": "void addTransformation(ChannelStateTransformation transformation){\r\n    transformations.add(transformation);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.ui.classic.internal.servlet.WebAppServlet.getAllItems",
	"Comment": "collects all items that are represented by a given list of widgets",
	"Method": "Set<GenericItem> getAllItems(EList<Widget> widgets){\r\n    Set<GenericItem> items = new HashSet<GenericItem>();\r\n    if (renderer.getItemUIRegistry() != null) {\r\n        for (Widget widget : widgets) {\r\n            boolean skipWidget = false;\r\n            if (widget instanceof Chart) {\r\n                Chart chartWidget = (Chart) widget;\r\n                skipWidget = chartWidget.getRefresh() > 0;\r\n            }\r\n            if (!skipWidget) {\r\n                addItemWithName(items, widget.getItem());\r\n            }\r\n            if (widget instanceof Frame) {\r\n                items.addAll(getAllItems(((Frame) widget).getChildren()));\r\n            }\r\n            for (VisibilityRule vr : widget.getVisibility()) {\r\n                addItemWithName(items, vr.getItem());\r\n            }\r\n        }\r\n    }\r\n    return items;\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.Transform.addRotation",
	"Comment": "adds a rotation to this transform. returns the results as a new copy.",
	"Method": "Transform<E> addRotation(Vector3d rotation,Transform<E> addRotation,Quaterniond rotation){\r\n    checkNotNull(rotation, \"rotation\");\r\n    return new Transform(getExtent(), getPosition(), toAxesAngles(rotation.mul(getRotationAsQuaternion())), getScale());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.dmx.internal.Util.fadeTimeFraction",
	"Comment": "calculate a fraction of the fadetime depending on current and target value",
	"Method": "int fadeTimeFraction(int currentValue,int targetValue,int fadeTime){\r\n    return Math.abs(targetValue - currentValue) * fadeTime / (DmxChannel.MAX_VALUE - DmxChannel.MIN_VALUE);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.onewire.internal.owserver.OwserverConnection.closeOnError",
	"Comment": "close the connection to the owserver instance after an error occured",
	"Method": "void closeOnError(){\r\n    connectionErrorCounter++;\r\n    close();\r\n    if (connectionErrorCounter > CONNECTION_MAX_RETRY) {\r\n        owserverConnectionState = OwserverConnectionState.FAILED;\r\n        thingHandlerCallback.reportConnectionState(owserverConnectionState);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.tradfri.handler.TradfriGatewayHandler.registerDeviceUpdateListener",
	"Comment": "registers a listener, which is informed about device details.",
	"Method": "void registerDeviceUpdateListener(DeviceUpdateListener listener){\r\n    this.deviceUpdateListeners.add(listener);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.tools.ChildMap.apply",
	"Comment": "modifies the map in way that it matches the entries of the given childids.",
	"Method": "CompletableFuture<@Nullable Void> apply(String[] childIDs,Function<TYPE, CompletableFuture<Void>> addedAction,Function<String, TYPE> supplyNewChild,Consumer<TYPE> removedCallback){\r\n    Set<String> arrayValues = Stream.of(childIDs).collect(Collectors.toSet());\r\n    final Map<String, TYPE> newSubnodes = arrayValues.stream().filter(entry -> !this.map.containsKey(entry)).collect(Collectors.toMap(k -> k, k -> supplyNewChild.apply(k)));\r\n    this.map.putAll(newSubnodes);\r\n    this.map.entrySet().removeIf(entry -> {\r\n        if (!arrayValues.contains(entry.getKey())) {\r\n            removedCallback.accept(entry.getValue());\r\n            return true;\r\n        }\r\n        return false;\r\n    });\r\n    return CompletableFuture.allOf(newSubnodes.values().stream().map(v -> addedAction.apply(v)).toArray(CompletableFuture[]::new));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.internal.calc.MoonCalc.toLMST",
	"Comment": "convert greenwich mean sidereal time to local mean sidereal time.",
	"Method": "double toLMST(double gmst,double lon){\r\n    return mod(gmst + SunCalc.RAD2DEG * lon / 15., 24.);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.console.karaf.internal.ConsoleSupportKaraf.unregisterCommands",
	"Comment": "unregister all commands.the session factory must be not null.",
	"Method": "void unregisterCommands(){\r\n    for (final ConsoleCommandExtension command : commands) {\r\n        registerCommand(command);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.handler.HomematicThingHandler.deviceRemoved",
	"Comment": "called by the bridgehandler when this device has been removed from the gateway.",
	"Method": "void deviceRemoved(){\r\n    deviceDeletionPending = false;\r\n    if (getThing().getStatus() == ThingStatus.REMOVING) {\r\n        updateStatus(ThingStatus.REMOVED);\r\n    } else {\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.climate.jsonresponsecontainer.impl.AssignedSensors.existsAssignedSensors",
	"Comment": "returns true, if sensors exists at the zone, otherwise false.",
	"Method": "boolean existsAssignedSensors(){\r\n    return sensors != null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.Group.isModifiable",
	"Comment": "returns if the group can be modified.currently only returns false for the all lights pseudo group.",
	"Method": "boolean isModifiable(){\r\n    return !id.equals(\"0\");\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.sonos.internal.handler.ZonePlayerHandler.shouldIgnoreVariableUpdate",
	"Comment": "currenturi will not change, but will trigger change of currenturiformatedcurrenttrackmetadata will not change, but will trigger change of title, artist, album",
	"Method": "boolean shouldIgnoreVariableUpdate(String variable,String value,String oldValue){\r\n    return !hasValueChanged(value, oldValue) && !isQueueEvent(variable);\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.MappedIntProperty.greaterThan",
	"Comment": "create a mappedintproperty property which matches mappedintpropertyproperties with value greater than this value and matching key.",
	"Method": "MappedIntProperty greaterThan(Object key,Object value){\r\n    return new MappedIntProperty(key, value, Operator.GREATER);\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.MappedIntProperty.lessThan",
	"Comment": "create a mappedintproperty property which matches mappedintpropertyproperties with value less than this value and matching key.",
	"Method": "MappedIntProperty lessThan(Object key,Object value){\r\n    return new MappedIntProperty(key, value, Operator.LESS);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.ConfigDescriptionParameter.getLimitToOptions",
	"Comment": "returns true is the value for this parameter must be limited to thevalues in the options list.",
	"Method": "boolean getLimitToOptions(){\r\n    return this.limitToOptions;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.script.actions.BusEvent.storeStates",
	"Comment": "stores the current states for a list of items in a map.a group item is not itself put into the map, but instead all its members.",
	"Method": "Map<Item, State> storeStates(Item items){\r\n    Map<Item, State> statesMap = new HashMap();\r\n    if (items != null) {\r\n        for (Item item : items) {\r\n            if (item instanceof GroupItem) {\r\n                GroupItem groupItem = (GroupItem) item;\r\n                for (Item member : groupItem.getAllMembers()) {\r\n                    statesMap.put(member, member.getState());\r\n                }\r\n            } else {\r\n                statesMap.put(item, item.getState());\r\n            }\r\n        }\r\n    }\r\n    return statesMap;\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.GenericArguments.withSuggestions",
	"Comment": "uses a custom set of suggestions for an argument. the providedsuggestions will replace the regular ones.",
	"Method": "CommandElement withSuggestions(CommandElement argument,Iterable<String> suggestions,CommandElement withSuggestions,CommandElement argument,Iterable<String> suggestions,boolean requireBegin,CommandElement withSuggestions,CommandElement argument,Function<CommandSource, Iterable<String>> suggestions,CommandElement withSuggestions,CommandElement argument,Function<CommandSource, Iterable<String>> suggestions,boolean requireBegin){\r\n    return new WithSuggestionsElement(argument, suggestions, requireBegin);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.ConfigUtil.normalizeTypes",
	"Comment": "normalizes the types to the ones allowed for configurations.",
	"Method": "Map<String, Object> normalizeTypes(Map<String, Object> configuration,Map<String, Object> normalizeTypes,Map<String, Object> configuration,List<ConfigDescription> configDescriptions){\r\n    if (configDescriptions == null || configDescriptions.isEmpty()) {\r\n        throw new IllegalArgumentException(\"Config description must not be null.\");\r\n    }\r\n    if (configuration == null) {\r\n        return null;\r\n    }\r\n    Map<String, Object> convertedConfiguration = new HashMap();\r\n    Map<String, ConfigDescriptionParameter> configParams = new HashMap();\r\n    for (int i = configDescriptions.size() - 1; i >= 0; i--) {\r\n        configParams.putAll(configDescriptions.get(i).toParametersMap());\r\n    }\r\n    for (Entry<String, ?> parameter : configuration.entrySet()) {\r\n        String name = parameter.getKey();\r\n        Object value = parameter.getValue();\r\n        if (!isOSGiConfigParameter(name)) {\r\n            ConfigDescriptionParameter configDescriptionParameter = configParams.get(name);\r\n            convertedConfiguration.put(name, normalizeType(value, configDescriptionParameter));\r\n        }\r\n    }\r\n    return convertedConfiguration;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.convention.homeassistant.AbstractComponent.groupTypeUID",
	"Comment": "each homeassistant component corresponds to an esh channel group type.",
	"Method": "ChannelGroupTypeUID groupTypeUID(){\r\n    return channelGroupTypeUID;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.handler.AbstractBrokerHandler.initialize",
	"Comment": "registers a connection status listener and attempts a connection if there is none so far.",
	"Method": "void initialize(){\r\n    for (Channel channel : thing.getChannels()) {\r\n        final PublishTriggerChannelConfig channelConfig = channel.getConfiguration().as(PublishTriggerChannelConfig.class);\r\n        PublishTriggerChannel c = new PublishTriggerChannel(channelConfig, channel.getUID(), connection, this);\r\n        channelStateByChannelUID.put(channel.getUID(), c);\r\n    }\r\n    connection.addConnectionObserver(this);\r\n    connection.start().exceptionally(e -> {\r\n        connectionStateChanged(MqttConnectionState.DISCONNECTED, e);\r\n        return false;\r\n    }).thenAccept(v -> {\r\n        if (!v) {\r\n            connectionStateChanged(MqttConnectionState.DISCONNECTED, new TimeoutException(\"Timeout\"));\r\n        } else {\r\n            connectionStateChanged(MqttConnectionState.CONNECTED, null);\r\n        }\r\n    });\r\n    connectionFuture.complete(connection);\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.SlotIndex.of",
	"Comment": "create a slotindex property which matches slotindex properties withequal value.",
	"Method": "SlotIndex of(Object value){\r\n    return new SlotIndex(value, Operator.EQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.UidUtils.createHmDatapointInfo",
	"Comment": "generates the hmdatapointinfo for the given thing and channeluid.",
	"Method": "HmDatapointInfo createHmDatapointInfo(ChannelUID channelUID){\r\n    return new HmDatapointInfo(channelUID.getThingUID().getId(), HmParamsetType.VALUES, NumberUtils.toInt(channelUID.getGroupId()), channelUID.getIdWithoutGroup());\r\n}"
}, {
	"Path": "org.spongepowered.api.command.CommandResult.queryResult",
	"Comment": "returns a result indicating the command was processed with anamount of queries.",
	"Method": "CommandResult queryResult(int count,Builder queryResult,Integer queryResult){\r\n    return builder().queryResult(count).build();\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.EquipmentSlotType.of",
	"Comment": "create an equipmentslottype property which matches equipmentslottypeproperties with equal value.",
	"Method": "EquipmentSlotType of(Object value){\r\n    return new EquipmentSlotType(value, Operator.EQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.BridgeConfigUpdate.setName",
	"Comment": "set the name of the bridge, which also functions as the upnp name.",
	"Method": "BridgeConfigUpdate setName(String name){\r\n    if (Util.stringSize(name) < 4 || Util.stringSize(name) > 16) {\r\n        throw new IllegalArgumentException(\"Bridge name must be between 4 and 16 characters long\");\r\n    }\r\n    commands.add(new Command(\"name\", name));\r\n    return this;\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.SlotPos.greaterThanOrEqual",
	"Comment": "create an slotpos property which matches slotpos properties with valuegreater than or equal to this value.",
	"Method": "SlotPos greaterThanOrEqual(Object value){\r\n    return new SlotPos(value, Operator.GEQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.MqttBrokerConnection.removeConnectionObserver",
	"Comment": "remove a previously registered connection observer from this connection.",
	"Method": "void removeConnectionObserver(MqttConnectionObserver connectionObserver){\r\n    connectionObservers.remove(connectionObserver);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.client.RpcClient.hasInterface",
	"Comment": "returns true, if a connection is possible with the given interface.",
	"Method": "boolean hasInterface(HmInterface hmInterface,String id){\r\n    try {\r\n        checkInterface(hmInterface);\r\n        return true;\r\n    } catch (IOException ex) {\r\n        logger.info(\"Interface '{}' on gateway '{}' not available, disabling support\", hmInterface, id);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "ws.com.google.android.mms.pdu.CharacterSets.getMimeName",
	"Comment": "map an mibenum number to the name of the charset which this numberis assigned to by iana.",
	"Method": "String getMimeName(int mibEnumValue){\r\n    String name = MIBENUM_TO_NAME_MAP.get(mibEnumValue);\r\n    if (name == null) {\r\n        throw new UnsupportedEncodingException();\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.ArmorSlotType.of",
	"Comment": "create an armourslottype property which matches armourslottype propertieswith equal value.",
	"Method": "ArmorSlotType of(Object value){\r\n    return new ArmorSlotType(value, Operator.EQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.parser.CommonRpcParser.getSanitizedAddress",
	"Comment": "returns the address of a device, replacing group address identifier and illegal characters.",
	"Method": "String getSanitizedAddress(Object object){\r\n    String address = StringUtils.trimToNull(StringUtils.replaceOnce(toString(object), \"*\", \"T-\"));\r\n    return MiscUtils.validateCharacters(address, \"Address\", \"_\");\r\n}"
}, {
	"Path": "org.xerial.snappy.SnappyFramedOutputStream.flushBuffer",
	"Comment": "compresses and writes out any buffered data. this does nothing if thereis no currently buffered data.",
	"Method": "void flushBuffer(){\r\n    if (buffer.position() > 0) {\r\n        buffer.flip();\r\n        writeCompressed(buffer);\r\n        buffer.clear();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.xml.util.ConverterAssertion.assertEndOfType",
	"Comment": "asserts that the specified reader does not contain further elements in its section.",
	"Method": "void assertEndOfType(HierarchicalStreamReader reader){\r\n    if (reader.hasMoreChildren()) {\r\n        throw new ConversionException(\"The document is invalid, it contains unsupported data!\");\r\n    }\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.protocol.AbstractUserProcessor.processInIOThread",
	"Comment": "by default, return false, means not deserialize and process biz logic in io thread",
	"Method": "boolean processInIOThread(){\r\n    return false;\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.SlotSide.not",
	"Comment": "create a slotside property which matches slotside properties with unequalvalue.",
	"Method": "SlotSide not(Object value){\r\n    return new SlotSide(value, Operator.NOTEQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.ConfigDescriptionParameterBuilder.withMultipleLimit",
	"Comment": "set the configuration parameter to allow multiple selection",
	"Method": "ConfigDescriptionParameterBuilder withMultipleLimit(Integer multipleLimit){\r\n    this.multipleLimit = multipleLimit;\r\n    return this;\r\n}"
}, {
	"Path": "com.alipay.remoting.config.switches.ProtocolSwitch.isOn",
	"Comment": "check switch status whether on according to specified value",
	"Method": "boolean isOn(int index,boolean isOn,int switchIndex,int value){\r\n    return toBitSet(value).get(switchIndex);\r\n}"
}, {
	"Path": "com.alipay.remoting.ProtocolCode.getFirstByte",
	"Comment": "get the first single byte if your protocol code is single code.",
	"Method": "byte getFirstByte(){\r\n    return this.version[0];\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.protocol.RpcRequestProcessor.timeoutLog",
	"Comment": "print some log when request timeout and discarded in io thread.",
	"Method": "void timeoutLog(RpcRequestCommand cmd,long currentTimestamp,RemotingContext ctx){\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}].\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout());\r\n    }\r\n    String remoteAddr = \"UNKNOWN\";\r\n    if (null != ctx) {\r\n        ChannelHandlerContext channelCtx = ctx.getChannelContext();\r\n        Channel channel = channelCtx.channel();\r\n        if (null != channel) {\r\n            remoteAddr = RemotingUtil.parseRemoteAddress(channel);\r\n        }\r\n    }\r\n    logger.warn(\"Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}].\", cmd.getId(), remoteAddr, (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout());\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.GenericArguments.seq",
	"Comment": "consumes a series of arguments. usage is the elements concatenated",
	"Method": "CommandElement seq(CommandElement elements){\r\n    return new SequenceCommandElement(ImmutableList.copyOf(elements));\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.parsing.InputTokenizer.rawInput",
	"Comment": "returns an input tokenizer that returns the input string as a singleargument.",
	"Method": "InputTokenizer rawInput(){\r\n    return RawStringInputTokenizer.INSTANCE;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.voice.text.AbstractRuleBasedInterpreter.tokenize",
	"Comment": "tokenizes text. filters out all unsupported punctuation. tokens will be lower case.",
	"Method": "ArrayList<String> tokenize(Locale locale,String text){\r\n    ArrayList<String> parts = new ArrayList<String>();\r\n    if (text == null) {\r\n        return parts;\r\n    }\r\n    String[] split;\r\n    if ((locale != null) && locale.getLanguage().equalsIgnoreCase(Locale.FRENCH.getLanguage())) {\r\n        split = text.toLowerCase(locale).replaceAll(\"[\\\\']\", \" \").replaceAll(\"[^\\\\w\\\\sàâäçéèêëîïôùûü]\", \" \").split(\"\\\\s\");\r\n    } else {\r\n        split = text.toLowerCase(locale).replaceAll(\"[\\\\']\", \"\").replaceAll(\"[^\\\\w\\\\s]\", \" \").split(\"\\\\s\");\r\n    }\r\n    for (int i = 0; i < split.length; i++) {\r\n        String part = split[i].trim();\r\n        if (part.length() > 0) {\r\n            parts.add(part);\r\n        }\r\n    }\r\n    return parts;\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.ArgumentParseException.getAnnotatedPosition",
	"Comment": "return a string pointing to the position of the arguments when thisexception occurs.",
	"Method": "String getAnnotatedPosition(){\r\n    String source = this.source;\r\n    int position = this.position;\r\n    if (source.length() > 80) {\r\n        if (position >= 37) {\r\n            int startPos = position - 37;\r\n            int endPos = Math.min(source.length(), position + 37);\r\n            if (endPos < source.length()) {\r\n                source = \"...\" + source.substring(startPos, endPos) + \"...\";\r\n            } else {\r\n                source = \"...\" + source.substring(startPos, endPos);\r\n            }\r\n            position -= 40;\r\n        } else {\r\n            source = source.substring(0, 77) + \"...\";\r\n        }\r\n    }\r\n    return source + \"\\n\" + Strings.repeat(\" \", position) + \"^\";\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.config.Config.getApplicationName",
	"Comment": "returns the application name to generate the application token.",
	"Method": "String getApplicationName(){\r\n    return applicationName;\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.ArmorEquipable.setHelmet",
	"Comment": "sets the helmet currently being worn by this entity.having the helmet as null will result in having nothing equipped inthe helmet slot.",
	"Method": "void setHelmet(ItemStack helmet){\r\n    this.equip(EquipmentTypes.HEADWEAR, helmet);\r\n}"
}, {
	"Path": "org.spongepowered.api.service.economy.Currency.format",
	"Comment": "formats the given amount using the specified number of fractional digits.should include the symbol if it is present",
	"Method": "Text format(BigDecimal amount,Text format,BigDecimal amount,int numFractionDigits){\r\n    return this.format(amount, this.getDefaultFractionDigits());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.misc.MiscUtils.validateCharacters",
	"Comment": "replaces invalid characters of the text to fit into a openhab uid.",
	"Method": "String validateCharacters(String text,String textType,String replaceChar){\r\n    if (text == null) {\r\n        return \"EMPTY\";\r\n    }\r\n    String cleanedText = text.replaceAll(\"[^A-Za-z0-9_-]\", replaceChar);\r\n    if (!text.equals(cleanedText)) {\r\n        logger.info(\"{} '{}' contains invalid characters, new {} '{}'\", textType, text, textType, cleanedText);\r\n    }\r\n    return cleanedText;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.transform.actions.Transformation.transformRaw",
	"Comment": "applies a transformation of a given type with some function to a value.",
	"Method": "String transformRaw(String type,String function,String value){\r\n    return trans(type, function, value);\r\n}"
}, {
	"Path": "org.spongepowered.api.command.spec.CommandSpec.getHelp",
	"Comment": "return a longer description for this command. this description iscomposed of at least all present of the short description, the usagestatement, and the extended description",
	"Method": "Optional<Text> getHelp(CommandSource source){\r\n    checkNotNull(source, \"source\");\r\n    Text.Builder builder = Text.builder();\r\n    this.getShortDescription(source).ifPresent((a) -> builder.append(a, Text.NEW_LINE));\r\n    builder.append(getUsage(source));\r\n    this.getExtendedDescription(source).ifPresent((a) -> builder.append(Text.NEW_LINE, a));\r\n    return Optional.of(builder.build());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.auth.oauth2client.internal.OAuthFactoryImpl.setOAuthStoreHandler",
	"Comment": "the store handler is mandatory, but the actual storage service is not.oauthstorehandler will handle when storage service is missing.intended static mandatory 1..1 reference",
	"Method": "void setOAuthStoreHandler(OAuthStoreHandler oAuthStoreHandler){\r\n    this.oAuthStoreHandler = oAuthStoreHandler;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.cache.ExpiringCacheMap.invalidate",
	"Comment": "invalidates the value associated with the given key in the cache.",
	"Method": "void invalidate(K key){\r\n    final ExpiringCache<@Nullable V> item = items.get(key);\r\n    if (item == null) {\r\n        logger.debug(\"No item for key '{}' found\", key);\r\n    } else {\r\n        item.invalidateValue();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.internal.MqttBrokerConnectionServiceInstance.modified",
	"Comment": "create broker connections based on the service configuration. this will disconnect anddiscard all existing textual configured brokers.",
	"Method": "void modified(Map<String, Object> configMap){\r\n    if (connection != null) {\r\n        connection.stop();\r\n    }\r\n    if (configMap == null || configMap.isEmpty() || mqttService == null) {\r\n        return;\r\n    }\r\n    @NonNull\r\n    final MqttServiceImpl service = (@NonNull MqttServiceImpl) mqttService;\r\n    MqttBrokerConnectionConfig config = new Configuration(configMap).as(MqttBrokerConnectionConfig.class);\r\n    try {\r\n        String brokerID = config.getBrokerID();\r\n        if (StringUtils.isBlank(brokerID) || brokerID == null) {\r\n            logger.warn(\"Ignore invalid broker connection configuration: {}\", config);\r\n            return;\r\n        }\r\n        MqttBrokerConnection c = service.addBrokerConnection(brokerID, config);\r\n        connection = c;\r\n        if (c == null) {\r\n            logger.warn(\"Ignore existing broker connection configuration for: {}\", brokerID);\r\n            return;\r\n        }\r\n        c.start();\r\n    } catch (ConfigurationException | IllegalArgumentException e) {\r\n        logger.warn(\"MqttBroker connection configuration faulty: {}\", e.getMessage());\r\n    } catch (MqttException e) {\r\n        logger.warn(\"MqttBroker start failed: {}\", e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.internal.validation.ConfigDescriptionParameterValidatorFactory.createPatternValidator",
	"Comment": "returns a new validator for the pattern attribute of a config description parameter.",
	"Method": "ConfigDescriptionParameterValidator createPatternValidator(){\r\n    return new PatternValidator();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.dmx.internal.multiverse.DmxChannel.getNewHiResValue",
	"Comment": "get the new value for this channel as determined by active actions or thecurrent value.",
	"Method": "Integer getNewHiResValue(long calculationTime){\r\n    if (hasRunningActions()) {\r\n        logger.trace(\"checking actions, list is {}\", actions);\r\n        BaseAction action = actions.get(0);\r\n        value = action.getNewValue(this, calculationTime);\r\n        if (action.getState() == ActionState.COMPLETED && hasRunningActions()) {\r\n            switchToNextAction();\r\n        } else if (action.getState() == ActionState.COMPLETEDFINAL) {\r\n            clearAction();\r\n        }\r\n    }\r\n    if ((lastStateValue != value) && (calculationTime - lastStateTimestamp > refreshTime)) {\r\n        for (Entry<ChannelUID, DmxThingHandler> listener : valueListeners.entrySet()) {\r\n            int dmxValue = Util.toDmxValue(value >> 8);\r\n            (listener.getValue()).updateChannelValue(listener.getKey(), dmxValue);\r\n            logger.trace(\"sending VALUE={} (raw={}) status update to listener {} ({})\", dmxValue, value, listener.getValue(), listener.getKey());\r\n        }\r\n        if ((lastStateValue == 0) || (value == 0)) {\r\n            OnOffType state = (value == 0) ? OnOffType.OFF : OnOffType.ON;\r\n            for (Entry<ChannelUID, DmxThingHandler> listener : onOffListeners.entrySet()) {\r\n                (listener.getValue()).updateSwitchState(listener.getKey(), state);\r\n                logger.trace(\"sending ONOFF={} (raw={}), status update to listener {}\", state, value, listener.getKey());\r\n            }\r\n        }\r\n        lastStateValue = value;\r\n        lastStateTimestamp = calculationTime;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.internal.command.system.BlueGigaWhitelistRemoveCommand.setAddress",
	"Comment": "bluetooth device address to remove from the running white list.",
	"Method": "void setAddress(String address){\r\n    this.address = address;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.internal.MqttThingID.getThingUID",
	"Comment": "creates a normal broker thing with an url that will be converted to a thing id.",
	"Method": "ThingUID getThingUID(String host,int port){\r\n    return new ThingUID(MqttBindingConstants.BRIDGE_TYPE_BROKER, getThingID(host, port));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.net.NetUtil.isUseIPv6",
	"Comment": "use ipv6. if not set, ipv6 addresses should be completely ignored by listeners.",
	"Method": "boolean isUseIPv6(){\r\n    return useIPv6;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.module.script.defaultscope.internal.ScriptBusEvent.sendCommand",
	"Comment": "sends a number as a command for a specified item to the event bus.",
	"Method": "Object sendCommand(Item item,String commandString,Object sendCommand,Item item,Number number,Object sendCommand,String itemName,String commandString,Object sendCommand,Item item,Command command){\r\n    if (eventPublisher != null && item != null) {\r\n        eventPublisher.post(ItemEventFactory.createCommandEvent(item.getName(), command));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bosesoundtouch.internal.ContentItem.generateXML",
	"Comment": "returns the xml code that is needed to switch to this contentitem",
	"Method": "String generateXML(){\r\n    String xml;\r\n    switch(getOperationMode()) {\r\n        case BLUETOOTH:\r\n            xml = \"<ContentItem source=\\\"BLUETOOTH\\\"><\/ContentItem>\";\r\n            break;\r\n        case AUX:\r\n        case AUX1:\r\n        case AUX2:\r\n        case AUX3:\r\n            xml = \"<ContentItem source=\\\"AUX\\\" sourceAccount=\\\"\" + sourceAccount + \"\\\"><\/ContentItem>\";\r\n            break;\r\n        case TV:\r\n            xml = \"<ContentItem source=\\\"PRODUCT\\\" sourceAccount=\\\"TV\\\" isPresetable=\\\"false\\\" />\";\r\n            break;\r\n        case HDMI1:\r\n            xml = \"<ContentItem source=\\\"PRODUCT\\\" sourceAccount=\\\"HDMI_1\\\" isPresetable=\\\"false\\\" />\";\r\n            break;\r\n        default:\r\n            StringBuilder sbXml = new StringBuilder(\"<ContentItem\");\r\n            if (source != null) {\r\n                sbXml.append(\" source=\\\"\").append(StringEscapeUtils.escapeXml(source)).append(\"\\\"\");\r\n            }\r\n            if (location != null) {\r\n                sbXml.append(\" location=\\\"\").append(StringEscapeUtils.escapeXml(location)).append(\"\\\"\");\r\n            }\r\n            if (sourceAccount != null) {\r\n                sbXml.append(\" sourceAccount=\\\"\").append(StringEscapeUtils.escapeXml(sourceAccount)).append(\"\\\"\");\r\n            }\r\n            sbXml.append(\" isPresetable=\\\"\").append(presetable).append(\"\\\"\");\r\n            for (Map.Entry<String, String> aae : additionalAttributes.entrySet()) {\r\n                sbXml.append(\" \").append(aae.getKey()).append(\"=\\\"\").append(StringEscapeUtils.escapeXml(aae.getValue())).append(\"\\\"\");\r\n            }\r\n            sbXml.append(\">\");\r\n            if (itemName != null) {\r\n                sbXml.append(\"<itemName>\").append(itemName).append(\"<\/itemName>\");\r\n            }\r\n            if (containerArt != null) {\r\n                sbXml.append(\"<containerArt>\").append(containerArt).append(\"<\/containerArt>\");\r\n            }\r\n            sbXml.append(\"<\/ContentItem>\");\r\n            xml = sbXml.toString();\r\n            break;\r\n    }\r\n    return xml;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.client.RpcClient.listBidcosInterfaces",
	"Comment": "returns the info of all bidcos interfaces available on the gateway.",
	"Method": "ListBidcosInterfacesParser listBidcosInterfaces(HmInterface hmInterface){\r\n    RpcRequest<T> request = createRpcRequest(\"listBidcosInterfaces\");\r\n    return new ListBidcosInterfacesParser().parse(sendMessage(config.getRpcPort(hmInterface), request));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.internal.util.DateTimeUtils.isTimeGreaterEquals",
	"Comment": "returns true, if cal1 is greater or equal than cal2, ignoring seconds.",
	"Method": "boolean isTimeGreaterEquals(Calendar cal1,Calendar cal2){\r\n    Calendar truncCal1 = DateUtils.truncate(cal1, Calendar.MINUTE);\r\n    Calendar truncCal2 = DateUtils.truncate(cal2, Calendar.MINUTE);\r\n    return truncCal1.getTimeInMillis() >= truncCal2.getTimeInMillis();\r\n}"
}, {
	"Path": "org.spongepowered.api.service.permission.SubjectCollection.applyToAll",
	"Comment": "performs an action on each subject in the provided set.subjects are loaded, supplied to the consumer, and then allowed to beuncached by the implementation.this should be used to apply bulk changes or gather data about allsubjects in the collection. the provided consumer will be suppliedasynchronously. acting upon a large collection may be particularlyresource intensive.implementations may choose to load and process subjects inparallel.",
	"Method": "CompletableFuture<Void> applyToAll(Consumer<Subject> action,CompletableFuture<Void> applyToAll,Consumer<Subject> action,Set<String> identifiers){\r\n    Preconditions.checkNotNull(action, \"action\");\r\n    Preconditions.checkNotNull(identifiers, \"identifiers\");\r\n    return CompletableFuture.runAsync(() -> {\r\n        for (String id : identifiers) {\r\n            Subject subject = loadSubject(id).join();\r\n            action.accept(subject);\r\n            suggestUnload(subject.getIdentifier());\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.spongepowered.api.event.service.ChangeServiceProviderEvent.isReplacement",
	"Comment": "gets whether a previous provider existed, which was replaced by the newprovider.",
	"Method": "boolean isReplacement(){\r\n    return this.getPreviousProviderRegistration().isPresent();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.sse.SseResource.getEvents",
	"Comment": "subscribes the connecting client to the stream of events filtered by thegiven eventfilter.",
	"Method": "Object getEvents(String eventFilter){\r\n    if (!SseUtil.isValidTopicFilter(eventFilter)) {\r\n        return Response.status(Status.BAD_REQUEST).build();\r\n    }\r\n    final EventOutput eventOutput = new SseEventOutput(eventFilter);\r\n    broadcaster.add(eventOutput);\r\n    response.addHeader(X_ACCEL_BUFFERING_HEADER, \"no\");\r\n    if (!SseUtil.SERVLET3_SUPPORT) {\r\n        response.addHeader(HttpHeaders.CONTENT_ENCODING, \"identity\");\r\n        response.setStatus(HttpServletResponse.SC_OK);\r\n        response.setContentType(SseFeature.SERVER_SENT_EVENTS);\r\n        response.flushBuffer();\r\n        SseUtil.enableBlockingSse();\r\n    }\r\n    return eventOutput;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.voice.text.AbstractRuleBasedInterpreter.cmd",
	"Comment": "adds a command to the resulting ast tree, if the expression matches.",
	"Method": "Expression cmd(Object expression,Expression cmd,Object expression,Command command){\r\n    return tag(CMD, expression, command);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.test.OSGiTest.getInterfaceName",
	"Comment": "returns the interface name for a given service object by choosing the first interface.",
	"Method": "String getInterfaceName(Object service){\r\n    Class<?>[] classes = service.getClass().getInterfaces();\r\n    if (classes.length >= 1) {\r\n        return classes[0].getName();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.BluetoothCharacteristic.getDescriptor",
	"Comment": "returns a descriptor with a given uuid out of the list ofdescriptors for this characteristic.",
	"Method": "BluetoothDescriptor getDescriptor(UUID uuid){\r\n    return gattDescriptors.get(uuid);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.internal.command.system.BlueGigaWhitelistAppendCommand.setAddress",
	"Comment": "bluetooth device address to add to the running white list. maximum of 8 can be stored beforeyou must clear or remove entries.",
	"Method": "void setAddress(String address){\r\n    this.address = address;\r\n}"
}, {
	"Path": "org.spongepowered.api.profile.property.ProfileProperty.of",
	"Comment": "creates a new signed property.depending on the property name, if the signature is provided it mustoriginate from mojang.",
	"Method": "ProfileProperty of(String name,String value,ProfileProperty of,String name,String value,String signature){\r\n    return Sponge.getServer().getGameProfileManager().createProfileProperty(name, value, signature);\r\n}"
}, {
	"Path": "org.spongepowered.api.service.permission.NodeTree.asMap",
	"Comment": "convert this node tree into a map of the defined nodes in this tree.",
	"Method": "Map<String, Boolean> asMap(){\r\n    ImmutableMap.Builder<String, Boolean> ret = ImmutableMap.builder();\r\n    for (Map.Entry<String, Node> ent : this.rootNode.children.entrySet()) {\r\n        populateMap(ret, ent.getKey(), ent.getValue());\r\n    }\r\n    return ret.build();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.common.QueueingThreadPoolExecutorTest.testCreateInstance",
	"Comment": "creates queueingtpe instances. by default there will be no threadcreated, check it.",
	"Method": "void testCreateInstance(){\r\n    String poolName = \"testCreateInstance\";\r\n    QueueingThreadPoolExecutor.createInstance(poolName, 1);\r\n    QueueingThreadPoolExecutor.createInstance(poolName, 2);\r\n    QueueingThreadPoolExecutor.createInstance(poolName, 5);\r\n    QueueingThreadPoolExecutor.createInstance(poolName, 10);\r\n    QueueingThreadPoolExecutor.createInstance(poolName, 1000);\r\n    QueueingThreadPoolExecutor.createInstance(poolName, 10000);\r\n    QueueingThreadPoolExecutor.createInstance(poolName, 100000);\r\n    QueueingThreadPoolExecutor.createInstance(poolName, 1000000);\r\n    assertFalse(areThreadsFromPoolRunning(poolName));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.internal.validation.ConfigDescriptionParameterValidatorFactory.createTypeValidator",
	"Comment": "returns a new validator for the data type validation of a config description parameter.",
	"Method": "ConfigDescriptionParameterValidator createTypeValidator(){\r\n    return new TypeValidator();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.MqttBrokerConnection.unsubscribe",
	"Comment": "remove a previously registered consumer from this connection.if no more consumers are registered for a topic, the topic will be unsubscribed from.",
	"Method": "CompletableFuture<Boolean> unsubscribe(String topic,MqttMessageSubscriber subscriber){\r\n    synchronized (subscribers) {\r\n        @Nullable\r\n        final List<MqttMessageSubscriber> list = subscribers.get(topic);\r\n        if (list == null) {\r\n            return CompletableFuture.completedFuture(true);\r\n        }\r\n        list.remove(subscriber);\r\n        if (!list.isEmpty()) {\r\n            return CompletableFuture.completedFuture(true);\r\n        }\r\n        subscribers.remove(topic);\r\n        MqttAsyncClient client = this.client;\r\n        if (client != null) {\r\n            return unsubscribeRaw(client, topic);\r\n        } else {\r\n            return CompletableFuture.completedFuture(false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.fsinternetradio.internal.radio.FrontierSiliconRadio.getPlayInfoText",
	"Comment": "read the stations radio text like the song name currently playing",
	"Method": "String getPlayInfoText(){\r\n    FrontierSiliconRadioApiResult result = conn.doRequest(REQUEST_GET_PLAY_INFO_TEXT);\r\n    return result.getValueC8ArrayAsString();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.misc.DelayedExecuter.start",
	"Comment": "executes a callback method either immediately or after a given delay.",
	"Method": "void start(HmDatapointInfo dpInfo,double delay,DelayedExecuterCallback callback){\r\n    if (delay > 0.0) {\r\n        synchronized (DelayedExecuter.class) {\r\n            logger.debug(\"Delaying event for {} seconds: '{}'\", delay, dpInfo);\r\n            Timer timer = delayedEvents.get(dpInfo);\r\n            if (timer != null) {\r\n                timer.cancel();\r\n            }\r\n            timer = new Timer();\r\n            delayedEvents.put(dpInfo, timer);\r\n            timer.schedule(new TimerTask() {\r\n                @Override\r\n                public void run() {\r\n                    logger.debug(\"Executing delayed event for '{}'\", dpInfo);\r\n                    delayedEvents.remove(dpInfo);\r\n                    try {\r\n                        callback.execute();\r\n                    } catch (Exception ex) {\r\n                        logger.error(\"{}\", ex.getMessage(), ex);\r\n                    }\r\n                }\r\n            }, (long) (delay * 1000));\r\n        }\r\n    } else {\r\n        callback.execute();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.misc.DelayedExecuter.start",
	"Comment": "executes a callback method either immediately or after a given delay.",
	"Method": "void start(HmDatapointInfo dpInfo,double delay,DelayedExecuterCallback callback){\r\n    logger.debug(\"Executing delayed event for '{}'\", dpInfo);\r\n    delayedEvents.remove(dpInfo);\r\n    try {\r\n        callback.execute();\r\n    } catch (Exception ex) {\r\n        logger.error(\"{}\", ex.getMessage(), ex);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.type.ThingType.isListed",
	"Comment": "check, if things of this thing type should be listed for manually pairing or not.",
	"Method": "boolean isListed(){\r\n    return listed;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.testutil.i18n.DefaultLocaleSetter.setDefaultLocale",
	"Comment": "configures the org.eclipse.smarthome.core.i18nprovider based on the provided locale. note that the configurationis not necessarily effective yet when this method returns, as the configuration admin might configure thei18nprovider in another thread.",
	"Method": "void setDefaultLocale(Locale locale){\r\n    assertThat(locale, is(notNullValue()));\r\n    Configuration config = configAdmin.getConfiguration(\"org.eclipse.smarthome.core.i18nprovider\", null);\r\n    assertThat(config, is(notNullValue()));\r\n    Dictionary<String, Object> properties = config.getProperties();\r\n    if (properties == null) {\r\n        properties = new Hashtable();\r\n    }\r\n    properties.put(\"language\", locale.getLanguage());\r\n    properties.put(\"script\", locale.getScript());\r\n    properties.put(\"region\", locale.getCountry());\r\n    properties.put(\"variant\", locale.getVariant());\r\n    config.update(properties);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.firmware.FirmwareStatusInfo.getUpdatableFirmwareVersion",
	"Comment": "returns the firmware version of the latest updatable firmware for the thing.",
	"Method": "String getUpdatableFirmwareVersion(){\r\n    return this.firmwareVersion;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.weatherunderground.internal.json.WeatherUndergroundJsonResponse.getErrorDescription",
	"Comment": "get the error description returned by the weather underground service",
	"Method": "String getErrorDescription(){\r\n    return (error == null) ? null : error.getDescription();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.HueBridge.setGroupName",
	"Comment": "changes the name of the group and returns the new name.a number will be appended to duplicate names, which may result in a new name exceeding 32 characters.",
	"Method": "String setGroupName(Group group,String name){\r\n    requireAuthentication();\r\n    if (!group.isModifiable()) {\r\n        throw new IllegalArgumentException(\"Group cannot be modified\");\r\n    }\r\n    String body = gson.toJson(new SetAttributesRequest(name));\r\n    Result result = http.put(getRelativeURL(\"groups/\" + enc(group.getId())), body);\r\n    handleErrors(result);\r\n    List<SuccessResponse> entries = safeFromJson(result.getBody(), SuccessResponse.GSON_TYPE);\r\n    SuccessResponse response = entries.get(0);\r\n    return (String) response.success.get(\"/groups/\" + enc(group.getId()) + \"/name\");\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.voice.text.TokenList.checkTail",
	"Comment": "checks for the last token of the list.if it is equal to one of the provided alternatives, it will succeed.",
	"Method": "boolean checkTail(String alternatives){\r\n    return check(tail, alternatives);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.core.internal.folder.FolderObserverTest.testNonExisting",
	"Comment": "the following method test the configuration with a non existing subdirectory.",
	"Method": "void testNonExisting(){\r\n    configProps.put(\"nonExistingSubdir\", \"txt,jpg,java\");\r\n    folderObserver.activate(context);\r\n    sleep(WAIT_EVENT_TO_BE_HANDLED);\r\n    waitForAssert(() -> assertThat(modelRepo.isAddOrRefreshModelMethodCalled, is(false)));\r\n    waitForAssert(() -> assertThat(modelRepo.isRemoveModelMethodCalled, is(false)));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.common.HomematicConfig.setTimeout",
	"Comment": "sets the timeout for the communication to a homematic gateway in seconds.",
	"Method": "void setTimeout(int timeout){\r\n    this.timeout = timeout;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.storage.mapdb.internal.StorageServiceOSGiTest.serializationDeserialization",
	"Comment": "assert elements are serialized and deserialized by the storage.",
	"Method": "void serializationDeserialization(){\r\n    Assert.assertEquals(0, storage.getKeys().size());\r\n    storage.put(KEY_1, new PersistedItem(\"String\", Arrays.asList(\"LIGHT\", \"GROUND_FLOOR\")));\r\n    storage.put(KEY_2, new PersistedItem(\"Number\", Arrays.asList(\"TEMPERATURE\", \"OUTSIDE\")));\r\n    Assert.assertEquals(2, storage.getKeys().size());\r\n    final Object persistedObject = storage.get(KEY_1);\r\n    Assert.assertTrue(persistedObject instanceof PersistedItem);\r\n    storage.remove(KEY_1);\r\n    storage.remove(KEY_2);\r\n    Assert.assertEquals(0, storage.getKeys().size());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.climate.jsonresponsecontainer.BaseSensorValues.existSensorValue",
	"Comment": "returns true, if the given sensor type exist, otherwise false.",
	"Method": "boolean existSensorValue(SensorEnum sensorType){\r\n    return getCachedSensorValue(sensorType) != null;\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.RpcRemoting.toRemotingCommand",
	"Comment": "convert application request object to remoting request command.",
	"Method": "RemotingCommand toRemotingCommand(Object request,Connection conn,InvokeContext invokeContext,int timeoutMillis){\r\n    RpcRequestCommand command = this.getCommandFactory().createRequestCommand(request);\r\n    if (null != invokeContext) {\r\n        Object clientCustomSerializer = invokeContext.get(InvokeContext.BOLT_CUSTOM_SERIALIZER);\r\n        if (null != clientCustomSerializer) {\r\n            try {\r\n                command.setSerializer((Byte) clientCustomSerializer);\r\n            } catch (ClassCastException e) {\r\n                throw new IllegalArgumentException(\"Illegal custom serializer [\" + clientCustomSerializer + \"], the type of value should be [byte], but now is [\" + clientCustomSerializer.getClass().getName() + \"].\");\r\n            }\r\n        }\r\n        Boolean crcSwitch = invokeContext.get(InvokeContext.BOLT_CRC_SWITCH, ProtocolSwitch.CRC_SWITCH_DEFAULT_VALUE);\r\n        if (null != crcSwitch && crcSwitch) {\r\n            command.setProtocolSwitch(ProtocolSwitch.create(new int[] { ProtocolSwitch.CRC_SWITCH_INDEX }));\r\n        }\r\n    } else {\r\n        command.setProtocolSwitch(ProtocolSwitch.create(new int[] { ProtocolSwitch.CRC_SWITCH_INDEX }));\r\n    }\r\n    command.setTimeout(timeoutMillis);\r\n    command.setRequestClass(request.getClass().getName());\r\n    command.setInvokeContext(invokeContext);\r\n    command.serialize();\r\n    logDebugInfo(command);\r\n    return command;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.MetadataUtils.getPattern",
	"Comment": "returns the pattern metadata string for the given datapoint.",
	"Method": "String getPattern(HmDatapoint dp){\r\n    if (dp.isFloatType()) {\r\n        return \"%.2f\";\r\n    } else if (dp.isNumberType()) {\r\n        return \"%d\";\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.SlotIndex.lessThanOrEqual",
	"Comment": "create a slotindex property which matches slotindex properties withvalue less than or equal to this value.",
	"Method": "SlotIndex lessThanOrEqual(Object value){\r\n    return new SlotIndex(value, Operator.LEQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.script.actions.Voice.interpret",
	"Comment": "interprets the given text with a given human language interpreter.in case of interpretation error, the error message is played using the given audio sink.if sink parameter is null, the error message is simply not played.",
	"Method": "String interpret(Object text,String interpret,Object text,String interpreter,String interpret,Object text,String interpreter,String sink){\r\n    String response;\r\n    try {\r\n        response = VoiceActionService.voiceManager.interpret(text.toString(), interpreter);\r\n    } catch (InterpretationException e) {\r\n        if (sink != null) {\r\n            say(e.getMessage(), null, sink);\r\n        }\r\n        response = e.getMessage();\r\n    }\r\n    return response;\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.CommandContext.getAll",
	"Comment": "gets all values for the given argument. may return an empty list if novalues are present.",
	"Method": "Collection<T> getAll(String key,Collection<T> getAll,Text key){\r\n    return getAll(ArgUtils.textToArgKey(key));\r\n}"
}, {
	"Path": "org.spongepowered.api.service.context.Context.getName",
	"Comment": "gets the context name.for example, if the context represented a world, the name would bethe name of the world.",
	"Method": "String getName(){\r\n    return getValue();\r\n}"
}, {
	"Path": "ws.com.google.android.mms.pdu.EncodedStringValue.split",
	"Comment": "split this encoded string around matches of the given pattern.",
	"Method": "EncodedStringValue[] split(String pattern){\r\n    String[] temp = getString().split(pattern);\r\n    EncodedStringValue[] ret = new EncodedStringValue[temp.length];\r\n    for (int i = 0; i < ret.length; ++i) {\r\n        try {\r\n            ret[i] = new EncodedStringValue(mCharacterSet, temp[i].getBytes());\r\n        } catch (NullPointerException _) {\r\n            return null;\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.sse.SseResource.broadcastEvent",
	"Comment": "broadcasts an event described by the given parameter to all currentlylistening clients.",
	"Method": "void broadcastEvent(Event event){\r\n    executorService.execute(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            broadcaster.broadcast(SseUtil.buildEvent(event));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.sse.SseResource.broadcastEvent",
	"Comment": "broadcasts an event described by the given parameter to all currentlylistening clients.",
	"Method": "void broadcastEvent(Event event){\r\n    broadcaster.broadcast(SseUtil.buildEvent(event));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.sonos.internal.handler.ZonePlayerHandler.isAdHocGroup",
	"Comment": "checks if the player receiving the command is part of a group thatconsists of randomly added players or contains bonded players",
	"Method": "boolean isAdHocGroup(){\r\n    SonosZoneGroup currentZoneGroup = getCurrentZoneGroup();\r\n    if (currentZoneGroup != null) {\r\n        List<String> zoneGroupMemberNames = currentZoneGroup.getMemberZoneNames();\r\n        if (zoneGroupMemberNames != null) {\r\n            for (String zoneName : zoneGroupMemberNames) {\r\n                if (!zoneName.equals(zoneGroupMemberNames.get(0))) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.convention.homie300.Device.initialize",
	"Comment": "restore nodes and properties from thing channels after handler initalization.",
	"Method": "void initialize(String baseTopic,String deviceID,List<Channel> channels){\r\n    this.topic = baseTopic + \"/\" + deviceID;\r\n    this.deviceID = deviceID;\r\n    nodes.clear();\r\n    for (Channel channel : channels) {\r\n        final String nodeID = channel.getUID().getGroupId();\r\n        final String propertyID = channel.getUID().getIdWithoutGroup();\r\n        if (nodeID == null) {\r\n            continue;\r\n        }\r\n        Node node = nodes.get(nodeID);\r\n        if (node == null) {\r\n            node = createNode(nodeID);\r\n            node.nodeRestoredFromConfig();\r\n            nodes.put(nodeID, node);\r\n        }\r\n        Property property = node.createProperty(propertyID, channel.getConfiguration().as(PropertyAttributes.class));\r\n        property.createChannelFromAttribute();\r\n        node.properties.put(propertyID, property);\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.Inventory.transform",
	"Comment": "transforms this inventory using the given transformation.",
	"Method": "Inventory transform(InventoryTransformation transformation){\r\n    return transformation.transform(this);\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.CommandArgs.peek",
	"Comment": "try to read the next argument without advancing the current index.",
	"Method": "String peek(){\r\n    if (!hasNext()) {\r\n        throw createError(t(\"Not enough arguments\"));\r\n    }\r\n    return this.args.get(this.index + 1).getValue();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.sse.internal.util.SseUtil.enableBlockingSse",
	"Comment": "marks the current thread as processing a blocking sse request.",
	"Method": "void enableBlockingSse(){\r\n    blockingSseEnabled.set(true);\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.AbstractInventoryProperty.getDefaultOperator",
	"Comment": "return the default operator to use, based on the supplied key and value.",
	"Method": "Operator getDefaultOperator(K key,V value){\r\n    return Operator.defaultOperator();\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.explosive.Explosive.explosionRadius",
	"Comment": "the radius in blocks that the explosion will affect. this value may bemissing if the explosion radius is unknown such as when it is generatedrandomly on detonation. setting this value on such explosives willoverride that behavior.",
	"Method": "OptionalValue<Integer> explosionRadius(){\r\n    return getValue(Keys.EXPLOSION_RADIUS).get();\r\n}"
}, {
	"Path": "org.smssecure.smssecure.util.deque.LinkedBlockingDeque.clear",
	"Comment": "atomically removes all of the elements from this deque.the deque will be empty after this call returns.",
	"Method": "void clear(){\r\n    final ReentrantLock lock = this.lock;\r\n    lock.lock();\r\n    try {\r\n        for (Node<E> f = first; f != null; ) {\r\n            f.item = null;\r\n            Node<E> n = f.next;\r\n            f.prev = null;\r\n            f.next = null;\r\n            f = n;\r\n        }\r\n        first = last = null;\r\n        count = 0;\r\n        notFull.signalAll();\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.handler.HomematicThingHandler.deviceLoaded",
	"Comment": "called by the bridgehandler when the device for this thing has been added to the gateway.this is used to reconnect a device that was previously unpaired.",
	"Method": "void deviceLoaded(HmDevice device){\r\n    try {\r\n        updateStatus(device);\r\n    } catch (GatewayNotAvailableException ex) {\r\n    } catch (IOException ex) {\r\n        logger.warn(\"Could not reinitialize the device '{}': {}\", device.getAddress(), ex.getMessage(), ex);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.common.registry.AbstractRegistry.added",
	"Comment": "handle an element that has been added for a provider.this method must only be called if the write lock for elements has been locked!",
	"Method": "void added(Provider<E> provider,E element,boolean added,Provider<E> provider,E element,Collection<E> providerElements){\r\n    final K uid = element.getUID();\r\n    if (identifierToElement.containsKey(uid)) {\r\n        logger.warn(\"Cannot add \\\"{}\\\" with key \\\"{}\\\". It exists already from provider \\\"{}\\\"! Failed to add a second with the same UID from provider \\\"{}\\\"!\", element.getClass().getSimpleName(), uid, elementToProvider.get(identifierToElement.get(uid)).getClass().getSimpleName(), provider.getClass().getSimpleName());\r\n        return false;\r\n    }\r\n    try {\r\n        onAddElement(element);\r\n    } catch (final RuntimeException ex) {\r\n        logger.warn(\"Cannot add \\\"{}\\\" with key \\\"{}\\\": {}\", element.getClass().getSimpleName(), uid, ex.getMessage(), ex);\r\n        return false;\r\n    }\r\n    identifierToElement.put(element.getUID(), element);\r\n    elementToProvider.put(element, provider);\r\n    providerElements.add(element);\r\n    elements.add(element);\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.internal.eir.EirPacket.getRecord",
	"Comment": "returns the specified record decoded in the packet or null if the record is not found",
	"Method": "Object getRecord(EirDataType recordType){\r\n    return records.get(recordType);\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.ArmorEquipable.getHelmet",
	"Comment": "gets the helmet currently being worn by this entity.having the helmet as null will result in having nothing equipped inthe helmet slot.",
	"Method": "Optional<ItemStack> getHelmet(){\r\n    return this.getEquipped(EquipmentTypes.HEADWEAR);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.sample.extension.java.internal.WelcomeHomeCommands.register",
	"Comment": "this method is used to register the commands service, provider of the rules and handlers of the modules thatcompose the rules.",
	"Method": "void register(BundleContext context){\r\n    commandsServiceReg = context.registerService(ConsoleCommandExtension.class.getName(), this, null);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.profiles.dto.ProfileTypeDTOMapper.map",
	"Comment": "maps profile type into stripped profile type data transfer object.",
	"Method": "ProfileTypeDTO map(ProfileType profileType){\r\n    return new ProfileTypeDTO(profileType.getUID().toString(), profileType.getLabel(), profileType instanceof TriggerProfileType ? \"TRIGGER\" : \"STATE\", profileType.getSupportedItemTypes());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.internal.calc.SeasonCalc.getCurrentSeasonNameNorthern",
	"Comment": "returns the current season name for the northern hemisphere.",
	"Method": "SeasonName getCurrentSeasonNameNorthern(Calendar calendar){\r\n    long currentMillis = calendar.getTimeInMillis();\r\n    if (currentMillis < currentSeason.getSpring().getTimeInMillis() || currentMillis >= currentSeason.getWinter().getTimeInMillis()) {\r\n        return SeasonName.WINTER;\r\n    } else if (currentMillis >= currentSeason.getSpring().getTimeInMillis() && currentMillis < currentSeason.getSummer().getTimeInMillis()) {\r\n        return SeasonName.SPRING;\r\n    } else if (currentMillis >= currentSeason.getSummer().getTimeInMillis() && currentMillis < currentSeason.getAutumn().getTimeInMillis()) {\r\n        return SeasonName.SUMMER;\r\n    } else if (currentMillis >= currentSeason.getAutumn().getTimeInMillis() && currentMillis < currentSeason.getWinter().getTimeInMillis()) {\r\n        return SeasonName.AUTUMN;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.model.HmDatapoint.isTrigger",
	"Comment": "returns true, if the datapoint should be handled as a trigger.",
	"Method": "boolean isTrigger(){\r\n    return trigger;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.storage.mapdb.internal.StorageServiceOSGiTest.override",
	"Comment": "assert old element gets overwritten when new value is stored under an existing key.",
	"Method": "void override(){\r\n    Object persistedObject = null;\r\n    PersistedItem persistedItem = null;\r\n    Assert.assertEquals(0, storage.getKeys().size());\r\n    persistedObject = storage.put(KEY_1, new PersistedItem(\"String\", Arrays.asList(\"LIGHT\", \"GROUND_FLOOR\")));\r\n    Assert.assertEquals(1, storage.getKeys().size());\r\n    Assert.assertNull(persistedObject);\r\n    persistedObject = storage.get(KEY_1);\r\n    Assert.assertTrue(persistedObject instanceof PersistedItem);\r\n    persistedItem = (PersistedItem) persistedObject;\r\n    Assert.assertEquals(\"String\", persistedItem.itemType);\r\n    persistedObject = storage.put(KEY_1, new PersistedItem(\"Number\", Arrays.asList(\"TEMPERATURE\")));\r\n    Assert.assertTrue(persistedObject instanceof PersistedItem);\r\n    persistedItem = (PersistedItem) persistedObject;\r\n    Assert.assertEquals(1, storage.getKeys().size());\r\n    Assert.assertEquals(\"String\", persistedItem.itemType);\r\n    persistedObject = storage.get(KEY_1);\r\n    Assert.assertTrue(persistedObject instanceof PersistedItem);\r\n    persistedItem = (PersistedItem) persistedObject;\r\n    Assert.assertEquals(\"Number\", persistedItem.itemType);\r\n    storage.remove(KEY_1);\r\n    Assert.assertEquals(0, storage.getKeys().size());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.HomematicTypeGeneratorImpl.isIgnoredDatapoint",
	"Comment": "returns true, if the given datapoint can be ignored for metadata generation.",
	"Method": "boolean isIgnoredDatapoint(HmDatapoint dp){\r\n    return StringUtils.indexOfAny(dp.getName(), IGNORE_DATAPOINT_NAMES) != -1;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.sample.extension.java.internal.handler.WelcomeHomeActionHandler.getDevice",
	"Comment": "this method provides the way to configure which device to execute the action.",
	"Method": "String getDevice(Configuration configration){\r\n    return (String) (configration != null ? configration.get(WelcomeHomeActionType.CONFIG_DEVICE) : null);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.HueBridge.getGroups",
	"Comment": "returns the list of groups, including the unmodifiable all lights group.",
	"Method": "List<Group> getGroups(){\r\n    requireAuthentication();\r\n    Result result = http.get(getRelativeURL(\"groups\"));\r\n    handleErrors(result);\r\n    Map<String, Group> groupMap = safeFromJson(result.getBody(), Group.GSON_TYPE);\r\n    ArrayList<Group> groupList = new ArrayList();\r\n    groupList.add(new Group());\r\n    for (String id : groupMap.keySet()) {\r\n        Group group = groupMap.get(id);\r\n        group.setId(id);\r\n        groupList.add(group);\r\n    }\r\n    return groupList;\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.GenericArguments.firstParsing",
	"Comment": "returns a command element that matches the first of the provided elementsthat parses tab completion matches from all options.",
	"Method": "CommandElement firstParsing(CommandElement elements){\r\n    return new FirstParsingCommandElement(ImmutableList.copyOf(elements));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.CommandlineModuleTypeProvider.importModuleTypes",
	"Comment": "this method is responsible for importing a set of moduletypes from a specified file or url resource.",
	"Method": "Set<ModuleType> importModuleTypes(String parserType,URL url){\r\n    Parser<ModuleType> parser = parsers.get(parserType);\r\n    if (parser != null) {\r\n        InputStream is = url.openStream();\r\n        BufferedInputStream bis = new BufferedInputStream(is);\r\n        InputStreamReader inputStreamReader = new InputStreamReader(bis);\r\n        try {\r\n            return importData(url, parser, inputStreamReader);\r\n        } finally {\r\n            inputStreamReader.close();\r\n        }\r\n    } else {\r\n        throw new ParsingException(new ParsingNestedException(ParsingNestedException.MODULE_TYPE, null, new Exception(\"Parser \" + parserType + \" not available\")));\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.GenericArguments.repeated",
	"Comment": "require a given command element to be provided a certain number of times.command values will be stored under their provided keys in thecommandcontext.",
	"Method": "CommandElement repeated(CommandElement element,int times){\r\n    return new RepeatedCommandElement(element, times);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.type.ChannelType.getState",
	"Comment": "returns the restrictions of an item state which gives information how to interpret it.",
	"Method": "StateDescription getState(){\r\n    return state;\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.protocol.RpcRequestProcessor.sendResponseIfNecessary",
	"Comment": "send response using remoting context if necessary.if request type is oneway, no need to send any response nor exception.",
	"Method": "void sendResponseIfNecessary(RemotingContext ctx,byte type,RemotingCommand response){\r\n    final int id = response.getId();\r\n    if (type != RpcCommandType.REQUEST_ONEWAY) {\r\n        RemotingCommand serializedResponse = response;\r\n        try {\r\n            response.serialize();\r\n        } catch (SerializationException e) {\r\n            String errMsg = \"SerializationException occurred when sendResponseIfNecessary in RpcRequestProcessor, id=\" + id;\r\n            logger.error(errMsg, e);\r\n            serializedResponse = this.getCommandFactory().createExceptionResponse(id, ResponseStatus.SERVER_SERIAL_EXCEPTION, e);\r\n            try {\r\n                serializedResponse.serialize();\r\n            } catch (SerializationException e1) {\r\n                logger.error(\"serialize SerializationException response failed!\");\r\n            }\r\n        } catch (Throwable t) {\r\n            String errMsg = \"Serialize RpcResponseCommand failed when sendResponseIfNecessary in RpcRequestProcessor, id=\" + id;\r\n            logger.error(errMsg, t);\r\n            serializedResponse = this.getCommandFactory().createExceptionResponse(id, t, errMsg);\r\n        }\r\n        ctx.writeAndFlush(serializedResponse).addListener(new ChannelFutureListener() {\r\n            @Override\r\n            public void operationComplete(ChannelFuture future) throws Exception {\r\n                if (logger.isDebugEnabled()) {\r\n                    logger.debug(\"Rpc response sent! requestId=\" + id + \". The address is \" + RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel()));\r\n                }\r\n                if (!future.isSuccess()) {\r\n                    logger.error(\"Rpc response send failed! id=\" + id + \". The address is \" + RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel()), future.cause());\r\n                }\r\n            }\r\n        });\r\n    } else {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Oneway rpc request received, do not send response, id=\" + id + \", the address is \" + RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.protocol.RpcRequestProcessor.sendResponseIfNecessary",
	"Comment": "send response using remoting context if necessary.if request type is oneway, no need to send any response nor exception.",
	"Method": "void sendResponseIfNecessary(RemotingContext ctx,byte type,RemotingCommand response){\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Rpc response sent! requestId=\" + id + \". The address is \" + RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel()));\r\n    }\r\n    if (!future.isSuccess()) {\r\n        logger.error(\"Rpc response send failed! id=\" + id + \". The address is \" + RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel()), future.cause());\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.net.NetUtil.getIpv4NetBroadcastAddress",
	"Comment": "get the network broadcast address of the subnet a specific ip address is in",
	"Method": "String getIpv4NetBroadcastAddress(String ipAddressString,short prefix){\r\n    String errorString = \"IP '\" + ipAddressString + \"' is not a valid IPv4 address\";\r\n    if (!isValidIPConfig(ipAddressString)) {\r\n        throw new IllegalArgumentException(errorString);\r\n    }\r\n    if (prefix < 1 || prefix > 32) {\r\n        throw new IllegalArgumentException(\"Prefix '\" + prefix + \"' is out of bounds (1-32)\");\r\n    }\r\n    try {\r\n        byte[] addr = InetAddress.getByName(ipAddressString).getAddress();\r\n        byte[] netmask = InetAddress.getByName(networkPrefixLengthToNetmask(prefix)).getAddress();\r\n        byte[] broadcast = new byte[] { (byte) (~netmask[0] | addr[0]), (byte) (~netmask[1] | addr[1]), (byte) (~netmask[2] | addr[2]), (byte) (~netmask[3] | addr[3]) };\r\n        return InetAddress.getByAddress(broadcast).getHostAddress();\r\n    } catch (UnknownHostException ex) {\r\n        throw new IllegalArgumentException(errorString);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.CcuGateway.sendScript",
	"Comment": "main method for sending a tclrega script and parsing the xml result.",
	"Method": "T sendScript(String script,Class<T> clazz){\r\n    try {\r\n        script = StringUtils.trim(script);\r\n        if (StringUtils.isEmpty(script)) {\r\n            throw new RuntimeException(\"Homematic TclRegaScript is empty!\");\r\n        }\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(\"TclRegaScript: {}\", script);\r\n        }\r\n        StringContentProvider content = new StringContentProvider(script, config.getEncoding());\r\n        ContentResponse response = httpClient.POST(config.getTclRegaUrl()).content(content).timeout(config.getTimeout(), TimeUnit.SECONDS).header(HttpHeader.CONTENT_TYPE, \"text/plain;charset=\" + config.getEncoding()).send();\r\n        String result = new String(response.getContent(), config.getEncoding());\r\n        result = StringUtils.substringBeforeLast(result, \"<xml><exec>\");\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(\"Result TclRegaScript: {}\", result);\r\n        }\r\n        return (T) xStream.fromXML(result);\r\n    } catch (Exception ex) {\r\n        throw new IOException(ex.getMessage(), ex);\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.InventoryDimension.lessThan",
	"Comment": "create an inventorydimension property which matches inventorydimensionproperties with value less than this value.",
	"Method": "InventoryDimension lessThan(Object value){\r\n    return new InventoryDimension(value, Operator.LESS);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.MqttBrokerConnection.setRetain",
	"Comment": "set whether newly published messages should be retained by the broker.",
	"Method": "void setRetain(boolean retain){\r\n    this.retain = retain;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.binding.BaseThingHandler.updateConfiguration",
	"Comment": "updates the configuration of the thing and informs the framework about it.",
	"Method": "void updateConfiguration(Configuration configuration){\r\n    Map<String, Object> old = this.thing.getConfiguration().getProperties();\r\n    try {\r\n        this.thing.getConfiguration().setProperties(configuration.getProperties());\r\n        synchronized (this) {\r\n            if (this.callback != null) {\r\n                this.callback.thingUpdated(thing);\r\n            } else {\r\n                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\", this.getClass().getSimpleName());\r\n            }\r\n        }\r\n    } catch (RuntimeException e) {\r\n        logger.warn(\"Error while applying configuration changes: '{}: {}' - reverting configuration changes on thing '{}'.\", e.getClass().getSimpleName(), e.getMessage(), this.thing.getUID().getAsString());\r\n        this.thing.getConfiguration().setProperties(old);\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.HomematicGatewayFactory.loadGatewayInfo",
	"Comment": "loads some metadata about the type of the homematic gateway.",
	"Method": "void loadGatewayInfo(HomematicConfig config,String id,HttpClient httpClient){\r\n    RpcClient<String> rpcClient = new XmlRpcClient(config, httpClient);\r\n    try {\r\n        config.setGatewayInfo(rpcClient.getGatewayInfo(id));\r\n    } finally {\r\n        rpcClient.dispose();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.ui.icon.AbstractResourceIconProvider.activate",
	"Comment": "when activating the service, we need to keep the bundle context.",
	"Method": "void activate(BundleContext context){\r\n    this.context = context;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.internal.ssl.Pin.setCheckMode",
	"Comment": "this sets the pin instance to checking mode. the givendata is expected to be hashed in the pins hashmethod.",
	"Method": "void setCheckMode(PinMessageDigest pinMessageDigest,byte[] data){\r\n    this.hashDigest = pinMessageDigest;\r\n    this.learning = false;\r\n    this.pinData = data;\r\n}"
}, {
	"Path": "org.spongepowered.api.event.message.MessageEvent.clearMessage",
	"Comment": "clears the currently set message and returns the empty formatter.",
	"Method": "MessageFormatter clearMessage(){\r\n    MessageFormatter formatter = getFormatter();\r\n    formatter.clear();\r\n    return formatter;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.extensionservice.marketplace.internal.MarketplaceProxy.refresh",
	"Comment": "refreshes the local content by synchronizing with the remote marketplace.",
	"Method": "void refresh(){\r\n    XmlDocumentReader<Marketplace> reader = new MarketplaceXMLReader();\r\n    try {\r\n        Marketplace result = reader.readFromXML(url);\r\n        cachedNodes = result.categories[0].nodes;\r\n    } catch (Exception e) {\r\n        if (cachedNodes == null) {\r\n            logger.warn(\"Failed downloading Marketplace entries: {}\", e.getMessage());\r\n            logger.warn(\"Retrying again in a minute\");\r\n            this.executorService.schedule(() -> refresh(), retry_delay, TimeUnit.SECONDS);\r\n        } else {\r\n            logger.debug(\"Cannot access IoT Marketplace - will continue to use cached results: {}\", e.getMessage());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.internal.TopicSubscribeMultiConnection.remove",
	"Comment": "removes the thing from observed connections, if it exists in there, and stops any mqtt subscriptions.",
	"Method": "void remove(AbstractBrokerHandler handler){\r\n    final TopicSubscribe observedBrokerHandler = observedBrokerHandlers.remove(handler.getThing().getUID());\r\n    if (observedBrokerHandler != null) {\r\n        observedBrokerHandler.stop();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.weatherunderground.internal.json.WeatherUndergroundJsonUtils.convertToTrend",
	"Comment": "convert a string representing a decimal value into a pressure trend constant",
	"Method": "String convertToTrend(String value){\r\n    String result = null;\r\n    if (isValid(value)) {\r\n        try {\r\n            int val = Integer.valueOf(value.trim());\r\n            if (val < 0) {\r\n                result = TREND_DOWN;\r\n            } else if (val > 0) {\r\n                result = TREND_UP;\r\n            } else {\r\n                result = TREND_STABLE;\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            LoggerFactory.getLogger(WeatherUndergroundJsonUtils.class).debug(\"Cannot convert {} to Integer\", value);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.ui.icon.IconSet.getFormats",
	"Comment": "provides information about supported file formats of this set.",
	"Method": "Set<Format> getFormats(){\r\n    return Collections.unmodifiableSet(formats);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.internal.BlueGigaSerialHandler.sendBleRequestAsync",
	"Comment": "sends an bluegiga request without waiting for the response.",
	"Method": "Future<T> sendBleRequestAsync(BlueGigaCommand bleCommand,Class<T> expected){\r\n    checkIfAlive();\r\n    class TransactionWaiter implements Callable<T>, BluetoothListener<T> {\r\n        private boolean complete;\r\n        private BlueGigaResponse response;\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public T call() {\r\n            addTransactionListener(this);\r\n            queueFrame(bleCommand);\r\n            synchronized (this) {\r\n                while (!complete) {\r\n                    try {\r\n                        wait();\r\n                    } catch (InterruptedException e) {\r\n                        complete = true;\r\n                    }\r\n                }\r\n            }\r\n            removeTransactionListener(this);\r\n            return (T) response;\r\n        }\r\n        @Override\r\n        public boolean transactionEvent(BlueGigaResponse bleResponse) {\r\n            if (bleCommand.hashCode() == bleResponse.hashCode()) {\r\n                return false;\r\n            }\r\n            if (!expected.isInstance(bleResponse)) {\r\n                logger.warn(\"Ignoring {} response which has not been requested.\", bleResponse.getClass().getSimpleName());\r\n                return false;\r\n            }\r\n            response = bleResponse;\r\n            complete = true;\r\n            synchronized (this) {\r\n                notify();\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    Callable<T> worker = new TransactionWaiter();\r\n    return executor.submit(worker);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.internal.BlueGigaSerialHandler.sendBleRequestAsync",
	"Comment": "sends an bluegiga request without waiting for the response.",
	"Method": "Future<T> sendBleRequestAsync(BlueGigaCommand bleCommand,Class<T> expected){\r\n    addTransactionListener(this);\r\n    queueFrame(bleCommand);\r\n    synchronized (this) {\r\n        while (!complete) {\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException e) {\r\n                complete = true;\r\n            }\r\n        }\r\n    }\r\n    removeTransactionListener(this);\r\n    return (T) response;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.internal.BlueGigaSerialHandler.sendBleRequestAsync",
	"Comment": "sends an bluegiga request without waiting for the response.",
	"Method": "Future<T> sendBleRequestAsync(BlueGigaCommand bleCommand,Class<T> expected){\r\n    if (bleCommand.hashCode() == bleResponse.hashCode()) {\r\n        return false;\r\n    }\r\n    if (!expected.isInstance(bleResponse)) {\r\n        logger.warn(\"Ignoring {} response which has not been requested.\", bleResponse.getClass().getSimpleName());\r\n        return false;\r\n    }\r\n    response = bleResponse;\r\n    complete = true;\r\n    synchronized (this) {\r\n        notify();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.spongepowered.api.command.CommandResult.success",
	"Comment": "returns a result indicating the command was processed with a singlesuccess.",
	"Method": "CommandResult success(){\r\n    return SUCCESS;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.handler.BlueGigaBridgeHandler.bgConnect",
	"Comment": "connects to a device.if the device is already connected, or the attempt to connect failed, then we return false. if we have reachedthe maximum number of connections supported by this dongle, then we return false.",
	"Method": "boolean bgConnect(BluetoothAddress address,BluetoothAddressType addressType){\r\n    if (connections.containsValue(address)) {\r\n        return false;\r\n    }\r\n    if (connections.size() == maxConnections + 1) {\r\n        logger.debug(\"BlueGiga: Attempt to connect to {} but no connections available.\", address);\r\n        return false;\r\n    }\r\n    bgSetMode();\r\n    int connIntervalMin = 60;\r\n    int connIntervalMax = 100;\r\n    int latency = 0;\r\n    int timeout = 100;\r\n    BlueGigaConnectDirectCommand connect = new BlueGigaConnectDirectCommand();\r\n    connect.setAddress(address.toString());\r\n    connect.setAddrType(addressType);\r\n    connect.setConnIntervalMin(connIntervalMin);\r\n    connect.setConnIntervalMax(connIntervalMax);\r\n    connect.setLatency(latency);\r\n    connect.setTimeout(timeout);\r\n    BlueGigaConnectDirectResponse connectResponse = (BlueGigaConnectDirectResponse) getBgHandler().sendTransaction(connect);\r\n    if (connectResponse.getResult() != BgApiResponse.SUCCESS) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.internal.i18n.ResourceBundleTracker.addResourceBundle",
	"Comment": "this method adds the localization resources provided by this osgi bundle parameter if the bundle is not inuninstalled state.",
	"Method": "void addResourceBundle(Bundle bundle){\r\n    if (bundle.getState() != Bundle.UNINSTALLED) {\r\n        LanguageResourceBundleManager languageResource = new LanguageResourceBundleManager(localeProvider, bundle);\r\n        if (languageResource.containsResources()) {\r\n            this.bundleLanguageResourceMap.put(bundle, languageResource);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.UidUtils.generateChannelUID",
	"Comment": "generates the channeluid for the given datapoint with channelnumber and datapointname.",
	"Method": "ChannelUID generateChannelUID(HmDatapoint dp,ThingUID thingUID){\r\n    return new ChannelUID(thingUID, String.valueOf(dp.getChannel().getNumber()), dp.getName());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.sample.extension.java.internal.WelcomeHomeRulesProvider.update",
	"Comment": "this method is used to update the provided rules configuration.",
	"Method": "void update(String uid,String template,Configuration config){\r\n    Rule oldelement = rules.get(uid);\r\n    Rule element = RuleBuilder.create(uid).withTemplateUID(template).withConfiguration(config).build();\r\n    rules.put(uid, element);\r\n    for (ProviderChangeListener<Rule> listener : listeners) {\r\n        listener.updated(this, oldelement, element);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bosesoundtouch.internal.ContentItem.equals",
	"Comment": "returns true if source, sourceaccount, location, itemname, and presetable are equal",
	"Method": "boolean equals(Object obj){\r\n    if (obj instanceof ContentItem) {\r\n        ContentItem other = (ContentItem) obj;\r\n        if (!isEqual(other.source, this.source)) {\r\n            return false;\r\n        }\r\n        if (!isEqual(other.sourceAccount, this.sourceAccount)) {\r\n            return false;\r\n        }\r\n        if (other.presetable != this.presetable) {\r\n            return false;\r\n        }\r\n        if (!isEqual(other.location, this.location)) {\r\n            return false;\r\n        }\r\n        if (!isEqual(other.itemName, this.itemName)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    return super.equals(obj);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.discovery.mdns.internal.MDNSDiscoveryServiceOSGiTest.testDynamicConfigurationOfBackgroundDiscovery",
	"Comment": "test that configuring the background discovery dynamically via config admin is effective.",
	"Method": "void testDynamicConfigurationOfBackgroundDiscovery(){\r\n    setBackgroundDiscoveryViaConfigAdmin(true);\r\n    waitForAssert(() -> assertThat(mdnsDiscoveryService.isBackgroundDiscoveryEnabled(), is(true)), 2000, 100);\r\n    setBackgroundDiscoveryViaConfigAdmin(false);\r\n    waitForAssert(() -> assertThat(mdnsDiscoveryService.isBackgroundDiscoveryEnabled(), is(false)), 2000, 100);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.MqttBrokerConnection.finalizeStopAfterDisconnect",
	"Comment": "after a successful disconnect, the underlying library objects need to be closed and connection observers want tobe notified.",
	"Method": "boolean finalizeStopAfterDisconnect(boolean v){\r\n    if (client != null) {\r\n        try {\r\n            client.close();\r\n        } catch (Exception ignore) {\r\n        }\r\n    }\r\n    client = null;\r\n    if (dataStore != null) {\r\n        try {\r\n            dataStore.close();\r\n        } catch (Exception ignore) {\r\n        }\r\n        dataStore = null;\r\n    }\r\n    connectionObservers.forEach(o -> o.connectionStateChanged(MqttConnectionState.DISCONNECTED, null));\r\n    return v;\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.living.Living.maxHealth",
	"Comment": "gets the current maximum health.the maximum health set here may affect the attribute increasinghealth points. the base health should be minded that it may be lowerthan the total maximum health of this entity.",
	"Method": "MutableBoundedValue<Double> maxHealth(){\r\n    return getValue(Keys.MAX_HEALTH).get();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.sonos.internal.handler.ZonePlayerHandler.setVolumeForGroup",
	"Comment": "set the volume command specific to the current grouping according to the sonos behaviour.adhoc groups handles the volume specifically for each player.bonded groups delegate the volume to the coordinator which applies the same level to all group members.",
	"Method": "void setVolumeForGroup(Command command){\r\n    if (isAdHocGroup() || isStandalonePlayer()) {\r\n        setVolume(command);\r\n    } else {\r\n        try {\r\n            getCoordinatorHandler().setVolume(command);\r\n        } catch (IllegalStateException e) {\r\n            logger.debug(\"Cannot set group volume ({})\", e.getMessage());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.protocol.RpcRequestProcessor.preProcessRemotingContext",
	"Comment": "pre process remoting context, initial some useful infos and pass to biz",
	"Method": "void preProcessRemotingContext(RemotingContext ctx,RpcRequestCommand cmd,long currentTimestamp){\r\n    ctx.setArriveTimestamp(cmd.getArriveTime());\r\n    ctx.setTimeout(cmd.getTimeout());\r\n    ctx.setRpcCommandType(cmd.getType());\r\n    ctx.getInvokeContext().putIfAbsent(InvokeContext.BOLT_PROCESS_WAIT_TIME, currentTimestamp - cmd.getArriveTime());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.MetadataUtils.getStatePattern",
	"Comment": "returns the state pattern metadata string with unit for the given datapoint.",
	"Method": "String getStatePattern(HmDatapoint dp){\r\n    String unit = getUnit(dp);\r\n    if (unit != null && unit != \"\") {\r\n        String pattern = getPattern(dp);\r\n        if (pattern != null) {\r\n            return String.format(\"%s %s\", pattern, \"%unit%\");\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.crafting.CraftingInventory.getRecipe",
	"Comment": "retrieves the recipe formed by this craftinginventory, if any.",
	"Method": "Optional<CraftingRecipe> getRecipe(World world){\r\n    return getCraftingGrid().getRecipe(world);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bosesoundtouch.internal.CommandExecutor.addCurrentContentItemToPresetContainer",
	"Comment": "adds the current selected contentitem to the presetcontainer",
	"Method": "void addCurrentContentItemToPresetContainer(DecimalType command){\r\n    if (command.intValue() > 6) {\r\n        addContentItemToPresetContainer(command.intValue(), currentContentItem);\r\n    } else {\r\n        logger.warn(\"{}: Only PresetID >6 is allowed\", handler.getDeviceName());\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.Utils.sort3",
	"Comment": "auxiliary method for sorting lexicographically the strings at the positions x, y and z.",
	"Method": "void sort3(String[] a,int x,int y,int z){\r\n    if (a[x].compareTo(a[y]) > 0) {\r\n        if (a[x].compareTo(a[z]) > 0) {\r\n            if (a[y].compareTo(a[z]) > 0) {\r\n                swap(a, x, z);\r\n            } else {\r\n                swap3(a, x, y, z);\r\n            }\r\n        } else {\r\n            swap(a, x, y);\r\n        }\r\n    } else if (a[x].compareTo(a[z]) > 0) {\r\n        swap3(a, x, z, y);\r\n    } else if (a[y].compareTo(a[z]) > 0) {\r\n        swap(a, y, z);\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.SlotIndex.greaterThan",
	"Comment": "create a slotindex property which matches slotindex properties withvalue greater than this value.",
	"Method": "SlotIndex greaterThan(Object value){\r\n    return new SlotIndex(value, Operator.GREATER);\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.CommandContext.checkPermission",
	"Comment": "perform a permissions check, throwing an exception if the requiredpermissions are not present.",
	"Method": "void checkPermission(CommandSource commander,String permission){\r\n    if (!commander.hasPermission(permission)) {\r\n        throw new CommandException(t(\"You do not have permission to use this command!\"));\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.core.internal.item.ItemResource.getItemResponse",
	"Comment": "prepare a response representing the item depending in the status.",
	"Method": "Response getItemResponse(Status status,Item item,Locale locale,String errormessage){\r\n    Object entity = null != item ? EnrichedItemDTOMapper.map(item, true, null, uriInfo.getBaseUri(), locale) : null;\r\n    return JSONResponse.createResponse(status, entity, errormessage);\r\n}"
}, {
	"Path": "org.spongepowered.api.command.CommandResult.affectedEntities",
	"Comment": "returns a result indicating the command was processed with anamount of affected entities.",
	"Method": "CommandResult affectedEntities(int count,Builder affectedEntities,Integer affectedEntities){\r\n    return builder().affectedEntities(count).build();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.weatherunderground.internal.json.WeatherUndergroundJsonUtils.convertToZonedDateTime",
	"Comment": "convert a string representing an epoch value into a calendar object",
	"Method": "ZonedDateTime convertToZonedDateTime(String value){\r\n    if (isValid(value)) {\r\n        try {\r\n            Instant epochSeconds = Instant.ofEpochSecond(Long.valueOf(value));\r\n            return ZonedDateTime.ofInstant(epochSeconds, TimeZone.getDefault().toZoneId());\r\n        } catch (DateTimeException e) {\r\n            LoggerFactory.getLogger(WeatherUndergroundJsonUtils.class).debug(\"Cannot convert {} to ZonedDateTime\", value);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.InventoryDimension.of",
	"Comment": "create an inventorydimension property which matches inventorydimensionproperties with equal value.",
	"Method": "InventoryDimension of(Object value,InventoryDimension of,int width,int height){\r\n    return new InventoryDimension(new Vector2i(width, height), Operator.EQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.xml.util.ConverterAssertion.assertNoAttribute",
	"Comment": "asserts that the current node associated with the specified reader does not containany attributes.",
	"Method": "void assertNoAttribute(HierarchicalStreamReader reader){\r\n    if (reader.getAttributeCount() > 0) {\r\n        throw new ConversionException(\"The parameter '\" + reader.getNodeName() + \"' uses unknown attributes!\");\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.internal.util.DateTimeUtils.isSameDay",
	"Comment": "returns true, if two calendar objects are on the same day ignoring time.",
	"Method": "boolean isSameDay(Calendar cal1,Calendar cal2){\r\n    return cal1 != null && cal2 != null && DateUtils.isSameDay(cal1, cal2);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.common.HomematicConfig.getInstallModeDuration",
	"Comment": "returns time in seconds that the controller will be in install mode whena device discovery is initiated",
	"Method": "int getInstallModeDuration(){\r\n    return installModeDuration;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.BluetoothDevice.disableNotifications",
	"Comment": "disables notifications for a descriptor. only a single read or write operation can be requested at once.attempting to perform an operation when one is already in progress will result in subsequent calls returningfalse.",
	"Method": "boolean disableNotifications(BluetoothCharacteristic characteristic,boolean disableNotifications,BluetoothDescriptor descriptor){\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension.buildCommandUsage",
	"Comment": "build a command usage string.you should always use that function to use a usage string that complies to a standard format.",
	"Method": "String buildCommandUsage(String description,String buildCommandUsage,String syntax,String description){\r\n    return String.format(\"%s %s - %s\", getCommand(), syntax, description);\r\n}"
}, {
	"Path": "com.alipay.remoting.ProcessorManager.registerDefaultProcessor",
	"Comment": "register the default processor to process command with no specific processor registered.",
	"Method": "void registerDefaultProcessor(RemotingProcessor<?> processor){\r\n    if (this.defaultProcessor == null) {\r\n        this.defaultProcessor = processor;\r\n    } else {\r\n        throw new IllegalStateException(\"The defaultProcessor has already been registered: \" + this.defaultProcessor.getClass());\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.dto.ConfigDescriptionDTOMapper.mapParameterGroups",
	"Comment": "maps configuration description parameter groups into dto objects.",
	"Method": "List<ConfigDescriptionParameterGroupDTO> mapParameterGroups(List<ConfigDescriptionParameterGroup> parameterGroups){\r\n    List<ConfigDescriptionParameterGroupDTO> parameterGroupBeans = new ArrayList(parameterGroups.size());\r\n    for (ConfigDescriptionParameterGroup parameterGroup : parameterGroups) {\r\n        parameterGroupBeans.add(new ConfigDescriptionParameterGroupDTO(parameterGroup.getName(), parameterGroup.getContext(), parameterGroup.isAdvanced(), parameterGroup.getLabel(), parameterGroup.getDescription()));\r\n    }\r\n    return parameterGroupBeans;\r\n}"
}, {
	"Path": "com.alipay.remoting.DefaultConnectionManager.healIfNeed",
	"Comment": "execute heal connection tasks if the actual number of connections in pool is less than expected",
	"Method": "void healIfNeed(ConnectionPool pool,Url url){\r\n    String poolKey = url.getUniqueKey();\r\n    if (pool.isAsyncCreationDone() && pool.size() < url.getConnNum()) {\r\n        FutureTask<Integer> task = this.healTasks.get(poolKey);\r\n        if (null == task) {\r\n            task = new FutureTask<Integer>(new HealConnectionCall(url, pool));\r\n            task = this.healTasks.putIfAbsent(poolKey, task);\r\n            if (null == task) {\r\n                task = this.healTasks.get(poolKey);\r\n                task.run();\r\n            }\r\n        }\r\n        try {\r\n            int numAfterHeal = task.get();\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"[NOTIFYME] - conn num after heal {}, expected {}, warmup {}\", numAfterHeal, url.getConnNum(), url.isConnWarmup());\r\n            }\r\n        } catch (InterruptedException e) {\r\n            this.healTasks.remove(poolKey);\r\n            throw e;\r\n        } catch (ExecutionException e) {\r\n            this.healTasks.remove(poolKey);\r\n            Throwable cause = e.getCause();\r\n            if (cause instanceof RemotingException) {\r\n                throw (RemotingException) cause;\r\n            } else {\r\n                FutureTaskUtil.launderThrowable(cause);\r\n            }\r\n        }\r\n        this.healTasks.remove(poolKey);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.internal.calc.MoonCalc.getApogee",
	"Comment": "calculates the date, where the moon is furthest away from the earth.",
	"Method": "double getApogee(double julianDate,double decimalYear){\r\n    double k = Math.floor((decimalYear - 1999.97) * 13.2555) + .5;\r\n    double jd = 0;\r\n    do {\r\n        double t = k / 1325.55;\r\n        double d = 171.9179 + 335.9106046 * k - .010025 * t * t - .00001156 * t * t * t + .000000055 * t * t * t * t;\r\n        double m = 347.3477 + 27.1577721 * k - .0008323 * t * t - .000001 * t * t * t;\r\n        double f = 316.6109 + 364.5287911 * k - .0125131 * t * t - .0000148 * t * t * t;\r\n        jd = 2451534.6698 + 27.55454988 * k - .0006886 * t * t - .000001098 * t * t * t + .0000000052 * t * t + .4392 * SN(2 * d) + .0684 * SN(4 * d) + (.0456 - .00011 * t) * SN(m) + (.0426 - .00011 * t) * SN(2 * d - m) + .0212 * SN(2 * f);\r\n        jd += -.0189 * SN(d) + .0144 * SN(6 * d) + .0113 * SN(4 * d - m) + .0047 * SN(2 * d + 2 * f) + .0036 * SN(d + m) + .0035 * SN(8 * d) + .0034 * SN(6 * d - m) - .0034 * SN(2 * d - 2 * f) + .0022 * SN(2 * d - 2 * m) - .0017 * SN(3 * d);\r\n        jd += .0013 * SN(4 * d + 2 * f) + .0011 * SN(8 * d - m) + .001 * SN(4 * d - 2 * m) + .0009 * SN(10 * d) + .0007 * SN(3 * d + m) + .0006 * SN(2 * m) + .0005 * SN(2 * d + m) + .0005 * SN(2 * d + 2 * m) + .0004 * SN(6 * d + 2 * f);\r\n        jd += .0004 * SN(6 * d - 2 * m) + .0004 * SN(10 * d - m) - .0004 * SN(5 * d) - .0004 * SN(4 * d - 2 * f) + .0003 * SN(2 * f + m) + .0003 * SN(12 * d) + .0003 * SN(2 * d + 2 * f - m) - .0003 * SN(d - m);\r\n        k += 1;\r\n    } while (jd < julianDate);\r\n    return jd;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.manager.impl.TemperatureControlManager.isConfigured",
	"Comment": "returns true, if minimum one zone has temperature control configured.",
	"Method": "boolean isConfigured(){\r\n    return isConfigured;\r\n}"
}, {
	"Path": "org.spongepowered.api.item.recipe.smelting.SmeltingResult.getExperience",
	"Comment": "returns the amount of experience released after completing a recipe.",
	"Method": "double getExperience(){\r\n    return this.experience;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.MetadataUtils.isStandard",
	"Comment": "returns true, if the given datapoint is a standard datapoint.",
	"Method": "boolean isStandard(HmDatapoint dp){\r\n    Set<String> channelDatapoints = standardDatapoints.get(dp.getChannel().getType());\r\n    if (channelDatapoints == null) {\r\n        return true;\r\n    }\r\n    return channelDatapoints.contains(dp.getName());\r\n}"
}, {
	"Path": "com.alipay.remoting.ProcessorManager.registerProcessor",
	"Comment": "register processor to process command that has the command code of cmdcode.",
	"Method": "void registerProcessor(CommandCode cmdCode,RemotingProcessor<?> processor){\r\n    if (this.cmd2processors.containsKey(cmdCode)) {\r\n        logger.warn(\"Processor for cmd={} is already registered, the processor is {}, and changed to {}\", cmdCode, cmd2processors.get(cmdCode).getClass().getName(), processor.getClass().getName());\r\n    }\r\n    this.cmd2processors.put(cmdCode, processor);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.convention.homie300.Property.attributesReceived",
	"Comment": "as soon as subscribing succeeded and corresponding mqtt values have been received, the channeltype andchannelstate are determined.",
	"Method": "void attributesReceived(){\r\n    createChannelFromAttribute();\r\n    callback.propertyAddedOrChanged(this);\r\n}"
}, {
	"Path": "org.spongepowered.api.command.CommandMessageFormatting.debug",
	"Comment": "format text to be output as a debug message directly to a sender.",
	"Method": "Text debug(Text debug){\r\n    return debug.toBuilder().color(TextColors.GRAY).build();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.net.NetUtil.isValidIPConfig",
	"Comment": "checks if the given string is a valid ipv4 addressor ipv4 address in cidr notation",
	"Method": "boolean isValidIPConfig(String ipAddress){\r\n    if (ipAddress.contains(\"/\")) {\r\n        String[] parts = ipAddress.split(\"/\");\r\n        boolean ipMatches = IPV4_PATTERN.matcher(parts[0]).matches();\r\n        int netMask = Integer.parseInt(parts[1]);\r\n        boolean netMaskMatches = false;\r\n        if (netMask > 0 || netMask < 32) {\r\n            netMaskMatches = true;\r\n        }\r\n        if (ipMatches && netMaskMatches) {\r\n            return true;\r\n        }\r\n    } else {\r\n        return IPV4_PATTERN.matcher(ipAddress).matches();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.CommandArgs.createError",
	"Comment": "create a parse exception with the provided message which has the positionof the last parsed argument attached. the returned exception must bethrown at the target",
	"Method": "ArgumentParseException createError(Text message){\r\n    return new ArgumentParseException(message, this.rawInput, this.index < 0 ? 0 : this.args.get(this.index).getStartIdx());\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.FallingBlock.canHurtEntities",
	"Comment": "gets whether this falling block will damage entities where it lands.",
	"Method": "Value<Boolean> canHurtEntities(){\r\n    return getValue(Keys.FALLING_BLOCK_CAN_HURT_ENTITIES).get();\r\n}"
}, {
	"Path": "com.alipay.remoting.DefaultConnectionManager.createConnectionAndHealIfNeed",
	"Comment": "if no task cached, create one and initialize the connections.if task cached, check whether the number of connections adequate, if not then heal it.",
	"Method": "void createConnectionAndHealIfNeed(Url url){\r\n    ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url));\r\n    if (null != pool) {\r\n        healIfNeed(pool, url);\r\n    } else {\r\n        logger.error(\"[NOTIFYME] bug detected! pool here must not be null!\");\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.script.actions.BusEvent.sendCommand",
	"Comment": "sends a number as a command for a specified item to the event bus.",
	"Method": "Object sendCommand(Item item,String commandString,Object sendCommand,Item item,Number number,Object sendCommand,String itemName,String commandString,Object sendCommand,Item item,Command command){\r\n    EventPublisher publisher = ScriptServiceUtil.getEventPublisher();\r\n    if (publisher != null && item != null) {\r\n        publisher.post(ItemEventFactory.createCommandEvent(item.getName(), command));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.type.ThingType.getUID",
	"Comment": "returns the unique identifier which identifies this thing type within the overall system.",
	"Method": "ThingTypeUID getUID(){\r\n    return (ThingTypeUID) super.getUID();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.MqttBrokerConnection.subscribeRaw",
	"Comment": "subscribes to a topic on the given connection, but does not alter the subscriber list.",
	"Method": "CompletableFuture<Boolean> subscribeRaw(String topic){\r\n    logger.trace(\"subscribeRaw message consumer for topic '{}' from broker '{}'\", topic, host);\r\n    CompletableFuture<Boolean> future = new CompletableFuture<Boolean>();\r\n    try {\r\n        MqttAsyncClient client = this.client;\r\n        if (client != null && client.isConnected()) {\r\n            client.subscribe(topic, qos, future, actionCallback);\r\n        } else {\r\n            future.complete(false);\r\n        }\r\n    } catch (org.eclipse.paho.client.mqttv3.MqttException e) {\r\n        logger.info(\"Error subscribing to topic {}\", topic, e);\r\n        future.completeExceptionally(e);\r\n    }\r\n    return future;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.deltaSince",
	"Comment": "gets the difference value of the state of a given item since a certain point in time.the default persistence service is used.",
	"Method": "DecimalType deltaSince(Item item,AbstractInstant timestamp,DecimalType deltaSince,Item item,AbstractInstant timestamp,String serviceId){\r\n    HistoricItem itemThen = historicState(item, timestamp, serviceId);\r\n    if (itemThen != null) {\r\n        DecimalType valueThen = (DecimalType) itemThen.getState();\r\n        DecimalType valueNow = item.getStateAs(DecimalType.class);\r\n        if ((valueThen != null) && (valueNow != null)) {\r\n            return new DecimalType(valueNow.toBigDecimal().subtract(valueThen.toBigDecimal()));\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.onewire.internal.OwDynamicStateDescriptionProvider.setDescription",
	"Comment": "set a state description for a channel. this description will be used when preparing the channel state bythe framework for presentation. a previous description, if existed, will be replaced.",
	"Method": "void setDescription(ChannelUID channelUID,StateDescription description){\r\n    logger.trace(\"adding state description for channel {}\", channelUID);\r\n    descriptions.put(channelUID, description);\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.SlotPos.not",
	"Comment": "create an slotpos property which matches slotpos properties with unequalvalue.",
	"Method": "SlotPos not(Object value){\r\n    return new SlotPos(value, Operator.NOTEQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.discovery.DiscoveryListener.removeOlderResults",
	"Comment": "removes all results belonging to one of the given types that are olderthan the given timestamp.",
	"Method": "Collection<ThingUID> removeOlderResults(DiscoveryService source,long timestamp,Collection<ThingTypeUID> thingTypeUIDs,Collection<ThingUID> removeOlderResults,DiscoveryService source,long timestamp,Collection<ThingTypeUID> thingTypeUIDs,ThingUID bridgeUID){\r\n    return removeOlderResults(source, timestamp, thingTypeUIDs, null);\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.GenericArguments.enumValue",
	"Comment": "require the argument to be a key under the provided enum.gives values of type t. this will return only one value.",
	"Method": "CommandElement enumValue(Text key,Class<T> type){\r\n    return new EnumValueElement(key, type);\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.InventoryDimension.not",
	"Comment": "create an inventorydimension property which matches inventorydimensionproperties with unequal value.",
	"Method": "InventoryDimension not(Object value){\r\n    return new InventoryDimension(value, Operator.NOTEQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.openweathermap.internal.utils.ByteArrayFileCache.remove",
	"Comment": "removes the file associated with the given key from the cache.",
	"Method": "void remove(String key){\r\n    deleteFile(getUniqueFile(key));\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.CommandContext.createSnapshot",
	"Comment": "gets a snapshot of the data inside this context to allow it to berestored later.this is only guaranteed to create a shallow copy of thebacking store. if any value is mutable, any changes to that valuewill be reflected in this snapshot. it is therefore not recommendedthat you keep this snapshot around for longer than is necessary.",
	"Method": "Snapshot createSnapshot(){\r\n    return new Snapshot(this.parsedArgs);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.dto.ConfigDescriptionDTOMapper.map",
	"Comment": "maps configuration description into configuration description dto object.",
	"Method": "ConfigDescriptionDTO map(ConfigDescription configDescription,List<ConfigDescriptionParameter> map,List<ConfigDescriptionParameterDTO> parameters){\r\n    if (parameters == null) {\r\n        return null;\r\n    }\r\n    final List<ConfigDescriptionParameter> result = new ArrayList(parameters.size());\r\n    for (ConfigDescriptionParameterDTO parameter : parameters) {\r\n        result.add(ConfigDescriptionParameterBuilder.create(parameter.name, parameter.type).withContext(parameter.context).withDefault(parameter.defaultValue).withDescription(parameter.description).withLabel(parameter.label).withRequired(parameter.required).withMinimum(parameter.min).withMaximum(parameter.max).withStepSize(parameter.stepsize).withPattern(parameter.pattern).withReadOnly(parameter.readOnly).withMultiple(parameter.multiple).withMultipleLimit(parameter.multipleLimit).withGroupName(parameter.groupName).withAdvanced(parameter.advanced).withVerify(parameter.verify).withLimitToOptions(parameter.limitToOptions).withUnit(parameter.unitLabel).withUnitLabel(parameter.unitLabel).withOptions(mapOptionsDTO(parameter.options)).withFilterCriteria(mapFilterCriteriaDTO(parameter.filterCriteria)).build());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.MqttBrokerConnection.subscribe",
	"Comment": "add a new message consumer to this connection. multiple subscribers with the sametopic are allowed. this method will not protect you from adding a subscriber objectmultiple times!if there is a retained message for the topic, you are guaranteed to receive a callbackfor each new subscriber, even for the same topic.",
	"Method": "CompletableFuture<Boolean> subscribe(String topic,MqttMessageSubscriber subscriber){\r\n    CompletableFuture<Boolean> future = new CompletableFuture<Boolean>();\r\n    synchronized (subscribers) {\r\n        TopicSubscribers subscriberList = subscribers.getOrDefault(topic, new TopicSubscribers(topic));\r\n        subscribers.put(topic, subscriberList);\r\n        subscriberList.add(subscriber);\r\n    }\r\n    final MqttAsyncClient client = this.client;\r\n    if (client == null) {\r\n        future.completeExceptionally(new Exception(\"No MQTT client\"));\r\n        return future;\r\n    }\r\n    if (client.isConnected()) {\r\n        try {\r\n            client.subscribe(topic, qos, future, actionCallback);\r\n        } catch (org.eclipse.paho.client.mqttv3.MqttException e) {\r\n            future.completeExceptionally(e);\r\n        }\r\n    } else {\r\n        future.complete(false);\r\n    }\r\n    return future;\r\n}"
}, {
	"Path": "org.spongepowered.api.service.permission.NodeTree.of",
	"Comment": "create a new node tree with the given values, and the specified rootfallback value.",
	"Method": "NodeTree of(Map<String, Boolean> values,NodeTree of,Map<String, Boolean> values,Tristate defaultValue){\r\n    NodeTree newTree = new NodeTree(defaultValue);\r\n    for (Map.Entry<String, Boolean> value : values.entrySet()) {\r\n        Iterable<String> parts = NODE_SPLITTER.split(value.getKey().toLowerCase());\r\n        Node currentNode = newTree.rootNode;\r\n        for (String part : parts) {\r\n            if (currentNode.children.containsKey(part)) {\r\n                currentNode = currentNode.children.get(part);\r\n            } else {\r\n                Node newNode = new Node(new HashMap());\r\n                currentNode.children.put(part, newNode);\r\n                currentNode = newNode;\r\n            }\r\n        }\r\n        currentNode.value = Tristate.fromBoolean(value.getValue());\r\n    }\r\n    return newTree;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.ConfigDescriptionParameter.getDescription",
	"Comment": "returns a human readable description for the configuration parameter.",
	"Method": "String getDescription(){\r\n    return this.description;\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.RpcCommandFactory.createServerException",
	"Comment": "create server exception using error msg and fill the stack trace using the stack trace of throwable.",
	"Method": "RpcServerException createServerException(String errMsg,RpcServerException createServerException,Throwable t,String errMsg){\r\n    String formattedErrMsg = String.format(\"[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s\", t.getClass().getName(), t.getMessage(), errMsg);\r\n    RpcServerException e = new RpcServerException(formattedErrMsg);\r\n    e.setStackTrace(t.getStackTrace());\r\n    return e;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.weatherunderground.internal.discovery.WeatherUndergroundDiscoveryService.activate",
	"Comment": "we override this method to allow a call from the thing handler factory",
	"Method": "void activate(Map<@NonNull String, @Nullable Object> configProperties){\r\n    super.activate(configProperties);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.CommandlineModuleTypeProvider.remove",
	"Comment": "this method is responsible for removing a set of objects loaded from a specified file or url resource.",
	"Method": "String remove(URL url){\r\n    List<String> portfolio = null;\r\n    synchronized (providerPortfolio) {\r\n        portfolio = providerPortfolio.remove(url);\r\n    }\r\n    if (portfolio != null && !portfolio.isEmpty()) {\r\n        synchronized (providedObjectsHolder) {\r\n            for (String uid : portfolio) {\r\n                notifyListeners(providedObjectsHolder.remove(uid));\r\n            }\r\n        }\r\n    }\r\n    return AutomationCommand.SUCCESS;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.providers.DsChannelTypeProvider.getItemType",
	"Comment": "returns the supported item type for the given channel type id or null, if the channel type does not exist.",
	"Method": "String getItemType(String channelTypeID){\r\n    if (channelTypeID != null) {\r\n        if (stringContains(channelTypeID, STAGE)) {\r\n            return STRING;\r\n        }\r\n        if (stringContains(channelTypeID, SWITCH) || stringContains(channelTypeID, SCENE) || stringContains(channelTypeID, WIPE) || stringContains(channelTypeID, BINARY_INPUT_PRE)) {\r\n            return SWITCH;\r\n        }\r\n        if (stringContains(channelTypeID, DIMMER) || stringContains(channelTypeID, ANGLE)) {\r\n            return DIMMER;\r\n        }\r\n        if (stringContains(channelTypeID, TEMPERATURE_CONTROLLED)) {\r\n            return NUMBER;\r\n        }\r\n        if (channelTypeID.contains(SHADE)) {\r\n            return ROLLERSHUTTER;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.core.internal.composite.CompositeModuleHandlerFactory.getTypes",
	"Comment": "it is system factory and must not be registered as service. this method is not used.",
	"Method": "Collection<String> getTypes(){\r\n    return new ArrayList();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.climate.jsonresponsecontainer.impl.WeatherSensorData.getWeatherConditionId",
	"Comment": "returns the weather condition id of the set weather service.",
	"Method": "String getWeatherConditionId(){\r\n    return weatherConditionId;\r\n}"
}, {
	"Path": "org.spongepowered.api.command.spec.CommandSpec.getExtendedDescription",
	"Comment": "gets the extended description used with this command if any is present.",
	"Method": "Optional<Text> getExtendedDescription(CommandSource source){\r\n    return this.extendedDescription;\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.CommandArgs.nextIfPresent",
	"Comment": "try to read the next argument, advancing the current index if successfulor returning an absent optional if not.",
	"Method": "Optional<String> nextIfPresent(){\r\n    return hasNext() ? Optional.of(this.args.get(++this.index).getValue()) : Optional.<String>empty();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.model.HmChannel.checkForChannelFunctionChange",
	"Comment": "checks whether the function this channel is configured to changed since this method was last invoked.returns false if the channel is not reconfigurable or was not initialized yet.",
	"Method": "boolean checkForChannelFunctionChange(){\r\n    Integer currentFunction = getCurrentFunction();\r\n    if (currentFunction == null) {\r\n        return false;\r\n    }\r\n    if (lastFunction == null) {\r\n        lastFunction = currentFunction;\r\n        return false;\r\n    }\r\n    if (lastFunction.equals(currentFunction)) {\r\n        return false;\r\n    }\r\n    lastFunction = currentFunction;\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bosesoundtouch.internal.CommandExecutor.updatePresetContainerFromPlayer",
	"Comment": "synchronizes the underlying storage container with the current value for the presets stored on the playerby updating the available ones and deleting the cleared ones",
	"Method": "void updatePresetContainerFromPlayer(Map<Integer, ContentItem> playerPresets){\r\n    playerPresets.forEach((k, v) -> {\r\n        try {\r\n            if (v != null) {\r\n                handler.getPresetContainer().put(k, v);\r\n            } else {\r\n                handler.getPresetContainer().remove(k);\r\n            }\r\n        } catch (ContentItemNotPresetableException e) {\r\n            logger.debug(\"{}: ContentItem is not presetable\", handler.getDeviceName());\r\n        }\r\n    });\r\n    handler.refreshPresetChannel();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bosesoundtouch.internal.ContentItem.getOperationMode",
	"Comment": "returns the operation mode, depending on the stats that are set",
	"Method": "OperationModeType getOperationMode(){\r\n    OperationModeType operationMode = OperationModeType.OTHER;\r\n    if (source == null || source.equals(\"\")) {\r\n        return OperationModeType.OTHER;\r\n    }\r\n    if (source.contains(\"PRODUCT\")) {\r\n        if (sourceAccount.contains(\"TV\")) {\r\n            operationMode = OperationModeType.TV;\r\n        }\r\n        if (sourceAccount.contains(\"HDMI\")) {\r\n            operationMode = OperationModeType.HDMI1;\r\n        }\r\n        return operationMode;\r\n    }\r\n    try {\r\n        operationMode = OperationModeType.valueOf(source);\r\n        return operationMode;\r\n    } catch (IllegalArgumentException iae) {\r\n        return OperationModeType.OTHER;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.lirc.internal.connector.LIRCConnector.startRemoteDiscovery",
	"Comment": "begins discovery of all remotes the lirc server knows about.",
	"Method": "void startRemoteDiscovery(){\r\n    sendCommand(\"LIST\");\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.MetadataUtils.getConfigDescriptionParameterType",
	"Comment": "returns the configdescriptionparameter type for the given datapoint.",
	"Method": "Type getConfigDescriptionParameterType(HmDatapoint dp){\r\n    if (dp.isBooleanType()) {\r\n        return Type.BOOLEAN;\r\n    } else if (dp.isIntegerType()) {\r\n        return Type.INTEGER;\r\n    } else if (dp.isFloatType()) {\r\n        return Type.DECIMAL;\r\n    } else {\r\n        return Type.TEXT;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.profiles.ProfileTypeBuilder.build",
	"Comment": "create a profile type instance with the previously given parameters.",
	"Method": "T build(){\r\n    return profileTypeFactory.create(profileTypeUID, label, supportedItemTypes, supportedItemTypesOfChannel, supportedChannelTypeUIDs);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.script.actions.ScriptExecutionTest.testRescheduleTimerAfterExecution",
	"Comment": "tests that a timer can be rescheduled after it has terminated",
	"Method": "void testRescheduleTimerAfterExecution(){\r\n    MockClosure0 closure = new MockClosure0();\r\n    Timer t = createTimer(closure);\r\n    assertThat(t.isRunning(), is(equalTo(false)));\r\n    assertThat(t.hasTerminated(), is(equalTo(false)));\r\n    assertThat(closure.getApplyCount(), is(equalTo(0)));\r\n    assertThat(scheduler.getPendingJobCount(), is(equalTo(1)));\r\n    scheduler.run();\r\n    assertThat(scheduler.getPendingJobCount(), is(equalTo(0)));\r\n    assertThat(closure.getApplyCount(), is(equalTo(1)));\r\n    assertThat(t.isRunning(), is(equalTo(false)));\r\n    assertThat(t.hasTerminated(), is(equalTo(true)));\r\n    boolean rescheduled = t.reschedule(now());\r\n    assertThat(rescheduled, is(equalTo(true)));\r\n    assertThat(t.hasTerminated(), is(equalTo(false)));\r\n    assertThat(scheduler.getPendingJobCount(), is(equalTo(1)));\r\n    scheduler.run();\r\n    assertThat(scheduler.getPendingJobCount(), is(equalTo(0)));\r\n    assertThat(closure.getApplyCount(), is(equalTo(2)));\r\n    assertThat(t.isRunning(), is(equalTo(false)));\r\n    assertThat(t.hasTerminated(), is(equalTo(true)));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.model.HmDatapointConfig.getReceiveDelay",
	"Comment": "returns the delay in seconds for receiving a new datapoint event.",
	"Method": "Double getReceiveDelay(){\r\n    return receiveDelay == null ? 0.0 : receiveDelay;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.core.internal.composite.AbstractCompositeModuleHandler.getChildContext",
	"Comment": "creates child context that will be passed to the child handler.",
	"Method": "Map<String, Object> getChildContext(Module child,Map<String, ?> compositeContext){\r\n    return ReferenceResolver.getCompositeChildContext(child, compositeContext);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.binding.BaseThingHandler.isModifyingCurrentConfig",
	"Comment": "checks whether a given list of parameters would mean any change to the existing thing configuration if applied toit.note that the passed parameters might be a subset of the existing configuration.",
	"Method": "boolean isModifyingCurrentConfig(Map<String, Object> configurationParameters){\r\n    Configuration currentConfig = getConfig();\r\n    for (Entry<String, Object> entry : configurationParameters.entrySet()) {\r\n        if (!Objects.equals(currentConfig.get(entry.getKey()), entry.getValue())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.manager.impl.TemperatureControlManager.isHeatingControllerInstallated",
	"Comment": "returns true, if the digitalstrom heating controller app is installed.",
	"Method": "boolean isHeatingControllerInstallated(ConnectionManager connectionManager){\r\n    return connectionManager.getDigitalSTROMAPI().propertyTreeGetChildren(connectionManager.getSessionToken(), GET_HEATING_HEATING_CONTROLLER_CHILDREN_PATH) != null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.util.ThingHandlerHelper.isHandlerInitialized",
	"Comment": "checks if the given state indicates that a thing handler has been initialized.",
	"Method": "boolean isHandlerInitialized(ThingStatus thingStatus,boolean isHandlerInitialized,Thing thing,boolean isHandlerInitialized,ThingHandler handler){\r\n    return isHandlerInitialized(handler.getThing());\r\n}"
}, {
	"Path": "ws.com.google.android.mms.pdu.PduHeaders.setEncodedStringValue",
	"Comment": "set encodedstringvalue value to pdu header by header field.",
	"Method": "void setEncodedStringValue(EncodedStringValue value,int field){\r\n    if (null == value) {\r\n        throw new NullPointerException();\r\n    }\r\n    switch(field) {\r\n        case SUBJECT:\r\n        case RECOMMENDED_RETRIEVAL_MODE_TEXT:\r\n        case RETRIEVE_TEXT:\r\n        case STATUS_TEXT:\r\n        case STORE_STATUS_TEXT:\r\n        case RESPONSE_TEXT:\r\n        case FROM:\r\n        case PREVIOUSLY_SENT_BY:\r\n        case MM_FLAGS:\r\n            break;\r\n        default:\r\n            throw new RuntimeException(\"Invalid header field!\");\r\n    }\r\n    mHeaderMap.put(field, value);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.virtual.AbstractVirtualDatapointHandler.addDatapoint",
	"Comment": "creates a new datapoint with the given parameters and adds it to the channel.",
	"Method": "HmDatapoint addDatapoint(HmDevice device,Integer channelNumber,String datapointName,HmValueType valueType,Object value,boolean readOnly,HmDatapoint addDatapoint,HmChannel channel,HmDatapoint dp){\r\n    logger.trace(\"Adding virtual datapoint '{}' to device '{}' ({}) and channel {}\", dp.getName(), channel.getDevice().getAddress(), channel.getDevice().getType(), channel.getNumber());\r\n    dp.setVirtual(true);\r\n    dp.setReadable(true);\r\n    channel.addDatapoint(dp);\r\n    return dp;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.internal.BlueGigaSerialHandler.notifyEventListeners",
	"Comment": "notify any transaction listeners when we receive a response.this uses a separate thread to separate the processing of the event.",
	"Method": "void notifyEventListeners(BlueGigaResponse response){\r\n    synchronized (this) {\r\n        for (final BlueGigaEventListener listener : eventListeners) {\r\n            executor.submit(() -> listener.bluegigaEventReceived(response));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.voice.text.TokenList.peekTail",
	"Comment": "retrieves the last token of the list, in case it is equal to one of the provided alternatives.",
	"Method": "String peekTail(String alternatives){\r\n    return peek(tail, alternatives);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.StateUpdate.setTransitionTime",
	"Comment": "set the transition time from the current state to the new state.time is accurate to 100 milliseconds.",
	"Method": "StateUpdate setTransitionTime(int timeMillis){\r\n    if (timeMillis < 0 || timeMillis > 6553600) {\r\n        throw new IllegalArgumentException(\"Transition time out of range\");\r\n    }\r\n    commands.add(new Command(\"transitiontime\", timeMillis / 100));\r\n    return this;\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.ArmorEquipable.setLeggings",
	"Comment": "sets the leggings currently being worn by this entity.having the leggings as null will result in having nothing equipped inthe leggings slot.",
	"Method": "void setLeggings(ItemStack leggings){\r\n    this.equip(EquipmentTypes.LEGGINGS, leggings);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.generic.ChannelState.setValue",
	"Comment": "publishes a value on mqtt. a command topic needs to be set in the configuration.",
	"Method": "CompletableFuture<@Nullable Void> setValue(Command command){\r\n    String mqttCommandValue = getValue().update(command);\r\n    final MqttBrokerConnection connection = this.connection;\r\n    if (!readOnly && connection != null) {\r\n        if (config.formatBeforePublish.length() > 0) {\r\n            try (Formatter formatter = new Formatter()) {\r\n                Formatter format = formatter.format(config.formatBeforePublish, mqttCommandValue);\r\n                mqttCommandValue = format.toString();\r\n            } catch (IllegalFormatException e) {\r\n                logger.debug(\"Format pattern incorrect for {}\", channelUID, e);\r\n            }\r\n        }\r\n        return connection.publish(config.commandTopic, mqttCommandValue.getBytes(), 1, config.retained).thenRun(() -> {\r\n        });\r\n    } else {\r\n        CompletableFuture<@Nullable Void> f = new CompletableFuture();\r\n        f.completeExceptionally(new IllegalStateException(\"No connection or readOnly channel!\"));\r\n        return f;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.config.Config.setSensordataConnectionTimeout",
	"Comment": "sets the connection timeout for sensor readings from devices.",
	"Method": "void setSensordataConnectionTimeout(int sensordataConnectionTimeout){\r\n    this.sensordataConnectionTimeout = sensordataConnectionTimeout;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.sample.extension.java.internal.WelcomeHomeCommands.activate",
	"Comment": "this method is used to schedule the execution of the provided rules. it gives ability to provide external data,that can affect the execution of the rules.",
	"Method": "void activate(String[] params,Console console){\r\n    if (params.length < 2) {\r\n        console.println(\"Missing required parameters\");\r\n        return;\r\n    }\r\n    if (params[0] != null && (params[0].equalsIgnoreCase(\"on\") || params[0].equalsIgnoreCase(\"off\"))) {\r\n        currentState = params[0];\r\n    } else {\r\n        console.println(\"Invalid parameter value of the parameter \\\"currentState\\\". Should be \\\"on\\\" or \\\"off\\\"\");\r\n        return;\r\n    }\r\n    try {\r\n        currentTemperature = new Integer(params[1]);\r\n    } catch (NumberFormatException e) {\r\n        console.println(\"Invalid parameter value of the parameter \\\"currentTemperature\\\". Should be number.\");\r\n        return;\r\n    }\r\n    Map<String, Object> context = new HashMap<String, Object>();\r\n    context.put(TemperatureConditionType.INPUT_CURRENT_TEMPERATURE, currentTemperature);\r\n    context.put(StateConditionType.INPUT_CURRENT_STATE, currentState);\r\n    WelcomeHomeTriggerHandler handler = handlerFactory.getTriggerHandler(WelcomeHomeRulesProvider.AC_UID);\r\n    if (handler != null) {\r\n        handler.trigger(context);\r\n    }\r\n    console.println(\"SUCCESS\");\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.core.provider.Vendor.count",
	"Comment": "this method increases the rules count and returns the current count.",
	"Method": "int count(){\r\n    return rulesCount++;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.climate.jsonresponsecontainer.impl.AssignedSensors.existSensorType",
	"Comment": "returns true, if the given sensortype exists at the zone, otherwise false.",
	"Method": "boolean existSensorType(SensorEnum sensorType){\r\n    return getAssignedSensorType(sensorType) != null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.net.http.HttpUtil.prepareProxyParams",
	"Comment": "load proxy parameters in global variables proxyhost, proxyport, proxyuser, proxypassword and nonproxyhosts",
	"Method": "ProxyParams prepareProxyParams(){\r\n    final ProxyParams proxyParams = new ProxyParams();\r\n    String proxySet = System.getProperty(\"http.proxySet\");\r\n    if (\"true\".equalsIgnoreCase(proxySet)) {\r\n        proxyParams.proxyHost = System.getProperty(\"http.proxyHost\");\r\n        String proxyPortString = System.getProperty(\"http.proxyPort\");\r\n        if (StringUtils.isNotBlank(proxyPortString)) {\r\n            try {\r\n                proxyParams.proxyPort = Integer.valueOf(proxyPortString);\r\n            } catch (NumberFormatException e) {\r\n                LOGGER.warn(\"'{}' is not a valid proxy port - using default port ({}) instead\", proxyPortString, proxyParams.proxyPort);\r\n            }\r\n        }\r\n        proxyParams.proxyUser = System.getProperty(\"http.proxyUser\");\r\n        proxyParams.proxyPassword = System.getProperty(\"http.proxyPassword\");\r\n        proxyParams.nonProxyHosts = System.getProperty(\"http.nonProxyHosts\");\r\n    }\r\n    return proxyParams;\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.timeout.ServerTimeoutSwitchTest.testOneway",
	"Comment": "the second request will not timeout in oneway process work queue",
	"Method": "void testOneway(){\r\n    for (int i = 0; i <= 1; ++i) {\r\n        new Thread() {\r\n            @Override\r\n            public void run() {\r\n                oneway(client, null);\r\n            }\r\n        }.start();\r\n    }\r\n    try {\r\n        Thread.sleep(max_timeout * 2);\r\n    } catch (InterruptedException e) {\r\n        logger.error(\"\", e);\r\n    }\r\n    Assert.assertEquals(2, serverUserProcessor.getInvokeTimesEachCallType(RequestBody.InvokeType.ONEWAY));\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.timeout.ServerTimeoutSwitchTest.testOneway",
	"Comment": "the second request will not timeout in oneway process work queue",
	"Method": "void testOneway(){\r\n    oneway(client, null);\r\n}"
}, {
	"Path": "co.aikar.timings.Timings.getHistoryLength",
	"Comment": "gets how long in ticks timings history is kept for the server.",
	"Method": "int getHistoryLength(){\r\n    return factory.getHistoryLength();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.internal.command.attributedb.BlueGigaSendAttributesCommand.setConnection",
	"Comment": "connection handle to send to. use 0xff to send to all connected clients which have subscribedto receive the notifications or indications. an error is returned as soon as the first failedtransmission occurs.",
	"Method": "void setConnection(int connection){\r\n    this.connection = connection;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.HueBridge.setGroupAttributes",
	"Comment": "changes the name and the lights of a group and returns the new name.",
	"Method": "String setGroupAttributes(Group group,String name,List<HueObject> lights){\r\n    requireAuthentication();\r\n    if (!group.isModifiable()) {\r\n        throw new IllegalArgumentException(\"Group cannot be modified\");\r\n    }\r\n    String body = gson.toJson(new SetAttributesRequest(name, lights));\r\n    Result result = http.put(getRelativeURL(\"groups/\" + enc(group.getId())), body);\r\n    handleErrors(result);\r\n    List<SuccessResponse> entries = safeFromJson(result.getBody(), SuccessResponse.GSON_TYPE);\r\n    SuccessResponse response = entries.get(0);\r\n    return (String) response.success.get(\"/groups/\" + enc(group.getId()) + \"/name\");\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.semantics.internal.SemanticsMetadataProvider.processProperties",
	"Comment": "processes property tags on items and if found, adds it to the metadata configuration.",
	"Method": "void processProperties(Item item,Map<String, Object> configuration){\r\n    Class<? extends Tag> type = SemanticTags.getSemanticType(item);\r\n    for (Entry<List<Class<? extends Tag>>, String> relation : propertyRelations.entrySet()) {\r\n        Class<? extends Tag> entityClass = relation.getKey().get(0);\r\n        if (entityClass.isAssignableFrom(type)) {\r\n            Class<? extends Property> p = SemanticTags.getProperty(item);\r\n            if (p != null) {\r\n                configuration.put(relation.getValue(), p.getAnnotation(TagInfo.class).id());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.weatherunderground.internal.json.WeatherUndergroundJsonUtils.convertToInteger",
	"Comment": "convert a string representing an integer value into an integer object",
	"Method": "Integer convertToInteger(String value){\r\n    Integer result = null;\r\n    if (isValid(value)) {\r\n        try {\r\n            result = Integer.valueOf(value.trim());\r\n        } catch (NumberFormatException e) {\r\n            LoggerFactory.getLogger(WeatherUndergroundJsonUtils.class).debug(\"Cannot convert {} to Integer\", value);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.model.HmChannel.getCurrentFunction",
	"Comment": "returns the numeric value of the function this channel is currently configured to.returns null if the channel is not yet initialized or does not support dynamic reconfiguration.",
	"Method": "Integer getCurrentFunction(){\r\n    HmDatapoint functionDp = getDatapoint(HmParamsetType.MASTER, HomematicConstants.DATAPOINT_NAME_CHANNEL_FUNCTION);\r\n    return functionDp == null ? null : (Integer) functionDp.getValue();\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.ArgumentParseException.getPosition",
	"Comment": "gets the position of the last fetched argument in the provided sourcestring.",
	"Method": "int getPosition(){\r\n    return this.position;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.MqttBrokerConnection.start",
	"Comment": "this will establish a connection to the mqtt broker and if successful, notify allpublishers and subscribers that the connection has become active. this method willdo nothing if there is already an active connection.",
	"Method": "CompletableFuture<Boolean> start(){\r\n    synchronized (this) {\r\n        if (connectionState() != MqttConnectionState.DISCONNECTED) {\r\n            return CompletableFuture.completedFuture(true);\r\n        }\r\n        isConnecting = true;\r\n        connectionObservers.forEach(o -> o.connectionStateChanged(MqttConnectionState.CONNECTING, null));\r\n    }\r\n    if (reconnectStrategy != null) {\r\n        reconnectStrategy.start();\r\n    }\r\n    if (client != null) {\r\n        try {\r\n            client.close();\r\n        } catch (org.eclipse.paho.client.mqttv3.MqttException ignore) {\r\n        }\r\n        client = null;\r\n    }\r\n    CompletableFuture<Boolean> future = connectionCallback.createFuture();\r\n    StringBuilder serverURI = new StringBuilder();\r\n    switch(protocol) {\r\n        case TCP:\r\n            serverURI.append(secure ? \"ssl://\" : \"tcp://\");\r\n            break;\r\n        case WEBSOCKETS:\r\n            serverURI.append(secure ? \"wss://\" : \"ws://\");\r\n            break;\r\n        default:\r\n            future.completeExceptionally(new ConfigurationException(\"protocol\", \"Protocol unknown\"));\r\n            return future;\r\n    }\r\n    serverURI.append(host);\r\n    serverURI.append(\":\");\r\n    serverURI.append(port);\r\n    Path persistencePath = this.persistencePath;\r\n    if (persistencePath == null) {\r\n        persistencePath = Paths.get(ConfigConstants.getUserDataFolder()).resolve(\"mqtt\").resolve(host);\r\n    }\r\n    try {\r\n        persistencePath = Files.createDirectories(persistencePath);\r\n    } catch (IOException e) {\r\n        future.completeExceptionally(new MqttException(e));\r\n        return future;\r\n    }\r\n    MqttDefaultFilePersistence _dataStore = new MqttDefaultFilePersistence(persistencePath.toString());\r\n    MqttAsyncClient _client;\r\n    try {\r\n        _client = createClient(serverURI.toString(), clientId, _dataStore);\r\n    } catch (org.eclipse.paho.client.mqttv3.MqttException e) {\r\n        future.completeExceptionally(new MqttException(e));\r\n        return future;\r\n    }\r\n    this.client = _client;\r\n    this.dataStore = _dataStore;\r\n    _client.setCallback(clientCallback);\r\n    try {\r\n        _client.connect(createMqttOptions(), null, connectionCallback);\r\n        logger.info(\"Starting MQTT broker connection to '{}' with clientid {} and file store '{}'\", host, getClientId(), persistencePath);\r\n    } catch (org.eclipse.paho.client.mqttv3.MqttException | ConfigurationException e) {\r\n        future.completeExceptionally(new MqttException(e));\r\n        return future;\r\n    }\r\n    ScheduledExecutorService executor = timeoutExecutor;\r\n    if (executor != null) {\r\n        final ScheduledFuture<?> timeoutFuture = this.timeoutFuture.getAndSet(executor.schedule(() -> connectionCallback.onFailure(null, new TimeoutException()), timeout, TimeUnit.MILLISECONDS));\r\n        if (timeoutFuture != null) {\r\n            timeoutFuture.cancel(false);\r\n        }\r\n    }\r\n    return future;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.internal.BlueGigaSerialHandler.notifyClosed",
	"Comment": "notify handler event listeners that the handler was bluegigaclosed due to an error specified as an argument.",
	"Method": "void notifyClosed(Exception reason){\r\n    for (BlueGigaHandlerListener listener : handlerListeners) {\r\n        try {\r\n            listener.bluegigaClosed(reason);\r\n        } catch (Exception ex) {\r\n            logger.warn(\"Execution error of a BlueGigaHandlerListener listener.\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.model.HmChannel.removeValueDatapoints",
	"Comment": "removes all datapoints with values param set type from the channel.",
	"Method": "void removeValueDatapoints(){\r\n    synchronized (datapoints) {\r\n        Iterator<Map.Entry<HmDatapointInfo, HmDatapoint>> iterator = datapoints.entrySet().iterator();\r\n        while (iterator.hasNext()) {\r\n            if (iterator.next().getKey().getParamsetType() == HmParamsetType.VALUES) {\r\n                iterator.remove();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bosesoundtouch.internal.discovery.DiscoveryUtil.getContentOfFirstElement",
	"Comment": "finds the content in an elementthis is a quick and dirty method, it always delivers the first appearance of content in an element",
	"Method": "String getContentOfFirstElement(String content,String element){\r\n    if (content == null) {\r\n        return \"\";\r\n    }\r\n    String beginTag = \"<\" + element + \">\";\r\n    String endTag = \"<\/\" + element + \">\";\r\n    int startIndex = content.indexOf(beginTag) + beginTag.length();\r\n    int endIndex = content.indexOf(endTag);\r\n    if (startIndex != -1 && endIndex != -1) {\r\n        return content.substring(startIndex, endIndex);\r\n    } else {\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.module.script.internal.handler.AbstractScriptModuleHandler.setExecutionContext",
	"Comment": "adds the passed context variables of the rule engine to the context scope of the scriptengine, this should beupdated each time the module is executed",
	"Method": "void setExecutionContext(ScriptEngine engine,Map<String, ?> context){\r\n    ScriptContext executionContext = engine.getContext();\r\n    final Map<String, Object> contextNew = new HashMap(context);\r\n    contextNew.put(\"ruleUID\", this.ruleUID);\r\n    executionContext.setAttribute(\"ctx\", contextNew, ScriptContext.ENGINE_SCOPE);\r\n    executionContext.setAttribute(\"ruleUID\", this.ruleUID, ScriptContext.ENGINE_SCOPE);\r\n    for (Entry<String, ?> entry : context.entrySet()) {\r\n        Object value = entry.getValue();\r\n        String key = entry.getKey();\r\n        int dotIndex = key.indexOf('.');\r\n        if (dotIndex != -1) {\r\n            key = key.substring(dotIndex + 1);\r\n        }\r\n        executionContext.setAttribute(key, value, ScriptContext.ENGINE_SCOPE);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.common.HomematicConfig.setDiscoveryTimeToLive",
	"Comment": "sets the time to live for discovery results of a homematic gateway in seconds.",
	"Method": "void setDiscoveryTimeToLive(long discoveryTimeToLive){\r\n    this.discoveryTimeToLive = discoveryTimeToLive;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.client.RpcClient.getAllSystemVariables",
	"Comment": "returns all variable metadata and values from a homegear gateway.",
	"Method": "void getAllSystemVariables(HmChannel channel){\r\n    RpcRequest<T> request = createRpcRequest(\"getAllSystemVariables\");\r\n    new GetAllSystemVariablesParser(channel).parse(sendMessage(config.getRpcPort(channel), request));\r\n}"
}, {
	"Path": "org.spongepowered.api.data.DataQuery.getQueryParts",
	"Comment": "returns the parts of this query as individual queries. the returned listis immutable.",
	"Method": "List<DataQuery> getQueryParts(){\r\n    if (this.queryParts == null) {\r\n        ImmutableList.Builder<DataQuery> builder = ImmutableList.builder();\r\n        for (String part : getParts()) {\r\n            builder.add(new DataQuery(part));\r\n        }\r\n        this.queryParts = builder.build();\r\n    }\r\n    return this.queryParts;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.HueBridge.link",
	"Comment": "link with bridge using the specified device type. a random valid username will be generated by the bridge andreturned.",
	"Method": "void link(String username,String devicetype,String link,String devicetype,String link,CreateUserRequest request){\r\n    if (this.username != null) {\r\n        throw new IllegalStateException(\"already linked\");\r\n    }\r\n    String body = gson.toJson(request);\r\n    Result result = http.post(getRelativeURL(\"\"), body);\r\n    handleErrors(result);\r\n    List<SuccessResponse> entries = safeFromJson(result.getBody(), SuccessResponse.GSON_TYPE);\r\n    SuccessResponse response = entries.get(0);\r\n    return (String) response.success.get(\"username\");\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.core.internal.ConnectionValidator.checkCompatibility",
	"Comment": "checks the compatibility of data types of the input and connected output. throwsexception if they are incompatible.",
	"Method": "void checkCompatibility(String msg,Connection connection,Input input,List<Output> outputs){\r\n    if (connection.getReference() != null) {\r\n        return;\r\n    }\r\n    String outputName = connection.getOutputName();\r\n    if (outputs != null && !outputs.isEmpty()) {\r\n        for (Output output : outputs) {\r\n            if (output.getName().equals(outputName)) {\r\n                if (input.getType().equals(\"*\")) {\r\n                    return;\r\n                } else {\r\n                    try {\r\n                        Class<?> outputType = Class.forName(output.getType());\r\n                        Class<?> inputType = Class.forName(input.getType());\r\n                        if (inputType.isAssignableFrom(outputType)) {\r\n                            return;\r\n                        } else {\r\n                            throw new IllegalArgumentException(msg + \" Incompatible types : \\\"\" + output.getType() + \"\\\" and \\\"\" + input.getType() + \"\\\".\");\r\n                        }\r\n                    } catch (ClassNotFoundException e) {\r\n                        if (output.getType().equals(input.getType())) {\r\n                            return;\r\n                        } else {\r\n                            throw new IllegalArgumentException(msg + \" Incompatible types : \\\"\" + output.getType() + \"\\\" and \\\"\" + input.getType() + \"\\\".\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(msg + \" Output with name \\\"\" + outputName + \"\\\" not exists in the ModuleImpl with ID \\\"\" + connection.getOutputModuleId() + \"\\\"\");\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.core.internal.ruleengine.WrappedModule.getModuleHandler",
	"Comment": "this method gets handler which is responsible for handling of this module.",
	"Method": "H getModuleHandler(){\r\n    return handler;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.ConfigDescriptionParameterBuilder.withMultiple",
	"Comment": "set the configuration parameter to allow multiple selection",
	"Method": "ConfigDescriptionParameterBuilder withMultiple(Boolean multiple){\r\n    this.multiple = multiple;\r\n    return this;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.MetadataUtils.generateOptions",
	"Comment": "creates channel and config description metadata options for the given datapoint.",
	"Method": "List<T> generateOptions(HmDatapoint dp,OptionsBuilder<T> optionsBuilder){\r\n    List<T> options = null;\r\n    if (dp.getOptions() == null) {\r\n        logger.warn(\"No options for ENUM datapoint {}\", dp);\r\n    } else {\r\n        options = new ArrayList<T>();\r\n        for (int i = 0; i < dp.getOptions().length; i++) {\r\n            String description = null;\r\n            if (!dp.isVariable() && !dp.isScript()) {\r\n                description = getDescription(dp.getChannel().getType(), dp.getName(), dp.getOptions()[i]);\r\n            }\r\n            if (description == null) {\r\n                description = dp.getOptions()[i];\r\n            }\r\n            options.add(optionsBuilder.createOption(dp.getOptions()[i], description));\r\n        }\r\n    }\r\n    return options;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.internal.validation.ConfigDescriptionParameterValidatorFactory.createRequiredValidator",
	"Comment": "returns a new validator for the required attribute of a config description parameter.",
	"Method": "ConfigDescriptionParameterValidator createRequiredValidator(){\r\n    return new RequiredValidator();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.structure.scene.SceneDiscovery.generateAllScenes",
	"Comment": "generates all named, reachable group, apartment and zone scenes.",
	"Method": "void generateAllScenes(ConnectionManager connectionManager,StructureManager structureManager){\r\n    generateNamedScenes(connectionManager);\r\n    generateApartmentScence();\r\n    generateZoneScenes(connectionManager, structureManager);\r\n    generateReachableScenes(connectionManager, structureManager);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.sample.java.demo.internal.SampleJavaDemo.activate",
	"Comment": "called from ds when all of the required services are available.",
	"Method": "void activate(ComponentContext componentContext){\r\n    addRule();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.MqttBrokerConnection.setCredentials",
	"Comment": "set the optional user name and optional password to use when connecting to the mqtt broker.the connection needs to be restarted for the new settings to take effect.",
	"Method": "void setCredentials(String user,String password){\r\n    this.user = user;\r\n    this.password = password;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.historicState",
	"Comment": "retrieves the historic item for a given item at a certain point in time through the defaultpersistence service.",
	"Method": "HistoricItem historicState(Item item,AbstractInstant timestamp,HistoricItem historicState,Item item,AbstractInstant timestamp,String serviceId){\r\n    PersistenceService service = getService(serviceId);\r\n    if (service instanceof QueryablePersistenceService) {\r\n        QueryablePersistenceService qService = (QueryablePersistenceService) service;\r\n        FilterCriteria filter = new FilterCriteria();\r\n        filter.setEndDate(ZonedDateTime.ofInstant(timestamp.toDate().toInstant(), timeZoneProvider.getTimeZone()));\r\n        filter.setItemName(item.getName());\r\n        filter.setPageSize(1);\r\n        filter.setOrdering(Ordering.DESCENDING);\r\n        Iterable<HistoricItem> result = qService.query(filter);\r\n        if (result.iterator().hasNext()) {\r\n            return result.iterator().next();\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        LoggerFactory.getLogger(PersistenceExtensions.class).warn(\"There is no queryable persistence service registered with the id '{}'\", serviceId);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.transaction.InventoryTransactionResult.getReplacedItems",
	"Comment": "if the operation replaced items in the inventory, this collection returnsthe itemstacks which were replaced.",
	"Method": "Collection<ItemStackSnapshot> getReplacedItems(){\r\n    return this.replaced;\r\n}"
}, {
	"Path": "org.spongepowered.api.command.source.CommandBlockSource.doesTrackOutput",
	"Comment": "gets whether this command block will keep track of the output from thelast command it executed.",
	"Method": "Value<Boolean> doesTrackOutput(){\r\n    return getValue(Keys.TRACKS_OUTPUT).get();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.binding.BaseThingHandler.updateProperties",
	"Comment": "informs the framework, that the given properties map of the thing was updated. this method performs a check, ifthe properties were updated. if the properties did not change, the framework is not informed about changes.",
	"Method": "void updateProperties(Map<String, String> properties){\r\n    boolean propertiesUpdated = false;\r\n    for (Entry<String, String> property : properties.entrySet()) {\r\n        String propertyName = property.getKey();\r\n        String propertyValue = property.getValue();\r\n        String existingPropertyValue = thing.getProperties().get(propertyName);\r\n        if (existingPropertyValue == null || !existingPropertyValue.equals(propertyValue)) {\r\n            this.thing.setProperty(propertyName, propertyValue);\r\n            propertiesUpdated = true;\r\n        }\r\n    }\r\n    if (propertiesUpdated) {\r\n        synchronized (this) {\r\n            if (this.callback != null) {\r\n                this.callback.thingUpdated(thing);\r\n            } else {\r\n                logger.warn(\"Handler {} tried updating its thing's properties although the handler was already disposed.\", this.getClass().getSimpleName());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.maximumSince",
	"Comment": "gets the historic item with the maximum value of the state of a given item sincea certain point in time. the default persistence service is used.",
	"Method": "HistoricItem maximumSince(Item item,AbstractInstant timestamp,HistoricItem maximumSince,Item item,AbstractInstant timestamp,String serviceId){\r\n    Iterable<HistoricItem> result = getAllStatesSince(item, timestamp, serviceId);\r\n    Iterator<HistoricItem> it = result.iterator();\r\n    HistoricItem maximumHistoricItem = null;\r\n    DecimalType maximum = item.getStateAs(DecimalType.class);\r\n    while (it.hasNext()) {\r\n        HistoricItem historicItem = it.next();\r\n        State state = historicItem.getState();\r\n        if (state instanceof DecimalType) {\r\n            DecimalType value = (DecimalType) state;\r\n            if (maximum == null || value.compareTo(maximum) > 0) {\r\n                maximum = value;\r\n                maximumHistoricItem = historicItem;\r\n            }\r\n        }\r\n    }\r\n    if (maximumHistoricItem == null && maximum != null) {\r\n        final DecimalType state = maximum;\r\n        return new HistoricItem() {\r\n            @Override\r\n            public Date getTimestamp() {\r\n                return Calendar.getInstance().getTime();\r\n            }\r\n            @Override\r\n            public State getState() {\r\n                return state;\r\n            }\r\n            @Override\r\n            public String getName() {\r\n                return item.getName();\r\n            }\r\n        };\r\n    } else {\r\n        return maximumHistoricItem;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.maximumSince",
	"Comment": "gets the historic item with the maximum value of the state of a given item sincea certain point in time. the default persistence service is used.",
	"Method": "HistoricItem maximumSince(Item item,AbstractInstant timestamp,HistoricItem maximumSince,Item item,AbstractInstant timestamp,String serviceId){\r\n    return Calendar.getInstance().getTime();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.maximumSince",
	"Comment": "gets the historic item with the maximum value of the state of a given item sincea certain point in time. the default persistence service is used.",
	"Method": "HistoricItem maximumSince(Item item,AbstractInstant timestamp,HistoricItem maximumSince,Item item,AbstractInstant timestamp,String serviceId){\r\n    return state;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.maximumSince",
	"Comment": "gets the historic item with the maximum value of the state of a given item sincea certain point in time. the default persistence service is used.",
	"Method": "HistoricItem maximumSince(Item item,AbstractInstant timestamp,HistoricItem maximumSince,Item item,AbstractInstant timestamp,String serviceId){\r\n    return item.getName();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.fsinternetradio.test.FSInternetRadioHandlerJavaTest.offlineIfParseError",
	"Comment": "verify offline thing status when the http response cannot be parsed correctly.",
	"Method": "void offlineIfParseError(){\r\n    String modeChannelID = FSInternetRadioBindingConstants.CHANNEL_MODE;\r\n    String acceptedItemType = acceptedItemTypes.get(modeChannelID);\r\n    createChannel(DEFAULT_THING_UID, modeChannelID, acceptedItemType);\r\n    Thing radioThing = initializeRadioThing(DEFAULT_COMPLETE_CONFIGURATION);\r\n    testRadioThingConsideringConfiguration(radioThing);\r\n    ChannelUID modeChannelUID = getChannelUID(radioThing, modeChannelID);\r\n    radioServiceDummy.setInvalidResponse(true);\r\n    radioHandler.handleCommand(modeChannelUID, DecimalType.valueOf(\"1\"));\r\n    waitForAssert(() -> {\r\n        String exceptionMessage = \"java.io.IOException: org.xml.sax.SAXParseException; lineNumber: 1; columnNumber: 2;\";\r\n        verifyCommunicationError(exceptionMessage);\r\n    });\r\n    radioServiceDummy.setInvalidResponse(false);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.internal.calc.MoonCalc.prepareCoordinate",
	"Comment": "prepares the coordinate for moonrise and moonset calculation.",
	"Method": "double prepareCoordinate(double coordinate,double system){\r\n    double c = Math.abs(coordinate);\r\n    if (c - Math.floor(c) >= .599) {\r\n        c = Math.floor(c) + (c - Math.floor(c)) / 1 * .6;\r\n    }\r\n    if (c > system) {\r\n        c = Math.floor(c) % system + (c - Math.floor(c));\r\n    }\r\n    return Math.round(c * 100.0) / 100.0;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.structure.scene.InternalScene.deactivateSceneByDevice",
	"Comment": "will be called by a device, if an call of an other scene deactivated this scene.",
	"Method": "void deactivateSceneByDevice(){\r\n    if (active) {\r\n        this.active = false;\r\n        deviceHasChanged = false;\r\n        informListener();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.handler.HueBridgeHandler.notifyLightStatusListeners",
	"Comment": "iterate through lightstatuslisteners and notify them about a changed or added light state.",
	"Method": "void notifyLightStatusListeners(FullLight fullLight,String type){\r\n    if (lightStatusListeners.isEmpty()) {\r\n        logger.debug(\"No light status listeners to notify of light change for light '{}'\", fullLight.getId());\r\n        return;\r\n    }\r\n    for (LightStatusListener lightStatusListener : lightStatusListeners) {\r\n        try {\r\n            switch(type) {\r\n                case STATE_ADDED:\r\n                    logger.debug(\"Sending lightAdded for light '{}'\", fullLight.getId());\r\n                    lightStatusListener.onLightAdded(hueBridge, fullLight);\r\n                    break;\r\n                case STATE_CHANGED:\r\n                    logger.debug(\"Sending lightStateChanged for light '{}'\", fullLight.getId());\r\n                    lightStatusListener.onLightStateChanged(hueBridge, fullLight);\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException(\"Could not notify lightStatusListeners for unknown event type \" + type);\r\n            }\r\n        } catch (Exception e) {\r\n            logger.error(\"An exception occurred while calling the BridgeHeartbeatListener\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.tools.DelayedBatchProcessing.join",
	"Comment": "return the so far accumulated objects, but do not deliver them to the target consumer anymore.",
	"Method": "List<TYPE> join(){\r\n    ScheduledFuture<?> scheduledFuture = this.future;\r\n    if (scheduledFuture != null && !scheduledFuture.isDone()) {\r\n        scheduledFuture.cancel(false);\r\n    }\r\n    List<TYPE> lqueue = new ArrayList();\r\n    synchronized (queue) {\r\n        lqueue.addAll(queue);\r\n        queue.clear();\r\n    }\r\n    return lqueue;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.MetadataUtils.loadStandardDatapoints",
	"Comment": "loads the standard datapoints for channel metadata generation.",
	"Method": "void loadStandardDatapoints(){\r\n    Bundle bundle = FrameworkUtil.getBundle(MetadataUtils.class);\r\n    try (InputStream stream = bundle.getResource(\"homematic/standard-datapoints.properties\").openStream();\r\n        BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {\r\n        String line;\r\n        while ((line = reader.readLine()) != null) {\r\n            if (StringUtils.trimToNull(line) != null && !StringUtils.startsWith(line, \"#\")) {\r\n                String channelType = StringUtils.trimToNull(StringUtils.substringBefore(line, \"|\"));\r\n                String datapointName = StringUtils.trimToNull(StringUtils.substringAfter(line, \"|\"));\r\n                Set<String> channelDatapoints = standardDatapoints.get(channelType);\r\n                if (channelDatapoints == null) {\r\n                    channelDatapoints = new HashSet<String>();\r\n                    standardDatapoints.put(channelType, channelDatapoints);\r\n                }\r\n                channelDatapoints.add(datapointName);\r\n            }\r\n        }\r\n    } catch (IllegalStateException | IOException e) {\r\n        logger.warn(\"Can't load standard-datapoints.properties file!\", e);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.handler.ThingChannelConstants.cb",
	"Comment": "create a channel with exact the parameters we need for the tests",
	"Method": "Channel cb(String id,String acceptedType,Configuration config,ChannelTypeUID channelTypeUID){\r\n    return ChannelBuilder.create(new ChannelUID(testGenericThing, id), acceptedType).withConfiguration(config).withType(channelTypeUID).build();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.persistence.dto.ItemHistoryDTO.addData",
	"Comment": "add a new record to the data history.this method returns a double value equal to the state. this may be used for comparison by the caller.",
	"Method": "void addData(Long time,State state){\r\n    HistoryDataBean newVal = new HistoryDataBean();\r\n    newVal.time = time;\r\n    newVal.state = state.toString();\r\n    data.add(newVal);\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.RpcResponseResolver.toResponseObject",
	"Comment": "convert remoting response command to application response object.",
	"Method": "Object toResponseObject(ResponseCommand responseCommand){\r\n    RpcResponseCommand response = (RpcResponseCommand) responseCommand;\r\n    response.deserialize();\r\n    return response.getResponseObject();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.transform.actions.Transformation.transform",
	"Comment": "applies a transformation of a given type with some function to a value.",
	"Method": "String transform(String type,String function,String value){\r\n    Logger logger = LoggerFactory.getLogger(Transformation.class);\r\n    String result;\r\n    try {\r\n        result = trans(type, function, value);\r\n    } catch (TransformationException e) {\r\n        logger.debug(\"Error executing the transformation '{}': {}\", type, e.getMessage());\r\n        result = value;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.voice.text.TokenList.peekHead",
	"Comment": "retrieves the first token of the list, in case it is equal to one of the provided alternatives.",
	"Method": "String peekHead(String alternatives){\r\n    return peek(head, alternatives);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.event.EventListener.addSubscribe",
	"Comment": "adds a event and subscribed it, if it is not subscribed already.",
	"Method": "void addSubscribe(String subscribeEvent){\r\n    if (!subscribedEvents.contains(subscribeEvent)) {\r\n        subscribedEvents.add(subscribeEvent);\r\n        logger.debug(\"subscibeEvent: {} added\", subscribeEvent);\r\n        if (subscribed) {\r\n            subscribe(subscribeEvent);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.discovery.usbserial.linuxsysfs.internal.SysfsUsbSerialScanner.getUsbInterfaceParentPath",
	"Comment": "walks up the directory structure of a path in the sysfs, trying to find a directory that represents an interfaceof a usb device.",
	"Method": "Path getUsbInterfaceParentPath(Path sysfsPath){\r\n    if (sysfsPath.getFileName() == null) {\r\n        return null;\r\n    } else if (SYSFS_USB_INTERFACE_DIRECTORY_PATTERN.matcher(sysfsPath.getFileName().toString()).matches()) {\r\n        return sysfsPath;\r\n    } else {\r\n        Path parentPath = sysfsPath.getParent();\r\n        if (parentPath == null) {\r\n            return null;\r\n        } else {\r\n            return getUsbInterfaceParentPath(parentPath);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.common.ThreadPoolManager.getScheduledPool",
	"Comment": "returns an instance of a scheduled thread pool service. if it is the first request for the given pool name, theinstance is newly created.",
	"Method": "ScheduledExecutorService getScheduledPool(String poolName){\r\n    ExecutorService pool = pools.get(poolName);\r\n    if (pool == null) {\r\n        synchronized (pools) {\r\n            pool = pools.get(poolName);\r\n            if (pool == null) {\r\n                int cfg = getConfig(poolName);\r\n                pool = new WrappedScheduledExecutorService(cfg, new NamedThreadFactory(poolName));\r\n                ((ThreadPoolExecutor) pool).setKeepAliveTime(THREAD_TIMEOUT, TimeUnit.SECONDS);\r\n                ((ThreadPoolExecutor) pool).allowCoreThreadTimeOut(true);\r\n                ((ScheduledThreadPoolExecutor) pool).setRemoveOnCancelPolicy(true);\r\n                pools.put(poolName, pool);\r\n                LOGGER.debug(\"Created scheduled thread pool '{}' of size {}\", new Object[] { poolName, cfg });\r\n            }\r\n        }\r\n    }\r\n    if (pool instanceof ScheduledExecutorService) {\r\n        return (ScheduledExecutorService) pool;\r\n    } else {\r\n        throw new IllegalArgumentException(\"Pool \" + poolName + \" is not a scheduled pool!\");\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.openweathermap.internal.handler.OpenWeatherMapWeatherAndForecastHandler.updateDailyForecastChannel",
	"Comment": "update the channel from the last openweathermap data retrieved.",
	"Method": "void updateDailyForecastChannel(ChannelUID channelUID,int count){\r\n    String channelId = channelUID.getIdWithoutGroup();\r\n    String channelGroupId = channelUID.getGroupId();\r\n    if (dailyForecastData != null && dailyForecastData.getList().size() > count) {\r\n        org.eclipse.smarthome.binding.openweathermap.internal.model.forecast.daily.List forecastData = dailyForecastData.getList().get(count);\r\n        State state = UnDefType.UNDEF;\r\n        switch(channelId) {\r\n            case CHANNEL_TIME_STAMP:\r\n                state = getDateTimeTypeState(forecastData.getDt());\r\n                break;\r\n            case CHANNEL_CONDITION:\r\n                state = getStringTypeState(forecastData.getWeather().get(0).getDescription());\r\n                break;\r\n            case CHANNEL_CONDITION_ID:\r\n                state = getStringTypeState(forecastData.getWeather().get(0).getId().toString());\r\n                break;\r\n            case CHANNEL_CONDITION_ICON:\r\n                state = getRawTypeState(OpenWeatherMapConnection.getWeatherIcon(forecastData.getWeather().get(0).getIcon()));\r\n                break;\r\n            case CHANNEL_MIN_TEMPERATURE:\r\n                state = getQuantityTypeState(forecastData.getTemp().getMin(), CELSIUS);\r\n                break;\r\n            case CHANNEL_MAX_TEMPERATURE:\r\n                state = getQuantityTypeState(forecastData.getTemp().getMax(), CELSIUS);\r\n                break;\r\n            case CHANNEL_PRESSURE:\r\n                state = getQuantityTypeState(forecastData.getPressure(), HECTO(PASCAL));\r\n                break;\r\n            case CHANNEL_HUMIDITY:\r\n                state = getQuantityTypeState(forecastData.getHumidity(), SmartHomeUnits.PERCENT);\r\n                break;\r\n            case CHANNEL_WIND_SPEED:\r\n                state = getQuantityTypeState(forecastData.getSpeed(), SmartHomeUnits.METRE_PER_SECOND);\r\n                break;\r\n            case CHANNEL_WIND_DIRECTION:\r\n                state = getQuantityTypeState(forecastData.getDeg(), SmartHomeUnits.DEGREE_ANGLE);\r\n                break;\r\n            case CHANNEL_GUST_SPEED:\r\n                state = getQuantityTypeState(forecastData.getGust(), SmartHomeUnits.METRE_PER_SECOND);\r\n                break;\r\n            case CHANNEL_CLOUDINESS:\r\n                state = getQuantityTypeState(forecastData.getClouds(), SmartHomeUnits.PERCENT);\r\n                break;\r\n            case CHANNEL_RAIN:\r\n                state = getQuantityTypeState(forecastData.getRain() == null ? 0 : forecastData.getRain(), MILLI(METRE));\r\n                break;\r\n            case CHANNEL_SNOW:\r\n                state = getQuantityTypeState(forecastData.getSnow() == null ? 0 : forecastData.getSnow(), MILLI(METRE));\r\n                break;\r\n        }\r\n        logger.debug(\"Update channel '{}' of group '{}' with new state '{}'.\", channelId, channelGroupId, state);\r\n        updateState(channelUID, state);\r\n    } else {\r\n        logger.debug(\"No weather data available to update channel '{}' of group '{}'.\", channelId, channelGroupId);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.lastUpdate",
	"Comment": "query the last update time of a given item. the default persistence service is used.",
	"Method": "AbstractInstant lastUpdate(Item item,AbstractInstant lastUpdate,Item item,String serviceId){\r\n    PersistenceService service = getService(serviceId);\r\n    if (service instanceof QueryablePersistenceService) {\r\n        QueryablePersistenceService qService = (QueryablePersistenceService) service;\r\n        FilterCriteria filter = new FilterCriteria();\r\n        filter.setItemName(item.getName());\r\n        filter.setOrdering(Ordering.DESCENDING);\r\n        filter.setPageSize(1);\r\n        Iterable<HistoricItem> result = qService.query(filter);\r\n        if (result.iterator().hasNext()) {\r\n            return new DateTime(result.iterator().next().getTimestamp());\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        LoggerFactory.getLogger(PersistenceExtensions.class).warn(\"There is no queryable persistence service registered with the id '{}'\", serviceId);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.command.spec.CommandSpec.checkPermission",
	"Comment": "check the relevant permission for this command with the provided source,throwing an exception if the source does not have permission to usethe command.",
	"Method": "void checkPermission(CommandSource source){\r\n    checkNotNull(source, \"source\");\r\n    if (!testPermission(source)) {\r\n        throw new CommandPermissionException();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.config.Config.setApplicationName",
	"Comment": "sets the application name to generate the application token.",
	"Method": "void setApplicationName(String applicationName){\r\n    this.applicationName = applicationName;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.Utils.putInHastable",
	"Comment": "this method puts in a map, the uids of the automation objects. keys are corresponding to the index into thearray with strings, which is lexicographically sorted.",
	"Method": "Map<String, String> putInHastable(String[] strings){\r\n    Hashtable<String, String> sorted = new Hashtable<String, String>();\r\n    for (int i = 0; i < strings.length; i++) {\r\n        sorted.put(new Integer(i + 1).toString(), strings[i]);\r\n    }\r\n    return sorted;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.Utils.swap",
	"Comment": "auxiliary method for sorting lexicographically the strings. shuffling strings on positions x and y, as the stringat the position x, goes to the position y, the string at the position y, goes to the position x.",
	"Method": "void swap(String[] a,int x,int y){\r\n    String t = a[x];\r\n    a[x] = a[y];\r\n    a[y] = t;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.Utils.collectTableRows",
	"Comment": "this method is responsible for collecting the content of the rows of a table.",
	"Method": "List<String> collectTableRows(int width,int[] columnWidths,List<String> values,String titleRow){\r\n    List<String> tableRows = getTableTitle(titleRow, width);\r\n    for (String value : values) {\r\n        tableRows.add(value);\r\n    }\r\n    tableRows.add(getTableBottom(width));\r\n    return tableRows;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.core.internal.folder.FolderObserverTest.tearDown",
	"Comment": "the folderobserver service have to be stopped at the end of each testas most of the tests are covering assertions on its initialization actions",
	"Method": "void tearDown(){\r\n    folderObserver.deactivate();\r\n    FileUtils.deleteDirectory(WATCHED_DIRECTORY);\r\n    modelRepo.clean();\r\n    if (defaultWatchedDir != null) {\r\n        System.setProperty(ConfigConstants.CONFIG_DIR_PROG_ARGUMENT, defaultWatchedDir);\r\n    } else {\r\n        System.clearProperty(ConfigConstants.CONFIG_DIR_PROG_ARGUMENT);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.converter.type.OnOffTypeConverter.isInvert",
	"Comment": "if the item is a sensor or a state from some devices, then onoff must be inverted.",
	"Method": "boolean isInvert(HmDatapoint dp){\r\n    return DATAPOINT_NAME_SENSOR.equals(dp.getName()) || isStateInvertDatapoint(dp);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.convention.homeassistant.AbstractComponent.start",
	"Comment": "subscribes to all state channels of the component and adds all channels to the provided channel type provider.",
	"Method": "CompletableFuture<@Nullable Void> start(MqttBrokerConnection connection,ScheduledExecutorService scheduler,int timeout){\r\n    return channels.values().stream().map(v -> v.channelState.start(connection, scheduler, timeout)).reduce(CompletableFuture.completedFuture(null), (f, v) -> f.thenCompose(b -> v));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.BluetoothDevice.getTxPower",
	"Comment": "returns the last transmit power value or null if no transmit power has been received",
	"Method": "Integer getTxPower(){\r\n    return txPower;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.ConfigDescriptionParameterBuilder.withLimitToOptions",
	"Comment": "set the configuration parameter to be limited to the values in the options list",
	"Method": "ConfigDescriptionParameterBuilder withLimitToOptions(Boolean limitToOptions){\r\n    this.limitToOptions = limitToOptions;\r\n    return this;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.sitemap.internal.SitemapResource.getAllItems",
	"Comment": "collects all items that are represented by a given list of widgets",
	"Method": "Set<GenericItem> getAllItems(EList<Widget> widgets){\r\n    Set<GenericItem> items = new HashSet<GenericItem>();\r\n    if (itemUIRegistry != null) {\r\n        for (Widget widget : widgets) {\r\n            boolean skipWidget = false;\r\n            if (widget instanceof Chart) {\r\n                Chart chartWidget = (Chart) widget;\r\n                skipWidget = chartWidget.getRefresh() > 0;\r\n            }\r\n            String itemName = widget.getItem();\r\n            if (!skipWidget && itemName != null) {\r\n                try {\r\n                    Item item = itemUIRegistry.getItem(itemName);\r\n                    if (item instanceof GenericItem) {\r\n                        items.add((GenericItem) item);\r\n                    }\r\n                } catch (ItemNotFoundException e) {\r\n                }\r\n            }\r\n            if (widget instanceof Frame) {\r\n                items.addAll(getAllItems(((Frame) widget).getChildren()));\r\n            }\r\n            items.addAll(getItemsInVisibilityCond(widget.getVisibility()));\r\n            items.addAll(getItemsInColorCond(widget.getLabelColor()));\r\n            items.addAll(getItemsInColorCond(widget.getValueColor()));\r\n        }\r\n    }\r\n    return items;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.server.RpcResponseHandler.handleMethodCall",
	"Comment": "returns a valid result of the method called by the homematic gateway.",
	"Method": "T handleMethodCall(String methodName,Object[] responseData){\r\n    if (RPC_METHODNAME_EVENT.equals(methodName)) {\r\n        return handleEvent(responseData);\r\n    } else if (RPC_METHODNAME_LIST_DEVICES.equals(methodName) || RPC_METHODNAME_UPDATE_DEVICE.equals(methodName)) {\r\n        return getEmptyArrayResult();\r\n    } else if (RPC_METHODNAME_DELETE_DEVICES.equals(methodName)) {\r\n        return handleDeleteDevice(responseData);\r\n    } else if (RPC_METHODNAME_NEW_DEVICES.equals(methodName)) {\r\n        return handleNewDevice(responseData);\r\n    } else if (RPC_METHODNAME_SYSTEM_LISTMETHODS.equals(methodName)) {\r\n        RpcRequest<T> msg = createRpcRequest();\r\n        msg.addArg(getListMethods());\r\n        return msg.createMessage();\r\n    } else if (RPC_METHODNAME_SYSTEM_MULTICALL.equals(methodName)) {\r\n        for (Object o : (Object[]) responseData[0]) {\r\n            Map<?, ?> call = (Map<?, ?>) o;\r\n            if (call != null) {\r\n                String method = ObjectUtils.toString(call.get(\"methodName\"));\r\n                Object[] data = (Object[]) call.get(\"params\");\r\n                handleMethodCall(method, data);\r\n            }\r\n        }\r\n        return getEmptyEventListResult();\r\n    } else if (RPC_METHODNAME_SET_CONFIG_READY.equals(methodName)) {\r\n        return getEmptyEventListResult();\r\n    } else {\r\n        logger.warn(\"Unknown method called by Homematic gateway: {}\", methodName);\r\n        return getEmptyEventListResult();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.MqttBrokerConnection.createMqttOptions",
	"Comment": "create a mqttconnectoptions object using the fields of this mqttbrokerconnection instance.package local, for testing.",
	"Method": "MqttConnectOptions createMqttOptions(){\r\n    MqttConnectOptions options = new MqttConnectOptions();\r\n    if (!StringUtils.isBlank(user)) {\r\n        options.setUserName(user);\r\n    }\r\n    if (!StringUtils.isBlank(password) && password != null) {\r\n        options.setPassword(password.toCharArray());\r\n    }\r\n    if (secure) {\r\n        options.setSocketFactory(sslContextProvider.getContext().getSocketFactory());\r\n    }\r\n    if (lastWill != null) {\r\n        MqttWillAndTestament lastWill = this.lastWill;\r\n        options.setWill(lastWill.getTopic(), lastWill.getPayload(), lastWill.getQos(), lastWill.isRetain());\r\n    }\r\n    options.setKeepAliveInterval(keepAliveInterval);\r\n    return options;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.Printer.collectRecords",
	"Comment": "this method is responsible for printing the strings, representing the auxiliary automation objects.",
	"Method": "List<String> collectRecords(int[] columnWidths,String prop,Collection<?> list){\r\n    List<String> res = new ArrayList<String>();\r\n    boolean isFirst = true;\r\n    boolean isList = false;\r\n    List<String> values = new ArrayList<String>();\r\n    values.add(prop);\r\n    values.add(\"\");\r\n    if (list != null && !list.isEmpty()) {\r\n        for (Object element : list) {\r\n            if (element instanceof String) {\r\n                res.add(Utils.getColumn(columnWidths[0], values.get(0)) + (String) element);\r\n                if (isFirst) {\r\n                    isFirst = false;\r\n                    values.set(0, \"\");\r\n                }\r\n            } else if (element instanceof Module) {\r\n                List<String> moduleRecords = getModuleRecords((Module) element);\r\n                for (String elementRecord : moduleRecords) {\r\n                    res.add(Utils.getColumn(columnWidths[0], values.get(0)) + elementRecord);\r\n                    if (isFirst) {\r\n                        isFirst = false;\r\n                        values.set(0, \"\");\r\n                    }\r\n                }\r\n            } else {\r\n                isList = true;\r\n                if (isFirst) {\r\n                    values.set(1, \"[\");\r\n                    res.add(Utils.getRow(columnWidths, values));\r\n                    isFirst = false;\r\n                }\r\n                values.set(0, \"\");\r\n                if (element instanceof FilterCriteria) {\r\n                    values.set(1, getFilterCriteriaRecord((FilterCriteria) element));\r\n                } else if (element instanceof ParameterOption) {\r\n                    values.set(1, getParameterOptionRecord((ParameterOption) element));\r\n                } else if (element instanceof Input) {\r\n                    values.set(1, getInputRecord((Input) element));\r\n                } else if (element instanceof Output) {\r\n                    values.set(1, getOutputRecord((Output) element));\r\n                } else if (element instanceof Entry) {\r\n                    values.set(1, \"  \" + ((Entry<String, ?>) element).getKey() + \" = \\\"\" + ((Entry<String, ?>) element).getValue().toString() + \"\\\"\");\r\n                }\r\n                res.add(Utils.getRow(columnWidths, values));\r\n            }\r\n        }\r\n        if (isList) {\r\n            values.set(0, \"\");\r\n            values.set(1, \"]\");\r\n            res.add(Utils.getRow(columnWidths, values));\r\n        }\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.semantics.internal.SemanticsMetadataProvider.processItem",
	"Comment": "updates the semantic metadata for an item and notifies all listeners about changes",
	"Method": "void processItem(Item item){\r\n    MetadataKey key = new MetadataKey(NAMESPACE, item.getName());\r\n    Map<String, Object> configuration = new HashMap();\r\n    Class<? extends Tag> type = SemanticTags.getSemanticType(item);\r\n    if (type != null) {\r\n        processProperties(item, configuration);\r\n        processHierarchy(item, configuration);\r\n        Metadata md = new Metadata(key, type.getAnnotation(TagInfo.class).id(), configuration);\r\n        Metadata oldMd = semantics.put(item.getName(), md);\r\n        if (oldMd == null) {\r\n            notifyListenersAboutAddedElement(md);\r\n        } else {\r\n            notifyListenersAboutUpdatedElement(oldMd, md);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.InventoryCapacity.of",
	"Comment": "create an inventorycapacity property which matches inventorycapacityproperties with equal value.",
	"Method": "InventoryCapacity of(int capacity){\r\n    return new InventoryCapacity(capacity, Operator.EQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.voice.SpeechRecognitionEvent.getConfidence",
	"Comment": "returns the confidence of the transcript. the confidence represents a numeric estimate between 0 and 1, inclusively, of how confident the recognition engine is of the transcript. a higher number means the system is more confident.",
	"Method": "float getConfidence(){\r\n    return this.confidence;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.service.WatchQueueReader.checkAndTrackContent",
	"Comment": "calculate a checksum of the given file and report back whether it has changed since the last time.",
	"Method": "boolean checkAndTrackContent(AbstractWatchService service,Path resolvedPath){\r\n    byte[] newHash = hash(resolvedPath);\r\n    if (newHash == null) {\r\n        return true;\r\n    }\r\n    Map<Path, byte[]> keyHashes = hashes.get(service);\r\n    if (keyHashes == null) {\r\n        keyHashes = new HashMap();\r\n        hashes.put(service, keyHashes);\r\n    }\r\n    byte[] oldHash = keyHashes.put(resolvedPath, newHash);\r\n    return oldHash == null || !Arrays.equals(oldHash, newHash);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.BluetoothCharacteristic.intToSignedBits",
	"Comment": "convert an integer into the signed bits of the specified length.",
	"Method": "int intToSignedBits(int i,int size){\r\n    if (i < 0) {\r\n        return (1 << size - 1) + (i & ((1 << size - 1) - 1));\r\n    } else {\r\n        return i;\r\n    }\r\n}"
}, {
	"Path": "com.alipay.remoting.AbstractRemotingProcessor.process",
	"Comment": "process the remoting command with its own executor or with the defaultexecutor if its own if null.",
	"Method": "void process(RemotingContext ctx,T msg,ExecutorService defaultExecutor){\r\n    ProcessTask task = new ProcessTask(ctx, msg);\r\n    if (this.getExecutor() != null) {\r\n        this.getExecutor().execute(task);\r\n    } else {\r\n        defaultExecutor.execute(task);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.auth.oauth2client.internal.OAuthClientServiceImpl.createInstance",
	"Comment": "it should only be used internally, thus the access is package level",
	"Method": "OAuthClientServiceImpl createInstance(String handle,OAuthStoreHandler storeHandler,HttpClientFactory httpClientFactory,PersistedParams params){\r\n    OAuthClientServiceImpl clientService = new OAuthClientServiceImpl(handle, params.tokenExpiresInSeconds, httpClientFactory);\r\n    clientService.storeHandler = storeHandler;\r\n    clientService.persistedParams = params;\r\n    storeHandler.savePersistedParams(handle, clientService.persistedParams);\r\n    return clientService;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.discovery.HueBridgeNupnpDiscovery.discoverHueBridges",
	"Comment": "discover available hue bridges and then add them in the discovery inbox",
	"Method": "void discoverHueBridges(){\r\n    for (BridgeJsonParameters bridge : getBridgeList()) {\r\n        if (isReachableAndValidHueBridge(bridge)) {\r\n            String host = bridge.getInternalIpAddress();\r\n            String serialNumber = bridge.getId().substring(0, 6) + bridge.getId().substring(10);\r\n            ThingUID uid = new ThingUID(THING_TYPE_BRIDGE, serialNumber);\r\n            DiscoveryResult result = DiscoveryResultBuilder.create(uid).withProperties(buildProperties(host, serialNumber)).withLabel(LABEL_PATTERN.replace(\"IP\", host)).withRepresentationProperty(PROPERTY_SERIAL_NUMBER).build();\r\n            thingDiscovered(result);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.voice.text.AbstractRuleBasedInterpreter.tag",
	"Comment": "adds a name and a tag to the resulting ast tree, if the given expression matches.",
	"Method": "Expression tag(String name,Object expression,Expression tag,Object expression,Object tag,Expression tag,String name,Object expression,Object tag){\r\n    return new ExpressionLet(name, exp(expression), null, tag);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.binding.BaseThingHandler.getConfigAs",
	"Comment": "returns the configuration of the thing and transforms it to the givenclass.",
	"Method": "T getConfigAs(Class<T> configurationClass){\r\n    return getConfig().as(configurationClass);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.console.karaf.internal.ConsoleSupportKaraf.registerCommands",
	"Comment": "register all commands.the session factory must be not null.",
	"Method": "void registerCommands(){\r\n    for (final ConsoleCommandExtension command : commands) {\r\n        registerCommand(command);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.module.script.defaultscope.internal.ScriptBusEvent.storeStates",
	"Comment": "stores the current states for a list of items in a map.a group item is not itself put into the map, but instead all its members.",
	"Method": "Map<Item, State> storeStates(Item items){\r\n    Map<Item, State> statesMap = new HashMap();\r\n    if (items != null) {\r\n        for (Item item : items) {\r\n            if (item instanceof GroupItem) {\r\n                GroupItem groupItem = (GroupItem) item;\r\n                for (Item member : groupItem.getAllMembers()) {\r\n                    statesMap.put(member, member.getState());\r\n                }\r\n            } else {\r\n                statesMap.put(item, item.getState());\r\n            }\r\n        }\r\n    }\r\n    return statesMap;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.config.Config.getTrashDeviceDeleteTime",
	"Comment": "returns the number of days after the trash devices is deleted.",
	"Method": "int getTrashDeviceDeleteTime(){\r\n    return trashDeviceDeleteTime;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.FullConfig.getLights",
	"Comment": "returns detailed information about all lights known to the bridge.",
	"Method": "List<FullLight> getLights(){\r\n    ArrayList<FullLight> lightsList = new ArrayList();\r\n    for (String id : lights.keySet()) {\r\n        FullLight light = lights.get(id);\r\n        light.setId(id);\r\n        lightsList.add(light);\r\n    }\r\n    return lightsList;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.AutomationCommands.executeCommand",
	"Comment": "this method is responsible for execution of every particular command and to return the result of the execution.",
	"Method": "String executeCommand(String command,String[] parameterValues){\r\n    AutomationCommand commandInst = parseCommand(command, parameterValues);\r\n    if (commandInst != null) {\r\n        return commandInst.execute();\r\n    }\r\n    return String.format(\"Command \\\"%s\\\" is not supported!\", command);\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.protocol.AbstractMultiInterestUserProcessor.interest",
	"Comment": "do not need to implement this method because of the multiple interests",
	"Method": "String interest(){\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.BluetoothCharacteristic.getProperties",
	"Comment": "returns the properties of this characteristic.the properties contain a bit mask of property flags indicating the features of this characteristic.",
	"Method": "int getProperties(){\r\n    return properties;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.client.RpcClient.getRpcAddress",
	"Comment": "returns the rpc address from a device address, correctly handling groups.",
	"Method": "String getRpcAddress(String address){\r\n    if (address != null && address.startsWith(\"T-\")) {\r\n        address = \"*\" + address.substring(2);\r\n    }\r\n    return address;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.discovery.HueBridgeNupnpDiscovery.getBridgeList",
	"Comment": "use the philips hue nupnp service to find hue bridges in local network.",
	"Method": "List<BridgeJsonParameters> getBridgeList(){\r\n    try {\r\n        Gson gson = new Gson();\r\n        String json = doGetRequest(DISCOVERY_URL);\r\n        return gson.fromJson(json, new TypeToken<List<BridgeJsonParameters>>() {\r\n        }.getType());\r\n    } catch (IOException e) {\r\n        logger.debug(\"Philips Hue NUPnP service not reachable. Can't discover bridges\");\r\n    } catch (JsonParseException je) {\r\n        logger.debug(\"Invalid json respone from Hue NUPnP service. Can't discover bridges\");\r\n    }\r\n    return new ArrayList();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.AbstractHomematicGateway.getVirtualDatapointHandler",
	"Comment": "returns a virtualdatapointhandler for the given datapoint if available.",
	"Method": "VirtualDatapointHandler getVirtualDatapointHandler(HmDatapoint dp,Object value){\r\n    for (VirtualDatapointHandler vdph : virtualDatapointHandlers) {\r\n        if (vdph.canHandleCommand(dp, value)) {\r\n            return vdph;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.fsinternetradio.test.FSInternetRadioHandlerJavaTest.verifyOnlineStatus",
	"Comment": "verify online status of a thing with complete configuration.",
	"Method": "void verifyOnlineStatus(){\r\n    Thing radioThing = initializeRadioThing(DEFAULT_COMPLETE_CONFIGURATION);\r\n    testRadioThingConsideringConfiguration(radioThing);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.dmx.internal.multiverse.DmxChannel.setChannelAction",
	"Comment": "replace the current list of channel actions with the provided one.",
	"Method": "void setChannelAction(BaseAction channelAction){\r\n    clearAction();\r\n    actions.add(channelAction);\r\n    logger.trace(\"set action {} for DMX channel {}\", channelAction, this);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.firmware.FirmwareUpdateProgressInfo.isPending",
	"Comment": "returns true if the firmware update is pending, false otherwise",
	"Method": "boolean isPending(){\r\n    return pending;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.javasound.internal.JavaSoundAudioSource.convertAudioFormat",
	"Comment": "converts a javax.sound.sampled.audioformat to a org.eclipse.smarthome.core.audio.audioformat",
	"Method": "AudioFormat convertAudioFormat(javax.sound.sampled.AudioFormat audioFormat){\r\n    String container = AudioFormat.CONTAINER_WAVE;\r\n    String codec = audioFormat.getEncoding().toString();\r\n    Boolean bigEndian = new Boolean(audioFormat.isBigEndian());\r\n    int frameSize = audioFormat.getFrameSize();\r\n    int bitsPerFrame = frameSize * 8;\r\n    Integer bitDepth = ((AudioSystem.NOT_SPECIFIED == frameSize) ? null : new Integer(bitsPerFrame));\r\n    float frameRate = audioFormat.getFrameRate();\r\n    Integer bitRate = ((AudioSystem.NOT_SPECIFIED == frameRate) ? null : new Integer((int) (frameRate * bitsPerFrame)));\r\n    float sampleRate = audioFormat.getSampleRate();\r\n    Long frequency = ((AudioSystem.NOT_SPECIFIED == sampleRate) ? null : new Long((long) sampleRate));\r\n    return new AudioFormat(container, codec, bigEndian, bitDepth, bitRate, frequency);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.sonos.internal.handler.ZonePlayerHandler.isStandalonePlayer",
	"Comment": "checks if the player receiving the command is a standalone player",
	"Method": "boolean isStandalonePlayer(){\r\n    return getCurrentZoneGroup() != null ? getCurrentZoneGroup().getMembers().size() == 1 : true;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.MetadataUtils.isRollerShutter",
	"Comment": "returns true, if the device of the datapoint is a rollershutter.",
	"Method": "boolean isRollerShutter(HmDatapoint dp){\r\n    String channelType = dp.getChannel().getType();\r\n    return channelType.equals(CHANNEL_TYPE_BLIND) || channelType.equals(CHANNEL_TYPE_JALOUSIE) || channelType.equals(CHANNEL_TYPE_SHUTTER_TRANSMITTER) || channelType.equals(CHANNEL_TYPE_SHUTTER_VIRTUAL_RECEIVER);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.FullGroup.getAction",
	"Comment": "returns the last sent state update to the group.this does not have to reflect the current state of the group.",
	"Method": "State getAction(){\r\n    return action;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.structure.scene.InternalScene.activateSceneByDevice",
	"Comment": "will be called by a device, if an undo call of an other scene activated this scene.",
	"Method": "void activateSceneByDevice(){\r\n    if (!active && !deviceHasChanged) {\r\n        this.active = true;\r\n        deviceHasChanged = false;\r\n        informListener();\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.CommandArgs.getSnapshot",
	"Comment": "gets a snapshot of the data inside this context to allow it to berestored later.",
	"Method": "Snapshot getSnapshot(){\r\n    return new Snapshot(this.index, this.args);\r\n}"
}, {
	"Path": "com.alipay.remoting.ScheduledDisconnectStrategy.monitor",
	"Comment": "monitor connections and close connections with status is off",
	"Method": "void monitor(Map<String, RunStateRecordedFutureTask<ConnectionPool>> connPools){\r\n    try {\r\n        if (null != connPools && !connPools.isEmpty()) {\r\n            Iterator<Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>>> iter = connPools.entrySet().iterator();\r\n            while (iter.hasNext()) {\r\n                Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>> entry = iter.next();\r\n                String poolKey = entry.getKey();\r\n                ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(entry.getValue(), logger);\r\n                List<Connection> connections = pool.getAll();\r\n                Map<String, List<Connection>> filteredConnectons = this.filter(connections);\r\n                List<Connection> serviceOnConnections = filteredConnectons.get(Configs.CONN_SERVICE_STATUS_ON);\r\n                List<Connection> serviceOffConnections = filteredConnectons.get(Configs.CONN_SERVICE_STATUS_OFF);\r\n                if (serviceOnConnections.size() > CONNECTION_THRESHOLD) {\r\n                    Connection freshSelectConnect = serviceOnConnections.get(random.nextInt(serviceOnConnections.size()));\r\n                    freshSelectConnect.setAttribute(Configs.CONN_SERVICE_STATUS, Configs.CONN_SERVICE_STATUS_OFF);\r\n                    Connection lastSelectConnect = freshSelectConnections.remove(poolKey);\r\n                    freshSelectConnections.put(poolKey, freshSelectConnect);\r\n                    closeFreshSelectConnections(lastSelectConnect, serviceOffConnections);\r\n                } else {\r\n                    if (freshSelectConnections.containsKey(poolKey)) {\r\n                        Connection lastSelectConnect = freshSelectConnections.remove(poolKey);\r\n                        closeFreshSelectConnections(lastSelectConnect, serviceOffConnections);\r\n                    }\r\n                    if (logger.isInfoEnabled()) {\r\n                        logger.info(\"the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}].\", serviceOnConnections.size(), CONNECTION_THRESHOLD);\r\n                    }\r\n                }\r\n                for (Connection offConn : serviceOffConnections) {\r\n                    if (offConn.isFine()) {\r\n                        offConn.close();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        logger.error(\"ScheduledDisconnectStrategy monitor error\", e);\r\n    }\r\n}"
}, {
	"Path": "com.alipay.remoting.DefaultConnectionManager.getAndCreateIfAbsent",
	"Comment": "if no task cached, create one and initialize the connections.",
	"Method": "Connection getAndCreateIfAbsent(Url url){\r\n    ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url));\r\n    if (null != pool) {\r\n        return pool.get();\r\n    } else {\r\n        logger.error(\"[NOTIFYME] bug detected! pool here must not be null!\");\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.config.Config.setSensordataReadTimeout",
	"Comment": "sets the connection timeout for sensor readings from devices.",
	"Method": "void setSensordataReadTimeout(int sensordataReadTimeout){\r\n    this.sensordataReadTimeout = sensordataReadTimeout;\r\n}"
}, {
	"Path": "com.alipay.remoting.DefaultConnectionManager.scan",
	"Comment": "in case of cache pollution and connection leak, to do schedule scan",
	"Method": "void scan(){\r\n    if (null != this.connTasks && !this.connTasks.isEmpty()) {\r\n        Iterator<String> iter = this.connTasks.keySet().iterator();\r\n        while (iter.hasNext()) {\r\n            String poolKey = iter.next();\r\n            ConnectionPool pool = this.getConnectionPool(this.connTasks.get(poolKey));\r\n            if (null != pool) {\r\n                pool.scan();\r\n                if (pool.isEmpty()) {\r\n                    if ((System.currentTimeMillis() - pool.getLastAccessTimestamp()) > DEFAULT_EXPIRE_TIME) {\r\n                        iter.remove();\r\n                        logger.warn(\"Remove expired pool task of poolKey {} which is empty.\", poolKey);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.SlotSide.of",
	"Comment": "create a slotside property which matches slotside properties with equalvalue.",
	"Method": "SlotSide of(Object value){\r\n    return new SlotSide(value, Operator.EQUAL);\r\n}"
}, {
	"Path": "org.spongepowered.api.asset.Asset.getFileName",
	"Comment": "returns the the last portion of the asset url, e.g. the file name.",
	"Method": "String getFileName(){\r\n    String path = getUrl().getPath();\r\n    int end = path.lastIndexOf('/');\r\n    if (end < 0) {\r\n        return path;\r\n    }\r\n    return path.substring(end + 1);\r\n}"
}, {
	"Path": "org.spongepowered.api.command.spec.CommandSpec.populateContext",
	"Comment": "process this command with existing arguments and context objects.",
	"Method": "void populateContext(CommandSource source,CommandArgs args,CommandContext context){\r\n    this.args.parse(source, args, context);\r\n    if (args.hasNext()) {\r\n        args.next();\r\n        throw args.createError(t(\"Too many arguments!\"));\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.SoftwareUpdate.getUpdateState",
	"Comment": "returns the state of the update.actual meaning currently undocumented",
	"Method": "int getUpdateState(){\r\n    return updatestate;\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.heartbeat.ClientHeartBeatTest.testClientHeartBeatTriggerExceed3Times",
	"Comment": "test heartbeat no response, close the connection from client side",
	"Method": "void testClientHeartBeatTriggerExceed3Times(){\r\n    server.getRpcServer().registerProcessor(RpcProtocol.PROTOCOL_CODE, CommonCommandCode.HEARTBEAT, heartBeatProcessor);\r\n    try {\r\n        client.createStandaloneConnection(addr, 1000);\r\n    } catch (RemotingException e) {\r\n        logger.error(\"\", e);\r\n    }\r\n    Thread.sleep(3000);\r\n    Assert.assertTrue(heartBeatProcessor.getHeartBeatTimes() > 1);\r\n    Assert.assertEquals(1, clientConnectProcessor.getConnectTimes());\r\n    Assert.assertEquals(1, serverConnectProcessor.getConnectTimes());\r\n    Assert.assertEquals(1, clientDisConnectProcessor.getDisConnectTimes());\r\n    Assert.assertEquals(1, serverDisConnectProcessor.getDisConnectTimes());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.cache.ExpiringCacheMap.refresh",
	"Comment": "refreshes and returns the value associated with the given key in the cache.",
	"Method": "V refresh(K key){\r\n    final ExpiringCache<@Nullable V> item = items.get(key);\r\n    if (item == null) {\r\n        logger.debug(\"No item for key '{}' found\", key);\r\n        return null;\r\n    } else {\r\n        return item.refreshValue();\r\n    }\r\n}"
}, {
	"Path": "org.smssecure.smssecure.util.Base64.decodeToObject",
	"Comment": "attempts to decode base64 data and deserialize a javaobject within. returns null if there was an error.if loader is not null, it will be the class loaderused when deserializing.",
	"Method": "Object decodeToObject(String encodedObject,Object decodeToObject,String encodedObject,int options,ClassLoader loader){\r\n    byte[] objBytes = decode(encodedObject, options);\r\n    java.io.ByteArrayInputStream bais = null;\r\n    java.io.ObjectInputStream ois = null;\r\n    Object obj = null;\r\n    try {\r\n        bais = new java.io.ByteArrayInputStream(objBytes);\r\n        if (loader == null) {\r\n            ois = new java.io.ObjectInputStream(bais);\r\n        } else {\r\n            ois = new java.io.ObjectInputStream(bais) {\r\n                @Override\r\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\r\n                    Class c = Class.forName(streamClass.getName(), false, loader);\r\n                    if (c == null) {\r\n                        return super.resolveClass(streamClass);\r\n                    } else {\r\n                        return c;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        obj = ois.readObject();\r\n    } catch (java.io.IOException e) {\r\n        throw e;\r\n    } catch (java.lang.ClassNotFoundException e) {\r\n        throw e;\r\n    } finally {\r\n        try {\r\n            bais.close();\r\n        } catch (Exception e) {\r\n        }\r\n        try {\r\n            ois.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "org.smssecure.smssecure.util.Base64.decodeToObject",
	"Comment": "attempts to decode base64 data and deserialize a javaobject within. returns null if there was an error.if loader is not null, it will be the class loaderused when deserializing.",
	"Method": "Object decodeToObject(String encodedObject,Object decodeToObject,String encodedObject,int options,ClassLoader loader){\r\n    Class c = Class.forName(streamClass.getName(), false, loader);\r\n    if (c == null) {\r\n        return super.resolveClass(streamClass);\r\n    } else {\r\n        return c;\r\n    }\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.RpcResponseResolver.detailErrMsg",
	"Comment": "detail your error msg with the error msg returned from response command",
	"Method": "String detailErrMsg(String clientErrMsg,ResponseCommand responseCommand){\r\n    RpcResponseCommand resp = (RpcResponseCommand) responseCommand;\r\n    if (StringUtils.isNotBlank(resp.getErrorMsg())) {\r\n        return String.format(\"%s, ServerErrorMsg:%s\", clientErrMsg, resp.getErrorMsg());\r\n    } else {\r\n        return String.format(\"%s, ServerErrorMsg:null\", clientErrMsg);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.voice.text.TokenList.checkHead",
	"Comment": "checks for the first token of the list.if it is equal to one of the provided alternatives, it will succeed.",
	"Method": "boolean checkHead(String alternatives){\r\n    return check(head, alternatives);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.ui.basic.internal.render.PageRenderer.processPage",
	"Comment": "this is the main method, which is called to produce the html code for a servlet request.",
	"Method": "StringBuilder processPage(String id,String sitemap,String label,EList<Widget> children,boolean async){\r\n    String snippet = getSnippet(async ? \"layer\" : \"main\");\r\n    snippet = snippet.replaceAll(\"%main.offline-msg%\", localizeText(\"@text/main.offline-msg\"));\r\n    snippet = snippet.replaceAll(\"%main.long-polling-mode-msg%\", localizeText(\"@text/main.long-polling-mode-msg\"));\r\n    snippet = snippet.replaceAll(\"%id%\", id);\r\n    String labelPlain = label;\r\n    if (labelPlain.contains(\"[\") && labelPlain.endsWith(\"]\")) {\r\n        labelPlain = labelPlain.replace(\"[\", \"\").replace(\"]\", \"\");\r\n    }\r\n    snippet = StringUtils.replace(snippet, \"%label%\", escapeHtml(labelPlain));\r\n    snippet = StringUtils.replace(snippet, \"%servletname%\", WebAppServlet.SERVLET_NAME);\r\n    snippet = StringUtils.replace(snippet, \"%sitemap%\", sitemap);\r\n    snippet = StringUtils.replace(snippet, \"%htmlclass%\", config.getCssClassList());\r\n    snippet = StringUtils.replace(snippet, \"%icon_type%\", config.getIconType());\r\n    snippet = StringUtils.replace(snippet, \"%theme%\", config.getTheme());\r\n    String[] parts = snippet.split(\"%children%\");\r\n    StringBuilder preChildren = new StringBuilder(parts[0]);\r\n    StringBuilder postChildren = new StringBuilder(parts[1]);\r\n    if (parts.length == 2) {\r\n        processChildren(preChildren, postChildren, children);\r\n    } else if (parts.length > 2) {\r\n        logger.error(\"Snippet '{}' contains multiple %children% sections, but only one is allowed!\", async ? \"layer\" : \"main\");\r\n    }\r\n    return preChildren.append(postChildren);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.convention.homie300.Property.stop",
	"Comment": "unsubscribe from all property attributes and the property value.",
	"Method": "CompletableFuture<@Nullable Void> stop(){\r\n    final ChannelState channelState = this.channelState;\r\n    if (channelState != null) {\r\n        return channelState.stop().thenCompose(b -> attributes.unsubscribe());\r\n    }\r\n    return attributes.unsubscribe();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.type.Input.getLabel",
	"Comment": "gets the short description of the input. usually the label should be a single word description.",
	"Method": "String getLabel(){\r\n    return label;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.server.BinRpcResponseHandler.run",
	"Comment": "reads the event from the homematic gateway and handles the method call.",
	"Method": "void run(){\r\n    try {\r\n        boolean isMaxAliveReached;\r\n        do {\r\n            BinRpcMessage message = new BinRpcMessage(socket.getInputStream(), true, config.getEncoding());\r\n            logger.trace(\"Event BinRpcMessage: {}\", message);\r\n            byte[] returnValue = rpcResponseHandler.handleMethodCall(message.getMethodName(), message.getResponseData());\r\n            if (returnValue != null) {\r\n                socket.getOutputStream().write(returnValue);\r\n            }\r\n            isMaxAliveReached = System.currentTimeMillis() - created > (config.getSocketMaxAlive() * 1000);\r\n        } while (!isMaxAliveReached);\r\n    } catch (EOFException eof) {\r\n    } catch (Exception e) {\r\n        logger.warn(\"{}\", e.getMessage(), e);\r\n    } finally {\r\n        try {\r\n            socket.close();\r\n        } catch (IOException ioe) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.InventoryDimension.greaterThanOrEqual",
	"Comment": "create an inventorydimension property which matches inventorydimensionproperties with value greater than or equal to this value.",
	"Method": "InventoryDimension greaterThanOrEqual(Object value){\r\n    return new InventoryDimension(value, Operator.GEQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.Utils.getTableContent",
	"Comment": "this method is responsible for the printing of a table with the number and width of the columns,as indicated by the parameter of the method columnwidths and the content of the columns,indicated by the parameter values. the table has title with rows, indicated by theparameter of the method titlerows.",
	"Method": "String getTableContent(int width,int[] columnWidths,List<String> values,String titleRow){\r\n    StringBuilder sb = new StringBuilder();\r\n    List<String> tableRows = collectTableRows(width, columnWidths, values, titleRow);\r\n    for (String tableRow : tableRows) {\r\n        sb.append(tableRow + ROW_END);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.FallingBlock.fallTime",
	"Comment": "gets the time the block has been falling. defaults to a value of 1.",
	"Method": "Value<Integer> fallTime(){\r\n    return getValue(Keys.FALL_TIME).get();\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.timeout.ServerTimeoutTest.testServerOneway",
	"Comment": "the second request will not timeout in oneway process work queue",
	"Method": "void testServerOneway(){\r\n    for (int i = 0; i <= 1; ++i) {\r\n        new Thread() {\r\n            @Override\r\n            public void run() {\r\n                oneway(client, server.getRpcServer());\r\n            }\r\n        }.start();\r\n    }\r\n    try {\r\n        Thread.sleep(max_timeout * 2);\r\n    } catch (InterruptedException e) {\r\n        logger.error(\"\", e);\r\n    }\r\n    Assert.assertEquals(2, clientUserProcessor.getInvokeTimesEachCallType(RequestBody.InvokeType.ONEWAY));\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.timeout.ServerTimeoutTest.testServerOneway",
	"Comment": "the second request will not timeout in oneway process work queue",
	"Method": "void testServerOneway(){\r\n    oneway(client, server.getRpcServer());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.ui.classic.internal.servlet.WebAppServlet.waitForChanges",
	"Comment": "this method only returns when a change has occurred to any item on the page to display",
	"Method": "boolean waitForChanges(EList<Widget> widgets){\r\n    long startTime = (new Date()).getTime();\r\n    boolean timeout = false;\r\n    BlockingStateChangeListener listener = new BlockingStateChangeListener();\r\n    Set<GenericItem> items = getAllItems(widgets);\r\n    for (GenericItem item : items) {\r\n        item.addStateChangeListener(listener);\r\n    }\r\n    while (!listener.hasChangeOccurred() && !timeout) {\r\n        timeout = (new Date()).getTime() - startTime > TIMEOUT_IN_MS;\r\n        try {\r\n            Thread.sleep(300);\r\n        } catch (InterruptedException e) {\r\n            timeout = true;\r\n            break;\r\n        }\r\n    }\r\n    for (GenericItem item : items) {\r\n        item.removeStateChangeListener(listener);\r\n    }\r\n    return !timeout;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.ui.internal.items.ItemUIRegistryImpl.getDynamicGroupChildren",
	"Comment": "this method creates a list of children for a group dynamically.if there are no explicit children defined in a sitemap, the childrencan thus be created on the fly by iterating over the members of the group item.",
	"Method": "EList<Widget> getDynamicGroupChildren(Group group){\r\n    EList<Widget> children = new BasicEList<Widget>();\r\n    String itemName = group.getItem();\r\n    try {\r\n        if (itemName != null) {\r\n            Item item = getItem(itemName);\r\n            if (item instanceof GroupItem) {\r\n                GroupItem groupItem = (GroupItem) item;\r\n                for (Item member : groupItem.getMembers()) {\r\n                    Widget widget = getDefaultWidget(member.getClass(), member.getName());\r\n                    if (widget != null) {\r\n                        widget.setItem(member.getName());\r\n                        children.add(widget);\r\n                    }\r\n                }\r\n            } else {\r\n                logger.warn(\"Item '{}' is not a group.\", item.getName());\r\n            }\r\n        } else {\r\n            logger.warn(\"Group does not specify an associated item - ignoring it.\");\r\n        }\r\n    } catch (ItemNotFoundException e) {\r\n        logger.warn(\"Dynamic group with label '{}' will be ignored, because its item '{}' does not exist.\", group.getLabel(), itemName);\r\n    }\r\n    return children;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.test.OSGiTest.registerService",
	"Comment": "register the given object as osgi service.the given interface names are used as osgi service interface name.",
	"Method": "ServiceRegistration<?> registerService(Object service,ServiceRegistration<?> registerService,Object service,Dictionary<String, ?> properties,ServiceRegistration<?> registerService,Object service,String interfaceName,ServiceRegistration<?> registerService,Object service,String interfaceName,Dictionary<String, ?> properties,ServiceRegistration<?> registerService,Object service,String[] interfaceNames,Dictionary<String, ?> properties){\r\n    assertThat(interfaceNames, is(notNullValue()));\r\n    final ServiceRegistration<?> srvReg = bundleContext.registerService(interfaceNames, service, properties);\r\n    for (final String interfaceName : interfaceNames) {\r\n        saveServiceRegistration(interfaceName, srvReg);\r\n    }\r\n    return srvReg;\r\n}"
}, {
	"Path": "co.aikar.timings.Timings.setTimingsEnabled",
	"Comment": "sets whether or not the timings system should be enabled.callingthis will reset timing data.",
	"Method": "void setTimingsEnabled(boolean enabled){\r\n    factory.setTimingsEnabled(enabled);\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.MappedIntProperty.greaterThanOrEqual",
	"Comment": "create a mappedintproperty property which matches mappedintpropertyproperties with value greater than or equal to this value and matchingkey.",
	"Method": "MappedIntProperty greaterThanOrEqual(Object key,Object value){\r\n    return new MappedIntProperty(key, value, Operator.GEQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.converter.type.OpenClosedTypeConverter.isInvert",
	"Comment": "invert only values which are not from a sensor or a state from some devices.",
	"Method": "boolean isInvert(HmDatapoint dp){\r\n    return !DATAPOINT_NAME_SENSOR.equals(dp.getName()) && !isStateInvertDatapoint(dp);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.discovery.AbstractDiscoveryService.stopScan",
	"Comment": "this method cleans up after a scan, i.e. it removes listeners and other required operations.",
	"Method": "void stopScan(){\r\n    if (scanListener != null) {\r\n        scanListener.onFinished();\r\n        scanListener = null;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.common.registry.AbstractRegistry.getProvider",
	"Comment": "this method retrieves the provider of an element from the registry.",
	"Method": "Provider<E> getProvider(K key,Provider<E> getProvider,E element){\r\n    elementReadLock.lock();\r\n    try {\r\n        return elementToProvider.get(element);\r\n    } finally {\r\n        elementReadLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.common.HomematicConfig.getDiscoveryTimeToLive",
	"Comment": "returns the time to live for discovery results of a homematic gateway in seconds.",
	"Method": "long getDiscoveryTimeToLive(){\r\n    return discoveryTimeToLive;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.BridgeConfigUpdate.setLinkButton",
	"Comment": "set whether the link button has been pressed within the last 30 seconds or not.",
	"Method": "BridgeConfigUpdate setLinkButton(boolean pressed){\r\n    commands.add(new Command(\"linkbutton\", pressed));\r\n    return this;\r\n}"
}, {
	"Path": "org.spongepowered.api.service.permission.MemorySubjectData.getNodeTree",
	"Comment": "gets the calculated node tree representation of the permissions for thissubject data instance. if no data is present for the given context,returns null.",
	"Method": "NodeTree getNodeTree(Set<Context> contexts){\r\n    NodeTree perms = this.permissions.get(contexts);\r\n    return perms == null ? NodeTree.of(Collections.emptyMap()) : perms;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.net.http.HttpUtil.downloadImage",
	"Comment": "download the image data from an url.if content type is not found in the headers, the data is scanned to determine the content type.",
	"Method": "RawType downloadImage(String url,RawType downloadImage,String url,int timeout,RawType downloadImage,String url,boolean scanTypeInContent,long maxContentLength,RawType downloadImage,String url,boolean scanTypeInContent,long maxContentLength,int timeout){\r\n    return downloadData(url, \"image/.*\", scanTypeInContent, maxContentLength, timeout);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.xml.internal.AbstractDescriptionTypeConverter.getUID",
	"Comment": "returns the full extracted uid of the specific xml type definition.",
	"Method": "String getUID(Map<String, String> attributes,UnmarshallingContext context){\r\n    String bindingId = (String) context.get(\"thing-descriptions.bindingId\");\r\n    String typeId = getID(attributes);\r\n    String uid = String.format(\"%s:%s\", bindingId, typeId);\r\n    return uid;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.internal.job.AbstractJob.checkArgument",
	"Comment": "ensures the truth of an expression involving one or more parameters to thecalling method.",
	"Method": "void checkArgument(boolean expression,String errorMessage){\r\n    if (!expression) {\r\n        throw new IllegalArgumentException(errorMessage);\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.data.property.LocationBasePropertyHolder.getFacesWithProperty",
	"Comment": "gets all the faces of this block that have the given property.",
	"Method": "Collection<Direction> getFacesWithProperty(Vector3i coords,Class<? extends Property<?, ?>> propertyClass,Collection<Direction> getFacesWithProperty,int x,int y,int z,Class<? extends Property<?, ?>> propertyClass){\r\n    return getFacesWithProperty(coords.getX(), coords.getY(), coords.getZ(), propertyClass);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.BluetoothDevice.getServiceByHandle",
	"Comment": "gets a service based on the handle.this will return a service if the handle falls within the start and end handles for the service.",
	"Method": "BluetoothService getServiceByHandle(int handle){\r\n    synchronized (supportedServices) {\r\n        for (BluetoothService service : supportedServices.values()) {\r\n            if (service.getHandleStart() <= handle && service.getHandleEnd() >= handle) {\r\n                return service;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.internal.validation.ConfigDescriptionParameterValidatorFactory.createMinMaxValidator",
	"Comment": "returns a new validator for the min and max attribute of a config description parameter.",
	"Method": "ConfigDescriptionParameterValidator createMinMaxValidator(){\r\n    return new MinMaxValidator();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.internal.BlueGigaSerialHandler.sendFrame",
	"Comment": "synchronize this method to ensure a packet gets sent as a block",
	"Method": "void sendFrame(BlueGigaCommand bleFrame){\r\n    try {\r\n        int[] payload = bleFrame.serialize();\r\n        logger.trace(\"TX BLE frame: {}\", printHex(payload, payload.length));\r\n        for (int b : payload) {\r\n            outputStream.write(b);\r\n        }\r\n    } catch (IOException e) {\r\n        throw new BlueGigaException(\"Error sending BLE frame\", e);\r\n    }\r\n    logger.trace(\"--> TX BLE frame: {}\", bleFrame);\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.SlotIndex.greaterThanOrEqual",
	"Comment": "create a slotindex property which matches slotindex properties withvalue greater than or equal to this value.",
	"Method": "SlotIndex greaterThanOrEqual(Object value){\r\n    return new SlotIndex(value, Operator.GEQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.handler.HomematicThingHandler.containsChannel",
	"Comment": "checks whether the given list includes a channel with the given uid",
	"Method": "boolean containsChannel(List<Channel> channels,ChannelUID channelUID){\r\n    for (Channel channel : channels) {\r\n        ChannelUID uid = channel.getUID();\r\n        if (StringUtils.equals(channelUID.getGroupId(), uid.getGroupId()) && StringUtils.equals(channelUID.getId(), uid.getId())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.internal.MqttBrokerHandlerFactory.unsubscribe",
	"Comment": "unsubscribe a listener from all available broker connections.",
	"Method": "void unsubscribe(MQTTTopicDiscoveryParticipant listener){\r\n    TopicSubscribeMultiConnection multiSubscriber = subscriber.remove(listener);\r\n    if (multiSubscriber != null) {\r\n        multiSubscriber.stop();\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.command.spec.CommandSpec.complete",
	"Comment": "return tab completion results using the existing parsed arguments andcontext. primarily useful when including a subcommand in an existingspecification.",
	"Method": "List<String> complete(CommandSource source,CommandArgs args,CommandContext context){\r\n    checkNotNull(source, \"source\");\r\n    List<String> ret = this.args.complete(source, args, context);\r\n    return ret == null ? ImmutableList.<String>of() : ImmutableList.copyOf(ret);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.convention.homie300.Device.startChannels",
	"Comment": "subscribe to all property state topics. the handler will receive an update call for eachreceived value. therefore the thing channels should have been created before.",
	"Method": "CompletableFuture<@Nullable Void> startChannels(MqttBrokerConnection connection,ScheduledExecutorService scheduler,int timeout,HomieThingHandler handler){\r\n    if (!isInitialized() || deviceID.isEmpty()) {\r\n        CompletableFuture<@Nullable Void> c = new CompletableFuture();\r\n        c.completeExceptionally(new Exception(\"Homie Device Tree not inialized yet.\"));\r\n        return c;\r\n    }\r\n    return CompletableFuture.allOf(nodes.stream().flatMap(node -> node.properties.stream()).map(p -> p.startChannel(connection, scheduler, timeout)).toArray(CompletableFuture[]::new));\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.MappedIntProperty.not",
	"Comment": "create a mappedintproperty property which matches mappedintpropertyproperties with unequal value and matching key.",
	"Method": "MappedIntProperty not(Object key,Object value){\r\n    return new MappedIntProperty(key, value, Operator.NOTEQUAL);\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.SlotPos.of",
	"Comment": "create an slotpos property which matches slotpos properties with equalvalue.",
	"Method": "SlotPos of(Object value,SlotPos of,int x,int y){\r\n    return new SlotPos(new Vector2i(x, y), Operator.EQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.sample.extension.java.internal.WelcomeHomeRulesProvider.unregister",
	"Comment": "this method is used to unregister the welcomehomerulesprovider service.",
	"Method": "void unregister(){\r\n    providerReg.unregister();\r\n    providerReg = null;\r\n    rules = null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.transform.TransformationHelper.isTransform",
	"Comment": "determines whether a pattern refers to a transformation service",
	"Method": "boolean isTransform(String pattern){\r\n    return EXTRACT_TRANSFORMFUNCTION_PATTERN.matcher(pattern).matches();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.tools.DelayedBatchProcessing.accept",
	"Comment": "add new object to the batch process list. if the list was empty, the delay timeris armed and all successive objects are accumulated from here on.",
	"Method": "void accept(TYPE t){\r\n    queue.add(t);\r\n    final ScheduledFuture<?> scheduledFuture = this.future;\r\n    if (scheduledFuture == null || scheduledFuture.isDone()) {\r\n        this.future = executor.schedule(this::run, delay, TimeUnit.MILLISECONDS);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.convention.homeassistant.HaID.getThingID",
	"Comment": "we map the homeassistant mqtt topic tree object to an esh thing.",
	"Method": "String getThingID(){\r\n    return objectID;\r\n}"
}, {
	"Path": "org.spongepowered.api.profile.GameProfileCache.add",
	"Comment": "add an entry to this cache, with an optional expiration date.",
	"Method": "boolean add(GameProfile profile,boolean add,GameProfile profile,Date expiry,boolean add,GameProfile profile,Instant expiry,boolean add,GameProfile profile,boolean overwrite,Date expiry,boolean add,GameProfile profile,boolean overwrite,Instant expiry){\r\n    return this.add(profile, overwrite, expiry == null ? null : expiry.toInstant());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluez.BlueZBluetoothDevice.updateTinybDevice",
	"Comment": "updates the internally used tinyb device instance. it replaces any previous instance, disables notifications onit and enables notifications on the new instance.",
	"Method": "void updateTinybDevice(tinyb.BluetoothDevice tinybDevice){\r\n    if (device != null && !tinybDevice.equals(device)) {\r\n        disableNotifications();\r\n    }\r\n    if (this.device == null || !tinybDevice.equals(device)) {\r\n        this.device = tinybDevice;\r\n        enableNotifications();\r\n    }\r\n    tinyb.BluetoothDevice dev = this.device;\r\n    if (dev != null) {\r\n        this.rssi = (int) dev.getRSSI();\r\n        this.txPower = (int) dev.getTxPower();\r\n        if (dev.getConnected()) {\r\n            this.connectionState = ConnectionState.CONNECTED;\r\n        }\r\n    }\r\n    refreshServices();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.semantics.internal.SemanticsMetadataProvider.processHierarchy",
	"Comment": "retrieves semantic information from parent or member items.",
	"Method": "void processHierarchy(Item item,Map<String, Object> configuration){\r\n    Class<? extends Tag> type = SemanticTags.getSemanticType(item);\r\n    if (type != null) {\r\n        for (String parent : item.getGroupNames()) {\r\n            Item parentItem = itemRegistry.get(parent);\r\n            if (parentItem != null) {\r\n                processParent(type, parentItem, configuration);\r\n            }\r\n        }\r\n        if (item instanceof GroupItem) {\r\n            GroupItem gItem = (GroupItem) item;\r\n            for (Item memberItem : gItem.getMembers()) {\r\n                processMember(type, memberItem, configuration);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.internal.filter.CorsFilter.getValue",
	"Comment": "get the first value of a header which may contains several values.",
	"Method": "String getValue(MultivaluedMap<String, String> headers,String header){\r\n    List<String> values = headers.get(header);\r\n    if (values == null || values.isEmpty()) {\r\n        return null;\r\n    }\r\n    return values.get(0).toString();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.common.QueueingThreadPoolExecutorTest.testSetInvalidRejectionHandler",
	"Comment": "tests what happens when wrong rejected execution handler will be used.",
	"Method": "void testSetInvalidRejectionHandler(){\r\n    String poolName = \"testShutdownNoEntriesIntoQueueAnymore\";\r\n    ThreadPoolExecutor pool = QueueingThreadPoolExecutor.createInstance(poolName, 2);\r\n    pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.InventoryDimension.greaterThan",
	"Comment": "create an inventorydimension property which matches inventorydimensionproperties with value greater than this value.",
	"Method": "InventoryDimension greaterThan(Object value){\r\n    return new InventoryDimension(value, Operator.GREATER);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.audio.AudioFormat.getBestMatch",
	"Comment": "determines the best match between a list of audio formats supported by a source and a sink.",
	"Method": "AudioFormat getBestMatch(Set<AudioFormat> inputs,Set<AudioFormat> outputs){\r\n    AudioFormat preferredFormat = getPreferredFormat(inputs);\r\n    if (preferredFormat != null) {\r\n        for (AudioFormat output : outputs) {\r\n            if (output.isCompatible(preferredFormat)) {\r\n                return preferredFormat;\r\n            } else {\r\n                for (AudioFormat input : inputs) {\r\n                    if (output.isCompatible(input)) {\r\n                        return input;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.SlotPos.lessThanOrEqual",
	"Comment": "create an slotpos property which matches slotpos properties with valueless than or equal to this value.",
	"Method": "SlotPos lessThanOrEqual(Object value){\r\n    return new SlotPos(value, Operator.LEQUAL);\r\n}"
}, {
	"Path": "org.spongepowered.api.command.CommandResult.affectedBlocks",
	"Comment": "returns a result indicating the command was processed with anamount of affected blocks.",
	"Method": "CommandResult affectedBlocks(int count,Builder affectedBlocks,Integer affectedBlocks){\r\n    return builder().affectedBlocks(count).build();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.BluetoothDevice.discoverServices",
	"Comment": "starts a discovery on a device. this will iterate through all services and characteristics to build up a view ofthe device.this method should be called before attempting to read or write characteristics.",
	"Method": "boolean discoverServices(){\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.handler.BlueGigaBridgeHandler.deviceDiscovered",
	"Comment": "device discovered. this simply passes the discover information to the discovery service for processing.",
	"Method": "void deviceDiscovered(BluetoothDevice device){\r\n    if (discoveryActive) {\r\n        for (BluetoothDiscoveryListener listener : discoveryListeners) {\r\n            listener.deviceDiscovered(device);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.ui.internal.proxy.ProxyServletService.uriFromRequest",
	"Comment": "determine which uri to address based on the request contents.",
	"Method": "URI uriFromRequest(HttpServletRequest request){\r\n    try {\r\n        URI uri = (URI) request.getAttribute(ATTR_URI);\r\n        if (uri != null) {\r\n            return uri;\r\n        } else {\r\n            ProxyServletException pse = (ProxyServletException) request.getAttribute(ATTR_SERVLET_EXCEPTION);\r\n            if (pse != null) {\r\n                return null;\r\n            }\r\n        }\r\n        String sitemapName = request.getParameter(\"sitemap\");\r\n        if (sitemapName == null) {\r\n            throw new ProxyServletException(HttpServletResponse.SC_BAD_REQUEST, \"Parameter 'sitemap' must be provided!\");\r\n        }\r\n        String widgetId = request.getParameter(\"widgetId\");\r\n        if (widgetId == null) {\r\n            throw new ProxyServletException(HttpServletResponse.SC_BAD_REQUEST, \"Parameter 'widgetId' must be provided!\");\r\n        }\r\n        Sitemap sitemap = (Sitemap) modelRepository.getModel(sitemapName);\r\n        if (sitemap == null) {\r\n            throw new ProxyServletException(HttpServletResponse.SC_NOT_FOUND, String.format(\"Sitemap '%s' could not be found!\", sitemapName));\r\n        }\r\n        Widget widget = itemUIRegistry.getWidget(sitemap, widgetId);\r\n        if (widget == null) {\r\n            throw new ProxyServletException(HttpServletResponse.SC_NOT_FOUND, String.format(\"Widget '%s' could not be found!\", widgetId));\r\n        }\r\n        String uriString = null;\r\n        if (widget instanceof Image) {\r\n            uriString = ((Image) widget).getUrl();\r\n        } else if (widget instanceof Video) {\r\n            uriString = ((Video) widget).getUrl();\r\n        } else {\r\n            throw new ProxyServletException(HttpServletResponse.SC_FORBIDDEN, String.format(\"Widget type '%s' is not supported!\", widget.getClass().getName()));\r\n        }\r\n        String itemName = widget.getItem();\r\n        if (itemName != null) {\r\n            State state = itemUIRegistry.getItemState(itemName);\r\n            if (state != null && state instanceof StringType) {\r\n                try {\r\n                    uri = createURIFromString(state.toString());\r\n                    request.setAttribute(ATTR_URI, uri);\r\n                    return uri;\r\n                } catch (MalformedURLException | URISyntaxException ex) {\r\n                }\r\n            }\r\n        }\r\n        try {\r\n            uri = createURIFromString(uriString);\r\n            request.setAttribute(ATTR_URI, uri);\r\n            return uri;\r\n        } catch (MalformedURLException | URISyntaxException ex) {\r\n            throw new ProxyServletException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, String.format(\"URL '%s' is not a valid URL.\", uriString));\r\n        }\r\n    } catch (ProxyServletException pse) {\r\n        request.setAttribute(ATTR_SERVLET_EXCEPTION, pse);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.internal.BlueGigaSerialHandler.notifyTransactionComplete",
	"Comment": "notify any transaction listeners when we receive a response.",
	"Method": "boolean notifyTransactionComplete(BlueGigaResponse response){\r\n    boolean processed = false;\r\n    synchronized (transactionListeners) {\r\n        for (BluetoothListener<? extends BlueGigaResponse> listener : transactionListeners) {\r\n            if (listener.transactionEvent(response)) {\r\n                processed = true;\r\n            }\r\n        }\r\n    }\r\n    return processed;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.console.ConsoleInterpreter.getUsages",
	"Comment": "returns an array of the usage texts for all available commands",
	"Method": "List<String> getUsages(Collection<ConsoleCommandExtension> consoleCommandExtensions){\r\n    List<String> usages = new ArrayList<String>();\r\n    for (ConsoleCommandExtension consoleCommandExtension : consoleCommandExtensions) {\r\n        usages.addAll(consoleCommandExtension.getUsages());\r\n    }\r\n    return usages;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.internal.calc.SeasonCalc.getCurrentSeasonNameSouthern",
	"Comment": "returns the current season name for the southern hemisphere.",
	"Method": "SeasonName getCurrentSeasonNameSouthern(Calendar calendar){\r\n    long currentMillis = calendar.getTimeInMillis();\r\n    if (currentMillis < currentSeason.getAutumn().getTimeInMillis() || currentMillis >= currentSeason.getSummer().getTimeInMillis()) {\r\n        return SeasonName.SUMMER;\r\n    } else if (currentMillis >= currentSeason.getAutumn().getTimeInMillis() && currentMillis < currentSeason.getWinter().getTimeInMillis()) {\r\n        return SeasonName.AUTUMN;\r\n    } else if (currentMillis >= currentSeason.getWinter().getTimeInMillis() && currentMillis < currentSeason.getSpring().getTimeInMillis()) {\r\n        return SeasonName.WINTER;\r\n    } else if (currentMillis >= currentSeason.getSpring().getTimeInMillis() && currentMillis < currentSeason.getSummer().getTimeInMillis()) {\r\n        return SeasonName.SPRING;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.JSONResponse.createResponse",
	"Comment": "depending on the status, create a response object containing either the entity alone or an error jsonwhich might hold the entity as well.",
	"Method": "Response createResponse(Response.StatusType status,Object entity,String errormessage,Response createResponse,Response.StatusType status,Object entity){\r\n    ResponseBuilder rp = responseBuilder(status);\r\n    if (entity == null) {\r\n        return rp.build();\r\n    }\r\n    PipedOutputStream out = new PipedOutputStream();\r\n    try {\r\n        PipedInputStream in = new PipedInputStream(out);\r\n        rp.entity(in);\r\n    } catch (IOException e) {\r\n        throw new IllegalStateException(e);\r\n    }\r\n    Thread writerThread = new Thread(() -> {\r\n        try (JsonWriter jsonWriter = new JsonWriter(new BufferedWriter(new OutputStreamWriter(out)))) {\r\n            gson.toJson(entity, entity.getClass(), jsonWriter);\r\n            jsonWriter.flush();\r\n        } catch (IOException | JsonIOException e) {\r\n            logger.error(\"Error streaming JSON through PipedInpuStream/PipedOutputStream: \", e);\r\n        }\r\n    });\r\n    writerThread.setDaemon(true);\r\n    writerThread.start();\r\n    return rp.build();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.ui.classic.internal.render.AbstractWidgetRenderer.getLabel",
	"Comment": "retrieves the label for a widget and formats it for the webapp.net framework",
	"Method": "String getLabel(Widget w,String getLabel,Widget w,String preferredValue){\r\n    String label = itemUIRegistry.getLabel(w);\r\n    int index = label.indexOf('[');\r\n    int index2 = label.lastIndexOf(']');\r\n    if (index != -1 && index2 != -1) {\r\n        label = formatLabel(label.substring(0, index).trim(), (preferredValue == null) ? label.substring(index + 1, index2) : preferredValue);\r\n    } else {\r\n        label = formatLabel(label, null);\r\n    }\r\n    return label;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.sonos.internal.handler.ZonePlayerHandler.isQueueEvent",
	"Comment": "similar to the avtransport eventing, the queue events its state variablesas sub values within a synthesized lastchange state variable.",
	"Method": "boolean isQueueEvent(String variable){\r\n    return \"LastChange\".equals(variable);\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.ArmorSlotType.not",
	"Comment": "create an armourslottype property which matches armourslottype propertieswith unequal value.",
	"Method": "ArmorSlotType not(Object value){\r\n    return new ArmorSlotType(value, Operator.NOTEQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.script.actions.ScriptExecutionTest.testRescheduleTimerDuringExecution",
	"Comment": "test that a running timer can be rescheduled from within its closure",
	"Method": "void testRescheduleTimerDuringExecution(){\r\n    MockClosure0 closure = new MockClosure0(1);\r\n    Timer t = createTimer(closure);\r\n    assertThat(t.isRunning(), is(equalTo(false)));\r\n    assertThat(t.hasTerminated(), is(equalTo(false)));\r\n    assertThat(closure.getApplyCount(), is(equalTo(0)));\r\n    assertThat(scheduler.getPendingJobCount(), is(equalTo(1)));\r\n    scheduler.run();\r\n    assertThat(scheduler.getPendingJobCount(), is(equalTo(1)));\r\n    scheduler.run();\r\n    assertThat(scheduler.getPendingJobCount(), is(equalTo(0)));\r\n    assertThat(closure.getApplyCount(), is(equalTo(2)));\r\n    assertThat(t.isRunning(), is(equalTo(false)));\r\n    assertThat(t.hasTerminated(), is(equalTo(true)));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.core.provider.HostFragmentMappingUtil.returnHostBundles",
	"Comment": "this method is used to get the host bundles of the parameter which is a fragment bundle.",
	"Method": "List<Bundle> returnHostBundles(Bundle fragment){\r\n    List<Bundle> hosts = new ArrayList<Bundle>();\r\n    Bundle[] bundles = pkgAdmin.getHosts(fragment);\r\n    if (bundles != null) {\r\n        hosts = Arrays.asList(bundles);\r\n    } else {\r\n        for (Bundle host : hostFragmentMapping.keySet()) {\r\n            if (hostFragmentMapping.get(host).contains(fragment)) {\r\n                hosts.add(host);\r\n            }\r\n        }\r\n    }\r\n    return hosts;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.common.HomematicConfig.getSocketMaxAlive",
	"Comment": "returns the max alive time of a socket connection to a homematic gateway in seconds.",
	"Method": "int getSocketMaxAlive(){\r\n    return socketMaxAlive;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.ui.classic.internal.render.PageRenderer.processPage",
	"Comment": "this is the main method, which is called to produce the html code for a servlet request.",
	"Method": "StringBuilder processPage(String id,String sitemap,String label,EList<Widget> children,boolean async){\r\n    String snippet = getSnippet(async ? \"layer\" : \"main\");\r\n    snippet = snippet.replaceAll(\"%id%\", id);\r\n    String labelPlain = label;\r\n    if (labelPlain.contains(\"[\") && labelPlain.endsWith(\"]\")) {\r\n        labelPlain = labelPlain.replace(\"[\", \"\").replace(\"]\", \"\");\r\n    }\r\n    snippet = StringUtils.replace(snippet, \"%labelstyle%\", \"\");\r\n    snippet = StringUtils.replace(snippet, \"%label%\", StringEscapeUtils.escapeHtml(labelPlain));\r\n    snippet = StringUtils.replace(snippet, \"%servletname%\", WebAppServlet.SERVLET_NAME);\r\n    snippet = StringUtils.replace(snippet, \"%sitemap%\", sitemap);\r\n    String[] parts = snippet.split(\"%children%\");\r\n    StringBuilder preChildren = new StringBuilder(parts[0]);\r\n    StringBuilder postChildren = new StringBuilder(parts[1]);\r\n    if (parts.length == 2) {\r\n        processChildren(preChildren, postChildren, children);\r\n    } else if (parts.length > 2) {\r\n        logger.error(\"Snippet '{}' contains multiple %children% sections, but only one is allowed!\", async ? \"layer\" : \"main\");\r\n    }\r\n    return preChildren.append(postChildren);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.generic.ChannelState.stop",
	"Comment": "removes the subscription to the state topic and resets the channelstateupdatelistener.",
	"Method": "CompletableFuture<@Nullable Void> stop(){\r\n    final MqttBrokerConnection connection = this.connection;\r\n    if (connection != null && StringUtils.isNotBlank(config.stateTopic)) {\r\n        return connection.unsubscribe(config.stateTopic, this).thenRun(this::internalStop);\r\n    } else {\r\n        internalStop();\r\n        return CompletableFuture.completedFuture(null);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.minimumSince",
	"Comment": "gets the historic item with the minimum value of the state of a given item sincea certain point in time. the default persistence service is used.",
	"Method": "HistoricItem minimumSince(Item item,AbstractInstant timestamp,HistoricItem minimumSince,Item item,AbstractInstant timestamp,String serviceId){\r\n    Iterable<HistoricItem> result = getAllStatesSince(item, timestamp, serviceId);\r\n    Iterator<HistoricItem> it = result.iterator();\r\n    HistoricItem minimumHistoricItem = null;\r\n    DecimalType minimum = item.getStateAs(DecimalType.class);\r\n    while (it.hasNext()) {\r\n        HistoricItem historicItem = it.next();\r\n        State state = historicItem.getState();\r\n        if (state instanceof DecimalType) {\r\n            DecimalType value = (DecimalType) state;\r\n            if (minimum == null || value.compareTo(minimum) < 0) {\r\n                minimum = value;\r\n                minimumHistoricItem = historicItem;\r\n            }\r\n        }\r\n    }\r\n    if (minimumHistoricItem == null && minimum != null) {\r\n        final DecimalType state = minimum;\r\n        return new HistoricItem() {\r\n            @Override\r\n            public Date getTimestamp() {\r\n                return Calendar.getInstance().getTime();\r\n            }\r\n            @Override\r\n            public State getState() {\r\n                return state;\r\n            }\r\n            @Override\r\n            public String getName() {\r\n                return item.getName();\r\n            }\r\n        };\r\n    } else {\r\n        return minimumHistoricItem;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.minimumSince",
	"Comment": "gets the historic item with the minimum value of the state of a given item sincea certain point in time. the default persistence service is used.",
	"Method": "HistoricItem minimumSince(Item item,AbstractInstant timestamp,HistoricItem minimumSince,Item item,AbstractInstant timestamp,String serviceId){\r\n    return Calendar.getInstance().getTime();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.minimumSince",
	"Comment": "gets the historic item with the minimum value of the state of a given item sincea certain point in time. the default persistence service is used.",
	"Method": "HistoricItem minimumSince(Item item,AbstractInstant timestamp,HistoricItem minimumSince,Item item,AbstractInstant timestamp,String serviceId){\r\n    return state;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.minimumSince",
	"Comment": "gets the historic item with the minimum value of the state of a given item sincea certain point in time. the default persistence service is used.",
	"Method": "HistoricItem minimumSince(Item item,AbstractInstant timestamp,HistoricItem minimumSince,Item item,AbstractInstant timestamp,String serviceId){\r\n    return item.getName();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.onewire.internal.handler.OwBaseThingHandler.refresh",
	"Comment": "refresh this thingneeds proper exception handling for refresh errors if overridden",
	"Method": "void refresh(OwBaseBridgeHandler bridgeHandler,long now){\r\n    try {\r\n        Boolean forcedRefresh = lastRefresh == 0;\r\n        if (now >= (lastRefresh + refreshInterval)) {\r\n            logger.trace(\"refreshing {}\", this.thing.getUID());\r\n            lastRefresh = now;\r\n            if (!sensors.get(0).checkPresence(bridgeHandler)) {\r\n                logger.trace(\"sensor not present\");\r\n                return;\r\n            }\r\n            for (int i = 0; i < sensorCount; i++) {\r\n                logger.trace(\"refreshing sensor {} ({})\", i, sensors.get(i).getSensorId());\r\n                sensors.get(i).refresh(bridgeHandler, forcedRefresh);\r\n            }\r\n        }\r\n    } catch (OwException e) {\r\n        logger.debug(\"{}: refresh exception {}\", this.thing.getUID(), e.getMessage());\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"refresh exception\");\r\n    }\r\n}"
}, {
	"Path": "com.alipay.remoting.ProcessorManager.getProcessor",
	"Comment": "get the specific processor with command code of cmdcode if registered, otherwise the default processor is returned.",
	"Method": "RemotingProcessor<?> getProcessor(CommandCode cmdCode){\r\n    RemotingProcessor<?> processor = this.cmd2processors.get(cmdCode);\r\n    if (processor != null) {\r\n        return processor;\r\n    }\r\n    return this.defaultProcessor;\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.protocol.AbstractUserProcessor.timeoutDiscard",
	"Comment": "by default, return true, means discard requests which timeout already.",
	"Method": "boolean timeoutDiscard(){\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.scheduler.CronExpression.isValidExpression",
	"Comment": "indicates whether the specified expression can be parsed into avalid expression",
	"Method": "boolean isValidExpression(String cronExpression){\r\n    try {\r\n        new CronExpression(cronExpression);\r\n    } catch (ParseException pe) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.sample.extension.java.internal.WelcomeHomeCommands.unregister",
	"Comment": "this method is used to unregister the commands service, provider of the rules and handlers of the modules thatcompose the rules.",
	"Method": "void unregister(){\r\n    if (commandsServiceReg != null) {\r\n        commandsServiceReg.unregister();\r\n    }\r\n    commandsServiceReg = null;\r\n    rulesProvider = null;\r\n    handlerFactory = null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.core.internal.item.MetadataSelectorMatcher.filterNamespaces",
	"Comment": "filter existing metadata namespaces against the given namespaeselector. the given string might consist of a commaseparated list of namespaces as well as a regular expression.",
	"Method": "Set<String> filterNamespaces(String namespaceSelector,Locale locale){\r\n    if (namespaceSelector == null || namespaceSelector.isEmpty()) {\r\n        return Collections.emptySet();\r\n    } else {\r\n        // \r\n        Set<String> originalNamespaces = // \r\n        Arrays.stream(namespaceSelector.split(\",\")).filter(// \r\n        n -> !metadataRegistry.isInternalNamespace(n)).map(n -> n.trim()).collect(Collectors.toSet());\r\n        String namespacePattern = originalNamespaces.stream().collect(Collectors.joining(\"|\"));\r\n        Pattern pattern = Pattern.compile(METADATA_SCHEME_PREFIX + \"(\" + namespacePattern + \")$\");\r\n        Collection<ConfigDescription> configDescriptions = configDescriptionRegistry.getConfigDescriptions(locale);\r\n        Set<String> configNamespaces = configDescriptions.stream().filter(cd -> cd.getUID().getScheme().equals(METADATA_SCHEME)).map(cd -> cd.getUID().toString()).filter(pattern.asPredicate()).map(uri -> uri.substring(METADATA_SCHEME_PREFIX.length())).collect(toSet());\r\n        Set<String> result = new HashSet(originalNamespaces);\r\n        result.addAll(configNamespaces);\r\n        return result.stream().filter(namespace -> namespace.matches(AbstractUID.SEGMENT_PATTERN)).collect(toSet());\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.cache.ExpiringCacheMap.putValue",
	"Comment": "puts a new value into the cache if the specified key is present.",
	"Method": "void putValue(K key,V value){\r\n    final ExpiringCache<@Nullable V> item = items.get(key);\r\n    if (item == null) {\r\n        throw new IllegalArgumentException(String.format(\"No item found for key '%s' .\", key));\r\n    } else {\r\n        item.putValue(value);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.BeaconBluetoothHandler.updateStatusBasedOnRssi",
	"Comment": "this method sets the thing status based on whether or not we can receive a signal from it.this is the best logic for beacons, but connected devices might want to deactivate this by overriding the method.",
	"Method": "void updateStatusBasedOnRssi(boolean receivedSignal){\r\n    if (receivedSignal) {\r\n        updateStatus(ThingStatus.ONLINE);\r\n    } else {\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.javasound.internal.AudioPlayer.convertAudioFormat",
	"Comment": "converts a org.eclipse.smarthome.core.audio.audioformatto a javax.sound.sampled.audioformat",
	"Method": "AudioFormat convertAudioFormat(org.eclipse.smarthome.core.audio.AudioFormat audioFormat){\r\n    AudioFormat.Encoding encoding = new AudioFormat.Encoding(audioFormat.getCodec());\r\n    if (audioFormat.getCodec().equals(org.eclipse.smarthome.core.audio.AudioFormat.CODEC_PCM_SIGNED)) {\r\n        encoding = AudioFormat.Encoding.PCM_SIGNED;\r\n    } else if (audioFormat.getCodec().equals(org.eclipse.smarthome.core.audio.AudioFormat.CODEC_PCM_ULAW)) {\r\n        encoding = AudioFormat.Encoding.ULAW;\r\n    } else if (audioFormat.getCodec().equals(org.eclipse.smarthome.core.audio.AudioFormat.CODEC_PCM_ALAW)) {\r\n        encoding = AudioFormat.Encoding.ALAW;\r\n    }\r\n    final Long frequency = audioFormat.getFrequency();\r\n    if (frequency == null) {\r\n        return null;\r\n    }\r\n    final float sampleRate = frequency.floatValue();\r\n    final Integer bitDepth = audioFormat.getBitDepth();\r\n    if (bitDepth == null) {\r\n        return null;\r\n    }\r\n    final int sampleSizeInBits = bitDepth.intValue();\r\n    final int channels = 1;\r\n    final int frameSize = sampleSizeInBits / 8;\r\n    final float frameRate = sampleRate / frameSize;\r\n    final Boolean bigEndian = audioFormat.isBigEndian();\r\n    if (bigEndian == null) {\r\n        return null;\r\n    }\r\n    return new AudioFormat(encoding, sampleRate, sampleSizeInBits, channels, frameSize, frameRate, bigEndian);\r\n}"
}, {
	"Path": "org.spongepowered.api.extra.modifier.skylands.SkylandsUtil.getNextAir",
	"Comment": "gets the next air block in the buffer, starting from the given ycoordinate and going down until yend. returns yend if none is found.",
	"Method": "int getNextAir(MutableBlockVolume buffer,int x,int y,int z,int yEnd){\r\n    for (; y >= yEnd && !buffer.getBlockType(x, y, z).equals(BlockTypes.AIR); y--) {\r\n    }\r\n    return y;\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.SlotPos.lessThan",
	"Comment": "create an slotpos property which matches slotpos properties with valueless than this value.",
	"Method": "SlotPos lessThan(Object value){\r\n    return new SlotPos(value, Operator.LESS);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.handler.HomematicBridgeHandler.getDutyCycleRatio",
	"Comment": "returns the last value for the duty cycle ratio that was retrieved from the homematic gateway.",
	"Method": "int getDutyCycleRatio(){\r\n    return dutyCycleRatio;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.weatherunderground.internal.discovery.WeatherUndergroundDiscoveryService.deactivate",
	"Comment": "we override this method to allow a call from the thing handler factory",
	"Method": "void deactivate(){\r\n    super.deactivate();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.xml.osgi.XmlDocumentBundleTracker.withLock",
	"Comment": "execute given method while take the lock and unlock before return.",
	"Method": "T withLock(Lock lock,Supplier<T> supplier){\r\n    lock.lock();\r\n    try {\r\n        return supplier.get();\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.reconnect.AbstractReconnectStrategy.getBrokerConnection",
	"Comment": "return the brokerconnection object that this reconnect policy is assigned to.",
	"Method": "MqttBrokerConnection getBrokerConnection(){\r\n    return brokerConnection;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.sonos.internal.SonosResourceMetaData.getUpnpClass",
	"Comment": "the upnp class for the resource meta data. this can be different from theparent meta data class and should be used to match the play type over theparent value.",
	"Method": "String getUpnpClass(){\r\n    return upnpClass;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.CommandlineModuleTypeProvider.exportModuleTypes",
	"Comment": "this method is responsible for exporting a set of moduletypes in a specified file.",
	"Method": "String exportModuleTypes(String parserType,Set<ModuleType> set,File file){\r\n    return super.exportData(parserType, set, file);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.weatherunderground.handler.WeatherUndergroundHandler.updateWeatherData",
	"Comment": "request new current conditions and forecast 10 days to the weather underground serviceand store the data in weatherdata",
	"Method": "boolean updateWeatherData(Set<String> features){\r\n    WeatherUndergroundJsonData result = null;\r\n    boolean resultOk = false;\r\n    String error = null;\r\n    String errorDetail = null;\r\n    String statusDescr = null;\r\n    try {\r\n        WeatherUndergroundConfiguration config = getConfigAs(WeatherUndergroundConfiguration.class);\r\n        String urlStr = URL_QUERY.replace(\"%APIKEY%\", StringUtils.trimToEmpty(bridgeHandler.getApikey()));\r\n        urlStr = urlStr.replace(\"þATURES%\", String.join(\"/\", features));\r\n        String lang = StringUtils.trimToEmpty(config.language);\r\n        if (lang.isEmpty()) {\r\n            lang = getCodeFromLanguage(localeProvider.getLocale());\r\n            logger.debug(\"Use language deduced from system locale {}: {}\", localeProvider.getLocale().getLanguage(), lang);\r\n        }\r\n        if (lang.isEmpty()) {\r\n            urlStr = urlStr.replace(\"%SETTINGS%\", \"\");\r\n        } else {\r\n            urlStr = urlStr.replace(\"%SETTINGS%\", \"lang:\" + lang.toUpperCase());\r\n        }\r\n        urlStr = urlStr.replace(\"%QUERY%\", StringUtils.trimToEmpty(config.location));\r\n        logger.debug(\"URL = {}\", urlStr);\r\n        String response = null;\r\n        try {\r\n            response = HttpUtil.executeUrl(\"GET\", urlStr, WeatherUndergroundBridgeHandler.FETCH_TIMEOUT_MS);\r\n            logger.debug(\"weatherData = {}\", response);\r\n        } catch (IllegalArgumentException e) {\r\n            error = \"Error creating URI with location parameter: '\" + StringUtils.trimToEmpty(config.location) + \"'\";\r\n            errorDetail = e.getMessage();\r\n            statusDescr = \"@text/offline.uri-error\";\r\n        }\r\n        result = gson.fromJson(response, WeatherUndergroundJsonData.class);\r\n        if (result.getResponse() == null) {\r\n            errorDetail = \"missing response sub-object\";\r\n        } else if (result.getResponse().getErrorDescription() != null) {\r\n            if (\"keynotfound\".equals(result.getResponse().getErrorType())) {\r\n                error = \"API key has to be fixed\";\r\n                statusDescr = \"@text/offline.comm-error-invalid-api-key\";\r\n            }\r\n            errorDetail = result.getResponse().getErrorDescription();\r\n        } else {\r\n            resultOk = true;\r\n            for (String feature : features) {\r\n                if (feature.equals(FEATURE_CONDITIONS) && result.getCurrent() == null) {\r\n                    resultOk = false;\r\n                    errorDetail = \"missing current_observation sub-object\";\r\n                } else if (feature.equals(FEATURE_FORECAST10DAY) && result.getForecast() == null) {\r\n                    resultOk = false;\r\n                    errorDetail = \"missing forecast sub-object\";\r\n                } else if (feature.equals(FEATURE_GEOLOOKUP) && result.getLocation() == null) {\r\n                    resultOk = false;\r\n                    errorDetail = \"missing location sub-object\";\r\n                }\r\n            }\r\n        }\r\n        if (!resultOk && error == null) {\r\n            error = \"Error in Weather Underground response\";\r\n            statusDescr = \"@text/offline.comm-error-response\";\r\n        }\r\n    } catch (IOException e) {\r\n        error = \"Error running Weather Underground request\";\r\n        errorDetail = e.getMessage();\r\n        statusDescr = \"@text/offline.comm-error-running-request\";\r\n    } catch (JsonSyntaxException e) {\r\n        error = \"Error parsing Weather Underground response\";\r\n        errorDetail = e.getMessage();\r\n        statusDescr = \"@text/offline.comm-error-parsing-response\";\r\n    }\r\n    if (resultOk) {\r\n        updateStatus(ThingStatus.ONLINE);\r\n        weatherData = result;\r\n    } else {\r\n        logger.debug(\"Setting thing '{}' to OFFLINE: Error '{}': {}\", getThing().getUID(), error, errorDetail);\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, statusDescr);\r\n        weatherData = null;\r\n    }\r\n    return resultOk;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.sample.moduletype.demo.internal.commands.DemoCommandsPluggable.executeCommand",
	"Comment": "this method is responsible for execution of every particular command and to return the result of the execution.",
	"Method": "String executeCommand(String command,String[] parameterValues){\r\n    DemoCommand commandInst = parseCommand(command, parameterValues);\r\n    if (commandInst != null) {\r\n        return commandInst.execute();\r\n    }\r\n    return String.format(\"Command \\\"%s\\\" is not supported!\", command);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.binding.BaseThingHandler.validateConfigurationParameters",
	"Comment": "validates the given configuration parameters against the configuration description.",
	"Method": "void validateConfigurationParameters(Map<String, Object> configurationParameters){\r\n    if (this.callback != null) {\r\n        this.callback.validateConfigurationParameters(this.getThing(), configurationParameters);\r\n    } else {\r\n        logger.warn(\"Handler {} tried validating its configuration although the handler was already disposed.\", this.getClass().getSimpleName());\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.mqttembeddedbroker.internal.MqttEmbeddedBrokerDetectStart.stopBrokerStartDetection",
	"Comment": "stops the broker server reachable detection if it is still running.",
	"Method": "void stopBrokerStartDetection(){\r\n    if (schedule != null) {\r\n        schedule.cancel(true);\r\n        schedule = null;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.generator.CcuMetadataExtractor.generate",
	"Comment": "loads the javascript file from the ccu and generates the properties file.",
	"Method": "void generate(){\r\n    Map<String, String> deviceKeys = loadDeviceKeys();\r\n    for (String lang : LANGUAGES) {\r\n        Map<String, String> langDescriptions = loadJsonLangDescriptionFile(CCU_URL + DESCRIPTION_KEYS, lang);\r\n        for (String fileName : MASTER_LANG_FILES) {\r\n            langDescriptions.putAll(loadJsonLangDescriptionFile(CCU_URL + MASTER_LANG_PATH + fileName, lang));\r\n        }\r\n        Map<String, String> deviceDescriptions = loadJsonLangDescriptionFile(CCU_URL + DESCRIPTION_DESCRIPTIONS, lang);\r\n        String langIdent = (\"en\".equals(lang) ? \"\" : \"_\" + lang);\r\n        File file = new File(\"./src/main/resources/homematic/generated-descriptions\" + langIdent + \".properties\");\r\n        System.out.println(\"Writing file \" + file.getAbsolutePath());\r\n        if (file.exists()) {\r\n            file.delete();\r\n        }\r\n        file.createNewFile();\r\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), \"ISO-8859-1\"));\r\n        bw.write(\"# -------------- generated descriptions \" + new Date() + \" --------------\\n\");\r\n        bw.write(\"# DON'T CHANGE THIS FILE!\\n\\n\");\r\n        for (Entry<String, String> entry : deviceDescriptions.entrySet()) {\r\n            bw.write(entry.getKey());\r\n            bw.write(\"=\");\r\n            bw.write(entry.getValue());\r\n            bw.write(\"\\n\");\r\n        }\r\n        bw.write(\"\\n\\n\\n\");\r\n        for (Entry<String, String> entry : deviceKeys.entrySet()) {\r\n            String description = langDescriptions.get(entry.getValue());\r\n            if (description == null) {\r\n                System.out.println(\"WARNING: Can't find a translation for \" + entry.getValue());\r\n            } else {\r\n                bw.write(entry.getKey().toUpperCase());\r\n                bw.write(\"=\");\r\n                bw.write(description);\r\n                bw.write(\"\\n\");\r\n            }\r\n        }\r\n        bw.flush();\r\n        bw.close();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.ui.basic.internal.render.AbstractWidgetRenderer.getSnippet",
	"Comment": "this method provides the html snippet for a given elementtype of the sitemap model.",
	"Method": "String getSnippet(String elementType){\r\n    String lowerTypeElementType = elementType.toLowerCase();\r\n    String snippet = SNIPPET_CACHE.get(lowerTypeElementType);\r\n    if (snippet == null) {\r\n        String snippetLocation = SNIPPET_LOCATION + lowerTypeElementType + SNIPPET_EXT;\r\n        URL entry = WebAppActivator.getContext().getBundle().getEntry(snippetLocation);\r\n        if (entry != null) {\r\n            try {\r\n                snippet = IOUtils.toString(entry.openStream());\r\n                SNIPPET_CACHE.put(lowerTypeElementType, snippet);\r\n            } catch (IOException e) {\r\n                logger.warn(\"Cannot load snippet for element type '{}'\", lowerTypeElementType, e);\r\n            }\r\n        } else {\r\n            throw new RenderException(\"Cannot find a snippet for element type '\" + lowerTypeElementType + \"'\");\r\n        }\r\n    }\r\n    return snippet;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bosesoundtouch.internal.PresetContainer.put",
	"Comment": "adds a contentitem as preset, with presetid. note that a eventually existing id in preset will be overwritten bypresetid",
	"Method": "void put(int presetID,ContentItem preset){\r\n    preset.setPresetID(presetID);\r\n    if (preset.isPresetable()) {\r\n        mapOfPresets.put(presetID, preset);\r\n        writeToStorage();\r\n    } else {\r\n        throw new ContentItemNotPresetableException();\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.MappedIntProperty.lessThanOrEqual",
	"Comment": "create a mappedintproperty property which matches mappedintpropertyproperties with value less than or equal to this value and matching key.",
	"Method": "MappedIntProperty lessThanOrEqual(Object key,Object value){\r\n    return new MappedIntProperty(key, value, Operator.LEQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.sonos.internal.handler.ZonePlayerHandler.getZoneGroupMembers",
	"Comment": "returns a list of all zone group members this particular player is member ofor empty list if the players is not assigned to any group",
	"Method": "List<String> getZoneGroupMembers(){\r\n    List<String> result = new ArrayList();\r\n    if (stateMap.get(\"ZoneGroupState\") != null) {\r\n        Collection<SonosZoneGroup> zoneGroups = SonosXMLParser.getZoneGroupFromXML(stateMap.get(\"ZoneGroupState\"));\r\n        for (SonosZoneGroup zg : zoneGroups) {\r\n            if (zg.getMembers().contains(getUDN())) {\r\n                result.addAll(zg.getMembers());\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        result.add(getUDN());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.CcuGateway.sendScriptByName",
	"Comment": "sends a tclrega script with the specified variables to the ccu.",
	"Method": "T sendScriptByName(String scriptName,Class<T> clazz,T sendScriptByName,String scriptName,Class<T> clazz,String[] variableNames,String[] values){\r\n    String script = tclregaScripts.get(scriptName);\r\n    for (int i = 0; i < variableNames.length; i++) {\r\n        script = StringUtils.replace(script, \"{\" + variableNames[i] + \"}\", values[i]);\r\n    }\r\n    return sendScript(script, clazz);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.sample.java.demo.internal.SampleJavaDemo.deactivate",
	"Comment": "called from ds when one of the required services becomes unavailable.",
	"Method": "void deactivate(ComponentContext componentContext){\r\n    SampleJavaDemo.ruleRegistry.remove(RULE_UID);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.HueBridge.getLastSearch",
	"Comment": "returns the last time a search for new lights was started.if a search is currently running, the current time will bereturned or null if a search has never been started.",
	"Method": "Date getLastSearch(){\r\n    requireAuthentication();\r\n    Result result = http.get(getRelativeURL(\"lights/new\"));\r\n    handleErrors(result);\r\n    String lastScan = safeFromJson(result.getBody(), NewLightsResponse.class).lastscan;\r\n    switch(lastScan) {\r\n        case \"none\":\r\n            return null;\r\n        case \"active\":\r\n            return new Date();\r\n        default:\r\n            try {\r\n                return new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\").parse(lastScan);\r\n            } catch (ParseException e) {\r\n                return null;\r\n            }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.mapping.AbstractMqttAttributeClass.createSubscriber",
	"Comment": "creates a field subscriber for the given field on the given object",
	"Method": "SubscribeFieldToMQTTtopic createSubscriber(ScheduledExecutorService scheduler,Field field,String topic,boolean mandatory){\r\n    return new SubscribeFieldToMQTTtopic(scheduler, field, this, topic, mandatory);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.handler.HomematicBridgeHandler.scheduleReinitialize",
	"Comment": "schedules a reinitialization, if the homematic gateway is not reachable at bridge startup.",
	"Method": "void scheduleReinitialize(){\r\n    if (!isDisposed) {\r\n        initializeFuture = scheduler.schedule(this::initializeInternal, REINITIALIZE_DELAY_SECONDS, TimeUnit.SECONDS);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.config.Config.getBinCheckTime",
	"Comment": "sets the milliseconds after the trash devices will be checked, if its time to delete.",
	"Method": "int getBinCheckTime(){\r\n    return binCheckTime;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.fsinternetradio.test.FSInternetRadioDiscoveryParticipantJavaTest.noDiscoveryResultIfNullDetails",
	"Comment": "verify no discovery result for fsinternetradio device with null details.",
	"Method": "void noDiscoveryResultIfNullDetails(){\r\n    RemoteDevice fsInterntRadioDeviceWithNullDetails = new RemoteDevice(null);\r\n    assertNull(discoveryParticipant.createResult(fsInterntRadioDeviceWithNullDetails));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.internal.calc.SunCalc.getSunInfo",
	"Comment": "calculates all sun rise and sets at the specified coordinates.",
	"Method": "Sun getSunInfo(Calendar calendar,double latitude,double longitude,Double altitude,Sun getSunInfo,Calendar calendar,double latitude,double longitude,Double altitude,boolean onlyAstro){\r\n    double lw = -longitude * DEG2RAD;\r\n    double phi = latitude * DEG2RAD;\r\n    double j = DateTimeUtils.midnightDateToJulianDate(calendar) + 0.5;\r\n    double n = getJulianCycle(j, lw);\r\n    double js = getApproxSolarTransit(0, lw, n);\r\n    double m = getSolarMeanAnomaly(js);\r\n    double c = getEquationOfCenter(m);\r\n    double lsun = getEclipticLongitude(m, c);\r\n    double d = getSunDeclination(lsun);\r\n    double jtransit = getSolarTransit(js, m, lsun);\r\n    double w0 = getHourAngle(H0, phi, d);\r\n    double w1 = getHourAngle(H0 + SUN_DIAMETER, phi, d);\r\n    double jset = getSunsetJulianDate(w0, m, lsun, lw, n);\r\n    double jsetstart = getSunsetJulianDate(w1, m, lsun, lw, n);\r\n    double jrise = getSunriseJulianDate(jtransit, jset);\r\n    double jriseend = getSunriseJulianDate(jtransit, jsetstart);\r\n    double w2 = getHourAngle(H1, phi, d);\r\n    double jnau = getSunsetJulianDate(w2, m, lsun, lw, n);\r\n    double jciv2 = getSunriseJulianDate(jtransit, jnau);\r\n    double w3 = getHourAngle(H2, phi, d);\r\n    double w4 = getHourAngle(H3, phi, d);\r\n    double jastro = getSunsetJulianDate(w3, m, lsun, lw, n);\r\n    double jdark = getSunsetJulianDate(w4, m, lsun, lw, n);\r\n    double jnau2 = getSunriseJulianDate(jtransit, jastro);\r\n    double jastro2 = getSunriseJulianDate(jtransit, jdark);\r\n    Sun sun = new Sun();\r\n    sun.setAstroDawn(new Range(DateTimeUtils.toCalendar(jastro2), DateTimeUtils.toCalendar(jnau2)));\r\n    sun.setAstroDusk(new Range(DateTimeUtils.toCalendar(jastro), DateTimeUtils.toCalendar(jdark)));\r\n    if (onlyAstro) {\r\n        return sun;\r\n    }\r\n    sun.setNoon(new Range(DateTimeUtils.toCalendar(jtransit), DateTimeUtils.toCalendar(jtransit + JD_ONE_MINUTE_FRACTION)));\r\n    sun.setRise(new Range(DateTimeUtils.toCalendar(jrise), DateTimeUtils.toCalendar(jriseend)));\r\n    sun.setSet(new Range(DateTimeUtils.toCalendar(jsetstart), DateTimeUtils.toCalendar(jset)));\r\n    sun.setCivilDawn(new Range(DateTimeUtils.toCalendar(jciv2), DateTimeUtils.toCalendar(jrise)));\r\n    sun.setCivilDusk(new Range(DateTimeUtils.toCalendar(jset), DateTimeUtils.toCalendar(jnau)));\r\n    sun.setNauticDawn(new Range(DateTimeUtils.toCalendar(jnau2), DateTimeUtils.toCalendar(jciv2)));\r\n    sun.setNauticDusk(new Range(DateTimeUtils.toCalendar(jnau), DateTimeUtils.toCalendar(jastro)));\r\n    boolean isSunUpAllDay = isSunUpAllDay(calendar, latitude, longitude, altitude);\r\n    Range daylightRange = new Range();\r\n    if (sun.getRise().getStart() == null && sun.getRise().getEnd() == null) {\r\n        if (isSunUpAllDay) {\r\n            daylightRange = new Range(DateTimeUtils.truncateToMidnight(calendar), DateTimeUtils.truncateToMidnight(addDays(calendar, 1)));\r\n        }\r\n    } else {\r\n        daylightRange = new Range(sun.getRise().getEnd(), sun.getSet().getStart());\r\n    }\r\n    sun.setDaylight(daylightRange);\r\n    Sun sunYesterday = getSunInfo(addDays(calendar, -1), latitude, longitude, altitude, true);\r\n    Range morningNightRange = null;\r\n    if (sunYesterday.getAstroDusk().getEnd() != null && DateUtils.isSameDay(sunYesterday.getAstroDusk().getEnd(), calendar)) {\r\n        morningNightRange = new Range(sunYesterday.getAstroDusk().getEnd(), sun.getAstroDawn().getStart());\r\n    } else if (isSunUpAllDay || sun.getAstroDawn().getStart() == null) {\r\n        morningNightRange = new Range();\r\n    } else {\r\n        morningNightRange = new Range(DateTimeUtils.truncateToMidnight(calendar), sun.getAstroDawn().getStart());\r\n    }\r\n    sun.setMorningNight(morningNightRange);\r\n    Range eveningNightRange = null;\r\n    if (sun.getAstroDusk().getEnd() != null && DateUtils.isSameDay(sun.getAstroDusk().getEnd(), calendar)) {\r\n        eveningNightRange = new Range(sun.getAstroDusk().getEnd(), DateTimeUtils.truncateToMidnight(addDays(calendar, 1)));\r\n    } else {\r\n        eveningNightRange = new Range();\r\n    }\r\n    sun.setEveningNight(eveningNightRange);\r\n    if (isSunUpAllDay) {\r\n        sun.setNight(new Range());\r\n    } else {\r\n        Sun sunTomorrow = getSunInfo(addDays(calendar, 1), latitude, longitude, altitude, true);\r\n        sun.setNight(new Range(sun.getAstroDusk().getEnd(), sunTomorrow.getAstroDawn().getStart()));\r\n    }\r\n    SunEclipse eclipse = sun.getEclipse();\r\n    MoonCalc mc = new MoonCalc();\r\n    double partial = mc.getEclipse(calendar, MoonCalc.ECLIPSE_TYPE_SUN, j, MoonCalc.ECLIPSE_MODE_PARTIAL);\r\n    eclipse.setPartial(DateTimeUtils.toCalendar(partial));\r\n    double ring = mc.getEclipse(calendar, MoonCalc.ECLIPSE_TYPE_SUN, j, MoonCalc.ECLIPSE_MODE_RING);\r\n    eclipse.setRing(DateTimeUtils.toCalendar(ring));\r\n    double total = mc.getEclipse(calendar, MoonCalc.ECLIPSE_TYPE_SUN, j, MoonCalc.ECLIPSE_MODE_TOTAL);\r\n    eclipse.setTotal(DateTimeUtils.toCalendar(total));\r\n    SunZodiacCalc zodiacCalc = new SunZodiacCalc();\r\n    sun.setZodiac(zodiacCalc.getZodiac(calendar));\r\n    SeasonCalc seasonCalc = new SeasonCalc();\r\n    sun.setSeason(seasonCalc.getSeason(calendar, latitude));\r\n    for (Entry<SunPhaseName, Range> rangeEntry : sun.getAllRanges().entrySet()) {\r\n        SunPhaseName entryPhase = rangeEntry.getKey();\r\n        if (rangeEntry.getValue().matches(Calendar.getInstance())) {\r\n            if (entryPhase == SunPhaseName.MORNING_NIGHT || entryPhase == SunPhaseName.EVENING_NIGHT) {\r\n                sun.getPhase().setName(SunPhaseName.NIGHT);\r\n            } else {\r\n                sun.getPhase().setName(entryPhase);\r\n            }\r\n        }\r\n    }\r\n    return sun;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.internal.model.SunZodiac.isValid",
	"Comment": "returns true, if the zodiac is valid on the specified calendar object.",
	"Method": "boolean isValid(Calendar calendar){\r\n    if (range == null || range.getStart() == null || range.getEnd() == null) {\r\n        return false;\r\n    }\r\n    return range.getStart().getTimeInMillis() <= calendar.getTimeInMillis() && range.getEnd().getTimeInMillis() >= calendar.getTimeInMillis();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.provider.file.AbstractFileProvider.importFile",
	"Comment": "this method is responsible for importing a set of automation objects from a specified url resource.",
	"Method": "void importFile(String parserType,URL url){\r\n    Parser<E> parser = parsers.get(parserType);\r\n    if (parser != null) {\r\n        InputStream is = null;\r\n        InputStreamReader inputStreamReader = null;\r\n        try {\r\n            is = url.openStream();\r\n            BufferedInputStream bis = new BufferedInputStream(is);\r\n            inputStreamReader = new InputStreamReader(bis);\r\n            Set<E> providedObjects = parser.parse(inputStreamReader);\r\n            updateProvidedObjectsHolder(url, providedObjects);\r\n        } catch (ParsingException e) {\r\n            logger.debug(\"{}\", e.getMessage(), e);\r\n        } catch (IOException e) {\r\n            logger.debug(\"{}\", e.getMessage(), e);\r\n        } finally {\r\n            if (inputStreamReader != null) {\r\n                try {\r\n                    inputStreamReader.close();\r\n                } catch (IOException e) {\r\n                }\r\n            }\r\n            if (is != null) {\r\n                try {\r\n                    is.close();\r\n                } catch (IOException e) {\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        synchronized (urls) {\r\n            List<URL> value = urls.get(parserType);\r\n            if (value == null) {\r\n                value = new ArrayList<URL>();\r\n                urls.put(parserType, value);\r\n            }\r\n            value.add(url);\r\n        }\r\n        logger.debug(\"Parser {} not available\", parserType, new Exception());\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.sonos.internal.handler.ZonePlayerHandler.handleNotificationSound",
	"Comment": "handle the execution of the notification sound by sequentially executing the required steps.",
	"Method": "void handleNotificationSound(Command notificationURL,ZonePlayerHandler coordinator){\r\n    String originalVolume = (isAdHocGroup() || isStandalonePlayer()) ? getVolume() : coordinator.getVolume();\r\n    coordinator.stop();\r\n    coordinator.waitForNotTransportState(STATE_PLAYING);\r\n    applyNotificationSoundVolume();\r\n    long notificationPosition = coordinator.getQueueSize() + 1;\r\n    coordinator.addURIToQueue(notificationURL.toString(), \"\", notificationPosition, false);\r\n    coordinator.setCurrentURI(QUEUE_URI + coordinator.getUDN() + \"#0\", \"\");\r\n    coordinator.setPositionTrack(notificationPosition);\r\n    coordinator.play();\r\n    coordinator.waitForFinishedNotification();\r\n    if (originalVolume != null) {\r\n        setVolumeForGroup(DecimalType.valueOf(originalVolume));\r\n    }\r\n    coordinator.removeRangeOfTracksFromQueue(new StringType(Long.toString(notificationPosition) + \",1\"));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.AutomationCommands.remove",
	"Comment": "this method is responsible for removing a set of objects loaded from a specified file or url resource.",
	"Method": "String remove(int providerType,URL url){\r\n    switch(providerType) {\r\n        case AutomationCommands.MODULE_TYPE_PROVIDER:\r\n            if (moduleTypeProvider != null) {\r\n                return moduleTypeProvider.remove(url);\r\n            }\r\n            break;\r\n        case AutomationCommands.TEMPLATE_PROVIDER:\r\n            if (templateProvider != null) {\r\n                return templateProvider.remove(url);\r\n            }\r\n            break;\r\n    }\r\n    return AutomationCommand.FAIL;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.discovery.HomematicDeviceDiscoveryService.loadDevices",
	"Comment": "starts a thread which loads all homematic devices connected to the gateway.",
	"Method": "void loadDevices(){\r\n    if (loadDevicesFuture == null && bridgeHandler.getGateway() != null) {\r\n        loadDevicesFuture = scheduler.submit(() -> {\r\n            try {\r\n                final HomematicGateway gateway = bridgeHandler.getGateway();\r\n                gateway.loadAllDeviceMetadata();\r\n                bridgeHandler.getTypeGenerator().validateFirmwares();\r\n            } catch (Throwable ex) {\r\n                logger.error(\"{}\", ex.getMessage(), ex);\r\n            } finally {\r\n                loadDevicesFuture = null;\r\n                bridgeHandler.setOfflineStatus();\r\n                removeOlderResults(getTimestampOfLastScan());\r\n            }\r\n        });\r\n    } else {\r\n        logger.debug(\"Homematic devices discovery scan in progress\");\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.AbstractHomematicGateway.createGatewayDevice",
	"Comment": "creates a virtual device for handling variables, scripts and other special gateway functions.",
	"Method": "HmDevice createGatewayDevice(){\r\n    String type = String.format(\"%s-%s\", HmDevice.TYPE_GATEWAY_EXTRAS, StringUtils.upperCase(id));\r\n    HmDevice device = new HmDevice(HmDevice.ADDRESS_GATEWAY_EXTRAS, getDefaultInterface(), type, config.getGatewayInfo().getId(), null, null);\r\n    device.setName(HmDevice.TYPE_GATEWAY_EXTRAS);\r\n    device.addChannel(new HmChannel(HmChannel.TYPE_GATEWAY_EXTRAS, HmChannel.CHANNEL_NUMBER_EXTRAS));\r\n    device.addChannel(new HmChannel(HmChannel.TYPE_GATEWAY_VARIABLE, HmChannel.CHANNEL_NUMBER_VARIABLE));\r\n    device.addChannel(new HmChannel(HmChannel.TYPE_GATEWAY_SCRIPT, HmChannel.CHANNEL_NUMBER_SCRIPT));\r\n    return device;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.core.internal.composite.CompositeConditionHandler.isSatisfied",
	"Comment": "the method calls handlers of child modules and return true only when they all are satisfied.",
	"Method": "boolean isSatisfied(Map<String, Object> context){\r\n    List<Condition> children = getChildren();\r\n    Map<String, Object> compositeContext = getCompositeContext(context);\r\n    for (Condition child : children) {\r\n        Map<String, Object> childContext = Collections.unmodifiableMap(getChildContext(child, compositeContext));\r\n        ConditionHandler childHandler = moduleHandlerMap.get(child);\r\n        boolean isSatisfied = childHandler.isSatisfied(childContext);\r\n        if (!isSatisfied) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.ConfigUtil.normalizeType",
	"Comment": "normalizes the type of the parameter to the one allowed for configurations.",
	"Method": "Object normalizeType(Object value,ConfigDescriptionParameter configDescriptionParameter,Object normalizeType,Object value){\r\n    return normalizeType(value, null);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.internal.command.attributeclient.BlueGigaPrepareWriteCommand.setData",
	"Comment": "data to write. maximum amount of data that can be sent in single command is 18 bytes.",
	"Method": "void setData(int[] data){\r\n    this.data = data;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.fsinternetradio.test.FSInternetRadioDiscoveryParticipantJavaTest.validDiscoveryResultIfWithoutBaseUrl",
	"Comment": "verify valid discoveryresult with fsinterntradio device without base url.",
	"Method": "void validDiscoveryResultIfWithoutBaseUrl(){\r\n    RemoteDevice fsInternetRadioDeviceWithoutUrl = createDefaultFSInternetRadioDevice(null);\r\n    final DiscoveryResult result = discoveryParticipant.createResult(fsInternetRadioDeviceWithoutUrl);\r\n    assertEquals(new ThingUID(DEFAULT_RADIO_THING_UID), result.getThingUID());\r\n    assertEquals(FSInternetRadioBindingConstants.THING_TYPE_RADIO, result.getThingTypeUID());\r\n    assertEquals(DEFAULT_RADIO_MANIFACTURER, result.getProperties().get(FSInternetRadioBindingConstants.PROPERTY_MANUFACTURER));\r\n    assertEquals(DEFAULT_RADIO_MODEL_NUMBER, result.getProperties().get(FSInternetRadioBindingConstants.PROPERTY_MODEL));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.core.provider.AutomationResourceBundlesTracker.addEvent",
	"Comment": "this method is called when a new event for a bundle providing automation resources is received. it causes acreation of a new thread if there is no other created yet and starting the thread. if the thread already exists,it is waiting for events and will be notified for the event.",
	"Method": "void addEvent(Bundle bundle,BundleEvent event){\r\n    BundleEvent e = event != null ? event : initializeEvent(bundle);\r\n    synchronized (queue) {\r\n        queue.add(e);\r\n        for (AutomationResourceBundlesEventQueue queue : providerEventsQueue) {\r\n            queue.addEvent(bundle, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.timeout.ServerTimeoutTest.testOneway",
	"Comment": "the second request will not timeout in oneway process work queue",
	"Method": "void testOneway(){\r\n    for (int i = 0; i <= 1; ++i) {\r\n        new Thread() {\r\n            @Override\r\n            public void run() {\r\n                oneway(client, null);\r\n            }\r\n        }.start();\r\n    }\r\n    try {\r\n        Thread.sleep(max_timeout * 2);\r\n    } catch (InterruptedException e) {\r\n        logger.error(\"\", e);\r\n    }\r\n    Assert.assertEquals(2, serverUserProcessor.getInvokeTimesEachCallType(RequestBody.InvokeType.ONEWAY));\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.timeout.ServerTimeoutTest.testOneway",
	"Comment": "the second request will not timeout in oneway process work queue",
	"Method": "void testOneway(){\r\n    oneway(client, null);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.fsinternetradio.internal.radio.FrontierSiliconRadioConnection.doRequest",
	"Comment": "performs a request to the radio with addition parameters.typically used for changing parameters.",
	"Method": "FrontierSiliconRadioApiResult doRequest(String requestString,FrontierSiliconRadioApiResult doRequest,String requestString,String params){\r\n    for (int i = 0; i < 3; i++) {\r\n        if (!isLoggedIn && !doLogin()) {\r\n            continue;\r\n        }\r\n        final String url = \"http://\" + hostname + \":\" + port + FrontierSiliconRadioConstants.CONNECTION_PATH + \"/\" + requestString + \"?pin=\" + pin + \"&sid=\" + sessionId + (params == null || params.trim().length() == 0 ? \"\" : \"&\" + params);\r\n        logger.trace(\"calling url: '{}'\", url);\r\n        Request request = httpClient.newRequest(url).method(HttpMethod.GET).timeout(SOCKET_TIMEOUT, TimeUnit.MILLISECONDS);\r\n        try {\r\n            ContentResponse response = request.send();\r\n            final int statusCode = response.getStatus();\r\n            if (statusCode != HttpStatus.OK_200) {\r\n                if (i >= 2) {\r\n                    String reason = response.getReason();\r\n                    logger.warn(\"Method failed: {}  {}\", statusCode, reason);\r\n                }\r\n                isLoggedIn = false;\r\n                continue;\r\n            }\r\n            final String responseBody = response.getContentAsString();\r\n            if (!responseBody.isEmpty()) {\r\n                logger.trace(\"got result: {}\", responseBody);\r\n            } else {\r\n                logger.debug(\"got empty result\");\r\n                isLoggedIn = false;\r\n                continue;\r\n            }\r\n            final FrontierSiliconRadioApiResult result = new FrontierSiliconRadioApiResult(responseBody);\r\n            if (result.isStatusOk()) {\r\n                return result;\r\n            }\r\n            isLoggedIn = false;\r\n            continue;\r\n        } catch (Exception e) {\r\n            logger.error(\"Fatal transport error: {}\", e.toString());\r\n            throw new IOException(e);\r\n        }\r\n    }\r\n    isLoggedIn = false;\r\n    return null;\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.SlotPos.greaterThan",
	"Comment": "create an slotpos property which matches slotpos properties with valuegreater than this value.",
	"Method": "SlotPos greaterThan(Object value){\r\n    return new SlotPos(value, Operator.GREATER);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.sitemap.internal.SitemapResource.waitForChanges",
	"Comment": "this method only returns when a change has occurred to any item on thepage to display or if the timeout is reached",
	"Method": "boolean waitForChanges(EList<Widget> widgets){\r\n    long startTime = (new Date()).getTime();\r\n    boolean timeout = false;\r\n    BlockingStateChangeListener listener = new BlockingStateChangeListener();\r\n    Set<GenericItem> items = getAllItems(widgets);\r\n    for (GenericItem item : items) {\r\n        item.addStateChangeListener(listener);\r\n    }\r\n    while (!listener.hasChangeOccurred() && !timeout) {\r\n        timeout = (new Date()).getTime() - startTime > TIMEOUT_IN_MS;\r\n        try {\r\n            Thread.sleep(300);\r\n        } catch (InterruptedException e) {\r\n            timeout = true;\r\n            break;\r\n        }\r\n    }\r\n    for (GenericItem item : items) {\r\n        item.removeStateChangeListener(listener);\r\n    }\r\n    return timeout;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.model.HmChannel.setInitialized",
	"Comment": "sets the flag, if the values for all datapoints has been loaded.",
	"Method": "void setInitialized(boolean initialized){\r\n    this.initialized = initialized;\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.EquipmentSlotType.not",
	"Comment": "create an equipmentslottype property which matches equipmentslottypeproperties with unequal value.",
	"Method": "EquipmentSlotType not(Object value){\r\n    return new EquipmentSlotType(value, Operator.NOTEQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.provider.file.AbstractFileProvider.removeResources",
	"Comment": "removes resources that were loaded from the specified file or directory when the file or directory disappears.",
	"Method": "void removeResources(File file){\r\n    String path = file.getAbsolutePath();\r\n    for (URL key : providerPortfolio.keySet()) {\r\n        try {\r\n            File f = new File(key.toURI());\r\n            if (f.getAbsolutePath().startsWith(path)) {\r\n                List<String> portfolio = providerPortfolio.remove(key);\r\n                removeElements(portfolio);\r\n            }\r\n        } catch (URISyntaxException e) {\r\n            logger.debug(\"Can't create a URI\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.events.ThingEventFactory.createStatusInfoEvent",
	"Comment": "creates a new thing status info event based on a thing uid and a thing status info object.",
	"Method": "Event createStatusInfoEvent(String topic,String payload,ThingStatusInfoEvent createStatusInfoEvent,ThingUID thingUID,ThingStatusInfo thingStatusInfo){\r\n    checkNotNull(thingUID, \"thingUID\");\r\n    checkNotNull(thingStatusInfo, \"thingStatusInfo\");\r\n    String topic = buildTopic(THING_STATUS_INFO_EVENT_TOPIC, thingUID);\r\n    String payload = serializePayload(thingStatusInfo);\r\n    return new ThingStatusInfoEvent(topic, payload, thingUID, thingStatusInfo);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.client.RpcClient.setDatapointValue",
	"Comment": "sets the value of the datapoint using the provided rx transmission mode.",
	"Method": "void setDatapointValue(HmDatapoint dp,Object value,String rxMode){\r\n    if (dp.isIntegerType() && value instanceof Double) {\r\n        value = ((Number) value).intValue();\r\n    }\r\n    RpcRequest<T> request;\r\n    if (HmParamsetType.VALUES == dp.getParamsetType()) {\r\n        request = createRpcRequest(\"setValue\");\r\n        request.addArg(getRpcAddress(dp.getChannel().getDevice().getAddress()) + getChannelSuffix(dp.getChannel()));\r\n        request.addArg(dp.getName());\r\n        request.addArg(value);\r\n        configureRxMode(request, rxMode);\r\n    } else {\r\n        request = createRpcRequest(\"putParamset\");\r\n        request.addArg(getRpcAddress(dp.getChannel().getDevice().getAddress()) + getChannelSuffix(dp.getChannel()));\r\n        request.addArg(HmParamsetType.MASTER.toString());\r\n        Map<String, Object> paramSet = new HashMap<String, Object>();\r\n        paramSet.put(dp.getName(), value);\r\n        request.addArg(paramSet);\r\n        configureRxMode(request, rxMode);\r\n    }\r\n    sendMessage(config.getRpcPort(dp.getChannel()), request);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.common.QueueingThreadPoolExecutor.setRejectedExecutionHandler",
	"Comment": "this implementation does not allow setting a custom handler.",
	"Method": "void setRejectedExecutionHandler(RejectedExecutionHandler handler){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.timeout.TimeoutTest.testFutureWithLongerTime",
	"Comment": "future try to get result wait a longer time than specified timeout in invokewithfuture",
	"Method": "void testFutureWithLongerTime(){\r\n    RequestBody b4 = new RequestBody(4, \"Hello world!\");\r\n    Object obj = null;\r\n    try {\r\n        RpcResponseFuture future = client.invokeWithFuture(addr, b4, timeout);\r\n        obj = future.get(timeout + 100);\r\n        Assert.fail(\"Should not reach here!\");\r\n    } catch (InvokeTimeoutException e) {\r\n        Assert.assertNull(obj);\r\n    } catch (RemotingException e) {\r\n        logger.error(\"Other RemotingException but InvokeTimeoutException occurred in future\", e);\r\n        Assert.fail(\"Should not reach here!\");\r\n    } catch (InterruptedException e) {\r\n        logger.error(\"InterruptedException in sync\", e);\r\n        Assert.fail(\"Should not reach here!\");\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.CommandlineRuleImporter.importRules",
	"Comment": "this method is responsible for importing a set of rules from a specified file or url resource.",
	"Method": "Set<Rule> importRules(String parserType,URL url){\r\n    Parser<Rule> parser = parsers.get(parserType);\r\n    if (parser != null) {\r\n        InputStreamReader inputStreamReader = new InputStreamReader(new BufferedInputStream(url.openStream()));\r\n        try {\r\n            return importData(url, parser, inputStreamReader);\r\n        } finally {\r\n            inputStreamReader.close();\r\n        }\r\n    } else {\r\n        throw new ParsingException(new ParsingNestedException(ParsingNestedException.RULE, null, new Exception(\"Parser \" + parserType + \" not available\")));\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.openweathermap.internal.utils.ByteArrayFileCache.getUniqueFileName",
	"Comment": "creates a unique file name from the key with which the file is to be associated.",
	"Method": "String getUniqueFileName(String key){\r\n    try {\r\n        byte[] bytesOfFileName = key.getBytes(StandardCharsets.UTF_8);\r\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\r\n        byte[] md5Hash = md.digest(bytesOfFileName);\r\n        BigInteger bigInt = new BigInteger(1, md5Hash);\r\n        StringBuilder fileNameHash = new StringBuilder(bigInt.toString(16));\r\n        while (fileNameHash.length() < 32) {\r\n            fileNameHash.insert(0, \"0\");\r\n        }\r\n        return fileNameHash.toString();\r\n    } catch (NoSuchAlgorithmException ex) {\r\n        logger.error(\"Could not create MD5 hash for key '{}'\", key, ex);\r\n        return key.toString();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.structure.scene.InternalScene.deviceSceneChanged",
	"Comment": "this method has a device to call, if this scene was activated and the device state has changed.",
	"Method": "void deviceSceneChanged(short sceneNumber){\r\n    if (this.sceneID != sceneNumber) {\r\n        if (active) {\r\n            deviceHasChanged = true;\r\n            active = false;\r\n            informListener();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.Utils.filterList",
	"Comment": "this method uses the map, indicated by the parameter listobjects for filtering the map, indicated by theparameter listuids. after that the map with uids of the objects will correspond to the map with theobjects.",
	"Method": "Map<String, String> filterList(Map<String, ?> listObjects,Map<String, String> listUIDs){\r\n    Hashtable<String, String> filtered = new Hashtable<String, String>();\r\n    for (final Entry<String, String> entry : listUIDs.entrySet()) {\r\n        final String id = entry.getKey();\r\n        final String uid = entry.getValue();\r\n        Object obj = listObjects.get(uid);\r\n        if (obj != null) {\r\n            filtered.put(id, uid);\r\n        }\r\n    }\r\n    return filtered;\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.ArmorEquipable.getBoots",
	"Comment": "gets the boots currently being worn by this entity.having the boots as null will result in having nothing equipped in theboots slot.",
	"Method": "Optional<ItemStack> getBoots(){\r\n    return this.getEquipped(EquipmentTypes.BOOTS);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.cache.ExpiringCacheAsync.getLastKnownValue",
	"Comment": "return the raw value, no matter if it is alreadyexpired or still valid.",
	"Method": "V getLastKnownValue(){\r\n    return value;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.persistence.internal.PersistenceManagerImpl.getAllItems",
	"Comment": "retrieves all items for which the persistence configuration applies to.",
	"Method": "Iterable<Item> getAllItems(SimpleItemConfiguration config){\r\n    for (Object itemCfg : config.getItems()) {\r\n        if (itemCfg instanceof SimpleAllConfig) {\r\n            return itemRegistry.getItems();\r\n        }\r\n    }\r\n    Set<Item> items = new HashSet<Item>();\r\n    for (Object itemCfg : config.getItems()) {\r\n        if (itemCfg instanceof SimpleItemConfig) {\r\n            SimpleItemConfig singleItemConfig = (SimpleItemConfig) itemCfg;\r\n            try {\r\n                Item item = itemRegistry.getItem(singleItemConfig.getItem());\r\n                items.add(item);\r\n            } catch (ItemNotFoundException e) {\r\n                logger.debug(\"Item '{}' does not exist.\", singleItemConfig.getItem());\r\n            }\r\n        }\r\n        if (itemCfg instanceof SimpleGroupConfig) {\r\n            SimpleGroupConfig groupItemCfg = (SimpleGroupConfig) itemCfg;\r\n            String groupName = groupItemCfg.getGroup();\r\n            try {\r\n                Item gItem = itemRegistry.getItem(groupName);\r\n                if (gItem instanceof GroupItem) {\r\n                    GroupItem groupItem = (GroupItem) gItem;\r\n                    items.addAll(groupItem.getAllMembers());\r\n                }\r\n            } catch (ItemNotFoundException e) {\r\n                logger.debug(\"Item group '{}' does not exist.\", groupName);\r\n            }\r\n        }\r\n    }\r\n    return items;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.rule.runtime.internal.engine.RuleTriggerManager.clear",
	"Comment": "removes all rules with a given trigger type from the mapping tables.",
	"Method": "void clear(TriggerTypes type){\r\n    switch(type) {\r\n        case STARTUP:\r\n            systemStartupTriggeredRules.clear();\r\n            break;\r\n        case SHUTDOWN:\r\n            systemShutdownTriggeredRules.clear();\r\n            break;\r\n        case UPDATE:\r\n            updateEventTriggeredRules.clear();\r\n            break;\r\n        case CHANGE:\r\n            changedEventTriggeredRules.clear();\r\n            break;\r\n        case COMMAND:\r\n            commandEventTriggeredRules.clear();\r\n            break;\r\n        case TRIGGER:\r\n            triggerEventTriggeredRules.clear();\r\n            break;\r\n        case TIMER:\r\n            for (Rule rule : timerEventTriggeredRules) {\r\n                removeTimerRule(rule);\r\n            }\r\n            timerEventTriggeredRules.clear();\r\n            break;\r\n        case THINGUPDATE:\r\n            thingUpdateEventTriggeredRules.clear();\r\n            break;\r\n        case THINGCHANGE:\r\n            thingChangedEventTriggeredRules.clear();\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.CommandlineRuleImporter.exportRules",
	"Comment": "this method is responsible for exporting a set of rules in a specified file.",
	"Method": "String exportRules(String parserType,Set<Rule> set,File file){\r\n    return super.exportData(parserType, set, file);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.common.HomematicConfig.getTimeout",
	"Comment": "returns the timeout for the communication to a homematic gateway in seconds.",
	"Method": "int getTimeout(){\r\n    return timeout;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.tools.WaitForTopicValue.waitForTopicValueAsync",
	"Comment": "return a future that completes successfully with a topic value or fails exceptionally with a timeout exception.",
	"Method": "CompletableFuture<String> waitForTopicValueAsync(ScheduledExecutorService scheduler,int timeoutInMS){\r\n    scheduler.schedule(this::timeout, timeoutInMS, TimeUnit.MILLISECONDS);\r\n    return subscripeFuture.thenCompose(b -> future);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.updatedSince",
	"Comment": "checks if the state of a given item has been updated since a certain point in time.the default persistence service is used.",
	"Method": "Boolean updatedSince(Item item,AbstractInstant timestamp,Boolean updatedSince,Item item,AbstractInstant timestamp,String serviceId){\r\n    Iterable<HistoricItem> result = getAllStatesSince(item, timestamp, serviceId);\r\n    if (result.iterator().hasNext()) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.sonos.internal.handler.ZonePlayerHandler.playFavorite",
	"Comment": "this will attempt to match the station string with a entry in thefavorites list, this supports both single entries and playlists",
	"Method": "void playFavorite(Command command){\r\n    if (command instanceof StringType) {\r\n        String favorite = command.toString();\r\n        List<SonosEntry> favorites = getFavorites();\r\n        SonosEntry theEntry = null;\r\n        for (SonosEntry entry : favorites) {\r\n            if (entry.getTitle().equals(favorite)) {\r\n                theEntry = entry;\r\n                break;\r\n            }\r\n        }\r\n        if (theEntry != null) {\r\n            try {\r\n                ZonePlayerHandler coordinator = getCoordinatorHandler();\r\n                if (theEntry.getResourceMetaData() != null && theEntry.getResourceMetaData().getUpnpClass().startsWith(\"object.container\")) {\r\n                    coordinator.removeAllTracksFromQueue();\r\n                    coordinator.addURIToQueue(theEntry);\r\n                    coordinator.setCurrentURI(QUEUE_URI + coordinator.getUDN() + \"#0\", \"\");\r\n                    String firstTrackNumberEnqueued = stateMap.get(\"FirstTrackNumberEnqueued\");\r\n                    if (firstTrackNumberEnqueued != null) {\r\n                        coordinator.seek(\"TRACK_NR\", firstTrackNumberEnqueued);\r\n                    }\r\n                } else {\r\n                    coordinator.setCurrentURI(theEntry);\r\n                }\r\n                coordinator.play();\r\n            } catch (IllegalStateException e) {\r\n                logger.debug(\"Cannot paly favorite ({})\", e.getMessage());\r\n            }\r\n        } else {\r\n            logger.debug(\"Favorite '{}' not found\", favorite);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.core.internal.composite.CompositeActionHandler.getCompositeOutputMap",
	"Comment": "create a map of links between child outputs and parent outputs. these links are base on the refecences defined inthe outputs of parent action.",
	"Method": "Map<String, Output> getCompositeOutputMap(List<Output> outputs){\r\n    Map<String, Output> result = new HashMap<String, Output>(11);\r\n    if (outputs != null) {\r\n        for (Output output : outputs) {\r\n            String refs = output.getReference();\r\n            if (refs != null) {\r\n                String ref;\r\n                StringTokenizer st = new StringTokenizer(refs, \",\");\r\n                while (st.hasMoreTokens()) {\r\n                    ref = st.nextToken().trim();\r\n                    int i = ref.indexOf('.');\r\n                    if (i != -1) {\r\n                        int j = ReferenceResolver.getNextRefToken(ref, i + 1);\r\n                        if (j != -1) {\r\n                            ref = ref.substring(0, j);\r\n                        }\r\n                    }\r\n                    result.put(ref, output);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.binding.BaseThingHandler.isLinked",
	"Comment": "returns whether at least one item is linked for the given uid of the channel.",
	"Method": "boolean isLinked(String channelId,boolean isLinked,ChannelUID channelUID){\r\n    if (callback != null) {\r\n        return callback.isChannelLinked(channelUID);\r\n    } else {\r\n        logger.warn(\"Handler {} of thing {} tried checking if channel {} is linked although the handler was already disposed.\", this.getClass().getSimpleName(), channelUID.getThingUID(), channelUID.getId());\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.UidUtils.generateChannelTypeUID",
	"Comment": "generates the channeltypeuid for the given datapoint with devicetype, channelnumber and datapointname.",
	"Method": "ChannelTypeUID generateChannelTypeUID(HmDatapoint dp){\r\n    return new ChannelTypeUID(BINDING_ID, String.format(\"%s_%s_%s\", dp.getChannel().getDevice().getType(), dp.getChannel().getNumber(), dp.getName()));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bosesoundtouch.internal.CommandExecutor.setCurrentContentItem",
	"Comment": "sets the current contentitem if it is valid, and inits an update of the operating values",
	"Method": "void setCurrentContentItem(ContentItem contentItem){\r\n    if ((contentItem != null) && (contentItem.isValid())) {\r\n        ContentItem psFound = null;\r\n        if (handler.getPresetContainer() != null) {\r\n            Collection<ContentItem> listOfPresets = handler.getPresetContainer().getAllPresets();\r\n            for (ContentItem ps : listOfPresets) {\r\n                if (ps.isPresetable()) {\r\n                    if (ps.getLocation().equals(contentItem.getLocation())) {\r\n                        psFound = ps;\r\n                    }\r\n                }\r\n            }\r\n            int presetID = 0;\r\n            if (psFound != null) {\r\n                presetID = psFound.getPresetID();\r\n            }\r\n            contentItem.setPresetID(presetID);\r\n            currentContentItem = contentItem;\r\n        }\r\n    }\r\n    updateOperatingValues();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.openweathermap.internal.utils.ByteArrayFileCache.put",
	"Comment": "adds a file to the cache. if the cache previously contained a file for the key, the old file is replaced by thenew content.",
	"Method": "void put(String key,byte[] content){\r\n    writeFile(getUniqueFile(key), content);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.core.internal.ModuleImpl.setDescription",
	"Comment": "this method is used for setting the description of the moduleimpl.",
	"Method": "void setDescription(String description){\r\n    this.description = description;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.discovery.usbserial.linuxsysfs.internal.SysfsUsbSerialScanner.getSerialPortInfos",
	"Comment": "gets the set of all found serial ports, by searching through the tty devices directory in the sysfs andchecking for each found serial port if the device file in the devices folder is both readable and writable.",
	"Method": "Set<SerialPortInfo> getSerialPortInfos(){\r\n    Set<SerialPortInfo> result = new HashSet();\r\n    try (DirectoryStream<Path> sysfsTtyPaths = newDirectoryStream(Paths.get(sysfsTtyDevicesDirectory))) {\r\n        for (Path sysfsTtyPath : sysfsTtyPaths) {\r\n            String serialPortName = sysfsTtyPath.getFileName().toString();\r\n            Path devicePath = Paths.get(devDirectory).resolve(serialPortName);\r\n            Path sysfsDevicePath = getSysfsDevicePath(sysfsTtyPath);\r\n            if (sysfsDevicePath != null && isReadable(devicePath) && isWritable(devicePath)) {\r\n                result.add(new SerialPortInfo(devicePath, sysfsDevicePath));\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.rule.runtime.internal.engine.RuleTriggerManager.getRules",
	"Comment": "returns all rules for which the trigger condition is true for the given type and channel.",
	"Method": "Iterable<Rule> getRules(TriggerTypes type,Iterable<Rule> getRules,TriggerTypes triggerType,Item item,State state,Iterable<Rule> getRules,TriggerTypes triggerType,Item item,State oldState,State newState,Iterable<Rule> getRules,TriggerTypes triggerType,Item item,Command command,Iterable<Rule> getRules,TriggerTypes triggerType,String channel,String event,Iterable<Rule> getRules,TriggerTypes triggerType,String thingUid,ThingStatus state,Iterable<Rule> getRules,TriggerTypes triggerType,String thingUid,ThingStatus oldState,ThingStatus newState){\r\n    return internalGetThingRules(triggerType, thingUid, oldState, newState);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.handler.HueLightHandler.cancelScheduledFuture",
	"Comment": "this method will cancel previously scheduled alert item staterestoration.",
	"Method": "void cancelScheduledFuture(){\r\n    if (scheduledFuture != null) {\r\n        scheduledFuture.cancel(true);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.cache.ExpiringCacheMap.remove",
	"Comment": "removes the item associated with the given key from the cache.",
	"Method": "void remove(K key){\r\n    items.remove(key);\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.living.Living.health",
	"Comment": "returns the health amount.the range of the health depends on the object on which thismethod is defined. for players in minecraft, the nominal range isbetween 0 and 20, inclusive, but the range can be adjusted.convention dictates that health does not follow below 0 but thisconvention may be broken.",
	"Method": "MutableBoundedValue<Double> health(){\r\n    return getValue(Keys.HEALTH).get();\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.Transform.setPosition",
	"Comment": "creates a copy of this transform while setting the position of the newone.",
	"Method": "Transform<E> setPosition(Vector3d position){\r\n    checkNotNull(position, \"position\");\r\n    return new Transform(getExtent(), position, getRotation(), getScale());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.model.HmDevice.isUpdatePending",
	"Comment": "returns true, if the gateway has a update to transfer to the device.",
	"Method": "boolean isUpdatePending(){\r\n    return isStatusDatapointEnabled(DATAPOINT_NAME_UPDATE_PENDING);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.CommandlineTemplateProvider.importTemplates",
	"Comment": "this method is responsible for importing a set of ruletemplates from a specified file or url resource.",
	"Method": "Set<RuleTemplate> importTemplates(String parserType,URL url){\r\n    Parser<RuleTemplate> parser = parsers.get(parserType);\r\n    if (parser != null) {\r\n        InputStreamReader inputStreamReader = new InputStreamReader(new BufferedInputStream(url.openStream()));\r\n        try {\r\n            return importData(url, parser, inputStreamReader);\r\n        } finally {\r\n            inputStreamReader.close();\r\n        }\r\n    } else {\r\n        throw new ParsingException(new ParsingNestedException(ParsingNestedException.TEMPLATE, null, new Exception(\"Parser \" + parserType + \" not available\")));\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.ui.internal.proxy.AsyncProxyServlet.copyRequestHeaders",
	"Comment": "add basic authentication header to request if user and password are specified in uri.",
	"Method": "void copyRequestHeaders(HttpServletRequest clientRequest,Request proxyRequest){\r\n    super.copyRequestHeaders(clientRequest, proxyRequest);\r\n    service.maybeAppendAuthHeader(service.uriFromRequest(clientRequest), proxyRequest);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.sse.internal.util.SseUtil.shouldAsyncBlock",
	"Comment": "returns true if the current thread is processing an sse request thatshould block.",
	"Method": "boolean shouldAsyncBlock(){\r\n    return blockingSseEnabled.get().booleanValue();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.test.java.JavaTest.waitFor",
	"Comment": "wait until the condition is fulfilled or the timeout is reached.",
	"Method": "boolean waitFor(BooleanSupplier condition,boolean waitFor,BooleanSupplier condition,long timeout,long sleepTime){\r\n    int waitingTime = 0;\r\n    boolean rv;\r\n    while (!(rv = condition.getAsBoolean()) && waitingTime < timeout) {\r\n        waitingTime += sleepTime;\r\n        internalSleep(sleepTime);\r\n    }\r\n    return rv;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.storage.json.internal.JsonStorageService.urlEscapeUnwantedChars",
	"Comment": "escapes all invalid url characters and strips the maximum length to 127 to be used as a file name",
	"Method": "String urlEscapeUnwantedChars(String s){\r\n    String result;\r\n    try {\r\n        result = URLEncoder.encode(s, \"UTF-8\");\r\n    } catch (UnsupportedEncodingException e) {\r\n        logger.warn(\"Encoding UTF-8 is not supported, might generate invalid filenames.\");\r\n        result = s;\r\n    }\r\n    int length = Math.min(result.length(), MAX_FILENAME_LENGTH);\r\n    return result.substring(0, length);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.persistence.internal.PersistenceManagerImpl.hasStrategy",
	"Comment": "checks if a given persistence configuration entry has a certain strategy for the given service",
	"Method": "boolean hasStrategy(String serviceName,SimpleItemConfiguration itemConfig,SimpleStrategy strategy){\r\n    final PersistenceServiceConfiguration config = persistenceServiceConfigs.get(serviceName);\r\n    if (config.getDefaults().contains(strategy) && itemConfig.getStrategies().isEmpty()) {\r\n        return true;\r\n    } else {\r\n        for (SimpleStrategy s : itemConfig.getStrategies()) {\r\n            if (s.equals(strategy)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.cache.ExpiringCacheAsync.getCurrentNanoTime",
	"Comment": "returns an arbitrary time reference in nanoseconds.this is used for the cache to determine if a value has expired.",
	"Method": "long getCurrentNanoTime(){\r\n    return System.nanoTime();\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.ArmorEquipable.getChestplate",
	"Comment": "gets the chestplate currently being worn by this entity.having the chestplate as null will result in having nothing equippedin the chestplate slot.",
	"Method": "Optional<ItemStack> getChestplate(){\r\n    return this.getEquipped(EquipmentTypes.CHESTPLATE);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.lifx.internal.fields.Field.bytes",
	"Comment": "converts the given value to a bytebuffer. actual behavior is determinedby the concrete implementation.",
	"Method": "ByteBuffer bytes(T value){\r\n    ByteBuffer buf = bytesInternal(value);\r\n    buf.rewind();\r\n    return buf;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.openweathermap.internal.handler.AbstractOpenWeatherMapHandler.updateChannels",
	"Comment": "updates all channels of this handler from the latest openweathermap data retrieved.",
	"Method": "void updateChannels(){\r\n    for (Channel channel : getThing().getChannels()) {\r\n        ChannelUID channelUID = channel.getUID();\r\n        if (ChannelKind.STATE.equals(channel.getKind()) && channelUID.isInGroup() && channelUID.getGroupId() != null && isLinked(channelUID)) {\r\n            updateChannel(channelUID);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.rule.runtime.internal.engine.RuleTriggerManager.removeRule",
	"Comment": "removes a given rule from the mapping tables of a certain trigger type",
	"Method": "void removeRule(TriggerTypes type,Rule rule){\r\n    switch(type) {\r\n        case STARTUP:\r\n            systemStartupTriggeredRules.remove(rule);\r\n            break;\r\n        case SHUTDOWN:\r\n            systemShutdownTriggeredRules.remove(rule);\r\n            break;\r\n        case UPDATE:\r\n            for (Set<Rule> rules : updateEventTriggeredRules.values()) {\r\n                rules.remove(rule);\r\n            }\r\n            break;\r\n        case CHANGE:\r\n            for (Set<Rule> rules : changedEventTriggeredRules.values()) {\r\n                rules.remove(rule);\r\n            }\r\n            break;\r\n        case COMMAND:\r\n            for (Set<Rule> rules : commandEventTriggeredRules.values()) {\r\n                rules.remove(rule);\r\n            }\r\n            break;\r\n        case TRIGGER:\r\n            for (Set<Rule> rules : triggerEventTriggeredRules.values()) {\r\n                rules.remove(rule);\r\n            }\r\n            break;\r\n        case TIMER:\r\n            timerEventTriggeredRules.remove(rule);\r\n            removeTimerRule(rule);\r\n            break;\r\n        case THINGUPDATE:\r\n            for (Set<Rule> rules : thingUpdateEventTriggeredRules.values()) {\r\n                rules.remove(rule);\r\n            }\r\n            break;\r\n        case THINGCHANGE:\r\n            for (Set<Rule> rules : thingChangedEventTriggeredRules.values()) {\r\n                rules.remove(rule);\r\n            }\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.convention.homie300.Node.stop",
	"Comment": "unsubscribe from node attribute and also all property attributes and the property value",
	"Method": "CompletableFuture<@Nullable Void> stop(){\r\n    return attributes.unsubscribe().thenCompose(b -> CompletableFuture.allOf(properties.stream().map(p -> p.stop()).toArray(CompletableFuture[]::new)));\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.Entity.getNearbyEntities",
	"Comment": "gets the nearby entities that satisfy the desired predicate.",
	"Method": "Collection<Entity> getNearbyEntities(double distance,Collection<Entity> getNearbyEntities,Predicate<Entity> predicate){\r\n    checkNotNull(predicate, \"Null predicate!\");\r\n    return getWorld().getEntities(predicate::test);\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.RpcRemoting.invokeWithFuture",
	"Comment": "rpc invocation with future returned.notice! do not modify the request object concurrently when this method is called.",
	"Method": "RpcResponseFuture invokeWithFuture(String addr,Object request,InvokeContext invokeContext,int timeoutMillis,RpcResponseFuture invokeWithFuture,Url url,Object request,InvokeContext invokeContext,int timeoutMillis,RpcResponseFuture invokeWithFuture,Connection conn,Object request,InvokeContext invokeContext,int timeoutMillis){\r\n    RemotingCommand requestCommand = toRemotingCommand(request, conn, invokeContext, timeoutMillis);\r\n    preProcessInvokeContext(invokeContext, requestCommand, conn);\r\n    InvokeFuture future = super.invokeWithFuture(conn, requestCommand, timeoutMillis);\r\n    return new RpcResponseFuture(RemotingUtil.parseRemoteAddress(conn.getChannel()), future);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.sonos.internal.SonosEntry.getResourceMetaData",
	"Comment": "the resourcemetadata field from the resmd parent, this will be login info forstreaming accounts to use in favorites",
	"Method": "SonosResourceMetaData getResourceMetaData(){\r\n    return resourceMetaData;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.convention.homeassistant.CFactory.createComponent",
	"Comment": "create a ha mqtt component by a given channel configuration.",
	"Method": "AbstractComponent createComponent(ThingUID thingUID,HaID haID,String configJSON,ChannelStateUpdateListener channelStateUpdateListener,AbstractComponent createComponent,String basetopic,Channel channel,ChannelStateUpdateListener channelStateUpdateListener){\r\n    HaID haID = new HaID(basetopic, channel.getUID());\r\n    ThingUID thingUID = channel.getUID().getThingUID();\r\n    String configJSON = (String) channel.getConfiguration().get(\"config\");\r\n    if (configJSON == null) {\r\n        logger.warn(\"Provided channel does not have a 'config' configuration key!\");\r\n        return null;\r\n    }\r\n    try {\r\n        switch(haID.component) {\r\n            case \"alarm_control_panel\":\r\n                return new ComponentAlarmControlPanel(thingUID, haID, configJSON, channelStateUpdateListener);\r\n            case \"binary_sensor\":\r\n                return new ComponentBinarySensor(thingUID, haID, configJSON, channelStateUpdateListener);\r\n            case \"camera\":\r\n                return new ComponentCamera(thingUID, haID, configJSON, channelStateUpdateListener);\r\n            case \"cover\":\r\n                return new ComponentCover(thingUID, haID, configJSON, channelStateUpdateListener);\r\n            case \"fan\":\r\n                return new ComponentFan(thingUID, haID, configJSON, channelStateUpdateListener);\r\n            case \"climate\":\r\n                return new ComponentClimate(thingUID, haID, configJSON, channelStateUpdateListener);\r\n            case \"light\":\r\n                return new ComponentLight(thingUID, haID, configJSON, channelStateUpdateListener);\r\n            case \"lock\":\r\n                return new ComponentLock(thingUID, haID, configJSON, channelStateUpdateListener);\r\n            case \"sensor\":\r\n                return new ComponentSensor(thingUID, haID, configJSON, channelStateUpdateListener);\r\n            case \"switch\":\r\n                return new ComponentSwitch(thingUID, haID, configJSON, channelStateUpdateListener);\r\n        }\r\n    } catch (UnsupportedOperationException e) {\r\n        logger.warn(\"Not supported\", e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.HueBridge.setLightName",
	"Comment": "changes the name of the light and returns the new name.a number will be appended to duplicate names, which may result in a new name exceeding 32 characters.",
	"Method": "String setLightName(HueObject light,String name){\r\n    requireAuthentication();\r\n    String body = gson.toJson(new SetAttributesRequest(name));\r\n    Result result = http.put(getRelativeURL(\"lights/\" + enc(light.getId())), body);\r\n    handleErrors(result);\r\n    List<SuccessResponse> entries = safeFromJson(result.getBody(), SuccessResponse.GSON_TYPE);\r\n    SuccessResponse response = entries.get(0);\r\n    return (String) response.success.get(\"/lights/\" + enc(light.getId()) + \"/name\");\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.persistence.internal.PersistenceManagerImpl.handleStateEvent",
	"Comment": "calls all persistence services which use change or update policy for the given item",
	"Method": "void handleStateEvent(Item item,boolean onlyChanges){\r\n    synchronized (persistenceServiceConfigs) {\r\n        for (Entry<String, PersistenceServiceConfiguration> entry : persistenceServiceConfigs.entrySet()) {\r\n            final String serviceName = entry.getKey();\r\n            final PersistenceServiceConfiguration config = entry.getValue();\r\n            if (persistenceServices.containsKey(serviceName)) {\r\n                for (SimpleItemConfiguration itemConfig : config.getConfigs()) {\r\n                    if (hasStrategy(serviceName, itemConfig, onlyChanges ? SimpleStrategy.Globals.CHANGE : SimpleStrategy.Globals.UPDATE)) {\r\n                        if (appliesToItem(itemConfig, item)) {\r\n                            persistenceServices.get(serviceName).store(item, itemConfig.getAlias());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.MqttBrokerConnection.setKeepAliveInterval",
	"Comment": "set the keep alive interval. the default interval is 60 seconds. if no heartbeat is received within thistimeframe, the connection will be considered dead. set this to a higher value on systems which may not always beable to process the heartbeat in time.",
	"Method": "void setKeepAliveInterval(int keepAliveInterval){\r\n    if (keepAliveInterval <= 0) {\r\n        throw new IllegalArgumentException(\"Keep alive cannot be <=0\");\r\n    }\r\n    this.keepAliveInterval = keepAliveInterval;\r\n}"
}, {
	"Path": "org.xerial.snappy.SnappyFramed.releaseDirectByteBuffer",
	"Comment": "provides jvm implementation specific operation to aggressively release resources associated with buffer.",
	"Method": "void releaseDirectByteBuffer(ByteBuffer buffer){\r\n    assert buffer != null && buffer.isDirect();\r\n    if (SUN_DIRECT_BUFFER != null && SUN_DIRECT_BUFFER.isAssignableFrom(buffer.getClass())) {\r\n        try {\r\n            Object cleaner = SUN_BUFFER_CLEANER.invoke(buffer, (Object[]) null);\r\n            SUN_CLEANER_CLEAN.invoke(cleaner, (Object[]) null);\r\n        } catch (Throwable t) {\r\n            Logger.getLogger(SnappyFramed.class.getName()).log(Level.FINE, \"Exception occurred attempting to clean up Sun specific DirectByteBuffer.\", t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.event.cause.Cause.of",
	"Comment": "constructs a new cause with the specified event context and causes.",
	"Method": "Cause of(EventContext ctx,Object cause,Cause of,EventContext ctx,Object cause,Object causes,Cause of,EventContext ctx,Iterable<Object> iterable){\r\n    checkNotNull(ctx, \"Context\");\r\n    Builder builder = builder();\r\n    for (Object cause : iterable) {\r\n        builder.append(cause);\r\n    }\r\n    return builder.build(ctx);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.discovery.usbserial.linuxsysfs.internal.DeltaUsbSerialScannerTest.testInitialEmptyResult",
	"Comment": "if there are no devices discovered in a first scan, then there is no delta.",
	"Method": "void testInitialEmptyResult(){\r\n    when(usbSerialScanner.scan()).thenReturn(emptySet());\r\n    Delta<UsbSerialDeviceInformation> delta = deltaUsbSerialScanner.scan();\r\n    assertThat(delta.getAdded(), is(empty()));\r\n    assertThat(delta.getRemoved(), is(empty()));\r\n    assertThat(delta.getUnchanged(), is(empty()));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.ntp.handler.NtpHandler.getTime",
	"Comment": "queries the given timeserver hostname and returns the timein milliseconds.",
	"Method": "long getTime(String hostname){\r\n    try {\r\n        NTPUDPClient timeClient = new NTPUDPClient();\r\n        timeClient.setDefaultTimeout(NTP_TIMEOUT);\r\n        InetAddress inetAddress = InetAddress.getByName(hostname);\r\n        TimeInfo timeInfo = timeClient.getTime(inetAddress, port.intValue());\r\n        timeInfo.computeDetails();\r\n        long serverMillis = timeInfo.getReturnTime() + timeInfo.getOffset();\r\n        logger.debug(\"{} Got time update from host '{}': {}.\", getThing().getUID(), hostname, SDF.format(new Date(serverMillis)));\r\n        updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\r\n        return serverMillis;\r\n    } catch (UnknownHostException uhe) {\r\n        logger.debug(\"{} The given hostname '{}' of the timeserver is unknown -> returning current sytem time instead. ({})\", getThing().getUID(), hostname, uhe.getMessage());\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"@text/offline.comm-error-unknown-host [\\\"\" + (hostname == null ? \"null\" : hostname) + \"\\\"]\");\r\n    } catch (IOException ioe) {\r\n        logger.debug(\"{} Couldn't establish network connection to host '{}' -> returning current sytem time instead. ({})\", getThing().getUID(), hostname, ioe.getMessage());\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"@text/offline.comm-error-connection [\\\"\" + (hostname == null ? \"null\" : hostname) + \"\\\"]\");\r\n    }\r\n    return System.currentTimeMillis();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.AutomationCommand.getStackTrace",
	"Comment": "this method is responsible for processing the st option of the command.",
	"Method": "String getStackTrace(Exception e){\r\n    StringBuilder writer = new StringBuilder();\r\n    if (st) {\r\n        StackTraceElement[] ste = e.getStackTrace();\r\n        for (int i = 0; i < ste.length; i++) {\r\n            if (i == 0) {\r\n                writer.append(String.format(\"FAIL : %s\", ste[i].toString() + \"\\n\"));\r\n            } else {\r\n                writer.append(String.format(\"%s\", ste[i].toString() + \"\\n\"));\r\n            }\r\n        }\r\n    } else {\r\n        writer.append(String.format(\"FAIL : %s\", e.getMessage() + \"\\n\"));\r\n    }\r\n    return writer.toString();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.sonos.internal.handler.ZonePlayerHandler.getOtherZoneGroupMembers",
	"Comment": "returns a list of other zone group members this particular player is member ofor empty list if the players is not assigned to any group",
	"Method": "List<String> getOtherZoneGroupMembers(){\r\n    List<String> zoneGroupMembers = getZoneGroupMembers();\r\n    zoneGroupMembers.remove(getUDN());\r\n    return zoneGroupMembers;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.sitemap.internal.PageChangeListener.getAllItems",
	"Comment": "collects all items that are represented by a given list of widgets",
	"Method": "Set<Item> getAllItems(EList<Widget> widgets){\r\n    Set<Item> items = new HashSet<Item>();\r\n    if (itemUIRegistry != null) {\r\n        for (Widget widget : widgets) {\r\n            addItemWithName(items, widget.getItem());\r\n            if (widget instanceof Frame) {\r\n                items.addAll(getAllItems(((Frame) widget).getChildren()));\r\n            }\r\n            for (VisibilityRule rule : widget.getVisibility()) {\r\n                addItemWithName(items, rule.getItem());\r\n            }\r\n            for (ColorArray rule : widget.getLabelColor()) {\r\n                addItemWithName(items, rule.getItem());\r\n            }\r\n            for (ColorArray rule : widget.getValueColor()) {\r\n                addItemWithName(items, rule.getItem());\r\n            }\r\n        }\r\n    }\r\n    return items;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.generic.MqttChannelStateDescriptionProvider.setDescription",
	"Comment": "set a state description for a channel. this description will be used when preparing the channel state bythe framework for presentation. a previous description, if existed, will be replaced.",
	"Method": "void setDescription(ChannelUID channelUID,StateDescription description){\r\n    logger.debug(\"Adding state description for channel {}\", channelUID);\r\n    descriptions.put(channelUID, description);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.handler.HomematicBridgeHandler.setOfflineStatus",
	"Comment": "sets the offline status for all things of this bridge that has been removed from the gateway.",
	"Method": "void setOfflineStatus(){\r\n    for (Thing hmThing : getThing().getThings()) {\r\n        try {\r\n            gateway.getDevice(UidUtils.getHomematicAddress(hmThing));\r\n        } catch (HomematicClientException e) {\r\n            if (hmThing.getHandler() != null) {\r\n                ((HomematicThingHandler) hmThing.getHandler()).handleRemoval();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.model.HmChannel.isInitialized",
	"Comment": "returns true, if the values for all datapoints has been loaded.",
	"Method": "boolean isInitialized(){\r\n    return initialized;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.changedSince",
	"Comment": "checks if the state of a given item has changed since a certain point in time.the default persistence service is used.",
	"Method": "Boolean changedSince(Item item,AbstractInstant timestamp,Boolean changedSince,Item item,AbstractInstant timestamp,String serviceId){\r\n    Iterable<HistoricItem> result = getAllStatesSince(item, timestamp, serviceId);\r\n    Iterator<HistoricItem> it = result.iterator();\r\n    HistoricItem itemThen = historicState(item, timestamp);\r\n    if (itemThen == null) {\r\n        return it.hasNext();\r\n    }\r\n    State state = itemThen.getState();\r\n    while (it.hasNext()) {\r\n        HistoricItem hItem = it.next();\r\n        if (state != null && !hItem.getState().equals(state)) {\r\n            return true;\r\n        }\r\n        state = hItem.getState();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "ws.com.google.android.mms.pdu.PduComposer.make",
	"Comment": "make the message. no need to check whether mandatory fields are set,because the constructors of outgoing pdus are taking care of this.",
	"Method": "byte[] make(){\r\n    int type = mPdu.getMessageType();\r\n    switch(type) {\r\n        case PduHeaders.MESSAGE_TYPE_SEND_REQ:\r\n            if (makeSendReqPdu() != PDU_COMPOSE_SUCCESS) {\r\n                return null;\r\n            }\r\n            break;\r\n        case PduHeaders.MESSAGE_TYPE_NOTIFYRESP_IND:\r\n            if (makeNotifyResp() != PDU_COMPOSE_SUCCESS) {\r\n                return null;\r\n            }\r\n            break;\r\n        case PduHeaders.MESSAGE_TYPE_ACKNOWLEDGE_IND:\r\n            if (makeAckInd() != PDU_COMPOSE_SUCCESS) {\r\n                return null;\r\n            }\r\n            break;\r\n        case PduHeaders.MESSAGE_TYPE_READ_REC_IND:\r\n            if (makeReadRecInd() != PDU_COMPOSE_SUCCESS) {\r\n                return null;\r\n            }\r\n            break;\r\n        default:\r\n            return null;\r\n    }\r\n    Log.w(\"PduComposer\", \"Returning: \" + mMessage.size() + \" bytes...\");\r\n    return mMessage.toByteArray();\r\n}"
}, {
	"Path": "org.spongepowered.api.command.CommandResult.successCount",
	"Comment": "returns a result indicating the command was processed with a singlesuccess.",
	"Method": "CommandResult successCount(int count,Builder successCount,Integer successCount){\r\n    return builder().successCount(count).build();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.sitemap.SitemapSubscriptionService.setPageId",
	"Comment": "updates the subscription to send events for the provided page id.",
	"Method": "void setPageId(String subscriptionId,String sitemapName,String pageId){\r\n    SitemapSubscriptionCallback callback = callbacks.get(subscriptionId);\r\n    if (callback != null) {\r\n        String oldSitemapPage = pageOfSubscription.remove(subscriptionId);\r\n        if (oldSitemapPage != null) {\r\n            removeCallbackFromListener(oldSitemapPage, callback);\r\n        }\r\n        addCallbackToListener(sitemapName, pageId, callback);\r\n        pageOfSubscription.put(subscriptionId, getValue(sitemapName, pageId));\r\n        logger.debug(\"Subscription {} changed to page {} of sitemap {} ({} active subscriptions}\", new Object[] { subscriptionId, pageId, sitemapName, callbacks.size() });\r\n    } else {\r\n        throw new IllegalArgumentException(\"Subscription \" + subscriptionId + \" does not exist!\");\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.GenericArguments.optional",
	"Comment": "make the provided command element optional.this means the command element is not required. however, if theelement is provided with invalid format and there are no more argsspecified, any errors will still be passed on.",
	"Method": "CommandElement optional(CommandElement element,CommandElement optional,CommandElement element,Object value){\r\n    return new OptionalCommandElement(element, value, false);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.common.HomematicConfig.isUnpairOnDeletion",
	"Comment": "returns if devices are unpaired from the gateway when their corresponding things are removed",
	"Method": "boolean isUnpairOnDeletion(){\r\n    return unpairOnDeletion;\r\n}"
}, {
	"Path": "org.spongepowered.api.service.permission.Subject.getParents",
	"Comment": "return all parents that this group has in the given context combination.this must include inherited values if the permissionsservice supports inheritance.",
	"Method": "List<SubjectReference> getParents(List<SubjectReference> getParents,Set<Context> contexts){\r\n    return getParents(getActiveContexts());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.firmware.FirmwareUpdateProgressInfo.getFirmwareVersion",
	"Comment": "returns the firmware version of the firmware that is updated.",
	"Method": "String getFirmwareVersion(){\r\n    return firmwareVersion;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.i18n.I18nUtil.stripConstantOr",
	"Comment": "if key is a constant strip the constant part, otherwise use the supplier provided string.",
	"Method": "String stripConstantOr(String key,Supplier<String> supplier){\r\n    if (key != null && key.startsWith(CONSTANT_PATTERN)) {\r\n        return stripConstant(key);\r\n    } else {\r\n        return supplier.get();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.CommandlineTemplateProvider.exportTemplates",
	"Comment": "this method is responsible for exporting a set of ruletemplates in a specified file.",
	"Method": "String exportTemplates(String parserType,Set<RuleTemplate> set,File file){\r\n    return super.exportData(parserType, set, file);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.MqttBrokerConnection.isSecure",
	"Comment": "return true if this is or will be an encrypted connection to the broker",
	"Method": "boolean isSecure(){\r\n    return secure;\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.MappedIntProperty.of",
	"Comment": "create a mappedintproperty property which matches mappedintpropertyproperties with equal value and matching key.",
	"Method": "MappedIntProperty of(Object key,Object value){\r\n    return new MappedIntProperty(key, value, Operator.EQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.transform.AbstractFileTransformationService.getLocalizedProposedFilename",
	"Comment": "returns the name of the localized transformation fileif it actually exists, keeps the original in the other case",
	"Method": "String getLocalizedProposedFilename(String filename,WatchService watchService){\r\n    String extension = FilenameUtils.getExtension(filename);\r\n    String prefix = FilenameUtils.getPath(filename);\r\n    String result = filename;\r\n    if (!prefix.isEmpty()) {\r\n        watchSubDirectory(prefix, watchService);\r\n    }\r\n    if (!filename.matches(\".*_[a-z]{2}.\" + extension + \"$\")) {\r\n        String basename = FilenameUtils.getBaseName(filename);\r\n        String alternateName = prefix + basename + \"_\" + getLocale().getLanguage() + \".\" + extension;\r\n        String alternatePath = getSourcePath() + alternateName;\r\n        File f = new File(alternatePath);\r\n        if (f.exists()) {\r\n            result = alternateName;\r\n        }\r\n    }\r\n    result = getSourcePath() + result;\r\n    return result;\r\n}"
}, {
	"Path": "org.spongepowered.api.command.CommandMessageFormatting.error",
	"Comment": "format text to be output as an error directly to a sender. not necessarywhen creating an exception to be thrown",
	"Method": "Text error(Text error){\r\n    return error.toBuilder().color(TextColors.RED).build();\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.AcceptsItems.of",
	"Comment": "create an acceptsitems property which matches acceptsitems propertieswith containing one or more of the supplied values.",
	"Method": "AcceptsItems of(Object value){\r\n    return new AcceptsItems(value, Operator.EQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.config.Config.getTotalPowerUpdateInterval",
	"Comment": "returns the interval to refresh the total power sensor data.",
	"Method": "int getTotalPowerUpdateInterval(){\r\n    return totalPowerUpdateInterval;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.HueBridge.handleErrors",
	"Comment": "used as assert in all requests to elegantly catch common errors",
	"Method": "void handleErrors(Result result){\r\n    if (result.getResponseCode() != 200) {\r\n        throw new IOException();\r\n    } else {\r\n        try {\r\n            List<ErrorResponse> errors = gson.fromJson(result.getBody(), ErrorResponse.GSON_TYPE);\r\n            if (errors == null) {\r\n                return;\r\n            }\r\n            for (ErrorResponse error : errors) {\r\n                if (error.getType() == null) {\r\n                    continue;\r\n                }\r\n                switch(error.getType()) {\r\n                    case 1:\r\n                        username = null;\r\n                        throw new UnauthorizedException(error.getDescription());\r\n                    case 3:\r\n                        throw new EntityNotAvailableException(error.getDescription());\r\n                    case 7:\r\n                        throw new InvalidCommandException(error.getDescription());\r\n                    case 101:\r\n                        throw new LinkButtonException(error.getDescription());\r\n                    case 201:\r\n                        throw new DeviceOffException(error.getDescription());\r\n                    case 301:\r\n                        throw new GroupTableFullException(error.getDescription());\r\n                    default:\r\n                        throw new ApiException(error.getDescription());\r\n                }\r\n            }\r\n        } catch (JsonParseException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.sample.extension.java.internal.handler.WelcomeHomeActionHandler.getResult",
	"Comment": "this method provides the way to configure the command which to be executed.",
	"Method": "String getResult(Configuration configration){\r\n    return (String) (configration != null ? configration.get(WelcomeHomeActionType.CONFIG_RESULT) : null);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.weatherunderground.handler.WeatherUndergroundHandler.updateChannel",
	"Comment": "update the channel from the last weather underground data retrieved",
	"Method": "void updateChannel(String channelId){\r\n    if (isLinked(channelId)) {\r\n        State state = null;\r\n        if (weatherData != null) {\r\n            if (channelId.startsWith(\"current\")) {\r\n                state = updateCurrentObservationChannel(channelId, weatherData.getCurrent());\r\n            } else if (channelId.startsWith(\"forecast\")) {\r\n                state = updateForecastChannel(channelId, weatherData.getForecast());\r\n            }\r\n        }\r\n        logger.debug(\"Update channel {} with state {}\", channelId, (state == null) ? \"null\" : state.toString());\r\n        if (state != null) {\r\n            updateState(channelId, state);\r\n        } else {\r\n            updateState(channelId, UnDefType.NULL);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.internal.ssl.Pin.isEqual",
	"Comment": "this method is used to determine if the given digest is equal to theone of this pin. if this pin is still learning, it will always return true.",
	"Method": "boolean isEqual(byte[] digestData){\r\n    if (learning) {\r\n        return true;\r\n    }\r\n    return Arrays.equals(pinData, digestData);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.config.Config.getSensordataConnectionTimeout",
	"Comment": "returns the connection timeout for sensor readings from devices.",
	"Method": "int getSensordataConnectionTimeout(){\r\n    return sensordataConnectionTimeout;\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.FallingBlock.canDropAsItem",
	"Comment": "gets whether this falling block can drop as an item if it lands in a waythat it can not be placed.",
	"Method": "Value<Boolean> canDropAsItem(){\r\n    return getValue(Keys.CAN_DROP_AS_ITEM).get();\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.ArmorEquipable.setChestplate",
	"Comment": "sets the chestplate currently being worn by this entity.having the chestplate as null will result in having nothing equippedin the chestplate slot.",
	"Method": "void setChestplate(ItemStack chestplate){\r\n    this.equip(EquipmentTypes.CHESTPLATE, chestplate);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.binding.BaseThingHandler.updateThing",
	"Comment": "informs the framework, that a thing was updated. this method must be called after the configuration or channelswas changed.",
	"Method": "void updateThing(Thing thing){\r\n    if (thing == this.thing) {\r\n        throw new IllegalArgumentException(\"Changes must not be done on the current thing - create a copy, e.g. via editThing()\");\r\n    }\r\n    synchronized (this) {\r\n        if (this.callback != null) {\r\n            this.thing = thing;\r\n            this.callback.thingUpdated(thing);\r\n        } else {\r\n            logger.warn(\"Handler {} tried updating thing {} although the handler was already disposed.\", this.getClass().getSimpleName(), thing.getUID());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.command.spec.CommandSpec.getExecutor",
	"Comment": "gets the active executor for this command. generally not a good idea tocall this directly, unless you are handling arg parsing specially",
	"Method": "CommandExecutor getExecutor(){\r\n    return this.executor;\r\n}"
}, {
	"Path": "org.spongepowered.api.data.DataQuery.getParts",
	"Comment": "gets the parts that make up this query. the returned list is immutable.",
	"Method": "List<String> getParts(){\r\n    return this.parts;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.ConfigUtil.isOSGiConfigParameter",
	"Comment": "we do not want to handle or try to normalize osgi provided configuration parameters",
	"Method": "boolean isOSGiConfigParameter(String name){\r\n    return name.equals(\"objectClass\") || name.equals(\"component.name\") || name.equals(\"component.id\");\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.config.Config.setSensordataRefreshInterval",
	"Comment": "sets the interval in milliseconds to refresh the sensor data.",
	"Method": "void setSensordataRefreshInterval(int sensordataRefreshInterval){\r\n    this.sensordataRefreshInterval = sensordataRefreshInterval;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.client.RpcClient.init",
	"Comment": "register a callback for the specified interface where the homematic gateway can send its events.",
	"Method": "void init(HmInterface hmInterface,String clientId){\r\n    RpcRequest<T> request = createRpcRequest(\"init\");\r\n    request.addArg(getRpcCallbackUrl());\r\n    request.addArg(clientId);\r\n    if (config.getGatewayInfo().isHomegear()) {\r\n        request.addArg(new Integer(0x22));\r\n    }\r\n    sendMessage(config.getRpcPort(hmInterface), request);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.client.RpcClient.isConfigurationChannel",
	"Comment": "checks whether a channel is a configuration channel. the configuration channel of a device encapsulates themaster paramset that does not belong to one of its actual channels.",
	"Method": "boolean isConfigurationChannel(HmChannel channel){\r\n    return channel.getNumber() == CONFIGURATION_CHANNEL_NUMBER;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.UidUtils.getHomematicAddress",
	"Comment": "returns the address of the homematic device from the given thing.",
	"Method": "String getHomematicAddress(Thing thing){\r\n    return thing.getUID().getId();\r\n}"
}, {
	"Path": "org.spongepowered.api.event.cause.EventContext.get",
	"Comment": "gets the value corresponding to the given key from the context.",
	"Method": "Optional<T> get(EventContextKey<T> key){\r\n    checkNotNull(key, \"EventContextKey cannot be null\");\r\n    return Optional.ofNullable((T) this.entries.get(key));\r\n}"
}, {
	"Path": "org.spongepowered.api.service.permission.NodeTree.get",
	"Comment": "returns the value assigned to a specific node, or the nearest parentvalue in the tree if the node itself is undefined.",
	"Method": "Tristate get(String node){\r\n    Iterable<String> parts = NODE_SPLITTER.split(node.toLowerCase());\r\n    Node currentNode = this.rootNode;\r\n    Tristate lastUndefinedVal = Tristate.UNDEFINED;\r\n    for (String str : parts) {\r\n        if (!currentNode.children.containsKey(str)) {\r\n            break;\r\n        }\r\n        currentNode = currentNode.children.get(str);\r\n        if (currentNode.value != Tristate.UNDEFINED) {\r\n            lastUndefinedVal = currentNode.value;\r\n        }\r\n    }\r\n    return lastUndefinedVal;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.server.BinRpcNetworkService.run",
	"Comment": "listening for events and starts the callbackhandler if a event received.",
	"Method": "void run(){\r\n    while (accept) {\r\n        try {\r\n            Socket cs = serverSocket.accept();\r\n            BinRpcResponseHandler rpcHandler = new BinRpcResponseHandler(cs, rpcResponseHandler, config);\r\n            ThreadPoolManager.getPool(RPC_POOL_NAME).execute(rpcHandler);\r\n        } catch (IOException ex) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.CommandContext.hasAny",
	"Comment": "returns whether this context has any value for the given argument key.",
	"Method": "boolean hasAny(String key,boolean hasAny,Text key){\r\n    return hasAny(ArgUtils.textToArgKey(key));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.common.ThreadPoolManager.getPool",
	"Comment": "returns an instance of a cached thread pool service. if it is the first request for the given pool name, theinstance is newly created.",
	"Method": "ExecutorService getPool(String poolName){\r\n    ExecutorService pool = pools.get(poolName);\r\n    if (pool == null) {\r\n        synchronized (pools) {\r\n            pool = pools.get(poolName);\r\n            if (pool == null) {\r\n                int cfg = getConfig(poolName);\r\n                pool = QueueingThreadPoolExecutor.createInstance(poolName, cfg);\r\n                ((ThreadPoolExecutor) pool).setKeepAliveTime(THREAD_TIMEOUT, TimeUnit.SECONDS);\r\n                ((ThreadPoolExecutor) pool).allowCoreThreadTimeOut(true);\r\n                pools.put(poolName, pool);\r\n                LOGGER.debug(\"Created thread pool '{}' with size {}\", new Object[] { poolName, cfg });\r\n            }\r\n        }\r\n    }\r\n    return pool;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.core.internal.item.ItemResource.createOrUpdateItems",
	"Comment": "create or update a list of items by supplying a list of item beans.",
	"Method": "Response createOrUpdateItems(GroupItemDTO @Nullable[] items){\r\n    if (items == null) {\r\n        return Response.status(Status.BAD_REQUEST).build();\r\n    }\r\n    List<GroupItemDTO> wrongTypes = new ArrayList();\r\n    List<Item> activeItems = new ArrayList();\r\n    Map<String, Collection<String>> tagMap = new HashMap();\r\n    for (GroupItemDTO item : items) {\r\n        Item newItem = ItemDTOMapper.map(item, itemBuilderFactory);\r\n        if (newItem == null) {\r\n            wrongTypes.add(item);\r\n            tagMap.put(item.name, item.tags);\r\n        } else {\r\n            activeItems.add(newItem);\r\n        }\r\n    }\r\n    List<Item> createdItems = new ArrayList();\r\n    List<Item> updatedItems = new ArrayList();\r\n    List<Item> failedItems = new ArrayList();\r\n    for (Item activeItem : activeItems) {\r\n        String itemName = activeItem.getName();\r\n        if (getItem(itemName) == null) {\r\n            managedItemProvider.add(activeItem);\r\n            createdItems.add(activeItem);\r\n        } else if (managedItemProvider.get(itemName) != null) {\r\n            managedItemProvider.update(activeItem);\r\n            updatedItems.add(activeItem);\r\n        } else {\r\n            logger.warn(\"Cannot update existing item '{}', because it is not managed.\", itemName);\r\n            failedItems.add(activeItem);\r\n        }\r\n    }\r\n    List<JsonObject> responseList = new ArrayList();\r\n    for (GroupItemDTO item : wrongTypes) {\r\n        responseList.add(buildStatusObject(item.name, \"error\", \"Received HTTP PUT request at '\" + uriInfo.getPath() + \"' with an invalid item type '\" + item.type + \"'.\"));\r\n    }\r\n    for (Item item : failedItems) {\r\n        responseList.add(buildStatusObject(item.getName(), \"error\", \"Cannot update non-managed item\"));\r\n    }\r\n    for (Item item : createdItems) {\r\n        responseList.add(buildStatusObject(item.getName(), \"created\", null));\r\n    }\r\n    for (Item item : updatedItems) {\r\n        responseList.add(buildStatusObject(item.getName(), \"updated\", null));\r\n    }\r\n    return JSONResponse.createResponse(Status.OK, responseList, null);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.openweathermap.internal.handler.OpenWeatherMapWeatherAndForecastHandler.updateCurrentChannel",
	"Comment": "update the channel from the last openweathermap data retrieved.",
	"Method": "void updateCurrentChannel(ChannelUID channelUID){\r\n    String channelId = channelUID.getIdWithoutGroup();\r\n    String channelGroupId = channelUID.getGroupId();\r\n    if (weatherData != null) {\r\n        State state = UnDefType.UNDEF;\r\n        switch(channelId) {\r\n            case CHANNEL_STATION_ID:\r\n                state = getStringTypeState(weatherData.getId().toString());\r\n                break;\r\n            case CHANNEL_STATION_NAME:\r\n                state = getStringTypeState(weatherData.getName());\r\n                break;\r\n            case CHANNEL_STATION_LOCATION:\r\n                state = getPointTypeState(weatherData.getCoord().getLat(), weatherData.getCoord().getLon());\r\n                break;\r\n            case CHANNEL_TIME_STAMP:\r\n                state = getDateTimeTypeState(weatherData.getDt());\r\n                break;\r\n            case CHANNEL_CONDITION:\r\n                state = getStringTypeState(weatherData.getWeather().get(0).getDescription());\r\n                break;\r\n            case CHANNEL_CONDITION_ID:\r\n                state = getStringTypeState(weatherData.getWeather().get(0).getId().toString());\r\n                break;\r\n            case CHANNEL_CONDITION_ICON:\r\n                state = getRawTypeState(OpenWeatherMapConnection.getWeatherIcon(weatherData.getWeather().get(0).getIcon()));\r\n                break;\r\n            case CHANNEL_TEMPERATURE:\r\n                state = getQuantityTypeState(weatherData.getMain().getTemp(), CELSIUS);\r\n                break;\r\n            case CHANNEL_PRESSURE:\r\n                state = getQuantityTypeState(weatherData.getMain().getPressure(), HECTO(PASCAL));\r\n                break;\r\n            case CHANNEL_HUMIDITY:\r\n                state = getQuantityTypeState(weatherData.getMain().getHumidity(), SmartHomeUnits.PERCENT);\r\n                break;\r\n            case CHANNEL_WIND_SPEED:\r\n                state = getQuantityTypeState(weatherData.getWind().getSpeed(), SmartHomeUnits.METRE_PER_SECOND);\r\n                break;\r\n            case CHANNEL_WIND_DIRECTION:\r\n                state = getQuantityTypeState(weatherData.getWind().getDeg(), SmartHomeUnits.DEGREE_ANGLE);\r\n                break;\r\n            case CHANNEL_GUST_SPEED:\r\n                state = getQuantityTypeState(weatherData.getWind().getGust(), SmartHomeUnits.METRE_PER_SECOND);\r\n                break;\r\n            case CHANNEL_CLOUDINESS:\r\n                state = getQuantityTypeState(weatherData.getClouds().getAll(), SmartHomeUnits.PERCENT);\r\n                break;\r\n            case CHANNEL_RAIN:\r\n                state = getQuantityTypeState(weatherData.getRain() == null || weatherData.getRain().get3h() == null ? 0 : weatherData.getRain().get3h(), MILLI(METRE));\r\n                break;\r\n            case CHANNEL_SNOW:\r\n                state = getQuantityTypeState(weatherData.getSnow() == null || weatherData.getSnow().get3h() == null ? 0 : weatherData.getSnow().get3h(), MILLI(METRE));\r\n                break;\r\n        }\r\n        logger.debug(\"Update channel '{}' of group '{}' with new state '{}'.\", channelId, channelGroupId, state);\r\n        updateState(channelUID, state);\r\n    } else {\r\n        logger.debug(\"No weather data available to update channel '{}' of group '{}'.\", channelId, channelGroupId);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.weatherunderground.internal.json.WeatherUndergroundJsonResponse.getErrorType",
	"Comment": "get the error type returned by the weather underground service",
	"Method": "String getErrorType(){\r\n    return (error == null) ? null : error.getType();\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.GenericArguments.optionalWeak",
	"Comment": "make the provided command element optionalthis means the command element is not required.if the argument is provided but of invalid format, it will be skipped.",
	"Method": "CommandElement optionalWeak(CommandElement element,CommandElement optionalWeak,CommandElement element,Object value){\r\n    return new OptionalCommandElement(element, value, true);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.type.AbstractDescriptionType.getDescription",
	"Comment": "returns the human readable description for the according type.",
	"Method": "String getDescription(){\r\n    return this.description;\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.RpcResponseResolver.toThrowable",
	"Comment": "convert remoting response command to throwable if it is a throwable, otherwise return null.",
	"Method": "Throwable toThrowable(ResponseCommand responseCommand){\r\n    RpcResponseCommand resp = (RpcResponseCommand) responseCommand;\r\n    resp.deserialize();\r\n    Object ex = resp.getResponseObject();\r\n    if (ex != null && ex instanceof Throwable) {\r\n        return (Throwable) ex;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.auth.oauth2client.internal.OAuthClientServiceImpl.getInstance",
	"Comment": "it should only be used internally, thus the access is package level",
	"Method": "OAuthClientServiceImpl getInstance(String handle,OAuthStoreHandler storeHandler,int tokenExpiresInSeconds,HttpClientFactory httpClientFactory){\r\n    PersistedParams persistedParamsFromStore = storeHandler.loadPersistedParams(handle);\r\n    if (persistedParamsFromStore == null) {\r\n        return null;\r\n    }\r\n    OAuthClientServiceImpl clientService = new OAuthClientServiceImpl(handle, tokenExpiresInSeconds, httpClientFactory);\r\n    clientService.storeHandler = storeHandler;\r\n    clientService.persistedParams = persistedParamsFromStore;\r\n    return clientService;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.core.provider.AutomationResourceBundlesEventQueue.addAll",
	"Comment": "this method is responsible for initializing the queue with all already received bundleevents and starting athread that should process them.",
	"Method": "void addAll(List<BundleEvent> queue){\r\n    if (closed) {\r\n        return;\r\n    }\r\n    if (shared) {\r\n        this.queue = new LinkedList<BundleEvent>();\r\n        shared = false;\r\n    }\r\n    if (this.queue.addAll(queue)) {\r\n        if (running) {\r\n            notifyAll();\r\n        } else {\r\n            runningThread = new Thread(this, \"Automation Provider Processing Queue\");\r\n            runningThread.start();\r\n            running = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.internal.command.connection.BlueGigaUpdateCommand.setLatency",
	"Comment": "slave latency which defines how many connections intervals a slave may skip.",
	"Method": "void setLatency(int latency){\r\n    this.latency = latency;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.lifx.internal.protocol.Packet.preambleDefaults",
	"Comment": "sets default preamble values. if needed, subclasses may override thesevalues by specifically overriding this method, or by setting individualvalues within the constructor, as this method is called automaticallyduring initialization.",
	"Method": "void preambleDefaults(){\r\n    size = 0;\r\n    protocol = 1024;\r\n    target = new MACAddress();\r\n    sequence = 0;\r\n    packetType = packetType();\r\n}"
}, {
	"Path": "org.spongepowered.api.service.ServiceManager.isRegistered",
	"Comment": "gets whether the class of the type of service is already registered withthis manager. this does not register or unregister any services.",
	"Method": "boolean isRegistered(Class<?> service){\r\n    return provide(service).isPresent();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.module.media.internal.MediaActionTypeProvider.getSoundOptions",
	"Comment": "this method creates one option for every file that is found in the sounds directory.as a label, the file extension is removed and the string is capitalized.",
	"Method": "List<ParameterOption> getSoundOptions(){\r\n    List<ParameterOption> options = new ArrayList();\r\n    File soundsDir = Paths.get(ConfigConstants.getConfigFolder(), AudioManager.SOUND_DIR).toFile();\r\n    if (soundsDir.isDirectory()) {\r\n        for (String fileName : soundsDir.list()) {\r\n            if (fileName.contains(\".\") && !fileName.startsWith(\".\")) {\r\n                String soundName = StringUtils.capitalize(fileName.substring(0, fileName.lastIndexOf(\".\")));\r\n                options.add(new ParameterOption(fileName, soundName));\r\n            }\r\n        }\r\n    }\r\n    return options;\r\n}"
}, {
	"Path": "co.aikar.timings.Timings.getHistoryInterval",
	"Comment": "gets the interval between timing history report generation.",
	"Method": "int getHistoryInterval(){\r\n    return factory.getHistoryInterval();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.internal.validation.ConfigDescriptionValidatorImpl.validateParameter",
	"Comment": "validates the given value against the given config description parameter.",
	"Method": "ConfigValidationMessage validateParameter(ConfigDescriptionParameter configDescriptionParameter,Object value){\r\n    for (ConfigDescriptionParameterValidator validator : VALIDATORS) {\r\n        ConfigValidationMessage message = validator.validate(configDescriptionParameter, value);\r\n        if (message != null) {\r\n            return message;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.timeout.TimeoutTest.testFutureWithShorterOrJustTheSameTime",
	"Comment": "future try to get result wait a shorter time or just the same with specified timeout in invokewithfuture",
	"Method": "void testFutureWithShorterOrJustTheSameTime(){\r\n    RequestBody b4 = new RequestBody(4, \"Hello world!\");\r\n    Object obj = null;\r\n    try {\r\n        RpcResponseFuture future = client.invokeWithFuture(addr, b4, timeout);\r\n        obj = future.get(timeout - 50);\r\n        Assert.fail(\"Should not reach here!\");\r\n    } catch (InvokeTimeoutException e) {\r\n        Assert.assertNull(obj);\r\n    } catch (RemotingException e) {\r\n        logger.error(\"Should not catch any exception here\", e);\r\n        Assert.fail(\"Should not reach here!\");\r\n    } catch (InterruptedException e) {\r\n        logger.error(\"InterruptedException in sync\", e);\r\n        Assert.fail(\"Should not reach here!\");\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.transform.TransformationHelper.transform",
	"Comment": "transforms a state string using transformation functions within a given pattern.",
	"Method": "String transform(BundleContext context,String stateDescPattern,String state,String transform,TransformationService service,String function,String format,String state){\r\n    try {\r\n        String value = String.format(format, state);\r\n        return service.transform(function, value);\r\n    } catch (IllegalFormatException e) {\r\n        throw new TransformationException(\"Cannot format state '\" + state + \"' to format '\" + format + \"'\", e);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.manager.impl.TemperatureControlManager.getTemperatureControlStatusFromAllZones",
	"Comment": "returns all zone which have temperature controlled configured.",
	"Method": "Collection<TemperatureControlStatus> getTemperatureControlStatusFromAllZones(){\r\n    return temperationControlStatus != null ? this.temperationControlStatus.values() : new LinkedList<TemperatureControlStatus>();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.fsinternetradio.internal.radio.FrontierSiliconRadio.setPreset",
	"Comment": "set a station preset. tunes the radio to a preselected station.",
	"Method": "void setPreset(Integer presetId){\r\n    conn.doRequest(REQUEST_SET_PRESET, \"value=1\");\r\n    conn.doRequest(REQUEST_SET_PRESET_ACTION, \"value=\" + presetId.toString());\r\n    conn.doRequest(REQUEST_SET_PRESET, \"value=0\");\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.sitemap.internal.SitemapResource.getSitemapEvents",
	"Comment": "subscribes the connecting client to the stream of sitemap events.",
	"Method": "Object getSitemapEvents(String subscriptionId,String sitemapname,String pageId){\r\n    EventOutput eventOutput = eventOutputs.get(subscriptionId);\r\n    if (!subscriptions.exists(subscriptionId) || eventOutput == null) {\r\n        return JSONResponse.createResponse(Status.NOT_FOUND, null, \"Subscription id \" + subscriptionId + \" does not exist.\");\r\n    }\r\n    if (sitemapname != null && pageId != null) {\r\n        subscriptions.setPageId(subscriptionId, sitemapname, pageId);\r\n    }\r\n    if (subscriptions.getSitemapName(subscriptionId) == null || subscriptions.getPageId(subscriptionId) == null) {\r\n        return JSONResponse.createResponse(Status.BAD_REQUEST, null, \"Subscription id \" + subscriptionId + \" is not yet linked to a sitemap/page.\");\r\n    }\r\n    logger.debug(\"Client from IP {} requested sitemap event stream for subscription {}.\", request.getRemoteAddr(), subscriptionId);\r\n    response.addHeader(X_ACCEL_BUFFERING_HEADER, \"no\");\r\n    return eventOutput;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.internal.common.SafeCallerImplTest.spawn",
	"Comment": "executes the given runnable in another thread.returns immediately.",
	"Method": "void spawn(Runnable runnable){\r\n    AssertingThread t = new AssertingThread(runnable);\r\n    threads.add(t);\r\n    t.start();\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.CommandArgs.getAll",
	"Comment": "gets a list of all arguments as a string. the returned list is immutable.",
	"Method": "List<String> getAll(){\r\n    return Collections.unmodifiableList(this.args.stream().map(SingleArg::getValue).collect(Collectors.toList()));\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.Transform.addTranslation",
	"Comment": "adds a translation to this transform.returns the results as a new copy.",
	"Method": "Transform<E> addTranslation(Vector3d translation){\r\n    checkNotNull(translation, \"translation\");\r\n    return new Transform(getExtent(), getPosition().add(translation), getRotation(), getScale());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.binding.BindingInfo.getServiceId",
	"Comment": "returns the service id of the bindings main service, that can be configured.",
	"Method": "String getServiceId(){\r\n    return serviceId;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.link.AbstractLinkRegistry.isLinked",
	"Comment": "returns if an item for a given item name is linked to a channel or thing for agiven uid.",
	"Method": "boolean isLinked(String itemName,UID uid,boolean isLinked,String itemName,boolean isLinked,UID uid){\r\n    toLinkLock.readLock().lock();\r\n    try {\r\n        return linkedUidToLink.get(uid) != null;\r\n    } finally {\r\n        toLinkLock.readLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.RpcResponseResolver.resolveResponseObject",
	"Comment": "analyze the response command and generate the response object.",
	"Method": "Object resolveResponseObject(ResponseCommand responseCommand,String addr){\r\n    preProcess(responseCommand, addr);\r\n    if (responseCommand.getResponseStatus() == ResponseStatus.SUCCESS) {\r\n        return toResponseObject(responseCommand);\r\n    } else {\r\n        String msg = String.format(\"Rpc invocation exception: %s, the address is %s, id=%s\", responseCommand.getResponseStatus(), addr, responseCommand.getId());\r\n        logger.warn(msg);\r\n        if (responseCommand.getCause() != null) {\r\n            throw new InvokeException(msg, responseCommand.getCause());\r\n        } else {\r\n            throw new InvokeException(msg + \", please check the server log for more.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.command.CommandResult.affectedItems",
	"Comment": "returns a result indicating the command was processed with anamount of affected items.",
	"Method": "CommandResult affectedItems(int count,Builder affectedItems,Integer affectedItems){\r\n    return builder().affectedItems(count).build();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.module.media.internal.MediaActionTypeProvider.getSinkOptions",
	"Comment": "this method creates one option for every sink that is found in the system.",
	"Method": "List<ParameterOption> getSinkOptions(Locale locale){\r\n    List<ParameterOption> options = new ArrayList();\r\n    for (AudioSink sink : audioManager.getAllSinks()) {\r\n        options.add(new ParameterOption(sink.getId(), sink.getLabel(locale)));\r\n    }\r\n    return options;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.UidUtils.generateChannelGroupTypeUID",
	"Comment": "generates the channeltypeuid for the given datapoint with devicetype and channelnumber.",
	"Method": "ChannelGroupTypeUID generateChannelGroupTypeUID(HmChannel channel){\r\n    return new ChannelGroupTypeUID(BINDING_ID, String.format(\"%s_%s\", channel.getDevice().getType(), channel.getNumber()));\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.FallingBlock.canPlaceAsBlock",
	"Comment": "gets whether this falling block will try to place itself where it lands.",
	"Method": "Value<Boolean> canPlaceAsBlock(){\r\n    return getValue(Keys.CAN_PLACE_AS_BLOCK).get();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.library.types.PointType.distanceFrom",
	"Comment": "return the distance in meters from otherpoint, ignoring altitude. this algorithm alsoignores the oblate spheroid shape of earth and assumes a perfect sphere, so resultsare inexact.",
	"Method": "DecimalType distanceFrom(PointType otherPoint){\r\n    double dLat = Math.toRadians(otherPoint.latitude.doubleValue() - this.latitude.doubleValue());\r\n    double dLong = Math.toRadians(otherPoint.longitude.doubleValue() - this.longitude.doubleValue());\r\n    double a = Math.pow(Math.sin(dLat / 2D), 2D) + Math.cos(Math.toRadians(this.latitude.doubleValue())) * Math.cos(Math.toRadians(otherPoint.latitude.doubleValue())) * Math.pow(Math.sin(dLong / 2D), 2D);\r\n    double c = 2D * Math.atan2(Math.sqrt(a), Math.sqrt(1D - a));\r\n    return new DecimalType(WGS84_A * c);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.convention.homeassistant.AbstractComponent.resetState",
	"Comment": "resets all channel states to state undef. call this method after the connectionto the mqtt broker got lost.",
	"Method": "void resetState(){\r\n    channels.values().forEach(c -> c.channelState.getValue().resetState());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.handler.AstroThingHandler.publishPlanet",
	"Comment": "iterates all channels of the thing and updates their states.",
	"Method": "void publishPlanet(){\r\n    logger.debug(\"Publishing planet {} for thing {}\", getPlanet().getClass().getSimpleName(), getThing().getUID());\r\n    for (Channel channel : getThing().getChannels()) {\r\n        if (channel.getKind() != TRIGGER) {\r\n            publishChannelIfLinked(channel.getUID());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.dmx.internal.multiverse.DmxChannel.getNewValue",
	"Comment": "get the new value for this channel as determined by active actions or thecurrent value.",
	"Method": "Integer getNewValue(long calculationTime){\r\n    return (getNewHiResValue(calculationTime) >> 8);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.discovery.AbstractDiscoveryService.getScanTimeout",
	"Comment": "returns the amount of time in seconds after which the discovery service automaticallystops its forced discovery process.",
	"Method": "int getScanTimeout(){\r\n    return this.timeout;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.internal.i18n.ResourceBundleTracker.isFragmentBundle",
	"Comment": "this method checks if the osgi bundle parameter is a fragment bundle.",
	"Method": "boolean isFragmentBundle(Bundle bundle){\r\n    return pkgAdmin.getBundleType(bundle) == PackageAdmin.BUNDLE_TYPE_FRAGMENT;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.mapping.AbstractMqttAttributeClass.getAllFields",
	"Comment": "return fields of the given class as well as all super classes.",
	"Method": "List<Field> getAllFields(Class<?> clazz){\r\n    List<Field> fields = new ArrayList<Field>();\r\n    Class<?> currentClass = clazz;\r\n    while (currentClass != null) {\r\n        fields.addAll(Arrays.asList(currentClass.getDeclaredFields()));\r\n        currentClass = currentClass.getSuperclass();\r\n    }\r\n    return fields;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.ui.classic.internal.render.AbstractWidgetRenderer.getSnippet",
	"Comment": "this method provides the html snippet for a given elementtype of the sitemap model.",
	"Method": "String getSnippet(String elementType){\r\n    String lowerCaseElementType = elementType.toLowerCase();\r\n    String snippet = SNIPPET_CACHE.get(lowerCaseElementType);\r\n    if (snippet == null) {\r\n        String snippetLocation = SNIPPET_LOCATION + lowerCaseElementType + SNIPPET_EXT;\r\n        URL entry = WebAppActivator.getContext().getBundle().getEntry(snippetLocation);\r\n        if (entry != null) {\r\n            try {\r\n                snippet = IOUtils.toString(entry.openStream());\r\n                if (!config.isHtmlCacheDisabled()) {\r\n                    SNIPPET_CACHE.put(lowerCaseElementType, snippet);\r\n                }\r\n            } catch (IOException e) {\r\n                logger.warn(\"Cannot load snippet for element type '{}'\", lowerCaseElementType, e);\r\n            }\r\n        } else {\r\n            throw new RenderException(\"Cannot find a snippet for element type '\" + lowerCaseElementType + \"'\");\r\n        }\r\n    }\r\n    return snippet;\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.CommandContext.requireOne",
	"Comment": "gets the value for the given key if the key has only one value, throws anexception otherwise.",
	"Method": "T requireOne(String key,T requireOne,Text key){\r\n    return requireOne(ArgUtils.textToArgKey(key));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.mapping.SubscribeFieldToMQTTtopic.hasReceivedValue",
	"Comment": "return true if the corresponding field has received a value at least once.",
	"Method": "boolean hasReceivedValue(){\r\n    return receivedValue;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.mapping.AbstractMqttAttributeClass.fieldChanged",
	"Comment": "one of the observed mqtt topics got a new value. apply this to the given field nowand propagate the changed value event.",
	"Method": "void fieldChanged(Field field,Object value){\r\n    final MqttBrokerConnection connection = this.connection.get();\r\n    final ScheduledExecutorService scheduler = this.scheduler.get();\r\n    if (connection == null || scheduler == null) {\r\n        logger.warn(\"No connection or scheduler set!\");\r\n        return;\r\n    }\r\n    try {\r\n        field.set(getFieldsOf(), value);\r\n        final boolean newComplete = !subscriptions.stream().anyMatch(s -> s.isMandatory() && !s.hasReceivedValue());\r\n        attributeChangedListener.attributeChanged(field.getName(), value, connection, scheduler, newComplete);\r\n        complete = newComplete;\r\n    } catch (IllegalArgumentException | IllegalAccessException e) {\r\n        logger.warn(\"Could not assign value {} to field {}\", value, field, e);\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.command.spec.CommandSpec.getUsage",
	"Comment": "gets the usage for this command appropriate for the provided commandsource.",
	"Method": "Text getUsage(CommandSource source){\r\n    checkNotNull(source, \"source\");\r\n    return this.args.getUsage(source);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.core.internal.composite.CompositeActionHandler.execute",
	"Comment": "the method calls handlers of child action, collect their outputs and sets the output of the parent action.",
	"Method": "Map<String, Object> execute(Map<String, Object> context){\r\n    final Map<String, Object> result = new HashMap<String, Object>();\r\n    final List<Action> children = getChildren();\r\n    final Map<String, Object> compositeContext = getCompositeContext(context);\r\n    for (Action child : children) {\r\n        ActionHandler childHandler = moduleHandlerMap.get(child);\r\n        Map<String, Object> childContext = Collections.unmodifiableMap(getChildContext(child, compositeContext));\r\n        Map<String, Object> childResults = childHandler.execute(childContext);\r\n        if (childResults != null) {\r\n            for (Entry<String, Object> childResult : childResults.entrySet()) {\r\n                String childOuputName = child.getId() + \".\" + childResult.getKey();\r\n                Output output = compositeOutputs.get(childOuputName);\r\n                if (output != null) {\r\n                    String childOuputRef = output.getReference();\r\n                    if (childOuputRef != null && childOuputRef.length() > childOuputName.length()) {\r\n                        childOuputRef = childOuputRef.substring(childOuputName.length());\r\n                        result.put(output.getName(), ReferenceResolver.resolveComplexDataReference(childResult.getValue(), childOuputRef));\r\n                    } else {\r\n                        result.put(output.getName(), childResult.getValue());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result.size() > 0 ? result : null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.audio.AudioFormat.getPreferredFormat",
	"Comment": "gets the first concrete audioformat in the passed set or a preferred onebased on 16bit, 16khz, big endian default",
	"Method": "AudioFormat getPreferredFormat(Set<AudioFormat> audioFormats){\r\n    for (AudioFormat currentAudioFormat : audioFormats) {\r\n        if (null == currentAudioFormat.getCodec()) {\r\n            continue;\r\n        }\r\n        if (null == currentAudioFormat.getContainer()) {\r\n            continue;\r\n        }\r\n        if (null == currentAudioFormat.isBigEndian()) {\r\n            continue;\r\n        }\r\n        if (null == currentAudioFormat.getBitDepth()) {\r\n            continue;\r\n        }\r\n        if (null == currentAudioFormat.getBitRate()) {\r\n            continue;\r\n        }\r\n        if (null == currentAudioFormat.getFrequency()) {\r\n            continue;\r\n        }\r\n        if (!currentAudioFormat.getContainer().equals(\"WAVE\")) {\r\n            continue;\r\n        }\r\n        return currentAudioFormat;\r\n    }\r\n    for (AudioFormat currentAudioFormat : audioFormats) {\r\n        AudioFormat format = currentAudioFormat;\r\n        if (null == format.getCodec()) {\r\n            continue;\r\n        }\r\n        if (null == format.getContainer()) {\r\n            continue;\r\n        }\r\n        if (!format.getContainer().equals(AudioFormat.CONTAINER_WAVE)) {\r\n            continue;\r\n        }\r\n        if (null == format.isBigEndian()) {\r\n            format = new AudioFormat(format.getContainer(), format.getCodec(), new Boolean(true), format.getBitDepth(), format.getBitRate(), format.getFrequency());\r\n        }\r\n        if (null == format.getBitDepth() || null == format.getBitRate() || null == format.getFrequency()) {\r\n            int defaultBitDepth = 16;\r\n            long defaultFrequency = 16384;\r\n            Integer bitRate = format.getBitRate();\r\n            Long frequency = format.getFrequency();\r\n            Integer bitDepth = format.getBitDepth();\r\n            if (null == bitRate) {\r\n                if (null == bitDepth) {\r\n                    bitDepth = new Integer(defaultBitDepth);\r\n                }\r\n                if (null == frequency) {\r\n                    frequency = new Long(defaultFrequency);\r\n                }\r\n                bitRate = new Integer(bitDepth.intValue() * frequency.intValue());\r\n            } else if (null == bitDepth) {\r\n                if (null == frequency) {\r\n                    frequency = new Long(defaultFrequency);\r\n                }\r\n                bitDepth = new Integer(bitRate.intValue() / frequency.intValue());\r\n            } else if (null == frequency) {\r\n                frequency = new Long(bitRate.longValue() / bitDepth.longValue());\r\n            }\r\n            format = new AudioFormat(format.getContainer(), format.getCodec(), format.isBigEndian(), bitDepth, bitRate, frequency);\r\n        }\r\n        return format;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.config.Config.setTotalPowerUpdateInterval",
	"Comment": "sets the interval in milliseconds to refresh the total power sensor data.",
	"Method": "void setTotalPowerUpdateInterval(int totalPowerUpdateInterval){\r\n    this.totalPowerUpdateInterval = totalPowerUpdateInterval;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.weatherunderground.internal.json.WeatherUndergroundJsonUtils.convertToBigDecimal",
	"Comment": "convert a string representing a decimal value into a bigdecimal object",
	"Method": "BigDecimal convertToBigDecimal(String value){\r\n    BigDecimal result = null;\r\n    if (isValid(value)) {\r\n        result = new BigDecimal(value.trim());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.events.AbstractEventFactory.serializePayload",
	"Comment": "serializes the payload object into its equivalent json representation.",
	"Method": "String serializePayload(Object payloadObject){\r\n    return JSONCONVERTER.toJson(payloadObject);\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.CommandArgs.next",
	"Comment": "try to read the next argument, advancing the current index if successful.",
	"Method": "String next(){\r\n    if (!hasNext()) {\r\n        throw createError(t(\"Not enough arguments!\"));\r\n    }\r\n    return this.args.get(++this.index).getValue();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.internal.items.ItemRegistryImpl.initializeItem",
	"Comment": "an item should be initialized, which means that the event publisher isinjected and its implementation is notified that it has just beencreated, so it can perform any task it needs to do after its creation.",
	"Method": "void initializeItem(Item item){\r\n    ItemUtil.assertValidItemName(item.getName());\r\n    injectServices(item);\r\n    if (item instanceof GroupItem) {\r\n        addMembersToGroupItem((GroupItem) item);\r\n    }\r\n    addToGroupItems(item, item.getGroupNames());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.convention.homeassistant.AbstractComponent.removeChannelTypes",
	"Comment": "removes all channels from the channel type provider.call this if the corresponding thing handler gets disposed.",
	"Method": "void removeChannelTypes(MqttChannelTypeProvider channelTypeProvider){\r\n    channels.values().forEach(v -> channelTypeProvider.removeChannelType(v.channelTypeUID));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.log.internal.LogHandler.createLogLevelsMap",
	"Comment": "return map of currently logged messages. they can change at runtime.",
	"Method": "Map<String, Boolean> createLogLevelsMap(){\r\n    Map<String, Boolean> result = new HashMap();\r\n    result.put(\"error\", logger.isErrorEnabled());\r\n    result.put(\"warn\", logger.isWarnEnabled());\r\n    result.put(\"info\", logger.isInfoEnabled());\r\n    result.put(\"debug\", logger.isDebugEnabled());\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.sample.extension.java.internal.WelcomeHomeRulesProvider.createACRule",
	"Comment": "this method creates a rule from template by using uid, templateuid and configuration.",
	"Method": "Rule createACRule(){\r\n    Configuration config = new Configuration();\r\n    config.put(CONFIG_UNIT, \"Air Conditioner\");\r\n    config.put(CONFIG_EXPECTED_RESULT, \"The air conditioner is switched on.\");\r\n    config.put(AirConditionerRuleTemplate.CONFIG_TARGET_TEMPERATURE, new Integer(18));\r\n    config.put(AirConditionerRuleTemplate.CONFIG_OPERATION, TemperatureConditionType.OPERATOR_HEATING);\r\n    Rule rule = RuleBuilder.create(AC_UID).withTemplateUID(AirConditionerRuleTemplate.UID).withConfiguration(config).build();\r\n    return rule;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.internal.BlueGigaResponse.isEvent",
	"Comment": "returns true if this response is an event, or false if it is a response to a command",
	"Method": "boolean isEvent(){\r\n    return event;\r\n}"
}, {
	"Path": "com.alipay.remoting.codec.AbstractBatchDecoder.internalBuffer",
	"Comment": "returns the internal cumulative buffer of this decoder. you usuallydo not need to access the internal buffer directly to write a decoder.use it only when you must use it at your own risk.",
	"Method": "ByteBuf internalBuffer(){\r\n    if (cumulation != null) {\r\n        return cumulation;\r\n    } else {\r\n        return Unpooled.EMPTY_BUFFER;\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.ArmorEquipable.getLeggings",
	"Comment": "gets the leggings currently being worn by this entity.having the leggings as null will result in having nothing equipped inthe leggings slot.",
	"Method": "Optional<ItemStack> getLeggings(){\r\n    return this.getEquipped(EquipmentTypes.LEGGINGS);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.sample.moduletype.demo.internal.handlers.ConsoleTrigger.setCallback",
	"Comment": "this method is used to set a callback object to the ruleengine",
	"Method": "void setCallback(ModuleHandlerCallback callback){\r\n    super.setCallback(callback);\r\n    final Dictionary<String, Object> registrationProperties = new Hashtable<String, Object>();\r\n    registrationProperties.put(EventConstants.EVENT_TOPIC, eventTopic);\r\n    registration = context.registerService(EventHandler.class, this, registrationProperties);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.internal.util.DateTimeUtils.getRange",
	"Comment": "creates a range object within the specified months and days. the starttime is midnight, the end time is end of the day.",
	"Method": "Range getRange(int startYear,int startMonth,int startDay,int endYear,int endMonth,int endDay){\r\n    Calendar start = Calendar.getInstance();\r\n    start.set(Calendar.YEAR, startYear);\r\n    start.set(Calendar.MONTH, startMonth);\r\n    start.set(Calendar.DAY_OF_MONTH, startDay);\r\n    start = truncateToMidnight(start);\r\n    Calendar end = Calendar.getInstance();\r\n    end.set(Calendar.YEAR, endYear);\r\n    end.set(Calendar.MONTH, endMonth);\r\n    end.set(Calendar.DAY_OF_MONTH, endDay);\r\n    end.set(Calendar.HOUR_OF_DAY, 23);\r\n    end.set(Calendar.MINUTE, 59);\r\n    end.set(Calendar.SECOND, 59);\r\n    end.set(Calendar.MILLISECOND, 999);\r\n    return new Range(start, end);\r\n}"
}, {
	"Path": "org.spongepowered.api.command.args.parsing.InputTokenizer.spaceSplitString",
	"Comment": "returns an input tokenizer that takes input strings and splits them byspace.",
	"Method": "InputTokenizer spaceSplitString(){\r\n    return SpaceSplitInputTokenizer.INSTANCE;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.sample.json.internal.handler.SampleHandlerFactory.getCreatedTriggerHandler",
	"Comment": "retrieves created triggerhandlers from this handlerfactory.",
	"Method": "List<TriggerHandler> getCreatedTriggerHandler(){\r\n    return createdTriggerHandler;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.config.Config.getSensordataRefreshInterval",
	"Comment": "returns the interval in milliseconds to refresh the sensor data.",
	"Method": "int getSensordataRefreshInterval(){\r\n    return sensordataRefreshInterval;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.ConfigDescriptionParameter.getOptions",
	"Comment": "returns a static selection list for the value of this parameter.",
	"Method": "List<ParameterOption> getOptions(){\r\n    return this.options;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.internal.util.PropertyUtils.getPropertyValue",
	"Comment": "iterates through the nested properties and returns the getter value.",
	"Method": "Object getPropertyValue(ChannelUID channelUID,Object instance,Object getPropertyValue,Object instance,String[] properties,int nestedIndex){\r\n    String propertyName = properties[nestedIndex];\r\n    Method m = instance.getClass().getMethod(toGetterString(propertyName), null);\r\n    Object result = m.invoke(instance, (Object[]) null);\r\n    if (nestedIndex + 1 < properties.length) {\r\n        return getPropertyValue(result, properties, nestedIndex + 1);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.alipay.remoting.config.switches.ProtocolSwitch.toByte",
	"Comment": "generate byte value according to the bit set in protocolswitchstatus",
	"Method": "byte toByte(byte toByte,BitSet bs){\r\n    int value = 0;\r\n    for (int i = 0; i < bs.length(); ++i) {\r\n        if (bs.get(i)) {\r\n            value += 1 << i;\r\n        }\r\n    }\r\n    if (bs.length() > 7) {\r\n        throw new IllegalArgumentException(\"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\");\r\n    }\r\n    return (byte) value;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.BeaconBluetoothHandler.updateRSSI",
	"Comment": "updates the rssi channel and the thing status according to the new received rssi value",
	"Method": "void updateRSSI(){\r\n    if (device != null) {\r\n        Integer rssi = device.getRssi();\r\n        if (rssi != null && rssi != 0) {\r\n            updateState(BluetoothBindingConstants.CHANNEL_TYPE_RSSI, new DecimalType(rssi));\r\n            updateStatusBasedOnRssi(true);\r\n        } else {\r\n            updateState(BluetoothBindingConstants.CHANNEL_TYPE_RSSI, UnDefType.NULL);\r\n            updateStatusBasedOnRssi(false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.core.provider.AutomationResourceBundlesEventQueue.addEvent",
	"Comment": "this method is called when a new event for a bundle providing automation resources is received. it causes acreation of a new thread if there is no other created yet and starting the it. if the thread already exists,it is waiting for events and will be notified for the event.",
	"Method": "void addEvent(Bundle bundle,BundleEvent event){\r\n    if (closed) {\r\n        return;\r\n    }\r\n    if (shared) {\r\n        queue = new LinkedList<BundleEvent>();\r\n        shared = false;\r\n    }\r\n    if (queue.add(event)) {\r\n        logger.debug(\"Process bundle event {}, for automation bundle '{}' \", event.getType(), event.getBundle().getSymbolicName());\r\n        if (running) {\r\n            notifyAll();\r\n        } else {\r\n            runningThread = new Thread(this, \"Automation Provider Processing Queue\");\r\n            runningThread.start();\r\n            running = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler.getThingByUID",
	"Comment": "finds and returns a child thing for a given uid of this bridge.",
	"Method": "Thing getThingByUID(ThingUID uid){\r\n    Bridge bridge = getThing();\r\n    List<Thing> things = bridge.getThings();\r\n    for (Thing thing : things) {\r\n        if (thing.getUID().equals(uid)) {\r\n            return thing;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.internal.calc.SeasonCalc.calcInitial",
	"Comment": "calculate an initial guess of the equinox or solstice of a given year.",
	"Method": "double calcInitial(int season,int year){\r\n    double y = (year - 2000) / 1000d;\r\n    switch(season) {\r\n        case 0:\r\n            return 2451623.80984 + 365242.37404 * y + 0.05169 * Math.pow(y, 2) - 0.00411 * Math.pow(y, 3) - 0.00057 * Math.pow(y, 4);\r\n        case 1:\r\n            return 2451716.56767 + 365241.62603 * y + 0.00325 * Math.pow(y, 2) + 0.00888 * Math.pow(y, 3) - 0.00030 * Math.pow(y, 4);\r\n        case 2:\r\n            return 2451810.21715 + 365242.01767 * y - 0.11575 * Math.pow(y, 2) + 0.00337 * Math.pow(y, 3) + 0.00078 * Math.pow(y, 4);\r\n        case 3:\r\n            return 2451900.05952 + 365242.74049 * y - 0.06223 * Math.pow(y, 2) - 0.00823 * Math.pow(y, 3) + 0.00032 * Math.pow(y, 4);\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.MqttException.getCause",
	"Comment": "returns the underlying cause of this exception, if available.",
	"Method": "Throwable getCause(){\r\n    return cause;\r\n}"
}, {
	"Path": "org.spongepowered.api.Game.getCommandManager",
	"Comment": "gets the command dispatcher used for registering and dispatchingregistered commands.",
	"Method": "CommandManager getCommandManager(){\r\n    return Sponge.getCommandManager();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.ConfigDescriptionParameter.getLabel",
	"Comment": "returns a human readable label for the configuration parameter.",
	"Method": "String getLabel(){\r\n    return this.label;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.core.internal.ModuleImpl.setTypeUID",
	"Comment": "this method is used for setting the typeuid of the moduleimpl.",
	"Method": "void setTypeUID(String typeUID){\r\n    this.type = typeUID;\r\n}"
}, {
	"Path": "org.spongepowered.api.entity.ArmorEquipable.setBoots",
	"Comment": "sets the boots currently being worn by this entity.having the boots as null will result in having nothing equipped in theboots slot.",
	"Method": "void setBoots(ItemStack boots){\r\n    this.equip(EquipmentTypes.BOOTS, boots);\r\n}"
}, {
	"Path": "org.xerial.snappy.Snappy.maxCompressedLength",
	"Comment": "get the maximum byte size needed for compressing data of the given bytesize.",
	"Method": "int maxCompressedLength(int byteSize){\r\n    return impl.maxCompressedLength(byteSize);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.FullConfig.getGroups",
	"Comment": "returns detailed information about all groups on the bridge.",
	"Method": "List<FullGroup> getGroups(){\r\n    ArrayList<FullGroup> groupsList = new ArrayList();\r\n    for (String id : groups.keySet()) {\r\n        FullGroup group = groups.get(id);\r\n        group.setId(id);\r\n        groupsList.add(group);\r\n    }\r\n    return groupsList;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.core.provider.AutomationResourceBundlesEventQueue.stop",
	"Comment": "this method is invoked when this component is deactivated to stop the separate thread if still running.",
	"Method": "void stop(){\r\n    synchronized (this) {\r\n        closed = true;\r\n        notifyAll();\r\n    }\r\n    Thread runningThread = this.runningThread;\r\n    if (runningThread != null) {\r\n        try {\r\n            runningThread.join(30000);\r\n        } catch (InterruptedException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.dto.StrippedThingTypeDTOMapper.map",
	"Comment": "maps thing type into stripped thing type data transfer object.",
	"Method": "StrippedThingTypeDTO map(ThingType thingType,Locale locale){\r\n    return new StrippedThingTypeDTO(thingType.getUID().toString(), thingType.getLabel(), thingType.getDescription(), thingType.getCategory(), thingType.isListed(), thingType.getSupportedBridgeTypeUIDs(), thingType instanceof BridgeType);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.transport.mqtt.MqttBrokerConnection.unsubscribeRaw",
	"Comment": "unsubscribes from a topic on the given connection, but does not alter the subscriber list.",
	"Method": "CompletableFuture<Boolean> unsubscribeRaw(MqttAsyncClient client,String topic){\r\n    logger.trace(\"Unsubscribing message consumer for topic '{}' from broker '{}'\", topic, host);\r\n    CompletableFuture<Boolean> future = new CompletableFuture<Boolean>();\r\n    try {\r\n        if (client.isConnected()) {\r\n            client.unsubscribe(topic, future, actionCallback);\r\n        } else {\r\n            future.complete(false);\r\n        }\r\n    } catch (org.eclipse.paho.client.mqttv3.MqttException e) {\r\n        logger.info(\"Error unsubscribing topic from broker\", e);\r\n        future.completeExceptionally(e);\r\n    }\r\n    return future;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.fsinternetradio.internal.radio.FrontierSiliconRadioApiResult.getXmlDocFromString",
	"Comment": "converts the string we got from the radio to a parsable xml document",
	"Method": "Document getXmlDocFromString(String xmlString){\r\n    final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\r\n    final DocumentBuilder builder = factory.newDocumentBuilder();\r\n    final Document xmlDocument = builder.parse(new InputSource(new StringReader(xmlString)));\r\n    return xmlDocument;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.dto.ConfigDescriptionDTOMapper.mapParameters",
	"Comment": "maps configuration description parameters into dto objects.",
	"Method": "List<ConfigDescriptionParameterDTO> mapParameters(List<ConfigDescriptionParameter> parameters){\r\n    List<ConfigDescriptionParameterDTO> configDescriptionParameterBeans = new ArrayList(parameters.size());\r\n    for (ConfigDescriptionParameter configDescriptionParameter : parameters) {\r\n        ConfigDescriptionParameterDTO configDescriptionParameterBean = new ConfigDescriptionParameterDTO(configDescriptionParameter.getName(), configDescriptionParameter.getType(), configDescriptionParameter.getMinimum(), configDescriptionParameter.getMaximum(), configDescriptionParameter.getStepSize(), configDescriptionParameter.getPattern(), configDescriptionParameter.isRequired(), configDescriptionParameter.isReadOnly(), configDescriptionParameter.isMultiple(), configDescriptionParameter.getContext(), configDescriptionParameter.getDefault(), configDescriptionParameter.getLabel(), configDescriptionParameter.getDescription(), mapOptions(configDescriptionParameter.getOptions()), mapFilterCriteria(configDescriptionParameter.getFilterCriteria()), configDescriptionParameter.getGroupName(), configDescriptionParameter.isAdvanced(), configDescriptionParameter.getLimitToOptions(), configDescriptionParameter.getMultipleLimit(), configDescriptionParameter.getUnit(), configDescriptionParameter.getUnitLabel(), configDescriptionParameter.isVerifyable());\r\n        configDescriptionParameterBeans.add(configDescriptionParameterBean);\r\n    }\r\n    return configDescriptionParameterBeans;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.type.UidUtils.generateThingUID",
	"Comment": "generates the thinguid for the given device in the given bridge.",
	"Method": "ThingUID generateThingUID(HmDevice device,Bridge bridge){\r\n    ThingTypeUID thingTypeUID = generateThingTypeUID(device);\r\n    return new ThingUID(thingTypeUID, bridge.getUID(), device.getAddress());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.common.HomematicConfig.setSocketMaxAlive",
	"Comment": "sets the max alive time of a socket connection to a homematic gateway in seconds.",
	"Method": "void setSocketMaxAlive(int socketMaxAlive){\r\n    this.socketMaxAlive = socketMaxAlive;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.cache.ExpiringCacheMap.refreshAll",
	"Comment": "refreshes and returns a collection of all new values in the cache.",
	"Method": "Collection<@Nullable V> refreshAll(){\r\n    final Collection<@Nullable V> values = new LinkedList();\r\n    for (final ExpiringCache<@Nullable V> item : items.values()) {\r\n        values.add(item.refreshValue());\r\n    }\r\n    return values;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.persistence.internal.PersistenceManagerImpl.appliesToItem",
	"Comment": "checks if a given persistence configuration entry is relevant for an item",
	"Method": "boolean appliesToItem(SimpleItemConfiguration config,Item item){\r\n    for (SimpleConfig itemCfg : config.getItems()) {\r\n        if (itemCfg instanceof SimpleAllConfig) {\r\n            return true;\r\n        }\r\n        if (itemCfg instanceof SimpleItemConfig) {\r\n            SimpleItemConfig singleItemConfig = (SimpleItemConfig) itemCfg;\r\n            if (item.getName().equals(singleItemConfig.getItem())) {\r\n                return true;\r\n            }\r\n        }\r\n        if (itemCfg instanceof SimpleGroupConfig) {\r\n            SimpleGroupConfig groupItemCfg = (SimpleGroupConfig) itemCfg;\r\n            String groupName = groupItemCfg.getGroup();\r\n            try {\r\n                Item gItem = itemRegistry.getItem(groupName);\r\n                if (gItem instanceof GroupItem) {\r\n                    GroupItem groupItem = (GroupItem) gItem;\r\n                    if (groupItem.getAllMembers().contains(item)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.common.QueueingThreadPoolExecutorTest.basicTestForPoolName",
	"Comment": "basic tests of a pool with a given name. checks thread creation andcleanup.",
	"Method": "void basicTestForPoolName(String poolName){\r\n    ThreadPoolExecutor pool = QueueingThreadPoolExecutor.createInstance(poolName, 2);\r\n    pool.execute(createRunnable100ms());\r\n    pool.execute(createRunnable100ms());\r\n    assertTrue(isPoolThreadActive(poolName, 1));\r\n    assertTrue(isPoolThreadActive(poolName, 2));\r\n    pool.shutdown();\r\n    Thread.sleep(CORE_POOL_TIMEOUT + 1000);\r\n    assertFalse(areThreadsFromPoolRunning(poolName));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.tradfri.handler.TradfriGatewayHandler.getEndpoint",
	"Comment": "returns the coap endpoint that can be used within coap clients.",
	"Method": "CoapEndpoint getEndpoint(){\r\n    return endPoint;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.averageSince",
	"Comment": "gets the average value of the state of a given item since a certain point in time.the default persistence service is used.",
	"Method": "DecimalType averageSince(Item item,AbstractInstant timestamp,DecimalType averageSince,Item item,AbstractInstant timestamp,String serviceId){\r\n    Iterable<HistoricItem> result = getAllStatesSince(item, timestamp, serviceId);\r\n    Iterator<HistoricItem> it = result.iterator();\r\n    BigDecimal total = BigDecimal.ZERO;\r\n    BigDecimal avgValue, timeSpan;\r\n    DecimalType lastState = null, thisState = null;\r\n    BigDecimal lastTimestamp = null, thisTimestamp = null;\r\n    BigDecimal firstTimestamp = null;\r\n    while (it.hasNext()) {\r\n        HistoricItem thisItem = it.next();\r\n        State state = thisItem.getState();\r\n        if (state instanceof DecimalType) {\r\n            thisState = (DecimalType) state;\r\n            thisTimestamp = BigDecimal.valueOf(thisItem.getTimestamp().getTime());\r\n            if (firstTimestamp == null) {\r\n                firstTimestamp = thisTimestamp;\r\n            } else {\r\n                avgValue = (thisState.toBigDecimal().add(lastState.toBigDecimal())).divide(BigDecimal.valueOf(2), MathContext.DECIMAL64);\r\n                timeSpan = thisTimestamp.subtract(lastTimestamp);\r\n                total = total.add(avgValue.multiply(timeSpan, MathContext.DECIMAL64));\r\n            }\r\n            lastTimestamp = thisTimestamp;\r\n            lastState = thisState;\r\n        }\r\n    }\r\n    if (lastState != null) {\r\n        thisState = item.getStateAs(DecimalType.class);\r\n        if (thisState != null) {\r\n            thisTimestamp = BigDecimal.valueOf((new DateTime()).getMillis());\r\n            avgValue = (thisState.toBigDecimal().add(lastState.toBigDecimal())).divide(BigDecimal.valueOf(2), MathContext.DECIMAL64);\r\n            timeSpan = thisTimestamp.subtract(lastTimestamp);\r\n            total = total.add(avgValue.multiply(timeSpan, MathContext.DECIMAL64));\r\n        }\r\n    }\r\n    if (thisTimestamp != null) {\r\n        timeSpan = thisTimestamp.subtract(firstTimestamp, MathContext.DECIMAL64);\r\n        BigDecimal average = total.divide(timeSpan, MathContext.DECIMAL64);\r\n        return new DecimalType(average);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.xml.osgi.XmlDocumentBundleTracker.filterPatches",
	"Comment": "this method creates a list where all resources are containedexcept the ones from the host bundle which are also contained ina fragment. so the fragment bundle resources can override thehost bundles resources.",
	"Method": "Collection<URL> filterPatches(Enumeration<URL> xmlDocumentPaths,Bundle bundle){\r\n    List<URL> hostResources = new ArrayList<URL>();\r\n    List<URL> fragmentResources = new ArrayList<URL>();\r\n    while (xmlDocumentPaths.hasMoreElements()) {\r\n        URL path = xmlDocumentPaths.nextElement();\r\n        if (bundle.getEntry(path.getPath()) != null && bundle.getEntry(path.getPath()).equals(path)) {\r\n            hostResources.add(path);\r\n        } else {\r\n            fragmentResources.add(path);\r\n        }\r\n    }\r\n    if (!fragmentResources.isEmpty()) {\r\n        Map<String, URL> helper = new HashMap<String, URL>();\r\n        for (URL url : hostResources) {\r\n            helper.put(url.getPath(), url);\r\n        }\r\n        for (URL url : fragmentResources) {\r\n            helper.put(url.getPath(), url);\r\n        }\r\n        return helper.values();\r\n    }\r\n    return hostResources;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.service.WatchQueueReader.customizeWatchQueueReader",
	"Comment": "customize the queue reader to process the watch events for the given directory, provided by the watch service",
	"Method": "void customizeWatchQueueReader(AbstractWatchService watchService,Path toWatch,boolean watchSubDirectories){\r\n    try {\r\n        if (watchSubDirectories) {\r\n            registerWithSubDirectories(watchService, toWatch);\r\n        } else {\r\n            registerDirectoryInternal(watchService, watchService.getWatchEventKinds(toWatch), toWatch);\r\n        }\r\n    } catch (NoSuchFileException e) {\r\n        logger.debug(\"Not watching folder '{}' as it does not exist.\", toWatch);\r\n    } catch (IOException e) {\r\n        logger.warn(\"Cannot customize folder watcher for folder '{}'\", toWatch, e);\r\n    }\r\n}"
}, {
	"Path": "com.alipay.remoting.util.NettyEventLoopUtil.newEventLoopGroup",
	"Comment": "create the right event loop according to current platform and system property, fallback to nio when epoll not enabled.",
	"Method": "EventLoopGroup newEventLoopGroup(int nThreads,ThreadFactory threadFactory){\r\n    return epollEnabled ? new EpollEventLoopGroup(nThreads, threadFactory) : new NioEventLoopGroup(nThreads, threadFactory);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.handler.HomematicThingHandler.updateDatapointState",
	"Comment": "sets the configuration or evaluates the channel for this datapoint and updates the state of the channel.",
	"Method": "void updateDatapointState(HmDatapoint dp){\r\n    try {\r\n        if (HomematicTypeGeneratorImpl.isStatusDatapoint(dp)) {\r\n            updateStatus(dp.getChannel().getDevice());\r\n        }\r\n        if (dp.getParamsetType() == HmParamsetType.MASTER) {\r\n            Configuration config = editConfiguration();\r\n            config.put(MetadataUtils.getParameterName(dp), dp.isEnumType() ? dp.getOptionValue() : dp.getValue());\r\n            updateConfiguration(config);\r\n        } else if (!HomematicTypeGeneratorImpl.isIgnoredDatapoint(dp)) {\r\n            ChannelUID channelUID = UidUtils.generateChannelUID(dp, thing.getUID());\r\n            Channel channel = thing.getChannel(channelUID.getId());\r\n            if (channel != null) {\r\n                updateChannelState(dp, channel);\r\n            } else {\r\n                logger.warn(\"Channel not found for datapoint '{}'\", new HmDatapointInfo(dp));\r\n            }\r\n        }\r\n    } catch (GatewayNotAvailableException ex) {\r\n    } catch (Exception ex) {\r\n        logger.error(\"{}\", ex.getMessage(), ex);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.model.persistence.extensions.PersistenceExtensions.sumSince",
	"Comment": "gets the sum of the state of a given item since a certain point in time.the default persistence service is used.",
	"Method": "DecimalType sumSince(Item item,AbstractInstant timestamp,DecimalType sumSince,Item item,AbstractInstant timestamp,String serviceId){\r\n    Iterable<HistoricItem> result = getAllStatesSince(item, timestamp, serviceId);\r\n    Iterator<HistoricItem> it = result.iterator();\r\n    BigDecimal sum = BigDecimal.ZERO;\r\n    while (it.hasNext()) {\r\n        State state = it.next().getState();\r\n        if (state instanceof DecimalType) {\r\n            sum = sum.add(((DecimalType) state).toBigDecimal());\r\n        }\r\n    }\r\n    return new DecimalType(sum);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.handler.SystemBrokerHandler.brokerAdded",
	"Comment": "the base implementation will set the connection variable to the given brokerif it matches the brokerid and will start to connect to the broker if thereis no connection established yet.",
	"Method": "void brokerAdded(String connectionName,MqttBrokerConnection addedConnection){\r\n    if (!connectionName.equals(brokerID) || connection == addedConnection) {\r\n        return;\r\n    }\r\n    this.connection = addedConnection;\r\n    super.initialize();\r\n}"
}, {
	"Path": "org.eclipse.smarthome.io.rest.LocaleServiceImpl.tryGetLocale",
	"Comment": "returns the provided locale or the default one if the provider is null.",
	"Method": "Locale tryGetLocale(){\r\n    final LocaleProvider provider = localeProvider;\r\n    if (provider != null) {\r\n        return provider.getLocale();\r\n    } else {\r\n        logger.error(\"There should ALWAYS be a local provider available, as it is provided by the core.\");\r\n        return Locale.US;\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.AbstractInventoryProperty.getDefaultKey",
	"Comment": "gets the default key for the provided inventoryproperty class.",
	"Method": "K getDefaultKey(V value,Object getDefaultKey,Class<T> clazz){\r\n    return defaultKeys.computeIfAbsent(clazz, k -> k.getSimpleName().toLowerCase(Locale.ENGLISH));\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.property.SlotIndex.not",
	"Comment": "create a slotindex property which matches slotindex properties withunequal value.",
	"Method": "SlotIndex not(Object value){\r\n    return new SlotIndex(value, Operator.NOTEQUAL);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.ConfigDescriptionParameter.isAdvanced",
	"Comment": "returns true is the parameter is considered an advanced option.",
	"Method": "boolean isAdvanced(){\r\n    return this.advanced;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.FullSchedule.getTime",
	"Comment": "returns the time for which the command is scheduled to be ran.",
	"Method": "Date getTime(){\r\n    return time;\r\n}"
}, {
	"Path": "org.spongepowered.api.data.DataQuery.asString",
	"Comment": "gets this query as a string separated by the given separator character.",
	"Method": "String asString(String separator,String asString,char separator){\r\n    return asString(String.valueOf(separator));\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.RpcRemoting.invokeSync",
	"Comment": "synchronous rpc invocation.notice! do not modify the request object concurrently when this method is called.",
	"Method": "Object invokeSync(String addr,Object request,InvokeContext invokeContext,int timeoutMillis,Object invokeSync,Url url,Object request,InvokeContext invokeContext,int timeoutMillis,Object invokeSync,Connection conn,Object request,InvokeContext invokeContext,int timeoutMillis){\r\n    RemotingCommand requestCommand = toRemotingCommand(request, conn, invokeContext, timeoutMillis);\r\n    preProcessInvokeContext(invokeContext, requestCommand, conn);\r\n    ResponseCommand responseCommand = (ResponseCommand) super.invokeSync(conn, requestCommand, timeoutMillis);\r\n    responseCommand.setInvokeContext(invokeContext);\r\n    Object responseObject = RpcResponseResolver.resolveResponseObject(responseCommand, RemotingUtil.parseRemoteAddress(conn.getChannel()));\r\n    return responseObject;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.ConfigDescriptionParameterBuilder.withGroupName",
	"Comment": "set the configuration parameter to be limited to the values in the options list",
	"Method": "ConfigDescriptionParameterBuilder withGroupName(String groupName){\r\n    this.groupName = groupName;\r\n    return this;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.bluetooth.bluegiga.handler.BlueGigaBridgeHandler.bgStopProcedure",
	"Comment": "the following methods are private methods for handling the bluegiga protocol",
	"Method": "boolean bgStopProcedure(){\r\n    BlueGigaCommand command = new BlueGigaEndProcedureCommand();\r\n    BlueGigaEndProcedureResponse response = (BlueGigaEndProcedureResponse) getBgHandler().sendTransaction(command);\r\n    return response.getResult() == BgApiResponse.SUCCESS;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.internal.commands.CommandlineTemplateProvider.remove",
	"Comment": "this method is responsible for removing a set of objects loaded from a specified file or url resource.",
	"Method": "String remove(URL url){\r\n    List<String> portfolio = null;\r\n    synchronized (providerPortfolio) {\r\n        portfolio = providerPortfolio.remove(url);\r\n    }\r\n    if (portfolio != null && !portfolio.isEmpty()) {\r\n        synchronized (providedObjectsHolder) {\r\n            for (String uid : portfolio) {\r\n                notifyListeners(providedObjectsHolder.remove(uid));\r\n            }\r\n        }\r\n    }\r\n    return AutomationCommand.SUCCESS;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.astro.handler.AstroThingHandler.restartJobs",
	"Comment": "schedules a positional and a daily job at midnight for astro calculation and starts it immediately too. removesalready scheduled jobs first.",
	"Method": "void restartJobs(){\r\n    logger.debug(\"Restarting jobs for thing {}\", getThing().getUID());\r\n    monitor.lock();\r\n    try {\r\n        stopJobs();\r\n        if (getThing().getStatus() == ONLINE) {\r\n            String thingUID = getThing().getUID().toString();\r\n            if (scheduledExecutor == null) {\r\n                logger.warn(\"Thread Pool Executor is not available\");\r\n                return;\r\n            }\r\n            dailyJob = getDailyJob();\r\n            scheduledExecutor.schedule(dailyJob, new CronExpression(DAILY_MIDNIGHT));\r\n            logger.debug(\"Scheduled {} at midnight\", dailyJob);\r\n            dailyJob.run();\r\n            if (isPositionalChannelLinked()) {\r\n                Job positionalJob = new PositionalJob(thingUID);\r\n                ScheduledFuture<?> future = scheduler.scheduleAtFixedRate(positionalJob, 0, thingConfig.getInterval(), TimeUnit.SECONDS);\r\n                scheduledFutures.add(future);\r\n                logger.info(\"Scheduled {} every {} seconds\", positionalJob, thingConfig.getInterval());\r\n            }\r\n        }\r\n    } catch (ParseException ex) {\r\n        logger.error(\"{}\", ex.getMessage(), ex);\r\n    } finally {\r\n        monitor.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.generic.ChannelState.start",
	"Comment": "subscribes to the state topic on the given connection and informs about updates on the given listener.",
	"Method": "CompletableFuture<@Nullable Void> start(MqttBrokerConnection connection,ScheduledExecutorService scheduler,int timeout){\r\n    if (hasSubscribed) {\r\n        return CompletableFuture.completedFuture(null);\r\n    }\r\n    this.connection = connection;\r\n    if (StringUtils.isBlank(config.stateTopic)) {\r\n        return CompletableFuture.completedFuture(null);\r\n    }\r\n    this.future = new CompletableFuture();\r\n    connection.subscribe(config.stateTopic, this).thenRun(() -> {\r\n        hasSubscribed = true;\r\n        if (timeout > 0 && !future.isDone()) {\r\n            this.scheduledFuture = scheduler.schedule(this::receivedOrTimeout, timeout, TimeUnit.MILLISECONDS);\r\n        } else {\r\n            receivedOrTimeout();\r\n        }\r\n    }).exceptionally(this::subscribeFail);\r\n    return future;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.scheduler.RecurrenceExpression.isValidExpression",
	"Comment": "indicates whether the specified expression can be parsed into avalid recurrencexpression",
	"Method": "boolean isValidExpression(String expression){\r\n    try {\r\n        new RecurrenceExpression(expression);\r\n    } catch (ParseException pe) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.lib.climate.jsonresponsecontainer.BaseTemperatureControl.getControlDSUID",
	"Comment": "returns the dsuid of the control sensor for heating of the zone.",
	"Method": "String getControlDSUID(){\r\n    return controlDSUID;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.model.HmDevice.isConfigPending",
	"Comment": "returns true, if the gateway has a config to transfer to the device.",
	"Method": "boolean isConfigPending(){\r\n    return isStatusDatapointEnabled(DATAPOINT_NAME_CONFIG_PENDING);\r\n}"
}, {
	"Path": "com.alipay.remoting.rpc.RpcResponseFuture.get",
	"Comment": "get result with timeout specifiedif request done, resolve normal responseobjectif request not done, throws invoketimeoutexception",
	"Method": "Object get(int timeoutMillis,Object get){\r\n    ResponseCommand responseCommand = (ResponseCommand) this.future.waitResponse();\r\n    responseCommand.setInvokeContext(this.future.getInvokeContext());\r\n    return RpcResponseResolver.resolveResponseObject(responseCommand, addr);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.core.internal.RuleRegistryImpl.resolveRuleByTemplate",
	"Comment": "the method checks if the rule has to be resolved by template or not. if the rule does not contain tempateuid itreturns same rule, otherwise it tries to resolve the rule created from template. if the template is availablethe method creates a new rule based on triggers, conditions and actions from template. if the template is notavailable returns the same rule.",
	"Method": "Rule resolveRuleByTemplate(Rule rule){\r\n    String templateUID = rule.getTemplateUID();\r\n    if (templateUID == null) {\r\n        return rule;\r\n    }\r\n    RuleTemplate template = templateRegistry.get(templateUID);\r\n    String uid = rule.getUID();\r\n    if (template == null) {\r\n        updateRuleTemplateMapping(templateUID, uid, false);\r\n        logger.debug(\"Rule template {} does not exist.\", templateUID);\r\n        return rule;\r\n    } else {\r\n        RuleImpl resolvedRule = (RuleImpl) RuleBuilder.create(template, rule.getUID(), rule.getName(), rule.getConfiguration(), rule.getVisibility()).build();\r\n        resolveConfigurations(resolvedRule);\r\n        updateRuleTemplateMapping(templateUID, uid, true);\r\n        return resolvedRule;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.discovery.eq3udp.Eq3UdpResponse.isValid",
	"Comment": "returns true, if this response is from a homematic ccu gateway.",
	"Method": "boolean isValid(){\r\n    return this.senderId == Eq3UdpRequest.getSenderId() && (deviceTypeId.startsWith(\"eQ3-HM-CCU\") || deviceTypeId.startsWith(\"eQ3-HmIP-CCU3\")) && !serialNumber.contains(Eq3UdpRequest.getEq3SerialNumber());\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.mqtt.generic.internal.convention.homeassistant.DiscoverComponents.startDiscovery",
	"Comment": "start a components discovery.we need to consider the case that the remote client is using node idsand also the case that no node ids are used.",
	"Method": "CompletableFuture<@Nullable Void> startDiscovery(MqttBrokerConnection connection,int discoverTime,HaID topicDescription,ComponentDiscovered componentsDiscoveredListener){\r\n    this.topicWithNode = topicDescription.baseTopic + \"/+/+/\" + topicDescription.objectID + \"/config\";\r\n    this.topic = topicDescription.baseTopic + \"/+/\" + topicDescription.objectID + \"/config\";\r\n    this.discoverTime = discoverTime;\r\n    this.componentsDiscoveredListener = componentsDiscoveredListener;\r\n    this.connectionRef = new WeakReference(connection);\r\n    CompletableFuture.allOf(connection.subscribe(topic, this), connection.subscribe(topicWithNode, this)).thenRun(this::subscribeSuccess).exceptionally(this::subscribeFail);\r\n    return discoverFinishedFuture;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.ui.basic.internal.render.AbstractWidgetRenderer.hasValue",
	"Comment": "returns whether the item associated to widget has a value or not",
	"Method": "boolean hasValue(Widget w,boolean hasValue,String text){\r\n    return (text.indexOf('[') != -1);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.homematic.internal.communicator.AbstractHomematicGateway.getDefaultInterface",
	"Comment": "returns the default interface to communicate with the homematic gateway.",
	"Method": "HmInterface getDefaultInterface(){\r\n    return availableInterfaces.containsKey(HmInterface.RF) ? HmInterface.RF : HmInterface.HMIP;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.config.core.status.ConfigStatusInfo.getConfigStatusMessages",
	"Comment": "retrieves all configuration status messages that have one of the given parameter names or types.",
	"Method": "Collection<ConfigStatusMessage> getConfigStatusMessages(Collection<ConfigStatusMessage> getConfigStatusMessages,Type types,Collection<ConfigStatusMessage> getConfigStatusMessages,String parameterNames,Collection<ConfigStatusMessage> getConfigStatusMessages,Collection<Type> types,Collection<String> parameterNames){\r\n    Objects.requireNonNull(types);\r\n    Objects.requireNonNull(parameterNames);\r\n    return filterConfigStatusMessages(getConfigStatusMessages(), configStatusMessage -> types.contains(configStatusMessage.type) || parameterNames.contains(configStatusMessage.parameterName));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.digitalstrom.internal.providers.DsChannelTypeProvider.isOutputChannel",
	"Comment": "returns true, if the given channel type id is a output channel.",
	"Method": "boolean isOutputChannel(String channelTypeID){\r\n    return supportedOutputChannelTypes.contains(channelTypeID);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.hue.internal.HueBridge.authenticate",
	"Comment": "authenticate on the bridge as the specified user.this function verifies that the specified username is valid and will useit for subsequent requests if it is, otherwise an unauthorizedexceptionis thrown and the internal username is not changed.",
	"Method": "void authenticate(String username){\r\n    try {\r\n        this.username = username;\r\n        getLights();\r\n    } catch (Exception e) {\r\n        this.username = null;\r\n        throw new UnauthorizedException(e.toString());\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.item.inventory.transaction.InventoryTransactionResult.getRejectedItems",
	"Comment": "if items were supplied to the operation, this collection will return anyitems which were rejected by the target inventory.",
	"Method": "Collection<ItemStackSnapshot> getRejectedItems(){\r\n    return this.rejected;\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.openweathermap.internal.handler.OpenWeatherMapWeatherAndForecastHandler.updateHourlyForecastChannel",
	"Comment": "update the channel from the last openweathermap data retrieved.",
	"Method": "void updateHourlyForecastChannel(ChannelUID channelUID,int count){\r\n    String channelId = channelUID.getIdWithoutGroup();\r\n    String channelGroupId = channelUID.getGroupId();\r\n    if (hourlyForecastData != null && hourlyForecastData.getList().size() > count) {\r\n        org.eclipse.smarthome.binding.openweathermap.internal.model.forecast.hourly.List forecastData = hourlyForecastData.getList().get(count);\r\n        State state = UnDefType.UNDEF;\r\n        switch(channelId) {\r\n            case CHANNEL_TIME_STAMP:\r\n                state = getDateTimeTypeState(forecastData.getDt());\r\n                break;\r\n            case CHANNEL_CONDITION:\r\n                state = getStringTypeState(forecastData.getWeather().get(0).getDescription());\r\n                break;\r\n            case CHANNEL_CONDITION_ID:\r\n                state = getStringTypeState(forecastData.getWeather().get(0).getId().toString());\r\n                break;\r\n            case CHANNEL_CONDITION_ICON:\r\n                state = getRawTypeState(OpenWeatherMapConnection.getWeatherIcon(forecastData.getWeather().get(0).getIcon()));\r\n                break;\r\n            case CHANNEL_TEMPERATURE:\r\n                state = getQuantityTypeState(forecastData.getMain().getTemp(), CELSIUS);\r\n                break;\r\n            case CHANNEL_PRESSURE:\r\n                state = getQuantityTypeState(forecastData.getMain().getPressure(), HECTO(PASCAL));\r\n                break;\r\n            case CHANNEL_HUMIDITY:\r\n                state = getQuantityTypeState(forecastData.getMain().getHumidity(), SmartHomeUnits.PERCENT);\r\n                break;\r\n            case CHANNEL_WIND_SPEED:\r\n                state = getQuantityTypeState(forecastData.getWind().getSpeed(), SmartHomeUnits.METRE_PER_SECOND);\r\n                break;\r\n            case CHANNEL_WIND_DIRECTION:\r\n                state = getQuantityTypeState(forecastData.getWind().getDeg(), SmartHomeUnits.DEGREE_ANGLE);\r\n                break;\r\n            case CHANNEL_GUST_SPEED:\r\n                state = getQuantityTypeState(forecastData.getWind().getGust(), SmartHomeUnits.METRE_PER_SECOND);\r\n                break;\r\n            case CHANNEL_CLOUDINESS:\r\n                state = getQuantityTypeState(forecastData.getClouds().getAll(), SmartHomeUnits.PERCENT);\r\n                break;\r\n            case CHANNEL_RAIN:\r\n                state = getQuantityTypeState(forecastData.getRain() == null || forecastData.getRain().get3h() == null ? 0 : forecastData.getRain().get3h(), MILLI(METRE));\r\n                break;\r\n            case CHANNEL_SNOW:\r\n                state = getQuantityTypeState(forecastData.getSnow() == null || forecastData.getSnow().get3h() == null ? 0 : forecastData.getSnow().get3h(), MILLI(METRE));\r\n                break;\r\n        }\r\n        logger.debug(\"Update channel '{}' of group '{}' with new state '{}'.\", channelId, channelGroupId, state);\r\n        updateState(channelUID, state);\r\n    } else {\r\n        logger.debug(\"No weather data available to update channel '{}' of group '{}'.\", channelId, channelGroupId);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.smarthome.core.thing.binding.builder.ThingStatusInfoBuilder.create",
	"Comment": "creates a status info builder for the given status and detail.",
	"Method": "ThingStatusInfoBuilder create(ThingStatus status,ThingStatusDetail statusDetail,ThingStatusInfoBuilder create,ThingStatus status){\r\n    return create(status, ThingStatusDetail.NONE);\r\n}"
}, {
	"Path": "org.eclipse.smarthome.binding.tradfri.internal.TradfriCoapClient.startObserve",
	"Comment": "starts observation of the resource and uses the given callback to provide updates.",
	"Method": "CoapObserveRelation startObserve(CoapCallback callback){\r\n    return observe(new TradfriCoapHandler(callback));\r\n}"
}, {
	"Path": "org.eclipse.smarthome.automation.sample.moduletype.demo.internal.factory.HandlerFactory.deactivate",
	"Comment": "this method is called when a service that is required from this factory becomes unavailable.",
	"Method": "void deactivate(){\r\n    super.deactivate();\r\n}"
}]