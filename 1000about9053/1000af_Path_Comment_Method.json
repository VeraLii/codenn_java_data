[{
	"Path": "org.springframework.cloud.sleuth.instrument.messaging.TracingChannelInterceptor.postReceive",
	"Comment": "this starts a consumer span as a child of the incoming message or the current trace\tcontext, placing it in scope until the receive completes.",
	"Method": "Message<?> postReceive(Message<?> message,MessageChannel channel){\r\n    if (emptyMessage(message)) {\r\n        return message;\r\n    }\r\n    MessageHeaderAccessor headers = mutableHeaderAccessor(message);\r\n    TraceContextOrSamplingFlags extracted = this.extractor.extract(headers);\r\n    Span span = this.threadLocalSpan.next(extracted);\r\n    MessageHeaderPropagation.removeAnyTraceHeaders(headers, this.tracing.propagation().keys());\r\n    this.injector.inject(span.context(), headers);\r\n    if (!span.isNoop()) {\r\n        span.kind(Span.Kind.CONSUMER).name(\"receive\").start();\r\n        span.remoteServiceName(REMOTE_SERVICE_NAME);\r\n        addTags(message, span, channel);\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Created a new span in post receive \" + span);\r\n    }\r\n    headers.setImmutable();\r\n    return new GenericMessage(message.getPayload(), headers.getMessageHeaders());\r\n}"
}, {
	"Path": "spoon.template.Substitution.substitute",
	"Comment": "substitutes all the template parameters in a given template type and\treturns the resulting type.",
	"Method": "E substitute(CtType<?> targetType,Template<?> template,E code,T substitute,Template<?> template,T templateType){\r\n    CtType<?> result = TemplateBuilder.createPattern(templateType, template).substituteSingle(null, CtType.class);\r\n    result.setPositions(null);\r\n    return (T) result;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Order.isAscending",
	"Comment": "returns whether sorting for the property shall be ascending.",
	"Method": "boolean isAscending(){\r\n    return this.direction.equals(Direction.ASC);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.dbre.addon.DbreDatabaseListenerImpl.getIntegrationTestOperations",
	"Comment": "method to get integrationtestoperations service implementation",
	"Method": "IntegrationTestOperations getIntegrationTestOperations(){\r\n    if (integrationTestOperations == null) {\r\n        try {\r\n            ServiceReference<?>[] references = context.getAllServiceReferences(IntegrationTestOperations.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                integrationTestOperations = (IntegrationTestOperations) context.getService(ref);\r\n                return integrationTestOperations;\r\n            }\r\n            return null;\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load IntegrationTestOperations on DbreDatabaseListenerImpl.\");\r\n            return null;\r\n        }\r\n    } else {\r\n        return integrationTestOperations;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.PartTree.getOptions",
	"Comment": "returns the different queries that can be build based on the current defined query.first it lists the subject expressions that can be build. once it is completed, it returns the queries available todefine the predicate.",
	"Method": "List<String> getOptions(){\r\n    if (!subject.isComplete()) {\r\n        return subject.getOptions();\r\n    } else if (!predicate.hasOrderClause()) {\r\n        return predicate.getOptions(subject.toString());\r\n    } else {\r\n        return predicate.getOrderOptions(subject.toString());\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.EntityUniverse.getIntersectingEntities",
	"Comment": "gets all the entities that are in the line of sight of the given entity,up to a given distance. this ignores occluders like blocks or otherentities. that is to say, the returned entities might not actually bevisible. only the entities that pass the filter test are added.",
	"Method": "Set<Entity> getIntersectingEntities(AABB box,Set<Entity> getIntersectingEntities,AABB box,Predicate<Entity> filter,Set<EntityHit> getIntersectingEntities,Vector3d start,Vector3d end,Set<EntityHit> getIntersectingEntities,Vector3d start,Vector3d end,Predicate<EntityHit> filter,Set<EntityHit> getIntersectingEntities,Entity looker,double distance,Set<EntityHit> getIntersectingEntities,Entity looker,double distance,Predicate<EntityHit> filter,Set<EntityHit> getIntersectingEntities,Vector3d start,Vector3d direction,double distance,Set<EntityHit> getIntersectingEntities,Vector3d start,Vector3d direction,double distance,Predicate<EntityHit> filter){\r\n    return getIntersectingEntities(start, direction, distance, hit -> true);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMVCViewResponseService.addJasperReportsDependencies",
	"Comment": "this method adds jasperreports dependencies to generated project",
	"Method": "void addJasperReportsDependencies(Pom module){\r\n    String moduleName = module.getModuleName();\r\n    getProjectOperations().addDependency(moduleName, DYNAMIC_JASPER_DEPENDENCY);\r\n    getProjectOperations().addDependency(moduleName, DYNAMIC_JASPER_CORE_FONTS_DEPENDENCY);\r\n    getProjectOperations().addDependency(moduleName, POI_DEPENDENCY);\r\n    getProjectOperations().addDependency(moduleName, SPRING_CONTEXT_SUPPORT);\r\n    getProjectOperations().addProperty(\"\", DYNAMIC_JASPER_VERSION_PROPERTY);\r\n    getProjectOperations().addProperty(\"\", DYNAMIC_JASPER_FONTS_VERSION_PROPERTY);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.MongoClientOptionsFactoryBean.setHeartbeatSocketTimeout",
	"Comment": "set the socket timeout for connections used for the cluster heartbeat.",
	"Method": "void setHeartbeatSocketTimeout(int heartbeatSocketTimeout){\r\n    this.heartbeatSocketTimeout = heartbeatSocketTimeout;\r\n}"
}, {
	"Path": "spoon.support.visitor.ClassTypingContext.resolveActualTypeArgumentsOf",
	"Comment": "resolve actual type argument values of the provided type reference",
	"Method": "List<CtTypeReference<?>> resolveActualTypeArgumentsOf(CtTypeReference<?> typeRef){\r\n    final String typeQualifiedName = typeRef.getQualifiedName();\r\n    List<CtTypeReference<?>> args = typeToArguments.get(typeQualifiedName);\r\n    if (args != null) {\r\n        return args;\r\n    }\r\n    CtTypeReference<?> enclosingTypeRef = getEnclosingType(typeRef);\r\n    if (enclosingTypeRef != null) {\r\n        if (enclosingClassTypingContext == null) {\r\n            return null;\r\n        }\r\n        if (enclosingClassTypingContext.resolveActualTypeArgumentsOf(enclosingTypeRef) == null) {\r\n            return null;\r\n        }\r\n    }\r\n    if (lastResolvedSuperclass == null) {\r\n        return null;\r\n    }\r\n    final HierarchyListener listener = new HierarchyListener(getVisitedSet());\r\n    getVisitedSet().remove(lastResolvedSuperclass.getQualifiedName());\r\n    ((CtElement) lastResolvedSuperclass).map(new SuperInheritanceHierarchyFunction().interfacesExtendObject(true).includingSelf(false).returnTypeReferences(true).setListener(listener)).forEach(new CtConsumer<CtTypeReference<?>>() {\r\n        @Override\r\n        public void accept(CtTypeReference<?> typeRef) {\r\n            String superTypeQualifiedName = typeRef.getQualifiedName();\r\n            List<CtTypeReference<?>> actualTypeArguments = typeRef.getActualTypeArguments();\r\n            if (actualTypeArguments.isEmpty()) {\r\n                List<CtTypeParameter> typeParams;\r\n                CtType<?> type = typeRef.getTypeDeclaration();\r\n                if (type != null) {\r\n                    typeParams = type.getFormalCtTypeParameters();\r\n                } else {\r\n                    if (typeRef.getFactory().getEnvironment().getNoClasspath()) {\r\n                        typeParams = Collections.emptyList();\r\n                    } else {\r\n                        throw new SpoonClassNotFoundException(typeRef.getQualifiedName() + \" cannot be found in the sourcepath or classpath\");\r\n                    }\r\n                }\r\n                if (!typeParams.isEmpty()) {\r\n                    actualTypeArguments = new ArrayList(typeParams.size());\r\n                    for (CtTypeParameter typeParam : typeParams) {\r\n                        actualTypeArguments.add(typeParam.getTypeErasure());\r\n                    }\r\n                }\r\n            }\r\n            List<CtTypeReference<?>> superTypeActualTypeArgumentsResolvedFromSubType = resolveTypeParameters(actualTypeArguments);\r\n            typeToArguments.put(superTypeQualifiedName, superTypeActualTypeArgumentsResolvedFromSubType);\r\n            if (typeQualifiedName.equals(superTypeQualifiedName)) {\r\n                listener.foundArguments = superTypeActualTypeArgumentsResolvedFromSubType;\r\n            }\r\n        }\r\n    });\r\n    if (listener.foundArguments == null) {\r\n        lastResolvedSuperclass = null;\r\n    }\r\n    return listener.foundArguments;\r\n}"
}, {
	"Path": "spoon.support.visitor.ClassTypingContext.resolveActualTypeArgumentsOf",
	"Comment": "resolve actual type argument values of the provided type reference",
	"Method": "List<CtTypeReference<?>> resolveActualTypeArgumentsOf(CtTypeReference<?> typeRef){\r\n    String superTypeQualifiedName = typeRef.getQualifiedName();\r\n    List<CtTypeReference<?>> actualTypeArguments = typeRef.getActualTypeArguments();\r\n    if (actualTypeArguments.isEmpty()) {\r\n        List<CtTypeParameter> typeParams;\r\n        CtType<?> type = typeRef.getTypeDeclaration();\r\n        if (type != null) {\r\n            typeParams = type.getFormalCtTypeParameters();\r\n        } else {\r\n            if (typeRef.getFactory().getEnvironment().getNoClasspath()) {\r\n                typeParams = Collections.emptyList();\r\n            } else {\r\n                throw new SpoonClassNotFoundException(typeRef.getQualifiedName() + \" cannot be found in the sourcepath or classpath\");\r\n            }\r\n        }\r\n        if (!typeParams.isEmpty()) {\r\n            actualTypeArguments = new ArrayList(typeParams.size());\r\n            for (CtTypeParameter typeParam : typeParams) {\r\n                actualTypeArguments.add(typeParam.getTypeErasure());\r\n            }\r\n        }\r\n    }\r\n    List<CtTypeReference<?>> superTypeActualTypeArgumentsResolvedFromSubType = resolveTypeParameters(actualTypeArguments);\r\n    typeToArguments.put(superTypeQualifiedName, superTypeActualTypeArgumentsResolvedFromSubType);\r\n    if (typeQualifiedName.equals(superTypeQualifiedName)) {\r\n        listener.foundArguments = superTypeActualTypeArgumentsResolvedFromSubType;\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.util.AABB.offset",
	"Comment": "offsets this bounding box by a given amount and returns a new box.",
	"Method": "AABB offset(Vector3i offset,AABB offset,Vector3d offset,AABB offset,double x,double y,double z){\r\n    return new AABB(this.min.add(x, y, z), this.max.add(x, y, z));\r\n}"
}, {
	"Path": "org.springframework.data.redis.listener.RedisMessageListenerContainer.setMaxSubscriptionRegistrationWaitingTime",
	"Comment": "specify the max time to wait for subscription registrations, in milliseconds. the default is 2000ms, that\tis, 2 second.",
	"Method": "void setMaxSubscriptionRegistrationWaitingTime(long maxSubscriptionRegistrationWaitingTime){\r\n    this.maxSubscriptionRegistrationWaitingTime = maxSubscriptionRegistrationWaitingTime;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getListDatatablesDetailMethod",
	"Comment": "this method provides detail datatables list method using thymeleafresponse type",
	"Method": "MethodMetadata getListDatatablesDetailMethod(){\r\n    RelationInfo detailsInfo = controllerMetadata.getLastDetailsInfo();\r\n    final ServiceMetadata detailsServiceMetadata = controllerMetadata.getServiceMetadataForEntity(detailsInfo.childType);\r\n    final MethodMetadata findAllMethod = detailsServiceMetadata.getRefencedFieldFindAllDefinedMethod(detailsInfo.mappedBy);\r\n    final MethodMetadata countByDetailMethod = detailsServiceMetadata.getCountByReferenceFieldDefinedMethod(detailsInfo.mappedBy);\r\n    final FieldMetadata detailsServiceField = controllerMetadata.getDetailsServiceFields(detailsInfo.childType);\r\n    final JavaSymbolName methodName = LIST_DATATABLES_DETAILS_METHOD_NAME;\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    parameterTypes.add(new AnnotatedJavaType(findAllMethod.getParameterTypes().get(0).getJavaType(), ANN_METADATA_MODEL_ATTRIBUTE));\r\n    parameterTypes.add(DATATABLES_COLUMNS_PARAM);\r\n    parameterTypes.add(GLOBAL_SEARCH_PARAM);\r\n    parameterTypes.add(DATATABLES_PAGEABLE_PARAM);\r\n    AnnotationMetadataBuilder requestParamAnnotation = new AnnotationMetadataBuilder(REQUEST_PARAM);\r\n    requestParamAnnotation.addStringAttribute(\"value\", \"draw\");\r\n    parameterTypes.add(new AnnotatedJavaType(JavaType.INT_OBJECT, requestParamAnnotation.build()));\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    final List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    final JavaSymbolName parentParamName = findAllMethod.getParameterNames().get(0);\r\n    parameterNames.add(parentParamName);\r\n    parameterNames.add(DATATABLES_COLUMNS_PARAM_NAME);\r\n    parameterNames.add(new JavaSymbolName(\"search\"));\r\n    parameterNames.add(new JavaSymbolName(\"pageable\"));\r\n    parameterNames.add(new JavaSymbolName(\"draw\"));\r\n    final List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n    AnnotationMetadataBuilder getMappingAnnotation = new AnnotationMetadataBuilder(GET_MAPPING);\r\n    getMappingAnnotation.addStringAttribute(\"name\", methodName.getSymbolName());\r\n    getMappingAnnotation.addEnumAttribute(\"produces\", SPRINGLETS_DATATABLES, \"MEDIA_TYPE\");\r\n    getMappingAnnotation.addStringAttribute(\"value\", \"/dt\");\r\n    annotations.add(getMappingAnnotation);\r\n    this.mvcMethodNames.put(methodName.getSymbolName(), methodName.getSymbolName());\r\n    annotations.add(RESPONSE_BODY_ANNOTATION);\r\n    final JavaType serviceReturnType = findAllMethod.getReturnType();\r\n    final JavaType dataReturnType = JavaType.wrapperOf(SpringletsJavaType.SPRINGLETS_CONVERTED_DATATABLES_DATA, serviceReturnType.getParameters().get(0));\r\n    final JavaType returnType = JavaType.wrapperOf(RESPONSE_ENTITY, dataReturnType);\r\n    final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    final String itemsName = StringUtils.uncapitalize(detailsInfo.fieldName);\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"%s %s = %s().%s(%s, search, pageable);\", getNameOfJavaType(serviceReturnType), itemsName, getAccessorMethod(detailsServiceField).getMethodName(), findAllMethod.getMethodName(), parentParamName);\r\n    final String totalVarName = \"total\" + StringUtils.capitalize(itemsName) + \"Count\";\r\n    bodyBuilder.appendFormalLine(\"%s %s = %s().%s(%s);\", getNameOfJavaType(countByDetailMethod.getReturnType()), totalVarName, getAccessorMethod(detailsServiceField).getMethodName(), countByDetailMethod.getMethodName(), parentParamName);\r\n    bodyBuilder.appendFormalLine(\"%1$s data =  new %1$s(%2$s, %3$s, draw, %4$s(), %5$s);\", getNameOfJavaType(dataReturnType), itemsName, totalVarName, getAccessorMethod(this.conversionServiceField).getMethodName(), DATATABLES_COLUMNS_PARAM_NAME);\r\n    bodyBuilder.appendFormalLine(\"return %s.ok(data);\", getNameOfJavaType(SpringJavaType.RESPONSE_ENTITY));\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, returnType, parameterTypes, parameterNames, bodyBuilder);\r\n    methodBuilder.setAnnotations(annotations);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.responses.json.JSONMetadata.getModelAttributeMethod",
	"Comment": "this method provides the method to add to manage a model attribute from apath variable",
	"Method": "MethodMetadata getModelAttributeMethod(MethodMetadata getModelAttributeMethod,String pathVariable,ServiceMetadata serviceMetadata,FieldMetadata serviceField){\r\n    final JavaSymbolName methodName = new JavaSymbolName(\"get\" + StringUtils.capitalize(pathVariable));\r\n    final JavaType idType = serviceMetadata.getCurrentFindOneMethod().getParameterTypes().get(0).getJavaType();\r\n    final JavaSymbolName idName = serviceMetadata.getCurrentFindOneMethod().getParameterNames().get(0);\r\n    final JavaType entityType = serviceMetadata.getCurrentFindOneMethod().getReturnType();\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    AnnotationMetadataBuilder pathVariableAnnotation = new AnnotationMetadataBuilder(SpringJavaType.PATH_VARIABLE);\r\n    pathVariableAnnotation.addStringAttribute(\"value\", StringUtils.uncapitalize(pathVariable));\r\n    parameterTypes.add(new AnnotatedJavaType(idType, pathVariableAnnotation.build()));\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    final List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    parameterNames.add(idName);\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    bodyBuilder.appendFormalLine(\"%s %s = %s.%s(%s);\", getNameOfJavaType(entityType), pathVariable, serviceField.getFieldName(), serviceMetadata.getCurrentFindOneMethod().getMethodName(), idName);\r\n    bodyBuilder.appendFormalLine(\"if (%s == null) {\", pathVariable);\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\"throw new %s(String.format(\\\"%s with identifier '%%s' not found\\\",%s));\", getNameOfJavaType(SpringletsJavaType.SPRINGLETS_NOT_FOUND_EXCEPTION), entityType.getSimpleTypeName(), idName);\r\n    bodyBuilder.indentRemove();\r\n    bodyBuilder.appendFormalLine(\"}\");\r\n    bodyBuilder.appendFormalLine(\"return %s;\", pathVariable);\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, entityType, parameterTypes, parameterNames, bodyBuilder);\r\n    methodBuilder.addAnnotation(ANN_MODEL_ATTRIBUTE);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.finder.WebFinderOperationsImpl.checkAndUseApplicationModule",
	"Comment": "checks if module provided in package is an application module. if not, find anapplication module and use it with default package.",
	"Method": "JavaPackage checkAndUseApplicationModule(JavaPackage controllerPackage){\r\n    if (!typeLocationService.hasModuleFeature(projectOperations.getPomFromModuleName(controllerPackage.getModule()), ModuleFeatureName.APPLICATION)) {\r\n        LOGGER.log(Level.WARNING, \"Focused or specified module isn't an application module (containing a class \" + \"annotated with @SpringBootApplication). Looking for an application module and default package...\");\r\n        Validate.notEmpty(typeLocationService.getModuleNames(ModuleFeatureName.APPLICATION), \"The project must have at least one application module to publish web finders.\");\r\n        String moduleName = typeLocationService.getModuleNames(ModuleFeatureName.APPLICATION).iterator().next();\r\n        Pom module = projectOperations.getPomFromModuleName(moduleName);\r\n        controllerPackage = new JavaPackage(typeLocationService.getTopLevelPackageForModule(module).concat(\".web\"), moduleName);\r\n    }\r\n    return controllerPackage;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform2.andThen",
	"Comment": "returns a transform that is the composition of the given transform withthis transform. the result will apply the given transformation afterthis one.",
	"Method": "DiscreteTransform2 andThen(DiscreteTransform2 that){\r\n    return that.compose(this);\r\n}"
}, {
	"Path": "spoon.refactoring.CtParameterRemoveRefactoring.computeAllInvocations",
	"Comment": "search for all methods and lambdas which has to be refactored together with target method",
	"Method": "void computeAllInvocations(){\r\n    ExecutableReferenceFilter execRefFilter = new ExecutableReferenceFilter();\r\n    for (CtExecutable<?> exec : getTargetExecutables()) {\r\n        execRefFilter.addExecutable(exec);\r\n    }\r\n    final List<CtInvocation<?>> invocations = new ArrayList();\r\n    target.getFactory().getModel().filterChildren(execRefFilter).forEach(new CtConsumer<CtExecutableReference<?>>() {\r\n        @Override\r\n        public void accept(CtExecutableReference<?> t) {\r\n            CtElement parent = t.getParent();\r\n            if (parent instanceof CtInvocation<?>) {\r\n                invocations.add((CtInvocation<?>) parent);\r\n            }\r\n        }\r\n    });\r\n    targetInvocations = Collections.unmodifiableList(invocations);\r\n}"
}, {
	"Path": "spoon.refactoring.CtParameterRemoveRefactoring.computeAllInvocations",
	"Comment": "search for all methods and lambdas which has to be refactored together with target method",
	"Method": "void computeAllInvocations(){\r\n    CtElement parent = t.getParent();\r\n    if (parent instanceof CtInvocation<?>) {\r\n        invocations.add((CtInvocation<?>) parent);\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.world.gen.populator.BigMushroom.clearSupplierOverride",
	"Comment": "clears the supplier override to force the weighted table to be usedinstead.",
	"Method": "void clearSupplierOverride(){\r\n    setSupplierOverride(null);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.index.Index.unique",
	"Comment": "reject all documents that contain a duplicate value for the indexed field.",
	"Method": "Index unique(){\r\n    this.unique = true;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.mapreduce.MapReduceOptions.options",
	"Comment": "static factory method to create a mapreduceoptions instance",
	"Method": "MapReduceOptions options(){\r\n    return new MapReduceOptions();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.test.RepositoryJpaTestCreator.getValidDataOnDemandCreatorsForType",
	"Comment": "gets all the valid implementations of dataondemandcreatorprovider for a javatype.",
	"Method": "List<DataOnDemandCreatorProvider> getValidDataOnDemandCreatorsForType(JavaType type){\r\n    if (this.dodCreators.isEmpty()) {\r\n        try {\r\n            ServiceReference<?>[] references = this.context.getAllServiceReferences(DataOnDemandCreatorProvider.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                DataOnDemandCreatorProvider dodCreatorProvider = (DataOnDemandCreatorProvider) this.context.getService(ref);\r\n                this.dodCreators.add(dodCreatorProvider);\r\n            }\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load DataOnDemandCreatorProvider on RepositoryJpaTestCreator.\");\r\n            return null;\r\n        }\r\n    }\r\n    List<DataOnDemandCreatorProvider> validDoDCreators = new ArrayList<DataOnDemandCreatorProvider>();\r\n    for (DataOnDemandCreatorProvider provider : this.dodCreators) {\r\n        if (provider.isValid(type)) {\r\n            validDoDCreators.add(provider);\r\n        }\r\n    }\r\n    return validDoDCreators;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.test.ThymeleafControllerTestCreator.getValidDataOnDemandCreatorsForType",
	"Comment": "gets all the valid implementations of dataondemandcreatorprovider for a javatype.",
	"Method": "List<DataOnDemandCreatorProvider> getValidDataOnDemandCreatorsForType(JavaType type){\r\n    if (this.dodCreators.isEmpty()) {\r\n        try {\r\n            ServiceReference<?>[] references = this.context.getAllServiceReferences(DataOnDemandCreatorProvider.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                DataOnDemandCreatorProvider dodCreatorProvider = (DataOnDemandCreatorProvider) this.context.getService(ref);\r\n                this.dodCreators.add(dodCreatorProvider);\r\n            }\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load DataOnDemandCreatorProvider on ThymeleafControllerTestCreator.\");\r\n            return null;\r\n        }\r\n    }\r\n    List<DataOnDemandCreatorProvider> validDoDCreators = new ArrayList<DataOnDemandCreatorProvider>();\r\n    for (DataOnDemandCreatorProvider provider : this.dodCreators) {\r\n        if (provider.isValid(type)) {\r\n            validDoDCreators.add(provider);\r\n        }\r\n    }\r\n    return validDoDCreators;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMVCViewResponseService.getMainController",
	"Comment": "this operation returns the main controller generated by thymeleaf response type.",
	"Method": "JavaType getMainController(){\r\n    Set<ClassOrInterfaceTypeDetails> mainController = getTypeLocationService().findClassesOrInterfaceDetailsWithAnnotation(getMainControllerAnnotation());\r\n    if (mainController != null && !mainController.isEmpty()) {\r\n        Iterator<ClassOrInterfaceTypeDetails> it = mainController.iterator();\r\n        while (it.hasNext()) {\r\n            return it.next().getType();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "daikon.Daikon.createUpperPpts",
	"Comment": "creates upper program points by merging together the invariantsfrom all of the lower points.",
	"Method": "void createUpperPpts(PptMap all_ppts){\r\n    for (Iterator<PptTopLevel> i = all_ppts.pptIterator(); i.hasNext(); ) {\r\n        PptTopLevel ppt = i.next();\r\n        if (ppt.parents.size() == 0) {\r\n            ppt.mergeInvs();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "daikon.FileIO.skip_decl",
	"Comment": "skips over a decl.essentially reads in everything up to and includingthe next blank line.",
	"Method": "void skip_decl(LineNumberReader reader){\r\n    String line = reader.readLine();\r\n    while ((line != null) && !line.equals(\"\")) {\r\n        line = reader.readLine();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Query.isRestrictedTypeKey",
	"Comment": "returns whether the given key is the one used to hold the type restriction information.",
	"Method": "boolean isRestrictedTypeKey(String key){\r\n    return RESTRICTED_TYPES_KEY.equals(key);\r\n}"
}, {
	"Path": "spoon.ContractVerifier.checkElementToPathToElementEquivalence",
	"Comment": "checks that for all elements, the path can be obtained, parsed, and give the same element when evaluated",
	"Method": "void checkElementToPathToElementEquivalence(){\r\n    _rootPackage.getPackage(\"spoon\").getElements(e -> true).parallelStream().forEach(element -> {\r\n        CtPath path = element.getPath();\r\n        String pathStr = path.toString();\r\n        try {\r\n            CtPath pathRead = new CtPathStringBuilder().fromString(pathStr);\r\n            assertEquals(pathStr, pathRead.toString());\r\n            Collection<CtElement> returnedElements = pathRead.evaluateOn(_rootPackage);\r\n            assertEquals(1, returnedElements.size());\r\n            CtElement actualElement = (CtElement) returnedElements.toArray()[0];\r\n            assertSame(element, actualElement);\r\n        } catch (CtPathException e) {\r\n            throw new AssertionError(\"Path \" + pathStr + \" is either incorrectly generated or incorrectly read\", e);\r\n        } catch (AssertionError e) {\r\n            throw new AssertionError(\"Path \" + pathStr + \" detection failed on \" + element.getClass().getSimpleName() + \": \" + element.toString(), e);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.identifier.IdentifierMetadata.getFieldBuilders",
	"Comment": "locates declared fields.if no parent is defined, one will be located or created. all declaredfields will be returned.",
	"Method": "List<FieldMetadataBuilder> getFieldBuilders(){\r\n    final List<? extends FieldMetadata> declaredFields = governorTypeDetails.getDeclaredFields();\r\n    final List<FieldMetadata> fields = new ArrayList<FieldMetadata>();\r\n    if (identifierServiceResult != null) {\r\n        for (final Identifier identifier : identifierServiceResult) {\r\n            final List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n            annotations.add(getColumnBuilder(identifier));\r\n            if (identifier.getFieldType().equals(DATE)) {\r\n                setDateAnnotations(identifier.getColumnDefinition(), annotations);\r\n            }\r\n            final FieldMetadata idField = new FieldMetadataBuilder(getId(), Modifier.PRIVATE, annotations, identifier.getFieldName(), identifier.getFieldType()).build();\r\n            if (!hasField(declaredFields, idField)) {\r\n                fields.add(idField);\r\n            }\r\n        }\r\n    }\r\n    fields.addAll(declaredFields);\r\n    for (final Iterator<FieldMetadata> iter = fields.iterator(); iter.hasNext(); ) {\r\n        final FieldMetadata field = iter.next();\r\n        if (Modifier.isStatic(field.getModifier()) || Modifier.isTransient(field.getModifier())) {\r\n            iter.remove();\r\n        }\r\n    }\r\n    final List<FieldMetadata> transientAnnotatedFields = governorTypeDetails.getFieldsWithAnnotation(TRANSIENT);\r\n    if (fields.containsAll(transientAnnotatedFields)) {\r\n        fields.removeAll(transientAnnotatedFields);\r\n    }\r\n    final List<FieldMetadataBuilder> fieldBuilders = new ArrayList<FieldMetadataBuilder>();\r\n    if (!fields.isEmpty()) {\r\n        for (final FieldMetadata field : fields) {\r\n            fieldBuilders.add(new FieldMetadataBuilder(field));\r\n        }\r\n        return fieldBuilders;\r\n    }\r\n    final List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n    final AnnotationMetadataBuilder columnBuilder = new AnnotationMetadataBuilder(COLUMN);\r\n    columnBuilder.addStringAttribute(\"name\", \"id\");\r\n    columnBuilder.addBooleanAttribute(\"nullable\", false);\r\n    annotations.add(columnBuilder);\r\n    fieldBuilders.add(new FieldMetadataBuilder(getId(), Modifier.PRIVATE, annotations, new JavaSymbolName(\"id\"), LONG_OBJECT));\r\n    return fieldBuilders;\r\n}"
}, {
	"Path": "spoon.reflect.factory.TypeFactory.getDeclaringTypeName",
	"Comment": "gets the declaring type name for a given java qualified name.",
	"Method": "String getDeclaringTypeName(String qualifiedName){\r\n    return qualifiedName.substring(0, hasInnerType(qualifiedName));\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.JDTTreeBuilderHelper.createModule",
	"Comment": "creates an entire object ctmodule from a module declaration.",
	"Method": "CtModule createModule(ModuleDeclaration moduleDeclaration){\r\n    CtModule module = jdtTreeBuilder.getFactory().Module().getOrCreate(new String(moduleDeclaration.moduleName));\r\n    module.setIsOpenModule(moduleDeclaration.isOpen());\r\n    jdtTreeBuilder.getContextBuilder().enter(module, moduleDeclaration);\r\n    if (moduleDeclaration.requires != null && moduleDeclaration.requires.length > 0) {\r\n        List<CtModuleRequirement> moduleRequirements = new ArrayList();\r\n        for (RequiresStatement requiresStatement : moduleDeclaration.requires) {\r\n            moduleRequirements.add(this.createModuleRequirement(requiresStatement));\r\n        }\r\n        module.setRequiredModules(moduleRequirements);\r\n    }\r\n    if (moduleDeclaration.exports != null && moduleDeclaration.exports.length > 0) {\r\n        List<CtPackageExport> moduleExports = new ArrayList();\r\n        for (ExportsStatement exportsStatement : moduleDeclaration.exports) {\r\n            moduleExports.add(this.createModuleExport(exportsStatement));\r\n        }\r\n        module.setExportedPackages(moduleExports);\r\n    }\r\n    if (moduleDeclaration.opens != null && moduleDeclaration.opens.length > 0) {\r\n        List<CtPackageExport> moduleOpens = new ArrayList();\r\n        for (OpensStatement opensStatement : moduleDeclaration.opens) {\r\n            moduleOpens.add(this.createModuleExport(opensStatement));\r\n        }\r\n        module.setOpenedPackages(moduleOpens);\r\n    }\r\n    if (moduleDeclaration.uses != null && moduleDeclaration.uses.length > 0) {\r\n        List<CtUsedService> consumedServices = new ArrayList();\r\n        for (UsesStatement consumedService : moduleDeclaration.uses) {\r\n            consumedServices.add(this.createUsedService(consumedService));\r\n        }\r\n        module.setUsedServices(consumedServices);\r\n    }\r\n    if (moduleDeclaration.services != null && moduleDeclaration.services.length > 0) {\r\n        List<CtProvidedService> moduleProvidedServices = new ArrayList();\r\n        for (ProvidesStatement providesStatement : moduleDeclaration.services) {\r\n            moduleProvidedServices.add(this.createModuleProvidedService(providesStatement));\r\n        }\r\n        module.setProvidedServices(moduleProvidedServices);\r\n    }\r\n    module.setPosition(this.jdtTreeBuilder.getPositionBuilder().buildPosition(moduleDeclaration.declarationSourceStart, moduleDeclaration.declarationSourceEnd));\r\n    return module;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerOperationsImpl.getInstalledControllerMVCResponseTypes",
	"Comment": "this method gets all implementations of controllermvcresponseserviceinterface to be able to locate all installed controllermvcresponseservice",
	"Method": "Map<String, ControllerMVCResponseService> getInstalledControllerMVCResponseTypes(){\r\n    if (responseTypes.isEmpty()) {\r\n        try {\r\n            ServiceReference<?>[] references = this.context.getAllServiceReferences(ControllerMVCResponseService.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                ControllerMVCResponseService responseTypeService = (ControllerMVCResponseService) this.context.getService(ref);\r\n                boolean isInstalled = false;\r\n                for (Pom module : getProjectOperations().getPoms()) {\r\n                    if (responseTypeService.isInstalledInModule(module.getModuleName())) {\r\n                        isInstalled = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (isInstalled) {\r\n                    responseTypes.put(responseTypeService.getResponseType(), responseTypeService);\r\n                }\r\n            }\r\n            return responseTypes;\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load ControllerMVCResponseService on ControllerOperationsImpl.\");\r\n            return null;\r\n        }\r\n    } else {\r\n        return responseTypes;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.spel.ExpressionTransformationContextSupport.addToPreviousOrReturn",
	"Comment": "adds the given value to the previous operation if one is present or returns the value to add as is.",
	"Method": "Object addToPreviousOrReturn(Object value){\r\n    return hasPreviousOperation() ? addToPreviousOperation(value) : value;\r\n}"
}, {
	"Path": "spoon.reflect.factory.TypeFactory.createReferences",
	"Comment": "creates a collection of type references from a collection of classes.",
	"Method": "List<CtTypeReference<?>> createReferences(List<Class<?>> classes){\r\n    List<CtTypeReference<?>> refs = new ArrayList(classes.size());\r\n    for (Class<?> c : classes) {\r\n        refs.add(createReference(c));\r\n    }\r\n    return refs;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.FinderCommands.getTypeFromEntityParam",
	"Comment": "tries to obtain javatype indicated in command or which has the focusin the shell",
	"Method": "JavaType getTypeFromEntityParam(ShellContext shellContext){\r\n    String typeString = shellContext.getParameters().get(\"entity\");\r\n    JavaType type = null;\r\n    if (typeString != null) {\r\n        JavaTypeConverter converter = (JavaTypeConverter) getJavaTypeConverter().get(0);\r\n        type = converter.convertFromText(typeString, JavaType.class, PROJECT);\r\n    } else {\r\n        type = lastUsed.getJavaType();\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.biome.GroundCoverLayer.getDepth",
	"Comment": "gets a representation of the depth of this layer. the variable amountwill be seeded with the stone noise at generation time.",
	"Method": "SeededVariableAmount<Double> getDepth(){\r\n    return this.depth;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.test.TestOperationsImpl.getValidTestCreatorsForType",
	"Comment": "gets all the valid implementations of testcreatorprovider for a javatype.",
	"Method": "List<TestCreatorProvider> getValidTestCreatorsForType(JavaType type){\r\n    if (this.testCreators.isEmpty()) {\r\n        try {\r\n            ServiceReference<?>[] references = this.context.getAllServiceReferences(TestCreatorProvider.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                TestCreatorProvider testCreatorProvider = (TestCreatorProvider) this.context.getService(ref);\r\n                this.testCreators.add(testCreatorProvider);\r\n            }\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load TestCreatorProvider on TestOperationsImpl.\");\r\n            return null;\r\n        }\r\n    }\r\n    List<TestCreatorProvider> validTestCreators = new ArrayList<TestCreatorProvider>();\r\n    for (TestCreatorProvider provider : this.testCreators) {\r\n        if (provider.isValid(type)) {\r\n            validTestCreators.add(provider);\r\n        }\r\n    }\r\n    return validTestCreators;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.convert.MappingMongoConverter.potentiallyUnescapeMapKey",
	"Comment": "translates the map key replacements in the given key just read with a dot in case a map key replacement has been\tconfigured.",
	"Method": "String potentiallyUnescapeMapKey(String source){\r\n    return mapKeyDotReplacement == null ? source : source.replaceAll(mapKeyDotReplacement, \"\\\\.\");\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Collation.caseFirst",
	"Comment": "set the flag that determines sort order of case differences during tertiary level comparisons.",
	"Method": "Collation caseFirst(String caseFirst,Collation caseFirst,CaseFirst sort,ComparisonLevel caseFirst,CaseFirst caseFirst){\r\n    ComparisonLevel strengthValue = strength.orElseGet(ComparisonLevel::tertiary);\r\n    return strength(new ICUComparisonLevel(strengthValue.getLevel(), Optional.of(sort), strengthValue.getCaseLevel()));\r\n}"
}, {
	"Path": "spoon.pattern.PatternBuilder.configurePatternParameters",
	"Comment": "all the variable references, whose variables are out of the template model\tare automatically marked as pattern parameters",
	"Method": "PatternBuilder configurePatternParameters(PatternBuilder configurePatternParameters,Consumer<PatternParameterConfigurator> parametersBuilder){\r\n    PatternParameterConfigurator pb = new PatternParameterConfigurator(this, parameterInfos);\r\n    parametersBuilder.accept(pb);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.pushin.PushInOperationsImpl.methodMatch",
	"Comment": "this method checks if the provided methodname matches with the providedregular expression",
	"Method": "boolean methodMatch(MethodMetadata method,String regEx){\r\n    Pattern pattern = Pattern.compile(regEx);\r\n    Matcher matcher = pattern.matcher(method.getMethodName().getSymbolName());\r\n    boolean matches = matcher.matches();\r\n    if (!matches && regEx.split(\"\\\\(\").length > 1) {\r\n        String name = regEx.split(\"\\\\(\")[0];\r\n        String[] parameterTypes = regEx.split(\"\\\\(\")[1].replaceAll(\"\\\\)\", \"\").split(\",\");\r\n        if (StringUtils.isEmpty(name)) {\r\n            return false;\r\n        }\r\n        if (method.getMethodName().equals(new JavaSymbolName(name))) {\r\n            List<AnnotatedJavaType> methodParams = method.getParameterTypes();\r\n            boolean sameParameterTypes = false;\r\n            if (methodParams.size() == parameterTypes.length) {\r\n                sameParameterTypes = true;\r\n                for (int i = 0; i < methodParams.size(); i++) {\r\n                    if (!methodParams.get(i).getJavaType().getSimpleTypeName().equals(parameterTypes[i])) {\r\n                        sameParameterTypes = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (sameParameterTypes) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return matches;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerOperationsImpl.isPublishOperationsAvailable",
	"Comment": "this operation will check if the operation publish services methods isavailable",
	"Method": "boolean isPublishOperationsAvailable(){\r\n    return getProjectOperations().isFeatureInstalled(FeatureNames.MVC);\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform2.getMatrix",
	"Comment": "returns the matrix representation of the transform. it is 3d to allow itto include a translation.",
	"Method": "Matrix3d getMatrix(){\r\n    return this.matrix;\r\n}"
}, {
	"Path": "org.eclipse.draw2d.text.FlowUtilities.setupFragment",
	"Comment": "sets up the fragment width based using the font and string passed in.",
	"Method": "void setupFragment(TextFragmentBox fragment,Font font,String string){\r\n    if (fragment.getWidth() == -1 || fragment.isTruncated()) {\r\n        int width;\r\n        if (string.length() == 0 || fragment.length == 0)\r\n            width = 0;\r\n        else if (fragment.requiresBidi()) {\r\n            width = getTextLayoutBounds(string, font, 0, fragment.length - 1).width;\r\n        } else\r\n            width = getTextUtilities().getStringExtents(string.substring(0, fragment.length), font).width;\r\n        if (fragment.isTruncated())\r\n            width += getEllipsisWidth(font);\r\n        fragment.setWidth(width);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.exceptions.addon.ExceptionsCommands.exceptionHandler",
	"Comment": "this method provides the command definition to be able to add an exceptionhandler.",
	"Method": "void exceptionHandler(JavaType exception,JavaType controller,JavaType controllerAdvice,String errorView){\r\n    exceptionsOperations.addExceptionHandler(exception, controller, controllerAdvice, errorView);\r\n}"
}, {
	"Path": "spoon.test.SpoonTestHelpers.getSetterOf",
	"Comment": "returns the corresponding setter, if several are possible returns the lowest one in the hierarchy",
	"Method": "CtMethod<?> getSetterOf(CtType<?> baseType,CtMethod<?> getter){\r\n    String setterName = getter.getSimpleName().replaceFirst(\"^get\", \"set\");\r\n    Object[] tentativeSetters = baseType.getAllMethods().stream().filter(x -> x.getSimpleName().equals(setterName)).toArray();\r\n    if (tentativeSetters.length == 0) {\r\n        return null;\r\n    }\r\n    for (Object o : tentativeSetters) {\r\n        if (baseType.getPackage().getElements(new OverridingMethodFilter((CtMethod<?>) o)).isEmpty()) {\r\n            return (CtMethod<?>) o;\r\n        }\r\n    }\r\n    return (CtMethod<?>) tentativeSetters[0];\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Meta.setComment",
	"Comment": "add a comment to the query that is propagated to the profile log.",
	"Method": "void setComment(String comment){\r\n    setValue(MetaKey.COMMENT.key, comment);\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform3.compose",
	"Comment": "returns a transform that is the composition of this transform and thegiven transform. the result will apply this transformation after thegiven one.",
	"Method": "DiscreteTransform3 compose(DiscreteTransform3 that){\r\n    return new DiscreteTransform3(this.matrix.mul(that.matrix));\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.persistentEntityJackson2Module",
	"Comment": "jackson module responsible for intelligently serializing and deserializing json that corresponds to an entity.",
	"Method": "Module persistentEntityJackson2Module(){\r\n    PersistentEntities entities = persistentEntities();\r\n    ConversionService conversionService = defaultConversionService();\r\n    UriToEntityConverter uriToEntityConverter = uriToEntityConverter(conversionService);\r\n    RepositoryInvokerFactory repositoryInvokerFactory = repositoryInvokerFactory(conversionService);\r\n    EmbeddedResourcesAssembler assembler = new EmbeddedResourcesAssembler(entities, associationLinks(), excerptProjector());\r\n    LookupObjectSerializer lookupObjectSerializer = new LookupObjectSerializer(Java8PluginRegistry.of(getEntityLookups()));\r\n    return new PersistentEntityJackson2Module(associationLinks(), entities, uriToEntityConverter, linkCollector(), repositoryInvokerFactory, lookupObjectSerializer, resourceProcessorInvoker(), assembler);\r\n}"
}, {
	"Path": "org.spongepowered.api.text.title.Title.isReset",
	"Comment": "returns whether this configuration is clearing the current title from thescreen and resetting the current configuration to the default values.this is recommended when you want to make sure to display a singletitle.",
	"Method": "boolean isReset(boolean isReset){\r\n    return this.reset;\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.BaseUri.getRepositoryLookupPath",
	"Comment": "extracts the actual lookup path within the spring data rest managed uri space. this includes stripping the\tnecessary parts of the base uri from the source lookup path.",
	"Method": "String getRepositoryLookupPath(NativeWebRequest request,String getRepositoryLookupPath,HttpServletRequest request,String getRepositoryLookupPath,String lookupPath){\r\n    Assert.notNull(lookupPath, \"Lookup path must not be null!\");\r\n    lookupPath = lookupPath.replaceAll(\"//\", \"/\");\r\n    lookupPath = trimTrailingCharacter(lookupPath, '/');\r\n    if (!baseUri.isAbsolute()) {\r\n        String uri = baseUri.toString();\r\n        if (!StringUtils.hasText(uri)) {\r\n            return lookupPath;\r\n        }\r\n        uri = uri.startsWith(\"/\") ? uri : \"/\".concat(uri);\r\n        return lookupPath.startsWith(uri) ? lookupPath.substring(uri.length(), lookupPath.length()) : null;\r\n    }\r\n    List<String> baseUriSegments = UriComponentsBuilder.fromUri(baseUri).build().getPathSegments();\r\n    Collections.reverse(baseUriSegments);\r\n    String tail = \"\";\r\n    for (String tailSegment : baseUriSegments) {\r\n        tail = \"/\".concat(tailSegment).concat(tail);\r\n        if (lookupPath.startsWith(tail)) {\r\n            return lookupPath.substring(tail.length(), lookupPath.length());\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.FindAndReplaceOptions.isUpsert",
	"Comment": "get the bit indicating if to create a new document if not exists.",
	"Method": "boolean isUpsert(){\r\n    return upsert;\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.support.RepositoryEntityLinks.linkToSearchResource",
	"Comment": "creates the link to the search resource with the given rel for a given type.",
	"Method": "Link linkToSearchResource(Class<?> domainType,String rel,Link linkToSearchResource,Class<?> domainType,String rel,Pageable pageable,Link linkToSearchResource,Class<?> domainType,String rel,Sort sort){\r\n    return getSearchResourceLinkFor(domainType, rel, null, sort);\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.ProjectionDefinitionConfiguration.getProjectionsFor",
	"Comment": "returns all projections registered for the given source type.",
	"Method": "Map<String, Class<?>> getProjectionsFor(Class<?> sourceType){\r\n    Assert.notNull(sourceType, \"Source type must not be null!\");\r\n    Class<?> userType = ClassUtils.getUserClass(sourceType);\r\n    Map<String, ProjectionDefinition> byName = new HashMap<String, ProjectionDefinition>();\r\n    Map<String, Class<?>> result = new HashMap<String, Class<?>>();\r\n    for (ProjectionDefinition entry : projectionDefinitions) {\r\n        if (!entry.sourceType.isAssignableFrom(userType)) {\r\n            continue;\r\n        }\r\n        ProjectionDefinition existing = byName.get(entry.name);\r\n        if (existing == null || isSubTypeOf(entry.sourceType, existing.sourceType)) {\r\n            byName.put(entry.name, entry);\r\n            result.put(entry.name, entry.targetType);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerCommands.addController",
	"Comment": "this method provides the command definition to be able to generate newcontrollers on current project.",
	"Method": "void addController(boolean all,JavaType entity,String responseType,JavaPackage controllersPackage,String pathPrefix){\r\n    Map<String, ControllerMVCResponseService> responseTypeServices = getInstalledControllerMVCResponseTypes();\r\n    if (!responseTypeServices.containsKey(responseType)) {\r\n        LOGGER.log(Level.SEVERE, \"ERROR: Provided responseType is not valid. Use autocomplete feature to obtain valid responseTypes.\");\r\n        return;\r\n    }\r\n    pathPrefix = StringUtils.lowerCase(pathPrefix);\r\n    if (all) {\r\n        getControllerOperations().createOrUpdateControllerForAllEntities(responseTypeServices.get(responseType), controllersPackage, pathPrefix);\r\n    } else {\r\n        getControllerOperations().createOrUpdateControllerForEntity(entity, responseTypeServices.get(responseType), controllersPackage, pathPrefix);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.ProjectionsBenchmark.readIntoDtoProjectionWithOneField",
	"Comment": "read into dto projection that only needs to map one field back.",
	"Method": "Object readIntoDtoProjectionWithOneField(){\r\n    return asDtoProjection.all();\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.monitor.ServerInfo.getHostName",
	"Comment": "returns the hostname of the used server reported by mongodb.",
	"Method": "String getHostName(){\r\n    return getMongoClient().getAddress().getHost();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.service.addon.ServiceOperationsImpl.canGenerateService",
	"Comment": "informs if this component can generate service class for required entity",
	"Method": "boolean canGenerateService(JavaType domainType,boolean canGenerateService,ClassOrInterfaceTypeDetails domainType){\r\n    ClassOrInterfaceTypeDetails repository = repositoryJpaLocator.getFirstRepository(domainType.getName());\r\n    if (repository == null) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "spoon.pattern.internal.PatternPrinter.generatePatternParameterElement",
	"Comment": "creates an element which will be printed in source code of pattern as marker of parameter",
	"Method": "T generatePatternParameterElement(ParameterInfo parameterInfo,Class<T> type){\r\n    if (type != null) {\r\n        if (type.isAssignableFrom(CtInvocation.class)) {\r\n            return (T) factory.createInvocation(factory.createThisAccess(factory.Type().objectType(), true), factory.createExecutableReference().setSimpleName(parameterInfo.getName()));\r\n        }\r\n        if (type.isAssignableFrom(CtLocalVariable.class)) {\r\n            return (T) factory.createLocalVariable(factory.Type().objectType(), parameterInfo.getName(), null);\r\n        }\r\n        if (type.isAssignableFrom(String.class)) {\r\n            return (T) parameterInfo.getName();\r\n        }\r\n        if (type.isAssignableFrom(CtTypeReference.class)) {\r\n            return (T) factory.Type().createReference(parameterInfo.getName());\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.test.JpaUnitTestMetadata.getMockitoRuleField",
	"Comment": "creates mockitorule field for validating and initialize mocks.",
	"Method": "FieldMetadataBuilder getMockitoRuleField(){\r\n    List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n    AnnotationMetadataBuilder ruleAnnotation = new AnnotationMetadataBuilder(RULE);\r\n    annotations.add(ruleAnnotation);\r\n    FieldMetadataBuilder ruleField = new FieldMetadataBuilder(getId(), Modifier.PUBLIC, annotations, new JavaSymbolName(\"mockito\"), MOCKITO_RULE);\r\n    return ruleField;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.PartTree.getValidProperties",
	"Comment": "filters the entity properties of a javatype that can be used to build spring dataexpressions. persistence version field is excluded, and multivalued fieldsare removed since spring data does not supports operations with them.",
	"Method": "List<FieldMetadata> getValidProperties(List<FieldMetadata> fields,List<FieldMetadata> getValidProperties,JavaType javaType){\r\n    if (finderAutocomplete != null) {\r\n        final MemberDetails entityDetails = finderAutocomplete.getEntityDetails(javaType);\r\n        if (entityDetails != null) {\r\n            return getValidProperties((List<FieldMetadata>) entityDetails.getFields());\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.mapping.BasicMongoPersistentProperty.isIdProperty",
	"Comment": "also considers fields as id that are of supported id type and name.",
	"Method": "boolean isIdProperty(){\r\n    if (super.isIdProperty()) {\r\n        return true;\r\n    }\r\n    return SUPPORTED_ID_PROPERTY_NAMES.contains(getName()) && !hasExplicitFieldName();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.service.addon.ServiceImplMetadata.getMethod",
	"Comment": "method that generates implementation of provided method with specifiedbody",
	"Method": "MethodMetadata getMethod(MethodMetadata methodToBeImplemented,MethodMetadata getMethod,MethodMetadata methodToBeImplemented,boolean isTransactional,MethodMetadata getMethod,MethodMetadata methodToBeImplemented,boolean isTransactional,InvocableMemberBodyBuilder bodyBuilder){\r\n    List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>(methodToBeImplemented.getParameterNames());\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>(methodToBeImplemented.getParameterTypes());\r\n    MethodMetadata existingMethod = getGovernorMethod(methodToBeImplemented.getMethodName(), AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodToBeImplemented.getMethodName(), methodToBeImplemented.getReturnType(), parameterTypes, parameterNames, bodyBuilder);\r\n    if (isTransactional) {\r\n        AnnotationMetadataBuilder transactionalAnnotation = new AnnotationMetadataBuilder(SpringJavaType.TRANSACTIONAL);\r\n        methodBuilder.addAnnotation(transactionalAnnotation);\r\n    }\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.pushin.PushInOperationsImpl.getPrivateFields",
	"Comment": "method that obtains all declared fields and returns a list with the private ones.",
	"Method": "List<? extends FieldMetadata> getPrivateFields(MemberDetails memberDetails){\r\n    List<FieldMetadata> privateFields = new ArrayList<FieldMetadata>();\r\n    for (FieldMetadata field : memberDetails.getFields()) {\r\n        if (field.getModifier() == Modifier.PRIVATE || field.getModifier() == Modifier.PRIVATE + Modifier.FINAL) {\r\n            privateFields.add(field);\r\n        }\r\n    }\r\n    return privateFields;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.aggregation.AggregationOptions.getCursor",
	"Comment": "specify a document that contains options that control the creation of the cursor object.",
	"Method": "Optional<Document> getCursor(){\r\n    return cursor;\r\n}"
}, {
	"Path": "spoon.template.Substitution.getFactory",
	"Comment": "returns a spoon factory object from the first template parameter that contains one",
	"Method": "Factory getFactory(Template<?> template){\r\n    try {\r\n        for (Field f : Parameters.getAllTemplateParameterFields(template.getClass())) {\r\n            if (f.get(template) != null && f.get(template) instanceof FactoryAccessor) {\r\n                return ((FactoryAccessor) f.get(template)).getFactory();\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        throw new SpoonException(e);\r\n    }\r\n    throw new TemplateException(\"no factory found in template \" + template.getClass().getName());\r\n}"
}, {
	"Path": "daikon.Daikon.cleanup",
	"Comment": "cleans up static variables so that mainhelper can be called morethan once.",
	"Method": "void cleanup(){\r\n    if ((fileio_progress != null) && (fileio_progress.getState() != Thread.State.NEW)) {\r\n        fileio_progress.shouldStop = true;\r\n        try {\r\n            fileio_progress.join(2000);\r\n        } catch (InterruptedException e) {\r\n        }\r\n        if (fileio_progress.getState() != Thread.State.TERMINATED) {\r\n            throw new TerminationMessage(\"Can't stop fileio_progress thead\");\r\n        }\r\n    }\r\n    fileio_progress = null;\r\n    progress = \"\";\r\n    proto_invs.clear();\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.JDTTreeBuilderHelper.createType",
	"Comment": "creates a class, an enum, an interface or a annotation type.",
	"Method": "CtType<?> createType(TypeDeclaration typeDeclaration){\r\n    CtType<?> type;\r\n    if ((typeDeclaration.modifiers & ClassFileConstants.AccAnnotation) != 0) {\r\n        type = jdtTreeBuilder.getFactory().Core().<java.lang.annotation.Annotation>createAnnotationType();\r\n    } else if ((typeDeclaration.modifiers & ClassFileConstants.AccEnum) != 0) {\r\n        type = jdtTreeBuilder.getFactory().Core().createEnum();\r\n    } else if ((typeDeclaration.modifiers & ClassFileConstants.AccInterface) != 0) {\r\n        type = jdtTreeBuilder.getFactory().Core().createInterface();\r\n    } else {\r\n        type = jdtTreeBuilder.getFactory().Core().createClass();\r\n    }\r\n    type.setExtendedModifiers(getModifiers(typeDeclaration.modifiers, false, false));\r\n    jdtTreeBuilder.getContextBuilder().enter(type, typeDeclaration);\r\n    if (typeDeclaration.superInterfaces != null) {\r\n        for (TypeReference ref : typeDeclaration.superInterfaces) {\r\n            final CtTypeReference superInterface = jdtTreeBuilder.references.buildTypeReference(ref, null);\r\n            type.addSuperInterface(superInterface);\r\n        }\r\n    }\r\n    if (type instanceof CtClass) {\r\n        if (typeDeclaration.superclass != null) {\r\n            ((CtClass) type).setSuperclass(jdtTreeBuilder.references.buildTypeReference(typeDeclaration.superclass, typeDeclaration.scope));\r\n        }\r\n        if (typeDeclaration.binding.isAnonymousType() || (typeDeclaration.binding instanceof LocalTypeBinding && typeDeclaration.binding.enclosingMethod() != null)) {\r\n            type.setSimpleName(computeAnonymousName(typeDeclaration.binding.constantPoolName()));\r\n        } else {\r\n            type.setSimpleName(new String(typeDeclaration.name));\r\n        }\r\n    } else {\r\n        type.setSimpleName(new String(typeDeclaration.name));\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "spoon.reflect.factory.ConstructorFactory.create",
	"Comment": "creates a constructor into a target class by copying it from a source\tmethod.",
	"Method": "CtConstructor<T> create(CtClass<T> target,CtConstructor<?> source,CtConstructor<T> create,CtClass<T> target,CtMethod<?> source,CtConstructor<T> create,CtClass<T> target,Set<ModifierKind> modifiers,List<CtParameter<?>> parameters,Set<CtTypeReference<? extends Throwable>> thrownTypes,CtConstructor<T> create,CtClass<T> target,Set<ModifierKind> modifiers,List<CtParameter<?>> parameters,Set<CtTypeReference<? extends Throwable>> thrownTypes,CtBlock<T> body){\r\n    CtConstructor<T> constructor = create(target, modifiers, parameters, thrownTypes);\r\n    constructor.setBody(body);\r\n    return constructor;\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchPackage",
	"Comment": "searches a package used in units declared in a compilation unit.",
	"Method": "ImportReference searchPackage(char[][] packageName,CompilationUnitDeclaration[] unitsToProcess){\r\n    for (CompilationUnitDeclaration unit : unitsToProcess) {\r\n        final ImportReference currentPackage = unit.currentPackage;\r\n        if (currentPackage == null) {\r\n            continue;\r\n        }\r\n        final char[][] tokens = currentPackage.tokens;\r\n        if (packageName.length > tokens.length) {\r\n            continue;\r\n        }\r\n        boolean isFound = true;\r\n        for (int i = 0; i < packageName.length; i++) {\r\n            char[] chars = packageName[i];\r\n            if (!CharOperation.equals(chars, tokens[i])) {\r\n                isFound = false;\r\n                break;\r\n            }\r\n        }\r\n        if (isFound) {\r\n            return currentPackage;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.data.rest.tests.TestMvcClient.follow",
	"Comment": "follow url supplied as a string with a specific accept header.",
	"Method": "ResultActions follow(Link link,ResultActions follow,String href,ResultActions follow,Link link,MediaType accept,ResultActions follow,String href,MediaType accept){\r\n    return mvc.perform(get(href).header(HttpHeaders.ACCEPT, accept.toString()));\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.MongoClientOptionsFactoryBean.setConnectTimeout",
	"Comment": "set the connect timeout in milliseconds. 0 is default and infinite.",
	"Method": "void setConnectTimeout(int connectTimeout){\r\n    this.connectTimeout = connectTimeout;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMVCViewResponseService.addWebMVCThymeleafUIConfiguration",
	"Comment": "this method adds new webmvcthymeleafuiconfiguration.java class inside .configpackage of generated project",
	"Method": "void addWebMVCThymeleafUIConfiguration(Pom module){\r\n    Set<ClassOrInterfaceTypeDetails> webMvcConfigurationSet = getTypeLocationService().findClassesOrInterfaceDetailsWithAnnotation(RooJavaType.ROO_WEB_MVC_CONFIGURATION);\r\n    if (webMvcConfigurationSet == null || webMvcConfigurationSet.isEmpty()) {\r\n        throw new IllegalStateException(String.format(\"ERROR: Can't found configuration class annotated with @%s.\", RooJavaType.ROO_WEB_MVC_CONFIGURATION));\r\n    }\r\n    ClassOrInterfaceTypeDetails webMvcConfiguration = webMvcConfigurationSet.iterator().next();\r\n    if (webMvcConfiguration.getAnnotation(RooJavaType.ROO_WEB_MVC_THYMELEAF_UI_CONFIGURATION) == null) {\r\n        AnnotationMetadataBuilder thymeleaftConfigurationAnnotation = new AnnotationMetadataBuilder(RooJavaType.ROO_WEB_MVC_THYMELEAF_UI_CONFIGURATION);\r\n        ClassOrInterfaceTypeDetailsBuilder cidBuilder = new ClassOrInterfaceTypeDetailsBuilder(webMvcConfiguration);\r\n        ;\r\n        cidBuilder.addAnnotation(thymeleaftConfigurationAnnotation);\r\n        cidBuilder.addImplementsType(SpringJavaType.APPLICATION_CONTEXT_AWARE);\r\n        getTypeManagementService().createOrUpdateTypeOnDisk(cidBuilder.build());\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.javabean.addon.JavaBeanMetadata.getMutatorMethods",
	"Comment": "returns a list with the mutator methods of the class requesting the metadata",
	"Method": "List<MethodMetadata> getMutatorMethods(){\r\n    return (List<MethodMetadata>) this.mutatorMethods.values();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.entity.factories.JpaEntityFactoryMetadata.generateNoConstructorCreateMethodBody",
	"Comment": "generate body for create method when entity has not default constructor available",
	"Method": "void generateNoConstructorCreateMethodBody(InvocableMemberBodyBuilder bodyBuilder){\r\n    bodyBuilder.appendFormalLine(\"throw new IllegalStateException(\\\"No no-argument constructor found for the entity \\\"+ %s.class.getName() +\\\". This is required by the JPA especification. Please provide a default constructor for the related class and open the Spring Roo console again.\\\");\", getNameOfJavaType(this.entity));\r\n}"
}, {
	"Path": "org.springframework.cloud.kubernetes.examples.NameController.getName",
	"Comment": "endpoint to get a name with a capability to delay a response for some number of milliseconds.",
	"Method": "String getName(int delayValue){\r\n    LOG.info(String.format(\"Returning a name '%s' with a delay '%d'\", this.hostName, delayValue));\r\n    delay(delayValue);\r\n    return this.hostName;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.ExtentBufferFactory.createThreadSafeBiomeBuffer",
	"Comment": "returns a new biome buffer of the desired size. this buffer is threadsafe.",
	"Method": "MutableBiomeVolume createThreadSafeBiomeBuffer(Vector3i size,MutableBiomeVolume createThreadSafeBiomeBuffer,Vector3i min,Vector3i size,MutableBiomeVolume createThreadSafeBiomeBuffer,int xSize,int ySize,int zSize,MutableBiomeVolume createThreadSafeBiomeBuffer,int xMin,int yMin,int zMin,int xSize,int ySize,int zSize){\r\n    return createThreadSafeBiomeBuffer(new Vector3i(xMin, yMin, zMin), new Vector3i(xSize, ySize, zSize));\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchTypeBinding",
	"Comment": "searches a type used in units declared in a compilation unit.",
	"Method": "TypeBinding searchTypeBinding(ReferenceBinding type,String simpleName,TypeBinding searchTypeBinding,String qualifiedName,CompilationUnitDeclaration[] unitsToProcess){\r\n    if (qualifiedName == null) {\r\n        return null;\r\n    }\r\n    for (CompilationUnitDeclaration unitToProcess : unitsToProcess) {\r\n        for (TypeDeclaration type : unitToProcess.types) {\r\n            if (qualifiedName.equals(CharOperation.toString(type.binding.compoundName))) {\r\n                return type.binding;\r\n            }\r\n            if (type.memberTypes != null) {\r\n                for (TypeDeclaration memberType : type.memberTypes) {\r\n                    if (qualifiedName.equals(CharOperation.toString(memberType.binding.compoundName))) {\r\n                        return type.binding;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Part.shouldIgnoreCase",
	"Comment": "returns whether the search criteria referenced should be matchedignoring case.",
	"Method": "IgnoreCaseType shouldIgnoreCase(){\r\n    return ignoreCase;\r\n}"
}, {
	"Path": "org.spongepowered.api.text.transform.TextFormatter.forEach",
	"Comment": "applies the specified consumer to each element of the specified typeafter the specified index.",
	"Method": "void forEach(Class<T> clazz,Consumer<T> consumer){\r\n    forEachAfter(0, clazz, consumer);\r\n}"
}, {
	"Path": "spoon.template.Substitution.insertConstructor",
	"Comment": "generates a constructor from a template constructor by substituting all\tthe template parameters by their values.",
	"Method": "CtConstructor<T> insertConstructor(CtClass<T> targetClass,Template<?> template,CtMethod<?> sourceMethod,CtConstructor<T> insertConstructor,CtClass<T> targetClass,Template<?> template,CtConstructor<?> sourceConstructor){\r\n    CtConstructor<T> newConstrutor = substitute(targetClass, template, (CtConstructor<T>) sourceConstructor);\r\n    if (newConstrutor.getParameters().isEmpty()) {\r\n        CtConstructor<?> c = targetClass.getConstructor();\r\n        if (c != null && c.isImplicit()) {\r\n            targetClass.removeConstructor((CtConstructor<T>) c);\r\n        }\r\n    }\r\n    targetClass.addConstructor(newConstrutor);\r\n    return newConstrutor;\r\n}"
}, {
	"Path": "org.springframework.cloud.kubernetes.config.MultipleConfigMapsSpringBootTest.testCommonMessage",
	"Comment": "the common property defined in all configmaps is taken from the last one defined",
	"Method": "void testCommonMessage(){\r\n    assertResponse(\"/common\", \"c3\");\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerCommands.isSetupAvailable",
	"Comment": "this indicator checks if spring mvc setup is availableif a valid project has been generated and spring mvc has not beeninstalled yet, this command will be available.",
	"Method": "boolean isSetupAvailable(){\r\n    return getControllerOperations().isSetupAvailable();\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.lettuce.DefaultLettucePool.setPassword",
	"Comment": "sets the password used for authenticating with the redis server.",
	"Method": "void setPassword(String password){\r\n    this.password = password;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerOperationsImpl.isAddControllerAvailable",
	"Comment": "this operation will check if add controllers operation is available",
	"Method": "boolean isAddControllerAvailable(){\r\n    return getProjectOperations().isFeatureInstalled(FeatureNames.MVC);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.javabean.addon.JavaBeanMetadata.checkIfInterfaceMethodWasImplemented",
	"Comment": "to check if current method was implemented on all java classes or itdsassociated to this entity class.if method was implemented, is not necessary to add again.",
	"Method": "boolean checkIfInterfaceMethodWasImplemented(MethodMetadataBuilder methodBuilder){\r\n    List<MethodMetadataBuilder> declaredMethods = builder.getDeclaredMethods();\r\n    for (MethodMetadataBuilder method : declaredMethods) {\r\n        if (method.getMethodName().equals(methodBuilder.getMethodName())) {\r\n            return true;\r\n        }\r\n    }\r\n    MemberDetails memberDetails = memberDetailsScanner.getMemberDetails(getClass().getName(), governorTypeDetails);\r\n    List<MethodMetadata> allMethods = memberDetails.getMethods();\r\n    for (MethodMetadata method : allMethods) {\r\n        if (method.getMethodName().equals(methodBuilder.getMethodName())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMVCViewResponseService.annotate",
	"Comment": "this operation annotates a controller with the thymeleaf annotation",
	"Method": "void annotate(JavaType controller){\r\n    Validate.notNull(controller, \"ERROR: You must provide a valid controller\");\r\n    ClassOrInterfaceTypeDetails controllerDetails = getTypeLocationService().getTypeDetails(controller);\r\n    Validate.notNull(controllerDetails, \"ERROR: You must provide an existing controller\");\r\n    Validate.notNull(controllerDetails.getAnnotation(RooJavaType.ROO_CONTROLLER), \"ERROR: You must provide a controller annotated with @RooController\");\r\n    ClassOrInterfaceTypeDetailsBuilder typeBuilder = new ClassOrInterfaceTypeDetailsBuilder(controllerDetails);\r\n    typeBuilder.addAnnotation(new AnnotationMetadataBuilder(getAnnotation()));\r\n    getTypeManagementService().createOrUpdateTypeOnDisk(typeBuilder.build());\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.audit.JpaAuditOperationsImpl.getCreatedByField",
	"Comment": "builds createdby field for storing user who creates entity registers",
	"Method": "FieldMetadataBuilder getCreatedByField(ClassOrInterfaceTypeDetails entityDetails,String columnName){\r\n    List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n    if (StringUtils.isNotBlank(columnName)) {\r\n        AnnotationMetadataBuilder columnAnnotation = new AnnotationMetadataBuilder(JpaJavaType.COLUMN);\r\n        columnAnnotation.addStringAttribute(\"name\", columnName);\r\n        annotations.add(columnAnnotation);\r\n    }\r\n    AnnotationMetadataBuilder createdDateAnnotation = new AnnotationMetadataBuilder(SpringJavaType.CREATED_BY);\r\n    annotations.add(createdDateAnnotation);\r\n    FieldDetails fieldDetails = new FieldDetails(PhysicalTypeIdentifier.createIdentifier(entityDetails), JavaType.STRING, new JavaSymbolName(\"createdBy\"));\r\n    fieldDetails.setModifiers(Modifier.PRIVATE);\r\n    fieldDetails.setAnnotations(annotations);\r\n    FieldMetadataBuilder fieldBuilder = new FieldMetadataBuilder(fieldDetails);\r\n    return fieldBuilder;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.security.addon.security.SecurityAuthorizationsMetadataProviderImpl.checkParameters",
	"Comment": "check that the parameters of the method are equals of parameters list",
	"Method": "boolean checkParameters(MethodMetadata method,List<?> methodParametersToCompare){\r\n    boolean parametersAreEquals = true;\r\n    List<AnnotatedJavaType> parameterTypes = method.getParameterTypes();\r\n    if (methodParametersToCompare.size() != parameterTypes.size()) {\r\n        parametersAreEquals = false;\r\n    } else {\r\n        for (int i = 0; i < methodParametersToCompare.size(); i++) {\r\n            ClassAttributeValue methodParameterToCompare = (ClassAttributeValue) methodParametersToCompare.get(i);\r\n            AnnotatedJavaType parameterJavaType = parameterTypes.get(i);\r\n            if (!methodParameterToCompare.getValue().getSimpleTypeName().equals(parameterJavaType.getJavaType().getSimpleTypeName())) {\r\n                parametersAreEquals = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return parametersAreEquals;\r\n}"
}, {
	"Path": "org.springframework.data.redis.core.StreamOperations.delete",
	"Comment": "removes the specified records from the stream. returns the number of records deleted, that may be different from\tthe number of ids passed in case certain ids do not exist.",
	"Method": "Long delete(K key,String recordIds,Long delete,Record<K, ?> record,Long delete,K key,RecordId recordIds){\r\n    return delete(record.getStream(), record.getId());\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerCommands.getInstalledControllerMVCResponseTypes",
	"Comment": "this method gets all implementations of controllermvcresponseserviceinterface to be able to locate all installed controllermvcresponseservice",
	"Method": "Map<String, ControllerMVCResponseService> getInstalledControllerMVCResponseTypes(){\r\n    try {\r\n        ServiceReference<?>[] references = this.context.getAllServiceReferences(ControllerMVCResponseService.class.getName(), null);\r\n        for (ServiceReference<?> ref : references) {\r\n            ControllerMVCResponseService responseTypeService = (ControllerMVCResponseService) this.context.getService(ref);\r\n            boolean isInstalled = false;\r\n            for (Pom module : getProjectOperations().getPoms()) {\r\n                if (responseTypeService.isInstalledInModule(module.getModuleName())) {\r\n                    isInstalled = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (isInstalled) {\r\n                responseTypes.put(responseTypeService.getResponseType(), responseTypeService);\r\n            }\r\n        }\r\n        return responseTypes;\r\n    } catch (InvalidSyntaxException e) {\r\n        LOGGER.warning(\"Cannot load ControllerMVCResponseService on ControllerCommands.\");\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaCustomImplMetadata.getCustomCountImpl",
	"Comment": "method that generates implementation methods for each count method, associatedto each custom finder.",
	"Method": "MethodMetadata getCustomCountImpl(Pair<MethodMetadata, PartTree> methodInfo){\r\n    final MethodMetadata method = methodInfo.getLeft();\r\n    JavaSymbolName methodName = method.getMethodName();\r\n    List<AnnotatedJavaType> parameterTypes = method.getParameterTypes();\r\n    List<JavaSymbolName> parameterNames = method.getParameterNames();\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    String entity = this.entity.getSimpleTypeName();\r\n    String entityVariable = StringUtils.uncapitalize(entity);\r\n    JavaType finderParamType = parameterTypes.get(0).getJavaType();\r\n    String finderParamName = parameterNames.get(0).getSymbolName();\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(String.format(\"%1$s %2$s = %1$s.%2$s;\", getNameOfJavaType(entityQtype), entityVariable));\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(String.format(\"%s query = from(%s);\", getNameOfJavaType(getJPQLQueryFor(this.entity)), entityVariable));\r\n    bodyBuilder.newLine();\r\n    buildFormBeanFilterBody(bodyBuilder, finderParamType, finderParamName, entityVariable, methodInfo.getRight());\r\n    bodyBuilder.appendFormalLine(\"return query.fetchCount();\");\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, method.getReturnType(), parameterTypes, parameterNames, bodyBuilder);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "spoon.test.imports.testclasses.ToBeModified.m",
	"Comment": "this method contains list, but it will be removed during refactoring",
	"Method": "void m(){\r\n    List<?> x;\r\n}"
}, {
	"Path": "org.spongepowered.api.text.transform.TextFormatter.firstAfter",
	"Comment": "returns the first element of the specified type after the specifiedindex.",
	"Method": "Optional<T> firstAfter(int index,Class<T> clazz){\r\n    checkNotNull(clazz, \"class\");\r\n    for (int i = index; i < size(); i++) {\r\n        E e = get(i);\r\n        if (clazz.isAssignableFrom(e.getClass())) {\r\n            return Optional.of((T) e);\r\n        }\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "org.springframework.data.redis.core.RedisConnectionUtils.getConnection",
	"Comment": "gets a redis connection from the given factory. is aware of and will return any existing corresponding connections\tbound to the current thread, for example when using a transaction manager. will always create a new connection\totherwise.",
	"Method": "RedisConnection getConnection(RedisConnectionFactory factory,RedisConnection getConnection,RedisConnectionFactory factory,boolean enableTranactionSupport,RedisConnection getConnection){\r\n    return doGetConnection(factory, true, false, enableTranactionSupport);\r\n}"
}, {
	"Path": "org.spongepowered.api.util.blockray.BlockRay.from",
	"Comment": "initializes a block ray builder with the given starting location.",
	"Method": "BlockRayBuilder<E> from(Location<E> start,BlockRayBuilder<E> from,E extent,Vector3d start,BlockRayBuilder<World> from,Entity entity){\r\n    checkNotNull(entity, \"entity\");\r\n    final Vector3d rotation = entity.getRotation();\r\n    final Vector3d direction = Quaterniond.fromAxesAnglesDeg(rotation.getX(), -rotation.getY(), rotation.getZ()).getDirection();\r\n    final Location<World> location = entity.getLocation();\r\n    final Optional<EyeLocationProperty> data = entity.getProperty(EyeLocationProperty.class);\r\n    final Vector3d position = data.map(EyeLocationProperty::getValue).orElse(location.getPosition());\r\n    return from(location.getExtent(), position).direction(direction);\r\n}"
}, {
	"Path": "spoon.support.visitor.ClassTypingContext.createEnclosingHierarchy",
	"Comment": "might be used to create custom chain of super type hierarchies",
	"Method": "ClassTypingContext createEnclosingHierarchy(CtType<?> enclosingType,ClassTypingContext createEnclosingHierarchy,CtTypeReference<?> enclosingTypeRef){\r\n    return new ClassTypingContext(enclosingTypeRef);\r\n}"
}, {
	"Path": "org.spongepowered.api.world.storage.ChunkLayout.isInChunk",
	"Comment": "returns true if the world coordinates fit in the chunk at the givencoordinates.",
	"Method": "boolean isInChunk(Vector3i localCoords,boolean isInChunk,int x,int y,int z,boolean isInChunk,Vector3i worldCoords,Vector3i chunkCoords,boolean isInChunk,int wx,int wy,int wz,int cx,int cy,int cz){\r\n    checkNotNull(worldCoords, \"worldCoords\");\r\n    checkNotNull(chunkCoords, \"chunkCoords\");\r\n    return isInChunk(worldCoords.getX(), worldCoords.getY(), worldCoords.getZ(), chunkCoords.getX(), chunkCoords.getY(), chunkCoords.getZ());\r\n}"
}, {
	"Path": "org.springframework.roo.addon.tailor.config.xml.TailorParser.mapXmlToTailorConfiguration",
	"Comment": "maps the xml file contents to a tailorconfiguration object. it ispossible to have multiple configurations in tailor.xml",
	"Method": "List<TailorConfiguration> mapXmlToTailorConfiguration(Element root){\r\n    final List<Element> elTailors = XmlUtils.findElements(\"/tailorconfiguration/tailor\", root);\r\n    if (elTailors.isEmpty()) {\r\n        logTailorXMLInvalid(\"no <tailor> definitions found in <tailorconfiguration> root element\");\r\n        return null;\r\n    }\r\n    final List<TailorConfiguration> configs = new ArrayList<TailorConfiguration>();\r\n    for (final Element eTailor : elTailors) {\r\n        final TailorConfiguration config = parseTailorConfiguration(eTailor);\r\n        if (config != null) {\r\n            configs.add(config);\r\n        }\r\n    }\r\n    return configs;\r\n}"
}, {
	"Path": "org.spongepowered.api.text.channel.MessageChannel.permission",
	"Comment": "creates a message channel that targets all subjects with the givenpermission.",
	"Method": "MessageChannel permission(String permission){\r\n    return new PermissionMessageChannel(permission);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getPopulateFormatsMethod",
	"Comment": "this method provides populateformats method that allows to configure datetime format for every entity",
	"Method": "MethodMetadata getPopulateFormatsMethod(){\r\n    final JavaSymbolName methodName = new JavaSymbolName(\"populateFormats\");\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    parameterTypes.add(AnnotatedJavaType.convertFromJavaType(SpringJavaType.MODEL));\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    final List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    parameterNames.add(MODEL_PARAM_NAME);\r\n    final List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    buildPopulateFormatBody(bodyBuilder, dateTimeFields);\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, JavaType.VOID_PRIMITIVE, parameterTypes, parameterNames, bodyBuilder);\r\n    methodBuilder.setAnnotations(annotations);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.RepositoryRestConfiguration.setReturnBodyOnCreate",
	"Comment": "set whether to return a response body after creating an entity.",
	"Method": "RepositoryRestConfiguration setReturnBodyOnCreate(Boolean returnBody){\r\n    this.returnBodyOnCreate = returnBody;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getFieldDefaultLabelValue",
	"Comment": "returns a string with default label to show when cannot find the rightlabel code.",
	"Method": "String getFieldDefaultLabelValue(String fieldName){\r\n    String[] splittedFieldName = StringUtils.splitByCharacterTypeCamelCase(fieldName);\r\n    String label = \"\";\r\n    for (int i = 0; i < splittedFieldName.length; i++) {\r\n        if (i != 0) {\r\n            label = label.concat(\" \");\r\n        }\r\n        label = label.concat(StringUtils.capitalize(splittedFieldName[i]));\r\n    }\r\n    return label;\r\n}"
}, {
	"Path": "spoon.template.Substitution.substituteMethodBody",
	"Comment": "gets a body from a template executable with all the template parameters\tsubstituted.",
	"Method": "CtBlock<?> substituteMethodBody(CtClass<?> targetClass,Template<?> template,String executableName,CtTypeReference<?> parameterTypes){\r\n    CtClass<?> sourceClass = getTemplateCtClass(targetClass, template);\r\n    CtExecutable<?> sourceExecutable = executableName.equals(template.getClass().getSimpleName()) ? sourceClass.getConstructor(parameterTypes) : sourceClass.getMethod(executableName, parameterTypes);\r\n    return substitute(targetClass, template, sourceExecutable.getBody());\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.AbstractViewGeneratorMetadataProvider.getDetailsControllers",
	"Comment": "this method obtains the details controller that are available for an specificview type.",
	"Method": "List<T> getDetailsControllers(ControllerMetadata controllerMetadata,JavaPackage controllerPackage,JavaType entity,JavaType responseType,String viewType){\r\n    List<T> detailsControllers = new ArrayList<T>();\r\n    Collection<ClassOrInterfaceTypeDetails> detailsControllersToCheck = getControllerLocator().getControllers(entity, ControllerType.DETAIL, responseType);\r\n    List<T> found = new ArrayList<T>();\r\n    for (ClassOrInterfaceTypeDetails controller : detailsControllersToCheck) {\r\n        if (controllerPackage.equals(controller.getType().getPackage())) {\r\n            T detailViewMetadata = getMetadataService().get(createLocalIdentifier(controller));\r\n            if (detailViewMetadata == null) {\r\n                return null;\r\n            }\r\n            DetailAnnotationValues detailAnnotationValues = new DetailAnnotationValues(controller);\r\n            String[] annotationViews = detailAnnotationValues.getViews();\r\n            if (annotationViews == null && viewType.equals(\"list\")) {\r\n                found.add(detailViewMetadata);\r\n            } else if (annotationViews != null) {\r\n                List<String> views = Arrays.asList(annotationViews);\r\n                if (views.contains(viewType)) {\r\n                    found.add(detailViewMetadata);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (!found.isEmpty()) {\r\n        detailsControllers = Collections.unmodifiableList(found);\r\n    }\r\n    return detailsControllers;\r\n}"
}, {
	"Path": "spoon.test.query_function.testclasses.VariableReferencesModelTest.localVarInNestedClass4",
	"Comment": "check localvariable shadowed in local class method by inherited ctfield 29",
	"Method": "void localVarInNestedClass4(){\r\n    int field = 30;\r\n    assertTrue(field == 30);\r\n    B fnc = new B() {\r\n        @Override\r\n        public void run() {\r\n            {\r\n                int field = 31;\r\n                assertTrue(field == 31);\r\n            }\r\n            assertTrue(field == 29);\r\n            int field = 32;\r\n            assertTrue(field == 32);\r\n            assertTrue(this.field == 29);\r\n        }\r\n    };\r\n    fnc.run();\r\n    assertTrue(field == 30);\r\n}"
}, {
	"Path": "spoon.test.query_function.testclasses.VariableReferencesModelTest.localVarInNestedClass4",
	"Comment": "check localvariable shadowed in local class method by inherited ctfield 29",
	"Method": "void localVarInNestedClass4(){\r\n    {\r\n        int field = 31;\r\n        assertTrue(field == 31);\r\n    }\r\n    assertTrue(field == 29);\r\n    int field = 32;\r\n    assertTrue(field == 32);\r\n    assertTrue(this.field == 29);\r\n}"
}, {
	"Path": "spoon.test.query_function.testclasses.VariableReferencesModelTest.localVarInNestedClass5",
	"Comment": "check localvariable shadowed in local class anonymous executable by inherited ctfield 29",
	"Method": "void localVarInNestedClass5(){\r\n    int field = 33;\r\n    assertTrue(field == 33);\r\n    class Local {\r\n        {\r\n            {\r\n                int field = 34;\r\n                assertTrue(field == 34);\r\n            }\r\n            assertTrue(field == 33);\r\n            int field = 35;\r\n            assertTrue(field == 35);\r\n        }\r\n    }\r\n    new Local();\r\n    assertTrue(field == 33);\r\n}"
}, {
	"Path": "org.springframework.data.redis.test.util.MockitoUtils.verifyInvocationsAcross",
	"Comment": "verifies a given method is called a total number of times across all given mocks.",
	"Method": "void verifyInvocationsAcross(String method,VerificationMode mode,Object mocks){\r\n    mode.verify(new VerificationDataImpl(getInvocations(method, mocks), new InvocationMatcher(null, Collections.singletonList(org.mockito.internal.matchers.Any.ANY)) {\r\n        @Override\r\n        public boolean matches(Invocation actual) {\r\n            return true;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"%s for method: %s\", mode, method);\r\n        }\r\n    }));\r\n}"
}, {
	"Path": "org.springframework.data.redis.test.util.MockitoUtils.verifyInvocationsAcross",
	"Comment": "verifies a given method is called a total number of times across all given mocks.",
	"Method": "void verifyInvocationsAcross(String method,VerificationMode mode,Object mocks){\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.data.redis.test.util.MockitoUtils.verifyInvocationsAcross",
	"Comment": "verifies a given method is called a total number of times across all given mocks.",
	"Method": "void verifyInvocationsAcross(String method,VerificationMode mode,Object mocks){\r\n    return String.format(\"%s for method: %s\", mode, method);\r\n}"
}, {
	"Path": "spoon.test.query_function.testclasses.VariableReferencesModelTest.localVarInNestedClass6",
	"Comment": "check localvariable shadowed in local class method by method parameter 39",
	"Method": "void localVarInNestedClass6(){\r\n    int field = 37;\r\n    assertTrue(field == 37);\r\n    class Local {\r\n        int field = 38;\r\n        void method(int field) {\r\n            assertTrue(field == 39);\r\n            assertTrue(this.field == 38);\r\n        }\r\n    }\r\n    new Local().method(39);\r\n    assertTrue(field == 37);\r\n}"
}, {
	"Path": "spoon.test.query_function.testclasses.VariableReferencesModelTest.localVarInNestedClass6",
	"Comment": "check localvariable shadowed in local class method by method parameter 39",
	"Method": "void localVarInNestedClass6(){\r\n    assertTrue(field == 39);\r\n    assertTrue(this.field == 38);\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.RepositoryRestConfiguration.setLimitParamName",
	"Comment": "set the name of the url query string parameter that indicates how many results to return at once.",
	"Method": "RepositoryRestConfiguration setLimitParamName(String limitParamName){\r\n    Assert.notNull(limitParamName, \"Limit param name cannot be null.\");\r\n    this.limitParamName = limitParamName;\r\n    return this;\r\n}"
}, {
	"Path": "spoon.reflect.path.CtPathBuilder.wildcard",
	"Comment": "add a simple wildcard. match only on elements child of current one.",
	"Method": "CtPathBuilder wildcard(){\r\n    return name(CtNamedPathElement.WILDCARD);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.ViewCommands.getMVCViewGenerationService",
	"Comment": "this method gets mvcviewgenerationservice implementation that contains necessary operationsto install templates inside generated project.",
	"Method": "MVCViewGenerationService getMVCViewGenerationService(String type){\r\n    try {\r\n        ServiceReference<?>[] references = this.context.getAllServiceReferences(MVCViewGenerationService.class.getName(), null);\r\n        for (ServiceReference<?> ref : references) {\r\n            MVCViewGenerationService viewGenerationService = (MVCViewGenerationService) this.context.getService(ref);\r\n            if (viewGenerationService.getName().equals(type)) {\r\n                return viewGenerationService;\r\n            }\r\n        }\r\n        return null;\r\n    } catch (InvalidSyntaxException e) {\r\n        LOGGER.warning(\"Cannot load MVCViewGenerationService on ViewCommands.\");\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.link.factory.LinkFactoryMetadata.getConstantForMethodName",
	"Comment": "builds and returns a private static final field with provided field name and initializer",
	"Method": "FieldMetadataBuilder getConstantForMethodName(String methodName){\r\n    if (constantForMethods.get(methodName) != null) {\r\n        return constantForMethods.get(methodName);\r\n    }\r\n    FieldMetadataBuilder constant = new FieldMetadataBuilder(getId(), Modifier.PUBLIC + Modifier.STATIC + Modifier.FINAL, new JavaSymbolName(methodName.toUpperCase()), JavaType.STRING, \"\\\"\" + methodName + \"\\\"\");\r\n    constantForMethods.put(methodName, constant);\r\n    return constant;\r\n}"
}, {
	"Path": "spoon.test.query_function.testclasses.VariableReferencesModelTest.localVarInNestedClass2",
	"Comment": "check localvariable shadowed in local class method by ctfield 27",
	"Method": "void localVarInNestedClass2(){\r\n    int field = 26;\r\n    assertTrue(field == 26);\r\n    Runnable fnc = new Runnable() {\r\n        int field = 27;\r\n        @Override\r\n        public void run() {\r\n            {\r\n                int field = 36;\r\n                assertTrue(field == 36);\r\n            }\r\n            assertTrue(field == 27);\r\n            int field = 28;\r\n            assertTrue(field == 28);\r\n            assertTrue(this.field == 27);\r\n        }\r\n    };\r\n    fnc.run();\r\n    assertTrue(field == 26);\r\n}"
}, {
	"Path": "spoon.test.query_function.testclasses.VariableReferencesModelTest.localVarInNestedClass2",
	"Comment": "check localvariable shadowed in local class method by ctfield 27",
	"Method": "void localVarInNestedClass2(){\r\n    {\r\n        int field = 36;\r\n        assertTrue(field == 36);\r\n    }\r\n    assertTrue(field == 27);\r\n    int field = 28;\r\n    assertTrue(field == 28);\r\n    assertTrue(this.field == 27);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaCustomImplMetadata.getFindByReferencedFieldsImpl",
	"Comment": "method that generates the findby referenced fields implementation method",
	"Method": "MethodMetadata getFindByReferencedFieldsImpl(FieldMetadata referencedField,MethodMetadata method,String referencedPathFieldName,List<FieldMetadata> fields){\r\n    JavaSymbolName methodName = method.getMethodName();\r\n    List<AnnotatedJavaType> parameterTypes = method.getParameterTypes();\r\n    List<JavaSymbolName> parameterNames = method.getParameterNames();\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, method.getReturnType(), parameterTypes, parameterNames, null);\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    JavaSymbolName referencedFieldParamName = parameterNames.get(0);\r\n    JavaSymbolName globalSearch = parameterNames.get(1);\r\n    JavaSymbolName pageable = parameterNames.get(2);\r\n    String entity = this.entity.getSimpleTypeName();\r\n    String entityVariable = StringUtils.uncapitalize(entity);\r\n    JavaType projection = QUERYDSL_PROJECTIONS;\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(String.format(\"%1$s %2$s = %1$s.%2$s;\", entityQtype.getNameIncludingTypeParameters(false, importResolver), entityVariable));\r\n    bodyBuilder.newLine();\r\n    buildQuery(bodyBuilder, entityVariable, globalSearch, referencedFieldParamName, referencedField, referencedPathFieldName, null, null, this.defaultReturnType, null, null);\r\n    bodyBuilder.newLine();\r\n    StringBuffer mappingBuilderLine = new StringBuffer();\r\n    mappingBuilderLine.append(String.format(\"%s mapping = buildMapper()\", SpringletsJavaType.SPRINGLETS_QUERYDSL_REPOSITORY_SUPPORT_ATTRIBUTE_BUILDER.getNameIncludingTypeParameters(false, this.importResolver)));\r\n    if (!this.typesAreProjections.get(this.defaultReturnType)) {\r\n        Iterator<FieldMetadata> iterator = fields.iterator();\r\n        while (iterator.hasNext()) {\r\n            FieldMetadata field = iterator.next();\r\n            String entityFieldName = field.getFieldName().getSymbolName();\r\n            mappingBuilderLine.append(String.format(\"\\n\\t\\t\\t.map(%s, %s.%s)\", getConstantForField(entityFieldName).getFieldName(), entityVariable, entityFieldName));\r\n        }\r\n    } else {\r\n        List<Pair<String, String>> projectionFields = this.typesFieldMaps.get(this.defaultReturnType);\r\n        Iterator<Pair<String, String>> iterator = projectionFields.iterator();\r\n        while (iterator.hasNext()) {\r\n            Pair<String, String> entry = iterator.next();\r\n            mappingBuilderLine.append(String.format(\"\\n\\t\\t\\t.map(%s, %s)\", getConstantForField(entry.getKey()).getFieldName(), entry.getValue()));\r\n        }\r\n    }\r\n    mappingBuilderLine.append(\";\");\r\n    bodyBuilder.appendFormalLine(mappingBuilderLine.toString());\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(String.format(\"applyPagination(pageable, query, mapping);\", pageable));\r\n    bodyBuilder.appendFormalLine(\"applyOrderById(query);\");\r\n    bodyBuilder.newLine();\r\n    buildQueryResult(bodyBuilder, pageable, entityVariable, projection, this.defaultReturnType);\r\n    methodBuilder.setBodyBuilder(bodyBuilder);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.JpaOperationsImpl.addTestScopedDependency",
	"Comment": "gets database dependency from config file and adds it with test scope",
	"Method": "void addTestScopedDependency(String moduleName,String databaseConfigPrefix,Element configuration){\r\n    final List<Element> databaseDependencies = XmlUtils.findElements(databaseConfigPrefix + \"/dependencies/dependency\", configuration);\r\n    for (final Element dependencyElement : databaseDependencies) {\r\n        NodeList childNodes = dependencyElement.getChildNodes();\r\n        for (int i = 0; i < childNodes.getLength(); i++) {\r\n            final Node node = childNodes.item(i);\r\n            if (node != null && node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(\"scope\")) {\r\n                node.setTextContent(\"test\");\r\n            }\r\n        }\r\n        getProjectOperations().addDependency(moduleName, new Dependency(dependencyElement));\r\n    }\r\n}"
}, {
	"Path": "com.duckduckgo.mobile.android.util.TorIntegration.dismissDialogs",
	"Comment": "if showing this will dismiss and release all the dialogs generated by torintegration",
	"Method": "void dismissDialogs(){\r\n    dismissOrbotStartDialog();\r\n    dismissOrbotPromptDialog();\r\n}"
}, {
	"Path": "com.duckduckgo.mobile.android.util.TorIntegration.showDownloadDialog",
	"Comment": "this method is taken from orbothelper it uses same resource strings but returns the dialog instead.",
	"Method": "AlertDialog showDownloadDialog(CharSequence stringTitle,CharSequence stringMessage,CharSequence stringButtonYes,CharSequence stringButtonNo,String uriString){\r\n    AlertDialog.Builder downloadDialog = new AlertDialog.Builder(context);\r\n    downloadDialog.setTitle(stringTitle);\r\n    downloadDialog.setMessage(stringMessage);\r\n    downloadDialog.setPositiveButton(stringButtonYes, new DialogInterface.OnClickListener() {\r\n        @Override\r\n        public void onClick(DialogInterface dialogInterface, int i) {\r\n            Uri uri = Uri.parse(uriString);\r\n            Intent intent = new Intent(Intent.ACTION_VIEW, uri);\r\n            context.startActivity(intent);\r\n        }\r\n    });\r\n    downloadDialog.setNegativeButton(stringButtonNo, new DialogInterface.OnClickListener() {\r\n        @Override\r\n        public void onClick(DialogInterface dialogInterface, int i) {\r\n        }\r\n    });\r\n    return downloadDialog.show();\r\n}"
}, {
	"Path": "com.duckduckgo.mobile.android.util.TorIntegration.showDownloadDialog",
	"Comment": "this method is taken from orbothelper it uses same resource strings but returns the dialog instead.",
	"Method": "AlertDialog showDownloadDialog(CharSequence stringTitle,CharSequence stringMessage,CharSequence stringButtonYes,CharSequence stringButtonNo,String uriString){\r\n    Uri uri = Uri.parse(uriString);\r\n    Intent intent = new Intent(Intent.ACTION_VIEW, uri);\r\n    context.startActivity(intent);\r\n}"
}, {
	"Path": "com.duckduckgo.mobile.android.util.TorIntegration.showDownloadDialog",
	"Comment": "this method is taken from orbothelper it uses same resource strings but returns the dialog instead.",
	"Method": "AlertDialog showDownloadDialog(CharSequence stringTitle,CharSequence stringMessage,CharSequence stringButtonYes,CharSequence stringButtonNo,String uriString){\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.PartTree.getParameters",
	"Comment": "method that obtains the necessary parameters of current finder",
	"Method": "List<FinderParameter> getParameters(){\r\n    return finderParameters;\r\n}"
}, {
	"Path": "org.apache.cassandra.index.SecondaryIndexManager.indexPartition",
	"Comment": "when building an index against existing data in sstables, add the given partition to the index",
	"Method": "void indexPartition(UnfilteredRowIterator partition,OpOrder.Group opGroup,Set<Index> indexes,int nowInSec){\r\n    if (!indexes.isEmpty()) {\r\n        DecoratedKey key = partition.partitionKey();\r\n        Set<Index.Indexer> indexers = indexes.stream().map(index -> index.indexerFor(key, nowInSec, opGroup, IndexTransaction.Type.UPDATE)).collect(Collectors.toSet());\r\n        indexers.forEach(Index.Indexer::begin);\r\n        try (RowIterator filtered = UnfilteredRowIterators.filter(partition, nowInSec)) {\r\n            if (!filtered.staticRow().isEmpty())\r\n                indexers.forEach(indexer -> indexer.insertRow(filtered.staticRow()));\r\n            while (filtered.hasNext()) {\r\n                Row row = filtered.next();\r\n                indexers.forEach(indexer -> indexer.insertRow(row));\r\n            }\r\n        }\r\n        indexers.forEach(Index.Indexer::finish);\r\n    }\r\n}"
}, {
	"Path": "spoon.metamodel.Metamodel.getAllMetamodelInterfaces",
	"Comment": "returns all interfaces of the spoon metamodel.\tthis method is stateless for sake of maintenance.\tif you need to call it several times, you should store the result.",
	"Method": "Set<CtType<?>> getAllMetamodelInterfaces(){\r\n    Set<CtType<?>> result = new HashSet();\r\n    Factory factory = new FactoryImpl(new DefaultCoreFactory(), new StandardEnvironment());\r\n    factory.getEnvironment().setLevel(\"INFO\");\r\n    result.add(factory.Type().get(spoon.reflect.code.BinaryOperatorKind.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtAbstractInvocation.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtAnnotationFieldAccess.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtArrayAccess.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtArrayRead.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtArrayWrite.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtAssert.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtAssignment.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtBinaryOperator.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtBlock.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtBodyHolder.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtBreak.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtCFlowBreak.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtCase.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtCatch.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtCatchVariable.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtCodeElement.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtCodeSnippetExpression.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtCodeSnippetStatement.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtComment.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtConditional.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtConstructorCall.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtContinue.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtDo.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtExecutableReferenceExpression.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtExpression.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtFieldAccess.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtFieldRead.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtFieldWrite.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtFor.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtForEach.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtIf.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtInvocation.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtJavaDoc.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtJavaDocTag.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtLabelledFlowBreak.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtLambda.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtLiteral.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtLocalVariable.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtLoop.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtNewArray.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtNewClass.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtOperatorAssignment.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtRHSReceiver.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtReturn.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtStatement.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtStatementList.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtSuperAccess.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtSwitch.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtSynchronized.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtTargetedExpression.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtThisAccess.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtThrow.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtTry.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtTryWithResource.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtTypeAccess.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtUnaryOperator.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtVariableAccess.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtVariableRead.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtVariableWrite.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.CtWhile.class));\r\n    result.add(factory.Type().get(spoon.reflect.code.UnaryOperatorKind.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtAnnotatedElementType.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtAnnotation.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtAnnotationMethod.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtAnnotationType.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtAnonymousExecutable.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtClass.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtCodeSnippet.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtCompilationUnit.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtConstructor.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtElement.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtEnum.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtEnumValue.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtExecutable.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtField.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtFormalTypeDeclarer.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtInterface.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtMethod.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtModifiable.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtMultiTypedElement.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtNamedElement.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtPackage.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtParameter.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtShadowable.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtType.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtTypeInformation.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtTypeMember.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtTypeParameter.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtTypedElement.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtVariable.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.ModifierKind.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.ParentNotInitializedException.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtActualTypeContainer.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtArrayTypeReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtCatchVariableReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtExecutableReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtFieldReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtIntersectionTypeReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtLocalVariableReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtPackageReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtParameterReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtTypeParameterReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtTypeReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtUnboundVariableReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtVariableReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtWildcardReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtTypeMemberWildcardImportReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtImport.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtImportKind.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtModule.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtModuleRequirement.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtPackageDeclaration.class));\r\n    result.add(factory.Type().get(CtPackageExport.class));\r\n    result.add(factory.Type().get(CtProvidedService.class));\r\n    result.add(factory.Type().get(spoon.reflect.reference.CtModuleReference.class));\r\n    result.add(factory.Type().get(spoon.reflect.declaration.CtUsedService.class));\r\n    result.add(factory.Type().get(CtModuleDirective.class));\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.plural.addon.PluralMetadata.createIdentifier",
	"Comment": "creates a plural identifier for the given type in the given path.",
	"Method": "String createIdentifier(JavaType javaType,LogicalPath path){\r\n    return PhysicalTypeIdentifierNamingUtils.createIdentifier(PROVIDES_TYPE_STRING, javaType, path);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.util.MongoDbErrorCodes.isClientSessionFailureCode",
	"Comment": "check if the given error code matches a know session related error.",
	"Method": "boolean isClientSessionFailureCode(Integer errorCode){\r\n    return errorCode == null ? false : clientSessionCodes.containsKey(errorCode);\r\n}"
}, {
	"Path": "spoon.refactoring.AbstractRenameRefactoring.isJavaIdentifier",
	"Comment": "helper method, which can be used by the child classes to check if name is an java identifier",
	"Method": "boolean isJavaIdentifier(String name){\r\n    return javaIdentifierRE.matcher(name).matches();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.dbre.addon.DbreDatabaseListenerImpl.getTypeLocationService",
	"Comment": "method to get typelocationservice service implementation",
	"Method": "TypeLocationService getTypeLocationService(){\r\n    if (typeLocationService == null) {\r\n        try {\r\n            ServiceReference<?>[] references = context.getAllServiceReferences(TypeLocationService.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                typeLocationService = (TypeLocationService) context.getService(ref);\r\n                return typeLocationService;\r\n            }\r\n            return null;\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load TypeLocationService on DbreDatabaseListenerImpl.\");\r\n            return null;\r\n        }\r\n    } else {\r\n        return typeLocationService;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.mapreduce.MapReduceOptions.outputTypeMerge",
	"Comment": "this option will merge new data into the old output collection. in other words, if the same key exists in both the\tresult set and the old collection, the new key will overwrite the old one.",
	"Method": "MapReduceOptions outputTypeMerge(){\r\n    this.outputType = MapReduceCommand.OutputType.MERGE;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.data.redis.core.RedisTemplate.execute",
	"Comment": "executes the given action object within a connection, which can be exposed or not.",
	"Method": "T execute(RedisCallback<T> action,T execute,RedisCallback<T> action,boolean exposeConnection,T execute,RedisCallback<T> action,boolean exposeConnection,boolean pipeline,T execute,SessionCallback<T> session,T execute,RedisScript<T> script,List<K> keys,Object args,T execute,RedisScript<T> script,RedisSerializer<?> argsSerializer,RedisSerializer<T> resultSerializer,List<K> keys,Object args){\r\n    return scriptExecutor.execute(script, argsSerializer, resultSerializer, keys, args);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.FinderOperationsImpl.checkDtoFieldsForFinder",
	"Comment": "validates that all dto fields matches with parameters on finder of a repository",
	"Method": "void checkDtoFieldsForFinder(ClassOrInterfaceTypeDetails formBeanDetails,PartTree finder,JavaType repository){\r\n    final JavaType dtoType = formBeanDetails.getName();\r\n    final String finderName = finder.getOriginalQuery();\r\n    FieldMetadata paramField, dtoField;\r\n    JavaType paramType, dtoFieldType;\r\n    for (FinderParameter param : finder.getParameters()) {\r\n        paramField = param.getPath().peek();\r\n        dtoField = formBeanDetails.getField(paramField.getFieldName());\r\n        Validate.notNull(dtoField, \"Field '%s' not found on DTO %s for finder '%s' of %s\", paramField.getFieldName(), dtoType, finderName, repository);\r\n        paramType = paramField.getFieldType().getBaseType();\r\n        dtoFieldType = dtoField.getFieldType().getBaseType();\r\n        Validate.isTrue(paramType.equals(dtoFieldType), \"Type missmatch for field '%s' on DTO %s for finder '%s' of %s: excepted %s and got %s\", dtoField.getFieldName(), dtoType, finderName, repository, paramType, dtoFieldType);\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.text.TextTemplate.getOpenArgString",
	"Comment": "returns the string used for containing args within the template.",
	"Method": "String getOpenArgString(String getOpenArgString){\r\n    return this.openArg;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.gen.populator.Shrub.clearSupplierOverride",
	"Comment": "clears the supplier override to force the weighted table to be usedinstead.",
	"Method": "void clearSupplierOverride(){\r\n    setSupplierOverride(null);\r\n}"
}, {
	"Path": "spoon.pattern.PatternBuilderHelper.getClonedPatternType",
	"Comment": "returns clone of the patterntype.\tthe clone is done only once. later calls returns cached clone.",
	"Method": "CtType<?> getClonedPatternType(){\r\n    if (clonedPatternType == null) {\r\n        clonedPatternType = patternType.clone();\r\n        if (patternType.isParentInitialized()) {\r\n            clonedPatternType.setParent(patternType.getParent());\r\n        }\r\n        setElements(Collections.singletonList(clonedPatternType));\r\n    }\r\n    return clonedPatternType;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform2.of",
	"Comment": "returns a new transform from the given transformation matrix, if theresulting transform would be discrete.",
	"Method": "Optional<DiscreteTransform2> of(Matrix3d matrix){\r\n    if (Arrays.stream(matrix.toArray()).anyMatch(value -> Math.rint(value) != value)) {\r\n        return Optional.empty();\r\n    }\r\n    return Optional.of(new DiscreteTransform2(matrix));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getModelAttributeMethod",
	"Comment": "this method provides the method to add to manage a model attribute from apath variable",
	"Method": "MethodMetadata getModelAttributeMethod(MethodMetadata getModelAttributeMethod,String pathVariable,ServiceMetadata serviceMetadata,FieldMetadata serviceField){\r\n    String pathVariableUncapitalized = StringUtils.uncapitalize(pathVariable);\r\n    final JavaSymbolName methodName = new JavaSymbolName(\"get\" + StringUtils.capitalize(pathVariable));\r\n    final JavaType idType = serviceMetadata.getCurrentFindOneMethod().getParameterTypes().get(0).getJavaType();\r\n    final JavaSymbolName idName = serviceMetadata.getCurrentFindOneMethod().getParameterNames().get(0);\r\n    final JavaType entityType = serviceMetadata.getCurrentFindOneMethod().getReturnType();\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    AnnotationMetadataBuilder pathVariableAnnotation = new AnnotationMetadataBuilder(SpringJavaType.PATH_VARIABLE);\r\n    pathVariableAnnotation.addStringAttribute(\"value\", pathVariableUncapitalized);\r\n    parameterTypes.add(new AnnotatedJavaType(idType, pathVariableAnnotation.build()));\r\n    parameterTypes.add(LOCALE_PARAM);\r\n    parameterTypes.add(new AnnotatedJavaType(SpringJavaType.HTTP_METHOD));\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    final List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    parameterNames.add(idName);\r\n    parameterNames.add(LOCALE_PARAM_NAME);\r\n    parameterNames.add(HTTP_METHOD_PARAM_NAME);\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    if (this.entityMetadata.isReadOnly()) {\r\n        bodyBuilder.appendFormalLine(\"%s %s = %s.%s(%s);\", getNameOfJavaType(entityType), pathVariableUncapitalized, serviceField.getFieldName(), serviceMetadata.getCurrentFindOneMethod().getMethodName(), idName);\r\n        bodyBuilder.appendFormalLine(\"if (%s == null) {\", pathVariableUncapitalized);\r\n        bodyBuilder.indent();\r\n        bodyBuilder.appendFormalLine(\"String message = %s.getMessage(\\\"error_NotFound\\\", new Object[] \" + \"{\\\"%s\\\", %s}, \\\"The record couldn't be found\\\", %s);\", MESSAGE_SOURCE, this.entity.getSimpleTypeName(), idName, LOCALE_PARAM_NAME.getSymbolName());\r\n        bodyBuilder.appendFormalLine(\"throw new %s(message);\", getNameOfJavaType(SPRINGLETS_NOT_FOUND_EXCEPTION));\r\n        bodyBuilder.indentRemove();\r\n        bodyBuilder.appendFormalLine(\"}\");\r\n    } else {\r\n        bodyBuilder.appendFormalLine(\"%s %s = null;\", getNameOfJavaType(entityType), pathVariableUncapitalized);\r\n        bodyBuilder.appendFormalLine(\"if (%s.PUT.equals(%s)) {\", getNameOfJavaType(SpringJavaType.HTTP_METHOD), HTTP_METHOD_PARAM_NAME);\r\n        bodyBuilder.indent();\r\n        bodyBuilder.appendFormalLine(\"%s = %s.%s(%s);\", pathVariableUncapitalized, serviceField.getFieldName().getSymbolName(), FIN_ONE_FOR_UPDATE_METHOD_NAME.getSymbolName(), idName);\r\n        bodyBuilder.indentRemove();\r\n        bodyBuilder.appendFormalLine(\"} else {\");\r\n        bodyBuilder.indent();\r\n        bodyBuilder.appendFormalLine(\"%s = %s.%s(%s);\", pathVariableUncapitalized, serviceField.getFieldName().getSymbolName(), serviceMetadata.getCurrentFindOneMethod().getMethodName().getSymbolName(), idName);\r\n        bodyBuilder.indentRemove();\r\n        bodyBuilder.appendFormalLine(\"}\");\r\n        bodyBuilder.newLine();\r\n        bodyBuilder.appendFormalLine(\"if (%s == null) {\", pathVariableUncapitalized);\r\n        bodyBuilder.indent();\r\n        bodyBuilder.appendFormalLine(\"String message = %s.getMessage(\\\"error_NotFound\\\", new Object[] {\\\"%s\\\", %s}, \\\"The record couldn't be found\\\", %s);\", MESSAGE_SOURCE, this.entity.getSimpleTypeName(), idName, LOCALE_PARAM_NAME.getSymbolName());\r\n        bodyBuilder.appendFormalLine(\"throw new %s(message);\", getNameOfJavaType(SPRINGLETS_NOT_FOUND_EXCEPTION));\r\n        bodyBuilder.indentRemove();\r\n        bodyBuilder.appendFormalLine(\"}\");\r\n    }\r\n    bodyBuilder.appendFormalLine(\"return %s;\", pathVariableUncapitalized);\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, entityType, parameterTypes, parameterNames, bodyBuilder);\r\n    methodBuilder.addAnnotation(ANN_METADATA_MODEL_ATTRIBUTE);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.spongepowered.api.text.channel.MessageChannel.combined",
	"Comment": "gets a message channel that targets all subjects contained within thegiven channels and applies the message transformations of each channel inorder.",
	"Method": "MessageChannel combined(MessageChannel channels,MessageChannel combined,Collection<MessageChannel> channels){\r\n    return new CombinedMessageChannel(channels);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.convert.MappingMongoConverter.getPotentiallyConvertedSimpleWrite",
	"Comment": "checks whether we have a custom conversion registered for the given value into an arbitrary simple mongo type.\treturns the converted value if so. if not, we perform special enum handling or simply return the value as is.",
	"Method": "Object getPotentiallyConvertedSimpleWrite(Object value){\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    Optional<Class<?>> customTarget = conversions.getCustomWriteTarget(value.getClass());\r\n    if (customTarget.isPresent()) {\r\n        return conversionService.convert(value, customTarget.get());\r\n    }\r\n    if (ObjectUtils.isArray(value)) {\r\n        if (value instanceof byte[]) {\r\n            return value;\r\n        }\r\n        return asCollection(value);\r\n    }\r\n    return Enum.class.isAssignableFrom(value.getClass()) ? ((Enum<?>) value).name() : value;\r\n}"
}, {
	"Path": "org.spongepowered.api.text.format.TextStyle.hasStrikethrough",
	"Comment": "checks for whether text where this style is applied has a strikethrough.",
	"Method": "Optional<Boolean> hasStrikethrough(){\r\n    return this.strikethrough;\r\n}"
}, {
	"Path": "org.springframework.data.redis.cache.RedisCache.createCacheKey",
	"Comment": "customization hook for creating cache key before it gets serialized.",
	"Method": "String createCacheKey(Object key){\r\n    String convertedKey = convertKey(key);\r\n    if (!cacheConfig.usePrefix()) {\r\n        return convertedKey;\r\n    }\r\n    return prefixCacheKey(convertedKey);\r\n}"
}, {
	"Path": "org.springframework.data.redis.listener.adapter.MessageListenerAdapter.setDelegate",
	"Comment": "set a target object to delegate message listening to. specified listener methods have to be present on this target\tobject.\tif no explicit delegate object has been specified, listener methods are expected to present on this adapter\tinstance, that is, on a custom subclass of this adapter, defining listener methods.",
	"Method": "void setDelegate(Object delegate){\r\n    Assert.notNull(delegate, \"Delegate must not be null\");\r\n    this.delegate = delegate;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.test.RepositoryJpaIntegrationTestMetadata.getFindAllCustomNotFilteredPagedTestMethod",
	"Comment": "builds a method to test the find all custom method not filtered and paged.",
	"Method": "MethodMetadata getFindAllCustomNotFilteredPagedTestMethod(){\r\n    JavaSymbolName methodName = new JavaSymbolName(String.format(\"findAllCustomNotFilteredPagedShouldReturnA%sPage\", this.entityPlural));\r\n    MethodMetadata method = getGovernorMethod(methodName);\r\n    if (method != null) {\r\n        return method;\r\n    }\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    bodyBuilder.appendFormalLine(\"// Exercise\");\r\n    bodyBuilder.appendFormalLine(\"%s<%s> all = %s().findAll((%s) null, new %s(0, 3));\", getNameOfJavaType(SpringJavaType.PAGE), getNameOfJavaType(this.defaultReturnType), getAccessorMethod(this.repositoryField).getMethodName(), getNameOfJavaType(SpringletsJavaType.SPRINGLETS_GLOBAL_SEARCH), getNameOfJavaType(SpringJavaType.PAGE_REQUEST));\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"// Verify\");\r\n    bodyBuilder.appendFormalLine(\"%s(all.getNumberOfElements())\", getNameOfJavaType(ASSERT_THAT));\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\".as(\\\"Check result number is not greater than the page size\\\").isLessThanOrEqualTo(3);\");\r\n    bodyBuilder.indentRemove();\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, JavaType.VOID_PRIMITIVE, bodyBuilder);\r\n    methodBuilder.addAnnotation(new AnnotationMetadataBuilder(TEST));\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.schema.TypedJsonSchemaObject.oneOf",
	"Comment": "the field value must match exactly one of the specified schemas.",
	"Method": "TypedJsonSchemaObject oneOf(Collection<JsonSchemaObject> oneOf,ObjectJsonSchemaObject oneOf,Collection<JsonSchemaObject> oneOf,NumericJsonSchemaObject oneOf,Collection<JsonSchemaObject> oneOf,StringJsonSchemaObject oneOf,Collection<JsonSchemaObject> oneOf,ArrayJsonSchemaObject oneOf,Collection<JsonSchemaObject> oneOf,BooleanJsonSchemaObject oneOf,Collection<JsonSchemaObject> oneOf,NullJsonSchemaObject oneOf,Collection<JsonSchemaObject> oneOf,DateJsonSchemaObject oneOf,Collection<JsonSchemaObject> oneOf,TimestampJsonSchemaObject oneOf,Collection<JsonSchemaObject> oneOf){\r\n    return new TypedJsonSchemaObject(types, description, generateDescription, restrictions.oneOf(oneOf));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.cache.CacheCommands.getCacheProviders",
	"Comment": "gets the right implementation of fieldcreatorprovider for a javatype",
	"Method": "List<CacheProvider> getCacheProviders(){\r\n    if (cacheProviders.isEmpty()) {\r\n        try {\r\n            ServiceReference<?>[] references = this.context.getAllServiceReferences(CacheProvider.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                CacheProvider cacheProvider = (CacheProvider) this.context.getService(ref);\r\n                cacheProviders.add(cacheProvider);\r\n            }\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load CacheProvider on CacheCommands.\");\r\n            return null;\r\n        }\r\n    }\r\n    return cacheProviders;\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.support.DefaultSelfLinkProvider.getResourceId",
	"Comment": "returns the identifier to be used to create the self link uri.",
	"Method": "Object getResourceId(Object instance){\r\n    Class<? extends Object> instanceType = instance.getClass();\r\n    return // \r\n    lookups.getPluginFor(instanceType).map(// \r\n    it -> it.getClass().cast(it)).map(it -> (Object) it.getResourceIdentifier(instance)).orElseGet(() -> identifierOrNull(instance));\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.jedis.JedisConnectionFactory.setDatabase",
	"Comment": "sets the index of the database used by this connection factory. default is 0.",
	"Method": "void setDatabase(int index){\r\n    Assert.isTrue(index >= 0, \"invalid DB index (a positive index required)\");\r\n    if (RedisConfiguration.isDatabaseIndexAware(configuration)) {\r\n        ((WithDatabaseIndex) configuration).setDatabase(index);\r\n        return;\r\n    }\r\n    standaloneConfig.setDatabase(index);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.pushin.PushInOperationsImpl.getNewField",
	"Comment": "this method generates new field instance using an existing fieldmetadata",
	"Method": "FieldMetadata getNewField(String declaredByMetadataId,FieldMetadata field){\r\n    FieldMetadataBuilder fieldBuilder = new FieldMetadataBuilder(declaredByMetadataId, field.getModifier(), field.getFieldName(), field.getFieldType(), field.getFieldInitializer());\r\n    fieldBuilder.setAnnotations(field.getAnnotations());\r\n    return fieldBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.RepositoryRestConfiguration.exposeIdsFor",
	"Comment": "set the list of domain types for which we will expose the id value as a normal property.",
	"Method": "RepositoryRestConfiguration exposeIdsFor(Class<?> domainTypes){\r\n    Collections.addAll(exposeIdsFor, domainTypes);\r\n    return this;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.blockray.BlockRay.end",
	"Comment": "traces the block ray to the end and returns the last blockaccepted by the filter, or none if the extent or block limit was reached.this advances the iterator.",
	"Method": "Optional<BlockRayHit<E>> end(Optional<BlockRayHit<E>> end){\r\n    BlockRayHit<E> last = null;\r\n    while (hasNext()) {\r\n        last = next();\r\n    }\r\n    return Optional.ofNullable(last);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Criteria.and",
	"Comment": "static factory method to create a criteria using the provided key",
	"Method": "Criteria and(String key){\r\n    return new Criteria(this.criteriaChain, key);\r\n}"
}, {
	"Path": "org.springframework.cloud.sleuth.annotation.SleuthAnnotationUtils.findAnnotation",
	"Comment": "searches for an annotation either on a method or inside the method parameters.",
	"Method": "T findAnnotation(Method method,Class<T> clazz){\r\n    T annotation = AnnotationUtils.findAnnotation(method, clazz);\r\n    if (annotation == null) {\r\n        try {\r\n            annotation = AnnotationUtils.findAnnotation(method.getDeclaringClass().getMethod(method.getName(), method.getParameterTypes()), clazz);\r\n        } catch (NoSuchMethodException | SecurityException ex) {\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"Exception occurred while tyring to find the annotation\", ex);\r\n            }\r\n        }\r\n    }\r\n    return annotation;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.responses.json.JSONMetadata.createNullExpression",
	"Comment": "checks field type and creates a proper expression to check against null.mainly differences will be between primitive and non primitive values.",
	"Method": "String createNullExpression(FieldMetadata field){\r\n    String expression = \"\";\r\n    JavaType versionType = field.getFieldType();\r\n    if (versionType.isPrimitive()) {\r\n        expression = String.format(\"%s.get%s() != 0\", entityItemName, field.getFieldName().getSymbolNameCapitalisedFirstLetter());\r\n    } else {\r\n        expression = String.format(\"%s.get%s() != null\", entityItemName, field.getFieldName().getSymbolNameCapitalisedFirstLetter());\r\n    }\r\n    return expression;\r\n}"
}, {
	"Path": "daikon.Daikon.suppressWithSimplify",
	"Comment": "process the invariants with simplify to remove redundant invariants",
	"Method": "void suppressWithSimplify(PptMap all_ppts){\r\n    System.out.print(\"Invoking Simplify to identify redundant invariants\");\r\n    System.out.flush();\r\n    stopwatch.reset();\r\n    for (Iterator<PptTopLevel> itor = all_ppts.ppt_all_iterator(); itor.hasNext(); ) {\r\n        PptTopLevel ppt = itor.next();\r\n        ppt.mark_implied_via_simplify(all_ppts);\r\n        System.out.print(\".\");\r\n        System.out.flush();\r\n    }\r\n    System.out.println(stopwatch.format());\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.Extent.getIntersectingCollisionBoxes",
	"Comment": "gets all the collision boxes that intersect the bounding box owned bythe entity, in no particular order. there may be more than one box perblock. this also includes entities.",
	"Method": "Set<AABB> getIntersectingCollisionBoxes(Entity owner,Set<AABB> getIntersectingCollisionBoxes,Entity owner,AABB box){\r\n    checkNotNull(owner, \"owner\");\r\n    return owner.getBoundingBox().map(box -> getIntersectingCollisionBoxes(owner, box)).orElse(Collections.emptySet());\r\n}"
}, {
	"Path": "spoon.test.query_function.testclasses.VariableReferencesModelTest.localVarInNestedClass",
	"Comment": "check localvariable shadowed in local class method by another localvariable declaration",
	"Method": "void localVarInNestedClass(){\r\n    int field = 23;\r\n    assertTrue(field == 23);\r\n    Runnable fnc = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            {\r\n                int field = 24;\r\n                assertTrue(field == 24);\r\n            }\r\n            assertTrue(field == 23);\r\n            int field = 25;\r\n            assertTrue(field == 25);\r\n        }\r\n    };\r\n    fnc.run();\r\n    assertTrue(field == 23);\r\n}"
}, {
	"Path": "spoon.test.query_function.testclasses.VariableReferencesModelTest.localVarInNestedClass",
	"Comment": "check localvariable shadowed in local class method by another localvariable declaration",
	"Method": "void localVarInNestedClass(){\r\n    {\r\n        int field = 24;\r\n        assertTrue(field == 24);\r\n    }\r\n    assertTrue(field == 23);\r\n    int field = 25;\r\n    assertTrue(field == 25);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.geo.GeoSpatialIndexTests.hasIndexOfType",
	"Comment": "returns whether an index with the given name exists for the given entity type.",
	"Method": "boolean hasIndexOfType(Class<?> entityType,String type){\r\n    return template.execute(entityType, new CollectionCallback<Boolean>() {\r\n        @SuppressWarnings(\"unchecked\")\r\n        public Boolean doInCollection(MongoCollection<org.bson.Document> collection) throws MongoException, DataAccessException {\r\n            List<org.bson.Document> indexes = new ArrayList<org.bson.Document>();\r\n            collection.listIndexes(org.bson.Document.class).into(indexes);\r\n            for (org.bson.Document indexInfo : indexes) {\r\n                org.bson.Document keys = (org.bson.Document) indexInfo.get(\"key\");\r\n                Map<String, Object> keysMap = keys;\r\n                for (String key : keysMap.keySet()) {\r\n                    Object indexType = keys.get(key);\r\n                    if (type.equals(indexType)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.geo.GeoSpatialIndexTests.hasIndexOfType",
	"Comment": "returns whether an index with the given name exists for the given entity type.",
	"Method": "boolean hasIndexOfType(Class<?> entityType,String type){\r\n    List<org.bson.Document> indexes = new ArrayList<org.bson.Document>();\r\n    collection.listIndexes(org.bson.Document.class).into(indexes);\r\n    for (org.bson.Document indexInfo : indexes) {\r\n        org.bson.Document keys = (org.bson.Document) indexInfo.get(\"key\");\r\n        Map<String, Object> keysMap = keys;\r\n        for (String key : keysMap.keySet()) {\r\n            Object indexType = keys.get(key);\r\n            if (type.equals(indexType)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform3.transformZ",
	"Comment": "transforms the z coordinate of a vectorusing this transform. only creates a newobject on the first call.",
	"Method": "int transformZ(Vector3i vector,int transformZ,int x,int y,int z){\r\n    return GenericMath.floor(this.matrixRow2.dot(x, y, z, 1) + GenericMath.FLT_EPSILON);\r\n}"
}, {
	"Path": "spoon.reflect.factory.ConstructorFactory.createReference",
	"Comment": "creates a constructor reference from an actual constructor.",
	"Method": "CtExecutableReference<T> createReference(CtConstructor<T> c,CtExecutableReference<T> createReference,Constructor<T> constructor,CtExecutableReference<T> createReference,CtTypeReference<T> type,CtExpression<?> parameters){\r\n    final CtExecutableReference<T> executableReference = factory.Core().createExecutableReference();\r\n    executableReference.setType(type);\r\n    executableReference.setDeclaringType(type == null ? null : type.clone());\r\n    executableReference.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);\r\n    List<CtTypeReference<?>> typeReferences = new ArrayList();\r\n    for (CtExpression<?> parameter : parameters) {\r\n        typeReferences.add(parameter.getType() == null ? null : parameter.getType().clone());\r\n    }\r\n    executableReference.setParameters(typeReferences);\r\n    return executableReference;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform3.transformY",
	"Comment": "transforms the y coordinate of a vectorusing this transform. only creates a newobject on the first call.",
	"Method": "int transformY(Vector3i vector,int transformY,int x,int y,int z){\r\n    return GenericMath.floor(this.matrixRow1.dot(x, y, z, 1) + GenericMath.FLT_EPSILON);\r\n}"
}, {
	"Path": "spoon.reflect.factory.EnumFactory.get",
	"Comment": "gets an already created enumeration from its qualified name.",
	"Method": "CtEnum<?> get(String qualifiedName){\r\n    try {\r\n        return (CtEnum<?>) super.get(qualifiedName);\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform3.transformX",
	"Comment": "transforms the x coordinate of a vectorusing this transform. only creates a newobject on the first call.",
	"Method": "int transformX(Vector3i vector,int transformX,int x,int y,int z){\r\n    return GenericMath.floor(this.matrixRow0.dot(x, y, z, 1) + GenericMath.FLT_EPSILON);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMainControllerMetadata.getJavasrcriptTemplates",
	"Comment": "returns the method which handles javascript templates request",
	"Method": "MethodMetadata getJavasrcriptTemplates(){\r\n    return javasrcriptTemplatesMethod;\r\n}"
}, {
	"Path": "spoon.reflect.visitor.ElementPrinterHelper.writeQualifiedName",
	"Comment": "splits qualified name to primitive tokens and sends them to tokenwriter individually",
	"Method": "TokenWriter writeQualifiedName(String qualifiedName){\r\n    StringTokenizer st = new StringTokenizer(qualifiedName, QUALIFIED_NAME_SEPARATORS, true);\r\n    while (st.hasMoreTokens()) {\r\n        String token = st.nextToken();\r\n        if (token.length() == 1 && QUALIFIED_NAME_SEPARATORS.indexOf(token.charAt(0)) >= 0) {\r\n            printer.writeSeparator(token);\r\n        } else {\r\n            printer.writeIdentifier(token);\r\n        }\r\n    }\r\n    return printer;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMVCViewResponseService.addThymeleafDependencies",
	"Comment": "this method adds necessary thymeleaf dependencies togenerated project",
	"Method": "void addThymeleafDependencies(Pom module){\r\n    getProjectOperations().addDependency(module.getModuleName(), STARTER_THYMELEAF_DEPENDENCY);\r\n    getProjectOperations().addDependency(module.getModuleName(), LAYOUT_THYMELEAF_DEPENDENCY);\r\n    getProjectOperations().addDependency(module.getModuleName(), DATA_THYMELEAF_DEPENDENCY);\r\n    getProjectOperations().addProperty(\"\", new Property(\"thymeleaf.version\", \"3.0.0.RELEASE\"));\r\n    getProjectOperations().addProperty(\"\", new Property(\"thymeleaf-layout-dialect.version\", \"2.0.0\"));\r\n    getProjectOperations().addProperty(\"\", new Property(\"thymeleaf-data-dialect.version\", \"2.0.1\"));\r\n}"
}, {
	"Path": "spoon.ContractVerifier.checkShadow",
	"Comment": "check that we have all shadow elements, and that they are correctly isshadow",
	"Method": "void checkShadow(){\r\n    new CtScanner() {\r\n        @Override\r\n        public void scan(CtElement element) {\r\n            if (element != null && CtShadowable.class.isAssignableFrom(element.getClass())) {\r\n                assertFalse(((CtShadowable) element).isShadow());\r\n            }\r\n            super.scan(element);\r\n        }\r\n        @Override\r\n        public <T> void visitCtTypeReference(CtTypeReference<T> reference) {\r\n            assertNotNull(reference);\r\n            if (CtTypeReference.NULL_TYPE_NAME.equals(reference.getSimpleName()) || \"?\".equals(reference.getSimpleName())) {\r\n                super.visitCtTypeReference(reference);\r\n                return;\r\n            }\r\n            final CtType<T> typeDeclaration = reference.getTypeDeclaration();\r\n            assertNotNull(reference.toString() + \" cannot be found in \", typeDeclaration);\r\n            assertEquals(reference.getSimpleName(), typeDeclaration.getSimpleName());\r\n            assertEquals(reference.getQualifiedName(), typeDeclaration.getQualifiedName());\r\n            if (reference.getDeclaration() == null) {\r\n                assertTrue(\"typeDeclaration must be shadow\", typeDeclaration.isShadow());\r\n            }\r\n            super.visitCtTypeReference(reference);\r\n        }\r\n        @Override\r\n        public <T> void visitCtExecutableReference(CtExecutableReference<T> reference) {\r\n            super.visitCtExecutableReference(reference);\r\n            assertNotNull(reference);\r\n            if (isLanguageExecutable(reference)) {\r\n                return;\r\n            }\r\n            final CtExecutable<T> executableDeclaration = reference.getExecutableDeclaration();\r\n            assertNotNull(\"cannot find decl for \" + reference.toString(), executableDeclaration);\r\n            assertEquals(reference.getSimpleName(), executableDeclaration.getSimpleName());\r\n            for (int i = 0; i < reference.getParameters().size(); i++) {\r\n                if (executableDeclaration instanceof CtLambda) {\r\n                    return;\r\n                }\r\n                CtTypeReference<?> methodParamTypeRef = executableDeclaration.getParameters().get(i).getType();\r\n                assertEquals(reference.getParameters().get(i).getQualifiedName(), methodParamTypeRef.getTypeErasure().getQualifiedName());\r\n            }\r\n            if (reference.getActualTypeArguments().isEmpty() && executableDeclaration instanceof CtMethod && !((CtMethod) executableDeclaration).getFormalCtTypeParameters().isEmpty()) {\r\n                assertEquals(reference.getSignature(), executableDeclaration.getSignature());\r\n            }\r\n            if (reference.getActualTypeArguments().isEmpty() && executableDeclaration instanceof CtConstructor && !((CtConstructor) executableDeclaration).getFormalCtTypeParameters().isEmpty()) {\r\n                assertEquals(reference.getSignature(), executableDeclaration.getSignature());\r\n            }\r\n            if (reference.getDeclaration() == null && CtShadowable.class.isAssignableFrom(executableDeclaration.getClass())) {\r\n                assertTrue(\"execDecl at \" + reference.toString() + \" must be shadow \", ((CtShadowable) executableDeclaration).isShadow());\r\n            }\r\n        }\r\n        private <T> boolean isLanguageExecutable(CtExecutableReference<T> reference) {\r\n            return \"values\".equals(reference.getSimpleName());\r\n        }\r\n        @Override\r\n        public <T> void visitCtFieldReference(CtFieldReference<T> reference) {\r\n            assertNotNull(reference);\r\n            if (isLanguageField(reference) || isDeclaredInSuperClass(reference)) {\r\n                super.visitCtFieldReference(reference);\r\n                return;\r\n            }\r\n            final CtField<T> fieldDeclaration = reference.getFieldDeclaration();\r\n            assertNotNull(fieldDeclaration);\r\n            assertEquals(reference.getSimpleName(), fieldDeclaration.getSimpleName());\r\n            assertEquals(reference.getType().getQualifiedName(), fieldDeclaration.getType().getQualifiedName());\r\n            if (reference.getDeclaration() == null) {\r\n                assertTrue(\"fieldDecl must be shadow\", fieldDeclaration.isShadow());\r\n            }\r\n            super.visitCtFieldReference(reference);\r\n        }\r\n        private <T> boolean isLanguageField(CtFieldReference<T> reference) {\r\n            return \"class\".equals(reference.getSimpleName()) || \"length\".equals(reference.getSimpleName());\r\n        }\r\n        private <T> boolean isDeclaredInSuperClass(CtFieldReference<T> reference) {\r\n            final CtType<?> typeDeclaration = reference.getDeclaringType().getTypeDeclaration();\r\n            return typeDeclaration != null && typeDeclaration.getField(reference.getSimpleName()) == null;\r\n        }\r\n    }.visitCtPackage(_rootPackage);\r\n}"
}, {
	"Path": "spoon.ContractVerifier.checkShadow",
	"Comment": "check that we have all shadow elements, and that they are correctly isshadow",
	"Method": "void checkShadow(){\r\n    if (element != null && CtShadowable.class.isAssignableFrom(element.getClass())) {\r\n        assertFalse(((CtShadowable) element).isShadow());\r\n    }\r\n    super.scan(element);\r\n}"
}, {
	"Path": "spoon.ContractVerifier.checkShadow",
	"Comment": "check that we have all shadow elements, and that they are correctly isshadow",
	"Method": "void checkShadow(){\r\n    assertNotNull(reference);\r\n    if (CtTypeReference.NULL_TYPE_NAME.equals(reference.getSimpleName()) || \"?\".equals(reference.getSimpleName())) {\r\n        super.visitCtTypeReference(reference);\r\n        return;\r\n    }\r\n    final CtType<T> typeDeclaration = reference.getTypeDeclaration();\r\n    assertNotNull(reference.toString() + \" cannot be found in \", typeDeclaration);\r\n    assertEquals(reference.getSimpleName(), typeDeclaration.getSimpleName());\r\n    assertEquals(reference.getQualifiedName(), typeDeclaration.getQualifiedName());\r\n    if (reference.getDeclaration() == null) {\r\n        assertTrue(\"typeDeclaration must be shadow\", typeDeclaration.isShadow());\r\n    }\r\n    super.visitCtTypeReference(reference);\r\n}"
}, {
	"Path": "spoon.ContractVerifier.checkShadow",
	"Comment": "check that we have all shadow elements, and that they are correctly isshadow",
	"Method": "void checkShadow(){\r\n    super.visitCtExecutableReference(reference);\r\n    assertNotNull(reference);\r\n    if (isLanguageExecutable(reference)) {\r\n        return;\r\n    }\r\n    final CtExecutable<T> executableDeclaration = reference.getExecutableDeclaration();\r\n    assertNotNull(\"cannot find decl for \" + reference.toString(), executableDeclaration);\r\n    assertEquals(reference.getSimpleName(), executableDeclaration.getSimpleName());\r\n    for (int i = 0; i < reference.getParameters().size(); i++) {\r\n        if (executableDeclaration instanceof CtLambda) {\r\n            return;\r\n        }\r\n        CtTypeReference<?> methodParamTypeRef = executableDeclaration.getParameters().get(i).getType();\r\n        assertEquals(reference.getParameters().get(i).getQualifiedName(), methodParamTypeRef.getTypeErasure().getQualifiedName());\r\n    }\r\n    if (reference.getActualTypeArguments().isEmpty() && executableDeclaration instanceof CtMethod && !((CtMethod) executableDeclaration).getFormalCtTypeParameters().isEmpty()) {\r\n        assertEquals(reference.getSignature(), executableDeclaration.getSignature());\r\n    }\r\n    if (reference.getActualTypeArguments().isEmpty() && executableDeclaration instanceof CtConstructor && !((CtConstructor) executableDeclaration).getFormalCtTypeParameters().isEmpty()) {\r\n        assertEquals(reference.getSignature(), executableDeclaration.getSignature());\r\n    }\r\n    if (reference.getDeclaration() == null && CtShadowable.class.isAssignableFrom(executableDeclaration.getClass())) {\r\n        assertTrue(\"execDecl at \" + reference.toString() + \" must be shadow \", ((CtShadowable) executableDeclaration).isShadow());\r\n    }\r\n}"
}, {
	"Path": "spoon.ContractVerifier.checkShadow",
	"Comment": "check that we have all shadow elements, and that they are correctly isshadow",
	"Method": "void checkShadow(){\r\n    return \"values\".equals(reference.getSimpleName());\r\n}"
}, {
	"Path": "spoon.ContractVerifier.checkShadow",
	"Comment": "check that we have all shadow elements, and that they are correctly isshadow",
	"Method": "void checkShadow(){\r\n    assertNotNull(reference);\r\n    if (isLanguageField(reference) || isDeclaredInSuperClass(reference)) {\r\n        super.visitCtFieldReference(reference);\r\n        return;\r\n    }\r\n    final CtField<T> fieldDeclaration = reference.getFieldDeclaration();\r\n    assertNotNull(fieldDeclaration);\r\n    assertEquals(reference.getSimpleName(), fieldDeclaration.getSimpleName());\r\n    assertEquals(reference.getType().getQualifiedName(), fieldDeclaration.getType().getQualifiedName());\r\n    if (reference.getDeclaration() == null) {\r\n        assertTrue(\"fieldDecl must be shadow\", fieldDeclaration.isShadow());\r\n    }\r\n    super.visitCtFieldReference(reference);\r\n}"
}, {
	"Path": "spoon.ContractVerifier.checkShadow",
	"Comment": "check that we have all shadow elements, and that they are correctly isshadow",
	"Method": "void checkShadow(){\r\n    return \"class\".equals(reference.getSimpleName()) || \"length\".equals(reference.getSimpleName());\r\n}"
}, {
	"Path": "spoon.ContractVerifier.checkShadow",
	"Comment": "check that we have all shadow elements, and that they are correctly isshadow",
	"Method": "void checkShadow(){\r\n    final CtType<?> typeDeclaration = reference.getDeclaringType().getTypeDeclaration();\r\n    return typeDeclaration != null && typeDeclaration.getField(reference.getSimpleName()) == null;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.test.JsonControllerTestCreator.getValidDataOnDemandCreatorsForType",
	"Comment": "gets all the valid implementations of dataondemandcreatorprovider for a javatype.",
	"Method": "List<DataOnDemandCreatorProvider> getValidDataOnDemandCreatorsForType(JavaType type){\r\n    if (this.dodCreators.isEmpty()) {\r\n        try {\r\n            ServiceReference<?>[] references = this.context.getAllServiceReferences(DataOnDemandCreatorProvider.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                DataOnDemandCreatorProvider dodCreatorProvider = (DataOnDemandCreatorProvider) this.context.getService(ref);\r\n                this.dodCreators.add(dodCreatorProvider);\r\n            }\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load DataOnDemandCreatorProvider on JsonControllerTestCreator.\");\r\n            return null;\r\n        }\r\n    }\r\n    List<DataOnDemandCreatorProvider> validDoDCreators = new ArrayList<DataOnDemandCreatorProvider>();\r\n    for (DataOnDemandCreatorProvider provider : this.dodCreators) {\r\n        if (provider.isValid(type)) {\r\n            validDoDCreators.add(provider);\r\n        }\r\n    }\r\n    return validDoDCreators;\r\n}"
}, {
	"Path": "spoon.ContractVerifier.checkParentContract",
	"Comment": "checks that there is always one parent, corresponding to the scanning order",
	"Method": "void checkParentContract(){\r\n    _rootPackage.filterChildren(null).forEach((CtElement elem) -> {\r\n        assertTrue(\"no parent for \" + elem.getClass() + \"-\" + elem.getPosition(), elem.isParentInitialized());\r\n    });\r\n    new CtScanner() {\r\n        Deque<CtElement> elementStack = new ArrayDeque();\r\n        @Override\r\n        public void scan(CtElement e) {\r\n            if (e == null) {\r\n                return;\r\n            }\r\n            if (e instanceof CtReference) {\r\n                return;\r\n            }\r\n            if (!elementStack.isEmpty()) {\r\n                assertEquals(elementStack.peek(), e.getParent());\r\n            }\r\n            elementStack.push(e);\r\n            e.accept(this);\r\n            elementStack.pop();\r\n        }\r\n    }.scan(_rootPackage);\r\n}"
}, {
	"Path": "spoon.ContractVerifier.checkParentContract",
	"Comment": "checks that there is always one parent, corresponding to the scanning order",
	"Method": "void checkParentContract(){\r\n    if (e == null) {\r\n        return;\r\n    }\r\n    if (e instanceof CtReference) {\r\n        return;\r\n    }\r\n    if (!elementStack.isEmpty()) {\r\n        assertEquals(elementStack.peek(), e.getParent());\r\n    }\r\n    elementStack.push(e);\r\n    e.accept(this);\r\n    elementStack.pop();\r\n}"
}, {
	"Path": "org.spongepowered.api.text.channel.MessageChannel.fixed",
	"Comment": "creates a message channel that targets the given recipients.",
	"Method": "MessageChannel fixed(MessageReceiver recipients,MessageChannel fixed,Collection<? extends MessageReceiver> recipients){\r\n    return new FixedMessageChannel(recipients);\r\n}"
}, {
	"Path": "org.spongepowered.api.world.Location.setBlock",
	"Comment": "replace the block at this position with a new state.this will remove any extended block data at the given position.",
	"Method": "boolean setBlock(BlockState state,boolean setBlock,BlockState state,BlockChangeFlag flag){\r\n    return getExtent().setBlock(getBlockPosition(), state, flag);\r\n}"
}, {
	"Path": "org.spongepowered.api.util.Coerce.toLong",
	"Comment": "coerce the supplied object to a long number, parse it if necessary.",
	"Method": "long toLong(Object obj){\r\n    if (obj == null) {\r\n        return 0;\r\n    }\r\n    if (obj instanceof Number) {\r\n        return ((Number) obj).longValue();\r\n    }\r\n    try {\r\n        return Long.parseLong(Coerce.sanitiseNumber(obj));\r\n    } catch (NumberFormatException e) {\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.AbstractViewGenerationService.buildLabel",
	"Comment": "builds the label of the specified field by joining its names and adding itto the entity label",
	"Method": "String buildLabel(String entityName,String fieldNames){\r\n    String label = XmlUtils.convertId(\"label.\" + entityName.toLowerCase());\r\n    for (String fieldName : fieldNames) {\r\n        label = XmlUtils.convertId(label.concat(\".\").concat(fieldName.toLowerCase()));\r\n    }\r\n    return label;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.dto.addon.DtoOperationsImpl.checkAndAddIdField",
	"Comment": "check if provided fields contain the related entity id field and otherwiseadds it to the map.",
	"Method": "String checkAndAddIdField(JavaType entity,String fieldsString){\r\n    List<FieldMetadata> identifierFields = getPersistenceMemberLocator().getIdentifierFields(entity);\r\n    String[] fieldsProvided = fieldsString.split(\",\");\r\n    for (FieldMetadata idField : identifierFields) {\r\n        boolean fieldIsInProjection = false;\r\n        for (String field : fieldsProvided) {\r\n            if (field.equals(idField.getFieldName().getSymbolName())) {\r\n                fieldIsInProjection = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!fieldIsInProjection) {\r\n            fieldsString = idField.getFieldName().getSymbolName().concat(\",\").concat(fieldsString);\r\n            LOGGER.info(String.format(\"INFO: You haven't included the identifier field/s of the entity '%s' in \" + \"your projection, which is necessary to be able to use this projection \" + \"in the view layer. But don't worry, Spring Roo has included it automatically.\", entity.getSimpleTypeName()));\r\n        }\r\n    }\r\n    return fieldsString;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.finder.WebFinderCommands.getInstalledControllerMVCResponseTypes",
	"Comment": "this method gets all implementations of controllermvcresponseservice interface to be ableto locate all installed controllermvcresponseservice",
	"Method": "Map<String, ControllerMVCResponseService> getInstalledControllerMVCResponseTypes(){\r\n    if (responseTypes.isEmpty()) {\r\n        try {\r\n            ServiceReference<?>[] references = this.context.getAllServiceReferences(ControllerMVCResponseService.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                ControllerMVCResponseService responseTypeService = (ControllerMVCResponseService) this.context.getService(ref);\r\n                boolean isInstalled = false;\r\n                for (Pom module : getProjectOperations().getPoms()) {\r\n                    if (responseTypeService.isInstalledInModule(module.getModuleName())) {\r\n                        isInstalled = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (isInstalled) {\r\n                    responseTypes.put(responseTypeService.getResponseType(), responseTypeService);\r\n                }\r\n            }\r\n            return responseTypes;\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load ControllerMVCResponseService on ControllerCommands.\");\r\n            return null;\r\n        }\r\n    } else {\r\n        return responseTypes;\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.InteractableVolume.placeBlock",
	"Comment": "simulates the placement of a block at the given location as if a playerhad done so.",
	"Method": "boolean placeBlock(Vector3i position,BlockState block,Direction side,GameProfile profile,boolean placeBlock,int x,int y,int z,BlockState block,Direction side,GameProfile profile){\r\n    return placeBlock(checkNotNull(position, \"position\").getX(), position.getY(), position.getZ(), block, side, profile);\r\n}"
}, {
	"Path": "spoon.support.StandardEnvironment.reportEnd",
	"Comment": "this method should be called to report the end of the processing.",
	"Method": "void reportEnd(){\r\n    logger.info(\"end of processing: \");\r\n    if (warningCount > 0) {\r\n        logger.info(warningCount + \" warning\");\r\n        if (warningCount > 1) {\r\n            logger.info(\"s\");\r\n        }\r\n        if (errorCount > 0) {\r\n            logger.info(\", \");\r\n        }\r\n    }\r\n    if (errorCount > 0) {\r\n        logger.info(errorCount + \" error\");\r\n        if (errorCount > 1) {\r\n            logger.info(\"s\");\r\n        }\r\n    }\r\n    if ((errorCount + warningCount) > 0) {\r\n        logger.info(\"\\n\");\r\n    } else {\r\n        logger.info(\"no errors, no warnings\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.convert.MongoWriter.convertToMongoType",
	"Comment": "converts the given object into one mongo will be able to store natively. if the given object can already be stored\tas is, no conversion will happen.",
	"Method": "Object convertToMongoType(Object obj,Object convertToMongoType,Object obj,TypeInformation<?> typeInformation){\r\n    return convertToMongoType(obj, null);\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.jpa.JpaWebTests.returnsProjectionIfRequested",
	"Comment": "checks, that the server only returns the properties contained in the projection requested.",
	"Method": "void returnsProjectionIfRequested(){\r\n    Link orders = client.discoverUnique(\"orders\");\r\n    MockHttpServletResponse response = client.request(orders);\r\n    Link orderLink = assertContentLinkWithRel(\"self\", response, true).expand();\r\n    UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(orderLink.getHref());\r\n    String uri = builder.queryParam(\"projection\", \"summary\").build().toUriString();\r\n    response = mvc.perform(get(uri)).andExpect(status().isOk()).andExpect(jsonPath(\"$.price\", is(2.5))).andReturn().getResponse();\r\n    assertJsonPathDoesntExist(\"$.lineItems\", response);\r\n}"
}, {
	"Path": "org.springframework.data.redis.core.TimeoutUtils.toSeconds",
	"Comment": "converts the given timeout to seconds.\tsince a 0 timeout blocks some redis ops indefinitely, this method will return 1 if the original value is greater\tthan 0 but is truncated to 0 on conversion.",
	"Method": "long toSeconds(long timeout,TimeUnit unit){\r\n    return roundUpIfNecessary(timeout, unit.toSeconds(timeout));\r\n}"
}, {
	"Path": "spoon.reflect.factory.CompilationUnitFactory.removeFromCache",
	"Comment": "removes compilation unit from the cache and returns it\tused by jdtsnippetcompiler to remove processed snippet from the cache",
	"Method": "CompilationUnit removeFromCache(String filePath){\r\n    return cachedCompilationUnits.remove(filePath);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.DefaultBulkOperationsIntegrationTests.mixedBulkOrdered",
	"Comment": "if working on the same set of documents, only an ordered bulk operation will yield predictable results.",
	"Method": "void mixedBulkOrdered(){\r\n    com.mongodb.bulk.BulkWriteResult result = createBulkOps(BulkMode.ORDERED, BaseDoc.class).insert(newDoc(\"1\", \"v1\")).updateOne(where(\"_id\", \"1\"), set(\"value\", \"v2\")).remove(where(\"value\", \"v2\")).execute();\r\n    assertThat(result, notNullValue());\r\n    assertThat(result.getInsertedCount(), is(1));\r\n    assertThat(result.getModifiedCount(), is(1));\r\n    assertThat(result.getDeletedCount(), is(1));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.entity.JpaEntityMetadata.getRemoveMethodName",
	"Comment": "generate method name to use for remove method of selected field",
	"Method": "JavaSymbolName getRemoveMethodName(FieldMetadata field){\r\n    final JavaSymbolName methodName = new JavaSymbolName(REMOVE_METHOD_PREFIX + StringUtils.capitalize(field.getFieldName().getSymbolName()));\r\n    return methodName;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.Location.setBlockType",
	"Comment": "replace the block type at this position by a new type.this will remove any extended block data at the given position.",
	"Method": "boolean setBlockType(BlockType type,boolean setBlockType,BlockType type,BlockChangeFlag flag){\r\n    return getExtent().setBlockType(getBlockPosition(), type, flag);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadataProviderImpl.getReturnTypeValidFields",
	"Comment": "return the entity list of valid fields. static and referenced fieldsare excluded.",
	"Method": "List<FieldMetadata> getReturnTypeValidFields(List<FieldMetadata> fields){\r\n    List<FieldMetadata> validFields = new ArrayList<FieldMetadata>();\r\n    for (FieldMetadata field : fields) {\r\n        if (field.getFieldType().isMultiValued()) {\r\n            continue;\r\n        }\r\n        if (Modifier.isStatic(field.getModifier()) || Modifier.isFinal(field.getModifier())) {\r\n            continue;\r\n        }\r\n        if (field.getAnnotation(JpaJavaType.ONE_TO_ONE) != null) {\r\n            continue;\r\n        }\r\n        if (field.getAnnotation(JpaJavaType.MANY_TO_ONE) != null) {\r\n            continue;\r\n        }\r\n        if (field.getAnnotation(JpaJavaType.EMBEDDED) != null || field.getAnnotation(JpaJavaType.EMBEDDED_ID) != null) {\r\n            continue;\r\n        }\r\n        validFields.add(field);\r\n    }\r\n    return validFields;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.pushin.PushInOperationsImpl.getTypeLocationService",
	"Comment": "method to obtain typelocationservice service implementation",
	"Method": "TypeLocationService getTypeLocationService(){\r\n    return serviceManager.getServiceInstance(this, TypeLocationService.class);\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.RepositoryRestConfiguration.setReturnBodyOnUpdate",
	"Comment": "set whether to return a response body after updating an entity.",
	"Method": "RepositoryRestConfiguration setReturnBodyOnUpdate(Boolean returnBodyOnUpdate){\r\n    this.returnBodyOnUpdate = returnBodyOnUpdate;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.data.rest.tests.TestMvcClient.request",
	"Comment": "convenience wrapper that first expands the link using uri substitution before requesting with the default media\ttype.",
	"Method": "MockHttpServletResponse request(String href,MediaType contentType,MockHttpServletResponse request,String href,MediaType contentType,HttpHeaders httpHeaders,MockHttpServletResponse request,Link link,MockHttpServletResponse request,Link link,MediaType mediaType,MockHttpServletResponse request,String href){\r\n    return request(href, DEFAULT_MEDIA_TYPE);\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.jedis.JedisVersionUtil.atMost",
	"Comment": "compares given version string against current jedis version.",
	"Method": "boolean atMost(String version){\r\n    return jedisVersion.compareTo(parseVersion(version)) <= 0;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.AABB.expand",
	"Comment": "expands this bounding box by a given amount in both directions andreturns a new box. the expansion is applied half and half to theminimum and maximum corners.",
	"Method": "AABB expand(Vector3i amount,AABB expand,Vector3d amount,AABB expand,double x,double y,double z){\r\n    x /= 2;\r\n    y /= 2;\r\n    z /= 2;\r\n    return new AABB(this.min.sub(x, y, z), this.max.add(x, y, z));\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Meta.setSnapshot",
	"Comment": "using snapshot prevents the cursor from returning a document more than once.",
	"Method": "void setSnapshot(boolean useSnapshot){\r\n    setValue(MetaKey.SNAPSHOT.key, useSnapshot);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.TextQuery.includeScore",
	"Comment": "include text search document score in returned fields using the given fieldname.",
	"Method": "TextQuery includeScore(TextQuery includeScore,String fieldname){\r\n    setScoreFieldName(fieldname);\r\n    includeScore();\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Part.getSupportedOperators",
	"Comment": "returns operators supported by the search expression property",
	"Method": "List<String> getSupportedOperators(){\r\n    if (property == null) {\r\n        return null;\r\n    }\r\n    List<String> typeKeywords = new ArrayList<String>();\r\n    List<Type> types = Type.getOperators(property.getLeft().peek().getFieldType());\r\n    boolean removePrefix = Type.ALL_KEYWORDS.contains(operatorGroup);\r\n    for (Type type : types) {\r\n        for (String keyword : type.getKeywords()) {\r\n            if (StringUtils.isBlank(operatorGroup) && !StringUtils.startsWithAny(keyword, Type.PREFIX_GROUP)) {\r\n                typeKeywords.add(keyword);\r\n            }\r\n            if (StringUtils.isNotBlank(operatorGroup) && keyword.startsWith(operatorGroup)) {\r\n                if (removePrefix) {\r\n                    typeKeywords.add(StringUtils.substringAfter(keyword, operatorGroup));\r\n                } else {\r\n                    typeKeywords.add(keyword);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (StringUtils.isBlank(operatorGroup)) {\r\n        typeKeywords.addAll(Arrays.asList(Type.PREFIX_GROUP));\r\n    }\r\n    return typeKeywords;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.Coerce.toShort",
	"Comment": "coerce the supplied object to a short number, parse it if necessary.",
	"Method": "short toShort(Object obj){\r\n    if (obj == null) {\r\n        return 0;\r\n    }\r\n    if (obj instanceof Number) {\r\n        return ((Number) obj).shortValue();\r\n    }\r\n    try {\r\n        return Short.parseShort(Coerce.sanitiseNumber(obj));\r\n    } catch (NumberFormatException e) {\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.RepositorySearchController.executeSearchCompact",
	"Comment": "executes a query method and exposes the results in compact form.",
	"Method": "ResourceSupport executeSearchCompact(RootResourceInformation resourceInformation,HttpHeaders headers,MultiValueMap<String, Object> parameters,String repository,String search,DefaultedPageable pageable,Sort sort,PersistentEntityResourceAssembler assembler){\r\n    Method method = checkExecutability(resourceInformation, search);\r\n    Optional<Object> result = executeQueryMethod(resourceInformation.getInvoker(), parameters, method, pageable, sort, assembler);\r\n    ResourceMetadata metadata = resourceInformation.getResourceMetadata();\r\n    ResponseEntity<?> entity = toResource(result, assembler, metadata.getDomainType(), Optional.empty(), headers, resourceInformation);\r\n    Object resource = entity.getBody();\r\n    List<Link> links = new ArrayList<Link>();\r\n    if (resource instanceof Resources && ((Resources<?>) resource).getContent() != null) {\r\n        for (Object obj : ((Resources<?>) resource).getContent()) {\r\n            if (null != obj && obj instanceof Resource) {\r\n                Resource<?> res = (Resource<?>) obj;\r\n                links.add(resourceLink(resourceInformation, res));\r\n            }\r\n        }\r\n    } else if (resource instanceof Resource) {\r\n        Resource<?> res = (Resource<?>) resource;\r\n        links.add(resourceLink(resourceInformation, res));\r\n    }\r\n    return new Resources<Resource<?>>(EMPTY_RESOURCE_LIST, links);\r\n}"
}, {
	"Path": "org.springframework.data.redis.repository.cdi.CdiBean.createPassivationId",
	"Comment": "creates a unique identifier for the given repository type and the given annotations.",
	"Method": "String createPassivationId(Set<Annotation> qualifiers,Class<?> repositoryType){\r\n    List<String> qualifierNames = new ArrayList(qualifiers.size());\r\n    for (Annotation qualifier : qualifiers) {\r\n        qualifierNames.add(qualifier.annotationType().getName());\r\n    }\r\n    Collections.sort(qualifierNames);\r\n    StringBuilder builder = new StringBuilder(StringUtils.collectionToDelimitedString(qualifierNames, \":\"));\r\n    builder.append(\":\").append(repositoryType.getName());\r\n    return builder.toString();\r\n}"
}, {
	"Path": "org.springframework.data.rest.tests.TestMvcClient.assertHasLinkWithRel",
	"Comment": "for a given servlet response, verify that the provided rel exists in its hypermedia. if so, return the uri link.",
	"Method": "Link assertHasLinkWithRel(String rel,MockHttpServletResponse response){\r\n    String content = response.getContentAsString();\r\n    Link link = getDiscoverer(response).findLinkWithRel(rel, content);\r\n    assertThat(\"Expected to find link with rel \" + rel + \" but found none in \" + content + \"!\", link, is(notNullValue()));\r\n    return link;\r\n}"
}, {
	"Path": "org.springframework.data.redis.listener.RedisMessageListenerContainer.sleepBeforeRecoveryAttempt",
	"Comment": "sleep according to the specified recovery interval. called between recovery attempts.",
	"Method": "void sleepBeforeRecoveryAttempt(){\r\n    if (this.recoveryInterval > 0) {\r\n        try {\r\n            Thread.sleep(this.recoveryInterval);\r\n        } catch (InterruptedException interEx) {\r\n            logger.debug(\"Thread interrupted while sleeping the recovery interval\");\r\n            Thread.currentThread().interrupt();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.world.Location.getBlockType",
	"Comment": "gets the base type of block.the type does not include block data such as the contents ofinventories.",
	"Method": "BlockType getBlockType(){\r\n    return getExtent().getBlockType(getBlockPosition());\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMVCViewResponseService.getName",
	"Comment": "this operation returns the feature name. in this case,the feature name is the same as the response type.",
	"Method": "String getName(){\r\n    return getResponseType();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.cache.CacheCommands.getProviderPossibleValues",
	"Comment": "this indicator returns the cache provider possible values.",
	"Method": "List<String> getProviderPossibleValues(ShellContext shellContext){\r\n    List<String> possibleValues = new ArrayList<String>();\r\n    for (CacheProvider provider : getCacheProviders()) {\r\n        possibleValues.add(provider.getName());\r\n    }\r\n    return possibleValues;\r\n}"
}, {
	"Path": "org.sat4j.minisat.core.Solver.analyzeFinalConflictInTermsOfAssumptions",
	"Comment": "derive a subset of the assumptions causing the inconistency.",
	"Method": "IVecInt analyzeFinalConflictInTermsOfAssumptions(Constr confl,IVecInt assumps,int conflictingLiteral){\r\n    if (assumps.size() == 0) {\r\n        return null;\r\n    }\r\n    while (!this.trailLim.isEmpty() && this.trailLim.last() == this.trail.size()) {\r\n        this.trailLim.pop();\r\n    }\r\n    final boolean[] seen = this.mseen;\r\n    final IVecInt outLearnt = this.moutLearnt;\r\n    final IVecInt preason = this.mpreason;\r\n    outLearnt.clear();\r\n    if (this.trailLim.size() == 0) {\r\n        return outLearnt;\r\n    }\r\n    assert outLearnt.size() == 0;\r\n    for (int i = 0; i < seen.length; i++) {\r\n        seen[i] = false;\r\n    }\r\n    if (confl == null) {\r\n        seen[conflictingLiteral >> 1] = true;\r\n    }\r\n    int p = ILits.UNDEFINED;\r\n    while (confl == null && this.trail.size() > 0 && this.trailLim.size() > 0) {\r\n        p = this.trail.last();\r\n        confl = this.voc.getReason(p);\r\n        undoOne();\r\n        if (confl == null && p == (conflictingLiteral ^ 1)) {\r\n            outLearnt.push(toDimacs(p));\r\n        }\r\n        if (this.trail.size() <= this.trailLim.last()) {\r\n            this.trailLim.pop();\r\n        }\r\n    }\r\n    if (confl == null) {\r\n        return outLearnt;\r\n    }\r\n    do {\r\n        preason.clear();\r\n        confl.calcReason(p, preason);\r\n        for (int j = 0; j < preason.size(); j++) {\r\n            int q = preason.get(j);\r\n            if (!seen[q >> 1]) {\r\n                seen[q >> 1] = true;\r\n                if (this.voc.getReason(q) == null && this.voc.getLevel(q) > 0) {\r\n                    assert assumps.contains(toDimacs(q));\r\n                    outLearnt.push(toDimacs(q));\r\n                }\r\n            }\r\n        }\r\n        do {\r\n            p = this.trail.last();\r\n            confl = this.voc.getReason(p);\r\n            undoOne();\r\n            if (decisionLevel() > 0 && this.trail.size() <= this.trailLim.last()) {\r\n                this.trailLim.pop();\r\n            }\r\n        } while (this.trail.size() > 0 && decisionLevel() > 0 && (!seen[p >> 1] || confl == null));\r\n    } while (decisionLevel() > 0);\r\n    return outLearnt;\r\n}"
}, {
	"Path": "spoon.template.Substitution.substituteStatement",
	"Comment": "gets a statement from a template executable with all the template\tparameters substituted.",
	"Method": "CtStatement substituteStatement(CtClass<?> targetClass,Template<?> template,int statementIndex,String executableName,CtTypeReference<?> parameterTypes){\r\n    CtClass<?> sourceClass = getTemplateCtClass(targetClass, template);\r\n    CtExecutable<?> sourceExecutable = executableName.equals(template.getClass().getSimpleName()) ? sourceClass.getConstructor(parameterTypes) : sourceClass.getMethod(executableName, parameterTypes);\r\n    return substitute(targetClass, template, sourceExecutable.getBody().getStatement(statementIndex));\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.EntityOperations.determineEntityCollectionName",
	"Comment": "returns the collection name to be used for the given entity.",
	"Method": "String determineEntityCollectionName(Object obj){\r\n    return null == obj ? null : determineCollectionName(obj.getClass());\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.JpaOperationsImpl.getIdentifierField",
	"Comment": "this method generates the identifier field using the provided values.",
	"Method": "FieldMetadata getIdentifierField(JavaType entity,String identifierField,JavaType identifierType,String identifierColumn,String sequenceName,IdentifierStrategy identifierStrategy,InheritanceType inheritanceType){\r\n    final List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n    final boolean hasIdClass = !(identifierType.isCoreType());\r\n    final JavaType annotationType = hasIdClass ? EMBEDDED_ID : ID;\r\n    annotations.add(new AnnotationMetadataBuilder(annotationType));\r\n    if (StringUtils.isEmpty(identifierField)) {\r\n        identifierField = \"id\";\r\n    }\r\n    if (!hasIdClass) {\r\n        if (!\"\".equals(sequenceName)) {\r\n            boolean isValidIdentifierStrategy = false;\r\n            if (identifierStrategy != null) {\r\n                for (IdentifierStrategy identifierStrategyType : IdentifierStrategy.values()) {\r\n                    if (identifierStrategyType.name().equals(identifierStrategy.name())) {\r\n                        isValidIdentifierStrategy = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!isValidIdentifierStrategy) {\r\n                identifierStrategy = IdentifierStrategy.AUTO;\r\n            }\r\n            if (IdentifierStrategy.AUTO.name().equals(identifierStrategy.name())) {\r\n                if (inheritanceType != null) {\r\n                    if (\"TABLE_PER_CLASS\".equals(inheritanceType.name())) {\r\n                        identifierStrategy = IdentifierStrategy.TABLE;\r\n                    }\r\n                }\r\n            }\r\n            final AnnotationMetadataBuilder generatedValueBuilder = new AnnotationMetadataBuilder(GENERATED_VALUE);\r\n            generatedValueBuilder.addEnumAttribute(\"strategy\", new EnumDetails(GENERATION_TYPE, new JavaSymbolName(identifierStrategy.name())));\r\n            if (StringUtils.isNotBlank(sequenceName)) {\r\n                final String sequenceKey = StringUtils.uncapitalize(entity.getSimpleTypeName()) + \"Gen\";\r\n                generatedValueBuilder.addStringAttribute(\"generator\", sequenceKey);\r\n                final AnnotationMetadataBuilder sequenceGeneratorBuilder = new AnnotationMetadataBuilder(SEQUENCE_GENERATOR);\r\n                sequenceGeneratorBuilder.addStringAttribute(\"name\", sequenceKey);\r\n                sequenceGeneratorBuilder.addStringAttribute(\"sequenceName\", sequenceName);\r\n                annotations.add(sequenceGeneratorBuilder);\r\n            }\r\n            annotations.add(generatedValueBuilder);\r\n        }\r\n        if (StringUtils.isNotBlank(identifierColumn)) {\r\n            final AnnotationMetadataBuilder columnBuilder = new AnnotationMetadataBuilder(COLUMN);\r\n            columnBuilder.addStringAttribute(\"name\", identifierColumn);\r\n            annotations.add(columnBuilder);\r\n        }\r\n    }\r\n    FieldDetails identifierFieldDetails = new FieldDetails(getTypeLocationService().getPhysicalTypeIdentifier(entity), identifierType, new JavaSymbolName(identifierField));\r\n    identifierFieldDetails.setModifiers(Modifier.PRIVATE);\r\n    identifierFieldDetails.addAnnotations(annotations);\r\n    return new FieldMetadataBuilder(identifierFieldDetails).build();\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.SimpleReactiveMongoDatabaseFactory.destroy",
	"Comment": "clean up the mongo instance if it was created by the factory itself.",
	"Method": "void destroy(){\r\n    if (mongoInstanceCreated) {\r\n        mongo.close();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.TextCriteria.forLanguage",
	"Comment": "for a full list of supported languages see the mongodb reference manual for\ttext search languages.",
	"Method": "TextCriteria forLanguage(String language){\r\n    Assert.hasText(language, \"Language must not be null or empty!\");\r\n    return new TextCriteria(language);\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.FutureResult.isStatus",
	"Comment": "indicates if this result is the status of an operation. typically status results will be discarded on conversion.",
	"Method": "boolean isStatus(){\r\n    return status;\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.json.patch.SpelPath.isAppend",
	"Comment": "returns whether the current path represents an append path, i.e. is supposed to append to collection.",
	"Method": "boolean isAppend(){\r\n    return path.endsWith(\"-\");\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Part.getParameters",
	"Comment": "builds a list of parameters based on the number of arguments that operator type needs and the property java type",
	"Method": "List<FinderParameter> getParameters(){\r\n    List<FinderParameter> parameters = new ArrayList<FinderParameter>();\r\n    String suffix = \"\";\r\n    int arguments;\r\n    if (!hasProperty()) {\r\n        return parameters;\r\n    }\r\n    if (!hasOperator()) {\r\n        arguments = Type.SIMPLE_PROPERTY.getNumberOfArguments();\r\n    } else {\r\n        arguments = type.getNumberOfArguments();\r\n    }\r\n    JavaType javaType = property.getLeft().peek().getFieldType();\r\n    String name = property.getLeft().peek().getFieldName().toString();\r\n    if (type != null && (type == Type.IN || type == Type.NOT_IN)) {\r\n        name = name.concat(\"List\");\r\n        JavaType listType = new JavaType(\"java.util.List\", 0, DataType.TYPE, null, Arrays.asList(new JavaType(javaType.getFullyQualifiedTypeName(), javaType.getArray(), DataType.TYPE, javaType.getArgName(), javaType.getParameters(), javaType.getModule())));\r\n        parameters.add(new FinderParameter(listType, new JavaSymbolName(name)));\r\n    } else {\r\n        for (int i = 0; i < arguments; i++) {\r\n            if (type.getNumberOfArguments() > 1) {\r\n                suffix = String.valueOf(i + 1);\r\n            }\r\n            parameters.add(new FinderParameter(javaType, new JavaSymbolName(name.concat(suffix)), property.getLeft()));\r\n        }\r\n    }\r\n    return parameters;\r\n}"
}, {
	"Path": "spoon.reflect.visitor.ImportScannerImpl.isTypeInCollision",
	"Comment": "test if the reference can be imported, i.e. test if the importation could lead to a collision.",
	"Method": "boolean isTypeInCollision(CtReference ref,boolean fqnMode){\r\n    if (targetType != null && targetType.getSimpleName().equals(ref.getSimpleName()) && !targetType.equals(ref)) {\r\n        return true;\r\n    }\r\n    try {\r\n        CtElement parent;\r\n        if (ref instanceof CtTypeReference) {\r\n            parent = ref.getParent();\r\n        } else {\r\n            parent = ref;\r\n        }\r\n        if (parent instanceof CtLiteral) {\r\n            return false;\r\n        }\r\n        Set<String> localVariablesOfBlock = new HashSet();\r\n        if (parent instanceof CtField) {\r\n            this.fieldAndMethodsNames.add(((CtField) parent).getSimpleName());\r\n        } else if (parent instanceof CtMethod) {\r\n            this.fieldAndMethodsNames.add(((CtMethod) parent).getSimpleName());\r\n        } else {\r\n            localVariablesOfBlock = this.lookForLocalVariables(parent);\r\n        }\r\n        while (!(parent instanceof CtPackage)) {\r\n            if ((parent instanceof CtFieldReference) || (parent instanceof CtExecutableReference) || (parent instanceof CtInvocation)) {\r\n                CtReference parentType;\r\n                if (parent instanceof CtInvocation) {\r\n                    parentType = ((CtInvocation) parent).getExecutable();\r\n                } else {\r\n                    parentType = (CtReference) parent;\r\n                }\r\n                LinkedList<String> qualifiedNameTokens = new LinkedList();\r\n                if (parentType != parent) {\r\n                    qualifiedNameTokens.add(parentType.getSimpleName());\r\n                }\r\n                CtTypeReference typeReference;\r\n                if (parent instanceof CtFieldReference) {\r\n                    typeReference = ((CtFieldReference) parent).getDeclaringType();\r\n                } else if (parent instanceof CtExecutableReference) {\r\n                    typeReference = ((CtExecutableReference) parent).getDeclaringType();\r\n                } else {\r\n                    typeReference = ((CtInvocation) parent).getExecutable().getDeclaringType();\r\n                }\r\n                if (typeReference != null) {\r\n                    qualifiedNameTokens.addFirst(typeReference.getSimpleName());\r\n                    if (typeReference.getPackage() != null) {\r\n                        StringTokenizer token = new StringTokenizer(typeReference.getPackage().getSimpleName(), CtPackage.PACKAGE_SEPARATOR);\r\n                        int index = 0;\r\n                        while (token.hasMoreElements()) {\r\n                            qualifiedNameTokens.add(index, token.nextToken());\r\n                            index++;\r\n                        }\r\n                    }\r\n                }\r\n                if (!qualifiedNameTokens.isEmpty()) {\r\n                    if (fieldAndMethodsNames.contains(qualifiedNameTokens.getFirst()) || localVariablesOfBlock.contains(qualifiedNameTokens.getFirst())) {\r\n                        qualifiedNameTokens.removeFirst();\r\n                        if (fqnMode) {\r\n                            if (ref instanceof CtTypeReference) {\r\n                                if (qualifiedNameTokens.isEmpty()) {\r\n                                    return true;\r\n                                }\r\n                                for (String testedToken : qualifiedNameTokens) {\r\n                                    if (!fieldAndMethodsNames.contains(testedToken) && !localVariablesOfBlock.contains(testedToken)) {\r\n                                        return true;\r\n                                    }\r\n                                }\r\n                                return false;\r\n                            } else {\r\n                                return true;\r\n                            }\r\n                        } else {\r\n                            for (String testedToken : qualifiedNameTokens) {\r\n                                if (!fieldAndMethodsNames.contains(testedToken) && !localVariablesOfBlock.contains(testedToken)) {\r\n                                    return false;\r\n                                }\r\n                            }\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            parent = parent.getParent();\r\n        }\r\n    } catch (ParentNotInitializedException e) {\r\n        return false;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.data.redis.listener.adapter.MessageListenerAdapter.handleListenerException",
	"Comment": "handle the given exception that arose during listener execution. the default implementation logs the exception at\terror level.",
	"Method": "void handleListenerException(Throwable ex){\r\n    logger.error(\"Listener execution failed\", ex);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.test.TestOperationsImpl.addUnitTestDependencies",
	"Comment": "add needed dependencies and plugins to run created unit tests.",
	"Method": "void addUnitTestDependencies(String module){\r\n    projectOperations.addDependency(module, JUNIT_DEPENDENCY);\r\n    projectOperations.addDependency(module, ASSERTJ_CORE_DEPENDENCY);\r\n    projectOperations.addDependency(module, SPRING_TEST_DEPENDENCY);\r\n    projectOperations.addBuildPlugin(module, MAVEN_SUREFIRE_PLUGIN);\r\n}"
}, {
	"Path": "org.spongepowered.api.util.Coerce.toEnum",
	"Comment": "coerce the specified object to an enum of the supplied type, returns thespecified default value if parsing fails.",
	"Method": "E toEnum(Object obj,Class<E> enumClass,E toEnum,Object obj,Class<E> enumClass,E defaultValue){\r\n    checkNotNull(enumClass, \"enumClass\");\r\n    checkNotNull(defaultValue, \"defaultValue\");\r\n    if (obj == null) {\r\n        return defaultValue;\r\n    }\r\n    if (enumClass.isAssignableFrom(obj.getClass())) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        E enumObj = (E) obj;\r\n        return enumObj;\r\n    }\r\n    String strObj = obj.toString().trim();\r\n    try {\r\n        return Enum.valueOf(enumClass, strObj);\r\n    } catch (IllegalArgumentException ex) {\r\n    }\r\n    for (E value : enumClass.getEnumConstants()) {\r\n        if (value.name().equalsIgnoreCase(strObj)) {\r\n            return value;\r\n        }\r\n    }\r\n    return defaultValue;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Part.getOperatorGroup",
	"Comment": "returns the operator group. if it does not have a group returns an empty string.",
	"Method": "String getOperatorGroup(){\r\n    return operatorGroup;\r\n}"
}, {
	"Path": "org.spongepowered.api.text.title.Title.isClear",
	"Comment": "returns whether this configuration is clearing the current title from thescreen.",
	"Method": "boolean isClear(boolean isClear){\r\n    return this.clear;\r\n}"
}, {
	"Path": "org.springframework.cloud.kubernetes.examples.GreetingController.getGreeting",
	"Comment": "endpoint to get a greeting. this endpoint uses a name server to get a name for the greeting.\trequest to the name service is guarded with a circuit breaker. therefore if a name service is not available or is too\tslow to response fallback name is used.\tdelay parameter can me used to make name service response slower.",
	"Method": "String getGreeting(int delay){\r\n    return String.format(\"Hello from %s!\", this.nameService.getName(delay));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Subject.getOptions",
	"Comment": "returns the different queries that can be build based on the current subject expressions.the options are joined to the current query expression.",
	"Method": "List<String> getOptions(){\r\n    List<String> options = new ArrayList<String>();\r\n    String query = toString();\r\n    if (StringUtils.isBlank(operation)) {\r\n        return Arrays.asList(ArrayUtils.add(QUERY_TYPE, COUNT_PATTERN));\r\n    }\r\n    options.add(query + \"By\");\r\n    if (property == null) {\r\n        for (FieldMetadata field : fields) {\r\n            options.add(query.concat(StringUtils.capitalize(field.getFieldName().toString())));\r\n        }\r\n        if (StringUtils.isBlank(limit) && !isCountProjection()) {\r\n            options.add(query.concat(\"First\"));\r\n            options.add(query.concat(\"Top\"));\r\n            if (!isDistinct()) {\r\n                options.add(query + DISTINCT);\r\n            } else {\r\n                for (FieldMetadata field : fields) {\r\n                    String name = StringUtils.capitalize(field.getFieldName().toString());\r\n                    if (name.startsWith(DISTINCT)) {\r\n                        options.add(query.concat(StringUtils.substringAfter(name, DISTINCT)));\r\n                    }\r\n                }\r\n            }\r\n        } else if (maxResults == null && !isCountProjection()) {\r\n            options.add(query + \"[Number]\");\r\n            for (FieldMetadata field : fields) {\r\n                String name = StringUtils.capitalize(field.getFieldName().toString());\r\n                if (name.startsWith(limit)) {\r\n                    options.add(query.concat(StringUtils.substringAfter(name, limit)));\r\n                } else if (isDistinct() && name.startsWith(DISTINCT.concat(limit))) {\r\n                    options.add(query.concat(StringUtils.substringAfter(name, DISTINCT.concat(limit))));\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        List<FieldMetadata> fields = currentPartTreeInstance.getValidProperties(property.getLeft().peek().getFieldType());\r\n        if (fields != null) {\r\n            for (FieldMetadata relatedEntityfield : fields) {\r\n                options.add(query.concat(StringUtils.capitalize(relatedEntityfield.getFieldName().toString())));\r\n            }\r\n        }\r\n    }\r\n    return options;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.generator.dummy.DummyObjectProvider.createExtendedFor",
	"Comment": "creates a new dummy class implementing the specified interface.",
	"Method": "I createExtendedFor(Class<T> type,String fieldName){\r\n    try {\r\n        return (I) factories.getUnchecked(type).getConstructor(String.class).newInstance(fieldName);\r\n    } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {\r\n        throw new RuntimeException(String.format(\"Failed to instantiate dummy class for class %s\", type), e);\r\n    }\r\n}"
}, {
	"Path": "spoon.template.Substitution.redirectTypeReferences",
	"Comment": "a helper method that recursively redirects all the type references from a\tsource type to a target type in the given element.",
	"Method": "void redirectTypeReferences(CtElement element,CtTypeReference<?> source,CtTypeReference<?> target){\r\n    List<CtTypeReference<?>> refs = Query.getReferences(element, new ReferenceTypeFilter(CtTypeReference.class));\r\n    String srcName = source.getQualifiedName();\r\n    String targetName = target.getSimpleName();\r\n    CtPackageReference targetPackage = target.getPackage();\r\n    for (CtTypeReference<?> ref : refs) {\r\n        if (ref.getQualifiedName().equals(srcName)) {\r\n            ref.setSimpleName(targetName);\r\n            ref.setPackage(targetPackage);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.dbre.addon.DbreDatabaseListenerImpl.hasStandardEntityAnnotations",
	"Comment": "indicates whether the given entity has the standard annotations appliedby roo, and no others.",
	"Method": "boolean hasStandardEntityAnnotations(ClassOrInterfaceTypeDetails entity){\r\n    final List<? extends AnnotationMetadata> typeAnnotations = entity.getAnnotations();\r\n    if (typeAnnotations.size() != 4) {\r\n        return false;\r\n    }\r\n    for (final AnnotationMetadata annotation : typeAnnotations) {\r\n        final JavaType annotationType = annotation.getAnnotationType();\r\n        final boolean entityAnnotation = ROO_JPA_ENTITY.equals(annotationType);\r\n        if (!entityAnnotation && !ROO_DB_MANAGED.equals(annotationType) && !ROO_JAVA_BEAN.equals(annotationType) && !ROO_TO_STRING.equals(annotationType)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.AbstractViewGenerationService.getReferenceField",
	"Comment": "this method obtains all necessary configuration to be able to work withreference fields. complete provided fielditem with extra fields. if someextra configuration is not available, returns false to prevent that thisfield will be added. if everything is ok, returns true to add this field togenerated view.",
	"Method": "boolean getReferenceField(FieldItem fieldItem,ClassOrInterfaceTypeDetails typeDetails,ViewContext<T> viewContext){\r\n    fieldItem.setType(FieldTypes.REFERENCE.toString());\r\n    fieldItem.addConfigurationElement(\"referencedEntity\", typeDetails.getType().getSimpleTypeName());\r\n    final String controllerPrefix = viewContext.getViewMetadata().getControllerMetadata().getAnnotationValues().getPathPrefix();\r\n    Collection<ClassOrInterfaceTypeDetails> allControllers = getControllerLocator().getControllers(typeDetails.getType(), ControllerType.COLLECTION, getType());\r\n    Iterator<ClassOrInterfaceTypeDetails> it = allControllers.iterator();\r\n    String referencedPath = \"\";\r\n    ClassOrInterfaceTypeDetails referencedController = null;\r\n    while (it.hasNext()) {\r\n        ClassOrInterfaceTypeDetails controller = it.next();\r\n        ControllerAnnotationValues values = new ControllerAnnotationValues(controller);\r\n        AnnotationMetadata controllerAnnotation = controller.getAnnotation(RooJavaType.ROO_CONTROLLER);\r\n        AnnotationAttributeValue<String> prefixAttr = controllerAnnotation.getAttribute(\"pathPrefix\");\r\n        if (StringUtils.equals(values.getPathPrefix(), controllerPrefix)) {\r\n            referencedPath = getControllerOperations().getBaseUrlForController(controller);\r\n            referencedController = controller;\r\n            ClassOrInterfaceTypeDetails relatedEntityCid = getTypeLocationService().getTypeDetails(typeDetails.getType());\r\n            JpaEntityMetadata relatedEntityMetadata = getMetadataService().get(JpaEntityMetadata.createIdentifier(relatedEntityCid));\r\n            fieldItem.addConfigurationElement(\"identifierField\", relatedEntityMetadata.getCurrentIndentifierField().getFieldName().getSymbolName());\r\n            break;\r\n        }\r\n    }\r\n    if (referencedController == null) {\r\n        return false;\r\n    }\r\n    fieldItem.addConfigurationElement(\"referencedPath\", referencedPath);\r\n    fieldItem.addConfigurationElement(\"referencedController\", referencedController);\r\n    return true;\r\n}"
}, {
	"Path": "spoon.test.refactoring.testclasses.CtRenameLocalVariableRefactoringTestSubject.nestedClassMethodWithRefs",
	"Comment": "tests nested class and conflict with field, \tand nested local variable references, which must would be shadowed",
	"Method": "void nestedClassMethodWithRefs(){\r\n    @TestTryRename({ \"-var2\", \"-var3\", \"-var4\", \"-var5\", \"-var6\" })\r\n    int var1 = 1;\r\n    new Consumer<Integer>() {\r\n        @TestTryRename({ \"-var1\", \"-var3\", \"-var4\", \"-var5\", \"-var6\" })\r\n        int var2 = 2;\r\n        @Override\r\n        public void accept(@TestTryRename({ \"-var1\", \"var2\", \"-var3\", \"-var5\", \"-var6\" }) Integer var4) {\r\n            @TestTryRename({ \"-var1\", \"var2\", \"-var4\", \"-var5\", \"-var6\" })\r\n            int var3 = 3;\r\n            try {\r\n                @TestTryRename({ \"-var1\", \"var2\", \"-var3\", \"-var4\", \"var6\" })\r\n                int var5 = 5;\r\n                assertTrue(var1 == 1);\r\n                assertTrue(var2 == 2);\r\n                assertTrue(var3 == 3);\r\n                assertTrue(var4 == 4);\r\n                assertTrue(var5 == 5);\r\n                throw new NumberFormatException();\r\n            } catch (@TestTryRename({ \"-var1\", \"var2\", \"-var3\", \"-var4\", \"var5\" }) NumberFormatException var6) {\r\n                assertTrue(var1 == 1);\r\n                assertTrue(var2 == 2);\r\n                assertTrue(var3 == 3);\r\n                assertTrue(var4 == 4);\r\n            }\r\n        }\r\n    }.accept(4);\r\n    assertTrue(var1 == 1);\r\n}"
}, {
	"Path": "spoon.test.refactoring.testclasses.CtRenameLocalVariableRefactoringTestSubject.nestedClassMethodWithRefs",
	"Comment": "tests nested class and conflict with field, \tand nested local variable references, which must would be shadowed",
	"Method": "void nestedClassMethodWithRefs(){\r\n    @TestTryRename({ \"-var1\", \"var2\", \"-var4\", \"-var5\", \"-var6\" })\r\n    int var3 = 3;\r\n    try {\r\n        @TestTryRename({ \"-var1\", \"var2\", \"-var3\", \"-var4\", \"var6\" })\r\n        int var5 = 5;\r\n        assertTrue(var1 == 1);\r\n        assertTrue(var2 == 2);\r\n        assertTrue(var3 == 3);\r\n        assertTrue(var4 == 4);\r\n        assertTrue(var5 == 5);\r\n        throw new NumberFormatException();\r\n    } catch (@TestTryRename({ \"-var1\", \"var2\", \"-var3\", \"-var4\", \"var5\" }) NumberFormatException var6) {\r\n        assertTrue(var1 == 1);\r\n        assertTrue(var2 == 2);\r\n        assertTrue(var3 == 3);\r\n        assertTrue(var4 == 4);\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.util.Coerce.toListOf",
	"Comment": "coerce the specified object to a list containing only objects of typespecified by ofclass. also coerces list values wherepossible.",
	"Method": "List<T> toListOf(Object obj,Class<T> ofClass){\r\n    checkNotNull(ofClass, \"ofClass\");\r\n    List<T> filteredList = Lists.newArrayList();\r\n    for (Object o : Coerce.toList(obj)) {\r\n        if (ofClass.isAssignableFrom(o.getClass())) {\r\n            filteredList.add((T) o);\r\n        } else if (ofClass.equals(String.class)) {\r\n            filteredList.add((T) Coerce.toString(o));\r\n        } else if (ofClass.equals(Integer.TYPE) || ofClass.equals(Integer.class)) {\r\n            filteredList.add((T) (Integer) Coerce.toInteger(o));\r\n        } else if (ofClass.equals(Float.TYPE) || ofClass.equals(Float.class)) {\r\n            filteredList.add((T) new Float(Coerce.toDouble(o)));\r\n        } else if (ofClass.equals(Double.TYPE) || ofClass.equals(Double.class)) {\r\n            filteredList.add((T) (Double) Coerce.toDouble(o));\r\n        } else if (ofClass.equals(Boolean.TYPE) || ofClass.equals(Boolean.class)) {\r\n            filteredList.add((T) (Boolean) Coerce.toBoolean(o));\r\n        }\r\n    }\r\n    return filteredList;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.tailor.TailorCommands.tailorList",
	"Comment": "this method lists all available tailor configurations in the the rooshell.",
	"Method": "void tailorList(){\r\n    LOGGER.info(\"Available tailor configurations: \");\r\n    final Map<String, TailorConfiguration> configs = configLocator.getAvailableConfigurations();\r\n    final TailorConfiguration activeConfig = configLocator.getActiveTailorConfiguration();\r\n    final Iterator<String> iterator = configs.keySet().iterator();\r\n    while (iterator.hasNext()) {\r\n        final String configName = iterator.next();\r\n        final String isActive = activeConfig != null && configName.equals(activeConfig.getName()) ? \" [ ACTIVE ] \" : \"\";\r\n        LOGGER.info(\"\\to \" + configName + isActive + \" - \" + configs.get(configName).getDescription());\r\n    }\r\n}"
}, {
	"Path": "spoon.javadoc.internal.JavadocInlineTag.nextWord",
	"Comment": "return the next word of the string, in other words it stops when a space is encountered.",
	"Method": "String nextWord(String string){\r\n    int index = 0;\r\n    while (index < string.length() && !Character.isWhitespace(string.charAt(index))) {\r\n        index++;\r\n    }\r\n    return string.substring(0, index);\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform3.withTransformation",
	"Comment": "adds another transformation to this transformation andreturns int as a new transform.",
	"Method": "DiscreteTransform3 withTransformation(DiscreteTransform3 transform){\r\n    return new DiscreteTransform3(transform.getMatrix().mul(getMatrix()));\r\n}"
}, {
	"Path": "org.spongepowered.api.world.gen.populator.Forest.clearSupplierOverride",
	"Comment": "clears the supplier override to force the weighted table to be usedinstead.",
	"Method": "void clearSupplierOverride(){\r\n    setSupplierOverride(null);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Collation.alternate",
	"Comment": "set the field that determines whether collation should consider whitespace and punctuation as base characters for\tpurposes of comparison.",
	"Method": "Collation alternate(String alternate,Collation alternate,Alternate alternate){\r\n    Collation newInstance = copy();\r\n    newInstance.alternate = Optional.of(alternate);\r\n    return newInstance;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform2.transformX",
	"Comment": "transforms the x coordinate of a vector using this transform. onlycreates a new object on the first call.",
	"Method": "int transformX(Vector2i vector,int transformX,int x,int y){\r\n    return GenericMath.floor(this.matrixRow0.dot(x, y, 1) + GenericMath.FLT_EPSILON);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getAddColumnToReportBuilderMethod",
	"Comment": "generates a method to add columns to dynamicjasper report builder.",
	"Method": "MethodMetadata getAddColumnToReportBuilderMethod(){\r\n    JavaSymbolName methodName = ADD_COLUMN_TO_REPORT_BUILDER_METHOD_NAME;\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    parameterTypes.add(STRING_PARAM);\r\n    parameterTypes.add(new AnnotatedJavaType(FAST_REPORT_BUILDER));\r\n    parameterTypes.add(LOCALE_PARAM);\r\n    parameterTypes.add(STRING_PARAM);\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    final List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    final JavaSymbolName columnName = new JavaSymbolName(\"columnName\");\r\n    parameterNames.add(columnName);\r\n    final JavaSymbolName reportBuilder = new JavaSymbolName(\"builder\");\r\n    parameterNames.add(reportBuilder);\r\n    parameterNames.add(LOCALE_PARAM_NAME);\r\n    parameterNames.add(FILE_NAME_PARAM_NAME);\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    bodyBuilder.appendFormalLine(\"try {\");\r\n    for (int i = 0; i < this.entityValidFields.size(); i++) {\r\n        FieldMetadata fieldMetadata = this.entityValidFields.get(i);\r\n        String fieldName = fieldMetadata.getFieldName().getSymbolName();\r\n        if (i == 0) {\r\n            bodyBuilder.appendFormalLine(\"if (columnName.equals(\\\"%s\\\")) {\", fieldName);\r\n        } else {\r\n            bodyBuilder.appendFormalLine(\"else if (columnName.equals(\\\"%s\\\")) {\", fieldName);\r\n        }\r\n        bodyBuilder.indent();\r\n        JavaType fieldType = fieldMetadata.getFieldType();\r\n        if (fieldMetadata.getFieldName().equals(this.entityMetadata.getCurrentIndentifierField().getFieldName())) {\r\n            if (fieldType.isPrimitive()) {\r\n                bodyBuilder.appendFormalLine(\"builder.addColumn(%s().getMessage(\\\"%s_%s\\\", null, \\\"%s\\\", locale), \\\"%s\\\", %s.class.getName(), 50);\", getAccessorMethod(this.messageSourceField).getMethodName(), this.entityLabel, fieldName.toLowerCase(), getFieldDefaultLabelValue(fieldName), fieldName, fieldType.getSimpleTypeName());\r\n                getNameOfJavaType(fieldType);\r\n            } else {\r\n                bodyBuilder.appendFormalLine(\"builder.addColumn(%s().getMessage(\\\"%s_%s\\\", null, \\\"%s\\\", locale), \\\"%s\\\", %s.class.getName(), 50);\", getAccessorMethod(this.messageSourceField).getMethodName(), this.entityLabel, fieldName.toLowerCase(), getFieldDefaultLabelValue(fieldName), fieldName, getNameOfJavaType(fieldType.withoutParameters()));\r\n            }\r\n        } else {\r\n            if (fieldType.isPrimitive()) {\r\n                bodyBuilder.appendFormalLine(\"builder.addColumn(%s().getMessage(\\\"%s_%s\\\", null, \\\"%s\\\", locale), \\\"%s\\\", %s.class.getName(), 100);\", getAccessorMethod(this.messageSourceField).getMethodName(), this.entityLabel, fieldName.toLowerCase(), getFieldDefaultLabelValue(fieldName), fieldName, fieldType.getSimpleTypeName());\r\n                getNameOfJavaType(fieldType);\r\n            } else {\r\n                bodyBuilder.appendFormalLine(\"builder.addColumn(%s().getMessage(\\\"%s_%s\\\", null, \\\"%s\\\", locale), \\\"%s\\\", %s.class.getName(), 100);\", getAccessorMethod(this.messageSourceField).getMethodName(), this.entityLabel, fieldName.toLowerCase(), getFieldDefaultLabelValue(fieldName), fieldName, getNameOfJavaType(fieldType.withoutParameters()));\r\n            }\r\n        }\r\n        bodyBuilder.indentRemove();\r\n        bodyBuilder.appendFormalLine(\"}\");\r\n    }\r\n    bodyBuilder.appendFormalLine(\"}\");\r\n    buildExportCatchBlock(bodyBuilder, COLUMN_BUILDER_EXCEPTION);\r\n    buildExportCatchBlock(bodyBuilder, CLASS_NOT_FOUND_EXCEPTION);\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, JavaType.VOID_PRIMITIVE, parameterTypes, parameterNames, bodyBuilder);\r\n    CommentStructure commentStructure = new CommentStructure();\r\n    String description = \"This method contains all the entity fields that are able to be displayed in a \".concat(IOUtils.LINE_SEPARATOR).concat(\"report. The developer could add a new column to the report builder providing the \").concat(IOUtils.LINE_SEPARATOR).concat(\"field name and the builder where the new field will be added as column.\");\r\n    List<String> paramInfo = new ArrayList<String>();\r\n    paramInfo.add(\"columnName the field name to show as column\");\r\n    paramInfo.add(\"builder The builder where the new field will be added as column.\");\r\n    commentStructure.addComment(new JavadocComment(description, paramInfo, null, null), CommentLocation.BEGINNING);\r\n    methodBuilder.setCommentStructure(commentStructure);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform2.transformY",
	"Comment": "transforms the y coordinate of a vector using this transform. onlycreates a new object on the first call.",
	"Method": "int transformY(Vector2i vector,int transformY,int x,int y){\r\n    return GenericMath.floor(this.matrixRow1.dot(x, y, 1) + GenericMath.FLT_EPSILON);\r\n}"
}, {
	"Path": "spoon.reflect.visitor.DefaultJavaPrettyPrinter.isInitializeStaticFinalField",
	"Comment": "check if the target expression is a static final field initialized in a static anonymous block.",
	"Method": "boolean isInitializeStaticFinalField(CtExpression<T> targetExp){\r\n    final CtElement parent;\r\n    final CtAnonymousExecutable anonymousParent;\r\n    try {\r\n        parent = targetExp.getParent();\r\n        anonymousParent = targetExp.getParent(CtAnonymousExecutable.class);\r\n    } catch (ParentNotInitializedException e) {\r\n        return false;\r\n    }\r\n    return parent instanceof CtFieldWrite && targetExp.equals(((CtFieldWrite) parent).getTarget()) && anonymousParent != null && ((CtFieldWrite) parent).getVariable() != null && ((CtFieldWrite) parent).getVariable().getModifiers().contains(ModifierKind.STATIC) && ((CtFieldWrite) parent).getVariable().getModifiers().contains(ModifierKind.FINAL);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.MongoClientOptionsFactoryBean.setSocketKeepAlive",
	"Comment": "set the keep alive flag, controls whether or not to have socket keep alive timeout. defaults to false.",
	"Method": "void setSocketKeepAlive(boolean socketKeepAlive){\r\n    this.socketKeepAlive = socketKeepAlive;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.security.addon.security.SecurityCommands.getSecurityProviderFromName",
	"Comment": "this method obtains the implementation of the spring security providerusing the provided name.",
	"Method": "SecurityProvider getSecurityProviderFromName(String name){\r\n    List<SecurityProvider> securityProviders = securityOperations.getAllSecurityProviders();\r\n    for (SecurityProvider type : securityProviders) {\r\n        if (type.getName().equals(name)) {\r\n            return type;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getFinderFormMethodForFinderInService",
	"Comment": "generates a finder method which delegates on entity service to get result",
	"Method": "MethodMetadata getFinderFormMethodForFinderInService(String finderName,MethodMetadata serviceFinderMethod){\r\n    String pathName = finderName;\r\n    if (pathName.startsWith(\"findBy\")) {\r\n        pathName = pathName.replace(\"findBy\", \"by\");\r\n    }\r\n    final JavaSymbolName methodName = new JavaSymbolName(pathName.concat(\"Form\"));\r\n    final JavaType formBean = serviceFinderMethod.getParameterTypes().get(0).getJavaType();\r\n    List<AnnotationMetadata> formBeanAnnotations = new ArrayList<AnnotationMetadata>();\r\n    AnnotationMetadataBuilder formBeanAnnotation = new AnnotationMetadataBuilder(SpringJavaType.MODEL_ATTRIBUTE);\r\n    formBeanAnnotation.addStringAttribute(\"value\", FORM_BEAN_PARAM_NAME.getSymbolName());\r\n    formBeanAnnotations.add(formBeanAnnotation.build());\r\n    AnnotatedJavaType annotatedFormBean = new AnnotatedJavaType(formBean, formBeanAnnotations);\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    parameterTypes.add(annotatedFormBean);\r\n    parameterTypes.add(MODEL_PARAM);\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    final List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    parameterNames.add(FORM_BEAN_PARAM_NAME);\r\n    parameterNames.add(MODEL_PARAM_NAME);\r\n    final List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n    AnnotationMetadataBuilder getMappingAnnotation = new AnnotationMetadataBuilder(GET_MAPPING);\r\n    getMappingAnnotation.addStringAttribute(\"name\", methodName.getSymbolName());\r\n    getMappingAnnotation.addStringAttribute(\"value\", \"/\" + pathName + \"/search-form\");\r\n    annotations.add(getMappingAnnotation);\r\n    this.mvcMethodNames.put(methodName.getSymbolName(), methodName.getSymbolName());\r\n    final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    buildPopulateFormatBody(bodyBuilder, formBeansDateTimeFields.get(formBean));\r\n    final List<FieldMetadata> enumFileds = formBeansEnumFields.get(formBean);\r\n    if (enumFileds != null && !enumFileds.isEmpty()) {\r\n        buildPopulateEnumsBody(bodyBuilder, formBeansEnumFields.get(formBean));\r\n    }\r\n    bodyBuilder.appendFormalLine(\"return new %s(\\\"%s/%s\\\");\", getNameOfJavaType(SpringJavaType.MODEL_AND_VIEW), viewsPath, finderName.concat(\"Form\"));\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, SpringJavaType.MODEL_AND_VIEW, parameterTypes, parameterNames, bodyBuilder);\r\n    methodBuilder.setAnnotations(annotations);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.data.redis.test.util.IsBucketMatcher.containingDateAsMsec",
	"Comment": "checks for presence of equivalent time in msec value at path.",
	"Method": "IsBucketMatcher containingDateAsMsec(String path,Date date){\r\n    this.expected.put(path, date);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerCommands.isPublishOperationsAvailable",
	"Comment": "this indicator checks if is possible to publish own operations incontrollers.if a valid project has been generated and spring mvc has been installed,this command will be available.",
	"Method": "boolean isPublishOperationsAvailable(){\r\n    return getControllerOperations().isPublishOperationsAvailable();\r\n}"
}, {
	"Path": "org.springframework.cloud.kubernetes.config.reload.ConfigurationChangeDetector.findPropertySource",
	"Comment": "finds one registered property source of the given type, logging a warning if\tmultiple property sources of that type are available.",
	"Method": "S findPropertySource(Class<S> sourceClass){\r\n    List<S> sources = findPropertySources(sourceClass);\r\n    if (sources.size() == 0) {\r\n        return null;\r\n    }\r\n    if (sources.size() > 1) {\r\n        log.warn(\"Found more than one property source of type \" + sourceClass);\r\n    }\r\n    return sources.get(0);\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.RepositoryRestConfiguration.setPageParamName",
	"Comment": "set the name of the url query string parameter that indicates what page to return.",
	"Method": "RepositoryRestConfiguration setPageParamName(String pageParamName){\r\n    Assert.notNull(pageParamName, \"Page param name cannot be null.\");\r\n    this.pageParamName = pageParamName;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.tailor.actions.ActionConfig.setArgument",
	"Comment": "sets an argument value. this method will throw an exception if a valuewith that key is already set, thus making them immutable. this is toavoid unexpected behaviour, because actionconfigs in atailorconfiguration must stay the same once that configuration isinitiated at roo startup.",
	"Method": "void setArgument(String argument){\r\n    if (StringUtils.isNotBlank(attributes.get(argument))) {\r\n        throw new IllegalStateException(\"ActionConfig.setArgument: ActionConfig attributes are immutable once instantiated!\");\r\n    }\r\n    attributes.put(ATTR_ARGUMENT, argument);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.ReactiveMongoTemplate.doCreateCollection",
	"Comment": "create the specified collection using the provided options",
	"Method": "Mono<MongoCollection<Document>> doCreateCollection(String collectionName,CreateCollectionOptions collectionOptions){\r\n    return createMono(db -> db.createCollection(collectionName, collectionOptions)).map(success -> {\r\n        if (LOGGER.isDebugEnabled()) {\r\n            LOGGER.debug(\"Created collection [{}]\", collectionName);\r\n        }\r\n        return getCollection(collectionName);\r\n    });\r\n}"
}, {
	"Path": "spoon.support.visitor.SubInheritanceHierarchyResolver.addSuperType",
	"Comment": "add another super type to this mapping function.\tusing this function you can search parallel in more sub type hierarchies.",
	"Method": "SubInheritanceHierarchyResolver addSuperType(CtTypeInformation superType){\r\n    targetSuperTypes.add(superType.getQualifiedName());\r\n    if (hasSuperInterface == false) {\r\n        hasSuperInterface = superType.isInterface();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.service.addon.ServiceMetadata.getFindAllReferencedFieldMethod",
	"Comment": "method that generates findall method for provided referenced fields on current interface",
	"Method": "MethodMetadata getFindAllReferencedFieldMethod(MethodMetadata method){\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    List<AnnotatedJavaType> methodParamTypes = method.getParameterTypes();\r\n    List<JavaSymbolName> methodParamNames = method.getParameterNames();\r\n    for (int i = 0; i < method.getParameterTypes().size(); i++) {\r\n        parameterTypes.add(methodParamTypes.get(i));\r\n        parameterNames.add(methodParamNames.get(i));\r\n    }\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC + Modifier.ABSTRACT, method.getMethodName(), method.getReturnType(), parameterTypes, parameterNames, null);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaOperationsImpl.addRepositoryCustom",
	"Comment": "method that generates repositorycustom interface and its implementationfor an specific entity",
	"Method": "JavaType addRepositoryCustom(JavaType domainType,JavaType repositoryType){\r\n    JavaType interfaceType = getCustomRepositoryJavaTypeFor(repositoryType);\r\n    final String interfaceIdentifier = getPathResolver().getCanonicalPath(interfaceType.getModule(), Path.SRC_MAIN_JAVA, interfaceType);\r\n    if (getFileManager().exists(interfaceIdentifier)) {\r\n        return interfaceType;\r\n    }\r\n    final String interfaceMdId = PhysicalTypeIdentifier.createIdentifier(interfaceType, getPathResolver().getPath(interfaceIdentifier));\r\n    final ClassOrInterfaceTypeDetailsBuilder interfaceBuilder = new ClassOrInterfaceTypeDetailsBuilder(interfaceMdId, Modifier.PUBLIC, interfaceType, PhysicalTypeCategory.INTERFACE);\r\n    final AnnotationMetadataBuilder repositoryCustomAnnotationMetadata = new AnnotationMetadataBuilder(RooJavaType.ROO_REPOSITORY_JPA_CUSTOM);\r\n    repositoryCustomAnnotationMetadata.addAttribute(new ClassAttributeValue(new JavaSymbolName(\"entity\"), domainType));\r\n    interfaceBuilder.addAnnotation(repositoryCustomAnnotationMetadata);\r\n    getTypeManagementService().createOrUpdateTypeOnDisk(interfaceBuilder.build());\r\n    generateRepositoryCustomImpl(interfaceType, repositoryType, domainType);\r\n    return interfaceType;\r\n}"
}, {
	"Path": "spoon.reflect.factory.CodeFactory.createConstructorCall",
	"Comment": "creates a constructor call. the correct constructor is inferred based on parameters",
	"Method": "CtConstructorCall<T> createConstructorCall(CtTypeReference<T> type,CtExpression<?> parameters){\r\n    CtConstructorCall<T> constructorCall = factory.Core().createConstructorCall();\r\n    CtExecutableReference<T> executableReference = factory.Core().createExecutableReference();\r\n    executableReference.setType(type);\r\n    executableReference.setDeclaringType(type == null ? type : type.clone());\r\n    executableReference.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);\r\n    List<CtTypeReference<?>> typeReferences = new ArrayList();\r\n    for (CtExpression<?> parameter : parameters) {\r\n        typeReferences.add(parameter.getType());\r\n    }\r\n    executableReference.setParameters(typeReferences);\r\n    constructorCall.setArguments(Arrays.asList(parameters));\r\n    constructorCall.setExecutable(executableReference);\r\n    return constructorCall;\r\n}"
}, {
	"Path": "spoon.template.AbstractTemplate.isWellFormed",
	"Comment": "verifies whether there is at least one template parameter.",
	"Method": "boolean isWellFormed(){\r\n    return !Parameters.getAllTemplateParameterFields(this.getClass()).isEmpty();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.test.RepositoryJpaIntegrationTestMetadata.getPersistGenerateIdTestMethod",
	"Comment": "builds a method to test the generation of id when persisting entities.",
	"Method": "MethodMetadata getPersistGenerateIdTestMethod(){\r\n    MethodMetadata method = getGovernorMethod(PERSIST_SHOULD_GENERATE_ID_METHOD_NAME);\r\n    if (method != null) {\r\n        return method;\r\n    }\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    bodyBuilder.appendFormalLine(\"// Setup\");\r\n    bodyBuilder.appendFormalLine(\"// Exercise\");\r\n    bodyBuilder.appendFormalLine(\"%1$s %2$s = %3$s().getNewRandomTransient%1$s();\", getNameOfJavaType(this.entity), this.entityVar, getAccessorMethod(this.dodField).getMethodName());\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"// Verify\");\r\n    bodyBuilder.appendFormalLine(\"%s(%s).as(\\\"Check the Data on demand generated a new non null '%s'\\\").isNotNull();\", getNameOfJavaType(ASSERT_THAT), this.entityVar, getNameOfJavaType(this.entity));\r\n    bodyBuilder.appendFormalLine(\"%s(%s.%s()).as(\\\"Check the Data on demand generated a new '%s' whose id is null\\\")\", getNameOfJavaType(ASSERT_THAT), this.entityVar, this.identifierAccessorMethodName, getNameOfJavaType(this.entity));\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\".isNull();\");\r\n    bodyBuilder.indentRemove();\r\n    bodyBuilder.appendFormalLine(\"try {\");\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\"%1$s = %2$s().saveAndFlush(%1$s);\", this.entityVar, getAccessorMethod(this.repositoryField).getMethodName());\r\n    bodyBuilder.indentRemove();\r\n    bodyBuilder.appendFormalLine(\"} catch (final %s e) {\", getNameOfJavaType(Jsr303JavaType.CONSTRAINT_VIOLATION_EXCEPTION));\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\"final %1$s msg = new %1$s();\", getNameOfJavaType(JdkJavaType.STRING_BUILDER));\r\n    bodyBuilder.appendFormalLine(\"for (%s<%s<?>> iter = e.getConstraintViolations().iterator(); iter\", getNameOfJavaType(JdkJavaType.ITERATOR), getNameOfJavaType(Jsr303JavaType.CONSTRAINT_VIOLATION));\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\".hasNext();) {\");\r\n    bodyBuilder.appendFormalLine(\"final %s<?> cv = iter.next();\", getNameOfJavaType(Jsr303JavaType.CONSTRAINT_VIOLATION));\r\n    bodyBuilder.appendFormalLine(\"msg.append(\\\"[\\\").append(cv.getRootBean().getClass().getName()).append(\\\".\\\")\");\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\".append(cv.getPropertyPath()).append(\\\": \\\").append(cv.getMessage())\");\r\n    bodyBuilder.appendFormalLine(\".append(\\\" (invalid value = \\\").append(cv.getInvalidValue()).append(\\\")\\\").append(\\\"]\\\");\");\r\n    bodyBuilder.indentRemove();\r\n    bodyBuilder.indentRemove();\r\n    bodyBuilder.appendFormalLine(\"}\");\r\n    bodyBuilder.appendFormalLine(\"throw new %s(msg.toString(), e);\", getNameOfJavaType(JdkJavaType.ILLEGAL_STATE_EXCEPTION));\r\n    bodyBuilder.indentRemove();\r\n    bodyBuilder.appendFormalLine(\"}\");\r\n    bodyBuilder.appendFormalLine(\"%1$s(%2$s.%3$s()).as(\\\"Check a '%4$s' (%5$s) id is not null after been persisted\\\", %2$s)\", getNameOfJavaType(ASSERT_THAT), this.entityVar, this.identifierAccessorMethodName, getNameOfJavaType(this.entity), \"%s\");\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\".isNotNull();\");\r\n    bodyBuilder.reset();\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, PERSIST_SHOULD_GENERATE_ID_METHOD_NAME, JavaType.VOID_PRIMITIVE, bodyBuilder);\r\n    methodBuilder.addAnnotation(new AnnotationMetadataBuilder(TEST));\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaLayerProvider.getMethodAdditions",
	"Comment": "returns the additions that the caller needs to make in order to invokethe given method",
	"Method": "MemberTypeAdditions getMethodAdditions(String callerMID,RepositoryJpaLayerMethod method,JavaType repositoryType,List<MethodParameter> parameters){\r\n    final ClassOrInterfaceTypeDetailsBuilder cidBuilder = new ClassOrInterfaceTypeDetailsBuilder(callerMID);\r\n    final AnnotationMetadataBuilder autowiredAnnotation = new AnnotationMetadataBuilder(AUTOWIRED);\r\n    final String repositoryFieldName = StringUtils.uncapitalize(repositoryType.getSimpleTypeName());\r\n    cidBuilder.addField(new FieldMetadataBuilder(callerMID, 0, Arrays.asList(autowiredAnnotation), new JavaSymbolName(repositoryFieldName), repositoryType));\r\n    final String methodCall = repositoryFieldName + \".\" + method.getCall(parameters);\r\n    return new MemberTypeAdditions(cidBuilder, method.getName(), methodCall, false, parameters);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.service.addon.ServiceImplMetadata.getConstructor",
	"Comment": "method that generates service implementation constructor. if exists arepository, it will be included as constructor parameter",
	"Method": "ConstructorMetadataBuilder getConstructor(boolean autowired){\r\n    ConstructorMetadataBuilder constructorBuilder = new ConstructorMetadataBuilder(getId());\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    if (repositoryFieldMetadata != null) {\r\n        addFieldToConstructor(bodyBuilder, constructorBuilder, repositoryFieldMetadata, false);\r\n    }\r\n    for (FieldMetadata requiredService : requiredServiceFieldByEntity.values()) {\r\n        addFieldToConstructor(bodyBuilder, constructorBuilder, requiredService, true);\r\n    }\r\n    constructorBuilder.setBodyBuilder(bodyBuilder);\r\n    constructorBuilder.setModifier(Modifier.PUBLIC);\r\n    if (autowired) {\r\n        constructorBuilder.addAnnotation(new AnnotationMetadataBuilder(SpringJavaType.AUTOWIRED));\r\n    }\r\n    return constructorBuilder;\r\n}"
}, {
	"Path": "spoon.reflect.visitor.filter.CtScannerFunction.setQuery",
	"Comment": "it is called automatically by ctquery implementation,\twhen this mapping function is added.",
	"Method": "void setQuery(CtQuery query){\r\n    scanner.query = query;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform2.withTransformation",
	"Comment": "adds another transformation to this transformation and returns int as anew transform.",
	"Method": "DiscreteTransform2 withTransformation(DiscreteTransform2 transform){\r\n    return new DiscreteTransform2(transform.getMatrix().mul(getMatrix()));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerCommands.isAddDetailControllerAvailable",
	"Comment": "this indicator checks if is possible to add new detail controllers.if a valid project has been generated and spring mvc has been installed,this command will be available.",
	"Method": "boolean isAddDetailControllerAvailable(){\r\n    return getControllerOperations().isAddDetailControllerAvailable();\r\n}"
}, {
	"Path": "org.springframework.data.redis.listener.RedisMessageListenerContainer.setRecoveryInterval",
	"Comment": "specify the interval between recovery attempts, in milliseconds. the default is 5000 ms, that is, 5 seconds.",
	"Method": "void setRecoveryInterval(long recoveryInterval){\r\n    this.recoveryInterval = recoveryInterval;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getFinderMethodForFinderInService",
	"Comment": "generates a finder method which delegates on entity service to get result",
	"Method": "MethodMetadata getFinderMethodForFinderInService(String finderName,MethodMetadata serviceFinderMethod){\r\n    String pathName = finderName;\r\n    if (pathName.startsWith(\"findBy\")) {\r\n        pathName = pathName.replace(\"findBy\", \"by\");\r\n    }\r\n    final JavaSymbolName methodName = new JavaSymbolName(pathName);\r\n    final JavaType formBean = serviceFinderMethod.getParameterTypes().get(0).getJavaType();\r\n    List<AnnotationMetadata> formBeanAnnotations = new ArrayList<AnnotationMetadata>();\r\n    AnnotationMetadataBuilder formBeanAnnotation = new AnnotationMetadataBuilder(SpringJavaType.MODEL_ATTRIBUTE);\r\n    formBeanAnnotation.addStringAttribute(\"value\", FORM_BEAN_PARAM_NAME.getSymbolName());\r\n    formBeanAnnotations.add(formBeanAnnotation.build());\r\n    AnnotatedJavaType annotatedFormBean = new AnnotatedJavaType(formBean, formBeanAnnotations);\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    parameterTypes.add(annotatedFormBean);\r\n    parameterTypes.add(MODEL_PARAM);\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    final List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    parameterNames.add(FORM_BEAN_PARAM_NAME);\r\n    parameterNames.add(MODEL_PARAM_NAME);\r\n    final List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n    AnnotationMetadataBuilder getMappingAnnotation = new AnnotationMetadataBuilder(GET_MAPPING);\r\n    getMappingAnnotation.addStringAttribute(\"name\", methodName.getSymbolName());\r\n    getMappingAnnotation.addStringAttribute(\"value\", \"/\" + pathName);\r\n    annotations.add(getMappingAnnotation);\r\n    this.mvcMethodNames.put(methodName.getSymbolName(), methodName.getSymbolName());\r\n    final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    buildPopulateFormatBody(bodyBuilder, formBeansDateTimeFields.get(formBean));\r\n    final List<FieldMetadata> enumFileds = formBeansEnumFields.get(formBean);\r\n    if (enumFileds != null && !enumFileds.isEmpty()) {\r\n        buildPopulateEnumsBody(bodyBuilder, formBeansEnumFields.get(formBean));\r\n    }\r\n    bodyBuilder.appendFormalLine(\"return new %s(\\\"%s/%s\\\");\", getNameOfJavaType(SpringJavaType.MODEL_AND_VIEW), viewsPath, finderName);\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, SpringJavaType.MODEL_AND_VIEW, parameterTypes, parameterNames, bodyBuilder);\r\n    methodBuilder.setAnnotations(annotations);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory.getValidateConnection",
	"Comment": "indicates if validation of the native lettuce connection is enabled.",
	"Method": "boolean getValidateConnection(){\r\n    return validateConnection;\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.ProjectionDefinitionConfiguration.setParameterName",
	"Comment": "configures the request parameter name to be used to accept the projection name to be returned.",
	"Method": "void setParameterName(String parameterName){\r\n    this.parameterName = StringUtils.hasText(parameterName) ? parameterName : DEFAULT_PROJECTION_PARAMETER_NAME;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerOperationsImpl.checkDetailControllerExists",
	"Comment": "check if detail controller exists for the values entity, responsetype,controllerpackage, pathprefix and relationfield provided by parameters",
	"Method": "boolean checkDetailControllerExists(JavaType entity,ControllerMVCResponseService responseType,JavaPackage controllerPackage,String pathPrefix,String relationField){\r\n    Collection<ClassOrInterfaceTypeDetails> detailControllers = getControllerLocator().getControllers(entity, ControllerType.DETAIL, responseType.getAnnotation());\r\n    for (ClassOrInterfaceTypeDetails existingController : detailControllers) {\r\n        if (existingController.getType().getPackage().equals(controllerPackage)) {\r\n            ControllerAnnotationValues values = new ControllerAnnotationValues(existingController);\r\n            AnnotationAttributeValue<String> relationFieldAttr = existingController.getAnnotation(RooJavaType.ROO_DETAIL).getAttribute(RELATION_FIELD_KEY);\r\n            if (StringUtils.equals(pathPrefix, values.getPathPrefix())) {\r\n                if (relationFieldAttr == null) {\r\n                    if (LOGGER.isLoggable(Level.WARNING)) {\r\n                        LOGGER.warning(String.format(\"Controller %s is defined as @%s.type = DETAIL but @%s is missing!\", existingController.getType().getFullyQualifiedTypeName(), RooJavaType.ROO_CONTROLLER, RooJavaType.ROO_DETAIL));\r\n                    }\r\n                } else if (relationField.equals(relationFieldAttr.getValue())) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.AABB.intersects",
	"Comment": "tests for intersection between the box and a ray defined by a startingpoint and a direction.",
	"Method": "boolean intersects(AABB other,Optional<Tuple<Vector3d, Vector3d>> intersects,Vector3d start,Vector3d direction){\r\n    checkNotNull(start, \"start\");\r\n    checkNotNull(direction, \"direction\");\r\n    final double txMin;\r\n    final double txMax;\r\n    final Vector3d xNormal;\r\n    if (Math.copySign(1, direction.getX()) > 0) {\r\n        txMin = (this.min.getX() - start.getX()) / direction.getX();\r\n        txMax = (this.max.getX() - start.getX()) / direction.getX();\r\n        xNormal = Vector3d.UNIT_X;\r\n    } else {\r\n        txMin = (this.max.getX() - start.getX()) / direction.getX();\r\n        txMax = (this.min.getX() - start.getX()) / direction.getX();\r\n        xNormal = Vector3d.UNIT_X.negate();\r\n    }\r\n    final double tyMin;\r\n    final double tyMax;\r\n    final Vector3d yNormal;\r\n    if (Math.copySign(1, direction.getY()) > 0) {\r\n        tyMin = (this.min.getY() - start.getY()) / direction.getY();\r\n        tyMax = (this.max.getY() - start.getY()) / direction.getY();\r\n        yNormal = Vector3d.UNIT_Y;\r\n    } else {\r\n        tyMin = (this.max.getY() - start.getY()) / direction.getY();\r\n        tyMax = (this.min.getY() - start.getY()) / direction.getY();\r\n        yNormal = Vector3d.UNIT_Y.negate();\r\n    }\r\n    if (txMin > tyMax || txMax < tyMin) {\r\n        return Optional.empty();\r\n    }\r\n    Vector3d normalMax;\r\n    Vector3d normalMin;\r\n    double tMin;\r\n    if (tyMin == txMin) {\r\n        tMin = tyMin;\r\n        normalMin = xNormal.negate().sub(yNormal);\r\n    } else if (tyMin > txMin) {\r\n        tMin = tyMin;\r\n        normalMin = yNormal.negate();\r\n    } else {\r\n        tMin = txMin;\r\n        normalMin = xNormal.negate();\r\n    }\r\n    double tMax;\r\n    if (tyMax == txMax) {\r\n        tMax = tyMax;\r\n        normalMax = xNormal.add(yNormal);\r\n    } else if (tyMax < txMax) {\r\n        tMax = tyMax;\r\n        normalMax = yNormal;\r\n    } else {\r\n        tMax = txMax;\r\n        normalMax = xNormal;\r\n    }\r\n    final double tzMin;\r\n    final double tzMax;\r\n    final Vector3d zNormal;\r\n    if (Math.copySign(1, direction.getZ()) > 0) {\r\n        tzMin = (this.min.getZ() - start.getZ()) / direction.getZ();\r\n        tzMax = (this.max.getZ() - start.getZ()) / direction.getZ();\r\n        zNormal = Vector3d.UNIT_Z;\r\n    } else {\r\n        tzMin = (this.max.getZ() - start.getZ()) / direction.getZ();\r\n        tzMax = (this.min.getZ() - start.getZ()) / direction.getZ();\r\n        zNormal = Vector3d.UNIT_Z.negate();\r\n    }\r\n    if (tMin > tzMax || tMax < tzMin) {\r\n        return Optional.empty();\r\n    }\r\n    if (tzMin == tMin) {\r\n        normalMin = normalMin.sub(zNormal);\r\n    } else if (tzMin > tMin) {\r\n        tMin = tzMin;\r\n        normalMin = zNormal.negate();\r\n    }\r\n    if (tzMax == tMax) {\r\n        normalMax = normalMax.add(zNormal);\r\n    } else if (tzMax < tMax) {\r\n        tMax = tzMax;\r\n        normalMax = zNormal;\r\n    }\r\n    if (tMax < 0) {\r\n        return Optional.empty();\r\n    }\r\n    final double t;\r\n    Vector3d normal;\r\n    if (tMin < 0) {\r\n        t = tMax;\r\n        normal = normalMax;\r\n    } else {\r\n        t = tMin;\r\n        normal = normalMin;\r\n    }\r\n    normal = normal.normalize();\r\n    final double x;\r\n    final double y;\r\n    final double z;\r\n    if (normal.getX() > 0) {\r\n        x = this.max.getX();\r\n    } else if (normal.getX() < 0) {\r\n        x = this.min.getX();\r\n    } else {\r\n        x = direction.getX() * t + start.getX();\r\n    }\r\n    if (normal.getY() > 0) {\r\n        y = this.max.getY();\r\n    } else if (normal.getY() < 0) {\r\n        y = this.min.getY();\r\n    } else {\r\n        y = direction.getY() * t + start.getY();\r\n    }\r\n    if (normal.getZ() > 0) {\r\n        z = this.max.getZ();\r\n    } else if (normal.getZ() < 0) {\r\n        z = this.min.getZ();\r\n    } else {\r\n        z = direction.getZ() * t + start.getZ();\r\n    }\r\n    return Optional.of(new Tuple(new Vector3d(x, y, z), normal));\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.jedis.JedisSentinelConnection.doInit",
	"Comment": "do what ever is required to establish the connection to redis.",
	"Method": "void doInit(Jedis jedis){\r\n    jedis.connect();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.embedded.AbstractEmbeddedProvider.isProviderSupported",
	"Comment": "helper method to determine if a given provider is supported by thisimplementation.",
	"Method": "boolean isProviderSupported(String candidate,EmbeddedCompletor[] completors){\r\n    for (final EmbeddedCompletor completor : completors) {\r\n        if (completor.name().equalsIgnoreCase(candidate)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerCommands.getTypeFromEntityParam",
	"Comment": "tries to obtain javatype indicated in command or which has the focus in theshell",
	"Method": "JavaType getTypeFromEntityParam(ShellContext shellContext){\r\n    String typeString = shellContext.getParameters().get(\"entity\");\r\n    JavaType type = null;\r\n    if (typeString != null) {\r\n        JavaTypeConverter converter = (JavaTypeConverter) getJavaTypeConverter().get(0);\r\n        type = converter.convertFromText(typeString, JavaType.class, PROJECT);\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.dod.JpaDataOnDemandMetadata.getConstructorWithEntityManagerAndSize",
	"Comment": "builds constructor with entitymanager and size arguments.",
	"Method": "ConstructorMetadataBuilder getConstructorWithEntityManagerAndSize(){\r\n    ConstructorMetadataBuilder constructorBuilder = new ConstructorMetadataBuilder(getId());\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    constructorBuilder.addParameter(ENTITY_MANAGER_VAR, JpaJavaType.ENTITY_MANAGER);\r\n    constructorBuilder.addParameter(SIZE_VAR, JavaType.INT_PRIMITIVE);\r\n    bodyBuilder.appendFormalLine(String.format(\"%1$s(%2$s);\", getMutatorMethod(getEntityManagerField().build()).getMethodName(), ENTITY_MANAGER_VAR));\r\n    bodyBuilder.appendFormalLine(String.format(\"%1$s(%2$s);\", getMutatorMethod(getSizeField()).getMethodName(), SIZE_VAR));\r\n    constructorBuilder.setModifier(Modifier.PUBLIC);\r\n    constructorBuilder.setBodyBuilder(bodyBuilder);\r\n    CommentStructure comment = new CommentStructure();\r\n    List<String> paramsInfo = new ArrayList<String>();\r\n    paramsInfo.add(ENTITY_MANAGER_VAR + \" to persist entities\");\r\n    paramsInfo.add(SIZE_VAR + \" the number of entities to create and persist initially.\");\r\n    JavadocComment javadocComment = new JavadocComment(String.format(\"Creates a new {@link %s}.\", this.governorPhysicalTypeMetadata.getType().getSimpleTypeName()), paramsInfo, null, null);\r\n    comment.addComment(javadocComment, CommentLocation.BEGINNING);\r\n    constructorBuilder.setCommentStructure(comment);\r\n    return constructorBuilder;\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.jedis.JedisVersionUtil.atLeast",
	"Comment": "compares given version string against current jedis version.",
	"Method": "boolean atLeast(String version){\r\n    return jedisVersion.compareTo(parseVersion(version)) >= 0;\r\n}"
}, {
	"Path": "spoon.reflect.visitor.ImportScannerImpl.isInCollisionWithLocalMethod",
	"Comment": "test if the given executable reference is targeted a method name which is in collision with a method name of the current class",
	"Method": "boolean isInCollisionWithLocalMethod(CtExecutableReference ref){\r\n    CtType<?> typeDecl = ref.getParent(CtType.class);\r\n    if (typeDecl != null) {\r\n        String methodName = ref.getSimpleName();\r\n        for (CtMethod<?> method : typeDecl.getAllMethods()) {\r\n            if (method.getSimpleName().equals(methodName)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getListDatatablesByIdsInDetailMethod",
	"Comment": "this method provides detail datatablesbyidsin list method using thymeleafresponse type",
	"Method": "MethodMetadata getListDatatablesByIdsInDetailMethod(){\r\n    RelationInfo detailsInfo = controllerMetadata.getLastDetailsInfo();\r\n    final ServiceMetadata detailsServiceMetadata = controllerMetadata.getServiceMetadataForEntity(detailsInfo.childType);\r\n    final MethodMetadata findAllByIdsInMethod = detailsServiceMetadata.getCurrentFindAllByIdsInWithGlobalSearchMethod();\r\n    if (findAllByIdsInMethod == null) {\r\n        return null;\r\n    }\r\n    final FieldMetadata detailsServiceField = controllerMetadata.getDetailsServiceFields(detailsInfo.childType);\r\n    final JavaSymbolName methodName = LIST_DATATABLES_BY_IDS_IN_DETAILS_METHOD_NAME;\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    AnnotationMetadataBuilder requestParamIdsAnnotation = new AnnotationMetadataBuilder(REQUEST_PARAM);\r\n    requestParamIdsAnnotation.addStringAttribute(\"value\", \"ids\");\r\n    parameterTypes.add(new AnnotatedJavaType(JavaType.wrapperOf(JavaType.LIST, findAllByIdsInMethod.getParameterTypes().get(0).getJavaType().getBaseType()), requestParamIdsAnnotation.build()));\r\n    parameterTypes.add(DATATABLES_COLUMNS_PARAM);\r\n    parameterTypes.add(GLOBAL_SEARCH_PARAM);\r\n    parameterTypes.add(DATATABLES_PAGEABLE_PARAM);\r\n    AnnotationMetadataBuilder requestParamAnnotation = new AnnotationMetadataBuilder(REQUEST_PARAM);\r\n    requestParamAnnotation.addStringAttribute(\"value\", \"draw\");\r\n    parameterTypes.add(new AnnotatedJavaType(JavaType.INT_OBJECT, requestParamAnnotation.build()));\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    final List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    parameterNames.add(new JavaSymbolName(\"ids\"));\r\n    parameterNames.add(DATATABLES_COLUMNS_PARAM_NAME);\r\n    parameterNames.add(new JavaSymbolName(\"search\"));\r\n    parameterNames.add(new JavaSymbolName(\"pageable\"));\r\n    parameterNames.add(new JavaSymbolName(\"draw\"));\r\n    final List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n    AnnotationMetadataBuilder getMappingAnnotation = new AnnotationMetadataBuilder(GET_MAPPING);\r\n    getMappingAnnotation.addStringAttribute(\"name\", methodName.getSymbolName());\r\n    getMappingAnnotation.addEnumAttribute(\"produces\", SPRINGLETS_DATATABLES, \"MEDIA_TYPE\");\r\n    getMappingAnnotation.addStringAttribute(\"value\", \"/dtByIdsIn\");\r\n    annotations.add(getMappingAnnotation);\r\n    this.mvcMethodNames.put(methodName.getSymbolName(), methodName.getSymbolName());\r\n    annotations.add(RESPONSE_BODY_ANNOTATION);\r\n    final JavaType serviceReturnType = findAllByIdsInMethod.getReturnType();\r\n    final JavaType dataReturnType = JavaType.wrapperOf(SpringletsJavaType.SPRINGLETS_CONVERTED_DATATABLES_DATA, serviceReturnType.getParameters().get(0));\r\n    final JavaType returnType = JavaType.wrapperOf(RESPONSE_ENTITY, dataReturnType);\r\n    final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    final String itemsName = StringUtils.uncapitalize(detailsInfo.fieldName);\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"%s %s = %s().%s(ids, search, pageable);\", getNameOfJavaType(serviceReturnType), itemsName, getAccessorMethod(detailsServiceField).getMethodName(), findAllByIdsInMethod.getMethodName());\r\n    final String totalVarName = \"total\" + StringUtils.capitalize(itemsName) + \"Count\";\r\n    bodyBuilder.appendFormalLine(\"long %s = %s.getTotalElements();\", totalVarName, itemsName);\r\n    bodyBuilder.appendFormalLine(\"%1$s data =  new %1$s(%2$s, %3$s, draw, %4$s(), %5$s);\", getNameOfJavaType(dataReturnType), itemsName, totalVarName, getAccessorMethod(this.conversionServiceField).getMethodName(), DATATABLES_COLUMNS_PARAM_NAME);\r\n    bodyBuilder.appendFormalLine(\"return %s.ok(data);\", getNameOfJavaType(SpringJavaType.RESPONSE_ENTITY));\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, returnType, parameterTypes, parameterNames, bodyBuilder);\r\n    methodBuilder.setAnnotations(annotations);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory.setDatabase",
	"Comment": "sets the index of the database used by this connection factory. default is 0.",
	"Method": "void setDatabase(int index){\r\n    Assert.isTrue(index >= 0, \"invalid DB index (a positive index required)\");\r\n    if (RedisConfiguration.isDatabaseIndexAware(configuration)) {\r\n        ((WithDatabaseIndex) configuration).setDatabase(index);\r\n        return;\r\n    }\r\n    standaloneConfig.setDatabase(index);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.jsp.JspOperationsImpl.updateConfiguration",
	"Comment": "adds tiles maven dependencies and updates the mvc config to include tilesview support",
	"Method": "void updateConfiguration(){\r\n    final Element configuration = XmlUtils.getRootElement(getClass(), \"tiles/configuration.xml\");\r\n    final List<Dependency> dependencies = new ArrayList<Dependency>();\r\n    final List<Element> springDependencies = XmlUtils.findElements(\"/configuration/tiles/dependencies/dependency\", configuration);\r\n    for (final Element dependencyElement : springDependencies) {\r\n        dependencies.add(new Dependency(dependencyElement));\r\n    }\r\n    getProjectOperations().addDependencies(getProjectOperations().getFocusedModuleName(), dependencies);\r\n    final String mvcConfig = getPathResolver().getFocusedIdentifier(SRC_MAIN_WEBAPP, \"WEB-INF/spring/webmvc-config.xml\");\r\n    final Document mvcConfigDocument = XmlUtils.readXml(fileManager.getInputStream(mvcConfig));\r\n    final Element beans = mvcConfigDocument.getDocumentElement();\r\n    if (XmlUtils.findFirstElement(\"/beans/bean[@id = 'tilesViewResolver']\", beans) != null || XmlUtils.findFirstElement(\"/beans/bean[@id = 'tilesConfigurer']\", beans) != null) {\r\n        return;\r\n    }\r\n    final Document configDoc = getDocumentTemplate(\"tiles/tiles-mvc-config-template.xml\");\r\n    final Element configElement = configDoc.getDocumentElement();\r\n    final List<Element> tilesConfig = XmlUtils.findElements(\"/config/bean\", configElement);\r\n    for (final Element bean : tilesConfig) {\r\n        final Node importedBean = mvcConfigDocument.importNode(bean, true);\r\n        beans.appendChild(importedBean);\r\n    }\r\n    fileManager.createOrUpdateTextFileIfRequired(mvcConfig, XmlUtils.nodeToString(mvcConfigDocument), true);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaCustomImplMetadata.getFindAllByIdsInImpl",
	"Comment": "method that generates the findallbyidsin implementation method",
	"Method": "MethodMetadata getFindAllByIdsInImpl(MethodMetadata findAllByIdsInGlobalSearchMethod,FieldMetadata idField,List<FieldMetadata> fields){\r\n    JavaSymbolName methodName = findAllByIdsInGlobalSearchMethod.getMethodName();\r\n    List<AnnotatedJavaType> parameterTypes = findAllByIdsInGlobalSearchMethod.getParameterTypes();\r\n    List<JavaSymbolName> parameterNames = findAllByIdsInGlobalSearchMethod.getParameterNames();\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, findAllByIdsInGlobalSearchMethod.getMethodName(), findAllByIdsInGlobalSearchMethod.getReturnType(), findAllByIdsInGlobalSearchMethod.getParameterTypes(), findAllByIdsInGlobalSearchMethod.getParameterNames(), null);\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    JavaSymbolName globalSearch = parameterNames.get(1);\r\n    JavaSymbolName pageable = parameterNames.get(2);\r\n    String entity = this.entity.getSimpleTypeName();\r\n    String entityVariable = StringUtils.uncapitalize(entity);\r\n    JavaType projection = QUERYDSL_PROJECTIONS;\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(String.format(\"%1$s %2$s = %1$s.%2$s;\", entityQtype.getNameIncludingTypeParameters(false, importResolver), entityVariable));\r\n    bodyBuilder.newLine();\r\n    buildQuery(bodyBuilder, entityVariable, globalSearch, null, null, null, null, null, this.defaultReturnType, null, null);\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"// Also, filter by the provided ids\");\r\n    bodyBuilder.appendFormalLine(\"query.where(%s.%s.in(ids));\", entityVariable, idField.getFieldName());\r\n    bodyBuilder.newLine();\r\n    StringBuffer mappingBuilderLine = new StringBuffer();\r\n    mappingBuilderLine.append(String.format(\"%s mapping = buildMapper()\", getNameOfJavaType(SpringletsJavaType.SPRINGLETS_QUERYDSL_REPOSITORY_SUPPORT_ATTRIBUTE_BUILDER)));\r\n    if (!this.typesAreProjections.get(this.defaultReturnType)) {\r\n        Iterator<FieldMetadata> iterator = fields.iterator();\r\n        while (iterator.hasNext()) {\r\n            FieldMetadata field = iterator.next();\r\n            String fieldName = field.getFieldName().getSymbolName();\r\n            mappingBuilderLine.append(String.format(\"\\n\\t\\t\\t.map(%s, %s.%s)\", getConstantForField(fieldName).getFieldName(), entityVariable, fieldName));\r\n        }\r\n    } else {\r\n        List<Pair<String, String>> projectionFields = this.typesFieldMaps.get(this.defaultReturnType);\r\n        Iterator<Pair<String, String>> iterator = projectionFields.iterator();\r\n        while (iterator.hasNext()) {\r\n            Entry<String, String> entry = iterator.next();\r\n            mappingBuilderLine.append(String.format(\"\\n\\t\\t\\t.map(%s, %s)\", getConstantForField(entry.getKey()).getFieldName(), entry.getValue()));\r\n        }\r\n    }\r\n    mappingBuilderLine.append(\";\");\r\n    bodyBuilder.appendFormalLine(mappingBuilderLine.toString());\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(String.format(\"applyPagination(%s, query, mapping);\", pageable));\r\n    bodyBuilder.appendFormalLine(\"applyOrderById(query);\");\r\n    bodyBuilder.newLine();\r\n    buildQueryResult(bodyBuilder, pageable, entityVariable, projection, this.defaultReturnType);\r\n    methodBuilder.setBodyBuilder(bodyBuilder);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaAnnotationValues.getEntity",
	"Comment": "returns the entity type managed by the annotated repository",
	"Method": "JavaType getEntity(){\r\n    return entity;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMVCViewResponseService.addConcurrencyExceptionManager",
	"Comment": "this method add new concurrencyexceptionmanager.java classthis controller advice will be used to manage concurrency",
	"Method": "void addConcurrencyExceptionManager(Pom module){\r\n    String packageName = getProjectOperations().getTopLevelPackage(module.getModuleName()).getFullyQualifiedPackageName().concat(\".web.advices\");\r\n    final JavaType type = new JavaType(String.format(\"%s.%s\", packageName, \"ConcurrencyExceptionManager\"), module.getModuleName());\r\n    Validate.notNull(type.getModule(), \"ERROR: Module name is required to generate a valid JavaType\");\r\n    final String identifier = getPathResolver().getCanonicalPath(type.getModule(), Path.SRC_MAIN_JAVA, type);\r\n    InputStream inputStream = null;\r\n    if (!this.fileManager.exists(identifier)) {\r\n        try {\r\n            inputStream = FileUtils.getInputStream(getClass(), \"ConcurrencyExceptionManager-template._java\");\r\n            String input = IOUtils.toString(inputStream);\r\n            input = input.replace(\"__PACKAGE__\", packageName);\r\n            this.fileManager.createOrUpdateTextFileIfRequired(identifier, input, true);\r\n        } catch (final IOException e) {\r\n            throw new IllegalStateException(String.format(\"Unable to create '%s'\", identifier), e);\r\n        } finally {\r\n            IOUtils.closeQuietly(inputStream);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.field.addon.FieldCommands.getTypeFromCommand",
	"Comment": "tries to obtain javatype indicated in command or which has the focusin the shell",
	"Method": "JavaType getTypeFromCommand(ShellContext shellContext){\r\n    String typeString = shellContext.getParameters().get(\"class\");\r\n    JavaType type = null;\r\n    if (typeString != null) {\r\n        type = getJavaTypeConverter().convertFromText(typeString, JavaType.class, PROJECT);\r\n    } else {\r\n        type = lastUsed.getJavaType();\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "spoon.support.reflect.code.CtCommentImpl.equals",
	"Comment": "the comments are not printed during the ctelement equality.\tthe method is this overridden for ctcomment.",
	"Method": "boolean equals(Object o){\r\n    if (this == o) {\r\n        return true;\r\n    }\r\n    if (o == null || getClass() != o.getClass()) {\r\n        return false;\r\n    }\r\n    CtCommentImpl ctComment = (CtCommentImpl) o;\r\n    if (!Objects.equals(content, ctComment.content)) {\r\n        return false;\r\n    }\r\n    return type == ctComment.type;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.components.FieldItem.buildId",
	"Comment": "builds the id of the specified field and adds it to the entity label",
	"Method": "void buildId(String suffix){\r\n    String id = XmlUtils.convertId(this.entityName.toLowerCase());\r\n    if (!StringUtils.isEmpty(this.fieldName)) {\r\n        id = id.concat(\"-\").concat(XmlUtils.convertId(fieldName.toLowerCase()));\r\n    }\r\n    if (!StringUtils.isEmpty(suffix)) {\r\n        id = id.concat(\"-\").concat(XmlUtils.convertId(suffix.toLowerCase()));\r\n    }\r\n    this.fieldId = id;\r\n}"
}, {
	"Path": "org.springframework.data.redis.listener.RedisMessageListenerContainer.handleListenerException",
	"Comment": "handle the given exception that arose during listener execution.\tthe default implementation logs the exception at error level. this can be overridden in subclasses.",
	"Method": "void handleListenerException(Throwable ex){\r\n    if (isActive()) {\r\n        invokeErrorHandler(ex);\r\n    } else {\r\n        logger.debug(\"Listener exception after container shutdown\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.ViewCommands.isInstallTemplateAvailable",
	"Comment": "this method checks if web mvc templates setup command is available or not.templates setup command will be available if exists some type thathas been installed.",
	"Method": "boolean isInstallTemplateAvailable(){\r\n    return getProjectOperations().isFeatureInstalled(FeatureNames.MVC) && !getControllerMVCResponseTypes(true).isEmpty();\r\n}"
}, {
	"Path": "daikon.Daikon.create_combined_exits",
	"Comment": "create exit program points as needed for exitnn program points.",
	"Method": "void create_combined_exits(PptMap ppts){\r\n    PptMap exit_ppts = new PptMap();\r\n    for (Iterator<PptTopLevel> i = ppts.pptIterator(); i.hasNext(); ) {\r\n        PptTopLevel ppt = i.next();\r\n        if (!ppt.is_subexit())\r\n            continue;\r\n        PptTopLevel exitnn_ppt = ppt;\r\n        PptName exitnn_name = exitnn_ppt.ppt_name;\r\n        PptName exit_name = ppt.ppt_name.makeExit();\r\n        PptTopLevel exit_ppt = exit_ppts.get(exit_name);\r\n        if (debugInit.isLoggable(Level.FINE))\r\n            debugInit.fine(\"create_combined_exits: encounted exit \" + exitnn_ppt.name());\r\n        if (exit_ppt == null) {\r\n            int len = ppt.num_tracevars + ppt.num_static_constant_vars;\r\n            VarInfo[] exit_vars = new VarInfo[len];\r\n            for (int j = 0; j < len; j++) {\r\n                exit_vars[j] = new VarInfo(ppt.var_infos[j]);\r\n                exit_vars[j].varinfo_index = ppt.var_infos[j].varinfo_index;\r\n                exit_vars[j].value_index = ppt.var_infos[j].value_index;\r\n                exit_vars[j].equalitySet = null;\r\n            }\r\n            exit_ppt = new PptTopLevel(exit_name.getName(), PptTopLevel.PptType.EXIT, ppt.parent_relations, ppt.flags, exit_vars);\r\n            exit_ppts.add(exit_ppt);\r\n            if (debugInit.isLoggable(Level.FINE))\r\n                debugInit.fine(\"create_combined_exits: created exit \" + exit_name);\r\n            init_ppt(exit_ppt, ppts);\r\n        }\r\n    }\r\n    for (Iterator<PptTopLevel> i = exit_ppts.pptIterator(); i.hasNext(); ) {\r\n        PptTopLevel ppt = i.next();\r\n        ppts.add(ppt);\r\n    }\r\n}"
}, {
	"Path": "org.apache.cassandra.index.SecondaryIndexManager.validate",
	"Comment": "called at write time to ensure that values present in the updateare valid according to the rules of all registered indexes whichwill process it. the partition key as well as the clustering andcell values for each row in the update may be checked by indeximplementations",
	"Method": "void validate(PartitionUpdate update){\r\n    indexes.values().stream().filter(i -> i.indexes(update.columns())).forEach(i -> i.validate(update));\r\n}"
}, {
	"Path": "org.elasticsearch.tasks.TaskManager.getBanCount",
	"Comment": "returns the number of currently banned tasks.will be used in task manager stats and for debugging.",
	"Method": "int getBanCount(){\r\n    return banedParents.size();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Predicate.getParameters",
	"Comment": "builds the parameters that every condition needs to perform its operation",
	"Method": "List<FinderParameter> getParameters(){\r\n    List<FinderParameter> parameters = new ArrayList<FinderParameter>();\r\n    Map<FieldMetadata, Integer> parametersCount = new HashMap<FieldMetadata, Integer>();\r\n    final Pattern lastIntPattern = Pattern.compile(\"[^0-9]+([0-9]+)$\");\r\n    for (OrPart orPart : nodes) {\r\n        for (Part part : orPart.getChildren()) {\r\n            if (part.getProperty() == null) {\r\n                continue;\r\n            }\r\n            Integer count = parametersCount.get(part.getProperty().getLeft().peek());\r\n            for (FinderParameter parameter : part.getParameters()) {\r\n                if (count != null) {\r\n                    String name = parameter.getName().toString();\r\n                    Matcher matcher = lastIntPattern.matcher(name);\r\n                    if (matcher.find()) {\r\n                        name = StringUtils.removeEnd(name, matcher.group(1));\r\n                    }\r\n                    count++;\r\n                    parameter.setName(new JavaSymbolName(name.concat(count.toString())));\r\n                } else {\r\n                    count = 1;\r\n                }\r\n                parametersCount.put(part.getProperty().getLeft().peek(), count);\r\n                parameters.add(parameter);\r\n            }\r\n        }\r\n    }\r\n    return parameters;\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration.repoRequestArgumentResolver",
	"Comment": "a convenience resolver that pulls together all the information needed to service a request.",
	"Method": "RootResourceInformationHandlerMethodArgumentResolver repoRequestArgumentResolver(){\r\n    if (QuerydslUtils.QUERY_DSL_PRESENT) {\r\n        QuerydslBindingsFactory factory = applicationContext.getBean(QuerydslBindingsFactory.class);\r\n        QuerydslPredicateBuilder predicateBuilder = new QuerydslPredicateBuilder(defaultConversionService(), factory.getEntityPathResolver());\r\n        return new QuerydslAwareRootResourceInformationHandlerMethodArgumentResolver(repositories(), repositoryInvokerFactory(defaultConversionService()), resourceMetadataHandlerMethodArgumentResolver(), predicateBuilder, factory);\r\n    }\r\n    return new RootResourceInformationHandlerMethodArgumentResolver(repositories(), repositoryInvokerFactory(defaultConversionService()), resourceMetadataHandlerMethodArgumentResolver());\r\n}"
}, {
	"Path": "daikon.Daikon.setup_proto_invs",
	"Comment": "creates the list of prototype invariants for all daikon invariants.new invariants must be added to this list",
	"Method": "void setup_proto_invs(){\r\n    {\r\n        proto_invs.add(OneOfScalar.get_proto());\r\n        proto_invs.add(OneOfFloat.get_proto());\r\n        proto_invs.add(OneOfString.get_proto());\r\n        proto_invs.add(NonZero.get_proto());\r\n        proto_invs.add(NonZeroFloat.get_proto());\r\n        proto_invs.add(LowerBound.get_proto());\r\n        proto_invs.add(LowerBoundFloat.get_proto());\r\n        proto_invs.add(UpperBound.get_proto());\r\n        proto_invs.add(UpperBoundFloat.get_proto());\r\n        proto_invs.add(Modulus.get_proto());\r\n        proto_invs.add(NonModulus.get_proto());\r\n        proto_invs.addAll(RangeInt.get_proto_all());\r\n        proto_invs.addAll(RangeFloat.get_proto_all());\r\n        proto_invs.add(PrintableString.get_proto());\r\n    }\r\n    {\r\n        proto_invs.add(OneOfSequence.get_proto());\r\n        proto_invs.add(OneOfFloatSequence.get_proto());\r\n        proto_invs.add(OneOfStringSequence.get_proto());\r\n        proto_invs.add(EltOneOf.get_proto());\r\n        proto_invs.add(EltOneOfFloat.get_proto());\r\n        proto_invs.add(EltOneOfString.get_proto());\r\n        proto_invs.addAll(EltRangeInt.get_proto_all());\r\n        proto_invs.addAll(EltRangeFloat.get_proto_all());\r\n        proto_invs.add(SeqIndexIntEqual.get_proto());\r\n        proto_invs.add(SeqIndexIntNonEqual.get_proto());\r\n        proto_invs.add(SeqIndexIntGreaterEqual.get_proto());\r\n        proto_invs.add(SeqIndexIntGreaterThan.get_proto());\r\n        proto_invs.add(SeqIndexIntLessEqual.get_proto());\r\n        proto_invs.add(SeqIndexIntLessThan.get_proto());\r\n        proto_invs.add(SeqIndexFloatEqual.get_proto());\r\n        proto_invs.add(SeqIndexFloatNonEqual.get_proto());\r\n        proto_invs.add(SeqIndexFloatGreaterEqual.get_proto());\r\n        proto_invs.add(SeqIndexFloatGreaterThan.get_proto());\r\n        proto_invs.add(SeqIndexFloatLessEqual.get_proto());\r\n        proto_invs.add(SeqIndexFloatLessThan.get_proto());\r\n        proto_invs.add(EltwiseIntEqual.get_proto());\r\n        proto_invs.add(EltwiseIntLessEqual.get_proto());\r\n        proto_invs.add(EltwiseIntGreaterEqual.get_proto());\r\n        proto_invs.add(EltwiseIntLessThan.get_proto());\r\n        proto_invs.add(EltwiseIntGreaterThan.get_proto());\r\n        proto_invs.add(EltwiseFloatEqual.get_proto());\r\n        proto_invs.add(EltwiseFloatLessEqual.get_proto());\r\n        proto_invs.add(EltwiseFloatGreaterEqual.get_proto());\r\n        proto_invs.add(EltwiseFloatLessThan.get_proto());\r\n        proto_invs.add(EltwiseFloatGreaterThan.get_proto());\r\n        proto_invs.add(EltNonZero.get_proto());\r\n        proto_invs.add(EltNonZeroFloat.get_proto());\r\n        proto_invs.add(NoDuplicates.get_proto());\r\n        proto_invs.add(NoDuplicatesFloat.get_proto());\r\n        proto_invs.add(EltLowerBound.get_proto());\r\n        proto_invs.add(EltUpperBound.get_proto());\r\n        proto_invs.add(EltLowerBoundFloat.get_proto());\r\n        proto_invs.add(EltUpperBoundFloat.get_proto());\r\n        proto_invs.add(CommonSequence.get_proto());\r\n        proto_invs.add(CommonFloatSequence.get_proto());\r\n        proto_invs.add(CommonStringSequence.get_proto());\r\n    }\r\n    {\r\n        proto_invs.add(IntEqual.get_proto());\r\n        proto_invs.add(IntNonEqual.get_proto());\r\n        proto_invs.add(IntLessThan.get_proto());\r\n        proto_invs.add(IntGreaterThan.get_proto());\r\n        proto_invs.add(IntLessEqual.get_proto());\r\n        proto_invs.add(IntGreaterEqual.get_proto());\r\n        proto_invs.add(FloatEqual.get_proto());\r\n        proto_invs.add(FloatNonEqual.get_proto());\r\n        proto_invs.add(FloatLessThan.get_proto());\r\n        proto_invs.add(FloatGreaterThan.get_proto());\r\n        proto_invs.add(FloatLessEqual.get_proto());\r\n        proto_invs.add(FloatGreaterEqual.get_proto());\r\n        proto_invs.add(StringEqual.get_proto());\r\n        proto_invs.add(StringNonEqual.get_proto());\r\n        proto_invs.add(StringLessThan.get_proto());\r\n        proto_invs.add(StringGreaterThan.get_proto());\r\n        proto_invs.add(StringLessEqual.get_proto());\r\n        proto_invs.add(StringGreaterEqual.get_proto());\r\n        proto_invs.add(LinearBinary.get_proto());\r\n        proto_invs.add(LinearBinaryFloat.get_proto());\r\n        proto_invs.addAll(NumericInt.get_proto_all());\r\n        proto_invs.addAll(NumericFloat.get_proto_all());\r\n    }\r\n    {\r\n        proto_invs.addAll(PairwiseNumericInt.get_proto_all());\r\n        proto_invs.addAll(PairwiseNumericFloat.get_proto_all());\r\n        proto_invs.add(SeqSeqIntEqual.get_proto());\r\n        proto_invs.add(SeqSeqIntLessThan.get_proto());\r\n        proto_invs.add(SeqSeqIntGreaterThan.get_proto());\r\n        proto_invs.add(SeqSeqIntLessEqual.get_proto());\r\n        proto_invs.add(SeqSeqIntGreaterEqual.get_proto());\r\n        proto_invs.add(SeqSeqFloatEqual.get_proto());\r\n        proto_invs.add(SeqSeqFloatLessThan.get_proto());\r\n        proto_invs.add(SeqSeqFloatGreaterThan.get_proto());\r\n        proto_invs.add(SeqSeqFloatLessEqual.get_proto());\r\n        proto_invs.add(SeqSeqFloatGreaterEqual.get_proto());\r\n        proto_invs.add(SeqSeqStringEqual.get_proto());\r\n        proto_invs.add(SeqSeqStringLessThan.get_proto());\r\n        proto_invs.add(SeqSeqStringGreaterThan.get_proto());\r\n        proto_invs.add(SeqSeqStringLessEqual.get_proto());\r\n        proto_invs.add(SeqSeqStringGreaterEqual.get_proto());\r\n        proto_invs.add(PairwiseIntEqual.get_proto());\r\n        proto_invs.add(PairwiseIntLessThan.get_proto());\r\n        proto_invs.add(PairwiseIntGreaterThan.get_proto());\r\n        proto_invs.add(PairwiseIntLessEqual.get_proto());\r\n        proto_invs.add(PairwiseIntGreaterEqual.get_proto());\r\n        proto_invs.add(PairwiseFloatEqual.get_proto());\r\n        proto_invs.add(PairwiseFloatLessThan.get_proto());\r\n        proto_invs.add(PairwiseFloatGreaterThan.get_proto());\r\n        proto_invs.add(PairwiseFloatLessEqual.get_proto());\r\n        proto_invs.add(PairwiseFloatGreaterEqual.get_proto());\r\n        proto_invs.add(Reverse.get_proto());\r\n        proto_invs.add(ReverseFloat.get_proto());\r\n        proto_invs.add(PairwiseLinearBinary.get_proto());\r\n        proto_invs.add(PairwiseLinearBinaryFloat.get_proto());\r\n        proto_invs.add(SubSet.get_proto());\r\n        proto_invs.add(SuperSet.get_proto());\r\n        proto_invs.add(SubSetFloat.get_proto());\r\n        proto_invs.add(SuperSetFloat.get_proto());\r\n        proto_invs.add(SubSequence.get_proto());\r\n        proto_invs.add(SubSequenceFloat.get_proto());\r\n        proto_invs.add(SuperSequence.get_proto());\r\n        proto_invs.add(SuperSequenceFloat.get_proto());\r\n    }\r\n    {\r\n        proto_invs.add(SeqIntEqual.get_proto());\r\n        proto_invs.add(SeqIntLessThan.get_proto());\r\n        proto_invs.add(SeqIntGreaterThan.get_proto());\r\n        proto_invs.add(SeqIntLessEqual.get_proto());\r\n        proto_invs.add(SeqIntGreaterEqual.get_proto());\r\n        proto_invs.add(SeqFloatEqual.get_proto());\r\n        proto_invs.add(SeqFloatLessThan.get_proto());\r\n        proto_invs.add(SeqFloatGreaterThan.get_proto());\r\n        proto_invs.add(SeqFloatLessEqual.get_proto());\r\n        proto_invs.add(SeqFloatGreaterEqual.get_proto());\r\n        proto_invs.add(Member.get_proto());\r\n        proto_invs.add(MemberFloat.get_proto());\r\n        proto_invs.add(MemberString.get_proto());\r\n    }\r\n    {\r\n        proto_invs.addAll(FunctionBinary.get_proto_all());\r\n        proto_invs.addAll(FunctionBinaryFloat.get_proto_all());\r\n        proto_invs.add(LinearTernary.get_proto());\r\n        proto_invs.add(LinearTernaryFloat.get_proto());\r\n    }\r\n    for (Iterator<Invariant> i = proto_invs.iterator(); i.hasNext(); ) {\r\n        Invariant inv = i.next();\r\n        Assert.assertTrue(inv != null);\r\n        if (!inv.enabled())\r\n            i.remove();\r\n    }\r\n}"
}, {
	"Path": "spoon.processing.AbstractAnnotationProcessor.isToBeProcessed",
	"Comment": "returns true if the element is annotated with an annotation whose type is\tprocessed.",
	"Method": "boolean isToBeProcessed(E element){\r\n    if ((element != null) && (element.getAnnotations() != null)) {\r\n        for (CtAnnotation<? extends Annotation> a : element.getAnnotations()) {\r\n            if (shoudBeProcessed(a)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.mapreduce.MapReduceOptions.getLimit",
	"Comment": "get the maximum number of documents for the input into the map function.",
	"Method": "Integer getLimit(){\r\n    return limit;\r\n}"
}, {
	"Path": "org.apache.commons.math4.linear.ArrayRealVector.getDataRef",
	"Comment": "get a reference to the underlying data array.this method does not make a fresh copy of the underlying data.",
	"Method": "double[] getDataRef(){\r\n    return data;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMVCViewResponseService.hasThymeleafDependencies",
	"Comment": "this method checks if thymeleaf dependencies has been installed before",
	"Method": "boolean hasThymeleafDependencies(String moduleName){\r\n    if (!getProjectOperations().getPomFromModuleName(moduleName).getDependenciesExcludingVersion(STARTER_THYMELEAF_DEPENDENCY).isEmpty() && !getProjectOperations().getPomFromModuleName(moduleName).getDependenciesExcludingVersion(LAYOUT_THYMELEAF_DEPENDENCY).isEmpty()) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "spoon.reflect.factory.FactoryImpl.getParentFactory",
	"Comment": "returns the parent of this factory. when an element is not found in a\tfactory, it can be looked up in its parent factory using a delegation\tmodel.",
	"Method": "Factory getParentFactory(){\r\n    return parentFactory;\r\n}"
}, {
	"Path": "org.springframework.data.redis.core.IndexWriter.deleteAndUpdateIndexes",
	"Comment": "updates indexes by first removing key from existing one and then persisting new index data.",
	"Method": "void deleteAndUpdateIndexes(Object key,Iterable<IndexedData> indexValues){\r\n    createOrUpdateIndexes(key, indexValues, IndexWriteMode.UPDATE);\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.RepositoryEntityController.createAndReturn",
	"Comment": "triggers the creation of the domain object and renders it into the response if needed.",
	"Method": "ResponseEntity<ResourceSupport> createAndReturn(Object domainObject,RepositoryInvoker invoker,PersistentEntityResourceAssembler assembler,boolean returnBody){\r\n    publisher.publishEvent(new BeforeCreateEvent(domainObject));\r\n    Object savedObject = invoker.invokeSave(domainObject);\r\n    publisher.publishEvent(new AfterCreateEvent(savedObject));\r\n    Optional<PersistentEntityResource> resource = Optional.ofNullable(returnBody ? assembler.toFullResource(savedObject) : null);\r\n    HttpHeaders headers = headersPreparer.prepareHeaders(resource);\r\n    addLocationHeader(headers, assembler, savedObject);\r\n    return ControllerUtils.toResponseEntity(HttpStatus.CREATED, headers, resource);\r\n}"
}, {
	"Path": "org.spongepowered.api.text.format.TextStyle.hasUnderline",
	"Comment": "checks for whether text where this style is applied has an underline.",
	"Method": "Optional<Boolean> hasUnderline(){\r\n    return this.underline;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Query.withHint",
	"Comment": "configures the query to use the given hint when being executed.",
	"Method": "Query withHint(String name){\r\n    Assert.hasText(name, \"Hint must not be empty or null!\");\r\n    this.hint = name;\r\n    return this;\r\n}"
}, {
	"Path": "daikon.FileIO.read_serialized_pptmap",
	"Comment": "read either a serialized pptmap or a invmap and return apptmap.if an invmap is specified, it is converted to a pptmap",
	"Method": "PptMap read_serialized_pptmap(File file,boolean use_saved_config){\r\n    try {\r\n        Object obj = UtilMDE.readObject(file);\r\n        if (obj instanceof FileIO.SerialFormat) {\r\n            SerialFormat record = (SerialFormat) obj;\r\n            if (use_saved_config) {\r\n                Configuration.getInstance().overlap(record.config);\r\n            }\r\n            FileIO.new_decl_format = record.new_decl_format;\r\n            return (record.map);\r\n        } else if (obj instanceof InvMap) {\r\n            InvMap invs = (InvMap) obj;\r\n            PptMap ppts = new PptMap();\r\n            for (Iterator<PptTopLevel> i = invs.pptIterator(); i.hasNext(); ) {\r\n                PptTopLevel ppt = i.next();\r\n                PptTopLevel nppt = new PptTopLevel(ppt.name, ppt.var_infos);\r\n                nppt.set_sample_number(ppt.num_samples());\r\n                ppts.add(nppt);\r\n                List<Invariant> inv_list = invs.get(ppt);\r\n                for (Invariant inv : inv_list) {\r\n                    PptSlice slice = nppt.get_or_instantiate_slice(inv.ppt.var_infos);\r\n                    inv.ppt = slice;\r\n                    slice.addInvariant(inv);\r\n                }\r\n            }\r\n            return (ppts);\r\n        } else {\r\n            throw new IOException(\"Unexpected serialized file type: \" + obj.getClass());\r\n        }\r\n    } catch (ClassNotFoundException e) {\r\n        throw (IOException) (new IOException(\"Error while loading inv file\").initCause(e));\r\n    } catch (InvalidClassException e) {\r\n        throw new IOException(\"It is likely that the .inv file format has changed, because a Daikon data structure has been modified, so your old .inv file is no longer readable by Daikon.  Please regenerate your .inv file.\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Part.detectAndSetIgnoreCase",
	"Comment": "detects if expression contains ignorecase option and removes it.",
	"Method": "String detectAndSetIgnoreCase(String expression){\r\n    Matcher matcher = IGNORE_CASE.matcher(expression);\r\n    String result = expression;\r\n    if (matcher.find()) {\r\n        ignoreCase = IgnoreCaseType.ALWAYS;\r\n        ignoreCaseString = matcher.group(0);\r\n        result = expression.substring(0, matcher.start()) + expression.substring(matcher.end(), expression.length());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "spoon.reflect.visitor.PrinterHelper.adjustStartPosition",
	"Comment": "writes as many newlines as needed to align the line number again between the element position and the current line number",
	"Method": "PrinterHelper adjustStartPosition(CtElement e){\r\n    if (!e.isImplicit() && e.getPosition().isValidPosition()) {\r\n        while (line < e.getPosition().getLine()) {\r\n            writeln();\r\n        }\r\n        while (line > e.getPosition().getLine()) {\r\n            if (!removeLine()) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.i18n.I18nOperationsImpl.getControllerMVCResponseTypes",
	"Comment": "this method gets all implementations of controllermvcresponseserviceinterface to be able to locate all controllermvcresponseservice. usesparam installed to obtain only the installed or not installed responsetypes.",
	"Method": "List<ControllerMVCResponseService> getControllerMVCResponseTypes(boolean installed){\r\n    List<ControllerMVCResponseService> responseTypes = new ArrayList<ControllerMVCResponseService>();\r\n    try {\r\n        ServiceReference<?>[] references = this.context.getAllServiceReferences(ControllerMVCResponseService.class.getName(), null);\r\n        for (ServiceReference<?> ref : references) {\r\n            ControllerMVCResponseService responseTypeService = (ControllerMVCResponseService) this.context.getService(ref);\r\n            boolean isAbleToInstall = false;\r\n            for (Pom module : getProjectOperations().getPoms()) {\r\n                if (responseTypeService.isInstalledInModule(module.getModuleName()) == installed) {\r\n                    isAbleToInstall = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (isAbleToInstall) {\r\n                responseTypes.add(responseTypeService);\r\n            }\r\n        }\r\n        return responseTypes;\r\n    } catch (InvalidSyntaxException e) {\r\n        LOGGER.warning(\"Cannot load ControllerMVCResponseService on I18nOperationsImpl.\");\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaCustomMetadata.getCustomFinderMethods",
	"Comment": "this method returns all finder methods which return a projection",
	"Method": "List<Pair<MethodMetadata, PartTree>> getCustomFinderMethods(){\r\n    return customFinderMethods;\r\n}"
}, {
	"Path": "org.springframework.data.redis.listener.adapter.MessageListenerAdapter.getListenerMethodName",
	"Comment": "determine the name of the listener method that is supposed to handle the given message.\tthe default implementation simply returns the configured default listener method, if any.",
	"Method": "String getListenerMethodName(Message originalMessage,Object extractedMessage){\r\n    return getDefaultListenerMethod();\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.json.JacksonMetadata.isValueType",
	"Comment": "returns whether the backing type is considered a jackson value type.",
	"Method": "boolean isValueType(){\r\n    return isValue;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMVCViewResponseService.isInstalledInModule",
	"Comment": "this operation checks if this feature is installed in module.thymeleaf is installed in module if thymeleaf dependencies has been installed before.",
	"Method": "boolean isInstalledInModule(String moduleName){\r\n    return getProjectOperations().isFeatureInstalled(FeatureNames.MVC) && hasThymeleafDependencies(moduleName);\r\n}"
}, {
	"Path": "org.springframework.data.redis.listener.adapter.MessageListenerAdapter.getDefaultListenerMethod",
	"Comment": "return the name of the default listener method to delegate to.",
	"Method": "String getDefaultListenerMethod(){\r\n    return this.defaultListenerMethod;\r\n}"
}, {
	"Path": "org.apache.cassandra.index.SecondaryIndexManager.newCleanupTransaction",
	"Comment": "transaction for use when removing partitions during cleanup",
	"Method": "CleanupTransaction newCleanupTransaction(DecoratedKey key,PartitionColumns partitionColumns,int nowInSec){\r\n    if (!hasIndexes())\r\n        return CleanupTransaction.NO_OP;\r\n    Index[] interestedIndexes = indexes.values().stream().filter(i -> i.indexes(partitionColumns)).toArray(Index[]::new);\r\n    return interestedIndexes.length == 0 ? CleanupTransaction.NO_OP : new CleanupGCTransaction(key, nowInSec, interestedIndexes);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.responses.json.JSONMVCResponseService.annotate",
	"Comment": "this operation annotates a controller with the json annotation",
	"Method": "void annotate(JavaType controller){\r\n    Validate.notNull(controller, \"ERROR: You must provide a valid controller\");\r\n    ClassOrInterfaceTypeDetails controllerDetails = getTypeLocationService().getTypeDetails(controller);\r\n    Validate.notNull(controllerDetails, \"ERROR: You must provide an existing controller\");\r\n    Validate.notNull(controllerDetails.getAnnotation(RooJavaType.ROO_CONTROLLER), \"ERROR: You must provide a controller annotated with @RooController\");\r\n    ClassOrInterfaceTypeDetailsBuilder typeBuilder = new ClassOrInterfaceTypeDetailsBuilder(controllerDetails);\r\n    typeBuilder.addAnnotation(new AnnotationMetadataBuilder(getAnnotation()));\r\n    getTypeManagementService().createOrUpdateTypeOnDisk(typeBuilder.build());\r\n}"
}, {
	"Path": "org.spongepowered.api.world.Location.hasTileEntity",
	"Comment": "checks for whether the block at this position contains tile entity data.",
	"Method": "boolean hasTileEntity(){\r\n    return getExtent().getTileEntity(getBlockPosition()).isPresent();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.entity.JpaFieldCreatorProvider.checkFieldExists",
	"Comment": "checks if entity has already a field with the same name and throws an exceptionin that case.",
	"Method": "void checkFieldExists(JavaSymbolName fieldName,boolean isForce,ClassOrInterfaceTypeDetails javaTypeDetails,String parameterName){\r\n    MemberDetails memberDetails = memberDetailsScanner.getMemberDetails(this.getClass().getName(), javaTypeDetails);\r\n    List<FieldMetadata> fields = memberDetails.getFields();\r\n    for (FieldMetadata field : fields) {\r\n        if (field.getFieldName().equals(fieldName) && !isForce) {\r\n            throw new IllegalArgumentException(String.format(\"Field '%s' already exists and cannot be created. Try to use a \" + \"different field name on --%s parameter or use --force parameter to overwrite it.\", fieldName, parameterName));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.index.IndexInfo.isIndexForFields",
	"Comment": "returns whether the index is covering exactly the fields given independently of the order.",
	"Method": "boolean isIndexForFields(Collection<String> keys){\r\n    Assert.notNull(keys, \"Collection of keys must not be null!\");\r\n    List<String> indexKeys = new ArrayList<String>(indexFields.size());\r\n    for (IndexField field : indexFields) {\r\n        indexKeys.add(field.getKey());\r\n    }\r\n    return indexKeys.containsAll(keys);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.gridfs.AntPath.toRegex",
	"Comment": "returns the regular expression equivalent of this ant path.",
	"Method": "String toRegex(){\r\n    StringBuilder patternBuilder = new StringBuilder();\r\n    Matcher m = WILDCARD_PATTERN.matcher(path);\r\n    int end = 0;\r\n    while (m.find()) {\r\n        patternBuilder.append(quote(path, end, m.start()));\r\n        String match = m.group();\r\n        if (\"?\".equals(match)) {\r\n            patternBuilder.append('.');\r\n        } else if (\"**\".equals(match)) {\r\n            patternBuilder.append(\".*\");\r\n        } else if (\"*\".equals(match)) {\r\n            patternBuilder.append(\"[^/]*\");\r\n        }\r\n        end = m.end();\r\n    }\r\n    patternBuilder.append(quote(path, end, path.length()));\r\n    return patternBuilder.toString();\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.json.DomainObjectReader.readPut",
	"Comment": "reads the given source node onto the given target object and applies put semantics, i.e. explicitly",
	"Method": "T readPut(ObjectNode source,T target,ObjectMapper mapper){\r\n    Assert.notNull(source, \"ObjectNode must not be null!\");\r\n    Assert.notNull(target, \"Existing object instance must not be null!\");\r\n    Assert.notNull(mapper, \"ObjectMapper must not be null!\");\r\n    Class<? extends Object> type = target.getClass();\r\n    entities.getRequiredPersistentEntity(type);\r\n    try {\r\n        Object intermediate = mapper.readerFor(target.getClass()).readValue(source);\r\n        return (T) mergeForPut(intermediate, target, mapper);\r\n    } catch (Exception o_O) {\r\n        throw new HttpMessageNotReadableException(\"Could not read payload!\", o_O);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.components.MenuEntry.calculateZ",
	"Comment": "calculate the hash code of the entityname, path, pathprefix, entitylabel and entityplurallabel properties",
	"Method": "String calculateZ(){\r\n    final int prime = 31;\r\n    int result = 1;\r\n    result = prime * result + ((entityName == null) ? 0 : entityName.hashCode());\r\n    result = prime * result + ((path == null) ? 0 : path.hashCode());\r\n    result = prime * result + ((pathPrefix == null) ? 0 : pathPrefix.hashCode());\r\n    result = prime * result + ((entityLabel == null) ? 0 : entityLabel.hashCode());\r\n    result = prime * result + ((entityPluralLabel == null) ? 0 : entityPluralLabel.hashCode());\r\n    return Integer.toHexString(result);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.ViewCommands.installTemplates",
	"Comment": "this method provides the command definition to be able to installview generation templates on current project.installing this templates, developers will be able to customize view generation.",
	"Method": "void installTemplates(String type){\r\n    Map<String, ControllerMVCResponseService> responseTypes = getControllerMVCResponseTypes(true);\r\n    if (!responseTypes.containsKey(type)) {\r\n        throw new IllegalArgumentException(\"ERROR: You have provided an invalid type.\");\r\n    }\r\n    getMVCViewGenerationService(type).installTemplates();\r\n}"
}, {
	"Path": "daikon.FileIO.print_invocations_grouped",
	"Comment": "print the invocations in the collection, in order, andsuppressing duplicates.",
	"Method": "void print_invocations_grouped(Collection<Invocation> invocations){\r\n    Map<Invocation, Integer> counter = new HashMap<Invocation, Integer>();\r\n    for (Invocation invok : invocations) {\r\n        invok = invok.canonicalize();\r\n        if (counter.containsKey(invok)) {\r\n            Integer oldCount = counter.get(invok);\r\n            Integer newCount = new Integer(oldCount.intValue() + 1);\r\n            counter.put(invok, newCount);\r\n        } else {\r\n            counter.put(invok, new Integer(1));\r\n        }\r\n    }\r\n    TreeSet<Invocation> keys = new TreeSet<Invocation>(counter.keySet());\r\n    for (Invocation invok : keys) {\r\n        Integer count = counter.get(invok);\r\n        System.out.println(invok.format(false) + \" : \" + UtilMDE.nplural(count.intValue(), \"invocation\"));\r\n    }\r\n}"
}, {
	"Path": "spoon.refactoring.Refactoring.changeMethodName",
	"Comment": "changes name of a method, propagates the change in the executable references of the model.",
	"Method": "void changeMethodName(CtMethod<?> method,String newName){\r\n    final List<CtExecutableReference<?>> references = Query.getElements(method.getFactory(), new TypeFilter<CtExecutableReference<?>>(CtExecutableReference.class) {\r\n        @Override\r\n        public boolean matches(CtExecutableReference<?> reference) {\r\n            return reference.getDeclaration() == method;\r\n        }\r\n    });\r\n    method.setSimpleName(newName);\r\n    for (CtExecutableReference<?> reference : references) {\r\n        reference.setSimpleName(newName);\r\n    }\r\n}"
}, {
	"Path": "spoon.refactoring.Refactoring.changeMethodName",
	"Comment": "changes name of a method, propagates the change in the executable references of the model.",
	"Method": "void changeMethodName(CtMethod<?> method,String newName){\r\n    return reference.getDeclaration() == method;\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.JDTTreeBuilderHelper.createVariableAccess",
	"Comment": "creates a variable or a field access from its qualified name.",
	"Method": "CtVariableAccess<T> createVariableAccess(CtVariableReference<T> variableReference,boolean isReadAccess,CtVariableAccess<T> createVariableAccess,SingleNameReference singleNameReference,CtVariableAccess<T> createVariableAccess,QualifiedNameReference qualifiedNameReference){\r\n    long[] positions = qualifiedNameReference.sourcePositions;\r\n    int sourceStart = qualifiedNameReference.sourceStart();\r\n    int sourceEnd = qualifiedNameReference.sourceEnd();\r\n    if (qualifiedNameReference.indexOfFirstFieldBinding < positions.length) {\r\n        sourceEnd = (int) (positions[qualifiedNameReference.indexOfFirstFieldBinding] >>> 32) - 2;\r\n    }\r\n    CtVariableAccess<T> va;\r\n    CtVariableReference<T> ref;\r\n    boolean fromAssignment = isLhsAssignment(jdtTreeBuilder.getContextBuilder(), qualifiedNameReference);\r\n    boolean isOtherBinding = qualifiedNameReference.otherBindings == null || qualifiedNameReference.otherBindings.length == 0;\r\n    if (qualifiedNameReference.binding instanceof FieldBinding) {\r\n        ref = jdtTreeBuilder.getReferencesBuilder().getVariableReference(qualifiedNameReference.fieldBinding());\r\n        ref.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(sourceStart, sourceEnd));\r\n        va = createFieldAccess(ref, createTargetFieldAccess(qualifiedNameReference, (CtFieldReference<Object>) ref), isOtherBinding && fromAssignment);\r\n    } else {\r\n        ref = jdtTreeBuilder.getReferencesBuilder().getVariableReference((VariableBinding) qualifiedNameReference.binding);\r\n        ref.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(sourceStart, sourceEnd));\r\n        va = createVariableAccess(ref, isOtherBinding && fromAssignment);\r\n    }\r\n    ref.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(sourceStart, sourceEnd));\r\n    if (qualifiedNameReference.otherBindings != null) {\r\n        int i = 0;\r\n        va.setPosition(ref.getPosition());\r\n        sourceStart = (int) (positions[qualifiedNameReference.indexOfFirstFieldBinding - 1] >>> 32);\r\n        for (FieldBinding b : qualifiedNameReference.otherBindings) {\r\n            isOtherBinding = qualifiedNameReference.otherBindings.length == i + 1;\r\n            CtFieldAccess<T> other = createFieldAccess(jdtTreeBuilder.getReferencesBuilder().<T>getVariableReference(b, qualifiedNameReference.tokens[i + 1]), va, isOtherBinding && fromAssignment);\r\n            if (i + qualifiedNameReference.indexOfFirstFieldBinding >= qualifiedNameReference.otherBindings.length) {\r\n                sourceEnd = qualifiedNameReference.sourceEnd();\r\n            } else {\r\n                sourceEnd = (int) (positions[qualifiedNameReference.indexOfFirstFieldBinding + i + 1] >>> 32) - 2;\r\n            }\r\n            other.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(sourceStart, sourceEnd));\r\n            va = other;\r\n            i++;\r\n        }\r\n    } else if (!(qualifiedNameReference.binding instanceof FieldBinding) && qualifiedNameReference.tokens.length > 1) {\r\n        sourceStart = (int) (positions[0] >>> 32);\r\n        for (int i = 1; i < qualifiedNameReference.tokens.length; i++) {\r\n            isOtherBinding = qualifiedNameReference.tokens.length == i + 1;\r\n            CtFieldAccess<T> other = createFieldAccess(jdtTreeBuilder.getReferencesBuilder().<T>getVariableReference(null, qualifiedNameReference.tokens[i]), va, isOtherBinding && fromAssignment);\r\n            sourceEnd = (int) (positions[i]);\r\n            va.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(sourceStart, sourceEnd));\r\n            va = other;\r\n        }\r\n    }\r\n    va.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(qualifiedNameReference.sourceStart(), qualifiedNameReference.sourceEnd()));\r\n    return va;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform2.transform",
	"Comment": "transform a vector represented as a pair of coordinates using thistransform.",
	"Method": "Vector2i transform(Vector2i vector,Vector2i transform,int x,int y){\r\n    return new Vector2i(transformX(x, y), transformY(x, y));\r\n}"
}, {
	"Path": "spoon.reflect.factory.FactoryImpl.readObject",
	"Comment": "needed to restore state of transient fields during reading from stream",
	"Method": "void readObject(java.io.ObjectInputStream in){\r\n    threadLocalDedup = new ThreadLocal<Dedup>() {\r\n        @Override\r\n        protected Dedup initialValue() {\r\n            return new Dedup();\r\n        }\r\n    };\r\n    in.defaultReadObject();\r\n}"
}, {
	"Path": "spoon.reflect.factory.FactoryImpl.readObject",
	"Comment": "needed to restore state of transient fields during reading from stream",
	"Method": "void readObject(java.io.ObjectInputStream in){\r\n    return new Dedup();\r\n}"
}, {
	"Path": "spoon.support.reflect.cu.position.SourcePositionImpl.searchLineNumber",
	"Comment": "search the line number corresponding to a specific position",
	"Method": "int searchLineNumber(int position){\r\n    int[] lineSeparatorPositions = getLineSeparatorPositions();\r\n    if (lineSeparatorPositions == null) {\r\n        return 1;\r\n    }\r\n    int length = lineSeparatorPositions.length;\r\n    if (length == 0) {\r\n        return -1;\r\n    }\r\n    int g = 0;\r\n    int d = length - 1;\r\n    int m = 0;\r\n    int start;\r\n    while (g <= d) {\r\n        m = (g + d) / 2;\r\n        if (position < (start = lineSeparatorPositions[m])) {\r\n            d = m - 1;\r\n        } else if (position > start) {\r\n            g = m + 1;\r\n        } else {\r\n            return m + 1;\r\n        }\r\n    }\r\n    if (position < lineSeparatorPositions[m]) {\r\n        return m + 1;\r\n    }\r\n    return m + 2;\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.json.JacksonMetadata.isExported",
	"Comment": "check if a given property for a type is available to be exported, i.e. serialized via jackson.",
	"Method": "boolean isExported(PersistentProperty<?> property){\r\n    Assert.notNull(property, \"PersistentProperty must not be null!\");\r\n    return getDefinitionFor(property) != null;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.AbstractViewGenerationService.getFieldViewItems",
	"Comment": "this method obtains all necessary information about fields from entity andreturns a list of fielditem. if provided entity has more than 5 fields,only the first 5 ones will be included on generated view.",
	"Method": "List<FieldItem> getFieldViewItems(JpaEntityMetadata entityMetadata,List<FieldMetadata> entityFields,String entityName,boolean checkMaxFields,ViewContext<T> ctx,String suffixId){\r\n    List<FieldItem> fieldViewItems = new ArrayList<FieldItem>();\r\n    for (FieldMetadata entityField : entityFields) {\r\n        FieldItem fieldItem = createFieldItem(entityMetadata, entityField, entityName, suffixId, ctx, null);\r\n        if (fieldItem != null) {\r\n            fieldViewItems.add(fieldItem);\r\n        }\r\n        if (fieldViewItems.size() >= MAX_FIELDS_TO_ADD && checkMaxFields) {\r\n            break;\r\n        }\r\n    }\r\n    return fieldViewItems;\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.RepositoryEntityController.addLocationHeader",
	"Comment": "sets the location header pointing to the resource representing the given instance. will make sure we properly\texpand the uri template potentially created as self link.",
	"Method": "void addLocationHeader(HttpHeaders headers,PersistentEntityResourceAssembler assembler,Object source){\r\n    String selfLink = assembler.getSelfLinkFor(source).getHref();\r\n    headers.setLocation(new UriTemplate(selfLink).expand());\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.embedded.AbstractEmbeddedProvider.sendHttpGetRequest",
	"Comment": "method to send a http get request through the roo providedinfrastructure.",
	"Method": "String sendHttpGetRequest(String urlStr){\r\n    Validate.notBlank(urlStr, \"URL required\");\r\n    String result = null;\r\n    if (urlStr.startsWith(\"http://\")) {\r\n        InputStream inputStream = null;\r\n        try {\r\n            final URL url = new URL(urlStr);\r\n            inputStream = urlInputStreamService.openConnection(url);\r\n            return IOUtils.toString(inputStream);\r\n        } catch (final IOException e) {\r\n            LOGGER.warning(\"Unable to connect to \" + urlStr);\r\n        } finally {\r\n            IOUtils.closeQuietly(inputStream);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.elasticsearch.tasks.TaskManager.getCancellableTask",
	"Comment": "returns a cancellable task with given id, or null if the task is not found.",
	"Method": "CancellableTask getCancellableTask(long id){\r\n    CancellableTaskHolder holder = cancellableTasks.get(id);\r\n    if (holder != null) {\r\n        return holder.getTask();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.javabean.addon.JavaBeanMetadata.getAccesorMethods",
	"Comment": "returns a list with the accesor methods of the class requesting the metadata",
	"Method": "List<MethodMetadata> getAccesorMethods(){\r\n    return (List<MethodMetadata>) this.accesorMethods.values();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.config.EntityDeserializerMetadata.getFieldFor",
	"Comment": "this method returns service field included on controller that itrepresents the service spent as parameter",
	"Method": "FieldMetadata getFieldFor(String declaredByMetadataId,JavaType service){\r\n    String fieldName = new JavaSymbolName(service.getSimpleTypeName()).getSymbolNameUnCapitalisedFirstLetter();\r\n    return new FieldMetadataBuilder(declaredByMetadataId, Modifier.PRIVATE, new ArrayList<AnnotationMetadataBuilder>(), new JavaSymbolName(fieldName), service).build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.dto.addon.DtoCommands.getTypeFromEntityParam",
	"Comment": "tries to obtain javatype indicated in command or which has the focus in theshell",
	"Method": "JavaType getTypeFromEntityParam(ShellContext shellContext){\r\n    String typeString = shellContext.getParameters().get(\"entity\");\r\n    JavaType type = null;\r\n    if (typeString != null) {\r\n        type = getJavaTypeConverter().convertFromText(typeString, JavaType.class, PROJECT);\r\n    } else {\r\n        type = lastUsed.getJavaType();\r\n    }\r\n    Validate.notNull(type, \"Couldn't get the entity for 'entity projection' command. Please, be sure that \" + \"param '--entity' is specified with a right value.\");\r\n    return type;\r\n}"
}, {
	"Path": "spoon.Launcher.createCompiler",
	"Comment": "creates a new spoon java compiler with a default factory and a list of\tinput sources.",
	"Method": "SpoonModelBuilder createCompiler(Factory factory,SpoonModelBuilder createCompiler,Factory factory,List<SpoonResource> inputSources,SpoonModelBuilder createCompiler,Factory factory,List<SpoonResource> inputSources,List<SpoonResource> templateSources,SpoonModelBuilder createCompiler,SpoonModelBuilder createCompiler,List<SpoonResource> inputSources){\r\n    SpoonModelBuilder c = createCompiler(factory);\r\n    c.addInputSources(inputSources);\r\n    return c;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.BiomeVolume.getBiome",
	"Comment": "gets an object representing the biome at the given position.",
	"Method": "BiomeType getBiome(Vector3i position,BiomeType getBiome,int x,int y,int z){\r\n    return getBiome(position.getX(), position.getY(), position.getZ());\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.InteractableVolume.getBlockDigTimeWith",
	"Comment": "gets the time it takes to dig this block with the specified item inticks.",
	"Method": "int getBlockDigTimeWith(Vector3i position,ItemStack itemStack,GameProfile profile,int getBlockDigTimeWith,int x,int y,int z,ItemStack itemStack,GameProfile profile){\r\n    return getBlockDigTimeWith(checkNotNull(position, \"position\").getX(), position.getY(), position.getZ(), itemStack, profile);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.repository.query.MongoParameters.getFullTextParameterIndex",
	"Comment": "returns ths inde of the parameter to be used as a textquery param",
	"Method": "int getFullTextParameterIndex(){\r\n    return fullTextIndex != null ? fullTextIndex.intValue() : -1;\r\n}"
}, {
	"Path": "spoon.refactoring.CtParameterRemoveRefactoring.isAllowedParameterUsage",
	"Comment": "detects whether found usage of removed parameter is acceptable",
	"Method": "boolean isAllowedParameterUsage(CtParameterReference<?> paramRef){\r\n    return isRemovedParamOfRefactoredInvocation(paramRef);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaOperationsImpl.generateReadOnlyRepository",
	"Comment": "method that generates readonlyrepository interface on current package. ifreadonlyrepository already exists in this or other package, will not begenerated.",
	"Method": "JavaType generateReadOnlyRepository(JavaPackage repositoryPackage){\r\n    Set<JavaType> readOnlyRepositories = getTypeLocationService().findTypesWithAnnotation(RooJavaType.ROO_READ_ONLY_REPOSITORY);\r\n    if (!readOnlyRepositories.isEmpty()) {\r\n        Iterator<JavaType> it = readOnlyRepositories.iterator();\r\n        while (it.hasNext()) {\r\n            return it.next();\r\n        }\r\n    }\r\n    final JavaType javaType = new JavaType(String.format(\"%s.ReadOnlyRepository\", repositoryPackage), repositoryPackage.getModule());\r\n    final String physicalPath = getPathResolver().getCanonicalPath(javaType.getModule(), Path.SRC_MAIN_JAVA, javaType);\r\n    InputStream inputStream = null;\r\n    try {\r\n        inputStream = FileUtils.getInputStream(getClass(), \"ReadOnlyRepository-template._java\");\r\n        String input = IOUtils.toString(inputStream);\r\n        input = input.replace(\"__PACKAGE__\", repositoryPackage.getFullyQualifiedPackageName());\r\n        getFileManager().createOrUpdateTextFileIfRequired(physicalPath, input, true);\r\n    } catch (final IOException e) {\r\n        throw new IllegalStateException(String.format(\"Unable to create '%s'\", physicalPath), e);\r\n    } finally {\r\n        IOUtils.closeQuietly(inputStream);\r\n    }\r\n    return javaType;\r\n}"
}, {
	"Path": "spoon.ContractVerifier.checkModifiers",
	"Comment": "verifies that the explicit modifier should be present in the original source code",
	"Method": "void checkModifiers(){\r\n    for (CtModifiable modifiable : _rootPackage.getElements(new TypeFilter(CtModifiable.class))) {\r\n        for (CtExtendedModifier modifier : modifiable.getExtendedModifiers()) {\r\n            if (modifier.isImplicit()) {\r\n                continue;\r\n            }\r\n            SourcePosition position = modifier.getPosition();\r\n            CompilationUnit compilationUnit = position.getCompilationUnit();\r\n            String originalSourceCode = compilationUnit.getOriginalSourceCode();\r\n            assertEquals(modifier.getKind().toString(), originalSourceCode.substring(position.getSourceStart(), position.getSourceEnd() + 1));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.world.gen.populator.DoublePlant.clearSupplierOverride",
	"Comment": "clears the supplier override to force the weighted table to be usedinstead.",
	"Method": "void clearSupplierOverride(){\r\n    setSupplierOverride(null);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.aggregation.AggregationResults.getUniqueMappedResult",
	"Comment": "returns the unique mapped result. assumes no result or exactly one.",
	"Method": "T getUniqueMappedResult(){\r\n    Assert.isTrue(mappedResults.size() < 2, \"Expected unique result or null, but got more than one!\");\r\n    return mappedResults.size() == 1 ? mappedResults.get(0) : null;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.crossstore.MongoChangeSetPersister.getCollectionNameForEntity",
	"Comment": "returns the collection the given entity type shall be persisted to.",
	"Method": "String getCollectionNameForEntity(Class<? extends ChangeSetBacked> entityClass){\r\n    return mongoTemplate.getCollectionName(entityClass);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.FindAndReplaceOptions.isReturnNew",
	"Comment": "get the bit indicating to return the replacement document.",
	"Method": "boolean isReturnNew(){\r\n    return returnNew;\r\n}"
}, {
	"Path": "org.springframework.cloud.kubernetes.config.reload.ConfigurationChangeDetector.locateMapPropertySources",
	"Comment": "returns a list of mappropertysource that correspond to the current state of the\tsystem this only handles the propertysource objects that are returned",
	"Method": "List<MapPropertySource> locateMapPropertySources(PropertySourceLocator propertySourceLocator,Environment environment){\r\n    List<MapPropertySource> result = new ArrayList();\r\n    PropertySource propertySource = propertySourceLocator.locate(environment);\r\n    if (propertySource instanceof MapPropertySource) {\r\n        result.add((MapPropertySource) propertySource);\r\n    } else if (propertySource instanceof CompositePropertySource) {\r\n        result.addAll(((CompositePropertySource) propertySource).getPropertySources().stream().filter(p -> p instanceof MapPropertySource).map(p -> (MapPropertySource) p).collect(Collectors.toList()));\r\n    } else {\r\n        log.debug(\"Found property source that cannot be handled: \" + propertySource.getClass());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.lettuce.DefaultLettucePool.setDatabase",
	"Comment": "sets the index of the database used by this connection pool. default is 0.",
	"Method": "void setDatabase(int index){\r\n    Assert.isTrue(index >= 0, \"invalid DB index (a positive index required)\");\r\n    this.dbIndex = index;\r\n}"
}, {
	"Path": "spoon.reflect.visitor.Query.getElements",
	"Comment": "within a given factory, returns all the program elements that match the\tfilter.",
	"Method": "List<E> getElements(Factory factory,Filter<E> filter,List<E> getElements,CtElement rootElement,Filter<E> filter){\r\n    return rootElement.filterChildren(filter).list();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerCommands.addDetailController",
	"Comment": "this method provides the command definition to be able to generate newcontrollers on current project.",
	"Method": "void addDetailController(boolean all,JavaType entity,String field,JavaPackage controllersPackage,String responseType,String viewsList){\r\n    Map<String, ControllerMVCResponseService> responseTypeServices = getInstalledControllerMVCResponseTypes();\r\n    if (!responseTypeServices.containsKey(responseType)) {\r\n        LOGGER.log(Level.SEVERE, \"ERROR: Provided responseType is not valid. Use autocomplete feature to obtain valid responseTypes.\");\r\n        return;\r\n    }\r\n    if (all) {\r\n        getControllerOperations().createOrUpdateDetailControllersForAllEntities(responseTypeServices.get(responseType), controllersPackage, viewsList);\r\n    } else {\r\n        getControllerOperations().createOrUpdateDetailControllerForEntity(entity, field, responseTypeServices.get(responseType), controllersPackage, viewsList);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.mapreduce.MapReduceOptions.verbose",
	"Comment": "flag to set that will provide statistics on job execution time.",
	"Method": "MapReduceOptions verbose(boolean verbose){\r\n    this.verbose = verbose;\r\n    return this;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform3.transform",
	"Comment": "transform a vector represented as a pair ofcoordinates using this transform.",
	"Method": "Vector3i transform(Vector3i vector,Vector3i transform,int x,int y,int z){\r\n    return new Vector3i(transformX(x, y, z), transformY(x, y, z), transformZ(x, y, z));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Predicate.getOptions",
	"Comment": "returns the different queries that can be build based on the current predicate expressions.the options are joined to the current query expression.",
	"Method": "List<String> getOptions(String subject){\r\n    List<String> options = new ArrayList<String>();\r\n    OrPart lastOr = null;\r\n    Part lastAnd = null;\r\n    if (!nodes.isEmpty()) {\r\n        lastOr = nodes.get(nodes.size() - 1);\r\n        lastAnd = lastOr.getChildren().isEmpty() ? null : lastOr.getChildren().get(lastOr.getChildren().size() - 1);\r\n    }\r\n    subject = subject.concat(toString());\r\n    if (lastAnd == null || !lastAnd.hasProperty()) {\r\n        if (subject.endsWith(\"Or\")) {\r\n            options.add(StringUtils.removeEnd(subject, \"Or\").concat(ORDER_BY));\r\n        }\r\n        for (FieldMetadata field : fields) {\r\n            options.add(subject.concat(StringUtils.capitalize(field.getFieldName().toString())));\r\n        }\r\n    } else {\r\n        options.add(subject.concat(\"\"));\r\n        options.add(subject.concat(ORDER_BY));\r\n        if (!alwaysIgnoreCase) {\r\n            options.add(subject.concat(\"AllIgnoreCase\"));\r\n            options.add(subject.concat(\"AllIgnoringCase\"));\r\n            options.add(subject.concat(\"And\"));\r\n            options.add(subject.concat(\"Or\"));\r\n            if (!lastAnd.hasOperator()) {\r\n                List<String> types = lastAnd.getSupportedOperators();\r\n                for (String type : types) {\r\n                    options.add(subject.concat(type));\r\n                }\r\n            } else if (lastAnd.shouldIgnoreCase() != IgnoreCaseType.ALWAYS) {\r\n                List<String> types = lastAnd.getSupportedOperatorsByPrefix(lastAnd.getOperator());\r\n                for (String type : types) {\r\n                    if (StringUtils.isNotBlank(type)) {\r\n                        options.add(subject.concat(type));\r\n                    }\r\n                }\r\n            }\r\n            if (lastAnd.shouldIgnoreCase() != IgnoreCaseType.ALWAYS && lastAnd.getProperty().getKey().peek().getFieldType().equals(JavaType.STRING)) {\r\n                options.add(subject.concat(\"IgnoreCase\"));\r\n                options.add(subject.concat(\"IgnoringCase\"));\r\n            }\r\n            if (!lastAnd.hasOperator() && lastAnd.shouldIgnoreCase() != IgnoreCaseType.ALWAYS) {\r\n                List<FieldMetadata> fields = currentPartTreeInstance.getValidProperties(lastAnd.getProperty().getLeft().peek().getFieldType());\r\n                if (fields != null) {\r\n                    for (FieldMetadata field : fields) {\r\n                        options.add(subject.concat(StringUtils.capitalize(field.getFieldName().toString())));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return options;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMVCViewResponseService.addJasperReportExportClasses",
	"Comment": "create the support classes to allow export data to different file types using jasperreports.",
	"Method": "void addJasperReportExportClasses(Pom module){\r\n    createJasperReportsClassFromTemplate(module, \"JasperReportsExporter-template._java\", \"JasperReportsExporter\");\r\n    createJasperReportsClassFromTemplate(module, \"JasperReportsCsvExporter-template._java\", \"JasperReportsCsvExporter\");\r\n    createJasperReportsClassFromTemplate(module, \"JasperReportsPdfExporter-template._java\", \"JasperReportsPdfExporter\");\r\n    createJasperReportsClassFromTemplate(module, \"JasperReportsXlsExporter-template._java\", \"JasperReportsXlsExporter\");\r\n    createJasperReportsClassFromTemplate(module, \"ExportingErrorException-template._java\", \"ExportingErrorException\");\r\n}"
}, {
	"Path": "spoon.reflect.factory.TypeFactory.hasInnerType",
	"Comment": "tells if a given java qualified name is that of an inner type.",
	"Method": "int hasInnerType(String qualifiedName){\r\n    return qualifiedName.lastIndexOf(CtType.INNERTTYPE_SEPARATOR);\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory.setPassword",
	"Comment": "sets the password used for authenticating with the redis server.",
	"Method": "void setPassword(String password){\r\n    if (RedisConfiguration.isPasswordAware(configuration)) {\r\n        ((WithPassword) configuration).setPassword(password);\r\n        return;\r\n    }\r\n    standaloneConfig.setPassword(RedisPassword.of(password));\r\n}"
}, {
	"Path": "org.spongepowered.api.text.transform.TextFormatter.retain",
	"Comment": "removes all elements from the formatter except for these specifiedelements.",
	"Method": "boolean retain(Collection<E> elements,boolean retain,Iterable<E> elements,boolean retain,Iterator<E> elements){\r\n    return retain(Lists.newArrayList(elements));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.service.addon.ServiceImplMetadata.getIdentifierTypeGetterMethod",
	"Comment": "builds a method which returns the class of the entity identifier javatype.",
	"Method": "MethodMetadata getIdentifierTypeGetterMethod(){\r\n    List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    MethodMetadata existingMethod = getGovernorMethod(GET_ID_TYPE_METHOD_NAME, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    bodyBuilder.appendFormalLine(\"return %s.class;\", getNameOfJavaType(this.entityIdentifierType));\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, GET_ID_TYPE_METHOD_NAME, JavaType.wrapperOf(JavaType.CLASS, this.serviceMetadata.getIdType()), parameterTypes, parameterNames, bodyBuilder);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Subject.extractValidField",
	"Comment": "extracts the property defined in source. if any property is found returns null.",
	"Method": "Pair<Stack<FieldMetadata>, String> extractValidField(String source,List<FieldMetadata> fields){\r\n    if (source == null) {\r\n        return null;\r\n    }\r\n    source = StringUtils.substringBefore(source, \"By\");\r\n    return currentPartTreeInstance.extractValidProperty(source, fields);\r\n}"
}, {
	"Path": "spoon.refactoring.CtParameterRemoveRefactoring.computeAllExecutables",
	"Comment": "search for all methods and lambdas which has to be refactored together with target method",
	"Method": "void computeAllExecutables(){\r\n    if (getTarget() == null) {\r\n        throw new SpoonException(\"The target of refactoring is not defined\");\r\n    }\r\n    final List<CtExecutable<?>> executables = new ArrayList();\r\n    CtExecutable<?> targetExecutable = target.getParent();\r\n    executables.add(targetExecutable);\r\n    targetExecutable.map(new AllMethodsSameSignatureFunction()).forEach(new CtConsumer<CtExecutable<?>>() {\r\n        @Override\r\n        public void accept(CtExecutable<?> executable) {\r\n            executables.add(executable);\r\n        }\r\n    });\r\n    targetExecutables = Collections.unmodifiableList(executables);\r\n}"
}, {
	"Path": "spoon.refactoring.CtParameterRemoveRefactoring.computeAllExecutables",
	"Comment": "search for all methods and lambdas which has to be refactored together with target method",
	"Method": "void computeAllExecutables(){\r\n    executables.add(executable);\r\n}"
}, {
	"Path": "org.spongepowered.api.util.Coerce.toInteger",
	"Comment": "coerce the supplied object to an integer, parse it if necessary.",
	"Method": "int toInteger(Object obj){\r\n    if (obj == null) {\r\n        return 0;\r\n    }\r\n    if (obj instanceof Number) {\r\n        return ((Number) obj).intValue();\r\n    }\r\n    String strObj = Coerce.sanitiseNumber(obj);\r\n    Integer iParsed = Ints.tryParse(strObj);\r\n    if (iParsed != null) {\r\n        return iParsed;\r\n    }\r\n    Double dParsed = Doubles.tryParse(strObj);\r\n    return dParsed != null ? dParsed.intValue() : 0;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.dbre.addon.DbreMetadata.hasFieldInItd",
	"Comment": "indicates whether the itd being built has a field of the given name",
	"Method": "boolean hasFieldInItd(JavaSymbolName fieldName){\r\n    for (final FieldMetadataBuilder declaredField : builder.getDeclaredFields()) {\r\n        if (declaredField.getFieldName().equals(fieldName)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "spoon.Launcher.getProcessors",
	"Comment": "gets the list of processors instance to be initially applied during the\tprocessing.",
	"Method": "List<Processor<? extends CtElement>> getProcessors(){\r\n    return processors;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerCommands.getAllEntities",
	"Comment": "find entities in project and returns a list with their fully qualifiednames.",
	"Method": "List<String> getAllEntities(ShellContext shellContext){\r\n    String currentText = shellContext.getParameters().get(\"entity\");\r\n    List<String> results = new ArrayList<String>();\r\n    Set<ClassOrInterfaceTypeDetails> entities = getTypeLocationService().findClassesOrInterfaceDetailsWithAnnotation(RooJavaType.ROO_JPA_ENTITY);\r\n    for (ClassOrInterfaceTypeDetails entity : entities) {\r\n        if (!entity.isAbstract()) {\r\n            String name = getClasspathOperations().replaceTopLevelPackageString(entity, currentText);\r\n            if (!results.contains(name)) {\r\n                results.add(name);\r\n            }\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.ViewCommands.isSetupAvailable",
	"Comment": "this method checks if web mvc view setup command is available or not.view setup command will be available if exists some type thathas not been installed.",
	"Method": "boolean isSetupAvailable(){\r\n    return getProjectOperations().isFeatureInstalled(FeatureNames.MVC) && !getControllerMVCResponseTypes(false).isEmpty();\r\n}"
}, {
	"Path": "org.spongepowered.api.world.Chunk.getNeighbor",
	"Comment": "gets the chunk in the given direction from this chunk, if it exists.",
	"Method": "Optional<Chunk> getNeighbor(Direction direction,Optional<Chunk> getNeighbor,Direction direction,boolean shouldLoad){\r\n    Optional<Vector3i> neighborPosition = Sponge.getServer().getChunkLayout().moveToChunk(getPosition(), direction);\r\n    return neighborPosition.flatMap(vector3i -> getWorld().loadChunk(vector3i, shouldLoad));\r\n}"
}, {
	"Path": "com.duckduckgo.mobile.android.util.TorIntegration.promptToInstall",
	"Comment": "this method is same as orbothelper.prompttoinstall except dismisses the previous dialogs and stores the reference of new one.",
	"Method": "void promptToInstall(){\r\n    String uriMarket = context.getString(info.guardianproject.onionkit.R.string.market_orbot);\r\n    dialogOrbotInstall = showDownloadDialog(context.getString(info.guardianproject.onionkit.R.string.install_orbot_), context.getString(info.guardianproject.onionkit.R.string.you_must_have_orbot), context.getString(info.guardianproject.onionkit.R.string.yes), context.getString(info.guardianproject.onionkit.R.string.no), uriMarket);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.components.EntityItem.buildId",
	"Comment": "builds the id of the specified field and adds it to the entity label",
	"Method": "void buildId(String suffix){\r\n    String id = XmlUtils.convertId(this.entityName.toLowerCase());\r\n    if (!StringUtils.isEmpty(suffix)) {\r\n        id = id.concat(\"-\").concat(XmlUtils.convertId(suffix.toLowerCase()));\r\n    }\r\n    this.entityItemId = id;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.dbre.addon.DbreDatabaseListenerImpl.getRepositoryJpaOperations",
	"Comment": "method to get repositoryjpaoperations service implementation",
	"Method": "RepositoryJpaOperations getRepositoryJpaOperations(){\r\n    if (repositoryJpaOperations == null) {\r\n        try {\r\n            ServiceReference<?>[] references = context.getAllServiceReferences(RepositoryJpaOperations.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                repositoryJpaOperations = (RepositoryJpaOperations) context.getService(ref);\r\n                return repositoryJpaOperations;\r\n            }\r\n            return null;\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load RepositoryJpaOperations on DbreDatabaseListenerImpl.\");\r\n            return null;\r\n        }\r\n    } else {\r\n        return repositoryJpaOperations;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Update.update",
	"Comment": "static factory method to create an update using the provided key",
	"Method": "Update update(String key,Object value){\r\n    return new Update().set(key, value);\r\n}"
}, {
	"Path": "spoon.test.refactoring.testclasses.CtRenameLocalVariableRefactoringTestSubject.nestedClassMethodWithoutRefs",
	"Comment": "tests nested class and conflict with field, \tand no nested local variable references so rename is possible",
	"Method": "void nestedClassMethodWithoutRefs(){\r\n    @TestTryRename({ \"var2\", \"var3\", \"var4\", \"var5\", \"var6\" })\r\n    int var1 = 1;\r\n    new Consumer<Integer>() {\r\n        @TestTryRename({ \"-var1\", \"var3\", \"var4\", \"var5\", \"var6\" })\r\n        int var2 = 2;\r\n        @Override\r\n        public void accept(@TestTryRename({ \"-var1\", \"var2\", \"-var3\", \"-var5\", \"-var6\" }) Integer var4) {\r\n            @TestTryRename({ \"var1\", \"var2\", \"-var4\", \"-var5\", \"-var6\" })\r\n            int var3 = 3;\r\n            try {\r\n                @TestTryRename({ \"var1\", \"var2\", \"-var3\", \"-var4\", \"var6\" })\r\n                int var5 = 5;\r\n                assertTrue(var2 == 2);\r\n                assertTrue(var3 == 3);\r\n                assertTrue(var4 == 4);\r\n                assertTrue(var5 == 5);\r\n                throw new NumberFormatException();\r\n            } catch (@TestTryRename({ \"var1\", \"var2\", \"-var3\", \"-var4\", \"var5\" }) NumberFormatException var6) {\r\n                assertTrue(var2 == 2);\r\n                assertTrue(var3 == 3);\r\n                assertTrue(var4 == 4);\r\n            }\r\n        }\r\n    }.accept(4);\r\n    assertTrue(var1 == 1);\r\n}"
}, {
	"Path": "spoon.test.refactoring.testclasses.CtRenameLocalVariableRefactoringTestSubject.nestedClassMethodWithoutRefs",
	"Comment": "tests nested class and conflict with field, \tand no nested local variable references so rename is possible",
	"Method": "void nestedClassMethodWithoutRefs(){\r\n    @TestTryRename({ \"var1\", \"var2\", \"-var4\", \"-var5\", \"-var6\" })\r\n    int var3 = 3;\r\n    try {\r\n        @TestTryRename({ \"var1\", \"var2\", \"-var3\", \"-var4\", \"var6\" })\r\n        int var5 = 5;\r\n        assertTrue(var2 == 2);\r\n        assertTrue(var3 == 3);\r\n        assertTrue(var4 == 4);\r\n        assertTrue(var5 == 5);\r\n        throw new NumberFormatException();\r\n    } catch (@TestTryRename({ \"var1\", \"var2\", \"-var3\", \"-var4\", \"var5\" }) NumberFormatException var6) {\r\n        assertTrue(var2 == 2);\r\n        assertTrue(var3 == 3);\r\n        assertTrue(var4 == 4);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaOperationsImpl.generateRepositoryCustomImpl",
	"Comment": "method that generates repositorycustom implementation on current package.if this repositorycustom implementation already exists in this or otherpackage, will not be generated.",
	"Method": "JavaType generateRepositoryCustomImpl(JavaType interfaceType,JavaType repository,JavaType entity){\r\n    JavaType implType = new JavaType(repository.getFullyQualifiedTypeName().concat(\"Impl\"), repository.getModule());\r\n    final String implIdentifier = getPathResolver().getCanonicalPath(implType.getModule(), Path.SRC_MAIN_JAVA, implType);\r\n    if (getFileManager().exists(implIdentifier)) {\r\n        return implType;\r\n    }\r\n    Set<JavaType> repositoriesCustomImpl = getTypeLocationService().findTypesWithAnnotation(RooJavaType.ROO_REPOSITORY_JPA_CUSTOM_IMPL);\r\n    if (!repositoriesCustomImpl.isEmpty()) {\r\n        Iterator<JavaType> it = repositoriesCustomImpl.iterator();\r\n        while (it.hasNext()) {\r\n            JavaType repositoryCustom = it.next();\r\n            ClassOrInterfaceTypeDetails repositoryDetails = getTypeLocationService().getTypeDetails(repositoryCustom);\r\n            AnnotationMetadata annotation = repositoryDetails.getAnnotation(RooJavaType.ROO_REPOSITORY_JPA_CUSTOM_IMPL);\r\n            AnnotationAttributeValue<JavaType> repositoryType = annotation.getAttribute(\"repository\");\r\n            if (repositoryType.getValue().equals(interfaceType)) {\r\n                return repositoryType.getValue();\r\n            }\r\n        }\r\n    }\r\n    InputStream inputStream = null;\r\n    try {\r\n        inputStream = FileUtils.getInputStream(getClass(), \"RepositoryCustomImpl-template._java\");\r\n        String input = IOUtils.toString(inputStream);\r\n        input = input.replace(\"__PACKAGE__\", implType.getPackage().getFullyQualifiedPackageName());\r\n        input = input.replace(\"__ENTITY_IMPORT__\", entity.getFullyQualifiedTypeName());\r\n        input = input.replace(\"__REPOSITORY_CUSTOM_INTERFACE__\", interfaceType.getSimpleTypeName());\r\n        input = input.replaceAll(\"__REPOSITORY_CUSTOM_IMPL__\", implType.getSimpleTypeName());\r\n        input = input.replace(\"__ENTITY_NAME__\", entity.getSimpleTypeName());\r\n        getFileManager().createOrUpdateTextFileIfRequired(implIdentifier, input, false);\r\n    } catch (final IOException e) {\r\n        throw new IllegalStateException(String.format(\"Unable to create '%s'\", implIdentifier), e);\r\n    } finally {\r\n        IOUtils.closeQuietly(inputStream);\r\n    }\r\n    return implType;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.ViewCommands.setup",
	"Comment": "this method provides the command definition to be able to installprovided responsetype on generated project",
	"Method": "void setup(String type,Pom module){\r\n    Map<String, ControllerMVCResponseService> responseTypes = getControllerMVCResponseTypes(false);\r\n    if (!responseTypes.containsKey(type)) {\r\n        throw new IllegalArgumentException(\"ERROR: You have provided an invalid type.\");\r\n    }\r\n    getViewOperations().setup(responseTypes.get(type), module);\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.ReactiveStreamCommands.xDel",
	"Comment": "removes the specified entries from the stream. returns the number of items deleted, that may be different from the\tnumber of ids passed in case certain ids do not exist.",
	"Method": "Mono<Long> xDel(ByteBuffer key,String recordIds,Mono<Long> xDel,ByteBuffer key,RecordId recordIds,Flux<CommandResponse<DeleteCommand, Long>> xDel,Publisher<DeleteCommand> commands){\r\n    Assert.notNull(key, \"Key must not be null!\");\r\n    Assert.notNull(recordIds, \"RecordIds must not be null!\");\r\n    return xDel(Mono.just(DeleteCommand.stream(key).records(recordIds))).next().map(CommandResponse::getOutput);\r\n}"
}, {
	"Path": "org.spongepowered.api.util.RespawnLocation.isForced",
	"Comment": "gets whether the spawn position is forced in the given world, ifavailable. a forced position will spawn the player there even if a bed ismissing or obstructed.",
	"Method": "boolean isForced(){\r\n    return this.forced;\r\n}"
}, {
	"Path": "org.springframework.data.redis.listener.RedisMessageListenerContainer.invokeErrorHandler",
	"Comment": "invoke the registered errorhandler, if any. log at error level otherwise.",
	"Method": "void invokeErrorHandler(Throwable ex){\r\n    if (this.errorHandler != null) {\r\n        this.errorHandler.handleError(ex);\r\n    } else if (logger.isWarnEnabled()) {\r\n        logger.warn(\"Execution of message listener failed, and no ErrorHandler has been set.\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.mapping.Associations.isLinkableAssociation",
	"Comment": "returns whether the given property is an association that is linkable.",
	"Method": "boolean isLinkableAssociation(Association<? extends PersistentProperty<?>> association,boolean isLinkableAssociation,PersistentProperty<?> property){\r\n    Assert.notNull(property, \"PersistentProperty must not be null!\");\r\n    if (!property.isAssociation() || config.isLookupType(property.getActualType())) {\r\n        return false;\r\n    }\r\n    ResourceMetadata metadata = mappings.getMetadataFor(property.getOwner().getType());\r\n    if (metadata != null && !metadata.isExported(property)) {\r\n        return false;\r\n    }\r\n    metadata = mappings.getMetadataFor(property.getActualType());\r\n    return metadata == null ? false : metadata.isExported();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.dto.addon.DtoCommands.returnEntityValues",
	"Comment": "find entities in project and returns a list with their fully qualifiednames.",
	"Method": "List<String> returnEntityValues(ShellContext shellContext){\r\n    String currentText = shellContext.getParameters().get(\"entity\");\r\n    List<String> results = new ArrayList<String>();\r\n    Set<ClassOrInterfaceTypeDetails> entities = typeLocationService.findClassesOrInterfaceDetailsWithAnnotation(RooJavaType.ROO_JPA_ENTITY, JpaJavaType.ENTITY);\r\n    for (ClassOrInterfaceTypeDetails entity : entities) {\r\n        String name = replaceTopLevelPackageString(entity, currentText);\r\n        if (!results.contains(name)) {\r\n            results.add(name);\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.Location.getRelative",
	"Comment": "gets the location next to this one in the given direction.always moves by a unit amount, even diagonally.",
	"Method": "Location<E> getRelative(Direction direction){\r\n    return add(direction.asOffset());\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.mapping.TypeBasedCollectionResourceMapping.getDefaultPathFor",
	"Comment": "returns the default path to be used if the path is not configured manually.",
	"Method": "String getDefaultPathFor(Class<?> type){\r\n    return getSimpleTypeName(type);\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.JDTImportBuilder.build",
	"Comment": "package visible method in a package visible class, not in the public api",
	"Method": "void build(){\r\n    if (declarationUnit.imports == null || declarationUnit.imports.length == 0) {\r\n        return;\r\n    }\r\n    for (ImportReference importRef : declarationUnit.imports) {\r\n        String importName = importRef.toString();\r\n        if (!importRef.isStatic()) {\r\n            if (importName.endsWith(\"*\")) {\r\n                int lastDot = importName.lastIndexOf('.');\r\n                String packageName = importName.substring(0, lastDot);\r\n                CtPackage ctPackage = this.factory.Package().get(packageName);\r\n                if (ctPackage != null) {\r\n                    this.imports.add(createImportWithPosition(ctPackage.getReference(), importRef));\r\n                }\r\n            } else {\r\n                CtType klass = this.getOrLoadClass(importName);\r\n                if (klass != null) {\r\n                    this.imports.add(createImportWithPosition(klass.getReference(), importRef));\r\n                }\r\n            }\r\n        } else {\r\n            int lastDot = importName.lastIndexOf('.');\r\n            String className = importName.substring(0, lastDot);\r\n            String methodOrFieldName = importName.substring(lastDot + 1);\r\n            CtType klass = this.getOrLoadClass(className);\r\n            if (klass != null) {\r\n                if (\"*\".equals(methodOrFieldName)) {\r\n                    this.imports.add(createImportWithPosition(factory.Type().createTypeMemberWildcardImportReference(klass.getReference()), importRef));\r\n                } else {\r\n                    List<CtNamedElement> methodOrFields = klass.getElements(new NamedElementFilter(CtNamedElement.class, methodOrFieldName));\r\n                    if (!methodOrFields.isEmpty()) {\r\n                        CtNamedElement methodOrField = methodOrFields.get(0);\r\n                        this.imports.add(createImportWithPosition(methodOrField.getReference(), importRef));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    spoonUnit.setImports(this.imports);\r\n}"
}, {
	"Path": "org.springframework.data.redis.SpinBarrier.waitFor",
	"Comment": "periodically tests for a condition until it is met or a timeout occurs",
	"Method": "boolean waitFor(TestCondition condition,long timeout){\r\n    boolean passes = false;\r\n    for (long currentTime = System.currentTimeMillis(); System.currentTimeMillis() - currentTime < timeout; ) {\r\n        if (condition.passes()) {\r\n            passes = true;\r\n            break;\r\n        }\r\n        try {\r\n            Thread.sleep(100);\r\n        } catch (InterruptedException e) {\r\n        }\r\n    }\r\n    return passes;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Part.getOperator",
	"Comment": "returns operator keyword. if operator is not defined, returns an empty string.",
	"Method": "String getOperator(){\r\n    return operator;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Predicate.detectAndSetAllIgnoreCase",
	"Comment": "splits source by allignorecase option and returns information before this option.",
	"Method": "String detectAndSetAllIgnoreCase(String source){\r\n    Matcher matcher = ALL_IGNORE_CASE.matcher(source);\r\n    if (matcher.find()) {\r\n        alwaysIgnoreCase = true;\r\n        alwaysIgnoreCaseString = matcher.group(0);\r\n        source = source.substring(0, matcher.start());\r\n    }\r\n    return source;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.storage.ChunkLayout.addToChunk",
	"Comment": "adds the chunk offset to the chunk coordinates. returns nothing if thenew coordinates are not valid.",
	"Method": "Optional<Vector3i> addToChunk(Vector3i chunkCoords,Vector3i chunkOffset,Optional<Vector3i> addToChunk,int cx,int cy,int cz,int ox,int oy,int oz){\r\n    final Vector3i newChunkCoords = new Vector3i(cx + ox, cy + oy, cz + oz);\r\n    return isValidChunk(newChunkCoords) ? Optional.of(newChunkCoords) : Optional.empty();\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.schema.TypedJsonSchemaObject.anyOf",
	"Comment": "the field value must match at least one of the specified schemas.",
	"Method": "TypedJsonSchemaObject anyOf(Collection<JsonSchemaObject> anyOf,ObjectJsonSchemaObject anyOf,Collection<JsonSchemaObject> anyOf,NumericJsonSchemaObject anyOf,Collection<JsonSchemaObject> anyOf,StringJsonSchemaObject anyOf,Collection<JsonSchemaObject> anyOf,ArrayJsonSchemaObject anyOf,Collection<JsonSchemaObject> anyOf,BooleanJsonSchemaObject anyOf,Collection<JsonSchemaObject> anyOf,NullJsonSchemaObject anyOf,Collection<JsonSchemaObject> anyOf,DateJsonSchemaObject anyOf,Collection<JsonSchemaObject> anyOf,TimestampJsonSchemaObject anyOf,Collection<JsonSchemaObject> anyOf){\r\n    return new TypedJsonSchemaObject(types, description, generateDescription, restrictions.anyOf(anyOf));\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.JDTTreeBuilderHelper.createFieldAccessNoClasspath",
	"Comment": "in no classpath mode, when we build a field access, we have a binding typed by problembinding.\twe try to get all information we can get from this binding.",
	"Method": "CtFieldAccess<T> createFieldAccessNoClasspath(SingleNameReference singleNameReference,CtFieldAccess<T> createFieldAccessNoClasspath,QualifiedNameReference qualifiedNameReference){\r\n    boolean fromAssignment = isLhsAssignment(jdtTreeBuilder.getContextBuilder(), qualifiedNameReference);\r\n    CtFieldAccess<T> fieldAccess = createFieldAccess(jdtTreeBuilder.getReferencesBuilder().<T>getVariableReference((ProblemBinding) qualifiedNameReference.binding), null, fromAssignment);\r\n    final char[][] declaringClass = CharOperation.subarray(qualifiedNameReference.tokens, 0, qualifiedNameReference.tokens.length - 1);\r\n    final MissingTypeBinding declaringType = jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.scope.environment.createMissingType(null, declaringClass);\r\n    final CtTypeReference<T> declaringRef = jdtTreeBuilder.getReferencesBuilder().getTypeReference(declaringType);\r\n    fieldAccess.getVariable().setDeclaringType(declaringRef);\r\n    fieldAccess.getVariable().setStatic(true);\r\n    fieldAccess.setTarget(jdtTreeBuilder.getFactory().Code().createTypeAccess(declaringRef));\r\n    fieldAccess.getVariable().setSimpleName(createQualifiedTypeName(CharOperation.subarray(qualifiedNameReference.tokens, qualifiedNameReference.tokens.length - 1, qualifiedNameReference.tokens.length)));\r\n    return fieldAccess;\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.FutureResult.setStatus",
	"Comment": "indicates if this result is the status of an operation. typically status results will be discarded on conversion.",
	"Method": "void setStatus(boolean status){\r\n    this.status = status;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.test.TestCommands.getValidTestCreatorsForType",
	"Comment": "gets all the valid implementations of testcreatorprovider for a javatype.",
	"Method": "List<TestCreatorProvider> getValidTestCreatorsForType(JavaType type){\r\n    if (this.testCreators.isEmpty()) {\r\n        try {\r\n            ServiceReference<?>[] references = this.context.getAllServiceReferences(TestCreatorProvider.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                TestCreatorProvider testCreatorProvider = (TestCreatorProvider) this.context.getService(ref);\r\n                this.testCreators.add(testCreatorProvider);\r\n            }\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load TestCreatorProvider on TestCommands.\");\r\n            return null;\r\n        }\r\n    }\r\n    List<TestCreatorProvider> validTestCreators = new ArrayList<TestCreatorProvider>();\r\n    for (TestCreatorProvider provider : this.testCreators) {\r\n        if (provider.isValid(type)) {\r\n            validTestCreators.add(provider);\r\n        }\r\n    }\r\n    return validTestCreators;\r\n}"
}, {
	"Path": "spoon.template.Substitution.insertMethod",
	"Comment": "generates a method from a template method by substituting all the\ttemplate parameters by their values.",
	"Method": "CtMethod<T> insertMethod(CtType<?> targetType,Template<?> template,CtMethod<T> sourceMethod){\r\n    CtMethod<T> newMethod = substitute(targetType, template, sourceMethod);\r\n    if (targetType instanceof CtInterface) {\r\n        newMethod.setBody(null);\r\n    }\r\n    targetType.addMethod(newMethod);\r\n    return newMethod;\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.FutureResult.convert",
	"Comment": "converts the given result if a converter is specified, else returns the result",
	"Method": "Object convert(Object result){\r\n    if (result == null) {\r\n        return computeDefaultResult(null);\r\n    }\r\n    return computeDefaultResult(converter.convert(result));\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.RepositoryEntityController.saveAndReturn",
	"Comment": "merges the given incoming object into the given domain object.",
	"Method": "ResponseEntity<ResourceSupport> saveAndReturn(Object domainObject,RepositoryInvoker invoker,HttpMethod httpMethod,PersistentEntityResourceAssembler assembler,boolean returnBody){\r\n    publisher.publishEvent(new BeforeSaveEvent(domainObject));\r\n    Object obj = invoker.invokeSave(domainObject);\r\n    publisher.publishEvent(new AfterSaveEvent(obj));\r\n    PersistentEntityResource resource = assembler.toFullResource(obj);\r\n    HttpHeaders headers = headersPreparer.prepareHeaders(Optional.of(resource));\r\n    if (PUT.equals(httpMethod)) {\r\n        addLocationHeader(headers, assembler, obj);\r\n    }\r\n    if (returnBody) {\r\n        return ControllerUtils.toResponseEntity(HttpStatus.OK, headers, resource);\r\n    } else {\r\n        return ControllerUtils.toEmptyResponse(HttpStatus.NO_CONTENT, headers);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaCustomMetadata.getFindAllByIdsInGlobalSearchMethod",
	"Comment": "method that generates the findallbyidsin method on current interface.",
	"Method": "MethodMetadata getFindAllByIdsInGlobalSearchMethod(){\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    parameterTypes.add(AnnotatedJavaType.convertFromJavaType(JavaType.wrapperOf(JavaType.LIST, identifierType)));\r\n    parameterNames.add(new JavaSymbolName(\"ids\"));\r\n    parameterTypes.add(GLOBAL_SEARCH_PARAMETER);\r\n    parameterNames.add(GOBAL_SEARCH_PARAMETER_NAME);\r\n    parameterTypes.add(PAGEABLE_PARAMETER);\r\n    parameterNames.add(PAGEABLE_PARAMETER_NAME);\r\n    JavaSymbolName methodName = new JavaSymbolName(\"findAllByIdsIn\");\r\n    JavaType returnType = new JavaType(\"org.springframework.data.domain.Page\", 0, DataType.TYPE, null, Arrays.asList(defaultReturnType));\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC + Modifier.ABSTRACT, methodName, returnType, parameterTypes, parameterNames, null);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.pushin.PushInOperationsImpl.getTypeManagementService",
	"Comment": "method to obtain typemanagementservice service implementation",
	"Method": "TypeManagementService getTypeManagementService(){\r\n    return serviceManager.getServiceInstance(this, TypeManagementService.class);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.jsp.tiles.TilesOperationsImpl.getViewsElement",
	"Comment": "returns the root element of the given tiles configuration file",
	"Method": "Element getViewsElement(String viewsDefinitionFile){\r\n    final Document tilesView;\r\n    if (fileManager.exists(viewsDefinitionFile)) {\r\n        final DocumentBuilder builder = XmlUtils.getDocumentBuilder();\r\n        builder.setEntityResolver(new TilesDtdResolver());\r\n        try {\r\n            tilesView = builder.parse(fileManager.getInputStream(viewsDefinitionFile));\r\n        } catch (final SAXException se) {\r\n            throw new IllegalStateException(\"Unable to parse the tiles \" + viewsDefinitionFile + \" file\", se);\r\n        } catch (final IOException ioe) {\r\n            throw new IllegalStateException(\"Unable to read the tiles \" + viewsDefinitionFile + \" file (reason: \" + ioe.getMessage() + \")\", ioe);\r\n        }\r\n    } else {\r\n        tilesView = XmlUtils.getDocumentBuilder().newDocument();\r\n        tilesView.appendChild(tilesView.createElement(\"tiles-definitions\"));\r\n    }\r\n    return tilesView.getDocumentElement();\r\n}"
}, {
	"Path": "spoon.reflect.visitor.filter.LambdaFilter.addImplementingInterface",
	"Comment": "allows to search for lambdas implemented by different interfaces.",
	"Method": "LambdaFilter addImplementingInterface(CtTypeInformation typeInfo){\r\n    if (typeInfo instanceof CtType) {\r\n        if (typeInfo instanceof CtInterface) {\r\n            qualifiedNamesOfInterfaces.add(typeInfo.getQualifiedName());\r\n        }\r\n    } else {\r\n        qualifiedNamesOfInterfaces.add(typeInfo.getQualifiedName());\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.service.addon.ServiceMetadata.getTransactionalDefinedMethods",
	"Comment": "this method returns all defined methods in service interfacethat aren transactional",
	"Method": "List<MethodMetadata> getTransactionalDefinedMethods(){\r\n    return this.transactionalDefinedMethod;\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.alps.AlpsController.descriptor",
	"Comment": "exposes an alps resource to describe an individual repository resource.",
	"Method": "HttpEntity<RootResourceInformation> descriptor(RootResourceInformation information){\r\n    verifyAlpsEnabled();\r\n    return new ResponseEntity<RootResourceInformation>(information, HttpStatus.OK);\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.InteractableVolume.interactBlockWith",
	"Comment": "simulates the interaction the block using the given item as if the playerhad done so.",
	"Method": "boolean interactBlockWith(Vector3i position,ItemStack itemStack,Direction side,GameProfile profile,boolean interactBlockWith,int x,int y,int z,ItemStack itemStack,Direction side,GameProfile profile){\r\n    return interactBlockWith(checkNotNull(position, \"position\").getX(), position.getY(), position.getZ(), itemStack, side, profile);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Collation.normalization",
	"Comment": "set the flag that determines whether to check if text require normalization and to perform normalization.",
	"Method": "Collation normalization(boolean normalization){\r\n    Collation newInstance = copy();\r\n    newInstance.normalization = Optional.of(normalization);\r\n    return newInstance;\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.RepositoryController.listRepositories",
	"Comment": "lists all repositories exported by creating a link list pointing to resources exposing the repositories.",
	"Method": "HttpEntity<RepositoryLinksResource> listRepositories(){\r\n    RepositoryLinksResource resource = new RepositoryLinksResource();\r\n    for (Class<?> domainType : repositories) {\r\n        ResourceMetadata metadata = mappings.getMetadataFor(domainType);\r\n        if (metadata.isExported()) {\r\n            resource.add(entityLinks.linkToCollectionResource(domainType));\r\n        }\r\n    }\r\n    return new ResponseEntity<RepositoryLinksResource>(resource, HttpStatus.OK);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.cache.CacheOperationsImpl.getProjectOperations",
	"Comment": "method to obtain projectoperation service implementation",
	"Method": "ProjectOperations getProjectOperations(){\r\n    if (projectOperations == null) {\r\n        try {\r\n            ServiceReference<?>[] references = context.getAllServiceReferences(ProjectOperations.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                projectOperations = (ProjectOperations) context.getService(ref);\r\n                return projectOperations;\r\n            }\r\n            return null;\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load ProjectOperations on PushInOperationsImpl.\");\r\n            return null;\r\n        }\r\n    } else {\r\n        return projectOperations;\r\n    }\r\n}"
}, {
	"Path": "spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction.isTypeOnTheWay",
	"Comment": "this method provides access to current state of this function.\tit is intended to be called by other mapping functions at query processing time or after query is finished.",
	"Method": "boolean isTypeOnTheWay(){\r\n    return isTypeOnTheWay;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.TextQuery.sortByScore",
	"Comment": "add sorting by text score. will also add text score to returned fields.",
	"Method": "TextQuery sortByScore(){\r\n    this.includeScore();\r\n    this.sortByScore = true;\r\n    return this;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.blockray.BlockRayHit.getLocation",
	"Comment": "returns the location of the hit block, not the intersectionlocation.",
	"Method": "Location<E> getLocation(){\r\n    if (this.location == null) {\r\n        this.location = new Location(this.extent, this.xBlock, this.yBlock, this.zBlock);\r\n    }\r\n    return this.location;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.Extent.getHighestYAt",
	"Comment": "get the y value of the highest block that sunlight can reach in the givencolumn.this method ignores all transparent blocks, providing the highestopaque block.",
	"Method": "int getHighestYAt(int x,int z,int getHighestYAt,Vector2i column){\r\n    return this.getHighestYAt(column.getX(), column.getY());\r\n}"
}, {
	"Path": "org.springframework.roo.addon.javabean.addon.SerializableMetadataTest.assertItdContents",
	"Comment": "asserts that the itd has the expected contents when the governor does ordoes not contain the required members",
	"Method": "void assertItdContents(boolean alreadySerializable,boolean alreadyHasVersionField){\r\n    when(mockClassDetails.implementsType(JdkJavaType.SERIALIZABLE)).thenReturn(alreadySerializable);\r\n    when(mockClassDetails.declaresField(SerializableMetadata.SERIAL_VERSION_FIELD)).thenReturn(alreadyHasVersionField);\r\n    final SerializableMetadata metadata = new SerializableMetadata(METADATA_ID, mockAspectName, mockGovernor);\r\n    final ItdTypeDetails itd = metadata.getItdTypeDetails();\r\n    assertEquals(alreadySerializable ? 0 : 1, itd.getImplementsTypes().size());\r\n    assertEquals(alreadyHasVersionField ? 0 : 1, itd.getDeclaredFields().size());\r\n}"
}, {
	"Path": "org.spongepowered.api.world.World.getChunkAtBlock",
	"Comment": "gets the loaded chunk at the given block coordinate position.",
	"Method": "Optional<Chunk> getChunkAtBlock(Vector3i blockPosition,Optional<Chunk> getChunkAtBlock,int bx,int by,int bz){\r\n    return getChunk(Sponge.getServer().getChunkLayout().forceToChunk(bx, by, bz));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaOperationsImpl.addRepositoryInterface",
	"Comment": "method that generates the repository interface. this method takes in mindif entity is defined as readonly or not.",
	"Method": "void addRepositoryInterface(JavaType interfaceType,JavaType domainType,ClassOrInterfaceTypeDetails entityDetails,String interfaceIdentifier,JavaType defaultReturnType){\r\n    final AnnotationMetadataBuilder interfaceAnnotationMetadata = new AnnotationMetadataBuilder(RooJavaType.ROO_REPOSITORY_JPA);\r\n    interfaceAnnotationMetadata.addAttribute(new ClassAttributeValue(new JavaSymbolName(\"entity\"), domainType));\r\n    if (defaultReturnType != null) {\r\n        interfaceAnnotationMetadata.addAttribute(new ClassAttributeValue(new JavaSymbolName(\"defaultReturnType\"), defaultReturnType));\r\n        getProjectOperations().addModuleDependency(interfaceType.getModule(), defaultReturnType.getModule());\r\n    }\r\n    final String entityMetadataId = JpaEntityMetadata.createIdentifier(entityDetails);\r\n    final JpaEntityMetadata entityMetadata = getMetadataService().get(entityMetadataId);\r\n    if (entityMetadata == null) {\r\n        throw new IllegalArgumentException(\"Can't get information about entity \" + domainType.getSimpleTypeName());\r\n    }\r\n    final String interfaceMdId = PhysicalTypeIdentifier.createIdentifier(interfaceType, getPathResolver().getPath(interfaceIdentifier));\r\n    final ClassOrInterfaceTypeDetailsBuilder cidBuilder = new ClassOrInterfaceTypeDetailsBuilder(interfaceMdId, Modifier.PUBLIC, interfaceType, PhysicalTypeCategory.INTERFACE);\r\n    cidBuilder.addAnnotation(interfaceAnnotationMetadata.build());\r\n    JavaType repositoryType = null;\r\n    if (entityMetadata.isReadOnly()) {\r\n        repositoryType = getReadOnlyRepositoryInteface();\r\n    } else {\r\n        repositoryType = SpringletsJavaType.SPRINGLETS_DETACHABLE_JPA_REPOSITORY;\r\n    }\r\n    cidBuilder.addExtendsTypes(JavaType.wrapperOf(repositoryType, domainType, entityMetadata.getCurrentIndentifierField().getFieldType()));\r\n    cidBuilder.addExtendsTypes(getCustomRepositoryJavaTypeFor(interfaceType));\r\n    getTypeManagementService().createOrUpdateTypeOnDisk(cidBuilder.build());\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.finder.WebFinderOperationsImpl.buildNewSearchController",
	"Comment": "build a new search controller for provided entity, with provided response type,package, path prefix and query methods.",
	"Method": "ClassOrInterfaceTypeDetailsBuilder buildNewSearchController(JavaType entity,List<String> queryMethods,ControllerMVCResponseService responseType,JavaPackage controllerPackage,String pathPrefix){\r\n    ClassOrInterfaceTypeDetailsBuilder controllerBuilder;\r\n    JavaType searchController = new JavaType(String.format(\"%s.%sSearch%sController\", controllerPackage.getFullyQualifiedPackageName(), pluralService.getPlural(entity), responseType.getControllerNameModifier()), controllerPackage.getModule());\r\n    final String physicalPath = PhysicalTypeIdentifier.createIdentifier(searchController, LogicalPath.getInstance(Path.SRC_MAIN_JAVA, controllerPackage.getModule()));\r\n    controllerBuilder = new ClassOrInterfaceTypeDetailsBuilder(physicalPath, Modifier.PUBLIC, searchController, PhysicalTypeCategory.CLASS);\r\n    AnnotationMetadataBuilder controllerAnnotation = new AnnotationMetadataBuilder(RooJavaType.ROO_CONTROLLER);\r\n    controllerAnnotation.addClassAttribute(\"entity\", entity);\r\n    if (StringUtils.isNotBlank(pathPrefix)) {\r\n        controllerAnnotation.addStringAttribute(\"pathPrefix\", pathPrefix);\r\n    }\r\n    controllerAnnotation.addEnumAttribute(\"type\", new EnumDetails(RooJavaType.ROO_ENUM_CONTROLLER_TYPE, new JavaSymbolName(\"SEARCH\")));\r\n    controllerBuilder.addAnnotation(controllerAnnotation.build());\r\n    AnnotationMetadataBuilder searchAnnotation = new AnnotationMetadataBuilder(RooJavaType.ROO_SEARCH);\r\n    List<AnnotationAttributeValue<?>> findersToAdd = new ArrayList<AnnotationAttributeValue<?>>();\r\n    for (String finder : queryMethods) {\r\n        findersToAdd.add(new StringAttributeValue(new JavaSymbolName(\"value\"), finder));\r\n    }\r\n    searchAnnotation.addAttribute(new ArrayAttributeValue<AnnotationAttributeValue<?>>(new JavaSymbolName(\"finders\"), findersToAdd));\r\n    controllerBuilder.addAnnotation(searchAnnotation);\r\n    AnnotationMetadataBuilder responseTypeAnnotation = new AnnotationMetadataBuilder(responseType.getAnnotation());\r\n    controllerBuilder.addAnnotation(responseTypeAnnotation);\r\n    return controllerBuilder;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.jsp.JspOperationsImplTest.assertFolderAndMapping",
	"Comment": "asserts that the given preferred mapping provided by the user gives riseto the expected folder name and mapping to use in the annotation",
	"Method": "void assertFolderAndMapping(String preferredMapping,String expectedFolder,String expectedMapping){\r\n    final JavaType mockController = mock(JavaType.class);\r\n    when(mockController.getSimpleTypeName()).thenReturn(\"FooController\");\r\n    final ImmutablePair<String, String> pair = JspOperationsImpl.getFolderAndMapping(preferredMapping, mockController);\r\n    assertEquals(expectedFolder, pair.getKey());\r\n    assertEquals(expectedMapping, pair.getValue());\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.RepositoryRestConfiguration.setBasePath",
	"Comment": "configures the base path to be used by spring data rest to expose repository resources.",
	"Method": "RepositoryRestConfiguration setBasePath(String basePath){\r\n    Assert.isTrue(!basePath.startsWith(\"http\"), \"Use a path not a URI\");\r\n    basePath = StringUtils.trimTrailingCharacter(basePath, '/');\r\n    this.basePath = URI.create(basePath.startsWith(\"/\") ? basePath : \"/\".concat(basePath));\r\n    Assert.isTrue(!this.basePath.isAbsolute(), \"Absolute URIs are not supported as base path!\");\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.jedis.JedisConnectionFactory.setPassword",
	"Comment": "sets the password used for authenticating with the redis server.",
	"Method": "void setPassword(String password){\r\n    if (RedisConfiguration.isPasswordAware(configuration)) {\r\n        ((WithPassword) configuration).setPassword(password);\r\n        return;\r\n    }\r\n    standaloneConfig.setPassword(RedisPassword.of(password));\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.MutableBlockVolume.setBlockType",
	"Comment": "replace the block at this position by a new type.this will remove any extended block data at the given position.",
	"Method": "boolean setBlockType(Vector3i position,BlockType type,boolean setBlockType,int x,int y,int z,BlockType type){\r\n    return setBlock(x, y, z, type.getDefaultState());\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.components.FieldItem.buildLabel",
	"Comment": "builds the label of the specified field and adds it to the entity label",
	"Method": "String buildLabel(String entityName,String fieldName){\r\n    String entityLabel = XmlUtils.convertId(\"label.\" + entityName.toLowerCase());\r\n    if (fieldName != null && StringUtils.isBlank(fieldName)) {\r\n        return entityLabel;\r\n    }\r\n    return XmlUtils.convertId(entityLabel.concat(\".\").concat(fieldName.toLowerCase()));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.service.addon.ServiceImplMetadata.getFieldFor",
	"Comment": "this method returns field to included on service for a service orrepository",
	"Method": "FieldMetadata getFieldFor(JavaType type){\r\n    final JavaSymbolName fieldName = new JavaSymbolName(StringUtils.uncapitalize(type.getSimpleTypeName()));\r\n    FieldMetadata currentField = governorTypeDetails.getField(fieldName);\r\n    if (currentField != null) {\r\n        Validate.isTrue(currentField.getFieldType().equals(type), \"Field %s already in %s but type not match: expected %s\", currentField.getFieldName(), governorTypeDetails.getType(), type);\r\n        return currentField;\r\n    }\r\n    return new FieldMetadataBuilder(getId(), Modifier.PRIVATE, new ArrayList<AnnotationMetadataBuilder>(), fieldName, type).build();\r\n}"
}, {
	"Path": "org.spongepowered.api.world.Location.sub",
	"Comment": "subtract vector components to the position on this instance, returning anew location instance.",
	"Method": "Location<E> sub(Vector3d v,Location<E> sub,Vector3i v,Location<E> sub,double x,double y,double z){\r\n    return setPosition(getPosition().sub(x, y, z));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.dbre.addon.model.Database.init",
	"Comment": "initializes the model by establishing the relationships between elementsin this model eg. in foreign keys etc.",
	"Method": "void init(){\r\n    final Set<Schema> schemas = new HashSet<Schema>();\r\n    for (final Table table : tables) {\r\n        schemas.add(table.getSchema());\r\n        initializeImportedKeys(table);\r\n        initializeExportedKeys(table);\r\n        initializeIndices(table);\r\n        initializeJoinTable(table);\r\n    }\r\n    multipleSchemas = schemas.size() > 1;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.Coerce.toChar",
	"Comment": "coerce the supplied object to a character, parse it if necessary.",
	"Method": "char toChar(Object obj){\r\n    if (obj == null) {\r\n        return 0;\r\n    }\r\n    if (obj instanceof Character) {\r\n        return (Character) obj;\r\n    }\r\n    try {\r\n        return obj.toString().charAt(0);\r\n    } catch (Exception e) {\r\n    }\r\n    return '';\r\n}"
}, {
	"Path": "spoon.pattern.InlinedStatementConfigurator.byElement",
	"Comment": "marks all ctif and ctforeach whose expression contains element as inline statement.",
	"Method": "InlinedStatementConfigurator byElement(CtElement element){\r\n    CtStatement stmt = element instanceof CtStatement ? (CtStatement) element : element.getParent(CtStatement.class);\r\n    stmt.accept(new CtAbstractVisitor() {\r\n        @Override\r\n        public void visitCtForEach(CtForEach foreach) {\r\n            markAsInlined(foreach);\r\n        }\r\n        @Override\r\n        public void visitCtIf(CtIf ifElement) {\r\n            markAsInlined(ifElement);\r\n        }\r\n    });\r\n    return this;\r\n}"
}, {
	"Path": "spoon.pattern.InlinedStatementConfigurator.byElement",
	"Comment": "marks all ctif and ctforeach whose expression contains element as inline statement.",
	"Method": "InlinedStatementConfigurator byElement(CtElement element){\r\n    markAsInlined(foreach);\r\n}"
}, {
	"Path": "spoon.pattern.InlinedStatementConfigurator.byElement",
	"Comment": "marks all ctif and ctforeach whose expression contains element as inline statement.",
	"Method": "InlinedStatementConfigurator byElement(CtElement element){\r\n    markAsInlined(ifElement);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.convert.AbstractMongoConverter.setCustomConversions",
	"Comment": "registers the given custom conversions with the converter.",
	"Method": "void setCustomConversions(CustomConversions conversions){\r\n    Assert.notNull(conversions, \"Conversions must not be null!\");\r\n    this.conversions = conversions;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.cloud.CloudCommands.setup",
	"Comment": "this method registers a command with the roo shell. it also offers twocommand attributes, a mandatory one and an optional command which has adefault value.",
	"Method": "void setup(CloudProviderId provider,String configuration){\r\n    operations.installProvider(provider, configuration);\r\n}"
}, {
	"Path": "org.spongepowered.api.text.format.TextStyle.propCompose",
	"Comment": "utility method to perform a compose operation between two properties.",
	"Method": "Optional<Boolean> propCompose(Optional<Boolean> prop1,Optional<Boolean> prop2){\r\n    if (!prop1.isPresent()) {\r\n        return prop2;\r\n    } else if (!prop2.isPresent()) {\r\n        return prop1;\r\n    } else if (!prop1.equals(prop2)) {\r\n        return OptBool.ABSENT;\r\n    } else {\r\n        return prop1;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.responses.json.JSONMetadata.getFinderMethodForFinderInService",
	"Comment": "generates a finder method which delegates on entity service to get result",
	"Method": "MethodMetadata getFinderMethodForFinderInService(String finderName,MethodMetadata serviceFinderMethod){\r\n    String pathName = finderName;\r\n    if (pathName.startsWith(\"findBy\")) {\r\n        pathName = pathName.replace(\"findBy\", \"by\");\r\n    }\r\n    final JavaSymbolName methodName = new JavaSymbolName(pathName);\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    final JavaType formBean = serviceFinderMethod.getParameterTypes().get(0).getJavaType();\r\n    List<AnnotationMetadata> formBeanAnnotations = new ArrayList<AnnotationMetadata>();\r\n    AnnotationMetadataBuilder formBeanAnnotation = new AnnotationMetadataBuilder(SpringJavaType.MODEL_ATTRIBUTE);\r\n    formBeanAnnotation.addStringAttribute(\"value\", FORM_BEAN_PARAM_NAME.getSymbolName());\r\n    formBeanAnnotations.add(formBeanAnnotation.build());\r\n    AnnotatedJavaType annotatedFormBean = new AnnotatedJavaType(formBean, formBeanAnnotations);\r\n    parameterTypes.add(annotatedFormBean);\r\n    parameterTypes.add(GLOBAL_SEARCH_PARAM);\r\n    parameterTypes.add(PAGEABLE_PARAM);\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    final List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    final List<String> parameterStrings = new ArrayList<String>();\r\n    parameterNames.add(FORM_BEAN_PARAM_NAME);\r\n    parameterStrings.add(FORM_BEAN_PARAM_NAME.getSymbolName());\r\n    parameterNames.add(GLOBAL_SEARCH_PARAM_NAME);\r\n    parameterStrings.add(GLOBAL_SEARCH_PARAM_NAME.getSymbolName());\r\n    parameterNames.add(PAGEABLE_PARAM_NAME);\r\n    parameterStrings.add(PAGEABLE_PARAM_NAME.getSymbolName());\r\n    final List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n    AnnotationMetadataBuilder getMappingAnnotation = new AnnotationMetadataBuilder(GET_MAPPING);\r\n    getMappingAnnotation.addStringAttribute(\"name\", methodName.getSymbolName());\r\n    getMappingAnnotation.addStringAttribute(\"value\", \"/\" + pathName);\r\n    annotations.add(getMappingAnnotation);\r\n    JavaType serviceReturnType = serviceFinderMethod.getReturnType();\r\n    JavaType datatablesDataReturnType = serviceReturnType.getParameters().isEmpty() ? serviceReturnType.getBaseType() : serviceReturnType.getParameters().get(0);\r\n    JavaType returnType = JavaType.wrapperOf(RESPONSE_ENTITY, JavaType.wrapperOf(SpringJavaType.PAGE, datatablesDataReturnType));\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    final String itemNames = StringUtils.uncapitalize(this.entityPlural);\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"%s %s = %s().%s(%s);\", getNameOfJavaType(serviceReturnType), itemNames, getAccessorMethod(controllerMetadata.getServiceField()).getMethodName(), serviceFinderMethod.getMethodName(), StringUtils.join(parameterStrings, \",\"));\r\n    bodyBuilder.appendFormalLine(String.format(\"return %s.ok(%s);\", getNameOfJavaType(RESPONSE_ENTITY), itemNames));\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, returnType, parameterTypes, parameterNames, bodyBuilder);\r\n    methodBuilder.setAnnotations(annotations);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.finder.WebFinderCommands.getJavaTypeConverter",
	"Comment": "this method obtains javatype converter to be able to obtain javatypefrom strings",
	"Method": "Converter<JavaType> getJavaTypeConverter(){\r\n    if (javaTypeConverter == null) {\r\n        List<Converter> javaTypeConverters = serviceInstaceManager.getServiceInstance(this, Converter.class, new ServiceInstaceManager.Matcher<Converter>() {\r\n            @Override\r\n            public boolean match(Converter service) {\r\n                return service.supports(JavaType.class, \"\");\r\n            }\r\n        });\r\n        if (!javaTypeConverters.isEmpty()) {\r\n            javaTypeConverter = javaTypeConverters.get(0);\r\n        }\r\n        return javaTypeConverter;\r\n    }\r\n    return javaTypeConverter;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.finder.WebFinderCommands.getJavaTypeConverter",
	"Comment": "this method obtains javatype converter to be able to obtain javatypefrom strings",
	"Method": "Converter<JavaType> getJavaTypeConverter(){\r\n    return service.supports(JavaType.class, \"\");\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.components.FieldItem.buildFieldWithoutCamelCase",
	"Comment": "this method builds the fieldname without the camel case style.",
	"Method": "String buildFieldWithoutCamelCase(String fieldName){\r\n    String fieldWithoutCamelCase = \"\";\r\n    String[] camelCase = StringUtils.splitByCharacterTypeCamelCase(fieldName);\r\n    for (String part : camelCase) {\r\n        fieldWithoutCamelCase = fieldWithoutCamelCase.concat(part).concat(\"-\");\r\n    }\r\n    if (fieldWithoutCamelCase.endsWith(\"-\")) {\r\n        fieldWithoutCamelCase = fieldWithoutCamelCase.substring(0, fieldWithoutCamelCase.length() - 1);\r\n    } else {\r\n        fieldWithoutCamelCase = fieldName;\r\n    }\r\n    return fieldWithoutCamelCase;\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.ControllerUtils.toEmptyResponse",
	"Comment": "return an empty response that is only comprised of headers and a status",
	"Method": "ResponseEntity<ResourceSupport> toEmptyResponse(HttpStatus status,ResponseEntity<ResourceSupport> toEmptyResponse,HttpStatus status,HttpHeaders headers){\r\n    return toResponseEntity(status, headers, Optional.empty());\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.JpaCommands.areVersionParamsVisibleForEntityJpa",
	"Comment": "indicator that checks if versionfield param has been specified and makesits associate params visible",
	"Method": "boolean areVersionParamsVisibleForEntityJpa(ShellContext shellContext){\r\n    String versionFieldParam = shellContext.getParameters().get(\"versionField\");\r\n    if (versionFieldParam != null) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.cloud.providers.cloudfoundry.CloudFoundryProvider.setup",
	"Comment": "this method configure your project with cloud foundry maven plugin",
	"Method": "void setup(String pluginConfiguration){\r\n    updatePlugins(pluginConfiguration, projectOperations);\r\n    showInfo(pluginConfiguration);\r\n}"
}, {
	"Path": "spoon.pattern.PatternParameterConfigurator.matchInlinedStatements",
	"Comment": "marks a ctif and ctforeach to be matched, even when inlined.",
	"Method": "PatternParameterConfigurator matchInlinedStatements(){\r\n    InlinedStatementConfigurator sb = new InlinedStatementConfigurator(patternBuilder);\r\n    for (CtElement ctElement : substitutedNodes) {\r\n        sb.byElement(ctElement);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.audit.JpaAuditOperationsImpl.getModifiedByField",
	"Comment": "builds modifiedby field for storing user who last modifies entity registers",
	"Method": "FieldMetadataBuilder getModifiedByField(ClassOrInterfaceTypeDetails entityDetails,String columnName){\r\n    List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n    if (StringUtils.isNotBlank(columnName)) {\r\n        AnnotationMetadataBuilder columnAnnotation = new AnnotationMetadataBuilder(JpaJavaType.COLUMN);\r\n        columnAnnotation.addStringAttribute(\"name\", columnName);\r\n        annotations.add(columnAnnotation);\r\n    }\r\n    AnnotationMetadataBuilder createdDateAnnotation = new AnnotationMetadataBuilder(SpringJavaType.LAST_MODIFIED_BY);\r\n    annotations.add(createdDateAnnotation);\r\n    FieldDetails fieldDetails = new FieldDetails(PhysicalTypeIdentifier.createIdentifier(entityDetails), JavaType.STRING, new JavaSymbolName(\"modifiedBy\"));\r\n    fieldDetails.setModifiers(Modifier.PRIVATE);\r\n    fieldDetails.setAnnotations(annotations);\r\n    FieldMetadataBuilder fieldBuilder = new FieldMetadataBuilder(fieldDetails);\r\n    return fieldBuilder;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getFinderFormMethod",
	"Comment": "this method provides a finder form method using thymeleaf response type",
	"Method": "MethodMetadata getFinderFormMethod(MethodMetadata finderMethod){\r\n    return null;\r\n}"
}, {
	"Path": "spoon.test.api.MetamodelTest.spoonMetaModelTest",
	"Comment": "this test reports all spoon model elements which are not yet handled by meta model\tactually this is the result",
	"Method": "void spoonMetaModelTest(){\r\n    Factory factory = new FactoryImpl(new DefaultCoreFactory(), new StandardEnvironment());\r\n    Metamodel mm = Metamodel.getInstance();\r\n    List<String> problems = new ArrayList();\r\n    Set<CtRole> unhandledRoles = new HashSet(Arrays.asList(CtRole.values()));\r\n    mm.getConcepts().forEach(mmConcept -> {\r\n        mmConcept.getRoleToProperty().forEach((role, mmField) -> {\r\n            unhandledRoles.remove(role);\r\n            if (mmField.getMethod(MMMethodKind.GET) == null) {\r\n                problems.add(\"Missing getter for \" + mmField.getOwner().getName() + \" and CtRole.\" + mmField.getRole());\r\n            }\r\n            if (mmField.getMethod(MMMethodKind.SET) == null) {\r\n                if (new ClassTypingContext(mmConcept.getMetamodelInterface()).isSubtypeOf(factory.Type().createReference(CtReference.class)) == false && \"CtTypeInformation\".equals(mmConcept.getName()) == false) {\r\n                    problems.add(\"Missing setter for \" + mmField.getOwner().getName() + \" and CtRole.\" + mmField.getRole());\r\n                }\r\n            }\r\n            assertFalse(\"Value type of Field \" + mmField.toString() + \" is implicit\", mmField.getTypeOfField().isImplicit());\r\n            assertFalse(\"Item value type of Field \" + mmField.toString() + \" is implicit\", mmField.getTypeofItems().isImplicit());\r\n            mmField.getMethods(MMMethodKind.OTHER).forEach(mmethod -> mmethod.getDeclaredMethods().forEach(ctMethod -> problems.add(\"Unhandled method signature: \" + ctMethod.getDeclaringType().getSimpleName() + \"#\" + ctMethod.getSignature())));\r\n        });\r\n    });\r\n    unhandledRoles.forEach(it -> problems.add(\"Unused CtRole.\" + it.name()));\r\n}"
}, {
	"Path": "org.springframework.cloud.sleuth.instrument.messaging.TracingChannelInterceptor.beforeHandle",
	"Comment": "this starts a consumer span as a child of the incoming message or the current trace\tcontext. it then creates a span for the handler, placing it in scope.",
	"Method": "Message<?> beforeHandle(Message<?> message,MessageChannel channel,MessageHandler handler){\r\n    if (emptyMessage(message)) {\r\n        return message;\r\n    }\r\n    MessageHeaderAccessor headers = mutableHeaderAccessor(message);\r\n    TraceContextOrSamplingFlags extracted = this.extractor.extract(headers);\r\n    Span consumerSpan = this.tracer.nextSpan(extracted);\r\n    if (!consumerSpan.isNoop()) {\r\n        consumerSpan.kind(Span.Kind.CONSUMER).start();\r\n        consumerSpan.remoteServiceName(REMOTE_SERVICE_NAME);\r\n        addTags(message, consumerSpan, channel);\r\n        consumerSpan.finish();\r\n    }\r\n    this.threadLocalSpan.next(TraceContextOrSamplingFlags.create(consumerSpan.context())).name(\"handle\").start();\r\n    MessageHeaderPropagation.removeAnyTraceHeaders(headers, this.tracing.propagation().keys());\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Created a new span in before handle\" + consumerSpan);\r\n    }\r\n    if (message instanceof ErrorMessage) {\r\n        return new ErrorMessage((Throwable) message.getPayload(), headers.getMessageHeaders());\r\n    }\r\n    headers.setImmutable();\r\n    return new GenericMessage(message.getPayload(), headers.getMessageHeaders());\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getCsvExportMethod",
	"Comment": "generates a method to export data to csv using dynamicjasper.",
	"Method": "MethodMetadata getCsvExportMethod(){\r\n    if (jasperReportsMap.get(\"JasperReportsCsvExporter\") != null) {\r\n        final String exporterMethodInvocation = String.format(\"new %s()\", getNameOfJavaType(jasperReportsMap.get(\"JasperReportsCsvExporter\")));\r\n        final String fileName = String.format(\"%s_report.csv\", StringUtils.uncapitalize(this.entityPlural));\r\n        final JavaSymbolName methodName = EXPORT_CSV_METHOD_NAME;\r\n        return buildExportTypeMethod(exporterMethodInvocation, fileName, methodName, \"exportCsv\", \"/export/csv\", \"CSV\");\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "spoon.reflect.factory.CodeFactory.createVariableAssignments",
	"Comment": "creates a list of statements that contains the assignments of a set of\tvariables.",
	"Method": "CtStatementList createVariableAssignments(List<? extends CtVariable<T>> variables,List<? extends CtExpression<T>> expressions){\r\n    CtStatementList result = factory.Core().createStatementList();\r\n    for (int i = 0; i < variables.size(); i++) {\r\n        result.addStatement(createVariableAssignment(variables.get(i).getReference(), variables.get(i).getModifiers().contains(ModifierKind.STATIC), expressions.get(i)));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.spongepowered.api.text.format.TextStyle.isBold",
	"Comment": "checks for whether text where this style is applied is bolded.",
	"Method": "Optional<Boolean> isBold(){\r\n    return this.bold;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.embedded.AbstractEmbeddedProvider.getTitle",
	"Comment": "convenience method to create a readable title for a embeddedcompletorenum value",
	"Method": "String getTitle(String providerName){\r\n    final String[] names = providerName.split(\"_\");\r\n    final StringBuilder sb = new StringBuilder();\r\n    for (final String name : names) {\r\n        sb.append(StringUtils.capitalize(name.toLowerCase()));\r\n        sb.append(\" \");\r\n    }\r\n    return sb.toString().trim();\r\n}"
}, {
	"Path": "org.spongepowered.api.world.World.getChunk",
	"Comment": "gets the loaded chunk at the given chunk coordinate position.in vanilla, the y coordinate will always be 0.",
	"Method": "Optional<Chunk> getChunk(Vector3i chunkPosition,Optional<Chunk> getChunk,int cx,int cy,int cz){\r\n    return getChunk(chunkPosition.getX(), chunkPosition.getY(), chunkPosition.getZ());\r\n}"
}, {
	"Path": "spoon.reflect.factory.ExecutableFactory.createParameterReference",
	"Comment": "creates a parameter reference from an existing parameter.",
	"Method": "CtParameterReference<T> createParameterReference(CtParameter<T> parameter){\r\n    CtParameterReference<T> ref = factory.Core().createParameterReference();\r\n    ref.setSimpleName(parameter.getSimpleName());\r\n    ref.setType(parameter.getType());\r\n    return ref;\r\n}"
}, {
	"Path": "spoon.reflect.factory.PackageFactory.createReference",
	"Comment": "creates a reference to a package. the given name has to be a fully qualified name.",
	"Method": "CtPackageReference createReference(CtPackage pack,CtPackageReference createReference,Package pack,CtPackageReference createReference,String name){\r\n    CtPackageReference ref = factory.Core().createPackageReference();\r\n    ref.setSimpleName(name);\r\n    return ref;\r\n}"
}, {
	"Path": "spoon.support.template.Parameters.getAllTemplateParameterFields",
	"Comment": "returns all the runtime fields of a template representing a template parameter",
	"Method": "List<Field> getAllTemplateParameterFields(Class<? extends Template> clazz,List<CtField<?>> getAllTemplateParameterFields,Class<? extends Template<?>> clazz,Factory factory){\r\n    CtClass<?> c = factory.Class().get(clazz);\r\n    if (c == null) {\r\n        throw new IllegalArgumentException(\"Template not in template classpath\");\r\n    }\r\n    List<CtField<?>> result = new ArrayList();\r\n    for (Field f : getAllTemplateParameterFields(clazz)) {\r\n        result.add(c.getField(f.getName()));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.identifier.IdentifierMetadata.getParameterizedConstructor",
	"Comment": "locates the parameterised constructor consisting of the id fields forthis class.",
	"Method": "ConstructorMetadataBuilder getParameterizedConstructor(List<FieldMetadataBuilder> fields){\r\n    final List<JavaType> parameterTypes = new ArrayList<JavaType>();\r\n    for (final FieldMetadataBuilder field : fields) {\r\n        parameterTypes.add(field.getFieldType());\r\n    }\r\n    final ConstructorMetadata result = governorTypeDetails.getDeclaredConstructor(parameterTypes);\r\n    if (result != null) {\r\n        publicNoArgConstructor = true;\r\n        return null;\r\n    }\r\n    final List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    bodyBuilder.appendFormalLine(\"super();\");\r\n    for (final FieldMetadataBuilder field : fields) {\r\n        final String fieldName = field.getFieldName().getSymbolName();\r\n        bodyBuilder.appendFormalLine(\"this.\" + fieldName + \" = \" + fieldName + \";\");\r\n        parameterNames.add(field.getFieldName());\r\n    }\r\n    final ConstructorMetadataBuilder constructorBuilder = new ConstructorMetadataBuilder(getId());\r\n    constructorBuilder.setModifier(Modifier.PUBLIC);\r\n    constructorBuilder.setParameterTypes(AnnotatedJavaType.convertFromJavaTypes(parameterTypes));\r\n    constructorBuilder.setParameterNames(parameterNames);\r\n    constructorBuilder.setBodyBuilder(bodyBuilder);\r\n    return constructorBuilder;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaCustomImplAnnotationValues.getRepository",
	"Comment": "returns the repository type implemented by the annotated class",
	"Method": "JavaType getRepository(){\r\n    return repository;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.jsp.JspOperationsImpl.registerStaticSpringMvcController",
	"Comment": "registers a static spring mvc controller to handle the given relativeurl.",
	"Method": "void registerStaticSpringMvcController(String relativeUrl,LogicalPath webappPath){\r\n    final String mvcConfig = getProjectOperations().getPathResolver().getIdentifier(webappPath, \"WEB-INF/spring/webmvc-config.xml\");\r\n    if (fileManager.exists(mvcConfig)) {\r\n        final Document document = XmlUtils.readXml(fileManager.getInputStream(mvcConfig));\r\n        final String prefixedUrl = \"/\" + relativeUrl;\r\n        if (XmlUtils.findFirstElement(\"/beans/view-controller[@path='\" + prefixedUrl + \"']\", document.getDocumentElement()) == null) {\r\n            final Element sibling = XmlUtils.findFirstElement(\"/beans/view-controller\", document.getDocumentElement());\r\n            final Element view = new XmlElementBuilder(\"mvc:view-controller\", document).addAttribute(\"path\", prefixedUrl).build();\r\n            if (sibling != null) {\r\n                sibling.getParentNode().insertBefore(view, sibling);\r\n            } else {\r\n                document.getDocumentElement().appendChild(view);\r\n            }\r\n            fileManager.createOrUpdateTextFileIfRequired(mvcConfig, XmlUtils.nodeToString(document), false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.index.IndexingIntegrationTests.hasIndex",
	"Comment": "returns whether an index with the given name exists for the given entity type.",
	"Method": "boolean hasIndex(String indexName,Class<?> entityType){\r\n    return operations.execute(entityType, new CollectionCallback<Boolean>() {\r\n        public Boolean doInCollection(MongoCollection<org.bson.Document> collection) throws MongoException, DataAccessException {\r\n            List<org.bson.Document> indexes = new ArrayList<org.bson.Document>();\r\n            collection.listIndexes(org.bson.Document.class).into(indexes);\r\n            for (org.bson.Document indexInfo : indexes) {\r\n                if (indexName.equals(indexInfo.get(\"name\"))) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.index.IndexingIntegrationTests.hasIndex",
	"Comment": "returns whether an index with the given name exists for the given entity type.",
	"Method": "boolean hasIndex(String indexName,Class<?> entityType){\r\n    List<org.bson.Document> indexes = new ArrayList<org.bson.Document>();\r\n    collection.listIndexes(org.bson.Document.class).into(indexes);\r\n    for (org.bson.Document indexInfo : indexes) {\r\n        if (indexName.equals(indexInfo.get(\"name\"))) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.convert.UpdateMapper.delegateConvertToMongoType",
	"Comment": "converts the given source object to a mongo type retaining the original type information of the source type on the\tmongo type.",
	"Method": "Object delegateConvertToMongoType(Object source,MongoPersistentEntity<?> entity){\r\n    return converter.convertToMongoType(source, entity == null ? ClassTypeInformation.OBJECT : getTypeHintForEntity(source, entity));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getFinderDatatablesMethodForFinderInService",
	"Comment": "generates a finder method which delegates on entity service to get result",
	"Method": "MethodMetadata getFinderDatatablesMethodForFinderInService(String finderName,MethodMetadata serviceFinderMethod){\r\n    String pathName = finderName;\r\n    if (pathName.startsWith(\"findBy\")) {\r\n        pathName = pathName.replace(\"findBy\", \"by\");\r\n    }\r\n    final JavaSymbolName methodName = new JavaSymbolName(pathName.concat(\"Dt\"));\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    final JavaType formBean = serviceFinderMethod.getParameterTypes().get(0).getJavaType();\r\n    List<AnnotationMetadata> formBeanAnnotations = new ArrayList<AnnotationMetadata>();\r\n    AnnotationMetadataBuilder formBeanAnnotation = new AnnotationMetadataBuilder(SpringJavaType.MODEL_ATTRIBUTE);\r\n    formBeanAnnotation.addStringAttribute(\"value\", FORM_BEAN_PARAM_NAME.getSymbolName());\r\n    formBeanAnnotations.add(formBeanAnnotation.build());\r\n    AnnotatedJavaType annotatedFormBean = new AnnotatedJavaType(formBean, formBeanAnnotations);\r\n    parameterTypes.add(annotatedFormBean);\r\n    parameterTypes.add(DATATABLES_COLUMNS_PARAM);\r\n    parameterTypes.add(GLOBAL_SEARCH_PARAM);\r\n    parameterTypes.add(DATATABLES_PAGEABLE_PARAM);\r\n    List<AnnotationMetadata> drawAnnotations = new ArrayList<AnnotationMetadata>();\r\n    AnnotationMetadataBuilder drawAnnotation = new AnnotationMetadataBuilder(SpringJavaType.REQUEST_PARAM);\r\n    drawAnnotation.addEnumAttribute(\"value\", SpringletsJavaType.SPRINGLETS_DATATABLES, \"PARAMETER_DRAW\");\r\n    drawAnnotations.add(drawAnnotation.build());\r\n    AnnotatedJavaType annotatedDraw = new AnnotatedJavaType(JavaType.INT_OBJECT, drawAnnotations);\r\n    parameterTypes.add(annotatedDraw);\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    final List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    final List<String> parameterStrings = new ArrayList<String>();\r\n    parameterNames.add(FORM_BEAN_PARAM_NAME);\r\n    parameterStrings.add(FORM_BEAN_PARAM_NAME.getSymbolName());\r\n    parameterNames.add(DATATABLES_COLUMNS_PARAM_NAME);\r\n    parameterNames.add(GLOBAL_SEARCH_PARAM_NAME);\r\n    parameterStrings.add(GLOBAL_SEARCH_PARAM_NAME.getSymbolName());\r\n    parameterNames.add(DATATABLES_PAGEABLE_PARAM_NAME);\r\n    parameterStrings.add(DATATABLES_PAGEABLE_PARAM_NAME.getSymbolName());\r\n    parameterNames.add(DRAW_PARAM_NAME);\r\n    final List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n    AnnotationMetadataBuilder getMappingAnnotation = new AnnotationMetadataBuilder(GET_MAPPING);\r\n    getMappingAnnotation.addStringAttribute(\"name\", methodName.getSymbolName());\r\n    getMappingAnnotation.addStringAttribute(\"value\", \"/\" + pathName + \"/dt\");\r\n    getMappingAnnotation.addEnumAttribute(\"produces\", SPRINGLETS_DATATABLES, \"MEDIA_TYPE\");\r\n    annotations.add(getMappingAnnotation);\r\n    this.mvcMethodNames.put(methodName.getSymbolName(), methodName.getSymbolName());\r\n    annotations.add(RESPONSE_BODY_ANNOTATION);\r\n    JavaType serviceReturnType = serviceFinderMethod.getReturnType();\r\n    JavaType datatablesDataReturnType = serviceReturnType.getParameters().isEmpty() ? serviceReturnType.getBaseType() : serviceReturnType.getParameters().get(0);\r\n    JavaType returnType = JavaType.wrapperOf(RESPONSE_ENTITY, JavaType.wrapperOf(SpringletsJavaType.SPRINGLETS_CONVERTED_DATATABLES_DATA, datatablesDataReturnType));\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    final String itemNames = StringUtils.uncapitalize(this.entityPlural);\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"%s %s = %s().%s(%s);\", getNameOfJavaType(serviceReturnType), itemNames, getAccessorMethod(controllerMetadata.getServiceField()).getMethodName(), serviceFinderMethod.getMethodName(), StringUtils.join(parameterStrings, \",\"));\r\n    String totalItemNamesCount = String.format(\"total%sCount\", StringUtils.capitalize(itemNames));\r\n    bodyBuilder.appendFormalLine(String.format(\"long %s = %s.getTotalElements();\", totalItemNamesCount, itemNames));\r\n    bodyBuilder.appendFormalLine(String.format(\"if (%s != null && %s.isNotBlank(%s.getText())) {\", GLOBAL_SEARCH_PARAM_NAME, getNameOfJavaType(STRING_UTILS_APACHE), GLOBAL_SEARCH_PARAM_NAME));\r\n    MethodMetadata countMethod = null;\r\n    Map<JavaSymbolName, MethodMetadata> repositoryCustomFindersAndCounts = serviceMetadata.getRepositoryCustomFindersAndCounts();\r\n    for (Entry<JavaSymbolName, MethodMetadata> entry : repositoryCustomFindersAndCounts.entrySet()) {\r\n        if (entry.getKey().getSymbolName().equals(finderName)) {\r\n            countMethod = entry.getValue();\r\n        }\r\n    }\r\n    Validate.notNull(countMethod, String.format(\"ERROR: Is not possible to obtain the count method related with finder '%s'. Please, \" + \"generate the count method before continue publishing this finder to the web layer.\", finderName));\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(String.format(\"%s = %s().%s(%s);\", totalItemNamesCount, getAccessorMethod(controllerMetadata.getServiceField()).getMethodName(), countMethod.getMethodName(), FORM_BEAN_PARAM_NAME));\r\n    bodyBuilder.indentRemove();\r\n    bodyBuilder.appendFormalLine(\"}\");\r\n    bodyBuilder.appendFormalLine(String.format(\"%s<%s> datatablesData = new ConvertedDatatablesData<%s>(%s, %s, %s, %s(), %s);\", getNameOfJavaType(SpringletsJavaType.SPRINGLETS_CONVERTED_DATATABLES_DATA), getNameOfJavaType(datatablesDataReturnType), getNameOfJavaType(datatablesDataReturnType), itemNames, totalItemNamesCount, DRAW_PARAM_NAME, getAccessorMethod(this.conversionServiceField).getMethodName(), DATATABLES_COLUMNS_PARAM_NAME));\r\n    bodyBuilder.appendFormalLine(String.format(\"return %s.ok(datatablesData);\", getNameOfJavaType(RESPONSE_ENTITY)));\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, returnType, parameterTypes, parameterNames, bodyBuilder);\r\n    methodBuilder.setAnnotations(annotations);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaCustomMetadata.getReferencedFieldsFindAllMethods",
	"Comment": "this method returns all findall methods forreferenced fields",
	"Method": "Map<FieldMetadata, MethodMetadata> getReferencedFieldsFindAllMethods(){\r\n    return referencedFieldsFindAllMethods;\r\n}"
}, {
	"Path": "spoon.IncrementalLauncher.changesPresent",
	"Comment": "returns true, if any source code changes after previous build are present, and false otherwise.",
	"Method": "boolean changesPresent(){\r\n    return mChangesPresent;\r\n}"
}, {
	"Path": "spoon.reflect.visitor.ImportScannerImpl.declaringTypeIsLocalOrImported",
	"Comment": "this method is used to check if the declaring type has been already imported, or if it is local\tin both case we do not want to import it, even in fqn mode.",
	"Method": "boolean declaringTypeIsLocalOrImported(CtTypeReference declaringType){\r\n    if (declaringType != null) {\r\n        boolean isInCollision = isTypeInCollision(declaringType, false);\r\n        if (!isInCollision) {\r\n            boolean importSuccess = addClassImport(declaringType);\r\n            if (importSuccess) {\r\n                return true;\r\n            }\r\n        }\r\n        boolean importedInClassImports = isImportedInClassImports(declaringType);\r\n        boolean inJavaLang = classNamePresentInJavaLang(declaringType);\r\n        if (importedInClassImports || inJavaLang) {\r\n            return true;\r\n        }\r\n        while (declaringType != null) {\r\n            if (declaringType.equals(targetType)) {\r\n                return true;\r\n            }\r\n            declaringType = declaringType.getDeclaringType();\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerMetadataProviderImpl.getControllerDetailInfo",
	"Comment": "get necessary information about detail to create a detail controller",
	"Method": "List<RelationInfo> getControllerDetailInfo(PhysicalTypeMetadata governorPhysicalTypeMetadata,JpaEntityMetadata entityMetadata,String relationField,JavaType controller){\r\n    String[] relationPath = StringUtils.split(relationField, '.');\r\n    final List<RelationInfo> info = new ArrayList<JpaEntityMetadata.RelationInfo>();\r\n    RelationInfo curInfo;\r\n    JpaEntityMetadata curEntity = entityMetadata;\r\n    for (String relName : relationPath) {\r\n        curInfo = null;\r\n        if (curEntity.getRelationInfos() != null) {\r\n            curInfo = curEntity.getRelationInfos().get(relName);\r\n        }\r\n        Validate.notNull(curEntity.getRelationInfos(), \"ERROR: In %s controller, @RooDetail: Invalid value '%s': Can't get relation information about '%s' on %s entity\", controller, relationField, relName, curEntity.getDestination());\r\n        Validate.isTrue(curInfo.cardinality == Cardinality.ONE_TO_MANY || curInfo.cardinality == Cardinality.MANY_TO_MANY, \"ERROR: In %s controller, @RooDetail '%s' [%s] has unsupported type (%s) on '%s' entity: should be ONE_TO_MANY or MANY_TO_MANY\", controller, relName, relationField, curInfo.cardinality.name(), curEntity.getDestination());\r\n        info.add(curInfo);\r\n    }\r\n    return info;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform3.of",
	"Comment": "returns a new transform from the given transformation matrix, if theresulting transform would be discrete.",
	"Method": "Optional<DiscreteTransform3> of(Matrix4d matrix){\r\n    if (Arrays.stream(matrix.toArray()).anyMatch(value -> Math.rint(value) != value)) {\r\n        return Optional.empty();\r\n    }\r\n    return Optional.of(new DiscreteTransform3(matrix));\r\n}"
}, {
	"Path": "com.oreilly.springdata.gemfire.core.GemfireCustomerRepository.findAll",
	"Comment": "returns all objects in the region. not advisable for very large data sets.",
	"Method": "List<Customer> findAll(){\r\n    return new ArrayList<Customer>((Collection<? extends Customer>) template.getRegion().values());\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.ViewCommands.getControllerMVCResponseTypes",
	"Comment": "this method gets all implementations of controllermvcresponseservice interface to be ableto locate all controllermvcresponseservice. uses param installed to obtain only the installedor not installed response types.",
	"Method": "Map<String, ControllerMVCResponseService> getControllerMVCResponseTypes(boolean installed){\r\n    Map<String, ControllerMVCResponseService> responseTypes = new HashMap<String, ControllerMVCResponseService>();\r\n    try {\r\n        ServiceReference<?>[] references = this.context.getAllServiceReferences(ControllerMVCResponseService.class.getName(), null);\r\n        for (ServiceReference<?> ref : references) {\r\n            ControllerMVCResponseService responseTypeService = (ControllerMVCResponseService) this.context.getService(ref);\r\n            boolean isAbleToInstall = false;\r\n            for (Pom module : getProjectOperations().getPoms()) {\r\n                if (responseTypeService.isInstalledInModule(module.getModuleName()) == installed) {\r\n                    isAbleToInstall = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (isAbleToInstall) {\r\n                responseTypes.put(responseTypeService.getResponseType(), responseTypeService);\r\n            }\r\n        }\r\n        return responseTypes;\r\n    } catch (InvalidSyntaxException e) {\r\n        LOGGER.warning(\"Cannot load ControllerMVCResponseService on ViewCommands.\");\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.sf.jabref.collab.ChangeScanner.bestFit",
	"Comment": "finds the entry in neu best fitting the specified entry in old. if no entries get a scoreabove zero, an entry is still returned.",
	"Method": "BibtexEntry bestFit(EntrySorter old,EntrySorter neu,int index){\r\n    double comp = -1;\r\n    int found = 0;\r\n    loop: for (int i = 0; i < neu.getEntryCount(); i++) {\r\n        double res = Util.compareEntriesStrictly(old.getEntryAt(index), neu.getEntryAt(i));\r\n        if (res > comp) {\r\n            comp = res;\r\n            found = i;\r\n        }\r\n        if (comp > 1)\r\n            break loop;\r\n    }\r\n    return neu.getEntryAt(found);\r\n}"
}, {
	"Path": "org.springframework.data.redis.core.ReactiveStreamOperations.add",
	"Comment": "append the record, backed by the given value, to the stream. the value will be hashed and serialized.",
	"Method": "Flux<RecordId> add(K key,Publisher<? extends Map<? extends HK, ? extends HV>> bodyPublisher,Mono<RecordId> add,K key,Map<? extends HK, ? extends HV> content,Mono<RecordId> add,MapRecord<K, ? extends HK, ? extends HV> record,Mono<RecordId> add,Record<K, ?> record){\r\n    return add((Record) record);\r\n}"
}, {
	"Path": "org.spongepowered.api.text.transform.TextFormatter.forEachAfter",
	"Comment": "applies the specified consumer to each element of the specified typeafter the specified index.",
	"Method": "void forEachAfter(int index,Class<T> clazz,Consumer<T> consumer){\r\n    checkNotNull(clazz, \"class\");\r\n    for (int i = index; i < size(); i++) {\r\n        E e = get(i);\r\n        if (clazz.isAssignableFrom(e.getClass())) {\r\n            consumer.accept((T) e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel",
	"Comment": "get the units from the given source folder and build the spoon model.",
	"Method": "boolean buildUnitsAndModel(JDTBuilder jdtBuilder,SpoonFolder sourcesFolder,String[] classpath,String debugMessagePrefix){\r\n    CompilationUnitDeclaration[] units = buildUnits(jdtBuilder, sourcesFolder, classpath, debugMessagePrefix);\r\n    buildModel(units);\r\n    return probs.isEmpty();\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.json.patch.Patch.apply",
	"Comment": "applies the patch to a given list of objects. makes a copy of the given list so that it will remain unchanged after\tapplication of the patch and in case any errors occur while performing the patch.",
	"Method": "T apply(T in,Class<T> type,List<T> apply,List<T> in,Class<T> type){\r\n    for (PatchOperation operation : operations) {\r\n        operation.perform(in, type);\r\n    }\r\n    return in;\r\n}"
}, {
	"Path": "spoon.reflect.factory.ExecutableFactory.createReference",
	"Comment": "creates an executable reference from an existing executable.",
	"Method": "CtExecutableReference<T> createReference(CtExecutable<T> e,CtExecutableReference<T> createReference,CtTypeReference<?> declaringType,CtTypeReference<T> type,String methodName,CtTypeReference<?> parameterTypes,CtExecutableReference<T> createReference,CtTypeReference<?> declaringType,boolean isStatic,CtTypeReference<T> type,String methodName,CtTypeReference<?> parameterTypes,CtExecutableReference<T> createReference,CtTypeReference<?> declaringType,boolean isStatic,CtTypeReference<T> type,String methodName,List<CtTypeReference<?>> parameterTypes,CtExecutableReference<T> createReference,CtTypeReference<?> declaringType,CtTypeReference<T> type,String methodName,List<CtTypeReference<?>> parameterTypes,CtExecutableReference<T> createReference,String signature){\r\n    CtExecutableReference<T> executableRef = factory.Core().createExecutableReference();\r\n    String type = signature.substring(0, signature.indexOf(' '));\r\n    String declaringType = signature.substring(signature.indexOf(' ') + 1, signature.indexOf(CtExecutable.EXECUTABLE_SEPARATOR));\r\n    String executableName = signature.substring(signature.indexOf(CtExecutable.EXECUTABLE_SEPARATOR) + 1, signature.indexOf('('));\r\n    executableRef.setSimpleName(executableName);\r\n    executableRef.setDeclaringType(factory.Type().createReference(declaringType));\r\n    CtTypeReference<T> typeRef = factory.Type().createReference(type);\r\n    executableRef.setType(typeRef);\r\n    String parameters = signature.substring(signature.indexOf('(') + 1, signature.indexOf(')'));\r\n    List<CtTypeReference<?>> params = new ArrayList(PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\r\n    StringTokenizer t = new StringTokenizer(parameters, \",\");\r\n    while (t.hasMoreTokens()) {\r\n        String paramType = t.nextToken();\r\n        params.add(factory.Type().createReference(paramType));\r\n    }\r\n    executableRef.setParameters(params);\r\n    return executableRef;\r\n}"
}, {
	"Path": "org.elasticsearch.tasks.TaskManager.waitForTaskCompletion",
	"Comment": "blocks the calling thread, waiting for the task to vanish from the taskmanager.",
	"Method": "void waitForTaskCompletion(Task task,long untilInNanos){\r\n    while (System.nanoTime() - untilInNanos < 0) {\r\n        if (getTask(task.getId()) == null) {\r\n            return;\r\n        }\r\n        try {\r\n            Thread.sleep(WAIT_FOR_COMPLETION_POLL.millis());\r\n        } catch (InterruptedException e) {\r\n            throw new ElasticsearchException(\"Interrupted waiting for completion of [{}]\", e, task);\r\n        }\r\n    }\r\n    throw new ElasticsearchTimeoutException(\"Timed out waiting for completion of [{}]\", task);\r\n}"
}, {
	"Path": "org.spongepowered.api.util.ban.Ban.isIndefinite",
	"Comment": "gets whether this ban is indefinitely long, e.g. has no expiration date.",
	"Method": "boolean isIndefinite(){\r\n    return !this.getExpirationDate().isPresent();\r\n}"
}, {
	"Path": "spoon.compiler.builder.SourceOptions.sources",
	"Comment": "adds the given paths as concatenated string with file.pathseparator as sources",
	"Method": "T sources(String sources,T sources,String sources,T sources,List<SpoonFile> sources){\r\n    if (sources == null || sources.isEmpty()) {\r\n        args.add(\".\");\r\n        return myself;\r\n    }\r\n    for (SpoonFile source : sources) {\r\n        if (source.isActualFile()) {\r\n            args.add(source.toString());\r\n        } else {\r\n            try {\r\n                File file = File.createTempFile(source.getName(), \".java\");\r\n                file.deleteOnExit();\r\n                IOUtils.copy(source.getContent(), new FileOutputStream(file));\r\n                args.add(file.toString());\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(e.getMessage(), e);\r\n            }\r\n        }\r\n    }\r\n    return myself;\r\n}"
}, {
	"Path": "org.elasticsearch.tasks.TaskManager.removeBan",
	"Comment": "removes the ban for the specified parent task.this method is called when a previously banned task finally cancelled",
	"Method": "void removeBan(TaskId parentTaskId){\r\n    logger.trace(\"removing ban for the parent task {}\", parentTaskId);\r\n    banedParents.remove(parentTaskId);\r\n}"
}, {
	"Path": "spoon.processing.AbstractProcessor.initProperties",
	"Comment": "helper method to initialize the properties of a given processor.",
	"Method": "void initProperties(ProcessorProperties properties){\r\n    ProcessorUtils.initProperties(this, properties);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.test.RepositoryJpaIntegrationTestMetadata.getFindAllCustomNotFilteredNotPagedTestMethod",
	"Comment": "builds a method to test the find all custom method not filtered and not paged.",
	"Method": "MethodMetadata getFindAllCustomNotFilteredNotPagedTestMethod(){\r\n    JavaSymbolName methodName = new JavaSymbolName(String.format(\"findAllCustomNotFilteredNotPagedShouldReturnAll%s\", this.entityPlural));\r\n    MethodMetadata method = getGovernorMethod(methodName);\r\n    if (method != null) {\r\n        return method;\r\n    }\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    bodyBuilder.appendFormalLine(\"// Exercise\");\r\n    bodyBuilder.appendFormalLine(\"%s<%s> all = %s().findAll((%s) null, new %s(0, %s().getSize()));\", getNameOfJavaType(SpringJavaType.PAGE), getNameOfJavaType(this.defaultReturnType), getAccessorMethod(this.repositoryField).getMethodName(), getNameOfJavaType(SpringletsJavaType.SPRINGLETS_GLOBAL_SEARCH), getNameOfJavaType(SpringJavaType.PAGE_REQUEST), getAccessorMethod(this.dodField).getMethodName());\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"// Verify\");\r\n    bodyBuilder.appendFormalLine(\"%s(all.getNumberOfElements())\", getNameOfJavaType(ASSERT_THAT));\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\".as(\\\"Check 'findAll' with null '%s' and no pagination returns all entries\\\")\", getNameOfJavaType(SpringletsJavaType.SPRINGLETS_GLOBAL_SEARCH));\r\n    bodyBuilder.appendFormalLine(\".isEqualTo(%s().getSize());\", getAccessorMethod(this.dodField).getMethodName());\r\n    bodyBuilder.reset();\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, JavaType.VOID_PRIMITIVE, bodyBuilder);\r\n    methodBuilder.addAnnotation(new AnnotationMetadataBuilder(TEST));\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.field.addon.FieldCommands.getFieldCreatorAvailable",
	"Comment": "checks all fieldcreator implementations looking for any available",
	"Method": "boolean getFieldCreatorAvailable(){\r\n    if (fieldCreatorProviders.isEmpty()) {\r\n        try {\r\n            ServiceReference<?>[] references = this.context.getAllServiceReferences(FieldCreatorProvider.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                FieldCreatorProvider fieldCreatorProvider = (FieldCreatorProvider) this.context.getService(ref);\r\n                fieldCreatorProviders.add(fieldCreatorProvider);\r\n            }\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load FieldCreatorProvider on FieldCommands.\");\r\n            return false;\r\n        }\r\n    }\r\n    for (FieldCreatorProvider provider : fieldCreatorProviders) {\r\n        if (provider.isFieldManagementAvailable()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "spoon.reflect.visitor.CtIterator.scan",
	"Comment": "prevent scanner from going down the tree, instead save with other ctelement children of the current node",
	"Method": "void scan(CtElement element){\r\n    if (element != null) {\r\n        current_children.addFirst(element);\r\n    }\r\n}"
}, {
	"Path": "spoon.refactoring.CtParameterRemoveRefactoring.createParameterUsedIssue",
	"Comment": "override this method to get access to details about this refactoring issue",
	"Method": "void createParameterUsedIssue(CtParameter<?> usedParameter,CtParameterReference<?> parameterUsage){\r\n    throw new RefactoringException(\"The parameter \" + usedParameter.getSimpleName() + \" cannot be removed because it is used (\" + parameterUsage.getPosition() + \")\");\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.InteractableVolume.digBlockWith",
	"Comment": "simulate the digging of the block with the given tool as if a player haddone so.",
	"Method": "boolean digBlockWith(Vector3i position,ItemStack itemStack,GameProfile profile,boolean digBlockWith,int x,int y,int z,ItemStack itemStack,GameProfile profile){\r\n    return digBlockWith(checkNotNull(position, \"position\").getX(), position.getY(), position.getZ(), itemStack, profile);\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.ProfileController.getPath",
	"Comment": "return the href for the profile link of a given baseuri and domain type mapping.",
	"Method": "String getPath(RepositoryRestConfiguration configuration,ResourceMapping mapping){\r\n    String path = getRootPath(configuration);\r\n    return mapping == null ? path : path + mapping.getPath();\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.jedis.JedisConnectionFactory.getPassword",
	"Comment": "returns the password used for authenticating with the redis server.",
	"Method": "String getPassword(){\r\n    return getRedisPassword().map(String::new).orElse(null);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.service.addon.ServiceImplMetadata.removeMethodFromPendingList",
	"Comment": "removes metadatatoremove from listcompares, method name, number params and params types to decide it methodmatch and should be removed from list.",
	"Method": "void removeMethodFromPendingList(List<MethodMetadata> list,MethodMetadata metadataToRemove){\r\n    final Iterator<MethodMetadata> iter = list.iterator();\r\n    MethodMetadata current;\r\n    boolean matchTypes;\r\n    while (iter.hasNext()) {\r\n        current = iter.next();\r\n        matchTypes = true;\r\n        if (!current.getMethodName().equals(metadataToRemove.getMethodName())) {\r\n            continue;\r\n        }\r\n        if (current.getParameterTypes().size() != metadataToRemove.getParameterTypes().size()) {\r\n            continue;\r\n        }\r\n        for (int i = 0; i < current.getParameterTypes().size(); i++) {\r\n            if (!current.getParameterTypes().get(i).equals(metadataToRemove.getParameterTypes().get(i))) {\r\n                matchTypes = false;\r\n                break;\r\n            }\r\n        }\r\n        if (matchTypes) {\r\n            iter.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sat4j.minisat.core.Solver.forget",
	"Comment": "forget a variable in the formula by falsifying both its positive and\tnegative literals.",
	"Method": "Constr forget(int var){\r\n    boolean satisfied = this.voc.isSatisfied(toInternal(var));\r\n    this.voc.forgets(var);\r\n    Constr confl;\r\n    if (satisfied) {\r\n        confl = reduceClausesForFalsifiedLiteral(LiteralsUtils.toInternal(-var));\r\n    } else {\r\n        confl = reduceClausesForFalsifiedLiteral(LiteralsUtils.toInternal(var));\r\n    }\r\n    return confl;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.NearQuery.spherical",
	"Comment": "configures whether to return spherical values for the actual distance.",
	"Method": "NearQuery spherical(boolean spherical){\r\n    this.spherical = spherical;\r\n    return this;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.storage.ChunkLayout.forceToChunk",
	"Comment": "converts world coordinates to chunk coordinates. this method never failsand can returns invalid chunk coordinates.",
	"Method": "Vector3i forceToChunk(Vector3i worldCoords,Vector3i forceToChunk,int x,int y,int z){\r\n    checkNotNull(worldCoords, \"worldCoords\");\r\n    return forceToChunk(worldCoords.getX(), worldCoords.getY(), worldCoords.getZ());\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.CollectionOptions.getMaxDocuments",
	"Comment": "get the max number of documents the collection should be limited to.",
	"Method": "Optional<Long> getMaxDocuments(){\r\n    return Optional.ofNullable(maxDocuments);\r\n}"
}, {
	"Path": "org.elasticsearch.indices.analysis.HunspellService.scanAndLoadDictionaries",
	"Comment": "scans the hunspell directory and loads all found dictionaries",
	"Method": "void scanAndLoadDictionaries(){\r\n    if (Files.isDirectory(hunspellDir)) {\r\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(hunspellDir)) {\r\n            for (Path file : stream) {\r\n                if (Files.isDirectory(file)) {\r\n                    try (DirectoryStream<Path> inner = Files.newDirectoryStream(hunspellDir.resolve(file), \"*.dic\")) {\r\n                        if (inner.iterator().hasNext()) {\r\n                            try {\r\n                                getDictionary(file.getFileName().toString());\r\n                            } catch (Exception e) {\r\n                                logger.error(\"exception while loading dictionary {}\", e, file.getFileName());\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform3.withTranslation",
	"Comment": "adds a translation to this transform and returnsit as a new transform.",
	"Method": "DiscreteTransform3 withTranslation(Vector3i vector,DiscreteTransform3 withTranslation,int x,int y,int z){\r\n    return new DiscreteTransform3(this.matrix.translate(x, y, z));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getFinderMethod",
	"Comment": "this method provides a finder method using thymeleaf response type",
	"Method": "MethodMetadata getFinderMethod(MethodMetadata finderMethod){\r\n    return null;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.ExtentBufferFactory.createThreadSafeBlockBuffer",
	"Comment": "returns a new block buffer of the desired size and minimum position. thisbuffer is thread safe.",
	"Method": "MutableBlockVolume createThreadSafeBlockBuffer(Vector3i size,MutableBlockVolume createThreadSafeBlockBuffer,Vector3i min,Vector3i size,MutableBlockVolume createThreadSafeBlockBuffer,int xSize,int ySize,int zSize,MutableBlockVolume createThreadSafeBlockBuffer,int xMin,int yMin,int zMin,int xSize,int ySize,int zSize){\r\n    return createThreadSafeBlockBuffer(new Vector3i(xMin, yMin, zMin), new Vector3i(xSize, ySize, zSize));\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.RepositoryRestConfiguration.isReturnBodyOnCreate",
	"Comment": "whether to return a response body after creating an entity.",
	"Method": "Boolean isReturnBodyOnCreate(){\r\n    return returnBodyOnCreate;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerOperationsImpl.exportOperation",
	"Comment": "generate the operations selected in the controller indicated",
	"Method": "void exportOperation(JavaType controller,List<String> operations){\r\n    ClassOrInterfaceTypeDetails controllerDetails = getTypeLocationService().getTypeDetails(controller);\r\n    Validate.notNull(controllerDetails, \"ERROR: You must provide an existing controller\");\r\n    Validate.notNull(controllerDetails.getAnnotation(RooJavaType.ROO_CONTROLLER), \"ERROR: You must provide a controller annotated with @RooController\");\r\n    Validate.notEmpty(operations, \"INFO: Don't exist operations to publish\");\r\n    ClassOrInterfaceTypeDetailsBuilder controllerBuilder = new ClassOrInterfaceTypeDetailsBuilder(controllerDetails);\r\n    AnnotationMetadata operationsAnnotation = controllerDetails.getAnnotation(RooJavaType.ROO_OPERATIONS);\r\n    List<StringAttributeValue> operationsToAdd = new ArrayList<StringAttributeValue>();\r\n    if (operationsAnnotation == null) {\r\n        AnnotationMetadataBuilder opAnnotation = new AnnotationMetadataBuilder(RooJavaType.ROO_OPERATIONS);\r\n        controllerBuilder.addAnnotation(opAnnotation);\r\n        for (String operation : operations) {\r\n            operationsToAdd.add(new StringAttributeValue(VALUE_SYM, operation));\r\n        }\r\n        opAnnotation.addAttribute(new ArrayAttributeValue<StringAttributeValue>(new JavaSymbolName(OPERATIONS_KEY), operationsToAdd));\r\n        getTypeManagementService().createOrUpdateTypeOnDisk(controllerBuilder.build());\r\n    } else {\r\n        List<String> operationsNames = new ArrayList<String>();\r\n        boolean operationsAdded = false;\r\n        AnnotationAttributeValue<Object> attributeOperations = operationsAnnotation.getAttribute(OPERATIONS_KEY);\r\n        if (attributeOperations != null) {\r\n            List<StringAttributeValue> existingOperations = (List<StringAttributeValue>) attributeOperations.getValue();\r\n            Iterator<StringAttributeValue> it = existingOperations.iterator();\r\n            while (it.hasNext()) {\r\n                StringAttributeValue attributeValue = it.next();\r\n                operationsToAdd.add(attributeValue);\r\n                operationsNames.add(attributeValue.getValue());\r\n            }\r\n            for (String operation : operations) {\r\n                if (!operationsNames.contains(operation)) {\r\n                    operationsToAdd.add(new StringAttributeValue(VALUE_SYM, operation));\r\n                    operationsAdded = true;\r\n                }\r\n            }\r\n            if (operationsAdded) {\r\n                AnnotationMetadataBuilder opAnnotation = new AnnotationMetadataBuilder(operationsAnnotation);\r\n                opAnnotation.addAttribute(new ArrayAttributeValue<StringAttributeValue>(new JavaSymbolName(OPERATIONS_KEY), operationsToAdd));\r\n                controllerBuilder.updateTypeAnnotation(opAnnotation);\r\n                getTypeManagementService().createOrUpdateTypeOnDisk(controllerBuilder.build());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.dto.addon.DtoOperationsImpl.addFieldsToProjection",
	"Comment": "removes persistence annotations of provided fields and adds them to aclassorinterfacetypedetailsbuilder representing a projection in construction.also adds final modifier to fields if required.",
	"Method": "void addFieldsToProjection(ClassOrInterfaceTypeDetailsBuilder projectionBuilder,Map<String, FieldMetadata> fieldsToAdd){\r\n    Iterator<Entry<String, FieldMetadata>> iterator = fieldsToAdd.entrySet().iterator();\r\n    while (iterator.hasNext()) {\r\n        Entry<String, FieldMetadata> entry = iterator.next();\r\n        FieldMetadata field = entry.getValue();\r\n        FieldMetadataBuilder fieldBuilder = null;\r\n        FieldDetails fieldDetails = null;\r\n        if (field.getFieldType().getFullyQualifiedTypeName().equals(\"java.util.Set\")) {\r\n            JavaType fieldType = field.getFieldType().getParameters().get(0);\r\n            fieldDetails = new SetField(projectionBuilder.getDeclaredByMetadataId(), new JavaType(JdkJavaType.SET.getFullyQualifiedTypeName(), 0, DataType.TYPE, null, Arrays.asList(fieldType)), field.getFieldName(), fieldType, null, null, true);\r\n            fieldBuilder = new FieldMetadataBuilder(fieldDetails);\r\n            fieldBuilder.setModifier(field.getModifier());\r\n            fieldBuilder.setAnnotations(field.getAnnotations());\r\n        } else if (field.getFieldType().getFullyQualifiedTypeName().equals(\"java.util.List\")) {\r\n            JavaType fieldType = field.getFieldType().getParameters().get(0);\r\n            fieldDetails = new ListField(projectionBuilder.getDeclaredByMetadataId(), new JavaType(JdkJavaType.LIST.getFullyQualifiedTypeName(), 0, DataType.TYPE, null, Arrays.asList(fieldType)), field.getFieldName(), fieldType, null, null, true);\r\n            fieldBuilder = new FieldMetadataBuilder(fieldDetails);\r\n            fieldBuilder.setModifier(field.getModifier());\r\n            fieldBuilder.setAnnotations(field.getAnnotations());\r\n        } else {\r\n            fieldBuilder = new FieldMetadataBuilder(projectionBuilder.getDeclaredByMetadataId(), field);\r\n        }\r\n        typeLocationService.addModuleDependency(projectionBuilder.getName().getModule(), field.getFieldType());\r\n        fieldBuilder.setFieldName(new JavaSymbolName(entry.getKey()));\r\n        String initializer = null;\r\n        if (fieldDetails instanceof CollectionField) {\r\n            final CollectionField collectionField = (CollectionField) fieldDetails;\r\n            initializer = \"new \" + collectionField.getInitializer() + \"()\";\r\n        } else if (fieldDetails instanceof DateField && fieldDetails.getFieldName().getSymbolName().equals(\"created\")) {\r\n            initializer = \"new Date()\";\r\n        }\r\n        fieldBuilder.setFieldInitializer(initializer);\r\n        List<AnnotationMetadata> annotations = field.getAnnotations();\r\n        for (AnnotationMetadata annotation : annotations) {\r\n            if (annotation.getAnnotationType().getFullyQualifiedTypeName().contains(\"javax.persistence\")) {\r\n                fieldBuilder.removeAnnotation(annotation.getAnnotationType());\r\n            } else if (annotation.getAnnotationType().getFullyQualifiedTypeName().startsWith(\"javax.validation\")) {\r\n                projectOperations.addDependency(projectionBuilder.getName().getModule(), new Dependency(\"javax.validation\", \"validation-api\", null));\r\n            } else if (annotation.getAnnotationType().equals(RooJavaType.ROO_JPA_RELATION)) {\r\n                fieldBuilder.removeAnnotation(annotation.getAnnotationType());\r\n            }\r\n        }\r\n        fieldBuilder.setModifier(Modifier.PRIVATE);\r\n        FieldMetadata projectionField = fieldBuilder.build();\r\n        projectionBuilder.addField(projectionField);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.test.TestOperationsImpl.addIntegrationTestDependencies",
	"Comment": "add needed dependencies and plugins to run created integration tests.",
	"Method": "void addIntegrationTestDependencies(String moduleName){\r\n    projectOperations.addDependency(moduleName, JUNIT_DEPENDENCY);\r\n    projectOperations.addDependency(moduleName, ASSERTJ_CORE_DEPENDENCY);\r\n    projectOperations.addDependency(moduleName, SPRING_TEST_DEPENDENCY);\r\n    projectOperations.addDependency(moduleName, SPRING_BOOT_TEST_DEPENDENCY);\r\n    Pom module = projectOperations.getPomFromModuleName(moduleName);\r\n    for (final Plugin plugin : module.getBuildPlugins()) {\r\n        if (plugin.getArtifactId().equals(\"maven-failsafe-plugin\")) {\r\n            return;\r\n        }\r\n    }\r\n    final Element configuration = XmlUtils.getConfiguration(getClass());\r\n    final Element plugin = XmlUtils.findFirstElement(\"/configuration/plugin\", configuration);\r\n    if (plugin != null) {\r\n        projectOperations.addBuildPlugin(moduleName, new Plugin(plugin));\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.i18n.I18nOperationsImpl.getInstalledLanguages",
	"Comment": "return a list of installed languages in the provided application module.",
	"Method": "List<I18n> getInstalledLanguages(String moduleName){\r\n    final LogicalPath resourcesPath = LogicalPath.getInstance(Path.SRC_MAIN_RESOURCES, moduleName);\r\n    final String targetDirectory = getPathResolver().getIdentifier(resourcesPath, \"\");\r\n    List<I18n> installedLanguages = new ArrayList<I18n>();\r\n    Set<I18n> supportedLanguages = getI18nSupport().getSupportedLanguages();\r\n    for (I18n i18n : supportedLanguages) {\r\n        String messageBundle = String.format(\"messages_%s.properties\", i18n.getLocale().getLanguage());\r\n        String bundlePath = String.format(\"%s%s%s\", targetDirectory, AntPathMatcher.DEFAULT_PATH_SEPARATOR, messageBundle);\r\n        if (getFileManager().exists(bundlePath)) {\r\n            installedLanguages.add(i18n);\r\n        }\r\n    }\r\n    installedLanguages.add(new EnglishLanguage());\r\n    return Collections.unmodifiableList(installedLanguages);\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform3.andThen",
	"Comment": "returns a transform that is the composition of the given transform withthis transform. the result will apply the given transformation after thisone.",
	"Method": "DiscreteTransform3 andThen(DiscreteTransform3 that){\r\n    return that.compose(this);\r\n}"
}, {
	"Path": "daikon.Daikon.mainHelper",
	"Comment": "this does the work of main, but it never calls system.exit, so itis appropriate to be called progrmmatically.termination of the program with a message to the user is indicated bythrowing terminationmessage.",
	"Method": "void mainHelper(String[] args){\r\n    cleanup();\r\n    FileOptions files = read_options(args, usage);\r\n    Set<File> decls_files = files.decls;\r\n    Set<String> dtrace_files = files.dtrace;\r\n    Set<File> spinfo_files = files.spinfo;\r\n    Set<File> map_files = files.map;\r\n    if (server_dir == null && (decls_files.size() == 0) && (dtrace_files.size() == 0)) {\r\n        System.out.println(\"No .decls or .dtrace files specified\");\r\n        throw new Daikon.TerminationMessage(\"No .decls or .dtrace files specified\");\r\n    }\r\n    if (Daikon.dkconfig_undo_opts) {\r\n        Daikon.dkconfig_disable_splitting = true;\r\n    }\r\n    if (Daikon.dkconfig_quiet)\r\n        Daikon.dkconfig_progress_delay = -1;\r\n    LogHelper.setupLogs(Global.debugAll ? LogHelper.FINE : LogHelper.INFO);\r\n    if (!noversion_output) {\r\n        if (!Daikon.dkconfig_quiet)\r\n            System.out.println(release_string);\r\n    }\r\n    if (NIS.dkconfig_suppression_processor == SuppressionProcessor.HYBRID) {\r\n        NIS.hybrid_method = true;\r\n    } else {\r\n        if (NIS.dkconfig_suppression_processor == SuppressionProcessor.ANTECEDENT) {\r\n            NIS.antecedent_method = true;\r\n            NIS.hybrid_method = false;\r\n        } else {\r\n            assert (NIS.dkconfig_suppression_processor == SuppressionProcessor.FALSIFIED);\r\n            NIS.antecedent_method = false;\r\n            NIS.hybrid_method = false;\r\n        }\r\n    }\r\n    setup_proto_invs();\r\n    if (PrintInvariants.print_discarded_invariants) {\r\n        DiscReasonMap.initialize();\r\n    }\r\n    fileio_progress = new FileIOProgress();\r\n    fileio_progress.start();\r\n    load_spinfo_files(spinfo_files);\r\n    all_ppts = load_decls_files(decls_files);\r\n    load_map_files(all_ppts, map_files);\r\n    all_ppts.trimToSize();\r\n    if (dkconfig_calc_possible_invs) {\r\n        fileio_progress.shouldStop = true;\r\n        int total_invs = 0;\r\n        for (Iterator<PptTopLevel> itor = all_ppts.ppt_all_iterator(); itor.hasNext(); ) {\r\n            PptTopLevel ppt = itor.next();\r\n            System.out.printf(\"Processing %s with %d variables\", ppt.name(), ppt.var_infos.length);\r\n            int inv_cnt = 0;\r\n            if (ppt.var_infos.length > 1600) {\r\n                System.out.println(\"Skipping, too many variables!\");\r\n            } else {\r\n                ppt.instantiate_views_and_invariants();\r\n                inv_cnt = ppt.invariant_cnt();\r\n                ppt.clean_for_merge();\r\n                System.out.println(inv_cnt + \" invariants in \" + ppt.name());\r\n                total_invs += inv_cnt;\r\n            }\r\n        }\r\n        System.out.println(total_invs + \"invariants total\");\r\n        return;\r\n    }\r\n    isInferencing = true;\r\n    process_data(all_ppts, dtrace_files);\r\n    isInferencing = false;\r\n    if (Debug.logOn())\r\n        Debug.check(all_ppts, \"After process data\");\r\n    if (suppress_redundant_invariants_with_simplify) {\r\n        suppressWithSimplify(all_ppts);\r\n    }\r\n    all_ppts.repCheck();\r\n    if (omit_from_output) {\r\n        processOmissions(all_ppts);\r\n    }\r\n    if (inv_file != null) {\r\n        try {\r\n            FileIO.write_serialized_pptmap(all_ppts, inv_file);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(\"Error while writing .inv file \" + \"'\" + inv_file + \"': \" + e.toString());\r\n        }\r\n    }\r\n    if (false) {\r\n        for (PptTopLevel ppt : all_ppts.all_ppts()) {\r\n            System.out.printf(\"Dumping variables for ppt %s%n\", ppt.name());\r\n            for (VarInfo vi : ppt.var_infos) {\r\n                System.out.printf(\"  vi %s%n\", vi);\r\n                System.out.printf(\"    file_rep_type = %s%n\", vi.file_rep_type);\r\n                System.out.printf(\"    type = %s%n\", vi.type);\r\n            }\r\n        }\r\n    }\r\n    if (Daikon.dkconfig_undo_opts) {\r\n        for (Iterator<PptTopLevel> t = all_ppts.pptIterator(); t.hasNext(); ) {\r\n            PptTopLevel ppt = t.next();\r\n            if (ppt.num_samples() == 0) {\r\n                continue;\r\n            }\r\n            List<Invariant> invs = PrintInvariants.sort_invariant_list(ppt.invariants_vector());\r\n            List<Invariant> filtered_invs = filter_invs(invs);\r\n            System.out.println(\"====================================================\");\r\n            System.out.println(ppt.name());\r\n            System.out.println(ppt.num_samples());\r\n            for (Invariant inv : filtered_invs) {\r\n                System.out.println(inv.getClass());\r\n                System.out.println(inv);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    if (output_num_samples) {\r\n        System.out.println(\"The --output_num_samples debugging flag is on.\");\r\n        System.out.println(\"Some of the debugging output may only make sense to Daikon programmers.\");\r\n    }\r\n    if (!PrintInvariants.print_discarded_invariants) {\r\n        PrintInvariants.print_invariants(all_ppts);\r\n    } else {\r\n        PrintInvariants.print_reasons(all_ppts);\r\n    }\r\n    if (output_num_samples) {\r\n        Global.output_statistics();\r\n    }\r\n    if (dkconfig_print_sample_totals)\r\n        System.out.println(FileIO.samples_processed + \" samples processed\");\r\n    if (debugStats.isLoggable(Level.FINE)) {\r\n        for (Iterator<PptTopLevel> itor = all_ppts.ppt_all_iterator(); itor.hasNext(); ) {\r\n            PptTopLevel ppt = itor.next();\r\n            PrintInvariants.print_filter_stats(debugStats, ppt, all_ppts);\r\n        }\r\n    }\r\n    if (!Daikon.dkconfig_quiet) {\r\n        System.out.println(\"Exiting Daikon.\");\r\n    }\r\n}"
}, {
	"Path": "spoon.IncrementalLauncher.saveCache",
	"Comment": "caches current spoon model and binary files. should be called only after model is built.",
	"Method": "void saveCache(){\r\n    if (mIncrementalCacheDirectory == null) {\r\n        throw new SpoonException(\"incremental cache directory is null\");\r\n    }\r\n    Factory factory = getFactory();\r\n    if (factory == null) {\r\n        throw new SpoonException(\"factory is null\");\r\n    }\r\n    getModelBuilder().compile(SpoonModelBuilder.InputType.FILES);\r\n    saveFactory(factory, mModelFile);\r\n    CacheInfo newCacheInfo = new CacheInfo();\r\n    newCacheInfo.lastBuildTime = System.currentTimeMillis();\r\n    Map<File, Set<File>> newSourcesMap = new HashMap();\r\n    for (Entry<String, CompilationUnit> e : factory.CompilationUnit().getMap().entrySet()) {\r\n        newSourcesMap.put(new File(e.getKey()), new HashSet(e.getValue().getBinaryFiles()));\r\n    }\r\n    if (mCacheInfo != null) {\r\n        newSourcesMap.putAll(mCacheInfo.inputSourcesMap);\r\n        for (File r : mRemovedSources) {\r\n            newSourcesMap.get(r).forEach(File::delete);\r\n            newSourcesMap.remove(r);\r\n        }\r\n    }\r\n    Collection<File> dirs = FileUtils.listFilesAndDirs(mClassFilesDir, DirectoryFileFilter.INSTANCE, TrueFileFilter.INSTANCE);\r\n    dirs.stream().filter(d -> d.exists() && FileUtils.listFiles(d, TrueFileFilter.INSTANCE, TrueFileFilter.INSTANCE).isEmpty()).forEach(FileUtils::deleteQuietly);\r\n    newCacheInfo.inputSourcesMap = newSourcesMap;\r\n    saveCacheInfo(newCacheInfo, mCacheInfoFile);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.PartTree.extractReturnType",
	"Comment": "extracts the java type of the results to be returned by the parttree query",
	"Method": "JavaType extractReturnType(MemberDetails entityDetails){\r\n    Integer maxResults = subject.getMaxResults();\r\n    Pair<Stack<FieldMetadata>, String> property = subject.getProperty();\r\n    JavaType type = null;\r\n    if (subject.isCountProjection()) {\r\n        return JavaType.LONG_OBJECT;\r\n    }\r\n    if (property != null && property.getLeft() != null) {\r\n        type = property.getLeft().peek().getFieldType();\r\n    } else if (providedReturnType != null) {\r\n        type = providedReturnType;\r\n    } else {\r\n        List<MemberHoldingTypeDetails> details = entityDetails.getDetails();\r\n        for (MemberHoldingTypeDetails detail : details) {\r\n            if (finderAutocomplete != null && finderAutocomplete.getEntityDetails(detail.getType()).equals(entityDetails)) {\r\n                type = detail.getType();\r\n                break;\r\n            } else {\r\n                type = detail.getType();\r\n            }\r\n        }\r\n    }\r\n    if (maxResults != null && maxResults == 1) {\r\n        return type;\r\n    }\r\n    if (type.isPrimitive()) {\r\n        type = new JavaType(type.getFullyQualifiedTypeName(), type.getArray(), DataType.TYPE, type.getArgName(), type.getParameters(), type.getModule());\r\n    }\r\n    return new JavaType(\"org.springframework.data.domain.Page\", 0, DataType.TYPE, null, Arrays.asList(type));\r\n}"
}, {
	"Path": "org.springframework.data.redis.listener.RedisMessageListenerContainer.isActive",
	"Comment": "return whether this container is currently active, that is, whether it has been set up but not shut down yet.",
	"Method": "boolean isActive(){\r\n    return initialized;\r\n}"
}, {
	"Path": "spoon.reflect.factory.FieldFactory.createReference",
	"Comment": "creates a field reference from a java.lang.reflect field.",
	"Method": "CtFieldReference<T> createReference(CtField<T> field,CtFieldReference<T> createReference,CtTypeReference<?> declaringType,CtTypeReference<T> type,String fieldName,CtFieldReference<T> createReference,Field field,CtFieldReference<T> createReference,String signature){\r\n    CtFieldReference<T> fieldRef = factory.Core().createFieldReference();\r\n    String type = signature.substring(0, signature.indexOf(' '));\r\n    String declaringType = signature.substring(signature.indexOf(' ') + 1, signature.indexOf(CtField.FIELD_SEPARATOR));\r\n    String fieldName = signature.substring(signature.indexOf(CtField.FIELD_SEPARATOR) + 1);\r\n    fieldRef.setSimpleName(fieldName);\r\n    fieldRef.setDeclaringType(factory.Type().createReference(declaringType));\r\n    CtTypeReference<T> typeRef = factory.Type().createReference(type);\r\n    fieldRef.setType(typeRef);\r\n    return fieldRef;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Criteria.where",
	"Comment": "static factory method to create a criteria using the provided key",
	"Method": "Criteria where(String key){\r\n    return new Criteria(key);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.tailor.config.xml.TailorParser.parseTailorConfiguration",
	"Comment": "maps the single xml tailor configuration to a tailorconfiguration object.",
	"Method": "TailorConfiguration parseTailorConfiguration(Element elTailor){\r\n    if (StringUtils.isBlank(elTailor.getAttribute(\"name\"))) {\r\n        logTailorXMLInvalid(\"<tailor> must have a name attribute\");\r\n        return null;\r\n    }\r\n    final TailorConfiguration result = new TailorConfiguration(elTailor.getAttribute(\"name\"), elTailor.getAttribute(\"description\"));\r\n    final String activeAttribute = elTailor.getAttribute(\"activate\");\r\n    if (StringUtils.isNotBlank(activeAttribute)) {\r\n        final boolean isActive = \"true\".equalsIgnoreCase(activeAttribute) || \"yes\".equalsIgnoreCase(activeAttribute);\r\n        result.setActive(isActive);\r\n    }\r\n    final List<Element> elConfigs = XmlUtils.findElements(\"config\", elTailor);\r\n    if (elConfigs.isEmpty()) {\r\n        logTailorXMLInvalid(\"<tailor> must have <config> child elements\");\r\n        return null;\r\n    }\r\n    for (final Element elConfig : elConfigs) {\r\n        final String command = elConfig.getAttribute(\"command\");\r\n        if (StringUtils.isBlank(command)) {\r\n            logTailorXMLInvalid(\"found <config> without command attribute\");\r\n            return null;\r\n        }\r\n        final CommandConfiguration newCmdConfig = new CommandConfiguration();\r\n        newCmdConfig.setCommandName(command);\r\n        final List<Element> elActions = XmlUtils.findElements(\"action\", elConfig);\r\n        for (final Element elAction : elActions) {\r\n            if (StringUtils.isBlank(elAction.getAttribute(\"type\"))) {\r\n                logTailorXMLInvalid(\"found <action> without type attribute\");\r\n                return null;\r\n            }\r\n            final ActionConfig newAction = new ActionConfig(elAction.getAttribute(\"type\"));\r\n            final NamedNodeMap attributes = elAction.getAttributes();\r\n            for (int i = 0; i < attributes.getLength(); i++) {\r\n                final Node item = attributes.item(i);\r\n                final String attributeKey = item.getNodeName();\r\n                if (!\"type\".equals(attributeKey)) {\r\n                    newAction.setAttribute(attributeKey, item.getNodeValue());\r\n                }\r\n            }\r\n            newCmdConfig.addAction(newAction);\r\n        }\r\n        result.addCommandConfig(newCmdConfig);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.DefaultBulkOperationsIntegrationTests.mixedBulkOrderedWithList",
	"Comment": "if working on the same set of documents, only an ordered bulk operation will yield predictable results.",
	"Method": "void mixedBulkOrderedWithList(){\r\n    List<BaseDoc> inserts = Arrays.asList(newDoc(\"1\", \"v1\"), newDoc(\"2\", \"v2\"), newDoc(\"3\", \"v2\"));\r\n    List<Pair<Query, Update>> updates = Arrays.asList(Pair.of(where(\"value\", \"v2\"), set(\"value\", \"v3\")));\r\n    List<Query> removes = Arrays.asList(where(\"_id\", \"1\"));\r\n    com.mongodb.bulk.BulkWriteResult result = createBulkOps(BulkMode.ORDERED, BaseDoc.class).insert(inserts).updateMulti(updates).remove(removes).execute();\r\n    assertThat(result, notNullValue());\r\n    assertThat(result.getInsertedCount(), is(3));\r\n    assertThat(result.getModifiedCount(), is(2));\r\n    assertThat(result.getDeletedCount(), is(1));\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.spel.ExpressionTransformationContextSupport.addToPreviousOperation",
	"Comment": "adds the given value to the previous operation and returns it.",
	"Method": "Document addToPreviousOperation(Object value){\r\n    Assert.state(previousOperationObject != null, \"No previous operation available!\");\r\n    extractArgumentListFrom(previousOperationObject).add(value);\r\n    return previousOperationObject;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.pushin.PushInOperationsImpl.getNewMethod",
	"Comment": "this method generates new method instance using an existingmethodmetadata",
	"Method": "MethodMetadata getNewMethod(String declaredByMetadataId,MethodMetadata method){\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    bodyBuilder.appendFormalLine(method.getBody());\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(declaredByMetadataId, method.getModifier(), method.getMethodName(), method.getReturnType(), method.getParameterTypes(), method.getParameterNames(), bodyBuilder);\r\n    methodBuilder.setAnnotations(method.getAnnotations());\r\n    methodBuilder.setCommentStructure(method.getCommentStructure());\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "spoon.reflect.visitor.Query.getReferences",
	"Comment": "within a given factory, returns all the program element references that\tmatch the filter.",
	"Method": "List<T> getReferences(CtElement rootElement,Filter<T> filter,List<R> getReferences,Factory factory,Filter<R> filter){\r\n    return getReferences(factory.Package().getRootPackage(), filter);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Query.comment",
	"Comment": "add a comment to the query that is propagated to the profile log.",
	"Method": "Query comment(String comment){\r\n    meta.setComment(comment);\r\n    return this;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.BlockVolume.getBlockCopy",
	"Comment": "returns a mutable copy of the blocks stored in this volume. this uses theprovided storage type.",
	"Method": "MutableBlockVolume getBlockCopy(MutableBlockVolume getBlockCopy,StorageType type){\r\n    return getBlockCopy(StorageType.STANDARD);\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.MetadataConfiguration.omitUnresolvableDescriptionKeys",
	"Comment": "returns whether to omit documentation attributes for unresolvable resource bundle keys.",
	"Method": "boolean omitUnresolvableDescriptionKeys(){\r\n    return omitUnresolvableDescriptionKeys;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.gen.populator.Flower.clearSupplierOverride",
	"Comment": "clears the supplier override to force the weighted table to be usedinstead.",
	"Method": "void clearSupplierOverride(){\r\n    setSupplierOverride(null);\r\n}"
}, {
	"Path": "spoon.refactoring.CtParameterRemoveRefactoring.createExpressionCannotBeRemovedIssue",
	"Comment": "override this method to get access to details about this refactoring issue.",
	"Method": "void createExpressionCannotBeRemovedIssue(CtInvocation<?> invocation,CtExpression<?> toBeRemovedExpression){\r\n    throw new RefactoringException(\"The expression \" + toBeRemovedExpression + \", which creates argument of the to be removed parameter in invocation \" + invocation + \" cannot be removed.\" + \" Override method `canRemoveExpression` to customize this behavior.\");\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.repository.support.ReactiveMongoRepositoryFactoryBean.setCreateIndexesForQueryMethods",
	"Comment": "configures whether to automatically create indexes for the properties referenced in a query method.",
	"Method": "void setCreateIndexesForQueryMethods(boolean createIndexesForQueryMethods){\r\n    this.createIndexesForQueryMethods = createIndexesForQueryMethods;\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.ReferenceBuilder.getTypeParameterReference",
	"Comment": "try to build a cttypeparameterreference from a single name with specified generic types but\tkeep in mind that if you give wrong data in the strong, reference will be wrong.",
	"Method": "CtTypeReference<Object> getTypeParameterReference(TypeBinding binding,TypeReference ref,CtTypeReference<Object> getTypeParameterReference,String name){\r\n    CtTypeReference<Object> param = null;\r\n    if (name.contains(\"extends\") || name.contains(\"super\")) {\r\n        String[] split = name.contains(\"extends\") ? name.split(\"extends\") : name.split(\"super\");\r\n        param = getTypeParameterReference(split[0].trim());\r\n        if (param instanceof CtWildcardReference) {\r\n            ((CtWildcardReference) param).setBoundingType(getTypeReference(split[split.length - 1].trim()));\r\n        }\r\n    } else if (name.matches(\".*(<.+>)\")) {\r\n        Pattern pattern = Pattern.compile(\"([^<]+)<(.+)>\");\r\n        Matcher m = pattern.matcher(name);\r\n        if (m.find()) {\r\n            param = this.jdtTreeBuilder.getFactory().Core().createTypeReference();\r\n            param.setSimpleName(m.group(1));\r\n            final String[] split = m.group(2).split(\",\");\r\n            for (String parameter : split) {\r\n                param.addActualTypeArgument(getTypeParameterReference(parameter.trim()));\r\n            }\r\n        }\r\n    } else if (name.contains(\"?\")) {\r\n        param = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\r\n    } else {\r\n        param = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();\r\n        param.setSimpleName(name);\r\n    }\r\n    return param;\r\n}"
}, {
	"Path": "spoon.refactoring.CtParameterRemoveRefactoring.detectIssues",
	"Comment": "validates whether this refactoring can be done without changing behavior of the refactored code.",
	"Method": "void detectIssues(){\r\n    checkAllExecutables();\r\n    checkAllInvocations();\r\n}"
}, {
	"Path": "spoon.javadoc.internal.Javadoc.toText",
	"Comment": "return the text content of the document. it does not containing trailing spaces and asterisks\t\t at the start of the line.",
	"Method": "String toText(){\r\n    StringBuilder sb = new StringBuilder();\r\n    if (!description.isEmpty()) {\r\n        sb.append(description.toText());\r\n        sb.append(System.lineSeparator());\r\n    }\r\n    if (!blockTags.isEmpty()) {\r\n        sb.append(System.lineSeparator());\r\n    }\r\n    blockTags.forEach(bt -> {\r\n        sb.append(bt.toText());\r\n        sb.append(System.lineSeparator());\r\n    });\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaMetadata.getCountMethodByReferencedFields",
	"Comment": "this method returns all generated countmethodbyreferencedfields",
	"Method": "Map<FieldMetadata, MethodMetadata> getCountMethodByReferencedFields(){\r\n    return countMethodByReferencedFields;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMainControllerMetadata.getCurrentIndexMethod",
	"Comment": "this method returns the index method of thymeleafmain controller",
	"Method": "MethodMetadata getCurrentIndexMethod(){\r\n    return this.indexMethod;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.aggregation.AggregationOptions.isExplain",
	"Comment": "specifies to return the information on the processing of the pipeline.",
	"Method": "boolean isExplain(){\r\n    return explain;\r\n}"
}, {
	"Path": "org.springframework.data.redis.listener.adapter.MessageListenerAdapter.getDelegate",
	"Comment": "returns the target object to delegate message listening to.",
	"Method": "Object getDelegate(){\r\n    return this.delegate;\r\n}"
}, {
	"Path": "spoon.support.sniper.internal.AbstractSourceFragmentContext.findIndexOfNextChildTokenByType",
	"Comment": "looks for next child token which contains expected token type",
	"Method": "int findIndexOfNextChildTokenByType(TokenType type){\r\n    return findIndexOfNextFragment(childFragments, childFragmentIdx + 1, filter(TokenSourceFragment.class, fragment -> type == fragment.getType()));\r\n}"
}, {
	"Path": "org.spongepowered.api.util.generator.dummy.DummyObjectProvider.createFor",
	"Comment": "creates a new dummy class implementing the specified interface.",
	"Method": "T createFor(Class<T> type,String fieldName){\r\n    try {\r\n        return (T) factories.getUnchecked(type).getConstructor(String.class).newInstance(fieldName);\r\n    } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {\r\n        throw new RuntimeException(String.format(\"Failed to instantiate dummy class for class %s\", type), e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Query.restrict",
	"Comment": "restricts the query to only return documents instances that are exactly of the given types.",
	"Method": "Query restrict(Class<?> type,Class<?> additionalTypes){\r\n    Assert.notNull(type, \"Type must not be null!\");\r\n    Assert.notNull(additionalTypes, \"AdditionalTypes must not be null\");\r\n    restrictedTypes.add(type);\r\n    restrictedTypes.addAll(Arrays.asList(additionalTypes));\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.spel.ExpressionTransformationContextSupport.parentIsSameOperation",
	"Comment": "returns whether the parent node is of the same operation as the current node.",
	"Method": "boolean parentIsSameOperation(){\r\n    return parentNode != null && currentNode.isOfSameTypeAs(parentNode);\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.MetadataConfiguration.registerFormattingPatternFor",
	"Comment": "registers the given formatting patter for the given value type.",
	"Method": "void registerFormattingPatternFor(String pattern,Class<?> type){\r\n    Assert.hasText(pattern, \"Pattern must not be null or empty!\");\r\n    Assert.notNull(type, \"Type must not be null!\");\r\n    this.patterns.put(type, Pattern.compile(pattern));\r\n}"
}, {
	"Path": "org.springframework.cloud.sleuth.instrument.grpc.stubs.HelloServiceGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "HelloServiceStub newStub(io.grpc.Channel channel){\r\n    return new HelloServiceStub(channel);\r\n}"
}, {
	"Path": "org.spongepowered.api.util.blockray.BlockRayHit.getNormal",
	"Comment": "returns the normal of the entered face, edge or corner.edges and corners use the average of the surrounding faces.",
	"Method": "Vector3d getNormal(){\r\n    return this.normal;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.ExtentBufferFactory.createBlockBuffer",
	"Comment": "returns a new block buffer of the desired size and minimum position.",
	"Method": "MutableBlockVolume createBlockBuffer(Vector3i size,MutableBlockVolume createBlockBuffer,Vector3i min,Vector3i size,MutableBlockVolume createBlockBuffer,int xSize,int ySize,int zSize,MutableBlockVolume createBlockBuffer,int xMin,int yMin,int zMin,int xSize,int ySize,int zSize){\r\n    return createBlockBuffer(new Vector3i(xMin, yMin, zMin), new Vector3i(xSize, ySize, zSize));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.pushin.PushInOperationsImpl.getProjectOperations",
	"Comment": "method to obtain projectoperation service implementation",
	"Method": "ProjectOperations getProjectOperations(){\r\n    return serviceManager.getServiceInstance(this, ProjectOperations.class);\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.halbrowser.HalBrowser.index",
	"Comment": "redirects requests to the api root asking for html to the hal browser.",
	"Method": "View index(HttpServletRequest request){\r\n    return getRedirectView(request, false);\r\n}"
}, {
	"Path": "org.spongepowered.api.util.weighted.RandomObjectTable.getRolls",
	"Comment": "gets the number of times this table will roll while retrieving items. foreach roll a complete pass through of the table will occur.",
	"Method": "VariableAmount getRolls(){\r\n    return this.rolls;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.BlockVolume.getBlockType",
	"Comment": "gets the base type of block.the type does not include block data such as the contents ofinventories.",
	"Method": "BlockType getBlockType(Vector3i position,BlockType getBlockType,int x,int y,int z){\r\n    return getBlockType(position.getX(), position.getY(), position.getZ());\r\n}"
}, {
	"Path": "spoon.ContractVerifier.assertSourcePositionTreeIsCorrectlyOrder",
	"Comment": "asserts that all siblings and children of sp are well ordered",
	"Method": "int assertSourcePositionTreeIsCorrectlyOrder(ElementSourceFragment sourceFragment,int minOffset,int maxOffset){\r\n    int nr = 0;\r\n    int pos = minOffset;\r\n    while (sourceFragment != null) {\r\n        nr++;\r\n        assertTrue(\"min(\" + pos + \") <= fragment.start(\" + sourceFragment.getStart() + \")\", pos <= sourceFragment.getStart());\r\n        assertTrue(\"fragment.start(\" + sourceFragment.getStart() + \") <= fragment.end(\" + sourceFragment.getEnd() + \")\", sourceFragment.getStart() <= sourceFragment.getEnd());\r\n        pos = sourceFragment.getEnd();\r\n        nr += assertSourcePositionTreeIsCorrectlyOrder(sourceFragment.getFirstChild(), sourceFragment.getStart(), sourceFragment.getEnd());\r\n        sourceFragment = sourceFragment.getNextSibling();\r\n    }\r\n    assertTrue(\"lastFragment.end(\" + pos + \") <= max(\" + maxOffset + \")\", pos <= maxOffset);\r\n    return nr;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.components.EntityItem.calculateZ",
	"Comment": "calculate the hash code of the entityname, entityitemid and configuration properties",
	"Method": "String calculateZ(){\r\n    final int prime = 31;\r\n    int result = 1;\r\n    result = prime * result + ((entityName == null) ? 0 : entityName.hashCode());\r\n    result = prime * result + ((entityItemId == null) ? 0 : entityItemId.hashCode());\r\n    result = prime * result + ((configuration == null) ? 0 : configuration.hashCode());\r\n    return Integer.toHexString(result);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.convert.QueryMapper.delegateConvertToMongoType",
	"Comment": "converts the given source object to a mongo type with the type information of the original source type omitted.\tsubclasses may overwrite this method to retain the type information of the source type on the resulting mongo type.",
	"Method": "Object delegateConvertToMongoType(Object source,MongoPersistentEntity<?> entity){\r\n    return converter.convertToMongoType(source, entity == null ? null : entity.getTypeInformation());\r\n}"
}, {
	"Path": "spoon.test.generics.testclasses3.ComparableComparatorBug.comparableComparator",
	"Comment": "gets the singleton instance of a comparablecomparator.developers are encouraged to use the comparator returned from this methodinstead of constructing a new instance to reduce allocation and gc overheadwhen multiple comparable comparators may be used in the same vm.",
	"Method": "ComparableComparatorBug<E> comparableComparator(){\r\n    return INSTANCE;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerCommands.setup",
	"Comment": "this method provides the command definition to be able to include springmvc on generated project.",
	"Method": "void setup(Pom module){\r\n    boolean usesDefaultModule = false;\r\n    if (module == null) {\r\n        Collection<Pom> applicationModules = getTypeLocationService().getModules(ModuleFeatureName.APPLICATION);\r\n        if (applicationModules.size() == 1) {\r\n            module = applicationModules.iterator().next();\r\n            usesDefaultModule = true;\r\n        }\r\n    }\r\n    getControllerOperations().setup(module, usesDefaultModule);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.dto.addon.DtoCommands.getEntityFieldList",
	"Comment": "gets a list of fields from an entity. static and transient fields are excludedas well as collection fields which type is an entity.",
	"Method": "List<FieldMetadata> getEntityFieldList(JavaType entity){\r\n    List<FieldMetadata> fieldList = new ArrayList<FieldMetadata>();\r\n    ClassOrInterfaceTypeDetails typeDetails = typeLocationService.getTypeDetails(entity);\r\n    Validate.notNull(typeDetails, String.format(\"Cannot find details for class %s. Please be sure that the class exists.\", entity.getFullyQualifiedTypeName()));\r\n    MemberDetails entityMemberDetails = memberDetailsScanner.getMemberDetails(this.getClass().getName(), typeDetails);\r\n    Validate.notNull(entityMemberDetails.getAnnotation(JpaJavaType.ENTITY), String.format(\"%s must be an entity to obtain it's fields info.\", entity.getFullyQualifiedTypeName()));\r\n    List<FieldMetadata> entityFields = entityMemberDetails.getFields();\r\n    for (FieldMetadata field : entityFields) {\r\n        if (Modifier.isStatic(field.getModifier())) {\r\n            continue;\r\n        }\r\n        if (field.getAnnotation(JpaJavaType.TRANSIENT) != null) {\r\n            continue;\r\n        }\r\n        JavaType fieldType = field.getFieldType();\r\n        if (fieldType.isCommonCollectionType()) {\r\n            boolean isEntityCollectionField = false;\r\n            List<JavaType> parameters = fieldType.getParameters();\r\n            for (JavaType parameter : parameters) {\r\n                if (typeIsEntity(parameter)) {\r\n                    isEntityCollectionField = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (isEntityCollectionField) {\r\n                continue;\r\n            }\r\n        }\r\n        fieldList.add(field);\r\n    }\r\n    return fieldList;\r\n}"
}, {
	"Path": "spoon.support.sniper.internal.AbstractSourceFragmentContext.printStandardSpaces",
	"Comment": "print all tokens, which represents white spaces\tand then forget them, so we can collect next white spaces",
	"Method": "void printStandardSpaces(){\r\n    for (Runnable runnable : separatorActions) {\r\n        runnable.run();\r\n    }\r\n    separatorActions.clear();\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.ProjectionsBenchmark.readIntoOpenProjection",
	"Comment": "read into an open projection backed by the mapped domain object.",
	"Method": "Object readIntoOpenProjection(){\r\n    return asOpenProjection.all();\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.FactoryCompilerConfig.initializeCompiler",
	"Comment": "returns the compilation units corresponding to the types in the factory.",
	"Method": "void initializeCompiler(JDTBatchCompiler compiler){\r\n    JDTBasedSpoonCompiler jdtCompiler = compiler.getJdtCompiler();\r\n    List<CompilationUnit> unitList = new ArrayList();\r\n    for (CtType<?> ctType : jdtCompiler.getFactory().Type().getAll()) {\r\n        if (ctType.isTopLevel()) {\r\n            unitList.add(new CompilationUnitWrapper(ctType));\r\n        }\r\n    }\r\n    compiler.setCompilationUnits(unitList.toArray(new CompilationUnit[0]));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.OrderBySource.getOptions",
	"Comment": "returns the different order clauses that can be build based on the current order clause defined.query is added as options prefix.",
	"Method": "List<String> getOptions(String query){\r\n    List<String> options = new ArrayList<String>();\r\n    Order lastOrder = orders.get(orders.size() - 1);\r\n    if (!lastOrder.hasProperty()) {\r\n        for (FieldMetadata field : fields) {\r\n            options.add(query.concat(StringUtils.capitalize(field.getFieldName().toString())));\r\n        }\r\n        if (orders.size() > 1) {\r\n            options.add(query.concat(\"\"));\r\n        }\r\n    } else {\r\n        options.add(query.concat(Direction.ASC.getKeyword()));\r\n        options.add(query.concat(Direction.DESC.getKeyword()));\r\n        List<FieldMetadata> fields = currentPartTreeInstance.getValidProperties(lastOrder.getProperty().getLeft().peek().getFieldType());\r\n        if (fields != null) {\r\n            for (FieldMetadata field : fields) {\r\n                options.add(query.concat(StringUtils.capitalize(field.getFieldName().toString())));\r\n            }\r\n        }\r\n    }\r\n    return options;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMVCViewResponseService.getMainControllerAnnotation",
	"Comment": "this operation returns the annotation type that identifies the maincontroller generated by thymeleaf response type.",
	"Method": "JavaType getMainControllerAnnotation(){\r\n    return RooJavaType.ROO_THYMELEAF_MAIN_CONTROLLER;\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.RepositorySearchesResource.getDomainType",
	"Comment": "returns the domain type for which the resource lists searches.",
	"Method": "Class<?> getDomainType(){\r\n    return domainType;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.field.addon.FieldCommands.getFieldCreatorProvider",
	"Comment": "gets the right implementation of fieldcreatorprovider for a javatype",
	"Method": "FieldCreatorProvider getFieldCreatorProvider(JavaType type){\r\n    if (fieldCreatorProviders.isEmpty()) {\r\n        try {\r\n            ServiceReference<?>[] references = this.context.getAllServiceReferences(FieldCreatorProvider.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                FieldCreatorProvider fieldCreatorProvider = (FieldCreatorProvider) this.context.getService(ref);\r\n                fieldCreatorProviders.add(fieldCreatorProvider);\r\n            }\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load FieldCreatorProvider on FieldCommands.\");\r\n            return null;\r\n        }\r\n    }\r\n    for (FieldCreatorProvider provider : fieldCreatorProviders) {\r\n        if (provider.isValid(type)) {\r\n            return provider;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaCustomMetadata.getFindAllMethodByReferencedField",
	"Comment": "method that generates the findall method for provided referenced field on current interface.",
	"Method": "MethodMetadata getFindAllMethodByReferencedField(FieldMetadata referencedField,RelationInfo relationInfo){\r\n    String findPattern = \"findBy%s\";\r\n    if (relationInfo.cardinality == Cardinality.MANY_TO_MANY) {\r\n        findPattern = \"findBy%sContains\";\r\n    }\r\n    JavaSymbolName methodName = new JavaSymbolName(String.format(findPattern, referencedField.getFieldName().getSymbolNameCapitalisedFirstLetter()));\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    final JavaType paramType = referencedField.getFieldType().getBaseType();\r\n    parameterTypes.add(AnnotatedJavaType.convertFromJavaType(paramType));\r\n    parameterTypes.add(GLOBAL_SEARCH_PARAMETER);\r\n    parameterTypes.add(PAGEABLE_PARAMETER);\r\n    List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    parameterNames.add(new JavaSymbolName(StringUtils.uncapitalize(referencedField.getFieldName().getSymbolName())));\r\n    parameterNames.add(GOBAL_SEARCH_PARAMETER_NAME);\r\n    parameterNames.add(PAGEABLE_PARAMETER_NAME);\r\n    JavaType returnType = new JavaType(SpringJavaType.PAGE.getFullyQualifiedTypeName(), 0, DataType.TYPE, null, Arrays.asList(defaultReturnType));\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC + Modifier.ABSTRACT, methodName, returnType, parameterTypes, parameterNames, null);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.AbstractViewGenerationService.getWebFlowViewsFromDir",
	"Comment": "this method obtains the webflow views generated in the project.",
	"Method": "List<String> getWebFlowViewsFromDir(String viewsFolder,List<String> views){\r\n    if (views == null) {\r\n        views = new ArrayList<String>();\r\n    }\r\n    File viewsDir = new File(viewsFolder);\r\n    File[] allElements = viewsDir.listFiles();\r\n    for (File element : allElements) {\r\n        if (element.isDirectory()) {\r\n            getWebFlowViewsFromDir(element.getAbsolutePath(), views);\r\n        } else if (element.getName().endsWith(\"-flow.xml\")) {\r\n            String flowName = element.getName().replaceAll(\"-flow.xml\", \"\");\r\n            views.add(flowName);\r\n        }\r\n    }\r\n    return views;\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.JDTTreeBuilderQuery.isValidProblemBindingField",
	"Comment": "checks if the qualified name reference is a problem field binding and have a valid field.",
	"Method": "boolean isValidProblemBindingField(QualifiedNameReference qualifiedNameReference){\r\n    return qualifiedNameReference.binding instanceof ProblemFieldBinding && !((FieldBinding) qualifiedNameReference.binding).declaringClass.isAnonymousType() && qualifiedNameReference.tokens.length - 1 == ((FieldBinding) qualifiedNameReference.binding).declaringClass.compoundName.length && CharOperation.equals(CharOperation.subarray(qualifiedNameReference.tokens, 0, qualifiedNameReference.tokens.length - 1), ((FieldBinding) qualifiedNameReference.binding).declaringClass.compoundName);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getPdfExportMethod",
	"Comment": "generates a method to export data to pdf using dynamicjasper.",
	"Method": "MethodMetadata getPdfExportMethod(){\r\n    if (jasperReportsMap.get(\"JasperReportsPdfExporter\") != null) {\r\n        final String exporterMethodInvocation = String.format(\"new %s()\", getNameOfJavaType(jasperReportsMap.get(\"JasperReportsPdfExporter\")));\r\n        final String fileName = String.format(\"%s_report.pdf\", StringUtils.uncapitalize(this.entityPlural));\r\n        final JavaSymbolName methodName = EXPORT_PDF_METHOD_NAME;\r\n        return buildExportTypeMethod(exporterMethodInvocation, fileName, methodName, \"exportPdf\", \"/export/pdf\", \"PDF\");\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.responses.json.JSONMVCResponseService.getName",
	"Comment": "this operation returns the feature name. in this case,the feature name is the same as the response type.",
	"Method": "String getName(){\r\n    return getResponseType();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.link.factory.LinkFactoryMetadata.addAndGet",
	"Comment": "add method to governor if needed and returns the methodmetadata.",
	"Method": "MethodMetadata addAndGet(MethodMetadata method){\r\n    ensureGovernorHasMethod(new MethodMetadataBuilder(method));\r\n    return method;\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.util.UriUtils.findMappingVariable",
	"Comment": "returns the value for the mapping variable with the given name.",
	"Method": "String findMappingVariable(String variable,Method method,String lookupPath){\r\n    Assert.hasText(variable, \"Variable name must not be null or empty!\");\r\n    Assert.notNull(method, \"Method must not be null!\");\r\n    String mapping = DISCOVERER.getMapping(method);\r\n    Map<String, String> variables = new org.springframework.web.util.UriTemplate(mapping).match(lookupPath);\r\n    String value = variables.get(variable);\r\n    if (value != null) {\r\n        return value;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.RedisPipelineException.getPipelineResult",
	"Comment": "optionally returns the result of the pipeline that caused the exception. typically contains both the results of the\tsuccessful statements but also the exceptions of the incorrect ones.",
	"Method": "List<Object> getPipelineResult(){\r\n    return results;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaCustomImplMetadata.getCustomFindersImpl",
	"Comment": "method that generates implementation methods for each finder which return typeis a projection or argument is a dto.",
	"Method": "MethodMetadata getCustomFindersImpl(Pair<MethodMetadata, PartTree> methodInfo,List<FieldMetadata> fields){\r\n    MethodMetadata method = methodInfo.getLeft();\r\n    JavaSymbolName methodName = method.getMethodName();\r\n    List<AnnotatedJavaType> parameterTypes = method.getParameterTypes();\r\n    List<JavaSymbolName> parameterNames = method.getParameterNames();\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    JavaSymbolName globalSearch = getParameterNameFor(method, SpringletsJavaType.SPRINGLETS_GLOBAL_SEARCH);\r\n    JavaSymbolName pageable = getParameterNameFor(method, SpringJavaType.PAGEABLE);\r\n    String entity = this.entity.getSimpleTypeName();\r\n    String entityVariable = StringUtils.uncapitalize(entity);\r\n    JavaType finderParamType = parameterTypes.get(0).getJavaType();\r\n    String finderParamName = parameterNames.get(0).getSymbolName();\r\n    JavaType returnType = getDomainTypeOfFinderMethod(method);\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(String.format(\"%1$s %2$s = %1$s.%2$s;\", getNameOfJavaType(entityQtype), entityVariable));\r\n    bodyBuilder.newLine();\r\n    buildQuery(bodyBuilder, entityVariable, globalSearch, null, null, null, finderParamType, finderParamName, returnType, method.getMethodName(), methodInfo.getRight());\r\n    bodyBuilder.newLine();\r\n    StringBuffer mappingBuilderLine = new StringBuffer();\r\n    mappingBuilderLine.append(String.format(\"%s mapping = buildMapper()\", getNameOfJavaType(SpringletsJavaType.SPRINGLETS_QUERYDSL_REPOSITORY_SUPPORT_ATTRIBUTE_BUILDER)));\r\n    if (!this.typesAreProjections.get(returnType)) {\r\n        Iterator<FieldMetadata> iterator = fields.iterator();\r\n        while (iterator.hasNext()) {\r\n            FieldMetadata field = iterator.next();\r\n            String fieldName = field.getFieldName().getSymbolName();\r\n            mappingBuilderLine.append(String.format(\"\\n\\t\\t\\t.map(%s, %s.%s)\", getConstantForField(fieldName).getFieldName(), entityVariable, fieldName));\r\n        }\r\n    } else {\r\n        List<Pair<String, String>> projectionFields = this.typesFieldMaps.get(returnType);\r\n        Iterator<Pair<String, String>> iterator = projectionFields.iterator();\r\n        while (iterator.hasNext()) {\r\n            Entry<String, String> entry = iterator.next();\r\n            mappingBuilderLine.append(String.format(\"\\n\\t\\t\\t.map(%s, %s)\", getConstantForField(entry.getKey()).getFieldName(), entry.getValue()));\r\n        }\r\n    }\r\n    mappingBuilderLine.append(\";\");\r\n    bodyBuilder.appendFormalLine(mappingBuilderLine.toString());\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(String.format(\"applyPagination(%s, query, mapping);\", pageable));\r\n    bodyBuilder.appendFormalLine(\"applyOrderById(query);\");\r\n    bodyBuilder.newLine();\r\n    buildQueryResult(bodyBuilder, pageable, entityVariable, QUERYDSL_PROJECTIONS, returnType);\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, methodInfo.getLeft().getReturnType(), parameterTypes, parameterNames, bodyBuilder);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.jsp.JspOperationsImpl.getFolderAndMapping",
	"Comment": "returns the folder name and mapping value for the given preferred maaping",
	"Method": "ImmutablePair<String, String> getFolderAndMapping(String preferredMapping,JavaType controller){\r\n    if (StringUtils.isNotBlank(preferredMapping)) {\r\n        String folderName = StringUtils.removeStart(preferredMapping, \"/\");\r\n        folderName = StringUtils.removeEnd(folderName, \"**\");\r\n        folderName = StringUtils.removeEnd(folderName, \"/\");\r\n        String mapping = (preferredMapping.startsWith(\"/\") ? \"\" : \"/\") + preferredMapping;\r\n        mapping = StringUtils.removeEnd(mapping, \"/\");\r\n        mapping = mapping + (mapping.endsWith(\"/**\") ? \"\" : \"/**\");\r\n        return new ImmutablePair<String, String>(folderName, mapping);\r\n    }\r\n    final String typeNameLower = StringUtils.removeEnd(controller.getSimpleTypeName(), \"Controller\").toLowerCase();\r\n    return new ImmutablePair<String, String>(typeNameLower, \"/\" + typeNameLower + \"/**\");\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaCustomMetadata.getFindAllGlobalSearchMethod",
	"Comment": "method that generates the findall method on current interface.",
	"Method": "MethodMetadata getFindAllGlobalSearchMethod(){\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    parameterTypes.add(GLOBAL_SEARCH_PARAMETER);\r\n    parameterNames.add(GOBAL_SEARCH_PARAMETER_NAME);\r\n    parameterTypes.add(PAGEABLE_PARAMETER);\r\n    parameterNames.add(PAGEABLE_PARAMETER_NAME);\r\n    JavaSymbolName methodName = new JavaSymbolName(\"findAll\");\r\n    JavaType returnType = new JavaType(\"org.springframework.data.domain.Page\", 0, DataType.TYPE, null, Arrays.asList(defaultReturnType));\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC + Modifier.ABSTRACT, methodName, returnType, parameterTypes, parameterNames, null);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.InteractableVolume.interactBlock",
	"Comment": "simulates the interaction the block as if a player had done so.",
	"Method": "boolean interactBlock(Vector3i position,Direction side,GameProfile profile,boolean interactBlock,int x,int y,int z,Direction side,GameProfile profile){\r\n    return interactBlock(checkNotNull(position, \"position\").getX(), position.getY(), position.getZ(), side, profile);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getFinderRedirectMethod",
	"Comment": "this method provides a finder redirect method using thymeleaf responsetype",
	"Method": "MethodMetadata getFinderRedirectMethod(MethodMetadata finderMethod){\r\n    return null;\r\n}"
}, {
	"Path": "org.spongepowered.api.text.serializer.TextSerializers.formattingCode",
	"Comment": "returns a representation that accepts and outputs formatting codes, usingthe provided formatting character.",
	"Method": "FormattingCodeTextSerializer formattingCode(char formattingChar){\r\n    if (formattingChar == LEGACY_FORMATTING_CODE.getCharacter()) {\r\n        return LEGACY_FORMATTING_CODE;\r\n    } else if (formattingChar == FORMATTING_CODE.getCharacter()) {\r\n        return FORMATTING_CODE;\r\n    } else {\r\n        return Sponge.getRegistry().getTextSerializerFactory().getFormattingCodeTextSerializer(formattingChar);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.entity.JpaFieldCreatorProvider.createChildEntityFactory",
	"Comment": "creates the factory class of the child entity of relationship, only if parent entity has jpa unit tests.",
	"Method": "void createChildEntityFactory(JavaType childType,JavaType parentType){\r\n    Set<JavaType> unitTestTypes = typeLocationService.findTypesWithAnnotation(RooJavaType.ROO_JPA_UNIT_TEST);\r\n    for (JavaType unitTestType : unitTestTypes) {\r\n        ClassOrInterfaceTypeDetails cid = typeLocationService.getTypeDetails(unitTestType);\r\n        AnnotationMetadata rooUnitTestAnnotation = cid.getAnnotation(RooJavaType.ROO_JPA_UNIT_TEST);\r\n        AnnotationAttributeValue<Object> targetClass = rooUnitTestAnnotation.getAttribute(\"targetClass\");\r\n        Validate.notNull(targetClass, String.format(\"'targetClass' attribute can't be found for annotation @RooJpaUnitTest in class %s\", unitTestType.getSimpleTypeName()));\r\n        if (parentType.equals(targetClass.getValue())) {\r\n            if (jpaEntityFactoryLocator.getFirstJpaEntityFactoryForEntity(childType) == null) {\r\n                dataOnDemandCreatorProvider.createEntityFactory(childType);\r\n            }\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.redis.core.IndexWriter.updateIndexes",
	"Comment": "updates indexes by first removing key from existing one and then persisting new index data.",
	"Method": "void updateIndexes(Object key,Iterable<IndexedData> indexValues){\r\n    createOrUpdateIndexes(key, indexValues, IndexWriteMode.PARTIAL_UPDATE);\r\n}"
}, {
	"Path": "spoon.test.SpoonTestHelpers.getAllMetamodelMethods",
	"Comment": "returns all possible methods in the order class then interface, and up again",
	"Method": "List<CtMethod<?>> getAllMetamodelMethods(CtType<?> baseType){\r\n    List<CtMethod<?>> result = new ArrayList();\r\n    for (CtMethod<?> m : baseType.getMethods()) {\r\n        if (!containsMethodBasedOnName(result, m)) {\r\n            result.add(m);\r\n        }\r\n    }\r\n    for (CtTypeReference<?> itf : baseType.getSuperInterfaces()) {\r\n        for (CtMethod<?> up : getAllSetters(itf.getTypeDeclaration())) {\r\n            if (!containsMethodBasedOnName(result, up)) {\r\n                result.add(up);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.ProfileController.getRootPath",
	"Comment": "return the href for the profile root link of a given baseuri.",
	"Method": "String getRootPath(RepositoryRestConfiguration configuration){\r\n    BaseUri baseUri = new BaseUri(configuration.getBaseUri());\r\n    return baseUri.getUriComponentsBuilder().path(ProfileController.PROFILE_ROOT_MAPPING).build().toString();\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.RepositoryRestConfiguration.setSortParamName",
	"Comment": "set the name of the url query string parameter that indicates what direction to sort results.",
	"Method": "RepositoryRestConfiguration setSortParamName(String sortParamName){\r\n    Assert.notNull(sortParamName, \"Sort param name cannot be null.\");\r\n    this.sortParamName = sortParamName;\r\n    return this;\r\n}"
}, {
	"Path": "spoon.test.architecture.SpoonArchitectureEnforcerTest.testSrcMainJava",
	"Comment": "we put them in the same test in order to only build the full model once",
	"Method": "void testSrcMainJava(){\r\n    Launcher spoon = new Launcher();\r\n    spoon.getEnvironment().setCommentEnabled(true);\r\n    spoon.addInputResource(\"src/main/java/\");\r\n    spoon.buildModel();\r\n    List<String> notDocumented = new ArrayList();\r\n    for (CtMethod method : spoon.getModel().getElements(new TypeFilter(CtMethod.class))) {\r\n        if (method.hasModifier(ModifierKind.PUBLIC) && !method.getSimpleName().startsWith(\"get\") && !method.getSimpleName().startsWith(\"set\") && !method.getSimpleName().startsWith(\"is\") && !method.getSimpleName().startsWith(\"add\") && !method.getSimpleName().startsWith(\"remove\") && method.getTopDefinitions().isEmpty() && (method.hasModifier(ModifierKind.ABSTRACT) || method.filterChildren(new TypeFilter(CtCodeElement.class)).list().size() > 35)) {\r\n            if (method.getDocComment().length() <= 15) {\r\n                notDocumented.add(method.getParent(CtType.class).getQualifiedName() + \"#\" + method.getSignature());\r\n            }\r\n        }\r\n    }\r\n    if (!notDocumented.isEmpty()) {\r\n        fail(notDocumented.size() + \" public methods should be documented with proper API documentation: \\n\" + StringUtils.join(notDocumented, \"\\n\"));\r\n    }\r\n    List<CtConstructorCall> treeSetWithoutComparators = spoon.getFactory().Package().getRootPackage().filterChildren(new AbstractFilter<CtConstructorCall>() {\r\n        @Override\r\n        public boolean matches(CtConstructorCall element) {\r\n            return element.getType().getActualClass().equals(TreeSet.class) && element.getArguments().isEmpty();\r\n        }\r\n    }).list();\r\n    assertEquals(0, treeSetWithoutComparators.size());\r\n}"
}, {
	"Path": "spoon.test.architecture.SpoonArchitectureEnforcerTest.testSrcMainJava",
	"Comment": "we put them in the same test in order to only build the full model once",
	"Method": "void testSrcMainJava(){\r\n    return element.getType().getActualClass().equals(TreeSet.class) && element.getArguments().isEmpty();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerOperationsImpl.checkRelationField",
	"Comment": "find recursively if relation field is valid. check that the fields areset or list and check that the parents controllers exists",
	"Method": "List<RelationInfo> checkRelationField(JpaEntityMetadata entityMetadata,String[] relationField,int level,ControllerMVCResponseService responseType,JavaPackage controllerPackage,String pathPrefix,JavaType masterEntity){\r\n    List<RelationInfo> infos = new ArrayList<RelationInfo>();\r\n    RelationInfo info = entityMetadata.getRelationInfos().get(relationField[level]);\r\n    if (info == null) {\r\n        return null;\r\n    }\r\n    if (info.cardinality != Cardinality.ONE_TO_MANY && info.cardinality != Cardinality.MANY_TO_MANY) {\r\n        return null;\r\n    }\r\n    infos.add(info);\r\n    if (relationField.length > level + 1) {\r\n        List<String> currentPathList = new ArrayList<String>(level + 1);\r\n        for (int i = 0; i < relationField.length; i++) {\r\n            currentPathList.add(relationField[i]);\r\n        }\r\n        String currentPath = StringUtils.join(currentPathList, '.');\r\n        if (checkDetailControllerExists(masterEntity, responseType, controllerPackage, pathPrefix, currentPath)) {\r\n            JpaEntityMetadata childEntity = getMetadataService().get(JpaEntityMetadata.createIdentifier(getTypeLocationService().getTypeDetails(info.childType)));\r\n            List<RelationInfo> subPath = checkRelationField(childEntity, relationField, level + 1, responseType, controllerPackage, pathPrefix, masterEntity);\r\n            if (subPath == null) {\r\n                return null;\r\n            }\r\n            infos.addAll(subPath);\r\n        } else {\r\n            if (LOGGER.isLoggable(Level.INFO)) {\r\n                LOGGER.info(String.format(\"Details controller is required for %s befor can create %s\", currentPath, StringUtils.join(Arrays.asList(relationField), ',')));\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n    return infos;\r\n}"
}, {
	"Path": "org.springframework.data.redis.core.ReactiveStreamOperations.delete",
	"Comment": "removes the specified records from the stream. returns the number of records deleted, that may be different from\tthe number of ids passed in case certain ids do not exist.",
	"Method": "Mono<Long> delete(K key,String recordIds,Mono<Long> delete,Record<K, ?> record,Mono<Long> delete,K key,RecordId recordIds){\r\n    return delete(record.getStream(), record.getId());\r\n}"
}, {
	"Path": "org.spongepowered.api.text.TextTemplate.getCloseArgString",
	"Comment": "returns the string used for containing args within the template.",
	"Method": "String getCloseArgString(String getCloseArgString){\r\n    return this.closeArg;\r\n}"
}, {
	"Path": "org.spongepowered.api.text.translation.Translation.get",
	"Comment": "gets the translation format with the specified parameters.",
	"Method": "String get(String get,Object args,String get,Locale locale,String get,Locale locale,Object args){\r\n    return get(Locales.DEFAULT, args);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.field.addon.FieldCommands.checkFieldExists",
	"Comment": "checks if entity has already a field with the same name and throws an exceptionin that case.",
	"Method": "void checkFieldExists(JavaSymbolName fieldName,ShellContext shellContext,ClassOrInterfaceTypeDetails javaTypeDetails){\r\n    MemberDetails memberDetails = memberDetailsScanner.getMemberDetails(this.getClass().getName(), javaTypeDetails);\r\n    List<FieldMetadata> fields = memberDetails.getFields();\r\n    for (FieldMetadata field : fields) {\r\n        if (field.getFieldName().equals(fieldName) && !shellContext.isForce()) {\r\n            throw new IllegalArgumentException(String.format(\"Field '%s' already exists and cannot be created. Try to use a \" + \"different field name on --fieldName parameter or use --force parameter to overwrite it.\", fieldName));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.convert.MappingMongoConverter.potentiallyEscapeMapKey",
	"Comment": "potentially replaces dots in the given map key with the configured map key replacement if configured or aborts\tconversion if none is configured.",
	"Method": "String potentiallyEscapeMapKey(String source){\r\n    if (!source.contains(\".\")) {\r\n        return source;\r\n    }\r\n    if (mapKeyDotReplacement == null) {\r\n        throw new MappingException(String.format(\"Map key %s contains dots but no replacement was configured! Make \" + \"sure map keys don't contain dots in the first place or configure an appropriate replacement!\", source));\r\n    }\r\n    return source.replaceAll(\"\\\\.\", mapKeyDotReplacement);\r\n}"
}, {
	"Path": "org.spongepowered.api.util.Coerce.toByte",
	"Comment": "coerce the supplied object to a byte number, parse it if necessary.",
	"Method": "byte toByte(Object obj){\r\n    if (obj == null) {\r\n        return 0;\r\n    }\r\n    if (obj instanceof Number) {\r\n        return ((Number) obj).byteValue();\r\n    }\r\n    try {\r\n        return Byte.parseByte(Coerce.sanitiseNumber(obj));\r\n    } catch (NumberFormatException e) {\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.buildPopulateFormatBody",
	"Comment": "build method body which populate in model all required formats for a formbased on datetimefield of a type.also populate current locale in model.",
	"Method": "void buildPopulateFormatBody(InvocableMemberBodyBuilder bodyBuilder,List<FieldMetadata> dateTimeFields){\r\n    bodyBuilder.appendFormalLine(\"model.addAttribute(\\\"application_locale\\\", %s.getLocale().getLanguage());\", getNameOfJavaType(SpringJavaType.LOCALE_CONTEXT_HOLDER));\r\n    if (dateTimeFields == null || dateTimeFields.isEmpty()) {\r\n        return;\r\n    }\r\n    for (FieldMetadata field : dateTimeFields) {\r\n        AnnotationMetadata dateTimeFormatAnnotation = field.getAnnotation(SpringJavaType.DATE_TIME_FORMAT);\r\n        if (dateTimeFormatAnnotation != null && (dateTimeFormatAnnotation.getAttribute(\"style\") != null || dateTimeFormatAnnotation.getAttribute(\"pattern\") != null)) {\r\n            AnnotationAttributeValue<String> formatAttr = dateTimeFormatAnnotation.getAttribute(\"style\");\r\n            if (formatAttr != null) {\r\n                String format = formatAttr.getValue();\r\n                bodyBuilder.appendFormalLine(\"model.addAttribute(\\\"%s_date_format\\\", %s.patternForStyle(\\\"%s\\\", %s.getLocale()));\", field.getFieldName(), getNameOfJavaType(JODA_DATETIME_FORMAT_JAVA_TYPE), format, getNameOfJavaType(SpringJavaType.LOCALE_CONTEXT_HOLDER));\r\n            } else {\r\n                formatAttr = dateTimeFormatAnnotation.getAttribute(\"pattern\");\r\n                String format = formatAttr.getValue();\r\n                bodyBuilder.appendFormalLine(String.format(\"model.addAttribute(\\\"%s_date_format\\\", \\\"%s\\\");\", field.getFieldName(), format));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.cloud.sleuth.instrument.messaging.TracingChannelInterceptor.addTags",
	"Comment": "when an upstream context was not present, lookup keys are unlikely added",
	"Method": "void addTags(Message<?> message,SpanCustomizer result,MessageChannel channel){\r\n    if (channel != null) {\r\n        result.tag(\"channel\", messageChannelName(channel));\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.RepositoryRestConfiguration.returnBodyOnUpdate",
	"Comment": "whether to return a response body after updating an entity considering the given accept header.",
	"Method": "boolean returnBodyOnUpdate(String acceptHeader){\r\n    return returnBodyOnUpdate == null ? StringUtils.hasText(acceptHeader) : returnBodyOnUpdate;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.blockray.BlockRay.continueAfterFilter",
	"Comment": "extends a filter by a number of blocks, regardless of what the extendedfilter does.",
	"Method": "Predicate<BlockRayHit<E>> continueAfterFilter(Predicate<BlockRayHit<E>> filter,int numberOfBlocks){\r\n    return new ContinueAfterFilter(filter, numberOfBlocks);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaMetadataProviderImpl.checkDtoFieldsForFinder",
	"Comment": "validates that all dto fields matches with parameters on finder of a repository",
	"Method": "void checkDtoFieldsForFinder(ClassOrInterfaceTypeDetails formBeanDetails,PartTree finder,JavaType repository){\r\n    final JavaType dtoType = formBeanDetails.getName();\r\n    final String finderName = finder.getOriginalQuery();\r\n    FieldMetadata paramField, dtoField;\r\n    JavaType paramType, dtoFieldType;\r\n    for (FinderParameter param : finder.getParameters()) {\r\n        paramField = param.getPath().peek();\r\n        dtoField = formBeanDetails.getField(paramField.getFieldName());\r\n        Validate.notNull(dtoField, \"Field '%s' not found on DTO %s for finder '%s' of %s\", paramField.getFieldName(), dtoType, finderName, repository);\r\n        paramType = paramField.getFieldType().getBaseType();\r\n        dtoFieldType = dtoField.getFieldType().getBaseType();\r\n        Validate.isTrue(paramType.equals(dtoFieldType), \"Type missmatch for field '%s' on DTO %s for finder '%s' of %s: excepted %s and got %s\", dtoField.getFieldName(), dtoType, finderName, repository, paramType, dtoFieldType);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaOperationsImpl.addRepositoryConfigurationClass",
	"Comment": "checks for all the application modules in project and adds a repository configuration class, which uses the springlets base repository class if none is already specified.",
	"Method": "void addRepositoryConfigurationClass(){\r\n    Set<ClassOrInterfaceTypeDetails> applicationCids = getTypeLocationService().findClassesOrInterfaceDetailsWithAnnotation(SpringJavaType.SPRING_BOOT_APPLICATION);\r\n    for (ClassOrInterfaceTypeDetails applicationCid : applicationCids) {\r\n        Pom module = getProjectOperations().getPomFromModuleName(applicationCid.getType().getModule());\r\n        JavaType repositoryConfigurationClass = new JavaType(String.format(\"%s.config.SpringDataJpaDetachableRepositoryConfiguration\", getTypeLocationService().getTopLevelPackageForModule(module)), module.getModuleName());\r\n        Validate.notNull(repositoryConfigurationClass.getModule(), \"ERROR: Module name is required to generate a valid JavaType\");\r\n        final String repositoryConfigurationClassIdentifier = getPathResolver().getCanonicalPath(repositoryConfigurationClass.getModule(), Path.SRC_MAIN_JAVA, repositoryConfigurationClass);\r\n        final String mid = PhysicalTypeIdentifier.createIdentifier(repositoryConfigurationClass, getPathResolver().getPath(repositoryConfigurationClassIdentifier));\r\n        if (!getFileManager().exists(repositoryConfigurationClassIdentifier)) {\r\n            final ClassOrInterfaceTypeDetailsBuilder typeBuilder = new ClassOrInterfaceTypeDetailsBuilder(mid, PUBLIC, repositoryConfigurationClass, PhysicalTypeCategory.CLASS);\r\n            AnnotationMetadataBuilder repositoryCondigurationAnnotation = new AnnotationMetadataBuilder(RooJavaType.ROO_JPA_REPOSITORY_CONFIGURATION);\r\n            typeBuilder.addAnnotation(repositoryCondigurationAnnotation);\r\n            getTypeManagementService().createOrUpdateTypeOnDisk(typeBuilder.build());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.cloud.providers.cloudfoundry.CloudFoundryProvider.updatePlugins",
	"Comment": "this method update plugins with the added to configuration.xml file",
	"Method": "void updatePlugins(String pluginConfiguration,ProjectOperations projectOperations){\r\n    Configuration conf = null;\r\n    if (StringUtils.isNotBlank(pluginConfiguration)) {\r\n        try {\r\n            DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();\r\n            DocumentBuilder docBuilder = docFactory.newDocumentBuilder();\r\n            Document doc = docBuilder.newDocument();\r\n            Element configElement = doc.createElement(\"configuration\");\r\n            String[] configurationTags = pluginConfiguration.split(\",\");\r\n            for (String configurationTag : configurationTags) {\r\n                String[] keyValue = configurationTag.split(\"=\");\r\n                if (keyValue.length == 2) {\r\n                    Element element = doc.createElement(keyValue[0]);\r\n                    element.setTextContent(keyValue[1]);\r\n                    configElement.appendChild(element);\r\n                }\r\n            }\r\n            conf = new Configuration(configElement);\r\n        } catch (Exception e) {\r\n            LOGGER.log(Level.WARNING, \"[ERROR] \" + e);\r\n        }\r\n    }\r\n    Plugin cloudFoundryMvnPlugin = new Plugin(\"org.cloudfoundry\", \"cf-maven-plugin\", \"1.0.4\", conf, null, null);\r\n    projectOperations.addBuildPlugin(projectOperations.getFocusedModuleName(), cloudFoundryMvnPlugin);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.dbre.addon.DbreDatabaseListenerImpl.getTypeManagementService",
	"Comment": "method to get typemanagementservice service implementation",
	"Method": "TypeManagementService getTypeManagementService(){\r\n    if (typeManagementService == null) {\r\n        try {\r\n            ServiceReference<?>[] references = context.getAllServiceReferences(TypeManagementService.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                typeManagementService = (TypeManagementService) context.getService(ref);\r\n                return typeManagementService;\r\n            }\r\n            return null;\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load TypeManagementService on DbreDatabaseListenerImpl.\");\r\n            return null;\r\n        }\r\n    } else {\r\n        return typeManagementService;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean.setCreateIndexesForQueryMethods",
	"Comment": "configures whether to automatically create indexes for the properties referenced in a query method.",
	"Method": "void setCreateIndexesForQueryMethods(boolean createIndexesForQueryMethods){\r\n    this.createIndexesForQueryMethods = createIndexesForQueryMethods;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.ProjectionsBenchmark.readIntoDomainTypeRestrictingToOneField",
	"Comment": "read into the domain type but restrict query to only return one field.",
	"Method": "Object readIntoDomainTypeRestrictingToOneField(){\r\n    return asPersonWithFieldsRestriction.all();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.javabean.addon.JavaBeanMetadata.getInterfaceMethod",
	"Comment": "obtains a valid methodmetadatabuilder with necessary configuration",
	"Method": "MethodMetadataBuilder getInterfaceMethod(MethodMetadata method){\r\n    final JavaSymbolName methodName = method.getMethodName();\r\n    if (governorHasMethod(methodName)) {\r\n        return null;\r\n    }\r\n    JavaType returnType = method.getReturnType();\r\n    final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    if (returnType.isPrimitive()) {\r\n        JavaType baseType = returnType.getBaseType();\r\n        if (baseType.equals(JavaType.BOOLEAN_PRIMITIVE)) {\r\n            bodyBuilder.appendFormalLine(\"return false;\");\r\n        } else if (baseType.equals(JavaType.BYTE_PRIMITIVE)) {\r\n            bodyBuilder.appendFormalLine(RETURN_0);\r\n        } else if (baseType.equals(JavaType.SHORT_PRIMITIVE)) {\r\n            bodyBuilder.appendFormalLine(RETURN_0);\r\n        } else if (baseType.equals(JavaType.INT_PRIMITIVE)) {\r\n            bodyBuilder.appendFormalLine(RETURN_0);\r\n        } else if (baseType.equals(JavaType.LONG_PRIMITIVE)) {\r\n            bodyBuilder.appendFormalLine(\"return 0l;\");\r\n        } else if (baseType.equals(JavaType.FLOAT_PRIMITIVE)) {\r\n            bodyBuilder.appendFormalLine(\"return 0.0f;\");\r\n        } else if (baseType.equals(JavaType.DOUBLE_PRIMITIVE)) {\r\n            bodyBuilder.appendFormalLine(\"return 0.00;\");\r\n        } else if (baseType.equals(JavaType.CHAR_PRIMITIVE)) {\r\n            bodyBuilder.appendFormalLine(\"return '\\0';\");\r\n        }\r\n    } else {\r\n        bodyBuilder.appendFormalLine(\"return null;\");\r\n    }\r\n    return new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, returnType, bodyBuilder);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.tailor.util.TailorHelperTest.testReplaceVarsDuplicatePlaceholders",
	"Comment": "test replacevars when there is more than one occurence of the sameplaceholder in the target",
	"Method": "void testReplaceVarsDuplicatePlaceholders(){\r\n    final CommandTransformation rooCommand = new CommandTransformation(\"project --topLevelPackage com.foo.sample --projectName test --domain otherdomainname\");\r\n    final String result = TailorHelper.replaceVars(rooCommand, \"module create --moduleName ${domain} --topLevelPackage ${topLevelPackage}.${domain}\");\r\n    final String expectedResult = \"module create --moduleName otherdomainname --topLevelPackage com.foo.sample.otherdomainname\";\r\n    Assert.assertEquals(\"Unexpected result: \" + result, expectedResult, result);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.config.ServerAddressPropertyEditorUnitTests.handleIPv6HostaddressLoopbackLong",
	"Comment": "here we detect no port since the last segment of the address contains leading zeros.",
	"Method": "void handleIPv6HostaddressLoopbackLong(){\r\n    String hostAddress = \"0000:0000:0000:0000:0000:0000:0000:0001\";\r\n    editor.setAsText(hostAddress);\r\n    assertSingleAddressWithPort(hostAddress, null, editor.getValue());\r\n}"
}, {
	"Path": "org.spongepowered.api.util.TextMessageException.getText",
	"Comment": "returns the text message for this exception, or null if nothing ispresent.",
	"Method": "Text getText(){\r\n    return this.message;\r\n}"
}, {
	"Path": "org.springframework.cloud.sleuth.instrument.messaging.ITTracingChannelInterceptor.propagatesNoopSpan",
	"Comment": "formerly known as tracechannelinterceptortest.executablespancreation",
	"Method": "void propagatesNoopSpan(){\r\n    directChannel.send(MessageBuilder.withPayload(\"hi\").setHeader(\"X-B3-Sampled\", \"0\").build());\r\n    assertThat(message.getHeaders()).containsEntry(\"X-B3-Sampled\", \"0\");\r\n    assertThat(currentSpan.isNoop()).isTrue();\r\n}"
}, {
	"Path": "spoon.test.template.testclasses.replace.NewPattern.patternModel",
	"Comment": "the body of this method contains a model of transformed code",
	"Method": "void patternModel(OldPattern.Parameters params){\r\n    elementPrinterHelper.printList(params.getIterable.S(), params.startPrefixSpace, params.start, params.startSuffixSpace, params.nextPrefixSpace, params.next, params.nextSuffixSpace, params.endPrefixSpace, params.end, v -> {\r\n        params.statements.S();\r\n    });\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaCustomAnnotationValues.getEntity",
	"Comment": "returns the entity type managed by the annotated repository",
	"Method": "JavaType getEntity(){\r\n    return entity;\r\n}"
}, {
	"Path": "org.elasticsearch.tasks.TaskManager.setBan",
	"Comment": "bans all tasks with the specified parent task from execution, cancels all tasks that are currently executing.this method is called when a parent task that has children is cancelled.",
	"Method": "void setBan(TaskId parentTaskId,String reason){\r\n    logger.trace(\"setting ban for the parent task {} {}\", parentTaskId, reason);\r\n    synchronized (banedParents) {\r\n        if (lastDiscoveryNodes.nodeExists(parentTaskId.getNodeId())) {\r\n            banedParents.put(parentTaskId, reason);\r\n        }\r\n    }\r\n    for (Map.Entry<Long, CancellableTaskHolder> taskEntry : cancellableTasks.entrySet()) {\r\n        CancellableTaskHolder holder = taskEntry.getValue();\r\n        if (holder.hasParent(parentTaskId)) {\r\n            holder.cancel(reason);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.service.addon.ServiceMetadata.getCountByReferencedFieldMethod",
	"Comment": "method that generates countbyreferencedfield method on current interface",
	"Method": "MethodMetadata getCountByReferencedFieldMethod(MethodMetadata countMethod){\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    List<AnnotatedJavaType> methodParamTypes = countMethod.getParameterTypes();\r\n    List<JavaSymbolName> methodParamNames = countMethod.getParameterNames();\r\n    for (int i = 0; i < countMethod.getParameterTypes().size(); i++) {\r\n        parameterTypes.add(methodParamTypes.get(i));\r\n        parameterNames.add(methodParamNames.get(i));\r\n    }\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC + Modifier.ABSTRACT, countMethod.getMethodName(), countMethod.getReturnType(), parameterTypes, parameterNames, null);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMVCViewResponseService.copyStaticResources",
	"Comment": "this method copy and generate all necessary resources to be ableto use thymeleaf.",
	"Method": "void copyStaticResources(Pom module){\r\n    LogicalPath resourcesPath = LogicalPath.getInstance(Path.SRC_MAIN_RESOURCES, module.getModuleName());\r\n    copyDirectoryContents(\"static/css/*.css\", getPathResolver().getIdentifier(resourcesPath, \"/static/public/css\"), true);\r\n    copyDirectoryContents(\"static/fonts/*.eot\", getPathResolver().getIdentifier(resourcesPath, \"/static/public/fonts\"), true);\r\n    copyDirectoryContents(\"static/fonts/*.svg\", getPathResolver().getIdentifier(resourcesPath, \"/static/public/fonts\"), true);\r\n    copyDirectoryContents(\"static/fonts/*.ttf\", getPathResolver().getIdentifier(resourcesPath, \"/static/public/fonts\"), true);\r\n    copyDirectoryContents(\"static/fonts/*.woff\", getPathResolver().getIdentifier(resourcesPath, \"/static/public/fonts\"), true);\r\n    copyDirectoryContents(\"static/fonts/*.woff2\", getPathResolver().getIdentifier(resourcesPath, \"/static/public/fonts\"), true);\r\n    copyDirectoryContents(\"static/img/*.ico\", getPathResolver().getIdentifier(resourcesPath, \"/static/public/img\"), false);\r\n    copyDirectoryContents(\"static/img/*.jpg\", getPathResolver().getIdentifier(resourcesPath, \"/static/public/img\"), false);\r\n    copyDirectoryContents(\"static/img/*.png\", getPathResolver().getIdentifier(resourcesPath, \"/static/public/img\"), false);\r\n    copyDirectoryContents(\"static/img/*.gif\", getPathResolver().getIdentifier(resourcesPath, \"/static/public/img\"), false);\r\n    copyDirectoryContents(\"static/js/*.js\", getPathResolver().getIdentifier(resourcesPath, \"/static/public/js\"), true);\r\n    copyDirectoryContents(\"templates/fragments/js/*.html\", getPathResolver().getIdentifier(resourcesPath, \"/templates/fragments/js\"), true);\r\n    copyDirectoryContents(\"templates/fragments/js/*.js\", getPathResolver().getIdentifier(resourcesPath, \"/templates/fragments/js\"), true);\r\n    copyDirectoryContents(\"templates/reports/*.jrxml\", getPathResolver().getIdentifier(resourcesPath, \"/templates/reports\"), true);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.JpaOperationsImpl.getVersionField",
	"Comment": "this method generates the version field using the provided values",
	"Method": "FieldMetadata getVersionField(JavaType entity,String versionField,JavaType versionType,String versionColumn){\r\n    if (StringUtils.isEmpty(versionField)) {\r\n        versionField = \"version\";\r\n    }\r\n    final List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n    annotations.add(new AnnotationMetadataBuilder(VERSION));\r\n    if (StringUtils.isNotEmpty(versionColumn)) {\r\n        final AnnotationMetadataBuilder columnBuilder = new AnnotationMetadataBuilder(COLUMN);\r\n        columnBuilder.addStringAttribute(\"name\", versionColumn);\r\n        annotations.add(columnBuilder);\r\n    }\r\n    FieldDetails versionFieldDetails = new FieldDetails(getTypeLocationService().getPhysicalTypeIdentifier(entity), versionType, new JavaSymbolName(versionField));\r\n    versionFieldDetails.setModifiers(Modifier.PRIVATE);\r\n    versionFieldDetails.addAnnotations(annotations);\r\n    return new FieldMetadataBuilder(versionFieldDetails).build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.service.addon.ServiceMetadata.getReferencedFieldsFindAllDefinedMethods",
	"Comment": "this method returns all defined findall methods for referenced fields inservice interface",
	"Method": "Map<FieldMetadata, MethodMetadata> getReferencedFieldsFindAllDefinedMethods(){\r\n    return this.referencedFieldsFindAllDefinedMethods;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.template.engines.AbstractFreeMarkerViewGenerationService.copyDirectoryContents",
	"Comment": "this method will copy the contents of a directory to another if theresource does not already exist in the target directory",
	"Method": "void copyDirectoryContents(String sourceAntPath,String targetDirectory,boolean replace){\r\n    Validate.notBlank(sourceAntPath, \"Source path required\");\r\n    Validate.notBlank(targetDirectory, \"Target directory required\");\r\n    if (!targetDirectory.endsWith(\"/\")) {\r\n        targetDirectory += \"/\";\r\n    }\r\n    if (!fileManager.exists(targetDirectory)) {\r\n        fileManager.createDirectory(targetDirectory);\r\n    }\r\n    final String path = FileUtils.getPath(getClass(), sourceAntPath);\r\n    final Iterable<URL> urls = OSGiUtils.findEntriesByPattern(context, path);\r\n    Validate.notNull(urls, \"Could not search bundles for resources for Ant Path '%s'\", path);\r\n    for (final URL url : urls) {\r\n        final String fileName = url.getPath().substring(url.getPath().lastIndexOf(\"/\") + 1);\r\n        if (replace) {\r\n            try {\r\n                String contents = IOUtils.toString(url);\r\n                fileManager.createOrUpdateTextFileIfRequired(targetDirectory + fileName, contents, false);\r\n            } catch (final Exception e) {\r\n                throw new IllegalStateException(e);\r\n            }\r\n        } else {\r\n            if (!fileManager.exists(targetDirectory + fileName)) {\r\n                InputStream inputStream = null;\r\n                OutputStream outputStream = null;\r\n                try {\r\n                    inputStream = url.openStream();\r\n                    outputStream = fileManager.createFile(targetDirectory + fileName).getOutputStream();\r\n                    IOUtils.copy(inputStream, outputStream);\r\n                } catch (final Exception e) {\r\n                    throw new IllegalStateException(\"Encountered an error during copying of resources for the add-on.\", e);\r\n                } finally {\r\n                    IOUtils.closeQuietly(inputStream);\r\n                    IOUtils.closeQuietly(outputStream);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.responses.json.JSONMVCResponseService.isInstalledInModule",
	"Comment": "this operation checks if this feature is installed in module.json is installed in module if spring mvc has been installed before.",
	"Method": "boolean isInstalledInModule(String moduleName){\r\n    return getProjectOperations().isFeatureInstalled(FeatureNames.MVC);\r\n}"
}, {
	"Path": "org.spongepowered.api.world.WorldBorder.copyPropertiesFrom",
	"Comment": "copies the properties of the passed border onto this border.",
	"Method": "void copyPropertiesFrom(WorldBorder border){\r\n    setCenter(border.getCenter().getX(), border.getCenter().getZ());\r\n    setDamageAmount(border.getDamageAmount());\r\n    setDamageThreshold(border.getDamageThreshold());\r\n    setDiameter(border.getDiameter(), border.getNewDiameter(), border.getTimeRemaining());\r\n    setWarningDistance(border.getWarningDistance());\r\n    setWarningTime(border.getWarningTime());\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.schema.UntypedJsonSchemaObject.anyOf",
	"Comment": "the field value must match at least one of the specified schemas.",
	"Method": "UntypedJsonSchemaObject anyOf(Collection<JsonSchemaObject> anyOf,Restrictions anyOf,Collection<JsonSchemaObject> anyOf){\r\n    return new UntypedJsonSchemaObject(restrictions.anyOf(anyOf), description, generateDescription);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.pushin.PushInOperationsImpl.getMemberDetailsScanner",
	"Comment": "method to obtain memberdetailsscanner service implementation",
	"Method": "MemberDetailsScanner getMemberDetailsScanner(){\r\n    return serviceManager.getServiceInstance(this, MemberDetailsScanner.class);\r\n}"
}, {
	"Path": "spoon.compiler.SpoonFile.getContentChars",
	"Comment": "gets the file content as a char array, considering encoding or encoding\tprovider.",
	"Method": "char[] getContentChars(Environment env){\r\n    byte[] bytes;\r\n    try (InputStream contentStream = getContent()) {\r\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\r\n        IOUtils.copy(contentStream, outputStream);\r\n        bytes = outputStream.toByteArray();\r\n    } catch (IOException e) {\r\n        throw new SpoonException(e);\r\n    }\r\n    if (env.getEncodingProvider() == null) {\r\n        return new String(bytes, env.getEncoding()).toCharArray();\r\n    } else {\r\n        Charset encoding = env.getEncodingProvider().detectEncoding(this, bytes);\r\n        return new String(bytes, encoding).toCharArray();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Part.hasProperty",
	"Comment": "returns true if the part or search criteria has a property defined",
	"Method": "boolean hasProperty(){\r\n    return property != null;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.TextCriteria.diacriticSensitive",
	"Comment": "optionally enable or disable diacritic sensitive search against version 3 text indexes.",
	"Method": "TextCriteria diacriticSensitive(boolean diacriticSensitive){\r\n    this.diacriticSensitive = diacriticSensitive;\r\n    return this;\r\n}"
}, {
	"Path": "org.elasticsearch.tasks.TaskManager.getCancellableTasks",
	"Comment": "returns the list of currently running tasks on the node that can be cancelled",
	"Method": "Map<Long, CancellableTask> getCancellableTasks(){\r\n    HashMap<Long, CancellableTask> taskHashMap = new HashMap();\r\n    for (CancellableTaskHolder holder : cancellableTasks.values()) {\r\n        taskHashMap.put(holder.getTask().getId(), holder.getTask());\r\n    }\r\n    return Collections.unmodifiableMap(taskHashMap);\r\n}"
}, {
	"Path": "org.springframework.data.redis.core.TimeoutUtils.toMillis",
	"Comment": "converts the given timeout to milliseconds.\tsince a 0 timeout blocks some redis ops indefinitely, this method will return 1 if the original value is greater\tthan 0 but is truncated to 0 on conversion.",
	"Method": "long toMillis(long timeout,TimeUnit unit){\r\n    return roundUpIfNecessary(timeout, unit.toMillis(timeout));\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Collation.numericOrdering",
	"Comment": "set the flag that determines whether to compare numeric strings as numbers or as strings.",
	"Method": "Collation numericOrdering(boolean flag){\r\n    Collation newInstance = copy();\r\n    newInstance.numericOrdering = Optional.of(flag);\r\n    return newInstance;\r\n}"
}, {
	"Path": "spoon.support.sniper.internal.AbstractSourceFragmentContext.findIndexOfNextChildTokenByValue",
	"Comment": "looks for next child token which contains exactly same token",
	"Method": "int findIndexOfNextChildTokenByValue(String token){\r\n    return findIndexOfNextFragment(childFragments, childFragmentIdx + 1, fragment -> Objects.equals(token, fragment.getSourceCode()));\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.JDTTreeBuilderHelper.createTypeAccess",
	"Comment": "creates a type access from its qualified name and with a field reference.",
	"Method": "CtTypeAccess<?> createTypeAccess(QualifiedNameReference qualifiedNameReference,CtFieldReference<?> fieldReference){\r\n    final TypeBinding receiverType = qualifiedNameReference.actualReceiverType;\r\n    if (receiverType != null) {\r\n        final CtTypeReference<Object> qualifiedRef = jdtTreeBuilder.getReferencesBuilder().getQualifiedTypeReference(qualifiedNameReference.tokens, receiverType, qualifiedNameReference.fieldBinding().declaringClass.enclosingType(), new JDTTreeBuilder.OnAccessListener() {\r\n            @Override\r\n            public boolean onAccess(char[][] tokens, int index) {\r\n                return !CharOperation.equals(tokens[index + 1], tokens[tokens.length - 1]);\r\n            }\r\n        });\r\n        if (qualifiedRef != null) {\r\n            fieldReference.setDeclaringType(qualifiedRef);\r\n        } else {\r\n            fieldReference.setDeclaringType(jdtTreeBuilder.getReferencesBuilder().getTypeReference(receiverType));\r\n        }\r\n    }\r\n    CtTypeAccess<?> typeAccess = jdtTreeBuilder.getFactory().Code().createTypeAccess(fieldReference.getDeclaringType());\r\n    if (qualifiedNameReference.indexOfFirstFieldBinding > 1) {\r\n        long[] positions = qualifiedNameReference.sourcePositions;\r\n        typeAccess.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(qualifiedNameReference.sourceStart(), (int) (positions[qualifiedNameReference.indexOfFirstFieldBinding - 1] >>> 32) - 2));\r\n    } else {\r\n        typeAccess.setImplicit(qualifiedNameReference.isImplicitThis());\r\n    }\r\n    return typeAccess;\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.JDTTreeBuilderHelper.createTypeAccess",
	"Comment": "creates a type access from its qualified name and with a field reference.",
	"Method": "CtTypeAccess<?> createTypeAccess(QualifiedNameReference qualifiedNameReference,CtFieldReference<?> fieldReference){\r\n    return !CharOperation.equals(tokens[index + 1], tokens[tokens.length - 1]);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Collation.forwardDiacriticSort",
	"Comment": "do not sort string with diacritics sort from back of the string.",
	"Method": "Collation forwardDiacriticSort(){\r\n    return backwards(false);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Meta.setMaxTimeMsec",
	"Comment": "set the maximum time limit in milliseconds for processing operations.",
	"Method": "void setMaxTimeMsec(long maxTimeMsec){\r\n    setMaxTime(Duration.ofMillis(maxTimeMsec));\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.JDTCommentBuilder.addCommentToNear",
	"Comment": "insert the element to nearer element in the elements collections",
	"Method": "CtElement addCommentToNear(CtComment comment,Collection<CtElement> elements){\r\n    CtElement best = null;\r\n    int smallDistance = Integer.MAX_VALUE;\r\n    for (CtElement element : elements) {\r\n        if (element.getPosition().isValidPosition() == false) {\r\n            continue;\r\n        }\r\n        if (element.isImplicit()) {\r\n            continue;\r\n        }\r\n        if (element instanceof CtComment) {\r\n            continue;\r\n        }\r\n        final boolean isAfter = element.getPosition().getSourceEnd() < comment.getPosition().getSourceStart();\r\n        int distance = Math.abs(element.getPosition().getSourceStart() - comment.getPosition().getSourceEnd());\r\n        if (isAfter) {\r\n            distance = Math.abs(element.getPosition().getSourceEnd() - comment.getPosition().getSourceStart());\r\n        }\r\n        int elementEndLine = element.getPosition().getEndLine();\r\n        int commentLine = comment.getPosition().getLine();\r\n        if (distance < smallDistance && (!isAfter || elementEndLine == commentLine || element instanceof CtType)) {\r\n            best = element;\r\n            smallDistance = distance;\r\n        }\r\n    }\r\n    if (best != null) {\r\n        best.addComment(comment);\r\n    }\r\n    return best;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.cache.CacheOperationsImpl.getTypeManagementService",
	"Comment": "method to obtain typemanagementservice service implementation",
	"Method": "TypeManagementService getTypeManagementService(){\r\n    if (typeManagementService == null) {\r\n        try {\r\n            ServiceReference<?>[] references = context.getAllServiceReferences(TypeManagementService.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                typeManagementService = (TypeManagementService) context.getService(ref);\r\n                return typeManagementService;\r\n            }\r\n            return null;\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load TypeManagementService on PushInOperationsImpl.\");\r\n            return null;\r\n        }\r\n    } else {\r\n        return typeManagementService;\r\n    }\r\n}"
}, {
	"Path": "daikon.tools.InvariantChecker.mainHelper",
	"Comment": "this does the work of main, but it never calls system.exit, so itis appropriate to be called progrmmatically.termination of the program with a message to the user is indicated bythrowing daikon.terminationmessage.",
	"Method": "void mainHelper(String[] args){\r\n    daikon.LogHelper.setupLogs(daikon.LogHelper.INFO);\r\n    LongOpt[] longopts = new LongOpt[] { new LongOpt(Daikon.config_option_SWITCH, LongOpt.REQUIRED_ARGUMENT, null, 0), new LongOpt(output_SWITCH, LongOpt.REQUIRED_ARGUMENT, null, 0), new LongOpt(dir_SWITCH, LongOpt.REQUIRED_ARGUMENT, null, 0), new LongOpt(conf_SWITCH, LongOpt.NO_ARGUMENT, null, 0), new LongOpt(filter_SWITCH, LongOpt.NO_ARGUMENT, null, 0), new LongOpt(Daikon.debugAll_SWITCH, LongOpt.NO_ARGUMENT, null, 0), new LongOpt(Daikon.debug_SWITCH, LongOpt.REQUIRED_ARGUMENT, null, 0), new LongOpt(Daikon.ppt_regexp_SWITCH, LongOpt.REQUIRED_ARGUMENT, null, 0), new LongOpt(Daikon.track_SWITCH, LongOpt.REQUIRED_ARGUMENT, null, 0) };\r\n    Getopt g = new Getopt(\"daikon.tools.InvariantChecker\", args, \"h\", longopts);\r\n    int c;\r\n    while ((c = g.getopt()) != -1) {\r\n        switch(c) {\r\n            case 0:\r\n                String option_name = longopts[g.getLongind()].getName();\r\n                if (Daikon.help_SWITCH.equals(option_name)) {\r\n                    System.out.println(usage);\r\n                    throw new Daikon.TerminationMessage();\r\n                } else if (conf_SWITCH.equals(option_name)) {\r\n                    doConf = true;\r\n                } else if (filter_SWITCH.equals(option_name)) {\r\n                    doFilter = true;\r\n                } else if (dir_SWITCH.equals(option_name)) {\r\n                    dir_file = new File(g.getOptarg());\r\n                    if (!dir_file.exists() || !dir_file.isDirectory())\r\n                        throw new Daikon.TerminationMessage(\"Error reading the directory \" + dir_file);\r\n                } else if (output_SWITCH.equals(option_name)) {\r\n                    output_file = new File(g.getOptarg());\r\n                    output_stream = new PrintStream(new FileOutputStream(output_file));\r\n                } else if (Daikon.config_option_SWITCH.equals(option_name)) {\r\n                    String item = g.getOptarg();\r\n                    daikon.config.Configuration.getInstance().apply(item);\r\n                    break;\r\n                } else if (Daikon.debugAll_SWITCH.equals(option_name)) {\r\n                    Global.debugAll = true;\r\n                } else if (Daikon.debug_SWITCH.equals(option_name)) {\r\n                    LogHelper.setLevel(g.getOptarg(), LogHelper.FINE);\r\n                } else if (Daikon.track_SWITCH.equals(option_name)) {\r\n                    LogHelper.setLevel(\"daikon.Debug\", LogHelper.FINE);\r\n                    String error = Debug.add_track(g.getOptarg());\r\n                    if (error != null) {\r\n                        throw new Daikon.TerminationMessage(\"Error parsing track argument '\" + g.getOptarg() + \"' - \" + error);\r\n                    }\r\n                } else {\r\n                    throw new RuntimeException(\"Unknown long option received: \" + option_name);\r\n                }\r\n                break;\r\n            case 'h':\r\n                System.out.println(usage);\r\n                throw new Daikon.TerminationMessage();\r\n            case '?':\r\n                break;\r\n            default:\r\n                System.out.println(\"getopt() returned \" + c);\r\n                break;\r\n        }\r\n    }\r\n    for (int i = g.getOptind(); i < args.length; i++) {\r\n        File file = new File(args[i]);\r\n        if (!file.exists()) {\r\n            throw new Error(\"File \" + file + \" not found.\");\r\n        }\r\n        String filename = file.toString();\r\n        if (filename.indexOf(\".inv\") != -1) {\r\n            if (inv_file != null) {\r\n                throw new Daikon.TerminationMessage(\"multiple inv files specified\", usage);\r\n            }\r\n            inv_file = file;\r\n        } else if (filename.indexOf(\".dtrace\") != -1) {\r\n            dtrace_files.add(filename);\r\n        } else {\r\n            throw new Error(\"Unrecognized argument: \" + file);\r\n        }\r\n    }\r\n    if (dir_file == null) {\r\n        checkInvariants();\r\n        return;\r\n    }\r\n    File[] filesInDir = dir_file.listFiles();\r\n    if (filesInDir == null || filesInDir.length == 0)\r\n        throw new Daikon.TerminationMessage(\"The directory \" + dir_file + \" is empty\", usage);\r\n    ArrayList<File> invariants = new ArrayList<File>();\r\n    for (File f : filesInDir) if (f.toString().indexOf(\".inv\") != -1)\r\n        invariants.add(f);\r\n    if (invariants.size() == 0)\r\n        throw new Daikon.TerminationMessage(\"Did not find any invariant files in the directory \" + dir_file, usage);\r\n    ArrayList<File> dtraces = new ArrayList<File>();\r\n    for (File f : filesInDir) if (f.toString().indexOf(\".dtrace\") != -1)\r\n        dtraces.add(f);\r\n    if (dtraces.size() == 0)\r\n        throw new Daikon.TerminationMessage(\"Did not find any dtrace files in the directory \" + dir_file, usage);\r\n    System.out.println(\"Collecting data for invariants files \" + invariants + \" and dtrace files \" + dtraces);\r\n    dtrace_files.clear();\r\n    for (File dtrace : dtraces) {\r\n        dtrace_files.add(dtrace.toString());\r\n    }\r\n    String commaLine = \"\";\r\n    for (File inFile : invariants) {\r\n        String name = inFile.getName().replace(\".inv\", \"\").replace(\".gz\", \"\");\r\n        commaLine += \",\" + name;\r\n    }\r\n    outputComma.add(commaLine);\r\n    commaLine = \"\";\r\n    for (File inFile : invariants) {\r\n        inv_file = inFile;\r\n        failedInvariants.clear();\r\n        testedInvariants.clear();\r\n        error_cnt = 0;\r\n        output_stream = new PrintStream(new FileOutputStream(inFile.toString().replace(\".inv\", \"\").replace(\".gz\", \"\") + \".false-positives.txt\"));\r\n        checkInvariants();\r\n        output_stream.close();\r\n        int failedCount = failedInvariants.size();\r\n        int testedCount = testedInvariants.size();\r\n        String percent = toPercentage(failedCount, testedCount);\r\n        commaLine += \",\" + percent;\r\n    }\r\n    outputComma.add(commaLine);\r\n    System.out.println();\r\n    for (String output : outputComma) System.out.println(output);\r\n}"
}, {
	"Path": "daikon.FileIO.parse_ppt_flags",
	"Comment": "parses a program point flag record.adds any specified flags toto flags.",
	"Method": "void parse_ppt_flags(ParseState state,Scanner scanner,EnumSet<PptFlags> flags){\r\n    flags.add(parse_enum_val(state, scanner, PptFlags.class, \"ppt flags\"));\r\n    while (scanner.hasNext()) flags.add(parse_enum_val(state, scanner, PptFlags.class, \"ppt flags\"));\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform3.getMatrix",
	"Comment": "returns the matrix representation of the transform.it is 4d to allow it to include a translation.",
	"Method": "Matrix4d getMatrix(){\r\n    return this.matrix;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.service.addon.ServiceMetadata.getCountByReferenceFieldDefinedMethod",
	"Comment": "this method returns all defined count methods inservice interface",
	"Method": "Map<FieldMetadata, MethodMetadata> getCountByReferenceFieldDefinedMethod(MethodMetadata getCountByReferenceFieldDefinedMethod,String fieldName){\r\n    for (Entry<FieldMetadata, MethodMetadata> entry : this.countByReferenceFieldDefinedMethod.entrySet()) {\r\n        if (entry.getKey().getFieldName().getSymbolName().equals(fieldName)) {\r\n            return entry.getValue();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.Extent.getPrecipitationLevelAt",
	"Comment": "returns the position that precipitation ends falling in the columnof the given position.a position is still returned for positions in biomes which do notreceive precipitation.",
	"Method": "int getPrecipitationLevelAt(int x,int z,int getPrecipitationLevelAt,Vector2i column,Vector3i getPrecipitationLevelAt,Vector3i position){\r\n    return new Vector3i(position.getX(), this.getPrecipitationLevelAt(position.getX(), position.getZ()), position.getZ());\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.MongoClientOptionsFactoryBean.setHeartbeatFrequency",
	"Comment": "set the frequency that the driver will attempt to determine the current state of each server in the cluster.",
	"Method": "void setHeartbeatFrequency(int heartbeatFrequency){\r\n    this.heartbeatFrequency = heartbeatFrequency;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.PartTree.extractRelatedEntityValidProperty",
	"Comment": "gets the property of a related entity, using raw property information.",
	"Method": "Pair<Stack<FieldMetadata>, String> extractRelatedEntityValidProperty(String extractProperty,FieldMetadata referenceProperty,Stack<FieldMetadata> path){\r\n    if (StringUtils.isBlank(extractProperty) || referenceProperty == null) {\r\n        return null;\r\n    }\r\n    String property = StringUtils.substringAfter(extractProperty, referenceProperty.getFieldName().toString());\r\n    if (StringUtils.isBlank(property)) {\r\n        return null;\r\n    }\r\n    return extractValidProperty(property, getValidProperties(referenceProperty.getFieldType()), path);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.convert.QueryMapper.getMappedKeyword",
	"Comment": "returns the mapped keyword considered defining a criteria for the given property.",
	"Method": "Document getMappedKeyword(Keyword keyword,MongoPersistentEntity<?> entity,Document getMappedKeyword,Field property,Keyword keyword){\r\n    boolean needsAssociationConversion = property.isAssociation() && !keyword.isExists() && keyword.mayHoldDbRef();\r\n    Object value = keyword.getValue();\r\n    Object convertedValue = needsAssociationConversion ? convertAssociation(value, property) : getMappedValue(property.with(keyword.getKey()), value);\r\n    return new Document(keyword.key, convertedValue);\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.RepositoryRestHandlerMapping.getRepositoryBasePath",
	"Comment": "returns the first segment of the given repository lookup path.",
	"Method": "String getRepositoryBasePath(String repositoryLookupPath){\r\n    int secondSlashIndex = repositoryLookupPath.indexOf('/', repositoryLookupPath.startsWith(\"/\") ? 1 : 0);\r\n    return secondSlashIndex == -1 ? repositoryLookupPath : repositoryLookupPath.substring(0, secondSlashIndex);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafUIConfigurationMetadata.getJavascriptTemplateResolverMethod",
	"Comment": "returns method which configure springresourcetemplateresolve",
	"Method": "MethodMetadata getJavascriptTemplateResolverMethod(){\r\n    final JavaSymbolName methodName = new JavaSymbolName(\"javascriptTemplateResolver\");\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    final List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    final List<AnnotationMetadataBuilder> annotations = new ArrayList<AnnotationMetadataBuilder>();\r\n    annotations.add(new AnnotationMetadataBuilder(SpringJavaType.BEAN));\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    bodyBuilder.appendFormalLine(\"%1$s resolver = new %1$s();\", getNameOfJavaType(SPRING_RESOURCE_TEMPLATE_RESOLVER));\r\n    bodyBuilder.appendFormalLine(\"resolver.setApplicationContext(%s());\", getAccessorMethod(this.applicationContextAwareField).getMethodName());\r\n    bodyBuilder.appendFormalLine(\"resolver.setPrefix(\\\"classpath:/templates/fragments/js/\\\");\");\r\n    bodyBuilder.appendFormalLine(\"resolver.setTemplateMode(%s.JAVASCRIPT);\", getNameOfJavaType(TEMPLATE_MODE));\r\n    bodyBuilder.appendFormalLine(\"resolver.setCharacterEncoding(\\\"UTF-8\\\");\");\r\n    bodyBuilder.appendFormalLine(\"resolver.setCheckExistence(true);\");\r\n    bodyBuilder.appendFormalLine(\"resolver.setCacheable(%s().isCache());\", getAccessorMethod(this.thymeleafPropertiesField).getMethodName());\r\n    bodyBuilder.appendFormalLine(\"return resolver;\");\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, SPRING_RESOURCE_TEMPLATE_RESOLVER, parameterTypes, parameterNames, bodyBuilder);\r\n    methodBuilder.setAnnotations(annotations);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.util.MongoDbErrorCodes.isTransactionFailureCode",
	"Comment": "check if the given error code matches a know transaction related error.",
	"Method": "boolean isTransactionFailureCode(Integer errorCode){\r\n    return errorCode == null ? false : transactionCodes.containsKey(errorCode);\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.json.EnumTranslator.fromDefault",
	"Comment": "tries to obtain an enum value assuming the given text is a default translation of the enum name.",
	"Method": "T fromDefault(Class<T> type,String text){\r\n    return resolveEnum(type, text.toUpperCase(Locale.US).replaceAll(\" \", \"_\"), true);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.mapreduce.MapReduceOptions.outputTypeReplace",
	"Comment": "the output will be inserted into a collection which will atomically replace any existing collection with the same\tname. note, the default is mapreducecommand.outputtype.replace",
	"Method": "MapReduceOptions outputTypeReplace(){\r\n    this.outputType = MapReduceCommand.OutputType.REPLACE;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.json.patch.SpelPath.getLeafType",
	"Comment": "returns the leaf type of the underlying expression or the given type",
	"Method": "Class<?> getLeafType(Class<?> type){\r\n    return // \r\n    TypedSpelPath.verifyPath(path, type).<\// \r\n    Class<?>>map(it -> it.getType()).orElse(type);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.jpa.addon.test.JpaTestCreator.getValidDataOnDemandCreatorsForType",
	"Comment": "gets all the valid implementations of dataondemandcreatorprovider for a javatype.",
	"Method": "List<DataOnDemandCreatorProvider> getValidDataOnDemandCreatorsForType(JavaType type){\r\n    if (this.dodCreators.isEmpty()) {\r\n        try {\r\n            ServiceReference<?>[] references = this.context.getAllServiceReferences(DataOnDemandCreatorProvider.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                DataOnDemandCreatorProvider dodCreatorProvider = (DataOnDemandCreatorProvider) this.context.getService(ref);\r\n                this.dodCreators.add(dodCreatorProvider);\r\n            }\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load DataOnDemandCreatorProvider on TestOperationsImpl.\");\r\n            return null;\r\n        }\r\n    }\r\n    List<DataOnDemandCreatorProvider> validDoDCreators = new ArrayList<DataOnDemandCreatorProvider>();\r\n    for (DataOnDemandCreatorProvider provider : this.dodCreators) {\r\n        if (provider.isValid(type)) {\r\n            validDoDCreators.add(provider);\r\n        }\r\n    }\r\n    return validDoDCreators;\r\n}"
}, {
	"Path": "spoon.template.AbstractTemplate.getFactory",
	"Comment": "returns a spoon factory object from the first template parameter that contains one",
	"Method": "Factory getFactory(){\r\n    return Substitution.getFactory(this);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.mapreduce.GroupBy.reduceFunction",
	"Comment": "define the aggregation function that operates on the documents during the grouping operation",
	"Method": "GroupBy reduceFunction(String reduceFunction){\r\n    reduce = reduceFunction;\r\n    return this;\r\n}"
}, {
	"Path": "org.spongepowered.api.world.storage.ChunkLayout.isValidChunk",
	"Comment": "returns true if the coordinates are valid chunk coordinates. false ifotherwise.",
	"Method": "boolean isValidChunk(Vector3i coords,boolean isValidChunk,int x,int y,int z){\r\n    return x >= getSpaceMin().getX() && x <= getSpaceMax().getX() && y >= getSpaceMin().getY() && y <= getSpaceMax().getY() && z >= getSpaceMin().getZ() && z <= getSpaceMax().getZ();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.exceptions.addon.ExceptionsOperationsImpl.addExceptionLabel",
	"Comment": "writes a label with a default exception message on messages.properties files",
	"Method": "void addExceptionLabel(JavaType exception,String moduleName){\r\n    if (getProjectOperations().isMultimoduleProject()) {\r\n        Validate.notBlank(moduleName, \"Module name is required\");\r\n    }\r\n    final LogicalPath resourcesPath = LogicalPath.getInstance(Path.SRC_MAIN_RESOURCES, moduleName);\r\n    final String targetDirectory = getPathResolver().getIdentifier(resourcesPath, \"\");\r\n    final String exceptionName = exception.getSimpleTypeName();\r\n    final String labelKey = LABEL_PREFIX.concat(exceptionName.toLowerCase());\r\n    Set<I18n> supportedLanguages = getI18nSupport().getSupportedLanguages();\r\n    for (I18n i18n : supportedLanguages) {\r\n        String messageBundle = String.format(\"messages_%s.properties\", i18n.getLocale().getLanguage());\r\n        String bundlePath = String.format(\"%s%s%s\", targetDirectory, AntPathMatcher.DEFAULT_PATH_SEPARATOR, messageBundle);\r\n        if (getFileManager().exists(bundlePath)) {\r\n            getPropFilesManager().addPropertyIfNotExists(resourcesPath, messageBundle, labelKey, String.format(LABEL_MESSAGE, exceptionName), true);\r\n        }\r\n    }\r\n    getPropFilesManager().addPropertyIfNotExists(resourcesPath, \"messages.properties\", labelKey, String.format(LABEL_MESSAGE, exceptionName), true);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerOperationsImpl.getAllMethodsToPublish",
	"Comment": "get all the methods that can be published from the service or thecontroller established by parameter",
	"Method": "List<String> getAllMethodsToPublish(String currentService,String currentController){\r\n    List<String> serviceMethodsToPublish = new ArrayList<String>();\r\n    List<ClassOrInterfaceTypeDetails> servicesToPublish = new ArrayList<ClassOrInterfaceTypeDetails>();\r\n    if (StringUtils.isEmpty(currentService)) {\r\n        Collection<ClassOrInterfaceTypeDetails> controllers = getTypeLocationService().findClassesOrInterfaceDetailsWithAnnotation(RooJavaType.ROO_CONTROLLER);\r\n        for (ClassOrInterfaceTypeDetails controller : controllers) {\r\n            String name = getClasspathOperations().replaceTopLevelPackageString(controller, currentController);\r\n            if (currentController.equals(name)) {\r\n                AnnotationMetadata controllerAnnotation = controller.getAnnotation(RooJavaType.ROO_CONTROLLER);\r\n                JavaType entity = (JavaType) controllerAnnotation.getAttribute(ENTITY_KEY).getValue();\r\n                Set<ClassOrInterfaceTypeDetails> services = getTypeLocationService().findClassesOrInterfaceDetailsWithAnnotation(RooJavaType.ROO_SERVICE);\r\n                Iterator<ClassOrInterfaceTypeDetails> itServices = services.iterator();\r\n                while (itServices.hasNext()) {\r\n                    ClassOrInterfaceTypeDetails existingService = itServices.next();\r\n                    AnnotationAttributeValue<Object> entityAttr = existingService.getAnnotation(RooJavaType.ROO_SERVICE).getAttribute(ENTITY_KEY);\r\n                    if (entityAttr != null && entityAttr.getValue().equals(entity)) {\r\n                        servicesToPublish.add(existingService);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        Set<ClassOrInterfaceTypeDetails> services = getTypeLocationService().findClassesOrInterfaceDetailsWithAnnotation(RooJavaType.ROO_SERVICE);\r\n        for (ClassOrInterfaceTypeDetails service : services) {\r\n            String name = getClasspathOperations().replaceTopLevelPackageString(service, currentService);\r\n            if (currentService.equals(name)) {\r\n                servicesToPublish.add(service);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    for (ClassOrInterfaceTypeDetails serviceToPublish : servicesToPublish) {\r\n        final ServiceMetadata serviceMetadata = getMetadataService().get(ServiceMetadata.createIdentifier(serviceToPublish));\r\n        List<MethodMetadata> methodsImplementedByRoo = new ArrayList<MethodMetadata>();\r\n        methodsImplementedByRoo.addAll(serviceMetadata.getNotTransactionalDefinedMethods());\r\n        methodsImplementedByRoo.addAll(serviceMetadata.getTransactionalDefinedMethods());\r\n        List<MethodMetadata> methods = serviceToPublish.getMethods();\r\n        boolean notGeneratedByRoo;\r\n        for (MethodMetadata method : methods) {\r\n            notGeneratedByRoo = true;\r\n            Iterator<MethodMetadata> iterMethodsImplRoo = methodsImplementedByRoo.iterator();\r\n            while (iterMethodsImplRoo.hasNext() && notGeneratedByRoo) {\r\n                MethodMetadata methodImplementedByRoo = iterMethodsImplRoo.next();\r\n                if (method.getMethodName().equals(methodImplementedByRoo.getMethodName())) {\r\n                    if (method.getParameterTypes().size() == methodImplementedByRoo.getParameterTypes().size()) {\r\n                        Iterator<AnnotatedJavaType> iterParameterTypesMethodRoo = methodImplementedByRoo.getParameterTypes().iterator();\r\n                        boolean allParametersAreEquals = true;\r\n                        for (AnnotatedJavaType parameterType : method.getParameterTypes()) {\r\n                            AnnotatedJavaType parameterTypeMethodRoo = iterParameterTypesMethodRoo.next();\r\n                            if (!parameterType.getJavaType().equals(parameterTypeMethodRoo.getJavaType())) {\r\n                                allParametersAreEquals = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (allParametersAreEquals) {\r\n                            notGeneratedByRoo = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (notGeneratedByRoo) {\r\n                StringBuilder methodNameBuffer = new StringBuilder();\r\n                if (StringUtils.isEmpty(currentService)) {\r\n                    methodNameBuffer.append(getClasspathOperations().replaceTopLevelPackage(serviceToPublish)).append(\".\");\r\n                }\r\n                methodNameBuffer.append(method.getMethodName().getSymbolName());\r\n                List<AnnotatedJavaType> parameterTypes = method.getParameterTypes();\r\n                methodNameBuffer = methodNameBuffer.append(\"(\");\r\n                for (int i = 0; i < parameterTypes.size(); i++) {\r\n                    String paramType = parameterTypes.get(i).getJavaType().getSimpleTypeName();\r\n                    methodNameBuffer = methodNameBuffer.append(paramType).append(\",\");\r\n                }\r\n                String methodName;\r\n                if (!parameterTypes.isEmpty()) {\r\n                    methodName = methodNameBuffer.toString().substring(0, methodNameBuffer.toString().length() - 1).concat(\")\");\r\n                } else {\r\n                    methodName = methodNameBuffer.append(\")\").toString();\r\n                }\r\n                serviceMethodsToPublish.add(methodName);\r\n            }\r\n        }\r\n    }\r\n    return serviceMethodsToPublish;\r\n}"
}, {
	"Path": "daikon.Daikon.init_ppt",
	"Comment": "create combined exit points, setup splitters, and add orig andderived variables,",
	"Method": "void init_ppt(PptTopLevel ppt,PptMap all_ppts){\r\n    if (!Daikon.using_DaikonSimple) {\r\n        if (!(ppt instanceof PptConditional)) {\r\n            setup_splitters(ppt);\r\n        }\r\n    }\r\n    progress = \"Creating orig variables for: \" + ppt.name;\r\n    create_orig_vars(ppt, all_ppts);\r\n    if (!Derivation.dkconfig_disable_derived_variables) {\r\n        progress = \"Creating derived variables for: \" + ppt.name;\r\n        ppt.create_derived_variables();\r\n    }\r\n    if (!Daikon.using_DaikonSimple) {\r\n        setupEquality(ppt);\r\n        if (ppt.has_splitters()) {\r\n            for (Iterator<PptConditional> ii = ppt.cond_iterator(); ii.hasNext(); ) {\r\n                PptConditional ppt_cond = ii.next();\r\n                init_ppt(ppt_cond, all_ppts);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.stream.ReadOffset.lastConsumed",
	"Comment": "read all new arriving elements with ids greater than the last one consumed by the consumer group.",
	"Method": "ReadOffset lastConsumed(){\r\n    return new ReadOffset(\">\");\r\n}"
}, {
	"Path": "org.spongepowered.api.world.storage.ChunkLayout.forceToWorld",
	"Comment": "converts chunk coordinates to world coordinates. this method never failsand can returns invalid world coordinates.",
	"Method": "Vector3i forceToWorld(Vector3i chunkCoords,Vector3i forceToWorld,int x,int y,int z){\r\n    checkNotNull(chunkCoords, \"chunkCoords\");\r\n    return forceToWorld(chunkCoords.getX(), chunkCoords.getY(), chunkCoords.getZ());\r\n}"
}, {
	"Path": "org.springframework.data.redis.repository.cdi.RedisRepositoryExtension.processBean",
	"Comment": "pick up existing bean definitions that are required for a repository to work.",
	"Method": "void processBean(ProcessBean<X> processBean){\r\n    Bean<X> bean = processBean.getBean();\r\n    for (Type type : bean.getTypes()) {\r\n        Type beanType = type;\r\n        if (beanType instanceof ParameterizedType) {\r\n            beanType = ((ParameterizedType) beanType).getRawType();\r\n        }\r\n        if (beanType instanceof Class<?> && RedisKeyValueTemplate.class.isAssignableFrom((Class<?>) beanType)) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(String.format(\"Discovered %s with qualifiers %s.\", RedisKeyValueTemplate.class.getName(), bean.getQualifiers()));\r\n            }\r\n            redisKeyValueTemplates.put(new HashSet(bean.getQualifiers()), (Bean<KeyValueOperations>) bean);\r\n        }\r\n        if (beanType instanceof Class<?> && RedisKeyValueAdapter.class.isAssignableFrom((Class<?>) beanType)) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(String.format(\"Discovered %s with qualifiers %s.\", RedisKeyValueAdapter.class.getName(), bean.getQualifiers()));\r\n            }\r\n            redisKeyValueAdapters.put(new HashSet(bean.getQualifiers()), (Bean<RedisKeyValueAdapter>) bean);\r\n        }\r\n        if (beanType instanceof Class<?> && RedisOperations.class.isAssignableFrom((Class<?>) beanType)) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(String.format(\"Discovered %s with qualifiers %s.\", RedisOperations.class.getName(), bean.getQualifiers()));\r\n            }\r\n            redisOperations.put(new HashSet(bean.getQualifiers()), (Bean<RedisOperations<?, ?>>) bean);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.ExtentBufferFactory.createBiomeBuffer",
	"Comment": "returns a new biome buffer of the desired size and minimum position.",
	"Method": "MutableBiomeVolume createBiomeBuffer(Vector3i size,MutableBiomeVolume createBiomeBuffer,Vector3i min,Vector3i size,MutableBiomeVolume createBiomeBuffer,int xSize,int ySize,int zSize,MutableBiomeVolume createBiomeBuffer,int xMin,int yMin,int zMin,int xSize,int ySize,int zSize){\r\n    return createBiomeBuffer(new Vector3i(xMin, yMin, zMin), new Vector3i(xSize, ySize, zSize));\r\n}"
}, {
	"Path": "spoon.reflect.factory.PackageFactory.getOrCreate",
	"Comment": "gets or creates a package and make its parent the given module",
	"Method": "CtPackage getOrCreate(String qualifiedName,CtPackage getOrCreate,String qualifiedName,CtModule rootModule){\r\n    if (qualifiedName.isEmpty()) {\r\n        return rootModule.getRootPackage();\r\n    }\r\n    StringTokenizer token = new StringTokenizer(qualifiedName, CtPackage.PACKAGE_SEPARATOR);\r\n    CtPackage last = rootModule.getRootPackage();\r\n    while (token.hasMoreElements()) {\r\n        String name = token.nextToken();\r\n        CtPackage next = last.getPackage(name);\r\n        if (next == null) {\r\n            next = factory.Core().createPackage();\r\n            next.setSimpleName(name);\r\n            last.addPackage(next);\r\n        }\r\n        last = next;\r\n    }\r\n    return last;\r\n}"
}, {
	"Path": "spoon.support.reflect.reference.CtTypeReferenceImpl.isImplementationOf",
	"Comment": "detects if this type is an code responsible for implementing of that type.\tin means it detects whether this type can access protected members of that type",
	"Method": "boolean isImplementationOf(CtTypeReference<?> type){\r\n    CtTypeReference<?> impl = this;\r\n    while (impl != null) {\r\n        if (impl.isSubtypeOf(type)) {\r\n            return true;\r\n        }\r\n        impl = impl.getDeclaringType();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.lettuce.DefaultLettucePool.getPassword",
	"Comment": "returns the password used for authenticating with the redis server.",
	"Method": "String getPassword(){\r\n    return password;\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.alps.RootResourceInformationToAlpsDescriptorConverter.buildProjectionDescriptor",
	"Comment": "builds a descriptor for the projection parameter of the given resource.",
	"Method": "Descriptor buildProjectionDescriptor(ResourceMetadata metadata){\r\n    ProjectionDefinitionConfiguration projectionConfiguration = configuration.getProjectionConfiguration();\r\n    String projectionParameterName = projectionConfiguration.getParameterName();\r\n    Map<String, Class<?>> projections = projectionConfiguration.getProjectionsFor(metadata.getDomainType());\r\n    List<Descriptor> projectionDescriptors = new ArrayList<Descriptor>(projections.size());\r\n    for (Entry<String, Class<?>> projection : projections.entrySet()) {\r\n        Class<?> type = projection.getValue();\r\n        String key = String.format(\"%s.%s.%s\", metadata.getRel(), projectionParameterName, projection.getKey());\r\n        ResourceDescription fallback = SimpleResourceDescription.defaultFor(key);\r\n        AnnotationBasedResourceDescription projectionDescription = new AnnotationBasedResourceDescription(type, fallback);\r\n        projectionDescriptors.add(// \r\n        descriptor().type(// \r\n        Type.SEMANTIC).name(projection.getKey()).doc(getDocFor(projectionDescription)).descriptors(createJacksonDescriptor(projection.getKey(), type)).build());\r\n    }\r\n    return // \r\n    descriptor().type(// \r\n    Type.SEMANTIC).name(projectionParameterName).doc(getDocFor(// \r\n    SimpleResourceDescription.defaultFor(projectionParameterName))).descriptors(projectionDescriptors).build();\r\n}"
}, {
	"Path": "org.spongepowered.api.world.Location.add",
	"Comment": "add vector components to the position on this instance, returning a newlocation instance.",
	"Method": "Location<E> add(Vector3d v,Location<E> add,Vector3i v,Location<E> add,double x,double y,double z){\r\n    return setPosition(getPosition().add(x, y, z));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerCommands.getDetailFieldsRelatedToEntity",
	"Comment": "get a field list that can be selected to do a detail controller.",
	"Method": "List<String> getDetailFieldsRelatedToEntity(ShellContext shellContext,List<String> getDetailFieldsRelatedToEntity,ClassOrInterfaceTypeDetails entity,String parentFieldName){\r\n    List<String> results = new ArrayList<String>();\r\n    MemberDetails entityDetails = getMemberDetailsScanner().getMemberDetails(entity.getType().getSimpleTypeName(), entity);\r\n    List<FieldMetadata> fields = entityDetails.getFields();\r\n    for (FieldMetadata field : fields) {\r\n        AnnotationMetadata oneToManyAnnotation = field.getAnnotation(JpaJavaType.ONE_TO_MANY);\r\n        AnnotationMetadata manyToManyAnnotation = field.getAnnotation(JpaJavaType.MANY_TO_MANY);\r\n        if ((oneToManyAnnotation != null || manyToManyAnnotation != null) && (field.getFieldType().getFullyQualifiedTypeName().equals(JavaType.LIST.getFullyQualifiedTypeName()) || field.getFieldType().getFullyQualifiedTypeName().equals(JavaType.SET.getFullyQualifiedTypeName()))) {\r\n            results.add(parentFieldName.concat(field.getFieldName().getSymbolName()));\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.buildPopulateEnumsBody",
	"Comment": "build method body which populate enum field of a entity into model",
	"Method": "void buildPopulateEnumsBody(InvocableMemberBodyBuilder bodyBuilder,List<FieldMetadata> enumFields){\r\n    for (FieldMetadata field : enumFields) {\r\n        bodyBuilder.appendFormalLine(\"model.addAttribute(\\\"%s\\\", %s.asList(%s.values()));\", field.getFieldName(), getNameOfJavaType(JavaType.ARRAYS), getNameOfJavaType(field.getFieldType()));\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.Extent.getBlockSelectionBox",
	"Comment": "gets the bounding box used to select blocks, which appearsas a black outline on a vanilla client.",
	"Method": "Optional<AABB> getBlockSelectionBox(Vector3i pos,Optional<AABB> getBlockSelectionBox,int x,int y,int z){\r\n    checkNotNull(pos, \"pos\");\r\n    return getBlockSelectionBox(pos.getX(), pos.getY(), pos.getZ());\r\n}"
}, {
	"Path": "org.springframework.cloud.sleuth.instrument.messaging.TracingChannelInterceptorTest.pollingReceive_injectsConsumerSpan",
	"Comment": "we have to inject headers on a polling receive as any future processor will come\tlater",
	"Method": "void pollingReceive_injectsConsumerSpan(){\r\n    channel.addInterceptor(consumerSideOnly(interceptor));\r\n    channel.send(MessageBuilder.withPayload(\"foo\").build());\r\n    assertThat(channel.receive().getHeaders()).containsKeys(\"X-B3-TraceId\", \"X-B3-SpanId\", \"X-B3-Sampled\", \"nativeHeaders\");\r\n    assertThat(spans).hasSize(1).flatExtracting(Span::kind).containsExactly(Span.Kind.CONSUMER);\r\n}"
}, {
	"Path": "org.spongepowered.api.text.transform.TextTemplateApplier.getParameter",
	"Comment": "returns the current value of the parameter with the specified key.",
	"Method": "TextElement getParameter(String key){\r\n    return getParameters().get(key);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.query.Collation.backwards",
	"Comment": "set the flag that determines whether strings with diacritics sort from back of the string.",
	"Method": "Collation backwards(boolean backwards){\r\n    Collation newInstance = copy();\r\n    newInstance.backwards = Optional.of(backwards);\r\n    return newInstance;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.dbre.addon.DbreTypeUtils.getAnnotationAttribute",
	"Comment": "returns the value of the given attribute of the given annotation on thegiven type",
	"Method": "T getAnnotationAttribute(MemberHoldingTypeDetails type,JavaType annotationType,JavaSymbolName attributeName){\r\n    final AnnotationMetadata typeAnnotation = type.getTypeAnnotation(annotationType);\r\n    if (typeAnnotation == null) {\r\n        return null;\r\n    }\r\n    final AnnotationAttributeValue<?> attributeValue = typeAnnotation.getAttribute(attributeName);\r\n    if (attributeValue == null) {\r\n        return null;\r\n    }\r\n    return (T) attributeValue.getValue();\r\n}"
}, {
	"Path": "spoon.support.sniper.internal.AbstractSourceFragmentContext.onPrintFoundFragment",
	"Comment": "prints not modified or partially modified origin source fragment",
	"Method": "void onPrintFoundFragment(PrinterEvent event,int fragmentIndex){\r\n    printSpaces(fragmentIndex);\r\n    setChildFragmentIdx(fragmentIndex);\r\n    SourceFragment fragment = childFragments.get(fragmentIndex);\r\n    event.printSourceFragment(fragment, isFragmentModified(fragment));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.components.FieldItem.calculateZ",
	"Comment": "calculate the hash code of the fieldname, label and type properties",
	"Method": "String calculateZ(){\r\n    final int prime = 31;\r\n    int result = 1;\r\n    result = prime * result + ((fieldName == null) ? 0 : fieldName.hashCode());\r\n    result = prime * result + ((label == null) ? 0 : label.hashCode());\r\n    result = prime * result + ((type == null) ? 0 : type.hashCode());\r\n    return Integer.toHexString(result);\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.jedis.JedisConnectionFactory.fetchJedisConnector",
	"Comment": "returns a jedis instance to be used as a redis connection. the instance can be newly created or retrieved from a\tpool.",
	"Method": "Jedis fetchJedisConnector(){\r\n    try {\r\n        if (getUsePool() && pool != null) {\r\n            return pool.getResource();\r\n        }\r\n        Jedis jedis = createJedis();\r\n        jedis.connect();\r\n        potentiallySetClientName(jedis);\r\n        return jedis;\r\n    } catch (Exception ex) {\r\n        throw new RedisConnectionFailureException(\"Cannot get Jedis connection\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.repository.query.ExpressionEvaluatingParameterBinder.postProcessQuotedBinding",
	"Comment": "sanitize string binding by replacing single quoted values with double quotes which prevents potential single quotes\tcontained in replacement to interfere with the json parsing. also take care of complex objects by removing the\tquotation entirely.",
	"Method": "void postProcessQuotedBinding(StringBuffer buffer,String valueForBinding,Object raw,boolean isExpression){\r\n    int quotationMarkIndex = buffer.length() - valueForBinding.length() - 1;\r\n    char quotationMark = buffer.charAt(quotationMarkIndex);\r\n    while (quotationMark != '\\'' && quotationMark != '\"') {\r\n        quotationMarkIndex--;\r\n        if (quotationMarkIndex < 0) {\r\n            throw new IllegalArgumentException(\"Could not find opening quotes for quoted parameter\");\r\n        }\r\n        quotationMark = buffer.charAt(quotationMarkIndex);\r\n    }\r\n    if (valueForBinding.startsWith(\"{\") && (raw instanceof DBObject || isExpression)) {\r\n        buffer.deleteCharAt(quotationMarkIndex);\r\n    } else {\r\n        if (isExpression) {\r\n            buffer.deleteCharAt(quotationMarkIndex);\r\n            return;\r\n        }\r\n        if (quotationMark == '\\'') {\r\n            buffer.replace(quotationMarkIndex, quotationMarkIndex + 1, \"\\\"\");\r\n        }\r\n        buffer.append(\"\\\"\");\r\n    }\r\n}"
}, {
	"Path": "spoon.reflect.visitor.EarlyTerminatingScanner.doScan",
	"Comment": "this method is called only when the listener decides that the current element and children should be visited.\tsubclasses can override it to react accordingly.",
	"Method": "void doScan(CtRole role,CtElement element,ScanningMode mode){\r\n    if (mode.visitElement) {\r\n        onElement(role, element);\r\n    }\r\n    if (mode.visitChildren) {\r\n        element.accept(this);\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.BiomeVolume.getBiomeCopy",
	"Comment": "returns a mutable copy of the biomes stored in this volume. this uses theprovided storage type.",
	"Method": "MutableBiomeVolume getBiomeCopy(MutableBiomeVolume getBiomeCopy,StorageType type){\r\n    return getBiomeCopy(StorageType.STANDARD);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.ProjectionsBenchmark.baseline",
	"Comment": "set the baseline for comparison by using the plain mongodb java driver api without any additional fluff.",
	"Method": "Object baseline(){\r\n    return mongoCollection.find().first();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Predicate.getOrderOptions",
	"Comment": "returns the different queries that can be defined from the current order clause.the options are concatenated to the current query.",
	"Method": "List<String> getOrderOptions(String query){\r\n    return orderBySource.getOptions(query.concat(toString()));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.components.DetailEntityItem.calculateZ",
	"Comment": "calculate the hash code of the path, configuration and fieldname",
	"Method": "String calculateZ(){\r\n    final int prime = 31;\r\n    int result = 1;\r\n    result = prime * result + ((entityItemId == null) ? 0 : entityItemId.hashCode());\r\n    result = prime * result + ((getConfiguration() == null) ? 0 : getConfiguration().hashCode());\r\n    result = prime * result + ((fieldName == null) ? 0 : fieldName.hashCode());\r\n    return Integer.toHexString(result);\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.aggregation.AggregationResults.getServerUsed",
	"Comment": "returns the server that has been used to perform the aggregation.",
	"Method": "String getServerUsed(){\r\n    return serverUsed;\r\n}"
}, {
	"Path": "spoon.support.visitor.ClassTypingContext.resolveTypeParameters",
	"Comment": "resolve typerefs declared in scope of declarer using actual type arguments registered in typescopetoactualtypearguments",
	"Method": "List<CtTypeReference<?>> resolveTypeParameters(List<CtTypeReference<?>> typeRefs){\r\n    List<CtTypeReference<?>> result = new ArrayList(typeRefs.size());\r\n    for (CtTypeReference<?> typeRef : typeRefs) {\r\n        if (typeRef instanceof CtTypeParameterReference) {\r\n            CtTypeParameterReference typeParamRef = (CtTypeParameterReference) typeRef;\r\n            CtTypeParameter typeParam = typeParamRef.getDeclaration();\r\n            if (typeParam == null) {\r\n                throw new SpoonException(\"The typeParam \" + typeRef.getQualifiedName() + \" declaration cannot be resolved\");\r\n            }\r\n            CtFormalTypeDeclarer declarer = typeParam.getTypeParameterDeclarer();\r\n            typeRef = resolveTypeParameter(declarer, typeParamRef, typeParam, typeRef);\r\n        }\r\n        result.add(typeRef);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerCommands.isAddControllerAvailable",
	"Comment": "this indicator checks if is possible to add new controllers.if a valid project has been generated and spring mvc has been installed,this command will be available.",
	"Method": "boolean isAddControllerAvailable(){\r\n    return getControllerOperations().isAddControllerAvailable();\r\n}"
}, {
	"Path": "org.spongepowered.api.text.format.TextStyle.isItalic",
	"Comment": "checks for whether text where this style is applied is italicized.",
	"Method": "Optional<Boolean> isItalic(){\r\n    return this.italic;\r\n}"
}, {
	"Path": "spoon.reflect.factory.FactoryImpl.dedup",
	"Comment": "returns a string equal to the given symbol. performs probablilistic\tdeduplication.",
	"Method": "String dedup(String symbol){\r\n    Dedup dedup = threadLocalDedup.get();\r\n    Map<String, String> cache = dedup.cache;\r\n    String cached;\r\n    if ((cached = cache.get(symbol)) != null) {\r\n        return cached;\r\n    } else {\r\n        int prob = (int) (Integer.MIN_VALUE + (0.2 * (1L << 32)));\r\n        if (dedup.random.nextInt() < prob) {\r\n            cache.put(symbol, symbol);\r\n        }\r\n        return symbol;\r\n    }\r\n}"
}, {
	"Path": "org.spongepowered.api.text.transform.FixedPartitionedTextFormatter.clear",
	"Comment": "clears each partition. retains the actual partitions themselves.",
	"Method": "void clear(){\r\n    forEach(SimpleTextFormatter::clear);\r\n}"
}, {
	"Path": "spoon.decompiler.TypeTransformer.accept",
	"Comment": "user defined filter to discard type that will not be transformed by the spoonclassfiletransformer.",
	"Method": "boolean accept(CtType type){\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.FindAndModifyOptions.options",
	"Comment": "static factory method to create a findandmodifyoptions instance",
	"Method": "FindAndModifyOptions options(){\r\n    return new FindAndModifyOptions();\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.RedisStreamCommands.xAck",
	"Comment": "acknowledge one or more records, identified via their id, as processed.",
	"Method": "Long xAck(byte[] key,String group,String recordIds,Long xAck,byte[] key,String group,RecordId recordIds){\r\n    return xAck(key, group, Arrays.stream(recordIds).map(RecordId::of).toArray(RecordId[]::new));\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.MongoClientOptionsFactoryBean.setHeartbeatConnectTimeout",
	"Comment": "set the connect timeout for connections used for the cluster heartbeat.",
	"Method": "void setHeartbeatConnectTimeout(int heartbeatConnectTimeout){\r\n    this.heartbeatConnectTimeout = heartbeatConnectTimeout;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getXlsMethod",
	"Comment": "generates a method to export data to xls using dynamicjasper.",
	"Method": "MethodMetadata getXlsMethod(){\r\n    if (jasperReportsMap.get(\"JasperReportsXlsExporter\") != null) {\r\n        final String exporterMethodInvocation = String.format(\"new %s()\", getNameOfJavaType(jasperReportsMap.get(\"JasperReportsXlsExporter\")));\r\n        final String fileName = String.format(\"%s_report.xls\", StringUtils.uncapitalize(this.entityPlural));\r\n        final JavaSymbolName methodName = EXPORT_XLS_METHOD_NAME;\r\n        return buildExportTypeMethod(exporterMethodInvocation, fileName, methodName, \"exportXls\", \"/export/xls\", \"XLS\");\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.data.rest.tests.TestMvcClient.hasLinkWithRel",
	"Comment": "mockmvc matcher used to verify existence of rel with uri link",
	"Method": "ResultMatcher hasLinkWithRel(String rel){\r\n    return new ResultMatcher() {\r\n        @Override\r\n        public void match(MvcResult result) throws Exception {\r\n            MockHttpServletResponse response = result.getResponse();\r\n            String s = response.getContentAsString();\r\n            assertThat(\"Expected to find link with rel \" + rel + \" but found none in \" + s, getDiscoverer(response).findLinkWithRel(rel, s), notNullValue());\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.springframework.data.rest.tests.TestMvcClient.hasLinkWithRel",
	"Comment": "mockmvc matcher used to verify existence of rel with uri link",
	"Method": "ResultMatcher hasLinkWithRel(String rel){\r\n    MockHttpServletResponse response = result.getResponse();\r\n    String s = response.getContentAsString();\r\n    assertThat(\"Expected to find link with rel \" + rel + \" but found none in \" + s, getDiscoverer(response).findLinkWithRel(rel, s), notNullValue());\r\n}"
}, {
	"Path": "spoon.pattern.PatternBuilder.configureLocalParameters",
	"Comment": "used by inline for each statement to define template parameter which is local in the scope of the inline statement",
	"Method": "PatternBuilder configureLocalParameters(Consumer<PatternParameterConfigurator> parametersBuilder){\r\n    PatternParameterConfigurator pb = new PatternParameterConfigurator(this, new HashMap());\r\n    parametersBuilder.accept(pb);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Order.hasProperty",
	"Comment": "returns true if the expression has a property. otherwise, returns false",
	"Method": "boolean hasProperty(){\r\n    return property != null;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.ControllerOperationsImpl.isAddDetailControllerAvailable",
	"Comment": "this operation will check if add detail controllers operation isavailable",
	"Method": "boolean isAddDetailControllerAvailable(){\r\n    return getProjectOperations().isFeatureInstalled(FeatureNames.MVC);\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.RepositoryRestConfiguration.getBaseUri",
	"Comment": "the base uri against which the exporter should calculate its links.",
	"Method": "URI getBaseUri(){\r\n    return basePath != NO_URI ? basePath : baseUri;\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.JDTTreeBuilderHelper.computeAnonymousName",
	"Comment": "computes the anonymous simple name from its fully qualified type name.",
	"Method": "String computeAnonymousName(char[] anonymousQualifiedName){\r\n    final String poolName = CharOperation.charToString(anonymousQualifiedName);\r\n    return poolName.substring(poolName.lastIndexOf(CtType.INNERTTYPE_SEPARATOR) + 1);\r\n}"
}, {
	"Path": "spoon.support.compiler.jdt.JDTTreeBuilderQuery.isLhsAssignment",
	"Comment": "checks if the last node in the stack in the context is an assignment and have a lhs equals to the given expression.",
	"Method": "boolean isLhsAssignment(ContextBuilder context,Expression lhs){\r\n    return context.stack.peek().node instanceof Assignment && ((Assignment) context.stack.peek().node).lhs.equals(lhs);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.security.addon.security.SecurityFiltersMetadataProviderImpl.checkParameters",
	"Comment": "check that the parameters of the method are equals of parameters list",
	"Method": "boolean checkParameters(MethodMetadata method,List<?> methodParametersToCompare){\r\n    boolean parametersAreEquals = true;\r\n    List<AnnotatedJavaType> parameterTypes = method.getParameterTypes();\r\n    if (methodParametersToCompare.size() != parameterTypes.size()) {\r\n        parametersAreEquals = false;\r\n    } else {\r\n        for (int i = 0; i < methodParametersToCompare.size(); i++) {\r\n            ClassAttributeValue methodParameterToCompare = (ClassAttributeValue) methodParametersToCompare.get(i);\r\n            AnnotatedJavaType parameterJavaType = parameterTypes.get(i);\r\n            if (!methodParameterToCompare.getValue().getSimpleTypeName().equals(parameterJavaType.getJavaType().getSimpleTypeName())) {\r\n                parametersAreEquals = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return parametersAreEquals;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMVCViewResponseService.addThymeleafDatatablesResources",
	"Comment": "this method install datatables resources and datatables support for thymeleafimplementationthis is necessary because thymeleaf response type uses datatables components tolist results on generated views.",
	"Method": "void addThymeleafDatatablesResources(Pom module){\r\n    addWebMVCThymeleafUIConfiguration(module);\r\n}"
}, {
	"Path": "org.spongepowered.api.world.biome.BiomeGenerationSettings.builder",
	"Comment": "gets a new builder for creating new biomegenerationsettings.",
	"Method": "Builder builder(){\r\n    return Sponge.getRegistry().createBuilder(Builder.class);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.cache.CacheOperationsImpl.getTypeLocationService",
	"Comment": "method to obtain typelocationservice service implementation",
	"Method": "TypeLocationService getTypeLocationService(){\r\n    if (typeLocationService == null) {\r\n        try {\r\n            ServiceReference<?>[] references = context.getAllServiceReferences(TypeLocationService.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                typeLocationService = (TypeLocationService) context.getService(ref);\r\n                return typeLocationService;\r\n            }\r\n            return null;\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load TypeLocationService on PushInOperationsImpl.\");\r\n            return null;\r\n        }\r\n    } else {\r\n        return typeLocationService;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.redis.core.StreamOperations.add",
	"Comment": "append the record, backed by the given value, to the stream. the value is mapped as hash and serialized.",
	"Method": "RecordId add(K key,Map<? extends HK, ? extends HV> content,RecordId add,MapRecord<K, ? extends HK, ? extends HV> record,RecordId add,Record<K, ?> record){\r\n    return add((Record) record);\r\n}"
}, {
	"Path": "spoon.support.reflect.reference.CtTypeReferenceImpl.applyActualTypeArguments",
	"Comment": "adds the actualtypearguments of sourcetyperef to targettyperef. type of targettyperef extends from type of sourcetyperef",
	"Method": "void applyActualTypeArguments(CtTypeReference<?> targetTypeRef,CtTypeReference<?> sourceTypeRef){\r\n    CtTypeReference<?> targetDeclType = targetTypeRef.getDeclaringType();\r\n    CtTypeReference<?> sourceDeclType = sourceTypeRef.getDeclaringType();\r\n    if (targetDeclType != null && sourceDeclType != null && targetDeclType.isSubtypeOf(sourceDeclType)) {\r\n        applyActualTypeArguments(targetDeclType, sourceDeclType);\r\n    }\r\n    if (targetTypeRef.isSubtypeOf(sourceTypeRef) == false) {\r\n        throw new SpoonException(\"Invalid arguments. targetTypeRef \" + targetTypeRef.getQualifiedName() + \" must be a sub type of sourceTypeRef \" + sourceTypeRef.getQualifiedName());\r\n    }\r\n    List<CtTypeReference<?>> newTypeArgs = new ArrayList();\r\n    for (CtTypeReference<?> l_tr : sourceTypeRef.getActualTypeArguments()) {\r\n        newTypeArgs.add(l_tr.clone());\r\n    }\r\n    targetTypeRef.setActualTypeArguments(newTypeArgs);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.dbre.addon.DbreDatabaseListenerImpl.getIdentifierType",
	"Comment": "returns the type of id that dbre should use for the given entity",
	"Method": "JavaType getIdentifierType(JavaType entity){\r\n    final PhysicalTypeMetadata governorPhysicalTypeMetadata = getPhysicalTypeMetadata(entity);\r\n    if (governorPhysicalTypeMetadata != null) {\r\n        final ClassOrInterfaceTypeDetails governorTypeDetails = governorPhysicalTypeMetadata.getMemberHoldingTypeDetails();\r\n        final AnnotationMetadata jpaAnnotation = getJpaAnnotation(governorTypeDetails);\r\n        if (jpaAnnotation != null) {\r\n            final AnnotationAttributeValue<?> identifierTypeAttribute = jpaAnnotation.getAttribute(new JavaSymbolName(IDENTIFIER_TYPE));\r\n            if (identifierTypeAttribute != null) {\r\n                final JavaType identifierType = (JavaType) identifierTypeAttribute.getValue();\r\n                if (identifierType != null && !JdkJavaType.isPartOfJavaLang(identifierType)) {\r\n                    return identifierType;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return new JavaType(entity.getFullyQualifiedTypeName() + PRIMARY_KEY_SUFFIX);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.AbstractViewGenerationService.loadExistingDoc",
	"Comment": "this method load the provided file and get its content in string format.after that, uses parse method to generate a valid doc object.",
	"Method": "DOC loadExistingDoc(String path){\r\n    String content = \"\";\r\n    try {\r\n        content = FileUtils.readFileToString(new File(path));\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(String.format(\"ERROR: Error trying to load existing doc %s\", path));\r\n    }\r\n    return parse(content);\r\n}"
}, {
	"Path": "org.spongepowered.api.text.Text.trim",
	"Comment": "removes all empty texts from the beginning and end of thistext.",
	"Method": "Text trim(Builder trim){\r\n    return toBuilder().trim().build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaCommands.getTypeFromEntityParam",
	"Comment": "tries to obtain javatype indicated in command or which has the focusin the shell",
	"Method": "JavaType getTypeFromEntityParam(ShellContext shellContext){\r\n    String typeString = shellContext.getParameters().get(\"entity\");\r\n    JavaType type = null;\r\n    if (typeString != null) {\r\n        type = getJavaTypeConverter().convertFromText(typeString, JavaType.class, PROJECT);\r\n    } else {\r\n        type = lastUsed.getJavaType();\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "spoon.reflect.factory.TypeFactory.hasPackage",
	"Comment": "tells if a given java qualified name contains a package name.",
	"Method": "int hasPackage(String qualifiedName){\r\n    return qualifiedName.lastIndexOf(CtPackage.PACKAGE_SEPARATOR);\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory.getPassword",
	"Comment": "returns the password used for authenticating with the redis server.",
	"Method": "String getPassword(){\r\n    return getRedisPassword().map(String::new).orElse(null);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.views.ViewOperationsImpl.getMVCViewGenerationService",
	"Comment": "this method gets mvcviewgenerationservice implementation that contains necessary operationsto install templates inside generated project.",
	"Method": "MVCViewGenerationService getMVCViewGenerationService(String type){\r\n    try {\r\n        ServiceReference<?>[] references = this.context.getAllServiceReferences(MVCViewGenerationService.class.getName(), null);\r\n        for (ServiceReference<?> ref : references) {\r\n            MVCViewGenerationService viewGenerationService = (MVCViewGenerationService) this.context.getService(ref);\r\n            if (viewGenerationService.getName().equals(type)) {\r\n                return viewGenerationService;\r\n            }\r\n        }\r\n        return null;\r\n    } catch (InvalidSyntaxException e) {\r\n        LOGGER.warning(\"Cannot load MVCViewGenerationService on ViewCommands.\");\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.draw2d.text.FlowUtilities.getTextUtilities",
	"Comment": "returns an instance of a textutililities class on whichtext calculations can be performed. clients may override to customize.",
	"Method": "TextUtilities getTextUtilities(){\r\n    return TextUtilities.INSTANCE;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform2.withTranslation",
	"Comment": "adds a translation to this transform and returns it as a new transform.",
	"Method": "DiscreteTransform2 withTranslation(Vector2i vector,DiscreteTransform2 withTranslation,int x,int y){\r\n    return new DiscreteTransform2(this.matrix.translate(x, y));\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.MongoTemplate.doCreateCollection",
	"Comment": "create the specified collection using the provided options",
	"Method": "MongoCollection<Document> doCreateCollection(String collectionName,Document collectionOptions){\r\n    return execute(new DbCallback<MongoCollection<Document>>() {\r\n        public MongoCollection<Document> doInDB(MongoDatabase db) throws MongoException, DataAccessException {\r\n            CreateCollectionOptions co = new CreateCollectionOptions();\r\n            if (collectionOptions.containsKey(\"capped\")) {\r\n                co.capped((Boolean) collectionOptions.get(\"capped\"));\r\n            }\r\n            if (collectionOptions.containsKey(\"size\")) {\r\n                co.sizeInBytes(((Number) collectionOptions.get(\"size\")).longValue());\r\n            }\r\n            if (collectionOptions.containsKey(\"max\")) {\r\n                co.maxDocuments(((Number) collectionOptions.get(\"max\")).longValue());\r\n            }\r\n            if (collectionOptions.containsKey(\"collation\")) {\r\n                co.collation(IndexConverters.fromDocument(collectionOptions.get(\"collation\", Document.class)));\r\n            }\r\n            if (collectionOptions.containsKey(\"validator\")) {\r\n                com.mongodb.client.model.ValidationOptions options = new com.mongodb.client.model.ValidationOptions();\r\n                if (collectionOptions.containsKey(\"validationLevel\")) {\r\n                    options.validationLevel(ValidationLevel.fromString(collectionOptions.getString(\"validationLevel\")));\r\n                }\r\n                if (collectionOptions.containsKey(\"validationAction\")) {\r\n                    options.validationAction(ValidationAction.fromString(collectionOptions.getString(\"validationAction\")));\r\n                }\r\n                options.validator(collectionOptions.get(\"validator\", Document.class));\r\n                co.validationOptions(options);\r\n            }\r\n            db.createCollection(collectionName, co);\r\n            MongoCollection<Document> coll = db.getCollection(collectionName, Document.class);\r\n            if (LOGGER.isDebugEnabled()) {\r\n                LOGGER.debug(\"Created collection [{}]\", coll.getNamespace() != null ? coll.getNamespace().getCollectionName() : collectionName);\r\n            }\r\n            return coll;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.MongoTemplate.doCreateCollection",
	"Comment": "create the specified collection using the provided options",
	"Method": "MongoCollection<Document> doCreateCollection(String collectionName,Document collectionOptions){\r\n    CreateCollectionOptions co = new CreateCollectionOptions();\r\n    if (collectionOptions.containsKey(\"capped\")) {\r\n        co.capped((Boolean) collectionOptions.get(\"capped\"));\r\n    }\r\n    if (collectionOptions.containsKey(\"size\")) {\r\n        co.sizeInBytes(((Number) collectionOptions.get(\"size\")).longValue());\r\n    }\r\n    if (collectionOptions.containsKey(\"max\")) {\r\n        co.maxDocuments(((Number) collectionOptions.get(\"max\")).longValue());\r\n    }\r\n    if (collectionOptions.containsKey(\"collation\")) {\r\n        co.collation(IndexConverters.fromDocument(collectionOptions.get(\"collation\", Document.class)));\r\n    }\r\n    if (collectionOptions.containsKey(\"validator\")) {\r\n        com.mongodb.client.model.ValidationOptions options = new com.mongodb.client.model.ValidationOptions();\r\n        if (collectionOptions.containsKey(\"validationLevel\")) {\r\n            options.validationLevel(ValidationLevel.fromString(collectionOptions.getString(\"validationLevel\")));\r\n        }\r\n        if (collectionOptions.containsKey(\"validationAction\")) {\r\n            options.validationAction(ValidationAction.fromString(collectionOptions.getString(\"validationAction\")));\r\n        }\r\n        options.validator(collectionOptions.get(\"validator\", Document.class));\r\n        co.validationOptions(options);\r\n    }\r\n    db.createCollection(collectionName, co);\r\n    MongoCollection<Document> coll = db.getCollection(collectionName, Document.class);\r\n    if (LOGGER.isDebugEnabled()) {\r\n        LOGGER.debug(\"Created collection [{}]\", coll.getNamespace() != null ? coll.getNamespace().getCollectionName() : collectionName);\r\n    }\r\n    return coll;\r\n}"
}, {
	"Path": "org.elasticsearch.tasks.TaskManager.cancel",
	"Comment": "cancels a taskreturns a set of nodes with child tasks where this task should be cancelled if cancellation was successful, null otherwise.",
	"Method": "Set<String> cancel(CancellableTask task,String reason,Consumer<Set<String>> listener,Set<String> cancel,String reason,Consumer<Set<String>> listener,Set<String> cancel,String reason){\r\n    CancellableTaskHolder holder = cancellableTasks.get(task.getId());\r\n    if (holder != null) {\r\n        logger.trace(\"cancelling task with id {}\", task.getId());\r\n        return holder.cancel(reason, listener);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.jedis.JedisConnectionFactory.postProcessConnection",
	"Comment": "post process a newly retrieved connection. useful for decorating or executing initialization commands on a new\tconnection. this implementation simply returns the connection.",
	"Method": "JedisConnection postProcessConnection(JedisConnection connection){\r\n    return connection;\r\n}"
}, {
	"Path": "org.spongepowered.api.util.DiscreteTransform2.compose",
	"Comment": "returns a transform that is the composition of this transform and thegiven transform. the result will apply this transformation after thegiven one.",
	"Method": "DiscreteTransform2 compose(DiscreteTransform2 that){\r\n    return new DiscreteTransform2(this.matrix.mul(that.matrix));\r\n}"
}, {
	"Path": "org.springframework.roo.addon.tailor.util.TestTailorHelper.testReplaceVarsDuplicatePlaceholders",
	"Comment": "test replacevars when there is more than one occurence of the sameplaceholder in the target",
	"Method": "void testReplaceVarsDuplicatePlaceholders(){\r\n    final CommandTransformation rooCommand = new CommandTransformation(\"project --topLevelPackage com.foo.sample --projectName test --domain otherdomainname\");\r\n    final String result = TailorHelper.replaceVars(rooCommand, \"module create --moduleName ${domain} --topLevelPackage ${topLevelPackage}.${domain}\");\r\n    final String expectedResult = \"module create --moduleName otherdomainname --topLevelPackage com.foo.sample.otherdomainname\";\r\n    Assert.assertEquals(\"Unexpected result: \" + result, expectedResult, result);\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.RepositoryRestConfiguration.isReturnBodyOnUpdate",
	"Comment": "whether to return a response body after updating an entity.",
	"Method": "Boolean isReturnBodyOnUpdate(){\r\n    return returnBodyOnUpdate;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.thymeleaf.addon.ThymeleafMetadata.getExportMethod",
	"Comment": "generates a method to export data using dynamicjasper and argumentsreceived as different export methods will delegate in this one.",
	"Method": "MethodMetadata getExportMethod(){\r\n    JavaSymbolName methodName = EXPORT_METHOD_NAME;\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    parameterTypes.add(GLOBAL_SEARCH_PARAM);\r\n    AnnotationMetadataBuilder pageableDefaultAnnotation = new AnnotationMetadataBuilder(SpringJavaType.PAGEABLE_DEFAULT);\r\n    pageableDefaultAnnotation.addIntegerAttribute(\"size\", Integer.MAX_VALUE);\r\n    parameterTypes.add(new AnnotatedJavaType(SpringJavaType.PAGEABLE, pageableDefaultAnnotation.build()));\r\n    parameterTypes.add(STRING_ARRAY_PARAM);\r\n    parameterTypes.add(new AnnotatedJavaType(new JavaType(\"javax.servlet.http.HttpServletResponse\")));\r\n    parameterTypes.add(new AnnotatedJavaType(this.jasperReportsMap.get(\"JasperReportsExporter\")));\r\n    parameterTypes.add(STRING_PARAM);\r\n    parameterTypes.add(LOCALE_PARAM);\r\n    MethodMetadata existingMethod = getGovernorMethod(methodName, AnnotatedJavaType.convertFromAnnotatedJavaTypes(parameterTypes));\r\n    if (existingMethod != null) {\r\n        return existingMethod;\r\n    }\r\n    final List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    parameterNames.add(GLOBAL_SEARCH_PARAM_NAME);\r\n    parameterNames.add(PAGEABLE_PARAM_NAME);\r\n    parameterNames.add(DATATABLES_COLUMNS_PARAM_NAME);\r\n    parameterNames.add(RESPONSE_PARAM_NAME);\r\n    parameterNames.add(EXPORTER_PARAM_NAME);\r\n    parameterNames.add(FILE_NAME_PARAM_NAME);\r\n    parameterNames.add(LOCALE_PARAM_NAME);\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    MethodMetadata findAllMethod = this.serviceMetadata.getCurrentFindAllWithGlobalSearchMethod();\r\n    JavaType defaultReturnType = findAllMethod.getReturnType();\r\n    bodyBuilder.appendFormalLine(\"// Obtain the filtered and ordered elements\");\r\n    bodyBuilder.appendFormalLine(\"%s %s = %s().%s(%s, %s);\", getNameOfJavaType(defaultReturnType), this.entityPluralUncapitalized, getAccessorMethod(this.controllerMetadata.getServiceField()).getMethodName(), findAllMethod.getMethodName().getSymbolName(), GLOBAL_SEARCH_PARAM_NAME, PAGEABLE_PARAM_NAME);\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"// Prevent generation of reports with empty data\");\r\n    bodyBuilder.appendFormalLine(\"if (%1$s == null || %s.getContent().isEmpty()) {\", this.entityPluralUncapitalized);\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\"return;\");\r\n    bodyBuilder.indentRemove();\r\n    bodyBuilder.appendFormalLine(\"}\");\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"// Creates a new ReportBuilder using DynamicJasper library\");\r\n    bodyBuilder.appendFormalLine(\"%1$s builder = new %1$s();\", getNameOfJavaType(FAST_REPORT_BUILDER));\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"// IMPORTANT: By default, this application uses \\\"export_default.jrxml\\\"\");\r\n    bodyBuilder.appendFormalLine(\"// to generate all reports. If you want to customize this specific report,\");\r\n    bodyBuilder.appendFormalLine(\"// create a new \\\".jrxml\\\" template and customize it. (Take in account the \");\r\n    bodyBuilder.appendFormalLine(\"// DynamicJasper restrictions: \");\r\n    bodyBuilder.appendFormalLine(\"// http://dynamicjasper.com/2010/10/06/how-to-use-custom-jrxml-templates/)\");\r\n    bodyBuilder.appendFormalLine(\"builder.setTemplateFile(\\\"templates/reports/export_default.jrxml\\\");\");\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"// The generated report will display the same columns as the Datatables component.\");\r\n    bodyBuilder.appendFormalLine(\"// However, this is not mandatory. You could edit this code if you want to ignore\");\r\n    bodyBuilder.appendFormalLine(\"// the provided datatablesColumns\");\r\n    bodyBuilder.appendFormalLine(\"if (%s != null) {\", DATATABLES_COLUMNS_PARAM_NAME);\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\"for (String column : %s) {\", DATATABLES_COLUMNS_PARAM_NAME);\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\"// Delegates in %s to include each datatables column\", ADD_COLUMN_TO_REPORT_BUILDER_METHOD_NAME);\r\n    bodyBuilder.appendFormalLine(\"// to the report builder\");\r\n    bodyBuilder.appendFormalLine(\"addColumnToReportBuilder(column, builder, %s, %s);\", LOCALE_PARAM_NAME, FILE_NAME_PARAM_NAME);\r\n    bodyBuilder.indentRemove();\r\n    bodyBuilder.appendFormalLine(\"}\");\r\n    bodyBuilder.indentRemove();\r\n    bodyBuilder.appendFormalLine(\"}\");\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"// This property resizes the columns to use full width page.\");\r\n    bodyBuilder.appendFormalLine(\"// Set false value if you want to use the specific width of each column.\");\r\n    bodyBuilder.appendFormalLine(\"builder.setUseFullPageWidth(true);\");\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"// Creates a new Jasper Reports Datasource using the obtained elements\");\r\n    bodyBuilder.appendFormalLine(\"%s ds = new %s(%s.getContent());\", getNameOfJavaType(JR_DATA_SOURCE), getNameOfJavaType(JR_BEAN_COLLECTION_DATA_SOURCE), this.entityPluralUncapitalized);\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"// Generates the JasperReport\");\r\n    bodyBuilder.appendFormalLine(\"%s jp;\", getNameOfJavaType(JASPER_PRINT));\r\n    bodyBuilder.appendFormalLine(\"try {\");\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\"jp = %s.generateJasperPrint(builder.build(), new %s(), ds);\", getNameOfJavaType(DYNAMIC_JASPER_HELPER), getNameOfJavaType(CLASSIC_LAYOUT_MANAGER));\r\n    bodyBuilder.indentRemove();\r\n    bodyBuilder.appendFormalLine(\"}\");\r\n    buildExportCatchBlock(bodyBuilder, JR_EXCEPTION);\r\n    bodyBuilder.newLine();\r\n    bodyBuilder.appendFormalLine(\"// Converts the JaspertReport element to a ByteArrayOutputStream and\");\r\n    bodyBuilder.appendFormalLine(\"// write it into the response stream using the provided JasperReportExporter\");\r\n    bodyBuilder.appendFormalLine(\"try {\");\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\"%s.export(jp, %s, %s);\", EXPORTER_PARAM_NAME, FILE_NAME_PARAM_NAME, RESPONSE_PARAM_NAME);\r\n    bodyBuilder.indentRemove();\r\n    bodyBuilder.appendFormalLine(\"}\");\r\n    buildExportCatchBlock(bodyBuilder, JR_EXCEPTION);\r\n    buildExportCatchBlock(bodyBuilder, IO_EXCEPTION);\r\n    bodyBuilder.reset();\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, JavaType.VOID_PRIMITIVE, parameterTypes, parameterNames, bodyBuilder);\r\n    CommentStructure commentStructure = new CommentStructure();\r\n    String description = \"Method that obtains the filtered and ordered records using the Datatables information and \".concat(IOUtils.LINE_SEPARATOR).concat(\"export them to a new report file. (It ignores the current pagination).\").concat(IOUtils.LINE_SEPARATOR).concat(IOUtils.LINE_SEPARATOR).concat(\"To generate the report file it uses the `DynamicJasper` library\").concat(IOUtils.LINE_SEPARATOR).concat(\"(http://dynamicjasper.com). This library allows developers to generate reports dynamically\").concat(IOUtils.LINE_SEPARATOR).concat(\"without use an specific template to each entity.\").concat(IOUtils.LINE_SEPARATOR).concat(IOUtils.LINE_SEPARATOR).concat(\"To customize the appearance of ALL generated reports, you could customize the \").concat(IOUtils.LINE_SEPARATOR).concat(\"\\\"export_default.jrxml\\\" template located in \\\"src/main/resources/templates/reports/\\\". However,\").concat(IOUtils.LINE_SEPARATOR).concat(\"if you want to customize the appearance of this specific report, you could create a new\").concat(IOUtils.LINE_SEPARATOR).concat(\"\\\".jrxml\\\" file and provide it to the library replacing the `builder.setTemplateFile();`\").concat(IOUtils.LINE_SEPARATOR).concat(\"operation used in this implementation.\");\r\n    List<String> paramsInfo = new ArrayList<String>();\r\n    paramsInfo.add(\"search GlobalSearch that contains the filter provided by the Datatables component.\");\r\n    paramsInfo.add(\"pageable Pageable that contains the Sort info provided by the Datatabes component.\");\r\n    paramsInfo.add(\"datatablesColumns Columns displayed in the Datatables component.\");\r\n    paramsInfo.add(\"response The HttpServletResponse.\");\r\n    paramsInfo.add(\"exporter An specific JasperReportsExporter to be used during export process.\");\r\n    paramsInfo.add(\"fileName The final filename to use.\");\r\n    paramsInfo.add(\"locale The current Locale in the view context.\");\r\n    commentStructure.addComment(new JavadocComment(description, paramsInfo, null, null), CommentLocation.BEGINNING);\r\n    methodBuilder.setCommentStructure(commentStructure);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.spongepowered.api.text.Text.joinWith",
	"Comment": "joins a sequence of text objects together along with a separator.",
	"Method": "Text joinWith(Text separator,Text texts,Text joinWith,Text separator,Iterable<? extends Text> texts,Text joinWith,Text separator,Iterator<? extends Text> texts){\r\n    if (!texts.hasNext()) {\r\n        return EMPTY;\r\n    }\r\n    Text first = texts.next();\r\n    if (!texts.hasNext()) {\r\n        return first;\r\n    }\r\n    Text.Builder builder = builder().append(first);\r\n    do {\r\n        builder.append(separator);\r\n        builder.append(texts.next());\r\n    } while (texts.hasNext());\r\n    return builder.build();\r\n}"
}, {
	"Path": "spoon.reflect.visitor.chain.CtQueryImpl.addInput",
	"Comment": "adds list of elements which will be used as input of the query too",
	"Method": "CtQueryImpl addInput(Object input,CtQueryImpl addInput,Iterable<?> input){\r\n    if (this.inputs == null) {\r\n        this.inputs = new ArrayList();\r\n    }\r\n    if (input != null) {\r\n        for (Object in : input) {\r\n            this.inputs.add(in);\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.data.mongodb.core.mapreduce.MapReduceOptions.limit",
	"Comment": "limit the number of objects to return from the collection that is fed into the map reduce operation often used in\tconjunction with a query and sort option so as to reduce the portion of the data that will be processed.",
	"Method": "MapReduceOptions limit(int limit){\r\n    this.limit = limit;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.finder.parser.Part.getSupportedOperatorsByPrefix",
	"Comment": "returns operators which name starts with a given prefix and are supported by the search expression property",
	"Method": "List<String> getSupportedOperatorsByPrefix(String prefix){\r\n    if (property == null) {\r\n        return null;\r\n    }\r\n    List<String> typeKeywords = new ArrayList<String>();\r\n    List<Type> types = Type.getOperators(property.getLeft().peek().getFieldType());\r\n    boolean removePrefix = Type.ALL_KEYWORDS.contains(prefix);\r\n    for (Type type : types) {\r\n        for (String keyword : type.getKeywords()) {\r\n            if (StringUtils.isBlank(prefix) && !StringUtils.startsWithAny(keyword, Type.PREFIX_GROUP)) {\r\n                typeKeywords.add(keyword);\r\n            }\r\n            if (StringUtils.isNotBlank(prefix) && keyword.startsWith(prefix)) {\r\n                if (removePrefix) {\r\n                    typeKeywords.add(StringUtils.substringAfter(keyword, prefix));\r\n                } else {\r\n                    typeKeywords.add(keyword);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (StringUtils.isBlank(prefix)) {\r\n        typeKeywords.addAll(Arrays.asList(Type.PREFIX_GROUP));\r\n    }\r\n    return typeKeywords;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaCustomMetadata.getCustomFinder",
	"Comment": "method that generates finder methods whose return types are projections.",
	"Method": "MethodMetadata getCustomFinder(JavaType finderReturnType,JavaSymbolName finderName,JavaType parameterType){\r\n    List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    parameterTypes.add(AnnotatedJavaType.convertFromJavaType(parameterType));\r\n    parameterTypes.add(GLOBAL_SEARCH_PARAMETER);\r\n    parameterTypes.add(PAGEABLE_PARAMETER);\r\n    List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();\r\n    parameterNames.add(new JavaSymbolName(\"formBean\"));\r\n    parameterNames.add(GOBAL_SEARCH_PARAMETER_NAME);\r\n    parameterNames.add(PAGEABLE_PARAMETER_NAME);\r\n    JavaType returnType = new JavaType(SpringJavaType.PAGE.getFullyQualifiedTypeName(), 0, DataType.TYPE, null, Arrays.asList(finderReturnType));\r\n    MethodMetadataBuilder methodBuilder = new MethodMetadataBuilder(getId(), Modifier.PUBLIC + Modifier.ABSTRACT, finderName, returnType, parameterTypes, parameterNames, null);\r\n    return methodBuilder.build();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaCustomMetadata.getFinderMethodsAndCounts",
	"Comment": "return the finder name methods and the related count method if exists.",
	"Method": "Map<JavaSymbolName, MethodMetadata> getFinderMethodsAndCounts(){\r\n    return finderMethodsAndCounts;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.web.mvc.controller.addon.finder.WebFinderCommands.addController",
	"Comment": "this method provides the command definition to be able to addnew finder on controllers.",
	"Method": "void addController(JavaType entity,boolean all,String queryMethod,String responseType,JavaPackage controllerPackage,String pathPrefix){\r\n    Map<String, ControllerMVCResponseService> responseTypeServices = getInstalledControllerMVCResponseTypes();\r\n    ControllerMVCResponseService controllerResponseType = null;\r\n    if (responseType != null) {\r\n        if (!responseTypeServices.containsKey(responseType)) {\r\n            LOGGER.log(Level.SEVERE, \"ERROR: Provided responseType is not valid. Use autocomplete feature \" + \"to obtain valid responseTypes.\");\r\n            return;\r\n        } else {\r\n            controllerResponseType = responseTypeServices.get(responseType);\r\n        }\r\n    } else {\r\n        controllerResponseType = responseTypeServices.get(\"JSON\");\r\n    }\r\n    if (!all) {\r\n        List<String> queryMethods = new ArrayList<String>();\r\n        if (queryMethod != null) {\r\n            queryMethods.add(queryMethod);\r\n        } else {\r\n            queryMethods = getFinders(entity, controllerResponseType);\r\n        }\r\n        webFinderOperations.createOrUpdateSearchControllerForEntity(entity, queryMethods, controllerResponseType, controllerPackage, pathPrefix);\r\n    } else {\r\n        webFinderOperations.createOrUpdateSearchControllerForAllEntities(controllerResponseType, controllerPackage, pathPrefix);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.draw2d.parts.ScrollableThumbnail.setViewport",
	"Comment": "sets the viewport that this scrollablethumbnail will synch with.",
	"Method": "void setViewport(Viewport port){\r\n    port.addPropertyChangeListener(Viewport.PROPERTY_VIEW_LOCATION, propListener);\r\n    port.addFigureListener(figureListener);\r\n    viewport = port;\r\n}"
}, {
	"Path": "org.springframework.data.redis.connection.StringRedisConnection.xDel",
	"Comment": "removes the specified entries from the stream. returns the number of items deleted, that may be different from the\tnumber of ids passed in case certain ids do not exist.",
	"Method": "Long xDel(String key,String entryIds,Long xDel,String key,RecordId recordIds){\r\n    return xDel(key, entryIds(entryIds));\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.RepositoryRestConfiguration.returnBodyOnCreate",
	"Comment": "whether to return a response body after creating an entity considering the given accept header.",
	"Method": "boolean returnBodyOnCreate(String acceptHeader){\r\n    return returnBodyOnCreate == null ? StringUtils.hasText(acceptHeader) : returnBodyOnCreate;\r\n}"
}, {
	"Path": "org.springframework.data.rest.core.config.ProjectionDefinitionConfiguration.addProjection",
	"Comment": "adds the given projection type for the given source types under the given name.",
	"Method": "ProjectionDefinitionConfiguration addProjection(Class<?> projectionType,ProjectionDefinitionConfiguration addProjection,Class<?> projectionType,Class<?> sourceTypes,ProjectionDefinitionConfiguration addProjection,Class<?> projectionType,String name,Class<?> sourceTypes){\r\n    Assert.notNull(projectionType, \"Projection type must not be null!\");\r\n    Assert.hasText(name, \"Name must not be null or empty!\");\r\n    Assert.notEmpty(sourceTypes, \"Source types must not be null!\");\r\n    for (Class<?> sourceType : sourceTypes) {\r\n        this.projectionDefinitions.add(ProjectionDefinition.of(sourceType, projectionType, name));\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "spoon.ContractVerifier.checkAssignmentContracts",
	"Comment": "checks that all assignments are aither a ctfieldwrite, a ctvariablewrite or a ctarraywrite",
	"Method": "void checkAssignmentContracts(){\r\n    for (CtAssignment assign : _rootPackage.getElements(new TypeFilter(CtAssignment.class))) {\r\n        CtExpression assigned = assign.getAssigned();\r\n        if (!(assigned instanceof CtFieldWrite || assigned instanceof CtVariableWrite || assigned instanceof CtArrayWrite)) {\r\n            throw new AssertionError(\"AssignmentContract error:\" + assign.getPosition() + \"\\n\" + assign.toString() + \"\\nAssigned is \" + assigned.getClass());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.layers.repository.jpa.addon.RepositoryJpaAnnotationValues.getDefaultReturnType",
	"Comment": "returns the default return type to use to finders in repository custom",
	"Method": "JavaType getDefaultReturnType(){\r\n    return defaultReturnType;\r\n}"
}, {
	"Path": "org.apache.cassandra.index.SecondaryIndexManager.reload",
	"Comment": "drops and adds new indexes associated with the underlying cf",
	"Method": "void reload(){\r\n    Indexes tableIndexes = baseCfs.metadata.getIndexes();\r\n    indexes.keySet().stream().filter(indexName -> !tableIndexes.has(indexName)).forEach(this::removeIndex);\r\n    for (IndexMetadata tableIndex : tableIndexes) addIndex(tableIndex);\r\n}"
}, {
	"Path": "org.spongepowered.api.world.extent.Extent.getLocation",
	"Comment": "gets a location in this extent at the given position. essentially, thisis a 3d pointer in the extent.",
	"Method": "Location<? extends Extent> getLocation(Vector3i position,Location<? extends Extent> getLocation,int x,int y,int z,Location<? extends Extent> getLocation,Vector3d position,Location<? extends Extent> getLocation,double x,double y,double z){\r\n    return getLocation(new Vector3i(x, y, z));\r\n}"
}, {
	"Path": "spoon.pattern.internal.DefaultGenerator.applyGeneratedBy",
	"Comment": "adds a generated by comment to the javadoc of generatedelement",
	"Method": "void applyGeneratedBy(CtElement generatedElement,String genBy){\r\n    if (isAddGeneratedBy() && generatedElement instanceof CtTypeMember) {\r\n        if (genBy != null) {\r\n            addGeneratedByComment(generatedElement, genBy);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.objectweb.carol.jndi.spi.CmiContext.unwrapObject",
	"Comment": "if this object is a reference wrapper return the reference if this objectis a resource wrapper return the resource",
	"Method": "Object unwrapObject(Object o,Name name){\r\n    return super.defaultUnwrapObject(o, name);\r\n}"
}, {
	"Path": "org.spongepowered.api.world.gen.populator.Mushroom.clearSupplierOverride",
	"Comment": "clears the supplier override to force the chance table to be usedinstead.",
	"Method": "void clearSupplierOverride(){\r\n    setSupplierOverride(null);\r\n}"
}, {
	"Path": "org.springframework.data.rest.webmvc.json.DomainObjectReader.mergeForPut",
	"Comment": "merges the state of given source object onto the target one preserving put semantics.",
	"Method": "T mergeForPut(T source,T target,ObjectMapper mapper){\r\n    Assert.notNull(mapper, \"ObjectMapper must not be null!\");\r\n    if (target == null || source == null) {\r\n        return source;\r\n    }\r\n    Class<? extends Object> type = target.getClass();\r\n    return // \r\n    entities.getPersistentEntity(// \r\n    type).filter(it -> !it.isImmutable()).map(it -> {\r\n        MergingPropertyHandler propertyHandler = new MergingPropertyHandler(source, target, it, mapper);\r\n        it.doWithProperties(propertyHandler);\r\n        it.doWithAssociations(new LinkedAssociationSkippingAssociationHandler(associationLinks, propertyHandler));\r\n        copyRemainingProperties(propertyHandler.getProperties(), source, target);\r\n        return target;\r\n    }).orElse(source);\r\n}"
}]