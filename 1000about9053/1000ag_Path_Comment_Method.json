[{
	"Path": "org.squirrelframework.foundation.util.Base64Coder.encodeLines",
	"Comment": "encodes a byte array into base 64 format and breaks the output intolines.",
	"Method": "String encodeLines(byte[] in,String encodeLines,byte[] in,int iOff,int iLen,int lineLen,String lineSeparator){\r\n    int blockLen = (lineLen * 3) / 4;\r\n    if (blockLen <= 0)\r\n        throw new IllegalArgumentException();\r\n    int lines = (iLen + blockLen - 1) / blockLen;\r\n    int bufLen = ((iLen + 2) / 3) * 4 + lines * lineSeparator.length();\r\n    StringBuilder buf = new StringBuilder(bufLen);\r\n    int ip = 0;\r\n    while (ip < iLen) {\r\n        int l = Math.min(iLen - ip, blockLen);\r\n        buf.append(encode(in, iOff + ip, l));\r\n        buf.append(lineSeparator);\r\n        ip += l;\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "teammates.ui.pagedata.PageData.getStudentProfileLink",
	"Comment": "returns the relative path to the student profile page. the user id is encoded in the url as a parameter.",
	"Method": "String getStudentProfileLink(String getStudentProfileLink,boolean isUnregistered){\r\n    String link = Const.ActionURIs.STUDENT_PROFILE_PAGE;\r\n    link = addUserIdToUrl(link);\r\n    if (isUnregistered) {\r\n        link = Url.addParamToUrl(student.getRegistrationUrl(), Const.ParamsNames.NEXT_URL, link);\r\n    }\r\n    return link;\r\n}"
}, {
	"Path": "teammates.test.driver.HtmlHelper.processPageSourceForHtmlComparison",
	"Comment": "processes the string from web page source for html comparison.",
	"Method": "String processPageSourceForHtmlComparison(String content){\r\n    return replaceUnpredictableValuesWithPlaceholders(suppressVariationsInInjectedValues(content));\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.itd.AbstractItdTypeDetailsProvidingMetadataItem.getField",
	"Comment": "convenience method for returning a simple private field based on thefield name, type, and initializer.",
	"Method": "FieldMetadataBuilder getField(int modifier,JavaSymbolName fieldName,JavaType fieldType,String fieldInitializer,FieldMetadataBuilder getField,JavaSymbolName fieldName,JavaType fieldType){\r\n    return getField(PRIVATE, fieldName, fieldType, null);\r\n}"
}, {
	"Path": "tlc2.tool.liveness.NodePtrTable.put",
	"Comment": "addinto the table. if the table has already contained k,\toverwrite the old value.",
	"Method": "void put(long k,long elem){\r\n    if (this.count >= this.thresh) {\r\n        this.grow();\r\n    }\r\n    int loc = ((int) k & 0x7FFFFFFF) % this.length;\r\n    while (true) {\r\n        if (this.elems[loc] == -1) {\r\n            this.keys[loc] = k;\r\n            this.elems[loc] = elem;\r\n            this.count++;\r\n            return;\r\n        }\r\n        if (this.keys[loc] == k) {\r\n            this.elems[loc] = elem;\r\n            return;\r\n        }\r\n        loc = (loc + 1) % this.length;\r\n    }\r\n}"
}, {
	"Path": "tla2sany.semantic.DecimalNode.walkGraph",
	"Comment": "walkgraph finds all reachable nodes in the semantic graph andinserts them in the hashtable semnodestable for use by theexplorer tool.",
	"Method": "void walkGraph(Hashtable<Integer, ExploreNode> semNodesTable,ExplorerVisitor visitor){\r\n    Integer uid = Integer.valueOf(myUID);\r\n    if (semNodesTable.get(uid) != null)\r\n        return;\r\n    semNodesTable.put(uid, this);\r\n    visitor.preVisit(this);\r\n    visitor.postVisit(this);\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.Shell.getTimeout",
	"Comment": "get the current shell execution timeout. \tthis is the time in milliseconds from which an execution is killed in case it has stalled.",
	"Method": "Integer getTimeout(){\r\n    return mShellTimeout;\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.ObjectAbstractTest.readExternalFormFromBytes",
	"Comment": "read a serialized or externalized object from bytes.useful for verifying serialization in memory.",
	"Method": "Object readExternalFormFromBytes(byte[] b){\r\n    ByteArrayInputStream stream = new ByteArrayInputStream(b);\r\n    return readExternalFormFromStream(stream);\r\n}"
}, {
	"Path": "org.springframework.roo.project.maven.Pom.getBuildPluginsExcludingVersion",
	"Comment": "returns any build plugins with the same groupid and artifactid as thegiven plugin. this is useful for upgrade cases.",
	"Method": "Set<Plugin> getBuildPluginsExcludingVersion(Plugin plugin){\r\n    Validate.notNull(plugin, \"Plugin to locate is required\");\r\n    final Set<Plugin> result = new HashSet<Plugin>();\r\n    for (final Plugin p : buildPlugins) {\r\n        if (plugin.getArtifactId().equals(p.getArtifactId()) && plugin.getGroupId().equals(p.getGroupId())) {\r\n            result.add(p);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.isGiverVisible",
	"Comment": "returns true if the giver from a response is visible to the current user.returns false otherwise.",
	"Method": "boolean isGiverVisible(FeedbackResponseAttributes response){\r\n    return isFeedbackParticipantVisible(true, response);\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackResponsesLogic.isResponseOfFeedbackQuestionVisibleToStudent",
	"Comment": "returns true if the responses of the question are visible to students.",
	"Method": "boolean isResponseOfFeedbackQuestionVisibleToStudent(FeedbackQuestionAttributes question){\r\n    if (question.isResponseVisibleTo(FeedbackParticipantType.STUDENTS)) {\r\n        return true;\r\n    }\r\n    boolean isStudentRecipientType = question.recipientType.equals(FeedbackParticipantType.STUDENTS) || question.recipientType.equals(FeedbackParticipantType.OWN_TEAM_MEMBERS) || question.recipientType.equals(FeedbackParticipantType.OWN_TEAM_MEMBERS_INCLUDING_SELF) || question.recipientType.equals(FeedbackParticipantType.GIVER) && question.giverType.equals(FeedbackParticipantType.STUDENTS);\r\n    if ((isStudentRecipientType || question.recipientType.isTeam()) && question.isResponseVisibleTo(FeedbackParticipantType.RECEIVER)) {\r\n        return true;\r\n    }\r\n    if (question.giverType == FeedbackParticipantType.TEAMS || question.isResponseVisibleTo(FeedbackParticipantType.OWN_TEAM_MEMBERS)) {\r\n        return true;\r\n    }\r\n    return question.isResponseVisibleTo(FeedbackParticipantType.RECEIVER_TEAM_MEMBERS);\r\n}"
}, {
	"Path": "tlc2.util.FP64.Extend",
	"Comment": "extend the fingerprint fp by the bytesof the stream is. ioexceptionis thrown in the event of an error reading the stream.",
	"Method": "long Extend(long fp,String s,long Extend,long fp,char[] chars,int start,int len,long Extend,long fp,byte[] bytes,int start,int len,long Extend,long fp,InputStream is,long Extend,long fp,char c,long Extend,long fp,byte b,long Extend,long fp,int x,long Extend,long fp,long fp1){\r\n    long[] mod = ByteModTable_7;\r\n    byte b = (byte) (fp1 & 0xFF);\r\n    fp = ((fp >>> 8) ^ (mod[(b ^ ((int) fp)) & 0xFF]));\r\n    fp1 = fp1 >>> 8;\r\n    b = (byte) (fp1 & 0xFF);\r\n    fp = ((fp >>> 8) ^ (mod[(b ^ ((int) fp)) & 0xFF]));\r\n    fp1 = fp1 >>> 8;\r\n    b = (byte) (fp1 & 0xFF);\r\n    fp = ((fp >>> 8) ^ (mod[(b ^ ((int) fp)) & 0xFF]));\r\n    fp1 = fp1 >>> 8;\r\n    b = (byte) (fp1 & 0xFF);\r\n    fp = ((fp >>> 8) ^ (mod[(b ^ ((int) fp)) & 0xFF]));\r\n    fp1 = fp1 >>> 8;\r\n    b = (byte) (fp1 & 0xFF);\r\n    fp = ((fp >>> 8) ^ (mod[(b ^ ((int) fp)) & 0xFF]));\r\n    fp1 = fp1 >>> 8;\r\n    b = (byte) (fp1 & 0xFF);\r\n    fp = ((fp >>> 8) ^ (mod[(b ^ ((int) fp)) & 0xFF]));\r\n    fp1 = fp1 >>> 8;\r\n    b = (byte) (fp1 & 0xFF);\r\n    fp = ((fp >>> 8) ^ (mod[(b ^ ((int) fp)) & 0xFF]));\r\n    fp1 = fp1 >>> 8;\r\n    b = (byte) (fp1 & 0xFF);\r\n    fp = ((fp >>> 8) ^ (mod[(b ^ ((int) fp)) & 0xFF]));\r\n    return fp;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.clickNoOnModal",
	"Comment": "waits for a confirmation modal to appear and click the no button.",
	"Method": "void clickNoOnModal(){\r\n    waitForModalShown();\r\n    WebElement noButton = browser.driver.findElement(By.cssSelector(\"[data-bb-handler='no']\"));\r\n    waitForElementToBeClickable(noButton);\r\n    clickDismissModalButtonAndWaitForModalHidden(noButton);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.job.ProverJob.getBeginLine",
	"Comment": "get the begin line of the region to pass to the prover.the begin line is the begin line of the location of the level node.",
	"Method": "int getBeginLine(LevelNode nodeToProve){\r\n    return nodeToProve.getLocation().beginLine();\r\n}"
}, {
	"Path": "com.facebook.swift.service.explicitidentifiers.ExplicitIdentifiersTest.testExplicitParameterOrdering",
	"Comment": "client passes all parameters, but in a different order than the server expects",
	"Method": "void testExplicitParameterOrdering(){\r\n    int integerParam = Integer.MAX_VALUE;\r\n    byte byteParam = Byte.MAX_VALUE;\r\n    Boolean booleanParam = Boolean.TRUE;\r\n    getClient().explicitParameterOrdering(\"STRING\", integerParam, booleanParam, byteParam);\r\n    assertEquals(getHandler().getLastIntegerParam().get(), (Integer) integerParam);\r\n    assertEquals(getHandler().getLastBooleanParam().get(), booleanParam);\r\n    assertEquals(getHandler().getLastByteParam().get(), (Byte) byteParam);\r\n    assertEquals(getHandler().getLastStringParam().get(), \"STRING\");\r\n    assertFalse(getHandler().hasLastCustomParam());\r\n}"
}, {
	"Path": "teammates.ui.controller.Action.getRequestParamAsBoolean",
	"Comment": "returns false if the specified parameter was not found in the request.",
	"Method": "boolean getRequestParamAsBoolean(String paramName){\r\n    return Boolean.parseBoolean(getRequestParamValue(paramName));\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.AnimatedGifEncoder.setPosition",
	"Comment": "sets the gif frame position. the position is 0,0 by default.useful for only updating a section of the image",
	"Method": "void setPosition(int x,int y){\r\n    this.x = x;\r\n    this.y = y;\r\n}"
}, {
	"Path": "tlc2.util.BufferedRandomAccessFile.reset",
	"Comment": "resets the bufferedrandomaccessfile so it appears to be a pristine file.\tthe previous content of the underlying disk file will be overwritten.",
	"Method": "void reset(){\r\n    setLength(0);\r\n    this.init();\r\n}"
}, {
	"Path": "tlc2.tool.Defns.get",
	"Comment": "returns the definition of key if its definition exists.otherwise, returns null.",
	"Method": "Object get(UniqueString key,Object get,String key){\r\n    UniqueString var = UniqueString.uniqueStringOf(key);\r\n    return this.get(var);\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorHomePageData.getEditCopyActionLink",
	"Comment": "retrieves the link to submit the request for copy of session.also contains home page link to return after the action.",
	"Method": "String getEditCopyActionLink(){\r\n    return getInstructorFeedbackEditCopyActionLink(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.editor.page.MainModelPage.setHasVariables",
	"Comment": "this method is used to enable and disable ui widgets depending on the fact if the specification has variables.",
	"Method": "void setHasVariables(boolean hasVariables){\r\n    this.closedFormulaRadio.setEnabled(hasVariables);\r\n    this.initNextFairnessRadio.setEnabled(hasVariables);\r\n    this.initFormulaSource.getControl().setEnabled(hasVariables);\r\n    this.nextFormulaSource.getControl().setEnabled(hasVariables);\r\n    this.specSource.getControl().setEnabled(hasVariables);\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.BeanInfoUtils.hasAccessorAndMutator",
	"Comment": "attempts to locate an accessor and a mutator method for a given field.not every javabean getter or setter actually backs to a field with anidentical name. in such cases, false will be returned.",
	"Method": "boolean hasAccessorAndMutator(FieldMetadata field,MemberDetails memberDetails){\r\n    Validate.notNull(field, \"Field required\");\r\n    Validate.notNull(memberDetails, \"Member details required\");\r\n    if (memberDetails.getMethod(getAccessorMethodName(field), new ArrayList<JavaType>()) != null && memberDetails.getMethod(getMutatorMethodName(field), Arrays.asList(field.getFieldType())) != null) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.preference.ProverPreferencePage.createFieldEditors",
	"Comment": "creates the field editors. field editors are abstractions ofthe common gui blocks needed to manipulate various typesof preferences. each field editor knows how to save andrestore itself.",
	"Method": "void createFieldEditors(){\r\n    for (int i = 1; i <= NUM_STATUS_COLORS; i++) {\r\n        addField(new ColorFieldEditor(getMainColorPrefName(i), \"Color \" + i, getFieldEditorParent()));\r\n        addField(new ComboFieldEditor(getColorPredPrefName(i), \"Predicate\", ColorPredicate.PREDEFINED_MACROS, getFieldEditorParent()));\r\n        addField(new BooleanFieldEditor(getLeafSideBarPrefName(i), \"Show Leaf Steps in Side Bar\", getFieldEditorParent()));\r\n        addField(new BooleanFieldEditor(getAppliesToLeafPrefName(i), \"Applies to Leaf Steps Only\", getFieldEditorParent()));\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.InstructorPrivileges.isAllowedForPrivilegeAnySection",
	"Comment": "returns true if privilege for session is present for any section.",
	"Method": "boolean isAllowedForPrivilegeAnySection(String sessionName,String privilegeName){\r\n    return isAllowedInSessionLevelAnySection(sessionName, privilegeName);\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.XmlRoundTripUtils.checkNamespaces",
	"Comment": "compare necessary namespace declarations between original and proposeddocument, if namespaces in the original are missing compared to theproposed, we add them to the original.",
	"Method": "boolean checkNamespaces(Document original,Document proposed){\r\n    boolean originalDocumentChanged = false;\r\n    final NamedNodeMap nsNodes = proposed.getDocumentElement().getAttributes();\r\n    for (int i = 0; i < nsNodes.getLength(); i++) {\r\n        if (0 == original.getDocumentElement().getAttribute(nsNodes.item(i).getNodeName()).length()) {\r\n            original.getDocumentElement().setAttribute(nsNodes.item(i).getNodeName(), nsNodes.item(i).getNodeValue());\r\n            originalDocumentChanged = true;\r\n        }\r\n    }\r\n    return originalDocumentChanged;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.TLAFastPartitioner.isSupportedContentType",
	"Comment": "returns whether the given type is one of the legal content types.may be extended by subclasses.",
	"Method": "boolean isSupportedContentType(String contentType){\r\n    if (contentType != null) {\r\n        for (int i = 0; i < fLegalContentTypes.length; i++) {\r\n            if (fLegalContentTypes[i].equals(contentType))\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.itd.AbstractItdTypeDetailsProvidingMetadataItem.ensureGovernorIsAnnotated",
	"Comment": "ensures that the governor is annotated with the given annotation",
	"Method": "void ensureGovernorIsAnnotated(AnnotationMetadataBuilder annotationMetadata){\r\n    if (governorTypeDetails.getAnnotation(annotationMetadata.getAnnotationType()) == null) {\r\n        builder.addAnnotation(annotationMetadata);\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.TLAEditor.doSave",
	"Comment": "we override this method to add information about who modified the file when.",
	"Method": "void doSave(IProgressMonitor progressMonitor){\r\n    service.send(PRE_SAVE_EVENT, this);\r\n    final IEditorInput editorInput = this.getEditorInput();\r\n    IDocument doc = this.getDocumentProvider().getDocument(editorInput);\r\n    String text = doc.get();\r\n    int historyStart = text.indexOf(ResourceHelper.modificationHistory);\r\n    if (historyStart > -1) {\r\n        int newEntryStart = historyStart + ResourceHelper.modificationHistory.length();\r\n        String user = System.getProperty(\"user.name\");\r\n        String searchString = ResourceHelper.modifiedBy + user;\r\n        int searchStringLength = searchString.length();\r\n        boolean found = false;\r\n        int nextEntry = newEntryStart - 1;\r\n        int endOfLine = -1;\r\n        label: while (!found) {\r\n            nextEntry = text.indexOf(ResourceHelper.lastModified, nextEntry + 1);\r\n            if (nextEntry < 0) {\r\n                break label;\r\n            }\r\n            endOfLine = text.indexOf(StringHelper.newline, nextEntry + 1);\r\n            if (endOfLine < 0) {\r\n                endOfLine = text.length();\r\n            }\r\n            int realEOL = endOfLine;\r\n            while (text.charAt(realEOL - 1) == ' ') {\r\n                realEOL--;\r\n            }\r\n            if ((nextEntry + searchStringLength < realEOL) && (searchString.equals(text.substring(realEOL - searchStringLength, realEOL)))) {\r\n                found = true;\r\n            }\r\n        }\r\n        try {\r\n            if (found) {\r\n                doc.replace(nextEntry, endOfLine - nextEntry, \"\");\r\n            }\r\n            doc.replace(newEntryStart, 0, ResourceHelper.lastModified + (new Date()) + searchString);\r\n            lastUndoOperations.clear();\r\n            final IOperationHistory operationHistory = PlatformUI.getWorkbench().getOperationSupport().getOperationHistory();\r\n            final IUndoableOperation[] undoHistory = operationHistory.getUndoHistory(getUndoContext());\r\n            if (found) {\r\n                lastUndoOperations.add(undoHistory[undoHistory.length - 2]);\r\n            }\r\n            lastUndoOperations.add(undoHistory[undoHistory.length - 1]);\r\n        } catch (BadLocationException e) {\r\n        }\r\n    }\r\n    super.doSave(progressMonitor);\r\n    if (editorInput instanceof FileEditorInput) {\r\n        final FileEditorInput fei = (FileEditorInput) editorInput;\r\n        final IFile spec = fei.getFile();\r\n        service.post(SAVE_EVENT, spec);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.file.monitor.polling.PollingFileMonitorService.publish",
	"Comment": "publish the events, if needed.this method assumes the caller has already acquired a synchronisationlock.",
	"Method": "void publish(List<FileEvent> eventsToPublish){\r\n    if (eventsToPublish.isEmpty()) {\r\n        return;\r\n    }\r\n    if (fileEventListeners.isEmpty() || eventsToPublish.isEmpty()) {\r\n        return;\r\n    }\r\n    for (final FileEvent event : eventsToPublish) {\r\n        updateChanges(event.getFileDetails().getCanonicalPath(), event.getOperation() == FileOperation.DELETED);\r\n        for (final FileEventListener l : fileEventListeners) {\r\n            l.onFileEvent(event);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorFeedbackEditPageData.getQuestionTypeChoiceOptions",
	"Comment": "returns string of html containing a list of options for selecting question type.used in instructorfeedbackedit.jsp for selecting the question type for a new question.",
	"Method": "String getQuestionTypeChoiceOptions(){\r\n    StringBuilder options = new StringBuilder();\r\n    for (FeedbackQuestionType type : FeedbackQuestionType.values()) {\r\n        options.append(type.getFeedbackQuestionDetailsInstance().getQuestionTypeChoiceOption());\r\n    }\r\n    return options.toString();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.ResourceHelper.deleteProject",
	"Comment": "deletes the project\tthe boolean argument isforget was added by ll on 3 august 2011. it is\ttrue iff the toolbox should only remove the spec from its list of specs\tbut should not delete its .toolbox directory.",
	"Method": "void deleteProject(IProject project,IProgressMonitor aMonitor,boolean isForget){\r\n    try {\r\n        if (isForget) {\r\n            project.delete(IResource.NEVER_DELETE_PROJECT_CONTENT, aMonitor);\r\n        } else {\r\n            project.delete(true, aMonitor);\r\n        }\r\n    } catch (CoreException e) {\r\n        Activator.getDefault().logError(\"Error deleting a specification\", e);\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.getPossibleGiversInSection",
	"Comment": "get the possible givers for the question specified within specified section.",
	"Method": "List<String> getPossibleGiversInSection(FeedbackQuestionAttributes fqa,String section){\r\n    List<String> allPossibleGivers = getPossibleGivers(fqa);\r\n    if (section == null || \"All\".equals(section)) {\r\n        return allPossibleGivers;\r\n    }\r\n    List<String> giversInSection = new ArrayList();\r\n    for (String giverIdentifier : allPossibleGivers) {\r\n        if (getSectionFromRoster(giverIdentifier).equals(section)) {\r\n            giversInSection.add(giverIdentifier);\r\n        }\r\n    }\r\n    return giversInSection;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.traceexplorer.TraceExplorerComposite.changeButtonEnablement",
	"Comment": "if a formula in the table is selected, then enable the remove and edit buttons, else disable them.",
	"Method": "void changeButtonEnablement(){\r\n    IStructuredSelection selection = (IStructuredSelection) tableViewer.getSelection();\r\n    if (buttonRemove != null) {\r\n        buttonRemove.setEnabled(!selection.isEmpty());\r\n    }\r\n    if (buttonEdit != null) {\r\n        buttonEdit.setEnabled(selection.size() == 1);\r\n    }\r\n    if (buttonExplore != null) {\r\n        buttonExplore.setEnabled(view.getTrace() != null && !view.getTrace().isTraceEmpty() && tableViewer.getCheckedElements().length > 0);\r\n    }\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorFeedbackSessionsPageData.getEditCopyActionLink",
	"Comment": "retrieves the link to submit the request for copy of session.also contains feedback page link to return after the action.",
	"Method": "String getEditCopyActionLink(){\r\n    return getInstructorFeedbackEditCopyActionLink(Const.ActionURIs.INSTRUCTOR_FEEDBACK_SESSIONS_PAGE);\r\n}"
}, {
	"Path": "tla2sany.semantic.AssumeNode.getAssume",
	"Comment": "returns the expression that is the statement of the assumption",
	"Method": "ExprNode getAssume(){\r\n    return this.assumeExpr;\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.plugins.pcx.BitRotator.bitRotateCW",
	"Comment": "rotate bits clockwise.the iffimagereader uses this to convert pixel bits from planar to chunky.bits from the source are rotated 90 degrees clockwise written to thedestination.",
	"Method": "void bitRotateCW(byte[] pSrc,int pSrcPos,int pSrcStep,byte[] pDst,int pDstPos,int pDstStep){\r\n    int idx = pSrcPos;\r\n    int lonyb;\r\n    int hinyb;\r\n    long lo = 0;\r\n    long hi = 0;\r\n    for (int i = 0; i < 8; i++) {\r\n        lonyb = pSrc[idx] & 0xF;\r\n        hinyb = (pSrc[idx] >> 4) & 0xF;\r\n        lo |= RTABLE[i][lonyb];\r\n        hi |= RTABLE[i][hinyb];\r\n        idx += pSrcStep;\r\n    }\r\n    idx = pDstPos;\r\n    pDst[idx] = (byte) ((hi >> 24) & 0xFF);\r\n    idx += pDstStep;\r\n    if (idx < pDst.length) {\r\n        pDst[idx] = (byte) ((hi >> 16) & 0xFF);\r\n        idx += pDstStep;\r\n        if (idx < pDst.length) {\r\n            pDst[idx] = (byte) ((hi >> 8) & 0xFF);\r\n            idx += pDstStep;\r\n            if (idx < pDst.length) {\r\n                pDst[idx] = (byte) (hi & 0xFF);\r\n                idx += pDstStep;\r\n            }\r\n        }\r\n    }\r\n    if (idx < pDst.length) {\r\n        pDst[idx] = (byte) ((lo >> 24) & 0xFF);\r\n        idx += pDstStep;\r\n        if (idx < pDst.length) {\r\n            pDst[idx] = (byte) ((lo >> 16) & 0xFF);\r\n            idx += pDstStep;\r\n            if (idx < pDst.length) {\r\n                pDst[idx] = (byte) ((lo >> 8) & 0xFF);\r\n                idx += pDstStep;\r\n                if (idx < pDst.length) {\r\n                    pDst[idx] = (byte) (lo & 0xFF);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.isRecipientVisible",
	"Comment": "returns true if the recipient from a response is visible to the current user.returns false otherwise.",
	"Method": "boolean isRecipientVisible(FeedbackResponseAttributes response){\r\n    return isFeedbackParticipantVisible(false, response);\r\n}"
}, {
	"Path": "teammates.test.driver.BackDoor.removeDataBundle",
	"Comment": "removes given data from the datastore.if given entities have already been deleted, it fails silently.",
	"Method": "String removeDataBundle(DataBundle dataBundle){\r\n    removeAdminEmailsFromDataBundle(dataBundle);\r\n    String dataBundleJson = JsonUtils.toJson(dataBundle);\r\n    Map<String, String> params = createParamMap(BackDoorOperation.OPERATION_REMOVE_DATABUNDLE);\r\n    params.put(BackDoorOperation.PARAMETER_DATABUNDLE_JSON, dataBundleJson);\r\n    return makePostRequest(params);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.contribution.SizeControlContribution.updateSize",
	"Comment": "updates status from the specification currently loaded in the specmanager",
	"Method": "void updateSize(long size){\r\n    if (sizeLabel == null || sizeLabel.isDisposed()) {\r\n        return;\r\n    }\r\n    UIHelper.runUIAsync(new Runnable() {\r\n        public void run() {\r\n            if (!composite.isDisposed()) {\r\n                composite.setVisible(false);\r\n            }\r\n            if (!sizeLabel.isDisposed() && !composite.isDisposed()) {\r\n                if (size / (1000 * 1000 * 1000) > 0) {\r\n                    sizeLabel.setText(Long.toString(size / (1000 * 1000 * 1000)) + \" gB\");\r\n                } else if (size / (1000 * 1000) > 0) {\r\n                    sizeLabel.setText(Long.toString(size / (1000 * 1000)) + \" mB\");\r\n                } else if (size / 1000 > 0) {\r\n                    sizeLabel.setText(Long.toString(size / 1000) + \" kB\");\r\n                } else {\r\n                    sizeLabel.setText(Long.toString(size) + \" bytes\");\r\n                }\r\n                if ((size / 1000L) < Activator.getDefault().getPreferenceStore().getInt(IPreferenceConstants.I_MIN_DISPLAYED_SIZE)) {\r\n                    composite.setVisible(false);\r\n                    return;\r\n                }\r\n                sizeLabel.redraw();\r\n                composite.setVisible(true);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.contribution.SizeControlContribution.updateSize",
	"Comment": "updates status from the specification currently loaded in the specmanager",
	"Method": "void updateSize(long size){\r\n    if (!composite.isDisposed()) {\r\n        composite.setVisible(false);\r\n    }\r\n    if (!sizeLabel.isDisposed() && !composite.isDisposed()) {\r\n        if (size / (1000 * 1000 * 1000) > 0) {\r\n            sizeLabel.setText(Long.toString(size / (1000 * 1000 * 1000)) + \" gB\");\r\n        } else if (size / (1000 * 1000) > 0) {\r\n            sizeLabel.setText(Long.toString(size / (1000 * 1000)) + \" mB\");\r\n        } else if (size / 1000 > 0) {\r\n            sizeLabel.setText(Long.toString(size / 1000) + \" kB\");\r\n        } else {\r\n            sizeLabel.setText(Long.toString(size) + \" bytes\");\r\n        }\r\n        if ((size / 1000L) < Activator.getDefault().getPreferenceStore().getInt(IPreferenceConstants.I_MIN_DISPLAYED_SIZE)) {\r\n            composite.setVisible(false);\r\n            return;\r\n        }\r\n        sizeLabel.redraw();\r\n        composite.setVisible(true);\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.launch.TLCModelLaunchDelegate.launch",
	"Comment": "5. method called on launchmain launch method called by the platform on model launches",
	"Method": "void launch(ILaunchConfiguration config,String mode,ILaunch launch,IProgressMonitor monitor){\r\n    if (!MODE_MODELCHECK.equals(mode)) {\r\n        throw new CoreException(new Status(IStatus.ERROR, TLCActivator.PLUGIN_ID, \"Unsupported launch mode \" + mode));\r\n    }\r\n    final Model model = config.getAdapter(Model.class);\r\n    final IProject project = model.getSpec().getProject();\r\n    if (project == null) {\r\n        throw new CoreException(new Status(IStatus.ERROR, TLCActivator.PLUGIN_ID, \"Error accessing the spec project \" + model.getSpec().getName()));\r\n    }\r\n    model.setRunning(true);\r\n    model.setOriginalTraceShown(true);\r\n    int numberOfWorkers = config.getAttribute(LAUNCH_NUMBER_OF_WORKERS, LAUNCH_NUMBER_OF_WORKERS_DEFAULT);\r\n    String cloud = \"off\";\r\n    if (config.hasAttribute(LAUNCH_DISTRIBUTED)) {\r\n        try {\r\n            cloud = config.getAttribute(LAUNCH_DISTRIBUTED, LAUNCH_DISTRIBUTED_DEFAULT);\r\n        } catch (CoreException e) {\r\n            boolean distributed = config.getAttribute(LAUNCH_DISTRIBUTED, false);\r\n            if (distributed) {\r\n                cloud = \"ad hoc\";\r\n            }\r\n        }\r\n    }\r\n    Job job = null;\r\n    if (\"off\".equalsIgnoreCase(cloud)) {\r\n        job = new TLCProcessJob(model.getSpec().getName(), model.getName(), launch, numberOfWorkers);\r\n        job.setRule(mutexRule);\r\n    } else {\r\n        if (\"ad hoc\".equalsIgnoreCase(cloud)) {\r\n            job = new DistributedTLCJob(model.getSpec().getName(), model.getName(), launch, numberOfWorkers);\r\n            job.setRule(mutexRule);\r\n        } else {\r\n            numberOfWorkers = config.getAttribute(LAUNCH_DISTRIBUTED_NODES_COUNT, LAUNCH_DISTRIBUTED_NODES_COUNT_DEFAULT);\r\n            final IFolder launchDir = model.getFolder();\r\n            final File file = launchDir.getRawLocation().makeAbsolute().toFile();\r\n            final BundleContext bundleContext = FrameworkUtil.getBundle(TLCModelLaunchDelegate.class).getBundleContext();\r\n            final ServiceReference<IExtensionRegistry> serviceReference = bundleContext.getServiceReference(IExtensionRegistry.class);\r\n            final IExtensionRegistry registry = bundleContext.getService(serviceReference);\r\n            final IConfigurationElement[] elements = registry.getConfigurationElementsFor(\"org.lamport.tla.toolx.tlc.job\");\r\n            for (IConfigurationElement element : elements) {\r\n                final DummyProcess process = new DummyProcess(launch);\r\n                launch.addProcess(process);\r\n                final TLCJobFactory factory = (TLCJobFactory) element.createExecutableExtension(\"clazz\");\r\n                final Properties props = new Properties();\r\n                props.put(TLCJobFactory.MAIN_CLASS, tlc2.TLC.class.getName());\r\n                props.put(TLCJobFactory.MODEL_NAME, model.getName());\r\n                props.put(TLCJobFactory.SPEC_NAME, model.getSpec().getName());\r\n                if (numberOfWorkers > 1) {\r\n                    props.put(TLCJobFactory.MAIN_CLASS, tlc2.tool.distributed.TLCServer.class.getName());\r\n                }\r\n                props.put(TLCJobFactory.MAIL_ADDRESS, config.getAttribute(LAUNCH_DISTRIBUTED_RESULT_MAIL_ADDRESS, \"tlc@localhost\"));\r\n                final StringBuffer tlcParams = new StringBuffer();\r\n                final int fpSeedOffset = launch.getLaunchConfiguration().getAttribute(LAUNCH_FP_INDEX, LAUNCH_FP_INDEX_DEFAULT);\r\n                tlcParams.append(\"-fp \");\r\n                tlcParams.append(String.valueOf(fpSeedOffset - 1));\r\n                tlcParams.append(\" \");\r\n                final int maxSetSize = launch.getLaunchConfiguration().getAttribute(LAUNCH_MAXSETSIZE, TLCGlobals.setBound);\r\n                if (maxSetSize != TLCGlobals.setBound) {\r\n                    tlcParams.append(\"-maxSetSize \");\r\n                    tlcParams.append(String.valueOf(maxSetSize));\r\n                    tlcParams.append(\" \");\r\n                }\r\n                if (model.getAttribute(LAUNCH_DEFER_LIVENESS, false)) {\r\n                    tlcParams.append(\"-lncheck \");\r\n                    tlcParams.append(\"final\");\r\n                    tlcParams.append(\" \");\r\n                }\r\n                boolean checkDeadlock = config.getAttribute(IModelConfigurationConstants.MODEL_CORRECTNESS_CHECK_DEADLOCK, IModelConfigurationDefaults.MODEL_CORRECTNESS_CHECK_DEADLOCK_DEFAULT);\r\n                if (!checkDeadlock) {\r\n                    tlcParams.append(\"-deadlock\");\r\n                }\r\n                job = factory.getTLCJob(cloud, file, numberOfWorkers, props, tlcParams.toString());\r\n                job.addJobChangeListener(new WithStatusJobChangeListener(process, config.getAdapter(Model.class)));\r\n                break;\r\n            }\r\n            if (job == null) {\r\n                throw new CoreException(new Status(IStatus.ERROR, TLCActivator.PLUGIN_ID, String.format(\"The distribution mode '%s' selected in the \\\"How to run?\\\" section caused \" + \"an error. Check the Toolbox's \\\"Installation Details\\\" if the \" + \"'JCloud distributed TLC provider' is installed. If not, this is a bug \" + \"and should be reported to the Toolbox authors. Thank you for \" + \"your help and sorry for the inconvenience.\" + \"\\n\\n\" + \"In the meantime, try running the Toolbox in non-distributed mode \" + \"by setting \\\"Run in distributed mode\\\" to 'off'. \" + \"You might have to 'Repair' your model via the \\\"Spec Explorer\\\" first.\", cloud)));\r\n            }\r\n        }\r\n    }\r\n    job.setPriority(Job.LONG);\r\n    job.setUser(true);\r\n    TLCJobChangeListener tlcJobListener = new TLCJobChangeListener(config.getAdapter(Model.class));\r\n    job.addJobChangeListener(tlcJobListener);\r\n    job.schedule();\r\n}"
}, {
	"Path": "teammates.ui.pagedata.PageData.getInstructorFeedbackEditCopyActionLink",
	"Comment": "retrieves the link to submit the request for copy of session.appends the return url to the link.",
	"Method": "String getInstructorFeedbackEditCopyActionLink(String returnUrl){\r\n    String link = Const.ActionURIs.INSTRUCTOR_FEEDBACK_EDIT_COPY;\r\n    link = Url.addParamToUrl(link, Const.ParamsNames.NEXT_URL, returnUrl);\r\n    link = addSessionTokenToUrl(link);\r\n    return link;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.BeanInfoUtils.isEntityReasonablyNamed",
	"Comment": "determines whether the presented entity is a test class or not.",
	"Method": "boolean isEntityReasonablyNamed(JavaType entity){\r\n    Validate.notNull(entity, \"Entity required\");\r\n    return !entity.getSimpleTypeName().startsWith(\"Test\") && !entity.getSimpleTypeName().endsWith(\"TestCase\") && !entity.getSimpleTypeName().endsWith(\"Test\");\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackResponsesLogic.getFeedbackResponsesFromStudentOrTeamForQuestion",
	"Comment": "get existing feedback responses from student or his team for the givenquestion.",
	"Method": "List<FeedbackResponseAttributes> getFeedbackResponsesFromStudentOrTeamForQuestion(FeedbackQuestionAttributes question,StudentAttributes student){\r\n    if (question.giverType == FeedbackParticipantType.TEAMS) {\r\n        return getFeedbackResponsesFromTeamForQuestion(question.getId(), question.courseId, student.team);\r\n    }\r\n    return frDb.getFeedbackResponsesFromGiverForQuestion(question.getId(), student.email);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.setHeight",
	"Comment": "sets the height of the button. distance should be the value in dp, it will beconverted to the appropriate pixel value",
	"Method": "void setHeight(int height){\r\n    this.height = height;\r\n}"
}, {
	"Path": "org.springframework.roo.project.maven.Pom.isBuildPluginRegistered",
	"Comment": "indicates whether the given build plugin is registered, based on itsgroupid, artifactid, and version.",
	"Method": "boolean isBuildPluginRegistered(Plugin plugin){\r\n    return plugin != null && isPluginRegistered(plugin.getGAV());\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.ShellStream.isRunning",
	"Comment": "check whether the shell is currently busy processing a command.",
	"Method": "Boolean isRunning(){\r\n    return mCounter.size() > 0;\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.utils.File.remove",
	"Comment": "remove the file. \tfolders will be recursively cleaned before deleting.",
	"Method": "Boolean remove(){\r\n    synchronized (mLock) {\r\n        Boolean status = false;\r\n        if (exists()) {\r\n            String[] fileList = getList();\r\n            String path = getAbsolutePath();\r\n            if (fileList != null) {\r\n                for (String intry : fileList) {\r\n                    if (!getFile(path + \"/\" + intry).remove()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            if (!(status = mFile.delete())) {\r\n                String rmCommand = isFile() || isLink() ? \"unlink\" : \"rmdir\";\r\n                String[] commands = new String[] { \"rm -rf '\" + path + \"' 2> /dev/null\", rmCommand + \" '\" + path + \"' 2> /dev/null\" };\r\n                for (String command : commands) {\r\n                    Result result = mShell.createAttempts(command).execute();\r\n                    if (result != null && (status = result.wasSuccessful())) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (status) {\r\n                Bundle bundle = new Bundle();\r\n                bundle.putString(\"action\", \"exists\");\r\n                bundle.putString(\"location\", path);\r\n                Shell.sendBroadcast(\"file\", bundle);\r\n            }\r\n        } else {\r\n            status = true;\r\n        }\r\n        return status;\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.Time.getTimeInMillis",
	"Comment": "gets the full time in milliseconds, for use in creating dates orsimilar.",
	"Method": "long getTimeInMillis(){\r\n    return (long) time * 1000L;\r\n}"
}, {
	"Path": "teammates.logic.api.Logic.restoreAllFeedbackSessionsFromRecycleBin",
	"Comment": "restores all sessions from recycle bin to feedback sessions table.",
	"Method": "void restoreAllFeedbackSessionsFromRecycleBin(List<InstructorAttributes> instructorList){\r\n    Assumption.assertNotNull(instructorList);\r\n    feedbackSessionsLogic.restoreAllFeedbackSessionsFromRecycleBin(instructorList);\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorCopyFsToModal.waitForModalLoadingError",
	"Comment": "waits for the error message indicating that the loading of the form modal has failed.",
	"Method": "void waitForModalLoadingError(){\r\n    waitForElementPresence(By.id(\"fs-copy-modal-error\"));\r\n}"
}, {
	"Path": "teammates.storage.api.InstructorsDb.putDocuments",
	"Comment": "batch creates or updates documents for the given instructors.",
	"Method": "void putDocuments(List<InstructorAttributes> instructorParams){\r\n    List<SearchDocument> instructorDocuments = new ArrayList();\r\n    for (InstructorAttributes instructor : instructorParams) {\r\n        if (instructor.key == null) {\r\n            instructor = this.getInstructorForEmail(instructor.courseId, instructor.email);\r\n        }\r\n        if (instructor.key != null) {\r\n            instructorDocuments.add(new InstructorSearchDocument(instructor));\r\n        }\r\n    }\r\n    putDocuments(Const.SearchIndex.INSTRUCTOR, instructorDocuments);\r\n}"
}, {
	"Path": "teammates.logic.api.Logic.getFeedbackSessionsWhichNeedAutomatedPublishedEmailsToBeSent",
	"Comment": "returns a list of sessions that require automated emails to be sent as they are published.",
	"Method": "List<FeedbackSessionAttributes> getFeedbackSessionsWhichNeedAutomatedPublishedEmailsToBeSent(){\r\n    return feedbackSessionsLogic.getFeedbackSessionsWhichNeedAutomatedPublishedEmailsToBeSent();\r\n}"
}, {
	"Path": "it.michelelacorte.swipeablecard.SwipeableCard.animationCardDown",
	"Comment": "animation card for down animation, please do not modify this.",
	"Method": "void animationCardDown(CardView card,Toolbar toolbar,long duration){\r\n    new CountDownTimer(1, 1) {\r\n        public void onTick(long millisUntilFinished) {\r\n        }\r\n        public void onFinish() {\r\n            card.animate().translationY(height - ((int) (toolbar.getHeight() * 1.7))).setDuration(duration).start();\r\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\r\n                fab.animate().translationY((height - ((int) (toolbar.getHeight() * 1.7))) + card.getHeight() - (fab.getHeight() - fab.getHeight() / 4)).setDuration(duration).start();\r\n            } else {\r\n                fab.animate().translationY((height - ((int) (toolbar.getHeight() * 1.7))) + card.getHeight() - (fab.getHeight() - fab.getHeight() / 3)).setDuration(duration).start();\r\n            }\r\n        }\r\n    }.start();\r\n}"
}, {
	"Path": "it.michelelacorte.swipeablecard.SwipeableCard.animationCardDown",
	"Comment": "animation card for down animation, please do not modify this.",
	"Method": "void animationCardDown(CardView card,Toolbar toolbar,long duration){\r\n}"
}, {
	"Path": "it.michelelacorte.swipeablecard.SwipeableCard.animationCardDown",
	"Comment": "animation card for down animation, please do not modify this.",
	"Method": "void animationCardDown(CardView card,Toolbar toolbar,long duration){\r\n    card.animate().translationY(height - ((int) (toolbar.getHeight() * 1.7))).setDuration(duration).start();\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\r\n        fab.animate().translationY((height - ((int) (toolbar.getHeight() * 1.7))) + card.getHeight() - (fab.getHeight() - fab.getHeight() / 4)).setDuration(duration).start();\r\n    } else {\r\n        fab.animate().translationY((height - ((int) (toolbar.getHeight() * 1.7))) + card.getHeight() - (fab.getHeight() - fab.getHeight() / 3)).setDuration(duration).start();\r\n    }\r\n}"
}, {
	"Path": "tlc2.module.TLC.Assert",
	"Comment": "returns true if the value of v1 is true. otherwise, throwsan exception with v2 as the error message.",
	"Method": "Value Assert(Value v1,Value v2){\r\n    if ((v1 instanceof BoolValue) && ((BoolValue) v1).val) {\r\n        return v1;\r\n    }\r\n    throw new EvalException(EC.TLC_VALUE_ASSERT_FAILED, Value.ppr(v2.toString()));\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.utils.File.getAbsolutePath",
	"Comment": "returns the absolute path. an absolute path is a path that starts at a root of the file system.",
	"Method": "String getAbsolutePath(){\r\n    return mFile.getAbsolutePath();\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackResponseCommentsLogic.createFeedbackResponseComment",
	"Comment": "creates a feedback response comment.if the comment is given by feedback participant, ownership of the corresponding responseof the comment is not checked.",
	"Method": "FeedbackResponseCommentAttributes createFeedbackResponseComment(FeedbackResponseCommentAttributes frComment){\r\n    verifyIsCoursePresent(frComment.courseId);\r\n    verifyIsUserOfCourse(frComment.courseId, frComment.commentGiver, frComment.commentGiverType, frComment.isCommentFromFeedbackParticipant);\r\n    verifyIsFeedbackSessionOfCourse(frComment.courseId, frComment.feedbackSessionName);\r\n    try {\r\n        return frcDb.createFeedbackResponseComment(frComment);\r\n    } catch (EntityAlreadyExistsException e) {\r\n        try {\r\n            FeedbackResponseCommentAttributes existingComment = frcDb.getFeedbackResponseComment(frComment.feedbackResponseId, frComment.commentGiver, frComment.createdAt);\r\n            if (existingComment == null) {\r\n                existingComment = frcDb.getFeedbackResponseComment(frComment.courseId, frComment.createdAt, frComment.commentGiver);\r\n            }\r\n            frComment.setId(existingComment.getId());\r\n            return frcDb.updateFeedbackResponseComment(frComment);\r\n        } catch (Exception ex) {\r\n            Assumption.fail();\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.stream.BufferedImageInputStreamTest.rangeEquals",
	"Comment": "test two arrays for range equality. that is, they contain the same elements for some specified range.",
	"Method": "boolean rangeEquals(byte[] pFirst,int pFirstOffset,byte[] pSecond,int pSecondOffset,int pLength){\r\n    if (pFirst == pSecond && pFirstOffset == pSecondOffset) {\r\n        return true;\r\n    }\r\n    if (pFirst == null || pSecond == null) {\r\n        return false;\r\n    }\r\n    if (pFirst.length < pFirstOffset + pLength || pSecond.length < pSecondOffset + pLength) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < pLength; i++) {\r\n        if (pFirst[pFirstOffset + i] != pSecond[pSecondOffset + i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.ActivityUtils.refreshActivity",
	"Comment": "refresh the new followers, mentions, number of favorites, and retweeters",
	"Method": "boolean refreshActivity(){\r\n    boolean newActivity = false;\r\n    Twitter twitter;\r\n    if (!useSecondAccount) {\r\n        twitter = Utils.getTwitter(context, settings);\r\n    } else {\r\n        twitter = Utils.getSecondTwitter(context);\r\n    }\r\n    if (getMentions(twitter)) {\r\n        newActivity = true;\r\n    }\r\n    if (getQuotes(twitter)) {\r\n        newActivity = true;\r\n    }\r\n    if (getFollowers(twitter)) {\r\n        newActivity = true;\r\n    }\r\n    List<Status> myTweets = getMyTweets(twitter);\r\n    if (myTweets != null) {\r\n        if (getRetweets(twitter, myTweets)) {\r\n            newActivity = true;\r\n        }\r\n        if (getFavorites(myTweets)) {\r\n            newActivity = true;\r\n        }\r\n    }\r\n    sharedPrefs.edit().putBoolean(\"refresh_me_activity\", true).apply();\r\n    return newActivity;\r\n}"
}, {
	"Path": "teammates.common.util.SanitizationHelper.sanitizeForHtmlTag",
	"Comment": "escapes html tag safely. this function can be applied multiple times.",
	"Method": "String sanitizeForHtmlTag(String string){\r\n    if (string == null) {\r\n        return null;\r\n    }\r\n    return string.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\");\r\n}"
}, {
	"Path": "util.BufferedDataInputStream.readInt",
	"Comment": "reads and returns the next int valueencoded in the next four bytes of this stream, orthrows eofexception if the stream containsfewer than four bytes.",
	"Method": "int readInt(){\r\n    this.readFully(this.temp, 0, 4);\r\n    int res = temp[0];\r\n    res <<= 8;\r\n    res |= (temp[1] & 0xff);\r\n    res <<= 8;\r\n    res |= (temp[2] & 0xff);\r\n    res <<= 8;\r\n    res |= (temp[3] & 0xff);\r\n    return res;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.output.source.TagBasedTLCAnalyzer.getTaggedRegion",
	"Comment": "retrieves last detected coverage region, or null if no coverage information were available",
	"Method": "TLCRegion getTaggedRegion(){\r\n    return this.taggedRegion;\r\n}"
}, {
	"Path": "teammates.test.driver.GmailServiceMaker.getCredentialFromFlow",
	"Comment": "gets the credential containing the access token from the flow if it exists. otherwise a local server receiver is usedto receive authorization code and then exchanges the code for an access token.",
	"Method": "Credential getCredentialFromFlow(GoogleAuthorizationCodeFlow flow){\r\n    return new AuthorizationCodeInstalledApp(flow, new LocalServerReceiver()).authorize(username);\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.getFeedbackSessionResultsForInstructorFromSectionWithinRange",
	"Comment": "gets results of a feedback session to show to an instructor in a section in an indicated range.",
	"Method": "FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorFromSectionWithinRange(String feedbackSessionName,String courseId,String userEmail,String section,int range){\r\n    CourseRoster roster = new CourseRoster(studentsLogic.getStudentsForCourse(courseId), instructorsLogic.getInstructorsForCourse(courseId));\r\n    Map<String, String> params = new HashMap();\r\n    params.put(PARAM_IS_INCLUDE_RESPONSE_STATUS, \"true\");\r\n    params.put(PARAM_IN_SECTION, \"false\");\r\n    params.put(PARAM_FROM_SECTION, \"true\");\r\n    params.put(PARAM_TO_SECTION, \"false\");\r\n    params.put(PARAM_SECTION, section);\r\n    if (range > 0) {\r\n        params.put(PARAM_RANGE, String.valueOf(range));\r\n    }\r\n    return getFeedbackSessionResultsForUserWithParams(feedbackSessionName, courseId, userEmail, UserRole.INSTRUCTOR, roster, params);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.GotoMatchingParenHandler.findMatchingLeftParen",
	"Comment": "assumes that currloc is just past a right paren with indexparenidx in parens.it sets currloc to the location just pastthe matching left paren, or throws an exception if there is a matching error.",
	"Method": "void findMatchingLeftParen(int parenIdx){\r\n    int savedCurrLoc = currLoc;\r\n    int lastParenSearched = parenIdx;\r\n    boolean justWentToPrevRegion = false;\r\n    while (true) {\r\n        if (!justWentToPrevRegion) {\r\n            currLoc = currLoc - PARENS[lastParenSearched].length();\r\n        }\r\n        int pidx = -1;\r\n        while (currLoc > beginCurrRegion && ((pidx = getParenToLeftOf(currLoc)) == -1)) {\r\n            currLoc--;\r\n        }\r\n        if (pidx == -1) {\r\n            getPrevRegion();\r\n            currLoc = endCurrRegion;\r\n            justWentToPrevRegion = true;\r\n        } else {\r\n            if (pidx >= PCOUNT) {\r\n                findMatchingLeftParen(pidx);\r\n                lastParenSearched = pidx;\r\n                justWentToPrevRegion = false;\r\n            } else {\r\n                if ((pidx - parenIdx) % PCOUNT == 0) {\r\n                    return;\r\n                } else {\r\n                    throw new ParenErrorException(PARENS[pidx] + \" matches \" + PARENS[parenIdx], new Region(currLoc - PARENS[pidx].length(), PARENS[pidx].length()), new Region(savedCurrLoc - PARENS[parenIdx].length(), PARENS[parenIdx].length()));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionQuestionsBundle.resetAllResponses",
	"Comment": "empties responses for all questions in this bundle.used to not show existing responses when previewing as instructor",
	"Method": "void resetAllResponses(){\r\n    for (FeedbackQuestionAttributes question : questionResponseBundle.keySet()) {\r\n        questionResponseBundle.put(question, new ArrayList());\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.FeedbackQuestionAttributes.setQuestionDetails",
	"Comment": "converts the given feedbackquestiondetails object to json for storing.",
	"Method": "void setQuestionDetails(FeedbackQuestionDetails questionDetails){\r\n    questionMetaData = JsonUtils.toJson(questionDetails, getFeedbackQuestionDetailsClass());\r\n}"
}, {
	"Path": "org.squirrelframework.foundation.util.Base64Coder.decodeString",
	"Comment": "decodes a string from base64 format. no blanks or line breaks are allowedwithin the base64 encoded input data.",
	"Method": "String decodeString(String s){\r\n    return new String(decode(s));\r\n}"
}, {
	"Path": "teammates.ui.controller.InstructorFeedbackQuestionEditAction.validateQuestionGiverRecipientVisibility",
	"Comment": "validates that the giver and recipient for the given feedbackquestionattributes is valid for its question type.validates that the visibility for the given feedbackquestionattributes is valid for its question type.",
	"Method": "String validateQuestionGiverRecipientVisibility(FeedbackQuestionAttributes feedbackQuestionAttributes){\r\n    String errorMsg = \"\";\r\n    FeedbackQuestionDetails questionDetails = null;\r\n    Class<? extends FeedbackQuestionDetails> questionDetailsClass = feedbackQuestionAttributes.questionType.getQuestionDetailsClass();\r\n    Constructor<? extends FeedbackQuestionDetails> questionDetailsClassConstructor;\r\n    try {\r\n        questionDetailsClassConstructor = questionDetailsClass.getConstructor();\r\n        questionDetails = questionDetailsClassConstructor.newInstance();\r\n        Method m = questionDetailsClass.getMethod(\"validateGiverRecipientVisibility\", FeedbackQuestionAttributes.class);\r\n        errorMsg = (String) m.invoke(questionDetails, feedbackQuestionAttributes);\r\n    } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | InstantiationException e) {\r\n        log.severe(TeammatesException.toStringWithStackTrace(e));\r\n        Assumption.fail(\"Failed to instantiate Feedback*QuestionDetails instance for \" + feedbackQuestionAttributes.questionType.toString() + \" question type.\");\r\n    }\r\n    return errorMsg;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.TLAEditor.updateFoldingStructure",
	"Comment": "update the annotation structure in the editor.this is only currently used by commentfolding and should be removed because itis incorrect.",
	"Method": "void updateFoldingStructure(List<Position> positions){\r\n    if (annotationModel == null) {\r\n        return;\r\n    }\r\n    Annotation[] annotations = new Annotation[positions.size()];\r\n    Map<ProjectionAnnotation, Position> newAnnotations = new HashMap<ProjectionAnnotation, Position>();\r\n    for (int i = 0; i < positions.size(); i++) {\r\n        ProjectionAnnotation annotation = new ProjectionAnnotation();\r\n        newAnnotations.put(annotation, positions.get(i));\r\n        annotations[i] = annotation;\r\n    }\r\n    this.annotationModel.modifyAnnotations(oldAnnotations, newAnnotations, null);\r\n    oldAnnotations = annotations;\r\n}"
}, {
	"Path": "org.springframework.roo.file.monitor.polling.PollingFileMonitorService.recursiveAntMatch",
	"Comment": "locates all files under the specified current directory which patch thegiven ant path.",
	"Method": "void recursiveAntMatch(String antPath,File currentDirectory,SortedSet<FileDetails> result){\r\n    Validate.notNull(currentDirectory, \"Current directory required\");\r\n    Validate.isTrue(currentDirectory.exists() && currentDirectory.isDirectory(), \"Path '%s' does not exist or is not a directory\", currentDirectory);\r\n    Validate.notBlank(antPath, \"Ant path required\");\r\n    Validate.notNull(result, \"Result required\");\r\n    final File[] listFiles = currentDirectory.listFiles();\r\n    if (listFiles == null || listFiles.length == 0) {\r\n        return;\r\n    }\r\n    for (final File f : listFiles) {\r\n        try {\r\n            if (FileUtils.matchesAntPath(antPath, f.getCanonicalPath())) {\r\n                result.add(new FileDetails(f, f.lastModified()));\r\n            }\r\n        } catch (final IOException ignored) {\r\n        }\r\n        if (f.isDirectory()) {\r\n            recursiveAntMatch(antPath, f, result);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.test.driver.BackDoor.getWhetherPictureIsPresentInGcs",
	"Comment": "checks if a profile picture with the specified key is present in gcs.",
	"Method": "boolean getWhetherPictureIsPresentInGcs(String pictureKey){\r\n    Map<String, String> params = createParamMap(BackDoorOperation.OPERATION_IS_PICTURE_PRESENT_IN_GCS);\r\n    params.put(BackDoorOperation.PARAMETER_PICTURE_KEY, pictureKey);\r\n    return Boolean.parseBoolean(makePostRequest(params));\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackResultsPage.waitForPageStructureToLoad",
	"Comment": "waits until the page structure is loaded.does not wait for all the content that are loaded by ajax to load.",
	"Method": "void waitForPageStructureToLoad(){\r\n    super.waitForPageToLoad();\r\n}"
}, {
	"Path": "com.twelvemonkeys.contrib.tiff.TIFFUtilities.merge",
	"Comment": "merges all pages from the input tiff files into one tiff file at theoutput location.",
	"Method": "void merge(List<File> inputFiles,File outputFile){\r\n    ImageOutputStream output = null;\r\n    try {\r\n        output = ImageIO.createImageOutputStream(outputFile);\r\n        for (File file : inputFiles) {\r\n            ImageInputStream input = null;\r\n            try {\r\n                input = ImageIO.createImageInputStream(file);\r\n                List<TIFFPage> pages = getPages(input);\r\n                writePages(output, pages);\r\n            } finally {\r\n                if (input != null) {\r\n                    input.close();\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        if (output != null) {\r\n            output.flush();\r\n            output.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.liveness.LNDisj.equals",
	"Comment": "this method returns true or false for whether two liveexprnodes are\tsyntactically equal.",
	"Method": "boolean equals(LiveExprNode exp){\r\n    if (exp instanceof LNDisj) {\r\n        LNDisj exp2 = (LNDisj) exp;\r\n        if (getCount() != exp2.getCount()) {\r\n            return false;\r\n        }\r\n        for (int i = 0; i < getCount(); i++) {\r\n            if (!getBody(i).equals(exp2.getBody(i))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.facebook.swift.service.ThriftServerConfig.setMaxQueuedRequests",
	"Comment": "sets the maximum number of received requests that will wait in the queue to be executed.after this many requests are waiting, the worker queue will start rejecting requests, whichwill cause the server to fail those requests.",
	"Method": "ThriftServerConfig setMaxQueuedRequests(Integer maxQueuedRequests){\r\n    this.maxQueuedRequests = Optional.fromNullable(maxQueuedRequests);\r\n    return this;\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.utils.Device.reboot",
	"Comment": "reboots the device.\tthis method first tries using the reboot command from toolbox. \tbut since some toolbox versions does not have this, it further fallbacks on using a sysrq trigger.",
	"Method": "Boolean reboot(){\r\n    Result result = mShell.execute(\"toolbox reboot\");\r\n    if (result == null || !result.wasSuccessful()) {\r\n        result = mShell.execute(\"echo 1 > /proc/sys/kernel/sysrq && echo s > /proc/sysrq-trigger && echo b > /proc/sysrq-trigger\");\r\n    }\r\n    return result != null && result.wasSuccessful();\r\n}"
}, {
	"Path": "teammates.common.util.Templates.populateTemplate",
	"Comment": "populates the html templates by replacing variables in the template stringwith the given value strings.",
	"Method": "String populateTemplate(String template,String keyValuePairs){\r\n    Assumption.assertTrue(\"The number of elements in keyValuePairs passed in must be even\", keyValuePairs.length % 2 == 0);\r\n    String populatedTemplate = template;\r\n    for (int i = 0; i < keyValuePairs.length; i += 2) {\r\n        populatedTemplate = populatedTemplate.replace(keyValuePairs[i], keyValuePairs[i + 1]);\r\n    }\r\n    return populatedTemplate;\r\n}"
}, {
	"Path": "teammates.test.cases.browsertests.AdminEmailLogPageUiTest.isEmailLogDataDisplayCorrect",
	"Comment": "this method only checks if the email log data table are displayed correctlyi.e, table headers are correct.it does not test for the table content.",
	"Method": "boolean isEmailLogDataDisplayCorrect(){\r\n    return emailLogPage.isElementPresent(By.className(\"table\")) && isEmailLogTableHeaderCorrect();\r\n}"
}, {
	"Path": "teammates.logic.api.TaskQueuer.scheduleCourseRegistrationInviteToInstructor",
	"Comment": "schedules for course registration to be sent to the specified instructor.",
	"Method": "void scheduleCourseRegistrationInviteToInstructor(String inviterGoogleId,String instructorEmail,String courseId){\r\n    Map<String, String> paramMap = new HashMap();\r\n    paramMap.put(ParamsNames.INVITER_ID, inviterGoogleId);\r\n    paramMap.put(ParamsNames.INSTRUCTOR_EMAIL, instructorEmail);\r\n    paramMap.put(ParamsNames.COURSE_ID, courseId);\r\n    addTask(TaskQueue.INSTRUCTOR_COURSE_JOIN_EMAIL_QUEUE_NAME, TaskQueue.INSTRUCTOR_COURSE_JOIN_EMAIL_WORKER_URL, paramMap);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.util.EditorUtil.getRegionOf",
	"Comment": "this returns the region in document represented by thelocation.note that a location is a regionrepresented by thecoordinates of its first and last characters.",
	"Method": "IRegion getRegionOf(IDocument document,Location location){\r\n    int offset;\r\n    int length;\r\n    offset = document.getLineInformation(location.beginLine() - 1).getOffset() + location.beginColumn() - 1;\r\n    length = document.getLineInformation(location.endLine() - 1).getOffset() + location.endColumn() - offset;\r\n    return new Region(offset, length);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.proof.TLAProofFoldingStructureProvider.foldEverythingUnusable",
	"Comment": "folds all proofs not containing the cursor.note that this will fold every proof if the cursoris not in a proof.",
	"Method": "void foldEverythingUnusable(int cursorOffset){\r\n    Vector<Annotation> modifiedAnnotations = new Vector<Annotation>();\r\n    for (Iterator<TLAProofPosition> it = foldPositions.iterator(); it.hasNext(); ) {\r\n        TLAProofPosition proofPosition = it.next();\r\n        try {\r\n            if (proofPosition.containsInProofOrStatement(cursorOffset, document)) {\r\n                if (proofPosition.getAnnotation().isCollapsed()) {\r\n                    proofPosition.getAnnotation().markExpanded();\r\n                    modifiedAnnotations.add(proofPosition.getAnnotation());\r\n                }\r\n            } else if (!proofPosition.getAnnotation().isCollapsed()) {\r\n                proofPosition.getAnnotation().markCollapsed();\r\n                modifiedAnnotations.add(proofPosition.getAnnotation());\r\n            }\r\n        } catch (BadLocationException e) {\r\n            Activator.getDefault().logError(\"Error changing expansion state of proofs.\", e);\r\n        }\r\n    }\r\n    editor.modifyProjectionAnnotations((Annotation[]) modifiedAnnotations.toArray(new ProjectionAnnotation[modifiedAnnotations.size()]));\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResponseStatus.getStudentsWhoResponded",
	"Comment": "returns list of students who responded to the feedback session.",
	"Method": "List<String> getStudentsWhoResponded(){\r\n    return studentsWhoResponded;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ProverToolboxLifecycleParticipant.terminate",
	"Comment": "is called during termination of the toolbox. this implementation cancels all running prover jobs.",
	"Method": "void terminate(){\r\n    ProverHelper.cancelProverJobs(true);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.model.TypedSet.getValuesAsList",
	"Comment": "convenience interface for iteration over the valuesthis method disconnects the actual typed set from the collection of values",
	"Method": "List<String> getValuesAsList(){\r\n    if (!hasType()) {\r\n        return Arrays.asList(values);\r\n    } else {\r\n        List<String> typedList = new ArrayList<String>(values.length);\r\n        for (int i = 0; i < values.length; i++) {\r\n            String value = type + SEPARATOR + values[i];\r\n            typedList.add(value);\r\n        }\r\n        return typedList;\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.Tool.getNextStates",
	"Comment": "this method returns the set of next states when taking the actionin the given state.",
	"Method": "StateVec getNextStates(Action action,TLCState state,TLCState getNextStates,SemanticNode pred,ActionItemList acts,Context c,TLCState s0,TLCState s1,StateVec nss,TLCState getNextStates,ActionItemList acts,TLCState s0,TLCState s1,StateVec nss){\r\n    int kind = acts.carKind();\r\n    if (acts.isEmpty()) {\r\n        nss.addElement(s1);\r\n        return s1.copy();\r\n    } else if (s1.allAssigned()) {\r\n        SemanticNode pred = acts.carPred();\r\n        Context c = acts.carContext();\r\n        while (!acts.isEmpty()) {\r\n            if (kind > 0 || kind == -1) {\r\n                final Value bval = this.eval(pred, c, s0, s1, EvalControl.Clear);\r\n                if (!(bval instanceof BoolValue)) {\r\n                    Assert.fail(EC.TLC_EXPECTED_EXPRESSION_IN_COMPUTING, new String[] { \"next states\", \"boolean\", bval.toString(), acts.pred.toString() });\r\n                }\r\n                if (!((BoolValue) bval).val) {\r\n                    return s1;\r\n                }\r\n            } else if (kind == -2) {\r\n                return this.processUnchanged(pred, acts.cdr(), c, s0, s1, nss);\r\n            } else {\r\n                final Value v1 = this.eval(pred, c, s0);\r\n                final Value v2 = this.eval(pred, c, s1);\r\n                if (v1.equals(v2)) {\r\n                    return s1;\r\n                }\r\n            }\r\n            acts = acts.cdr();\r\n            pred = acts.carPred();\r\n            c = acts.carContext();\r\n            kind = acts.carKind();\r\n        }\r\n        nss.addElement(s1);\r\n        return s1.copy();\r\n    }\r\n    SemanticNode pred = acts.carPred();\r\n    Context c = acts.carContext();\r\n    ActionItemList acts1 = acts.cdr();\r\n    if (kind > 0) {\r\n        return this.getNextStates(pred, acts1, c, s0, s1, nss);\r\n    } else if (kind == -1) {\r\n        return this.getNextStates(pred, acts1, c, s0, s1, nss);\r\n    } else if (kind == -2) {\r\n        return this.processUnchanged(pred, acts1, c, s0, s1, nss);\r\n    } else {\r\n        Value v1 = this.eval(pred, c, s0);\r\n        Value v2 = this.eval(pred, c, s1);\r\n        if (!v1.equals(v2)) {\r\n            return this.getNextStates(acts1, s0, s1, nss);\r\n        }\r\n    }\r\n    return s1;\r\n}"
}, {
	"Path": "tlc2.tool.liveness.TableauNodePtrTableTest.testRedundantMethodYieldSameResult",
	"Comment": "test various methods which apparently all yield pretty much the same result",
	"Method": "void testRedundantMethodYieldSameResult(){\r\n    final TableauNodePtrTable tbl = new TableauNodePtrTable(0);\r\n    final long fingerprint = 1L;\r\n    assertEquals(-1, tbl.getNodesLoc(fingerprint));\r\n    final int loc = tbl.setDone(fingerprint);\r\n    assertTrue(tbl.isDone(fingerprint));\r\n    assertTrue(tbl.getNodesLoc(fingerprint) != -1);\r\n    assertEquals(tbl.getNodesLoc(fingerprint), loc);\r\n    assertTrue(Arrays.equals(tbl.getNodesByLoc(loc), tbl.getNodes(fingerprint)));\r\n    assertEquals(-1, tbl.getLoc(fingerprint, 1));\r\n    tbl.addElem(fingerprint, 1, 2342);\r\n    assertEquals(-1, tbl.getLoc(fingerprint, 1));\r\n    tbl.put(fingerprint, 1, 2342);\r\n    assertTrue(tbl.getLoc(fingerprint, 1) != -1);\r\n}"
}, {
	"Path": "teammates.ui.controller.InstructorCourseInstructorAbstractAction.updateInstructorWithSectionLevelPrivileges",
	"Comment": "updates section and session level privileges for the instructor.",
	"Method": "void updateInstructorWithSectionLevelPrivileges(String courseId,InstructorAttributes instructor){\r\n    List<String> sectionNames = null;\r\n    try {\r\n        sectionNames = logic.getSectionNamesForCourse(courseId);\r\n    } catch (EntityDoesNotExistException e) {\r\n        return;\r\n    }\r\n    HashMap<String, Boolean> isSectionSpecialMappings = new HashMap();\r\n    for (String sectionName : sectionNames) {\r\n        isSectionSpecialMappings.put(sectionName, false);\r\n    }\r\n    List<String> feedbackNames = new ArrayList();\r\n    List<FeedbackSessionAttributes> feedbacks = logic.getFeedbackSessionsForCourse(courseId);\r\n    for (FeedbackSessionAttributes feedback : feedbacks) {\r\n        feedbackNames.add(feedback.getFeedbackSessionName());\r\n    }\r\n    Map<String, List<String>> sectionNamesMap = getSectionsWithSpecialPrivilegesFromParameters(instructor, sectionNames, isSectionSpecialMappings);\r\n    sectionNamesMap.forEach((sectionGroupName, specialSectionsInSectionGroup) -> {\r\n        updateInstructorPrivilegesForSectionInSectionLevel(sectionGroupName, specialSectionsInSectionGroup, instructor);\r\n        String setSessionsStr = getRequestParamValue(\"is\" + sectionGroupName + \"sessionsset\");\r\n        boolean isSessionsForSectionGroupSpecial = Boolean.parseBoolean(setSessionsStr);\r\n        if (isSessionsForSectionGroupSpecial) {\r\n            updateInstructorPrivilegesForSectionInSessionLevel(sectionGroupName, specialSectionsInSectionGroup, feedbackNames, instructor);\r\n        } else {\r\n            removeSessionLevelPrivileges(instructor, specialSectionsInSectionGroup);\r\n        }\r\n    });\r\n    isSectionSpecialMappings.forEach((sectionNameToBeChecked, isSectionSpecial) -> {\r\n        if (!isSectionSpecial) {\r\n            instructor.privileges.removeSectionLevelPrivileges(sectionNameToBeChecked);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.plugins.iff.IFFUtil.bitRotateCW",
	"Comment": "rotate bits clockwise.the iffimagereader uses this to convert pixel bits from planar to chunky.bits from the source are rotated 90 degrees clockwise written to thedestination.",
	"Method": "void bitRotateCW(byte[] pSrc,int pSrcPos,int pSrcStep,byte[] pDst,int pDstPos,int pDstStep){\r\n    int idx = pSrcPos;\r\n    int lonyb;\r\n    int hinyb;\r\n    long lo = 0;\r\n    long hi = 0;\r\n    for (int i = 0; i < 8; i++) {\r\n        lonyb = pSrc[idx] & 0xF;\r\n        hinyb = (pSrc[idx] >> 4) & 0xF;\r\n        lo |= RTABLE[i][lonyb];\r\n        hi |= RTABLE[i][hinyb];\r\n        idx += pSrcStep;\r\n    }\r\n    idx = pDstPos;\r\n    pDst[idx] = (byte) ((hi >> 24) & 0xFF);\r\n    idx += pDstStep;\r\n    if (idx < pDst.length) {\r\n        pDst[idx] = (byte) ((hi >> 16) & 0xFF);\r\n        idx += pDstStep;\r\n        if (idx < pDst.length) {\r\n            pDst[idx] = (byte) ((hi >> 8) & 0xFF);\r\n            idx += pDstStep;\r\n            if (idx < pDst.length) {\r\n                pDst[idx] = (byte) (hi & 0xFF);\r\n                idx += pDstStep;\r\n            }\r\n        }\r\n    }\r\n    if (idx < pDst.length) {\r\n        pDst[idx] = (byte) ((lo >> 24) & 0xFF);\r\n        idx += pDstStep;\r\n        if (idx < pDst.length) {\r\n            pDst[idx] = (byte) ((lo >> 16) & 0xFF);\r\n            idx += pDstStep;\r\n            if (idx < pDst.length) {\r\n                pDst[idx] = (byte) ((lo >> 8) & 0xFF);\r\n                idx += pDstStep;\r\n                if (idx < pDst.length) {\r\n                    pDst[idx] = (byte) (lo & 0xFF);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.spec.manager.WorkspaceSpecManager.specParsed",
	"Comment": "is triggered when a spec has been parsednot intended to be called by clients",
	"Method": "void specParsed(Spec spec){\r\n    this.lifecycleManager.sendEvent(new SpecEvent(spec, SpecEvent.TYPE_PARSE));\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.preference.ProverPreferencePage.propertyChange",
	"Comment": "this method makes sure pairs of annotation types correspondingto a given logical color are always bound to the same physical color.when the color preference is changed for the key which is bound to the colorfield editors for this page, this method sets the value for the partner keyto be the same.see the documentation for this class to read more about this.",
	"Method": "void propertyChange(PropertyChangeEvent event){\r\n    if (event.getProperty().contains(COLOR_PREF_KEY_PREFIX) && event.getProperty().endsWith(\"A\")) {\r\n        int colorNum = getNumFromMainColorPref(event.getProperty());\r\n        IPreferenceStore store = getPreferenceStore();\r\n        String partnerPrefName = getPartnerColorPrefName(colorNum);\r\n        String newValue = getPreferenceStore().getString(event.getProperty());\r\n        if (store.getDefaultString(partnerPrefName).equals(newValue)) {\r\n            store.setToDefault(partnerPrefName);\r\n        } else {\r\n            getPreferenceStore().setValue(partnerPrefName, newValue);\r\n        }\r\n    }\r\n    super.propertyChange(event);\r\n}"
}, {
	"Path": "tlc2.util.Context.lookup",
	"Comment": "this method returns the value for the name var. it returns null if this\tcontext does not contain var.",
	"Method": "Object lookup(SymbolNode var,Object lookup,SymbolNode var,boolean cutoff){\r\n    Context cur = this;\r\n    while (cur != Empty) {\r\n        if (cur.name != null) {\r\n            if (var == cur.name) {\r\n                return cur.value;\r\n            }\r\n        } else if (cutoff == true) {\r\n            assert cur.value == null;\r\n            return null;\r\n        }\r\n        cur = cur.next;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "tla2sany.semantic.OpDefNode.walkGraph",
	"Comment": "walkgraph finds all reachable nodes in the semantic graphand inserts them in the hashtable semnodestable for use bythe explorer tool.",
	"Method": "void walkGraph(Hashtable<Integer, ExploreNode> semNodesTable,ExplorerVisitor visitor){\r\n    Integer uid = Integer.valueOf(myUID);\r\n    if (semNodesTable.get(uid) != null)\r\n        return;\r\n    semNodesTable.put(uid, this);\r\n    visitor.preVisit(this);\r\n    if (params != null && params.length > 0) {\r\n        for (int i = 0; i < params.length; i++) {\r\n            if (params[i] != null)\r\n                params[i].walkGraph(semNodesTable, visitor);\r\n        }\r\n    }\r\n    if (body != null)\r\n        body.walkGraph(semNodesTable, visitor);\r\n    if (stepNode != null)\r\n        stepNode.walkGraph(semNodesTable, visitor);\r\n    visitor.postVisit(this);\r\n}"
}, {
	"Path": "teammates.ui.controller.ImageUploadAction.extractImageKey",
	"Comment": "extracts the image metadata by the passed image key parameter.",
	"Method": "BlobInfo extractImageKey(String param){\r\n    try {\r\n        Map<String, List<BlobInfo>> blobsMap = BlobstoreServiceFactory.getBlobstoreService().getBlobInfos(request);\r\n        List<BlobInfo> blobs = blobsMap.get(param);\r\n        if (blobs == null || blobs.isEmpty()) {\r\n            data.ajaxStatus = Const.StatusMessages.NO_IMAGE_GIVEN;\r\n            isError = true;\r\n            return null;\r\n        }\r\n        BlobInfo image = blobs.get(0);\r\n        return validateImage(image);\r\n    } catch (IllegalStateException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.setDistanceFromLeft",
	"Comment": "sets how far away from the left side of the screen the button should be displayed.distance should be the value in px",
	"Method": "void setDistanceFromLeft(int distance){\r\n    this.distanceFromLeft = distance;\r\n}"
}, {
	"Path": "com.facebook.swift.codec.metadata.AbstractThriftMetadataBuilder.verifyFieldType",
	"Comment": "verifies that the the fields all have a supported java type and that all fields map to theexact same thrifttype.",
	"Method": "void verifyFieldType(short id,String name,Collection<FieldMetadata> fields,ThriftCatalog catalog){\r\n    boolean isSupportedType = true;\r\n    for (FieldMetadata field : fields) {\r\n        if (!catalog.isSupportedStructFieldType(field.getJavaType())) {\r\n            metadataErrors.addError(\"Thrift class '%s' field '%s(%s)' type '%s' is not a supported Java type\", structName, name, id, TypeToken.of(field.getJavaType()));\r\n            isSupportedType = false;\r\n            break;\r\n        }\r\n    }\r\n    if (isSupportedType) {\r\n        Set<ThriftTypeReference> types = new HashSet();\r\n        for (FieldMetadata field : fields) {\r\n            types.add(catalog.getFieldThriftTypeReference(field));\r\n        }\r\n        if (types.size() > 1) {\r\n            metadataErrors.addError(\"Thrift class '%s' field '%s(%s)' has multiple types: %s\", structName, name, id, types);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.spec.SpecTest.testCreateDeleteSpec",
	"Comment": "verify that specs and the their corresponding project are deleted correctly.",
	"Method": "void testCreateDeleteSpec(){\r\n    createDelete(\"TestCreateDeleteSpec\", true);\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackResponseCommentsDb.getFeedbackResponseCommentEntitiesForLastEditorInCourse",
	"Comment": "gets a list of feedbackresponsecomments which have a last editor associated with the given email",
	"Method": "List<FeedbackResponseComment> getFeedbackResponseCommentEntitiesForLastEditorInCourse(String courseId,String lastEditorEmail){\r\n    return load().filter(\"courseId =\", courseId).filter(\"lastEditorEmail =\", lastEditorEmail).list();\r\n}"
}, {
	"Path": "teammates.ui.controller.AdminActivityLogPageAction.searchLogsWithExactTimePeriod",
	"Comment": "retrieves all logs in the time period specified in the query.",
	"Method": "List<ActivityLogEntry> searchLogsWithExactTimePeriod(AdminLogQuery query,AdminActivityLogPageData data){\r\n    GaeLogApi logApi = new GaeLogApi();\r\n    List<AppLogLine> searchResult = logApi.fetchLogs(query);\r\n    nextEndTimeToSearch = data.getFromDate() - 1;\r\n    totalLogsSearched = searchResult.size();\r\n    return filterLogsForActivityLogPage(searchResult, data);\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.service.ServiceRegistry.register",
	"Comment": "registers the given provider for all categories it matches.",
	"Method": "boolean register(Object pProvider,boolean register,T pProvider,Class<? super T> pCategory,boolean register,T pProvider){\r\n    return registerImpl(pProvider, pCategory);\r\n}"
}, {
	"Path": "teammates.test.driver.BackDoor.getFeedbackResponsesFromGiverForCourse",
	"Comment": "gets a list of feedback response data for particular giver from the datastore.",
	"Method": "List<FeedbackResponseAttributes> getFeedbackResponsesFromGiverForCourse(String courseId,String giverEmail){\r\n    Map<String, String> params = createParamMap(BackDoorOperation.OPERATION_GET_FEEDBACK_RESPONSES_FOR_GIVER_AS_JSON);\r\n    params.put(BackDoorOperation.PARAMETER_COURSE_ID, courseId);\r\n    params.put(BackDoorOperation.PARAMETER_GIVER_EMAIL, giverEmail);\r\n    String feedbackResponsesJson = makePostRequest(params);\r\n    return JsonUtils.fromJson(feedbackResponsesJson, new TypeToken<List<FeedbackResponseAttributes>>() {\r\n    }.getType());\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackSessionsDb.deleteInstructorRespondent",
	"Comment": "the objectify library does not support throwing checked exceptions inside transactions",
	"Method": "void deleteInstructorRespondent(String email,FeedbackSessionAttributes feedbackSession){\r\n    Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, email);\r\n    Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSession);\r\n    feedbackSession.sanitizeForSaving();\r\n    if (!feedbackSession.isValid()) {\r\n        throw new InvalidParametersException(feedbackSession.getInvalidityInfo());\r\n    }\r\n    try {\r\n        ofy().transact(new VoidWork() {\r\n            @Override\r\n            public void vrun() {\r\n                FeedbackSession fs = getEntity(feedbackSession);\r\n                if (fs == null) {\r\n                    throw new RuntimeException(new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString()));\r\n                }\r\n                fs.getRespondingInstructorList().remove(email);\r\n                saveEntity(fs, feedbackSession);\r\n            }\r\n        });\r\n    } catch (RuntimeException e) {\r\n        if (e.getCause() instanceof EntityDoesNotExistException) {\r\n            throw (EntityDoesNotExistException) e.getCause();\r\n        }\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackSessionsDb.deleteInstructorRespondent",
	"Comment": "the objectify library does not support throwing checked exceptions inside transactions",
	"Method": "void deleteInstructorRespondent(String email,FeedbackSessionAttributes feedbackSession){\r\n    FeedbackSession fs = getEntity(feedbackSession);\r\n    if (fs == null) {\r\n        throw new RuntimeException(new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString()));\r\n    }\r\n    fs.getRespondingInstructorList().remove(email);\r\n    saveEntity(fs, feedbackSession);\r\n}"
}, {
	"Path": "toothpick.ScopeImpl.installInternalProvider",
	"Comment": "installs a provider either in the scope or the pool of unbound providers.",
	"Method": "InternalProviderImpl installInternalProvider(Class<T> clazz,String bindingName,InternalProviderImpl<? extends T> internalProvider,boolean isBound,boolean isTestProvider){\r\n    if (bindingName == null) {\r\n        if (isBound) {\r\n            return installUnNamedProvider(mapClassesToUnNamedBoundProviders, clazz, internalProvider, isTestProvider);\r\n        } else {\r\n            return installUnNamedProvider(mapClassesToUnNamedUnBoundProviders, clazz, internalProvider, isTestProvider);\r\n        }\r\n    } else {\r\n        return installNamedProvider(mapClassesToNamedBoundProviders, clazz, bindingName, internalProvider, isTestProvider);\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.util.ChangedSpecModulesGatheringDeltaVisitor.getCheckpointChanged",
	"Comment": "returns true if the visitor has found a change to the directorycontaining the checkpoints, so a checkpoint might have changed.",
	"Method": "boolean getCheckpointChanged(){\r\n    return checkpointsChanged;\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackQuestionsLogic.getFeedbackSessionTemplateQuestions",
	"Comment": "gets the list of questions for the specified feedback session template.",
	"Method": "List<FeedbackQuestionAttributes> getFeedbackSessionTemplateQuestions(String templateType,String courseId,String feedbackSessionName,String creatorEmail){\r\n    if (\"TEAMEVALUATION\".equals(templateType)) {\r\n        String jsonString = Templates.populateTemplate(Templates.FeedbackSessionTemplates.TEAM_EVALUATION, \"${courseId}\", courseId, \"${feedbackSessionName}\", feedbackSessionName, \"${creatorEmail}\", creatorEmail);\r\n        Type listType = new TypeToken<ArrayList<FeedbackQuestionAttributes>>() {\r\n        }.getType();\r\n        return JsonUtils.fromJson(jsonString, listType);\r\n    }\r\n    return new ArrayList();\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.containers.Data.replace",
	"Comment": "this can be used to replace whole lines based on a contained pattern.",
	"Method": "String replace(String input,DATATYPE replace,DataReplace dataReplace,DATATYPE replace,String contains,String newLine){\r\n    return (DATATYPE) replace(new DataReplace() {\r\n        @Override\r\n        public String replace(String input) {\r\n            return input != null && input.contains(contains) ? newLine : input;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.containers.Data.replace",
	"Comment": "this can be used to replace whole lines based on a contained pattern.",
	"Method": "String replace(String input,DATATYPE replace,DataReplace dataReplace,DATATYPE replace,String contains,String newLine){\r\n    return input != null && input.contains(contains) ? newLine : input;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.spec.Spec.createNewSpec",
	"Comment": "factory method creates a new specification, the underlying iproject linkthe root file",
	"Method": "Spec createNewSpec(String name,String rootFilename,boolean importExisting,IProgressMonitor monitor){\r\n    IProject project = ResourceHelper.getProject(name, rootFilename, true, importExisting, monitor);\r\n    PreferenceStoreHelper.storeRootFilename(project, rootFilename);\r\n    Spec spec = new Spec(project);\r\n    spec.setLastModified();\r\n    return spec;\r\n}"
}, {
	"Path": "teammates.test.cases.browsertests.AdminEmailPageUiTest.isEmailDraftDataDisplayCorrect",
	"Comment": "this method only checks if the email draft data table is displayed correctlyi.e, table headers are correct.it does not test for the table content.",
	"Method": "boolean isEmailDraftDataDisplayCorrect(){\r\n    return emailPage.isElementPresent(By.className(\"table\")) && isEmailTableHeaderCorrect();\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.WsCommands.areWsCommandsAvailable",
	"Comment": "this method is an availability indicator of the web service commands. it indicatesif the command is available or not.delegates in wsoperations to know if the command is available or not.",
	"Method": "boolean areWsCommandsAvailable(){\r\n    return getWsOperations().areWsCommandsAvailable();\r\n}"
}, {
	"Path": "tlc2.tool.liveness.LNBool.pushNeg",
	"Comment": "this method pushes a negation all the way down to the atoms. it is\tcurrently not used.",
	"Method": "LiveExprNode pushNeg(LiveExprNode pushNeg,boolean hasNeg){\r\n    if (hasNeg) {\r\n        return new LNBool(!b);\r\n    }\r\n    return super.pushNeg(hasNeg);\r\n}"
}, {
	"Path": "org.springframework.roo.project.MavenOperationsImpl.createFolder",
	"Comment": "creates toplevelpackage folder structure inside the focused module. iffolder is not null, adds this new folder inside toplevelpackage folders",
	"Method": "void createFolder(JavaPackage topLevelPackage,String folder){\r\n    Validate.notNull(topLevelPackage, \"Cannot create topLevelPackage folders\");\r\n    String filename = topLevelPackage.getFullyQualifiedPackageName().replace('.', File.separatorChar);\r\n    if (StringUtils.isNotBlank(folder)) {\r\n        filename += File.separatorChar + folder;\r\n    }\r\n    final String physicalPath = getPathResolver().getFocusedIdentifier(Path.SRC_MAIN_JAVA, filename);\r\n    getFileManager().createDirectory(physicalPath);\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.ImageReaderBase.checkBounds",
	"Comment": "convenience method to make sure image index is within bounds.",
	"Method": "void checkBounds(int index){\r\n    assertInput();\r\n    if (index < getMinIndex()) {\r\n        throw new IndexOutOfBoundsException(\"index < minIndex\");\r\n    }\r\n    int numImages = getNumImages(false);\r\n    if (numImages != -1 && index >= numImages) {\r\n        throw new IndexOutOfBoundsException(\"index >= numImages (\" + index + \" >= \" + numImages + \")\");\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.Tool.isGoodState",
	"Comment": "this method determines if the argument is a valid state.a stateis good iff it assigns legal explicit values to all the globalstate variables.",
	"Method": "boolean isGoodState(TLCState state){\r\n    return state.allAssigned();\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.StudentAttributes.isEmailChanged",
	"Comment": "returns true if email value has changed from its original value.",
	"Method": "boolean isEmailChanged(StudentAttributes originalStudentAttribute){\r\n    return this.email != null && !this.email.equals(originalStudentAttribute.email);\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.StringUtil.capitalize",
	"Comment": "makes the nth letter of a string uppercase. if the index is outside thethe length of the argument string, the argument is simply returned.",
	"Method": "String capitalize(String pString,int pIndex,String capitalize,String pString){\r\n    return capitalize(pString, 0);\r\n}"
}, {
	"Path": "tlc2.tool.CheckImpl.checkState",
	"Comment": "returns true iff the state satisfies all the invariant properties.it also records the state if it is not seen before.",
	"Method": "boolean checkState(TLCState state){\r\n    long fp = state.fingerPrint();\r\n    boolean seen = this.coverSet.put(fp);\r\n    if (!seen) {\r\n        if (!this.theFPSet.contains(fp)) {\r\n            state.uid = this.trace.writeState(this.curState, fp);\r\n            int cnt = this.invariants.length;\r\n            for (int j = 0; j < cnt; j++) {\r\n                if (!this.tool.isValid(this.invariants[j], state)) {\r\n                    ToolIO.out.println(\"Error: Invariant \" + this.tool.getInvNames()[j] + \" is violated. The behavior up to this point is:\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.getCsvDetailedInstructorFeedbackResponseComments",
	"Comment": "returns string of all instructor comments on a response appended to their names for csv.",
	"Method": "String getCsvDetailedInstructorFeedbackResponseComments(FeedbackResponseAttributes response){\r\n    if (!this.responseComments.containsKey(response.getId())) {\r\n        return \"\";\r\n    }\r\n    StringBuilder commentRow = new StringBuilder(200);\r\n    List<FeedbackResponseCommentAttributes> frcList = this.responseComments.get(response.getId());\r\n    for (FeedbackResponseCommentAttributes frc : frcList) {\r\n        if (!frc.isCommentFromFeedbackParticipant) {\r\n            commentRow.append(\",\" + commentGiverEmailToNameTable.get(frc.commentGiver) + \",\" + frc.getCommentAsCsvString());\r\n        }\r\n    }\r\n    return commentRow.toString();\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.BeanInfoUtils.getAccessorMethodName",
	"Comment": "returns the accessor name for the given field name and field type.",
	"Method": "JavaSymbolName getAccessorMethodName(FieldMetadata field,JavaSymbolName getAccessorMethodName,JavaSymbolName fieldName,JavaType fieldType){\r\n    Validate.notNull(fieldName, \"Field name required\");\r\n    Validate.notNull(fieldType, \"Field type required\");\r\n    final String capitalizedFieldName = StringUtils.capitalize(fieldName.getSymbolName());\r\n    return fieldType.equals(JavaType.BOOLEAN_PRIMITIVE) ? new JavaSymbolName(\"is\" + capitalizedFieldName) : new JavaSymbolName(\"get\" + capitalizedFieldName);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.actions.ToggleCommentAction.getFirstCompleteLineOfRegion",
	"Comment": "returns the index of the first line whose start offset is in the given text range.",
	"Method": "int getFirstCompleteLineOfRegion(IRegion region,IDocument document){\r\n    try {\r\n        int startLine = document.getLineOfOffset(region.getOffset());\r\n        int offset = document.getLineOffset(startLine);\r\n        if (offset >= region.getOffset())\r\n            return startLine;\r\n        offset = document.getLineOffset(startLine + 1);\r\n        return (offset > region.getOffset() + region.getLength() ? -1 : startLine + 1);\r\n    } catch (BadLocationException x) {\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.ShowAllProofsHandler.setEnabled",
	"Comment": "this method is used to update the enablement state. this has theeffect of graying out any menu items for thecommand if the handler is disabled. through experimentation, this method seems to becalled just before such menu items are rendered in the ui andjust before the handler is executed.",
	"Method": "void setEnabled(Object context){\r\n    TLAEditor editor = EditorUtil.getTLAEditorWithFocus();\r\n    if (editor != null) {\r\n        if (editor.getProofStructureProvider() != null) {\r\n            setBaseEnabled(editor.getProofStructureProvider().canRunFoldOperation(IProofFoldCommandIds.EXPAND_ALL_PROOFS, (ITextSelection) editor.getSelectionProvider().getSelection()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackRankOptionsQuestionDetails.generateOptionRanksMapping",
	"Comment": "from the feedback responses, generate a mapping of the option to a list ofranks received for that option.the key of the map returned is the option name.the values of the map are list of ranks received by the key.",
	"Method": "Map<String, List<Integer>> generateOptionRanksMapping(List<FeedbackResponseAttributes> responses){\r\n    Map<String, List<Integer>> optionRanks = new HashMap();\r\n    for (FeedbackResponseAttributes response : responses) {\r\n        FeedbackRankOptionsResponseDetails frd = (FeedbackRankOptionsResponseDetails) response.getResponseDetails();\r\n        List<Integer> answers = frd.getAnswerList();\r\n        Map<String, Integer> mapOfOptionToRank = new HashMap();\r\n        Assumption.assertEquals(answers.size(), options.size());\r\n        for (int i = 0; i < options.size(); i++) {\r\n            int rankReceived = answers.get(i);\r\n            mapOfOptionToRank.put(options.get(i), rankReceived);\r\n        }\r\n        Map<String, Integer> normalisedRankForOption = obtainMappingToNormalisedRanksForRanking(mapOfOptionToRank, options);\r\n        for (String optionReceivingRanks : options) {\r\n            int rankReceived = normalisedRankForOption.get(optionReceivingRanks);\r\n            if (rankReceived != Const.POINTS_NOT_SUBMITTED) {\r\n                updateOptionRanksMapping(optionRanks, optionReceivingRanks, rankReceived);\r\n            }\r\n        }\r\n    }\r\n    return optionRanks;\r\n}"
}, {
	"Path": "teammates.common.util.StringHelper.removeExtraSpace",
	"Comment": "trims all strings in the set and reduces consecutive white spaces to only one space.",
	"Method": "String removeExtraSpace(String str,Set<String> removeExtraSpace,Set<String> strSet){\r\n    if (strSet == null) {\r\n        return null;\r\n    }\r\n    Set<String> result = new TreeSet();\r\n    for (String s : strSet) {\r\n        result.add(removeExtraSpace(s));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.MemberFindingUtils.getAnnotationOfType",
	"Comment": "returns the metadata for the annotation of the given type from within thegiven metadata",
	"Method": "AnnotationMetadata getAnnotationOfType(List<? extends AnnotationMetadata> annotations,JavaType annotationType,AnnotationMetadata getAnnotationOfType,MemberHoldingTypeDetailsMetadataItem<?> metadata,JavaType annotationType){\r\n    if (metadata == null || metadata.getMemberHoldingTypeDetails() == null) {\r\n        return null;\r\n    }\r\n    return getAnnotationOfType(metadata.getMemberHoldingTypeDetails().getAnnotations(), annotationType);\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.comments.JavadocComment.checkJavadocSyntax",
	"Comment": "checks if the provided string has the proper javadoc syntax and adds itif its not present.",
	"Method": "String checkJavadocSyntax(String comment){\r\n    if (comment.contains(\"/**\")) {\r\n        return comment;\r\n    }\r\n    if (this.commentBuilder == null) {\r\n        this.commentBuilder = new StringBuilder();\r\n    }\r\n    String[] lines = comment.split(IOUtils.LINE_SEPARATOR);\r\n    this.commentBuilder.append(\"/**\").append(IOUtils.LINE_SEPARATOR);\r\n    this.beginDescriptionIndex = this.commentBuilder.length();\r\n    for (String line : lines) {\r\n        this.commentBuilder.append(\" * \").append(line).append(IOUtils.LINE_SEPARATOR);\r\n    }\r\n    this.commentBuilder.append(\" * \").append(IOUtils.LINE_SEPARATOR);\r\n    this.commentBuilder.append(\" */\").append(IOUtils.LINE_SEPARATOR);\r\n    return this.commentBuilder.toString();\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.video.OutputSurface.eglSetup",
	"Comment": "prepares egl. we want a gles 2.0 context and a surface that supports pbuffer.",
	"Method": "void eglSetup(int width,int height){\r\n    mEGL = (EGL10) EGLContext.getEGL();\r\n    mEGLDisplay = mEGL.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);\r\n    if (!mEGL.eglInitialize(mEGLDisplay, null)) {\r\n        throw new RuntimeException(\"unable to initialize EGL10\");\r\n    }\r\n    int[] attribList = { EGL10.EGL_RED_SIZE, 8, EGL10.EGL_GREEN_SIZE, 8, EGL10.EGL_BLUE_SIZE, 8, EGL10.EGL_SURFACE_TYPE, EGL10.EGL_PBUFFER_BIT, EGL10.EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT, EGL10.EGL_NONE };\r\n    EGLConfig[] configs = new EGLConfig[1];\r\n    int[] numConfigs = new int[1];\r\n    if (!mEGL.eglChooseConfig(mEGLDisplay, attribList, configs, 1, numConfigs)) {\r\n        throw new RuntimeException(\"unable to find RGB888+pbuffer EGL config\");\r\n    }\r\n    int[] attrib_list = { EGL14.EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE };\r\n    mEGLContext = mEGL.eglCreateContext(mEGLDisplay, configs[0], EGL10.EGL_NO_CONTEXT, attrib_list);\r\n    checkEglError(\"eglCreateContext\");\r\n    if (mEGLContext == null) {\r\n        throw new RuntimeException(\"null context\");\r\n    }\r\n    int[] surfaceAttribs = { EGL10.EGL_WIDTH, width, EGL10.EGL_HEIGHT, height, EGL10.EGL_NONE };\r\n    mEGLSurface = mEGL.eglCreatePbufferSurface(mEGLDisplay, configs[0], surfaceAttribs);\r\n    checkEglError(\"eglCreatePbufferSurface\");\r\n    if (mEGLSurface == null) {\r\n        throw new RuntimeException(\"surface was null\");\r\n    }\r\n}"
}, {
	"Path": "tla2sany.semantic.ExternalModuleTable.levelDataToString",
	"Comment": "walkgraph, leveldatatostring, and tostring methods to implement explorenode interface",
	"Method": "String levelDataToString(String levelDataToString){\r\n    return \"Dummy level string\";\r\n}"
}, {
	"Path": "com.twelvemonkeys.io.LittleEndianRandomAccessFile.writeDouble",
	"Comment": "writes an 8 byte java double to the underlying output stream inlittle endian order.",
	"Method": "void writeDouble(double d){\r\n    writeLong(Double.doubleToLongBits(d));\r\n}"
}, {
	"Path": "teammates.logic.backdoor.BackDoorLogic.putDocuments",
	"Comment": "creates document for entities that have document, i.e. searchable.",
	"Method": "String putDocuments(DataBundle dataBundle){\r\n    Map<String, StudentAttributes> students = dataBundle.students;\r\n    for (StudentAttributes student : students.values()) {\r\n        StudentAttributes studentInDb = studentsDb.getStudentForEmail(student.course, student.email);\r\n        studentsDb.putDocument(studentInDb);\r\n    }\r\n    Map<String, InstructorAttributes> instructors = dataBundle.instructors;\r\n    for (InstructorAttributes instructor : instructors.values()) {\r\n        InstructorAttributes instructorInDb = instructorsDb.getInstructorForEmail(instructor.courseId, instructor.email);\r\n        instructorsDb.putDocument(instructorInDb);\r\n    }\r\n    Map<String, FeedbackResponseCommentAttributes> responseComments = dataBundle.feedbackResponseComments;\r\n    for (FeedbackResponseCommentAttributes responseComment : responseComments.values()) {\r\n        FeedbackResponseCommentAttributes fcInDb = fcDb.getFeedbackResponseComment(responseComment.courseId, responseComment.createdAt, responseComment.commentGiver);\r\n        fcDb.putDocument(fcInDb);\r\n    }\r\n    return Const.StatusCodes.BACKDOOR_STATUS_SUCCESS;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.util.EditorUtil.lineLocationContainment",
	"Comment": "true iff the range of lines specified by loc1 is a subset of the range of linesspecified by loc2.",
	"Method": "boolean lineLocationContainment(Location loc1,Location loc2){\r\n    return (loc1.beginLine() >= loc2.beginLine()) && (loc2.endLine() >= loc1.endLine());\r\n}"
}, {
	"Path": "tlc2.value.Value.toRcd",
	"Comment": "this method converts a value to a function value. it returnsnull if the conversion fails.",
	"Method": "RecordValue toRcd(){\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.roo.metadata.MetadataIdentificationUtils.isIdentifyingInstance",
	"Comment": "indicates whether the argument appears to represent a specific metadatainstance.",
	"Method": "boolean isIdentifyingInstance(String metadataIdentificationString){\r\n    return isValid(metadataIdentificationString) && metadataIdentificationString.contains(INSTANCE_DELIMITER) && !metadataIdentificationString.endsWith(INSTANCE_DELIMITER);\r\n}"
}, {
	"Path": "tla2sany.semantic.FrontEnd.semanticAnalysis",
	"Comment": "this method returns a semanticnode.the semanticnode is the meaning of the treenode cst, interpreted in the context ctxt, toproduce a node whose kind field is nkind.the context ctxt isupdated to include the context information from analyzing cst.the precise meaning of this new context is not yet specified ingeneral.however, when nkind specifies a module node, and ctxt isthe context obtained by a series of calls of semanticanalysis formodule nodes, then the returned context is ctxt augmented by the assignment of the name of the module cst to the returned semnode.",
	"Method": "SemanticNode semanticAnalysis(TreeNode cst,int nkind,Context ctxt){\r\n    return null;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.getPossibleGivers",
	"Comment": "get the possible givers for a student recipient for the question specified.",
	"Method": "List<String> getPossibleGivers(FeedbackQuestionAttributes fqa,String recipientParticipantIdentifier,List<String> getPossibleGivers,FeedbackQuestionAttributes fqa,StudentAttributes studentRecipient,List<String> getPossibleGivers,FeedbackQuestionAttributes fqa){\r\n    FeedbackParticipantType giverType = fqa.giverType;\r\n    List<String> possibleGivers = new ArrayList();\r\n    switch(giverType) {\r\n        case STUDENTS:\r\n            possibleGivers = getSortedListOfStudentEmails();\r\n            break;\r\n        case INSTRUCTORS:\r\n            possibleGivers = getSortedListOfInstructorEmails();\r\n            break;\r\n        case TEAMS:\r\n            possibleGivers = getSortedListOfTeams();\r\n            break;\r\n        case SELF:\r\n            possibleGivers = new ArrayList();\r\n            possibleGivers.add(fqa.creatorEmail);\r\n            break;\r\n        default:\r\n            log.severe(\"Invalid giver type specified\");\r\n            break;\r\n    }\r\n    return possibleGivers;\r\n}"
}, {
	"Path": "tlc2.value.Value.toFcnRcd",
	"Comment": "this method converts a value to a function value. it returnsnull if the conversion fails.",
	"Method": "FcnRcdValue toFcnRcd(){\r\n    return null;\r\n}"
}, {
	"Path": "teammates.test.cases.action.StudentProfilePictureActionTest.testActionWithBlobKey",
	"Comment": "tests the branch of the action handling a request from the studentdirectly, where the parameters are simply the blobkey of the pictureitself.",
	"Method": "void testActionWithBlobKey(){\r\n    testActionWithBlobKeySuccess();\r\n    testActionWithBlobKeySuccessMasquerade();\r\n}"
}, {
	"Path": "tlc2.tool.liveness.LNNeg.equals",
	"Comment": "this method returns true or false for whether two liveexprnodes are\tsyntactically equal.",
	"Method": "boolean equals(LiveExprNode exp){\r\n    if (exp instanceof LNNeg) {\r\n        return getBody().equals(((LNNeg) exp).getBody());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.MapAbstractTest.makeConfirmedMap",
	"Comment": "override to return a map other than hashmap as the confirmed map.",
	"Method": "Map makeConfirmedMap(){\r\n    return new HashMap();\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.LRUMap.setMaxSize",
	"Comment": "sets the maximum number of elements in this map.if the current size is greater than the new max size, the map will betrimmed to fit the new max size constraint.",
	"Method": "void setMaxSize(int pMaxSize){\r\n    if (pMaxSize < 0) {\r\n        throw new IllegalArgumentException(\"max size must be positive\");\r\n    }\r\n    maxSize = pMaxSize;\r\n    while (size() > maxSize) {\r\n        removeLRU();\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.proof.TLAProofFoldingStructureProvider.showImmediateDescendants",
	"Comment": "shows the immediate descendants in the proof of astatement and hides the proofs of the immediate descendants.assumes all tlaproofposition in foldpositions are sorted by ascending offset.",
	"Method": "void showImmediateDescendants(int offset){\r\n    List<Annotation> modifiedAnnotations = new ArrayList<Annotation>();\r\n    TLAProofPosition found = null;\r\n    for (Iterator<TLAProofPosition> it = foldPositions.iterator(); it.hasNext(); ) {\r\n        TLAProofPosition proofPosition = it.next();\r\n        try {\r\n            if (found == null && proofPosition.containsBeforeProof(offset, document)) {\r\n                found = proofPosition;\r\n                if (found.getAnnotation().isCollapsed()) {\r\n                    found.getAnnotation().markExpanded();\r\n                    modifiedAnnotations.add(found.getAnnotation());\r\n                }\r\n                continue;\r\n            }\r\n            if (found != null && found.contains(proofPosition)) {\r\n                if (!proofPosition.getAnnotation().isCollapsed()) {\r\n                    proofPosition.getAnnotation().markCollapsed();\r\n                    modifiedAnnotations.add(proofPosition.getAnnotation());\r\n                }\r\n            }\r\n        } catch (BadLocationException e) {\r\n            Activator.getDefault().logError(\"Error changing expansion state of proofs.\", e);\r\n        }\r\n    }\r\n    editor.modifyProjectionAnnotations((Annotation[]) modifiedAnnotations.toArray(new ProjectionAnnotation[modifiedAnnotations.size()]));\r\n}"
}, {
	"Path": "pcal.ParseAlgorithm.GetLastLocationStart",
	"Comment": "returns the pcallocation object corresponding to the beginning of the last token returned by getalgtoken or gobbled by a gobble... method.",
	"Method": "PCalLocation GetLastLocationStart(){\r\n    return new PCalLocation(lastTokLine - 1, lastTokCol - 1);\r\n}"
}, {
	"Path": "tla2sany.semantic.AssumeNode.walkGraph",
	"Comment": "walkgraph finds all reachable nodes in the semantic graph andinserts them in the hashtable semnodestable for use by theexplorer tool.",
	"Method": "void walkGraph(Hashtable<Integer, ExploreNode> semNodesTable,ExplorerVisitor visitor){\r\n    Integer uid = Integer.valueOf(myUID);\r\n    if (semNodesTable.get(uid) != null)\r\n        return;\r\n    semNodesTable.put(uid, this);\r\n    visitor.preVisit(this);\r\n    if (assumeExpr != null) {\r\n        assumeExpr.walkGraph(semNodesTable, visitor);\r\n    }\r\n    ;\r\n    visitor.postVisit(this);\r\n}"
}, {
	"Path": "org.springframework.roo.project.XmlTestCase.assertXmlEquals",
	"Comment": "asserts that the given xml node contains the expected content",
	"Method": "void assertXmlEquals(String expectedXml,Node actualNode){\r\n    final String normalisedXml = expectedXml.replace(\"\\n\", IOUtils.LINE_SEPARATOR);\r\n    final String actualXml = StringUtils.stripEnd(XmlUtils.nodeToString(actualNode), null);\r\n    assertEquals(StringUtils.replace(normalisedXml, IOUtils.LINE_SEPARATOR, \"\"), StringUtils.replace(actualXml, IOUtils.LINE_SEPARATOR, \"\"));\r\n}"
}, {
	"Path": "tlc2.tool.liveness.TBPar.contains",
	"Comment": "this method tests whether a particle par is a subset of this particle.",
	"Method": "boolean contains(TBPar par){\r\n    for (int i = 0; i < par.size(); i++) {\r\n        if (!this.member(par.exprAt(i))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "util.BufferedDataInputStream.skip",
	"Comment": "skips over the next n bytes in this stream,or throws eofexception if it contains fewerthan n bytes.",
	"Method": "void skip(int n){\r\n    while (this.len > 0 && this.curr + n >= this.len) {\r\n        n -= (this.len - this.curr);\r\n        this.len = this.in.read(this.buff);\r\n        Assert.check(this.len != 0, EC.SYSTEM_STREAM_EMPTY);\r\n        this.curr = 0;\r\n    }\r\n    if (n > 0 && this.len < 0)\r\n        throw new EOFException();\r\n    this.curr += n;\r\n    Assert.check(this.len < 0 || this.curr < this.len, EC.SYSTEM_INDEX_ERROR);\r\n}"
}, {
	"Path": "util.UniqueString.compareTo",
	"Comment": "not a compare method as usual for objectsdelivers the difference in positions inside of the table, the unique strings are stored in",
	"Method": "int compareTo(UniqueString uniqueString){\r\n    return this.tok - uniqueString.tok;\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.buildUnion",
	"Comment": "defines the code to build the struct instance using the data in the local variables.",
	"Method": "LocalVariableDefinition buildUnion(MethodDefinition read,Map<Short, LocalVariableDefinition> unionData){\r\n    LocalVariableDefinition instance = constructUnionInstance(read);\r\n    read.loadVariable(\"fieldId\");\r\n    List<CaseStatement> cases = new ArrayList();\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        cases.add(caseStatement(field.getId(), field.getName() + \"-inject-field\"));\r\n    }\r\n    read.switchStatement(\"inject-default\", cases);\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        read.visitLabel(field.getName() + \"-inject-field\");\r\n        injectField(read, field, instance, unionData.get(field.getId()));\r\n        if (field.getMethodInjection().isPresent()) {\r\n            injectMethod(read, field.getMethodInjection().get(), instance, unionData);\r\n        }\r\n        read.gotoLabel(\"inject-default\");\r\n    }\r\n    read.visitLabel(\"inject-default\");\r\n    ThriftFieldMetadata idField = getOnlyElement(metadata.getFields(THRIFT_UNION_ID));\r\n    injectIdField(read, idField, instance, unionData);\r\n    invokeFactoryMethod(read, unionData, instance);\r\n    return instance;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.BoxedCommentHandler.setCommentFields",
	"Comment": "sets begincommentoffset, endcommentoffset, indent, and margin",
	"Method": "void setCommentFields(){\r\n    int searchOffset = offset;\r\n    if ((offset > 0) && text.charAt(offset - 1) == '(') {\r\n        searchOffset++;\r\n    }\r\n    beginCommentOffset = text.lastIndexOf(\"(*\", searchOffset);\r\n    searchOffset = offset;\r\n    if (text.charAt(offset) == ')') {\r\n        searchOffset--;\r\n    }\r\n    endCommentOffset = text.indexOf(\"*)\", searchOffset) + 2;\r\n    IRegion beginCommentLineInfo = doc.getLineInformationOfOffset(beginCommentOffset);\r\n    indent = beginCommentOffset - beginCommentLineInfo.getOffset();\r\n    margin = Math.max(RightMargin, indent + 4);\r\n}"
}, {
	"Path": "tlc2.util.List.cons",
	"Comment": "this method is the cons equivalent. it returns a new listof adding a new element in the front.",
	"Method": "List cons(Object value){\r\n    ConsCell cell = new ConsCell(value, this.first);\r\n    List newList = new List();\r\n    newList.first = cell;\r\n    newList.last = (this.last == null) ? cell : this.last;\r\n    return newList;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackEditPage.selectGiverToBeInstructorsAndWaitForVisibilityMessageToLoad",
	"Comment": "selects the giver in the feedback path to be instructors in the course and waits for the corresponding visibilitymessage to load.",
	"Method": "void selectGiverToBeInstructorsAndWaitForVisibilityMessageToLoad(){\r\n    selectDropdownByVisibleValueAndHandleAjaxRequests(giverDropdownForNewQuestion, \"Instructors in this course\");\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackQuestionsLogic.deleteFeedbackQuestionsCascadeForSession",
	"Comment": "cascade deletes all feedback questions for a session.silently fails if questions do not exist.",
	"Method": "void deleteFeedbackQuestionsCascadeForSession(String feedbackSessionName,String courseId){\r\n    List<FeedbackQuestionAttributes> questions = fqDb.getFeedbackQuestionsForSession(feedbackSessionName, courseId);\r\n    for (FeedbackQuestionAttributes question : questions) {\r\n        frLogic.deleteFeedbackResponsesForQuestionAndCascade(question.getId(), false);\r\n    }\r\n    fqDb.deleteEntities(questions);\r\n}"
}, {
	"Path": "util.ToolIO.setMode",
	"Comment": "set the mode and returns true if the mode argument is legal, otherwise does nothing and returns false.",
	"Method": "boolean setMode(int m){\r\n    if (m == SYSTEM) {\r\n        mode = m;\r\n        out = System.out;\r\n        err = System.err;\r\n        return true;\r\n    } else if (m == TOOL) {\r\n        mode = m;\r\n        out = new ToolPrintStream();\r\n        err = new ToolPrintStream();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.PhysicalTypeIdentifier.getPath",
	"Comment": "parses the given metadata id for the path of the user project type towhich it relates.",
	"Method": "LogicalPath getPath(String metadataId){\r\n    return PhysicalTypeIdentifierNamingUtils.getPath(PHYSICAL_METADATA_TYPE, metadataId);\r\n}"
}, {
	"Path": "tla2sany.semantic.Generator.generateOpArg",
	"Comment": "return an opargnode constructed from a generalid tree to be usedin the rhs of a substitution",
	"Method": "OpArgNode generateOpArg(SymbolNode targetSymbol,TreeNode opArgSyntaxNode,ModuleNode mn){\r\n    if (opArgSyntaxNode.isKind(N_Lambda)) {\r\n        return new OpArgNode(generateLambda(opArgSyntaxNode, mn), opArgSyntaxNode, mn);\r\n    }\r\n    ;\r\n    if (!(opArgSyntaxNode.isKind(N_GeneralId) || opArgSyntaxNode.isKind(N_GenInfixOp) || opArgSyntaxNode.isKind(N_GenPrefixOp) || opArgSyntaxNode.isKind(N_GenNonExpPrefixOp) || opArgSyntaxNode.isKind(N_GenPostfixOp))) {\r\n        errors.addError(opArgSyntaxNode.getLocation(), \"Arity \" + targetSymbol.getArity() + \" operator (not an expression) is expected\" + \" \\nto substitute for CONSTANT '\" + targetSymbol.getName() + \"'.\");\r\n        return nullOpArg;\r\n    }\r\n    if (opArgSyntaxNode.getKind() == N_GeneralId) {\r\n        if (targetSymbol.getArity() <= 0) {\r\n            errors.addAbort(opArgSyntaxNode.getLocation(), \"Internal error: expected to find arity > 0.\", true);\r\n        }\r\n        ;\r\n        LevelNode ln = selectorToNode(genIdToSelector((SyntaxTreeNode) opArgSyntaxNode), targetSymbol.getArity(), false, false, mn);\r\n        if (!(ln instanceof OpArgNode)) {\r\n            if (errors.getNumErrors() > 0) {\r\n                return nullOpArg;\r\n            }\r\n            errors.addAbort(opArgSyntaxNode.getLocation(), \"Internal error: \" + \"Expected an operator argument but \" + \"found something else.\");\r\n        }\r\n        ;\r\n        return (OpArgNode) ln;\r\n    }\r\n    ;\r\n    GenID genID = generateGenID(opArgSyntaxNode, mn);\r\n    if (genID.getFullyQualifiedOp() != null && genID.getArgs().length == 0) {\r\n        return new OpArgNode(genID.getFullyQualifiedOp(), opArgSyntaxNode, mn);\r\n    } else if (genID.getArgs().length > 0) {\r\n        errors.addError(opArgSyntaxNode.getLocation(), \"Arity \" + targetSymbol.getArity() + \" operator (not an expression) is expected\" + \" to substitute for CONSTANT '\" + targetSymbol.getName() + \"'.\");\r\n        return nullOpArg;\r\n    } else {\r\n        return nullOpArg;\r\n    }\r\n}"
}, {
	"Path": "teammates.storage.search.SearchManager.putDocument",
	"Comment": "creates or updates the search document for the given document and index.",
	"Method": "void putDocument(String indexName,Document document){\r\n    try {\r\n        putDocumentWithRetry(indexName, document);\r\n    } catch (PutException e) {\r\n        log.severe(String.format(ERROR_NON_TRANSIENT_BACKEND_ISSUE, document, indexName) + TeammatesException.toStringWithStackTrace(e));\r\n    } catch (MaximumRetriesExceededException e) {\r\n        log.severe(String.format(ERROR_MAXIMUM_RETRIES_EXCEEDED, document, indexName, e.finalMessage) + TeammatesException.toStringWithStackTrace(e));\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.WsEndpointsMetadata.getServiceField",
	"Comment": "this method obtains the service field that will be used in some differentmethods.",
	"Method": "FieldMetadata getServiceField(JavaType service){\r\n    if (serviceFields.get(service) != null) {\r\n        return serviceFields.get(service);\r\n    }\r\n    FieldMetadataBuilder serviceField = new FieldMetadataBuilder(getId(), Modifier.PRIVATE, new JavaSymbolName(StringUtils.uncapitalize(service.getSimpleTypeName())), service, null);\r\n    serviceField.addAnnotation(new AnnotationMetadataBuilder(SpringJavaType.AUTOWIRED));\r\n    serviceFields.put(service, serviceField.build());\r\n    return serviceField.build();\r\n}"
}, {
	"Path": "teammates.ui.controller.AdminSessionsPageAction.findAvailableInstructorGoogleIdForCourse",
	"Comment": "this method loops through all instructors for the given course until a registered instructor is found.it returns the google id of the found instructor.",
	"Method": "String findAvailableInstructorGoogleIdForCourse(String courseId){\r\n    for (InstructorAttributes instructor : logic.getInstructorsForCourse(courseId)) {\r\n        if (instructor.googleId != null) {\r\n            return instructor.googleId;\r\n        }\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.ReflectionUtils.handleReflectionException",
	"Comment": "handle the given reflection exception. should only be called if nochecked exception is expected to be thrown by the target method.throws the underlying runtimeexception or error in case of aninvocationtargetexception with such a root cause. throws anillegalstateexception with an appropriate message else.",
	"Method": "void handleReflectionException(Exception ex){\r\n    if (ex instanceof NoSuchMethodException) {\r\n        throw new IllegalStateException(\"Method not found: \" + ex.getMessage());\r\n    }\r\n    if (ex instanceof IllegalAccessException) {\r\n        throw new IllegalStateException(\"Could not access method: \" + ex.getMessage());\r\n    }\r\n    if (ex instanceof InvocationTargetException) {\r\n        handleInvocationTargetException((InvocationTargetException) ex);\r\n    }\r\n    if (ex instanceof RuntimeException) {\r\n        throw (RuntimeException) ex;\r\n    }\r\n    handleUnexpectedException(ex);\r\n}"
}, {
	"Path": "pcal.TLAtoPCalMapping.NextLocOf",
	"Comment": "returns the position within map of the next object after the one withposition loc.it returns null if there is no further object in map.",
	"Method": "PCalLocation NextLocOf(PCalLocation loc,MappingObject[][] map){\r\n    if (loc.getColumn() + 1 < map[loc.getLine()].length) {\r\n        return new PCalLocation(loc.getLine(), loc.getColumn() + 1);\r\n    }\r\n    for (int i = loc.getLine() + 1; i < map.length; i++) {\r\n        if (map[i].length > 0) {\r\n            return new PCalLocation(i, 0);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.isElementInvisibleOrStale",
	"Comment": "returns true if the element is invisible or stale as defined in the webdriver specification.",
	"Method": "boolean isElementInvisibleOrStale(By locator){\r\n    return isExpectedCondition(ExpectedConditions.invisibilityOfElementLocated(locator));\r\n}"
}, {
	"Path": "tla2sany.semantic.APSubstInNode.addExplicitSubstitute",
	"Comment": "add a substitution to the substitutions array, either byoverwriting a legal implicit substitution, if one matches, orcreating a new one.in general, the substitutions array on entryto this method can contain a mixture of explicit and implicitsubstitutions",
	"Method": "void addExplicitSubstitute(Context instanceCtxt,UniqueString lhs,TreeNode stn,ExprOrOpArgNode sub){\r\n    int index;\r\n    for (index = 0; index < this.substs.length; index++) {\r\n        if (lhs == this.substs[index].getOp().getName())\r\n            break;\r\n    }\r\n    if (index < this.substs.length) {\r\n        if (!this.substs[index].isImplicit()) {\r\n            errors.addError(stn.getLocation(), \"Multiple substitutions for symbol '\" + lhs.toString() + \"' in substitution.\");\r\n        } else {\r\n            this.substs[index].setExpr(sub, false);\r\n            this.substs[index].setExprSTN(stn);\r\n        }\r\n    } else {\r\n        SymbolNode lhsSymbol = instanceCtxt.getSymbol(lhs);\r\n        if (!(lhsSymbol instanceof OpDeclNode)) {\r\n            return;\r\n        }\r\n        if (lhsSymbol != null) {\r\n            int newlength = this.substs.length + 1;\r\n            Subst[] newSubsts = new Subst[newlength];\r\n            Subst newSubst = new Subst((OpDeclNode) lhsSymbol, sub, stn, false);\r\n            System.arraycopy(this.substs, 0, newSubsts, 0, newlength - 1);\r\n            newSubsts[newlength - 1] = newSubst;\r\n            this.substs = newSubsts;\r\n        } else {\r\n            errors.addError(stn.getLocation(), \"Illegal identifier '\" + lhs + \"' in LHS of substitution.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.wizard.AssignmentWizardPage.modelValueSelected",
	"Comment": "added by ll on 5 nov 2009returns true iff the page has a model value option that is chosen.",
	"Method": "boolean modelValueSelected(){\r\n    if (optionModelValue == null) {\r\n        return false;\r\n    }\r\n    return optionModelValue.getSelection();\r\n}"
}, {
	"Path": "teammates.common.datatransfer.CourseRoster.getEmailToNameTableFromRoster",
	"Comment": "returns a map of email mapped to name of instructors and students of the course.",
	"Method": "Map<String, String> getEmailToNameTableFromRoster(){\r\n    Map<String, String> emailToNameTable = new HashMap();\r\n    List<InstructorAttributes> instructorList = getInstructors();\r\n    for (InstructorAttributes instructor : instructorList) {\r\n        emailToNameTable.put(instructor.email, instructor.name);\r\n    }\r\n    List<StudentAttributes> studentList = getStudents();\r\n    for (StudentAttributes student : studentList) {\r\n        emailToNameTable.put(student.email, student.name);\r\n    }\r\n    return emailToNameTable;\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.utils.File.extractResource",
	"Comment": "extract data from an inputstream and add it to the current file location.\tif the file already exist, it will be overwritten. otherwise the file will be created.",
	"Method": "Boolean extractResource(Context context,String asset,Boolean extractResource,Context context,Integer resourceid,Boolean extractResource,InputStream resource){\r\n    synchronized (mLock) {\r\n        if (!isDirectory()) {\r\n            try {\r\n                FileWriter writer = getFileWriter();\r\n                if (writer != null) {\r\n                    byte[] buffer = new byte[1024];\r\n                    int loc = 0;\r\n                    while ((loc = resource.read(buffer)) > 0) {\r\n                        writer.write(buffer, 0, loc);\r\n                    }\r\n                    writer.close();\r\n                }\r\n            } catch (Throwable e) {\r\n                Log.e(TAG, e.getMessage(), e);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackEditPage.selectConstSumPointsOptions",
	"Comment": "selects the points distribution scheme for a const sum question.",
	"Method": "void selectConstSumPointsOptions(String pointsOption,int questionNumber){\r\n    markRadioButtonAsChecked(browser.driver.findElement(By.id(\"constSumPoints\" + pointsOption + \"-\" + questionNumber)));\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.readFieldValues",
	"Comment": "defines the code to read all of the data from the protocol into local variables.",
	"Method": "Map<Short, LocalVariableDefinition> readFieldValues(MethodDefinition read){\r\n    LocalVariableDefinition protocol = read.getLocalVariable(\"reader\");\r\n    Map<Short, LocalVariableDefinition> structData = new TreeMap();\r\n    for (ThriftFieldMetadata field : metadata.getFields(FieldKind.THRIFT_FIELD)) {\r\n        LocalVariableDefinition variable = read.addInitializedLocalVariable(toParameterizedType(field.getThriftType()), \"f_\" + field.getName());\r\n        structData.put(field.getId(), variable);\r\n    }\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"readStructBegin\", void.class);\r\n    read.visitLabel(\"while-begin\");\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"nextField\", boolean.class);\r\n    read.ifZeroGoto(\"while-end\");\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"getFieldId\", short.class);\r\n    List<CaseStatement> cases = new ArrayList();\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        cases.add(caseStatement(field.getId(), field.getName() + \"-field\"));\r\n    }\r\n    read.switchStatement(\"default\", cases);\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        read.visitLabel(field.getName() + \"-field\");\r\n        read.loadVariable(protocol);\r\n        FieldDefinition codecField = codecFields.get(field.getId());\r\n        if (codecField != null) {\r\n            read.loadThis().getField(codecType, codecField);\r\n        }\r\n        Method readMethod = getReadMethod(field.getThriftType());\r\n        if (readMethod == null) {\r\n            throw new IllegalArgumentException(\"Unsupported field type \" + field.getThriftType().getProtocolType());\r\n        }\r\n        read.invokeVirtual(readMethod);\r\n        if (needsCastAfterRead(field, readMethod)) {\r\n            read.checkCast(toParameterizedType(field.getThriftType()));\r\n        }\r\n        if (field.getCoercion().isPresent()) {\r\n            read.invokeStatic(field.getCoercion().get().getFromThrift());\r\n        }\r\n        read.storeVariable(structData.get(field.getId()));\r\n        read.gotoLabel(\"while-begin\");\r\n    }\r\n    read.visitLabel(\"default\").loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"skipFieldData\", void.class).gotoLabel(\"while-begin\");\r\n    read.visitLabel(\"while-end\");\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"readStructEnd\", void.class);\r\n    return structData;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.CourseDetailsBundle.getFeedbackSessionsList",
	"Comment": "gets all feedbacksessionattributes in this coursedetailsbundle.",
	"Method": "List<FeedbackSessionAttributes> getFeedbackSessionsList(){\r\n    List<FeedbackSessionAttributes> feedbackSessionAttributes = new ArrayList();\r\n    for (FeedbackSessionDetailsBundle feedbackSessionDetails : feedbackSessions) {\r\n        feedbackSessionAttributes.add(feedbackSessionDetails.feedbackSession);\r\n    }\r\n    return feedbackSessionAttributes;\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.NotificationDrawerLayout.setScrimColor",
	"Comment": "set a color to use for the scrim that obscures primary content while a drawer is open.",
	"Method": "void setScrimColor(int color){\r\n    mScrimColor = color;\r\n    invalidate();\r\n}"
}, {
	"Path": "util.BufferedDataOutputStream.flush",
	"Comment": "flush all bytes written to this stream to the underlyingoutput stream.",
	"Method": "void flush(){\r\n    this.out.write(this.buff, 0, this.len);\r\n    this.out.flush();\r\n    this.len = 0;\r\n}"
}, {
	"Path": "teammates.logic.core.CoursesLogic.isSampleCourse",
	"Comment": "returns true if the course with id courseid is a sample course.",
	"Method": "boolean isSampleCourse(String courseId){\r\n    Assumption.assertNotNull(\"Course ID is null\", courseId);\r\n    return StringHelper.isMatching(courseId, FieldValidator.REGEX_SAMPLE_COURSE_ID);\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.defineConstructor",
	"Comment": "defines the constructor with a parameter for the thrifttype and the delegate codecs. theconstructor simply assigns these parameters to the class fields.",
	"Method": "void defineConstructor(){\r\n    MethodDefinition constructor = new MethodDefinition(a(PUBLIC), \"<init>\", type(void.class), parameters.getParameters());\r\n    constructor.loadThis().invokeConstructor(type(Object.class));\r\n    for (FieldDefinition fieldDefinition : parameters.getFields()) {\r\n        constructor.loadThis().loadVariable(fieldDefinition.getName()).putField(codecType, fieldDefinition);\r\n    }\r\n    constructor.ret();\r\n    classDefinition.addMethod(constructor);\r\n}"
}, {
	"Path": "teammates.test.cases.browsertests.AdminSessionsPageUiTest.isSessionDataDisplayCorrect",
	"Comment": "this method only checks if the session data tables are displayed correctlyi.e, table headers are correct, and appropriate message is displayed if nosession data is present.it does not test for the table content",
	"Method": "boolean isSessionDataDisplayCorrect(){\r\n    if (sessionsPage.isElementPresent(By.className(\"data-table\"))) {\r\n        int numSessionDataTables = browser.driver.findElements(By.className(\"data-table\")).size();\r\n        for (int i = 0; i < numSessionDataTables; i++) {\r\n            if (!isSessionTableHeaderCorrect(i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    sessionsPage.waitForTextsForAllStatusMessagesToUserEquals(\"Currently No Ongoing Sessions\");\r\n    return true;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackEditPage.waitForTextsForAllStatusMessagesToUserEqualsErrorTexts",
	"Comment": "waits and verifies that the texts of user status messages in the page are equal to the expected error texts.",
	"Method": "void waitForTextsForAllStatusMessagesToUserEqualsErrorTexts(String firstExpectedErrorText,String remainingExpectedErrorTexts){\r\n    waitForScrollingToComplete();\r\n    waitForTextsForAllStatusMessagesToUserEquals(firstExpectedErrorText, remainingExpectedErrorTexts);\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackResultsPage.isAllResultsPanelBodyVisibilityEquals",
	"Comment": "checks if the body of all the results panels are collapsed or expanded.",
	"Method": "boolean isAllResultsPanelBodyVisibilityEquals(boolean isVisible){\r\n    By panelCollapseSelector = By.cssSelector(\".panel-heading+.panel-collapse\");\r\n    List<WebElement> webElements = browser.driver.findElements(panelCollapseSelector);\r\n    int numOfQns = webElements.size();\r\n    assertTrue(numOfQns > 0);\r\n    for (WebElement e : webElements) {\r\n        if (e.isDisplayed() != isVisible) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "tlc2.tool.Tool.eval",
	"Comment": "this method evaluates the expression expr in the given context,current state, and partial next state.",
	"Method": "Value eval(SemanticNode expr,Context c,TLCState s0,Value eval,SemanticNode expr,Context c,TLCState s0,TLCState s1,int control){\r\n    if (this.callStack != null)\r\n        this.callStack.push(expr);\r\n    try {\r\n        switch(expr.getKind()) {\r\n            case LabelKind:\r\n                {\r\n                    LabelNode expr1 = (LabelNode) expr;\r\n                    return this.eval(expr1.getBody(), c, s0, s1, control);\r\n                }\r\n            case OpApplKind:\r\n                {\r\n                    OpApplNode expr1 = (OpApplNode) expr;\r\n                    return this.evalAppl(expr1, c, s0, s1, control);\r\n                }\r\n            case LetInKind:\r\n                {\r\n                    LetInNode expr1 = (LetInNode) expr;\r\n                    OpDefNode[] letDefs = expr1.getLets();\r\n                    int letLen = letDefs.length;\r\n                    Context c1 = c;\r\n                    for (int i = 0; i < letLen; i++) {\r\n                        OpDefNode opDef = letDefs[i];\r\n                        if (opDef.getArity() == 0) {\r\n                            Value rhs = new LazyValue(opDef.getBody(), c1);\r\n                            c1 = c1.cons(opDef, rhs);\r\n                        }\r\n                    }\r\n                    return this.eval(expr1.getBody(), c1, s0, s1, control);\r\n                }\r\n            case SubstInKind:\r\n                {\r\n                    SubstInNode expr1 = (SubstInNode) expr;\r\n                    Subst[] subs = expr1.getSubsts();\r\n                    int slen = subs.length;\r\n                    Context c1 = c;\r\n                    for (int i = 0; i < slen; i++) {\r\n                        Subst sub = subs[i];\r\n                        c1 = c1.cons(sub.getOp(), this.getVal(sub.getExpr(), c, true));\r\n                    }\r\n                    return this.eval(expr1.getBody(), c1, s0, s1, control);\r\n                }\r\n            case APSubstInKind:\r\n                {\r\n                    APSubstInNode expr1 = (APSubstInNode) expr;\r\n                    Subst[] subs = expr1.getSubsts();\r\n                    int slen = subs.length;\r\n                    Context c1 = c;\r\n                    for (int i = 0; i < slen; i++) {\r\n                        Subst sub = subs[i];\r\n                        c1 = c1.cons(sub.getOp(), this.getVal(sub.getExpr(), c, true));\r\n                    }\r\n                    return this.eval(expr1.getBody(), c1, s0, s1, control);\r\n                }\r\n            case NumeralKind:\r\n            case DecimalKind:\r\n            case StringKind:\r\n                {\r\n                    return Value.getValue(expr);\r\n                }\r\n            case AtNodeKind:\r\n                {\r\n                    return (Value) c.lookup(EXCEPT_AT);\r\n                }\r\n            case OpArgKind:\r\n                {\r\n                    OpArgNode expr1 = (OpArgNode) expr;\r\n                    SymbolNode opNode = expr1.getOp();\r\n                    Object val = this.lookup(opNode, c, false);\r\n                    if (val instanceof OpDefNode) {\r\n                        return setSource(expr, new OpLambdaValue((OpDefNode) val, this, c, s0, s1));\r\n                    }\r\n                    return (Value) val;\r\n                }\r\n            default:\r\n                {\r\n                    Assert.fail(\"Attempted to evaluate an expression that cannot be evaluated.\\n\" + expr);\r\n                    return null;\r\n                }\r\n        }\r\n    } catch (TLCRuntimeException | EvalException e) {\r\n        if (this.callStack != null) {\r\n            this.callStack.freeze();\r\n        }\r\n        throw e;\r\n    } finally {\r\n        if (this.callStack != null) {\r\n            this.callStack.pop();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "tla2sany.semantic.SubstInNode.addExplicitSubstitute",
	"Comment": "add a substitution to the substitutions array, either byoverwriting a legal implicit substitution, if one matches, orcreating a new one.in general, the substitutions array on entryto this method can contain a mixture of explicit and implicitsubstitutions",
	"Method": "void addExplicitSubstitute(Context instanceCtxt,UniqueString lhs,TreeNode stn,ExprOrOpArgNode sub){\r\n    int index;\r\n    for (index = 0; index < this.substs.length; index++) {\r\n        if (lhs == this.substs[index].getOp().getName())\r\n            break;\r\n    }\r\n    if (index < this.substs.length) {\r\n        if (!this.substs[index].isImplicit()) {\r\n            errors.addError(stn.getLocation(), \"Multiple substitutions for symbol '\" + lhs.toString() + \"' in substitution.\");\r\n        } else {\r\n            this.substs[index].setExpr(sub, false);\r\n            this.substs[index].setExprSTN(stn);\r\n        }\r\n    } else {\r\n        SymbolNode lhsSymbol = instanceCtxt.getSymbol(lhs);\r\n        if (!(lhsSymbol instanceof OpDeclNode)) {\r\n            return;\r\n        }\r\n        if (lhsSymbol != null) {\r\n            int newlength = this.substs.length + 1;\r\n            Subst[] newSubsts = new Subst[newlength];\r\n            Subst newSubst = new Subst((OpDeclNode) lhsSymbol, sub, stn, false);\r\n            System.arraycopy(this.substs, 0, newSubsts, 0, newlength - 1);\r\n            newSubsts[newlength - 1] = newSubst;\r\n            this.substs = newSubsts;\r\n        } else {\r\n            errors.addError(stn.getLocation(), \"Illegal identifier '\" + lhs + \"' in LHS of substitution.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "tla2sany.parser.OperatorStack.reduceStack",
	"Comment": "returns true if reduction succeeded, or was without effect.",
	"Method": "void reduceStack(){\r\n    int n;\r\n    Operator oR, oL;\r\n    Operator LastOp = null;\r\n    OSelement tm0, tm1, tm2;\r\n    int a1, a2;\r\n    do {\r\n        n = CurrentTop.size() - 1;\r\n        tm0 = (OSelement) CurrentTop.elementAt(n);\r\n        if (!tm0.isOperator())\r\n            break;\r\n        oR = tm0.getOperator();\r\n        if (oR.isPostfix()) {\r\n            if (n == 0) {\r\n                throw new ParseException(\"\\n  Encountered postfix op \" + oR.getIdentifier() + \" in block \" + tm0.getNode().getLocation().toString() + \" on empty stack\");\r\n            } else {\r\n                tm1 = (OSelement) CurrentTop.elementAt(n - 1);\r\n                if (tm1.isOperator()) {\r\n                    oL = tm1.getOperator();\r\n                    if (oL.isInfix() || oL.isPrefix()) {\r\n                        throw new ParseException(\"\\n  Encountered postfix op \" + oR.getIdentifier() + \" in block \" + tm0.getNode().getLocation().toString() + \" following prefix or infix op \" + oL.getIdentifier() + \".\");\r\n                    } else {\r\n                        reducePostfix();\r\n                    }\r\n                } else {\r\n                    if (n > 1) {\r\n                        tm2 = (OSelement) CurrentTop.elementAt(n - 2);\r\n                        if (tm2.isOperator()) {\r\n                            oL = tm2.getOperator();\r\n                            if (Operator.succ(oL, oR)) {\r\n                                if (oL.isInfix())\r\n                                    reduceInfix(oL);\r\n                                else\r\n                                    reducePrefix();\r\n                            } else if (!Operator.prec(oL, oR)) {\r\n                                throw new ParseException(\"Precedence conflict between ops \" + oL.getIdentifier() + \" in block \" + tm0.getNode().getLocation().toString() + \" and \" + oR.getIdentifier() + \".\");\r\n                            } else\r\n                                break;\r\n                        } else {\r\n                            throw new ParseException(\"Expression at location \" + tm2.getNode().getLocation().toString() + \" and expression at location \" + tm1.getNode().getLocation().toString() + \" follow each other without any intervening operator.\");\r\n                        }\r\n                    } else\r\n                        break;\r\n                }\r\n            }\r\n        } else if (oR.isPrefix()) {\r\n            if (n == 0)\r\n                break;\r\n            else {\r\n                tm1 = (OSelement) CurrentTop.elementAt(n - 1);\r\n                if (tm1.isOperator()) {\r\n                    oL = tm1.getOperator();\r\n                    if (oL.isPostfix()) {\r\n                        throw new ParseException(\"\\n  Encountered prefix op \" + oR.getIdentifier() + \" in block \" + tm0.getNode().getLocation().toString() + \" following postfix op \" + oL.getIdentifier() + \".\");\r\n                    } else\r\n                        break;\r\n                } else {\r\n                    throw new ParseException(\"\\n  Encountered prefix op \" + oR.getIdentifier() + \" in block \" + tm0.getNode().getLocation().toString() + \" following an expression.\");\r\n                }\r\n            }\r\n        } else {\r\n            if (n == 0) {\r\n                Operator mixR = Operators.getMixfix(oR);\r\n                if (mixR == null)\r\n                    throw new ParseException(\"\\n  Encountered infix op \" + oR.getIdentifier() + \" in block \" + tm0.getNode().getLocation().toString() + \" on empty stack.\");\r\n                else\r\n                    break;\r\n            } else {\r\n                tm1 = (OSelement) CurrentTop.elementAt(n - 1);\r\n                if (tm1.isOperator()) {\r\n                    oL = tm1.getOperator();\r\n                    if (oL.isInfix() || oL.isPrefix()) {\r\n                        Operator mixR = Operators.getMixfix(oR);\r\n                        if (mixR == null) {\r\n                            if (oR == Operator.VoidOperator())\r\n                                throw new ParseException(\"\\n  Missing expression in block \" + tm1.getNode().getLocation().toString() + \" following prefix or infix op \" + oL.getIdentifier() + \".\");\r\n                            else\r\n                                throw new ParseException(\"\\n  Encountered infix op \" + oR.getIdentifier() + \" in block \" + tm1.getNode().getLocation().toString() + \" following prefix or infix op \" + oL.getIdentifier() + \".\");\r\n                        } else if (Operator.succ(oL, mixR) || (oL == mixR && oL.assocLeft())) {\r\n                            throw new ParseException(\"\\n  Precedence conflict between ops \" + oL.getIdentifier() + \" in block \" + tm1.getNode().getLocation().toString() + \" and \" + mixR.getIdentifier() + \".\");\r\n                        }\r\n                    } else\r\n                        reducePostfix();\r\n                } else {\r\n                    if (n > 1) {\r\n                        tm2 = (OSelement) CurrentTop.elementAt(n - 2);\r\n                        if (tm2.isOperator()) {\r\n                            oL = tm2.getOperator();\r\n                            Operator mixL = Operators.getMixfix(oL);\r\n                            if (mixL != null && ((n == 2) || ((OSelement) CurrentTop.elementAt(n - 3)).isOperator())) {\r\n                                oL = mixL;\r\n                            }\r\n                            if (Operator.succ(oL, oR) || (oL == oR && oL.assocLeft())) {\r\n                                if (oL.isInfix())\r\n                                    reduceInfix(oL);\r\n                                else if (oL.isPrefix())\r\n                                    reducePrefix();\r\n                                else {\r\n                                    if ((tm2.getNode().getLocation().beginLine() < tm1.getNode().getLocation().beginLine()) && (oR.getIdentifier() == UniqueString.uniqueStringOf(\"=\"))) {\r\n                                        throw new ParseException(\"\\n  *** Hint *** You may have mistyped ==\" + \"\\n  Illegal combination of operators \" + oL.getIdentifier() + \" in block \" + tm2.getNode().getLocation().toString() + \" and \" + oR.getIdentifier() + \".\");\r\n                                    } else if (oR == Operator.VoidOperator()) {\r\n                                        throw new ParseException(\"\\n Error following expression at  \" + tm2.getNode().getLocation().toString() + \", missing operator or separator.\");\r\n                                    } else {\r\n                                        throw new ParseException(\"\\n  Illegal combination of operators \" + oL.getIdentifier() + \" in block \" + tm2.getNode().getLocation().toString() + \" and \" + oR.getIdentifier() + \".\");\r\n                                    }\r\n                                }\r\n                            } else if (!(Operator.prec(oL, oR) || (oL == oR && oL.assocRight()))) {\r\n                                throw new ParseException(\"\\n  Precedence conflict between ops \" + oL.getIdentifier() + \" in block \" + tm2.getNode().getLocation().toString() + \" and \" + oR.getIdentifier() + \".\");\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        } else {\r\n                            throw new ParseException(\"Expression at location \" + tm2.getNode().getLocation().toString() + \" and expression at location \" + tm1.getNode().getLocation().toString() + \" follow each other without any \" + \"intervening operator.\");\r\n                        }\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } while (n != CurrentTop.size() - 1);\r\n}"
}, {
	"Path": "org.springframework.roo.project.maven.PomFactoryImpl.parseElements",
	"Comment": "parses any elements matching the given xpath expression into instances ofthe given type.",
	"Method": "List<T> parseElements(Class<T> type,String xPath,Element root){\r\n    final List<T> results = new ArrayList<T>();\r\n    for (final Element element : XmlUtils.findElements(xPath, root)) {\r\n        try {\r\n            results.add(type.getConstructor(Element.class).newInstance(element));\r\n        } catch (final RuntimeException e) {\r\n            throw e;\r\n        } catch (final Exception e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "tla2sany.semantic.SubstInNode.getChildren",
	"Comment": "the children of this node are the body and the expressionsbeing substituted for symbols.",
	"Method": "SemanticNode[] getChildren(){\r\n    SemanticNode[] res = new SemanticNode[this.substs.length + 1];\r\n    res[0] = this.body;\r\n    for (int i = 0; i < substs.length; i++) {\r\n        res[i + 1] = substs[i].getExpr();\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "org.springframework.roo.obr.addon.search.ObrRepositoryOperationsImpl.populateRepositories",
	"Comment": "method to populate current repositories using osgi service",
	"Method": "void populateRepositories(){\r\n    repositories.clear();\r\n    Validate.notNull(getRepositoryAdmin(), \"RepositoryAdmin not found\");\r\n    Enumeration persistedRepos = installedRepos.keys();\r\n    while (persistedRepos.hasMoreElements()) {\r\n        String repositoryURL = (String) persistedRepos.nextElement();\r\n        if (repositoryURL.startsWith(\"http\") || repositoryURL.startsWith(\"file\")) {\r\n            getRepositoryAdmin().addRepository(repositoryURL);\r\n        }\r\n    }\r\n    for (Repository repo : getRepositoryAdmin().listRepositories()) {\r\n        repositories.add(repo);\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.util.ChangedSpecModulesGatheringDeltaVisitor.isModelChanged",
	"Comment": "returns if the resource delta contained a marker modifications of the model file",
	"Method": "boolean isModelChanged(){\r\n    return this.model != null;\r\n}"
}, {
	"Path": "teammates.storage.api.InstructorsDb.updateInstructorByGoogleId",
	"Comment": "updates the instructor. cannot modify course id or google id.",
	"Method": "void updateInstructorByGoogleId(InstructorAttributes instructorAttributesToUpdate){\r\n    Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, instructorAttributesToUpdate);\r\n    if (!instructorAttributesToUpdate.isValid()) {\r\n        throw new InvalidParametersException(instructorAttributesToUpdate.getInvalidityInfo());\r\n    }\r\n    instructorAttributesToUpdate.sanitizeForSaving();\r\n    Instructor instructorToUpdate = getInstructorEntityForGoogleId(instructorAttributesToUpdate.courseId, instructorAttributesToUpdate.googleId);\r\n    if (instructorToUpdate == null) {\r\n        throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT_ACCOUNT + instructorAttributesToUpdate.googleId + ThreadHelper.getCurrentThreadStack());\r\n    }\r\n    instructorToUpdate.setName(instructorAttributesToUpdate.name);\r\n    instructorToUpdate.setEmail(instructorAttributesToUpdate.email);\r\n    instructorToUpdate.setIsArchived(instructorAttributesToUpdate.isArchived);\r\n    instructorToUpdate.setRole(instructorAttributesToUpdate.role);\r\n    instructorToUpdate.setIsDisplayedToStudents(instructorAttributesToUpdate.isDisplayedToStudents);\r\n    instructorToUpdate.setDisplayedName(instructorAttributesToUpdate.displayedName);\r\n    instructorToUpdate.setInstructorPrivilegeAsText(instructorAttributesToUpdate.getTextFromInstructorPrivileges());\r\n    putDocument(makeAttributes(instructorToUpdate));\r\n    saveEntity(instructorToUpdate, instructorAttributesToUpdate);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.TLAMarkerHelper.installProblemMarkers",
	"Comment": "installs the error markers from the vector of markerinformationholders",
	"Method": "void installProblemMarkers(Vector<TLAMarkerInformationHolder> detectedErrors,IProgressMonitor monitor){\r\n    if (detectedErrors == null || detectedErrors.isEmpty()) {\r\n        return;\r\n    }\r\n    for (int i = 0; i < detectedErrors.size(); i++) {\r\n        TLAMarkerInformationHolder holder = (TLAMarkerInformationHolder) detectedErrors.get(i);\r\n        installProblemMarker(holder.resource, holder.moduleName, holder.severityError, holder.coordinates, holder.message, monitor, holder.type);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.obr.addon.search.ObrRepositoryOperationsImpl.getNamesOfInstalledBundles",
	"Comment": "method to get all names of installed bundles on spring roo shell",
	"Method": "List<String> getNamesOfInstalledBundles(){\r\n    List<String> names = new ArrayList<String>();\r\n    Bundle[] bundles = context.getBundles();\r\n    for (Bundle bundle : bundles) {\r\n        names.add(bundle.getSymbolicName());\r\n    }\r\n    return names;\r\n}"
}, {
	"Path": "tla2sany.semantic.Context.getOpDefs",
	"Comment": "returns a vector of those symbolnodes in this context that areinstances of class opdefnode and that are not of kind builtinkindor moduleinstancekind",
	"Method": "Vector<OpDefNode> getOpDefs(){\r\n    Pair nextPair = lastPair;\r\n    Vector<OpDefNode> result = new Vector();\r\n    while (nextPair != null) {\r\n        if (nextPair.info instanceof OpDefNode && ((OpDefNode) nextPair.info).getKind() != ASTConstants.ModuleInstanceKind && ((OpDefNode) nextPair.info).getKind() != ASTConstants.BuiltInKind)\r\n            result.addElement((OpDefNode) (nextPair.info));\r\n        nextPair = nextPair.link;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.isFeedbackSessionViewableTo",
	"Comment": "checks whether the feedback session is viewable to the specified user.",
	"Method": "boolean isFeedbackSessionViewableTo(FeedbackSessionAttributes session,boolean isInstructorOfCourse){\r\n    if (isInstructorOfCourse) {\r\n        return true;\r\n    }\r\n    return isFeedbackSessionViewableToStudents(session);\r\n}"
}, {
	"Path": "pcal.TLAExpr.print",
	"Comment": "for debugging, the following prints a tlaexpr with an indicated name.",
	"Method": "void print(String name){\r\n    PcalDebug.print2DVector(tokens, name + \".tokens\");\r\n    PcalDebug.printObjectArray(anchorTokens, name + \".anchorTokens\");\r\n    PcalDebug.printIntArray(anchorTokCol, name + \".anchorTokCol\");\r\n}"
}, {
	"Path": "pcal.ParseAlgorithm.SubstituteInStmtSeq",
	"Comment": "the substituteinstmtseq method does substitutions only in the class ofstatements found in the body of a macro.however, it is simple todefine a substituteinlabeledstmtseq method and enhancesubstituteinstmtseq so the substituteinlabeledstmtseq can be used to do arbitrary substitutions in the body of a process or uniprocessalgorithm.",
	"Method": "Vector SubstituteInStmtSeq(Vector stmts,Vector args,Vector params,int macroLine,int macroCol){\r\n    Vector result = new Vector();\r\n    int i = 0;\r\n    while (i < stmts.size()) {\r\n        result.addElement(SubstituteInStmt((AST) stmts.elementAt(i), args, params, macroLine, macroCol));\r\n        i = i + 1;\r\n    }\r\n    ;\r\n    return result;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.StudentProfilePage.ensureNationalityIsSelectedAs",
	"Comment": "makes sure that the nationality is selected in the dropdown list.if not, it fails with a message.",
	"Method": "void ensureNationalityIsSelectedAs(String nationality){\r\n    if (NationalityHelper.getNationalities().contains(nationality) || \"\".equals(nationality)) {\r\n        assertEquals(nationality, studentNationalityDropdown.getAttribute(\"value\"));\r\n    } else {\r\n        fail(\"unexpected nationality value given\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.ReflectionUtils.handleInvocationTargetException",
	"Comment": "handle the given invocation target exception. should only be called if nochecked exception is expected to be thrown by the target method.throws the underlying runtimeexception or error in case of such a rootcause. throws an illegalstateexception else.",
	"Method": "void handleInvocationTargetException(InvocationTargetException ex){\r\n    rethrowRuntimeException(ex.getTargetException());\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.ShowChildrenOnlyHandler.setEnabled",
	"Comment": "this method is used to update the enablement state. this has theeffect of graying out any menu items for thecommand if the handler is disabled. through experimentation, this method seems to becalled just before such menu items are rendered in the ui andjust before the handler is executed.",
	"Method": "void setEnabled(Object context){\r\n    TLAEditor editor = EditorUtil.getTLAEditorWithFocus();\r\n    if (editor != null) {\r\n        if (editor.getProofStructureProvider() != null) {\r\n            setBaseEnabled(editor.getProofStructureProvider().canRunFoldOperation(IProofFoldCommandIds.SHOW_IMMEDIATE, (ITextSelection) editor.getSelectionProvider().getSelection()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.util.TLCUIHelper.jumpToSavedLocation",
	"Comment": "attempts to jump to the location in a saved versionof the module for the given model. it will jump to the locationin a nested editor in the model editor for configuration if sucha nested editor is already open. if a nested editor is not alreadyopen, it will not make the jump and will return false.returns true if it successfully jumps to the location in the nestededitor showing the saved module.",
	"Method": "boolean jumpToSavedLocation(Location location,Model model){\r\n    IEditorPart editor = model.getAdapter(ModelEditor.class);\r\n    if (editor instanceof ModelEditor) {\r\n        ModelEditor modelEditor = (ModelEditor) editor;\r\n        ITextEditor moduleEditor = modelEditor.getSavedModuleEditor(location.source());\r\n        if (moduleEditor != null) {\r\n            try {\r\n                IRegion jumpToRegion = AdapterFactory.locationToRegion(moduleEditor.getDocumentProvider().getDocument(moduleEditor.getEditorInput()), location);\r\n                UIHelper.getActivePage().activate(modelEditor);\r\n                modelEditor.setActiveEditor(moduleEditor);\r\n                moduleEditor.selectAndReveal(jumpToRegion.getOffset(), jumpToRegion.getLength());\r\n                return true;\r\n            } catch (BadLocationException e) {\r\n                TLCUIActivator.getDefault().logError(\"Error converting location to region in saved module. The location is \" + location, e);\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "teammates.ui.controller.InstructorCourseEnrollSaveAction.separateStudents",
	"Comment": "separate the studentdata objects in the list into different categories basedon their updatestatus. each category is put into a separate list.",
	"Method": "List<StudentAttributes>[] separateStudents(List<StudentAttributes> students){\r\n    ArrayList<StudentAttributes>[] lists = new ArrayList[StudentUpdateStatus.STATUS_COUNT];\r\n    for (int i = 0; i < StudentUpdateStatus.STATUS_COUNT; i++) {\r\n        lists[i] = new ArrayList();\r\n    }\r\n    for (StudentAttributes student : students) {\r\n        lists[student.updateStatus.numericRepresentation].add(student);\r\n    }\r\n    for (int i = 0; i < StudentUpdateStatus.STATUS_COUNT; i++) {\r\n        StudentAttributes.sortByNameAndThenByEmail(lists[i]);\r\n    }\r\n    return lists;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.PhysicalTypeIdentifier.isValid",
	"Comment": "indicates whether the given metadata id identifies a physical java type,in other words an interface, class, annotation, or enum.",
	"Method": "boolean isValid(String metadataIdentificationString){\r\n    return PhysicalTypeIdentifierNamingUtils.isValid(PHYSICAL_METADATA_TYPE, metadataIdentificationString);\r\n}"
}, {
	"Path": "org.springframework.roo.project.maven.Pom.getPropertiesExcludingValue",
	"Comment": "locates any properties which match the presented property, excluding thevalue. this is useful for upgrade use cases, where it is necessary tolocate any properties with the name so that they can be removed.",
	"Method": "Set<Property> getPropertiesExcludingValue(Property property){\r\n    Validate.notNull(property, \"Property to locate is required\");\r\n    final Set<Property> result = new HashSet<Property>();\r\n    for (final Property p : pomProperties) {\r\n        if (property.getName().equals(p.getName())) {\r\n            result.add(p);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.job.ProverJob.setUpStreamListening",
	"Comment": "this method sets up the mechanism for listening to the error and output streamsof the prover. it also sets the value of the field proverprocess.",
	"Method": "void setUpStreamListening(Process process,IProgressMonitor monitor){\r\n    if (process != null) {\r\n        synchronized (process.getInputStream()) {\r\n            synchronized (process.getErrorStream()) {\r\n                proverProcess = DebugPlugin.newProcess(launch, process, getName());\r\n                listener = new TLAPMBroadcastStreamListener(module, this, monitor);\r\n                listener.streamAppended(\"---------------- New Prover Launch --------------\\n\", null);\r\n                IStreamMonitor esMonitor = proverProcess.getStreamsProxy().getErrorStreamMonitor();\r\n                IStreamMonitor osMonitor = proverProcess.getStreamsProxy().getOutputStreamMonitor();\r\n                esMonitor.addListener(listener);\r\n                osMonitor.addListener(listener);\r\n                if (esMonitor instanceof IFlushableStreamMonitor && osMonitor instanceof IFlushableStreamMonitor) {\r\n                    ((IFlushableStreamMonitor) esMonitor).setBuffered(false);\r\n                    ((IFlushableStreamMonitor) osMonitor).setBuffered(false);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.containers.Data.sort",
	"Comment": "this is used to determine whether or not to keep lines in the data array. each line will be compared to the argument. if the line contains anything from the argument, it will not be removed from the data array.",
	"Method": "DATATYPE sort(DataSorting test,DATATYPE sort,String contains,DATATYPE sort,Integer start,DATATYPE sort,Integer start,Integer stop){\r\n    if (size() > 0) {\r\n        List<String> list = new ArrayList<String>();\r\n        Integer begin = start < 0 ? (mLines.length + start) : start;\r\n        Integer end = stop < 0 ? (mLines.length + stop) : stop;\r\n        Integer[] min = null, max = null;\r\n        if (begin > end) {\r\n            if (end == 0) {\r\n                min = new Integer[] { begin };\r\n                max = new Integer[] { mLines.length };\r\n            } else {\r\n                min = new Integer[] { 0, begin };\r\n                max = new Integer[] { end, mLines.length };\r\n            }\r\n        } else {\r\n            min = new Integer[] { begin };\r\n            max = new Integer[] { end };\r\n        }\r\n        for (int i = 0; i < min.length; i++) {\r\n            for (int x = min[i]; x < max[i]; x++) {\r\n                list.add(mLines[x]);\r\n            }\r\n        }\r\n        mLines = list.toArray(new String[list.size()]);\r\n    }\r\n    return (DATATYPE) this;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.output.source.TLCOutputSourceRegistry.addTLCOutputSource",
	"Comment": "adds a source. if the source with the same identity is already present,reconnect the the listeners, iff there are any at place and the prio of the new source is higherthat the one of the old one.",
	"Method": "void addTLCOutputSource(ITLCOutputSource source){\r\n    Assert.isNotNull(source);\r\n    ITLCOutputSource existingSource = this.sources.get(source.getModel());\r\n    if (existingSource != null && source.getSourcePrio() >= existingSource.getSourcePrio()) {\r\n        ITLCOutputListener[] registered = existingSource.getListeners();\r\n        for (int i = 0; i < registered.length; i++) {\r\n            existingSource.removeTLCOutputListener(registered[i]);\r\n            source.addTLCOutputListener(registered[i]);\r\n            registered[i].onNewSource();\r\n        }\r\n    } else {\r\n        if (existingSource == null) {\r\n            TLCModelLaunchDataProvider provider = providers.get(source.getModel());\r\n            if (provider != null) {\r\n                source.addTLCOutputListener(provider);\r\n            }\r\n        }\r\n    }\r\n    this.sources.put(source.getModel(), source);\r\n    printStats();\r\n}"
}, {
	"Path": "tlc2.tool.ModelChecker.doNext",
	"Comment": "compute the set of the next states.for each next state, check thatit is a valid state, check that the invariants are satisfied, checkthat it satisfies the constraints, and enqueue it in the state queue.return true if the model checking should stop.this method is called from the workers on every step",
	"Method": "boolean doNext(TLCState curState,ObjLongTable<SemanticNode> counts,Worker worker){\r\n    if (this.cancellationFlag) {\r\n        return false;\r\n    }\r\n    boolean deadLocked = true;\r\n    TLCState succState = null;\r\n    SetOfStates liveNextStates = null;\r\n    int unseenSuccessorStates = 0;\r\n    if (this.checkLiveness) {\r\n        liveNextStates = new SetOfStates(INITIAL_CAPACITY * threadLocal.get());\r\n    }\r\n    try {\r\n        int k = 0;\r\n        for (int i = 0; i < this.actions.length; i++) {\r\n            if (this.cancellationFlag) {\r\n                return false;\r\n            }\r\n            StateVec nextStates = this.tool.getNextStates(this.actions[i], curState);\r\n            int sz = nextStates.size();\r\n            worker.incrementStatesGenerated(sz);\r\n            deadLocked = deadLocked && (sz == 0);\r\n            SUCCESSORS: for (int j = 0; j < sz; j++) {\r\n                succState = nextStates.elementAt(j);\r\n                succState.level = (short) ((short) 1 + curState.level);\r\n                assert succState.level >= 1;\r\n                if (!this.tool.isGoodState(succState)) {\r\n                    synchronized (this) {\r\n                        if (this.setErrState(curState, succState, false)) {\r\n                            final Set<OpDeclNode> unassigned = succState.getUnassigned();\r\n                            if (this.actions.length == 1) {\r\n                                MP.printError(EC.TLC_STATE_NOT_COMPLETELY_SPECIFIED_NEXT, new String[] { unassigned.size() > 1 ? \"s are\" : \" is\", unassigned.stream().map(n -> n.getName().toString()).collect(Collectors.joining(\", \")) });\r\n                            } else {\r\n                                MP.printError(EC.TLC_STATE_NOT_COMPLETELY_SPECIFIED_NEXT, new String[] { this.actions[i].getName().toString(), unassigned.size() > 1 ? \"s are\" : \" is\", unassigned.stream().map(n -> n.getName().toString()).collect(Collectors.joining(\", \")) });\r\n                            }\r\n                            this.trace.printTrace(curState, succState);\r\n                            this.theStateQueue.finishAll();\r\n                            this.notify();\r\n                        }\r\n                        return true;\r\n                    }\r\n                }\r\n                if (TLCGlobals.isCoverageEnabled()) {\r\n                    ((TLCStateMutSource) succState).addCounts(counts);\r\n                }\r\n                final boolean inModel = (this.tool.isInModel(succState) && this.tool.isInActions(curState, succState));\r\n                boolean seen = false;\r\n                if (inModel) {\r\n                    long fp = succState.fingerPrint();\r\n                    seen = this.theFPSet.put(fp);\r\n                    this.allStateWriter.writeState(curState, succState, !seen, this.actions[i]);\r\n                    if (!seen) {\r\n                        worker.writeState(curState, fp, succState);\r\n                        unseenSuccessorStates++;\r\n                    }\r\n                    if (this.checkLiveness) {\r\n                        liveNextStates.put(fp, succState);\r\n                    }\r\n                }\r\n                if (!seen) {\r\n                    try {\r\n                        int len = this.invariants.length;\r\n                        INVARIANTS: for (k = 0; k < len; k++) {\r\n                            if (this.cancellationFlag) {\r\n                                return false;\r\n                            }\r\n                            if (!tool.isValid(this.invariants[k], succState)) {\r\n                                synchronized (this) {\r\n                                    if (TLCGlobals.continuation) {\r\n                                        MP.printError(EC.TLC_INVARIANT_VIOLATED_BEHAVIOR, this.tool.getInvNames()[k]);\r\n                                        this.trace.printTrace(curState, succState);\r\n                                        break INVARIANTS;\r\n                                    } else {\r\n                                        if (this.setErrState(curState, succState, false)) {\r\n                                            MP.printError(EC.TLC_INVARIANT_VIOLATED_BEHAVIOR, this.tool.getInvNames()[k]);\r\n                                            this.trace.printTrace(curState, succState);\r\n                                            this.theStateQueue.finishAll();\r\n                                            this.notify();\r\n                                        }\r\n                                        return true;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        if (k < len) {\r\n                            if (inModel && !seen) {\r\n                                this.theStateQueue.sEnqueue(succState);\r\n                            }\r\n                            continue SUCCESSORS;\r\n                        }\r\n                    } catch (Exception e) {\r\n                        synchronized (this) {\r\n                            if (this.setErrState(curState, succState, true)) {\r\n                                MP.printError(EC.TLC_INVARIANT_EVALUATION_FAILED, new String[] { this.tool.getInvNames()[k], (e.getMessage() == null) ? e.toString() : e.getMessage() });\r\n                                this.trace.printTrace(curState, succState);\r\n                                this.theStateQueue.finishAll();\r\n                                this.notify();\r\n                            }\r\n                            throw e;\r\n                        }\r\n                    }\r\n                }\r\n                try {\r\n                    int len = this.impliedActions.length;\r\n                    IMPLIED: for (k = 0; k < len; k++) {\r\n                        if (this.cancellationFlag) {\r\n                            return false;\r\n                        }\r\n                        if (!tool.isValid(this.impliedActions[k], curState, succState)) {\r\n                            synchronized (this) {\r\n                                if (TLCGlobals.continuation) {\r\n                                    MP.printError(EC.TLC_ACTION_PROPERTY_VIOLATED_BEHAVIOR, this.tool.getImpliedActNames()[k]);\r\n                                    this.trace.printTrace(curState, succState);\r\n                                    break IMPLIED;\r\n                                } else {\r\n                                    if (this.setErrState(curState, succState, false)) {\r\n                                        MP.printError(EC.TLC_ACTION_PROPERTY_VIOLATED_BEHAVIOR, this.tool.getImpliedActNames()[k]);\r\n                                        this.trace.printTrace(curState, succState);\r\n                                        this.theStateQueue.finishAll();\r\n                                        this.notify();\r\n                                    }\r\n                                    return true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (k < len) {\r\n                        if (inModel && !seen) {\r\n                            this.theStateQueue.sEnqueue(succState);\r\n                        }\r\n                        continue SUCCESSORS;\r\n                    }\r\n                } catch (Exception e) {\r\n                    synchronized (this) {\r\n                        if (this.setErrState(curState, succState, true)) {\r\n                            MP.printError(EC.TLC_ACTION_PROPERTY_EVALUATION_FAILED, new String[] { this.tool.getImpliedActNames()[k], (e.getMessage() == null) ? e.toString() : e.getMessage() });\r\n                            this.trace.printTrace(curState, succState);\r\n                            this.theStateQueue.finishAll();\r\n                            this.notify();\r\n                        }\r\n                        throw e;\r\n                    }\r\n                }\r\n                if (inModel && !seen) {\r\n                    this.theStateQueue.sEnqueue(succState);\r\n                }\r\n            }\r\n            succState = null;\r\n        }\r\n        if (deadLocked && this.checkDeadlock) {\r\n            synchronized (this) {\r\n                if (this.setErrState(curState, null, false)) {\r\n                    MP.printError(EC.TLC_DEADLOCK_REACHED);\r\n                    this.trace.printTrace(curState, null);\r\n                    this.theStateQueue.finishAll();\r\n                    this.notify();\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        if (this.checkLiveness) {\r\n            final long curStateFP = curState.fingerPrint();\r\n            liveNextStates.put(curStateFP, curState);\r\n            this.allStateWriter.writeState(curState, curState, true, IStateWriter.Visualization.STUTTERING);\r\n            liveCheck.addNextState(curState, curStateFP, liveNextStates);\r\n            final int multiplier = threadLocal.get();\r\n            if (liveNextStates.capacity() > (multiplier * INITIAL_CAPACITY)) {\r\n                threadLocal.set(multiplier + 1);\r\n            }\r\n        }\r\n        worker.setOutDegree(unseenSuccessorStates);\r\n        return false;\r\n    } catch (Throwable e) {\r\n        boolean keep = ((e instanceof StackOverflowError) || (e instanceof OutOfMemoryError) || (e instanceof AssertionError));\r\n        synchronized (this) {\r\n            if (this.setErrState(curState, succState, !keep)) {\r\n                if (e instanceof StackOverflowError) {\r\n                    MP.printError(EC.SYSTEM_STACK_OVERFLOW, e);\r\n                } else if (e instanceof OutOfMemoryError) {\r\n                    MP.printError(EC.SYSTEM_OUT_OF_MEMORY, e);\r\n                } else if (e instanceof AssertionError) {\r\n                    MP.printError(EC.TLC_BUG, e);\r\n                } else if (e.getMessage() != null) {\r\n                    MP.printError(EC.GENERAL, e);\r\n                }\r\n                this.trace.printTrace(curState, succState);\r\n                this.theStateQueue.finishAll();\r\n                this.notify();\r\n            }\r\n        }\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "teammates.logic.core.CoursesLogic.createCourseAndInstructor",
	"Comment": "creates a course object and an instructor object for the course.",
	"Method": "void createCourseAndInstructor(String instructorGoogleId,String courseId,String courseName,String courseTimeZone){\r\n    AccountAttributes courseCreator = accountsLogic.getAccount(instructorGoogleId);\r\n    Assumption.assertNotNull(\"Trying to create a course for a non-existent instructor :\" + instructorGoogleId, courseCreator);\r\n    Assumption.assertTrue(\"Trying to create a course for a person who doesn't have instructor privileges :\" + instructorGoogleId, courseCreator.isInstructor);\r\n    createCourse(courseId, courseName, courseTimeZone);\r\n    InstructorPrivileges privileges = new InstructorPrivileges(Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_COOWNER);\r\n    InstructorAttributes instructor = InstructorAttributes.builder(instructorGoogleId, courseId, courseCreator.name, courseCreator.email).withPrivileges(privileges).build();\r\n    try {\r\n        instructorsLogic.createInstructor(instructor);\r\n    } catch (EntityAlreadyExistsException | InvalidParametersException e) {\r\n        coursesDb.deleteCourse(courseId);\r\n        String errorMessage = \"Unexpected exception while trying to create instructor for a new course \" + System.lineSeparator() + instructor.toString() + System.lineSeparator() + TeammatesException.toStringWithStackTrace(e);\r\n        Assumption.fail(errorMessage);\r\n    }\r\n}"
}, {
	"Path": "pcal.TLAtoPCalMapping.makeMapping",
	"Comment": "sets the mapping field to an array version of mapvec, which must be a vector of vectors of mappingobjects.",
	"Method": "void makeMapping(Vector<Vector<MappingObject>> mapVec){\r\n    this.mapping = new MappingObject[mapVec.size()][];\r\n    for (int i = 0; i < this.mapping.length; i++) {\r\n        Vector<MappingObject> line = mapVec.elementAt(i);\r\n        this.mapping[i] = new MappingObject[line.size()];\r\n        for (int j = 0; j < line.size(); j++) {\r\n            this.mapping[i][j] = line.elementAt(j);\r\n        }\r\n    }\r\n    return;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.output.data.ObligationStatus.updateObligation",
	"Comment": "updates the obligation with informationfrom the message. in particular, this updatesthe state of the obligation and set the prettyprinted form of the obligation if that informationis in the message.if the state of this obligation changes because of the message,this method updates the status of the parent.",
	"Method": "void updateObligation(ObligationStatusMessage message){\r\n    String oldStatusOnBackend = (String) proverStatuses.get(message.getBackend());\r\n    if (oldStatusOnBackend != null && oldStatusOnBackend.equals(ProverHelper.PROVED)) {\r\n        return;\r\n    }\r\n    if (this.obligationString == null || this.obligationString.length() == 0) {\r\n        this.obligationString = message.getObString();\r\n    }\r\n    if (message.getBackend() != null && message.getStatus() != null) {\r\n        proverStatuses.put(message.getBackend(), message.getStatus());\r\n    }\r\n    if (message.getBackend() != null && message.getReason() != null) {\r\n        proverReasons.put(message.getBackend(), message.getReason());\r\n    }\r\n    int oldState = getObligationState();\r\n    int newState = ProverHelper.getIntFromStringStatus(message.getStatus(), oldState, message.getBackend());\r\n    if (oldState != newState) {\r\n        obState = newState;\r\n        parent.updateStatus();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.ReflectionUtils.getAllDeclaredMethods",
	"Comment": "get all declared methods on the leaf class and all superclasses. leafclass methods are included first.",
	"Method": "Method[] getAllDeclaredMethods(Class<?> leafClass){\r\n    final List<Method> methods = new ArrayList<Method>(32);\r\n    doWithMethods(leafClass, new MethodCallback() {\r\n        public void doWith(final Method method) {\r\n            methods.add(method);\r\n        }\r\n    });\r\n    return methods.toArray(new Method[methods.size()]);\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.ReflectionUtils.getAllDeclaredMethods",
	"Comment": "get all declared methods on the leaf class and all superclasses. leafclass methods are included first.",
	"Method": "Method[] getAllDeclaredMethods(Class<?> leafClass){\r\n    methods.add(method);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.job.ProverJobRule.isConflicting",
	"Comment": "any job with an instance of this rule cannotbe run at the same time.",
	"Method": "boolean isConflicting(ISchedulingRule rule){\r\n    return rule instanceof ProverJobRule;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.WsOperationsImpl.includeDependenciesAndPluginsForWsClient",
	"Comment": "this method includes the tracee and cxf dependencies and includes the cxfcodegen plugin with the necessary configuration for the new wsclient.",
	"Method": "void includeDependenciesAndPluginsForWsClient(String wsdlName,String wsdlModuleName){\r\n    getProjectOperations().addProperty(\"\", CXF_PROPERTY);\r\n    getProjectOperations().addDependency(wsdlModuleName, CXF_RT_FRONTEND_JAXWS_DEPENDENCY);\r\n    getProjectOperations().addDependency(wsdlModuleName, CXF_RT_TRANSPORTS_HTTP_DEPENDENCY);\r\n    getProjectOperations().addProperty(\"\", TRACEE_PROPERTY);\r\n    getProjectOperations().addDependency(wsdlModuleName, TRACEE_CXF_DEPENDENCY);\r\n    final Element configuration = XmlUtils.getConfiguration(getClass());\r\n    final List<Element> plugins = XmlUtils.findElements(\"/configuration/plugins/plugin\", configuration);\r\n    Plugin cxfPlugin = null;\r\n    for (final Element pluginElement : plugins) {\r\n        cxfPlugin = new Plugin(pluginElement);\r\n        getProjectOperations().addBuildPlugin(wsdlModuleName, cxfPlugin);\r\n        break;\r\n    }\r\n    Map<String, String> wsdlLocationProperties = new HashMap<String, String>();\r\n    wsdlLocationProperties.put(\"wsdl\", \"${project.basedir}/src/main/resources/\" + wsdlName);\r\n    wsdlLocationProperties.put(\"wsdlLocation\", \"classpath:\" + wsdlName);\r\n    getProjectOperations().addElementToPluginExecution(wsdlModuleName, cxfPlugin, \"generate-sources\", \"wsdlOptions\", \"wsdlOption\", wsdlLocationProperties);\r\n}"
}, {
	"Path": "tlc2.tool.liveness.LiveExprNode.toDNF",
	"Comment": "the method todnf turns a liveexprnode into disjunctive normal form.",
	"Method": "LiveExprNode toDNF(){\r\n    return this;\r\n}"
}, {
	"Path": "tlc2.tool.distributed.fp.DynamicFPSetManagerTest.testCtor1",
	"Comment": "test that the ctor correctly calculates its mask used to index fpset\tservers for valid values.",
	"Method": "void testCtor1(){\r\n    DynamicFPSetManager dynamicFPSetManager = new DynamicFPSetManager(1);\r\n    long mask = dynamicFPSetManager.getMask();\r\n    assertEquals(1L, mask);\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.plugins.thumbsdb.ThumbsDBImageReader.setLoadEagerly",
	"Comment": "instructs the reader wether it should read and cache alle thumbnailsin sequence, during the first read operation.this is useful mainly if you need to read all the thumbnails, and youneed them in random order, as it requires less repositioning in theunderlying stream.",
	"Method": "void setLoadEagerly(boolean pLoadEagerly){\r\n    loadEagerly = pLoadEagerly;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.model.Model.getTargetDirectory",
	"Comment": "retrieves the working directory for the model. returns null if the model has\tnot run yet. in other words, gets created by running tlc.\tnote, this is a handle operation only, the resource returned may not exist",
	"Method": "IFolder getTargetDirectory(){\r\n    return (IFolder) getSpec().getProject().findMember(getName());\r\n}"
}, {
	"Path": "tla2sany.semantic.Context.getVariableDecls",
	"Comment": "returns vector of opdeclnodes that represent constant declarations",
	"Method": "Vector<SemanticNode> getVariableDecls(){\r\n    Class<? extends SemanticNode> templateClass = OpDeclNode.class;\r\n    Enumeration<Pair> list = table.elements();\r\n    Vector<SemanticNode> result = new Vector();\r\n    while (list.hasMoreElements()) {\r\n        Pair elt = list.nextElement();\r\n        if (templateClass.isInstance(elt.info) && ((OpDeclNode) elt.info).getKind() == ASTConstants.VariableDeclKind)\r\n            result.addElement((SemanticNode) (elt.info));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.hide",
	"Comment": "animates the actionbutton off of the screen. animation will go from its current position anddown until it is no longer being shown to the user.",
	"Method": "void hide(){\r\n    if (!isShowing) {\r\n        return;\r\n    }\r\n    isShowing = false;\r\n    if (true) {\r\n        ObjectAnimator animator = ObjectAnimator.ofFloat(this, View.ALPHA, 1.0f, 0.0f);\r\n        animator.setDuration(fadeAnimationTime);\r\n        animator.start();\r\n    } else {\r\n        if (showTitle) {\r\n            title.setVisibility(View.INVISIBLE);\r\n            ObjectAnimator animator = ObjectAnimator.ofFloat(title, View.ALPHA, FINAL_TITLE_ALPHA, 0.0f);\r\n            animator.setDuration(fadeAnimationTime);\r\n            animator.start();\r\n        }\r\n        content.setVisibility(View.INVISIBLE);\r\n        ObjectAnimator animator = ObjectAnimator.ofFloat(content, View.ALPHA, 1.0f, 0.0f);\r\n        animator.setDuration(fadeAnimationTime);\r\n        animator.addListener(new Animator.AnimatorListener() {\r\n            @Override\r\n            public void onAnimationStart(Animator animation) {\r\n            }\r\n            @Override\r\n            public void onAnimationEnd(Animator animation) {\r\n                content.setVisibility(View.GONE);\r\n            }\r\n            @Override\r\n            public void onAnimationCancel(Animator animation) {\r\n            }\r\n            @Override\r\n            public void onAnimationRepeat(Animator animation) {\r\n            }\r\n        });\r\n        animator.start();\r\n        new Handler().postDelayed(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                ObjectAnimator alpha = ObjectAnimator.ofFloat(PopupLayout.this, View.ALPHA, 1.0f, 0f);\r\n                final ObjectAnimator xTranslation = ObjectAnimator.ofFloat(PopupLayout.this, View.TRANSLATION_X, distanceFromLeft, animStartLeft);\r\n                ObjectAnimator yTranslation = ObjectAnimator.ofFloat(PopupLayout.this, View.TRANSLATION_Y, distanceFromTop, animStartTop);\r\n                final ValueAnimator widthExpander = ValueAnimator.ofInt(width, 0);\r\n                ValueAnimator heightExpander = ValueAnimator.ofInt(height, Utils.toDP(5, getContext()));\r\n                widthExpander.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r\n                    @Override\r\n                    public void onAnimationUpdate(ValueAnimator valueAnimator) {\r\n                        int val = (Integer) valueAnimator.getAnimatedValue();\r\n                        ViewGroup.LayoutParams layoutParams = getLayoutParams();\r\n                        layoutParams.width = val;\r\n                        setLayoutParams(layoutParams);\r\n                    }\r\n                });\r\n                widthExpander.setDuration(realAnimationTime);\r\n                widthExpander.setInterpolator(INTERPOLATOR);\r\n                heightExpander.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r\n                    @Override\r\n                    public void onAnimationUpdate(ValueAnimator valueAnimator) {\r\n                        int val = (Integer) valueAnimator.getAnimatedValue();\r\n                        ViewGroup.LayoutParams layoutParams = getLayoutParams();\r\n                        layoutParams.height = val;\r\n                        setLayoutParams(layoutParams);\r\n                    }\r\n                });\r\n                heightExpander.setDuration(realAnimationTime);\r\n                heightExpander.setInterpolator(INTERPOLATOR);\r\n                xTranslation.setDuration(realAnimationTime);\r\n                xTranslation.setInterpolator(INTERPOLATOR);\r\n                yTranslation.setDuration(realAnimationTime);\r\n                yTranslation.setInterpolator(INTERPOLATOR);\r\n                alpha.setDuration(realAnimationTime);\r\n                alpha.setInterpolator(INTERPOLATOR);\r\n                alpha.start();\r\n                yTranslation.start();\r\n                heightExpander.start();\r\n                xTranslation.start();\r\n                widthExpander.start();\r\n                new Handler().postDelayed(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                    }\r\n                }, shortAnimationTime);\r\n            }\r\n        }, fadeAnimationTime + 100);\r\n    }\r\n    ObjectAnimator dimAnimator = ObjectAnimator.ofFloat(dim, View.ALPHA, FINAL_DIM_ALPHA, 0.0f);\r\n    dimAnimator.setDuration(fadeAnimationTime);\r\n    dimAnimator.start();\r\n    new Handler().postDelayed(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            parent.removeView(PopupLayout.this);\r\n            parent.removeView(dim);\r\n        }\r\n    }, realAnimationTime + 100);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.hide",
	"Comment": "animates the actionbutton off of the screen. animation will go from its current position anddown until it is no longer being shown to the user.",
	"Method": "void hide(){\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.hide",
	"Comment": "animates the actionbutton off of the screen. animation will go from its current position anddown until it is no longer being shown to the user.",
	"Method": "void hide(){\r\n    content.setVisibility(View.GONE);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.hide",
	"Comment": "animates the actionbutton off of the screen. animation will go from its current position anddown until it is no longer being shown to the user.",
	"Method": "void hide(){\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.hide",
	"Comment": "animates the actionbutton off of the screen. animation will go from its current position anddown until it is no longer being shown to the user.",
	"Method": "void hide(){\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.hide",
	"Comment": "animates the actionbutton off of the screen. animation will go from its current position anddown until it is no longer being shown to the user.",
	"Method": "void hide(){\r\n    ObjectAnimator alpha = ObjectAnimator.ofFloat(PopupLayout.this, View.ALPHA, 1.0f, 0f);\r\n    final ObjectAnimator xTranslation = ObjectAnimator.ofFloat(PopupLayout.this, View.TRANSLATION_X, distanceFromLeft, animStartLeft);\r\n    ObjectAnimator yTranslation = ObjectAnimator.ofFloat(PopupLayout.this, View.TRANSLATION_Y, distanceFromTop, animStartTop);\r\n    final ValueAnimator widthExpander = ValueAnimator.ofInt(width, 0);\r\n    ValueAnimator heightExpander = ValueAnimator.ofInt(height, Utils.toDP(5, getContext()));\r\n    widthExpander.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r\n        @Override\r\n        public void onAnimationUpdate(ValueAnimator valueAnimator) {\r\n            int val = (Integer) valueAnimator.getAnimatedValue();\r\n            ViewGroup.LayoutParams layoutParams = getLayoutParams();\r\n            layoutParams.width = val;\r\n            setLayoutParams(layoutParams);\r\n        }\r\n    });\r\n    widthExpander.setDuration(realAnimationTime);\r\n    widthExpander.setInterpolator(INTERPOLATOR);\r\n    heightExpander.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r\n        @Override\r\n        public void onAnimationUpdate(ValueAnimator valueAnimator) {\r\n            int val = (Integer) valueAnimator.getAnimatedValue();\r\n            ViewGroup.LayoutParams layoutParams = getLayoutParams();\r\n            layoutParams.height = val;\r\n            setLayoutParams(layoutParams);\r\n        }\r\n    });\r\n    heightExpander.setDuration(realAnimationTime);\r\n    heightExpander.setInterpolator(INTERPOLATOR);\r\n    xTranslation.setDuration(realAnimationTime);\r\n    xTranslation.setInterpolator(INTERPOLATOR);\r\n    yTranslation.setDuration(realAnimationTime);\r\n    yTranslation.setInterpolator(INTERPOLATOR);\r\n    alpha.setDuration(realAnimationTime);\r\n    alpha.setInterpolator(INTERPOLATOR);\r\n    alpha.start();\r\n    yTranslation.start();\r\n    heightExpander.start();\r\n    xTranslation.start();\r\n    widthExpander.start();\r\n    new Handler().postDelayed(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n        }\r\n    }, shortAnimationTime);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.hide",
	"Comment": "animates the actionbutton off of the screen. animation will go from its current position anddown until it is no longer being shown to the user.",
	"Method": "void hide(){\r\n    int val = (Integer) valueAnimator.getAnimatedValue();\r\n    ViewGroup.LayoutParams layoutParams = getLayoutParams();\r\n    layoutParams.width = val;\r\n    setLayoutParams(layoutParams);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.hide",
	"Comment": "animates the actionbutton off of the screen. animation will go from its current position anddown until it is no longer being shown to the user.",
	"Method": "void hide(){\r\n    int val = (Integer) valueAnimator.getAnimatedValue();\r\n    ViewGroup.LayoutParams layoutParams = getLayoutParams();\r\n    layoutParams.height = val;\r\n    setLayoutParams(layoutParams);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.hide",
	"Comment": "animates the actionbutton off of the screen. animation will go from its current position anddown until it is no longer being shown to the user.",
	"Method": "void hide(){\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.hide",
	"Comment": "animates the actionbutton off of the screen. animation will go from its current position anddown until it is no longer being shown to the user.",
	"Method": "void hide(){\r\n    parent.removeView(PopupLayout.this);\r\n    parent.removeView(dim);\r\n}"
}, {
	"Path": "tla2sany.st.Location.equals",
	"Comment": "returns true if object is an instance of locationand has the same begin line, begin column, end line,end column, and module name.",
	"Method": "boolean equals(Object object){\r\n    if (object instanceof Location) {\r\n        Location loc = (Location) object;\r\n        return loc.bLine == bLine && loc.bColumn == bColumn && loc.eLine == eLine && loc.eColumn == eColumn && loc.source().equals(source());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.roo.project.maven.Pom.getProperty",
	"Comment": "locates the first occurrence of a property for a given name and returns",
	"Method": "Property getProperty(String name){\r\n    Validate.notBlank(name, \"Property name to locate is required\");\r\n    for (final Property p : pomProperties) {\r\n        if (name.equals(p.getName())) {\r\n            return p;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "teammates.test.driver.HtmlHelper.convertToStandardHtml",
	"Comment": "transform the html text to follow a standard format.element attributes are reordered in alphabetical order.spacing and line breaks are standardized too.",
	"Method": "String convertToStandardHtml(String rawHtml,boolean isPart){\r\n    try {\r\n        Node documentNode = getNodeFromString(rawHtml);\r\n        String initialIndentation = \"\";\r\n        return getNodeContent(documentNode, initialIndentation, isPart);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "teammates.ui.template.StudentFeedbackResultsQuestionWithResponses.getSelfResponseTables",
	"Comment": "returns a list of responses which are provided by user himself.",
	"Method": "List<FeedbackResultsResponseTable> getSelfResponseTables(){\r\n    return responseTables.stream().filter(responseTable -> responseTable.isGiverNameYou()).collect(Collectors.toList());\r\n}"
}, {
	"Path": "tlc2.util.StatePoolWriter.doWork",
	"Comment": "this method first completes the preceding write if not started.it then notifies this writer to flush enqbuf to file. in practice,we expect the preceding write to have been completed.",
	"Method": "TLCState[] doWork(TLCState[] enqBuf,File file){\r\n    if (this.poolFile != null) {\r\n        ValueOutputStream vos = new ValueOutputStream(this.poolFile);\r\n        for (int i = 0; i < this.buf.length; i++) {\r\n            this.buf[i].write(vos);\r\n        }\r\n        vos.close();\r\n    }\r\n    TLCState[] res = this.buf;\r\n    this.buf = enqBuf;\r\n    this.poolFile = file;\r\n    this.notify();\r\n    return res;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.util.ModelHelper.hasConstant",
	"Comment": "checks whether the constant defined by assignment is defined in the module node",
	"Method": "boolean hasConstant(Assignment assignment,ModuleNode moduleNode){\r\n    OpDeclNode[] constantDecls = moduleNode.getConstantDecls();\r\n    for (int i = 0; i < constantDecls.length; i++) {\r\n        if (assignment.getLabel().equals(constantDecls[i].getName().toString()) && assignment.getParams().length == constantDecls[i].getNumberOfArgs()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.roo.project.maven.Pom.asDependency",
	"Comment": "returns this module as a dependency with the given scope and type",
	"Method": "Dependency asDependency(DependencyScope scope,Dependency asDependency,DependencyScope scope,DependencyType type){\r\n    return new Dependency(gav, type, scope);\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackQuestionsDb.getFeedbackQuestionEntity",
	"Comment": "gets a feedbackquestion based on feedbacksessionname and questionnumber.",
	"Method": "FeedbackQuestion getFeedbackQuestionEntity(String feedbackQuestionId,FeedbackQuestion getFeedbackQuestionEntity,String feedbackSessionName,String courseId,int questionNumber){\r\n    return load().filter(\"feedbackSessionName =\", feedbackSessionName).filter(\"courseId =\", courseId).filter(\"questionNumber =\", questionNumber).first().now();\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackEditPage.clickVisibilityDropdownForNewQuestionAndWaitForVisibilityMessageToLoad",
	"Comment": "selects the visibility option and waits for the visibility message to load for the new question.",
	"Method": "void clickVisibilityDropdownForNewQuestionAndWaitForVisibilityMessageToLoad(String optionValue){\r\n    clickVisibilityDropdownAndWaitForVisibilityMessageToLoad(optionValue, NEW_QUESTION_NUM);\r\n}"
}, {
	"Path": "org.springframework.roo.shell.SimpleParserTest.assertNormalised",
	"Comment": "asserts that normalising the given input produces the given output",
	"Method": "void assertNormalised(String input,String output){\r\n    Assert.assertEquals(output, simpleParser.normalise(input));\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.editor.ModelEditor.getValidateRunnable",
	"Comment": "returns the validaterunnable so that the pagescan be validated by code outside of this class.",
	"Method": "ValidateRunnable getValidateRunnable(){\r\n    return validateRunable;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.itd.AbstractItdTypeDetailsProvidingMetadataItem.hasToExcludeMethod",
	"Comment": "checks if required method is declared to be exclude from generation",
	"Method": "boolean hasToExcludeMethod(MethodMetadataBuilder methodMetadata){\r\n    return excludeMethods.contains(methodMetadata.getMethodName().getSymbolName());\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorHomePageData.getSessionResendPublishedEmailLink",
	"Comment": "retrieves the link to submit the request for resending the session published email.also contains home page link to return to after the action.",
	"Method": "String getSessionResendPublishedEmailLink(){\r\n    return getInstructorFeedbackResendPublishedEmailLink(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.FeedbackQuestionAttributes.getFeedbackQuestionDetailsClass",
	"Comment": "this method gets the appropriate class type for the feedbackquestiondetails object for this question.",
	"Method": "Class<? extends FeedbackQuestionDetails> getFeedbackQuestionDetailsClass(){\r\n    return questionType.getQuestionDetailsClass();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tla2tex.handler.ProducePDFHandler.runPDFJob",
	"Comment": "this method schedules a long running job that runs tla2tex on the file to\ttranslate and loads it in the browser that is part of the second tab of\tthe tlaeditorandpdfviewer.\tit is done as a long running job so that the ui thread is not locked\twhile tla2tex runs.\tthis handles any unrecoverable error in tla2tex translation and presents\tit to the user as an error message.\tif the user has the pdf file in the .toolbox directory open in another\tprogram, then the toolbox will show a warning stating that the new pdf\tfile could not be created. it will display the old, unmodified pdf file\tto the user.",
	"Method": "void runPDFJob(AbstractPDFViewerRunnable runnable,IResource fileToTranslate){\r\n    Job tla2TexJob = new WorkspaceJob(\"Produce PDF\") {\r\n        public IStatus runInWorkspace(final IProgressMonitor monitor) {\r\n            try {\r\n                Vector<String> tla2texArgs = new Vector<String>();\r\n                IPreferenceStore preferenceStore = TLA2TeXActivator.getDefault().getPreferenceStore();\r\n                if (preferenceStore.getBoolean(ITLA2TeXPreferenceConstants.SHADE_COMMENTS)) {\r\n                    tla2texArgs.add(\"-shade\");\r\n                    tla2texArgs.add(\"-nops\");\r\n                }\r\n                if (preferenceStore.getBoolean(ITLA2TeXPreferenceConstants.NO_PCAL_SHADE)) {\r\n                    tla2texArgs.add(\"-noPcalShade\");\r\n                }\r\n                if (preferenceStore.getBoolean(ITLA2TeXPreferenceConstants.NUMBER_LINES)) {\r\n                    tla2texArgs.add(\"-number\");\r\n                }\r\n                tla2texArgs.add(\"-latexCommand\");\r\n                String latexCommand = preferenceStore.getString(ITLA2TeXPreferenceConstants.LATEX_COMMAND);\r\n                tla2texArgs.add(latexCommand);\r\n                tla2texArgs.add(\"-grayLevel\");\r\n                tla2texArgs.add(Double.toString(preferenceStore.getDouble(ITLA2TeXPreferenceConstants.GRAY_LEVEL)));\r\n                tla2texArgs.add(\"-latexOutputExt\");\r\n                tla2texArgs.add(TLA2TeX_Output_Extension);\r\n                tla2texArgs.add(\"-metadir\");\r\n                tla2texArgs.add(fileToTranslate.getProject().getLocation().toOSString());\r\n                tla2texArgs.add(fileToTranslate.getLocation().toOSString());\r\n                monitor.beginTask(\"Producing PDF\", 2);\r\n                monitor.subTask(\"Translating Module\");\r\n                TLA.runTranslation((String[]) tla2texArgs.toArray(new String[tla2texArgs.size()]));\r\n                fileToTranslate.getProject().refreshLocal(IResource.DEPTH_INFINITE, monitor);\r\n                monitor.worked(1);\r\n                final String outputFileName = fileToTranslate.getProject().getLocation().toOSString() + File.separator + ResourceHelper.getModuleName(fileToTranslate) + \".\" + TLA2TeX_Output_Extension;\r\n                final File outputFile = new File(outputFileName);\r\n                if (outputFile.exists()) {\r\n                    runnable.setFile(outputFileName);\r\n                    runnable.setMonitor(monitor);\r\n                    UIHelper.runUISync(runnable);\r\n                } else {\r\n                    UIHelper.runUISync(new Runnable() {\r\n                        public void run() {\r\n                            MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"PDF file not found\", \"Could not locate a pdf file for the module.\");\r\n                        }\r\n                    });\r\n                }\r\n            } catch (final TLA2TexException e) {\r\n                TLA2TeXActivator.getDefault().logError(\"Error while producing pdf file: \" + e.getMessage(), e);\r\n                UIHelper.runUISync(new Runnable() {\r\n                    public void run() {\r\n                        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"PDF Production Error\", e.getMessage());\r\n                    }\r\n                });\r\n            } catch (final CoreException e) {\r\n                TLA2TeXActivator.getDefault().logError(\"Error while producing pdf file: \" + e.getMessage(), e);\r\n                UIHelper.runUISync(new Runnable() {\r\n                    public void run() {\r\n                        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"PDF Production Error\", e.getMessage());\r\n                    }\r\n                });\r\n            } finally {\r\n            }\r\n            return Status.OK_STATUS;\r\n        }\r\n    };\r\n    tla2TexJob.setUser(false);\r\n    tla2TexJob.setPriority(Job.LONG);\r\n    tla2TexJob.schedule();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tla2tex.handler.ProducePDFHandler.runPDFJob",
	"Comment": "this method schedules a long running job that runs tla2tex on the file to\ttranslate and loads it in the browser that is part of the second tab of\tthe tlaeditorandpdfviewer.\tit is done as a long running job so that the ui thread is not locked\twhile tla2tex runs.\tthis handles any unrecoverable error in tla2tex translation and presents\tit to the user as an error message.\tif the user has the pdf file in the .toolbox directory open in another\tprogram, then the toolbox will show a warning stating that the new pdf\tfile could not be created. it will display the old, unmodified pdf file\tto the user.",
	"Method": "void runPDFJob(AbstractPDFViewerRunnable runnable,IResource fileToTranslate){\r\n    try {\r\n        Vector<String> tla2texArgs = new Vector<String>();\r\n        IPreferenceStore preferenceStore = TLA2TeXActivator.getDefault().getPreferenceStore();\r\n        if (preferenceStore.getBoolean(ITLA2TeXPreferenceConstants.SHADE_COMMENTS)) {\r\n            tla2texArgs.add(\"-shade\");\r\n            tla2texArgs.add(\"-nops\");\r\n        }\r\n        if (preferenceStore.getBoolean(ITLA2TeXPreferenceConstants.NO_PCAL_SHADE)) {\r\n            tla2texArgs.add(\"-noPcalShade\");\r\n        }\r\n        if (preferenceStore.getBoolean(ITLA2TeXPreferenceConstants.NUMBER_LINES)) {\r\n            tla2texArgs.add(\"-number\");\r\n        }\r\n        tla2texArgs.add(\"-latexCommand\");\r\n        String latexCommand = preferenceStore.getString(ITLA2TeXPreferenceConstants.LATEX_COMMAND);\r\n        tla2texArgs.add(latexCommand);\r\n        tla2texArgs.add(\"-grayLevel\");\r\n        tla2texArgs.add(Double.toString(preferenceStore.getDouble(ITLA2TeXPreferenceConstants.GRAY_LEVEL)));\r\n        tla2texArgs.add(\"-latexOutputExt\");\r\n        tla2texArgs.add(TLA2TeX_Output_Extension);\r\n        tla2texArgs.add(\"-metadir\");\r\n        tla2texArgs.add(fileToTranslate.getProject().getLocation().toOSString());\r\n        tla2texArgs.add(fileToTranslate.getLocation().toOSString());\r\n        monitor.beginTask(\"Producing PDF\", 2);\r\n        monitor.subTask(\"Translating Module\");\r\n        TLA.runTranslation((String[]) tla2texArgs.toArray(new String[tla2texArgs.size()]));\r\n        fileToTranslate.getProject().refreshLocal(IResource.DEPTH_INFINITE, monitor);\r\n        monitor.worked(1);\r\n        final String outputFileName = fileToTranslate.getProject().getLocation().toOSString() + File.separator + ResourceHelper.getModuleName(fileToTranslate) + \".\" + TLA2TeX_Output_Extension;\r\n        final File outputFile = new File(outputFileName);\r\n        if (outputFile.exists()) {\r\n            runnable.setFile(outputFileName);\r\n            runnable.setMonitor(monitor);\r\n            UIHelper.runUISync(runnable);\r\n        } else {\r\n            UIHelper.runUISync(new Runnable() {\r\n                public void run() {\r\n                    MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"PDF file not found\", \"Could not locate a pdf file for the module.\");\r\n                }\r\n            });\r\n        }\r\n    } catch (final TLA2TexException e) {\r\n        TLA2TeXActivator.getDefault().logError(\"Error while producing pdf file: \" + e.getMessage(), e);\r\n        UIHelper.runUISync(new Runnable() {\r\n            public void run() {\r\n                MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"PDF Production Error\", e.getMessage());\r\n            }\r\n        });\r\n    } catch (final CoreException e) {\r\n        TLA2TeXActivator.getDefault().logError(\"Error while producing pdf file: \" + e.getMessage(), e);\r\n        UIHelper.runUISync(new Runnable() {\r\n            public void run() {\r\n                MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"PDF Production Error\", e.getMessage());\r\n            }\r\n        });\r\n    } finally {\r\n    }\r\n    return Status.OK_STATUS;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tla2tex.handler.ProducePDFHandler.runPDFJob",
	"Comment": "this method schedules a long running job that runs tla2tex on the file to\ttranslate and loads it in the browser that is part of the second tab of\tthe tlaeditorandpdfviewer.\tit is done as a long running job so that the ui thread is not locked\twhile tla2tex runs.\tthis handles any unrecoverable error in tla2tex translation and presents\tit to the user as an error message.\tif the user has the pdf file in the .toolbox directory open in another\tprogram, then the toolbox will show a warning stating that the new pdf\tfile could not be created. it will display the old, unmodified pdf file\tto the user.",
	"Method": "void runPDFJob(AbstractPDFViewerRunnable runnable,IResource fileToTranslate){\r\n    MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"PDF file not found\", \"Could not locate a pdf file for the module.\");\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tla2tex.handler.ProducePDFHandler.runPDFJob",
	"Comment": "this method schedules a long running job that runs tla2tex on the file to\ttranslate and loads it in the browser that is part of the second tab of\tthe tlaeditorandpdfviewer.\tit is done as a long running job so that the ui thread is not locked\twhile tla2tex runs.\tthis handles any unrecoverable error in tla2tex translation and presents\tit to the user as an error message.\tif the user has the pdf file in the .toolbox directory open in another\tprogram, then the toolbox will show a warning stating that the new pdf\tfile could not be created. it will display the old, unmodified pdf file\tto the user.",
	"Method": "void runPDFJob(AbstractPDFViewerRunnable runnable,IResource fileToTranslate){\r\n    MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"PDF Production Error\", e.getMessage());\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tla2tex.handler.ProducePDFHandler.runPDFJob",
	"Comment": "this method schedules a long running job that runs tla2tex on the file to\ttranslate and loads it in the browser that is part of the second tab of\tthe tlaeditorandpdfviewer.\tit is done as a long running job so that the ui thread is not locked\twhile tla2tex runs.\tthis handles any unrecoverable error in tla2tex translation and presents\tit to the user as an error message.\tif the user has the pdf file in the .toolbox directory open in another\tprogram, then the toolbox will show a warning stating that the new pdf\tfile could not be created. it will display the old, unmodified pdf file\tto the user.",
	"Method": "void runPDFJob(AbstractPDFViewerRunnable runnable,IResource fileToTranslate){\r\n    MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"PDF Production Error\", e.getMessage());\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.util.ModelHelper.hasVariables",
	"Comment": "returns true iff the specified module declaresat least one variable.added 10 sep 2009 by ll & dr",
	"Method": "boolean hasVariables(ModuleNode moduleNode){\r\n    OpDeclNode[] variableDecls = moduleNode.getVariableDecls();\r\n    return variableDecls.length > 0;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.ResourceHelper.getProject",
	"Comment": "retrieves a project by name or creates a new project is createmissing is set to true",
	"Method": "IProject getProject(String name,IProject getProject,String name,String rootFilename,boolean createMissing,boolean importExisting,IProgressMonitor monitor){\r\n    Assert.isNotNull(name);\r\n    Assert.isNotNull(rootFilename);\r\n    IProject project = getProject(name);\r\n    if (!project.exists() && createMissing) {\r\n        String parentDirectory = getParentDirName(rootFilename);\r\n        Assert.isNotNull(parentDirectory);\r\n        IPath projectDescriptionPath = new Path(parentDirectory).removeTrailingSeparator().append(name.concat(TOOLBOX_DIRECTORY_SUFFIX)).addTrailingSeparator();\r\n        IProjectDescription description;\r\n        boolean performImport = importExisting && projectDescriptionPath.append(PROJECT_DESCRIPTION_FILE).toFile().exists();\r\n        if (performImport) {\r\n            description = project.getWorkspace().loadProjectDescription(projectDescriptionPath.append(PROJECT_DESCRIPTION_FILE));\r\n            String[] natureIds = description.getNatureIds();\r\n            boolean natureFound = false;\r\n            for (int i = 0; i < natureIds.length; i++) {\r\n                if (TLANature.ID.equals(natureIds[i])) {\r\n                    natureFound = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!natureFound) {\r\n                String[] newNatureIds = new String[natureIds.length + 1];\r\n                System.arraycopy(natureIds, 0, newNatureIds, 0, natureIds.length);\r\n                newNatureIds[natureIds.length] = TLANature.ID;\r\n                description.setNatureIds(newNatureIds);\r\n            }\r\n            ICommand[] commands = description.getBuildSpec();\r\n            boolean tlaBuilderFound = false;\r\n            int numberOfBuildersToInstall = 1;\r\n            for (int i = 0; i < commands.length; ++i) {\r\n                String builderName = commands[i].getBuilderName();\r\n                if (builderName.equals(TLAParsingBuilder.BUILDER_ID)) {\r\n                    tlaBuilderFound = true;\r\n                    numberOfBuildersToInstall--;\r\n                }\r\n                if (tlaBuilderFound) {\r\n                    break;\r\n                }\r\n            }\r\n            if (numberOfBuildersToInstall > 0) {\r\n                ICommand[] newCommands = new ICommand[commands.length + numberOfBuildersToInstall];\r\n                System.arraycopy(commands, 0, newCommands, 0, commands.length);\r\n                int position = commands.length;\r\n                if (!tlaBuilderFound) {\r\n                    ICommand command = description.newCommand();\r\n                    command.setBuilderName(TLAParsingBuilder.BUILDER_ID);\r\n                    newCommands[position] = command;\r\n                    position++;\r\n                }\r\n            }\r\n        } else {\r\n            description = project.getWorkspace().newProjectDescription(name);\r\n            description.setLocation(projectDescriptionPath);\r\n            description.setNatureIds(new String[] { TLANature.ID });\r\n            ICommand command = description.newCommand();\r\n            command.setBuilderName(TLAParsingBuilder.BUILDER_ID);\r\n            description.setBuildSpec(new ICommand[] { command });\r\n        }\r\n        project.create(description, monitor);\r\n        project.refreshLocal(IResource.DEPTH_INFINITE, monitor);\r\n        project.open(monitor);\r\n        if (performImport) {\r\n            relocateFiles(project, new Path(parentDirectory), monitor);\r\n        }\r\n    }\r\n    return project;\r\n}"
}, {
	"Path": "tlc2.tool.Spec.getOpContext",
	"Comment": "the following added by ll on 23 october 2012 to fix bug in evaluation of names of theorems and assumptions imported by parameterized instantiation.",
	"Method": "Context getOpContext(OpDefNode opDef,ExprOrOpArgNode[] args,Context c,boolean cachable,Context getOpContext,ThmOrAssumpDefNode opDef,ExprOrOpArgNode[] args,Context c,boolean cachable){\r\n    FormalParamNode[] formals = opDef.getParams();\r\n    int alen = args.length;\r\n    Context c1 = c;\r\n    for (int i = 0; i < alen; i++) {\r\n        Object aval = this.getVal(args[i], c, cachable);\r\n        c1 = c1.cons(formals[i], aval);\r\n    }\r\n    return c1;\r\n}"
}, {
	"Path": "org.springframework.roo.shell.SimpleParser.checkVisibilityAndValues",
	"Comment": "check if executed command has compatible options and values based on itsindicators",
	"Method": "void checkVisibilityAndValues(MethodTarget methodTarget,Map<String, String> options,ShellContextImpl shellContext,CliOption cliOption){\r\n    if (!this.isVisibleParam(methodTarget.getKey(), cliOption, shellContext)) {\r\n        MethodTarget optionVisibilityIndicator = optionVisibilityIndicators.get(methodTarget.getKey().concat(\"|\").concat(cliOption.key()[0]));\r\n        if (optionVisibilityIndicator != null && optionVisibilityIndicator.getMethod() != null) {\r\n            CliOptionVisibilityIndicator visibilityIndicator = optionVisibilityIndicator.getMethod().getAnnotation(CliOptionVisibilityIndicator.class);\r\n            if (visibilityIndicator != null) {\r\n                LOGGER.warning(visibilityIndicator.help());\r\n                throw new RuntimeException();\r\n            }\r\n        }\r\n    }\r\n    if (autocompleteNeedsValidation(methodTarget.getKey(), cliOption)) {\r\n        String value = options.get(cliOption.key()[0]);\r\n        List<String> possibleValues = getPossibleValuesByIndicator(methodTarget.getKey(), cliOption, shellContext);\r\n        if (possibleValues != null && !possibleValues.contains(value)) {\r\n            MethodTarget optionAutocompleteIndicator = optionAutocompleteIndicators.get(methodTarget.getKey().concat(\"|\").concat(cliOption.key()[0]));\r\n            if (optionAutocompleteIndicator != null && optionAutocompleteIndicator.getMethod() != null) {\r\n                CliOptionAutocompleteIndicator autocompleteIndicator = optionAutocompleteIndicator.getMethod().getAnnotation(CliOptionAutocompleteIndicator.class);\r\n                if (autocompleteIndicator != null) {\r\n                    LOGGER.warning(autocompleteIndicator.help());\r\n                    throw new RuntimeException();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.swift.generator.SwiftGeneratorConfig.isGenerateIncludedCode",
	"Comment": "if true, generate code for all included thrift idls instead of just referring tothem.",
	"Method": "boolean isGenerateIncludedCode(){\r\n    return generateIncludedCode;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.OldDecomposeProofHandler.realExecute",
	"Comment": "the real execute methodthis method is called by a synchronous job launched in the execute method to do most of the work of executing the decompose proof command.",
	"Method": "Object realExecute(){\r\n    Activator.getDefault().logDebug(\"Decompose Proof Called\");\r\n    Vector<SemanticNode> assumes;\r\n    SemanticNode goal;\r\n    String[] blankLine = new String[] { \"\" };\r\n    String[] oneline = new String[] { \"1\" };\r\n    if (this.windowShell != null) {\r\n        if (!this.windowShell.isDisposed()) {\r\n            System.out.println(\"Command called when being executed.\");\r\n            return null;\r\n        }\r\n    }\r\n    if (existDirtyModules()) {\r\n        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"There is an unsaved module.\");\r\n        return null;\r\n    }\r\n    Spec spec = Activator.getSpecManager().getSpecLoaded();\r\n    if (spec == null || spec.getStatus() != IParseConstants.PARSED) {\r\n        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"The spec status must be \\\"parsed\\\" to execute this command.\");\r\n        return null;\r\n    }\r\n    if (editor == null) {\r\n        Activator.getDefault().logDebug(\"2nd call of getTLAEditorWithFocus returned null\");\r\n        return null;\r\n    }\r\n    editorIFile = ((FileEditorInput) editor.getEditorInput()).getFile();\r\n    if (editor.isDirty()) {\r\n        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"The module is dirty; this should not happen.\");\r\n        return null;\r\n    }\r\n    hasChanged = false;\r\n    chosenSplit = -1;\r\n    needsStepNumber = false;\r\n    andSplitBegin = -1;\r\n    andSplitEnd = -1;\r\n    goalDefinitions = new HashSet<String>();\r\n    assumpDefinitions = new HashSet<String>();\r\n    Location selectedLocation = EditorUtil.getLocationAt(doc, offset, selection.getLength());\r\n    TheoremNode[] allTheorems = moduleNode.getTheorems();\r\n    theorem = null;\r\n    int i = 0;\r\n    String moduleFile = moduleNode.stn.getFilename();\r\n    while ((theorem == null) & (i < allTheorems.length)) {\r\n        if (allTheorems[i].stn.getFilename().equals(moduleFile) && EditorUtil.lineLocationContainment(selectedLocation, allTheorems[i].stn.getLocation())) {\r\n            theorem = allTheorems[i];\r\n        }\r\n        i++;\r\n    }\r\n    if (theorem == null) {\r\n        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"The cursor is not in a theorem.\");\r\n        return null;\r\n    }\r\n    this.declaredIdentifiers = ResourceHelper.declaredSymbolsInScope(this.moduleNode, theorem.stn.getLocation());\r\n    step = theorem;\r\n    boolean notDone = true;\r\n    proofLevel = -1;\r\n    proof = step.getProof();\r\n    while (notDone && (proof != null) && (proof instanceof NonLeafProofNode)) {\r\n        LevelNode[] pfsteps = ((NonLeafProofNode) proof).getSteps();\r\n        LevelNode foundLevelNode = null;\r\n        i = 0;\r\n        proofLevel = -1;\r\n        while ((foundLevelNode == null) && (i < pfsteps.length)) {\r\n            if ((proofLevel == -1) && !(pfsteps[i] instanceof DefStepNode) && !(pfsteps[i] instanceof InstanceNode)) {\r\n                proofLevel = stepLevel(pfsteps[i]);\r\n            }\r\n            if (EditorUtil.lineLocationContainment(selectedLocation, pfsteps[i].stn.getLocation())) {\r\n                foundLevelNode = pfsteps[i];\r\n                if (!step.isSuffices() && (step.getTheorem() instanceof AssumeProveNode)) {\r\n                    SemanticNode[] assumptions = ((AssumeProveNode) step.getTheorem()).getAssumes();\r\n                    for (int j = 0; j < assumptions.length; j++) {\r\n                        if (assumptions[j] instanceof NewSymbNode) {\r\n                            declaredIdentifiers.add(((NewSymbNode) assumptions[j]).getOpDeclNode().getName().toString());\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (pfsteps[i] instanceof TheoremNode) {\r\n                    TheoremNode node = (TheoremNode) pfsteps[i];\r\n                    if (node.isSuffices() && (node.getTheorem() instanceof AssumeProveNode)) {\r\n                        SemanticNode[] assumptions = ((AssumeProveNode) node.getTheorem()).getAssumes();\r\n                        for (int j = 0; j < assumptions.length; j++) {\r\n                            if (assumptions[j] instanceof NewSymbNode) {\r\n                                declaredIdentifiers.add(((NewSymbNode) assumptions[j]).getOpDeclNode().getName().toString());\r\n                            }\r\n                        }\r\n                    } else if (node.getTheorem() instanceof OpApplNode) {\r\n                        OpApplNode oanode = (OpApplNode) node.getTheorem();\r\n                        if (oanode.getOperator().getName().toString().equals(\"$Pick\")) {\r\n                            FormalParamNode[] fp = oanode.getUnbdedQuantSymbols();\r\n                            if (fp != null) {\r\n                                for (int j = 0; j < fp.length; j++) {\r\n                                    declaredIdentifiers.add(fp[j].getName().toString());\r\n                                }\r\n                            } else {\r\n                                FormalParamNode[][] fpn = oanode.getBdedQuantSymbolLists();\r\n                                for (int j = 0; j < fpn.length; j++) {\r\n                                    for (int k = 0; k < fpn[j].length; k++) {\r\n                                        declaredIdentifiers.add(fpn[j][k].getName().toString());\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (pfsteps[i] instanceof DefStepNode) {\r\n                    OpDefNode[] defs = ((DefStepNode) pfsteps[i]).getDefs();\r\n                    for (int j = 0; j < defs.length; j++) {\r\n                        declaredIdentifiers.add(defs[j].getName().toString());\r\n                    }\r\n                }\r\n                if (pfsteps[i] instanceof InstanceNode) {\r\n                    ResourceHelper.addDeclaredSymbolsInScope(declaredIdentifiers, ((InstanceNode) pfsteps[i]).getModule(), ResourceHelper.infiniteLoc);\r\n                }\r\n            }\r\n            i++;\r\n        }\r\n        if (foundLevelNode == null) {\r\n            notDone = false;\r\n        } else if (!(foundLevelNode instanceof TheoremNode)) {\r\n            MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"The cursor is in a non-provable step.\");\r\n            return null;\r\n        } else {\r\n            step = (TheoremNode) foundLevelNode;\r\n            proof = step.getProof();\r\n        }\r\n    }\r\n    if (step.isSuffices()) {\r\n        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"Cannot decompose a SUFFICES step.\");\r\n        return null;\r\n    }\r\n    int level = this.proofLevel;\r\n    if (level < 0) {\r\n        level = 0;\r\n    }\r\n    proofLevelString = \"<\" + (level + 1) + \">\";\r\n    SyntaxTreeNode nd = (SyntaxTreeNode) step.stn;\r\n    if (step == theorem) {\r\n        stepNumber = null;\r\n    } else {\r\n        stepNumber = nd.getHeirs()[0].image.toString();\r\n        if (stepNumber.indexOf('>') == stepNumber.length() - 1) {\r\n            stepNumber = null;\r\n        } else {\r\n            i = stepNumber.indexOf('>') + 1;\r\n            while ((i < stepNumber.length() && (Character.isLetterOrDigit(stepNumber.charAt(i)) || (stepNumber.charAt(i) == '_')))) {\r\n                i++;\r\n            }\r\n            if (i < stepNumber.length()) {\r\n                stepNumber = stepNumber.substring(0, i);\r\n            }\r\n        }\r\n    }\r\n    stepColumn = nd.getLocation().beginColumn();\r\n    if ((proof != null) && !(proof instanceof LeafProofNode)) {\r\n        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"You have selected a step that already has a non-leaf proof.\");\r\n        return null;\r\n    }\r\n    try {\r\n        stepRep = new NodeRepresentation(doc, step);\r\n    } catch (BadLocationException e) {\r\n        e.printStackTrace();\r\n        System.out.println(\"threw exception\");\r\n    }\r\n    LevelNode thm = step.getTheorem();\r\n    if (thm instanceof AssumeProveNode) {\r\n        hasAssumes = true;\r\n        SemanticNode[] assump = ((AssumeProveNode) thm).getAssumes();\r\n        assumes = new Vector<SemanticNode>();\r\n        assumeReps = new Vector<NodeRepresentation>();\r\n        int rowOfLastNew = -1;\r\n        for (i = 0; i < assump.length; i++) {\r\n            if (assump[i] instanceof AssumeProveNode) {\r\n                MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"Cannot decompose a step with a nested ASSUME/PROVE.\");\r\n                return null;\r\n            }\r\n            assumes.add(assump[i]);\r\n            NodeRepresentation nodeRep = stepRep.subNodeRep(assump[i], assumeReps, null, null, null);\r\n            if (nodeRep.nodeType == NodeRepresentation.NEW_NODE) {\r\n                Location loc = nodeRep.semanticNode.stn.getLocation();\r\n                if (loc.beginLine() == loc.endLine()) {\r\n                    if (loc.beginLine() == rowOfLastNew) {\r\n                        assumeReps.elementAt(i - 1).onSameLineAsNext = true;\r\n                    }\r\n                    rowOfLastNew = loc.beginLine();\r\n                } else {\r\n                    rowOfLastNew = -1;\r\n                }\r\n            } else {\r\n                rowOfLastNew = -1;\r\n            }\r\n            assumeReps.add(nodeRep);\r\n            goal = ((AssumeProveNode) thm).getProve();\r\n            if (!(goal instanceof OpApplNode)) {\r\n                MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"This step has a weird goal that cannot\\n be processed.\");\r\n                return null;\r\n            }\r\n            goalRep = stepRep.subNodeRep(goal, null, null, null, null);\r\n        }\r\n    } else {\r\n        hasAssumes = false;\r\n        assumes = new Vector<SemanticNode>();\r\n        assumeReps = new Vector<NodeRepresentation>();\r\n        if (!(thm instanceof OpApplNode)) {\r\n            MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"This is a weird step that cannot\\n be processed.\");\r\n            return null;\r\n        }\r\n        goal = thm;\r\n        UniqueString goalOpName = null;\r\n        if (goal instanceof OpApplNode) {\r\n            goalOpName = ((OpApplNode) goal).getOperator().getName();\r\n        }\r\n        if ((goalOpName == null) || (goalOpName == ASTConstants.OP_qed) || (goalOpName == ASTConstants.OP_pfcase) || (goalOpName == ASTConstants.OP_have) || (goalOpName == ASTConstants.OP_pick) || (goalOpName == ASTConstants.OP_witness) || (goalOpName == ASTConstants.OP_suffices)) {\r\n            MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"Cannot decompose this kind of step.\");\r\n            return null;\r\n        }\r\n        goalRep = stepRep.subNodeRep(goal, null, null, null, null);\r\n    }\r\n    editorIFile.setReadOnly(true);\r\n    raiseWindow();\r\n    return null;\r\n}"
}, {
	"Path": "tlc2.tool.liveness.LiveCheck1.addNodesForStut",
	"Comment": "this method is called for each new node created. it generates nodes\tinduced by a stuttering state transition.",
	"Method": "void addNodesForStut(TLCState state,long fp,BTGraphNode node,boolean[] checkState,boolean[] checkAction,OrderOfSolution os,BEGraph bgraph){\r\n    int slen = os.getCheckState().length;\r\n    int alen = os.getCheckAction().length;\r\n    TBGraphNode tnode = node.getTNode(os.getTableau());\r\n    for (int i = 0; i < tnode.nextSize(); i++) {\r\n        TBGraphNode tnode1 = tnode.nextAt(i);\r\n        BTGraphNode destNode = bgraph.allNodes.getBTNode(fp, tnode1.getIndex());\r\n        if (destNode == null) {\r\n            if (tnode1.isConsistent(state, myTool)) {\r\n                destNode = new BTGraphNode(fp, tnode1.getIndex());\r\n                destNode.setCheckState(checkState);\r\n                node.addTransition(destNode, slen, alen, checkAction);\r\n                bgraph.allNodes.putBTNode(destNode);\r\n                addNodesForStut(state, fp, destNode, checkState, checkAction, os, bgraph);\r\n            }\r\n        } else {\r\n            node.addTransition(destNode, slen, alen, checkAction);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.itd.AbstractItdTypeDetailsProvidingMetadataItem.governorHasMethodWithSameName",
	"Comment": "indicates whether the governor has a method with the given method nameregardless of method parameters.",
	"Method": "boolean governorHasMethodWithSameName(JavaSymbolName methodName){\r\n    return MemberFindingUtils.getDeclaredMethod(governorTypeDetails, methodName) != null;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.StudentAttributes.isSectionChanged",
	"Comment": "returns true if section value has changed from its original value.",
	"Method": "boolean isSectionChanged(StudentAttributes originalStudentAttribute){\r\n    return this.section != null && !this.section.equals(originalStudentAttribute.section);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.model.Model.getOutputLogFile",
	"Comment": "retrieves a file where the log of the tlc run is written. if istraceexploration is true, thiswill return the log file for trace exploration. if that flag is false, this will return the log filefor normal model checking.",
	"Method": "IFile getOutputLogFile(IFile getOutputLogFile,boolean getTraceExplorerOutput){\r\n    if (getTraceExplorerOutput) {\r\n        return getFile(ModelHelper.TE_FILE_OUT);\r\n    } else {\r\n        return getFile(ModelHelper.FILE_OUT);\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.Tool.isInActions",
	"Comment": "this method determines if a pair of states satisfy the action constraints.",
	"Method": "boolean isInActions(TLCState s1,TLCState s2){\r\n    ExprNode[] constrs = this.getActionConstraints();\r\n    for (int i = 0; i < constrs.length; i++) {\r\n        Value bval = this.eval(constrs[i], Context.Empty, s1, s2, EvalControl.Clear);\r\n        if (!(bval instanceof BoolValue)) {\r\n            Assert.fail(EC.TLC_EXPECTED_VALUE, new String[] { \"boolean\", constrs[i].toString() });\r\n        }\r\n        if (!((BoolValue) bval).val)\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.roo.shell.jline.JLineShell.closeShell",
	"Comment": "should be called by a subclass before deactivating the shell.",
	"Method": "void closeShell(){\r\n    setShellStatus(Status.SHUTTING_DOWN);\r\n    if (statusListener != null) {\r\n        removeShellStatusListener(statusListener);\r\n    }\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackSessionsDb.getFeedbackSessionsPossiblyNeedingOpenEmail",
	"Comment": "gets a list of undeleted feedback sessions which start within the last 2 hoursand possibly need an open email to be sent.",
	"Method": "List<FeedbackSessionAttributes> getFeedbackSessionsPossiblyNeedingOpenEmail(){\r\n    return makeAttributes(getFeedbackSessionEntitiesPossiblyNeedingOpenEmail()).stream().filter(session -> !session.isSessionDeleted()).collect(Collectors.toList());\r\n}"
}, {
	"Path": "tla2sany.semantic.SymbolNode.export",
	"Comment": "we override export in order not to export location and level.we only export names.",
	"Method": "Element export(Document doc,tla2sany.xml.SymbolContext context){\r\n    context.put(this, doc);\r\n    Element e = doc.createElement(getNodeRef());\r\n    e.appendChild(appendText(doc, \"UID\", Integer.toString(myUID)));\r\n    return e;\r\n}"
}, {
	"Path": "teammates.ui.controller.InstructorCourseInstructorEditSaveAction.updateToEnsureValidityOfInstructorsForTheCourse",
	"Comment": "checks if there are any other registered instructors that can modify instructors.if there are none, the instructor currently being edited will be granted the privilegeof modifying instructors automatically.",
	"Method": "void updateToEnsureValidityOfInstructorsForTheCourse(String courseId,InstructorAttributes instructorToEdit){\r\n    List<InstructorAttributes> instructors = logic.getInstructorsForCourse(courseId);\r\n    int numOfInstrCanModifyInstructor = 0;\r\n    InstructorAttributes instrWithModifyInstructorPrivilege = null;\r\n    for (InstructorAttributes instructor : instructors) {\r\n        if (instructor.isAllowedForPrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR)) {\r\n            numOfInstrCanModifyInstructor++;\r\n            instrWithModifyInstructorPrivilege = instructor;\r\n        }\r\n    }\r\n    boolean isLastRegInstructorWithPrivilege = numOfInstrCanModifyInstructor <= 1 && instrWithModifyInstructorPrivilege != null && (!instrWithModifyInstructorPrivilege.isRegistered() || instrWithModifyInstructorPrivilege.googleId.equals(instructorToEdit.googleId));\r\n    if (isLastRegInstructorWithPrivilege) {\r\n        instructorToEdit.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR, true);\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.io.enc.PackBitsDecoder.decode",
	"Comment": "decodes bytes from the given input stream, to the given buffer.",
	"Method": "int decode(InputStream stream,ByteBuffer buffer){\r\n    if (reachedEOF) {\r\n        return -1;\r\n    }\r\n    while (buffer.hasRemaining()) {\r\n        int n;\r\n        if (splitRun) {\r\n            n = leftOfRun;\r\n            splitRun = false;\r\n        } else {\r\n            int b = stream.read();\r\n            if (b < 0) {\r\n                reachedEOF = true;\r\n                break;\r\n            }\r\n            n = (byte) b;\r\n        }\r\n        if (n >= 0 && n + 1 > buffer.remaining()) {\r\n            leftOfRun = n;\r\n            splitRun = true;\r\n            break;\r\n        } else if (n < 0 && -n + 1 > buffer.remaining()) {\r\n            leftOfRun = n;\r\n            splitRun = true;\r\n            break;\r\n        }\r\n        try {\r\n            if (n >= 0) {\r\n                readFully(stream, buffer, sample.length * (n + 1));\r\n            } else if (disableNoOp || n != -128) {\r\n                for (int s = 0; s < sample.length; s++) {\r\n                    sample[s] = readByte(stream);\r\n                }\r\n                for (int i = -n + 1; i > 0; i--) {\r\n                    buffer.put(sample);\r\n                }\r\n            }\r\n        } catch (IndexOutOfBoundsException e) {\r\n            throw new DecodeException(\"Error in PackBits decompression, data seems corrupt\", e);\r\n        }\r\n    }\r\n    return buffer.position();\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.StringUtil.toDate",
	"Comment": "converts the string to a date, using the default date format.",
	"Method": "Date toDate(String pString,Date toDate,String pString,String pFormat,Date toDate,String pString,DateFormat pFormat){\r\n    try {\r\n        synchronized (pFormat) {\r\n            return pFormat.parse(pString);\r\n        }\r\n    } catch (ParseException pe) {\r\n        throw new IllegalArgumentException(pe.getMessage());\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.liveness.TBGraph.findOrCreateNode",
	"Comment": "the method findorcreatenode, given a list of particles, either finds the\tparticle in that list, or creates a new one and puts it in the list. if\tit does create a node, then it also sticks that node into allnodes.",
	"Method": "TBGraphNode findOrCreateNode(TBPar par){\r\n    for (int i = 0; i < this.size(); i++) {\r\n        final TBGraphNode gn = (TBGraphNode) this.elementAt(i);\r\n        if (par.equals(gn.getPar())) {\r\n            return gn;\r\n        }\r\n    }\r\n    final TBGraphNode gn = new TBGraphNode(par);\r\n    this.addElement(gn);\r\n    return gn;\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.ObjectAbstractTest.readExternalFormFromBytes",
	"Comment": "read a serialized or externalized object from bytes.useful for verifying serialization in memory.",
	"Method": "Object readExternalFormFromBytes(byte[] b){\r\n    ByteArrayInputStream stream = new ByteArrayInputStream(b);\r\n    return readExternalFormFromStream(stream);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.preference.ProverPreferencePage.getColorPredPrefName",
	"Comment": "returns the preference name for the color predicatefor logical color colornum. this is the name used to storethe preference in the preference store.",
	"Method": "String getColorPredPrefName(int colorNum){\r\n    return STEP_STATUS_COLOR + colorNum + PREDICATE;\r\n}"
}, {
	"Path": "tlc2.tool.liveness.BEGraphNode.setParent",
	"Comment": "set node to be the parent of this. this would destroy the original graph.\tuse with caution.",
	"Method": "void setParent(BEGraphNode node){\r\n    if (this.nnodes.length == 0) {\r\n        this.nnodes = new BEGraphNode[1];\r\n    }\r\n    this.nnodes[0] = node;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.TLAMarkerHelper.currentSpecHasProblems",
	"Comment": "convenience method that determines if the current spec has problems",
	"Method": "boolean currentSpecHasProblems(){\r\n    Spec spec = Activator.getSpecManager().getSpecLoaded();\r\n    if (spec == null) {\r\n        return false;\r\n    }\r\n    return (TLAMarkerHelper.getProblemMarkers(spec.getProject(), null).length > 0);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.editor.page.BasicFormPage.isComplete",
	"Comment": "returns if the input is complete and the page contains no errors",
	"Method": "boolean isComplete(){\r\n    return isComplete;\r\n}"
}, {
	"Path": "pcal.PcalSymTab.ExtractEither",
	"Comment": "handling of either and labeleither added by ll on 24 jan 2006.",
	"Method": "void ExtractEither(AST.Either ast,String context,String cType){\r\n    for (int i = 0; i < ast.ors.size(); i++) {\r\n        Vector orClause = (Vector) ast.ors.elementAt(i);\r\n        for (int j = 0; j < orClause.size(); j++) ExtractStmt((AST) orClause.elementAt(j), context, cType);\r\n    }\r\n    ;\r\n}"
}, {
	"Path": "teammates.ui.controller.FileDownloadResult.getContentDispositionHeader",
	"Comment": "suggests a filename for the content of the response to be saved as.",
	"Method": "String getContentDispositionHeader(){\r\n    return \"attachment; filename=\\\"\" + getAsciiOnlyCsvFileName() + \"\\\";\" + \"filename*= UTF-8''\" + getUrlEscapedCsvFileName();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.proof.TLAProofPosition.containsInProofOrStatement",
	"Comment": "returns whether the offset is contained on any of the linesof the proof or the statement. note that this position endsat the first offset of the line after the proof, but this methoddoes not consider that line part of the statement or the proof. the positionends at that offset for reasons explained in the constructor of this class.",
	"Method": "boolean containsInProofOrStatement(int offset,IDocument document){\r\n    int startLine = document.getLineOfOffset(this.offset);\r\n    int endLine = document.getLineOfOffset(this.offset + length) - 1;\r\n    int lineOfOffset = document.getLineOfOffset(offset);\r\n    return lineOfOffset >= startLine && lineOfOffset <= endLine;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.tla.TokenSpec.findCurrentTokenSpec",
	"Comment": "this method returns the tokenspec of the symbol at the cursor position of the tlaeditor with the current focus.if it cannot find the definitionor declaration of such a symbol, it returns a tokenspec for the tokenbeing pointed to with a null resolvedsymbol field.this will be thecase if that token is a module name.this method is used byshowuseshandler.execute.",
	"Method": "TokenSpec findCurrentTokenSpec(TokenSpec findCurrentTokenSpec,IRegion regionInput){\r\n    TLAEditor editor = EditorUtil.getTLAEditorWithFocus();\r\n    if (editor == null) {\r\n        return null;\r\n    }\r\n    String moduleName = editor.getModuleName();\r\n    ModuleNode moduleNode = ResourceHelper.getModuleNode(moduleName);\r\n    if (moduleNode == null) {\r\n        return null;\r\n    }\r\n    ISourceViewer internalSourceViewer = editor.publicGetSourceViewer();\r\n    IDocument document = internalSourceViewer.getDocument();\r\n    ITextSelection selection = (ITextSelection) editor.getSelectionProvider().getSelection();\r\n    IRegion region = regionInput;\r\n    if (regionInput == null) {\r\n        region = new Region(selection.getOffset(), selection.getLength());\r\n    }\r\n    String currentLine;\r\n    int currentPos;\r\n    int offsetOfLine;\r\n    try {\r\n        int lineNumber = document.getLineOfOffset(region.getOffset());\r\n        int lineDelimLength = 0;\r\n        String delim = document.getLineDelimiter(lineNumber);\r\n        if (delim != null) {\r\n            lineDelimLength = delim.length();\r\n        }\r\n        ;\r\n        offsetOfLine = document.getLineOffset(lineNumber);\r\n        currentLine = document.get(offsetOfLine, document.getLineLength(lineNumber) - lineDelimLength);\r\n        currentPos = region.getOffset() - offsetOfLine;\r\n    } catch (BadLocationException e) {\r\n        TLAEditorActivator.getDefault().logDebug(\"Exception thrown\", e);\r\n        return null;\r\n    }\r\n    TokenSpec[] tokenSpecs = findTokenSpecs(currentLine, currentPos);\r\n    int goodIndex = -1;\r\n    SymbolNode symbol = null;\r\n    for (int i = 0; i < tokenSpecs.length; i++) {\r\n        int leftPos = tokenSpecs[i].leftPos;\r\n        int rightPos = tokenSpecs[i].rightPos;\r\n        tokenSpecs[i].leftPos = leftPos + offsetOfLine;\r\n        tokenSpecs[i].rightPos = rightPos + offsetOfLine;\r\n        String indiceAdjustedToken = tokenSpecs[i].token;\r\n        Location location = EditorUtil.getLocationAt(document, tokenSpecs[i].leftPos, rightPos - leftPos);\r\n        if ((indiceAdjustedToken != null) && (indiceAdjustedToken.length() > 1) && (indiceAdjustedToken.charAt(0) == '_')) {\r\n            indiceAdjustedToken = indiceAdjustedToken.substring(1);\r\n        }\r\n        symbol = EditorUtil.lookupOriginalSymbol(UniqueString.uniqueStringOf(indiceAdjustedToken), moduleNode, location, null);\r\n        if (symbol != null) {\r\n            goodIndex = i;\r\n            break;\r\n        }\r\n    }\r\n    if (goodIndex == -1) {\r\n        if (tokenSpecs.length == 0) {\r\n            return null;\r\n        } else {\r\n            goodIndex = 0;\r\n        }\r\n    }\r\n    TokenSpec result = new TokenSpec(tokenSpecs[goodIndex].token, tokenSpecs[goodIndex].leftPos, tokenSpecs[goodIndex].rightPos);\r\n    result.resolvedSymbol = symbol;\r\n    return result;\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.plugins.bmp.AbstractRLEDecoder.decode",
	"Comment": "decodes as much data as possible, from the stream into the buffer.",
	"Method": "int decode(InputStream stream,ByteBuffer buffer){\r\n    if (buffer.capacity() < row.length) {\r\n        throw new AssertionError(\"This decoder needs a buffer.capacity() of at least one row\");\r\n    }\r\n    while (buffer.remaining() >= row.length && srcY >= 0) {\r\n        if (dstX == 0 && srcY == dstY) {\r\n            decodeRow(stream);\r\n        }\r\n        int length = Math.min(row.length - (dstX * bitsPerSample) / 8, buffer.remaining());\r\n        buffer.put(row, 0, length);\r\n        dstX += (length * 8) / bitsPerSample;\r\n        if (dstX == (row.length * 8) / bitsPerSample) {\r\n            dstX = 0;\r\n            dstY++;\r\n            if (srcX > dstX) {\r\n                Arrays.fill(row, 0, (srcX * bitsPerSample) / 8, (byte) 0);\r\n            }\r\n            if (srcY > dstY) {\r\n                Arrays.fill(row, (byte) 0);\r\n            }\r\n        }\r\n    }\r\n    return buffer.position();\r\n}"
}, {
	"Path": "com.twelvemonkeys.io.SubStream.close",
	"Comment": "marks this stream as closed.this implementation does not close the underlying stream.",
	"Method": "void close(){\r\n    while (bytesLeft > 0) {\r\n        skip(bytesLeft);\r\n    }\r\n}"
}, {
	"Path": "sharedcode.turboeditor.util.systemui.SystemUiHelper.delayHide",
	"Comment": "request that the system ui is hidden after a delay.any currently queued delayed hide requests will be removed.",
	"Method": "void delayHide(long delayMillis){\r\n    removeQueuedRunnables();\r\n    mHandler.postDelayed(mHideRunnable, delayMillis);\r\n}"
}, {
	"Path": "teammates.logic.api.TaskQueuer.scheduleFeedbackSessionUnpublishedEmail",
	"Comment": "schedules for feedback session unpublished email to be sent.",
	"Method": "void scheduleFeedbackSessionUnpublishedEmail(String courseId,String feedbackSessionName){\r\n    Map<String, String> paramMap = new HashMap();\r\n    paramMap.put(ParamsNames.EMAIL_COURSE, courseId);\r\n    paramMap.put(ParamsNames.EMAIL_FEEDBACK, feedbackSessionName);\r\n    addTask(TaskQueue.FEEDBACK_SESSION_UNPUBLISHED_EMAIL_QUEUE_NAME, TaskQueue.FEEDBACK_SESSION_UNPUBLISHED_EMAIL_WORKER_URL, paramMap);\r\n}"
}, {
	"Path": "teammates.test.driver.TimeHelperExtension.getInstantMinutesOffsetFromNow",
	"Comment": "returns an java.time.instant object that is offset by a number of minutes from now.",
	"Method": "Instant getInstantMinutesOffsetFromNow(long offsetInMinutes){\r\n    return Instant.now().plus(Duration.ofMinutes(offsetInMinutes));\r\n}"
}, {
	"Path": "teammates.client.scripts.statistics.FileStore.getStatisticsBundleFromFileIfPossible",
	"Comment": "decrypts and parses the statistics bundle that is saved in the disk.",
	"Method": "StatisticsBundle getStatisticsBundleFromFileIfPossible(){\r\n    StatisticsBundle.InstitutesStatsMetadata metadata = new StatisticsBundle.InstitutesStatsMetadata();\r\n    File metadataFile = new File(INSTITUTES_STATS_METADATA_FILEPATH);\r\n    if (metadataFile.isFile()) {\r\n        metadata = getSerializer().fromJson(FileHelper.readFile(INSTITUTES_STATS_METADATA_FILEPATH), StatisticsBundle.InstitutesStatsMetadata.class);\r\n    }\r\n    File institutesStatsFile = new File(INSTITUTES_STATS_FILEPATH);\r\n    Map<String, StatisticsBundle.InstituteStats> institutesStats = new HashMap();\r\n    if (institutesStatsFile.isFile()) {\r\n        institutesStats = parseEncryptedJsonFile(INSTITUTES_STATS_FILEPATH, jsonReader -> getSerializer().fromJson(jsonReader, new TypeToken<Map<String, StatisticsBundle.InstituteStats>>() {\r\n        }.getType()));\r\n    }\r\n    StatisticsBundle statisticsBundle = new StatisticsBundle();\r\n    statisticsBundle.setInstitutesStatsMetadata(metadata);\r\n    statisticsBundle.setInstitutesStats(institutesStats);\r\n    return statisticsBundle;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.job.ProverJob.isStatusCheck",
	"Comment": "if true, the prover will be launched forstatus checking only, not proving.",
	"Method": "boolean isStatusCheck(){\r\n    return checkStatus;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.preference.TLCChainedPreferenceStore.getOtherValue",
	"Comment": "returns an object of the same dynamic type as thisvalue, the returned object\tencapsulates the value of the property from the preference store.",
	"Method": "Object getOtherValue(String property,IPreferenceStore store,Object thisValue){\r\n    if (thisValue instanceof Boolean)\r\n        return store.getBoolean(property) ? Boolean.TRUE : Boolean.FALSE;\r\n    else if (thisValue instanceof Double)\r\n        return new Double(store.getDouble(property));\r\n    else if (thisValue instanceof Float)\r\n        return new Float(store.getFloat(property));\r\n    else if (thisValue instanceof Integer)\r\n        return new Integer(store.getInt(property));\r\n    else if (thisValue instanceof Long)\r\n        return new Long(store.getLong(property));\r\n    else if (thisValue instanceof String)\r\n        return store.getString(property);\r\n    return store.getString(property);\r\n}"
}, {
	"Path": "tlc2.tool.AbstractChecker.runTLC",
	"Comment": "i believe this method is called after the initial states are computedto do all the rest of the model checking.ll 9 april 2012create the partial state space for given starting state upto the given depth or the number of states.",
	"Method": "boolean runTLC(int depth){\r\n    if (this.cancellationFlag) {\r\n        return false;\r\n    }\r\n    if (depth < 2) {\r\n        return true;\r\n    }\r\n    workers = startWorkers(this, depth);\r\n    int count = TLCGlobals.coverageInterval / TLCGlobals.progressInterval;\r\n    synchronized (this) {\r\n        if (!this.done) {\r\n            this.wait(3000);\r\n        }\r\n    }\r\n    while (!this.cancellationFlag) {\r\n        if (!this.doPeriodicWork()) {\r\n            return false;\r\n        }\r\n        synchronized (this) {\r\n            if (!this.done) {\r\n                runTLCContinueDoing(count, depth);\r\n                if (count == 0) {\r\n                    count = TLCGlobals.coverageInterval / TLCGlobals.progressInterval;\r\n                } else {\r\n                    count--;\r\n                }\r\n            }\r\n            if (this.done)\r\n                break;\r\n        }\r\n    }\r\n    for (int i = 0; i < workers.length; i++) {\r\n        workers[i].join();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "tlc2.tool.liveness.TableauDiskGraphTest.testNodeSetDone",
	"Comment": "test how an initial node transitions through the done state",
	"Method": "void testNodeSetDone(){\r\n    final TableauDiskGraph dg = (TableauDiskGraph) getDiskGraph();\r\n    final long fingerprint = 1L;\r\n    dg.addInitNode(fingerprint, 0);\r\n    assertFalse(dg.isDone(fingerprint));\r\n    GraphNode node = new GraphNode(fingerprint, 0);\r\n    node.addTransition(fingerprint, 1, NUMBER_OF_SOLUTIONS, NUMBER_OF_ACTIONS, NO_ACTIONS, NUMBER_OF_ACTIONS, 0);\r\n    dg.addNode(node);\r\n    assertTrue(dg.isDone(fingerprint));\r\n}"
}, {
	"Path": "teammates.logic.core.CoursesLogic.getSectionsNameForCourse",
	"Comment": "returns a list of section names for a course with or without a need tocheck if the course is existent.",
	"Method": "List<String> getSectionsNameForCourse(String courseId,List<String> getSectionsNameForCourse,String courseId,boolean isCourseVerified){\r\n    if (!isCourseVerified) {\r\n        verifyCourseIsPresent(courseId);\r\n    }\r\n    List<StudentAttributes> studentDataList = studentsLogic.getStudentsForCourse(courseId);\r\n    Set<String> sectionNameSet = new HashSet();\r\n    for (StudentAttributes sd : studentDataList) {\r\n        if (!sd.section.equals(Const.DEFAULT_SECTION)) {\r\n            sectionNameSet.add(sd.section);\r\n        }\r\n    }\r\n    List<String> sectionNameList = new ArrayList(sectionNameSet);\r\n    sectionNameList.sort(null);\r\n    return sectionNameList;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.handler.OpenModuleHandler.openModule",
	"Comment": "this was the body of the execute, but was pulled out so it could beused in other places to open a module.",
	"Method": "void openModule(String moduleName){\r\n    if (moduleName == null) {\r\n        throw new RuntimeException(\"Module was null\");\r\n    }\r\n    Spec spec = Activator.getSpecManager().getSpecLoaded();\r\n    final IFile module = ResourceHelper.getLinkedFile(spec.getProject(), ResourceHelper.getModuleFileName(moduleName));\r\n    if (module == null) {\r\n        throw new RuntimeException(\"Module \" + moduleName + \" could not be found\");\r\n    }\r\n    IEditorPart part = UIHelper.openEditor(OpenSpecHandler.TLA_EDITOR, new FileEditorInput(module));\r\n    part.addPropertyListener(new IPropertyListener() {\r\n        public void propertyChanged(Object source, int propId) {\r\n            if (IWorkbenchPartConstants.PROP_DIRTY == propId) {\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.handler.OpenModuleHandler.openModule",
	"Comment": "this was the body of the execute, but was pulled out so it could beused in other places to open a module.",
	"Method": "void openModule(String moduleName){\r\n    if (IWorkbenchPartConstants.PROP_DIRTY == propId) {\r\n    }\r\n}"
}, {
	"Path": "pcal.TLAToken.Clone",
	"Comment": "modified by ll on 6 dec 2011 to set the source field too. and on 14 dec 2011 to set the beginsubst and endsubst fields.",
	"Method": "TLAToken Clone(){\r\n    TLAToken result = new TLAToken(this.string, this.column, this.type);\r\n    result.source = this.source;\r\n    result.beginSubst = (Vector) this.beginSubst.clone();\r\n    result.endSubst = (Vector) this.endSubst.clone();\r\n    result.isAppended = this.isAppended;\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.itd.InvocableMemberBodyBuilder.newLine",
	"Comment": "prints a blank line, ensuring any indent is included before doing so.",
	"Method": "InvocableMemberBodyBuilder newLine(InvocableMemberBodyBuilder newLine,boolean indentBefore){\r\n    if (indentBefore) {\r\n        appendIndent();\r\n    }\r\n    stringBuilder.append(\"\\n\");\r\n    return this;\r\n}"
}, {
	"Path": "teammates.common.util.FieldValidator.getInvalidityInfoForCommentGiverType",
	"Comment": "checks if comment giver type is either instructor, student or team.",
	"Method": "String getInvalidityInfoForCommentGiverType(FeedbackParticipantType commentGiverType){\r\n    Assumption.assertNotNull(\"Non-null value expected\", commentGiverType);\r\n    if (!commentGiverType.equals(FeedbackParticipantType.STUDENTS) && !commentGiverType.equals(FeedbackParticipantType.INSTRUCTORS) && !commentGiverType.equals(FeedbackParticipantType.TEAMS)) {\r\n        return \"Invalid comment giver type: \" + commentGiverType;\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "teammates.test.driver.EmailChecker.injectTestProperties",
	"Comment": "injects values specified in configuration files to the appropriate placeholders.",
	"Method": "String injectTestProperties(String emailContent){\r\n    return emailContent.replace(\"${app.url}\", Config.APP_URL).replace(\"${support.email}\", Config.SUPPORT_EMAIL);\r\n}"
}, {
	"Path": "teammates.ui.pagedata.StudentFeedbackResultsPageData.createResponseTables",
	"Comment": "creates feedback results responses tables for every recipient.",
	"Method": "List<FeedbackResultsResponseTable> createResponseTables(FeedbackQuestionAttributes question,List<FeedbackResponseAttributes> responsesBundle){\r\n    List<FeedbackResultsResponseTable> responseTables = new ArrayList();\r\n    List<String> recipients = new ArrayList();\r\n    for (FeedbackResponseAttributes singleResponse : responsesBundle) {\r\n        if (!recipients.contains(singleResponse.recipient)) {\r\n            recipients.add(singleResponse.recipient);\r\n        }\r\n    }\r\n    for (String recipient : recipients) {\r\n        List<FeedbackResponseAttributes> responsesForRecipient = filterResponsesByRecipientEmail(recipient, responsesBundle);\r\n        boolean isUserRecipient = student.email.equals(recipient);\r\n        boolean isUserTeamRecipient = question.recipientType == FeedbackParticipantType.TEAMS && student.team.equals(recipient);\r\n        String recipientName;\r\n        if (isUserRecipient) {\r\n            recipientName = \"You\";\r\n        } else if (isUserTeamRecipient) {\r\n            recipientName = String.format(\"Your Team (%s)\", bundle.getNameForEmail(recipient));\r\n        } else {\r\n            recipientName = bundle.getNameForEmail(recipient);\r\n        }\r\n        responseTables.add(createResponseTable(question, responsesForRecipient, recipientName));\r\n    }\r\n    return responseTables;\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.AnimatedGifEncoder.setDispose",
	"Comment": "sets the gif frame disposal code for the last added frame and anysubsequent frames. default is 0 if no transparent color has been set,otherwise 2.",
	"Method": "void setDispose(int code){\r\n    if (code >= 0) {\r\n        dispose = code;\r\n    }\r\n}"
}, {
	"Path": "tla2sany.parser.TLAplusParser.ElementaryExpression",
	"Comment": "l.generalid, l.opapplication, l.string, l.number, l.genop...",
	"Method": "SyntaxTreeNode ElementaryExpression(){\r\n    SyntaxTreeNode tn;\r\n    Token t;\r\n    bpa(\"Elementary expression\");\r\n    switch((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\r\n        case op_57:\r\n        case op_68:\r\n        case op_69:\r\n        case op_70:\r\n        case op_26:\r\n        case op_29:\r\n        case op_58:\r\n        case CASESEP:\r\n        case op_61:\r\n        case op_112:\r\n        case op_113:\r\n        case op_114:\r\n        case op_115:\r\n        case op_116:\r\n        case op_1:\r\n        case AND:\r\n        case op_3:\r\n        case op_4:\r\n        case OR:\r\n        case op_6:\r\n        case op_7:\r\n        case op_8:\r\n        case op_9:\r\n        case op_10:\r\n        case op_11:\r\n        case op_12:\r\n        case op_13:\r\n        case op_14:\r\n        case op_15:\r\n        case op_16:\r\n        case op_17:\r\n        case op_18:\r\n        case op_19:\r\n        case IN:\r\n        case op_21:\r\n        case op_22:\r\n        case op_23:\r\n        case op_24:\r\n        case op_25:\r\n        case op_27:\r\n        case op_30:\r\n        case op_31:\r\n        case op_32:\r\n        case op_33:\r\n        case op_34:\r\n        case op_35:\r\n        case op_36:\r\n        case op_37:\r\n        case op_38:\r\n        case op_39:\r\n        case op_40:\r\n        case op_41:\r\n        case op_42:\r\n        case op_43:\r\n        case op_44:\r\n        case op_45:\r\n        case op_46:\r\n        case op_47:\r\n        case op_48:\r\n        case op_49:\r\n        case op_50:\r\n        case op_51:\r\n        case op_52:\r\n        case op_53:\r\n        case op_54:\r\n        case op_55:\r\n        case op_56:\r\n        case op_59:\r\n        case op_62:\r\n        case op_63:\r\n        case op_64:\r\n        case EQUALS:\r\n        case op_66:\r\n        case op_67:\r\n        case op_71:\r\n        case op_72:\r\n        case op_73:\r\n        case op_74:\r\n        case op_75:\r\n        case op_77:\r\n        case op_78:\r\n        case op_79:\r\n        case op_80:\r\n        case op_81:\r\n        case op_82:\r\n        case op_83:\r\n        case op_84:\r\n        case op_85:\r\n        case op_86:\r\n        case op_87:\r\n        case op_88:\r\n        case op_89:\r\n        case op_90:\r\n        case op_91:\r\n        case op_92:\r\n        case op_93:\r\n        case op_94:\r\n        case op_95:\r\n        case op_96:\r\n        case op_97:\r\n        case op_98:\r\n        case op_100:\r\n        case op_101:\r\n        case op_102:\r\n        case op_103:\r\n        case op_104:\r\n        case op_105:\r\n        case op_106:\r\n        case op_107:\r\n        case op_108:\r\n        case op_109:\r\n        case op_110:\r\n        case op_111:\r\n        case op_117:\r\n        case op_118:\r\n        case op_119:\r\n        case IDENTIFIER:\r\n            tn = Extension();\r\n            break;\r\n        case STRING_LITERAL:\r\n            tn = String();\r\n            epa();\r\n            break;\r\n        case NUMBER_LITERAL:\r\n            tn = Number();\r\n            epa();\r\n            break;\r\n        default:\r\n            jj_la1[81] = jj_gen;\r\n            jj_consume_token(-1);\r\n            throw new ParseException();\r\n    }\r\n    {\r\n        if (true)\r\n            return tn;\r\n    }\r\n    throw new Error(\"Missing return statement in function\");\r\n}"
}, {
	"Path": "teammates.storage.search.SearchManager.putDocumentsWithRetry",
	"Comment": "tries putting multiple documents, handling transient errors by retrying with exponential backoff.",
	"Method": "void putDocumentsWithRetry(String indexName,List<Document> documents){\r\n    Index index = getIndex(indexName);\r\n    RM.runUntilSuccessful(new RetryableTaskThrows<PutException>(\"Put documents\") {\r\n        private List<Document> documentsToPut = documents;\r\n        private List<OperationResult> lastResults;\r\n        private List<String> lastIds;\r\n        @Override\r\n        public void run() throws PutException {\r\n            try {\r\n                PutResponse response = index.put(documentsToPut);\r\n                lastResults = response.getResults();\r\n                lastIds = response.getIds();\r\n            } catch (PutException e) {\r\n                lastResults = e.getResults();\r\n                lastIds = e.getIds();\r\n            }\r\n        }\r\n        @Override\r\n        public boolean isSuccessful() {\r\n            boolean hasTransientError = false;\r\n            List<Document> failedDocuments = new ArrayList();\r\n            for (int i = 0; i < documentsToPut.size(); i++) {\r\n                StatusCode code = lastResults.get(i).getCode();\r\n                if (!StatusCode.OK.equals(code)) {\r\n                    failedDocuments.add(documentsToPut.get(i));\r\n                    if (StatusCode.TRANSIENT_ERROR.equals(code)) {\r\n                        hasTransientError = true;\r\n                    }\r\n                }\r\n            }\r\n            documentsToPut = failedDocuments;\r\n            finalMessage = lastResults.get(0).getMessage();\r\n            finalData = documentsToPut;\r\n            if (documentsToPut.isEmpty()) {\r\n                return true;\r\n            } else if (hasTransientError) {\r\n                return false;\r\n            } else {\r\n                throw new PutException(lastResults.get(0), lastResults, lastIds);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "teammates.storage.search.SearchManager.putDocumentsWithRetry",
	"Comment": "tries putting multiple documents, handling transient errors by retrying with exponential backoff.",
	"Method": "void putDocumentsWithRetry(String indexName,List<Document> documents){\r\n    try {\r\n        PutResponse response = index.put(documentsToPut);\r\n        lastResults = response.getResults();\r\n        lastIds = response.getIds();\r\n    } catch (PutException e) {\r\n        lastResults = e.getResults();\r\n        lastIds = e.getIds();\r\n    }\r\n}"
}, {
	"Path": "teammates.storage.search.SearchManager.putDocumentsWithRetry",
	"Comment": "tries putting multiple documents, handling transient errors by retrying with exponential backoff.",
	"Method": "void putDocumentsWithRetry(String indexName,List<Document> documents){\r\n    boolean hasTransientError = false;\r\n    List<Document> failedDocuments = new ArrayList();\r\n    for (int i = 0; i < documentsToPut.size(); i++) {\r\n        StatusCode code = lastResults.get(i).getCode();\r\n        if (!StatusCode.OK.equals(code)) {\r\n            failedDocuments.add(documentsToPut.get(i));\r\n            if (StatusCode.TRANSIENT_ERROR.equals(code)) {\r\n                hasTransientError = true;\r\n            }\r\n        }\r\n    }\r\n    documentsToPut = failedDocuments;\r\n    finalMessage = lastResults.get(0).getMessage();\r\n    finalData = documentsToPut;\r\n    if (documentsToPut.isEmpty()) {\r\n        return true;\r\n    } else if (hasTransientError) {\r\n        return false;\r\n    } else {\r\n        throw new PutException(lastResults.get(0), lastResults, lastIds);\r\n    }\r\n}"
}, {
	"Path": "tla2sany.semantic.OpDefNode.levelDataToString",
	"Comment": "tostring, leveldatatostring, and walkgraph methods to implementexplorenode interface",
	"Method": "String levelDataToString(){\r\n    if ((this.getKind() == ModuleInstanceKind) || (this.getKind() == NumberedProofStepKind)) {\r\n        return \"\";\r\n    }\r\n    ;\r\n    if (this.arity < 0) {\r\n        return \"Arity: \" + this.arity + \"\\n\" + \"Level: \" + this.getLevel() + \"\\n\" + \"MaxLevel: \" + this.maxLevels[0] + \"\\n\";\r\n    } else {\r\n        String maxLevelStr = \"\";\r\n        for (int i = 0; i < this.maxLevels.length; i++) {\r\n            if (i > 0) {\r\n                maxLevelStr = maxLevelStr + \", \";\r\n            }\r\n            ;\r\n            maxLevelStr = maxLevelStr + this.maxLevels[i];\r\n        }\r\n        ;\r\n        String isLeibnizArgStr = \"\";\r\n        for (int i = 0; i < this.isLeibnizArg.length; i++) {\r\n            if (i > 0) {\r\n                isLeibnizArgStr = isLeibnizArgStr + \", \";\r\n            }\r\n            ;\r\n            isLeibnizArgStr = isLeibnizArgStr + this.isLeibnizArg[i];\r\n        }\r\n        ;\r\n        String opLevelCondStr = \"\";\r\n        if (opLevelCond != null) {\r\n            opLevelCondStr = \"[\";\r\n            for (int i = 0; i < opLevelCond.length; i++) {\r\n                opLevelCondStr = opLevelCondStr + \" [\";\r\n                for (int j = 0; j < opLevelCond[i].length; j++) {\r\n                    opLevelCondStr = opLevelCondStr + \" [\";\r\n                    for (int k = 0; k < opLevelCond[i][j].length; k++) {\r\n                        String foo = \" \";\r\n                        if (k == 0) {\r\n                            foo = \"\";\r\n                        }\r\n                        opLevelCondStr = opLevelCondStr + foo + this.opLevelCond[i][j][k];\r\n                    }\r\n                    opLevelCondStr = opLevelCondStr + \"]\";\r\n                }\r\n                opLevelCondStr = opLevelCondStr + \"]\";\r\n            }\r\n            ;\r\n            opLevelCondStr = opLevelCondStr + \"]\";\r\n        }\r\n        ;\r\n        return \"Arity: \" + this.arity + \"\\n\" + \"Level: \" + this.getLevel() + \"\\n\" + \"LevelParams: \" + this.getLevelParams() + \"\\n\" + \"LevelConstraints: \" + this.getLevelConstraints() + \"\\n\" + \"ArgLevelConstraints: \" + this.getArgLevelConstraints() + \"\\n\" + \"ArgLevelParams: \" + ALPHashSetToString(this.getArgLevelParams()) + \"\\n\" + \"MaxLevel: \" + maxLevelStr + \"\\n\" + \"opLevelCond: \" + opLevelCondStr + \"\\n\" + \"AllParams: \" + HashSetToString(this.getAllParams()) + \"\\n\" + \"NonLeibnizParams: \" + HashSetToString(this.getNonLeibnizParams()) + \"\\n\" + \"IsLeibniz: \" + this.isLeibniz + \"\\n\" + \"isLeibnizArg: \" + isLeibnizArgStr + \"\\n\";\r\n    }\r\n}"
}, {
	"Path": "com.facebook.swift.codec.metadata.ThriftCatalog.getThriftType",
	"Comment": "gets the thrifttype for the specified java type.the native thrift type for the java type willbe inferred from the java type, and if necessary type coercions will be applied.",
	"Method": "ThriftType getThriftType(Type javaType){\r\n    ThriftType thriftType = getThriftTypeFromCache(javaType);\r\n    if (thriftType == null) {\r\n        thriftType = buildThriftType(javaType);\r\n    }\r\n    return thriftType;\r\n}"
}, {
	"Path": "teammates.storage.entity.FeedbackResponseComment.getFeedbackResponseCommentId",
	"Comment": "use only if the comment already persisted in the datastore and id generated by gae.",
	"Method": "Long getFeedbackResponseCommentId(){\r\n    return feedbackResponseCommentId;\r\n}"
}, {
	"Path": "tla2sany.semantic.AssumeProveNode.getChildren",
	"Comment": "the children of this node are the assumes and prove expressions.",
	"Method": "SemanticNode[] getChildren(){\r\n    SemanticNode[] res = new SemanticNode[this.assumes.length + 1];\r\n    res[assumes.length] = this.prove;\r\n    for (int i = 0; i < assumes.length; i++) {\r\n        res[i] = assumes[i];\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.InstructorAttributes.isAllowedForPrivilegeAnySection",
	"Comment": "returns true if privilege for session is present for any section.",
	"Method": "boolean isAllowedForPrivilegeAnySection(String sessionName,String privilegeName){\r\n    if (privileges == null) {\r\n        privileges = new InstructorPrivileges(Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_COOWNER);\r\n    }\r\n    return privileges.isAllowedForPrivilegeAnySection(sessionName, privilegeName);\r\n}"
}, {
	"Path": "util.BufferedDataInputStream.readByte",
	"Comment": "reads and returns the next byte of this stream, or throwseofexception if the stream is exhausted.",
	"Method": "byte readByte(){\r\n    if (this.len < 0)\r\n        throw new EOFException();\r\n    byte res = this.buff[this.curr++];\r\n    if (this.curr == this.len) {\r\n        this.len = this.in.read(this.buff);\r\n        Assert.check(this.len != 0, EC.SYSTEM_STREAM_EMPTY);\r\n        this.curr = 0;\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "teammates.logic.core.InstructorsLogic.putDocuments",
	"Comment": "batch creates or updates documents for the given instructors.",
	"Method": "void putDocuments(List<InstructorAttributes> instructors){\r\n    instructorsDb.putDocuments(instructors);\r\n}"
}, {
	"Path": "org.springframework.roo.shell.ShellContextImpl.setParameters",
	"Comment": "set a list of parameters like defined parameters on spring roo shell",
	"Method": "void setParameters(Map<String, String> parameters){\r\n    for (Entry<String, String> param : parameters.entrySet()) {\r\n        setParameter(param.getKey(), param.getValue());\r\n    }\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.AnimatedGifEncoder.setTransparent",
	"Comment": "sets the transparent color for the last added frame and any subsequentframes. since all colors are subject to modification in the quantizationprocess, the color in the final palette for each frame closest to the givencolor becomes the transparent color for that frame. may be set to null toindicate no transparent color.",
	"Method": "void setTransparent(int c){\r\n    transparent = c;\r\n}"
}, {
	"Path": "teammates.client.scripts.statistics.StatisticsBundle.getInstituteStatsSortByTotalStudentsDescending",
	"Comment": "gets a list of institute stats sorted by the number of students inside institute.",
	"Method": "List<InstituteStats> getInstituteStatsSortByTotalStudentsDescending(){\r\n    List<InstituteStats> instituteStatsList = new ArrayList(institutesStats.values());\r\n    instituteStatsList.sort(Comparator.comparing(InstituteStats::getStudentTotal).reversed());\r\n    return instituteStatsList;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackRankQuestionDetails.updateOptionRanksMapping",
	"Comment": "updates the mapping of ranks for the option optionreceivingpoints.",
	"Method": "void updateOptionRanksMapping(Map<String, List<Integer>> optionRanks,String optionReceivingRanks,int rankReceived){\r\n    optionRanks.computeIfAbsent(optionReceivingRanks, key -> new ArrayList()).add(rankReceived);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.WsEndpointsMetadata.getOpenEntityManagerInViewFilterMethod",
	"Comment": "this method obtains the method that register the openentitymanagerinview filter",
	"Method": "MethodMetadata getOpenEntityManagerInViewFilterMethod(){\r\n    if (openEntityManagerInViewFilterMethod != null) {\r\n        return openEntityManagerInViewFilterMethod;\r\n    }\r\n    JavaType filterRegistrationBeanType = new JavaType(\"org.springframework.boot.context.embedded.FilterRegistrationBean\");\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    bodyBuilder.appendFormalLine(\"%s filterRegBean = new FilterRegistrationBean();\", getNameOfJavaType(filterRegistrationBeanType));\r\n    bodyBuilder.appendFormalLine(\"filterRegBean.setFilter(new %s());\", getNameOfJavaType(new JavaType(\"org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter\")));\r\n    bodyBuilder.appendFormalLine(\"%s<String> urlPatterns = new %s<String>();\", getNameOfJavaType(JavaType.LIST), getNameOfJavaType(JavaType.ARRAY_LIST));\r\n    bodyBuilder.appendFormalLine(\"urlPatterns.add(%s() + \\\"/*\\\");\", getAccessorMethod(getServletField()).getMethodName());\r\n    bodyBuilder.appendFormalLine(\"filterRegBean.setUrlPatterns(urlPatterns);\");\r\n    bodyBuilder.appendFormalLine(\"if (%s().isDebugEnabled()) {\", getAccessorMethod(getLoggerField()).getMethodName());\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\"%s().debug(\\\"Registering the 'OpenEntityManagerInViewFilter' filter for the '\\\"\", getAccessorMethod(getLoggerField()).getMethodName());\r\n    bodyBuilder.indent();\r\n    bodyBuilder.appendFormalLine(\".concat(%s() + \\\"/*\\\").concat(\\\"' URL.\\\"));\", getAccessorMethod(getServletField()).getMethodName());\r\n    bodyBuilder.indentRemove();\r\n    bodyBuilder.indentRemove();\r\n    bodyBuilder.appendFormalLine(\"}\");\r\n    bodyBuilder.appendFormalLine(\"return filterRegBean;\");\r\n    MethodMetadataBuilder method = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, new JavaSymbolName(\"openEntityManagerInViewFilter\"), filterRegistrationBeanType, bodyBuilder);\r\n    method.addAnnotation(new AnnotationMetadataBuilder(SpringJavaType.BEAN));\r\n    openEntityManagerInViewFilterMethod = method.build();\r\n    return openEntityManagerInViewFilterMethod;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tla2tex.PDFHandlerThreadingTest.assertNoBackendCodeInUIThread",
	"Comment": "checks how many invocations of backend code have happend inside the ui thread",
	"Method": "void assertNoBackendCodeInUIThread(){\r\n    Assert.assertTrue(\"Test requires active MonitorAspect aspect!\", MonitorAdaptor.aspectIsActive());\r\n    Assert.assertFalse(\"Backend code (e.g. parsing must not be executed in UI thread) times executed: \" + MonitorAdaptor.getTriggeredJoinPoints().size(), MonitorAdaptor.hasTriggeredBackendCode());\r\n    MonitorAdaptor.reset();\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackResponsesDb.hasFeedbackResponseEntitiesForCourse",
	"Comment": "returns true if there are existing responses in any feedback session in the course.",
	"Method": "boolean hasFeedbackResponseEntitiesForCourse(String courseId){\r\n    Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);\r\n    return !getFeedbackResponseEntitiesForCourseWithinRange(courseId, 1).isEmpty();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.ResourceHelper.getTLALibraryPath",
	"Comment": "modified by ll on 28 nov 2012 to make locationlist a vector instead of ahashset. with a hashset, it returned the library paths in an order thatwas mostly independent of the order of the paths specified by the user.",
	"Method": "String[] getTLALibraryPath(IProject project){\r\n    final IPreferenceStore store = PreferenceStoreHelper.getProjectPreferenceStore(project);\r\n    String prefStr = store.getString(LibraryPathComposite.LIBRARY_PATH_LOCATION_PREFIX);\r\n    if (\"\".equals(prefStr)) {\r\n        prefStr = PreferenceStoreHelper.getInstancePreferenceStore().getString(LibraryPathComposite.LIBRARY_PATH_LOCATION_PREFIX);\r\n    }\r\n    if (!\"\".equals(prefStr)) {\r\n        final Vector<String> locationList = new Vector<String>();\r\n        final String[] locations = prefStr.split(LibraryPathComposite.ESCAPE_REGEX + LibraryPathComposite.LOCATION_DELIM);\r\n        for (String location : locations) {\r\n            final String[] split = location.split(LibraryPathComposite.ESCAPE_REGEX + LibraryPathComposite.STATE_DELIM);\r\n            if (Boolean.parseBoolean(split[1])) {\r\n                locationList.add(split[0]);\r\n            }\r\n        }\r\n        return locationList.toArray(new String[locationList.size()]);\r\n    }\r\n    return new String[0];\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.waitForTextContainedInElementPresence",
	"Comment": "waits for text contained in the element to appear in the page, or timeout.",
	"Method": "void waitForTextContainedInElementPresence(By by,String text){\r\n    waitFor(ExpectedConditions.textToBePresentInElementLocated(by, text));\r\n}"
}, {
	"Path": "tlc2.tool.liveness.TableauDiskGraphTest.testGetPathWithTwoInits",
	"Comment": "test that getpath returns the correct init state if the graph contains\tmultiple initial states with the same fingerprint but different tableau idxs.",
	"Method": "void testGetPathWithTwoInits(){\r\n    final AbstractDiskGraph dg = getDiskGraph();\r\n    final long fingerprint = 1L;\r\n    dg.addInitNode(fingerprint, 0);\r\n    dg.addInitNode(fingerprint, 1);\r\n    try {\r\n        dg.createCache();\r\n        dg.getPath(fingerprint, 2);\r\n        dg.destroyCache();\r\n    } catch (RuntimeException e) {\r\n        dg.addInitNode(fingerprint, 2);\r\n        dg.createCache();\r\n        LongVec path = dg.getPath(fingerprint, 2);\r\n        dg.destroyCache();\r\n        assertEquals(1, path.size());\r\n        assertEquals(fingerprint, path.elementAt(0));\r\n        return;\r\n    }\r\n    fail(\"Returned path to non-existing node\");\r\n}"
}, {
	"Path": "teammates.test.driver.BackDoor.getEncryptedKeyForStudent",
	"Comment": "gets the encrypted registration key for a student in the datastore.",
	"Method": "String getEncryptedKeyForStudent(String courseId,String studentEmail){\r\n    Map<String, String> params = createParamMap(BackDoorOperation.OPERATION_GET_ENCRYPTED_KEY_FOR_STUDENT);\r\n    params.put(BackDoorOperation.PARAMETER_COURSE_ID, courseId);\r\n    params.put(BackDoorOperation.PARAMETER_STUDENT_EMAIL, studentEmail);\r\n    return makePostRequest(params);\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorCoursesPage.addCourse",
	"Comment": "if instructorslist is null, the current value in the page will be used instead.",
	"Method": "InstructorCoursesPage addCourse(String courseId,String courseName){\r\n    fillTextBox(courseIdTextBox, courseId);\r\n    fillTextBox(courseNameTextBox, courseName);\r\n    click(submitButton);\r\n    waitForPageToLoad();\r\n    return this;\r\n}"
}, {
	"Path": "tla2sany.modanalyzer.SpecObj.getSemanticErrors",
	"Comment": "returns errors object containing errors found during semanticprocessing and level checking.",
	"Method": "Errors getSemanticErrors(){\r\n    return semanticErrors;\r\n}"
}, {
	"Path": "tlc2.util.List.member",
	"Comment": "this method returns true iff the argument is a member ofthe list. the equality check is on reference.",
	"Method": "boolean member(Object value){\r\n    ConsCell cell = this.first;\r\n    boolean isMember = false;\r\n    while (cell != null) {\r\n        if (cell.value == value) {\r\n            isMember = true;\r\n            break;\r\n        }\r\n        cell = cell.next;\r\n    }\r\n    return isMember;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.ResourceHelper.earlierLine",
	"Comment": "true iff the beginning line of loc1 is less than the beginning line of loc2.",
	"Method": "boolean earlierLine(Location loc1,Location loc2){\r\n    return loc1.beginLine() < loc2.beginLine();\r\n}"
}, {
	"Path": "teammates.logic.core.CoursesLogic.restoreCourseFromRecycleBin",
	"Comment": "restores a course from recycle bin by its given corresponding id.",
	"Method": "void restoreCourseFromRecycleBin(String courseId){\r\n    CourseAttributes course = coursesDb.getCourse(courseId);\r\n    course.resetDeletedAt();\r\n    coursesDb.updateCourse(course);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.FontPreferenceChangeListener.removeControl",
	"Comment": "removes a control from the set of controls whose font should beset when the preference corresponding to preferencename is changed",
	"Method": "void removeControl(Control control){\r\n    controls.remove(control);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.InstructorPrivileges.removeSessionsPrivilegesForSection",
	"Comment": "removes special settings for all sessionnames in sectionname.",
	"Method": "void removeSessionsPrivilegesForSection(String sectionName){\r\n    if (this.sessionLevel.containsKey(sectionName)) {\r\n        this.sessionLevel.remove(sectionName);\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.distributed.TLCWorker.getSet",
	"Comment": "todo remove once performance tests show superiority of treeset",
	"Method": "Set<Holder> getSet(){\r\n    if (unsorted) {\r\n        return new HashSet<Holder>();\r\n    } else {\r\n        return new TreeSet<Holder>();\r\n    }\r\n}"
}, {
	"Path": "teammates.ui.controller.AdminActivityLogPageAction.filterLogsForActivityLogPage",
	"Comment": "filters logs that should be shown on admin activity log page.",
	"Method": "List<ActivityLogEntry> filterLogsForActivityLogPage(List<AppLogLine> appLogLines,AdminActivityLogPageData data){\r\n    List<ActivityLogEntry> appLogs = new LinkedList();\r\n    for (AppLogLine appLog : appLogLines) {\r\n        String logMsg = appLog.getLogMessage();\r\n        boolean isNotTeammatesLog = !logMsg.contains(\"TEAMMATESLOG\");\r\n        boolean isLogFromAdminActivityLogPage = logMsg.contains(\"adminActivityLogPage\");\r\n        if (isNotTeammatesLog || isLogFromAdminActivityLogPage) {\r\n            continue;\r\n        }\r\n        ActivityLogEntry activityLogEntry = ActivityLogEntry.buildFromAppLog(appLog);\r\n        boolean isToShow = data.filterLog(activityLogEntry) && (!activityLogEntry.isTestingData() || data.getShouldShowTestData());\r\n        if (!isToShow) {\r\n            continue;\r\n        }\r\n        appLogs.add(activityLogEntry);\r\n    }\r\n    return appLogs;\r\n}"
}, {
	"Path": "teammates.common.util.HttpRequestHelper.getCookieValueFromRequest",
	"Comment": "returns the cookie value, or null if said cookie does not exist.",
	"Method": "String getCookieValueFromRequest(HttpServletRequest req,String cookieName){\r\n    Cookie[] existingCookies = req.getCookies();\r\n    if (existingCookies == null) {\r\n        return null;\r\n    }\r\n    for (Cookie cookie : existingCookies) {\r\n        if (cookie.getName().equals(cookieName)) {\r\n            return cookie.getValue();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.AbstractMemberHoldingTypeDetailsBuilder.getExtendsTypes",
	"Comment": "returns the types that the built instance will extend, if any. does notreturn a copy, i.e. modifying the returned list will modify this builder!todo improve encapsulation by returning a defensive copy andupdating callers accordingly",
	"Method": "List<JavaType> getExtendsTypes(){\r\n    return extendsTypes;\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.VideoMatcherUtil.isTwitterGifLink",
	"Comment": "used to put a badge on the videos on the adapters and tweetview",
	"Method": "boolean isTwitterGifLink(String link){\r\n    if (link == null)\r\n        return false;\r\n    if (link.contains(\"dm_gif\")) {\r\n        return true;\r\n    }\r\n    return (link.contains(\"/photo/1\") && link.contains(\"twitter.com/\")) || (link.contains(\"video.twimg.com/tweet_video\") || link.contains(\"pbs.twimg.com/tweet_video\"));\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.MapAbstractTest.isSubMapViewsSerializable",
	"Comment": "returns whether the sub map views of sortedmap are serializable.if the class being tested is based around a treemap then you shouldoverride and return false as treemap has a bug in deserialization.",
	"Method": "boolean isSubMapViewsSerializable(){\r\n    return true;\r\n}"
}, {
	"Path": "org.squirrelframework.foundation.component.SquirrelProvider.register",
	"Comment": "register the implementation class for a certain class. note, if there is already an entry in the registry forthe class, then it will be overwritten.",
	"Method": "void register(Class<?> clazz,Class<?> implementationClass){\r\n    implementationRegistry.put(clazz, implementationClass);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.FeedbackSessionAttributes.isOpened",
	"Comment": "returns true if the session is currently open and accepting responses.",
	"Method": "boolean isOpened(){\r\n    Instant now = Instant.now();\r\n    return (now.isAfter(startTime) || now.equals(startTime)) && now.isBefore(endTime);\r\n}"
}, {
	"Path": "tlc2.tool.distributed.fp.DynamicFPSetManagerTest.testCtorMax",
	"Comment": "test that the ctor correctly calculates its mask used to index fpset\tservers for valid values.",
	"Method": "void testCtorMax(){\r\n    DynamicFPSetManager dynamicFPSetManager = new DynamicFPSetManager(Integer.MAX_VALUE);\r\n    long mask = dynamicFPSetManager.getMask();\r\n    assertEquals((Integer.MAX_VALUE), mask);\r\n}"
}, {
	"Path": "teammates.client.scripts.statistics.CourseToInstituteCache.asMap",
	"Comment": "gets the a map that represents the mapping between courseid and institute.",
	"Method": "Map<String, String> asMap(){\r\n    return cache.asMap();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.output.data.ColorPredicate.printBitVectorOfStates",
	"Comment": "for debugging.prints the list of states represented by a bit vector.",
	"Method": "void printBitVectorOfStates(long vector){\r\n    System.out.println(bitVectorOfStatesToString(vector));\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.StringUtil.substring",
	"Comment": "gets the first substring between the given string boundaries.",
	"Method": "String substring(String pSource,String pBeginBoundaryString,String pEndBoundaryString,int pOffset){\r\n    int offset = (pOffset < 0) ? 0 : pOffset;\r\n    int startIndex = pSource.indexOf(pBeginBoundaryString, offset) + pBeginBoundaryString.length();\r\n    if (startIndex < 0) {\r\n        return null;\r\n    }\r\n    int endIndex = pSource.indexOf(pEndBoundaryString, startIndex);\r\n    if (endIndex < 0) {\r\n        return null;\r\n    }\r\n    return pSource.substring(startIndex, endIndex);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.suite.AddonSuiteSymbolicNameConverter.populateRooAddonSuites",
	"Comment": "method to populate current roo addon suites using osgi serive",
	"Method": "void populateRooAddonSuites(){\r\n    installedSubsystems.clear();\r\n    try {\r\n        ServiceReference<?>[] references = context.getAllServiceReferences(Subsystem.class.getName(), null);\r\n        for (ServiceReference<?> ref : references) {\r\n            Subsystem subsystem = (Subsystem) context.getService(ref);\r\n            installedSubsystems.add(subsystem);\r\n        }\r\n    } catch (InvalidSyntaxException e) {\r\n        LOGGER.warning(\"Cannot load Subsystem on AddonSymbolicName.\");\r\n    }\r\n}"
}, {
	"Path": "teammates.logic.api.TaskQueuer.scheduleCourseRegistrationInviteToStudent",
	"Comment": "schedules for course registration to be sent to the specified student.",
	"Method": "void scheduleCourseRegistrationInviteToStudent(String courseId,String studentEmail,boolean isRejoining){\r\n    Map<String, String> paramMap = new HashMap();\r\n    paramMap.put(ParamsNames.COURSE_ID, courseId);\r\n    paramMap.put(ParamsNames.STUDENT_EMAIL, studentEmail);\r\n    paramMap.put(ParamsNames.IS_STUDENT_REJOINING, String.valueOf(isRejoining));\r\n    addTask(TaskQueue.STUDENT_COURSE_JOIN_EMAIL_QUEUE_NAME, TaskQueue.STUDENT_COURSE_JOIN_EMAIL_WORKER_URL, paramMap);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackQuestionDetails.getNoResponseText",
	"Comment": "returns text to indicate that there is no response between the giver and recipient.used in instructorfeedbackresultspage to show possible givers and recipients who didnot respond to the question in the feedback session.",
	"Method": "String getNoResponseText(String giverEmail,String recipientEmail,FeedbackSessionResultsBundle bundle,FeedbackQuestionAttributes question){\r\n    return Const.INSTRUCTOR_FEEDBACK_RESULTS_MISSING_RESPONSE;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.view.ObligationsView.updateItem",
	"Comment": "adds the information from the obligation status to the view.if there is already an item with information of the sameobligation as the status, that item is updated. if nosuch item exists, a new one is created.modified by ll on 1 nov 2012 to add the goto obligation buttonand remove the listener from the text widget so clicking onthe obligation text no longer goes to the obligation.",
	"Method": "void updateItem(ObligationStatus status){\r\n    int id = status.getId();\r\n    if (id != -1) {\r\n        ExpandItem item = items.get(new Integer(id));\r\n        if (!ProverHelper.isInterestingObligation(status)) {\r\n            if (item != null) {\r\n                removeItem(item);\r\n            }\r\n            return;\r\n        }\r\n        if (item == null) {\r\n            item = new ExpandItem(bar, SWT.None, 0);\r\n            item.setData(KEY, new Integer(id));\r\n            Composite oblWidget = new Composite(bar, SWT.LINE_SOLID);\r\n            GridLayout gl = new GridLayout(1, true);\r\n            gl.marginWidth = 0;\r\n            gl.marginHeight = 0;\r\n            oblWidget.setLayout(gl);\r\n            Composite buttonsWidget = new Composite(oblWidget, SWT.LINE_SOLID);\r\n            GridLayout buttonsGl = new GridLayout(2, true);\r\n            buttonsGl.marginWidth = 0;\r\n            buttonsGl.marginHeight = 0;\r\n            buttonsWidget.setLayout(buttonsGl);\r\n            buttonsWidget.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\r\n            Button stopButton = new Button(buttonsWidget, SWT.PUSH);\r\n            stopButton.setText(\"Stop Proving\");\r\n            stopButton.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\r\n            stopButton.setData(status.getObMarker());\r\n            stopButton.addSelectionListener(stopObListener);\r\n            item.setControl(oblWidget);\r\n            item.setData(KEY_BUTTON, stopButton);\r\n            Button gotoButton = new Button(buttonsWidget, SWT.PUSH);\r\n            gotoButton.setText(\"Goto Obligation\");\r\n            gotoButton.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\r\n            gotoButton.setData(status.getObMarker());\r\n            gotoButton.addSelectionListener(gotoObListener);\r\n            SourceViewer viewer = new SourceViewer(oblWidget, null, SWT.READ_ONLY | SWT.MULTI | SWT.H_SCROLL);\r\n            viewer.getTextWidget().setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\r\n            viewer.configure(new ObligationSourceViewerConfiguration());\r\n            viewer.getControl().setFont(JFaceResources.getTextFont());\r\n            fontListener.addControl(viewer.getControl());\r\n            viewers.put(item, viewer);\r\n            item.setControl(oblWidget);\r\n            item.setExpanded(true);\r\n            item.setData(status.getObMarker());\r\n            viewer.getTextWidget().setData(status.getObMarker());\r\n            oblWidget.setData(status.getObMarker());\r\n            item.addListener(SWT.MouseDown, obClickListener);\r\n            items.put(new Integer(id), item);\r\n        }\r\n        item.setText(\"Obligation \" + id + \" - status : \" + status.getProverStatusString());\r\n        Button button = (Button) item.getData(KEY_BUTTON);\r\n        button.setEnabled(ProverHelper.isBeingProvedObligation(status));\r\n        SourceViewer viewer = (SourceViewer) viewers.get(item);\r\n        Assert.isNotNull(viewer, \"Expand item has been created without a source viewer. This is a bug.\");\r\n        String oblString = status.getObligationString();\r\n        if (oblString == null) {\r\n            oblString = \"\";\r\n        }\r\n        if ((viewer.getDocument() == null || !viewer.getDocument().get().equals(oblString)) && !(oblString.length() == 0)) {\r\n            viewer.setDocument(new Document(oblString.trim()));\r\n            item.setHeight(item.getControl().computeSize(SWT.DEFAULT, SWT.DEFAULT, true).y);\r\n        } else if (oblString.length() == 0 && (viewer.getDocument() == null || viewer.getDocument().get().length() == 0)) {\r\n            viewer.setDocument(new Document(\"No obligation text available.\"));\r\n            item.setHeight(100);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.logic.api.GateKeeper.verifyAdminPrivileges",
	"Comment": "verifies that the logged in user is the admin and there is nomasquerading going on.",
	"Method": "void verifyAdminPrivileges(AccountAttributes account){\r\n    if (isUserLoggedOn() && userService.isUserAdmin() && getCurrentGoogleUser().getNickname().equals(account.googleId)) {\r\n        return;\r\n    }\r\n    throw new UnauthorizedAccessException(\"User \" + getCurrentGoogleUser().getNickname() + \" does not have admin privilleges\");\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.PhysicalTypeIdentifier.getJavaType",
	"Comment": "parses the given metadata id for the user project type to which itrelates.",
	"Method": "JavaType getJavaType(String physicalTypeId){\r\n    Validate.isTrue(PhysicalTypeIdentifier.isValid(physicalTypeId), \"Physical type identifier is invalid\");\r\n    return PhysicalTypeIdentifierNamingUtils.getJavaType(PHYSICAL_METADATA_TYPE, physicalTypeId);\r\n}"
}, {
	"Path": "org.squirrelframework.foundation.component.SquirrelProvider.findImplementationClass",
	"Comment": "find implementation class name according to programming convention",
	"Method": "Class<T> findImplementationClass(Class<T> interfaceClass){\r\n    Class<?> implementationClass = null;\r\n    String implClassName = interfaceClass.getName() + \"Impl\";\r\n    try {\r\n        implementationClass = Class.forName(implClassName);\r\n    } catch (ClassNotFoundException e) {\r\n        implClassName = ReflectUtils.getPackageName(interfaceClass.getName()) + \".impl.\" + interfaceClass.getSimpleName() + \"Impl\";\r\n        implementationClass = ReflectUtils.getClass(implClassName);\r\n    }\r\n    return (Class<T>) implementationClass;\r\n}"
}, {
	"Path": "teammates.logic.api.TaskQueuer.getNumberOfTasksAdded",
	"Comment": "gets the number of tasks added for each queue name.this method is used only for testing, where it is overridden.",
	"Method": "Map<String, Integer> getNumberOfTasksAdded(){\r\n    throw new UnsupportedOperationException(\"Method is used only for testing\");\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.ShowDeclarationsHandler.execute",
	"Comment": "this method is called to handle the show declarations operation.",
	"Method": "Object execute(ExecutionEvent event){\r\n    Shell parent = UIHelper.getShellProvider().getShell();\r\n    ShowDeclarationsPopupDialog popup = new ShowDeclarationsPopupDialog(parent);\r\n    popup.open();\r\n    return null;\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackSessionsDb.updateFeedbackSessionsTimeZoneForCourse",
	"Comment": "the objectify library does not support throwing checked exceptions inside transactions",
	"Method": "void updateFeedbackSessionsTimeZoneForCourse(String courseId,ZoneId courseTimeZone){\r\n    Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);\r\n    Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseTimeZone);\r\n    List<Key<FeedbackSession>> sessionKeys = getFeedbackSessionKeysForCourse(courseId);\r\n    for (Key<FeedbackSession> sessionKey : sessionKeys) {\r\n        try {\r\n            ofy().transact(new VoidWork() {\r\n                @Override\r\n                public void vrun() {\r\n                    FeedbackSession session = ofy().load().key(sessionKey).now();\r\n                    if (session == null) {\r\n                        throw new RuntimeException(new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + sessionKey.getName()));\r\n                    }\r\n                    session.setTimeZone(courseTimeZone.getId());\r\n                    saveEntity(session);\r\n                }\r\n            });\r\n        } catch (RuntimeException e) {\r\n            if (e.getCause() instanceof EntityDoesNotExistException) {\r\n                log.severe(e.getMessage());\r\n                continue;\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackSessionsDb.updateFeedbackSessionsTimeZoneForCourse",
	"Comment": "the objectify library does not support throwing checked exceptions inside transactions",
	"Method": "void updateFeedbackSessionsTimeZoneForCourse(String courseId,ZoneId courseTimeZone){\r\n    FeedbackSession session = ofy().load().key(sessionKey).now();\r\n    if (session == null) {\r\n        throw new RuntimeException(new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + sessionKey.getName()));\r\n    }\r\n    session.setTimeZone(courseTimeZone.getId());\r\n    saveEntity(session);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.TLAEditor.getModuleName",
	"Comment": "gets the module name from the name of the file thatthis editor is editing.",
	"Method": "String getModuleName(){\r\n    final IEditorInput iei = this.getEditorInput();\r\n    if (iei instanceof FileEditorInput) {\r\n        final IFile moduleFile = ((FileEditorInput) iei).getFile();\r\n        return ResourceHelper.getModuleName(moduleFile);\r\n    } else if (iei instanceof IURIEditorInput) {\r\n        final URI uri = ((IURIEditorInput) iei).getURI();\r\n        if (uri != null) {\r\n            final IPath path = URIUtil.toPath(uri);\r\n            if (path != null) {\r\n                final IFile moduleFile = ResourcesPlugin.getWorkspace().getRoot().getFile(path);\r\n                return ResourceHelper.getModuleName(moduleFile);\r\n            }\r\n        }\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "tlc2.module.TLC.PrintT",
	"Comment": "prints to standard error the string v1. always returns true.modified on 22 june 2011 by ll.see comment on the print method",
	"Method": "Value PrintT(Value v1){\r\n    Value v1c = v1.deepCopy();\r\n    v1c.deepNormalize();\r\n    if (OUTPUT == null) {\r\n        String ppr = Value.ppr(v1c.toString());\r\n        ToolIO.out.println(ppr);\r\n    } else {\r\n        try {\r\n            OUTPUT.write(Value.ppr(v1c.toString(\"\\n\")));\r\n        } catch (IOException e) {\r\n            MP.printError(EC.GENERAL, e);\r\n        }\r\n    }\r\n    return ValTrue;\r\n}"
}, {
	"Path": "toothpick.ScopeImpl.reset",
	"Comment": "resets the state of the scope.useful for automation testing when we want to reset the scope used to install test modules.",
	"Method": "void reset(){\r\n    super.reset();\r\n    mapClassesToNamedBoundProviders.clear();\r\n    mapClassesToUnNamedBoundProviders.clear();\r\n    hasTestModules = false;\r\n    installBindingForScope();\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.MapAbstractTest.cloneMapEntry",
	"Comment": "creates a new map entry that is independent of the first and the map.",
	"Method": "Map.Entry cloneMapEntry(Map.Entry entry){\r\n    HashMap map = new HashMap();\r\n    map.put(entry.getKey(), entry.getValue());\r\n    return (Map.Entry) map.entrySet().iterator().next();\r\n}"
}, {
	"Path": "com.facebook.swift.service.ThriftServerConfig.setQueueTimeout",
	"Comment": "sets a timeout period between receiving a request and the pulling the request off the queue.if the timeout expires before the request reaches the front of the queue and beginsprocessing, the server will discard the request instead of processing it.",
	"Method": "ThriftServerConfig setQueueTimeout(Duration queueTimeout){\r\n    this.queueTimeout = queueTimeout;\r\n    return this;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.selectDropdownByVisibleValueAndHandleAjaxRequests",
	"Comment": "waits for all ongoing ajax requests to complete if any before selecting the option by visible text, thenwaits for the associated ajax request to complete.",
	"Method": "void selectDropdownByVisibleValueAndHandleAjaxRequests(WebElement element,String text){\r\n    jQueryAjaxHandler.waitForAjaxIfPresentThenRegisterHandlers();\r\n    if (selectDropdownByVisibleValue(element, text)) {\r\n        jQueryAjaxHandler.waitForRequestComplete();\r\n    } else {\r\n        jQueryAjaxHandler.unregisterHandlers();\r\n    }\r\n}"
}, {
	"Path": "teammates.test.cases.action.BaseActionTest.modifyParamValue",
	"Comment": "modifies the value of a key in a parameter list.assumes key is present. use for testing.",
	"Method": "void modifyParamValue(String[] params,String key,String value){\r\n    for (int i = 0; i < params.length; i += 2) {\r\n        if (params[i].equals(key)) {\r\n            if (i + 1 >= params.length) {\r\n                fail(\"Cannot find parameter to modify.\");\r\n            } else {\r\n                params[i + 1] = value;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    fail(\"Cannot find parameter to modify.\");\r\n}"
}, {
	"Path": "tlc2.tool.Spec.getVar",
	"Comment": "return the variable if expr is a state variable. otherwise, null.",
	"Method": "SymbolNode getVar(SemanticNode expr,Context c,boolean cutoff){\r\n    if (expr instanceof OpApplNode) {\r\n        SymbolNode opNode = ((OpApplNode) expr).getOperator();\r\n        if (opNode.getArity() == 0) {\r\n            boolean isVarDecl = (opNode.getKind() == VariableDeclKind);\r\n            Object val = this.lookup(opNode, c, cutoff && isVarDecl);\r\n            if (val instanceof LazyValue) {\r\n                LazyValue lval = (LazyValue) val;\r\n                return this.getVar(lval.expr, lval.con, cutoff);\r\n            }\r\n            if (val instanceof OpDefNode) {\r\n                return this.getVar(((OpDefNode) val).getBody(), c, cutoff);\r\n            }\r\n            if (isVarDecl) {\r\n                return opNode;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.output.data.ObligationStatus.getProverStatusString",
	"Comment": "returns a string description of the mostrecent status of each prover on each backend.modified by ll on 16 april 2011 to add the reasons to the string.this may have to be changed when the final exact form of the reasonfield returned by tlapm is determined.",
	"Method": "String getProverStatusString(){\r\n    StringBuilder buffer = new StringBuilder();\r\n    Set entrySet = proverStatuses.entrySet();\r\n    for (Iterator it = entrySet.iterator(); it.hasNext(); ) {\r\n        Map.Entry nextEntry = (Map.Entry) it.next();\r\n        String key = (String) nextEntry.getKey();\r\n        String reason = (String) proverReasons.get(key);\r\n        if (reason != null && !reason.equals(\"\") && !reason.equals(\"false\")) {\r\n            reason = \" (\" + reason + \")\";\r\n        } else {\r\n            reason = \"\";\r\n        }\r\n        buffer.append(key + \" : \" + nextEntry.getValue() + reason);\r\n        if (it.hasNext()) {\r\n            buffer.append(\" , \");\r\n        }\r\n    }\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.util.ProverHelper.processWarningMessage",
	"Comment": "processes a warning message from the tlapm. this simply displaysa warning to the user.",
	"Method": "void processWarningMessage(WarningMessage warningMessage){\r\n    UIHelper.runUIAsync(new Runnable() {\r\n        public void run() {\r\n            InformationDialog.openWarning(warningMessage.getMessage(), \"TLAPM Warning\");\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.util.ProverHelper.processWarningMessage",
	"Comment": "processes a warning message from the tlapm. this simply displaysa warning to the user.",
	"Method": "void processWarningMessage(WarningMessage warningMessage){\r\n    InformationDialog.openWarning(warningMessage.getMessage(), \"TLAPM Warning\");\r\n}"
}, {
	"Path": "tlc2.tool.liveness.TableauNodePtrTable.getNodes",
	"Comment": "return all nodes with key k. return null if this does not contain k.",
	"Method": "int[] getNodes(long k){\r\n    if (count >= thresh) {\r\n        this.grow();\r\n    }\r\n    int loc = ((int) k & 0x7FFFFFFF) % this.length;\r\n    while (true) {\r\n        int[] node = this.nodes[loc];\r\n        if (node == null) {\r\n            return null;\r\n        }\r\n        if (getKey(node) == k) {\r\n            return this.nodes[loc];\r\n        }\r\n        loc = (loc + 1) % this.length;\r\n    }\r\n}"
}, {
	"Path": "teammates.test.cases.browsertests.AdminSearchPageUiTest.isSearchDataDisplayCorrect",
	"Comment": "this method only checks if the search data tables are displayed correctlyi.e, table headers are correct, and appropriate message is displayed if nosearch data is present.it does not test for the table content",
	"Method": "boolean isSearchDataDisplayCorrect(){\r\n    if (searchPage.isElementPresent(By.className(\"table\"))) {\r\n        int numSearchDataTables = browser.driver.findElements(By.className(\"table\")).size();\r\n        for (int i = 0; i < numSearchDataTables; i++) {\r\n            if (!isSearchTableHeaderCorrect(i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    searchPage.waitForTextsForAllStatusMessagesToUserEquals(\"No result found, please try again\");\r\n    return true;\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.Shell.addShellConnectionListener",
	"Comment": "add a shell connection listener. this callback will be invoked whenever the connection to\tthe shell changes.",
	"Method": "void addShellConnectionListener(OnShellConnectionListener listener){\r\n    mConnectionRecievers.add(listener);\r\n}"
}, {
	"Path": "teammates.logic.api.GateKeeper.verifyStudentPrivileges",
	"Comment": "verifies that the nominal user has student privileges. currently, alllogged in users as student privileges.",
	"Method": "void verifyStudentPrivileges(AccountAttributes account){\r\n    verifyLoggedInUserPrivileges();\r\n}"
}, {
	"Path": "tla2sany.semantic.SymbolNode.getLevelElement",
	"Comment": "we also override getlevelelement as it should never be called",
	"Method": "Element getLevelElement(Document doc,tla2sany.xml.SymbolContext context){\r\n    throw new UnsupportedOperationException(\"implementation Error: A symbol node may not be called for its level element.\");\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.StringUtil.containsIgnoreCase",
	"Comment": "tests if a string contains a specific character, ignoring case.",
	"Method": "boolean containsIgnoreCase(String pContainer,String pLookFor,boolean containsIgnoreCase,String pString,int pChar){\r\n    return ((pString != null) && ((pString.indexOf(Character.toLowerCase((char) pChar)) >= 0) || (pString.indexOf(Character.toUpperCase((char) pChar)) >= 0)));\r\n}"
}, {
	"Path": "tla2sany.semantic.APSubstInNode.getChildren",
	"Comment": "the children of this node are the body and the expressionsbeing substituted for symbols.",
	"Method": "SemanticNode[] getChildren(){\r\n    SemanticNode[] res = new SemanticNode[this.substs.length + 1];\r\n    res[0] = this.body;\r\n    for (int i = 0; i < substs.length; i++) {\r\n        res[i + 1] = substs[i].getExpr();\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "teammates.common.util.StringHelper.join",
	"Comment": "returns a new string composed of copies of the string elements joined togetherwith a copy of the specified delimiter.",
	"Method": "String join(String delimiter,List<Integer> elements){\r\n    return String.join(delimiter, toStringArray(elements));\r\n}"
}, {
	"Path": "teammates.test.driver.GaeSimulation.loginAsAdmin",
	"Comment": "logs in the user to the gae simulation environment as an admin.",
	"Method": "void loginAsAdmin(String userId){\r\n    loginUser(userId);\r\n    helper.setEnvIsAdmin(true);\r\n}"
}, {
	"Path": "util.BufferedDataOutputStream.writeChars",
	"Comment": "write n characters of chars starting at offset off to this stream as a sequence of bytes.",
	"Method": "void writeChars(char[] chars,int off,int n){\r\n    int finOff = off + n;\r\n    while (off < finOff) {\r\n        int endOff = Math.min(finOff, off + this.buff.length - this.len);\r\n        while (off < endOff) this.buff[this.len++] = (byte) chars[off++];\r\n        if (this.buff.length == this.len) {\r\n            this.out.write(this.buff, 0, this.len);\r\n            this.len = 0;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.support.osgi.BundleFindingUtils.findFirstBundleForTypeName",
	"Comment": "locates the first bundle that contains the presented type name and returnits bundle symbolic name.",
	"Method": "String findFirstBundleForTypeName(BundleContext context,String typeNameInExternalForm){\r\n    Validate.notNull(context, \"Bundle context required to perform the search\");\r\n    Validate.notBlank(typeNameInExternalForm, \"Resource name to locate is required\");\r\n    final String resourceName = \"/\" + typeNameInExternalForm.replace('.', '/') + \".class\";\r\n    final Bundle[] bundles = context.getBundles();\r\n    if (bundles == null) {\r\n        return null;\r\n    }\r\n    for (final Bundle bundle : bundles) {\r\n        try {\r\n            final URL url = bundle.getEntry(resourceName);\r\n            if (url != null) {\r\n                return bundle.getSymbolicName();\r\n            }\r\n        } catch (final RuntimeException e) {\r\n            return null;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.swipe_refresh_layout.SwipeProgressBar.setColorScheme",
	"Comment": "set the four colors used in the progress animation. the first color willalso be the color of the bar that grows in response to a user swipegesture.",
	"Method": "void setColorScheme(int color1,int color2,int color3,int color4){\r\n    mColor1 = color1;\r\n    mColor2 = color2;\r\n    mColor3 = color3;\r\n    mColor4 = color4;\r\n}"
}, {
	"Path": "teammates.client.scripts.statistics.FileStore.getCourseToInstituteCacheFromFileIfPossible",
	"Comment": "gets the cache service.if the cache is persisted to the disk, decrypts and parses it to warm up the cache.",
	"Method": "CourseToInstituteCache getCourseToInstituteCacheFromFileIfPossible(){\r\n    File courseToInstituteCacheFile = new File(COURSE_TO_INSTITUTE_CACHE_FILEPATH);\r\n    CourseToInstituteCache courseToInstituteCache = new CourseToInstituteCache();\r\n    if (courseToInstituteCacheFile.isFile()) {\r\n        courseToInstituteCache = parseEncryptedJsonFile(COURSE_TO_INSTITUTE_CACHE_FILEPATH, jsonReader -> {\r\n            CourseToInstituteCache cache = new CourseToInstituteCache();\r\n            jsonReader.beginObject();\r\n            while (jsonReader.hasNext()) {\r\n                cache.populate(jsonReader.nextName(), jsonReader.nextString());\r\n            }\r\n            jsonReader.endObject();\r\n            return cache;\r\n        });\r\n    }\r\n    return courseToInstituteCache;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.util.ModelHelper.copyExtendedModuleFiles",
	"Comment": "copies the module files that are extended by specrootfile into thefolder given by targetfolderpath.",
	"Method": "void copyExtendedModuleFiles(IFile specRootFile,IPath targetFolderPath,IProgressMonitor monitor,int STEP,IProject project){\r\n    List<String> extendedModules = ToolboxHandle.getExtendedModules(specRootFile.getName());\r\n    IFile moduleFile = null;\r\n    for (int i = 0; i < extendedModules.size(); i++) {\r\n        String module = extendedModules.get(i);\r\n        if (ToolboxHandle.isUserModule(module)) {\r\n            moduleFile = ResourceHelper.getLinkedFile(project, module, false);\r\n            if (moduleFile != null) {\r\n                moduleFile.copy(targetFolderPath.append(moduleFile.getProjectRelativePath()), IResource.DERIVED | IResource.FORCE, new SubProgressMonitor(monitor, STEP / extendedModules.size()));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.storage.api.InstructorsDb.deleteInstructorsForCourse",
	"Comment": "deletes all instructors for the course specified by courseid.",
	"Method": "void deleteInstructorsForCourse(String courseId){\r\n    Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);\r\n    deleteInstructors(getInstructorEntitiesForCourse(courseId));\r\n}"
}, {
	"Path": "tlc2.tool.liveness.TBPar.isLocallyConsistent",
	"Comment": "the method islocallyconsistent determines whether a list of state\tpredicates is locally consistent.",
	"Method": "boolean isLocallyConsistent(){\r\n    TBPar pos = new TBPar(this.size());\r\n    TBPar neg = new TBPar(this.size());\r\n    for (int i = 0; i < this.size(); i++) {\r\n        LiveExprNode ln = this.exprAt(i);\r\n        if (ln instanceof LNState) {\r\n            pos.addElement(ln);\r\n        } else if (ln instanceof LNNeg) {\r\n            LiveExprNode body = ((LNNeg) ln).getBody();\r\n            if (body instanceof LNState) {\r\n                neg.addElement(body);\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < pos.size(); i++) {\r\n        if (neg.member(pos.exprAt(i))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.roo.project.GAV.getInstance",
	"Comment": "returns an instance based on the given concatenated maven coordinates.",
	"Method": "GAV getInstance(String coordinates){\r\n    final String[] coordinateArray = ArrayUtils.nullToEmpty(StringUtils.split(coordinates, MavenUtils.COORDINATE_SEPARATOR));\r\n    Validate.isTrue(coordinateArray.length == 3, \"Expected three coordinates, but found \" + coordinateArray.length + \": \" + Arrays.toString(coordinateArray) + \"; did you use the '\" + MavenUtils.COORDINATE_SEPARATOR + \"' separator?\");\r\n    return new GAV(coordinateArray[0], coordinateArray[1], coordinateArray[2]);\r\n}"
}, {
	"Path": "teammates.logic.core.CoursesLogic.deleteAllCoursesCascade",
	"Comment": "permanently deletes all courses in recycle bin.this will also cascade the data in other databases which are related to these courses.",
	"Method": "void deleteAllCoursesCascade(List<InstructorAttributes> instructorList){\r\n    Assumption.assertNotNull(\"Supplied parameter was null\", instructorList);\r\n    List<String> softDeletedCourseIdList = instructorList.stream().filter(instructor -> coursesDb.getCourse(instructor.courseId).isCourseDeleted()).map(InstructorAttributes::getCourseId).collect(Collectors.toList());\r\n    for (String courseId : softDeletedCourseIdList) {\r\n        deleteCourseCascade(courseId);\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.output.data.StepTuple.getColorPredicateValues",
	"Comment": "returns the current value of the color predicates forthis obligation.",
	"Method": "boolean[] getColorPredicateValues(){\r\n    return colorPredicateValues;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.util.ModelHelper.getOpDefNode",
	"Comment": "returns the opdefnode with name equal to input stringreturns null if there is no such opdefnode",
	"Method": "OpDefNode getOpDefNode(String name){\r\n    SpecObj specObj = ToolboxHandle.getCurrentSpec().getValidRootModule();\r\n    if (specObj != null) {\r\n        OpDefNode[] opDefNodes = specObj.getExternalModuleTable().getRootModule().getOpDefs();\r\n        for (int j = 0; j < opDefNodes.length; j++) {\r\n            if (opDefNodes[j].getName().toString().equals(name)) {\r\n                return opDefNodes[j];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorHomePageData.getRemindParticularStudentsLink",
	"Comment": "retrieves the link to submit the request to remind particular students.also contains home page link to return after the action.",
	"Method": "String getRemindParticularStudentsLink(){\r\n    return getInstructorFeedbackRemindParticularStudentsLink(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);\r\n}"
}, {
	"Path": "teammates.test.driver.GaeSimulation.getEnvironmentAttributesWithApplicationHostname",
	"Comment": "returns an environment attribute with application host name.",
	"Method": "Map<String, Object> getEnvironmentAttributesWithApplicationHostname(){\r\n    Map<String, Object> attributes = new HashMap();\r\n    try {\r\n        attributes.put(\"com.google.appengine.runtime.default_version_hostname\", new URL(TestProperties.TEAMMATES_URL).getAuthority());\r\n    } catch (MalformedURLException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    return attributes;\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.util.IIOInputStreamAdapter.close",
	"Comment": "marks this stream as closed.this implementation does not close the underlying stream.",
	"Method": "void close(){\r\n    if (hasLength) {\r\n        input.seek(input.getStreamPosition() + left);\r\n    }\r\n    left = 0;\r\n    input = null;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionQuestionsBundle.getSortedQuestions",
	"Comment": "gets the list of questions in this bundle, sorted by question number.",
	"Method": "List<FeedbackQuestionAttributes> getSortedQuestions(){\r\n    List<FeedbackQuestionAttributes> sortedQuestions = new ArrayList(this.questionResponseBundle.keySet());\r\n    sortedQuestions.sort(null);\r\n    return sortedQuestions;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.selectDropdownByVisibleValue",
	"Comment": "selects the option by visible text and returns whether the dropdown value has changed.",
	"Method": "boolean selectDropdownByVisibleValue(WebElement element,String text){\r\n    Select select = new Select(element);\r\n    WebElement originalSelectedOption = select.getFirstSelectedOption();\r\n    select.selectByVisibleText(text);\r\n    WebElement newSelectedOption = select.getFirstSelectedOption();\r\n    assertEquals(text, newSelectedOption.getText().trim());\r\n    return !newSelectedOption.equals(originalSelectedOption);\r\n}"
}, {
	"Path": "teammates.test.driver.GaeSimulation.loginUser",
	"Comment": "logs in the user to the gae simulation environment without admin rights.",
	"Method": "void loginUser(String userId){\r\n    helper.setEnvIsLoggedIn(true);\r\n    helper.setEnvEmail(userId);\r\n    helper.setEnvAuthDomain(\"gmail.com\");\r\n    helper.setEnvIsAdmin(false);\r\n}"
}, {
	"Path": "teammates.logic.backdoor.BackDoorLogic.injectRealIdsIntoResponses",
	"Comment": "this method is necessary to generate the feedbackquestionid of the question the response is for. normally, the id is already generated on creation, but the json file does not contain the actual response id.therefore the question number corresponding to the created response should be inserted in the json file in place of the actual response id. this method will then generate the correct id and replace the field.",
	"Method": "void injectRealIdsIntoResponses(Collection<FeedbackResponseAttributes> responses,Map<String, String> questionIdMap){\r\n    for (FeedbackResponseAttributes response : responses) {\r\n        int questionNumber;\r\n        try {\r\n            questionNumber = Integer.parseInt(response.feedbackQuestionId);\r\n        } catch (NumberFormatException e) {\r\n            continue;\r\n        }\r\n        String sessionKey = makeSessionKey(response.feedbackSessionName, response.courseId);\r\n        String questionKey = makeQuestionKey(sessionKey, questionNumber);\r\n        response.feedbackQuestionId = questionIdMap.get(questionKey);\r\n    }\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorFeedbackResultsPageData.buildResponseRowsForQuestion",
	"Comment": "builds response rows for a given question. this not only builds response rows for existing responses, but includesthe missing responses between pairs of givers and recipients.",
	"Method": "List<InstructorFeedbackResultsResponseRow> buildResponseRowsForQuestion(FeedbackQuestionAttributes question,List<FeedbackResponseAttributes> responses){\r\n    List<InstructorFeedbackResultsResponseRow> responseRows = new ArrayList();\r\n    List<String> possibleGiversWithoutResponses = bundle.getPossibleGivers(question);\r\n    List<String> possibleReceiversWithoutResponsesForGiver = new ArrayList();\r\n    String prevGiver = \"\";\r\n    Map<String, Integer> responseGiverRecipientIndex = new HashMap();\r\n    for (FeedbackResponseAttributes response : responses) {\r\n        if (!bundle.isGiverVisible(response) || !bundle.isRecipientVisible(response)) {\r\n            possibleGiversWithoutResponses.clear();\r\n            possibleReceiversWithoutResponsesForGiver.clear();\r\n        }\r\n        removeParticipantIdentifierFromList(possibleGiversWithoutResponses, response.giver);\r\n        boolean isNewGiver = !prevGiver.equals(response.giver);\r\n        if (isNewGiver) {\r\n            if (isMissingResponsesShown) {\r\n                responseRows.addAll(buildMissingResponseRowsBetweenGiverAndPossibleRecipients(question, possibleReceiversWithoutResponsesForGiver, prevGiver, bundle.getNameForEmail(prevGiver), bundle.getTeamNameForEmail(prevGiver)));\r\n            }\r\n            String giverIdentifier = response.giver;\r\n            possibleReceiversWithoutResponsesForGiver = bundle.getPossibleRecipients(question, giverIdentifier);\r\n        }\r\n        removeParticipantIdentifierFromList(possibleReceiversWithoutResponsesForGiver, response.recipient);\r\n        prevGiver = response.giver;\r\n        InstructorFeedbackResultsModerationButton moderationButton = buildModerationButtonForExistingResponse(question, response);\r\n        boolean isFeedbackParticipantCommentsOnResponsesAllowed = question.getQuestionDetails().isFeedbackParticipantCommentsOnResponsesAllowed();\r\n        InstructorFeedbackResultsResponseRow responseRow = new InstructorFeedbackResultsResponseRow(bundle.getGiverNameForResponse(response), bundle.getTeamNameForEmail(response.giver), bundle.getRecipientNameForResponse(response), bundle.getTeamNameForEmail(response.recipient), bundle.getResponseAnswerHtml(response, question), moderationButton, isFeedbackParticipantCommentsOnResponsesAllowed);\r\n        if (isFeedbackParticipantCommentsOnResponsesAllowed) {\r\n            String comment = getFeedbackParticipantCommentText(response);\r\n            responseRow.setFeedbackParticipantComment(comment);\r\n        }\r\n        configureResponseRow(prevGiver, response.recipient, responseRow);\r\n        if (question.getQuestionDetails().isInstructorCommentsOnResponsesAllowed()) {\r\n            responseGiverRecipientIndex.putIfAbsent(response.giver, responseGiverRecipientIndex.size() + 1);\r\n            responseGiverRecipientIndex.putIfAbsent(response.recipient, responseGiverRecipientIndex.size() + 1);\r\n            addCommentsToResponseRow(question, response, responseRow, responseGiverRecipientIndex);\r\n        } else {\r\n            responseRow.setInstructorCommentsOnResponsesAllowed(false);\r\n        }\r\n        responseRows.add(responseRow);\r\n    }\r\n    if (!responses.isEmpty()) {\r\n        responseRows.addAll(getRemainingMissingResponseRows(question, possibleGiversWithoutResponses, possibleReceiversWithoutResponsesForGiver, prevGiver));\r\n    }\r\n    return responseRows;\r\n}"
}, {
	"Path": "tlc2.tool.fp.LongArray.log2phy",
	"Comment": "converts from logical positions to \tphysical memory addresses.",
	"Method": "long log2phy(long logicalAddress){\r\n    return baseAddress + (logicalAddress << logAddressSize);\r\n}"
}, {
	"Path": "tla2sany.configuration.ASCII_CharStream.adjustBeginLineColumn",
	"Comment": "method to adjust line and column numbers for the start of a token.",
	"Method": "void adjustBeginLineColumn(int newLine,int newCol){\r\n    int start = tokenBegin;\r\n    int len;\r\n    if (bufpos >= tokenBegin) {\r\n        len = bufpos - tokenBegin + inBuf + 1;\r\n    } else {\r\n        len = bufsize - tokenBegin + bufpos + 1 + inBuf;\r\n    }\r\n    int i = 0, j = 0, k = 0;\r\n    int nextColDiff = 0, columnDiff = 0;\r\n    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {\r\n        bufline[j] = newLine;\r\n        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\r\n        bufcolumn[j] = newCol + columnDiff;\r\n        columnDiff = nextColDiff;\r\n        i++;\r\n    }\r\n    if (i < len) {\r\n        bufline[j] = newLine++;\r\n        bufcolumn[j] = newCol + columnDiff;\r\n        while (i++ < len) {\r\n            if (bufline[j = start % bufsize] != bufline[++start % bufsize])\r\n                bufline[j] = newLine++;\r\n            else\r\n                bufline[j] = newLine;\r\n        }\r\n    }\r\n    line = bufline[j];\r\n    column = bufcolumn[j];\r\n}"
}, {
	"Path": "teammates.test.driver.CsvChecker.replaceUnpredictableValuesWithPlaceholders",
	"Comment": "substitutes values that are different across various test runs with placeholders.these values are identified using their known, unique formats.",
	"Method": "String replaceUnpredictableValuesWithPlaceholders(String csvContent){\r\n    return csvContent.replaceAll(Const.DISPLAYED_NAME_FOR_ANONYMOUS_PARTICIPANT + \" (student|instructor|team) \" + REGEX_ANONYMOUS_PARTICIPANT_HASH, Const.DISPLAYED_NAME_FOR_ANONYMOUS_PARTICIPANT + \" $1 \\\\${participant\\\\.hash}\");\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.WsEndpointsMetadata.getServletField",
	"Comment": "this method obtains the servlet field that will be used in some different methods",
	"Method": "FieldMetadata getServletField(){\r\n    if (this.servletField != null) {\r\n        return this.servletField;\r\n    }\r\n    FieldMetadataBuilder servlet = new FieldMetadataBuilder(getId(), Modifier.PRIVATE, new JavaSymbolName(\"cxfServletPath\"), JavaType.STRING, null);\r\n    AnnotationMetadataBuilder valueAnnotation = new AnnotationMetadataBuilder(SpringJavaType.VALUE);\r\n    valueAnnotation.addStringAttribute(\"value\", \"${cxf.path}\");\r\n    servlet.addAnnotation(valueAnnotation);\r\n    servletField = servlet.build();\r\n    return servletField;\r\n}"
}, {
	"Path": "toothpick.configuration.Configuration.preventMultipleRootScopes",
	"Comment": "prevents the creation of multiple root scopes in the scope forest.tp scope forest will be restricted to a scope tree. on android this optioncan help to detect when a scope is reopened after it was destroyed.",
	"Method": "Configuration preventMultipleRootScopes(){\r\n    this.multipleRootScopeCheckConfiguration = new MultipleRootScopeCheckOnConfiguration();\r\n    return this;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.FeedbackResponseAttributes.getResponseDetails",
	"Comment": "retrieves the feedbackresponsedetails object for this response.",
	"Method": "FeedbackResponseDetails getResponseDetails(){\r\n    if (isMissingResponse()) {\r\n        return null;\r\n    }\r\n    Class<? extends FeedbackResponseDetails> responseDetailsClass = getFeedbackResponseDetailsClass();\r\n    if (responseDetailsClass == FeedbackTextResponseDetails.class) {\r\n        return new FeedbackTextResponseDetails(responseMetaData);\r\n    }\r\n    return JsonUtils.fromJson(responseMetaData, responseDetailsClass);\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.layers.MemberTypeAdditions.getInstance",
	"Comment": "factory method that builds the method call from the given target, method,and array of parameter names.",
	"Method": "MemberTypeAdditions getInstance(ClassOrInterfaceTypeDetailsBuilder builder,String targetName,String methodName,boolean isStatic,List<MethodParameter> parameters,MemberTypeAdditions getInstance,ClassOrInterfaceTypeDetailsBuilder builder,String targetName,String methodName,boolean isStatic,MethodParameter parameters){\r\n    return getInstance(builder, targetName, methodName, isStatic, Arrays.asList(parameters));\r\n}"
}, {
	"Path": "org.lamport.org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.createLabels",
	"Comment": "create the labels for the list and the progress. return the list label.",
	"Method": "Label createLabels(Composite parent){\r\n    Composite labels = new Composite(parent, SWT.NONE);\r\n    GridLayout layout = new GridLayout();\r\n    layout.numColumns = 2;\r\n    layout.marginWidth = 0;\r\n    layout.marginHeight = 0;\r\n    labels.setLayout(layout);\r\n    Label listLabel = new Label(labels, SWT.NONE);\r\n    listLabel.setText(WorkbenchMessages.FilteredItemsSelectionDialog_listLabel);\r\n    listLabel.addTraverseListener(new TraverseListener() {\r\n        public void keyTraversed(TraverseEvent e) {\r\n            if (e.detail == SWT.TRAVERSE_MNEMONIC && e.doit) {\r\n                e.detail = SWT.TRAVERSE_NONE;\r\n                list.getTable().setFocus();\r\n            }\r\n        }\r\n    });\r\n    GridData gd = new GridData(GridData.FILL_HORIZONTAL);\r\n    listLabel.setLayoutData(gd);\r\n    progressLabel = new Label(labels, SWT.RIGHT);\r\n    progressLabel.setLayoutData(gd);\r\n    labels.setLayoutData(gd);\r\n    return listLabel;\r\n}"
}, {
	"Path": "org.lamport.org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.createLabels",
	"Comment": "create the labels for the list and the progress. return the list label.",
	"Method": "Label createLabels(Composite parent){\r\n    if (e.detail == SWT.TRAVERSE_MNEMONIC && e.doit) {\r\n        e.detail = SWT.TRAVERSE_NONE;\r\n        list.getTable().setFocus();\r\n    }\r\n}"
}, {
	"Path": "teammates.logic.core.AdminEmailsLogic.moveAdminEmailToTrashBin",
	"Comment": "move an admin email to trash bin.after this the attribute isintrashbin will be set to true",
	"Method": "void moveAdminEmailToTrashBin(String adminEmailId){\r\n    Assumption.assertNotNull(adminEmailId);\r\n    AdminEmailAttributes adminEmailToUpdate = getAdminEmailById(adminEmailId);\r\n    if (adminEmailToUpdate != null) {\r\n        adminEmailToUpdate.isInTrashBin = true;\r\n        adminEmailsDb.updateAdminEmail(adminEmailToUpdate);\r\n    }\r\n}"
}, {
	"Path": "teammates.logic.core.AdminEmailsLogic.getSentAdminEmails",
	"Comment": "gets all admin emails that have been sent and not in trash bin.",
	"Method": "List<AdminEmailAttributes> getSentAdminEmails(){\r\n    return adminEmailsDb.getSentAdminEmails();\r\n}"
}, {
	"Path": "teammates.ui.pagedata.StudentHomePageData.getStudentSubmissionStatusForSession",
	"Comment": "returns the submission status of the student for a given feedback session as a string.",
	"Method": "String getStudentSubmissionStatusForSession(FeedbackSessionAttributes session,boolean hasSubmitted){\r\n    if (session.isOpened()) {\r\n        return hasSubmitted ? \"Submitted\" : \"Pending\";\r\n    }\r\n    if (session.isWaitingToOpen()) {\r\n        return \"Awaiting\";\r\n    }\r\n    return \"Closed\";\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.utils.File.write",
	"Comment": "write data to the file. the data should be an array where each index is a line that should be written to the file. \t\tif the file does not already exist, it will be created.",
	"Method": "Boolean write(String input,Boolean write,String input,Boolean append,Boolean write,String[] input,Boolean write,String[] input,Boolean append){\r\n    synchronized (mLock) {\r\n        Boolean status = false;\r\n        if (input != null && !isDirectory()) {\r\n            try {\r\n                BufferedWriter output = new BufferedWriter(new java.io.FileWriter(mFile, append));\r\n                for (String line : input) {\r\n                    output.write(line);\r\n                    output.newLine();\r\n                }\r\n                output.close();\r\n                status = true;\r\n            } catch (Throwable e) {\r\n                String redirect = append ? \">>\" : \">\";\r\n                String path = getAbsolutePath();\r\n                for (String line : input) {\r\n                    String escapedInput = oPatternEscape.matcher(line).replaceAll(\"\\\\\\\\$1\");\r\n                    Attempts attempts = mShell.createAttempts(\"echo '\" + escapedInput + \"' \" + redirect + \" '\" + path + \"' 2> /dev/null\");\r\n                    Result result = attempts.execute();\r\n                    if (result != null && !(status = result.wasSuccessful())) {\r\n                        break;\r\n                    }\r\n                    redirect = \">>\";\r\n                }\r\n            }\r\n            if (status) {\r\n                Bundle bundle = new Bundle();\r\n                bundle.putString(\"action\", \"exists\");\r\n                bundle.putString(\"location\", getAbsolutePath());\r\n                Shell.sendBroadcast(\"file\", bundle);\r\n            }\r\n        }\r\n        return status;\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.ResourceHelper.addContent",
	"Comment": "writes contents stored in the string buffer to the file, appending the content",
	"Method": "void addContent(IFile file,StringBuffer buffer,IProgressMonitor monitor){\r\n    boolean force = true;\r\n    ByteArrayInputStream stream = new ByteArrayInputStream(buffer.toString().getBytes());\r\n    if (file.exists()) {\r\n        file.appendContents(stream, IResource.FORCE, monitor);\r\n    } else {\r\n        file.create(stream, force, monitor);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.comments.JavadocComment.addParamsInfo",
	"Comment": "adds or changes javadoccomment parameters info. existing info will bereplaced by this one.",
	"Method": "void addParamsInfo(List<String> paramsInfo){\r\n    Validate.isTrue(StringUtils.isNotBlank(getComment()), \"JavadocComment needs to have a description value before adding parameters info to it. \" + \"You can do that using 'setDescription(String)' method first, or full constructor.\");\r\n    if (paramsInfo == null || paramsInfo.isEmpty()) {\r\n        return;\r\n    }\r\n    initializeCommentIndexes();\r\n    this.beginParamsIndex = this.endDescriptionIndex;\r\n    this.commentBuilder.delete(this.beginParamsIndex, this.endParamsIndex);\r\n    int nextLineStartingIndex = this.beginParamsIndex;\r\n    for (String paramInfo : paramsInfo) {\r\n        String[] lines = paramInfo.split(IOUtils.LINE_SEPARATOR);\r\n        for (int i = 0; i < lines.length; i++) {\r\n            String newLine = \"\";\r\n            if (i == 0) {\r\n                newLine = (\" * @param \").concat(lines[i]).concat(IOUtils.LINE_SEPARATOR);\r\n            } else {\r\n                newLine = (\" * \").concat(\"\\t\\t\\t\\t\").concat(lines[i]).concat(IOUtils.LINE_SEPARATOR);\r\n            }\r\n            this.commentBuilder.insert(nextLineStartingIndex, newLine);\r\n            int newLineLenght = newLine.length();\r\n            nextLineStartingIndex += newLineLenght;\r\n            this.endParamsIndex += newLineLenght;\r\n            this.endReturnIndex += newLineLenght;\r\n            this.endThrowsIndex += newLineLenght;\r\n        }\r\n    }\r\n    super.setComment(this.commentBuilder.toString());\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.spec.parser.ParseResultBroadcaster.clear",
	"Comment": "clears all information from this broadcaster. thelist of listeners and the map of parse results getscleared.",
	"Method": "void clear(){\r\n    listeners.clear();\r\n    parseResults.clear();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.util.ProverHelper.cancelProverJobs",
	"Comment": "requests cancellation of all running prover jobs. if waitis true, sleeps the current thread until all prover jobs are donethat they are done.",
	"Method": "void cancelProverJobs(boolean wait){\r\n    ProverJobMatcher jobMatcher = new ProverJob.ProverJobMatcher();\r\n    Job.getJobManager().cancel(jobMatcher);\r\n    if (wait) {\r\n        while (Job.getJobManager().find(jobMatcher).length > 0) {\r\n            try {\r\n                Thread.sleep(1000);\r\n            } catch (InterruptedException e) {\r\n                ProverUIActivator.getDefault().logError(\"Error sleeping thread.\", e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.output.source.TagBasedTLCAnalyzer.processTag",
	"Comment": "process the calculation of the coverage regionthe task of this method is to produce tlcregion or tlcregioncontainer instances based on the regions stored on the stack.",
	"Method": "void processTag(ITypedRegion end){\r\n    int messageCode = getMessageCode(end, END);\r\n    ITypedRegion[] stackContent = getFindStart(messageCode);\r\n    TLCRegion start = (TLCRegion) stackContent[stackContent.length - 1];\r\n    int length = end.getOffset() - start.getLength() - start.getOffset();\r\n    int offset = start.getOffset() + start.getLength();\r\n    TLCRegion region;\r\n    if (stackContent.length > 1) {\r\n        region = new TLCRegionContainer(offset, length - 1);\r\n        Vector<ITypedRegion> regions = new Vector<ITypedRegion>();\r\n        for (int i = 0; i < stackContent.length - 1; i++) {\r\n            regions.add(stackContent[i]);\r\n            if (stackContent[i] instanceof TLCRegion) {\r\n                if (offset == stackContent[i].getOffset() - OPEN_TAG_LENGTH) {\r\n                    if (length - CLOSE_TAG_LENGTH == stackContent[i].getLength()) {\r\n                        length = -1;\r\n                        offset = -1;\r\n                    } else {\r\n                        int shift = OPEN_TAG_LENGTH + stackContent[i].getLength();\r\n                        offset = offset + shift;\r\n                        length = length - shift;\r\n                    }\r\n                } else if (offset + length - CLOSE_TAG_LENGTH == stackContent[i].getOffset() + stackContent[i].getLength()) {\r\n                    int shift = stackContent[i].getLength();\r\n                    length = length - shift;\r\n                } else {\r\n                    throw new IllegalArgumentException(\"Bug parsing the regions\");\r\n                }\r\n            }\r\n        }\r\n        ((TLCRegionContainer) region).setSubRegions(regions);\r\n    } else {\r\n        region = new TLCRegion(offset, length - 1);\r\n    }\r\n    region.setMessageCode(start.getMessageCode());\r\n    region.setSeverity(start.getSeverity());\r\n    if (inTag()) {\r\n        stack.push(region);\r\n    } else {\r\n        this.taggedRegion = region;\r\n    }\r\n}"
}, {
	"Path": "teammates.ui.pagedata.PageData.getTimeOptionsAsElementTags",
	"Comment": "returns the time options as html code.by default the selected one is the last one.",
	"Method": "List<ElementTag> getTimeOptionsAsElementTags(LocalDateTime timeToShowAsSelected){\r\n    List<ElementTag> result = new ArrayList();\r\n    for (int i = 1; i <= 24; i++) {\r\n        ElementTag option = createOption(String.format(\"dH\", i * 100 - (i == 24 ? 41 : 0)), String.valueOf(i), isTimeToBeSelected(timeToShowAsSelected, i));\r\n        result.add(option);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "teammates.common.util.HttpRequestHelper.getValueFromParamMap",
	"Comment": "returns the first value for the key in the parameter map, or null if key not found.",
	"Method": "String getValueFromParamMap(Map<String, String[]> paramMap,String key){\r\n    String[] values = paramMap.get(key);\r\n    return values == null ? null : values[0];\r\n}"
}, {
	"Path": "teammates.ui.pagedata.PageData.getInstructorFeedbackRemindLink",
	"Comment": "retrieves the link to submit the request for remind studentappends the return url to the link.",
	"Method": "String getInstructorFeedbackRemindLink(String courseId,String feedbackSessionName,String returnUrl){\r\n    String link = Const.ActionURIs.INSTRUCTOR_FEEDBACK_REMIND;\r\n    link = Url.addParamToUrl(link, Const.ParamsNames.COURSE_ID, courseId);\r\n    link = Url.addParamToUrl(link, Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);\r\n    link = Url.addParamToUrl(link, Const.ParamsNames.NEXT_URL, returnUrl);\r\n    link = addUserIdToUrl(link);\r\n    link = addSessionTokenToUrl(link);\r\n    return link;\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.StringUtil.lastIndexOfIgnoreCase",
	"Comment": "returns the index within this string of the last occurrence of thespecified character, searching backward starting at the specified index.",
	"Method": "int lastIndexOfIgnoreCase(String pString,String pLookFor,int lastIndexOfIgnoreCase,String pString,String pLookFor,int pPos,int lastIndexOfIgnoreCase,String pString,int pChar,int lastIndexOfIgnoreCase,String pString,int pChar,int pPos){\r\n    if ((pString == null)) {\r\n        return -1;\r\n    }\r\n    char lower = Character.toLowerCase((char) pChar);\r\n    char upper = Character.toUpperCase((char) pChar);\r\n    int indexLower;\r\n    int indexUpper;\r\n    indexLower = pString.lastIndexOf(lower, pPos);\r\n    indexUpper = pString.lastIndexOf(upper, pPos);\r\n    if (indexLower < 0) {\r\n        return indexUpper;\r\n    } else if (indexUpper < 0) {\r\n        return indexLower;\r\n    } else {\r\n        return (indexLower > indexUpper) ? indexLower : indexUpper;\r\n    }\r\n}"
}, {
	"Path": "teammates.ui.template.ElementTag.setAttribute",
	"Comment": "associates the specified value to the specified attribute name.",
	"Method": "String setAttribute(String attributeName,String attributeValue){\r\n    return attributes.put(attributeName, attributeValue);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.RCPNameToFileIStream.resolve",
	"Comment": "tries to find the specified module.starts in work directory and then looks up in to the library paths for modules.",
	"Method": "File resolve(String name,boolean isModule){\r\n    if (isModule && name.endsWith(\".tla\")) {\r\n        name = name.substring(0, name.length() - 4);\r\n    }\r\n    String sourceFileName;\r\n    if (isModule) {\r\n        sourceFileName = name + \".tla\";\r\n    } else {\r\n        sourceFileName = name;\r\n    }\r\n    File sourceFile = locate(sourceFileName);\r\n    return sourceFile;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.util.EditorUtil.innerGetCurrentToken",
	"Comment": "the inner method of getcurrenttoken.it assumes thatlocation is contained within stn.location.",
	"Method": "StringAndLocation innerGetCurrentToken(SyntaxTreeNode stn,Location location){\r\n    int kind = stn.getKind();\r\n    if (kind == SyntaxTreeConstants.N_GeneralId) {\r\n        return new StringAndLocation(concatHeirTokens(stn), stn.getLocation());\r\n    }\r\n    SyntaxTreeNode[] heirs = stn.getHeirs();\r\n    if (heirs.length == 0) {\r\n        return new StringAndLocation(stn.getImage(), stn.getLocation());\r\n    }\r\n    for (int i = 0; i < heirs.length; i++) {\r\n        if (locationContainment(location, heirs[i].getLocation())) {\r\n            return innerGetCurrentToken(heirs[i], location);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.MapAbstractTest.getCompatibilityVersion",
	"Comment": "gets the compatability version, needed for package access.",
	"Method": "String getCompatibilityVersion(){\r\n    return super.getCompatibilityVersion();\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.DomUtils.createChildIfNotExists",
	"Comment": "returns the child node with the given tag name, creating it if it doesnot exist.",
	"Method": "Element createChildIfNotExists(String tagName,Node parent,Document document){\r\n    final Element existingChild = XmlUtils.findFirstElement(tagName, parent);\r\n    if (existingChild != null) {\r\n        return existingChild;\r\n    }\r\n    return createChildElement(tagName, parent, document);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.activities.WhiteToolbarActivity.activateLightStatusBar",
	"Comment": "sets the status bar to be light or not. light status bar means dark icons.",
	"Method": "void activateLightStatusBar(boolean lightStatusBar){\r\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M || !AppSettings.isWhiteToolbar(this) || neverUseLightStatusBar) {\r\n        return;\r\n    }\r\n    int oldSystemUiFlags = getWindow().getDecorView().getSystemUiVisibility();\r\n    int newSystemUiFlags = oldSystemUiFlags;\r\n    if (lightStatusBar) {\r\n        newSystemUiFlags |= View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;\r\n    } else {\r\n        newSystemUiFlags &= ~(View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);\r\n    }\r\n    if (newSystemUiFlags != oldSystemUiFlags) {\r\n        getWindow().getDecorView().setSystemUiVisibility(newSystemUiFlags);\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.wizard.AssignmentWizardPage.getInputText",
	"Comment": "returns the unmodified text entered into this pagessource text field.",
	"Method": "String getInputText(){\r\n    return source.getDocument().get();\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorStudentRecordsPage.areAllRecordPanelBodiesVisibilityEquals",
	"Comment": "checks if the bodies of all the record panels are collapsed or expanded.",
	"Method": "boolean areAllRecordPanelBodiesVisibilityEquals(boolean isVisible){\r\n    for (WebElement e : getStudentFeedbackPanels()) {\r\n        if (e.isDisplayed() != isVisible) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "tlc2.tool.liveness.Liveness.addToBin",
	"Comment": "given a list of checks, ensures that the checks are in the bin. it\treturns an array of index of the checks in the bin.",
	"Method": "int addToBin(LiveExprNode check,Vect bin,int[] addToBin,Vect checks,Vect bin){\r\n    int[] index = new int[checks.size()];\r\n    for (int i = 0; i < checks.size(); i++) {\r\n        LiveExprNode check = (LiveExprNode) checks.elementAt(i);\r\n        index[i] = addToBin(check, bin);\r\n    }\r\n    return index;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.annotations.AnnotationMetadataBuilder.getInstance",
	"Comment": "returns the metadata for the existing annotation, with no attributevalues",
	"Method": "AnnotationMetadata getInstance(Class<?> annotationType,AnnotationMetadata getInstance,JavaType annotationType,AnnotationMetadataBuilder getInstance,JavaType annotationType,Collection<AnnotationAttributeValue<?>> attributeValues,AnnotationMetadata getInstance,String annotationType){\r\n    return new AnnotationMetadataBuilder(annotationType).build();\r\n}"
}, {
	"Path": "tlc2.tool.liveness.Liveness.parseLiveness",
	"Comment": "parse the temporals and impliedtemporals given in the config file. it\treturns null if there is nothing to check.",
	"Method": "LiveExprNode parseLiveness(Tool tool){\r\n    Action[] fairs = tool.getTemporals();\r\n    LNConj lnc = new LNConj(fairs.length);\r\n    for (int i = 0; i < fairs.length; i++) {\r\n        LiveExprNode ln = astToLive(tool, (ExprNode) fairs[i].pred, fairs[i].con);\r\n        lnc.addConj(ln);\r\n    }\r\n    Action[] checks = tool.getImpliedTemporals();\r\n    if (checks.length == 0) {\r\n        if (fairs.length == 0) {\r\n            return null;\r\n        }\r\n    } else if (checks.length == 1) {\r\n        LiveExprNode ln = astToLive(tool, (ExprNode) checks[0].pred, checks[0].con);\r\n        if (lnc.getCount() == 0) {\r\n            return new LNNeg(ln);\r\n        }\r\n        lnc.addConj(new LNNeg(ln));\r\n    } else {\r\n        LNDisj lnd = new LNDisj(checks.length);\r\n        for (int i = 0; i < checks.length; i++) {\r\n            LiveExprNode ln = astToLive(tool, (ExprNode) checks[i].pred, checks[i].con);\r\n            lnd.addDisj(new LNNeg(ln));\r\n        }\r\n        if (lnc.getCount() == 0) {\r\n            return lnd;\r\n        }\r\n        lnc.addConj(lnd);\r\n    }\r\n    return lnc;\r\n}"
}, {
	"Path": "tla2sany.semantic.SetOfLevelConstraints.put",
	"Comment": "this method addsinto this map. it subsumesany existing one.",
	"Method": "Integer put(SymbolNode param,Integer level){\r\n    int newLevel = level.intValue();\r\n    Integer old = this.get(param);\r\n    int oldLevel = (old == null) ? MaxLevel : old.intValue();\r\n    super.put(param, new Integer(Math.min(newLevel, oldLevel)));\r\n    return old;\r\n}"
}, {
	"Path": "teammates.logic.core.AdminEmailsLogic.getAdminEmailDrafts",
	"Comment": "gets all admin email drafts that have not been sent and not in trash bin.",
	"Method": "List<AdminEmailAttributes> getAdminEmailDrafts(){\r\n    return adminEmailsDb.getAdminEmailDrafts();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.spec.Spec.getModuleResources",
	"Comment": "retrieves the list of modules in the spec, or an empty list if no modules the list is sorted on the resource name",
	"Method": "IResource[] getModuleResources(){\r\n    IResource[] modules = null;\r\n    try {\r\n        modules = getProject().members(IResource.NONE);\r\n        List<IResource> moduleList = new ArrayList<IResource>(Arrays.asList(modules));\r\n        Collections.sort(moduleList, new ResourceNameComparator());\r\n        return moduleList.toArray(new IResource[moduleList.size()]);\r\n    } catch (CoreException e) {\r\n        Activator.getDefault().logError(\"Error retrieving the the spec modules\", e);\r\n        modules = new IResource[0];\r\n    }\r\n    return modules;\r\n}"
}, {
	"Path": "com.twelvemonkeys.io.LittleEndianDataOutputStream.writeFloat",
	"Comment": "writes a 4 byte java float to the underlying output stream inlittle endian order.",
	"Method": "void writeFloat(float f){\r\n    writeInt(Float.floatToIntBits(f));\r\n}"
}, {
	"Path": "teammates.ui.controller.InstructorCourseInstructorAbstractAction.removeSessionLevelPrivileges",
	"Comment": "removes session level privileges for the instructor under the given sections.",
	"Method": "void removeSessionLevelPrivileges(InstructorAttributes instructor,List<String> sectionNames){\r\n    for (String sectionName : sectionNames) {\r\n        instructor.privileges.removeSessionsPrivilegesForSection(sectionName);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.obr.addon.search.ObrAddonSearchOperationsImpl.populateBundleCache",
	"Comment": "method to populate current bundles on installed repositories",
	"Method": "void populateBundleCache(){\r\n    populateRepositories();\r\n    bundleCache.clear();\r\n    for (Repository repo : repositories) {\r\n        Resource[] repoResources = repo.getResources();\r\n        for (Resource repoResource : repoResources) {\r\n            ObrBundle bundle = new ObrBundle(repoResource.getSymbolicName(), repoResource.getPresentationName(), repoResource.getSize(), repoResource.getVersion(), repoResource.getURI());\r\n            Capability[] resourceCapabilities = repoResource.getCapabilities();\r\n            for (Capability capability : resourceCapabilities) {\r\n                if (capability.getName().equals(CAPABILITY_COMMANDS_NAME) || capability.getName().equals(CAPABILITY_JDBCDRIVER_NAME) || capability.getName().equals(CAPABILITY_LIBRARY_NAME)) {\r\n                    Map<String, Object> capabilityProperties = capability.getPropertiesAsMap();\r\n                    for (Entry capabilityProperty : capabilityProperties.entrySet()) {\r\n                        String capabilityCommand = (String) capabilityProperty.getValue();\r\n                        bundle.addCommand(capabilityCommand);\r\n                    }\r\n                    bundleCache.put(bundle.getSymbolicName(), bundle);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.test.cases.browsertests.FeedbackConstSumOptionQuestionUiTest.testDisableConstSumPointsAction",
	"Comment": "tests that the constsumpoints number fields gets disabled, if the corresponding radio button is not checked.",
	"Method": "void testDisableConstSumPointsAction(){\r\n    ______TS(\"Success case: CONSTSUM-option points to distribute field disables when radio button is unchecked\");\r\n    feedbackEditPage.clickNewQuestionButton();\r\n    feedbackEditPage.selectNewQuestionTypeAndWaitForNewQuestionPanelReady(\"CONSTSUM_OPTION\");\r\n    assertTrue(browser.driver.findElement(By.id(\"constSumPointsTotal--1\")).isSelected());\r\n    feedbackEditPage.verifyUnclickable(browser.driver.findElement(By.id(\"constSumPointsForEachOption--1\")));\r\n    feedbackEditPage.selectConstSumPointsOptionsForNewQuestion(\"PerOption\");\r\n    feedbackEditPage.verifyUnclickable(browser.driver.findElement(By.id(\"constSumPoints--1\")));\r\n    feedbackEditPage.selectConstSumPointsOptionsForNewQuestion(\"Total\");\r\n    feedbackEditPage.verifyUnclickable(browser.driver.findElement(By.id(\"constSumPointsForEachOption--1\")));\r\n    feedbackEditPage.clickDiscardChangesLinkForNewQuestion();\r\n    feedbackEditPage.waitForConfirmationModalAndClickOk();\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.swipe_refresh_layout.FullScreenSwipeRefreshLayout.setOnRefreshListener",
	"Comment": "set the listener to be notified when a refresh is triggered via the swipegesture.",
	"Method": "void setOnRefreshListener(OnRefreshListener listener){\r\n    mListener = listener;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.util.BufferedDocumentScanner.updateBuffer",
	"Comment": "fills the buffer with the contents of the document starting at the given\toffset.",
	"Method": "void updateBuffer(int offset){\r\n    fBufferOffset = offset;\r\n    if (fBufferOffset + fBuffer.length > fRangeOffset + fRangeLength)\r\n        fBufferLength = fRangeLength - (fBufferOffset - fRangeOffset);\r\n    else\r\n        fBufferLength = fBuffer.length;\r\n    try {\r\n        final String content = fDocument.get(fBufferOffset, fBufferLength);\r\n        content.getChars(0, fBufferLength, fBuffer, 0);\r\n    } catch (BadLocationException e) {\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.queue.StateQueue.isAvail",
	"Comment": "checks if states are available. if no states are available, the callee\twill be put to sleep until new states are available or another callee\tsignals work done. this is determined by the fact, that all other workers\tare waiting for states.",
	"Method": "boolean isAvail(){\r\n    if (this.finish) {\r\n        return false;\r\n    }\r\n    while (isEmpty() || this.stop) {\r\n        this.numWaiting++;\r\n        if (this.numWaiting >= TLCGlobals.getNumWorkers()) {\r\n            if (isEmpty()) {\r\n                this.numWaiting--;\r\n                return false;\r\n            }\r\n            synchronized (this.mu) {\r\n                this.mu.notify();\r\n            }\r\n        }\r\n        try {\r\n            this.wait();\r\n        } catch (Exception e) {\r\n            MP.printError(EC.GENERAL, \"making a worker wait for a state from the queue\", e);\r\n            System.exit(1);\r\n        }\r\n        this.numWaiting--;\r\n        if (this.finish) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.lamport.org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.restoreDialog",
	"Comment": "restores dialog using persisted settings. the default implementation\trestores the status of the details line and the selection history.",
	"Method": "void restoreDialog(IDialogSettings settings){\r\n    boolean toggleStatusLine = true;\r\n    if (settings.get(SHOW_STATUS_LINE) != null) {\r\n        toggleStatusLine = settings.getBoolean(SHOW_STATUS_LINE);\r\n    }\r\n    toggleStatusLineAction.setChecked(toggleStatusLine);\r\n    details.setVisible(toggleStatusLine);\r\n    String setting = settings.get(HISTORY_SETTINGS);\r\n    if (setting != null) {\r\n        try {\r\n            IMemento memento = XMLMemento.createReadRoot(new StringReader(setting));\r\n            this.contentProvider.loadHistory(memento);\r\n        } catch (WorkbenchException e) {\r\n            StatusManager.getManager().handle(new Status(IStatus.ERROR, PlatformUI.PLUGIN_ID, IStatus.ERROR, WorkbenchMessages.FilteredItemsSelectionDialog_restoreError, e));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "tla2sany.semantic.ThmOrAssumpDefNode.setLocal",
	"Comment": "theorem and assumption definitions are local iff imported with alocal instance.",
	"Method": "void setLocal(boolean localness){\r\n    local = localness;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.util.SemanticHelper.getNewContext",
	"Comment": "convenience method for constructing a new context, extending the one used in the current spec",
	"Method": "Context getNewContext(){\r\n    SpecObj specObj = ToolboxHandle.getSpecObj();\r\n    Context moduleContext;\r\n    if (specObj != null) {\r\n        ExternalModuleTable externalModuleTable = specObj.getExternalModuleTable();\r\n        moduleContext = externalModuleTable.getRootModule().getContext().duplicate(externalModuleTable);\r\n    } else {\r\n        moduleContext = Context.getGlobalContext();\r\n    }\r\n    return moduleContext;\r\n}"
}, {
	"Path": "org.springframework.roo.project.LogicalPath.isProjectRoot",
	"Comment": "indicates whether this is the root of the entire user project.",
	"Method": "boolean isProjectRoot(){\r\n    return isModuleRoot() && StringUtils.isBlank(module);\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorFeedbackSessionsPageData.determinePlaceholderMessage",
	"Comment": "determines the message for placeholder depending on whether the instructor has any active courses.",
	"Method": "String determinePlaceholderMessage(boolean hasActiveCourses){\r\n    return hasActiveCourses ? Const.StatusMessages.INSTRUCTOR_NO_MODIFY_PERMISSION_FOR_ACTIVE_COURSES_SESSIONS : Const.StatusMessages.INSTRUCTOR_NO_ACTIVE_COURSES;\r\n}"
}, {
	"Path": "teammates.ui.pagedata.PageData.sanitizeForHtml",
	"Comment": "these util methods simply delegate the work to the matching helperclass. we keep them here so that jsp pages do not have to import helper classes.",
	"Method": "String sanitizeForHtml(String unsanitizedStringLiteral){\r\n    return SanitizationHelper.sanitizeForHtml(unsanitizedStringLiteral);\r\n}"
}, {
	"Path": "teammates.common.util.TimeHelper.getInstantDaysOffsetFromNow",
	"Comment": "returns an instant that is offset by a number of days from now.",
	"Method": "Instant getInstantDaysOffsetFromNow(long offsetInDays){\r\n    return Instant.now().plus(Duration.ofDays(offsetInDays));\r\n}"
}, {
	"Path": "com.twelvemonkeys.contrib.tiff.TIFFUtilities.split",
	"Comment": "splits all pages from the input tiff file to one file per page in theoutput directory.",
	"Method": "List<File> split(File inputFile,File outputDirectory){\r\n    ImageInputStream input = null;\r\n    List<File> outputFiles = new ArrayList();\r\n    try {\r\n        input = ImageIO.createImageInputStream(inputFile);\r\n        List<TIFFPage> pages = getPages(input);\r\n        int pageNo = 1;\r\n        for (TIFFPage tiffPage : pages) {\r\n            ArrayList<TIFFPage> outputPages = new ArrayList<TIFFPage>(1);\r\n            ImageOutputStream outputStream = null;\r\n            try {\r\n                File outputFile = new File(outputDirectory, String.format(\"d\", pageNo) + \".tif\");\r\n                outputStream = ImageIO.createImageOutputStream(outputFile);\r\n                outputPages.clear();\r\n                outputPages.add(tiffPage);\r\n                writePages(outputStream, outputPages);\r\n                outputFiles.add(outputFile);\r\n            } finally {\r\n                if (outputStream != null) {\r\n                    outputStream.flush();\r\n                    outputStream.close();\r\n                }\r\n            }\r\n            ++pageNo;\r\n        }\r\n    } finally {\r\n        if (input != null) {\r\n            input.close();\r\n        }\r\n    }\r\n    return outputFiles;\r\n}"
}, {
	"Path": "org.springframework.roo.felix.pgp.PgpServiceImpl.getKeyServerUrlToRetrieveKeyId",
	"Comment": "obtains a url that should allow the download of the specified public key.the key server may not contain the specified public key if it has neverbeen uploaded.",
	"Method": "URL getKeyServerUrlToRetrieveKeyId(PgpKeyId keyId){\r\n    try {\r\n        return new URL(defaultKeyServerUrl + keyId);\r\n    } catch (final MalformedURLException e) {\r\n        throw new IllegalStateException(e);\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.image.BrightnessContrastFilter.filterRGB",
	"Comment": "filters one pixel, adjusting brightness and contrast according to thisfilter.",
	"Method": "int filterRGB(int pX,int pY,int pARGB){\r\n    int r = pARGB >> 16 & 0xFF;\r\n    int g = pARGB >> 8 & 0xFF;\r\n    int b = pARGB & 0xFF;\r\n    r = LUT[r];\r\n    g = LUT[g];\r\n    b = LUT[b];\r\n    return (pARGB & 0xFF000000) | (r << 16) | (g << 8) | b;\r\n}"
}, {
	"Path": "teammates.storage.entity.Instructor.generateRegistrationKey",
	"Comment": "generate unique registration key for the instructor.the key contains random elements to avoid being guessed.",
	"Method": "String generateRegistrationKey(){\r\n    String uniqueId = getUniqueId();\r\n    SecureRandom prng = new SecureRandom();\r\n    return uniqueId + prng.nextInt();\r\n}"
}, {
	"Path": "tlc2.tool.liveness.TableauDiskGraph.getNode",
	"Comment": "get the graph node. returns a new graphnode if the node is not in this.",
	"Method": "GraphNode getNode(long fp,int tidx){\r\n    long ptr = this.nodePtrTbl.get(fp, tidx);\r\n    if (ptr < 0) {\r\n        return new GraphNode(fp, tidx);\r\n    }\r\n    if (gnodes == null) {\r\n        return this.getNodeFromDisk(fp, tidx, ptr);\r\n    }\r\n    return this.getNode(fp, tidx, ptr);\r\n}"
}, {
	"Path": "tlc2.value.Value.select",
	"Comment": "this method selects the component of this value. the component isspecified by path.",
	"Method": "Value select(Value[] path){\r\n    try {\r\n        Value result = this;\r\n        for (int i = 0; i < path.length; i++) {\r\n            if (!(result instanceof Applicable)) {\r\n                Assert.fail(\"Attempted to apply EXCEPT construct to the value \" + ppr(result.toString()) + \".\");\r\n            }\r\n            Value elem = path[i];\r\n            result = ((Applicable) result).select(elem);\r\n            if (result == null)\r\n                return null;\r\n        }\r\n        return result;\r\n    } catch (RuntimeException | OutOfMemoryError e) {\r\n        if (hasSource()) {\r\n            throw FingerprintException.getNewHead(this, e);\r\n        } else {\r\n            throw e;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "tla2sany.semantic.ThmOrAssumpDefNode.getArity",
	"Comment": "implementations of the abstract methods of the symbolnode superclass.",
	"Method": "int getArity(){\r\n    return this.arity;\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.StringUtil.isEmpty",
	"Comment": "tests a string array, to see if all items are null or an empty string.",
	"Method": "boolean isEmpty(String pString,boolean isEmpty,String[] pStringArray){\r\n    if (pStringArray == null) {\r\n        return true;\r\n    }\r\n    for (String string : pStringArray) {\r\n        if (!isEmpty(string)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackResponseCommentsLogic.updateFeedbackResponseCommentsEmails",
	"Comment": "updates all email fields of feedback response comments with the new email",
	"Method": "void updateFeedbackResponseCommentsEmails(String courseId,String oldEmail,String updatedEmail){\r\n    frcDb.updateGiverEmailOfFeedbackResponseComments(courseId, oldEmail, updatedEmail);\r\n    frcDb.updateLastEditorEmailOfFeedbackResponseComments(courseId, oldEmail, updatedEmail);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.contribution.ParseStatusContributionItem.updateStatus",
	"Comment": "updates status from the specification currently loaded in the specmanager",
	"Method": "void updateStatus(){\r\n    if (statusLabel == null || statusLabel.isDisposed()) {\r\n        return;\r\n    }\r\n    final Job j = new ToolboxJob(\"Calculating specification size...\") {\r\n        protected IStatus run(IProgressMonitor monitor) {\r\n            final Spec spec = Activator.getSpecManager().getSpecLoaded();\r\n            UIHelper.runUIAsync(new Runnable() {\r\n                public void run() {\r\n                    if (spec == null && !composite.isDisposed()) {\r\n                        composite.setVisible(false);\r\n                    } else if (!statusLabel.isDisposed() && !composite.isDisposed()) {\r\n                        statusLabel.setText(AdapterFactory.getStatusAsString(spec));\r\n                        statusLabel.setBackground(statusLabel.getDisplay().getSystemColor(AdapterFactory.getStatusAsSWTBGColor(spec)));\r\n                        statusLabel.setForeground(statusLabel.getDisplay().getSystemColor(AdapterFactory.getStatusAsSWTFGColor(spec)));\r\n                        statusLabel.redraw();\r\n                        composite.setVisible(true);\r\n                    }\r\n                }\r\n            });\r\n            return Status.OK_STATUS;\r\n        }\r\n    };\r\n    j.schedule();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.contribution.ParseStatusContributionItem.updateStatus",
	"Comment": "updates status from the specification currently loaded in the specmanager",
	"Method": "void updateStatus(){\r\n    final Spec spec = Activator.getSpecManager().getSpecLoaded();\r\n    UIHelper.runUIAsync(new Runnable() {\r\n        public void run() {\r\n            if (spec == null && !composite.isDisposed()) {\r\n                composite.setVisible(false);\r\n            } else if (!statusLabel.isDisposed() && !composite.isDisposed()) {\r\n                statusLabel.setText(AdapterFactory.getStatusAsString(spec));\r\n                statusLabel.setBackground(statusLabel.getDisplay().getSystemColor(AdapterFactory.getStatusAsSWTBGColor(spec)));\r\n                statusLabel.setForeground(statusLabel.getDisplay().getSystemColor(AdapterFactory.getStatusAsSWTFGColor(spec)));\r\n                statusLabel.redraw();\r\n                composite.setVisible(true);\r\n            }\r\n        }\r\n    });\r\n    return Status.OK_STATUS;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.contribution.ParseStatusContributionItem.updateStatus",
	"Comment": "updates status from the specification currently loaded in the specmanager",
	"Method": "void updateStatus(){\r\n    if (spec == null && !composite.isDisposed()) {\r\n        composite.setVisible(false);\r\n    } else if (!statusLabel.isDisposed() && !composite.isDisposed()) {\r\n        statusLabel.setText(AdapterFactory.getStatusAsString(spec));\r\n        statusLabel.setBackground(statusLabel.getDisplay().getSystemColor(AdapterFactory.getStatusAsSWTBGColor(spec)));\r\n        statusLabel.setForeground(statusLabel.getDisplay().getSystemColor(AdapterFactory.getStatusAsSWTFGColor(spec)));\r\n        statusLabel.redraw();\r\n        composite.setVisible(true);\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.util.ModelHelper.containsTraceExplorerModuleConflict",
	"Comment": "determines if the spec with root module rootmodulename is dependent on amodule with the same name as the root module used for trace exploration.",
	"Method": "boolean containsTraceExplorerModuleConflict(String rootModuleName){\r\n    String rootModuleFileName = rootModuleName;\r\n    if (!rootModuleName.endsWith(ResourceHelper.TLA_EXTENSION)) {\r\n        rootModuleFileName = ResourceHelper.getModuleFileName(rootModuleName);\r\n    }\r\n    List<String> extendedModuleNames = ToolboxHandle.getExtendedModules(rootModuleFileName);\r\n    Iterator<String> it = extendedModuleNames.iterator();\r\n    while (it.hasNext()) {\r\n        String moduleName = it.next();\r\n        if (moduleName.equals(TE_FILE_TLA)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "tla2sany.semantic.TheoremNode.export",
	"Comment": "overrides levelnode.export and exports a uid reference instad of the full version",
	"Method": "Element export(Document doc,SymbolContext context){\r\n    context.put(this, doc);\r\n    Element e = doc.createElement(getNodeRef());\r\n    e.appendChild(appendText(doc, \"UID\", Integer.toString(myUID)));\r\n    return e;\r\n}"
}, {
	"Path": "teammates.logic.api.Logic.moveCourseToRecycleBin",
	"Comment": "moves a course to recycle bin by its given corresponding id.all data related will not be deleted.",
	"Method": "void moveCourseToRecycleBin(String courseId){\r\n    Assumption.assertNotNull(courseId);\r\n    coursesLogic.moveCourseToRecycleBin(courseId);\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackEditPage.selectGiverToBeStudentsAndWaitForVisibilityMessageToLoad",
	"Comment": "selects the giver in the feedback path to be students in the course and waits for the corresponding visibility messageto load.",
	"Method": "void selectGiverToBeStudentsAndWaitForVisibilityMessageToLoad(){\r\n    selectDropdownByVisibleValueAndHandleAjaxRequests(giverDropdownForNewQuestion, \"Students in this course\");\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.TLAFastPartitioner.overlapsOrTouches",
	"Comment": "returns true if the given ranges overlap with or touch each other.",
	"Method": "boolean overlapsOrTouches(Position gap,int offset,int length){\r\n    return gap.getOffset() <= offset + length && offset <= gap.getOffset() + gap.getLength();\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackResultsPage.loadResultLargeScalePanel",
	"Comment": "expands a particular large scale results panel, causing its results to load.",
	"Method": "void loadResultLargeScalePanel(int panelNumber){\r\n    String panelId = \"panelHeading-\" + panelNumber;\r\n    clickLargeScalePanelAndWaitForExpansion(panelId);\r\n}"
}, {
	"Path": "tla2sany.semantic.SemanticNode.getPreComments",
	"Comment": "returns the array of comments immediately preceding the firsttoken of the spec that produces this semantic node.",
	"Method": "String[] getPreComments(){\r\n    return ((SyntaxTreeNode) this.stn).getAttachedComments();\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.video.InputSurface.eglSetup",
	"Comment": "prepares egl. we want a gles 2.0 context and a surface that supports recording.",
	"Method": "void eglSetup(){\r\n    mEGLDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);\r\n    if (mEGLDisplay == EGL14.EGL_NO_DISPLAY) {\r\n        throw new RuntimeException(\"unable to get EGL14 display\");\r\n    }\r\n    int[] version = new int[2];\r\n    if (!EGL14.eglInitialize(mEGLDisplay, version, 0, version, 1)) {\r\n        mEGLDisplay = null;\r\n        throw new RuntimeException(\"unable to initialize EGL14\");\r\n    }\r\n    int[] attribList = { EGL14.EGL_RED_SIZE, 8, EGL14.EGL_GREEN_SIZE, 8, EGL14.EGL_BLUE_SIZE, 8, EGL14.EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT, EGL_RECORDABLE_ANDROID, 1, EGL14.EGL_NONE };\r\n    EGLConfig[] configs = new EGLConfig[1];\r\n    int[] numConfigs = new int[1];\r\n    if (!EGL14.eglChooseConfig(mEGLDisplay, attribList, 0, configs, 0, configs.length, numConfigs, 0)) {\r\n        throw new RuntimeException(\"unable to find RGB888+recordable ES2 EGL config\");\r\n    }\r\n    int[] attrib_list = { EGL14.EGL_CONTEXT_CLIENT_VERSION, 2, EGL14.EGL_NONE };\r\n    mEGLContext = EGL14.eglCreateContext(mEGLDisplay, configs[0], EGL14.EGL_NO_CONTEXT, attrib_list, 0);\r\n    checkEglError(\"eglCreateContext\");\r\n    if (mEGLContext == null) {\r\n        throw new RuntimeException(\"null context\");\r\n    }\r\n    int[] surfaceAttribs = { EGL14.EGL_NONE };\r\n    mEGLSurface = EGL14.eglCreateWindowSurface(mEGLDisplay, configs[0], mSurface, surfaceAttribs, 0);\r\n    checkEglError(\"eglCreateWindowSurface\");\r\n    if (mEGLSurface == null) {\r\n        throw new RuntimeException(\"surface was null\");\r\n    }\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.getFeedbackSessionsForUserInCourse",
	"Comment": "checks if the specified course exists, then gets the feedback sessions forthe specified user in the course if it does exist.",
	"Method": "List<FeedbackSessionAttributes> getFeedbackSessionsForUserInCourse(String courseId,String userEmail){\r\n    if (!coursesLogic.isCoursePresent(courseId)) {\r\n        throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_COURSE);\r\n    }\r\n    return getFeedbackSessionsForUserInCourseSkipCheck(courseId, userEmail);\r\n}"
}, {
	"Path": "teammates.logic.api.TaskQueuer.scheduleFeedbackSessionResendPublishedEmail",
	"Comment": "schedules for feedback session publication remindersfor the specified feedback session for the specified group of users.",
	"Method": "void scheduleFeedbackSessionResendPublishedEmail(String courseId,String feedbackSessionName,String[] usersToEmail){\r\n    Map<String, String[]> paramMap = new HashMap();\r\n    paramMap.put(ParamsNames.SUBMISSION_FEEDBACK, new String[] { feedbackSessionName });\r\n    paramMap.put(ParamsNames.SUBMISSION_COURSE, new String[] { courseId });\r\n    paramMap.put(ParamsNames.SUBMISSION_RESEND_PUBLISHED_EMAIL_USER_LIST, usersToEmail);\r\n    addTaskMultisetParam(TaskQueue.FEEDBACK_SESSION_RESEND_PUBLISHED_EMAIL_QUEUE_NAME, TaskQueue.FEEDBACK_SESSION_RESEND_PUBLISHED_EMAIL_WORKER_URL, paramMap);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackRubricQuestionDetails.isValidDescriptionSize",
	"Comment": "checks if the dimensions of rubricdescription is valid accordingto numofrubricsubquestions and numofrubricchoices.",
	"Method": "boolean isValidDescriptionSize(){\r\n    if (rubricDescriptions.size() != numOfRubricSubQuestions) {\r\n        return false;\r\n    }\r\n    for (List<String> rubricDescription : rubricDescriptions) {\r\n        if (rubricDescription.size() != numOfRubricChoices) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.swipe_refresh_layout.FullScreenSwipeRefreshLayout.setRefreshing",
	"Comment": "notify the widget that refresh state has changed. do not call this whenrefresh is triggered by a swipe gesture.",
	"Method": "void setRefreshing(boolean refreshing){\r\n    if (mRefreshing != refreshing) {\r\n        ensureTarget();\r\n        mCurrPercentage = 0;\r\n        mRefreshing = refreshing;\r\n        if (mRefreshing) {\r\n            mProgressBar.start();\r\n        } else {\r\n            mProgressBar.stop();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "it.michelelacorte.swipeablecard.OptionView.isMultipleMarker",
	"Comment": "get boolean ismultiplemarker to know if multiple marker mode is used",
	"Method": "boolean isMultipleMarker(){\r\n    return multipleMarker;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorCopyFsToModal.fillFormWithAllCoursesSelected",
	"Comment": "populates the fields of the form by using the provided name, and selecting every course.",
	"Method": "void fillFormWithAllCoursesSelected(String newFsName){\r\n    WebElement fsCopyModal = browser.driver.findElement(By.id(\"fsCopyModal\"));\r\n    List<WebElement> coursesCheckBoxes = fsCopyModal.findElements(By.name(Const.ParamsNames.COPIED_COURSES_ID));\r\n    for (WebElement e : coursesCheckBoxes) {\r\n        markCheckBoxAsChecked(e);\r\n    }\r\n    WebElement fsNameInput = fsCopyModal.findElement(By.id(Const.ParamsNames.COPIED_FEEDBACK_SESSION_NAME));\r\n    fillTextBox(fsNameInput, newFsName);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.DecomposeProofHandler.newVecInsertPos",
	"Comment": "the new position corresponding to old position oldpos after the sequencevec of insertions. see comments for the insertion class.",
	"Method": "int newVecInsertPos(int oldPos,Vector<Insertion> vec){\r\n    return innerNewVecInsertPos(oldPos, 0, vec);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.FeedbackQuestionAttributes.getQuestionDetails",
	"Comment": "retrieves the feedbackquestiondetails object for this question.",
	"Method": "FeedbackQuestionDetails getQuestionDetails(){\r\n    if (questionType == FeedbackQuestionType.TEXT && !isValidJsonString(questionMetaData)) {\r\n        return new FeedbackTextQuestionDetails(questionMetaData);\r\n    }\r\n    return JsonUtils.fromJson(questionMetaData, getFeedbackQuestionDetailsClass());\r\n}"
}, {
	"Path": "tla2sany.semantic.ModuleNode.levelDataToString",
	"Comment": "walkgraph, leveldatatostring, and tostring methods to implementexplorenode interface",
	"Method": "String levelDataToString(){\r\n    return \"LevelParams: \" + getLevelParams() + \"\\n\" + \"LevelConstraints: \" + getLevelConstraints() + \"\\n\" + \"ArgLevelConstraints: \" + getArgLevelConstraints() + \"\\n\" + \"ArgLevelParams: \" + getArgLevelParams() + \"\\n\";\r\n}"
}, {
	"Path": "teammates.logic.api.Logic.restoreFeedbackSessionFromRecycleBin",
	"Comment": "restores a specific session from recycle bin to feedback sessions table.",
	"Method": "void restoreFeedbackSessionFromRecycleBin(String feedbackSessionName,String courseId){\r\n    Assumption.assertNotNull(feedbackSessionName);\r\n    Assumption.assertNotNull(courseId);\r\n    feedbackSessionsLogic.restoreFeedbackSessionFromRecycleBin(feedbackSessionName, courseId);\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.getFeedbackSessionResultsForInstructorInSectionWithinRangeFromView",
	"Comment": "gets results of a feedback session to show to an instructor in a section in an indicated range.",
	"Method": "FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorInSectionWithinRangeFromView(String feedbackSessionName,String courseId,String userEmail,String section,int range,String viewType){\r\n    CourseRoster roster = new CourseRoster(studentsLogic.getStudentsForCourse(courseId), instructorsLogic.getInstructorsForCourse(courseId));\r\n    Map<String, String> params = new HashMap();\r\n    params.put(PARAM_IS_INCLUDE_RESPONSE_STATUS, \"true\");\r\n    params.put(PARAM_IN_SECTION, \"false\");\r\n    params.put(PARAM_FROM_SECTION, \"true\");\r\n    params.put(PARAM_TO_SECTION, \"false\");\r\n    params.put(PARAM_SECTION, section);\r\n    if (range > 0) {\r\n        params.put(PARAM_RANGE, String.valueOf(range));\r\n    }\r\n    params.put(PARAM_VIEW_TYPE, viewType);\r\n    return getFeedbackSessionResultsForUserWithParams(feedbackSessionName, courseId, userEmail, UserRole.INSTRUCTOR, roster, params);\r\n}"
}, {
	"Path": "teammates.test.driver.TimeHelperExtension.getInstantHoursOffsetFromNow",
	"Comment": "returns an java.time.instant object that is offset by a number of hours from now.",
	"Method": "Instant getInstantHoursOffsetFromNow(long offsetInHours){\r\n    return Instant.now().plus(Duration.ofHours(offsetInHours));\r\n}"
}, {
	"Path": "teammates.test.pageobjects.BrowserPool.release",
	"Comment": "releases a browser instance back to the pool, ready to be reused.",
	"Method": "void release(Browser browser){\r\n    BrowserPool pool = getInstance();\r\n    synchronized (pool) {\r\n        browser.isInUse = false;\r\n        pool.notifyAll();\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.dialog.FilteredDefinitionSelectionDialog.getDetailLabelProvider",
	"Comment": "creates a label provider for the detail section below the listthe label provider prints out the name of operation definition and the module the operation is defined in",
	"Method": "ILabelProvider getDetailLabelProvider(){\r\n    return new LabelProvider() {\r\n        public String getText(Object element) {\r\n            if (element instanceof OpDefNode) {\r\n                OpDefNode node = (OpDefNode) element;\r\n                return node.getSource().getName().toString() + ((node.getSource().getOriginallyDefinedInModuleNode() != null) ? \" : \" + node.getSource().getOriginallyDefinedInModuleNode().getName().toString() : \"\");\r\n            }\r\n            return super.getText(element);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.dialog.FilteredDefinitionSelectionDialog.getDetailLabelProvider",
	"Comment": "creates a label provider for the detail section below the listthe label provider prints out the name of operation definition and the module the operation is defined in",
	"Method": "ILabelProvider getDetailLabelProvider(){\r\n    if (element instanceof OpDefNode) {\r\n        OpDefNode node = (OpDefNode) element;\r\n        return node.getSource().getName().toString() + ((node.getSource().getOriginallyDefinedInModuleNode() != null) ? \" : \" + node.getSource().getOriginallyDefinedInModuleNode().getName().toString() : \"\");\r\n    }\r\n    return super.getText(element);\r\n}"
}, {
	"Path": "tlc2.tool.liveness.LiveExprNode.pushNeg",
	"Comment": "this method pushes a negation all the way down to the atoms. it is\tcurrently not used.",
	"Method": "LiveExprNode pushNeg(LiveExprNode pushNeg,boolean hasNeg){\r\n    if (hasNeg) {\r\n        return new LNNeg(this);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.MapAbstractTest.tearDown",
	"Comment": "erases any leftover instance variables by setting them to null.",
	"Method": "void tearDown(){\r\n    map = null;\r\n    keySet = null;\r\n    entrySet = null;\r\n    values = null;\r\n    confirmed = null;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.hasResponseToInstructorOrGeneral",
	"Comment": "returns true if bundle contains response to instructor or general.",
	"Method": "boolean hasResponseToInstructorOrGeneral(){\r\n    for (FeedbackResponseAttributes response : responses) {\r\n        String recipientIdentifier = response.recipient;\r\n        if (Const.NO_SPECIFIC_SECTION.equals(getSectionFromRoster(recipientIdentifier))) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.twelvemonkeys.image.ImageUtil.waitForImages",
	"Comment": "waits for a number of images to load completely.will wait the specified time.",
	"Method": "boolean waitForImages(Image[] pImages,boolean waitForImages,Image[] pImages,long pTimeOut){\r\n    boolean success = true;\r\n    int imageId;\r\n    imageId = pImages.length == 1 ? System.identityHashCode(pImages[0]) : System.identityHashCode(pImages);\r\n    for (Image image : pImages) {\r\n        sTracker.addImage(image, imageId);\r\n        if (sTracker.checkID(imageId, false)) {\r\n            sTracker.removeImage(image, imageId);\r\n        }\r\n    }\r\n    try {\r\n        if (pTimeOut < 0L) {\r\n            sTracker.waitForID(imageId);\r\n        } else {\r\n            success = sTracker.waitForID(imageId, pTimeOut);\r\n        }\r\n    } catch (InterruptedException ie) {\r\n        success = false;\r\n    } finally {\r\n        for (Image pImage : pImages) {\r\n            sTracker.removeImage(pImage, imageId);\r\n        }\r\n    }\r\n    return success && !sTracker.isErrorID(imageId);\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.getRowsOfPossibleRecipientsInCsvFormat",
	"Comment": "for a giver and a list of possiblerecipientsforgiver, generate rowsof missing responses between the giver and the possible recipients.",
	"Method": "StringBuilder getRowsOfPossibleRecipientsInCsvFormat(FeedbackSessionResultsBundle results,FeedbackQuestionAttributes question,FeedbackQuestionDetails questionDetails,List<String> possibleRecipientsForGiver,String giver){\r\n    StringBuilder exportBuilder = new StringBuilder();\r\n    for (String possibleRecipient : possibleRecipientsForGiver) {\r\n        String giverName = results.getFullNameFromRoster(giver);\r\n        String giverLastName = results.getLastNameFromRoster(giver);\r\n        String giverEmail = results.getDisplayableEmailFromRoster(giver);\r\n        String possibleRecipientName = results.getFullNameFromRoster(possibleRecipient);\r\n        String possibleRecipientLastName = results.getLastNameFromRoster(possibleRecipient);\r\n        String possibleRecipientEmail = results.getDisplayableEmailFromRoster(possibleRecipient);\r\n        if (questionDetails.shouldShowNoResponseText(question)) {\r\n            exportBuilder.append(SanitizationHelper.sanitizeForCsv(results.getTeamNameFromRoster(giver)) + \",\" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(giverName)) + \",\" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(giverLastName)) + \",\" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(giverEmail)) + \",\" + SanitizationHelper.sanitizeForCsv(results.getTeamNameFromRoster(possibleRecipient)) + \",\" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(possibleRecipientName)) + \",\" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(possibleRecipientLastName)) + \",\" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(possibleRecipientEmail)) + \",\" + questionDetails.getNoResponseTextInCsv(giver, possibleRecipient, results, question) + System.lineSeparator());\r\n        }\r\n    }\r\n    return exportBuilder;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.util.ModelHelper.containsModelCheckingModuleConflict",
	"Comment": "determines if the spec with root module rootmodulename is dependent on amodule with the same name as the root module used for model checking.",
	"Method": "boolean containsModelCheckingModuleConflict(String rootModuleName){\r\n    String rootModuleFileName = rootModuleName;\r\n    if (!rootModuleName.endsWith(ResourceHelper.TLA_EXTENSION)) {\r\n        rootModuleFileName = ResourceHelper.getModuleFileName(rootModuleName);\r\n    }\r\n    List<String> extendedModuleNames = ToolboxHandle.getExtendedModules(rootModuleFileName);\r\n    Iterator<String> it = extendedModuleNames.iterator();\r\n    while (it.hasNext()) {\r\n        String moduleName = it.next();\r\n        if (moduleName.equals(FILE_TLA)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.util.DocumentHelper.getRegionExpandedForwards",
	"Comment": "at a given position in text retrieves the region marking the word, starting at and ending after the current position",
	"Method": "IRegion getRegionExpandedForwards(IDocument document,int documentOffset,IWordDetector detector){\r\n    int charCounter = 0;\r\n    while (true) {\r\n        try {\r\n            char c = document.getChar(++documentOffset);\r\n            if (!detector.isWordPart(c))\r\n                break;\r\n            charCounter++;\r\n        } catch (BadLocationException e) {\r\n            break;\r\n        }\r\n    }\r\n    return new Region(documentOffset - charCounter, charCounter + 1);\r\n}"
}, {
	"Path": "tla2sany.semantic.TheoremNode.getProof",
	"Comment": "return the proof of the theorem, which is null if there is none.",
	"Method": "ProofNode getProof(){\r\n    return this.proof;\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.video.OutputSurface.drawImage",
	"Comment": "draws the data from surfacetexture onto the current egl surface.",
	"Method": "void drawImage(){\r\n    mTextureRender.drawFrame(mSurfaceTexture);\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.antlrjavaparser.details.JavaParserAnnotationMetadataBuilder.addAnnotationToList",
	"Comment": "facilitates the addition of the annotation to the presented type.",
	"Method": "void addAnnotationToList(CompilationUnitServices compilationUnitServices,List<AnnotationExpr> annotations,AnnotationMetadata annotation){\r\n    Validate.notNull(compilationUnitServices, \"Compilation unit services required\");\r\n    Validate.notNull(annotations, \"Annotations required\");\r\n    Validate.notNull(annotation, \"Annotation metadata required\");\r\n    final NameExpr nameToUse = JavaParserUtils.importTypeIfRequired(compilationUnitServices.getEnclosingTypeName(), compilationUnitServices.getImports(), annotation.getAnnotationType());\r\n    final List<MemberValuePair> memberValuePairs = new ArrayList<MemberValuePair>();\r\n    for (final JavaSymbolName attributeName : annotation.getAttributeNames()) {\r\n        final AnnotationAttributeValue<?> value = annotation.getAttribute(attributeName);\r\n        Validate.notNull(value, \"Unable to acquire value '%s' from annotation\", attributeName);\r\n        final MemberValuePair memberValuePair = convert(value, compilationUnitServices);\r\n        if (memberValuePair != null) {\r\n            memberValuePairs.add(memberValuePair);\r\n        }\r\n    }\r\n    AnnotationExpr annotationExpression = null;\r\n    if (memberValuePairs.isEmpty()) {\r\n        annotationExpression = new MarkerAnnotationExpr(nameToUse);\r\n    } else if (memberValuePairs.size() == 1 && (memberValuePairs.get(0).getName() == null || \"value\".equals(memberValuePairs.get(0).getName()))) {\r\n        final Expression toUse = JavaParserUtils.importExpressionIfRequired(compilationUnitServices.getEnclosingTypeName(), compilationUnitServices.getImports(), memberValuePairs.get(0).getValue());\r\n        annotationExpression = new SingleMemberAnnotationExpr(nameToUse, toUse);\r\n    } else {\r\n        annotationExpression = new NormalAnnotationExpr(nameToUse, new ArrayList<MemberValuePair>());\r\n    }\r\n    JavaParserCommentMetadataBuilder.updateCommentsToJavaParser(annotationExpression, annotation.getCommentStructure());\r\n    annotations.add(annotationExpression);\r\n    if (!memberValuePairs.isEmpty()) {\r\n        if (annotationExpression instanceof MarkerAnnotationExpr) {\r\n            final MarkerAnnotationExpr mae = (MarkerAnnotationExpr) annotationExpression;\r\n            annotations.remove(mae);\r\n            if (memberValuePairs.size() == 1 && (memberValuePairs.get(0).getName() == null || \"value\".equals(memberValuePairs.get(0).getName()))) {\r\n                final Expression toUse = JavaParserUtils.importExpressionIfRequired(compilationUnitServices.getEnclosingTypeName(), compilationUnitServices.getImports(), memberValuePairs.get(0).getValue());\r\n                annotationExpression = new SingleMemberAnnotationExpr(nameToUse, toUse);\r\n                JavaParserCommentMetadataBuilder.updateCommentsToJavaParser(annotationExpression, annotation.getCommentStructure());\r\n                annotations.add(annotationExpression);\r\n            } else {\r\n                annotationExpression = new NormalAnnotationExpr(nameToUse, new ArrayList<MemberValuePair>());\r\n                JavaParserCommentMetadataBuilder.updateCommentsToJavaParser(annotationExpression, annotation.getCommentStructure());\r\n                annotations.add(annotationExpression);\r\n            }\r\n        }\r\n        if (annotationExpression instanceof SingleMemberAnnotationExpr) {\r\n            final SingleMemberAnnotationExpr smae = (SingleMemberAnnotationExpr) annotationExpression;\r\n            if (memberValuePairs.size() == 1 && memberValuePairs.get(0).getName() == null || memberValuePairs.get(0).getName().equals(\"value\") || memberValuePairs.get(0).getName().equals(\"\")) {\r\n                final Expression toUse = JavaParserUtils.importExpressionIfRequired(compilationUnitServices.getEnclosingTypeName(), compilationUnitServices.getImports(), memberValuePairs.get(0).getValue());\r\n                smae.setMemberValue(toUse);\r\n                return;\r\n            }\r\n            final Expression existingValue = smae.getMemberValue();\r\n            annotationExpression = new NormalAnnotationExpr(smae.getName(), new ArrayList<MemberValuePair>());\r\n            ((NormalAnnotationExpr) annotationExpression).getPairs().add(new MemberValuePair(\"value\", existingValue));\r\n        }\r\n        Validate.isInstanceOf(NormalAnnotationExpr.class, annotationExpression, \"Attempting to add >1 annotation member-value pair requires an existing normal annotation expression\");\r\n        final List<MemberValuePair> annotationPairs = ((NormalAnnotationExpr) annotationExpression).getPairs();\r\n        annotationPairs.clear();\r\n        for (final MemberValuePair pair : memberValuePairs) {\r\n            final Expression toUse = JavaParserUtils.importExpressionIfRequired(compilationUnitServices.getEnclosingTypeName(), compilationUnitServices.getImports(), pair.getValue());\r\n            pair.setValue(toUse);\r\n            annotationPairs.add(pair);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.convert.ConverterImpl.toObject",
	"Comment": "converts the string to an object of the given type, parsing after the given format.",
	"Method": "Object toObject(String pString,Class pType,String pFormat){\r\n    if (pString == null) {\r\n        return null;\r\n    }\r\n    if (pType == null) {\r\n        throw new MissingTypeException();\r\n    }\r\n    PropertyConverter converter = getConverterForType(pType);\r\n    if (converter == null) {\r\n        throw new NoAvailableConverterException(\"Cannot convert to object, no converter available for type \\\"\" + pType.getName() + \"\\\"\");\r\n    }\r\n    return converter.toObject(pString, pType, pFormat);\r\n}"
}, {
	"Path": "teammates.logic.api.EmailSender.getEmailsSent",
	"Comment": "gets the emails sent.this method is used only for testing, where it is overridden.",
	"Method": "List<EmailWrapper> getEmailsSent(){\r\n    throw new UnsupportedOperationException(\"Method is used only for testing\");\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackContributionResponseDetails.getAnswerCsv",
	"Comment": "not used for contribution question, due to calculations required. see corresponding function below.",
	"Method": "String getAnswerCsv(FeedbackQuestionDetails questionDetails,String getAnswerCsv,FeedbackResponseAttributes response,FeedbackQuestionAttributes question,FeedbackSessionResultsBundle feedbackSessionResultsBundle){\r\n    return getContributionQuestionResponseAnswerCsv(response, question, feedbackSessionResultsBundle);\r\n}"
}, {
	"Path": "tla2sany.parser.ParseException.add_escapes",
	"Comment": "used to convert raw characters to their escaped versionwhen these raw version cannot be used as part of an asciistring literal.",
	"Method": "String add_escapes(String str){\r\n    StringBuffer retval = new StringBuffer();\r\n    char ch;\r\n    for (int i = 0; i < str.length(); i++) {\r\n        switch(str.charAt(i)) {\r\n            case 0:\r\n                continue;\r\n            case '\\b':\r\n                retval.append(\"\\\\b\");\r\n                continue;\r\n            case '\\t':\r\n                retval.append(\"\\\\t\");\r\n                continue;\r\n            case '\\n':\r\n                retval.append(\"\\\\n\");\r\n                continue;\r\n            case '\\f':\r\n                retval.append(\"\\\\f\");\r\n                continue;\r\n            case '\\r':\r\n                retval.append(\"\\\\r\");\r\n                continue;\r\n            case '\\\"':\r\n                retval.append(\"\\\\\\\"\");\r\n                continue;\r\n            case '\\'':\r\n                retval.append(\"\\\\\\'\");\r\n                continue;\r\n            case '\\\\':\r\n                retval.append(\"\\\\\\\\\");\r\n                continue;\r\n            default:\r\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\r\n                    String s = \"0000\" + Integer.toString(ch, 16);\r\n                    retval.append(\"\\\%u\" + s.substring(s.length() - 4, s.length()));\r\n                } else {\r\n                    retval.append(ch);\r\n                }\r\n                continue;\r\n        }\r\n    }\r\n    return retval.toString();\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.getTextsForAllStatusMessagesToUser",
	"Comment": "returns a list containing the texts of the user status messages in the page.",
	"Method": "List<String> getTextsForAllStatusMessagesToUser(){\r\n    List<WebElement> statusMessagesToUser = statusMessage.findElements(By.tagName(\"div\"));\r\n    List<String> statusMessageTexts = new ArrayList<String>();\r\n    for (WebElement statusMessage : statusMessagesToUser) {\r\n        statusMessageTexts.add(statusMessage.getText());\r\n    }\r\n    return statusMessageTexts;\r\n}"
}, {
	"Path": "tlc2.value.Value.toString",
	"Comment": "this abstract method returns a string representation of thisvalue. each subclass must provide its own implementation.",
	"Method": "StringBuffer toString(StringBuffer sb,int offset,String toString,String toString,String delim){\r\n    try {\r\n        StringBuffer sb = new StringBuffer();\r\n        sb = this.toString(sb, 0);\r\n        sb.append(delim);\r\n        return sb.toString();\r\n    } catch (RuntimeException | OutOfMemoryError e) {\r\n        if (hasSource()) {\r\n            throw FingerprintException.getNewHead(this, e);\r\n        } else {\r\n            throw e;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.StringUtil.ltrim",
	"Comment": "trims the argument string for whitespace on the left side only.",
	"Method": "String ltrim(String pString){\r\n    if ((pString == null) || (pString.length() == 0)) {\r\n        return pString;\r\n    }\r\n    for (int i = 0; i < pString.length(); i++) {\r\n        if (!Character.isWhitespace(pString.charAt(i))) {\r\n            if (i == 0) {\r\n                return pString;\r\n            } else {\r\n                return pString.substring(i);\r\n            }\r\n        }\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.launch.TraceExplorerDelegate.writeModelInfo",
	"Comment": "writes constants, model values, new definitions, and overrides to the model writer.for a more detailed description of what the calls in this method do, see thecorresponding part of tlcmodellaunchdelegate.buildforlaunch.",
	"Method": "void writeModelInfo(ILaunchConfiguration config,ModelWriter writer){\r\n    final List<Assignment> constants = ModelHelper.deserializeAssignmentList(config.getAttribute(MODEL_PARAMETER_CONSTANTS, new Vector<String>()), true);\r\n    TypedSet modelValues = TypedSet.parseSet(config.getAttribute(MODEL_PARAMETER_MODEL_VALUES, EMPTY_STRING));\r\n    writer.addConstants(constants, modelValues, MODEL_PARAMETER_CONSTANTS, MODEL_PARAMETER_MODEL_VALUES);\r\n    writer.addNewDefinitions(config.getAttribute(MODEL_PARAMETER_NEW_DEFINITIONS, EMPTY_STRING), MODEL_PARAMETER_NEW_DEFINITIONS);\r\n    writer.addConstantsBis(constants, MODEL_PARAMETER_CONSTANTS);\r\n    List<Assignment> overrides = ModelHelper.deserializeAssignmentList(config.getAttribute(MODEL_PARAMETER_DEFINITIONS, new Vector<String>()));\r\n    writer.addFormulaList(ModelWriter.createOverridesContent(overrides, ModelWriter.DEFOV_SCHEME), \"CONSTANT\", MODEL_PARAMETER_DEFINITIONS);\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackSessionsDb.deleteStudentRespondent",
	"Comment": "the objectify library does not support throwing checked exceptions inside transactions",
	"Method": "void deleteStudentRespondent(String email,FeedbackSessionAttributes feedbackSession){\r\n    Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, email);\r\n    Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSession);\r\n    feedbackSession.sanitizeForSaving();\r\n    if (!feedbackSession.isValid()) {\r\n        throw new InvalidParametersException(feedbackSession.getInvalidityInfo());\r\n    }\r\n    try {\r\n        ofy().transact(new VoidWork() {\r\n            @Override\r\n            public void vrun() {\r\n                FeedbackSession fs = getEntity(feedbackSession);\r\n                if (fs == null) {\r\n                    throw new RuntimeException(new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString()));\r\n                }\r\n                fs.getRespondingStudentList().remove(email);\r\n                saveEntity(fs, feedbackSession);\r\n            }\r\n        });\r\n    } catch (RuntimeException e) {\r\n        if (e.getCause() instanceof EntityDoesNotExistException) {\r\n            throw (EntityDoesNotExistException) e.getCause();\r\n        }\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackSessionsDb.deleteStudentRespondent",
	"Comment": "the objectify library does not support throwing checked exceptions inside transactions",
	"Method": "void deleteStudentRespondent(String email,FeedbackSessionAttributes feedbackSession){\r\n    FeedbackSession fs = getEntity(feedbackSession);\r\n    if (fs == null) {\r\n        throw new RuntimeException(new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString()));\r\n    }\r\n    fs.getRespondingStudentList().remove(email);\r\n    saveEntity(fs, feedbackSession);\r\n}"
}, {
	"Path": "teammates.test.driver.HtmlHelper.areSameHtml",
	"Comment": "verifies that two html files are logically equivalent, e.g. ignoresdifferences in whitespace and attribute order.",
	"Method": "boolean areSameHtml(String expected,String actual,boolean isPart){\r\n    return assertSameHtml(expected, actual, isPart, false);\r\n}"
}, {
	"Path": "teammates.ui.controller.StudentProfilePictureEditAction.readAllPostParameterValuesToFields",
	"Comment": "gets all the parameters from the request and ensures that they are not null.",
	"Method": "void readAllPostParameterValuesToFields(){\r\n    leftXString = getLeftXString();\r\n    topYString = getTopYString();\r\n    rightXString = getRightXString();\r\n    bottomYString = getBottomYString();\r\n    heightString = getPictureHeight();\r\n    widthString = getPictureWidth();\r\n    blobKey = getBlobKey();\r\n    rotateString = getRotateString();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.preference.SWTFactory.createVerticalSpacer",
	"Comment": "creates a vertical spacer for separating components. if applied to a \tgridlayout, this method will automatically span all of the columns of the parent\tto make vertical space",
	"Method": "void createVerticalSpacer(Composite parent,int numlines){\r\n    Label lbl = new Label(parent, SWT.NONE);\r\n    GridData gd = new GridData(GridData.FILL_HORIZONTAL);\r\n    Layout layout = parent.getLayout();\r\n    if (layout instanceof GridLayout) {\r\n        gd.horizontalSpan = ((GridLayout) parent.getLayout()).numColumns;\r\n    }\r\n    gd.heightHint = numlines;\r\n    lbl.setLayoutData(gd);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.output.data.TraceExplorerDataProvider.connectToSourceRegistry",
	"Comment": "this is currently called by the constructor of tlcmodellaunchdataproviderthere are two different tlc output source registries,one for trace exploration and one for model checking. thisconnects to the one for trace exploration.",
	"Method": "void connectToSourceRegistry(){\r\n    TLCOutputSourceRegistry.getTraceExploreSourceRegistry().connect(this);\r\n}"
}, {
	"Path": "org.squirrelframework.foundation.util.ReflectUtils.isUserDefinedMethod",
	"Comment": "returns true if method is user defined and not defined in object class.",
	"Method": "boolean isUserDefinedMethod(Method method){\r\n    return method.getDeclaringClass() != Object.class;\r\n}"
}, {
	"Path": "tla2sany.parser.BracketStack.newClass",
	"Comment": "the following three methods seem to be used only to create a single bracketstack object and initialize its classes field.",
	"Method": "void newClass(){\r\n    classIndex++;\r\n}"
}, {
	"Path": "sharedcode.turboeditor.activity.SelectFileActivity.finishWithResult",
	"Comment": "finish this activity with a result code and uri of the selected file.",
	"Method": "void finishWithResult(File file){\r\n    if (file != null) {\r\n        Uri uri = Uri.fromFile(file);\r\n        setResult(RESULT_OK, new Intent().setData(uri));\r\n        finish();\r\n    } else {\r\n        setResult(RESULT_CANCELED);\r\n        finish();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.project.PomManagementServiceImpl.getMetadataDependencyRegistry",
	"Comment": "method to get metadatadependencyregistry service implementation",
	"Method": "MetadataDependencyRegistry getMetadataDependencyRegistry(){\r\n    if (metadataDependencyRegistry == null) {\r\n        try {\r\n            ServiceReference<?>[] references = context.getAllServiceReferences(MetadataDependencyRegistry.class.getName(), null);\r\n            for (ServiceReference<?> ref : references) {\r\n                metadataDependencyRegistry = (MetadataDependencyRegistry) context.getService(ref);\r\n                return metadataDependencyRegistry;\r\n            }\r\n            return null;\r\n        } catch (InvalidSyntaxException e) {\r\n            LOGGER.warning(\"Cannot load MetadataDependencyRegistry on PomManagementServiceImpl.\");\r\n            return null;\r\n        }\r\n    } else {\r\n        return metadataDependencyRegistry;\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.util.EditorUtil.locationContainment",
	"Comment": "returns true iff the location loc1 is contained within location loc2,where the file names of the locations are ignored.",
	"Method": "boolean locationContainment(Location loc1,Location loc2){\r\n    if ((loc1.beginLine() < loc2.beginLine()) || ((loc1.beginLine() == loc2.beginLine()) && (loc1.beginColumn() < loc2.beginColumn()))) {\r\n        return false;\r\n    }\r\n    return (loc1.endLine() < loc2.endLine()) || ((loc1.endLine() == loc2.endLine()) && (loc1.endColumn() <= loc2.endColumn()));\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.StringSet.clone",
	"Comment": "returns a shallow copy of the set, which for strings isequivalent to a deep copy.",
	"Method": "StringSet clone(){\r\n    StringSet result = new StringSet();\r\n    for (int i = 0; i < contents.size(); i++) {\r\n        result.add(contents.elementAt(i));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.comments.JavadocComment.addThrowsInfo",
	"Comment": "adds or changes javadoccomment throws info. existing info will bereplaced by this one.",
	"Method": "void addThrowsInfo(List<String> throwsInfo){\r\n    Validate.isTrue(StringUtils.isNotBlank(getComment()), \"JavadocComment needs to have a description value before adding throws info to it. \" + \"You can do that using 'setDescription(String)' method first, or full constructor.\");\r\n    if (throwsInfo == null || throwsInfo.isEmpty()) {\r\n        return;\r\n    }\r\n    initializeCommentIndexes();\r\n    this.beginThrowsIndex = this.endReturnIndex;\r\n    this.commentBuilder.delete(this.beginThrowsIndex, this.endThrowsIndex);\r\n    int nextLineStartingIndex = this.beginThrowsIndex;\r\n    for (String entry : throwsInfo) {\r\n        String[] lines = entry.split(IOUtils.LINE_SEPARATOR);\r\n        for (int i = 0; i < lines.length; i++) {\r\n            String newLine = \"\";\r\n            if (i == 0) {\r\n                newLine = (\" * @throws \").concat(lines[i]).concat(IOUtils.LINE_SEPARATOR);\r\n            } else {\r\n                newLine = (\" * \").concat(\"\\t\\t\\t\\t\").concat(lines[i]).concat(IOUtils.LINE_SEPARATOR);\r\n            }\r\n            this.commentBuilder.insert(nextLineStartingIndex, newLine);\r\n            int newLineLenght = newLine.length();\r\n            nextLineStartingIndex += newLineLenght;\r\n            this.endThrowsIndex += newLineLenght;\r\n        }\r\n    }\r\n    super.setComment(this.commentBuilder.toString());\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.getFeedbackSessionResultsForInstructorToSectionWithinRange",
	"Comment": "gets results of a feedback session to show to an instructor in a section in an indicated range.",
	"Method": "FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorToSectionWithinRange(String feedbackSessionName,String courseId,String userEmail,String section,int range){\r\n    CourseRoster roster = new CourseRoster(studentsLogic.getStudentsForCourse(courseId), instructorsLogic.getInstructorsForCourse(courseId));\r\n    Map<String, String> params = new HashMap();\r\n    params.put(PARAM_IS_INCLUDE_RESPONSE_STATUS, \"true\");\r\n    params.put(PARAM_IN_SECTION, \"false\");\r\n    params.put(PARAM_FROM_SECTION, \"false\");\r\n    params.put(PARAM_TO_SECTION, \"true\");\r\n    params.put(PARAM_SECTION, section);\r\n    if (range > 0) {\r\n        params.put(PARAM_RANGE, String.valueOf(range));\r\n    }\r\n    return getFeedbackSessionResultsForUserWithParams(feedbackSessionName, courseId, userEmail, UserRole.INSTRUCTOR, roster, params);\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.TimeoutMap.setExpiryTime",
	"Comment": "sets the maximum time any value will be kept in the map, before it expires.removes any items that are older than the specified time.",
	"Method": "void setExpiryTime(long pExpiryTime){\r\n    long oldEexpiryTime = expiryTime;\r\n    expiryTime = pExpiryTime;\r\n    if (expiryTime < oldEexpiryTime) {\r\n        nextExpiryTime = 0;\r\n        removeExpiredEntries();\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.plugins.hdr.RGBE.readPixels",
	"Comment": "simple read routine.will not correctly handle run length encoding.",
	"Method": "void readPixels(DataInput in,float[] data,int numpixels){\r\n    byte[] rgbe = new byte[4];\r\n    float[] rgb = new float[3];\r\n    int offset = 0;\r\n    while (numpixels-- > 0) {\r\n        in.readFully(rgbe);\r\n        rgbe2float(rgb, rgbe, 0);\r\n        data[offset++] = rgb[0];\r\n        data[offset++] = rgb[1];\r\n        data[offset++] = rgb[2];\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.PhysicalTypeIdentifierNamingUtils.getJavaType",
	"Comment": "returns the user project type with which the given metadata id isassociated.",
	"Method": "JavaType getJavaType(String metadataIdentificationString,JavaType getJavaType,String metadataClass,String metadataId){\r\n    final String instanceKey = getInstanceKey(metadataClass, metadataId);\r\n    return new JavaType(instanceKey.substring(instanceKey.indexOf(PATH_SUFFIX) + 1), getModuleFromIdentificationString(metadataId));\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.SystemUtil.loadProperties",
	"Comment": "returns a properties, loaded from the given inputstream. if the given inputstream is null, then an empty properties object is returned.",
	"Method": "Properties loadProperties(Class pClass,String pName,Properties loadProperties,Class pClass,Properties loadProperties,String pName,Properties loadProperties,InputStream pInput){\r\n    if (pInput == null) {\r\n        throw new IllegalArgumentException(\"InputStream == null!\");\r\n    }\r\n    Properties mapping = new Properties();\r\n    mapping.load(pInput);\r\n    return mapping;\r\n}"
}, {
	"Path": "teammates.ui.pagedata.StudentFeedbackResultsPageData.createFeedbackResultsQuestionsWithResponses",
	"Comment": "parses the contents of the map and keeps only those data which will be displayed on the browser.",
	"Method": "void createFeedbackResultsQuestionsWithResponses(Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> questionsWithResponses){\r\n    feedbackResultsQuestionsWithResponses = new ArrayList();\r\n    int questionIndex = 1;\r\n    for (Map.Entry<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> questionWithResponses : questionsWithResponses.entrySet()) {\r\n        FeedbackQuestionAttributes question = questionWithResponses.getKey();\r\n        List<FeedbackResponseAttributes> responsesBundle = questionWithResponses.getValue();\r\n        FeedbackQuestionDetails questionDetailsBundle = question.getQuestionDetails();\r\n        FeedbackResultsQuestionDetails questionDetails = createQuestionDetails(questionIndex, question, questionDetailsBundle, responsesBundle);\r\n        List<FeedbackResultsResponseTable> responseTables = createResponseTables(question, responsesBundle);\r\n        feedbackResultsQuestionsWithResponses.add(new StudentFeedbackResultsQuestionWithResponses(questionDetails, responseTables));\r\n        questionIndex++;\r\n    }\r\n}"
}, {
	"Path": "tlc2.util.DotStateWriter.dotLegend",
	"Comment": "creates a dot legend that maps actions to their corresponding edge color in the state graph.",
	"Method": "String dotLegend(String name,Set<String> actions){\r\n    final StringBuilder sb = new StringBuilder();\r\n    sb.append(String.format(\"subgraph %s {\", \"cluster_legend\"));\r\n    sb.append(\"graph[style=bold];\");\r\n    sb.append(\"label = \\\"Next State Actions\\\" style=\\\"solid\\\"\\n\");\r\n    sb.append(String.format(\"node [ labeljust=\\\"l\\\",colorscheme=\\\"%s\\\",style=filled,shape=record ]\\n\", dotColorScheme));\r\n    for (String action : actions) {\r\n        String str = String.format(\"%s [label=\\\"%s\\\",fillcolor=%d]\", action, action, this.actionToColors.get(action));\r\n        sb.append(str);\r\n        sb.append(\"\\n\");\r\n    }\r\n    sb.append(\"}\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.squirrelframework.foundation.util.ReflectUtils.getMethod",
	"Comment": "searches for the method in the given class and in its super classes",
	"Method": "Method getMethod(Class<?> clazz,String methodName,Class<?>[] parameterTypes,Method getMethod,Class<?> clazz,String methodName,Class<?>[] parameterTypes,Class<?> original){\r\n    Method method = null;\r\n    try {\r\n        method = clazz.getDeclaredMethod(methodName, parameterTypes);\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(\"found method \" + getClassNameSafe(clazz) + \".\" + methodName + \"(\" + Arrays.toString(parameterTypes) + \")\");\r\n        }\r\n    } catch (SecurityException e) {\r\n        throw new SquirrelRuntimeException(e, ErrorCodes.NOT_ALLOW_ACCESS_METHOD, getClassNameSafe(clazz), methodName, getParameterTypesText(parameterTypes));\r\n    } catch (NoSuchMethodException e) {\r\n        if (clazz.getSuperclass() != null) {\r\n            return getMethod(clazz.getSuperclass(), methodName, parameterTypes, original);\r\n        } else {\r\n            throw new SquirrelRuntimeException(e, ErrorCodes.METHOD_NOT_FOUND, original.getName(), methodName, getParameterTypesText(parameterTypes));\r\n        }\r\n    }\r\n    return method;\r\n}"
}, {
	"Path": "tlc2.util.ObjLongTable.mergeInto",
	"Comment": "merges the keys and longs of into this instance. if this instance already\tcontains an entry with a given key, the long values will be accumulated.",
	"Method": "ObjLongTable<T> mergeInto(ObjLongTable<T> other){\r\n    T key;\r\n    final ObjLongTable<T>.Enumerator<T> keys2 = other.keys();\r\n    while ((key = keys2.nextElement()) != null) {\r\n        add(key, other.get(key));\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.roo.shell.SimpleParser.suggestOptionKey",
	"Comment": "suggests command option keys when the user try to autocomplete.",
	"Method": "void suggestOptionKey(ShellContextImpl shellContext,String translated,SortedSet<Completion> results,MethodTarget methodTarget,Map<String, String> options,List<CliOption> unspecified,String lastOptionValue,List<CliOption> alreadySpecified){\r\n    boolean showAllRemaining = true;\r\n    for (final CliOption include : unspecified) {\r\n        if (isMandatoryParam(methodTarget.getKey(), include, shellContext)) {\r\n            showAllRemaining = false;\r\n            break;\r\n        }\r\n    }\r\n    if (lastOptionValue != null && lastOptionValue.equals(\"-\") && showAllRemaining == true) {\r\n        for (CliOption option : alreadySpecified) {\r\n            if (option.key().length > 1) {\r\n                for (String key : option.key()) {\r\n                    if (!(\"\").equals(key)) {\r\n                        results.add(new Completion(translated.concat(\"-\").concat(key).concat(\" \")));\r\n                        showAllRemaining = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (!showAllRemaining) {\r\n        for (final CliOption include : unspecified) {\r\n            if (isMandatoryParam(methodTarget.getKey(), include, shellContext) && isVisibleParam(methodTarget.getKey(), include, shellContext)) {\r\n                for (final String value : include.key()) {\r\n                    if (!\"\".equals(value)) {\r\n                        if (methodTarget.getRemainingBuffer().endsWith(\"--\")) {\r\n                            results.add(new Completion(StringUtils.stripEnd(translated, null).concat(value).concat(\" \")));\r\n                        } else if (methodTarget.getRemainingBuffer().endsWith(\" -\") || methodTarget.getRemainingBuffer().length() == 1) {\r\n                            results.add(new Completion(StringUtils.stripEnd(translated, null).concat(\"-\").concat(value).concat(\" \")));\r\n                        } else {\r\n                            results.add(new Completion(translated.concat(\"--\").concat(value).concat(\" \")));\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        for (final CliOption include : unspecified) {\r\n            if (isVisibleParam(methodTarget.getKey(), include, shellContext)) {\r\n                for (final String value : include.key()) {\r\n                    if (!\"\".equals(value)) {\r\n                        if (methodTarget.getRemainingBuffer().endsWith(\"--\")) {\r\n                            results.add(new Completion(StringUtils.stripEnd(translated, null).concat(value).concat(\" \")));\r\n                        } else if (methodTarget.getRemainingBuffer().endsWith(\" -\") || methodTarget.getRemainingBuffer().length() == 1) {\r\n                            results.add(new Completion(StringUtils.stripEnd(translated, null).concat(\"-\").concat(value).concat(\" \")));\r\n                        } else {\r\n                            results.add(new Completion(translated.concat(\"--\").concat(value).concat(\" \")));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (hasShellContextParameter(methodTarget.getMethod())) {\r\n            for (String parameter : globalParameters) {\r\n                if (!options.containsKey(parameter)) {\r\n                    if (!\"\".equals(parameter)) {\r\n                        if (methodTarget.getRemainingBuffer().endsWith(\"--\")) {\r\n                            results.add(new Completion(StringUtils.stripEnd(translated, null).concat(parameter).concat(\" \")));\r\n                        } else if (methodTarget.getRemainingBuffer().endsWith(\" -\") || methodTarget.getRemainingBuffer().length() == 1) {\r\n                            results.add(new Completion(StringUtils.stripEnd(translated, null).concat(\"-\").concat(parameter).concat(\" \")));\r\n                        } else {\r\n                            results.add(new Completion(translated.concat(\"--\").concat(parameter).concat(\" \")));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.view.ObligationsView.removeItem",
	"Comment": "removes the item from the view, performing necessarycleanup.",
	"Method": "void removeItem(ExpandItem item){\r\n    fontListener.removeControl(((SourceViewer) viewers.get(item)).getControl());\r\n    final Object data = item.getData(KEY);\r\n    items.remove(Integer.parseInt(data.toString()));\r\n    item.getControl().dispose();\r\n    item.dispose();\r\n}"
}, {
	"Path": "teammates.test.cases.browsertests.AdminSearchPageUiTest.assertStudentRowDisplayed",
	"Comment": "returns true if the student is displayed correctly in the student table.",
	"Method": "void assertStudentRowDisplayed(StudentAttributes student,InstructorAttributes instructorToMasquaradeAs,CourseAttributes course){\r\n    WebElement studentRow = searchPage.getStudentRow(student);\r\n    assertStudentContentCorrect(studentRow, student, course);\r\n    assertTrue(isStudentLinkCorrect(studentRow, student, instructorToMasquaradeAs));\r\n}"
}, {
	"Path": "teammates.test.cases.browsertests.AdminEmailPageUiTest.isEmailTrashDataDisplayCorrect",
	"Comment": "this method only checks if the email trash data table is displayed correctlyi.e, table headers are correct.it does not test for the table content.",
	"Method": "boolean isEmailTrashDataDisplayCorrect(){\r\n    return emailPage.isElementPresent(By.className(\"table\")) && isEmptyTrashButtonPresent() && isEmailTableHeaderCorrect();\r\n}"
}, {
	"Path": "com.twelvemonkeys.io.FileUtil.copy",
	"Comment": "copies all data from one stream to another.the data is copied from the fromstream to the tostream using bufferedstreams for efficiency.",
	"Method": "boolean copy(String pFromFileName,String pToFileName,boolean copy,String pFromFileName,String pToFileName,boolean pOverWrite,boolean copy,File pFromFile,File pToFile,boolean copy,File pFromFile,File pToFile,boolean pOverWrite,boolean copy,InputStream pFrom,OutputStream pTo){\r\n    Validate.notNull(pFrom, \"from\");\r\n    Validate.notNull(pTo, \"to\");\r\n    InputStream in = new BufferedInputStream(pFrom, BUF_SIZE * 2);\r\n    OutputStream out = new BufferedOutputStream(pTo, BUF_SIZE * 2);\r\n    byte[] buffer = new byte[BUF_SIZE];\r\n    int count;\r\n    while ((count = in.read(buffer)) != -1) {\r\n        out.write(buffer, 0, count);\r\n    }\r\n    out.flush();\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.DomUtils.getChildTextContent",
	"Comment": "returns the text content of the first child of the given parent that hasthe given tag name, if any.",
	"Method": "String getChildTextContent(Element parent,String child){\r\n    final List<Element> children = XmlUtils.findElements(child, parent);\r\n    if (children.isEmpty()) {\r\n        return null;\r\n    }\r\n    return getTextContent(children.get(0), null);\r\n}"
}, {
	"Path": "tla2sany.modanalyzer.SpecObj.findNextUnresolvedInstantiationBody",
	"Comment": "more unresolved instances names in the entire specification.",
	"Method": "boolean findNextUnresolvedInstantiationBody(ModulePointer currentModule,HashSet alreadyVisited){\r\n    if (alreadyVisited.contains(currentModule)) {\r\n        instantiationFound = false;\r\n        return false;\r\n    }\r\n    alreadyVisited.add(currentModule);\r\n    ModuleContext currentContext = currentModule.getContext();\r\n    Vector extendees = currentModule.getNamesOfModulesExtended();\r\n    Vector instancees = currentModule.getNamesOfModulesInstantiated();\r\n    for (int i = 0; i < instancees.size(); i++) {\r\n        if (currentContext.resolve((String) instancees.elementAt(i)) == null) {\r\n            if (!instanceResolvesToInternalModule(currentModule, (String) instancees.elementAt(i))) {\r\n                nextParseUnitName = (String) instancees.elementAt(i);\r\n                nextExtenderOrInstancerModule = currentModule;\r\n                instantiationFound = true;\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < extendees.size(); i++) {\r\n        if (findNextUnresolvedInstantiationBody(currentContext.resolve((String) extendees.elementAt(i)), alreadyVisited)) {\r\n            instantiationFound = true;\r\n            return true;\r\n        }\r\n    }\r\n    for (int i = 0; i < instancees.size(); i++) {\r\n        if (currentContext.resolve((String) instancees.elementAt(i)) != null) {\r\n            if (findNextUnresolvedInstantiationBody(currentContext.resolve((String) instancees.elementAt(i)), alreadyVisited)) {\r\n                instantiationFound = true;\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    Vector innerModules = currentModule.getDirectInnerModules();\r\n    for (int i = 0; i < innerModules.size(); i++) {\r\n        if (findNextUnresolvedInstantiationBody((ModulePointer) innerModules.elementAt(i), alreadyVisited)) {\r\n            instantiationFound = true;\r\n            return true;\r\n        }\r\n    }\r\n    instantiationFound = false;\r\n    return false;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackEditPage.isAlertClassEnabledForVisibilityOptions",
	"Comment": "checks if alert class is enabled on the visibility options div for the specified question number.",
	"Method": "boolean isAlertClassEnabledForVisibilityOptions(int questionNo){\r\n    String visibilityOptionsDivXPath = \"//div[@id='questionTable-\" + questionNo + \"']//div[@class='visibility-checkbox-delegate panel-body']\" + \"//b[@class='visibility-title']/../..\";\r\n    return browser.driver.findElement(By.xpath(visibilityOptionsDivXPath)).getAttribute(\"class\").matches(\".*\\\\balert alert-danger\\\\b.*\");\r\n}"
}, {
	"Path": "tla2sany.semantic.TheoremNode.getName",
	"Comment": "return the name of the theorem if it is a named theorem, else returnnull.",
	"Method": "UniqueString getName(){\r\n    if (def == null) {\r\n        return null;\r\n    }\r\n    ;\r\n    return def.getName();\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackQuestionsLogic.getFeedbackQuestion",
	"Comment": "gets a single question corresponding to the given parameters.",
	"Method": "FeedbackQuestionAttributes getFeedbackQuestion(String feedbackQuestionId,FeedbackQuestionAttributes getFeedbackQuestion,String feedbackSessionName,String courseId,int questionNumber){\r\n    return fqDb.getFeedbackQuestion(feedbackSessionName, courseId, questionNumber);\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.deleteFeedbackSessionCascade",
	"Comment": "permanently deletes a specific feedback session in recycle bin, and all its questions and responses.",
	"Method": "void deleteFeedbackSessionCascade(String feedbackSessionName,String courseId){\r\n    fqLogic.deleteFeedbackQuestionsCascadeForSession(feedbackSessionName, courseId);\r\n    FeedbackSessionAttributes sessionToDelete = FeedbackSessionAttributes.builder(feedbackSessionName, courseId, \"\").build();\r\n    fsDb.deleteEntity(sessionToDelete);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.actions.ProofFoldAction.run",
	"Comment": "if the caret is located within a proof, collapses andexpands the appropriate proofs.",
	"Method": "void run(){\r\n    if (getTextEditor() instanceof TLAEditor) {\r\n        TLAEditor editor = (TLAEditor) getTextEditor();\r\n        editor.runFoldOperation(getActionDefinitionId());\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.MapAbstractTest.makeEntryArray",
	"Comment": "utility methods to create an array of map.entry objectsout of the given key and value arrays.",
	"Method": "Map.Entry[] makeEntryArray(Object[] keys,Object[] values){\r\n    Map.Entry[] result = new Map.Entry[keys.length];\r\n    for (int i = 0; i < keys.length; i++) {\r\n        Map map = makeConfirmedMap();\r\n        map.put(keys[i], values[i]);\r\n        result[i] = (Map.Entry) map.entrySet().iterator().next();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "tlc2.tool.Simulator.shutdownAndJoinWorkers",
	"Comment": "shut down all of the given workers and make sure they have stopped.",
	"Method": "void shutdownAndJoinWorkers(List<SimulationWorker> workers){\r\n    for (SimulationWorker worker : workers) {\r\n        worker.interrupt();\r\n        worker.join();\r\n    }\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.activities.scheduled_tweets.NewScheduledTweet.discardClick",
	"Comment": "finishes the activity when the discard button is clicked, without making any changes or saving anything",
	"Method": "boolean discardClick(){\r\n    finish();\r\n    return true;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.output.source.StateTagBasedTLCOutputIncrementalParserTest.verifyParserOutput",
	"Comment": "verify parser finished successfully recognizing all states",
	"Method": "void verifyParserOutput(){\r\n    Assert.assertTrue(testListener.isDone());\r\n    final List<TLCState> parsedStates = testListener.getStates();\r\n    Assert.assertEquals(STATES, parsedStates.size());\r\n    for (Iterator<TLCState> iterator = parsedStates.iterator(); iterator.hasNext(); ) {\r\n        final TLCState tlcState = iterator.next();\r\n        final int stateNumber = tlcState.getStateNumber();\r\n        Assert.assertEquals(STATE_NUM, stateNumber);\r\n        final String label = tlcState.getLabel();\r\n        Assert.assertEquals(LABEL, label);\r\n        final TLCVariable[] variables = tlcState.getVariables();\r\n        Assert.assertEquals(EXPECTED_VARS, variables.length);\r\n        for (int i = 0; i < variables.length; i++) {\r\n            final TLCVariable tlcVariable = variables[i];\r\n            final String varName = tlcVariable.getName();\r\n            final String expectedValue = vars.get(varName.trim());\r\n            TLCVariableValue actualValue = tlcVariable.getValue();\r\n            Assert.assertEquals(expectedValue, actualValue.toString());\r\n        }\r\n    }\r\n    Assert.assertEquals(STATES, testListener.getRegions().size());\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.AnimatedGifEncoder.finish",
	"Comment": "flushes any pending data and closes output file. if writing to anoutputstream, the stream is not closed.",
	"Method": "boolean finish(){\r\n    if (!started)\r\n        return false;\r\n    boolean ok = true;\r\n    started = false;\r\n    try {\r\n        out.write(0x3b);\r\n        out.flush();\r\n        if (closeStream) {\r\n            out.close();\r\n        }\r\n    } catch (IOException e) {\r\n        ok = false;\r\n    }\r\n    transIndex = 0;\r\n    out = null;\r\n    image = null;\r\n    pixels = null;\r\n    indexedPixels = null;\r\n    colorTab = null;\r\n    closeStream = false;\r\n    firstFrame = true;\r\n    return ok;\r\n}"
}, {
	"Path": "teammates.common.util.StringHelper.trim",
	"Comment": "returns a string array after removing white spaces leading andtrailing any string in the input array.",
	"Method": "String[] trim(String[] stringsToTrim){\r\n    return Arrays.stream(stringsToTrim).map(s -> s.trim()).toArray(size -> new String[size]);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.ResourceHelper.getValidParseResult",
	"Comment": "if file has been parsed since it was last written, then returnits parseresult.else, return null.",
	"Method": "ParseResult getValidParseResult(IFile file){\r\n    ParseResult parseResult = ParseResultBroadcaster.getParseResultBroadcaster().getParseResult(file.getLocation());\r\n    if ((parseResult == null)) {\r\n        return null;\r\n    }\r\n    long timeWhenParsed = parseResult.getParserCalled();\r\n    long timeWhenWritten = file.getLocalTimeStamp();\r\n    if ((timeWhenWritten == IResource.NULL_STAMP) || (timeWhenWritten > timeWhenParsed)) {\r\n        return null;\r\n    }\r\n    return parseResult;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.preference.TLCChainedPreferenceStore.registerChildListeners",
	"Comment": "register the child listeners on the child preference stores.",
	"Method": "void registerChildListeners(){\r\n    Iterator<PropertyChangeListener> iter = fChildListeners.iterator();\r\n    while (iter.hasNext()) {\r\n        PropertyChangeListener listener = iter.next();\r\n        listener.register();\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.CourseRoster.isInstructorOfCourse",
	"Comment": "checks if an instructor is the instructor of a course by providing an email address.",
	"Method": "boolean isInstructorOfCourse(String instructorEmail){\r\n    return instructorListByEmail.containsKey(instructorEmail);\r\n}"
}, {
	"Path": "pcal.ParseAlgorithm.GetLastLocationEnd",
	"Comment": "returns the pcallocation object corresponding to the position to the right of the last token returned by getalgtoken or gobbled bya gobble... method.",
	"Method": "PCalLocation GetLastLocationEnd(){\r\n    return new PCalLocation(lastTokLine - 1, lastTokCol - 1 + lastTokString.length());\r\n}"
}, {
	"Path": "tlc2.util.BufferedRandomAccessFile.init",
	"Comment": "initialize the private fields of the file so as to make it valid.",
	"Method": "void init(){\r\n    this.dirty = false;\r\n    this.lo = this.curr = this.hi = 0;\r\n    synchronized (mu) {\r\n        this.buff = (numAvailBuffs > 0) ? availBuffs[--numAvailBuffs] : new byte[BuffSz];\r\n    }\r\n    this.maxHi = BuffSz;\r\n    this.hitEOF = false;\r\n    this.diskPos = 0L;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.output.data.ObligationNumberMessage.getCount",
	"Comment": "returns the number of obligations in the message.this is the number of obligations to be proved or checked.",
	"Method": "int getCount(){\r\n    return count;\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorFeedbackResultsPageData.removeParticipantIdentifierFromList",
	"Comment": "given a participantidentifier, remove it from participantidentifierlist.",
	"Method": "void removeParticipantIdentifierFromList(List<String> participantIdentifierList,String participantIdentifier){\r\n    participantIdentifierList.remove(participantIdentifier);\r\n}"
}, {
	"Path": "teammates.test.driver.AssertHelper.assertLogIdContainsUserId",
	"Comment": "assert that the actual log message contains userid in its id field.",
	"Method": "void assertLogIdContainsUserId(String actualMessage,String userIdentifier){\r\n    int endIndex = actualMessage.lastIndexOf(Const.ActivityLog.FIELD_SEPARATOR);\r\n    String actualId = actualMessage.substring(endIndex + Const.ActivityLog.FIELD_SEPARATOR.length());\r\n    assertTrue(\"expected actual message's id to contain \" + userIdentifier + \" but was \" + actualId, actualId.contains(userIdentifier));\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.util.ModelHelper.createVariableArray",
	"Comment": "returns an array of strings containing the variables declaredin the module.added 10 sep 2009 by ll & dr",
	"Method": "String[] createVariableArray(ModuleNode moduleNode){\r\n    OpDeclNode[] variableDecls = moduleNode.getVariableDecls();\r\n    String[] returnVal = new String[variableDecls.length];\r\n    for (int i = 0; i < variableDecls.length; i++) {\r\n        returnVal[i] = variableDecls[i].getName().toString();\r\n    }\r\n    return returnVal;\r\n}"
}, {
	"Path": "org.springframework.roo.application.config.ApplicationConfigServiceImpl.getAppliCationConfigFileName",
	"Comment": "method that generates application config file name using applicationconfig file name profile parameter if exists, and config file extension.",
	"Method": "String getAppliCationConfigFileName(String profile){\r\n    String fileName = DEFAULT_APPLICATION_CONFIG_FILE_NAME;\r\n    String fileNameShellConfig = settingsService.getProperty(CONFIG_FILE_NAME_SHELL_PROPERTY);\r\n    if (fileNameShellConfig != null && StringUtils.isNotBlank(fileNameShellConfig)) {\r\n        fileName = fileNameShellConfig;\r\n    }\r\n    if (profile != null && StringUtils.isNotBlank(profile)) {\r\n        fileName = fileName.concat(\"-\").concat(profile);\r\n    }\r\n    fileName = fileName.concat(DEFAULT_APPLICATION_CONFIG_FILE_EXTENSION);\r\n    return fileName;\r\n}"
}, {
	"Path": "org.springframework.roo.project.LogicalPath.getPathRelativeToPom",
	"Comment": "returns the physical path of this logical path relative to the given pom",
	"Method": "String getPathRelativeToPom(Pom pom){\r\n    return path.getPathRelativeToPom(pom);\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.convert.Converter.toObject",
	"Comment": "converts the string to an object of the given type, parsing after the given format.",
	"Method": "Object toObject(String pString,Class pType,Object toObject,String pString,Class pType,String pFormat){\r\n    return toObject(pString, pType, null);\r\n}"
}, {
	"Path": "teammates.logic.api.Logic.getFeedbackSessionsClosedWithinThePastHour",
	"Comment": "returns returns a list of sessions that were closed within past hour.",
	"Method": "List<FeedbackSessionAttributes> getFeedbackSessionsClosedWithinThePastHour(){\r\n    return feedbackSessionsLogic.getFeedbackSessionsClosedWithinThePastHour();\r\n}"
}, {
	"Path": "util.BufferedDataInputStream.readBoolean",
	"Comment": "reads and returns the next boolean valueencoded in the next byte of this stream, orthrows eofexception if the stream isexhausted.",
	"Method": "boolean readBoolean(){\r\n    return (this.readByte() != 0);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackRubricQuestionDetails.getPercentageFrequencyString",
	"Comment": "returns a string containing percentage frequency, response frequency,and if weights are assigned, then weights.",
	"Method": "String getPercentageFrequencyString(boolean isSubQuestionRespondedTo,float[][] rubricStats,int[][] responseFrequency,int subQnIndex,int choiceIndex){\r\n    DecimalFormat df = new DecimalFormat(\"#\");\r\n    DecimalFormat dfWeight = new DecimalFormat(\"#.##\");\r\n    List<List<Double>> weights = getRubricWeights();\r\n    return (isSubQuestionRespondedTo ? df.format(rubricStats[subQnIndex][choiceIndex] * 100) + \"%\" : STATISTICS_NO_VALUE_STRING) + \" (\" + responseFrequency[subQnIndex][choiceIndex] + \")\" + (hasAssignedWeights ? \" [\" + dfWeight.format(weights.get(subQnIndex).get(choiceIndex)) + \"]\" : \"\");\r\n}"
}, {
	"Path": "teammates.test.driver.GaeSimulation.logoutUser",
	"Comment": "logs the current user out of the gae simulation environment.",
	"Method": "void logoutUser(){\r\n    helper.setEnvIsLoggedIn(false);\r\n    helper.setEnvIsAdmin(false);\r\n}"
}, {
	"Path": "org.springframework.roo.shell.SimpleParser.isMandatoryParam",
	"Comment": "method that checks if given method attribute is mandatory. takes in countif this option could be dynamicmandatory.",
	"Method": "boolean isMandatoryParam(String command,CliOption cliOption,ShellContext shellContext){\r\n    if (cliOption.mandatory()) {\r\n        String[] option = cliOption.key();\r\n        try {\r\n            MethodTarget dynamicMandatoryIndicator = dynamicMandatoryIndicators.get(command.concat(\"|\").concat(option[0]));\r\n            if (dynamicMandatoryIndicator == null) {\r\n                return cliOption.mandatory();\r\n            } else {\r\n                if (dynamicMandatoryIndicator.getMethod().getParameterTypes().length == 1) {\r\n                    return (Boolean) dynamicMandatoryIndicator.getMethod().invoke(dynamicMandatoryIndicator.getTarget(), shellContext);\r\n                }\r\n                return (Boolean) dynamicMandatoryIndicator.getMethod().invoke(dynamicMandatoryIndicator.getTarget());\r\n            }\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(String.format(\"ERROR: Error trying to get mandatory value for '%s' option on '%s' command. Please, fix errors on indicator method.\", option[0], command));\r\n        }\r\n    } else {\r\n        return cliOption.mandatory();\r\n    }\r\n}"
}, {
	"Path": "teammates.ui.pagedata.StudentFeedbackResultsPageData.createQuestionDetails",
	"Comment": "parses question details which will be displayed on the browser.",
	"Method": "FeedbackResultsQuestionDetails createQuestionDetails(int questionIndex,FeedbackQuestionAttributes question,FeedbackQuestionDetails questionDetailsBundle,List<FeedbackResponseAttributes> responsesBundle){\r\n    String questionText = questionDetailsBundle.getQuestionText();\r\n    String additionalInfo = questionDetailsBundle.getQuestionAdditionalInfoHtml(questionIndex, \"\");\r\n    String studentEmail = student == null ? null : student.email;\r\n    String questionResultStatistics = questionDetailsBundle.getQuestionResultStatisticsHtml(responsesBundle, question, studentEmail, bundle, \"student\");\r\n    boolean isIndividualResponsesShownToStudents = questionDetailsBundle.isIndividualResponsesShownToStudents();\r\n    return new FeedbackResultsQuestionDetails(Integer.toString(questionIndex), questionText, additionalInfo, questionResultStatistics, isIndividualResponsesShownToStudents);\r\n}"
}, {
	"Path": "teammates.test.driver.AssertHelper.assertLogMessageEqualsIgnoreLogId",
	"Comment": "assert that the actual log message, excluding its id, is equal to the expected log message.",
	"Method": "void assertLogMessageEqualsIgnoreLogId(String expected,String actual){\r\n    int endIndex = actual.lastIndexOf(Const.ActivityLog.FIELD_SEPARATOR);\r\n    String actualLogWithoutId = actual.substring(0, endIndex);\r\n    assertEquals(expected, actualLogWithoutId);\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.containers.Data.assort",
	"Comment": "this is used to determine whether or not to remove lines from the data array. each line will be compared to the argument. if the line contains anything from the argument, it will be removed from the data array.",
	"Method": "DATATYPE assort(DataSorting test,DATATYPE assort,String contains,DATATYPE assort,Integer start,Integer stop,DATATYPE assort,Integer start){\r\n    return (DATATYPE) assort(mLines.length, start);\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.utils.File.readMatch",
	"Comment": "search the file line by line to find a match for a specific word or sentence and return all of the matched lines or the ones not matching.",
	"Method": "FileData readMatch(String match,Boolean invert){\r\n    synchronized (mLock) {\r\n        if (isFile()) {\r\n            try {\r\n                BufferedReader reader = new BufferedReader(new java.io.FileReader(mFile));\r\n                List<String> content = new ArrayList<String>();\r\n                String line;\r\n                while ((line = reader.readLine()) != null) {\r\n                    if (invert != line.contains(match)) {\r\n                        content.add(line);\r\n                    }\r\n                }\r\n                reader.close();\r\n                return new FileData(content.toArray(new String[content.size()]));\r\n            } catch (Throwable e) {\r\n                String escapedMatch = oPatternEscape.matcher(match).replaceAll(\"\\\\\\\\$1\");\r\n                Result result = mShell.createAttempts(\"grep \" + (invert ? \"-v \" : \"\") + \"'\" + escapedMatch + \"' '\" + getAbsolutePath() + \"'\").execute(new OnShellValidateListener() {\r\n                    @Override\r\n                    public Boolean onShellValidate(String command, Integer result, List<String> output, Set<Integer> resultCodes) {\r\n                        return result.equals(0) || output.size() == 0;\r\n                    }\r\n                });\r\n                if (result.wasSuccessful()) {\r\n                    return new FileData(result.getArray());\r\n                } else {\r\n                    result = mShell.createAttempts(\"cat '\" + getAbsolutePath() + \"' 2> /dev/null\").execute();\r\n                    if (result != null && result.wasSuccessful()) {\r\n                        result.sort(new DataSorting() {\r\n                            @Override\r\n                            public Boolean test(String input) {\r\n                                return invert != input.contains(match);\r\n                            }\r\n                        });\r\n                        return new FileData(result.getArray());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.utils.File.readMatch",
	"Comment": "search the file line by line to find a match for a specific word or sentence and return all of the matched lines or the ones not matching.",
	"Method": "FileData readMatch(String match,Boolean invert){\r\n    return result.equals(0) || output.size() == 0;\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.utils.File.readMatch",
	"Comment": "search the file line by line to find a match for a specific word or sentence and return all of the matched lines or the ones not matching.",
	"Method": "FileData readMatch(String match,Boolean invert){\r\n    return invert != input.contains(match);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.AnimatedGifEncoder.writeNetscapeExt",
	"Comment": "writes netscape application extension to define repeat count.",
	"Method": "void writeNetscapeExt(){\r\n    out.write(0x21);\r\n    out.write(0xff);\r\n    out.write(11);\r\n    writeString(\"NETSCAPE\" + \"2.0\");\r\n    out.write(3);\r\n    out.write(1);\r\n    writeShort(repeat);\r\n    out.write(0);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackRubricQuestionDetails.getRubricWeightsForEachCell",
	"Comment": "extracts rubric weight values from request parameters map.",
	"Method": "List<List<Double>> getRubricWeightsForEachCell(Map<String, String[]> requestParameters,int numOfRubricChoices,int numOfRubricSubQuestions,boolean hasAssignedWeights){\r\n    List<List<Double>> rubricWeightsForEachCell = new ArrayList();\r\n    if (!hasAssignedWeights) {\r\n        return rubricWeightsForEachCell;\r\n    }\r\n    int weightRows = -1;\r\n    for (int i = 0; i < numOfRubricSubQuestions; i++) {\r\n        String subQn = HttpRequestHelper.getValueFromParamMap(requestParameters, Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_SUBQUESTION + \"-\" + i);\r\n        if (subQn == null || subQn.trim().isEmpty()) {\r\n            continue;\r\n        }\r\n        boolean rowAdded = false;\r\n        for (int j = 0; j < numOfRubricChoices; j++) {\r\n            String choice = HttpRequestHelper.getValueFromParamMap(requestParameters, Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_CHOICE + \"-\" + j);\r\n            String paramName = Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_WEIGHT + \"-\" + i + \"-\" + j;\r\n            String weight = HttpRequestHelper.getValueFromParamMap(requestParameters, paramName);\r\n            if (weight != null && choice != null) {\r\n                if (!rowAdded) {\r\n                    weightRows++;\r\n                    rubricWeightsForEachCell.add(new ArrayList<Double>());\r\n                    rowAdded = true;\r\n                }\r\n                try {\r\n                    rubricWeightsForEachCell.get(weightRows).add(Double.parseDouble(weight));\r\n                } catch (NumberFormatException e) {\r\n                    log.severe(\"Failed to parse weight for rubric question \" + weight);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return rubricWeightsForEachCell;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.UIHelper.openPerspectiveInWindowRight",
	"Comment": "opens the perspective in a new window on the right of the original window",
	"Method": "IWorkbenchWindow openPerspectiveInWindowRight(String perspectiveId,IAdaptable input,int width){\r\n    IWorkbench workbench = Activator.getDefault().getWorkbench();\r\n    Rectangle bounds = workbench.getActiveWorkbenchWindow().getShell().getBounds();\r\n    IWorkbenchWindow window = openPerspectiveInNewWindow(perspectiveId, input);\r\n    window.getShell().setBounds(bounds.x + bounds.width, bounds.y, width, bounds.height);\r\n    return window;\r\n}"
}, {
	"Path": "org.springframework.roo.model.JavaType.isPrimitive",
	"Comment": "indicates whether this type is a primitive, or in the case of an array,whether its elements are primitive.",
	"Method": "boolean isPrimitive(){\r\n    return DataType.PRIMITIVE == dataType;\r\n}"
}, {
	"Path": "org.springframework.roo.process.manager.event.AbstractProcessManagerStatusPublisher.getProcessManagerStatus",
	"Comment": "obtains the process manager status without synchronization.",
	"Method": "ProcessManagerStatus getProcessManagerStatus(){\r\n    return processManagerStatus.status;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.ResourceHelper.relocateFiles",
	"Comment": "on relocation, all linked files in the project become invalid. this method fixes this issue",
	"Method": "void relocateFiles(IProject project,IPath newLocationParent,IProgressMonitor monitor){\r\n    Assert.isNotNull(project);\r\n    Assert.isNotNull(newLocationParent);\r\n    if (!newLocationParent.hasTrailingSeparator()) {\r\n        newLocationParent.addTrailingSeparator();\r\n    }\r\n    try {\r\n        final Map<IResource, IPath> failures = new HashMap<IResource, IPath>();\r\n        IResource[] members = project.members();\r\n        monitor.beginTask(\"Relocating Files\", members.length * 2);\r\n        for (int i = 0; i < members.length; i++) {\r\n            final IResource resource = members[i];\r\n            if (resource.isLinked() && (!resource.isAccessible() || resource.getRawLocation().isAbsolute())) {\r\n                String name = members[i].getName();\r\n                IPath newLocation = newLocationParent.append(name);\r\n                members[i].delete(true, new SubProgressMonitor(monitor, 1));\r\n                if (newLocation.toFile().exists()) {\r\n                    getLinkedFile(project, ResourceHelper.PARENT_ONE_PROJECT_LOC + name, true);\r\n                    monitor.worked(1);\r\n                    Activator.getDefault().logDebug(\"File found \" + newLocation.toOSString());\r\n                } else {\r\n                    failures.put(members[i], newLocation);\r\n                    Activator.getDefault().logError(\"Error relocating files in \" + project.getName(), new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, \"Error relocating file \" + name + \". The specified location \" + newLocation.toOSString() + \" did not contain the file.\")));\r\n                }\r\n            } else {\r\n                monitor.worked(2);\r\n            }\r\n        }\r\n        if (!failures.isEmpty()) {\r\n            final StringBuffer buf = new StringBuffer(failures.size());\r\n            buf.append(String.format(\"The Toolbox failed to find %s %s while opening the %s spec:\", failures.size(), failures.size() > 1 ? \"files\" : \"file\", project.getName()));\r\n            buf.append(\"\\n\\n\");\r\n            final FilenameToStream resolver = new RCPNameToFileIStream(getTLALibraryPath(project));\r\n            for (Entry<IResource, IPath> entry : failures.entrySet()) {\r\n                final String moduleName = entry.getKey().getName();\r\n                final File resolve = resolver.resolve(moduleName, false);\r\n                boolean assumedStandardModule = resolve.exists();\r\n                final String path = entry.getValue().toOSString();\r\n                buf.append(String.format(\"%s %s\", path, assumedStandardModule == true ? \"(standard module)\" : \"\"));\r\n                buf.append(\"\\n\\n\");\r\n            }\r\n            buf.append(\"Files marked as standard modules will not cause the spec parser to fail. \" + \"If you intended to provide an overwrite of a standard module, it is up to you now to provide the module.\\n\" + \"Missing user modules will result in a parser failure and have to be manually created.\");\r\n            final UIJob job = new UIJob(\"Warning relocating files\") {\r\n                @Override\r\n                public IStatus runInUIThread(IProgressMonitor monitor) {\r\n                    MessageDialog.openWarning(UIHelper.getShell(), String.format(\"Failed to find %s spec files!\", failures.size(), failures.size() > 1 ? \"files\" : \"file\"), buf.toString());\r\n                    return Status.OK_STATUS;\r\n                }\r\n            };\r\n            job.schedule();\r\n        }\r\n    } catch (CoreException e) {\r\n        Activator.getDefault().logError(\"Error relocating files in \" + project.getName(), e);\r\n    } finally {\r\n        monitor.done();\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.ResourceHelper.relocateFiles",
	"Comment": "on relocation, all linked files in the project become invalid. this method fixes this issue",
	"Method": "void relocateFiles(IProject project,IPath newLocationParent,IProgressMonitor monitor){\r\n    MessageDialog.openWarning(UIHelper.getShell(), String.format(\"Failed to find %s spec files!\", failures.size(), failures.size() > 1 ? \"files\" : \"file\"), buf.toString());\r\n    return Status.OK_STATUS;\r\n}"
}, {
	"Path": "tla2sany.st.Location.moduleLocation",
	"Comment": "factory method to create unknown locations in a given module",
	"Method": "Location moduleLocation(String moduleName){\r\n    return new Location(UniqueString.uniqueStringOf(moduleName), 0, 0, 0, 0);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackContributionResponseDetails.getAnswerHtmlInstructorView",
	"Comment": "not used for contribution question, due to calculations required. see corresponding function below.",
	"Method": "String getAnswerHtmlInstructorView(FeedbackQuestionDetails questionDetails){\r\n    return FeedbackContributionQuestionDetails.convertToEqualShareFormatHtml(getAnswer());\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackResultsPage.waitForAjaxLoadedPanelToExpand",
	"Comment": "waits for ajax loaded panel to be expanded. the panel is expanded when ajax loading finishes,which is identified by the removal of ajax class in the element.",
	"Method": "void waitForAjaxLoadedPanelToExpand(String panelId,String ajaxClass){\r\n    WebElement panelElement = browser.driver.findElement(By.id(panelId));\r\n    waitFor(ExpectedConditions.not(ExpectedConditions.attributeContains(panelElement, \"class\", ajaxClass)));\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.editor.page.BasicFormPage.validateUsage",
	"Comment": "checks if the elements of the given list comply with the requirement of being not already defined in the contextof the current model and the specification. the method will iterate through the list and check whether every elementsatisfies the requirement. on violation, it adds the error message to the message manager.",
	"Method": "void validateUsage(String attributeName,List<String> values,String errorMessagePrefix,String elementType,String listSourceDescription,boolean addToContext){\r\n    if (values == null) {\r\n        return;\r\n    }\r\n    DataBindingManager dm = getDataBindingManager();\r\n    String sectionId = dm.getSectionForAttribute(attributeName);\r\n    if (sectionId == null) {\r\n        throw new IllegalArgumentException(\"No section for attribute \" + attributeName + \" found\");\r\n    }\r\n    Control widget = UIHelper.getWidget(dm.getAttributeControl(attributeName));\r\n    IMessageManager mm = getManagedForm().getMessageManager();\r\n    SemanticHelper helper = getLookupHelper();\r\n    String message;\r\n    for (int i = 0; i < values.size(); i++) {\r\n        String value = values.get(i);\r\n        Object usageHint = helper.getUsedHint(value);\r\n        if (usageHint != null) {\r\n            message = elementType + \" \" + value + \" may not be used, since it is \";\r\n            if (usageHint instanceof SymbolNode) {\r\n                message += \"\";\r\n                SymbolNode node = (SymbolNode) usageHint;\r\n                Location location = node.getLocation();\r\n                if (location.source().equals(SemanticHelper.TLA_BUILTIN)) {\r\n                    message += \"a built-in TLA+ definition.\";\r\n                } else {\r\n                    message += \"an identifier already defined at \" + location.toString() + \".\";\r\n                }\r\n            } else if (usageHint instanceof String) {\r\n                if (SemanticHelper.KEYWORD.equals(usageHint)) {\r\n                    message += \"a TLA+ keyword.\";\r\n                } else {\r\n                    message += \"already used in \" + usageHint;\r\n                }\r\n            } else {\r\n                message = \"Error during validation. This is a bug\";\r\n            }\r\n            mm.addMessage(errorMessagePrefix + i, message, value.toString(), IMessageProvider.ERROR, widget);\r\n            setComplete(false);\r\n            expandSection(sectionId);\r\n        } else {\r\n            if (addToContext) {\r\n                helper.addName(value, this, listSourceDescription);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.metadata.jpeg.JPEGSegmentUtil.readSegments",
	"Comment": "reads the requested jpeg segments from the stream.the stream position must be directly before the soi marker, and only segments for the current image is read.",
	"Method": "List<JPEGSegment> readSegments(ImageInputStream stream,int marker,String identifier,List<JPEGSegment> readSegments,ImageInputStream stream,Map<Integer, List<String>> segmentIdentifiers){\r\n    readSOI(notNull(stream, \"stream\"));\r\n    List<JPEGSegment> segments = Collections.emptyList();\r\n    JPEGSegment segment;\r\n    try {\r\n        do {\r\n            segment = readSegment(stream, segmentIdentifiers);\r\n            if (isRequested(segment, segmentIdentifiers)) {\r\n                if (segments == Collections.EMPTY_LIST) {\r\n                    segments = new ArrayList();\r\n                }\r\n                segments.add(segment);\r\n            }\r\n        } while (!isImageDone(segment));\r\n    } catch (EOFException ignore) {\r\n    }\r\n    return segments;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.ResourceHelper.getLinkedFile",
	"Comment": "retrieves a a resource from the project, creates a link if createnew is true and the file is not present todo improve this, if the name is wrong",
	"Method": "IFile getLinkedFile(IContainer project,String name,boolean createNew,IFile getLinkedFile,IProject project,String name){\r\n    return getLinkedFile(project, name, true);\r\n}"
}, {
	"Path": "tlc2.util.SetOfLong.put",
	"Comment": "add k into the table. return true iff the table has alreadycontained k.",
	"Method": "boolean put(long k){\r\n    if (count >= thresh)\r\n        this.grow();\r\n    if (k == 0) {\r\n        if (this.hasZero)\r\n            return true;\r\n        this.hasZero = true;\r\n        this.count++;\r\n        return false;\r\n    } else {\r\n        int loc = ((int) k & 0x7FFFFFFF) % this.length;\r\n        while (true) {\r\n            long ent = this.table[loc];\r\n            if (ent == k)\r\n                return true;\r\n            if (ent == 0) {\r\n                table[loc] = k;\r\n                count++;\r\n                return false;\r\n            }\r\n            loc = (loc + 1) % this.length;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.TLCTrace.printPrefix",
	"Comment": "returns a sequence of states that reaches, but excludes the state with\tfingerprint fp.",
	"Method": "TLCStateInfo[] printPrefix(long fp){\r\n    this.raf.seek(0);\r\n    this.raf.readLongNat();\r\n    while (this.raf.readLong() != fp) {\r\n        this.raf.readLongNat();\r\n    }\r\n    TLCState lastState = null;\r\n    TLCStateInfo[] prefix = this.getTrace(this.lastPtr, false);\r\n    int idx = 0;\r\n    while (idx < prefix.length) {\r\n        StatePrinter.printState(prefix[idx], lastState, idx + 1);\r\n        lastState = prefix[idx].state;\r\n        idx++;\r\n    }\r\n    return prefix;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.TLAFastPartitioner.getFirstIndexStartingAfterOffset",
	"Comment": "returns the index of the first position which starts at or after the given offset.",
	"Method": "int getFirstIndexStartingAfterOffset(Position[] positions,int offset){\r\n    int i = -1, j = positions.length;\r\n    while (j - i > 1) {\r\n        int k = (i + j) >> 1;\r\n        Position p = positions[k];\r\n        if (p.getOffset() >= offset)\r\n            j = k;\r\n        else\r\n            i = k;\r\n    }\r\n    return j;\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.deleteFeedbackSessionsForCourseCascade",
	"Comment": "deletes the feedback sessions in the course specified. the deleteis cascaded, and feedback questions, feedback responses, andfeedback response comments in the course are deleted.",
	"Method": "void deleteFeedbackSessionsForCourseCascade(String courseId){\r\n    frcLogic.deleteFeedbackResponseCommentsForCourse(courseId);\r\n    frLogic.deleteFeedbackResponsesForCourse(courseId);\r\n    fqLogic.deleteFeedbackQuestionsForCourse(courseId);\r\n    deleteFeedbackSessionsForCourse(courseId);\r\n}"
}, {
	"Path": "teammates.ui.controller.StudentProfilePictureUploadAction.execute",
	"Comment": "this class is not tested in actiontests as it is difficult toreproduce the upload action done by google blobstore apiwithout the server running.this class is covered in uitests.",
	"Method": "ActionResult execute(){\r\n    gateKeeper.verifyLoggedInUserPrivileges();\r\n    String pictureKey = \"\";\r\n    BlobKey blobKey = new BlobKey(\"\");\r\n    RedirectResult r = createRedirectResult(Const.ActionURIs.STUDENT_PROFILE_PAGE);\r\n    try {\r\n        BlobInfo blobInfo = extractProfilePictureKey();\r\n        if (!isError) {\r\n            blobKey = blobInfo.getBlobKey();\r\n            pictureKey = renameFileToGoogleId(blobInfo);\r\n            logic.updateStudentProfilePicture(account.googleId, pictureKey);\r\n            statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_PROFILE_PICTURE_SAVED, StatusMessageColor.SUCCESS));\r\n            r.addResponseParam(Const.ParamsNames.STUDENT_PROFILE_PHOTOEDIT, \"true\");\r\n        }\r\n    } catch (BlobstoreFailureException | IOException bfe) {\r\n        deletePicture(blobKey);\r\n        updateStatusesForBlobstoreFailure();\r\n        isError = true;\r\n    } catch (Exception e) {\r\n        deletePicture(new BlobKey(pictureKey));\r\n        statusToUser.clear();\r\n        throw e;\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "tlc2.tool.DFIDModelChecker.doNext",
	"Comment": "compute the set of the next states.for each next state, checkif it is a valid state, if the invariants are satisfied, and ifit satisfies the constraints. it also adds the states that havenot been done in nextstates.return true if it finds a leafsuccessor of curstate.",
	"Method": "boolean doNext(TLCState curState,long cfp,boolean isLeaf,ObjLongTable<SemanticNode> counts,StateVec states,LongVec fps){\r\n    boolean deadLocked = true;\r\n    TLCState succState = null;\r\n    SetOfStates liveNextStates = null;\r\n    if (this.checkLiveness && isLeaf) {\r\n        liveNextStates = new SetOfStates(INITIAL_CAPACITY * threadLocal.get());\r\n    }\r\n    try {\r\n        int k = 0;\r\n        boolean allSuccDone = true;\r\n        boolean allSuccNonLeaf = true;\r\n        for (int i = 0; i < this.actions.length; i++) {\r\n            StateVec nextStates = this.tool.getNextStates(this.actions[i], curState);\r\n            int sz = nextStates.size();\r\n            this.numOfGenStates.getAndAdd(sz);\r\n            deadLocked = deadLocked && (sz == 0);\r\n            for (int j = 0; j < sz; j++) {\r\n                succState = nextStates.elementAt(j);\r\n                if (!this.tool.isGoodState(succState)) {\r\n                    synchronized (this) {\r\n                        if (this.setErrState(curState, succState, false)) {\r\n                            final Set<OpDeclNode> unassigned = succState.getUnassigned();\r\n                            String[] parameters;\r\n                            if (this.actions.length == 1) {\r\n                                parameters = new String[] { unassigned.size() > 1 ? \"s are\" : \" is\", unassigned.stream().map(n -> n.getName().toString()).collect(Collectors.joining(\", \")) };\r\n                            } else {\r\n                                parameters = new String[] { this.actions[i].getName().toString(), unassigned.size() > 1 ? \"s are\" : \" is\", unassigned.stream().map(n -> n.getName().toString()).collect(Collectors.joining(\", \")) };\r\n                            }\r\n                            this.printTrace(EC.TLC_STATE_NOT_COMPLETELY_SPECIFIED_NEXT, parameters, curState, succState);\r\n                        }\r\n                    }\r\n                    return allSuccNonLeaf;\r\n                }\r\n                if (TLCGlobals.isCoverageEnabled()) {\r\n                    ((TLCStateMutSource) succState).addCounts(counts);\r\n                }\r\n                boolean inModel = (this.tool.isInModel(succState) && this.tool.isInActions(curState, succState));\r\n                int status = FPIntSet.NEW;\r\n                if (inModel) {\r\n                    long fp = succState.fingerPrint();\r\n                    status = this.theFPSet.setStatus(fp, FPIntSet.NEW);\r\n                    allSuccDone = allSuccDone && FPIntSet.isDone(status);\r\n                    allSuccNonLeaf = allSuccNonLeaf && !FPIntSet.isLeaf(status);\r\n                    this.allStateWriter.writeState(curState, succState, status == FPIntSet.NEW);\r\n                    if (!FPIntSet.isCompleted(status)) {\r\n                        states.addElement(succState);\r\n                        fps.addElement(fp);\r\n                    }\r\n                    if (this.checkLiveness && isLeaf) {\r\n                        liveNextStates.put(fp, succState);\r\n                    }\r\n                }\r\n                if (status == FPIntSet.NEW) {\r\n                    try {\r\n                        int len = this.invariants.length;\r\n                        for (k = 0; k < len; k++) {\r\n                            if (!tool.isValid(this.invariants[k], succState)) {\r\n                                synchronized (this) {\r\n                                    if (TLCGlobals.continuation) {\r\n                                        this.printTrace(EC.TLC_INVARIANT_VIOLATED_BEHAVIOR, new String[] { this.tool.getInvNames()[k] }, curState, succState);\r\n                                        break;\r\n                                    } else {\r\n                                        if (this.setErrState(curState, succState, false)) {\r\n                                            this.printTrace(EC.TLC_INVARIANT_VIOLATED_BEHAVIOR, new String[] { this.tool.getInvNames()[k] }, curState, succState);\r\n                                            this.notify();\r\n                                        }\r\n                                        return allSuccNonLeaf;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        if (k < len)\r\n                            continue;\r\n                    } catch (Exception e) {\r\n                        synchronized (this) {\r\n                            if (this.setErrState(curState, succState, true)) {\r\n                                this.printTrace(EC.TLC_INVARIANT_EVALUATION_FAILED, new String[] { this.tool.getInvNames()[k] }, curState, succState);\r\n                                this.notify();\r\n                            }\r\n                            return allSuccNonLeaf;\r\n                        }\r\n                    }\r\n                }\r\n                try {\r\n                    int len = this.impliedActions.length;\r\n                    for (k = 0; k < len; k++) {\r\n                        if (!tool.isValid(this.impliedActions[k], curState, succState)) {\r\n                            synchronized (this) {\r\n                                if (TLCGlobals.continuation) {\r\n                                    this.printTrace(EC.TLC_ACTION_PROPERTY_VIOLATED_BEHAVIOR, new String[] { this.tool.getImpliedActNames()[k] }, curState, succState);\r\n                                    break;\r\n                                } else {\r\n                                    if (this.setErrState(curState, succState, false)) {\r\n                                        this.printTrace(EC.TLC_ACTION_PROPERTY_VIOLATED_BEHAVIOR, new String[] { this.tool.getImpliedActNames()[k] }, curState, succState);\r\n                                        this.notify();\r\n                                    }\r\n                                    return allSuccNonLeaf;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (k < len)\r\n                        continue;\r\n                } catch (Exception e) {\r\n                    synchronized (this) {\r\n                        if (this.setErrState(curState, succState, true)) {\r\n                            this.printTrace(EC.TLC_ACTION_PROPERTY_EVALUATION_FAILED, new String[] { this.tool.getImpliedActNames()[k] }, curState, succState);\r\n                            this.notify();\r\n                        }\r\n                    }\r\n                    return allSuccNonLeaf;\r\n                }\r\n            }\r\n            succState = null;\r\n        }\r\n        if (deadLocked && this.checkDeadlock) {\r\n            synchronized (this) {\r\n                if (this.setErrState(curState, null, false)) {\r\n                    this.printTrace(EC.TLC_DEADLOCK_REACHED, null, curState, null);\r\n                    this.notify();\r\n                }\r\n            }\r\n            return allSuccNonLeaf;\r\n        }\r\n        if (this.checkLiveness && isLeaf) {\r\n            final long curStateFP = curState.fingerPrint();\r\n            liveNextStates.put(curStateFP, curState);\r\n            this.allStateWriter.writeState(curState, curState, true, IStateWriter.Visualization.STUTTERING);\r\n            liveCheck.addNextState(curState, curStateFP, liveNextStates);\r\n            final int multiplier = threadLocal.get();\r\n            if (liveNextStates.capacity() > (multiplier * INITIAL_CAPACITY)) {\r\n                threadLocal.set(multiplier + 1);\r\n            }\r\n        }\r\n        if (allSuccDone || (isLeaf && allSuccNonLeaf)) {\r\n            this.theFPSet.setStatus(cfp, FPIntSet.DONE);\r\n        }\r\n        return allSuccNonLeaf;\r\n    } catch (Throwable e) {\r\n        boolean keep = ((e instanceof StackOverflowError) || (e instanceof OutOfMemoryError));\r\n        synchronized (this) {\r\n            if (this.setErrState(curState, succState, !keep)) {\r\n                String[] parameters = null;\r\n                int errorCode;\r\n                if (e instanceof StackOverflowError) {\r\n                    errorCode = EC.SYSTEM_STACK_OVERFLOW;\r\n                } else if (e instanceof OutOfMemoryError) {\r\n                    errorCode = EC.SYSTEM_OUT_OF_MEMORY;\r\n                } else {\r\n                    errorCode = EC.GENERAL;\r\n                    parameters = new String[] { MP.ECGeneralMsg(\"computing the set of next states\", e) };\r\n                }\r\n                this.printTrace(errorCode, parameters, curState, succState);\r\n                this.notifyAll();\r\n            }\r\n        }\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "tla2sany.semantic.ThmOrAssumpDefNode.getProof",
	"Comment": "return the proof of the theorem, which is null unless this is a theorem and it has a proof.",
	"Method": "ProofNode getProof(){\r\n    return this.proof;\r\n}"
}, {
	"Path": "org.squirrelframework.foundation.util.Base64Coder.encodeString",
	"Comment": "encodes a string into base64 format. no blanks or line breaks areinserted.",
	"Method": "String encodeString(String s){\r\n    return new String(encode(s.getBytes()));\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.getSortedListOfInstructorEmails",
	"Comment": "returns a list of instructor emails, sorted alphabetically.",
	"Method": "List<String> getSortedListOfInstructorEmails(){\r\n    List<String> emailList = new ArrayList();\r\n    List<InstructorAttributes> instructors = roster.getInstructors();\r\n    for (InstructorAttributes instructor : instructors) {\r\n        emailList.add(instructor.email);\r\n    }\r\n    emailList.sort(null);\r\n    return emailList;\r\n}"
}, {
	"Path": "org.springframework.roo.file.monitor.event.FileEvent.getPreviousName",
	"Comment": "if supported by the implementation, indicates the old name of theresource. implementations are not required to support renamenotifications.",
	"Method": "File getPreviousName(){\r\n    return previousName;\r\n}"
}, {
	"Path": "teammates.test.driver.BackDoor.restoreDataBundle",
	"Comment": "persists given data into the datastore.if given entities already exist in the data store, they will be overwritten.",
	"Method": "String restoreDataBundle(DataBundle dataBundle){\r\n    removeAdminEmailsFromDataBundle(dataBundle);\r\n    String dataBundleJson = JsonUtils.toJson(dataBundle);\r\n    Map<String, String> params = createParamMap(BackDoorOperation.OPERATION_PERSIST_DATABUNDLE);\r\n    params.put(BackDoorOperation.PARAMETER_DATABUNDLE_JSON, dataBundleJson);\r\n    return makePostRequest(params);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.util.FormHelper.createFormsSourceViewer",
	"Comment": "creates a source viewer with given parent, toolkit and flags adopted to a form",
	"Method": "SourceViewer createFormsSourceViewer(FormToolkit toolkit,Composite parent,int flags,SourceViewer createFormsSourceViewer,FormToolkit toolkit,Composite parent,int flags,SourceViewerConfiguration config){\r\n    SourceViewer sourceViewer = createSourceViewer(parent, flags, config);\r\n    sourceViewer.setData(FormToolkit.KEY_DRAW_BORDER, FormToolkit.TREE_BORDER);\r\n    sourceViewer.getTextWidget().setData(FormToolkit.KEY_DRAW_BORDER, FormToolkit.TREE_BORDER);\r\n    toolkit.adapt(sourceViewer.getTextWidget(), true, true);\r\n    return sourceViewer;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.webflow.WebFlowOperationsImpl.copyDirectoryContents",
	"Comment": "this method will copy the contents of a directory to another if theresource does not already exist in the target directory. also, it makes replacements of strings which could exist with the provided map.",
	"Method": "void copyDirectoryContents(String sourceAntPath,String targetDirectory,Map<String, String> replacements,JavaType modelObject){\r\n    Validate.notBlank(sourceAntPath, \"Source path required\");\r\n    Validate.notBlank(targetDirectory, \"Target directory required\");\r\n    if (!targetDirectory.endsWith(\"/\")) {\r\n        targetDirectory += \"/\";\r\n    }\r\n    if (!fileManager.exists(targetDirectory)) {\r\n        fileManager.createDirectory(targetDirectory);\r\n    }\r\n    boolean doReplacements = false;\r\n    if (!replacements.isEmpty()) {\r\n        doReplacements = true;\r\n    }\r\n    final String path = FileUtils.getPath(getClass(), sourceAntPath);\r\n    final Iterable<URL> urls = OSGiUtils.findEntriesByPattern(context, path);\r\n    Validate.notNull(urls, \"Could not search bundles for resources for Ant Path '%s'\", path);\r\n    for (final URL url : urls) {\r\n        final String fileName = url.getPath().substring(url.getPath().lastIndexOf(\"/\") + 1);\r\n        try {\r\n            String contents = IOUtils.toString(url);\r\n            if (modelObject != null && contents.contains(\"data-th-action=\\\"${flowExecutionUrl}\\\"\")) {\r\n                contents = StringUtils.replace(contents, \"data-th-action=\\\"${flowExecutionUrl}\\\"\", String.format(\"data-th-action=\\\"${flowExecutionUrl}\\\" data-th-object=\\\"${%s}\\\"\", StringUtils.uncapitalize(modelObject.getSimpleTypeName())));\r\n            }\r\n            if (doReplacements) {\r\n                for (Entry<String, String> entry : replacements.entrySet()) {\r\n                    contents = contents.replace(entry.getKey(), entry.getValue());\r\n                }\r\n            }\r\n            fileManager.createOrUpdateTextFileIfRequired(targetDirectory + fileName, contents, false);\r\n        } catch (final Exception e) {\r\n            throw new IllegalStateException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackEditPage.selectRecipientsToBeGiverTeamMembersAndGiverAndWaitForVisibilityMessageToLoad",
	"Comment": "selects the recipients in the feedback path to be the team members and giver and waits for the correspondingvisibility message to load.",
	"Method": "void selectRecipientsToBeGiverTeamMembersAndGiverAndWaitForVisibilityMessageToLoad(){\r\n    selectDropdownByVisibleValueAndHandleAjaxRequests(recipientDropdownForNewQuestion, \"Giver's team members and Giver\");\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.XmlElementBuilder.setText",
	"Comment": "add text contents to the current element. this will overwrite anyprevious text content.",
	"Method": "XmlElementBuilder setText(String text){\r\n    Validate.notBlank(text, \"Text content required\");\r\n    element.setTextContent(text);\r\n    return this;\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.video.OutputSurface.release",
	"Comment": "discard all resources held by this class, notably the egl context.",
	"Method": "void release(){\r\n    if (mEGL != null) {\r\n        if (mEGL.eglGetCurrentContext().equals(mEGLContext)) {\r\n            mEGL.eglMakeCurrent(mEGLDisplay, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT);\r\n        }\r\n        mEGL.eglDestroySurface(mEGLDisplay, mEGLSurface);\r\n        mEGL.eglDestroyContext(mEGLDisplay, mEGLContext);\r\n    }\r\n    mSurface.release();\r\n    mEGLDisplay = null;\r\n    mEGLContext = null;\r\n    mEGLSurface = null;\r\n    mEGL = null;\r\n    mTextureRender = null;\r\n    mSurface = null;\r\n    mSurfaceTexture = null;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorCourseStudentDetailsEditPage.submitUnsuccessfully",
	"Comment": "if the parameter value is not null, the value will be filled into therelevent input field.",
	"Method": "InstructorCourseStudentDetailsEditPage submitUnsuccessfully(String studentName,String teamName,String studentEmail,String comments){\r\n    fillStudentDetailsForm(studentName, teamName, studentEmail, comments);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.roo.project.Execution.getPhase",
	"Comment": "returns the maven lifecycle phase to which this execution is bound",
	"Method": "String getPhase(){\r\n    return phase;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.DecomposeProofHandler.cloneMappingPairVector",
	"Comment": "returns a vector the same length as vec whose elements are clones of theelements of vec.",
	"Method": "Vector<MappingPair> cloneMappingPairVector(Vector<MappingPair> vec){\r\n    Vector<MappingPair> result = new Vector<DecomposeProofHandler.MappingPair>();\r\n    for (int i = 0; i < vec.size(); i++) {\r\n        result.add(vec.elementAt(i).clone());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.AbstractMemberHoldingTypeDetailsBuilder.setDeclaredInitializers",
	"Comment": "sets the builders for the initializers of the type being built",
	"Method": "void setDeclaredInitializers(Collection<? extends InitializerMetadataBuilder> declaredInitializers){\r\n    this.declaredInitializers.clear();\r\n    if (declaredInitializers != null) {\r\n        this.declaredInitializers.addAll(declaredInitializers);\r\n    }\r\n}"
}, {
	"Path": "tla2sany.semantic.Generator.processRcdForms",
	"Comment": "this method processes both the recordconstructor construct and thesetofrecords operator.the two are essentially identical except for which builtin operator is used.",
	"Method": "ExprNode processRcdForms(UniqueString operator,TreeNode treeNode,TreeNode children,ModuleNode cm){\r\n    int length = (children.length - 1) / 2;\r\n    ExprNode[] fieldPairs = new ExprNode[length];\r\n    UniqueString[] labels = new UniqueString[length];\r\n    for (int lvi = 0; lvi < length; lvi++) {\r\n        TreeNode[] syntaxTreeNode = children[2 * lvi + 1].heirs();\r\n        ExprNode[] sops = new ExprNode[2];\r\n        sops[0] = new StringNode(syntaxTreeNode[0], false);\r\n        labels[lvi] = ((StringNode) sops[0]).getRep();\r\n        for (int cmpIndex = 0; cmpIndex < lvi; cmpIndex++) {\r\n            if (labels[lvi].compareTo(labels[cmpIndex]) == 0) {\r\n                errors.addError(syntaxTreeNode[0].getLocation(), \"Non-unique fields in constructor.\");\r\n            }\r\n        }\r\n        sops[1] = generateExpression(syntaxTreeNode[2], cm);\r\n        fieldPairs[lvi] = new OpApplNode(OP_pair, sops, children[2 * lvi + 1], cm);\r\n    }\r\n    return new OpApplNode(operator, fieldPairs, treeNode, cm);\r\n}"
}, {
	"Path": "tlc2.tool.liveness.LNEven.equals",
	"Comment": "this method returns true or false for whether two liveexprnodes are\tsyntactically equal.",
	"Method": "boolean equals(LiveExprNode exp){\r\n    if (exp instanceof LNEven) {\r\n        return getBody().equals(((LNEven) exp).getBody());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.roo.support.osgi.OSGiUtils.findEntriesByPath",
	"Comment": "searches the bundles in the given context for entries with the givenpath.",
	"Method": "Collection<URL> findEntriesByPath(BundleContext context,String path){\r\n    Validate.notBlank(path, \"Path to locate is required\");\r\n    final Collection<URL> urls = new ArrayList<URL>();\r\n    final Collection<URI> uris = new ArrayList<URI>();\r\n    OSGiUtils.execute(new BundleCallback() {\r\n        public void execute(final Bundle bundle) {\r\n            try {\r\n                final URL url = bundle.getEntry(path);\r\n                if (url != null) {\r\n                    final URI uri = url.toURI();\r\n                    if (!uris.contains(uri)) {\r\n                        urls.add(url);\r\n                        uris.add(uri);\r\n                    }\r\n                }\r\n            } catch (final IllegalStateException e) {\r\n            } catch (final URISyntaxException e) {\r\n            }\r\n        }\r\n    }, context);\r\n    return urls;\r\n}"
}, {
	"Path": "org.springframework.roo.support.osgi.OSGiUtils.findEntriesByPath",
	"Comment": "searches the bundles in the given context for entries with the givenpath.",
	"Method": "Collection<URL> findEntriesByPath(BundleContext context,String path){\r\n    try {\r\n        final URL url = bundle.getEntry(path);\r\n        if (url != null) {\r\n            final URI uri = url.toURI();\r\n            if (!uris.contains(uri)) {\r\n                urls.add(url);\r\n                uris.add(uri);\r\n            }\r\n        }\r\n    } catch (final IllegalStateException e) {\r\n    } catch (final URISyntaxException e) {\r\n    }\r\n}"
}, {
	"Path": "tlc2.util.IdThread.GetId",
	"Comment": "if the calling thread is of type idthread,return its id. otherwise, return otherid.",
	"Method": "int GetId(int GetId,int otherId){\r\n    Thread th = Thread.currentThread();\r\n    return (th instanceof IdThread) ? ((IdThread) th).id : otherId;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.MemberFindingUtils.getMethod",
	"Comment": "searches up the inheritance hierarchy until the first method with thespecified name and parameters is located.",
	"Method": "MethodMetadata getMethod(MemberDetails memberDetails,JavaSymbolName methodName,MethodMetadata getMethod,MemberDetails memberDetails,JavaSymbolName methodName,List<JavaType> parameters,MethodMetadata getMethod,MemberDetails memberDetails,JavaSymbolName methodName,List<JavaType> parameters,String excludingMid,MethodMetadata getMethod,MemberDetails memberDetails,String methodName,MethodMetadata getMethod,MemberHoldingTypeDetails memberHoldingTypeDetails,JavaSymbolName methodName,MethodMetadata getMethod,MemberHoldingTypeDetails memberHoldingTypeDetails,JavaSymbolName methodName,List<JavaType> parameters,MethodMetadata getMethod,MemberHoldingTypeDetails memberHoldingTypeDetails,String methodName){\r\n    return memberHoldingTypeDetails.getMethod(new JavaSymbolName(methodName));\r\n}"
}, {
	"Path": "com.twelvemonkeys.io.SubStream.findMaxLen",
	"Comment": "finds the maximum number of bytes we can read or skip, from this stream.",
	"Method": "long findMaxLen(long pLength){\r\n    if (bytesLeft < pLength) {\r\n        return (int) Math.max(bytesLeft, 0);\r\n    } else {\r\n        return pLength;\r\n    }\r\n}"
}, {
	"Path": "util.ToolIO.reset",
	"Comment": "resets the toolio and deletes the messages the mode and user directory are not changed",
	"Method": "void reset(){\r\n    messages = new String[InitialMaxLength];\r\n    length = 0;\r\n    nextMessage = \"\";\r\n}"
}, {
	"Path": "teammates.common.util.FieldValidator.isValidEmailAddress",
	"Comment": "checks whether a given text input represents a format of a valid email address.",
	"Method": "boolean isValidEmailAddress(String email){\r\n    return StringHelper.isMatching(email, REGEX_EMAIL);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.setDistanceFromTop",
	"Comment": "sets how far away from the top of the screen the button should be displayed.distance should be the value in px",
	"Method": "void setDistanceFromTop(int distance){\r\n    this.distanceFromTop = distance;\r\n}"
}, {
	"Path": "teammates.common.util.Version.compareTo",
	"Comment": "compares versions by major, minor then by patch.the version with greater major, minor or patch will be smaller.",
	"Method": "int compareTo(Version anotherVersion){\r\n    int majorComparisonResult = compareVersionString(this.major, anotherVersion.major);\r\n    if (majorComparisonResult != 0) {\r\n        return majorComparisonResult;\r\n    }\r\n    int minorComparisonResult = compareVersionString(this.minor, anotherVersion.minor);\r\n    if (minorComparisonResult != 0) {\r\n        return minorComparisonResult;\r\n    }\r\n    int patchComparisonResult = compareVersionString(this.patch, anotherVersion.patch);\r\n    if (patchComparisonResult != 0) {\r\n        return patchComparisonResult;\r\n    }\r\n    return Boolean.compare(anotherVersion.isRcVersion, isRcVersion);\r\n}"
}, {
	"Path": "com.twelvemonkeys.io.FileUtil.getDirectoryname",
	"Comment": "extracts the directory path without the filename, from a completefilename path.",
	"Method": "String getDirectoryname(String pPath,String getDirectoryname,String pPath,char pSeparator){\r\n    int index = pPath.lastIndexOf(pSeparator);\r\n    if (index < 0) {\r\n        return \"\";\r\n    }\r\n    return pPath.substring(0, index);\r\n}"
}, {
	"Path": "tlc2.tool.Tool.isInModel",
	"Comment": "this method determines if a state satisfies the model constraints.",
	"Method": "boolean isInModel(TLCState state){\r\n    ExprNode[] constrs = this.getModelConstraints();\r\n    for (int i = 0; i < constrs.length; i++) {\r\n        Value bval = this.eval(constrs[i], Context.Empty, state);\r\n        if (!(bval instanceof BoolValue)) {\r\n            Assert.fail(EC.TLC_EXPECTED_VALUE, new String[] { \"boolean\", constrs[i].toString() });\r\n        }\r\n        if (!((BoolValue) bval).val)\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.WsEndpointsMetadata.getBusField",
	"Comment": "this method obtains the bus field that will be used in some different methods",
	"Method": "FieldMetadata getBusField(){\r\n    if (this.busField != null) {\r\n        return this.busField;\r\n    }\r\n    FieldMetadataBuilder bus = new FieldMetadataBuilder(getId(), Modifier.PRIVATE, new JavaSymbolName(\"bus\"), new JavaType(\"org.apache.cxf.Bus\"), null);\r\n    bus.addAnnotation(new AnnotationMetadataBuilder(SpringJavaType.AUTOWIRED));\r\n    busField = bus.build();\r\n    return busField;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.waitForElementsToDisappear",
	"Comment": "waits for a list of elements to be invisible or not present, or timeout.",
	"Method": "void waitForElementsToDisappear(List<WebElement> elements){\r\n    waitFor(ExpectedConditions.invisibilityOfAllElements(elements));\r\n}"
}, {
	"Path": "com.twelvemonkeys.image.ImageUtil.blend",
	"Comment": "blends two argb values half and half, to create a tone in between.",
	"Method": "int blend(int pRGB1,int pRGB2,Color blend,Color pColor,Color pOther,Color blend,Color pColor,Color pOther,float pBlendFactor){\r\n    float inverseBlend = (1f - pBlendFactor);\r\n    return new Color(clamp((pColor.getRed() * inverseBlend) + (pOther.getRed() * pBlendFactor)), clamp((pColor.getGreen() * inverseBlend) + (pOther.getGreen() * pBlendFactor)), clamp((pColor.getBlue() * inverseBlend) + (pOther.getBlue() * pBlendFactor)), clamp((pColor.getAlpha() * inverseBlend) + (pOther.getAlpha() * pBlendFactor)));\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.model.Model.getTEFile",
	"Comment": "retrieves the te file that is being used by the trace explorer.",
	"Method": "IFile getTEFile(){\r\n    return getFile(ModelHelper.TE_FILE_TLA);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.getPossibleRecipients",
	"Comment": "get the possible recipients for a student giver for the question specified.",
	"Method": "List<String> getPossibleRecipients(FeedbackQuestionAttributes fqa,List<String> getPossibleRecipients,FeedbackQuestionAttributes fqa,String giverParticipantIdentifier,List<String> getPossibleRecipients,FeedbackQuestionAttributes fqa,InstructorAttributes instructorGiver,List<String> getPossibleRecipients,FeedbackQuestionAttributes fqa,StudentAttributes studentGiver){\r\n    FeedbackParticipantType recipientType = fqa.recipientType;\r\n    List<String> possibleRecipients = new ArrayList();\r\n    switch(recipientType) {\r\n        case STUDENTS:\r\n            possibleRecipients = getSortedListOfStudentEmails();\r\n            possibleRecipients.remove(studentGiver.email);\r\n            break;\r\n        case OWN_TEAM_MEMBERS:\r\n            possibleRecipients = getSortedListOfTeamMembersEmailsExcludingSelf(studentGiver);\r\n            break;\r\n        case OWN_TEAM_MEMBERS_INCLUDING_SELF:\r\n            possibleRecipients = getSortedListOfTeamMembersEmails(studentGiver);\r\n            break;\r\n        case INSTRUCTORS:\r\n            possibleRecipients = getSortedListOfInstructorEmails();\r\n            break;\r\n        case TEAMS:\r\n            possibleRecipients = getSortedListOfTeamsExcludingOwnTeam(studentGiver);\r\n            break;\r\n        case OWN_TEAM:\r\n            possibleRecipients.add(studentGiver.team);\r\n            break;\r\n        case SELF:\r\n            possibleRecipients.add(studentGiver.email);\r\n            break;\r\n        case NONE:\r\n            possibleRecipients.add(Const.GENERAL_QUESTION);\r\n            break;\r\n        default:\r\n            log.severe(\"Invalid recipient type specified\");\r\n            break;\r\n    }\r\n    return possibleRecipients;\r\n}"
}, {
	"Path": "tlc2.tool.fp.LongArray.get",
	"Comment": "returns the element at the specified position in this array.",
	"Method": "long get(long position){\r\n    rangeCheck(position);\r\n    return this.unsafe.getAddress(log2phy(position));\r\n}"
}, {
	"Path": "teammates.ui.template.FeedbackResponseCommentRow.getTypeOfPeopleCanViewComment",
	"Comment": "returns the type of people that can view the response comment.",
	"Method": "String getTypeOfPeopleCanViewComment(FeedbackResponseCommentAttributes comment,FeedbackQuestionAttributes relatedQuestion){\r\n    List<FeedbackParticipantType> showCommentTo;\r\n    if (comment.isVisibilityFollowingFeedbackQuestion) {\r\n        showCommentTo = relatedQuestion.showResponsesTo;\r\n    } else {\r\n        showCommentTo = comment.showCommentTo;\r\n    }\r\n    if (showCommentTo == null || showCommentTo.isEmpty()) {\r\n        return \"nobody\";\r\n    }\r\n    StringBuilder peopleCanView = new StringBuilder(100);\r\n    for (int i = 0; i < showCommentTo.size(); i++) {\r\n        FeedbackParticipantType commentViewer = showCommentTo.get(i);\r\n        if (i == showCommentTo.size() - 1 && showCommentTo.size() > 1) {\r\n            peopleCanView.append(\"and \");\r\n        }\r\n        switch(commentViewer) {\r\n            case GIVER:\r\n                peopleCanView.append(\"response giver, \");\r\n                break;\r\n            case RECEIVER:\r\n                peopleCanView.append(\"response recipient, \");\r\n                break;\r\n            case OWN_TEAM_MEMBERS:\r\n                peopleCanView.append(\"response giver's team members, \");\r\n                break;\r\n            case RECEIVER_TEAM_MEMBERS:\r\n                peopleCanView.append(\"response recipient's team, \");\r\n                break;\r\n            case STUDENTS:\r\n                peopleCanView.append(\"other students in this course, \");\r\n                break;\r\n            case INSTRUCTORS:\r\n                peopleCanView.append(\"instructors, \");\r\n                break;\r\n            case OWN_TEAM_MEMBERS_INCLUDING_SELF:\r\n                peopleCanView.append(\"response giver's team members and response giver, \");\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    String peopleCanViewString = peopleCanView.toString();\r\n    return removeEndComma(peopleCanViewString);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.TLAEditorAndPDFViewer.setDescription",
	"Comment": "sets the text that appears above the text viewer.currently, this is the full file path.",
	"Method": "void setDescription(){\r\n    IEditorInput input = getEditorInput();\r\n    if (input != null) {\r\n        if (input instanceof FileEditorInput) {\r\n            FileEditorInput fin = (FileEditorInput) input;\r\n            setContentDescription(fin.getPath().toOSString());\r\n        } else {\r\n            setContentDescription(input.getName());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.InstructorPrivileges.isSessionInSectionSpecial",
	"Comment": "returns true if there are special settings for sessionname in sectionname.",
	"Method": "boolean isSessionInSectionSpecial(String sectionName,String sessionName){\r\n    return this.sessionLevel.containsKey(sectionName) && this.sessionLevel.get(sectionName).containsKey(sessionName);\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackSessionsDb.addInstructorRespondents",
	"Comment": "the objectify library does not support throwing checked exceptions inside transactions",
	"Method": "void addInstructorRespondents(List<String> emails,FeedbackSessionAttributes feedbackSession){\r\n    Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, emails);\r\n    Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSession);\r\n    feedbackSession.sanitizeForSaving();\r\n    if (!feedbackSession.isValid()) {\r\n        throw new InvalidParametersException(feedbackSession.getInvalidityInfo());\r\n    }\r\n    try {\r\n        ofy().transact(new VoidWork() {\r\n            @Override\r\n            public void vrun() {\r\n                FeedbackSession fs = getEntity(feedbackSession);\r\n                if (fs == null) {\r\n                    throw new RuntimeException(new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString()));\r\n                }\r\n                fs.getRespondingInstructorList().addAll(emails);\r\n                saveEntity(fs, feedbackSession);\r\n            }\r\n        });\r\n    } catch (RuntimeException e) {\r\n        if (e.getCause() instanceof EntityDoesNotExistException) {\r\n            throw (EntityDoesNotExistException) e.getCause();\r\n        }\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackSessionsDb.addInstructorRespondents",
	"Comment": "the objectify library does not support throwing checked exceptions inside transactions",
	"Method": "void addInstructorRespondents(List<String> emails,FeedbackSessionAttributes feedbackSession){\r\n    FeedbackSession fs = getEntity(feedbackSession);\r\n    if (fs == null) {\r\n        throw new RuntimeException(new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString()));\r\n    }\r\n    fs.getRespondingInstructorList().addAll(emails);\r\n    saveEntity(fs, feedbackSession);\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.StringUtil.replace",
	"Comment": "replaces a substring of a string with another string. all matches arereplaced.",
	"Method": "String replace(String pSource,String pPattern,String pReplace){\r\n    if (pPattern.length() == 0) {\r\n        return pSource;\r\n    }\r\n    int match;\r\n    int offset = 0;\r\n    StringBuilder result = new StringBuilder();\r\n    while ((match = pSource.indexOf(pPattern, offset)) != -1) {\r\n        result.append(pSource.substring(offset, match));\r\n        result.append(pReplace);\r\n        offset = match + pPattern.length();\r\n    }\r\n    result.append(pSource.substring(offset));\r\n    return result.toString();\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackEditPage.selectRecipientsToBeInstructorsAndWaitForVisibilityMessageToLoad",
	"Comment": "selects the recipients in the feedback path to be instructors in the course and waits for the correspondingvisibility message to load.",
	"Method": "void selectRecipientsToBeInstructorsAndWaitForVisibilityMessageToLoad(){\r\n    selectDropdownByVisibleValueAndHandleAjaxRequests(recipientDropdownForNewQuestion, \"Instructors in the course\");\r\n}"
}, {
	"Path": "teammates.common.datatransfer.InstructorPrivileges.isSessionsInSectionSpecial",
	"Comment": "returns true if there are special settings for sectionname.",
	"Method": "boolean isSessionsInSectionSpecial(String sectionName){\r\n    return this.sessionLevel.containsKey(sectionName);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.SearchUtils.correctActivity",
	"Comment": "returns true if it is one of the activities that always needs to translate the search view down.",
	"Method": "boolean correctActivity(){\r\n    return activity instanceof SearchPager;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.StudentProfilePage.selectNationality",
	"Comment": "selects student nationality from the dropdown list if the nationality isvalid, otherwise it fails with a message.",
	"Method": "void selectNationality(String studentNationality){\r\n    if (NationalityHelper.getNationalities().contains(studentNationality) || \"\".equals(studentNationality)) {\r\n        Select dropdown = new Select(studentNationalityDropdown);\r\n        dropdown.selectByValue(studentNationality);\r\n    } else {\r\n        fail(\"Given nationality \" + studentNationality + \" is not valid!\");\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.GotoMatchingParenHandler.execute",
	"Comment": "the method called when the user executes the goto matching paren command.",
	"Method": "Object execute(ExecutionEvent event){\r\n    TLAEditor tlaEditor = EditorUtil.getTLAEditorWithFocus();\r\n    document = tlaEditor.publicGetSourceViewer().getDocument();\r\n    try {\r\n        ITextSelection selection = (ITextSelection) tlaEditor.getSelectionProvider().getSelection();\r\n        Region selectedRegion = new Region(selection.getOffset(), selection.getLength());\r\n        int selectedParenIdx = getSelectedParen(selectedRegion);\r\n        int lineNumber = selection.getStartLine();\r\n        if (lineNumber < 0) {\r\n            throw new ParenErrorException(\"Toolbox bug: bad selected line computed\", null, null);\r\n        }\r\n        setLineRegions(lineNumber);\r\n        setRegionInfo();\r\n        if (selectedParenIdx < PCOUNT) {\r\n            findMatchingRightParen(selectedParenIdx);\r\n        } else {\r\n            findMatchingLeftParen(selectedParenIdx);\r\n        }\r\n        tlaEditor.selectAndReveal(currLoc, 0);\r\n    } catch (ParenErrorException e) {\r\n        IResource resource = ResourceHelper.getResourceByModuleName(tlaEditor.getModuleName());\r\n        ErrorMessageEraser listener = new ErrorMessageEraser(tlaEditor, resource);\r\n        tlaEditor.getViewer().getTextWidget().addCaretListener(listener);\r\n        tlaEditor.getEditorSite().getActionBars().getStatusLineManager().setErrorMessage(e.message);\r\n        Region[] regions = e.regions;\r\n        if (regions[0] != null) {\r\n            try {\r\n                Spec spec = ToolboxHandle.getCurrentSpec();\r\n                spec.setMarkersToShow(null);\r\n                IMarker[] markersToShow = new IMarker[2];\r\n                for (int i = 0; i < 2; i++) {\r\n                    IMarker marker = resource.createMarker(PAREN_ERROR_MARKER_TYPE);\r\n                    Map<String, Integer> markerAttributes = new HashMap<String, Integer>(2);\r\n                    markerAttributes.put(IMarker.CHAR_START, new Integer(regions[i].getOffset()));\r\n                    markerAttributes.put(IMarker.CHAR_END, new Integer(regions[i].getOffset() + regions[i].getLength()));\r\n                    marker.setAttributes(markerAttributes);\r\n                    markersToShow[i] = marker;\r\n                }\r\n                spec.setMarkersToShow(markersToShow);\r\n            } catch (CoreException exc) {\r\n                System.out.println(\"GotoMatchingParenHandler.execute threw CoreException\");\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "tla2sany.semantic.Generator.generateLambda",
	"Comment": "added by ll on 27 march 2007. a lambda expression is represented as an opdefnode.since it isalways used only as an operator argument, this opdefnode will appearin an opargnode.",
	"Method": "OpDefNode generateLambda(TreeNode syntaxTreeNode,ModuleNode cm){\r\n    TreeNode[] children = syntaxTreeNode.heirs();\r\n    int arity = (children.length - 2) / 2;\r\n    Context ctxt = new Context(moduleTable, errors);\r\n    symbolTable.pushContext(ctxt);\r\n    FormalParamNode[] params = new FormalParamNode[arity];\r\n    int argPos = 1;\r\n    for (int i = 0; i < arity; i++) {\r\n        params[i] = new // parameters of a lambda expression\r\n        FormalParamNode(children[argPos].getUS(), 0, children[argPos], symbolTable, cm);\r\n        argPos = argPos + 2;\r\n    }\r\n    pushFormalParams(params);\r\n    ExprNode body = generateExpression(children[children.length - 1], cm);\r\n    popFormalParams();\r\n    symbolTable.popContext();\r\n    return new OpDefNode(S_lambda, UserDefinedOpKind, params, false, body, cm, null, syntaxTreeNode, true, null);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.getSortedListOfTeamMembersEmailsExcludingSelf",
	"Comment": "get a sorted list of team members, who are in the same team as the student,excluding the student.",
	"Method": "List<String> getSortedListOfTeamMembersEmailsExcludingSelf(StudentAttributes student){\r\n    List<String> teamMembers = getSortedListOfTeamMembersEmails(student);\r\n    String currentStudentEmail = student.email;\r\n    teamMembers.remove(currentStudentEmail);\r\n    return teamMembers;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.traceexplorer.TraceExplorerComposite.doExplore",
	"Comment": "runs the trace explorer with the expressionsthat are in the table.",
	"Method": "void doExplore(){\r\n    String rootModuleFileName = ToolboxHandle.getRootModule().getName();\r\n    if (ModelHelper.containsTraceExplorerModuleConflict(rootModuleFileName)) {\r\n        MessageDialog.openError(view.getSite().getShell(), \"Illegal module name\", \"Trace exploration is not allowed for a spec that contains a module named \" + ModelHelper.TE_MODEL_NAME + \".\");\r\n        return;\r\n    }\r\n    final ModelEditor modelEditor = view.getModel().getAdapter(ModelEditor.class);\r\n    if (modelEditor == null) {\r\n        MessageDialog.openError(view.getSite().getShell(), \"Trace exploration not allowed\", \"There is no model editor open on this model. The trace explorer cannot be run without opening the model editor on this model.\");\r\n        return;\r\n    } else if (!modelEditor.isComplete()) {\r\n        MessageDialog.openError(view.getSite().getShell(), \"Trace exploration not allowed\", \"The model contains errors, which should be corrected before running the trace explorer.\");\r\n        return;\r\n    }\r\n    modelEditor.doSaveWithoutValidating((new NullProgressMonitor()));\r\n    if (!view.getTrace().isTraceEmpty()) {\r\n        final Job job = new WorkspaceJob(\"Exploring the trace...\") {\r\n            public IStatus runInWorkspace(IProgressMonitor monitor) throws CoreException {\r\n                view.getModel().save(monitor).launch(TraceExplorerDelegate.MODE_TRACE_EXPLORE, monitor, true);\r\n                return Status.OK_STATUS;\r\n            }\r\n        };\r\n        job.setRule(ResourcesPlugin.getWorkspace().getRoot());\r\n        job.setUser(true);\r\n        job.schedule();\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.traceexplorer.TraceExplorerComposite.doExplore",
	"Comment": "runs the trace explorer with the expressionsthat are in the table.",
	"Method": "void doExplore(){\r\n    view.getModel().save(monitor).launch(TraceExplorerDelegate.MODE_TRACE_EXPLORE, monitor, true);\r\n    return Status.OK_STATUS;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.job.ProverJob.stopObligation",
	"Comment": "sends a signal to the tlapm indicating that the obligationwith the given id should be stopped.",
	"Method": "void stopObligation(int id){\r\n    if (proverProcess != null && !proverProcess.isTerminated()) {\r\n        try {\r\n            proverProcess.getStreamsProxy().write(\"stop \" + id + \"\\n\");\r\n        } catch (IOException e) {\r\n            ProverUIActivator.getDefault().logError(\"Error sending signal to tlapm to stop obligation \" + id, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.liveness.BEGraph.toString",
	"Comment": "this method assumes that the visited field of all the nodes is set to the\tsame value.",
	"Method": "String toString(){\r\n    StringBuffer buf = new StringBuffer();\r\n    int sz = this.initNodes.size();\r\n    if (sz != 0) {\r\n        boolean seen = this.getInitNode(0).getVisited();\r\n        for (int i = 0; i < this.initNodes.size(); i++) {\r\n            BEGraphNode node = this.getInitNode(i);\r\n            node.toString(buf, seen);\r\n        }\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.util.DocumentHelper.getRegionExpandedBoth",
	"Comment": "combines the effect of backwards and forwards region expansion",
	"Method": "WordRegion getRegionExpandedBoth(IDocument document,int documentOffset,WordRegion getRegionExpandedBoth,IDocument document,int documentOffset,IWordDetector detector){\r\n    final IRegion backwards = getRegionExpandedBackwards(document, documentOffset, detector);\r\n    final IRegion forwards = getRegionExpandedForwards(document, documentOffset, detector);\r\n    final String word = document.get(backwards.getOffset(), backwards.getLength() + forwards.getLength());\r\n    return new WordRegion(backwards.getOffset(), backwards.getLength() + forwards.getLength(), word);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.QustomDialogBuilder.setDividerColor",
	"Comment": "use this method to color the divider between the question and content.will not display if no question is set.",
	"Method": "QustomDialogBuilder setDividerColor(int color){\r\n    mDivider.setBackgroundColor(color);\r\n    return this;\r\n}"
}, {
	"Path": "com.facebook.swift.codec.ThriftCodecManager.addBuiltinCodec",
	"Comment": "adds a thriftcodec to the codec map, but does not register it with the catalog since builtinsshould already be registered",
	"Method": "void addBuiltinCodec(ThriftCodec<?> codec){\r\n    typeCodecs.put(codec.getType(), codec);\r\n}"
}, {
	"Path": "pcal.PcalTranslate.ExplodeCallGoto",
	"Comment": "generate sequence of statements corresponding to call followed by a goto.",
	"Method": "Vector ExplodeCallGoto(AST.CallGoto ast,String next){\r\n    AST.Call call = new AST.Call();\r\n    call.to = ast.to;\r\n    call.args = ast.args;\r\n    call.line = ast.line;\r\n    call.col = ast.col;\r\n    call.setOrigin(ast.getOrigin());\r\n    return ExplodeCall(call, ast.after);\r\n}"
}, {
	"Path": "com.facebook.swift.service.exceptions.ExceptionTest.testThrowUnexpectedThriftCheckedException",
	"Comment": "it from the java exception specification, so a thriftcheckedexception is caught.",
	"Method": "void testThrowUnexpectedThriftCheckedException(){\r\n    getClient().throwUnexpectedThriftCheckedException();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.util.ProverHelper.setSolverOption",
	"Comment": "if the user has specified a solver preference pref,then adds the appropriate entries to the list command of arguments.",
	"Method": "void setSolverOption(List<String> command){\r\n    String solverText = ProverUIActivator.getDefault().getPreferenceStore().getString(ProverSecondPreferencePage.SOLVER_KEY);\r\n    if (solverText.trim().length() == 0) {\r\n        return;\r\n    }\r\n    command.add(ITLAPMOptions.SOLVER);\r\n    command.add(solverText);\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.DomUtils.removeElements",
	"Comment": "removes any elements matching the given xpath expression, relative to thegiven element",
	"Method": "void removeElements(String xPath,Element searchBase){\r\n    for (final Element elementToDelete : XmlUtils.findElements(xPath, searchBase)) {\r\n        final Node parentNode = elementToDelete.getParentNode();\r\n        parentNode.removeChild(elementToDelete);\r\n        removeTextNodes(parentNode);\r\n    }\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.getFeedbackSessionsClosedWithinThePastHour",
	"Comment": "returns returns a list of sessions that were closed within past hour.",
	"Method": "List<FeedbackSessionAttributes> getFeedbackSessionsClosedWithinThePastHour(){\r\n    List<FeedbackSessionAttributes> requiredSessions = new ArrayList();\r\n    List<FeedbackSessionAttributes> sessions = fsDb.getFeedbackSessionsPossiblyNeedingClosedEmail();\r\n    for (FeedbackSessionAttributes session : sessions) {\r\n        if (!coursesLogic.getCourse(session.getCourseId()).isCourseDeleted() && session.isClosedWithinPastHour()) {\r\n            requiredSessions.add(session);\r\n        }\r\n    }\r\n    return requiredSessions;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.itd.AbstractItdTypeDetailsProvidingMetadataItem.getTypeAnnotation",
	"Comment": "returns the metadata for an annotation of the given type if the governordoes not already have one.",
	"Method": "AnnotationMetadata getTypeAnnotation(JavaType annotationType){\r\n    if (governorTypeDetails.getAnnotation(annotationType) != null) {\r\n        return null;\r\n    }\r\n    return new AnnotationMetadataBuilder(annotationType).build();\r\n}"
}, {
	"Path": "teammates.test.cases.util.StringHelperTest.assertEncryptionUsesExpectedDefaultParams",
	"Comment": "verifies that encrypting with and without specifying algorithm parameters produce the same ciphertext. this ensures parameters being specified for encryption are the same as the defaults.",
	"Method": "void assertEncryptionUsesExpectedDefaultParams(String plaintext){\r\n    String actualCiphertext = encryptWithoutSpecifyingAlgorithmParams(plaintext);\r\n    String expectedCiphertext = StringHelper.encrypt(plaintext);\r\n    assertEquals(expectedCiphertext, actualCiphertext);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.output.PartitionToolkit.mergePartitions",
	"Comment": "merges an array of partitions of the same type to one partition of this type",
	"Method": "ITypedRegion mergePartitions(ITypedRegion[] regions){\r\n    Assert.isNotNull(regions);\r\n    if (regions.length == 0) {\r\n        return null;\r\n    }\r\n    String type = null;\r\n    int offset = -1;\r\n    int length = 0;\r\n    int matcher = -1;\r\n    for (int i = 0; i < regions.length; i++) {\r\n        if (type == null) {\r\n            type = regions[i].getType();\r\n        } else {\r\n            if (!type.equals(regions[i].getType())) {\r\n                return null;\r\n            }\r\n        }\r\n        if (offset == -1) {\r\n            offset = regions[i].getOffset();\r\n        } else {\r\n            if (regions[i].getOffset() != matcher) {\r\n                return null;\r\n            }\r\n        }\r\n        matcher = regions[i].getOffset() + regions[i].getLength();\r\n        length += regions[i].getLength();\r\n    }\r\n    return new TypedRegion(offset, length, type);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.getPossibleGiversForTeam",
	"Comment": "get the possible givers for a team recipient for the question specified.",
	"Method": "List<String> getPossibleGiversForTeam(FeedbackQuestionAttributes fqa,String recipientTeam){\r\n    FeedbackParticipantType giverType = fqa.giverType;\r\n    FeedbackParticipantType recipientType = fqa.recipientType;\r\n    List<String> possibleGivers = new ArrayList();\r\n    if (recipientType == FeedbackParticipantType.TEAMS) {\r\n        switch(giverType) {\r\n            case TEAMS:\r\n                possibleGivers = getSortedListOfTeams();\r\n                break;\r\n            case STUDENTS:\r\n                possibleGivers = getSortedListOfStudentEmails();\r\n                break;\r\n            case INSTRUCTORS:\r\n                possibleGivers = getSortedListOfInstructorEmails();\r\n                break;\r\n            case SELF:\r\n                possibleGivers.add(fqa.creatorEmail);\r\n                break;\r\n            default:\r\n                log.severe(\"Invalid giver type specified\");\r\n                break;\r\n        }\r\n    } else if (recipientType == FeedbackParticipantType.OWN_TEAM) {\r\n        if (giverType == FeedbackParticipantType.TEAMS) {\r\n            possibleGivers.add(recipientTeam);\r\n        } else {\r\n            possibleGivers = new ArrayList(getTeamMembersFromRoster(recipientTeam));\r\n        }\r\n    }\r\n    return possibleGivers;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorCourseEditPage.clickSaveCourseButton",
	"Comment": "clicks the save changes button to save the changes made to the course.",
	"Method": "void clickSaveCourseButton(){\r\n    click(saveCourseButton);\r\n    waitForPageToLoad();\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.utils.Device.shutdown",
	"Comment": "shuts down the device.\tthis method first tries using the reboot command from toolbox. \tbut since some toolbox versions does not have this, it further fallbacks on using a sysrq trigger.",
	"Method": "Boolean shutdown(){\r\n    Result result = mShell.execute(\"toolbox reboot -p\");\r\n    if (result == null || !result.wasSuccessful()) {\r\n        result = mShell.execute(\"echo 1 > /proc/sys/kernel/sysrq && echo s > /proc/sysrq-trigger && echo o > /proc/sysrq-trigger\");\r\n    }\r\n    return result != null && result.wasSuccessful();\r\n}"
}, {
	"Path": "teammates.test.cases.action.BaseActionTest.getFeedbackParticipantComment",
	"Comment": "filters feedback participant comment from all comments on a response.",
	"Method": "FeedbackResponseCommentAttributes getFeedbackParticipantComment(String responseId){\r\n    FeedbackResponseCommentsDb frcDb = new FeedbackResponseCommentsDb();\r\n    List<FeedbackResponseCommentAttributes> frcList = frcDb.getFeedbackResponseCommentsForResponse(responseId);\r\n    frcList = frcList.stream().filter(comment -> comment.isCommentFromFeedbackParticipant).collect(Collectors.toList());\r\n    if (frcList.isEmpty()) {\r\n        return null;\r\n    }\r\n    return frcList.get(0);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.video.InputSurface.getSurface",
	"Comment": "returns the surface that the mediacodec receives buffers from.",
	"Method": "Surface getSurface(){\r\n    return mSurface;\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.containers.Data.trim",
	"Comment": "this method will remove all of the empty lines from the data array",
	"Method": "DATATYPE trim(){\r\n    if (size() > 0) {\r\n        List<String> list = new ArrayList<String>();\r\n        for (int i = 0; i < mLines.length; i++) {\r\n            if (mLines[i].trim().length() > 0) {\r\n                list.add(mLines[i]);\r\n            }\r\n        }\r\n        mLines = list.toArray(new String[list.size()]);\r\n    }\r\n    return (DATATYPE) this;\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.setOnTopOfView",
	"Comment": "places the popup layout on top of the given viewwill have the centers of the layouts in the same place",
	"Method": "void setOnTopOfView(View under){\r\n    int[] location = new int[2];\r\n    under.getLocationOnScreen(location);\r\n    int fromLeft = location[0];\r\n    int fromTop = location[1];\r\n    int viewWidth = under.getWidth();\r\n    int viewHeight = under.getHeight();\r\n    int startX;\r\n    int startY;\r\n    if (getContext().getResources().getBoolean(R.bool.isRTL)) {\r\n        startX = fromLeft - (int) (viewWidth / 2.0);\r\n        startY = fromTop - (int) (viewHeight / 2.0);\r\n    } else {\r\n        startX = fromLeft + (int) (viewWidth / 2.0);\r\n        startY = fromTop + (int) (viewHeight / 2.0);\r\n    }\r\n    startX = startX - (width / 2);\r\n    startY = startY - (height / 2);\r\n    if (startX < 0) {\r\n        startX = 10;\r\n    } else if (startX > screenWidth - width) {\r\n        startX = screenWidth - width - 10;\r\n    }\r\n    int statusActionBar = Utils.getStatusBarHeight(getContext());\r\n    if (startY < statusActionBar) {\r\n        startY = statusActionBar + 10;\r\n    } else if (Utils.hasNavBar(getContext()) && startY + height > screenHeight - Utils.getNavBarHeight(getContext())) {\r\n        startY = screenHeight - height - Utils.getNavBarHeight(getContext()) - 10;\r\n    } else if (!Utils.hasNavBar(getContext()) && startY + height > screenHeight) {\r\n        startY = screenHeight - height - 10;\r\n    }\r\n    setDistanceFromLeft(startX);\r\n    setDistanceFromTop(startY);\r\n}"
}, {
	"Path": "teammates.common.util.SanitizationHelper.sanitizeName",
	"Comment": "sanitizes name by removing leading, trailing, and duplicate internal whitespace.",
	"Method": "String sanitizeName(String rawName){\r\n    return StringHelper.removeExtraSpace(rawName);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.api_helper.TwitLongerHelper.updateTwitlonger",
	"Comment": "updates the status on twitlonger to include the tweet id from twitter.helpful for threading.",
	"Method": "boolean updateTwitlonger(TwitLongerStatus status,long tweetId){\r\n    try {\r\n        Request request = new Request.Builder().url(PUT_URL + status.getId()).addHeader(\"X-API-KEY\", TWITLONGER_API_KEY).addHeader(\"X-Auth-Service-Provider\", SERVICE_PROVIDER).addHeader(\"X-Verify-Credentials-Authorization\", getAuthrityHeader(twitter, context)).put(RequestBody.create(MediaType.parse(\"application/x-www-form-urlencoded;  charset=utf-8\"), (\"twitter_status_id=\" + tweetId).getBytes(\"UTF8\"))).build();\r\n        Response response = new OkHttpClient.Builder().build().newCall(request).execute();\r\n        BufferedReader rd = new BufferedReader(new InputStreamReader(response.body().byteStream()));\r\n        if (rd.readLine() != null) {\r\n            Log.v(\"twitlonger\", \"updated the status successfully\");\r\n            return true;\r\n        }\r\n    } catch (Throwable e) {\r\n        e.printStackTrace();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.swipe_refresh_layout.FullScreenSwipeRefreshLayout.setColorScheme",
	"Comment": "set the four colors used in the progress animation. the first color willalso be the color of the bar that grows in response to a user swipegesture.",
	"Method": "void setColorScheme(int colorRes1,int colorRes2,int colorRes3,int colorRes4){\r\n    ensureTarget();\r\n    final int color1 = colorRes1;\r\n    final int color2 = colorRes2;\r\n    final int color3 = colorRes3;\r\n    final int color4 = colorRes4;\r\n    mProgressBar.setColorScheme(color1, color2, color3, color4);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.output.data.TLCVariable.setTraceExplorerVar",
	"Comment": "sets the status of this variable as representing or notrepresenting a trace explorer expression. by default, itis not.",
	"Method": "void setTraceExplorerVar(boolean isTraceExplorerVar){\r\n    this.isTraceExplorerVar = isTraceExplorerVar;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.dialog.FilteredDefinitionSelectionDialog.getElementName",
	"Comment": "this is used to check for duplicates. currently, duplicates still appear for some reason.",
	"Method": "String getElementName(Object item){\r\n    OpDefNode node = (OpDefNode) item;\r\n    return node.getSource().getName().toString() + node.getSource().getOriginallyDefinedInModuleNode().getName().toString();\r\n}"
}, {
	"Path": "org.squirrelframework.foundation.util.Base64Coder.encode",
	"Comment": "encodes a byte array into base64 format. no blanks or line breaks areinserted in the output.",
	"Method": "char[] encode(byte[] in,char[] encode,byte[] in,int iLen,char[] encode,byte[] in,int iOff,int iLen){\r\n    int oDataLen = (iLen * 4 + 2) / 3;\r\n    int oLen = ((iLen + 2) / 3) * 4;\r\n    char[] out = new char[oLen];\r\n    int ip = iOff;\r\n    int iEnd = iOff + iLen;\r\n    int op = 0;\r\n    while (ip < iEnd) {\r\n        int i0 = in[ip++] & 0xff;\r\n        int i1 = ip < iEnd ? in[ip++] & 0xff : 0;\r\n        int i2 = ip < iEnd ? in[ip++] & 0xff : 0;\r\n        int o0 = i0 >>> 2;\r\n        int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\r\n        int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\r\n        int o3 = i2 & 0x3F;\r\n        out[op++] = map1[o0];\r\n        out[op++] = map1[o1];\r\n        out[op] = op < oDataLen ? map1[o2] : '=';\r\n        op++;\r\n        out[op] = op < oDataLen ? map1[o3] : '=';\r\n        op++;\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "teammates.test.cases.browsertests.AdminSearchPageUiTest.assertInstructorRowDisplayed",
	"Comment": "returns true if the instructor is displayed correctly in the instructor table.",
	"Method": "void assertInstructorRowDisplayed(InstructorAttributes instructor,CourseAttributes course){\r\n    WebElement instructorRow = searchPage.getInstructorRow(instructor);\r\n    String actualCourseId = instructorRow.findElement(By.xpath(\"td[1]\")).getText();\r\n    String actualCourseName = instructorRow.findElement(By.xpath(\"td[1]\")).getAttribute(\"data-original-title\");\r\n    String actualName = instructorRow.findElement(By.xpath(\"td[2]\")).getText();\r\n    String actualGoogleId = instructorRow.findElement(By.xpath(\"td[3]\")).getText();\r\n    String expectedCourseId = instructor.courseId;\r\n    String expectedCourseName = sanitizeWithFnEscapeXml(course.getName());\r\n    String expectedName = instructor.name;\r\n    String expectedGoogleId = StringHelper.convertToEmptyStringIfNull(instructor.googleId);\r\n    assertEquals(expectedCourseId, actualCourseId);\r\n    assertEquals(expectedCourseName, actualCourseName);\r\n    assertEquals(expectedName, actualName);\r\n    assertEquals(expectedGoogleId, actualGoogleId);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.preference.TLCChainedPreferenceStore.unregisterChildListeners",
	"Comment": "unregister the child listeners from the child preference stores.",
	"Method": "void unregisterChildListeners(){\r\n    Iterator<PropertyChangeListener> iter = fChildListeners.iterator();\r\n    while (iter.hasNext()) {\r\n        PropertyChangeListener listener = iter.next();\r\n        listener.unregister();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.swift.codec.ThriftCodecManager.addCodec",
	"Comment": "adds or replaces the codec associated with the type contained in the codec.this does notreplace any current users of the existing codec associated with the type.",
	"Method": "void addCodec(ThriftCodec<?> codec){\r\n    catalog.addThriftType(codec.getType());\r\n    typeCodecs.put(codec.getType(), codec);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.actions.ToggleCommentAction.isBlockCommented",
	"Comment": "determines whether each line is prefixed by one of the prefixes.",
	"Method": "boolean isBlockCommented(int startLine,int endLine,String[] prefixes,IDocument document){\r\n    try {\r\n        for (int i = startLine; i <= endLine; i++) {\r\n            IRegion line = document.getLineInformation(i);\r\n            String text = document.get(line.getOffset(), line.getLength());\r\n            int[] found = TextUtilities.indexOf(prefixes, text, 0);\r\n            if (found[0] == -1)\r\n                return false;\r\n            String s = document.get(line.getOffset(), found[0]);\r\n            s = s.trim();\r\n            if (s.length() != 0)\r\n                return false;\r\n        }\r\n        return true;\r\n    } catch (BadLocationException x) {\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "tla2sany.semantic.SemanticNode.getPreCommentsAsString",
	"Comment": "returns the result of getprecomments poorly formatted forprinting.to be used in the tostring methods for the variousnode types.",
	"Method": "String getPreCommentsAsString(){\r\n    return SyntaxTreeNode.PreCommentToString(this.getPreComments());\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.output.data.StepTuple.getSANYLocation",
	"Comment": "returns the location of this step as reportedby sany when the prover was launched. this locationis the beginning of the step to the end of the statementof the step.",
	"Method": "Location getSANYLocation(){\r\n    return ProverHelper.stringToLoc(sanyMarker.getAttribute(ProverHelper.SANY_LOC_ATR, null));\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.TLAFastPartitioner.clearPositionCache",
	"Comment": "clears the position cache. needs to be called whenever the positions havebeen updated.",
	"Method": "void clearPositionCache(){\r\n    if (fCachedPositions != null) {\r\n        fCachedPositions = null;\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.DateUtil.roundToHour",
	"Comment": "rounds the given time down to the closest hour, using the given timezone.",
	"Method": "long roundToHour(long pTime,long roundToHour,long pTime,TimeZone pTimeZone){\r\n    int offset = pTimeZone.getOffset(pTime);\r\n    return ((pTime / HOUR) * HOUR) - offset;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.job.TLCJob.constructProgramArguments",
	"Comment": "reads the model parameters and constructs the corresponding command line arguments",
	"Method": "String[] constructProgramArguments(){\r\n    final List<String> arguments = new ArrayList<String>();\r\n    ILaunchConfiguration config = launch.getLaunchConfiguration();\r\n    if (!checkDeadlock()) {\r\n        arguments.add(\"-deadlock\");\r\n    }\r\n    if (checkPoint()) {\r\n        arguments.add(\"-checkpoint\");\r\n        arguments.add(String.valueOf(CHECKPOINT_INTERVAL));\r\n    }\r\n    final boolean hasSpec = hasSpec(config);\r\n    if (hasSpec) {\r\n        if (runAsModelCheck()) {\r\n            if (isDepthFirst()) {\r\n                int dfidDepth = config.getAttribute(IModelConfigurationConstants.LAUNCH_DFID_DEPTH, IModelConfigurationDefaults.LAUNCH_DFID_DEPTH_DEFAULT);\r\n                arguments.add(\"-dfid\");\r\n                arguments.add(String.valueOf(dfidDepth));\r\n            }\r\n        } else {\r\n            arguments.add(\"-simulate\");\r\n            int traceDepth = config.getAttribute(IModelConfigurationConstants.LAUNCH_SIMU_DEPTH, IModelConfigurationDefaults.LAUNCH_SIMU_DEPTH_DEFAULT);\r\n            if (traceDepth != IModelConfigurationDefaults.LAUNCH_SIMU_DEPTH_DEFAULT) {\r\n                arguments.add(\"-depth\");\r\n                arguments.add(String.valueOf(traceDepth));\r\n            }\r\n            int aril = config.getAttribute(IModelConfigurationConstants.LAUNCH_SIMU_ARIL, IModelConfigurationDefaults.LAUNCH_SIMU_ARIL_DEFAULT);\r\n            int seed = config.getAttribute(IModelConfigurationConstants.LAUNCH_SIMU_SEED, IModelConfigurationDefaults.LAUNCH_SIMU_SEED_DEFAULT);\r\n            if (aril != IModelConfigurationDefaults.LAUNCH_SIMU_ARIL_DEFAULT) {\r\n                arguments.add(\"-aril\");\r\n                arguments.add(String.valueOf(aril));\r\n            }\r\n            if (seed != IModelConfigurationDefaults.LAUNCH_SIMU_SEED_DEFAULT) {\r\n                arguments.add(\"-seed\");\r\n                arguments.add(String.valueOf(seed));\r\n            }\r\n        }\r\n    }\r\n    if (hasSpec) {\r\n        if (recover()) {\r\n            IResource[] checkpoints = config.getAdapter(Model.class).getCheckpoints(false);\r\n            if (checkpoints.length > 0) {\r\n                arguments.add(\"-recover\");\r\n                arguments.add(checkpoints[0].getName());\r\n            }\r\n        }\r\n    }\r\n    final boolean deferLiveness = launch.getLaunchConfiguration().getAttribute(LAUNCH_DEFER_LIVENESS, false);\r\n    if (deferLiveness) {\r\n        arguments.add(\"-lncheck\");\r\n        arguments.add(\"final\");\r\n    }\r\n    int fpBits = launch.getLaunchConfiguration().getAttribute(LAUNCH_FPBITS, -1);\r\n    if (fpBits >= 0) {\r\n        arguments.add(\"-fpbits\");\r\n        arguments.add(String.valueOf(fpBits));\r\n    }\r\n    if (launch.getLaunchConfiguration().getAttribute(LAUNCH_FP_INDEX_RANDOM, LAUNCH_FP_INDEX_RANDOM_DEFAULT)) {\r\n        final int fpIndex = new Random().nextInt(FP64.Polys.length);\r\n        arguments.add(\"-fp\");\r\n        arguments.add(String.valueOf(fpIndex));\r\n    } else {\r\n        final int fpSeedOffset = launch.getLaunchConfiguration().getAttribute(LAUNCH_FP_INDEX, LAUNCH_FP_INDEX_DEFAULT);\r\n        arguments.add(\"-fp\");\r\n        arguments.add(String.valueOf(fpSeedOffset));\r\n    }\r\n    final int maxSetSize = launch.getLaunchConfiguration().getAttribute(LAUNCH_MAXSETSIZE, TLCGlobals.setBound);\r\n    if (maxSetSize != TLCGlobals.setBound) {\r\n        arguments.add(\"-maxSetSize\");\r\n        arguments.add(String.valueOf(maxSetSize));\r\n    }\r\n    if (visualizeStateGraph() && hasSpec) {\r\n        arguments.add(\"-dump\");\r\n        arguments.add(\"dot,colorize\");\r\n        arguments.add(modelName);\r\n    }\r\n    arguments.add(\"-config\");\r\n    arguments.add(cfgFile.getName());\r\n    if (config.getAttribute(MODEL_BEHAVIOR_SPEC_TYPE, MODEL_BEHAVIOR_TYPE_DEFAULT) != MODEL_BEHAVIOR_TYPE_NO_SPEC) {\r\n        arguments.add(\"-coverage\");\r\n        arguments.add(String.valueOf(COVERAGE_INTERVAL));\r\n    }\r\n    arguments.add(\"-workers\");\r\n    arguments.add(String.valueOf(workers));\r\n    arguments.add(\"-tool\");\r\n    arguments.add(\"-metadir\");\r\n    arguments.add(launchDir.getLocation().toOSString());\r\n    arguments.add(ResourceHelper.getModuleName(rootModule));\r\n    final ILaunchConfiguration launchConfig = launch.getLaunchConfiguration();\r\n    final String tlcParameters = launchConfig.getAttribute(LAUNCH_TLC_PARAMETERS, (String) null);\r\n    if (tlcParameters != null && !\"\".equals(tlcParameters.trim())) {\r\n        final String[] split = tlcParameters.trim().split(\"\\\\s+\");\r\n        arguments.addAll(Arrays.asList(split));\r\n    }\r\n    return (String[]) arguments.toArray(new String[arguments.size()]);\r\n}"
}, {
	"Path": "pcal.PcalTranslate.ExplodeReturn",
	"Comment": "modified by ll on 2 feb 2006 to add line and column numbers to thenewly created statements for error reporting.",
	"Method": "Vector ExplodeReturn(AST.Return ast,String next){\r\n    Vector result = new Vector();\r\n    if (ast.from == null) {\r\n        ast.from = currentProcedure;\r\n    }\r\n    if (ast.from == null) {\r\n        throw new PcalTranslateException(\"`return' statement not in procedure\", ast);\r\n    }\r\n    ;\r\n    int from = st.FindProc(ast.from);\r\n    if (!(from < st.procs.size())) {\r\n        throw new PcalTranslateException(\"Error in procedure (perhaps name used elsewhere)\", ast);\r\n    }\r\n    PcalSymTab.ProcedureEntry pe = (PcalSymTab.ProcedureEntry) st.procs.elementAt(from);\r\n    AST.Assign ass = new AST.Assign();\r\n    ass.line = ast.line;\r\n    ass.col = ast.col;\r\n    AST.SingleAssign sass = new AST.SingleAssign();\r\n    sass.line = ast.line;\r\n    sass.col = ast.col;\r\n    TLAExpr expr = new TLAExpr();\r\n    sass.lhs.var = \"pc\";\r\n    sass.lhs.sub = new TLAExpr();\r\n    expr.addLine();\r\n    expr.addToken(IdentToken(\"Head\"));\r\n    expr.addToken(BuiltInToken(\"(\"));\r\n    expr.addToken(AddedToken(\"stack\"));\r\n    expr.addToken(BuiltInToken(\")\"));\r\n    expr.addToken(BuiltInToken(\".\"));\r\n    expr.addToken(IdentToken(\"pc\"));\r\n    expr.normalize();\r\n    sass.rhs = expr;\r\n    ass.ass = Singleton(sass);\r\n    result.addElement(ass);\r\n    for (int i = 0; i < pe.decls.size(); i++) {\r\n        AST.PVarDecl decl = (AST.PVarDecl) pe.decls.elementAt(i);\r\n        ass = new AST.Assign();\r\n        ass.line = ast.line;\r\n        ass.col = ast.col;\r\n        sass = new AST.SingleAssign();\r\n        sass.line = ast.line;\r\n        sass.col = ast.col;\r\n        expr = new TLAExpr();\r\n        sass.lhs.var = decl.var;\r\n        sass.lhs.sub = new TLAExpr();\r\n        expr.addLine();\r\n        expr.addToken(IdentToken(\"Head\"));\r\n        expr.addToken(BuiltInToken(\"(\"));\r\n        expr.addToken(AddedToken(\"stack\"));\r\n        expr.addToken(BuiltInToken(\")\"));\r\n        expr.addToken(BuiltInToken(\".\"));\r\n        expr.addToken(IdentToken(decl.var));\r\n        expr.normalize();\r\n        sass.rhs = expr;\r\n        sass.setOrigin(ast.getOrigin());\r\n        ass.setOrigin(ast.getOrigin());\r\n        ass.ass = Singleton(sass);\r\n        result.addElement(ass);\r\n    }\r\n    for (int i = 0; i < pe.params.size(); i++) {\r\n        AST.PVarDecl decl = (AST.PVarDecl) pe.params.elementAt(i);\r\n        ass = new AST.Assign();\r\n        ass.line = ast.line;\r\n        ass.col = ast.col;\r\n        sass = new AST.SingleAssign();\r\n        sass.line = ast.line;\r\n        sass.col = ast.col;\r\n        sass.setOrigin(ast.getOrigin());\r\n        ass.setOrigin(ast.getOrigin());\r\n        expr = new TLAExpr();\r\n        sass.lhs.var = decl.var;\r\n        sass.lhs.sub = new TLAExpr();\r\n        expr.addLine();\r\n        expr.addToken(IdentToken(\"Head\"));\r\n        expr.addToken(BuiltInToken(\"(\"));\r\n        expr.addToken(AddedToken(\"stack\"));\r\n        expr.addToken(BuiltInToken(\")\"));\r\n        expr.addToken(BuiltInToken(\".\"));\r\n        expr.addToken(IdentToken(decl.var));\r\n        expr.normalize();\r\n        sass.rhs = expr;\r\n        ass.ass = Singleton(sass);\r\n        result.addElement(ass);\r\n    }\r\n    ass = new AST.Assign();\r\n    ass.line = ast.line;\r\n    ass.col = ast.col;\r\n    sass = new AST.SingleAssign();\r\n    sass.setOrigin(ast.getOrigin());\r\n    ass.setOrigin(ast.getOrigin());\r\n    sass.line = ast.line;\r\n    sass.col = ast.col;\r\n    expr = new TLAExpr();\r\n    sass.lhs.var = \"stack\";\r\n    sass.lhs.sub = new TLAExpr();\r\n    expr.addLine();\r\n    expr.addToken(IdentToken(\"Tail\"));\r\n    expr.addToken(BuiltInToken(\"(\"));\r\n    expr.addToken(AddedToken(\"stack\"));\r\n    expr.addToken(BuiltInToken(\")\"));\r\n    expr.normalize();\r\n    sass.rhs = expr;\r\n    ass.ass = Singleton(sass);\r\n    result.addElement(ass);\r\n    return result;\r\n}"
}, {
	"Path": "teammates.logic.core.StudentsLogic.validateSectionsAndTeams",
	"Comment": "validates sections for any limit violations and teams for any team name violations.",
	"Method": "void validateSectionsAndTeams(List<StudentAttributes> studentList,String courseId){\r\n    List<StudentAttributes> mergedList = getMergedList(studentList, courseId);\r\n    if (mergedList.size() < 2) {\r\n        return;\r\n    }\r\n    String errorMessage = getSectionInvalidityInfo(mergedList) + getTeamInvalidityInfo(mergedList);\r\n    if (!errorMessage.isEmpty()) {\r\n        throw new EnrollException(errorMessage);\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.output.data.TLCModelLaunchDataProvider.connectToSourceRegistry",
	"Comment": "connects this provider to the tlc output source registry. there are two different tlc output source registries, one for trace exploration and one for model checking. this connects to the one for model checking.",
	"Method": "void connectToSourceRegistry(){\r\n    TLCOutputSourceRegistry.getModelCheckSourceRegistry().connect(this);\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.containers.Data.getLine",
	"Comment": "this will return one specified line of the data array.\t\tnote that this also takes negative number to get a line from the end and up",
	"Method": "String getLine(String getLine,Integer aLineNumber,String getLine,Integer aLineNumber,Boolean aSkipEmpty){\r\n    if (size() > 0) {\r\n        Integer count = aLineNumber < 0 ? (mLines.length + aLineNumber) : aLineNumber;\r\n        while (count >= 0 && count < mLines.length) {\r\n            if (!aSkipEmpty || mLines[count].trim().length() > 0) {\r\n                return mLines[count].trim();\r\n            }\r\n            count = aLineNumber < 0 ? (count - 1) : (count + 1);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "teammates.ui.controller.InstructorFeedbackAbstractAction.extractFeedbackSessionData",
	"Comment": "creates a feedback session attributes object from the request parameters.the created time is always set to now, and the opening email enabled flag is always set to true.",
	"Method": "FeedbackSessionAttributes extractFeedbackSessionData(String fsName,CourseAttributes course,String creatorEmail){\r\n    Assumption.assertNotNull(fsName);\r\n    Assumption.assertNotNull(course);\r\n    Assumption.assertNotNull(creatorEmail);\r\n    FeedbackSessionAttributes attributes = // For existing sessions, creation time will be overwritten to its existing value at the logic layer\r\n    FeedbackSessionAttributes.builder(fsName, course.getId(), creatorEmail).withCreatedTime(Instant.now()).withTimeZone(course.getTimeZone()).build();\r\n    inputStartTimeLocal = TimeHelper.parseDateTimeFromSessionsForm(getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_STARTDATE), getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_STARTTIME));\r\n    inputEndTimeLocal = TimeHelper.parseDateTimeFromSessionsForm(getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_ENDDATE), getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_ENDTIME));\r\n    attributes.setStartTime(TimeHelper.convertLocalDateTimeToInstant(inputStartTimeLocal, attributes.getTimeZone()));\r\n    attributes.setEndTime(TimeHelper.convertLocalDateTimeToInstant(inputEndTimeLocal, attributes.getTimeZone()));\r\n    String paramGracePeriod = getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_GRACEPERIOD);\r\n    try {\r\n        attributes.setGracePeriodMinutes(Integer.parseInt(paramGracePeriod));\r\n    } catch (NumberFormatException nfe) {\r\n        throw new InvalidPostParametersException(\"Failed to parse grace period parameter: \" + paramGracePeriod, nfe);\r\n    }\r\n    attributes.setInstructions(getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_INSTRUCTIONS));\r\n    String type = getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_RESULTSVISIBLEBUTTON);\r\n    switch(type) {\r\n        case Const.INSTRUCTOR_FEEDBACK_RESULTS_VISIBLE_TIME_CUSTOM:\r\n            inputPublishTimeLocal = TimeHelper.parseDateTimeFromSessionsForm(getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_PUBLISHDATE), getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_PUBLISHTIME));\r\n            attributes.setResultsVisibleFromTime(TimeHelper.convertLocalDateTimeToInstant(inputPublishTimeLocal, attributes.getTimeZone()));\r\n            break;\r\n        case Const.INSTRUCTOR_FEEDBACK_RESULTS_VISIBLE_TIME_ATVISIBLE:\r\n            attributes.setResultsVisibleFromTime(Const.TIME_REPRESENTS_FOLLOW_VISIBLE);\r\n            break;\r\n        case Const.INSTRUCTOR_FEEDBACK_RESULTS_VISIBLE_TIME_LATER:\r\n            attributes.setResultsVisibleFromTime(Const.TIME_REPRESENTS_LATER);\r\n            break;\r\n        default:\r\n            throw new InvalidPostParametersException(\"Invalid resultsVisibleFrom setting: \" + type);\r\n    }\r\n    type = getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_SESSIONVISIBLEBUTTON);\r\n    switch(type) {\r\n        case Const.INSTRUCTOR_FEEDBACK_SESSION_VISIBLE_TIME_CUSTOM:\r\n            inputVisibleTimeLocal = TimeHelper.parseDateTimeFromSessionsForm(getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_VISIBLEDATE), getNonNullRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_VISIBLETIME));\r\n            attributes.setSessionVisibleFromTime(TimeHelper.convertLocalDateTimeToInstant(inputVisibleTimeLocal, attributes.getTimeZone()));\r\n            break;\r\n        case Const.INSTRUCTOR_FEEDBACK_SESSION_VISIBLE_TIME_ATOPEN:\r\n            attributes.setSessionVisibleFromTime(Const.TIME_REPRESENTS_FOLLOW_OPENING);\r\n            break;\r\n        default:\r\n            throw new InvalidPostParametersException(\"Invalid sessionVisibleFrom setting: \" + type);\r\n    }\r\n    String[] sendReminderEmailsArray = getRequestParamValues(Const.ParamsNames.FEEDBACK_SESSION_SENDREMINDEREMAIL);\r\n    List<String> sendReminderEmailsList = sendReminderEmailsArray == null ? new ArrayList() : Arrays.asList(sendReminderEmailsArray);\r\n    attributes.setClosingEmailEnabled(sendReminderEmailsList.contains(EmailType.FEEDBACK_CLOSING.toString()));\r\n    attributes.setPublishedEmailEnabled(sendReminderEmailsList.contains(EmailType.FEEDBACK_PUBLISHED.toString()));\r\n    attributes.setOpeningEmailEnabled(true);\r\n    return attributes;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.WsClientsMetadata.getEndpointMethod",
	"Comment": "this method provides the related method for the provided endpoint",
	"Method": "MethodMetadataBuilder getEndpointMethod(WsClientEndpoint endPoint){\r\n    if (endPointMethods.get(endPoint.getName()) != null) {\r\n        return endPointMethods.get(endPoint.getName());\r\n    }\r\n    String targetNameSpace = endPoint.getTargetNameSpace();\r\n    Validate.notEmpty(targetNameSpace, \"ERROR: Provided endpoint has not been registered inside @RooWsClients annotation\");\r\n    JavaType endPointType = new JavaType(String.format(\"%s.%s\", getPackageNameFromTargetNameSpace(targetNameSpace), StringUtils.capitalize(endPoint.getName())));\r\n    JavaSymbolName methodName = new JavaSymbolName(StringUtils.uncapitalize(endPoint.getName()));\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    bodyBuilder.appendFormalLine(\"%s jaxWsFactory = new JaxWsProxyFactoryBean();\", getNameOfJavaType(new JavaType(\"org.apache.cxf.jaxws.JaxWsProxyFactoryBean\")));\r\n    bodyBuilder.appendFormalLine(\"jaxWsFactory.setServiceClass(%s.class);\", getNameOfJavaType(endPointType));\r\n    bodyBuilder.appendFormalLine(\"jaxWsFactory.setAddress(this.%s);\", getEndPointField(endPoint).getFieldName());\r\n    if (endPoint.getBindingType().getField().getSymbolName().equals(SoapBindingType.SOAP12.name())) {\r\n        bodyBuilder.appendFormalLine(\"jaxWsFactory.setBindingId(%s.SOAP12HTTP_BINDING);\", getNameOfJavaType(new JavaType(\"javax.xml.ws.soap.SOAPBinding\")));\r\n        bodyBuilder.appendFormalLine(\"jaxWsFactory.setTransportId(%s.SOAP_12_HTTP_BINDING);\", getNameOfJavaType(new JavaType(\"org.apache.cxf.binding.soap.SoapTransportFactory\")));\r\n    }\r\n    bodyBuilder.appendFormalLine(\"jaxWsFactory.setFeatures(%s.asList(new %s(), new %s()));\", getNameOfJavaType(JavaType.ARRAYS), getNameOfJavaType(new JavaType(\"io.tracee.binding.cxf.TraceeCxfFeature\")), getNameOfJavaType(new JavaType(\"org.apache.cxf.feature.LoggingFeature\")));\r\n    bodyBuilder.appendFormalLine(\"%s.info(\\\"Web Service client %s has been created. URL: '{}'\\\", this.%s);\", getLoggerField().getFieldName(), getEndPointField(endPoint).getFieldName().getSymbolNameCapitalisedFirstLetter(), getEndPointField(endPoint).getFieldName());\r\n    bodyBuilder.appendFormalLine(\"return (%s) jaxWsFactory.create();\", getNameOfJavaType(endPointType));\r\n    MethodMetadataBuilder method = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, methodName, endPointType, bodyBuilder);\r\n    method.addAnnotation(new AnnotationMetadataBuilder(SpringJavaType.BEAN));\r\n    endPointMethods.put(endPoint.getName(), method);\r\n    return method;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.util.ProverHelper.isBeingProvedObligation",
	"Comment": "returns true iff the status representsan obligation that is currently being proved.",
	"Method": "boolean isBeingProvedObligation(ObligationStatus status){\r\n    int obState = status.getObligationState();\r\n    String[] proverStatuses = ColorPredicate.proverStatuses(obState);\r\n    for (int i = 0; i < proverStatuses.length; i++) {\r\n        if (proverStatuses[i].equals(ColorPredicate.PROVING_STATUS)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.TLAFastPartitioner.finishScan",
	"Comment": "called by documentchanged2, when it has finished calling the scanner, toset the information about the existence and location of a pluscal partition.",
	"Method": "void finishScan(int state){\r\n    switch(state) {\r\n        case SEEK_ALGORITHM:\r\n            pcalStartCommentOffset = -1;\r\n            pcalStartOffset = -1;\r\n            pcalEndCommentOffset = -1;\r\n            break;\r\n        case START_ALGORITHM:\r\n            break;\r\n        case IN_ALGORITHM:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.metadata.AbstractHashCodeTrackingMetadataNotifier.notifyIfRequired",
	"Comment": "notifies downstream dependencies of a change if and only if the passedmetadata item has a different hash code than the existing metadata item.this is aimed at reducing needless notifications if nothing has actuallychanged since the last notification.",
	"Method": "void notifyIfRequired(MetadataItem metadataItem){\r\n    final String instanceId = MetadataIdentificationUtils.getMetadataInstance(metadataItem.getId());\r\n    final Integer existing = hashes.get(instanceId);\r\n    final int newHash = metadataItem.hashCode();\r\n    if (existing != null && newHash == existing) {\r\n        return;\r\n    }\r\n    hashes.put(instanceId, newHash);\r\n    getMetadataService().put(metadataItem);\r\n    if (getMetadataDependencyRegistry() != null) {\r\n        getMetadataDependencyRegistry().notifyDownstream(metadataItem.getId());\r\n    }\r\n}"
}, {
	"Path": "teammates.logic.api.TaskQueuer.scheduleAdminEmailPreparationInAddressMode",
	"Comment": "schedules an admin email preparation in address mode, i.e. using the address list given directly.",
	"Method": "void scheduleAdminEmailPreparationInAddressMode(String emailId,String addressReceiverListString){\r\n    Map<String, String> paramMap = new HashMap();\r\n    paramMap.put(ParamsNames.ADMIN_EMAIL_ID, emailId);\r\n    paramMap.put(ParamsNames.ADMIN_EMAIL_ADDRESS_RECEIVERS, addressReceiverListString);\r\n    addTask(TaskQueue.ADMIN_PREPARE_EMAIL_ADDRESS_MODE_QUEUE_NAME, TaskQueue.ADMIN_PREPARE_EMAIL_ADDRESS_MODE_WORKER_URL, paramMap);\r\n}"
}, {
	"Path": "teammates.ui.controller.InstructorCourseInstructorAbstractAction.updateInstructorCourseLevelPrivileges",
	"Comment": "updates course level privileges for the instructor by retrieving request parameters.",
	"Method": "void updateInstructorCourseLevelPrivileges(InstructorAttributes instructor){\r\n    boolean isModifyCourseChecked = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_COURSE) != null;\r\n    boolean isModifyInstructorChecked = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR) != null;\r\n    boolean isModifySessionChecked = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION) != null;\r\n    boolean isModifyStudentChecked = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT) != null;\r\n    boolean isViewStudentInSectionsChecked = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS) != null;\r\n    boolean isViewSessionInSectionsChecked = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS) != null;\r\n    boolean isSubmitSessionInSectionsChecked = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS) != null;\r\n    boolean isModifySessionInSectionsChecked = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS) != null;\r\n    instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_COURSE, isModifyCourseChecked);\r\n    instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR, isModifyInstructorChecked);\r\n    instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION, isModifySessionChecked);\r\n    instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT, isModifyStudentChecked);\r\n    instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS, isViewStudentInSectionsChecked);\r\n    instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS, isViewSessionInSectionsChecked);\r\n    instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS, isSubmitSessionInSectionsChecked);\r\n    instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS, isModifySessionInSectionsChecked);\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AdminHomePage.createInstructor",
	"Comment": "fills the form with values from the parameters and clicks the submit button.if an attribute value is null, the existing value in the form is used.",
	"Method": "AdminHomePage createInstructor(InstructorAttributes attributesForNewAccount,String institute){\r\n    if (attributesForNewAccount.name != null) {\r\n        fillTextBox(nameTextBox, attributesForNewAccount.name);\r\n    }\r\n    if (attributesForNewAccount.email != null) {\r\n        fillTextBox(emailTextBox, attributesForNewAccount.email);\r\n    }\r\n    if (institute != null) {\r\n        fillTextBox(institutionTextBox, institute);\r\n    }\r\n    click(submitButton);\r\n    waitForElementToBeClickable(submitButton);\r\n    return this;\r\n}"
}, {
	"Path": "teammates.logic.core.AccountsLogic.joinCourseForInstructorWithInstitute",
	"Comment": "institute is set only if it is not null. if it is null, this instructoris given the institute of an existing instructor of the same course.",
	"Method": "void joinCourseForInstructorWithInstitute(String encryptedKey,String googleId,String institute){\r\n    confirmValidJoinCourseRequest(encryptedKey, googleId);\r\n    InstructorAttributes instructor = instructorsLogic.getInstructorForRegistrationKey(encryptedKey);\r\n    AccountAttributes account = accountsDb.getAccount(googleId);\r\n    String instituteToSave = institute == null ? getCourseInstitute(instructor.courseId) : institute;\r\n    if (account == null) {\r\n        createAccount(AccountAttributes.builder().withGoogleId(googleId).withName(instructor.name).withEmail(instructor.email).withInstitute(instituteToSave).withIsInstructor(true).build());\r\n    } else {\r\n        makeAccountInstructor(googleId);\r\n    }\r\n    instructor.googleId = googleId;\r\n    instructorsLogic.updateInstructorByEmail(instructor.email, instructor);\r\n    StudentAttributes student = studentsLogic.getStudentForEmail(instructor.courseId, instructor.email);\r\n    if (student != null) {\r\n        student.googleId = googleId;\r\n        studentsLogic.updateStudentCascade(instructor.email, student);\r\n    }\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorFeedbackSessionsPageData.addPlaceholderIfEmpty",
	"Comment": "adds the placeholder option to the list of select options if the list is empty.",
	"Method": "void addPlaceholderIfEmpty(List<ElementTag> selectOptions,String message){\r\n    if (!selectOptions.isEmpty()) {\r\n        return;\r\n    }\r\n    ElementTag placeholder = createOption(message, \"\", true);\r\n    selectOptions.add(placeholder);\r\n}"
}, {
	"Path": "teammates.test.cases.action.AdminExceptionTestActionTest.testExecuteAndPostProcess",
	"Comment": "this method verifies if exceptions from adminexceptiontestaction are thrown correctly.",
	"Method": "void testExecuteAndPostProcess(){\r\n    String adminUserId = \"admin.user\";\r\n    gaeSimulation.loginAsAdmin(adminUserId);\r\n    String error;\r\n    AdminExceptionTestAction action;\r\n    ______TS(\"test for AssertionError\");\r\n    error = AssertionError.class.getSimpleName();\r\n    action = getAction(Const.ParamsNames.ERROR, error);\r\n    try {\r\n        action.executeAndPostProcess();\r\n        signalFailureToDetectException(\"AssertionError\");\r\n    } catch (AssertionError ae) {\r\n        assertEquals(ae.getMessage(), \"AssertionError Testing\");\r\n    }\r\n    ______TS(\"test for EntityDoesNotExistException\");\r\n    error = EntityDoesNotExistException.class.getSimpleName();\r\n    action = getAction(Const.ParamsNames.ERROR, error);\r\n    try {\r\n        action.executeAndPostProcess();\r\n        signalFailureToDetectException(\"EntityNotFoundException\");\r\n    } catch (EntityNotFoundException enfe) {\r\n        assertEquals(enfe.getMessage(), \"EntityDoesNotExistException Testing\");\r\n    }\r\n    ______TS(\"test for UnauthorizedAccessException\");\r\n    error = UnauthorizedAccessException.class.getSimpleName();\r\n    action = getAction(Const.ParamsNames.ERROR, error);\r\n    try {\r\n        action.executeAndPostProcess();\r\n        signalFailureToDetectException(\"UnauthorizedAccessException\");\r\n    } catch (UnauthorizedAccessException uae) {\r\n        assertEquals(uae.getMessage(), \"UnauthorizedAccessException Testing\");\r\n    }\r\n    ______TS(\"test for NullPointerException\");\r\n    error = NullPointerException.class.getSimpleName();\r\n    action = getAction(Const.ParamsNames.ERROR, error);\r\n    try {\r\n        action.executeAndPostProcess();\r\n        signalFailureToDetectException(\"NullPointerException\");\r\n    } catch (NullPointerException npe) {\r\n        assertEquals(npe.getMessage(), \"NullPointerException Testing\");\r\n    }\r\n    ______TS(\"test for DeadlineExceededException\");\r\n    error = DeadlineExceededException.class.getSimpleName();\r\n    action = getAction(Const.ParamsNames.ERROR, error);\r\n    try {\r\n        action.executeAndPostProcess();\r\n        signalFailureToDetectException(\"DeadlineExceededException\");\r\n    } catch (DeadlineExceededException dlee) {\r\n        assertEquals(dlee.getMessage(), \"DeadlineExceededException Testing\");\r\n    }\r\n    ______TS(\"test for NullPostParameterException\");\r\n    error = NullPostParameterException.class.getSimpleName();\r\n    action = getAction(Const.ParamsNames.ERROR, error);\r\n    try {\r\n        action.executeAndPostProcess();\r\n        signalFailureToDetectException(\"NullPostParameterException\");\r\n    } catch (NullPostParameterException nppe) {\r\n        assertEquals(nppe.getMessage(), \"NullPostParameterException Testing\");\r\n    }\r\n    ______TS(\"test for success scenario\");\r\n    error = \"\";\r\n    action = getAction(Const.ParamsNames.ERROR, error);\r\n    ActionResult result = action.executeAndPostProcess();\r\n    assertEquals(Const.ActionURIs.ADMIN_HOME_PAGE, result.destination);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.getSortedListOfTeamMembersEmails",
	"Comment": "get a sorted list of team members, who are in the same team as the student.this list includes the student.",
	"Method": "List<String> getSortedListOfTeamMembersEmails(StudentAttributes student){\r\n    String teamName = student.team;\r\n    Set<String> teamMembersEmailsToNames = rosterTeamNameMembersTable.get(teamName);\r\n    List<String> teamMembers = new ArrayList(teamMembersEmailsToNames);\r\n    teamMembers.sort(null);\r\n    return teamMembers;\r\n}"
}, {
	"Path": "org.squirrelframework.foundation.component.ComponentProviderTest.testRegisterInterfaceToInterface",
	"Comment": "i would not think this should be a supported use case but nevertheless itfailed because it only performed one additional lookup iteration onfinding an interface...",
	"Method": "void testRegisterInterfaceToInterface(){\r\n    SquirrelProvider.getInstance().register(Person.class, Student.class);\r\n    SquirrelProvider.getInstance().register(Student.class, Programmer.class);\r\n    Person p = SquirrelProvider.getInstance().newInstance(Person.class);\r\n    assertThat(p, notNullValue());\r\n    assertThat(p, instanceOf(ProgrammerImpl.class));\r\n    SquirrelProvider.getInstance().unregister(Person.class);\r\n}"
}, {
	"Path": "tla2sany.drivers.SANY.frontEndInitialize",
	"Comment": "initialize the all parts of the frontend to handle a new specification.",
	"Method": "void frontEndInitialize(SpecObj spec,PrintStream syserr){\r\n    String fileName = spec.getFileName();\r\n    Errors initErrors = spec.initErrors;\r\n    try {\r\n        Configuration.ReInit();\r\n        Context.reInit();\r\n        Configuration.load(initErrors);\r\n        BuiltInLevel.load();\r\n        if (!initErrors.isSuccess()) {\r\n            syserr.println(\"*** Errors during initialization of SANY:\\n\");\r\n            syserr.print(initErrors);\r\n            spec.errorLevel = 1;\r\n            throw new InitException();\r\n        }\r\n    } catch (Exception e) {\r\n        syserr.println(\"Unexpected exception during SANY initialization \" + fileName + \"\\n\" + e);\r\n        syserr.println(\"Initialization errors detected before \" + \"the unexpected exception:\\n\");\r\n        syserr.print(initErrors);\r\n        spec.errorLevel = 1;\r\n        throw new InitException();\r\n    }\r\n    return;\r\n}"
}, {
	"Path": "tlc2.tool.distributed.fp.FPSetManager.reassign",
	"Comment": "replace the fpset at the given index from the list of fpsets with the\tnext available successor in the list.",
	"Method": "int reassign(int index){\r\n    if (index < 0 || index >= this.fpSets.size()) {\r\n        throw new IllegalArgumentException(\"index not within bounds\");\r\n    }\r\n    if (managerIsBroken) {\r\n        return -1;\r\n    }\r\n    final FPSets broken = this.fpSets.get(index);\r\n    broken.setUnavailable();\r\n    int next = (index + 1) % this.fpSets.size();\r\n    while (next != index) {\r\n        final FPSets replacement = this.fpSets.get(next);\r\n        if (replacement.isAvailable()) {\r\n            for (int j = index; j < next; j++) {\r\n                this.fpSets.set(j, replacement);\r\n            }\r\n            return next;\r\n        }\r\n        next = (next + 1) % this.fpSets.size();\r\n    }\r\n    managerIsBroken = true;\r\n    return -1;\r\n}"
}, {
	"Path": "teammates.ui.controller.InstructorCourseInstructorAbstractAction.getSectionsWithSpecialPrivilegesFromParameters",
	"Comment": "gets the sections that are special for the instructor to be added.",
	"Method": "Map<String, List<String>> getSectionsWithSpecialPrivilegesFromParameters(InstructorAttributes instructor,List<String> sectionNames,Map<String, Boolean> isSectionSpecialMappings){\r\n    HashMap<String, List<String>> specialSectionsInSectionGroups = new HashMap();\r\n    if (instructor.role.equals(Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_CUSTOM)) {\r\n        getSectionsWithSpecialPrivilegesForCustomInstructor(sectionNames, isSectionSpecialMappings, specialSectionsInSectionGroups);\r\n    }\r\n    return specialSectionsInSectionGroups;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.editor.part.EmptyPart.isControlledBy",
	"Comment": "tests if the control belongs to the part, providing a deep search for swt composites",
	"Method": "boolean isControlledBy(Control control){\r\n    Assert.isNotNull(control);\r\n    boolean contains = controls.contains(control);\r\n    if (!contains && control instanceof Composite) {\r\n        Control[] children = ((Composite) control).getChildren();\r\n        for (int i = 0; i < children.length; i++) {\r\n            contains = isControlledBy(children[i]);\r\n            if (contains) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return contains;\r\n}"
}, {
	"Path": "teammates.ui.pagedata.AdminActivityLogPageData.filterLog",
	"Comment": "performs the actual filtering, based on queryparameters.returns false if the logentry fails the filtering process.if the querymessage is null, the function will return trueand set the querymessage with error message.",
	"Method": "boolean filterLog(ActivityLogEntry logEntry){\r\n    if (q == null) {\r\n        if (this.queryMessage == null) {\r\n            this.queryMessage = \"Error parsing the query. QueryParameters not created.\";\r\n        }\r\n        return shouldIncludeLogEntry(logEntry);\r\n    }\r\n    if (q.isRequestInQuery && !arrayContains(q.requestValues, logEntry.getActionName())) {\r\n        return false;\r\n    }\r\n    if (q.isResponseInQuery && !arrayContains(q.responseValues, logEntry.getActionResponse())) {\r\n        return false;\r\n    }\r\n    if (q.isPersonInQuery && !logEntry.getUserName().toLowerCase().contains(q.personValue.toLowerCase()) && !logEntry.getUserGoogleId().toLowerCase().contains(q.personValue.toLowerCase()) && !logEntry.getUserEmail().toLowerCase().contains(q.personValue.toLowerCase())) {\r\n        return false;\r\n    }\r\n    if (q.isRoleInQuery && !arrayContains(q.roleValues, logEntry.getUserRole())) {\r\n        return false;\r\n    }\r\n    if (q.isCutoffInQuery && (logEntry.getActionTimeTaken() == 0 || logEntry.getActionTimeTaken() < q.cutoffValue)) {\r\n        return false;\r\n    }\r\n    if (q.isInfoInQuery) {\r\n        for (String keyString : q.infoValues) {\r\n            if (!logEntry.getLogMessage().toLowerCase().contains(keyString.toLowerCase())) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    if (q.isIdInQuery && !arrayContains(q.idValues, logEntry.getLogId())) {\r\n        return false;\r\n    }\r\n    return shouldIncludeLogEntry(logEntry);\r\n}"
}, {
	"Path": "com.facebook.swift.service.ThriftClientManager.getRemoteAddress",
	"Comment": "returns the remote address that a swift client is connected to",
	"Method": "HostAndPort getRemoteAddress(Object client){\r\n    NiftyClientChannel niftyChannel = getNiftyChannel(client);\r\n    try {\r\n        Channel nettyChannel = niftyChannel.getNettyChannel();\r\n        SocketAddress address = nettyChannel.getRemoteAddress();\r\n        InetSocketAddress inetAddress = (InetSocketAddress) address;\r\n        return HostAndPort.fromParts(inetAddress.getHostString(), inetAddress.getPort());\r\n    } catch (NullPointerException | ClassCastException e) {\r\n        throw new IllegalArgumentException(\"Invalid swift client object\", e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.project.Execution.getElement",
	"Comment": "returns the xml element for this execution within the given maven pom",
	"Method": "Element getElement(Document document){\r\n    final Element executionElement = document.createElement(\"execution\");\r\n    if (StringUtils.isNotBlank(id)) {\r\n        executionElement.appendChild(XmlUtils.createTextElement(document, \"id\", id));\r\n    }\r\n    if (StringUtils.isNotBlank(phase)) {\r\n        executionElement.appendChild(XmlUtils.createTextElement(document, \"phase\", phase));\r\n    }\r\n    final Element goalsElement = DomUtils.createChildElement(\"goals\", executionElement, document);\r\n    for (final String goal : goals) {\r\n        goalsElement.appendChild(XmlUtils.createTextElement(document, \"goal\", goal));\r\n    }\r\n    if (configuration != null) {\r\n        final Node configurationNode = document.importNode(configuration.getConfiguration(), true);\r\n        executionElement.appendChild(configurationNode);\r\n    }\r\n    return executionElement;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.layers.MemberTypeAdditions.buildMethodCall",
	"Comment": "builds the code snippet for a method call with the given properties",
	"Method": "String buildMethodCall(String targetName,String methodName,Collection<MethodParameter> parameters){\r\n    JavaSymbolName.assertJavaNameLegal(methodName);\r\n    final StringBuilder methodCall = new StringBuilder();\r\n    if (StringUtils.isNotBlank(targetName)) {\r\n        JavaSymbolName.assertJavaNameLegal(targetName);\r\n        methodCall.append(targetName);\r\n        methodCall.append(\".\");\r\n    }\r\n    methodCall.append(methodName);\r\n    methodCall.append(\"(\");\r\n    for (final Iterator<MethodParameter> iter = parameters.iterator(); iter.hasNext(); ) {\r\n        final MethodParameter parameter = iter.next();\r\n        methodCall.append(parameter.getValue());\r\n        if (iter.hasNext()) {\r\n            methodCall.append(\", \");\r\n        }\r\n    }\r\n    methodCall.append(\")\");\r\n    return methodCall.toString();\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.readSingleFieldValue",
	"Comment": "defines the code to read all of the data from the protocol into local variables.",
	"Method": "Map<Short, LocalVariableDefinition> readSingleFieldValue(MethodDefinition read){\r\n    LocalVariableDefinition protocol = read.getLocalVariable(\"reader\");\r\n    Map<Short, LocalVariableDefinition> unionData = new TreeMap();\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        LocalVariableDefinition variable = read.addInitializedLocalVariable(toParameterizedType(field.getThriftType()), \"f_\" + field.getName());\r\n        unionData.put(field.getId(), variable);\r\n    }\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"readStructBegin\", void.class);\r\n    read.visitLabel(\"while-begin\");\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"nextField\", boolean.class);\r\n    read.ifZeroGoto(\"while-end\");\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"getFieldId\", short.class);\r\n    read.storeVariable(\"fieldId\");\r\n    read.loadVariable(\"fieldId\");\r\n    List<CaseStatement> cases = new ArrayList();\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        cases.add(caseStatement(field.getId(), field.getName() + \"-field\"));\r\n    }\r\n    read.switchStatement(\"default\", cases);\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        read.visitLabel(field.getName() + \"-field\");\r\n        read.loadVariable(protocol);\r\n        FieldDefinition codecField = codecFields.get(field.getId());\r\n        if (codecField != null) {\r\n            read.loadThis().getField(codecType, codecField);\r\n        }\r\n        Method readMethod = getReadMethod(field.getThriftType());\r\n        if (readMethod == null) {\r\n            throw new IllegalArgumentException(\"Unsupported field type \" + field.getThriftType().getProtocolType());\r\n        }\r\n        read.invokeVirtual(readMethod);\r\n        if (needsCastAfterRead(field, readMethod)) {\r\n            read.checkCast(toParameterizedType(field.getThriftType()));\r\n        }\r\n        if (field.getCoercion().isPresent()) {\r\n            read.invokeStatic(field.getCoercion().get().getFromThrift());\r\n        }\r\n        read.storeVariable(unionData.get(field.getId()));\r\n        read.gotoLabel(\"while-begin\");\r\n    }\r\n    read.visitLabel(\"default\").loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"skipFieldData\", void.class).gotoLabel(\"while-begin\");\r\n    read.visitLabel(\"while-end\");\r\n    read.loadVariable(protocol).invokeVirtual(TProtocolReader.class, \"readStructEnd\", void.class);\r\n    return unionData;\r\n}"
}, {
	"Path": "tlc2.value.Value.toSetEnum",
	"Comment": "convert val into a setenumvalue.returns null if not possible.",
	"Method": "SetEnumValue toSetEnum(){\r\n    return null;\r\n}"
}, {
	"Path": "teammates.ui.controller.InstructorEditInstructorFeedbackSaveAction.isSessionOpenForSpecificUser",
	"Comment": "checks if the session is still open. however, since the instructor is moderating the session,they can moderate it anytime. therefore, it will be true forever.",
	"Method": "boolean isSessionOpenForSpecificUser(FeedbackSessionAttributes session){\r\n    return true;\r\n}"
}, {
	"Path": "util.FileUtil.makeMetaDir",
	"Comment": "the metadir is fromchkpt if it is not null. otherwise, create anew one based on the current time.",
	"Method": "String makeMetaDir(String specDir,String fromChkpt,String makeMetaDir,Date date,String specDir,String fromChkpt){\r\n    if (fromChkpt != null) {\r\n        return fromChkpt;\r\n    }\r\n    String metadir = TLCGlobals.metaDir;\r\n    if (metadir == null) {\r\n        metadir = specDir + TLCGlobals.metaRoot + FileUtil.separator;\r\n    }\r\n    SimpleDateFormat sdf;\r\n    if (Boolean.getBoolean(FileUtil.class.getName() + \".milliseconds\")) {\r\n        sdf = new SimpleDateFormat(\"yy-MM-dd-HH-mm-ss.SSS\");\r\n    } else {\r\n        sdf = new SimpleDateFormat(\"yy-MM-dd-HH-mm-ss\");\r\n    }\r\n    metadir += sdf.format(date);\r\n    File filedir = new File(metadir);\r\n    Assert.check(!filedir.exists(), EC.SYSTEM_METADIR_EXISTS, metadir);\r\n    Assert.check(filedir.mkdirs(), EC.SYSTEM_METADIR_CREATION_ERROR, metadir);\r\n    return metadir;\r\n}"
}, {
	"Path": "teammates.test.driver.EmailChecker.replaceUnpredictableValuesWithPlaceholders",
	"Comment": "substitutes values that are different across various test runs with placeholders.these values are identified using their known, unique formats.",
	"Method": "String replaceUnpredictableValuesWithPlaceholders(String emailContent){\r\n    return emailContent.replaceAll(Const.ParamsNames.REGKEY + \"=\" + REGEX_ENCRYPTED_REGKEY, Const.ParamsNames.REGKEY + \"=\\\\${regkey\\\\.enc}\");\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackRubricQuestionDetails.isValidWeightSize",
	"Comment": "checks if the dimensions of rubricweightsforeachcell is valid accordingto numofrubricsubquestions and numofrubricchoices.",
	"Method": "boolean isValidWeightSize(){\r\n    if (rubricWeightsForEachCell.size() != numOfRubricSubQuestions) {\r\n        return false;\r\n    }\r\n    return rubricWeightsForEachCell.stream().allMatch(x -> x.size() == numOfRubricChoices);\r\n}"
}, {
	"Path": "tlc2.util.StatePoolReader.getCache",
	"Comment": "returns the cached buffer if filled. otherwise, returns null.",
	"Method": "TLCState[] getCache(TLCState[] deqBuf,File file){\r\n    if (this.isFull) {\r\n        Assert.check(this.poolFile == null, EC.SYSTEM_FILE_NULL);\r\n        TLCState[] res = this.buf;\r\n        this.buf = deqBuf;\r\n        this.poolFile = file;\r\n        this.isFull = false;\r\n        this.canRead = false;\r\n        return res;\r\n    } else if (this.poolFile != null && this.canRead) {\r\n        ValueInputStream vis = new ValueInputStream(this.poolFile);\r\n        for (int i = 0; i < deqBuf.length; i++) {\r\n            deqBuf[i] = TLCState.Empty.createEmpty();\r\n            deqBuf[i].read(vis);\r\n        }\r\n        vis.close();\r\n        this.poolFile = file;\r\n        this.canRead = false;\r\n        return deqBuf;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.StringUtil.replaceIgnoreCase",
	"Comment": "replaces a substring of a string with another string, ignoring case.all matches are replaced.",
	"Method": "String replaceIgnoreCase(String pSource,String pPattern,String pReplace){\r\n    if (pPattern.length() == 0) {\r\n        return pSource;\r\n    }\r\n    int match;\r\n    int offset = 0;\r\n    StringBuilder result = new StringBuilder();\r\n    while ((match = indexOfIgnoreCase(pSource, pPattern, offset)) != -1) {\r\n        result.append(pSource.substring(offset, match));\r\n        result.append(pReplace);\r\n        offset = match + pPattern.length();\r\n    }\r\n    result.append(pSource.substring(offset));\r\n    return result.toString();\r\n}"
}, {
	"Path": "teammates.logic.core.CoursesLogic.deleteCourseCascade",
	"Comment": "permanently deletes a course in recycle bin by its given corresponding id.this will also cascade the data in other databases which are related to this course.",
	"Method": "void deleteCourseCascade(String courseId){\r\n    studentsLogic.deleteStudentsForCourse(courseId);\r\n    instructorsLogic.deleteInstructorsForCourse(courseId);\r\n    feedbackSessionsLogic.deleteFeedbackSessionsForCourseCascade(courseId);\r\n    coursesDb.deleteCourse(courseId);\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.StringUtil.toStringArray",
	"Comment": "converts a delimiter separated string to an array of strings.",
	"Method": "String[] toStringArray(String pString,String pDelimiters,String[] toStringArray,String pString){\r\n    return toStringArray(pString, DELIMITER_STRING);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.editor.page.BasicFormPage.pageInitializationComplete",
	"Comment": "method finalizing the page initializationthis method activates the dirty part listeners",
	"Method": "void pageInitializationComplete(){\r\n    Object[] listeners = dirtyPartListeners.getListeners();\r\n    for (int i = 0; i < listeners.length; ++i) {\r\n        ((IgnoringListener) listeners[i]).setIgnoreInput(false);\r\n    }\r\n    initialized = true;\r\n}"
}, {
	"Path": "tlc2.value.ModelValue.init",
	"Comment": "a method to reset the model valuesall callers should make sure that the model value class has been initialized",
	"Method": "void init(){\r\n    count = 0;\r\n    mvTable = new Hashtable();\r\n    mvs = null;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.selectDropdownByActualValueAndHandleAjaxRequests",
	"Comment": "waits for all ongoing ajax requests to complete if any before selecting the option by actual value, thenwaits for the associated ajax request to complete.",
	"Method": "void selectDropdownByActualValueAndHandleAjaxRequests(WebElement element,String value){\r\n    jQueryAjaxHandler.waitForAjaxIfPresentThenRegisterHandlers();\r\n    if (selectDropdownByActualValue(element, value)) {\r\n        jQueryAjaxHandler.waitForRequestComplete();\r\n    } else {\r\n        jQueryAjaxHandler.unregisterHandlers();\r\n    }\r\n}"
}, {
	"Path": "tla2sany.modanalyzer.ModulePointer.getDirectInnerModules",
	"Comment": "returns vector of names of module pointers for immediate inner modules",
	"Method": "Vector getDirectInnerModules(){\r\n    return moduleRelatives.directInnerModules;\r\n}"
}, {
	"Path": "org.springframework.roo.project.AbstractProjectOperations.getDescriptionOfChange",
	"Comment": "generates a message about the addition of the given items to the pom",
	"Method": "String getDescriptionOfChange(String action,Collection<String> items,String singular,String plural){\r\n    if (items.isEmpty()) {\r\n        return \"\";\r\n    }\r\n    return highlight(action + \" \" + (items.size() == 1 ? singular : plural)) + \" \" + StringUtils.join(items, \", \");\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.launch.TLCModelLaunchDelegate.finalLaunchCheck",
	"Comment": "launch the module parser on the root module and handle the errors4. method called on launch",
	"Method": "boolean finalLaunchCheck(ILaunchConfiguration configuration,String mode,IProgressMonitor monitor){\r\n    monitor.beginTask(\"Verifying model files\", 4);\r\n    final Model model = configuration.getAdapter(Model.class);\r\n    final IFile rootModule = model.getTLAFile();\r\n    monitor.worked(1);\r\n    IParseResult parseResult = ToolboxHandle.parseModule(rootModule, new SubProgressMonitor(monitor, 1), false, false);\r\n    final Vector<TLAMarkerInformationHolder> detectedErrors = parseResult.getDetectedErrors();\r\n    boolean status = !AdapterFactory.isProblemStatus(parseResult.getStatus());\r\n    monitor.worked(1);\r\n    model.removeMarkers(Model.TLC_MODEL_ERROR_MARKER_SANY);\r\n    monitor.worked(1);\r\n    if (!detectedErrors.isEmpty()) {\r\n        TLCActivator.logDebug(\"Errors in model file found \" + rootModule.getLocation());\r\n    }\r\n    FileEditorInput fileEditorInput = new FileEditorInput((IFile) rootModule);\r\n    FileDocumentProvider fileDocumentProvider = new FileDocumentProvider();\r\n    try {\r\n        fileDocumentProvider.connect(fileEditorInput);\r\n        IDocument document = fileDocumentProvider.getDocument(fileEditorInput);\r\n        FindReplaceDocumentAdapter searchAdapter = new FindReplaceDocumentAdapter(document);\r\n        for (int i = 0; i < detectedErrors.size(); i++) {\r\n            TLAMarkerInformationHolder markerHolder = (TLAMarkerInformationHolder) detectedErrors.get(i);\r\n            String message = markerHolder.getMessage();\r\n            if (markerHolder.getModuleName() != null) {\r\n                if (markerHolder.getModuleName().equals(rootModule.getName())) {\r\n                    int severity = markerHolder.getSeverityError();\r\n                    int[] coordinates = markerHolder.getCoordinates();\r\n                    Hashtable<String, Object> props = ModelHelper.createMarkerDescription(document, searchAdapter, message, severity, coordinates);\r\n                    if (props != null) {\r\n                        model.setMarker(props, Model.TLC_MODEL_ERROR_MARKER_SANY);\r\n                    }\r\n                } else {\r\n                    DebugPlugin.getDefault().getLaunchManager().removeLaunch(this.launch);\r\n                    throw new CoreException(new Status(IStatus.ERROR, TLCActivator.PLUGIN_ID, \"Fatal error during validation of the model. \" + \"SANY discovered an error somewhere else than the MC file. \" + \"This is a bug. The error message was \" + message + \" in the module \" + markerHolder.getModuleName()));\r\n                }\r\n            } else {\r\n                DebugPlugin.getDefault().getLaunchManager().removeLaunch(this.launch);\r\n                throw new CoreException(new Status(IStatus.ERROR, TLCActivator.PLUGIN_ID, \"Fatal error during validation of the model. \" + \"SANY discovered an error somewhere else than the MC file. \" + \"This is a bug. The error message was \" + message + \".\"));\r\n            }\r\n        }\r\n    } finally {\r\n        fileDocumentProvider.disconnect(fileEditorInput);\r\n        monitor.done();\r\n    }\r\n    if (MODE_GENERATE.equals(mode)) {\r\n        return false;\r\n    } else {\r\n        return status;\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.getSortedListOfTeams",
	"Comment": "get a sorted list of teams for the feedback session.instructors are not present as a team.",
	"Method": "List<String> getSortedListOfTeams(){\r\n    List<String> teams = new ArrayList(rosterTeamNameMembersTable.keySet());\r\n    teams.remove(Const.USER_TEAM_FOR_INSTRUCTOR);\r\n    teams.sort(null);\r\n    return teams;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.preference.TLCChainedPreferenceStore.handlePropertyChangeEvent",
	"Comment": "handle property change event from the child listener with the given child preference store.",
	"Method": "void handlePropertyChangeEvent(IPreferenceStore childPreferenceStore,PropertyChangeEvent event){\r\n    String property = event.getProperty();\r\n    Object oldValue = event.getOldValue();\r\n    Object newValue = event.getNewValue();\r\n    IPreferenceStore visibleStore = getVisibleStore(property);\r\n    if (visibleStore == null && newValue != null)\r\n        visibleStore = childPreferenceStore;\r\n    if (visibleStore == null) {\r\n        if (oldValue != null)\r\n            firePropertyChangeEvent(event);\r\n    } else if (visibleStore == childPreferenceStore) {\r\n        if (oldValue != null) {\r\n            firePropertyChangeEvent(event);\r\n        } else {\r\n            IPreferenceStore oldVisibleStore = null;\r\n            int i = 0;\r\n            int length = fPreferenceStores.length;\r\n            while (i < length && fPreferenceStores[i++] != visibleStore) {\r\n            }\r\n            while (oldVisibleStore == null && i < length) {\r\n                if (fPreferenceStores[i].contains(property))\r\n                    oldVisibleStore = fPreferenceStores[i];\r\n                i++;\r\n            }\r\n            if (oldVisibleStore == null) {\r\n                firePropertyChangeEvent(event);\r\n            } else {\r\n                oldValue = getOtherValue(property, oldVisibleStore, newValue);\r\n                if (!oldValue.equals(newValue))\r\n                    firePropertyChangeEvent(property, oldValue, newValue);\r\n            }\r\n        }\r\n    } else {\r\n        boolean eventBeforeVisibleStore = false;\r\n        for (int i = 0, length = fPreferenceStores.length; i < length; i++) {\r\n            IPreferenceStore store = fPreferenceStores[i];\r\n            if (store == visibleStore)\r\n                break;\r\n            if (store == childPreferenceStore) {\r\n                eventBeforeVisibleStore = true;\r\n                break;\r\n            }\r\n        }\r\n        if (eventBeforeVisibleStore) {\r\n            newValue = getOtherValue(property, visibleStore, oldValue);\r\n            if (!newValue.equals(oldValue))\r\n                firePropertyChangeEvent(property, oldValue, newValue);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "tla2sany.semantic.Errors.getAborts",
	"Comment": "the following methods to return the warnings, errors, and aborts in a sane way were added by ll on 12 may 2008.",
	"Method": "String[] getAborts(){\r\n    return StringVectortoStringArray(aborts);\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.isFeedbackSessionForStudentsToAnswer",
	"Comment": "returns true if there are any questions for students to answer.",
	"Method": "boolean isFeedbackSessionForStudentsToAnswer(FeedbackSessionAttributes session){\r\n    List<FeedbackQuestionAttributes> questionsToAnswer = fqLogic.getFeedbackQuestionsForStudents(session.getFeedbackSessionName(), session.getCourseId());\r\n    return session.isVisible() && !questionsToAnswer.isEmpty();\r\n}"
}, {
	"Path": "tlc2.tool.liveness.TBPar.impliedSuccessors",
	"Comment": "this method returns a list of implied successors of a given particle.",
	"Method": "TBPar impliedSuccessors(){\r\n    TBPar successors = new TBPar(this.size());\r\n    for (int i = 0; i < this.size(); i++) {\r\n        LiveExprNode ln = this.exprAt(i);\r\n        if (ln instanceof LNNext) {\r\n            successors.addElement(((LNNext) ln).getBody());\r\n        }\r\n    }\r\n    return successors;\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.CollectionUtils.isEmpty",
	"Comment": "return true if the supplied map is null orempty. otherwise, return false.",
	"Method": "boolean isEmpty(Collection<?> collection,boolean isEmpty,Map<?, ?> map){\r\n    return map == null || map.isEmpty();\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.DomUtils.getChildElementValueByTagName",
	"Comment": "returns the first child element value identified by its name.",
	"Method": "String getChildElementValueByTagName(Element element,String childElementName){\r\n    final Element child = getChildElementByTagName(element, childElementName);\r\n    return child != null ? getTextValue(child) : null;\r\n}"
}, {
	"Path": "org.springframework.roo.metadata.MetadataIdentificationUtils.isIdentifyingClass",
	"Comment": "indicates whether the argument appears to represent a particular metadataidentification class. this method returns false if a particular instanceis identified.",
	"Method": "boolean isIdentifyingClass(String metadataIdentificationString){\r\n    return isValid(metadataIdentificationString) && !metadataIdentificationString.contains(INSTANCE_DELIMITER);\r\n}"
}, {
	"Path": "tlc2.tool.liveness.LiveCheck1.extractComponent",
	"Comment": "returns the set of nodes in a nontrivial component. returns null for a\ttrivial one. it also assigns a new number to all the nodes in the\tcomponent.",
	"Method": "Vect extractComponent(BEGraphNode node){\r\n    BEGraphNode node1 = (BEGraphNode) comStack.pop();\r\n    if (node == node1 && !node.transExists(node)) {\r\n        node.setNumber(MAX_FIRST);\r\n        return null;\r\n    }\r\n    Vect nodes = new Vect();\r\n    numFirstCom = secondNum++;\r\n    numSecondCom = thirdNum;\r\n    node1.setNumber(numFirstCom);\r\n    nodes.addElement(node1);\r\n    while (node != node1) {\r\n        node1 = (BEGraphNode) comStack.pop();\r\n        node1.setNumber(numFirstCom);\r\n        nodes.addElement(node1);\r\n    }\r\n    return nodes;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.TLAColorProvider.dispose",
	"Comment": "release all of the color resources held onto by the receiver.",
	"Method": "void dispose(){\r\n    Iterator e = fColorTable.values().iterator();\r\n    while (e.hasNext()) ((Color) e.next()).dispose();\r\n}"
}, {
	"Path": "teammates.test.driver.HtmlHelper.replaceUnpredictableValuesWithPlaceholders",
	"Comment": "substitutes values that are different across various test runs with placeholders.these values are identified using their known, unique formats.",
	"Method": "String replaceUnpredictableValuesWithPlaceholders(String content){\r\n    LocalDate today = LocalDate.now();\r\n    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"EEE, dd MMM yyyy, \");\r\n    String dateToday = formatter.format(today);\r\n    String dateYesterday = formatter.format(today.minusDays(1));\r\n    String dateTomorrow = formatter.format(today.plusDays(1));\r\n    String dateTodayInIso8601 = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'\").format(today);\r\n    String dateTodayInCoursesPageFormat = DateTimeFormatter.ofPattern(\"d MMM yyyy\").format(today);\r\n    return // logout URL generated by Google\r\n    content.replace(\"\\\"\" + TestProperties.TEAMMATES_URL + \"/_ah\", \"\\\"/_ah\").replaceAll(\"_ah/logout\\\\?continue=\" + REGEX_CONTINUE_URL + \"\\\"\", // student profile picture link\r\n    \"_ah/logout?continue=\\\\${continue\\\\.url}\\\"\").replaceAll(Const.ActionURIs.STUDENT_PROFILE_PICTURE + \"\\\\?\" + Const.ParamsNames.STUDENT_EMAIL + \"=\" + REGEX_ENCRYPTED_STUDENT_EMAIL + \"\\\\&amp;\" + Const.ParamsNames.COURSE_ID + \"=\" + REGEX_ENCRYPTED_COURSE_ID, // blob-key in student profile page\r\n    Const.ActionURIs.STUDENT_PROFILE_PICTURE + \"\\\\?\" + Const.ParamsNames.STUDENT_EMAIL + \"=\\\\${student\\\\.email\\\\.enc}\" + \"\\\\&amp;\" + Const.ParamsNames.COURSE_ID + \"=\\\\${course\\\\.id\\\\.enc}\").replaceAll(Const.ActionURIs.STUDENT_PROFILE_PICTURE + \"\\\\?\" + Const.ParamsNames.BLOB_KEY + \"=\" + REGEX_BLOB_KEY, Const.ActionURIs.STUDENT_PROFILE_PICTURE + \"\\\\?\" + Const.ParamsNames.BLOB_KEY + \"=\\\\${blobkey}\").replaceAll(\"( type=\\\"hidden\\\"|\" + \" name=\\\"\" + Const.ParamsNames.BLOB_KEY + \"\\\"|\" + \" id=\\\"blobKey\\\"|\" + \" value=\\\"\" + REGEX_BLOB_KEY + \"\\\"){4}\", // regkey in URLs\r\n    \" id=\\\"blobKey\\\" name=\\\"\" + Const.ParamsNames.BLOB_KEY + \"\\\"\" + \" type=\\\"hidden\\\" value=\\\"\\\\${blobkey}\\\"\").replaceAll(Const.ParamsNames.REGKEY + \"=\" + REGEX_ENCRYPTED_REGKEY, // regkey in unreg student page\r\n    Const.ParamsNames.REGKEY + \"=\\\\${regkey\\\\.enc}\").replaceAll(\"( type=\\\"hidden\\\"|\" + \" name=\\\"\" + Const.ParamsNames.REGKEY + \"\\\"|\" + \" value=\\\"\" + REGEX_ENCRYPTED_REGKEY + \"\\\"){3}\", // anonymous student identifier on results page\r\n    \" name=\\\"\" + Const.ParamsNames.REGKEY + \"\\\"\" + \" type=\\\"hidden\\\" value=\\\"\\\\${regkey\\\\.enc}\\\"\").replaceAll(Const.DISPLAYED_NAME_FOR_ANONYMOUS_PARTICIPANT + \" (student|instructor|team) \" + REGEX_ANONYMOUS_PARTICIPANT_HASH, // sessionToken in form inputs\r\n    Const.DISPLAYED_NAME_FOR_ANONYMOUS_PARTICIPANT + \" $1 \\\\${participant\\\\.hash}\").replaceAll(\"( type=\\\"hidden\\\"|\" + \" name=\\\"\" + Const.ParamsNames.SESSION_TOKEN + \"\\\"|\" + \" value=\\\"\" + REGEX_SESSION_TOKEN + \"\\\"){3}\", // questionid as value\r\n    \" name=\\\"\" + Const.ParamsNames.SESSION_TOKEN + \"\\\"\" + \" type=\\\"hidden\\\" value=\\\"\\\\${sessionToken}\\\"\").replaceAll(\"value=\\\"\" + REGEX_QUESTION_ID + \"\\\"\", // questionid as part of responseid\r\n    \"value=\\\"\\\\${question\\\\.id}\\\"\").replaceAll(\"\\\"\" + REGEX_QUESTION_ID + \"%\", // commentid in quotes, used as values\r\n    \"\\\"\\\\${question\\\\.id}%\").replaceAll(\"\\\"\" + REGEX_COMMENT_ID + \"\\\"\", // commentid in URLs\r\n    \"\\\"\\\\${comment\\\\.id}\\\"\").replaceAll(\"#\" + REGEX_COMMENT_ID, // commentid as part of div ids\r\n    \"#\\\\${comment\\\\.id}\").replaceAll(\"responseCommentRow-\" + REGEX_COMMENT_ID, \"responseCommentRow-\\\\${comment\\\\.id}\").replaceAll(\"commentBar-\" + REGEX_COMMENT_ID, \"commentBar-\\\\${comment\\\\.id}\").replaceAll(\"plainCommentText-\" + REGEX_COMMENT_ID, // account for time zone differences by accepting dates within one day from now\r\n    \"plainCommentText-\\\\${comment\\\\.id}\").replaceAll(\"(\" + dateToday + \"|\" + dateYesterday + \"|\" + dateTomorrow + \")\" + REGEX_DISPLAY_TIME, \"\\\\${datetime\\\\.now}\").replaceAll(dateTodayInIso8601 + REGEX_DISPLAY_TIME_ISO_8601_UTC, \"\\\\${datetime\\\\.now\\\\.iso8601utc}\").replaceAll(dateTodayInCoursesPageFormat, // admin footer, test institute section\r\n    \"\\\\${datetime\\\\.now\\\\.courses}\").replaceAll(\"(?s)<div( class=\\\"col-md-8\\\"| id=\\\"adminInstitute\\\"){2}>\" + REGEX_ADMIN_INSTITUTE_FOOTER + \"<\/div>\", // sessionToken in URL parameters\r\n    \"\\\\${admin\\\\.institute}\").replaceAll(\"(\\\\&amp;|\\\\?)\" + Const.ParamsNames.SESSION_TOKEN + \"=\" + REGEX_SESSION_TOKEN, // TODO check if this is necessary\r\n    \"$1\" + Const.ParamsNames.SESSION_TOKEN + \"=\\\\${sessionToken}\").replace(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\", // TODO check if wildcarding this is better; better yet, check if not removing at all works\r\n    \"<html>\").replaceFirst(\"(?s)<noscript>.*<\/noscript>\", \"\");\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.isElementPresent",
	"Comment": "returns true if there is a corresponding element for the given id or name.",
	"Method": "boolean isElementPresent(By by,boolean isElementPresent,String elementId){\r\n    try {\r\n        browser.driver.findElement(By.id(elementId));\r\n        return true;\r\n    } catch (NoSuchElementException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.RooWsClientsAnnotationValues.getEndpoints",
	"Comment": "returns the endpoints that manages this configuration class",
	"Method": "RooWsClient[] getEndpoints(){\r\n    return endpoints;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackConstantSumQuestionDetails.updateOptionPointsMapping",
	"Comment": "used to update the optionpointsmapping for the option optionreceivingpoints.",
	"Method": "void updateOptionPointsMapping(Map<String, List<Integer>> optionPoints,String optionReceivingPoints,int pointsReceived){\r\n    List<Integer> points = optionPoints.get(optionReceivingPoints);\r\n    if (points == null) {\r\n        points = new ArrayList();\r\n        optionPoints.put(optionReceivingPoints, points);\r\n    }\r\n    points.add(pointsReceived);\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.waitForElementPresence",
	"Comment": "waits for the element to appear in the page, up to the timeout specified.",
	"Method": "WebElement waitForElementPresence(By by){\r\n    return waitFor(ExpectedConditions.presenceOfElementLocated(by));\r\n}"
}, {
	"Path": "tlc2.tool.distributed.TLCServer.printSummary",
	"Comment": "this allows the toolbox to easily display the last setof state space statistics by putting them in the sameform as all other progress statistics.",
	"Method": "void printSummary(int level,long statesGenerated,long statesLeftInQueue,long distinctStates,boolean success){\r\n    if (TLCGlobals.tool) {\r\n        MP.printMessage(EC.TLC_PROGRESS_STATS, new String[] { String.valueOf(level), String.valueOf(statesGenerated), String.valueOf(distinctStates), String.valueOf(statesLeftInQueue), \"0\", \"0\" });\r\n    }\r\n    MP.printMessage(EC.TLC_STATS, new String[] { String.valueOf(statesGenerated), String.valueOf(distinctStates), String.valueOf(statesLeftInQueue) });\r\n    if (success) {\r\n        MP.printMessage(EC.TLC_SEARCH_DEPTH, String.valueOf(level));\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.job.ProverJob.getLastJob",
	"Comment": "returns the most prover job that led to the mostrecent launch of the prover.",
	"Method": "ProverJob getLastJob(){\r\n    return lastJob;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.ExecuteNextCommandHandler.verifyKey",
	"Comment": "listens for the first key to be pressed. if it is a digit, itfinds the word currently containing the caret and repeats that wordthe number of times equal to the digit pressed. if the key pressedis not a digit, this does nothing to the document andremoves itself from subsequent key events.",
	"Method": "void verifyKey(VerifyEvent event){\r\n    try {\r\n        event.doit = false;\r\n        System.out.println(\"Heard keystroke.\");\r\n        IBindingService ibindingService = (IBindingService) UIHelper.getActivePage().getActivePart().getSite().getService(IBindingService.class);\r\n        KeyStroke keyStroke = SWTKeySupport.convertAcceleratorToKeyStroke(SWTKeySupport.convertEventToUnmodifiedAccelerator(event));\r\n        Binding binding = ibindingService.getPerfectMatch(KeySequence.getInstance(keyStroke));\r\n        ParameterizedCommand pcommand = binding.getParameterizedCommand();\r\n        IHandlerService ihandlerService = (IHandlerService) UIHelper.getActivePage().getActivePart().getSite().getService(IHandlerService.class);\r\n        ihandlerService.executeCommand(pcommand, null);\r\n    } catch (ExecutionException e) {\r\n        e.printStackTrace();\r\n    } catch (NotDefinedException e) {\r\n        e.printStackTrace();\r\n    } catch (NotEnabledException e) {\r\n        e.printStackTrace();\r\n    } catch (NotHandledException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        uninstall();\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.io.LittleEndianDataOutputStream.writeDouble",
	"Comment": "writes an 8 byte java double to the underlying output stream inlittle endian order.",
	"Method": "void writeDouble(double d){\r\n    writeLong(Double.doubleToLongBits(d));\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.StudentAttributes.isTeamChanged",
	"Comment": "returns true if team value has changed from its original value.",
	"Method": "boolean isTeamChanged(StudentAttributes originalStudentAttribute){\r\n    return this.team != null && !this.team.equals(originalStudentAttribute.team);\r\n}"
}, {
	"Path": "tlc2.tool.Tool.getState",
	"Comment": "reconstruct the next state of state s whose fingerprint is fp.",
	"Method": "TLCStateInfo getState(long fp,TLCStateInfo getState,long fp,TLCStateInfo sinfo,TLCStateInfo getState,long fp,TLCState s,TLCStateInfo getState,TLCState s1,TLCState s){\r\n    IdThread.setCurrentState(s);\r\n    for (int i = 0; i < this.actions.length; i++) {\r\n        Action curAction = this.actions[i];\r\n        StateVec nextStates = this.getNextStates(curAction, s);\r\n        for (int j = 0; j < nextStates.size(); j++) {\r\n            TLCState state = nextStates.elementAt(j);\r\n            if (s1.equals(state)) {\r\n                return new TLCStateInfo(state, curAction.getLocation());\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "teammates.ui.pagedata.StudentHomePageData.getStudentFeedbackSessionActions",
	"Comment": "returns the list of available actions for a specific feedback session.",
	"Method": "StudentFeedbackSessionActions getStudentFeedbackSessionActions(FeedbackSessionAttributes fs,boolean hasSubmitted){\r\n    String resultsLink = getStudentFeedbackResultsLink(fs.getCourseId(), fs.getFeedbackSessionName());\r\n    String responseEditLink = getStudentFeedbackSubmissionEditLink(fs.getCourseId(), fs.getFeedbackSessionName());\r\n    return new StudentFeedbackSessionActions(fs, resultsLink, responseEditLink, hasSubmitted);\r\n}"
}, {
	"Path": "tla2sany.semantic.SubstInNode.getSubFor",
	"Comment": "returns the opdeclnode of the ith element of the substitutionlist.",
	"Method": "OpDeclNode getSubFor(int i){\r\n    return this.substs[i].getOp();\r\n}"
}, {
	"Path": "org.squirrelframework.foundation.util.ReflectUtils.getField",
	"Comment": "searches for the field in the given class and in its super classes",
	"Method": "Field getField(Class<?> clazz,String fieldName,Field getField,Class<?> clazz,String fieldName,Class<?> original){\r\n    Field field = null;\r\n    try {\r\n        field = clazz.getDeclaredField(fieldName);\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(\"found field \" + fieldName + \" in \" + getClassNameSafe(clazz));\r\n        }\r\n    } catch (SecurityException e) {\r\n        throw new SquirrelRuntimeException(e, ErrorCodes.NOT_ALLOW_ACCESS_FIELD, getClassNameSafe(clazz), fieldName);\r\n    } catch (NoSuchFieldException e) {\r\n        if (clazz.getSuperclass() != null) {\r\n            return getField(clazz.getSuperclass(), fieldName, original);\r\n        } else {\r\n            throw new SquirrelRuntimeException(e, ErrorCodes.FIELD_NOT_FOUND, original.getName(), fieldName);\r\n        }\r\n    }\r\n    return field;\r\n}"
}, {
	"Path": "tla2tex.TokenizeSpec.getNextTokenPosition",
	"Comment": "returns the position in the final output of the nexttoken to be output.",
	"Method": "Position getNextTokenPosition(){\r\n    return new Position(vspec.size(), linev.size());\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorFeedbackResultsPageData.buildTeamsStatisticsTableForSectionPanel",
	"Comment": "constructs instructorfeedbackresultsquestiontable containing statistics for each team.the statistics tables are added to the sectionpanel.",
	"Method": "void buildTeamsStatisticsTableForSectionPanel(InstructorFeedbackResultsSectionPanel sectionPanel,Map<String, Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>> responsesGroupedByTeam,Set<String> teamsInSection){\r\n    Map<String, List<InstructorFeedbackResultsQuestionTable>> teamToStatisticsTables = new HashMap();\r\n    for (String team : teamsInSection) {\r\n        if (!responsesGroupedByTeam.containsKey(team) || !isTeamVisible(team)) {\r\n            continue;\r\n        }\r\n        List<InstructorFeedbackResultsQuestionTable> statisticsTablesForTeam = new ArrayList();\r\n        for (FeedbackQuestionAttributes question : bundle.questions.values()) {\r\n            if (!responsesGroupedByTeam.get(team).containsKey(question)) {\r\n                continue;\r\n            }\r\n            List<FeedbackResponseAttributes> responsesForTeamAndQuestion = responsesGroupedByTeam.get(team).get(question);\r\n            InstructorFeedbackResultsQuestionTable statsTable = buildQuestionTableWithoutResponseRows(question, responsesForTeamAndQuestion, \"\");\r\n            statsTable.setCollapsible(false);\r\n            if (!statsTable.getQuestionStatisticsTable().isEmpty()) {\r\n                statisticsTablesForTeam.add(statsTable);\r\n            }\r\n        }\r\n        InstructorFeedbackResultsQuestionTable.sortByQuestionNumber(statisticsTablesForTeam);\r\n        teamToStatisticsTables.put(team, statisticsTablesForTeam);\r\n    }\r\n    sectionPanel.setTeamStatisticsTable(teamToStatisticsTables);\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.convert.DateConverter.toObject",
	"Comment": "converts the string to a date, using the given format for parsing.",
	"Method": "Object toObject(String pString,Class pType,String pFormat){\r\n    if (StringUtil.isEmpty(pString))\r\n        return null;\r\n    try {\r\n        DateFormat format;\r\n        if (pFormat == null) {\r\n            format = DateFormat.getDateTimeInstance();\r\n        } else {\r\n            format = getDateFormat(pFormat);\r\n        }\r\n        Date date = StringUtil.toDate(pString, format);\r\n        if (pType != Date.class) {\r\n            try {\r\n                date = (Date) BeanUtil.createInstance(pType, new Long(date.getTime()));\r\n            } catch (ClassCastException e) {\r\n                throw new TypeMismathException(pType);\r\n            } catch (InvocationTargetException e) {\r\n                throw new ConversionException(e);\r\n            }\r\n        }\r\n        return date;\r\n    } catch (RuntimeException rte) {\r\n        throw new ConversionException(rte);\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackContributionQuestionDetails.getStudentResults",
	"Comment": "returns a map with student email as key and studentresultsummary as value for the specified question.",
	"Method": "Map<String, StudentResultSummary> getStudentResults(FeedbackSessionResultsBundle bundle,FeedbackQuestionAttributes question,Map<String, StudentResultSummary> getStudentResults,Map<String, List<String>> teamMembersEmail,Map<String, TeamEvalResult> teamResults){\r\n    Map<String, StudentResultSummary> studentResults = new LinkedHashMap();\r\n    teamResults.forEach((key, teamResult) -> {\r\n        List<String> teamEmails = teamMembersEmail.get(key);\r\n        int i = 0;\r\n        for (String studentEmail : teamEmails) {\r\n            StudentResultSummary summary = new StudentResultSummary();\r\n            summary.claimedToInstructor = teamResult.normalizedClaimed[i][i];\r\n            summary.perceivedToInstructor = teamResult.normalizedAveragePerceived[i];\r\n            studentResults.put(studentEmail, summary);\r\n            i++;\r\n        }\r\n    });\r\n    return studentResults;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.scrollElementToFirstCellAndSendKeys",
	"Comment": "scrolls element to first cell in spreadsheet, clicks on it and sends the value as keystrokes.",
	"Method": "void scrollElementToFirstCellAndSendKeys(WebElement spreadsheetElement,String value){\r\n    new Actions(browser.driver).moveToElement(spreadsheetElement).click().sendKeys(value).build().perform();\r\n}"
}, {
	"Path": "tlc2.tool.distributed.selector.LimitingBlockSelector.getBlockSize",
	"Comment": "limits the block size to a defined maximum if the dynamically calculated\tblock size exceeds it",
	"Method": "long getBlockSize(long size,TLCWorkerRMI aWorker){\r\n    final long blockSize = super.getBlockSize(size, aWorker);\r\n    if (blockSize > maximum) {\r\n        return maximum;\r\n    }\r\n    return blockSize;\r\n}"
}, {
	"Path": "tlc2.tool.queue.DiskStateQueueTest.testGrowBeyondIntMaxValue",
	"Comment": "reuse the same state to speed up instantiation and space requirements",
	"Method": "void testGrowBeyondIntMaxValue(){\r\n    final TLCState state = new DummyTLCState();\r\n    final long j = Integer.MAX_VALUE + 1L;\r\n    for (long i = 0; i < j; i++) {\r\n        sQueue.sEnqueue(state);\r\n    }\r\n    assertTrue(sQueue.size() == j);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.preference.ProverPreferencePage.getLeafSideBarPrefName",
	"Comment": "returns the preference name for the boolean preferenceof showing leaf markers in the side bar. that is, if selectedwhenever the physical color corresponding to colornum is shownin the editor on a leaf step, it will appear in the side bar as well.this is the name used to store the preference in the preference store.",
	"Method": "String getLeafSideBarPrefName(int colorNum){\r\n    return STEP_STATUS_OVERVIEW + colorNum + \"B\";\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.itd.InvocableMemberBodyBuilder.appendFormalLine",
	"Comment": "prints the message formatted with values, after adding indents and returns to a new line. thisis the most commonly used method.",
	"Method": "InvocableMemberBodyBuilder appendFormalLine(String message,InvocableMemberBodyBuilder appendFormalLine,String message,Object values){\r\n    appendIndent();\r\n    if (message != null && !\"\".equals(message)) {\r\n        stringBuilder.append(String.format(message, values));\r\n    }\r\n    return newLine(false);\r\n}"
}, {
	"Path": "util.BufferedDataOutputStream.close",
	"Comment": "closes this stream and its underlying stream, after firstflushing any buffered data.",
	"Method": "void close(){\r\n    this.flush();\r\n    this.out.close();\r\n    this.out = null;\r\n}"
}, {
	"Path": "com.facebook.swift.service.ThriftServerConfig.setTaskExpirationTimeout",
	"Comment": "sets a timeout period between receiving a request and the completion of that request. ifthe timeout expires before the request reaches the front of the queue and begins processing,the server will discard the request instead of processing it. if the timeout expires afterthe request has started processing, the server will send an error immediately, and discardthe result of request handling.",
	"Method": "ThriftServerConfig setTaskExpirationTimeout(Duration taskExpirationTimeout){\r\n    this.taskExpirationTimeout = taskExpirationTimeout;\r\n    return this;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackResultsPage.loadResultQuestionPanel",
	"Comment": "expands a particular question panel, causing its results to load.",
	"Method": "void loadResultQuestionPanel(int questionNumber){\r\n    String panelId = \"panelHeading-\" + questionNumber;\r\n    clickPanelAndWaitForExpansion(panelId);\r\n}"
}, {
	"Path": "pcal.TLAtoPCalMapping.PrevLocOf",
	"Comment": "returns the position within map of the previous object after the one withposition loc.it returns null if there is no previousobject in map.",
	"Method": "PCalLocation PrevLocOf(PCalLocation loc,MappingObject[][] map){\r\n    if (loc.getColumn() > 0) {\r\n        return new PCalLocation(loc.getLine(), loc.getColumn() - 1);\r\n    }\r\n    for (int i = loc.getLine() - 1; i >= 0; i--) {\r\n        if (map[i].length > 0) {\r\n            return new PCalLocation(i, map[i].length - 1);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "pcal.PcalSymTab.FindSym",
	"Comment": "returns first it finds with id and context, no matterwhat type it is.",
	"Method": "int FindSym(int type,String id,String context,int FindSym,String id,String context){\r\n    int i = 0;\r\n    while (i < symtab.size()) {\r\n        SymTabEntry se = (SymTabEntry) symtab.elementAt(i);\r\n        if (se.id.equals(id) && se.context.equals(context))\r\n            return i;\r\n        i = i + 1;\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "tlc2.tool.TLCState.getVals",
	"Comment": "returns a mapping of variable names to their assigned values in this state.",
	"Method": "Map<UniqueString, Value> getVals(){\r\n    final Map<UniqueString, Value> valMap = new HashMap<UniqueString, Value>();\r\n    for (int i = 0; i < vars.length; i++) {\r\n        UniqueString key = vars[i].getName();\r\n        Value val = this.lookup(key);\r\n        valMap.put(key, val);\r\n    }\r\n    return valMap;\r\n}"
}, {
	"Path": "tlc2.tool.distributed.fp.DynamicFPSetManagerTest.testCtor10",
	"Comment": "test that the ctor correctly calculates its mask used to index fpset\tservers for valid values.",
	"Method": "void testCtor10(){\r\n    DynamicFPSetManager dynamicFPSetManager = new DynamicFPSetManager(10);\r\n    long mask = dynamicFPSetManager.getMask();\r\n    assertEquals(15L, mask);\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.PhysicalTypeIdentifierNamingUtils.getModuleFromIdentificationString",
	"Comment": "extracts module name from a metadata identification string",
	"Method": "String getModuleFromIdentificationString(String metadataId){\r\n    return StringUtils.defaultString(StringUtils.substringBetween(metadataId, \"#\", \":\"), \"\");\r\n}"
}, {
	"Path": "tlc2.tool.DFIDModelChecker.checkAssumptions",
	"Comment": "check the assumptions.this code is a clone of the same method in modelchecker",
	"Method": "boolean checkAssumptions(){\r\n    ExprNode[] assumps = this.tool.getAssumptions();\r\n    boolean[] isAxiom = this.tool.getAssumptionIsAxiom();\r\n    for (int i = 0; i < assumps.length; i++) {\r\n        try {\r\n            if ((!isAxiom[i]) && !this.tool.isValid(assumps[i])) {\r\n                MP.printError(EC.TLC_ASSUMPTION_FALSE, assumps[i].toString());\r\n                return false;\r\n            }\r\n        } catch (Exception e) {\r\n            MP.printError(EC.TLC_ASSUMPTION_EVALUATION_ERROR, new String[] { assumps[i].toString(), e.getMessage() });\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.roo.support.osgi.OSGiUtils.execute",
	"Comment": "executes the given callback on any bundles in the given context",
	"Method": "void execute(BundleCallback callback,BundleContext context){\r\n    if (callback == null || context == null) {\r\n        return;\r\n    }\r\n    final Bundle[] bundles = context.getBundles();\r\n    if (bundles == null) {\r\n        return;\r\n    }\r\n    for (final Bundle bundle : bundles) {\r\n        callback.execute(bundle);\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.isEmailOfPerson",
	"Comment": "returns true if the given identifier is an email of a person in the course.returns false otherwise.",
	"Method": "boolean isEmailOfPerson(String participantIdentifier){\r\n    boolean isIdentifierEmail = participantIdentifier.contains(\"@\");\r\n    String name = emailNameTable.get(participantIdentifier);\r\n    boolean isIdentifierName = name != null && name.equals(participantIdentifier);\r\n    boolean isIdentifierTeam = name != null && name.equals(Const.USER_IS_TEAM);\r\n    String teamName = emailTeamNameTable.get(participantIdentifier);\r\n    boolean isIdentifierTeamName = teamName != null && teamName.equals(participantIdentifier);\r\n    return isIdentifierEmail && !(isIdentifierName || isIdentifierTeamName || isIdentifierTeam);\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.plugins.jpeg.JPEGImageReaderTest.testReadSubsamplingBounds1028",
	"Comment": "this might change in the future. if so, the tests will no longer test what tey are supposed to....",
	"Method": "void testReadSubsamplingBounds1028(){\r\n    JPEGImageReader reader = createReader();\r\n    reader.setInput(ImageIO.createImageInputStream(getClassLoaderResource(\"/jpeg/read-error1028.jpg\")));\r\n    ImageReadParam param = reader.getDefaultReadParam();\r\n    param.setSourceSubsampling(3, 3, 1, 1);\r\n    BufferedImage image = reader.read(0, param);\r\n    assertNotNull(image);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.FeedbackResponseAttributes.setResponseDetails",
	"Comment": "converts the given feedbackresponsedetails object to json for storing.",
	"Method": "void setResponseDetails(FeedbackResponseDetails responseDetails){\r\n    if (responseDetails == null) {\r\n        responseMetaData = \"\";\r\n    } else if (responseDetails.questionType == FeedbackQuestionType.TEXT) {\r\n        responseMetaData = responseDetails.getAnswerString();\r\n    } else {\r\n        responseMetaData = JsonUtils.toJson(responseDetails, getFeedbackResponseDetailsClass());\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.io.LittleEndianRandomAccessFile.writeFloat",
	"Comment": "writes a 4 byte java float to the underlying output stream inlittle endian order.",
	"Method": "void writeFloat(float f){\r\n    writeInt(Float.floatToIntBits(f));\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.TLAEditorAndPDFViewer.getPDFViewingPage",
	"Comment": "creates the pdfviewinpage and adds it to the editor if it does not exist.returns the pdfviewing page whether it previously existed or not.",
	"Method": "PDFViewingPage getPDFViewingPage(){\r\n    if (pdfViewingPage == null) {\r\n        pdfViewingPage = new PDFViewingPage(this, PDFPage_ID, \"PDF Viewer\");\r\n        try {\r\n            addPage(pdfViewingPage);\r\n        } catch (PartInitException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    return pdfViewingPage;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AdminEmailPage.inputGroupRecipient",
	"Comment": "makes the groupreceiverlistuploadbox visible, uploads file and makes it invisible again.",
	"Method": "void inputGroupRecipient(String fileName){\r\n    executeScript(\"arguments[0].style.display = 'inline'\", groupReceiverListUploadBox);\r\n    File file = new File(TestProperties.TEST_EMAILS_FOLDER + File.separator + fileName);\r\n    inputFieldForGroupList.sendKeys(file.getAbsolutePath());\r\n    executeScript(\"arguments[0].style.display = 'none'\", groupReceiverListUploadBox);\r\n    waitForAjaxLoaderGifToDisappear();\r\n}"
}, {
	"Path": "teammates.storage.search.SearchManager.putDocumentWithRetry",
	"Comment": "tries putting a document, handling transient errors by retrying with exponential backoff.",
	"Method": "void putDocumentWithRetry(String indexName,Document document){\r\n    Index index = getIndex(indexName);\r\n    RM.runUntilSuccessful(new RetryableTaskThrows<PutException>(\"Put document\") {\r\n        private OperationResult lastResult;\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                PutResponse response = index.put(document);\r\n                lastResult = response.getResults().get(0);\r\n            } catch (PutException e) {\r\n                lastResult = e.getOperationResult();\r\n            }\r\n        }\r\n        @Override\r\n        public boolean isSuccessful() throws PutException {\r\n            finalMessage = lastResult.getMessage();\r\n            if (StatusCode.OK.equals(lastResult.getCode())) {\r\n                return true;\r\n            } else if (StatusCode.TRANSIENT_ERROR.equals(lastResult.getCode())) {\r\n                return false;\r\n            } else {\r\n                throw new PutException(lastResult);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "teammates.storage.search.SearchManager.putDocumentWithRetry",
	"Comment": "tries putting a document, handling transient errors by retrying with exponential backoff.",
	"Method": "void putDocumentWithRetry(String indexName,Document document){\r\n    try {\r\n        PutResponse response = index.put(document);\r\n        lastResult = response.getResults().get(0);\r\n    } catch (PutException e) {\r\n        lastResult = e.getOperationResult();\r\n    }\r\n}"
}, {
	"Path": "teammates.storage.search.SearchManager.putDocumentWithRetry",
	"Comment": "tries putting a document, handling transient errors by retrying with exponential backoff.",
	"Method": "void putDocumentWithRetry(String indexName,Document document){\r\n    finalMessage = lastResult.getMessage();\r\n    if (StatusCode.OK.equals(lastResult.getCode())) {\r\n        return true;\r\n    } else if (StatusCode.TRANSIENT_ERROR.equals(lastResult.getCode())) {\r\n        return false;\r\n    } else {\r\n        throw new PutException(lastResult);\r\n    }\r\n}"
}, {
	"Path": "teammates.common.util.FieldValidator.getInvalidityInfoForTimeForVisibilityStartAndSessionStart",
	"Comment": "checks if session visibility start time is before session start time.",
	"Method": "String getInvalidityInfoForTimeForVisibilityStartAndSessionStart(Instant visibilityStart,Instant sessionStart){\r\n    return getInvalidityInfoForFirstTimeIsBeforeSecondTime(visibilityStart, sessionStart, SESSION_VISIBLE_TIME_FIELD_NAME, SESSION_START_TIME_FIELD_NAME);\r\n}"
}, {
	"Path": "com.twelvemonkeys.image.DiffusionDither.getBounds2D",
	"Comment": "returns the bounding box of the filtered destination raster.sincethis is not a geometric operation, the bounding box does notchange.",
	"Method": "Rectangle2D getBounds2D(BufferedImage pSrc,Rectangle2D getBounds2D,Raster pSrc){\r\n    return pSrc.getBounds();\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.defineReadBridgeMethod",
	"Comment": "defines the generics bridge method with untyped args to the type specific read method.",
	"Method": "void defineReadBridgeMethod(){\r\n    classDefinition.addMethod(new MethodDefinition(a(PUBLIC, BRIDGE, SYNTHETIC), \"read\", type(Object.class), arg(\"protocol\", TProtocol.class)).addException(Exception.class).loadThis().loadVariable(\"protocol\").invokeVirtual(codecType, \"read\", structType, type(TProtocol.class)).retObject());\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.spec.SpecTest.testCreateDeleteSpecForget",
	"Comment": "verify that specs and the their corresponding project are deleted correctly with forget.",
	"Method": "void testCreateDeleteSpecForget(){\r\n    createDelete(\"TestCreateDeleteSpecForget\", true);\r\n}"
}, {
	"Path": "pcal.trans.exitWithStatus",
	"Comment": "if run in the system mode, exits the program, in tool mode returns the status",
	"Method": "int exitWithStatus(int status){\r\n    if (ToolIO.getMode() == ToolIO.SYSTEM) {\r\n        System.exit(status);\r\n    }\r\n    return status;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.util.DocumentHelper.getRegionExpandedBackwards",
	"Comment": "at a given position in text retrieves the region marking the word, starting before and ending on current position",
	"Method": "IRegion getRegionExpandedBackwards(IDocument document,int documentOffset,IWordDetector detector){\r\n    int charCounter = 0;\r\n    while (true) {\r\n        try {\r\n            char c = document.getChar(--documentOffset);\r\n            if (!detector.isWordPart(c))\r\n                break;\r\n            charCounter++;\r\n        } catch (BadLocationException e) {\r\n            break;\r\n        }\r\n    }\r\n    return new Region(documentOffset + 1, charCounter);\r\n}"
}, {
	"Path": "tla2sany.semantic.TheoremNode.levelDataToString",
	"Comment": "tostring, leveldatatostring, and walkgraph methods to implementexplorenode interface",
	"Method": "String levelDataToString(){\r\n    return \"Level: \" + this.getLevel() + \"\\n\" + \"LevelParameters: \" + this.getLevelParams() + \"\\n\" + \"LevelConstraints: \" + this.getLevelConstraints() + \"\\n\" + \"ArgLevelConstraints: \" + this.getArgLevelConstraints() + \"\\n\" + \"ArgLevelParams: \" + this.getArgLevelParams() + \"\\n\";\r\n}"
}, {
	"Path": "util.BufferedDataOutputStream.writeString",
	"Comment": "write the characters of the string s to thisstream as a sequence of bytes.",
	"Method": "void writeString(String s){\r\n    int n = s.length();\r\n    int off = 0;\r\n    while (n > 0) {\r\n        int toCopy = Math.min(n, this.buff.length - this.len);\r\n        s.getBytes(off, off + toCopy, this.buff, this.len);\r\n        this.len += toCopy;\r\n        off += toCopy;\r\n        n -= toCopy;\r\n        if (this.buff.length == this.len) {\r\n            this.out.write(this.buff, 0, this.len);\r\n            this.len = 0;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.SeiImplMetadata.getConstructor",
	"Comment": "this method obtains the constructor method of the annotated endpoint",
	"Method": "ConstructorMetadata getConstructor(){\r\n    if (constructor != null) {\r\n        return constructor;\r\n    }\r\n    ConstructorMetadataBuilder constructorMethod = new ConstructorMetadataBuilder(getId());\r\n    constructorMethod.setModifier(Modifier.PUBLIC);\r\n    constructorMethod.addParameter(getServiceField().getFieldName().getSymbolNameUnCapitalisedFirstLetter(), getServiceField().getFieldType());\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    bodyBuilder.appendFormalLine(\"%s(%s);\", getMutatorMethod(getServiceField()).getMethodName(), getServiceField().getFieldName().getSymbolNameUnCapitalisedFirstLetter());\r\n    constructorMethod.setBodyBuilder(bodyBuilder);\r\n    constructor = constructorMethod.build();\r\n    return constructor;\r\n}"
}, {
	"Path": "pcal.ParseAlgorithm.IsIn",
	"Comment": "sets of strings methods for handling sets of strings, where such a set is represented as a vector of its elements.",
	"Method": "boolean IsIn(String elt,Vector set){\r\n    int i = 0;\r\n    boolean result = false;\r\n    while (i < set.size()) {\r\n        result = result || elt.equals((String) set.elementAt(i));\r\n        i = i + 1;\r\n    }\r\n    ;\r\n    return result;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.proof.TLAProofFoldingStructureProvider.hideCurrentSubtree",
	"Comment": "hides the proof of a statement and all subproofs. assumesall tlaproofposition in foldpositions are sorted by ascending offset.",
	"Method": "void hideCurrentSubtree(int offset){\r\n    List<Annotation> modifiedAnnotations = new ArrayList<Annotation>();\r\n    TLAProofPosition found = null;\r\n    for (Iterator<TLAProofPosition> it = foldPositions.iterator(); it.hasNext(); ) {\r\n        TLAProofPosition proofPosition = it.next();\r\n        try {\r\n            if (found == null && proofPosition.containsBeforeProof(offset, document)) {\r\n                found = proofPosition;\r\n                if (!found.getAnnotation().isCollapsed()) {\r\n                    found.getAnnotation().markCollapsed();\r\n                    modifiedAnnotations.add(found.getAnnotation());\r\n                }\r\n                continue;\r\n            }\r\n            if (found != null && found.contains(proofPosition)) {\r\n                if (!proofPosition.getAnnotation().isCollapsed()) {\r\n                    proofPosition.getAnnotation().markCollapsed();\r\n                    modifiedAnnotations.add(proofPosition.getAnnotation());\r\n                }\r\n            }\r\n        } catch (BadLocationException e) {\r\n            Activator.getDefault().logError(\"Error changing expansion state of proofs.\", e);\r\n        }\r\n    }\r\n    editor.modifyProjectionAnnotations((Annotation[]) modifiedAnnotations.toArray(new ProjectionAnnotation[modifiedAnnotations.size()]));\r\n}"
}, {
	"Path": "org.springframework.roo.project.maven.Pom.getGroupId",
	"Comment": "returns the id of the organisation or group that owns this module orproject",
	"Method": "String getGroupId(){\r\n    return gav.getGroupId();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.AdapterFactory.getStatusAsSWTFGColor",
	"Comment": "converts parse status to a foreground color for display in the status contribution item",
	"Method": "int getStatusAsSWTFGColor(Spec spec){\r\n    if (spec != null) {\r\n        switch(spec.getStatus()) {\r\n            case IParseConstants.PARSED:\r\n                return SWT.COLOR_BLACK;\r\n            case IParseConstants.COULD_NOT_FIND_MODULE:\r\n            case IParseConstants.SEMANTIC_WARNING:\r\n            case IParseConstants.SEMANTIC_ERROR:\r\n            case IParseConstants.SYNTAX_ERROR:\r\n            case IParseConstants.UNKNOWN_ERROR:\r\n                return SWT.COLOR_WHITE;\r\n            case IParseConstants.UNPARSED:\r\n                return SWT.COLOR_BLACK;\r\n            case IParseConstants.UNKNOWN:\r\n            default:\r\n                return SWT.COLOR_BLACK;\r\n        }\r\n    } else {\r\n        return SWT.COLOR_BLACK;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.model.JavaType.isMultiValued",
	"Comment": "indicates whether a field or variable of this type can contain multiplevalues",
	"Method": "boolean isMultiValued(){\r\n    return isCommonCollectionType() || isArray();\r\n}"
}, {
	"Path": "com.facebook.swift.service.ThriftServerConfig.setConnectionLimit",
	"Comment": "sets an upper bound on the number of concurrent connections the server will accept.the default is not to limit the number of connections.",
	"Method": "ThriftServerConfig setConnectionLimit(int connectionLimit){\r\n    this.connectionLimit = connectionLimit;\r\n    return this;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.editor.part.ValidateableOverridesSectionPart.createTableViewer",
	"Comment": "overrides the method in validateableconstantsectionpart in orderto add a label provider for displaying definition overrides properly.",
	"Method": "TableViewer createTableViewer(Table table){\r\n    TableViewer tableViewer = super.createTableViewer(table);\r\n    tableViewer.setLabelProvider(new LabelProvider() {\r\n        public String getText(Object element) {\r\n            if (element instanceof Assignment) {\r\n                Assignment assign = (Assignment) element;\r\n                String label = assign.getLabel();\r\n                String noBangLabel = label.substring(label.lastIndexOf(\"!\") + 1);\r\n                String rightSide = null;\r\n                if (assign.isModelValue()) {\r\n                    rightSide = noBangLabel;\r\n                } else {\r\n                    rightSide = assign.getRight();\r\n                }\r\n                Assignment assignNoBang = new Assignment(noBangLabel, assign.getParams(), rightSide);\r\n                return assignNoBang.toString();\r\n            }\r\n            return super.getText(element);\r\n        }\r\n    });\r\n    return tableViewer;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.editor.part.ValidateableOverridesSectionPart.createTableViewer",
	"Comment": "overrides the method in validateableconstantsectionpart in orderto add a label provider for displaying definition overrides properly.",
	"Method": "TableViewer createTableViewer(Table table){\r\n    if (element instanceof Assignment) {\r\n        Assignment assign = (Assignment) element;\r\n        String label = assign.getLabel();\r\n        String noBangLabel = label.substring(label.lastIndexOf(\"!\") + 1);\r\n        String rightSide = null;\r\n        if (assign.isModelValue()) {\r\n            rightSide = noBangLabel;\r\n        } else {\r\n            rightSide = assign.getRight();\r\n        }\r\n        Assignment assignNoBang = new Assignment(noBangLabel, assign.getParams(), rightSide);\r\n        return assignNoBang.toString();\r\n    }\r\n    return super.getText(element);\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.regex.WildcardStringParser.isInAlphabet",
	"Comment": "tests if a certain character is a valid character in the alphabet that is applying for this automaton.",
	"Method": "boolean isInAlphabet(char pCharToCheck){\r\n    for (int i = 0; i < ALPHABET.length; i++) {\r\n        if (pCharToCheck == ALPHABET[i]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.roo.project.maven.Pom.getDependenciesExcludingVersion",
	"Comment": "locates any dependencies which match the presented dependency, excludingthe version number. this is useful for upgrade use cases, where it isnecessary to remove any dependencies with the same group id, artifact id,and type as the dependency being upgraded to.",
	"Method": "Set<Dependency> getDependenciesExcludingVersion(Dependency dependency){\r\n    final Set<Dependency> result = new HashSet<Dependency>();\r\n    for (final Dependency d : dependencies) {\r\n        if (dependency != null && dependency.getArtifactId().equals(d.getArtifactId()) && dependency.getGroupId().equals(d.getGroupId()) && dependency.getType().equals(d.getType())) {\r\n            result.add(d);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "tlc2.tool.distributed.fp.DynamicFPSetManagerTest.testCtor33",
	"Comment": "test that the ctor correctly calculates its mask used to index fpset\tservers for valid values.",
	"Method": "void testCtor33(){\r\n    DynamicFPSetManager dynamicFPSetManager = new DynamicFPSetManager(33);\r\n    long mask = dynamicFPSetManager.getMask();\r\n    assertEquals(63L, mask);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.HideAllProofsHandler.setEnabled",
	"Comment": "this method is used to update the enablement state. this has theeffect of graying out any menu items for thecommand if the handler is disabled. through experimentation, this method seems to becalled just before such menu items are rendered in the ui andjust before the handler is executed.",
	"Method": "void setEnabled(Object context){\r\n    TLAEditor editor = EditorUtil.getTLAEditorWithFocus();\r\n    if (editor != null) {\r\n        if (editor.getProofStructureProvider() != null) {\r\n            setBaseEnabled(editor.getProofStructureProvider().canRunFoldOperation(IProofFoldCommandIds.FOLD_ALL_PROOFS, (ITextSelection) editor.getSelectionProvider().getSelection()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.distributed.fp.DynamicFPSetManagerTest.testCtor32",
	"Comment": "test that the ctor correctly calculates its mask used to index fpset\tservers for valid values.",
	"Method": "void testCtor32(){\r\n    DynamicFPSetManager dynamicFPSetManager = new DynamicFPSetManager(32);\r\n    long mask = dynamicFPSetManager.getMask();\r\n    assertEquals(63L, mask);\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.CollectionAbstractTest.cloneMapEntry",
	"Comment": "creates a new map entry that is independent of the first and the map.",
	"Method": "Map.Entry cloneMapEntry(Map.Entry entry){\r\n    HashMap map = new HashMap();\r\n    map.put(entry.getKey(), entry.getValue());\r\n    return (Map.Entry) map.entrySet().iterator().next();\r\n}"
}, {
	"Path": "org.springframework.roo.project.AbstractProjectOperations.removeManagementConfiguration",
	"Comment": "method that removes version, scope and exclusions from provided element.",
	"Method": "Element removeManagementConfiguration(Element element){\r\n    NodeList elementAttributes = element.getChildNodes();\r\n    List<Node> elementsToRemove = new ArrayList<Node>();\r\n    for (int i = 0; i < elementAttributes.getLength(); i++) {\r\n        Element elementAttribute = (Element) elementAttributes.item(i);\r\n        if (elementAttribute != null && elementAttribute.getTagName().equals(\"version\")) {\r\n            elementsToRemove.add(elementAttributes.item(i));\r\n        }\r\n        if (elementAttribute != null && elementAttribute.getTagName().equals(\"scope\")) {\r\n            elementsToRemove.add(elementAttributes.item(i));\r\n        }\r\n        if (elementAttribute != null && elementAttribute.getTagName().equals(\"exclusions\")) {\r\n            elementsToRemove.add(elementAttributes.item(i));\r\n        }\r\n    }\r\n    for (Node child : elementsToRemove) {\r\n        element.removeChild(child);\r\n    }\r\n    return element;\r\n}"
}, {
	"Path": "tlc2.tool.distributed.fp.DynamicFPSetManagerTest.testCtor31",
	"Comment": "test that the ctor correctly calculates its mask used to index fpset\tservers for valid values.",
	"Method": "void testCtor31(){\r\n    DynamicFPSetManager dynamicFPSetManager = new DynamicFPSetManager(31);\r\n    long mask = dynamicFPSetManager.getMask();\r\n    assertEquals(31L, mask);\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.metadata.CompoundDirectoryAbstractTest.createSingleDirectory",
	"Comment": "override by subclasses that require special kind of directory",
	"Method": "Directory createSingleDirectory(Collection<Entry> entries){\r\n    return new TestDirectory(entries);\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackResponsesLogic.updateFeedbackResponsesForChangingTeam",
	"Comment": "updates responses for a student when his team changes. this is done bydeleting responses that are no longer relevant to him in his new team.",
	"Method": "void updateFeedbackResponsesForChangingTeam(String courseId,String userEmail,String oldTeam,String newTeam){\r\n    deleteResponsesFromUserToTeam(courseId, userEmail);\r\n    deleteResponsesFromTeamToUser(courseId, userEmail);\r\n    boolean isOldTeamEmpty = studentsLogic.getStudentsForTeam(oldTeam, courseId).isEmpty();\r\n    if (isOldTeamEmpty) {\r\n        deleteTeamResponses(courseId, oldTeam);\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.Tool.getSymmetryPerms",
	"Comment": "return the set of all permutations under the symmetry assumption.",
	"Method": "MVPerm[] getSymmetryPerms(){\r\n    final String name = this.config.getSymmetry();\r\n    if (name.length() == 0) {\r\n        return null;\r\n    }\r\n    final Object symm = this.defns.get(name);\r\n    if (symm == null) {\r\n        Assert.fail(EC.TLC_CONFIG_SPECIFIED_NOT_DEFINED, new String[] { \"symmetry function\", name });\r\n    }\r\n    if (!(symm instanceof OpDefNode)) {\r\n        Assert.fail(\"The symmetry function \" + name + \" must specify a set of permutations.\");\r\n    }\r\n    final Value fcns = this.eval(((OpDefNode) symm).getBody(), Context.Empty, TLCState.Empty);\r\n    if (!(fcns instanceof Enumerable)) {\r\n        Assert.fail(\"The symmetry operator must specify a set of functions.\");\r\n    }\r\n    return MVPerm.permutationSubgroup((Enumerable) fcns);\r\n}"
}, {
	"Path": "util.FileUtil.replaceFile",
	"Comment": "atomically replaces the file targetname with the file sourcename.",
	"Method": "void replaceFile(String sourceName,String targetName){\r\n    Files.move(new File(sourceName).toPath(), new File(targetName).toPath(), StandardCopyOption.REPLACE_EXISTING);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.test.threading.HandlerThreadingTest.assertNoBackendCodeInUIThread",
	"Comment": "checks how many invocations of backend code have happend inside the ui\tthread",
	"Method": "void assertNoBackendCodeInUIThread(){\r\n    Assert.assertTrue(\"Test requires active MonitorAspect aspect!\", MonitorAdaptor.aspectIsActive());\r\n    if (MonitorAdaptor.hasTriggeredBackendCode()) {\r\n        Set<JoinPoint> joinPoints = MonitorAdaptor.getTriggeredJoinPoints();\r\n        for (JoinPoint joinPoint : joinPoints) {\r\n            System.err.println(joinPoint);\r\n        }\r\n    }\r\n    Assert.assertFalse(\"Backend code (e.g. parsing must not be executed in UI thread) times executed: \" + MonitorAdaptor.getTriggeredJoinPoints().size(), MonitorAdaptor.hasTriggeredBackendCode());\r\n    MonitorAdaptor.reset();\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.CollectionUtils.arrayToList",
	"Comment": "convert the supplied array into a list. a primitive array gets convertedinto a list of the appropriate wrapper type.a null source value will be converted to an empty list.",
	"Method": "List<?> arrayToList(Object source){\r\n    return Arrays.asList(ObjectUtils.toObjectArray(source));\r\n}"
}, {
	"Path": "org.springframework.roo.support.osgi.UrlFindingUtils.findUrls",
	"Comment": "searches the bundles in the given context for the given resource.",
	"Method": "Set<URL> findUrls(BundleContext context,String resourceName){\r\n    Validate.notBlank(resourceName, \"Resource name to locate is required\");\r\n    final Set<URL> results = new HashSet<URL>();\r\n    OSGiUtils.execute(new BundleCallback() {\r\n        public void execute(final Bundle bundle) {\r\n            try {\r\n                final URL url = bundle.getEntry(resourceName);\r\n                if (url != null) {\r\n                    results.add(url);\r\n                }\r\n            } catch (final IllegalStateException e) {\r\n            }\r\n        }\r\n    }, context);\r\n    return results;\r\n}"
}, {
	"Path": "org.springframework.roo.support.osgi.UrlFindingUtils.findUrls",
	"Comment": "searches the bundles in the given context for the given resource.",
	"Method": "Set<URL> findUrls(BundleContext context,String resourceName){\r\n    try {\r\n        final URL url = bundle.getEntry(resourceName);\r\n        if (url != null) {\r\n            results.add(url);\r\n        }\r\n    } catch (final IllegalStateException e) {\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.getTeamsInSectionFromRoster",
	"Comment": "get the team names in a section. instructors are not contained in any section.",
	"Method": "Set<String> getTeamsInSectionFromRoster(String sectionName){\r\n    return new HashSet(rosterSectionTeamNameTable.getOrDefault(sectionName, new HashSet()));\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.defineGetTypeMethod",
	"Comment": "defines the gettype method which simply returns the value of the type field.",
	"Method": "void defineGetTypeMethod(){\r\n    classDefinition.addMethod(new MethodDefinition(a(PUBLIC), \"getType\", type(ThriftType.class)).loadThis().getField(codecType, typeField).retObject());\r\n}"
}, {
	"Path": "teammates.ui.controller.InstructorFeedbackEditCopyAction.filterConflictsInCourses",
	"Comment": "given an array of course ids, return only the ids of courses which hasan existing feedback session with a name conflicting with feedbacksessionname.",
	"Method": "List<String> filterConflictsInCourses(String feedbackSessionName,String[] coursesIdToCopyTo){\r\n    List<String> courses = new ArrayList();\r\n    for (String courseIdToCopy : coursesIdToCopyTo) {\r\n        FeedbackSessionAttributes existingFs = logic.getFeedbackSession(feedbackSessionName, courseIdToCopy);\r\n        boolean hasExistingFs = existingFs != null;\r\n        if (hasExistingFs) {\r\n            courses.add(existingFs.getCourseId());\r\n        }\r\n    }\r\n    return courses;\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorFeedbackResultsPageData.buildQuestionTableAndResponseRows",
	"Comment": "builds a question table for given question, and response rows for the given responses.",
	"Method": "InstructorFeedbackResultsQuestionTable buildQuestionTableAndResponseRows(FeedbackQuestionAttributes question,List<FeedbackResponseAttributes> responses,String additionalInfoId,InstructorFeedbackResultsQuestionTable buildQuestionTableAndResponseRows,FeedbackQuestionAttributes question,List<FeedbackResponseAttributes> responses,String additionalInfoId,String participantIdentifier,boolean isShowingResponseRows){\r\n    List<ElementTag> columnTags = new ArrayList();\r\n    Map<String, Boolean> isSortable = new HashMap();\r\n    boolean isCollapsible = true;\r\n    List<InstructorFeedbackResultsResponseRow> responseRows = null;\r\n    FeedbackQuestionDetails questionDetails = questionToDetailsMap.get(question);\r\n    boolean isFeedbackParticipantCommentsOnResponsesAllowed = questionDetails.isFeedbackParticipantCommentsOnResponsesAllowed();\r\n    if (isShowingResponseRows) {\r\n        switch(viewType) {\r\n            case QUESTION:\r\n                buildTableColumnHeaderForQuestionView(columnTags, isSortable, isFeedbackParticipantCommentsOnResponsesAllowed);\r\n                responseRows = buildResponseRowsForQuestion(question, responses);\r\n                break;\r\n            case GIVER_QUESTION_RECIPIENT:\r\n                buildTableColumnHeaderForGiverQuestionRecipientView(columnTags, isSortable, isFeedbackParticipantCommentsOnResponsesAllowed);\r\n                responseRows = buildResponseRowsForQuestionForSingleGiver(question, responses, participantIdentifier);\r\n                isCollapsible = false;\r\n                break;\r\n            case RECIPIENT_QUESTION_GIVER:\r\n                buildTableColumnHeaderForRecipientQuestionGiverView(columnTags, isSortable, isFeedbackParticipantCommentsOnResponsesAllowed);\r\n                responseRows = buildResponseRowsForQuestionForSingleRecipient(question, responses, participantIdentifier);\r\n                isCollapsible = false;\r\n                break;\r\n            default:\r\n                Assumption.fail(\"View type should not involve question tables\");\r\n                break;\r\n        }\r\n        if (questionDetails.isQuestionSpecificSortingRequired()) {\r\n            responseRows.sort(questionDetails.getResponseRowsSortOrder());\r\n        } else {\r\n            responseRows = InstructorFeedbackResultsResponseRow.sortListWithDefaultOrder(responseRows);\r\n        }\r\n    }\r\n    String studentEmail = student == null ? null : student.email;\r\n    String statisticsTable = questionDetails.getQuestionResultStatisticsHtml(responses, question, studentEmail, bundle, viewType.toString());\r\n    String questionText = questionDetails.getQuestionText();\r\n    String additionalInfoText = questionDetails.getQuestionAdditionalInfoHtml(question.questionNumber, additionalInfoId);\r\n    InstructorFeedbackResultsQuestionTable questionTable = new InstructorFeedbackResultsQuestionTable(!responses.isEmpty(), statisticsTable, responseRows, question, questionText, additionalInfoText, columnTags, isSortable);\r\n    if (viewType == InstructorFeedbackResultsPageViewType.QUESTION) {\r\n        questionTable.setAjaxClass(isLargeNumberOfResponses() ? \" ajax_submit\" : \" ajax_auto\");\r\n    }\r\n    questionTable.setShowResponseRows(isShowingResponseRows);\r\n    questionTable.setCollapsible(isCollapsible);\r\n    return questionTable;\r\n}"
}, {
	"Path": "org.springframework.roo.metadata.MetadataIdentificationUtils.getMetadataInstance",
	"Comment": "returns the instance key from the given metadata instance id.",
	"Method": "String getMetadataInstance(String metadataId){\r\n    if (isIdentifyingInstance(metadataId)) {\r\n        return metadataId.substring(metadataId.indexOf(INSTANCE_DELIMITER) + 1);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "tlc2.tool.Spec.getPrimedVar",
	"Comment": "return the variable if expr is a primed state variable. otherwise, null.",
	"Method": "SymbolNode getPrimedVar(SemanticNode expr,Context c,boolean cutoff){\r\n    if (expr instanceof OpApplNode) {\r\n        OpApplNode expr1 = (OpApplNode) expr;\r\n        SymbolNode opNode = expr1.getOperator();\r\n        if (BuiltInOPs.getOpCode(opNode.getName()) == OPCODE_prime) {\r\n            return this.getVar(expr1.getArgs()[0], c, cutoff);\r\n        }\r\n        if (opNode.getArity() == 0) {\r\n            boolean isVarDecl = (opNode.getKind() == VariableDeclKind);\r\n            Object val = this.lookup(opNode, c, cutoff && isVarDecl);\r\n            if (val instanceof LazyValue) {\r\n                LazyValue lval = (LazyValue) val;\r\n                return this.getPrimedVar(lval.expr, lval.con, cutoff);\r\n            }\r\n            if (val instanceof OpDefNode) {\r\n                return this.getPrimedVar(((OpDefNode) val).getBody(), c, cutoff);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.test.RCPTestSetupHelper.resetWorkbench",
	"Comment": "close all open windows, editors, perspectives. open and reset default perspective.",
	"Method": "void resetWorkbench(){\r\n    try {\r\n        IWorkbench workbench = PlatformUI.getWorkbench();\r\n        IWorkbenchWindow workbenchWindow = workbench.getActiveWorkbenchWindow();\r\n        IWorkbenchPage page = workbenchWindow.getActivePage();\r\n        Shell activeShell = Display.getCurrent().getActiveShell();\r\n        if (activeShell != null && activeShell != workbenchWindow.getShell()) {\r\n            activeShell.close();\r\n        }\r\n        page.closeAllEditors(false);\r\n        page.resetPerspective();\r\n        String defaultPerspectiveId = workbench.getPerspectiveRegistry().getDefaultPerspective();\r\n        workbench.showPerspective(defaultPerspectiveId, workbenchWindow);\r\n        page.resetPerspective();\r\n        page.showView(\"org.eclipse.ui.internal.introview\");\r\n    } catch (WorkbenchException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.itd.ItdSourceFileComposer.appendFormalLine",
	"Comment": "prints the message, after adding indents and returns to a new line. thisis the most commonly used method.",
	"Method": "ItdSourceFileComposer appendFormalLine(String message){\r\n    appendIndent();\r\n    if (message != null && !\"\".equals(message)) {\r\n        pw.append(message);\r\n        content = true;\r\n    }\r\n    return newLine(false);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.output.data.ObligationStatusMessage.getObString",
	"Comment": "returns the pretty printed form of the obligationif that is part of the message. otherwise returnsnull.",
	"Method": "String getObString(){\r\n    return obString;\r\n}"
}, {
	"Path": "teammates.storage.api.AdminEmailsDb.getAdminEmailDrafts",
	"Comment": "gets all admin email drafts that have not been sent and not in trash bin.",
	"Method": "List<AdminEmailAttributes> getAdminEmailDrafts(){\r\n    return makeAttributes(load().filter(\"isInTrashBin =\", false).filter(\"sendDate =\", null).list());\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.GotoMatchingParenHandler.findMatchingRightParen",
	"Comment": "assumes that currloc is just past a left paren with indexparenidx in parens.it sets currloc to the location just pastthe matching right paren, or throws an exception if there is a matching error.",
	"Method": "void findMatchingRightParen(int parenIdx){\r\n    int savedCurrLoc = currLoc;\r\n    while (true) {\r\n        currLoc++;\r\n        int pidx = -1;\r\n        while (currLoc <= endCurrRegion && ((pidx = getParenToLeftOf(currLoc)) == -1)) {\r\n            currLoc++;\r\n        }\r\n        if (pidx == -1) {\r\n            getNextRegion();\r\n            currLoc = beginCurrRegion;\r\n        } else {\r\n            if (pidx == LEFT_ROUND_PAREN_IDX && getParenToLeftOf(currLoc + 1) == BEGIN_MULTILINE_COMMENT_IDX) {\r\n                currLoc++;\r\n                pidx = BEGIN_MULTILINE_COMMENT_IDX;\r\n            }\r\n            if (pidx < PCOUNT) {\r\n                findMatchingRightParen(pidx);\r\n            } else {\r\n                if ((pidx - parenIdx) % PCOUNT == 0) {\r\n                    return;\r\n                } else {\r\n                    throw new ParenErrorException(PARENS[parenIdx] + \" matched by \" + PARENS[pidx], new Region(currLoc - PARENS[pidx].length(), PARENS[pidx].length()), new Region(savedCurrLoc - PARENS[parenIdx].length(), PARENS[parenIdx].length()));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.WsEndpointsMetadata.getSeiFromEndpoint",
	"Comment": "this method obtains the associated sei of the provided endpoint",
	"Method": "JavaType getSeiFromEndpoint(JavaType endpoint){\r\n    return endpointsAndSeis.get(endpoint);\r\n}"
}, {
	"Path": "org.springframework.roo.project.maven.Pom.getModuleName",
	"Comment": "returns the programmatic name of this module of the user project",
	"Method": "String getModuleName(){\r\n    return moduleName;\r\n}"
}, {
	"Path": "tla2sany.semantic.SymbolNode.exportDefinition",
	"Comment": "symbol nodes are exported using their names only. within a context element,we want to expand their whole definitions and are using this methodwe need to add location and level information here.",
	"Method": "Element exportDefinition(Document doc,tla2sany.xml.SymbolContext context){\r\n    if (!context.isTop_level_entry())\r\n        throw new IllegalArgumentException(\"Exporting definition \" + getName() + \" ref \" + getNodeRef() + \" twice!\");\r\n    context.resetTop_level_entry();\r\n    try {\r\n        Element e = getSymbolElement(doc, context);\r\n        try {\r\n            Element l = appendText(doc, \"level\", Integer.toString(getLevel()));\r\n            e.insertBefore(l, e.getFirstChild());\r\n        } catch (RuntimeException ee) {\r\n        }\r\n        try {\r\n            Element loc = getLocationElement(doc);\r\n            e.insertBefore(loc, e.getFirstChild());\r\n        } catch (RuntimeException ee) {\r\n        }\r\n        return e;\r\n    } catch (RuntimeException ee) {\r\n        System.err.println(\"failed for node.toString(): \" + toString() + \"\\n with error \");\r\n        ee.printStackTrace();\r\n        throw ee;\r\n    }\r\n}"
}, {
	"Path": "tlc2.module.TLC.JavaTime",
	"Comment": "the current wall clock time.note that it is not declared as final.so, tlc will not treat it as a constant.",
	"Method": "Value JavaTime(){\r\n    int t = (int) System.currentTimeMillis();\r\n    return IntValue.gen(t & 0x7FFFFFFF);\r\n}"
}, {
	"Path": "teammates.ui.pagedata.PageData.getResponseVisibilityMap",
	"Comment": "returns map in which key is feedback participant and value determines whether response is visible to it.",
	"Method": "Map<FeedbackParticipantType, Boolean> getResponseVisibilityMap(FeedbackQuestionAttributes question){\r\n    Map<FeedbackParticipantType, Boolean> responseVisibilityMap = new HashMap();\r\n    FeedbackParticipantType[] relevantTypes = { FeedbackParticipantType.GIVER, FeedbackParticipantType.RECEIVER, FeedbackParticipantType.OWN_TEAM_MEMBERS, FeedbackParticipantType.RECEIVER_TEAM_MEMBERS, FeedbackParticipantType.STUDENTS, FeedbackParticipantType.INSTRUCTORS };\r\n    for (FeedbackParticipantType participantType : relevantTypes) {\r\n        responseVisibilityMap.put(participantType, isResponseVisibleTo(participantType, question));\r\n    }\r\n    return responseVisibilityMap;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.verifyNotContain",
	"Comment": "verifies that the page source does not contain the given searchstring.",
	"Method": "AppPage verifyNotContain(String searchString){\r\n    String pageSource = getPageSource();\r\n    assertFalse(pageSource.contains(searchString));\r\n    return this;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.ResourceHelper.innerGetBoundIdentifiers",
	"Comment": "this is the recursive operator that implements getboundidentifiers.it adds thebound identifiers in expr to those in vec.the identifiers in vec should be differentfrom the ones declared in expr.",
	"Method": "void innerGetBoundIdentifiers(Vector<FormalParamNode> vec,ExprNode expr){\r\n    if (expr instanceof OpApplNode) {\r\n        OpApplNode node = (OpApplNode) expr;\r\n        if (node.getUnbdedQuantSymbols() != null) {\r\n            for (int i = 0; i < node.getUnbdedQuantSymbols().length; i++) {\r\n                vec.add(node.getUnbdedQuantSymbols()[i]);\r\n            }\r\n        }\r\n        if (node.getBdedQuantSymbolLists() != null) {\r\n            for (int i = 0; i < node.getBdedQuantSymbolLists().length; i++) {\r\n                FormalParamNode[] nodeList = node.getBdedQuantSymbolLists()[i];\r\n                for (int j = 0; j < nodeList.length; j++) {\r\n                    vec.add(nodeList[j]);\r\n                }\r\n                innerGetBoundIdentifiers(vec, node.getBdedQuantBounds()[i]);\r\n            }\r\n        }\r\n        for (int i = 0; i < node.getArgs().length; i++) {\r\n            if (node.getArgs()[i] instanceof ExprNode) {\r\n                innerGetBoundIdentifiers(vec, (ExprNode) node.getArgs()[i]);\r\n            }\r\n        }\r\n    } else if (expr instanceof LetInNode) {\r\n        LetInNode node = (LetInNode) expr;\r\n        for (int i = 0; i < node.getLets().length; i++) {\r\n            OpDefNode def = node.getLets()[i];\r\n            for (int j = 0; j < def.getParams().length; j++) {\r\n                vec.add(def.getParams()[j]);\r\n            }\r\n            innerGetBoundIdentifiers(vec, node.getBody());\r\n            return;\r\n        }\r\n    } else {\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.output.data.TLCVariable.getSingleLineName",
	"Comment": "returns the name this variable in a single line string.the name could be multiple lines if this represents a trace explorerexpression.",
	"Method": "String getSingleLineName(){\r\n    return name.replaceAll(\"\\n\", \"\").replaceAll(\"\\r\", \"\");\r\n}"
}, {
	"Path": "teammates.ui.controller.AdminInstructorAccountAddAction.generateDemoCourseId",
	"Comment": "generate a course id for demo course, and if the generated id already exists, try another one.",
	"Method": "String generateDemoCourseId(String instructorEmail){\r\n    String proposedCourseId = generateNextDemoCourseId(instructorEmail, FieldValidator.COURSE_ID_MAX_LENGTH);\r\n    while (logic.getCourse(proposedCourseId) != null) {\r\n        proposedCourseId = generateNextDemoCourseId(proposedCourseId, FieldValidator.COURSE_ID_MAX_LENGTH);\r\n    }\r\n    return proposedCourseId;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.WsOperationsImpl.includeDependenciesAndPluginsForSei",
	"Comment": "this method includes the tracee and cxf dependencies. also, include the cxf starter",
	"Method": "void includeDependenciesAndPluginsForSei(String moduleName){\r\n    getProjectOperations().addProperty(\"\", CXF_PROPERTY);\r\n    getProjectOperations().addDependency(moduleName, CXF_STARTER_DEPENDENCY);\r\n    getProjectOperations().addProperty(\"\", TRACEE_PROPERTY);\r\n    getProjectOperations().addDependency(moduleName, TRACEE_JAXWS_DEPENDENCY);\r\n    getProjectOperations().addDependency(moduleName, TRACEE_CXF_DEPENDENCY);\r\n}"
}, {
	"Path": "teammates.common.util.SanitizationHelper.sanitizeTitle",
	"Comment": "sanitizes title by removing leading, trailing, and duplicate internal whitespace.",
	"Method": "String sanitizeTitle(String rawTitle){\r\n    return StringHelper.removeExtraSpace(rawTitle);\r\n}"
}, {
	"Path": "teammates.logic.api.Logic.putInstructorDocuments",
	"Comment": "batch creates or updates documents for the given instructors.",
	"Method": "void putInstructorDocuments(List<InstructorAttributes> instructors){\r\n    instructorsLogic.putDocuments(instructors);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.proof.TLAProofFoldingStructureProvider.expandCurrentSubtree",
	"Comment": "expands the proof of a statement and all sub proofs. assumesall tlaproofposition in foldpositions are sorted by ascending offset.",
	"Method": "void expandCurrentSubtree(int offset){\r\n    List<Annotation> modifiedAnnotations = new ArrayList<Annotation>();\r\n    TLAProofPosition found = null;\r\n    for (Iterator<TLAProofPosition> it = foldPositions.iterator(); it.hasNext(); ) {\r\n        TLAProofPosition proofPosition = it.next();\r\n        try {\r\n            if (found == null && proofPosition.containsBeforeProof(offset, document)) {\r\n                found = proofPosition;\r\n                if (found.getAnnotation().isCollapsed()) {\r\n                    found.getAnnotation().markExpanded();\r\n                    modifiedAnnotations.add(found.getAnnotation());\r\n                }\r\n                continue;\r\n            }\r\n            if (found != null && found.contains(proofPosition)) {\r\n                if (proofPosition.getAnnotation().isCollapsed()) {\r\n                    proofPosition.getAnnotation().markExpanded();\r\n                    modifiedAnnotations.add(proofPosition.getAnnotation());\r\n                }\r\n            }\r\n        } catch (BadLocationException e) {\r\n            Activator.getDefault().logError(\"Error changing expansion state of proofs.\", e);\r\n        }\r\n    }\r\n    editor.modifyProjectionAnnotations((Annotation[]) modifiedAnnotations.toArray(new ProjectionAnnotation[modifiedAnnotations.size()]));\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.ToolboxHandle.getRootModule",
	"Comment": "retrieves the root file of the loaded spec or null if no spec selected",
	"Method": "IFile getRootModule(IResource getRootModule,IProject project){\r\n    return PreferenceStoreHelper.readProjectRootFile(project);\r\n}"
}, {
	"Path": "util.UniqueString.equals",
	"Comment": "since uniqueness is guaranteed, the equals is a high performance reference comparison",
	"Method": "boolean equals(UniqueString t,boolean equals,String t){\r\n    return this.s.equals(t);\r\n}"
}, {
	"Path": "teammates.logic.api.Logic.restoreAllCoursesFromRecycleBin",
	"Comment": "restores all courses and all data related to these courses from recycle bin.",
	"Method": "void restoreAllCoursesFromRecycleBin(List<InstructorAttributes> instructorList){\r\n    Assumption.assertNotNull(instructorList);\r\n    coursesLogic.restoreAllCoursesFromRecycleBin(instructorList);\r\n}"
}, {
	"Path": "com.facebook.swift.codec.metadata.ReflectionHelper.findAnnotatedMethods",
	"Comment": "find methods that are tagged with a given annotation somewhere in the hierarchy",
	"Method": "Collection<Method> findAnnotatedMethods(Class<?> type,Class<? extends Annotation> annotation){\r\n    List<Method> result = new ArrayList();\r\n    for (Method method : type.getMethods()) {\r\n        if (method.isSynthetic() || method.isBridge() || isStatic(method.getModifiers())) {\r\n            continue;\r\n        }\r\n        Method managedMethod = findAnnotatedMethod(type, annotation, method.getName(), method.getParameterTypes());\r\n        if (managedMethod != null) {\r\n            result.add(managedMethod);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.EntityAttributes.isValid",
	"Comment": "returns true if the attributes represent a valid state for the entity.",
	"Method": "boolean isValid(){\r\n    return getInvalidityInfo().isEmpty();\r\n}"
}, {
	"Path": "teammates.ui.pagedata.PageData.isResponseVisibleTo",
	"Comment": "todo investigate and fix the differences between question.isresponsevisibleto and this method",
	"Method": "boolean isResponseVisibleTo(FeedbackParticipantType participantType,FeedbackQuestionAttributes question){\r\n    switch(participantType) {\r\n        case GIVER:\r\n            return question.isResponseVisibleTo(FeedbackParticipantType.GIVER);\r\n        case INSTRUCTORS:\r\n            return question.isResponseVisibleTo(FeedbackParticipantType.INSTRUCTORS);\r\n        case OWN_TEAM_MEMBERS:\r\n            return question.giverType != FeedbackParticipantType.INSTRUCTORS && question.giverType != FeedbackParticipantType.SELF && question.isResponseVisibleTo(FeedbackParticipantType.OWN_TEAM_MEMBERS);\r\n        case RECEIVER:\r\n            return question.recipientType != FeedbackParticipantType.SELF && question.recipientType != FeedbackParticipantType.NONE && question.isResponseVisibleTo(FeedbackParticipantType.RECEIVER);\r\n        case RECEIVER_TEAM_MEMBERS:\r\n            return question.recipientType != FeedbackParticipantType.INSTRUCTORS && question.recipientType != FeedbackParticipantType.SELF && question.recipientType != FeedbackParticipantType.NONE && question.isResponseVisibleTo(FeedbackParticipantType.RECEIVER_TEAM_MEMBERS);\r\n        case STUDENTS:\r\n            return question.isResponseVisibleTo(FeedbackParticipantType.STUDENTS);\r\n        default:\r\n            Assumption.fail(\"Invalid participant type\");\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.ObjectAbstractTest.testCanonicalEmptyCollectionExists",
	"Comment": "tests serialization by comparing against a previously stored version in cvs.if the test object is serializable, confirm that a canonical form exists.",
	"Method": "void testCanonicalEmptyCollectionExists(){\r\n    if (supportsEmptyCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {\r\n        Object object = makeObject();\r\n        if (object instanceof Serializable) {\r\n            String name = getCanonicalEmptyCollectionName(object);\r\n            assertTrue(\"Canonical empty collection (\" + name + \") is not in CVS\", new File(name).exists());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.storage.api.AdminEmailsDb.getSentAdminEmails",
	"Comment": "gets all admin emails that have been sent and not in trash bin.",
	"Method": "List<AdminEmailAttributes> getSentAdminEmails(){\r\n    return makeAttributes(load().filter(\"isInTrashBin =\", false).filter(\"sendDate !=\", null).list());\r\n}"
}, {
	"Path": "teammates.ui.pagedata.PageData.getInstructorFeedbackSessionActions",
	"Comment": "returns the links of actions available for a specific session.",
	"Method": "InstructorFeedbackSessionActions getInstructorFeedbackSessionActions(FeedbackSessionAttributes session,String returnUrl,InstructorAttributes instructor){\r\n    return new InstructorFeedbackSessionActions(this, session, returnUrl, instructor);\r\n}"
}, {
	"Path": "tlc2.tool.SimulationWorker.randomState",
	"Comment": "this method returns a state that is randomly chosen from the set of states.\tit returns null if the set of states is empty.",
	"Method": "TLCState randomState(RandomGenerator rng,StateVec states){\r\n    final int len = states.size();\r\n    if (len > 0) {\r\n        final int index = (int) Math.floor(rng.nextDouble() * len);\r\n        return states.elementAt(index);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.roo.felix.BundleSymbolicName.findBundleIdWithoutFail",
	"Comment": "locates the bundle id for this bundlesymbolicname, if available.",
	"Method": "Long findBundleIdWithoutFail(BundleContext context){\r\n    Validate.notNull(context, \"Bundle context is unavailable\");\r\n    final Bundle[] bundles = context.getBundles();\r\n    if (bundles == null) {\r\n        throw new IllegalStateException(\"Bundle IDs cannot be retrieved as BundleContext unavailable\");\r\n    }\r\n    for (final Bundle b : bundles) {\r\n        if (getKey().equals(b.getSymbolicName())) {\r\n            return b.getBundleId();\r\n        }\r\n    }\r\n    throw new IllegalStateException(\"Bundle symbolic name '\" + getKey() + \"' has no local bundle ID at this time\");\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.util.FormHelper.createSectionComposite",
	"Comment": "constructs a section and returns a section client compositethe section layout is tablewraplayout",
	"Method": "Section createSectionComposite(Composite parent,String title,String description,FormToolkit toolkit,int sectionFlags,IExpansionListener expansionListener,Section createSectionComposite,Composite parent,String title,String description,FormToolkit toolkit){\r\n    return createSectionComposite(parent, title, description, toolkit, Section.DESCRIPTION | Section.TITLE_BAR, null);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.spec.parser.ModuleParserLauncher.checkCancel",
	"Comment": "this is how the workbench signals a click on the cancel button or ifthe workbench has been shut down in the meantime.",
	"Method": "void checkCancel(IProgressMonitor monitor){\r\n    if (monitor.isCanceled()) {\r\n        throw new OperationCanceledException();\r\n    }\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.NavBarOverlayLayout.isShowing",
	"Comment": "tells whether or not the button is currently showing on the screen.",
	"Method": "boolean isShowing(){\r\n    return isShowing;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.traceexplorer.TraceExplorerComposite.doEditFormula",
	"Comment": "opens a dialog for formula processing and returns the edited formula",
	"Method": "Formula doEditFormula(Formula formula){\r\n    FormulaWizard wizard = new FormulaWizard(section.getText(), section.getDescription());\r\n    wizard.setFormula(formula);\r\n    WizardDialog dialog = new WizardDialog(getTableViewer().getTable().getShell(), wizard);\r\n    dialog.setHelpAvailable(true);\r\n    if (Window.OK == dialog.open()) {\r\n        return wizard.getFormula();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.output.data.ObligationStatusMessage.isAlreadyProcessed",
	"Comment": "returns true iff this status comesfrom the fingerprints file.",
	"Method": "boolean isAlreadyProcessed(){\r\n    return alreadyProcessed;\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.deleteAllFeedbackSessionsCascade",
	"Comment": "permanently deletes all feedback sessions in recycle bin, and all their questions and responses.",
	"Method": "void deleteAllFeedbackSessionsCascade(List<InstructorAttributes> instructorList){\r\n    Assumption.assertNotNull(\"Supplied parameter was null\", instructorList);\r\n    List<FeedbackSessionAttributes> feedbackSessionsList = getSoftDeletedFeedbackSessionsListForInstructors(instructorList);\r\n    for (FeedbackSessionAttributes session : feedbackSessionsList) {\r\n        deleteFeedbackSessionCascade(session.getFeedbackSessionName(), session.getCourseId());\r\n    }\r\n}"
}, {
	"Path": "toothpick.ScopeNode.reset",
	"Comment": "resets the state of the scope.useful for automation testing when we want to reset the scope used to install test modules.",
	"Method": "void reset(){\r\n    scopeAnnotationClasses.clear();\r\n    isOpen = true;\r\n    bindScopeAnnotationIfNameIsScopeAnnotation();\r\n}"
}, {
	"Path": "teammates.ui.pagedata.PageData.getTimeZoneOptionsAsHtml",
	"Comment": "returns the timezone options as html code.none is selected, since the selection should only be done in client side.",
	"Method": "List<String> getTimeZoneOptionsAsHtml(ZoneId existingTimeZone){\r\n    List<ZoneId> options = TimeHelper.getTimeZoneValues();\r\n    ArrayList<String> result = new ArrayList();\r\n    for (ZoneId timeZoneOption : options) {\r\n        result.add(\"<option value=\\\"\" + timeZoneOption.getId() + \"\\\"\" + (existingTimeZone.equals(timeZoneOption) ? \" selected\" : \"\") + \">\" + \"(\" + timeZoneOption.getId() + \") \" + TimeHelper.getCitiesForTimeZone(timeZoneOption) + \"<\/option>\");\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "tla2sany.configuration.ParseException.add_escapes",
	"Comment": "used to convert raw characters to their escaped versionwhen these raw version cannot be used as part of an asciistring literal.",
	"Method": "String add_escapes(String str){\r\n    StringBuffer retval = new StringBuffer();\r\n    char ch;\r\n    for (int i = 0; i < str.length(); i++) {\r\n        switch(str.charAt(i)) {\r\n            case 0:\r\n                continue;\r\n            case '\\b':\r\n                retval.append(\"\\\\b\");\r\n                continue;\r\n            case '\\t':\r\n                retval.append(\"\\\\t\");\r\n                continue;\r\n            case '\\n':\r\n                retval.append(\"\\\\n\");\r\n                continue;\r\n            case '\\f':\r\n                retval.append(\"\\\\f\");\r\n                continue;\r\n            case '\\r':\r\n                retval.append(\"\\\\r\");\r\n                continue;\r\n            case '\\\"':\r\n                retval.append(\"\\\\\\\"\");\r\n                continue;\r\n            case '\\'':\r\n                retval.append(\"\\\\\\'\");\r\n                continue;\r\n            case '\\\\':\r\n                retval.append(\"\\\\\\\\\");\r\n                continue;\r\n            default:\r\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\r\n                    String s = \"0000\" + Integer.toString(ch, 16);\r\n                    retval.append(\"\\\%u\" + s.substring(s.length() - 4, s.length()));\r\n                } else {\r\n                    retval.append(ch);\r\n                }\r\n                continue;\r\n        }\r\n    }\r\n    return retval.toString();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.model.Model.recover",
	"Comment": "tries to recover model after an abnormal tlc terminationit deletes all temporary files on disk and restores the state to unlocked.",
	"Method": "void recover(){\r\n    final IFile resource = getFile();\r\n    if (resource.exists()) {\r\n        try {\r\n            IMarker[] foundMarkers = resource.findMarkers(TLC_CRASHED_MARKER, false, IResource.DEPTH_ZERO);\r\n            if (foundMarkers.length == 0) {\r\n                return;\r\n            }\r\n            for (int i = 0; i < foundMarkers.length; i++) {\r\n                foundMarkers[i].delete();\r\n            }\r\n            foundMarkers = resource.findMarkers(TLC_MODEL_IN_USE_MARKER, false, IResource.DEPTH_ZERO);\r\n            for (int i = 0; i < foundMarkers.length; i++) {\r\n                foundMarkers[i].delete();\r\n            }\r\n        } catch (CoreException shouldNotHappen) {\r\n            TLCActivator.logError(shouldNotHappen.getMessage(), shouldNotHappen);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.liveness.TBPar.equals",
	"Comment": "this method returns true iff this particle is equal to another particle",
	"Method": "boolean equals(TBPar par){\r\n    return (this.contains(par) && par.contains(this));\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.dialog.InformationDialog.setImage",
	"Comment": "sets the image that will be displayed next to the messagein the dialog.",
	"Method": "void setImage(Image image){\r\n    this.image = image;\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorSearchPageData.filterStudentsByCourse",
	"Comment": "filters students from studentsearchresultbundle by course id.",
	"Method": "List<StudentAttributes> filterStudentsByCourse(String courseId,StudentSearchResultBundle studentSearchResultBundle){\r\n    List<StudentAttributes> students = new ArrayList();\r\n    for (StudentAttributes student : studentSearchResultBundle.studentList) {\r\n        if (courseId.equals(student.course)) {\r\n            students.add(student);\r\n        }\r\n    }\r\n    return students;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackEditPage.selectRecipientTypeForNewQuestionAndWaitForVisibilityMessageToLoad",
	"Comment": "selects the recipient type in the feedback path and waits for the corresponding visibility message to load.",
	"Method": "void selectRecipientTypeForNewQuestionAndWaitForVisibilityMessageToLoad(String recipientType){\r\n    WebElement selectElement = browser.driver.findElement(By.id(\"recipienttype-\" + NEW_QUESTION_NUM));\r\n    selectDropdownByVisibleValueAndHandleAjaxRequests(selectElement, recipientType);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.editor.ModelEditor.doSaveWithoutValidating",
	"Comment": "commits the pages and saves the config without running validationon the model.",
	"Method": "void doSaveWithoutValidating(IProgressMonitor monitor){\r\n    this.commitPages(monitor, true);\r\n    model.save(monitor);\r\n    this.editorDirtyStateChanged();\r\n}"
}, {
	"Path": "tlc2.util.List.cdr",
	"Comment": "this method is the cdr equivalent. it returns a new listof removing the first front element.",
	"Method": "List cdr(){\r\n    List newList = new List();\r\n    newList.first = this.first.next;\r\n    newList.last = (newList.first == null) ? null : this.last;\r\n    return newList;\r\n}"
}, {
	"Path": "teammates.test.driver.HtmlHelper.injectTestProperties",
	"Comment": "injects values specified in configuration files to the appropriate placeholders.",
	"Method": "String injectTestProperties(String content){\r\n    return content.replace(\"${studentmotd.url}\", Config.STUDENT_MOTD_URL).replace(\"${support.email}\", Config.SUPPORT_EMAIL).replace(\"${version}\", TestProperties.TEAMMATES_VERSION).replace(\"${test.admin}\", TestProperties.TEST_ADMIN_ACCOUNT).replace(\"${test.student1}\", TestProperties.TEST_STUDENT1_ACCOUNT).replace(\"${test.student2}\", TestProperties.TEST_STUDENT2_ACCOUNT).replace(\"${test.instructor}\", TestProperties.TEST_INSTRUCTOR_ACCOUNT);\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.FeedbackResponseAttributes.getFeedbackResponseDetailsClass",
	"Comment": "this method gets the appropriate class type for the feedbackresponsedetails objectfor this response.",
	"Method": "Class<? extends FeedbackResponseDetails> getFeedbackResponseDetailsClass(){\r\n    return feedbackQuestionType.getResponseDetailsClass();\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResponseStatus.getStudentsWhoDidNotRespond",
	"Comment": "returns list of students who did not respond to the feedback session.",
	"Method": "List<String> getStudentsWhoDidNotRespond(){\r\n    return studentsWhoDidNotRespond;\r\n}"
}, {
	"Path": "teammates.logic.api.Logic.putStudentDocuments",
	"Comment": "batch creates or updates search documents for the given students.",
	"Method": "void putStudentDocuments(List<StudentAttributes> students){\r\n    studentsLogic.putDocuments(students);\r\n}"
}, {
	"Path": "teammates.logic.core.TaskQueuesLogic.addDeferredTask",
	"Comment": "adds the given task, to be run after the specified time, to the specified queue.",
	"Method": "void addDeferredTask(TaskWrapper task,long countdownTime){\r\n    Queue requiredQueue = QueueFactory.getQueue(task.getQueueName());\r\n    TaskOptions taskToBeAdded = TaskOptions.Builder.withUrl(task.getWorkerUrl());\r\n    if (countdownTime > 0) {\r\n        taskToBeAdded.countdownMillis(countdownTime);\r\n    }\r\n    for (Map.Entry<String, String[]> entry : task.getParamMap().entrySet()) {\r\n        String name = entry.getKey();\r\n        String[] values = entry.getValue();\r\n        for (String value : values) {\r\n            taskToBeAdded = taskToBeAdded.param(name, value);\r\n        }\r\n    }\r\n    requiredQueue.add(taskToBeAdded);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.launch.TraceExplorerDelegate.finalLaunchCheck",
	"Comment": "we use this method to check for parsing errors and to determine the levelof each trace explorer expression, i.e. whether there are primed variables or not.if an expression is a temporal formula, this should show an error to the user.",
	"Method": "boolean finalLaunchCheck(ILaunchConfiguration configuration,String mode,IProgressMonitor monitor){\r\n    monitor.beginTask(\"Verifying model files\", 4);\r\n    final Model model = configuration.getAdapter(Model.class);\r\n    final IFile rootModule = model.getTEFile();\r\n    monitor.worked(1);\r\n    IParseResult parseResult = ToolboxHandle.parseModule(rootModule, new SubProgressMonitor(monitor, 1), false, false);\r\n    Assert.isTrue(parseResult instanceof ParseResult, \"Object returned by parsing the module is not an instance of ParseResult. This is not expected by the toolbox.\");\r\n    if (parseResult.getDetectedErrors().size() > 0) {\r\n        final StringBuffer errorMessage = new StringBuffer();\r\n        Iterator<TLAMarkerInformationHolder> it = parseResult.getDetectedErrors().iterator();\r\n        while (it.hasNext()) {\r\n            TLAMarkerInformationHolder errorInfo = it.next();\r\n            errorMessage.append(errorInfo.getMessage() + \"\\n\");\r\n        }\r\n        UIHelper.runUIAsync(new Runnable() {\r\n            public void run() {\r\n                MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Parsing error when running trace explorer\", errorMessage.toString());\r\n            }\r\n        });\r\n        return false;\r\n    }\r\n    OpDefNode[] opDefNodes = ((ParseResult) parseResult).getSpecObj().getExternalModuleTable().getRootModule().getOpDefs();\r\n    Hashtable<String, OpDefNode> nodeTable = new Hashtable<String, OpDefNode>(opDefNodes.length);\r\n    Assert.isNotNull(opDefNodes, \"OpDefNodes[] from parsing TE.tla is null. This is a bug.\");\r\n    for (int j = 0; j < opDefNodes.length; j++) {\r\n        String key = opDefNodes[j].getName().toString();\r\n        nodeTable.put(key, opDefNodes[j]);\r\n    }\r\n    Vector<TraceExpressionInformationHolder> levelThreeExpressions = new Vector<TraceExpressionInformationHolder>();\r\n    for (int i = 0; i < traceExpressionData.length; i++) {\r\n        OpDefNode opDefNode = (OpDefNode) nodeTable.get(traceExpressionData[i].getIdentifier());\r\n        int level = opDefNode.getBody().getLevel();\r\n        traceExpressionData[i].setLevel(level);\r\n        if (level == 3) {\r\n            levelThreeExpressions.add(traceExpressionData[i]);\r\n        }\r\n    }\r\n    if (!levelThreeExpressions.isEmpty()) {\r\n        final StringBuffer errorBuffer = new StringBuffer();\r\n        errorBuffer.append(\"The trace explorer cannot evaluate temporal formulas. The following expressions are temporal formulas:\\n\\n\");\r\n        Iterator<TraceExpressionInformationHolder> it = levelThreeExpressions.iterator();\r\n        while (it.hasNext()) {\r\n            TraceExpressionInformationHolder expressionInfo = it.next();\r\n            errorBuffer.append(expressionInfo.getExpression() + \"\\n\\n\");\r\n        }\r\n        UIHelper.runUIAsync(new Runnable() {\r\n            public void run() {\r\n                MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Temporal formulas found\", errorBuffer.toString());\r\n            }\r\n        });\r\n        return false;\r\n    }\r\n    ModelHelper.createOrClearFiles(new IFile[] { tlaFile, cfgFile, outFile }, monitor);\r\n    monitor.subTask(\"Creating contents\");\r\n    final TraceExpressionModelWriter writer = new TraceExpressionModelWriter();\r\n    writer.addInfoComments(traceExpressionData);\r\n    writer.addPrimer(ModelHelper.TE_MODEL_NAME, ResourceHelper.getModuleName(model.getSpec().getRootFilename()));\r\n    writeModelInfo(configuration, writer);\r\n    writer.addVariablesAndDefinitions(traceExpressionData, TRACE_EXPLORE_EXPRESSIONS, false);\r\n    writer.addInitNext(trace, traceExpressionData, initId, nextId);\r\n    SimpleTLCState finalState = (SimpleTLCState) trace.get(trace.size() - 1);\r\n    boolean isBackToState = finalState.isBackToState();\r\n    boolean isStuttering = finalState.isStuttering();\r\n    if (isStuttering) {\r\n        writer.addStutteringProperty((SimpleTLCState) trace.get(trace.size() - 2));\r\n    } else if (isBackToState) {\r\n        writer.addBackToStateProperty((SimpleTLCState) trace.get(trace.size() - 2), (SimpleTLCState) trace.get(finalState.getStateNumber() - 1));\r\n    } else {\r\n    }\r\n    writer.writeFiles(tlaFile, cfgFile, monitor);\r\n    IFolder modelFolder = model.getFolder();\r\n    modelFolder.refreshLocal(IResource.DEPTH_ONE, new SubProgressMonitor(monitor, 100));\r\n    configuration.getAdapter(Model.class).setOriginalTraceShown(false);\r\n    return true;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.launch.TraceExplorerDelegate.finalLaunchCheck",
	"Comment": "we use this method to check for parsing errors and to determine the levelof each trace explorer expression, i.e. whether there are primed variables or not.if an expression is a temporal formula, this should show an error to the user.",
	"Method": "boolean finalLaunchCheck(ILaunchConfiguration configuration,String mode,IProgressMonitor monitor){\r\n    MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Parsing error when running trace explorer\", errorMessage.toString());\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.launch.TraceExplorerDelegate.finalLaunchCheck",
	"Comment": "we use this method to check for parsing errors and to determine the levelof each trace explorer expression, i.e. whether there are primed variables or not.if an expression is a temporal formula, this should show an error to the user.",
	"Method": "boolean finalLaunchCheck(ILaunchConfiguration configuration,String mode,IProgressMonitor monitor){\r\n    MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Temporal formulas found\", errorBuffer.toString());\r\n}"
}, {
	"Path": "teammates.logic.core.CoursesLogic.getArchivedCourseIds",
	"Comment": "returns a list of courseids for all archived courses for all instructors.",
	"Method": "List<String> getArchivedCourseIds(List<CourseAttributes> allCourses,Map<String, InstructorAttributes> instructorsForCourses){\r\n    List<String> archivedCourseIds = new ArrayList();\r\n    for (CourseAttributes course : allCourses) {\r\n        InstructorAttributes instructor = instructorsForCourses.get(course.getId());\r\n        if (instructor.isArchived) {\r\n            archivedCourseIds.add(course.getId());\r\n        }\r\n    }\r\n    return archivedCourseIds;\r\n}"
}, {
	"Path": "com.twelvemonkeys.io.enc.DecoderStream.fill",
	"Comment": "fills the buffer, by decoding data from the underlying input stream.",
	"Method": "int fill(){\r\n    buffer.clear();\r\n    int read = decoder.decode(in, buffer);\r\n    if (read > buffer.capacity()) {\r\n        throw new AssertionError(String.format(\"Decode beyond buffer (%d): %d (using %s decoder)\", buffer.capacity(), read, decoder.getClass().getName()));\r\n    }\r\n    buffer.flip();\r\n    if (read == 0) {\r\n        return -1;\r\n    }\r\n    return read;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.editor.part.ValidateableTableSectionPart.doMakeDirty",
	"Comment": "marks the part dirty and hooks the validation method of the page",
	"Method": "void doMakeDirty(){\r\n    this.validate();\r\n    this.markDirty();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.handler.RenameSpecHandlerTest.openSpecExplorer",
	"Comment": "open spec explorer which is the only place to reach the rename action",
	"Method": "void openSpecExplorer(){\r\n    SWTBotMenu windowMenu = bot.menu(\"Window\");\r\n    SWTBotMenu specExplorerMenu = windowMenu.menu(SPEC_EXPLORER);\r\n    specExplorerMenu.click();\r\n    SWTBotView packageExplorerView = bot.viewByTitle(SPEC_EXPLORER);\r\n    packageExplorerView.setFocus();\r\n}"
}, {
	"Path": "tlc2.tool.liveness.TBPar.member",
	"Comment": "this method tests whether or not an expression is in a list of\texpressions.",
	"Method": "boolean member(LiveExprNode e){\r\n    for (int i = 0; i < this.size(); i++) {\r\n        if (e.equals(this.exprAt(i))) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.ExampleEditCommandHandler.verifyKey",
	"Comment": "listens for the first key to be pressed. if it is a digit, itfinds the word currently containing the caret and repeats that wordthe number of times equal to the digit pressed. if the key pressedis not a digit, this does nothing to the document andremoves itself from subsequent key events.",
	"Method": "void verifyKey(VerifyEvent event){\r\n    try {\r\n        event.doit = false;\r\n        if (event.stateMask == SWT.NONE && Character.isDigit(event.character)) {\r\n            int input = Character.getNumericValue(event.character);\r\n            ISelection selection = editor.getSelectionProvider().getSelection();\r\n            if (selection != null && selection instanceof ITextSelection) {\r\n                ITextSelection textSelection = (ITextSelection) selection;\r\n                IDocument document = editor.getDocumentProvider().getDocument(editor.getEditorInput());\r\n                if (textSelection.getLength() == 0 && document != null) {\r\n                    try {\r\n                        IRegion region = DocumentHelper.getRegionExpandedBoth(document, textSelection.getOffset());\r\n                        String insertionText = \" \" + document.get(region.getOffset(), region.getLength());\r\n                        StringBuilder sb = new StringBuilder();\r\n                        for (int i = 0; i < input; i++) {\r\n                            sb.append(insertionText);\r\n                        }\r\n                        document.replace(region.getOffset() + region.getLength(), 0, sb.toString());\r\n                    } catch (BadLocationException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        uninstall();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.swift.generator.SwiftGeneratorConfig.getIncludeSearchPaths",
	"Comment": "returns the list of uris used as prefixes to search for include files.",
	"Method": "Iterable<URI> getIncludeSearchPaths(){\r\n    return includeSearchPaths;\r\n}"
}, {
	"Path": "org.squirrelframework.foundation.component.SquirrelProvider.newInstance",
	"Comment": "create a new instance of the requested class using the internal registry.",
	"Method": "T newInstance(TypeReference<T> typeRef,T newInstance,TypeReference<T> typeRef,Class<?>[] argTypes,Object[] args,T newInstance,Class<T> clz,T newInstance,Class<T> clz,Class<?>[] argTypes,Object[] args){\r\n    Class<T> implementationClass = getImplementation(clz);\r\n    if (args == null) {\r\n        return postProcess(clz, ReflectUtils.newInstance(implementationClass));\r\n    }\r\n    Constructor<T> constructor = ReflectUtils.getConstructor(implementationClass, argTypes);\r\n    return postProcess(clz, ReflectUtils.newInstance(constructor, args));\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.proof.TLAProofPosition.containsInProof",
	"Comment": "returns whether the offset is contained on any of the linesof the proof. note that this position endsat the first offset of the line after the proof, but this methoddoes not consider that line part of the proof. the positionends at that offset for reasons explained in the constructor of this class.",
	"Method": "boolean containsInProof(int offset,IDocument document){\r\n    int startLine = document.getLineOfOffset(positionOfProof.getOffset());\r\n    int endLine = document.getLineOfOffset(positionOfProof.getOffset() + positionOfProof.getLength());\r\n    int lineOfOffset = document.getLineOfOffset(offset);\r\n    return lineOfOffset >= startLine && lineOfOffset <= endLine;\r\n}"
}, {
	"Path": "org.springframework.roo.project.maven.Pom.isPluginRepositoryRegistered",
	"Comment": "indicates whether the given plugin repository is registered.",
	"Method": "boolean isPluginRepositoryRegistered(Repository repository){\r\n    return pluginRepositories.contains(repository);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.util.EditorUtil.concatHeirTokens",
	"Comment": "returns the concatenation of the images of all leaf nodesof the node stn that correspond to actual tokens",
	"Method": "String concatHeirTokens(SyntaxTreeNode stn){\r\n    SyntaxTreeNode[] heirs = stn.getHeirs();\r\n    if (heirs.length == 0) {\r\n        if (stn.getKind() < SyntaxTreeConstants.NULL_ID) {\r\n            return stn.getImage();\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n    String val = \"\";\r\n    for (int i = 0; i < heirs.length; i++) {\r\n        val = val + concatHeirTokens(heirs[i]);\r\n    }\r\n    return val;\r\n}"
}, {
	"Path": "teammates.test.driver.BackDoor.getEncryptedKeyForInstructor",
	"Comment": "gets the encrypted registration key for an instructor in the datastore.",
	"Method": "String getEncryptedKeyForInstructor(String courseId,String instructorEmail){\r\n    Map<String, String> params = createParamMap(BackDoorOperation.OPERATION_GET_ENCRYPTED_KEY_FOR_INSTRUCTOR);\r\n    params.put(BackDoorOperation.PARAMETER_COURSE_ID, courseId);\r\n    params.put(BackDoorOperation.PARAMETER_INSTRUCTOR_EMAIL, instructorEmail);\r\n    return makePostRequest(params);\r\n}"
}, {
	"Path": "tlc2.util.List.car",
	"Comment": "this method is the car equivalent. it returns the firstelement of the list.",
	"Method": "Object car(){\r\n    return this.first.value;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.CourseSummaryBundle.sortSummarizedCoursesByCreationDate",
	"Comment": "sorts courses based on course creation date in the order of latest to oldest order.",
	"Method": "void sortSummarizedCoursesByCreationDate(List<CourseSummaryBundle> courses){\r\n    courses.sort(Comparator.comparing((CourseSummaryBundle obj) -> obj.course.createdAt).reversed());\r\n}"
}, {
	"Path": "tlc2.tool.CommonTestCase.assertStuttering",
	"Comment": "asserts that the error trace ends in stuttering at the given number.",
	"Method": "void assertStuttering(int stateNum){\r\n    assertTrue(recorder.recorded(EC.TLC_STATE_PRINT3));\r\n    List<Object> stutter = recorder.getRecords(EC.TLC_STATE_PRINT3);\r\n    assertTrue(stutter.size() > 0);\r\n    Object[] object = (Object[]) stutter.get(0);\r\n    assertEquals(stateNum, object[1]);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.navigator.ToolboxExplorer.getInitialInput",
	"Comment": "override the method to deliver the root object for the nce activation",
	"Method": "Object getInitialInput(){\r\n    return Activator.getSpecManager();\r\n}"
}, {
	"Path": "tlc2.tool.SimulationWorker.randomNextStates",
	"Comment": "this method returns the set of next states generated by a randomly chosen\taction. it returns null if there is no possible next state.",
	"Method": "StateVec randomNextStates(RandomGenerator rng,TLCState state){\r\n    final Action[] actions = this.tool.getActions();\r\n    final int len = actions.length;\r\n    int index = (int) Math.floor(rng.nextDouble() * len);\r\n    final int p = rng.nextPrime();\r\n    for (int i = 0; i < len; i++) {\r\n        final StateVec pstates = this.tool.getNextStates(actions[index], state);\r\n        if (!pstates.empty()) {\r\n            return pstates;\r\n        }\r\n        index = (index + p) % len;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.StudentAttributesFactory.makeStudent",
	"Comment": "return a studentattributes object created from the given enrollline.",
	"Method": "StudentAttributes makeStudent(String enrollLine,String courseId){\r\n    if (enrollLine.isEmpty()) {\r\n        throw new EnrollException(ERROR_ENROLL_LINE_EMPTY);\r\n    }\r\n    String[] columns = splitLineIntoColumns(enrollLine);\r\n    boolean hasMissingFields = columns.length <= teamColumnIndex || columns.length <= nameColumnIndex || columns.length <= emailColumnIndex;\r\n    if (hasMissingFields) {\r\n        throw new EnrollException(ERROR_ENROLL_LINE_TOOFEWPARTS);\r\n    }\r\n    String paramTeam = StringHelper.removeExtraSpace(columns[teamColumnIndex]);\r\n    String paramName = StringHelper.removeExtraSpace(columns[nameColumnIndex]);\r\n    String paramEmail = StringHelper.removeExtraSpace(columns[emailColumnIndex]);\r\n    String paramComment = \"\";\r\n    if (hasComment && columns.length > commentColumnIndex) {\r\n        paramComment = StringHelper.removeExtraSpace(columns[commentColumnIndex]);\r\n    }\r\n    String paramSection;\r\n    if (hasSection && columns.length > sectionColumnIndex && !columns[sectionColumnIndex].isEmpty()) {\r\n        paramSection = StringHelper.removeExtraSpace(columns[sectionColumnIndex]);\r\n    } else {\r\n        paramSection = Const.DEFAULT_SECTION;\r\n    }\r\n    return StudentAttributes.builder(courseId, paramName, paramEmail).withTeam(paramTeam).withSection(paramSection).withComments(paramComment).build();\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.isExpectedCondition",
	"Comment": "returns true if the expected condition is evaluated to true immediately.",
	"Method": "boolean isExpectedCondition(ExpectedCondition<?> expectedCondition){\r\n    Object value = expectedCondition.apply(browser.driver);\r\n    if (value == null) {\r\n        return false;\r\n    }\r\n    if (value.getClass() == Boolean.class) {\r\n        return (boolean) value;\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackRubricQuestionDetails.filterResponsesForStatistics",
	"Comment": "returns a list of feedbackresponseattributes filtered according to view, question recipient typefor the statistics table.",
	"Method": "List<FeedbackResponseAttributes> filterResponsesForStatistics(List<FeedbackResponseAttributes> responses,FeedbackQuestionAttributes question,String studentEmail,FeedbackSessionResultsBundle bundle,String view){\r\n    boolean isViewedByStudent = \"student\".equals(view);\r\n    if (!isViewedByStudent) {\r\n        return responses;\r\n    }\r\n    FeedbackParticipantType recipientType = question.getRecipientType();\r\n    boolean isFilteringSkipped = recipientType.equals(FeedbackParticipantType.INSTRUCTORS) || recipientType.equals(FeedbackParticipantType.NONE) || recipientType.equals(FeedbackParticipantType.SELF);\r\n    if (isFilteringSkipped) {\r\n        return responses;\r\n    }\r\n    boolean isFilteringByTeams = recipientType.equals(FeedbackParticipantType.OWN_TEAM) || recipientType.equals(FeedbackParticipantType.TEAMS);\r\n    List<FeedbackResponseAttributes> receivedResponses = new ArrayList();\r\n    String recipientString = isFilteringByTeams ? bundle.getTeamNameForEmail(studentEmail) : studentEmail;\r\n    for (FeedbackResponseAttributes response : responses) {\r\n        boolean isReceivedResponse = response.recipient.equals(recipientString);\r\n        if (isReceivedResponse) {\r\n            receivedResponses.add(response);\r\n        }\r\n    }\r\n    return receivedResponses;\r\n}"
}, {
	"Path": "tlc2.tool.liveness.LiveWorker.setErrFound",
	"Comment": "returns true iff either an error has not been found or the error is found\tby this thread.\tthis is used so that only one of the threads which have found an error\tprints it.",
	"Method": "boolean setErrFound(){\r\n    synchronized (workerLock) {\r\n        if (errFoundByThread == -1) {\r\n            errFoundByThread = this.myGetId();\r\n            return true;\r\n        } else if (errFoundByThread == this.myGetId()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.preference.SWTFactory.showPropertiesDialog",
	"Comment": "this method allows us to open a property page in the default platform dialog",
	"Method": "void showPropertiesDialog(Shell shell,String id,IAdaptable element,Object data){\r\n    PreferencesUtil.createPropertyDialogOn(shell, element, id, new String[] { id }, data).open();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.actions.ExampleEditorAction.verifyKey",
	"Comment": "listens for the first key to be pressed. if it is a digit, itfinds the word currently containing the caret and repeats that wordthe number of times equal to the digit pressed.",
	"Method": "void verifyKey(VerifyEvent event){\r\n    event.doit = false;\r\n    if (event.stateMask == SWT.NONE && Character.isDigit(event.character)) {\r\n        int input = Character.getNumericValue(event.character);\r\n        ISelection selection = getTextEditor().getSelectionProvider().getSelection();\r\n        if (selection != null && selection instanceof ITextSelection) {\r\n            ITextSelection textSelection = (ITextSelection) selection;\r\n            IDocument document = getTextEditor().getDocumentProvider().getDocument(getTextEditor().getEditorInput());\r\n            if (textSelection.getLength() == 0 && document != null) {\r\n                try {\r\n                    IRegion region = DocumentHelper.getRegionExpandedBoth(document, textSelection.getOffset());\r\n                    String insertionText = \" \" + document.get(region.getOffset(), region.getLength());\r\n                    StringBuilder sb = new StringBuilder();\r\n                    for (int i = 0; i < input; i++) {\r\n                        sb.append(insertionText);\r\n                    }\r\n                    document.replace(region.getOffset() + region.getLength(), 0, sb.toString());\r\n                } catch (BadLocationException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    ((TLAEditor) getTextEditor()).getViewer().removeVerifyKeyListener(this);\r\n    statusLine.setMessage(\"\");\r\n}"
}, {
	"Path": "tla2sany.modanalyzer.ModuleContext.union",
	"Comment": "add elements of unionee modulecontext to this modulecontext,without overwriting in cases where keys overlap between this and unionee",
	"Method": "void union(ModuleContext unionee){\r\n    Enumeration Enum = unionee.context.keys();\r\n    while (Enum.hasMoreElements()) {\r\n        String key = (String) Enum.nextElement();\r\n        this.bindIfNotBound(key, unionee.resolve(key));\r\n    }\r\n}"
}, {
	"Path": "teammates.logic.core.AdminEmailsLogic.moveAdminEmailOutOfTrashBin",
	"Comment": "move an admin email out of trash bin.after this the attribute isintrashbin will be set to false",
	"Method": "void moveAdminEmailOutOfTrashBin(String adminEmailId){\r\n    Assumption.assertNotNull(adminEmailId);\r\n    AdminEmailAttributes adminEmailToUpdate = getAdminEmailById(adminEmailId);\r\n    if (adminEmailToUpdate != null) {\r\n        adminEmailToUpdate.isInTrashBin = false;\r\n        adminEmailsDb.updateAdminEmail(adminEmailToUpdate);\r\n    }\r\n}"
}, {
	"Path": "tla2sany.semantic.ThmOrAssumpDefNode.export",
	"Comment": "overrides levelnode.export and exports a uid reference instad of the full version",
	"Method": "Element export(Document doc,SymbolContext context){\r\n    context.put(this, doc);\r\n    Element e = doc.createElement(getNodeRef());\r\n    e.appendChild(appendText(doc, \"UID\", Integer.toString(myUID)));\r\n    return e;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes.getCommentAsCsvString",
	"Comment": "converts comment text in form of string for csv i.e if it contains image, changes it into link.",
	"Method": "String getCommentAsCsvString(){\r\n    String htmlText = commentText;\r\n    StringBuilder comment = new StringBuilder(200);\r\n    comment.append(Jsoup.parse(htmlText).text());\r\n    convertImageToLinkInComment(comment, htmlText);\r\n    return SanitizationHelper.sanitizeForCsv(comment.toString());\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorCourseStudentDetailsEditPage.fillStudentDetailsForm",
	"Comment": "if the parameter value is not null, the value will be filled into therelevant input field.",
	"Method": "void fillStudentDetailsForm(String studentName,String teamName,String studentEmail,String comments){\r\n    if (studentName != null) {\r\n        fillTextBox(studentNameTextbox, studentName);\r\n    }\r\n    if (teamName != null) {\r\n        fillTextBox(teamNameTextbox, teamName);\r\n    }\r\n    if (studentEmail != null) {\r\n        fillTextBox(studentEmailTextbox, studentEmail);\r\n    }\r\n    if (comments != null) {\r\n        fillTextBox(commentsTextbox, comments);\r\n    }\r\n    if (teamName == null) {\r\n        if (studentEmail == null) {\r\n            click(submitButton);\r\n        } else {\r\n            clickAndConfirm(submitButton);\r\n        }\r\n    } else {\r\n        clickAndConfirmWithoutWaitingForModalDisappearance(submitButton);\r\n        if (studentEmail != null) {\r\n            clickNoOnModal();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.BoxedCommentHandler.unboxComment",
	"Comment": "removes the box from a comment in the obvious way so that boxing it\tshould produce the same result. however, anything outside the box but on\tthe same line as the box will be deleted, except for text preceding the\tfirst line of the box or following the last line.",
	"Method": "void unboxComment(){\r\n    if ((offset > 2) && (text.charAt(offset) == ')')) {\r\n        offset--;\r\n    }\r\n    if ((offset > 1) && (text.charAt(offset) == '*')) {\r\n        offset--;\r\n    }\r\n    String errorMsg = \"Unbox Coment command called when not inside a boxed comment.\";\r\n    int startOffset = text.lastIndexOf(\"(**\", offset);\r\n    int endOffset = text.indexOf(\"**)\", offset) + 3;\r\n    if ((startOffset < 0) || (endOffset < 0)) {\r\n        displayNotInBoxedCommentError(errorMsg);\r\n        return;\r\n    }\r\n    int startIndent = startOffset - doc.getLineOffset(doc.getLineOfOffset(startOffset));\r\n    int asteriskLength = RightMargin - startIndent - 1;\r\n    String asterisks = StringHelper.copyString(\"*\", asteriskLength);\r\n    int beginLine = doc.getLineOfOffset(startOffset);\r\n    int endLine = doc.getLineOfOffset(endOffset);\r\n    if (beginLine == endLine) {\r\n        if (text.substring(startOffset + 1, endOffset - 1).equals(StringHelper.copyString(\"*\", endOffset - startOffset - 2))) {\r\n            displayNotInBoxedCommentError(\"You are at the beginning or ending line of a boxed comment,\\n\" + \"not inside the boxed comment\");\r\n        } else {\r\n            displayNotInBoxedCommentError(errorMsg);\r\n        }\r\n        return;\r\n    }\r\n    StringBuffer buffer = null;\r\n    int bufferSize = endOffset - startOffset - 6 * (endLine - beginLine);\r\n    if (bufferSize > 0) {\r\n        buffer = new StringBuffer(bufferSize);\r\n    } else {\r\n        buffer = new StringBuffer();\r\n    }\r\n    buffer.append(asterisks);\r\n    buffer.append(StringHelper.newline);\r\n    for (int i = beginLine + 1; i < endLine; i++) {\r\n        IRegion lineInfo = doc.getLineInformation(i);\r\n        String currentLine = doc.get(lineInfo.getOffset(), lineInfo.getLength());\r\n        int beginTokenIndex = currentLine.indexOf(\"(*\");\r\n        int endTokenIndex = currentLine.indexOf(\"*)\");\r\n        if ((!(beginTokenIndex < 0)) && (!(beginTokenIndex > endTokenIndex))) {\r\n            buffer.append(StringHelper.trimEnd(currentLine.substring(beginTokenIndex + 3, endTokenIndex)));\r\n            buffer.append(StringHelper.newline);\r\n        } else {\r\n            buffer.append(currentLine);\r\n            buffer.append(StringHelper.newline);\r\n        }\r\n    }\r\n    buffer.append(StringHelper.copyString(\" \", startIndent));\r\n    buffer.append(asterisks);\r\n    doc.replace(startOffset + 1, endOffset - 2 - startOffset, buffer.toString());\r\n    return;\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.MapAbstractTest.makeObject",
	"Comment": "implements the superclass method to return the map to be tested.",
	"Method": "Object makeObject(){\r\n    return makeEmptyMap();\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.MemberFindingUtils.getFieldsWithAnnotation",
	"Comment": "searches up the inheritance hierarchy and locates all declared fieldswhich are annotated with the specified annotation.",
	"Method": "List<FieldMetadata> getFieldsWithAnnotation(MemberHoldingTypeDetails memberHoldingTypeDetails,JavaType annotation){\r\n    return memberHoldingTypeDetails.getFieldsWithAnnotation(annotation);\r\n}"
}, {
	"Path": "tla2sany.modanalyzer.ModulePointer.getContext",
	"Comment": "returns context for module referred to by this modulepointer",
	"Method": "ModuleContext getContext(){\r\n    return moduleRelatives.context;\r\n}"
}, {
	"Path": "teammates.ui.controller.InstructorFeedbackAbstractAction.loadCourseInstructorMap",
	"Comment": "gets a map with courseid as key, and instructorattributes as value.",
	"Method": "Map<String, InstructorAttributes> loadCourseInstructorMap(boolean omitArchived){\r\n    HashMap<String, InstructorAttributes> courseInstructorMap = new HashMap();\r\n    List<InstructorAttributes> instructors = logic.getInstructorsForGoogleId(account.googleId, omitArchived);\r\n    for (InstructorAttributes instructor : instructors) {\r\n        courseInstructorMap.put(instructor.courseId, instructor);\r\n    }\r\n    return courseInstructorMap;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.util.BufferedDocumentScanner.setRange",
	"Comment": "configures the scanner by providing access to the document range over\twhich to scan.",
	"Method": "void setRange(IDocument document,int offset,int length){\r\n    fDocument = document;\r\n    fRangeOffset = offset;\r\n    fRangeLength = length;\r\n    String[] delimiters = document.getLegalLineDelimiters();\r\n    fDelimiters = new char[delimiters.length][];\r\n    for (int i = 0; i < delimiters.length; i++) fDelimiters[i] = delimiters[i].toCharArray();\r\n    updateBuffer(offset);\r\n    fOffset = 0;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.editor.part.ValidateableTableSectionPart.doEditFormula",
	"Comment": "opens a dialog for formula processing and returns the edited formula",
	"Method": "Formula doEditFormula(Formula formula){\r\n    FormulaWizard wizard = new FormulaWizard(getSection().getText(), getSection().getDescription());\r\n    wizard.setFormula(formula);\r\n    WizardDialog dialog = new WizardDialog(getTableViewer().getTable().getShell(), wizard);\r\n    dialog.setHelpAvailable(true);\r\n    if (Window.OK == dialog.open()) {\r\n        return wizard.getFormula();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionQuestionsBundle.hideUnmoderatableQuestions",
	"Comment": "removes question from the bundle if the question has givers or recipients that are anonymous to the instructoror responses that are hidden from the instructor.",
	"Method": "void hideUnmoderatableQuestions(){\r\n    List<FeedbackQuestionAttributes> questionsToHide = new ArrayList();\r\n    for (FeedbackQuestionAttributes question : questionResponseBundle.keySet()) {\r\n        boolean isGiverVisibleToInstructor = question.showGiverNameTo.contains(FeedbackParticipantType.INSTRUCTORS);\r\n        boolean isRecipientVisibleToInstructor = question.showRecipientNameTo.contains(FeedbackParticipantType.INSTRUCTORS);\r\n        boolean isResponseVisibleToInstructor = question.showResponsesTo.contains(FeedbackParticipantType.INSTRUCTORS);\r\n        if (!isResponseVisibleToInstructor || !isGiverVisibleToInstructor || !isRecipientVisibleToInstructor) {\r\n            questionsToHide.add(question);\r\n            questionResponseBundle.put(question, new ArrayList());\r\n        }\r\n    }\r\n    questionResponseBundle.keySet().removeAll(questionsToHide);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.property.GenericFieldEditorPropertyPage.performDefaults",
	"Comment": "the field editor preference page implementation of a preferencepagemethod loads all the field editors with their default values.",
	"Method": "void performDefaults(){\r\n    if (fields != null) {\r\n        Iterator e = fields.iterator();\r\n        while (e.hasNext()) {\r\n            FieldEditor pe = (FieldEditor) e.next();\r\n            pe.loadDefault();\r\n        }\r\n    }\r\n    checkState();\r\n    super.performDefaults();\r\n}"
}, {
	"Path": "teammates.test.cases.browsertests.StudentCourseJoinConfirmationPageUiTest.getKeyFromBackDoor",
	"Comment": "continuously ask backdoor to get the key until a legit key is returned",
	"Method": "String getKeyFromBackDoor(String courseId,String studentEmail){\r\n    int numberOfRemainingRetries = 10;\r\n    String key = \"[BACKDOOR_STATUS_FAILURE]\";\r\n    while (key.startsWith(\"[BACKDOOR_STATUS_FAILURE]\") && numberOfRemainingRetries > 0) {\r\n        key = BackDoor.getEncryptedKeyForStudent(courseId, studentEmail);\r\n        numberOfRemainingRetries--;\r\n        ThreadHelper.waitFor(100);\r\n    }\r\n    return key;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.isElementCovered",
	"Comment": "checks if the midpoint of an element is covered by any other element.",
	"Method": "boolean isElementCovered(WebElement element){\r\n    int x = element.getLocation().x + element.getSize().width / 2;\r\n    int y = element.getLocation().y + element.getSize().height / 2;\r\n    WebElement topElem = (WebElement) executeScript(\"return document.elementFromPoint(\" + x + \",\" + y + \");\");\r\n    return !topElem.equals(element);\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.injectStructFields",
	"Comment": "defines the code to inject data into the struct public fields.",
	"Method": "void injectStructFields(MethodDefinition read,LocalVariableDefinition instance,Map<Short, LocalVariableDefinition> structData){\r\n    for (ThriftFieldMetadata field : metadata.getFields(THRIFT_FIELD)) {\r\n        injectField(read, field, instance, structData.get(field.getId()));\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.traceexplorer.TraceExplorerComposite.sectionInitialize",
	"Comment": "constructs the section contentthis consists of setting the layout for the client area of the section, creating the tablefor the section, creating the table viewer, and creating the buttons.",
	"Method": "void sectionInitialize(FormToolkit toolkit){\r\n    GridData gd;\r\n    Composite sectionArea = (Composite) section.getClient();\r\n    sectionArea.setLayout(new GridLayout(2, false));\r\n    Table table = createTable(sectionArea, toolkit);\r\n    gd = new GridData(GridData.FILL_BOTH);\r\n    gd.grabExcessHorizontalSpace = true;\r\n    gd.grabExcessVerticalSpace = true;\r\n    gd.verticalSpan = 5;\r\n    table.setLayoutData(gd);\r\n    tableViewer = createTableViewer(table);\r\n    createButtons(sectionArea, toolkit);\r\n    changeButtonEnablement();\r\n}"
}, {
	"Path": "tla2sany.semantic.SubstInNode.getSubWith",
	"Comment": "returns the exproropargnode of the ith element of thesubstitution list.",
	"Method": "ExprOrOpArgNode getSubWith(int i){\r\n    return this.substs[i].getExpr();\r\n}"
}, {
	"Path": "org.springframework.roo.shell.SimpleParser.hasToReloadComponents",
	"Comment": "this method compares roobundleactivator lasttimebundlechange withsimpleparser lastimeupdatecommands",
	"Method": "boolean hasToReloadComponents(){\r\n    if (getRooBundleActivator() != null) {\r\n        return getRooBundleActivator().getLastTimeBundleChange() > getLasTimeUpdateComponents();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "tla2sany.semantic.AssumeNode.export",
	"Comment": "overrides levelnode.export and exports a uid reference instad of the full version",
	"Method": "Element export(Document doc,SymbolContext context){\r\n    context.put(this, doc);\r\n    Element e = doc.createElement(getNodeRef());\r\n    e.appendChild(appendText(doc, \"UID\", Integer.toString(myUID)));\r\n    return e;\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.swipe_refresh_layout.SwipeProgressBar.setTriggerPercentage",
	"Comment": "update the progress the user has made toward triggering the swipegesture. and use this value to update the percentage of the trigger thatis shown.",
	"Method": "void setTriggerPercentage(float triggerPercentage){\r\n    mTriggerPercentage = triggerPercentage;\r\n    mStartTime = 0;\r\n    ViewCompat.postInvalidateOnAnimation(mParent);\r\n}"
}, {
	"Path": "tla2sany.semantic.APSubstInNode.getSubWith",
	"Comment": "returns the exproropargnode of the ith element of thesubstitution list.",
	"Method": "ExprOrOpArgNode getSubWith(int i){\r\n    return this.substs[i].getExpr();\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.LRUHashMap.setMaxSize",
	"Comment": "sets the maximum number of elements in this map.if the current size is greater than the new max size, the map will betrimmed to fit the new max size constraint.",
	"Method": "void setMaxSize(int pMaxSize){\r\n    if (pMaxSize < 0) {\r\n        throw new IllegalArgumentException(\"max size must be positive\");\r\n    }\r\n    maxSize = pMaxSize;\r\n    while (size() > maxSize) {\r\n        removeLRU();\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.distributed.fp.FPSetManager.executeCallablesAndCollect",
	"Comment": "executes the given solvers by using the executor service. afterwards it\twaits for completion and collects the results.",
	"Method": "BitVector[] executeCallablesAndCollect(ExecutorService executorService,List<Callable<BitVectorWrapper>> solvers){\r\n    int retry = 0;\r\n    final CompletionService<BitVectorWrapper> ecs = new ExecutorCompletionService<BitVectorWrapper>(executorService);\r\n    for (int i = 0; i < solvers.size(); i++) {\r\n        final Callable<BitVectorWrapper> s = solvers.get(i);\r\n        try {\r\n            ecs.submit(s);\r\n            retry = 0;\r\n        } catch (RejectedExecutionException e) {\r\n            if (retry++ < 3 && !executorService.isShutdown()) {\r\n                int sleep = 1 + rnd.nextInt(5);\r\n                LOGGER.log(Level.FINE, \"{0}. time throttleing task submission due to overload during FPSetManager callable execution #{1} for {2} seconds\", new Object[] { retry, i });\r\n                try {\r\n                    Thread.sleep(sleep * 1000L);\r\n                } catch (InterruptedException e1) {\r\n                    e1.printStackTrace();\r\n                }\r\n                i -= 1;\r\n                continue;\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    final BitVector[] res = new BitVector[solvers.size()];\r\n    for (int i = 0; i < res.length; i++) {\r\n        try {\r\n            final BitVectorWrapper indexBitVector = ecs.take().get();\r\n            final int index = indexBitVector.getIndex();\r\n            Assert.check(res[index] == null, EC.GENERAL);\r\n            res[index] = indexBitVector.getBitVector();\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (ExecutionException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.output.data.TLCVariableValue.diff",
	"Comment": "the recursive method called by innerdiff that diffs the subobjects of\tthe variable value objects to indicate which rows of\tthe hierarchical trace table should be highlighted to show the parts of\tthe state that have changed.",
	"Method": "void diff(TLCVariableValue other){\r\n    if (!this.toSimpleString().equals(other.toSimpleString())) {\r\n        other.setChanged();\r\n        if (this.getClass().equals(other.getClass())) {\r\n            innerDiff(other);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.InstructorPrivileges.isAllowedForPrivilege",
	"Comment": "returns true if it is allowed for the privilege specified by privilegename for sessionname in sectionname.",
	"Method": "boolean isAllowedForPrivilege(String privilegeName,boolean isAllowedForPrivilege,String sectionName,String privilegeName,boolean isAllowedForPrivilege,String sectionName,String sessionName,String privilegeName){\r\n    return isAllowedInSessionLevel(sectionName, sessionName, privilegeName);\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.plugins.tiff.TIFFImageMetadata.getTIFFField",
	"Comment": "returns an entry which contains the data of the requested tiff field.",
	"Method": "Entry getTIFFField(int tagNumber){\r\n    return ifd.getEntryById(tagNumber);\r\n}"
}, {
	"Path": "tlc2.tool.Tool.init",
	"Comment": "initialization. any tool object must call it before doing anything.",
	"Method": "SpecObj init(boolean preprocess,SpecObj spec){\r\n    SpecObj processSpec = super.processSpec(spec);\r\n    if (TLCGlobals.isCoverageEnabled()) {\r\n        TLCStateMutSource.init(this);\r\n    } else {\r\n        TLCStateMut.init(this);\r\n    }\r\n    if (preprocess) {\r\n        this.processConstantDefns();\r\n    }\r\n    super.processConfig();\r\n    return processSpec;\r\n}"
}, {
	"Path": "tla2sany.drivers.SANY.SANYmain",
	"Comment": "main driver method for maintainers and debuggers of the tlafrontend.calls frontendmain for each file named on the command line and then, barring errors too severe, calls the explorer tool with the resulting externalmoduletable.",
	"Method": "void SANYmain(String args){\r\n    int i;\r\n    for (i = 0; (i < args.length) && (args[i].charAt(0) == '-'); i++) {\r\n        if (args[i].equals(\"-S\") || args[i].equals(\"-s\"))\r\n            doSemanticAnalysis = !doSemanticAnalysis;\r\n        else if (args[i].equals(\"-L\") || args[i].equals(\"-l\"))\r\n            doLevelChecking = !doLevelChecking;\r\n        else if (args[i].equals(\"-D\") || args[i].equals(\"-d\"))\r\n            doDebugging = !doDebugging;\r\n        else if (args[i].equals(\"-STAT\") || args[i].equals(\"-stat\"))\r\n            doStats = !doStats;\r\n        else {\r\n            ToolIO.out.println(\"Illegal switch: \" + args[i]);\r\n            System.exit(-1);\r\n        }\r\n    }\r\n    for (; i < args.length; i++) {\r\n        ToolIO.out.println(\"\\n****** SANY2 \" + version + \"\\n\");\r\n        SpecObj spec = new SpecObj(args[i], null);\r\n        if (FileUtil.createNamedInputStream(args[i], spec.getResolver()) != null) {\r\n            try {\r\n                int ret = frontEndMain(spec, args[i], ToolIO.out);\r\n                if (ret != 0) {\r\n                    System.exit(ret);\r\n                }\r\n            } catch (FrontEndException fe) {\r\n                fe.printStackTrace();\r\n                ToolIO.out.println(fe);\r\n                System.exit(-1);\r\n            }\r\n            if (doStats)\r\n                frontEndStatistics(spec);\r\n            if (doDebugging) {\r\n                Explorer explorer = new Explorer(spec.getExternalModuleTable());\r\n                try {\r\n                    explorer.main(args);\r\n                } catch (ExplorerQuitException e) {\r\n                }\r\n            }\r\n        } else {\r\n            ToolIO.out.println(\"Cannot find the specified file \" + args[i] + \".\");\r\n            System.exit(-1);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.DecomposeProofHandler.createdAssumptions",
	"Comment": "returns string array such that applying stringarraytostring to itproduces the text of the list of assumptions in createdassumps ofthe spec of makeproof.",
	"Method": "String[] createdAssumptions(){\r\n    Boolean sufficesSelected = useSufficesButton.getSelection();\r\n    Vector<String[]> vec = new Vector<String[]>();\r\n    int lastAddedAssump = state.assumeReps.size();\r\n    if (state.splitChosen()) {\r\n        lastAddedAssump--;\r\n    }\r\n    for (int i = state.firstAddedAssumption; i < lastAddedAssump; i++) {\r\n        NodeRepresentation rep = state.assumeReps.elementAt(i);\r\n        String newDecls = null;\r\n        while (rep.onSameLineAsNext) {\r\n            if (newDecls != null) {\r\n                newDecls = newDecls + \", \";\r\n            } else {\r\n                newDecls = \"\";\r\n            }\r\n            newDecls = newDecls + rep.nodeText[0];\r\n            i++;\r\n            rep = state.assumeReps.elementAt(i);\r\n        }\r\n        if (newDecls == null) {\r\n            vec.add(rep.primedNodeText());\r\n        } else {\r\n            vec.add(new String[] { newDecls + \", \" + rep.nodeText[0] });\r\n        }\r\n    }\r\n    Vector<String> resVec = new Vector<String>();\r\n    for (int i = 0; i < vec.size(); i++) {\r\n        String[] strArray = vec.elementAt(i);\r\n        for (int j = 0; j < strArray.length; j++) {\r\n            String str = strArray[j];\r\n            if ((j == strArray.length - 1) && (i != vec.size() - 1)) {\r\n                str = str + \",\";\r\n            }\r\n            resVec.add(str);\r\n        }\r\n    }\r\n    String[] result = new String[resVec.size()];\r\n    for (int i = 0; i < result.length; i++) {\r\n        result[i] = resVec.elementAt(i);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.squirrelframework.foundation.util.Base64Coder.decode",
	"Comment": "decodes a byte array from base64 format. no blanks or line breaks areallowed within the base64 encoded input data.",
	"Method": "byte[] decode(String s,byte[] decode,char[] in,byte[] decode,char[] in,int iOff,int iLen){\r\n    if (iLen % 4 != 0)\r\n        throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n    while (iLen > 0 && in[iOff + iLen - 1] == '=') iLen--;\r\n    int oLen = (iLen * 3) / 4;\r\n    byte[] out = new byte[oLen];\r\n    int ip = iOff;\r\n    int iEnd = iOff + iLen;\r\n    int op = 0;\r\n    while (ip < iEnd) {\r\n        int i0 = in[ip++];\r\n        int i1 = in[ip++];\r\n        int i2 = ip < iEnd ? in[ip++] : 'A';\r\n        int i3 = ip < iEnd ? in[ip++] : 'A';\r\n        if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)\r\n            throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n        int b0 = map2[i0];\r\n        int b1 = map2[i1];\r\n        int b2 = map2[i2];\r\n        int b3 = map2[i3];\r\n        if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)\r\n            throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n        int o0 = (b0 << 2) | (b1 >>> 4);\r\n        int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);\r\n        int o2 = ((b2 & 3) << 6) | b3;\r\n        out[op++] = (byte) o0;\r\n        if (op < oLen)\r\n            out[op++] = (byte) o1;\r\n        if (op < oLen)\r\n            out[op++] = (byte) o2;\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "teammates.test.driver.BackDoor.deleteGroupListFile",
	"Comment": "deletes the uploaded test file for testing email using group mode.",
	"Method": "String deleteGroupListFile(String groupListFileKey){\r\n    Map<String, String> params = createParamMap(BackDoorOperation.OPERATION_DELETE_GROUP_LIST_FILE);\r\n    params.put(BackDoorOperation.PARAMETER_GROUP_LIST_FILE_KEY, groupListFileKey);\r\n    return makePostRequest(params);\r\n}"
}, {
	"Path": "teammates.common.util.Version.compareVersionString",
	"Comment": "compares version numbers.if their length are different, 0s will be appended in front of shorter string untilthe length are the same.",
	"Method": "int compareVersionString(String s1,String s2){\r\n    if (s1 == null && s2 == null) {\r\n        return 0;\r\n    }\r\n    if (s1 == null) {\r\n        return 1;\r\n    }\r\n    if (s2 == null) {\r\n        return -1;\r\n    }\r\n    String convertedS1;\r\n    String convertedS2;\r\n    if (s1.length() == s2.length()) {\r\n        convertedS1 = s1;\r\n        convertedS2 = s2;\r\n    } else if (s1.length() > s2.length()) {\r\n        convertedS1 = s1;\r\n        convertedS2 = StringHelper.generateStringOfLength(s1.length() - s2.length(), '0') + s2;\r\n    } else {\r\n        convertedS1 = StringHelper.generateStringOfLength(s2.length() - s1.length(), '0') + s1;\r\n        convertedS2 = s2;\r\n    }\r\n    return convertedS2.compareTo(convertedS1);\r\n}"
}, {
	"Path": "teammates.logic.core.AccountsLogic.deleteAccountCascade",
	"Comment": "deletes both instructor and student privileges, as long as the account and associated student profile.does not delete courses, which can result in orphan courses.fails silently if no such account.",
	"Method": "void deleteAccountCascade(String googleId){\r\n    profilesLogic.deleteStudentProfile(googleId);\r\n    instructorsLogic.deleteInstructorsForGoogleIdAndCascade(googleId);\r\n    studentsLogic.deleteStudentsForGoogleIdAndCascade(googleId);\r\n    accountsDb.deleteAccount(googleId);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.util.ModelHelper.getSectionNameFromAttributeName",
	"Comment": "this gets the title of the section in the model editorcorresponding to the attributename.",
	"Method": "String getSectionNameFromAttributeName(String attributeName){\r\n    if (attributeName.equals(MODEL_CORRECTNESS_INVARIANTS)) {\r\n        return \"Invariants\";\r\n    } else if (attributeName.equals(MODEL_CORRECTNESS_PROPERTIES)) {\r\n        return \"Properties\";\r\n    } else if (attributeName.equals(MODEL_PARAMETER_ACTION_CONSTRAINT)) {\r\n        return \"Action Contraint\";\r\n    } else if (attributeName.equals(MODEL_PARAMETER_CONSTRAINT)) {\r\n        return \"Constraint\";\r\n    } else if (attributeName.equals(MODEL_PARAMETER_CONSTANTS)) {\r\n        return \"What is the model?\";\r\n    } else if (attributeName.equals(MODEL_PARAMETER_DEFINITIONS)) {\r\n        return \"Definition Override\";\r\n    } else if (attributeName.equals(MODEL_PARAMETER_NEW_DEFINITIONS)) {\r\n        return \"Additional Definitions\";\r\n    } else if (attributeName.equals(MODEL_PARAMETER_MODEL_VALUES)) {\r\n        return \"Model Values\";\r\n    } else if (attributeName.equals(MODEL_BEHAVIOR_CLOSED_SPECIFICATION)) {\r\n        return \"Temporal formula\";\r\n    } else if (attributeName.equals(MODEL_BEHAVIOR_SEPARATE_SPECIFICATION_INIT)) {\r\n        return \"Init\";\r\n    } else if (attributeName.equals(MODEL_BEHAVIOR_SEPARATE_SPECIFICATION_NEXT)) {\r\n        return \"Next\";\r\n    } else if (attributeName.equals(MODEL_PARAMETER_VIEW)) {\r\n        return \"View\";\r\n    } else if (attributeName.equals(Model.MODEL_EXPRESSION_EVAL)) {\r\n        return \"Expression\";\r\n    }\r\n    return attributeName;\r\n}"
}, {
	"Path": "tlc2.value.Value.toTuple",
	"Comment": "this method converts a value to a tuple value. it returnsnull if the conversion fails.",
	"Method": "TupleValue toTuple(){\r\n    return null;\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.NavBarOverlayLayout.show",
	"Comment": "animates the actionbutton onto the screen so that the user may interact.animation occurs from the bottom of the screen, moving up until it reaches theappropriate distance from the bottom.",
	"Method": "void show(){\r\n    final Activity activity = (Activity) getContext();\r\n    setAlpha(1f);\r\n    FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(width, height);\r\n    params.gravity = Gravity.BOTTOM;\r\n    this.setLayoutParams(params);\r\n    if (parent == null) {\r\n        parent = (FrameLayout) activity.findViewById(android.R.id.content);\r\n    }\r\n    try {\r\n        parent.addView(this);\r\n    } catch (Exception e) {\r\n    }\r\n}"
}, {
	"Path": "pcal.PcalFixIDs.FixProcedure",
	"Comment": "fixprocedure modified by ll on 12 january 2011 so it also fixes thepluslabels and minuslabels entries.",
	"Method": "void FixProcedure(AST.Procedure ast,String context){\r\n    for (int i = 0; i < ast.decls.size(); i++) FixPVarDecl((AST.PVarDecl) ast.decls.elementAt(i), ast.name);\r\n    for (int i = 0; i < ast.params.size(); i++) FixPVarDecl((AST.PVarDecl) ast.params.elementAt(i), ast.name);\r\n    for (int i = 0; i < ast.body.size(); i++) FixLabeledStmt((AST.LabeledStmt) ast.body.elementAt(i), ast.name);\r\n    PcalSymTab.ProcedureEntry p = (PcalSymTab.ProcedureEntry) st.procs.elementAt(st.FindProc(ast.name));\r\n    for (int i = 0; i < ast.plusLabels.size(); i++) {\r\n        String lbl = (String) ast.plusLabels.elementAt(i);\r\n        String newLbl = st.UseThis(PcalSymTab.LABEL, lbl, ast.name);\r\n        ast.plusLabels.setElementAt(newLbl, i);\r\n    }\r\n    for (int i = 0; i < ast.minusLabels.size(); i++) {\r\n        String lbl = (String) ast.minusLabels.elementAt(i);\r\n        String newLbl = st.UseThis(PcalSymTab.LABEL, lbl, ast.name);\r\n        ast.minusLabels.setElementAt(newLbl, i);\r\n    }\r\n    p.iPC = st.UseThis(PcalSymTab.LABEL, p.iPC, ast.name);\r\n    ast.name = st.UseThis(PcalSymTab.PROCEDURE, ast.name, \"\");\r\n    p.name = ast.name;\r\n}"
}, {
	"Path": "tlc2.value.Value.permute",
	"Comment": "this method returns the value permuted by the permutation. itreturns this if nothing is permuted.",
	"Method": "Value permute(MVPerm perm){\r\n    try {\r\n        Assert.fail(\"TLC has found a state in which the value of a variable contains \" + Value.ppr(this.toString()));\r\n        return null;\r\n    } catch (RuntimeException | OutOfMemoryError e) {\r\n        if (hasSource()) {\r\n            throw FingerprintException.getNewHead(this, e);\r\n        } else {\r\n            throw e;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.DecomposeProofHandler.realExecute",
	"Comment": "the real execute methodthis method is called by a synchronous job launched in the execute methodto do most of the work of executing the decompose proof command.",
	"Method": "Object realExecute(){\r\n    Vector<SemanticNode> assumes = new Vector<SemanticNode>();\r\n    SemanticNode goal = null;\r\n    LevelNode goalStep = null;\r\n    String nullReason = \"[This string should never be displayed]\";\r\n    Vector<SemanticNode> contextAssumptions = new Vector<SemanticNode>();\r\n    Vector<LevelNode> contextSteps = new Vector<LevelNode>();\r\n    Vector<String> contextSources = new Vector<String>();\r\n    if (this.windowShell != null) {\r\n        if (!this.windowShell.isDisposed()) {\r\n            System.out.println(\"Command called when being executed.\");\r\n            return null;\r\n        }\r\n    }\r\n    if (existDirtyModules()) {\r\n        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"There is an unsaved module.\");\r\n        return null;\r\n    }\r\n    Spec spec = Activator.getSpecManager().getSpecLoaded();\r\n    if (spec == null || spec.getStatus() != IParseConstants.PARSED) {\r\n        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"The spec status must be \\\"parsed\\\" to execute this command.\");\r\n        return null;\r\n    }\r\n    if (editor == null) {\r\n        Activator.getDefault().logDebug(\"2nd call of getTLAEditorWithFocus returned null\");\r\n        return null;\r\n    }\r\n    editorIFile = ((FileEditorInput) editor.getEditorInput()).getFile();\r\n    if (editor.isDirty()) {\r\n        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"The module is dirty; this should not happen.\");\r\n        return null;\r\n    }\r\n    this.state = new DecompositionState();\r\n    state.hasChanged = false;\r\n    state.goalDefinitions = new StringSet();\r\n    state.assumpDefinitions = new HashSet<String>();\r\n    Location selectedLocation = EditorUtil.getLocationAt(doc, offset, selection.getLength());\r\n    TheoremNode[] allTheorems = moduleNode.getTheorems();\r\n    theorem = null;\r\n    int i = 0;\r\n    String moduleFile = moduleNode.stn.getFilename();\r\n    while ((theorem == null) & (i < allTheorems.length)) {\r\n        if (allTheorems[i].stn.getFilename().equals(moduleFile) && EditorUtil.lineLocationContainment(selectedLocation, allTheorems[i].stn.getLocation())) {\r\n            theorem = allTheorems[i];\r\n        }\r\n        i++;\r\n    }\r\n    if (theorem == null) {\r\n        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"The cursor is not in a theorem.\");\r\n        return null;\r\n    }\r\n    goal = theorem.getTheorem();\r\n    if (goal instanceof AssumeProveNode) {\r\n        goal = ((AssumeProveNode) goal).getProve();\r\n    }\r\n    goalStep = theorem;\r\n    this.declaredIdentifiers = ResourceHelper.declaredSymbolsInScopeSet(this.moduleNode, theorem.stn.getLocation());\r\n    step = theorem;\r\n    boolean notDone = true;\r\n    proofLevel = -1;\r\n    proof = step.getProof();\r\n    while (notDone && (proof != null) && (proof instanceof NonLeafProofNode)) {\r\n        LevelNode[] pfsteps = ((NonLeafProofNode) proof).getSteps();\r\n        LevelNode foundLevelNode = null;\r\n        i = 0;\r\n        proofLevel = -1;\r\n        while ((foundLevelNode == null) && (i < pfsteps.length)) {\r\n            if ((proofLevel == -1) && !(pfsteps[i] instanceof DefStepNode) && !(pfsteps[i] instanceof InstanceNode)) {\r\n                proofLevel = stepLevel(pfsteps[i]);\r\n            }\r\n            String currStepName = null;\r\n            if (pfsteps[i] instanceof TheoremNode) {\r\n                currStepName = getStepName((TheoremNode) pfsteps[i]);\r\n            }\r\n            if (EditorUtil.lineLocationContainment(selectedLocation, pfsteps[i].stn.getLocation())) {\r\n                foundLevelNode = pfsteps[i];\r\n                if (pfsteps[i] instanceof TheoremNode) {\r\n                    TheoremNode thmNode = (TheoremNode) pfsteps[i];\r\n                    ProofNode pfNode = thmNode.getProof();\r\n                    boolean isChosenStep = (pfNode == null) || (pfNode instanceof LeafProofNode);\r\n                    if (!thmNode.isSuffices()) {\r\n                        if (thmNode.getTheorem() instanceof AssumeProveNode) {\r\n                            SemanticNode[] assumptions = ((AssumeProveNode) thmNode.getTheorem()).getAssumes();\r\n                            for (int j = 0; j < assumptions.length; j++) {\r\n                                if (assumptions[j] instanceof NewSymbNode) {\r\n                                    declaredIdentifiers.add(((NewSymbNode) assumptions[j]).getOpDeclNode().getName().toString());\r\n                                } else {\r\n                                    if (!(assumptions[j] instanceof AssumeProveNode)) {\r\n                                        if (isChosenStep) {\r\n                                            assumes.addElement(assumptions[j]);\r\n                                        } else {\r\n                                            contextAssumptions.addElement(assumptions[j]);\r\n                                            contextSteps.addElement(thmNode);\r\n                                            contextSources.addElement(currStepName);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            goal = ((AssumeProveNode) thmNode.getTheorem()).getProve();\r\n                            goalStep = thmNode;\r\n                        } else {\r\n                            SemanticNode newGoalSemNode = thmNode.getTheorem();\r\n                            if (newGoalSemNode instanceof OpApplNode) {\r\n                                OpApplNode newGoal = (OpApplNode) newGoalSemNode;\r\n                                UniqueString goalOpName = newGoal.getOperator().getName();\r\n                                if (goalOpName == ASTConstants.OP_pfcase) {\r\n                                    if (isChosenStep) {\r\n                                        assumes.addElement(newGoal.getArgs()[0]);\r\n                                    } else {\r\n                                        contextAssumptions.addElement(newGoal.getArgs()[0]);\r\n                                        contextSteps.addElement(thmNode);\r\n                                        contextSources.addElement(currStepName);\r\n                                    }\r\n                                } else if (goalOpName == ASTConstants.OP_pick) {\r\n                                    goal = null;\r\n                                    nullReason = \"PICK\";\r\n                                } else if (goalOpName == ASTConstants.OP_have) {\r\n                                    goal = null;\r\n                                    nullReason = \"HAVE\";\r\n                                } else if (goalOpName == ASTConstants.OP_take) {\r\n                                    goal = null;\r\n                                    nullReason = \"TAKE\";\r\n                                } else if (goalOpName == null) {\r\n                                    goal = null;\r\n                                    nullReason = \"weird\";\r\n                                } else if (goalOpName == ASTConstants.OP_qed) {\r\n                                } else {\r\n                                    goal = newGoal;\r\n                                    goalStep = thmNode;\r\n                                }\r\n                            } else {\r\n                                goal = null;\r\n                                nullReason = \"weird\";\r\n                            }\r\n                        }\r\n                    } else {\r\n                        goal = null;\r\n                        nullReason = \"SUFFICES\";\r\n                    }\r\n                } else {\r\n                    goal = null;\r\n                    nullReason = \"weird\";\r\n                }\r\n            } else {\r\n                if (pfsteps[i] instanceof TheoremNode) {\r\n                    TheoremNode node = (TheoremNode) pfsteps[i];\r\n                    if (node.isSuffices()) {\r\n                        if (node.getTheorem() instanceof AssumeProveNode) {\r\n                            goal = ((AssumeProveNode) node.getTheorem()).getProve();\r\n                            goalStep = node;\r\n                            SemanticNode[] assumptions = ((AssumeProveNode) node.getTheorem()).getAssumes();\r\n                            for (int j = 0; j < assumptions.length; j++) {\r\n                                if (assumptions[j] instanceof NewSymbNode) {\r\n                                    declaredIdentifiers.add(((NewSymbNode) assumptions[j]).getOpDeclNode().getName().toString());\r\n                                } else {\r\n                                    if (!(assumptions[j] instanceof AssumeProveNode)) {\r\n                                        contextAssumptions.addElement(assumptions[j]);\r\n                                        contextSteps.addElement(node);\r\n                                        contextSources.addElement(currStepName);\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            goal = (SemanticNode) node.getTheorem();\r\n                            goalStep = node;\r\n                            if (!(goal instanceof OpApplNode)) {\r\n                                goal = null;\r\n                                nullReason = \"weird\";\r\n                            }\r\n                        }\r\n                    } else if (node.getTheorem() instanceof OpApplNode) {\r\n                        OpApplNode oanode = (OpApplNode) node.getTheorem();\r\n                        String operatorName = oanode.getOperator().getName().toString();\r\n                        if (operatorName.equals(\"$Pick\") || operatorName.equals(\"$Witness\") || operatorName.equals(\"$Take\")) {\r\n                            FormalParamNode[] fp = oanode.getUnbdedQuantSymbols();\r\n                            if (operatorName.equals(\"$Pick\")) {\r\n                                contextAssumptions.addElement(oanode.getArgs()[0]);\r\n                                contextSteps.addElement(node);\r\n                                contextSources.addElement(currStepName);\r\n                            }\r\n                            if (!operatorName.equals(\"$Witness\")) {\r\n                                if (fp != null) {\r\n                                    for (int j = 0; j < fp.length; j++) {\r\n                                        declaredIdentifiers.add(fp[j].getName().toString());\r\n                                    }\r\n                                } else {\r\n                                    FormalParamNode[][] fpn = oanode.getBdedQuantSymbolLists();\r\n                                    for (int j = 0; j < fpn.length; j++) {\r\n                                        for (int k = 0; k < fpn[j].length; k++) {\r\n                                            declaredIdentifiers.add(fpn[j][k].getName().toString());\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (operatorName.equals(\"$Take\")) {\r\n                                    goal = null;\r\n                                    nullReason = \"TAKE\";\r\n                                }\r\n                            } else {\r\n                                goal = null;\r\n                                nullReason = \"WITNESS\";\r\n                            }\r\n                        } else if (operatorName.equals(\"$Have\")) {\r\n                            goal = null;\r\n                            nullReason = \"HAVE\";\r\n                            contextAssumptions.addElement(oanode.getArgs()[0]);\r\n                            contextSteps.addElement(node);\r\n                            contextSources.addElement(currStepName);\r\n                        } else if (!operatorName.equals(\"$Pfcase\")) {\r\n                            contextAssumptions.addElement(oanode);\r\n                            contextSteps.addElement(node);\r\n                            contextSources.addElement(currStepName);\r\n                        }\r\n                    }\r\n                }\r\n                if (pfsteps[i] instanceof DefStepNode) {\r\n                    OpDefNode[] defs = ((DefStepNode) pfsteps[i]).getDefs();\r\n                    for (int j = 0; j < defs.length; j++) {\r\n                        declaredIdentifiers.add(defs[j].getName().toString());\r\n                    }\r\n                }\r\n                if (pfsteps[i] instanceof InstanceNode) {\r\n                    ResourceHelper.addDeclaredSymbolsInScopeSet(declaredIdentifiers, ((InstanceNode) pfsteps[i]).getModule(), ResourceHelper.infiniteLoc);\r\n                }\r\n            }\r\n            i++;\r\n        }\r\n        if (foundLevelNode == null) {\r\n            notDone = false;\r\n        } else if (!(foundLevelNode instanceof TheoremNode)) {\r\n            MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"The cursor is in a non-provable step.\");\r\n            return null;\r\n        } else {\r\n            step = (TheoremNode) foundLevelNode;\r\n            proof = step.getProof();\r\n        }\r\n    }\r\n    if ((proof != null) && !(proof instanceof LeafProofNode)) {\r\n        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"You have selected a step that already has a non-leaf proof.\");\r\n        return null;\r\n    }\r\n    if (step == theorem) {\r\n        if (step.getTheorem() instanceof AssumeProveNode) {\r\n            SemanticNode[] assumptions = ((AssumeProveNode) step.getTheorem()).getAssumes();\r\n            for (int j = 0; j < assumptions.length; j++) {\r\n                if (assumptions[j] instanceof NewSymbNode) {\r\n                    declaredIdentifiers.add(((NewSymbNode) assumptions[j]).getOpDeclNode().getName().toString());\r\n                    assumes.addElement(assumptions[j]);\r\n                } else {\r\n                    if (!(assumptions[j] instanceof AssumeProveNode)) {\r\n                        assumes.addElement(assumptions[j]);\r\n                    }\r\n                }\r\n            }\r\n            goal = ((AssumeProveNode) step.getTheorem()).getProve();\r\n            goalStep = step;\r\n        } else {\r\n            SemanticNode newGoalSemNode = step.getTheorem();\r\n            if (newGoalSemNode instanceof OpApplNode) {\r\n                OpApplNode newGoal = (OpApplNode) newGoalSemNode;\r\n                UniqueString goalOpName = newGoal.getOperator().getName();\r\n                if (goalOpName == ASTConstants.OP_pfcase) {\r\n                    goal = newGoal.getArgs()[0];\r\n                } else if (goalOpName == ASTConstants.OP_pick) {\r\n                    goal = null;\r\n                    nullReason = \"PICK\";\r\n                } else if (goalOpName == null) {\r\n                    goal = null;\r\n                    nullReason = \"weird\";\r\n                } else if (goalOpName == ASTConstants.OP_qed) {\r\n                } else {\r\n                    goal = newGoal;\r\n                    goalStep = step;\r\n                }\r\n            } else {\r\n                goal = null;\r\n                nullReason = \"weird\";\r\n            }\r\n        }\r\n    } else {\r\n        if (theorem.getTheorem() instanceof AssumeProveNode) {\r\n            SemanticNode[] thmAssumps = ((AssumeProveNode) theorem.getTheorem()).getAssumes();\r\n            int k = 0;\r\n            for (int j = 0; j < thmAssumps.length; j++) {\r\n                if (thmAssumps[j] instanceof NewSymbNode) {\r\n                    declaredIdentifiers.add(((NewSymbNode) thmAssumps[j]).getOpDeclNode().getName().toString());\r\n                } else {\r\n                    contextAssumptions.insertElementAt(thmAssumps[j], k);\r\n                    contextSteps.insertElementAt(theorem.getTheorem(), k);\r\n                    contextSources.insertElementAt(null, k);\r\n                    k++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (goal == null) {\r\n        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"Cannot decompose because goal is from a \" + nullReason + \" step.\");\r\n        return null;\r\n    }\r\n    int level = this.proofLevel;\r\n    if (level < 0) {\r\n        level = 0;\r\n    }\r\n    proofLevelString = \"<\" + (level + 1) + \">\";\r\n    SyntaxTreeNode nd = (SyntaxTreeNode) step.stn;\r\n    if (step == theorem) {\r\n        stepNumber = null;\r\n    } else {\r\n        stepNumber = nd.getHeirs()[0].image.toString();\r\n        if (stepNumber.indexOf('>') == stepNumber.length() - 1) {\r\n            stepNumber = null;\r\n        } else {\r\n            i = stepNumber.indexOf('>') + 1;\r\n            while ((i < stepNumber.length() && (Character.isLetterOrDigit(stepNumber.charAt(i)) || (stepNumber.charAt(i) == '_')))) {\r\n                i++;\r\n            }\r\n            if (i < stepNumber.length()) {\r\n                stepNumber = stepNumber.substring(0, i);\r\n            }\r\n        }\r\n    }\r\n    stepColumn = nd.getLocation().beginColumn();\r\n    try {\r\n        stepRep = new NodeRepresentation(doc, step);\r\n    } catch (BadLocationException e) {\r\n        e.printStackTrace();\r\n        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"An error that should not happen has occurred in \" + \"line 1479 of NewDecomposeProofHandler.\");\r\n        return null;\r\n    }\r\n    state.assumeReps = new Vector<NodeRepresentation>();\r\n    for (i = 0; i < contextAssumptions.size(); i++) {\r\n        NodeRepresentation contextStepRep = null;\r\n        try {\r\n            contextStepRep = new NodeRepresentation(doc, contextSteps.elementAt(i));\r\n        } catch (BadLocationException e) {\r\n            e.printStackTrace();\r\n            MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"An error that should not happen has occurred in \" + \"line 1544 of NewDecomposeProofHandler.\");\r\n            return null;\r\n        }\r\n        NodeRepresentation nodeRep = contextStepRep.subNodeRep(contextAssumptions.elementAt(i), state.assumeReps, null, null, null, true);\r\n        nodeRep.contextStepName = contextSources.elementAt(i);\r\n        if ((nodeRep.decomposition != null) && (nodeRep.nodeSubtype != NodeRepresentation.IMPLIES_TYPE) && (nodeRep.nodeSubtype != NodeRepresentation.FORALL_TYPE)) {\r\n            nodeRep.initialPosition = state.assumeReps.size();\r\n            state.assumeReps.addElement(nodeRep);\r\n            state.numberOfContextAssumptions++;\r\n        }\r\n    }\r\n    hasAssumes = false;\r\n    if (assumes.size() > 0) {\r\n        hasAssumes = true;\r\n    }\r\n    for (i = 0; i < assumes.size(); i++) {\r\n        NodeRepresentation nodeRep = stepRep.subNodeRep(assumes.elementAt(i), state.assumeReps, null, null, null, true);\r\n        nodeRep.contextStepName = this.stepNumber;\r\n        nodeRep.initialPosition = state.assumeReps.size();\r\n        state.assumeReps.addElement(nodeRep);\r\n    }\r\n    state.firstAddedAssumption = state.assumeReps.size();\r\n    NodeRepresentation goalStepRep = null;\r\n    try {\r\n        goalStepRep = new NodeRepresentation(doc, goalStep);\r\n    } catch (BadLocationException e) {\r\n        e.printStackTrace();\r\n        MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"An error that should not happen has occurred in \" + \"line 1583 of NewDecomposeProofHandler.\");\r\n        return null;\r\n    }\r\n    state.goalRep = goalStepRep.subNodeRep(goal, null, null, null, null, false);\r\n    state.goalRep.initialPosition = Integer.MAX_VALUE - 42;\r\n    state.goalRep.fromGoal = true;\r\n    editorIFile.setReadOnly(true);\r\n    raiseWindow();\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.roo.project.PluginTest.assertElement",
	"Comment": "asserts that the given plugin returns the expected xml for its pomelement",
	"Method": "void assertElement(Plugin plugin,Document document,String expectedXml){\r\n    final Element element = plugin.getElement(document);\r\n    assertXmlEquals(expectedXml, element);\r\n}"
}, {
	"Path": "tla2sany.semantic.FormalParamNode.getArity",
	"Comment": "returns the number of arguments this paramter takes when used inan expression.",
	"Method": "int getArity(){\r\n    return this.arity;\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.plugins.pict.PICTUtil.readStr31",
	"Comment": "reads a 32 byte fixed length pascal string from the given input.the input stream must be positioned at the length byte of the text,the text will be no longer than 31 characters long.",
	"Method": "String readStr31(DataInput pStream){\r\n    String text = readPascalString(pStream);\r\n    int length = 31 - text.length();\r\n    if (length < 0) {\r\n        throw new IOException(\"String length exceeds maximum (31): \" + text.length());\r\n    }\r\n    pStream.skipBytes(length);\r\n    return text;\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.path.Paths.readClipped",
	"Comment": "reads the clipping path from the given input stream, if any,and applies it to the first image in the stream.if no path was found, the image is returned without any clipping.supports psd, jpeg and tiff as container formats for photoshop resources.",
	"Method": "BufferedImage readClipped(ImageInputStream stream){\r\n    Shape clip = readPath(stream);\r\n    stream.seek(0);\r\n    BufferedImage image = ImageIO.read(stream);\r\n    if (clip == null) {\r\n        return image;\r\n    }\r\n    return applyClippingPath(clip, image);\r\n}"
}, {
	"Path": "sharedcode.turboeditor.util.PixelDipConverter.convertDpToPixel",
	"Comment": "this method convets dp unit to equivalent device specific value in pixels.",
	"Method": "float convertDpToPixel(float dp,Context context){\r\n    final Resources resources = context.getResources();\r\n    final DisplayMetrics metrics = resources.getDisplayMetrics();\r\n    return dp * metrics.densityDpi / 160f;\r\n}"
}, {
	"Path": "tlc2.tool.CommonTestCase.assertTraceWith",
	"Comment": "asserts that the actual trace and the expected error trace are equal.",
	"Method": "void assertTraceWith(List<Object> actual,List<String> expectedTrace){\r\n    assertEquals(expectedTrace.size(), actual.size());\r\n    for (int i = 0; i < expectedTrace.size(); i++) {\r\n        final Object[] objs = (Object[]) actual.get(i);\r\n        final TLCStateInfo stateInfo = (TLCStateInfo) objs[0];\r\n        final String info = (String) stateInfo.info;\r\n        if (i == 0) {\r\n            \"<Initial predicate>\".equals(info);\r\n        } else {\r\n            info.startsWith(\"<Action\");\r\n        }\r\n        assertEquals(expectedTrace.get(i), stateInfo.toString().trim());\r\n        assertEquals(i + 1, objs[1]);\r\n    }\r\n}"
}, {
	"Path": "pcal.PcalFixIDs.FixProcess",
	"Comment": "fixprocess modified by ll on 12 january 2011 so it also fixes thepluslabels and minuslabels entries.",
	"Method": "void FixProcess(AST.Process ast,String context){\r\n    for (int i = 0; i < ast.decls.size(); i++) FixVarDecl((AST.VarDecl) ast.decls.elementAt(i), ast.name);\r\n    for (int i = 0; i < ast.body.size(); i++) FixLabeledStmt((AST.LabeledStmt) ast.body.elementAt(i), ast.name);\r\n    PcalSymTab.ProcessEntry p = (PcalSymTab.ProcessEntry) st.processes.elementAt(st.FindProcess(ast.name));\r\n    for (int i = 0; i < ast.plusLabels.size(); i++) {\r\n        String lbl = (String) ast.plusLabels.elementAt(i);\r\n        String newLbl = st.UseThis(PcalSymTab.LABEL, lbl, ast.name);\r\n        ast.plusLabels.setElementAt(newLbl, i);\r\n    }\r\n    for (int i = 0; i < ast.minusLabels.size(); i++) {\r\n        String lbl = (String) ast.minusLabels.elementAt(i);\r\n        String newLbl = st.UseThis(PcalSymTab.LABEL, lbl, ast.name);\r\n        ast.minusLabels.setElementAt(newLbl, i);\r\n    }\r\n    p.iPC = st.UseThis(PcalSymTab.LABEL, p.iPC, ast.name);\r\n    ast.name = st.UseThis(PcalSymTab.PROCESS, ast.name, \"\");\r\n    p.name = ast.name;\r\n}"
}, {
	"Path": "tla2sany.semantic.OpApplNode.makeNonRecursive",
	"Comment": "sets the unboundedbound symbols vector for this opapplnode to null,once it is discoved that a function def is in fact nonrecursive.",
	"Method": "void makeNonRecursive(){\r\n    this.unboundedBoundSymbols = null;\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.video.TextureRender.surfaceCreated",
	"Comment": "initializes gl state. call this after the egl surface has been created and made current.",
	"Method": "void surfaceCreated(){\r\n    mProgram = createProgram(VERTEX_SHADER, FRAGMENT_SHADER);\r\n    if (mProgram == 0) {\r\n        throw new RuntimeException(\"failed creating program\");\r\n    }\r\n    maPositionHandle = GLES20.glGetAttribLocation(mProgram, \"aPosition\");\r\n    checkGlError(\"glGetAttribLocation aPosition\");\r\n    if (maPositionHandle == -1) {\r\n        throw new RuntimeException(\"Could not get attrib location for aPosition\");\r\n    }\r\n    maTextureHandle = GLES20.glGetAttribLocation(mProgram, \"aTextureCoord\");\r\n    checkGlError(\"glGetAttribLocation aTextureCoord\");\r\n    if (maTextureHandle == -1) {\r\n        throw new RuntimeException(\"Could not get attrib location for aTextureCoord\");\r\n    }\r\n    muMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, \"uMVPMatrix\");\r\n    checkGlError(\"glGetUniformLocation uMVPMatrix\");\r\n    if (muMVPMatrixHandle == -1) {\r\n        throw new RuntimeException(\"Could not get attrib location for uMVPMatrix\");\r\n    }\r\n    muSTMatrixHandle = GLES20.glGetUniformLocation(mProgram, \"uSTMatrix\");\r\n    checkGlError(\"glGetUniformLocation uSTMatrix\");\r\n    if (muSTMatrixHandle == -1) {\r\n        throw new RuntimeException(\"Could not get attrib location for uSTMatrix\");\r\n    }\r\n    int[] textures = new int[1];\r\n    GLES20.glGenTextures(1, textures, 0);\r\n    mTextureID = textures[0];\r\n    GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, mTextureID);\r\n    checkGlError(\"glBindTexture mTextureID\");\r\n    GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);\r\n    GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);\r\n    GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);\r\n    GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);\r\n    checkGlError(\"glTexParameter\");\r\n}"
}, {
	"Path": "teammates.test.cases.BaseComponentTestCase.verifySearchResults",
	"Comment": "verifies that search results match with expected output.compares the text for each comment as it is unique.",
	"Method": "void verifySearchResults(FeedbackResponseCommentSearchResultBundle actual,FeedbackResponseCommentAttributes expected){\r\n    assertEquals(expected.length, actual.numberOfResults);\r\n    assertEquals(expected.length, actual.comments.size());\r\n    FeedbackResponseCommentAttributes.sortFeedbackResponseCommentsByCreationTime(Arrays.asList(expected));\r\n    FeedbackResponseCommentAttributes[] sortedComments = Arrays.asList(expected).toArray(new FeedbackResponseCommentAttributes[2]);\r\n    int[] i = new int[] { 0 };\r\n    actual.comments.forEach((key, comments) -> comments.forEach(comment -> {\r\n        assertEquals(sortedComments[i[0]].commentText, comment.commentText);\r\n        i[0]++;\r\n    }));\r\n}"
}, {
	"Path": "org.springframework.roo.project.Dependency.isHigherLevel",
	"Comment": "indicates whether one dependency type is at a higher logical level thananother.",
	"Method": "boolean isHigherLevel(String type1,String type2){\r\n    final int type1Index = TYPE_HIERARCHY.indexOf(type1.toLowerCase());\r\n    final int type2Index = TYPE_HIERARCHY.indexOf(type2.toLowerCase());\r\n    return type2Index >= 0 && type1Index > type2Index;\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.SeiImplMetadata.getEndpointMethodFromSEIMethod",
	"Comment": "this method obtains an endpoint method from a provided sei method.this method caches the generated methods",
	"Method": "MethodMetadataBuilder getEndpointMethodFromSEIMethod(MethodMetadata seiMethod,MethodMetadata serviceMethod){\r\n    if (endpointMethodsFromSeiMethods.get(seiMethod) != null) {\r\n        return endpointMethodsFromSeiMethods.get(seiMethod);\r\n    }\r\n    List<JavaType> parameters = new ArrayList<JavaType>();\r\n    for (AnnotatedJavaType type : seiMethod.getParameterTypes()) {\r\n        parameters.add(type.getJavaType());\r\n    }\r\n    MethodMetadataBuilder endpointMethod = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, seiMethod.getMethodName(), seiMethod.getReturnType(), AnnotatedJavaType.convertFromJavaTypes(parameters), seiMethod.getParameterNames(), null);\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    String parametersList = \"\";\r\n    for (JavaSymbolName param : seiMethod.getParameterNames()) {\r\n        parametersList = parametersList.concat(param.getSymbolName()).concat(\", \");\r\n    }\r\n    if (StringUtils.isNotBlank(parametersList)) {\r\n        parametersList = parametersList.substring(0, parametersList.length() - 2);\r\n    }\r\n    bodyBuilder.appendFormalLine(\"%s%s().%s(%s);\", seiMethod.getReturnType() != JavaType.VOID_PRIMITIVE ? \"return \" : \"\", getAccessorMethod(getServiceField()).getMethodName(), serviceMethod.getMethodName().getSymbolName(), parametersList);\r\n    endpointMethod.setBodyBuilder(bodyBuilder);\r\n    endpointMethodsFromSeiMethods.put(seiMethod, endpointMethod);\r\n    endpointMethods.add(endpointMethod.build());\r\n    return endpointMethod;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.BeanInfoUtils.getFieldForPropertyName",
	"Comment": "attempts to locate the field which is represented by the presentedproperty name.not every javabean getter or setter actually backs to a field with anidentical name. in such cases, null will be returned.",
	"Method": "FieldMetadata getFieldForPropertyName(MemberDetails memberDetails,JavaSymbolName propertyName){\r\n    Validate.notNull(memberDetails, \"Member details required\");\r\n    Validate.notNull(propertyName, \"Property name required\");\r\n    for (final MemberHoldingTypeDetails holder : memberDetails.getDetails()) {\r\n        FieldMetadata result = holder.getDeclaredField(propertyName);\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n        result = holder.getDeclaredField(new JavaSymbolName(StringUtils.uncapitalize(propertyName.getSymbolName())));\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.ResourceHelper.replaceContent",
	"Comment": "writes contents stored in the string buffer to the file, replacing the content",
	"Method": "void replaceContent(IFile file,StringBuffer buffer,IProgressMonitor monitor){\r\n    ByteArrayInputStream stream = new ByteArrayInputStream(buffer.toString().getBytes());\r\n    if (file.exists()) {\r\n        file.setContents(stream, IResource.FORCE, monitor);\r\n    } else {\r\n        throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, \"Exected \" + file.getName() + \" file has been removed externally\"));\r\n    }\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackEditPage.waitForNewQuestionPanelReady",
	"Comment": "waits for the new question panel to be ready, that is, all states initialized and all animations complete.",
	"Method": "void waitForNewQuestionPanelReady(){\r\n    waitForScrollingToComplete();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.FocusOnStepHandler.setEnabled",
	"Comment": "this method is used to update the enablement state. this has theeffect of graying out any menu items for thecommand if the handler is disabled. through experimentation, this method seems to becalled just before such menu items are rendered in the ui andjust before the handler is executed.",
	"Method": "void setEnabled(Object context){\r\n    TLAEditor editor = EditorUtil.getTLAEditorWithFocus();\r\n    if (editor != null) {\r\n        if (editor.getProofStructureProvider() != null) {\r\n            setBaseEnabled(editor.getProofStructureProvider().canRunFoldOperation(IProofFoldCommandIds.FOCUS_ON_STEP, (ITextSelection) editor.getSelectionProvider().getSelection()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.launch.TLCModelLaunchDelegate.copyUserModuleOverride",
	"Comment": "java source file from which the user manually compiled the class file.",
	"Method": "void copyUserModuleOverride(IProgressMonitor monitor,int ticks,IProject project,IPath targetFolderPath,IFile tlaFile){\r\n    final IFile[] userModuleOverrides = ResourceHelper.getModuleOverrides(project, tlaFile);\r\n    for (IFile userModuleOverride : userModuleOverrides) {\r\n        try {\r\n            userModuleOverride.copy(targetFolderPath.append(userModuleOverride.getProjectRelativePath()), IResource.DERIVED | IResource.FORCE, new SubProgressMonitor(monitor, ticks));\r\n        } catch (CoreException e) {\r\n            userModuleOverride.delete(true, monitor);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.preference.ProverPreferencePage.getAppliesToLeafPrefName",
	"Comment": "returns the preference name for the boolean preference of whether thecolor applies only to leaf steps. this is the name used to store the preferencein the preference store.",
	"Method": "String getAppliesToLeafPrefName(int colorNum){\r\n    String string = APPLIES_TO_LEAF_ONLY;\r\n    return string + colorNum;\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.ObjectAbstractTest.readExternalFormFromDisk",
	"Comment": "reads a serialized or externalized object from disk.useful for creating compatibility tests betweendifferent cvs versions of the same class",
	"Method": "Object readExternalFormFromDisk(String path){\r\n    FileInputStream stream = new FileInputStream(path);\r\n    return readExternalFormFromStream(stream);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.model.Model.getTLAFile",
	"Comment": "retrieves the tla file that is being model checked on the model run. this is\tthe mc.tla file.",
	"Method": "IFile getTLAFile(){\r\n    return getFile(ModelHelper.FILE_TLA);\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackSessionsDb.getFeedbackSessionsPossiblyNeedingPublishedEmail",
	"Comment": "gets a list of undeleted published feedback sessions which possibly need a published emailto be sent.",
	"Method": "List<FeedbackSessionAttributes> getFeedbackSessionsPossiblyNeedingPublishedEmail(){\r\n    return makeAttributes(getFeedbackSessionEntitiesPossiblyNeedingPublishedEmail()).stream().filter(session -> !session.isSessionDeleted()).collect(Collectors.toList());\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.ShellStream.waitFor",
	"Comment": "this is an internal method, which is used to change which object to add a lock to.",
	"Method": "Boolean waitFor(Boolean waitFor,Integer timeout,Boolean waitFor,Integer timeout,Integer index){\r\n    Integer counter = mCounter.size() + index;\r\n    if (counter > 0) {\r\n        Long timeoutMilis = timeout > 0 ? System.currentTimeMillis() + timeout : 0L;\r\n        synchronized (mLock) {\r\n            while (mCounter.size() > 0 && mIsActive) {\r\n                try {\r\n                    counter -= 1;\r\n                    mLock.wait(timeout.longValue());\r\n                    if (timeout > 0 && System.currentTimeMillis() >= timeoutMilis) {\r\n                        return mCounter.size() == 0 && mIsActive;\r\n                    } else if (counter <= 0) {\r\n                        return mIsActive;\r\n                    }\r\n                } catch (InterruptedException e) {\r\n                    Log.w(TAG, e.getMessage(), e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return mIsActive;\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorFeedbackSessionsPageData.getSessionResendPublishedEmailLink",
	"Comment": "retrieves the link to submit the request for resending the session published email.also contains feedback page link to return to after the action.",
	"Method": "String getSessionResendPublishedEmailLink(){\r\n    return getInstructorFeedbackResendPublishedEmailLink(Const.ActionURIs.INSTRUCTOR_FEEDBACK_SESSIONS_PAGE);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.isShowing",
	"Comment": "tells whether or not the button is currently showing on the screen.",
	"Method": "boolean isShowing(){\r\n    return isShowing;\r\n}"
}, {
	"Path": "teammates.ui.controller.InstructorEditInstructorFeedbackSaveAction.setAdditionalParameters",
	"Comment": "retrieves any additional parameters from request and set them accordingly.",
	"Method": "void setAdditionalParameters(){\r\n    String moderatedInstructorEmail = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_MODERATED_PERSON);\r\n    Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_MODERATED_PERSON, moderatedInstructorEmail);\r\n    moderatedInstructor = logic.getInstructorForEmail(courseId, moderatedInstructorEmail);\r\n    isSendSubmissionEmail = false;\r\n    if (moderatedInstructor == null) {\r\n        throw new EntityDoesNotExistException(\"Instructor Email \" + moderatedInstructorEmail + \" does not exist in \" + courseId + \".\");\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.ResourceHelper.innerGetUsesOfUserDefinedOps",
	"Comment": "the inner recursive method used by getusesofuserdefinedops. it appends all the appropriateopapplnodesto found.",
	"Method": "void innerGetUsesOfUserDefinedOps(SemanticNode node,Vector<ExprOrOpArgNode> found){\r\n    if (hasUserDefinedOp(node)) {\r\n        found.add((ExprOrOpArgNode) node);\r\n    }\r\n    SemanticNode[] children = node.getChildren();\r\n    if (children == null) {\r\n        return;\r\n    }\r\n    for (int i = 0; i < children.length; i++) {\r\n        final SemanticNode sn = children[i];\r\n        if (sn != null) {\r\n            if (node.getLocation().source().equals(sn.getLocation().source())) {\r\n                innerGetUsesOfUserDefinedOps(sn, found);\r\n            }\r\n        }\r\n    }\r\n    return;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.antlrjavaparser.JavaParserTypeParsingService.updateOutput",
	"Comment": "appends the presented class to the end of the presented bodydeclarations. the body declarations appear within the presentedcompilation unit. this is used to progressively build inner types.",
	"Method": "void updateOutput(CompilationUnit compilationUnit,CompilationUnitServices enclosingCompilationUnitServices,ClassOrInterfaceTypeDetails cid,List<BodyDeclaration> parent){\r\n    Validate.notNull(compilationUnit.getImports(), \"Compilation unit imports should be non-null when producing type '%s'\", cid.getName());\r\n    for (final ImportMetadata importType : cid.getRegisteredImports()) {\r\n        ImportDeclaration importDeclaration;\r\n        if (!importType.isAsterisk()) {\r\n            NameExpr typeToImportExpr;\r\n            if (importType.getImportType().getEnclosingType() == null) {\r\n                typeToImportExpr = new QualifiedNameExpr(new NameExpr(importType.getImportType().getPackage().getFullyQualifiedPackageName()), importType.getImportType().getSimpleTypeName());\r\n            } else {\r\n                typeToImportExpr = new QualifiedNameExpr(new NameExpr(importType.getImportType().getEnclosingType().getFullyQualifiedTypeName()), importType.getImportType().getSimpleTypeName());\r\n            }\r\n            importDeclaration = new ImportDeclaration(typeToImportExpr, importType.isStatic(), false);\r\n        } else {\r\n            importDeclaration = new ImportDeclaration(new NameExpr(importType.getImportPackage().getFullyQualifiedPackageName()), importType.isStatic(), importType.isAsterisk());\r\n        }\r\n        JavaParserCommentMetadataBuilder.updateCommentsToJavaParser(importDeclaration, importType.getCommentStructure());\r\n        compilationUnit.getImports().add(importDeclaration);\r\n    }\r\n    final int javaParserModifier = JavaParserUtils.getJavaParserModifier(cid.getModifier());\r\n    TypeDeclaration typeDeclaration;\r\n    ClassOrInterfaceDeclaration classOrInterfaceDeclaration;\r\n    final List<ClassOrInterfaceType> implementsList = new ArrayList<ClassOrInterfaceType>();\r\n    for (final JavaType current : cid.getImplementsTypes()) {\r\n        implementsList.add(JavaParserUtils.getResolvedName(cid.getName(), current, compilationUnit));\r\n    }\r\n    if (cid.getPhysicalTypeCategory() == PhysicalTypeCategory.INTERFACE || cid.getPhysicalTypeCategory() == PhysicalTypeCategory.CLASS) {\r\n        final boolean isInterface = cid.getPhysicalTypeCategory() == PhysicalTypeCategory.INTERFACE;\r\n        if (parent == null) {\r\n            typeDeclaration = new ClassOrInterfaceDeclaration(javaParserModifier, isInterface, cid.getName().getNameIncludingTypeParameters().replace(cid.getName().getPackage().getFullyQualifiedPackageName() + \".\", \"\"));\r\n            classOrInterfaceDeclaration = (ClassOrInterfaceDeclaration) typeDeclaration;\r\n        } else {\r\n            typeDeclaration = new ClassOrInterfaceDeclaration(javaParserModifier, isInterface, cid.getName().getSimpleTypeName());\r\n            classOrInterfaceDeclaration = (ClassOrInterfaceDeclaration) typeDeclaration;\r\n            if (cid.getName().getParameters().size() > 0) {\r\n                classOrInterfaceDeclaration.setTypeParameters(new ArrayList<TypeParameter>());\r\n                for (final JavaType param : cid.getName().getParameters()) {\r\n                    NameExpr pNameExpr = JavaParserUtils.importTypeIfRequired(cid.getName(), compilationUnit.getImports(), param);\r\n                    final String tempName = StringUtils.replace(pNameExpr.toString(), param.getArgName() + \" extends \", \"\", 1);\r\n                    pNameExpr = new NameExpr(tempName);\r\n                    final ClassOrInterfaceType pResolvedName = JavaParserUtils.getClassOrInterfaceType(pNameExpr);\r\n                    classOrInterfaceDeclaration.getTypeParameters().add(new TypeParameter(param.getArgName().getSymbolName(), Collections.singletonList(pResolvedName)));\r\n                }\r\n            }\r\n        }\r\n        final List<ClassOrInterfaceType> extendsList = new ArrayList<ClassOrInterfaceType>();\r\n        for (final JavaType current : cid.getExtendsTypes()) {\r\n            if (!OBJECT.equals(current)) {\r\n                extendsList.add(JavaParserUtils.getResolvedName(cid.getName(), current, compilationUnit));\r\n            }\r\n        }\r\n        if (extendsList.size() > 0) {\r\n            classOrInterfaceDeclaration.setExtends(extendsList);\r\n        }\r\n        if (implementsList.size() > 0) {\r\n            classOrInterfaceDeclaration.setImplements(implementsList);\r\n        }\r\n    } else {\r\n        typeDeclaration = new EnumDeclaration(javaParserModifier, cid.getName().getSimpleTypeName());\r\n    }\r\n    typeDeclaration.setMembers(new ArrayList<BodyDeclaration>());\r\n    Validate.notNull(typeDeclaration.getName(), \"Missing type declaration name for '%s'\", cid.getName());\r\n    Validate.notNull(compilationUnit.getTypes(), \"Compilation unit types must not be null when attempting to add '%s'\", cid.getName());\r\n    if (parent == null) {\r\n        compilationUnit.getTypes().add(typeDeclaration);\r\n    } else {\r\n        parent.add(typeDeclaration);\r\n    }\r\n    if (enclosingCompilationUnitServices == null) {\r\n        enclosingCompilationUnitServices = new CompilationUnitServices() {\r\n            @Override\r\n            public JavaPackage getCompilationUnitPackage() {\r\n                return cid.getName().getPackage();\r\n            }\r\n            @Override\r\n            public JavaType getEnclosingTypeName() {\r\n                return cid.getName();\r\n            }\r\n            @Override\r\n            public List<ImportDeclaration> getImports() {\r\n                return compilationUnit.getImports();\r\n            }\r\n            @Override\r\n            public List<TypeDeclaration> getInnerTypes() {\r\n                return compilationUnit.getTypes();\r\n            }\r\n            @Override\r\n            public PhysicalTypeCategory getPhysicalTypeCategory() {\r\n                return cid.getPhysicalTypeCategory();\r\n            }\r\n        };\r\n    }\r\n    final CompilationUnitServices finalCompilationUnitServices = enclosingCompilationUnitServices;\r\n    final CompilationUnitServices compilationUnitServices = new CompilationUnitServices() {\r\n        @Override\r\n        public JavaPackage getCompilationUnitPackage() {\r\n            return finalCompilationUnitServices.getCompilationUnitPackage();\r\n        }\r\n        @Override\r\n        public JavaType getEnclosingTypeName() {\r\n            return cid.getName();\r\n        }\r\n        @Override\r\n        public List<ImportDeclaration> getImports() {\r\n            return finalCompilationUnitServices.getImports();\r\n        }\r\n        @Override\r\n        public List<TypeDeclaration> getInnerTypes() {\r\n            return compilationUnit.getTypes();\r\n        }\r\n        @Override\r\n        public PhysicalTypeCategory getPhysicalTypeCategory() {\r\n            return cid.getPhysicalTypeCategory();\r\n        }\r\n    };\r\n    final List<AnnotationExpr> annotations = new ArrayList<AnnotationExpr>();\r\n    typeDeclaration.setAnnotations(annotations);\r\n    for (final AnnotationMetadata candidate : cid.getAnnotations()) {\r\n        JavaParserAnnotationMetadataBuilder.addAnnotationToList(compilationUnitServices, annotations, candidate);\r\n    }\r\n    List<Comment> classComments = compilationUnit.getComments();\r\n    if (classComments == null || classComments.isEmpty()) {\r\n        CommentStructure defaultCommentStructure = new CommentStructure();\r\n        String defaultComment = \"= \".concat(cid.getType().getSimpleTypeName()).concat(\"\\n \\nTODO Auto-generated class documentation\");\r\n        defaultCommentStructure.addComment(new JavadocComment(defaultComment), CommentLocation.BEGINNING);\r\n        if (annotations.isEmpty()) {\r\n            JavaParserCommentMetadataBuilder.updateCommentsToJavaParser(typeDeclaration, defaultCommentStructure);\r\n        } else {\r\n            AnnotationExpr firstAnnotation = annotations.get(0);\r\n            JavaParserCommentMetadataBuilder.updateCommentsToJavaParser(firstAnnotation, defaultCommentStructure);\r\n        }\r\n    }\r\n    if (typeDeclaration instanceof EnumDeclaration && cid.getEnumConstants().size() > 0) {\r\n        final EnumDeclaration enumDeclaration = (EnumDeclaration) typeDeclaration;\r\n        final List<EnumConstantDeclaration> constants = new ArrayList<EnumConstantDeclaration>();\r\n        enumDeclaration.setEntries(constants);\r\n        for (final JavaSymbolName constant : cid.getEnumConstants()) {\r\n            addEnumConstant(constants, constant);\r\n        }\r\n        if (implementsList.size() > 0) {\r\n            enumDeclaration.setImplements(implementsList);\r\n        }\r\n    }\r\n    for (final FieldMetadata candidate : cid.getDeclaredFields()) {\r\n        JavaParserFieldMetadataBuilder.addField(compilationUnitServices, typeDeclaration.getMembers(), candidate);\r\n    }\r\n    for (final ConstructorMetadata candidate : cid.getDeclaredConstructors()) {\r\n        JavaParserConstructorMetadataBuilder.addConstructor(compilationUnitServices, typeDeclaration.getMembers(), candidate, null);\r\n    }\r\n    for (final MethodMetadata candidate : cid.getDeclaredMethods()) {\r\n        JavaParserMethodMetadataBuilder.addMethod(compilationUnitServices, typeDeclaration.getMembers(), candidate, null);\r\n    }\r\n    for (final ClassOrInterfaceTypeDetails candidate : cid.getDeclaredInnerTypes()) {\r\n        updateOutput(compilationUnit, compilationUnitServices, candidate, typeDeclaration.getMembers());\r\n    }\r\n    final HashSet<String> imported = new HashSet<String>();\r\n    final ArrayList<ImportDeclaration> imports = new ArrayList<ImportDeclaration>();\r\n    for (final ImportDeclaration importDeclaration : compilationUnit.getImports()) {\r\n        JavaPackage importPackage = null;\r\n        JavaType importType = null;\r\n        if (importDeclaration.isAsterisk()) {\r\n            importPackage = new JavaPackage(importDeclaration.getName().toString());\r\n        } else {\r\n            importType = new JavaType(importDeclaration.getName().toString());\r\n            importPackage = importType.getPackage();\r\n        }\r\n        if (importPackage.equals(cid.getName().getPackage()) && importDeclaration.isAsterisk()) {\r\n            continue;\r\n        }\r\n        if (importPackage.equals(cid.getName().getPackage()) && importType != null && importType.getEnclosingType() == null) {\r\n            continue;\r\n        }\r\n        if (importType != null && importType.equals(cid.getName())) {\r\n            continue;\r\n        }\r\n        if (!imported.contains(importDeclaration.getName().toString())) {\r\n            imports.add(importDeclaration);\r\n            imported.add(importDeclaration.getName().toString());\r\n        }\r\n    }\r\n    Collections.sort(imports, new Comparator<ImportDeclaration>() {\r\n        @Override\r\n        public int compare(final ImportDeclaration importDeclaration, final ImportDeclaration importDeclaration1) {\r\n            return importDeclaration.getName().toString().compareTo(importDeclaration1.getName().toString());\r\n        }\r\n    });\r\n    compilationUnit.setImports(imports);\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.antlrjavaparser.JavaParserTypeParsingService.updateOutput",
	"Comment": "appends the presented class to the end of the presented bodydeclarations. the body declarations appear within the presentedcompilation unit. this is used to progressively build inner types.",
	"Method": "void updateOutput(CompilationUnit compilationUnit,CompilationUnitServices enclosingCompilationUnitServices,ClassOrInterfaceTypeDetails cid,List<BodyDeclaration> parent){\r\n    return cid.getName().getPackage();\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.antlrjavaparser.JavaParserTypeParsingService.updateOutput",
	"Comment": "appends the presented class to the end of the presented bodydeclarations. the body declarations appear within the presentedcompilation unit. this is used to progressively build inner types.",
	"Method": "void updateOutput(CompilationUnit compilationUnit,CompilationUnitServices enclosingCompilationUnitServices,ClassOrInterfaceTypeDetails cid,List<BodyDeclaration> parent){\r\n    return cid.getName();\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.antlrjavaparser.JavaParserTypeParsingService.updateOutput",
	"Comment": "appends the presented class to the end of the presented bodydeclarations. the body declarations appear within the presentedcompilation unit. this is used to progressively build inner types.",
	"Method": "void updateOutput(CompilationUnit compilationUnit,CompilationUnitServices enclosingCompilationUnitServices,ClassOrInterfaceTypeDetails cid,List<BodyDeclaration> parent){\r\n    return compilationUnit.getImports();\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.antlrjavaparser.JavaParserTypeParsingService.updateOutput",
	"Comment": "appends the presented class to the end of the presented bodydeclarations. the body declarations appear within the presentedcompilation unit. this is used to progressively build inner types.",
	"Method": "void updateOutput(CompilationUnit compilationUnit,CompilationUnitServices enclosingCompilationUnitServices,ClassOrInterfaceTypeDetails cid,List<BodyDeclaration> parent){\r\n    return compilationUnit.getTypes();\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.antlrjavaparser.JavaParserTypeParsingService.updateOutput",
	"Comment": "appends the presented class to the end of the presented bodydeclarations. the body declarations appear within the presentedcompilation unit. this is used to progressively build inner types.",
	"Method": "void updateOutput(CompilationUnit compilationUnit,CompilationUnitServices enclosingCompilationUnitServices,ClassOrInterfaceTypeDetails cid,List<BodyDeclaration> parent){\r\n    return cid.getPhysicalTypeCategory();\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.antlrjavaparser.JavaParserTypeParsingService.updateOutput",
	"Comment": "appends the presented class to the end of the presented bodydeclarations. the body declarations appear within the presentedcompilation unit. this is used to progressively build inner types.",
	"Method": "void updateOutput(CompilationUnit compilationUnit,CompilationUnitServices enclosingCompilationUnitServices,ClassOrInterfaceTypeDetails cid,List<BodyDeclaration> parent){\r\n    return finalCompilationUnitServices.getCompilationUnitPackage();\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.antlrjavaparser.JavaParserTypeParsingService.updateOutput",
	"Comment": "appends the presented class to the end of the presented bodydeclarations. the body declarations appear within the presentedcompilation unit. this is used to progressively build inner types.",
	"Method": "void updateOutput(CompilationUnit compilationUnit,CompilationUnitServices enclosingCompilationUnitServices,ClassOrInterfaceTypeDetails cid,List<BodyDeclaration> parent){\r\n    return cid.getName();\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.antlrjavaparser.JavaParserTypeParsingService.updateOutput",
	"Comment": "appends the presented class to the end of the presented bodydeclarations. the body declarations appear within the presentedcompilation unit. this is used to progressively build inner types.",
	"Method": "void updateOutput(CompilationUnit compilationUnit,CompilationUnitServices enclosingCompilationUnitServices,ClassOrInterfaceTypeDetails cid,List<BodyDeclaration> parent){\r\n    return finalCompilationUnitServices.getImports();\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.antlrjavaparser.JavaParserTypeParsingService.updateOutput",
	"Comment": "appends the presented class to the end of the presented bodydeclarations. the body declarations appear within the presentedcompilation unit. this is used to progressively build inner types.",
	"Method": "void updateOutput(CompilationUnit compilationUnit,CompilationUnitServices enclosingCompilationUnitServices,ClassOrInterfaceTypeDetails cid,List<BodyDeclaration> parent){\r\n    return compilationUnit.getTypes();\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.antlrjavaparser.JavaParserTypeParsingService.updateOutput",
	"Comment": "appends the presented class to the end of the presented bodydeclarations. the body declarations appear within the presentedcompilation unit. this is used to progressively build inner types.",
	"Method": "void updateOutput(CompilationUnit compilationUnit,CompilationUnitServices enclosingCompilationUnitServices,ClassOrInterfaceTypeDetails cid,List<BodyDeclaration> parent){\r\n    return cid.getPhysicalTypeCategory();\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.antlrjavaparser.JavaParserTypeParsingService.updateOutput",
	"Comment": "appends the presented class to the end of the presented bodydeclarations. the body declarations appear within the presentedcompilation unit. this is used to progressively build inner types.",
	"Method": "void updateOutput(CompilationUnit compilationUnit,CompilationUnitServices enclosingCompilationUnitServices,ClassOrInterfaceTypeDetails cid,List<BodyDeclaration> parent){\r\n    return importDeclaration.getName().toString().compareTo(importDeclaration1.getName().toString());\r\n}"
}, {
	"Path": "org.springframework.roo.web.ui.Activator.start",
	"Comment": "open the http service tracker to get the http service to register thestatic resources of the spring roo estearn grey ui web app.",
	"Method": "void start(BundleContext context){\r\n    httpTracker = new ServiceTracker(context, HttpService.class.getName(), null) {\r\n        public void removedService(ServiceReference reference, Object service) {\r\n            try {\r\n                ((HttpService) service).unregister(\"/\");\r\n            } catch (IllegalArgumentException exception) {\r\n                LOGGER.log(Level.FINE, \"Servlet registration probably failed earlier.\");\r\n            }\r\n        }\r\n        public Object addingService(ServiceReference reference) {\r\n            HttpService httpService = (HttpService) this.context.getService(reference);\r\n            try {\r\n                httpService.registerServlet(\"/\", new RedirectServlet(CONTEXT_PATH.concat(\"/index.html\")), null, null);\r\n                httpService.registerResources(CONTEXT_PATH, \"ui\", null);\r\n                LOGGER.log(Level.INFO, \"Spring Roo Eastern Grey UI started at 'http://localhost:9191/'\");\r\n            } catch (Exception ex) {\r\n                LOGGER.log(Level.SEVERE, \"Unabled to connect to 'http://localhost:9191/'\", ex);\r\n            }\r\n            return httpService;\r\n        }\r\n    };\r\n    httpTracker.open();\r\n}"
}, {
	"Path": "org.springframework.roo.web.ui.Activator.start",
	"Comment": "open the http service tracker to get the http service to register thestatic resources of the spring roo estearn grey ui web app.",
	"Method": "void start(BundleContext context){\r\n    try {\r\n        ((HttpService) service).unregister(\"/\");\r\n    } catch (IllegalArgumentException exception) {\r\n        LOGGER.log(Level.FINE, \"Servlet registration probably failed earlier.\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.web.ui.Activator.start",
	"Comment": "open the http service tracker to get the http service to register thestatic resources of the spring roo estearn grey ui web app.",
	"Method": "void start(BundleContext context){\r\n    HttpService httpService = (HttpService) this.context.getService(reference);\r\n    try {\r\n        httpService.registerServlet(\"/\", new RedirectServlet(CONTEXT_PATH.concat(\"/index.html\")), null, null);\r\n        httpService.registerResources(CONTEXT_PATH, \"ui\", null);\r\n        LOGGER.log(Level.INFO, \"Spring Roo Eastern Grey UI started at 'http://localhost:9191/'\");\r\n    } catch (Exception ex) {\r\n        LOGGER.log(Level.SEVERE, \"Unabled to connect to 'http://localhost:9191/'\", ex);\r\n    }\r\n    return httpService;\r\n}"
}, {
	"Path": "util.BufferedDataOutputStream.writeLine",
	"Comment": "write the characters of the string s to thisstream as a sequence of bytes, followed by a newline.",
	"Method": "void writeLine(String s){\r\n    this.writeString(s);\r\n    this.writeByte((byte) '\\n');\r\n}"
}, {
	"Path": "org.lamport.org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.getListSelectionLabelDecorator",
	"Comment": "returns the label decorator for selected items in the list.",
	"Method": "ILabelDecorator getListSelectionLabelDecorator(){\r\n    return getItemsListLabelProvider().getSelectionDecorator();\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.itd.ItdSourceFileComposer.newLine",
	"Comment": "prints a blank line, ensuring any indent is included before doing so.",
	"Method": "ItdSourceFileComposer newLine(ItdSourceFileComposer newLine,boolean indent){\r\n    if (indent) {\r\n        appendIndent();\r\n    }\r\n    pw.append(NEW_LINE);\r\n    return this;\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorFeedbackSessionsPageData.getRemindParticularStudentsLink",
	"Comment": "retrieves the link to submit the request to remind particular students.also contains feedbacks page link to return after the action.",
	"Method": "String getRemindParticularStudentsLink(){\r\n    return getInstructorFeedbackRemindParticularStudentsLink(Const.ActionURIs.INSTRUCTOR_FEEDBACK_SESSIONS_PAGE);\r\n}"
}, {
	"Path": "teammates.ui.pagedata.PageData.getInstructorFeedbackResendPublishedEmailLink",
	"Comment": "retrieves the link to submit the request for resending the session published email.",
	"Method": "String getInstructorFeedbackResendPublishedEmailLink(String returnUrl){\r\n    String link = Const.ActionURIs.INSTRUCTOR_FEEDBACK_RESEND_PUBLISHED_EMAIL;\r\n    link = Url.addParamToUrl(link, Const.ParamsNames.NEXT_URL, returnUrl);\r\n    link = addSessionTokenToUrl(link);\r\n    return link;\r\n}"
}, {
	"Path": "sharedcode.turboeditor.util.PixelDipConverter.convertPixelsToDp",
	"Comment": "this method converts device specific pixels to device independent pixels.",
	"Method": "float convertPixelsToDp(float px,Context context){\r\n    final Resources resources = context.getResources();\r\n    final DisplayMetrics metrics = resources.getDisplayMetrics();\r\n    return px / (metrics.densityDpi / 160f);\r\n}"
}, {
	"Path": "tla2sany.semantic.OpApplNode.walkGraph",
	"Comment": "walkgraph finds all reachable nodes in the semantic graphand inserts them in the hashtable semnodestable for use by the explorer tool.",
	"Method": "void walkGraph(Hashtable<Integer, ExploreNode> semNodesTable,ExplorerVisitor visitor){\r\n    Integer uid = Integer.valueOf(myUID);\r\n    if (semNodesTable.get(uid) != null)\r\n        return;\r\n    semNodesTable.put(uid, this);\r\n    visitor.preVisit(this);\r\n    if (operator != null) {\r\n        operator.walkGraph(semNodesTable, visitor);\r\n    }\r\n    if (unboundedBoundSymbols != null && unboundedBoundSymbols.length > 0) {\r\n        for (int i = 0; i < unboundedBoundSymbols.length; i++) if (unboundedBoundSymbols[i] != null)\r\n            unboundedBoundSymbols[i].walkGraph(semNodesTable, visitor);\r\n    }\r\n    if (operands != null && operands.length > 0) {\r\n        for (int i = 0; i < operands.length; i++) if (operands[i] != null)\r\n            operands[i].walkGraph(semNodesTable, visitor);\r\n    }\r\n    if (ranges.length > 0) {\r\n        for (int i = 0; i < ranges.length; i++) if (ranges[i] != null)\r\n            ranges[i].walkGraph(semNodesTable, visitor);\r\n    }\r\n    if (boundedBoundSymbols != null && boundedBoundSymbols.length > 0) {\r\n        for (int i = 0; i < boundedBoundSymbols.length; i++) {\r\n            if (boundedBoundSymbols[i] != null && boundedBoundSymbols[i].length > 0) {\r\n                for (int j = 0; j < boundedBoundSymbols[i].length; j++) {\r\n                    if (boundedBoundSymbols[i][j] != null)\r\n                        boundedBoundSymbols[i][j].walkGraph(semNodesTable, visitor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    visitor.postVisit(this);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.model.TypedSet.hasANumberOnlyValue",
	"Comment": "this test functions checks whether the type has at least one valuethat contain only of digits",
	"Method": "boolean hasANumberOnlyValue(){\r\n    if (hasType()) {\r\n        return !hasValidType();\r\n    } else {\r\n        for (int i = 0; i < values.length; i++) {\r\n            if (values[i].matches(\"[0-9]*\")) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.CheckImpl.checkTrace",
	"Comment": "the main method to check a trace.it gets the states in atrace by calling the getstate method.for each new stateobtained by getstate, checktrace checks if it satisfies allthe invariant properties and if the transition is legal.",
	"Method": "void checkTrace(){\r\n    this.curState = this.getState();\r\n    if (this.curState == null)\r\n        return;\r\n    this.checkState(this.curState);\r\n    while (true) {\r\n        TLCState state = this.getState();\r\n        if (state == null)\r\n            break;\r\n        this.checkState(state);\r\n        this.checkReachability(this.curState, state);\r\n        this.curState = state;\r\n    }\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.utils.Memory.getUsage",
	"Comment": "get memory information like ram usage, ram total, cached memory, swap total etc.",
	"Method": "MemStat getUsage(){\r\n    FileData data = mShell.getFile(\"/proc/meminfo\").read();\r\n    if (data != null && data.size() > 0) {\r\n        String[] lines = data.getArray();\r\n        MemStat stat = new MemStat();\r\n        for (int i = 0; i < lines.length; i++) {\r\n            String[] parts = oPatternSpaceSearch.split(lines[i]);\r\n            if (parts[0].equals(\"MemTotal:\")) {\r\n                stat.mMemTotal = Long.parseLong(parts[1]) * 1024L;\r\n            } else if (parts[0].equals(\"MemFree:\")) {\r\n                stat.mMemFree = Long.parseLong(parts[1]) * 1024L;\r\n            } else if (parts[0].equals(\"Cached:\")) {\r\n                stat.mMemCached = Long.parseLong(parts[1]) * 1024L;\r\n            } else if (parts[0].equals(\"SwapTotal:\")) {\r\n                stat.mSwapTotal = Long.parseLong(parts[1]) * 1024L;\r\n            } else if (parts[0].equals(\"SwapFree:\")) {\r\n                stat.mSwapFree = Long.parseLong(parts[1]) * 1024L;\r\n            } else if (parts[0].equals(\"SwapCached:\")) {\r\n                stat.mSwapCached = Long.parseLong(parts[1]) * 1024L;\r\n            }\r\n        }\r\n        return stat;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.twelvemonkeys.io.FileUtil.copyDir",
	"Comment": "copies a directory recursively. if the destination folder does not exist,it is created",
	"Method": "boolean copyDir(File pFrom,File pTo,boolean pOverWrite){\r\n    if (pTo.exists() && !pTo.isDirectory()) {\r\n        throw new IOException(\"A directory may only be copied to another directory, not to a file\");\r\n    }\r\n    pTo.mkdirs();\r\n    boolean allOkay = true;\r\n    File[] files = pFrom.listFiles();\r\n    for (File file : files) {\r\n        if (!copy(file, new File(pTo, file.getName()), pOverWrite)) {\r\n            allOkay = false;\r\n        }\r\n    }\r\n    return allOkay;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.output.source.CachingTLAPMOutputSource.addListener",
	"Comment": "adds the listener to the list of listenersto be notified of new data and informs the listenerof all existing data.does nothing if the listener is already connectedto this source.",
	"Method": "void addListener(ITLAPMOutputSourceListener listener){\r\n    if (!listeners.contains(listener)) {\r\n        listeners.add(listener);\r\n        for (Iterator it = outputData.iterator(); it.hasNext(); ) {\r\n            listener.newData((TLAPMMessage) it.next());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.WsEndpointsMetadata.getEndpointMethod",
	"Comment": "this method obtains the method that will be used to registered the endpoint",
	"Method": "MethodMetadata getEndpointMethod(JavaType endpoint){\r\n    if (endpointMethods.get(endpoint) != null) {\r\n        return endpointMethods.get(endpoint);\r\n    }\r\n    InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\r\n    bodyBuilder.appendFormalLine(\"%s endpoint = new EndpointImpl(%s(), new %s(%s()));\", getNameOfJavaType(new JavaType(\"org.apache.cxf.jaxws.EndpointImpl\")), getAccessorMethod(getBusField()).getMethodName(), getNameOfJavaType(endpoint), getAccessorMethod(getServiceField(getServiceFromEndpoint(endpoint))).getMethodName());\r\n    bodyBuilder.appendFormalLine(\"endpoint.setFeatures(%s.asList(new %s(), new %s()));\", getNameOfJavaType(JavaType.ARRAYS), getNameOfJavaType(new JavaType(\"io.tracee.binding.cxf.TraceeCxfFeature\")), getNameOfJavaType(new JavaType(\"org.apache.cxf.feature.LoggingFeature\")));\r\n    bodyBuilder.appendFormalLine(\"endpoint.publish(\\\"/%s\\\");\", getSeiFromEndpoint(endpoint).getSimpleTypeName());\r\n    bodyBuilder.appendFormalLine(\"return endpoint;\");\r\n    MethodMetadataBuilder endpointMethod = new MethodMetadataBuilder(getId(), Modifier.PUBLIC, new JavaSymbolName(StringUtils.uncapitalize(endpoint.getSimpleTypeName())), JavaType.ENDPOINT, bodyBuilder);\r\n    endpointMethod.addAnnotation(new AnnotationMetadataBuilder(SpringJavaType.BEAN));\r\n    endpointMethods.put(endpoint, endpointMethod.build());\r\n    return endpointMethod.build();\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.utils.File.getParentPath",
	"Comment": "returns the parent path. note that on folders, this means the parent folder. \thowever, on files, it will return the folder path that the file resides in.",
	"Method": "String getParentPath(){\r\n    return mFile.getParent();\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.waitForElementToBeMemberOfClass",
	"Comment": "waits until an element belongs to the class or the timeout expires.",
	"Method": "void waitForElementToBeMemberOfClass(WebElement element,String elementClass){\r\n    waitFor(driver -> {\r\n        String classAttribute = element.getAttribute(\"class\");\r\n        List<String> classes = Arrays.asList(classAttribute.split(\" \"));\r\n        return classes.contains(elementClass);\r\n    });\r\n}"
}, {
	"Path": "tlc2.util.BigInt.equals",
	"Comment": "returns true iff x is a bigint whose value is equal to this.value. this method is provided so that bigints can be used as hash keys.",
	"Method": "boolean equals(Object x){\r\n    return ((x instanceof BigInt) && super.equals(x));\r\n}"
}, {
	"Path": "teammates.logic.core.InstructorsLogic.updateInstructorByEmail",
	"Comment": "update the google id and name of an instructor with the specific email.",
	"Method": "void updateInstructorByEmail(String email,InstructorAttributes instructor){\r\n    Assumption.assertNotNull(\"Supplied parameter was null\", instructor);\r\n    coursesLogic.verifyCourseIsPresent(instructor.courseId);\r\n    verifyIsEmailOfInstructorOfCourse(email, instructor.courseId);\r\n    instructorsDb.updateInstructorByEmail(instructor);\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackSessionsDb.addStudentRespondents",
	"Comment": "the objectify library does not support throwing checked exceptions inside transactions",
	"Method": "void addStudentRespondents(List<String> emails,FeedbackSessionAttributes feedbackSession){\r\n    Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, emails);\r\n    Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSession);\r\n    feedbackSession.sanitizeForSaving();\r\n    if (!feedbackSession.isValid()) {\r\n        throw new InvalidParametersException(feedbackSession.getInvalidityInfo());\r\n    }\r\n    try {\r\n        ofy().transact(new VoidWork() {\r\n            @Override\r\n            public void vrun() {\r\n                FeedbackSession fs = getEntity(feedbackSession);\r\n                if (fs == null) {\r\n                    throw new RuntimeException(new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString()));\r\n                }\r\n                fs.getRespondingStudentList().addAll(emails);\r\n                saveEntity(fs, feedbackSession);\r\n            }\r\n        });\r\n    } catch (RuntimeException e) {\r\n        if (e.getCause() instanceof EntityDoesNotExistException) {\r\n            throw (EntityDoesNotExistException) e.getCause();\r\n        }\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackSessionsDb.addStudentRespondents",
	"Comment": "the objectify library does not support throwing checked exceptions inside transactions",
	"Method": "void addStudentRespondents(List<String> emails,FeedbackSessionAttributes feedbackSession){\r\n    FeedbackSession fs = getEntity(feedbackSession);\r\n    if (fs == null) {\r\n        throw new RuntimeException(new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString()));\r\n    }\r\n    fs.getRespondingStudentList().addAll(emails);\r\n    saveEntity(fs, feedbackSession);\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorFeedbackEditPageData.getEditCopyActionLink",
	"Comment": "retrieves the link to submit the request for copy of session.also contains feedback page link to return after the action.",
	"Method": "String getEditCopyActionLink(){\r\n    return getInstructorFeedbackEditCopyActionLink(Const.ActionURIs.INSTRUCTOR_FEEDBACK_SESSIONS_PAGE);\r\n}"
}, {
	"Path": "com.twelvemonkeys.net.MIMEUtil.main",
	"Comment": "for debugging. prints all known mime types and file extensions.",
	"Method": "void main(String[] pArgs){\r\n    if (pArgs.length > 1) {\r\n        String type = pArgs[0];\r\n        String family = pArgs[1];\r\n        boolean incuded = includes(family, type);\r\n        System.out.println(\"Mime type family \" + family + (incuded ? \" includes \" : \" does not include \") + \"type \" + type);\r\n    }\r\n    if (pArgs.length > 0) {\r\n        String str = pArgs[0];\r\n        if (str.indexOf('/') >= 0) {\r\n            String extension = getExtension(str);\r\n            System.out.println(\"Default extension for MIME type '\" + str + \"' is \" + (extension != null ? \": '\" + extension + \"'\" : \"unknown\") + \".\");\r\n            System.out.println(\"All possible: \" + getExtensions(str));\r\n        } else {\r\n            String mimeType = getMIMEType(str);\r\n            System.out.println(\"Default MIME type for extension '\" + str + \"' is \" + (mimeType != null ? \": '\" + mimeType + \"'\" : \"unknown\") + \".\");\r\n            System.out.println(\"All possible: \" + getMIMETypes(str));\r\n        }\r\n        return;\r\n    }\r\n    Set set = sMIMEToExt.keySet();\r\n    String[] mimeTypes = new String[set.size()];\r\n    int i = 0;\r\n    for (Iterator iterator = set.iterator(); iterator.hasNext(); i++) {\r\n        String mime = (String) iterator.next();\r\n        mimeTypes[i] = mime;\r\n    }\r\n    Arrays.sort(mimeTypes);\r\n    System.out.println(\"Known MIME types (\" + mimeTypes.length + \"):\");\r\n    for (int j = 0; j < mimeTypes.length; j++) {\r\n        String mimeType = mimeTypes[j];\r\n        if (j != 0) {\r\n            System.out.print(\", \");\r\n        }\r\n        System.out.print(mimeType);\r\n    }\r\n    System.out.println(\"\\n\");\r\n    set = sExtToMIME.keySet();\r\n    String[] extensions = new String[set.size()];\r\n    i = 0;\r\n    for (Iterator iterator = set.iterator(); iterator.hasNext(); i++) {\r\n        String ext = (String) iterator.next();\r\n        extensions[i] = ext;\r\n    }\r\n    Arrays.sort(extensions);\r\n    System.out.println(\"Known file types (\" + extensions.length + \"):\");\r\n    for (int j = 0; j < extensions.length; j++) {\r\n        String extension = extensions[j];\r\n        if (j != 0) {\r\n            System.out.print(\", \");\r\n        }\r\n        System.out.print(extension);\r\n    }\r\n    System.out.println();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.FontPreferenceChangeListener.addControl",
	"Comment": "adds a control to the set of controls whose font should beset when the preference corresponding to preferencename is changed",
	"Method": "void addControl(Control control){\r\n    controls.add(control);\r\n}"
}, {
	"Path": "teammates.common.util.Url.toAbsoluteString",
	"Comment": "returns the absolute version of the url by appending the base urlto the url input.",
	"Method": "String toAbsoluteString(){\r\n    return baseUrl + toString();\r\n}"
}, {
	"Path": "tlc2.tool.liveness.LiveCheck1.checkSubcomponent",
	"Comment": "checksubcomponent checks if a subcomponent satisfies the aes of the\tcurrent pem, and is fulfilling. the subcomponents are those after pruning\teas. when a counterexample is found, it throws a liveexception exception.",
	"Method": "void checkSubcomponent(BEGraphNode node){\r\n    int slen = currentOOS.getCheckState().length;\r\n    int alen = currentOOS.getCheckAction().length;\r\n    boolean[] AEStateRes = new boolean[currentPEM.AEState.length];\r\n    boolean[] AEActionRes = new boolean[currentPEM.AEAction.length];\r\n    boolean[] promiseRes = new boolean[currentOOS.getPromises().length];\r\n    ObjectStack stack = new MemObjectStack(metadir, \"subcomstack\");\r\n    node.incNumber();\r\n    stack.push(node);\r\n    while (stack.size() != 0) {\r\n        BEGraphNode curNode = (BEGraphNode) stack.pop();\r\n        for (int i = 0; i < currentPEM.AEState.length; i++) {\r\n            if (!AEStateRes[i]) {\r\n                int idx = currentPEM.AEState[i];\r\n                AEStateRes[i] = curNode.getCheckState(idx);\r\n            }\r\n        }\r\n        int nsz = curNode.nextSize();\r\n        for (int i = 0; i < nsz; i++) {\r\n            BEGraphNode node1 = curNode.nextAt(i);\r\n            long num = node1.getNumber();\r\n            if (num >= thirdNum) {\r\n                for (int j = 0; j < currentPEM.AEAction.length; j++) {\r\n                    if (!AEActionRes[j]) {\r\n                        int idx = currentPEM.AEAction[j];\r\n                        AEActionRes[j] = curNode.getCheckAction(slen, alen, i, idx);\r\n                    }\r\n                }\r\n            }\r\n            if (num == thirdNum) {\r\n                node1.incNumber();\r\n                stack.push(node1);\r\n            }\r\n        }\r\n        for (int i = 0; i < currentOOS.getPromises().length; i++) {\r\n            LNEven promise = currentOOS.getPromises()[i];\r\n            TBPar par = curNode.getTNode(currentOOS.getTableau()).getPar();\r\n            if (par.isFulfilling(promise)) {\r\n                promiseRes[i] = true;\r\n            }\r\n        }\r\n    }\r\n    thirdNum += 2;\r\n    for (int i = 0; i < currentPEM.AEState.length; i++) {\r\n        if (!AEStateRes[i]) {\r\n            return;\r\n        }\r\n    }\r\n    for (int i = 0; i < currentPEM.AEAction.length; i++) {\r\n        if (!AEActionRes[i]) {\r\n            return;\r\n        }\r\n    }\r\n    for (int i = 0; i < currentOOS.getPromises().length; i++) {\r\n        if (!promiseRes[i]) {\r\n            return;\r\n        }\r\n    }\r\n    try {\r\n        printErrorTrace(node);\r\n    } catch (IOException e) {\r\n        MP.printError(EC.GENERAL, \"printing an error trace\", e);\r\n    }\r\n    throw new LiveException(\"LiveCheck: Found error trace.\");\r\n}"
}, {
	"Path": "tla2sany.modanalyzer.SpecObj.getInitErrors",
	"Comment": "returns errors object produced during initialization of the frontend.should never be interesting.",
	"Method": "Errors getInitErrors(){\r\n    return initErrors;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.itd.ItdSourceFileComposer.appendInnerTypes",
	"Comment": "supports static inner types with static field definitions only at thispoint",
	"Method": "void appendInnerTypes(){\r\n    final List<ClassOrInterfaceTypeDetails> innerTypes = itdTypeDetails.getInnerTypes();\r\n    for (final ClassOrInterfaceTypeDetails innerType : innerTypes) {\r\n        content = true;\r\n        appendIndent();\r\n        if (innerType.getModifier() != 0) {\r\n            append(Modifier.toString(innerType.getModifier()));\r\n            append(\" \");\r\n        }\r\n        append(\"class \");\r\n        append(introductionTo.getNameIncludingTypeParameters());\r\n        append(\".\");\r\n        append(innerType.getName().getSimpleTypeName());\r\n        writeExtends(innerType);\r\n        final List<JavaType> implementsTypes = innerType.getImplementsTypes();\r\n        writeImplements(implementsTypes);\r\n        append(\"{\");\r\n        this.newLine(false);\r\n        writeInnerTypeFields(innerType);\r\n        this.newLine(false);\r\n        indent();\r\n        writeInnerTypeConstructors(innerType.getName(), innerType.getDeclaredConstructors(), false, false);\r\n        indentRemove();\r\n        indent();\r\n        writeMethods(innerType.getDeclaredMethods(), false, false);\r\n        indentRemove();\r\n        appendIndent();\r\n        append(\"}\");\r\n        this.newLine(false);\r\n        this.newLine();\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.ConcurrentTLCTrace.printTrace",
	"Comment": "write out a sequence of states that reaches s2 from an initial state,\taccording to the spec. s2 is a next state of s1.",
	"Method": "void printTrace(TLCState s1,TLCState s2){\r\n    if (s1.isInitial()) {\r\n        printTrace(s1, s2, new TLCStateInfo[0]);\r\n    } else {\r\n        printTrace(s1, s2, getTrace(s1));\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.launch.TLCModelLaunchDelegate.preLaunchCheck",
	"Comment": "returns whether a launch should proceed. this method is called firstin the launch sequence providing an opportunity for this launch delegateto abort the launch.2. method called on launch",
	"Method": "boolean preLaunchCheck(ILaunchConfiguration config,String mode,IProgressMonitor monitor){\r\n    if (!config.exists()) {\r\n        return false;\r\n    }\r\n    try {\r\n        monitor.beginTask(\"Reading model parameters\", 1);\r\n    } finally {\r\n        monitor.done();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.ResourceHelper.isValidSpecName",
	"Comment": "checks a specification name for its validity wrt the parser identifier definition",
	"Method": "boolean isValidSpecName(String aSpecName){\r\n    String identifier = getIdentifier(aSpecName);\r\n    return aSpecName.equals(identifier);\r\n}"
}, {
	"Path": "teammates.test.cases.BaseTestCase.getTypicalDataBundle",
	"Comment": "creates a databundle as specified in typicaldatabundle.json.",
	"Method": "DataBundle getTypicalDataBundle(){\r\n    return loadDataBundle(\"/typicalDataBundle.json\");\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.spec.manager.WorkspaceSpecManager.getSelection",
	"Comment": "retrieves loaded spec encapsulated in to a selection object",
	"Method": "ISelection getSelection(){\r\n    if (this.loadedSpec != null) {\r\n        return new StructuredSelection(this.loadedSpec);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.TLCStateMutSource.fingerPrint",
	"Comment": "this method returns the fingerprint of this state. we fingerprintthe values in the state according to the order given by vars.this guarantees the same state has the same fingerprint.since the values in this state can be shared by multiple threadsvia the state queue. they have to be normalized before adding tothe state queue.we do that here.",
	"Method": "long fingerPrint(){\r\n    int sz = this.values.length;\r\n    Value[] minVals = this.values;\r\n    if (perms != null) {\r\n        Value[] vals = new Value[sz];\r\n        for (int i = 0; i < perms.length; i++) {\r\n            int cmp = 0;\r\n            for (int j = 0; j < sz; j++) {\r\n                vals[j] = this.values[j].permute(perms[i]);\r\n                if (cmp == 0) {\r\n                    cmp = vals[j].compareTo(minVals[j]);\r\n                }\r\n            }\r\n            if (cmp < 0) {\r\n                if (minVals == this.values) {\r\n                    minVals = vals;\r\n                    vals = new Value[sz];\r\n                } else {\r\n                    Value[] temp = minVals;\r\n                    minVals = vals;\r\n                    vals = temp;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    long fp = FP64.New();\r\n    if (viewMap == null) {\r\n        for (int i = 0; i < sz; i++) {\r\n            fp = minVals[i].fingerPrint(fp);\r\n        }\r\n        if (this.values != minVals) {\r\n            for (int i = 0; i < sz; i++) {\r\n                this.values[i].deepNormalize();\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = 0; i < sz; i++) {\r\n            this.values[i].deepNormalize();\r\n        }\r\n        TLCStateMutSource state = this;\r\n        if (minVals != this.values) {\r\n            state = new TLCStateMutSource(minVals, this.asts);\r\n        }\r\n        Value val = mytool.eval(viewMap, Context.Empty, state);\r\n        fp = val.fingerPrint(fp);\r\n    }\r\n    return fp;\r\n}"
}, {
	"Path": "org.springframework.roo.converters.JavaPackageConverterTest.assertConvertFromValidText",
	"Comment": "asserts that converting the given text in the given option contextresults in the expected package name",
	"Method": "void assertConvertFromValidText(String text,String optionContext,String expectedPackage){\r\n    when(mockProjectOperations.isProjectAvailable(mockPom.getModuleName())).thenReturn(true);\r\n    when(mockProjectOperations.getFocusedModule()).thenReturn(mockPom);\r\n    when(mockTypeLocationService.getTopLevelPackageForModule(mockPom)).thenReturn(TOP_LEVEL_PACKAGE);\r\n    assertEquals(expectedPackage, converter.convertFromText(text, JavaPackage.class, optionContext).getFullyQualifiedPackageName());\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.ShowUsesParseResultListener.newParseResult",
	"Comment": "i have no idea when this method is supposed to be called, but i have notseen it ever called.",
	"Method": "void newParseResult(ParseResult parseResult){\r\n    TLAEditorActivator.getDefault().logDebug(\"newParseResult called with status: \" + parseResult.getStatus());\r\n}"
}, {
	"Path": "teammates.common.datatransfer.CourseDetailsBundle.sortDetailedCoursesByCreationDate",
	"Comment": "sorts courses based on course creation date in the order of latest to oldest order.",
	"Method": "void sortDetailedCoursesByCreationDate(List<CourseDetailsBundle> courses){\r\n    courses.sort(Comparator.comparing((CourseDetailsBundle obj) -> obj.course.createdAt).reversed());\r\n}"
}, {
	"Path": "org.lamport.org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.refreshDetails",
	"Comment": "refreshes the details field according to the current selection in the\titems list.",
	"Method": "void refreshDetails(){\r\n    StructuredSelection selection = getSelectedItems();\r\n    switch(selection.size()) {\r\n        case 0:\r\n            details.setInput(null);\r\n            break;\r\n        case 1:\r\n            details.setInput(selection.getFirstElement());\r\n            break;\r\n        default:\r\n            details.setInput(NLS.bind(WorkbenchMessages.FilteredItemsSelectionDialog_nItemsSelected, new Integer(selection.size())));\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.job.ProverJob.getLevelNode",
	"Comment": "gets the step or module node on which theprover was launched.",
	"Method": "LevelNode getLevelNode(){\r\n    return nodeToProve;\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.restoreAllFeedbackSessionsFromRecycleBin",
	"Comment": "restores all feedback sessions from recycle bin to feedback sessions table.",
	"Method": "void restoreAllFeedbackSessionsFromRecycleBin(List<InstructorAttributes> instructorList){\r\n    Assumption.assertNotNull(\"Supplied parameter was null\", instructorList);\r\n    List<FeedbackSessionAttributes> feedbackSessionsList = getSoftDeletedFeedbackSessionsListForInstructors(instructorList);\r\n    for (FeedbackSessionAttributes session : feedbackSessionsList) {\r\n        restoreFeedbackSessionFromRecycleBin(session.getFeedbackSessionName(), session.getCourseId());\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.color.ColorSpaces.isCS_sRGB",
	"Comment": "tests whether an icc color profile is equal to the default srgb profile.",
	"Method": "boolean isCS_sRGB(ICC_Profile profile){\r\n    Validate.notNull(profile, \"profile\");\r\n    return profile.getColorSpaceType() == ColorSpace.TYPE_RGB && Arrays.equals(getProfileHeaderWithProfileId(profile), sRGB.header);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.dialog.TLAPMErrorDialog.setImage",
	"Comment": "sets the image that will be displayed next to the messagein the dialog.",
	"Method": "void setImage(Image image){\r\n    this.image = image;\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.XmlUtils.assertElementLegal",
	"Comment": "checks the presented element for illegal characters that could causemalformed xml.",
	"Method": "void assertElementLegal(String element){\r\n    if (StringUtils.isBlank(element)) {\r\n        throw new IllegalArgumentException(\"Element required\");\r\n    }\r\n    final char[] value = element.toCharArray();\r\n    for (final char c : value) {\r\n        if (' ' == c || '>' == c || '<' == c || '!' == c || '@' == c || '%' == c || '^' == c || '?' == c || '(' == c || ')' == c || '~' == c || '`' == c || '{' == c || '}' == c || '[' == c || ']' == c || '|' == c || '\\\\' == c || '\\'' == c || '+' == c) {\r\n            throw new IllegalArgumentException(\"Illegal name '\" + element + \"' (illegal character)\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.FeedbackSessionAttributes.isInGracePeriod",
	"Comment": "returns true if the session is currently close but is still accept responses.",
	"Method": "boolean isInGracePeriod(){\r\n    Instant now = Instant.now();\r\n    Instant gracedEnd = endTime.plus(gracePeriod);\r\n    return (now.isAfter(endTime) || now.equals(endTime)) && (now.isBefore(gracedEnd) || now.equals(gracedEnd));\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.path.Paths.applyClippingPath",
	"Comment": "applies the clipping path to the given image.all pixels outside the path will be transparent.",
	"Method": "BufferedImage applyClippingPath(Shape clip,BufferedImage image,BufferedImage applyClippingPath,Shape clip,BufferedImage image,BufferedImage destination){\r\n    notNull(clip, \"clip\");\r\n    notNull(image, \"image\");\r\n    isTrue(destination != null && destination != image, \"destination may not be null or same instance as image\");\r\n    Graphics2D g = destination.createGraphics();\r\n    try {\r\n        AffineTransform originalTransform = g.getTransform();\r\n        g.scale(image.getWidth(), image.getHeight());\r\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\r\n        g.fill(clip);\r\n        g.setTransform(originalTransform);\r\n        g.setComposite(AlphaComposite.SrcIn);\r\n        g.drawImage(image, 0, 0, null);\r\n    } finally {\r\n        g.dispose();\r\n    }\r\n    return destination;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.output.data.TraceExplorerDataProvider.getTraceExpressionsInformation",
	"Comment": "collects and stores trace expression information for later use.",
	"Method": "void getTraceExpressionsInformation(){\r\n    if (traceExpressionDataTable == null) {\r\n        traceExpressionDataTable = new Hashtable<String, TraceExpressionInformationHolder>();\r\n    }\r\n    traceExpressionDataTable.clear();\r\n    IFile teFile = getModel().getTraceExplorerTLAFile();\r\n    FileEditorInput teFileEditorInput = new FileEditorInput((IFile) teFile);\r\n    FileDocumentProvider teFileDocumentProvider = new LegacyFileDocumentProvider();\r\n    try {\r\n        teFileDocumentProvider.connect(teFileEditorInput);\r\n        IDocument teDocument = teFileDocumentProvider.getDocument(teFileEditorInput);\r\n        FindReplaceDocumentAdapter teSearcher = new FindReplaceDocumentAdapter(teDocument);\r\n        String regularExpression = FindReplaceDocumentAdapter.escapeForRegExPattern(\"\\\\* \") + \":[0-2]:\" + ModelWriter.TRACE_EXPR_VAR_SCHEME + \"_[0-9]{17,}:[\\\\s\\\\S]*?\" + Pattern.quote(ModelWriter.CONSTANT_EXPRESSION_EVAL_IDENTIFIER) + \"\\n\";\r\n        IRegion region = teSearcher.find(0, regularExpression, true, true, false, true);\r\n        while (region != null) {\r\n            String commentString = teDocument.get(region.getOffset(), region.getLength());\r\n            String[] stringSections = commentString.split(\":\", 4);\r\n            int level = Integer.parseInt(stringSections[1]);\r\n            String variableName = stringSections[2];\r\n            String expressionAndDelimiter = stringSections[3];\r\n            String expression = expressionAndDelimiter.substring(0, expressionAndDelimiter.indexOf(ModelWriter.CONSTANT_EXPRESSION_EVAL_IDENTIFIER));\r\n            TraceExpressionInformationHolder expressionData = new TraceExpressionInformationHolder(expression, null, variableName);\r\n            expressionData.setLevel(level);\r\n            this.traceExpressionDataTable.put(variableName.trim(), expressionData);\r\n            region = teSearcher.find(region.getOffset() + region.getLength(), regularExpression, true, true, false, true);\r\n        }\r\n    } catch (CoreException e) {\r\n        TLCUIActivator.getDefault().logError(\"Error finding trace expression information in TE.tla file.\", e);\r\n    } catch (BadLocationException e) {\r\n        TLCUIActivator.getDefault().logError(\"Error finding trace expression information in TE.tla file.\", e);\r\n    } finally {\r\n        teFileDocumentProvider.disconnect(teFileEditorInput);\r\n    }\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.getFeedbackSessionResultsForInstructorFromQuestion",
	"Comment": "gets results of a feedback session to show to an instructor from an indicated question.this will not retrieve the list of comments for this question.",
	"Method": "FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorFromQuestion(String feedbackSessionName,String courseId,String userEmail,String questionId){\r\n    CourseRoster roster = new CourseRoster(studentsLogic.getStudentsForCourse(courseId), instructorsLogic.getInstructorsForCourse(courseId));\r\n    Map<String, String> params = new HashMap();\r\n    params.put(PARAM_IS_INCLUDE_RESPONSE_STATUS, \"true\");\r\n    params.put(PARAM_IN_SECTION, \"false\");\r\n    params.put(PARAM_FROM_SECTION, \"false\");\r\n    params.put(PARAM_TO_SECTION, \"false\");\r\n    params.put(PARAM_QUESTION_ID, questionId);\r\n    return getFeedbackSessionResultsForUserWithParams(feedbackSessionName, courseId, userEmail, UserRole.INSTRUCTOR, roster, params);\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.waitForTextsForAllStatusMessagesToUserEquals",
	"Comment": "waits and verifies that the texts of user status messages in the page are equal to the expected texts.the check is done multiple times with waiting times in between to account fortiming issues due to page load, inconsistencies in selenium api, etc.",
	"Method": "void waitForTextsForAllStatusMessagesToUserEquals(String firstExpectedText,String remainingExpectedTexts){\r\n    List<String> expectedTexts = Arrays.asList(ObjectArrays.concat(firstExpectedText, remainingExpectedTexts));\r\n    try {\r\n        uiRetryManager.runUntilNoRecognizedException(new RetryableTask(\"Verify status to user\") {\r\n            @Override\r\n            public void run() {\r\n                new Actions(browser.driver).moveToElement(statusMessage).perform();\r\n                waitForElementVisibility(statusMessage);\r\n                assertEquals(expectedTexts, getTextsForAllStatusMessagesToUser());\r\n            }\r\n        }, WebDriverException.class, AssertionError.class);\r\n    } catch (MaximumRetriesExceededException e) {\r\n        assertEquals(expectedTexts, getTextsForAllStatusMessagesToUser());\r\n    }\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.waitForTextsForAllStatusMessagesToUserEquals",
	"Comment": "waits and verifies that the texts of user status messages in the page are equal to the expected texts.the check is done multiple times with waiting times in between to account fortiming issues due to page load, inconsistencies in selenium api, etc.",
	"Method": "void waitForTextsForAllStatusMessagesToUserEquals(String firstExpectedText,String remainingExpectedTexts){\r\n    new Actions(browser.driver).moveToElement(statusMessage).perform();\r\n    waitForElementVisibility(statusMessage);\r\n    assertEquals(expectedTexts, getTextsForAllStatusMessagesToUser());\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackQuestionDetails.isIndividualResponsesShownToStudents",
	"Comment": "individual responses are shown by default.override for specific question types if necessary.",
	"Method": "boolean isIndividualResponsesShownToStudents(){\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.comments.JavadocComment.addDescription",
	"Comment": "adds a new description or changes an existing in the javadoccomment.",
	"Method": "void addDescription(String description){\r\n    String[] descriptionLines = description.split(IOUtils.LINE_SEPARATOR);\r\n    if (this.getComment() == null || this.getComment().isEmpty()) {\r\n        Validate.isTrue(StringUtils.isNotBlank(description), \"The provided comment must be not null, not blank nor empty.\");\r\n        checkJavadocSyntax(description);\r\n        initializeCommentIndexes();\r\n    } else {\r\n        initializeCommentIndexes();\r\n        this.commentBuilder.delete(this.beginDescriptionIndex, this.endDescriptionIndex);\r\n        for (String line : descriptionLines) {\r\n            String newLine = (\" * \").concat(line).concat(IOUtils.LINE_SEPARATOR);\r\n            this.commentBuilder.insert(this.beginDescriptionIndex, newLine);\r\n            int newLineLenght = newLine.length();\r\n            this.endDescriptionIndex += newLineLenght;\r\n            this.endParamsIndex += newLineLenght;\r\n            this.endReturnIndex += newLineLenght;\r\n            this.endThrowsIndex += newLineLenght;\r\n        }\r\n    }\r\n    super.setComment(this.commentBuilder.toString());\r\n}"
}, {
	"Path": "teammates.common.util.JsonUtils.toJson",
	"Comment": "serializes the specified object into its equivalent json string.",
	"Method": "String toJson(Object src,Type typeOfSrc,String toJson,Object src){\r\n    return getTeammatesGson().toJson(src);\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.ObjectAbstractTest.readExternalFormFromDisk",
	"Comment": "reads a serialized or externalized object from disk.useful for creating compatibility tests betweendifferent cvs versions of the same class",
	"Method": "Object readExternalFormFromDisk(String path){\r\n    FileInputStream stream = new FileInputStream(path);\r\n    return readExternalFormFromStream(stream);\r\n}"
}, {
	"Path": "tla2sany.semantic.OpApplNode.getBdedQuantBounds",
	"Comment": "returns array of the bound expressions for quantified variables thatare bounded in this operator application.",
	"Method": "ExprNode[] getBdedQuantBounds(){\r\n    return this.ranges;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.attributes.FeedbackSessionAttributes.isClosedWithinPastHour",
	"Comment": "checks if the session closed some time in the last one hour from calling this function.",
	"Method": "boolean isClosedWithinPastHour(){\r\n    Instant now = Instant.now();\r\n    Instant given = endTime.plus(gracePeriod);\r\n    return given.isBefore(now) && Duration.between(given, now).compareTo(Duration.ofHours(1)) < 0;\r\n}"
}, {
	"Path": "teammates.test.cases.search.InstructorSearchTest.standardizeInstructorsForComparison",
	"Comment": "standardizes instructors for comparison by setting key fields to null",
	"Method": "void standardizeInstructorsForComparison(InstructorAttributes instructors){\r\n    for (InstructorAttributes instructor : instructors) {\r\n        instructor.key = null;\r\n    }\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.waitForTextContainedInElementAbsence",
	"Comment": "waits for text contained in the element to disappear from the page, or timeout.",
	"Method": "void waitForTextContainedInElementAbsence(By by,String text){\r\n    waitFor(ExpectedConditions.not(ExpectedConditions.textToBePresentInElementLocated(by, text)));\r\n}"
}, {
	"Path": "org.lamport.org.eclipse.ui.dialogs.FilteredItemsSelectionDialog.handleSelected",
	"Comment": "handle selection in the items list by updating labels of selected and\tunselected items and refresh the details field using the selection.",
	"Method": "void handleSelected(StructuredSelection selection){\r\n    IStatus status = new Status(IStatus.OK, PlatformUI.PLUGIN_ID, IStatus.OK, EMPTY_STRING, null);\r\n    Object[] lastSelection = currentSelection;\r\n    currentSelection = selection.toArray();\r\n    if (selection.size() == 0) {\r\n        status = new Status(IStatus.ERROR, PlatformUI.PLUGIN_ID, IStatus.ERROR, EMPTY_STRING, null);\r\n        if (lastSelection != null && getListSelectionLabelDecorator() != null) {\r\n            list.update(lastSelection, null);\r\n        }\r\n        currentSelection = null;\r\n    } else {\r\n        status = new Status(IStatus.ERROR, PlatformUI.PLUGIN_ID, IStatus.ERROR, EMPTY_STRING, null);\r\n        List items = selection.toList();\r\n        Object item = null;\r\n        IStatus tempStatus = null;\r\n        for (Iterator it = items.iterator(); it.hasNext(); ) {\r\n            Object o = it.next();\r\n            if (o instanceof ItemsListSeparator) {\r\n                continue;\r\n            }\r\n            item = o;\r\n            tempStatus = validateItem(item);\r\n            if (tempStatus.isOK()) {\r\n                status = new Status(IStatus.OK, PlatformUI.PLUGIN_ID, IStatus.OK, EMPTY_STRING, null);\r\n            } else {\r\n                status = tempStatus;\r\n                break;\r\n            }\r\n        }\r\n        if (lastSelection != null && getListSelectionLabelDecorator() != null) {\r\n            list.update(lastSelection, null);\r\n        }\r\n        if (getListSelectionLabelDecorator() != null) {\r\n            list.update(currentSelection, null);\r\n        }\r\n    }\r\n    refreshDetails();\r\n    updateStatus(status);\r\n}"
}, {
	"Path": "org.springframework.roo.project.maven.Pom.getArtifactId",
	"Comment": "returns the id of the artifact created by this module or project",
	"Method": "String getArtifactId(){\r\n    return gav.getArtifactId();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.DecomposeProofHandler.newInsertPos",
	"Comment": "the new position corresponding to old position oldpos after the insertionins. see comments for the insertion class.",
	"Method": "int newInsertPos(int oldPos,Insertion ins){\r\n    if (oldPos <= ins.pos) {\r\n        return oldPos;\r\n    }\r\n    if (oldPos < ins.pos + ins.oldLen) {\r\n        if (oldPos < ins.pos + ins.newLen) {\r\n            return oldPos;\r\n        } else {\r\n            return ins.pos + ins.newLen - ins.oldLen;\r\n        }\r\n    } else {\r\n        return oldPos + ins.newLen - ins.oldLen;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.AbstractMemberHoldingTypeDetailsBuilder.setDeclaredFields",
	"Comment": "sets the builders for the fields to be declared by the type being built",
	"Method": "void setDeclaredFields(Collection<? extends FieldMetadataBuilder> declaredFields){\r\n    this.declaredFields.clear();\r\n    if (declaredFields != null) {\r\n        this.declaredFields.addAll(declaredFields);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.DomUtils.getTextValue",
	"Comment": "extract the text value from the given dom element, ignoring xml comments.appends all characterdata nodes and entityreference nodes into a singlestring value, excluding comment nodes.",
	"Method": "String getTextValue(Element valueElement){\r\n    Validate.notNull(valueElement, \"Element must not be null\");\r\n    final StringBuilder sb = new StringBuilder();\r\n    final NodeList nl = valueElement.getChildNodes();\r\n    for (int i = 0; i < nl.getLength(); i++) {\r\n        final Node item = nl.item(i);\r\n        if (item instanceof CharacterData && !(item instanceof Comment) || item instanceof EntityReference) {\r\n            sb.append(item.getNodeValue());\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "teammates.test.cases.browsertests.FeedbackConstSumRecipientQuestionUiTest.testDisableConstSumPointsAction",
	"Comment": "tests that the constsumpoints number fields gets disabled, if the corresponding radio button is not checked.",
	"Method": "void testDisableConstSumPointsAction(){\r\n    ______TS(\"Success case: CONSTSUM-recipient points to distribute field disables when radio button is unchecked\");\r\n    feedbackEditPage.clickNewQuestionButton();\r\n    feedbackEditPage.selectNewQuestionTypeAndWaitForNewQuestionPanelReady(\"CONSTSUM_RECIPIENT\");\r\n    assertTrue(browser.driver.findElement(By.id(\"constSumPointsTotal--1\")).isSelected());\r\n    feedbackEditPage.verifyUnclickable(browser.driver.findElement(By.id(\"constSumPointsForEachRecipient--1\")));\r\n    feedbackEditPage.selectConstSumPointsOptionsForNewQuestion(\"PerRecipient\");\r\n    feedbackEditPage.verifyUnclickable(browser.driver.findElement(By.id(\"constSumPoints--1\")));\r\n    feedbackEditPage.selectConstSumPointsOptionsForNewQuestion(\"Total\");\r\n    feedbackEditPage.verifyUnclickable(browser.driver.findElement(By.id(\"constSumPointsForEachRecipient--1\")));\r\n    feedbackEditPage.clickDiscardChangesLinkForNewQuestion();\r\n    feedbackEditPage.waitForConfirmationModalAndClickOk();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.view.ObligationsView.fillFromCurrentSpec",
	"Comment": "fills the obligation view with informationfrom the most recent launch of the prover on thecurrent spec if the most recent launch of the prover was on the currentspec. otherwise, does nothing.",
	"Method": "void fillFromCurrentSpec(){\r\n    ObligationStatus[] statuses = ProverHelper.getObligationStatuses();\r\n    if (statuses != null) {\r\n        for (int i = 0; i < statuses.length; i++) {\r\n            updateItem(statuses[i]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.getFeedbackSessionResultsForInstructorInSection",
	"Comment": "gets results of a feedback session to show to an instructor for a specific section.",
	"Method": "FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorInSection(String feedbackSessionName,String courseId,String userEmail,String section){\r\n    CourseRoster roster = new CourseRoster(studentsLogic.getStudentsForCourse(courseId), instructorsLogic.getInstructorsForCourse(courseId));\r\n    Map<String, String> params = new HashMap();\r\n    params.put(PARAM_IS_INCLUDE_RESPONSE_STATUS, \"true\");\r\n    params.put(PARAM_IN_SECTION, \"true\");\r\n    params.put(PARAM_FROM_SECTION, \"false\");\r\n    params.put(PARAM_TO_SECTION, \"false\");\r\n    params.put(PARAM_SECTION, section);\r\n    return getFeedbackSessionResultsForUserWithParams(feedbackSessionName, courseId, userEmail, UserRole.INSTRUCTOR, roster, params);\r\n}"
}, {
	"Path": "teammates.logic.api.Logic.moveAdminEmailOutOfTrashBin",
	"Comment": "move an admin email out of trash bin.after this the attribute isintrashbin will be set to false",
	"Method": "void moveAdminEmailOutOfTrashBin(String adminEmailId){\r\n    Assumption.assertNotNull(adminEmailId);\r\n    adminEmailsLogic.moveAdminEmailOutOfTrashBin(adminEmailId);\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.XmlRoundTripUtils.compareDocuments",
	"Comment": "this method will compare the original document with the proposed documentand return true if adjustments to the original document were necessary.adjustments are only made if new elements or attributes are proposed.changes to the order of attributes or elements in the original documentwill not result in an adjustment.",
	"Method": "boolean compareDocuments(Document original,Document proposed){\r\n    boolean originalDocumentAdjusted = checkNamespaces(original, proposed);\r\n    originalDocumentAdjusted |= addOrUpdateElements(original.getDocumentElement(), proposed.getDocumentElement(), originalDocumentAdjusted);\r\n    originalDocumentAdjusted |= removeElements(original.getDocumentElement(), proposed.getDocumentElement(), originalDocumentAdjusted);\r\n    return originalDocumentAdjusted;\r\n}"
}, {
	"Path": "it.michelelacorte.swipeablecard.OptionView.isSingleMarker",
	"Comment": "get boolean issinglemarker to know if single marker mode is used",
	"Method": "boolean isSingleMarker(){\r\n    return singleMarker;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.TLAFastPartitioner.getFirstIndexEndingAfterOffset",
	"Comment": "returns the index of the first position which ends after the given offset.",
	"Method": "int getFirstIndexEndingAfterOffset(Position[] positions,int offset){\r\n    int i = -1, j = positions.length;\r\n    while (j - i > 1) {\r\n        int k = (i + j) >> 1;\r\n        Position p = positions[k];\r\n        if (p.getOffset() + p.getLength() > offset)\r\n            j = k;\r\n        else\r\n            i = k;\r\n    }\r\n    return j;\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.convert.NumberConverter.toObject",
	"Comment": "converts the string to a number, using the given format for parsing.",
	"Method": "Object toObject(String pString,Class pType,String pFormat){\r\n    if (StringUtil.isEmpty(pString)) {\r\n        return null;\r\n    }\r\n    try {\r\n        if (pType.equals(BigInteger.class)) {\r\n            return new BigInteger(pString);\r\n        }\r\n        if (pType.equals(BigDecimal.class)) {\r\n            return new BigDecimal(pString);\r\n        }\r\n        NumberFormat format;\r\n        if (pFormat == null) {\r\n            format = sDefaultFormat;\r\n        } else {\r\n            format = getNumberFormat(pFormat);\r\n        }\r\n        Number num;\r\n        synchronized (format) {\r\n            num = format.parse(pString);\r\n        }\r\n        if (pType == Integer.TYPE || pType == Integer.class) {\r\n            return num.intValue();\r\n        } else if (pType == Long.TYPE || pType == Long.class) {\r\n            return num.longValue();\r\n        } else if (pType == Double.TYPE || pType == Double.class) {\r\n            return num.doubleValue();\r\n        } else if (pType == Float.TYPE || pType == Float.class) {\r\n            return num.floatValue();\r\n        } else if (pType == Byte.TYPE || pType == Byte.class) {\r\n            return num.byteValue();\r\n        } else if (pType == Short.TYPE || pType == Short.class) {\r\n            return num.shortValue();\r\n        }\r\n        return num;\r\n    } catch (ParseException pe) {\r\n        throw new ConversionException(pe);\r\n    } catch (RuntimeException rte) {\r\n        throw new ConversionException(rte);\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.output.TagBasedTLAPMOutputIncrementalParser.processFinished",
	"Comment": "called when no more text is to besent to this parser.this method compares the step statusescomputed by the toolbox to the step statuses reportedby the tlapm.",
	"Method": "void processFinished(){\r\n    ProverHelper.compareStepStatusComputations(proverJob);\r\n}"
}, {
	"Path": "tla2sany.semantic.Context.getModDefs",
	"Comment": "returns a vector of those symbolnodes in this context that areinstances of class modulenode",
	"Method": "Vector<SemanticNode> getModDefs(){\r\n    Class<? extends SemanticNode> template = ModuleNode.class;\r\n    Enumeration<Pair> list = table.elements();\r\n    Vector<SemanticNode> result = new Vector();\r\n    while (list.hasMoreElements()) {\r\n        Pair elt = list.nextElement();\r\n        if (template.isInstance(elt.info))\r\n            result.addElement((SemanticNode) (elt.info));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.roo.project.maven.Pom.isAllPluginsRegistered",
	"Comment": "indicates whether all of the given plugins are registered, based on theirgroupid, artifactid, and version.",
	"Method": "boolean isAllPluginsRegistered(Collection<? extends Plugin> plugins){\r\n    Validate.notNull(plugins, \"Plugins to check is required\");\r\n    for (final Plugin plugin : plugins) {\r\n        if (plugin != null && !isBuildPluginRegistered(plugin)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.containers.Data.getString",
	"Comment": "this will return a string of the data array with custom characters used as line breakers",
	"Method": "String getString(String getString,String separater){\r\n    return mLines == null ? null : TextUtils.join(separater, Arrays.asList(mLines));\r\n}"
}, {
	"Path": "teammates.ui.pagedata.StudentHomePageData.getStudentSubmissionsTooltipForSession",
	"Comment": "returns the hover message to explain feedback session submission status.",
	"Method": "String getStudentSubmissionsTooltipForSession(FeedbackSessionAttributes session,boolean hasSubmitted){\r\n    StringBuilder msg = new StringBuilder();\r\n    Boolean isAwaiting = session.isWaitingToOpen();\r\n    if (isAwaiting) {\r\n        msg.append(Const.Tooltips.STUDENT_FEEDBACK_SESSION_STATUS_AWAITING);\r\n    } else if (hasSubmitted) {\r\n        msg.append(Const.Tooltips.STUDENT_FEEDBACK_SESSION_STATUS_SUBMITTED);\r\n    } else {\r\n        msg.append(Const.Tooltips.STUDENT_FEEDBACK_SESSION_STATUS_PENDING);\r\n    }\r\n    if (session.isClosed()) {\r\n        msg.append(Const.Tooltips.STUDENT_FEEDBACK_SESSION_STATUS_CLOSED);\r\n    }\r\n    return msg.toString();\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.convert.TimeConverter.toObject",
	"Comment": "converts the string to a time, using the given format for parsing.",
	"Method": "Object toObject(String pString,Class pType,String pFormat){\r\n    if (StringUtil.isEmpty(pString))\r\n        return null;\r\n    TimeFormat format;\r\n    try {\r\n        if (pFormat == null) {\r\n            format = TimeFormat.getInstance();\r\n        } else {\r\n            format = getTimeFormat(pFormat);\r\n        }\r\n        return format.parse(pString);\r\n    } catch (RuntimeException rte) {\r\n        throw new ConversionException(rte);\r\n    }\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.restoreFeedbackSessionFromRecycleBin",
	"Comment": "restores a specific feedback session from recycle bin to feedback sessions table.",
	"Method": "void restoreFeedbackSessionFromRecycleBin(String feedbackSessionName,String courseId){\r\n    FeedbackSessionAttributes feedbackSession = fsDb.getSoftDeletedFeedbackSession(courseId, feedbackSessionName);\r\n    feedbackSession.resetDeletedTime();\r\n    fsDb.updateFeedbackSession(feedbackSession);\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorFeedbackResultsPageData.hasEntitiesInNoSpecificSection",
	"Comment": "checks if there are entities in no specific section.true if the course has teams in default sectiontrue if view is grq or gqr and there is feedback from instructorstrue if view is rgq or rqg and there is general feedback or feedback to instructorsfalse otherwise",
	"Method": "boolean hasEntitiesInNoSpecificSection(InstructorFeedbackResultsPageViewType viewType){\r\n    boolean hasFeedbackFromInstructor = bundle.hasResponseFromInstructor();\r\n    boolean hasFeedbackToInstructorOrGeneral = bundle.hasResponseToInstructorOrGeneral();\r\n    boolean viewTypeIsRecipient = viewType == InstructorFeedbackResultsPageViewType.RECIPIENT_QUESTION_GIVER || viewType == InstructorFeedbackResultsPageViewType.RECIPIENT_GIVER_QUESTION;\r\n    boolean viewTypeIsGiver = viewType == InstructorFeedbackResultsPageViewType.GIVER_QUESTION_RECIPIENT || viewType == InstructorFeedbackResultsPageViewType.GIVER_RECIPIENT_QUESTION;\r\n    boolean hasTeamsInNoSection = bundle.getTeamsInSectionFromRoster(Const.DEFAULT_SECTION).size() > 0;\r\n    return hasTeamsInNoSection || viewTypeIsGiver && hasFeedbackFromInstructor || viewTypeIsRecipient && hasFeedbackToInstructorOrGeneral;\r\n}"
}, {
	"Path": "org.springframework.roo.project.MavenOperationsImpl.addBannerFile",
	"Comment": "this method creates a banner.txt file inside generated project that willbe displayed when the generated spring boot application starts.",
	"Method": "void addBannerFile(Pom module){\r\n    LogicalPath resourcesPath = LogicalPath.getInstance(Path.SRC_MAIN_RESOURCES, module.getModuleName());\r\n    String sourceAntPath = \"banner/banner.txt\";\r\n    String targetDirectory = getPathResolver().getIdentifier(resourcesPath, \"\");\r\n    if (!getFileManager().exists(targetDirectory)) {\r\n        getFileManager().createDirectory(targetDirectory);\r\n    }\r\n    final String path = FileUtils.getPath(getClass(), sourceAntPath);\r\n    final Iterable<URL> urls = OSGiUtils.findEntriesByPattern(context, path);\r\n    Validate.notNull(urls, \"Could not search bundles for resources for Ant Path '%s'\", path);\r\n    for (final URL url : urls) {\r\n        final String fileName = url.getPath().substring(url.getPath().lastIndexOf(\"/\") + 1);\r\n        try {\r\n            String contents = IOUtils.toString(url);\r\n            getFileManager().createOrUpdateTextFileIfRequired(targetDirectory + fileName, contents, false);\r\n        } catch (final Exception e) {\r\n            throw new IllegalStateException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.test.driver.BackDoor.putDocuments",
	"Comment": "puts searchable documents for entities into the datastore.",
	"Method": "String putDocuments(DataBundle dataBundle){\r\n    String dataBundleJson = JsonUtils.toJson(dataBundle);\r\n    Map<String, String> params = createParamMap(BackDoorOperation.OPERATION_PUT_DOCUMENTS);\r\n    params.put(BackDoorOperation.PARAMETER_DATABUNDLE_JSON, dataBundleJson);\r\n    return makePostRequest(params);\r\n}"
}, {
	"Path": "teammates.ui.controller.Action.getRequestParamValues",
	"Comment": "returns null if the specified parameter was not found in the request.",
	"Method": "String[] getRequestParamValues(String paramName){\r\n    return HttpRequestHelper.getValuesFromParamMap(requestParameters, paramName);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.WsClientsMetadata.getEndPointField",
	"Comment": "this method provides the related field for the provided endpoint",
	"Method": "FieldMetadataBuilder getEndPointField(WsClientEndpoint endPoint){\r\n    if (endPointFields.get(endPoint.getName()) != null) {\r\n        return endPointFields.get(endPoint.getName());\r\n    }\r\n    JavaSymbolName fieldName = new JavaSymbolName(StringUtils.uncapitalize(endPoint.getName()).concat(\"Url\"));\r\n    FieldMetadataBuilder endPointField = new FieldMetadataBuilder(getId(), Modifier.PRIVATE, fieldName, JavaType.STRING, null);\r\n    AnnotationMetadataBuilder valueAnnotation = new AnnotationMetadataBuilder(SpringJavaType.VALUE);\r\n    valueAnnotation.addStringAttribute(\"value\", String.format(\"${url/%s}\", endPoint.getName()));\r\n    endPointField.addAnnotation(valueAnnotation);\r\n    endPointFields.put(endPoint.getName(), endPointField);\r\n    return endPointField;\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.DateUtil.roundToDay",
	"Comment": "rounds the given time down to the closest day, using the given timezone.",
	"Method": "long roundToDay(long pTime,long roundToDay,long pTime,TimeZone pTimeZone){\r\n    int offset = pTimeZone.getOffset(pTime);\r\n    return (((pTime + offset) / DAY) * DAY) - offset;\r\n}"
}, {
	"Path": "pcal.TLAtoPCalMapping.Dist",
	"Comment": "the distance between the two locations, where the distance from the end of one line to the beginning of the next is considered to be 9999 times as great as the distance between adjacent characters.",
	"Method": "int Dist(PCalLocation locA,PCalLocation locB){\r\n    return 9999 * Math.abs(locA.getLine() - locB.getLine()) + Math.abs(locA.getColumn() - locB.getColumn());\r\n}"
}, {
	"Path": "tla2sany.parser.SimpleCharStream.adjustBeginLineColumn",
	"Comment": "method to adjust line and column numbers for the start of a token.",
	"Method": "void adjustBeginLineColumn(int newLine,int newCol){\r\n    int start = tokenBegin;\r\n    int len;\r\n    if (bufpos >= tokenBegin) {\r\n        len = bufpos - tokenBegin + inBuf + 1;\r\n    } else {\r\n        len = bufsize - tokenBegin + bufpos + 1 + inBuf;\r\n    }\r\n    int i = 0, j = 0, k = 0;\r\n    int nextColDiff = 0, columnDiff = 0;\r\n    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {\r\n        bufline[j] = newLine;\r\n        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\r\n        bufcolumn[j] = newCol + columnDiff;\r\n        columnDiff = nextColDiff;\r\n        i++;\r\n    }\r\n    if (i < len) {\r\n        bufline[j] = newLine++;\r\n        bufcolumn[j] = newCol + columnDiff;\r\n        while (i++ < len) {\r\n            if (bufline[j = start % bufsize] != bufline[++start % bufsize])\r\n                bufline[j] = newLine++;\r\n            else\r\n                bufline[j] = newLine;\r\n        }\r\n    }\r\n    line = bufline[j];\r\n    column = bufcolumn[j];\r\n}"
}, {
	"Path": "com.twelvemonkeys.lang.StringUtil.rtrim",
	"Comment": "trims the argument string for whitespace on the right side only.",
	"Method": "String rtrim(String pString){\r\n    if ((pString == null) || (pString.length() == 0)) {\r\n        return pString;\r\n    }\r\n    for (int i = pString.length(); i > 0; i--) {\r\n        if (!Character.isWhitespace(pString.charAt(i - 1))) {\r\n            if (i == pString.length()) {\r\n                return pString;\r\n            } else {\r\n                return pString.substring(0, i);\r\n            }\r\n        }\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.itd.AbstractItdTypeDetailsProvidingMetadataItem.getMethod",
	"Comment": "returns a public method given the method name, return type, parametertypes, parameter names, and method body.",
	"Method": "MethodMetadataBuilder getMethod(int modifier,JavaSymbolName methodName,JavaType returnType,List<JavaType> parameterTypes,List<JavaSymbolName> parameterNames,InvocableMemberBodyBuilder bodyBuilder){\r\n    final MethodMetadata method = getGovernorMethod(methodName, parameterTypes);\r\n    if (method != null) {\r\n        return null;\r\n    }\r\n    addToImports(parameterTypes);\r\n    return new MethodMetadataBuilder(getId(), modifier, methodName, returnType, AnnotatedJavaType.convertFromJavaTypes(parameterTypes), parameterNames, bodyBuilder);\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.builtin.VoidThriftCodec.read",
	"Comment": "always returns null without reading anything from the stream.",
	"Method": "Void read(TProtocol protocol){\r\n    Preconditions.checkNotNull(protocol, \"protocol is null\");\r\n    return null;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackRankRecipientsQuestionDetails.generateSelfRankForEachRecipient",
	"Comment": "generates a key, value mapping. each key corresponds to a recipient and its value is the normalised self rank.",
	"Method": "Map<String, Integer> generateSelfRankForEachRecipient(List<FeedbackResponseAttributes> responses){\r\n    Map<FeedbackResponseAttributes, Integer> normalisedRankOfResponse = getNormalisedRankForEachResponse(responses);\r\n    Map<String, Integer> recipientToSelfRank = new HashMap();\r\n    for (FeedbackResponseAttributes response : responses) {\r\n        if (response.recipient.equalsIgnoreCase(response.giver)) {\r\n            recipientToSelfRank.put(response.recipient, normalisedRankOfResponse.get(response));\r\n        }\r\n    }\r\n    return recipientToSelfRank;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.UIHelper.getActiveEditorFileSelectionProvider",
	"Comment": "retrieves the selection provider for files in the active editor",
	"Method": "ISelectionProvider getActiveEditorFileSelectionProvider(){\r\n    return new GenericSelectionProvider() {\r\n        public ISelection getSelection() {\r\n            IEditorInput input = getActiveEditor().getEditorInput();\r\n            if (input instanceof FileEditorInput) {\r\n                IFile resource = ((FileEditorInput) input).getFile();\r\n                return new StructuredSelection(resource);\r\n            }\r\n            return null;\r\n        }\r\n        public void setSelection(ISelection selection) {\r\n            throw new UnsupportedOperationException(\"This selection provider is read-only\");\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.UIHelper.getActiveEditorFileSelectionProvider",
	"Comment": "retrieves the selection provider for files in the active editor",
	"Method": "ISelectionProvider getActiveEditorFileSelectionProvider(){\r\n    IEditorInput input = getActiveEditor().getEditorInput();\r\n    if (input instanceof FileEditorInput) {\r\n        IFile resource = ((FileEditorInput) input).getFile();\r\n        return new StructuredSelection(resource);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.UIHelper.getActiveEditorFileSelectionProvider",
	"Comment": "retrieves the selection provider for files in the active editor",
	"Method": "ISelectionProvider getActiveEditorFileSelectionProvider(){\r\n    throw new UnsupportedOperationException(\"This selection provider is read-only\");\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.utils.File.createDirectory",
	"Comment": "create a new directory based on the path from this file object.",
	"Method": "Boolean createDirectory(){\r\n    synchronized (mLock) {\r\n        Boolean status = false;\r\n        if (!exists()) {\r\n            if (!(status = mFile.mkdir())) {\r\n                Result result = mShell.createAttempts(\"mkdir '\" + getAbsolutePath() + \"' 2> /dev/null\").execute();\r\n                if (result == null || !(status = result.wasSuccessful())) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (status) {\r\n                Bundle bundle = new Bundle();\r\n                bundle.putString(\"action\", \"exists\");\r\n                bundle.putString(\"location\", getAbsolutePath());\r\n                Shell.sendBroadcast(\"file\", bundle);\r\n            }\r\n        } else {\r\n            status = isDirectory();\r\n        }\r\n        return status;\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.getPossibleRecipientsForTeam",
	"Comment": "get the possible recipients for a team giver for the question specified.",
	"Method": "List<String> getPossibleRecipientsForTeam(FeedbackQuestionAttributes fqa,String givingTeam){\r\n    FeedbackParticipantType recipientType = fqa.recipientType;\r\n    List<String> possibleRecipients = new ArrayList();\r\n    switch(recipientType) {\r\n        case TEAMS:\r\n            possibleRecipients = getSortedListOfTeams();\r\n            possibleRecipients.remove(givingTeam);\r\n            break;\r\n        case SELF:\r\n        case OWN_TEAM:\r\n            possibleRecipients.add(givingTeam);\r\n            break;\r\n        case INSTRUCTORS:\r\n            possibleRecipients = getSortedListOfInstructorEmails();\r\n            break;\r\n        case STUDENTS:\r\n            possibleRecipients = getSortedListOfStudentEmails();\r\n            break;\r\n        case OWN_TEAM_MEMBERS_INCLUDING_SELF:\r\n            if (rosterTeamNameMembersTable.containsKey(givingTeam)) {\r\n                Set<String> studentEmailsToNames = rosterTeamNameMembersTable.get(givingTeam);\r\n                possibleRecipients = new ArrayList(studentEmailsToNames);\r\n                possibleRecipients.sort(null);\r\n            }\r\n            break;\r\n        case NONE:\r\n            possibleRecipients.add(Const.GENERAL_QUESTION);\r\n            break;\r\n        default:\r\n            log.severe(\"Invalid recipient type specified\");\r\n            break;\r\n    }\r\n    return possibleRecipients;\r\n}"
}, {
	"Path": "tlc2.tool.fp.DiskFPSet.checkValid",
	"Comment": "checks if the given fingerprint has a value that can be correctly stored\tby this fpset",
	"Method": "long checkValid(long fp){\r\n    if (fp == 0L) {\r\n    }\r\n    return fp;\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackResponsesLogic.copyFixedValuesFromOldToNew",
	"Comment": "copies values that cannot be changed to defensively avoid invalid parameters.",
	"Method": "void copyFixedValuesFromOldToNew(FeedbackResponseAttributes newResponse,FeedbackResponseAttributes oldResponse){\r\n    newResponse.courseId = oldResponse.courseId;\r\n    newResponse.feedbackSessionName = oldResponse.feedbackSessionName;\r\n    newResponse.feedbackQuestionId = oldResponse.feedbackQuestionId;\r\n    newResponse.feedbackQuestionType = oldResponse.feedbackQuestionType;\r\n    if (newResponse.responseMetaData == null) {\r\n        newResponse.responseMetaData = oldResponse.responseMetaData;\r\n    }\r\n    if (newResponse.giver == null) {\r\n        newResponse.giver = oldResponse.giver;\r\n    }\r\n    if (newResponse.recipient == null) {\r\n        newResponse.recipient = oldResponse.recipient;\r\n    }\r\n    if (newResponse.giverSection == null) {\r\n        newResponse.giverSection = oldResponse.giverSection;\r\n    }\r\n    if (newResponse.recipientSection == null) {\r\n        newResponse.recipientSection = oldResponse.recipientSection;\r\n    }\r\n}"
}, {
	"Path": "pcal.TLAtoPCalMapping.ObjectAt",
	"Comment": "returns the mappingobject at the location in map indicated by loc.",
	"Method": "MappingObject ObjectAt(PCalLocation loc,MappingObject[][] map){\r\n    return map[loc.getLine()][loc.getColumn()];\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.waitForElementToDisappear",
	"Comment": "waits for element to be invisible or not present, or timeout.",
	"Method": "void waitForElementToDisappear(By by){\r\n    waitFor(ExpectedConditions.invisibilityOfElementLocated(by));\r\n}"
}, {
	"Path": "tlc2.tool.liveness.LNConj.toDNF",
	"Comment": "the method todnf turns a liveexprnode into disjunctive normal form.",
	"Method": "LiveExprNode toDNF(){\r\n    int count = getCount();\r\n    LiveExprNode[] temp = new LiveExprNode[count];\r\n    for (int i = 0; i < count; i++) {\r\n        temp[i] = getBody(i).toDNF();\r\n    }\r\n    Vect nes = new Vect(count);\r\n    int total = 1;\r\n    for (int i = 0; i < count; i++) {\r\n        LiveExprNode elem = temp[i];\r\n        if (elem instanceof LNDisj) {\r\n            nes.addElement(elem);\r\n            total *= ((LNDisj) elem).getCount();\r\n        } else if (elem instanceof LNConj) {\r\n            LNConj elem1 = (LNConj) elem;\r\n            int count1 = elem1.getCount();\r\n            for (int j = 0; j < count1; j++) {\r\n                nes.addElement(elem1.getBody(j));\r\n            }\r\n        } else {\r\n            nes.addElement(elem);\r\n        }\r\n    }\r\n    if (total == 1) {\r\n        return new LNConj(nes);\r\n    }\r\n    int nesSize = nes.size();\r\n    Vect res = new Vect(total);\r\n    for (int i = 0; i < total; i++) {\r\n        res.addElement(new LNConj(nesSize));\r\n    }\r\n    int num = 1;\r\n    int rCount = total;\r\n    for (int i = 0; i < nesSize; i++) {\r\n        LiveExprNode ln = (LiveExprNode) nes.elementAt(i);\r\n        if (ln instanceof LNDisj) {\r\n            LNDisj disj = (LNDisj) ln;\r\n            rCount = rCount / disj.getCount();\r\n            int idx = 0;\r\n            for (int j = 0; j < num; j++) {\r\n                for (int k = 0; k < disj.getCount(); k++) {\r\n                    LiveExprNode elem = disj.getBody(k);\r\n                    for (int l = 0; l < rCount; l++) {\r\n                        ((LNConj) res.elementAt(idx++)).addConj(elem);\r\n                    }\r\n                }\r\n            }\r\n            num = num * disj.getCount();\r\n        } else {\r\n            for (int j = 0; j < total; j++) {\r\n                ((LNConj) res.elementAt(j)).addConj(ln);\r\n            }\r\n        }\r\n    }\r\n    return new LNDisj(res);\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.MemberFindingUtils.getFirstAnnotation",
	"Comment": "returns the first of the given types of annotation on the given class orinterface",
	"Method": "AnnotationMetadata getFirstAnnotation(ClassOrInterfaceTypeDetails cid,JavaType annotationTypes){\r\n    if (cid != null && annotationTypes != null) {\r\n        for (final JavaType annotationType : annotationTypes) {\r\n            final AnnotationMetadata annotation = MemberFindingUtils.getAnnotationOfType(cid.getAnnotations(), annotationType);\r\n            if (annotation != null) {\r\n                return annotation;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.getFeedbackSessionResultsForUserInSectionByQuestions",
	"Comment": "get the feedback results for user in a section iterated by questions",
	"Method": "FeedbackSessionResultsBundle getFeedbackSessionResultsForUserInSectionByQuestions(String feedbackSessionName,String courseId,String userEmail,UserRole role,String section,FeedbackSessionResultsBundle getFeedbackSessionResultsForUserInSectionByQuestions,String feedbackSessionName,String courseId,String userEmail,UserRole role,String section,CourseRoster roster){\r\n    FeedbackSessionAttributes session = fsDb.getFeedbackSession(courseId, feedbackSessionName);\r\n    if (session == null) {\r\n        throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_VIEW + courseId + \"/\" + feedbackSessionName);\r\n    }\r\n    List<FeedbackResponseAttributes> responses = new ArrayList();\r\n    Map<String, FeedbackQuestionAttributes> relevantQuestions = new HashMap();\r\n    Map<String, String> emailNameTable = new HashMap();\r\n    Map<String, String> emailLastNameTable = new HashMap();\r\n    Map<String, String> emailTeamNameTable = new HashMap();\r\n    Map<String, Set<String>> sectionTeamNameTable = new HashMap();\r\n    Map<String, boolean[]> visibilityTable = new HashMap();\r\n    Map<String, List<FeedbackResponseCommentAttributes>> responseComments = new HashMap();\r\n    FeedbackSessionResponseStatus responseStatus = new FeedbackSessionResponseStatus();\r\n    List<FeedbackQuestionAttributes> allQuestions = fqLogic.getFeedbackQuestionsForSession(feedbackSessionName, courseId);\r\n    Map<String, FeedbackResponseAttributes> relevantResponse = new HashMap();\r\n    for (FeedbackQuestionAttributes question : allQuestions) {\r\n        List<FeedbackResponseAttributes> responsesForThisQn;\r\n        responsesForThisQn = frLogic.getViewableFeedbackResponsesForQuestionInSection(question, userEmail, role, section);\r\n        boolean hasResponses = !responsesForThisQn.isEmpty();\r\n        if (hasResponses) {\r\n            relevantQuestions.put(question.getId(), question);\r\n            responses.addAll(responsesForThisQn);\r\n            for (FeedbackResponseAttributes response : responsesForThisQn) {\r\n                relevantResponse.put(response.getId(), response);\r\n                addEmailNamePairsToTable(emailNameTable, response, question, roster);\r\n                addEmailLastNamePairsToTable(emailLastNameTable, response, question, roster);\r\n                addEmailTeamNamePairsToTable(emailTeamNameTable, response, question, roster);\r\n                addVisibilityToTable(visibilityTable, question, response, userEmail, role, roster);\r\n            }\r\n        }\r\n    }\r\n    StudentAttributes student = null;\r\n    Set<String> studentsEmailInTeam = new HashSet();\r\n    if (isStudent(role)) {\r\n        student = studentsLogic.getStudentForEmail(courseId, userEmail);\r\n        List<StudentAttributes> studentsInTeam = studentsLogic.getStudentsForTeam(student.team, courseId);\r\n        for (StudentAttributes teammates : studentsInTeam) {\r\n            studentsEmailInTeam.add(teammates.email);\r\n        }\r\n    }\r\n    List<FeedbackResponseCommentAttributes> allResponseComments = frcLogic.getFeedbackResponseCommentForSession(courseId, feedbackSessionName);\r\n    for (FeedbackResponseCommentAttributes frc : allResponseComments) {\r\n        FeedbackResponseAttributes relatedResponse = relevantResponse.get(frc.feedbackResponseId);\r\n        FeedbackQuestionAttributes relatedQuestion = relevantQuestions.get(frc.feedbackQuestionId);\r\n        boolean isVisibleResponseComment = frcLogic.isResponseCommentVisibleForUser(userEmail, role, student, studentsEmailInTeam, relatedResponse, relatedQuestion, frc);\r\n        if (isVisibleResponseComment) {\r\n            if (!frcLogic.isNameVisibleToUser(frc, relatedResponse, userEmail, roster)) {\r\n                frc.commentGiver = Const.DISPLAYED_NAME_FOR_ANONYMOUS_PARTICIPANT;\r\n            }\r\n            if (responseComments.get(frc.feedbackResponseId) == null) {\r\n                responseComments.put(frc.feedbackResponseId, new ArrayList<FeedbackResponseCommentAttributes>());\r\n            }\r\n            responseComments.get(frc.feedbackResponseId).add(frc);\r\n        }\r\n    }\r\n    for (List<FeedbackResponseCommentAttributes> responseCommentList : responseComments.values()) {\r\n        sortByCreatedDate(responseCommentList);\r\n    }\r\n    addSectionTeamNamesToTable(sectionTeamNameTable, roster, courseId, userEmail, role, feedbackSessionName, section);\r\n    return new FeedbackSessionResultsBundle(session, responses, relevantQuestions, emailNameTable, emailLastNameTable, emailTeamNameTable, sectionTeamNameTable, visibilityTable, responseStatus, roster, responseComments);\r\n}"
}, {
	"Path": "teammates.common.util.StringHelper.isAnyMatching",
	"Comment": "checks whether any substring of the input string matches any of the group of given regex expressions.",
	"Method": "boolean isAnyMatching(String input,List<String> regexList){\r\n    return regexList.stream().anyMatch(r -> isMatching(input.trim().toLowerCase(), r));\r\n}"
}, {
	"Path": "org.springframework.roo.metadata.internal.StandardMetadataTimingStatisticTest.getTestInstance",
	"Comment": "creates an instance with fixed test values and the given duration",
	"Method": "StandardMetadataTimingStatistic getTestInstance(long nanoseconds){\r\n    return new StandardMetadataTimingStatistic(NAME, nanoseconds, INVOCATIONS);\r\n}"
}, {
	"Path": "teammates.storage.api.StudentsDb.putDocuments",
	"Comment": "batch creates or updates search documents for the given students.",
	"Method": "void putDocuments(List<StudentAttributes> students){\r\n    List<SearchDocument> studentDocuments = new ArrayList();\r\n    for (StudentAttributes student : students) {\r\n        studentDocuments.add(new StudentSearchDocument(student));\r\n    }\r\n    putDocuments(Const.SearchIndex.STUDENT, studentDocuments);\r\n}"
}, {
	"Path": "teammates.ui.controller.Action.putStatusMessageToSession",
	"Comment": "adds the list of status messages from actionresult into session variables.",
	"Method": "void putStatusMessageToSession(ActionResult response){\r\n    @SuppressWarnings(\"unchecked\")\r\n    List<StatusMessage> statusMessagesToUser = (List<StatusMessage>) session.getAttribute(Const.ParamsNames.STATUS_MESSAGES_LIST);\r\n    if (statusMessagesToUser == null) {\r\n        statusMessagesToUser = new ArrayList();\r\n    }\r\n    statusMessagesToUser.addAll(response.statusToUser);\r\n    session.setAttribute(Const.ParamsNames.STATUS_MESSAGES_LIST, statusMessagesToUser);\r\n}"
}, {
	"Path": "teammates.logic.backdoor.BackDoorLogic.injectRealIdsIntoResponseComments",
	"Comment": "this method is necessary to generate the feedbackquestionid and feedbackresponseid of the question and response the comment is for. normally, the id is already generated on creation, but the json file does not contain the actual response id.therefore the question number and questionnumber%giveremail%recipient corresponding to the created comment should be inserted in the json file in place of the actual id. this method will then generate the correct id and replace the field.",
	"Method": "void injectRealIdsIntoResponseComments(Collection<FeedbackResponseCommentAttributes> responseComments,Map<String, String> questionIdMap){\r\n    for (FeedbackResponseCommentAttributes comment : responseComments) {\r\n        int questionNumber;\r\n        try {\r\n            questionNumber = Integer.parseInt(comment.feedbackQuestionId);\r\n        } catch (NumberFormatException e) {\r\n            continue;\r\n        }\r\n        String sessionKey = makeSessionKey(comment.feedbackSessionName, comment.courseId);\r\n        String questionKey = makeQuestionKey(sessionKey, questionNumber);\r\n        comment.feedbackQuestionId = questionIdMap.get(questionKey);\r\n        String[] responseIdParam = comment.feedbackResponseId.split(\"%\", 3);\r\n        comment.feedbackResponseId = comment.feedbackQuestionId + \"%\" + responseIdParam[1] + \"%\" + responseIdParam[2];\r\n    }\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.getFeedbackSessionResultsForInstructorWithinRangeFromView",
	"Comment": "gets results of a feedback session to show to an instructor in an indicated range.",
	"Method": "FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorWithinRangeFromView(String feedbackSessionName,String courseId,String userEmail,int range,String viewType){\r\n    return getFeedbackSessionResultsForInstructorInSectionWithinRangeFromView(feedbackSessionName, courseId, userEmail, null, range, viewType);\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.plugins.jpeg.FastCMYKToRGB.filter",
	"Comment": "converts the cmyk source raster to the destination rgb raster.",
	"Method": "WritableRaster filter(Raster src,WritableRaster dest){\r\n    Validate.notNull(src, \"src may not be null\");\r\n    Validate.isTrue(src != dest, \"src and dest raster may not be same\");\r\n    Validate.isTrue(src.getTransferType() == DataBuffer.TYPE_BYTE, src, \"only TYPE_BYTE rasters supported as src: %s\");\r\n    Validate.isTrue(src.getNumDataElements() >= 4, src.getNumDataElements(), \"CMYK raster must have at least 4 data elements: %s\");\r\n    if (dest == null) {\r\n        dest = createCompatibleDestRaster(src);\r\n    } else {\r\n        Validate.isTrue(dest.getTransferType() == DataBuffer.TYPE_BYTE && dest.getNumDataElements() >= 3 || dest.getTransferType() == DataBuffer.TYPE_INT && dest.getNumDataElements() == 1, src, \"only 3 or 4 byte TYPE_BYTE or 1 int TYPE_INT rasters supported as dest: %s\");\r\n    }\r\n    final int height = src.getHeight();\r\n    final int width = src.getWidth();\r\n    final byte[] in = new byte[src.getNumDataElements()];\r\n    if (dest.getTransferType() == DataBuffer.TYPE_BYTE) {\r\n        final byte[] out = new byte[dest.getNumDataElements()];\r\n        if (out.length > 3) {\r\n            out[3] = (byte) 0xFF;\r\n        }\r\n        for (int y = dest.getMinY(); y < height; y++) {\r\n            for (int x = dest.getMinX(); x < width; x++) {\r\n                src.getDataElements(x, y, in);\r\n                convertCMYKToRGB(in, out);\r\n                dest.setDataElements(x, y, out);\r\n            }\r\n        }\r\n    } else if (dest.getTransferType() == DataBuffer.TYPE_INT) {\r\n        final int[] out = new int[dest.getNumDataElements()];\r\n        final byte[] temp = new byte[3];\r\n        int[] bitOffsets;\r\n        SampleModel sm = dest.getSampleModel();\r\n        if (sm instanceof SinglePixelPackedSampleModel) {\r\n            bitOffsets = ((SinglePixelPackedSampleModel) sm).getBitOffsets();\r\n        } else {\r\n            bitOffsets = new int[] { 0, 8, 16 };\r\n        }\r\n        final int alpha = bitOffsets.length > 3 ? 0xFF : 0x00;\r\n        for (int y = dest.getMinY(); y < height; y++) {\r\n            for (int x = dest.getMinX(); x < width; x++) {\r\n                src.getDataElements(x, y, in);\r\n                convertCMYKToRGB(in, temp);\r\n                out[0] = alpha << 24 | (temp[0] & 0xFF) << bitOffsets[0] | (temp[1] & 0xFF) << bitOffsets[1] | (temp[2] & 0xFF) << bitOffsets[2];\r\n                dest.setDataElements(x, y, out);\r\n            }\r\n        }\r\n    } else {\r\n        throw new AssertionError();\r\n    }\r\n    return dest;\r\n}"
}, {
	"Path": "pcal.PcalFixIDs.FixEither",
	"Comment": "handling of either and labeleither added by ll on 24 jan 2006.",
	"Method": "void FixEither(AST.Either ast,String context){\r\n    for (int i = 0; i < ast.ors.size(); i++) {\r\n        Vector orClause = (Vector) ast.ors.elementAt(i);\r\n        for (int j = 0; j < orClause.size(); j++) FixSym((AST) orClause.elementAt(j), context);\r\n    }\r\n    ;\r\n}"
}, {
	"Path": "pcal.PCalTLAGenerator.translate",
	"Comment": "the main translation method.should go in a new .java file.note that this requires removenameconflicts to be called firstbecause of the grotty use of the class variable st.",
	"Method": "Vector<String> translate(){\r\n    Vector<String> result = new Vector<String>();\r\n    AST xast = null;\r\n    for (int i = 0; i < st.disambiguateReport.size(); i++) result.addElement((String) st.disambiguateReport.elementAt(i));\r\n    try {\r\n        xast = PcalTranslate.Explode(ast, st);\r\n    } catch (PcalTranslateException e) {\r\n        throw new RemoveNameConflictsException(e);\r\n    }\r\n    try {\r\n        PcalTLAGen tlaGenerator = new PcalTLAGen();\r\n        result = tlaGenerator.generate(xast, st, result);\r\n    } catch (PcalTLAGenException e) {\r\n        throw new RemoveNameConflictsException(e);\r\n    }\r\n    try {\r\n        if (ParseAlgorithm.hasDefaultInitialization) {\r\n            st.CheckForDefaultInitValue();\r\n        }\r\n    } catch (PcalSymTabException e) {\r\n        throw new RemoveNameConflictsException(e.getMessage());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.roo.obr.addon.search.ObrRepositoryOperationsImpl.populateRooAddonSuites",
	"Comment": "method to populate current roo addon suites using osgi serive",
	"Method": "void populateRooAddonSuites(){\r\n    installedSubsystems.clear();\r\n    try {\r\n        ServiceReference<?>[] references = context.getAllServiceReferences(Subsystem.class.getName(), null);\r\n        for (ServiceReference<?> ref : references) {\r\n            Subsystem subsystem = (Subsystem) context.getService(ref);\r\n            installedSubsystems.add(subsystem);\r\n        }\r\n    } catch (InvalidSyntaxException e) {\r\n        LOGGER.warning(\"Cannot load Subsystem on AddonSymbolicName.\");\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.preferences.AutomaticUpdatesPreferencePage.performOk",
	"Comment": "method declared on ipreferencepage. subclasses should override",
	"Method": "boolean performOk(){\r\n    IPreferenceStore pref = AutomaticUpdatePlugin.getDefault().getPreferenceStore();\r\n    pref.setValue(PreferenceConstants.PREF_AUTO_UPDATE_ENABLED, enabledCheck.getSelection());\r\n    artifactRepositoryManager.setEnabled(uri, enabledBeta.getSelection());\r\n    metadataRepositoryManager.setEnabled(uri, enabledBeta.getSelection());\r\n    if (onStartupRadio.getSelection()) {\r\n        pref.setValue(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_STARTUP);\r\n    } else if (onFuzzyScheduleRadio.getSelection()) {\r\n        pref.setValue(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_FUZZY_SCHEDULE);\r\n        new LastAutoCheckForUpdateMemo(AutomaticUpdatePlugin.getDefault().getAgentLocation()).readAndStoreIfAbsent(Calendar.getInstance().getTime());\r\n    } else {\r\n        pref.setValue(PreferenceConstants.PREF_AUTO_UPDATE_SCHEDULE, PreferenceConstants.PREF_UPDATE_ON_SCHEDULE);\r\n    }\r\n    if (remindScheduleRadio.getSelection()) {\r\n        pref.setValue(PreferenceConstants.PREF_REMIND_SCHEDULE, true);\r\n        pref.setValue(PreferenceConstants.PREF_REMIND_ELAPSED, AutomaticUpdatesPopup.ELAPSED_VALUES[remindElapseCombo.getSelectionIndex()]);\r\n    } else {\r\n        pref.setValue(PreferenceConstants.PREF_REMIND_SCHEDULE, false);\r\n    }\r\n    pref.setValue(AutomaticUpdateScheduler.P_FUZZY_RECURRENCE, fuzzyRecurrenceCombo.getText());\r\n    pref.setValue(PreferenceConstants.PREF_DOWNLOAD_ONLY, searchAndDownloadRadio.getSelection());\r\n    pref.setValue(PreferenceConstants.PREF_SHOW_UPDATE_WIZARD, showUpdateWizard.getSelection());\r\n    AutomaticUpdatePlugin.getDefault().savePreferences();\r\n    AutomaticUpdatePlugin.getDefault().getScheduler().rescheduleUpdate();\r\n    return true;\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.RootFW.unlock",
	"Comment": "removes one lock from this connection. each call will remove 1 lock as long as there are 1 or more locks attached.",
	"Method": "void unlock(){\r\n    synchronized (mLock) {\r\n        if (mLockCount > 0) {\r\n            mLockCount -= 1;\r\n        } else {\r\n            mLockCount = 0;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackRankOptionsResponseDetails.getFilteredSortedAnswerList",
	"Comment": "returns list of sorted answers, with uninitialised values filtered out.",
	"Method": "List<Integer> getFilteredSortedAnswerList(){\r\n    List<Integer> filteredAnswers = new ArrayList();\r\n    for (int answer : answers) {\r\n        if (answer != Const.POINTS_NOT_SUBMITTED) {\r\n            filteredAnswers.add(answer);\r\n        }\r\n    }\r\n    filteredAnswers.sort(null);\r\n    return filteredAnswers;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.output.source.TagBasedTLCOutputIncrementalParser.addIncrement",
	"Comment": "add the incrementthe argument should be a relatively short string, i.e. no morethan what tlc prints out in a single instant.it is also better if when at least one tlc end tag is partof the string passed to this method, the string terminates witha tlc end tag.",
	"Method": "void addIncrement(String text){\r\n    if (text == null || text.length() == 0 || text.equals(\"\\n\")) {\r\n        return;\r\n    } else if (text.charAt(text.length() - 1) != 10) {\r\n        throw new BadLocationException(\"Input does not end with newline\");\r\n    }\r\n    document.replace(document.getLength(), 0, text);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.setWidth",
	"Comment": "sets the width of the button. distance should be the value in dp, it will beconverted to the appropriate pixel value",
	"Method": "void setWidth(int width){\r\n    this.width = width;\r\n}"
}, {
	"Path": "teammates.ui.template.CourseEditSectionRow.isSectionSpecial",
	"Comment": "checks if the section this row corresponds to is special.a section is considered special if the instructor has special privilegesie. privileges that are not defined at course level.",
	"Method": "boolean isSectionSpecial(){\r\n    return instructor != null && instructor.privileges.isSectionSpecial(sectionName);\r\n}"
}, {
	"Path": "tlc2.tool.liveness.TableauNodePtrTable.isDone",
	"Comment": "this method returns true iff we have already done the nodes with key k.\tif we have done with k and a new node is being added, we must get this\tnew node done.",
	"Method": "boolean isDone(long k){\r\n    int[] node = this.getNodes(k);\r\n    if (node == null) {\r\n        return false;\r\n    }\r\n    if (node.length == 2) {\r\n        return true;\r\n    }\r\n    return node[3] != -2;\r\n}"
}, {
	"Path": "tlc2.tool.TLCStateMut.fingerPrint",
	"Comment": "this method returns the fingerprint of this state. we fingerprintthe values in the state according to the order given by vars.this guarantees the same state has the same fingerprint.since the values in this state can be shared by multiple threadsvia the state queue. they have to be normalized before adding tothe state queue.we do that here.",
	"Method": "long fingerPrint(){\r\n    int sz = this.values.length;\r\n    Value[] minVals = this.values;\r\n    if (perms != null) {\r\n        Value[] vals = new Value[sz];\r\n        NEXT_PERM: for (int i = 0; i < perms.length; i++) {\r\n            int cmp = 0;\r\n            for (int j = 0; j < sz; j++) {\r\n                vals[j] = this.values[j].permute(perms[i]);\r\n                if (cmp == 0) {\r\n                    cmp = vals[j].compareTo(minVals[j]);\r\n                    if (cmp > 0) {\r\n                        continue NEXT_PERM;\r\n                    }\r\n                }\r\n            }\r\n            if (cmp < 0) {\r\n                if (minVals == this.values) {\r\n                    minVals = vals;\r\n                    vals = new Value[sz];\r\n                } else {\r\n                    Value[] temp = minVals;\r\n                    minVals = vals;\r\n                    vals = temp;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    long fp = FP64.New();\r\n    if (viewMap == null) {\r\n        for (int i = 0; i < sz; i++) {\r\n            fp = minVals[i].fingerPrint(fp);\r\n        }\r\n        if (this.values != minVals) {\r\n            for (int i = 0; i < sz; i++) {\r\n                this.values[i].deepNormalize();\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = 0; i < sz; i++) {\r\n            this.values[i].deepNormalize();\r\n        }\r\n        TLCStateMut state = this;\r\n        if (minVals != this.values) {\r\n            state = new TLCStateMut(minVals);\r\n        }\r\n        Value val = mytool.eval(viewMap, Context.Empty, state);\r\n        fp = val.fingerPrint(fp);\r\n    }\r\n    return fp;\r\n}"
}, {
	"Path": "com.spazedog.lib.rootfw4.utils.Memory.setSwappiness",
	"Comment": "change the swappiness level.\tthe level should be between 0 for low swap usage and 100 for high swap usage.",
	"Method": "Boolean setSwappiness(Integer level){\r\n    Result result = null;\r\n    if (level >= 0 && level <= 100 && hasSwapSupport()) {\r\n        result = mShell.execute(\"echo '\" + level + \"' > /proc/sys/vm/swappiness\");\r\n    }\r\n    return result != null && result.wasSuccessful();\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.buildStruct",
	"Comment": "defines the code to build the struct instance using the data in the local variables.",
	"Method": "LocalVariableDefinition buildStruct(MethodDefinition read,Map<Short, LocalVariableDefinition> structData){\r\n    LocalVariableDefinition instance = constructStructInstance(read, structData);\r\n    injectStructFields(read, instance, structData);\r\n    injectStructMethods(read, instance, structData);\r\n    invokeFactoryMethod(read, structData, instance);\r\n    return instance;\r\n}"
}, {
	"Path": "teammates.common.util.ActivityLogEntry.isTestingData",
	"Comment": "checks whether the activity log is related to testing data or not.",
	"Method": "boolean isTestingData(){\r\n    return userEmail.endsWith(Const.ActivityLog.TESTING_DATA_EMAIL_POSTFIX);\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackEditPage.verifyEditSessionBoxIsEnabled",
	"Comment": "returns true if all elements expected to be enabled in the edit session frame are enabledafter edit link is clicked.",
	"Method": "boolean verifyEditSessionBoxIsEnabled(){\r\n    boolean isEditSessionEnabled = fsSaveLink.isDisplayed() && timezoneDropDown.isEnabled() && defaultSessionVisibleTimeButton.isEnabled() && customSessionVisibleTimeButton.isEnabled() && closingSessionEmailReminderButton.isEnabled() && publishedSessionEmailReminderButton.isEnabled();\r\n    if (isEditSessionEnabled) {\r\n        isEditSessionEnabled = gracePeriodDropdown.isEnabled() && startDateBox.isEnabled() && startTimeDropdown.isEnabled() && endDateBox.isEnabled() && endTimeDropdown.isEnabled() && defaultResultsVisibleTimeButton.isEnabled() && customResultsVisibleTimeButton.isEnabled() && manualResultsVisibleTimeButton.isEnabled();\r\n    }\r\n    return isEditSessionEnabled;\r\n}"
}, {
	"Path": "pcal.PcalTLAGen.stringToTLATokens",
	"Comment": "returns the vector of mappingobjects containing the begintlatoken andendtlatoken that are put in the mappingvector by a call of addonelineoftla.the code was essentially copied from addonetokentotla.",
	"Method": "Vector stringToTLATokens(String token){\r\n    Vector result = new Vector(3);\r\n    String trimmedToken = token.trim();\r\n    int numberOfLeftTrimmedTokens = (trimmedToken.length() == 0) ? -1 : token.indexOf(trimmedToken.charAt(0));\r\n    if (numberOfLeftTrimmedTokens == -1) {\r\n        numberOfLeftTrimmedTokens = 0;\r\n        trimmedToken = token;\r\n    }\r\n    int objBegin = numberOfLeftTrimmedTokens;\r\n    result.addElement(new MappingObject.BeginTLAToken(objBegin));\r\n    result.addElement(new MappingObject.EndTLAToken(objBegin + trimmedToken.length()));\r\n    return result;\r\n}"
}, {
	"Path": "teammates.ui.pagedata.InstructorFeedbackResultsPageData.buildQuestionTableWithoutResponseRows",
	"Comment": "builds question tables without response rows, but with stats.",
	"Method": "InstructorFeedbackResultsQuestionTable buildQuestionTableWithoutResponseRows(FeedbackQuestionAttributes question,List<FeedbackResponseAttributes> responses,String additionalInfoId){\r\n    return buildQuestionTableAndResponseRows(question, responses, additionalInfoId, null, false);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.AnimatedGifEncoder.start",
	"Comment": "initiates gif file creation on the given stream. the stream is not closedautomatically.",
	"Method": "boolean start(OutputStream os){\r\n    if (os == null)\r\n        return false;\r\n    boolean ok = true;\r\n    closeStream = false;\r\n    out = os;\r\n    try {\r\n        writeString(\"GIF89a\");\r\n    } catch (IOException e) {\r\n        ok = false;\r\n    }\r\n    return started = ok;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.HideSubtreeHandler.setEnabled",
	"Comment": "this method is used to update the enablement state. this has theeffect of graying out any menu items for thecommand if the handler is disabled. through experimentation, this method seems to becalled just before such menu items are rendered in the ui andjust before the handler is executed.",
	"Method": "void setEnabled(Object context){\r\n    TLAEditor editor = EditorUtil.getTLAEditorWithFocus();\r\n    if (editor != null) {\r\n        if (editor.getProofStructureProvider() != null) {\r\n            setBaseEnabled(editor.getProofStructureProvider().canRunFoldOperation(IProofFoldCommandIds.COLLAPSE_SUBTREE, (ITextSelection) editor.getSelectionProvider().getSelection()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.shell.SimpleParser.isVisibleParam",
	"Comment": "method that checks if given method attribute is visible in the shell.takes in count the dependencies with other parameters in same command.",
	"Method": "boolean isVisibleParam(String command,CliOption cliOption,ShellContextImpl shellContext){\r\n    String[] option = cliOption.key();\r\n    try {\r\n        MethodTarget optionVisibilityIndicator = optionVisibilityIndicators.get(command.concat(\"|\").concat(option[0]));\r\n        if (optionVisibilityIndicator == null) {\r\n            return true;\r\n        } else {\r\n            return (Boolean) optionVisibilityIndicator.getMethod().invoke(optionVisibilityIndicator.getTarget(), shellContext);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(String.format(\"ERROR: Error trying to get option visibility value for '%s' option on '%s' command. Please, fix errors on indicator method.\", option[0], command));\r\n    }\r\n}"
}, {
	"Path": "com.facebook.swift.generator.swift2thrift.Swift2ThriftGenerator.verifyTypes",
	"Comment": "and does a topological sort of thrifttypes in dependency order",
	"Method": "boolean verifyTypes(){\r\n    SuccessAndResult<ThriftType> output = topologicalSort(thriftTypes, new Predicate<ThriftType>() {\r\n        @Override\r\n        public boolean apply(@Nullable ThriftType t) {\r\n            ThriftProtocolType proto = checkNotNull(t).getProtocolType();\r\n            if (proto == ThriftProtocolType.ENUM || proto == ThriftProtocolType.STRUCT) {\r\n                return verifyStruct(t, true);\r\n            } else {\r\n                Preconditions.checkState(false, \"Top-level non-enum and non-struct?\");\r\n                return false;\r\n            }\r\n        }\r\n    });\r\n    if (output.success) {\r\n        thriftTypes = output.result;\r\n        return true;\r\n    } else {\r\n        for (ThriftType t : output.result) {\r\n            verifyStruct(t, false);\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.swift.generator.swift2thrift.Swift2ThriftGenerator.verifyTypes",
	"Comment": "and does a topological sort of thrifttypes in dependency order",
	"Method": "boolean verifyTypes(){\r\n    ThriftProtocolType proto = checkNotNull(t).getProtocolType();\r\n    if (proto == ThriftProtocolType.ENUM || proto == ThriftProtocolType.STRUCT) {\r\n        return verifyStruct(t, true);\r\n    } else {\r\n        Preconditions.checkState(false, \"Top-level non-enum and non-struct?\");\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.ClassOrInterfaceTypeDetailsBuilder.add",
	"Comment": "adds the given imports to this builder, if not already present",
	"Method": "boolean add(Collection<ImportMetadata> imports,boolean add,ImportMetadata importMetadata){\r\n    if (importMetadata == null) {\r\n        return false;\r\n    }\r\n    return registeredImports.add(importMetadata);\r\n}"
}, {
	"Path": "org.springframework.roo.support.osgi.OSGiUtils.getRooWorkingDirectory",
	"Comment": "returns the roo working directory for the given osgi component context",
	"Method": "String getRooWorkingDirectory(ComponentContext componentContext){\r\n    return componentContext.getBundleContext().getProperty(ROO_WORKING_DIRECTORY_PROPERTY);\r\n}"
}, {
	"Path": "tla2sany.semantic.Context.getConstantDecls",
	"Comment": "returns vector of opdeclnodes that represent constant declarations",
	"Method": "Vector<SemanticNode> getConstantDecls(){\r\n    Class<? extends SemanticNode> templateClass = OpDeclNode.class;\r\n    Enumeration<Pair> list = table.elements();\r\n    Vector<SemanticNode> result = new Vector();\r\n    while (list.hasMoreElements()) {\r\n        Pair elt = list.nextElement();\r\n        if (templateClass.isInstance(elt.info) && ((OpDeclNode) elt.info).getKind() == ASTConstants.ConstantDeclKind)\r\n            result.addElement((SemanticNode) (elt.info));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "util.BufferedDataInputStream.readShort",
	"Comment": "read and return the next short valueencoded in the next two bytes of this stream, orthrow eofexception if the stream containsfewer than two bytes.",
	"Method": "short readShort(){\r\n    this.readFully(this.temp, 0, 2);\r\n    return (short) ((temp[0] << 8) | (temp[1] & 0xff));\r\n}"
}, {
	"Path": "tla2tex.TokenizeSpec.isString",
	"Comment": "a hash table containing all the string tokens found in the spec.it is used for formatting comments.",
	"Method": "boolean isString(String str){\r\n    return null != stringHashTable.get(str);\r\n}"
}, {
	"Path": "tla2sany.semantic.Context.getContextSymbolEnumeration",
	"Comment": "returns a new contextsymbolenumeration object, which enumeratesthe symbolnodes of this context",
	"Method": "ContextSymbolEnumeration getContextSymbolEnumeration(){\r\n    return new ContextSymbolEnumeration();\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.plugins.pict.PICTImageReader.readPoly",
	"Comment": "read in a polygon. the input stream should be positioned at the first byteof the polygon.",
	"Method": "Polygon readPoly(DataInput pStream,Rectangle pBounds){\r\n    int size = pStream.readUnsignedShort();\r\n    readRectangle(pStream, pBounds);\r\n    int points = (size - 10) / 4;\r\n    Polygon polygon = new Polygon();\r\n    for (int i = 0; i < points; i++) {\r\n        int y = getYPtCoord(pStream.readShort());\r\n        int x = getXPtCoord(pStream.readShort());\r\n        polygon.addPoint(x, y);\r\n    }\r\n    if (!pBounds.contains(polygon.getBounds())) {\r\n        processWarningOccurred(\"Bad poly, contains point(s) out of bounds \" + pBounds + \": \" + polygon);\r\n    }\r\n    return polygon;\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.XmlUtils.readXml",
	"Comment": "read an xml document from the supplied input stream and return adocument.",
	"Method": "Document readXml(InputStream inputStream){\r\n    Validate.notNull(inputStream, \"InputStream required\");\r\n    try {\r\n        if (!(inputStream instanceof BufferedInputStream)) {\r\n            inputStream = new BufferedInputStream(inputStream);\r\n        }\r\n        return getDocumentBuilder().parse(inputStream);\r\n    } catch (final Exception e) {\r\n        throw new IllegalStateException(e);\r\n    } finally {\r\n        IOUtils.closeQuietly(inputStream);\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.fp.LongArray.set",
	"Comment": "inserts the specified element at the specified position in thisarray. overwrites any previous occupant of the specified position.",
	"Method": "void set(long position,long value){\r\n    rangeCheck(position);\r\n    this.unsafe.putAddress(log2phy(position), value);\r\n}"
}, {
	"Path": "pcal.PcalTLAGen.NeedsParentheses",
	"Comment": "as part of adding the tla to pcal translation code, ll removedseparated the code that decides if parentheses are needed from the parenthesize method and put it into this method.the parenthesize method itselfwill not be needed.",
	"Method": "boolean NeedsParentheses(Vector vec){\r\n    if (vec.size() == 0) {\r\n        return false;\r\n    }\r\n    ;\r\n    int curCharNum = 0;\r\n    int curLineNum = 0;\r\n    int parenDepth = 0;\r\n    boolean inString = false;\r\n    boolean needParen = false;\r\n    while ((curLineNum < vec.size()) && (!needParen)) {\r\n        String curLine = (String) vec.elementAt(0);\r\n        while ((curCharNum < curLine.length()) && (!needParen)) {\r\n            char curChar = curLine.charAt(curCharNum);\r\n            if (inString) {\r\n                switch(curChar) {\r\n                    case '\\\"':\r\n                        inString = false;\r\n                        break;\r\n                    case '\\\\':\r\n                        curCharNum++;\r\n                        break;\r\n                }\r\n                ;\r\n            } else {\r\n                boolean leftParen = false;\r\n                boolean rightParen = false;\r\n                boolean mayNeedParen = false;\r\n                char nextChar = ' ';\r\n                if (curCharNum < curLine.length() - 1) {\r\n                    nextChar = curLine.charAt(curCharNum + 1);\r\n                }\r\n                switch(curChar) {\r\n                    case '\\\"':\r\n                        inString = true;\r\n                        break;\r\n                    case '=':\r\n                        mayNeedParen = true;\r\n                        break;\r\n                    case '#':\r\n                        mayNeedParen = true;\r\n                        break;\r\n                    case '<':\r\n                        if (nextChar == '<') {\r\n                            curCharNum++;\r\n                            leftParen = true;\r\n                        } else {\r\n                            mayNeedParen = true;\r\n                        }\r\n                        ;\r\n                        break;\r\n                    case '>':\r\n                        if (nextChar == '>') {\r\n                            curCharNum++;\r\n                            rightParen = true;\r\n                        } else {\r\n                            mayNeedParen = true;\r\n                        }\r\n                        ;\r\n                        break;\r\n                    case '|':\r\n                        if ((nextChar == '-') || ((curCharNum > 0) && (curLine.charAt(curCharNum - 1) == '-'))) {\r\n                            mayNeedParen = true;\r\n                        }\r\n                        ;\r\n                        break;\r\n                    case '\\\\':\r\n                        if (!((nextChar == ' ') || (nextChar == 'o') || (nextChar == 'X'))) {\r\n                            mayNeedParen = true;\r\n                        }\r\n                        ;\r\n                        break;\r\n                    case '/':\r\n                        if (nextChar == '\\\\') {\r\n                            mayNeedParen = true;\r\n                        }\r\n                        ;\r\n                        break;\r\n                    case '(':\r\n                    case '[':\r\n                    case '{':\r\n                        leftParen = true;\r\n                        break;\r\n                    case ')':\r\n                    case ']':\r\n                    case '}':\r\n                        rightParen = true;\r\n                        break;\r\n                }\r\n                ;\r\n                if (mayNeedParen && (parenDepth == 0)) {\r\n                    needParen = true;\r\n                }\r\n                ;\r\n                if (leftParen) {\r\n                    parenDepth++;\r\n                }\r\n                ;\r\n                if (rightParen) {\r\n                    if (parenDepth == 0) {\r\n                        needParen = true;\r\n                    }\r\n                    ;\r\n                    parenDepth--;\r\n                }\r\n            }\r\n            ;\r\n            curCharNum++;\r\n        }\r\n        ;\r\n        if (inString) {\r\n            needParen = true;\r\n        }\r\n        ;\r\n        curLineNum++;\r\n        curCharNum = 0;\r\n    }\r\n    return needParen;\r\n}"
}, {
	"Path": "teammates.test.driver.BackDoor.getInstructorByEmail",
	"Comment": "gets an instructor data with particular email from the datastore.",
	"Method": "InstructorAttributes getInstructorByEmail(String instructorEmail,String courseId){\r\n    Map<String, String> params = createParamMap(BackDoorOperation.OPERATION_GET_INSTRUCTOR_AS_JSON_BY_EMAIL);\r\n    params.put(BackDoorOperation.PARAMETER_INSTRUCTOR_EMAIL, instructorEmail);\r\n    params.put(BackDoorOperation.PARAMETER_COURSE_ID, courseId);\r\n    String instructorJsonString = makePostRequest(params);\r\n    return JsonUtils.fromJson(instructorJsonString, InstructorAttributes.class);\r\n}"
}, {
	"Path": "teammates.logic.api.Logic.getAdminEmailDrafts",
	"Comment": "gets all admin email drafts that have not been sent and not in trash bin.",
	"Method": "List<AdminEmailAttributes> getAdminEmailDrafts(){\r\n    return adminEmailsLogic.getAdminEmailDrafts();\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.PhysicalTypeIdentifierNamingUtils.isValid",
	"Comment": "indicates whether the given metadata id appears to identify an instanceof the given metadata class.",
	"Method": "boolean isValid(String metadataClass,String metadataId){\r\n    return MetadataIdentificationUtils.isIdentifyingInstance(metadataId) && MetadataIdentificationUtils.getMetadataClass(metadataId).equals(metadataClass) && MetadataIdentificationUtils.getMetadataInstance(metadataId).contains(PATH_SUFFIX);\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorCourseStudentDetailsEditPage.submitSuccessfully",
	"Comment": "if the parameter value is not null, the value will be filled into therelevent input filed.",
	"Method": "InstructorCourseDetailsPage submitSuccessfully(String studentName,String teamName,String studentEmail,String comments){\r\n    fillStudentDetailsForm(studentName, teamName, studentEmail, comments);\r\n    return changePageType(InstructorCourseDetailsPage.class);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.video.OutputSurface.awaitNewImage",
	"Comment": "latches the next buffer into the texture. must be called from the thread that created the outputsurface object, after the onframeavailable callback has signaled that new data is available.",
	"Method": "void awaitNewImage(){\r\n    final int TIMEOUT_MS = 500;\r\n    synchronized (mFrameSyncObject) {\r\n        while (!mFrameAvailable) {\r\n            try {\r\n                mFrameSyncObject.wait(TIMEOUT_MS);\r\n                if (!mFrameAvailable) {\r\n                    throw new RuntimeException(\"Surface frame wait timed out\");\r\n                }\r\n            } catch (InterruptedException ie) {\r\n                throw new RuntimeException(ie);\r\n            }\r\n        }\r\n        mFrameAvailable = false;\r\n    }\r\n    mTextureRender.checkGlError(\"before updateTexImage\");\r\n    mSurfaceTexture.updateTexImage();\r\n}"
}, {
	"Path": "teammates.test.cases.browsertests.InstructorCourseDetailsPageUiTest.assertStudentDoesNotReceiveReminder",
	"Comment": "asserts that the student does not receive any reminder email.",
	"Method": "void assertStudentDoesNotReceiveReminder(String courseName,String courseId,EmailAccount studentEmailAccount){\r\n    ThreadHelper.waitFor(15000);\r\n    String keyReceivedInEmail = studentEmailAccount.getRegistrationKeyFromUnreadEmails(courseName, courseId);\r\n    assertNull(\"Student \" + studentEmailAccount + \" should not receive any reminder email!\", keyReceivedInEmail);\r\n}"
}, {
	"Path": "teammates.common.util.StringHelper.countEmptyStrings",
	"Comment": "counts the number of empty strings passed as the argument. null isconsidered an empty string, while whitespace is not.",
	"Method": "int countEmptyStrings(String strings){\r\n    return Math.toIntExact(Arrays.stream(strings).filter(s -> isEmpty(s)).count());\r\n}"
}, {
	"Path": "teammates.common.util.AdminLogQuery.moveTimePeriodBackward",
	"Comment": "moves the time period to query logs to the next period in the past with a length of timeinmillis.",
	"Method": "void moveTimePeriodBackward(long timeInMillis){\r\n    long nextEndTime = getStartTime() - 1;\r\n    long nextStartTime = nextEndTime - timeInMillis;\r\n    setTimePeriod(nextStartTime, nextEndTime);\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackSessionsPage.fillTimeValueForDatePickerTest",
	"Comment": "this method contains an intended mix of selenium and javascript to ensure that the testpasses consistently, do not try to click on the datepicker element using selenium as it willresult in a test that passes or fail randomly.",
	"Method": "void fillTimeValueForDatePickerTest(String timeId,LocalDate newValue){\r\n    WebElement dateInputElement = browser.driver.findElement(By.id(timeId));\r\n    click(dateInputElement);\r\n    dateInputElement.clear();\r\n    dateInputElement.sendKeys(TimeHelper.formatDateForSessionsForm(newValue.atStartOfDay()));\r\n    List<WebElement> elements = browser.driver.findElements(By.className(\"ui-datepicker-current-day\"));\r\n    for (WebElement element : elements) {\r\n        click(element);\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.util.RCPNameToFileIStream.initInternalLibraryPath",
	"Comment": "initialization of rcp internal location of standard modules",
	"Method": "void initInternalLibraryPath(){\r\n    try {\r\n        final Bundle bundle = Platform.getBundle(BuiltInModuleHelper.BUNDLE_ID);\r\n        Enumeration<URL> installedInternalModules = bundle.findEntries(BuiltInModuleHelper.STANDARD_MODULES_PATH, BuiltInModuleHelper.STANDARD_MODULES, true);\r\n        if (installedInternalModules == null) {\r\n            installedInternalModules = bundle.findEntries(File.separator + \"src\" + File.separator + BuiltInModuleHelper.STANDARD_MODULES_PATH, BuiltInModuleHelper.STANDARD_MODULES, true);\r\n        }\r\n        while (installedInternalModules.hasMoreElements()) {\r\n            final URL library = installedInternalModules.nextElement();\r\n            if (library != null) {\r\n                final String path = FileLocator.resolve(library).getPath();\r\n                libraryPathEntries.add(path);\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "teammates.common.util.JsonUtils.fromJson",
	"Comment": "deserializes the specified json string into an object of the specified type.",
	"Method": "T fromJson(String json,Type typeOfT){\r\n    return getTeammatesGson().fromJson(json, typeOfT);\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.BeanInfoUtils.getFieldForJavaBeanMethod",
	"Comment": "attempts to locate the field which is represented by the presented javabean method.not every javabean getter or setter actually backs to a field with anidentical name. in such cases, null will be returned.",
	"Method": "FieldMetadata getFieldForJavaBeanMethod(MemberDetails memberDetails,MethodMetadata method){\r\n    Validate.notNull(memberDetails, \"Member details required\");\r\n    Validate.notNull(method, \"Method is required\");\r\n    final JavaSymbolName propertyName = getPropertyNameForJavaBeanMethod(method);\r\n    return getFieldForPropertyName(memberDetails, propertyName);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.ShowSubtreeHandler.setEnabled",
	"Comment": "this method is used to update the enablement state. this has theeffect of graying out any menu items for thecommand if the handler is disabled. through experimentation, this method seems to becalled just before such menu items are rendered in the ui andjust before the handler is executed.",
	"Method": "void setEnabled(Object context){\r\n    TLAEditor editor = EditorUtil.getTLAEditorWithFocus();\r\n    if (editor != null) {\r\n        if (editor.getProofStructureProvider() != null) {\r\n            setBaseEnabled(editor.getProofStructureProvider().canRunFoldOperation(IProofFoldCommandIds.EXPAND_SUBTREE, (ITextSelection) editor.getSelectionProvider().getSelection()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.test.pageobjects.InstructorFeedbackEditPage.areDatesOfPreviousCurrentAndNextMonthEnabled",
	"Comment": "returns true if the dates of previous, current and next month are enabled.",
	"Method": "boolean areDatesOfPreviousCurrentAndNextMonthEnabled(boolean areDatesOfPreviousCurrentAndNextMonthEnabled,WebElement dateBox){\r\n    LocalDate previousMonth = LocalDate.now().minusMonths(1);\r\n    if (!navigate(dateBox, previousMonth)) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < 3; i++) {\r\n        List<WebElement> dates = browser.driver.findElements(By.xpath(\"//div[@id='ui-datepicker-div']/table/tbody/tr/td\"));\r\n        for (WebElement date : dates) {\r\n            boolean isDisabled = date.getAttribute(\"class\").contains(\"ui-datepicker-unselectable ui-state-disabled\");\r\n            boolean isFromOtherMonth = date.getAttribute(\"class\").contains(\"ui-datepicker-other-month\");\r\n            if (isDisabled && !isFromOtherMonth) {\r\n                return false;\r\n            }\r\n        }\r\n        click(browser.driver.findElement(By.className(\"ui-datepicker-next\")));\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.DecomposeProofHandler.decompose",
	"Comment": "this computes the decompose field of a noderepresentation.",
	"Method": "Decomposition decompose(NodeRepresentation nodeRep,Decomposition decomp,boolean isAssumption){\r\n    SemanticNode sn = nodeRep.semanticNode;\r\n    if (!(sn instanceof OpApplNode)) {\r\n        return null;\r\n    }\r\n    OpApplNode node = (OpApplNode) sn;\r\n    OpApplNode unprimedNode = node;\r\n    Decomposition result = new Decomposition();\r\n    if (decomp != null) {\r\n        result.renaming.identifiers = (Vector<FormalParamNode>) decomp.renaming.identifiers.clone();\r\n        result.renaming.newNames = (Vector<String>) decomp.renaming.newNames.clone();\r\n    }\r\n    result.instantiationSubstitutions = nodeRep.instantiationSubstitutions;\r\n    if (node.getOperator().getName() == ASTConstants.OP_prime) {\r\n        if (!(node.getArgs()[0] instanceof OpApplNode)) {\r\n            return null;\r\n        }\r\n        node = (OpApplNode) node.getArgs()[0];\r\n        unprimedNode = node;\r\n        result.primed = true;\r\n    }\r\n    if ((!nodeRep.isSubexpressionName) && (node.getOperator().getKind() == ASTConstants.UserDefinedOpKind)) {\r\n        OpDefNode definition = (OpDefNode) node.getOperator();\r\n        String operatorName = definition.getName().toString();\r\n        ExprNode opDef = definition.getBody();\r\n        InstanceSubstitution instSubs = nodeRep.instantiationSubstitutions.clone();\r\n        while (opDef instanceof SubstInNode) {\r\n            instSubs = substInNodeToInstanceSub(instSubs, operatorName, (SubstInNode) opDef);\r\n            if (instSubs == null) {\r\n                MessageDialog.openError(UIHelper.getShellProvider().getShell(), \"Decompose Proof Command\", \"Decomposing an instantiated definition whose\\n\" + \"instantiation cannot be handled.\");\r\n                return null;\r\n            }\r\n            opDef = ((SubstInNode) opDef).getBody();\r\n        }\r\n        String instNamePrefix = nodeRep.instantiationSubstitutions.prefix;\r\n        String restOfName = operatorName;\r\n        while (restOfName.indexOf(\"!\") != -1) {\r\n            instNamePrefix = instNamePrefix + restOfName.substring(0, restOfName.indexOf(\"!\") + 1);\r\n            restOfName = restOfName.substring(restOfName.indexOf(\"!\") + 1);\r\n        }\r\n        instSubs.prefix = instNamePrefix;\r\n        if (opDef instanceof OpApplNode) {\r\n            ExprOrOpArgNode[] args = node.getArgs();\r\n            for (int i = 0; i < args.length; i++) {\r\n                SyntaxTreeNode stn = (SyntaxTreeNode) args[i].stn;\r\n                Location stnLoc = stn.getLocation();\r\n                if (stnLoc.beginLine() != stnLoc.endLine()) {\r\n                    return null;\r\n                }\r\n            }\r\n            node = (OpApplNode) opDef;\r\n            result.moduleName = ((SyntaxTreeNode) node.stn).getLocation().source();\r\n            result.instantiationSubstitutions = instSubs;\r\n            result.definedOp = operatorName;\r\n            result.definedOpRep = nodeRep.subNodeText(unprimedNode);\r\n            result.formalParams = definition.getParams();\r\n            result.arguments = new String[result.formalParams.length];\r\n            result.argNodes = unprimedNode.getArgs();\r\n            for (int i = 0; i < result.arguments.length; i++) {\r\n                result.arguments[i] = stringArrayToString(nodeRep.subNodeText(((OpApplNode) unprimedNode).getArgs()[i]).nodeText);\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    boolean isAndOrOr = false;\r\n    boolean isJunction = false;\r\n    boolean isQuantifier = false;\r\n    boolean isBoundedQuantifier = false;\r\n    if (!(node.getOperator() instanceof OpDefNode)) {\r\n        return null;\r\n    }\r\n    UniqueString opId = ((OpDefNode) node.getOperator()).getName();\r\n    String opName = opId.toString();\r\n    if (((opId == ASTConstants.OP_cl) || opName.equals(\"\\\\land\")) && ((!isAssumption) || conjIsDecomposable(node))) {\r\n        result.type = NodeRepresentation.AND_TYPE;\r\n        if (opId == ASTConstants.OP_cl) {\r\n            isJunction = true;\r\n        } else {\r\n            isAndOrOr = true;\r\n        }\r\n    } else if ((opId == ASTConstants.OP_dl) || opName.equals(\"\\\\lor\")) {\r\n        result.type = NodeRepresentation.OR_TYPE;\r\n        if (opId == ASTConstants.OP_dl) {\r\n            isJunction = true;\r\n        } else {\r\n            isAndOrOr = true;\r\n        }\r\n    } else if (opName.equals(\"=>\")) {\r\n        result.type = NodeRepresentation.IMPLIES_TYPE;\r\n    } else if ((opId == ASTConstants.OP_bf) || (opId == ASTConstants.OP_uf)) {\r\n        result.type = NodeRepresentation.FORALL_TYPE;\r\n        isQuantifier = true;\r\n        if (opId == ASTConstants.OP_bf) {\r\n            isBoundedQuantifier = true;\r\n        }\r\n    } else if ((opId == ASTConstants.OP_be) || (opId == ASTConstants.OP_ue)) {\r\n        result.type = NodeRepresentation.EXISTS_TYPE;\r\n        isQuantifier = true;\r\n        if (opId == ASTConstants.OP_be) {\r\n            isBoundedQuantifier = true;\r\n        }\r\n    } else if (opId == ASTConstants.OP_sa) {\r\n        result.type = NodeRepresentation.SQSUB_TYPE;\r\n    } else {\r\n        return null;\r\n    }\r\n    if (isAndOrOr) {\r\n        processAndOrOr(result, node, \"\", opName);\r\n    } else if (isJunction) {\r\n        SemanticNode[] juncts = node.getArgs();\r\n        for (int i = 0; i < juncts.length; i++) {\r\n            result.children.add(juncts[i]);\r\n            result.namePath.add(\"!\" + (i + 1));\r\n        }\r\n    } else if (isQuantifier) {\r\n        result.children.add(node.getArgs()[0]);\r\n        String namePath = \"!(\";\r\n        result.quantIds = new Vector<FormalParamNode>();\r\n        if (isBoundedQuantifier) {\r\n            result.quantBounds = new Vector<ExprNode>();\r\n            result.quantBoundsubexpNames = new Vector<String>();\r\n            FormalParamNode[][] quantIdsArray = node.getBdedQuantSymbolLists();\r\n            ExprNode[] quantBounds = node.getBdedQuantBounds();\r\n            for (int i = 0; i < quantIdsArray.length; i++) {\r\n                if (node.isBdedQuantATuple()[i]) {\r\n                    return null;\r\n                }\r\n                FormalParamNode[] quantIds = quantIdsArray[i];\r\n                for (int j = 0; j < quantIds.length; j++) {\r\n                    result.quantIds.add(quantIds[j]);\r\n                    result.quantBounds.add(quantBounds[i]);\r\n                    result.quantBoundsubexpNames.add(\"!\" + (i + 1));\r\n                    if (!((i == 0) && (j == 0))) {\r\n                        namePath = namePath + \",\";\r\n                    }\r\n                    namePath = namePath + quantIds[j].getName().toString();\r\n                }\r\n            }\r\n        } else {\r\n            FormalParamNode[] quantIds = node.getUnbdedQuantSymbols();\r\n            for (int i = 0; i < quantIds.length; i++) {\r\n                result.quantIds.add(quantIds[i]);\r\n                if (i != 0) {\r\n                    namePath = namePath + \",\";\r\n                }\r\n                namePath = namePath + quantIds[i].getName().toString();\r\n            }\r\n        }\r\n        namePath = namePath + \")\";\r\n        result.namePath.add(namePath);\r\n    } else if ((result.type == NodeRepresentation.IMPLIES_TYPE) || (result.type == NodeRepresentation.SQSUB_TYPE)) {\r\n        result.children.add(node.getArgs()[0]);\r\n        result.namePath.add(\"!1\");\r\n        result.children.add(node.getArgs()[1]);\r\n        result.namePath.add(\"!2\");\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.handlers.ExecuteNextCommandHandler.uninstall",
	"Comment": "should be called when the handler is done listening forkey strokes.removes itself as a key stroke listener, a focus listener, and setsthe status line to the empty string.",
	"Method": "void uninstall(){\r\n    System.out.println(\"Start uninstall\");\r\n    editor.getViewer().removeVerifyKeyListener(this);\r\n    editor.getViewer().getTextWidget().removeFocusListener(this);\r\n    editor.setStatusMessage(\"\");\r\n    System.out.println(\"End uninstall\");\r\n}"
}, {
	"Path": "org.springframework.roo.support.osgi.BundleFindingUtils.findFirstBundleWithType",
	"Comment": "locates the first bundle that contains the presented type name and returnthat class.",
	"Method": "Class<?> findFirstBundleWithType(BundleContext context,String typeNameInExternalForm){\r\n    Validate.notNull(context, \"Bundle context required to perform the search\");\r\n    Validate.notBlank(typeNameInExternalForm, \"Resource name to locate is required\");\r\n    final String resourceName = \"/\" + typeNameInExternalForm.replace('.', '/') + \".class\";\r\n    final Bundle[] bundles = context.getBundles();\r\n    if (bundles == null) {\r\n        return null;\r\n    }\r\n    for (final Bundle bundle : bundles) {\r\n        try {\r\n            final URL url = bundle.getEntry(resourceName);\r\n            if (url != null) {\r\n                return bundle.loadClass(typeNameInExternalForm);\r\n            }\r\n        } catch (final Throwable e) {\r\n            return null;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.spec.manager.WorkspaceSpecManager.constructSpecName",
	"Comment": "constructs a specification name from the proposition string",
	"Method": "String constructSpecName(String proposition,boolean firstRun){\r\n    Spec existingSpec = getSpecByName(proposition);\r\n    if (existingSpec != null) {\r\n        if (firstRun) {\r\n            return constructSpecName(proposition.concat(\"_1\"), false);\r\n        } else {\r\n            String oldNumber = proposition.substring(proposition.lastIndexOf(\"_\"));\r\n            int number = Integer.parseInt(oldNumber) + 1;\r\n            proposition = proposition.substring(0, proposition.lastIndexOf(\"_\"));\r\n            return constructSpecName(proposition + number, false);\r\n        }\r\n    }\r\n    return proposition;\r\n}"
}, {
	"Path": "info.xiaomo.core.untils.StringUtil.decodeUnicode",
	"Comment": "this method will decode the string to a recognized stringin ui.",
	"Method": "StringBuffer decodeUnicode(String dataStr){\r\n    int start = 0;\r\n    int end = 0;\r\n    final StringBuffer buffer = new StringBuffer();\r\n    while (start > -1) {\r\n        end = dataStr.indexOf(\"\\\%u\", start + 2);\r\n        String charStr = \"\";\r\n        if (end == -1) {\r\n            charStr = dataStr.substring(start + 2, dataStr.length());\r\n        } else {\r\n            charStr = dataStr.substring(start + 2, end);\r\n        }\r\n        char letter = (char) Integer.parseInt(charStr, 16);\r\n        buffer.append(Character.toString(letter));\r\n        start = end;\r\n    }\r\n    return buffer;\r\n}"
}, {
	"Path": "com.twelvemonkeys.image.ImageUtil.waitForImage",
	"Comment": "waits for an image to load completely.will wait the specified time.",
	"Method": "boolean waitForImage(Image pImage,boolean waitForImage,Image pImage,long pTimeOut){\r\n    return waitForImages(new Image[] { pImage }, pTimeOut);\r\n}"
}, {
	"Path": "org.springframework.roo.addon.ws.addon.SeiMetadata.getSEIMethodFromServiceMethod",
	"Comment": "this method obtains a sei method from a provided service method.this method caches the generated methods",
	"Method": "MethodMetadata getSEIMethodFromServiceMethod(MethodMetadata serviceMethod){\r\n    if (seiMethodsFromServiceMethods.get(serviceMethod) != null) {\r\n        return seiMethodsFromServiceMethods.get(serviceMethod);\r\n    }\r\n    JavaSymbolName methodName = serviceMethod.getMethodName();\r\n    JavaType returnType = serviceMethod.getReturnType();\r\n    List<AnnotatedJavaType> parameterTypes = serviceMethod.getParameterTypes();\r\n    List<JavaSymbolName> parameterNames = serviceMethod.getParameterNames();\r\n    String paramList = \"\";\r\n    for (AnnotatedJavaType param : parameterTypes) {\r\n        paramList = paramList.concat(StringUtils.capitalize(param.getJavaType().getSimpleTypeName())).concat(\"And\");\r\n    }\r\n    if (StringUtils.isNotBlank(paramList)) {\r\n        if (methodName.toString().startsWith(\"findBy\")) {\r\n            methodName = new JavaSymbolName(\"find\");\r\n        } else if (methodName.toString().startsWith(\"countBy\")) {\r\n            methodName = new JavaSymbolName(\"count\");\r\n        }\r\n        paramList = paramList.substring(0, paramList.length() - \"And\".length());\r\n        methodName = new JavaSymbolName(methodName.toString().concat(\"By\").concat(paramList));\r\n    }\r\n    List<AnnotatedJavaType> annotatedParameterTypes = new ArrayList<AnnotatedJavaType>();\r\n    for (int i = 0; i < parameterTypes.size(); i++) {\r\n        List<AnnotationMetadata> annotations = new ArrayList<AnnotationMetadata>();\r\n        AnnotatedJavaType paramType = parameterTypes.get(i);\r\n        JavaSymbolName paramName = parameterNames.get(i);\r\n        AnnotationMetadataBuilder webParamAnnotation = new AnnotationMetadataBuilder(JavaType.WEB_PARAM);\r\n        webParamAnnotation.addStringAttribute(\"name\", paramName.toString());\r\n        webParamAnnotation.addStringAttribute(\"targetNamespace\", \"\");\r\n        annotations.add(webParamAnnotation.build());\r\n        AnnotationMetadataBuilder javaTypeAdapter = new AnnotationMetadataBuilder(JavaType.XML_JAVATYPE_ADAPTER);\r\n        if (paramType.getJavaType().getFullyQualifiedTypeName().equals(JavaType.ITERABLE.getFullyQualifiedTypeName())) {\r\n            javaTypeAdapter.addClassAttribute(\"value\", SpringletsJavaType.SPRINGLETS_ITERABLE_ADAPTER);\r\n            annotations.add(javaTypeAdapter.build());\r\n        } else if (paramType.getJavaType().getFullyQualifiedTypeName().equals(SpringJavaType.PAGE.getFullyQualifiedTypeName())) {\r\n            javaTypeAdapter.addClassAttribute(\"value\", SpringletsJavaType.SPRINGLETS_PAGE_ADAPTER);\r\n            annotations.add(javaTypeAdapter.build());\r\n        } else if (paramType.getJavaType().equals(SpringletsJavaType.SPRINGLETS_GLOBAL_SEARCH)) {\r\n            javaTypeAdapter.addClassAttribute(\"value\", SpringletsJavaType.SPRINGLETS_GLOBAL_SEARCH_ADAPTER);\r\n            annotations.add(javaTypeAdapter.build());\r\n        } else if (paramType.getJavaType().equals(SpringJavaType.PAGEABLE)) {\r\n            javaTypeAdapter.addClassAttribute(\"value\", SpringletsJavaType.SPRINGLETS_PAGEABLE_ADAPTER);\r\n            annotations.add(javaTypeAdapter.build());\r\n        }\r\n        AnnotatedJavaType annotatedParam = new AnnotatedJavaType(paramType.getJavaType(), annotations);\r\n        annotatedParameterTypes.add(annotatedParam);\r\n    }\r\n    MethodMetadataBuilder seiMethod = new MethodMetadataBuilder(getId(), Modifier.PUBLIC + Modifier.ABSTRACT, methodName, returnType, annotatedParameterTypes, parameterNames, null);\r\n    AnnotationMetadataBuilder javaTypeAdapter = new AnnotationMetadataBuilder(JavaType.XML_JAVATYPE_ADAPTER);\r\n    if (returnType.getFullyQualifiedTypeName().equals(JavaType.ITERABLE.getFullyQualifiedTypeName())) {\r\n        javaTypeAdapter.addClassAttribute(\"value\", SpringletsJavaType.SPRINGLETS_ITERABLE_ADAPTER);\r\n        seiMethod.addAnnotation(javaTypeAdapter);\r\n    } else if (returnType.getFullyQualifiedTypeName().equals(SpringJavaType.PAGE.getFullyQualifiedTypeName())) {\r\n        javaTypeAdapter.addClassAttribute(\"value\", SpringletsJavaType.SPRINGLETS_PAGE_ADAPTER);\r\n        seiMethod.addAnnotation(javaTypeAdapter);\r\n    } else if (returnType.equals(SpringletsJavaType.SPRINGLETS_GLOBAL_SEARCH)) {\r\n        javaTypeAdapter.addClassAttribute(\"value\", SpringletsJavaType.SPRINGLETS_GLOBAL_SEARCH_ADAPTER);\r\n        seiMethod.addAnnotation(javaTypeAdapter);\r\n    } else if (returnType.equals(SpringJavaType.PAGEABLE)) {\r\n        javaTypeAdapter.addClassAttribute(\"value\", SpringletsJavaType.SPRINGLETS_PAGEABLE_ADAPTER);\r\n        seiMethod.addAnnotation(javaTypeAdapter);\r\n    }\r\n    AnnotationMetadataBuilder requestWrapperAnnotation = new AnnotationMetadataBuilder(JavaType.REQUEST_WRAPPER);\r\n    requestWrapperAnnotation.addStringAttribute(\"className\", String.format(\"%s.%sRequest\", sei.getType().getPackage(), seiMethod.getMethodName().getSymbolNameCapitalisedFirstLetter()));\r\n    requestWrapperAnnotation.addStringAttribute(\"localName\", String.format(\"%sRequest\", seiMethod.getMethodName().getSymbolNameCapitalisedFirstLetter()));\r\n    requestWrapperAnnotation.addStringAttribute(\"targetNamespace\", String.format(\"http://ws.%s/\", StringUtils.reverseDelimited(projectTopLevelPackage.getFullyQualifiedPackageName(), '.')));\r\n    seiMethod.addAnnotation(requestWrapperAnnotation);\r\n    AnnotationMetadataBuilder responseWrapperAnnotation = new AnnotationMetadataBuilder(JavaType.RESPONSE_WRAPPER);\r\n    responseWrapperAnnotation.addStringAttribute(\"className\", String.format(\"%s.%sResponse\", sei.getType().getPackage(), seiMethod.getMethodName().getSymbolNameCapitalisedFirstLetter()));\r\n    responseWrapperAnnotation.addStringAttribute(\"localName\", String.format(\"%sResponse\", seiMethod.getMethodName().getSymbolNameCapitalisedFirstLetter()));\r\n    responseWrapperAnnotation.addStringAttribute(\"targetNamespace\", String.format(\"http://ws.%s/\", StringUtils.reverseDelimited(projectTopLevelPackage.getFullyQualifiedPackageName(), '.')));\r\n    seiMethod.addAnnotation(responseWrapperAnnotation);\r\n    AnnotationMetadataBuilder webMethodAnnotation = new AnnotationMetadataBuilder(JavaType.WEB_METHOD);\r\n    webMethodAnnotation.addStringAttribute(\"action\", String.format(\"urn:%s\", seiMethod.getMethodName().getSymbolNameCapitalisedFirstLetter()));\r\n    seiMethod.addAnnotation(webMethodAnnotation);\r\n    AnnotationMetadataBuilder webResultAnnotation = new AnnotationMetadataBuilder(JavaType.WEB_RESULT);\r\n    webResultAnnotation.addStringAttribute(\"name\", returnType.getBaseType().getSimpleTypeName().toLowerCase());\r\n    webResultAnnotation.addStringAttribute(\"targetNamespace\", \"\");\r\n    seiMethod.addAnnotation(webResultAnnotation);\r\n    AnnotationMetadataBuilder wsdlDocumentationCollectionAnnotation = new AnnotationMetadataBuilder(new JavaType(\"org.apache.cxf.annotations.WSDLDocumentationCollection\"));\r\n    List<AnnotationAttributeValue<?>> documentations = new ArrayList<AnnotationAttributeValue<?>>();\r\n    AnnotationMetadataBuilder documentationAnnotation1 = new AnnotationMetadataBuilder(wsdlDocumentationType);\r\n    documentationAnnotation1.addStringAttribute(\"value\", String.format(\"TODO Auto-generated documentation for %s\", sei.getType().getSimpleTypeName()));\r\n    documentationAnnotation1.addEnumAttribute(\"placement\", wsdlDocumentationType, new JavaSymbolName(\"Placement.DEFAULT\"));\r\n    NestedAnnotationAttributeValue newDocumentation1 = new NestedAnnotationAttributeValue(new JavaSymbolName(\"value\"), documentationAnnotation1.build());\r\n    documentations.add(newDocumentation1);\r\n    AnnotationMetadataBuilder documentationAnnotation2 = new AnnotationMetadataBuilder(wsdlDocumentationType);\r\n    documentationAnnotation2.addStringAttribute(\"value\", String.format(\"TODO Auto-generated documentation for %s\", sei.getType().getSimpleTypeName()));\r\n    documentationAnnotation2.addEnumAttribute(\"placement\", wsdlDocumentationType, new JavaSymbolName(\"Placement.PORT_TYPE_OPERATION_OUTPUT\"));\r\n    NestedAnnotationAttributeValue newDocumentation2 = new NestedAnnotationAttributeValue(new JavaSymbolName(\"value\"), documentationAnnotation2.build());\r\n    documentations.add(newDocumentation2);\r\n    ArrayAttributeValue<AnnotationAttributeValue<?>> newDocumentations = new ArrayAttributeValue<AnnotationAttributeValue<?>>(new JavaSymbolName(\"value\"), documentations);\r\n    wsdlDocumentationCollectionAnnotation.addAttribute(newDocumentations);\r\n    seiMethod.addAnnotation(wsdlDocumentationCollectionAnnotation);\r\n    seiMethodsFromServiceMethods.put(serviceMethod, seiMethod.build());\r\n    seiMethods.put(seiMethod.build(), serviceMethod);\r\n    return seiMethod.build();\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.util.ModelEditorPartListener.partVisible",
	"Comment": "this updates the error view. if the error view is not open,then the user may have closed it, so nothing is done.if the error view is open but the model editor being switchedto has no errors, then the error view is cleared but not closed.if the model editor made visible does have errors, then the errorview is updated with these errors.",
	"Method": "void partVisible(IWorkbenchPartReference partRef){\r\n    final IWorkbenchPart part = partRef.getPart(false);\r\n    if (part != null && part instanceof ModelEditor) {\r\n        final ModelEditor editor = (ModelEditor) part;\r\n        TLCModelLaunchDataProvider provider = null;\r\n        final Model model = editor.getModel();\r\n        if (model.isOriginalTraceShown()) {\r\n            provider = TLCOutputSourceRegistry.getModelCheckSourceRegistry().getProvider(model);\r\n        } else {\r\n            provider = TLCOutputSourceRegistry.getTraceExploreSourceRegistry().getProvider(model);\r\n        }\r\n        final TLCErrorView errorView = (TLCErrorView) UIHelper.findView(TLCErrorView.ID);\r\n        if (errorView != null && provider != null) {\r\n            if (provider.getErrors().size() > 0) {\r\n                TLCErrorView.updateErrorView(model, !UIHelper.isInSameStack(editor, TLCErrorView.ID));\r\n            } else {\r\n                errorView.clear();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.ui.controller.InstructorCourseInstructorAddAction.createInstructorWithBasicAttributes",
	"Comment": "creates a new instructor with basic information.this consists of everything apart from custom privileges.",
	"Method": "InstructorAttributes createInstructorWithBasicAttributes(String courseId,String instructorName,String instructorEmail,String instructorRole,boolean isDisplayedToStudents,String displayedName){\r\n    String instrName = SanitizationHelper.sanitizeName(instructorName);\r\n    String instrEmail = SanitizationHelper.sanitizeEmail(instructorEmail);\r\n    String instrRole = SanitizationHelper.sanitizeName(instructorRole);\r\n    String instrDisplayedName = SanitizationHelper.sanitizeName(displayedName);\r\n    InstructorPrivileges privileges = new InstructorPrivileges(instructorRole);\r\n    return InstructorAttributes.builder(null, courseId, instrName, instrEmail).withRole(instrRole).withIsDisplayedToStudents(isDisplayedToStudents).withDisplayedName(instrDisplayedName).withPrivileges(privileges).build();\r\n}"
}, {
	"Path": "tla2sany.semantic.LabelNode.getChildren",
	"Comment": "the following method was inexplicably missing until added by llon 16 october 2013.",
	"Method": "SemanticNode[] getChildren(){\r\n    return new SemanticNode[] { this.body };\r\n}"
}, {
	"Path": "com.facebook.swift.codec.internal.compiler.ThriftCodecByteCodeGenerator.defineWriteBridgeMethod",
	"Comment": "defines the generics bridge method with untyped args to the type specific write method.",
	"Method": "void defineWriteBridgeMethod(){\r\n    classDefinition.addMethod(new MethodDefinition(a(PUBLIC, BRIDGE, SYNTHETIC), \"write\", null, arg(\"struct\", Object.class), arg(\"protocol\", TProtocol.class)).addException(Exception.class).loadThis().loadVariable(\"struct\", structType).loadVariable(\"protocol\").invokeVirtual(codecType, \"write\", type(void.class), structType, type(TProtocol.class)).ret());\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.AbstractMemberHoldingTypeDetailsBuilder.setDeclaredConstructors",
	"Comment": "sets the builders for the constructors that are to be declared",
	"Method": "void setDeclaredConstructors(Collection<? extends ConstructorMetadataBuilder> declaredConstructors){\r\n    this.declaredConstructors.clear();\r\n    if (declaredConstructors != null) {\r\n        this.declaredConstructors.addAll(declaredConstructors);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.obr.addon.search.ObrAddonSearchOperationsImpl.populateBundlesToInstall",
	"Comment": "method to populate bundles to install. depending of the search type, will be displayed different kinds of bundles.",
	"Method": "void populateBundlesToInstall(String searchTerms,SearchType type){\r\n    populateRepositories();\r\n    bundlesToInstall.clear();\r\n    searchResultCache.clear();\r\n    int bundleId = 0;\r\n    for (Repository repo : repositories) {\r\n        Resource[] repoResources = repo.getResources();\r\n        for (Resource repoResource : repoResources) {\r\n            ObrBundle bundle = new ObrBundle(repoResource.getSymbolicName(), repoResource.getPresentationName(), repoResource.getSize(), repoResource.getVersion(), repoResource.getURI());\r\n            if (checkIfBundleIsInstalled(bundle)) {\r\n                continue;\r\n            }\r\n            Capability[] resourceCapabilities = repoResource.getCapabilities();\r\n            for (Capability capability : resourceCapabilities) {\r\n                if (type.equals(SearchType.ADDON)) {\r\n                    if (capability.getName().equals(CAPABILITY_COMMANDS_NAME)) {\r\n                        Map<String, Object> capabilityProperties = capability.getPropertiesAsMap();\r\n                        boolean match = false;\r\n                        for (Entry capabilityProperty : capabilityProperties.entrySet()) {\r\n                            String capabilityCommand = (String) capabilityProperty.getValue();\r\n                            bundle.addCommand(capabilityCommand);\r\n                            if (capabilityCommand.startsWith(searchTerms)) {\r\n                                match = true;\r\n                            }\r\n                        }\r\n                        if (match) {\r\n                            bundleId++;\r\n                            bundlesToInstall.add(bundle);\r\n                            searchResultCache.put(String.format(\"d\", bundleId), bundle);\r\n                        }\r\n                    }\r\n                } else if (type.equals(SearchType.JDBCDRIVER)) {\r\n                    if (capability.getName().equals(CAPABILITY_JDBCDRIVER_NAME)) {\r\n                        Map<String, Object> capabilityProperties = capability.getPropertiesAsMap();\r\n                        boolean match = false;\r\n                        for (Entry capabilityProperty : capabilityProperties.entrySet()) {\r\n                            String capabilityKey = (String) capabilityProperty.getKey();\r\n                            if (capabilityKey.toLowerCase().equals(\"driver\")) {\r\n                                String capabilityDriver = (String) capabilityProperty.getValue();\r\n                                if (capabilityDriver.startsWith(searchTerms)) {\r\n                                    match = true;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (match) {\r\n                            bundleId++;\r\n                            bundlesToInstall.add(bundle);\r\n                            searchResultCache.put(String.format(\"d\", bundleId), bundle);\r\n                        }\r\n                    }\r\n                } else if (type.equals(SearchType.LIBRARY)) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.ui.pagedata.PageData.getInstructorHomeLink",
	"Comment": "returns the relative path to the instructor home page. the user id is encoded in the url as a parameter.",
	"Method": "String getInstructorHomeLink(){\r\n    String link = Const.ActionURIs.INSTRUCTOR_HOME_PAGE;\r\n    link = addUserIdToUrl(link);\r\n    return link;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.model.ModelWriter.addArrowAssignment",
	"Comment": "assigns a right side to a label using an id generated from given schema",
	"Method": "String addArrowAssignment(Assignment constant,String schema){\r\n    String id = ModelWriter.getValidIdentifier(schema);\r\n    tlaBuffer.append(constant.getParametrizedLabel(id)).append(DEFINES).append(CR).append(constant.getRight()).append(CR);\r\n    cfgBuffer.append(\"CONSTANT\").append(CR);\r\n    cfgBuffer.append(constant.getLabel()).append(ARROW).append(id).append(CR);\r\n    return id;\r\n}"
}, {
	"Path": "org.srpingframework.roo.osgi.gogo.commands.SubsystemCommands.installSubsystemDependencies",
	"Comment": "method that checks capabilities of selected subsystem resource and if appears any related repository or any related subsystem are going to be installed.",
	"Method": "void installSubsystemDependencies(Resource subsystemResource){\r\n    Capability[] capabilities = subsystemResource.getCapabilities();\r\n    List<Capability> repositoriesCapability = new ArrayList<Capability>();\r\n    List<Capability> subsystemsCapability = new ArrayList<Capability>();\r\n    LOGGER.log(Level.INFO, \"Getting 'Roo Addon Suite' dependencies...\");\r\n    LOGGER.log(Level.INFO, \" \");\r\n    for (Capability capability : capabilities) {\r\n        if (capability.getName().equals(REPOSITORY_DEPENDENCY_CAPABILITY_NAME)) {\r\n            repositoriesCapability.add(capability);\r\n        } else if (capability.getName().equals(SUBSYSTEM_DEPENDENCY_CAPABILITY_NAME)) {\r\n            subsystemsCapability.add(capability);\r\n        }\r\n    }\r\n    showDependenciesInfo(repositoriesCapability, subsystemsCapability);\r\n    if (repositoriesCapability.isEmpty() && subsystemsCapability.isEmpty()) {\r\n        return;\r\n    }\r\n    if (!repositoriesCapability.isEmpty()) {\r\n        LOGGER.log(Level.INFO, \"   Adding repositories to Spring Roo installation\");\r\n        LOGGER.log(Level.INFO, \"   ----------------------------------------------------------\");\r\n        LOGGER.log(Level.INFO, \"\");\r\n        for (Capability repositoryCapability : repositoriesCapability) {\r\n            Property[] repositoryList = repositoryCapability.getProperties();\r\n            for (Property repository : repositoryList) {\r\n                String repoURL = repository.getValue();\r\n                getRepositoryAdmin().addRepository(repoURL);\r\n                LOGGER.log(Level.INFO, \"      \" + repoURL + \" added\");\r\n            }\r\n        }\r\n        LOGGER.log(Level.INFO, \"\");\r\n    }\r\n    if (!subsystemsCapability.isEmpty()) {\r\n        LOGGER.log(Level.INFO, \"   Installing subsystems into Spring Roo installation\");\r\n        LOGGER.log(Level.INFO, \"   ----------------------------------------------------------\");\r\n        LOGGER.log(Level.INFO, \"\");\r\n        for (Capability subsystemCapability : subsystemsCapability) {\r\n            Property[] subsystemList = subsystemCapability.getProperties();\r\n            for (Property subsystem : subsystemList) {\r\n                String subsystemURL = subsystem.getValue();\r\n                getSubsystem(0).install(subsystemURL);\r\n                LOGGER.log(Level.INFO, \"      \" + subsystemURL + \" installed\");\r\n            }\r\n        }\r\n        LOGGER.log(Level.INFO, \"\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.model.JdkJavaType.isPartOfJavaLang",
	"Comment": "determines whether the presented simple type name is part of java.lang ornot.",
	"Method": "boolean isPartOfJavaLang(JavaType javaType,boolean isPartOfJavaLang,String simpleTypeName){\r\n    Validate.notBlank(simpleTypeName, \"Simple type name required\");\r\n    return javaLangSimpleTypeNames.contains(simpleTypeName);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.video.InputSurface.setPresentationTime",
	"Comment": "sends the presentation time stamp to egl. time is expressed in nanoseconds.",
	"Method": "void setPresentationTime(long nsecs){\r\n    EGLExt.eglPresentationTimeANDROID(mEGLDisplay, mEGLSurface, nsecs);\r\n}"
}, {
	"Path": "teammates.test.cases.testdriver.TestNgTest.addFilesToTestsRecursively",
	"Comment": "recursively adds files from testng.xml which are to be checked.",
	"Method": "Map<String, String> addFilesToTestsRecursively(String path,boolean areFilesInCurrentDirExcluded,String packageName,String testNgXml){\r\n    Map<String, String> testFiles = new HashMap();\r\n    File folder = new File(path);\r\n    File[] listOfFiles = folder.listFiles();\r\n    if (listOfFiles == null) {\r\n        return testFiles;\r\n    }\r\n    for (File file : listOfFiles) {\r\n        String name = file.getName();\r\n        if (file.isFile() && name.endsWith(\".java\") && !name.startsWith(\"package-info\") && !areFilesInCurrentDirExcluded) {\r\n            testFiles.put(name.replace(\".java\", \"\"), packageName);\r\n        } else if (file.isDirectory()) {\r\n            testFiles.putAll(addFilesToTestsRecursively(path + \"/\" + name, isPackageNameInTestNg(packageName + \".\" + name, testNgXml), packageName + \".\" + name, testNgXml));\r\n        }\r\n    }\r\n    return testFiles;\r\n}"
}, {
	"Path": "teammates.test.driver.AssertHelper.assertSameContentIgnoreOrder",
	"Comment": "asserts that the two given lists have the same contents, ignoring their order.",
	"Method": "void assertSameContentIgnoreOrder(List<?> a,List<?> b){\r\n    String expectedListAsString = Joiner.on(\"\\t\").join(a);\r\n    String actualListAsString = Joiner.on(\"\\t\").join(b);\r\n    List<String> expectedStringTypeList = new ArrayList(Arrays.asList(expectedListAsString.split(\"\\t\")));\r\n    List<String> actualStringTypeList = new ArrayList(Arrays.asList(actualListAsString.split(\"\\t\")));\r\n    expectedStringTypeList.sort(null);\r\n    actualStringTypeList.sort(null);\r\n    assertEquals(expectedStringTypeList, actualStringTypeList);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.output.data.ObligationStatus.getTLAPMLocation",
	"Comment": "returns the location of the obligation that was reported by tlapm.note that this is not necessarily the current location of the markerrepresenting this obligation.",
	"Method": "Location getTLAPMLocation(){\r\n    return location;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackRubricQuestionDetails.getRubricWeights",
	"Comment": "returns a list of rubric weights if the weights are assigned,otherwise returns an empty list.",
	"Method": "List<List<Double>> getRubricWeights(){\r\n    if (hasAssignedWeights) {\r\n        return rubricWeightsForEachCell;\r\n    }\r\n    return new ArrayList();\r\n}"
}, {
	"Path": "teammates.common.util.FieldValidator.getInvalidityInfoForVisibilityOfFeedbackParticipantComments",
	"Comment": "checks if visibility of comment is following question when comment is from a feedback participant.",
	"Method": "String getInvalidityInfoForVisibilityOfFeedbackParticipantComments(boolean isCommentFromFeedbackParticipant,boolean isVisibilityFollowingFeedbackQuestion){\r\n    if (isCommentFromFeedbackParticipant && !isVisibilityFollowingFeedbackQuestion) {\r\n        return \"Comment by feedback participant not following visibility setting of the question.\";\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "com.twelvemonkeys.image.CopyDither.getBounds2D",
	"Comment": "returns the bounding box of the filtered destination raster.sincethis is not a geometric operation, the bounding box does notchange.",
	"Method": "Rectangle2D getBounds2D(BufferedImage pSrc,Rectangle2D getBounds2D,Raster pSrc){\r\n    return pSrc.getBounds();\r\n}"
}, {
	"Path": "tla2sany.modanalyzer.ParseUnit.getInstanceInLet",
	"Comment": "if we want to allow plain instances inside a let, this method must be modified accordingly.",
	"Method": "void getInstanceInLet(TreeNode treeNode,ModuleRelatives currentRelatives){\r\n    TreeNode[] children = treeNode.heirs();\r\n    if (treeNode.getImage().equals(\"N_LetIn\")) {\r\n        TreeNode[] syntaxTreeNode = children[1].heirs();\r\n        for (int i = 0; i < syntaxTreeNode.length; i++) {\r\n            TreeNode def = syntaxTreeNode[i];\r\n            if (def.getImage().equals(\"N_ModuleDefinition\")) {\r\n                TreeNode[] instanceHeirs = def.heirs();\r\n                int nonLocalInstanceNodeIX = 2;\r\n                String instanceModuleName = instanceHeirs[nonLocalInstanceNodeIX].heirs()[1].getImage();\r\n                currentRelatives.directlyInstantiatedModuleNames.addElement(instanceModuleName);\r\n            } else {\r\n                TreeNode[] defChildren = def.heirs();\r\n                for (int j = 0; j < defChildren.length; j++) {\r\n                    this.getInstanceInLet(defChildren[j], currentRelatives);\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = 0; i < children.length; i++) {\r\n            this.getInstanceInLet(children[i], currentRelatives);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.MetadataLocatorUtils.checkEvictCache",
	"Comment": "evict cache from cachemap if type is found on cachemapinverse",
	"Method": "void checkEvictCache(JavaType type){\r\n    if (type == null) {\r\n        return;\r\n    }\r\n    final JavaType mainType = cacheMapInverse.remove(type);\r\n    if (mainType != null) {\r\n        cacheMap.remove(mainType);\r\n    }\r\n}"
}, {
	"Path": "tla2sany.modanalyzer.ModuleContext.bind",
	"Comment": "bind a module name to a particular modulepointer, replacing any bindingthat is already there to the same modname.",
	"Method": "void bind(String modName,ModulePointer modPointer){\r\n    context.put(modName, modPointer);\r\n}"
}, {
	"Path": "tlc2.tool.liveness.LiveCheck1.reset",
	"Comment": "this method resets the behavior graph so that we can recompute the sccs.",
	"Method": "void reset(){\r\n    for (int i = 0; i < bgraphs.length; i++) {\r\n        bgraphs[i].resetNumberField();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.itd.AbstractItdTypeDetailsProvidingMetadataItem.governorHasMethod",
	"Comment": "indicates whether the governor has a method with the given signature.",
	"Method": "boolean governorHasMethod(JavaSymbolName methodName,JavaType parameterTypes,boolean governorHasMethod,JavaSymbolName methodName,List<JavaType> parameterTypes){\r\n    return getGovernorMethod(methodName, parameterTypes) != null;\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.isElementHasClass",
	"Comment": "returns true if there exists an element with the given id and class name.",
	"Method": "boolean isElementHasClass(String elementId,String targetClass){\r\n    List<WebElement> elementsMatched = browser.driver.findElements(By.cssSelector(\"#\" + elementId + \".\" + targetClass));\r\n    return !elementsMatched.isEmpty();\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.utils.video.OutputSurface.setup",
	"Comment": "creates instances of texturerender and surfacetexture, and a surface associated with the surfacetexture.",
	"Method": "void setup(){\r\n    mTextureRender = new TextureRender();\r\n    mTextureRender.surfaceCreated();\r\n    if (VERBOSE)\r\n        Log.d(TAG, \"textureID=\" + mTextureRender.getTextureId());\r\n    mSurfaceTexture = new SurfaceTexture(mTextureRender.getTextureId());\r\n    mSurfaceTexture.setOnFrameAvailableListener(this);\r\n    mSurface = new Surface(mSurfaceTexture);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.TLAColorProvider.getColor",
	"Comment": "return the color that is stored in the color table under the given rgbvalue.",
	"Method": "Color getColor(RGB rgb){\r\n    Color color = (Color) fColorTable.get(rgb);\r\n    if (color == null) {\r\n        color = new Color(Display.getCurrent(), rgb);\r\n        fColorTable.put(rgb, color);\r\n    }\r\n    return color;\r\n}"
}, {
	"Path": "tlc2.util.FP64.New",
	"Comment": "return the fingerprint of the contents of thestream is. ioexceptionis thrown in the event of an error reading thestream.",
	"Method": "long New(long New,String s,long New,char[] c,long New,char[] c,int off,int len,long New,byte[] bytes,long New,InputStream is){\r\n    return Extend(IrredPoly, is);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.proof.TLAProofFoldingStructureProvider.documentAboutToBeChanged",
	"Comment": "this method used to assess whether the document haschanged between the time that the parser was calledand when it completes.",
	"Method": "void documentAboutToBeChanged(DocumentEvent event){\r\n    documentLastModified = System.currentTimeMillis();\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.regex.WildcardStringParser.getStringMask",
	"Comment": "gets the string mask that was used when building the parser atomaton.",
	"Method": "String getStringMask(){\r\n    return stringMask;\r\n}"
}, {
	"Path": "tla2sany.semantic.APSubstInNode.getSubFor",
	"Comment": "returns the opdeclnode of the ith element of the substitutionlist.",
	"Method": "OpDeclNode getSubFor(int i){\r\n    return this.substs[i].getOp();\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.TimeoutMap.getExpiryTime",
	"Comment": "gets the maximum time any value will be kept in the map, before it expires.",
	"Method": "long getExpiryTime(){\r\n    return expiryTime;\r\n}"
}, {
	"Path": "org.springframework.roo.support.util.ReflectionUtils.handleUnexpectedException",
	"Comment": "throws an illegalstateexception with the given exception as root cause.",
	"Method": "void handleUnexpectedException(Throwable ex){\r\n    throw new IllegalStateException(\"Unexpected exception thrown\", ex);\r\n}"
}, {
	"Path": "it.michelelacorte.swipeablecard.SwipeableCardAdapter.animationCardDown",
	"Comment": "animation card for down animation, please do not modify this.",
	"Method": "void animationCardDown(CardView card,Toolbar toolbar,long duration){\r\n    new CountDownTimer(1, 1) {\r\n        public void onTick(long millisUntilFinished) {\r\n        }\r\n        public void onFinish() {\r\n            card.animate().translationY(height - ((int) (toolbar.getHeight() * 1.7))).setDuration(duration).start();\r\n        }\r\n    }.start();\r\n}"
}, {
	"Path": "it.michelelacorte.swipeablecard.SwipeableCardAdapter.animationCardDown",
	"Comment": "animation card for down animation, please do not modify this.",
	"Method": "void animationCardDown(CardView card,Toolbar toolbar,long duration){\r\n}"
}, {
	"Path": "it.michelelacorte.swipeablecard.SwipeableCardAdapter.animationCardDown",
	"Comment": "animation card for down animation, please do not modify this.",
	"Method": "void animationCardDown(CardView card,Toolbar toolbar,long duration){\r\n    card.animate().translationY(height - ((int) (toolbar.getHeight() * 1.7))).setDuration(duration).start();\r\n}"
}, {
	"Path": "it.michelelacorte.swipeablecard.CustomCardAnimation.animationCustomCardStart",
	"Comment": "start animation and set card at start positiondo not modify this!",
	"Method": "void animationCustomCardStart(){\r\n    final int height = getScreenSize(mContext);\r\n    new CountDownTimer(300, 1) {\r\n        public void onTick(long millisUntilFinished) {\r\n            mCardView.setTranslationY(height - ((int) (mStartCardPosition * 1.7)));\r\n        }\r\n        public void onFinish() {\r\n            mCardView.setTranslationY(height - ((int) (mStartCardPosition * 1.7)));\r\n        }\r\n    }.start();\r\n}"
}, {
	"Path": "it.michelelacorte.swipeablecard.CustomCardAnimation.animationCustomCardStart",
	"Comment": "start animation and set card at start positiondo not modify this!",
	"Method": "void animationCustomCardStart(){\r\n    mCardView.setTranslationY(height - ((int) (mStartCardPosition * 1.7)));\r\n}"
}, {
	"Path": "it.michelelacorte.swipeablecard.CustomCardAnimation.animationCustomCardStart",
	"Comment": "start animation and set card at start positiondo not modify this!",
	"Method": "void animationCustomCardStart(){\r\n    mCardView.setTranslationY(height - ((int) (mStartCardPosition * 1.7)));\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.plugins.pict.PICTUtil.readPascalString",
	"Comment": "reads a pascal string from the given stream.the input stream must be positioned at the length byte of the text,which can thus be a maximum of 255 characters long.",
	"Method": "String readPascalString(DataInput pStream){\r\n    int length = pStream.readUnsignedByte();\r\n    byte[] bytes = new byte[length];\r\n    pStream.readFully(bytes, 0, length);\r\n    return new String(bytes, ENCODING);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.editor.ModelEditor.addErrorMessage",
	"Comment": "this adds error messages to all pages for the given control.if the control is null, it will do nothing.",
	"Method": "void addErrorMessage(Object key,String messageText,String pageId,int type,Control control){\r\n    if (control != null) {\r\n        for (int i = 0; i < pagesToAdd.length; i++) {\r\n            pagesToAdd[i].getManagedForm().getMessageManager().addMessage(key, messageText, pageId, type, control);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "tla2sany.semantic.ModuleNode.isParameterFree",
	"Comment": "variable decls, so that instanceing it is the same as extending it.",
	"Method": "boolean isParameterFree(){\r\n    return (getConstantDecls().length == 0 && getVariableDecls().length == 0);\r\n}"
}, {
	"Path": "tlc2.tool.liveness.TBParVec.contains",
	"Comment": "this method tests whether a particle is in a list of other particles",
	"Method": "boolean contains(TBPar par){\r\n    for (int i = 0; i < this.size(); i++) {\r\n        if (par.equals(this.parAt(i))) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "teammates.ui.pagedata.PageData.getStudentHomeLink",
	"Comment": "returns the relative path to the student home page. the user id is encoded in the url as a parameter.",
	"Method": "String getStudentHomeLink(String getStudentHomeLink,boolean isUnregistered){\r\n    String link = Const.ActionURIs.STUDENT_HOME_PAGE;\r\n    link = addUserIdToUrl(link);\r\n    if (isUnregistered) {\r\n        link = Url.addParamToUrl(student.getRegistrationUrl(), Const.ParamsNames.NEXT_URL, link);\r\n    }\r\n    return link;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.editor.basic.util.EditorUtil.lookupOriginalSymbol",
	"Comment": "like lookupsymbol except that for definitions that were obtained by instantiation from a definition in another module, it returns the definition from that other module.",
	"Method": "SymbolNode lookupOriginalSymbol(UniqueString name,SemanticNode curNode,Location location,SymbolNode defaultResult){\r\n    name = Operators.resolveSynonym(name);\r\n    SymbolNode resolvedSymbol = lookupSymbol(name, curNode, location, defaultResult);\r\n    if (resolvedSymbol == null) {\r\n        return null;\r\n    }\r\n    if (resolvedSymbol instanceof OpDefNode) {\r\n        OpDefNode opdef = (OpDefNode) resolvedSymbol;\r\n        if (opdef.getSource() != null) {\r\n            resolvedSymbol = opdef.getSource();\r\n        }\r\n    } else if (resolvedSymbol instanceof ThmOrAssumpDefNode) {\r\n        ThmOrAssumpDefNode opdef = (ThmOrAssumpDefNode) resolvedSymbol;\r\n        if (opdef.getSource() != null) {\r\n            resolvedSymbol = opdef.getSource();\r\n        }\r\n    }\r\n    return resolvedSymbol;\r\n}"
}, {
	"Path": "tlc2.tool.CheckImplFile.getState",
	"Comment": "this method gets a new state from the external world via files.it returns null if there is nothing available.",
	"Method": "TLCState getState(){\r\n    if (this.sidx < this.states.length) {\r\n        return this.states[sidx++];\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackQuestionsLogic.shiftQuestionNumbersDown",
	"Comment": "shifts all question numbers after questionnumbertoshiftfrom down by one.",
	"Method": "void shiftQuestionNumbersDown(int questionNumberToShiftFrom,List<FeedbackQuestionAttributes> questionsToShift){\r\n    for (FeedbackQuestionAttributes question : questionsToShift) {\r\n        if (question.questionNumber > questionNumberToShiftFrom) {\r\n            question.questionNumber -= 1;\r\n            updateFeedbackQuestionWithoutResponseRateUpdate(question);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.output.data.ObligationStatus.getProverStatuses",
	"Comment": "returns a map from the name of backendsto the string representing the mostrecent status of the backend on this obligation.",
	"Method": "Map getProverStatuses(){\r\n    return proverStatuses;\r\n}"
}, {
	"Path": "teammates.common.datatransfer.InstructorPrivileges.validatePrivileges",
	"Comment": "validates the privileges in course level, section level and session level.makes sure there is nothing wrong with privileges hierarchy by adding theprerequisite privileges if they have not been granted yet.",
	"Method": "void validatePrivileges(){\r\n    if (this.courseLevel.getOrDefault(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS, false)) {\r\n        this.courseLevel.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS, true);\r\n    }\r\n    for (Map<String, Boolean> sectionMap : this.sectionLevel.values()) {\r\n        if (sectionMap.getOrDefault(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS, false)) {\r\n            sectionMap.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS, true);\r\n        }\r\n    }\r\n    for (Map<String, Map<String, Boolean>> section : this.sessionLevel.values()) {\r\n        for (Map<String, Boolean> sessionMap : section.values()) {\r\n            if (sessionMap.getOrDefault(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS, false)) {\r\n                sessionMap.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS, true);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.storage.api.FeedbackResponseCommentsDb.putDocuments",
	"Comment": "batch creates or updates search documents for the given comments",
	"Method": "void putDocuments(List<FeedbackResponseCommentAttributes> comments){\r\n    List<SearchDocument> frcSearchDocuments = new ArrayList();\r\n    for (FeedbackResponseCommentAttributes comment : comments) {\r\n        frcSearchDocuments.add(new FeedbackResponseCommentSearchDocument(comment));\r\n    }\r\n    putDocuments(Const.SearchIndex.FEEDBACK_RESPONSE_COMMENT, frcSearchDocuments);\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.clearAndSetNewValueForTinyMce",
	"Comment": "simulates the clearing and setting of value for a tinymce editor. this method is a legacy helper for filling rich texteditors and should not be used unless necessary.",
	"Method": "void clearAndSetNewValueForTinyMce(String id,String preparedContent){\r\n    executeScript(\"tinyMCE.get(arguments[0]).setContent('');\" + \"tinyMCE.get(arguments[0]).insertContent(arguments[1]);\" + \"tinyMCE.get(arguments[0]).focus();\", id, preparedContent);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.view.CircularProgressBar.interpolateSpeed",
	"Comment": "get the speed of the animation that we want based on the current sweep angle, needs a normal distribution",
	"Method": "float interpolateSpeed(float sweepAngle){\r\n    double increase = getUnstableIncrease();\r\n    double speed = (increase * Math.pow(e, -1 * pi * Math.pow(sweepAngle / 100 - 1.5, 2))) + increase;\r\n    return (float) speed;\r\n}"
}, {
	"Path": "tla2sany.semantic.InstanceNode.getChildren",
	"Comment": "the children of an instance are the expressions beingssubstituted for parameters.",
	"Method": "SemanticNode[] getChildren(){\r\n    SemanticNode[] res = new SemanticNode[substs.length];\r\n    for (int i = 0; i < substs.length; i++) {\r\n        res[i] = substs[i].getExpr();\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.output.data.ObligationStatus.getObligationString",
	"Comment": "returns the pretty printed form of the obligation. thiscan be null if the obligation string has not been sent.",
	"Method": "String getObligationString(){\r\n    return obligationString;\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackQuestionsLogic.areQuestionNumbersConsistent",
	"Comment": "todo can be removed once we are sure that question numbers will be consistent",
	"Method": "boolean areQuestionNumbersConsistent(List<FeedbackQuestionAttributes> questions){\r\n    Set<Integer> questionNumbersInSession = new HashSet();\r\n    for (FeedbackQuestionAttributes question : questions) {\r\n        if (!questionNumbersInSession.add(question.questionNumber)) {\r\n            return false;\r\n        }\r\n    }\r\n    for (int i = 1; i <= questions.size(); i++) {\r\n        if (!questionNumbersInSession.contains(i)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "tlc2.tool.CheckImpl.generateNewTrace",
	"Comment": "generate a trace ending with an uncovered state. returnsnull if there is no more uncovered state in the currentstate space.",
	"Method": "TLCStateInfo[] generateNewTrace(){\r\n    long pos = -1;\r\n    while ((pos = this.stateEnum.nextPos()) != -1) {\r\n        long fp = this.stateEnum.nextFP();\r\n        if (!this.coverSet.contains(fp)) {\r\n            return this.trace.getTrace(pos, true);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "tlc2.tool.liveness.LiveCheck1.addInitState",
	"Comment": "this method adds new nodes into the behavior graph when a new initial\tstate is generated.",
	"Method": "void addInitState(TLCState state,long stateFP){\r\n    for (int soln = 0; soln < solutions.length; soln++) {\r\n        OrderOfSolution os = solutions[soln];\r\n        BEGraph bgraph = bgraphs[soln];\r\n        int slen = os.getCheckState().length;\r\n        int alen = os.getCheckAction().length;\r\n        boolean[] checkStateRes = os.checkState(state);\r\n        boolean[] checkActionRes = os.checkAction(state, state);\r\n        if (!os.hasTableau()) {\r\n            BEGraphNode node = new BEGraphNode(stateFP);\r\n            node.setCheckState(checkStateRes);\r\n            bgraph.addInitNode(node);\r\n            node.addTransition(node, slen, alen, checkActionRes);\r\n            bgraph.allNodes.putBENode(node);\r\n        } else {\r\n            int initCnt = os.getTableau().getInitCnt();\r\n            for (int i = 0; i < initCnt; i++) {\r\n                TBGraphNode tnode = os.getTableau().getNode(i);\r\n                if (tnode.isConsistent(state, myTool)) {\r\n                    BTGraphNode destNode = new BTGraphNode(stateFP, tnode.getIndex());\r\n                    destNode.setCheckState(checkStateRes);\r\n                    bgraph.addInitNode(destNode);\r\n                    bgraph.allNodes.putBTNode(destNode);\r\n                    addNodesForStut(state, stateFP, destNode, checkStateRes, checkActionRes, os, bgraph);\r\n                }\r\n            }\r\n        }\r\n        bgraph.allNodes.setDone(stateFP);\r\n    }\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.waitForConfirmationModalAndClickOk",
	"Comment": "waits for a confirmation modal to appear and click the confirm button.",
	"Method": "void waitForConfirmationModalAndClickOk(){\r\n    waitForModalShown();\r\n    WebElement okayButton = browser.driver.findElement(By.className(\"modal-btn-ok\"));\r\n    waitForElementToBeClickable(okayButton);\r\n    clickDismissModalButtonAndWaitForModalHidden(okayButton);\r\n}"
}, {
	"Path": "org.springframework.roo.classpath.details.AbstractMemberHoldingTypeDetailsBuilder.removeExtendsTypes",
	"Comment": "ensures that the type being built does not extend any of the given types",
	"Method": "void removeExtendsTypes(JavaType superTypes){\r\n    extendsTypes.removeAll(Arrays.asList(superTypes));\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.output.data.ColorPredicate.satisfiedByObligations",
	"Comment": "returns true iff this color predicate is satisfied by a set ofobligations whose states have the numbers in the arrayobligationstatenumbers.",
	"Method": "boolean satisfiedByObligations(int[] obligationStateNumbers){\r\n    boolean[] childValues = new boolean[obligationStateNumbers.length];\r\n    for (int i = 0; i < obligationStateNumbers.length; i++) {\r\n        long bit = 1L << obligationStateNumbers[i];\r\n        childValues[i] = (bit & this.set) != 0;\r\n    }\r\n    return this.satisfiedBasedOnChildrenValues(childValues);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.util.ProverHelper.clearObligationMarkers",
	"Comment": "removes all markers indicating obligation information ona resource. doesnothing if the resource does not exist. it deletes these markers only at one levelunder the resource. that is, if the resource is a directory, it deletes markerson its children.",
	"Method": "void clearObligationMarkers(IResource resource){\r\n    if (resource.exists()) {\r\n        resource.deleteMarkers(OBLIGATION_MARKER, false, IResource.DEPTH_ONE);\r\n    }\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.plugins.pict.QuickTime.getDecompressor",
	"Comment": "gets a decompressor that can decompress the described data.",
	"Method": "QTDecompressor getDecompressor(ImageDesc pDescription){\r\n    for (QTDecompressor decompressor : sDecompressors) {\r\n        if (decompressor.canDecompress(pDescription)) {\r\n            return decompressor;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "util.BufferedDataInputStream.readLong",
	"Comment": "reads and returns the next long valueencoded in the next eight bytes of this stream, orthrows eofexception if the stream containsfewer than eight bytes.",
	"Method": "long readLong(){\r\n    this.readFully(this.temp, 0, 8);\r\n    long res = temp[0];\r\n    res <<= 8;\r\n    res |= (temp[1] & 0xff);\r\n    res <<= 8;\r\n    res |= (temp[2] & 0xff);\r\n    res <<= 8;\r\n    res |= (temp[3] & 0xff);\r\n    res <<= 8;\r\n    res |= (temp[4] & 0xff);\r\n    res <<= 8;\r\n    res |= (temp[5] & 0xff);\r\n    res <<= 8;\r\n    res |= (temp[6] & 0xff);\r\n    res <<= 8;\r\n    res |= (temp[7] & 0xff);\r\n    return res;\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.isOpenOrPublishedEmailSentForTheCourse",
	"Comment": "returns true if there is some open or published email sent for the course.",
	"Method": "boolean isOpenOrPublishedEmailSentForTheCourse(String courseId){\r\n    List<FeedbackSessionAttributes> sessions = getFeedbackSessionsForCourse(courseId);\r\n    for (FeedbackSessionAttributes session : sessions) {\r\n        if (session.isSentOpenEmail() || session.isSentPublishedEmail()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "teammates.logic.api.Logic.restoreCourseFromRecycleBin",
	"Comment": "restores a course and all data related to the course from recycle bin byits given corresponding id.",
	"Method": "void restoreCourseFromRecycleBin(String courseId){\r\n    Assumption.assertNotNull(courseId);\r\n    coursesLogic.restoreCourseFromRecycleBin(courseId);\r\n}"
}, {
	"Path": "tlc2.tool.Worker.run",
	"Comment": "this method gets a state from the queue, generates all thepossible next states of the state, checks the invariants, andupdates the state set and state queue.",
	"Method": "void run(){\r\n    TLCState curState = null;\r\n    try {\r\n        while (true) {\r\n            curState = (TLCState) this.squeue.sDequeue();\r\n            if (curState == null) {\r\n                synchronized (this.tlc) {\r\n                    this.tlc.setDone();\r\n                    this.tlc.notify();\r\n                }\r\n                this.squeue.finishAll();\r\n                return;\r\n            }\r\n            setCurrentState(curState);\r\n            if (this.tlc.doNext(curState, this.astCounts, this)) {\r\n                return;\r\n            }\r\n        }\r\n    } catch (Throwable e) {\r\n        resetCurrentState();\r\n        synchronized (this.tlc) {\r\n            if (this.tlc.setErrState(curState, null, true)) {\r\n                MP.printError(EC.GENERAL, e);\r\n            }\r\n            this.squeue.finishAll();\r\n            this.tlc.notify();\r\n        }\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.show",
	"Comment": "animates the actionbutton onto the screen so that the user may interact.animation occurs from the bottom of the screen, moving up until it reaches theappropriate distance from the bottom.",
	"Method": "void show(){\r\n    if (isShowing) {\r\n        return;\r\n    }\r\n    isShowing = true;\r\n    if (dontShow) {\r\n        return;\r\n    }\r\n    final Activity activity = (Activity) getContext();\r\n    ViewGroup.LayoutParams params = new FrameLayout.LayoutParams(width, height);\r\n    this.setLayoutParams(params);\r\n    if (parent == null) {\r\n        parent = (FrameLayout) activity.findViewById(android.R.id.content);\r\n    }\r\n    try {\r\n        parent.addView(dim);\r\n    } catch (Exception e) {\r\n    }\r\n    try {\r\n        parent.addView(this);\r\n    } catch (Exception e) {\r\n    }\r\n    if (animStartTop == -1) {\r\n        setTranslationX(distanceFromLeft);\r\n        setTranslationY(distanceFromTop);\r\n        ObjectAnimator animator = ObjectAnimator.ofFloat(this, View.ALPHA, 0.0f, 1.0f);\r\n        animator.setDuration(fadeAnimationTime);\r\n        animator.start();\r\n    } else {\r\n        title.setVisibility(View.GONE);\r\n        content.setVisibility(View.GONE);\r\n        setTranslationX(animStartLeft);\r\n        setTranslationY(animStartTop);\r\n        ViewGroup.LayoutParams layoutParams = getLayoutParams();\r\n        layoutParams.width = 0;\r\n        layoutParams.height = Utils.toDP(5, getContext());\r\n        setLayoutParams(layoutParams);\r\n        ObjectAnimator alpha = ObjectAnimator.ofFloat(this, View.ALPHA, 0.0f, 1.0f);\r\n        ObjectAnimator xTranslation = ObjectAnimator.ofFloat(this, View.TRANSLATION_X, animStartLeft, distanceFromLeft);\r\n        final ObjectAnimator yTranslation = ObjectAnimator.ofFloat(this, View.TRANSLATION_Y, animStartTop, distanceFromTop);\r\n        ValueAnimator widthExpander = ValueAnimator.ofInt(0, width);\r\n        final ValueAnimator heightExpander = ValueAnimator.ofInt(0, height);\r\n        widthExpander.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r\n            @Override\r\n            public void onAnimationUpdate(ValueAnimator valueAnimator) {\r\n                int val = (Integer) valueAnimator.getAnimatedValue();\r\n                ViewGroup.LayoutParams layoutParams = getLayoutParams();\r\n                layoutParams.width = val;\r\n                setLayoutParams(layoutParams);\r\n            }\r\n        });\r\n        widthExpander.setDuration(realAnimationTime);\r\n        widthExpander.setInterpolator(INTERPOLATOR);\r\n        heightExpander.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r\n            @Override\r\n            public void onAnimationUpdate(ValueAnimator valueAnimator) {\r\n                int val = (Integer) valueAnimator.getAnimatedValue();\r\n                ViewGroup.LayoutParams layoutParams = getLayoutParams();\r\n                layoutParams.height = val;\r\n                setLayoutParams(layoutParams);\r\n            }\r\n        });\r\n        heightExpander.setDuration(realAnimationTime);\r\n        heightExpander.setInterpolator(INTERPOLATOR);\r\n        xTranslation.setDuration(realAnimationTime);\r\n        xTranslation.setInterpolator(INTERPOLATOR);\r\n        yTranslation.setDuration(realAnimationTime);\r\n        yTranslation.setInterpolator(INTERPOLATOR);\r\n        alpha.setDuration(realAnimationTime);\r\n        alpha.setInterpolator(INTERPOLATOR);\r\n        alpha.start();\r\n        xTranslation.start();\r\n        widthExpander.start();\r\n        yTranslation.start();\r\n        heightExpander.start();\r\n        new Handler().postDelayed(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n            }\r\n        }, longAnimationTime);\r\n        if (showTitle) {\r\n            new Handler().postDelayed(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    title.setVisibility(View.VISIBLE);\r\n                    ObjectAnimator animator = ObjectAnimator.ofFloat(title, View.ALPHA, 0.0f, FINAL_TITLE_ALPHA);\r\n                    animator.setDuration(fadeAnimationTime);\r\n                    animator.start();\r\n                }\r\n            }, realAnimationTime);\r\n        }\r\n        new Handler().postDelayed(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                content.setVisibility(View.VISIBLE);\r\n                ObjectAnimator animator = ObjectAnimator.ofFloat(content, View.ALPHA, 0.0f, 1.0f);\r\n                animator.setDuration(fadeAnimationTime);\r\n                animator.start();\r\n                if (PopupLayout.this instanceof WebPopupLayout) {\r\n                    new Handler().postDelayed(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            content.setVisibility(View.GONE);\r\n                            content.setVisibility(View.VISIBLE);\r\n                        }\r\n                    }, 200);\r\n                }\r\n            }\r\n        }, realAnimationTime + 200);\r\n    }\r\n    ObjectAnimator dimAnimator = ObjectAnimator.ofFloat(dim, View.ALPHA, 0.0f, FINAL_DIM_ALPHA);\r\n    dimAnimator.setDuration(fadeAnimationTime);\r\n    dimAnimator.start();\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.show",
	"Comment": "animates the actionbutton onto the screen so that the user may interact.animation occurs from the bottom of the screen, moving up until it reaches theappropriate distance from the bottom.",
	"Method": "void show(){\r\n    int val = (Integer) valueAnimator.getAnimatedValue();\r\n    ViewGroup.LayoutParams layoutParams = getLayoutParams();\r\n    layoutParams.width = val;\r\n    setLayoutParams(layoutParams);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.show",
	"Comment": "animates the actionbutton onto the screen so that the user may interact.animation occurs from the bottom of the screen, moving up until it reaches theappropriate distance from the bottom.",
	"Method": "void show(){\r\n    int val = (Integer) valueAnimator.getAnimatedValue();\r\n    ViewGroup.LayoutParams layoutParams = getLayoutParams();\r\n    layoutParams.height = val;\r\n    setLayoutParams(layoutParams);\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.show",
	"Comment": "animates the actionbutton onto the screen so that the user may interact.animation occurs from the bottom of the screen, moving up until it reaches theappropriate distance from the bottom.",
	"Method": "void show(){\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.show",
	"Comment": "animates the actionbutton onto the screen so that the user may interact.animation occurs from the bottom of the screen, moving up until it reaches theappropriate distance from the bottom.",
	"Method": "void show(){\r\n    title.setVisibility(View.VISIBLE);\r\n    ObjectAnimator animator = ObjectAnimator.ofFloat(title, View.ALPHA, 0.0f, FINAL_TITLE_ALPHA);\r\n    animator.setDuration(fadeAnimationTime);\r\n    animator.start();\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.show",
	"Comment": "animates the actionbutton onto the screen so that the user may interact.animation occurs from the bottom of the screen, moving up until it reaches theappropriate distance from the bottom.",
	"Method": "void show(){\r\n    content.setVisibility(View.VISIBLE);\r\n    ObjectAnimator animator = ObjectAnimator.ofFloat(content, View.ALPHA, 0.0f, 1.0f);\r\n    animator.setDuration(fadeAnimationTime);\r\n    animator.start();\r\n    if (PopupLayout.this instanceof WebPopupLayout) {\r\n        new Handler().postDelayed(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                content.setVisibility(View.GONE);\r\n                content.setVisibility(View.VISIBLE);\r\n            }\r\n        }, 200);\r\n    }\r\n}"
}, {
	"Path": "com.klinker.android.twitter_l.views.widgets.PopupLayout.show",
	"Comment": "animates the actionbutton onto the screen so that the user may interact.animation occurs from the bottom of the screen, moving up until it reaches theappropriate distance from the bottom.",
	"Method": "void show(){\r\n    content.setVisibility(View.GONE);\r\n    content.setVisibility(View.VISIBLE);\r\n}"
}, {
	"Path": "teammates.test.pageobjects.AppPage.selectDropdownByActualValue",
	"Comment": "selects the option by value and returns whether the dropdown value has changed.",
	"Method": "boolean selectDropdownByActualValue(WebElement element,String value){\r\n    Select select = new Select(element);\r\n    WebElement originalSelectedOption = select.getFirstSelectedOption();\r\n    select.selectByValue(value);\r\n    WebElement newSelectedOption = select.getFirstSelectedOption();\r\n    assertEquals(value, newSelectedOption.getAttribute(\"value\"));\r\n    return !newSelectedOption.equals(originalSelectedOption);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.ui.view.TLCErrorView.fill",
	"Comment": "fill data into the viewthis includes loading expressions into the trace explorer table.",
	"Method": "void fill(Model model,List<TLCError> problems,List<String> serializedInput){\r\n    traceExplorerComposite.getTableViewer().setInput(new Vector<Formula>());\r\n    FormHelper.setSerializedInput(traceExplorerComposite.getTableViewer(), serializedInput);\r\n    TLCError trace = null;\r\n    if (problems != null && !problems.isEmpty()) {\r\n        StringBuffer buffer = new StringBuffer();\r\n        for (int i = 0; i < problems.size(); i++) {\r\n            TLCError error = problems.get(i);\r\n            appendError(buffer, error);\r\n            if (error.hasTrace()) {\r\n                Assert.isTrue(trace == null, \"Two traces are provided. Unexpected. This is a bug\");\r\n                trace = error;\r\n            }\r\n        }\r\n        if (trace == null) {\r\n            trace = new TLCError();\r\n        }\r\n        IDocument document = errorViewer.getDocument();\r\n        try {\r\n            document.replace(0, document.getLength(), buffer.toString());\r\n            TLCUIHelper.setTLCLocationHyperlinks(errorViewer.getTextWidget());\r\n        } catch (BadLocationException e) {\r\n            TLCUIActivator.getDefault().logError(\"Error reporting the error \" + buffer.toString(), e);\r\n        }\r\n        TLCError oldTrace = (TLCError) variableViewer.getInput();\r\n        boolean isNewTrace = trace != null && oldTrace != null && !(trace == oldTrace);\r\n        if (isNewTrace) {\r\n            this.setTraceInput(trace);\r\n            traceExplorerComposite.changeExploreEnablement(true);\r\n        }\r\n        if (model.isSnapshot()) {\r\n            final String date = sdf.format(model.getSnapshotTimeStamp());\r\n            this.form.setText(model.getSnapshotFor().getName() + \" (\" + date + \")\");\r\n        } else {\r\n            this.form.setText(model.getName());\r\n        }\r\n    } else {\r\n        clear();\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.handler.NewSpecHandler.createModuleAndSpecInNonUIThread",
	"Comment": "this triggers a build which might even be blocked due to the jobscheduling rule, hence decouple and let the ui thread continue.",
	"Method": "void createModuleAndSpecInNonUIThread(String rootFilename,boolean importExisting,String specName){\r\n    Assert.isNotNull(rootFilename);\r\n    Assert.isNotNull(specName);\r\n    final Job job = new NewSpecHandlerJob(specName, rootFilename, importExisting);\r\n    job.schedule();\r\n}"
}, {
	"Path": "teammates.logic.core.InstructorsLogic.updateInstructorByGoogleId",
	"Comment": "update the name and email address of an instructor with the specific google id.",
	"Method": "void updateInstructorByGoogleId(String googleId,InstructorAttributes instructor){\r\n    Assumption.assertNotNull(\"Supplied parameter was null\", instructor);\r\n    coursesLogic.verifyCourseIsPresent(instructor.courseId);\r\n    verifyInstructorInDbAndCascadeEmailChange(googleId, instructor);\r\n    checkForUpdatingRespondents(instructor);\r\n    instructorsDb.updateInstructorByGoogleId(instructor);\r\n}"
}, {
	"Path": "teammates.logic.api.TaskQueuer.getTasksAdded",
	"Comment": "gets the tasks added to the queue.this method is used only for testing, where it is overridden.",
	"Method": "List<TaskWrapper> getTasksAdded(){\r\n    throw new UnsupportedOperationException(\"Method is used only for testing\");\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.plugins.bmp.BMPImageReaderTest.testReadWithSubsampleParamPixels",
	"Comment": "subsampling of the same data with an offset... should we deal with this in the reader? yes?",
	"Method": "void testReadWithSubsampleParamPixels(){\r\n    ImageReader reader = createReader();\r\n    TestData data = getTestData().get(19);\r\n    reader.setInput(data.getInputStream());\r\n    ImageReadParam param = reader.getDefaultReadParam();\r\n    BufferedImage image = null;\r\n    BufferedImage subsampled = null;\r\n    try {\r\n        image = reader.read(0, param);\r\n        param.setSourceSubsampling(2, 2, 0, 0);\r\n        subsampled = reader.read(0, param);\r\n    } catch (IOException e) {\r\n        failBecause(\"Image could not be read\", e);\r\n    }\r\n    assertSubsampledImageDataEquals(\"Subsampled image data does not match expected\", image, subsampled, param);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.preference.SWTFactory.showPreferencePage",
	"Comment": "this method allows us to open the preference dialog on the specific page, in this case the perspective page",
	"Method": "void showPreferencePage(Shell shell,String id,Object data){\r\n    PreferencesUtil.createPreferenceDialogOn(shell, id, new String[] { id }, data).open();\r\n}"
}, {
	"Path": "teammates.logic.api.EmailGenerator.getAdditionalContactInformationFragment",
	"Comment": "generates additional contact information for user email templates.",
	"Method": "String getAdditionalContactInformationFragment(CourseAttributes course){\r\n    return Templates.populateTemplate(EmailTemplates.FRAGMENT_SESSION_ADDITIONAL_CONTACT_INFORMATION, \"${coOwnersEmails}\", generateCoOwnersEmailsLine(course.getId()), \"${supportEmail}\", Config.SUPPORT_EMAIL);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.job.ProverJob.getEndLine",
	"Comment": "get the end line of the region to pass to the prover.if the level node has a proof, the end line is the end line of the proof. if thelevel node does not have a proof, the end line is the end line of the level node.",
	"Method": "int getEndLine(LevelNode nodeToProve){\r\n    if (nodeToProve instanceof TheoremNode && ((TheoremNode) nodeToProve).getProof() != null) {\r\n        return ((TheoremNode) nodeToProve).getProof().getLocation().endLine();\r\n    } else {\r\n        return nodeToProve.getLocation().endLine();\r\n    }\r\n}"
}, {
	"Path": "tlc2.tool.fp.MemFPSet.put",
	"Comment": "tests if the specified fingerprint is in this set.as a sideeffect, updates the set to contain the fingerprint.",
	"Method": "boolean put(long fp){\r\n    int index = (int) (fp & this.mask);\r\n    long[] list = this.table[index];\r\n    if (list != null) {\r\n        int listlen = list.length;\r\n        for (int i = 0; i < listlen; i++) {\r\n            if (list[i] == fp)\r\n                return true;\r\n        }\r\n    }\r\n    if (count >= threshold) {\r\n        rehash();\r\n        index = (int) (fp & this.mask);\r\n        list = this.table[index];\r\n    }\r\n    int len = (list == null ? 0 : list.length);\r\n    long[] newList = new long[len + 1];\r\n    if (list != null)\r\n        System.arraycopy(list, 0, newList, 0, len);\r\n    newList[len] = fp;\r\n    this.table[index] = newList;\r\n    this.count++;\r\n    return false;\r\n}"
}, {
	"Path": "teammates.logic.core.FeedbackSessionsLogic.getRemainingRowsInCsvFormat",
	"Comment": "generate rows of missing responses for the remaining possible givers and recipients.if for the prevgiver, possiblerecipientsforgiver is not empty,the remaining missing responses for the prevgiver will be generated first.",
	"Method": "StringBuilder getRemainingRowsInCsvFormat(FeedbackSessionResultsBundle results,Map.Entry<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> entry,FeedbackQuestionAttributes question,FeedbackQuestionDetails questionDetails,List<String> remainingPossibleGivers,List<String> possibleRecipientsForGiver,String prevGiver){\r\n    StringBuilder exportBuilder = new StringBuilder();\r\n    if (possibleRecipientsForGiver != null) {\r\n        exportBuilder.append(getRowsOfPossibleRecipientsInCsvFormat(results, question, questionDetails, possibleRecipientsForGiver, prevGiver));\r\n    }\r\n    removeParticipantIdentifierFromList(question.giverType, remainingPossibleGivers, prevGiver, results);\r\n    for (String possibleGiverWithNoResponses : remainingPossibleGivers) {\r\n        List<String> possibleRecipientsForRemainingGiver = results.getPossibleRecipients(entry.getKey(), possibleGiverWithNoResponses);\r\n        exportBuilder.append(getRowsOfPossibleRecipientsInCsvFormat(results, question, questionDetails, possibleRecipientsForRemainingGiver, possibleGiverWithNoResponses));\r\n    }\r\n    return exportBuilder;\r\n}"
}, {
	"Path": "tlc2.tool.liveness.TBPar.alphaTriples",
	"Comment": "the methods alphatriples and betatriples, given a positive closure,\tfigure out the alpha and beta triples. the way the algorithm works, by\tthe time we extract triples, it should already have been positively\tclosed. all junctions must have been binarified at this stage by\tmakebinary, otherwise it may give the wrong answer and crash.",
	"Method": "Vect alphaTriples(){\r\n    Vect ts = new Vect();\r\n    for (int i = 0; i < this.size(); i++) {\r\n        LiveExprNode ln = this.exprAt(i);\r\n        if (ln instanceof LNAll) {\r\n            ts.addElement(new TBTriple(ln, ((LNAll) ln).getBody(), new LNNext(ln)));\r\n        } else if (ln instanceof LNConj) {\r\n            LNConj lnc = (LNConj) ln;\r\n            ts.addElement(new TBTriple(lnc, lnc.getBody(0), lnc.getBody(1)));\r\n        }\r\n    }\r\n    return ts;\r\n}"
}, {
	"Path": "com.twelvemonkeys.util.ObjectAbstractTest.testCanonicalFullCollectionExists",
	"Comment": "tests serialization by comparing against a previously stored version in cvs.if the test object is serializable, confirm that a canonical form exists.",
	"Method": "void testCanonicalFullCollectionExists(){\r\n    if (supportsFullCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {\r\n        Object object = makeObject();\r\n        if (object instanceof Serializable) {\r\n            String name = getCanonicalFullCollectionName(object);\r\n            assertTrue(\"Canonical full collection (\" + name + \") is not in CVS\", new File(name).exists());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "teammates.common.datatransfer.questions.FeedbackRankRecipientsQuestionDetails.getStudentQuestionResultsStatisticsHtml",
	"Comment": "constructs results statistics for each student.statistics to student is only shown when visibility setting is permissive enoughi.e., if the ranks for all team members are in the results bundle.",
	"Method": "String getStudentQuestionResultsStatisticsHtml(String studentEmail,FeedbackQuestionAttributes question,FeedbackSessionResultsBundle bundle){\r\n    if (question.recipientType.isTeam() && (!question.showResponsesTo.contains(FeedbackParticipantType.RECEIVER) || !question.showResponsesTo.contains(FeedbackParticipantType.STUDENTS))) {\r\n        return \"\";\r\n    }\r\n    if (!question.recipientType.isTeam() && (!question.showResponsesTo.contains(FeedbackParticipantType.RECEIVER) || !question.showResponsesTo.contains(FeedbackParticipantType.OWN_TEAM_MEMBERS))) {\r\n        return \"\";\r\n    }\r\n    List<FeedbackResponseAttributes> allResponses = bundle.getActualUnsortedResponses(question);\r\n    Map<String, List<Integer>> recipientRanks = generateOptionRanksMapping(allResponses);\r\n    boolean isRecipientTypeTeam = question.recipientType == FeedbackParticipantType.TEAMS || question.recipientType == FeedbackParticipantType.OWN_TEAM;\r\n    String currentUserTeam = bundle.roster.getStudentForEmail(studentEmail).getTeam();\r\n    String currentUserIdentifier = isRecipientTypeTeam ? currentUserTeam : studentEmail;\r\n    List<Integer> ranksReceived = recipientRanks.get(currentUserIdentifier);\r\n    if (ranksReceived == null) {\r\n        return \"\";\r\n    }\r\n    Map<String, Integer> recipientOverallRank = generateNormalizedOverallRankMapping(recipientRanks);\r\n    Map<String, List<Integer>> recipientRanksExcludingSelf = getRecipientRanksExcludingSelf(allResponses);\r\n    Map<String, Integer> recipientOverallRankExceptSelf = generateNormalizedOverallRankMapping(recipientRanksExcludingSelf);\r\n    Map<String, Integer> recipientSelfRanks = generateSelfRankForEachRecipient(allResponses);\r\n    String ranksReceivedAsString = getListOfRanksReceivedAsString(ranksReceived);\r\n    String overallRank = Integer.toString(recipientOverallRank.get(currentUserIdentifier));\r\n    String name = bundle.getNameForEmail(currentUserIdentifier);\r\n    String overallRankExceptSelf = recipientOverallRankExceptSelf.containsKey(currentUserIdentifier) ? Integer.toString(recipientOverallRankExceptSelf.get(currentUserIdentifier)) : \"-\";\r\n    String selfRank = recipientSelfRanks.containsKey(currentUserIdentifier) ? Integer.toString(recipientSelfRanks.get(currentUserIdentifier)) : \"-\";\r\n    String fragments = Templates.populateTemplate(FormTemplates.RANK_RESULT_STATS_RECIPIENTFRAGMENT, Slots.RANK_OPTION_VALUE, SanitizationHelper.sanitizeForHtml(name), Slots.TEAM, SanitizationHelper.sanitizeForHtml(currentUserTeam), Slots.RANK_RECIEVED, ranksReceivedAsString, Slots.RANK_SELF, selfRank, Slots.RANK_OVERALL, overallRank, Slots.RANK_EXCLUDING_SELF_OVERALL, overallRankExceptSelf);\r\n    String statsTitle = isRecipientTypeTeam ? \"Summary of responses received by your team\" : \"Summary of responses received by you\";\r\n    return Templates.populateTemplate(FormTemplates.RANK_RESULT_RECIPIENT_STATS, Slots.SUMMARY_TITLE, statsTitle, Slots.RANK_OPTION_RECIPIENT_DISPLAY_NAME, \"Recipient\", Slots.FRAGMENTS, fragments);\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.ui.wizard.NewSpecWizardPage.importExisting",
	"Comment": "returns the user choice if the existing project files should be imported",
	"Method": "boolean importExisting(){\r\n    return importExisting.getSelection();\r\n}"
}, {
	"Path": "teammates.common.datatransfer.FeedbackSessionResultsBundle.isEmailOfPersonFromRoster",
	"Comment": "return true if the participantidentifier is an email of either a studentor instructor in the course roster. otherwise, return false.",
	"Method": "boolean isEmailOfPersonFromRoster(String participantIdentifier){\r\n    boolean isStudent = isParticipantIdentifierStudent(participantIdentifier);\r\n    boolean isInstructor = isParticipantIdentifierInstructor(participantIdentifier);\r\n    return isStudent || isInstructor;\r\n}"
}, {
	"Path": "com.twelvemonkeys.imageio.plugins.pict.QuickTime.decompress",
	"Comment": "decompresses the quicktime image data from the given stream.",
	"Method": "BufferedImage decompress(ImageInputStream pStream){\r\n    ImageDesc description = ImageDesc.read(pStream);\r\n    if (PICTImageReader.DEBUG) {\r\n        System.out.println(description);\r\n    }\r\n    QTDecompressor decompressor = getDecompressor(description);\r\n    if (decompressor == null) {\r\n        return null;\r\n    }\r\n    InputStream streamAdapter = IIOUtil.createStreamAdapter(pStream, description.dataSize);\r\n    try {\r\n        return decompressor.decompress(description, streamAdapter);\r\n    } finally {\r\n        streamAdapter.close();\r\n    }\r\n}"
}, {
	"Path": "tla2sany.semantic.LevelNode.getLevelElement",
	"Comment": "t.l. october 2014abstract method for subclasses of levelnode to add their information",
	"Method": "Element getLevelElement(Document doc,SymbolContext context){\r\n    throw new UnsupportedOperationException(\"xml export is not yet supported for: \" + getClass() + \" with toString: \" + toString(100));\r\n}"
}, {
	"Path": "teammates.client.scripts.util.LoopHelper.recordLoop",
	"Comment": "increments count and prints the count and message on system output when count is a multiple of printcycle.",
	"Method": "void recordLoop(){\r\n    count++;\r\n    if (count % printCycle == 0) {\r\n        System.out.printf(\"[%d] %s%n\", count, message);\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.dialog.LaunchProverDialog.okPressed",
	"Comment": "this method is called by eclipse when the user presses ok.the current state of the dialog is saved in preferencesso that it can be restored next time, and the pm is launchedwith the selected options.",
	"Method": "void okPressed(){\r\n    IPreferenceStore store = ProverUIActivator.getDefault().getPreferenceStore();\r\n    store.setValue(EXTRA_OPTIONS_KEY, extraOptionsText.getText());\r\n    store.setValue(TOOLBOX_MODE_KEY, toolboxMode.getSelection());\r\n    store.setValue(ISATOOL_KEY, isatool.getSelection());\r\n    store.setValue(STATUS_CHECK_KEY, noProving.getSelection());\r\n    store.setValue(ISACHECK_KEY, isacheck.getSelection());\r\n    store.setValue(NOISA_KEY, noisa.getSelection());\r\n    store.setValue(PARANOID_KEY, paranoid.getSelection());\r\n    store.setValue(FP_NORMAL_KEY, fpNormal.getSelection());\r\n    store.setValue(FP_FORGET_ALL_KEY, fpForgetAll.getSelection());\r\n    store.setValue(FP_FORGET_CURRENT_KEY, fpForgetCurrent.getSelection());\r\n    ArrayList command = new ArrayList();\r\n    if (isatool.getSelection()) {\r\n    } else if (isacheck.getSelection()) {\r\n        command.add(ITLAPMOptions.ISACHECK);\r\n    }\r\n    if (fpForgetAll.getSelection()) {\r\n        command.add(ITLAPMOptions.FORGET_ALL);\r\n    } else if (fpForgetCurrent.getSelection()) {\r\n        command.add(ITLAPMOptions.FORGET_CURRENT);\r\n    }\r\n    if (paranoid.isEnabled() && paranoid.getSelection()) {\r\n        command.add(ITLAPMOptions.PARANOID);\r\n    }\r\n    ProverHelper.setThreadsOption(command);\r\n    ProverHelper.setSolverOption(command);\r\n    ProverHelper.setSafeFPOption(command);\r\n    String extraOptions = extraOptionsText.getText();\r\n    StringBuilder argument = new StringBuilder();\r\n    int state = 0;\r\n    for (int j = 0; j < extraOptions.length(); j++) {\r\n        char c = extraOptions.charAt(j);\r\n        switch(state) {\r\n            case 0:\r\n                if (c == ' ') {\r\n                } else if (c == '\\'') {\r\n                    state = 2;\r\n                } else {\r\n                    argument.append(c);\r\n                    state = 1;\r\n                }\r\n                break;\r\n            case 1:\r\n                if (c == ' ') {\r\n                    command.add(argument.toString());\r\n                    argument.setLength(0);\r\n                    state = 0;\r\n                } else if (c == '\\'') {\r\n                    state = 2;\r\n                } else {\r\n                    argument.append(c);\r\n                }\r\n                break;\r\n            case 2:\r\n                if (c == '\\'') {\r\n                    state = 1;\r\n                } else {\r\n                    argument.append(c);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    if (state == 1 || state == 2) {\r\n        command.add(argument.toString());\r\n    }\r\n    TLAEditor editor = EditorUtil.getActiveTLAEditor();\r\n    Assert.isNotNull(editor, \"User attempted to run general prover dialog without a tla editor active. This is a bug.\");\r\n    ProverJob proverJob = new ProverJob(((FileEditorInput) editor.getEditorInput()).getFile(), ((ITextSelection) editor.getSelectionProvider().getSelection()).getOffset(), noProving.getSelection(), (String[]) command.toArray(new String[command.size()]), toolboxMode.getSelection());\r\n    proverJob.setUser(true);\r\n    proverJob.schedule();\r\n    super.okPressed();\r\n}"
}, {
	"Path": "teammates.ui.controller.Action.getRequestParamValue",
	"Comment": "returns null if the specified parameter was not found in the request.",
	"Method": "String getRequestParamValue(String paramName){\r\n    return HttpRequestHelper.getValueFromParamMap(requestParameters, paramName);\r\n}"
}, {
	"Path": "teammates.test.cases.browsertests.InstructorFeedbackSubmitPageUiTest.testQuestionTypesSubmitAction",
	"Comment": "tests the behavior of different question types. test response validation on client side as well, if any.",
	"Method": "void testQuestionTypesSubmitAction(){\r\n    ______TS(\"test submit actions for different question types.\");\r\n    testEssaySubmitAction();\r\n    testMcqSubmitAction();\r\n    testMsqSubmitAction();\r\n    testNumScaleSubmitAction();\r\n    testConstSumSubmitAction();\r\n    testContribSubmitAction();\r\n}"
}, {
	"Path": "tlc2.tool.liveness.LNEven.pushNeg",
	"Comment": "this method pushes a negation all the way down to the atoms. it is\tcurrently not used.",
	"Method": "LiveExprNode pushNeg(LiveExprNode pushNeg,boolean hasNeg){\r\n    if (hasNeg) {\r\n        return new LNAll(getBody().pushNeg(true));\r\n    } else {\r\n        return new LNEven(getBody().pushNeg(false));\r\n    }\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.tlc.traceexplorer.TraceExplorerHelper.getErrorOfOriginalTrace",
	"Comment": "returns the error that has a trace most recently produced by running model checkingon the config or null if none found.",
	"Method": "TLCError getErrorOfOriginalTrace(Model model){\r\n    TLCModelLaunchDataProvider originalTraceProvider = TLCOutputSourceRegistry.getModelCheckSourceRegistry().getProvider(model);\r\n    List<TLCError> errors = originalTraceProvider.getErrors();\r\n    if (errors != null) {\r\n        Iterator<TLCError> it = errors.iterator();\r\n        while (it.hasNext()) {\r\n            TLCError error = it.next();\r\n            if (error.hasTrace()) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "teammates.ui.controller.AdminExceptionTestAction.execute",
	"Comment": "this method throws an exception and redirects the user to an error pagedepending on the type of error in the user request.",
	"Method": "ActionResult execute(){\r\n    gateKeeper.verifyAdminPrivileges(account);\r\n    String error = getRequestParamValue(Const.ParamsNames.ERROR);\r\n    if (error.equals(AssertionError.class.getSimpleName())) {\r\n        throw new AssertionError(\"AssertionError Testing\");\r\n    } else if (error.equals(EntityDoesNotExistException.class.getSimpleName())) {\r\n        throw new EntityDoesNotExistException(\"EntityDoesNotExistException Testing\");\r\n    } else if (error.equals(UnauthorizedAccessException.class.getSimpleName())) {\r\n        throw new UnauthorizedAccessException(\"UnauthorizedAccessException Testing\");\r\n    } else if (error.equals(NullPointerException.class.getSimpleName())) {\r\n        throw new NullPointerException(\"NullPointerException Testing\");\r\n    } else if (error.equals(DeadlineExceededException.class.getSimpleName())) {\r\n        throw new DeadlineExceededException(\"DeadlineExceededException Testing\");\r\n    } else if (error.equals(NullPostParameterException.class.getSimpleName())) {\r\n        throw new NullPostParameterException(\"NullPostParameterException Testing\");\r\n    }\r\n    statusToAdmin = \"adminExceptionTest\";\r\n    return createRedirectResult(Const.ActionURIs.ADMIN_HOME_PAGE);\r\n}"
}, {
	"Path": "teammates.ui.pagedata.StudentFeedbackResultsPageData.createResponseTable",
	"Comment": "creates a feedback results responses table for a recipient.",
	"Method": "FeedbackResultsResponseTable createResponseTable(FeedbackQuestionAttributes question,List<FeedbackResponseAttributes> responsesBundleForRecipient,String recipientNameParam){\r\n    List<FeedbackResultsResponse> responses = new ArrayList();\r\n    FeedbackQuestionDetails questionDetails = question.getQuestionDetails();\r\n    String recipientName = removeAnonymousHash(recipientNameParam);\r\n    for (FeedbackResponseAttributes response : responsesBundleForRecipient) {\r\n        String giverName = bundle.getGiverNameForResponse(response);\r\n        String displayedGiverName;\r\n        boolean isUserGiver = student.email.equals(response.giver);\r\n        boolean isUserPartOfGiverTeam = student.team.equals(giverName);\r\n        if (question.giverType == FeedbackParticipantType.TEAMS && isUserPartOfGiverTeam) {\r\n            displayedGiverName = \"Your Team (\" + giverName + \")\";\r\n        } else if (isUserGiver) {\r\n            displayedGiverName = \"You\";\r\n        } else {\r\n            displayedGiverName = removeAnonymousHash(giverName);\r\n        }\r\n        boolean isUserRecipient = student.email.equals(response.recipient);\r\n        if (isUserGiver && !isUserRecipient) {\r\n            recipientName = bundle.getNameForEmail(response.recipient);\r\n        }\r\n        String answer = response.getResponseDetails().getAnswerHtmlStudentView(questionDetails);\r\n        List<FeedbackResponseCommentRow> comments = createStudentFeedbackResultsResponseComments(response.getId(), question);\r\n        responses.add(new FeedbackResultsResponse(displayedGiverName, answer, comments));\r\n    }\r\n    return new FeedbackResultsResponseTable(recipientName, responses);\r\n}"
}, {
	"Path": "teammates.logic.api.Logic.getSentAdminEmails",
	"Comment": "gets all admin emails that have been sent and not in trash bin.",
	"Method": "List<AdminEmailAttributes> getSentAdminEmails(){\r\n    return adminEmailsLogic.getSentAdminEmails();\r\n}"
}, {
	"Path": "com.twelvemonkeys.io.SeekableInputStreamAbstractTest.rangeEquals",
	"Comment": "test two arrays for range equality. that is, they contain the same elements for some specified range.",
	"Method": "boolean rangeEquals(byte[] pFirst,int pFirstOffset,byte[] pSecond,int pSecondOffset,int pLength){\r\n    if (pFirst == pSecond && pFirstOffset == pSecondOffset) {\r\n        return true;\r\n    }\r\n    if (pFirst == null || pSecond == null) {\r\n        return false;\r\n    }\r\n    if (pFirst.length < pFirstOffset + pLength || pSecond.length < pSecondOffset + pLength) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < pLength; i++) {\r\n        if (pFirst[pFirstOffset + i] != pSecond[pSecondOffset + i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.lamport.tla.toolbox.tool.prover.ui.util.ProverHelper.setThreadsOption",
	"Comment": "if the user has specified a number of threads preference of i,then adds the appropriate entries to the list command of arguments.",
	"Method": "void setThreadsOption(List<String> command){\r\n    String numThreadsText = ProverUIActivator.getDefault().getPreferenceStore().getString(ProverSecondPreferencePage.NUM_THREADS_KEY);\r\n    if (numThreadsText.trim().length() == 0) {\r\n        return;\r\n    }\r\n    command.add(ITLAPMOptions.THREADS);\r\n    command.add(numThreadsText);\r\n}"
}]