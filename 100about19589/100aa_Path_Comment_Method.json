[{
	"Path": "org.activiti.engine.test.api.v6.Activiti6Test.testProcessDefinitionTagCreated",
	"Comment": "simple test that checks if all databases have correcly added the process definition tag.",
	"Method": "void testProcessDefinitionTagCreated(){\r\n    ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery().singleResult();\r\n    assertNull(((ProcessDefinitionEntity) processDefinition).getEngineVersion());\r\n}"
}, {
	"Path": "org.activiti.engine.test.bpmn.subprocess.SubProcessTest.testNestedSimpleSubProcess",
	"Comment": "test case where the simple sub process of previous test cases is nested within another subprocess.",
	"Method": "void testNestedSimpleSubProcess(){\r\n    ProcessInstance pi = runtimeService.startProcessInstanceByKey(\"nestedSimpleSubProcess\", CollectionUtil.singletonMap(\"someVar\", \"abc\"));\r\n    runtimeService.deleteProcessInstance(pi.getId(), \"deleted\");\r\n    pi = runtimeService.startProcessInstanceByKey(\"nestedSimpleSubProcess\");\r\n    Task subProcessTask = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();\r\n    assertEquals(\"Task in subprocess\", subProcessTask.getName());\r\n    taskService.complete(subProcessTask.getId());\r\n    Task taskAfterSubProcesses = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();\r\n    assertNotNull(taskAfterSubProcesses);\r\n    assertEquals(\"Task after subprocesses\", taskAfterSubProcesses.getName());\r\n    taskService.complete(taskAfterSubProcesses.getId());\r\n    assertProcessEnded(pi.getId());\r\n}"
}, {
	"Path": "org.antlr.v4.tool.DOTGenerator.getDOT",
	"Comment": "return a string containing a dot description that, when displayed, will show the incoming state machine visually.all nodes reachable from startstate will be included.",
	"Method": "String getDOT(DFA dfa,boolean isLexer,String getDOT,ATNState startState,String getDOT,ATNState startState,boolean isLexer,String getDOT,ATNState startState,String[] ruleNames,boolean isLexer){\r\n    if (startState == null)\r\n        return null;\r\n    Set<ATNState> markedStates = new HashSet<ATNState>();\r\n    ST dot = stlib.getInstanceOf(\"atn\");\r\n    dot.add(\"startState\", startState.stateNumber);\r\n    dot.add(\"rankdir\", rankdir);\r\n    List<ATNState> work = new LinkedList<ATNState>();\r\n    work.add(startState);\r\n    while (!work.isEmpty()) {\r\n        ATNState s = work.get(0);\r\n        if (markedStates.contains(s)) {\r\n            work.remove(0);\r\n            continue;\r\n        }\r\n        markedStates.add(s);\r\n        if (s instanceof RuleStopState)\r\n            continue;\r\n        ST edgeST;\r\n        for (int i = 0; i < s.getNumberOfTransitions(); i++) {\r\n            Transition edge = s.transition(i);\r\n            if (edge instanceof RuleTransition) {\r\n                RuleTransition rr = ((RuleTransition) edge);\r\n                edgeST = stlib.getInstanceOf(\"edge\");\r\n                String label = \"<\" + ruleNames[rr.ruleIndex];\r\n                if (((RuleStartState) rr.target).isLeftRecursiveRule) {\r\n                    label += \"[\" + rr.precedence + \"]\";\r\n                }\r\n                label += \">\";\r\n                edgeST.add(\"label\", label);\r\n                edgeST.add(\"src\", \"s\" + s.stateNumber);\r\n                edgeST.add(\"target\", \"s\" + rr.followState.stateNumber);\r\n                edgeST.add(\"arrowhead\", arrowhead);\r\n                dot.add(\"edges\", edgeST);\r\n                work.add(rr.followState);\r\n                continue;\r\n            }\r\n            if (edge instanceof ActionTransition) {\r\n                edgeST = stlib.getInstanceOf(\"action-edge\");\r\n                edgeST.add(\"label\", getEdgeLabel(edge.toString()));\r\n            } else if (edge instanceof AbstractPredicateTransition) {\r\n                edgeST = stlib.getInstanceOf(\"edge\");\r\n                edgeST.add(\"label\", getEdgeLabel(edge.toString()));\r\n            } else if (edge.isEpsilon()) {\r\n                edgeST = stlib.getInstanceOf(\"epsilon-edge\");\r\n                edgeST.add(\"label\", getEdgeLabel(edge.toString()));\r\n                boolean loopback = false;\r\n                if (edge.target instanceof PlusBlockStartState) {\r\n                    loopback = s.equals(((PlusBlockStartState) edge.target).loopBackState);\r\n                } else if (edge.target instanceof StarLoopEntryState) {\r\n                    loopback = s.equals(((StarLoopEntryState) edge.target).loopBackState);\r\n                }\r\n                edgeST.add(\"loopback\", loopback);\r\n            } else if (edge instanceof AtomTransition) {\r\n                edgeST = stlib.getInstanceOf(\"edge\");\r\n                AtomTransition atom = (AtomTransition) edge;\r\n                String label = String.valueOf(atom.label);\r\n                if (isLexer)\r\n                    label = \"'\" + getEdgeLabel(new StringBuilder().appendCodePoint(atom.label).toString()) + \"'\";\r\n                else if (grammar != null)\r\n                    label = grammar.getTokenDisplayName(atom.label);\r\n                edgeST.add(\"label\", getEdgeLabel(label));\r\n            } else if (edge instanceof SetTransition) {\r\n                edgeST = stlib.getInstanceOf(\"edge\");\r\n                SetTransition set = (SetTransition) edge;\r\n                String label = set.label().toString();\r\n                if (isLexer)\r\n                    label = set.label().toString(true);\r\n                else if (grammar != null)\r\n                    label = set.label().toString(grammar.getVocabulary());\r\n                if (edge instanceof NotSetTransition)\r\n                    label = \"~\" + label;\r\n                edgeST.add(\"label\", getEdgeLabel(label));\r\n            } else if (edge instanceof RangeTransition) {\r\n                edgeST = stlib.getInstanceOf(\"edge\");\r\n                RangeTransition range = (RangeTransition) edge;\r\n                String label = range.label().toString();\r\n                if (isLexer)\r\n                    label = range.toString();\r\n                else if (grammar != null)\r\n                    label = range.label().toString(grammar.getVocabulary());\r\n                edgeST.add(\"label\", getEdgeLabel(label));\r\n            } else {\r\n                edgeST = stlib.getInstanceOf(\"edge\");\r\n                edgeST.add(\"label\", getEdgeLabel(edge.toString()));\r\n            }\r\n            edgeST.add(\"src\", \"s\" + s.stateNumber);\r\n            edgeST.add(\"target\", \"s\" + edge.target.stateNumber);\r\n            edgeST.add(\"arrowhead\", arrowhead);\r\n            if (s.getNumberOfTransitions() > 1) {\r\n                edgeST.add(\"transitionIndex\", i);\r\n            } else {\r\n                edgeST.add(\"transitionIndex\", false);\r\n            }\r\n            dot.add(\"edges\", edgeST);\r\n            work.add(edge.target);\r\n        }\r\n    }\r\n    for (ATNState s : markedStates) {\r\n        if (!(s instanceof RuleStopState))\r\n            continue;\r\n        ST st = stlib.getInstanceOf(\"stopstate\");\r\n        st.add(\"name\", \"s\" + s.stateNumber);\r\n        st.add(\"label\", getStateLabel(s));\r\n        dot.add(\"states\", st);\r\n    }\r\n    for (ATNState s : markedStates) {\r\n        if (s instanceof RuleStopState)\r\n            continue;\r\n        ST st = stlib.getInstanceOf(\"state\");\r\n        st.add(\"name\", \"s\" + s.stateNumber);\r\n        st.add(\"label\", getStateLabel(s));\r\n        st.add(\"transitions\", s.getTransitions());\r\n        dot.add(\"states\", st);\r\n    }\r\n    return dot.render();\r\n}"
}, {
	"Path": "com.facebook.buck.android.NativeLibraryMergeEnhancer.getRuleDependencies",
	"Comment": "calculates the actual target dependency edges between two merged libraries. returns them asstrings for printing.",
	"Method": "Set<Pair<String, String>> getRuleDependencies(BuildRuleResolver ruleResolver,Map<NativeLinkable, MergedNativeLibraryConstituents> linkableMembership,MergedNativeLibraryConstituents from,MergedNativeLibraryConstituents to){\r\n    Set<Pair<String, String>> buildTargets = new LinkedHashSet();\r\n    for (NativeLinkable sourceLinkable : from.getLinkables()) {\r\n        for (NativeLinkable targetLinkable : Iterables.concat(sourceLinkable.getNativeLinkableDeps(ruleResolver), sourceLinkable.getNativeLinkableExportedDeps(ruleResolver))) {\r\n            if (linkableMembership.get(targetLinkable) == to) {\r\n                buildTargets.add(new Pair(sourceLinkable.getBuildTarget().toString(), targetLinkable.getBuildTarget().toString()));\r\n            }\r\n        }\r\n    }\r\n    return buildTargets;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.ExecutionGraphUtil.isReachable",
	"Comment": "verifies if the element with the given source identifier can reach the element with the target identifier through following sequence flow.",
	"Method": "boolean isReachable(String processDefinitionId,String sourceElementId,String targetElementId,boolean isReachable,Process process,FlowNode sourceElement,FlowNode targetElement,Set<String> visitedElements){\r\n    if (sourceElement.getOutgoingFlows().size() == 0) {\r\n        visitedElements.add(sourceElement.getId());\r\n        FlowElementsContainer parentElement = process.findParent(sourceElement);\r\n        if (parentElement instanceof SubProcess) {\r\n            sourceElement = (SubProcess) parentElement;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    if (sourceElement.getId().equals(targetElement.getId())) {\r\n        return true;\r\n    }\r\n    visitedElements.add(sourceElement.getId());\r\n    List<SequenceFlow> sequenceFlows = sourceElement.getOutgoingFlows();\r\n    if (sequenceFlows != null && sequenceFlows.size() > 0) {\r\n        for (SequenceFlow sequenceFlow : sequenceFlows) {\r\n            String targetRef = sequenceFlow.getTargetRef();\r\n            FlowNode sequenceFlowTarget = (FlowNode) process.getFlowElement(targetRef, true);\r\n            if (sequenceFlowTarget != null && !visitedElements.contains(sequenceFlowTarget.getId())) {\r\n                boolean reachable = isReachable(process, sequenceFlowTarget, targetElement, visitedElements);\r\n                if (reachable) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.asynchttpclient.netty.request.NettyRequestSender.sendRequestWithCertainForceConnect",
	"Comment": "we know for sure if we have to force to connect or not, so we can build thehttprequest right away this reduces the probability of having a pooledchannel closed by the server by the time we build the request",
	"Method": "ListenableFuture<T> sendRequestWithCertainForceConnect(Request request,AsyncHandler<T> asyncHandler,NettyResponseFuture<T> future,ProxyServer proxyServer,boolean performConnectRequest){\r\n    NettyResponseFuture<T> newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, performConnectRequest);\r\n    Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);\r\n    return Channels.isChannelActive(channel) ? sendRequestWithOpenChannel(newFuture, asyncHandler, channel) : sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler);\r\n}"
}, {
	"Path": "org.apache.commons.net.ProtocolCommandSupport.getListenerCount",
	"Comment": "returns the number of protocolcommandlisteners currently registered.",
	"Method": "int getListenerCount(){\r\n    return __listeners.getListenerCount();\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.TypefaceProvider.getTypeface",
	"Comment": "returns a reference to the requested typeface, creating a new instance if none already exists",
	"Method": "Typeface getTypeface(Context context,IconSet iconSet){\r\n    String path = iconSet.fontPath().toString();\r\n    if (TYPEFACE_MAP.get(path) == null) {\r\n        final Typeface font = Typeface.createFromAsset(context.getAssets(), path);\r\n        TYPEFACE_MAP.put(path, font);\r\n    }\r\n    return TYPEFACE_MAP.get(path);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONTokener.nextString",
	"Comment": "return the characters up to the next close quote character. backslash processing is done. the formal json format does not allow strings in single quotes, but an implementation is allowed toaccept them.",
	"Method": "String nextString(char quote){\r\n    char c;\r\n    StringBuilder sb = new StringBuilder();\r\n    for (; ; ) {\r\n        c = next();\r\n        switch(c) {\r\n            case 0:\r\n            case '\\n':\r\n            case '\\r':\r\n                throw syntaxError(\"Unterminated string\");\r\n            case '\\\\':\r\n                c = next();\r\n                switch(c) {\r\n                    case 'b':\r\n                        sb.append('\\b');\r\n                        break;\r\n                    case 't':\r\n                        sb.append('\\t');\r\n                        break;\r\n                    case 'n':\r\n                        sb.append('\\n');\r\n                        break;\r\n                    case 'f':\r\n                        sb.append('\\f');\r\n                        break;\r\n                    case 'r':\r\n                        sb.append('\\r');\r\n                        break;\r\n                    case 'u':\r\n                        sb.append((char) Integer.parseInt(next(4), 16));\r\n                        break;\r\n                    case '\"':\r\n                    case '\\'':\r\n                    case '\\\\':\r\n                    case '/':\r\n                        sb.append(c);\r\n                        break;\r\n                    default:\r\n                        throw syntaxError(\"Illegal escape.\");\r\n                }\r\n                break;\r\n            default:\r\n                if (c == quote) {\r\n                    return sb.toString();\r\n                }\r\n                sb.append(c);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.auto.value.processor.BuilderMethodClassifier.classify",
	"Comment": "classifies the given methods from a builder type and its ancestors.",
	"Method": "Optional<BuilderMethodClassifier> classify(Iterable<ExecutableElement> methods,ErrorReporter errorReporter,ProcessingEnvironment processingEnv,TypeElement autoValueClass,TypeElement builderType,ImmutableBiMap<ExecutableElement, String> getterToPropertyName,boolean autoValueHasToBuilder){\r\n    BuilderMethodClassifier classifier = new BuilderMethodClassifier(errorReporter, processingEnv, autoValueClass, builderType, getterToPropertyName);\r\n    if (classifier.classifyMethods(methods, autoValueHasToBuilder)) {\r\n        return Optional.of(classifier);\r\n    } else {\r\n        return Optional.empty();\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONWriter.key",
	"Comment": "append a key. the key will be associated with the next value. in an object, every value must be preceded by a key.",
	"Method": "JSONWriter key(String s){\r\n    if (s == null) {\r\n        throw new JSONException(\"Null key.\");\r\n    }\r\n    if (this.mode == 'k') {\r\n        try {\r\n            stack[top - 1].putOnce(s, Boolean.TRUE);\r\n            if (this.comma) {\r\n                this.writer.write(',');\r\n            }\r\n            this.writer.write(JSONObject.quote(s));\r\n            this.writer.write(':');\r\n            this.comma = false;\r\n            this.mode = 'o';\r\n            return this;\r\n        } catch (IOException e) {\r\n            throw new JSONException(e);\r\n        }\r\n    }\r\n    throw new JSONException(\"Misplaced key.\");\r\n}"
}, {
	"Path": "com.google.auto.value.processor.AutoAnnotationErrorsTest.testSameNameDifferentPackagesDoesNotTriggerOverload",
	"Comment": "this verifies that implementations in different packages work correctly.",
	"Method": "void testSameNameDifferentPackagesDoesNotTriggerOverload(){\r\n    JavaFileObject fooTestSource = JavaFileObjects.forSourceLines(\"com.foo.Test\", \"package com.foo;\", \"\", \"import com.example.TestAnnotation;\", \"import com.google.auto.value.AutoAnnotation;\", \"\", \"class Test {\", \"  @AutoAnnotation static TestAnnotation newTestAnnotation(int value) {\", \"    return new AutoAnnotation_Test_newTestAnnotation(value);\", \"  }\", \"}\");\r\n    JavaFileObject barTestSource = JavaFileObjects.forSourceLines(\"com.bar.Test\", \"package com.bar;\", \"\", \"import com.example.TestAnnotation;\", \"import com.google.auto.value.AutoAnnotation;\", \"\", \"class Test {\", \"  @AutoAnnotation static TestAnnotation newTestAnnotation(int value) {\", \"    return new AutoAnnotation_Test_newTestAnnotation(value);\", \"  }\", \"}\");\r\n    assert_().about(javaSources()).that(ImmutableList.of(TEST_ANNOTATION, fooTestSource, barTestSource)).processedWith(new AutoAnnotationProcessor()).compilesWithoutError();\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetCommand.getCommand",
	"Comment": "returns the string representation of the telnet protocol commandcorresponding to the given command code.",
	"Method": "String getCommand(int code){\r\n    return __commandString[__FIRST_COMMAND - code];\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.event.SignalThrowingEventListenerTest.testThrowSignalInRolledbackTransaction",
	"Comment": "test signal throwing when a job failed, signaling will happen in the rolled back transaction, not doing anything in the end...",
	"Method": "void testThrowSignalInRolledbackTransaction(){\r\n    SignalThrowingEventListener listener = null;\r\n    try {\r\n        listener = new SignalThrowingEventListener();\r\n        listener.setSignalName(\"Signal\");\r\n        listener.setProcessInstanceScope(true);\r\n        processEngineConfiguration.getEventDispatcher().addEventListener(listener, ActivitiEventType.JOB_EXECUTION_FAILURE);\r\n        ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(\"testSignal\");\r\n        assertNotNull(processInstance);\r\n        Job signalJob = managementService.createJobQuery().processInstanceId(processInstance.getId()).singleResult();\r\n        try {\r\n            managementService.executeJob(signalJob.getId());\r\n            fail(\"Exception expected\");\r\n        } catch (ActivitiException ae) {\r\n        }\r\n        Job failedJob = managementService.createTimerJobQuery().withException().processInstanceId(processInstance.getId()).singleResult();\r\n        assertNotNull(\"Expected job with exception, found no such job\", failedJob);\r\n        assertEquals(2, failedJob.getRetries());\r\n        assertEquals(0, taskService.createTaskQuery().processInstanceId(processInstance.getId()).count());\r\n        try {\r\n            managementService.moveTimerToExecutableJob(failedJob.getId());\r\n            managementService.executeJob(failedJob.getId());\r\n            fail(\"Exception expected\");\r\n        } catch (ActivitiException ae) {\r\n            assertEquals(0, taskService.createTaskQuery().processInstanceId(processInstance.getId()).count());\r\n        }\r\n    } finally {\r\n        processEngineConfiguration.getEventDispatcher().removeEventListener(listener);\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.ProcessEngines.retry",
	"Comment": "retries to initialize a process engine that previously failed.",
	"Method": "ProcessEngineInfo retry(String resourceUrl){\r\n    log.debug(\"retying initializing of resource {}\", resourceUrl);\r\n    try {\r\n        return initProcessEngineFromResource(new URL(resourceUrl));\r\n    } catch (MalformedURLException e) {\r\n        throw new ActivitiIllegalArgumentException(\"invalid url: \" + resourceUrl, e);\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.HTTPTokener.nextToken",
	"Comment": "get the next token or string. this is used in parsing http headers.",
	"Method": "String nextToken(){\r\n    char c;\r\n    char q;\r\n    StringBuilder sb = new StringBuilder();\r\n    do {\r\n        c = next();\r\n    } while (Character.isWhitespace(c));\r\n    if (c == '\"' || c == '\\'') {\r\n        q = c;\r\n        for (; ; ) {\r\n            c = next();\r\n            if (c < ' ') {\r\n                throw syntaxError(\"Unterminated string.\");\r\n            }\r\n            if (c == q) {\r\n                return sb.toString();\r\n            }\r\n            sb.append(c);\r\n        }\r\n    }\r\n    for (; ; ) {\r\n        if (c == 0 || Character.isWhitespace(c)) {\r\n            return sb.toString();\r\n        }\r\n        sb.append(c);\r\n        c = next();\r\n    }\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.atn.PredictionContextCache.add",
	"Comment": "add a context to the cache and return it. if the context already exists,\t return that one instead and do not add a new context to the cache.\t protect shared cache from unsafe thread access.",
	"Method": "PredictionContext add(PredictionContext ctx){\r\n    if (ctx == PredictionContext.EMPTY)\r\n        return PredictionContext.EMPTY;\r\n    PredictionContext existing = cache.get(ctx);\r\n    if (existing != null) {\r\n        return existing;\r\n    }\r\n    cache.put(ctx, ctx);\r\n    return ctx;\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetInputStream.__read",
	"Comment": "get the next byte of data.iac commands are processed internally and do not return data.",
	"Method": "int __read(boolean mayBlock){\r\n    int ch;\r\n    while (true) {\r\n        if (!mayBlock && super.available() == 0) {\r\n            return WOULD_BLOCK;\r\n        }\r\n        if ((ch = super.read()) < 0) {\r\n            return EOF;\r\n        }\r\n        ch = (ch & 0xff);\r\n        synchronized (__client) {\r\n            __client._processAYTResponse();\r\n        }\r\n        __client._spyRead(ch);\r\n        switch(__receiveState) {\r\n            case _STATE_CR:\r\n                if (ch == '\\0') {\r\n                    continue;\r\n                }\r\n            case _STATE_DATA:\r\n                if (ch == TelnetCommand.IAC) {\r\n                    __receiveState = _STATE_IAC;\r\n                    continue;\r\n                }\r\n                if (ch == '\\r') {\r\n                    synchronized (__client) {\r\n                        if (__client._requestedDont(TelnetOption.BINARY)) {\r\n                            __receiveState = _STATE_CR;\r\n                        } else {\r\n                            __receiveState = _STATE_DATA;\r\n                        }\r\n                    }\r\n                } else {\r\n                    __receiveState = _STATE_DATA;\r\n                }\r\n                break;\r\n            case _STATE_IAC:\r\n                switch(ch) {\r\n                    case TelnetCommand.WILL:\r\n                        __receiveState = _STATE_WILL;\r\n                        continue;\r\n                    case TelnetCommand.WONT:\r\n                        __receiveState = _STATE_WONT;\r\n                        continue;\r\n                    case TelnetCommand.DO:\r\n                        __receiveState = _STATE_DO;\r\n                        continue;\r\n                    case TelnetCommand.DONT:\r\n                        __receiveState = _STATE_DONT;\r\n                        continue;\r\n                    case TelnetCommand.SB:\r\n                        __suboption_count = 0;\r\n                        __receiveState = _STATE_SB;\r\n                        continue;\r\n                    case TelnetCommand.IAC:\r\n                        __receiveState = _STATE_DATA;\r\n                        break;\r\n                    case TelnetCommand.SE:\r\n                        __receiveState = _STATE_DATA;\r\n                        continue;\r\n                    default:\r\n                        __receiveState = _STATE_DATA;\r\n                        __client._processCommand(ch);\r\n                        continue;\r\n                }\r\n                break;\r\n            case _STATE_WILL:\r\n                synchronized (__client) {\r\n                    __client._processWill(ch);\r\n                    __client._flushOutputStream();\r\n                }\r\n                __receiveState = _STATE_DATA;\r\n                continue;\r\n            case _STATE_WONT:\r\n                synchronized (__client) {\r\n                    __client._processWont(ch);\r\n                    __client._flushOutputStream();\r\n                }\r\n                __receiveState = _STATE_DATA;\r\n                continue;\r\n            case _STATE_DO:\r\n                synchronized (__client) {\r\n                    __client._processDo(ch);\r\n                    __client._flushOutputStream();\r\n                }\r\n                __receiveState = _STATE_DATA;\r\n                continue;\r\n            case _STATE_DONT:\r\n                synchronized (__client) {\r\n                    __client._processDont(ch);\r\n                    __client._flushOutputStream();\r\n                }\r\n                __receiveState = _STATE_DATA;\r\n                continue;\r\n            case _STATE_SB:\r\n                switch(ch) {\r\n                    case TelnetCommand.IAC:\r\n                        __receiveState = _STATE_IAC_SB;\r\n                        continue;\r\n                    default:\r\n                        if (__suboption_count < __suboption.length) {\r\n                            __suboption[__suboption_count++] = ch;\r\n                        }\r\n                        break;\r\n                }\r\n                __receiveState = _STATE_SB;\r\n                continue;\r\n            case _STATE_IAC_SB:\r\n                switch(ch) {\r\n                    case TelnetCommand.SE:\r\n                        synchronized (__client) {\r\n                            __client._processSuboption(__suboption, __suboption_count);\r\n                            __client._flushOutputStream();\r\n                        }\r\n                        __receiveState = _STATE_DATA;\r\n                        continue;\r\n                    case TelnetCommand.IAC:\r\n                        if (__suboption_count < __suboption.length) {\r\n                            __suboption[__suboption_count++] = ch;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n                __receiveState = _STATE_SB;\r\n                continue;\r\n        }\r\n        break;\r\n    }\r\n    return ch;\r\n}"
}, {
	"Path": "com.facebook.buck.apple.AppleDescriptions.getPlatformMatchingBinary",
	"Comment": "returns an optional binary target that matches the target platform.",
	"Method": "Optional<BuildTarget> getPlatformMatchingBinary(String targetPlatform,PatternMatchedCollection<BuildTarget> platformBinary){\r\n    ImmutableList<BuildTarget> matchingBinaries = platformBinary.getMatchingValues(targetPlatform);\r\n    if (matchingBinaries.size() > 1) {\r\n        throw new HumanReadableException(\"There must be at most one binary matching the target platform \" + targetPlatform + \" but all of \" + matchingBinaries + \" matched. Please make your pattern more precise and remove any duplicates.\");\r\n    }\r\n    return matchingBinaries.isEmpty() ? Optional.empty() : Optional.of(matchingBinaries.get(0));\r\n}"
}, {
	"Path": "com.google.auto.value.processor.ErrorReporter.abortWithError",
	"Comment": "issue a compilation error and abandon the processing of this class. this does not prevent theprocessing of other classes.",
	"Method": "void abortWithError(String msg,Element e){\r\n    reportError(msg, e);\r\n    throw new AbortProcessingException();\r\n}"
}, {
	"Path": "com.facebook.buck.android.NativeLibraryMergeEnhancer.createLinkables",
	"Comment": "create the final linkables that will be passed to the later stages of graph enhancement.",
	"Method": "Set<MergedLibNativeLinkable> createLinkables(CellPathResolver cellPathResolver,CxxBuckConfig cxxBuckConfig,ActionGraphBuilder graphBuilder,SourcePathResolver pathResolver,SourcePathRuleFinder ruleFinder,BuildTarget baseBuildTarget,ProjectFilesystem projectFilesystem,Optional<NativeLinkable> glueLinkable,Optional<ImmutableSortedSet<String>> symbolsToLocalize,Iterable<MergedNativeLibraryConstituents> orderedConstituents){\r\n    Map<NativeLinkable, MergedLibNativeLinkable> mergeResults = new HashMap();\r\n    for (MergedNativeLibraryConstituents constituents : orderedConstituents) {\r\n        ImmutableCollection<NativeLinkable> preMergeLibs = constituents.getLinkables();\r\n        List<MergedLibNativeLinkable> orderedDeps = getStructuralDeps(constituents, x -> x.getNativeLinkableDeps(graphBuilder), mergeResults);\r\n        List<MergedLibNativeLinkable> orderedExportedDeps = getStructuralDeps(constituents, x -> x.getNativeLinkableExportedDeps(graphBuilder), mergeResults);\r\n        ProjectFilesystem targetProjectFilesystem = projectFilesystem;\r\n        if (!constituents.isActuallyMerged()) {\r\n            BuildTarget target = preMergeLibs.iterator().next().getBuildTarget();\r\n            if (!target.getCellPath().equals(projectFilesystem.getRootPath())) {\r\n                targetProjectFilesystem = graphBuilder.getRule(target).getProjectFilesystem();\r\n            }\r\n        }\r\n        MergedLibNativeLinkable mergedLinkable = new MergedLibNativeLinkable(cellPathResolver, cxxBuckConfig, graphBuilder, pathResolver, ruleFinder, baseBuildTarget, targetProjectFilesystem, constituents, orderedDeps, orderedExportedDeps, glueLinkable, symbolsToLocalize);\r\n        for (NativeLinkable lib : preMergeLibs) {\r\n            mergeResults.put(lib, mergedLinkable);\r\n        }\r\n    }\r\n    return ImmutableSortedSet.copyOf(Comparator.comparing(NativeLinkable::getBuildTarget), mergeResults.values());\r\n}"
}, {
	"Path": "org.activiti.engine.ProcessEngines.destroy",
	"Comment": "closes all process engines. this method should be called when the server shuts down.",
	"Method": "void destroy(){\r\n    if (isInitialized()) {\r\n        Map<String, ProcessEngine> engines = new HashMap<String, ProcessEngine>(processEngines);\r\n        processEngines = new HashMap<String, ProcessEngine>();\r\n        for (String processEngineName : engines.keySet()) {\r\n            ProcessEngine processEngine = engines.get(processEngineName);\r\n            try {\r\n                processEngine.close();\r\n            } catch (Exception e) {\r\n                log.error(\"exception while closing {}\", (processEngineName == null ? \"the default process engine\" : \"process engine \" + processEngineName), e);\r\n            }\r\n        }\r\n        processEngineInfosByName.clear();\r\n        processEngineInfosByResourceUrl.clear();\r\n        processEngineInfos.clear();\r\n        setInitialized(false);\r\n    }\r\n}"
}, {
	"Path": "org.asynchttpclient.request.body.multipart.MultipartUploadTest.testSentFile",
	"Comment": "test that the files were sent, based on the response from the servlet",
	"Method": "void testSentFile(List<String> expectedContents,List<File> sourceFiles,Response r,List<Boolean> deflate){\r\n    String content = r.getResponseBody();\r\n    assertNotNull(content);\r\n    logger.debug(content);\r\n    String[] contentArray = content.split(\"\\\\|\\\\|\");\r\n    assertEquals(contentArray.length, 2);\r\n    String tmpFiles = contentArray[1];\r\n    assertNotNull(tmpFiles);\r\n    assertTrue(tmpFiles.trim().length() > 2);\r\n    tmpFiles = tmpFiles.substring(1, tmpFiles.length() - 1);\r\n    String[] responseFiles = tmpFiles.split(\",\");\r\n    assertNotNull(responseFiles);\r\n    assertEquals(responseFiles.length, sourceFiles.size());\r\n    logger.debug(Arrays.toString(responseFiles));\r\n    int i = 0;\r\n    for (File sourceFile : sourceFiles) {\r\n        File tmp = null;\r\n        try {\r\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n            byte[] sourceBytes;\r\n            try (InputStream instream = Files.newInputStream(sourceFile.toPath())) {\r\n                byte[] buf = new byte[8092];\r\n                int len;\r\n                while ((len = instream.read(buf)) > 0) {\r\n                    baos.write(buf, 0, len);\r\n                }\r\n                logger.debug(\"================\");\r\n                logger.debug(\"Length of file: \" + baos.toByteArray().length);\r\n                logger.debug(\"Contents: \" + Arrays.toString(baos.toByteArray()));\r\n                logger.debug(\"================\");\r\n                System.out.flush();\r\n                sourceBytes = baos.toByteArray();\r\n            }\r\n            tmp = new File(responseFiles[i].trim());\r\n            logger.debug(\"==============================\");\r\n            logger.debug(tmp.getAbsolutePath());\r\n            logger.debug(\"==============================\");\r\n            System.out.flush();\r\n            assertTrue(tmp.exists());\r\n            byte[] bytes;\r\n            try (InputStream instream = Files.newInputStream(tmp.toPath())) {\r\n                ByteArrayOutputStream baos2 = new ByteArrayOutputStream();\r\n                byte[] buf = new byte[8092];\r\n                int len;\r\n                while ((len = instream.read(buf)) > 0) {\r\n                    baos2.write(buf, 0, len);\r\n                }\r\n                bytes = baos2.toByteArray();\r\n                assertEquals(bytes, sourceBytes);\r\n            }\r\n            if (!deflate.get(i)) {\r\n                String helloString = new String(bytes);\r\n                assertEquals(helloString, expectedContents.get(i));\r\n            } else {\r\n                try (InputStream instream = Files.newInputStream(tmp.toPath())) {\r\n                    ByteArrayOutputStream baos3 = new ByteArrayOutputStream();\r\n                    GZIPInputStream deflater = new GZIPInputStream(instream);\r\n                    try {\r\n                        byte[] buf3 = new byte[8092];\r\n                        int len3;\r\n                        while ((len3 = deflater.read(buf3)) > 0) {\r\n                            baos3.write(buf3, 0, len3);\r\n                        }\r\n                    } finally {\r\n                        deflater.close();\r\n                    }\r\n                    String helloString = new String(baos3.toByteArray());\r\n                    assertEquals(expectedContents.get(i), helloString);\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            fail(\"Download Exception\");\r\n        } finally {\r\n            if (tmp != null)\r\n                FileUtils.deleteQuietly(tmp);\r\n            i++;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.test.bpmn.subprocess.SubProcessTest.testDoubleNestedSimpleSubProcess",
	"Comment": "test case where the simple sub process of previous test cases is nested within two other sub processes",
	"Method": "void testDoubleNestedSimpleSubProcess(){\r\n    ProcessInstance pi = runtimeService.startProcessInstanceByKey(\"nestedSimpleSubProcess\");\r\n    Task subProcessTask = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();\r\n    assertEquals(\"Task in subprocess\", subProcessTask.getName());\r\n    taskService.complete(subProcessTask.getId());\r\n    Task taskAfterSubProcesses = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();\r\n    assertEquals(\"Task after subprocesses\", taskAfterSubProcesses.getName());\r\n}"
}, {
	"Path": "com.facebook.buck.apple.AppleLibraryDescriptionSwiftEnhancer.getPreprocessorInputsForAppleLibrary",
	"Comment": "returns transitive preprocessor inputs excluding those from the swift delegate of the givencxxlibrary.",
	"Method": "ImmutableSet<CxxPreprocessorInput> getPreprocessorInputsForAppleLibrary(BuildTarget target,ActionGraphBuilder graphBuilder,CxxPlatform platform,AppleNativeTargetDescriptionArg arg){\r\n    CxxLibrary lib = (CxxLibrary) graphBuilder.requireRule(target.withFlavors());\r\n    ImmutableMap<BuildTarget, CxxPreprocessorInput> transitiveMap = TransitiveCxxPreprocessorInputCache.computeTransitiveCxxToPreprocessorInputMap(platform, lib, false, graphBuilder);\r\n    ImmutableSet.Builder<CxxPreprocessorInput> builder = ImmutableSet.builder();\r\n    builder.addAll(transitiveMap.values());\r\n    if (arg.isModular()) {\r\n        Optional<CxxPreprocessorInput> underlyingModule = AppleLibraryDescription.underlyingModuleCxxPreprocessorInput(target, graphBuilder, platform);\r\n        underlyingModule.ifPresent(builder::add);\r\n    } else {\r\n        builder.add(lib.getPublicCxxPreprocessorInputExcludingDelegate(platform, graphBuilder));\r\n    }\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.facebook.buck.android.bundle.GenerateBundleConfigStep.createDefaultBundleConfig",
	"Comment": "this method creates a buildconfig with all fields built upon default setting",
	"Method": "BundleConfig createDefaultBundleConfig(){\r\n    Optimizations.Builder optimizations = Optimizations.newBuilder();\r\n    SplitsConfig.Builder splitsConfig = SplitsConfig.newBuilder();\r\n    for (int i = 1; i <= 3; i++) {\r\n        splitsConfig.addSplitDimension(SplitDimension.newBuilder().setValueValue(i).setNegate(i != 1).build());\r\n    }\r\n    optimizations.setSplitsConfig(splitsConfig.build());\r\n    return BundleConfig.newBuilder().setBundletool(Bundletool.newBuilder().build()).setOptimizations(optimizations.build()).setCompression(Compression.newBuilder().build()).build();\r\n}"
}, {
	"Path": "org.apache.commons.net.SocketClient.getCommandSupport",
	"Comment": "subclasses can override this if they need to provide their owninstance field for backwards compatibilty.",
	"Method": "ProtocolCommandSupport getCommandSupport(){\r\n    return __commandSupport;\r\n}"
}, {
	"Path": "com.google.auto.value.processor.BuilderMethodClassifier.classifyMethods",
	"Comment": "classifies the given methods and sets the state of this object based on what is found.",
	"Method": "boolean classifyMethods(Iterable<ExecutableElement> methods,boolean autoValueHasToBuilder){\r\n    boolean ok = true;\r\n    for (ExecutableElement method : methods) {\r\n        ok &= classifyMethod(method);\r\n    }\r\n    if (!ok) {\r\n        return false;\r\n    }\r\n    Multimap<String, ExecutableElement> propertyNameToSetter;\r\n    if (propertyNameToPrefixedSetters.isEmpty()) {\r\n        propertyNameToSetter = propertyNameToUnprefixedSetters;\r\n        this.settersPrefixed = false;\r\n    } else if (propertyNameToUnprefixedSetters.isEmpty()) {\r\n        propertyNameToSetter = propertyNameToPrefixedSetters;\r\n        this.settersPrefixed = true;\r\n    } else {\r\n        errorReporter.reportError(\"If any setter methods use the setFoo convention then all must\", propertyNameToUnprefixedSetters.values().iterator().next());\r\n        return false;\r\n    }\r\n    for (Map.Entry<ExecutableElement, String> getterEntry : getterToPropertyName.entrySet()) {\r\n        String property = getterEntry.getValue();\r\n        TypeMirror propertyType = getterEntry.getKey().getReturnType();\r\n        boolean hasSetter = propertyNameToSetter.containsKey(property);\r\n        PropertyBuilder propertyBuilder = propertyNameToPropertyBuilder.get(property);\r\n        boolean hasBuilder = propertyBuilder != null;\r\n        if (hasBuilder) {\r\n            boolean canMakeBarBuilder = (propertyBuilder.getBuiltToBuilder() != null || propertyBuilder.getCopyAll() != null);\r\n            boolean needToMakeBarBuilder = (autoValueHasToBuilder || hasSetter);\r\n            if (needToMakeBarBuilder && !canMakeBarBuilder) {\r\n                String error = String.format(\"Property builder method returns %1$s but there is no way to make that type from \" + \"%2$s: %2$s does not have a non-static toBuilder() method that returns %1$s\", propertyBuilder.getBuilderTypeMirror(), propertyType);\r\n                errorReporter.reportError(error, propertyBuilder.getPropertyBuilderMethod());\r\n            }\r\n        } else if (!hasSetter) {\r\n            String setterName = settersPrefixed ? prefixWithSet(property) : property;\r\n            String error = String.format(\"Expected a method with this signature: %s%s %s(%s), or a %sBuilder() method\", builderType, typeParamsString(), setterName, propertyType, property);\r\n            errorReporter.reportError(error, builderType);\r\n            ok = false;\r\n        }\r\n    }\r\n    return ok;\r\n}"
}, {
	"Path": "com.facebook.buck.android.support.exopackage.DelegatingClassLoader.setDexOptDir",
	"Comment": "provide an output dir where optimized dex file outputs can live. the file is assumed to alreadyexist and to be a directory",
	"Method": "DelegatingClassLoader setDexOptDir(File dexOptDir){\r\n    mDexOptDir = dexOptDir;\r\n    return this;\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.GLTextureView.getRenderMode",
	"Comment": "get the current rendering mode. may be calledfrom any thread. must not be called before a renderer has been set.",
	"Method": "int getRenderMode(int getRenderMode){\r\n    return glThread.getRenderMode();\r\n}"
}, {
	"Path": "com.facebook.buck.android.exopackage.RealAndroidDevice.deviceInstallPackageViaSd",
	"Comment": "installs apk on device, copying apk to external storage first.",
	"Method": "String deviceInstallPackageViaSd(String apk){\r\n    try {\r\n        String externalStorage = deviceGetExternalStorage();\r\n        if (externalStorage == null) {\r\n            return \"Cannot get external storage location.\";\r\n        }\r\n        String remotePackage = String.format(\"%s/%s.apk\", externalStorage, UUID.randomUUID());\r\n        device.pushFile(apk, remotePackage);\r\n        device.installRemotePackage(remotePackage, true);\r\n        device.removeRemotePackage(remotePackage);\r\n        return null;\r\n    } catch (Throwable t) {\r\n        return String.valueOf(t.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.cli.TestRunning.writeXmlOutput",
	"Comment": "writes the test results in xml format to the supplied writer.this method does not close the writer object.",
	"Method": "void writeXmlOutput(List<TestResults> allResults,Writer writer){\r\n    try {\r\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\r\n        DocumentBuilder docBuilder = dbf.newDocumentBuilder();\r\n        Document doc = docBuilder.newDocument();\r\n        Element testsEl = doc.createElement(\"tests\");\r\n        doc.appendChild(testsEl);\r\n        for (TestResults results : allResults) {\r\n            for (TestCaseSummary testCase : results.getTestCases()) {\r\n                Element testEl = doc.createElement(\"test\");\r\n                testEl.setAttribute(\"name\", testCase.getTestCaseName());\r\n                testEl.setAttribute(\"status\", testCase.isSuccess() ? \"PASS\" : \"FAIL\");\r\n                testEl.setAttribute(\"time\", Long.toString(testCase.getTotalTime()));\r\n                testEl.setAttribute(\"target\", results.getBuildTarget().getFullyQualifiedName());\r\n                testsEl.appendChild(testEl);\r\n                addExtraXmlInfo(testCase, testEl);\r\n            }\r\n        }\r\n        TransformerFactory tf = TransformerFactory.newInstance();\r\n        Transformer transformer = tf.newTransformer();\r\n        transformer.transform(new DOMSource(doc), new StreamResult(writer));\r\n    } catch (TransformerException | ParserConfigurationException ex) {\r\n        throw new IOException(\"Unable to build the XML document!\");\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.cli.TestRunning.getReportCommand",
	"Comment": "returns the shellcommand object that is supposed to generate a code coverage report from dataobtained during the test run. this method will also generate a set of source paths to the classfiles tested during the test run.",
	"Method": "Step getReportCommand(ImmutableSet<JavaLibrary> rulesUnderTest,DefaultJavaPackageFinder defaultJavaPackageFinder,Tool javaRuntimeLauncher,ProjectFilesystem filesystem,SourcePathResolver sourcePathResolver,SourcePathRuleFinder ruleFinder,Path outputDirectory,Set<CoverageReportFormat> formats,String title,boolean useIntermediateClassesDir,Optional<String> coverageIncludes,Optional<String> coverageExcludes){\r\n    ImmutableSet.Builder<String> srcDirectories = ImmutableSet.builder();\r\n    ImmutableSet.Builder<Path> pathsToJars = ImmutableSet.builder();\r\n    for (JavaLibrary rule : rulesUnderTest) {\r\n        ImmutableSet<String> sourceFolderPath = getPathToSourceFolders(rule, sourcePathResolver, ruleFinder, defaultJavaPackageFinder);\r\n        if (!sourceFolderPath.isEmpty()) {\r\n            srcDirectories.addAll(sourceFolderPath);\r\n        }\r\n        Path classesItem = null;\r\n        if (useIntermediateClassesDir) {\r\n            classesItem = CompilerOutputPaths.getClassesDir(rule.getBuildTarget(), filesystem);\r\n        } else {\r\n            SourcePath path = rule.getSourcePathToOutput();\r\n            if (path != null) {\r\n                classesItem = sourcePathResolver.getRelativePath(path);\r\n            }\r\n        }\r\n        if (classesItem == null) {\r\n            continue;\r\n        }\r\n        pathsToJars.add(classesItem);\r\n    }\r\n    return new GenerateCodeCoverageReportStep(javaRuntimeLauncher.getCommandPrefix(sourcePathResolver), filesystem, srcDirectories.build(), pathsToJars.build(), outputDirectory, formats, title, coverageIncludes, coverageExcludes);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONObject.increment",
	"Comment": "increment a property of a jsonobject. if there is no such property, create one with a value of 1. if there is such a property, and if it is an integer, long, double, or float, then add one to it.",
	"Method": "JSONObject increment(String key){\r\n    Object value = opt(key);\r\n    if (value == null) {\r\n        put(key, 1);\r\n    } else {\r\n        if (value instanceof Integer) {\r\n            put(key, ((Integer) value).intValue() + 1);\r\n        } else if (value instanceof Long) {\r\n            put(key, ((Long) value).longValue() + 1);\r\n        } else if (value instanceof Double) {\r\n            put(key, ((Double) value).doubleValue() + 1);\r\n        } else if (value instanceof Float) {\r\n            put(key, ((Float) value).floatValue() + 1);\r\n        } else {\r\n            throw new JSONException(\"Unable to increment [\" + key + \"].\");\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.taobao.arthas.core.command.basic1000.SystemPropertyCommand.complete",
	"Comment": "first, try to complete with the sysprop command scope.if completion is failed, delegates to super class.",
	"Method": "void complete(Completion completion){\r\n    CompletionUtils.complete(completion, System.getProperties().stringPropertyNames());\r\n}"
}, {
	"Path": "org.antlr.v4.test.tool.TestATNParserPrediction.checkPredictedAlt",
	"Comment": "first check that the atn predicts right alt.\t then check adaptive prediction.",
	"Method": "void checkPredictedAlt(LexerGrammar lg,Grammar g,int decision,String inputString,int expectedAlt){\r\n    Tool.internalOption_ShowATNConfigsInDFA = true;\r\n    ATN lexatn = createATN(lg, true);\r\n    LexerATNSimulator lexInterp = new LexerATNSimulator(lexatn, new DFA[] { new DFA(lexatn.modeToStartState.get(Lexer.DEFAULT_MODE)) }, new PredictionContextCache());\r\n    IntegerList types = getTokenTypesViaATN(inputString, lexInterp);\r\n    semanticProcess(lg);\r\n    g.importVocab(lg);\r\n    semanticProcess(g);\r\n    ParserATNFactory f = new ParserATNFactory(g);\r\n    ATN atn = f.createATN();\r\n    DOTGenerator dot = new DOTGenerator(g);\r\n    Rule r = g.getRule(\"a\");\r\n    r = g.getRule(\"b\");\r\n    r = g.getRule(\"e\");\r\n    r = g.getRule(\"ifstat\");\r\n    r = g.getRule(\"block\");\r\n    TokenStream input = new IntTokenStream(types);\r\n    ParserInterpreterForTesting interp = new ParserInterpreterForTesting(g, input);\r\n    int alt = interp.adaptivePredict(input, decision, ParserRuleContext.EMPTY);\r\n    assertEquals(expectedAlt, alt);\r\n    input.seek(0);\r\n    alt = interp.adaptivePredict(input, decision, null);\r\n    assertEquals(expectedAlt, alt);\r\n    input.seek(0);\r\n    alt = interp.adaptivePredict(input, decision, null);\r\n    assertEquals(expectedAlt, alt);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.persistence.entity.TimerJobEntityManagerImpl.deleteExceptionByteArrayRef",
	"Comment": "deletes a the byte array used to store the exception information.subclasses may overrideto provide custom implementations.",
	"Method": "void deleteExceptionByteArrayRef(TimerJobEntity jobEntity){\r\n    ByteArrayRef exceptionByteArrayRef = jobEntity.getExceptionByteArrayRef();\r\n    if (exceptionByteArrayRef != null) {\r\n        exceptionByteArrayRef.delete();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.android.AdbHelper.filterDevices",
	"Comment": "returns list of devices that pass the filter. if there is an invalid combination or no devicesare left after filtering this function prints an error and returns null.",
	"Method": "List<IDevice> filterDevices(IDevice[] allDevices){\r\n    if (allDevices.length == 0) {\r\n        printError(\"No devices are found.\");\r\n        return null;\r\n    }\r\n    List<IDevice> devices = new ArrayList();\r\n    Optional<Boolean> emulatorsOnly = Optional.empty();\r\n    if (deviceOptions.isEmulatorsOnlyModeEnabled() && options.isMultiInstallModeEnabled()) {\r\n        emulatorsOnly = Optional.empty();\r\n    } else if (deviceOptions.isEmulatorsOnlyModeEnabled()) {\r\n        emulatorsOnly = Optional.of(true);\r\n    } else if (deviceOptions.isRealDevicesOnlyModeEnabled()) {\r\n        emulatorsOnly = Optional.of(false);\r\n    }\r\n    int onlineDevices = 0;\r\n    for (IDevice device : allDevices) {\r\n        boolean passed = false;\r\n        if (device.isOnline()) {\r\n            onlineDevices++;\r\n            boolean serialMatches = true;\r\n            if (deviceOptions.getSerialNumber().isPresent()) {\r\n                serialMatches = device.getSerialNumber().equals(deviceOptions.getSerialNumber().get());\r\n            } else if (getEnvironment().containsKey(SERIAL_NUMBER_ENV)) {\r\n                serialMatches = device.getSerialNumber().equals(getEnvironment().get(SERIAL_NUMBER_ENV));\r\n            }\r\n            boolean deviceTypeMatches;\r\n            if (emulatorsOnly.isPresent()) {\r\n                deviceTypeMatches = (emulatorsOnly.get() == createDevice(device).isEmulator());\r\n            } else {\r\n                deviceTypeMatches = true;\r\n            }\r\n            passed = serialMatches && deviceTypeMatches;\r\n        }\r\n        if (passed) {\r\n            devices.add(device);\r\n        }\r\n    }\r\n    if (onlineDevices == 0) {\r\n        printError(\"No devices are found.\");\r\n        return null;\r\n    }\r\n    if (devices.isEmpty()) {\r\n        printError(String.format(\"Found %d connected device(s), but none of them matches specified filter.\", onlineDevices));\r\n        return null;\r\n    }\r\n    return devices;\r\n}"
}, {
	"Path": "com.facebook.buck.android.HasDuplicateAndroidResourceTypes.getDuplicateResourceBehavior",
	"Comment": "this only exists to enable migration from allowing by default to banning by default.",
	"Method": "DuplicateResourceBehaviour getDuplicateResourceBehavior(){\r\n    return DuplicateResourceBehaviour.ALLOW_BY_DEFAULT;\r\n}"
}, {
	"Path": "com.facebook.buck.cli.DistBuildSourceFilesCommand.runLocally",
	"Comment": "runs the first stage of a distributed build locally to compute all required source files forremote materialisation.",
	"Method": "void runLocally(CommandRunnerParams params){\r\n    try (CommandThreadManager pool = new CommandThreadManager(\"DistBuildSourceFiles\", getConcurrencyLimit(params.getBuckConfig()))) {\r\n        BuildJobState jobState = getAsyncDistBuildState(arguments, params, pool.getWeightedListeningExecutorService()).get();\r\n        outputResultToTempFile(params, jobState);\r\n    } catch (ExecutionException e) {\r\n        throw new RuntimeException(\"Could not create DistBuildState.\", e);\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONObject.accumulate",
	"Comment": "accumulate values under a key. it is similar to the put method except that if there is already an object stored under the key then a jsonarray is stored under the key to hold all of theaccumulated values. if there is already a jsonarray, then the new value is appended to it. in contrast, the put method replaces the previous value.",
	"Method": "JSONObject accumulate(String key,Object value){\r\n    testValidity(value);\r\n    Object o = opt(key);\r\n    if (o == null) {\r\n        put(key, value instanceof JSONArray ? new JSONArray().put(value) : value);\r\n    } else if (o instanceof JSONArray) {\r\n        ((JSONArray) o).put(value);\r\n    } else {\r\n        put(key, new JSONArray().put(o).put(value));\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.activiti.engine.test.bpmn.deployment.MessageEventsAndNewVersionDeploymentsTest.testBoundaryEventSubscriptionDeletedOnDeploymentDelete",
	"Comment": "verifying that the event subscriptions do get removed when removing a deployment.",
	"Method": "void testBoundaryEventSubscriptionDeletedOnDeploymentDelete(){\r\n    String deploymentId = deployBoundaryMessageTestProcess();\r\n    runtimeService.startProcessInstanceByKey(\"messageTest\");\r\n    assertEquals(\"My Task\", taskService.createTaskQuery().singleResult().getName());\r\n    String deploymentId2 = deployBoundaryMessageTestProcess();\r\n    runtimeService.startProcessInstanceByKey(\"messageTest\");\r\n    assertEquals(2, taskService.createTaskQuery().count());\r\n    assertEquals(2, getAllEventSubscriptions().size());\r\n    repositoryService.deleteDeployment(deploymentId, true);\r\n    assertEquals(\"My Task\", taskService.createTaskQuery().singleResult().getName());\r\n    assertEquals(1, getAllEventSubscriptions().size());\r\n    repositoryService.deleteDeployment(deploymentId2, true);\r\n    assertEquals(0, getAllEventSubscriptions().size());\r\n}"
}, {
	"Path": "org.activiti.engine.impl.agenda.AbstractOperation.findFirstParentScopeExecution",
	"Comment": "returns the first parent execution of the provided execution that is a scope.",
	"Method": "ExecutionEntity findFirstParentScopeExecution(ExecutionEntity executionEntity){\r\n    ExecutionEntityManager executionEntityManager = commandContext.getExecutionEntityManager();\r\n    ExecutionEntity parentScopeExecution = null;\r\n    ExecutionEntity currentlyExaminedExecution = executionEntityManager.findById(executionEntity.getParentId());\r\n    while (currentlyExaminedExecution != null && parentScopeExecution == null) {\r\n        if (currentlyExaminedExecution.isScope()) {\r\n            parentScopeExecution = currentlyExaminedExecution;\r\n        } else {\r\n            currentlyExaminedExecution = executionEntityManager.findById(currentlyExaminedExecution.getParentId());\r\n        }\r\n    }\r\n    return parentScopeExecution;\r\n}"
}, {
	"Path": "org.activiti.image.impl.DefaultProcessDiagramCanvas.close",
	"Comment": "closes the canvas which dissallows further drawing and releases graphicalresources.",
	"Method": "void close(){\r\n    g.dispose();\r\n    closed = true;\r\n}"
}, {
	"Path": "com.facebook.buck.android.AndroidBundle.getApkInfo",
	"Comment": "the apk at this path is the final one that points to an apk that a user should install.",
	"Method": "ApkInfo getApkInfo(){\r\n    return ApkInfo.builder().setApkPath(getSourcePathToOutput()).setManifestPath(manifestPath).setExopackageInfo(exopackageInfo).build();\r\n}"
}, {
	"Path": "com.facebook.buck.apple.AppleDebuggableBinary.createWithDsym",
	"Comment": "create with runtime dependencies including the dsym rule. dsym holds all the debug infocollected from object files, so object files are not needed for debugging at runtime.",
	"Method": "AppleDebuggableBinary createWithDsym(ProjectFilesystem filesystem,BuildTarget baseTarget,BuildRule strippedBinaryRule,AppleDsym dsym){\r\n    return new AppleDebuggableBinary(filesystem, baseTarget.withAppendedFlavors(RULE_FLAVOR, AppleDebugFormat.DWARF_AND_DSYM.getFlavor()), strippedBinaryRule, Optional.of(dsym), Stream.empty());\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetClient.addOptionHandler",
	"Comment": "registers a new telnetoptionhandler for this telnet client to use.",
	"Method": "void addOptionHandler(TelnetOptionHandler opthand){\r\n    super.addOptionHandler(opthand);\r\n}"
}, {
	"Path": "com.google.auto.value.extension.AutoValueExtension.applicable",
	"Comment": "determines whether this extension applies to the given context.",
	"Method": "boolean applicable(Context context){\r\n    return false;\r\n}"
}, {
	"Path": "org.activiti.bpmn.BPMNLayout.layout",
	"Comment": "starts the actual compact tree layout algorithm at the given node.",
	"Method": "void layout(TreeNode node){\r\n    if (node != null) {\r\n        TreeNode child = node.child;\r\n        while (child != null) {\r\n            layout(child);\r\n            child = child.next;\r\n        }\r\n        if (node.child != null) {\r\n            attachParent(node, join(node));\r\n        } else {\r\n            layoutLeaf(node);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.apple.AppleTest.getRuntimeDeps",
	"Comment": "this test rule just executes the test bundle, so we need it available locally.",
	"Method": "Stream<BuildTarget> getRuntimeDeps(SourcePathRuleFinder ruleFinder){\r\n    return Stream.concat(Stream.concat(Stream.of(testBundle), Stream.concat(Optionals.toStream(testHostApp), Optionals.toStream(uiTestTargetApp))).map(BuildRule::getBuildTarget), Optionals.toStream(xctool).map(ruleFinder::filterBuildRuleInputs).flatMap(ImmutableSet::stream).map(BuildRule::getBuildTarget));\r\n}"
}, {
	"Path": "com.taobao.arthas.core.command.klass100.ClassLoaderCommand.processClassLoaderStats",
	"Comment": "calculate classloader statistics.e.g. in jvm, there are 100 grooyclassloader instances, which loaded 200 classes in total",
	"Method": "void processClassLoaderStats(CommandProcess process,Instrumentation inst){\r\n    RowAffect affect = new RowAffect();\r\n    List<ClassLoaderInfo> classLoaderInfos = getAllClassLoaderInfo(inst);\r\n    Map<String, ClassLoaderStat> classLoaderStats = new HashMap<String, ClassLoaderStat>();\r\n    for (ClassLoaderInfo info : classLoaderInfos) {\r\n        String name = info.classLoader == null ? \"BootstrapClassLoader\" : info.classLoader.getClass().getName();\r\n        ClassLoaderStat stat = classLoaderStats.get(name);\r\n        if (null == stat) {\r\n            stat = new ClassLoaderStat();\r\n            classLoaderStats.put(name, stat);\r\n        }\r\n        stat.addLoadedCount(info.loadedClassCount);\r\n        stat.addNumberOfInstance(1);\r\n    }\r\n    TreeMap<String, ClassLoaderStat> sorted = new TreeMap<String, ClassLoaderStat>(new ValueComparator(classLoaderStats));\r\n    sorted.putAll(classLoaderStats);\r\n    Element element = renderStat(sorted);\r\n    process.write(RenderUtil.render(element, process.width())).write(com.taobao.arthas.core.util.Constants.EMPTY_STRING);\r\n    affect.rCnt(sorted.keySet().size());\r\n    process.write(affect + \"\\n\");\r\n    process.end();\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.XML.noSpace",
	"Comment": "throw an exception if the string contains whitespace. whitespace is not allowed in tagnames and attributes.",
	"Method": "void noSpace(String string){\r\n    int i, length = string.length();\r\n    if (length == 0) {\r\n        throw new JSONException(\"Empty string.\");\r\n    }\r\n    for (i = 0; i < length; i += 1) {\r\n        if (Character.isWhitespace(string.charAt(i))) {\r\n            throw new JSONException(\"'\" + string + \"' contains a space character.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.BootstrapProgressBar.createTile",
	"Comment": "creates a bitmap which is a tile of the progress bar background",
	"Method": "Bitmap createTile(float h,Paint stripePaint,Paint progressPaint){\r\n    Bitmap bm = Bitmap.createBitmap((int) h * 2, (int) h, ARGB_8888);\r\n    Canvas tile = new Canvas(bm);\r\n    float x = 0;\r\n    Path path = new Path();\r\n    path.moveTo(x, 0);\r\n    path.lineTo(x, h);\r\n    path.lineTo(h, h);\r\n    tile.drawPath(path, stripePaint);\r\n    path.reset();\r\n    path.moveTo(x, 0);\r\n    path.lineTo(x + h, h);\r\n    path.lineTo(x + (h * 2), h);\r\n    path.lineTo(x + h, 0);\r\n    tile.drawPath(path, progressPaint);\r\n    x += h;\r\n    path.reset();\r\n    path.moveTo(x, 0);\r\n    path.lineTo(x + h, 0);\r\n    path.lineTo(x + h, h);\r\n    tile.drawPath(path, stripePaint);\r\n    return bm;\r\n}"
}, {
	"Path": "org.antlr.mojo.antlr4.Antlr4Mojo.execute",
	"Comment": "the main entry point for this mojo, it is responsible for convertingantlr 4.x grammars into the target language specified by the grammar.",
	"Method": "void execute(){\r\n    Log log = getLog();\r\n    outputEncoding = validateEncoding(outputEncoding);\r\n    if (log.isDebugEnabled()) {\r\n        for (String e : excludes) {\r\n            log.debug(\"ANTLR: Exclude: \" + e);\r\n        }\r\n        for (String e : includes) {\r\n            log.debug(\"ANTLR: Include: \" + e);\r\n        }\r\n        log.debug(\"ANTLR: Output: \" + outputDirectory);\r\n        log.debug(\"ANTLR: Library: \" + libDirectory);\r\n    }\r\n    if (!sourceDirectory.isDirectory()) {\r\n        log.info(\"No ANTLR 4 grammars to compile in \" + sourceDirectory.getAbsolutePath());\r\n        return;\r\n    }\r\n    File outputDir = getOutputDirectory();\r\n    if (!outputDir.exists()) {\r\n        outputDir.mkdirs();\r\n    }\r\n    GrammarDependencies dependencies = new GrammarDependencies(sourceDirectory, libDirectory, arguments, getDependenciesStatusFile(), getLog());\r\n    List<List<String>> argumentSets;\r\n    Set<File> grammarFiles;\r\n    Set<File> importGrammarFiles;\r\n    try {\r\n        List<String> args = getCommandArguments();\r\n        grammarFiles = getGrammarFiles(sourceDirectory);\r\n        importGrammarFiles = getImportFiles(sourceDirectory);\r\n        argumentSets = processGrammarFiles(args, grammarFiles, dependencies, sourceDirectory);\r\n    } catch (Exception e) {\r\n        log.error(e);\r\n        throw new MojoExecutionException(\"Fatal error occured while evaluating the names of the grammar files to analyze\", e);\r\n    }\r\n    log.debug(\"Output directory base will be \" + outputDirectory.getAbsolutePath());\r\n    log.info(\"ANTLR 4: Processing source directory \" + sourceDirectory.getAbsolutePath());\r\n    for (List<String> args : argumentSets) {\r\n        try {\r\n            tool = new CustomTool(args.toArray(new String[args.size()]));\r\n        } catch (Exception e) {\r\n            log.error(\"The attempt to create the ANTLR 4 build tool failed, see exception report for details\", e);\r\n            throw new MojoFailureException(\"Error creating an instanceof the ANTLR tool.\", e);\r\n        }\r\n        try {\r\n            dependencies.analyze(grammarFiles, importGrammarFiles, tool);\r\n        } catch (Exception e) {\r\n            log.error(\"Dependency analysis failed, see exception report for details\", e);\r\n            throw new MojoFailureException(\"Dependency analysis failed.\", e);\r\n        }\r\n        tool.inputDirectory = sourceDirectory;\r\n        tool.processGrammarsOnCommandLine();\r\n        if (tool.getNumErrors() > 0) {\r\n            throw new MojoExecutionException(\"ANTLR 4 caught \" + tool.getNumErrors() + \" build errors.\");\r\n        }\r\n    }\r\n    if (project != null) {\r\n        addSourceRoot(this.getOutputDirectory());\r\n    }\r\n    try {\r\n        dependencies.save();\r\n    } catch (IOException ex) {\r\n        log.warn(\"Could not save grammar dependency status\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.google.auto.value.processor.TypeEncoderTest.testErrorTypes",
	"Comment": "annotation processor, and propagate any failures out of this test.",
	"Method": "void testErrorTypes(){\r\n    JavaFileObject source = JavaFileObjects.forSourceString(\"ExtendsUndefinedType\", \"class ExtendsUndefinedType extends UndefinedParent {}\");\r\n    Compilation compilation = javac().withProcessors(new ErrorTestProcessor()).compile(source);\r\n    assertThat(compilation).failed();\r\n    assertThat(compilation).hadErrorContaining(\"UndefinedParent\");\r\n    assertThat(compilation).hadErrorCount(1);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONArray.optJSONObject",
	"Comment": "get the optional jsonobject associated with an index. null is returned if the key is not found, or null if the index has no value, or if the value is not a jsonobject.",
	"Method": "JSONObject optJSONObject(int index){\r\n    Object o = opt(index);\r\n    return o instanceof JSONObject ? (JSONObject) o : null;\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.atn.ParseInfo.getTotalSLLATNLookaheadOps",
	"Comment": "gets the total number of atn lookahead operations for sll prediction\tacross all decisions made during parsing.",
	"Method": "long getTotalSLLATNLookaheadOps(){\r\n    DecisionInfo[] decisions = atnSimulator.getDecisionInfo();\r\n    long k = 0;\r\n    for (int i = 0; i < decisions.length; i++) {\r\n        k += decisions[i].SLL_ATNTransitions;\r\n    }\r\n    return k;\r\n}"
}, {
	"Path": "com.facebook.buck.cli.TestCommand.handleException",
	"Comment": "it prints error message when users do not pass arguments to underlying binary correctly.",
	"Method": "void handleException(CmdLineException e){\r\n    handleException(e, \"If using an external runner, remember to use '--'.\");\r\n}"
}, {
	"Path": "org.apache.commons.net.DatagramSocketClient.getDefaultTimeout",
	"Comment": "returns the default timeout in milliseconds that is used whenopening a socket.",
	"Method": "int getDefaultTimeout(){\r\n    return _timeout_;\r\n}"
}, {
	"Path": "com.facebook.buck.artifact_cache.ThriftArtifactCacheProtocol.copyExactly",
	"Comment": "copy an exact number of bytes between two streams, failing if source has fewer bytes thanrequested.",
	"Method": "void copyExactly(InputStream source,OutputStream destination,long bytesToRead){\r\n    long bytesCopied = ByteStreams.copy(ByteStreams.limit(source, bytesToRead), destination);\r\n    if (bytesCopied < bytesToRead) {\r\n        String msg = String.format(\"InputStream was missing [%d] bytes. Expected to read a total of [%d] bytes.\", bytesToRead - bytesCopied, bytesToRead);\r\n        LOG.error(msg);\r\n        throw new IOException(msg);\r\n    }\r\n}"
}, {
	"Path": "org.antlr.v4.tool.GrammarInterpreterRuleContext.getOuterAltNum",
	"Comment": "the predicted outermost alternative for the rule associated\t with this context object.if this node left recursive, the true original\t outermost alternative is returned.",
	"Method": "int getOuterAltNum(){\r\n    return outerAltNum;\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.DefaultErrorStrategy.beginErrorCondition",
	"Comment": "this method is called to enter error recovery mode when a recognition\texception is reported.",
	"Method": "void beginErrorCondition(Parser recognizer){\r\n    errorRecoveryMode = true;\r\n}"
}, {
	"Path": "org.antlr.v4.codegen.OutputModelController.buildParserOutputModel",
	"Comment": "build a file with a parser containing rule functions. use the\t controller as factory in sourcegentriggers so it triggers codegen\t extensions too, not just the factory functions in this factory.",
	"Method": "OutputModelObject buildParserOutputModel(boolean header){\r\n    CodeGenerator gen = delegate.getGenerator();\r\n    ParserFile file = parserFile(gen.getRecognizerFileName(header));\r\n    setRoot(file);\r\n    file.parser = parser(file);\r\n    Grammar g = delegate.getGrammar();\r\n    for (Rule r : g.rules.values()) {\r\n        buildRuleFunction(file.parser, r);\r\n    }\r\n    return file;\r\n}"
}, {
	"Path": "com.roughike.bottombar.ShySettings.showBar",
	"Comment": "shows the bottombar if it was hidden, with a translate animation.",
	"Method": "void showBar(){\r\n    toggleIsVisibleInShyMode(true);\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.Telnet.addOptionHandler",
	"Comment": "registers a new telnetoptionhandler for this telnetto use.",
	"Method": "void addOptionHandler(TelnetOptionHandler opthand){\r\n    int optcode = opthand.getOptionCode();\r\n    if (TelnetOption.isValidOption(optcode)) {\r\n        if (optionHandlers[optcode] == null) {\r\n            optionHandlers[optcode] = opthand;\r\n            if (isConnected()) {\r\n                if (opthand.getInitLocal()) {\r\n                    _requestWill(optcode);\r\n                }\r\n                if (opthand.getInitRemote()) {\r\n                    _requestDo(optcode);\r\n                }\r\n            }\r\n        } else {\r\n            throw (new InvalidTelnetOptionException(\"Already registered option\", optcode));\r\n        }\r\n    } else {\r\n        throw (new InvalidTelnetOptionException(\"Invalid Option Code\", optcode));\r\n    }\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.GPUImageView.capture",
	"Comment": "capture the current image with the size as it is displayed and retrieve it as bitmap.",
	"Method": "Bitmap capture(int width,int height,Bitmap capture){\r\n    final Semaphore waiter = new Semaphore(0);\r\n    final int width = surfaceView.getMeasuredWidth();\r\n    final int height = surfaceView.getMeasuredHeight();\r\n    final Bitmap resultBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\r\n    gpuImage.runOnGLThread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            GPUImageNativeLibrary.adjustBitmap(resultBitmap);\r\n            waiter.release();\r\n        }\r\n    });\r\n    requestRender();\r\n    waiter.acquire();\r\n    return resultBitmap;\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.GPUImageView.capture",
	"Comment": "capture the current image with the size as it is displayed and retrieve it as bitmap.",
	"Method": "Bitmap capture(int width,int height,Bitmap capture){\r\n    GPUImageNativeLibrary.adjustBitmap(resultBitmap);\r\n    waiter.release();\r\n}"
}, {
	"Path": "com.facebook.buck.artifact_cache.ClientCertificateHandler.fromConfiguration",
	"Comment": "create a new clientcertificatehandler based on client tls settings in configuration",
	"Method": "Optional<ClientCertificateHandler> fromConfiguration(ArtifactCacheBuckConfig config){\r\n    if (!config.getClientTlsKey().isPresent() || !config.getClientTlsCertificate().isPresent()) {\r\n        return Optional.empty();\r\n    }\r\n    HandshakeCertificates handshakeCertificates = parseHandshakeCertificates(config.getClientTlsKey().get(), config.getClientTlsCertificate().get());\r\n    return Optional.of(new ClientCertificateHandler(handshakeCertificates, Optional.empty()));\r\n}"
}, {
	"Path": "com.facebook.buck.android.aapt.RDotTxtEntry.compareTo",
	"Comment": "a collection of resources should be sorted such that resources of the same type should begrouped together, and should be alphabetized within that group.",
	"Method": "int compareTo(RDotTxtEntry that){\r\n    if (this == that) {\r\n        return 0;\r\n    }\r\n    ComparisonChain comparisonChain = ComparisonChain.start().compare(this.type, that.type).compare(this.parent, that.parent).compare(this.name, that.name);\r\n    return comparisonChain.result();\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.history.HistoricProcessInstanceAndVariablesQueryTest.setUp",
	"Comment": "setup starts 4 process instances of onetaskprocess and 1 instance of onetaskprocess2",
	"Method": "void setUp(){\r\n    super.setUp();\r\n    repositoryService.createDeployment().addClasspathResource(\"org/activiti/engine/test/api/runtime/oneTaskProcess.bpmn20.xml\").addClasspathResource(\"org/activiti/engine/test/api/runtime/oneTaskProcess2.bpmn20.xml\").addClasspathResource(\"org/activiti/engine/test/api/runtime/oneTaskProcess3.bpmn20.xml\").deploy();\r\n    Map<String, Object> startMap = new HashMap<String, Object>();\r\n    startMap.put(\"test\", \"test\");\r\n    startMap.put(\"test2\", \"test2\");\r\n    processInstanceIds = new ArrayList<String>();\r\n    for (int i = 0; i < 4; i++) {\r\n        processInstanceIds.add(runtimeService.startProcessInstanceByKey(PROCESS_DEFINITION_KEY, i + \"\", startMap).getId());\r\n        if (i == 0) {\r\n            Task task = taskService.createTaskQuery().processInstanceId(processInstanceIds.get(0)).singleResult();\r\n            taskService.complete(task.getId());\r\n        }\r\n    }\r\n    startMap.clear();\r\n    startMap.put(\"anothertest\", 123);\r\n    processInstanceIds.add(runtimeService.startProcessInstanceByKey(PROCESS_DEFINITION_KEY_2, \"1\", startMap).getId());\r\n    startMap.clear();\r\n    startMap.put(\"casetest\", \"MyTest\");\r\n    processInstanceIds.add(runtimeService.startProcessInstanceByKey(PROCESS_DEFINITION_KEY_3, \"1\", startMap).getId());\r\n}"
}, {
	"Path": "org.activiti.standalone.event.ProcessDefinitionScopedEventListenerDefinitionTest.testProcessDefinitionListenerDefinitionEntities",
	"Comment": "test to verify listeners defined in the bpmn xml are added to the process definition and are active, for all entity types",
	"Method": "void testProcessDefinitionListenerDefinitionEntities(){\r\n    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(\"testEventListeners\");\r\n    assertNotNull(processInstance);\r\n    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();\r\n    assertNotNull(task);\r\n    TestActivitiEventListener theListener = (TestActivitiEventListener) processEngineConfiguration.getBeans().get(\"testAttachmentEventListener\");\r\n    assertNotNull(theListener);\r\n    assertEquals(0, theListener.getEventsReceived().size());\r\n    taskService.createAttachment(\"test\", task.getId(), processInstance.getId(), \"test\", \"test\", \"url\");\r\n    assertEquals(2, theListener.getEventsReceived().size());\r\n    assertEquals(ActivitiEventType.ENTITY_CREATED, theListener.getEventsReceived().get(0).getType());\r\n    assertEquals(ActivitiEventType.ENTITY_INITIALIZED, theListener.getEventsReceived().get(1).getType());\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetOptionHandler.setInitRemote",
	"Comment": "tells this option whether to send a do request upon connection.",
	"Method": "void setInitRemote(boolean init){\r\n    initialRemote = init;\r\n}"
}, {
	"Path": "com.facebook.buck.android.AndroidBinaryBuildable.getCompressedResourcesApkPath",
	"Comment": "the apk at this path will have compressed resources, but will not be zipaligned.",
	"Method": "Path getCompressedResourcesApkPath(){\r\n    return Paths.get(getUnsignedApkPath().replaceAll(\"\\\\.unsigned\\\\.apk$\", \".compressed.apk\"));\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONML.toString",
	"Comment": "reverse the jsonml transformation, making an xml text from a jsonarray.",
	"Method": "String toString(JSONArray ja,String toString,JSONObject jo){\r\n    StringBuilder sb = new StringBuilder();\r\n    Object e;\r\n    int i;\r\n    JSONArray ja;\r\n    String k;\r\n    Iterator keys;\r\n    int len;\r\n    String tagName;\r\n    String v;\r\n    tagName = jo.optString(\"tagName\");\r\n    if (tagName == null) {\r\n        return XML.escape(jo.toString());\r\n    }\r\n    XML.noSpace(tagName);\r\n    tagName = XML.escape(tagName);\r\n    sb.append('<');\r\n    sb.append(tagName);\r\n    keys = jo.keys();\r\n    while (keys.hasNext()) {\r\n        k = keys.next().toString();\r\n        if (!k.equals(\"tagName\") && !k.equals(\"childNodes\")) {\r\n            XML.noSpace(k);\r\n            v = jo.optString(k);\r\n            if (v != null) {\r\n                sb.append(' ');\r\n                sb.append(XML.escape(k));\r\n                sb.append('=');\r\n                sb.append('\"');\r\n                sb.append(XML.escape(v));\r\n                sb.append('\"');\r\n            }\r\n        }\r\n    }\r\n    ja = jo.optJSONArray(\"childNodes\");\r\n    if (ja == null) {\r\n        sb.append('/');\r\n        sb.append('>');\r\n    } else {\r\n        sb.append('>');\r\n        len = ja.length();\r\n        for (i = 0; i < len; i += 1) {\r\n            e = ja.get(i);\r\n            if (e != null) {\r\n                if (e instanceof String) {\r\n                    sb.append(XML.escape(e.toString()));\r\n                } else if (e instanceof JSONObject) {\r\n                    sb.append(toString((JSONObject) e));\r\n                } else if (e instanceof JSONArray) {\r\n                    sb.append(toString((JSONArray) e));\r\n                }\r\n            }\r\n        }\r\n        sb.append('<');\r\n        sb.append('/');\r\n        sb.append(tagName);\r\n        sb.append('>');\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.GPUImage.getBitmapWithFilterApplied",
	"Comment": "gets the given bitmap with current filter applied as a bitmap.",
	"Method": "Bitmap getBitmapWithFilterApplied(Bitmap getBitmapWithFilterApplied,Bitmap bitmap,Bitmap getBitmapWithFilterApplied,Bitmap bitmap,boolean recycle){\r\n    if (glSurfaceView != null || glTextureView != null) {\r\n        renderer.deleteImage();\r\n        renderer.runOnDraw(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                synchronized (filter) {\r\n                    filter.destroy();\r\n                    filter.notify();\r\n                }\r\n            }\r\n        });\r\n        synchronized (filter) {\r\n            requestRender();\r\n            try {\r\n                filter.wait();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    GPUImageRenderer renderer = new GPUImageRenderer(filter);\r\n    renderer.setRotation(Rotation.NORMAL, this.renderer.isFlippedHorizontally(), this.renderer.isFlippedVertically());\r\n    renderer.setScaleType(scaleType);\r\n    PixelBuffer buffer = new PixelBuffer(bitmap.getWidth(), bitmap.getHeight());\r\n    buffer.setRenderer(renderer);\r\n    renderer.setImageBitmap(bitmap, recycle);\r\n    Bitmap result = buffer.getBitmap();\r\n    filter.destroy();\r\n    renderer.deleteImage();\r\n    buffer.destroy();\r\n    this.renderer.setFilter(filter);\r\n    if (currentBitmap != null) {\r\n        this.renderer.setImageBitmap(currentBitmap, false);\r\n    }\r\n    requestRender();\r\n    return result;\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.GPUImage.getBitmapWithFilterApplied",
	"Comment": "gets the given bitmap with current filter applied as a bitmap.",
	"Method": "Bitmap getBitmapWithFilterApplied(Bitmap getBitmapWithFilterApplied,Bitmap bitmap,Bitmap getBitmapWithFilterApplied,Bitmap bitmap,boolean recycle){\r\n    synchronized (filter) {\r\n        filter.destroy();\r\n        filter.notify();\r\n    }\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetOptionHandler.getInitRemote",
	"Comment": "returns a boolean indicating whether to send a do requestto the other end upon connection.",
	"Method": "boolean getInitRemote(){\r\n    return (initialRemote);\r\n}"
}, {
	"Path": "com.facebook.buck.android.AndroidBuckConfig.getAapt2Override",
	"Comment": "returns the path to the platform specific aapt2 executable that is overridden by the currentproject. if not specified, the android platform aapt will be used.",
	"Method": "Optional<Supplier<Tool>> getAapt2Override(){\r\n    return getToolOverride(\"aapt2\");\r\n}"
}, {
	"Path": "com.facebook.buck.apple.AppleBinaryDescription.shouldWrapIntoAppleDebuggableBinary",
	"Comment": "so unless flavor is explicitly set, lets just produce binary!",
	"Method": "boolean shouldWrapIntoAppleDebuggableBinary(BuildTarget buildTarget,BuildRule binaryBuildRule){\r\n    Optional<AppleDebugFormat> explicitDebugInfoFormat = AppleDebugFormat.FLAVOR_DOMAIN.getValue(buildTarget);\r\n    boolean binaryIsWrappable = AppleDebuggableBinary.canWrapBinaryBuildRule(binaryBuildRule);\r\n    return explicitDebugInfoFormat.isPresent() && binaryIsWrappable;\r\n}"
}, {
	"Path": "org.activiti.bpmn.BPMNLayout.moveNode",
	"Comment": "moves the specified node and all of its children by the given amount.",
	"Method": "void moveNode(TreeNode node,double dx,double dy){\r\n    node.x += dx;\r\n    node.y += dy;\r\n    apply(node, null);\r\n    TreeNode child = node.child;\r\n    while (child != null) {\r\n        moveNode(child, dx, dy);\r\n        child = child.next;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.apple.AppleDebuggableBinary.createFromUnstrippedBinary",
	"Comment": "create with runtime dependencies to the binary itself and its static library constituents.this is necessary as macho binaries have pointers to debug information stored in objectfiles, rather than copying the debug info into the binary itself.",
	"Method": "AppleDebuggableBinary createFromUnstrippedBinary(ProjectFilesystem filesystem,BuildTarget baseTarget,HasAppleDebugSymbolDeps unstrippedBinaryRule){\r\n    return new AppleDebuggableBinary(filesystem, baseTarget.withAppendedFlavors(RULE_FLAVOR, AppleDebugFormat.DWARF.getFlavor()), unstrippedBinaryRule, Optional.empty(), unstrippedBinaryRule.getAppleDebugSymbolDeps());\r\n}"
}, {
	"Path": "com.facebook.buck.cli.bootstrapper.filesystem.BuckUnixPath.asDefault",
	"Comment": "return java default implementation of path inferred from current instance",
	"Method": "Path asDefault(){\r\n    return fs.getDefaultFileSystem().getPath(toString());\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetOptionHandler.setAcceptLocal",
	"Comment": "set behaviour of the option for do requests coming fromthe other end.",
	"Method": "void setAcceptLocal(boolean accept){\r\n    acceptLocal = accept;\r\n}"
}, {
	"Path": "org.asynchttpclient.ntlm.NtlmEngine.lmv2Response",
	"Comment": "creates the lmv2 response from the given hash, client data, and type 2challenge.",
	"Method": "byte[] lmv2Response(byte[] hash,byte[] challenge,byte[] clientData){\r\n    final HMACMD5 hmacMD5 = new HMACMD5(hash);\r\n    hmacMD5.update(challenge);\r\n    hmacMD5.update(clientData);\r\n    final byte[] mac = hmacMD5.getOutput();\r\n    final byte[] lmv2Response = new byte[mac.length + clientData.length];\r\n    System.arraycopy(mac, 0, lmv2Response, 0, mac.length);\r\n    System.arraycopy(clientData, 0, lmv2Response, mac.length, clientData.length);\r\n    return lmv2Response;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.listener.DelegateExpressionTransactionDependentExecutionListener.getExpressionText",
	"Comment": "returns the expression text for this execution listener. comes in handy if you want to check which listeners you already have.",
	"Method": "String getExpressionText(){\r\n    return expression.getExpressionText();\r\n}"
}, {
	"Path": "org.activiti.standalone.event.ProcessDefinitionScopedEventListenerDefinitionTest.testProcessDefinitionListenerDefinition",
	"Comment": "test to verify listeners defined in the bpmn xml are added to the process definition and are active.",
	"Method": "void testProcessDefinitionListenerDefinition(){\r\n    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(\"testEventListeners\");\r\n    assertNotNull(testListenerBean);\r\n    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();\r\n    taskService.complete(task.getId());\r\n    assertFalse(testListenerBean.getEventsReceived().isEmpty());\r\n    for (ActivitiEvent event : testListenerBean.getEventsReceived()) {\r\n        assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());\r\n    }\r\n    assertTrue(testListenerBean.getEventsReceived().get(0) instanceof ActivitiEntityEvent);\r\n    ActivitiEntityEvent event = (ActivitiEntityEvent) testListenerBean.getEventsReceived().get(0);\r\n    assertTrue(event.getEntity() instanceof ProcessInstance);\r\n    assertEquals(processInstance.getId(), ((ProcessInstance) event.getEntity()).getId());\r\n    List<ActivitiEvent> events = StaticTestActivitiEventListener.getEventsReceived();\r\n    assertFalse(events.isEmpty());\r\n    boolean insertFound = false;\r\n    boolean deleteFound = false;\r\n    for (ActivitiEvent e : events) {\r\n        if (ActivitiEventType.ENTITY_CREATED == e.getType()) {\r\n            insertFound = true;\r\n        } else if (ActivitiEventType.ENTITY_DELETED == e.getType()) {\r\n            deleteFound = true;\r\n        }\r\n    }\r\n    assertTrue(insertFound);\r\n    assertTrue(deleteFound);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONArray.optLong",
	"Comment": "get the optional long value associated with an index. the defaultvalue is returned if there is no value for the index, or if the value is not a number and cannot be converted to a number.",
	"Method": "long optLong(int index,long optLong,int index,long defaultValue){\r\n    try {\r\n        return getLong(index);\r\n    } catch (Exception e) {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.dfa.DFAState.getAltSet",
	"Comment": "get the set of all alts mentioned by all atn configurations in this\t dfa state.",
	"Method": "Set<Integer> getAltSet(){\r\n    Set<Integer> alts = new HashSet<Integer>();\r\n    if (configs != null) {\r\n        for (ATNConfig c : configs) {\r\n            alts.add(c.alt);\r\n        }\r\n    }\r\n    if (alts.isEmpty())\r\n        return null;\r\n    return alts;\r\n}"
}, {
	"Path": "com.taobao.arthas.core.command.basic1000.SystemEnvCommand.complete",
	"Comment": "first, try to complete with the sysenv command scope. if completion isfailed, delegates to super class.",
	"Method": "void complete(Completion completion){\r\n    CompletionUtils.complete(completion, System.getenv().keySet());\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.GLTextureView.onDetachedFromWindow",
	"Comment": "this method is used as part of the view class and is not normallycalled or subclassed by clients of gltextureview.must not be called before a renderer has been set.",
	"Method": "void onDetachedFromWindow(){\r\n    if (LOG_ATTACH_DETACH) {\r\n        Log.d(TAG, \"onDetachedFromWindow\");\r\n    }\r\n    if (glThread != null) {\r\n        glThread.requestExitAndWait();\r\n    }\r\n    detached = true;\r\n    super.onDetachedFromWindow();\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.XMLTokener.skipPast",
	"Comment": "skip characters until past the requested string. if it is not found, we are left at the end of the source with a result of false.",
	"Method": "boolean skipPast(String to){\r\n    boolean b;\r\n    char c;\r\n    int i;\r\n    int j;\r\n    int offset = 0;\r\n    int n = to.length();\r\n    char[] circle = new char[n];\r\n    for (i = 0; i < n; i += 1) {\r\n        c = next();\r\n        if (c == 0) {\r\n            return false;\r\n        }\r\n        circle[i] = c;\r\n    }\r\n    for (; ; ) {\r\n        j = offset;\r\n        b = true;\r\n        for (i = 0; i < n; i += 1) {\r\n            if (circle[j] != to.charAt(i)) {\r\n                b = false;\r\n                break;\r\n            }\r\n            j += 1;\r\n            if (j >= n) {\r\n                j -= n;\r\n            }\r\n        }\r\n        if (b) {\r\n            return true;\r\n        }\r\n        c = next();\r\n        if (c == 0) {\r\n            return false;\r\n        }\r\n        circle[offset] = c;\r\n        offset += 1;\r\n        if (offset >= n) {\r\n            offset -= n;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.commons.net.ProtocolCommandEvent.isReply",
	"Comment": "returns true if the protocolcommandevent was generated as a resultof receiving a reply.",
	"Method": "boolean isReply(){\r\n    return !isCommand();\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.ExecutionGraphUtil.orderFromRootToLeaf",
	"Comment": "takes in a collection of executions belonging to the same process instance. orders the executions in a list, first elements are the leaf, last element is the root elements.",
	"Method": "List<ExecutionEntity> orderFromRootToLeaf(Collection<ExecutionEntity> executions){\r\n    List<ExecutionEntity> orderedList = new ArrayList<ExecutionEntity>(executions.size());\r\n    HashSet<String> previousIds = new HashSet<String>();\r\n    for (ExecutionEntity execution : executions) {\r\n        if (execution.getParentId() == null) {\r\n            orderedList.add(execution);\r\n            previousIds.add(execution.getId());\r\n        }\r\n    }\r\n    while (orderedList.size() < executions.size()) {\r\n        for (ExecutionEntity execution : executions) {\r\n            if (!previousIds.contains(execution.getId()) && previousIds.contains(execution.getParentId())) {\r\n                orderedList.add(execution);\r\n                previousIds.add(execution.getId());\r\n            }\r\n        }\r\n    }\r\n    return orderedList;\r\n}"
}, {
	"Path": "com.facebook.buck.core.graph.transformation.executor.impl.DefaultDepsAwareTask.ofThrowing",
	"Comment": "constructs a task from a callable with the specified dependencies, where dependency discoverycould throw",
	"Method": "DefaultDepsAwareTask<U> ofThrowing(Callable<U> callable,ThrowingSupplier<ImmutableSet<DefaultDepsAwareTask<U>>, Exception> depsSupplier){\r\n    return new DefaultDepsAwareTask(callable, depsSupplier);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONObject.optDouble",
	"Comment": "get an optional double associated with a key, or the defaultvalue if there is no such key or if its value is not a number. if the value is a string, an attempt will be made to evaluate it as anumber.",
	"Method": "double optDouble(String key,double optDouble,String key,double defaultValue){\r\n    try {\r\n        Object o = opt(key);\r\n        return o instanceof Number ? ((Number) o).doubleValue() : new Double((String) o).doubleValue();\r\n    } catch (Exception e) {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.event.VariableEventsTest.testProcessInstanceVariableEventsOnStart",
	"Comment": "test create event of variables when process is started with variables passed in.",
	"Method": "void testProcessInstanceVariableEventsOnStart(){\r\n    HashMap<String, Object> vars = new HashMap<String, Object>();\r\n    vars.put(\"testVariable\", \"The value\");\r\n    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(\"oneTaskProcess\", vars);\r\n    assertNotNull(processInstance);\r\n    assertEquals(1, listener.getEventsReceived().size());\r\n    ActivitiVariableEvent event = (ActivitiVariableEvent) listener.getEventsReceived().get(0);\r\n    assertEquals(ActivitiEventType.VARIABLE_CREATED, event.getType());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    assertEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertNull(event.getTaskId());\r\n    assertEquals(\"testVariable\", event.getVariableName());\r\n    assertEquals(\"The value\", event.getVariableValue());\r\n    listener.clearEventsReceived();\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.listener.DelegateExpressionTaskListener.getExpressionText",
	"Comment": "returns the expression text for this task listener. comes in handy if you want to check which listeners you already have.",
	"Method": "String getExpressionText(){\r\n    return expression.getExpressionText();\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.deployer.BpmnDeployer.persistProcessDefinitionsAndAuthorizations",
	"Comment": "saves each process definition.it is assumed that the deployment is new, the definitionshave never been saved before, and that they have all their values properly set up.",
	"Method": "void persistProcessDefinitionsAndAuthorizations(ParsedDeployment parsedDeployment){\r\n    CommandContext commandContext = Context.getCommandContext();\r\n    ProcessDefinitionEntityManager processDefinitionManager = commandContext.getProcessDefinitionEntityManager();\r\n    for (ProcessDefinitionEntity processDefinition : parsedDeployment.getAllProcessDefinitions()) {\r\n        processDefinitionManager.insert(processDefinition, false);\r\n        bpmnDeploymentHelper.addAuthorizationsForNewProcessDefinition(parsedDeployment.getProcessModelForProcessDefinition(processDefinition), processDefinition);\r\n    }\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.Recognizer.getRuleIndexMap",
	"Comment": "get a map from rule names to rule indexes.\tused for xpath and tree pattern compilation.",
	"Method": "Map<String, Integer> getRuleIndexMap(){\r\n    String[] ruleNames = getRuleNames();\r\n    if (ruleNames == null) {\r\n        throw new UnsupportedOperationException(\"The current recognizer does not provide a list of rule names.\");\r\n    }\r\n    synchronized (ruleIndexMapCache) {\r\n        Map<String, Integer> result = ruleIndexMapCache.get(ruleNames);\r\n        if (result == null) {\r\n            result = Collections.unmodifiableMap(Utils.toMap(ruleNames));\r\n            ruleIndexMapCache.put(ruleNames, result);\r\n        }\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.event.ProcessInstanceEventsTest.testProcessInstanceEvents",
	"Comment": "test create, update and delete events of process instances.",
	"Method": "void testProcessInstanceEvents(){\r\n    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(\"oneTaskProcess\");\r\n    assertNotNull(processInstance);\r\n    assertEquals(5, listener.getEventsReceived().size());\r\n    assertTrue(listener.getEventsReceived().get(0) instanceof ActivitiEntityEvent);\r\n    ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);\r\n    assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());\r\n    assertEquals(processInstance.getId(), ((ProcessInstance) event.getEntity()).getId());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);\r\n    assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(2);\r\n    assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertNotEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(3);\r\n    assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertNotEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(4);\r\n    assertEquals(ActivitiEventType.PROCESS_STARTED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    assertTrue(event instanceof ActivitiProcessStartedEvent);\r\n    assertNull(((ActivitiProcessStartedEvent) event).getNestedProcessDefinitionId());\r\n    assertNull(((ActivitiProcessStartedEvent) event).getNestedProcessInstanceId());\r\n    listener.clearEventsReceived();\r\n    runtimeService.suspendProcessInstanceById(processInstance.getId());\r\n    runtimeService.activateProcessInstanceById(processInstance.getId());\r\n    assertEquals(4, listener.getEventsReceived().size());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);\r\n    assertEquals(processInstance.getId(), ((ProcessInstance) event.getEntity()).getId());\r\n    assertEquals(ActivitiEventType.ENTITY_SUSPENDED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);\r\n    assertEquals(ActivitiEventType.ENTITY_SUSPENDED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertNotEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(2);\r\n    assertEquals(ActivitiEventType.ENTITY_ACTIVATED, event.getType());\r\n    assertEquals(processInstance.getId(), ((ProcessInstance) event.getEntity()).getId());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(3);\r\n    assertEquals(ActivitiEventType.ENTITY_ACTIVATED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertNotEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    listener.clearEventsReceived();\r\n    repositoryService.suspendProcessDefinitionById(processInstance.getProcessDefinitionId(), true, null);\r\n    repositoryService.activateProcessDefinitionById(processInstance.getProcessDefinitionId(), true, null);\r\n    assertEquals(4, listener.getEventsReceived().size());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);\r\n    assertEquals(processInstance.getId(), ((ProcessInstance) event.getEntity()).getId());\r\n    assertEquals(ActivitiEventType.ENTITY_SUSPENDED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);\r\n    assertEquals(ActivitiEventType.ENTITY_SUSPENDED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertNotEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(2);\r\n    assertEquals(ActivitiEventType.ENTITY_ACTIVATED, event.getType());\r\n    assertEquals(processInstance.getId(), ((ProcessInstance) event.getEntity()).getId());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(3);\r\n    assertEquals(ActivitiEventType.ENTITY_ACTIVATED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertNotEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    listener.clearEventsReceived();\r\n    runtimeService.updateBusinessKey(processInstance.getId(), \"thekey\");\r\n    assertEquals(1, listener.getEventsReceived().size());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);\r\n    assertEquals(processInstance.getId(), ((ProcessInstance) event.getEntity()).getId());\r\n    assertEquals(ActivitiEventType.ENTITY_UPDATED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    listener.clearEventsReceived();\r\n    runtimeService.deleteProcessInstance(processInstance.getId(), \"Testing events\");\r\n    List<ActivitiEvent> processCancelledEvents = listener.filterEvents(ActivitiEventType.PROCESS_CANCELLED);\r\n    assertEquals(1, processCancelledEvents.size());\r\n    ActivitiCancelledEvent cancelledEvent = (ActivitiCancelledEvent) processCancelledEvents.get(0);\r\n    assertEquals(ActivitiEventType.PROCESS_CANCELLED, cancelledEvent.getType());\r\n    assertEquals(processInstance.getId(), cancelledEvent.getProcessInstanceId());\r\n    assertEquals(processInstance.getId(), cancelledEvent.getExecutionId());\r\n    listener.clearEventsReceived();\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.listener.ExpressionTaskListener.getExpressionText",
	"Comment": "returns the expression text for this task listener. comes in handy if you want to check which listeners you already have.",
	"Method": "String getExpressionText(){\r\n    return expression.getExpressionText();\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONArray.optString",
	"Comment": "get the optional string associated with an index. the defaultvalue is returned if the key is not found.",
	"Method": "String optString(int index,String optString,int index,String defaultValue){\r\n    Object o = opt(index);\r\n    return o != null ? o.toString() : defaultValue;\r\n}"
}, {
	"Path": "org.antlr.v4.tool.Grammar.isTokenName",
	"Comment": "is id a valid token name? does id start with an uppercase letter?",
	"Method": "boolean isTokenName(String id){\r\n    return Character.isUpperCase(id.charAt(0));\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONObject.optInt",
	"Comment": "get an optional int value associated with a key, or the default if there is no such key or if the value is not a number. if the value is a string, an attempt will be made to evaluate it as anumber.",
	"Method": "int optInt(String key,int optInt,String key,int defaultValue){\r\n    try {\r\n        return getInt(key);\r\n    } catch (Exception e) {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "org.apache.commons.net.SocketClient.getSoTimeout",
	"Comment": "returns the timeout in milliseconds of the currently opened socket.",
	"Method": "int getSoTimeout(){\r\n    return _socket_.getSoTimeout();\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.BootstrapDropDown.setOnDropDownItemClickListener",
	"Comment": "sets a listener which will be called when an item is clicked in the dropdown.",
	"Method": "void setOnDropDownItemClickListener(OnDropDownItemClickListener onDropDownItemClickListener){\r\n    this.onDropDownItemClickListener = onDropDownItemClickListener;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONTokener.next",
	"Comment": "consume the next character, and check that it matches a specified character.",
	"Method": "char next(char next,char c,String next,int n){\r\n    if (n == 0) {\r\n        return \"\";\r\n    }\r\n    char[] buffer = new char[n];\r\n    int pos = 0;\r\n    while (pos < n) {\r\n        buffer[pos] = next();\r\n        if (end()) {\r\n            throw syntaxError(\"Substring bounds error\");\r\n        }\r\n        pos += 1;\r\n    }\r\n    return new String(buffer);\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetOption.getOption",
	"Comment": "returns the string representation of the telnet protocol optioncorresponding to the given option code.",
	"Method": "String getOption(int code){\r\n    if (__optionString[code].length() == 0) {\r\n        return \"UNASSIGNED\";\r\n    } else {\r\n        return __optionString[code];\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.CDL.rowToJSONArray",
	"Comment": "produce a jsonarray of strings from a row of comma delimited values.",
	"Method": "JSONArray rowToJSONArray(JSONTokener x){\r\n    JSONArray ja = new JSONArray();\r\n    for (; ; ) {\r\n        String value = getValue(x);\r\n        char c = x.next();\r\n        if (value == null || (ja.length() == 0 && value.length() == 0 && c != ',')) {\r\n            return null;\r\n        }\r\n        ja.put(value);\r\n        for (; ; ) {\r\n            if (c == ',') {\r\n                break;\r\n            }\r\n            if (c != ' ') {\r\n                if (c == '\\n' || c == '\\r' || c == 0) {\r\n                    return ja;\r\n                }\r\n                throw x.syntaxError(\"Bad character '\" + c + \"' (\" + (int) c + \").\");\r\n            }\r\n            c = x.next();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.AwesomeTextView.setTypicon",
	"Comment": "sets the text to display a fonticon, replacing whatever text is already present.used to set the text to display a typicon.",
	"Method": "void setTypicon(CharSequence iconCode){\r\n    setBootstrapText(new BootstrapText.Builder(getContext(), isInEditMode()).addTypicon(iconCode).build());\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.deployer.BpmnDeployer.getPreviousVersionsOfProcessDefinitions",
	"Comment": "constructs a map from new processdefinitionentities to the previous version by key and tenant.if no previous version exists, no map entry is created.",
	"Method": "Map<ProcessDefinitionEntity, ProcessDefinitionEntity> getPreviousVersionsOfProcessDefinitions(ParsedDeployment parsedDeployment){\r\n    Map<ProcessDefinitionEntity, ProcessDefinitionEntity> result = new LinkedHashMap<ProcessDefinitionEntity, ProcessDefinitionEntity>();\r\n    for (ProcessDefinitionEntity newDefinition : parsedDeployment.getAllProcessDefinitions()) {\r\n        ProcessDefinitionEntity existingDefinition = bpmnDeploymentHelper.getMostRecentVersionOfProcessDefinition(newDefinition);\r\n        if (existingDefinition != null) {\r\n            result.put(newDefinition, existingDefinition);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONArray.length",
	"Comment": "get the number of elements in the jsonarray, included nulls.",
	"Method": "int length(){\r\n    return this.myArrayList.size();\r\n}"
}, {
	"Path": "com.facebook.buck.android.apkmodule.APKModuleGraph.generateGraph",
	"Comment": "generate the graph by identifying root targets, then marking targets with the seeds they arereachable with, then consolidating the targets reachable by multiple seeds into shared modules",
	"Method": "DirectedAcyclicGraph<APKModule> generateGraph(){\r\n    MutableDirectedGraph<APKModule> apkModuleGraph = new MutableDirectedGraph();\r\n    apkModuleGraph.addNode(rootAPKModuleSupplier.get());\r\n    if (getSeedConfigMap().isPresent()) {\r\n        Multimap<BuildTarget, String> targetToContainingApkModulesMap = mapTargetsToContainingModules();\r\n        generateSharedModules(apkModuleGraph, targetToContainingApkModulesMap);\r\n        Map<String, APKModule> nameToAPKModules = new HashMap();\r\n        for (APKModule node : apkModuleGraph.getNodes()) {\r\n            nameToAPKModules.put(node.getName(), node);\r\n        }\r\n        DirectedAcyclicGraph<String> declaredDependencies = getDeclaredDependencyGraph();\r\n        for (String source : declaredDependencies.getNodes()) {\r\n            for (String sink : declaredDependencies.getOutgoingNodesFor(source)) {\r\n                apkModuleGraph.addEdge(nameToAPKModules.get(source), nameToAPKModules.get(sink));\r\n            }\r\n        }\r\n    }\r\n    return new DirectedAcyclicGraph(apkModuleGraph);\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.BootstrapProgressBar.createRoundedBitmap",
	"Comment": "creates a rounded bitmap with transparent corners, from a square bitmap.see stackoverflow",
	"Method": "Bitmap createRoundedBitmap(Bitmap bitmap,float cornerRadius,boolean roundRight,boolean roundLeft){\r\n    Bitmap roundedBitmap = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), ARGB_8888);\r\n    Canvas canvas = new Canvas(roundedBitmap);\r\n    final Paint paint = new Paint();\r\n    final Rect frame = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());\r\n    final Rect leftRect = new Rect(0, 0, bitmap.getWidth() / 2, bitmap.getHeight());\r\n    final Rect rightRect = new Rect(bitmap.getWidth() / 2, 0, bitmap.getWidth(), bitmap.getHeight());\r\n    paint.setAntiAlias(true);\r\n    paint.setColor(0xFFFFFFFF);\r\n    paint.setStyle(Paint.Style.FILL);\r\n    canvas.drawARGB(0, 0, 0, 0);\r\n    canvas.drawRoundRect(new RectF(frame), cornerRadius, cornerRadius, paint);\r\n    if (!roundLeft) {\r\n        canvas.drawRect(leftRect, paint);\r\n    }\r\n    if (!roundRight) {\r\n        canvas.drawRect(rightRect, paint);\r\n    }\r\n    paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\r\n    canvas.drawBitmap(bitmap, frame, frame, paint);\r\n    return roundedBitmap;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONObject.optLong",
	"Comment": "get an optional long value associated with a key, or the default if there is no such key or if the value is not a number. if the value is a string, an attempt will be made to evaluate it as anumber.",
	"Method": "long optLong(String key,long optLong,String key,long defaultValue){\r\n    try {\r\n        return getLong(key);\r\n    } catch (Exception e) {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "com.taobao.arthas.core.shell.command.Command.create",
	"Comment": "create a command from a java class, annotated with cli annotations.",
	"Method": "Command create(Class<? extends AnnotatedCommand> clazz){\r\n    return new AnnotatedCommandImpl(clazz);\r\n}"
}, {
	"Path": "org.asynchttpclient.util.ProxyUtils.getJdkDefaultProxyServerSelector",
	"Comment": "get a proxy server selector based on the jdk default proxy selector.",
	"Method": "ProxyServerSelector getJdkDefaultProxyServerSelector(){\r\n    return createProxyServerSelector(ProxySelector.getDefault());\r\n}"
}, {
	"Path": "org.asynchttpclient.ntlm.NtlmEngine.lmResponse",
	"Comment": "creates the lm response from the given hash and type 2 challenge.",
	"Method": "byte[] lmResponse(byte[] hash,byte[] challenge){\r\n    try {\r\n        final byte[] keyBytes = new byte[21];\r\n        System.arraycopy(hash, 0, keyBytes, 0, 16);\r\n        final Key lowKey = createDESKey(keyBytes, 0);\r\n        final Key middleKey = createDESKey(keyBytes, 7);\r\n        final Key highKey = createDESKey(keyBytes, 14);\r\n        final Cipher des = Cipher.getInstance(\"DES/ECB/NoPadding\");\r\n        des.init(Cipher.ENCRYPT_MODE, lowKey);\r\n        final byte[] lowResponse = des.doFinal(challenge);\r\n        des.init(Cipher.ENCRYPT_MODE, middleKey);\r\n        final byte[] middleResponse = des.doFinal(challenge);\r\n        des.init(Cipher.ENCRYPT_MODE, highKey);\r\n        final byte[] highResponse = des.doFinal(challenge);\r\n        final byte[] lmResponse = new byte[24];\r\n        System.arraycopy(lowResponse, 0, lmResponse, 0, 8);\r\n        System.arraycopy(middleResponse, 0, lmResponse, 8, 8);\r\n        System.arraycopy(highResponse, 0, lmResponse, 16, 8);\r\n        return lmResponse;\r\n    } catch (final Exception e) {\r\n        throw new NtlmEngineException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.artifact_cache.AbstractAsynchronousCache.getMultiFetchBatchSize",
	"Comment": "used to compute the number of keys to include in every multifetchrequest. if1, fetch will beused instead of multifetch.",
	"Method": "int getMultiFetchBatchSize(int pendingRequestsSize){\r\n    return 0;\r\n}"
}, {
	"Path": "com.google.auto.value.processor.Optionalish.createIfOptional",
	"Comment": "returns an instance wrapping the given typemirror, or null if it is not any kind of optional.",
	"Method": "Optionalish createIfOptional(TypeMirror type){\r\n    if (isOptional(type)) {\r\n        return new Optionalish(MoreTypes.asDeclared(type));\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.core.build.engine.impl.MetadataChecker.deleteScratchDir",
	"Comment": "special case deletion for scratch dir since build.log is open, which is a problem for windows",
	"Method": "void deleteScratchDir(ProjectFilesystem filesystem){\r\n    Path scratchDir = filesystem.getPathForRelativePath(filesystem.getBuckPaths().getScratchDir());\r\n    Files.walkFileTree(scratchDir, new SimpleFileVisitor<Path>() {\r\n        @Override\r\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\r\n            if (!file.getFileName().toString().equals(\"build.log\")) {\r\n                Files.delete(file);\r\n            }\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n        @Override\r\n        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\r\n            if (exc != null) {\r\n                throw exc;\r\n            }\r\n            if (!dir.equals(scratchDir)) {\r\n                Files.delete(dir);\r\n            }\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.facebook.buck.core.build.engine.impl.MetadataChecker.deleteScratchDir",
	"Comment": "special case deletion for scratch dir since build.log is open, which is a problem for windows",
	"Method": "void deleteScratchDir(ProjectFilesystem filesystem){\r\n    if (!file.getFileName().toString().equals(\"build.log\")) {\r\n        Files.delete(file);\r\n    }\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "com.facebook.buck.core.build.engine.impl.MetadataChecker.deleteScratchDir",
	"Comment": "special case deletion for scratch dir since build.log is open, which is a problem for windows",
	"Method": "void deleteScratchDir(ProjectFilesystem filesystem){\r\n    if (exc != null) {\r\n        throw exc;\r\n    }\r\n    if (!dir.equals(scratchDir)) {\r\n        Files.delete(dir);\r\n    }\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.event.ProcessDefinitionEventsTest.testProcessDefinitionEvents",
	"Comment": "test create, update and delete events of process definitions.",
	"Method": "void testProcessDefinitionEvents(){\r\n    ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery().processDefinitionKey(\"oneTaskProcess\").singleResult();\r\n    assertNotNull(processDefinition);\r\n    assertEquals(2, listener.getEventsReceived().size());\r\n    assertTrue(listener.getEventsReceived().get(0) instanceof ActivitiEntityEvent);\r\n    ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);\r\n    assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());\r\n    assertEquals(processDefinition.getId(), ((ProcessDefinition) event.getEntity()).getId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);\r\n    assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());\r\n    assertEquals(processDefinition.getId(), ((ProcessDefinition) event.getEntity()).getId());\r\n    listener.clearEventsReceived();\r\n    repositoryService.setProcessDefinitionCategory(processDefinition.getId(), \"test\");\r\n    assertEquals(1, listener.getEventsReceived().size());\r\n    assertTrue(listener.getEventsReceived().get(0) instanceof ActivitiEntityEvent);\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);\r\n    assertEquals(ActivitiEventType.ENTITY_UPDATED, event.getType());\r\n    assertEquals(processDefinition.getId(), ((ProcessDefinition) event.getEntity()).getId());\r\n    assertEquals(\"test\", ((ProcessDefinition) event.getEntity()).getCategory());\r\n    listener.clearEventsReceived();\r\n    repositoryService.suspendProcessDefinitionById(processDefinition.getId());\r\n    repositoryService.activateProcessDefinitionById(processDefinition.getId());\r\n    assertEquals(2, listener.getEventsReceived().size());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);\r\n    assertEquals(processDefinition.getId(), ((ProcessDefinition) event.getEntity()).getId());\r\n    assertEquals(ActivitiEventType.ENTITY_SUSPENDED, event.getType());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);\r\n    assertEquals(ActivitiEventType.ENTITY_ACTIVATED, event.getType());\r\n    assertEquals(processDefinition.getId(), ((ProcessDefinition) event.getEntity()).getId());\r\n    listener.clearEventsReceived();\r\n    repositoryService.deleteDeployment(processDefinition.getDeploymentId(), true);\r\n    deploymentIdFromDeploymentAnnotation = null;\r\n    assertEquals(1, listener.getEventsReceived().size());\r\n    assertTrue(listener.getEventsReceived().get(0) instanceof ActivitiEntityEvent);\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);\r\n    assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());\r\n    assertEquals(processDefinition.getId(), ((ProcessDefinition) event.getEntity()).getId());\r\n    listener.clearEventsReceived();\r\n}"
}, {
	"Path": "com.facebook.buck.android.support.exopackage.DelegatingClassLoader.loadManagedClass",
	"Comment": "try to load the class definition from the dexfiles that this loader manages. does not delegateto parent. users of delegatingclassloader should prefer calling this whenever the class isknown to exist in a hotswappable module.",
	"Method": "Class<?> loadManagedClass(String className){\r\n    if (mDelegate == null) {\r\n        throw new RuntimeException(\"DelegatingCL was not initialized via ExopackageDexLoader.loadExopackageJars\");\r\n    }\r\n    try {\r\n        Class<?> clazz = (Class<?>) sFIND_LOADED_CLASS.invoke(mDelegate, className);\r\n        if (clazz == null) {\r\n            DexFile origin = mManagedClassesToDexFile.get(className);\r\n            if (origin == null) {\r\n                throw new ClassNotFoundException(\"Unable to find class \" + className);\r\n            }\r\n            clazz = origin.loadClass(className, mDelegate);\r\n        }\r\n        return clazz;\r\n    } catch (Exception e) {\r\n        throw new ClassNotFoundException(\"Unable to find class \" + className, e.getCause());\r\n    }\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.DiagnosticErrorListener.getConflictingAlts",
	"Comment": "computes the set of conflicting or ambiguous alternatives from a\tconfiguration set, if that information was not already provided by the\tparser.",
	"Method": "BitSet getConflictingAlts(BitSet reportedAlts,ATNConfigSet configs){\r\n    if (reportedAlts != null) {\r\n        return reportedAlts;\r\n    }\r\n    BitSet result = new BitSet();\r\n    for (ATNConfig config : configs) {\r\n        result.set(config.alt);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.facebook.buck.artifact_cache.MultiArtifactCache.fetchAsync",
	"Comment": "fetch the artifact matching rulekey and store it to output. if any of the encapsulatedartifactcaches contains the desired artifact, this method succeeds, and it may store theartifact to one or more of the other encapsulated artifactcaches as a side effect.",
	"Method": "ListenableFuture<CacheResult> fetchAsync(BuildTarget target,RuleKey ruleKey,LazyPath output){\r\n    ListenableFuture<CacheResult> cacheResult = Futures.immediateFuture(CacheResult.miss());\r\n    ImmutableList.Builder<ArtifactCache> cachesToFill = ImmutableList.builder();\r\n    for (ArtifactCache artifactCache : artifactCaches) {\r\n        cacheResult = Futures.transformAsync(cacheResult, (result) -> {\r\n            if (result.getType().isSuccess()) {\r\n                return Futures.immediateFuture(result);\r\n            }\r\n            if (artifactCache.getCacheReadMode().isWritable()) {\r\n                cachesToFill.add(artifactCache);\r\n            }\r\n            return artifactCache.fetchAsync(target, ruleKey, output);\r\n        }, MoreExecutors.directExecutor());\r\n    }\r\n    return Futures.transform(cacheResult, (CacheResult result) -> {\r\n        if (!result.getType().isSuccess()) {\r\n            return result;\r\n        }\r\n        storeToCaches(cachesToFill.build(), ArtifactInfo.builder().addRuleKeys(ruleKey).setMetadata(result.getMetadata()).build(), BorrowablePath.notBorrowablePath(output.getUnchecked()));\r\n        return result;\r\n    }, MoreExecutors.directExecutor());\r\n}"
}, {
	"Path": "com.facebook.buck.apple.toolchain.AbstractProvisioningProfileMetadata.prefixFromEntitlements",
	"Comment": "takes an immutablemap representing an entitlements file, returns the application prefix if itcan be inferred from keys in the entitlement. otherwise, it returns empty.",
	"Method": "Optional<String> prefixFromEntitlements(ImmutableMap<String, NSObject> entitlements){\r\n    try {\r\n        NSArray keychainAccessGroups = ((NSArray) entitlements.get(\"keychain-access-groups\"));\r\n        Objects.requireNonNull(keychainAccessGroups);\r\n        String appID = keychainAccessGroups.objectAtIndex(0).toString();\r\n        return Optional.of(splitAppID(appID).getFirst());\r\n    } catch (RuntimeException e) {\r\n        return Optional.empty();\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.listener.DelegateExpressionTransactionDependentTaskListener.getExpressionText",
	"Comment": "returns the expression text for this task listener. comes in handy if you want to check which listeners you already have.",
	"Method": "String getExpressionText(){\r\n    return expression.getExpressionText();\r\n}"
}, {
	"Path": "org.antlr.v4.tool.Grammar.getAllCharValues",
	"Comment": "return min to max char as defined by the target.\t if no target, use max unicode char value.",
	"Method": "IntSet getAllCharValues(){\r\n    return IntervalSet.of(Lexer.MIN_CHAR_VALUE, getMaxCharValue());\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetClient.disconnect",
	"Comment": "disconnects the telnet session, closing the input and output streamsas well as the socket.if you have references to theinput and output streams of the telnet connection, you should notclose them yourself, but rather call disconnect to properly closethe connection.",
	"Method": "void disconnect(){\r\n    if (__input != null) {\r\n        __input.close();\r\n    }\r\n    if (__output != null) {\r\n        __output.close();\r\n    }\r\n    super.disconnect();\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.parser.factory.DefaultActivityBehaviorFactory.createCamelActivityBehavior",
	"Comment": "activitybehavior and instantiate the delegate instance using a string instead of the class itself.",
	"Method": "ActivityBehavior createCamelActivityBehavior(ServiceTask serviceTask,ActivityBehavior createCamelActivityBehavior,SendTask sendTask,ActivityBehavior createCamelActivityBehavior,TaskWithFieldExtensions task,List<FieldExtension> fieldExtensions){\r\n    try {\r\n        Class<?> theClass = null;\r\n        FieldExtension behaviorExtension = null;\r\n        for (FieldExtension fieldExtension : fieldExtensions) {\r\n            if (\"camelBehaviorClass\".equals(fieldExtension.getFieldName()) && StringUtils.isNotEmpty(fieldExtension.getStringValue())) {\r\n                theClass = Class.forName(fieldExtension.getStringValue());\r\n                behaviorExtension = fieldExtension;\r\n                break;\r\n            }\r\n        }\r\n        if (behaviorExtension != null) {\r\n            fieldExtensions.remove(behaviorExtension);\r\n        }\r\n        if (theClass == null) {\r\n            theClass = Class.forName(\"org.activiti.camel.impl.CamelBehaviorDefaultImpl\");\r\n        }\r\n        List<FieldDeclaration> fieldDeclarations = createFieldDeclarations(fieldExtensions);\r\n        addExceptionMapAsFieldDeclaration(fieldDeclarations, task.getMapExceptions());\r\n        return (ActivityBehavior) ClassDelegate.defaultInstantiateDelegate(theClass, fieldDeclarations);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new ActivitiException(\"Could not find org.activiti.camel.CamelBehavior: \", e);\r\n    }\r\n}"
}, {
	"Path": "com.google.auto.value.processor.AutoValueOrOneOfProcessor.abstractMethodsIn",
	"Comment": "returns the subset of all abstract methods in the given set of methods. a given methodsignature is only mentioned once, even if it is inherited on more than one path.",
	"Method": "ImmutableSet<ExecutableElement> abstractMethodsIn(ImmutableSet<ExecutableElement> methods){\r\n    Set<Name> noArgMethods = new HashSet();\r\n    ImmutableSet.Builder<ExecutableElement> abstracts = ImmutableSet.builder();\r\n    for (ExecutableElement method : methods) {\r\n        if (method.getModifiers().contains(Modifier.ABSTRACT)) {\r\n            boolean hasArgs = !method.getParameters().isEmpty();\r\n            if (hasArgs || noArgMethods.add(method.getSimpleName())) {\r\n                abstracts.add(method);\r\n            }\r\n        }\r\n    }\r\n    return abstracts.build();\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONTokener.skipTo",
	"Comment": "skip characters until the next character is the requested character. if the requested character is not found, no characters are skipped.",
	"Method": "char skipTo(char to){\r\n    char c;\r\n    try {\r\n        int startIndex = this.index;\r\n        int startCharacter = this.character;\r\n        int startLine = this.line;\r\n        reader.mark(Integer.MAX_VALUE);\r\n        do {\r\n            c = next();\r\n            if (c == 0) {\r\n                reader.reset();\r\n                this.index = startIndex;\r\n                this.character = startCharacter;\r\n                this.line = startLine;\r\n                return c;\r\n            }\r\n        } while (c != to);\r\n    } catch (IOException exc) {\r\n        throw new JSONException(exc);\r\n    }\r\n    back();\r\n    return c;\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.event.ActivitiEventDispatcherTest.addAndRemoveEventListenerAllEvents",
	"Comment": "test adding a listener and check if events are sent to it. also checks that after removal, no events are received.",
	"Method": "void addAndRemoveEventListenerAllEvents(){\r\n    TestActivitiEventListener newListener = new TestActivitiEventListener();\r\n    dispatcher.addEventListener(newListener);\r\n    ActivitiEntityEventImpl event1 = new ActivitiEntityEventImpl(processEngineConfiguration.getTaskEntityManager().create(), ActivitiEventType.ENTITY_CREATED);\r\n    ActivitiEntityEventImpl event2 = new ActivitiEntityEventImpl(processEngineConfiguration.getTaskEntityManager().create(), ActivitiEventType.ENTITY_CREATED);\r\n    dispatcher.dispatchEvent(event1);\r\n    dispatcher.dispatchEvent(event2);\r\n    assertEquals(2, newListener.getEventsReceived().size());\r\n    assertEquals(event1, newListener.getEventsReceived().get(0));\r\n    assertEquals(event2, newListener.getEventsReceived().get(1));\r\n    dispatcher.removeEventListener(newListener);\r\n    newListener.clearEventsReceived();\r\n    dispatcher.dispatchEvent(event1);\r\n    dispatcher.dispatchEvent(event2);\r\n    assertTrue(newListener.getEventsReceived().isEmpty());\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.atn.LexerPushModeAction.getMode",
	"Comment": "get the lexer mode this action should transition the lexer to.",
	"Method": "int getMode(){\r\n    return mode;\r\n}"
}, {
	"Path": "com.facebook.buck.cli.bootstrapper.filesystem.BuckUnixPath.of",
	"Comment": "create a new instance of buckunixpath. the implementation may use interning.",
	"Method": "BuckUnixPath of(BuckFileSystem fs,String path){\r\n    if (path.isEmpty()) {\r\n        return fs.getEmptyPath();\r\n    }\r\n    if (path.equals(\"/\")) {\r\n        return fs.getRootDirectory();\r\n    }\r\n    return new BuckUnixPath(fs, intern(normalizeAndCheck(path).split(\"/\")));\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.AwesomeTextView.setIcon",
	"Comment": "sets the text to display a fonticon, replacing whatever text is already present.used to set the text to display a fontawesome icon.",
	"Method": "void setIcon(CharSequence iconCode,IconSet iconSet){\r\n    setBootstrapText(new BootstrapText.Builder(getContext(), isInEditMode()).addIcon(iconCode, iconSet).build());\r\n}"
}, {
	"Path": "com.facebook.buck.core.build.engine.buildinfo.BuildInfo.getPathToMetadataDirectory",
	"Comment": "returns the path to a directory where metadata files for a build rule with the specified targetshould be stored.",
	"Method": "Path getPathToMetadataDirectory(BuildTarget target,ProjectFilesystem filesystem){\r\n    return BuildTargetPaths.getScratchPath(filesystem, target, \".%s/metadata/\");\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.deployer.BpmnDeploymentHelper.updateTimersAndEvents",
	"Comment": "updates all timers and events for the process definition.this removes obsolete message and signalsubscriptions and timers, and adds new ones.",
	"Method": "void updateTimersAndEvents(ProcessDefinitionEntity processDefinition,ProcessDefinitionEntity previousProcessDefinition,ParsedDeployment parsedDeployment){\r\n    Process process = parsedDeployment.getProcessModelForProcessDefinition(processDefinition);\r\n    BpmnModel bpmnModel = parsedDeployment.getBpmnModelForProcessDefinition(processDefinition);\r\n    eventSubscriptionManager.removeObsoleteMessageEventSubscriptions(previousProcessDefinition);\r\n    eventSubscriptionManager.addMessageEventSubscriptions(processDefinition, process, bpmnModel);\r\n    eventSubscriptionManager.removeObsoleteSignalEventSubScription(previousProcessDefinition);\r\n    eventSubscriptionManager.addSignalEventSubscriptions(Context.getCommandContext(), processDefinition, process, bpmnModel);\r\n    timerManager.removeObsoleteTimers(processDefinition);\r\n    timerManager.scheduleTimers(processDefinition, process);\r\n}"
}, {
	"Path": "com.google.auto.value.extension.memoized.processor.MemoizeExtension.annotatedReturnType",
	"Comment": "the return type of the given method, including type annotations.",
	"Method": "TypeName annotatedReturnType(ExecutableElement method){\r\n    TypeMirror returnType = method.getReturnType();\r\n    List<AnnotationSpec> annotations = returnType.getAnnotationMirrors().stream().map(AnnotationSpec::get).collect(toList());\r\n    return TypeName.get(returnType).annotated(annotations);\r\n}"
}, {
	"Path": "com.facebook.buck.apple.AppleAssetCatalog.strictlyValidateAssetCatalog",
	"Comment": "perform strict validation, guarding against missing contents.json and duplicate image names.",
	"Method": "void strictlyValidateAssetCatalog(Path catalogPath,Map<String, Path> catalogPathsForImageNames,List<String> errors,ProjectFilesystem projectFilesystem){\r\n    try {\r\n        for (Path asset : projectFilesystem.getDirectoryContents(catalogPath)) {\r\n            String assetName = asset.getFileName().toString();\r\n            if (assetName.equals(\"Contents.json\")) {\r\n                continue;\r\n            }\r\n            String[] parts = assetName.split(\"\\\\.\");\r\n            if (parts.length < 2) {\r\n                errors.add(String.format(\"Unexpected file in %s: '%s'\", catalogPath, assetName));\r\n            }\r\n            String assetType = parts[parts.length - 1];\r\n            if (!TYPES_REQUIRING_CONTENTS_JSON.contains(assetType)) {\r\n                continue;\r\n            }\r\n            boolean contentsJsonPresent = false;\r\n            for (Path assetContentPath : projectFilesystem.getDirectoryContents(asset)) {\r\n                String filename = assetContentPath.getFileName().toString();\r\n                if (filename.equals(\"Contents.json\")) {\r\n                    contentsJsonPresent = true;\r\n                    continue;\r\n                }\r\n                if (!assetType.equals(\"imageset\")) {\r\n                    continue;\r\n                }\r\n                String filenameKey = filename.toLowerCase();\r\n                if (catalogPathsForImageNames.containsKey(filenameKey)) {\r\n                    Path existingCatalogPath = catalogPathsForImageNames.get(filenameKey);\r\n                    if (catalogPath.equals(existingCatalogPath)) {\r\n                        continue;\r\n                    } else {\r\n                        errors.add(String.format(\"%s is included by two asset catalogs: '%s' and '%s'\", assetContentPath.getFileName(), catalogPath, existingCatalogPath));\r\n                    }\r\n                } else {\r\n                    catalogPathsForImageNames.put(filenameKey, catalogPath);\r\n                }\r\n            }\r\n            if (!contentsJsonPresent) {\r\n                errors.add(String.format(\"%s doesn't have Contents.json\", asset));\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        throw new HumanReadableException(\"Failed to process asset catalog at %s: %s\", catalogPath, e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.event.ActivitiEventDispatcherTest.exceptionInListener",
	"Comment": "test dispatching behavior when an exception occurs in the listener",
	"Method": "void exceptionInListener(){\r\n    TestExceptionActivitiEventListener listener = new TestExceptionActivitiEventListener(false);\r\n    TestActivitiEventListener secondListener = new TestActivitiEventListener();\r\n    dispatcher.addEventListener(listener);\r\n    dispatcher.addEventListener(secondListener);\r\n    ActivitiEventImpl event = new ActivitiEventImpl(ActivitiEventType.ENTITY_CREATED);\r\n    try {\r\n        dispatcher.dispatchEvent(event);\r\n        assertEquals(1, secondListener.getEventsReceived().size());\r\n    } catch (Throwable t) {\r\n        fail(\"No exception expected\");\r\n    }\r\n    dispatcher.removeEventListener(listener);\r\n    dispatcher.removeEventListener(secondListener);\r\n    listener = new TestExceptionActivitiEventListener(true);\r\n    secondListener = new TestActivitiEventListener();\r\n    dispatcher.addEventListener(listener);\r\n    dispatcher.addEventListener(secondListener);\r\n    try {\r\n        dispatcher.dispatchEvent(event);\r\n        fail(\"Exception expected\");\r\n    } catch (Throwable t) {\r\n        assertTrue(t instanceof ActivitiException);\r\n        assertTrue(t.getCause() instanceof RuntimeException);\r\n        assertEquals(\"Test exception\", t.getCause().getMessage());\r\n        assertEquals(0, secondListener.getEventsReceived().size());\r\n    }\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.BootstrapDropDown.setDropdownData",
	"Comment": "sets the string values which should be used to populate the menu displayed in the dropdown.",
	"Method": "void setDropdownData(String[] dropdownData){\r\n    this.dropdownData = dropdownData;\r\n    createDropDown();\r\n    updateDropDownState();\r\n}"
}, {
	"Path": "org.activiti.engine.impl.el.JsonNodeELResolver.isResolvable",
	"Comment": "test whether the given base should be resolved by this elresolver.",
	"Method": "boolean isResolvable(Object base){\r\n    return base instanceof JsonNode;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.calendar.CronExpression.getTimeZone",
	"Comment": "returns the time zone for which this cronexpression will be resolved.",
	"Method": "TimeZone getTimeZone(){\r\n    if (timeZone == null) {\r\n        timeZone = clockReader.getCurrentTimeZone();\r\n    }\r\n    return timeZone;\r\n}"
}, {
	"Path": "org.activiti.runtime.api.connector.DefaultServiceTaskBehavior.execute",
	"Comment": "we have two different implementation strategy that can be executedin according if we have a connector action definition match or not.",
	"Method": "void execute(DelegateExecution execution){\r\n    Connector connector;\r\n    IntegrationContext context;\r\n    String implementation = ((ServiceTask) execution.getCurrentFlowElement()).getImplementation();\r\n    List<VariableDefinition> outBoundVariableDefinitions = null;\r\n    if (connectorActionDefinitionFinder != null && connectorDefinitions != null) {\r\n        Optional<ActionDefinition> actionDefinitionOptional = connectorActionDefinitionFinder.find(implementation, connectorDefinitions);\r\n        ActionDefinition actionDefinition = null;\r\n        if (actionDefinitionOptional.isPresent()) {\r\n            actionDefinition = actionDefinitionOptional.get();\r\n            context = integrationContextBuilder.from(execution, actionDefinition);\r\n            connector = applicationContext.getBean(actionDefinition.getName(), Connector.class);\r\n        } else {\r\n            context = integrationContextBuilder.from(execution, null);\r\n            connector = applicationContext.getBean(implementation, Connector.class);\r\n        }\r\n        outBoundVariableDefinitions = actionDefinition == null ? null : actionDefinition.getOutput();\r\n    } else {\r\n        context = integrationContextBuilder.from(execution, null);\r\n        connector = applicationContext.getBean(implementation, Connector.class);\r\n    }\r\n    IntegrationContext results = connector.execute(context);\r\n    if (variablesMatchHelper != null) {\r\n        execution.setVariables(variablesMatchHelper.match(results.getOutBoundVariables(), outBoundVariableDefinitions));\r\n    } else {\r\n        execution.setVariables(results.getOutBoundVariables());\r\n    }\r\n    leave(execution);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONObject.append",
	"Comment": "append values to the array under a key. if the key does not exist in the jsonobject, then the key is put in the jsonobject with its value being a jsonarray containing the value parameter. if thekey was already associated with a jsonarray, then the value parameter is appended to it.",
	"Method": "JSONObject append(String key,Object value){\r\n    testValidity(value);\r\n    Object o = opt(key);\r\n    if (o == null) {\r\n        put(key, new JSONArray().put(value));\r\n    } else if (o instanceof JSONArray) {\r\n        put(key, ((JSONArray) o).put(value));\r\n    } else {\r\n        throw new JSONException(\"JSONObject[\" + key + \"] is not a JSONArray.\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.facebook.buck.apple.xcode.XcodeprojSerializer.toPlist",
	"Comment": "generate a plist serialization of project bound to this serializer.",
	"Method": "NSDictionary toPlist(){\r\n    serializeObject(rootObject);\r\n    NSDictionary root = new NSDictionary();\r\n    root.put(\"archiveVersion\", \"1\");\r\n    root.put(\"classes\", new NSDictionary());\r\n    root.put(\"objectVersion\", \"46\");\r\n    root.put(\"objects\", objects);\r\n    root.put(\"rootObject\", rootObject.getGlobalID());\r\n    return root;\r\n}"
}, {
	"Path": "com.taobao.arthas.common.ExecutingCommand.runNative",
	"Comment": "executes a command on the native command line and returns the result line byline.",
	"Method": "List<String> runNative(String cmdToRun,List<String> runNative,String[] cmdToRunWithArgs){\r\n    Process p = null;\r\n    try {\r\n        p = Runtime.getRuntime().exec(cmdToRunWithArgs);\r\n    } catch (SecurityException e) {\r\n        AnsiLog.trace(\"Couldn't run command {}:\", Arrays.toString(cmdToRunWithArgs));\r\n        AnsiLog.trace(e);\r\n        return new ArrayList<String>(0);\r\n    } catch (IOException e) {\r\n        AnsiLog.trace(\"Couldn't run command {}:\", Arrays.toString(cmdToRunWithArgs));\r\n        AnsiLog.trace(e);\r\n        return new ArrayList<String>(0);\r\n    }\r\n    ArrayList<String> sa = new ArrayList<String>();\r\n    BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));\r\n    try {\r\n        String line;\r\n        while ((line = reader.readLine()) != null) {\r\n            sa.add(line);\r\n        }\r\n        p.waitFor();\r\n    } catch (IOException e) {\r\n        AnsiLog.trace(\"Problem reading output from {}:\", Arrays.toString(cmdToRunWithArgs));\r\n        AnsiLog.trace(e);\r\n        return new ArrayList<String>(0);\r\n    } catch (InterruptedException ie) {\r\n        AnsiLog.trace(\"Problem reading output from {}:\", Arrays.toString(cmdToRunWithArgs));\r\n        AnsiLog.trace(ie);\r\n        Thread.currentThread().interrupt();\r\n    } finally {\r\n        IOUtils.close(reader);\r\n    }\r\n    return sa;\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.ParserInterpreter.recover",
	"Comment": "rely on the error handler for this parser but, if no tokens are consumed\t to recover, add an error node. otherwise, nothing is seen in the parse\t tree.",
	"Method": "void recover(RecognitionException e){\r\n    int i = _input.index();\r\n    getErrorHandler().recover(this, e);\r\n    if (_input.index() == i) {\r\n        if (e instanceof InputMismatchException) {\r\n            InputMismatchException ime = (InputMismatchException) e;\r\n            Token tok = e.getOffendingToken();\r\n            int expectedTokenType = Token.INVALID_TYPE;\r\n            if (!ime.getExpectedTokens().isNil()) {\r\n                expectedTokenType = ime.getExpectedTokens().getMinElement();\r\n            }\r\n            Token errToken = // invalid start/stop\r\n            getTokenFactory().create(// invalid start/stop\r\n            new Pair<TokenSource, CharStream>(tok.getTokenSource(), tok.getTokenSource().getInputStream()), // invalid start/stop\r\n            expectedTokenType, // invalid start/stop\r\n            tok.getText(), Token.DEFAULT_CHANNEL, -1, -1, tok.getLine(), tok.getCharPositionInLine());\r\n            _ctx.addErrorNode(createErrorNode(_ctx, errToken));\r\n        } else {\r\n            Token tok = e.getOffendingToken();\r\n            Token errToken = // invalid start/stop\r\n            getTokenFactory().create(// invalid start/stop\r\n            new Pair<TokenSource, CharStream>(tok.getTokenSource(), tok.getTokenSource().getInputStream()), // invalid start/stop\r\n            Token.INVALID_TYPE, // invalid start/stop\r\n            tok.getText(), Token.DEFAULT_CHANNEL, -1, -1, tok.getLine(), tok.getCharPositionInLine());\r\n            _ctx.addErrorNode(createErrorNode(_ctx, errToken));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.TypefaceProvider.getRegisteredIconSets",
	"Comment": "retrieves a collection of all registered iconsets in the application",
	"Method": "Collection<IconSet> getRegisteredIconSets(){\r\n    return REGISTERED_ICON_SETS.values();\r\n}"
}, {
	"Path": "com.facebook.buck.core.build.engine.impl.CachingBuildEngine.getDepResults",
	"Comment": "dispatch and return a future resolving to a list of all results of this rules dependencies.",
	"Method": "ListenableFuture<List<BuildResult>> getDepResults(BuildRule rule,BuildEngineBuildContext buildContext,ExecutionContext executionContext,ListenableFuture<List<BuildResult>> getDepResults,BuildRule rule,ExecutionContext executionContext){\r\n    List<ListenableFuture<BuildResult>> depResults = new ArrayList(SortedSets.sizeEstimate(rule.getBuildDeps()));\r\n    for (BuildRule dep : shuffled(rule.getBuildDeps())) {\r\n        depResults.add(getBuildRuleResultWithRuntimeDeps(dep, buildContext, executionContext));\r\n    }\r\n    return Futures.allAsList(depResults);\r\n}"
}, {
	"Path": "com.facebook.buck.apple.AbstractAppleBundleResources.getAll",
	"Comment": "returns all the sourcepaths from the different types of resources.",
	"Method": "Iterable<SourcePath> getAll(){\r\n    return Iterables.concat(getResourceDirs(), getDirsContainingResourceDirs(), getResourceFiles(), getResourceVariantFiles());\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONArray.toJSONObject",
	"Comment": "produce a jsonobject by combining a jsonarray of names with the values of this jsonarray.",
	"Method": "JSONObject toJSONObject(JSONArray names){\r\n    if (names == null || names.length() == 0 || length() == 0) {\r\n        return null;\r\n    }\r\n    JSONObject jo = new JSONObject();\r\n    for (int i = 0; i < names.length(); i += 1) {\r\n        jo.put(names.getString(i), this.opt(i));\r\n    }\r\n    return jo;\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetOptionHandler.setInitLocal",
	"Comment": "tells this option whether to send a will request upon connection.",
	"Method": "void setInitLocal(boolean init){\r\n    initialLocal = init;\r\n}"
}, {
	"Path": "org.asynchttpclient.ntlm.NtlmEngine.ntlm2SessionResponse",
	"Comment": "calculates the ntlm2 session response for the given challenge, using thespecified password and client challenge.",
	"Method": "byte[] ntlm2SessionResponse(byte[] ntlmHash,byte[] challenge,byte[] clientChallenge){\r\n    try {\r\n        final MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\r\n        md5.update(challenge);\r\n        md5.update(clientChallenge);\r\n        final byte[] digest = md5.digest();\r\n        final byte[] sessionHash = new byte[8];\r\n        System.arraycopy(digest, 0, sessionHash, 0, 8);\r\n        return lmResponse(ntlmHash, sessionHash);\r\n    } catch (final Exception e) {\r\n        if (e instanceof NtlmEngineException) {\r\n            throw (NtlmEngineException) e;\r\n        }\r\n        throw new NtlmEngineException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.android.relinker.NativeRelinker.getAllDependentsMap",
	"Comment": "creates a map from every buildrule to the set of transitive dependents of that buildrule thatare in the linkablerules set.",
	"Method": "ImmutableMap<BuildRule, ImmutableSet<BuildRule>> getAllDependentsMap(Set<BuildRule> linkableRules,DirectedAcyclicGraph<BuildRule> graph,ImmutableList<BuildRule> sortedRules){\r\n    Map<BuildRule, ImmutableSet<BuildRule>> allDependentsMap = new HashMap();\r\n    for (BuildRule rule : sortedRules.reverse()) {\r\n        ImmutableSet.Builder<BuildRule> transitiveDependents = ImmutableSet.builder();\r\n        for (BuildRule dependent : graph.getIncomingNodesFor(rule)) {\r\n            transitiveDependents.addAll(allDependentsMap.get(dependent));\r\n            if (linkableRules.contains(dependent)) {\r\n                transitiveDependents.add(dependent);\r\n            }\r\n        }\r\n        allDependentsMap.put(rule, transitiveDependents.build());\r\n    }\r\n    return ImmutableMap.copyOf(allDependentsMap);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.persistence.entity.SuspendedJobEntityManagerImpl.deleteExceptionByteArrayRef",
	"Comment": "deletes a the byte array used to store the exception information.subclasses may overrideto provide custom implementations.",
	"Method": "void deleteExceptionByteArrayRef(SuspendedJobEntity jobEntity){\r\n    ByteArrayRef exceptionByteArrayRef = jobEntity.getExceptionByteArrayRef();\r\n    if (exceptionByteArrayRef != null) {\r\n        exceptionByteArrayRef.delete();\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.deployer.BpmnDeploymentHelper.setResourceNamesOnProcessDefinitions",
	"Comment": "updates all the process definition entities to have the correct resource names.",
	"Method": "void setResourceNamesOnProcessDefinitions(ParsedDeployment parsedDeployment){\r\n    for (ProcessDefinitionEntity processDefinition : parsedDeployment.getAllProcessDefinitions()) {\r\n        String resourceName = parsedDeployment.getResourceForProcessDefinition(processDefinition).getName();\r\n        processDefinition.setResourceName(resourceName);\r\n    }\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.filter.GPUImageSphereRefractionFilter.setRefractiveIndex",
	"Comment": "the index of refraction for the sphere, with a default of 0.71",
	"Method": "void setRefractiveIndex(float refractiveIndex){\r\n    this.refractiveIndex = refractiveIndex;\r\n    setFloat(refractiveIndexLocation, refractiveIndex);\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.BootstrapProgressBar.startStripedAnimationIfNeeded",
	"Comment": "starts an infinite animation cycle which provides the visual effect of stripes movingbackwards. the current system time is used to offset tiled bitmaps of the progress background,producing the effect that the stripes are moving backwards.",
	"Method": "void startStripedAnimationIfNeeded(){\r\n    if (!striped || !animated) {\r\n        return;\r\n    }\r\n    clearAnimation();\r\n    progressAnimator = ValueAnimator.ofFloat(0, 0);\r\n    progressAnimator.setDuration(UPDATE_ANIM_MS);\r\n    progressAnimator.setRepeatCount(ValueAnimator.INFINITE);\r\n    progressAnimator.setRepeatMode(ValueAnimator.RESTART);\r\n    progressAnimator.setInterpolator(new LinearInterpolator());\r\n    progressAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r\n        @Override\r\n        public void onAnimationUpdate(ValueAnimator animation) {\r\n            invalidate();\r\n        }\r\n    });\r\n    progressAnimator.start();\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.BootstrapProgressBar.startStripedAnimationIfNeeded",
	"Comment": "starts an infinite animation cycle which provides the visual effect of stripes movingbackwards. the current system time is used to offset tiled bitmaps of the progress background,producing the effect that the stripes are moving backwards.",
	"Method": "void startStripedAnimationIfNeeded(){\r\n    invalidate();\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.DefaultErrorStrategy.endErrorCondition",
	"Comment": "this method is called to leave error recovery mode after recovering from\ta recognition exception.",
	"Method": "void endErrorCondition(Parser recognizer){\r\n    errorRecoveryMode = false;\r\n    lastErrorStates = null;\r\n    lastErrorIndex = -1;\r\n}"
}, {
	"Path": "org.antlr.v4.codegen.OutputModelController.buildRuleFunction",
	"Comment": "create rulefunction per rule and update sempreds,actions of parser\t output object with stuff found in r.",
	"Method": "void buildRuleFunction(Parser parser,Rule r){\r\n    RuleFunction function = rule(r);\r\n    parser.funcs.add(function);\r\n    pushCurrentRule(function);\r\n    function.fillNamedActions(delegate, r);\r\n    if (r instanceof LeftRecursiveRule) {\r\n        buildLeftRecursiveRuleFunction((LeftRecursiveRule) r, (LeftRecursiveRuleFunction) function);\r\n    } else {\r\n        buildNormalRuleFunction(r, function);\r\n    }\r\n    Grammar g = getGrammar();\r\n    for (ActionAST a : r.actions) {\r\n        if (a instanceof PredAST) {\r\n            PredAST p = (PredAST) a;\r\n            RuleSempredFunction rsf = parser.sempredFuncs.get(r);\r\n            if (rsf == null) {\r\n                rsf = new RuleSempredFunction(delegate, r, function.ctxType);\r\n                parser.sempredFuncs.put(r, rsf);\r\n            }\r\n            rsf.actions.put(g.sempreds.get(p), new Action(delegate, p));\r\n        }\r\n    }\r\n    popCurrentRule();\r\n}"
}, {
	"Path": "org.antlr.v4.tool.ErrorManager.getLastNonErrorManagerCodeLocation",
	"Comment": "return first non errormanager code location for generating messages",
	"Method": "StackTraceElement getLastNonErrorManagerCodeLocation(Throwable e){\r\n    StackTraceElement[] stack = e.getStackTrace();\r\n    int i = 0;\r\n    for (; i < stack.length; i++) {\r\n        StackTraceElement t = stack[i];\r\n        if (!t.toString().contains(\"ErrorManager\")) {\r\n            break;\r\n        }\r\n    }\r\n    StackTraceElement location = stack[i];\r\n    return location;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.calendar.CronExpression.setCalendarHour",
	"Comment": "advance the calendar to the particular hour paying particular attention to daylight saving problems.",
	"Method": "void setCalendarHour(Calendar cal,int hour){\r\n    cal.set(Calendar.HOUR_OF_DAY, hour);\r\n    if (cal.get(Calendar.HOUR_OF_DAY) != hour && hour != 24) {\r\n        cal.set(Calendar.HOUR_OF_DAY, hour + 1);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.core.build.engine.impl.CachingBuildEngine.serviceByAdjustingDefaultWeightsTo",
	"Comment": "we have a lot of places where tasks are submitted into a service implicitly. there is no way toassign custom weights to such tasks. by creating a temporary service with adjusted weights itis possible to trick the system and tweak the weights.",
	"Method": "WeightedListeningExecutorService serviceByAdjustingDefaultWeightsTo(ResourceAmounts defaultAmounts){\r\n    return resourceAwareSchedulingInfo.adjustServiceDefaultWeightsTo(defaultAmounts, service);\r\n}"
}, {
	"Path": "org.apache.commons.net.SocketClient.getDefaultTimeout",
	"Comment": "returns the default timeout in milliseconds that is used whenopening a socket.",
	"Method": "int getDefaultTimeout(){\r\n    return _timeout_;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.listener.ExpressionExecutionListener.getExpressionText",
	"Comment": "returns the expression text for this execution listener. comes in handy if you want to check which listeners you already have.",
	"Method": "String getExpressionText(){\r\n    return expression.getExpressionText();\r\n}"
}, {
	"Path": "org.antlr.v4.analysis.LeftRecursionDetector.addRulesToCycle",
	"Comment": "enclosingrule calls targetrule. find the cycle containing\t the target and add the caller.find the cycle containing the caller\t and add the target.if no cycles contain either, then create a new\t cycle.",
	"Method": "void addRulesToCycle(Rule enclosingRule,Rule targetRule){\r\n    boolean foundCycle = false;\r\n    for (Set<Rule> rulesInCycle : listOfRecursiveCycles) {\r\n        if (rulesInCycle.contains(targetRule)) {\r\n            rulesInCycle.add(enclosingRule);\r\n            foundCycle = true;\r\n        }\r\n        if (rulesInCycle.contains(enclosingRule)) {\r\n            rulesInCycle.add(targetRule);\r\n            foundCycle = true;\r\n        }\r\n    }\r\n    if (!foundCycle) {\r\n        Set<Rule> cycle = new OrderedHashSet<Rule>();\r\n        cycle.add(targetRule);\r\n        cycle.add(enclosingRule);\r\n        listOfRecursiveCycles.add(cycle);\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONArray.optInt",
	"Comment": "get the optional int value associated with an index. the defaultvalue is returned if there is no value for the index, or if the value is not a number and cannot be converted to a number.",
	"Method": "int optInt(int index,int optInt,int index,int defaultValue){\r\n    try {\r\n        return getInt(index);\r\n    } catch (Exception e) {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.behavior.CallActivityBehavior.initializeVariables",
	"Comment": "allow a subclass to override how variables are initialized.",
	"Method": "void initializeVariables(ExecutionEntity subProcessInstance,Map<String, Object> variables){\r\n    subProcessInstance.setVariables(variables);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.deployer.BpmnDeploymentHelper.getMostRecentVersionOfProcessDefinition",
	"Comment": "gets the most recent persisted process definition that matches this one for tenant and key.if none is found, returns null.this method assumes that the tenant and key are properlyset on the process definition entity.",
	"Method": "ProcessDefinitionEntity getMostRecentVersionOfProcessDefinition(ProcessDefinitionEntity processDefinition){\r\n    String key = processDefinition.getKey();\r\n    String tenantId = processDefinition.getTenantId();\r\n    ProcessDefinitionEntityManager processDefinitionManager = Context.getCommandContext().getProcessEngineConfiguration().getProcessDefinitionEntityManager();\r\n    ProcessDefinitionEntity existingDefinition = null;\r\n    if (tenantId != null && !tenantId.equals(ProcessEngineConfiguration.NO_TENANT_ID)) {\r\n        existingDefinition = processDefinitionManager.findLatestProcessDefinitionByKeyAndTenantId(key, tenantId);\r\n    } else {\r\n        existingDefinition = processDefinitionManager.findLatestProcessDefinitionByKey(key);\r\n    }\r\n    return existingDefinition;\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.WindowSizeOptionHandler.startSubnegotiationLocal",
	"Comment": "implements the abstract method of telnetoptionhandler.this will send the client height and width to the server.",
	"Method": "int[] startSubnegotiationLocal(){\r\n    int nCompoundWindowSize = m_nWidth * 0x10000 + m_nHeight;\r\n    int nResponseSize = 5;\r\n    int nIndex;\r\n    int nShift;\r\n    int nTurnedOnBits;\r\n    if ((m_nWidth % 0x100) == 0xFF) {\r\n        nResponseSize += 1;\r\n    }\r\n    if ((m_nWidth / 0x100) == 0xFF) {\r\n        nResponseSize += 1;\r\n    }\r\n    if ((m_nHeight % 0x100) == 0xFF) {\r\n        nResponseSize += 1;\r\n    }\r\n    if ((m_nHeight / 0x100) == 0xFF) {\r\n        nResponseSize += 1;\r\n    }\r\n    int[] response = new int[nResponseSize];\r\n    response[0] = WINDOW_SIZE;\r\n    for (nIndex = 1, nShift = 24; nIndex < nResponseSize; nIndex++, nShift -= 8) {\r\n        nTurnedOnBits = 0xFF;\r\n        nTurnedOnBits <<= nShift;\r\n        response[nIndex] = (nCompoundWindowSize & nTurnedOnBits) >>> nShift;\r\n        if (response[nIndex] == 0xff) {\r\n            nIndex++;\r\n            response[nIndex] = 0xff;\r\n        }\r\n    }\r\n    return response;\r\n}"
}, {
	"Path": "com.google.auto.value.processor.BuilderMethodClassifier.classifyMethod",
	"Comment": "classifies a method and update the state of this object based on what is found.",
	"Method": "boolean classifyMethod(ExecutableElement method){\r\n    switch(method.getParameters().size()) {\r\n        case 0:\r\n            return classifyMethodNoArgs(method);\r\n        case 1:\r\n            return classifyMethodOneArg(method);\r\n        default:\r\n            errorReporter.reportError(\"Builder methods must have 0 or 1 parameters\", method);\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.persistence.entity.JobEntityManagerImpl.deleteExceptionByteArrayRef",
	"Comment": "deletes a the byte array used to store the exception information.subclasses may overrideto provide custom implementations.",
	"Method": "void deleteExceptionByteArrayRef(JobEntity jobEntity){\r\n    ByteArrayRef exceptionByteArrayRef = jobEntity.getExceptionByteArrayRef();\r\n    if (exceptionByteArrayRef != null) {\r\n        exceptionByteArrayRef.delete();\r\n    }\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.Parser.setTrace",
	"Comment": "during a parse is sometimes useful to listen in on the rule entry and exit\t events as well as token matches. this is for quick and dirty debugging.",
	"Method": "void setTrace(boolean trace){\r\n    if (!trace) {\r\n        removeParseListener(_tracer);\r\n        _tracer = null;\r\n    } else {\r\n        if (_tracer != null)\r\n            removeParseListener(_tracer);\r\n        else\r\n            _tracer = new TraceListener();\r\n        addParseListener(_tracer);\r\n    }\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.atn.SemanticContext.evalPrecedence",
	"Comment": "evaluate the precedence predicates for the context and reduce the result.",
	"Method": "SemanticContext evalPrecedence(Recognizer<?, ?> parser,RuleContext parserCallStack,SemanticContext evalPrecedence,Recognizer<?, ?> parser,RuleContext parserCallStack,SemanticContext evalPrecedence,Recognizer<?, ?> parser,RuleContext parserCallStack,SemanticContext evalPrecedence,Recognizer<?, ?> parser,RuleContext parserCallStack){\r\n    return this;\r\n}"
}, {
	"Path": "com.roughike.bottombar.BottomBar.setLongPressHintsEnabled",
	"Comment": "controls whether the long pressed tab title should be displayed ina helpful toast if the title is not currently visible.",
	"Method": "void setLongPressHintsEnabled(boolean enabled){\r\n    longPressHintsEnabled = enabled;\r\n}"
}, {
	"Path": "org.antlr.v4.tool.ErrorManager.getLocationFormat",
	"Comment": "return a stringtemplate that refers to the current format used foremitting messages.",
	"Method": "ST getLocationFormat(){\r\n    return format.getInstanceOf(\"location\");\r\n}"
}, {
	"Path": "com.facebook.buck.apple.xcode.xcodeproj.PBXShellScriptBuildPhase.setShellPath",
	"Comment": "sets the path to the shell under which the script is to be executed.",
	"Method": "void setShellPath(String shellPath){\r\n    this.shellPath = shellPath;\r\n}"
}, {
	"Path": "org.antlr.v4.tool.BuildDependencyGenerator.getGeneratedFileList",
	"Comment": "from t.g return a list of file objects that name files antlr will emit from t.g.",
	"Method": "List<File> getGeneratedFileList(){\r\n    List<File> files = new ArrayList<File>();\r\n    if (generator.getTarget().needsHeader()) {\r\n        files.add(getOutputFile(generator.getRecognizerFileName(true)));\r\n    }\r\n    files.add(getOutputFile(generator.getRecognizerFileName(false)));\r\n    files.add(getOutputFile(generator.getVocabFileName()));\r\n    ST headerExtST = null;\r\n    ST extST = generator.getTemplates().getInstanceOf(\"codeFileExtension\");\r\n    if (generator.getTemplates().isDefined(\"headerFile\")) {\r\n        headerExtST = generator.getTemplates().getInstanceOf(\"headerFileExtension\");\r\n        String suffix = Grammar.getGrammarTypeToFileNameSuffix(g.getType());\r\n        String fileName = g.name + suffix + headerExtST.render();\r\n        files.add(getOutputFile(fileName));\r\n    }\r\n    if (g.isCombined()) {\r\n        String suffix = Grammar.getGrammarTypeToFileNameSuffix(ANTLRParser.LEXER);\r\n        String lexer = g.name + suffix + extST.render();\r\n        files.add(getOutputFile(lexer));\r\n        String lexerTokens = g.name + suffix + CodeGenerator.VOCAB_FILE_EXTENSION;\r\n        files.add(getOutputFile(lexerTokens));\r\n        if (headerExtST != null) {\r\n            String header = g.name + suffix + headerExtST.render();\r\n            files.add(getOutputFile(header));\r\n        }\r\n    }\r\n    if (g.tool.gen_listener) {\r\n        if (generator.getTarget().needsHeader()) {\r\n            files.add(getOutputFile(generator.getListenerFileName(true)));\r\n        }\r\n        files.add(getOutputFile(generator.getListenerFileName(false)));\r\n        if (generator.getTarget().needsHeader()) {\r\n            files.add(getOutputFile(generator.getBaseListenerFileName(true)));\r\n        }\r\n        files.add(getOutputFile(generator.getBaseListenerFileName(false)));\r\n    }\r\n    if (g.tool.gen_visitor) {\r\n        if (generator.getTarget().needsHeader()) {\r\n            files.add(getOutputFile(generator.getVisitorFileName(true)));\r\n        }\r\n        files.add(getOutputFile(generator.getVisitorFileName(false)));\r\n        if (generator.getTarget().needsHeader()) {\r\n            files.add(getOutputFile(generator.getBaseVisitorFileName(true)));\r\n        }\r\n        files.add(getOutputFile(generator.getBaseVisitorFileName(false)));\r\n    }\r\n    List<Grammar> imports = g.getAllImportedGrammars();\r\n    if (imports != null) {\r\n        for (Grammar g : imports) {\r\n            files.add(getOutputFile(g.fileName));\r\n        }\r\n    }\r\n    if (files.isEmpty()) {\r\n        return null;\r\n    }\r\n    return files;\r\n}"
}, {
	"Path": "com.facebook.buck.apple.toolchain.AbstractProvisioningProfileStore.getBestProvisioningProfile",
	"Comment": "xxxxxxxxxx.com.example. will match over xxxxxxxxxx. for com.example.testapp",
	"Method": "Optional<ProvisioningProfileMetadata> getBestProvisioningProfile(String bundleID,ApplePlatform platform,Optional<ImmutableMap<String, NSObject>> entitlements,Optional<? extends Iterable<CodeSignIdentity>> identities,StringBuffer diagnosticsBuffer){\r\n    Optional<String> prefix;\r\n    ImmutableList.Builder<String> lines = ImmutableList.builder();\r\n    if (entitlements.isPresent()) {\r\n        prefix = ProvisioningProfileMetadata.prefixFromEntitlements(entitlements.get());\r\n    } else {\r\n        prefix = Optional.empty();\r\n    }\r\n    int bestMatchLength = -1;\r\n    Optional<ProvisioningProfileMetadata> bestMatch = Optional.empty();\r\n    lines.add(String.format(\"Looking for a provisioning profile for bundle ID %s\", bundleID));\r\n    boolean atLeastOneMatch = false;\r\n    for (ProvisioningProfileMetadata profile : getProvisioningProfiles()) {\r\n        Pair<String, String> appID = profile.getAppID();\r\n        LOG.debug(\"Looking at provisioning profile \" + profile.getUUID() + \",\" + appID);\r\n        if (!prefix.isPresent() || prefix.get().equals(appID.getFirst())) {\r\n            String profileBundleID = appID.getSecond();\r\n            boolean match;\r\n            if (profileBundleID.endsWith(\"*\")) {\r\n                profileBundleID = profileBundleID.substring(0, profileBundleID.length() - 1);\r\n                match = bundleID.startsWith(profileBundleID);\r\n            } else {\r\n                match = (bundleID.equals(profileBundleID));\r\n            }\r\n            if (!match) {\r\n                LOG.debug(\"Ignoring non-matching ID for profile \" + profile.getUUID() + \".  Expected: \" + profileBundleID + \", actual: \" + bundleID);\r\n                continue;\r\n            }\r\n            atLeastOneMatch = true;\r\n            if (!profile.getExpirationDate().after(new Date())) {\r\n                String message = \"Ignoring expired profile \" + profile.getUUID() + \": \" + profile.getExpirationDate();\r\n                LOG.debug(message);\r\n                lines.add(message);\r\n                continue;\r\n            }\r\n            Optional<String> platformName = platform.getProvisioningProfileName();\r\n            if (platformName.isPresent() && !profile.getPlatforms().contains(platformName.get())) {\r\n                String message = \"Ignoring incompatible platform \" + platformName.get() + \" for profile \" + profile.getUUID();\r\n                LOG.debug(message);\r\n                lines.add(message);\r\n                continue;\r\n            }\r\n            if (entitlements.isPresent()) {\r\n                ImmutableMap<String, NSObject> entitlementsDict = entitlements.get();\r\n                ImmutableMap<String, NSObject> profileEntitlements = profile.getEntitlements();\r\n                for (Entry<String, NSObject> entry : entitlementsDict.entrySet()) {\r\n                    NSObject profileEntitlement = profileEntitlements.get(entry.getKey());\r\n                    if (!(FORCE_INCLUDE_ENTITLEMENTS.contains(entry.getKey()) || matchesOrArrayIsSubsetOf(entry.getValue(), profileEntitlement))) {\r\n                        match = false;\r\n                        String profileEntitlementString = getStringFromNSObject(profileEntitlement);\r\n                        String entryValueString = getStringFromNSObject(entry.getValue());\r\n                        String message = \"Profile \" + profile.getProfilePath().getFileName() + \" (\" + profile.getUUID() + \") with bundleID \" + profile.getAppID().getSecond() + \" correctly matches. However there is a mismatched entitlement \" + entry.getKey() + \";\" + System.lineSeparator() + \"value is: \" + profileEntitlementString + \"but expected: \" + entryValueString;\r\n                        LOG.debug(message);\r\n                        lines.add(message);\r\n                    }\r\n                }\r\n            }\r\n            ImmutableSet<HashCode> validFingerprints = profile.getDeveloperCertificateFingerprints();\r\n            if (match && identities.isPresent() && !validFingerprints.isEmpty()) {\r\n                match = false;\r\n                for (CodeSignIdentity identity : identities.get()) {\r\n                    Optional<HashCode> fingerprint = identity.getFingerprint();\r\n                    if (fingerprint.isPresent() && validFingerprints.contains(fingerprint.get())) {\r\n                        match = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!match) {\r\n                    String message = \"Ignoring profile \" + profile.getUUID() + \" because it can't be signed with any valid identity in the current keychain.\";\r\n                    LOG.debug(message);\r\n                    lines.add(message);\r\n                    continue;\r\n                }\r\n            }\r\n            if (match && profileBundleID.length() > bestMatchLength) {\r\n                bestMatchLength = profileBundleID.length();\r\n                bestMatch = Optional.of(profile);\r\n            }\r\n        }\r\n    }\r\n    if (!atLeastOneMatch) {\r\n        lines.add(String.format(\"No provisioning profile matching the bundle ID %s was found\", bundleID));\r\n    }\r\n    LOG.debug(\"Found provisioning profile \" + bestMatch);\r\n    ImmutableList<String> diagnostics = lines.build();\r\n    diagnosticsBuffer.append(Joiner.on(\"\\n\").join(diagnostics));\r\n    return bestMatch;\r\n}"
}, {
	"Path": "com.google.auto.common.BasicAnnotationProcessor.postRound",
	"Comment": "an optional hook for logic to be executed at the end of each round.",
	"Method": "void postRound(RoundEnvironment roundEnv){\r\n    if (!roundEnv.processingOver()) {\r\n        postProcess();\r\n    }\r\n}"
}, {
	"Path": "org.apache.commons.net.DefaultDatagramSocketFactory.createDatagramSocket",
	"Comment": "creates a datagramsocket at the specified address on the local hostat a specified port.",
	"Method": "DatagramSocket createDatagramSocket(DatagramSocket createDatagramSocket,int port,DatagramSocket createDatagramSocket,int port,InetAddress laddr){\r\n    return new DatagramSocket(port, laddr);\r\n}"
}, {
	"Path": "org.activiti.engine.test.bpmn.deployment.MessageEventsAndNewVersionDeploymentsWithTenantIdTest.testBoundaryEventSubscriptionDeletedOnDeploymentDelete",
	"Comment": "verifying that the event subscriptions do get removed when removing a deployment.",
	"Method": "void testBoundaryEventSubscriptionDeletedOnDeploymentDelete(){\r\n    String deploymentId = deployBoundaryMessageTestProcess();\r\n    runtimeService.startProcessInstanceByKeyAndTenantId(\"messageTest\", TENANT_ID);\r\n    assertEquals(\"My Task\", taskService.createTaskQuery().singleResult().getName());\r\n    String deploymentId2 = deployBoundaryMessageTestProcess();\r\n    runtimeService.startProcessInstanceByKeyAndTenantId(\"messageTest\", TENANT_ID);\r\n    assertEquals(2, taskService.createTaskQuery().count());\r\n    assertEquals(2, getAllEventSubscriptions().size());\r\n    repositoryService.deleteDeployment(deploymentId, true);\r\n    assertEquals(\"My Task\", taskService.createTaskQuery().singleResult().getName());\r\n    assertEquals(1, getAllEventSubscriptions().size());\r\n    repositoryService.deleteDeployment(deploymentId2, true);\r\n    assertEquals(0, getAllEventSubscriptions().size());\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.GLTextureView.setPreserveEGLContextOnPause",
	"Comment": "control whether the egl context is preserved when the gltextureview is paused andresumed.if set to true, then the egl context may be preserved when the gltextureview is paused.whether the egl context is actually preserved or not depends upon whether theandroid device that the program is running on can support an arbitrary number of eglcontexts or not. devices that can only support a limited number of egl contexts mustrelease theegl context in order to allow multiple applications to share the gpu.if set to false, the egl context will be released when the gltextureview is paused,and recreated when the gltextureview is resumed.the default is false.",
	"Method": "void setPreserveEGLContextOnPause(boolean preserveOnPause){\r\n    preserveEGLContextOnPause = preserveOnPause;\r\n}"
}, {
	"Path": "com.facebook.buck.apple.MultiarchFileInfos.generateThinFlavors",
	"Comment": "expand flavors representing a fat binary into its thin binary equivalents.useful when dealing with functions unaware of fat binaries.this does not actually check that the particular flavor set is valid.",
	"Method": "ImmutableList<ImmutableSortedSet<Flavor>> generateThinFlavors(Set<Flavor> platformFlavors,SortedSet<Flavor> flavors){\r\n    Set<Flavor> platformFreeFlavors = Sets.difference(flavors, platformFlavors);\r\n    ImmutableList.Builder<ImmutableSortedSet<Flavor>> thinTargetsBuilder = ImmutableList.builder();\r\n    for (Flavor flavor : flavors) {\r\n        if (platformFlavors.contains(flavor)) {\r\n            thinTargetsBuilder.add(ImmutableSortedSet.<Flavor>naturalOrder().addAll(platformFreeFlavors).add(flavor).build());\r\n        }\r\n    }\r\n    return thinTargetsBuilder.build();\r\n}"
}, {
	"Path": "org.activiti.engine.impl.el.JsonNodeELResolver.getType",
	"Comment": "if the base object is a map, returns the most general acceptable type for a value in thismap. if the base is a map, the propertyresolved property of the elcontext object must be setto true by this resolver, before returning. if this property is not true after this method iscalled, the caller should ignore the return value. assuming the base is a map, this methodwill always return object.class. this is because maps accept any object as the value for agiven key.",
	"Method": "Class<?> getType(ELContext context,Object base,Object property){\r\n    if (context == null) {\r\n        throw new NullPointerException(\"context is null\");\r\n    }\r\n    Class<?> result = null;\r\n    if (isResolvable(base)) {\r\n        result = Object.class;\r\n        context.setPropertyResolved(true);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.activiti.standalone.testing.ActivitiRuleJunit4Test.testWaitForJobs",
	"Comment": "this is to show how jobtesthelper could be used to wait for jobs to be all processed",
	"Method": "void testWaitForJobs(){\r\n    RuntimeService runtimeService = activitiRule.getRuntimeService();\r\n    ManagementService managementService = activitiRule.getManagementService();\r\n    runtimeService.startProcessInstanceByKey(\"asyncTask\");\r\n    assertEquals(1, managementService.createJobQuery().count());\r\n    JobTestHelper.waitForJobExecutorToProcessAllJobs(activitiRule, 5000L, 500L);\r\n    assertEquals(0, managementService.createJobQuery().count());\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetOptionHandler.answerSubnegotiation",
	"Comment": "method called upon reception of a subnegotiation for this optioncoming from the other end.this implementation returns null, andmust be overridden by the actual telnetoptionhandler to specifywhich response must be sent for the subnegotiation request.",
	"Method": "int[] answerSubnegotiation(int suboptionData,int suboptionLength){\r\n    return null;\r\n}"
}, {
	"Path": "com.facebook.buck.android.apkmodule.APKModuleGraph.mapTargetsToContainingModules",
	"Comment": "for each seed target, find its reachable targets and mark them in a multimap as being reachableby that module for later sorting into exclusive and shared targets",
	"Method": "Multimap<BuildTarget, String> mapTargetsToContainingModules(){\r\n    Multimap<BuildTarget, String> targetToContainingApkModuleNameMap = MultimapBuilder.treeKeys().treeSetValues().build();\r\n    for (Map.Entry<String, List<BuildTarget>> seedConfig : getSeedConfigMap().get().entrySet()) {\r\n        String seedModuleName = seedConfig.getKey();\r\n        for (BuildTarget seedTarget : seedConfig.getValue()) {\r\n            targetToContainingApkModuleNameMap.put(seedTarget, seedModuleName);\r\n            new AbstractBreadthFirstTraversal<TargetNode<?>>(targetGraph.get(seedTarget)) {\r\n                @Override\r\n                public ImmutableSet<TargetNode<?>> visit(TargetNode<?> node) {\r\n                    ImmutableSet.Builder<TargetNode<?>> depsBuilder = ImmutableSet.builder();\r\n                    for (BuildTarget depTarget : node.getBuildDeps()) {\r\n                        if (!isInRootModule(depTarget) && !isSeedTarget(depTarget)) {\r\n                            depsBuilder.add(targetGraph.get(depTarget));\r\n                            targetToContainingApkModuleNameMap.put(depTarget, seedModuleName);\r\n                        }\r\n                    }\r\n                    return depsBuilder.build();\r\n                }\r\n            }.start();\r\n        }\r\n    }\r\n    DirectedAcyclicGraph<String> declaredDependencies = getDeclaredDependencyGraph();\r\n    Multimap<BuildTarget, String> targetModuleEntriesToRemove = MultimapBuilder.treeKeys().treeSetValues().build();\r\n    for (BuildTarget key : targetToContainingApkModuleNameMap.keySet()) {\r\n        Collection<String> modulesForTarget = targetToContainingApkModuleNameMap.get(key);\r\n        new AbstractBreadthFirstTraversal<String>(modulesForTarget) {\r\n            @Override\r\n            public Iterable<String> visit(String moduleName) throws RuntimeException {\r\n                Collection<String> dependentModules = declaredDependencies.getIncomingNodesFor(moduleName);\r\n                for (String dependent : dependentModules) {\r\n                    if (modulesForTarget.contains(dependent)) {\r\n                        targetModuleEntriesToRemove.put(key, dependent);\r\n                    }\r\n                }\r\n                return dependentModules;\r\n            }\r\n        }.start();\r\n    }\r\n    for (Map.Entry<BuildTarget, String> entryToRemove : targetModuleEntriesToRemove.entries()) {\r\n        targetToContainingApkModuleNameMap.remove(entryToRemove.getKey(), entryToRemove.getValue());\r\n    }\r\n    return targetToContainingApkModuleNameMap;\r\n}"
}, {
	"Path": "com.facebook.buck.android.apkmodule.APKModuleGraph.mapTargetsToContainingModules",
	"Comment": "for each seed target, find its reachable targets and mark them in a multimap as being reachableby that module for later sorting into exclusive and shared targets",
	"Method": "Multimap<BuildTarget, String> mapTargetsToContainingModules(){\r\n    ImmutableSet.Builder<TargetNode<?>> depsBuilder = ImmutableSet.builder();\r\n    for (BuildTarget depTarget : node.getBuildDeps()) {\r\n        if (!isInRootModule(depTarget) && !isSeedTarget(depTarget)) {\r\n            depsBuilder.add(targetGraph.get(depTarget));\r\n            targetToContainingApkModuleNameMap.put(depTarget, seedModuleName);\r\n        }\r\n    }\r\n    return depsBuilder.build();\r\n}"
}, {
	"Path": "com.facebook.buck.android.apkmodule.APKModuleGraph.mapTargetsToContainingModules",
	"Comment": "for each seed target, find its reachable targets and mark them in a multimap as being reachableby that module for later sorting into exclusive and shared targets",
	"Method": "Multimap<BuildTarget, String> mapTargetsToContainingModules(){\r\n    Collection<String> dependentModules = declaredDependencies.getIncomingNodesFor(moduleName);\r\n    for (String dependent : dependentModules) {\r\n        if (modulesForTarget.contains(dependent)) {\r\n            targetModuleEntriesToRemove.put(key, dependent);\r\n        }\r\n    }\r\n    return dependentModules;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.CDL.toJSONArray",
	"Comment": "produce a jsonarray of jsonobjects from a comma delimited text string using a supplied jsonarray as the source of element names.",
	"Method": "JSONArray toJSONArray(String string,JSONArray toJSONArray,JSONTokener x,JSONArray toJSONArray,JSONArray names,String string,JSONArray toJSONArray,JSONArray names,JSONTokener x){\r\n    if (names == null || names.length() == 0) {\r\n        return null;\r\n    }\r\n    JSONArray ja = new JSONArray();\r\n    for (; ; ) {\r\n        JSONObject jo = rowToJSONObject(names, x);\r\n        if (jo == null) {\r\n            break;\r\n        }\r\n        ja.put(jo);\r\n    }\r\n    if (ja.length() == 0) {\r\n        return null;\r\n    }\r\n    return ja;\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.event.ProcessInstanceEventsTest.testSubProcessInstanceEvents",
	"Comment": "test create, update and delete events of process instances.",
	"Method": "void testSubProcessInstanceEvents(){\r\n    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(\"nestedSimpleSubProcess\");\r\n    assertNotNull(processInstance);\r\n    String processDefinitionId = processInstance.getProcessDefinitionId();\r\n    assertEquals(9, listener.getEventsReceived().size());\r\n    assertTrue(listener.getEventsReceived().get(0) instanceof ActivitiEntityEvent);\r\n    ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);\r\n    assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());\r\n    assertEquals(processInstance.getId(), ((ProcessInstance) event.getEntity()).getId());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertEquals(processInstance.getId(), event.getExecutionId());\r\n    assertEquals(processDefinitionId, event.getProcessDefinitionId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);\r\n    String processExecutionId = event.getExecutionId();\r\n    assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertEquals(processInstance.getId(), processExecutionId);\r\n    assertEquals(processDefinitionId, event.getProcessDefinitionId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(2);\r\n    processExecutionId = event.getExecutionId();\r\n    assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertNotEquals(processInstance.getId(), processExecutionId);\r\n    assertEquals(processDefinitionId, event.getProcessDefinitionId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(3);\r\n    assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertNotEquals(processInstance.getId(), ((ExecutionEntity) event.getEntity()).getId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(4);\r\n    assertEquals(ActivitiEventType.PROCESS_STARTED, event.getType());\r\n    assertEquals(processInstance.getId(), event.getProcessInstanceId());\r\n    assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());\r\n    assertTrue(event instanceof ActivitiProcessStartedEvent);\r\n    assertNull(((ActivitiProcessStartedEvent) event).getNestedProcessDefinitionId());\r\n    assertNull(((ActivitiProcessStartedEvent) event).getNestedProcessInstanceId());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(5);\r\n    assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());\r\n    ExecutionEntity subProcessEntity = (ExecutionEntity) event.getEntity();\r\n    assertEquals(processExecutionId, subProcessEntity.getSuperExecutionId());\r\n    String subProcessInstanceId = subProcessEntity.getProcessInstanceId();\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(6);\r\n    assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());\r\n    assertEquals(subProcessInstanceId, event.getProcessInstanceId());\r\n    assertNotEquals(subProcessInstanceId, event.getExecutionId());\r\n    String subProcessDefinitionId = ((ExecutionEntity) event.getEntity()).getProcessDefinitionId();\r\n    assertNotNull(subProcessDefinitionId);\r\n    ProcessDefinition subProcessDefinition = repositoryService.getProcessDefinition(subProcessDefinitionId);\r\n    assertEquals(\"simpleSubProcess\", subProcessDefinition.getKey());\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(7);\r\n    assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());\r\n    assertEquals(subProcessInstanceId, event.getProcessInstanceId());\r\n    assertNotEquals(subProcessInstanceId, event.getExecutionId());\r\n    subProcessDefinitionId = ((ExecutionEntity) event.getEntity()).getProcessDefinitionId();\r\n    assertNotNull(subProcessDefinitionId);\r\n    event = (ActivitiEntityEvent) listener.getEventsReceived().get(8);\r\n    assertEquals(ActivitiEventType.PROCESS_STARTED, event.getType());\r\n    assertEquals(subProcessInstanceId, event.getProcessInstanceId());\r\n    assertEquals(subProcessDefinitionId, event.getProcessDefinitionId());\r\n    assertTrue(event instanceof ActivitiProcessStartedEvent);\r\n    assertEquals(processDefinitionId, ((ActivitiProcessStartedEvent) event).getNestedProcessDefinitionId());\r\n    assertEquals(processInstance.getId(), ((ActivitiProcessStartedEvent) event).getNestedProcessInstanceId());\r\n    listener.clearEventsReceived();\r\n}"
}, {
	"Path": "org.activiti.engine.test.bpmn.deployment.MessageEventsAndNewVersionDeploymentsWithTenantIdTest.testBoundaryEventSubscrptionsDeletedOnProcessInstanceDelete",
	"Comment": "verifying that the event subscriptions do get removed when removing a process instance.",
	"Method": "void testBoundaryEventSubscrptionsDeletedOnProcessInstanceDelete(){\r\n    String deploymentId1 = deployBoundaryMessageTestProcess();\r\n    runtimeService.startProcessInstanceByKeyAndTenantId(\"messageTest\", TENANT_ID);\r\n    assertEquals(\"My Task\", taskService.createTaskQuery().singleResult().getName());\r\n    String deploymentId2 = deployBoundaryMessageTestProcess();\r\n    ProcessInstance processInstance2 = runtimeService.startProcessInstanceByKeyAndTenantId(\"messageTest\", TENANT_ID);\r\n    assertEquals(2, taskService.createTaskQuery().count());\r\n    assertEquals(2, getAllEventSubscriptions().size());\r\n    runtimeService.deleteProcessInstance(processInstance2.getId(), \"testing\");\r\n    assertEquals(\"My Task\", taskService.createTaskQuery().singleResult().getName());\r\n    assertEquals(1, getAllEventSubscriptions().size());\r\n    runtimeService.messageEventReceived(\"myMessage\", getExecutionIdsForMessageEventSubscription(\"myMessage\").get(0));\r\n    assertEquals(0, getAllEventSubscriptions().size());\r\n    assertEquals(\"Task after message\", taskService.createTaskQuery().singleResult().getName());\r\n    cleanup(deploymentId1, deploymentId2);\r\n}"
}, {
	"Path": "org.activiti.bpmn.converter.util.CommaSplitter.splitCommas",
	"Comment": "split the given spring using commas if they are not inside an expression",
	"Method": "List<String> splitCommas(String st){\r\n    List<String> result = new ArrayList<String>();\r\n    int offset = 0;\r\n    boolean inExpression = false;\r\n    for (int i = 0; i < st.length(); i++) {\r\n        if (!inExpression && st.charAt(i) == ',') {\r\n            if ((i - offset) > 1) {\r\n                result.add(st.substring(offset, i));\r\n            }\r\n            offset = i + 1;\r\n        } else if ((st.charAt(i) == '$' || st.charAt(i) == '#') && st.charAt(i + 1) == '{') {\r\n            inExpression = true;\r\n        } else if (st.charAt(i) == '}') {\r\n            inExpression = false;\r\n        }\r\n    }\r\n    if ((st.length() - offset) > 1) {\r\n        result.add(st.substring(offset));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.google.auto.value.processor.TemplateVars.readerFromUrl",
	"Comment": "through the getresourceasstream should be a lot more efficient than reopening the jar.",
	"Method": "Reader readerFromUrl(String resourceName){\r\n    URL resourceUrl = TemplateVars.class.getResource(resourceName);\r\n    InputStream in;\r\n    try {\r\n        if (resourceUrl.getProtocol().equalsIgnoreCase(\"file\")) {\r\n            in = inputStreamFromFile(resourceUrl);\r\n        } else if (resourceUrl.getProtocol().equalsIgnoreCase(\"jar\")) {\r\n            in = inputStreamFromJar(resourceUrl);\r\n        } else {\r\n            throw new AssertionError(\"Template fallback logic fails for: \" + resourceUrl);\r\n        }\r\n    } catch (URISyntaxException e) {\r\n        throw new IOException(e);\r\n    }\r\n    return new InputStreamReader(in, StandardCharsets.UTF_8);\r\n}"
}, {
	"Path": "com.google.classyshark.updater.utils.FileUtils.downloadFileFrom",
	"Comment": "this method will download the new version if and only if it has not been downloaded already.in case the software detects that the same new jar is already present, it will skip the download and justnotify the user about the new version",
	"Method": "File downloadFileFrom(Release release){\r\n    File file = new File(NamingUtils.buildNameFrom(release));\r\n    if (!file.exists()) {\r\n        obtainNewJarFrom(release, file);\r\n    }\r\n    return file;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.persistence.entity.DeadLetterJobEntityManagerImpl.deleteExceptionByteArrayRef",
	"Comment": "deletes a the byte array used to store the exception information.subclasses may overrideto provide custom implementations.",
	"Method": "void deleteExceptionByteArrayRef(DeadLetterJobEntity jobEntity){\r\n    ByteArrayRef exceptionByteArrayRef = jobEntity.getExceptionByteArrayRef();\r\n    if (exceptionByteArrayRef != null) {\r\n        exceptionByteArrayRef.delete();\r\n    }\r\n}"
}, {
	"Path": "org.antlr.mojo.antlr4.GrammarDependencies.isDependencyChanged",
	"Comment": "determines whether a grammar used by the given grammar was modified since the lastbuild.",
	"Method": "boolean isDependencyChanged(File grammarFile){\r\n    String grammarPath = getRelativePath(grammarFile);\r\n    for (Map.Entry<File, Map.Entry<byte[], Collection<String>>> e : grammars.entrySet()) {\r\n        File depGrammarFile = e.getKey();\r\n        byte[] checksum = e.getValue().getKey();\r\n        Collection<String> usages = e.getValue().getValue();\r\n        if (usages.contains(grammarPath)) {\r\n            if (!depGrammarFile.exists() || !Arrays.equals(MojoUtils.checksum(depGrammarFile), checksum)) {\r\n                log.debug(\"  \" + grammarPath + \": dependency \" + depGrammarFile.getName() + \" changed\");\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.activiti.engine.test.bpmn.callactivity.CallActivityAdvancedTest.testSubProcessWithDataInputOutput",
	"Comment": "test case for handing over process variables to a sub process",
	"Method": "void testSubProcessWithDataInputOutput(){\r\n    Map<String, Object> vars = new HashMap<String, Object>();\r\n    vars.put(\"superVariable\", \"Hello from the super process.\");\r\n    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(\"subProcessDataInputOutput\", vars);\r\n    TaskQuery taskQuery = taskService.createTaskQuery();\r\n    Task taskBeforeSubProcess = taskQuery.singleResult();\r\n    assertEquals(\"Task in subprocess\", taskBeforeSubProcess.getName());\r\n    assertEquals(\"Hello from the super process.\", runtimeService.getVariable(taskBeforeSubProcess.getProcessInstanceId(), \"subVariable\"));\r\n    assertEquals(\"Hello from the super process.\", taskService.getVariable(taskBeforeSubProcess.getId(), \"subVariable\"));\r\n    runtimeService.setVariable(taskBeforeSubProcess.getProcessInstanceId(), \"subVariable\", \"Hello from sub process.\");\r\n    assertEquals(\"Hello from the super process.\", runtimeService.getVariable(processInstance.getId(), \"superVariable\"));\r\n    taskService.complete(taskBeforeSubProcess.getId());\r\n    Task taskAfterSubProcess = taskQuery.singleResult();\r\n    assertEquals(\"Task in super process\", taskAfterSubProcess.getName());\r\n    assertEquals(\"Hello from sub process.\", runtimeService.getVariable(processInstance.getId(), \"superVariable\"));\r\n    assertEquals(\"Hello from sub process.\", taskService.getVariable(taskAfterSubProcess.getId(), \"superVariable\"));\r\n    vars.clear();\r\n    vars.put(\"x\", 5l);\r\n    taskService.complete(taskAfterSubProcess.getId(), vars);\r\n    Task taskInSecondSubProcess = taskQuery.singleResult();\r\n    assertEquals(\"Task in subprocess\", taskInSecondSubProcess.getName());\r\n    assertEquals(10l, runtimeService.getVariable(taskInSecondSubProcess.getProcessInstanceId(), \"y\"));\r\n    assertEquals(10l, taskService.getVariable(taskInSecondSubProcess.getId(), \"y\"));\r\n    taskService.complete(taskInSecondSubProcess.getId());\r\n    Task taskAfterSecondSubProcess = taskQuery.singleResult();\r\n    assertEquals(\"Task in super process\", taskAfterSecondSubProcess.getName());\r\n    assertEquals(15l, runtimeService.getVariable(taskAfterSecondSubProcess.getProcessInstanceId(), \"z\"));\r\n    assertEquals(15l, taskService.getVariable(taskAfterSecondSubProcess.getId(), \"z\"));\r\n    taskService.complete(taskAfterSecondSubProcess.getId());\r\n    assertProcessEnded(processInstance.getId());\r\n    assertEquals(0, runtimeService.createExecutionQuery().list().size());\r\n}"
}, {
	"Path": "org.activiti.engine.test.bpmn.deployment.SignalEventsAndNewVersionDeploymentsTest.testBoundaryEventSubscrptionsDeletedOnProcessInstanceDelete",
	"Comment": "verifying that the event subscriptions do get removed when removing a process instance.",
	"Method": "void testBoundaryEventSubscrptionsDeletedOnProcessInstanceDelete(){\r\n    String deploymentId1 = deployBoundarySignalTestProcess();\r\n    runtimeService.startProcessInstanceByKey(\"signalTest\");\r\n    assertEquals(\"My Task\", taskService.createTaskQuery().singleResult().getName());\r\n    String deploymentId2 = deployBoundarySignalTestProcess();\r\n    ProcessInstance processInstance2 = runtimeService.startProcessInstanceByKey(\"signalTest\");\r\n    assertEquals(2, taskService.createTaskQuery().count());\r\n    assertEquals(2, getAllEventSubscriptions().size());\r\n    runtimeService.deleteProcessInstance(processInstance2.getId(), \"testing\");\r\n    assertEquals(\"My Task\", taskService.createTaskQuery().singleResult().getName());\r\n    assertEquals(1, getAllEventSubscriptions().size());\r\n    runtimeService.signalEventReceived(\"mySignal\");\r\n    assertEquals(0, getAllEventSubscriptions().size());\r\n    assertEquals(\"Task after signal\", taskService.createTaskQuery().singleResult().getName());\r\n    cleanup(deploymentId1, deploymentId2);\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.Parser.createErrorNode",
	"Comment": "how to create an error node, given a token, associated with a parent.\t typically, the error node to create is not a function of the parent.",
	"Method": "ErrorNode createErrorNode(ParserRuleContext parent,Token t){\r\n    return new ErrorNodeImpl(t);\r\n}"
}, {
	"Path": "com.facebook.buck.android.support.exopackage.ExopackageDexLoader.cleanUpOldOdexFiles",
	"Comment": "clean up any odex files that do not belong to the specified set of jars",
	"Method": "void cleanUpOldOdexFiles(File dexOptDir,List<File> dexJars){\r\n    Set<String> expectedOdexSet = new HashSet();\r\n    for (File file : dexJars) {\r\n        expectedOdexSet.add(file.getName().replaceFirst(\"\\\\.jar$\", \".dex\"));\r\n    }\r\n    File[] odexes = dexOptDir.listFiles();\r\n    if (odexes != null) {\r\n        for (File odex : odexes) {\r\n            if (!expectedOdexSet.contains(odex.getName())) {\r\n                if (!odex.delete()) {\r\n                    Log.w(TAG, \"Failed to delete stale odex: \" + odex.getAbsolutePath());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.parser.factory.DefaultActivityBehaviorFactory.createMuleActivityBehavior",
	"Comment": "activitybehavior and instantiate the delegate instance using a string instead of the class itself.",
	"Method": "ActivityBehavior createMuleActivityBehavior(ServiceTask serviceTask,ActivityBehavior createMuleActivityBehavior,SendTask sendTask,ActivityBehavior createMuleActivityBehavior,TaskWithFieldExtensions task,List<FieldExtension> fieldExtensions){\r\n    try {\r\n        Class<?> theClass = Class.forName(\"org.activiti.mule.MuleSendActivitiBehavior\");\r\n        List<FieldDeclaration> fieldDeclarations = createFieldDeclarations(fieldExtensions);\r\n        return (ActivityBehavior) ClassDelegate.defaultInstantiateDelegate(theClass, fieldDeclarations);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new ActivitiException(\"Could not find org.activiti.mule.MuleSendActivitiBehavior: \", e);\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.test.AbstractActivitiTestCase.assertAndEnsureCleanDb",
	"Comment": "each test is assumed to clean up all db content it entered. after a test method executed, this method scans all tables to see if the db is completely clean. it throws assertionfailed in case thedb is not clean. if the db is not clean, it is cleaned by performing a create a drop.",
	"Method": "void assertAndEnsureCleanDb(){\r\n    log.debug(\"verifying that db is clean after test\");\r\n    Map<String, Long> tableCounts = managementService.getTableCount();\r\n    StringBuilder outputMessage = new StringBuilder();\r\n    for (String tableName : tableCounts.keySet()) {\r\n        String tableNameWithoutPrefix = tableName.replace(processEngineConfiguration.getDatabaseTablePrefix(), \"\");\r\n        if (!TABLENAMES_EXCLUDED_FROM_DB_CLEAN_CHECK.contains(tableNameWithoutPrefix)) {\r\n            Long count = tableCounts.get(tableName);\r\n            if (count != 0L) {\r\n                outputMessage.append(\"  \").append(tableName).append(\": \").append(count).append(\" record(s) \");\r\n            }\r\n        }\r\n    }\r\n    if (outputMessage.length() > 0) {\r\n        outputMessage.insert(0, \"DB NOT CLEAN: \\n\");\r\n        log.error(EMPTY_LINE);\r\n        log.error(outputMessage.toString());\r\n        log.info(\"dropping and recreating db\");\r\n        CommandExecutor commandExecutor = ((ProcessEngineImpl) processEngine).getProcessEngineConfiguration().getCommandExecutor();\r\n        CommandConfig config = new CommandConfig().transactionNotSupported();\r\n        commandExecutor.execute(config, new Command<Object>() {\r\n            public Object execute(CommandContext commandContext) {\r\n                DbSqlSession session = commandContext.getDbSqlSession();\r\n                session.dbSchemaDrop();\r\n                session.dbSchemaCreate();\r\n                return null;\r\n            }\r\n        });\r\n        if (exception != null) {\r\n            throw exception;\r\n        } else {\r\n            Assert.fail(outputMessage.toString());\r\n        }\r\n    } else {\r\n        log.info(\"database was clean\");\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.test.AbstractActivitiTestCase.assertAndEnsureCleanDb",
	"Comment": "each test is assumed to clean up all db content it entered. after a test method executed, this method scans all tables to see if the db is completely clean. it throws assertionfailed in case thedb is not clean. if the db is not clean, it is cleaned by performing a create a drop.",
	"Method": "void assertAndEnsureCleanDb(){\r\n    DbSqlSession session = commandContext.getDbSqlSession();\r\n    session.dbSchemaDrop();\r\n    session.dbSchemaCreate();\r\n    return null;\r\n}"
}, {
	"Path": "com.google.auto.value.processor.TypeSimplifier.classNameOf",
	"Comment": "returns the name of the given type, including any enclosing types but not the package.",
	"Method": "String classNameOf(TypeElement type){\r\n    String name = type.getQualifiedName().toString();\r\n    String pkgName = packageNameOf(type);\r\n    return pkgName.isEmpty() ? name : name.substring(pkgName.length() + 1);\r\n}"
}, {
	"Path": "com.roughike.bottombar.ShySettings.hideBar",
	"Comment": "hides the bottombar in if it was visible, with a translate animation.",
	"Method": "void hideBar(){\r\n    toggleIsVisibleInShyMode(false);\r\n}"
}, {
	"Path": "org.activiti.engine.test.image.ProcessDiagramGeneratorTest.testGenerateDefaultDiagram",
	"Comment": "test that when the diagram is generated for a model without graphic infothen the default diagram image is returnedor the activitiinterchangeinfonotfoundexception is throwndepending on the value of the generatedefaultdiagram parameter.",
	"Method": "void testGenerateDefaultDiagram(){\r\n    String id = repositoryService.createProcessDefinitionQuery().processDefinitionKey(\"fixSystemFailure\").singleResult().getId();\r\n    BpmnModel bpmnModel = repositoryService.getBpmnModel(id);\r\n    ProcessDiagramGenerator imageGenerator = new DefaultProcessDiagramGenerator();\r\n    String activityFontName = imageGenerator.getDefaultActivityFontName();\r\n    String labelFontName = imageGenerator.getDefaultLabelFontName();\r\n    String annotationFontName = imageGenerator.getDefaultAnnotationFontName();\r\n    try (final InputStream resourceStream = imageGenerator.generateDiagram(bpmnModel, emptyList(), emptyList(), activityFontName, labelFontName, annotationFontName, true)) {\r\n        assertThat(resourceStream).isNotNull();\r\n        byte[] diagram = IOUtils.toByteArray(resourceStream);\r\n        assertThat(diagram).isNotNull();\r\n        try (InputStream imageStream = getClass().getResourceAsStream(imageGenerator.getDefaultDiagramImageFileName())) {\r\n            assertThat(diagram).isEqualTo(IOUtils.toByteArray(imageStream));\r\n        }\r\n    }\r\n    // WHEN\r\n    assertThatExceptionOfType(ActivitiInterchangeInfoNotFoundException.class).isThrownBy(() -> imageGenerator.generateDiagram(bpmnModel, emptyList(), emptyList(), activityFontName, labelFontName, annotationFontName, false)).withMessage(\"No interchange information found.\");\r\n    // WHEN\r\n    assertThatExceptionOfType(ActivitiImageException.class).isThrownBy(() -> imageGenerator.generateDiagram(bpmnModel, emptyList(), emptyList(), activityFontName, labelFontName, annotationFontName, true, \"invalid-file-name\")).withMessage(\"Error occurred while getting default diagram image from file: invalid-file-name\");\r\n}"
}, {
	"Path": "com.facebook.buck.apple.simulator.AppleSimulatorDiscovery.tryDiscoverAppleSimulators",
	"Comment": "discovers information about apple simulators installed on the system.",
	"Method": "ImmutableSet<AppleSimulator> tryDiscoverAppleSimulators(ProcessExecutor processExecutor,Path simctlPath){\r\n    LOG.debug(\"Running xcrun simctl list to get list of simulators\");\r\n    ProcessExecutorParams processExecutorParams = ProcessExecutorParams.builder().setCommand(ImmutableList.of(simctlPath.toString(), \"list\")).build();\r\n    ProcessExecutor.Result simctlListResult = processExecutor.launchAndExecute(processExecutorParams);\r\n    if (simctlListResult.getExitCode() != 0) {\r\n        throw new IOException(simctlListResult.getMessageForUnexpectedResult(\"simctl list\"));\r\n    }\r\n    String output = simctlListResult.getStdout().orElseThrow(() -> new IllegalStateException(\"stdout should be captured\"));\r\n    ImmutableSet.Builder<AppleSimulator> simulatorsBuilder = ImmutableSet.builder();\r\n    SimctlListOutputParsing.parseOutput(output, simulatorsBuilder);\r\n    ImmutableSet<AppleSimulator> simulators = simulatorsBuilder.build();\r\n    LOG.debug(\"Discovered simulators: %s\", simulators);\r\n    return simulators;\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.filter.GPUImageSwirlFilter.setAngle",
	"Comment": "the amount of distortion to apply, with a minimum of 0.0 and a default of 1.0.",
	"Method": "void setAngle(float angle){\r\n    this.angle = angle;\r\n    setFloat(angleLocation, angle);\r\n}"
}, {
	"Path": "org.apache.commons.net.SocketClient.isAvailable",
	"Comment": "make various checks on the socket to test if it is available for use.note that the only sure test is to use it, but these checks may helpin some cases.",
	"Method": "boolean isAvailable(){\r\n    if (isConnected()) {\r\n        try {\r\n            if (_socket_.getInetAddress() == null) {\r\n                return false;\r\n            }\r\n            if (_socket_.getPort() == 0) {\r\n                return false;\r\n            }\r\n            if (_socket_.getRemoteSocketAddress() == null) {\r\n                return false;\r\n            }\r\n            if (_socket_.isClosed()) {\r\n                return false;\r\n            }\r\n            if (_socket_.isInputShutdown()) {\r\n                return false;\r\n            }\r\n            if (_socket_.isOutputShutdown()) {\r\n                return false;\r\n            }\r\n            _socket_.getInputStream();\r\n            _socket_.getOutputStream();\r\n        } catch (IOException ioex) {\r\n            return false;\r\n        }\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.filter.GPUImageCrosshatchFilter.setLineWidth",
	"Comment": "a relative width for the crosshatch lines. the default is 0.003.",
	"Method": "void setLineWidth(float lineWidth){\r\n    this.lineWidth = lineWidth;\r\n    setFloat(lineWidthLocation, this.lineWidth);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.behavior.BpmnActivityBehavior.dispatchJobCanceledEvents",
	"Comment": "dispatch job canceled event for job associated with given execution entity",
	"Method": "void dispatchJobCanceledEvents(ExecutionEntity activityExecution){\r\n    if (activityExecution != null) {\r\n        List<JobEntity> jobs = activityExecution.getJobs();\r\n        for (JobEntity job : jobs) {\r\n            if (Context.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) {\r\n                Context.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.JOB_CANCELED, job));\r\n            }\r\n        }\r\n        List<TimerJobEntity> timerJobs = activityExecution.getTimerJobs();\r\n        for (TimerJobEntity job : timerJobs) {\r\n            if (Context.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) {\r\n                Context.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.JOB_CANCELED, job));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.core.build.engine.impl.CachingBuildRuleBuilder.serviceByAdjustingDefaultWeightsTo",
	"Comment": "we have a lot of places where tasks are submitted into a service implicitly. there is no way toassign custom weights to such tasks. by creating a temporary service with adjusted weights itis possible to trick the system and tweak the weights.",
	"Method": "WeightedListeningExecutorService serviceByAdjustingDefaultWeightsTo(ResourceAmounts defaultAmounts){\r\n    return resourceAwareSchedulingInfo.adjustServiceDefaultWeightsTo(defaultAmounts, service);\r\n}"
}, {
	"Path": "org.activiti.engine.test.bpmn.deployment.SignalEventsAndNewVersionDeploymentsTest.testBoundaryEventSubscriptionDeletedOnDeploymentDelete",
	"Comment": "verifying that the event subscriptions do get removed when removing a deployment.",
	"Method": "void testBoundaryEventSubscriptionDeletedOnDeploymentDelete(){\r\n    String deploymentId = deployBoundarySignalTestProcess();\r\n    runtimeService.startProcessInstanceByKey(\"signalTest\");\r\n    assertEquals(\"My Task\", taskService.createTaskQuery().singleResult().getName());\r\n    String deploymentId2 = deployBoundarySignalTestProcess();\r\n    runtimeService.startProcessInstanceByKey(\"signalTest\");\r\n    assertEquals(2, taskService.createTaskQuery().count());\r\n    assertEquals(2, getAllEventSubscriptions().size());\r\n    repositoryService.deleteDeployment(deploymentId, true);\r\n    assertEquals(\"My Task\", taskService.createTaskQuery().singleResult().getName());\r\n    assertEquals(1, getAllEventSubscriptions().size());\r\n    repositoryService.deleteDeployment(deploymentId2, true);\r\n    assertEquals(0, getAllEventSubscriptions().size());\r\n}"
}, {
	"Path": "com.facebook.buck.android.resources.BringToFrontMapper.construct",
	"Comment": "constructs a referencemapper that will reassign ids and adjust offsets such that for each keyin idsbytype, the ids in idsbytype will be reassigned to the first n ids of that type. the idsprovided should not include package or type ids.",
	"Method": "BringToFrontMapper construct(int packageId,Map<Integer, SortedSet<Integer>> idsByType){\r\n    int maxType = 0;\r\n    for (int k : idsByType.keySet()) {\r\n        maxType = Math.max(k, maxType);\r\n    }\r\n    int[][] mapping = new int[maxType + 1][];\r\n    int[][] rewriters = new int[maxType + 1][];\r\n    idsByType.forEach((type, idsSet) -> {\r\n        int maxRef = 0;\r\n        int[] ids = idsSet.stream().mapToInt(i -> i).toArray();\r\n        for (int id : ids) {\r\n            maxRef = Math.max(maxRef, id);\r\n        }\r\n        int[] newMapping = IntStream.range(0, maxRef + 1).toArray();\r\n        for (int i = ids.length - 1; i >= 0; i--) {\r\n            int id = ids[i];\r\n            newMapping[i] = newMapping[id];\r\n            newMapping[id] = i;\r\n        }\r\n        mapping[type] = newMapping;\r\n        rewriters[type] = ids;\r\n    });\r\n    return new BringToFrontMapper(packageId, mapping, rewriters);\r\n}"
}, {
	"Path": "com.facebook.buck.android.exopackage.RealAndroidDevice.chunkArgs",
	"Comment": "breaks a list of strings into groups whose total size is within some limit. kind of like thexargs command that groups arguments to avoid maximum argument length limits. except that thelimit in adb is about 1k instead of 512k or 2m on linux.",
	"Method": "ImmutableList<ImmutableList<String>> chunkArgs(Iterable<String> args,int sizeLimit){\r\n    ImmutableList.Builder<ImmutableList<String>> topLevelBuilder = ImmutableList.builder();\r\n    ImmutableList.Builder<String> chunkBuilder = ImmutableList.builder();\r\n    int chunkSize = 0;\r\n    for (String arg : args) {\r\n        if (chunkSize + arg.length() > sizeLimit) {\r\n            topLevelBuilder.add(chunkBuilder.build());\r\n            chunkBuilder = ImmutableList.builder();\r\n            chunkSize = 0;\r\n        }\r\n        chunkBuilder.add(arg);\r\n        chunkSize += arg.length();\r\n    }\r\n    ImmutableList<String> tail = chunkBuilder.build();\r\n    if (!tail.isEmpty()) {\r\n        topLevelBuilder.add(tail);\r\n    }\r\n    return topLevelBuilder.build();\r\n}"
}, {
	"Path": "com.facebook.buck.artifact_cache.config.ArtifactCacheBuckConfig.getClientTlsCertificate",
	"Comment": "gets the path to a pem encoded x509 certifiate to use as the tls client certificate for httpcache requestsboth the key and certificate must be set for client tls certificates to be used",
	"Method": "Optional<Path> getClientTlsCertificate(){\r\n    return buckConfig.getValue(CACHE_SECTION_NAME, \"http_client_tls_cert\").map(Paths::get);\r\n}"
}, {
	"Path": "com.facebook.buck.cli.TargetsCommand.getTransitiveParseTimeDeps",
	"Comment": "get the set of targetnodes and their parse time dependencies",
	"Method": "Iterable<TargetNode<?>> getTransitiveParseTimeDeps(Pair<TargetGraph, Iterable<TargetNode<?>>> targetGraphAndTargetNodes){\r\n    AcyclicDepthFirstPostOrderTraversal<TargetNode<?>> traversal = new AcyclicDepthFirstPostOrderTraversal(node -> targetGraphAndTargetNodes.getFirst().getAll(node.getParseDeps()).iterator());\r\n    return traversal.traverse(targetGraphAndTargetNodes.getSecond());\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.Lexer.getAllTokens",
	"Comment": "return a list of all token objects in input char stream.\t forces load of all tokens. does not include eof token.",
	"Method": "List<? extends Token> getAllTokens(){\r\n    List<Token> tokens = new ArrayList<Token>();\r\n    Token t = nextToken();\r\n    while (t.getType() != Token.EOF) {\r\n        tokens.add(t);\r\n        t = nextToken();\r\n    }\r\n    return tokens;\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetOptionHandler.getWill",
	"Comment": "returns a boolean indicating whether a will request sent to the otherside has been acknowledged.",
	"Method": "boolean getWill(){\r\n    return willFlag;\r\n}"
}, {
	"Path": "com.google.auto.service.processor.ServicesFiles.getPath",
	"Comment": "returns an absolute path to a service file given the classname of the service.",
	"Method": "String getPath(String serviceName){\r\n    return SERVICES_PATH + \"/\" + serviceName;\r\n}"
}, {
	"Path": "com.facebook.buck.android.apkmodule.APKModuleGraph.findResourceModuleForTarget",
	"Comment": "get the module that should contain the resources for the given target",
	"Method": "APKModule findResourceModuleForTarget(BuildTarget target){\r\n    APKModule module = targetToModuleMapSupplier.get().get(target);\r\n    return (module == null || !module.hasResources()) ? rootAPKModuleSupplier.get() : module;\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.event.DeploymentEventsTest.testDeploymentEvents",
	"Comment": "test create, update and delete events of deployment entities.",
	"Method": "void testDeploymentEvents(){\r\n    Deployment deployment = null;\r\n    try {\r\n        listener.clearEventsReceived();\r\n        deployment = repositoryService.createDeployment().addClasspathResource(\"org/activiti/engine/test/api/runtime/oneTaskProcess.bpmn20.xml\").deploy();\r\n        assertNotNull(deployment);\r\n        assertEquals(2, listener.getEventsReceived().size());\r\n        assertTrue(listener.getEventsReceived().get(0) instanceof ActivitiEntityEvent);\r\n        ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);\r\n        assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());\r\n        assertEquals(deployment.getId(), ((Deployment) event.getEntity()).getId());\r\n        assertTrue(listener.getEventsReceived().get(1) instanceof ActivitiEntityEvent);\r\n        event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);\r\n        assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());\r\n        assertEquals(deployment.getId(), ((Deployment) event.getEntity()).getId());\r\n        listener.clearEventsReceived();\r\n        repositoryService.setDeploymentCategory(deployment.getId(), \"test\");\r\n        assertEquals(1, listener.getEventsReceived().size());\r\n        assertTrue(listener.getEventsReceived().get(0) instanceof ActivitiEntityEvent);\r\n        event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);\r\n        assertEquals(ActivitiEventType.ENTITY_UPDATED, event.getType());\r\n        assertEquals(deployment.getId(), ((Deployment) event.getEntity()).getId());\r\n        assertEquals(\"test\", ((Deployment) event.getEntity()).getCategory());\r\n        listener.clearEventsReceived();\r\n        repositoryService.deleteDeployment(deployment.getId(), true);\r\n        assertEquals(1, listener.getEventsReceived().size());\r\n        assertTrue(listener.getEventsReceived().get(0) instanceof ActivitiEntityEvent);\r\n        event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);\r\n        assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());\r\n        assertEquals(deployment.getId(), ((Deployment) event.getEntity()).getId());\r\n        listener.clearEventsReceived();\r\n    } finally {\r\n        if (deployment != null && repositoryService.createDeploymentQuery().deploymentId(deployment.getId()).count() > 0) {\r\n            repositoryService.deleteDeployment(deployment.getId(), true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.android.support.exopackage.ExoHelper.triggerCallbacks",
	"Comment": "trigger all callbacks which have registered to receive notifications when the moduledefinitions have changed on disk",
	"Method": "void triggerCallbacks(){\r\n    synchronized (sCallbacks) {\r\n        for (OnModulesChangedCallback mCallback : sCallbacks) {\r\n            mCallback.onModulesChanged();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.auto.value.processor.AutoAnnotationProcessor.reportError",
	"Comment": "issue a compilation error. this method does not throw an exception, since we want to continueprocessing and perhaps report other errors.",
	"Method": "void reportError(Element e,String msg,Object msgParams){\r\n    String formattedMessage = String.format(msg, msgParams);\r\n    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, formattedMessage, e);\r\n}"
}, {
	"Path": "com.facebook.buck.android.packageable.AndroidPackageableCollector.addManifestPiece",
	"Comment": "add a manifest piece associated with the target owner. if part of a module the manifest pieceswill be included in both the module manifest and the base apk manifest",
	"Method": "AndroidPackageableCollector addManifestPiece(BuildTarget owner,SourcePath manifest){\r\n    collectionBuilder.putAndroidManifestPieces(apkModuleGraph.findResourceModuleForTarget(owner), manifest);\r\n    return this;\r\n}"
}, {
	"Path": "org.antlr.v4.tool.Grammar.defineChannelName",
	"Comment": "define a token channel with a specified name.\tif a channel with the specified name already exists, the previously\tassigned channel value is not altered.",
	"Method": "int defineChannelName(String name,int defineChannelName,String name,int value){\r\n    Integer prev = channelNameToValueMap.get(name);\r\n    if (prev != null) {\r\n        return prev;\r\n    }\r\n    channelNameToValueMap.put(name, value);\r\n    setChannelNameForValue(value, name);\r\n    maxChannelType = Math.max(maxChannelType, value);\r\n    return value;\r\n}"
}, {
	"Path": "org.antlr.v4.codegen.model.RuleFunction.getDeclsForAllElements",
	"Comment": "for all alts, find which ref x or r needs list\t must see across alts. if any alt needs x or r as list, then\t define as list.",
	"Method": "Set<Decl> getDeclsForAllElements(List<AltAST> altASTs){\r\n    Set<String> needsList = new HashSet<String>();\r\n    Set<String> nonOptional = new HashSet<String>();\r\n    List<GrammarAST> allRefs = new ArrayList<GrammarAST>();\r\n    boolean firstAlt = true;\r\n    IntervalSet reftypes = new IntervalSet(RULE_REF, TOKEN_REF, STRING_LITERAL);\r\n    for (AltAST ast : altASTs) {\r\n        List<GrammarAST> refs = getRuleTokens(ast.getNodesWithType(reftypes));\r\n        allRefs.addAll(refs);\r\n        Pair<FrequencySet<String>, FrequencySet<String>> minAndAltFreq = getElementFrequenciesForAlt(ast);\r\n        FrequencySet<String> minFreq = minAndAltFreq.a;\r\n        FrequencySet<String> altFreq = minAndAltFreq.b;\r\n        for (GrammarAST t : refs) {\r\n            String refLabelName = getName(t);\r\n            if (refLabelName != null) {\r\n                if (altFreq.count(refLabelName) > 1) {\r\n                    needsList.add(refLabelName);\r\n                }\r\n                if (firstAlt && minFreq.count(refLabelName) != 0) {\r\n                    nonOptional.add(refLabelName);\r\n                }\r\n            }\r\n        }\r\n        for (String ref : nonOptional.toArray(new String[nonOptional.size()])) {\r\n            if (minFreq.count(ref) == 0) {\r\n                nonOptional.remove(ref);\r\n            }\r\n        }\r\n        firstAlt = false;\r\n    }\r\n    Set<Decl> decls = new LinkedHashSet<Decl>();\r\n    for (GrammarAST t : allRefs) {\r\n        String refLabelName = getName(t);\r\n        if (refLabelName == null) {\r\n            continue;\r\n        }\r\n        List<Decl> d = getDeclForAltElement(t, refLabelName, needsList.contains(refLabelName), !nonOptional.contains(refLabelName));\r\n        decls.addAll(d);\r\n    }\r\n    return decls;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.CDL.toString",
	"Comment": "produce a comma delimited text from a jsonarray of jsonobjects using a provided list of names. the list of names is not included in the output.",
	"Method": "String toString(JSONArray ja,String toString,JSONArray names,JSONArray ja){\r\n    if (names == null || names.length() == 0) {\r\n        return null;\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < ja.length(); i += 1) {\r\n        JSONObject jo = ja.optJSONObject(i);\r\n        if (jo != null) {\r\n            sb.append(rowToString(jo.toJSONArray(names)));\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.facebook.buck.android.support.exopackage.ExoHelper.addOnModulesChangedCallback",
	"Comment": "add a callback which will fire whenever code definitions have changed in the app. this callbackwill be executed on the main thread.",
	"Method": "void addOnModulesChangedCallback(OnModulesChangedCallback callback){\r\n    synchronized (sCallbacks) {\r\n        sCallbacks.add(callback);\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.event.ProcessDefinitionEventsTest.testTimerStartEventDeployment",
	"Comment": "test sequence of events for process definition with timer start event",
	"Method": "void testTimerStartEventDeployment(){\r\n    ProcessDefinitionEntity processDefinition = (ProcessDefinitionEntity) repositoryService.createProcessDefinitionQuery().processDefinitionKey(\"startTimerEventExample\").singleResult();\r\n    ActivitiEntityEvent processDefinitionCreated = ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_CREATED, processDefinition);\r\n    TimerJobEntity timer = (TimerJobEntity) managementService.createTimerJobQuery().singleResult();\r\n    ActivitiEntityEvent timerCreated = ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_CREATED, timer);\r\n    assertSequence(processDefinitionCreated, timerCreated);\r\n    listener.clearEventsReceived();\r\n}"
}, {
	"Path": "com.facebook.buck.android.support.exopackage.ExoHelper.restartActivity",
	"Comment": "restart the given activity. the same intent will be used to launch the new activity, preservingactions, extras, etc. must be run on the main thread.",
	"Method": "void restartActivity(Activity activity){\r\n    assertIsUiThread();\r\n    final Intent intent = activity.getIntent();\r\n    activity.startActivity(intent);\r\n    activity.finish();\r\n}"
}, {
	"Path": "com.facebook.buck.apple.MultiarchFileInfos.create",
	"Comment": "inspect the given build target and return information about it if its a fat binary.",
	"Method": "Optional<MultiarchFileInfo> create(FlavorDomain<AppleCxxPlatform> appleCxxPlatforms,BuildTarget target){\r\n    ImmutableList<ImmutableSortedSet<Flavor>> thinFlavorSets = generateThinFlavors(appleCxxPlatforms.getFlavors(), target.getFlavors());\r\n    if (thinFlavorSets.size() <= 1) {\r\n        return Optional.empty();\r\n    }\r\n    assertTargetSupportsMultiarch(target);\r\n    AppleCxxPlatform representativePlatform = null;\r\n    AppleSdk sdk = null;\r\n    for (SortedSet<Flavor> flavorSet : thinFlavorSets) {\r\n        AppleCxxPlatform platform = Objects.requireNonNull(appleCxxPlatforms.getValue(flavorSet).orElse(null));\r\n        if (sdk == null) {\r\n            sdk = platform.getAppleSdk();\r\n            representativePlatform = platform;\r\n        } else if (sdk != platform.getAppleSdk()) {\r\n            throw new HumanReadableException(\"%s: Fat binaries can only be generated from binaries compiled for the same SDK.\", target);\r\n        }\r\n    }\r\n    MultiarchFileInfo.Builder builder = MultiarchFileInfo.builder().setFatTarget(target).setRepresentativePlatform(Objects.requireNonNull(representativePlatform));\r\n    BuildTarget platformFreeTarget = target.withoutFlavors(appleCxxPlatforms.getFlavors());\r\n    for (SortedSet<Flavor> flavorSet : thinFlavorSets) {\r\n        builder.addThinTargets(platformFreeTarget.withFlavors(flavorSet));\r\n    }\r\n    return Optional.of(builder.build());\r\n}"
}, {
	"Path": "org.activiti.engine.test.bpmn.event.message.MessageEventSubprocessTest.testTwoInterruptingUnderProcessDefinition",
	"Comment": "checks if unused event subscriptions are properly deleted.",
	"Method": "void testTwoInterruptingUnderProcessDefinition(){\r\n    testInterruptingUnderProcessDefinition(2, 4);\r\n}"
}, {
	"Path": "com.taobao.arthas.core.util.FileUtils.saveCommandHistory",
	"Comment": "save the command history to the given file, data will be overridden.",
	"Method": "void saveCommandHistory(List<int[]> history,File file){\r\n    OutputStream out = null;\r\n    try {\r\n        out = openOutputStream(file, false);\r\n        for (int[] command : history) {\r\n            for (int i : command) {\r\n                out.write(i);\r\n            }\r\n            out.write('\\n');\r\n        }\r\n    } catch (IOException e) {\r\n    } finally {\r\n        try {\r\n            if (out != null) {\r\n                out.close();\r\n            }\r\n        } catch (IOException ioe) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetOptionHandler.getAcceptLocal",
	"Comment": "returns a boolean indicating whether to accept a dorequest coming from the other end.",
	"Method": "boolean getAcceptLocal(){\r\n    return (acceptLocal);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONObject.optString",
	"Comment": "get an optional string associated with a key. it returns the defaultvalue if there is no such key.",
	"Method": "String optString(String key,String optString,String key,String defaultValue){\r\n    Object o = opt(key);\r\n    return o != null ? o.toString() : defaultValue;\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.BufferedTokenStream.getTokens",
	"Comment": "given a start and stop index, return a list of all tokens in the token type bitset.return null if no tokens were found.this method looks at both on and off channel tokens.",
	"Method": "List<Token> getTokens(List<Token> getTokens,int start,int stop,List<Token> getTokens,int start,int stop,Set<Integer> types,List<Token> getTokens,int start,int stop,int ttype){\r\n    HashSet<Integer> s = new HashSet<Integer>(ttype);\r\n    s.add(ttype);\r\n    return getTokens(start, stop, s);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.cmd.NeedsActiveTaskCmd.execute",
	"Comment": "subclasses must implement in this method their normal command logic. the provided task is ensured to be active.",
	"Method": "T execute(CommandContext commandContext,T execute,CommandContext commandContext,TaskEntity task){\r\n    if (taskId == null) {\r\n        throw new ActivitiIllegalArgumentException(\"taskId is null\");\r\n    }\r\n    TaskEntity task = commandContext.getTaskEntityManager().findById(taskId);\r\n    if (task == null) {\r\n        throw new ActivitiObjectNotFoundException(\"Cannot find task with id \" + taskId, Task.class);\r\n    }\r\n    if (task.isSuspended()) {\r\n        throw new ActivitiException(getSuspendedTaskException());\r\n    }\r\n    return execute(commandContext, task);\r\n}"
}, {
	"Path": "org.apache.commons.net.DatagramSocketClient.getSoTimeout",
	"Comment": "returns the timeout in milliseconds of the currently opened socket.if you call this method when the client socket is not open,a nullpointerexception is thrown.",
	"Method": "int getSoTimeout(){\r\n    return _socket_.getSoTimeout();\r\n}"
}, {
	"Path": "com.fernandocejas.android10.sample.data.cache.FileManager.exists",
	"Comment": "returns a boolean indicating whether this file can be found on the underlying file system.",
	"Method": "boolean exists(File file){\r\n    return file.exists();\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.Recognizer.setState",
	"Comment": "indicate that the recognizer has changed internal state that is\t consistent with the atn state passed in.this way we always know\t where we are in the atn as the parser goes along. the rule\t context objects form a stack that lets us see the stack of\t invoking rules. combine this and we have complete atn\t configuration information.",
	"Method": "void setState(int atnState){\r\n    _stateNumber = atnState;\r\n}"
}, {
	"Path": "com.google.auto.value.processor.AutoAnnotationProcessor.invariableHashes",
	"Comment": "returns a map from the names of members with invariable hashcodes to the values of thosehashcodes.",
	"Method": "ImmutableMap<String, Integer> invariableHashes(ImmutableMap<String, Member> members,ImmutableSet<String> parameters){\r\n    ImmutableMap.Builder<String, Integer> builder = ImmutableMap.builder();\r\n    for (String element : members.keySet()) {\r\n        if (!parameters.contains(element)) {\r\n            Member member = members.get(element);\r\n            AnnotationValue annotationValue = member.method.getDefaultValue();\r\n            Optional<Integer> invariableHash = invariableHash(annotationValue);\r\n            if (invariableHash.isPresent()) {\r\n                builder.put(element, (element.hashCode() * 127) ^ invariableHash.get());\r\n            }\r\n        }\r\n    }\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.google.auto.value.processor.AutoValueOrOneOfProcessor.annotationStrings",
	"Comment": "returns the spelling to be used in the generated code for the given list of annotations.",
	"Method": "ImmutableList<String> annotationStrings(List<? extends AnnotationMirror> annotations){\r\n    return ImmutableList.copyOf(annotations.stream().map(AnnotationOutput::sourceFormForAnnotation).collect(toList()));\r\n}"
}, {
	"Path": "org.apache.commons.net.ProtocolCommandEvent.getReplyCode",
	"Comment": "returns the reply code of the received server reply.undefined ifthis is not a reply event.",
	"Method": "int getReplyCode(){\r\n    return __replyCode;\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.filter.GPUImageToonFilter.setQuantizationLevels",
	"Comment": "the levels of quantization for the posterization of colors within the scene, with a default of 10.0.",
	"Method": "void setQuantizationLevels(float quantizationLevels){\r\n    this.quantizationLevels = quantizationLevels;\r\n    setFloat(quantizationLevelsLocation, quantizationLevels);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONObject.optJSONObject",
	"Comment": "get an optional jsonobject associated with a key. it returns null if there is no such key, or if its value is not a jsonobject.",
	"Method": "JSONObject optJSONObject(String key){\r\n    Object o = opt(key);\r\n    return o instanceof JSONObject ? (JSONObject) o : null;\r\n}"
}, {
	"Path": "org.antlr.v4.gui.PostScriptDocument.header",
	"Comment": "compute the header separately because we need to wait for the bounding box",
	"Method": "StringBuilder header(){\r\n    StringBuilder b = new StringBuilder();\r\n    b.append(\"%!PS-Adobe-3.0 EPSF-3.0\\n\");\r\n    b.append(boundingBox).append(\"\\n\");\r\n    b.append(\"0.3 setlinewidth\\n\");\r\n    b.append(\"%% x y w h highlight\\n\" + \"/highlight {\\n\" + \"        4 dict begin\\n\" + \"        /h exch def\\n\" + \"        /w exch def\\n\" + \"        /y exch def\\n\" + \"        /x exch def\\n\" + \"        gsave\\n\" + \"        newpath\\n\" + \"        x y moveto\\n\" + \"        0 h rlineto     % up to left corner\\n\" + \"        w 0 rlineto     % to upper right corner\\n\" + \"        0 h neg rlineto % to lower right corner\\n\" + \"        w neg 0 rlineto % back home to lower left corner\\n\" + \"        closepath\\n\" + \"        .95 .83 .82 setrgbcolor\\n\" + \"        fill\\n\" + \"        grestore\\n\" + \"        end\\n\" + \"} def\\n\");\r\n    return b;\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetCommand.isValidCommand",
	"Comment": "determines if a given command code is valid.returns true if valid,false if not.",
	"Method": "boolean isValidCommand(int code){\r\n    return (code <= __FIRST_COMMAND && code >= __LAST_COMMAND);\r\n}"
}, {
	"Path": "com.facebook.buck.cli.TargetsCommand.printDotFormat",
	"Comment": "output rules along with dependencies as a graph in dot format as a part of invocation,constructs both target and action graphs",
	"Method": "void printDotFormat(CommandRunnerParams params,ListeningExecutorService executor){\r\n    TargetGraphAndBuildTargets targetGraphAndTargets = buildTargetGraphAndTargets(params, executor);\r\n    TargetGraph targetGraph = getSubgraphWithoutConfigurationNodes(targetGraphAndTargets.getTargetGraph());\r\n    ActionGraphAndBuilder result = params.getActionGraphProvider().getActionGraph(targetGraph);\r\n    MutableDirectedGraph<BuildRule> actionGraphMutable = new MutableDirectedGraph();\r\n    for (BuildRule rule : result.getActionGraph().getNodes()) {\r\n        actionGraphMutable.addNode(rule);\r\n        for (BuildRule node : rule.getBuildDeps()) {\r\n            actionGraphMutable.addEdge(rule, node);\r\n        }\r\n    }\r\n    try (RuleKeyCacheScope<RuleKey> ruleKeyCacheScope = getDefaultRuleKeyCacheScope(params, new RuleKeyCacheRecycler.SettingsAffectingCache(params.getBuckConfig().getKeySeed(), result.getActionGraph()))) {\r\n        SourcePathRuleFinder ruleFinder = new SourcePathRuleFinder(result.getActionGraphBuilder());\r\n        DefaultRuleKeyFactory ruleKeyFactory = new DefaultRuleKeyFactory(new RuleKeyFieldLoader(params.getRuleKeyConfiguration()), params.getFileHashCache(), DefaultSourcePathResolver.from(ruleFinder), ruleFinder, ruleKeyCacheScope.getCache(), Optional.empty());\r\n        Dot.builder(new DirectedAcyclicGraph(actionGraphMutable), \"action_graph\").setNodeToName(node -> node.getFullyQualifiedName() + \" \" + node.getType() + \" \" + ruleKeyFactory.build(node)).setNodeToTypeName(node -> node.getType()).build().writeOutput(params.getConsole().getStdOut());\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.test.bpmn.subprocess.SubProcessTest.IGNORE_testSimpleSubProcessWithConcurrentTimer",
	"Comment": "a test case that has a timer attached to the subprocess, where 2 concurrent paths are defined when the timer fires.",
	"Method": "void IGNORE_testSimpleSubProcessWithConcurrentTimer(){\r\n    ProcessInstance pi = runtimeService.startProcessInstanceByKey(\"simpleSubProcessWithConcurrentTimer\");\r\n    TaskQuery taskQuery = taskService.createTaskQuery().processInstanceId(pi.getId()).orderByTaskName().asc();\r\n    Task subProcessTask = taskQuery.singleResult();\r\n    assertEquals(\"Task in subprocess\", subProcessTask.getName());\r\n    Job job = managementService.createJobQuery().singleResult();\r\n    managementService.executeJob(job.getId());\r\n    List<Task> tasksAfterTimer = taskQuery.list();\r\n    assertEquals(2, tasksAfterTimer.size());\r\n    Task taskAfterTimer1 = tasksAfterTimer.get(0);\r\n    Task taskAfterTimer2 = tasksAfterTimer.get(1);\r\n    assertEquals(\"Task after timer 1\", taskAfterTimer1.getName());\r\n    assertEquals(\"Task after timer 2\", taskAfterTimer2.getName());\r\n    taskService.complete(taskAfterTimer1.getId());\r\n    taskService.complete(taskAfterTimer2.getId());\r\n    assertProcessEnded(pi.getId());\r\n}"
}, {
	"Path": "com.facebook.buck.android.apkmodule.APKModuleGraph.getRootAPKModule",
	"Comment": "get the apkmodule representing the core application that is always included in the apk",
	"Method": "APKModule getRootAPKModule(){\r\n    return rootAPKModuleSupplier.get();\r\n}"
}, {
	"Path": "org.activiti.engine.ProcessEngines.getProcessEngines",
	"Comment": "provides access to process engine to application clients in a managed server environment.",
	"Method": "Map<String, ProcessEngine> getProcessEngines(){\r\n    return processEngines;\r\n}"
}, {
	"Path": "org.asynchttpclient.util.ProxyUtils.createProxyServerSelector",
	"Comment": "create a proxy server selector based on the passed in jdk proxy selector.",
	"Method": "ProxyServerSelector createProxyServerSelector(Properties properties,ProxyServerSelector createProxyServerSelector,ProxySelector proxySelector){\r\n    return uri -> {\r\n        try {\r\n            URI javaUri = uri.toJavaNetURI();\r\n            List<Proxy> proxies = proxySelector.select(javaUri);\r\n            if (proxies != null) {\r\n                for (Proxy proxy : proxies) {\r\n                    switch(proxy.type()) {\r\n                        case HTTP:\r\n                            if (!(proxy.address() instanceof InetSocketAddress)) {\r\n                                logger.warn(\"Don't know how to connect to address \" + proxy.address());\r\n                                return null;\r\n                            } else {\r\n                                InetSocketAddress address = (InetSocketAddress) proxy.address();\r\n                                return proxyServer(address.getHostName(), address.getPort()).build();\r\n                            }\r\n                        case DIRECT:\r\n                            return null;\r\n                        default:\r\n                            logger.warn(\"ProxySelector returned proxy type that we don't know how to use: \" + proxy.type());\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        } catch (URISyntaxException e) {\r\n            logger.warn(uri + \" couldn't be turned into a java.net.URI\", e);\r\n            return null;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.taobao.arthas.core.shell.term.TermServer.createHttpTermServer",
	"Comment": "create a term server for the http protocol, using an existing router.",
	"Method": "TermServer createHttpTermServer(){\r\n    return null;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONObject.testValidity",
	"Comment": "throw an exception if the object is an nan or infinite number.",
	"Method": "void testValidity(Object o){\r\n    if (o != null) {\r\n        if (o instanceof Double) {\r\n            if (((Double) o).isInfinite() || ((Double) o).isNaN()) {\r\n                throw new JSONException(\"JSON does not allow non-finite numbers.\");\r\n            }\r\n        } else if (o instanceof Float) {\r\n            if (((Float) o).isInfinite() || ((Float) o).isNaN()) {\r\n                throw new JSONException(\"JSON does not allow non-finite numbers.\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.auto.common.BasicAnnotationProcessor.validElements",
	"Comment": "returns the valid annotated elements contained in all of the deferred elements. if none arefound for a deferred element, defers it again.",
	"Method": "ImmutableSetMultimap<Class<? extends Annotation>, Element> validElements(ImmutableMap<String, Optional<? extends Element>> deferredElements,RoundEnvironment roundEnv){\r\n    ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element> deferredElementsByAnnotationBuilder = ImmutableSetMultimap.builder();\r\n    for (Entry<String, Optional<? extends Element>> deferredTypeElementEntry : deferredElements.entrySet()) {\r\n        Optional<? extends Element> deferredElement = deferredTypeElementEntry.getValue();\r\n        if (deferredElement.isPresent()) {\r\n            findAnnotatedElements(deferredElement.get(), getSupportedAnnotationClasses(), deferredElementsByAnnotationBuilder);\r\n        } else {\r\n            deferredElementNames.add(ElementName.forTypeName(deferredTypeElementEntry.getKey()));\r\n        }\r\n    }\r\n    ImmutableSetMultimap<Class<? extends Annotation>, Element> deferredElementsByAnnotation = deferredElementsByAnnotationBuilder.build();\r\n    ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element> validElements = ImmutableSetMultimap.builder();\r\n    Set<ElementName> validElementNames = new LinkedHashSet<ElementName>();\r\n    for (Class<? extends Annotation> annotationClass : getSupportedAnnotationClasses()) {\r\n        TypeElement annotationType = elements.getTypeElement(annotationClass.getCanonicalName());\r\n        Set<? extends Element> elementsAnnotatedWith = (annotationType == null) ? ImmutableSet.<Element>of() : roundEnv.getElementsAnnotatedWith(annotationType);\r\n        for (Element annotatedElement : Sets.union(elementsAnnotatedWith, deferredElementsByAnnotation.get(annotationClass))) {\r\n            if (annotatedElement.getKind().equals(PACKAGE)) {\r\n                PackageElement annotatedPackageElement = (PackageElement) annotatedElement;\r\n                ElementName annotatedPackageName = ElementName.forPackageName(annotatedPackageElement.getQualifiedName().toString());\r\n                boolean validPackage = validElementNames.contains(annotatedPackageName) || (!deferredElementNames.contains(annotatedPackageName) && validateElement(annotatedPackageElement));\r\n                if (validPackage) {\r\n                    validElements.put(annotationClass, annotatedPackageElement);\r\n                    validElementNames.add(annotatedPackageName);\r\n                } else {\r\n                    deferredElementNames.add(annotatedPackageName);\r\n                }\r\n            } else {\r\n                TypeElement enclosingType = getEnclosingType(annotatedElement);\r\n                ElementName enclosingTypeName = ElementName.forTypeName(enclosingType.getQualifiedName().toString());\r\n                boolean validEnclosingType = validElementNames.contains(enclosingTypeName) || (!deferredElementNames.contains(enclosingTypeName) && validateElement(enclosingType));\r\n                if (validEnclosingType) {\r\n                    validElements.put(annotationClass, annotatedElement);\r\n                    validElementNames.add(enclosingTypeName);\r\n                } else {\r\n                    deferredElementNames.add(enclosingTypeName);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return validElements.build();\r\n}"
}, {
	"Path": "org.antlr.v4.codegen.model.RuleFunction.getElementFrequenciesForAlt",
	"Comment": "given list of x and r refs in alt, compute how many of each there are",
	"Method": "Pair<FrequencySet<String>, FrequencySet<String>> getElementFrequenciesForAlt(AltAST ast){\r\n    try {\r\n        ElementFrequenciesVisitor visitor = new ElementFrequenciesVisitor(new CommonTreeNodeStream(new GrammarASTAdaptor(), ast));\r\n        visitor.outerAlternative();\r\n        if (visitor.frequencies.size() != 1) {\r\n            factory.getGrammar().tool.errMgr.toolError(ErrorType.INTERNAL_ERROR);\r\n            return new Pair(new FrequencySet<String>(), new FrequencySet<String>());\r\n        }\r\n        return new Pair(visitor.getMinFrequencies(), visitor.frequencies.peek());\r\n    } catch (RecognitionException ex) {\r\n        factory.getGrammar().tool.errMgr.toolError(ErrorType.INTERNAL_ERROR, ex);\r\n        return new Pair(new FrequencySet<String>(), new FrequencySet<String>());\r\n    }\r\n}"
}, {
	"Path": "com.google.auto.factory.processor.Elements2.getExecutableElementAsMemberOf",
	"Comment": "given an executable element in a supertype, returns its executabletype when it is viewed as amember of a subtype.",
	"Method": "ExecutableType getExecutableElementAsMemberOf(Types types,ExecutableElement executableElement,TypeElement subTypeElement){\r\n    checkNotNull(types);\r\n    checkNotNull(executableElement);\r\n    checkNotNull(subTypeElement);\r\n    TypeMirror subTypeMirror = subTypeElement.asType();\r\n    if (!subTypeMirror.getKind().equals(TypeKind.DECLARED)) {\r\n        throw new IllegalStateException(\"Expected subTypeElement.asType() to return a class/interface type.\");\r\n    }\r\n    TypeMirror subExecutableTypeMirror = types.asMemberOf((DeclaredType) subTypeMirror, executableElement);\r\n    if (!subExecutableTypeMirror.getKind().equals(TypeKind.EXECUTABLE)) {\r\n        throw new IllegalStateException(\"Expected subExecutableTypeMirror to be an executable type.\");\r\n    }\r\n    return (ExecutableType) subExecutableTypeMirror;\r\n}"
}, {
	"Path": "com.google.classyshark.analytics.JGoogleAnalyticsTracker.setUrlBuildingStrategy",
	"Comment": "setter injection for urlbuildingstrategy incase if you want to use a different url building logic.",
	"Method": "void setUrlBuildingStrategy(URLBuildingStrategy urlBuildingStrategy){\r\n    this.urlBuildingStrategy = urlBuildingStrategy;\r\n}"
}, {
	"Path": "org.activiti.engine.test.bpmn.deployment.MessageEventsAndNewVersionDeploymentsTest.testBoundaryEventSubscrptionsDeletedOnProcessInstanceDelete",
	"Comment": "verifying that the event subscriptions do get removed when removing a process instance.",
	"Method": "void testBoundaryEventSubscrptionsDeletedOnProcessInstanceDelete(){\r\n    String deploymentId1 = deployBoundaryMessageTestProcess();\r\n    runtimeService.startProcessInstanceByKey(\"messageTest\");\r\n    assertEquals(\"My Task\", taskService.createTaskQuery().singleResult().getName());\r\n    String deploymentId2 = deployBoundaryMessageTestProcess();\r\n    ProcessInstance processInstance2 = runtimeService.startProcessInstanceByKey(\"messageTest\");\r\n    assertEquals(2, taskService.createTaskQuery().count());\r\n    assertEquals(2, getAllEventSubscriptions().size());\r\n    runtimeService.deleteProcessInstance(processInstance2.getId(), \"testing\");\r\n    assertEquals(\"My Task\", taskService.createTaskQuery().singleResult().getName());\r\n    assertEquals(1, getAllEventSubscriptions().size());\r\n    runtimeService.messageEventReceived(\"myMessage\", getExecutionIdsForMessageEventSubscription(\"myMessage\").get(0));\r\n    assertEquals(0, getAllEventSubscriptions().size());\r\n    assertEquals(\"Task after message\", taskService.createTaskQuery().singleResult().getName());\r\n    cleanup(deploymentId1, deploymentId2);\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.GPUImage.setScaleType",
	"Comment": "this sets the scale type of gpuimage. this has to be run before setting the image.if image is set and scale type changed, image needs to be reset.",
	"Method": "void setScaleType(ScaleType scaleType){\r\n    this.scaleType = scaleType;\r\n    renderer.setScaleType(scaleType);\r\n    renderer.deleteImage();\r\n    currentBitmap = null;\r\n    requestRender();\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.atn.ParserATNSimulator.computeTargetState",
	"Comment": "compute a target state for an edge in the dfa, and attempt to add the\tcomputed state and corresponding edge to the dfa.",
	"Method": "DFAState computeTargetState(DFA dfa,DFAState previousD,int t){\r\n    ATNConfigSet reach = computeReachSet(previousD.configs, t, false);\r\n    if (reach == null) {\r\n        addDFAEdge(dfa, previousD, t, ERROR);\r\n        return ERROR;\r\n    }\r\n    DFAState D = new DFAState(reach);\r\n    int predictedAlt = getUniqueAlt(reach);\r\n    if (debug) {\r\n        Collection<BitSet> altSubSets = PredictionMode.getConflictingAltSubsets(reach);\r\n        System.out.println(\"SLL altSubSets=\" + altSubSets + \", configs=\" + reach + \", predict=\" + predictedAlt + \", allSubsetsConflict=\" + PredictionMode.allSubsetsConflict(altSubSets) + \", conflictingAlts=\" + getConflictingAlts(reach));\r\n    }\r\n    if (predictedAlt != ATN.INVALID_ALT_NUMBER) {\r\n        D.isAcceptState = true;\r\n        D.configs.uniqueAlt = predictedAlt;\r\n        D.prediction = predictedAlt;\r\n    } else if (PredictionMode.hasSLLConflictTerminatingPrediction(mode, reach)) {\r\n        D.configs.conflictingAlts = getConflictingAlts(reach);\r\n        D.requiresFullContext = true;\r\n        D.isAcceptState = true;\r\n        D.prediction = D.configs.conflictingAlts.nextSetBit(0);\r\n    }\r\n    if (D.isAcceptState && D.configs.hasSemanticContext) {\r\n        predicateDFAState(D, atn.getDecisionState(dfa.decision));\r\n        if (D.predicates != null) {\r\n            D.prediction = ATN.INVALID_ALT_NUMBER;\r\n        }\r\n    }\r\n    D = addDFAEdge(dfa, previousD, t, D);\r\n    return D;\r\n}"
}, {
	"Path": "com.google.auto.value.processor.AnnotationOutput.sourceFormForAnnotation",
	"Comment": "returns a string representation of the given annotation mirror, suitable for inclusion in ajava source file to reproduce the annotation in source form.",
	"Method": "String sourceFormForAnnotation(AnnotationMirror annotationMirror){\r\n    StringBuilder sb = new StringBuilder();\r\n    new AnnotationSourceFormVisitor().visitAnnotation(annotationMirror, sb);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.BootstrapProgressBar.setMaxProgress",
	"Comment": "used for settings the maxprogress. also check if currentprogress is smaller than newmaxprogress.",
	"Method": "void setMaxProgress(int newMaxProgress){\r\n    if (getProgress() <= newMaxProgress) {\r\n        maxProgress = newMaxProgress;\r\n    } else {\r\n        throw new IllegalArgumentException(String.format(\"MaxProgress cant be smaller than the current progress %d<%d\", getProgress(), newMaxProgress));\r\n    }\r\n    invalidate();\r\n    BootstrapProgressBarGroup parent = (BootstrapProgressBarGroup) getParent();\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.TypefaceProvider.registerCustomIconSet",
	"Comment": "registers a custom iconset, so that it is available for use throughout the whole application.",
	"Method": "void registerCustomIconSet(IconSet iconSet){\r\n    REGISTERED_ICON_SETS.put(iconSet.fontPath(), iconSet);\r\n}"
}, {
	"Path": "com.google.auto.value.processor.AutoValueOrOneOfProcessor.defineSharedVarsForType",
	"Comment": "defines the template variables that are shared by autovalue and autooneof.",
	"Method": "void defineSharedVarsForType(TypeElement type,ImmutableSet<ExecutableElement> methods,AutoValueOrOneOfTemplateVars vars){\r\n    vars.pkg = TypeSimplifier.packageNameOf(type);\r\n    vars.origClass = TypeSimplifier.classNameOf(type);\r\n    vars.simpleClassName = TypeSimplifier.simpleNameOf(vars.origClass);\r\n    vars.generated = generatedAnnotation(elementUtils(), processingEnv.getSourceVersion()).map(annotation -> TypeEncoder.encode(annotation.asType())).orElse(\"\");\r\n    vars.formalTypes = TypeEncoder.formalTypeParametersString(type);\r\n    vars.actualTypes = TypeSimplifier.actualTypeParametersString(type);\r\n    vars.wildcardTypes = wildcardTypeParametersString(type);\r\n    vars.annotations = copiedClassAnnotations(type);\r\n    Map<ObjectMethod, ExecutableElement> methodsToGenerate = determineObjectMethodsToGenerate(methods);\r\n    vars.toString = methodsToGenerate.containsKey(ObjectMethod.TO_STRING);\r\n    vars.equals = methodsToGenerate.containsKey(ObjectMethod.EQUALS);\r\n    vars.hashCode = methodsToGenerate.containsKey(ObjectMethod.HASH_CODE);\r\n    vars.equalsParameterType = equalsParameterType(methodsToGenerate);\r\n}"
}, {
	"Path": "com.facebook.buck.apple.AppleDescriptions.stripBundleSpecificFlavors",
	"Comment": "strip flavors that only apply to a bundle from build targets that are passed to constituentrules of the bundle, such as its associated binary, asset catalog, etc.",
	"Method": "BuildTarget stripBundleSpecificFlavors(BuildTarget buildTarget){\r\n    return buildTarget.withoutFlavors(BUNDLE_SPECIFIC_FLAVORS);\r\n}"
}, {
	"Path": "com.google.auto.value.extension.AutoValueExtension.mustBeFinal",
	"Comment": "denotes that the class generated by this extension must be the final class in the inheritancehierarchy. only one extension may be the final class, so this should be used sparingly.",
	"Method": "boolean mustBeFinal(Context context){\r\n    return false;\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.filter.GPUImageBulgeDistortionFilter.setRadius",
	"Comment": "the radius of the distortion, ranging from 0.0 to 1.0, with a default of 0.25",
	"Method": "void setRadius(float radius){\r\n    this.radius = radius;\r\n    setFloat(radiusLocation, radius);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.db.DbSqlSession.removeUnnecessaryOperations",
	"Comment": "clears all deleted and inserted objects from the cache,and removes inserts and deletes that cancel each other.also removes deletes with duplicate ids.",
	"Method": "void removeUnnecessaryOperations(){\r\n    for (Class<? extends Entity> entityClass : deletedObjects.keySet()) {\r\n        Set<String> ids = new HashSet<String>();\r\n        Iterator<Entity> entitiesToDeleteIterator = deletedObjects.get(entityClass).values().iterator();\r\n        while (entitiesToDeleteIterator.hasNext()) {\r\n            Entity entityToDelete = entitiesToDeleteIterator.next();\r\n            if (!ids.contains(entityToDelete.getId())) {\r\n                ids.add(entityToDelete.getId());\r\n            } else {\r\n                entitiesToDeleteIterator.remove();\r\n            }\r\n        }\r\n        for (String id : ids) {\r\n            if (insertedObjects.containsKey(entityClass) && insertedObjects.get(entityClass).containsKey(id)) {\r\n                insertedObjects.get(entityClass).remove(id);\r\n                deletedObjects.get(entityClass).remove(id);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.asynchttpclient.RedirectConnectionUsageTest.testGetRedirectFinalUrl",
	"Comment": "tests that after a redirect the final url in the response reflect the redirect",
	"Method": "void testGetRedirectFinalUrl(){\r\n    AsyncHttpClientConfig config = config().setKeepAlive(true).setMaxConnectionsPerHost(1).setMaxConnections(1).setConnectTimeout(1000).setRequestTimeout(1000).setFollowRedirect(true).build();\r\n    try (AsyncHttpClient c = asyncHttpClient(config)) {\r\n        ListenableFuture<Response> response = c.executeRequest(get(servletEndpointRedirectUrl));\r\n        Response res = response.get();\r\n        assertNotNull(res.getResponseBody());\r\n        assertEquals(res.getUri().toString(), BASE_URL + \"/overthere\");\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.apple.device.AppleDeviceHelper.runBundleOnDevice",
	"Comment": "attempts to run a bundle on the device. the bundle must be installed already.",
	"Method": "boolean runBundleOnDevice(String udid,String bundleID){\r\n    ProcessExecutorParams processExecutorParams = ProcessExecutorParams.builder().setCommand(ImmutableList.of(deviceHelperPath.toString(), \"--json\", udid, \"launch\", bundleID)).build();\r\n    Set<ProcessExecutor.Option> options = EnumSet.of(ProcessExecutor.Option.PRINT_STD_OUT, ProcessExecutor.Option.PRINT_STD_ERR);\r\n    ProcessExecutor.Result result;\r\n    try {\r\n        result = processExecutor.launchAndExecute(processExecutorParams, options, Optional.empty(), Optional.of((long) 60000), Optional.empty());\r\n    } catch (InterruptedException | IOException e) {\r\n        LOG.warn(\"Could not execute device helper.\");\r\n        return false;\r\n    }\r\n    if (result.isTimedOut()) {\r\n        throw new RuntimeException(\"Device helper failed: timed out\");\r\n    }\r\n    return (result.getExitCode() == 0);\r\n}"
}, {
	"Path": "com.facebook.buck.cli.BuildCommand.tryConvertingToStampede",
	"Comment": "mark this build as being automatically converted to stampede.",
	"Method": "boolean tryConvertingToStampede(DistBuildConfig config){\r\n    if (forceDisableDistributedBuild) {\r\n        LOG.warn(String.format(\"%s has been specified. Will not auto-convert build to stampede.\", LOCAL_BUILD_LONG_ARG));\r\n        useDistributedBuild = false;\r\n        return false;\r\n    }\r\n    useDistributedBuild = true;\r\n    Objects.requireNonNull(getDistBuildCommandDelegate()).tryConvertingToStampede(config);\r\n    return true;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.CDL.rowToString",
	"Comment": "produce a comma delimited text row from a jsonarray. values containing the comma character will be quoted. troublesome characters may be removed.",
	"Method": "String rowToString(JSONArray ja){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < ja.length(); i += 1) {\r\n        if (i > 0) {\r\n            sb.append(',');\r\n        }\r\n        Object o = ja.opt(i);\r\n        if (o != null) {\r\n            String s = o.toString();\r\n            if (s.length() > 0 && (s.indexOf(',') >= 0 || s.indexOf('\\n') >= 0 || s.indexOf('\\r') >= 0 || s.indexOf(0) >= 0 || s.charAt(0) == '\"')) {\r\n                sb.append('\"');\r\n                int length = s.length();\r\n                for (int j = 0; j < length; j += 1) {\r\n                    char c = s.charAt(j);\r\n                    if (c >= ' ' && c != '\"') {\r\n                        sb.append(c);\r\n                    }\r\n                }\r\n                sb.append('\"');\r\n            } else {\r\n                sb.append(s);\r\n            }\r\n        }\r\n    }\r\n    sb.append('\\n');\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.AwesomeTextView.setMaterialIcon",
	"Comment": "sets the text to display a materialicon, replacing whatever text is already present.used to set the text to display a materialicon icon.",
	"Method": "void setMaterialIcon(CharSequence iconCode){\r\n    setBootstrapText(new BootstrapText.Builder(getContext(), isInEditMode()).addMaterialIcon(iconCode).build());\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.TypefaceProvider.registerDefaultIconSets",
	"Comment": "registers instances of the default iconsets so that they are available throughout the wholeapplication. currently the default icon sets include fontawesome and typicon.",
	"Method": "void registerDefaultIconSets(){\r\n    final FontAwesome fontAwesome = new FontAwesome();\r\n    final Typicon typicon = new Typicon();\r\n    final MaterialIcons materialIcons = new MaterialIcons();\r\n    REGISTERED_ICON_SETS.put(fontAwesome.fontPath(), fontAwesome);\r\n    REGISTERED_ICON_SETS.put(typicon.fontPath(), typicon);\r\n    REGISTERED_ICON_SETS.put(materialIcons.fontPath(), materialIcons);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONWriter.endObject",
	"Comment": "end an object. this method most be called to balance calls to object.",
	"Method": "JSONWriter endObject(){\r\n    return this.end('k', '}');\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONObject.optJSONArray",
	"Comment": "get an optional jsonarray associated with a key. it returns null if there is no such key, or if its value is not a jsonarray.",
	"Method": "JSONArray optJSONArray(String key){\r\n    Object o = opt(key);\r\n    return o instanceof JSONArray ? (JSONArray) o : null;\r\n}"
}, {
	"Path": "com.google.auto.value.processor.BuilderSpec.abstractMethods",
	"Comment": "return a set of all abstract methods in the given typeelement or inherited from ancestors.",
	"Method": "Set<ExecutableElement> abstractMethods(TypeElement typeElement){\r\n    Set<ExecutableElement> methods = getLocalAndInheritedMethods(typeElement, processingEnv.getTypeUtils(), processingEnv.getElementUtils());\r\n    ImmutableSet.Builder<ExecutableElement> abstractMethods = ImmutableSet.builder();\r\n    for (ExecutableElement method : methods) {\r\n        if (method.getModifiers().contains(Modifier.ABSTRACT)) {\r\n            abstractMethods.add(method);\r\n        }\r\n    }\r\n    return abstractMethods.build();\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.GPUImageView.setRatio",
	"Comment": "todo should be an xml attribute. but then gpuimage can not be distributed as .jar anymore.",
	"Method": "void setRatio(float ratio){\r\n    this.ratio = ratio;\r\n    surfaceView.requestLayout();\r\n    gpuImage.deleteImage();\r\n}"
}, {
	"Path": "com.facebook.buck.core.config.BuckConfig.withBuildTargetParser",
	"Comment": "returns a clone of the current config with a the argument cellpathresolver.",
	"Method": "BuckConfig withBuildTargetParser(Function<String, BuildTarget> buildTargetParser){\r\n    return new BuckConfig(config, projectFilesystem, architecture, platform, environment, buildTargetParser);\r\n}"
}, {
	"Path": "com.facebook.buck.android.exopackage.AndroidDevicesHelper.adbCallOrThrow",
	"Comment": "a simple wrapper around adbcall that will throw if adbcall returns false.",
	"Method": "void adbCallOrThrow(String description,AdbDeviceCallable func,boolean quiet){\r\n    adbCall(description, func, quiet);\r\n}"
}, {
	"Path": "org.antlr.v4.gui.Trees.inspect",
	"Comment": "call this method to view a parse tree in a dialog box visually.",
	"Method": "Future<JFrame> inspect(Tree t,List<String> ruleNames,Future<JFrame> inspect,Tree t,Parser parser){\r\n    List<String> ruleNames = parser != null ? Arrays.asList(parser.getRuleNames()) : null;\r\n    return inspect(t, ruleNames);\r\n}"
}, {
	"Path": "com.facebook.buck.cli.OwnersReport.getInputsWithNoOwners",
	"Comment": "get the set of files that were requested that did not have an owning rule",
	"Method": "ImmutableSet<Path> getInputsWithNoOwners(){\r\n    return inputsWithNoOwners;\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.filter.GPUImageSphereRefractionFilter.setRadius",
	"Comment": "the radius of the distortion, ranging from 0.0 to 1.0, with a default of 0.25",
	"Method": "void setRadius(float radius){\r\n    this.radius = radius;\r\n    setFloat(radiusLocation, radius);\r\n}"
}, {
	"Path": "org.activiti.spring.test.servicetask.UseActivitiServiceInServiceTaskTest.testUseInjectedRuntimeServiceInServiceTask",
	"Comment": "this test will use the dependency injection of spring to inject the runtime service in the java delegate.",
	"Method": "void testUseInjectedRuntimeServiceInServiceTask(){\r\n    runtimeService.startProcessInstanceByKey(\"startProcessFromDelegate\");\r\n    List<ProcessInstance> processInstances = runtimeService.createProcessInstanceQuery().list();\r\n    assertEquals(2, processInstances.size());\r\n    boolean startProcessFromDelegateFound = false;\r\n    boolean oneTaskProcessFound = false;\r\n    for (ProcessInstance processInstance : processInstances) {\r\n        ProcessDefinition processDefinition = repositoryService.getProcessDefinition(processInstance.getProcessDefinitionId());\r\n        if (processDefinition.getKey().equals(\"startProcessFromDelegate\")) {\r\n            startProcessFromDelegateFound = true;\r\n        } else if (processDefinition.getKey().equals(\"oneTaskProcess\")) {\r\n            oneTaskProcessFound = true;\r\n        }\r\n    }\r\n    assertTrue(startProcessFromDelegateFound);\r\n    assertTrue(oneTaskProcessFound);\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetOptionHandler.getDo",
	"Comment": "returns a boolean indicating whether a do request sent to the otherside has been acknowledged.",
	"Method": "boolean getDo(){\r\n    return doFlag;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.el.JsonNodeELResolver.getCommonPropertyType",
	"Comment": "if the base object is not null, returns the most general type that this resolver accepts forthe property argument. otherwise, returns null. assuming the base is not null, this methodwill always return object.class. this is because any object is accepted as a key and iscoerced into a string.",
	"Method": "Class<?> getCommonPropertyType(ELContext context,Object base){\r\n    return isResolvable(base) ? Object.class : null;\r\n}"
}, {
	"Path": "com.facebook.buck.android.agent.AgentMain.doGetSignature",
	"Comment": "print the signature of an apk to stdout. the apk path is passed as the only command lineargument.",
	"Method": "void doGetSignature(List<String> userArgs){\r\n    if (userArgs.size() != 1) {\r\n        throw new IllegalArgumentException(\"usage: get-signature FILE\");\r\n    }\r\n    String packagePath = userArgs.get(0);\r\n    System.out.println(AgentUtil.getJarSignature(packagePath));\r\n}"
}, {
	"Path": "com.google.auto.value.processor.AutoValueOrOneOfProcessor.checkReturnType",
	"Comment": "checks that the return type of the given property method is allowed. currently, this means thatit cannot be an array, unless it is a primitive array.",
	"Method": "void checkReturnType(TypeElement autoValueClass,ExecutableElement getter){\r\n    TypeMirror type = getter.getReturnType();\r\n    if (type.getKind() == TypeKind.ARRAY) {\r\n        TypeMirror componentType = ((ArrayType) type).getComponentType();\r\n        if (componentType.getKind().isPrimitive()) {\r\n            warnAboutPrimitiveArrays(autoValueClass, getter);\r\n        } else {\r\n            errorReporter.reportError(\"An @\" + simpleAnnotationName + \" class cannot define an array-valued property unless it is a primitive array\", getter);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.runtime.ProcessInstanceQueryTest.setUp",
	"Comment": "setup starts 4 process instances of onetaskprocess and 1 instance of onetaskprocess2",
	"Method": "void setUp(){\r\n    super.setUp();\r\n    deployment = repositoryService.createDeployment().addClasspathResource(\"org/activiti/engine/test/api/runtime/oneTaskProcess.bpmn20.xml\").addClasspathResource(\"org/activiti/engine/test/api/runtime/oneTaskProcess2.bpmn20.xml\").deploy();\r\n    processInstanceIds = new ArrayList<String>();\r\n    for (int i = 0; i < PROCESS_DEFINITION_KEY_DEPLOY_COUNT; i++) {\r\n        processInstanceIds.add(runtimeService.startProcessInstanceByKey(PROCESS_DEFINITION_KEY, i + \"\").getId());\r\n    }\r\n    processInstanceIds.add(runtimeService.startProcessInstanceByKey(PROCESS_DEFINITION_KEY_2, \"1\").getId());\r\n}"
}, {
	"Path": "com.taobao.arthas.core.shell.system.impl.InternalCommandManager.complete",
	"Comment": "perform completion, the completion argument will be notified of the completion progress.",
	"Method": "void complete(Completion completion){\r\n    List<CliToken> lineTokens = completion.lineTokens();\r\n    int index = findLastPipe(lineTokens);\r\n    LinkedList<CliToken> tokens = new LinkedList<CliToken>(lineTokens.subList(index + 1, lineTokens.size()));\r\n    while (tokens.size() > 0 && tokens.getFirst().isBlank()) {\r\n        tokens.removeFirst();\r\n    }\r\n    if (tokens.size() > 1) {\r\n        completeSingleCommand(completion, tokens);\r\n    } else {\r\n        completeCommands(completion, tokens);\r\n    }\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.Recognizer.getInterpreter",
	"Comment": "get the atn interpreter used by the recognizer for prediction.",
	"Method": "ATNInterpreter getInterpreter(){\r\n    return _interp;\r\n}"
}, {
	"Path": "com.facebook.buck.core.build.engine.impl.BuildRulePipelinesRunner.removeRule",
	"Comment": "removes a rule from pipeline eligibility. if a pipeline is already running the rule, waits forit to complete before returning.",
	"Method": "void removeRule(SupportsPipelining<?> rule){\r\n    BuildRulePipelineStage<? extends RulePipelineState> pipelineStage = rules.remove(rule);\r\n    if (pipelineStage != null && pipelineStage.pipelineBuilt()) {\r\n        pipelineStage.cancelAndWait();\r\n    }\r\n}"
}, {
	"Path": "org.apache.commons.net.SocketClient.setProxy",
	"Comment": "sets the proxy for use with all the connections.the proxy is used for connections established after thecall to this method.",
	"Method": "void setProxy(Proxy proxy){\r\n    setSocketFactory(new DefaultSocketFactory(proxy));\r\n    connProxy = proxy;\r\n}"
}, {
	"Path": "com.facebook.buck.android.aapt.MiniAapt.extractDocumentLocation",
	"Comment": "extracts document location saved by xmldomparserwithlinenumbers",
	"Method": "DocumentLocation extractDocumentLocation(Node node){\r\n    return (DocumentLocation) node.getUserData(PositionalXmlHandler.LOCATION_USER_DATA_KEY);\r\n}"
}, {
	"Path": "com.fernandocejas.android10.sample.data.net.ApiConnection.requestSyncCall",
	"Comment": "do a request to an api synchronously.it should not be executed in the main thread of the application.",
	"Method": "String requestSyncCall(){\r\n    connectToApi();\r\n    return response;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.behavior.ParallelMultiInstanceBehavior.createInstances",
	"Comment": "handles the parallel case of spawning the instances. will create child executions accordingly for every instance needed.",
	"Method": "int createInstances(DelegateExecution execution){\r\n    int nrOfInstances = resolveNrOfInstances(execution);\r\n    if (nrOfInstances < 0) {\r\n        throw new ActivitiIllegalArgumentException(\"Invalid number of instances: must be non-negative integer value\" + \", but was \" + nrOfInstances);\r\n    }\r\n    execution.setMultiInstanceRoot(true);\r\n    setLoopVariable(execution, NUMBER_OF_INSTANCES, nrOfInstances);\r\n    setLoopVariable(execution, NUMBER_OF_COMPLETED_INSTANCES, 0);\r\n    setLoopVariable(execution, NUMBER_OF_ACTIVE_INSTANCES, nrOfInstances);\r\n    List<DelegateExecution> concurrentExecutions = new ArrayList<DelegateExecution>();\r\n    for (int loopCounter = 0; loopCounter < nrOfInstances; loopCounter++) {\r\n        DelegateExecution concurrentExecution = Context.getCommandContext().getExecutionEntityManager().createChildExecution((ExecutionEntity) execution);\r\n        concurrentExecution.setCurrentFlowElement(activity);\r\n        concurrentExecution.setActive(true);\r\n        concurrentExecution.setScope(false);\r\n        concurrentExecutions.add(concurrentExecution);\r\n        logLoopDetails(concurrentExecution, \"initialized\", loopCounter, 0, nrOfInstances, nrOfInstances);\r\n    }\r\n    for (int loopCounter = 0; loopCounter < nrOfInstances; loopCounter++) {\r\n        DelegateExecution concurrentExecution = concurrentExecutions.get(loopCounter);\r\n        if (concurrentExecution.isActive() && !concurrentExecution.isEnded() && concurrentExecution.getParent().isActive() && !concurrentExecution.getParent().isEnded()) {\r\n            setLoopVariable(concurrentExecution, getCollectionElementIndexVariable(), loopCounter);\r\n            executeOriginalBehavior(concurrentExecution, loopCounter);\r\n        }\r\n    }\r\n    if (!concurrentExecutions.isEmpty()) {\r\n        ExecutionEntity executionEntity = (ExecutionEntity) execution;\r\n        executionEntity.setActive(false);\r\n    }\r\n    return nrOfInstances;\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.Lexer.getText",
	"Comment": "return the text matched so far for the current token or any\t text override.",
	"Method": "String getText(){\r\n    if (_text != null) {\r\n        return _text;\r\n    }\r\n    return getInterpreter().getText(_input);\r\n}"
}, {
	"Path": "org.antlr.v4.codegen.CodeGenerator.getVocabFileName",
	"Comment": "what is the name of the vocab file generated for this grammar?\t returns null if no .tokens file should be generated.",
	"Method": "String getVocabFileName(){\r\n    return g.name + VOCAB_FILE_EXTENSION;\r\n}"
}, {
	"Path": "com.facebook.buck.apple.BuiltinApplePackage.getLegacyWatchStubFromDeps",
	"Comment": "get the stub binary rule from a legacy apple watch extension build rule.",
	"Method": "Optional<WriteFile> getLegacyWatchStubFromDeps(AppleBundle appleBundle){\r\n    for (BuildRule rule : appleBundle.getBuildDeps()) {\r\n        if (rule instanceof AppleBundle && rule.getBuildTarget().getFlavors().contains(AppleBinaryDescription.LEGACY_WATCH_FLAVOR)) {\r\n            AppleBundle legacyWatchApp = (AppleBundle) rule;\r\n            if (legacyWatchApp.getBinary().isPresent()) {\r\n                BuildRule legacyWatchStub = legacyWatchApp.getBinary().get();\r\n                if (legacyWatchStub instanceof WriteFile) {\r\n                    return Optional.of((WriteFile) legacyWatchStub);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "com.facebook.buck.android.apkmodule.APKModuleGraph.getAPKModuleToClassesMap",
	"Comment": "group the classes in the input jars into a multimap based on the apkmodule they belong to",
	"Method": "ImmutableMultimap<APKModule, String> getAPKModuleToClassesMap(ImmutableMultimap<APKModule, Path> apkModuleToJarPathMap,Function<String, String> translatorFunction,ProjectFilesystem filesystem){\r\n    ImmutableMultimap.Builder<APKModule, String> builder = ImmutableSetMultimap.builder();\r\n    if (!apkModuleToJarPathMap.isEmpty()) {\r\n        for (APKModule dexStore : apkModuleToJarPathMap.keySet()) {\r\n            for (Path jarFilePath : apkModuleToJarPathMap.get(dexStore)) {\r\n                ClasspathTraverser classpathTraverser = new DefaultClasspathTraverser();\r\n                classpathTraverser.traverse(new ClasspathTraversal(ImmutableSet.of(jarFilePath), filesystem) {\r\n                    @Override\r\n                    public void visit(FileLike entry) {\r\n                        if (!entry.getRelativePath().endsWith(\".class\")) {\r\n                            return;\r\n                        }\r\n                        String classpath = entry.getRelativePath().replaceAll(\"\\\\.class$\", \"\");\r\n                        if (translatorFunction.apply(classpath) != null) {\r\n                            builder.put(dexStore, translatorFunction.apply(classpath));\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.facebook.buck.android.apkmodule.APKModuleGraph.getAPKModuleToClassesMap",
	"Comment": "group the classes in the input jars into a multimap based on the apkmodule they belong to",
	"Method": "ImmutableMultimap<APKModule, String> getAPKModuleToClassesMap(ImmutableMultimap<APKModule, Path> apkModuleToJarPathMap,Function<String, String> translatorFunction,ProjectFilesystem filesystem){\r\n    if (!entry.getRelativePath().endsWith(\".class\")) {\r\n        return;\r\n    }\r\n    String classpath = entry.getRelativePath().replaceAll(\"\\\\.class$\", \"\");\r\n    if (translatorFunction.apply(classpath) != null) {\r\n        builder.put(dexStore, translatorFunction.apply(classpath));\r\n    }\r\n}"
}, {
	"Path": "org.antlr.v4.tool.Grammar.getTokenTypes",
	"Comment": "return a set of all possible token or char types for this grammar",
	"Method": "IntSet getTokenTypes(){\r\n    if (isLexer()) {\r\n        return getAllCharValues();\r\n    }\r\n    return IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, getMaxTokenType());\r\n}"
}, {
	"Path": "org.antlr.v4.test.runtime.go.BaseGoTest.groupSetUp",
	"Comment": "copies all files from go runtime to a temporary folder that is inside a valid gopath project structure.",
	"Method": "void groupSetUp(){\r\n    tmpGopath = new File(System.getProperty(\"java.io.tmpdir\"), \"antlr-goruntime-tmpgopath-\" + Long.toHexString(System.currentTimeMillis()));\r\n    ArrayList<String> pathsegments = new ArrayList<String>();\r\n    pathsegments.add(\"src\");\r\n    pathsegments.addAll(Arrays.asList(GO_RUNTIME_IMPORT_PATH.split(\"/\")));\r\n    File tmpPackageDir = tmpGopath;\r\n    for (String pathsegment : pathsegments) {\r\n        tmpPackageDir = new File(tmpPackageDir, pathsegment);\r\n    }\r\n    if (!tmpPackageDir.mkdirs()) {\r\n        throw new Exception(\"Could not create temp go runtime package dirs!\");\r\n    }\r\n    File[] runtimeFiles = locateRuntime().listFiles();\r\n    if (runtimeFiles == null) {\r\n        throw new Exception(\"Go runtime file list is empty.\");\r\n    }\r\n    for (File runtimeFile : runtimeFiles) {\r\n        File dest = new File(tmpPackageDir, runtimeFile.getName());\r\n        copyFile(runtimeFile, dest);\r\n    }\r\n    cacheGoRuntime(tmpPackageDir);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.delegate.invocation.DelegateInvocation.proceed",
	"Comment": "make the invocation proceed, performing the actual invocation of the user code.",
	"Method": "void proceed(){\r\n    invoke();\r\n}"
}, {
	"Path": "com.facebook.buck.android.AndroidNativeLibsPackageableGraphEnhancer.requireStripLinkable",
	"Comment": "so be careful not to let information about this particular app slip into the definitions.",
	"Method": "StripLinkable requireStripLinkable(ProjectFilesystem projectFilesystem,SourcePathRuleFinder ruleFinder,ActionGraphBuilder graphBuilder,SourcePath sourcePath,TargetCpuType targetCpuType,NdkCxxPlatform platform,BuildTarget baseBuildTarget,String sharedLibrarySoName){\r\n    BuildTarget targetForStripRule = baseBuildTarget.withAppendedFlavors(InternalFlavor.of(\"android-strip\"), InternalFlavor.of(Flavor.replaceInvalidCharacters(sharedLibrarySoName)), InternalFlavor.of(Flavor.replaceInvalidCharacters(targetCpuType.name())));\r\n    return (StripLinkable) graphBuilder.computeIfAbsent(targetForStripRule, (buildTarget) -> new StripLinkable(targetForStripRule, projectFilesystem, ImmutableSortedSet.copyOf(ruleFinder.filterBuildRuleInputs(sourcePath)), platform.getCxxPlatform().getStrip(), sourcePath, sharedLibrarySoName));\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.GLTextureView.surfaceChanged",
	"Comment": "this method is part of the surfaceholder.callback interface, and isnot normally called or subclassed by clients of gltextureview.",
	"Method": "void surfaceChanged(SurfaceTexture texture,int format,int w,int h){\r\n    glThread.onWindowResize(w, h);\r\n}"
}, {
	"Path": "com.taobao.arthas.core.util.IOUtils.toString",
	"Comment": "get the contents of an inputstream as a stringusing the default character encoding of the platform.this method buffers the input internally, so there is no need to use abufferedinputstream.",
	"Method": "String toString(InputStream input){\r\n    BufferedReader br = null;\r\n    try {\r\n        StringBuilder sb = new StringBuilder();\r\n        br = new BufferedReader(new InputStreamReader(input));\r\n        String line;\r\n        while ((line = br.readLine()) != null) {\r\n            sb.append(line).append(\"\\n\");\r\n        }\r\n        return sb.toString();\r\n    } finally {\r\n        if (br != null) {\r\n            try {\r\n                br.close();\r\n            } catch (IOException e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.auto.value.processor.AnnotationOutput.sourceFormForInitializer",
	"Comment": "returns a string representation of the given annotation value, suitable for inclusion in a javasource file as the initializer of a variable of the appropriate type.",
	"Method": "String sourceFormForInitializer(AnnotationValue annotationValue,ProcessingEnvironment processingEnv,String memberName,Element context){\r\n    SourceFormVisitor visitor = new InitializerSourceFormVisitor(processingEnv, memberName, context);\r\n    StringBuilder sb = new StringBuilder();\r\n    visitor.visit(annotationValue, sb);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.roughike.bottombar.BottomBar.setDefaultTabPosition",
	"Comment": "sets the default tab for this bottombar that is shown until the user changesthe selection.",
	"Method": "void setDefaultTabPosition(int defaultTabPosition){\r\n    if (isComingFromRestoredState)\r\n        return;\r\n    selectTabAtPosition(defaultTabPosition);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.asyncexecutor.ExecuteAsyncRunnable.lockJobIfNeeded",
	"Comment": "returns true if lock succeeded, or no lock was needed.returns false if locking was unsuccessfull.",
	"Method": "boolean lockJobIfNeeded(){\r\n    try {\r\n        if (job.isExclusive()) {\r\n            processEngineConfiguration.getCommandExecutor().execute(new LockExclusiveJobCmd(job));\r\n        }\r\n    } catch (Throwable lockException) {\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Could not lock exclusive job. Unlocking job so it can be acquired again. Catched exception: \" + lockException.getMessage());\r\n        }\r\n        unacquireJob();\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONObject.isNull",
	"Comment": "determine if the value associated with the key is null or if there is no value.",
	"Method": "boolean isNull(String key){\r\n    return JSONObject.NULL.equals(opt(key));\r\n}"
}, {
	"Path": "com.facebook.buck.cli.TestRunning.getPathToSourceFolders",
	"Comment": "returns a set of source folders of the java files of a library.",
	"Method": "ImmutableSet<String> getPathToSourceFolders(JavaLibrary rule,SourcePathResolver sourcePathResolver,SourcePathRuleFinder ruleFinder,DefaultJavaPackageFinder defaultJavaPackageFinder){\r\n    ImmutableSet<SourcePath> javaSrcs = rule.getJavaSrcs();\r\n    if (javaSrcs.isEmpty()) {\r\n        return ImmutableSet.of();\r\n    }\r\n    Set<String> srcFolders = new HashSet();\r\n    loopThroughSourcePath: for (SourcePath javaSrcPath : javaSrcs) {\r\n        if (ruleFinder.getRule(javaSrcPath).isPresent()) {\r\n            continue;\r\n        }\r\n        Path javaSrcRelativePath = sourcePathResolver.getRelativePath(javaSrcPath);\r\n        for (String srcFolder : srcFolders) {\r\n            if (javaSrcRelativePath.startsWith(srcFolder)) {\r\n                continue loopThroughSourcePath;\r\n            }\r\n        }\r\n        ImmutableSortedSet<String> pathsFromRoot = defaultJavaPackageFinder.getPathsFromRoot();\r\n        for (String root : pathsFromRoot) {\r\n            if (javaSrcRelativePath.startsWith(root)) {\r\n                srcFolders.add(root);\r\n                continue loopThroughSourcePath;\r\n            }\r\n        }\r\n        ImmutableSet<String> pathElements = defaultJavaPackageFinder.getPathElements();\r\n        Path directory = sourcePathResolver.getAbsolutePath(javaSrcPath).getParent();\r\n        if (pathElements.isEmpty()) {\r\n            continue;\r\n        }\r\n        while (directory != null && directory.getFileName() != null && !pathElements.contains(directory.getFileName().toString())) {\r\n            directory = directory.getParent();\r\n        }\r\n        if (directory == null || directory.getFileName() == null) {\r\n            continue;\r\n        }\r\n        String directoryPath = directory.toString();\r\n        if (!directoryPath.endsWith(\"/\")) {\r\n            directoryPath += \"/\";\r\n        }\r\n        srcFolders.add(directoryPath);\r\n    }\r\n    return ImmutableSet.copyOf(srcFolders);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.listener.DelegateExpressionCustomPropertiesResolver.getExpressionText",
	"Comment": "returns the expression text for this execution listener. comes in handy if you want to check which listeners you already have.",
	"Method": "String getExpressionText(){\r\n    return expression.getExpressionText();\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.runtime.ProcessInstanceQueryTest.testQueryBySuperProcessInstanceIdNested",
	"Comment": "nested subprocess make the query complexer, hence this test",
	"Method": "void testQueryBySuperProcessInstanceIdNested(){\r\n    ProcessInstance superProcessInstance = runtimeService.startProcessInstanceByKey(\"nestedSubProcessQueryTest\");\r\n    ProcessInstance subProcessInstance = runtimeService.createProcessInstanceQuery().superProcessInstanceId(superProcessInstance.getId()).singleResult();\r\n    assertNotNull(subProcessInstance);\r\n    ProcessInstance nestedSubProcessInstance = runtimeService.createProcessInstanceQuery().superProcessInstanceId(subProcessInstance.getId()).singleResult();\r\n    assertNotNull(nestedSubProcessInstance);\r\n}"
}, {
	"Path": "com.facebook.buck.android.toolchain.impl.AndroidBuildToolsResolver.getBuildToolsVersion",
	"Comment": "returns android sdk build tools version that was either discovered or provided during creation.",
	"Method": "Optional<String> getBuildToolsVersion(){\r\n    return discoveredBuildToolsVersion.isPresent() ? discoveredBuildToolsVersion : targetBuildToolsVersion;\r\n}"
}, {
	"Path": "com.google.auto.value.processor.AutoAnnotationProcessor.abortWithError",
	"Comment": "issue a compilation error and return an exception that, when thrown, will cause the processingof this class to be abandoned. this does not prevent the processing of other classes.",
	"Method": "AbortProcessingException abortWithError(String msg,Element e){\r\n    reportError(e, msg);\r\n    return new AbortProcessingException();\r\n}"
}, {
	"Path": "com.facebook.buck.cli.Main.resetDaemon",
	"Comment": "used to clean up the daemon after running integration tests that exercise it.",
	"Method": "void resetDaemon(){\r\n    daemonLifecycleManager.resetDaemon();\r\n}"
}, {
	"Path": "org.antlr.v4.semantics.UseDefAnalyzer.getRuleDependencies",
	"Comment": "find all rules reachable from r directly or indirectly for all r in g",
	"Method": "Map<Rule, Set<Rule>> getRuleDependencies(Grammar g,Map<Rule, Set<Rule>> getRuleDependencies,LexerGrammar g,String modeName,Map<Rule, Set<Rule>> getRuleDependencies,Grammar g,Collection<Rule> rules){\r\n    Map<Rule, Set<Rule>> dependencies = new HashMap<Rule, Set<Rule>>();\r\n    for (Rule r : rules) {\r\n        List<GrammarAST> tokenRefs = r.ast.getNodesWithType(ANTLRParser.TOKEN_REF);\r\n        for (GrammarAST tref : tokenRefs) {\r\n            Set<Rule> calls = dependencies.get(r);\r\n            if (calls == null) {\r\n                calls = new HashSet<Rule>();\r\n                dependencies.put(r, calls);\r\n            }\r\n            calls.add(g.getRule(tref.getText()));\r\n        }\r\n    }\r\n    return dependencies;\r\n}"
}, {
	"Path": "org.activiti.spring.integration.Activiti.inboundGatewayActivityBehavior",
	"Comment": "this is the bean to expose and then referencefrom your activiti bpmn flow in an expression.",
	"Method": "IntegrationActivityBehavior inboundGatewayActivityBehavior(ActivitiInboundGateway gateway){\r\n    return new IntegrationActivityBehavior(gateway);\r\n}"
}, {
	"Path": "org.activiti.spring.boot.process.ProcessRuntimeEmptyConnectorDefinitionTest.connectorDefinitionEmptyDir",
	"Comment": "this test points to a directory having no connectors definitions.as resulting behaviour, we have the same when there is no match with connector definitions.",
	"Method": "void connectorDefinitionEmptyDir(){\r\n    securityUtil.logInAs(\"salaboy\");\r\n    processRuntime.start(ProcessPayloadBuilder.start().withProcessDefinitionKey(CATEGORIZE_PROCESS).withVariable(\"expectedKey\", true).build());\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.atn.LexerModeAction.getMode",
	"Comment": "get the lexer mode this action should transition the lexer to.",
	"Method": "int getMode(){\r\n    return mode;\r\n}"
}, {
	"Path": "com.facebook.buck.android.bundle.GetAbiByName.getAbi",
	"Comment": "this method takes the path name as input and returns corresponding abi number, if there is any.",
	"Method": "int getAbi(String abiName){\r\n    return ABI_BY_NAME.getOrDefault(abiName.toUpperCase(), -1);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.helper.ScopeUtil.createCopyOfSubProcessExecutionForCompensation",
	"Comment": "creates a new event scope execution and moves existing event subscriptions to this new execution",
	"Method": "void createCopyOfSubProcessExecutionForCompensation(ExecutionEntity subProcessExecution){\r\n    EventSubscriptionEntityManager eventSubscriptionEntityManager = Context.getCommandContext().getEventSubscriptionEntityManager();\r\n    List<EventSubscriptionEntity> eventSubscriptions = eventSubscriptionEntityManager.findEventSubscriptionsByExecutionAndType(subProcessExecution.getId(), \"compensate\");\r\n    List<CompensateEventSubscriptionEntity> compensateEventSubscriptions = new ArrayList<CompensateEventSubscriptionEntity>();\r\n    for (EventSubscriptionEntity event : eventSubscriptions) {\r\n        if (event instanceof CompensateEventSubscriptionEntity) {\r\n            compensateEventSubscriptions.add((CompensateEventSubscriptionEntity) event);\r\n        }\r\n    }\r\n    if (CollectionUtil.isNotEmpty(compensateEventSubscriptions)) {\r\n        ExecutionEntity processInstanceExecutionEntity = subProcessExecution.getProcessInstance();\r\n        ExecutionEntity eventScopeExecution = Context.getCommandContext().getExecutionEntityManager().createChildExecution(processInstanceExecutionEntity);\r\n        eventScopeExecution.setActive(false);\r\n        eventScopeExecution.setEventScope(true);\r\n        eventScopeExecution.setCurrentFlowElement(subProcessExecution.getCurrentFlowElement());\r\n        new SubProcessVariableSnapshotter().setVariablesSnapshots(subProcessExecution, eventScopeExecution);\r\n        for (CompensateEventSubscriptionEntity eventSubscriptionEntity : compensateEventSubscriptions) {\r\n            eventSubscriptionEntityManager.delete(eventSubscriptionEntity);\r\n            CompensateEventSubscriptionEntity newSubscription = eventSubscriptionEntityManager.insertCompensationEvent(eventScopeExecution, eventSubscriptionEntity.getActivityId());\r\n            newSubscription.setConfiguration(eventSubscriptionEntity.getConfiguration());\r\n            newSubscription.setCreated(eventSubscriptionEntity.getCreated());\r\n        }\r\n        CompensateEventSubscriptionEntity eventSubscription = eventSubscriptionEntityManager.insertCompensationEvent(processInstanceExecutionEntity, eventScopeExecution.getCurrentFlowElement().getId());\r\n        eventSubscription.setConfiguration(eventScopeExecution.getId());\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.cli.BuckQueryEnvironment.evaluateQuery",
	"Comment": "evaluate the specified query expression in this environment.",
	"Method": "ImmutableSet<QueryTarget> evaluateQuery(QueryExpression expr,ImmutableSet<QueryTarget> evaluateQuery,String query){\r\n    return evaluateQuery(QueryExpression.parse(query, this));\r\n}"
}, {
	"Path": "com.facebook.buck.android.AndroidBuckConfig.getAaptOverride",
	"Comment": "returns the path to the platform specific aapt executable that is overridden by the currentproject. if not specified, the android platform aapt will be used.",
	"Method": "Optional<Supplier<Tool>> getAaptOverride(){\r\n    return getToolOverride(\"aapt\");\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.event.VariableEventsTest.testTaskVariableStandalone",
	"Comment": "test to check create, update an delete behavior for variables on a task not related to a process.",
	"Method": "void testTaskVariableStandalone(){\r\n    Task newTask = taskService.newTask();\r\n    try {\r\n        taskService.saveTask(newTask);\r\n        taskService.setVariable(newTask.getId(), \"testVariable\", 123);\r\n        taskService.setVariable(newTask.getId(), \"testVariable\", 456);\r\n        taskService.removeVariable(newTask.getId(), \"testVariable\");\r\n        assertEquals(3, listener.getEventsReceived().size());\r\n        ActivitiVariableEvent event = (ActivitiVariableEvent) listener.getEventsReceived().get(0);\r\n        assertEquals(ActivitiEventType.VARIABLE_CREATED, event.getType());\r\n        assertNull(event.getProcessDefinitionId());\r\n        assertNull(event.getExecutionId());\r\n        assertNull(event.getProcessInstanceId());\r\n        assertEquals(newTask.getId(), event.getTaskId());\r\n        assertEquals(\"testVariable\", event.getVariableName());\r\n        assertEquals(123, event.getVariableValue());\r\n        event = (ActivitiVariableEvent) listener.getEventsReceived().get(1);\r\n        assertEquals(ActivitiEventType.VARIABLE_UPDATED, event.getType());\r\n        assertNull(event.getProcessDefinitionId());\r\n        assertNull(event.getExecutionId());\r\n        assertNull(event.getProcessInstanceId());\r\n        assertEquals(newTask.getId(), event.getTaskId());\r\n        assertEquals(\"testVariable\", event.getVariableName());\r\n        assertEquals(456, event.getVariableValue());\r\n        event = (ActivitiVariableEvent) listener.getEventsReceived().get(2);\r\n        assertEquals(ActivitiEventType.VARIABLE_DELETED, event.getType());\r\n        assertNull(event.getProcessDefinitionId());\r\n        assertNull(event.getExecutionId());\r\n        assertNull(event.getProcessInstanceId());\r\n        assertEquals(newTask.getId(), event.getTaskId());\r\n        assertEquals(\"testVariable\", event.getVariableName());\r\n        assertEquals(null, event.getVariableValue());\r\n    } finally {\r\n        if (newTask.getId() != null) {\r\n            taskService.deleteTask(newTask.getId());\r\n            if (processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.ACTIVITY)) {\r\n                historyService.deleteHistoricTaskInstance(newTask.getId());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.auto.value.processor.TypeSimplifier.actualTypeParametersString",
	"Comment": "is the actual type parameter list, which is what this method returns.",
	"Method": "String actualTypeParametersString(TypeElement type){\r\n    List<? extends TypeParameterElement> typeParameters = type.getTypeParameters();\r\n    if (typeParameters.isEmpty()) {\r\n        return \"\";\r\n    } else {\r\n        return typeParameters.stream().map(e -> e.getSimpleName().toString()).collect(joining(\", \", \"<\", \">\"));\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.cmd.NeedsActiveExecutionCmd.getSuspendedExceptionMessage",
	"Comment": "subclasses can override this to provide a more detailed exception message that will be thrown when the execution is suspended.",
	"Method": "String getSuspendedExceptionMessage(){\r\n    return \"Cannot execution operation because execution '\" + executionId + \"' is suspended\";\r\n}"
}, {
	"Path": "org.activiti.engine.test.mock.Mocks.get",
	"Comment": "this method returns the mock object registered under the provided key or null if there is no object for the provided key.",
	"Method": "Object get(Object key){\r\n    return getMocks().get(key);\r\n}"
}, {
	"Path": "com.facebook.buck.apple.ApplePackageDescription.getApplePackageConfig",
	"Comment": "get the correct package configuration based on the platform flavors of this build target.validates that all named platforms yields the identical package config.",
	"Method": "Optional<ApplePackageConfigAndPlatformInfo> getApplePackageConfig(BuildTarget target,Function<String, Arg> macroExpander){\r\n    FlavorDomain<AppleCxxPlatform> appleCxxPlatformFlavorDomain = getAppleCxxPlatformFlavorDomain();\r\n    Set<Flavor> platformFlavors = getPlatformFlavorsOrDefault(target, appleCxxPlatformFlavorDomain);\r\n    Multimap<Optional<ApplePackageConfigAndPlatformInfo>, Flavor> packageConfigs = MultimapBuilder.hashKeys().arrayListValues().build();\r\n    for (Flavor flavor : platformFlavors) {\r\n        AppleCxxPlatform platform = appleCxxPlatformFlavorDomain.getValue(flavor);\r\n        Optional<ApplePackageConfig> packageConfig = config.getPackageConfigForPlatform(platform.getAppleSdk().getApplePlatform());\r\n        packageConfigs.put(packageConfig.isPresent() ? Optional.of(ApplePackageConfigAndPlatformInfo.of(packageConfig.get(), macroExpander, platform)) : Optional.empty(), flavor);\r\n    }\r\n    if (packageConfigs.isEmpty()) {\r\n        return Optional.empty();\r\n    } else if (packageConfigs.keySet().size() == 1) {\r\n        return Iterables.getOnlyElement(packageConfigs.keySet());\r\n    } else {\r\n        throw new HumanReadableException(\"In target %s: Multi-architecture package has different package configs for targets: %s\", target.getFullyQualifiedName(), packageConfigs.asMap().values());\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.event.logger.EventLogger.createEventFlusher",
	"Comment": "subclasses that want something else than the database flusher should override this method",
	"Method": "EventFlusher createEventFlusher(){\r\n    return null;\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.tree.pattern.ParseTreePattern.getPatternRuleIndex",
	"Comment": "get the parser rule which serves as the outermost rule for the tree\tpattern.",
	"Method": "int getPatternRuleIndex(){\r\n    return patternRuleIndex;\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.event.SignalThrowingEventListenerTest.testThrowSignalInNewTransaction",
	"Comment": "test signal throwing when a job failed and the retries are decremented, affectively starting a new transaction.",
	"Method": "void testThrowSignalInNewTransaction(){\r\n    SignalThrowingEventListener listener = null;\r\n    try {\r\n        listener = new SignalThrowingEventListener();\r\n        listener.setSignalName(\"Signal\");\r\n        listener.setProcessInstanceScope(true);\r\n        processEngineConfiguration.getEventDispatcher().addEventListener(listener, ActivitiEventType.JOB_RETRIES_DECREMENTED);\r\n        ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(\"testSignal\");\r\n        assertNotNull(processInstance);\r\n        Job signalJob = managementService.createJobQuery().processInstanceId(processInstance.getId()).singleResult();\r\n        try {\r\n            managementService.executeJob(signalJob.getId());\r\n            fail(\"Exception expected\");\r\n        } catch (ActivitiException ae) {\r\n        }\r\n        Job failedJob = managementService.createTimerJobQuery().withException().processInstanceId(processInstance.getId()).singleResult();\r\n        assertNotNull(failedJob);\r\n        assertEquals(2, failedJob.getRetries());\r\n        assertEquals(1, taskService.createTaskQuery().processInstanceId(processInstance.getId()).count());\r\n        try {\r\n            managementService.moveTimerToExecutableJob(failedJob.getId());\r\n            managementService.executeJob(failedJob.getId());\r\n            fail(\"Exception expected\");\r\n        } catch (ActivitiException ae) {\r\n            assertEquals(2, taskService.createTaskQuery().processInstanceId(processInstance.getId()).count());\r\n        }\r\n    } finally {\r\n        processEngineConfiguration.getEventDispatcher().removeEventListener(listener);\r\n    }\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetInputStream.__processChar",
	"Comment": "tries to write. returns true if buffer was previously empty.",
	"Method": "boolean __processChar(int ch){\r\n    boolean bufferWasEmpty;\r\n    synchronized (__queue) {\r\n        bufferWasEmpty = (__bytesAvailable == 0);\r\n        while (__bytesAvailable >= __queue.length - 1) {\r\n            if (__threaded) {\r\n                __queue.notify();\r\n                try {\r\n                    __queue.wait();\r\n                } catch (InterruptedException e) {\r\n                    throw e;\r\n                }\r\n            } else {\r\n                throw new IllegalStateException(\"Queue is full! Cannot process another character.\");\r\n            }\r\n        }\r\n        if (__readIsWaiting && __threaded) {\r\n            __queue.notify();\r\n        }\r\n        __queue[__queueTail] = ch;\r\n        ++__bytesAvailable;\r\n        if (++__queueTail >= __queue.length) {\r\n            __queueTail = 0;\r\n        }\r\n    }\r\n    return bufferWasEmpty;\r\n}"
}, {
	"Path": "com.facebook.buck.android.support.exopackage.SystemClassLoaderAdder.installDexJars",
	"Comment": "installs a list of .dex.jar files into the application class loader.",
	"Method": "void installDexJars(ClassLoader appClassLoader,File optimizedDirectory,List<File> dexJars){\r\n    SystemClassLoaderAdder classLoaderAdder = new SystemClassLoaderAdder();\r\n    for (File dexJar : dexJars) {\r\n        DexClassLoader newClassLoader = new DexClassLoader(dexJar.getAbsolutePath(), optimizedDirectory.getAbsolutePath(), null, appClassLoader);\r\n        classLoaderAdder.addPathsOfClassLoaderToSystemClassLoader(newClassLoader, (PathClassLoader) appClassLoader);\r\n    }\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.BootstrapProgressBarGroup.onProgressChanged",
	"Comment": "this should be called by all children to notify the bootstrapprogressbargroup that there progress has changed",
	"Method": "void onProgressChanged(BootstrapProgressBar bootstrapProgressBar){\r\n    updateBootstrapGroup();\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONObject.names",
	"Comment": "produce a jsonarray containing the names of the elements of this jsonobject.",
	"Method": "JSONArray names(){\r\n    JSONArray ja = new JSONArray();\r\n    Iterator keys = keys();\r\n    while (keys.hasNext()) {\r\n        ja.put(keys.next());\r\n    }\r\n    return ja.length() == 0 ? null : ja;\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.Telnet._sendCommand",
	"Comment": "sends a command, automatically adds iac prefix and flushes the output.",
	"Method": "void _sendCommand(byte cmd){\r\n    _output_.write(TelnetCommand.IAC);\r\n    _output_.write(cmd);\r\n    _output_.flush();\r\n}"
}, {
	"Path": "org.antlr.mojo.antlr4.GrammarDependencies.findUsages",
	"Comment": "returns the grammar file names that directly or indirectly use the given grammar.",
	"Method": "Collection<String> findUsages(String grammarFileName){\r\n    Collection<String> result = new ArrayList<String>();\r\n    explore(grammarFileName, result);\r\n    return result;\r\n}"
}, {
	"Path": "com.facebook.buck.android.support.exopackage.ExoHelper.restartApp",
	"Comment": "restart the application by setting a pendingintent on the alarmmanager and then killing thecurrent process.",
	"Method": "void restartApp(Context context){\r\n    Context appContext = context.getApplicationContext();\r\n    final Intent launchIntent = appContext.getPackageManager().getLaunchIntentForPackage(appContext.getPackageName()).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\r\n    int id = 0xe354735f;\r\n    final int flags = PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_ONE_SHOT;\r\n    PendingIntent pendingIntent = PendingIntent.getActivity(appContext, id, launchIntent, flags);\r\n    AlarmManager am = appContext.getSystemService(AlarmManager.class);\r\n    long deadline = System.currentTimeMillis() + 500L;\r\n    am.setExact(AlarmManager.RTC_WAKEUP, deadline, pendingIntent);\r\n    Process.killProcess(Process.myPid());\r\n}"
}, {
	"Path": "org.antlr.v4.tool.Grammar.getStateToGrammarRegion",
	"Comment": "given an atn state number, return the token index range within the grammar from which that atn state was derived.",
	"Method": "Interval getStateToGrammarRegion(int atnStateNumber){\r\n    if (stateToGrammarRegionMap == null) {\r\n        stateToGrammarRegionMap = getStateToGrammarRegionMap(ast, null);\r\n    }\r\n    if (stateToGrammarRegionMap == null)\r\n        return Interval.INVALID;\r\n    return stateToGrammarRegionMap.get(atnStateNumber);\r\n}"
}, {
	"Path": "org.activiti.engine.ActivitiWrongDbException.getDbVersion",
	"Comment": "the version of the activiti library that was used to create the database schema.",
	"Method": "String getDbVersion(){\r\n    return dbVersion;\r\n}"
}, {
	"Path": "com.facebook.buck.apple.MultiarchFileInfos.getMultiarchOutputFormatString",
	"Comment": "generate the format string for the fat rule output. if all the thin rules have the same outputfile name, use this as the file name for the fat rule output. otherwise, default to simplestring substitution.",
	"Method": "String getMultiarchOutputFormatString(SourcePathResolver pathResolver,ImmutableSortedSet<SourcePath> inputs){\r\n    if (inputs.isEmpty()) {\r\n        return BASE_OUTPUT_FORMAT_STRING;\r\n    }\r\n    String outputFileName = pathResolver.getAbsolutePath(inputs.first()).getFileName().toString();\r\n    for (SourcePath input : inputs) {\r\n        String inputFileName = pathResolver.getAbsolutePath(input).getFileName().toString();\r\n        if (!outputFileName.equals(inputFileName)) {\r\n            return BASE_OUTPUT_FORMAT_STRING;\r\n        }\r\n    }\r\n    return NESTED_OUTPUT_FORMAT_STRING + outputFileName;\r\n}"
}, {
	"Path": "org.asynchttpclient.extras.rxjava.AsyncHttpObservable.observe",
	"Comment": "observe a request execution and emit the response to the observer.",
	"Method": "Observable<Response> observe(Func0<BoundRequestBuilder> supplier){\r\n    ReplaySubject<Response> subject = ReplaySubject.create();\r\n    toObservable(supplier).subscribe(subject);\r\n    return subject;\r\n}"
}, {
	"Path": "com.facebook.buck.artifact_cache.config.ArtifactCacheBuckConfig.getDownloadHeavyBuildHttpCacheFetchThreads",
	"Comment": "number of cache fetch threads to be used by download heavy builds, such as the synchronizedbuild phase of stampede, which almost entirely consists of cache fetches.",
	"Method": "int getDownloadHeavyBuildHttpCacheFetchThreads(){\r\n    return buckConfig.getInteger(CACHE_SECTION_NAME, DOWNLOAD_HEAVY_BUILD_CACHE_FETCH_THREADS).orElse(DEFAULT_DOWNLOAD_HEAVY_BUILD_CACHE_FETCH_THREADS);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.XML.parse",
	"Comment": "scan the content following the named tag, attaching it to the context.",
	"Method": "boolean parse(XMLTokener x,JSONObject context,String name){\r\n    char c;\r\n    int i;\r\n    String n;\r\n    JSONObject o = null;\r\n    String s;\r\n    Object t;\r\n    t = x.nextToken();\r\n    if (t == BANG) {\r\n        c = x.next();\r\n        if (c == '-') {\r\n            if (x.next() == '-') {\r\n                x.skipPast(\"-->\");\r\n                return false;\r\n            }\r\n            x.back();\r\n        } else if (c == '[') {\r\n            t = x.nextToken();\r\n            if (t.equals(\"CDATA\")) {\r\n                if (x.next() == '[') {\r\n                    s = x.nextCDATA();\r\n                    if (s.length() > 0) {\r\n                        context.accumulate(\"content\", s);\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n            throw x.syntaxError(\"Expected 'CDATA['\");\r\n        }\r\n        i = 1;\r\n        do {\r\n            t = x.nextMeta();\r\n            if (t == null) {\r\n                throw x.syntaxError(\"Missing '>' after '<!'.\");\r\n            } else if (t == LT) {\r\n                i += 1;\r\n            } else if (t == GT) {\r\n                i -= 1;\r\n            }\r\n        } while (i > 0);\r\n        return false;\r\n    } else if (t == QUEST) {\r\n        x.skipPast(\"?>\");\r\n        return false;\r\n    } else if (t == SLASH) {\r\n        t = x.nextToken();\r\n        if (name == null) {\r\n            throw x.syntaxError(\"Mismatched close tag\" + t);\r\n        }\r\n        if (!t.equals(name)) {\r\n            throw x.syntaxError(\"Mismatched \" + name + \" and \" + t);\r\n        }\r\n        if (x.nextToken() != GT) {\r\n            throw x.syntaxError(\"Misshaped close tag\");\r\n        }\r\n        return true;\r\n    } else if (t instanceof Character) {\r\n        throw x.syntaxError(\"Misshaped tag\");\r\n    } else {\r\n        n = (String) t;\r\n        t = null;\r\n        o = new JSONObject();\r\n        for (; ; ) {\r\n            if (t == null) {\r\n                t = x.nextToken();\r\n            }\r\n            if (t instanceof String) {\r\n                s = (String) t;\r\n                t = x.nextToken();\r\n                if (t == EQ) {\r\n                    t = x.nextToken();\r\n                    if (!(t instanceof String)) {\r\n                        throw x.syntaxError(\"Missing value\");\r\n                    }\r\n                    o.accumulate(s, JSONObject.stringToValue((String) t));\r\n                    t = null;\r\n                } else {\r\n                    o.accumulate(s, \"\");\r\n                }\r\n            } else if (t == SLASH) {\r\n                if (x.nextToken() != GT) {\r\n                    throw x.syntaxError(\"Misshaped tag\");\r\n                }\r\n                context.accumulate(n, \"\");\r\n                return false;\r\n            } else if (t == GT) {\r\n                for (; ; ) {\r\n                    t = x.nextContent();\r\n                    if (t == null) {\r\n                        if (n != null) {\r\n                            throw x.syntaxError(\"Unclosed tag \" + n);\r\n                        }\r\n                        return false;\r\n                    } else if (t instanceof String) {\r\n                        s = (String) t;\r\n                        if (s.length() > 0) {\r\n                            o.accumulate(\"content\", JSONObject.stringToValue(s));\r\n                        }\r\n                    } else if (t == LT) {\r\n                        if (parse(x, o, n)) {\r\n                            if (o.length() == 0) {\r\n                                context.accumulate(n, \"\");\r\n                            } else if (o.length() == 1 && o.opt(\"content\") != null) {\r\n                                context.accumulate(n, o.opt(\"content\"));\r\n                            } else {\r\n                                context.accumulate(n, o);\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                throw x.syntaxError(\"Misshaped tag\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.android.support.exopackage.DelegatingClassLoader.resetDelegate",
	"Comment": "clear the existing delegate and return the new one, populated with the given dex files",
	"Method": "void resetDelegate(List<File> dexJars){\r\n    mDelegate = new PathClassLoader(\"\", \"\", this);\r\n    mManagedClassesToDexFile.clear();\r\n    for (File dexJar : dexJars) {\r\n        try {\r\n            final File optFile = new File(mDexOptDir, dexJar.getName());\r\n            DexFile dexFile = DexFile.loadDex(dexJar.getCanonicalPath(), optFile.getCanonicalPath(), 0);\r\n            final Enumeration<String> entries = dexFile.entries();\r\n            while (entries.hasMoreElements()) {\r\n                mManagedClassesToDexFile.put(entries.nextElement(), dexFile);\r\n            }\r\n        } catch (IOException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.core.config.BuckConfig.useBuckBinaryHash",
	"Comment": "whether buck should use buck binary hash or git commit id as the core key in all rule keys.the binary hash reflects the code that can affect the content of artifacts.by default git commit id is used as the core key.",
	"Method": "boolean useBuckBinaryHash(){\r\n    return getBooleanValue(\"cache\", \"use_buck_binary_hash\", false);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.CDL.rowToJSONObject",
	"Comment": "produce a jsonobject from a row of comma delimited text, using a parallel jsonarray of strings to provides the names of the elements.",
	"Method": "JSONObject rowToJSONObject(JSONArray names,JSONTokener x){\r\n    JSONArray ja = rowToJSONArray(x);\r\n    return ja != null ? ja.toJSONObject(names) : null;\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.filter.GPUImageChromaKeyBlendFilter.setSmoothing",
	"Comment": "the degree of smoothing controls how gradually similar colors are replaced in the imagethe default value is 0.1",
	"Method": "void setSmoothing(float smoothing){\r\n    this.smoothing = smoothing;\r\n    setFloat(smoothingLocation, this.smoothing);\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.GPUImage.getBitmapForMultipleFilters",
	"Comment": "gets the images for multiple filters on a image. this can be used toquickly get thumbnail images for filters. whenever a new bitmap is ready, the listener will be called with thebitmap. the order of the calls to the listener will be the same as thefilter order.",
	"Method": "void getBitmapForMultipleFilters(Bitmap bitmap,List<GPUImageFilter> filters,ResponseListener<Bitmap> listener){\r\n    if (filters.isEmpty()) {\r\n        return;\r\n    }\r\n    GPUImageRenderer renderer = new GPUImageRenderer(filters.get(0));\r\n    renderer.setImageBitmap(bitmap, false);\r\n    PixelBuffer buffer = new PixelBuffer(bitmap.getWidth(), bitmap.getHeight());\r\n    buffer.setRenderer(renderer);\r\n    for (GPUImageFilter filter : filters) {\r\n        renderer.setFilter(filter);\r\n        listener.response(buffer.getBitmap());\r\n        filter.destroy();\r\n    }\r\n    renderer.deleteImage();\r\n    buffer.destroy();\r\n}"
}, {
	"Path": "org.apache.commons.net.ProtocolCommandEvent.isCommand",
	"Comment": "returns true if the protocolcommandevent was generated as a resultof sending a command.",
	"Method": "boolean isCommand(){\r\n    return __isCommand;\r\n}"
}, {
	"Path": "com.facebook.buck.cli.OwnersReport.getNonFileInputs",
	"Comment": "get inputs to a build rule that do not appear to be regular files",
	"Method": "ImmutableSet<String> getNonFileInputs(){\r\n    return nonFileInputs;\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.tree.pattern.ParseTreePattern.matches",
	"Comment": "determine whether or not a parse tree matches this tree pattern.",
	"Method": "boolean matches(ParseTree tree){\r\n    return matcher.match(tree, this).succeeded();\r\n}"
}, {
	"Path": "org.activiti.engine.impl.test.AbstractTestCase.assertTextPresentIgnoreCase",
	"Comment": "asserts if the provided text is part of some text, ignoring any uppercase characters",
	"Method": "void assertTextPresentIgnoreCase(String expected,String actual){\r\n    assertTextPresent(expected.toLowerCase(), actual.toLowerCase());\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONArray.put",
	"Comment": "put or replace an object value in the jsonarray. if the index is greater than the length of the jsonarray, then null elements will be added as necessary to pad it out.",
	"Method": "JSONArray put(boolean value,JSONArray put,Collection value,JSONArray put,double value,JSONArray put,int value,JSONArray put,long value,JSONArray put,Map value,JSONArray put,Object value,JSONArray put,int index,boolean value,JSONArray put,int index,Collection value,JSONArray put,int index,double value,JSONArray put,int index,int value,JSONArray put,int index,long value,JSONArray put,int index,Map value,JSONArray put,int index,Object value){\r\n    JSONObject.testValidity(value);\r\n    if (index < 0) {\r\n        throw new JSONException(\"JSONArray[\" + index + \"] not found.\");\r\n    }\r\n    if (index < length()) {\r\n        this.myArrayList.set(index, value);\r\n    } else {\r\n        while (index != length()) {\r\n            put(JSONObject.NULL);\r\n        }\r\n        put(value);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.BootstrapDrawableFactory.bootstrapLabel",
	"Comment": "generates a drawable for a bootstrap label background, according to state parameters",
	"Method": "Drawable bootstrapLabel(Context context,BootstrapBrand bootstrapBrand,boolean rounded,float height){\r\n    int cornerRadius = (int) DimenUtils.pixelsFromDpResource(context, R.dimen.bootstrap_default_corner_radius);\r\n    GradientDrawable drawable = new GradientDrawable();\r\n    drawable.setColor(bootstrapBrand.defaultFill(context));\r\n    drawable.setCornerRadius(rounded ? height / 2 : cornerRadius);\r\n    return drawable;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.helper.ScopeUtil.throwCompensationEvent",
	"Comment": "we create a separate execution for each compensation handler invocation.",
	"Method": "void throwCompensationEvent(List<CompensateEventSubscriptionEntity> eventSubscriptions,DelegateExecution execution,boolean async){\r\n    ExecutionEntityManager executionEntityManager = Context.getCommandContext().getExecutionEntityManager();\r\n    for (EventSubscriptionEntity eventSubscription : eventSubscriptions) {\r\n        ExecutionEntity compensatingExecution = null;\r\n        if (eventSubscription.getConfiguration() != null) {\r\n            compensatingExecution = executionEntityManager.findById(eventSubscription.getConfiguration());\r\n            compensatingExecution.setParent(compensatingExecution.getProcessInstance());\r\n            compensatingExecution.setEventScope(false);\r\n        } else {\r\n            compensatingExecution = executionEntityManager.createChildExecution((ExecutionEntity) execution);\r\n            eventSubscription.setConfiguration(compensatingExecution.getId());\r\n        }\r\n    }\r\n    Collections.sort(eventSubscriptions, new Comparator<EventSubscriptionEntity>() {\r\n        public int compare(EventSubscriptionEntity o1, EventSubscriptionEntity o2) {\r\n            return o2.getCreated().compareTo(o1.getCreated());\r\n        }\r\n    });\r\n    for (CompensateEventSubscriptionEntity compensateEventSubscriptionEntity : eventSubscriptions) {\r\n        Context.getCommandContext().getEventSubscriptionEntityManager().eventReceived(compensateEventSubscriptionEntity, null, async);\r\n    }\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.helper.ScopeUtil.throwCompensationEvent",
	"Comment": "we create a separate execution for each compensation handler invocation.",
	"Method": "void throwCompensationEvent(List<CompensateEventSubscriptionEntity> eventSubscriptions,DelegateExecution execution,boolean async){\r\n    return o2.getCreated().compareTo(o1.getCreated());\r\n}"
}, {
	"Path": "org.activiti.engine.test.api.event.TaskEventsTest.testDeleteEventDoesNotDispathComplete",
	"Comment": "check events related to process instance delete and standalone task delete.",
	"Method": "void testDeleteEventDoesNotDispathComplete(){\r\n    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(\"oneTaskProcess\");\r\n    assertNotNull(processInstance);\r\n    listener.clearEventsReceived();\r\n    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();\r\n    assertNotNull(task);\r\n    runtimeService.deleteProcessInstance(processInstance.getId(), \"testing task delete events\");\r\n    assertEquals(1, listener.getEventsReceived().size());\r\n    ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);\r\n    assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());\r\n    assertTrue(event.getEntity() instanceof Task);\r\n    Task taskFromEvent = (Task) event.getEntity();\r\n    assertEquals(task.getId(), taskFromEvent.getId());\r\n    assertExecutionDetails(event, processInstance);\r\n    try {\r\n        task = taskService.newTask();\r\n        task.setCategory(\"123\");\r\n        task.setDescription(\"Description\");\r\n        taskService.saveTask(task);\r\n        listener.clearEventsReceived();\r\n        taskService.deleteTask(task.getId());\r\n        assertEquals(1, listener.getEventsReceived().size());\r\n        event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);\r\n        assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());\r\n        assertTrue(event.getEntity() instanceof Task);\r\n        taskFromEvent = (Task) event.getEntity();\r\n        assertEquals(task.getId(), taskFromEvent.getId());\r\n        assertNull(event.getProcessDefinitionId());\r\n        assertNull(event.getProcessInstanceId());\r\n        assertNull(event.getExecutionId());\r\n    } finally {\r\n        if (task != null) {\r\n            String taskId = task.getId();\r\n            task = taskService.createTaskQuery().taskId(taskId).singleResult();\r\n            if (task != null) {\r\n                taskService.deleteTask(taskId);\r\n            }\r\n            historyService.deleteHistoricTaskInstance(taskId);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.core.config.BuckConfig.getErrorMessageAugmentations",
	"Comment": "list of error message replacements to make things more friendly for humans",
	"Method": "Map<Pattern, String> getErrorMessageAugmentations(){\r\n    return config.getMap(\"ui\", \"error_message_augmentations\").entrySet().stream().collect(ImmutableMap.toImmutableMap(e -> {\r\n        try {\r\n            return Pattern.compile(e.getKey(), Pattern.MULTILINE | Pattern.DOTALL);\r\n        } catch (Exception ex) {\r\n            throw new HumanReadableException(\"Could not parse regular expression %s from buckconfig: %s\", e.getKey(), ex.getMessage());\r\n        }\r\n    }, Entry::getValue));\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetOptionHandler.getInitLocal",
	"Comment": "returns a boolean indicating whether to send a will requestto the other end upon connection.",
	"Method": "boolean getInitLocal(){\r\n    return (initialLocal);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.CDL.getValue",
	"Comment": "get the next value. the value can be wrapped in quotes. the value can be empty.",
	"Method": "String getValue(JSONTokener x){\r\n    char c;\r\n    char q;\r\n    StringBuffer sb;\r\n    do {\r\n        c = x.next();\r\n    } while (c == ' ' || c == '\\t');\r\n    switch(c) {\r\n        case 0:\r\n            return null;\r\n        case '\"':\r\n        case '\\'':\r\n            q = c;\r\n            sb = new StringBuffer();\r\n            for (; ; ) {\r\n                c = x.next();\r\n                if (c == q) {\r\n                    break;\r\n                }\r\n                if (c == 0 || c == '\\n' || c == '\\r') {\r\n                    throw x.syntaxError(\"Missing close quote '\" + q + \"'.\");\r\n                }\r\n                sb.append(c);\r\n            }\r\n            return sb.toString();\r\n        case ',':\r\n            x.back();\r\n            return \"\";\r\n        default:\r\n            x.back();\r\n            return x.nextTo(',');\r\n    }\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.BootstrapProgressBarGroup.addEmptyProgressBar",
	"Comment": "this looks for instances of emptyprogressbar and removes them if they are not at the end and then adds one at the end if its needed.",
	"Method": "void addEmptyProgressBar(){\r\n    int whereIsEmpty = -1;\r\n    for (int i = 0; i < getChildCount(); i++) {\r\n        if (retrieveChild(i) != null && retrieveChild(i).equals(emptyProgressBar)) {\r\n            whereIsEmpty = i;\r\n        }\r\n    }\r\n    if (whereIsEmpty != getChildCount() - 1) {\r\n        if (whereIsEmpty != -1) {\r\n            isEmptyBeingAdded = true;\r\n            removeView(emptyProgressBar);\r\n            isEmptyBeingAdded = false;\r\n        }\r\n        if (!isEmptyBeingAdded) {\r\n            addView(emptyProgressBar);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.android.AndroidBinaryBuildable.getProguardTextFilesPath",
	"Comment": "directory of text files used by proguard. unforunately, this contains both inputs and outputs.",
	"Method": "Path getProguardTextFilesPath(){\r\n    return BuildTargetPaths.getGenPath(getProjectFilesystem(), getBuildTarget(), \"%s/proguard\");\r\n}"
}, {
	"Path": "com.fernandocejas.android10.sample.presentation.presenter.UserListPresenter.initialize",
	"Comment": "initializes the presenter by start retrieving the user list.",
	"Method": "void initialize(){\r\n    this.loadUserList();\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.filter.GPUImageSwirlFilter.setRadius",
	"Comment": "the radius of the distortion, ranging from 0.0 to 1.0, with a default of 0.5.",
	"Method": "void setRadius(float radius){\r\n    this.radius = radius;\r\n    setFloat(radiusLocation, radius);\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.ParserRuleContext.addChild",
	"Comment": "add a token leaf node child and force its parent to be this node.",
	"Method": "RuleContext addChild(RuleContext ruleInvocation,TerminalNode addChild,TerminalNode t,TerminalNode addChild,Token matchedToken){\r\n    TerminalNodeImpl t = new TerminalNodeImpl(matchedToken);\r\n    addAnyChild(t);\r\n    t.setParent(this);\r\n    return t;\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.Recognizer.setInterpreter",
	"Comment": "set the atn interpreter used by the recognizer for prediction.",
	"Method": "void setInterpreter(ATNInterpreter interpreter){\r\n    _interp = interpreter;\r\n}"
}, {
	"Path": "com.facebook.buck.cli.IdleKiller.setIdleKillTask",
	"Comment": "clear any existing kill tasks and set up a new kill task to fire after idle delay.",
	"Method": "void setIdleKillTask(){\r\n    clearIdleKillTask();\r\n    idleKillTask = scheduledExecutorService.schedule(killTask, idleKillDelay.toMillis(), TimeUnit.MILLISECONDS);\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.misc.MurmurHash.hashCode",
	"Comment": "utility function to compute the hash code of an array using the\tmurmurhash algorithm.",
	"Method": "int hashCode(T[] data,int seed){\r\n    int hash = initialize(seed);\r\n    for (T value : data) {\r\n        hash = update(hash, value);\r\n    }\r\n    hash = finish(hash, data.length);\r\n    return hash;\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.Parser.createTerminalNode",
	"Comment": "how to create a token leaf node associated with a parent.\t typically, the terminal node to create is not a function of the parent.",
	"Method": "TerminalNode createTerminalNode(ParserRuleContext parent,Token t){\r\n    return new TerminalNodeImpl(t);\r\n}"
}, {
	"Path": "com.roughike.bottombar.BottomBar.setDefaultTab",
	"Comment": "set the default selected to be the tab with the corresponding tab id.by default, the first tab in the container is the default tab.",
	"Method": "void setDefaultTab(int defaultTabId){\r\n    int defaultTabPosition = findPositionForTabWithId(defaultTabId);\r\n    setDefaultTabPosition(defaultTabPosition);\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.atn.ParseInfo.getDFASize",
	"Comment": "gets the total number of dfa states stored in the dfa cache for a\tparticular decision.",
	"Method": "int getDFASize(int getDFASize,int decision){\r\n    DFA decisionToDFA = atnSimulator.decisionToDFA[decision];\r\n    return decisionToDFA.states.size();\r\n}"
}, {
	"Path": "org.apache.commons.net.DefaultSocketFactory.createSocket",
	"Comment": "creates a socket connected to the given host and port andoriginating from the specified local address and port.",
	"Method": "Socket createSocket(Socket createSocket,String host,int port,Socket createSocket,InetAddress address,int port,Socket createSocket,String host,int port,InetAddress localAddr,int localPort,Socket createSocket,InetAddress address,int port,InetAddress localAddr,int localPort){\r\n    if (connProxy != null) {\r\n        Socket s = new Socket(connProxy);\r\n        s.bind(new InetSocketAddress(localAddr, localPort));\r\n        s.connect(new InetSocketAddress(address, port));\r\n        return s;\r\n    }\r\n    return new Socket(address, port, localAddr, localPort);\r\n}"
}, {
	"Path": "jp.co.cyberagent.android.gpuimage.filter.GPUImageCrosshatchFilter.setCrossHatchSpacing",
	"Comment": "the fractional width of the image to use as the spacing for the crosshatch. the default is 0.03.",
	"Method": "void setCrossHatchSpacing(float crossHatchSpacing){\r\n    float singlePixelSpacing;\r\n    if (getOutputWidth() != 0) {\r\n        singlePixelSpacing = 1.0f / (float) getOutputWidth();\r\n    } else {\r\n        singlePixelSpacing = 1.0f / 2048.0f;\r\n    }\r\n    if (crossHatchSpacing < singlePixelSpacing) {\r\n        this.crossHatchSpacing = singlePixelSpacing;\r\n    } else {\r\n        this.crossHatchSpacing = crossHatchSpacing;\r\n    }\r\n    setFloat(crossHatchSpacingLocation, this.crossHatchSpacing);\r\n}"
}, {
	"Path": "org.antlr.v4.runtime.Recognizer.getTokenTypeMap",
	"Comment": "get a map from token names to token types.\tused for xpath and tree pattern compilation.",
	"Method": "Map<String, Integer> getTokenTypeMap(){\r\n    Vocabulary vocabulary = getVocabulary();\r\n    synchronized (tokenTypeMapCache) {\r\n        Map<String, Integer> result = tokenTypeMapCache.get(vocabulary);\r\n        if (result == null) {\r\n            result = new HashMap<String, Integer>();\r\n            for (int i = 0; i <= getATN().maxTokenType; i++) {\r\n                String literalName = vocabulary.getLiteralName(i);\r\n                if (literalName != null) {\r\n                    result.put(literalName, i);\r\n                }\r\n                String symbolicName = vocabulary.getSymbolicName(i);\r\n                if (symbolicName != null) {\r\n                    result.put(symbolicName, i);\r\n                }\r\n            }\r\n            result.put(\"EOF\", Token.EOF);\r\n            result = Collections.unmodifiableMap(result);\r\n            tokenTypeMapCache.put(vocabulary, result);\r\n        }\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.antlr.v4.misc.Utils.select",
	"Comment": "apply methodname to list and return list of results. method has\t no args.this pulls data out of a list essentially.",
	"Method": "boolean select(T t,List<To> select,List<From> list,Func1<From, To> selector){\r\n    if (list == null)\r\n        return null;\r\n    List<To> b = new ArrayList<To>();\r\n    for (From f : list) {\r\n        b.add(selector.exec(f));\r\n    }\r\n    return b;\r\n}"
}, {
	"Path": "com.facebook.buck.cli.AbstractCliConfig.getJsonAttributeFormat",
	"Comment": "when printing out json representation of targets, what formatting should be applied",
	"Method": "JsonAttributeFormat getJsonAttributeFormat(){\r\n    return getDelegate().getEnum(\"ui\", \"json_attribute_format\", JsonAttributeFormat.class).orElse(JsonAttributeFormat.DEFAULT);\r\n}"
}, {
	"Path": "com.facebook.buck.cli.TargetPatternEvaluator.preloadTargetPatterns",
	"Comment": "attempts to parse and load the given collection of patterns.",
	"Method": "void preloadTargetPatterns(Iterable<String> patterns,ListeningExecutorService executor){\r\n    resolveTargetPatterns(patterns, executor);\r\n}"
}, {
	"Path": "com.facebook.buck.cli.OwnersReport.getNonExistentInputs",
	"Comment": "get the set of inputs specified in a build rule that do not exist on disk",
	"Method": "ImmutableSet<String> getNonExistentInputs(){\r\n    return nonExistentInputs;\r\n}"
}, {
	"Path": "com.facebook.buck.cli.Main.getWaitEventsWrapper",
	"Comment": "raii wrapper which does not really close any object but waits for all events in given event busto complete. we want to have it this way to safely start deinitializing event listeners",
	"Method": "CloseableWrapper<BuckEventBus> getWaitEventsWrapper(BuckEventBus buildEventBus){\r\n    return CloseableWrapper.of(buildEventBus, eventBus -> {\r\n        if (!eventBus.waitEvents(EVENT_BUS_TIMEOUT_SECONDS * 1000)) {\r\n            LOG.warn(\"Event bus did not complete all events within timeout; event listener's data\" + \"may be incorrect\");\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.facebook.buck.cli.TargetsCommand.getUserFacingOutputPath",
	"Comment": "returns absolute path to the output rule, if the rule has an output.",
	"Method": "Optional<Path> getUserFacingOutputPath(SourcePathResolver pathResolver,BuildRule rule,boolean buckOutCompatLink){\r\n    Optional<Path> outputPathOptional = Optional.ofNullable(rule.getSourcePathToOutput()).map(pathResolver::getRelativePath);\r\n    if (outputPathOptional.isPresent() && buckOutCompatLink) {\r\n        BuckPaths paths = rule.getProjectFilesystem().getBuckPaths();\r\n        if (outputPathOptional.get().startsWith(paths.getConfiguredBuckOut())) {\r\n            outputPathOptional = Optional.of(paths.getBuckOut().resolve(outputPathOptional.get().subpath(paths.getConfiguredBuckOut().getNameCount(), outputPathOptional.get().getNameCount())));\r\n        }\r\n    }\r\n    return outputPathOptional.map(rule.getProjectFilesystem()::resolve);\r\n}"
}, {
	"Path": "org.activiti.engine.impl.util.json.JSONObject.toJSONArray",
	"Comment": "produce a jsonarray containing the values of the members of this jsonobject.",
	"Method": "JSONArray toJSONArray(JSONArray names){\r\n    if (names == null || names.length() == 0) {\r\n        return null;\r\n    }\r\n    JSONArray ja = new JSONArray();\r\n    for (int i = 0; i < names.length(); i += 1) {\r\n        ja.put(this.opt(names.getString(i)));\r\n    }\r\n    return ja;\r\n}"
}, {
	"Path": "com.facebook.buck.android.AndroidBinary.getApkInfo",
	"Comment": "the apk at this path is the final one that points to an apk that a user should install.",
	"Method": "ApkInfo getApkInfo(){\r\n    return ApkInfo.builder().setApkPath(getSourcePathToOutput()).setManifestPath(manifestPath).setExopackageInfo(exopackageInfo).build();\r\n}"
}, {
	"Path": "com.taobao.arthas.core.shell.ShellServerOptions.setWelcomeMessage",
	"Comment": "set the shell welcome message, i.e the message displayed in the user console when he connects to the shell.",
	"Method": "ShellServerOptions setWelcomeMessage(String welcomeMessage){\r\n    this.welcomeMessage = welcomeMessage;\r\n    return this;\r\n}"
}, {
	"Path": "com.facebook.buck.android.aapt.RDotTxtEntry.hexDecimalStringValue",
	"Comment": "convert integer string values to hex decimal string fornon integer arrays and non styleable entries.",
	"Method": "String hexDecimalStringValue(IdType idType,RType type,String idValue){\r\n    if (idType == IdType.INT_ARRAY || type == RType.STYLEABLE) {\r\n        return idValue;\r\n    }\r\n    if (idValue.length() == 0 || idValue.startsWith(\"0x\")) {\r\n        return idValue;\r\n    } else {\r\n        return String.format(\"0xx\", Integer.parseInt(idValue));\r\n    }\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.AwesomeTextView.setFontAwesomeIcon",
	"Comment": "sets the text to display a fonticon, replacing whatever text is already present.used to set the text to display a fontawesome icon.",
	"Method": "void setFontAwesomeIcon(CharSequence iconCode){\r\n    setBootstrapText(new BootstrapText.Builder(getContext(), isInEditMode()).addFontAwesomeIcon(iconCode).build());\r\n}"
}, {
	"Path": "com.fernandocejas.android10.sample.presentation.view.activity.BaseActivity.getApplicationComponent",
	"Comment": "get the main application component for dependency injection.",
	"Method": "ApplicationComponent getApplicationComponent(){\r\n    return ((AndroidApplication) getApplication()).getApplicationComponent();\r\n}"
}, {
	"Path": "org.asynchttpclient.extras.rxjava.AsyncHttpObservable.toObservable",
	"Comment": "observe a request execution and emit the response to the observer.",
	"Method": "Observable<Response> toObservable(Func0<BoundRequestBuilder> supplier){\r\n    final BoundRequestBuilder builder = supplier.call();\r\n    return Observable.unsafeCreate(new Observable.OnSubscribe<Response>() {\r\n        @Override\r\n        public void call(final Subscriber<? super Response> subscriber) {\r\n            try {\r\n                AsyncCompletionHandler<Void> handler = new AsyncCompletionHandler<Void>() {\r\n                    @Override\r\n                    public Void onCompleted(Response response) throws Exception {\r\n                        subscriber.onNext(response);\r\n                        subscriber.onCompleted();\r\n                        return null;\r\n                    }\r\n                    @Override\r\n                    public void onThrowable(Throwable t) {\r\n                        subscriber.onError(t);\r\n                    }\r\n                };\r\n                builder.execute(handler);\r\n            } catch (Throwable t) {\r\n                subscriber.onError(t);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.asynchttpclient.extras.rxjava.AsyncHttpObservable.toObservable",
	"Comment": "observe a request execution and emit the response to the observer.",
	"Method": "Observable<Response> toObservable(Func0<BoundRequestBuilder> supplier){\r\n    try {\r\n        AsyncCompletionHandler<Void> handler = new AsyncCompletionHandler<Void>() {\r\n            @Override\r\n            public Void onCompleted(Response response) throws Exception {\r\n                subscriber.onNext(response);\r\n                subscriber.onCompleted();\r\n                return null;\r\n            }\r\n            @Override\r\n            public void onThrowable(Throwable t) {\r\n                subscriber.onError(t);\r\n            }\r\n        };\r\n        builder.execute(handler);\r\n    } catch (Throwable t) {\r\n        subscriber.onError(t);\r\n    }\r\n}"
}, {
	"Path": "org.asynchttpclient.extras.rxjava.AsyncHttpObservable.toObservable",
	"Comment": "observe a request execution and emit the response to the observer.",
	"Method": "Observable<Response> toObservable(Func0<BoundRequestBuilder> supplier){\r\n    subscriber.onNext(response);\r\n    subscriber.onCompleted();\r\n    return null;\r\n}"
}, {
	"Path": "org.asynchttpclient.extras.rxjava.AsyncHttpObservable.toObservable",
	"Comment": "observe a request execution and emit the response to the observer.",
	"Method": "Observable<Response> toObservable(Func0<BoundRequestBuilder> supplier){\r\n    subscriber.onError(t);\r\n}"
}, {
	"Path": "com.facebook.buck.android.AdbHelper.createAdb",
	"Comment": "creates connection to adb and waits for this connection to be initialized and receive initiallist of devices.",
	"Method": "AndroidDebugBridge createAdb(AndroidPlatformTarget androidPlatformTarget,ExecutionContext context,int adbTimeout){\r\n    DdmPreferences.setTimeOut(adbTimeout);\r\n    try {\r\n        AndroidDebugBridge.init(false);\r\n    } catch (IllegalStateException ex) {\r\n    }\r\n    AndroidDebugBridge adb = AndroidDebugBridge.createBridge(androidPlatformTarget.getAdbExecutable().toString(), false);\r\n    if (adb == null) {\r\n        context.getConsole().printBuildFailure(\"Failed to connect to adb. Make sure adb server is running.\");\r\n        return null;\r\n    }\r\n    long start = System.currentTimeMillis();\r\n    while (!isAdbInitialized(adb)) {\r\n        long timeLeft = start + ADB_CONNECT_TIMEOUT_MS - System.currentTimeMillis();\r\n        if (timeLeft <= 0) {\r\n            break;\r\n        }\r\n        Thread.sleep(ADB_CONNECT_TIME_STEP_MS);\r\n    }\r\n    return isAdbInitialized(adb) ? adb : null;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.cmd.NeedsActiveTaskCmd.getSuspendedTaskException",
	"Comment": "subclasses can override this method to provide a customized exception message that will be thrown when the task is suspended.",
	"Method": "String getSuspendedTaskException(){\r\n    return \"Cannot execute operation: task is suspended\";\r\n}"
}, {
	"Path": "org.asynchttpclient.ntlm.NtlmEngine.createBlob",
	"Comment": "creates the ntlmv2 blob from the given target information block andclient challenge.",
	"Method": "byte[] createBlob(byte[] clientChallenge,byte[] targetInformation,byte[] timestamp){\r\n    final byte[] blobSignature = new byte[] { (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00 };\r\n    final byte[] reserved = new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };\r\n    final byte[] unknown1 = new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };\r\n    final byte[] unknown2 = new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };\r\n    final byte[] blob = new byte[blobSignature.length + reserved.length + timestamp.length + 8 + unknown1.length + targetInformation.length + unknown2.length];\r\n    int offset = 0;\r\n    System.arraycopy(blobSignature, 0, blob, offset, blobSignature.length);\r\n    offset += blobSignature.length;\r\n    System.arraycopy(reserved, 0, blob, offset, reserved.length);\r\n    offset += reserved.length;\r\n    System.arraycopy(timestamp, 0, blob, offset, timestamp.length);\r\n    offset += timestamp.length;\r\n    System.arraycopy(clientChallenge, 0, blob, offset, 8);\r\n    offset += 8;\r\n    System.arraycopy(unknown1, 0, blob, offset, unknown1.length);\r\n    offset += unknown1.length;\r\n    System.arraycopy(targetInformation, 0, blob, offset, targetInformation.length);\r\n    offset += targetInformation.length;\r\n    System.arraycopy(unknown2, 0, blob, offset, unknown2.length);\r\n    offset += unknown2.length;\r\n    return blob;\r\n}"
}, {
	"Path": "com.facebook.buck.android.resources.ResChunk.copy",
	"Comment": "these are some utilities used widely by subclasses for dealing with bytebuffers.",
	"Method": "ByteBuffer copy(ByteBuffer buf){\r\n    return wrap(Arrays.copyOfRange(buf.array(), buf.arrayOffset(), buf.arrayOffset() + buf.limit()));\r\n}"
}, {
	"Path": "org.apache.commons.net.telnet.TelnetOptionHandler.setAcceptRemote",
	"Comment": "set behaviour of the option for will requests coming fromthe other end.",
	"Method": "void setAcceptRemote(boolean accept){\r\n    acceptRemote = accept;\r\n}"
}, {
	"Path": "org.activiti.engine.impl.bpmn.behavior.CallActivityBehavior.findProcessDefinition",
	"Comment": "allow subclass to determine which version of a process to start.",
	"Method": "ProcessDefinition findProcessDefinition(String processDefinitionKey,String tenantId){\r\n    if (tenantId == null || ProcessEngineConfiguration.NO_TENANT_ID.equals(tenantId)) {\r\n        return Context.getProcessEngineConfiguration().getDeploymentManager().findDeployedLatestProcessDefinitionByKey(processDefinitionKey);\r\n    } else {\r\n        return Context.getProcessEngineConfiguration().getDeploymentManager().findDeployedLatestProcessDefinitionByKeyAndTenantId(processDefinitionKey, tenantId);\r\n    }\r\n}"
}, {
	"Path": "org.apache.commons.net.ProtocolCommandEvent.getMessage",
	"Comment": "returns the entire message sent to or received from the server.includes the line terminator.",
	"Method": "String getMessage(){\r\n    return __message;\r\n}"
}, {
	"Path": "com.facebook.buck.core.config.BuckConfig.getShouldDeleteTemporaries",
	"Comment": "whether to delete temporary files generated to run a build rule immediately after the rule isrun.",
	"Method": "boolean getShouldDeleteTemporaries(){\r\n    return config.getBooleanValue(\"build\", \"delete_temporaries\", false);\r\n}"
}, {
	"Path": "org.antlr.v4.semantics.SemanticPipeline.assignChannelTypes",
	"Comment": "assign constant values to custom channels defined in a grammar.",
	"Method": "void assignChannelTypes(Grammar g,List<GrammarAST> channelDefs){\r\n    Grammar outermost = g.getOutermostGrammar();\r\n    for (GrammarAST channel : channelDefs) {\r\n        String channelName = channel.getText();\r\n        if (g.getTokenType(channelName) != Token.INVALID_TYPE) {\r\n            g.tool.errMgr.grammarError(ErrorType.CHANNEL_CONFLICTS_WITH_TOKEN, g.fileName, channel.token, channelName);\r\n        }\r\n        if (LexerATNFactory.COMMON_CONSTANTS.containsKey(channelName)) {\r\n            g.tool.errMgr.grammarError(ErrorType.CHANNEL_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, channel.token, channelName);\r\n        }\r\n        if (outermost instanceof LexerGrammar) {\r\n            LexerGrammar lexerGrammar = (LexerGrammar) outermost;\r\n            if (lexerGrammar.modes.containsKey(channelName)) {\r\n                g.tool.errMgr.grammarError(ErrorType.CHANNEL_CONFLICTS_WITH_MODE, g.fileName, channel.token, channelName);\r\n            }\r\n        }\r\n        outermost.defineChannelName(channel.getText());\r\n    }\r\n}"
}, {
	"Path": "com.beardedhen.androidbootstrap.BootstrapButton.setViewGroupPosition",
	"Comment": "called by the viewparent, notifies the child of its position so that it can update itsdrawable to match the position",
	"Method": "void setViewGroupPosition(ViewGroupPosition viewGroupPosition,int parentIndex){\r\n    this.viewGroupPosition = viewGroupPosition;\r\n    this.parentIndex = parentIndex;\r\n    updateBootstrapState();\r\n}"
}, {
	"Path": "org.activiti.engine.impl.persistence.entity.ExecutionEntityManagerImpl.createChildExecution",
	"Comment": "creates a new execution. properties processdefinition, processinstance and activity will be initialized.",
	"Method": "ExecutionEntity createChildExecution(ExecutionEntity parentExecutionEntity){\r\n    ExecutionEntity childExecution = executionDataManager.create();\r\n    inheritCommonProperties(parentExecutionEntity, childExecution);\r\n    childExecution.setParent(parentExecutionEntity);\r\n    childExecution.setProcessDefinitionId(parentExecutionEntity.getProcessDefinitionId());\r\n    childExecution.setProcessDefinitionKey(parentExecutionEntity.getProcessDefinitionKey());\r\n    childExecution.setProcessInstanceId(parentExecutionEntity.getProcessInstanceId() != null ? parentExecutionEntity.getProcessInstanceId() : parentExecutionEntity.getId());\r\n    childExecution.setScope(false);\r\n    parentExecutionEntity.addChildExecution(childExecution);\r\n    insert(childExecution, false);\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Child execution {} created with parent {}\", childExecution, parentExecutionEntity.getId());\r\n    }\r\n    if (getEventDispatcher().isEnabled()) {\r\n        getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_CREATED, childExecution));\r\n        getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_INITIALIZED, childExecution));\r\n    }\r\n    return childExecution;\r\n}"
}, {
	"Path": "com.facebook.buck.artifact_cache.ArtifactCaches.newServedCache",
	"Comment": "creates a new instance of the cache to be used to serve the dircache from the webserver.",
	"Method": "Optional<ArtifactCache> newServedCache(ArtifactCacheBuckConfig buckConfig,ProjectFilesystem projectFilesystem){\r\n    return buckConfig.getServedLocalCache().map(input -> createDirArtifactCache(Optional.empty(), input, projectFilesystem, MoreExecutors.newDirectExecutorService()));\r\n}"
}]