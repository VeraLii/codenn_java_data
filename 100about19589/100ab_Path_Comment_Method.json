[{
	"Path": "com.facebook.buck.event.chrome_trace.ChromeTraceWriter.writeEnd",
	"Comment": "must be called after all events to properly terminate event stream.",
	"Method": "void writeEnd(){\r\n    jsonGenerator.writeEndArray();\r\n}"
}, {
	"Path": "com.android.dx.cf.code.BaseMachine.throwLocalMismatch",
	"Comment": "throws an exception that indicates a mismatch in local variabletypes.",
	"Method": "void throwLocalMismatch(TypeBearer found,TypeBearer local){\r\n    throw new SimException(\"local variable type mismatch: \" + \"attempt to set or access a value of type \" + found.toHuman() + \" using a local variable of type \" + local.toHuman() + \". This is symptomatic of .class transformation tools \" + \"that ignore local variable information.\");\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.ThriftCoordinatorClient.getWork",
	"Comment": "requests for more work from the coordinator to build locally.",
	"Method": "GetWorkResponse getWork(String minionId,MinionType minionType,int minionExitCode,List<String> finishedTargets,int maxWorkUnitsToFetch){\r\n    LOG.info(String.format(\"Sending GetWorkRequest. Minion [%s] is reporting that it finished building [%s] items. Requesting [%s] items.\", minionId, finishedTargets.size(), maxWorkUnitsToFetch));\r\n    Client checkedClient = checkThriftClientRunningOrThrow();\r\n    GetWorkRequest request = new GetWorkRequest().setStampedeId(stampedeId).setMinionId(minionId).setMinionType(minionType).setFinishedTargets(finishedTargets).setMaxWorkUnitsToFetch(maxWorkUnitsToFetch).setLastExitCode(minionExitCode);\r\n    try {\r\n        GetWorkResponse work = checkedClient.getWork(request);\r\n        LOG.info(String.format(\"Finished sending GetWorkRequest. MinionId: %s.\", minionId));\r\n        return work;\r\n    } catch (TException ex) {\r\n        throw handleTException(ex, \"GetWorkRequest\");\r\n    } catch (RuntimeException ex) {\r\n        throw handleRuntimeException(ex, \"GetWorkRequest\");\r\n    }\r\n}"
}, {
	"Path": "com.android.common.xml.AndroidManifest.getDebuggable",
	"Comment": "returns whether the manifest is set to make the application debuggable.if the give manifest does not contain the debuggable attribute then the applicationis considered to not be debuggable.",
	"Method": "boolean getDebuggable(IAbstractFile manifestFile){\r\n    String value = getStringValue(manifestFile, \"/\" + NODE_MANIFEST + \"/\" + NODE_APPLICATION + \"/@\" + AndroidXPathFactory.DEFAULT_NS_PREFIX + \":\" + ATTRIBUTE_DEBUGGABLE);\r\n    return Boolean.parseBoolean(value);\r\n}"
}, {
	"Path": "com.android.dx.cf.attrib.RawAttribute.getPool",
	"Comment": "gets the constant pool to use for cpi resolution, if any. itpresumably came from the class file that this attribute camefrom.",
	"Method": "ConstantPool getPool(){\r\n    return pool;\r\n}"
}, {
	"Path": "com.android.dx.dex.code.LocalStart.getLocal",
	"Comment": "gets the register spec representing the local variable introducedby this instance.",
	"Method": "RegisterSpec getLocal(){\r\n    return local;\r\n}"
}, {
	"Path": "com.facebook.buck.query.QueryExpression.collectTargetPatterns",
	"Comment": "collects all target patterns that are referenced anywhere within this query expression and addsthem to the given collection, which must be mutable.this is intended to accumulate patterns from multiple expressions for preloading at once.",
	"Method": "void collectTargetPatterns(Collection<String> literals){\r\n    traverse(new TargetPatternCollector(literals));\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.tracing.TracingTaskListenerTest.testTracesAfterChainingOnStart",
	"Comment": "in order for tracingtasklistener to record the most accurate timings for time spent in javac,it needs to trace start events after chaining to the next listener.",
	"Method": "void testTracesAfterChainingOnStart(){\r\n    TaskEventMirror enterEvent = new TaskEventMirror(null, TaskEventMirror.Kind.ENTER, createMock(JavaFileObject.class), null, null);\r\n    mockControl.checkOrder(true);\r\n    mockNextListener.started(enterEvent);\r\n    mockTracer.beginEnter();\r\n    mockControl.replay();\r\n    tracingTaskListener.started(enterEvent);\r\n    mockControl.verify();\r\n}"
}, {
	"Path": "com.android.common.utils.XmlUtils.formatFloatAttribute",
	"Comment": "format the given floating value into an xml string, omitting decimals if",
	"Method": "String formatFloatAttribute(double value){\r\n    if (value != (int) value) {\r\n        return String.format((Locale) null, \"%.2f\", value);\r\n    } else {\r\n        return Integer.toString((int) value);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.AbstractDistBuildSlaveExecutorArgs.createDelegateAndGraphsInitiazerArgs",
	"Comment": "create the arguments for a new instance of delegateandgraphsinitiazer.",
	"Method": "DelegateAndGraphsInitializerArgs createDelegateAndGraphsInitiazerArgs(){\r\n    return DelegateAndGraphsInitializerArgs.builder().setState(this.getState()).setTimingStatsTracker(this.getTimingStatsTracker()).setVersionedTargetGraphCache(this.getVersionedTargetGraphCache()).setActionGraphProvider(this.getActionGraphProvider()).setParser(this.getParser()).setBuckEventBus(this.getBuckEventBus()).setRuleKeyConfiguration(this.getRuleKeyConfiguration()).setProjectFilesystemFactory(this.getProjectFilesystemFactory()).setExecutorService(this.getExecutorService()).setExecutors(this.getExecutors()).setProvider(this.getProvider()).setKnownRuleTypesProvider(getKnownRuleTypesProvider()).setDistBuildConfig(this.getDistBuildConfig()).build();\r\n}"
}, {
	"Path": "com.facebook.buck.android.toolchain.ndk.impl.NdkCxxPlatformTest.constructCompileRuleKeys",
	"Comment": "create and return some rule keys from a dummy source for the given platforms.",
	"Method": "ImmutableMap<TargetCpuType, RuleKey> constructCompileRuleKeys(Operation operation,ImmutableMap<TargetCpuType, NdkCxxPlatform> cxxPlatforms){\r\n    ActionGraphBuilder graphBuilder = new TestActionGraphBuilder();\r\n    SourcePathRuleFinder ruleFinder = new SourcePathRuleFinder(graphBuilder);\r\n    SourcePathResolver pathResolver = DefaultSourcePathResolver.from(ruleFinder);\r\n    String source = \"source.cpp\";\r\n    DefaultRuleKeyFactory ruleKeyFactory = new TestDefaultRuleKeyFactory(FakeFileHashCache.createFromStrings(ImmutableMap.<String, String>builder().put(\"source.cpp\", Strings.repeat(\"a\", 40)).build()), pathResolver, ruleFinder);\r\n    BuildTarget target = BuildTargetFactory.newInstance(\"//:target\");\r\n    ImmutableMap.Builder<TargetCpuType, RuleKey> ruleKeys = ImmutableMap.builder();\r\n    for (Map.Entry<TargetCpuType, NdkCxxPlatform> entry : cxxPlatforms.entrySet()) {\r\n        CxxSourceRuleFactory cxxSourceRuleFactory = CxxSourceRuleFactory.builder().setBaseBuildTarget(target).setProjectFilesystem(new FakeProjectFilesystem()).setActionGraphBuilder(graphBuilder).setPathResolver(pathResolver).setRuleFinder(ruleFinder).setCxxBuckConfig(CxxPlatformUtils.DEFAULT_CONFIG).setCxxPlatform(entry.getValue().getCxxPlatform()).setPicType(PicType.PIC).build();\r\n        CxxPreprocessAndCompile rule;\r\n        switch(operation) {\r\n            case PREPROCESS_AND_COMPILE:\r\n                rule = cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(source, CxxSource.of(CxxSource.Type.CXX, FakeSourcePath.of(source), ImmutableList.of()));\r\n                break;\r\n            case COMPILE:\r\n                rule = cxxSourceRuleFactory.requireCompileBuildRule(source, CxxSource.of(CxxSource.Type.CXX_CPP_OUTPUT, FakeSourcePath.of(source), ImmutableList.of()));\r\n                break;\r\n            default:\r\n                throw new IllegalStateException();\r\n        }\r\n        ruleKeys.put(entry.getKey(), ruleKeyFactory.build(rule));\r\n    }\r\n    return ruleKeys.build();\r\n}"
}, {
	"Path": "com.android.manifmerger.XmlElement.mergeWithLowerPriorityNode",
	"Comment": "merge this xml element with a lower priority node.for now, attributes will be merged. if present on both xml elements, a warning will beissued and the attribute merge will be rejected.",
	"Method": "void mergeWithLowerPriorityNode(XmlElement lowerPriorityNode,MergingReport.Builder mergingReport){\r\n    if (mSelector != null && !mSelector.isResolvable(getDocument().getSelectors())) {\r\n        mergingReport.addMessage(getSourceFilePosition(), MergingReport.Record.Severity.ERROR, String.format(\"'tools:selector=\\\"%1$s\\\"' is not a valid library identifier, \" + \"valid identifiers are : %2$s\", mSelector.toString(), Joiner.on(',').join(mDocument.getSelectors().getKeys())));\r\n        return;\r\n    }\r\n    mergingReport.getLogger().info(\"Merging \" + getId() + \" with lower \" + lowerPriorityNode.printPosition());\r\n    MergeType mergeType = getType().getMergeType();\r\n    if (isA(ManifestModel.NodeTypes.MANIFEST) && lowerPriorityNode.getDocument().getFileType() != XmlDocument.Type.LIBRARY) {\r\n        mergeType = MergeType.MERGE;\r\n    }\r\n    if (mergeType != MergeType.MERGE_CHILDREN_ONLY) {\r\n        List<AttributeModel> attributeModels = new ArrayList<AttributeModel>(lowerPriorityNode.getType().getAttributeModels());\r\n        for (XmlAttribute lowerPriorityAttribute : lowerPriorityNode.getAttributes()) {\r\n            lowerPriorityAttribute.mergeInHigherPriorityElement(this, mergingReport);\r\n            if (lowerPriorityAttribute.getModel() != null) {\r\n                attributeModels.remove(lowerPriorityAttribute.getModel());\r\n            }\r\n        }\r\n        for (AttributeModel attributeModel : attributeModels) {\r\n            if (attributeModel.getDefaultValue() != null) {\r\n                Optional<XmlAttribute> myAttribute = getAttribute(attributeModel.getName());\r\n                if (myAttribute.isPresent()) {\r\n                    myAttribute.get().mergeWithLowerPriorityDefaultValue(mergingReport, lowerPriorityNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (mNodeOperationType != NodeOperationType.MERGE_ONLY_ATTRIBUTES) {\r\n        mergeChildren(lowerPriorityNode, mergingReport);\r\n    } else {\r\n        for (XmlElement lowerPriorityChild : lowerPriorityNode.getMergeableElements()) {\r\n            mergingReport.getActionRecorder().recordNodeAction(this, Actions.ActionType.REJECTED, lowerPriorityChild);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.PrebuiltCxxLibraryDescription.requireSharedLibrary",
	"Comment": "makes sure all build rules needed to produce the shared library are added to the action graph.",
	"Method": "SourcePath requireSharedLibrary(BuildTarget target,ActionGraphBuilder graphBuilder,CellPathResolver cellRoots,ProjectFilesystem filesystem,CxxPlatform cxxPlatform,Optional<ImmutableMap<BuildTarget, Version>> selectedVersions,PrebuiltCxxLibraryDescriptionArg args){\r\n    PrebuiltCxxLibraryPaths paths = getPaths(target, args);\r\n    Optional<SourcePath> sharedLibraryPath = paths.getSharedLibrary(filesystem, graphBuilder, cellRoots, cxxPlatform, selectedVersions);\r\n    if (sharedLibraryPath.isPresent()) {\r\n        return sharedLibraryPath.get();\r\n    }\r\n    CxxLink sharedLibrary = (CxxLink) graphBuilder.requireRule(target.withAppendedFlavors(cxxPlatform.getFlavor(), Type.SHARED.getFlavor()));\r\n    return sharedLibrary.getSourcePathToOutput();\r\n}"
}, {
	"Path": "com.android.dx.dex.file.ClassDefsSection.writeHeaderPart",
	"Comment": "writes the portion of the file header that refers to this instance.",
	"Method": "void writeHeaderPart(AnnotatedOutput out){\r\n    throwIfNotPrepared();\r\n    int sz = classDefs.size();\r\n    int offset = (sz == 0) ? 0 : getFileOffset();\r\n    if (out.annotates()) {\r\n        out.annotate(4, \"class_defs_size: \" + Hex.u4(sz));\r\n        out.annotate(4, \"class_defs_off:  \" + Hex.u4(offset));\r\n    }\r\n    out.writeInt(sz);\r\n    out.writeInt(offset);\r\n}"
}, {
	"Path": "com.facebook.buck.features.apple.project.ProjectGeneratorTest.generatedProjectConfigurationListIsUnionOfAllTargetConfigurations",
	"Comment": "the project configurations should have named entries corresponding to every existing targetconfiguration for targets in the project.",
	"Method": "void generatedProjectConfigurationListIsUnionOfAllTargetConfigurations(){\r\n    BuildTarget buildTarget1 = BuildTargetFactory.newInstance(rootPath, \"//foo\", \"rule1\");\r\n    TargetNode<?> node1 = AppleLibraryBuilder.createBuilder(buildTarget1).setConfigs(ImmutableSortedMap.of(\"Conf1\", ImmutableMap.of(), \"Conf2\", ImmutableMap.of())).build();\r\n    BuildTarget buildTarget2 = BuildTargetFactory.newInstance(rootPath, \"//foo\", \"rule2\");\r\n    TargetNode<?> node2 = AppleLibraryBuilder.createBuilder(buildTarget2).setConfigs(ImmutableSortedMap.of(\"Conf2\", ImmutableMap.of(), \"Conf3\", ImmutableMap.of())).build();\r\n    ProjectGenerator projectGenerator = createProjectGenerator(ImmutableSet.of(node1, node2));\r\n    projectGenerator.createXcodeProjects();\r\n    PBXProject generatedProject = projectGenerator.getGeneratedProject();\r\n    Map<String, XCBuildConfiguration> configurations = generatedProject.getBuildConfigurationList().getBuildConfigurationsByName().asMap();\r\n    assertThat(configurations, hasKey(\"Conf1\"));\r\n    assertThat(configurations, hasKey(\"Conf2\"));\r\n    assertThat(configurations, hasKey(\"Conf3\"));\r\n}"
}, {
	"Path": "com.android.dx.dex.code.LocalStart.localString",
	"Comment": "returns the local variable listing string for a single register spec.",
	"Method": "String localString(RegisterSpec spec){\r\n    return spec.regString() + ' ' + spec.getLocalItem().toString() + \": \" + spec.getTypeBearer().toHuman();\r\n}"
}, {
	"Path": "com.facebook.buck.util.MoreSets.intersection",
	"Comment": "returns a new and mutable set containing the intersection of the two specified sets. using thesmaller of the two sets as the base for finding the intersection for performance reasons.",
	"Method": "Set<T> intersection(Set<T> x,Set<T> y){\r\n    Set<T> result = new LinkedHashSet();\r\n    if (x.size() > y.size()) {\r\n        Sets.intersection(y, x).copyInto(result);\r\n    } else {\r\n        Sets.intersection(x, y).copyInto(result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.facebook.buck.util.PackagedResource.getFilenamePath",
	"Comment": "use this combined with file hash as unique id when hashing is enabled.",
	"Method": "Path getFilenamePath(){\r\n    return filename;\r\n}"
}, {
	"Path": "com.facebook.buck.parser.cache.impl.CachingProjectBuildFileParserDecorator.getBuildFileManifest",
	"Comment": "calculate the globs state is proper for using the returned manifest from storage.",
	"Method": "BuildFileManifest getBuildFileManifest(Path buildFile){\r\n    @Nullable\r\n    HashCode weakFingerprint = null;\r\n    @Nullable\r\n    HashCode strongFingerprint = null;\r\n    Optional<BuildFileManifest> buildFileManifestFromCache = Optional.empty();\r\n    try {\r\n        ImmutableSortedSet<String> includeBuildFiles = delegate.getIncludedFiles(buildFile);\r\n        weakFingerprint = Fingerprinter.getWeakFingerprint(buildFile, config);\r\n        strongFingerprint = Fingerprinter.getStrongFingerprint(filesystem, includeBuildFiles, fileHashCache);\r\n        buildFileManifestFromCache = parserCache.getBuildFileManifest(buildFile, delegate, weakFingerprint, strongFingerprint);\r\n        if (buildFileManifestFromCache.isPresent()) {\r\n            return buildFileManifestFromCache.get();\r\n        }\r\n    } catch (IOException e) {\r\n        LOG.error(e, \"Failure getting BuildFileManifest in caching decorator.\");\r\n    } catch (BuildFileParseException e) {\r\n        LOG.debug(e, \"Failure getting includes when getting the BuildFileManifest in caching decorator.\");\r\n    }\r\n    BuildFileManifest parsedManifest = delegate.getBuildFileManifest(buildFile);\r\n    if (weakFingerprint != null && strongFingerprint != null) {\r\n        try {\r\n            parserCache.storeBuildFileManifest(buildFile, parsedManifest, weakFingerprint, strongFingerprint);\r\n        } catch (IOException e) {\r\n            LOG.error(e, \"Failure storing parsed BuildFileManifest.\");\r\n        }\r\n    }\r\n    return parsedManifest;\r\n}"
}, {
	"Path": "com.android.common.xml.AndroidManifest.getTestTargetPackageXPath",
	"Comment": "returns the xpath expression for the instrumentation target package",
	"Method": "String getTestTargetPackageXPath(){\r\n    return \"/\" + NODE_MANIFEST + \"/\" + NODE_INSTRUMENTATION + \"/@\" + AndroidXPathFactory.DEFAULT_NS_PREFIX + \":\" + ATTRIBUTE_TARGET_PACKAGE;\r\n}"
}, {
	"Path": "com.android.dx.cf.code.Ropper.getSynchReg",
	"Comment": "gets the register spec to use to hold the object to synchronize on,for a synchronized method.",
	"Method": "RegisterSpec getSynchReg(){\r\n    int reg = getNormalRegCount();\r\n    return RegisterSpec.make((reg < 1) ? 1 : reg, Type.OBJECT);\r\n}"
}, {
	"Path": "com.android.dx.dex.code.RopTranslator.outputInstructions",
	"Comment": "performs initial creation of output instructions based on theoriginal blocks.",
	"Method": "void outputInstructions(){\r\n    BasicBlockList blocks = method.getBlocks();\r\n    int[] order = this.order;\r\n    int len = order.length;\r\n    for (int i = 0; i < len; i++) {\r\n        int nextI = i + 1;\r\n        int nextLabel = (nextI == order.length) ? -1 : order[nextI];\r\n        outputBlock(blocks.labelToBlock(order[i]), nextLabel);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.features.apple.project.AbstractProjectGeneratorOptions.shouldCreateDirectoryStructure",
	"Comment": "put targets into groups reflecting directory structure of their buck files",
	"Method": "boolean shouldCreateDirectoryStructure(){\r\n    return false;\r\n}"
}, {
	"Path": "com.facebook.buck.features.project.intellij.aggregation.AggregationTree.createStartingNodes",
	"Comment": "make sure aggregation nodes are present at the starting locations of aggregation.creates artificial nodes if some nodes are not present. these nodes contain only modulepaths.",
	"Method": "void createStartingNodes(AggregationTreeNode node,int depth){\r\n    if (depth <= 0) {\r\n        return;\r\n    }\r\n    for (Path childPath : node.getChildrenPaths()) {\r\n        if (childPath.getNameCount() > depth) {\r\n            createStartingNode(node, depth, childPath);\r\n        } else if (childPath.getNameCount() < depth) {\r\n            createStartingNodes(node.getChild(childPath), depth - childPath.getNameCount());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.json.TargetCountVerificationParserDecorator.maybePostWarningAboutTooManyTargets",
	"Comment": "warns about more than reasonable amount of targets created by parsing the expanded buildfile.",
	"Method": "void maybePostWarningAboutTooManyTargets(Path buildFile,int targetCount){\r\n    if (targetCount <= targetWarnCount) {\r\n        return;\r\n    }\r\n    buckEventBus.post(ConsoleEvent.warning(String.format(\"Number of expanded targets - %1$d - in file %2$s exceeds the threshold of %3$d. This could result in really slow builds.\", targetCount, buildFile.toString(), targetWarnCount)));\r\n}"
}, {
	"Path": "com.facebook.buck.step.AbstractExecutionContext.getWorkerProcessPools",
	"Comment": "worker process pools that you can populate as needed. these will be destroyed as soon as buckinvocation finishes, thus, these pools are not persisted across buck invocations.",
	"Method": "ConcurrentMap<String, WorkerProcessPool> getWorkerProcessPools(){\r\n    return new ConcurrentHashMap();\r\n}"
}, {
	"Path": "com.facebook.buck.util.function.ThrowingFunction.asFunction",
	"Comment": "a simple helper for constructing a function from a throwing lambda.",
	"Method": "Function<T, R> asFunction(Function<T2, R2> asFunction,ThrowingFunction<T2, R2, E2> throwingFunction){\r\n    return throwingFunction.asFunction();\r\n}"
}, {
	"Path": "com.facebook.buck.util.cache.AbstractCacheStats.subtract",
	"Comment": "adds or subtract two cachestats if a field is specified by both cachestats, with a minimumvalue of 0. if only one cachestats specifies the field, the unspecified value is treated as 0.if non of the cachestats specifies the field, the field will be empty.",
	"Method": "CacheStats subtract(CacheStats stats){\r\n    return aggregate(this, stats, false);\r\n}"
}, {
	"Path": "com.facebook.buck.core.config.AliasConfigTest.testGetBasePathToAliasMap",
	"Comment": "ensure that whichever alias is listed first in the file is the one used in the reverse map ifthe value appears multiple times.",
	"Method": "void testGetBasePathToAliasMap(){\r\n    Reader reader1 = new StringReader(Joiner.on('\\n').join(\"[alias]\", \"debug   =   //java/com/example:app_debug\", \"release =   //java/com/example:app_release\"));\r\n    AliasConfig config1 = BuckConfigTestUtils.createWithDefaultFilesystem(temporaryFolder, reader1, AliasConfig.class);\r\n    assertEquals(ImmutableMap.of(Paths.get(\"java/com/example\"), \"debug\"), config1.getBasePathToAliasMap());\r\n    assertEquals(ImmutableMap.of(\"debug\", \"//java/com/example:app_debug\", \"release\", \"//java/com/example:app_release\"), config1.getEntries());\r\n    Reader reader2 = new StringReader(Joiner.on('\\n').join(\"[alias]\", \"release =   //java/com/example:app_release\", \"debug   =   //java/com/example:app_debug\"));\r\n    AliasConfig config2 = BuckConfigTestUtils.createWithDefaultFilesystem(temporaryFolder, reader2, AliasConfig.class);\r\n    assertEquals(ImmutableMap.of(Paths.get(\"java/com/example\"), \"release\"), config2.getBasePathToAliasMap());\r\n    assertEquals(ImmutableMap.of(\"debug\", \"//java/com/example:app_debug\", \"release\", \"//java/com/example:app_release\"), config2.getEntries());\r\n    Reader noAliasesReader = new StringReader(\"\");\r\n    AliasConfig noAliasesConfig = BuckConfigTestUtils.createWithDefaultFilesystem(temporaryFolder, noAliasesReader, AliasConfig.class);\r\n    assertEquals(ImmutableMap.of(), noAliasesConfig.getBasePathToAliasMap());\r\n    assertEquals(ImmutableMap.of(), noAliasesConfig.getEntries());\r\n}"
}, {
	"Path": "com.android.dex.Leb128.unsignedLeb128Size",
	"Comment": "gets the number of bytes in the unsigned leb128 encoding of thegiven value.",
	"Method": "int unsignedLeb128Size(int value){\r\n    int remaining = value >> 7;\r\n    int count = 0;\r\n    while (remaining != 0) {\r\n        remaining >>= 7;\r\n        count++;\r\n    }\r\n    return count + 1;\r\n}"
}, {
	"Path": "com.facebook.buck.rules.modern.ModernBuildRule.getSetupStepsForBuildable",
	"Comment": "gets the steps for preparing the output directories of the build rule.",
	"Method": "void getSetupStepsForBuildable(BuildContext context,ProjectFilesystem filesystem,Iterable<Path> outputs,Builder<Step> stepBuilder,OutputPathResolver outputPathResolver){\r\n    for (Path output : outputs) {\r\n        stepBuilder.add(RmStep.of(BuildCellRelativePath.fromCellRelativePath(context.getBuildCellRootPath(), filesystem, output)).withRecursive(true));\r\n    }\r\n    stepBuilder.addAll(MakeCleanDirectoryStep.of(BuildCellRelativePath.fromCellRelativePath(context.getBuildCellRootPath(), filesystem, outputPathResolver.getRootPath())));\r\n    stepBuilder.addAll(MakeCleanDirectoryStep.of(BuildCellRelativePath.fromCellRelativePath(context.getBuildCellRootPath(), filesystem, outputPathResolver.getTempPath())));\r\n}"
}, {
	"Path": "com.android.dx.dex.code.DalvInsn.makeMove",
	"Comment": "makes a move instruction, appropriate and ideal for the given arguments.",
	"Method": "SimpleInsn makeMove(SourcePosition position,RegisterSpec dest,RegisterSpec src){\r\n    boolean category1 = dest.getCategory() == 1;\r\n    boolean reference = dest.getType().isReference();\r\n    int destReg = dest.getReg();\r\n    int srcReg = src.getReg();\r\n    Dop opcode;\r\n    if ((srcReg | destReg) < 16) {\r\n        opcode = reference ? Dops.MOVE_OBJECT : (category1 ? Dops.MOVE : Dops.MOVE_WIDE);\r\n    } else if (destReg < 256) {\r\n        opcode = reference ? Dops.MOVE_OBJECT_FROM16 : (category1 ? Dops.MOVE_FROM16 : Dops.MOVE_WIDE_FROM16);\r\n    } else {\r\n        opcode = reference ? Dops.MOVE_OBJECT_16 : (category1 ? Dops.MOVE_16 : Dops.MOVE_WIDE_16);\r\n    }\r\n    return new SimpleInsn(opcode, position, RegisterSpecList.make(dest, src));\r\n}"
}, {
	"Path": "com.facebook.buck.features.project.intellij.IjProject.update",
	"Comment": "write a subset of the project to disk, specified by the targets passed on the command line.does not perform a clean of the project space after updating.",
	"Method": "ImmutableSet<BuildTarget> update(){\r\n    return performWriteOrUpdate(true);\r\n}"
}, {
	"Path": "com.facebook.buck.rules.coercer.AbstractSourceSortedSet.concat",
	"Comment": "concatenates elements of the given lists into a single list.",
	"Method": "SourceSortedSet concat(Iterable<SourceSortedSet> elements){\r\n    Type type = findType(elements);\r\n    if (type == Type.UNNAMED) {\r\n        return concatUnnamed(elements);\r\n    } else {\r\n        return concatNamed(elements);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.PrecompiledHeaderFeatureTest.preconfiguredCxxSourceBuilder",
	"Comment": "configures a cxxsource.builder representing a c source file.",
	"Method": "CxxSource.Builder preconfiguredCxxSourceBuilder(){\r\n    return CxxSource.builder().setType(CxxSource.Type.C).setPath(FakeSourcePath.of(\"foo.c\"));\r\n}"
}, {
	"Path": "com.android.dx.cf.code.LineNumberList.concat",
	"Comment": "returns an instance which is the concatenation of the two giveninstances.",
	"Method": "LineNumberList concat(LineNumberList list1,LineNumberList list2){\r\n    if (list1 == EMPTY) {\r\n        return list2;\r\n    }\r\n    int sz1 = list1.size();\r\n    int sz2 = list2.size();\r\n    LineNumberList result = new LineNumberList(sz1 + sz2);\r\n    for (int i = 0; i < sz1; i++) {\r\n        result.set(i, list1.get(i));\r\n    }\r\n    for (int i = 0; i < sz2; i++) {\r\n        result.set(sz1 + i, list2.get(i));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.facebook.buck.rules.modern.ModernBuildRule.injectFieldsIfNecessary",
	"Comment": "allows injecting the abstractbuildrule fields into a buildable after construction.",
	"Method": "void injectFieldsIfNecessary(ProjectFilesystem filesystem,BuildTarget target,Buildable buildable,SourcePathRuleFinder ruleFinder){\r\n    if (buildable instanceof ModernBuildRule) {\r\n        ModernBuildRule<?> rule = (ModernBuildRule<?>) buildable;\r\n        injectFields(rule, filesystem, target, ruleFinder);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.android.AndroidBinaryGraphEnhancerTest.testD8PreDexingWithoutInterfaceMethods",
	"Comment": "this test verifies that androidbinarygraphenhancer skips d8 desugar dependencies for javalibraries when interface methods desugar is disabled.",
	"Method": "void testD8PreDexingWithoutInterfaceMethods(){\r\n    JavaBuckConfig javaBuckConfig = getJavaBuckConfigWithInterfaceMethodsDexing(false);\r\n    BuildTarget javaDep1BuildTarget = BuildTargetFactory.newInstance(\"//java/com/example:dep1\");\r\n    BuildTarget javaDep2BuildTarget = BuildTargetFactory.newInstance(\"//java/com/example:dep2\");\r\n    TargetNode<?> javaDep2Node = JavaLibraryBuilder.createBuilder(javaDep2BuildTarget, javaBuckConfig).addSrc(Paths.get(\"java/com/example/Dep2.java\")).build();\r\n    TargetNode<?> javaDep1Node = JavaLibraryBuilder.createBuilder(javaDep1BuildTarget, javaBuckConfig).addSrc(Paths.get(\"java/com/example/Dep1.java\")).addDep(javaDep2Node.getBuildTarget()).build();\r\n    BuildTarget javaLibBuildTarget = BuildTargetFactory.newInstance(\"//java/com/example:lib\");\r\n    TargetNode<?> javaLibNode = JavaLibraryBuilder.createBuilder(javaLibBuildTarget, javaBuckConfig).addSrc(Paths.get(\"java/com/example/Lib.java\")).addDep(javaDep1Node.getBuildTarget()).build();\r\n    TargetGraph targetGraph = TargetGraphFactory.newInstance(javaDep1Node, javaDep2Node, javaLibNode);\r\n    ActionGraphBuilder graphBuilder = new TestActionGraphBuilder(targetGraph, createToolchainProviderForAndroidWithJava8());\r\n    SourcePathRuleFinder ruleFinder = new SourcePathRuleFinder(graphBuilder);\r\n    BuildRule javaDep1 = graphBuilder.requireRule(javaDep1BuildTarget);\r\n    BuildRule javaDep2 = graphBuilder.requireRule(javaDep2BuildTarget);\r\n    BuildRule javaLib = graphBuilder.requireRule(javaLibBuildTarget);\r\n    ImmutableSortedSet<BuildRule> originalDeps = ImmutableSortedSet.of(javaLib);\r\n    BuildTarget apkTarget = BuildTargetFactory.newInstance(\"//java/com/example:apk\");\r\n    FakeProjectFilesystem filesystem = new FakeProjectFilesystem();\r\n    BuildRuleParams originalParams = new BuildRuleParams(Suppliers.ofInstance(originalDeps), ImmutableSortedSet::of, ImmutableSortedSet.of());\r\n    AndroidBinaryGraphEnhancer graphEnhancer = new AndroidBinaryGraphEnhancer(createToolchainProviderForAndroidWithJava8(), TestCellPathResolver.get(filesystem), apkTarget, filesystem, TestAndroidPlatformTargetFactory.create(), originalParams, graphBuilder, AaptMode.AAPT1, ResourcesFilter.ResourceCompressionMode.DISABLED, FilterResourcesSteps.ResourceFilter.EMPTY_FILTER, EnumSet.noneOf(RType.class), Optional.empty(), Optional.empty(), ImmutableSet.of(), null, Optional.of(PathSourcePath.of(filesystem, Paths.get(\"AndroidManifest.xml\"))), Optional.empty(), Optional.empty(), PackageType.DEBUG, ImmutableSet.of(), false, true, DexSplitMode.NO_SPLIT, ImmutableSet.of(), ImmutableSet.of(), false, false, false, false, false, DEFAULT_JAVA_CONFIG, JavacFactoryHelper.createJavacFactory(DEFAULT_JAVA_CONFIG), ANDROID_JAVAC_OPTIONS, EnumSet.noneOf(ExopackageMode.class), BuildConfigFields.of(), Optional.empty(), OptionalInt.empty(), false, Optional.empty(), false, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), RelinkerMode.DISABLED, ImmutableList.of(), MoreExecutors.newDirectExecutorService(), ManifestEntries.empty(), CxxPlatformUtils.DEFAULT_CONFIG, new APKModuleGraph(TargetGraph.EMPTY, apkTarget, Optional.empty()), new DxConfig(FakeBuckConfig.builder().build()), DxStep.D8, Optional.empty(), defaultNonPredexedArgs(), ImmutableSortedSet.of(), false);\r\n    BuildTarget aaptPackageResourcesTarget = BuildTargetFactory.newInstance(\"//java/com/example:apk#aapt_package\");\r\n    AaptPackageResources aaptPackageResources = new AaptPackageResources(aaptPackageResourcesTarget, filesystem, TestAndroidPlatformTargetFactory.create(), ruleFinder, graphBuilder, FakeSourcePath.of(\"java/src/com/facebook/base/AndroidManifest.xml\"), ImmutableList.of(), new IdentityResourcesProvider(ImmutableList.of()), ImmutableList.of(), false, false, ManifestEntries.empty());\r\n    graphBuilder.addToIndex(aaptPackageResources);\r\n    AndroidPackageableCollection collection = new AndroidPackageableCollector(apkTarget, ImmutableSet.of(), ImmutableSet.of(), new APKModuleGraph(TargetGraph.EMPTY, apkTarget, Optional.empty())).addClasspathEntry(((HasJavaClassHashes) javaDep1), FakeSourcePath.of(\"ignored\")).addClasspathEntry(((HasJavaClassHashes) javaDep2), FakeSourcePath.of(\"ignored\")).addClasspathEntry(((HasJavaClassHashes) javaLib), FakeSourcePath.of(\"ignored\")).build();\r\n    graphEnhancer.createPreDexMergeRule(graphEnhancer.createPreDexRulesForLibraries(ImmutableList.of(), collection));\r\n    BuildRule javaDep1Abi = graphBuilder.getRule(BuildTargetFactory.newInstance(\"//java/com/example:dep1#class-abi\"));\r\n    BuildRule javaDep2Abi = graphBuilder.getRule(BuildTargetFactory.newInstance(\"//java/com/example:dep2#class-abi\"));\r\n    DexProducedFromJavaLibrary javaDep2DexRule = (DexProducedFromJavaLibrary) graphBuilder.getRule(BuildTargetFactory.newInstance(\"//java/com/example:dep2#d8\"));\r\n    assertNotNull(javaDep2DexRule);\r\n    assertThat(javaDep2DexRule.getDesugarDeps(), Matchers.nullValue());\r\n    assertThat(javaDep2DexRule.getBuildDeps(), Matchers.allOf(Matchers.not(Matchers.hasItem(javaDep2Abi)), Matchers.not(Matchers.hasItem(javaDep1Abi))));\r\n    DexProducedFromJavaLibrary javaDep1DexRule = (DexProducedFromJavaLibrary) graphBuilder.getRule(BuildTargetFactory.newInstance(\"//java/com/example:dep1#d8\"));\r\n    assertNotNull(javaDep1DexRule);\r\n    assertThat(javaDep1DexRule.getDesugarDeps(), Matchers.nullValue());\r\n    assertThat(javaDep1DexRule.getBuildDeps(), Matchers.allOf(Matchers.not(Matchers.hasItem(javaDep2Abi)), Matchers.not(Matchers.hasItem(javaDep1Abi))));\r\n    DexProducedFromJavaLibrary javaLibDexRule = (DexProducedFromJavaLibrary) graphBuilder.getRule(BuildTargetFactory.newInstance(\"//java/com/example:lib#d8\"));\r\n    assertNotNull(javaLibDexRule);\r\n    assertThat(javaLibDexRule.getDesugarDeps(), Matchers.nullValue());\r\n    assertThat(javaLibDexRule.getBuildDeps(), Matchers.allOf(Matchers.not(Matchers.hasItem(javaDep2Abi)), Matchers.not(Matchers.hasItem(javaDep1Abi))));\r\n}"
}, {
	"Path": "com.facebook.buck.log.thrift.ThriftRuleKeyLogger.write",
	"Comment": "writes a serialized form of the rule key to the output stream. serialization is thrift compact,with a 4 byte length prefix. serialization or write errors are swallowed, and logged so thatfailures to write do not terminate buck",
	"Method": "void write(FullRuleKey ruleKey){\r\n    TSerializer serializer = new TSerializer(new TCompactProtocol.Factory());\r\n    byte[] out;\r\n    try {\r\n        out = serializer.serialize(ruleKey);\r\n    } catch (TException e) {\r\n        logger.warn(e, \"Could not serialize key for target %s with hash %s\", ruleKey.name, ruleKey.key);\r\n        return;\r\n    }\r\n    synchronized (this) {\r\n        try {\r\n            writer.write(ByteBuffer.allocate(4).putInt(out.length).array());\r\n            writer.write(out);\r\n        } catch (IOException e) {\r\n            logger.warn(e, \"Could not write key for target %s with hash %s\", ruleKey.name, ruleKey.key);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.rules.macros.AbstractLocationMacro.of",
	"Comment": "shorthand for constructing a locationmacro referring to the main output.",
	"Method": "LocationMacro of(BuildTarget buildTarget){\r\n    return LocationMacro.of(buildTarget, Optional.empty());\r\n}"
}, {
	"Path": "com.facebook.buck.io.file.FileFinder.getOptionalFile",
	"Comment": "tries to find a file with one of a number of possible names in a search path.returns the first match found. search tries all paths in the search paths in order, lookingfor any matching names in each path.",
	"Method": "Optional<Path> getOptionalFile(Set<String> possibleNames,Iterable<Path> searchPaths,Predicate<Path> filter){\r\n    return RichStream.from(searchPaths).flatMap(searchPath -> possibleNames.stream().map(searchPath::resolve)).filter(filter).findFirst();\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.SuperConsoleConfig.getHideSucceededRulesInLogMode",
	"Comment": "when true, it will hide successful built rules when using the simple console.",
	"Method": "boolean getHideSucceededRulesInLogMode(){\r\n    return delegate.getBooleanValue(SECTION_NAME, \"hide_succeeded_rules_in_log_mode\", false);\r\n}"
}, {
	"Path": "com.facebook.buck.sandbox.darwin.DarwinSandbox.createCommandLineArgumentsForDescription",
	"Comment": "creates a list cl arguments that should be used to run a process in this sandbox",
	"Method": "ImmutableList<String> createCommandLineArgumentsForDescription(){\r\n    return createCommandLineArguments(\"sandbox-profile\");\r\n}"
}, {
	"Path": "com.facebook.buck.skylark.io.impl.WatchmanGlobber.toTypeExpression",
	"Comment": "returns an expression for matching types of files to return.",
	"Method": "ImmutableList<Object> toTypeExpression(boolean excludeDirectories){\r\n    ImmutableList.Builder<Object> typeExpressionBuilder = ImmutableList.builder().add(\"anyof\").add(ImmutableList.of(\"type\", \"f\")).add(ImmutableList.of(\"type\", \"l\"));\r\n    if (!excludeDirectories) {\r\n        typeExpressionBuilder.add(ImmutableList.of(\"type\", \"d\"));\r\n    }\r\n    return typeExpressionBuilder.build();\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.ThriftCoordinatorServer.checkAllMinionsAreAlive",
	"Comment": "checks if all minions are alive. fails the distributed build if they are not.",
	"Method": "void checkAllMinionsAreAlive(){\r\n    MinionHealthStatus minionHealthStatus = minionHealthTracker.checkMinionHealth();\r\n    if (allocator != null) {\r\n        for (MinionTrackingInfo deadMinion : minionHealthStatus.getDeadMinions()) {\r\n            if (deadMinions.contains(deadMinion.getMinionId())) {\r\n                continue;\r\n            }\r\n            allocator.handleMinionFailure(deadMinion.getMinionId());\r\n            try {\r\n                LOG.info(String.format(\"Updating status for [%s] to LOST.\", deadMinion.getRunId()));\r\n                distBuildService.updateBuildSlaveBuildStatus(stampedeId, deadMinion.getRunId(), BuildStatus.LOST);\r\n                deadMinions.add(deadMinion.getMinionId());\r\n            } catch (IOException e) {\r\n                LOG.error(e, String.format(\"Failed to update minion status to LOST for minion [%s]\", deadMinion.getRunId()));\r\n            }\r\n        }\r\n    }\r\n    OptionalInt totalMinionCount = minionCountProvider.getTotalMinionCount();\r\n    totalMinionCount.ifPresent(count -> {\r\n        int deadMinionCount = minionHealthStatus.getDeadMinions().size();\r\n        if (deadMinionCount >= count && !minionHealthStatus.hasAliveMinions()) {\r\n            String errorMessage = String.format(\"Failing build as all [%d] minions are dead\", deadMinionCount);\r\n            LOG.error(errorMessage);\r\n            exitCodeFuture.complete(ExitState.setLocally(DistributedExitCode.ALL_MINIONS_DEAD_EXIT_CODE.getCode(), errorMessage));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.facebook.buck.testrunner.TestNGRunner.mightBeATestClass",
	"Comment": "guessing whether or not a class is a test class is an imperfect art form.",
	"Method": "boolean mightBeATestClass(Class<?> klass){\r\n    int klassModifiers = klass.getModifiers();\r\n    if (!Modifier.isPublic(klassModifiers) || Modifier.isInterface(klassModifiers) || Modifier.isAbstract(klassModifiers)) {\r\n        return false;\r\n    }\r\n    boolean foundPublicNoArgConstructor = false;\r\n    boolean foundInjectedConstructor = false;\r\n    boolean hasGuiceAnnotation = klass.getAnnotationsByType(Guice.class).length > 0;\r\n    for (Constructor<?> c : klass.getConstructors()) {\r\n        if (Modifier.isPublic(c.getModifiers())) {\r\n            if (c.getParameterCount() == 0) {\r\n                foundPublicNoArgConstructor = true;\r\n            }\r\n            if (hasGuiceAnnotation && (c.getAnnotationsByType(com.google.inject.Inject.class).length > 0 || c.getAnnotationsByType(javax.inject.Inject.class).length > 0)) {\r\n                foundInjectedConstructor = true;\r\n            }\r\n        }\r\n    }\r\n    if (!foundPublicNoArgConstructor && !foundInjectedConstructor) {\r\n        return false;\r\n    }\r\n    boolean hasAtLeastOneTestMethod = false;\r\n    for (Method m : klass.getMethods()) {\r\n        if (Modifier.isPublic(m.getModifiers()) && m.getAnnotation(Test.class) != null) {\r\n            hasAtLeastOneTestMethod = true;\r\n        }\r\n        if (Modifier.isPublic(m.getModifiers()) && m.getAnnotation(Factory.class) != null) {\r\n            hasAtLeastOneTestMethod = true;\r\n        }\r\n    }\r\n    return hasAtLeastOneTestMethod;\r\n}"
}, {
	"Path": "com.android.manifmerger.ActionRecorder.recordDefaultNodeAction",
	"Comment": "when the first xml file is loaded, there is nothing to merge with, however, each xml elementand attribute added to the initial merged file need to be recorded.",
	"Method": "void recordDefaultNodeAction(XmlElement xmlElement){\r\n    if (!mRecords.containsKey(xmlElement.getOriginalId())) {\r\n        recordNodeAction(xmlElement, Actions.ActionType.ADDED);\r\n        for (XmlAttribute xmlAttribute : xmlElement.getAttributes()) {\r\n            AttributeOperationType attributeOperation = xmlElement.getAttributeOperationType(xmlAttribute.getName());\r\n            recordAttributeAction(xmlAttribute, Actions.ActionType.ADDED, attributeOperation);\r\n        }\r\n        for (XmlElement childNode : xmlElement.getMergeableElements()) {\r\n            recordDefaultNodeAction(childNode);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.dex.EncodedValueReader.skipValue",
	"Comment": "skips a single value, including its nested values if it is an array orannotation.",
	"Method": "void skipValue(){\r\n    switch(peek()) {\r\n        case ENCODED_BYTE:\r\n            readByte();\r\n            break;\r\n        case ENCODED_SHORT:\r\n            readShort();\r\n            break;\r\n        case ENCODED_CHAR:\r\n            readChar();\r\n            break;\r\n        case ENCODED_INT:\r\n            readInt();\r\n            break;\r\n        case ENCODED_LONG:\r\n            readLong();\r\n            break;\r\n        case ENCODED_FLOAT:\r\n            readFloat();\r\n            break;\r\n        case ENCODED_DOUBLE:\r\n            readDouble();\r\n            break;\r\n        case ENCODED_STRING:\r\n            readString();\r\n            break;\r\n        case ENCODED_TYPE:\r\n            readType();\r\n            break;\r\n        case ENCODED_FIELD:\r\n            readField();\r\n            break;\r\n        case ENCODED_ENUM:\r\n            readEnum();\r\n            break;\r\n        case ENCODED_METHOD:\r\n            readMethod();\r\n            break;\r\n        case ENCODED_ARRAY:\r\n            for (int i = 0, size = readArray(); i < size; i++) {\r\n                skipValue();\r\n            }\r\n            break;\r\n        case ENCODED_ANNOTATION:\r\n            for (int i = 0, size = readAnnotation(); i < size; i++) {\r\n                readAnnotationName();\r\n                skipValue();\r\n            }\r\n            break;\r\n        case ENCODED_NULL:\r\n            readNull();\r\n            break;\r\n        case ENCODED_BOOLEAN:\r\n            readBoolean();\r\n            break;\r\n        default:\r\n            throw new DexException(\"Unexpected type: \" + Integer.toHexString(type));\r\n    }\r\n}"
}, {
	"Path": "com.android.common.xml.AndroidManifest.getTargetSdkVersion",
	"Comment": "returns the value of the targetsdkversion attribute.if the attribute is set with an int value, the method returns an integer object.if the attribute is set with a codename, it returns the codename as a string object.if the attribute is not set, it returns null.",
	"Method": "Object getTargetSdkVersion(IAbstractFile manifestFile){\r\n    String result = getStringValue(manifestFile, getTargetSdkVersionXPath());\r\n    try {\r\n        return Integer.valueOf(result);\r\n    } catch (NumberFormatException e) {\r\n        return !result.isEmpty() ? result : null;\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.dex.code.OutputFinisher.findExpandedOpcodeForInsn",
	"Comment": "finds the proper opcode for the given instruction, ignoringregister constraints.",
	"Method": "Dop findExpandedOpcodeForInsn(DalvInsn insn){\r\n    Dop result = findOpcodeForInsn(insn.getLowRegVersion(), insn.getOpcode());\r\n    if (result == null) {\r\n        throw new DexException(\"No expanded opcode for \" + insn);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getLiteralNibble",
	"Comment": "gets the literal value, masked to be a nibble in size. thiswill throw if the value is out of the range of a signed nibble.",
	"Method": "int getLiteralNibble(){\r\n    if ((literal < -8) || (literal > 7)) {\r\n        throw new DexException(\"Literal out of range: \" + Hex.u8(literal));\r\n    }\r\n    return (int) literal & 0xf;\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.CxxBinaryIntegrationTest.headersShouldBeSetUpCorrectlyOnRebuild",
	"Comment": "tests that, if a file has to be rebuilt, but its header dependencies do not, that the headertree is still generated into the correct location.",
	"Method": "void headersShouldBeSetUpCorrectlyOnRebuild(){\r\n    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(this, \"cxx_binary_dep_header_tree_materialize\", tmp);\r\n    workspace.setUp();\r\n    workspace.enableDirCache();\r\n    workspace.runBuckBuild(\"//:bin\").assertSuccess();\r\n    workspace.runBuckCommand(\"clean\", \"--keep-cache\");\r\n    workspace.copyFile(\"bin.c.new\", \"bin.c\");\r\n    workspace.runBuckBuild(\"//:bin\").assertSuccess();\r\n    BuckBuildLog log = workspace.getBuildLog();\r\n    log.assertTargetBuiltLocally(\"//:bin#binary\");\r\n}"
}, {
	"Path": "com.facebook.buck.util.RichStream.filter",
	"Comment": "filter stream elements, returning only those that is an instance of the given class.",
	"Method": "RichStream<U> filter(Class<U> cls,RichStream<T> filter,Predicate<? super T> predicate){\r\n    return (RichStream<U>) filter(cls::isInstance);\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.MinionQueueProvider.registerMinionQueue",
	"Comment": "register mapping between given miniontype and minionqueue",
	"Method": "void registerMinionQueue(MinionType minionType,String minionQueue){\r\n    minionTypeToQueueName.put(minionType, minionQueue);\r\n}"
}, {
	"Path": "com.facebook.buck.util.string.MoreStrings.replaceCR",
	"Comment": "removes carriage return characters from the string with preserving new line characters.",
	"Method": "String replaceCR(String text){\r\n    return text.replace(\"\\r\\n\", \"\\n\").replace('\\r', '\\n');\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getLiteralUnit",
	"Comment": "gets the literal value, as a code unit. this will throw if thevalue is out of the range of a signed code unit.",
	"Method": "short getLiteralUnit(){\r\n    if (literal != (short) literal) {\r\n        throw new DexException(\"Literal out of range: \" + Hex.u8(literal));\r\n    }\r\n    return (short) literal;\r\n}"
}, {
	"Path": "com.android.dx.dex.file.FieldIdsSection.writeHeaderPart",
	"Comment": "writes the portion of the file header that refers to this instance.",
	"Method": "void writeHeaderPart(AnnotatedOutput out){\r\n    throwIfNotPrepared();\r\n    int sz = fieldIds.size();\r\n    int offset = (sz == 0) ? 0 : getFileOffset();\r\n    if (out.annotates()) {\r\n        out.annotate(4, \"field_ids_size:  \" + Hex.u4(sz));\r\n        out.annotate(4, \"field_ids_off:   \" + Hex.u4(offset));\r\n    }\r\n    out.writeInt(sz);\r\n    out.writeInt(offset);\r\n}"
}, {
	"Path": "com.android.dx.dex.file.OffsettedItem.getAlignment",
	"Comment": "gets the alignment requirement of this instance. an instance shouldonly be written when so aligned.",
	"Method": "int getAlignment(){\r\n    return alignment;\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.FatJarMain.updateEnvironment",
	"Comment": "update the library search path environment variable with the given native library directory.",
	"Method": "void updateEnvironment(Map<String, String> env,Path libDir){\r\n    String librarySearchPathName = getLibrarySearchPathName();\r\n    String originalLibPath = System.getenv(librarySearchPathName);\r\n    String newlibPath = libDir + (originalLibPath == null ? \"\" : File.pathSeparator + originalLibPath);\r\n    env.put(librarySearchPathName, newlibPath);\r\n}"
}, {
	"Path": "com.android.dx.dex.file.FieldIdsSection.indexOf",
	"Comment": "gets the index of the given reference, which must have been addedto this instance.",
	"Method": "int indexOf(CstFieldRef ref){\r\n    if (ref == null) {\r\n        throw new NullPointerException(\"ref == null\");\r\n    }\r\n    throwIfNotPrepared();\r\n    FieldIdItem item = fieldIds.get(ref);\r\n    if (item == null) {\r\n        throw new IllegalArgumentException(\"not found\");\r\n    }\r\n    return item.getIndex();\r\n}"
}, {
	"Path": "com.android.dx.dex.code.CatchHandlerList.toHuman",
	"Comment": "get the human form of this instance, prefixed on each linewith the string.",
	"Method": "String toHuman(String toHuman,String prefix,String header){\r\n    StringBuilder sb = new StringBuilder(100);\r\n    int size = size();\r\n    sb.append(prefix);\r\n    sb.append(header);\r\n    sb.append(\"catch \");\r\n    for (int i = 0; i < size; i++) {\r\n        Entry entry = get(i);\r\n        if (i != 0) {\r\n            sb.append(\",\\n\");\r\n            sb.append(prefix);\r\n            sb.append(\"  \");\r\n        }\r\n        if ((i == (size - 1)) && catchesAll()) {\r\n            sb.append(\"<any>\");\r\n        } else {\r\n            sb.append(entry.getExceptionType().toHuman());\r\n        }\r\n        sb.append(\" -> \");\r\n        sb.append(Hex.u2or4(entry.getHandler()));\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.RecordingProjectFileHashCache.isSymlinkInternalToKnownCellRoots",
	"Comment": "returns true if symlinks resolves to a target inside the known cell roots, and false if itpoints outside of all known cell root.",
	"Method": "boolean isSymlinkInternalToKnownCellRoots(Path relPath){\r\n    return getCellRootForAbsolutePath(findSafeRealPath(projectFilesystem.resolve(relPath))).isPresent();\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.AbstractConsoleEventBusListener.getWorkingTimeFromLastStartUntilNow",
	"Comment": "takes a collection of start and finished events. if there are any events that have a start, butno finished time, the collection is considered ongoing.",
	"Method": "long getWorkingTimeFromLastStartUntilNow(Collection<EventPair> eventPairs,long currentMillis){\r\n    long latestTimestamp = 0L;\r\n    long earliestOngoingStart = Long.MAX_VALUE;\r\n    boolean anyEventIsOngoing = false;\r\n    for (EventPair pair : eventPairs) {\r\n        if (pair.isOngoing()) {\r\n            anyEventIsOngoing = true;\r\n            if (pair.getStartTime() < earliestOngoingStart) {\r\n                latestTimestamp = pair.getStartTime();\r\n            }\r\n        } else if (pair.getEndTime() > latestTimestamp) {\r\n            latestTimestamp = pair.getEndTime();\r\n        }\r\n    }\r\n    return anyEventIsOngoing ? currentMillis - latestTimestamp : -1;\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.SuperConsoleEventBusListener.stopRenderScheduler",
	"Comment": "shuts down the thread pool and cancels the fixed interval runnable.",
	"Method": "void stopRenderScheduler(){\r\n    LOG.debug(\"Stopping render scheduler\");\r\n    renderScheduler.shutdownNow();\r\n}"
}, {
	"Path": "com.android.dx.dex.code.OutputFinisher.reverseBranch",
	"Comment": "reverses a branch which is buried a given number of instructionsbackward in the output. it is illegal to call this unless theindicated instruction really is a reversible branch.",
	"Method": "void reverseBranch(int which,CodeAddress newTarget){\r\n    int size = insns.size();\r\n    int index = size - which - 1;\r\n    TargetInsn targetInsn;\r\n    try {\r\n        targetInsn = (TargetInsn) insns.get(index);\r\n    } catch (IndexOutOfBoundsException ex) {\r\n        throw new IllegalArgumentException(\"too few instructions\");\r\n    } catch (ClassCastException ex) {\r\n        throw new IllegalArgumentException(\"non-reversible instruction\");\r\n    }\r\n    insns.set(index, targetInsn.withNewTargetAndReversed(newTarget));\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.CxxDescriptionEnhancer.resolveCxxSources",
	"Comment": "resolve the map of names to sourcepaths to a map of names to cxxsource objects.",
	"Method": "ImmutableMap<String, CxxSource> resolveCxxSources(ImmutableMap<String, SourceWithFlags> sources){\r\n    ImmutableMap.Builder<String, CxxSource> cxxSources = ImmutableMap.builder();\r\n    for (ImmutableMap.Entry<String, SourceWithFlags> ent : sources.entrySet()) {\r\n        String extension = Files.getFileExtension(ent.getKey());\r\n        Optional<CxxSource.Type> type = CxxSource.Type.fromExtension(extension);\r\n        if (!type.isPresent()) {\r\n            throw new HumanReadableException(\"invalid extension \\\"%s\\\": %s\", extension, ent.getKey());\r\n        }\r\n        cxxSources.put(ent.getKey(), CxxSource.of(type.get(), ent.getValue().getSourcePath(), ent.getValue().getFlags()));\r\n    }\r\n    return cxxSources.build();\r\n}"
}, {
	"Path": "com.android.dx.dex.file.Section.align",
	"Comment": "aligns the output of the given data to the alignment of this instance.",
	"Method": "void align(AnnotatedOutput out){\r\n    out.alignTo(alignment);\r\n}"
}, {
	"Path": "com.facebook.buck.parser.DaemonicParserState.getOrCreateNodeCache",
	"Comment": "retrieve the cache view for caching a particular type.note that the output type is not constrained to the type of the class object to allow fortypes with generics. care should be taken to ensure that the correct class object is passed in.",
	"Method": "PipelineNodeCache.Cache<BuildTarget, T> getOrCreateNodeCache(Class<?> cacheType){\r\n    try {\r\n        return (PipelineNodeCache.Cache<BuildTarget, T>) typedNodeCaches.get(cacheType);\r\n    } catch (ExecutionException e) {\r\n        throw new IllegalStateException(\"typedNodeCaches CacheLoader should not throw.\", e);\r\n    }\r\n}"
}, {
	"Path": "com.android.common.utils.Pair.of",
	"Comment": "constructs a new pair of the given two objects, inferring generic types.",
	"Method": "Pair<S, T> of(S first,T second){\r\n    return new Pair<S, T>(first, second);\r\n}"
}, {
	"Path": "com.facebook.buck.util.MoreThrowables.getThrowableOrigin",
	"Comment": "returns string representing class, method, filename and line number that throwable was thrownfrom",
	"Method": "String getThrowableOrigin(Throwable throwable){\r\n    StackTraceElement[] stack = throwable.getStackTrace();\r\n    Preconditions.checkState(stack.length > 0);\r\n    StackTraceElement element = stack[0];\r\n    return element.toString();\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.abi.source.api.ErrorSuppressingDiagnosticListener.getLog",
	"Comment": "gets the current log object, since the log and the context change for each round of annotationprocessing.",
	"Method": "Object getLog(){\r\n    try {\r\n        Object context = Objects.requireNonNull(contextField).get(task);\r\n        return Objects.requireNonNull(instanceMethod).invoke(null, context);\r\n    } catch (IllegalAccessException | InvocationTargetException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.parser.cache.impl.FakeManifestService.fetchManifest",
	"Comment": "fetch the current value of the manifest. an empty list is returned if no value is present.",
	"Method": "ListenableFuture<Manifest> fetchManifest(String manifestKey){\r\n    Manifest manifest = new Manifest();\r\n    manifest.setKey(manifestKey);\r\n    List<ByteBuffer> storedValues = fingerprints.get(manifestKey);\r\n    if (storedValues == null) {\r\n        storedValues = ImmutableList.of();\r\n    }\r\n    manifest.setValues(storedValues);\r\n    return Futures.immediateFuture(manifest);\r\n}"
}, {
	"Path": "com.facebook.buck.features.haskell.HaskellDescriptionUtils.createCompileRule",
	"Comment": "create a haskell compile rule that compiles all the given haskell sources in one step and pullsinterface files from all transitive haskell dependencies.",
	"Method": "HaskellCompileRule createCompileRule(BuildTarget target,ProjectFilesystem projectFilesystem,BuildRuleParams baseParams,ActionGraphBuilder graphBuilder,SourcePathRuleFinder ruleFinder,ImmutableSet<BuildRule> deps,HaskellPlatform platform,Linker.LinkableDepType depType,boolean hsProfile,Optional<String> main,Optional<HaskellPackageInfo> packageInfo,ImmutableList<String> flags,HaskellSources sources){\r\n    CxxPlatform cxxPlatform = platform.getCxxPlatform();\r\n    Map<BuildTarget, ImmutableList<String>> depFlags = new TreeMap();\r\n    Map<BuildTarget, ImmutableList<SourcePath>> depIncludes = new TreeMap();\r\n    ImmutableSortedMap.Builder<String, HaskellPackage> exposedPackagesBuilder = ImmutableSortedMap.naturalOrder();\r\n    ImmutableSortedMap.Builder<String, HaskellPackage> packagesBuilder = ImmutableSortedMap.naturalOrder();\r\n    new AbstractBreadthFirstTraversal<BuildRule>(deps) {\r\n        private final ImmutableSet<BuildRule> empty = ImmutableSet.of();\r\n        @Override\r\n        public Iterable<BuildRule> visit(BuildRule rule) {\r\n            Iterable<BuildRule> ruleDeps = empty;\r\n            if (rule instanceof HaskellCompileDep) {\r\n                HaskellCompileDep haskellCompileDep = (HaskellCompileDep) rule;\r\n                ruleDeps = haskellCompileDep.getCompileDeps(platform);\r\n                HaskellCompileInput compileInput = haskellCompileDep.getCompileInput(platform, depType, hsProfile);\r\n                depFlags.put(rule.getBuildTarget(), compileInput.getFlags());\r\n                depIncludes.put(rule.getBuildTarget(), compileInput.getIncludes());\r\n                boolean firstOrderDep = deps.contains(rule);\r\n                for (HaskellPackage pkg : compileInput.getPackages()) {\r\n                    if (firstOrderDep) {\r\n                        exposedPackagesBuilder.put(pkg.getInfo().getIdentifier(), pkg);\r\n                    } else {\r\n                        packagesBuilder.put(pkg.getInfo().getIdentifier(), pkg);\r\n                    }\r\n                }\r\n            }\r\n            return ruleDeps;\r\n        }\r\n    }.start();\r\n    Collection<CxxPreprocessorInput> cxxPreprocessorInputs = CxxPreprocessables.getTransitiveCxxPreprocessorInput(cxxPlatform, graphBuilder, deps);\r\n    ExplicitCxxToolFlags.Builder toolFlagsBuilder = CxxToolFlags.explicitBuilder();\r\n    PreprocessorFlags.Builder ppFlagsBuilder = PreprocessorFlags.builder();\r\n    toolFlagsBuilder.setPlatformFlags(StringArg.from(CxxSourceTypes.getPlatformPreprocessFlags(cxxPlatform, CxxSource.Type.C)));\r\n    for (CxxPreprocessorInput input : cxxPreprocessorInputs) {\r\n        ppFlagsBuilder.addAllIncludes(input.getIncludes());\r\n        ppFlagsBuilder.addAllFrameworkPaths(input.getFrameworks());\r\n        toolFlagsBuilder.addAllRuleFlags(input.getPreprocessorFlags().get(CxxSource.Type.C));\r\n    }\r\n    ppFlagsBuilder.setOtherFlags(toolFlagsBuilder.build());\r\n    PreprocessorFlags ppFlags = ppFlagsBuilder.build();\r\n    ImmutableList<String> compileFlags = ImmutableList.<String>builder().addAll(platform.getCompilerFlags()).addAll(flags).addAll(Iterables.concat(depFlags.values())).build();\r\n    ImmutableList<SourcePath> includes = ImmutableList.copyOf(Iterables.concat(depIncludes.values()));\r\n    ImmutableSortedMap<String, HaskellPackage> exposedPackages = exposedPackagesBuilder.build();\r\n    ImmutableSortedMap<String, HaskellPackage> packages = packagesBuilder.build();\r\n    return HaskellCompileRule.from(target, projectFilesystem, baseParams, ruleFinder, platform.getCompiler().resolve(graphBuilder), platform.getHaskellVersion(), compileFlags, ppFlags, cxxPlatform, depType == Linker.LinkableDepType.STATIC ? PicType.PDC : PicType.PIC, hsProfile, main, packageInfo, includes, exposedPackages, packages, sources, CxxSourceTypes.getPreprocessor(cxxPlatform, CxxSource.Type.C).resolve(graphBuilder));\r\n}"
}, {
	"Path": "com.facebook.buck.features.haskell.HaskellDescriptionUtils.createCompileRule",
	"Comment": "create a haskell compile rule that compiles all the given haskell sources in one step and pullsinterface files from all transitive haskell dependencies.",
	"Method": "HaskellCompileRule createCompileRule(BuildTarget target,ProjectFilesystem projectFilesystem,BuildRuleParams baseParams,ActionGraphBuilder graphBuilder,SourcePathRuleFinder ruleFinder,ImmutableSet<BuildRule> deps,HaskellPlatform platform,Linker.LinkableDepType depType,boolean hsProfile,Optional<String> main,Optional<HaskellPackageInfo> packageInfo,ImmutableList<String> flags,HaskellSources sources){\r\n    Iterable<BuildRule> ruleDeps = empty;\r\n    if (rule instanceof HaskellCompileDep) {\r\n        HaskellCompileDep haskellCompileDep = (HaskellCompileDep) rule;\r\n        ruleDeps = haskellCompileDep.getCompileDeps(platform);\r\n        HaskellCompileInput compileInput = haskellCompileDep.getCompileInput(platform, depType, hsProfile);\r\n        depFlags.put(rule.getBuildTarget(), compileInput.getFlags());\r\n        depIncludes.put(rule.getBuildTarget(), compileInput.getIncludes());\r\n        boolean firstOrderDep = deps.contains(rule);\r\n        for (HaskellPackage pkg : compileInput.getPackages()) {\r\n            if (firstOrderDep) {\r\n                exposedPackagesBuilder.put(pkg.getInfo().getIdentifier(), pkg);\r\n            } else {\r\n                packagesBuilder.put(pkg.getInfo().getIdentifier(), pkg);\r\n            }\r\n        }\r\n    }\r\n    return ruleDeps;\r\n}"
}, {
	"Path": "com.facebook.buck.parser.cache.impl.FakeManifestService.appendToManifest",
	"Comment": "appends one more entry to the manifest. creates a new one if it does not already exist.",
	"Method": "ListenableFuture<Void> appendToManifest(Manifest manifest){\r\n    return addToManifestBackingCollection(manifest);\r\n}"
}, {
	"Path": "com.android.common.sdklib.AndroidVersion.equals",
	"Comment": "returns true if the androidversion is an api level equals toapilevel.",
	"Method": "boolean equals(int apiLevel,boolean equals,Object obj){\r\n    if (!(obj instanceof AndroidVersion)) {\r\n        return false;\r\n    }\r\n    AndroidVersion other = (AndroidVersion) obj;\r\n    return mApiLevel == other.mApiLevel && Objects.equal(mCodename, other.mCodename);\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.DefaultJavaLibraryTest.testBuildInternalWithAndroidBootclasspath",
	"Comment": "make sure that when isandroidlibrary is true, that the android bootclasspath is used.",
	"Method": "void testBuildInternalWithAndroidBootclasspath(){\r\n    String folder = \"android/java/src/com/facebook\";\r\n    tmp.newFolder(folder.split(\"/\"));\r\n    BuildTarget buildTarget = BuildTargetFactory.newInstance(\"//\" + folder + \":fb\");\r\n    Path src = Paths.get(folder, \"Main.java\");\r\n    tmp.newFile(src.toString());\r\n    DefaultJavaLibrary libraryRule = AndroidLibraryBuilder.createBuilder(buildTarget).addSrc(src).build(graphBuilder);\r\n    DefaultJavaLibrary javaLibrary = libraryRule;\r\n    BuildContext context = createBuildContext();\r\n    List<Step> steps = javaLibrary.getBuildSteps(context, new FakeBuildableContext());\r\n    JavacStep javac = getJavacStep(steps);\r\n    assertEquals(\"Should compile Main.java rather than generated R.java.\", ImmutableSet.of(src), javac.getSrcs());\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.RemoteExecutionStorageService.createFetchResponseHandler",
	"Comment": "creates a responsehandler for the remoteexecutionfetch hybrid thrift request.",
	"Method": "HybridThriftResponseHandler<FrontendResponse> createFetchResponseHandler(OutputStream outputStream){\r\n    return new HybridThriftResponseHandler<FrontendResponse>(new FrontendResponse()) {\r\n        @Override\r\n        public void onResponseParsed() throws IOException {\r\n            FrontendResponse response = getResponse();\r\n            validateResponseOrThrow(response);\r\n        }\r\n        @Override\r\n        public int getTotalPayloads() {\r\n            int numberOfPayloads = getResponse().getRemoteExecutionFetchResponse().getDigestsSize();\r\n            Preconditions.checkState(1 == numberOfPayloads, \"Expected to only receive one payload but got [%d] instead.\", numberOfPayloads);\r\n            return numberOfPayloads;\r\n        }\r\n        @Override\r\n        public long getPayloadSizeBytes(int payloadIndex) {\r\n            DigestAndContent digestAndContent = getResponse().getRemoteExecutionFetchResponse().getDigests().get(payloadIndex);\r\n            Preconditions.checkState(!digestAndContent.isSetContent(), \"Unexpected inlined content from the server for digest [%s:%s].\", digestAndContent.digest.hash, digestAndContent.digest.sizeBytes);\r\n            return digestAndContent.getDigest().getSizeBytes();\r\n        }\r\n        @Override\r\n        public OutputStream getStreamForPayload(int payloadIndex) {\r\n            return outputStream;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.RemoteExecutionStorageService.createFetchResponseHandler",
	"Comment": "creates a responsehandler for the remoteexecutionfetch hybrid thrift request.",
	"Method": "HybridThriftResponseHandler<FrontendResponse> createFetchResponseHandler(OutputStream outputStream){\r\n    FrontendResponse response = getResponse();\r\n    validateResponseOrThrow(response);\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.RemoteExecutionStorageService.createFetchResponseHandler",
	"Comment": "creates a responsehandler for the remoteexecutionfetch hybrid thrift request.",
	"Method": "HybridThriftResponseHandler<FrontendResponse> createFetchResponseHandler(OutputStream outputStream){\r\n    int numberOfPayloads = getResponse().getRemoteExecutionFetchResponse().getDigestsSize();\r\n    Preconditions.checkState(1 == numberOfPayloads, \"Expected to only receive one payload but got [%d] instead.\", numberOfPayloads);\r\n    return numberOfPayloads;\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.RemoteExecutionStorageService.createFetchResponseHandler",
	"Comment": "creates a responsehandler for the remoteexecutionfetch hybrid thrift request.",
	"Method": "HybridThriftResponseHandler<FrontendResponse> createFetchResponseHandler(OutputStream outputStream){\r\n    DigestAndContent digestAndContent = getResponse().getRemoteExecutionFetchResponse().getDigests().get(payloadIndex);\r\n    Preconditions.checkState(!digestAndContent.isSetContent(), \"Unexpected inlined content from the server for digest [%s:%s].\", digestAndContent.digest.hash, digestAndContent.digest.sizeBytes);\r\n    return digestAndContent.getDigest().getSizeBytes();\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.RemoteExecutionStorageService.createFetchResponseHandler",
	"Comment": "creates a responsehandler for the remoteexecutionfetch hybrid thrift request.",
	"Method": "HybridThriftResponseHandler<FrontendResponse> createFetchResponseHandler(OutputStream outputStream){\r\n    return outputStream;\r\n}"
}, {
	"Path": "com.android.common.xml.AndroidManifest.getTestFunctionalTestXPath",
	"Comment": "returns the xpath expression for the instrumentation functiontest",
	"Method": "String getTestFunctionalTestXPath(){\r\n    return \"/\" + NODE_MANIFEST + \"/\" + NODE_INSTRUMENTATION + \"/@\" + AndroidXPathFactory.DEFAULT_NS_PREFIX + \":\" + ATTRIBUTE_FUNCTIONAL_TEST;\r\n}"
}, {
	"Path": "com.facebook.buck.features.haskell.HaskellGhciDescription.isPrebuiltSO",
	"Comment": "whether the nativelinkable should be linked shared or othewise",
	"Method": "boolean isPrebuiltSO(NativeLinkable nativeLinkable,CxxPlatform cxxPlatform,ActionGraphBuilder graphBuilder){\r\n    if (nativeLinkable instanceof PrebuiltCxxLibraryGroupDescription.CustomPrebuiltCxxLibrary) {\r\n        return true;\r\n    }\r\n    if (!(nativeLinkable instanceof PrebuiltCxxLibrary)) {\r\n        return false;\r\n    }\r\n    ImmutableMap<String, SourcePath> sharedLibraries = nativeLinkable.getSharedLibraries(cxxPlatform, graphBuilder);\r\n    for (Map.Entry<String, SourcePath> ent : sharedLibraries.entrySet()) {\r\n        if (!(ent.getValue() instanceof PathSourcePath)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.facebook.buck.sandbox.darwin.DarwinSandbox.createProfileFileFromConfiguration",
	"Comment": "converts sandbox to darwin sandbox profile and writes it to a file.",
	"Method": "void createProfileFileFromConfiguration(Path sandboxProfilePath,SandboxProperties sandboxConfiguration){\r\n    Collection<String> profileContent = generateSandboxProfileContent(sandboxConfiguration);\r\n    Files.write(sandboxProfilePath, profileContent);\r\n}"
}, {
	"Path": "com.facebook.buck.junit.testdata.build_then_test.AbstractClassWithTests.test",
	"Comment": "this test method should not be run since the class is abstract and cannot be instantiated.",
	"Method": "void test(){\r\n    throw new IllegalStateException(\"Attempt to call test declared in abstract class.\");\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.AbstractWorkspace.replaceFileContents",
	"Comment": "replaces all instances of target with replacement at the given path",
	"Method": "boolean replaceFileContents(String pathRelativeToWorkspaceRoot,String target,String replacement){\r\n    String fileContents = getFileContents(pathRelativeToWorkspaceRoot);\r\n    String newFileContents = fileContents.replace(target, replacement);\r\n    writeContentsToPath(newFileContents, pathRelativeToWorkspaceRoot);\r\n    return !newFileContents.equals(fileContents);\r\n}"
}, {
	"Path": "com.facebook.buck.shell.WorkerShellStep.getEnvironmentVariables",
	"Comment": "returns the environment variables to use when expanding the job arguments that get sent to theprocess.by default, this method returns an empty map.",
	"Method": "ImmutableMap<String, String> getEnvironmentVariables(){\r\n    return ImmutableMap.of();\r\n}"
}, {
	"Path": "com.facebook.buck.features.project.intellij.BaseIjModuleRule.getSourceFoldersToInputsIndex",
	"Comment": "calculate the set of directories containing inputs to the target.",
	"Method": "ImmutableMultimap<Path, Path> getSourceFoldersToInputsIndex(ImmutableCollection<Path> paths){\r\n    Path defaultParent = Paths.get(\"\");\r\n    return paths.stream().collect(ImmutableListMultimap.toImmutableListMultimap(path -> {\r\n        Path parent = path.getParent();\r\n        return parent == null ? defaultParent : parent;\r\n    }, path -> path));\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.CxxLibraryFactory.createSharedLibrary",
	"Comment": "create all build rules needed to generate the shared library.",
	"Method": "CxxLink createSharedLibrary(BuildTarget buildTargetMaybeWithLinkerMapMode,ProjectFilesystem projectFilesystem,ActionGraphBuilder graphBuilder,SourcePathResolver pathResolver,SourcePathRuleFinder ruleFinder,CellPathResolver cellRoots,CxxBuckConfig cxxBuckConfig,CxxPlatform cxxPlatform,CxxLibraryDescriptionArg args,ImmutableSet<BuildRule> deps,ImmutableList<StringWithMacros> linkerFlags,ImmutableList<StringWithMacros> postLinkerFlags,ImmutableSet<FrameworkPath> frameworks,ImmutableSet<FrameworkPath> libraries,Optional<String> soname,Optional<Linker.CxxRuntimeType> cxxRuntimeType,Linker.LinkType linkType,Linker.LinkableDepType linkableDepType,Optional<SourcePath> bundleLoader,ImmutableSet<BuildTarget> blacklist,CxxLibraryDescription.TransitiveCxxPreprocessorInputFunction transitiveCxxPreprocessorInputFunction,Optional<CxxLibraryDescriptionDelegate> delegate){\r\n    BuildTarget buildTargetWithoutLinkerMapMode = LinkerMapMode.removeLinkerMapModeFlavorInTarget(buildTargetMaybeWithLinkerMapMode, LinkerMapMode.FLAVOR_DOMAIN.getValue(buildTargetMaybeWithLinkerMapMode));\r\n    ImmutableList<SourcePath> objects = requireObjects(buildTargetWithoutLinkerMapMode, projectFilesystem, graphBuilder, pathResolver, ruleFinder, cellRoots, cxxBuckConfig, cxxPlatform, cxxPlatform.getPicTypeForSharedLinking(), args, deps, transitiveCxxPreprocessorInputFunction, delegate);\r\n    BuildTarget sharedTarget = CxxDescriptionEnhancer.createSharedLibraryBuildTarget(buildTargetMaybeWithLinkerMapMode, cxxPlatform.getFlavor(), linkType);\r\n    String sharedLibrarySoname = CxxDescriptionEnhancer.getSharedLibrarySoname(soname, buildTargetMaybeWithLinkerMapMode, cxxPlatform);\r\n    Path sharedLibraryPath = CxxDescriptionEnhancer.getSharedLibraryPath(projectFilesystem, sharedTarget, sharedLibrarySoname);\r\n    ImmutableList<NativeLinkable> delegateNativeLinkables = delegate.flatMap(d -> d.getNativeLinkableExportedDeps(sharedTarget, graphBuilder, cxxPlatform)).orElse(ImmutableList.of());\r\n    ImmutableList<NativeLinkable> allNativeLinkables = RichStream.from(deps).filter(NativeLinkable.class).concat(RichStream.from(delegateNativeLinkables)).toImmutableList();\r\n    CxxLinkOptions linkOptions = CxxLinkOptions.of(args.getThinLto());\r\n    return CxxLinkableEnhancer.createCxxLinkableBuildRule(cxxBuckConfig, cxxPlatform, projectFilesystem, graphBuilder, pathResolver, ruleFinder, sharedTarget, linkType, Optional.of(sharedLibrarySoname), sharedLibraryPath, args.getLinkerExtraOutputs(), linkableDepType, linkOptions, allNativeLinkables, cxxRuntimeType, bundleLoader, blacklist, ImmutableSet.of(), NativeLinkableInput.builder().addAllArgs(RichStream.from(linkerFlags).map(f -> CxxDescriptionEnhancer.toStringWithMacrosArgs(sharedTarget, cellRoots, graphBuilder, cxxPlatform, f)).toImmutableList()).addAllArgs(SourcePathArg.from(objects)).addAllArgs(RichStream.from(postLinkerFlags).map(f -> CxxDescriptionEnhancer.toStringWithMacrosArgs(sharedTarget, cellRoots, graphBuilder, cxxPlatform, f)).toImmutableList()).setFrameworks(frameworks).setLibraries(libraries).build(), Optional.empty(), cellRoots);\r\n}"
}, {
	"Path": "com.facebook.buck.httpserver.Responses.writeResponse",
	"Comment": "writes the specified content to the response with the specified status code.",
	"Method": "void writeResponse(String content,MediaType mediaType,Request baseRequest,HttpServletResponse response,int status){\r\n    response.setContentType(mediaType.toString());\r\n    response.setStatus(status);\r\n    response.getWriter().write(content);\r\n    response.flushBuffer();\r\n    baseRequest.setHandled(true);\r\n}"
}, {
	"Path": "com.android.dx.dex.file.DexFile.getStatistics",
	"Comment": "generates and returns statistics for all the items in the file.",
	"Method": "Statistics getStatistics(){\r\n    Statistics stats = new Statistics();\r\n    for (Section s : sections) {\r\n        stats.addAll(s);\r\n    }\r\n    return stats;\r\n}"
}, {
	"Path": "com.facebook.buck.remoteexecution.util.OutOfProcessIsolatedExecutionClients.create",
	"Comment": "returns a remoteexecution implementation that uses a local cas and a separate local temporarydirectory for execution.",
	"Method": "OutOfProcessIsolatedExecutionClients create(Protocol protocol,BuckEventBus eventBus){\r\n    return new OutOfProcessIsolatedExecutionClients(protocol, eventBus);\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.RuleKeyDivergenceRunnerFactory.createRunner",
	"Comment": "creates distbuildmoderunner to be used for rule key divergence checks",
	"Method": "DistBuildModeRunner createRunner(StampedeId stampedeId,BuildSlaveRunId buildSlaveRunId,Clock clock,DistBuildService distBuildService,DelegateAndGraphsInitializer initializer,RuleKeyConfiguration ruleKeyConfiguration,RuleKeyCacheScope<RuleKey> ruleKeyCacheScope,WeightedListeningExecutorService executorService,BuckEventBus eventBus,DistBuildState state,Cell rootCell){\r\n    return new AbstractDistBuildModeRunner() {\r\n        @Override\r\n        public ListenableFuture<?> getAsyncPrepFuture() {\r\n            return Futures.immediateFuture(null);\r\n        }\r\n        @Override\r\n        public ExitCode runAndReturnExitCode(HeartbeatService heartbeatService) throws IOException, InterruptedException {\r\n            try (Closer closer = Closer.create()) {\r\n                closer.register(heartbeatService.addCallback(\"ReportCoordinatorAlive\", createHeartbeatCallback(stampedeId, distBuildService)));\r\n                try {\r\n                    List<Pair<BuildRule, RuleKey>> rulesAndKeys = calculateDefaultRuleKeys(getTopLevelTargetsToBuild(state, rootCell), initializer, ruleKeyConfiguration, ruleKeyCacheScope, executorService, eventBus);\r\n                    List<BuildSlaveEvent> ruleKeyCalculatedEvents = rulesAndKeys.stream().map(rk -> {\r\n                        RuleKeyCalculatedEvent event = new RuleKeyCalculatedEvent();\r\n                        event.setBuildTarget(rk.getFirst().getFullyQualifiedName());\r\n                        event.setDefaultRuleKey(rk.getSecond().getHashCode().toString());\r\n                        BuildSlaveEvent buildSlaveEvent = new BuildSlaveEvent();\r\n                        buildSlaveEvent.setEventType(BuildSlaveEventType.RULE_KEY_CALCULATED_EVENT);\r\n                        buildSlaveEvent.setRuleKeyCalculatedEvent(event);\r\n                        return buildSlaveEvent;\r\n                    }).collect(Collectors.toList());\r\n                    List<List<BuildSlaveEvent>> ruleKeyCalculationBatches = Lists.partition(ruleKeyCalculatedEvents, RULE_CALCULATION_EVENTS_PER_FRONTEND_REQUEST);\r\n                    for (List<BuildSlaveEvent> ruleKeyCalculateBatch : ruleKeyCalculationBatches) {\r\n                        distBuildService.uploadBuildSlaveEvents(stampedeId, buildSlaveRunId, ruleKeyCalculateBatch);\r\n                    }\r\n                    distBuildService.sendAllBuildRulesPublishedEvent(stampedeId, buildSlaveRunId, clock.currentTimeMillis());\r\n                    distBuildService.setFinalBuildStatus(stampedeId, BuildStatus.FINISHED_SUCCESSFULLY, \"Rule key divergence check complete\");\r\n                    return ExitCode.SUCCESS;\r\n                } catch (ExecutionException | IOException e) {\r\n                    LOG.error(e, \"Failed to calculate rule keys\");\r\n                    distBuildService.setFinalBuildStatus(stampedeId, BuildStatus.FAILED, \"Could not compute or publish rule keys\");\r\n                    return ExitCode.FATAL_GENERIC;\r\n                }\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.RuleKeyDivergenceRunnerFactory.createRunner",
	"Comment": "creates distbuildmoderunner to be used for rule key divergence checks",
	"Method": "DistBuildModeRunner createRunner(StampedeId stampedeId,BuildSlaveRunId buildSlaveRunId,Clock clock,DistBuildService distBuildService,DelegateAndGraphsInitializer initializer,RuleKeyConfiguration ruleKeyConfiguration,RuleKeyCacheScope<RuleKey> ruleKeyCacheScope,WeightedListeningExecutorService executorService,BuckEventBus eventBus,DistBuildState state,Cell rootCell){\r\n    return Futures.immediateFuture(null);\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.RuleKeyDivergenceRunnerFactory.createRunner",
	"Comment": "creates distbuildmoderunner to be used for rule key divergence checks",
	"Method": "DistBuildModeRunner createRunner(StampedeId stampedeId,BuildSlaveRunId buildSlaveRunId,Clock clock,DistBuildService distBuildService,DelegateAndGraphsInitializer initializer,RuleKeyConfiguration ruleKeyConfiguration,RuleKeyCacheScope<RuleKey> ruleKeyCacheScope,WeightedListeningExecutorService executorService,BuckEventBus eventBus,DistBuildState state,Cell rootCell){\r\n    try (Closer closer = Closer.create()) {\r\n        closer.register(heartbeatService.addCallback(\"ReportCoordinatorAlive\", createHeartbeatCallback(stampedeId, distBuildService)));\r\n        try {\r\n            List<Pair<BuildRule, RuleKey>> rulesAndKeys = calculateDefaultRuleKeys(getTopLevelTargetsToBuild(state, rootCell), initializer, ruleKeyConfiguration, ruleKeyCacheScope, executorService, eventBus);\r\n            List<BuildSlaveEvent> ruleKeyCalculatedEvents = rulesAndKeys.stream().map(rk -> {\r\n                RuleKeyCalculatedEvent event = new RuleKeyCalculatedEvent();\r\n                event.setBuildTarget(rk.getFirst().getFullyQualifiedName());\r\n                event.setDefaultRuleKey(rk.getSecond().getHashCode().toString());\r\n                BuildSlaveEvent buildSlaveEvent = new BuildSlaveEvent();\r\n                buildSlaveEvent.setEventType(BuildSlaveEventType.RULE_KEY_CALCULATED_EVENT);\r\n                buildSlaveEvent.setRuleKeyCalculatedEvent(event);\r\n                return buildSlaveEvent;\r\n            }).collect(Collectors.toList());\r\n            List<List<BuildSlaveEvent>> ruleKeyCalculationBatches = Lists.partition(ruleKeyCalculatedEvents, RULE_CALCULATION_EVENTS_PER_FRONTEND_REQUEST);\r\n            for (List<BuildSlaveEvent> ruleKeyCalculateBatch : ruleKeyCalculationBatches) {\r\n                distBuildService.uploadBuildSlaveEvents(stampedeId, buildSlaveRunId, ruleKeyCalculateBatch);\r\n            }\r\n            distBuildService.sendAllBuildRulesPublishedEvent(stampedeId, buildSlaveRunId, clock.currentTimeMillis());\r\n            distBuildService.setFinalBuildStatus(stampedeId, BuildStatus.FINISHED_SUCCESSFULLY, \"Rule key divergence check complete\");\r\n            return ExitCode.SUCCESS;\r\n        } catch (ExecutionException | IOException e) {\r\n            LOG.error(e, \"Failed to calculate rule keys\");\r\n            distBuildService.setFinalBuildStatus(stampedeId, BuildStatus.FAILED, \"Could not compute or publish rule keys\");\r\n            return ExitCode.FATAL_GENERIC;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.manifmerger.XmlElement.getLeadingComments",
	"Comment": "returns all leading comments in the source xml before the node to be adopted.",
	"Method": "List<Node> getLeadingComments(Node nodeToBeAdopted){\r\n    @NonNull\r\n    ImmutableList.Builder<Node> nodesToAdopt = new ImmutableList.Builder<Node>();\r\n    Node previousSibling = nodeToBeAdopted.getPreviousSibling();\r\n    while (previousSibling != null && (previousSibling.getNodeType() == Node.COMMENT_NODE || previousSibling.getNodeType() == Node.TEXT_NODE)) {\r\n        if (previousSibling.getNodeType() == Node.COMMENT_NODE) {\r\n            nodesToAdopt.add(previousSibling);\r\n        }\r\n        previousSibling = previousSibling.getPreviousSibling();\r\n    }\r\n    return nodesToAdopt.build().reverse();\r\n}"
}, {
	"Path": "com.android.manifmerger.PostValidator.validateAttributes",
	"Comment": "verifies that all merging attributes on a passed xml element were applied.",
	"Method": "void validateAttributes(XmlElement xmlElement,Actions actions,MergingReport.Builder mergingReport){\r\n    @NonNull\r\n    Collection<Map.Entry<XmlNode.NodeName, AttributeOperationType>> attributeOperations = xmlElement.getAttributeOperations();\r\n    for (Map.Entry<XmlNode.NodeName, AttributeOperationType> attributeOperation : attributeOperations) {\r\n        switch(attributeOperation.getValue()) {\r\n            case REMOVE:\r\n                if (!isAttributeOperationPresent(xmlElement, attributeOperation, actions, ActionType.REJECTED)) {\r\n                    xmlElement.addMessage(mergingReport, MergingReport.Record.Severity.WARNING, String.format(\"%1$s@%2$s was tagged at %3$s:%4$d to remove other\" + \" declarations but no other declaration present\", xmlElement.getId(), attributeOperation.getKey(), xmlElement.getDocument().getSourceFile().print(true), xmlElement.getPosition().getStartLine() + 1));\r\n                }\r\n                break;\r\n            case REPLACE:\r\n                if (!isAttributeOperationPresent(xmlElement, attributeOperation, actions, ActionType.REJECTED)) {\r\n                    xmlElement.addMessage(mergingReport, MergingReport.Record.Severity.WARNING, String.format(\"%1$s@%2$s was tagged at %3$s:%4$d to replace other\" + \" declarations but no other declaration present\", xmlElement.getId(), attributeOperation.getKey(), xmlElement.getDocument().getSourceFile().print(true), xmlElement.getPosition().getStartLine() + 1));\r\n                }\r\n                break;\r\n            default:\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.core.model.actiongraph.computation.ActionGraphProvider.compareActionGraphs",
	"Comment": "compares the cached actiongraph with a newly generated from the targetgraph. the comparison isdone by generating and comparing content agnostic rulekeys. in case of mismatch, themismatching buildrules are printed and the building process is stopped.",
	"Method": "void compareActionGraphs(ActionGraphAndBuilder lastActionGraphAndBuilder,TargetNodeToBuildRuleTransformer transformer,TargetGraph targetGraph,RuleKeyFieldLoader fieldLoader,Optional<ThriftRuleKeyLogger> ruleKeyLogger){\r\n    try (SimplePerfEvent.Scope scope = SimplePerfEvent.scope(eventBus, PerfEventId.of(\"ActionGraphCacheCheck\"))) {\r\n        LOG.info(\"ActionGraph integrity check spawned.\");\r\n        ActionGraphAndBuilder newActionGraph = createActionGraph(transformer, targetGraph, IncrementalActionGraphMode.DISABLED);\r\n        Map<BuildRule, RuleKey> lastActionGraphRuleKeys = getRuleKeysFromBuildRules(lastActionGraphAndBuilder.getActionGraph().getNodes(), lastActionGraphAndBuilder.getActionGraphBuilder(), fieldLoader, Optional.empty());\r\n        Map<BuildRule, RuleKey> newActionGraphRuleKeys = getRuleKeysFromBuildRules(newActionGraph.getActionGraph().getNodes(), newActionGraph.getActionGraphBuilder(), fieldLoader, ruleKeyLogger);\r\n        if (!lastActionGraphRuleKeys.equals(newActionGraphRuleKeys)) {\r\n            actionGraphCache.invalidateCache();\r\n            String mismatchInfo = \"RuleKeys of cached and new ActionGraph don't match:\\n\";\r\n            MapDifference<BuildRule, RuleKey> mismatchedRules = Maps.difference(lastActionGraphRuleKeys, newActionGraphRuleKeys);\r\n            mismatchInfo += \"Number of nodes in common/differing: \" + mismatchedRules.entriesInCommon().size() + \"/\" + mismatchedRules.entriesDiffering().size() + \"\\n\" + \"Entries only in the cached ActionGraph: \" + mismatchedRules.entriesOnlyOnLeft().size() + \"Entries only in the newly created ActionGraph: \" + mismatchedRules.entriesOnlyOnRight().size() + \"The rules that did not match:\\n\";\r\n            mismatchInfo += mismatchedRules.entriesDiffering().keySet().toString();\r\n            LOG.error(mismatchInfo);\r\n            throw new RuntimeException(mismatchInfo);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.cf.code.ExecutionStack.setLocal",
	"Comment": "flags the next value pushed onto the stack as having local info.",
	"Method": "void setLocal(){\r\n    throwIfImmutable();\r\n    local[stackPtr] = true;\r\n}"
}, {
	"Path": "com.android.dx.cf.code.Frame.adjustLocalsForSubroutines",
	"Comment": "adjusts a locals array to account for a merged subroutines list.if a frame merge results in, effectively, a subroutine return througha throw then the current locals will be a localsarrayset that willneed to be trimmed of all onelocalsarray elements that relevent tothe subroutine that is returning.",
	"Method": "LocalsArray adjustLocalsForSubroutines(LocalsArray locals,IntList subroutines){\r\n    if (!(locals instanceof LocalsArraySet)) {\r\n        return locals;\r\n    }\r\n    LocalsArraySet laSet = (LocalsArraySet) locals;\r\n    if (subroutines.size() == 0) {\r\n        return laSet.getPrimary();\r\n    }\r\n    return laSet;\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.ThriftCoordinatorClient.reportMinionAlive",
	"Comment": "reports back to the coordinator that the current minion is alive and healthy.",
	"Method": "void reportMinionAlive(String minionId,BuildSlaveRunId runId){\r\n    LOG.info(\"Sending ReportMinionAliveRequest.\");\r\n    Client checkedClient = checkThriftClientRunningOrThrow();\r\n    ReportMinionAliveRequest request = new ReportMinionAliveRequest().setMinionId(minionId).setStampedeId(stampedeId).setRunId(runId);\r\n    try {\r\n        checkedClient.reportMinionAlive(request);\r\n        LOG.info(\"Finished sending ReportMinionAliveRequest.\");\r\n    } catch (TException ex) {\r\n        throw handleTException(ex, \"ReportMinionAliveRequest\");\r\n    } catch (RuntimeException ex) {\r\n        throw handleRuntimeException(ex, \"ReportMinionAliveRequest\");\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.dex.file.TypeIdsSection.indexOf",
	"Comment": "gets the index of the given type, which must havebeen added to this instance.",
	"Method": "int indexOf(Type type,int indexOf,CstType type){\r\n    if (type == null) {\r\n        throw new NullPointerException(\"type == null\");\r\n    }\r\n    return indexOf(type.getClassType());\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.WindowsClangUtils.getCommandBuilder",
	"Comment": "returns a buck command builder for a unix platform, which runs programs through cmd",
	"Method": "ImmutableList.Builder<String> getCommandBuilder(){\r\n    ImmutableList.Builder<String> commandBuilder = ImmutableList.builder();\r\n    commandBuilder.add(\"cmd\").add(\"/c\");\r\n    return commandBuilder;\r\n}"
}, {
	"Path": "com.facebook.buck.cli.DefaultJavaPackageFinderTest.testNoPathsSpecified",
	"Comment": "if no paths are specified, then the project root should be considered a java source root.",
	"Method": "void testNoPathsSpecified(){\r\n    DefaultJavaPackageFinder javaPackageFinder = DefaultJavaPackageFinder.createDefaultJavaPackageFinder(ImmutableList.of());\r\n    assertEquals(Paths.get(\"\"), javaPackageFinder.findJavaPackageFolder(Paths.get(\"Base.java\")));\r\n    assertEquals(Paths.get(\"java/com/example/base/\"), javaPackageFinder.findJavaPackageFolder(Paths.get(\"java/com/example/base/Base.java\")));\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.endtoend.EndToEndHelper.getProperBuildTarget",
	"Comment": "given a fully qualified build target string, this will get the name for that target withappropriate flavours.",
	"Method": "String getProperBuildTarget(String target){\r\n    BuildTarget buildTarget = BuildTargetFactory.newInstance(target);\r\n    Optional<String> platformFlavorName = platformUtils.getFlavor();\r\n    if (platformFlavorName.isPresent()) {\r\n        Flavor platformFlavor = UserFlavor.of(platformFlavorName.get(), platformFlavorName.get());\r\n        buildTarget = buildTarget.withFlavors(platformFlavor);\r\n    }\r\n    return buildTarget.getFullyQualifiedName();\r\n}"
}, {
	"Path": "com.facebook.buck.util.concurrent.WorkThreadTrackingFuture.completedFuture",
	"Comment": "returns an instance already completed with the given value.",
	"Method": "WorkThreadTrackingFuture<T> completedFuture(T value){\r\n    return new WorkThreadTrackingCompletedFuture(value);\r\n}"
}, {
	"Path": "com.facebook.buck.skylark.parser.AbstractBuckGlobals.getBuckLoadContextGlobals",
	"Comment": "always disable implicit native imports in skylark rules, they should utilize native.foo",
	"Method": "Environment.GlobalFrame getBuckLoadContextGlobals(){\r\n    ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();\r\n    addBuckGlobals(builder);\r\n    builder.put(\"native\", getNativeModule());\r\n    builder.put(\"struct\", StructProvider.STRUCT);\r\n    Runtime.setupSkylarkLibrary(builder, new SkylarkRuleFunctions());\r\n    return GlobalFrame.createForBuiltins(builder.build());\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.toolchain.objectfile.Machos.relativizeOsoSymbols",
	"Comment": "relativize paths in oso entries.oso entries point to other files containing debug information. these are generated by thelinker as absolute paths.",
	"Method": "void relativizeOsoSymbols(FileChannel file,ImmutableMap<Path, Path> cellRoots){\r\n    cellRoots.forEach((from, to) -> {\r\n        Preconditions.checkArgument(from.isAbsolute());\r\n        Preconditions.checkArgument(!to.isAbsolute());\r\n    });\r\n    long size = file.size();\r\n    MappedByteBuffer map = file.map(FileChannel.MapMode.READ_WRITE, 0, size);\r\n    MachoHeader header = getHeader(map);\r\n    int symbolTableOffset = 0;\r\n    int symbolTableCount = 0;\r\n    int stringTableOffset = 0;\r\n    int stringTableSizePosition = 0;\r\n    int stringTableSize = 0;\r\n    boolean symbolTableSegmentFound = false;\r\n    int segmentSizePosition = 0;\r\n    int segmentSize = 0;\r\n    boolean linkEditSegmentFound = false;\r\n    int segmentFileSizePosition = 0;\r\n    int segmentFileSize = 0;\r\n    int segment64FileSizePosition = 0;\r\n    long segment64FileSize = 0;\r\n    int commandsCount = header.getCommandsCount();\r\n    for (int i = 0; i < commandsCount; i++) {\r\n        int commandStart = map.position();\r\n        int command = ObjectFileScrubbers.getLittleEndianInt(map);\r\n        int commandSize = ObjectFileScrubbers.getLittleEndianInt(map);\r\n        switch(command) {\r\n            case LC_SYMTAB:\r\n                symbolTableOffset = ObjectFileScrubbers.getLittleEndianInt(map);\r\n                symbolTableCount = ObjectFileScrubbers.getLittleEndianInt(map);\r\n                stringTableOffset = ObjectFileScrubbers.getLittleEndianInt(map);\r\n                stringTableSizePosition = map.position();\r\n                stringTableSize = ObjectFileScrubbers.getLittleEndianInt(map);\r\n                symbolTableSegmentFound = true;\r\n                break;\r\n            case LC_SEGMENT:\r\n                byte[] segmentNameBytes = ObjectFileScrubbers.getBytes(map, 16);\r\n                String segmentName = new String(segmentNameBytes, Charsets.US_ASCII);\r\n                if (segmentName.startsWith(LINKEDIT)) {\r\n                    linkEditSegmentFound = true;\r\n                    ObjectFileScrubbers.getLittleEndianInt(map);\r\n                    ObjectFileScrubbers.getLittleEndianInt(map);\r\n                    ObjectFileScrubbers.getLittleEndianInt(map);\r\n                    segmentFileSizePosition = map.position();\r\n                    segmentFileSize = ObjectFileScrubbers.getLittleEndianInt(map);\r\n                    ObjectFileScrubbers.getLittleEndianInt(map);\r\n                    ObjectFileScrubbers.getLittleEndianInt(map);\r\n                    ObjectFileScrubbers.getLittleEndianInt(map);\r\n                    ObjectFileScrubbers.getLittleEndianInt(map);\r\n                    if (segmentSizePosition != 0) {\r\n                        throw new MachoException(\"multiple map segment commands map string table\");\r\n                    }\r\n                    segmentSizePosition = segmentFileSizePosition;\r\n                    segmentSize = segmentFileSize;\r\n                }\r\n                break;\r\n            case LC_SEGMENT_64:\r\n                byte[] segment64NameBytes = ObjectFileScrubbers.getBytes(map, 16);\r\n                String segment64Name = new String(segment64NameBytes, Charsets.US_ASCII);\r\n                if (segment64Name.startsWith(LINKEDIT)) {\r\n                    linkEditSegmentFound = true;\r\n                    ObjectFileScrubbers.getLittleEndianLong(map);\r\n                    ObjectFileScrubbers.getLittleEndianLong(map);\r\n                    ObjectFileScrubbers.getLittleEndianLong(map);\r\n                    segment64FileSizePosition = map.position();\r\n                    segment64FileSize = ObjectFileScrubbers.getLittleEndianLong(map);\r\n                    ObjectFileScrubbers.getLittleEndianInt(map);\r\n                    ObjectFileScrubbers.getLittleEndianInt(map);\r\n                    ObjectFileScrubbers.getLittleEndianInt(map);\r\n                    ObjectFileScrubbers.getLittleEndianInt(map);\r\n                    if (segmentSizePosition != 0) {\r\n                        throw new MachoException(\"multiple map segment commands map string table\");\r\n                    }\r\n                    segmentSizePosition = segment64FileSizePosition;\r\n                    if (segment64FileSize > Ints.MAX_POWER_OF_TWO) {\r\n                        throw new MachoException(\"map segment file size too big\");\r\n                    }\r\n                    segmentSize = (int) segment64FileSize;\r\n                }\r\n                break;\r\n        }\r\n        map.position(commandStart + commandSize);\r\n    }\r\n    if (!linkEditSegmentFound) {\r\n        return;\r\n    }\r\n    if (!symbolTableSegmentFound) {\r\n        throw new MachoException(\"LC_SYMTAB command not found\");\r\n    }\r\n    if (stringTableOffset + stringTableSize != size) {\r\n        throw new MachoException(\"String table does not end at end of file\");\r\n    }\r\n    if (stringTableSize == 0) {\r\n        return;\r\n    }\r\n    if (segmentSizePosition == 0 || segmentSize == 0) {\r\n        throw new MachoException(\"LC_SEGMENT or LC_SEGMENT_64 command for string table not found\");\r\n    }\r\n    map.position(stringTableOffset);\r\n    if (map.get() != 0x20) {\r\n        throw new MachoException(\"First character in the string table is not a space\");\r\n    }\r\n    if (map.get() != 0x00) {\r\n        throw new MachoException(\"Second character in the string table is not a NUL\");\r\n    }\r\n    int currentStringTableOffset = map.position();\r\n    byte[] stringTableBytes = new byte[stringTableSize];\r\n    map.position(stringTableOffset);\r\n    map.get(stringTableBytes);\r\n    ByteBuffer stringTable = ByteBuffer.wrap(stringTableBytes);\r\n    map.position(symbolTableOffset);\r\n    Map<Integer, Integer> strings = new HashMap();\r\n    for (int i = 0; i < symbolTableCount; i++) {\r\n        int stringTableIndexPosition = map.position();\r\n        int stringTableIndex = ObjectFileScrubbers.getLittleEndianInt(map);\r\n        byte type = map.get();\r\n        map.get();\r\n        ObjectFileScrubbers.getLittleEndianShort(map);\r\n        int valuePosition = map.position();\r\n        if (header.getIs64Bit()) {\r\n            ObjectFileScrubbers.getLittleEndianLong(map);\r\n        } else {\r\n            ObjectFileScrubbers.getLittleEndianInt(map);\r\n        }\r\n        if (stringTableIndex < 2) {\r\n            continue;\r\n        }\r\n        int position = map.position();\r\n        try {\r\n            int newStringTableIndex;\r\n            if (strings.containsKey(stringTableIndex)) {\r\n                newStringTableIndex = strings.get(stringTableIndex);\r\n            } else {\r\n                stringTable.position(stringTableIndex);\r\n                String string = ObjectFileScrubbers.getAsciiString(stringTable);\r\n                if (type == N_OSO) {\r\n                    for (Map.Entry<Path, Path> root : cellRoots.entrySet()) {\r\n                        String rootPrefix = root.getKey() + \"/\";\r\n                        if (string.startsWith(rootPrefix)) {\r\n                            String replacementPrefix = root.getValue().toString();\r\n                            if (replacementPrefix.equals(\"\")) {\r\n                                replacementPrefix = \".\";\r\n                            }\r\n                            string = replacementPrefix + \"/\" + string.substring(rootPrefix.length());\r\n                        }\r\n                    }\r\n                    map.position(valuePosition);\r\n                    int lastModifiedValue = ObjectFileCommonModificationDate.COMMON_MODIFICATION_TIME_STAMP;\r\n                    if (header.getIs64Bit()) {\r\n                        ObjectFileScrubbers.putLittleEndianLong(map, lastModifiedValue);\r\n                    } else {\r\n                        ObjectFileScrubbers.putLittleEndianInt(map, lastModifiedValue);\r\n                    }\r\n                }\r\n                map.position(currentStringTableOffset);\r\n                ObjectFileScrubbers.putAsciiString(map, string);\r\n                newStringTableIndex = currentStringTableOffset - stringTableOffset;\r\n                currentStringTableOffset = map.position();\r\n                strings.put(stringTableIndex, newStringTableIndex);\r\n            }\r\n            map.position(stringTableIndexPosition);\r\n            ObjectFileScrubbers.putLittleEndianInt(map, newStringTableIndex);\r\n        } finally {\r\n            map.position(position);\r\n        }\r\n    }\r\n    map.position(stringTableSizePosition);\r\n    int newStringTableSize = currentStringTableOffset - stringTableOffset;\r\n    ObjectFileScrubbers.putLittleEndianInt(map, newStringTableSize);\r\n    map.position(segmentSizePosition);\r\n    ObjectFileScrubbers.putLittleEndianInt(map, segmentSize + (newStringTableSize - stringTableSize));\r\n    file.truncate(currentStringTableOffset);\r\n}"
}, {
	"Path": "com.android.dx.dex.file.OffsettedItem.setWriteSize",
	"Comment": "sets the write size of this item. this may only be called onceper instance, and only if the size was unknown upon instancecreation.",
	"Method": "void setWriteSize(int writeSize){\r\n    if (writeSize < 0) {\r\n        throw new IllegalArgumentException(\"writeSize < 0\");\r\n    }\r\n    if (this.writeSize >= 0) {\r\n        throw new UnsupportedOperationException(\"writeSize already set\");\r\n    }\r\n    this.writeSize = writeSize;\r\n}"
}, {
	"Path": "com.android.dex.Dex.computeSignature",
	"Comment": "returns the signature of all but the first 32 bytes of this dex. thefirst 32 bytes of dex files are not specified to be included in thesignature.",
	"Method": "byte[] computeSignature(){\r\n    MessageDigest digest;\r\n    try {\r\n        digest = MessageDigest.getInstance(\"SHA-1\");\r\n    } catch (NoSuchAlgorithmException e) {\r\n        throw new AssertionError();\r\n    }\r\n    byte[] buffer = new byte[8192];\r\n    ByteBuffer data = this.data.duplicate();\r\n    data.limit(data.capacity());\r\n    data.position(SIGNATURE_OFFSET + SIGNATURE_SIZE);\r\n    while (data.hasRemaining()) {\r\n        int count = Math.min(buffer.length, data.remaining());\r\n        data.get(buffer, 0, count);\r\n        digest.update(buffer, 0, count);\r\n    }\r\n    return digest.digest();\r\n}"
}, {
	"Path": "com.facebook.buck.parser.PythonDslProjectBuildFileParser.initIfNeeded",
	"Comment": "initialization on demand moves around the performance impact of creating the python interpreterto when parsing actually begins. this makes it easier to attribute this time to the actualparse phase.",
	"Method": "void initIfNeeded(){\r\n    ensureNotClosed();\r\n    if (!isInitialized) {\r\n        init();\r\n        isInitialized = true;\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.cf.code.LocalVariableList.concat",
	"Comment": "returns an instance which is the concatenation of the two giveninstances. the result is immutable.",
	"Method": "LocalVariableList concat(LocalVariableList list1,LocalVariableList list2){\r\n    if (list1 == EMPTY) {\r\n        return list2;\r\n    }\r\n    int sz1 = list1.size();\r\n    int sz2 = list2.size();\r\n    LocalVariableList result = new LocalVariableList(sz1 + sz2);\r\n    for (int i = 0; i < sz1; i++) {\r\n        result.set(i, list1.get(i));\r\n    }\r\n    for (int i = 0; i < sz2; i++) {\r\n        result.set(sz1 + i, list2.get(i));\r\n    }\r\n    result.setImmutable();\r\n    return result;\r\n}"
}, {
	"Path": "com.android.common.xml.AndroidXPathFactory.newXPath",
	"Comment": "creates a new xpath object using the default prefix for the android namespace.",
	"Method": "XPath newXPath(String androidPrefix,XPath newXPath){\r\n    XPath xpath = sFactory.newXPath();\r\n    xpath.setNamespaceContext(AndroidNamespaceContext.getDefault());\r\n    return xpath;\r\n}"
}, {
	"Path": "com.android.dx.dex.file.IndexedItem.indexString",
	"Comment": "gets the index of this item as a string, suitable for including inannotations.",
	"Method": "String indexString(){\r\n    return '[' + Integer.toHexString(index) + ']';\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getBNibble",
	"Comment": "gets the b register number, as a nibble. this will throw if thevalue is out of the range of an unsigned nibble.",
	"Method": "short getBNibble(){\r\n    int b = getB();\r\n    if ((b & ~0xf) != 0) {\r\n        throw new DexException(\"Register B out of range: \" + Hex.u8(b));\r\n    }\r\n    return (short) b;\r\n}"
}, {
	"Path": "com.android.dx.cf.direct.AnnotationParser.requireLength",
	"Comment": "helper which will throw an exception if the given number of bytesis not available to be read.",
	"Method": "void requireLength(int requiredLength){\r\n    if (input.available() < requiredLength) {\r\n        throw new ParseException(\"truncated annotation attribute\");\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.dex.code.DalvInsnList.getRegistersSize",
	"Comment": "gets the minimum required register count implied by thisinstance.this includes any unused parameters that couldpotentially be at the top of the register space.",
	"Method": "int getRegistersSize(){\r\n    return regCount;\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.endtoend.EndToEndEnvironment.addLocalConfigSet",
	"Comment": "adds a new set of local buckconfig options for a separate test",
	"Method": "EndToEndEnvironment addLocalConfigSet(Map<String, Map<String, String>> localConfigSet){\r\n    localConfigSets.add(localConfigSet);\r\n    return this;\r\n}"
}, {
	"Path": "com.android.dx.cf.direct.CodeObserver.header",
	"Comment": "helper to produce the first bit of output for each instruction.",
	"Method": "String header(int offset){\r\n    int opcode = bytes.getUnsignedByte(offset);\r\n    String name = ByteOps.opName(opcode);\r\n    if (opcode == ByteOps.WIDE) {\r\n        opcode = bytes.getUnsignedByte(offset + 1);\r\n        name += \" \" + ByteOps.opName(opcode);\r\n    }\r\n    return Hex.u2(offset) + \": \" + name;\r\n}"
}, {
	"Path": "com.android.common.xml.AndroidManifest.getTestFunctionalTest",
	"Comment": "returns the instrumentation functionaltest value for the manifest.",
	"Method": "String getTestFunctionalTest(IAbstractFile manifestFile){\r\n    return getStringValue(manifestFile, getTestFunctionalTestXPath());\r\n}"
}, {
	"Path": "com.android.dx.dex.file.AnnotationItem.sortByTypeIdIndex",
	"Comment": "sorts an array of instances, in place, by type id index,ignoring all other aspects of the elements. this is only validto use after type id indices are known.",
	"Method": "void sortByTypeIdIndex(AnnotationItem[] array){\r\n    Arrays.sort(array, TYPE_ID_SORTER);\r\n}"
}, {
	"Path": "com.facebook.buck.skylark.parser.SkylarkProjectBuildFileParser.newGlobber",
	"Comment": "creates a globber for the package defined by the provided build file path.",
	"Method": "CachingGlobber newGlobber(Path buildFile){\r\n    return CachingGlobber.of(globberFactory.create(fileSystem.getPath(buildFile.getParent().toString())));\r\n}"
}, {
	"Path": "com.android.manifmerger.PreValidator.checkKeyPresence",
	"Comment": "checks that an element which is supposed to have a key does have one.",
	"Method": "boolean checkKeyPresence(MergingReport.Builder mergingReport,XmlElement xmlElement){\r\n    ManifestModel.NodeKeyResolver nodeKeyResolver = xmlElement.getType().getNodeKeyResolver();\r\n    ImmutableList<String> keyAttributesNames = nodeKeyResolver.getKeyAttributesNames();\r\n    if (keyAttributesNames.isEmpty()) {\r\n        return false;\r\n    }\r\n    if (Strings.isNullOrEmpty(xmlElement.getKey())) {\r\n        String message = keyAttributesNames.size() > 1 ? String.format(\"Missing one of the key attributes '%1$s' on element %2$s at %3$s\", Joiner.on(',').join(keyAttributesNames), xmlElement.getId(), xmlElement.printPosition()) : String.format(\"Missing '%1$s' key attribute on element %2$s at %3$s\", keyAttributesNames.get(0), xmlElement.getId(), xmlElement.printPosition());\r\n        xmlElement.addMessage(mergingReport, ERROR, message);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_client.DistBuildRunner.cancelAsLocalBuildFinished",
	"Comment": "performs cleanup of distributed build when local build finishes first.",
	"Method": "void cancelAsLocalBuildFinished(boolean localBuildSucceeded,Optional<ExitCode> localBuildExitCode){\r\n    Objects.requireNonNull(runDistributedBuildFuture, \"Cannot cancel build that hasn't started\");\r\n    String statusString = localBuildSucceeded ? \"finished\" : String.format(\"failed [exitCode=%d]\", localBuildExitCode.isPresent() ? localBuildExitCode.get().getCode() : -1);\r\n    eventBus.post(new StampedeLocalBuildStatusEvent(statusString));\r\n    localBuildFinishedFirst.set(true);\r\n    if (finishedSuccessfully() && !waitGracefullyForDistributedBuildThreadToFinish) {\r\n        runDistributedBuildFuture.cancel(true);\r\n        return;\r\n    }\r\n    if (stillPending()) {\r\n        setLocalBuildFinishedFirstExitCode();\r\n        String statusMessage = String.format(\"The build %s locally before distributed build finished.\", statusString);\r\n        terminateDistributedBuildJob(localBuildSucceeded ? BuildStatus.FINISHED_SUCCESSFULLY : BuildStatus.FAILED, statusMessage);\r\n    }\r\n    if (waitGracefullyForDistributedBuildThreadToFinish) {\r\n        waitUntilFinished();\r\n    } else {\r\n        waitUntilFinishedOrKillOnTimeout();\r\n    }\r\n}"
}, {
	"Path": "com.android.common.ide.common.blame.Message.getSourceFilePositions",
	"Comment": "returns a list of source positions. will always contain at least one item.",
	"Method": "List<SourceFilePosition> getSourceFilePositions(){\r\n    return mSourceFilePositions;\r\n}"
}, {
	"Path": "com.android.dx.cf.code.Ropper.isSubroutineCaller",
	"Comment": "checks to see if the basic block is a subroutine caller block.",
	"Method": "boolean isSubroutineCaller(BasicBlock bb){\r\n    IntList successors = bb.getSuccessors();\r\n    if (successors.size() < 2)\r\n        return false;\r\n    int subLabel = successors.get(1);\r\n    return (subLabel < subroutines.length) && (subroutines[subLabel] != null);\r\n}"
}, {
	"Path": "com.facebook.buck.eden.ReconnectingEdenClient.investigateAndPossiblyRethrowException",
	"Comment": "logic that decides how to proceed after a failed thrift rpc. if it appears to be a staleconnection, this method will not throw as a signal to retry the rpc. otherwise, it rethrows theexception that was passed in.",
	"Method": "void investigateAndPossiblyRethrowException(TException originalException){\r\n    thriftClient = null;\r\n    Throwable e = originalException;\r\n    while (e != null && !(e instanceof LastErrorException)) {\r\n        e = e.getCause();\r\n    }\r\n    if (e != null) {\r\n        LOG.info(e, \"Suspected closed Thrift connection: will create a new one.\");\r\n    } else {\r\n        throw originalException;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.testrunner.BuildThenTestIntegrationTest.testRunningTestOnClassWithoutTestMethods",
	"Comment": "test should pass even when we run tests on non junit test classes",
	"Method": "void testRunningTestOnClassWithoutTestMethods(){\r\n    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(this, \"build_then_test\", temporaryFolder);\r\n    workspace.setUp();\r\n    ProcessResult testResult = workspace.runBuckCommand(\"test\", \"//:nontestclass\");\r\n    testResult.assertSuccess(\"Passing test should exit with 0.\");\r\n}"
}, {
	"Path": "com.android.dx.dex.file.ClassDefItem.getMethods",
	"Comment": "gets all the methods in this class. the returned list is not linkedin any way to the underlying lists contained in this instance, butthe objects contained in the list are shared.",
	"Method": "ArrayList<EncodedMethod> getMethods(){\r\n    return classData.getMethods();\r\n}"
}, {
	"Path": "com.facebook.buck.util.unarchive.UntarTest.assertOutputSymlinkExists",
	"Comment": "assert that a symlink exists inside of the temp directory with given contents and that links tothe right file",
	"Method": "void assertOutputSymlinkExists(Path symlinkPath,Path expectedLinkedToPath,String expectedContents){\r\n    Path fullPath = tmpFolder.getRoot().resolve(symlinkPath);\r\n    if (Platform.detect() != Platform.WINDOWS) {\r\n        Assert.assertTrue(String.format(\"Expected %s to be a symlink\", fullPath), Files.isSymbolicLink(fullPath));\r\n        Path linkedToPath = Files.readSymbolicLink(fullPath);\r\n        Assert.assertEquals(String.format(\"Expected symlink at %s to point to %s, not %s\", symlinkPath, expectedLinkedToPath, linkedToPath), expectedLinkedToPath, linkedToPath);\r\n    }\r\n    Path realExpectedLinkedToPath = filesystem.getRootPath().resolve(symlinkPath.getParent().resolve(expectedLinkedToPath).normalize());\r\n    Assert.assertTrue(String.format(\"Expected link %s to be the same file as %s\", fullPath, realExpectedLinkedToPath), Files.isSameFile(fullPath, realExpectedLinkedToPath));\r\n    String contents = Joiner.on('\\n').join(Files.readAllLines(fullPath));\r\n    Assert.assertEquals(expectedContents, contents);\r\n}"
}, {
	"Path": "com.facebook.buck.android.SmartDexingStepTest.testDxPseudoRuleCaching",
	"Comment": "tests whether pseudo rule cache detection is working properly.",
	"Method": "void testDxPseudoRuleCaching(){\r\n    File testIn = new File(tmpDir.getRoot(), \"testIn\");\r\n    try (ZipOutputStream zipOut = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(testIn)))) {\r\n        zipOut.putNextEntry(new ZipEntry(\"foobar\"));\r\n        zipOut.write(new byte[] { 0 });\r\n    }\r\n    File outputFile = tmpDir.newFile(\"out.dex\");\r\n    Path outputHashFile = new File(tmpDir.getRoot(), \"out.dex.hash\").toPath();\r\n    Files.write(\"dummy\", outputHashFile.toFile(), Charsets.UTF_8);\r\n    ProjectFilesystem filesystem = TestProjectFilesystems.createProjectFilesystem(tmpDir.getRoot().toPath());\r\n    Sha1HashCode actualHashCode = Sha1HashCode.of(Strings.repeat(\"a\", 40));\r\n    DxPseudoRule rule = new DxPseudoRule(createAndroidPlatformTarget(), FakeBuildContext.NOOP_CONTEXT, filesystem, ImmutableMap.of(testIn.toPath(), actualHashCode), ImmutableSet.of(testIn.toPath()), outputFile.toPath(), outputHashFile, EnumSet.of(DxStep.Option.NO_OPTIMIZE), OptionalInt.empty(), Optional.empty(), DxStep.DX, null);\r\n    assertFalse(\"'dummy' is not a matching input hash\", rule.checkIsCached());\r\n    String actualHash = rule.hashInputs();\r\n    assertFalse(actualHash.isEmpty());\r\n    Files.write(actualHash, outputHashFile.toFile(), Charsets.UTF_8);\r\n    assertTrue(\"Matching input hash should be considered cached\", rule.checkIsCached());\r\n}"
}, {
	"Path": "com.android.dx.cf.code.Frame.mergeWith",
	"Comment": "merges two frames. if the merged result is the same as this frame,then this instance is returned.",
	"Method": "Frame mergeWith(Frame other){\r\n    LocalsArray resultLocals;\r\n    ExecutionStack resultStack;\r\n    IntList resultSubroutines;\r\n    resultLocals = getLocals().merge(other.getLocals());\r\n    resultStack = getStack().merge(other.getStack());\r\n    resultSubroutines = mergeSubroutineLists(other.subroutines);\r\n    resultLocals = adjustLocalsForSubroutines(resultLocals, resultSubroutines);\r\n    if ((resultLocals == getLocals()) && (resultStack == getStack()) && subroutines == resultSubroutines) {\r\n        return this;\r\n    }\r\n    return new Frame(resultLocals, resultStack, resultSubroutines);\r\n}"
}, {
	"Path": "com.facebook.buck.core.rules.knowntypes.AbstractKnownRuleTypes.check",
	"Comment": "verify that there are no duplicate rule types being defined.",
	"Method": "void check(){\r\n    Set<RuleType> types = new HashSet();\r\n    for (BaseDescription<?> description : getDescriptions()) {\r\n        RuleType type = DescriptionCache.getRuleType(description);\r\n        if (!types.add(DescriptionCache.getRuleType(description))) {\r\n            throw new IllegalStateException(String.format(\"multiple descriptions with type %s\", type));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.slb.HybridThriftOverHttpServiceImpl.writeToStream",
	"Comment": "writes the http body into a stream in hybrid thrift over http format.",
	"Method": "void writeToStream(DataOutputStream outputStream,byte[] serializedThriftData,HybridThriftRequestHandler<ThriftRequest> request){\r\n    outputStream.writeInt(serializedThriftData.length);\r\n    outputStream.write(serializedThriftData);\r\n    for (int i = 0; i < request.getNumberOfPayloads(); ++i) {\r\n        try (InputStream inputStream = request.getPayloadStream(i)) {\r\n            ByteStreams.copy(inputStream, outputStream);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.features.ocaml.OcamlBuildRulesGenerator.generate",
	"Comment": "generates build rules for both the native and bytecode outputs",
	"Method": "OcamlGeneratedBuildRules generate(){\r\n    ImmutableList.Builder<BuildRule> rules = ImmutableList.builder();\r\n    ImmutableList.Builder<BuildRule> nativeCompileDeps = ImmutableList.builder();\r\n    ImmutableList.Builder<BuildRule> bytecodeCompileDeps = ImmutableList.builder();\r\n    ImmutableList<SourcePath> objFiles = generateCCompilation(cInput);\r\n    if (!this.bytecodeOnly) {\r\n        ImmutableList<SourcePath> cmxFiles = generateMLNativeCompilation(mlInput);\r\n        nativeCompileDeps.addAll(ruleFinder.filterBuildRuleInputs(cmxFiles));\r\n        BuildRule nativeLink = generateNativeLinking(ImmutableList.<SourcePath>builder().addAll(Iterables.concat(cmxFiles, objFiles)).build());\r\n        rules.add(nativeLink);\r\n    }\r\n    ImmutableList<SourcePath> cmoFiles = generateMLBytecodeCompilation(mlInput);\r\n    bytecodeCompileDeps.addAll(ruleFinder.filterBuildRuleInputs(cmoFiles));\r\n    BuildRule bytecodeLink = generateBytecodeLinking(ImmutableList.<SourcePath>builder().addAll(Iterables.concat(cmoFiles, objFiles)).build());\r\n    rules.add(bytecodeLink);\r\n    if (!ocamlContext.isLibrary()) {\r\n        rules.add(generateDebugLauncherRule());\r\n    }\r\n    return OcamlGeneratedBuildRules.builder().setRules(rules.build()).setNativeCompileDeps(ImmutableSortedSet.copyOf(nativeCompileDeps.build())).setBytecodeCompileDeps(ImmutableSortedSet.copyOf(bytecodeCompileDeps.build())).setObjectFiles(objFiles).setBytecodeLink(bytecodeLink).setOcamlContext(ocamlContext).build();\r\n}"
}, {
	"Path": "com.facebook.buck.util.concurrent.MostExecutors.shutdownOrThrow",
	"Comment": "cancel the processing being carried out by the given service and waits for the processing tocomplete. if processing has still not terminated the method throws the given exception.",
	"Method": "void shutdownOrThrow(ExecutorService service,long timeout,TimeUnit unit,RuntimeException exception){\r\n    boolean terminated = false;\r\n    service.shutdown();\r\n    try {\r\n        terminated = service.awaitTermination(timeout, unit);\r\n    } catch (InterruptedException e) {\r\n        terminated = false;\r\n    } finally {\r\n        if (!terminated) {\r\n            service.shutdownNow();\r\n            try {\r\n                terminated = service.awaitTermination(timeout, unit);\r\n            } catch (InterruptedException e) {\r\n                terminated = false;\r\n            }\r\n        }\r\n    }\r\n    if (!terminated) {\r\n        throw exception;\r\n    }\r\n}"
}, {
	"Path": "com.android.manifmerger.XmlAttribute.handleBothAttributePresent",
	"Comment": "handles merging of two attributes value explicitly declared in xml elements.",
	"Method": "void handleBothAttributePresent(MergingReport.Builder report,XmlAttribute higherPriority,AttributeOperationType operationType){\r\n    if (getXml().getNamespaceURI() != null && getXml().getNamespaceURI().equals(SdkConstants.TOOLS_URI)) {\r\n        handleBothToolsAttributePresent(higherPriority);\r\n        return;\r\n    }\r\n    if (operationType == AttributeOperationType.REPLACE) {\r\n        report.getActionRecorder().recordAttributeAction(this, Actions.ActionType.REJECTED, AttributeOperationType.REPLACE);\r\n        return;\r\n    }\r\n    if (mAttributeModel != null) {\r\n        String mergedValue = mAttributeModel.getMergingPolicy().merge(higherPriority.getValue(), getValue());\r\n        if (mergedValue != null) {\r\n            higherPriority.mXml.setValue(mergedValue);\r\n        } else {\r\n            addConflictingValueMessage(report, higherPriority);\r\n        }\r\n        return;\r\n    }\r\n    if (!getValue().equals(higherPriority.getValue())) {\r\n        addConflictingValueMessage(report, higherPriority);\r\n    }\r\n}"
}, {
	"Path": "com.android.dex.Dex.annotationDirectoryOffsetFromClassDefIndex",
	"Comment": "look up an annotation directory offset from a class def index.",
	"Method": "int annotationDirectoryOffsetFromClassDefIndex(int classDefIndex){\r\n    checkBounds(classDefIndex, tableOfContents.classDefs.size);\r\n    int position = tableOfContents.classDefs.off + (SizeOf.CLASS_DEF_ITEM * classDefIndex);\r\n    position += SizeOf.UINT;\r\n    position += SizeOf.UINT;\r\n    position += SizeOf.UINT;\r\n    position += SizeOf.UINT;\r\n    position += SizeOf.UINT;\r\n    return data.getInt(position);\r\n}"
}, {
	"Path": "com.android.dx.dex.code.DalvInsnList.writeTo",
	"Comment": "writes all the instructions in this instance to the given outputdestination.",
	"Method": "void writeTo(AnnotatedOutput out){\r\n    int startCursor = out.getCursor();\r\n    int sz = size();\r\n    if (out.annotates()) {\r\n        boolean verbose = out.isVerbose();\r\n        for (int i = 0; i < sz; i++) {\r\n            DalvInsn insn = (DalvInsn) get0(i);\r\n            int codeBytes = insn.codeSize() * 2;\r\n            String s;\r\n            if ((codeBytes != 0) || verbose) {\r\n                s = insn.listingString(\"  \", out.getAnnotationWidth(), true);\r\n            } else {\r\n                s = null;\r\n            }\r\n            if (s != null) {\r\n                out.annotate(codeBytes, s);\r\n            } else if (codeBytes != 0) {\r\n                out.annotate(codeBytes, \"\");\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < sz; i++) {\r\n        DalvInsn insn = (DalvInsn) get0(i);\r\n        try {\r\n            insn.writeTo(out);\r\n        } catch (RuntimeException ex) {\r\n            throw ExceptionWithContext.withContext(ex, \"...while writing \" + insn);\r\n        }\r\n    }\r\n    int written = (out.getCursor() - startCursor) / 2;\r\n    if (written != codeSize()) {\r\n        throw new RuntimeException(\"write length mismatch; expected \" + codeSize() + \" but actually wrote \" + written);\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.AddressMap.put",
	"Comment": "sets the value address associated with the given key address.",
	"Method": "void put(int keyAddress,int valueAddress){\r\n    map.put(keyAddress, valueAddress);\r\n}"
}, {
	"Path": "com.facebook.buck.testrunner.BuildThenTestIntegrationTest.testRunningTestInAbstractClass",
	"Comment": "test should not be run because the base class is abstract. if the test attempts to run, it willthrow a java.lang.instantiationexception.",
	"Method": "void testRunningTestInAbstractClass(){\r\n    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(this, \"build_then_test\", temporaryFolder);\r\n    workspace.setUp();\r\n    ProcessResult testResult = workspace.runBuckCommand(\"test\", \"//:abstractclass\");\r\n    testResult.assertSuccess(\"Abstract class with test methods should exit with 0.\");\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.DefaultJavaLibraryIntegrationTest.getContents",
	"Comment": "asserts that the specified file exists and returns its contents.",
	"Method": "String getContents(Path relativePathToFile){\r\n    Path file = workspace.getPath(relativePathToFile);\r\n    assertTrue(relativePathToFile + \" should exist and be an ordinary file.\", Files.exists(file));\r\n    String content = Strings.nullToEmpty(new String(Files.readAllBytes(file), UTF_8)).trim();\r\n    assertFalse(relativePathToFile + \" should not be empty.\", content.isEmpty());\r\n    return content;\r\n}"
}, {
	"Path": "com.facebook.buck.util.zip.CentralDirectory.writeCentralDirectoryFileHeader",
	"Comment": "each entry requires a description of that entry to be contained in the central directory.",
	"Method": "long writeCentralDirectoryFileHeader(OutputStream out,EntryAccounting entry){\r\n    long size = 0;\r\n    size += ByteIo.writeInt(out, ZipEntry.CENSIG);\r\n    size += ByteIo.writeShort(out, entry.getRequiredExtractVersion());\r\n    size += ByteIo.writeShort(out, entry.getRequiredExtractVersion());\r\n    size += ByteIo.writeShort(out, entry.getFlags());\r\n    size += ByteIo.writeShort(out, entry.getCompressionMethod());\r\n    size += ByteIo.writeInt(out, entry.getTime());\r\n    size += ByteIo.writeInt(out, entry.getCrc());\r\n    size += ByteIo.writeInt(out, entry.getCompressedSize());\r\n    size += ByteIo.writeInt(out, entry.getSize());\r\n    byte[] nameBytes = entry.getName().getBytes(Charsets.UTF_8);\r\n    long externalAttributes = entry.getExternalAttributes();\r\n    size += ByteIo.writeShort(out, nameBytes.length);\r\n    size += ByteIo.writeShort(out, 0);\r\n    size += ByteIo.writeShort(out, 0);\r\n    size += ByteIo.writeShort(out, 0);\r\n    size += ByteIo.writeShort(out, 0);\r\n    size += ByteIo.writeInt(out, externalAttributes);\r\n    size += ByteIo.writeInt(out, entry.getOffset());\r\n    out.write(nameBytes);\r\n    size += nameBytes.length;\r\n    return size;\r\n}"
}, {
	"Path": "com.facebook.buck.features.apple.project.FocusedModuleTargetMatcher.focusedOn",
	"Comment": "returns a matcher that specifies a set of targets to focus on.",
	"Method": "FocusedModuleTargetMatcher focusedOn(ImmutableSet<UnflavoredBuildTarget> targets){\r\n    return new FocusedModuleTargetMatcher(targets);\r\n}"
}, {
	"Path": "com.facebook.buck.rules.keys.DefaultRuleKeyCache.invalidateInputs",
	"Comment": "invalidate the given inputs and all their transitive dependents.",
	"Method": "void invalidateInputs(Iterable<RuleKeyInput> inputs,CacheStatsTracker statsTracker){\r\n    List<Stream<Object>> nodes = new ArrayList();\r\n    for (RuleKeyInput input : inputs) {\r\n        LOG.verbose(\"invalidating input %s\", input);\r\n        Stream.Builder<Object> inputNodes = inputsIndex.remove(input);\r\n        if (inputNodes != null) {\r\n            nodes.add(inputNodes.build());\r\n        }\r\n    }\r\n    if (!nodes.isEmpty()) {\r\n        invalidateNodes(nodes.stream().flatMap(x -> x), statsTracker);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.apple.endtoend.AppleEndToEndTest.shouldBuild",
	"Comment": "determines that buck successfully outputs proper programs",
	"Method": "void shouldBuild(EndToEndTestDescriptor test,EndToEndWorkspace workspace){\r\n    ProcessResult result = workspace.runBuckCommand(test);\r\n    result.assertSuccess(\"Did not successfully build\");\r\n}"
}, {
	"Path": "com.facebook.buck.util.ProcessHelper.getTotalResourceConsumption",
	"Comment": "gets resource consumption of the process subtree rooted at the process with the given pid.",
	"Method": "ProcessResourceConsumption getTotalResourceConsumption(long pid){\r\n    ProcessResourceConsumption[] res = new ProcessResourceConsumption[] { null };\r\n    ProcessTree tree = processTree.get();\r\n    tree.visitAllDescendants(pid, (childPid, childNode) -> {\r\n        ProcessResourceConsumption childRes = getProcessResourceConsumptionInternal(childNode.info);\r\n        res[0] = ProcessResourceConsumption.getTotal(res[0], childRes);\r\n    });\r\n    return (res[0] != null) ? res[0] : getProcessResourceConsumption(pid);\r\n}"
}, {
	"Path": "com.facebook.buck.features.python.PythonTestDescription.getTestModulesListContents",
	"Comment": "create the contents of a python source file that just contains a list of the given testmodules.",
	"Method": "String getTestModulesListContents(ImmutableSet<String> modules){\r\n    StringBuilder contents = new StringBuilder(\"TEST_MODULES = [\\n\");\r\n    for (String module : modules) {\r\n        contents.append(String.format(\"    \\\"%s\\\",\\n\", module));\r\n    }\r\n    contents.append(\"]\");\r\n    return contents.toString();\r\n}"
}, {
	"Path": "com.facebook.buck.apple.toolchain.impl.AppleCxxPlatformsTest.constructCompileRuleKeys",
	"Comment": "create and return some rule keys from a dummy source for the given platforms.",
	"Method": "ImmutableMap<Flavor, RuleKey> constructCompileRuleKeys(Operation operation,ImmutableMap<Flavor, AppleCxxPlatform> cxxPlatforms){\r\n    ActionGraphBuilder graphBuilder = new TestActionGraphBuilder();\r\n    SourcePathRuleFinder ruleFinder = new SourcePathRuleFinder(graphBuilder);\r\n    SourcePathResolver pathResolver = DefaultSourcePathResolver.from(ruleFinder);\r\n    String source = \"source.cpp\";\r\n    DefaultRuleKeyFactory ruleKeyFactory = new TestDefaultRuleKeyFactory(new FakeFileHashCache(ImmutableMap.<Path, HashCode>builder().put(projectFilesystem.resolve(\"source.cpp\"), HashCode.fromInt(0)).build()), pathResolver, ruleFinder);\r\n    BuildTarget target = BuildTargetFactory.newInstance(projectFilesystem.getRootPath(), \"//:target\");\r\n    ImmutableMap.Builder<Flavor, RuleKey> ruleKeys = ImmutableMap.builder();\r\n    for (Map.Entry<Flavor, AppleCxxPlatform> entry : cxxPlatforms.entrySet()) {\r\n        CxxSourceRuleFactory cxxSourceRuleFactory = CxxSourceRuleFactory.builder().setProjectFilesystem(projectFilesystem).setBaseBuildTarget(target).setActionGraphBuilder(graphBuilder).setPathResolver(pathResolver).setRuleFinder(ruleFinder).setCxxBuckConfig(CxxPlatformUtils.DEFAULT_CONFIG).setCxxPlatform(entry.getValue().getCxxPlatform()).setPicType(PicType.PIC).build();\r\n        CxxPreprocessAndCompile rule;\r\n        switch(operation) {\r\n            case PREPROCESS_AND_COMPILE:\r\n                rule = cxxSourceRuleFactory.requirePreprocessAndCompileBuildRule(source, CxxSource.of(CxxSource.Type.CXX, FakeSourcePath.of(projectFilesystem, source), ImmutableList.of()));\r\n                break;\r\n            case COMPILE:\r\n                rule = cxxSourceRuleFactory.requireCompileBuildRule(source, CxxSource.of(CxxSource.Type.CXX_CPP_OUTPUT, FakeSourcePath.of(projectFilesystem, source), ImmutableList.of()));\r\n                break;\r\n            default:\r\n                throw new IllegalStateException();\r\n        }\r\n        ruleKeys.put(entry.getKey(), ruleKeyFactory.build(rule));\r\n    }\r\n    return ruleKeys.build();\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.endtoend.ConfigSetBuilder.build",
	"Comment": "builds and returns configurationset, and resets added sets to the builder",
	"Method": "Map<String, Map<String, String>> build(){\r\n    Map<String, Map<String, String>> builtConfigSet = configSet;\r\n    configSet = new HashMap();\r\n    return builtConfigSet;\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.DistBuildService.reportCoordinatorIsAlive",
	"Comment": "reports that the coordinator is alive to the stampede servers.",
	"Method": "void reportCoordinatorIsAlive(StampedeId stampedeId){\r\n    ReportCoordinatorAliveRequest request = new ReportCoordinatorAliveRequest();\r\n    request.setStampedeId(stampedeId);\r\n    FrontendRequest frontendRequest = new FrontendRequest();\r\n    frontendRequest.setType(FrontendRequestType.REPORT_COORDINATOR_ALIVE);\r\n    frontendRequest.setReportCoordinatorAliveRequest(request);\r\n    FrontendResponse response = makeRequestChecked(frontendRequest);\r\n    Preconditions.checkState(response.isSetReportCoordinatorAliveResponse());\r\n}"
}, {
	"Path": "com.android.dx.dex.file.OffsettedItem.getAbsoluteOffset",
	"Comment": "gets the absolute item offset. the offset is from the start ofthe file which the instance was written to.",
	"Method": "int getAbsoluteOffset(){\r\n    if (offset < 0) {\r\n        throw new RuntimeException(\"offset not yet known\");\r\n    }\r\n    return addedTo.getAbsoluteOffset(offset);\r\n}"
}, {
	"Path": "com.android.dx.dex.file.MapItem.addMap",
	"Comment": "constructs a list item with instances of this class representingthe contents of the given array of sections, adding it to thegiven map section.",
	"Method": "void addMap(Section[] sections,MixedItemSection mapSection){\r\n    if (sections == null) {\r\n        throw new NullPointerException(\"sections == null\");\r\n    }\r\n    if (mapSection.items().size() != 0) {\r\n        throw new IllegalArgumentException(\"mapSection.items().size() != 0\");\r\n    }\r\n    ArrayList<MapItem> items = new ArrayList<MapItem>(50);\r\n    for (Section section : sections) {\r\n        ItemType currentType = null;\r\n        Item firstItem = null;\r\n        Item lastItem = null;\r\n        int count = 0;\r\n        for (Item item : section.items()) {\r\n            ItemType type = item.itemType();\r\n            if (type != currentType) {\r\n                if (count != 0) {\r\n                    items.add(new MapItem(currentType, section, firstItem, lastItem, count));\r\n                }\r\n                currentType = type;\r\n                firstItem = item;\r\n                count = 0;\r\n            }\r\n            lastItem = item;\r\n            count++;\r\n        }\r\n        if (count != 0) {\r\n            items.add(new MapItem(currentType, section, firstItem, lastItem, count));\r\n        } else if (section == mapSection) {\r\n            items.add(new MapItem(mapSection));\r\n        }\r\n    }\r\n    mapSection.add(new UniformListItem<MapItem>(ItemType.TYPE_MAP_LIST, items));\r\n}"
}, {
	"Path": "com.facebook.buck.query.QueryTargetAccessor.filterAttributeContents",
	"Comment": "filters the objects in the given attribute that satisfy the given predicate.",
	"Method": "ImmutableSet<Object> filterAttributeContents(TypeCoercerFactory typeCoercerFactory,TargetNode<T> node,String attribute,Predicate<Object> predicate){\r\n    Class<?> constructorArgClass = node.getConstructorArg().getClass();\r\n    ParamInfo info = CoercedTypeCache.INSTANCE.getAllParamInfo(typeCoercerFactory, constructorArgClass).get(attribute);\r\n    if (info == null) {\r\n        return ImmutableSet.of();\r\n    }\r\n    ImmutableSet.Builder<Object> builder = ImmutableSet.builder();\r\n    info.traverse(node.getCellNames(), value -> {\r\n        if (predicate.test(value)) {\r\n            builder.add(value);\r\n        }\r\n    }, node.getConstructorArg());\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.android.dx.cf.code.LocalsArraySet.subArrayForLabel",
	"Comment": "returns a localsarray instance representing the locals state that shouldbe used when returning to a subroutine caller.",
	"Method": "LocalsArray subArrayForLabel(int subLabel){\r\n    LocalsArray result = getSecondaryForLabel(subLabel);\r\n    return result;\r\n}"
}, {
	"Path": "com.facebook.buck.rules.modern.ModernBuildRule.getSourcePath",
	"Comment": "this should only be exposed to implementations of the modernbuildrule, not of the buildable.",
	"Method": "BuildTargetSourcePath getSourcePath(OutputPath outputPath){\r\n    return ExplicitBuildTargetSourcePath.of(getBuildTarget(), outputPathResolver.resolvePath(outputPath));\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_client.BuildRuleEventManager.publishCacheSynchronizedBuildRuleFinishedEvents",
	"Comment": "publishes results of pending buildrulefinishedevent that have already synchronized with cache.",
	"Method": "void publishCacheSynchronizedBuildRuleFinishedEvents(){\r\n    synchronized (this) {\r\n        if (pendingBuildRuleFinishedEvent.isEmpty()) {\r\n            return;\r\n        }\r\n    }\r\n    List<TimestampedBuildRuleFinishedEvent> eventsToPublish = Lists.newArrayList();\r\n    synchronized (this) {\r\n        findAllCacheSynchronizedBuildRules(eventsToPublish);\r\n        pendingBuildRuleFinishedEvent.removeAll(eventsToPublish);\r\n    }\r\n    for (TimestampedBuildRuleFinishedEvent event : eventsToPublish) {\r\n        remoteBuildRuleCompletionNotifier.signalCompletionOfBuildRule(event.buildTarget);\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.dex.code.BlockAddresses.getLast",
	"Comment": "gets the instance for the final instruction of the block withthe given label.",
	"Method": "CodeAddress getLast(BasicBlock block,CodeAddress getLast,int label){\r\n    return lasts[label];\r\n}"
}, {
	"Path": "com.facebook.buck.features.project.intellij.IjProjectTemplateDataPreparer.addAndroidCompilerOutputPath",
	"Comment": "intellij may not be able to find classes on the compiler output path if the jars are retrievedfrom the network cache.",
	"Method": "void addAndroidCompilerOutputPath(Map<String, Object> androidProperties,IjModule module){\r\n    Optional<Path> compilerOutputPath = module.getCompilerOutputPath();\r\n    if (compilerOutputPath.isPresent()) {\r\n        androidProperties.put(\"compiler_output_path\", getUrl(projectPaths.getModuleQualifiedPath(compilerOutputPath.get(), module)));\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.dex.file.OffsettedItem.offsetString",
	"Comment": "gets the absolute offset of this item as a string, suitable forincluding in annotations.",
	"Method": "String offsetString(){\r\n    return '[' + Integer.toHexString(getAbsoluteOffset()) + ']';\r\n}"
}, {
	"Path": "com.android.manifmerger.XmlDocument.merge",
	"Comment": "merge this higher priority document with a higher priority document.",
	"Method": "Optional<XmlDocument> merge(XmlDocument lowerPriorityDocument,MergingReport.Builder mergingReportBuilder){\r\n    if (getFileType() == Type.MAIN) {\r\n        mergingReportBuilder.getActionRecorder().recordDefaultNodeAction(getRootNode());\r\n    }\r\n    getRootNode().mergeWithLowerPriorityNode(lowerPriorityDocument.getRootNode(), mergingReportBuilder);\r\n    addImplicitElements(lowerPriorityDocument, mergingReportBuilder);\r\n    return mergingReportBuilder.hasErrors() ? Optional.<XmlDocument>absent() : Optional.of(reparse());\r\n}"
}, {
	"Path": "com.facebook.buck.core.sourcepath.resolver.impl.AbstractSourcePathResolver.getSourcePathNames",
	"Comment": "resolves the logical names for a group of objects that have a sourcepath into a map, throwingan error on duplicates.",
	"Method": "ImmutableMap<String, SourcePath> getSourcePathNames(BuildTarget target,String parameter,Iterable<SourcePath> sourcePaths,ImmutableMap<String, T> getSourcePathNames,BuildTarget target,String parameter,Iterable<T> objects,Predicate<T> filter,Function<T, SourcePath> objectSourcePathFunction){\r\n    Map<String, T> resolved = new LinkedHashMap();\r\n    for (T object : objects) {\r\n        if (filter.test(object)) {\r\n            SourcePath path = objectSourcePathFunction.apply(object);\r\n            String name = getSourcePathName(target, path);\r\n            T old = resolved.put(name, object);\r\n            if (old != null) {\r\n                throw new HumanReadableException(String.format(\"%s: parameter '%s': duplicate entries for '%s'\", target, parameter, name));\r\n            }\r\n        }\r\n    }\r\n    return ImmutableMap.copyOf(resolved);\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getDNibble",
	"Comment": "gets the d register number, as a nibble. this will throw if thevalue is out of the range of an unsigned nibble.",
	"Method": "short getDNibble(){\r\n    int d = getD();\r\n    if ((d & ~0xf) != 0) {\r\n        throw new DexException(\"Register D out of range: \" + Hex.u8(d));\r\n    }\r\n    return (short) d;\r\n}"
}, {
	"Path": "com.facebook.buck.apple.AppleTestIntegrationTest.testDependenciesLinking",
	"Comment": "this test is disabled since the movement from xctool to fbxctest",
	"Method": "void testDependenciesLinking(){\r\n    assumeTrue(false);\r\n    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(this, \"apple_test_dependencies_test\", tmp);\r\n    workspace.setUp();\r\n    workspace.copyRecursively(TestDataHelper.getTestDataDirectory(this).resolve(\"fbxctest\"), Paths.get(\"fbxctest\"));\r\n    ProcessResult result = workspace.runBuckCommand(\"test\", \"--config\", \"apple.xctool_path=fbxctest/bin/fbxctest\", \"//:App\");\r\n    result.assertSuccess();\r\n    ProcessExecutor.Result hasSymbol = workspace.runCommand(\"nm\", workspace.getPath(BuildTargetPaths.getGenPath(filesystem, workspace.newBuildTarget(\"#AppBinary#binary,iphonesimulator-x86_64\"), \"AppBinary#apple-dsym,iphonesimulator-x86_64.dSYM\")).toString());\r\n    assertThat(hasSymbol.getExitCode(), equalTo(0));\r\n    assertThat(hasSymbol.getStdout().get(), containsString(\"U _OBJC_CLASS_$_Library\"));\r\n}"
}, {
	"Path": "com.android.dx.io.Opcodes.extractOpcodeFromUnit",
	"Comment": "gets the opcode out of an opcode unit, the latter of which may alsoinclude one or more argument values.",
	"Method": "int extractOpcodeFromUnit(int opcodeUnit){\r\n    int lowByte = opcodeUnit & 0xff;\r\n    return ((lowByte == 0) || (lowByte == 0xff)) ? opcodeUnit : lowByte;\r\n}"
}, {
	"Path": "com.facebook.buck.rules.keys.hasher.ThriftRuleKeyHasher.putContainer",
	"Comment": "adds a container to the stack. this will pop down the stack of already hashed values in orderto populate the container. the container value is then put back on the stack",
	"Method": "RuleKeyHasher<FullRuleKey> putContainer(Container container,int length){\r\n    try {\r\n        if (container == Container.LIST) {\r\n            return putList(length);\r\n        } else if (container == Container.MAP) {\r\n            return putMap(length);\r\n        } else if (container == Container.TUPLE) {\r\n            Value topValue = this.pendingValues.peek();\r\n            if (topValue.getSetField() == Value._Fields.KEY) {\r\n                return putTupleMap(length);\r\n            } else {\r\n                return putList(length);\r\n            }\r\n        }\r\n        return this;\r\n    } catch (Exception e) {\r\n        LOG.warn(e, \"Got exception in putContainer %s type: %s len: %s. Rulekey so far: %s\", this.hashCode(), container, length, ruleKey);\r\n        return this;\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.dex.code.InsnFormat.signedFitsInNibble",
	"Comment": "helper method to determine if a signed int value fits in a nibble.",
	"Method": "boolean signedFitsInNibble(int value){\r\n    return (value >= -8) && (value <= 7);\r\n}"
}, {
	"Path": "com.facebook.buck.core.rules.common.BuildableSupport.deriveDeps",
	"Comment": "derives dependencies based on everything added to the rulekey.",
	"Method": "Stream<BuildRule> deriveDeps(AddsToRuleKey rule,SourcePathRuleFinder ruleFinder,Stream<BuildRule> deriveDeps,BuildRule rule,SourcePathRuleFinder ruleFinder){\r\n    DepsBuilder builder = new DepsBuilder(ruleFinder);\r\n    AlterRuleKeys.amendKey(builder, rule);\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.android.dx.dex.code.DalvInsn.expandedSuffix",
	"Comment": "gets the instruction suffix required, if any, to use in an expandedversion of this instance. will not generate a move for a registermarked compatible to the format by the given bitset.",
	"Method": "DalvInsn expandedSuffix(BitSet compatRegs){\r\n    if (hasResult() && !compatRegs.get(0)) {\r\n        RegisterSpec r = registers.get(0);\r\n        return makeMove(position, r, r.withReg(0));\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.core.model.actiongraph.computation.ActionGraphProvider.getActionGraph",
	"Comment": "create an actiongraph, using options extracted from a buckconfig.",
	"Method": "ActionGraphAndBuilder getActionGraph(TargetGraph targetGraph,ActionGraphAndBuilder getActionGraph,TargetNodeToBuildRuleTransformer transformer,TargetGraph targetGraph,Optional<ThriftRuleKeyLogger> ruleKeyLogger){\r\n    ActionGraphEvent.Started started = ActionGraphEvent.started();\r\n    eventBus.post(started);\r\n    ActionGraphAndBuilder out;\r\n    ActionGraphEvent.Finished finished = ActionGraphEvent.finished(started);\r\n    try {\r\n        RuleKeyFieldLoader fieldLoader = new RuleKeyFieldLoader(ruleKeyConfiguration);\r\n        ActionGraphAndBuilder cachedActionGraph = actionGraphCache.getIfPresent(targetGraph);\r\n        if (cachedActionGraph != null) {\r\n            eventBus.post(ActionGraphEvent.Cache.hit());\r\n            LOG.info(\"ActionGraph cache hit.\");\r\n            if (checkActionGraphs) {\r\n                compareActionGraphs(cachedActionGraph, transformer, targetGraph, fieldLoader, ruleKeyLogger);\r\n            }\r\n            out = cachedActionGraph;\r\n        } else {\r\n            eventBus.post(ActionGraphEvent.Cache.miss(actionGraphCache.isEmpty()));\r\n            LOG.debug(\"Computing TargetGraph HashCode...\");\r\n            if (actionGraphCache.isEmpty()) {\r\n                LOG.info(\"ActionGraph cache miss. Cache was empty.\");\r\n                eventBus.post(ActionGraphEvent.Cache.missWithEmptyCache());\r\n            } else {\r\n                LOG.info(\"ActionGraph cache miss against \" + actionGraphCache.size() + \" entries.\");\r\n                eventBus.post(ActionGraphEvent.Cache.missWithTargetGraphDifference());\r\n            }\r\n            out = createActionGraph(transformer, targetGraph, skipActionGraphCache ? IncrementalActionGraphMode.DISABLED : incrementalActionGraphMode);\r\n            if (!skipActionGraphCache) {\r\n                LOG.info(\"ActionGraph cache assignment.\");\r\n                actionGraphCache.put(targetGraph, out);\r\n            }\r\n        }\r\n        finished = ActionGraphEvent.finished(started, out.getActionGraph().getSize(), out.getActionGraph());\r\n        return out;\r\n    } finally {\r\n        eventBus.post(finished);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.maven.aether.AetherUtil.addClassifier",
	"Comment": "transforms maven coordinates, adding the specified classifier",
	"Method": "String addClassifier(String mavenCoords,String classifier){\r\n    DefaultArtifact base = new DefaultArtifact(mavenCoords);\r\n    return new DefaultArtifact(base.getGroupId(), base.getArtifactId(), classifier, base.getExtension(), base.getVersion()).toString();\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getDUnit",
	"Comment": "gets the d register number, as a code unit. this will throw if thevalue is out of the range of an unsigned code unit.",
	"Method": "short getDUnit(){\r\n    int d = getD();\r\n    if ((d & ~0xffff) != 0) {\r\n        throw new DexException(\"Register D out of range: \" + Hex.u8(d));\r\n    }\r\n    return (short) d;\r\n}"
}, {
	"Path": "com.facebook.buck.remoteexecution.RemoteExecutionActionEvent.sendEvent",
	"Comment": "takes care of sending both started and finished events within a scope.",
	"Method": "Scope sendEvent(BuckEventBus eventBus,State state,BuildTarget buildTarget,Optional<Protocol.Digest> actionDigest){\r\n    final Started startedEvent = new Started(state, buildTarget, actionDigest);\r\n    eventBus.post(startedEvent);\r\n    final Scope leftEventScope = LeafEvents.scope(eventBus, state.toString().toLowerCase());\r\n    return () -> {\r\n        leftEventScope.close();\r\n        eventBus.post(new Finished(startedEvent));\r\n    };\r\n}"
}, {
	"Path": "com.facebook.buck.android.exopackage.RealAndroidDeviceTest.testFailedDeviceInstallWithException",
	"Comment": "verify that if exception is thrown during installation, installation is marked as failed.",
	"Method": "void testFailedDeviceInstallWithException(){\r\n    File apk = new File(\"/some/file.apk\");\r\n    TestDevice device = new TestDevice() {\r\n        @Override\r\n        public void installPackage(String s, boolean b, String... strings) throws InstallException {\r\n            throw new InstallException(\"Failed to install on test device.\", null);\r\n        }\r\n    };\r\n    device.setSerialNumber(\"serial#1\");\r\n    device.setName(\"testDevice\");\r\n    assertFalse(createAndroidDevice(device).installApkOnDevice(apk, false, false, false));\r\n}"
}, {
	"Path": "com.facebook.buck.android.exopackage.RealAndroidDeviceTest.testFailedDeviceInstallWithException",
	"Comment": "verify that if exception is thrown during installation, installation is marked as failed.",
	"Method": "void testFailedDeviceInstallWithException(){\r\n    throw new InstallException(\"Failed to install on test device.\", null);\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.abi.source.TreeBackedExecutableElementTest.testGetReceiverTypeOfStaticIsNull",
	"Comment": "the docs claim this should be a notype of typekind.none. the docs lie.",
	"Method": "void testGetReceiverTypeOfStaticIsNull(){\r\n    compile(Joiner.on('\\n').join(\"class Foo {\", \"  static void foo() { }\", \"}\"));\r\n    ExecutableElement element = findMethod(\"foo\", elements.getTypeElement(\"Foo\"));\r\n    TypeMirror receiverType = element.getReceiverType();\r\n    assertNull(receiverType);\r\n}"
}, {
	"Path": "com.facebook.buck.rules.coercer.ParamInfo.getResultClass",
	"Comment": "returns the type that input values will be coerced to. return the type parameter of optional ifwrapped in optional.",
	"Method": "Class<?> getResultClass(){\r\n    return typeCoercer.getOutputClass();\r\n}"
}, {
	"Path": "com.android.common.xml.AndroidManifest.hasVersionCode",
	"Comment": "returns whether the version code attribute is set in a given manifest.",
	"Method": "boolean hasVersionCode(IAbstractFile manifestFile){\r\n    return getVersionCode(manifestFile) != -1;\r\n}"
}, {
	"Path": "com.facebook.buck.event.DefaultBuckEventBus.timestamp",
	"Comment": "timestamp event. a timestamped event cannot subsequently being posted and is useful only topass its timestamp on to another posted event.",
	"Method": "void timestamp(BuckEvent event){\r\n    Long threadId = threadIdSupplier.get();\r\n    event.configure(clock.currentTimeMillis(), clock.nanoTime(), clock.threadUserNanoTime(threadId), threadId, buildId);\r\n}"
}, {
	"Path": "com.android.dx.dex.code.PositionList.make",
	"Comment": "extracts and returns the source position information out of aninstruction list.",
	"Method": "PositionList make(DalvInsnList insns,int howMuch){\r\n    switch(howMuch) {\r\n        case NONE:\r\n            {\r\n                return EMPTY;\r\n            }\r\n        case LINES:\r\n        case IMPORTANT:\r\n            {\r\n                break;\r\n            }\r\n        default:\r\n            {\r\n                throw new IllegalArgumentException(\"bogus howMuch\");\r\n            }\r\n    }\r\n    SourcePosition noInfo = SourcePosition.NO_INFO;\r\n    SourcePosition cur = noInfo;\r\n    int sz = insns.size();\r\n    PositionList.Entry[] arr = new PositionList.Entry[sz];\r\n    boolean lastWasTarget = false;\r\n    int at = 0;\r\n    for (int i = 0; i < sz; i++) {\r\n        DalvInsn insn = insns.get(i);\r\n        if (insn instanceof CodeAddress) {\r\n            lastWasTarget = true;\r\n            ;\r\n            continue;\r\n        }\r\n        SourcePosition pos = insn.getPosition();\r\n        if (pos.equals(noInfo) || pos.sameLine(cur)) {\r\n            continue;\r\n        }\r\n        if ((howMuch == IMPORTANT) && !lastWasTarget) {\r\n            continue;\r\n        }\r\n        cur = pos;\r\n        arr[at] = new PositionList.Entry(insn.getAddress(), pos);\r\n        at++;\r\n        lastWasTarget = false;\r\n    }\r\n    PositionList result = new PositionList(at);\r\n    for (int i = 0; i < at; i++) {\r\n        result.set(i, arr[i]);\r\n    }\r\n    result.setImmutable();\r\n    return result;\r\n}"
}, {
	"Path": "com.facebook.buck.rules.coercer.CoercedTypeCache.instantiateSkeleton",
	"Comment": "returns an unpopulated dto object, and the build method which must be called with it when it isfinished being populated.",
	"Method": "Pair<Object, Function<Object, T>> instantiateSkeleton(Class<T> dtoType,BuildTarget buildTarget){\r\n    try {\r\n        Object builder = dtoType.getMethod(\"builder\").invoke(null);\r\n        Method buildMethod = builder.getClass().getMethod(\"build\");\r\n        return new Pair(builder, x -> {\r\n            try {\r\n                return (T) buildMethod.invoke(x);\r\n            } catch (IllegalAccessException e) {\r\n                throw new IllegalStateException(String.format(\"Error building immutable constructor arg for %s: %s\", buildTarget, e.getMessage()), e);\r\n            } catch (InvocationTargetException e) {\r\n                if (e.getCause() instanceof IllegalStateException) {\r\n                    IllegalStateException cause = (IllegalStateException) e.getCause();\r\n                    if (cause.getMessage().contains(\"Cannot build\") && cause.getMessage().contains(\"required\")) {\r\n                        List<String> matches = Splitter.on(CharMatcher.anyOf(\"[]\")).splitToList(cause.getMessage());\r\n                        if (matches.size() >= 2) {\r\n                            throw new HumanReadableException(\"%s missing required argument(s): %s\", buildTarget, matches.get(1));\r\n                        }\r\n                    }\r\n                }\r\n                throw new RuntimeException(String.format(\"Error building immutable constructor arg for %s: %s\", buildTarget, e.getCause().getMessage()), e.getCause());\r\n            }\r\n        });\r\n    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\r\n        throw new IllegalStateException(String.format(\"Could not instantiate immutable constructor arg type %s: %s\", dtoType, e.getMessage()), e);\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getCByte",
	"Comment": "gets the c register number, as a byte. this will throw if thevalue is out of the range of an unsigned byte.",
	"Method": "short getCByte(){\r\n    int c = getC();\r\n    if ((c & ~0xff) != 0) {\r\n        throw new DexException(\"Register C out of range: \" + Hex.u8(c));\r\n    }\r\n    return (short) c;\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.DistBuildTraceTracker.updateWork",
	"Comment": "update tracker state with just finished targets, and targets to be executed.",
	"Method": "void updateWork(String minionId,List<String> finishedRules,List<WorkUnit> newWorkUnits){\r\n    long now = clock.currentTimeMillis();\r\n    minionFinishedWork(minionId, finishedRules, now);\r\n    minionGotWork(newWorkUnits, now);\r\n}"
}, {
	"Path": "com.android.dx.merge.DexMerger.readSortableTypes",
	"Comment": "reads just enough data on each class so that we can sort it and then findit later.",
	"Method": "void readSortableTypes(SortableType[] sortableTypes,Dex buffer,IndexMap indexMap){\r\n    for (ClassDef classDef : buffer.classDefs()) {\r\n        SortableType sortableType = indexMap.adjust(new SortableType(buffer, indexMap, classDef));\r\n        int t = sortableType.getTypeIndex();\r\n        if (sortableTypes[t] == null) {\r\n            sortableTypes[t] = sortableType;\r\n        } else if (collisionPolicy != CollisionPolicy.KEEP_FIRST) {\r\n            throw new DexException(\"Multiple dex files define \" + buffer.typeNames().get(classDef.getTypeIndex()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.rules.keys.RuleKeyDiagnostics.processRule",
	"Comment": "computes the diagnostic rulekey data for the given rule and all of its appendables recursively.previously processed rules and appendables are skipped and not fed to the consumer. results forthe newly processed rule and appendables are fed to the consumer, but not stored otherwise.only information of whether something has been processed or not gets stored.",
	"Method": "void processRule(BuildRule rule,Consumer<Result<RULE_KEY, DIAG_KEY>> resultConsumer){\r\n    if (!computed.add(rule)) {\r\n        return;\r\n    }\r\n    Queue<AddsToRuleKey> appendableQueue = new LinkedList();\r\n    Result<RULE_KEY, DIAG_KEY> result = ruleResultSupplier.apply(rule);\r\n    Iterables.addAll(appendableQueue, result.appendables);\r\n    resultConsumer.accept(result);\r\n    while (!appendableQueue.isEmpty()) {\r\n        AddsToRuleKey appendable = appendableQueue.remove();\r\n        if (computed.add(appendable)) {\r\n            result = appendableResultSupplier.apply(appendable);\r\n            Iterables.addAll(appendableQueue, result.appendables);\r\n            resultConsumer.accept(result);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.util.SimpleProcessListener.getStdout",
	"Comment": "gets the entire contents of stdout sent by the process. only call this after the process hasexited.",
	"Method": "String getStdout(){\r\n    Preconditions.checkState(process != null, \"Process didn't start yet\");\r\n    Preconditions.checkState(!process.isRunning(), \"Process must not still be running\");\r\n    return stdout.toString();\r\n}"
}, {
	"Path": "com.facebook.buck.parser.cache.impl.FakeManifestService.setManifest",
	"Comment": "sets the manifest for key. overwrites existing one if it already exists.",
	"Method": "ListenableFuture<Void> setManifest(Manifest manifest){\r\n    return addToManifestBackingCollection(manifest);\r\n}"
}, {
	"Path": "com.android.dx.cf.direct.StdAttributeFactory.throwSeverelyTruncated",
	"Comment": "throws the right exception when a known attribute has a way too shortlength.",
	"Method": "Attribute throwSeverelyTruncated(){\r\n    throw new ParseException(\"severely truncated attribute\");\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.endtoend.EndToEndWorkspace.runBuiltResult",
	"Comment": "runs the process that is built by the given fully qualified target name. the program should bealready built to run it.",
	"Method": "ProcessResult runBuiltResult(String target,String args){\r\n    String fullTarget = EndToEndHelper.getProperBuildTarget(target);\r\n    ProcessResult targetsResult = runBuckCommand(ranWithBuckd, \"targets\", fullTarget, \"--show-output\");\r\n    if (targetsResult.getExitCode().getCode() > 0) {\r\n        throw new RuntimeException(\"buck targets command getting outputPath failed: \" + targetsResult.getStderr());\r\n    }\r\n    String[] targetsOutput = targetsResult.getStdout().split(\" \");\r\n    if (targetsOutput.length != 2) {\r\n        throw new IllegalStateException(\"Expect to receive single target and path pair from buck targets --show-output, got:\" + targetsResult.getStdout());\r\n    }\r\n    String outputPath = targetsOutput[1].replaceAll(\"[ \\n]\", \"\");\r\n    ImmutableList.Builder<String> commandBuilder = platformUtils.getCommandBuilder();\r\n    List<String> command = commandBuilder.add(outputPath).addAll(ImmutableList.copyOf(args)).build();\r\n    return runCommand(ranWithBuckd, ImmutableMap.<String, String>builder().build(), command, Optional.of(buildResultTimeoutMS));\r\n}"
}, {
	"Path": "com.facebook.buck.shell.Shell.shellQuoteJoin",
	"Comment": "quotes all strings using escaper.escapeasbashstring and joins them using sep. should be usedfor constructing bash command lines, for example in bash scripts.",
	"Method": "String shellQuoteJoin(Iterable<String> items,String sep){\r\n    return Joiner.on(sep).join(FluentIterable.from(items).transform(Escaper::escapeAsBashString));\r\n}"
}, {
	"Path": "com.android.manifmerger.OrphanXmlElement.getKey",
	"Comment": "returns the unique key for this xml element within the xml file or null if there can be onlyone element of this type.",
	"Method": "String getKey(){\r\n    return mType.getNodeKeyResolver().getKey(mXml);\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.Omnibus.createOmnibus",
	"Comment": "create a build rule to link the giant merged omnibus library described by the given spec.",
	"Method": "OmnibusLibrary createOmnibus(BuildTarget buildTarget,ProjectFilesystem projectFilesystem,CellPathResolver cellPathResolver,BuildRuleParams params,ActionGraphBuilder graphBuilder,SourcePathRuleFinder ruleFinder,CxxBuckConfig cxxBuckConfig,CxxPlatform cxxPlatform,ImmutableList<? extends Arg> extraLdflags,OmnibusSpec spec){\r\n    ImmutableList.Builder<Arg> argsBuilder = ImmutableList.builder();\r\n    argsBuilder.addAll(extraLdflags);\r\n    List<SourcePath> undefinedSymbolsOnlyRoots = new ArrayList();\r\n    for (BuildTarget target : Sets.difference(spec.getRoots().keySet(), spec.getGraph().getNodes())) {\r\n        NativeLinkTarget linkTarget = Objects.requireNonNull(spec.getRoots().get(target));\r\n        undefinedSymbolsOnlyRoots.add(graphBuilder.requireRule(getRootTarget(buildTarget, shouldCreateDummyRoot(linkTarget, cxxPlatform) ? getDummyRootTarget(target) : target)).getSourcePathToOutput());\r\n    }\r\n    argsBuilder.addAll(createUndefinedSymbolsArgs(buildTarget, projectFilesystem, params, graphBuilder, ruleFinder, cxxPlatform, undefinedSymbolsOnlyRoots));\r\n    ImmutableList<BuildTarget> targets = TopologicalSort.sort(spec.getGraph()).reverse();\r\n    for (BuildTarget target : targets) {\r\n        NativeLinkTarget root = spec.getRoots().get(target);\r\n        if (root != null) {\r\n            argsBuilder.add(SourcePathArg.of(graphBuilder.requireRule(getRootTarget(buildTarget, root.getBuildTarget())).getSourcePathToOutput()));\r\n            continue;\r\n        }\r\n        NativeLinkable nativeLinkable = Objects.requireNonNull(spec.getBody().get(target));\r\n        NativeLinkableInput input = NativeLinkables.getNativeLinkableInput(cxxPlatform, Linker.LinkableDepType.STATIC_PIC, nativeLinkable, graphBuilder);\r\n        argsBuilder.addAll(input.getArgs());\r\n    }\r\n    ImmutableList<NativeLinkable> deps = NativeLinkables.getNativeLinkables(cxxPlatform, graphBuilder, spec.getDeps().values(), Linker.LinkableDepType.SHARED);\r\n    for (NativeLinkable nativeLinkable : deps) {\r\n        NativeLinkableInput input = NativeLinkables.getNativeLinkableInput(cxxPlatform, Linker.LinkableDepType.SHARED, nativeLinkable, graphBuilder);\r\n        argsBuilder.addAll(input.getArgs());\r\n    }\r\n    BuildTarget omnibusTarget = buildTarget.withAppendedFlavors(OMNIBUS_FLAVOR);\r\n    String omnibusSoname = getOmnibusSoname(cxxPlatform);\r\n    CxxLink omnibusRule = graphBuilder.addToIndex(CxxLinkableEnhancer.createCxxLinkableSharedBuildRule(cxxBuckConfig, cxxPlatform, projectFilesystem, graphBuilder, ruleFinder, omnibusTarget, BuildTargetPaths.getGenPath(projectFilesystem, omnibusTarget, \"%s\").resolve(omnibusSoname), ImmutableMap.of(), Optional.of(omnibusSoname), argsBuilder.build(), cellPathResolver));\r\n    return OmnibusLibrary.of(omnibusSoname, omnibusRule.getSourcePathToOutput());\r\n}"
}, {
	"Path": "com.facebook.buck.util.concurrent.MostExecutors.forkJoinPoolWithThreadLimit",
	"Comment": "construct a forkjoinpool with a stricter thread limit.forkjoinpool by default will create a new thread to handle pending work whenever an existingthread becomes blocked on a task and cannot work steal. in cases when many tasks would block ona slow running dependency, it can trigger thread creation for all those tasks.note that limiting the maximum threads will impact the ability for managedblockers to causethe pool to create new worker threads, leading to potential deadlock if many managedblockersare used.",
	"Method": "ForkJoinPool forkJoinPoolWithThreadLimit(int parallelism,int spares){\r\n    AtomicInteger activeThreads = new AtomicInteger(0);\r\n    return new ForkJoinPool(parallelism, pool -> {\r\n        if (activeThreads.get() > parallelism + spares) {\r\n            return null;\r\n        }\r\n        return new ForkJoinWorkerThread(pool) {\r\n            @Override\r\n            protected void onStart() {\r\n                super.onStart();\r\n                activeThreads.incrementAndGet();\r\n            }\r\n            @Override\r\n            protected void onTermination(Throwable exception) {\r\n                activeThreads.decrementAndGet();\r\n                super.onTermination(exception);\r\n            }\r\n        };\r\n    }, null, false);\r\n}"
}, {
	"Path": "com.facebook.buck.util.concurrent.MostExecutors.forkJoinPoolWithThreadLimit",
	"Comment": "construct a forkjoinpool with a stricter thread limit.forkjoinpool by default will create a new thread to handle pending work whenever an existingthread becomes blocked on a task and cannot work steal. in cases when many tasks would block ona slow running dependency, it can trigger thread creation for all those tasks.note that limiting the maximum threads will impact the ability for managedblockers to causethe pool to create new worker threads, leading to potential deadlock if many managedblockersare used.",
	"Method": "ForkJoinPool forkJoinPoolWithThreadLimit(int parallelism,int spares){\r\n    super.onStart();\r\n    activeThreads.incrementAndGet();\r\n}"
}, {
	"Path": "com.facebook.buck.util.concurrent.MostExecutors.forkJoinPoolWithThreadLimit",
	"Comment": "construct a forkjoinpool with a stricter thread limit.forkjoinpool by default will create a new thread to handle pending work whenever an existingthread becomes blocked on a task and cannot work steal. in cases when many tasks would block ona slow running dependency, it can trigger thread creation for all those tasks.note that limiting the maximum threads will impact the ability for managedblockers to causethe pool to create new worker threads, leading to potential deadlock if many managedblockersare used.",
	"Method": "ForkJoinPool forkJoinPoolWithThreadLimit(int parallelism,int spares){\r\n    activeThreads.decrementAndGet();\r\n    super.onTermination(exception);\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.DistBuildUtil.generateMinionId",
	"Comment": "from buildslave runid generates id for a minion running on this buildslave host.",
	"Method": "String generateMinionId(BuildSlaveRunId buildSlaveRunId){\r\n    Preconditions.checkState(!buildSlaveRunId.getId().isEmpty());\r\n    String hostname = \"Unknown\";\r\n    try {\r\n        InetAddress addr;\r\n        addr = InetAddress.getLocalHost();\r\n        hostname = addr.getHostName();\r\n    } catch (UnknownHostException ex) {\r\n        LOG.warn(\"Hostname can not be resolved - it will not be included in Minion ID.\");\r\n    }\r\n    return String.format(\"minion:%s:%s\", hostname, buildSlaveRunId);\r\n}"
}, {
	"Path": "com.facebook.buck.skylark.parser.SkylarkProjectBuildFileParser.using",
	"Comment": "create an instance of skylark project build file parser using provided options.",
	"Method": "SkylarkProjectBuildFileParser using(ProjectBuildFileParserOptions options,BuckEventBus buckEventBus,FileSystem fileSystem,BuckGlobals buckGlobals,EventHandler eventHandler,GlobberFactory globberFactory){\r\n    return new SkylarkProjectBuildFileParser(options, buckEventBus, fileSystem, buckGlobals, eventHandler, globberFactory);\r\n}"
}, {
	"Path": "com.android.dx.dex.file.OffsettedItem.place",
	"Comment": "indicates that this item has been added to the given section atthe given offset. it is only valid to call this method once perinstance.",
	"Method": "int place(Section addedTo,int offset){\r\n    if (addedTo == null) {\r\n        throw new NullPointerException(\"addedTo == null\");\r\n    }\r\n    if (offset < 0) {\r\n        throw new IllegalArgumentException(\"offset < 0\");\r\n    }\r\n    if (this.addedTo != null) {\r\n        throw new RuntimeException(\"already written\");\r\n    }\r\n    int mask = alignment - 1;\r\n    offset = (offset + mask) & ~mask;\r\n    this.addedTo = addedTo;\r\n    this.offset = offset;\r\n    place0(addedTo, offset);\r\n    return offset;\r\n}"
}, {
	"Path": "com.facebook.buck.util.Console.printFailureWithStacktrace",
	"Comment": "prints error message to console in red, logs and displays stacktrace",
	"Method": "void printFailureWithStacktrace(Throwable t,String failureMessage){\r\n    printFailure(t, failureMessage);\r\n    t.printStackTrace(stdErr);\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.CxxLibraryFactory.createStaticLibraryBuildRule",
	"Comment": "create all build rules needed to generate the static library.",
	"Method": "BuildRule createStaticLibraryBuildRule(BuildTarget buildTarget,ProjectFilesystem projectFilesystem,ActionGraphBuilder graphBuilder,CellPathResolver cellRoots,CxxBuckConfig cxxBuckConfig,CxxPlatform cxxPlatform,CxxLibraryDescriptionArg args,ImmutableSet<BuildRule> deps,PicType pic,CxxLibraryDescription.TransitiveCxxPreprocessorInputFunction transitiveCxxPreprocessorInputFunction,Optional<CxxLibraryDescriptionDelegate> delegate){\r\n    SourcePathRuleFinder ruleFinder = new SourcePathRuleFinder(graphBuilder);\r\n    SourcePathResolver sourcePathResolver = DefaultSourcePathResolver.from(ruleFinder);\r\n    ImmutableList<SourcePath> objects = requireObjects(buildTarget, projectFilesystem, graphBuilder, sourcePathResolver, ruleFinder, cellRoots, cxxBuckConfig, cxxPlatform, pic, args, deps, transitiveCxxPreprocessorInputFunction, delegate);\r\n    BuildTarget staticTarget = CxxDescriptionEnhancer.createStaticLibraryBuildTarget(buildTarget, cxxPlatform.getFlavor(), pic);\r\n    if (objects.isEmpty()) {\r\n        return new NoopBuildRule(staticTarget, projectFilesystem) {\r\n            @Override\r\n            public SortedSet<BuildRule> getBuildDeps() {\r\n                return ImmutableSortedSet.of();\r\n            }\r\n        };\r\n    }\r\n    Path staticLibraryPath = CxxDescriptionEnhancer.getStaticLibraryPath(projectFilesystem, buildTarget, cxxPlatform.getFlavor(), pic, args.getStaticLibraryBasename(), cxxPlatform.getStaticLibraryExtension(), cxxBuckConfig.isUniqueLibraryNameEnabled());\r\n    return Archive.from(staticTarget, projectFilesystem, graphBuilder, ruleFinder, cxxPlatform, cxxBuckConfig.getArchiveContents(), staticLibraryPath, ImmutableList.copyOf(objects), true);\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.CxxLibraryFactory.createStaticLibraryBuildRule",
	"Comment": "create all build rules needed to generate the static library.",
	"Method": "BuildRule createStaticLibraryBuildRule(BuildTarget buildTarget,ProjectFilesystem projectFilesystem,ActionGraphBuilder graphBuilder,CellPathResolver cellRoots,CxxBuckConfig cxxBuckConfig,CxxPlatform cxxPlatform,CxxLibraryDescriptionArg args,ImmutableSet<BuildRule> deps,PicType pic,CxxLibraryDescription.TransitiveCxxPreprocessorInputFunction transitiveCxxPreprocessorInputFunction,Optional<CxxLibraryDescriptionDelegate> delegate){\r\n    return ImmutableSortedSet.of();\r\n}"
}, {
	"Path": "com.facebook.buck.rules.coercer.AbstractSourceSet.concat",
	"Comment": "concatenates elements of the given lists into a single list.",
	"Method": "SourceSet concat(Iterable<SourceSet> elements){\r\n    Type type = findType(elements);\r\n    if (type == Type.UNNAMED) {\r\n        return concatUnnamed(elements);\r\n    } else {\r\n        return concatNamed(elements);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.android.exopackage.RealAndroidDeviceTest.testSuccessfulDeviceInstall",
	"Comment": "verify that successful installation on device results in true.",
	"Method": "void testSuccessfulDeviceInstall(){\r\n    File apk = new File(\"/some/file.apk\");\r\n    AtomicReference<String> apkPath = new AtomicReference();\r\n    TestDevice device = new TestDevice() {\r\n        @Override\r\n        public void installPackage(String s, boolean b, String... strings) {\r\n            apkPath.set(s);\r\n        }\r\n    };\r\n    device.setSerialNumber(\"serial#1\");\r\n    device.setName(\"testDevice\");\r\n    assertTrue(createAndroidDevice(device).installApkOnDevice(apk, false, false, false));\r\n    assertEquals(apk.getAbsolutePath(), apkPath.get());\r\n}"
}, {
	"Path": "com.facebook.buck.android.exopackage.RealAndroidDeviceTest.testSuccessfulDeviceInstall",
	"Comment": "verify that successful installation on device results in true.",
	"Method": "void testSuccessfulDeviceInstall(){\r\n    apkPath.set(s);\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_client.BuildRuleEventManager.recordBuildRuleUnlockedEvent",
	"Comment": "records the receipt of a buildruleunlocked event. as this indicates that remote machines takingpart in the build will not be uploading artifacts for the rule, we signal immediately that ruleneeds to be unlocked to allow local client to progress with the build.",
	"Method": "void recordBuildRuleUnlockedEvent(String buildTarget){\r\n    LOG.debug(String.format(\"Received BUILD_RULE_UNLOCKED_EVENT for [%s].\", buildTarget));\r\n    remoteBuildRuleCompletionNotifier.signalUnlockedBuildRule(buildTarget);\r\n}"
}, {
	"Path": "com.facebook.buck.io.filesystem.impl.DefaultProjectFilesystem.shouldVerifyConstructorArguments",
	"Comment": "for testing purposes, subclasses might want to skip some of the verification done by theconstructor on its arguments.",
	"Method": "boolean shouldVerifyConstructorArguments(){\r\n    return true;\r\n}"
}, {
	"Path": "com.facebook.buck.parser.ParserIntegrationTest.testAllowEmptyGlob",
	"Comment": "by default a glob call returning no results will not cause the build to fail.",
	"Method": "void testAllowEmptyGlob(){\r\n    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(this, \"allow_empty_glob\", temporaryFolder);\r\n    workspace.setUp();\r\n    ProcessResult result = workspace.runBuckCommand(\"build\", \"//:root_module\");\r\n    result.assertSuccess(\"buck build should ignore empty glob results by default\");\r\n}"
}, {
	"Path": "com.android.manifmerger.XmlElement.calculateNodeOperationType",
	"Comment": "calculate the effective node operation type for a higher priority node when a lower prioritynode is queried for merge.",
	"Method": "NodeOperationType calculateNodeOperationType(XmlElement higherPriority,XmlElement lowerPriority){\r\n    @NonNull\r\n    NodeOperationType operationType = higherPriority.getOperationType();\r\n    if (higherPriority.supportsSelector() && higherPriority.mSelector != null && !higherPriority.mSelector.appliesTo(lowerPriority)) {\r\n        operationType = NodeOperationType.MERGE;\r\n    }\r\n    return operationType;\r\n}"
}, {
	"Path": "com.facebook.buck.artifact_cache.SQLiteArtifactCacheTest.writeInlinedArtifact",
	"Comment": "writes an artifact small enough to inline in the database.uses the pathname to guarantee that files have different content for testing overwrites.",
	"Method": "void writeInlinedArtifact(Path file){\r\n    Files.write(file, file.toString().getBytes(UTF_8), StandardOpenOption.CREATE, StandardOpenOption.APPEND);\r\n}"
}, {
	"Path": "com.facebook.buck.rules.modern.builders.ModernBuildRuleBuilderFactory.createReconstructing",
	"Comment": "the reconstructing strategy serializes and deserializes the build rule in memory and builds thedeserialized version.",
	"Method": "BuildRuleStrategy createReconstructing(SourcePathRuleFinder ruleFinder,CellPathResolver cellResolver,Cell rootCell){\r\n    return new ReconstructingStrategy(ruleFinder, cellResolver, rootCell);\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.DistBuildSlaveExecutor.onBuildSlavePreparationCompleted",
	"Comment": "register a callback to be executed after the preparation is complete and the actual build isabout to start. this function does not guarantee that the actual build has not started, but itdoes guarantee that the preparation has finished when the callback is executed.",
	"Method": "void onBuildSlavePreparationCompleted(Runnable callback){\r\n    boolean alreadyCompleted;\r\n    synchronized (buildPreparationLock) {\r\n        this.postPreparationCallback = Optional.of(callback);\r\n        alreadyCompleted = buildPreparationCompleted;\r\n    }\r\n    if (alreadyCompleted) {\r\n        callback.run();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.abi.source.TreeBackedElements.getTypeElement",
	"Comment": "gets the type element with the given name. if a class with the given name is referenced in thecode or exists in the classpath, returns the corresponding element. otherwise returns null.",
	"Method": "TypeElement getTypeElement(CharSequence fullyQualifiedCharSequence){\r\n    Name fullyQualifiedName = getName(fullyQualifiedCharSequence);\r\n    if (!knownTypes.containsKey(fullyQualifiedName)) {\r\n        TypeElement javacElement = javacElements.getTypeElement(fullyQualifiedName);\r\n        if (javacElement != null) {\r\n            return javacElement;\r\n        }\r\n    }\r\n    return knownTypes.get(fullyQualifiedName);\r\n}"
}, {
	"Path": "com.facebook.buck.io.filesystem.impl.DefaultProjectFilesystem.getPosixFilePermissions",
	"Comment": "returns the set of posix file permissions, or the empty set if the underlying file system doesnot support posix file attributes.",
	"Method": "Set<PosixFilePermission> getPosixFilePermissions(Path path){\r\n    Path resolvedPath = getPathForRelativePath(path);\r\n    if (Files.getFileAttributeView(resolvedPath, PosixFileAttributeView.class) != null) {\r\n        return Files.getPosixFilePermissions(resolvedPath);\r\n    } else {\r\n        return ImmutableSet.of();\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.dex.code.InsnFormat.signedFitsInShort",
	"Comment": "helper method to determine if a signed int value fits in a short.",
	"Method": "boolean signedFitsInShort(int value){\r\n    return (short) value == value;\r\n}"
}, {
	"Path": "com.facebook.buck.event.chrome_trace.ChromeTraceWriter.writeStart",
	"Comment": "must be called prior to emitting first event to properly initialize stream.",
	"Method": "void writeStart(){\r\n    jsonGenerator.writeStartArray();\r\n}"
}, {
	"Path": "com.facebook.buck.versions.AbstractFlavorSearchTargetNodeFinder.check",
	"Comment": "verify that base targets correctly correspond to their node.",
	"Method": "void check(){\r\n    for (Map.Entry<BuildTarget, TargetNode> ent : getBaseTargetIndex().entrySet()) {\r\n        Preconditions.checkArgument(ent.getValue().getBuildTarget().getUnflavoredBuildTarget().equals(ent.getKey().getUnflavoredBuildTarget()));\r\n        Preconditions.checkArgument(ent.getValue().getBuildTarget().getFlavors().containsAll(ent.getKey().getFlavors()));\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.cf.code.RopperMachine.getExtraBlockCount",
	"Comment": "gets how many extra blocks will be needed to represent theblock currently being translated. each extra block should consistof one instruction from the end of the original block.",
	"Method": "int getExtraBlockCount(){\r\n    return extraBlockCount;\r\n}"
}, {
	"Path": "com.facebook.buck.rules.modern.builders.ModernBuildRuleBuilderFactory.createPassthrough",
	"Comment": "the passthrough strategy just forwards to executorrunner.runwithdefaultexecutor.",
	"Method": "BuildRuleStrategy createPassthrough(){\r\n    return new AbstractModernBuildRuleStrategy() {\r\n        @Override\r\n        public StrategyBuildResult build(BuildRule rule, BuildStrategyContext strategyContext) {\r\n            return StrategyBuildResult.nonCancellable(Futures.submitAsync(strategyContext::runWithDefaultBehavior, strategyContext.getExecutorService()));\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.facebook.buck.rules.modern.builders.ModernBuildRuleBuilderFactory.createPassthrough",
	"Comment": "the passthrough strategy just forwards to executorrunner.runwithdefaultexecutor.",
	"Method": "BuildRuleStrategy createPassthrough(){\r\n    return StrategyBuildResult.nonCancellable(Futures.submitAsync(strategyContext::runWithDefaultBehavior, strategyContext.getExecutorService()));\r\n}"
}, {
	"Path": "com.facebook.buck.swift.SwiftBuckConfig.getProjectAddASTPaths",
	"Comment": "if enabled, ast paths to the .swiftmodules will be added as part of the linker invocation. thisis necessary for lldb to be able to debug statically linked swift libraries.",
	"Method": "boolean getProjectAddASTPaths(){\r\n    return delegate.getBooleanValue(SECTION_NAME, PROJECT_ADD_AST_PATHS, false);\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.toolchain.CxxBuckConfig.getArchiverProvider",
	"Comment": "constructs the appropriate archiver for the specified platform.",
	"Method": "Optional<ArchiverProvider> getArchiverProvider(Platform defaultPlatform){\r\n    Optional<ToolProvider> toolProvider = delegate.getView(ToolConfig.class).getToolProvider(cxxSection, AR);\r\n    Optional<ArchiverProvider.Type> type = delegate.getEnum(cxxSection, ARCHIVER_TYPE, ArchiverProvider.Type.class);\r\n    return toolProvider.map(archiver -> {\r\n        Optional<Platform> archiverPlatform = delegate.getEnum(cxxSection, ARCHIVER_PLATFORM, Platform.class);\r\n        return ArchiverProvider.from(archiver, archiverPlatform.orElse(defaultPlatform), type);\r\n    });\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.DefaultClassUsageFileReader.getAbsolutePathForCellRootedPath",
	"Comment": "convert a path rooted in another cell to an absolute path in the filesystem",
	"Method": "Path getAbsolutePathForCellRootedPath(Path cellRootedPath,CellPathResolver cellPathResolver){\r\n    Preconditions.checkArgument(cellRootedPath.isAbsolute(), \"Path must begin with /<cell_name>\");\r\n    Iterator<Path> pathIterator = cellRootedPath.iterator();\r\n    Path cellName = pathIterator.next();\r\n    Path relativeToCellRoot = pathIterator.next();\r\n    while (pathIterator.hasNext()) {\r\n        relativeToCellRoot = relativeToCellRoot.resolve(pathIterator.next());\r\n    }\r\n    return cellPathResolver.getCellPathOrThrow(Optional.of(cellName.toString())).resolve(relativeToCellRoot);\r\n}"
}, {
	"Path": "com.facebook.buck.parser.implicit.AbstractImplicitInclude.getLoadPath",
	"Comment": "returns the load path for the given path. skylarkimport is used to eagerly compute fewerobjects up front and centralize error handling",
	"Method": "SkylarkImport getLoadPath(){\r\n    String label = getRawImportLabel();\r\n    try {\r\n        return SkylarkImports.create(label);\r\n    } catch (SkylarkImportSyntaxException e) {\r\n        throw new HumanReadableException(e, \"Invalid implicit label provided: %s\", label);\r\n    }\r\n}"
}, {
	"Path": "com.android.manifmerger.ManifestMerger2.merge",
	"Comment": "merge the optionally existing xmldocument with a lower priority xml file.",
	"Method": "MergingReport merge(Optional<XmlDocument> merge,Optional<XmlDocument> xmlDocument,LoadedManifestInfo lowerPriorityDocument,MergingReport.Builder mergingReportBuilder,MergingReport merge){\r\n    MergingReport.Result validationResult = PreValidator.validate(mergingReportBuilder, lowerPriorityDocument.getXmlDocument());\r\n    if (validationResult == MergingReport.Result.ERROR) {\r\n        mergingReportBuilder.addMessage(lowerPriorityDocument.getXmlDocument().getSourceFile(), MergingReport.Record.Severity.ERROR, \"Validation failed, exiting\");\r\n        return Optional.absent();\r\n    }\r\n    Optional<XmlDocument> result;\r\n    if (xmlDocument.isPresent()) {\r\n        result = xmlDocument.get().merge(lowerPriorityDocument.getXmlDocument(), mergingReportBuilder);\r\n    } else {\r\n        mergingReportBuilder.getActionRecorder().recordDefaultNodeAction(lowerPriorityDocument.getXmlDocument().getRootNode());\r\n        result = Optional.of(lowerPriorityDocument.getXmlDocument());\r\n    }\r\n    if (mOptionalFeatures.contains(Invoker.Feature.KEEP_INTERMEDIARY_STAGES) && result.isPresent()) {\r\n        mergingReportBuilder.addMergingStage(result.get().prettyPrint());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.android.dx.dex.cf.AttributeTranslator.getParameterAnnotations",
	"Comment": "gets the parameter annotations out of a given method. thiscombines both visible and invisible annotations into a singleresult set.",
	"Method": "AnnotationsList getParameterAnnotations(Method method){\r\n    AttributeList attribs = method.getAttributes();\r\n    AttRuntimeVisibleParameterAnnotations visible = (AttRuntimeVisibleParameterAnnotations) attribs.findFirst(AttRuntimeVisibleParameterAnnotations.ATTRIBUTE_NAME);\r\n    AttRuntimeInvisibleParameterAnnotations invisible = (AttRuntimeInvisibleParameterAnnotations) attribs.findFirst(AttRuntimeInvisibleParameterAnnotations.ATTRIBUTE_NAME);\r\n    if (visible == null) {\r\n        if (invisible == null) {\r\n            return AnnotationsList.EMPTY;\r\n        }\r\n        return invisible.getParameterAnnotations();\r\n    }\r\n    if (invisible == null) {\r\n        return visible.getParameterAnnotations();\r\n    }\r\n    return AnnotationsList.combine(visible.getParameterAnnotations(), invisible.getParameterAnnotations());\r\n}"
}, {
	"Path": "com.facebook.buck.rules.keys.AbstractRuleKeyBuilder.build",
	"Comment": "a convenience method that builds the rule key hash and transforms it with a mapper.",
	"Method": "RULE_KEY build(RESULT build,Function<RULE_KEY, RESULT> mapper){\r\n    return mapper.apply(build());\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getENibble",
	"Comment": "gets the e register number, as a nibble. this will throw if thevalue is out of the range of an unsigned nibble.",
	"Method": "short getENibble(){\r\n    int e = getE();\r\n    if ((e & ~0xf) != 0) {\r\n        throw new DexException(\"Register E out of range: \" + Hex.u8(e));\r\n    }\r\n    return (short) e;\r\n}"
}, {
	"Path": "com.facebook.buck.features.apple.project.ProjectGenerator.isBuiltByCurrentProject",
	"Comment": "whether a given build target is built by the project being generated, or being build elsewhere.",
	"Method": "boolean isBuiltByCurrentProject(BuildTarget buildTarget){\r\n    return initialTargets.contains(buildTarget);\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.DistBuildSlaveEventBusListener.publishServerSideBuildSlaveFinishedStatsEvent",
	"Comment": "sends a serversidebuildslavefinishedstatsevent to the given buckeventbus",
	"Method": "void publishServerSideBuildSlaveFinishedStatsEvent(BuckEventBus eventBus){\r\n    BuildSlaveFinishedStats buildSlaveFinishedStats = createBuildSlaveFinishedStats();\r\n    ServerSideBuildSlaveFinishedStatsEvent event = new ServerSideBuildSlaveFinishedStatsEvent(stampedeId, buildSlaveRunId, buildLabel, minionType, buildSlaveFinishedStats);\r\n    eventBus.post(event);\r\n}"
}, {
	"Path": "com.facebook.buck.android.toolchain.ndk.impl.NdkCxxPlatformTest.testExtraNdkFlagsLiterally",
	"Comment": "ndk platform flags so that such changes can actually be reviewed.",
	"Method": "void testExtraNdkFlagsLiterally(){\r\n    Assume.assumeTrue(Platform.detect() != Platform.WINDOWS);\r\n    ProjectFilesystem filesystem = TestProjectFilesystems.createProjectFilesystem(tmp.getRoot());\r\n    Path ndkRoot = tmp.newFolder(\"android-ndk-r10b\");\r\n    NdkCxxPlatformTargetConfiguration targetConfiguration = NdkCxxPlatforms.getTargetConfiguration(TargetCpuType.X86, NdkCxxPlatformCompiler.builder().setType(NdkCompilerType.GCC).setVersion(\"gcc-version\").setGccVersion(\"clang-version\").build(), \"android-16\");\r\n    MostFiles.writeLinesToFile(ImmutableList.of(\"r9c\"), ndkRoot.resolve(\"RELEASE.TXT\"));\r\n    BuckConfig buckConfig = FakeBuckConfig.builder().setSections(ImmutableMap.of(\"ndk\", ImmutableMap.of(\"extra_cflags\", \"--start-extra-cflags-- -DSOME_CFLAG --end-extra-cflags--\", \"extra_cxxflags\", \"--start-extra-cxxflags-- -DSOME_CXXFLAG --end-extra-cxxflags--\"), \"cxx\", ImmutableMap.of(\"cxxflags\", \"-Wignored-cxx-flag\", \"cflags\", \"-Wignored-c-flag\", \"cppflags\", \"-Wignored-cpp-flag\"))).build();\r\n    NdkCxxPlatform platform = NdkCxxPlatforms.build(new CxxBuckConfig(buckConfig), new AndroidBuckConfig(buckConfig, Platform.detect()), filesystem, InternalFlavor.of(\"android-x86\"), Platform.detect(), ndkRoot, targetConfiguration, NdkCxxRuntime.GNUSTL, NdkCxxRuntimeType.DYNAMIC, new AlwaysFoundExecutableFinder(), false);\r\n    Joiner joiner = Joiner.on(\"\\n\");\r\n    CxxPlatform cxxPlatform = platform.getCxxPlatform();\r\n    DebugPathSanitizer sanitizer = cxxPlatform.getCompilerDebugPathSanitizer();\r\n    Path expectedFlags = TestDataHelper.getTestDataDirectory(this).resolve(\"ndkcxxplatforms.flags\");\r\n    String expected = Files.toString(expectedFlags.toFile(), Charsets.UTF_8);\r\n    String actual = String.format(\"---BEGIN CFLAGS-------\\n\" + \"%s\\n\" + \"---END CFLAGS---------\\n\" + \"----------------------\\n\" + \"======================\\n\" + \"----------------------\\n\" + \"---BEGIN CPPFLAGS-----\\n\" + \"%s\\n\" + \"---END CPPFLAGS-------\\n\" + \"----------------------\\n\" + \"======================\\n\" + \"----------------------\\n\" + \"---BEGIN CXXFLAGS-----\\n\" + \"%s\\n\" + \"---END CXXFLAGS-------\\n\" + \"----------------------\\n\" + \"======================\\n\" + \"----------------------\\n\" + \"---BEGIN CXXPPFLAGS---\\n\" + \"%s\\n\" + \"---END CXXPPFLAGS-----\\n\", joiner.join(sanitizer.sanitizeFlags(cxxPlatform.getCflags())), joiner.join(sanitizer.sanitizeFlags(cxxPlatform.getCppflags())), joiner.join(sanitizer.sanitizeFlags(cxxPlatform.getCxxflags())), joiner.join(sanitizer.sanitizeFlags(cxxPlatform.getCxxppflags())));\r\n    assertEquals(expected, actual);\r\n}"
}, {
	"Path": "com.android.manifmerger.XmlElement.mergeChild",
	"Comment": "merge a child of a lower priority node into this higher priority node.",
	"Method": "void mergeChild(XmlElement lowerPriorityChild,MergingReport.Builder mergingReport){\r\n    ILogger logger = mergingReport.getLogger();\r\n    if (lowerPriorityChild.getType() == ManifestModel.NodeTypes.CUSTOM) {\r\n        handleCustomElement(lowerPriorityChild, mergingReport);\r\n        return;\r\n    }\r\n    Optional<XmlElement> thisChildOptional = getNodeByTypeAndKey(lowerPriorityChild.getType(), lowerPriorityChild.getKey());\r\n    if (!thisChildOptional.isPresent()) {\r\n        addElement(lowerPriorityChild, mergingReport);\r\n        return;\r\n    }\r\n    logger.verbose(lowerPriorityChild.getId() + \" defined in both files...\");\r\n    XmlElement thisChild = thisChildOptional.get();\r\n    switch(thisChild.getType().getMergeType()) {\r\n        case CONFLICT:\r\n            addMessage(mergingReport, MergingReport.Record.Severity.ERROR, String.format(\"Node %1$s cannot be present in more than one input file and it's \" + \"present at %2$s and %3$s\", thisChild.getType(), thisChild.printPosition(), lowerPriorityChild.printPosition()));\r\n            break;\r\n        case ALWAYS:\r\n            @NonNull\r\n            NodeOperationType operationType = calculateNodeOperationType(thisChild, lowerPriorityChild);\r\n            if (operationType == NodeOperationType.REMOVE || operationType == NodeOperationType.REPLACE) {\r\n                mergingReport.getActionRecorder().recordNodeAction(thisChild, Actions.ActionType.REJECTED, lowerPriorityChild);\r\n                break;\r\n            }\r\n            if (thisChild.getType().areMultipleDeclarationAllowed()) {\r\n                mergeChildrenWithMultipleDeclarations(lowerPriorityChild, mergingReport);\r\n            } else {\r\n                if (!thisChild.isEquals(lowerPriorityChild)) {\r\n                    addElement(lowerPriorityChild, mergingReport);\r\n                }\r\n            }\r\n            break;\r\n        default:\r\n            handleTwoElementsExistence(thisChild, lowerPriorityChild, mergingReport);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.core.HasDesugarSupport.isDesugarEnabled",
	"Comment": "desugar support for java 8 features withing single class file.such as lambda expressions, method references, repeating annotations",
	"Method": "boolean isDesugarEnabled(){\r\n    return false;\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.endtoend.EndToEndRunner.describeChild",
	"Comment": "needed for parentrunner implementation, describechild creates a testdescription from thetestmethod and the name we get from the test descriptor built off of environment configuration.",
	"Method": "Description describeChild(EndToEndTestDescriptor child){\r\n    if (setupError != null) {\r\n        return Description.createTestDescription(getTestClass().getJavaClass(), child.getName());\r\n    }\r\n    return Description.createTestDescription(getTestClass().getJavaClass(), child.getName(), child.getMethod().getAnnotations());\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_client.DistBuildControllerTest.setupExpectationsForSuccessfulDistBuildPrepStep",
	"Comment": "sets up mock expectations for a successful distributed build preparation step",
	"Method": "void setupExpectationsForSuccessfulDistBuildPrepStep(BuildJob job,BuildJobState buildJobState){\r\n    expect(mockDistBuildService.createBuild(invocationInfo.getBuildId(), BuildMode.REMOTE_BUILD, new MinionRequirements(), REPOSITORY, TENANT_ID, BUILD_TARGETS, BUILD_LABEL)).andReturn(job);\r\n    expect(mockDistBuildService.uploadMissingFilesAsync(distBuildCellIndexer.getLocalFilesystemsByCellIndex(), buildJobState.fileHashes, distBuildClientStatsTracker, directExecutor)).andReturn(Futures.immediateFuture(null));\r\n    expect(mockDistBuildService.uploadBuckDotFilesAsync(stampedeId, fakeProjectFilesystem, fakeFileHashCache, distBuildClientStatsTracker, directExecutor)).andReturn(Futures.immediateFuture(null));\r\n    mockDistBuildService.uploadTargetGraph(buildJobState, stampedeId, distBuildClientStatsTracker);\r\n    expectLastCall().once();\r\n    mockDistBuildService.setBuckVersion(stampedeId, buckVersion, distBuildClientStatsTracker);\r\n    expectLastCall().once();\r\n}"
}, {
	"Path": "com.android.dx.cf.code.Simulator.simulate",
	"Comment": "simulates the effect of the instruction at the given offset, bymaking appropriate calls on the given frame.",
	"Method": "void simulate(ByteBlock bb,Frame frame,int simulate,int offset,Frame frame){\r\n    visitor.setFrame(frame);\r\n    return code.parseInstruction(offset, visitor);\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.HeartbeatService.addCallback",
	"Comment": "add callback to be regularly called by the heartbeatservice and perform health checks.",
	"Method": "Closeable addCallback(String checkName,HeartbeatCallback callback){\r\n    ScheduledFuture<?> future = this.service.scheduleAtFixedRate(wrapHeartbeatCallback(callback), 0, intervalMillis, TimeUnit.MILLISECONDS);\r\n    return new Closeable() {\r\n        @Override\r\n        public void close() {\r\n            if (!future.cancel(true)) {\r\n                String msg = String.format(\"Failed to stop the heartbeart service for [%s] within [%d millis].\", checkName, MAX_WAIT_TIMEOUT_MILLIS);\r\n                LOG.error(msg);\r\n                throw new RuntimeException(msg);\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.HeartbeatService.addCallback",
	"Comment": "add callback to be regularly called by the heartbeatservice and perform health checks.",
	"Method": "Closeable addCallback(String checkName,HeartbeatCallback callback){\r\n    if (!future.cancel(true)) {\r\n        String msg = String.format(\"Failed to stop the heartbeart service for [%s] within [%d millis].\", checkName, MAX_WAIT_TIMEOUT_MILLIS);\r\n        LOG.error(msg);\r\n        throw new RuntimeException(msg);\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.merge.DexMerger.getSortedTypes",
	"Comment": "returns the union of classes from both files, sorted in order such thata class is always preceded by its supertype and implemented interfaces.",
	"Method": "SortableType[] getSortedTypes(){\r\n    SortableType[] sortableTypes = new SortableType[contentsOut.typeIds.size];\r\n    for (int i = 0; i < dexes.length; i++) {\r\n        readSortableTypes(sortableTypes, dexes[i], indexMaps[i]);\r\n    }\r\n    while (true) {\r\n        boolean allDone = true;\r\n        for (SortableType sortableType : sortableTypes) {\r\n            if (sortableType != null && !sortableType.isDepthAssigned()) {\r\n                allDone &= sortableType.tryAssignDepth(sortableTypes);\r\n            }\r\n        }\r\n        if (allDone) {\r\n            break;\r\n        }\r\n    }\r\n    Arrays.sort(sortableTypes, SortableType.NULLS_LAST_ORDER);\r\n    int firstNull = Arrays.asList(sortableTypes).indexOf(null);\r\n    return firstNull != -1 ? Arrays.copyOfRange(sortableTypes, 0, firstNull) : sortableTypes;\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.DistBuildService.uploadBuildSlaveEvents",
	"Comment": "publishes generic buildslaveevents, so that they can be downloaded by distributed build client.",
	"Method": "void uploadBuildSlaveEvents(StampedeId stampedeId,BuildSlaveRunId runId,List<BuildSlaveEvent> events){\r\n    Stopwatch watch = Stopwatch.createStarted();\r\n    LOG.debug(String.format(\"Uploading [%d] BuildSlaveEvents.\", events.size()));\r\n    AppendBuildSlaveEventsRequest request = new AppendBuildSlaveEventsRequest();\r\n    request.setStampedeId(stampedeId);\r\n    request.setBuildSlaveRunId(runId);\r\n    for (BuildSlaveEvent slaveEvent : events) {\r\n        request.addToEvents(ThriftUtil.serializeToByteBuffer(PROTOCOL_FOR_CLIENT_ONLY_STRUCTS, slaveEvent));\r\n    }\r\n    FrontendRequest frontendRequest = new FrontendRequest();\r\n    frontendRequest.setType(FrontendRequestType.APPEND_BUILD_SLAVE_EVENTS);\r\n    frontendRequest.setAppendBuildSlaveEventsRequest(request);\r\n    makeRequestChecked(frontendRequest);\r\n    LOG.debug(\"Uploaded [%d] BuildSlaveEvents in [%dms].\", events.size(), watch.elapsed(TimeUnit.MILLISECONDS));\r\n}"
}, {
	"Path": "com.facebook.buck.query.QueryParser.consumeIntLiteral",
	"Comment": "consumes the current token, which must be a word containing an integer literal. returns thatinteger, or throws a queryexception otherwise.",
	"Method": "int consumeIntLiteral(){\r\n    String intString = consume(TokenKind.WORD);\r\n    try {\r\n        return Integer.parseInt(intString);\r\n    } catch (NumberFormatException e) {\r\n        throw new QueryException(\"expected an integer literal but got '%s'\", intString);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.android.endtoend.AndroidEndToEndTest.shouldBuild",
	"Comment": "determines that buck successfully outputs proper programs",
	"Method": "void shouldBuild(EndToEndTestDescriptor test,EndToEndWorkspace workspace){\r\n    ProcessResult result = workspace.runBuckCommand(test);\r\n    result.assertSuccess(\"Did not successfully build\");\r\n}"
}, {
	"Path": "com.android.dx.dex.code.OutputFinisher.getAllConstants",
	"Comment": "returns the set of all constants referred to by instructions addedto this instance.",
	"Method": "HashSet<Constant> getAllConstants(){\r\n    HashSet<Constant> result = new HashSet<Constant>(20);\r\n    for (DalvInsn insn : insns) {\r\n        addConstants(result, insn);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.facebook.buck.util.ProcessHelper.getProcessResourceConsumption",
	"Comment": "gets resource consumption of the process with the given pid.",
	"Method": "ProcessResourceConsumption getProcessResourceConsumption(long pid){\r\n    try {\r\n        OperatingSystem os = OSHI.getOperatingSystem();\r\n        OSProcess process = os.getProcess((int) pid);\r\n        return getProcessResourceConsumptionInternal(process);\r\n    } catch (Exception ex) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.util.ListeningProcessExecutor.waitForProcess",
	"Comment": "blocks the calling thread until either the process exits or the timeout expires, whichever isfirst.",
	"Method": "int waitForProcess(LaunchedProcess process,long timeout,TimeUnit timeUnit,int waitForProcess,LaunchedProcess process){\r\n    long infiniteWait = 0;\r\n    int exitCode = waitForProcess(process, infiniteWait, TimeUnit.SECONDS);\r\n    if (exitCode == Integer.MIN_VALUE) {\r\n        Preconditions.checkArgument(process instanceof LaunchedProcessImpl);\r\n        LaunchedProcessImpl processImpl = (LaunchedProcessImpl) process;\r\n        throw new IOException(String.format(\"Failed to start process %s\", processImpl.params.getCommand()));\r\n    }\r\n    return exitCode;\r\n}"
}, {
	"Path": "com.facebook.buck.parser.DefaultProjectBuildFileParserFactory.createProjectBuildFileParser",
	"Comment": "creates a project build file parser based on buck configuration settings.",
	"Method": "ProjectBuildFileParser createProjectBuildFileParser(Cell cell,TypeCoercerFactory typeCoercerFactory,Console console,BuckEventBus eventBus,ParserConfig parserConfig,ProjectBuildFileParserOptions buildFileParserOptions){\r\n    ProjectBuildFileParser parser;\r\n    Syntax defaultBuildFileSyntax = parserConfig.getDefaultBuildFileSyntax();\r\n    if (parserConfig.isPolyglotParsingEnabled()) {\r\n        parser = HybridProjectBuildFileParser.using(ImmutableMap.of(Syntax.PYTHON_DSL, newPythonParser(cell, typeCoercerFactory, console, eventBus, buildFileParserOptions), Syntax.SKYLARK, addCachingDecoratorIfEnabled(cell.getBuckConfig(), newSkylarkParser(cell, typeCoercerFactory, eventBus, buildFileParserOptions, parserConfig.getSkylarkGlobHandler()), cell.getFilesystem())), defaultBuildFileSyntax);\r\n    } else {\r\n        switch(defaultBuildFileSyntax) {\r\n            case SKYLARK:\r\n                parser = addCachingDecoratorIfEnabled(cell.getBuckConfig(), newSkylarkParser(cell, typeCoercerFactory, eventBus, buildFileParserOptions, parserConfig.getSkylarkGlobHandler()), cell.getFilesystem());\r\n                break;\r\n            case PYTHON_DSL:\r\n                parser = newPythonParser(cell, typeCoercerFactory, console, eventBus, buildFileParserOptions);\r\n                break;\r\n            default:\r\n                throw new HumanReadableException(defaultBuildFileSyntax + \" is not supported by this version of Buck. Please update your Buck version or \" + \"change parser.default_build_file_syntax configuration to one of \" + Arrays.toString(Syntax.values()));\r\n        }\r\n    }\r\n    parser = createTargetCountingWrapper(parser, parserConfig.getParserTargetThreshold(), eventBus);\r\n    return parser;\r\n}"
}, {
	"Path": "com.facebook.buck.util.zip.CentralDirectory.writeCentralDirectory",
	"Comment": "write the entire central directory, including the file headers and the end of central directorysignature.",
	"Method": "void writeCentralDirectory(OutputStream out,long startOffset,Iterable<EntryAccounting> entries){\r\n    int entryCount = 0;\r\n    long size = 0;\r\n    for (EntryAccounting entry : entries) {\r\n        entryCount++;\r\n        size += writeCentralDirectoryFileHeader(out, entry);\r\n    }\r\n    ByteIo.writeInt(out, ZipEntry.ENDSIG);\r\n    ByteIo.writeShort(out, 0);\r\n    ByteIo.writeShort(out, 0);\r\n    ByteIo.writeShort(out, entryCount);\r\n    ByteIo.writeShort(out, entryCount);\r\n    ByteIo.writeInt(out, size);\r\n    ByteIo.writeInt(out, startOffset);\r\n    ByteIo.writeShort(out, 0);\r\n}"
}, {
	"Path": "com.android.dx.command.dexer.Main.processFileBytes",
	"Comment": "processes one file, which may be either a class or a resource.",
	"Method": "boolean processFileBytes(String name,long lastModified,byte[] bytes,boolean processFileBytes,String name,long lastModified,byte[] bytes){\r\n    boolean isClass = name.endsWith(\".class\");\r\n    boolean isClassesDex = name.equals(DexFormat.DEX_IN_JAR_NAME);\r\n    boolean keepResources = (outputResources != null);\r\n    if (!isClass && !isClassesDex && !keepResources) {\r\n        if (args.verbose) {\r\n            context.out.println(\"ignored resource \" + name);\r\n        }\r\n        return false;\r\n    }\r\n    if (args.verbose) {\r\n        context.out.println(\"processing \" + name + \"...\");\r\n    }\r\n    String fixedName = fixPath(name);\r\n    if (isClass) {\r\n        if (keepResources && args.keepClassesInJar) {\r\n            synchronized (outputResources) {\r\n                outputResources.put(fixedName, bytes);\r\n            }\r\n        }\r\n        if (lastModified < minimumFileAge) {\r\n            return true;\r\n        }\r\n        processClass(fixedName, bytes);\r\n        return false;\r\n    } else if (isClassesDex) {\r\n        synchronized (libraryDexBuffers) {\r\n            libraryDexBuffers.add(bytes);\r\n        }\r\n        return true;\r\n    } else {\r\n        synchronized (outputResources) {\r\n            outputResources.put(fixedName, bytes);\r\n        }\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.dex.code.InsnFormat.unsignedFitsInShort",
	"Comment": "helper method to determine if an unsigned int value fits in a short.",
	"Method": "boolean unsignedFitsInShort(int value){\r\n    return value == (value & 0xffff);\r\n}"
}, {
	"Path": "com.facebook.buck.rules.macros.AbstractStringWithMacrosConverter.expand",
	"Comment": "expand the input given for the this macro to some string, which is intended to be written to afile.",
	"Method": "Arg expand(T macro,ActionGraphBuilder ruleResolver,Arg expand,MacroContainer macroContainer,ActionGraphBuilder ruleResolver){\r\n    Arg arg = expand(macroContainer.getMacro(), ruleResolver);\r\n    if (macroContainer.isOutputToFile()) {\r\n        Hasher hasher = Hashing.sha256().newHasher();\r\n        hasher.putString(macroContainer.getMacro().getClass().getName(), UTF_8);\r\n        hasher.putInt(macroContainer.getMacro().hashCode());\r\n        String prefix = hasher.hash().toString();\r\n        arg = new WriteToFileArg(getBuildTarget(), prefix, arg);\r\n    }\r\n    return arg;\r\n}"
}, {
	"Path": "com.android.dx.dex.file.DebugInfoEncoder.buildSortedPositions",
	"Comment": "builds a list of position entries, sorted by ascending address.",
	"Method": "ArrayList<PositionList.Entry> buildSortedPositions(){\r\n    int sz = (positions == null) ? 0 : positions.size();\r\n    ArrayList<PositionList.Entry> result = new ArrayList(sz);\r\n    for (int i = 0; i < sz; i++) {\r\n        result.add(positions.get(i));\r\n    }\r\n    Collections.sort(result, new Comparator<PositionList.Entry>() {\r\n        public int compare(PositionList.Entry a, PositionList.Entry b) {\r\n            return a.getAddress() - b.getAddress();\r\n        }\r\n        public boolean equals(Object obj) {\r\n            return obj == this;\r\n        }\r\n    });\r\n    return result;\r\n}"
}, {
	"Path": "com.android.dx.dex.file.DebugInfoEncoder.buildSortedPositions",
	"Comment": "builds a list of position entries, sorted by ascending address.",
	"Method": "ArrayList<PositionList.Entry> buildSortedPositions(){\r\n    return a.getAddress() - b.getAddress();\r\n}"
}, {
	"Path": "com.android.dx.dex.file.DebugInfoEncoder.buildSortedPositions",
	"Comment": "builds a list of position entries, sorted by ascending address.",
	"Method": "ArrayList<PositionList.Entry> buildSortedPositions(){\r\n    return obj == this;\r\n}"
}, {
	"Path": "com.facebook.buck.cli.DaemonIntegrationTest.whenReadOnlyCommandsExecutedConcurrentlyThenAllSucceed",
	"Comment": "this verifies that multiple read only commands can be executed concurrently successfully.",
	"Method": "void whenReadOnlyCommandsExecutedConcurrentlyThenAllSucceed(){\r\n    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(this, \"exclusive_execution\", tmp);\r\n    workspace.setUp();\r\n    executorService.invokeAll(ImmutableList.of(createCallableCommand(ExitCode.SUCCESS, \"audit\", \"input\", \"//:sleep\"), createCallableCommand(ExitCode.SUCCESS, \"audit\", \"input\", \"//:sleep\"), createCallableCommand(ExitCode.SUCCESS, \"audit\", \"input\", \"//:sleep\"), createCallableCommand(ExitCode.SUCCESS, \"audit\", \"input\", \"//:sleep\"), createCallableCommand(ExitCode.SUCCESS, \"audit\", \"input\", \"//:sleep\")));\r\n}"
}, {
	"Path": "com.android.dx.cf.code.RopperMachine.getInsns",
	"Comment": "gets the instructions array. it is shared and gets modified bysubsequent calls to this instance.",
	"Method": "ArrayList<Insn> getInsns(){\r\n    return insns;\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.AbstractWorkspace.getFileContents",
	"Comment": "resolves the given path relative to the path the workspace is held and returns its contents",
	"Method": "String getFileContents(Path pathRelativeToWorkspaceRoot,String getFileContents,String pathRelativeToWorkspaceRoot){\r\n    return getFileContentsWithAbsolutePath(getPath(pathRelativeToWorkspaceRoot));\r\n}"
}, {
	"Path": "com.facebook.buck.core.select.Selector.getNoMatchMessage",
	"Comment": "returns a custom message that needs to be shown to a user when no condition matches.",
	"Method": "String getNoMatchMessage(){\r\n    return noMatchMessage;\r\n}"
}, {
	"Path": "com.facebook.buck.features.js.HasBundleName.computeBundleName",
	"Comment": "computes the bundle name as configured, or falls back to a default name.",
	"Method": "String computeBundleName(ImmutableSortedSet<Flavor> flavors,Supplier<String> defaultName){\r\n    for (Pair<Flavor, String> nameForFlavor : getBundleNameForFlavor()) {\r\n        if (flavors.contains(nameForFlavor.getFirst())) {\r\n            return nameForFlavor.getSecond();\r\n        }\r\n    }\r\n    return getBundleName().orElseGet(defaultName);\r\n}"
}, {
	"Path": "com.android.dx.dex.code.LocalList.make",
	"Comment": "constructs an instance for the given method, based on the givenblock order and intermediate local information.",
	"Method": "LocalList make(DalvInsnList insns){\r\n    int sz = insns.size();\r\n    MakeState state = new MakeState(sz);\r\n    for (int i = 0; i < sz; i++) {\r\n        DalvInsn insn = insns.get(i);\r\n        if (insn instanceof LocalSnapshot) {\r\n            RegisterSpecSet snapshot = ((LocalSnapshot) insn).getLocals();\r\n            state.snapshot(insn.getAddress(), snapshot);\r\n        } else if (insn instanceof LocalStart) {\r\n            RegisterSpec local = ((LocalStart) insn).getLocal();\r\n            state.startLocal(insn.getAddress(), local);\r\n        }\r\n    }\r\n    LocalList result = state.finish();\r\n    if (DEBUG) {\r\n        debugVerify(result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getDByte",
	"Comment": "gets the d register number, as a byte. this will throw if thevalue is out of the range of an unsigned byte.",
	"Method": "short getDByte(){\r\n    int d = getD();\r\n    if ((d & ~0xff) != 0) {\r\n        throw new DexException(\"Register D out of range: \" + Hex.u8(d));\r\n    }\r\n    return (short) d;\r\n}"
}, {
	"Path": "com.android.dx.command.annotool.AnnotationLister.printMatch",
	"Comment": "prints, or schedules for printing, elements related to a matchingclass.",
	"Method": "void printMatch(DirectClassFile cf){\r\n    for (Main.PrintType pt : args.printTypes) {\r\n        switch(pt) {\r\n            case CLASS:\r\n                String classname;\r\n                classname = cf.getThisClass().getClassType().getClassName();\r\n                classname = classname.replace('/', '.');\r\n                System.out.println(classname);\r\n                break;\r\n            case INNERCLASS:\r\n                matchInnerClassesOf.add(cf.getThisClass().getClassType().getClassName());\r\n                break;\r\n            case METHOD:\r\n                break;\r\n            case PACKAGE:\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.common.sdklib.AndroidVersion.compareTo",
	"Comment": "compares this object with the specified object for order. returns anegative integer, zero, or a positive integer as this object is lessthan, equal to, or greater than the specified object.",
	"Method": "int compareTo(AndroidVersion o,int compareTo,int apiLevel,String codename){\r\n    if (mCodename == null) {\r\n        if (codename == null) {\r\n            return mApiLevel - apiLevel;\r\n        } else {\r\n            if (mApiLevel == apiLevel) {\r\n                return -1;\r\n            }\r\n            return mApiLevel - apiLevel;\r\n        }\r\n    } else {\r\n        if (mApiLevel == apiLevel) {\r\n            if (codename == null) {\r\n                return +1;\r\n            } else {\r\n                return mCodename.compareTo(codename);\r\n            }\r\n        } else {\r\n            return mApiLevel - apiLevel;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.MinionHealthTracker.reportMinionAlive",
	"Comment": "heartbeat reports a minion is currently alive and happily running.",
	"Method": "void reportMinionAlive(String minionId,String runId){\r\n    LOG.debug(String.format(\"Received keep alive heartbeat from Minion [%s]\", minionId));\r\n    minions.computeIfAbsent(minionId, key -> new MinionTrackingInfo(minionId, runId, slowHeartbeatWarningThresholdMillis)).reportHealthy(clock.currentTimeMillis(), healthCheckStatsTracker);\r\n}"
}, {
	"Path": "com.android.dx.dex.file.Section.setFileOffset",
	"Comment": "sets the file offset. it is only valid to call this method onceonce per instance.",
	"Method": "int setFileOffset(int fileOffset){\r\n    if (fileOffset < 0) {\r\n        throw new IllegalArgumentException(\"fileOffset < 0\");\r\n    }\r\n    if (this.fileOffset >= 0) {\r\n        throw new RuntimeException(\"fileOffset already set\");\r\n    }\r\n    int mask = alignment - 1;\r\n    fileOffset = (fileOffset + mask) & ~mask;\r\n    this.fileOffset = fileOffset;\r\n    return fileOffset;\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.BuildSlaveService.makeRequest",
	"Comment": "wrapper around function that sends a request to http server running on localhost",
	"Method": "BuildSlaveResponse makeRequest(BuildSlaveRequest request){\r\n    BuildSlaveResponse response = new BuildSlaveResponse();\r\n    try {\r\n        makeRequest(request, response);\r\n    } catch (IOException e) {\r\n        LOG.warn(e, \"Failed to talk to local thrift service.\");\r\n        response.setWasSuccessful(false);\r\n    }\r\n    return response;\r\n}"
}, {
	"Path": "com.android.dx.dex.code.DalvCode.getInsnConstants",
	"Comment": "gets the set of all constants referred to by instructions inthe code.",
	"Method": "HashSet<Constant> getInsnConstants(){\r\n    return unprocessedInsns.getAllConstants();\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.CxxSourceTypes.isCompilableType",
	"Comment": "returns true for source types which can be built with the c compiler without a preprocessor.",
	"Method": "boolean isCompilableType(CxxSource.Type sourceType){\r\n    return sourceType == CxxSource.Type.C_CPP_OUTPUT || sourceType == CxxSource.Type.CXX_CPP_OUTPUT || sourceType == CxxSource.Type.ASSEMBLER || sourceType == CxxSource.Type.OBJC_CPP_OUTPUT || sourceType == CxxSource.Type.OBJCXX_CPP_OUTPUT || sourceType == CxxSource.Type.CUDA_CPP_OUTPUT || sourceType == CxxSource.Type.HIP_CPP_OUTPUT || sourceType == CxxSource.Type.ASM || sourceType == CxxSource.Type.PCM;\r\n}"
}, {
	"Path": "com.facebook.buck.step.StepFailedException.createForFailingStepWithExitCode",
	"Comment": "creates a stepfailedexception based on a stepexecutionresult.",
	"Method": "StepFailedException createForFailingStepWithExitCode(Step step,ExecutionContext context,StepExecutionResult executionResult){\r\n    int exitCode = executionResult.getExitCode();\r\n    StringBuilder messageBuilder = new StringBuilder();\r\n    messageBuilder.append(String.format(\"Command failed with exit code %d.\", exitCode));\r\n    executionResult.getStderr().ifPresent(stderr -> messageBuilder.append(System.lineSeparator()).append(\"stderr: \").append(stderr));\r\n    return createForFailingStepWithException(step, context, new HumanReadableException(messageBuilder.toString()));\r\n}"
}, {
	"Path": "com.facebook.buck.rules.modern.builders.ModernBuildRuleBuilderFactory.getBuildStrategy",
	"Comment": "creates a buildrulestrategy for modernbuildrules based on the buck configuration.",
	"Method": "Optional<BuildRuleStrategy> getBuildStrategy(ModernBuildRuleStrategyConfig config,RemoteExecutionConfig remoteExecutionConfig,BuildRuleResolver resolver,Cell rootCell,CellPathResolver cellResolver,FileHashLoader hashLoader,BuckEventBus eventBus,ListeningExecutorService remoteExecutorService,Optional<TraceInfoProvider> traceInfoProvider){\r\n    try {\r\n        RemoteExecutionClientsFactory remoteExecutionFactory = new RemoteExecutionClientsFactory(remoteExecutionConfig);\r\n        switch(config.getBuildStrategy()) {\r\n            case NONE:\r\n                return Optional.empty();\r\n            case DEBUG_RECONSTRUCT:\r\n                return Optional.of(createReconstructing(new SourcePathRuleFinder(resolver), cellResolver, rootCell));\r\n            case DEBUG_PASSTHROUGH:\r\n                return Optional.of(createPassthrough());\r\n            case HYBRID_LOCAL:\r\n                return Optional.of(createHybridLocal(config.getHybridLocalConfig(), remoteExecutionConfig, resolver, rootCell, cellResolver, hashLoader, eventBus, remoteExecutorService, traceInfoProvider));\r\n            case REMOTE:\r\n            case GRPC_REMOTE:\r\n            case DEBUG_GRPC_SERVICE_IN_PROCESS:\r\n            case DEBUG_ISOLATED_OUT_OF_PROCESS_GRPC:\r\n                return Optional.of(RemoteExecutionStrategy.createRemoteExecutionStrategy(eventBus, remoteExecutionConfig.useWorkerThreadPool() ? Optional.of(remoteExecutorService) : Optional.empty(), remoteExecutionFactory.create(eventBus, traceInfoProvider), new SourcePathRuleFinder(resolver), cellResolver, rootCell, hashLoader::get));\r\n        }\r\n    } catch (IOException e) {\r\n        throw new BuckUncheckedExecutionException(e, \"When creating MBR build strategy.\");\r\n    }\r\n    throw new IllegalStateException(\"Unrecognized build strategy \" + config.getBuildStrategy() + \".\");\r\n}"
}, {
	"Path": "com.android.dx.cf.code.Frame.subFrameForLabel",
	"Comment": "returns a frame instance representing the frame state that shouldbe used when returning from a subroutine. the stack state of allsubroutine invocations is identical, but the locals state may differ.",
	"Method": "Frame subFrameForLabel(int startLabel,int subLabel){\r\n    LocalsArray subLocals = null;\r\n    if (locals instanceof LocalsArraySet) {\r\n        subLocals = ((LocalsArraySet) locals).subArrayForLabel(subLabel);\r\n    }\r\n    IntList newSubroutines;\r\n    try {\r\n        newSubroutines = subroutines.mutableCopy();\r\n        if (newSubroutines.pop() != startLabel) {\r\n            throw new RuntimeException(\"returning from invalid subroutine\");\r\n        }\r\n        newSubroutines.setImmutable();\r\n    } catch (IndexOutOfBoundsException ex) {\r\n        throw new RuntimeException(\"returning from invalid subroutine\");\r\n    } catch (NullPointerException ex) {\r\n        throw new NullPointerException(\"can't return from non-subroutine\");\r\n    }\r\n    return (subLocals == null) ? null : new Frame(subLocals, stack, newSubroutines);\r\n}"
}, {
	"Path": "com.facebook.buck.remoteexecution.CasBlobDownloadEvent.sendEvent",
	"Comment": "send the started and returns a scoped object that sends the finished event.",
	"Method": "Scope sendEvent(BuckEventBus eventBus,int blobCount,long sizeBytes){\r\n    final Started startedEvent = new Started(blobCount, sizeBytes);\r\n    eventBus.post(startedEvent);\r\n    return () -> eventBus.post(new Finished(startedEvent));\r\n}"
}, {
	"Path": "com.facebook.buck.android.AdbHelperTest.testDeviceFilterCombos",
	"Comment": "verify that different combinations of arguments work correctly.",
	"Method": "void testDeviceFilterCombos(){\r\n    TestDevice realDevice1 = createRealDevice(\"1\", IDevice.DeviceState.ONLINE);\r\n    TestDevice realDevice2 = createRealDevice(\"2\", IDevice.DeviceState.ONLINE);\r\n    TestDevice emulator1 = createEmulator(\"3\", IDevice.DeviceState.ONLINE);\r\n    TestDevice emulator2 = createEmulator(\"4\", IDevice.DeviceState.ONLINE);\r\n    IDevice[] devices = new IDevice[] { realDevice1, emulator1, realDevice2, emulator2 };\r\n    AdbHelper myAdbHelper;\r\n    myAdbHelper = createAdbHelper(createAdbOptions(), new TargetDeviceOptions(false, true, Optional.of(realDevice1.getSerialNumber())));\r\n    List<IDevice> filteredDevices = myAdbHelper.filterDevices(devices);\r\n    assertNotNull(filteredDevices);\r\n    assertEquals(1, filteredDevices.size());\r\n    assertSame(realDevice1, filteredDevices.get(0));\r\n    myAdbHelper = createAdbHelper(createAdbOptions(), new TargetDeviceOptions(false, true, Optional.of(emulator1.getSerialNumber())));\r\n    filteredDevices = myAdbHelper.filterDevices(devices);\r\n    assertNull(filteredDevices);\r\n    myAdbHelper = createAdbHelper(createAdbOptions(), new TargetDeviceOptions(true, false, Optional.of(realDevice1.getSerialNumber())));\r\n    filteredDevices = myAdbHelper.filterDevices(devices);\r\n    assertNull(filteredDevices);\r\n    myAdbHelper = createAdbHelper(createAdbOptions(), new TargetDeviceOptions(true, false, Optional.of(emulator1.getSerialNumber())));\r\n    filteredDevices = myAdbHelper.filterDevices(devices);\r\n    assertNotNull(filteredDevices);\r\n    assertEquals(1, filteredDevices.size());\r\n    assertSame(emulator1, filteredDevices.get(0));\r\n    myAdbHelper = createAdbHelper(createAdbOptions(true), new TargetDeviceOptions(true, true, Optional.empty()));\r\n    filteredDevices = myAdbHelper.filterDevices(devices);\r\n    assertNotNull(filteredDevices);\r\n    assertEquals(devices.length, filteredDevices.size());\r\n    for (IDevice device : devices) {\r\n        assertTrue(filteredDevices.contains(device));\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.tracing.TracingTaskListenerTest.testTracesBeforeChainingOnFinish",
	"Comment": "in order for tracingtasklistener to record the most accurate timings for time spent in javac,it needs to trace finish events before it chains to the next listener.",
	"Method": "void testTracesBeforeChainingOnFinish(){\r\n    TaskEventMirror parseEvent = new TaskEventMirror(null, TaskEventMirror.Kind.PARSE, createMock(JavaFileObject.class), null, null);\r\n    mockControl.checkOrder(true);\r\n    mockTracer.endParse();\r\n    mockNextListener.finished(parseEvent);\r\n    mockControl.replay();\r\n    tracingTaskListener.finished(parseEvent);\r\n    mockControl.verify();\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.toolchain.ArchiverProvider.from",
	"Comment": "creates an appropriate archiverprovider instance for the given parameters.",
	"Method": "ArchiverProvider from(Archiver archiver,ArchiverProvider from,ToolProvider toolProvider,Platform platform,Optional<Type> type){\r\n    return new ArchiverProvider() {\r\n        @Override\r\n        public Archiver resolve(BuildRuleResolver resolver) {\r\n            Tool archiver = toolProvider.resolve(resolver);\r\n            switch(platform) {\r\n                case MACOS:\r\n                case FREEBSD:\r\n                    return new BsdArchiver(archiver);\r\n                case LINUX:\r\n                    return new GnuArchiver(archiver);\r\n                case WINDOWS:\r\n                    if (type.isPresent() && type.get().equals(Type.LLVM_LIB)) {\r\n                        return new ClangWindowsArchiver(archiver);\r\n                    }\r\n                    return new WindowsArchiver(archiver);\r\n                case UNKNOWN:\r\n                default:\r\n                    throw new RuntimeException(\"Invalid platform for archiver. Must be one of {MACOS, LINUX, WINDOWS}\");\r\n            }\r\n        }\r\n        @Override\r\n        public Iterable<BuildTarget> getParseTimeDeps() {\r\n            return toolProvider.getParseTimeDeps();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.toolchain.ArchiverProvider.from",
	"Comment": "creates an appropriate archiverprovider instance for the given parameters.",
	"Method": "ArchiverProvider from(Archiver archiver,ArchiverProvider from,ToolProvider toolProvider,Platform platform,Optional<Type> type){\r\n    Tool archiver = toolProvider.resolve(resolver);\r\n    switch(platform) {\r\n        case MACOS:\r\n        case FREEBSD:\r\n            return new BsdArchiver(archiver);\r\n        case LINUX:\r\n            return new GnuArchiver(archiver);\r\n        case WINDOWS:\r\n            if (type.isPresent() && type.get().equals(Type.LLVM_LIB)) {\r\n                return new ClangWindowsArchiver(archiver);\r\n            }\r\n            return new WindowsArchiver(archiver);\r\n        case UNKNOWN:\r\n        default:\r\n            throw new RuntimeException(\"Invalid platform for archiver. Must be one of {MACOS, LINUX, WINDOWS}\");\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.toolchain.ArchiverProvider.from",
	"Comment": "creates an appropriate archiverprovider instance for the given parameters.",
	"Method": "ArchiverProvider from(Archiver archiver,ArchiverProvider from,ToolProvider toolProvider,Platform platform,Optional<Type> type){\r\n    return toolProvider.getParseTimeDeps();\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.JavacFactory.addParseTimeDeps",
	"Comment": "adds the parse time deps required for javac based on the args. if the args has a spec forjavac, we assume that the parse time deps will be derived elsewhere.",
	"Method": "void addParseTimeDeps(ImmutableCollection.Builder<BuildTarget> targetGraphOnlyDepsBuilder,JvmLibraryArg args){\r\n    if (args == null || !args.hasJavacSpec()) {\r\n        javacProvider.get().addParseTimeDeps(targetGraphOnlyDepsBuilder);\r\n    }\r\n}"
}, {
	"Path": "com.android.manifmerger.Selector.isResolvable",
	"Comment": "returns true if the passed resolver can resolve this selector, false otherwise.",
	"Method": "boolean isResolvable(KeyResolver<String> resolver){\r\n    return resolver.resolve(mPackageName) != null;\r\n}"
}, {
	"Path": "com.android.manifmerger.ActionRecorder.recordImpliedNodeAction",
	"Comment": "record a node that was added due to an implicit presence in earlier sdk release but requiresan explicit declaration in the application targeted sdk.",
	"Method": "void recordImpliedNodeAction(XmlElement xmlElement,String reason){\r\n    NodeKey storageKey = xmlElement.getOriginalId();\r\n    Actions.DecisionTreeRecord nodeDecisionTree = mRecords.get(storageKey);\r\n    if (nodeDecisionTree == null) {\r\n        nodeDecisionTree = new Actions.DecisionTreeRecord();\r\n        mRecords.put(storageKey, nodeDecisionTree);\r\n    }\r\n    Actions.NodeRecord record = new Actions.NodeRecord(Actions.ActionType.IMPLIED, new SourceFilePosition(xmlElement.getDocument().getSourceFile(), xmlElement.getDocument().getRootNode().getPosition()), xmlElement.getOriginalId(), reason, xmlElement.getOperationType());\r\n    nodeDecisionTree.addNodeRecord(record);\r\n}"
}, {
	"Path": "com.facebook.buck.features.js.JsBundleDescription.findGeneratedSources",
	"Comment": "finds all build targets that are inputs to any transitive jsfile dependency of any of thepassed in jslibrary instances.",
	"Method": "Stream<BuildTarget> findGeneratedSources(SourcePathRuleFinder ruleFinder,Stream<JsLibrary> libraries){\r\n    return libraries.map(lib -> lib.getJsFiles(ruleFinder)).flatMap(Function.identity()).map(jsFile -> jsFile.getSourceBuildTarget(ruleFinder)).filter(Objects::nonNull);\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.JavaLibraryClasspathProvider.getClasspathsFromLibraries",
	"Comment": "given libraries that may contribute classpaths, visit them and collect the classpaths.this is used to generate transitive classpaths from library discovered in a previoustraversal.",
	"Method": "ImmutableSet<SourcePath> getClasspathsFromLibraries(Iterable<JavaLibrary> libraries){\r\n    ImmutableSet.Builder<SourcePath> classpathEntries = ImmutableSet.builder();\r\n    for (JavaLibrary library : libraries) {\r\n        classpathEntries.addAll(library.getImmediateClasspaths());\r\n    }\r\n    return classpathEntries.build();\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.endtoend.EndToEndTestDescriptor.getVariableMap",
	"Comment": "gets an environment variable override map to be used during the test",
	"Method": "Map<String, String> getVariableMap(){\r\n    return variableMap;\r\n}"
}, {
	"Path": "com.facebook.buck.testrunner.BuckBlockJUnit4ClassRunner.collectInitializationErrors",
	"Comment": "override default init error collector so that class without any test methods will pass",
	"Method": "void collectInitializationErrors(List<Throwable> errors){\r\n    if (!computeTestMethods().isEmpty()) {\r\n        super.collectInitializationErrors(errors);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.event.AbstractBuckEvent.equals",
	"Comment": "the default implementation of equals checks to see if two events are related, are on the samethread, and are the same concrete class. subclasses therefore can simply override isrelatedto,and the equals method will work correctly.",
	"Method": "boolean equals(Object o){\r\n    if (o == this) {\r\n        return true;\r\n    }\r\n    if (!(o instanceof AbstractBuckEvent)) {\r\n        return false;\r\n    }\r\n    AbstractBuckEvent that = (AbstractBuckEvent) o;\r\n    return isRelatedTo(that) && Objects.equals(getClass(), that.getClass());\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.AbstractJUnitJvmArgs.formatCommandLineArgsToList",
	"Comment": "formats the jvm arguments in this object suitable to pass on the command line.",
	"Method": "void formatCommandLineArgsToList(ImmutableList.Builder<String> args,ProjectFilesystem filesystem,Verbosity verbosity,long defaultTestTimeoutMillis){\r\n    args.add(String.format(\"-D%s=%s\", FileClassPathRunner.TESTRUNNER_CLASSES_PROPERTY, getTestRunnerClasspath()));\r\n    args.add(String.format(\"-D%s=%s\", FileClassPathRunner.CLASSPATH_FILE_PROPERTY, filesystem.resolve(getClasspathFile())));\r\n    if (isCodeCoverageEnabled()) {\r\n        args.add(String.format(\"-javaagent:%s=destfile=%s/%s,append=true,inclnolocationclasses=%b\", JacocoConstants.PATH_TO_JACOCO_AGENT_JAR, JacocoConstants.getJacocoOutputDir(filesystem), JacocoConstants.JACOCO_EXEC_COVERAGE_FILE, isInclNoLocationClassesEnabled()));\r\n    }\r\n    if (getPathToJavaAgent().isPresent()) {\r\n        args.add(String.format(\"-agentpath:%s\", getPathToJavaAgent().get()));\r\n    }\r\n    args.add(String.format(\"-D%s=%s\", BUILD_ID_PROPERTY, getBuildId()));\r\n    args.add(String.format(\"-D%s=%s\", MODULE_BASE_PATH_PROPERTY, getBuckModuleBaseSourceCodePath()));\r\n    args.add(\"-Dapple.awt.UIElement=true\");\r\n    if (getStdOutLogLevel().isPresent()) {\r\n        args.add(String.format(\"-D%s=%s\", STD_OUT_LOG_LEVEL_PROPERTY, getStdOutLogLevel().get()));\r\n    }\r\n    if (getStdErrLogLevel().isPresent()) {\r\n        args.add(String.format(\"-D%s=%s\", STD_ERR_LOG_LEVEL_PROPERTY, getStdErrLogLevel().get()));\r\n    }\r\n    if (getRobolectricLogPath().isPresent()) {\r\n        args.add(String.format(\"-Drobolectric.logging=%s\", getRobolectricLogPath().get()));\r\n    }\r\n    if (isDebugEnabled()) {\r\n        args.add(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005\");\r\n    }\r\n    if (getExtraJvmArgs().isPresent()) {\r\n        args.addAll(getExtraJvmArgs().get());\r\n    }\r\n    if (verbosity.shouldUseVerbosityFlagIfAvailable()) {\r\n        args.add(\"-verbose\");\r\n    }\r\n    args.add(\"-classpath\", getTestRunnerClasspath().toString());\r\n    args.add(FileClassPathRunner.class.getName());\r\n    args.add(getTestType().getDefaultTestRunner());\r\n    if (getDirectoryForTestResults().isPresent()) {\r\n        args.add(\"--output\", getDirectoryForTestResults().get().toString());\r\n    }\r\n    long timeout = isDebugEnabled() ? 0 : defaultTestTimeoutMillis;\r\n    args.add(\"--default-test-timeout\", String.valueOf(timeout));\r\n    StringBuilder selectorsArgBuilder = new StringBuilder();\r\n    if (getTestSelectorList().isPresent() && !getTestSelectorList().get().isEmpty()) {\r\n        for (String rawSelector : getTestSelectorList().get().getRawSelectors()) {\r\n            selectorsArgBuilder.append(rawSelector).append(\"\\n\");\r\n        }\r\n        args.add(\"--test-selectors\", selectorsArgBuilder.toString());\r\n        if (isShouldExplainTestSelectorList()) {\r\n            args.add(\"--explain-test-selectors\");\r\n        }\r\n    }\r\n    for (String testClassName : getTestClasses()) {\r\n        args.add(testClassName);\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.cf.attrib.BaseAnnotations.getAnnotations",
	"Comment": "gets the list of annotations associated with this instance.",
	"Method": "Annotations getAnnotations(){\r\n    return annotations;\r\n}"
}, {
	"Path": "com.facebook.buck.util.trace.ChromeTraceParser.parse",
	"Comment": "parses a chrome trace and stops parsing once all of the specified matchers have been satisfied.this method parses only one chrome trace event at a time, which avoids loading the entire traceinto memory.",
	"Method": "Map<ChromeTraceEventMatcher<?>, Object> parse(Path pathToTrace,Set<ChromeTraceEventMatcher<?>> chromeTraceEventMatchers){\r\n    Set<ChromeTraceEventMatcher<?>> unmatchedMatchers = new HashSet(chromeTraceEventMatchers);\r\n    Preconditions.checkArgument(!unmatchedMatchers.isEmpty(), \"Must specify at least one matcher\");\r\n    Map<ChromeTraceEventMatcher<?>, Object> results = new HashMap();\r\n    try (InputStream input = projectFilesystem.newFileInputStream(pathToTrace);\r\n        MappingIterator<ImmutableMap<String, Object>> it = ObjectMappers.READER.forType(new TypeReference<ImmutableMap<String, Object>>() {\r\n        }).readValues(input)) {\r\n        featureSearch: while (it.hasNext()) {\r\n            ImmutableMap<String, Object> event = it.next();\r\n            Object nameEl = event.get(\"name\");\r\n            if (!(nameEl instanceof String)) {\r\n                continue;\r\n            }\r\n            String name = (String) nameEl;\r\n            for (Iterator<ChromeTraceEventMatcher<?>> iter = unmatchedMatchers.iterator(); iter.hasNext(); ) {\r\n                ChromeTraceEventMatcher<?> chromeTraceEventMatcher = iter.next();\r\n                Optional<?> result = chromeTraceEventMatcher.test(event, name);\r\n                if (result.isPresent()) {\r\n                    iter.remove();\r\n                    results.put(chromeTraceEventMatcher, result.get());\r\n                    if (unmatchedMatchers.isEmpty()) {\r\n                        break featureSearch;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "com.facebook.buck.io.file.MostFiles.diffFileContents",
	"Comment": "log a simplistic diff between lines and the contents of file.",
	"Method": "List<String> diffFileContents(Iterable<String> lines,File file){\r\n    List<String> diffLines = new ArrayList();\r\n    Iterator<String> iter = lines.iterator();\r\n    try (BufferedReader reader = Files.newBufferedReader(file.toPath(), Charsets.UTF_8)) {\r\n        while (iter.hasNext()) {\r\n            String lineA = reader.readLine();\r\n            String lineB = iter.next();\r\n            if (!Objects.equal(lineA, lineB)) {\r\n                diffLines.add(String.format(\"| %s | %s |\", lineA == null ? \"\" : lineA, lineB));\r\n            }\r\n        }\r\n        String lineA;\r\n        while ((lineA = reader.readLine()) != null) {\r\n            diffLines.add(String.format(\"| %s |  |\", lineA));\r\n        }\r\n    }\r\n    return diffLines;\r\n}"
}, {
	"Path": "com.facebook.buck.core.model.actiongraph.computation.ActionGraphProviderTest.compareActionGraphsBasedOnRuleKeys",
	"Comment": "if this breaks it probably means the actiongraphprovider checking also breaks.",
	"Method": "void compareActionGraphsBasedOnRuleKeys(){\r\n    ActionGraphProvider actionGraphProvider = new ActionGraphProviderBuilder().withPoolSupplier(fakePoolSupplier).withEventBus(eventBus).build();\r\n    ActionGraphAndBuilder resultRun1 = actionGraphProvider.getFreshActionGraph(new DefaultTargetNodeToBuildRuleTransformer(), targetGraph1);\r\n    ActionGraphAndBuilder resultRun2 = actionGraphProvider.getFreshActionGraph(new DefaultTargetNodeToBuildRuleTransformer(), targetGraph1);\r\n    Map<BuildRule, RuleKey> resultRun1RuleKeys = getRuleKeysFromBuildRules(resultRun1.getActionGraph().getNodes(), resultRun1.getActionGraphBuilder());\r\n    Map<BuildRule, RuleKey> resultRun2RuleKeys = getRuleKeysFromBuildRules(resultRun2.getActionGraph().getNodes(), resultRun2.getActionGraphBuilder());\r\n    assertThat(resultRun1RuleKeys, equalTo(resultRun2RuleKeys));\r\n}"
}, {
	"Path": "com.facebook.buck.maven.Publisher.checkForDuplicatePackagedDeps",
	"Comment": "checks for any packaged dependencies that exist between more than one of the targets that weare trying to publish.",
	"Method": "ImmutableListMultimap<UnflavoredBuildTarget, UnflavoredBuildTarget> checkForDuplicatePackagedDeps(ImmutableSet<MavenPublishable> publishables){\r\n    Multimap<UnflavoredBuildTarget, UnflavoredBuildTarget> builtinDeps = HashMultimap.create();\r\n    for (MavenPublishable publishable : publishables) {\r\n        for (BuildRule buildRule : publishable.getPackagedDependencies()) {\r\n            builtinDeps.put(buildRule.getBuildTarget().getUnflavoredBuildTarget(), publishable.getBuildTarget().getUnflavoredBuildTarget());\r\n        }\r\n    }\r\n    ImmutableListMultimap.Builder<UnflavoredBuildTarget, UnflavoredBuildTarget> builder = ImmutableListMultimap.builder();\r\n    for (UnflavoredBuildTarget buildTarget : builtinDeps.keySet()) {\r\n        Collection<UnflavoredBuildTarget> publishablesUsingBuildTarget = builtinDeps.get(buildTarget);\r\n        if (publishablesUsingBuildTarget.size() > 1) {\r\n            builder.putAll(buildTarget, publishablesUsingBuildTarget);\r\n        }\r\n    }\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.ProgressEstimator.resetBuildData",
	"Comment": "reset the stats associated with buildruleevent counts. can be used to reset progress estimationfor a second build instance.",
	"Method": "void resetBuildData(){\r\n    numberOfRules.set(0);\r\n    numberOfStartedRules.set(0);\r\n    numberOfFinishedRules.set(0);\r\n    buildProgress.set(-1.0);\r\n}"
}, {
	"Path": "com.facebook.buck.io.AsynchronousDirectoryContentsCleaner.startCleaningDirectory",
	"Comment": "starts cleaning the configured directory in the background.multiple calls to this method will be serialized, so only one instance of directory cleaningwill occur at a time.",
	"Method": "void startCleaningDirectory(Path pathToClean){\r\n    executor.execute(() -> {\r\n        LOG.debug(\"Starting to clean %s\", pathToClean);\r\n        try {\r\n            MostFiles.deleteRecursivelyWithOptions(pathToClean, EnumSet.of(MostFiles.DeleteRecursivelyOptions.IGNORE_NO_SUCH_FILE_EXCEPTION, MostFiles.DeleteRecursivelyOptions.DELETE_CONTENTS_ONLY));\r\n        } catch (IOException e) {\r\n            LOG.warn(e, \"I/O error cleaning trash\");\r\n        } finally {\r\n            LOG.debug(\"Done cleaning %s\", pathToClean);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.android.common.ide.common.xml.XmlFormatPreferences.defaults",
	"Comment": "returns a new preferences object initialized with the defaults",
	"Method": "XmlFormatPreferences defaults(){\r\n    return new XmlFormatPreferences();\r\n}"
}, {
	"Path": "com.android.dx.dex.file.DebugInfoEncoder.extractMethodArguments",
	"Comment": "extracts method arguments from a locals list. these will be collectedfrom the input list and sorted by ascending register in thereturned list.",
	"Method": "ArrayList<LocalList.Entry> extractMethodArguments(){\r\n    ArrayList<LocalList.Entry> result = new ArrayList(desc.getParameterTypes().size());\r\n    int argBase = getParamBase();\r\n    BitSet seen = new BitSet(regSize - argBase);\r\n    int sz = locals.size();\r\n    for (int i = 0; i < sz; i++) {\r\n        LocalList.Entry e = locals.get(i);\r\n        int reg = e.getRegister();\r\n        if (reg < argBase) {\r\n            continue;\r\n        }\r\n        if (seen.get(reg - argBase)) {\r\n            continue;\r\n        }\r\n        seen.set(reg - argBase);\r\n        result.add(e);\r\n    }\r\n    Collections.sort(result, new Comparator<LocalList.Entry>() {\r\n        public int compare(LocalList.Entry a, LocalList.Entry b) {\r\n            return a.getRegister() - b.getRegister();\r\n        }\r\n        public boolean equals(Object obj) {\r\n            return obj == this;\r\n        }\r\n    });\r\n    return result;\r\n}"
}, {
	"Path": "com.android.dx.dex.file.DebugInfoEncoder.extractMethodArguments",
	"Comment": "extracts method arguments from a locals list. these will be collectedfrom the input list and sorted by ascending register in thereturned list.",
	"Method": "ArrayList<LocalList.Entry> extractMethodArguments(){\r\n    return a.getRegister() - b.getRegister();\r\n}"
}, {
	"Path": "com.android.dx.dex.file.DebugInfoEncoder.extractMethodArguments",
	"Comment": "extracts method arguments from a locals list. these will be collectedfrom the input list and sorted by ascending register in thereturned list.",
	"Method": "ArrayList<LocalList.Entry> extractMethodArguments(){\r\n    return obj == this;\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.endtoend.EndToEndWorkspace.waitForProcess",
	"Comment": "waits for given launched process to terminate, with 5 second timeout",
	"Method": "boolean waitForProcess(LaunchedProcess launchedProcess){\r\n    return !processExecutor.waitForLaunchedProcessWithTimeout(launchedProcess, 5000, Optional.empty()).isTimedOut();\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.AbstractConsoleEventBusListener.getStartAndFinish",
	"Comment": "calculate event pair that start and end the sequence. if there is any ongoing event, end eventwould be empty.",
	"Method": "EventPair getStartAndFinish(Collection<EventPair> eventPairs){\r\n    Optional<BuckEventExternalInterface> start = Optional.empty();\r\n    Optional<BuckEventExternalInterface> end = Optional.empty();\r\n    boolean anyOngoing = false;\r\n    for (EventPair pair : eventPairs) {\r\n        Optional<BuckEventExternalInterface> candidate = pair.getStart();\r\n        if (!start.isPresent() || (candidate.isPresent() && candidate.get().getTimestamp() < start.get().getTimestamp())) {\r\n            start = candidate;\r\n        }\r\n        if (anyOngoing) {\r\n            continue;\r\n        }\r\n        candidate = pair.getFinish();\r\n        if (!candidate.isPresent()) {\r\n            anyOngoing = true;\r\n            end = Optional.empty();\r\n            continue;\r\n        }\r\n        if (!end.isPresent() || candidate.get().getTimestamp() > end.get().getTimestamp()) {\r\n            end = candidate;\r\n        }\r\n    }\r\n    return EventPair.of(start, end);\r\n}"
}, {
	"Path": "com.facebook.buck.features.rust.RustCompileUtils.getCrateRoot",
	"Comment": "given a list of sources, return the one which is the root based on the defaults and userparameters.",
	"Method": "Optional<SourcePath> getCrateRoot(SourcePathResolver resolver,String crate,ImmutableSet<String> defaults,Stream<SourcePath> sources){\r\n    String crateName = String.format(\"%s.rs\", crate);\r\n    ImmutableList<SourcePath> res = sources.filter(src -> {\r\n        String name = resolver.getRelativePath(src).getFileName().toString();\r\n        return defaults.contains(name) || name.equals(crateName);\r\n    }).collect(ImmutableList.toImmutableList());\r\n    if (res.size() == 1) {\r\n        return Optional.of(res.get(0));\r\n    } else {\r\n        return Optional.empty();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.util.concurrent.JobLimiter.schedule",
	"Comment": "adds a new task to the queue. joblimiter uses the provided service only for invoking thecallable itself.",
	"Method": "ListenableFuture<V> schedule(ListeningExecutorService service,ThrowingSupplier<ListenableFuture<V>, Exception> callable){\r\n    ThrowingSupplier<ListenableFuture<V>, Exception> safeCallable = () -> Futures.submitAsync(callable::get, service);\r\n    if (semaphore.tryAcquire()) {\r\n        return send(safeCallable);\r\n    }\r\n    ListenableFuture<V> enqueued = enqueue(safeCallable);\r\n    if (semaphore.tryAcquire()) {\r\n        release();\r\n    }\r\n    return enqueued;\r\n}"
}, {
	"Path": "com.facebook.buck.core.config.AliasConfigTest.testEmptyConfig",
	"Comment": "ensures that all public methods of buckconfig return reasonable values for an empty config.",
	"Method": "void testEmptyConfig(){\r\n    AliasConfig emptyConfig = AliasConfig.from(FakeBuckConfig.builder().build());\r\n    assertEquals(ImmutableMap.<String, String>of(), emptyConfig.getEntries());\r\n    assertEquals(ImmutableSet.of(), emptyConfig.getBuildTargetForAliasAsString(\"fb4a\"));\r\n    assertEquals(ImmutableMap.<Path, String>of(), emptyConfig.getBasePathToAliasMap());\r\n}"
}, {
	"Path": "com.android.dx.cf.code.Ropper.setFirstFrame",
	"Comment": "sets up the first frame to contain all the incoming parameters inlocals.",
	"Method": "void setFirstFrame(){\r\n    Prototype desc = method.getEffectiveDescriptor();\r\n    startFrames[0].initializeWithParameters(desc.getParameterTypes());\r\n    startFrames[0].setImmutable();\r\n}"
}, {
	"Path": "com.facebook.buck.features.apple.project.ProjectGenerator.getFilesToCopyInXcode",
	"Comment": "returns the list of infos about the files that we need to copy during xcode build.",
	"Method": "ImmutableList<CopyInXcode> getFilesToCopyInXcode(){\r\n    return filesToCopyInXcodeBuilder.build();\r\n}"
}, {
	"Path": "com.facebook.buck.doctor.AbstractReport.getTracePathsOfBuilds",
	"Comment": "it returns a list of trace files that corresponds to builds while respecting the maximum sizeof the final zip file.",
	"Method": "ImmutableSet<Path> getTracePathsOfBuilds(ImmutableSet<BuildLogEntry> entries){\r\n    ImmutableSet.Builder<Path> tracePaths = new ImmutableSet.Builder();\r\n    long reportSizeBytes = 0;\r\n    for (BuildLogEntry entry : entries) {\r\n        reportSizeBytes += entry.getSize();\r\n        if (entry.getTraceFile().isPresent()) {\r\n            try {\r\n                Path traceFile = filesystem.getPathForRelativeExistingPath(entry.getTraceFile().get());\r\n                long traceFileSizeBytes = Files.size(traceFile);\r\n                if (doctorConfig.getReportMaxSizeBytes().isPresent()) {\r\n                    if (reportSizeBytes + traceFileSizeBytes < doctorConfig.getReportMaxSizeBytes().get()) {\r\n                        tracePaths.add(entry.getTraceFile().get());\r\n                        reportSizeBytes += traceFileSizeBytes;\r\n                    }\r\n                } else {\r\n                    tracePaths.add(entry.getTraceFile().get());\r\n                    reportSizeBytes += traceFileSizeBytes;\r\n                }\r\n            } catch (IOException e) {\r\n                LOG.info(\"Trace path %s wasn't valid, skipping it.\", entry.getTraceFile().get());\r\n            }\r\n        }\r\n    }\r\n    return tracePaths.build();\r\n}"
}, {
	"Path": "com.facebook.buck.util.function.ThrowingSupplier.asSupplier",
	"Comment": "returns a supplier that will wrap any thrown exception in a runtimeexception.",
	"Method": "Supplier<T> asSupplier(){\r\n    return () -> {\r\n        try {\r\n            return get();\r\n        } catch (Exception e) {\r\n            Throwables.throwIfUnchecked(e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.facebook.buck.android.toolchain.ndk.impl.NdkCxxPlatformTest.constructLinkRuleKeys",
	"Comment": "create and return some rule keys from a dummy source for the given platforms.",
	"Method": "ImmutableMap<TargetCpuType, RuleKey> constructLinkRuleKeys(ImmutableMap<TargetCpuType, NdkCxxPlatform> cxxPlatforms){\r\n    ActionGraphBuilder graphBuilder = new TestActionGraphBuilder();\r\n    SourcePathRuleFinder ruleFinder = new SourcePathRuleFinder(graphBuilder);\r\n    SourcePathResolver pathResolver = DefaultSourcePathResolver.from(ruleFinder);\r\n    DefaultRuleKeyFactory ruleKeyFactory = new TestDefaultRuleKeyFactory(FakeFileHashCache.createFromStrings(ImmutableMap.<String, String>builder().put(\"input.o\", Strings.repeat(\"a\", 40)).build()), pathResolver, ruleFinder);\r\n    BuildTarget target = BuildTargetFactory.newInstance(\"//:target\");\r\n    ImmutableMap.Builder<TargetCpuType, RuleKey> ruleKeys = ImmutableMap.builder();\r\n    for (Map.Entry<TargetCpuType, NdkCxxPlatform> entry : cxxPlatforms.entrySet()) {\r\n        FakeProjectFilesystem filesystem = new FakeProjectFilesystem();\r\n        BuildRule rule = CxxLinkableEnhancer.createCxxLinkableBuildRule(CxxPlatformUtils.DEFAULT_CONFIG, entry.getValue().getCxxPlatform(), filesystem, graphBuilder, pathResolver, ruleFinder, target, Linker.LinkType.EXECUTABLE, Optional.empty(), Paths.get(\"output\"), ImmutableList.of(), Linker.LinkableDepType.SHARED, CxxLinkOptions.of(), ImmutableList.of(), Optional.empty(), Optional.empty(), ImmutableSet.of(), ImmutableSet.of(), NativeLinkableInput.builder().setArgs(SourcePathArg.from(FakeSourcePath.of(\"input.o\"))).build(), Optional.empty(), TestCellPathResolver.get(filesystem));\r\n        ruleKeys.put(entry.getKey(), ruleKeyFactory.build(rule));\r\n    }\r\n    return ruleKeys.build();\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_client.SynchronizedBuildPhase.run",
	"Comment": "performs a local build that waits for build nodes to finish remotely before proceeding locally.deals with cleanup if local or distributed build fails.",
	"Method": "void run(DistBuildRunner distBuildRunner,LocalBuildRunner synchronizedBuildRunner,RemoteBuildRuleSynchronizer remoteBuildRuleSynchronizer,boolean localBuildFallbackEnabled,BuckEventBus eventBus){\r\n    LOG.info(\"Starting synchronized build phase.\");\r\n    eventBus.post(new StampedeLocalBuildStatusEvent(\"waiting\"));\r\n    remoteBuildRuleSynchronizer.switchToAlwaysWaitingMode();\r\n    synchronizedBuildRunner.runLocalBuildAsync();\r\n    LOG.info(\"Waiting for local synchronized build or distributed build to finish.\");\r\n    synchronizedBuildRunner.getBuildPhaseLatch().await();\r\n    if (distBuildRunner.finishedSuccessfully()) {\r\n        LOG.info(\"Distributed build finished before local build. Waiting for local build..\");\r\n        synchronizedBuildRunner.waitUntilFinished();\r\n    } else if (synchronizedBuildRunner.isFinished()) {\r\n        LOG.info(\"Local synchronized build finished before distributed build.\");\r\n        distBuildRunner.cancelAsLocalBuildFinished(synchronizedBuildRunner.finishedSuccessfully(), synchronizedBuildRunner.getExitCode());\r\n    } else {\r\n        LOG.info(\"Distributed build failed before local build.\");\r\n        if (localBuildFallbackEnabled) {\r\n            LOG.info(\"Falling back to local synchronized build. Waiting for it to finish..\");\r\n            eventBus.post(new StampedeLocalBuildStatusEvent(\"fallback\", \"Local Build\"));\r\n            synchronizedBuildRunner.waitUntilFinished();\r\n        } else {\r\n            LOG.info(\"Killing local synchronized build as local fallback not enabled.\");\r\n            synchronizedBuildRunner.cancelAndWait(\"Distributed build failed, and fallback not enabled.\");\r\n        }\r\n    }\r\n    LOG.info(\"Local synchronized build phase has finished.\");\r\n}"
}, {
	"Path": "com.android.common.xml.AndroidManifest.getMinSdkVersion",
	"Comment": "returns the value of the minsdkversion attribute.if the attribute is set with an int value, the method returns an integer object.if the attribute is set with a codename, it returns the codename as a string object.if the attribute is not set, it returns null.",
	"Method": "Object getMinSdkVersion(IAbstractFile manifestFile){\r\n    String result = getStringValue(manifestFile, getMinSdkVersionXPath());\r\n    try {\r\n        return Integer.valueOf(result);\r\n    } catch (NumberFormatException e) {\r\n        return !result.isEmpty() ? result : null;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.util.zip.JarBuilder.merge",
	"Comment": "merge entries from two manifests together, with existing attributes being overwritten.",
	"Method": "void merge(Manifest into,Manifest from){\r\n    Attributes attributes = from.getMainAttributes();\r\n    if (attributes != null) {\r\n        for (Map.Entry<Object, Object> attribute : attributes.entrySet()) {\r\n            into.getMainAttributes().put(attribute.getKey(), attribute.getValue());\r\n        }\r\n    }\r\n    Map<String, Attributes> entries = from.getEntries();\r\n    if (entries != null) {\r\n        for (Map.Entry<String, Attributes> entry : entries.entrySet()) {\r\n            Attributes existing = into.getAttributes(entry.getKey());\r\n            if (existing == null) {\r\n                existing = new Attributes();\r\n                into.getEntries().put(entry.getKey(), existing);\r\n            }\r\n            existing.putAll(entry.getValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.shell.Genrule.getOutputName",
	"Comment": "get the output name of the generated file, as listed in the buck file.",
	"Method": "String getOutputName(){\r\n    return out;\r\n}"
}, {
	"Path": "com.android.dx.dex.code.Dop.getOppositeTest",
	"Comment": "gets the opcode for the opposite test of this instance. this is onlyvalid for opcodes which are in fact tests.",
	"Method": "Dop getOppositeTest(){\r\n    switch(opcode) {\r\n        case Opcodes.IF_EQ:\r\n            return Dops.IF_NE;\r\n        case Opcodes.IF_NE:\r\n            return Dops.IF_EQ;\r\n        case Opcodes.IF_LT:\r\n            return Dops.IF_GE;\r\n        case Opcodes.IF_GE:\r\n            return Dops.IF_LT;\r\n        case Opcodes.IF_GT:\r\n            return Dops.IF_LE;\r\n        case Opcodes.IF_LE:\r\n            return Dops.IF_GT;\r\n        case Opcodes.IF_EQZ:\r\n            return Dops.IF_NEZ;\r\n        case Opcodes.IF_NEZ:\r\n            return Dops.IF_EQZ;\r\n        case Opcodes.IF_LTZ:\r\n            return Dops.IF_GEZ;\r\n        case Opcodes.IF_GEZ:\r\n            return Dops.IF_LTZ;\r\n        case Opcodes.IF_GTZ:\r\n            return Dops.IF_LEZ;\r\n        case Opcodes.IF_LEZ:\r\n            return Dops.IF_GTZ;\r\n    }\r\n    throw new IllegalArgumentException(\"bogus opcode: \" + this);\r\n}"
}, {
	"Path": "com.facebook.buck.core.model.impl.AbstractImmutableBuildTarget.of",
	"Comment": "helper for creating a build target with no flavors and no cell name.",
	"Method": "BuildTarget of(UnflavoredBuildTarget unflavoredBuildTarget,BuildTarget of,Path cellPath,String baseName,String shortName){\r\n    return ImmutableBuildTarget.of(ImmutableUnflavoredBuildTarget.of(cellPath, Optional.empty(), baseName, shortName));\r\n}"
}, {
	"Path": "com.android.common.xml.AndroidManifest.combinePackageAndClassName",
	"Comment": "combines a java package, with a class value from the manifest to make a fully qualifiedclass name",
	"Method": "String combinePackageAndClassName(String javaPackage,String className){\r\n    if (className == null || className.isEmpty()) {\r\n        return javaPackage;\r\n    }\r\n    if (javaPackage == null || javaPackage.isEmpty()) {\r\n        return className;\r\n    }\r\n    boolean startWithDot = (className.charAt(0) == '.');\r\n    boolean hasDot = (className.indexOf('.') != -1);\r\n    if (startWithDot || !hasDot) {\r\n        if (startWithDot) {\r\n            return javaPackage + className;\r\n        } else {\r\n            return javaPackage + '.' + className;\r\n        }\r\n    } else {\r\n        return className;\r\n    }\r\n}"
}, {
	"Path": "com.android.common.sdklib.AndroidVersion.getCodename",
	"Comment": "returns the version code name if applicable, null otherwise.if the codename is non null, then the api level should be ignored, and this should beused as a unique identifier of the target instead.",
	"Method": "String getCodename(){\r\n    return mCodename;\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.ProgressEstimator.didFinishParsing",
	"Comment": "indicates that buck has finished parsing, updating the progress estimation accordingly",
	"Method": "Future<?> didFinishParsing(){\r\n    if (command != null) {\r\n        return runAsync(() -> {\r\n            expectedNumberOfParsedRules.set(numberOfParsedRules.get());\r\n            expectedNumberOfParsedBUCKFiles.set(numberOfParsedBUCKFiles.get());\r\n            calculateParsingBuckFilesEstimatedProgress();\r\n            updateEstimatedBuckFilesParsingValues(command);\r\n        });\r\n    }\r\n    return Futures.immediateFuture(null);\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.CxxTest.validateExitCode",
	"Comment": "validates that the exit code in the file does not indicate an abnormal exit of the test program",
	"Method": "Optional<String> validateExitCode(Path exitCodePath){\r\n    try {\r\n        int realExitCode = parseExitCode(exitCodePath);\r\n        if (realExitCode > 128) {\r\n            return Optional.of(String.format(\"The program was killed by signal %s\", realExitCode - 128));\r\n        }\r\n        return Optional.empty();\r\n    } catch (IOException e) {\r\n        return Optional.of(\"Could not parse exit code from file\");\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.query.Lexer.scan",
	"Comment": "entry point to the lexer. returns the list of tokens for the specified input, or throwsqueryexception.",
	"Method": "List<Token> scan(char[] buffer){\r\n    Lexer lexer = new Lexer(buffer);\r\n    lexer.tokenize();\r\n    return lexer.tokens;\r\n}"
}, {
	"Path": "com.facebook.buck.util.MoreMaps.putIfAbsentCheckEquals",
	"Comment": "inserts the given value if nothing was already set for the key. if a value already existed forthis key, ensures it is the same as the one being inserted, otherwise throws anillegalstateexception.",
	"Method": "Map<K, V> putIfAbsentCheckEquals(ConcurrentMap<K, V> map,K key,V value){\r\n    V old = map.putIfAbsent(key, value);\r\n    if (old != null) {\r\n        Preconditions.checkState(old.equals(value));\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.endtoend.ConfigSetBuilder.addShlibConfigSet",
	"Comment": "adds configuration options to create shared library interfaces when building",
	"Method": "ConfigSetBuilder addShlibConfigSet(){\r\n    ensureSection(\"cxx\");\r\n    configSet.get(\"cxx\").put(\"shlib_interfaces\", \"enabled\");\r\n    configSet.get(\"cxx\").put(\"independent_shlib_interfaces\", \"true\");\r\n    platformUtils.getObjcopy().ifPresent(o -> configSet.get(\"cxx\").put(\"objcopy\", o));\r\n    return this;\r\n}"
}, {
	"Path": "com.facebook.buck.core.select.impl.SelectorFactory.createSelector",
	"Comment": "creates a new selector using the default error message when no conditions match.",
	"Method": "Selector<T> createSelector(CellPathResolver cellPathResolver,ProjectFilesystem filesystem,Path pathRelativeToProjectRoot,Map<String, ?> rawAttributes,TypeCoercer<T> elementTypeCoercer,Selector<T> createSelector,CellPathResolver cellPathResolver,ProjectFilesystem filesystem,Path pathRelativeToProjectRoot,Map<String, ?> rawAttributes,TypeCoercer<T> elementTypeCoercer,String noMatchMessage){\r\n    LinkedHashMap<SelectorKey, T> result = Maps.newLinkedHashMapWithExpectedSize(rawAttributes.size());\r\n    Set<SelectorKey> nullConditions = new HashSet();\r\n    boolean foundDefaultCondition = false;\r\n    for (Entry<String, ?> entry : rawAttributes.entrySet()) {\r\n        String key = entry.getKey();\r\n        SelectorKey selectorKey;\r\n        if (key.equals(SelectorKey.DEFAULT_KEYWORD)) {\r\n            foundDefaultCondition = true;\r\n            selectorKey = SelectorKey.DEFAULT;\r\n        } else {\r\n            selectorKey = new SelectorKey(buildTargetTypeCoercer.coerce(cellPathResolver, filesystem, pathRelativeToProjectRoot, key));\r\n        }\r\n        if (entry.getValue() == Runtime.NONE) {\r\n            result.remove(selectorKey);\r\n            nullConditions.add(selectorKey);\r\n        } else {\r\n            result.put(selectorKey, elementTypeCoercer.coerce(cellPathResolver, filesystem, pathRelativeToProjectRoot, entry.getValue()));\r\n            nullConditions.remove(selectorKey);\r\n        }\r\n    }\r\n    return new Selector(ImmutableMap.copyOf(result), ImmutableSet.copyOf(nullConditions), noMatchMessage, foundDefaultCondition);\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.abi.source.TreeBackedElements.getPackageElement",
	"Comment": "gets the package element with the given name. if a package with the given name is referenced inthe code or exists in the classpath, returns the corresponding element. otherwise returns null.",
	"Method": "ArtificialPackageElement getPackageElement(CharSequence qualifiedNameString){\r\n    Name qualifiedName = getName(qualifiedNameString);\r\n    if (!knownPackages.containsKey(qualifiedName)) {\r\n        PackageElement javacElement = javacElements.getPackageElement(qualifiedName);\r\n        if (javacElement != null) {\r\n            knownPackages.put(qualifiedName, new TreeBackedPackageElement(javacElement));\r\n        }\r\n    }\r\n    return knownPackages.get(qualifiedName);\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.DefaultJavaLibrary.initializeFromDisk",
	"Comment": "instructs this rule to report the abi it has on disk as its current abi.",
	"Method": "JavaLibrary.Data initializeFromDisk(SourcePathResolver pathResolver){\r\n    javaAbiInfo.load(pathResolver);\r\n    return JavaLibraryRules.initializeFromDisk(getBuildTarget(), getProjectFilesystem());\r\n}"
}, {
	"Path": "com.android.manifmerger.PlaceholderHandler.isPlaceHolder",
	"Comment": "returns true if the passed string is a placeholder value, false otherwise.",
	"Method": "boolean isPlaceHolder(String string){\r\n    return PATTERN.matcher(string).matches();\r\n}"
}, {
	"Path": "com.android.dx.dex.file.ProtoIdsSection.writeHeaderPart",
	"Comment": "writes the portion of the file header that refers to this instance.",
	"Method": "void writeHeaderPart(AnnotatedOutput out){\r\n    throwIfNotPrepared();\r\n    int sz = protoIds.size();\r\n    int offset = (sz == 0) ? 0 : getFileOffset();\r\n    if (sz > 65536) {\r\n        throw new UnsupportedOperationException(\"too many proto ids\");\r\n    }\r\n    if (out.annotates()) {\r\n        out.annotate(4, \"proto_ids_size:  \" + Hex.u4(sz));\r\n        out.annotate(4, \"proto_ids_off:   \" + Hex.u4(offset));\r\n    }\r\n    out.writeInt(sz);\r\n    out.writeInt(offset);\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_client.LocalBuildRunner.cancelAndWait",
	"Comment": "tells build engine to kill the local build, and then waits for local build main thread toterminate",
	"Method": "void cancelAndWait(String message){\r\n    synchronized (this) {\r\n        Objects.requireNonNull(runLocalBuildFuture, String.format(\"Attempting to kill Stampede local %s build which has not been started yet.\", localBuildType));\r\n    }\r\n    LOG.info(String.format(\"Attempting to kill Stampede local %s build. Waiting for Build to be initialized..\", localBuildType));\r\n    initializeBuildLatch.await();\r\n    Build build = Objects.requireNonNull(buildReference.get());\r\n    LOG.info(String.format(\"Killing Build for Stampede local %s build..\", localBuildType));\r\n    build.terminateBuildWithFailure(new CleanBuildShutdownException(message));\r\n    LOG.info(String.format(\"Sent termination signal to Build for Stampede local %s build.\", localBuildType));\r\n    waitUntilFinished();\r\n    LOG.info(String.format(\"Stampede local %s build cancellation complete.\", localBuildType));\r\n}"
}, {
	"Path": "com.facebook.buck.features.apple.project.AbstractProjectGeneratorOptions.shouldGenerateMissingUmbrellaHeader",
	"Comment": "generate an umbrella header for modular targets without one for use in a modulemap",
	"Method": "boolean shouldGenerateMissingUmbrellaHeader(){\r\n    return false;\r\n}"
}, {
	"Path": "com.facebook.buck.parser.PythonDslProjectBuildFileParser.getBuildFileManifest",
	"Comment": "collect all rules from a particular build file, along with meta rules about the rules, forexample which build files the rules depend on.",
	"Method": "BuildFileManifest getBuildFileManifest(Path buildFile){\r\n    try {\r\n        return getAllRulesInternal(buildFile);\r\n    } catch (IOException e) {\r\n        LOG.warn(e, \"Error getting all rules for %s\", buildFile);\r\n        MoreThrowables.propagateIfInterrupt(e);\r\n        throw BuildFileParseException.createForBuildFileParseError(buildFile, e);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.parser.BuildTargetPatternParser.forBaseName",
	"Comment": "used when parsing target names relative to another target, such as in a build file.",
	"Method": "BuildTargetPatternParser<BuildTargetPattern> forBaseName(String baseName){\r\n    Objects.requireNonNull(Strings.emptyToNull(baseName));\r\n    return new BuildFileContext(baseName);\r\n}"
}, {
	"Path": "com.facebook.buck.remoteexecution.grpc.GrpcExecutionFactory.createRemote",
	"Comment": "the remote strategy connects to a remote grpc remote execution service.",
	"Method": "RemoteExecutionClients createRemote(String executionEngineHost,int executionEnginePort,String casHost,int casPort,boolean insecure,boolean casInsecure,Optional<String> executionEngineHostSNIName,Optional<String> casHostSNIName,Optional<Path> certPath,Optional<Path> keyPath,Optional<Path> caPath,Optional<TraceInfoProvider> traceInfoProvider,BuckEventBus buckEventBus){\r\n    ManagedChannel executionEngineChannel;\r\n    if (insecure) {\r\n        executionEngineChannel = createInsecureChannel(executionEngineHost, executionEnginePort);\r\n    } else {\r\n        executionEngineChannel = createSecureChannel(executionEngineHost, executionEnginePort, executionEngineHostSNIName, certPath, keyPath, caPath);\r\n    }\r\n    ManagedChannel casChannel;\r\n    if (casInsecure) {\r\n        casChannel = createInsecureChannel(casHost, casPort);\r\n    } else {\r\n        casChannel = createSecureChannel(casHost, casPort, casHostSNIName, certPath, keyPath, caPath);\r\n    }\r\n    return new GrpcRemoteExecutionClients(\"buck\", executionEngineChannel, casChannel, traceInfoProvider, buckEventBus);\r\n}"
}, {
	"Path": "com.facebook.buck.features.d.DDescriptionUtils.sourcePathsForCompiledSources",
	"Comment": "generates buildtargetpaths and buildrules to compile d sources to object files, and returns alist of sourcepaths referring to the generated object files.",
	"Method": "ImmutableList<SourcePath> sourcePathsForCompiledSources(BuildTarget baseBuildTarget,ProjectFilesystem projectFilesystem,BuildRuleParams baseParams,ActionGraphBuilder graphBuilder,SourcePathResolver sourcePathResolver,SourcePathRuleFinder ruleFinder,CxxPlatform cxxPlatform,DBuckConfig dBuckConfig,ImmutableList<String> compilerFlags,SourceSortedSet sources,DIncludes includes){\r\n    ImmutableList.Builder<SourcePath> sourcePaths = ImmutableList.builder();\r\n    for (Map.Entry<String, SourcePath> source : sources.toNameMap(baseBuildTarget, sourcePathResolver, \"srcs\").entrySet()) {\r\n        BuildTarget compileTarget = createDCompileBuildTarget(baseBuildTarget, source.getKey(), cxxPlatform);\r\n        BuildRule rule = requireBuildRule(compileTarget, baseBuildTarget, projectFilesystem, baseParams, graphBuilder, ruleFinder, dBuckConfig, compilerFlags, source.getKey(), source.getValue(), includes);\r\n        sourcePaths.add(rule.getSourcePathToOutput());\r\n    }\r\n    return sourcePaths.build();\r\n}"
}, {
	"Path": "com.facebook.buck.rules.coercer.TypeCoercerTest.disallowAmbiguousSimpleTypes",
	"Comment": "specifying a field type that matches too many coercers should be disallowed.",
	"Method": "void disallowAmbiguousSimpleTypes(){\r\n    Type type = TestFields.class.getField(\"object\").getGenericType();\r\n    typeCoercerFactory.typeCoercerForType(type);\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.UnixUtils.getBuckCommandBuilder",
	"Comment": "returns a buck command builder for a unix platform, which runs buck through its .pex file",
	"Method": "ImmutableList.Builder<String> getBuckCommandBuilder(){\r\n    return getCommandBuilder().add(BUCK_EXE);\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.CxxSourceTypes.isPreprocessableType",
	"Comment": "returns true for source types which can be run through the c preprocessor.",
	"Method": "boolean isPreprocessableType(CxxSource.Type sourceType){\r\n    return sourceType == CxxSource.Type.C || sourceType == CxxSource.Type.CXX || sourceType == CxxSource.Type.ASSEMBLER_WITH_CPP || sourceType == CxxSource.Type.OBJC || sourceType == CxxSource.Type.OBJCXX || sourceType == CxxSource.Type.CUDA || sourceType == CxxSource.Type.HIP || sourceType == CxxSource.Type.ASM_WITH_CPP || sourceType == CxxSource.Type.PCM;\r\n}"
}, {
	"Path": "com.facebook.buck.parser.DefaultProjectBuildFileParserFactory.createTargetCountingWrapper",
	"Comment": "creates a delegate wrapper that counts the number of targets declared in a parsed file",
	"Method": "ProjectBuildFileParser createTargetCountingWrapper(ProjectBuildFileParser aggregate,int targetCountThreshold,BuckEventBus eventBus){\r\n    return new TargetCountVerificationParserDecorator(aggregate, targetCountThreshold, eventBus);\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getBUnit",
	"Comment": "gets the b register number, as a code unit. this will throw if thevalue is out of the range of an unsigned code unit.",
	"Method": "short getBUnit(){\r\n    int b = getB();\r\n    if ((b & ~0xffff) != 0) {\r\n        throw new DexException(\"Register B out of range: \" + Hex.u8(b));\r\n    }\r\n    return (short) b;\r\n}"
}, {
	"Path": "com.facebook.buck.testrunner.BuildThenTestIntegrationTest.testBuildThenTest",
	"Comment": "it is possible to build a test without running it. it is important to make sure that eventhough a test built successfully, it knows that it needs to run itself if its results are notavailable.",
	"Method": "void testBuildThenTest(){\r\n    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(this, \"build_then_test\", temporaryFolder);\r\n    workspace.setUp();\r\n    ProcessResult buildResult = workspace.runBuckCommand(\"build\", \"//:example\");\r\n    buildResult.assertSuccess(\"Successful build should exit with 0.\");\r\n    ProcessResult testResult = workspace.runBuckCommand(\"test\", \"//:example\");\r\n    assertEquals(\"\", testResult.getStdout());\r\n    assertThat(\"Should contain a line indicating what target it is testing\", testResult.getStderr(), containsString(\"TESTING //:example\"));\r\n    assertThat(\"Should contain results from the target.\", testResult.getStderr(), containsBuckTestOutputLine(\"PASS\", 1, 0, 0, \"com.example.MyTest\"));\r\n    assertThat(\"Should contain a line indicating that tests passed.\", testResult.getStderr(), containsString(\"TESTS PASSED\"));\r\n    testResult.assertSuccess(\"Passing tests should exit with 0.\");\r\n    workspace.verify();\r\n}"
}, {
	"Path": "com.android.dx.dex.file.DebugInfoEncoder.entryAnnotationString",
	"Comment": "returns a string representation of this locallist entry that isappropriate for emitting as an annotation.",
	"Method": "String entryAnnotationString(LocalList.Entry e){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(RegisterSpec.PREFIX);\r\n    sb.append(e.getRegister());\r\n    sb.append(' ');\r\n    CstString name = e.getName();\r\n    if (name == null) {\r\n        sb.append(\"null\");\r\n    } else {\r\n        sb.append(name.toHuman());\r\n    }\r\n    sb.append(' ');\r\n    CstType type = e.getType();\r\n    if (type == null) {\r\n        sb.append(\"null\");\r\n    } else {\r\n        sb.append(type.toHuman());\r\n    }\r\n    CstString signature = e.getSignature();\r\n    if (signature != null) {\r\n        sb.append(' ');\r\n        sb.append(signature.toHuman());\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.android.dx.dex.file.StringIdsSection.writeHeaderPart",
	"Comment": "writes the portion of the file header that refers to this instance.",
	"Method": "void writeHeaderPart(AnnotatedOutput out){\r\n    throwIfNotPrepared();\r\n    int sz = strings.size();\r\n    int offset = (sz == 0) ? 0 : getFileOffset();\r\n    if (out.annotates()) {\r\n        out.annotate(4, \"string_ids_size: \" + Hex.u4(sz));\r\n        out.annotate(4, \"string_ids_off:  \" + Hex.u4(offset));\r\n    }\r\n    out.writeInt(sz);\r\n    out.writeInt(offset);\r\n}"
}, {
	"Path": "com.android.dx.dex.file.MixedItemSection.writeHeaderPart",
	"Comment": "writes the portion of the file header that refers to this instance.",
	"Method": "void writeHeaderPart(AnnotatedOutput out){\r\n    throwIfNotPrepared();\r\n    if (writeSize == -1) {\r\n        throw new RuntimeException(\"write size not yet set\");\r\n    }\r\n    int sz = writeSize;\r\n    int offset = (sz == 0) ? 0 : getFileOffset();\r\n    String name = getName();\r\n    if (name == null) {\r\n        name = \"<unnamed>\";\r\n    }\r\n    int spaceCount = 15 - name.length();\r\n    char[] spaceArr = new char[spaceCount];\r\n    Arrays.fill(spaceArr, ' ');\r\n    String spaces = new String(spaceArr);\r\n    if (out.annotates()) {\r\n        out.annotate(4, name + \"_size:\" + spaces + Hex.u4(sz));\r\n        out.annotate(4, name + \"_off: \" + spaces + Hex.u4(offset));\r\n    }\r\n    out.writeInt(sz);\r\n    out.writeInt(offset);\r\n}"
}, {
	"Path": "com.facebook.buck.parser.decorators.EventReportingProjectBuildFileParser.maybePostFinishedEvent",
	"Comment": "post a finished event in case start event was posted previously.",
	"Method": "void maybePostFinishedEvent(){\r\n    synchronized (eventLock) {\r\n        if (projectBuildFileParseEventStarted != null) {\r\n            eventBus.post(new ProjectBuildFileParseEvents.Finished(Objects.requireNonNull(projectBuildFileParseEventStarted)));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.core.util.graph.AcyclicDepthFirstPostOrderTraversalTest.testCycleExceptionDoesNotContainUnrelatedNodes",
	"Comment": "verifies that the reported cycle mentions only a, b, and d, but not c or e.a",
	"Method": "void testCycleExceptionDoesNotContainUnrelatedNodes(){\r\n    Multimap<String, String> graph = LinkedListMultimap.create();\r\n    graph.put(\"A\", \"B\");\r\n    graph.put(\"B\", \"C\");\r\n    graph.put(\"B\", \"D\");\r\n    graph.put(\"B\", \"E\");\r\n    graph.put(\"D\", \"A\");\r\n    TestDagDepthFirstSearch dfs = new TestDagDepthFirstSearch(graph);\r\n    try {\r\n        dfs.traverse(ImmutableList.of(\"A\"));\r\n    } catch (CycleException e) {\r\n        assertThat(e.getMessage(), Matchers.containsString(linesToText(\"The following circular dependency has been found:\", \"A -> B -> D -> A\")));\r\n        assertEquals(ImmutableList.of(\"A\", \"B\", \"D\", \"A\"), e.getCycle());\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.worker.WorkerProcessPoolFactory.getWorkerProcessPool",
	"Comment": "returns an existing workerprocesspool for the given job params if one exists, otherwise createsa new one.",
	"Method": "WorkerProcessPool getWorkerProcessPool(ExecutionContext context,WorkerProcessParams paramsToUse){\r\n    ConcurrentMap<String, WorkerProcessPool> processPoolMap;\r\n    String key;\r\n    HashCode workerHash;\r\n    if (paramsToUse.getWorkerProcessIdentity().isPresent() && context.getPersistentWorkerPools().isPresent()) {\r\n        processPoolMap = context.getPersistentWorkerPools().get();\r\n        key = paramsToUse.getWorkerProcessIdentity().get().getPersistentWorkerKey();\r\n        workerHash = paramsToUse.getWorkerProcessIdentity().get().getWorkerHash();\r\n    } else {\r\n        processPoolMap = context.getWorkerProcessPools();\r\n        key = Joiner.on(' ').join(getCommand(context.getPlatform(), paramsToUse));\r\n        workerHash = Hashing.sha1().hashString(key, StandardCharsets.UTF_8);\r\n    }\r\n    WorkerProcessPool pool = processPoolMap.get(key);\r\n    if (pool != null && !pool.getPoolHash().equals(workerHash)) {\r\n        if (processPoolMap.remove(key, pool)) {\r\n            pool.close();\r\n        }\r\n        pool = processPoolMap.get(key);\r\n    }\r\n    if (pool == null) {\r\n        pool = createWorkerProcessPool(context, paramsToUse, processPoolMap, key, workerHash);\r\n    }\r\n    int poolCapacity = pool.getCapacity();\r\n    if (poolCapacity != paramsToUse.getMaxWorkers()) {\r\n        context.postEvent(ConsoleEvent.warning(\"There are two 'worker_tool' targets declared with the same command (%s), but \" + \"different 'max_worker' settings (%d and %d). Only the first capacity is applied. \" + \"Consolidate these workers to avoid this warning.\", key, poolCapacity, paramsToUse.getMaxWorkers()));\r\n    }\r\n    return pool;\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.AbstractConsoleEventBusListener.renderRemoteUploads",
	"Comment": "a method to print the line responsible to show how our remote cache upload goes.",
	"Method": "String renderRemoteUploads(){\r\n    long bytesUploaded = remoteArtifactTotalBytesUploaded.longValue();\r\n    String humanReadableBytesUploaded = convertToAllCapsIfNeeded(SizeUnit.toHumanReadableString(SizeUnit.getHumanReadableSize(bytesUploaded, SizeUnit.BYTES), locale));\r\n    int scheduled = remoteArtifactUploadsScheduledCount.get();\r\n    int complete = remoteArtifactUploadedCount.get();\r\n    int failed = remoteArtifactUploadFailedCount.get();\r\n    int uploading = remoteArtifactUploadsStartedCount.get() - (complete + failed);\r\n    int pending = scheduled - (uploading + complete + failed);\r\n    if (scheduled > 0) {\r\n        return String.format(\"%s (%d COMPLETE/%d FAILED/%d UPLOADING/%d PENDING)\", humanReadableBytesUploaded, complete, failed, uploading, pending);\r\n    } else {\r\n        return humanReadableBytesUploaded;\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.dex.file.Section.getFileOffset",
	"Comment": "gets the offset from the start of the file to this part. thisthrows an exception if the offset has not yet been set.",
	"Method": "int getFileOffset(){\r\n    if (fileOffset < 0) {\r\n        throw new RuntimeException(\"fileOffset not set\");\r\n    }\r\n    return fileOffset;\r\n}"
}, {
	"Path": "com.facebook.buck.io.filesystem.impl.DefaultProjectFilesystem.deleteFileAtPath",
	"Comment": "deletes a file specified by its path relative to the project root.",
	"Method": "void deleteFileAtPath(Path pathRelativeToProjectRoot){\r\n    Files.delete(getPathForRelativePath(pathRelativeToProjectRoot));\r\n}"
}, {
	"Path": "com.android.dx.dex.code.InsnFormat.cstComment",
	"Comment": "helper method to return an instruction comment for a constant.",
	"Method": "String cstComment(DalvInsn insn){\r\n    CstInsn ci = (CstInsn) insn;\r\n    if (!ci.hasIndex()) {\r\n        return \"\";\r\n    }\r\n    StringBuilder sb = new StringBuilder(20);\r\n    int index = ci.getIndex();\r\n    sb.append(ci.getConstant().typeName());\r\n    sb.append('@');\r\n    if (index < 65536) {\r\n        sb.append(Hex.u2(index));\r\n    } else {\r\n        sb.append(Hex.u4(index));\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.facebook.buck.rules.coercer.TypeCoercerTest.traverseShouldVisitEveryObject",
	"Comment": "traverse visits every element of an input value without coercing to the output type.",
	"Method": "void traverseShouldVisitEveryObject(){\r\n    Type type = TestFields.class.getField(\"stringMapOfLists\").getGenericType();\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeCoercer<ImmutableMap<String, ImmutableList<String>>> coercer = (TypeCoercer<ImmutableMap<String, ImmutableList<String>>>) typeCoercerFactory.typeCoercerForType(type);\r\n    ImmutableMap<String, ImmutableList<String>> input = ImmutableMap.of(\"foo\", ImmutableList.of(\"//foo:bar\", \"//foo:baz\"), \"bar\", ImmutableList.of(\":bar\", \"//foo:foo\"));\r\n    TestTraversal traversal = new TestTraversal();\r\n    coercer.traverse(cellRoots, input, traversal);\r\n    Matcher<Iterable<?>> matcher = Matchers.contains(ImmutableList.of(sameInstance((Object) input), is((Object) \"foo\"), sameInstance((Object) input.get(\"foo\")), is((Object) \"//foo:bar\"), is((Object) \"//foo:baz\"), is((Object) \"bar\"), sameInstance((Object) input.get(\"bar\")), is((Object) \":bar\"), is((Object) \"//foo:foo\")));\r\n    assertThat(traversal.getObjects(), matcher);\r\n}"
}, {
	"Path": "com.facebook.buck.rules.modern.impl.ModernBuildableSupport.newCellRelativePathFactory",
	"Comment": "creates a buildcellrelativepathfactory for a build root and filesystem pair.",
	"Method": "BuildCellRelativePathFactory newCellRelativePathFactory(Path buildCellRootPath,ProjectFilesystem projectFilesystem){\r\n    return new DefaultBuildCellRelativePathFactory(buildCellRootPath, projectFilesystem, Optional.empty());\r\n}"
}, {
	"Path": "com.android.dx.dex.code.DalvInsn.identifierString",
	"Comment": "gets the short identifier for this instruction. this is itsaddress, if assigned, or its identity hashcode if not.",
	"Method": "String identifierString(){\r\n    if (address != -1) {\r\n        return String.format(\"x\", address);\r\n    }\r\n    return Hex.u4(System.identityHashCode(this));\r\n}"
}, {
	"Path": "com.android.dex.Leb128.signedLeb128Size",
	"Comment": "gets the number of bytes in the signed leb128 encoding of thegiven value.",
	"Method": "int signedLeb128Size(int value){\r\n    int remaining = value >> 7;\r\n    int count = 0;\r\n    boolean hasMore = true;\r\n    int end = ((value & Integer.MIN_VALUE) == 0) ? 0 : -1;\r\n    while (hasMore) {\r\n        hasMore = (remaining != end) || ((remaining & 1) != ((value >> 6) & 1));\r\n        value = remaining;\r\n        remaining >>= 7;\r\n        count++;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getLiteralInt",
	"Comment": "gets the literal value, masked to be an int in size. this willthrow if the value is out of the range of a signed int.",
	"Method": "int getLiteralInt(){\r\n    if (literal != (int) literal) {\r\n        throw new DexException(\"Literal out of range: \" + Hex.u8(literal));\r\n    }\r\n    return (int) literal;\r\n}"
}, {
	"Path": "com.facebook.buck.rules.modern.OutputPathResolver.getTempPath",
	"Comment": "returns a relative path to the root directory for intermediate build outputs.",
	"Method": "Path getTempPath(Path getTempPath,String file){\r\n    return getTempPath().resolve(file);\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getAByte",
	"Comment": "gets the a register number, as a byte. this will throw if thevalue is out of the range of an unsigned byte.",
	"Method": "short getAByte(){\r\n    int a = getA();\r\n    if ((a & ~0xff) != 0) {\r\n        throw new DexException(\"Register A out of range: \" + Hex.u8(a));\r\n    }\r\n    return (short) a;\r\n}"
}, {
	"Path": "com.android.dx.dex.file.IndexedItem.hasIndex",
	"Comment": "gets whether or not this instance has been assigned an index.",
	"Method": "boolean hasIndex(){\r\n    return (index >= 0);\r\n}"
}, {
	"Path": "com.facebook.buck.features.apple.project.FocusedModuleTargetMatcher.isFocusedOn",
	"Comment": "test whether target matches any focused targets.if there is no focus, always return true.",
	"Method": "boolean isFocusedOn(BuildTarget buildTarget){\r\n    if (focusedTargets != null) {\r\n        return focusedTargets.contains(buildTarget.getUnflavoredBuildTarget());\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.dex.code.OutputCollector.reverseBranch",
	"Comment": "reverses a branch which is buried a given number of instructionsbackward in the output. it is illegal to call this unless theindicated instruction really is a reversible branch.",
	"Method": "void reverseBranch(int which,CodeAddress newTarget){\r\n    finisher.reverseBranch(which, newTarget);\r\n}"
}, {
	"Path": "com.facebook.buck.features.filebundler.ZipFileExtractor.extractZipFiles",
	"Comment": "given a list of archive files, generates a list of steps to extract those files in a givenlocation.",
	"Method": "ImmutableList<Step> extractZipFiles(BuildTarget target,ProjectFilesystem filesystem,Path destinationDir,Iterable<SourcePath> toExtract,SourcePathResolver pathResolver,PatternsMatcher entriesToExclude){\r\n    ImmutableList.Builder<Step> steps = ImmutableList.builder();\r\n    Map<Path, Path> relativeMap = createRelativeMap(target.getBasePath(), filesystem, pathResolver, toExtract);\r\n    for (Map.Entry<Path, Path> pathEntry : relativeMap.entrySet()) {\r\n        Path relativePath = pathEntry.getKey();\r\n        Path absolutePath = Objects.requireNonNull(pathEntry.getValue());\r\n        Path destination = destinationDir.resolve(relativePath);\r\n        steps.add(new UnzipStep(filesystem, absolutePath, destination.getParent(), Optional.empty(), entriesToExclude));\r\n    }\r\n    return steps.build();\r\n}"
}, {
	"Path": "com.facebook.buck.sandbox.darwin.DarwinSandbox.createVerificationCommandLineArguments",
	"Comment": "creates a list of cl arguments to run a sandbox to verify that sandbox is functioning",
	"Method": "ImmutableList<String> createVerificationCommandLineArguments(){\r\n    return ImmutableList.<String>builder().add(SANDBOX_EXEC).add(\"-p\").add(\"(version 1) (allow default)\").add(\"/usr/bin/true\").build();\r\n}"
}, {
	"Path": "com.android.dx.dex.cf.OptimizerOptions.compareOptimizerStep",
	"Comment": "compares the output of the optimizer run normally with a run skippingsome optional steps. results are printed to stderr.",
	"Method": "void compareOptimizerStep(RopMethod nonOptRmeth,int paramSize,boolean isStatic,CfOptions args,TranslationAdvice advice,RopMethod rmeth){\r\n    EnumSet<Optimizer.OptionalStep> steps;\r\n    steps = EnumSet.allOf(Optimizer.OptionalStep.class);\r\n    steps.remove(Optimizer.OptionalStep.CONST_COLLECTOR);\r\n    RopMethod skipRopMethod = Optimizer.optimize(nonOptRmeth, paramSize, isStatic, args.localInfo, advice, steps);\r\n    int normalInsns = rmeth.getBlocks().getEffectiveInstructionCount();\r\n    int skipInsns = skipRopMethod.getBlocks().getEffectiveInstructionCount();\r\n    System.err.printf(\"optimize step regs:(%d/%d/%.2f%%)\" + \" insns:(%d/%d/%.2f%%)\\n\", rmeth.getBlocks().getRegCount(), skipRopMethod.getBlocks().getRegCount(), 100.0 * ((skipRopMethod.getBlocks().getRegCount() - rmeth.getBlocks().getRegCount()) / (float) skipRopMethod.getBlocks().getRegCount()), normalInsns, skipInsns, 100.0 * ((skipInsns - normalInsns) / (float) skipInsns));\r\n}"
}, {
	"Path": "com.android.dx.dex.file.DebugInfoDecoder.validateEncode",
	"Comment": "validates an encoded debug info stream against data used to encode it,throwing an exception if they do not match. used to validate theencoder.",
	"Method": "void validateEncode(byte[] info,DexFile file,CstMethodRef ref,DalvCode code,boolean isStatic){\r\n    PositionList pl = code.getPositions();\r\n    LocalList ll = code.getLocals();\r\n    DalvInsnList insns = code.getInsns();\r\n    int codeSize = insns.codeSize();\r\n    int countRegisters = insns.getRegistersSize();\r\n    try {\r\n        validateEncode0(info, codeSize, countRegisters, isStatic, ref, file, pl, ll);\r\n    } catch (RuntimeException ex) {\r\n        System.err.println(\"instructions:\");\r\n        insns.debugPrint(System.err, \"  \", true);\r\n        System.err.println(\"local list:\");\r\n        ll.debugPrint(System.err, \"  \");\r\n        throw ExceptionWithContext.withContext(ex, \"while processing \" + ref.toHuman());\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.dex.file.Item.typeName",
	"Comment": "returns the human name for the particular type of item thisinstance is.",
	"Method": "String typeName(){\r\n    return itemType().toHuman();\r\n}"
}, {
	"Path": "com.android.dx.dex.file.ValueEncoder.constantToHuman",
	"Comment": "gets the colloquial type name and human form of the type of thegiven constant, when used as an encoded value.",
	"Method": "String constantToHuman(Constant cst){\r\n    int type = constantToValueType(cst);\r\n    if (type == VALUE_NULL) {\r\n        return \"null\";\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(cst.typeName());\r\n    sb.append(' ');\r\n    sb.append(cst.toHuman());\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.facebook.buck.features.apple.project.ProjectGenerator.rulesWithoutFrameworkBundles",
	"Comment": "returns a new list of rules which does not contain framework bundles.",
	"Method": "ImmutableList<TargetNode<?>> rulesWithoutFrameworkBundles(Iterable<TargetNode<?>> copiedRules){\r\n    return RichStream.from(copiedRules).filter(input -> TargetNodes.castArg(input, AppleBundleDescriptionArg.class).map(argTargetNode -> !isFrameworkBundle(argTargetNode.getConstructorArg())).orElse(true)).toImmutableList();\r\n}"
}, {
	"Path": "com.android.manifmerger.XmlAttribute.getId",
	"Comment": "returns a display friendly identification string that can be used in machine and userreadable messages.",
	"Method": "NodeKey getId(){\r\n    String myName = mXml.getNamespaceURI() == null ? mXml.getName() : mXml.getLocalName();\r\n    return new NodeKey(mOwnerElement.getId() + \"@\" + myName);\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.DistBuildConfig.getLocalBuildMode",
	"Comment": "this returns the mode that the local will have, either wait for remote build, run at the sametime or fire up the remote build and shut down local client.",
	"Method": "DistLocalBuildMode getLocalBuildMode(){\r\n    return buckConfig.getEnum(STAMPEDE_SECTION, LOCAL_MODE, DistLocalBuildMode.class).orElse(DEFAULT_LOCAL_MODE);\r\n}"
}, {
	"Path": "com.android.dx.merge.DexMerger.transformAnnotationSet",
	"Comment": "transform all annotations on a single type, member or parameter.",
	"Method": "void transformAnnotationSet(IndexMap indexMap,Dex.Section setIn){\r\n    contentsOut.annotationSets.size++;\r\n    annotationSetOut.assertFourByteAligned();\r\n    indexMap.putAnnotationSetOffset(setIn.getPosition(), annotationSetOut.getPosition());\r\n    int size = setIn.readInt();\r\n    annotationSetOut.writeInt(size);\r\n    for (int j = 0; j < size; j++) {\r\n        annotationSetOut.writeInt(indexMap.adjustAnnotation(setIn.readInt()));\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.JarBuildStepsFactory.getCoveredByDepFilePredicate",
	"Comment": "returns a predicate indicating whether a sourcepath is covered by the depfile.",
	"Method": "Predicate<SourcePath> getCoveredByDepFilePredicate(SourcePathResolver pathResolver,SourcePathRuleFinder ruleFinder){\r\n    return abiClasspath.getArchiveMembers(pathResolver, ruleFinder).collect(ImmutableSet.toImmutableSet())::contains;\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.DistBuildService.sendAllBuildRulesPublishedEvent",
	"Comment": "let the client no that there are no more build rule finished events on the way.",
	"Method": "void sendAllBuildRulesPublishedEvent(StampedeId stampedeId,BuildSlaveRunId runId,long timeMillis){\r\n    LOG.info(\"Sending all build rules finished event\");\r\n    AppendBuildSlaveEventsRequest request = new AppendBuildSlaveEventsRequest();\r\n    request.setStampedeId(stampedeId);\r\n    request.setBuildSlaveRunId(runId);\r\n    BuildSlaveEvent buildSlaveEvent = DistBuildUtil.createBuildSlaveEvent(BuildSlaveEventType.ALL_BUILD_RULES_FINISHED_EVENT, timeMillis);\r\n    request.addToEvents(ThriftUtil.serializeToByteBuffer(PROTOCOL_FOR_CLIENT_ONLY_STRUCTS, buildSlaveEvent));\r\n    FrontendRequest frontendRequest = new FrontendRequest();\r\n    frontendRequest.setType(FrontendRequestType.APPEND_BUILD_SLAVE_EVENTS);\r\n    frontendRequest.setAppendBuildSlaveEventsRequest(request);\r\n    makeRequestChecked(frontendRequest);\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.endtoend.CxxDependentOnPyEndToEndTest.shouldBuildAndRun",
	"Comment": "determines that buck successfully outputs proper programs",
	"Method": "void shouldBuildAndRun(EndToEndTestDescriptor test,EndToEndWorkspace workspace){\r\n    checkSuccessfulBuildAndRun(\"Did not successfully %s.\", test, workspace);\r\n}"
}, {
	"Path": "com.facebook.buck.android.resources.ChunkUtils.findChunks",
	"Comment": "finds all chunks in the buffer with the requested type. this is useful for tests to find chunksof a certain type without needing to understand all the other encountered chunks.",
	"Method": "List<Integer> findChunks(ByteBuffer data,int wantedType){\r\n    ByteBuffer buf = ResChunk.slice(data, 0);\r\n    ImmutableList.Builder<Integer> offsetsBuilder = ImmutableList.builder();\r\n    int offset = 0;\r\n    while (offset < buf.limit()) {\r\n        int type = buf.getShort(offset);\r\n        if (type == wantedType) {\r\n            offsetsBuilder.add(offset);\r\n        }\r\n        int headerSize = buf.getShort(offset + 2);\r\n        int chunkSize = buf.getInt(offset + 4);\r\n        if (type == ResChunk.CHUNK_RESOURCE_TABLE || type == ResChunk.CHUNK_RES_TABLE_PACKAGE || type == ResChunk.CHUNK_XML_TREE) {\r\n            int subchunksStart = offset + headerSize;\r\n            int subchunksLength = chunkSize - headerSize;\r\n            for (int subOffset : findChunks(ResChunk.slice(buf, subchunksStart, subchunksLength), wantedType)) {\r\n                offsetsBuilder.add(subchunksStart + subOffset);\r\n            }\r\n        }\r\n        offset += chunkSize;\r\n    }\r\n    return offsetsBuilder.build();\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.DefaultJavaLibraryIntegrationTest.testAddedSourceFileInvalidatesManifest",
	"Comment": "yes, we actually had the bug against which this test is guarding.",
	"Method": "void testAddedSourceFileInvalidatesManifest(){\r\n    setUpProjectWorkspaceForScenario(\"manifest_key\");\r\n    workspace.enableDirCache();\r\n    BuildTarget mainTarget = BuildTargetFactory.newInstance(\"//:main\");\r\n    ProcessResult buildResult = workspace.runBuckCommand(\"build\", mainTarget.getFullyQualifiedName());\r\n    buildResult.assertSuccess(\"Successful build should exit with 0.\");\r\n    workspace.getBuildLog().assertTargetBuiltLocally(\"//:main\");\r\n    ProcessResult cleanResult = workspace.runBuckCommand(\"clean\", \"--keep-cache\");\r\n    cleanResult.assertSuccess(\"Successful clean should exit with 0.\");\r\n    workspace.writeContentsToPath(\"package com.example; public class NewClass { }\", \"NewClass.java\");\r\n    ProcessResult buildResult2 = workspace.runBuckCommand(\"build\", mainTarget.getFullyQualifiedName());\r\n    buildResult2.assertSuccess(\"Successful build should exit with 0.\");\r\n    workspace.getBuildLog().assertTargetBuiltLocally(\"//:main\");\r\n}"
}, {
	"Path": "com.facebook.buck.features.apple.project.ProjectGenerator.getCopyFilesBuildPhases",
	"Comment": "convert a list of rules that should be somehow included into the bundle, into build phaseswhich copies them into the bundle. the parameters of these copy phases are divined byscrutinizing the type of node we want to include.",
	"Method": "ImmutableList<PBXBuildPhase> getCopyFilesBuildPhases(Iterable<TargetNode<?>> copiedNodes){\r\n    ImmutableSetMultimap.Builder<CopyFilePhaseDestinationSpec, TargetNode<?>> ruleByDestinationSpecBuilder = ImmutableSetMultimap.builder();\r\n    for (TargetNode<?> copiedNode : copiedNodes) {\r\n        getDestinationSpec(copiedNode).ifPresent(copyFilePhaseDestinationSpec -> ruleByDestinationSpecBuilder.put(copyFilePhaseDestinationSpec, copiedNode));\r\n    }\r\n    ImmutableList.Builder<PBXBuildPhase> phases = ImmutableList.builder();\r\n    ImmutableSetMultimap<CopyFilePhaseDestinationSpec, TargetNode<?>> ruleByDestinationSpec = ruleByDestinationSpecBuilder.build();\r\n    for (CopyFilePhaseDestinationSpec destinationSpec : ruleByDestinationSpec.keySet()) {\r\n        Iterable<TargetNode<?>> targetNodes = ruleByDestinationSpec.get(destinationSpec);\r\n        phases.add(getSingleCopyFilesBuildPhase(destinationSpec, targetNodes));\r\n    }\r\n    return phases.build();\r\n}"
}, {
	"Path": "com.facebook.buck.apple.CodeSigning.hasValidSignature",
	"Comment": "checks whether a binary or bundle already has a valid code signature.",
	"Method": "boolean hasValidSignature(ProcessExecutor processExecutor,Path path){\r\n    ProcessExecutorParams processExecutorParams = ProcessExecutorParams.builder().setCommand(ImmutableList.of(\"codesign\", \"--verify\", \"-v\", path.toString())).build();\r\n    Set<ProcessExecutor.Option> options = EnumSet.of(ProcessExecutor.Option.EXPECTING_STD_OUT, ProcessExecutor.Option.IS_SILENT);\r\n    ProcessExecutor.Result result = processExecutor.launchAndExecute(processExecutorParams, options, Optional.empty(), Optional.empty(), Optional.empty());\r\n    return result.getExitCode() == 0 && result.getStderr().isPresent() && result.getStderr().get().contains(\": satisfies its Designated Requirement\");\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.lang.model.BridgeMethodsTest.testNoHypotheticalBridges",
	"Comment": "a hypothetical bridge is one that the compiler adds to its internal data structures when theerasure would be different in the subclass, but there is no override and thus no runtimeconfusion. it adds this bridge to detect erasure clashes, but it does not actually get emittedto the class file.",
	"Method": "void testNoHypotheticalBridges(){\r\n    compile(ImmutableMap.of(\"Super.java\", Joiner.on('\\n').join(\"package com.example.buck;\", \"public class Super<T> {\", \"  public T method() { return null; }\", \"}\"), \"Subclass.java\", Joiner.on('\\n').join(\"package com.example.buck;\", \"public class Subclass extends Super<String> { }\")));\r\n    TypeElement subclass = elements.getTypeElement(\"com.example.buck.Subclass\");\r\n    assertNoNeededBridges(subclass);\r\n}"
}, {
	"Path": "com.android.dx.dex.file.StringIdItem.getData",
	"Comment": "gets the associated data object for this instance, if known.",
	"Method": "StringDataItem getData(){\r\n    return data;\r\n}"
}, {
	"Path": "com.android.dx.dex.code.SwitchData.shouldPack",
	"Comment": "determines whether the given list of cases warrant being packed.",
	"Method": "boolean shouldPack(IntList cases){\r\n    int sz = cases.size();\r\n    if (sz < 2) {\r\n        return true;\r\n    }\r\n    long packedSize = packedCodeSize(cases);\r\n    long sparseSize = sparseCodeSize(cases);\r\n    return (packedSize >= 0) && (packedSize <= ((sparseSize * 5) / 4));\r\n}"
}, {
	"Path": "com.android.dx.dex.code.DalvInsnList.getOutsSize",
	"Comment": "gets the size of the outgoing arguments area required by thismethod. this is equal to the largest argument word count of anymethod referred to by this instance.",
	"Method": "int getOutsSize(){\r\n    int sz = size();\r\n    int result = 0;\r\n    for (int i = 0; i < sz; i++) {\r\n        DalvInsn insn = (DalvInsn) get0(i);\r\n        if (!(insn instanceof CstInsn)) {\r\n            continue;\r\n        }\r\n        Constant cst = ((CstInsn) insn).getConstant();\r\n        if (!(cst instanceof CstBaseMethodRef)) {\r\n            continue;\r\n        }\r\n        boolean isStatic = (insn.getOpcode().getFamily() == Opcodes.INVOKE_STATIC);\r\n        int count = ((CstBaseMethodRef) cst).getParameterWordCount(isStatic);\r\n        if (count > result) {\r\n            result = count;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.android.dx.dex.file.AnnotationsDirectoryItem.setClassAnnotations",
	"Comment": "sets the direct annotations on this instance. these are annotationsmade on the class, per se, as opposed to on one of its members.it is only valid to call this method at most once per instance.",
	"Method": "void setClassAnnotations(Annotations annotations,DexFile dexFile){\r\n    if (annotations == null) {\r\n        throw new NullPointerException(\"annotations == null\");\r\n    }\r\n    if (classAnnotations != null) {\r\n        throw new UnsupportedOperationException(\"class annotations already set\");\r\n    }\r\n    classAnnotations = new AnnotationSetItem(annotations, dexFile);\r\n}"
}, {
	"Path": "com.facebook.buck.features.apple.project.ProjectGenerator.addToMergedHeaderMap",
	"Comment": "adds the set of headers defined by headervisibility to the merged header maps.",
	"Method": "void addToMergedHeaderMap(TargetNode<? extends CxxLibraryDescription.CommonArg> targetNode,HeaderMap.Builder headerMapBuilder){\r\n    CxxLibraryDescription.CommonArg arg = targetNode.getConstructorArg();\r\n    boolean shouldCreateHeadersSymlinks = arg.getXcodePublicHeadersSymlinks().orElse(cxxBuckConfig.getPublicHeadersSymlinksEnabled());\r\n    Path headerSymlinkTreeRoot = getPathToHeaderSymlinkTree(targetNode, HeaderVisibility.PUBLIC);\r\n    Path basePath;\r\n    if (shouldCreateHeadersSymlinks) {\r\n        basePath = projectFilesystem.getRootPath().resolve(targetNode.getBuildTarget().getCellPath()).resolve(headerSymlinkTreeRoot);\r\n    } else {\r\n        basePath = projectFilesystem.getRootPath();\r\n    }\r\n    for (Map.Entry<Path, SourcePath> entry : getPublicCxxHeaders(targetNode).entrySet()) {\r\n        Path path;\r\n        if (shouldCreateHeadersSymlinks) {\r\n            path = basePath.resolve(entry.getKey());\r\n        } else {\r\n            path = basePath.resolve(resolveSourcePath(entry.getValue()));\r\n        }\r\n        headerMapBuilder.add(entry.getKey().toString(), path);\r\n    }\r\n    ImmutableMap<Path, Path> swiftHeaderMapEntries = getSwiftPublicHeaderMapEntriesForTarget(targetNode);\r\n    for (Map.Entry<Path, Path> entry : swiftHeaderMapEntries.entrySet()) {\r\n        headerMapBuilder.add(entry.getKey().toString(), entry.getValue());\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.features.apple.project.ProjectGenerator.computeSharedLibrariesToBundles",
	"Comment": "generate a mapping from libraries to the framework bundles that include them.",
	"Method": "ImmutableMap<BuildTarget, TargetNode<?>> computeSharedLibrariesToBundles(ImmutableSet<TargetNode<?>> targetNodes,TargetGraphAndTargets targetGraphAndTargets){\r\n    Map<BuildTarget, TargetNode<?>> sharedLibraryToBundle = new HashMap();\r\n    for (TargetNode<?> targetNode : targetNodes) {\r\n        if (targetNode.getBuildTarget().isFlavored()) {\r\n            continue;\r\n        }\r\n        Optional<TargetNode<CxxLibraryDescription.CommonArg>> binaryNode = TargetNodes.castArg(targetNode, AppleBundleDescriptionArg.class).flatMap(bundleNode -> bundleNode.getConstructorArg().getBinary()).map(target -> targetGraphAndTargets.getTargetGraph().get(target)).flatMap(node -> TargetNodes.castArg(node, CxxLibraryDescription.CommonArg.class));\r\n        if (!binaryNode.isPresent()) {\r\n            continue;\r\n        }\r\n        CxxLibraryDescription.CommonArg arg = binaryNode.get().getConstructorArg();\r\n        if (arg.getPreferredLinkage().equals(Optional.of(Linkage.SHARED))) {\r\n            BuildTarget binaryBuildTargetWithoutFlavors = binaryNode.get().getBuildTarget().withoutFlavors();\r\n            if (sharedLibraryToBundle.containsKey(binaryBuildTargetWithoutFlavors)) {\r\n                throw new HumanReadableException(String.format(\"Library %s is declared as the 'binary' of multiple bundles:\\n first bundle: %s\\n second bundle: %s\", binaryBuildTargetWithoutFlavors, sharedLibraryToBundle.get(binaryBuildTargetWithoutFlavors).getBuildTarget(), targetNode.getBuildTarget()));\r\n            } else {\r\n                sharedLibraryToBundle.put(binaryBuildTargetWithoutFlavors, targetNode);\r\n            }\r\n        }\r\n    }\r\n    return ImmutableMap.copyOf(sharedLibraryToBundle);\r\n}"
}, {
	"Path": "com.facebook.buck.rules.args.WriteToFileArg.getContent",
	"Comment": "get the expanded content to write to the file. for some macros, the expanded value needs to bedifferent when written to a file.",
	"Method": "String getContent(SourcePathResolver pathResolver){\r\n    StringBuilder builder = new StringBuilder();\r\n    delegate.appendToCommandLine(builder::append, pathResolver);\r\n    return builder.toString();\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.ClassUsageTracker.getClassUsageMap",
	"Comment": "returns a multimap from jar path on disk to .class file paths within the jar for any classesthat were used.",
	"Method": "ImmutableSetMultimap<Path, Path> getClassUsageMap(){\r\n    return resultBuilder.build();\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.JavaTest.getCompiledTestsLibrary",
	"Comment": "returns the underlying java library containing the compiled tests.",
	"Method": "JavaLibrary getCompiledTestsLibrary(){\r\n    return compiledTestsLibrary;\r\n}"
}, {
	"Path": "com.facebook.buck.util.unarchive.UntarTest.assertOutputFileExists",
	"Comment": "assert that a file exists inside of the temp directory with given contents",
	"Method": "void assertOutputFileExists(Path path,String expectedContents){\r\n    Path fullPath = tmpFolder.getRoot().resolve(path);\r\n    Assert.assertTrue(String.format(\"Expected %s to be a file\", fullPath), Files.isRegularFile(fullPath));\r\n    String contents = Joiner.on('\\n').join(Files.readAllLines(fullPath));\r\n    Assert.assertEquals(expectedContents, contents);\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.abi.SourceVersionUtils.sourceVersionToClassFileVersion",
	"Comment": "gets the class file version corresponding to the given source version constant.",
	"Method": "int sourceVersionToClassFileVersion(SourceVersion version){\r\n    switch(version) {\r\n        case RELEASE_0:\r\n            return Opcodes.V1_1;\r\n        case RELEASE_1:\r\n            return Opcodes.V1_1;\r\n        case RELEASE_2:\r\n            return Opcodes.V1_2;\r\n        case RELEASE_3:\r\n            return Opcodes.V1_3;\r\n        case RELEASE_4:\r\n            return Opcodes.V1_4;\r\n        case RELEASE_5:\r\n            return Opcodes.V1_5;\r\n        case RELEASE_6:\r\n            return Opcodes.V1_6;\r\n        case RELEASE_7:\r\n            return Opcodes.V1_7;\r\n        case RELEASE_8:\r\n            return Opcodes.V1_8;\r\n        default:\r\n            throw new IllegalArgumentException(String.format(\"Unexpected source version: %s\", version));\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.io.file.FileFinder.combine",
	"Comment": "combines prefixes, base, and suffixes to create a set of file names.",
	"Method": "ImmutableSet<String> combine(Set<String> prefixes,String base,Set<String> suffixes){\r\n    ImmutableSet<String> suffixedSet;\r\n    if (suffixes.isEmpty()) {\r\n        suffixedSet = ImmutableSet.of(base);\r\n    } else {\r\n        ImmutableSet.Builder<String> suffixedBuilder = ImmutableSet.builder();\r\n        for (String suffix : suffixes) {\r\n            suffixedBuilder.add(base + suffix);\r\n        }\r\n        suffixedSet = suffixedBuilder.build();\r\n    }\r\n    if (prefixes.isEmpty()) {\r\n        return suffixedSet;\r\n    } else {\r\n        ImmutableSet.Builder<String> builder = ImmutableSet.builder();\r\n        for (String prefix : prefixes) {\r\n            for (String suffix : suffixedSet) {\r\n                builder.add(prefix + suffix);\r\n            }\r\n        }\r\n        return builder.build();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.kotlin.ExternalKotlinc.getKotlinCompilerVersion",
	"Comment": "returns the kotlin version, or the path if version is unknown",
	"Method": "String getKotlinCompilerVersion(){\r\n    if (DEFAULT_VERSION.equals(getVersion())) {\r\n        return getShortName();\r\n    } else {\r\n        return getVersion().toString();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.io.filesystem.impl.DefaultProjectFilesystem.relativize",
	"Comment": "construct a relative path between the project root and a given path.",
	"Method": "Path relativize(Path path){\r\n    return projectRoot.relativize(path);\r\n}"
}, {
	"Path": "com.facebook.buck.core.rules.impl.DependencyAggregationTestUtil.getDisaggregatedDeps",
	"Comment": "return dependencies of a rule, traversing through any dependency aggregations.",
	"Method": "Stream<BuildRule> getDisaggregatedDeps(BuildRule rule){\r\n    return rule.getBuildDeps().stream().flatMap((x) -> x instanceof DependencyAggregation ? x.getBuildDeps().stream() : Stream.of(x));\r\n}"
}, {
	"Path": "com.facebook.buck.shell.ShTest.getRuntimeDeps",
	"Comment": "dependencies, as these are always components that the shell test needs available to run.",
	"Method": "Stream<BuildTarget> getRuntimeDeps(SourcePathRuleFinder ruleFinder){\r\n    return getBuildDeps().stream().map(BuildRule::getBuildTarget);\r\n}"
}, {
	"Path": "com.facebook.buck.event.api.BuckTracing.setCurrentThreadTracingInterfaceFromJsr199Javac",
	"Comment": "used by buck to connect this class to its tracing mechanism. there is no need to call thismethod manually.",
	"Method": "void setCurrentThreadTracingInterfaceFromJsr199Javac(BuckTracingInterface buckTracingInterface){\r\n    curThreadTracingInterface.set(buckTracingInterface);\r\n}"
}, {
	"Path": "com.facebook.buck.io.file.LazyPath.get",
	"Comment": "on first access it will invoke the given supplier to obtain the value of the path.",
	"Method": "Path get(){\r\n    if (path == null) {\r\n        try {\r\n            path = create();\r\n        } catch (IOException e) {\r\n            exception = e;\r\n            LOG.warn(\"Failed to initialize lazy path, exception: \" + e + \"\\n\" + \"StackTrace: \" + Throwables.getStackTraceAsString(e));\r\n            throw e;\r\n        }\r\n    }\r\n    return path;\r\n}"
}, {
	"Path": "com.facebook.buck.apple.toolchain.impl.AppleCxxPlatformsTest.constructLinkRuleKeys",
	"Comment": "create and return some rule keys from a dummy source for the given platforms.",
	"Method": "ImmutableMap<Flavor, RuleKey> constructLinkRuleKeys(ImmutableMap<Flavor, AppleCxxPlatform> cxxPlatforms){\r\n    ActionGraphBuilder graphBuilder = new TestActionGraphBuilder();\r\n    SourcePathRuleFinder ruleFinder = new SourcePathRuleFinder(graphBuilder);\r\n    SourcePathResolver pathResolver = DefaultSourcePathResolver.from(ruleFinder);\r\n    DefaultRuleKeyFactory ruleKeyFactory = new TestDefaultRuleKeyFactory(FakeFileHashCache.createFromStrings(ImmutableMap.<String, String>builder().put(\"input.o\", Strings.repeat(\"a\", 40)).build()), pathResolver, ruleFinder);\r\n    BuildTarget target = BuildTargetFactory.newInstance(\"//:target\");\r\n    ImmutableMap.Builder<Flavor, RuleKey> ruleKeys = ImmutableMap.builder();\r\n    for (Map.Entry<Flavor, AppleCxxPlatform> entry : cxxPlatforms.entrySet()) {\r\n        BuildRule rule = CxxLinkableEnhancer.createCxxLinkableBuildRule(CxxPlatformUtils.DEFAULT_CONFIG, entry.getValue().getCxxPlatform(), new FakeProjectFilesystem(), graphBuilder, pathResolver, ruleFinder, target, Linker.LinkType.EXECUTABLE, Optional.empty(), projectFilesystem.getPath(\"output\"), ImmutableList.of(), Linker.LinkableDepType.SHARED, CxxLinkOptions.of(), ImmutableList.of(), Optional.empty(), Optional.empty(), ImmutableSet.of(), ImmutableSet.of(), NativeLinkableInput.builder().setArgs(SourcePathArg.from(FakeSourcePath.of(\"input.o\"))).build(), Optional.empty(), TestCellPathResolver.get(projectFilesystem));\r\n        ruleKeys.put(entry.getKey(), ruleKeyFactory.build(rule));\r\n    }\r\n    return ruleKeys.build();\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getRegisterCountUnit",
	"Comment": "gets the register count, as a code unit. this will throw if thevalue is out of the range of an unsigned code unit.",
	"Method": "short getRegisterCountUnit(){\r\n    int registerCount = getRegisterCount();\r\n    if ((registerCount & ~0xffff) != 0) {\r\n        throw new DexException(\"Register count out of range: \" + Hex.u8(registerCount));\r\n    }\r\n    return (short) registerCount;\r\n}"
}, {
	"Path": "com.android.dx.dex.code.OutputFinisher.hasAnyPositionInfo",
	"Comment": "returns whether any of the instructions added to this instancecome with position info.",
	"Method": "boolean hasAnyPositionInfo(){\r\n    return hasAnyPositionInfo;\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getCNibble",
	"Comment": "gets the c register number, as a nibble. this will throw if thevalue is out of the range of an unsigned nibble.",
	"Method": "short getCNibble(){\r\n    int c = getC();\r\n    if ((c & ~0xf) != 0) {\r\n        throw new DexException(\"Register C out of range: \" + Hex.u8(c));\r\n    }\r\n    return (short) c;\r\n}"
}, {
	"Path": "com.facebook.buck.features.project.intellij.aggregation.AggregationTreeNode.removeChild",
	"Comment": "removes a child and promotes its children to the current node.",
	"Method": "void removeChild(Path childPath){\r\n    AggregationTreeNode childNode = getChild(childPath);\r\n    Map<Path, AggregationTreeNode> nodesToKeep = new HashMap();\r\n    for (Map.Entry<Path, AggregationTreeNode> grandChild : childNode.children.entrySet()) {\r\n        nodesToKeep.put(childPath.resolve(grandChild.getKey()), grandChild.getValue());\r\n    }\r\n    children.remove(childPath);\r\n    nodesToKeep.entrySet().forEach(n -> children.put(n.getKey(), n.getValue()));\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.MinionModeRunnerIntegrationTest.createFakeHeartbeatService",
	"Comment": "returns a mock heartbeatservice that will always return valid closeables.",
	"Method": "HeartbeatService createFakeHeartbeatService(){\r\n    HeartbeatService service = EasyMock.createNiceMock(HeartbeatService.class);\r\n    EasyMock.expect(service.addCallback(EasyMock.anyString(), EasyMock.anyObject())).andReturn(new Closeable() {\r\n        @Override\r\n        public void close() {\r\n        }\r\n    }).anyTimes();\r\n    EasyMock.replay(service);\r\n    return service;\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.MinionModeRunnerIntegrationTest.createFakeHeartbeatService",
	"Comment": "returns a mock heartbeatservice that will always return valid closeables.",
	"Method": "HeartbeatService createFakeHeartbeatService(){\r\n}"
}, {
	"Path": "com.android.common.utils.SdkUtils.wrap",
	"Comment": "wraps the given text at the given line width, with an optional hangingindent.",
	"Method": "String wrap(String text,int lineWidth,String hangingIndent){\r\n    if (hangingIndent == null) {\r\n        hangingIndent = \"\";\r\n    }\r\n    int explanationLength = text.length();\r\n    StringBuilder sb = new StringBuilder(explanationLength * 2);\r\n    int index = 0;\r\n    while (index < explanationLength) {\r\n        int lineEnd = text.indexOf('\\n', index);\r\n        int next;\r\n        if (lineEnd != -1 && (lineEnd - index) < lineWidth) {\r\n            next = lineEnd + 1;\r\n        } else {\r\n            lineEnd = Math.min(index + lineWidth, explanationLength);\r\n            if (lineEnd - index < lineWidth) {\r\n                next = explanationLength;\r\n            } else {\r\n                int lastSpace = text.lastIndexOf(' ', lineEnd);\r\n                if (lastSpace > index) {\r\n                    lineEnd = lastSpace;\r\n                    next = lastSpace + 1;\r\n                } else {\r\n                    next = lineEnd + 1;\r\n                }\r\n            }\r\n        }\r\n        if (sb.length() > 0) {\r\n            sb.append(hangingIndent);\r\n        } else {\r\n            lineWidth -= hangingIndent.length();\r\n        }\r\n        sb.append(text.substring(index, lineEnd));\r\n        sb.append('\\n');\r\n        index = next;\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.facebook.buck.event.api.BuckTracing.clearCurrentThreadTracingInterfaceFromJsr199Javac",
	"Comment": "used by buck to disconnect this class from its tracing mechanism. there is no need to call thismethod manually.",
	"Method": "void clearCurrentThreadTracingInterfaceFromJsr199Javac(){\r\n    curThreadTracingInterface.set(null);\r\n}"
}, {
	"Path": "com.facebook.buck.util.network.BlockingHttpEndpoint.close",
	"Comment": "attempt to complete submitted requests on close so that as much information is recorded aspossible. this aids debugging when close is called during exception processing.",
	"Method": "void close(){\r\n    requestService.shutdown();\r\n    try {\r\n        if (!requestService.awaitTermination(timeoutMillis, TimeUnit.MILLISECONDS)) {\r\n            LOG.warn(Joiner.on(System.lineSeparator()).join(\"A BlockingHttpEndpoint failed to shut down within the standard timeout.\", \"Your build might have succeeded, but some requests made to \", this.url + \" were probably lost.\", \"Here's some debugging information:\", requestService.toString()));\r\n        }\r\n    } catch (InterruptedException e) {\r\n        Threads.interruptCurrentThread();\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getCUnit",
	"Comment": "gets the c register number, as a code unit. this will throw if thevalue is out of the range of an unsigned code unit.",
	"Method": "short getCUnit(){\r\n    int c = getC();\r\n    if ((c & ~0xffff) != 0) {\r\n        throw new DexException(\"Register C out of range: \" + Hex.u8(c));\r\n    }\r\n    return (short) c;\r\n}"
}, {
	"Path": "com.facebook.buck.core.rules.common.BuildRuleDependencyVisitors.getBuildRuleDirectedGraphFilteredBy",
	"Comment": "given dependencies in inputs builds graph of transitive dependencies filtering them byinstanceof t.",
	"Method": "DirectedAcyclicGraph<BuildRule> getBuildRuleDirectedGraphFilteredBy(Iterable<? extends BuildRule> inputs,Predicate<Object> filter,Predicate<Object> traverse){\r\n    MutableDirectedGraph<BuildRule> graph = new MutableDirectedGraph();\r\n    AbstractBreadthFirstTraversal<BuildRule> visitor = new AbstractBreadthFirstTraversal<BuildRule>(inputs) {\r\n        @Override\r\n        public Iterable<BuildRule> visit(BuildRule rule) {\r\n            if (filter.test(rule)) {\r\n                graph.addNode(rule);\r\n                for (BuildRule dep : rule.getBuildDeps()) {\r\n                    if (traverse.test(dep) && filter.test(dep)) {\r\n                        graph.addEdge(rule, dep);\r\n                    }\r\n                }\r\n            }\r\n            return traverse.test(rule) ? rule.getBuildDeps() : ImmutableSet.of();\r\n        }\r\n    };\r\n    visitor.start();\r\n    return new DirectedAcyclicGraph(graph);\r\n}"
}, {
	"Path": "com.facebook.buck.core.rules.common.BuildRuleDependencyVisitors.getBuildRuleDirectedGraphFilteredBy",
	"Comment": "given dependencies in inputs builds graph of transitive dependencies filtering them byinstanceof t.",
	"Method": "DirectedAcyclicGraph<BuildRule> getBuildRuleDirectedGraphFilteredBy(Iterable<? extends BuildRule> inputs,Predicate<Object> filter,Predicate<Object> traverse){\r\n    if (filter.test(rule)) {\r\n        graph.addNode(rule);\r\n        for (BuildRule dep : rule.getBuildDeps()) {\r\n            if (traverse.test(dep) && filter.test(dep)) {\r\n                graph.addEdge(rule, dep);\r\n            }\r\n        }\r\n    }\r\n    return traverse.test(rule) ? rule.getBuildDeps() : ImmutableSet.of();\r\n}"
}, {
	"Path": "com.android.dx.command.annotool.AnnotationLister.process",
	"Comment": "processes based on configuration specified in constructor.",
	"Method": "void process(){\r\n    for (String path : args.files) {\r\n        ClassPathOpener opener;\r\n        opener = new ClassPathOpener(path, true, new ClassPathOpener.Consumer() {\r\n            public boolean processFileBytes(String name, long lastModified, byte[] bytes) {\r\n                if (!name.endsWith(\".class\")) {\r\n                    return true;\r\n                }\r\n                ByteArray ba = new ByteArray(bytes);\r\n                DirectClassFile cf = new DirectClassFile(ba, name, true);\r\n                cf.setAttributeFactory(StdAttributeFactory.THE_ONE);\r\n                AttributeList attributes = cf.getAttributes();\r\n                Attribute att;\r\n                String cfClassName = cf.getThisClass().getClassType().getClassName();\r\n                if (cfClassName.endsWith(PACKAGE_INFO)) {\r\n                    att = attributes.findFirst(AttRuntimeInvisibleAnnotations.ATTRIBUTE_NAME);\r\n                    for (; att != null; att = attributes.findNext(att)) {\r\n                        BaseAnnotations ann = (BaseAnnotations) att;\r\n                        visitPackageAnnotation(cf, ann);\r\n                    }\r\n                    att = attributes.findFirst(AttRuntimeVisibleAnnotations.ATTRIBUTE_NAME);\r\n                    for (; att != null; att = attributes.findNext(att)) {\r\n                        BaseAnnotations ann = (BaseAnnotations) att;\r\n                        visitPackageAnnotation(cf, ann);\r\n                    }\r\n                } else if (isMatchingInnerClass(cfClassName) || isMatchingPackage(cfClassName)) {\r\n                    printMatch(cf);\r\n                } else {\r\n                    att = attributes.findFirst(AttRuntimeInvisibleAnnotations.ATTRIBUTE_NAME);\r\n                    for (; att != null; att = attributes.findNext(att)) {\r\n                        BaseAnnotations ann = (BaseAnnotations) att;\r\n                        visitClassAnnotation(cf, ann);\r\n                    }\r\n                    att = attributes.findFirst(AttRuntimeVisibleAnnotations.ATTRIBUTE_NAME);\r\n                    for (; att != null; att = attributes.findNext(att)) {\r\n                        BaseAnnotations ann = (BaseAnnotations) att;\r\n                        visitClassAnnotation(cf, ann);\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n            public void onException(Exception ex) {\r\n                throw new RuntimeException(ex);\r\n            }\r\n            public void onProcessArchiveStart(File file) {\r\n            }\r\n        });\r\n        opener.process();\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.command.annotool.AnnotationLister.process",
	"Comment": "processes based on configuration specified in constructor.",
	"Method": "void process(){\r\n    if (!name.endsWith(\".class\")) {\r\n        return true;\r\n    }\r\n    ByteArray ba = new ByteArray(bytes);\r\n    DirectClassFile cf = new DirectClassFile(ba, name, true);\r\n    cf.setAttributeFactory(StdAttributeFactory.THE_ONE);\r\n    AttributeList attributes = cf.getAttributes();\r\n    Attribute att;\r\n    String cfClassName = cf.getThisClass().getClassType().getClassName();\r\n    if (cfClassName.endsWith(PACKAGE_INFO)) {\r\n        att = attributes.findFirst(AttRuntimeInvisibleAnnotations.ATTRIBUTE_NAME);\r\n        for (; att != null; att = attributes.findNext(att)) {\r\n            BaseAnnotations ann = (BaseAnnotations) att;\r\n            visitPackageAnnotation(cf, ann);\r\n        }\r\n        att = attributes.findFirst(AttRuntimeVisibleAnnotations.ATTRIBUTE_NAME);\r\n        for (; att != null; att = attributes.findNext(att)) {\r\n            BaseAnnotations ann = (BaseAnnotations) att;\r\n            visitPackageAnnotation(cf, ann);\r\n        }\r\n    } else if (isMatchingInnerClass(cfClassName) || isMatchingPackage(cfClassName)) {\r\n        printMatch(cf);\r\n    } else {\r\n        att = attributes.findFirst(AttRuntimeInvisibleAnnotations.ATTRIBUTE_NAME);\r\n        for (; att != null; att = attributes.findNext(att)) {\r\n            BaseAnnotations ann = (BaseAnnotations) att;\r\n            visitClassAnnotation(cf, ann);\r\n        }\r\n        att = attributes.findFirst(AttRuntimeVisibleAnnotations.ATTRIBUTE_NAME);\r\n        for (; att != null; att = attributes.findNext(att)) {\r\n            BaseAnnotations ann = (BaseAnnotations) att;\r\n            visitClassAnnotation(cf, ann);\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.android.dx.command.annotool.AnnotationLister.process",
	"Comment": "processes based on configuration specified in constructor.",
	"Method": "void process(){\r\n    throw new RuntimeException(ex);\r\n}"
}, {
	"Path": "com.android.dx.command.annotool.AnnotationLister.process",
	"Comment": "processes based on configuration specified in constructor.",
	"Method": "void process(){\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.toolchain.CxxPlatforms.copyPlatformWithFlavorAndConfig",
	"Comment": "creates a cxxplatform with a defined flavor for a cxxbuckconfig with default values providedfrom another default cxxplatform",
	"Method": "CxxPlatform copyPlatformWithFlavorAndConfig(CxxPlatform defaultPlatform,Platform platform,CxxBuckConfig config,Flavor flavor){\r\n    return CxxPlatforms.build(flavor, platform, config, defaultPlatform.getAs(), defaultPlatform.getAspp(), defaultPlatform.getCc(), defaultPlatform.getCxx(), defaultPlatform.getCpp(), defaultPlatform.getCxxpp(), defaultPlatform.getLd(), defaultPlatform.getLdflags(), defaultPlatform.getStrip(), defaultPlatform.getAr(), defaultPlatform.getRanlib(), defaultPlatform.getSymbolNameTool(), defaultPlatform.getAsflags(), defaultPlatform.getAsppflags(), defaultPlatform.getCflags(), defaultPlatform.getCppflags(), defaultPlatform.getSharedLibraryExtension(), defaultPlatform.getSharedLibraryVersionedExtensionFormat(), defaultPlatform.getStaticLibraryExtension(), defaultPlatform.getObjectFileExtension(), defaultPlatform.getCompilerDebugPathSanitizer(), defaultPlatform.getAssemblerDebugPathSanitizer(), defaultPlatform.getFlagMacros(), defaultPlatform.getBinaryExtension(), defaultPlatform.getHeaderVerification(), defaultPlatform.getPicTypeForSharedLinking());\r\n}"
}, {
	"Path": "com.android.dx.dex.file.IdItem.getDefiningClass",
	"Comment": "gets the type constant for the defining class of thereference.",
	"Method": "CstType getDefiningClass(){\r\n    return type;\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.DistBuildService.fetchRuleKeyLogs",
	"Comment": "fetch rule key logs as name says. rkl are filtered by repository, schedule type and distributedflag.",
	"Method": "List<RuleKeyLogEntry> fetchRuleKeyLogs(Collection<String> ruleKeys,String repository,String scheduleType,boolean distributedBuildModeEnabled){\r\n    FetchRuleKeyLogsRequest request = new FetchRuleKeyLogsRequest();\r\n    request.setRuleKeys(Lists.newArrayList(ruleKeys));\r\n    request.setRepository(repository);\r\n    request.setScheduleType(scheduleType);\r\n    request.setDistributedBuildModeEnabled(distributedBuildModeEnabled);\r\n    FrontendRequest frontendRequest = new FrontendRequest();\r\n    frontendRequest.setType(FrontendRequestType.FETCH_RULE_KEY_LOGS);\r\n    frontendRequest.setFetchRuleKeyLogsRequest(request);\r\n    FrontendResponse response = makeRequestChecked(frontendRequest);\r\n    Preconditions.checkState(response.isSetFetchRuleKeyLogsResponse());\r\n    Preconditions.checkState(response.getFetchRuleKeyLogsResponse().isSetRuleKeyLogs());\r\n    return response.getFetchRuleKeyLogsResponse().getRuleKeyLogs();\r\n}"
}, {
	"Path": "com.android.dx.dex.code.DalvInsn.expandedPrefix",
	"Comment": "gets the instruction prefix required, if any, to use in an expandedversion of this instance. will not generate moves for registersmarked compatible to the format by the given bitset.",
	"Method": "DalvInsn expandedPrefix(BitSet compatRegs){\r\n    RegisterSpecList regs = registers;\r\n    boolean firstBit = compatRegs.get(0);\r\n    if (hasResult())\r\n        compatRegs.set(0);\r\n    regs = regs.subset(compatRegs);\r\n    if (hasResult())\r\n        compatRegs.set(0, firstBit);\r\n    if (regs.size() == 0)\r\n        return null;\r\n    return new HighRegisterPrefix(position, regs);\r\n}"
}, {
	"Path": "com.facebook.buck.rules.macros.MacroExpander.expandForFile",
	"Comment": "expand the input given for the this macro to some string, which is intended to be written to afile.",
	"Method": "Arg expandForFile(BuildTarget target,CellPathResolver cellNames,ActionGraphBuilder graphBuilder,ImmutableList<String> input,Object precomputedWork){\r\n    Hasher hasher = Hashing.sha1().newHasher();\r\n    hasher.putString(getClass().getName(), UTF_8);\r\n    input.forEach(s -> hasher.putString(s, UTF_8));\r\n    return makeExpandToFileArg(target, hasher.hash().toString(), expand(target, cellNames, graphBuilder, input, precomputedWork));\r\n}"
}, {
	"Path": "com.android.dx.cf.code.Frame.makeExceptionHandlerStartFrame",
	"Comment": "makes a new frame for an exception handler block invoked from thisframe.",
	"Method": "Frame makeExceptionHandlerStartFrame(CstType exceptionClass){\r\n    ExecutionStack newStack = getStack().copy();\r\n    newStack.clear();\r\n    newStack.push(exceptionClass);\r\n    return new Frame(getLocals(), newStack, subroutines);\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.MoreAsserts.assertLargeStringsEqual",
	"Comment": "asserts that two strings are equal, but compares them in chunks so that intellij will show thediffs when the assertion fails.",
	"Method": "void assertLargeStringsEqual(String expected,String content){\r\n    List<String> expectedChunks = chunkify(expected);\r\n    List<String> contentChunks = chunkify(content);\r\n    for (int i = 0; i < Math.min(expectedChunks.size(), contentChunks.size()); i++) {\r\n        assertEquals(\"Failed at index: \" + i, expectedChunks.get(i), contentChunks.get(i));\r\n    }\r\n    assertEquals(expectedChunks.size(), contentChunks.size());\r\n}"
}, {
	"Path": "com.facebook.buck.httpserver.Responses.writeSuccessfulResponse",
	"Comment": "writes the specified content to the response with a status code of 200.",
	"Method": "void writeSuccessfulResponse(String content,MediaType mediaType,Request baseRequest,HttpServletResponse response){\r\n    writeResponse(content, mediaType, baseRequest, response, HttpServletResponse.SC_OK);\r\n}"
}, {
	"Path": "com.facebook.buck.support.cli.args.BuckArgsMethods.expandFlagFile",
	"Comment": "recursively expands flag files into a list of command line flags.",
	"Method": "ImmutableList<String> expandFlagFile(String nextFlagFile,ImmutableMap<CellName, Path> cellMapping,Set<String> expansionPath){\r\n    if (expansionPath.contains(nextFlagFile)) {\r\n        throw new HumanReadableException(\"Expansion loop detected: \" + String.join(\" -> \", expansionPath) + \".\" + System.lineSeparator() + \"Please make sure your flag files form a directed acyclic graph.\");\r\n    }\r\n    expansionPath.add(nextFlagFile);\r\n    ImmutableList<String> expandedArgs = expandFlagFilesRecursively(expandFile(nextFlagFile, cellMapping), cellMapping, expansionPath);\r\n    expansionPath.remove(nextFlagFile);\r\n    return expandedArgs;\r\n}"
}, {
	"Path": "com.android.dx.cf.direct.StdAttributeFactory.throwTruncated",
	"Comment": "throws the right exception when a known attribute has a too shortlength.",
	"Method": "Attribute throwTruncated(){\r\n    throw new ParseException(\"truncated attribute\");\r\n}"
}, {
	"Path": "com.facebook.buck.util.config.Configs.getDefaultConfigurationFiles",
	"Comment": "gets all configuration files that should be used for parsing the project configuration",
	"Method": "ImmutableList<Path> getDefaultConfigurationFiles(Path root){\r\n    ImmutableList.Builder<Path> configFileBuilder = ImmutableList.builder();\r\n    configFileBuilder.addAll(listFiles(GLOBAL_BUCK_CONFIG_DIRECTORY_PATH));\r\n    if (Files.isRegularFile(GLOBAL_BUCK_CONFIG_FILE_PATH)) {\r\n        configFileBuilder.add(GLOBAL_BUCK_CONFIG_FILE_PATH);\r\n    }\r\n    Path homeDirectory = Paths.get(System.getProperty(\"user.home\"));\r\n    Path userConfigDir = homeDirectory.resolve(DEFAULT_BUCK_CONFIG_DIRECTORY_NAME);\r\n    configFileBuilder.addAll(listFiles(userConfigDir));\r\n    Path projectConfigDir = root.resolve(DEFAULT_BUCK_CONFIG_DIRECTORY_NAME);\r\n    configFileBuilder.addAll(listFiles(projectConfigDir));\r\n    Path userConfigFile = homeDirectory.resolve(DEFAULT_BUCK_CONFIG_FILE_NAME);\r\n    if (Files.isRegularFile(userConfigFile)) {\r\n        configFileBuilder.add(userConfigFile);\r\n    }\r\n    Path configFile = getMainConfigurationFile(root);\r\n    if (Files.isRegularFile(configFile)) {\r\n        configFileBuilder.add(configFile);\r\n    }\r\n    Path overrideConfigFile = root.resolve(DEFAULT_BUCK_CONFIG_OVERRIDE_FILE_NAME);\r\n    if (Files.isRegularFile(overrideConfigFile)) {\r\n        configFileBuilder.add(overrideConfigFile);\r\n    }\r\n    return configFileBuilder.build();\r\n}"
}, {
	"Path": "com.android.dx.dex.file.TypeIdsSection.writeHeaderPart",
	"Comment": "writes the portion of the file header that refers to this instance.",
	"Method": "void writeHeaderPart(AnnotatedOutput out){\r\n    throwIfNotPrepared();\r\n    int sz = typeIds.size();\r\n    int offset = (sz == 0) ? 0 : getFileOffset();\r\n    if (sz > DexFormat.MAX_TYPE_IDX + 1) {\r\n        throw new DexIndexOverflowException(\"Too many type references: \" + sz + \"; max is \" + (DexFormat.MAX_TYPE_IDX + 1) + \".\\n\" + Main.getTooManyIdsErrorMessage());\r\n    }\r\n    if (out.annotates()) {\r\n        out.annotate(4, \"type_ids_size:   \" + Hex.u4(sz));\r\n        out.annotate(4, \"type_ids_off:    \" + Hex.u4(offset));\r\n    }\r\n    out.writeInt(sz);\r\n    out.writeInt(offset);\r\n}"
}, {
	"Path": "com.android.dx.dex.code.DalvCode.hasLocals",
	"Comment": "gets whether this instance has any local variable data to represent.",
	"Method": "boolean hasLocals(){\r\n    return unprocessedInsns.hasAnyLocalInfo();\r\n}"
}, {
	"Path": "com.android.dx.dex.file.StringIdsSection.indexOf",
	"Comment": "gets the index of the given string, which must have been addedto this instance.",
	"Method": "int indexOf(CstString string){\r\n    if (string == null) {\r\n        throw new NullPointerException(\"string == null\");\r\n    }\r\n    throwIfNotPrepared();\r\n    StringIdItem s = strings.get(string);\r\n    if (s == null) {\r\n        throw new IllegalArgumentException(\"not found\");\r\n    }\r\n    return s.getIndex();\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getBByte",
	"Comment": "gets the b register number, as a byte. this will throw if thevalue is out of the range of an unsigned byte.",
	"Method": "short getBByte(){\r\n    int b = getB();\r\n    if ((b & ~0xff) != 0) {\r\n        throw new DexException(\"Register B out of range: \" + Hex.u8(b));\r\n    }\r\n    return (short) b;\r\n}"
}, {
	"Path": "com.facebook.buck.rules.macros.AbstractLocationMacro.splitSupplementaryOutputPart",
	"Comment": "split a build target string with optional supplementary output pattern.",
	"Method": "SplitResult splitSupplementaryOutputPart(String targetish){\r\n    Matcher matcher = BUILD_TARGET_WITH_SUPPLEMENTARY_OUTPUT_PATTERN.matcher(targetish);\r\n    if (!matcher.matches()) {\r\n        throw new HumanReadableException(String.format(\"Cannot parse build target: %s\", targetish));\r\n    }\r\n    return new SplitResult(matcher.group(\"target\"), Optional.ofNullable(matcher.group(\"output\")));\r\n}"
}, {
	"Path": "com.android.dx.dex.code.InsnFormat.unsignedFitsInByte",
	"Comment": "helper method to determine if an unsigned int value fits in a byte.",
	"Method": "boolean unsignedFitsInByte(int value){\r\n    return value == (value & 0xff);\r\n}"
}, {
	"Path": "com.facebook.buck.util.PackagedResource.getResourceIdentifier",
	"Comment": "use this as unique id for resource when hashing is not enabled",
	"Method": "String getResourceIdentifier(){\r\n    return relativeTo.getName() + \"#\" + name;\r\n}"
}, {
	"Path": "com.android.dx.command.dexer.Main.mergeLibraryDexBuffers",
	"Comment": "merges the dex files in library jars. if multiple dex files define thesame type, this fails with an exception.",
	"Method": "byte[] mergeLibraryDexBuffers(byte[] outArray){\r\n    ArrayList<Dex> dexes = new ArrayList<Dex>();\r\n    if (outArray != null) {\r\n        dexes.add(new Dex(outArray));\r\n    }\r\n    for (byte[] libraryDex : libraryDexBuffers) {\r\n        dexes.add(new Dex(libraryDex));\r\n    }\r\n    if (dexes.isEmpty()) {\r\n        return null;\r\n    }\r\n    DexMerger dexMerger = new DexMerger(dexes.toArray(new Dex[0]), CollisionPolicy.FAIL, context);\r\n    Dex merged = dexMerger.merge();\r\n    return merged.getBytes();\r\n}"
}, {
	"Path": "com.android.dx.command.annotool.AnnotationLister.printMatchPackage",
	"Comment": "prints, or schedules for printing, elements related to amatching package.",
	"Method": "void printMatchPackage(String packageName){\r\n    for (Main.PrintType pt : args.printTypes) {\r\n        switch(pt) {\r\n            case CLASS:\r\n            case INNERCLASS:\r\n            case METHOD:\r\n                matchPackages.add(packageName);\r\n                break;\r\n            case PACKAGE:\r\n                System.out.println(packageName.replace('/', '.'));\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.toolchain.nativelink.NativeLinkable.getNativeLinkableInput",
	"Comment": "return input that dependents should put on their link line when linking against thislinkable.",
	"Method": "NativeLinkableInput getNativeLinkableInput(CxxPlatform cxxPlatform,Linker.LinkableDepType type,boolean forceLinkWhole,ActionGraphBuilder graphBuilder,NativeLinkableInput getNativeLinkableInput,CxxPlatform cxxPlatform,Linker.LinkableDepType type,ActionGraphBuilder graphBuilder){\r\n    return getNativeLinkableInput(cxxPlatform, type, false, graphBuilder);\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.MoreAsserts.assertSetEquals",
	"Comment": "asserts that two sets have the same contents. on failure, prints a readable diff of the twosets for easy debugging.",
	"Method": "void assertSetEquals(Set<E> expected,Set<E> actual){\r\n    Set<E> missing = Sets.difference(expected, actual);\r\n    Set<E> extra = Sets.difference(actual, expected);\r\n    boolean setsEqual = missing.isEmpty() && extra.isEmpty();\r\n    Assert.assertTrue(String.format(\"%nMissing elements:%n%s%nExtraneous elements:%n%s\", missing, extra), setsEqual);\r\n}"
}, {
	"Path": "com.facebook.buck.android.AndroidBinaryGraphEnhancerTest.testD8PreDexingWithInterfaceMethods",
	"Comment": "this test verifies that androidbinarygraphenhancer correctly populates d8 desugar dependenciesfor java libraries.",
	"Method": "void testD8PreDexingWithInterfaceMethods(){\r\n    JavaBuckConfig javaBuckConfig = getJavaBuckConfigWithInterfaceMethodsDexing(true);\r\n    BuildTarget javaDep1BuildTarget = BuildTargetFactory.newInstance(\"//java/com/example:dep1\");\r\n    BuildTarget javaDep2BuildTarget = BuildTargetFactory.newInstance(\"//java/com/example:dep2\");\r\n    TargetNode<?> javaDep2Node = JavaLibraryBuilder.createBuilder(javaDep2BuildTarget, javaBuckConfig).addSrc(Paths.get(\"java/com/example/Dep2.java\")).build();\r\n    TargetNode<?> javaDep1Node = JavaLibraryBuilder.createBuilder(javaDep1BuildTarget, javaBuckConfig).addSrc(Paths.get(\"java/com/example/Dep1.java\")).addDep(javaDep2Node.getBuildTarget()).build();\r\n    BuildTarget javaLibBuildTarget = BuildTargetFactory.newInstance(\"//java/com/example:lib\");\r\n    TargetNode<?> javaLibNode = JavaLibraryBuilder.createBuilder(javaLibBuildTarget, javaBuckConfig).addSrc(Paths.get(\"java/com/example/Lib.java\")).addDep(javaDep1Node.getBuildTarget()).build();\r\n    TargetGraph targetGraph = TargetGraphFactory.newInstance(javaDep1Node, javaDep2Node, javaLibNode);\r\n    ActionGraphBuilder graphBuilder = new TestActionGraphBuilder(targetGraph, createToolchainProviderForAndroidWithJava8());\r\n    SourcePathRuleFinder ruleFinder = new SourcePathRuleFinder(graphBuilder);\r\n    BuildRule javaDep1 = graphBuilder.requireRule(javaDep1BuildTarget);\r\n    BuildRule javaDep2 = graphBuilder.requireRule(javaDep2BuildTarget);\r\n    BuildRule javaLib = graphBuilder.requireRule(javaLibBuildTarget);\r\n    ImmutableSortedSet<BuildRule> originalDeps = ImmutableSortedSet.of(javaLib);\r\n    BuildTarget apkTarget = BuildTargetFactory.newInstance(\"//java/com/example:apk\");\r\n    FakeProjectFilesystem filesystem = new FakeProjectFilesystem();\r\n    BuildRuleParams originalParams = new BuildRuleParams(Suppliers.ofInstance(originalDeps), ImmutableSortedSet::of, ImmutableSortedSet.of());\r\n    AndroidBinaryGraphEnhancer graphEnhancer = new AndroidBinaryGraphEnhancer(createToolchainProviderForAndroidWithJava8(), TestCellPathResolver.get(filesystem), apkTarget, filesystem, TestAndroidPlatformTargetFactory.create(), originalParams, graphBuilder, AaptMode.AAPT1, ResourcesFilter.ResourceCompressionMode.DISABLED, FilterResourcesSteps.ResourceFilter.EMPTY_FILTER, EnumSet.noneOf(RType.class), Optional.empty(), Optional.empty(), ImmutableSet.of(), null, Optional.of(PathSourcePath.of(filesystem, Paths.get(\"AndroidManifest.xml\"))), Optional.empty(), Optional.empty(), PackageType.DEBUG, ImmutableSet.of(), false, true, DexSplitMode.NO_SPLIT, ImmutableSet.of(), ImmutableSet.of(), false, false, false, false, false, DEFAULT_JAVA_CONFIG, JavacFactoryHelper.createJavacFactory(DEFAULT_JAVA_CONFIG), ANDROID_JAVAC_OPTIONS, EnumSet.noneOf(ExopackageMode.class), BuildConfigFields.of(), Optional.empty(), OptionalInt.empty(), false, Optional.empty(), false, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), RelinkerMode.DISABLED, ImmutableList.of(), MoreExecutors.newDirectExecutorService(), ManifestEntries.empty(), CxxPlatformUtils.DEFAULT_CONFIG, new APKModuleGraph(TargetGraph.EMPTY, apkTarget, Optional.empty()), new DxConfig(FakeBuckConfig.builder().build()), DxStep.D8, Optional.empty(), defaultNonPredexedArgs(), ImmutableSortedSet.of(), false);\r\n    BuildTarget aaptPackageResourcesTarget = BuildTargetFactory.newInstance(\"//java/com/example:apk#aapt_package\");\r\n    AaptPackageResources aaptPackageResources = new AaptPackageResources(aaptPackageResourcesTarget, filesystem, TestAndroidPlatformTargetFactory.create(), ruleFinder, graphBuilder, FakeSourcePath.of(\"java/src/com/facebook/base/AndroidManifest.xml\"), ImmutableList.of(), new IdentityResourcesProvider(ImmutableList.of()), ImmutableList.of(), false, false, ManifestEntries.empty());\r\n    graphBuilder.addToIndex(aaptPackageResources);\r\n    AndroidPackageableCollection collection = new AndroidPackageableCollector(apkTarget, ImmutableSet.of(), ImmutableSet.of(), new APKModuleGraph(TargetGraph.EMPTY, apkTarget, Optional.empty())).addClasspathEntry(((HasJavaClassHashes) javaDep1), FakeSourcePath.of(\"ignored\")).addClasspathEntry(((HasJavaClassHashes) javaDep2), FakeSourcePath.of(\"ignored\")).addClasspathEntry(((HasJavaClassHashes) javaLib), FakeSourcePath.of(\"ignored\")).build();\r\n    graphEnhancer.createPreDexMergeRule(graphEnhancer.createPreDexRulesForLibraries(ImmutableList.of(), collection));\r\n    BuildRule javaDep1Abi = graphBuilder.getRule(BuildTargetFactory.newInstance(\"//java/com/example:dep1#class-abi\"));\r\n    BuildRule javaDep2Abi = graphBuilder.getRule(BuildTargetFactory.newInstance(\"//java/com/example:dep2#class-abi\"));\r\n    DexProducedFromJavaLibrary javaDep2DexRule = (DexProducedFromJavaLibrary) graphBuilder.getRule(BuildTargetFactory.newInstance(\"//java/com/example:dep2#d8\"));\r\n    assertNotNull(javaDep2DexRule);\r\n    assertThat(javaDep2DexRule.getDesugarDeps(), Matchers.empty());\r\n    assertThat(javaDep2DexRule.getBuildDeps(), Matchers.allOf(Matchers.not(Matchers.hasItem(javaDep2Abi)), Matchers.not(Matchers.hasItem(javaDep1Abi))));\r\n    DexProducedFromJavaLibrary javaDep1DexRule = (DexProducedFromJavaLibrary) graphBuilder.getRule(BuildTargetFactory.newInstance(\"//java/com/example:dep1#d8\"));\r\n    assertNotNull(javaDep1DexRule);\r\n    assertThat(javaDep1DexRule.getDesugarDeps(), Matchers.hasSize(1));\r\n    assertThat(javaDep1DexRule.getDesugarDeps(), Matchers.hasItem(javaDep2Abi.getSourcePathToOutput()));\r\n    assertThat(javaDep1DexRule.getBuildDeps(), Matchers.allOf(Matchers.hasItem(javaDep2Abi), Matchers.not(Matchers.hasItem(javaDep1Abi))));\r\n    DexProducedFromJavaLibrary javaLibDexRule = (DexProducedFromJavaLibrary) graphBuilder.getRule(BuildTargetFactory.newInstance(\"//java/com/example:lib#d8\"));\r\n    assertNotNull(javaLibDexRule);\r\n    assertThat(javaLibDexRule.getDesugarDeps(), Matchers.hasSize(2));\r\n    assertThat(javaLibDexRule.getDesugarDeps(), Matchers.hasItems(javaDep1Abi.getSourcePathToOutput(), javaDep2Abi.getSourcePathToOutput()));\r\n    assertThat(javaLibDexRule.getBuildDeps(), Matchers.hasItems(javaDep1Abi, javaDep2Abi));\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.WindowsUtils.getCommandBuilder",
	"Comment": "returns a buck command builder for a unix platform, which runs programs through cmd",
	"Method": "ImmutableList.Builder<String> getCommandBuilder(){\r\n    ImmutableList.Builder<String> commandBuilder = ImmutableList.builder();\r\n    commandBuilder.add(\"cmd\").add(\"/c\");\r\n    return commandBuilder;\r\n}"
}, {
	"Path": "com.android.dx.cf.code.Frame.makeInitialized",
	"Comment": "replaces all the occurrences of the given uninitialized type inthis frame with its initialized equivalent.",
	"Method": "void makeInitialized(Type type){\r\n    locals.makeInitialized(type);\r\n    stack.makeInitialized(type);\r\n}"
}, {
	"Path": "com.android.common.ide.common.xml.XmlFormatPreferences.getTabWidth",
	"Comment": "returns the number of spaces used to display a single tab character",
	"Method": "int getTabWidth(){\r\n    if (mTabWidth == -1) {\r\n        mTabWidth = 4;\r\n    }\r\n    return mTabWidth;\r\n}"
}, {
	"Path": "com.android.manifmerger.XmlDocument.getApiLevelFromAttribute",
	"Comment": "decodes a sdk version from either its decimal representation or from a platform code name.",
	"Method": "int getApiLevelFromAttribute(String attributeVersion){\r\n    Preconditions.checkArgument(!Strings.isNullOrEmpty(attributeVersion));\r\n    if (Character.isDigit(attributeVersion.charAt(0))) {\r\n        return Integer.parseInt(attributeVersion);\r\n    }\r\n    return SdkVersionInfo.getApiByPreviewName(attributeVersion, true);\r\n}"
}, {
	"Path": "com.facebook.buck.features.apple.project.CxxPlatformXcodeConfigGenerator.getConfigValueForKey",
	"Comment": "if appendedconfig has value for given key, it will be used. otherwise, this method will attemptto extract value from cxxflags.",
	"Method": "String getConfigValueForKey(String key,List<String> cxxFlags,String prefix,Optional<String> containmentString,Map<String, String> appendedConfig){\r\n    String value = appendedConfig.get(key);\r\n    if (value == null) {\r\n        int indexOfCxxLibrarySpec = -1;\r\n        for (String item : cxxFlags) {\r\n            if (containmentString.isPresent() && !item.contains(containmentString.get())) {\r\n                continue;\r\n            }\r\n            if (item.startsWith(prefix)) {\r\n                indexOfCxxLibrarySpec = cxxFlags.indexOf(item);\r\n                value = item.substring(item.indexOf('=') + 1);\r\n                break;\r\n            }\r\n        }\r\n        if (indexOfCxxLibrarySpec != -1) {\r\n            cxxFlags.remove(indexOfCxxLibrarySpec);\r\n        } else {\r\n            LOG.debug(\"Cannot determine value of %s\", key);\r\n        }\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "com.facebook.buck.remoteexecution.factory.RemoteExecutionClientsFactory.create",
	"Comment": "creates the remoteexecutionclients based on the held configs.",
	"Method": "RemoteExecutionClients create(BuckEventBus eventBus,Optional<TraceInfoProvider> traceInfoProvider){\r\n    RemoteExecutionType type = remoteExecutionConfig.getType();\r\n    switch(type) {\r\n        case NONE:\r\n            throw new HumanReadableException(\"Remote execution implementation required but not configured. Please set an appropriate %s.type.\", RemoteExecutionConfig.SECTION);\r\n        case GRPC:\r\n            return GrpcExecutionFactory.createRemote(remoteExecutionConfig.getRemoteHost(), remoteExecutionConfig.getRemotePort(), remoteExecutionConfig.getCasHost(), remoteExecutionConfig.getCasPort(), remoteExecutionConfig.getInsecure(), remoteExecutionConfig.getCasInsecure(), remoteExecutionConfig.getRemoteHostSNIName(), remoteExecutionConfig.getCasHostSNIName(), remoteExecutionConfig.getCertFile(), remoteExecutionConfig.getKeyFile(), remoteExecutionConfig.getCAsFile(), traceInfoProvider, eventBus);\r\n        case DEBUG_GRPC_IN_PROCESS:\r\n            return OutOfProcessIsolatedExecutionClients.create(new GrpcProtocol(), eventBus);\r\n        case DEBUG_GRPC_LOCAL:\r\n            return GrpcExecutionFactory.createInProcess(eventBus);\r\n    }\r\n    throw new IllegalStateException(String.format(\"Something went wrong (%s).\", type));\r\n}"
}, {
	"Path": "com.android.common.xml.AndroidManifest.getTestHandleProfiling",
	"Comment": "returns the instrumentation handleprofiling value for the manifest.",
	"Method": "String getTestHandleProfiling(IAbstractFile manifestFile){\r\n    return getStringValue(manifestFile, getTestHandleProfilingXPath());\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getTargetByte",
	"Comment": "gets the target as a relative offset from the given baseaddress, masked to be a byte in size. this will throw if thevalue is out of the range of a signed byte.",
	"Method": "int getTargetByte(int baseAddress){\r\n    int relativeTarget = getTarget(baseAddress);\r\n    if (relativeTarget != (byte) relativeTarget) {\r\n        throw new DexException(\"Target out of range: \" + Hex.s4(relativeTarget));\r\n    }\r\n    return relativeTarget & 0xff;\r\n}"
}, {
	"Path": "com.facebook.buck.core.model.impl.FilesystemBackedBuildFileTree.isBasePath",
	"Comment": "returns whether the given path is a directory containing a buck file, i.e. a base path.",
	"Method": "boolean isBasePath(Path filePath){\r\n    return pathExistenceCache.getUnchecked(filePath.resolve(buildFileName)) && !isBuckOutput(filePath) && !projectFilesystem.isIgnored(filePath);\r\n}"
}, {
	"Path": "com.facebook.buck.core.resources.AbstractResourcesConfig.getConcurrencyLimit",
	"Comment": "construct a default concurrencylimit instance from this config.",
	"Method": "ConcurrencyLimit getConcurrencyLimit(){\r\n    return new ConcurrencyLimit(getDelegate().getNumThreads(), getResourceAllocationFairness(), getManagedThreadCount(), getDefaultResourceAmounts(), getMaximumResourceAmounts());\r\n}"
}, {
	"Path": "com.android.dx.cf.code.ByteBlock.getCatches",
	"Comment": "gets the list of exceptions caught and their handler targets.",
	"Method": "ByteCatchList getCatches(){\r\n    return catches;\r\n}"
}, {
	"Path": "com.android.dx.cf.code.ExecutionStack.makeInitialized",
	"Comment": "replaces all the occurrences of the given uninitialized type inthis stack with its initialized equivalent.",
	"Method": "void makeInitialized(Type type){\r\n    if (stackPtr == 0) {\r\n        return;\r\n    }\r\n    throwIfImmutable();\r\n    Type initializedType = type.getInitializedType();\r\n    for (int i = 0; i < stackPtr; i++) {\r\n        if (stack[i] == type) {\r\n            stack[i] = initializedType;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.manifmerger.XmlElement.getAllNodesByType",
	"Comment": "returns all immediate children of this node for a particular type, irrespective of theirkey.",
	"Method": "ImmutableList<XmlElement> getAllNodesByType(ManifestModel.NodeTypes type){\r\n    ImmutableList.Builder<XmlElement> listBuilder = ImmutableList.builder();\r\n    for (XmlElement mergeableChild : initMergeableChildren()) {\r\n        if (mergeableChild.isA(type)) {\r\n            listBuilder.add(mergeableChild);\r\n        }\r\n    }\r\n    return listBuilder.build();\r\n}"
}, {
	"Path": "com.android.common.utils.XmlUtils.parseDocumentSilently",
	"Comment": "parses the given xml string as a dom document, using the jdk parser. the parser does notvalidate, and is optionally namespace aware. any parsing errors are silently ignored.",
	"Method": "Document parseDocumentSilently(String xml,boolean namespaceAware){\r\n    try {\r\n        return parseDocument(xml, namespaceAware);\r\n    } catch (Exception e) {\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.CxxLibraryFactory.createDependentSharedLibraryInterface",
	"Comment": "create a shared library interface from the shared library built by this description.",
	"Method": "BuildRule createDependentSharedLibraryInterface(BuildTarget baseTarget,ProjectFilesystem projectFilesystem,ActionGraphBuilder graphBuilder,CxxPlatform cxxPlatform,SharedLibraryInterfaceParams params){\r\n    SourcePathRuleFinder ruleFinder = new SourcePathRuleFinder(graphBuilder);\r\n    SourcePathResolver pathResolver = DefaultSourcePathResolver.from(ruleFinder);\r\n    CxxLink sharedLibrary = (CxxLink) graphBuilder.requireRule(baseTarget.withAppendedFlavors(cxxPlatform.getFlavor(), CxxLibraryDescription.Type.SHARED.getFlavor()));\r\n    return SharedLibraryInterfaceFactoryResolver.resolveFactory(params).createSharedInterfaceLibraryFromLibrary(baseTarget.withAppendedFlavors(CxxLibraryDescription.Type.SHARED_INTERFACE.getFlavor(), cxxPlatform.getFlavor()), projectFilesystem, graphBuilder, pathResolver, ruleFinder, cxxPlatform, sharedLibrary.getSourcePathToOutput());\r\n}"
}, {
	"Path": "com.android.dx.command.Main.without",
	"Comment": "returns a copy of the given args array, but without the indicatedelement.",
	"Method": "String[] without(String[] orig,int n){\r\n    int len = orig.length - 1;\r\n    String[] newa = new String[len];\r\n    System.arraycopy(orig, 0, newa, 0, n);\r\n    System.arraycopy(orig, n + 1, newa, n, len - n);\r\n    return newa;\r\n}"
}, {
	"Path": "com.facebook.buck.rules.keys.AbstractRuleKeyBuilder.setReflectively",
	"Comment": "recursively serializes the value. serialization of the key is handled outside.",
	"Method": "AbstractRuleKeyBuilder<RULE_KEY> setReflectively(String key,Object val,AbstractRuleKeyBuilder<RULE_KEY> setReflectively,Object val){\r\n    if (val instanceof AddsToRuleKey) {\r\n        return setAddsToRuleKey((AddsToRuleKey) val);\r\n    }\r\n    if (val instanceof BuildRule) {\r\n        return setBuildRule((BuildRule) val);\r\n    }\r\n    if (val instanceof Supplier) {\r\n        try (Scope ignored = scopedHasher.wrapperScope(RuleKeyHasher.Wrapper.SUPPLIER)) {\r\n            Object newVal = ((Supplier<?>) val).get();\r\n            return setReflectively(newVal);\r\n        }\r\n    }\r\n    if (val instanceof Optional) {\r\n        Object o = ((Optional<?>) val).orElse(null);\r\n        try (Scope ignored = scopedHasher.wrapperScope(RuleKeyHasher.Wrapper.OPTIONAL)) {\r\n            return setReflectively(o);\r\n        }\r\n    }\r\n    if (val instanceof OptionalInt) {\r\n        OptionalInt optionalInt = (OptionalInt) val;\r\n        @Nullable\r\n        Object o = optionalInt.isPresent() ? optionalInt.getAsInt() : null;\r\n        try (Scope ignored = scopedHasher.wrapperScope(RuleKeyHasher.Wrapper.OPTIONAL_INT)) {\r\n            return setReflectively(o);\r\n        }\r\n    }\r\n    if (val instanceof Either) {\r\n        Either<?, ?> either = (Either<?, ?>) val;\r\n        if (either.isLeft()) {\r\n            try (Scope ignored = scopedHasher.wrapperScope(RuleKeyHasher.Wrapper.EITHER_LEFT)) {\r\n                return setReflectively(either.getLeft());\r\n            }\r\n        } else {\r\n            try (Scope ignored = scopedHasher.wrapperScope(RuleKeyHasher.Wrapper.EITHER_RIGHT)) {\r\n                return setReflectively(either.getRight());\r\n            }\r\n        }\r\n    }\r\n    if (val instanceof Iterable && !(val instanceof Path)) {\r\n        try (RuleKeyScopedHasher.ContainerScope containerScope = scopedHasher.containerScope(RuleKeyHasher.Container.LIST)) {\r\n            for (Object element : (Iterable<?>) val) {\r\n                try (Scope ignored = containerScope.elementScope()) {\r\n                    setReflectively(element);\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n    if (val instanceof Iterator) {\r\n        Iterator<?> iterator = (Iterator<?>) val;\r\n        try (RuleKeyScopedHasher.ContainerScope containerScope = scopedHasher.containerScope(RuleKeyHasher.Container.LIST)) {\r\n            while (iterator.hasNext()) {\r\n                try (Scope ignored = containerScope.elementScope()) {\r\n                    setReflectively(iterator.next());\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    if (val instanceof Map) {\r\n        if (!(val instanceof SortedMap || val instanceof ImmutableMap)) {\r\n            LOG.warn(\"Adding an unsorted map to the rule key. \" + \"Expect unstable ordering and caches misses: %s\", val);\r\n        }\r\n        try (RuleKeyScopedHasher.ContainerScope containerScope = scopedHasher.containerScope(RuleKeyHasher.Container.MAP)) {\r\n            for (Map.Entry<?, ?> entry : ((Map<?, ?>) val).entrySet()) {\r\n                try (Scope ignored = containerScope.elementScope()) {\r\n                    setReflectively(entry.getKey());\r\n                }\r\n                try (Scope ignored = containerScope.elementScope()) {\r\n                    setReflectively(entry.getValue());\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    if (val instanceof Path) {\r\n        throw new HumanReadableException(\"It's not possible to reliably disambiguate Paths. They are disallowed from rule keys\");\r\n    }\r\n    if (val instanceof SourcePath) {\r\n        return setSourcePath((SourcePath) val);\r\n    }\r\n    if (val instanceof NonHashableSourcePathContainer) {\r\n        SourcePath sourcePath = ((NonHashableSourcePathContainer) val).getSourcePath();\r\n        return setNonHashingSourcePath(sourcePath);\r\n    }\r\n    return setSingleValue(val);\r\n}"
}, {
	"Path": "com.facebook.buck.util.filesystem.PathFragments.fragmentToPath",
	"Comment": "convert a skylark pathfragment to a path using the default filesystem.",
	"Method": "Path fragmentToPath(PathFragment fragment,Path fragmentToPath,FileSystem fileSystem,PathFragment fragment){\r\n    return fileSystem.getPath(fragment.toString());\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getANibble",
	"Comment": "gets the a register number, as a nibble. this will throw if thevalue is out of the range of an unsigned nibble.",
	"Method": "short getANibble(){\r\n    int a = getA();\r\n    if ((a & ~0xf) != 0) {\r\n        throw new DexException(\"Register A out of range: \" + Hex.u8(a));\r\n    }\r\n    return (short) a;\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.TestResultFormatter.reportResult",
	"Comment": "writes a detailed summary that ends with a trailing newline.",
	"Method": "void reportResult(ImmutableList.Builder<String> addTo,TestResults results){\r\n    if (verbosity.shouldPrintBinaryRunInformation() && results.getTotalNumberOfTests() > 1) {\r\n        addTo.add(\"\");\r\n        addTo.add(String.format(locale, \"Results for %s (%d/%d) %s\", results.getBuildTarget().getFullyQualifiedName(), results.getSequenceNumber(), results.getTotalNumberOfTests(), verbosity));\r\n    }\r\n    boolean shouldReportLogSummaryAfterTests = false;\r\n    for (TestCaseSummary testCase : results.getTestCases()) {\r\n        if (testCase.getPassedCount() == 0 && testCase.getFailureCount() == 0 && testCase.getSkippedCount() == 0) {\r\n            continue;\r\n        }\r\n        String oneLineSummary = testCase.getOneLineSummary(locale, results.getDependenciesPassTheirTests(), ansi);\r\n        addTo.add(oneLineSummary);\r\n        if (testCase.isSuccess()) {\r\n            continue;\r\n        }\r\n        for (TestResultSummary testResult : testCase.getTestResults()) {\r\n            if (!results.getDependenciesPassTheirTests()) {\r\n                continue;\r\n            }\r\n            if (!testResult.isSuccess()) {\r\n                shouldReportLogSummaryAfterTests = true;\r\n                reportResultSummary(addTo, testResult);\r\n            }\r\n        }\r\n    }\r\n    if (shouldReportLogSummaryAfterTests && verbosity != Verbosity.SILENT) {\r\n        for (Path testLogPath : results.getTestLogPaths()) {\r\n            if (Files.exists(testLogPath)) {\r\n                reportLogSummary(locale, addTo, testLogPath, summaryVerbosity.getMaxDebugLogLines().orElse(DEFAULT_MAX_LOG_LINES));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.dex.code.StdCatchBuilder.rangeIsValid",
	"Comment": "gets whether the address range for the given two blocks is validfor a catch handler. this is true as long as the covered range isunder 65536 code units.",
	"Method": "boolean rangeIsValid(BasicBlock start,BasicBlock end,BlockAddresses addresses){\r\n    if (start == null) {\r\n        throw new NullPointerException(\"start == null\");\r\n    }\r\n    if (end == null) {\r\n        throw new NullPointerException(\"end == null\");\r\n    }\r\n    int startAddress = addresses.getLast(start).getAddress();\r\n    int endAddress = addresses.getEnd(end).getAddress();\r\n    return (endAddress - startAddress) <= MAX_CATCH_RANGE;\r\n}"
}, {
	"Path": "com.facebook.buck.shell.ExportFileDescription.inferInputsFromConstructorArgs",
	"Comment": "if the src field is absent, add the name field to the list of inputs.",
	"Method": "Iterable<Path> inferInputsFromConstructorArgs(UnflavoredBuildTarget buildTarget,ExportFileDescriptionArg constructorArg){\r\n    ImmutableList.Builder<Path> inputs = ImmutableList.builder();\r\n    if (!constructorArg.getSrc().isPresent()) {\r\n        inputs.add(buildTarget.getBasePath().resolve(buildTarget.getShortName()));\r\n    }\r\n    return inputs.build();\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.endtoend.EndToEndEnvironment.getVariableMaps",
	"Comment": "gets the list of environment variable override maps, where a test will be run with eachindividual map.if no environment override maps have been provided, then this will return a list with anempty override map inside.",
	"Method": "List<Map<String, String>> getVariableMaps(){\r\n    if (!variableMaps.isEmpty()) {\r\n        return variableMaps;\r\n    }\r\n    List<Map<String, String>> emptyMapList = new ArrayList();\r\n    emptyMapList.add(Collections.emptyMap());\r\n    return emptyMapList;\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.plugin.PluginLoader.getPluginClassLoader",
	"Comment": "returns a class loader that can be used to load classes from the compiler plugin jar.",
	"Method": "ClassLoader getPluginClassLoader(ClassLoaderCache classLoaderCache,JavaCompiler.CompilationTask compiler){\r\n    ClassLoader compilerClassLoader = compiler.getClass().getClassLoader();\r\n    return classLoaderCache.getClassLoaderForClassPath(compilerClassLoader, ImmutableList.of(JAVAC_PLUGIN_JAR_URL));\r\n}"
}, {
	"Path": "com.facebook.buck.parser.BuckPythonProgram.newInstance",
	"Comment": "create a new instance by layout the files in a temporary directory.",
	"Method": "BuckPythonProgram newInstance(TypeCoercerFactory typeCoercerFactory,ImmutableSet<BaseDescription<?>> descriptions,boolean cleanupEnabled){\r\n    Path pythonPath;\r\n    if (PATH_TO_PYTHON_DSL.isEmpty()) {\r\n        try {\r\n            URL url = Resources.getResource(\"buck_parser\");\r\n            if (\"jar\".equals(url.getProtocol())) {\r\n                JarURLConnection connection = (JarURLConnection) url.openConnection();\r\n                Preconditions.checkState(connection.getEntryName().equals(\"buck_parser\"), \"buck_parser directory should be at the root of the jar file.\");\r\n                URI jarFileURI = connection.getJarFileURL().toURI();\r\n                pythonPath = Paths.get(jarFileURI);\r\n            } else if (\"file\".equals(url.getProtocol())) {\r\n                pythonPath = Paths.get(url.toURI()).getParent();\r\n            } else {\r\n                throw new IllegalStateException(\"buck_python resource directory should reside in a local directory or in a jar file. \" + \"Got: \" + url);\r\n            }\r\n        } catch (URISyntaxException e) {\r\n            throw new IllegalStateException(\"Failed to determine location of buck_parser python package\", e);\r\n        }\r\n    } else {\r\n        pythonPath = Paths.get(PATH_TO_PYTHON_DSL);\r\n    }\r\n    Path generatedRoot = Files.createTempDirectory(\"buck_python_program\");\r\n    LOG.debug(\"Writing python rules stub to %s.\", generatedRoot);\r\n    try (Writer out = Files.newBufferedWriter(generatedRoot.resolve(\"generated_rules.py\"), UTF_8)) {\r\n        out.write(\"from buck_parser.buck import *\\n\\n\");\r\n        BuckPyFunction function = new BuckPyFunction(typeCoercerFactory, CoercedTypeCache.INSTANCE);\r\n        for (BaseDescription<?> description : descriptions) {\r\n            try {\r\n                out.write(function.toPythonFunction(DescriptionCache.getRuleType(description), description.getConstructorArgType()));\r\n                out.write('\\n');\r\n            } catch (RuntimeException e) {\r\n                throw new BuckUncheckedExecutionException(e, \"When writing python function for %s.\", description.getClass().getName());\r\n            }\r\n        }\r\n    }\r\n    String pathlibDir = PATH_TO_PATHLIB_PY.getParent().toString();\r\n    String watchmanDir = PATH_TO_PYWATCHMAN.toString();\r\n    String typingDir = PATH_TO_TYPING.toString();\r\n    String sixDir = PATH_TO_SIX_PY.getParent().toString();\r\n    try (Writer out = Files.newBufferedWriter(generatedRoot.resolve(\"__main__.py\"), UTF_8)) {\r\n        out.write(// Path to the bundled python code.\r\n        Joiner.on(\"\\n\").join(// Path to the bundled python code.\r\n        \"from __future__ import absolute_import, print_function\", // Path to the bundled python code.\r\n        \"import sys\", // Path to the bundled python code.\r\n        \"PY2 = sys.version_info[0] == 2\", // Path to the bundled python code.\r\n        \"sys.path.insert(0, \" + Escaper.escapeAsPythonString(MorePaths.pathWithUnixSeparators(pathlibDir)) + \")\", // Path to the bundled python code.\r\n        \"sys.path.insert(0, \" + Escaper.escapeAsPythonString(MorePaths.pathWithUnixSeparators(watchmanDir)) + \")\", // Path to the bundled python code.\r\n        \"if PY2:\", // Path to the bundled python code.\r\n        \"    sys.path.insert(0, \" + Escaper.escapeAsPythonString(MorePaths.pathWithUnixSeparators(typingDir)) + \")\", \"sys.path.insert(0, \" + Escaper.escapeAsPythonString(MorePaths.pathWithUnixSeparators(sixDir)) + \")\", \"sys.path.insert(0, \" + Escaper.escapeAsPythonString(MorePaths.pathWithUnixSeparators(pythonPath)) + \")\", \"sys.path.insert(0, \" + Escaper.escapeAsPythonString(MorePaths.pathWithUnixSeparators(generatedRoot)) + \")\", \"if __name__ == '__main__':\", \"    try:\", \"        from buck_parser import buck\", \"        buck.main()\", \"    except KeyboardInterrupt:\", \"        print('Killed by User', file=sys.stderr)\", \"\"));\r\n    }\r\n    LOG.debug(\"Created temporary buck.py instance at %s.\", generatedRoot);\r\n    return new BuckPythonProgram(generatedRoot, cleanupEnabled);\r\n}"
}, {
	"Path": "com.facebook.buck.remoteexecution.config.AbstractRemoteExecutionConfig.isSuperConsoleEnabled",
	"Comment": "whether superconsole output of remote execution information is enabled.",
	"Method": "boolean isSuperConsoleEnabled(){\r\n    return getType() != RemoteExecutionType.NONE;\r\n}"
}, {
	"Path": "com.facebook.buck.util.MoreIterables.zipAndConcat",
	"Comment": "combine the given iterables by peeling off items one at a time from each of the input iterablesuntil any one of the iterables are exhausted.",
	"Method": "Iterable<T> zipAndConcat(Iterable<T> inputs){\r\n    if (inputs.length == 0) {\r\n        return ImmutableList.of();\r\n    }\r\n    ImmutableList.Builder<T> result = ImmutableList.builder();\r\n    ImmutableList<Iterator<T>> iterators = iterators(inputs);\r\n    List<T> round = Lists.newArrayListWithCapacity(inputs.length);\r\n    while (true) {\r\n        for (Iterator<T> iterator : iterators) {\r\n            if (!iterator.hasNext()) {\r\n                return result.build();\r\n            }\r\n            round.add(iterator.next());\r\n        }\r\n        result.addAll(round);\r\n        round.clear();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.rules.modern.builders.IsolatedBuildableBuilder.build",
	"Comment": "deserializes the buildableandtarget corresponding to hash and builds it.",
	"Method": "void build(HashCode hash){\r\n    final Instant start = Instant.now();\r\n    Deserializer deserializer = new // is in).\r\n    Deserializer(// is in).\r\n    filesystemFunction, // is in).\r\n    classFinder, buildContext::getSourcePathResolver, toolchainProviderFunction.apply(Optional.empty()));\r\n    BuildableAndTarget reconstructed;\r\n    try (Scope ignored = LeafEvents.scope(eventBus, \"deserializing\")) {\r\n        reconstructed = deserializer.deserialize(getProvider(dataRoot.resolve(hash.toString())), BuildableAndTarget.class);\r\n    }\r\n    try (Scope ignored = LeafEvents.scope(eventBus, \"steps\")) {\r\n        ProjectFilesystem filesystem = filesystemFunction.apply(reconstructed.target.getCell());\r\n        ModernBuildRule.injectFieldsIfNecessary(filesystem, reconstructed.target, reconstructed.buildable, new SourcePathRuleFinder(new AbstractBuildRuleResolver() {\r\n            @Override\r\n            public Optional<BuildRule> getRuleOptional(BuildTarget buildTarget) {\r\n                throw new RuntimeException(\"Cannot resolve rules in deserialized MBR state.\");\r\n            }\r\n        }));\r\n        final Instant deserializationComplete = Instant.now();\r\n        LOG.info(String.format(\"Finished deserializing the rule at [%s], took %d ms. Running the build now.\", new java.util.Date(), deserializationComplete.minusMillis(start.toEpochMilli()).toEpochMilli()));\r\n        for (Step step : ModernBuildRule.stepsForBuildable(buildContext, reconstructed.buildable, filesystem, reconstructed.target)) {\r\n            new DefaultStepRunner().runStepForBuildTarget(executionContext, step, Optional.of(reconstructed.target));\r\n        }\r\n        LOG.info(String.format(\"Finished running the build at [%s], took %d ms. Exiting buck now.\", new java.util.Date(), Instant.now().minusMillis(deserializationComplete.toEpochMilli()).toEpochMilli()));\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.rules.modern.builders.IsolatedBuildableBuilder.build",
	"Comment": "deserializes the buildableandtarget corresponding to hash and builds it.",
	"Method": "void build(HashCode hash){\r\n    throw new RuntimeException(\"Cannot resolve rules in deserialized MBR state.\");\r\n}"
}, {
	"Path": "com.android.dx.dex.code.InsnFormat.signedFitsInByte",
	"Comment": "helper method to determine if a signed int value fits in a byte.",
	"Method": "boolean signedFitsInByte(int value){\r\n    return (byte) value == value;\r\n}"
}, {
	"Path": "com.facebook.buck.util.unarchive.Untar.setDirectoryModificationTimes",
	"Comment": "set the modification times on directories that were directly specified in the archive",
	"Method": "void setDirectoryModificationTimes(ProjectFilesystem filesystem,NavigableMap<Path, Long> dirToTime){\r\n    for (Map.Entry<Path, Long> pathAndTime : dirToTime.descendingMap().entrySet()) {\r\n        File file = filesystem.getRootPath().resolve(pathAndTime.getKey()).toFile();\r\n        file.setLastModified(pathAndTime.getValue());\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.SuperConsoleEventBusListener.startRenderScheduler",
	"Comment": "schedules a runnable that updates the console output at a fixed interval.",
	"Method": "void startRenderScheduler(long renderInterval,TimeUnit timeUnit){\r\n    LOG.debug(\"Starting render scheduler (interval %d ms)\", timeUnit.toMillis(renderInterval));\r\n    renderScheduler.scheduleAtFixedRate(() -> {\r\n        try {\r\n            SuperConsoleEventBusListener.this.render();\r\n        } catch (Error | RuntimeException e) {\r\n            LOG.error(e, \"Rendering exception\");\r\n            throw e;\r\n        }\r\n    }, renderInterval, renderInterval, timeUnit);\r\n}"
}, {
	"Path": "com.android.dx.cf.code.Ropper.deleteUnreachableBlocks",
	"Comment": "deletes all blocks that cannot be reached. this is run to deleteoriginal subroutine blocks after subroutine inlining.",
	"Method": "void deleteUnreachableBlocks(){\r\n    final IntList reachableLabels = new IntList(result.size());\r\n    resultSubroutines.clear();\r\n    forEachNonSubBlockDepthFirst(getSpecialLabel(PARAM_ASSIGNMENT), new BasicBlock.Visitor() {\r\n        public void visitBlock(BasicBlock b) {\r\n            reachableLabels.add(b.getLabel());\r\n        }\r\n    });\r\n    reachableLabels.sort();\r\n    for (int i = result.size() - 1; i >= 0; i--) {\r\n        if (reachableLabels.indexOf(result.get(i).getLabel()) < 0) {\r\n            result.remove(i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.cf.code.Ropper.deleteUnreachableBlocks",
	"Comment": "deletes all blocks that cannot be reached. this is run to deleteoriginal subroutine blocks after subroutine inlining.",
	"Method": "void deleteUnreachableBlocks(){\r\n    reachableLabels.add(b.getLabel());\r\n}"
}, {
	"Path": "com.facebook.buck.features.ocaml.OcamlUtil.ext",
	"Comment": "constructs a predicate instance which returns true if the input argument ends with any stringin extensions",
	"Method": "Predicate<? super Path> ext(String extensions){\r\n    return (Predicate<Path>) input -> {\r\n        String strInput = input.toString();\r\n        for (String ext : extensions) {\r\n            if (strInput.endsWith(ext)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.CoordinatorModeRunner.createHeartbeatCallback",
	"Comment": "reports back to the servers that the coordinator is healthy and alive.",
	"Method": "HeartbeatCallback createHeartbeatCallback(StampedeId stampedeId,DistBuildService service,HeartbeatCallback createHeartbeatCallback){\r\n    return createHeartbeatCallback(stampedeId, distBuildService);\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.HealthCheckStatsTracker.recordDeadMinionCheckSample",
	"Comment": "notify stats tracker about a new dead minion check completing.",
	"Method": "void recordDeadMinionCheckSample(long elapsedTimeSinceLastCheckMillis,boolean wasTooSlow){\r\n    if (wasTooSlow) {\r\n        slowDeadMinionChecksCount++;\r\n    }\r\n    if (elapsedTimeSinceLastCheckMillis > slowestDeadMinionCheckIntervalMillis) {\r\n        slowestDeadMinionCheckIntervalMillis = elapsedTimeSinceLastCheckMillis;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.rules.keys.config.impl.BuckBinaryHashProvider.getBuckBinaryHash",
	"Comment": "returns buck binary hashthe buck binary hash key is generated during build time and reflects changes in buck codethat can affect the content of build artifacts.",
	"Method": "String getBuckBinaryHash(){\r\n    if (buckBinaryHash == null) {\r\n        buckBinaryHash = Objects.requireNonNull(System.getProperty(\"buck.binary_hash\"));\r\n    }\r\n    return buckBinaryHash;\r\n}"
}, {
	"Path": "com.android.manifmerger.XmlDocument.checkUsesSdkMinVersion",
	"Comment": "returns true if the minsdkversion of the application and the library are compatible, falseotherwise.",
	"Method": "boolean checkUsesSdkMinVersion(XmlDocument lowerPriorityDocument,MergingReport.Builder mergingReport){\r\n    int thisMinSdk = getApiLevelFromAttribute(getMinSdkVersion(DEFAULT_SDK_VERSION));\r\n    int libraryMinSdk = getApiLevelFromAttribute(lowerPriorityDocument.getRawMinSdkVersion(String.valueOf(thisMinSdk)));\r\n    if (thisMinSdk < libraryMinSdk) {\r\n        Optional<XmlElement> xmlElementOptional = getByTypeAndKey(USES_SDK, null);\r\n        if (!xmlElementOptional.isPresent()) {\r\n            return false;\r\n        }\r\n        XmlElement xmlElement = xmlElementOptional.get();\r\n        for (Selector selector : xmlElement.getOverrideUsesSdkLibrarySelectors()) {\r\n            if (selector.appliesTo(lowerPriorityDocument.getRootNode())) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.facebook.buck.swift.SwiftBuckConfig.getProjectWMO",
	"Comment": "if enabled, turns on whole module optimization for any targets that contain swift.",
	"Method": "boolean getProjectWMO(){\r\n    return delegate.getBooleanValue(SECTION_NAME, PROJECT_WMO, false);\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.CompileToJarStepFactory.getBootClasspath",
	"Comment": "this can be used make the bootclasspath if available, to the postprocess classes commands.",
	"Method": "Optional<String> getBootClasspath(BuildContext context){\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "com.android.dx.dex.code.InsnFormat.opcodeUnit",
	"Comment": "helper method to combine an opcode and a second byte of data intothe appropriate form for emitting into a code buffer.",
	"Method": "short opcodeUnit(DalvInsn insn,int arg,short opcodeUnit,DalvInsn insn){\r\n    int opcode = insn.getOpcode().getOpcode();\r\n    if ((opcode < 0x100) || (opcode > 0xffff)) {\r\n        throw new IllegalArgumentException(\"opcode out of range 0..65535\");\r\n    }\r\n    return (short) opcode;\r\n}"
}, {
	"Path": "com.facebook.buck.artifact_cache.SQLiteArtifactCacheTest.writeFileArtifact",
	"Comment": "writes an artifact large enough to be stored on disk.uses the pathname to guarantee that files have different content for testing overwrites.",
	"Method": "void writeFileArtifact(Path file){\r\n    byte[] toWrite = file.toString().getBytes(UTF_8);\r\n    for (int i = 0; i <= MAX_INLINED_BYTES / toWrite.length; i++) {\r\n        Files.write(file, toWrite, StandardOpenOption.CREATE, StandardOpenOption.APPEND);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.rules.args.SanitizedArg.create",
	"Comment": "create a sanitizedarg by applying the given sanitizer function to an arg string.",
	"Method": "SanitizedArg create(Function<? super String, String> sanitizer,String unsanitized){\r\n    return INTERNER.intern(new SanitizedArg(unsanitized, sanitizer.apply(unsanitized)));\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getTargetUnit",
	"Comment": "gets the target as a relative offset from the given baseaddress, as a code unit. this will throw if the value is out ofthe range of a signed code unit.",
	"Method": "short getTargetUnit(int baseAddress){\r\n    int relativeTarget = getTarget(baseAddress);\r\n    if (relativeTarget != (short) relativeTarget) {\r\n        throw new DexException(\"Target out of range: \" + Hex.s4(relativeTarget));\r\n    }\r\n    return (short) relativeTarget;\r\n}"
}, {
	"Path": "com.android.dx.dex.file.MethodIdsSection.writeHeaderPart",
	"Comment": "writes the portion of the file header that refers to this instance.",
	"Method": "void writeHeaderPart(AnnotatedOutput out){\r\n    throwIfNotPrepared();\r\n    int sz = methodIds.size();\r\n    int offset = (sz == 0) ? 0 : getFileOffset();\r\n    if (out.annotates()) {\r\n        out.annotate(4, \"method_ids_size: \" + Hex.u4(sz));\r\n        out.annotate(4, \"method_ids_off:  \" + Hex.u4(offset));\r\n    }\r\n    out.writeInt(sz);\r\n    out.writeInt(offset);\r\n}"
}, {
	"Path": "com.facebook.buck.features.project.intellij.IjModuleGraphFactory.createModules",
	"Comment": "create all the modules we are capable of representing in intellij from the supplied graph.",
	"Method": "ImmutableMap<BuildTarget, IjModule> createModules(ProjectFilesystem projectFilesystem,IjProjectConfig projectConfig,TargetGraph targetGraph,IjModuleFactory moduleFactory,AggregationModuleFactory aggregationModuleFactory,int minimumPathDepth,ImmutableSet<String> ignoredTargetLabels){\r\n    Stream<TargetNode<?>> nodes = targetGraph.getNodes().stream().filter(input -> SupportedTargetTypeRegistry.isTargetTypeSupported(input.getDescription().getClass())).filter(targetNode -> {\r\n        CommonDescriptionArg arg = (CommonDescriptionArg) targetNode.getConstructorArg();\r\n        return !arg.labelsContainsAnyOf(ignoredTargetLabels);\r\n    }).filter(targetNode -> isInRootCell(projectFilesystem, targetNode));\r\n    ImmutableListMultimap<Path, TargetNode<?>> baseTargetPathMultimap = (projectConfig.getProjectRoot().isEmpty() ? nodes : nodes.filter(targetNode -> shouldConvertToIjModule(projectConfig.getProjectRoot(), targetNode))).collect(ImmutableListMultimap.toImmutableListMultimap(targetNode -> targetNode.getBuildTarget().getBasePath(), targetNode -> targetNode));\r\n    AggregationTree aggregationTree = createAggregationTree(projectConfig, aggregationModuleFactory, baseTargetPathMultimap);\r\n    aggregationTree.aggregateModules(minimumPathDepth);\r\n    ImmutableMap.Builder<BuildTarget, IjModule> moduleByBuildTarget = new ImmutableMap.Builder();\r\n    aggregationTree.getModules().parallelStream().filter(aggregationModule -> !aggregationModule.getTargets().isEmpty()).forEach(aggregationModule -> {\r\n        IjModule module = moduleFactory.createModule(aggregationModule.getModuleBasePath(), aggregationModule.getTargets(), aggregationModule.getExcludes());\r\n        synchronized (moduleByBuildTarget) {\r\n            module.getTargets().forEach(buildTarget -> moduleByBuildTarget.put(buildTarget, module));\r\n        }\r\n    });\r\n    return moduleByBuildTarget.build();\r\n}"
}, {
	"Path": "com.facebook.buck.sandbox.darwin.DarwinSandbox.createCommandLineArguments",
	"Comment": "creates a list cl arguments that should be used to run a process in this sandbox",
	"Method": "ImmutableList<String> createCommandLineArguments(String profilePath,ImmutableList<String> createCommandLineArguments){\r\n    return createCommandLineArguments(Objects.requireNonNull(sandboxProfilePath).toAbsolutePath().toString());\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.DefaultJavaLibraryTest.testAddAnnotationProcessorWithOptions",
	"Comment": "verify adding an annotation processor java binary with options.",
	"Method": "void testAddAnnotationProcessorWithOptions(){\r\n    AnnotationProcessingScenario scenario = new AnnotationProcessingScenario();\r\n    scenario.addAnnotationProcessorTarget(validJavaBinary);\r\n    scenario.getAnnotationProcessingParamsBuilder().setLegacyAnnotationProcessorNames(ImmutableList.of(\"MyProcessor\"));\r\n    scenario.getAnnotationProcessingParamsBuilder().addParameters(\"MyParameter\");\r\n    scenario.getAnnotationProcessingParamsBuilder().addParameters(\"MyKey=MyValue\");\r\n    scenario.getAnnotationProcessingParamsBuilder().setProcessOnly(true);\r\n    ImmutableList<String> parameters = scenario.buildAndGetCompileParameters();\r\n    MoreAsserts.assertContainsOne(parameters, \"-processorpath\");\r\n    MoreAsserts.assertContainsOne(parameters, \"-processor\");\r\n    assertHasProcessor(parameters, \"MyProcessor\");\r\n    MoreAsserts.assertContainsOne(parameters, \"-s\");\r\n    MoreAsserts.assertContainsOne(parameters, annotationScenarioGenPath);\r\n    MoreAsserts.assertContainsOne(parameters, \"-proc:only\");\r\n    assertEquals(\"Expected '-processor MyProcessor' parameters\", parameters.indexOf(\"-processor\") + 1, parameters.indexOf(\"MyProcessor\"));\r\n    assertEquals(\"Expected '-s \" + annotationScenarioGenPath + \"' parameters\", parameters.indexOf(\"-s\") + 1, parameters.indexOf(annotationScenarioGenPath));\r\n    MoreAsserts.assertContainsOne(parameters, \"-AMyParameter\");\r\n    MoreAsserts.assertContainsOne(parameters, \"-AMyKey=MyValue\");\r\n}"
}, {
	"Path": "com.android.dx.command.annotool.AnnotationLister.isMatchingPackage",
	"Comment": "checks to see if a specified package should be considered a match dueto previous matches.",
	"Method": "boolean isMatchingPackage(String s){\r\n    int slashIndex = s.lastIndexOf('/');\r\n    String packageName;\r\n    if (slashIndex == -1) {\r\n        packageName = \"\";\r\n    } else {\r\n        packageName = s.substring(0, slashIndex);\r\n    }\r\n    return matchPackages.contains(packageName);\r\n}"
}, {
	"Path": "com.android.dx.dex.file.ClassDefsSection.add",
	"Comment": "adds an element to this instance. it is illegal to attempt to add morethan one class with the same name.",
	"Method": "void add(ClassDefItem clazz){\r\n    Type type;\r\n    try {\r\n        type = clazz.getThisClass().getClassType();\r\n    } catch (NullPointerException ex) {\r\n        throw new NullPointerException(\"clazz == null\");\r\n    }\r\n    throwIfPrepared();\r\n    if (classDefs.get(type) != null) {\r\n        throw new IllegalArgumentException(\"already added: \" + type);\r\n    }\r\n    classDefs.put(type, clazz);\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.AbstractCxxSourceRuleFactory.canUsePrecompiledHeaders",
	"Comment": "can pch headers be used with the current configuration and type of compiler?",
	"Method": "boolean canUsePrecompiledHeaders(CxxSource.Type sourceType){\r\n    return getCxxBuckConfig().isPCHEnabled() && sourceType.getPrecompiledHeaderLanguage().isPresent() && CxxSourceTypes.getPreprocessor(getCxxPlatform(), sourceType).resolve(getActionGraphBuilder()).supportsPrecompiledHeaders();\r\n}"
}, {
	"Path": "com.android.manifmerger.XmlDocument.addImplicitElements",
	"Comment": "add all implicit elements from the passed lower priority document that arerequired in the target sdk.",
	"Method": "void addImplicitElements(XmlDocument lowerPriorityDocument,MergingReport.Builder mergingReport){\r\n    Optional<XmlElement> usesSdk = getByTypeAndKey(ManifestModel.NodeTypes.USES_SDK, null);\r\n    if (mType == Type.OVERLAY && !usesSdk.isPresent()) {\r\n        return;\r\n    }\r\n    if (usesSdk.isPresent()) {\r\n        XmlElement usesSdkElement = usesSdk.get();\r\n        if (usesSdkElement.getOperationType() != NodeOperationType.MERGE) {\r\n            mergingReport.addMessage(new SourceFilePosition(getSourceFile(), usesSdkElement.getPosition()), MergingReport.Record.Severity.ERROR, \"uses-sdk element cannot have a \\\"tools:node\\\" attribute\");\r\n            return;\r\n        }\r\n    }\r\n    int thisTargetSdk = getApiLevelFromAttribute(getTargetSdkVersion(DEFAULT_SDK_VERSION));\r\n    int libraryTargetSdk = getApiLevelFromAttribute(lowerPriorityDocument.getFileType() == Type.LIBRARY ? lowerPriorityDocument.getRawTargetSdkVersion(String.valueOf(thisTargetSdk)) : lowerPriorityDocument.getTargetSdkVersion(String.valueOf(thisTargetSdk)));\r\n    String libraryTargetSdkVersion = lowerPriorityDocument.getTargetSdkVersion(String.valueOf(thisTargetSdk));\r\n    if (!Character.isDigit(libraryTargetSdkVersion.charAt(0))) {\r\n        if (!libraryTargetSdkVersion.equals(getTargetSdkVersion(DEFAULT_SDK_VERSION))) {\r\n            mergingReport.addMessage(getSourceFile(), MergingReport.Record.Severity.ERROR, String.format(\"uses-sdk:targetSdkVersion %1$s cannot be different than version \" + \"%2$s declared in library %3$s\", getTargetSdkVersion(DEFAULT_SDK_VERSION), libraryTargetSdkVersion, lowerPriorityDocument.getSourceFile().print(false)));\r\n            return;\r\n        }\r\n    }\r\n    String libraryMinSdkVersion = lowerPriorityDocument.getRawMinSdkVersion(String.valueOf(thisTargetSdk));\r\n    if (!Character.isDigit(libraryMinSdkVersion.charAt(0))) {\r\n        if (!libraryMinSdkVersion.equals(getMinSdkVersion(DEFAULT_SDK_VERSION))) {\r\n            mergingReport.addMessage(getSourceFile(), MergingReport.Record.Severity.ERROR, String.format(\"uses-sdk:minSdkVersion %1$s cannot be different than version \" + \"%2$s declared in library %3$s\", getMinSdkVersion(DEFAULT_SDK_VERSION), libraryMinSdkVersion, lowerPriorityDocument.getSourceFile().print(false)));\r\n            return;\r\n        }\r\n    }\r\n    if (!checkUsesSdkMinVersion(lowerPriorityDocument, mergingReport)) {\r\n        String error = String.format(\"uses-sdk:minSdkVersion %1$s cannot be smaller than version \" + \"%2$s declared in library %3$s\\n\" + \"\\tSuggestion: use tools:overrideLibrary=\\\"%4$s\\\" to force usage\", getMinSdkVersion(DEFAULT_SDK_VERSION), libraryMinSdkVersion, lowerPriorityDocument.getSourceFile().print(false), lowerPriorityDocument.getPackageName());\r\n        if (usesSdk.isPresent()) {\r\n            mergingReport.addMessage(new SourceFilePosition(getSourceFile(), usesSdk.get().getPosition()), MergingReport.Record.Severity.ERROR, error);\r\n        } else {\r\n            mergingReport.addMessage(getSourceFile(), MergingReport.Record.Severity.ERROR, error);\r\n        }\r\n        return;\r\n    }\r\n    if (thisTargetSdk <= libraryTargetSdk) {\r\n        return;\r\n    }\r\n    if (thisTargetSdk < 4) {\r\n        return;\r\n    }\r\n    boolean hasWriteToExternalStoragePermission = lowerPriorityDocument.getByTypeAndKey(USES_PERMISSION, permission(\"WRITE_EXTERNAL_STORAGE\")).isPresent();\r\n    if (libraryTargetSdk < 4) {\r\n        addIfAbsent(mergingReport.getActionRecorder(), USES_PERMISSION, permission(\"WRITE_EXTERNAL_STORAGE\"), lowerPriorityDocument.getPackageName() + \" has a targetSdkVersion < 4\");\r\n        hasWriteToExternalStoragePermission = true;\r\n        addIfAbsent(mergingReport.getActionRecorder(), USES_PERMISSION, permission(\"READ_PHONE_STATE\"), lowerPriorityDocument.getPackageName() + \" has a targetSdkVersion < 4\");\r\n    }\r\n    if (hasWriteToExternalStoragePermission) {\r\n        addIfAbsent(mergingReport.getActionRecorder(), USES_PERMISSION, permission(\"READ_EXTERNAL_STORAGE\"), lowerPriorityDocument.getPackageName() + \" requested WRITE_EXTERNAL_STORAGE\");\r\n    }\r\n    if (thisTargetSdk >= 16 && libraryTargetSdk < 16) {\r\n        if (lowerPriorityDocument.getByTypeAndKey(USES_PERMISSION, permission(\"READ_CONTACTS\")).isPresent()) {\r\n            addIfAbsent(mergingReport.getActionRecorder(), USES_PERMISSION, permission(\"READ_CALL_LOG\"), lowerPriorityDocument.getPackageName() + \" has targetSdkVersion < 16 and requested READ_CONTACTS\");\r\n        }\r\n        if (lowerPriorityDocument.getByTypeAndKey(USES_PERMISSION, permission(\"WRITE_CONTACTS\")).isPresent()) {\r\n            addIfAbsent(mergingReport.getActionRecorder(), USES_PERMISSION, permission(\"WRITE_CALL_LOG\"), lowerPriorityDocument.getPackageName() + \" has targetSdkVersion < 16 and requested WRITE_CONTACTS\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.common.ide.common.xml.XmlFormatPreferences.getAttributeComparator",
	"Comment": "returns the comparator to use when formatting, or null for no sorting",
	"Method": "Comparator<Attr> getAttributeComparator(){\r\n    return sortAttributes.getAttributeComparator();\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.CxxLibraryDescription.getPreprocessorInputsForBuildingLibrarySources",
	"Comment": "this function is broken out so that cxxinferenhancer can get a list of dependencies forbuilding the library.",
	"Method": "ImmutableList<CxxPreprocessorInput> getPreprocessorInputsForBuildingLibrarySources(CxxBuckConfig cxxBuckConfig,ActionGraphBuilder graphBuilder,CellPathResolver cellRoots,BuildTarget target,CommonArg args,CxxPlatform cxxPlatform,ImmutableSet<BuildRule> deps,TransitiveCxxPreprocessorInputFunction transitivePreprocessorInputs,ImmutableList<HeaderSymlinkTree> headerSymlinkTrees){\r\n    return CxxDescriptionEnhancer.collectCxxPreprocessorInput(target, cxxPlatform, graphBuilder, deps, ImmutableListMultimap.copyOf(Multimaps.transformValues(CxxFlags.getLanguageFlagsWithMacros(args.getPreprocessorFlags(), args.getPlatformPreprocessorFlags(), args.getLangPreprocessorFlags(), args.getLangPlatformPreprocessorFlags(), cxxPlatform), f -> CxxDescriptionEnhancer.toStringWithMacrosArgs(target, cellRoots, graphBuilder, cxxPlatform, f))), headerSymlinkTrees, ImmutableSet.of(), RichStream.from(// Also add private deps if we are _not_ reexporting all deps.\r\n    transitivePreprocessorInputs.apply(// Also add private deps if we are _not_ reexporting all deps.\r\n    target, // Also add private deps if we are _not_ reexporting all deps.\r\n    graphBuilder, // Also add private deps if we are _not_ reexporting all deps.\r\n    cxxPlatform, deps, args.isReexportAllHeaderDependencies().orElse(cxxBuckConfig.getDefaultReexportAllHeaderDependencies()) ? CxxDeps.of() : args.getPrivateCxxDeps())).toOnceIterable(), args.getRawHeaders());\r\n}"
}, {
	"Path": "com.facebook.buck.event.LeafEvents.scope",
	"Comment": "creates a simple scoped leaf event that will be logged to superconsole, chrome traces, etc.",
	"Method": "Scope scope(BuckEventBus eventBus,String category){\r\n    SimpleLeafEvent.Started started = new SimpleLeafEvent.Started(EventKey.unique(), category);\r\n    eventBus.post(started);\r\n    return () -> eventBus.post(new SimpleLeafEvent.Finished(started));\r\n}"
}, {
	"Path": "com.facebook.buck.util.unarchive.Untar.tidyDirectories",
	"Comment": "cleans up any files that exist on the filesystem that were not in the archive",
	"Method": "void tidyDirectories(ProjectFilesystem filesystem,Set<Path> dirsToTidy,ImmutableSet<Path> createdFiles){\r\n    for (Path directory : dirsToTidy) {\r\n        for (Path foundFile : filesystem.getDirectoryContents(directory)) {\r\n            if (!createdFiles.contains(foundFile) && !dirsToTidy.contains(foundFile)) {\r\n                filesystem.deleteRecursivelyIfExists(foundFile);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.PerfTimesEventListener.onRuleKeyCalculationFinished",
	"Comment": "records when a rulekey finished calculation and it is time to extract time it took.",
	"Method": "void onRuleKeyCalculationFinished(BuildRuleEvent.FinishedRuleKeyCalc event){\r\n    TimeCostEntry<BuildRuleEvent> timeCostEntry = ruleKeysCosts.get(event.getBuildRule());\r\n    if (timeCostEntry != null && timeCostEntry.getStartEvent() != null) {\r\n        long costTimeMs = TimeUnit.NANOSECONDS.toMillis(event.getNanoTime() - timeCostEntry.getStartEvent().getNanoTime());\r\n        long newValue = ruleKeyCalculationTotalTimeMs.addAndGet(costTimeMs);\r\n        perfTimesStatsBuilder.setTotalRulekeyTimeMs(newValue);\r\n        eventBus.post(PerfTimesEvent.update(perfTimesStatsBuilder.build()));\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.testrunner.JUnitRunner.mightBeATestClass",
	"Comment": "guessing whether or not a class is a test class is an imperfect art form.",
	"Method": "boolean mightBeATestClass(Class<?> klass){\r\n    if (klass.getAnnotation(RunWith.class) != null) {\r\n        return true;\r\n    }\r\n    int klassModifiers = klass.getModifiers();\r\n    if (Modifier.isInterface(klassModifiers) || Modifier.isAbstract(klassModifiers)) {\r\n        return false;\r\n    }\r\n    boolean foundPublicNoArgConstructor = false;\r\n    for (Constructor<?> c : klass.getConstructors()) {\r\n        if (Modifier.isPublic(c.getModifiers())) {\r\n            if (c.getParameterCount() != 0) {\r\n                return false;\r\n            }\r\n            foundPublicNoArgConstructor = true;\r\n        }\r\n    }\r\n    if (!foundPublicNoArgConstructor) {\r\n        return false;\r\n    }\r\n    boolean hasAtLeastOneTest = false;\r\n    for (Method m : klass.getMethods()) {\r\n        if (Modifier.isPublic(m.getModifiers()) && m.getParameters().length == 0 && m.getAnnotation(Test.class) != null) {\r\n            hasAtLeastOneTest = true;\r\n            break;\r\n        }\r\n    }\r\n    return hasAtLeastOneTest;\r\n}"
}, {
	"Path": "com.facebook.buck.util.environment.MacNetworkConfiguration.getDevicesByServiceOrder",
	"Comment": "returns a list of the network devices in order of their service priorities.",
	"Method": "List<String> getDevicesByServiceOrder(){\r\n    LOG.debug(\"Determine network service order and extract device names\");\r\n    String serviceOrderOutput = runNetworkSetupCommand(\"listnetworkserviceorder\");\r\n    Matcher matcher = devicePattern.matcher(serviceOrderOutput);\r\n    List<String> devices = new ArrayList<String>();\r\n    while (matcher.find()) {\r\n        devices.add(matcher.group(1));\r\n    }\r\n    return devices;\r\n}"
}, {
	"Path": "com.facebook.buck.util.unarchive.Unzip.extractArchive",
	"Comment": "unzips a file to a destination and returns the paths of the written files.",
	"Method": "ImmutableSet<Path> extractArchive(Path archiveFile,ProjectFilesystem filesystem,Path relativePath,Optional<Path> stripPrefix,PatternsMatcher entriesToExclude,ExistingFileMode existingFileMode){\r\n    ImmutableSet.Builder<Path> filesWritten = ImmutableSet.builder();\r\n    try (ZipFile zip = new ZipFile(archiveFile.toFile())) {\r\n        SortedMap<Path, ZipArchiveEntry> pathMap;\r\n        if (stripPrefix.isPresent()) {\r\n            pathMap = getZipFilePathsStrippingPrefix(zip, relativePath, stripPrefix.get(), entriesToExclude);\r\n        } else {\r\n            pathMap = getZipFilePaths(zip, relativePath, entriesToExclude);\r\n        }\r\n        for (SortedMap.Entry<Path, ZipArchiveEntry> p : new ArrayList(pathMap.entrySet())) {\r\n            if (!isTopLevel(p.getKey(), pathMap)) {\r\n                fillIntermediatePaths(p.getKey(), pathMap);\r\n            }\r\n        }\r\n        DirectoryCreator creator = new DirectoryCreator(filesystem);\r\n        for (SortedMap.Entry<Path, ZipArchiveEntry> p : pathMap.entrySet()) {\r\n            Path target = p.getKey();\r\n            ZipArchiveEntry entry = p.getValue();\r\n            if (entry.isDirectory()) {\r\n                extractDirectory(existingFileMode, pathMap, creator, target);\r\n            } else {\r\n                extractFile(filesWritten, zip, creator, target, entry);\r\n            }\r\n        }\r\n    }\r\n    return filesWritten.build();\r\n}"
}, {
	"Path": "com.facebook.buck.core.rules.impl.AbstractBuildRule.injectFields",
	"Comment": "allows setting the fields after creation. should only be used when deserializing.",
	"Method": "void injectFields(AbstractBuildRule rule,ProjectFilesystem filesystem,BuildTarget target){\r\n    setField(\"projectFilesystem\", rule, filesystem);\r\n    setField(\"buildTarget\", rule, target);\r\n    setField(\"typeSupplier\", rule, MoreSuppliers.memoize(rule::getTypeForClass));\r\n    setField(\"hashCode\", rule, rule.computeHashCode());\r\n}"
}, {
	"Path": "com.facebook.buck.query.QueryExpression.getTargets",
	"Comment": "returns a set of all targets referenced from literals within this query expression.",
	"Method": "ImmutableSet<QueryTarget> getTargets(QueryEnvironment env){\r\n    QueryTargetCollector collector = new QueryTargetCollector(env);\r\n    traverse(collector);\r\n    return collector.getTargets();\r\n}"
}, {
	"Path": "com.android.dx.cf.code.ByteCatchList.listFor",
	"Comment": "gets the list of items active at the given address. the result isautomatically made immutable.",
	"Method": "ByteCatchList listFor(int pc){\r\n    int sz = size();\r\n    Item[] resultArr = new Item[sz];\r\n    int resultSz = 0;\r\n    for (int i = 0; i < sz; i++) {\r\n        Item one = get(i);\r\n        if (one.covers(pc) && typeNotFound(one, resultArr, resultSz)) {\r\n            resultArr[resultSz] = one;\r\n            resultSz++;\r\n        }\r\n    }\r\n    if (resultSz == 0) {\r\n        return EMPTY;\r\n    }\r\n    ByteCatchList result = new ByteCatchList(resultSz);\r\n    for (int i = 0; i < resultSz; i++) {\r\n        result.set(i, resultArr[i]);\r\n    }\r\n    result.setImmutable();\r\n    return result;\r\n}"
}, {
	"Path": "com.android.dx.dex.code.BlockAddresses.getStart",
	"Comment": "gets the instance for the start of the block with the given label.",
	"Method": "CodeAddress getStart(BasicBlock block,CodeAddress getStart,int label){\r\n    return starts[label];\r\n}"
}, {
	"Path": "com.facebook.buck.features.d.DDescriptionUtils.createBuildTargetForFile",
	"Comment": "creates a buildtarget, based on an existing build target, but flavored with a cxxplatform andan additional flavor created by combining a prefix and an output file name.",
	"Method": "BuildTarget createBuildTargetForFile(BuildTarget existingTarget,String flavorPrefix,String fileName,CxxPlatform cxxPlatform){\r\n    return existingTarget.withAppendedFlavors(cxxPlatform.getFlavor(), InternalFlavor.of(flavorPrefix + Flavor.replaceInvalidCharacters(fileName)));\r\n}"
}, {
	"Path": "com.android.dx.dex.code.DalvInsnList.makeImmutable",
	"Comment": "constructs and returns an immutable instance whose elements areidentical to the ones in the given list, in the same order.",
	"Method": "DalvInsnList makeImmutable(ArrayList<DalvInsn> list,int regCount){\r\n    int size = list.size();\r\n    DalvInsnList result = new DalvInsnList(size, regCount);\r\n    for (int i = 0; i < size; i++) {\r\n        result.set(i, list.get(i));\r\n    }\r\n    result.setImmutable();\r\n    return result;\r\n}"
}, {
	"Path": "com.android.dx.dex.file.MethodIdsSection.indexOf",
	"Comment": "gets the index of the given reference, which must have been addedto this instance.",
	"Method": "int indexOf(CstBaseMethodRef ref){\r\n    if (ref == null) {\r\n        throw new NullPointerException(\"ref == null\");\r\n    }\r\n    throwIfNotPrepared();\r\n    MethodIdItem item = methodIds.get(ref);\r\n    if (item == null) {\r\n        throw new IllegalArgumentException(\"not found\");\r\n    }\r\n    return item.getIndex();\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.toolchain.DebugSectionFinder.findElf",
	"Comment": "locate, if any, the debug sections in the elf file represented by the given buffer.",
	"Method": "ImmutableMap<String, DebugSection> findElf(ByteBuffer buffer){\r\n    ImmutableMap.Builder<String, DebugSection> debugSectionsBuilder = ImmutableMap.builder();\r\n    Elf elf = new Elf(buffer);\r\n    for (int i = 0; i < elf.getNumberOfSections(); i++) {\r\n        ElfSection section = elf.getSectionByIndex(i);\r\n        String name = elf.getSectionName(section.header);\r\n        ImmutableSet<DebugSectionProperty> properties = ELF_DEBUG_SECTIONS.get(name);\r\n        if (properties != null) {\r\n            buffer.position((int) section.header.sh_off);\r\n            ByteBuffer body = buffer.slice();\r\n            body.limit((int) section.header.sh_size);\r\n            debugSectionsBuilder.put(name, new DebugSection(properties, body));\r\n        }\r\n    }\r\n    return debugSectionsBuilder.build();\r\n}"
}, {
	"Path": "com.facebook.buck.io.filesystem.impl.DefaultProjectFilesystem.deleteRecursivelyIfExists",
	"Comment": "recursively delete everything under the specified path. ignore the failure if the file at thespecified path does not exist.",
	"Method": "void deleteRecursivelyIfExists(Path pathRelativeToProjectRoot){\r\n    MostFiles.deleteRecursivelyIfExists(resolve(pathRelativeToProjectRoot));\r\n}"
}, {
	"Path": "com.facebook.buck.util.SimpleProcessListener.getStderr",
	"Comment": "gets the entire contents of stderr sent by the process. only call this after the process hasexited.",
	"Method": "String getStderr(){\r\n    Preconditions.checkState(process != null, \"Process didn't start yet\");\r\n    Preconditions.checkState(!process.isRunning(), \"Process must not still be running\");\r\n    return stderr.toString();\r\n}"
}, {
	"Path": "com.facebook.buck.testrunner.DelegateRunNotifier.onTestRunFinished",
	"Comment": "performs any cleanup that we need to do as a result of the test run being complete.",
	"Method": "void onTestRunFinished(){\r\n    timer.cancel();\r\n}"
}, {
	"Path": "com.facebook.buck.core.model.actiongraph.computation.AbstractActionGraphConfig.getShouldInstrumentActionGraph",
	"Comment": "whether to instrument the action graph and record performance",
	"Method": "boolean getShouldInstrumentActionGraph(){\r\n    return getDelegate().getBooleanValue(\"instrumentation\", \"action_graph\", false);\r\n}"
}, {
	"Path": "com.facebook.buck.io.file.LazyPath.getUnchecked",
	"Comment": "does not invoke the path supplier, assuming it was invoked previously.",
	"Method": "Path getUnchecked(){\r\n    return Objects.requireNonNull(path, \"get() method must be called first to set initial value before invoking getUnchecked()\");\r\n}"
}, {
	"Path": "com.facebook.buck.testrunner.InstrumentationTestRunner.createAdb",
	"Comment": "creates connection to adb and waits for this connection to be initialized and receive initiallist of devices.",
	"Method": "AndroidDebugBridge createAdb(){\r\n    AndroidDebugBridge.initIfNeeded(false);\r\n    AndroidDebugBridge adb = AndroidDebugBridge.createBridge(this.adbExecutablePath, false);\r\n    if (adb == null) {\r\n        System.err.println(\"Failed to connect to adb. Make sure adb server is running.\");\r\n        return null;\r\n    }\r\n    long start = System.currentTimeMillis();\r\n    while (!isAdbInitialized(adb)) {\r\n        long timeLeft = start + ADB_CONNECT_TIMEOUT_MS - System.currentTimeMillis();\r\n        if (timeLeft <= 0) {\r\n            break;\r\n        }\r\n        Thread.sleep(ADB_CONNECT_TIME_STEP_MS);\r\n    }\r\n    return isAdbInitialized(adb) ? adb : null;\r\n}"
}, {
	"Path": "com.facebook.buck.core.select.Selector.hasDefaultCondition",
	"Comment": "returns whether or not this selector has a default condition.",
	"Method": "boolean hasDefaultCondition(){\r\n    return hasDefaultCondition;\r\n}"
}, {
	"Path": "com.android.dx.cf.code.BaseMachine.getLocalInfo",
	"Comment": "gets whether the loaded local has info in the local variable table.",
	"Method": "boolean getLocalInfo(){\r\n    return localInfo;\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.CxxLinkableEnhancer.deriveSupplementaryOutputPathsFromMainOutputPath",
	"Comment": "derive supplementary output paths based on the main output path.",
	"Method": "ImmutableMap<String, Path> deriveSupplementaryOutputPathsFromMainOutputPath(Path output,Iterable<String> supplementaryOutputNames){\r\n    return Streams.stream(supplementaryOutputNames).collect(ImmutableMap.toImmutableMap(name -> name, name -> output.getParent().resolve(output.getFileName() + \"-\" + name)));\r\n}"
}, {
	"Path": "com.facebook.buck.parser.ParserWithConfigurableAttributes.getTargetNodeRawAttributes",
	"Comment": "this implementation collects raw attributes of a target node and resolves configurableattributes.",
	"Method": "SortedMap<String, Object> getTargetNodeRawAttributes(PerBuildState state,Cell cell,TargetNode<?> targetNode){\r\n    BuildTarget buildTarget = targetNode.getBuildTarget();\r\n    Cell owningCell = cell.getCell(buildTarget);\r\n    BuildFileManifest buildFileManifest = getTargetNodeRawAttributes(state, owningCell, cell.getAbsolutePathToBuildFile(buildTarget));\r\n    String shortName = buildTarget.getShortName();\r\n    if (!buildFileManifest.getTargets().containsKey(shortName)) {\r\n        return null;\r\n    }\r\n    Map<String, Object> attributes = buildFileManifest.getTargets().get(shortName);\r\n    SortedMap<String, Object> convertedAttributes = copyWithResolvingConfigurableAttributes(state, cell, buildTarget, attributes);\r\n    convertedAttributes.put(InternalTargetAttributeNames.DIRECT_DEPENDENCIES, targetNode.getParseDeps().stream().map(Object::toString).collect(ImmutableList.toImmutableList()));\r\n    return convertedAttributes;\r\n}"
}, {
	"Path": "com.facebook.buck.util.MoreIterables.forEachPair",
	"Comment": "provides convenient consumption of a pair of iterables of the same length.",
	"Method": "void forEachPair(Iterable<L> left,Iterable<R> right,BiConsumer<? super L, ? super R> consumer){\r\n    Iterator<L> leftIter = left.iterator();\r\n    Iterator<R> rightIter = right.iterator();\r\n    while (leftIter.hasNext() && rightIter.hasNext()) {\r\n        consumer.accept(leftIter.next(), rightIter.next());\r\n    }\r\n    Preconditions.checkState(!leftIter.hasNext() && !rightIter.hasNext());\r\n}"
}, {
	"Path": "com.android.manifmerger.XmlNode.printPosition",
	"Comment": "returns the position of this attribute in the original xml file. this may return an invalidlocation as this xml fragment does not exist in any xml file but is the temporary resultof the merging process.",
	"Method": "String printPosition(){\r\n    return getSourceFilePosition().print(true);\r\n}"
}, {
	"Path": "com.facebook.buck.features.project.intellij.IjProjectWriter.updateModulesIndex",
	"Comment": "update the modules.xml file with any new modules from the given set",
	"Method": "void updateModulesIndex(ImmutableSet<IjModule> modulesEdited){\r\n    final Set<ModuleIndexEntry> existingModules = modulesParser.getAllModules(projectFilesystem.newFileInputStream(getIdeaConfigDir().resolve(\"modules.xml\")));\r\n    final Set<Path> existingModuleFilepaths = existingModules.stream().map(ModuleIndexEntry::getFilePath).map(MorePaths::pathWithUnixSeparators).map(Paths::get).collect(ImmutableSet.toImmutableSet());\r\n    ImmutableSet<Path> remainingModuleFilepaths = modulesEdited.stream().map(projectPaths::getModuleImlFilePath).map(MorePaths::pathWithUnixSeparators).map(Paths::get).filter(modulePath -> !existingModuleFilepaths.contains(modulePath)).collect(ImmutableSet.toImmutableSet());\r\n    ImmutableSortedSet.Builder<ModuleIndexEntry> finalModulesBuilder = ImmutableSortedSet.orderedBy(Comparator.<ModuleIndexEntry>naturalOrder());\r\n    finalModulesBuilder.addAll(existingModules);\r\n    remainingModuleFilepaths.forEach(modulePath -> finalModulesBuilder.add(ModuleIndexEntry.builder().setFilePath(projectPaths.getProjectRelativePath(modulePath)).setFileUrl(getUrl(projectPaths.getProjectQualifiedPath(modulePath))).setGroup(projectConfig.getModuleGroupName()).build()));\r\n    writeModulesIndex(finalModulesBuilder.build());\r\n}"
}, {
	"Path": "com.android.dx.dex.DexOptions.getMagic",
	"Comment": "gets the dex file magic number corresponding to this instance.",
	"Method": "String getMagic(){\r\n    return DexFormat.apiToMagic(targetApiLevel);\r\n}"
}, {
	"Path": "com.facebook.buck.util.unarchive.Unzip.getZipFilePathsStrippingPrefix",
	"Comment": "get a listing of all files in a zip file that start with a prefix, ignore others",
	"Method": "SortedMap<Path, ZipArchiveEntry> getZipFilePathsStrippingPrefix(ZipFile zip,Path relativePath,Path prefix,PatternsMatcher entriesToExclude){\r\n    SortedMap<Path, ZipArchiveEntry> pathMap = new TreeMap();\r\n    for (ZipArchiveEntry entry : Collections.list(zip.getEntries())) {\r\n        String entryName = entry.getName();\r\n        if (entriesToExclude.matchesAny(entryName)) {\r\n            continue;\r\n        }\r\n        Path entryPath = Paths.get(entryName);\r\n        if (entryPath.startsWith(prefix)) {\r\n            Path target = relativePath.resolve(prefix.relativize(entryPath)).normalize();\r\n            pathMap.put(target, entry);\r\n        }\r\n    }\r\n    return pathMap;\r\n}"
}, {
	"Path": "com.facebook.buck.android.exopackage.RealAndroidDeviceTest.testFailedDeviceInstallWithReason",
	"Comment": "verify that if failure reason is returned, installation is marked as failed.",
	"Method": "void testFailedDeviceInstallWithReason(){\r\n    File apk = new File(\"/some/file.apk\");\r\n    TestDevice device = new TestDevice() {\r\n        @Override\r\n        public void installPackage(String s, boolean b, String... strings) throws InstallException {\r\n            throw new InstallException(\"[SOME REASON]\");\r\n        }\r\n    };\r\n    device.setSerialNumber(\"serial#1\");\r\n    device.setName(\"testDevice\");\r\n    assertFalse(createAndroidDevice(device).installApkOnDevice(apk, false, false, false));\r\n}"
}, {
	"Path": "com.facebook.buck.android.exopackage.RealAndroidDeviceTest.testFailedDeviceInstallWithReason",
	"Comment": "verify that if failure reason is returned, installation is marked as failed.",
	"Method": "void testFailedDeviceInstallWithReason(){\r\n    throw new InstallException(\"[SOME REASON]\");\r\n}"
}, {
	"Path": "com.android.dx.dex.code.InsnFormat.unsignedFitsInNibble",
	"Comment": "helper method to determine if an unsigned int value fits in a nibble.",
	"Method": "boolean unsignedFitsInNibble(int value){\r\n    return value == (value & 0xf);\r\n}"
}, {
	"Path": "com.facebook.buck.util.AnsiEnvironmentChecking.environmentSupportsAnsiEscapes",
	"Comment": "returns true if the environment supports ansi escape sequences, false otherwise.",
	"Method": "boolean environmentSupportsAnsiEscapes(Platform platform,Map<String, String> environment){\r\n    boolean isWindows = (platform == Platform.WINDOWS);\r\n    boolean isDumbTerminal = Objects.equals(environment.get(TERM_ENV), \"dumb\");\r\n    String nailgunStdoutIsTtyEnv = environment.get(NAILGUN_STDOUT_ISTTY_ENV);\r\n    String nailgunStderrIsTtyEnv = environment.get(NAILGUN_STDERR_ISTTY_ENV);\r\n    boolean nailgunEnvPresent = (nailgunStdoutIsTtyEnv != null && nailgunStderrIsTtyEnv != null);\r\n    boolean nailgunStdoutIsTty = Objects.equals(nailgunStdoutIsTtyEnv, \"1\");\r\n    boolean nailgunStderrIsTty = Objects.equals(nailgunStderrIsTtyEnv, \"1\");\r\n    boolean outputIsTty;\r\n    if (nailgunEnvPresent) {\r\n        outputIsTty = nailgunStdoutIsTty && nailgunStderrIsTty;\r\n    } else {\r\n        outputIsTty = System.console() != null;\r\n    }\r\n    boolean result = !isDumbTerminal && outputIsTty;\r\n    LOG.verbose(\"windows=%s dumbterm=%s nailgun=%s ng stdout=%s ng stderr=%s output tty=%s result=%s\", isWindows, isDumbTerminal, nailgunEnvPresent, nailgunStdoutIsTty, nailgunStderrIsTty, outputIsTty, result);\r\n    return result;\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.MinionLocalBuildStateTracker.recordUploadedTarget",
	"Comment": "once a target has been built and uploaded to the cache, it is now safe to signal to thecoordinator that the target is finished.",
	"Method": "void recordUploadedTarget(String target){\r\n    Preconditions.checkArgument(knownTargets.contains(target));\r\n    Preconditions.checkArgument(!uploadedTargets.contains(target));\r\n    uploadedTargets.add(target);\r\n    uploadedTargetsToSignal.add(target);\r\n}"
}, {
	"Path": "com.android.dx.dex.file.ClassDataItem.getMethods",
	"Comment": "gets all the methods in this class. the returned list is not linkedin any way to the underlying lists contained in this instance, butthe objects contained in the list are shared.",
	"Method": "ArrayList<EncodedMethod> getMethods(){\r\n    int sz = directMethods.size() + virtualMethods.size();\r\n    ArrayList<EncodedMethod> result = new ArrayList<EncodedMethod>(sz);\r\n    result.addAll(directMethods);\r\n    result.addAll(virtualMethods);\r\n    return result;\r\n}"
}, {
	"Path": "com.android.common.xml.AndroidManifest.getInstrumentationRunnerXPath",
	"Comment": "returns the xpath expression for the instrumentation runner",
	"Method": "String getInstrumentationRunnerXPath(){\r\n    return \"/\" + NODE_MANIFEST + \"/\" + NODE_INSTRUMENTATION + \"/@\" + AndroidXPathFactory.DEFAULT_NS_PREFIX + \":\" + ATTRIBUTE_NAME;\r\n}"
}, {
	"Path": "com.android.dx.cf.attrib.BaseParameterAnnotations.getParameterAnnotations",
	"Comment": "gets the list of annotation lists associated with this instance.",
	"Method": "AnnotationsList getParameterAnnotations(){\r\n    return parameterAnnotations;\r\n}"
}, {
	"Path": "com.facebook.buck.features.rust.RustBuckConfig.getRustCompilerFlags",
	"Comment": "get common set of rustc flags. these are used for all rules that invoke rustc.",
	"Method": "ImmutableList<String> getRustCompilerFlags(String platform){\r\n    return getCompilerFlags(platform, RUSTC_FLAGS);\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.ThriftCoordinatorServer.exportChromeTraceIfSuccess",
	"Comment": "exports the stampede distbuild chrome trace to argument file.",
	"Method": "boolean exportChromeTraceIfSuccess(Path traceFilePath){\r\n    return exportChromeTraceIfSuccessInternal(traceFilePath, getExitState(), chromeTraceTracker);\r\n}"
}, {
	"Path": "com.facebook.buck.cli.TestRunningTest.testUnifiedSourceFile",
	"Comment": "if the source paths specified are from the new unified source tmp then we should return thecorrect source tmp corresponding to the unified source path.",
	"Method": "void testUnifiedSourceFile(){\r\n    Path pathToNonGenFile = Paths.get(\"java/package/src/SourceFile1.java\");\r\n    BuildTarget javaLibraryTarget = BuildTargetFactory.newInstance(\"//foo:bar\");\r\n    TargetNode<JavaLibraryDescriptionArg> javaLibraryNode = JavaLibraryBuilder.createBuilder(javaLibraryTarget).addSrc(pathToNonGenFile).build();\r\n    TargetGraph targetGraph = TargetGraphFactory.newInstance(javaLibraryNode);\r\n    ActionGraphBuilder graphBuilder = new TestActionGraphBuilder(targetGraph);\r\n    SourcePathRuleFinder ruleFinder = new SourcePathRuleFinder(graphBuilder);\r\n    SourcePathResolver resolver = DefaultSourcePathResolver.from(ruleFinder);\r\n    JavaLibrary javaLibrary = (JavaLibrary) graphBuilder.requireRule(javaLibraryTarget);\r\n    DefaultJavaPackageFinder defaultJavaPackageFinder = new DefaultJavaPackageFinder(pathsFromRoot, pathElements);\r\n    ImmutableSet<String> result = TestRunning.getPathToSourceFolders(javaLibrary, resolver, ruleFinder, defaultJavaPackageFinder);\r\n    assertEquals(\"All non-generated source files are under one source tmp.\", ImmutableSet.of(\"java/\"), result);\r\n}"
}, {
	"Path": "com.facebook.buck.util.zip.Zip.walkBaseDirectoryToCreateEntries",
	"Comment": "walks the file tree rooted in basedirectory to create zip entries",
	"Method": "void walkBaseDirectoryToCreateEntries(ProjectFilesystem filesystem,Map<String, Pair<CustomZipEntry, Optional<Path>>> entries,Path baseDir,ImmutableSet<Path> paths,boolean junkPaths,ZipCompressionLevel compressionLevel){\r\n    FileVisitor<Path> pathFileVisitor = new SimpleFileVisitor<Path>() {\r\n        private boolean isSkipFile(Path file) {\r\n            return !paths.isEmpty() && !paths.contains(file);\r\n        }\r\n        private String getEntryName(Path path) {\r\n            Path relativePath = junkPaths ? path.getFileName() : baseDir.relativize(path);\r\n            return MorePaths.pathWithUnixSeparators(relativePath);\r\n        }\r\n        private CustomZipEntry getZipEntry(String entryName, Path path, BasicFileAttributes attr) throws IOException {\r\n            boolean isDirectory = filesystem.isDirectory(path);\r\n            if (isDirectory) {\r\n                entryName += \"/\";\r\n            }\r\n            CustomZipEntry entry = new CustomZipEntry(entryName);\r\n            entry.setFakeTime();\r\n            entry.setCompressionLevel(isDirectory ? ZipCompressionLevel.NONE.getValue() : compressionLevel.getValue());\r\n            if (entry.getMethod() == ZipEntry.STORED && !isDirectory) {\r\n                entry.setSize(attr.size());\r\n                entry.setCompressedSize(attr.size());\r\n                entry.setCrc(new ByteSource() {\r\n                    @Override\r\n                    public InputStream openStream() throws IOException {\r\n                        return filesystem.newFileInputStream(path);\r\n                    }\r\n                }.hash(Hashing.crc32()).padToLong());\r\n            }\r\n            long externalAttributes = filesystem.getFileAttributesForZipEntry(path);\r\n            LOG.verbose(\"Setting mode for entry %s path %s to 0xX\", entryName, path, externalAttributes);\r\n            entry.setExternalAttributes(externalAttributes);\r\n            return entry;\r\n        }\r\n        @Override\r\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\r\n            if (!isSkipFile(file)) {\r\n                CustomZipEntry entry = getZipEntry(getEntryName(file), file, attrs);\r\n                entries.put(entry.getName(), new Pair(entry, Optional.of(file)));\r\n            }\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n        @Override\r\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\r\n            if (!dir.equals(baseDir) && !isSkipFile(dir)) {\r\n                CustomZipEntry entry = getZipEntry(getEntryName(dir), dir, attrs);\r\n                entries.put(entry.getName(), new Pair(entry, Optional.empty()));\r\n            }\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n    };\r\n    filesystem.walkRelativeFileTree(baseDir, pathFileVisitor);\r\n}"
}, {
	"Path": "com.facebook.buck.util.zip.Zip.walkBaseDirectoryToCreateEntries",
	"Comment": "walks the file tree rooted in basedirectory to create zip entries",
	"Method": "void walkBaseDirectoryToCreateEntries(ProjectFilesystem filesystem,Map<String, Pair<CustomZipEntry, Optional<Path>>> entries,Path baseDir,ImmutableSet<Path> paths,boolean junkPaths,ZipCompressionLevel compressionLevel){\r\n    return !paths.isEmpty() && !paths.contains(file);\r\n}"
}, {
	"Path": "com.facebook.buck.util.zip.Zip.walkBaseDirectoryToCreateEntries",
	"Comment": "walks the file tree rooted in basedirectory to create zip entries",
	"Method": "void walkBaseDirectoryToCreateEntries(ProjectFilesystem filesystem,Map<String, Pair<CustomZipEntry, Optional<Path>>> entries,Path baseDir,ImmutableSet<Path> paths,boolean junkPaths,ZipCompressionLevel compressionLevel){\r\n    Path relativePath = junkPaths ? path.getFileName() : baseDir.relativize(path);\r\n    return MorePaths.pathWithUnixSeparators(relativePath);\r\n}"
}, {
	"Path": "com.facebook.buck.util.zip.Zip.walkBaseDirectoryToCreateEntries",
	"Comment": "walks the file tree rooted in basedirectory to create zip entries",
	"Method": "void walkBaseDirectoryToCreateEntries(ProjectFilesystem filesystem,Map<String, Pair<CustomZipEntry, Optional<Path>>> entries,Path baseDir,ImmutableSet<Path> paths,boolean junkPaths,ZipCompressionLevel compressionLevel){\r\n    boolean isDirectory = filesystem.isDirectory(path);\r\n    if (isDirectory) {\r\n        entryName += \"/\";\r\n    }\r\n    CustomZipEntry entry = new CustomZipEntry(entryName);\r\n    entry.setFakeTime();\r\n    entry.setCompressionLevel(isDirectory ? ZipCompressionLevel.NONE.getValue() : compressionLevel.getValue());\r\n    if (entry.getMethod() == ZipEntry.STORED && !isDirectory) {\r\n        entry.setSize(attr.size());\r\n        entry.setCompressedSize(attr.size());\r\n        entry.setCrc(new ByteSource() {\r\n            @Override\r\n            public InputStream openStream() throws IOException {\r\n                return filesystem.newFileInputStream(path);\r\n            }\r\n        }.hash(Hashing.crc32()).padToLong());\r\n    }\r\n    long externalAttributes = filesystem.getFileAttributesForZipEntry(path);\r\n    LOG.verbose(\"Setting mode for entry %s path %s to 0xX\", entryName, path, externalAttributes);\r\n    entry.setExternalAttributes(externalAttributes);\r\n    return entry;\r\n}"
}, {
	"Path": "com.facebook.buck.util.zip.Zip.walkBaseDirectoryToCreateEntries",
	"Comment": "walks the file tree rooted in basedirectory to create zip entries",
	"Method": "void walkBaseDirectoryToCreateEntries(ProjectFilesystem filesystem,Map<String, Pair<CustomZipEntry, Optional<Path>>> entries,Path baseDir,ImmutableSet<Path> paths,boolean junkPaths,ZipCompressionLevel compressionLevel){\r\n    return filesystem.newFileInputStream(path);\r\n}"
}, {
	"Path": "com.facebook.buck.util.zip.Zip.walkBaseDirectoryToCreateEntries",
	"Comment": "walks the file tree rooted in basedirectory to create zip entries",
	"Method": "void walkBaseDirectoryToCreateEntries(ProjectFilesystem filesystem,Map<String, Pair<CustomZipEntry, Optional<Path>>> entries,Path baseDir,ImmutableSet<Path> paths,boolean junkPaths,ZipCompressionLevel compressionLevel){\r\n    if (!isSkipFile(file)) {\r\n        CustomZipEntry entry = getZipEntry(getEntryName(file), file, attrs);\r\n        entries.put(entry.getName(), new Pair(entry, Optional.of(file)));\r\n    }\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "com.facebook.buck.util.zip.Zip.walkBaseDirectoryToCreateEntries",
	"Comment": "walks the file tree rooted in basedirectory to create zip entries",
	"Method": "void walkBaseDirectoryToCreateEntries(ProjectFilesystem filesystem,Map<String, Pair<CustomZipEntry, Optional<Path>>> entries,Path baseDir,ImmutableSet<Path> paths,boolean junkPaths,ZipCompressionLevel compressionLevel){\r\n    if (!dir.equals(baseDir) && !isSkipFile(dir)) {\r\n        CustomZipEntry entry = getZipEntry(getEntryName(dir), dir, attrs);\r\n        entries.put(entry.getName(), new Pair(entry, Optional.empty()));\r\n    }\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "com.facebook.buck.util.zip.ZipScrubber.localEntryName",
	"Comment": "read the name of a zip file from a local entry. useful for debugging.",
	"Method": "String localEntryName(ByteBuffer entry){\r\n    byte[] nameBytes = new byte[entry.getShort(ZipEntry.LOCNAM)];\r\n    ((ByteBuffer) ((Buffer) entry.slice()).position(ZipEntry.LOCHDR)).get(nameBytes);\r\n    return new String(nameBytes);\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.PerfTimesEventListener.getTimeDifferenceSinceLastEventToEvent",
	"Comment": "helper method, returns the time difference from last invocation of this method.",
	"Method": "long getTimeDifferenceSinceLastEventToEvent(AbstractBuckEvent event){\r\n    long diff = event.getTimestamp() - buildPhasesLastEvent.get();\r\n    buildPhasesLastEvent.set(event.getTimestamp());\r\n    return diff;\r\n}"
}, {
	"Path": "com.facebook.buck.query.Lexer.tokenize",
	"Comment": "performs tokenization of the character buffer of file contents provided to the constructor.",
	"Method": "void tokenize(){\r\n    while (pos < buffer.length) {\r\n        char c = buffer[pos];\r\n        pos++;\r\n        switch(c) {\r\n            case '(':\r\n                {\r\n                    addToken(new Token(TokenKind.LPAREN));\r\n                    break;\r\n                }\r\n            case ')':\r\n                {\r\n                    addToken(new Token(TokenKind.RPAREN));\r\n                    break;\r\n                }\r\n            case ',':\r\n                {\r\n                    addToken(new Token(TokenKind.COMMA));\r\n                    break;\r\n                }\r\n            case '+':\r\n                {\r\n                    addToken(new Token(TokenKind.PLUS));\r\n                    break;\r\n                }\r\n            case '-':\r\n                {\r\n                    addToken(new Token(TokenKind.MINUS));\r\n                    break;\r\n                }\r\n            case '=':\r\n                {\r\n                    addToken(new Token(TokenKind.EQUALS));\r\n                    break;\r\n                }\r\n            case '^':\r\n                {\r\n                    addToken(new Token(TokenKind.CARET));\r\n                    break;\r\n                }\r\n            case '\\n':\r\n            case ' ':\r\n            case '\\t':\r\n            case '\\r':\r\n                {\r\n                    break;\r\n                }\r\n            case '\\'':\r\n            case '\\\"':\r\n                {\r\n                    addToken(quotedWord(c));\r\n                    break;\r\n                }\r\n            default:\r\n                {\r\n                    addToken(wordOrKeyword());\r\n                    break;\r\n                }\r\n        }\r\n    }\r\n    addToken(new Token(TokenKind.EOF));\r\n}"
}, {
	"Path": "com.android.dx.dex.file.OffsettedItem.getRelativeOffset",
	"Comment": "gets the relative item offset. the offset is from the start ofthe section which the instance was written to.",
	"Method": "int getRelativeOffset(){\r\n    if (offset < 0) {\r\n        throw new RuntimeException(\"offset not yet known\");\r\n    }\r\n    return offset;\r\n}"
}, {
	"Path": "com.facebook.buck.remoteexecution.CasBlobUploadEvent.sendEvent",
	"Comment": "send the started and returns a scoped object that sends the finished event.",
	"Method": "Scope sendEvent(BuckEventBus eventBus,int blobCount,long sizeBytes){\r\n    final Started startedEvent = new Started(blobCount, sizeBytes);\r\n    eventBus.post(startedEvent);\r\n    return () -> eventBus.post(new Finished(startedEvent));\r\n}"
}, {
	"Path": "com.android.dex.DexFormat.apiToMagic",
	"Comment": "returns the magic number corresponding to the given target api level.",
	"Method": "String apiToMagic(int targetApiLevel){\r\n    String version;\r\n    if (targetApiLevel >= API_CURRENT) {\r\n        version = VERSION_CURRENT;\r\n    } else {\r\n        version = VERSION_FOR_API_13;\r\n    }\r\n    return MAGIC_PREFIX + version + MAGIC_SUFFIX;\r\n}"
}, {
	"Path": "com.facebook.buck.cli.DaemonIntegrationTest.whenClientTimeoutDetectedThenMainThreadIsInterrupted",
	"Comment": "verifies that a client timeout will be detected by a nailgun nginputstream reading from ablocking heartbeat stream.",
	"Method": "void whenClientTimeoutDetectedThenMainThreadIsInterrupted(){\r\n    long timeoutMillis = 100;\r\n    ProjectWorkspace workspace = TestDataHelper.createProjectWorkspaceForScenario(this, \"exclusive_execution\", tmp);\r\n    workspace.setUp();\r\n    Thread.currentThread().setName(\"Test\");\r\n    try (TestContext context = new TestContext(EnvVariablesProvider.getSystemEnv(), timeoutMillis)) {\r\n        Thread thread = Thread.currentThread();\r\n        context.addClientListener(reason -> {\r\n            Threads.interruptThread(thread);\r\n        });\r\n        Thread.sleep(1000);\r\n        fail(\"Should have been interrupted.\");\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.util.config.Config.getMacroPreserver",
	"Comment": "macro.so, add special expanders to preserve these until they get fixed.",
	"Method": "MacroReplacer<String> getMacroPreserver(String name){\r\n    return input -> String.format(\"$(%s %s)\", name, Joiner.on(' ').join(input.getMacroInput()));\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.toolchain.nativelink.NativeLinkables.getNativeLinkables",
	"Comment": "extract from the dependency graph all the libraries which must be considered for linking.traversal proceeds depending on whether each dependency is to be statically or dynamicallylinked.",
	"Method": "ImmutableList<NativeLinkable> getNativeLinkables(CxxPlatform cxxPlatform,ActionGraphBuilder graphBuilder,Iterable<? extends NativeLinkable> inputs,Linker.LinkableDepType linkStyle,Predicate<? super NativeLinkable> traverse,ImmutableList<NativeLinkable> getNativeLinkables,CxxPlatform cxxPlatform,ActionGraphBuilder graphBuilder,Iterable<? extends NativeLinkable> inputs,Linker.LinkableDepType linkStyle){\r\n    return getNativeLinkables(cxxPlatform, graphBuilder, inputs, linkStyle, x -> true);\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.JsonMatcher.matchJsonObjects",
	"Comment": "static method which tries to match 2 jsonnode objects recursively.",
	"Method": "boolean matchJsonObjects(String path,JsonNode expected,JsonNode actual,Description description){\r\n    if (expected != null && actual != null && expected.isObject()) {\r\n        if (!actual.isObject()) {\r\n            description.appendText(String.format(\"the JsonNodeType is not OBJECT at path [%s]\", path));\r\n            return false;\r\n        }\r\n        HashSet<String> expectedFields = Sets.newHashSet(expected.fieldNames());\r\n        HashSet<String> actualFields = Sets.newHashSet(actual.fieldNames());\r\n        for (String field : expectedFields) {\r\n            if (!actualFields.contains(field)) {\r\n                description.appendText(String.format(\"expecting field [%s] at path [%s]\", field, path));\r\n                return false;\r\n            }\r\n            if (!matchJsonObjects(path + \"/\" + field, expected.get(field), actual.get(field), description)) {\r\n                return false;\r\n            }\r\n        }\r\n        if (!new HashSet().equals(Sets.difference(actualFields, expectedFields))) {\r\n            description.appendText(String.format(\"found unexpected fields %s at path [%s]\", Sets.difference(actualFields, expectedFields).toString(), path));\r\n            return false;\r\n        }\r\n    }\r\n    if (!expected.equals(actual)) {\r\n        description.appendText(String.format(\"mismatch at path [%s]\", path));\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.JavacFactory.create",
	"Comment": "returns either the defautl javac or one created from the provided args.",
	"Method": "Javac create(SourcePathRuleFinder ruleFinder,JvmLibraryArg args){\r\n    if (args != null) {\r\n        JavacSpec spec = args.getJavacSpec(ruleFinder);\r\n        if (spec != null) {\r\n            return spec.getJavacProvider().resolve(ruleFinder);\r\n        }\r\n    }\r\n    return javacProvider.get().resolve(ruleFinder);\r\n}"
}, {
	"Path": "com.facebook.buck.util.concurrent.ListeningMultiSemaphore.capResourceAmounts",
	"Comment": "we assume that if requested amounts are larger than we have in maximumvalues, then intentionwas to request all possible resources. this method caps the given resources to the maximumpossible value. without capping the deadlock will happen.",
	"Method": "ResourceAmounts capResourceAmounts(ResourceAmounts amounts){\r\n    return ResourceAmounts.of(Math.min(amounts.getCpu(), maximumValues.getCpu()), Math.min(amounts.getMemory(), maximumValues.getMemory()), Math.min(amounts.getDiskIO(), maximumValues.getDiskIO()), Math.min(amounts.getNetworkIO(), maximumValues.getNetworkIO()));\r\n}"
}, {
	"Path": "com.facebook.buck.io.filesystem.impl.DefaultProjectFilesystem.deleteFileAtPathIfExists",
	"Comment": "deletes a file specified by its path relative to the project root.ignores the failure if the file does not exist.",
	"Method": "boolean deleteFileAtPathIfExists(Path pathRelativeToProjectRoot){\r\n    return Files.deleteIfExists(getPathForRelativePath(pathRelativeToProjectRoot));\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.ThriftCoordinatorServer.checkBuildStatusIsNotTerminated",
	"Comment": "checks whether the buildstatus has not been set to terminated remotely.",
	"Method": "void checkBuildStatusIsNotTerminated(){\r\n    BuildJob buildJob = distBuildService.getCurrentBuildJobState(stampedeId);\r\n    BuildStatus status = buildJob.getStatus();\r\n    if (!buildJob.isSetStatus() || !BuildStatusUtil.isTerminalBuildStatus(status)) {\r\n        return;\r\n    }\r\n    if (status == BuildStatus.FINISHED_SUCCESSFULLY) {\r\n        exitCodeFuture.complete(ExitState.setByServers(DistributedExitCode.SUCCESSFUL.getCode(), \"Build succeeded externally.\"));\r\n    } else {\r\n        exitCodeFuture.complete(ExitState.setByServers(DistributedExitCode.BUILD_FAILED_EXTERNALLY_EXIT_CODE.getCode(), \"Build failed externally.\"));\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.parser.AbstractParserConfig.getBuckPackageBoundaryExceptions",
	"Comment": "a list of absolute paths under which buck package boundary checks should not be performed.",
	"Method": "ImmutableList<Path> getBuckPackageBoundaryExceptions(){\r\n    return getDelegate().getOptionalPathList(\"project\", \"package_boundary_exceptions\", true).orElse(ImmutableList.of());\r\n}"
}, {
	"Path": "com.facebook.buck.util.trace.uploader.launcher.UploaderLauncher.uploadInBackground",
	"Comment": "upload chrome trace in background process which runs even after current process dies.",
	"Method": "void uploadInBackground(BuildId buildId,Path traceFilePath,String traceFileKind,URI traceUploadUri,Path logFile,CompressionType compressionType){\r\n    LOG.debug(\"Uploading build trace in the background. Upload will log to %s\", logFile);\r\n    String buckClasspath = BuckClasspath.getBuckClasspathFromEnvVarOrNull();\r\n    if (Strings.isNullOrEmpty(buckClasspath)) {\r\n        LOG.error(BuckClasspath.ENV_VAR_NAME + \" env var is not set. Will not upload the trace file.\");\r\n        return;\r\n    }\r\n    try {\r\n        String[] args = { \"java\", \"-cp\", buckClasspath, \"com.facebook.buck.util.trace.uploader.Main\", \"--buildId\", buildId.toString(), \"--traceFilePath\", traceFilePath.toString(), \"--traceFileKind\", traceFileKind, \"--baseUrl\", traceUploadUri.toString(), \"--log\", logFile.toString(), \"--compressionType\", compressionType.name() };\r\n        Runtime.getRuntime().exec(args);\r\n    } catch (IOException e) {\r\n        LOG.error(e, e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.httpserver.StreamingWebSocketServlet.tellAll",
	"Comment": "sends the message to all websockets that are currently connected.",
	"Method": "void tellAll(String eventName,String message){\r\n    for (MyWebSocket webSocket : connections) {\r\n        if (webSocket.isConnected() && webSocket.isSubscribedTo(eventName)) {\r\n            webSocket.getRemote().sendStringByFuture(message);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.core.model.targetgraph.TargetGraph.getSubgraph",
	"Comment": "get the subgraph of the the current graph containing the passed in roots and all of theirtransitive dependencies as nodes. edges between the included nodes are preserved.",
	"Method": "TargetGraph getSubgraph(Iterable<? extends TargetNode<? extends T>> roots){\r\n    MutableDirectedGraph<TargetNode<?>> subgraph = new MutableDirectedGraph();\r\n    Map<BuildTarget, TargetNode<?>> index = new HashMap();\r\n    new AbstractBreadthFirstTraversal<TargetNode<?>>(roots) {\r\n        @Override\r\n        public Iterable<TargetNode<?>> visit(TargetNode<?> node) {\r\n            subgraph.addNode(node);\r\n            MoreMaps.putCheckEquals(index, node.getBuildTarget(), node);\r\n            if (node.getBuildTarget().isFlavored()) {\r\n                BuildTarget unflavoredBuildTarget = node.getBuildTarget().withoutFlavors();\r\n                MoreMaps.putCheckEquals(index, unflavoredBuildTarget, targetsToNodes.get(unflavoredBuildTarget));\r\n            }\r\n            ImmutableSet<TargetNode<?>> dependencies = ImmutableSet.copyOf(getAll(node.getParseDeps()));\r\n            for (TargetNode<?> dependency : dependencies) {\r\n                subgraph.addEdge(node, dependency);\r\n            }\r\n            return dependencies;\r\n        }\r\n    }.start();\r\n    return new TargetGraph(subgraph, ImmutableMap.copyOf(index));\r\n}"
}, {
	"Path": "com.facebook.buck.core.model.targetgraph.TargetGraph.getSubgraph",
	"Comment": "get the subgraph of the the current graph containing the passed in roots and all of theirtransitive dependencies as nodes. edges between the included nodes are preserved.",
	"Method": "TargetGraph getSubgraph(Iterable<? extends TargetNode<? extends T>> roots){\r\n    subgraph.addNode(node);\r\n    MoreMaps.putCheckEquals(index, node.getBuildTarget(), node);\r\n    if (node.getBuildTarget().isFlavored()) {\r\n        BuildTarget unflavoredBuildTarget = node.getBuildTarget().withoutFlavors();\r\n        MoreMaps.putCheckEquals(index, unflavoredBuildTarget, targetsToNodes.get(unflavoredBuildTarget));\r\n    }\r\n    ImmutableSet<TargetNode<?>> dependencies = ImmutableSet.copyOf(getAll(node.getParseDeps()));\r\n    for (TargetNode<?> dependency : dependencies) {\r\n        subgraph.addEdge(node, dependency);\r\n    }\r\n    return dependencies;\r\n}"
}, {
	"Path": "com.facebook.buck.features.apple.project.ProjectGenerator.updateOtherLinkerFlagsForOptions",
	"Comment": "subdivide the various deps and write out to the xcconfig file for scripts to post process if",
	"Method": "void updateOtherLinkerFlagsForOptions(TargetNode<? extends CommonArg> targetNode,Optional<TargetNode<AppleBundleDescriptionArg>> bundleLoaderNode,Builder<String, String> appendConfigsBuilder,Iterable<String> otherLdFlags){\r\n    FluentIterable<TargetNode<?>> depTargetNodes = collectRecursiveLibraryDepTargets(targetNode);\r\n    FluentIterable<TargetNode<?>> filteredDeps = collectRecursiveLibraryDepsMinusBundleLoaderDeps(targetNode, depTargetNodes, bundleLoaderNode);\r\n    ImmutableSet<FrameworkPath> systemFwkOrLibs = getSytemFrameworksLibsForTargetNode(targetNode);\r\n    ImmutableList<String> systemFwkOrLibFlags = collectSystemLibraryAndFrameworkLinkerFlags(systemFwkOrLibs);\r\n    if (options.shouldForceLoadLinkWholeLibraries() || options.shouldAddLinkedLibrariesAsFlags()) {\r\n        ImmutableList<String> forceLoadLocal = collectForceLoadLinkerFlags(filterRecursiveLibraryDepsIterable(filteredDeps, FilterFlags.LIBRARY_CURRENT_PROJECT_WITH_FORCE_LOAD));\r\n        ImmutableList<String> forceLoadFocused = collectForceLoadLinkerFlags(filterRecursiveLibraryDepsIterable(filteredDeps, FilterFlags.LIBRARY_FOCUSED_WITH_FORCE_LOAD));\r\n        ImmutableList<String> forceLoadOther = collectForceLoadLinkerFlags(filterRecursiveLibraryDepsIterable(filteredDeps, FilterFlags.LIBRARY_OTHER_WITH_FORCE_LOAD));\r\n        appendConfigsBuilder.put(\"BUCK_LINKER_FLAGS_LIBRARY_FORCE_LOAD_LOCAL\", Streams.stream(forceLoadLocal).map(Escaper.BASH_ESCAPER).collect(Collectors.joining(\" \")));\r\n        appendConfigsBuilder.put(\"BUCK_LINKER_FLAGS_LIBRARY_FORCE_LOAD_FOCUSED\", Streams.stream(forceLoadFocused).map(Escaper.BASH_ESCAPER).collect(Collectors.joining(\" \")));\r\n        appendConfigsBuilder.put(\"BUCK_LINKER_FLAGS_LIBRARY_FORCE_LOAD_OTHER\", Streams.stream(forceLoadOther).map(Escaper.BASH_ESCAPER).collect(Collectors.joining(\" \")));\r\n    }\r\n    if (options.shouldAddLinkedLibrariesAsFlags()) {\r\n        boolean shouldLimitByForceLoad = options.shouldForceLoadLinkWholeLibraries();\r\n        Iterable<String> localLibraryFlags = collectLibraryLinkerFlags(filterRecursiveLibraryDepsIterable(filteredDeps, shouldLimitByForceLoad ? FilterFlags.LIBRARY_CURRENT_PROJECT_WITHOUT_FORCE_LOAD : FilterFlags.LIBRARY_CURRENT_PROJECT));\r\n        Iterable<String> focusedLibraryFlags = collectLibraryLinkerFlags(filterRecursiveLibraryDepsIterable(filteredDeps, shouldLimitByForceLoad ? FilterFlags.LIBRARY_FOCUSED_WITHOUT_FORCE_LOAD : FilterFlags.LIBRARY_FOCUSED));\r\n        Iterable<String> otherLibraryFlags = collectLibraryLinkerFlags(filterRecursiveLibraryDepsIterable(filteredDeps, shouldLimitByForceLoad ? FilterFlags.LIBRARY_OTHER_WITHOUT_FORCE_LOAD : FilterFlags.LIBRARY_OTHER));\r\n        Iterable<String> localFrameworkFlags = collectFrameworkLinkerFlags(filterRecursiveLibraryDepsIterable(depTargetNodes, FilterFlags.FRAMEWORK_CURRENT_PROJECT));\r\n        Iterable<String> focusedFrameworkFlags = collectFrameworkLinkerFlags(filterRecursiveLibraryDepsIterable(depTargetNodes, FilterFlags.FRAMEWORK_FOCUSED));\r\n        Iterable<String> otherFrameworkFlags = collectFrameworkLinkerFlags(filterRecursiveLibraryDepsIterable(depTargetNodes, FilterFlags.FRAMEWORK_OTHER));\r\n        appendConfigsBuilder.put(\"BUCK_LINKER_FLAGS_LIBRARY_LOCAL\", Streams.stream(localLibraryFlags).collect(Collectors.joining(\" \"))).put(\"BUCK_LINKER_FLAGS_LIBRARY_FOCUSED\", Streams.stream(focusedLibraryFlags).collect(Collectors.joining(\" \"))).put(\"BUCK_LINKER_FLAGS_LIBRARY_OTHER\", Streams.stream(otherLibraryFlags).collect(Collectors.joining(\" \"))).put(\"BUCK_LINKER_FLAGS_FRAMEWORK_LOCAL\", Streams.stream(localFrameworkFlags).collect(Collectors.joining(\" \"))).put(\"BUCK_LINKER_FLAGS_FRAMEWORK_FOCUSED\", Streams.stream(focusedFrameworkFlags).collect(Collectors.joining(\" \"))).put(\"BUCK_LINKER_FLAGS_FRAMEWORK_OTHER\", Streams.stream(otherFrameworkFlags).collect(Collectors.joining(\" \"))).put(\"BUCK_LINKER_FLAGS_SYSTEM\", Streams.stream(systemFwkOrLibFlags).collect(Collectors.joining(\" \")));\r\n    }\r\n    Stream<String> otherLdFlagsStream = Streams.stream(otherLdFlags).map(Escaper.BASH_ESCAPER);\r\n    if (options.shouldForceLoadLinkWholeLibraries() && options.shouldAddLinkedLibrariesAsFlags()) {\r\n        appendConfigsBuilder.put(\"OTHER_LDFLAGS\", Streams.concat(otherLdFlagsStream, Stream.of(\"$BUCK_LINKER_FLAGS_SYSTEM\", \"$BUCK_LINKER_FLAGS_FRAMEWORK_LOCAL\", \"$BUCK_LINKER_FLAGS_FRAMEWORK_FOCUSED\", \"$BUCK_LINKER_FLAGS_FRAMEWORK_OTHER\", \"$BUCK_LINKER_FLAGS_LIBRARY_FORCE_LOAD_LOCAL\", \"$BUCK_LINKER_FLAGS_LIBRARY_FORCE_LOAD_FOCUSED\", \"$BUCK_LINKER_FLAGS_LIBRARY_FORCE_LOAD_OTHER\", \"$BUCK_LINKER_FLAGS_LIBRARY_LOCAL\", \"$BUCK_LINKER_FLAGS_LIBRARY_FOCUSED\", \"$BUCK_LINKER_FLAGS_LIBRARY_OTHER\")).collect(Collectors.joining(\" \")));\r\n    } else if (options.shouldForceLoadLinkWholeLibraries() && !options.shouldAddLinkedLibrariesAsFlags()) {\r\n        appendConfigsBuilder.put(\"OTHER_LDFLAGS\", Streams.concat(otherLdFlagsStream, Stream.of(\"$BUCK_LINKER_FLAGS_LIBRARY_FORCE_LOAD_LOCAL\", \"$BUCK_LINKER_FLAGS_LIBRARY_FORCE_LOAD_FOCUSED\", \"$BUCK_LINKER_FLAGS_LIBRARY_FORCE_LOAD_OTHER\")).collect(Collectors.joining(\" \")));\r\n    } else if (options.shouldAddLinkedLibrariesAsFlags()) {\r\n        appendConfigsBuilder.put(\"OTHER_LDFLAGS\", Streams.concat(otherLdFlagsStream, Stream.of(\"$BUCK_LINKER_FLAGS_SYSTEM\", \"$BUCK_LINKER_FLAGS_FRAMEWORK_LOCAL\", \"$BUCK_LINKER_FLAGS_FRAMEWORK_FOCUSED\", \"$BUCK_LINKER_FLAGS_FRAMEWORK_OTHER\", \"$BUCK_LINKER_FLAGS_LIBRARY_LOCAL\", \"$BUCK_LINKER_FLAGS_LIBRARY_FOCUSED\", \"$BUCK_LINKER_FLAGS_LIBRARY_OTHER\")).collect(Collectors.joining(\" \")));\r\n    } else {\r\n        appendConfigsBuilder.put(\"OTHER_LDFLAGS\", otherLdFlagsStream.collect(Collectors.joining(\" \")));\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.BuildTargetDurationListener.criticalPath",
	"Comment": "construct the critical path to the target coming from the given chain. usedchain preventsduplicate paths.",
	"Method": "Deque<CriticalPathEntry> criticalPath(BuildRuleInfo.Chain chain,BuildRuleInfo target,Set<BuildRuleInfo.Chain> usedChains,ImmutableList<CriticalPathEntry> criticalPath){\r\n    Deque<CriticalPathEntry> path = Queues.newArrayDeque();\r\n    path.push(ImmutableCriticalPathEntry.of(target.ruleName, target.startEpochMillis, target.finishEpochMillis, target.getDuration(), target.getWholeTargetDuration(), chain.longest, chain.prev, target.intervals));\r\n    long longest = chain.longest;\r\n    Optional<BuildRuleInfo> prev = chain.prev;\r\n    while (prev.isPresent()) {\r\n        chain = null;\r\n        longest -= target.getDuration();\r\n        target = prev.get();\r\n        for (BuildRuleInfo.Chain c : target.chain) {\r\n            if (c.longest == longest && !usedChains.contains(c)) {\r\n                chain = c;\r\n                usedChains.add(c);\r\n                break;\r\n            }\r\n        }\r\n        prev = chain != null ? chain.prev : Optional.empty();\r\n        longest = chain != null ? chain.longest : 0L;\r\n        path.push(ImmutableCriticalPathEntry.of(target.ruleName, target.startEpochMillis, target.finishEpochMillis, target.getDuration(), target.getWholeTargetDuration(), longest, prev, target.intervals));\r\n    }\r\n    return path;\r\n}"
}, {
	"Path": "com.android.common.utils.XmlUtils.hasElementChildren",
	"Comment": "returns true if the given node has one or more element children",
	"Method": "boolean hasElementChildren(Node node){\r\n    NodeList children = node.getChildNodes();\r\n    for (int i = 0, n = children.getLength(); i < n; i++) {\r\n        if (children.item(i).getNodeType() == Node.ELEMENT_NODE) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.android.dx.dex.code.OutputFinisher.hasAnyLocalInfo",
	"Comment": "returns whether this instance has any local variable information.",
	"Method": "boolean hasAnyLocalInfo(){\r\n    return hasAnyLocalInfo;\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.abi.SignatureFactory.signatureRequired",
	"Comment": "returns true if the jvm spec requires a signature to be emitted for this field. see jvms84.7.9.1",
	"Method": "boolean signatureRequired(TypeElement element,boolean signatureRequired,ExecutableType type,boolean signatureRequired,VariableElement element){\r\n    return usesGenerics(element.asType());\r\n}"
}, {
	"Path": "com.facebook.buck.core.util.graph.AcyclicDepthFirstPostOrderTraversalTest.testTrivialCycle",
	"Comment": "ensures that a cycle is detected in a trivial graph of a single node that points to itself.",
	"Method": "void testTrivialCycle(){\r\n    Multimap<String, String> graph = LinkedListMultimap.create();\r\n    graph.put(\"A\", \"A\");\r\n    TestDagDepthFirstSearch dfs = new TestDagDepthFirstSearch(graph);\r\n    try {\r\n        dfs.traverse(ImmutableList.of(\"A\"));\r\n    } catch (CycleException e) {\r\n        assertThat(e.getMessage(), Matchers.containsString(linesToText(\"The following circular dependency has been found:\", \"A -> A\")));\r\n        assertEquals(ImmutableList.of(\"A\", \"A\"), e.getCycle());\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.testutil.AbstractWorkspace.getPath",
	"Comment": "resolves the given path relative to the path the workspace is held.",
	"Method": "Path getPath(Path pathRelativeToWorkspaceRoot,Path getPath,String pathRelativeToWorkspaceRoot){\r\n    return destPath.resolve(pathRelativeToWorkspaceRoot);\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.BuildTargetDurationListener.findCriticalNodes",
	"Comment": "finds top k critical nodes and corresponding chain for the critical paths.",
	"Method": "MinMaxPriorityQueue<BuildRuleInfoSelectedChain> findCriticalNodes(Iterable<BuildRuleInfo> rootRules,int k){\r\n    MinMaxPriorityQueue<BuildRuleInfoSelectedChain> topK = MinMaxPriorityQueue.orderedBy((BuildRuleInfoSelectedChain first, BuildRuleInfoSelectedChain second) -> Long.compare(second.chain().longest, first.chain().longest)).maximumSize(k).create();\r\n    for (BuildRuleInfo ruleInfo : rootRules) {\r\n        for (BuildRuleInfo.Chain chain : ruleInfo.chain) {\r\n            topK.add(ImmutableBuildRuleInfoSelectedChain.of(ruleInfo, chain));\r\n        }\r\n    }\r\n    return topK;\r\n}"
}, {
	"Path": "com.android.dx.cf.code.SwitchList.getTargets",
	"Comment": "gets the list of all targets. this includes one extra element at theend of the list, which holds the default target.",
	"Method": "IntList getTargets(){\r\n    return targets;\r\n}"
}, {
	"Path": "com.facebook.buck.util.ProcessHelper.getPid",
	"Comment": "gets the native process identifier for the given process instance.",
	"Method": "Long getPid(Long getPid,Object process){\r\n    if (process instanceof NuProcess) {\r\n        return (long) ((NuProcess) process).getPID();\r\n    } else if (process instanceof Process) {\r\n        Long pid = jdk9ProcessId(process);\r\n        if (pid == null) {\r\n            pid = unixLikeProcessId(process);\r\n        }\r\n        if (pid == null) {\r\n            pid = windowsProcessId(process);\r\n        }\r\n        return pid;\r\n    } else {\r\n        throw new IllegalArgumentException(\"Unknown process class: \" + process.getClass());\r\n    }\r\n}"
}, {
	"Path": "com.android.common.utils.XmlUtils.parseUtfXmlFile",
	"Comment": "parses the given utf file as a dom document, using the jdk parser. the parser does notvalidate, and is optionally namespace aware.",
	"Method": "Document parseUtfXmlFile(File file,boolean namespaceAware){\r\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\r\n    Reader reader = getUtfReader(file);\r\n    try {\r\n        InputSource is = new InputSource(reader);\r\n        factory.setNamespaceAware(namespaceAware);\r\n        factory.setValidating(false);\r\n        DocumentBuilder builder = factory.newDocumentBuilder();\r\n        return builder.parse(is);\r\n    } finally {\r\n        reader.close();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.features.go.GoDescriptors.getDependenciesFromSources",
	"Comment": "make sure that if any srcs elements are a build rule, we add it as a dependency, so we wait forit to finish running before using the source",
	"Method": "ImmutableList<BuildRule> getDependenciesFromSources(SourcePathRuleFinder ruleFinder,ImmutableSet<SourcePath> srcs){\r\n    return srcs.stream().map(ruleFinder::getRule).filter(Optional::isPresent).map(Optional::get).collect(ImmutableList.toImmutableList());\r\n}"
}, {
	"Path": "com.facebook.buck.parser.cache.impl.ParserCache.getBuildFileManifest",
	"Comment": "get build file manifest for the appropriate build file from cache, ignoring errors",
	"Method": "Optional<BuildFileManifest> getBuildFileManifest(Path buildFile,ProjectBuildFileParser parser,HashCode weakFingerprint,HashCode strongFingerprint){\r\n    Optional<BuildFileManifest> cachedManifest = parserCacheStorage.getBuildFileManifest(weakFingerprint, strongFingerprint);\r\n    if (cachedManifest.isPresent() && parser.globResultsMatchCurrentState(buildFile, cachedManifest.get().getGlobManifest())) {\r\n        return cachedManifest;\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "com.android.manifmerger.XmlDocument.addIfAbsent",
	"Comment": "adds a new element of type nodetype with a specific keyvalue if the element is absent in thisdocument. will also add attributes expressed through key value pairs.",
	"Method": "Optional<Element> addIfAbsent(ActionRecorder actionRecorder,ManifestModel.NodeTypes nodeType,String keyValue,String reason,Pair<String, String> attributes){\r\n    Optional<XmlElement> xmlElementOptional = getByTypeAndKey(nodeType, keyValue);\r\n    if (xmlElementOptional.isPresent()) {\r\n        return Optional.absent();\r\n    }\r\n    Element elementNS = getXml().createElementNS(SdkConstants.ANDROID_URI, \"android:\" + nodeType.toXmlName());\r\n    ImmutableList<String> keyAttributesNames = nodeType.getNodeKeyResolver().getKeyAttributesNames();\r\n    if (keyAttributesNames.size() == 1) {\r\n        elementNS.setAttributeNS(SdkConstants.ANDROID_URI, \"android:\" + keyAttributesNames.get(0), keyValue);\r\n    }\r\n    if (attributes != null) {\r\n        for (Pair<String, String> attribute : attributes) {\r\n            elementNS.setAttributeNS(SdkConstants.ANDROID_URI, \"android:\" + attribute.getFirst(), attribute.getSecond());\r\n        }\r\n    }\r\n    XmlElement xmlElement = new XmlElement(elementNS, this);\r\n    actionRecorder.recordImpliedNodeAction(xmlElement, reason);\r\n    getRootNode().getXml().appendChild(elementNS);\r\n    return Optional.of(elementNS);\r\n}"
}, {
	"Path": "com.android.dx.cf.code.Ropper.addOrReplaceBlockNoDelete",
	"Comment": "adds or replaces a block in the output result. do not deleteany successors.",
	"Method": "boolean addOrReplaceBlockNoDelete(BasicBlock block,IntList subroutines){\r\n    if (block == null) {\r\n        throw new NullPointerException(\"block == null\");\r\n    }\r\n    int idx = labelToResultIndex(block.getLabel());\r\n    boolean ret;\r\n    if (idx < 0) {\r\n        ret = false;\r\n    } else {\r\n        result.remove(idx);\r\n        resultSubroutines.remove(idx);\r\n        ret = true;\r\n    }\r\n    result.add(block);\r\n    subroutines.throwIfMutable();\r\n    resultSubroutines.add(subroutines);\r\n    return ret;\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.abi.source.TreeBackedExecutableElementTest.testGetReceiverTypeOfTopLevelConstructorIsNull",
	"Comment": "the docs claim this should be a notype of typekind.none. the docs lie.",
	"Method": "void testGetReceiverTypeOfTopLevelConstructorIsNull(){\r\n    compile(Joiner.on('\\n').join(\"class Foo {\", \"  Foo () { }\", \"}\"));\r\n    ExecutableElement element = findDefaultConstructor(elements.getTypeElement(\"Foo\"));\r\n    TypeMirror receiverType = element.getReceiverType();\r\n    assertNull(receiverType);\r\n}"
}, {
	"Path": "com.android.common.utils.XmlUtils.parseDocument",
	"Comment": "parses the given xml string as a dom document, using the jdk parser. the parser does notvalidate, and is optionally namespace aware.",
	"Method": "Document parseDocument(String xml,boolean namespaceAware,Document parseDocument,Reader xml,boolean namespaceAware){\r\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\r\n    InputSource is = new InputSource(xml);\r\n    factory.setNamespaceAware(namespaceAware);\r\n    factory.setValidating(false);\r\n    DocumentBuilder builder = factory.newDocumentBuilder();\r\n    return builder.parse(is);\r\n}"
}, {
	"Path": "com.facebook.buck.event.listener.AbstractConsoleEventBusListener.logEventPair",
	"Comment": "adds a line about a pair of start and finished events to lines.",
	"Method": "long logEventPair(String prefix,Optional<String> suffix,long currentMillis,long offsetMs,BuckEvent startEvent,BuckEvent finishedEvent,Optional<Double> progress,Optional<Long> minimum,ImmutableList.Builder<String> lines,long logEventPair,String prefix,Optional<String> suffix,long currentMillis,long offsetMs,Collection<EventPair> eventPairs,Optional<Double> progress,Optional<Long> minimum,ImmutableList.Builder<String> lines){\r\n    if (eventPairs.isEmpty()) {\r\n        return UNFINISHED_EVENT_PAIR;\r\n    }\r\n    long completedRunTimesMs = getTotalCompletedTimeFromEventPairs(eventPairs);\r\n    long currentlyRunningTime = getWorkingTimeFromLastStartUntilNow(eventPairs, currentMillis);\r\n    boolean stillRunning = currentlyRunningTime >= 0;\r\n    String parseLine = prefix;\r\n    long elapsedTimeMs = completedRunTimesMs - offsetMs;\r\n    if (stillRunning) {\r\n        parseLine += \"... \";\r\n        elapsedTimeMs += currentlyRunningTime;\r\n    } else {\r\n        parseLine += convertToAllCapsIfNeeded(\": finished in \");\r\n        if (progress.isPresent()) {\r\n            progress = Optional.of(1.0);\r\n        }\r\n    }\r\n    if (minimum.isPresent() && elapsedTimeMs < minimum.get()) {\r\n        return elapsedTimeMs;\r\n    }\r\n    parseLine += formatElapsedTime(elapsedTimeMs);\r\n    if (progress.isPresent()) {\r\n        parseLine += \" (\" + Math.round(progress.get() * 100) + \"%)\";\r\n    }\r\n    if (suffix.isPresent()) {\r\n        parseLine += \" \" + suffix.get();\r\n    }\r\n    lines.add(parseLine);\r\n    return stillRunning ? UNFINISHED_EVENT_PAIR : elapsedTimeMs;\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_client.BuildRuleEventManager.flushAllPendingBuildRuleFinishedEvents",
	"Comment": "publishes results of all pending buildrulefinishedevent, waiting for cache synchronization ifnecessary.",
	"Method": "void flushAllPendingBuildRuleFinishedEvents(){\r\n    if (!allBuildRulesFinishedEventReceived) {\r\n        LOG.warn(\"flushAllPendingBuildRuleFinishedEvents(..) called without first receiving ALL_BUILD_RULES_FINISHED_EVENT\");\r\n    }\r\n    synchronized (this) {\r\n        if (pendingBuildRuleFinishedEvent.isEmpty()) {\r\n            return;\r\n        }\r\n    }\r\n    List<TimestampedBuildRuleFinishedEvent> eventsToPublish = Lists.newArrayList();\r\n    synchronized (this) {\r\n        eventsToPublish.addAll(pendingBuildRuleFinishedEvent);\r\n        pendingBuildRuleFinishedEvent.clear();\r\n    }\r\n    for (TimestampedBuildRuleFinishedEvent event : eventsToPublish) {\r\n        long currentTimeMillis = clock.currentTimeMillis();\r\n        long elapsedMillisSinceEvent = currentTimeMillis - event.eventTimestampMillis;\r\n        if (elapsedMillisSinceEvent < cacheSynchronizationSafetyMarginMillis) {\r\n            try {\r\n                long millisUntilCacheSynchronization = cacheSynchronizationSafetyMarginMillis - elapsedMillisSinceEvent;\r\n                threadSleep(millisUntilCacheSynchronization);\r\n            } catch (InterruptedException e) {\r\n                LOG.error(e, \"InterruptedException thrown while publishing build finished events. Skipping remaining events.\");\r\n                Thread.currentThread().interrupt();\r\n                return;\r\n            }\r\n        }\r\n        remoteBuildRuleCompletionNotifier.signalCompletionOfBuildRule(event.buildTarget);\r\n    }\r\n}"
}, {
	"Path": "com.android.dx.dex.code.DalvCode.hasPositions",
	"Comment": "gets whether this instance has any position data to represent.",
	"Method": "boolean hasPositions(){\r\n    return (positionInfo != PositionList.NONE) && unprocessedInsns.hasAnyPositionInfo();\r\n}"
}, {
	"Path": "com.facebook.buck.features.haskell.HaskellDescriptionUtils.createLinkRule",
	"Comment": "create a haskell link rule that links the given inputs to a executable or shared library andpulls in transitive native linkable deps from the given dep roots.",
	"Method": "HaskellLinkRule createLinkRule(BuildTarget target,ProjectFilesystem projectFilesystem,BuildRuleParams baseParams,ActionGraphBuilder graphBuilder,SourcePathRuleFinder ruleFinder,HaskellPlatform platform,Linker.LinkType linkType,ImmutableList<Arg> linkerFlags,Iterable<Arg> linkerInputs,Iterable<? extends NativeLinkable> deps,ImmutableSet<BuildTarget> linkWholeDeps,Linker.LinkableDepType depType,Path outputPath,Optional<String> soname,boolean hsProfile){\r\n    Tool linker = platform.getLinker().resolve(graphBuilder);\r\n    ImmutableList.Builder<Arg> linkerArgsBuilder = ImmutableList.builder();\r\n    ImmutableList.Builder<Arg> argsBuilder = ImmutableList.builder();\r\n    argsBuilder.addAll(StringArg.from(platform.getLinkerFlags()));\r\n    if (linkType.equals(Linker.LinkType.SHARED)) {\r\n        argsBuilder.addAll(StringArg.from(\"-shared\", \"-dynamic\"));\r\n        soname.ifPresent(name -> argsBuilder.addAll(StringArg.from(MoreIterables.zipAndConcat(Iterables.cycle(\"-optl\"), platform.getCxxPlatform().getLd().resolve(graphBuilder).soname(name)))));\r\n    }\r\n    argsBuilder.addAll(linkerFlags);\r\n    linkerArgsBuilder.addAll(linkerInputs);\r\n    for (NativeLinkable nativeLinkable : NativeLinkables.getNativeLinkables(platform.getCxxPlatform(), graphBuilder, deps, depType)) {\r\n        NativeLinkable.Linkage link = nativeLinkable.getPreferredLinkage(platform.getCxxPlatform(), graphBuilder);\r\n        NativeLinkableInput input = nativeLinkable.getNativeLinkableInput(platform.getCxxPlatform(), NativeLinkables.getLinkStyle(link, depType), linkWholeDeps.contains(nativeLinkable.getBuildTarget()), graphBuilder);\r\n        linkerArgsBuilder.addAll(input.getArgs());\r\n    }\r\n    BuildTarget emptyModuleTarget = target.withAppendedFlavors(InternalFlavor.of(\"empty-module\"));\r\n    WriteFile emptyModule = graphBuilder.addToIndex(new WriteFile(emptyModuleTarget, projectFilesystem, \"module Unused where\", BuildTargetPaths.getGenPath(projectFilesystem, emptyModuleTarget, \"%s/Unused.hs\"), false));\r\n    HaskellCompileRule emptyCompiledModule = graphBuilder.addToIndex(createCompileRule(// Buck dependency.\r\n    target.withAppendedFlavors(InternalFlavor.of(\"empty-compiled-module\")), // Buck dependency.\r\n    projectFilesystem, // Buck dependency.\r\n    baseParams, // Buck dependency.\r\n    graphBuilder, ruleFinder, RichStream.from(deps).filter(BuildRule.class).toImmutableSortedSet(Ordering.natural()), platform, depType, hsProfile, Optional.empty(), Optional.empty(), ImmutableList.of(), HaskellSources.builder().putModuleMap(\"Unused\", emptyModule.getSourcePathToOutput()).build()));\r\n    BuildTarget emptyArchiveTarget = target.withAppendedFlavors(InternalFlavor.of(\"empty-archive\"));\r\n    Archive emptyArchive = graphBuilder.addToIndex(Archive.from(emptyArchiveTarget, projectFilesystem, graphBuilder, ruleFinder, platform.getCxxPlatform(), ArchiveContents.NORMAL, BuildTargetPaths.getGenPath(projectFilesystem, emptyArchiveTarget, \"%s/libempty.a\"), emptyCompiledModule.getObjects(), true));\r\n    argsBuilder.add(SourcePathArg.of(emptyArchive.getSourcePathToOutput()));\r\n    ImmutableList<Arg> args = argsBuilder.build();\r\n    ImmutableList<Arg> linkerArgs = linkerArgsBuilder.build();\r\n    return graphBuilder.addToIndex(new HaskellLinkRule(target, projectFilesystem, baseParams.withDeclaredDeps(ImmutableSortedSet.<BuildRule>naturalOrder().addAll(BuildableSupport.getDepsCollection(linker, ruleFinder)).addAll(Stream.of(args, linkerArgs).flatMap(Collection::stream).flatMap(arg -> BuildableSupport.getDeps(arg, ruleFinder)).iterator()).build()).withoutExtraDeps(), linker, outputPath, args, linkerArgs, platform.shouldCacheLinks()));\r\n}"
}, {
	"Path": "com.android.dx.dex.file.ClassDefItem.setClassAnnotations",
	"Comment": "sets the direct annotations on this class. these are annotationsmade on the class, per se, as opposed to on one of its members.it is only valid to call this method at most once per instance.",
	"Method": "void setClassAnnotations(Annotations annotations,DexFile dexFile){\r\n    annotationsDirectory.setClassAnnotations(annotations, dexFile);\r\n}"
}, {
	"Path": "com.android.dx.cf.code.Ropper.addOrReplaceBlock",
	"Comment": "adds or replace a block in the output result. if this is areplacement, then any extra blocks that got added with theoriginal get removed as a result of calling this method.",
	"Method": "boolean addOrReplaceBlock(BasicBlock block,IntList subroutines){\r\n    if (block == null) {\r\n        throw new NullPointerException(\"block == null\");\r\n    }\r\n    int idx = labelToResultIndex(block.getLabel());\r\n    boolean ret;\r\n    if (idx < 0) {\r\n        ret = false;\r\n    } else {\r\n        removeBlockAndSpecialSuccessors(idx);\r\n        ret = true;\r\n    }\r\n    result.add(block);\r\n    subroutines.throwIfMutable();\r\n    resultSubroutines.add(subroutines);\r\n    return ret;\r\n}"
}, {
	"Path": "com.facebook.buck.support.cli.args.BuckArgsMethods.expandFlagFilesRecursively",
	"Comment": "recursively expands flag files into a flat list of command line arguments.loops are not allowed and result in runtime exception.",
	"Method": "ImmutableList<String> expandFlagFilesRecursively(Iterable<String> args,ImmutableMap<CellName, Path> cellMapping,Set<String> expansionPath){\r\n    Iterator<String> argsIterator = args.iterator();\r\n    ImmutableList.Builder<String> argumentsBuilder = ImmutableList.builder();\r\n    while (argsIterator.hasNext()) {\r\n        String arg = argsIterator.next();\r\n        if (PASS_THROUGH_DELIMITER.equals(arg)) {\r\n            argumentsBuilder.add(arg);\r\n            argumentsBuilder.addAll(argsIterator);\r\n            break;\r\n        }\r\n        if (FLAG_FILE_OPTIONS.contains(arg)) {\r\n            if (!argsIterator.hasNext()) {\r\n                throw new HumanReadableException(arg + \" should be followed by a path.\");\r\n            }\r\n            String nextFlagFile = argsIterator.next();\r\n            argumentsBuilder.addAll(expandFlagFile(nextFlagFile, cellMapping, expansionPath));\r\n        } else if (arg.startsWith(\"@\")) {\r\n            argumentsBuilder.addAll(expandFlagFile(arg.substring(1), cellMapping, expansionPath));\r\n        } else {\r\n            argumentsBuilder.add(arg);\r\n        }\r\n    }\r\n    return argumentsBuilder.build();\r\n}"
}, {
	"Path": "com.facebook.buck.features.apple.project.ProjectGenerator.createMergedHeaderMap",
	"Comment": "generates the merged header maps and write it to the public header symlink tree location.",
	"Method": "void createMergedHeaderMap(){\r\n    HeaderMap.Builder headerMapBuilder = new HeaderMap.Builder();\r\n    Set<TargetNode<? extends CxxLibraryDescription.CommonArg>> processedNodes = new HashSet();\r\n    for (TargetNode<?> targetNode : targetGraph.getAll(targetsInRequiredProjects)) {\r\n        getAppleNativeNode(targetGraph, targetNode).ifPresent(argTargetNode -> visitRecursiveHeaderSymlinkTrees(argTargetNode, (depNativeNode, headerVisibility) -> {\r\n            if (processedNodes.contains(depNativeNode)) {\r\n                return;\r\n            }\r\n            if (headerVisibility == HeaderVisibility.PUBLIC) {\r\n                addToMergedHeaderMap(depNativeNode, headerMapBuilder);\r\n                processedNodes.add(depNativeNode);\r\n            }\r\n        }));\r\n    }\r\n    Path mergedHeaderMapRoot = getPathToMergedHeaderMap();\r\n    Path headerMapLocation = getHeaderMapLocationFromSymlinkTreeRoot(mergedHeaderMapRoot);\r\n    projectFilesystem.mkdirs(mergedHeaderMapRoot);\r\n    projectFilesystem.writeBytesToPath(headerMapBuilder.build().getBytes(), headerMapLocation);\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.DistBuildUtil.doTargetsMatchProjectWhitelist",
	"Comment": "checks whether the given targets match the stampede project whitelist",
	"Method": "boolean doTargetsMatchProjectWhitelist(List<String> commandArgs,ImmutableSet<String> projectWhitelist,BuckConfig buckConfig,boolean doTargetsMatchProjectWhitelist,ImmutableSet<String> buildTargets,ImmutableSet<String> projectWhitelist){\r\n    if (buildTargets.isEmpty()) {\r\n        return false;\r\n    }\r\n    boolean mismatchFound = false;\r\n    for (String buildTarget : buildTargets) {\r\n        Pattern pattern = Pattern.compile(TARGET_TO_PROJECT_REGREX);\r\n        Matcher matcher = pattern.matcher(buildTarget);\r\n        if (matcher.find()) {\r\n            String projectForTarget = matcher.group(1);\r\n            mismatchFound = !projectWhitelist.contains(projectForTarget);\r\n        } else {\r\n            mismatchFound = true;\r\n        }\r\n        if (mismatchFound) {\r\n            break;\r\n        }\r\n    }\r\n    return !mismatchFound;\r\n}"
}, {
	"Path": "com.facebook.buck.util.xml.XmlDomParserWithLineNumbers.parse",
	"Comment": "constructs a document builder, parses xml, then returns a document with a new documentlocationobject stored as userdata in each node",
	"Method": "Document parse(InputStream xml,Document parse,InputSource xml,Document parse,InputSource is){\r\n    DocumentBuilderWithLineNumbers docBuilder = new DocumentBuilderWithLineNumbers();\r\n    return docBuilder.parse(xml);\r\n}"
}, {
	"Path": "com.facebook.buck.util.CreateSymlinksForTests.createSymLink",
	"Comment": "creates a symlink using platform specific implementations, if there are some.",
	"Method": "void createSymLink(Path symLink,Path realFile){\r\n    MorePaths.createSymLink(winFS, symLink, realFile);\r\n}"
}, {
	"Path": "com.facebook.buck.cxx.toolchain.elf.ElfStringTable.writeStringTableFromStringTable",
	"Comment": "writes a string table from null terminated byte strings described by the byte array andindices.",
	"Method": "ImmutableList<Integer> writeStringTableFromStringTable(byte[] data,Iterable<Integer> indices,OutputStream output){\r\n    return writeStringTable(RichStream.from(indices).map(index -> new Entry(data, index, getLengthForStringTableAndOffset(data, index))).toImmutableList(), output);\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getAUnit",
	"Comment": "gets the a register number, as a code unit. this will throw if thevalue is out of the range of an unsigned code unit.",
	"Method": "short getAUnit(){\r\n    int a = getA();\r\n    if ((a & ~0xffff) != 0) {\r\n        throw new DexException(\"Register A out of range: \" + Hex.u8(a));\r\n    }\r\n    return (short) a;\r\n}"
}, {
	"Path": "com.facebook.buck.log.thrift.ThriftRuleKeyLogger.create",
	"Comment": "create an instance of a logger that writes to the given file namean attempt is made to create all subdirectories before opening the file",
	"Method": "ThriftRuleKeyLogger create(Path filename){\r\n    Files.createDirectories(filename.getParent());\r\n    OutputStream writer = new BufferedOutputStream(Files.newOutputStream(filename));\r\n    return new ThriftRuleKeyLogger(writer);\r\n}"
}, {
	"Path": "com.android.dx.dex.code.HighRegisterPrefix.moveInsnFor",
	"Comment": "returns the proper move instruction for the given source specand destination index.",
	"Method": "SimpleInsn moveInsnFor(RegisterSpec src,int destIndex){\r\n    return DalvInsn.makeMove(SourcePosition.NO_INFO, RegisterSpec.make(destIndex, src.getType()), src);\r\n}"
}, {
	"Path": "com.android.dx.dex.file.MixedItemSection.writeIndexAnnotation",
	"Comment": "writes an index of contents of the items in this instance of thegiven type. if there are none, this writes nothing. if there are any,then the index is preceded by the given intro string.",
	"Method": "void writeIndexAnnotation(AnnotatedOutput out,ItemType itemType,String intro){\r\n    throwIfNotPrepared();\r\n    TreeMap<String, OffsettedItem> index = new TreeMap<String, OffsettedItem>();\r\n    for (OffsettedItem item : items) {\r\n        if (item.itemType() == itemType) {\r\n            String label = item.toHuman();\r\n            index.put(label, item);\r\n        }\r\n    }\r\n    if (index.size() == 0) {\r\n        return;\r\n    }\r\n    out.annotate(0, intro);\r\n    for (Map.Entry<String, OffsettedItem> entry : index.entrySet()) {\r\n        String label = entry.getKey();\r\n        OffsettedItem item = entry.getValue();\r\n        out.annotate(0, item.offsetString() + ' ' + label + '\\n');\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.cli.TestRunningTest.testGeneratedSourceFile",
	"Comment": "if the source paths specified are all generated files, then our path to source tmp should beabsent.",
	"Method": "void testGeneratedSourceFile(){\r\n    BuildTarget genSrcTarget = BuildTargetFactory.newInstance(\"//:gensrc\");\r\n    TargetNode<GenruleDescriptionArg> sourceGenerator = GenruleBuilder.newGenruleBuilder(genSrcTarget).setOut(\"com/facebook/GeneratedFile.java\").build();\r\n    BuildTarget javaLibraryTarget = BuildTargetFactory.newInstance(\"//:lib\");\r\n    TargetNode<JavaLibraryDescriptionArg> javaLibraryNode = JavaLibraryBuilder.createBuilder(javaLibraryTarget).addSrcTarget(genSrcTarget).build();\r\n    TargetGraph targetGraph = TargetGraphFactory.newInstance(sourceGenerator, javaLibraryNode);\r\n    ActionGraphBuilder graphBuilder = new TestActionGraphBuilder(targetGraph);\r\n    SourcePathRuleFinder ruleFinder = new SourcePathRuleFinder(graphBuilder);\r\n    SourcePathResolver resolver = DefaultSourcePathResolver.from(ruleFinder);\r\n    JavaLibrary javaLibrary = (JavaLibrary) graphBuilder.requireRule(javaLibraryTarget);\r\n    DefaultJavaPackageFinder defaultJavaPackageFinder = FakeBuckConfig.builder().build().getView(JavaBuckConfig.class).createDefaultJavaPackageFinder();\r\n    ImmutableSet<String> result = TestRunning.getPathToSourceFolders(javaLibrary, resolver, ruleFinder, defaultJavaPackageFinder);\r\n    assertThat(\"No path should be returned if the library contains only generated files.\", result, Matchers.empty());\r\n}"
}, {
	"Path": "com.android.dx.command.annotool.AnnotationLister.isMatchingInnerClass",
	"Comment": "checks to see if a specified class name should be considered a matchdue to previous matches.",
	"Method": "boolean isMatchingInnerClass(String s){\r\n    int i;\r\n    while (0 < (i = s.lastIndexOf('$'))) {\r\n        s = s.substring(0, i);\r\n        if (matchInnerClassesOf.contains(s)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.facebook.buck.swift.SwiftBuckConfig.getProjectEmbedRuntime",
	"Comment": "if enabled, automatically emebds the swift runtime if a relevant target depends on anylibraries that use swift.",
	"Method": "boolean getProjectEmbedRuntime(){\r\n    return delegate.getBooleanValue(SECTION_NAME, PROJECT_EMBED_RUNTIME, true);\r\n}"
}, {
	"Path": "com.facebook.buck.distributed.build_slave.MinionLocalBuildStateTracker.increaseCapacityIfTerminalNode",
	"Comment": "increases available capacity if the given target was at the end of a work unit.",
	"Method": "void increaseCapacityIfTerminalNode(String target){\r\n    if (!workUnitTerminalTargets.contains(target)) {\r\n        return;\r\n    }\r\n    capacityTracker.returnCapacity();\r\n    workUnitTerminalTargets.remove(target);\r\n}"
}, {
	"Path": "com.android.manifmerger.XmlDocument.getPackageName",
	"Comment": "package name for this android manifest which will be used to resolvepartial path. in the case of overlays, this is absent and the mainmanifest packagename must be used.",
	"Method": "String getPackageName(){\r\n    return mMainManifestPackageName.or(mRootElement.getAttribute(\"package\"));\r\n}"
}, {
	"Path": "com.facebook.buck.features.haskell.HaskellGhciDescription.requireOmnibusSharedObject",
	"Comment": "give a rule for an omnibus object to be loaded into a ghci session",
	"Method": "BuildRule requireOmnibusSharedObject(CellPathResolver cellPathResolver,BuildTarget baseTarget,ProjectFilesystem projectFilesystem,ActionGraphBuilder graphBuilder,CxxPlatform cxxPlatform,CxxBuckConfig cxxBuckConfig,Iterable<NativeLinkable> body,Iterable<NativeLinkable> deps,ImmutableList<Arg> extraLdFlags){\r\n    return graphBuilder.computeIfAbsent(ImmutableBuildTarget.of(ImmutableUnflavoredBuildTarget.of(baseTarget.getCellPath(), Optional.empty(), baseTarget.getBaseName(), baseTarget.getShortName() + \".omnibus-shared-object\"), baseTarget.getFlavors()), ruleTarget -> {\r\n        ImmutableList.Builder<Arg> linkFlagsBuilder = ImmutableList.builder();\r\n        linkFlagsBuilder.addAll(extraLdFlags);\r\n        linkFlagsBuilder.addAll(getOmnibusNativeLinkableInput(baseTarget, cxxPlatform, graphBuilder, body, deps).getArgs());\r\n        return CxxLinkableEnhancer.createCxxLinkableSharedBuildRule(cxxBuckConfig, cxxPlatform, projectFilesystem, graphBuilder, new SourcePathRuleFinder(graphBuilder), ruleTarget, BuildTargetPaths.getGenPath(projectFilesystem, ruleTarget, \"%s\").resolve(\"libghci_dependencies.so\"), ImmutableMap.of(), Optional.of(\"libghci_dependencies.so\"), linkFlagsBuilder.build(), cellPathResolver);\r\n    });\r\n}"
}, {
	"Path": "com.facebook.buck.core.rules.attr.BuildOutputInitializer.invalidate",
	"Comment": "invalidates the cached build output. this should be called whenever the on disk state is aboutto change.",
	"Method": "void invalidate(){\r\n    if (buildOutput != null) {\r\n        initializableFromDisk.invalidateInitializeFromDiskState();\r\n        buildOutput = null;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.rules.modern.impl.DefaultClassInfoFactory.forInstance",
	"Comment": "returns the classinfo for the object based on its runtime type.",
	"Method": "ClassInfo<T> forInstance(T value){\r\n    @SuppressWarnings(\"unchecked\")\r\n    ClassInfo<T> classInfo = (ClassInfo<T>) getClassInfo(value.getClass());\r\n    return classInfo;\r\n}"
}, {
	"Path": "com.facebook.buck.jvm.java.abi.SignatureFactory.getSignature",
	"Comment": "returns the type signature of the given element. if none is required by the vm spec, returnsnull.",
	"Method": "String getSignature(Element element,String getSignature,TypeMirror type){\r\n    SignatureWriter writer = new SignatureWriter();\r\n    type.accept(typeVisitorAdapter, writer);\r\n    String result = writer.toString();\r\n    return result.isEmpty() ? null : result;\r\n}"
}, {
	"Path": "com.android.dx.dex.file.DexFile.add",
	"Comment": "adds a class to this instance. it is illegal to attempt to add morethan one class with the same name.",
	"Method": "void add(ClassDefItem clazz){\r\n    classDefs.add(clazz);\r\n}"
}, {
	"Path": "com.facebook.buck.skylark.io.impl.WatchmanGlobber.toMatchExpressions",
	"Comment": "returns an expression for every matched include file should match in order to be returned.",
	"Method": "ImmutableList<Object> toMatchExpressions(Collection<String> exclude,boolean excludeDirectories){\r\n    ImmutableList.Builder<Object> matchExpressions = ImmutableList.builder();\r\n    matchExpressions.add(\"allof\", toTypeExpression(excludeDirectories));\r\n    if (!exclude.isEmpty()) {\r\n        matchExpressions.add(toExcludeExpression(exclude));\r\n    }\r\n    return matchExpressions.build();\r\n}"
}, {
	"Path": "com.facebook.buck.core.rules.common.BuildableSupport.getDeps",
	"Comment": "streams dependencies based on everything added to its rulekey.",
	"Method": "Stream<BuildRule> getDeps(AddsToRuleKey tool,SourcePathRuleFinder ruleFinder){\r\n    return deriveDeps(tool, ruleFinder);\r\n}"
}, {
	"Path": "com.facebook.buck.features.d.DDescriptionUtils.createDCompileBuildTarget",
	"Comment": "creates a new buildtarget, based on an existing target, for a file to be compiled.",
	"Method": "BuildTarget createDCompileBuildTarget(BuildTarget existingTarget,String src,CxxPlatform cxxPlatform){\r\n    return createBuildTargetForFile(existingTarget, \"compile-\", DCompileStep.getObjectNameForSourceName(src), cxxPlatform);\r\n}"
}, {
	"Path": "com.facebook.buck.core.model.impl.FilesystemBackedBuildFileTree.getBasePathOfAncestorTarget",
	"Comment": "returns the base path for a given path. the base path is the nearest directory at or abovefilepath that contains a build file. if no base directory is found, returns an empty path.",
	"Method": "Optional<Path> getBasePathOfAncestorTarget(Path filePath){\r\n    if (!projectFilesystem.isFile(filePath) && isBasePath(filePath)) {\r\n        return Optional.of(filePath);\r\n    }\r\n    return basePathOfAncestorCache.getUnchecked(filePath);\r\n}"
}, {
	"Path": "com.facebook.buck.rules.coercer.ParamInfo.setCoercedValue",
	"Comment": "set the param on dto to value, assuming value has already been coerced.this is useful for things like making copies of dtos.",
	"Method": "void setCoercedValue(Object dto,Object value){\r\n    try {\r\n        setter.invoke(dto, value);\r\n    } catch (IllegalAccessException | InvocationTargetException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.buck.util.cache.impl.DefaultFileHashCache.getDefaultPathPredicate",
	"Comment": "this predicate matches files that might be result of builds or files that are explicitlyignored.",
	"Method": "Predicate<Path> getDefaultPathPredicate(ProjectFilesystem projectFilesystem){\r\n    return path -> isInBuckOut(projectFilesystem, path) || isInEmbeddedCellBuckOut(projectFilesystem, path) || projectFilesystem.isIgnored(path);\r\n}"
}, {
	"Path": "com.android.dx.io.instructions.DecodedInstruction.getLiteralByte",
	"Comment": "gets the literal value, masked to be a byte in size. this willthrow if the value is out of the range of a signed byte.",
	"Method": "int getLiteralByte(){\r\n    if (literal != (byte) literal) {\r\n        throw new DexException(\"Literal out of range: \" + Hex.u8(literal));\r\n    }\r\n    return (int) literal & 0xff;\r\n}"
}, {
	"Path": "com.facebook.buck.rules.keys.hasher.ThriftRuleKeyHasher.getStringValueFromProperty",
	"Comment": "try to grab a string value from the values property of the current rule key",
	"Method": "String getStringValueFromProperty(String defaultValue,String fields){\r\n    for (String field : fields) {\r\n        Value potentialValue = ruleKey.values.get(field);\r\n        if (potentialValue != null && potentialValue.getSetField() == STRING_VALUE) {\r\n            return potentialValue.getStringValue();\r\n        }\r\n    }\r\n    return defaultValue;\r\n}"
}, {
	"Path": "com.facebook.buck.skylark.function.JsonPrinter.escapeDoubleQuotesAndBackslashesAndNewlines",
	"Comment": "escapes the given string for use in a json string.this escapes double quotes, backslashes, and newlines.",
	"Method": "String escapeDoubleQuotesAndBackslashesAndNewlines(String string){\r\n    return TextFormat.escapeDoubleQuotesAndBackslashes(string).replace(\"\\n\", \"\\\\n\");\r\n}"
}, {
	"Path": "com.facebook.buck.core.rulekey.RuleKeyTest.testRuleKeyDependsOnDeps",
	"Comment": "ensure that build rules with the same inputs but different deps have unique rulekeys.",
	"Method": "void testRuleKeyDependsOnDeps(){\r\n    FakeProjectFilesystem filesystem = new FakeProjectFilesystem();\r\n    FileHashCache hashCache = new StackedFileHashCache(ImmutableList.of(DefaultFileHashCache.createDefaultFileHashCache(filesystem, FileHashCacheMode.DEFAULT)));\r\n    ActionGraphBuilder graphBuilder1 = new TestActionGraphBuilder();\r\n    ActionGraphBuilder graphBuilder2 = new TestActionGraphBuilder();\r\n    SourcePathRuleFinder ruleFinder1 = new SourcePathRuleFinder(graphBuilder1);\r\n    DefaultRuleKeyFactory ruleKeyFactory = new TestDefaultRuleKeyFactory(hashCache, DefaultSourcePathResolver.from(ruleFinder1), ruleFinder1);\r\n    SourcePathRuleFinder ruleFinder2 = new SourcePathRuleFinder(graphBuilder2);\r\n    DefaultRuleKeyFactory ruleKeyFactory2 = new TestDefaultRuleKeyFactory(hashCache, DefaultSourcePathResolver.from(ruleFinder2), ruleFinder2);\r\n    FakeTargetNodeBuilder builder = FakeTargetNodeBuilder.newBuilder(BuildTargetFactory.newInstance(\"//src/com/facebook/buck/cli:common\"));\r\n    BuildRule commonJavaLibrary = builder.build(graphBuilder1);\r\n    builder.build(graphBuilder2);\r\n    FakeTargetNodeBuilder dependentBuilder = FakeTargetNodeBuilder.newBuilder(BuildTargetFactory.newInstance(\"//src/com/facebook/buck/cli:cli\"));\r\n    BuildRule libraryNoCommon = dependentBuilder.build(graphBuilder1, filesystem);\r\n    dependentBuilder.setDeps(commonJavaLibrary.getBuildTarget());\r\n    BuildRule libraryWithCommon = dependentBuilder.build(graphBuilder2, filesystem);\r\n    RuleKey r1 = ruleKeyFactory.build(libraryNoCommon);\r\n    RuleKey r2 = ruleKeyFactory2.build(libraryWithCommon);\r\n    assertThat(\"Rule keys should be distinct because the deps of the rules are different.\", r1, not(equalTo(r2)));\r\n}"
}, {
	"Path": "com.facebook.buck.core.rules.common.BuildableSupport.getDepsCollection",
	"Comment": "derives dependencies based on everything added to its rulekey.",
	"Method": "ImmutableCollection<BuildRule> getDepsCollection(AddsToRuleKey tool,SourcePathRuleFinder ruleFinder){\r\n    return getDeps(tool, ruleFinder).collect(ImmutableList.toImmutableList());\r\n}"
}, {
	"Path": "com.android.dx.dex.file.MixedItemSection.add",
	"Comment": "adds an item to this instance. this will in turn tell the given itemthat it has been added to this instance. it is invalid to add thesame item to more than one instance, nor to add the same itemsmultiple times to a single instance.",
	"Method": "void add(OffsettedItem item){\r\n    throwIfPrepared();\r\n    try {\r\n        if (item.getAlignment() > getAlignment()) {\r\n            throw new IllegalArgumentException(\"incompatible item alignment\");\r\n        }\r\n    } catch (NullPointerException ex) {\r\n        throw new NullPointerException(\"item == null\");\r\n    }\r\n    items.add(item);\r\n}"
}, {
	"Path": "com.facebook.buck.parser.DefaultParserTest.filterAllTargetsInProject",
	"Comment": "populates the collection of known build targets that this parser will use to construct anaction graph using all build files inside the given project root and returns an optionallyfiltered set of build targets.",
	"Method": "ImmutableSet<BuildTarget> filterAllTargetsInProject(Parser parser,Cell cell,ListeningExecutorService executor){\r\n    return FluentIterable.from(parser.buildTargetGraphForTargetNodeSpecs(cell, false, executor, ImmutableList.of(TargetNodePredicateSpec.of(BuildFileSpec.fromRecursivePath(Paths.get(\"\"), cell.getRoot())))).getTargetGraph().getNodes()).transform(TargetNode::getBuildTarget).toSet();\r\n}"
}, {
	"Path": "com.android.dx.command.dump.BaseDumper.setAt",
	"Comment": "sets the dump cursor to the indicated offset in the given array.",
	"Method": "void setAt(ByteArray arr,int offset){\r\n    at = arr.underlyingOffset(offset, bytes);\r\n}"
}]