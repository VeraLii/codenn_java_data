[{
	"Path": "org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin.getSubstitute",
	"Comment": "gets the substitute method, resolving it first if necessary.",
	"Method": "ResolvedJavaMethod getSubstitute(MetaAccessProvider metaAccess){\r\n    if (cachedSubstitute == null) {\r\n        cachedSubstitute = metaAccess.lookupJavaMethod(getJavaSubstitute());\r\n    }\r\n    return cachedSubstitute;\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.AbstractKey.getIndex",
	"Comment": "gets the globally unique index for the value represented by this object.",
	"Method": "int getIndex(){\r\n    ensureInitialized();\r\n    return index;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.test.AbstractObjectStampTest.meet",
	"Comment": "meets the two stamps and also asserts that the meet operation is commutative.",
	"Method": "Stamp meet(Stamp a,Stamp b){\r\n    Stamp ab = a.meet(b);\r\n    Stamp ba = b.meet(a);\r\n    Assert.assertEquals(ab, ba);\r\n    return ab;\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.DiagnosticsOutputDirectory.createPath",
	"Comment": "gets the path of the directory to be created.subclasses can override this to determine how the path name is created.",
	"Method": "String createPath(){\r\n    Path baseDir;\r\n    try {\r\n        baseDir = DebugOptions.getDumpDirectory(options);\r\n    } catch (IOException e) {\r\n        baseDir = Paths.get(\".\");\r\n    }\r\n    return baseDir.resolve(\"graal_diagnostics_\" + GraalServices.getExecutionID()).toAbsolutePath().toString();\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.common.inlining.walker.ComputeInliningRelevance.getMaxProbabilitySux",
	"Comment": "returns the most probable successor. if multiple successors share the maximum probability,one is returned and the others are enqueued in pathbeginnodes.",
	"Method": "Node getMaxProbabilitySux(ControlSplitNode controlSplit,ArrayList<FixedNode> pathBeginNodes){\r\n    Node maxSux = null;\r\n    double maxProbability = 0.0;\r\n    int pathBeginCount = pathBeginNodes.size();\r\n    for (Node sux : controlSplit.successors()) {\r\n        double probability = controlSplit.probability((AbstractBeginNode) sux);\r\n        if (probability > maxProbability) {\r\n            maxProbability = probability;\r\n            maxSux = sux;\r\n            truncate(pathBeginNodes, pathBeginCount);\r\n        } else if (probability == maxProbability) {\r\n            pathBeginNodes.add((FixedNode) sux);\r\n        }\r\n    }\r\n    return maxSux;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.test.AArch64ConditionalSetTest.conditionalSetSwap",
	"Comment": "conditionalset test when truevalue and falsevalue need to be exchanged.",
	"Method": "int conditionalSetSwap(int m,int n){\r\n    if (m == n) {\r\n        return 0;\r\n    }\r\n    return 1;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.cfg.Block.getRelativeFrequency",
	"Comment": "the execution frequency of this block relative to the start block as estimated by theprofiling information.",
	"Method": "double getRelativeFrequency(){\r\n    return relativeFrequency;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.LIRKind.setDerivedReferenceBase",
	"Comment": "change the base value of a derived reference. this must be called on derived references only.",
	"Method": "void setDerivedReferenceBase(AllocatableValue derivedReferenceBase){\r\n    assert isDerivedReference();\r\n    this.derivedReferenceBase = derivedReferenceBase;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.lsra.LinearScan.operandSize",
	"Comment": "gets the number of operands. this value will increase by 1 for new variable.",
	"Method": "int operandSize(){\r\n    return firstVariableNumber + numVariables;\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.Assembler.close",
	"Comment": "closes this assembler. no extra data can be written to this assembler after this call.",
	"Method": "byte[] close(boolean trimmedCopy){\r\n    return codeBuffer.close(trimmedCopy);\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.common.inlining.InliningUtil.logNotInlinedMethod",
	"Comment": "output a decision about not inlining a method to the logging stream, for debugging purposes.",
	"Method": "void logNotInlinedMethod(Invoke invoke,String msg){\r\n    DebugContext debug = invoke.asNode().getDebug();\r\n    if (shouldLogMethod(debug)) {\r\n        String methodString = invoke.toString();\r\n        if (invoke.callTarget() == null) {\r\n            methodString += \" callTarget=null\";\r\n        } else {\r\n            String targetName = invoke.callTarget().targetName();\r\n            if (!methodString.endsWith(targetName)) {\r\n                methodString += \" \" + targetName;\r\n            }\r\n        }\r\n        logMethod(debug, methodString, false, msg, new Object[0]);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.AArch64LIRGenerator.toIntConditionFlag",
	"Comment": "takes a condition and returns the correct aarch64 specific conditionflag.",
	"Method": "ConditionFlag toIntConditionFlag(Condition cond){\r\n    switch(cond) {\r\n        case EQ:\r\n            return ConditionFlag.EQ;\r\n        case NE:\r\n            return ConditionFlag.NE;\r\n        case LT:\r\n            return ConditionFlag.LT;\r\n        case LE:\r\n            return ConditionFlag.LE;\r\n        case GT:\r\n            return ConditionFlag.GT;\r\n        case GE:\r\n            return ConditionFlag.GE;\r\n        case AE:\r\n            return ConditionFlag.HS;\r\n        case BE:\r\n            return ConditionFlag.LS;\r\n        case AT:\r\n            return ConditionFlag.HI;\r\n        case BT:\r\n            return ConditionFlag.LO;\r\n        default:\r\n            throw GraalError.shouldNotReachHere();\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.tregex.dfa.NFATransitionSet.iterator",
	"Comment": "returns an iterator that will yield the elements contained in this set in insertionorder.",
	"Method": "Iterator<NFAStateTransition> iterator(){\r\n    return new NFATransitionSetIterator(nfa, transitions, size);\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.util.BlockWorkList.addSorted",
	"Comment": "adds a block to this list, sorted by the supplied number. the block with the lowest number isreturned upon subsequent removes.",
	"Method": "void addSorted(AbstractMergeNode block,int number){\r\n    if (workList == null) {\r\n        allocate();\r\n    } else if (workListIndex == workList.length) {\r\n        grow();\r\n    }\r\n    workList[workListIndex] = block;\r\n    workListNumbers[workListIndex] = number;\r\n    workListIndex++;\r\n    int i = workListIndex - 2;\r\n    for (; i >= 0; i--) {\r\n        int n = workListNumbers[i];\r\n        if (n >= number) {\r\n            break;\r\n        }\r\n        workList[i + 1] = workList[i];\r\n        workList[i] = block;\r\n        workListNumbers[i + 1] = n;\r\n        workListNumbers[i] = number;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.amd64.AMD64HotSpotLIRGenerator.emitSaveAllRegisters",
	"Comment": "adds a node to the graph that saves all allocatable registers to the stack.",
	"Method": "AMD64SaveRegistersOp emitSaveAllRegisters(Register[] savedRegisters,boolean supportsRemove){\r\n    AllocatableValue[] savedRegisterLocations = new AllocatableValue[savedRegisters.length];\r\n    for (int i = 0; i < savedRegisters.length; i++) {\r\n        savedRegisterLocations[i] = allocateSaveRegisterLocation(savedRegisters[i]);\r\n    }\r\n    return emitSaveRegisters(savedRegisters, savedRegisterLocations, supportsRemove);\r\n}"
}, {
	"Path": "org.graalvm.compiler.virtual.phases.ea.GraphEffectList.deleteNode",
	"Comment": "removes the given fixed node from the control flow and deletes it.",
	"Method": "void deleteNode(Node node){\r\n    add(\"delete fixed node\", (graph, obsoleteNodes) -> {\r\n        if (node instanceof FixedWithNextNode) {\r\n            GraphUtil.unlinkFixedNode((FixedWithNextNode) node);\r\n        }\r\n        obsoleteNodes.add(node);\r\n    });\r\n}"
}, {
	"Path": "org.graalvm.compiler.graph.Node.getUsageCount",
	"Comment": "gets the maximum number of usages this node has had at any point in time.",
	"Method": "int getUsageCount(){\r\n    if (usage0 == null) {\r\n        return 0;\r\n    }\r\n    if (usage1 == null) {\r\n        return 1;\r\n    }\r\n    return INLINE_USAGE_COUNT + extraUsagesCount;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.CommonedConstantsTest.test0Snippet",
	"Comment": "the dominating block of both usages is the block containing the call.",
	"Method": "Object test0Snippet(String[] arr,int i){\r\n    Object result = null;\r\n    try {\r\n        result = Array.get(arr, i);\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        result = array[0];\r\n    }\r\n    if (result == null) {\r\n        result = array[2];\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.RegexProfile.incMatches",
	"Comment": "increase the number of times a match for the regular expression was found by one.",
	"Method": "void incMatches(){\r\n    matches.inc();\r\n}"
}, {
	"Path": "org.graalvm.polyglot.tck.TypeDescriptor.union",
	"Comment": "creates a new union type. the union type is any of the given types.",
	"Method": "TypeDescriptor union(TypeDescriptor types){\r\n    Objects.requireNonNull(types);\r\n    final Set<TypeDescriptor> typesSet = new HashSet();\r\n    Collections.addAll(typesSet, types);\r\n    switch(typesSet.size()) {\r\n        case 0:\r\n            throw new IllegalArgumentException(\"No types.\");\r\n        case 1:\r\n            return types[0];\r\n        default:\r\n            final Set<TypeDescriptorImpl> typeImpls = new HashSet();\r\n            for (TypeDescriptor type : typesSet) {\r\n                typeImpls.add(type.impl);\r\n            }\r\n            final TypeDescriptorImpl unionImpl = unionImpl(typeImpls);\r\n            TypeDescriptor result = isPredefined(unionImpl);\r\n            return result != null ? result : new TypeDescriptor(unionImpl);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.Assembler.position",
	"Comment": "returns the current position of the underlying code buffer.",
	"Method": "int position(){\r\n    return codeBuffer.position();\r\n}"
}, {
	"Path": "org.graalvm.compiler.options.OptionsParser.fuzzyMatch",
	"Comment": "returns the set of options that fuzzy match a given option name.",
	"Method": "List<OptionDescriptor> fuzzyMatch(Iterable<OptionDescriptors> loader,String optionName){\r\n    List<OptionDescriptor> matches = new ArrayList();\r\n    for (OptionDescriptors options : loader) {\r\n        collectFuzzyMatches(options, optionName, matches);\r\n    }\r\n    return matches;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.alloc.ComputeBlockOrder.findAndMarkMostLikelySuccessor",
	"Comment": "find the highest likely unvisited successor block of a given block.",
	"Method": "T findAndMarkMostLikelySuccessor(T block,BitSet visitedBlocks){\r\n    T result = null;\r\n    for (T successor : block.getSuccessors()) {\r\n        assert successor.getRelativeFrequency() >= 0.0 : \"Relative frequencies must be positive\";\r\n        if (!visitedBlocks.get(successor.getId()) && successor.getLoopDepth() >= block.getLoopDepth() && (result == null || successor.getRelativeFrequency() >= result.getRelativeFrequency())) {\r\n            result = successor;\r\n        }\r\n    }\r\n    if (result != null) {\r\n        visitedBlocks.set(result.getId());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.HotSpotLockStack.makeLockSlot",
	"Comment": "gets a stack slot for a lock at a given lock nesting depth, allocating it first if necessary.",
	"Method": "VirtualStackSlot makeLockSlot(int lockDepth){\r\n    if (locks == EMPTY) {\r\n        locks = new AllocatableValue[lockDepth + 1];\r\n    } else if (locks.length < lockDepth + 1) {\r\n        locks = Arrays.copyOf(locks, lockDepth + 1);\r\n    }\r\n    if (locks[lockDepth] == null) {\r\n        locks[lockDepth] = frameMapBuilder.allocateSpillSlot(slotKind);\r\n    }\r\n    return (VirtualStackSlot) locks[lockDepth];\r\n}"
}, {
	"Path": "org.graalvm.polyglot.PolyglotException.isInternalError",
	"Comment": "returns true if this exception was caused by an internal implementation error.these errors should be reported as bugs if observed. internal error messages are typicallyhard to understand for guest language programmers and might contain implementation specificdetails that allows guest language implementers to debug the problem.",
	"Method": "boolean isInternalError(){\r\n    return impl.isInternalError();\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.java.AccessFieldNode.isStatic",
	"Comment": "checks whether this field access is an access to a static field.",
	"Method": "boolean isStatic(){\r\n    return field.isStatic();\r\n}"
}, {
	"Path": "org.graalvm.compiler.graph.GraalGraphError.transformAndAddContext",
	"Comment": "transform a graalerror into a graalgraphinternalerror and add a node to the context.",
	"Method": "GraalGraphError transformAndAddContext(GraalError e,Graph newGraph,GraalGraphError transformAndAddContext,GraalError e,Node newNode){\r\n    GraalGraphError graphError;\r\n    if (e instanceof GraalGraphError) {\r\n        graphError = (GraalGraphError) e;\r\n    } else {\r\n        graphError = new GraalGraphError(e);\r\n    }\r\n    return graphError.addContext(newNode);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.type.FloatStamp.isNonNaN",
	"Comment": "returns true if nan is non included in the value described by this stamp.",
	"Method": "boolean isNonNaN(){\r\n    return nonNaN;\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.OptimizedOSRLoopNodeTest.testStackFrameNodes",
	"Comment": "test that graal stack frame instances have call nodes associated even when there are osrframes on the stack.",
	"Method": "void testStackFrameNodes(OSRLoopFactory factory){\r\n    TestOSRStackTraceFromAbove testOSRStackTrace = new TestOSRStackTraceFromAbove();\r\n    TestRootNode rootNode = new TestRootNode(factory, testOSRStackTrace);\r\n    OptimizedCallTarget target = (OptimizedCallTarget) runtime.createCallTarget(rootNode);\r\n    rootNode.forceOSR();\r\n    target.call(1);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.InliningLog.replaceLog",
	"Comment": "completely replace the current log with the copy of the specified log.the precondition is that the current inlining log is completely empty. this is usually calledwhen copying the entire graph.",
	"Method": "void replaceLog(UnmodifiableEconomicMap<Node, Node> replacements,InliningLog replacementLog){\r\n    assert root.decisions.isEmpty();\r\n    assert root.children.isEmpty();\r\n    assert leaves.isEmpty();\r\n    EconomicMap<Callsite, Callsite> mapping = EconomicMap.create(Equivalence.IDENTITY_WITH_SYSTEM_HASHCODE);\r\n    copyTree(root, replacementLog.root, replacements, mapping);\r\n    MapCursor<Invokable, Callsite> replacementEntries = replacementLog.leaves.getEntries();\r\n    while (replacementEntries.advance()) {\r\n        Invokable replacementInvoke = replacementEntries.getKey();\r\n        Callsite replacementSite = replacementEntries.getValue();\r\n        if (replacementInvoke.isAlive()) {\r\n            Invokable invoke = (Invokable) replacements.get((Node) replacementInvoke);\r\n            Callsite site = mapping.get(replacementSite);\r\n            leaves.put(invoke, site);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.replacements.InstanceOfSnippets.instanceofDynamic",
	"Comment": "type test used when the type being tested against is not known at compile time.",
	"Method": "Object instanceofDynamic(KlassPointer hub,Object object,Object trueValue,Object falseValue,boolean allowNull,Counters counters){\r\n    if (probability(NOT_FREQUENT_PROBABILITY, object == null)) {\r\n        counters.isNull.inc();\r\n        if (allowNull) {\r\n            return trueValue;\r\n        } else {\r\n            return falseValue;\r\n        }\r\n    }\r\n    GuardingNode anchorNode = SnippetAnchorNode.anchor();\r\n    KlassPointer nonNullObjectHub = loadHubIntrinsic(PiNode.piCastNonNull(object, anchorNode));\r\n    if (BranchProbabilityNode.probability(BranchProbabilityNode.FAST_PATH_PROBABILITY, !hub.isNull())) {\r\n        if (checkUnknownSubType(hub, nonNullObjectHub, counters)) {\r\n            return trueValue;\r\n        }\r\n    }\r\n    return falseValue;\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.util.BlockWorkList.add",
	"Comment": "adds a block to this list in an unsorted fashion, like a stack.",
	"Method": "void add(AbstractMergeNode block){\r\n    if (workList == null) {\r\n        allocate();\r\n    } else if (workListIndex == workList.length) {\r\n        grow();\r\n    }\r\n    workList[workListIndex++] = block;\r\n}"
}, {
	"Path": "org.graalvm.word.LocationIdentity.overlaps",
	"Comment": "returns true if the memory slice denoted by this location identity may overlap with theprovided other location identity.",
	"Method": "boolean overlaps(LocationIdentity other){\r\n    return isAny() || other.isAny() || this.equals(other);\r\n}"
}, {
	"Path": "org.graalvm.compiler.bytecode.BytecodeSwitch.defaultOffset",
	"Comment": "gets the offset from the start of the switch instruction to the default switch target.",
	"Method": "int defaultOffset(){\r\n    return stream.readInt(alignedBci);\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.PhaseSuite.removePhase",
	"Comment": "removes the first instance of the given phase class, looking recursively into inner phasesuites.",
	"Method": "boolean removePhase(Class<? extends BasePhase<? super C>> phaseClass){\r\n    ListIterator<BasePhase<? super C>> it = phases.listIterator();\r\n    while (it.hasNext()) {\r\n        BasePhase<? super C> phase = it.next();\r\n        if (phaseClass.isInstance(phase)) {\r\n            it.remove();\r\n            return true;\r\n        } else if (phase instanceof PhaseSuite) {\r\n            PhaseSuite<C> innerSuite = (PhaseSuite<C>) phase;\r\n            if (innerSuite.removePhase(phaseClass)) {\r\n                if (innerSuite.phases.isEmpty()) {\r\n                    it.remove();\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.compiler.loop.LoopsData.checkLoopOrder",
	"Comment": "checks that loops are ordered such that outer loops appear first.",
	"Method": "boolean checkLoopOrder(Iterable<Loop<Block>> loops){\r\n    EconomicSet<Loop<Block>> seen = EconomicSet.create(Equivalence.IDENTITY);\r\n    for (Loop<Block> loop : loops) {\r\n        if (loop.getParent() != null && !seen.contains(loop.getParent())) {\r\n            return false;\r\n        }\r\n        seen.add(loop);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodeinfo.processor.GraphNodeProcessor.reportException",
	"Comment": "bugs in an annotation processor can cause silent failure so try to report any exceptionthrows as errors.",
	"Method": "void reportException(Kind kind,Element element,Throwable t){\r\n    StringWriter buf = new StringWriter();\r\n    t.printStackTrace(new PrintWriter(buf));\r\n    message(kind, element, \"Exception thrown during processing: %s\", buf.toString());\r\n}"
}, {
	"Path": "jdk.tools.jaotc.binformat.macho.MachOSymtab.calcSizes",
	"Comment": "return the file size taken up by symbol table entries and strings",
	"Method": "int calcSizes(){\r\n    int stroff;\r\n    stroff = symtabCmd.getInt(symtab_command.symoff.off) + (nlist_64.totalsize * symbolCount);\r\n    symtabCmd.putInt(symtab_command.nsyms.off, symbolCount);\r\n    symtabCmd.putInt(symtab_command.stroff.off, stroff);\r\n    symtabCmd.putInt(symtab_command.strsize.off, strTabNrOfBytes);\r\n    symtabDataSize = (nlist_64.totalsize * symbolCount) + strTabNrOfBytes;\r\n    return (symtabDataSize);\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.sparc.SPARCAssembler.getXBit",
	"Comment": "helper method to determine if the instruction needs the x bit set.",
	"Method": "int getXBit(Op3s op3){\r\n    switch(op3) {\r\n        case Sllx:\r\n        case Srax:\r\n        case Srlx:\r\n            return 1 << 12;\r\n        default:\r\n            return 0;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.tutorial.InvokeGraal.compileAndInstallMethod",
	"Comment": "the simplest way to compile a method, using the default behavior for everything.",
	"Method": "InstalledCode compileAndInstallMethod(ResolvedJavaMethod method){\r\n    CompilationIdentifier compilationId = backend.getCompilationIdentifier(method);\r\n    OptionValues options = getInitialOptions();\r\n    DebugContext debug = DebugContext.create(options, DebugHandlersFactory.LOADER);\r\n    try (DebugContext.Scope s = debug.scope(\"compileAndInstallMethod\", new DebugDumpScope(String.valueOf(compilationId), true))) {\r\n        StructuredGraph graph = new StructuredGraph.Builder(options, debug, AllowAssumptions.YES).method(method).compilationId(compilationId).build();\r\n        PhaseSuite<HighTierContext> graphBuilderSuite = backend.getSuites().getDefaultGraphBuilderSuite();\r\n        Suites suites = backend.getSuites().getDefaultSuites(options);\r\n        LIRSuites lirSuites = backend.getSuites().getDefaultLIRSuites(options);\r\n        OptimisticOptimizations optimisticOpts = OptimisticOptimizations.ALL;\r\n        ProfilingInfo profilingInfo = graph.getProfilingInfo(method);\r\n        CompilationResult compilationResult = new CompilationResult(graph.compilationId());\r\n        CompilationResultBuilderFactory factory = CompilationResultBuilderFactory.Default;\r\n        GraalCompiler.compileGraph(graph, method, providers, backend, graphBuilderSuite, optimisticOpts, profilingInfo, suites, lirSuites, compilationResult, factory, true);\r\n        return backend.addInstalledCode(debug, method, asCompilationRequest(compilationId), compilationResult);\r\n    } catch (Throwable ex) {\r\n        throw debug.handle(ex);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.NamedLocationIdentity.getArrayLocation",
	"Comment": "returns the named location identity for an array of the given element kind. array accesses ofthe same kind must have the same location identity unless an alias analysis guarantees thattwo distinct arrays are accessed.",
	"Method": "LocationIdentity getArrayLocation(JavaKind elementKind){\r\n    return ARRAY_LOCATIONS.get(elementKind);\r\n}"
}, {
	"Path": "org.graalvm.polyglot.Engine.findActiveEngines",
	"Comment": "used internally to find all active engines. do not hold on to the returned collectionpermanently as this may cause memory leaks.",
	"Method": "Collection<Engine> findActiveEngines(Collection<Engine> findActiveEngines){\r\n    return getImpl().findActiveEngines();\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.lsra.Interval.getIntervalCoveringOpId",
	"Comment": "returns the interval that covers the given opid or null if there is none",
	"Method": "Interval getIntervalCoveringOpId(int opId){\r\n    assert opId >= 0 : \"invalid opId\";\r\n    assert opId < to() : \"can only look into the past\";\r\n    if (opId >= from()) {\r\n        return this;\r\n    }\r\n    Interval parent = splitParent();\r\n    Interval result = null;\r\n    assert !parent.splitChildren.isEmpty() : \"no split children available\";\r\n    int len = parent.splitChildren.size();\r\n    for (int i = len - 1; i >= 0; i--) {\r\n        Interval cur = parent.splitChildren.get(i);\r\n        if (cur.from() <= opId && opId < cur.to()) {\r\n            assert result == null : \"covered by multiple split children \" + result + \" and \" + cur;\r\n            result = cur;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.replacements.InstanceOfSnippets.instanceofWithProfile",
	"Comment": "a test against a set of hints derived from a profile with 100% precise coverage of seentypes. this snippet deoptimizes on hint miss paths.",
	"Method": "Object instanceofWithProfile(Object object,KlassPointer[] hints,boolean[] hintIsPositive,Object trueValue,Object falseValue,boolean nullSeen,Counters counters){\r\n    if (probability(NOT_FREQUENT_PROBABILITY, object == null)) {\r\n        counters.isNull.inc();\r\n        if (!nullSeen) {\r\n            DeoptimizeNode.deopt(InvalidateReprofile, OptimizedTypeCheckViolated);\r\n        }\r\n        return falseValue;\r\n    }\r\n    GuardingNode anchorNode = SnippetAnchorNode.anchor();\r\n    KlassPointer objectHub = loadHubIntrinsic(PiNode.piCastNonNull(object, anchorNode));\r\n    ExplodeLoopNode.explodeLoop();\r\n    for (int i = 0; i < hints.length; i++) {\r\n        KlassPointer hintHub = hints[i];\r\n        boolean positive = hintIsPositive[i];\r\n        if (probability(LIKELY_PROBABILITY, hintHub.equal(objectHub))) {\r\n            counters.hintsHit.inc();\r\n            return positive ? trueValue : falseValue;\r\n        }\r\n        counters.hintsMiss.inc();\r\n    }\r\n    DeoptimizeNode.deopt(DeoptimizationAction.InvalidateReprofile, OptimizedTypeCheckViolated);\r\n    return falseValue;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.FindUniqueDefaultMethodTest.testInherited",
	"Comment": "this test illustrates a common pattern where a method at the root of a hierarchy is the onlyimplementation and can be statically inlined.",
	"Method": "void testInherited(){\r\n    Subclass2 s = new Subclass2();\r\n    testConstantReturn(\"runInherited\", 1);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.test.AArch64MultiplyAddSubTest.mulSubInt",
	"Comment": "multiplyaddsub match rule test for sub operation with int type.",
	"Method": "int mulSubInt(int input0,int input1,int input2){\r\n    return input2 - input0 * input1;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext.parsingIntrinsic",
	"Comment": "determines if this parsing context is within the bytecode of an intrinsic or a method inlinedby an intrinsic.",
	"Method": "boolean parsingIntrinsic(){\r\n    return getIntrinsic() != null;\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.runtime.GraalCompilerDirectives.inFirstTier",
	"Comment": "returns a boolean value indicating whether the method is executed in the first tier trufflecompilation.",
	"Method": "boolean inFirstTier(){\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.polyglot.tck.TypeDescriptor.executable",
	"Comment": "creates a new executable type with a given return type and parameter types.",
	"Method": "TypeDescriptor executable(TypeDescriptor returnType,TypeDescriptor parameterTypes,TypeDescriptor executable,TypeDescriptor returnType,boolean vararg,TypeDescriptor parameterTypes){\r\n    Objects.requireNonNull(returnType, \"Return type cannot be null\");\r\n    Objects.requireNonNull(parameterTypes, \"Parameter types cannot be null\");\r\n    if (isAny(returnType.impl) && parameterTypes.length == 0 && vararg) {\r\n        return EXECUTABLE;\r\n    }\r\n    final List<TypeDescriptorImpl> paramTypeImpls = new ArrayList(parameterTypes.length);\r\n    for (TypeDescriptor td : parameterTypes) {\r\n        Objects.requireNonNull(td, \"Parameter types cannot contain null\");\r\n        paramTypeImpls.add(td.impl);\r\n    }\r\n    return new TypeDescriptor(new ExecutableImpl(ExecutableImpl.Kind.UNIT, isAny(returnType.impl) ? null : returnType.impl, vararg, paramTypeImpls));\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.alloc.ComputeBlockOrder.enqueueSuccessors",
	"Comment": "add successor blocks into the given work list if they are not already marked as visited.",
	"Method": "void enqueueSuccessors(T block,PriorityQueue<T> worklist,BitSet visitedBlocks){\r\n    for (T successor : block.getSuccessors()) {\r\n        if (!visitedBlocks.get(successor.getId())) {\r\n            visitedBlocks.set(successor.getId());\r\n            worklist.add(successor);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.stubs.UnwindExceptionToCallerStub.assertionsEnabled",
	"Comment": "determines if either java assertions are enabled for graal or if this is a hotspot buildwhere the assert mechanism is enabled.",
	"Method": "boolean assertionsEnabled(GraalHotSpotVMConfig config){\r\n    return Assertions.assertionsEnabled() || cAssertionsEnabled(config);\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.test.CompilationWrapperTest.testTruffleCompilation3",
	"Comment": "tests that truffleperformancewarningsarefatal generates diagnostic output.",
	"Method": "void testTruffleCompilation3(){\r\n    assumeManagementLibraryIsLoadable();\r\n    Probe[] probes = { new Probe(\"Exiting VM due to TrufflePerformanceWarningsAreFatal=true\", 1) };\r\n    testHelper(Arrays.asList(probes), Arrays.asList(\"-Dgraal.CompilationFailureAction=Silent\", \"-Dgraal.TrufflePerformanceWarningsAreFatal=true\", \"-Dgraal.CrashAt=root test1:PermanentBailout\"), \"org.graalvm.compiler.truffle.test.SLTruffleGraalTestSuite\", \"test\");\r\n}"
}, {
	"Path": "org.graalvm.compiler.bytecode.Bytecodes.stackEffectOf",
	"Comment": "gets the effect on the depth of the expression stack of an instruction denoted by a givenopcode.",
	"Method": "int stackEffectOf(int opcode){\r\n    return stackEffectArray[opcode & 0xff];\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.cfg.Loop.transitiveParentLoop",
	"Comment": "determines if one loop is a transitive parent of another loop.",
	"Method": "boolean transitiveParentLoop(Loop<T> childLoop,Loop<T> parentLoop){\r\n    Loop<T> curr = childLoop;\r\n    while (curr != null) {\r\n        if (curr == parentLoop) {\r\n            return true;\r\n        }\r\n        curr = curr.getParent();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.lsra.LinearScan.attributes",
	"Comment": "gets an object describing the attributes of a given register according to this registerconfiguration.",
	"Method": "RegisterAttributes attributes(Register reg){\r\n    return registerAttributes[reg.number];\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.aarch64.AArch64Assembler.blr",
	"Comment": "branches to address in register and writes return address into register x30.",
	"Method": "void blr(Register reg){\r\n    unconditionalBranchRegInstruction(BLR, reg);\r\n}"
}, {
	"Path": "org.graalvm.compiler.code.CompilationResult.setFields",
	"Comment": "sets the fields that were referenced from the bytecodes that were used as input to thecompilation.",
	"Method": "void setFields(EconomicSet<ResolvedJavaField> accessedFields){\r\n    if (accessedFields != null) {\r\n        fields = accessedFields.toArray(new ResolvedJavaField[accessedFields.size()]);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.trace.lsra.TraceInterval.logString",
	"Comment": "gets a single line string for logging the details of this interval to a log stream.",
	"Method": "String logString(){\r\n    StringBuilder buf = new StringBuilder(100);\r\n    buf.append(\"any \").append(operandNumber).append(':').append(operand).append(' ');\r\n    if (!isRegister(operand)) {\r\n        if (location != null) {\r\n            buf.append(\"location{\").append(location).append(\"} \");\r\n        }\r\n    }\r\n    buf.append(\"hints{\").append(splitParent.operandNumber);\r\n    IntervalHint hint = locationHint(false);\r\n    if (hint != null) {\r\n        buf.append(\", \").append(hint.location());\r\n    }\r\n    buf.append(\"} ranges{\");\r\n    buf.append(\"[\" + from() + \", \" + to() + \"]\");\r\n    buf.append(\"} uses{\");\r\n    int prev = -1;\r\n    for (int i = numUsePos() - 1; i >= 0; --i) {\r\n        assert prev < getUsePos(i) : \"use positions not sorted\";\r\n        if (i != numUsePos() - 1) {\r\n            buf.append(\", \");\r\n        }\r\n        buf.append(getUsePos(i)).append(':').append(getUsePosRegisterPriority(i).shortName());\r\n        prev = getUsePos(i);\r\n    }\r\n    buf.append(\"} spill-state{\").append(spillState()).append(\"}\");\r\n    if (canMaterialize()) {\r\n        buf.append(\" (remat:\").append(getMaterializedValue().toString()).append(\")\");\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.test.ShortCircuitOrNodeTest.testCascadeSnippet1",
	"Comment": "we cannot trust subword inputs. parameter declared as boolean will have a stamp of int32.",
	"Method": "boolean testCascadeSnippet1(Boolean a,Boolean b){\r\n    return shortCircuitOr(shortCircuitOr(a, b), a);\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.asm.CompilationResultBuilder.asObjectConstRef",
	"Comment": "returns the address of an object constant that is embedded as a data reference into the code.",
	"Method": "AbstractAddress asObjectConstRef(JavaConstant value){\r\n    assert value.getJavaKind() == JavaKind.Object;\r\n    return recordDataReferenceInCode(value, 8);\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.test.CompilationWrapperTest.testTruffleCompilation2",
	"Comment": "tests that trufflecompilationexceptionsarefatal works as expected.",
	"Method": "void testTruffleCompilation2(){\r\n    Probe[] probes = { new Probe(\"Exiting VM due to TruffleCompilationExceptionsAreFatal=true\", 1) };\r\n    testHelper(Arrays.asList(probes), Arrays.asList(\"-Dgraal.CompilationFailureAction=Silent\", \"-Dgraal.TruffleCompilationExceptionsAreFatal=true\", \"-Dgraal.CrashAt=root test1\"), \"org.graalvm.compiler.truffle.test.SLTruffleGraalTestSuite\", \"test\");\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.processor.APHotSpotSignature.fromPrimitiveOrVoidTypeChar",
	"Comment": "returns the kind from the character describing a primitive or void.",
	"Method": "TypeKind fromPrimitiveOrVoidTypeChar(char ch){\r\n    switch(ch) {\r\n        case 'Z':\r\n            return TypeKind.BOOLEAN;\r\n        case 'C':\r\n            return TypeKind.CHAR;\r\n        case 'F':\r\n            return TypeKind.FLOAT;\r\n        case 'D':\r\n            return TypeKind.DOUBLE;\r\n        case 'B':\r\n            return TypeKind.BYTE;\r\n        case 'S':\r\n            return TypeKind.SHORT;\r\n        case 'I':\r\n            return TypeKind.INT;\r\n        case 'J':\r\n            return TypeKind.LONG;\r\n        case 'V':\r\n            return TypeKind.VOID;\r\n    }\r\n    throw new IllegalArgumentException(\"unknown primitive or void type character: \" + ch);\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.common.inlining.walker.ComputeInliningRelevance.getMaxProbabilityLoopExit",
	"Comment": "returns the most probable loop exit. if multiple successors share the maximum probability,one is returned and the others are enqueued in pathbeginnodes.",
	"Method": "Node getMaxProbabilityLoopExit(LoopBeginNode loopBegin,ArrayList<FixedNode> pathBeginNodes){\r\n    Node maxSux = null;\r\n    double maxProbability = 0.0;\r\n    int pathBeginCount = pathBeginNodes.size();\r\n    for (LoopExitNode sux : loopBegin.loopExits()) {\r\n        double probability = nodeProbabilities.applyAsDouble(sux);\r\n        if (probability > maxProbability) {\r\n            maxProbability = probability;\r\n            maxSux = sux;\r\n            truncate(pathBeginNodes, pathBeginCount);\r\n        } else if (probability == maxProbability) {\r\n            pathBeginNodes.add(sux);\r\n        }\r\n    }\r\n    return maxSux;\r\n}"
}, {
	"Path": "org.graalvm.nativeimage.ProcessProperties.destroyForcibly",
	"Comment": "kills the process forcibly. the process represented by the given process id is forciblyterminated. forcible process destruction is defined as the immediate termination of aprocess, whereas normal termination allows the process to shut down cleanly.",
	"Method": "void destroyForcibly(long processID){\r\n    ImageSingletons.lookup(ProcessPropertiesSupport.class).destroyForcibly(processID);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.alloc.ComputeBlockOrder.checkOrder",
	"Comment": "checks that the ordering contains the expected number of blocks.",
	"Method": "boolean checkOrder(List<? extends AbstractBlockBase<?>> order,int expectedBlockCount){\r\n    assert order.size() == expectedBlockCount : String.format(\"Number of blocks in ordering (%d) does not match expected block count (%d)\", order.size(), expectedBlockCount);\r\n    return true;\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.tregex.nodesplitter.DFANodeSplit.updateDFAGenerator",
	"Comment": "register all changes made in the dfa generator. this is necessary for gathering debuginformation only, never do this in production!",
	"Method": "void updateDFAGenerator(){\r\n    dfaGenerator.nodeSplitSetNewDFASize(graph.size());\r\n    for (GraphNode node : graph.getNodes()) {\r\n        node.registerDuplicate(dfaGenerator);\r\n    }\r\n    for (GraphNode node : graph.getNodes()) {\r\n        node.updateSuccessors(dfaGenerator);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.match.MatchPattern.matchUsage",
	"Comment": "match any named nodes and ensure that the consumed nodes can be safely merged.",
	"Method": "Result matchUsage(Node node,MatchContext context,Result matchUsage,Node node,MatchContext context,boolean atRoot){\r\n    Result result = matchType(node);\r\n    if (result != Result.OK) {\r\n        return result;\r\n    }\r\n    if (singleUser && !atRoot) {\r\n        result = context.consume(node);\r\n        if (result != Result.OK) {\r\n            return result;\r\n        }\r\n    }\r\n    if (name != null) {\r\n        result = context.captureNamedValue(name, nodeClass, node);\r\n    }\r\n    for (int input = 0; input < patterns.length; input++) {\r\n        result = patterns[input].matchUsage(getInput(input, node), context, false);\r\n        if (result != Result.OK) {\r\n            return result;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.LIRInstruction.addStackSlotsToTemporaries",
	"Comment": "utility method to add stack arguments to a list of temporaries. useful for modeling callingconventions that kill outgoing argument space.",
	"Method": "Value[] addStackSlotsToTemporaries(Value[] parameters,Value[] temporaries){\r\n    int extraTemps = 0;\r\n    for (Value p : parameters) {\r\n        if (isStackSlot(p)) {\r\n            extraTemps++;\r\n        }\r\n        assert !isVirtualStackSlot(p) : \"only real stack slots in calling convention\";\r\n    }\r\n    if (extraTemps != 0) {\r\n        int index = temporaries.length;\r\n        Value[] newTemporaries = Arrays.copyOf(temporaries, temporaries.length + extraTemps);\r\n        for (Value p : parameters) {\r\n            if (isStackSlot(p)) {\r\n                newTemporaries[index++] = p;\r\n            }\r\n        }\r\n        return newTemporaries;\r\n    }\r\n    return temporaries;\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.ExplodeLoopBlockDuplicationTest.testBlockDuplication",
	"Comment": "test that polymorphic caches duplicate the cached block and can therefore resolve theabstract method call and resolve the result to a constant.",
	"Method": "void testBlockDuplication(){\r\n    OptimizedCallTarget target = (OptimizedCallTarget) Truffle.getRuntime().createCallTarget(new ObjectCacheTestRootNode());\r\n    AbstractType value1 = new ConcreteType1();\r\n    AbstractType value2 = new ConcreteType2();\r\n    target.call(value1);\r\n    target.call(value2);\r\n    target.compile(true);\r\n    assertCompiled(target);\r\n    target.call(value1);\r\n    target.call(value2);\r\n    assertCompiled(target);\r\n}"
}, {
	"Path": "com.alibaba.json.test.Base64.decode",
	"Comment": "decodes a base64 encoded byte array. all illegal characters will be ignored and can handle both arrays with\tand without line separators.",
	"Method": "byte[] decode(char[] sArr,byte[] decode,byte[] sArr,byte[] decode,String str){\r\n    int sLen = str != null ? str.length() : 0;\r\n    if (sLen == 0)\r\n        return new byte[0];\r\n    int sepCnt = 0;\r\n    for (int i = 0; i < sLen; i++) if (IA[str.charAt(i)] < 0)\r\n        sepCnt++;\r\n    if ((sLen - sepCnt) % 4 != 0)\r\n        return null;\r\n    int pad = 0;\r\n    for (int i = sLen; i > 1 && IA[str.charAt(--i)] <= 0; ) if (str.charAt(i) == '=')\r\n        pad++;\r\n    int len = ((sLen - sepCnt) * 6 >> 3) - pad;\r\n    byte[] dArr = new byte[len];\r\n    for (int s = 0, d = 0; d < len; ) {\r\n        int i = 0;\r\n        for (int j = 0; j < 4; j++) {\r\n            int c = IA[str.charAt(s++)];\r\n            if (c >= 0)\r\n                i |= c << (18 - j * 6);\r\n            else\r\n                j--;\r\n        }\r\n        dArr[d++] = (byte) (i >> 16);\r\n        if (d < len) {\r\n            dArr[d++] = (byte) (i >> 8);\r\n            if (d < len)\r\n                dArr[d++] = (byte) i;\r\n        }\r\n    }\r\n    return dArr;\r\n}"
}, {
	"Path": "org.graalvm.options.OptionType.defaultType",
	"Comment": "returns the default option type for a class. returns null if no default optiontype is available for this java type.",
	"Method": "OptionType<T> defaultType(T value,OptionType<T> defaultType,Class<T> clazz){\r\n    return (OptionType<T>) DEFAULTTYPES.get(clazz);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.virtual.VirtualObjectNode.hasIdentity",
	"Comment": "specifies whether this virtual object has an object identity. if not, then the result of acomparison of two virtual objects is determined by comparing their contents.",
	"Method": "boolean hasIdentity(){\r\n    return hasIdentity;\r\n}"
}, {
	"Path": "org.graalvm.compiler.virtual.phases.ea.PartialEscapeBlockState.materializeBefore",
	"Comment": "materializes the given virtual object and produces the necessary effects in the effects list.this transitively also materializes all other virtual objects that are reachable from theentries.",
	"Method": "void materializeBefore(FixedNode fixed,VirtualObjectNode virtual,GraphEffectList materializeEffects){\r\n    PartialEscapeClosure.COUNTER_MATERIALIZATIONS.increment(fixed.getDebug());\r\n    List<AllocatedObjectNode> objects = new ArrayList(2);\r\n    List<ValueNode> values = new ArrayList(8);\r\n    List<List<MonitorIdNode>> locks = new ArrayList();\r\n    List<ValueNode> otherAllocations = new ArrayList(2);\r\n    List<Boolean> ensureVirtual = new ArrayList(2);\r\n    materializeWithCommit(fixed, virtual, objects, locks, values, ensureVirtual, otherAllocations);\r\n    materializeEffects.addVirtualizationDelta(-(objects.size() + otherAllocations.size()));\r\n    materializeEffects.add(\"materializeBefore\", new Effect() {\r\n        @Override\r\n        public void apply(StructuredGraph graph, ArrayList<Node> obsoleteNodes) {\r\n            for (ValueNode alloc : otherAllocations) {\r\n                ValueNode otherAllocation = graph.addOrUniqueWithInputs(alloc);\r\n                if (otherAllocation instanceof FixedWithNextNode) {\r\n                    graph.addBeforeFixed(fixed, (FixedWithNextNode) otherAllocation);\r\n                } else {\r\n                    assert otherAllocation instanceof FloatingNode;\r\n                }\r\n            }\r\n            if (!objects.isEmpty()) {\r\n                CommitAllocationNode commit;\r\n                if (fixed.predecessor() instanceof CommitAllocationNode) {\r\n                    commit = (CommitAllocationNode) fixed.predecessor();\r\n                } else {\r\n                    try (DebugCloseable context = graph.withNodeSourcePosition(NodeSourcePosition.placeholder(graph.method()))) {\r\n                        commit = graph.add(new CommitAllocationNode());\r\n                        graph.addBeforeFixed(fixed, commit);\r\n                    }\r\n                }\r\n                for (AllocatedObjectNode obj : objects) {\r\n                    graph.addWithoutUnique(obj);\r\n                    commit.getVirtualObjects().add(obj.getVirtualObject());\r\n                    obj.setCommit(commit);\r\n                }\r\n                for (ValueNode value : values) {\r\n                    commit.getValues().add(graph.addOrUniqueWithInputs(value));\r\n                }\r\n                for (List<MonitorIdNode> monitorIds : locks) {\r\n                    commit.addLocks(monitorIds);\r\n                }\r\n                commit.getEnsureVirtual().addAll(ensureVirtual);\r\n                assert commit.usages().filter(AllocatedObjectNode.class).count() == commit.getUsageCount();\r\n                List<AllocatedObjectNode> materializedValues = commit.usages().filter(AllocatedObjectNode.class).snapshot();\r\n                for (int i = 0; i < commit.getValues().size(); i++) {\r\n                    if (materializedValues.contains(commit.getValues().get(i))) {\r\n                        commit.getValues().set(i, ((AllocatedObjectNode) commit.getValues().get(i)).getVirtualObject());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.graalvm.compiler.virtual.phases.ea.PartialEscapeBlockState.materializeBefore",
	"Comment": "materializes the given virtual object and produces the necessary effects in the effects list.this transitively also materializes all other virtual objects that are reachable from theentries.",
	"Method": "void materializeBefore(FixedNode fixed,VirtualObjectNode virtual,GraphEffectList materializeEffects){\r\n    for (ValueNode alloc : otherAllocations) {\r\n        ValueNode otherAllocation = graph.addOrUniqueWithInputs(alloc);\r\n        if (otherAllocation instanceof FixedWithNextNode) {\r\n            graph.addBeforeFixed(fixed, (FixedWithNextNode) otherAllocation);\r\n        } else {\r\n            assert otherAllocation instanceof FloatingNode;\r\n        }\r\n    }\r\n    if (!objects.isEmpty()) {\r\n        CommitAllocationNode commit;\r\n        if (fixed.predecessor() instanceof CommitAllocationNode) {\r\n            commit = (CommitAllocationNode) fixed.predecessor();\r\n        } else {\r\n            try (DebugCloseable context = graph.withNodeSourcePosition(NodeSourcePosition.placeholder(graph.method()))) {\r\n                commit = graph.add(new CommitAllocationNode());\r\n                graph.addBeforeFixed(fixed, commit);\r\n            }\r\n        }\r\n        for (AllocatedObjectNode obj : objects) {\r\n            graph.addWithoutUnique(obj);\r\n            commit.getVirtualObjects().add(obj.getVirtualObject());\r\n            obj.setCommit(commit);\r\n        }\r\n        for (ValueNode value : values) {\r\n            commit.getValues().add(graph.addOrUniqueWithInputs(value));\r\n        }\r\n        for (List<MonitorIdNode> monitorIds : locks) {\r\n            commit.addLocks(monitorIds);\r\n        }\r\n        commit.getEnsureVirtual().addAll(ensureVirtual);\r\n        assert commit.usages().filter(AllocatedObjectNode.class).count() == commit.getUsageCount();\r\n        List<AllocatedObjectNode> materializedValues = commit.usages().filter(AllocatedObjectNode.class).snapshot();\r\n        for (int i = 0; i < commit.getValues().size(); i++) {\r\n            if (materializedValues.contains(commit.getValues().get(i))) {\r\n                commit.getValues().set(i, ((AllocatedObjectNode) commit.getValues().get(i)).getVirtualObject());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.InvokeWithExceptionNode.replaceWithInvoke",
	"Comment": "replaces this invokewithexceptionnode with a normal invokenode. kills the exception dispatchcode.",
	"Method": "InvokeNode replaceWithInvoke(){\r\n    InvokeNode newInvoke = graph().add(new InvokeNode(callTarget, bci, stamp, getLocationIdentity()));\r\n    newInvoke.setStateAfter(stateAfter);\r\n    newInvoke.setStateDuring(stateDuring);\r\n    AbstractBeginNode oldException = this.exceptionEdge;\r\n    graph().replaceSplitWithFixed(this, newInvoke, this.next());\r\n    GraphUtil.killCFG(oldException);\r\n    return newInvoke;\r\n}"
}, {
	"Path": "org.graalvm.nativeimage.ProcessProperties.destroy",
	"Comment": "kills the process. whether the process represented by the given process id is normallyterminated or not is implementation dependent.",
	"Method": "void destroy(long processID){\r\n    ImageSingletons.lookup(ProcessPropertiesSupport.class).destroy(processID);\r\n}"
}, {
	"Path": "org.graalvm.compiler.test.SubprocessUtil.getVMCommandLine",
	"Comment": "gets the command line used to start the current java vm, including all vm arguments, but notincluding the main class or any java arguments. this can be used to spawn an identical vm,but running different java code.",
	"Method": "List<String> getVMCommandLine(){\r\n    List<String> args = getProcessCommandLine();\r\n    if (args == null) {\r\n        return null;\r\n    } else {\r\n        int index = findMainClassIndex(args);\r\n        return args.subList(0, index);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.common.inlining.InliningUtil.getNodeCount",
	"Comment": "this method exclude instrumentationnode from inlining heuristics.",
	"Method": "int getNodeCount(StructuredGraph graph){\r\n    return graph.getNodeCount();\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.calc.BinaryArithmeticNode.shouldSwapInputs",
	"Comment": "determines if it would be better to swap the inputs in order to produce better assembly code.first we try to pick a value which is dead after this use. if both values are dead at thisuse then we try pick an induction variable phi to encourage the phi to live in a singleregister.",
	"Method": "boolean shouldSwapInputs(NodeValueMap nodeValueMap){\r\n    final boolean xHasOtherUsages = getX().hasUsagesOtherThan(this, nodeValueMap);\r\n    final boolean yHasOtherUsages = getY().hasUsagesOtherThan(this, nodeValueMap);\r\n    if (!getY().isConstant() && !yHasOtherUsages) {\r\n        if (xHasOtherUsages == yHasOtherUsages) {\r\n            return getY() instanceof ValuePhiNode && getY().inputs().contains(this);\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.collections.EconomicSet.create",
	"Comment": "creates a new set guaranteeing insertion order when iterating over its elements and insertsall elements of the specified collection.",
	"Method": "EconomicSet<E> create(EconomicSet<E> create,Equivalence strategy,EconomicSet<E> create,int initialCapacity,EconomicSet<E> create,UnmodifiableEconomicSet<E> c,EconomicSet<E> create,Equivalence strategy,int initialCapacity,EconomicSet<E> create,Equivalence strategy,UnmodifiableEconomicSet<E> c){\r\n    return EconomicMapImpl.create(strategy, c, true);\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.gen.LIRGenerator.resultOperandFor",
	"Comment": "gets the abi specific operand used to return a value of a given kind from a method.",
	"Method": "AllocatableValue resultOperandFor(JavaKind javaKind,ValueKind<?> valueKind){\r\n    Register reg = getRegisterConfig().getReturnRegister(javaKind);\r\n    assert target().arch.canStoreValue(reg.getRegisterCategory(), valueKind.getPlatformKind()) : reg.getRegisterCategory() + \" \" + valueKind.getPlatformKind();\r\n    return reg.asValue(valueKind);\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.common.LoweringPhase.checkPostLowering",
	"Comment": "checks that second lowering of a given graph did not introduce any new nodes.",
	"Method": "boolean checkPostLowering(StructuredGraph graph,PhaseContext context){\r\n    Mark expectedMark = graph.getMark();\r\n    lower(graph, context, LoweringMode.VERIFY_LOWERING);\r\n    Mark mark = graph.getMark();\r\n    assert mark.equals(expectedMark) : graph + \": a second round in the current lowering phase introduced these new nodes: \" + graph.getNewNodes(expectedMark).snapshot();\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.lsra.Interval.isEndMarker",
	"Comment": "returns true is this is the sentinel interval that denotes the end of an interval list.",
	"Method": "boolean isEndMarker(){\r\n    return operandNumber == END_MARKER_OPERAND_NUMBER;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.trace.TraceGlobalMoveResolver.block",
	"Comment": "mark assignedreg and assignedreghi of the interval as blocked",
	"Method": "void block(Value location){\r\n    if (mightBeBlocked(location)) {\r\n        assert areMultipleReadsAllowed() || valueBlocked(location) == 0 : \"location already marked as used: \" + location;\r\n        setValueBlocked(location, 1);\r\n        debug.log(\"block %s\", location);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.common.inlining.walker.InliningData.getInlineInfo",
	"Comment": "determines if inlining is possible at the given invoke node.",
	"Method": "InlineInfo getInlineInfo(Invoke invoke){\r\n    final String failureMessage = InliningUtil.checkInvokeConditions(invoke);\r\n    if (failureMessage != null) {\r\n        InliningUtil.logNotInlinedMethod(invoke, failureMessage);\r\n        return null;\r\n    }\r\n    MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();\r\n    ResolvedJavaMethod targetMethod = callTarget.targetMethod();\r\n    if (callTarget.invokeKind() == CallTargetNode.InvokeKind.Special || targetMethod.canBeStaticallyBound()) {\r\n        return getExactInlineInfo(invoke, targetMethod);\r\n    }\r\n    assert callTarget.invokeKind().isIndirect();\r\n    ResolvedJavaType holder = targetMethod.getDeclaringClass();\r\n    if (!(callTarget.receiver().stamp(NodeView.DEFAULT) instanceof ObjectStamp)) {\r\n        return null;\r\n    }\r\n    ObjectStamp receiverStamp = (ObjectStamp) callTarget.receiver().stamp(NodeView.DEFAULT);\r\n    if (receiverStamp.alwaysNull()) {\r\n        return null;\r\n    }\r\n    ResolvedJavaType contextType = invoke.getContextType();\r\n    if (receiverStamp.type() != null) {\r\n        ResolvedJavaType receiverType = receiverStamp.type();\r\n        if (receiverType != null && holder.isAssignableFrom(receiverType)) {\r\n            holder = receiverType;\r\n            if (receiverStamp.isExactType()) {\r\n                assert targetMethod.getDeclaringClass().isAssignableFrom(holder) : holder + \" subtype of \" + targetMethod.getDeclaringClass() + \" for \" + targetMethod;\r\n                ResolvedJavaMethod resolvedMethod = holder.resolveConcreteMethod(targetMethod, contextType);\r\n                if (resolvedMethod != null) {\r\n                    return getExactInlineInfo(invoke, resolvedMethod);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (holder.isArray()) {\r\n        ResolvedJavaMethod resolvedMethod = holder.resolveConcreteMethod(targetMethod, contextType);\r\n        if (resolvedMethod != null) {\r\n            return getExactInlineInfo(invoke, resolvedMethod);\r\n        }\r\n    }\r\n    AssumptionResult<ResolvedJavaType> leafConcreteSubtype = holder.findLeafConcreteSubtype();\r\n    if (leafConcreteSubtype != null) {\r\n        ResolvedJavaMethod resolvedMethod = leafConcreteSubtype.getResult().resolveConcreteMethod(targetMethod, contextType);\r\n        if (resolvedMethod != null && leafConcreteSubtype.canRecordTo(callTarget.graph().getAssumptions())) {\r\n            return getAssumptionInlineInfo(invoke, resolvedMethod, leafConcreteSubtype);\r\n        }\r\n    }\r\n    AssumptionResult<ResolvedJavaMethod> concrete = holder.findUniqueConcreteMethod(targetMethod);\r\n    if (concrete != null && concrete.canRecordTo(callTarget.graph().getAssumptions())) {\r\n        return getAssumptionInlineInfo(invoke, concrete.getResult(), concrete);\r\n    }\r\n    return getTypeCheckedInlineInfo(invoke, targetMethod);\r\n}"
}, {
	"Path": "org.graalvm.collections.EconomicMap.create",
	"Comment": "creates a new map that guarantees insertion order on the key set and initializes with aspecified capacity.",
	"Method": "EconomicMap<K, V> create(EconomicMap<K, V> create,int initialCapacity,EconomicMap<K, V> create,Equivalence strategy,EconomicMap<K, V> create,UnmodifiableEconomicMap<K, V> m,EconomicMap<K, V> create,Equivalence strategy,UnmodifiableEconomicMap<K, V> m,EconomicMap<K, V> create,Equivalence strategy,int initialCapacity){\r\n    return EconomicMapImpl.create(strategy, initialCapacity, false);\r\n}"
}, {
	"Path": "org.graalvm.compiler.java.BytecodeParser.successorProbabilites",
	"Comment": "helper function that sums up the probabilities of all keys that lead to a specific successor.",
	"Method": "double[] successorProbabilites(int successorCount,int[] keySuccessors,double[] keyProbabilities){\r\n    double[] probability = new double[successorCount];\r\n    for (int i = 0; i < keySuccessors.length; i++) {\r\n        probability[keySuccessors[i]] += keyProbabilities[i];\r\n    }\r\n    return probability;\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.aarch64.AArch64Assembler.stxr",
	"Comment": "store address exclusive. natural alignment of address is required. rs and rt may not point tothe same register.",
	"Method": "void stxr(int size,Register rs,Register rt,Register rn){\r\n    assert size == 8 || size == 16 || size == 32 || size == 64;\r\n    int transferSize = NumUtil.log2Ceil(size / 8);\r\n    exclusiveStoreInstruction(STXR, rs, rt, rn, transferSize);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.GraalCompilerTest.getInitialOptions",
	"Comment": "gets the initial option values provided by the graal runtime. these are option valuestypically parsed from the command line.",
	"Method": "OptionValues getInitialOptions(){\r\n    return Graal.getRequiredCapability(OptionValues.class);\r\n}"
}, {
	"Path": "org.graalvm.compiler.java.FrameStateBuilder.popArguments",
	"Comment": "pop the specified number of slots off of this stack and return them as an array ofinstructions.",
	"Method": "ValueNode[] popArguments(int argSize){\r\n    ValueNode[] result = allocateArray(argSize);\r\n    for (int i = argSize - 1; i >= 0; i--) {\r\n        ValueNode x = xpop();\r\n        if (x == TWO_SLOT_MARKER) {\r\n            x = xpop();\r\n        }\r\n        assert x != null && x != TWO_SLOT_MARKER;\r\n        result[i] = x;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.util.TypeReader.getUVInt",
	"Comment": "reads an unsigned variable byte size encoded value that is known to fit into the range ofint.",
	"Method": "int getUVInt(){\r\n    return TypeConversion.asS4(getUV());\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.compiler.TruffleCompilerImpl.compileAST",
	"Comment": "compiles a truffle ast. if compilation succeeds, the ast will have compiled code associatedwith it that can be executed instead of interpreting the ast.",
	"Method": "void compileAST(DebugContext debug,CompilableTruffleAST compilable,TruffleInliningPlan inliningPlan,CompilationIdentifier compilationId,CancellableTruffleCompilationTask task,TruffleCompilerListener listener){\r\n    final CompilationPrinter printer = CompilationPrinter.begin(TruffleCompilerOptions.getOptions(), compilationId, new TruffleDebugJavaMethod(compilable), INVOCATION_ENTRY_BCI);\r\n    StructuredGraph graph = null;\r\n    try (CompilationAlarm alarm = CompilationAlarm.trackCompilationPeriod(TruffleCompilerOptions.getOptions())) {\r\n        PhaseSuite<HighTierContext> graphBuilderSuite = createGraphBuilderSuite();\r\n        SpeculationLog speculationLog = compilable.getSpeculationLog();\r\n        if (speculationLog != null) {\r\n            speculationLog.collectFailedSpeculations();\r\n        }\r\n        try (DebugCloseable a = PartialEvaluationTime.start(debug);\r\n            DebugCloseable c = PartialEvaluationMemUse.start(debug)) {\r\n            graph = partialEvaluator.createGraph(debug, compilable, inliningPlan, AllowAssumptions.YES, compilationId, speculationLog, task);\r\n        }\r\n        if (task != null && task.isCancelled()) {\r\n            return;\r\n        }\r\n        if (listener != null) {\r\n            listener.onTruffleTierFinished(compilable, inliningPlan, new GraphInfoImpl(graph));\r\n        }\r\n        String compilationName = compilable.toString() + (task != null && task.isFirstTier() ? TruffleCompiler.FIRST_TIER_COMPILATION_SUFFIX : TruffleCompiler.SECOND_TIER_COMPILATION_SUFFIX);\r\n        CompilationResult compilationResult = compilePEGraph(graph, compilationName, graphBuilderSuite, compilable, asCompilationRequest(compilationId), listener, task);\r\n        if (listener != null) {\r\n            listener.onSuccess(compilable, inliningPlan, new GraphInfoImpl(graph), new CompilationResultInfoImpl(compilationResult));\r\n        }\r\n        printer.finish(compilationResult);\r\n    } catch (Throwable t) {\r\n        if (listener != null) {\r\n            BailoutException bailout = t instanceof BailoutException ? (BailoutException) t : null;\r\n            boolean permanentBailout = bailout != null ? bailout.isPermanent() : false;\r\n            listener.onFailure(compilable, t.toString(), bailout != null, permanentBailout);\r\n        }\r\n        throw t;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.test.TimerKeyTest.spin",
	"Comment": "actively spins the current thread for at least a given number of milliseconds in such a waythat timers for the current thread keep ticking over.",
	"Method": "long spin(long ms){\r\n    long start = GraalServices.getCurrentThreadCpuTime();\r\n    do {\r\n        long durationMS = (GraalServices.getCurrentThreadCpuTime() - start) / 1000;\r\n        if (durationMS >= ms) {\r\n            return durationMS;\r\n        }\r\n    } while (true);\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.phases.aot.ReplaceConstantNodesPhase.tryToReplaceWithExisting",
	"Comment": "try to find dominating node doing the resolution that can be reused.",
	"Method": "void tryToReplaceWithExisting(StructuredGraph graph,ConstantNode node){\r\n    ScheduleResult schedule = graph.getLastSchedule();\r\n    NodeMap<Block> nodeToBlock = schedule.getNodeToBlockMap();\r\n    BlockMap<List<Node>> blockToNodes = schedule.getBlockToNodesMap();\r\n    EconomicMap<Block, Node> blockToExisting = EconomicMap.create();\r\n    for (Node n : node.usages().filter(n -> isReplacementNode(n))) {\r\n        blockToExisting.put(nodeToBlock.get(n), n);\r\n    }\r\n    for (Node use : node.usages().filter(n -> !isReplacementNode(n)).snapshot()) {\r\n        boolean replaced = false;\r\n        Block b = nodeToBlock.get(use);\r\n        Node e = blockToExisting.get(b);\r\n        if (e != null) {\r\n            for (Node n : blockToNodes.get(b)) {\r\n                if (n.equals(use)) {\r\n                    break;\r\n                }\r\n                if (n.equals(e)) {\r\n                    use.replaceFirstInput(node, e);\r\n                    replaced = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (!replaced) {\r\n            for (Block d : blockToExisting.getKeys()) {\r\n                if (strictlyDominates(d, b)) {\r\n                    use.replaceFirstInput(node, blockToExisting.get(d));\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.test.AArch64AddSubShiftTest.addLeftShiftLong",
	"Comment": "addsubshift match rule test for add operation with long type.",
	"Method": "long addLeftShiftLong(long input){\r\n    long output = (input << 5) + input;\r\n    output += output << -5;\r\n    output += output << 64;\r\n    return output;\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.phases.aot.ReplaceConstantNodesPhase.findInsertionPoint",
	"Comment": "find a good place to insert a stateful fixed node that is above the given node. a goodinsertion point should have a valid framestate reaching it.",
	"Method": "FixedWithNextNode findInsertionPoint(StructuredGraph graph,FrameStateMapperClosure stateMapper,FloatingNode node){\r\n    FixedWithNextNode fixed = findFixedBeforeFloating(graph, node);\r\n    FixedWithNextNode result = findFixedWithValidState(graph, stateMapper, fixed);\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.phases.aot.ReplaceConstantNodesPhase.replaceKlassesAndObjects",
	"Comment": "replace object and klass constants with resolution nodes or reuse preceding initializations.",
	"Method": "void replaceKlassesAndObjects(StructuredGraph graph,FrameStateMapperClosure stateMapper,ClassInfo classInfo){\r\n    new SchedulePhase(SchedulingStrategy.LATEST_OUT_OF_LOOPS, true).apply(graph, false);\r\n    for (ConstantNode node : getConstantNodes(graph)) {\r\n        Constant constant = node.asConstant();\r\n        if (constant instanceof HotSpotMetaspaceConstant && anyUsagesNeedReplacement(node)) {\r\n            handleHotSpotMetaspaceConstant(graph, stateMapper, node, classInfo);\r\n        } else if (constant instanceof HotSpotObjectConstant && anyUsagesNeedReplacement(node)) {\r\n            handleHotSpotObjectConstant(graph, stateMapper, node, classInfo);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.GraalCompilerTest.checkLowTierGraph",
	"Comment": "can be overridden by unit tests to verify properties of the graph.",
	"Method": "boolean checkLowTierGraph(StructuredGraph graph){\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.framemap.FrameMap.callsMethod",
	"Comment": "informs the frame map that the compiled code calls a particular method, which may need stackspace for outgoing arguments.",
	"Method": "void callsMethod(CallingConvention cc){\r\n    reserveOutgoing(cc.getStackSize());\r\n}"
}, {
	"Path": "jdk.tools.jaotc.binformat.ByteContainer.getByteStreamSize",
	"Comment": "return the current size of byte stream backing the binarycontainer.",
	"Method": "int getByteStreamSize(){\r\n    return contentStream.size();\r\n}"
}, {
	"Path": "org.graalvm.compiler.code.CompilationResult.setMethods",
	"Comment": "sets the methods whose bytecodes were used as input to the compilation.",
	"Method": "void setMethods(ResolvedJavaMethod rootMethod,Collection<ResolvedJavaMethod> inlinedMethods){\r\n    checkOpen();\r\n    assert rootMethod != null;\r\n    assert inlinedMethods != null;\r\n    if (inlinedMethods.contains(rootMethod)) {\r\n        methods = inlinedMethods.toArray(new ResolvedJavaMethod[inlinedMethods.size()]);\r\n        for (int i = 0; i < methods.length; i++) {\r\n            if (methods[i].equals(rootMethod)) {\r\n                if (i != 0) {\r\n                    ResolvedJavaMethod tmp = methods[0];\r\n                    methods[0] = methods[i];\r\n                    methods[i] = tmp;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        methods = new ResolvedJavaMethod[1 + inlinedMethods.size()];\r\n        methods[0] = rootMethod;\r\n        int i = 1;\r\n        for (ResolvedJavaMethod m : inlinedMethods) {\r\n            methods[i++] = m;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.cfg.AbstractBlockBase.getDominatorDepth",
	"Comment": "level in the dominator tree starting with 0 for the start block.",
	"Method": "int getDominatorDepth(){\r\n    return domDepth;\r\n}"
}, {
	"Path": "org.graalvm.polyglot.Value.toString",
	"Comment": "a string representation of the value formatted by the original language.",
	"Method": "String toString(){\r\n    return impl.toString(receiver);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.NamedLocationIdentity.mutable",
	"Comment": "creates a named unique location identity for read and write operations against mutablememory.",
	"Method": "NamedLocationIdentity mutable(String name){\r\n    return create(name, false);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.amd64.AMD64LIRGenerator.getVMPageSize",
	"Comment": "return a conservative estimate of the page size for use by the string.indexof intrinsic.",
	"Method": "int getVMPageSize(){\r\n    return 4096;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.test.AArch64MultiplyAddSubTest.mulAddLong",
	"Comment": "multiplyaddsub match rule test for add operation with long type.",
	"Method": "long mulAddLong(long input0,long input1,long input2){\r\n    return input0 * input1 + input2;\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.DebugContext.contextLookupTopdown",
	"Comment": "searches the current debug scope, top down, for a context object that is an instance of agiven type. the first such object found is returned.",
	"Method": "T contextLookupTopdown(Class<T> clazz){\r\n    if (currentScope != null) {\r\n        T found = null;\r\n        for (Object o : context()) {\r\n            if (clazz.isInstance(o)) {\r\n                found = (T) o;\r\n            }\r\n        }\r\n        return found;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jdk.tools.jaotc.binformat.BinaryContainer.getAOTSymbolForVMFunctionName",
	"Comment": "gets the global aot symbol associated with the function name.",
	"Method": "String getAOTSymbolForVMFunctionName(String functionName){\r\n    return functionNamesToAOTSymbols.get(functionName);\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.aarch64.AArch64Assembler.ldaxr",
	"Comment": "load acquire exclusive. natural alignment of address is required.",
	"Method": "void ldaxr(int size,Register rt,Register rn){\r\n    assert size == 8 || size == 16 || size == 32 || size == 64;\r\n    int transferSize = NumUtil.log2Ceil(size / 8);\r\n    exclusiveLoadInstruction(LDAXR, rt, rn, transferSize);\r\n}"
}, {
	"Path": "org.graalvm.nativeimage.RuntimeOptions.set",
	"Comment": "set the value of the option with the provided name to the new value.",
	"Method": "void set(String optionName,Object value){\r\n    ImageSingletons.lookup(RuntimeOptionsSupport.class).set(optionName, value);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.GraalCompilerTest.branchProbability",
	"Comment": "inject a probability for a branch condition into the profiling information of this test case.",
	"Method": "boolean branchProbability(double p,boolean cond){\r\n    return GraalDirectives.injectBranchProbability(p, cond);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext.pop",
	"Comment": "pops a value from the frame state stack using an explicit kind.",
	"Method": "ValueNode pop(JavaKind slotKind){\r\n    throw GraalError.unimplemented();\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.RegexProfile.profileCaptureGroupAccess",
	"Comment": "update profile after the execution of a lazy capture groups search dfa.",
	"Method": "void profileCaptureGroupAccess(int matchLength,int numberOfCharsTraversed){\r\n    captureGroupAccesses.inc();\r\n    avgMatchLength += (matchLength - avgMatchLength) / captureGroupAccesses.getCount();\r\n    double matchedPortion = ((double) matchLength) / numberOfCharsTraversed;\r\n    avgMatchedPortionOfSearchSpace += (matchedPortion - avgMatchedPortionOfSearchSpace) / captureGroupAccesses.getCount();\r\n}"
}, {
	"Path": "jdk.tools.jaotc.binformat.ByteContainer.appendBytes",
	"Comment": "append to byte stream. it is an error to append to stream if the byte buffer version ischanged.",
	"Method": "ByteContainer appendBytes(byte[] newBytes,int off,int len,ByteContainer appendBytes,byte[] newBytes){\r\n    appendBytes(newBytes, 0, newBytes.length);\r\n    return this;\r\n}"
}, {
	"Path": "org.graalvm.compiler.java.BytecodeParser.createBlockTarget",
	"Comment": "returns a block begin node with the specified state. if the specified probability is 0, theblock deoptimizes immediately.",
	"Method": "AbstractBeginNode createBlockTarget(double probability,BciBlock block,FrameStateBuilder stateAfter){\r\n    FixedNode target = createTarget(probability, block, stateAfter);\r\n    AbstractBeginNode begin = BeginNode.begin(target);\r\n    assert !(target instanceof DeoptimizeNode && begin instanceof BeginStateSplitNode && ((BeginStateSplitNode) begin).stateAfter() != null) : \"We are not allowed to set the stateAfter of the begin node,\" + \" because we have to deoptimize to a bci _before_ the actual if, so that the interpreter can update the profiling information.\";\r\n    return begin;\r\n}"
}, {
	"Path": "org.graalvm.nativeimage.c.type.CTypeConversion.toCString",
	"Comment": "provides access to a c pointer for the provided java string, encoded with the defaultcharset.",
	"Method": "CCharPointerHolder toCString(CharSequence javaString,UnsignedWord toCString,CharSequence javaString,CCharPointer buffer,UnsignedWord bufferSize,UnsignedWord toCString,CharSequence javaString,Charset charset,CCharPointer buffer,UnsignedWord bufferSize){\r\n    return ImageSingletons.lookup(CTypeConversionSupport.class).toCString(javaString, charset, buffer, bufferSize);\r\n}"
}, {
	"Path": "jdk.tools.jaotc.CompiledMethodInfo.setStubsOffset",
	"Comment": "offset into the code of this method where the stub section starts.",
	"Method": "void setStubsOffset(int offset){\r\n    stubsOffset = offset;\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.DebugContext.getDescription",
	"Comment": "gets a description of the computation associated with this debug context.",
	"Method": "Description getDescription(){\r\n    return description;\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.TimerKey.getFlat",
	"Comment": "gets the timer recording the amount time spent within a timed scope minus the time spent inany nested timed scopes.",
	"Method": "TimerKey getFlat(){\r\n    return null;\r\n}"
}, {
	"Path": "jdk.tools.jaotc.JavaCallSiteRelocationSymbol.getResolveSymbolName",
	"Comment": "returns the name of the resolve method for this particular call.",
	"Method": "String getResolveSymbolName(CompiledMethodInfo mi,Call call){\r\n    String resolveSymbolName;\r\n    if (CallInfo.isStaticCall(call)) {\r\n        assert mi.hasMark(call, MarkId.INVOKESTATIC);\r\n        resolveSymbolName = BinaryContainer.getResolveStaticEntrySymbolName();\r\n    } else if (CallInfo.isSpecialCall(call)) {\r\n        resolveSymbolName = BinaryContainer.getResolveOptVirtualEntrySymbolName();\r\n    } else if (CallInfo.isOptVirtualCall(mi, call)) {\r\n        resolveSymbolName = BinaryContainer.getResolveOptVirtualEntrySymbolName();\r\n    } else if (CallInfo.isVirtualCall(mi, call)) {\r\n        resolveSymbolName = BinaryContainer.getResolveVirtualEntrySymbolName();\r\n    } else {\r\n        throw new InternalError(\"Unknown call type in \" + mi.asTag() + \" @ \" + call.pcOffset + \" for call\" + call.target);\r\n    }\r\n    return resolveSymbolName;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.GraalCompilerTest.checkHighTierGraph",
	"Comment": "can be overridden by unit tests to verify properties of the graph.",
	"Method": "boolean checkHighTierGraph(StructuredGraph graph){\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.DebugContext.getGlobalMetrics",
	"Comment": "gets the global metrics associated with this debug context.",
	"Method": "GlobalMetrics getGlobalMetrics(){\r\n    return globalMetrics;\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.aarch64.AArch64Assembler.fmovFpu2Cpu",
	"Comment": "move size bits from floating point register unchanged to general purpose register.",
	"Method": "void fmovFpu2Cpu(int size,Register dst,Register src){\r\n    assert dst.getRegisterCategory().equals(CPU);\r\n    assert src.getRegisterCategory().equals(SIMD);\r\n    fmovCpuFpuInstruction(dst, src, size == 64, Instruction.FMOVFPU2CPU);\r\n}"
}, {
	"Path": "org.graalvm.polyglot.SourceSection.isAvailable",
	"Comment": "returns whether this is a special instance that signifies that source information isavailable. available source sections are never equal to unavailable source sections.unavailable source sections return the same indices and lengths as empty source sectionsstarting at character index 0.",
	"Method": "boolean isAvailable(){\r\n    return IMPL.isAvailable(impl);\r\n}"
}, {
	"Path": "org.graalvm.polyglot.TypeLiteral.getType",
	"Comment": "returns the type literal including generic type information.",
	"Method": "Type getType(){\r\n    return this.type;\r\n}"
}, {
	"Path": "org.graalvm.util.test.CollectionSizeTest.testCompress",
	"Comment": "tests whether the map actually compresses the entries array when a large number of entriesare deleted.",
	"Method": "void testCompress(){\r\n    Assume.assumeTrue(\"Not working in JDK9 due to module visibility.\", GraalTest.Java8OrEarlier);\r\n    EconomicMap<Object, Object> map = EconomicMap.create();\r\n    Object firstValue = 0;\r\n    map.put(firstValue, firstValue);\r\n    ObjectSizeEstimate afterFirstValue = ObjectSizeEstimate.forObject(map);\r\n    for (int i = 1; i < 1000; ++i) {\r\n        Object value = i;\r\n        map.put(value, value);\r\n    }\r\n    ObjectSizeEstimate beforeRemove = ObjectSizeEstimate.forObject(map);\r\n    for (int i = 0; i < 999; ++i) {\r\n        map.removeKey(i);\r\n    }\r\n    ObjectSizeEstimate afterRemove = ObjectSizeEstimate.forObject(map);\r\n    assertEquals(afterFirstValue, afterRemove);\r\n    for (int i = 0; i < 999; ++i) {\r\n        Object value = i;\r\n        map.put(value, value);\r\n    }\r\n    ObjectSizeEstimate afterAdd = ObjectSizeEstimate.forObject(map);\r\n    assertEquals(beforeRemove.getPointerCount(), afterAdd.getPointerCount());\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.match.MatchRuleRegistry.createRules",
	"Comment": "this is a separate, public method so that external clients can create rules with a customlookup and without the default caching behavior.",
	"Method": "EconomicMap<Class<? extends Node>, List<MatchStatement>> createRules(Class<? extends NodeMatchRules> theClass){\r\n    EconomicMap<Class<? extends NodeMatchRules>, MatchStatementSet> matchSets = EconomicMap.create(Equivalence.IDENTITY);\r\n    Iterable<MatchStatementSet> sl = GraalServices.load(MatchStatementSet.class);\r\n    for (MatchStatementSet rules : sl) {\r\n        matchSets.put(rules.forClass(), rules);\r\n    }\r\n    EconomicMap<Class<? extends Node>, List<MatchStatement>> rules = EconomicMap.create(Equivalence.IDENTITY);\r\n    Class<? extends NodeMatchRules> currentClass = theClass;\r\n    do {\r\n        MatchStatementSet matchSet = matchSets.get(currentClass);\r\n        if (matchSet != null) {\r\n            List<MatchStatement> statements = matchSet.statements();\r\n            for (MatchStatement statement : statements) {\r\n                Class<? extends Node> nodeClass = statement.getPattern().nodeClass();\r\n                List<MatchStatement> current = rules.get(nodeClass);\r\n                if (current == null) {\r\n                    current = new ArrayList();\r\n                    rules.put(nodeClass, current);\r\n                }\r\n                current.add(statement);\r\n            }\r\n        }\r\n        currentClass = (Class<? extends NodeMatchRules>) currentClass.getSuperclass();\r\n    } while (currentClass != NodeMatchRules.class);\r\n    return rules;\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.ScopeImpl.scope",
	"Comment": "creates and enters a new scope which is either a child of the current scope or a disjoint toplevel scope.",
	"Method": "ScopeImpl scope(CharSequence name,DebugConfig sandboxConfig,Object newContextObjects){\r\n    ScopeImpl newScope = null;\r\n    if (sandboxConfig != null) {\r\n        newScope = new ScopeImpl(owner, name.toString(), this, true, newContextObjects);\r\n    } else {\r\n        newScope = this.createChild(name.toString(), newContextObjects);\r\n    }\r\n    newScope.updateFlags(owner.currentConfig);\r\n    return newScope;\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.test.MonitorTest.test5",
	"Comment": "tests recursive locking of objects which do not appear to be biasable.",
	"Method": "void test5(){\r\n    char[] src = \"1234567890\".toCharArray();\r\n    char[] dst = new char[src.length];\r\n    test(\"copyArr\", src, dst, 100);\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.test.MonitorTest.test4",
	"Comment": "tests recursive locking of objects which should be biasable.",
	"Method": "void test4(){\r\n    Chars src = new Chars(\"1234567890\".toCharArray());\r\n    Chars dst = new Chars(src.data.length);\r\n    test(\"copyObj\", src, dst, 100);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.java.RegisterFinalizerNode.mayHaveFinalizer",
	"Comment": "determines if the compiler should emit code to test whether a given object has a finalizerthat must be registered with the runtime upon object initialization.",
	"Method": "boolean mayHaveFinalizer(ValueNode object,Assumptions assumptions){\r\n    ObjectStamp objectStamp = (ObjectStamp) object.stamp(NodeView.DEFAULT);\r\n    if (objectStamp.isExactType()) {\r\n        return objectStamp.type().hasFinalizer();\r\n    } else if (objectStamp.type() != null) {\r\n        AssumptionResult<Boolean> result = objectStamp.type().hasFinalizableSubclass();\r\n        if (result.canRecordTo(assumptions)) {\r\n            result.recordTo(assumptions);\r\n            return result.getResult();\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.runtime.OptimizedCallTarget.invalidate",
	"Comment": "invalidates this call target by invalidating any machine code attached to it.",
	"Method": "void invalidate(Object source,CharSequence reason){\r\n    cachedNonTrivialNodeCount = -1;\r\n    if (isValid()) {\r\n        invalidateCode();\r\n        runtime().getListener().onCompilationInvalidated(this, source, reason);\r\n    }\r\n    runtime().cancelInstalledTask(this, source, reason);\r\n}"
}, {
	"Path": "org.graalvm.polyglot.Engine.getLanguages",
	"Comment": "gets a map of all installed languages with the language id as key and the language object asvalue. the returned map is unmodifiable and might be used from multiple threads.",
	"Method": "Map<String, Language> getLanguages(){\r\n    return impl.getLanguages();\r\n}"
}, {
	"Path": "org.graalvm.compiler.code.CompilationResult.validateExceptionHandlerAdd",
	"Comment": "validate if the exception handler for codepos already exists and handlerpos is different.",
	"Method": "boolean validateExceptionHandlerAdd(int codePos,int handlerPos){\r\n    ExceptionHandler exHandler = getExceptionHandlerForCodePos(codePos);\r\n    return exHandler == null || exHandler.handlerPos == handlerPos;\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.ExecutionListenerCompilerTest.testOnErrorNoException",
	"Comment": "collect all the data but without input events return value or error no additional code shouldbe produced. the polyglot listener nodes should specialize and deopt if it changes.",
	"Method": "void testOnErrorNoException(){\r\n    testListener(null, \"returnNull\", new ReturnNullNode());\r\n    testListener(ExecutionListener.newBuilder().onEnter(empty).onReturn(empty).expressions(true).collectReturnValue(true).collectInputValues(true), \"returnNull\", new ReturnNullNode());\r\n    testListener(ExecutionListener.newBuilder().onEnter(empty).onReturn(counting).expressions(true).collectReturnValue(true).collectInputValues(true), \"returnNullAndIncrement\", new ReturnNullNode());\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.OptimizedOSRLoopNodeTest.testTwoLoopsParentChild1",
	"Comment": "test that two loops in a parent child relationship are propagating loop counts.",
	"Method": "void testTwoLoopsParentChild1(OSRLoopFactory factory){\r\n    ChildLoopRepeatingNode childLoop = new ChildLoopRepeatingNode(factory, new TestRepeatingNode(), loop -> {\r\n        assertNotCompiled(loop.getOSRTarget());\r\n        return null;\r\n    });\r\n    TestRootNode rootNode = new TestRootNode(factory, childLoop);\r\n    CallTarget target = runtime.createCallTarget(rootNode);\r\n    target.call(1, OSR_THRESHOLD);\r\n    assertCompiled(rootNode.getOSRTarget());\r\n    assertNotCompiled(childLoop.getOSRTarget());\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.type.StampTool.unsignedCompare",
	"Comment": "compute the stamp resulting from the unsigned comparison being true.",
	"Method": "Stamp unsignedCompare(Stamp stamp,Stamp stamp2){\r\n    IntegerStamp x = (IntegerStamp) stamp;\r\n    IntegerStamp y = (IntegerStamp) stamp2;\r\n    if (x.isUnrestricted() && y.isUnrestricted()) {\r\n        return null;\r\n    }\r\n    if (x.lowerBound() == x.upperBound()) {\r\n        if (y.isPositive()) {\r\n            if (x.lowerBound() == (1 << x.getBits()) - 1) {\r\n                return null;\r\n            }\r\n            if (x.lowerBound() <= y.lowerBound()) {\r\n                return null;\r\n            }\r\n            return StampFactory.forInteger(x.getBits(), x.lowerBound() + 1, y.upperBound());\r\n        }\r\n        return null;\r\n    }\r\n    if (y.lowerBound() == y.upperBound() && y.isStrictlyPositive()) {\r\n        return StampFactory.forInteger(y.getBits(), 0, y.lowerBound() - 1);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.DefaultJavaLoweringProvider.createArrayIndexAddress",
	"Comment": "create a pinode on the index proving that the index is positive. on some platforms this isimportant to allow the index to be used as an int in the address mode.",
	"Method": "AddressNode createArrayIndexAddress(StructuredGraph graph,ValueNode array,JavaKind elementKind,ValueNode index,GuardingNode boundsCheck){\r\n    ValueNode positiveIndex = graph.maybeAddOrUnique(PiNode.create(index, POSITIVE_ARRAY_INDEX_STAMP, boundsCheck != null ? boundsCheck.asNode() : null));\r\n    return createArrayAddress(graph, array, elementKind, positiveIndex);\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.trace.TraceGlobalMoveResolver.unblock",
	"Comment": "mark assignedreg and assignedreghi of the interval as unblocked",
	"Method": "void unblock(Value location){\r\n    if (mightBeBlocked(location)) {\r\n        assert valueBlocked(location) > 0 : \"location already marked as unused: \" + location;\r\n        setValueBlocked(location, -1);\r\n        debug.log(\"unblock %s\", location);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.tregex.dfa.DFAStateNodeBuilder.isFinalStateSuccessor",
	"Comment": "used in pruneunambiguouspaths mode. states that are not final states or successors of finalstates may have their last matcher replaced with an anymatcher.",
	"Method": "boolean isFinalStateSuccessor(){\r\n    return isFinalStateSuccessor;\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.replacements.WriteBarrierSnippets.validateObject",
	"Comment": "validation helper method which performs sanity checks on write operations. the addresses ofboth the object and the value being written are checked in order to determine if they residein a valid heap region. if an object is stale, an invalid access is performed in order toprematurely crash the vm and debug the stack trace of the faulty method.",
	"Method": "void validateObject(Object parent,Object child){\r\n    if (verifyOops(INJECTED_VMCONFIG) && child != null) {\r\n        Word parentWord = Word.objectToTrackedPointer(parent);\r\n        Word childWord = Word.objectToTrackedPointer(child);\r\n        if (!validateOop(VALIDATE_OBJECT, parentWord, childWord)) {\r\n            log(true, \"Verification ERROR, Parent: %p Child: %p\\n\", parentWord.rawValue(), childWord.rawValue());\r\n            VMErrorNode.vmError(\"Verification ERROR, Parent: %p\\n\", parentWord.rawValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.java.BytecodeParser.callTargetIsResolved",
	"Comment": "ensure that concrete classes are at least linked before generating an invoke. interfaces maynever be linked so simply return true for them.",
	"Method": "boolean callTargetIsResolved(JavaMethod target){\r\n    if (target instanceof ResolvedJavaMethod) {\r\n        ResolvedJavaMethod resolvedTarget = (ResolvedJavaMethod) target;\r\n        ResolvedJavaType resolvedType = resolvedTarget.getDeclaringClass();\r\n        return resolvedType.isInterface() || resolvedType.isLinked();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.options.OptionType.convert",
	"Comment": "converts a string value, validates it, and converts it to an object of this type.",
	"Method": "T convert(String value){\r\n    T v = stringConverter.apply(value);\r\n    validate(v);\r\n    return v;\r\n}"
}, {
	"Path": "org.graalvm.compiler.bytecode.BytecodeSwitch.defaultTarget",
	"Comment": "gets the index of the instruction for the default switch target.",
	"Method": "int defaultTarget(){\r\n    return bci + defaultOffset();\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.common.util.EconomicSetNodeEventListener.exclude",
	"Comment": "excludes a given event from those for which nodes are collected.",
	"Method": "EconomicSetNodeEventListener exclude(NodeEvent e){\r\n    filter.remove(e);\r\n    return this;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.lsra.LinearScanAssignLocationsPhase.colorLirOperand",
	"Comment": "assigns the allocated location for an lir instruction operand back into the instruction.",
	"Method": "Value colorLirOperand(LIRInstruction op,Variable operand,OperandMode mode){\r\n    int opId = op.id();\r\n    Interval interval = allocator.intervalFor(operand);\r\n    assert interval != null : \"interval must exist\";\r\n    if (opId != -1) {\r\n        if (allocator.detailedAsserts) {\r\n            AbstractBlockBase<?> block = allocator.blockForId(opId);\r\n            if (block.getSuccessorCount() <= 1 && opId == allocator.getLastLirInstructionId(block)) {\r\n                LIRInstruction instr = allocator.getLIR().getLIRforBlock(block).get(allocator.getLIR().getLIRforBlock(block).size() - 1);\r\n                if (instr instanceof StandardOp.JumpOp) {\r\n                    if (allocator.getBlockData(block).liveOut.get(allocator.operandNumber(operand))) {\r\n                        assert false : String.format(\"can't get split child for the last branch of a block because the information would be incorrect (moves are inserted before the branch in resolveDataFlow) block=%s, instruction=%s, operand=%s\", block, instr, operand);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        interval = allocator.splitChildAtOpId(interval, opId, mode);\r\n    }\r\n    if (isIllegal(interval.location()) && interval.canMaterialize()) {\r\n        assert mode != OperandMode.DEF;\r\n        return new ConstantValue(interval.kind(), interval.getMaterializedValue());\r\n    }\r\n    return interval.location();\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.StructuredGraph.getFields",
	"Comment": "gets an unmodifiable view of the fields that were accessed while constructing this graph.",
	"Method": "EconomicSet<ResolvedJavaField> getFields(){\r\n    return fields;\r\n}"
}, {
	"Path": "org.graalvm.compiler.code.CompilationResult.getExceptionHandlerForCodePos",
	"Comment": "returns the first exceptionhandler which matches codepos.",
	"Method": "ExceptionHandler getExceptionHandlerForCodePos(int codePos){\r\n    for (ExceptionHandler h : exceptionHandlers) {\r\n        if (h.pcOffset == codePos) {\r\n            return h;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.OptimizedOSRLoopNodeTest.testThreadSafety",
	"Comment": "test that we are not crashing in multi threaded environments.",
	"Method": "void testThreadSafety(OSRLoopFactory factory){\r\n    int threshold = OSR_THRESHOLD;\r\n    IntStream.generate(() -> 10).limit(10).parallel().forEach(i -> {\r\n        TestRootNode rootNode = new TestRootNode(factory, new TestRepeatingNode());\r\n        IntStream.generate(() -> threshold).limit(10).parallel().forEach(k -> executeNoCallTarget(rootNode, threshold + 1));\r\n        waitForCompiled(rootNode.getOSRTarget());\r\n    });\r\n    IntStream.generate(() -> 10).limit(10).parallel().forEach(i -> {\r\n        TestRootNode rootNode = new TestRootNode(factory, new TestRepeatingNode());\r\n        IntStream.generate(() -> threshold).limit(10).parallel().forEach(k -> executeNoCallTarget(rootNode, threshold));\r\n        waitForCompiled(rootNode.getOSRTarget());\r\n    });\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.tregex.parser.ast.RegexASTNode.hasEmptyGuard",
	"Comment": "indicates whether or not this node should be allowed to match the empty string.",
	"Method": "boolean hasEmptyGuard(){\r\n    return isFlagSet(FLAG_EMPTY_GUARD);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.AArch64LIRGenerator.canStoreConstant",
	"Comment": "checks whether the supplied constant can be used without loading it into a register for storeoperations, i.e., on the right hand side of a memory access.",
	"Method": "boolean canStoreConstant(JavaConstant c){\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.getBytecodeProvider",
	"Comment": "gets provider of bytecode to be parsed for a method that is part of an intrinsic.",
	"Method": "BytecodeProvider getBytecodeProvider(){\r\n    return bytecodeProvider;\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.OptimizedOSRLoopNodeTest.testOSRMinInvocationThresholdPropagateLoopCounts",
	"Comment": "test that loop counts of osr loops propagate loop counts the parent call target.",
	"Method": "void testOSRMinInvocationThresholdPropagateLoopCounts(OSRLoopFactory factory){\r\n    TestRootNode rootNode = new TestRootNode(factory, new TestRepeatingNode());\r\n    OptimizedCallTarget target = (OptimizedCallTarget) runtime.createCallTarget(rootNode);\r\n    int osrThreshold = OSR_THRESHOLD;\r\n    int truffleMinInvokes = TruffleRuntimeOptions.getValue(TruffleMinInvokeThreshold);\r\n    int i;\r\n    int invokesleft = osrThreshold;\r\n    for (i = 0; i < truffleMinInvokes - 1; i++) {\r\n        int invokes = osrThreshold / truffleMinInvokes;\r\n        invokesleft -= invokes;\r\n        target.call(invokes);\r\n        assertNotCompiled(rootNode.getOSRTarget());\r\n    }\r\n    assertNotCompiled(target);\r\n    target.call(invokesleft + 1);\r\n    assertNotCompiled(rootNode.getOSRTarget());\r\n    assertCompiled(target);\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.replacements.NewObjectSnippets.fillWithGarbage",
	"Comment": "fill uninitialized memory with garbage value in a newly allocated object, unrolling asnecessary and ensuring that stores are aligned.",
	"Method": "void fillWithGarbage(int size,Word memory,boolean constantSize,int startOffset,boolean manualUnroll,Counters counters){\r\n    fillMemory(0xfefefefefefefefeL, size, memory, constantSize, startOffset, manualUnroll, counters);\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.RegexProfile.incCalls",
	"Comment": "increase the number of times the regular expression was executed by one.",
	"Method": "void incCalls(){\r\n    calls.inc();\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.MethodFilter.matchesClassName",
	"Comment": "determines if the class part of this filter matches a given class name.",
	"Method": "boolean matchesClassName(MethodFilter[] filters,String className,boolean matchesClassName,String className){\r\n    return clazz == null || clazz.matcher(className).matches();\r\n}"
}, {
	"Path": "org.graalvm.compiler.bytecode.BytecodeStream.readCPI4",
	"Comment": "reads a constant pool index for an invokedynamic instruction.",
	"Method": "int readCPI4(){\r\n    assert opcode == Bytecodes.INVOKEDYNAMIC;\r\n    return Bytes.beS4(code, curBCI + 1);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.type.IntegerStamp.lowerBound",
	"Comment": "the signed inclusive lower bound on the value described by this stamp.",
	"Method": "long lowerBound(){\r\n    return lowerBound;\r\n}"
}, {
	"Path": "com.alibaba.json.test.TestUtils.encodeToBase64String",
	"Comment": "encodes a raw byte array into a base64 string representation i accordance with rfc 2045.",
	"Method": "String encodeToBase64String(byte[] sArr,boolean lineSep){\r\n    return new String(encodeToChar(sArr, lineSep));\r\n}"
}, {
	"Path": "jdk.tools.jaotc.InfopointProcessor.getCallSiteRelocationInfo",
	"Comment": "get information about the call site. name of the callee and relocation call type.",
	"Method": "CallSiteRelocationInfo getCallSiteRelocationInfo(Call call){\r\n    InvokeTarget callTarget = call.target;\r\n    if (callTarget instanceof HotSpotResolvedJavaMethod) {\r\n        return new JavaCallSiteRelocationInfo(call, (HotSpotResolvedJavaMethod) callTarget);\r\n    } else if (callTarget instanceof HotSpotForeignCallLinkage) {\r\n        return new ForeignCallSiteRelocationInfo(call, (HotSpotForeignCallLinkage) callTarget);\r\n    } else {\r\n        throw new InternalError(\"Unhandled call type found in infopoint: \" + callTarget);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.graph.Graph.getTotalNodesDeleted",
	"Comment": "gets the total number of nodes which have been deleted from this graph.",
	"Method": "int getTotalNodesDeleted(){\r\n    return nodesDeletedSinceLastCompression + nodesDeletedBeforeLastCompression;\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.DebugContext.forceDump",
	"Comment": "forces an unconditional dump. this method exists mainly for debugging. it can also be used toforce a graph dump from ides that support invoking a java method while at a breakpoint.",
	"Method": "void forceDump(Object object,String format,Object args){\r\n    DebugConfig config = currentConfig;\r\n    Collection<DebugDumpHandler> dumpHandlers;\r\n    boolean closeAfterDump;\r\n    if (config != null) {\r\n        dumpHandlers = config.dumpHandlers();\r\n        closeAfterDump = false;\r\n    } else {\r\n        OptionValues options = getOptions();\r\n        dumpHandlers = new ArrayList();\r\n        for (DebugHandlersFactory factory : DebugHandlersFactory.LOADER) {\r\n            for (DebugHandler handler : factory.createHandlers(options)) {\r\n                if (handler instanceof DebugDumpHandler) {\r\n                    dumpHandlers.add((DebugDumpHandler) handler);\r\n                }\r\n            }\r\n        }\r\n        closeAfterDump = true;\r\n    }\r\n    for (DebugDumpHandler dumpHandler : dumpHandlers) {\r\n        dumpHandler.dump(this, object, format, args);\r\n        if (closeAfterDump) {\r\n            dumpHandler.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.bytecode.Bytecodes.isInvoke",
	"Comment": "determines if a given opcode denotes an instruction that stores a value to a local variableafter popping it from the operand stack.",
	"Method": "boolean isInvoke(int opcode){\r\n    return (flagsArray[opcode & 0xff] & INVOKE) != 0;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.test.AbstractObjectStampTest.join",
	"Comment": "joins the two stamps and also asserts that the meet operation is commutative.",
	"Method": "Stamp join(Stamp a,Stamp b){\r\n    Stamp ab = a.join(b);\r\n    Stamp ba = b.join(a);\r\n    Assert.assertEquals(ab, ba);\r\n    return ab;\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.DebugContext.addValuesTo",
	"Comment": "gets a tally of the metric values in this context and a given tally.",
	"Method": "long[] addValuesTo(long[] tally){\r\n    if (metricValues == null) {\r\n        return tally;\r\n    }\r\n    if (tally == null) {\r\n        return metricValues.clone();\r\n    } else if (metricValues.length >= tally.length) {\r\n        long[] newTally = metricValues.clone();\r\n        for (int i = 0; i < tally.length; i++) {\r\n            newTally[i] += tally[i];\r\n        }\r\n        return newTally;\r\n    } else {\r\n        for (int i = 0; i < metricValues.length; i++) {\r\n            tally[i] += metricValues[i];\r\n        }\r\n        return tally;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.lsra.MoveResolver.blockRegisters",
	"Comment": "mark assignedreg and assignedreghi of the interval as blocked",
	"Method": "void blockRegisters(Interval interval){\r\n    Value location = interval.location();\r\n    if (mightBeBlocked(location)) {\r\n        assert areMultipleReadsAllowed() || valueBlocked(location) == 0 : \"location already marked as used: \" + location;\r\n        int direction = 1;\r\n        setValueBlocked(location, direction);\r\n        allocator.getDebug().log(\"block %s\", location);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.type.TypeReference.createWithoutAssumptions",
	"Comment": "creates a type reference using the given type without assumptions and without trustinginterface types.",
	"Method": "TypeReference createWithoutAssumptions(ResolvedJavaType type){\r\n    return create(null, type);\r\n}"
}, {
	"Path": "org.graalvm.compiler.virtual.phases.ea.GraphEffectList.replaceFirstInput",
	"Comment": "replaces the first occurrence of oldinput in node with newinput.",
	"Method": "void replaceFirstInput(Node node,Node oldInput,Node newInput){\r\n    assert node.isAlive() && oldInput.isAlive() && !newInput.isDeleted();\r\n    add(\"replace first input\", new Effect() {\r\n        @Override\r\n        public void apply(StructuredGraph graph, ArrayList<Node> obsoleteNodes) {\r\n            if (node.isAlive()) {\r\n                assert oldInput.isAlive() && newInput.isAlive();\r\n                node.replaceFirstInput(oldInput, newInput);\r\n            }\r\n        }\r\n        @Override\r\n        public boolean isVisible() {\r\n            return !(node instanceof FrameState);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.graalvm.compiler.virtual.phases.ea.GraphEffectList.replaceFirstInput",
	"Comment": "replaces the first occurrence of oldinput in node with newinput.",
	"Method": "void replaceFirstInput(Node node,Node oldInput,Node newInput){\r\n    if (node.isAlive()) {\r\n        assert oldInput.isAlive() && newInput.isAlive();\r\n        node.replaceFirstInput(oldInput, newInput);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.virtual.phases.ea.GraphEffectList.replaceFirstInput",
	"Comment": "replaces the first occurrence of oldinput in node with newinput.",
	"Method": "void replaceFirstInput(Node node,Node oldInput,Node newInput){\r\n    return !(node instanceof FrameState);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.FinalizableSubclassTest.test1",
	"Comment": "use a custom class loader to generate classes, to make sure the given classes are loaded incorrect order.",
	"Method": "void test1(){\r\n    DebugContext debug = getDebugContext();\r\n    for (int i = 0; i < 2; i++) {\r\n        ClassTemplateLoader loader = new ClassTemplateLoader(debug);\r\n        checkForRegisterFinalizeNode(loader.findClass(\"NoFinalizerEverAAAA\"), true, AllowAssumptions.NO);\r\n        checkForRegisterFinalizeNode(loader.findClass(\"NoFinalizerEverAAAA\"), false, AllowAssumptions.YES);\r\n        checkForRegisterFinalizeNode(loader.findClass(\"NoFinalizerYetAAAA\"), false, AllowAssumptions.YES);\r\n        checkForRegisterFinalizeNode(loader.findClass(\"WithFinalizerAAAA\"), true, AllowAssumptions.YES);\r\n        checkForRegisterFinalizeNode(loader.findClass(\"NoFinalizerYetAAAA\"), true, AllowAssumptions.YES);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.ReplacementsUtil.staticAssert",
	"Comment": "asserts that condition evaluates to true by the time compilation is finished. this isintended to be used within snippets or stubs, and will lead to a compile error if theassertion fails.",
	"Method": "void staticAssert(boolean condition,String message){\r\n    if (REPLACEMENTS_ASSERTIONS_ENABLED) {\r\n        AssertionNode.assertion(true, condition, message);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.canBeIntrinsified",
	"Comment": "determines if methods in a given class can have invocation plugins.",
	"Method": "boolean canBeIntrinsified(ResolvedJavaType declaringClass){\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.lsra.LinearScanLifetimeAnalysisPhase.changeSpillDefinitionPos",
	"Comment": "eliminates moves from register to stack if the stack slot is known to be correct.",
	"Method": "void changeSpillDefinitionPos(LIRInstruction op,AllocatableValue operand,Interval interval,int defPos){\r\n    assert interval.isSplitParent() : \"can only be called for split parents\";\r\n    switch(interval.spillState()) {\r\n        case NoDefinitionFound:\r\n            assert interval.spillDefinitionPos() == -1 : \"must no be set before\";\r\n            interval.setSpillDefinitionPos(defPos);\r\n            interval.setSpillState(SpillState.NoSpillStore);\r\n            break;\r\n        case NoSpillStore:\r\n            assert defPos <= interval.spillDefinitionPos() : \"positions are processed in reverse order when intervals are created\";\r\n            if (defPos < interval.spillDefinitionPos() - 2) {\r\n                interval.setSpillState(SpillState.NoOptimization);\r\n            } else {\r\n                assert allocator.blockForId(defPos) == allocator.blockForId(interval.spillDefinitionPos()) : \"block must be equal\";\r\n            }\r\n            break;\r\n        case NoOptimization:\r\n            break;\r\n        default:\r\n            throw GraalError.shouldNotReachHere(\"other states not allowed at this time\");\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.options.OptionKey.hasBeenSet",
	"Comment": "returns true if a value for this key has been set for the given option values orfalse if no value has been set.",
	"Method": "boolean hasBeenSet(OptionValues values){\r\n    return values.hasBeenSet(this);\r\n}"
}, {
	"Path": "org.graalvm.compiler.graph.Node.verifyEdges",
	"Comment": "perform expensive verification of inputs, usages, predecessors and successors.",
	"Method": "boolean verifyEdges(){\r\n    for (Node input : inputs()) {\r\n        assertTrue(input == null || input.usages().contains(this), \"missing usage of %s in input %s\", this, input);\r\n    }\r\n    for (Node successor : successors()) {\r\n        assertTrue(successor.predecessor() == this, \"missing predecessor in %s (actual: %s)\", successor, successor.predecessor());\r\n        assertTrue(successor.graph() == graph(), \"mismatching graph in successor %s\", successor);\r\n    }\r\n    for (Node usage : usages()) {\r\n        assertFalse(usage.isDeleted(), \"usage %s must never be deleted\", usage);\r\n        assertTrue(usage.inputs().contains(this), \"missing input in usage %s\", usage);\r\n        boolean foundThis = false;\r\n        for (Position pos : usage.inputPositions()) {\r\n            if (pos.get(usage) == this) {\r\n                foundThis = true;\r\n                if (pos.getInputType() != InputType.Unchecked) {\r\n                    assertTrue(isAllowedUsageType(pos.getInputType()), \"invalid input of type %s from %s to %s (%s)\", pos.getInputType(), usage, this, pos.getName());\r\n                }\r\n            }\r\n        }\r\n        assertTrue(foundThis, \"missing input in usage %s\", usage);\r\n    }\r\n    if (predecessor != null) {\r\n        assertFalse(predecessor.isDeleted(), \"predecessor %s must never be deleted\", predecessor);\r\n        assertTrue(predecessor.successors().contains(this), \"missing successor in predecessor %s\", predecessor);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.HotSpotForeignCallLinkageImpl.createCallingConvention",
	"Comment": "gets a calling convention for a given descriptor and call type.",
	"Method": "CallingConvention createCallingConvention(MetaAccessProvider metaAccess,CodeCacheProvider codeCache,WordTypes wordTypes,ValueKindFactory<?> valueKindFactory,ForeignCallDescriptor descriptor,Type ccType){\r\n    assert ccType != null;\r\n    Class<?>[] argumentTypes = descriptor.getArgumentTypes();\r\n    JavaType[] parameterTypes = new JavaType[argumentTypes.length];\r\n    for (int i = 0; i < parameterTypes.length; ++i) {\r\n        parameterTypes[i] = asJavaType(argumentTypes[i], metaAccess, wordTypes);\r\n    }\r\n    JavaType returnType = asJavaType(descriptor.getResultType(), metaAccess, wordTypes);\r\n    RegisterConfig regConfig = codeCache.getRegisterConfig();\r\n    return regConfig.getCallingConvention(ccType, returnType, parameterTypes, valueKindFactory);\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.compiler.PartialEvaluator.getInstrumentation",
	"Comment": "gets the instrumentation manager associated with this compiler, creating it first ifnecessary. each compiler instance has its own instrumentation manager.",
	"Method": "InstrumentPhase.Instrumentation getInstrumentation(){\r\n    if (instrumentation == null) {\r\n        synchronized (this) {\r\n            if (instrumentation == null) {\r\n                OptionValues options = TruffleCompilerOptions.getOptions();\r\n                long[] accessTable = new long[TruffleCompilerOptions.TruffleInstrumentationTableSize.getValue(options)];\r\n                instrumentation = new InstrumentPhase.Instrumentation(accessTable);\r\n            }\r\n        }\r\n    }\r\n    return instrumentation;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.java.MethodCallTargetNode.receiver",
	"Comment": "gets the instruction that produces the receiver object for this invocation, if any.",
	"Method": "ValueNode receiver(){\r\n    return isStatic() ? null : arguments().get(0);\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.LIRFrameState.initDebugInfo",
	"Comment": "called by the register allocator to initialize the frame state.",
	"Method": "void initDebugInfo(FrameMap frameMap,boolean canHaveRegisters){\r\n    debugInfo = new DebugInfo(topFrame, virtualObjects);\r\n}"
}, {
	"Path": "org.graalvm.compiler.loop.LoopFragment.loop",
	"Comment": "return the original loopex for this fragment. for duplicated fragments this returns null.",
	"Method": "LoopEx loop(){\r\n    return loop;\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.OptimizedOSRLoopNodeTest.testInternalInvalidations",
	"Comment": "test behavior of osr compile loops if the invalidate internally during loop execution. alsotest that it respects the invalidation reprofile count.",
	"Method": "void testInternalInvalidations(OSRLoopFactory factory){\r\n    TestRepeatingNode repeating = new TestRepeatingNode();\r\n    TestRootNode rootNode = new TestRootNode(factory, repeating);\r\n    OptimizedCallTarget target = (OptimizedCallTarget) runtime.createCallTarget(rootNode);\r\n    target.call(OSR_THRESHOLD + 1);\r\n    target.resetCompilationProfile();\r\n    assertCompiled(rootNode.getOSRTarget());\r\n    repeating.invalidationCounter = 5;\r\n    target.call(4);\r\n    assertCompiled(rootNode.getOSRTarget());\r\n    target.call(2);\r\n    assertNotCompiled(rootNode.getOSRTarget());\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.extended.SwitchNode.keySuccessorIndex",
	"Comment": "returns the index of the successor belonging to the key at the specified index.",
	"Method": "int keySuccessorIndex(int i){\r\n    return keySuccessors[i];\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.common.util.EconomicSetNodeEventListener.getNodes",
	"Comment": "gets the set being used to accumulate the nodes communicated to this listener.",
	"Method": "EconomicSet<Node> getNodes(){\r\n    return nodes;\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.tregex.parser.flavors.PythonFlavorProcessor.emitSnippet",
	"Comment": "emits the argument into the output pattern verbatim. this is useful for syntaxcharacters or for prebaked snippets.",
	"Method": "void emitSnippet(String snippet){\r\n    if (!silent) {\r\n        outPattern.append(snippet);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.loop.LoopsData.deleteUnusedNodes",
	"Comment": "deletes any nodes created within the scope of this object that have no usages.",
	"Method": "void deleteUnusedNodes(){\r\n    for (LoopEx loop : loops()) {\r\n        loop.deleteUnusedNodes();\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.tutorial.InvokeGraal.findMethod",
	"Comment": "look up a method using java reflection and convert it to the graal api method object.",
	"Method": "ResolvedJavaMethod findMethod(Class<?> declaringClass,String name){\r\n    Method reflectionMethod = null;\r\n    for (Method m : declaringClass.getDeclaredMethods()) {\r\n        if (m.getName().equals(name)) {\r\n            assert reflectionMethod == null : \"More than one method with name \" + name + \" in class \" + declaringClass.getName();\r\n            reflectionMethod = m;\r\n        }\r\n    }\r\n    assert reflectionMethod != null : \"No method with name \" + name + \" in class \" + declaringClass.getName();\r\n    return metaAccess.lookupJavaMethod(reflectionMethod);\r\n}"
}, {
	"Path": "jdk.tools.jaotc.JavaMethodInfo.uniqueMethodName",
	"Comment": "name a java method with class and signature to make it unique.",
	"Method": "String uniqueMethodName(ResolvedJavaMethod method){\r\n    String className = method.getDeclaringClass().toClassName();\r\n    String name = className + \".\" + method.getName() + method.getSignature().toMethodDescriptor();\r\n    return name;\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.aarch64.AArch64Assembler.swp",
	"Comment": "atomic swap. this reads a value from an address rn, stores the value in rt, and then storesthe value in rs back at address rn.",
	"Method": "void swp(int size,Register rs,Register rt,Register rn,boolean acquire,boolean release){\r\n    assert size == 8 || size == 16 || size == 32 || size == 64;\r\n    int transferSize = NumUtil.log2Ceil(size / 8);\r\n    swapInstruction(SWP, rs, rt, rn, transferSize, acquire, release);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.alloc.RegisterAllocationConfig.getAllocatableRegisters",
	"Comment": "gets the set of registers that can be used by the register allocator.",
	"Method": "AllocatableRegisters getAllocatableRegisters(PlatformKind kind,RegisterArray getAllocatableRegisters){\r\n    if (cachedRegisters == null) {\r\n        cachedRegisters = initAllocatable(registerConfig.getAllocatableRegisters());\r\n    }\r\n    assert cachedRegisters != null;\r\n    return cachedRegisters;\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.ReplacementsUtil.runtimeAssert",
	"Comment": "asserts that condition evaluates to true at runtime. this is intended to be used withinsnippets or stubs, and will lead to a vm error if it fails.",
	"Method": "void runtimeAssert(boolean condition,String message){\r\n    if (REPLACEMENTS_ASSERTIONS_ENABLED) {\r\n        AssertionNode.assertion(false, condition, message);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.options.OptionDescriptor.getName",
	"Comment": "returns the name of the option that this descriptor represents.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "org.graalvm.compiler.java.FrameStateBuilder.push",
	"Comment": "pushes an instruction onto the stack with the expected type.",
	"Method": "void push(JavaKind slotKind,ValueNode x){\r\n    assert verifyKind(slotKind, x);\r\n    xpush(x);\r\n    if (slotKind.needsTwoSlots()) {\r\n        xpush(TWO_SLOT_MARKER);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.common.inlining.info.elem.InlineableGraph.parseBytecodes",
	"Comment": "this method builds the ir nodes for the given method and canonicalizes them.provided profiling info is mature, the resulting graph is cached. the caller is responsiblefor cloning before modification.",
	"Method": "StructuredGraph parseBytecodes(ResolvedJavaMethod method,HighTierContext context,CanonicalizerPhase canonicalizer,StructuredGraph caller,boolean trackNodeSourcePosition){\r\n    DebugContext debug = caller.getDebug();\r\n    StructuredGraph newGraph = new StructuredGraph.Builder(caller.getOptions(), debug, AllowAssumptions.ifNonNull(caller.getAssumptions())).method(method).trackNodeSourcePosition(trackNodeSourcePosition).useProfilingInfo(caller.useProfilingInfo()).build();\r\n    try (DebugContext.Scope s = debug.scope(\"InlineGraph\", newGraph)) {\r\n        if (!caller.isUnsafeAccessTrackingEnabled()) {\r\n            newGraph.disableUnsafeAccessTracking();\r\n        }\r\n        if (context.getGraphBuilderSuite() != null) {\r\n            context.getGraphBuilderSuite().apply(newGraph, context);\r\n        }\r\n        assert newGraph.start().next() != null : \"graph needs to be populated by the GraphBuilderSuite \" + method + \", \" + method.canBeInlined();\r\n        new DeadCodeEliminationPhase(Optional).apply(newGraph);\r\n        canonicalizer.apply(newGraph, context);\r\n        return newGraph;\r\n    } catch (Throwable e) {\r\n        throw debug.handle(e);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.polyglot.Value.removeArrayElement",
	"Comment": "removes an array element at a given index. returns true if the underlying arrayelement could be removed, otherwise false.",
	"Method": "boolean removeArrayElement(long index){\r\n    return impl.removeArrayElement(receiver, index);\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.Assembler.nameOf",
	"Comment": "gets a name for a label, creating it if it does not yet exist. by default, the returned nameis only unique with the scope of this assembler.",
	"Method": "String nameOf(Label l){\r\n    if (nameMap == null) {\r\n        nameMap = new HashMap();\r\n    }\r\n    String name = nameMap.get(l);\r\n    if (name == null) {\r\n        name = createLabelName(l, nameMap.size());\r\n        nameMap.put(l, name);\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "jdk.tools.jaotc.binformat.ByteContainer.updateByteBuffer",
	"Comment": "update byte buffer to reflect the current contents of byte stream.",
	"Method": "void updateByteBuffer(){\r\n    if (!bufferModified) {\r\n        contentBytes = ByteBuffer.wrap(contentStream.toByteArray());\r\n        this.contentBytes.order(ByteOrder.nativeOrder());\r\n    } else {\r\n        throw new InternalError(\"Backing byte buffer no longer in sync with byte stream\");\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.MemoryScheduleTest.testIfRead3Snippet",
	"Comment": "here the read should float to the end, right before the write.",
	"Method": "int testIfRead3Snippet(int a){\r\n    if (a < 0) {\r\n        container.a = 10;\r\n    }\r\n    int res = container.a;\r\n    container.a = 20;\r\n    return res;\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.replacements.NewObjectSnippets.formatArray",
	"Comment": "formats some allocated memory with an object header and zeroes out the rest.",
	"Method": "Object formatArray(KlassPointer hub,int allocationSize,int length,int headerSize,Word memory,Word prototypeMarkWord,boolean fillContents,boolean maybeUnroll,Counters counters){\r\n    memory.writeInt(arrayLengthOffset(INJECTED_VMCONFIG), length, LocationIdentity.init());\r\n    initializeObjectHeader(memory, prototypeMarkWord, hub);\r\n    if (fillContents) {\r\n        zeroMemory(allocationSize, memory, false, headerSize, maybeUnroll, counters);\r\n    } else if (REPLACEMENTS_ASSERTIONS_ENABLED) {\r\n        fillWithGarbage(allocationSize, memory, false, headerSize, maybeUnroll, counters);\r\n    }\r\n    MembarNode.memoryBarrier(MemoryBarriers.STORE_STORE, LocationIdentity.init());\r\n    return memory.toObjectNonNull();\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.common.inlining.walker.InliningData.inliningContext",
	"Comment": "gets the call hierarchy of this inlining from outer most call to inner most callee.",
	"Method": "Object[] inliningContext(){\r\n    if (!debug.isDumpEnabled(DebugContext.INFO_LEVEL)) {\r\n        return NO_CONTEXT;\r\n    }\r\n    Object[] result = new Object[graphQueue.size()];\r\n    int i = 0;\r\n    for (CallsiteHolder g : graphQueue) {\r\n        result[i++] = g.method();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.polyglot.tck.TypeDescriptor.isAssignable",
	"Comment": "checks if the given type is assignable to this type. the primitive types are assignable onlyto itself or to an union type containing the given primitive type. the array type with acomponent type can be assigned to itself, to an array type without a component type and to anunion type containing the given array type or an array type without a component type. theunion type can be assigned to other union type containing all union elements. theintersection type can be assigned to type having any intersection type. to the targetintersection type only an intersection type having all the target intersection elements canbe assigned.",
	"Method": "boolean isAssignable(TypeDescriptor fromType,boolean isAssignable,TypeDescriptorImpl origType,TypeDescriptorImpl byType,boolean isAssignable,TypeDescriptorImpl origType,TypeDescriptorImpl byType,boolean isAssignable,TypeDescriptorImpl origType,TypeDescriptorImpl byType,boolean isAssignable,TypeDescriptorImpl origType,TypeDescriptorImpl byType,boolean isAssignable,TypeDescriptorImpl origType,TypeDescriptorImpl byType,boolean isAssignable,TypeDescriptorImpl origType,TypeDescriptorImpl byType){\r\n    return impl.isAssignable(impl, fromType.impl);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.type.TypeReference.createTrusted",
	"Comment": "create a type reference using the given type with assumptions and trusting interface types.",
	"Method": "TypeReference createTrusted(Assumptions assumptions,ResolvedJavaType type){\r\n    if (type == null) {\r\n        return null;\r\n    }\r\n    ResolvedJavaType exactType = type.isLeaf() ? type : null;\r\n    if (exactType == null) {\r\n        Assumptions.AssumptionResult<ResolvedJavaType> leafConcreteSubtype = type.findLeafConcreteSubtype();\r\n        if (leafConcreteSubtype != null && leafConcreteSubtype.canRecordTo(assumptions)) {\r\n            leafConcreteSubtype.recordTo(assumptions);\r\n            exactType = leafConcreteSubtype.getResult();\r\n        }\r\n    }\r\n    if (exactType == null) {\r\n        return new TypeReference(type, false);\r\n    }\r\n    return new TypeReference(exactType, true);\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.DebugContext.contextLookup",
	"Comment": "searches the current debug scope, bottom up, for a context object that is an instance of agiven type. the first such object found is returned.",
	"Method": "T contextLookup(Class<T> clazz){\r\n    if (currentScope != null) {\r\n        for (Object o : context()) {\r\n            if (clazz.isInstance(o)) {\r\n                return ((T) o);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.GraphEncoder.encodeSingleGraph",
	"Comment": "utility method that does everything necessary to encode a single graph.",
	"Method": "EncodedGraph encodeSingleGraph(StructuredGraph graph,Architecture architecture){\r\n    GraphEncoder encoder = new GraphEncoder(architecture);\r\n    encoder.prepare(graph);\r\n    encoder.finishPrepare();\r\n    int startOffset = encoder.encode(graph);\r\n    return new EncodedGraph(encoder.getEncoding(), startOffset, encoder.getObjects(), encoder.getNodeClasses(), graph);\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.replacements.AESCryptSubstitutions.checkArgs",
	"Comment": "perform null and array bounds checks for arguments to a cipher operation.",
	"Method": "void checkArgs(byte[] in,int inOffset,byte[] out,int outOffset){\r\n    if (probability(VERY_SLOW_PATH_PROBABILITY, inOffset < 0 || in.length - AES_BLOCK_SIZE_IN_BYTES < inOffset || outOffset < 0 || out.length - AES_BLOCK_SIZE_IN_BYTES < outOffset)) {\r\n        DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.stubs.StubUtil.cAssertionsEnabled",
	"Comment": "determines if this is a hotspot build where the assert mechanism is enabled.",
	"Method": "boolean cAssertionsEnabled(GraalHotSpotVMConfig config){\r\n    return config.cAssertions;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.trace.lsra.TraceLinearScanWalker.allocLockedRegister",
	"Comment": "split an interval and spill it to memory so that cur can be placed in a register",
	"Method": "void allocLockedRegister(TraceInterval interval){\r\n    try (Indent indent = debug.logAndIndent(\"alloc locked register: need to split and spill to get register for %s\", interval)) {\r\n        int firstUsage = interval.firstUsage(RegisterPriority.MustHaveRegister);\r\n        int firstShouldHaveUsage = interval.firstUsage(RegisterPriority.ShouldHaveRegister);\r\n        int regNeededUntil = Math.min(firstUsage, interval.from() + 1);\r\n        int intervalTo = interval.to();\r\n        assert regNeededUntil >= 0 && regNeededUntil < Integer.MAX_VALUE : \"interval has no use\";\r\n        Register reg;\r\n        Register ignore;\r\n        for (RegisterPriority registerPriority = RegisterPriority.LiveAtLoopEnd; true; registerPriority = RegisterPriority.MustHaveRegister) {\r\n            initUseLists(false);\r\n            spillExcludeActiveFixed();\r\n            spillBlockInactiveFixed(interval);\r\n            spillCollectActiveAny(registerPriority);\r\n            if (debug.isLogEnabled()) {\r\n                printRegisterState();\r\n            }\r\n            reg = null;\r\n            ignore = interval.location() != null && isRegister(interval.location()) ? asRegister(interval.location()) : null;\r\n            for (Register availableReg : availableRegs) {\r\n                int number = availableReg.number;\r\n                if (availableReg.equals(ignore)) {\r\n                } else if (usePos[number] > regNeededUntil) {\r\n                    if (reg == null || (usePos[number] > usePos[reg.number]) || (usePos[number] == usePos[reg.number] && (!isInMemory.get(reg.number) && isInMemory.get(number)))) {\r\n                        reg = availableReg;\r\n                    }\r\n                }\r\n            }\r\n            if (debug.isLogEnabled()) {\r\n                debug.log(\"Register Selected: %s\", reg);\r\n            }\r\n            int regUsePos = (reg == null ? 0 : usePos[reg.number]);\r\n            if (regUsePos <= firstShouldHaveUsage) {\r\n                if (reg == null || interval.inMemoryAt(currentPosition) || !isInMemory.get(reg.number)) {\r\n                    if (debug.isLogEnabled()) {\r\n                        debug.log(\"able to spill current interval. firstUsage(register): %d, usePos: %d\", firstUsage, regUsePos);\r\n                    }\r\n                    if (firstUsage <= interval.from() + 1) {\r\n                        if (registerPriority.equals(RegisterPriority.LiveAtLoopEnd)) {\r\n                            debug.log(\"retry with register priority must have register\");\r\n                            continue;\r\n                        }\r\n                        String description = \"cannot spill interval (\" + interval + \") that is used in first instruction (possible reason: no register found) firstUsage=\" + firstUsage + \", interval.from()=\" + interval.from() + \"; already used candidates: \" + Arrays.toString(availableRegs);\r\n                        allocator.assignSpillSlot(interval);\r\n                        if (debug.isDumpEnabled(DebugContext.INFO_LEVEL)) {\r\n                            dumpLIRAndIntervals(description);\r\n                        }\r\n                        throw new OutOfRegistersException(\"LinearScan: no register found\", description);\r\n                    }\r\n                    splitAndSpillInterval(interval);\r\n                    return;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        boolean needSplit = blockPos[reg.number] <= intervalTo;\r\n        int splitPos = blockPos[reg.number];\r\n        if (debug.isLogEnabled()) {\r\n            debug.log(\"decided to use register %d\", reg.number);\r\n        }\r\n        assert splitPos > 0 : \"invalid splitPos\";\r\n        assert needSplit || splitPos > interval.from() : \"splitting interval at from\";\r\n        interval.assignLocation(reg.asValue(allocator.getKind(interval)));\r\n        if (needSplit) {\r\n            splitWhenPartialRegisterAvailable(interval, splitPos);\r\n        }\r\n        splitAndSpillIntersectingIntervals(reg);\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.printer.CompilationPrinter.flush",
	"Comment": "flushes all buffered output to the underlying output stream.",
	"Method": "void flush(){\r\n    out.flush();\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.AbstractMergeNode.removeEnd",
	"Comment": "removes the given end from the merge, along with the entries corresponding to this end in thephis connected to the merge.",
	"Method": "void removeEnd(AbstractEndNode pred){\r\n    int predIndex = phiPredecessorIndex(pred);\r\n    assert predIndex != -1;\r\n    deleteEnd(pred);\r\n    for (PhiNode phi : phis().snapshot()) {\r\n        if (phi.isDeleted()) {\r\n            continue;\r\n        }\r\n        ValueNode removedValue = phi.valueAt(predIndex);\r\n        phi.removeInput(predIndex);\r\n        if (removedValue != null) {\r\n            GraphUtil.tryKillUnused(removedValue);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.stubs.StubUtil.decipher",
	"Comment": "analyzes a given value and prints information about it to the log stream.",
	"Method": "void decipher(long value){\r\n    vmMessageC(VM_MESSAGE_C, false, WordFactory.zero(), value, 0L, 0L);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.test.AArch64AddSubShiftTest.testAddShiftLong",
	"Comment": "check whether the addsubshift match rule in aarch64nodematchrules does work for add operationwith long type and check if the expected lir instructions show up.",
	"Method": "void testAddShiftLong(){\r\n    test(\"addShiftLong\", 1234567L);\r\n    checkLIR(\"addShiftLong\", predicate, 6);\r\n}"
}, {
	"Path": "org.graalvm.compiler.graph.Graph.hasNode",
	"Comment": "returns whether the graph contains at least one node of the given type.",
	"Method": "boolean hasNode(NodeClass<T> type){\r\n    return getNodes(type).iterator().hasNext();\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.amd64.AMD64ArrayEqualsOp.emitFloatCompare",
	"Comment": "emits code to compare if two floats are bitwise equal or both nan.",
	"Method": "void emitFloatCompare(AMD64MacroAssembler masm,JavaKind kind,Register base1,Register base2,Register index,Value temp4,Value tempXMM,int offset,Label falseLabel,boolean skipBitwiseCompare){\r\n    AMD64Address address1 = new AMD64Address(base1, index, Scale.Times1, offset);\r\n    AMD64Address address2 = new AMD64Address(base2, index, Scale.Times1, offset);\r\n    Label bitwiseEqual = new Label();\r\n    if (!skipBitwiseCompare) {\r\n        Register temp = asRegister(temp4);\r\n        if (kind == JavaKind.Float) {\r\n            masm.movl(temp, address1);\r\n            masm.cmpl(temp, address2);\r\n        } else {\r\n            masm.movq(temp, address1);\r\n            masm.cmpq(temp, address2);\r\n        }\r\n        masm.jccb(ConditionFlag.Equal, bitwiseEqual);\r\n    }\r\n    emitNaNCheck(masm, kind, tempXMM, address1, falseLabel);\r\n    emitNaNCheck(masm, kind, tempXMM, address2, falseLabel);\r\n    masm.bind(bitwiseEqual);\r\n}"
}, {
	"Path": "org.graalvm.compiler.options.OptionDescriptor.getLocation",
	"Comment": "gets a description of the location where this option is stored.",
	"Method": "String getLocation(){\r\n    return getDeclaringClass().getName() + \".\" + getFieldName();\r\n}"
}, {
	"Path": "org.graalvm.nativeimage.c.type.CTypeConversion.toCBoolean",
	"Comment": "converts a java boolean into a c int containing boolean values.",
	"Method": "byte toCBoolean(boolean value){\r\n    return (byte) (value ? 1 : 0);\r\n}"
}, {
	"Path": "org.graalvm.polyglot.Value.getArrayElement",
	"Comment": "returns the array element of a given index. polyglot arrays start with index 0,independent of the guest language. the given array index must be greater or equal to 0.",
	"Method": "Value getArrayElement(long index){\r\n    return impl.getArrayElement(receiver, index);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.test.AArch64AddSubShiftTest.testSubShiftInt",
	"Comment": "check whether the addsubshift match rule in aarch64nodematchrules does work for sub operationwith int type and check if the expected lir instructions show up.",
	"Method": "void testSubShiftInt(){\r\n    test(\"subShiftInt\", 123, 456);\r\n    checkLIR(\"subShiftInt\", predicate, 3);\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.test.TimerKeyTest.test2",
	"Comment": "asserts that a timer replied recursively without any other interleaving timers has the sameflat and accumulated times.",
	"Method": "void test2(){\r\n    EconomicMap<OptionKey<?>, Object> map = EconomicMap.create();\r\n    map.put(DebugOptions.Time, \"\");\r\n    OptionValues options = new OptionValues(map);\r\n    DebugContext debug = DebugContext.create(options, NO_DESCRIPTION, NO_GLOBAL_METRIC_VALUES, DEFAULT_LOG_STREAM, NO_CONFIG_CUSTOMIZERS);\r\n    TimerKey timerC = DebugContext.timer(\"TimerC\");\r\n    try (DebugCloseable c1 = timerC.start(debug)) {\r\n        spin(50);\r\n        try (DebugCloseable c2 = timerC.start(debug)) {\r\n            spin(50);\r\n            try (DebugCloseable c3 = timerC.start(debug)) {\r\n                spin(50);\r\n                try (DebugCloseable c4 = timerC.start(debug)) {\r\n                    spin(50);\r\n                    try (DebugCloseable c5 = timerC.start(debug)) {\r\n                        spin(50);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (timerC.getFlat() != null) {\r\n        assertEquals(timerC.getFlat().getCurrentValue(debug), timerC.getCurrentValue(debug));\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.nativeimage.ImageSingletons.add",
	"Comment": "add a singleton to the registry. the key must be unique, i.e., no value must have beenregistered with the given class before.",
	"Method": "void add(Class<T> key,T value){\r\n    ImageSingletonsSupport.get().add(key, value);\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.test.WriteBarrierAdditionTest.test7",
	"Comment": "the following test concerns the runtime checks of the unsafe loads. in this test, we unsafelyload a matching offset of a wrong object so the pre barier must not be executed.",
	"Method": "void test7(){\r\n    test2(\"testUnsafeLoad\", UNSAFE, con, Long.valueOf(referentOffset), null);\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.test.WriteBarrierAdditionTest.test6",
	"Comment": "the following test concerns the runtime checks of the unsafe loads. in this test, we unsafelyload the java.lang.ref.reference.referent field so the pre barier has to be executed.",
	"Method": "void test6(){\r\n    test2(\"testUnsafeLoad\", UNSAFE, wr, Long.valueOf(referentOffset), null);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.test.AArch64AddSubShiftTest.addLeftShiftInt",
	"Comment": "addsubshift match rule test for add operation with int type.",
	"Method": "int addLeftShiftInt(int input){\r\n    int output = (input << 5) + input;\r\n    output += output << -5;\r\n    output += output << 32;\r\n    return output;\r\n}"
}, {
	"Path": "org.graalvm.polyglot.management.ExecutionEvent.getLocation",
	"Comment": "returns the source location of the event that was triggered or null if nolocation source location is available.",
	"Method": "SourceSection getLocation(){\r\n    return IMPL.getLocation(impl);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.StructuredGraph.getAssumptions",
	"Comment": "gets the object for recording assumptions while constructing of this graph.",
	"Method": "Assumptions getAssumptions(){\r\n    return assumptions;\r\n}"
}, {
	"Path": "org.graalvm.polyglot.Engine.getVersion",
	"Comment": "gets the version string of the engine in an unspecified format.",
	"Method": "String getVersion(){\r\n    return impl.getVersion();\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.sparc.test.SPARCAssemblerTest.doTestControlTransferOp",
	"Comment": "assembles the control transfer op and then verifies the expected disp value against the dispfield provided by the disassembler.",
	"Method": "void doTestControlTransferOp(Consumer<Label> opCreator,int minDisp,int maxDisp){\r\n    Label lBack = new Label();\r\n    Label lForward = new Label();\r\n    masm.bind(lBack);\r\n    for (int i = 0; i < -minDisp; i++) {\r\n        masm.nop();\r\n    }\r\n    int backPos = masm.position();\r\n    opCreator.accept(lBack);\r\n    masm.nop();\r\n    int forwardPos = masm.position();\r\n    opCreator.accept(lForward);\r\n    for (int i = 0; i < maxDisp - 1; i++) {\r\n        masm.nop();\r\n    }\r\n    masm.bind(lForward);\r\n    int condBack = masm.getInt(backPos);\r\n    SPARCOp backOp = SPARCAssembler.getSPARCOp(condBack);\r\n    int dispBack = ((ControlTransferOp) backOp).getDisp(condBack);\r\n    Assert.assertEquals(minDisp, dispBack);\r\n    int condFwd = masm.getInt(forwardPos);\r\n    SPARCOp fwdOp = SPARCAssembler.getSPARCOp(condFwd);\r\n    int dispFwd = ((ControlTransferOp) fwdOp).getDisp(condFwd);\r\n    Assert.assertEquals(maxDisp, dispFwd);\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.compiler.TruffleCompilerImpl.getBackend",
	"Comment": "gets the graal compiler backend used for truffle compilation.",
	"Method": "Backend getBackend(){\r\n    return backend;\r\n}"
}, {
	"Path": "org.graalvm.options.OptionDescriptor.newBuilder",
	"Comment": "creates a new option descriptor builder by key. the option group and name is inferred by thekey.",
	"Method": "Builder newBuilder(OptionKey<T> key,String name){\r\n    Objects.requireNonNull(key);\r\n    Objects.requireNonNull(name);\r\n    return EMPTY.new Builder(key, name);\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.amd64.AMD64SaveRegistersOp.indexForStackSlot",
	"Comment": "computes the index of a stack slot relative to slot 0. this is also the bit index of stackslots in the reference map.",
	"Method": "int indexForStackSlot(FrameMap frameMap,StackSlot slot){\r\n    assert frameMap.offsetForStackSlot(slot) % frameMap.getTarget().wordSize == 0;\r\n    int value = frameMap.offsetForStackSlot(slot) / frameMap.getTarget().wordSize;\r\n    return value;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.DumpPathTest.checkForFiles",
	"Comment": "check that the given directory contains file or directory names with all the givenextensions.",
	"Method": "void checkForFiles(Path directoryPath,String[] extensions){\r\n    String[] paths = new String[extensions.length];\r\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(directoryPath)) {\r\n        for (Path filePath : stream) {\r\n            String fileName = filePath.getFileName().toString();\r\n            for (int i = 0; i < extensions.length; i++) {\r\n                String extension = extensions[i];\r\n                if (fileName.endsWith(extensions[i])) {\r\n                    assertTrue(paths[i] == null, \"multiple files found for %s in %s\", extension, directoryPath);\r\n                    paths[i] = fileName.replace(extensions[i], \"\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < paths.length; i++) {\r\n        assertTrue(paths[i] != null, \"missing file for extension %s in %s\", extensions[i], directoryPath);\r\n    }\r\n    for (int i = 1; i < paths.length; i++) {\r\n        assertTrue(paths[0].equals(paths[i]), paths[0] + \" != \" + paths[i]);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.InstanceOfSnippetsTemplates.createReplacer",
	"Comment": "gets the specific replacer object used to replace the usage of an instanceof node with theresult of an instantiated instanceof snippet.",
	"Method": "InstanceOfUsageReplacer createReplacer(FloatingNode instanceOf,Instantiation instantiation,Node usage,StructuredGraph graph){\r\n    InstanceOfUsageReplacer replacer;\r\n    if (!canMaterialize(usage)) {\r\n        ValueNode trueValue = ConstantNode.forInt(1, graph);\r\n        ValueNode falseValue = ConstantNode.forInt(0, graph);\r\n        if (instantiation.isInitialized() && (trueValue != instantiation.trueValue || falseValue != instantiation.falseValue)) {\r\n            trueValue = instantiation.trueValue;\r\n            falseValue = instantiation.falseValue;\r\n        }\r\n        replacer = new NonMaterializationUsageReplacer(instantiation, trueValue, falseValue, instanceOf, usage);\r\n    } else {\r\n        assert usage instanceof ConditionalNode : \"unexpected usage of \" + instanceOf + \": \" + usage;\r\n        ConditionalNode c = (ConditionalNode) usage;\r\n        replacer = new MaterializationUsageReplacer(instantiation, c.trueValue(), c.falseValue(), instanceOf, c);\r\n    }\r\n    return replacer;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.test.AArch64AddSubShiftTest.subLeftShiftInt",
	"Comment": "addsubshift match rule test for sub operation with int type.",
	"Method": "int subLeftShiftInt(int input0,int input1){\r\n    return input0 - (input1 << 5);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.alloc.ComputeBlockOrder.skipLoopHeader",
	"Comment": "skip the loop header block if the loop consists of more than one block and it has only asingle loop end block.",
	"Method": "boolean skipLoopHeader(AbstractBlockBase<T> block){\r\n    return (block.isLoopHeader() && !block.isLoopEnd() && block.getLoop().numBackedges() == 1);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.deopt.MonitorDeoptTest.removeLoopSafepoint",
	"Comment": "remove the safepoint from the first loop in the test method, so only the safepoints onmonitorenter and monitorexit remain in the loop. that way, we can make sure it deopts insidethe monitorenter by invalidating the code while holding the lock.",
	"Method": "void removeLoopSafepoint(StructuredGraph graph){\r\n    LoopBeginNode loopBegin = findFirstLoop(graph);\r\n    loopBegin.disableSafepoint();\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.Assertions.detailedAssertionsEnabled",
	"Comment": "determines if detailed assertions are enabled. this requires that the normal assertions arealso enabled.",
	"Method": "boolean detailedAssertionsEnabled(OptionValues values){\r\n    return assertionsEnabled() && Options.DetailedAsserts.getValue(values);\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.trace.lsra.TraceLinearScanWalker.activateCurrent",
	"Comment": "allocate a physical register or memory location to an interval",
	"Method": "boolean activateCurrent(TraceInterval interval){\r\n    if (debug.isLogEnabled()) {\r\n        logCurrentStatus();\r\n    }\r\n    boolean result = true;\r\n    try (Indent indent = debug.logAndIndent(\"activating interval %s,  splitParent: %d\", interval, interval.splitParent().operandNumber)) {\r\n        if (interval.location() != null && isStackSlotValue(interval.location())) {\r\n            if (debug.isLogEnabled()) {\r\n                debug.log(\"interval has spill slot assigned (method parameter) . split it before first use\");\r\n            }\r\n            splitStackInterval(interval);\r\n            result = false;\r\n        } else {\r\n            if (interval.location() == null) {\r\n                if (debug.isLogEnabled()) {\r\n                    debug.log(\"normal allocation of register\");\r\n                }\r\n                combineSpilledIntervals(interval);\r\n                initVarsForAlloc(interval);\r\n                if (noAllocationPossible(interval) || !allocFreeRegister(interval)) {\r\n                    allocLockedRegister(interval);\r\n                }\r\n                if (!isRegister(interval.location())) {\r\n                    result = false;\r\n                }\r\n            }\r\n        }\r\n        if (interval.insertMoveWhenActivated()) {\r\n            assert interval.isSplitChild();\r\n            assert interval.currentSplitChild() != null;\r\n            assert interval.currentSplitChild().operandNumber != interval.operandNumber : \"cannot insert move between same interval\";\r\n            if (debug.isLogEnabled()) {\r\n                debug.log(\"Inserting move from interval %d to %d because insertMoveWhenActivated is set\", interval.currentSplitChild().operandNumber, interval.operandNumber);\r\n            }\r\n            insertMove(interval.from(), interval.currentSplitChild(), interval);\r\n        }\r\n        interval.makeCurrentSplitChild();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.test.AArch64MultiplyAddSubTest.mulSubLong",
	"Comment": "multiplyaddsub match rule test for sub operation with long type.",
	"Method": "long mulSubLong(long input0,long input1,long input2){\r\n    return input2 - input0 * input1;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.MergeCanonicalizerTest.getDefaultHighTierContext",
	"Comment": "these tests assume all code paths are reachable so disable profile based dead code removal.",
	"Method": "HighTierContext getDefaultHighTierContext(){\r\n    return new HighTierContext(getProviders(), getDefaultGraphBuilderSuite(), OptimisticOptimizations.ALL.remove(Optimization.RemoveNeverExecutedCode));\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.DebugContext.forCurrentThread",
	"Comment": "gets the debug context for the current thread. this should only be used when there is noother reasonable means to get a hold of a debug context.",
	"Method": "DebugContext forCurrentThread(){\r\n    DebugContext current = activated.get();\r\n    if (current == null) {\r\n        return DISABLED;\r\n    }\r\n    return current;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.cfg.ControlFlowGraph.computeFrequencies",
	"Comment": "computes the frequencies of all blocks relative to the start block. it uses the probabilityinformation attached to control flow splits to calculate the frequency of a block based onthe frequency of its predecessor and the probability of its incoming control flow branch.",
	"Method": "void computeFrequencies(){\r\n    for (Block block : reversePostOrder) {\r\n        Block[] predecessors = block.getPredecessors();\r\n        double relativeFrequency;\r\n        if (predecessors.length == 0) {\r\n            relativeFrequency = 1D;\r\n        } else if (predecessors.length == 1) {\r\n            Block pred = predecessors[0];\r\n            relativeFrequency = pred.relativeFrequency;\r\n            if (pred.getSuccessorCount() > 1) {\r\n                assert pred.getEndNode() instanceof ControlSplitNode;\r\n                ControlSplitNode controlSplit = (ControlSplitNode) pred.getEndNode();\r\n                relativeFrequency = multiplyRelativeFrequencies(relativeFrequency, controlSplit.probability(block.getBeginNode()));\r\n            }\r\n        } else {\r\n            relativeFrequency = predecessors[0].relativeFrequency;\r\n            for (int i = 1; i < predecessors.length; ++i) {\r\n                relativeFrequency += predecessors[i].relativeFrequency;\r\n            }\r\n            if (block.getBeginNode() instanceof LoopBeginNode) {\r\n                LoopBeginNode loopBegin = (LoopBeginNode) block.getBeginNode();\r\n                relativeFrequency = multiplyRelativeFrequencies(relativeFrequency, loopBegin.loopFrequency());\r\n            }\r\n        }\r\n        if (relativeFrequency < MIN_RELATIVE_FREQUENCY) {\r\n            relativeFrequency = MIN_RELATIVE_FREQUENCY;\r\n        } else if (relativeFrequency > MAX_RELATIVE_FREQUENCY) {\r\n            relativeFrequency = MAX_RELATIVE_FREQUENCY;\r\n        }\r\n        block.setRelativeFrequency(relativeFrequency);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.code.CompilationResult.getFields",
	"Comment": "gets the fields that were referenced from bytecodes that were used as input to thecompilation.the caller must not modify the contents of the returned array.",
	"Method": "ResolvedJavaField[] getFields(){\r\n    return fields;\r\n}"
}, {
	"Path": "org.graalvm.options.OptionDescriptor.isDeprecated",
	"Comment": "returns true if this option was marked deprecated. this indicates that theoption is going to be removed in a future release or its use is not recommended.",
	"Method": "boolean isDeprecated(){\r\n    return deprecated;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.tutorial.StaticAnalysis.addMethod",
	"Comment": "adds a root method to the static analysis. the method must be static and must not have anyparameters, because the possible types of the parameters would not be known.",
	"Method": "void addMethod(ResolvedJavaMethod method){\r\n    if (!method.isStatic() || method.getSignature().getParameterCount(false) > 0) {\r\n        error(\"Entry point method is not static or has parameters: \" + method.format(\"%H.%n(%p)\"));\r\n    }\r\n    addToWorklist(results.lookupMethod(method));\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.type.TypeReference.create",
	"Comment": "creates a type reference using the given type with assumptions and without trusting interfacetypes.",
	"Method": "TypeReference create(Assumptions assumptions,ResolvedJavaType type){\r\n    return createTrusted(assumptions, filterInterfaceTypesOut(type));\r\n}"
}, {
	"Path": "org.graalvm.compiler.graph.NodeClass.getEdges",
	"Comment": "gets the input or successor edges defined by this node class.",
	"Method": "Edges getEdges(Edges.Type type){\r\n    return type == Edges.Type.Inputs ? inputs : successors;\r\n}"
}, {
	"Path": "org.graalvm.compiler.java.BytecodeParser.shouldComplementProbability",
	"Comment": "hook for subclasses to decide whether the ifnode probability should be complemented duringconversion to graal ir.",
	"Method": "boolean shouldComplementProbability(){\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.match.MatchContext.consume",
	"Comment": "mark a node as consumed by the match. consumed nodes will never be evaluated.",
	"Method": "Result consume(Node node){\r\n    assert MatchPattern.isSingleValueUser(node) : \"should have already been checked\";\r\n    int index = nodes.indexOf(node);\r\n    if (index == -1) {\r\n        return Result.notInBlock(node, rule.getPattern());\r\n    }\r\n    if (builder.hasOperand(node)) {\r\n        return Result.alreadyUsed(node, rule.getPattern());\r\n    }\r\n    startIndex = Math.min(startIndex, index);\r\n    if (consumed == null) {\r\n        consumed = new ArrayList(2);\r\n    }\r\n    consumed.add(node);\r\n    return Result.OK;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.IfNode.splitIfAtPhi",
	"Comment": "take an if that is immediately dominated by a merge with a single phi and split off any pathswhere the test would be statically decidable creating a new merge below the approriate sideof the ifnode. any undecidable tests will continue to use the original ifnode.",
	"Method": "boolean splitIfAtPhi(SimplifierTool tool){\r\n    if (graph().getGuardsStage().areFrameStatesAtSideEffects()) {\r\n        return false;\r\n    }\r\n    if (!(predecessor() instanceof MergeNode)) {\r\n        return false;\r\n    }\r\n    MergeNode merge = (MergeNode) predecessor();\r\n    if (merge.forwardEndCount() == 1) {\r\n        return false;\r\n    }\r\n    if (merge.usages().count() != 1 || merge.phis().count() != 1) {\r\n        return false;\r\n    }\r\n    if (merge.stateAfter() != null) {\r\n        return false;\r\n    }\r\n    PhiNode phi = merge.phis().first();\r\n    if (phi.usages().count() != 1) {\r\n        return false;\r\n    }\r\n    if (!conditionUses(condition(), phi)) {\r\n        return false;\r\n    }\r\n    MergeNode trueMerge = null;\r\n    MergeNode falseMerge = null;\r\n    assert merge.stateAfter() == null;\r\n    for (EndNode end : merge.forwardEnds().snapshot()) {\r\n        Node value = phi.valueAt(end);\r\n        LogicNode result = computeCondition(tool, condition, phi, value);\r\n        if (result instanceof LogicConstantNode) {\r\n            merge.removeEnd(end);\r\n            if (((LogicConstantNode) result).getValue()) {\r\n                if (trueMerge == null) {\r\n                    trueMerge = insertMerge(trueSuccessor());\r\n                }\r\n                trueMerge.addForwardEnd(end);\r\n            } else {\r\n                if (falseMerge == null) {\r\n                    falseMerge = insertMerge(falseSuccessor());\r\n                }\r\n                falseMerge.addForwardEnd(end);\r\n            }\r\n        } else if (result != condition) {\r\n            BeginNode trueBegin = graph().add(new BeginNode());\r\n            trueBegin.setNodeSourcePosition(trueSuccessor().getNodeSourcePosition());\r\n            BeginNode falseBegin = graph().add(new BeginNode());\r\n            falseBegin.setNodeSourcePosition(falseSuccessor().getNodeSourcePosition());\r\n            if (result.graph() == null) {\r\n                result = graph().addOrUniqueWithInputs(result);\r\n                result.setNodeSourcePosition(condition.getNodeSourcePosition());\r\n            }\r\n            IfNode newIfNode = graph().add(new IfNode(result, trueBegin, falseBegin, trueSuccessorProbability));\r\n            newIfNode.setNodeSourcePosition(getNodeSourcePosition());\r\n            merge.removeEnd(end);\r\n            ((FixedWithNextNode) end.predecessor()).setNext(newIfNode);\r\n            if (trueMerge == null) {\r\n                trueMerge = insertMerge(trueSuccessor());\r\n            }\r\n            trueBegin.setNext(graph().add(new EndNode()));\r\n            trueMerge.addForwardEnd((EndNode) trueBegin.next());\r\n            if (falseMerge == null) {\r\n                falseMerge = insertMerge(falseSuccessor());\r\n            }\r\n            falseBegin.setNext(graph().add(new EndNode()));\r\n            falseMerge.addForwardEnd((EndNode) falseBegin.next());\r\n            end.safeDelete();\r\n        }\r\n    }\r\n    transferProxies(trueSuccessor(), trueMerge);\r\n    transferProxies(falseSuccessor(), falseMerge);\r\n    cleanupMerge(merge);\r\n    cleanupMerge(trueMerge);\r\n    cleanupMerge(falseMerge);\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.amd64.AMD64ArrayEqualsOp.supportsSSE41",
	"Comment": "returns if the underlying amd64 architecture supports sse 4.1 instructions.",
	"Method": "boolean supportsSSE41(TargetDescription target){\r\n    AMD64 arch = (AMD64) target.arch;\r\n    return arch.getFeatures().contains(CPUFeature.SSE4_1);\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.aarch64.AArch64Assembler.fmovCpu2Fpu",
	"Comment": "move size bits from general purpose register unchanged to floating point register.",
	"Method": "void fmovCpu2Fpu(int size,Register dst,Register src){\r\n    assert dst.getRegisterCategory().equals(SIMD);\r\n    assert src.getRegisterCategory().equals(CPU);\r\n    fmovCpuFpuInstruction(dst, src, size == 64, Instruction.FMOVCPU2FPU);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.amd64.test.AMD64MatchRuleTest.test1",
	"Comment": "verifies, if the match rules in amd64nodematchrules do work on the graphs by compiling andchecking if the expected lir instruction show up.",
	"Method": "void test1(){\r\n    compile(getResolvedJavaMethod(\"test1Snippet\"), null);\r\n    LIR lir = getLIR();\r\n    boolean found = false;\r\n    for (LIRInstruction ins : lir.getLIRforBlock(lir.codeEmittingOrder()[0])) {\r\n        if (ins instanceof MemoryConstOp && ((MemoryConstOp) ins).getOpcode().toString().equals(\"CMP\")) {\r\n            assertFalse(\"MemoryConstOp expected only once in first block\", found);\r\n            found = true;\r\n        }\r\n    }\r\n    assertTrue(\"Memory compare must be in the LIR\", found);\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.trace.lsra.TraceLocalMoveResolver.unblockRegisters",
	"Comment": "mark assignedreg and assignedreghi of the interval as unblocked",
	"Method": "void unblockRegisters(TraceInterval interval){\r\n    Value location = interval.location();\r\n    if (mightBeBlocked(location)) {\r\n        assert valueBlocked(location) > 0 : \"location already marked as unused: \" + location;\r\n        setValueBlocked(location, -1);\r\n        debug.log(\"unblock %s\", location);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.LIR.hasDebugInfo",
	"Comment": "determines if any instruction in the lir has debug info associated with it.",
	"Method": "boolean hasDebugInfo(){\r\n    for (AbstractBlockBase<?> b : linearScanOrder()) {\r\n        for (LIRInstruction op : getLIRforBlock(b)) {\r\n            if (op.hasState()) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.ea.EscapeAnalysisTest.testRemovalSpecialCase",
	"Comment": "test the case where allocations before and during a loop that have no usages other than theirphi need to be recognized as an important change. this needs a loop so that the allocation isnot trivially removed by dead code elimination.",
	"Method": "void testRemovalSpecialCase(){\r\n    prepareGraph(\"testRemovalSpecialCaseSnippet\", false);\r\n    Assert.assertEquals(2, graph.getNodes().filter(CommitAllocationNode.class).count());\r\n    graph.replaceFixedWithFloating(graph.getNodes().filter(LoadFieldNode.class).first(), graph.unique(ConstantNode.forInt(0)));\r\n    new CanonicalizerPhase().apply(graph, context);\r\n    new PartialEscapePhase(false, false, new CanonicalizerPhase(), null, graph.getOptions()).apply(graph, context);\r\n    Assert.assertEquals(0, graph.getNodes().filter(CommitAllocationNode.class).count());\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.DebugContext.withContext",
	"Comment": "create an unnamed scope that appends some context to the current scope.",
	"Method": "DebugContext.Scope withContext(Object context){\r\n    if (currentScope != null) {\r\n        return enterScope(\"\", null, context);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.GraalCompilerTest.getCode",
	"Comment": "gets installed code for a given method and graph, compiling it first if necessary.",
	"Method": "InstalledCode getCode(ResolvedJavaMethod method,InstalledCode getCode,ResolvedJavaMethod method,OptionValues options,InstalledCode getCode,ResolvedJavaMethod installedCodeOwner,StructuredGraph graph,InstalledCode getCode,ResolvedJavaMethod installedCodeOwner,StructuredGraph graph,boolean forceCompile,InstalledCode getCode,ResolvedJavaMethod installedCodeOwner,StructuredGraph graph,boolean forceCompile,boolean installAsDefault,OptionValues options){\r\n    boolean useCache = !forceCompile && getArgumentToBind() == null;\r\n    if (useCache && graph == null) {\r\n        InstalledCode cached = cache.get(installedCodeOwner);\r\n        if (cached != null) {\r\n            if (cached.isValid()) {\r\n                return cached;\r\n            }\r\n        }\r\n    }\r\n    for (int retry = 0; retry <= BAILOUT_RETRY_LIMIT; retry++) {\r\n        final CompilationIdentifier id = getOrCreateCompilationId(installedCodeOwner, graph);\r\n        InstalledCode installedCode = null;\r\n        StructuredGraph graphToCompile = graph == null ? parseForCompile(installedCodeOwner, id, options) : graph;\r\n        DebugContext debug = graphToCompile.getDebug();\r\n        try (AllocSpy spy = AllocSpy.open(installedCodeOwner);\r\n            DebugContext.Scope ds = debug.scope(\"Compiling\", new DebugDumpScope(id.toString(CompilationIdentifier.Verbosity.ID), true))) {\r\n            CompilationPrinter printer = CompilationPrinter.begin(options, id, installedCodeOwner, INVOCATION_ENTRY_BCI);\r\n            CompilationResult compResult = compile(installedCodeOwner, graphToCompile, new CompilationResult(graphToCompile.compilationId()), id, options);\r\n            printer.finish(compResult);\r\n            try (DebugContext.Scope s = debug.scope(\"CodeInstall\", getCodeCache(), installedCodeOwner, compResult);\r\n                DebugContext.Activation a = debug.activate()) {\r\n                try {\r\n                    if (installAsDefault) {\r\n                        installedCode = addDefaultMethod(debug, installedCodeOwner, compResult);\r\n                    } else {\r\n                        installedCode = addMethod(debug, installedCodeOwner, compResult);\r\n                    }\r\n                    if (installedCode == null) {\r\n                        throw new GraalError(\"Could not install code for \" + installedCodeOwner.format(\"%H.%n(%p)\"));\r\n                    }\r\n                } catch (BailoutException e) {\r\n                    if (retry < BAILOUT_RETRY_LIMIT && graph == null && !e.isPermanent()) {\r\n                        TTY.println(String.format(\"Restart compilation %s (%s) due to a non-permanent bailout!\", installedCodeOwner, id));\r\n                        continue;\r\n                    }\r\n                    throw e;\r\n                }\r\n            } catch (Throwable e) {\r\n                throw debug.handle(e);\r\n            }\r\n        } catch (Throwable e) {\r\n            throw debug.handle(e);\r\n        }\r\n        if (useCache) {\r\n            cache.put(installedCodeOwner, installedCode);\r\n        }\r\n        return installedCode;\r\n    }\r\n    throw GraalError.shouldNotReachHere();\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.AbstractMergeNode.simplify",
	"Comment": "this simplify method can deal with a null value for tool, so that it can be used outside ofcanonicalization.",
	"Method": "void simplify(SimplifierTool tool){\r\n    FixedNode currentNext = next();\r\n    if (currentNext instanceof AbstractEndNode) {\r\n        AbstractEndNode origLoopEnd = (AbstractEndNode) currentNext;\r\n        AbstractMergeNode merge = origLoopEnd.merge();\r\n        if (merge instanceof LoopBeginNode && !(origLoopEnd instanceof LoopEndNode)) {\r\n            return;\r\n        }\r\n        if (this.anchored().isNotEmpty()) {\r\n            return;\r\n        }\r\n        if (merge.stateAfter() == null && this.stateAfter() != null) {\r\n            return;\r\n        }\r\n        for (PhiNode phi : phis()) {\r\n            for (Node usage : phi.usages()) {\r\n                if (!(usage instanceof VirtualState) && !merge.isPhiAtMerge(usage)) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        getDebug().log(\"Split %s into ends for %s.\", this, merge);\r\n        int numEnds = this.forwardEndCount();\r\n        for (int i = 0; i < numEnds - 1; i++) {\r\n            AbstractEndNode end = forwardEndAt(numEnds - 1 - i);\r\n            if (tool != null) {\r\n                tool.addToWorkList(end);\r\n            }\r\n            AbstractEndNode newEnd;\r\n            try (DebugCloseable position = end.withNodeSourcePosition()) {\r\n                if (merge instanceof LoopBeginNode) {\r\n                    newEnd = graph().add(new LoopEndNode((LoopBeginNode) merge));\r\n                } else {\r\n                    EndNode tmpEnd = graph().add(new EndNode());\r\n                    merge.addForwardEnd(tmpEnd);\r\n                    newEnd = tmpEnd;\r\n                }\r\n            }\r\n            for (PhiNode phi : merge.phis()) {\r\n                ValueNode v = phi.valueAt(origLoopEnd);\r\n                ValueNode newInput;\r\n                if (isPhiAtMerge(v)) {\r\n                    PhiNode endPhi = (PhiNode) v;\r\n                    newInput = endPhi.valueAt(end);\r\n                } else {\r\n                    newInput = v;\r\n                }\r\n                phi.addInput(newInput);\r\n            }\r\n            this.removeEnd(end);\r\n            end.replaceAtPredecessor(newEnd);\r\n            end.safeDelete();\r\n            if (tool != null) {\r\n                tool.addToWorkList(newEnd.predecessor());\r\n            }\r\n        }\r\n        graph().reduceTrivialMerge(this);\r\n    } else if (currentNext instanceof ReturnNode) {\r\n        ReturnNode returnNode = (ReturnNode) currentNext;\r\n        if (anchored().isNotEmpty() || returnNode.getMemoryMap() != null) {\r\n            return;\r\n        }\r\n        List<PhiNode> phis = phis().snapshot();\r\n        for (PhiNode phi : phis) {\r\n            for (Node usage : phi.usages()) {\r\n                if (usage != returnNode && !(usage instanceof FrameState)) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        ValuePhiNode returnValuePhi = returnNode.result() == null || !isPhiAtMerge(returnNode.result()) ? null : (ValuePhiNode) returnNode.result();\r\n        List<EndNode> endNodes = forwardEnds().snapshot();\r\n        for (EndNode end : endNodes) {\r\n            try (DebugCloseable position = returnNode.withNodeSourcePosition()) {\r\n                ReturnNode newReturn = graph().add(new ReturnNode(returnValuePhi == null ? returnNode.result() : returnValuePhi.valueAt(end)));\r\n                if (tool != null) {\r\n                    tool.addToWorkList(end.predecessor());\r\n                }\r\n                end.replaceAtPredecessor(newReturn);\r\n            }\r\n        }\r\n        GraphUtil.killCFG(this);\r\n        for (EndNode end : endNodes) {\r\n            end.safeDelete();\r\n        }\r\n        for (PhiNode phi : phis) {\r\n            if (tool.allUsagesAvailable() && phi.isAlive() && phi.hasNoUsages()) {\r\n                GraphUtil.killWithUnusedFloatingInputs(phi);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.replacements.NewObjectSnippets.formatObject",
	"Comment": "formats some allocated memory with an object header and zeroes out the rest.",
	"Method": "Object formatObject(KlassPointer hub,int size,Word memory,Word compileTimePrototypeMarkWord,boolean fillContents,boolean constantSize,Counters counters){\r\n    Word prototypeMarkWord = useBiasedLocking(INJECTED_VMCONFIG) ? hub.readWord(prototypeMarkWordOffset(INJECTED_VMCONFIG), PROTOTYPE_MARK_WORD_LOCATION) : compileTimePrototypeMarkWord;\r\n    initializeObjectHeader(memory, prototypeMarkWord, hub);\r\n    if (fillContents) {\r\n        zeroMemory(size, memory, constantSize, instanceHeaderSize(INJECTED_VMCONFIG), false, counters);\r\n    } else if (REPLACEMENTS_ASSERTIONS_ENABLED) {\r\n        fillWithGarbage(size, memory, constantSize, instanceHeaderSize(INJECTED_VMCONFIG), false, counters);\r\n    }\r\n    MembarNode.memoryBarrier(MemoryBarriers.STORE_STORE, LocationIdentity.init());\r\n    return memory.toObjectNonNull();\r\n}"
}, {
	"Path": "org.graalvm.compiler.bytecode.Bytecodes.canTrap",
	"Comment": "determines if a given opcode denotes an instruction that can cause an implicit exception.",
	"Method": "boolean canTrap(int opcode){\r\n    return (flagsArray[opcode & 0xff] & TRAP) != 0;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.AbstractBeginNode.setWithSpeculationFence",
	"Comment": "set this begin node to be a speculation fence. this will prevent speculative execution ofthis block.",
	"Method": "void setWithSpeculationFence(){\r\n    this.withSpeculationFence = true;\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.tregex.parser.ast.Group.insertFirst",
	"Comment": "inserts a new alternative to this group. the new alternative will be inserted at thebeginning, meaning it will have the highest priority among all thealternatives.",
	"Method": "void insertFirst(Sequence sequence){\r\n    sequence.setParent(this);\r\n    alternatives.add(0, sequence);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.InliningLog.addLog",
	"Comment": "append the inlining decision tree from the specified log.the subtrees of the specified log are appended below the root of this log. this is usuallycalled when a node in the graph is replaced with its snippet.",
	"Method": "void addLog(UnmodifiableEconomicMap<Node, Node> replacements,InliningLog replacementLog){\r\n    EconomicMap<Callsite, Callsite> mapping = EconomicMap.create(Equivalence.IDENTITY_WITH_SYSTEM_HASHCODE);\r\n    for (Callsite calleeChild : replacementLog.root.children) {\r\n        Callsite child = root.addChild(calleeChild.invoke);\r\n        copyTree(child, calleeChild, replacements, mapping);\r\n    }\r\n    MapCursor<Invokable, Callsite> entries = replacementLog.leaves.getEntries();\r\n    while (entries.advance()) {\r\n        Invokable replacementInvoke = entries.getKey();\r\n        Callsite replacementCallsite = entries.getValue();\r\n        if (replacementInvoke.asFixedNode().isDeleted()) {\r\n            continue;\r\n        }\r\n        Invokable invoke = (Invokable) replacements.get(replacementInvoke.asFixedNode());\r\n        Callsite callsite = mapping.get(replacementCallsite);\r\n        leaves.put(invoke, callsite);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.serviceprovider.GraalServices.loadSingle",
	"Comment": "gets the provider for a given service for which at most one provider must be available.",
	"Method": "S loadSingle(Class<S> service,boolean required){\r\n    assert !service.getName().startsWith(\"jdk.vm.ci\") : \"JVMCI services must be loaded via \" + Services.class.getName();\r\n    Iterable<S> providers = load(service);\r\n    S singleProvider = null;\r\n    try {\r\n        for (Iterator<S> it = providers.iterator(); it.hasNext(); ) {\r\n            singleProvider = it.next();\r\n            if (it.hasNext()) {\r\n                S other = it.next();\r\n                throw new InternalError(String.format(\"Multiple %s providers found: %s, %s\", service.getName(), singleProvider.getClass().getName(), other.getClass().getName()));\r\n            }\r\n        }\r\n    } catch (ServiceConfigurationError e) {\r\n    }\r\n    if (singleProvider == null) {\r\n        if (required) {\r\n            throw new InternalError(String.format(\"No provider for %s found\", service.getName()));\r\n        }\r\n    }\r\n    return singleProvider;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.util.GraphUtil.createBailoutException",
	"Comment": "creates a bailout exception with the given stack trace elements and message.",
	"Method": "BailoutException createBailoutException(String message,Throwable cause,StackTraceElement[] elements){\r\n    return SourceStackTraceBailoutException.create(cause, message, elements);\r\n}"
}, {
	"Path": "org.graalvm.compiler.serviceprovider.GraalServices.getCurrentThreadCpuTime",
	"Comment": "returns the total cpu time for the current thread in nanoseconds. the returned value is ofnanoseconds precision but not necessarily nanoseconds accuracy. if the implementationdistinguishes between user mode time and system mode time, the returned cpu time is theamount of time that the current thread has executed in user mode or system mode.",
	"Method": "long getCurrentThreadCpuTime(){\r\n    JMXService jmx = JMXService.instance;\r\n    if (jmx == null) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n    return jmx.getCurrentThreadCpuTime();\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.alloc.ComputeBlockOrder.addPathToCodeEmittingOrder",
	"Comment": "add a linear path to the code emission order greedily following the most likely successor.",
	"Method": "void addPathToCodeEmittingOrder(T initialBlock,List<T> order,PriorityQueue<T> worklist,BitSet visitedBlocks){\r\n    T block = initialBlock;\r\n    while (block != null) {\r\n        if (!skipLoopHeader(block)) {\r\n            if (block.isLoopHeader()) {\r\n                block.setAlign(true);\r\n            }\r\n            addBlock(block, order);\r\n        }\r\n        Loop<T> loop = block.getLoop();\r\n        if (block.isLoopEnd() && skipLoopHeader(loop.getHeader())) {\r\n            addBlock(loop.getHeader(), order);\r\n            for (T successor : loop.getHeader().getSuccessors()) {\r\n                if (successor.getLoopDepth() == block.getLoopDepth()) {\r\n                    successor.setAlign(true);\r\n                }\r\n            }\r\n        }\r\n        T mostLikelySuccessor = findAndMarkMostLikelySuccessor(block, visitedBlocks);\r\n        enqueueSuccessors(block, worklist, visitedBlocks);\r\n        block = mostLikelySuccessor;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.spi.LoweringProvider.smallestCompareWidth",
	"Comment": "indicates the smallest width for comparing an integer value on the target platform.",
	"Method": "Integer smallestCompareWidth(){\r\n    return 32;\r\n}"
}, {
	"Path": "org.graalvm.compiler.code.CompilationResult.getMethods",
	"Comment": "gets the methods whose bytecodes were used as input to the compilation.the caller must not modify the contents of the returned array.",
	"Method": "ResolvedJavaMethod[] getMethods(){\r\n    return methods;\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.GraphKit.inline",
	"Comment": "inlines a given invocation to a method. the graph of the inlined method is processed in thesame manner as for snippets and method substitutions.",
	"Method": "void inline(InvokeNode invoke,String reason,String phase){\r\n    ResolvedJavaMethod method = ((MethodCallTargetNode) invoke.callTarget()).targetMethod();\r\n    MetaAccessProvider metaAccess = providers.getMetaAccess();\r\n    Plugins plugins = new Plugins(graphBuilderPlugins);\r\n    GraphBuilderConfiguration config = GraphBuilderConfiguration.getSnippetDefault(plugins);\r\n    StructuredGraph calleeGraph = new StructuredGraph.Builder(invoke.getOptions(), invoke.getDebug()).method(method).trackNodeSourcePosition(invoke.graph().trackNodeSourcePosition()).build();\r\n    IntrinsicContext initialReplacementContext = new IntrinsicContext(method, method, providers.getReplacements().getDefaultReplacementBytecodeProvider(), INLINE_AFTER_PARSING);\r\n    GraphBuilderPhase.Instance instance = createGraphBuilderInstance(metaAccess, providers.getStampProvider(), providers.getConstantReflection(), providers.getConstantFieldProvider(), config, OptimisticOptimizations.NONE, initialReplacementContext);\r\n    instance.apply(calleeGraph);\r\n    calleeGraph.clearAllStateAfter();\r\n    new DeadCodeEliminationPhase(Optionality.Required).apply(calleeGraph);\r\n    InliningUtil.inline(invoke, calleeGraph, false, method, reason, phase);\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.PhaseSuite.replacePhase",
	"Comment": "removes the first instance of the given phase class, looking recursively into inner phasesuites.",
	"Method": "boolean replacePhase(Class<? extends BasePhase<? super C>> phaseClass,BasePhase<? super C> newPhase){\r\n    ListIterator<BasePhase<? super C>> it = phases.listIterator();\r\n    while (it.hasNext()) {\r\n        BasePhase<? super C> phase = it.next();\r\n        if (phaseClass.isInstance(phase)) {\r\n            it.set(newPhase);\r\n            return true;\r\n        } else if (phase instanceof PhaseSuite) {\r\n            PhaseSuite<C> innerSuite = (PhaseSuite<C>) phase;\r\n            if (innerSuite.removePhase(phaseClass)) {\r\n                if (innerSuite.phases.isEmpty()) {\r\n                    it.set(newPhase);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.aarch64.AArch64Assembler.scvtf",
	"Comment": "converts integer to floating point. uses rounding mode defined by fcpr.",
	"Method": "void scvtf(int targetSize,int srcSize,Register dst,Register src){\r\n    assert dst.getRegisterCategory().equals(SIMD);\r\n    assert !src.equals(sp);\r\n    fcvtCpuFpuInstruction(SCVTF, dst, src, floatFromSize(targetSize), generalFromSize(srcSize));\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.OptimizedOSRLoopNodeTest.testOSRFrameSlotChangeDuringOSR",
	"Comment": "test frame slot changes in the loop cause deoptimization and reoptimization.",
	"Method": "void testOSRFrameSlotChangeDuringOSR(){\r\n    OSRLoopFactory factory = CONFIGURED;\r\n    TestRootNode rootNode = new TestRootNode(factory, new TestRepeatingNode() {\r\n        @Override\r\n        public boolean executeRepeating(VirtualFrame frame) {\r\n            boolean next = super.executeRepeating(frame);\r\n            if (!next) {\r\n                frame.setDouble(param2, 42.0);\r\n            }\r\n            return next;\r\n        }\r\n    }) {\r\n        @Override\r\n        public Object execute(VirtualFrame frame) {\r\n            Object result = super.execute(frame);\r\n            try {\r\n                Assert.assertEquals(42.0d, frame.getDouble(param2), 0.01);\r\n            } catch (FrameSlotTypeException e) {\r\n                Assert.fail();\r\n            }\r\n            return result;\r\n        }\r\n    };\r\n    executeNoCallTarget(rootNode, OSR_THRESHOLD + 1);\r\n    assertCompiled(rootNode.getOSRTarget());\r\n    executeNoCallTarget(rootNode, 1);\r\n    assertNotCompiled(rootNode.getOSRTarget());\r\n    executeNoCallTarget(rootNode, OSR_THRESHOLD + 1);\r\n    assertCompiled(rootNode.getOSRTarget());\r\n    executeNoCallTarget(rootNode, 1);\r\n    executeNoCallTarget(rootNode, OSR_THRESHOLD + 1);\r\n    assertCompiled(rootNode.getOSRTarget());\r\n    executeNoCallTarget(rootNode, 1);\r\n    assertCompiled(rootNode.getOSRTarget());\r\n    Assert.assertTrue(rootNode.wasRepeatingCalledCompiled());\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.OptimizedOSRLoopNodeTest.testOSRFrameSlotChangeDuringOSR",
	"Comment": "test frame slot changes in the loop cause deoptimization and reoptimization.",
	"Method": "void testOSRFrameSlotChangeDuringOSR(){\r\n    boolean next = super.executeRepeating(frame);\r\n    if (!next) {\r\n        frame.setDouble(param2, 42.0);\r\n    }\r\n    return next;\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.OptimizedOSRLoopNodeTest.testOSRFrameSlotChangeDuringOSR",
	"Comment": "test frame slot changes in the loop cause deoptimization and reoptimization.",
	"Method": "void testOSRFrameSlotChangeDuringOSR(){\r\n    Object result = super.execute(frame);\r\n    try {\r\n        Assert.assertEquals(42.0d, frame.getDouble(param2), 0.01);\r\n    } catch (FrameSlotTypeException e) {\r\n        Assert.fail();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.AbstractLocalNode.index",
	"Comment": "gets the index of this local in the array of parameters. this is not the jvm local index.",
	"Method": "int index(){\r\n    return index;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.calc.ConvertNode.preservesOrder",
	"Comment": "check whether a conversion preserves comparison order against a particular constant value.",
	"Method": "boolean preservesOrder(CanonicalCondition op,boolean preservesOrder,CanonicalCondition op,Constant value,ConstantReflectionProvider constantReflection){\r\n    return preservesOrder(op);\r\n}"
}, {
	"Path": "org.graalvm.util.ObjectSizeEstimate.forObject",
	"Comment": "collect the size occupied by the object graph reachable from the given root object.",
	"Method": "ObjectSizeEstimate forObject(Object root,ObjectSizeEstimate forObject,Object root,int maxDepth){\r\n    return forObjectHelper(root, maxDepth);\r\n}"
}, {
	"Path": "org.graalvm.compiler.jtt.optimize.Fold_Double04.test",
	"Comment": "contrived check whether both arguments are the same kind of zero",
	"Method": "boolean test(double x,double y){\r\n    if (x == 0) {\r\n        if (1 / x == Double.NEGATIVE_INFINITY) {\r\n            return 1 / y == Double.NEGATIVE_INFINITY;\r\n        } else {\r\n            return 1 / y == Double.POSITIVE_INFINITY;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.ReplacementsImpl.shouldInlineInvoke",
	"Comment": "determines whether a given method should be inlined based on whether it has a substitution orwhether the inlining context is already within a substitution.",
	"Method": "InlineInfo shouldInlineInvoke(GraphBuilderContext b,ResolvedJavaMethod method,ValueNode[] args){\r\n    Bytecode subst = getSubstitutionBytecode(method);\r\n    if (subst != null) {\r\n        if (b.parsingIntrinsic() || InlineDuringParsing.getValue(b.getOptions()) || InlineIntrinsicsDuringParsing.getValue(b.getOptions())) {\r\n            return createIntrinsicInlineInfo(subst.getMethod(), method, subst.getOrigin());\r\n        }\r\n        return null;\r\n    }\r\n    if (b.parsingIntrinsic()) {\r\n        assert b.getDepth() < MAX_GRAPH_INLINING_DEPTH : \"inlining limit exceeded\";\r\n        return createIntrinsicInlineInfo(method, null, defaultBytecodeProvider);\r\n    } else {\r\n        assert method.getAnnotation(NodeIntrinsic.class) == null : String.format(\"@%s method %s must only be called from within a replacement%n%s\", NodeIntrinsic.class.getSimpleName(), method.format(\"%h.%n\"), b);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.tregex.parser.ast.visitors.NFATraversalRegexASTVisitor.passingThrough",
	"Comment": "checks whether we have already entered this node before and would therefore be passingthrough its contents without matching any input characters.",
	"Method": "boolean passingThrough(RegexASTNode node){\r\n    for (PathElement elem : curPath) {\r\n        if (!elem.isGroupExit() && elem.getNode() == node) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.trace.lsra.TraceLocalMoveResolver.blockRegisters",
	"Comment": "mark assignedreg and assignedreghi of the interval as blocked",
	"Method": "void blockRegisters(TraceInterval interval){\r\n    Value location = interval.location();\r\n    if (mightBeBlocked(location)) {\r\n        assert areMultipleReadsAllowed() || valueBlocked(location) == 0 : \"location already marked as used: \" + location;\r\n        int direction = 1;\r\n        setValueBlocked(location, direction);\r\n        debug.log(\"block %s\", location);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.inlineOnly",
	"Comment": "determines if this plugin can only be used when inlining the method is it associated with.that is, this plugin cannot be used when the associated method is the compilation root.",
	"Method": "boolean inlineOnly(){\r\n    return isSignaturePolymorphic();\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.common.TruffleCompilerRuntime.getOptions",
	"Comment": "gets the option values for this runtime as a map from option name to option value.",
	"Method": "Map<String, Object> getOptions(T getOptions,Class<T> type){\r\n    throw new IllegalArgumentException(getClass().getName() + \" can not return option values of type \" + type.getName());\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext.getDepth",
	"Comment": "gets the inline depth of this context. a return value of 0 implies that this is the contextfor the parse root.",
	"Method": "int getDepth(){\r\n    GraphBuilderContext parent = getParent();\r\n    int result = 0;\r\n    while (parent != null) {\r\n        result++;\r\n        parent = parent.getParent();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.ReplacementsImpl.createGraphMaker",
	"Comment": "can be overridden to return an object that specializes various parts of graph preprocessing.",
	"Method": "GraphMaker createGraphMaker(ResolvedJavaMethod substitute,ResolvedJavaMethod original){\r\n    return new GraphMaker(this, substitute, original);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.amd64.AMD64LIRGenerator.canStoreConstant",
	"Comment": "checks whether the supplied constant can be used without loading it into a register for storeoperations, i.e., on the right hand side of a memory access.",
	"Method": "boolean canStoreConstant(JavaConstant c){\r\n    switch(c.getJavaKind()) {\r\n        case Long:\r\n            return NumUtil.isInt(c.asLong());\r\n        case Double:\r\n            return false;\r\n        case Object:\r\n            return c.isNull();\r\n        default:\r\n            return true;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker.handleSpillSlot",
	"Comment": "this is called for every interval that is assigned to a stack slot.",
	"Method": "void handleSpillSlot(Interval interval){\r\n    assert interval.location() != null && (interval.canMaterialize() || isStackSlotValue(interval.location())) : \"interval not assigned to a stack slot \" + interval;\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.UnsupportedRegexException.fillInStackTrace",
	"Comment": "for performance reasons, this exception does not record any stack trace information.",
	"Method": "Throwable fillInStackTrace(){\r\n    return null;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.java.NewInstanceNode.defaultFieldValue",
	"Comment": "factored out in a separate method so that subclasses can override it.",
	"Method": "ConstantNode defaultFieldValue(ResolvedJavaField field){\r\n    return ConstantNode.defaultForKind(field.getType().getJavaKind(), graph());\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.GraphKit.checkArgs",
	"Comment": "determines if a given set of arguments is compatible with the signature of a given method.",
	"Method": "boolean checkArgs(ResolvedJavaMethod method,ValueNode args){\r\n    Signature signature = method.getSignature();\r\n    boolean isStatic = method.isStatic();\r\n    if (signature.getParameterCount(!isStatic) != args.length) {\r\n        throw new AssertionError(graph + \": wrong number of arguments to \" + method);\r\n    }\r\n    int argIndex = 0;\r\n    if (!isStatic) {\r\n        JavaKind expected = asKind(method.getDeclaringClass());\r\n        JavaKind actual = args[argIndex++].stamp(NodeView.DEFAULT).getStackKind();\r\n        assert expected == actual : graph + \": wrong kind of value for receiver argument of call to \" + method + \" [\" + actual + \" != \" + expected + \"]\";\r\n    }\r\n    for (int i = 0; i != signature.getParameterCount(false); i++) {\r\n        JavaKind expected = asKind(signature.getParameterType(i, method.getDeclaringClass())).getStackKind();\r\n        JavaKind actual = args[argIndex++].stamp(NodeView.DEFAULT).getStackKind();\r\n        if (expected != actual) {\r\n            throw new AssertionError(graph + \": wrong kind of value for argument \" + i + \" of call to \" + method + \" [\" + actual + \" != \" + expected + \"]\");\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.polyglot.PolyglotException.getSourceLocation",
	"Comment": "gets a guest language source location of this error or null if no sourcelocation is available for this exception.",
	"Method": "SourceSection getSourceLocation(SourceSection getSourceLocation){\r\n    return impl.getSourceLocation();\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.alloc.ComputeBlockOrder.initializeWorklist",
	"Comment": "initializes the priority queue used for the work list of blocks and adds the start block.",
	"Method": "PriorityQueue<T> initializeWorklist(T startBlock,BitSet visitedBlocks){\r\n    PriorityQueue<T> result = new PriorityQueue(INITIAL_WORKLIST_CAPACITY, new BlockOrderComparator());\r\n    result.add(startBlock);\r\n    visitedBlocks.set(startBlock.getId());\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.sparc.SPARCLIRGenerator.emitCompare",
	"Comment": "this method emits the compare instruction, and may reorder the operands. it returns true ifit did so.",
	"Method": "boolean emitCompare(SPARCKind cmpKind,Value a,Value b){\r\n    boolean mirrored;\r\n    if (cmpKind.isInteger()) {\r\n        mirrored = emitIntegerCompare(cmpKind, a, b);\r\n    } else if (cmpKind.isFloat()) {\r\n        mirrored = false;\r\n        emitFloatCompare(cmpKind, a, b, Fcc0);\r\n    } else {\r\n        throw GraalError.shouldNotReachHere();\r\n    }\r\n    return mirrored;\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.DebugFilter.matchLevel",
	"Comment": "check whether a given input is matched by this filter, and determine the log level.",
	"Method": "int matchLevel(String input){\r\n    if (terms == null) {\r\n        return DebugContext.BASIC_LEVEL;\r\n    } else {\r\n        int defaultLevel = 0;\r\n        int level = -1;\r\n        for (Term t : terms) {\r\n            if (t.isMatchAny()) {\r\n                defaultLevel = t.level;\r\n            } else if (t.matches(input)) {\r\n                level = t.level;\r\n            }\r\n        }\r\n        return level == -1 ? defaultLevel : level;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.util.GraphUtil.approxSourceLocation",
	"Comment": "gets an approximate source code location for a node if possible.",
	"Method": "String approxSourceLocation(Node node){\r\n    StackTraceElement[] stackTraceElements = approxSourceStackTraceElement(node);\r\n    if (stackTraceElements != null && stackTraceElements.length > 0) {\r\n        StackTraceElement top = stackTraceElements[0];\r\n        if (top.getFileName() != null && top.getLineNumber() >= 0) {\r\n            return top.getFileName() + \":\" + top.getLineNumber();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.gen.LIRGenerationResult.hasForeignCall",
	"Comment": "determines whether the code being generated makes at least one foreign call.",
	"Method": "boolean hasForeignCall(){\r\n    return hasForeignCall;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.asm.CompilationResultBuilder.asDoubleConstRef",
	"Comment": "returns the address of a double constant that is embedded as a data reference into the code.",
	"Method": "AbstractAddress asDoubleConstRef(JavaConstant value,AbstractAddress asDoubleConstRef,JavaConstant value,int alignment){\r\n    assert value.getJavaKind() == JavaKind.Double;\r\n    return recordDataReferenceInCode(value, alignment);\r\n}"
}, {
	"Path": "org.graalvm.compiler.virtual.phases.ea.ObjectState.getEntries",
	"Comment": "users of this method are not allowed to change the entries of the returned array.",
	"Method": "ValueNode[] getEntries(){\r\n    assert isVirtual();\r\n    return entries;\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.test.AssemblerTest.getInitialOptions",
	"Comment": "gets the initial option values provided by the graal runtime. these are option valuestypically parsed from the command line.",
	"Method": "OptionValues getInitialOptions(){\r\n    return Graal.getRequiredCapability(OptionValues.class);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.ea.EscapeAnalysisTest.testChangeHandling",
	"Comment": "tests that a graph with allocations that does not make progress during pea will not bechanged.",
	"Method": "void testChangeHandling(){\r\n    prepareGraph(\"testChangeHandlingSnippet\", false);\r\n    Assert.assertEquals(2, graph.getNodes().filter(CommitAllocationNode.class).count());\r\n    Assert.assertEquals(1, graph.getNodes().filter(BoxNode.class).count());\r\n    List<Node> nodes = graph.getNodes().snapshot();\r\n    new PartialEscapePhase(false, false, new CanonicalizerPhase(), null, graph.getOptions()).apply(graph, context);\r\n    Assert.assertEquals(nodes.size(), graph.getNodeCount());\r\n    for (Node node : nodes) {\r\n        Assert.assertTrue(node.isAlive());\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.CompilationFinalWeakReferencePartialEvaluationTest.clearDebugScopeTL",
	"Comment": "perform a dummy compilation to ensure compilation result data of the last compilation keptalive through debugscope thread locals are freed.",
	"Method": "void clearDebugScopeTL(){\r\n    compileHelper(\"dummy\", RootNode.createConstantNode(null), new Object[] {});\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.ea.PartialEscapeAnalysisTreesTest.testGraph",
	"Comment": "prepare a graph that includes some blackholes and then remove the blackholes and compilenormally to create an unusual situation for pea.",
	"Method": "void testGraph(String name){\r\n    ResolvedJavaMethod method = getResolvedJavaMethod(name);\r\n    prepareGraph(name, true);\r\n    try (DebugContext.Scope s = graph.getDebug().scope(getClass(), method, getCodeCache(), graph)) {\r\n        for (BlackholeNode node : graph.getNodes().filter(BlackholeNode.class)) {\r\n            graph.removeFixed(node);\r\n        }\r\n        new DeadCodeEliminationPhase().apply(graph);\r\n        new CanonicalizerPhase().apply(graph, context);\r\n        InstalledCode code = getCode(method, graph, true);\r\n        GraalCompilerTest.Result r = executeExpected(method, null, true);\r\n        int expectedInstances = ((TreeNode) r.returnValue).countInstances();\r\n        TreeNode r2 = (TreeNode) code.executeVarargs(true);\r\n        Assert.assertEquals(\"Wrong number of nodes in tree\", expectedInstances, r2.countInstances());\r\n        r = executeExpected(method, null, false);\r\n        expectedInstances = ((TreeNode) r.returnValue).countInstances();\r\n        r2 = (TreeNode) code.executeVarargs(false);\r\n        Assert.assertEquals(\"Wrong number of nodes in tree\", expectedInstances, r2.countInstances());\r\n    } catch (Throwable e) {\r\n        throw graph.getDebug().handle(e);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.amd64.AMD64ArrayEqualsOp.supportsAVX2",
	"Comment": "returns if the underlying amd64 architecture supports avx instructions.",
	"Method": "boolean supportsAVX2(TargetDescription target){\r\n    AMD64 arch = (AMD64) target.arch;\r\n    return arch.getFeatures().contains(CPUFeature.AVX2);\r\n}"
}, {
	"Path": "org.graalvm.compiler.graph.Edges.initializeLists",
	"Comment": "initializes the list edges in a given node based on the size of the list edges in a prototypenode.",
	"Method": "void initializeLists(Node node,Node prototype){\r\n    int index = getDirectCount();\r\n    final long[] curOffsets = this.offsets;\r\n    final Edges.Type curType = this.type;\r\n    while (index < getCount()) {\r\n        NodeList<Node> list = getNodeList(prototype, curOffsets, index);\r\n        if (list != null) {\r\n            int size = list.initialSize;\r\n            NodeList<Node> newList = curType == Edges.Type.Inputs ? new NodeInputList(node, size) : new NodeSuccessorList(node, size);\r\n            initializeList(node, index, newList);\r\n        }\r\n        index++;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.trace.bu.BottomUpAllocator.attributes",
	"Comment": "gets an object describing the attributes of a given register according to this registerconfiguration.",
	"Method": "RegisterAttributes attributes(Register reg){\r\n    return registerAttributes[reg.number];\r\n}"
}, {
	"Path": "org.graalvm.compiler.code.HexCodeFile.addAnnotations",
	"Comment": "adds any jump tables, lookup tables or code comments from a list of code annotations.",
	"Method": "void addAnnotations(HexCodeFile hcf,List<CodeAnnotation> annotations){\r\n    if (annotations == null || annotations.isEmpty()) {\r\n        return;\r\n    }\r\n    for (CodeAnnotation a : annotations) {\r\n        if (a instanceof JumpTable) {\r\n            JumpTable table = (JumpTable) a;\r\n            hcf.jumpTables.add(table);\r\n        } else if (a instanceof CodeComment) {\r\n            CodeComment comment = (CodeComment) a;\r\n            hcf.addComment(comment.position, comment.value);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.launcher.Launcher.fuzzyMatch",
	"Comment": "returns the set of options that fuzzy match a given option name.",
	"Method": "List<String> fuzzyMatch(Set<String> arguments,String argument,float threshold){\r\n    List<String> matches = new ArrayList();\r\n    for (String arg : arguments) {\r\n        float score = stringSimilarity(arg, argument);\r\n        if (score >= threshold) {\r\n            matches.add(arg);\r\n        }\r\n    }\r\n    return matches;\r\n}"
}, {
	"Path": "org.graalvm.compiler.graph.NodeIdAccessor.verifyIdsAreStable",
	"Comment": "verifies that node identifiers have not changed since this object was created.",
	"Method": "boolean verifyIdsAreStable(){\r\n    int compressions = graph.compressions - epoch;\r\n    if (compressions != 0) {\r\n        throw new VerificationError(\"accessing node id in %s across %d graph compression%s\", graph, compressions, compressions == 1 ? \"\" : \"s\");\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.lsra.Interval.logString",
	"Comment": "gets a single line string for logging the details of this interval to a log stream.",
	"Method": "String logString(LinearScan allocator){\r\n    StringBuilder buf = new StringBuilder(100);\r\n    buf.append(operandNumber).append(':').append(operand).append(' ');\r\n    if (!isRegister(operand)) {\r\n        if (location != null) {\r\n            buf.append(\"location{\").append(location).append(\"} \");\r\n        }\r\n    }\r\n    buf.append(\"hints{\").append(splitParent.operandNumber);\r\n    Interval hint = locationHint(false);\r\n    if (hint != null && hint.operandNumber != splitParent.operandNumber) {\r\n        buf.append(\", \").append(hint.operandNumber);\r\n    }\r\n    buf.append(\"} ranges{\");\r\n    Range cur = first;\r\n    while (!cur.isEndMarker()) {\r\n        if (cur != first) {\r\n            buf.append(\", \");\r\n        }\r\n        buf.append(cur);\r\n        cur = cur.next;\r\n        assert cur != null : \"range list not closed with range sentinel\";\r\n    }\r\n    buf.append(\"} uses{\");\r\n    int prev = -1;\r\n    for (int i = usePosList.size() - 1; i >= 0; --i) {\r\n        assert prev < usePosList.usePos(i) : \"use positions not sorted\";\r\n        if (i != usePosList.size() - 1) {\r\n            buf.append(\", \");\r\n        }\r\n        buf.append(usePosList.usePos(i)).append(':').append(usePosList.registerPriority(i));\r\n        prev = usePosList.usePos(i);\r\n    }\r\n    buf.append(\"} spill-state{\").append(spillState()).append(\"}\");\r\n    if (canMaterialize()) {\r\n        buf.append(\" (remat:\").append(getMaterializedValue().toString()).append(\")\");\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.asm.CompilationResultBuilder.asFloatConstRef",
	"Comment": "returns the address of a float constant that is embedded as a data reference into the code.",
	"Method": "AbstractAddress asFloatConstRef(JavaConstant value,AbstractAddress asFloatConstRef,JavaConstant value,int alignment){\r\n    assert value.getJavaKind() == JavaKind.Float;\r\n    return recordDataReferenceInCode(value, alignment);\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.AbstractKey.getName",
	"Comment": "gets the globally unique name for the value represented by this object.",
	"Method": "String getName(){\r\n    if (name == null) {\r\n        name = createName(nameFormat, nameArg1, nameArg2);\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.ValueNode.asConstant",
	"Comment": "convert this value to a constant if it is a constant, otherwise return null.",
	"Method": "Constant asConstant(){\r\n    if (this instanceof ConstantNode) {\r\n        return ((ConstantNode) this).getValue();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.polyglot.Value.getMember",
	"Comment": "returns the member with a given identifier or null if the memberdoes not exist.",
	"Method": "Value getMember(String identifier){\r\n    Objects.requireNonNull(identifier, \"identifier\");\r\n    return impl.getMember(receiver, identifier);\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.stubs.Stub.getCode",
	"Comment": "gets the code for this stub, compiling it first if necessary.",
	"Method": "InstalledCode getCode(Backend backend){\r\n    if (code == null) {\r\n        try (DebugContext debug = openDebugContext(DebugContext.forCurrentThread())) {\r\n            try (DebugContext.Scope d = debug.scope(\"CompilingStub\", providers.getCodeCache(), debugScopeContext())) {\r\n                CodeCacheProvider codeCache = providers.getCodeCache();\r\n                CompilationResult compResult = buildCompilationResult(debug, backend);\r\n                try (DebugContext.Scope s = debug.scope(\"CodeInstall\", compResult);\r\n                    DebugContext.Activation a = debug.activate()) {\r\n                    assert destroyedCallerRegisters != null;\r\n                    HotSpotCompiledCode compiledCode = HotSpotCompiledCodeBuilder.createCompiledCode(codeCache, null, null, compResult, options);\r\n                    code = codeCache.installCode(null, compiledCode, null, null, false);\r\n                } catch (Throwable e) {\r\n                    throw debug.handle(e);\r\n                }\r\n            } catch (Throwable e) {\r\n                throw debug.handle(e);\r\n            }\r\n            assert code != null : \"error installing stub \" + this;\r\n        }\r\n    }\r\n    return code;\r\n}"
}, {
	"Path": "org.graalvm.compiler.options.OptionsParser.parseOptions",
	"Comment": "parses a map representing assignments of values to options.",
	"Method": "void parseOptions(EconomicMap<String, String> optionSettings,EconomicMap<OptionKey<?>, Object> values,Iterable<OptionDescriptors> loader){\r\n    if (optionSettings != null && !optionSettings.isEmpty()) {\r\n        MapCursor<String, String> cursor = optionSettings.getEntries();\r\n        while (cursor.advance()) {\r\n            parseOption(cursor.getKey(), cursor.getValue(), values, loader);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.code.DataSection.close",
	"Comment": "computes the layout of the data section and closes this object to further updates.this must be called exactly once.",
	"Method": "void close(){\r\n    checkOpen();\r\n    closed = true;\r\n    dataItems.sort((a, b) -> a.alignment - b.alignment);\r\n    int position = 0;\r\n    int alignment = 1;\r\n    for (Data d : dataItems) {\r\n        alignment = lcm(alignment, d.alignment);\r\n        position = align(position, d.alignment);\r\n        d.ref.setOffset(position);\r\n        position += d.size;\r\n    }\r\n    sectionAlignment = alignment;\r\n    sectionSize = position;\r\n}"
}, {
	"Path": "org.graalvm.compiler.api.directives.test.ControlFlowAnchorDirectiveTest.testClone",
	"Comment": "cloning a controlflowanchornode is not allowed but cloning a whole graph containing one isok.",
	"Method": "void testClone(){\r\n    StructuredGraph g = parseEager(\"preventPeelSnippet\", AllowAssumptions.NO);\r\n    g.copy(g.getDebug());\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.nodes.MethodHandleNode.maybeCastArgument",
	"Comment": "inserts a node to cast the argument at index to the given type if the given type is moreconcrete than the argument type.",
	"Method": "void maybeCastArgument(GraphAdder adder,ValueNode[] arguments,int index,JavaType type){\r\n    ValueNode argument = arguments[index];\r\n    if (type instanceof ResolvedJavaType && !((ResolvedJavaType) type).isJavaLangObject()) {\r\n        Assumptions assumptions = adder.getAssumptions();\r\n        TypeReference targetType = TypeReference.create(assumptions, (ResolvedJavaType) type);\r\n        if (targetType != null && !targetType.getType().isPrimitive() && !argument.getStackKind().isPrimitive()) {\r\n            ResolvedJavaType argumentType = StampTool.typeOrNull(argument.stamp(NodeView.DEFAULT));\r\n            if (argumentType == null || (argumentType.isAssignableFrom(targetType.getType()) && !argumentType.equals(targetType.getType()))) {\r\n                LogicNode inst = InstanceOfNode.createAllowNull(targetType, argument, null, null);\r\n                assert !inst.isAlive();\r\n                if (!inst.isTautology()) {\r\n                    inst = adder.add(inst);\r\n                    AnchoringNode guardAnchor = adder.getGuardAnchor();\r\n                    DeoptimizationReason reason = DeoptimizationReason.ClassCastException;\r\n                    DeoptimizationAction action = DeoptimizationAction.InvalidateRecompile;\r\n                    Speculation speculation = SpeculationLog.NO_SPECULATION;\r\n                    GuardingNode guard;\r\n                    if (guardAnchor == null) {\r\n                        FixedGuardNode fixedGuard = adder.add(new FixedGuardNode(inst, reason, action, speculation, false));\r\n                        guard = fixedGuard;\r\n                    } else {\r\n                        GuardNode newGuard = adder.add(new GuardNode(inst, guardAnchor, reason, action, false, speculation, null));\r\n                        adder.add(new ValueAnchorNode(newGuard));\r\n                        guard = newGuard;\r\n                    }\r\n                    ValueNode valueNode = adder.add(PiNode.create(argument, StampFactory.object(targetType), guard.asNode()));\r\n                    arguments[index] = valueNode;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.AArch64LIRGenerator.emitCompare",
	"Comment": "this method emits the compare instruction, and may reorder the operands. it returns true ifit did so.",
	"Method": "boolean emitCompare(PlatformKind cmpKind,Value a,Value b,Condition condition,boolean unorderedIsTrue){\r\n    Value left;\r\n    Value right;\r\n    boolean mirrored;\r\n    AArch64Kind kind = (AArch64Kind) cmpKind;\r\n    if (kind.isInteger()) {\r\n        Value aExt = a;\r\n        Value bExt = b;\r\n        int compareBytes = cmpKind.getSizeInBytes();\r\n        if (compareBytes < a.getPlatformKind().getSizeInBytes()) {\r\n            aExt = arithmeticLIRGen.emitSignExtend(a, compareBytes * 8, 64);\r\n        }\r\n        if (compareBytes < b.getPlatformKind().getSizeInBytes()) {\r\n            bExt = arithmeticLIRGen.emitSignExtend(b, compareBytes * 8, 64);\r\n        }\r\n        if (LIRValueUtil.isVariable(bExt)) {\r\n            left = load(bExt);\r\n            right = loadNonConst(aExt);\r\n            mirrored = true;\r\n        } else {\r\n            left = load(aExt);\r\n            right = loadNonConst(bExt);\r\n            mirrored = false;\r\n        }\r\n        append(new AArch64Compare.CompareOp(left, loadNonCompareConst(right)));\r\n    } else if (kind.isSIMD()) {\r\n        if (AArch64Compare.FloatCompareOp.isFloatCmpConstant(a, condition, unorderedIsTrue)) {\r\n            left = load(b);\r\n            right = a;\r\n            mirrored = true;\r\n        } else if (AArch64Compare.FloatCompareOp.isFloatCmpConstant(b, condition, unorderedIsTrue)) {\r\n            left = load(a);\r\n            right = b;\r\n            mirrored = false;\r\n        } else {\r\n            left = load(a);\r\n            right = loadReg(b);\r\n            mirrored = false;\r\n        }\r\n        append(new AArch64Compare.FloatCompareOp(left, asAllocatable(right), condition, unorderedIsTrue));\r\n    } else {\r\n        throw GraalError.shouldNotReachHere();\r\n    }\r\n    return mirrored;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.match.processor.MatchProcessor.processMatchableNodes",
	"Comment": "build up the type table to be used during parsing of the matchrule.",
	"Method": "void processMatchableNodes(Element element){\r\n    if (!processedMatchableNodes.contains(element)) {\r\n        try {\r\n            processedMatchableNodes.add(element);\r\n            List<AnnotationMirror> matchableNodeAnnotations;\r\n            AnnotationMirror mirror = getAnnotation(element, getType(MATCHABLE_NODES_CLASS_NAME));\r\n            if (mirror != null) {\r\n                matchableNodeAnnotations = getAnnotationValueList(mirror, \"value\", AnnotationMirror.class);\r\n            } else {\r\n                mirror = getAnnotation(element, getType(MATCHABLE_NODES_CLASS_NAME));\r\n                if (mirror != null) {\r\n                    matchableNodeAnnotations = Collections.singletonList(mirror);\r\n                } else {\r\n                    return;\r\n                }\r\n            }\r\n            TypeElement topDeclaringType = topDeclaringType(element);\r\n            for (AnnotationMirror matchableNode : matchableNodeAnnotations) {\r\n                processMatchableNode(element, topDeclaringType, matchableNode);\r\n            }\r\n        } catch (Throwable t) {\r\n            reportExceptionThrow(element, t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jdk.tools.jaotc.binformat.elf.ElfSymtab.getSymtabArray",
	"Comment": "create a single byte array that contains the symbol table entries",
	"Method": "byte[] getSymtabArray(){\r\n    ByteBuffer symtabData = ElfByteBuffer.allocate(symbolCount * Elf64_Sym.totalsize);\r\n    byte[] retarray;\r\n    updateIndexes();\r\n    for (int i = 0; i < localSymbols.size(); i++) {\r\n        ElfSymbol sym = localSymbols.get(i);\r\n        byte[] arr = sym.getArray();\r\n        symtabData.put(arr);\r\n    }\r\n    for (int i = 0; i < globalSymbols.size(); i++) {\r\n        ElfSymbol sym = globalSymbols.get(i);\r\n        byte[] arr = sym.getArray();\r\n        symtabData.put(arr);\r\n    }\r\n    retarray = symtabData.array();\r\n    return (retarray);\r\n}"
}, {
	"Path": "org.graalvm.compiler.graph.Graph.withoutNodeSourcePosition",
	"Comment": "opens a scope in which newly created nodes do not get any source information added.",
	"Method": "DebugCloseable withoutNodeSourcePosition(){\r\n    return new NodeSourcePositionScope(null);\r\n}"
}, {
	"Path": "org.graalvm.nativeimage.UnmanagedMemory.free",
	"Comment": "frees unmanaged memory that was previously allocated using methods of this class.",
	"Method": "void free(PointerBase ptr){\r\n    ImageSingletons.lookup(UnmanagedMemorySupport.class).free(ptr);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.type.IntegerStamp.sameSign",
	"Comment": "checks if the 2 stamps represent values of the same sign. returns true if the two stamps areboth positive of null or if they are both strictly negative",
	"Method": "boolean sameSign(IntegerStamp s1,IntegerStamp s2){\r\n    return s1.isPositive() && s2.isPositive() || s1.isStrictlyNegative() && s2.isStrictlyNegative();\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.aarch64.AArch64Assembler.exclusiveStoreInstruction",
	"Comment": "stores data from rt into address and sets rs to the returned exclusive access status.",
	"Method": "void exclusiveStoreInstruction(Instruction instr,Register rs,Register rt,Register rn,int log2TransferSize){\r\n    assert log2TransferSize >= 0 && log2TransferSize < 4;\r\n    assert rt.getRegisterCategory().equals(CPU) && rs.getRegisterCategory().equals(CPU) && !rs.equals(rt);\r\n    int transferSizeEncoding = log2TransferSize << LoadStoreTransferSizeOffset;\r\n    emitInt(transferSizeEncoding | instr.encoding | rs2(rs) | rn(rn) | rt(rt));\r\n}"
}, {
	"Path": "org.graalvm.polyglot.management.ExecutionEvent.getRootName",
	"Comment": "returns the root name or null if no name is available. the root name may also beavailable for events caused by expressions and statements. in this case the name of thecontaining root will be returned.",
	"Method": "String getRootName(){\r\n    return IMPL.getRootName(impl);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.java.MonitorExitNode.clearEscapedReturnValue",
	"Comment": "return value is cleared when a synchronized method graph is inlined.",
	"Method": "void clearEscapedReturnValue(){\r\n    updateUsages(escapedReturnValue, null);\r\n    this.escapedReturnValue = null;\r\n}"
}, {
	"Path": "org.graalvm.options.OptionType.getDefaultValue",
	"Comment": "returns the default value of this type. used if no value is available.",
	"Method": "T getDefaultValue(){\r\n    return defaultValue;\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.csdb",
	"Comment": "consumption of speculative data barrier. this is a memory barrier that controls speculativeexecution and data value prediction.",
	"Method": "void csdb(){\r\n    super.hint(SystemHint.CSDB);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.util.FrequencyEncoder.getLength",
	"Comment": "returns the number of distinct objects that have been added, i.e., the length of the array.",
	"Method": "int getLength(){\r\n    return map.size() + (containsNull ? 1 : 0);\r\n}"
}, {
	"Path": "org.graalvm.compiler.graph.Edges.setNode",
	"Comment": "sets the value of a given edge and notifies the new and old nodes on the other end of theedge of the change.",
	"Method": "void setNode(Node node,int index,Node value){\r\n    assert index < directCount;\r\n    Node old = getNodeUnsafe(node, offsets[index]);\r\n    initializeNode(node, index, value);\r\n    update(node, old, value);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.AArch64LIRGenerator.loadNonCompareConst",
	"Comment": "if value is a constant that cannot be used directly with a gpcompare instruction load it intoa register and return the register, otherwise return constant value unchanged.",
	"Method": "Value loadNonCompareConst(Value value){\r\n    if (!isCompareConstant(value)) {\r\n        return loadReg(value);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.RegexProfile.shouldUseEagerMatching",
	"Comment": "decides whether the capture groups of the regular expression should be matched in an eagermanner.",
	"Method": "boolean shouldUseEagerMatching(){\r\n    return matchRatio() > 0.5 && cgAccessRatio() > 0.5 && (avgMatchLength < 5 || avgMatchedPortionOfSearchSpace > 0.4);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.PhiNode.initializeValueAt",
	"Comment": "sets the value at the given index and makes sure that the values list is large enough.",
	"Method": "void initializeValueAt(int i,ValueNode x){\r\n    while (values().size() <= i) {\r\n        values().add(null);\r\n    }\r\n    values().set(i, x);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.util.GraphUtil.toString",
	"Comment": "returns a string representation of the given collection of objects.",
	"Method": "String toString(Iterable<?> objects){\r\n    StringBuilder str = new StringBuilder();\r\n    str.append(\"[\");\r\n    for (Object o : objects) {\r\n        str.append(o).append(\", \");\r\n    }\r\n    if (str.length() > 1) {\r\n        str.setLength(str.length() - 2);\r\n    }\r\n    str.append(\"]\");\r\n    return str.toString();\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.common.inlining.walker.InliningData.getInvocationStackTrace",
	"Comment": "gets a stack trace representing the current inlining stack represented by this object.",
	"Method": "Collection<StackTraceElement> getInvocationStackTrace(){\r\n    List<StackTraceElement> result = new ArrayList();\r\n    for (CallsiteHolder graph : graphQueue) {\r\n        result.add(graph.method().asStackTraceElement(0));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.DebugContext.isVerifyEnabled",
	"Comment": "determines if verification is enabled in the current scope.",
	"Method": "boolean isVerifyEnabled(){\r\n    return currentScope != null && currentScope.isVerifyEnabled();\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.util.GraphOrder.assertSchedulableGraph",
	"Comment": "this method schedules the graph and makes sure that, for every node, all inputs are availableat the position where it is scheduled. this is a very expensive assertion.",
	"Method": "boolean assertSchedulableGraph(StructuredGraph graph){\r\n    assert graph.getGuardsStage() != GuardsStage.AFTER_FSA : \"Cannot use the BlockIteratorClosure after FrameState Assignment, HIR Loop Data Structures are no longer valid.\";\r\n    try {\r\n        final SchedulePhase schedulePhase = new SchedulePhase(SchedulingStrategy.LATEST_OUT_OF_LOOPS, true);\r\n        final EconomicMap<LoopBeginNode, NodeBitMap> loopEntryStates = EconomicMap.create(Equivalence.IDENTITY);\r\n        schedulePhase.apply(graph, false);\r\n        final ScheduleResult schedule = graph.getLastSchedule();\r\n        BlockIteratorClosure<NodeBitMap> closure = new BlockIteratorClosure<NodeBitMap>() {\r\n            @Override\r\n            protected List<NodeBitMap> processLoop(Loop<Block> loop, NodeBitMap initialState) {\r\n                return ReentrantBlockIterator.processLoop(this, loop, initialState).exitStates;\r\n            }\r\n            @Override\r\n            protected NodeBitMap processBlock(final Block block, final NodeBitMap currentState) {\r\n                final List<Node> list = graph.getLastSchedule().getBlockToNodesMap().get(block);\r\n                FrameState pendingStateAfter = null;\r\n                for (final Node node : list) {\r\n                    if (node instanceof ValueNode) {\r\n                        FrameState stateAfter = node instanceof StateSplit ? ((StateSplit) node).stateAfter() : null;\r\n                        if (node instanceof FullInfopointNode) {\r\n                            stateAfter = ((FullInfopointNode) node).getState();\r\n                        }\r\n                        if (pendingStateAfter != null && node instanceof FixedNode) {\r\n                            pendingStateAfter.applyToNonVirtual(new NodeClosure<Node>() {\r\n                                @Override\r\n                                public void apply(Node usage, Node nonVirtualNode) {\r\n                                    assert currentState.isMarked(nonVirtualNode) || nonVirtualNode instanceof VirtualObjectNode || nonVirtualNode instanceof ConstantNode : nonVirtualNode + \" not available at virtualstate \" + usage + \" before \" + node + \" in block \" + block + \" \\n\" + list;\r\n                                }\r\n                            });\r\n                            pendingStateAfter = null;\r\n                        }\r\n                        if (node instanceof AbstractMergeNode) {\r\n                            currentState.markAll(((AbstractMergeNode) node).phis());\r\n                            if (node instanceof LoopBeginNode) {\r\n                                loopEntryStates.put((LoopBeginNode) node, currentState.copy());\r\n                            }\r\n                        } else if (node instanceof ProxyNode) {\r\n                            assert false : \"proxy nodes should not be in the schedule\";\r\n                        } else if (node instanceof LoopExitNode) {\r\n                            if (graph.hasValueProxies()) {\r\n                                for (ProxyNode proxy : ((LoopExitNode) node).proxies()) {\r\n                                    for (Node input : proxy.inputs()) {\r\n                                        if (input != proxy.proxyPoint()) {\r\n                                            assert currentState.isMarked(input) : input + \" not available at \" + proxy + \" in block \" + block + \"\\n\" + list;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                currentState.clearAll();\r\n                                currentState.markAll(loopEntryStates.get(((LoopExitNode) node).loopBegin()));\r\n                            }\r\n                            currentState.markAll(((LoopExitNode) node).proxies());\r\n                        } else {\r\n                            for (Node input : node.inputs()) {\r\n                                if (input != stateAfter) {\r\n                                    if (input instanceof FrameState) {\r\n                                        ((FrameState) input).applyToNonVirtual(new VirtualState.NodeClosure<Node>() {\r\n                                            @Override\r\n                                            public void apply(Node usage, Node nonVirtual) {\r\n                                                assert currentState.isMarked(nonVirtual) : nonVirtual + \" not available at \" + node + \" in block \" + block + \"\\n\" + list;\r\n                                            }\r\n                                        });\r\n                                    } else {\r\n                                        assert currentState.isMarked(input) || input instanceof VirtualObjectNode || input instanceof ConstantNode : input + \" not available at \" + node + \" in block \" + block + \"\\n\" + list;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        if (node instanceof AbstractEndNode) {\r\n                            AbstractMergeNode merge = ((AbstractEndNode) node).merge();\r\n                            for (PhiNode phi : merge.phis()) {\r\n                                ValueNode phiValue = phi.valueAt((AbstractEndNode) node);\r\n                                assert phiValue == null || currentState.isMarked(phiValue) || phiValue instanceof ConstantNode : phiValue + \" not available at phi \" + phi + \" / end \" + node + \" in block \" + block;\r\n                            }\r\n                        }\r\n                        if (stateAfter != null) {\r\n                            assert pendingStateAfter == null;\r\n                            pendingStateAfter = stateAfter;\r\n                        }\r\n                        currentState.mark(node);\r\n                    }\r\n                }\r\n                if (pendingStateAfter != null) {\r\n                    pendingStateAfter.applyToNonVirtual(new NodeClosure<Node>() {\r\n                        @Override\r\n                        public void apply(Node usage, Node nonVirtualNode) {\r\n                            assert currentState.isMarked(nonVirtualNode) || nonVirtualNode instanceof VirtualObjectNode || nonVirtualNode instanceof ConstantNode : nonVirtualNode + \" not available at virtualstate \" + usage + \" at end of block \" + block + \" \\n\" + list;\r\n                        }\r\n                    });\r\n                }\r\n                return currentState;\r\n            }\r\n            @Override\r\n            protected NodeBitMap merge(Block merge, List<NodeBitMap> states) {\r\n                NodeBitMap result = states.get(0);\r\n                for (int i = 1; i < states.size(); i++) {\r\n                    result.intersect(states.get(i));\r\n                }\r\n                return result;\r\n            }\r\n            @Override\r\n            protected NodeBitMap getInitialState() {\r\n                NodeBitMap ret = graph.createNodeBitMap();\r\n                ret.markAll(graph.getNodes().filter(ConstantNode.class));\r\n                return ret;\r\n            }\r\n            @Override\r\n            protected NodeBitMap cloneState(NodeBitMap oldState) {\r\n                return oldState.copy();\r\n            }\r\n        };\r\n        ReentrantBlockIterator.apply(closure, schedule.getCFG().getStartBlock());\r\n    } catch (Throwable t) {\r\n        graph.getDebug().handle(t);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.util.GraphOrder.assertSchedulableGraph",
	"Comment": "this method schedules the graph and makes sure that, for every node, all inputs are availableat the position where it is scheduled. this is a very expensive assertion.",
	"Method": "boolean assertSchedulableGraph(StructuredGraph graph){\r\n    return ReentrantBlockIterator.processLoop(this, loop, initialState).exitStates;\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.util.GraphOrder.assertSchedulableGraph",
	"Comment": "this method schedules the graph and makes sure that, for every node, all inputs are availableat the position where it is scheduled. this is a very expensive assertion.",
	"Method": "boolean assertSchedulableGraph(StructuredGraph graph){\r\n    final List<Node> list = graph.getLastSchedule().getBlockToNodesMap().get(block);\r\n    FrameState pendingStateAfter = null;\r\n    for (final Node node : list) {\r\n        if (node instanceof ValueNode) {\r\n            FrameState stateAfter = node instanceof StateSplit ? ((StateSplit) node).stateAfter() : null;\r\n            if (node instanceof FullInfopointNode) {\r\n                stateAfter = ((FullInfopointNode) node).getState();\r\n            }\r\n            if (pendingStateAfter != null && node instanceof FixedNode) {\r\n                pendingStateAfter.applyToNonVirtual(new NodeClosure<Node>() {\r\n                    @Override\r\n                    public void apply(Node usage, Node nonVirtualNode) {\r\n                        assert currentState.isMarked(nonVirtualNode) || nonVirtualNode instanceof VirtualObjectNode || nonVirtualNode instanceof ConstantNode : nonVirtualNode + \" not available at virtualstate \" + usage + \" before \" + node + \" in block \" + block + \" \\n\" + list;\r\n                    }\r\n                });\r\n                pendingStateAfter = null;\r\n            }\r\n            if (node instanceof AbstractMergeNode) {\r\n                currentState.markAll(((AbstractMergeNode) node).phis());\r\n                if (node instanceof LoopBeginNode) {\r\n                    loopEntryStates.put((LoopBeginNode) node, currentState.copy());\r\n                }\r\n            } else if (node instanceof ProxyNode) {\r\n                assert false : \"proxy nodes should not be in the schedule\";\r\n            } else if (node instanceof LoopExitNode) {\r\n                if (graph.hasValueProxies()) {\r\n                    for (ProxyNode proxy : ((LoopExitNode) node).proxies()) {\r\n                        for (Node input : proxy.inputs()) {\r\n                            if (input != proxy.proxyPoint()) {\r\n                                assert currentState.isMarked(input) : input + \" not available at \" + proxy + \" in block \" + block + \"\\n\" + list;\r\n                            }\r\n                        }\r\n                    }\r\n                    currentState.clearAll();\r\n                    currentState.markAll(loopEntryStates.get(((LoopExitNode) node).loopBegin()));\r\n                }\r\n                currentState.markAll(((LoopExitNode) node).proxies());\r\n            } else {\r\n                for (Node input : node.inputs()) {\r\n                    if (input != stateAfter) {\r\n                        if (input instanceof FrameState) {\r\n                            ((FrameState) input).applyToNonVirtual(new VirtualState.NodeClosure<Node>() {\r\n                                @Override\r\n                                public void apply(Node usage, Node nonVirtual) {\r\n                                    assert currentState.isMarked(nonVirtual) : nonVirtual + \" not available at \" + node + \" in block \" + block + \"\\n\" + list;\r\n                                }\r\n                            });\r\n                        } else {\r\n                            assert currentState.isMarked(input) || input instanceof VirtualObjectNode || input instanceof ConstantNode : input + \" not available at \" + node + \" in block \" + block + \"\\n\" + list;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (node instanceof AbstractEndNode) {\r\n                AbstractMergeNode merge = ((AbstractEndNode) node).merge();\r\n                for (PhiNode phi : merge.phis()) {\r\n                    ValueNode phiValue = phi.valueAt((AbstractEndNode) node);\r\n                    assert phiValue == null || currentState.isMarked(phiValue) || phiValue instanceof ConstantNode : phiValue + \" not available at phi \" + phi + \" / end \" + node + \" in block \" + block;\r\n                }\r\n            }\r\n            if (stateAfter != null) {\r\n                assert pendingStateAfter == null;\r\n                pendingStateAfter = stateAfter;\r\n            }\r\n            currentState.mark(node);\r\n        }\r\n    }\r\n    if (pendingStateAfter != null) {\r\n        pendingStateAfter.applyToNonVirtual(new NodeClosure<Node>() {\r\n            @Override\r\n            public void apply(Node usage, Node nonVirtualNode) {\r\n                assert currentState.isMarked(nonVirtualNode) || nonVirtualNode instanceof VirtualObjectNode || nonVirtualNode instanceof ConstantNode : nonVirtualNode + \" not available at virtualstate \" + usage + \" at end of block \" + block + \" \\n\" + list;\r\n            }\r\n        });\r\n    }\r\n    return currentState;\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.util.GraphOrder.assertSchedulableGraph",
	"Comment": "this method schedules the graph and makes sure that, for every node, all inputs are availableat the position where it is scheduled. this is a very expensive assertion.",
	"Method": "boolean assertSchedulableGraph(StructuredGraph graph){\r\n    assert currentState.isMarked(nonVirtualNode) || nonVirtualNode instanceof VirtualObjectNode || nonVirtualNode instanceof ConstantNode : nonVirtualNode + \" not available at virtualstate \" + usage + \" before \" + node + \" in block \" + block + \" \\n\" + list;\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.util.GraphOrder.assertSchedulableGraph",
	"Comment": "this method schedules the graph and makes sure that, for every node, all inputs are availableat the position where it is scheduled. this is a very expensive assertion.",
	"Method": "boolean assertSchedulableGraph(StructuredGraph graph){\r\n    assert currentState.isMarked(nonVirtual) : nonVirtual + \" not available at \" + node + \" in block \" + block + \"\\n\" + list;\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.util.GraphOrder.assertSchedulableGraph",
	"Comment": "this method schedules the graph and makes sure that, for every node, all inputs are availableat the position where it is scheduled. this is a very expensive assertion.",
	"Method": "boolean assertSchedulableGraph(StructuredGraph graph){\r\n    assert currentState.isMarked(nonVirtualNode) || nonVirtualNode instanceof VirtualObjectNode || nonVirtualNode instanceof ConstantNode : nonVirtualNode + \" not available at virtualstate \" + usage + \" at end of block \" + block + \" \\n\" + list;\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.util.GraphOrder.assertSchedulableGraph",
	"Comment": "this method schedules the graph and makes sure that, for every node, all inputs are availableat the position where it is scheduled. this is a very expensive assertion.",
	"Method": "boolean assertSchedulableGraph(StructuredGraph graph){\r\n    NodeBitMap result = states.get(0);\r\n    for (int i = 1; i < states.size(); i++) {\r\n        result.intersect(states.get(i));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.util.GraphOrder.assertSchedulableGraph",
	"Comment": "this method schedules the graph and makes sure that, for every node, all inputs are availableat the position where it is scheduled. this is a very expensive assertion.",
	"Method": "boolean assertSchedulableGraph(StructuredGraph graph){\r\n    NodeBitMap ret = graph.createNodeBitMap();\r\n    ret.markAll(graph.getNodes().filter(ConstantNode.class));\r\n    return ret;\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.util.GraphOrder.assertSchedulableGraph",
	"Comment": "this method schedules the graph and makes sure that, for every node, all inputs are availableat the position where it is scheduled. this is a very expensive assertion.",
	"Method": "boolean assertSchedulableGraph(StructuredGraph graph){\r\n    return oldState.copy();\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.SwitchStrategy.registerDefaultEffort",
	"Comment": "tells the system that the default successor is reached after depth number of comparisons,which is used to calculate average effort.",
	"Method": "void registerDefaultEffort(int depth){\r\n    if (effortClosure != null) {\r\n        effortClosure.defaultEffort += depth;\r\n        effortClosure.defaultCount++;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.gen.DebugInfoBuilder.storageKind",
	"Comment": "customization point for subclasses. for example, word types have a kind object, but areinternally stored as a primitive value. we do not know about word types here, but subclassesdo know.",
	"Method": "JavaKind storageKind(JavaType type){\r\n    return type.getJavaKind();\r\n}"
}, {
	"Path": "org.graalvm.polyglot.Source.create",
	"Comment": "shortcut for creating a source object from a language and char sequence. the given charactersmust not mutate after they were accessed for the first time.",
	"Method": "Source create(String language,CharSequence source){\r\n    return newBuilder(language, source, \"Unnamed\").buildLiteral();\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.OptimizedOSRLoopNodeTest.testExternalInvalidations",
	"Comment": "test behavior of invalidations when they come from the outside.",
	"Method": "void testExternalInvalidations(OSRLoopFactory factory){\r\n    TestRootNode rootNode = new TestRootNode(factory, new TestRepeatingNode());\r\n    executeNoCallTarget(rootNode, OSR_THRESHOLD + 1);\r\n    assertCompiled(rootNode.getOSRTarget());\r\n    for (int i = 0; i < 10; i++) {\r\n        rootNode.getOSRTarget().invalidate(this, \"test\");\r\n        Assert.assertNotNull(rootNode.getOSRTarget());\r\n        assertNotCompiled(rootNode.getOSRTarget());\r\n        Assert.assertNotNull(rootNode.getOSRTarget());\r\n        executeNoCallTarget(rootNode, OSR_THRESHOLD - 1);\r\n        assertNotCompiled(rootNode.getOSRTarget());\r\n        Assert.assertNull(rootNode.getOSRTarget());\r\n        executeNoCallTarget(rootNode, OSR_THRESHOLD + 1);\r\n        assertCompiled(rootNode.getOSRTarget());\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.aarch64.AArch64Assembler.cas",
	"Comment": "compare and swap word or doubleword in memory. this reads a value from an address rn,compares it against a given value rs, and, if equal, stores the value rt to memory. the valueread from address rn is stored in register rs.",
	"Method": "void cas(int size,Register rs,Register rt,Register rn,boolean acquire,boolean release){\r\n    assert size == 32 || size == 64;\r\n    int transferSize = NumUtil.log2Ceil(size / 8);\r\n    compareAndSwapInstruction(CAS, rs, rt, rn, transferSize, acquire, release);\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.runtime.OptimizedAssumption.countDependencies",
	"Comment": "gets the number of dependencies registered with this assumption.",
	"Method": "int countDependencies(){\r\n    return size;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.GraalCompilerTest.iterationCount",
	"Comment": "inject an iteration count for a loop condition into the profiling information of this testcase.",
	"Method": "boolean iterationCount(double i,boolean cond){\r\n    return GraalDirectives.injectIterationCount(i, cond);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.extended.IntegerSwitchNode.tryRemoveUnreachableKeys",
	"Comment": "remove unreachable keys from the switch based on the stamp of the value, i.e., based on theknown range of the switch value.",
	"Method": "boolean tryRemoveUnreachableKeys(SimplifierTool tool,Stamp valueStamp){\r\n    if (!(valueStamp instanceof IntegerStamp)) {\r\n        return false;\r\n    }\r\n    IntegerStamp integerStamp = (IntegerStamp) valueStamp;\r\n    if (integerStamp.isUnrestricted()) {\r\n        return false;\r\n    }\r\n    List<KeyData> newKeyDatas = new ArrayList(keys.length);\r\n    ArrayList<AbstractBeginNode> newSuccessors = new ArrayList(blockSuccessorCount());\r\n    for (int i = 0; i < keys.length; i++) {\r\n        if (integerStamp.contains(keys[i]) && keySuccessor(i) != defaultSuccessor()) {\r\n            newKeyDatas.add(new KeyData(keys[i], keyProbabilities[i], addNewSuccessor(keySuccessor(i), newSuccessors)));\r\n        }\r\n    }\r\n    if (newKeyDatas.size() == keys.length) {\r\n        return false;\r\n    } else if (newKeyDatas.size() == 0) {\r\n        if (tool != null) {\r\n            tool.addToWorkList(defaultSuccessor());\r\n        }\r\n        graph().removeSplitPropagate(this, defaultSuccessor());\r\n        return true;\r\n    } else {\r\n        int newDefaultSuccessor = addNewSuccessor(defaultSuccessor(), newSuccessors);\r\n        double newDefaultProbability = keyProbabilities[keyProbabilities.length - 1];\r\n        doReplace(value(), newKeyDatas, newSuccessors, newDefaultSuccessor, newDefaultProbability);\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.bytecode.Bytecodes.isStop",
	"Comment": "determines if a given opcode denotes an instruction that ends a basic block and does not letcontrol flow fall through to its lexical successor.",
	"Method": "boolean isStop(int opcode){\r\n    return (flagsArray[opcode & 0xff] & STOP) != 0;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.type.Stamp.asConstant",
	"Comment": "if this stamp represents a single value, the methods returns this single value. it returnsnull otherwise.",
	"Method": "Constant asConstant(){\r\n    return null;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.NamedLocationIdentity.create",
	"Comment": "creates a named unique location identity for read and write operations.",
	"Method": "NamedLocationIdentity create(String name,boolean immutable){\r\n    return new NamedLocationIdentity(name, immutable);\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.asm.CompilationResultBuilder.isSuccessorEdge",
	"Comment": "determines if a given edge from the block currently being emitted goes to its lexicalsuccessor.",
	"Method": "boolean isSuccessorEdge(LabelRef edge){\r\n    assert lir != null;\r\n    AbstractBlockBase<?>[] order = lir.codeEmittingOrder();\r\n    assert order[currentBlockIndex] == edge.getSourceBlock();\r\n    AbstractBlockBase<?> nextBlock = LIR.getNextBlock(order, currentBlockIndex);\r\n    return nextBlock == edge.getTargetBlock();\r\n}"
}, {
	"Path": "org.graalvm.compiler.bytecode.Bytecodes.isStore",
	"Comment": "determines if a given opcode denotes an instruction that stores a value to a local variableafter popping it from the operand stack.",
	"Method": "boolean isStore(int opcode){\r\n    return (flagsArray[opcode & 0xff] & STORE) != 0;\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.aarch64.AArch64Assembler.ldadd",
	"Comment": "atomic add. this reads a value from an address rn, stores the value in rt, and adds the valuein rs to it, and stores the result back at address rn. the initial value read from memory isstored in rt.",
	"Method": "void ldadd(int size,Register rs,Register rt,Register rn,boolean acquire,boolean release){\r\n    assert size == 8 || size == 16 || size == 32 || size == 64;\r\n    int transferSize = NumUtil.log2Ceil(size / 8);\r\n    loadAndAddInstruction(LDADD, rs, rt, rn, transferSize, acquire, release);\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.trace.lsra.FixedInterval.logString",
	"Comment": "gets a single line string for logging the details of this interval to a log stream.",
	"Method": "String logString(){\r\n    StringBuilder buf = new StringBuilder(100);\r\n    buf.append(\"fix \").append(asRegister(operand).number).append(':').append(operand).append(' ');\r\n    buf.append(\" ranges{\");\r\n    FixedRange cur = first;\r\n    while (cur != FixedRange.EndMarker) {\r\n        if (cur != first) {\r\n            buf.append(\", \");\r\n        }\r\n        buf.append(cur);\r\n        cur = cur.next;\r\n        assert cur != null : \"range list not closed with range sentinel\";\r\n    }\r\n    buf.append(\"}\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.lsra.LinearScan.createDerivedInterval",
	"Comment": "creates an interval as a result of splitting or spilling another interval.",
	"Method": "Interval createDerivedInterval(Interval source){\r\n    if (firstDerivedIntervalIndex == -1) {\r\n        firstDerivedIntervalIndex = intervalsSize;\r\n    }\r\n    if (intervalsSize == intervals.length) {\r\n        intervals = Arrays.copyOf(intervals, intervals.length + (intervals.length >> SPLIT_INTERVALS_CAPACITY_RIGHT_SHIFT) + 1);\r\n    }\r\n    intervalsSize++;\r\n    assert intervalsSize <= intervals.length;\r\n    Variable variable = new Variable(source.kind(), numVariables++);\r\n    Interval interval = createInterval(variable);\r\n    assert intervals[intervalsSize - 1] == interval;\r\n    return interval;\r\n}"
}, {
	"Path": "org.graalvm.compiler.bytecode.Bytecodes.isBlockEnd",
	"Comment": "determines if a given opcode is an instruction that delimits a basic block.",
	"Method": "boolean isBlockEnd(int opcode){\r\n    return (flagsArray[opcode & 0xff] & (STOP | FALL_THROUGH)) != 0;\r\n}"
}, {
	"Path": "org.graalvm.compiler.java.BytecodeParser.needsExplicitDivisionByZeroException",
	"Comment": "returns true if an explicit null check should be emitted for the given object.",
	"Method": "boolean needsExplicitDivisionByZeroException(ValueNode y){\r\n    return needsExplicitException();\r\n}"
}, {
	"Path": "org.graalvm.compiler.options.OptionDescriptor.getExtraHelp",
	"Comment": "gets extra lines of help text. these lines should not be subject to any line wrapping orformatting apart from indentation.",
	"Method": "List<String> getExtraHelp(){\r\n    return extraHelp;\r\n}"
}, {
	"Path": "org.graalvm.compiler.code.CompilationResult.getAssumptions",
	"Comment": "gets the assumptions made during compilation.the caller must not modify the contents of the returned array.",
	"Method": "Assumption[] getAssumptions(){\r\n    return assumptions;\r\n}"
}, {
	"Path": "org.graalvm.util.test.CollectionSizeTest.testSize",
	"Comment": "tests the memory size of an empty map and a map with only one or two entries.",
	"Method": "void testSize(){\r\n    Assume.assumeTrue(\"Not working in JDK9 due to module visibility.\", GraalTest.Java8OrEarlier);\r\n    EconomicMap<Object, Object> map = EconomicMap.create(Equivalence.IDENTITY);\r\n    assertEquals(49, ObjectSizeEstimate.forObject(map).getTotalBytes());\r\n    Integer value = 1;\r\n    map.put(value, value);\r\n    assertEquals(153, ObjectSizeEstimate.forObject(map).getTotalBytes());\r\n    Integer secondValue = 2;\r\n    map.put(secondValue, secondValue);\r\n    assertEquals(153 + 20, ObjectSizeEstimate.forObject(map).getTotalBytes());\r\n}"
}, {
	"Path": "org.graalvm.polyglot.Engine.newBuilder",
	"Comment": "creates a new context builder that allows to configure an engine instance.",
	"Method": "Builder newBuilder(){\r\n    return EMPTY.new Builder();\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.IfNode.removeOrMaterializeIf",
	"Comment": "tries to remove an empty if construct or replace an if construct with a materialization.",
	"Method": "boolean removeOrMaterializeIf(SimplifierTool tool){\r\n    assert trueSuccessor().hasNoUsages() && falseSuccessor().hasNoUsages();\r\n    if (trueSuccessor().next() instanceof AbstractEndNode && falseSuccessor().next() instanceof AbstractEndNode) {\r\n        AbstractEndNode trueEnd = (AbstractEndNode) trueSuccessor().next();\r\n        AbstractEndNode falseEnd = (AbstractEndNode) falseSuccessor().next();\r\n        AbstractMergeNode merge = trueEnd.merge();\r\n        if (merge == falseEnd.merge() && trueSuccessor().anchored().isEmpty() && falseSuccessor().anchored().isEmpty()) {\r\n            PhiNode singlePhi = null;\r\n            int distinct = 0;\r\n            for (PhiNode phi : merge.phis()) {\r\n                ValueNode trueValue = phi.valueAt(trueEnd);\r\n                ValueNode falseValue = phi.valueAt(falseEnd);\r\n                if (trueValue != falseValue) {\r\n                    distinct++;\r\n                    singlePhi = phi;\r\n                }\r\n            }\r\n            if (distinct == 0) {\r\n                removeThroughFalseBranch(tool, merge);\r\n                return true;\r\n            } else if (distinct == 1) {\r\n                ValueNode trueValue = singlePhi.valueAt(trueEnd);\r\n                ValueNode falseValue = singlePhi.valueAt(falseEnd);\r\n                ValueNode conditional = canonicalizeConditionalCascade(tool, trueValue, falseValue);\r\n                if (conditional != null) {\r\n                    conditional = proxyReplacement(conditional);\r\n                    singlePhi.setValueAt(trueEnd, conditional);\r\n                    removeThroughFalseBranch(tool, merge);\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (trueSuccessor().next() instanceof ReturnNode && falseSuccessor().next() instanceof ReturnNode) {\r\n        ReturnNode trueEnd = (ReturnNode) trueSuccessor().next();\r\n        ReturnNode falseEnd = (ReturnNode) falseSuccessor().next();\r\n        ValueNode trueValue = trueEnd.result();\r\n        ValueNode falseValue = falseEnd.result();\r\n        ValueNode value = null;\r\n        if (trueValue != null) {\r\n            if (trueValue == falseValue) {\r\n                value = trueValue;\r\n            } else {\r\n                value = canonicalizeConditionalCascade(tool, trueValue, falseValue);\r\n                if (value == null) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        ReturnNode newReturn = graph().add(new ReturnNode(value));\r\n        replaceAtPredecessor(newReturn);\r\n        GraphUtil.killCFG(this);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.FrameState.localAt",
	"Comment": "gets the value in the local variables at the specified index.",
	"Method": "ValueNode localAt(int i){\r\n    assert i >= 0 && i < localsSize : \"local variable index out of range: \" + i;\r\n    return values.get(i);\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.aarch64.AArch64HotSpotSafepointOp.isPollingPageFar",
	"Comment": "conservatively checks whether we can load the safepoint polling address with a single ldrinstruction or not.",
	"Method": "boolean isPollingPageFar(GraalHotSpotVMConfig config){\r\n    final long pollingPageAddress = config.safepointPollingAddress;\r\n    return !NumUtil.isSignedNbit(21, pollingPageAddress - config.codeCacheLowBound) || !NumUtil.isSignedNbit(21, pollingPageAddress - config.codeCacheHighBound);\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.lsra.LinearScanWalker.allocLockedRegister",
	"Comment": "split an interval and spill it to memory so that cur can be placed in a register",
	"Method": "void allocLockedRegister(Interval interval){\r\n    DebugContext debug = allocator.getDebug();\r\n    try (Indent indent = debug.logAndIndent(\"alloc locked register: need to split and spill to get register for %s\", interval)) {\r\n        int firstUsage = interval.firstUsage(RegisterPriority.MustHaveRegister);\r\n        int firstShouldHaveUsage = interval.firstUsage(RegisterPriority.ShouldHaveRegister);\r\n        int regNeededUntil = Math.min(firstUsage, interval.from() + 1);\r\n        int intervalTo = interval.to();\r\n        assert regNeededUntil >= 0 && regNeededUntil < Integer.MAX_VALUE : \"interval has no use\";\r\n        Register reg;\r\n        Register ignore;\r\n        for (RegisterPriority registerPriority = RegisterPriority.LiveAtLoopEnd; true; registerPriority = RegisterPriority.MustHaveRegister) {\r\n            initUseLists(false);\r\n            spillExcludeActiveFixed();\r\n            assert unhandledLists.get(RegisterBinding.Fixed).isEndMarker() : \"must not have unhandled fixed intervals because all fixed intervals have a use at position 0\";\r\n            spillBlockInactiveFixed(interval);\r\n            spillCollectActiveAny(registerPriority);\r\n            spillCollectInactiveAny(interval);\r\n            if (debug.isLogEnabled()) {\r\n                printRegisterState();\r\n            }\r\n            reg = null;\r\n            ignore = interval.location() != null && isRegister(interval.location()) ? asRegister(interval.location()) : null;\r\n            for (Register availableReg : availableRegs) {\r\n                int number = availableReg.number;\r\n                if (availableReg.equals(ignore)) {\r\n                } else if (usePos[number] > regNeededUntil) {\r\n                    if (reg == null || (usePos[number] > usePos[reg.number])) {\r\n                        reg = availableReg;\r\n                    }\r\n                }\r\n            }\r\n            int regUsePos = (reg == null ? 0 : usePos[reg.number]);\r\n            if (regUsePos <= firstShouldHaveUsage) {\r\n                if (debug.isLogEnabled()) {\r\n                    debug.log(\"able to spill current interval. firstUsage(register): %d, usePos: %d\", firstUsage, regUsePos);\r\n                }\r\n                if (firstUsage <= interval.from() + 1) {\r\n                    if (registerPriority.equals(RegisterPriority.LiveAtLoopEnd)) {\r\n                        debug.log(\"retry with register priority must have register\");\r\n                        continue;\r\n                    }\r\n                    String description = generateOutOfRegErrorMsg(interval, firstUsage, availableRegs);\r\n                    allocator.assignSpillSlot(interval);\r\n                    debug.dump(DebugContext.INFO_LEVEL, allocator.getLIR(), description);\r\n                    allocator.printIntervals(description);\r\n                    throw new OutOfRegistersException(\"LinearScan: no register found\", description);\r\n                }\r\n                splitAndSpillInterval(interval);\r\n                return;\r\n            }\r\n            break;\r\n        }\r\n        boolean needSplit = blockPos[reg.number] <= intervalTo;\r\n        int splitPos = blockPos[reg.number];\r\n        if (debug.isLogEnabled()) {\r\n            debug.log(\"decided to use register %d\", reg.number);\r\n        }\r\n        assert splitPos > 0 : \"invalid splitPos\";\r\n        assert needSplit || splitPos > interval.from() : \"splitting interval at from\";\r\n        interval.assignLocation(reg.asValue(interval.kind()));\r\n        if (needSplit) {\r\n            splitWhenPartialRegisterAvailable(interval, splitPos);\r\n        }\r\n        splitAndSpillIntersectingIntervals(reg);\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.phases.profiling.FinalizeProfileNodesPhase.simpleMethodHeuristic",
	"Comment": "the heuristic is applied after the graph is fully formed and before the first lowering.",
	"Method": "boolean simpleMethodHeuristic(StructuredGraph graph){\r\n    if (Options.ProfileSimpleMethods.getValue(graph.getOptions())) {\r\n        return false;\r\n    }\r\n    if (graph.getNodeCount() > Options.SimpleMethodGraphSize.getValue(graph.getOptions())) {\r\n        return false;\r\n    }\r\n    if (graph.hasLoops()) {\r\n        return false;\r\n    }\r\n    if (graph.getNodes().filter(InvokeNode.class).count() > Options.SimpleMethodCalls.getValue(graph.getOptions())) {\r\n        return false;\r\n    }\r\n    if (graph.getNodes().filter(InvokeNode.class).filter((n) -> ((InvokeNode) n).getInvokeKind().isIndirect()).count() > Options.SimpleMethodIndirectCalls.getDefaultValue()) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.java.FrameStateBuilder.stackOp",
	"Comment": "performs a raw stack operation as defined in the java bytecode specification.",
	"Method": "void stackOp(int opcode){\r\n    switch(opcode) {\r\n        case POP:\r\n            {\r\n                ValueNode w1 = xpop();\r\n                assert w1 != TWO_SLOT_MARKER;\r\n                break;\r\n            }\r\n        case POP2:\r\n            {\r\n                xpop();\r\n                ValueNode w2 = xpop();\r\n                assert w2 != TWO_SLOT_MARKER;\r\n                break;\r\n            }\r\n        case DUP:\r\n            {\r\n                ValueNode w1 = xpeek();\r\n                assert w1 != TWO_SLOT_MARKER;\r\n                xpush(w1);\r\n                break;\r\n            }\r\n        case DUP_X1:\r\n            {\r\n                ValueNode w1 = xpop();\r\n                ValueNode w2 = xpop();\r\n                assert w1 != TWO_SLOT_MARKER;\r\n                xpush(w1);\r\n                xpush(w2);\r\n                xpush(w1);\r\n                break;\r\n            }\r\n        case DUP_X2:\r\n            {\r\n                ValueNode w1 = xpop();\r\n                ValueNode w2 = xpop();\r\n                ValueNode w3 = xpop();\r\n                assert w1 != TWO_SLOT_MARKER;\r\n                xpush(w1);\r\n                xpush(w3);\r\n                xpush(w2);\r\n                xpush(w1);\r\n                break;\r\n            }\r\n        case DUP2:\r\n            {\r\n                ValueNode w1 = xpop();\r\n                ValueNode w2 = xpop();\r\n                xpush(w2);\r\n                xpush(w1);\r\n                xpush(w2);\r\n                xpush(w1);\r\n                break;\r\n            }\r\n        case DUP2_X1:\r\n            {\r\n                ValueNode w1 = xpop();\r\n                ValueNode w2 = xpop();\r\n                ValueNode w3 = xpop();\r\n                xpush(w2);\r\n                xpush(w1);\r\n                xpush(w3);\r\n                xpush(w2);\r\n                xpush(w1);\r\n                break;\r\n            }\r\n        case DUP2_X2:\r\n            {\r\n                ValueNode w1 = xpop();\r\n                ValueNode w2 = xpop();\r\n                ValueNode w3 = xpop();\r\n                ValueNode w4 = xpop();\r\n                xpush(w2);\r\n                xpush(w1);\r\n                xpush(w4);\r\n                xpush(w3);\r\n                xpush(w2);\r\n                xpush(w1);\r\n                break;\r\n            }\r\n        case SWAP:\r\n            {\r\n                ValueNode w1 = xpop();\r\n                ValueNode w2 = xpop();\r\n                assert w1 != TWO_SLOT_MARKER;\r\n                assert w2 != TWO_SLOT_MARKER;\r\n                xpush(w1);\r\n                xpush(w2);\r\n                break;\r\n            }\r\n        default:\r\n            throw shouldNotReachHere();\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.word.WordOperationPlugin.handleInvoke",
	"Comment": "processes a call to a method if it is annotated as a word operation by adding nodes to thegraph being built that implement the denoted operation.",
	"Method": "boolean handleInvoke(GraphBuilderContext b,ResolvedJavaMethod method,ValueNode[] args){\r\n    if (!wordTypes.isWordOperation(method)) {\r\n        return false;\r\n    }\r\n    processWordOperation(b, args, wordTypes.getWordOperation(method, b.getMethod().getDeclaringClass()));\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.test.AArch64MNegTest.mulNegFloat",
	"Comment": "check the case that mneg rule does not work at the reason of data type.",
	"Method": "float mulNegFloat(float x,float y){\r\n    return ((x + 1) * 2 + 3) * (-y);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.IfNode.successor",
	"Comment": "gets the node corresponding to the specified outcome of the branch.",
	"Method": "AbstractBeginNode successor(boolean istrue){\r\n    return istrue ? trueSuccessor : falseSuccessor;\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.tregex.parser.ast.Group.add",
	"Comment": "adds a new alternative to this group. the new alternative will be appended to theend, meaning it will have the lowest priority among all the alternatives.",
	"Method": "void add(Sequence sequence){\r\n    sequence.setParent(this);\r\n    alternatives.add(sequence);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.java.AbstractNewArrayNode.dimensionCount",
	"Comment": "the rank of the array allocated by this node, i.e. how many array dimensions.",
	"Method": "int dimensionCount(){\r\n    return 1;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.ea.EscapeAnalysisTest.testMonitor2Snippet",
	"Comment": "this test case differs from the last one in that it requires inlining within a synchronizedregion.",
	"Method": "int testMonitor2Snippet(){\r\n    Integer x = new Integer(0);\r\n    Double y = new Double(0);\r\n    Object z = new Object();\r\n    synchronized (x) {\r\n        synchronized (y) {\r\n            synchronized (z) {\r\n                notInlineable();\r\n                return x.intValue();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.IfNode.sameDestination",
	"Comment": "check it these two blocks end up at the same place. meeting at the same merge, ordeoptimizing in the same way.",
	"Method": "boolean sameDestination(AbstractBeginNode succ1,AbstractBeginNode succ2){\r\n    Node next1 = succ1.next();\r\n    Node next2 = succ2.next();\r\n    if (next1 instanceof EndNode && next2 instanceof EndNode) {\r\n        EndNode end1 = (EndNode) next1;\r\n        EndNode end2 = (EndNode) next2;\r\n        if (end1.merge() == end2.merge()) {\r\n            for (PhiNode phi : end1.merge().phis()) {\r\n                if (phi.valueAt(end1) != phi.valueAt(end2)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    } else if (next1 instanceof DeoptimizeNode && next2 instanceof DeoptimizeNode) {\r\n        DeoptimizeNode deopt1 = (DeoptimizeNode) next1;\r\n        DeoptimizeNode deopt2 = (DeoptimizeNode) next2;\r\n        if (deopt1.getReason() == deopt2.getReason() && deopt1.getAction() == deopt2.getAction()) {\r\n            return true;\r\n        }\r\n    } else if (next1 instanceof LoopExitNode && next2 instanceof LoopExitNode) {\r\n        LoopExitNode exit1 = (LoopExitNode) next1;\r\n        LoopExitNode exit2 = (LoopExitNode) next2;\r\n        if (exit1.loopBegin() == exit2.loopBegin() && exit1.stateAfter() == exit2.stateAfter() && exit1.stateAfter() == null && sameDestination(exit1, exit2)) {\r\n            return true;\r\n        }\r\n    } else if (next1 instanceof ReturnNode && next2 instanceof ReturnNode) {\r\n        ReturnNode exit1 = (ReturnNode) next1;\r\n        ReturnNode exit2 = (ReturnNode) next2;\r\n        if (exit1.result() == exit2.result()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.GraalHotSpotVMConfig.layoutHelperElementTypePrimitiveInPlace",
	"Comment": "this filters out the bit that differentiates a type array from an object array.",
	"Method": "int layoutHelperElementTypePrimitiveInPlace(){\r\n    return (layoutHelperArrayTagTypeValue & ~layoutHelperArrayTagObjectValue) << layoutHelperArrayTagShift;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.aarch64.AArch64SaveRegistersOp.indexForStackSlot",
	"Comment": "computes the index of a stack slot relative to slot 0. this is also the bit index of stackslots in the reference map.",
	"Method": "int indexForStackSlot(FrameMap frameMap,StackSlot slot){\r\n    assert frameMap.offsetForStackSlot(slot) % frameMap.getTarget().wordSize == 0;\r\n    int value = frameMap.offsetForStackSlot(slot) / frameMap.getTarget().wordSize;\r\n    return value;\r\n}"
}, {
	"Path": "org.graalvm.compiler.graph.Graph.getNodeCount",
	"Comment": "gets the number of live nodes in this graph. that is the number of nodes which have beenadded to the graph minus the number of deleted nodes.",
	"Method": "int getNodeCount(){\r\n    return nodesSize - getNodesDeletedSinceLastCompression();\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.FrameState.checkStackDepth",
	"Comment": "perform a few sanity checks on the transformation of the stack state. the current expectationis that a stateafter is being transformed into a stateduring, so the stack depth may change.",
	"Method": "boolean checkStackDepth(int oldBci,int oldStackSize,boolean oldDuringCall,boolean oldRethrowException,int newBci,int newStackSize,boolean newDuringCall,boolean newRethrowException){\r\n    if (BytecodeFrame.isPlaceholderBci(oldBci)) {\r\n        return true;\r\n    }\r\n    byte[] codes = code.getCode();\r\n    if (codes == null) {\r\n        return true;\r\n    }\r\n    byte newCode = codes[newBci];\r\n    if (oldBci == newBci) {\r\n        assert oldStackSize == newStackSize || oldDuringCall != newDuringCall || oldRethrowException != newRethrowException : \"bci is unchanged, stack depth shouldn't change\";\r\n    } else {\r\n        byte oldCode = codes[oldBci];\r\n        assert Bytecodes.lengthOf(newCode) + newBci == oldBci || Bytecodes.lengthOf(oldCode) + oldBci == newBci : \"expecting roll back or forward\";\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.trace.lsra.TraceInterval.getUsePosRegisterPriority",
	"Comment": "gets the register priority for the use position at a specified index in this list.",
	"Method": "RegisterPriority getUsePosRegisterPriority(int index){\r\n    return RegisterPriority.VALUES[intListGet((index << 1) + 1)];\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.ControlFlowOptimizer.run",
	"Comment": "performs control flow optimizations on the given lir graph.",
	"Method": "void run(TargetDescription target,LIRGenerationResult lirGenRes,PostAllocationOptimizationContext context){\r\n    LIR lir = lirGenRes.getLIR();\r\n    new Optimizer(lir).deleteEmptyBlocks(lir.codeEmittingOrder());\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.GlobalMetrics.asKeyValueMap",
	"Comment": "creates and returns a sorted map from metric names to their values in this object.",
	"Method": "EconomicMap<MetricKey, Long> asKeyValueMap(){\r\n    List<MetricKey> keys = KeyRegistry.getKeys();\r\n    Collections.sort(keys, MetricKey.NAME_COMPARATOR);\r\n    EconomicMap<MetricKey, Long> res = EconomicMap.create(keys.size());\r\n    long[] vals = values;\r\n    for (MetricKey key : keys) {\r\n        int index = ((AbstractKey) key).getIndex();\r\n        if (vals == null || index >= vals.length) {\r\n            res.put(key, 0L);\r\n        } else {\r\n            res.put(key, vals[index]);\r\n        }\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "org.graalvm.compiler.graph.NodeIdAccessor.getNodeId",
	"Comment": "gets the identifier for a node. if assertions are enabled, this method asserts that theidentifier is stable.",
	"Method": "int getNodeId(Node node){\r\n    assert verifyIdsAreStable();\r\n    return node.id();\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.match.processor.MatchProcessor.reportExceptionThrow",
	"Comment": "bugs in an annotation processor can cause silent failure so try to report any exceptionthrows as errors.",
	"Method": "void reportExceptionThrow(Element element,Throwable t){\r\n    if (element != null) {\r\n        logMessage(\"throw for %s:\\n\", element);\r\n    }\r\n    logException(t);\r\n    printError(element, \"Exception throw during processing: %s %s\", t, Arrays.toString(Arrays.copyOf(t.getStackTrace(), 4)));\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.OptimizedOSRLoopNodeTest.testNoOSRAfterMinInvocationThreshold",
	"Comment": "test that if a call target is called a min invocation theshold times it is unlikely that itneeds osr at all.",
	"Method": "void testNoOSRAfterMinInvocationThreshold(OSRLoopFactory factory){\r\n    TestRootNode rootNode = new TestRootNode(factory, new TestRepeatingNode());\r\n    RootCallTarget target = runtime.createCallTarget(rootNode);\r\n    int i;\r\n    for (i = 0; i < TruffleRuntimeOptions.getValue(TruffleMinInvokeThreshold); i++) {\r\n        target.call(0);\r\n        assertNotCompiled(rootNode.getOSRTarget());\r\n    }\r\n    target.call(OSR_THRESHOLD);\r\n    assertNotCompiled(rootNode.getOSRTarget());\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.common.LockEliminationPhase.isCompatibleLock",
	"Comment": "check that the paired operations operate on the same object at the same lock depth.",
	"Method": "boolean isCompatibleLock(AccessMonitorNode lock1,AccessMonitorNode lock2){\r\n    ValueNode object1 = GraphUtil.unproxify(lock1.object());\r\n    ValueNode object2 = GraphUtil.unproxify(lock2.object());\r\n    return object1 == object2 && lock1.getMonitorId().getLockDepth() == lock2.getMonitorId().getLockDepth();\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.alloc.ComputeBlockOrder.addPathToLinearScanOrder",
	"Comment": "add a linear path to the linear scan order greedily following the most likely successor.",
	"Method": "T addPathToLinearScanOrder(T block,List<T> order,PriorityQueue<T> worklist,BitSet visitedBlocks){\r\n    block.setLinearScanNumber(order.size());\r\n    order.add(block);\r\n    T mostLikelySuccessor = findAndMarkMostLikelySuccessor(block, visitedBlocks);\r\n    enqueueSuccessors(block, worklist, visitedBlocks);\r\n    if (mostLikelySuccessor != null) {\r\n        if (!mostLikelySuccessor.isLoopHeader() && mostLikelySuccessor.getPredecessorCount() > 1) {\r\n            double unscheduledSum = 0.0;\r\n            for (T pred : mostLikelySuccessor.getPredecessors()) {\r\n                if (pred.getLinearScanNumber() == -1) {\r\n                    unscheduledSum += pred.getRelativeFrequency();\r\n                }\r\n            }\r\n            if (unscheduledSum > block.getRelativeFrequency() / PENALTY_VERSUS_UNSCHEDULED) {\r\n                visitedBlocks.clear(mostLikelySuccessor.getId());\r\n                return null;\r\n            }\r\n        }\r\n        return mostLikelySuccessor;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.sparc.SPARCSaveRegistersOp.indexForStackSlot",
	"Comment": "computes the index of a stack slot relative to slot 0. this is also the bit index of stackslots in the reference map.",
	"Method": "int indexForStackSlot(FrameMap frameMap,StackSlot slot){\r\n    assert frameMap.offsetForStackSlot(slot) % frameMap.getTarget().wordSize == 0;\r\n    int value = frameMap.offsetForStackSlot(slot) / frameMap.getTarget().wordSize;\r\n    return value;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin.getBytecodeProvider",
	"Comment": "gets the object used to access the bytecodes of the substitute method.",
	"Method": "BytecodeProvider getBytecodeProvider(){\r\n    return bytecodeProvider;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.util.GraphUtil.originalValueForComplicatedPhi",
	"Comment": "handling for complicated nestings of phi functions. we need to reduce phi functionsrecursively, and need a temporary map of visited nodes to avoid endless recursion of cycles.",
	"Method": "ValueNode originalValueForComplicatedPhi(PhiNode phi,NodeBitMap visited){\r\n    if (visited.isMarked(phi)) {\r\n        return null;\r\n    }\r\n    visited.mark(phi);\r\n    ValueNode phiSingleValue = null;\r\n    int count = phi.valueCount();\r\n    for (int i = 0; i < count; ++i) {\r\n        ValueNode phiCurValue = originalValueForProxy(phi.valueAt(i));\r\n        if (phiCurValue instanceof PhiNode) {\r\n            phiCurValue = originalValueForComplicatedPhi((PhiNode) phiCurValue, visited);\r\n        }\r\n        if (phiCurValue == null) {\r\n        } else if (phiSingleValue == null) {\r\n            phiSingleValue = phiCurValue;\r\n        } else if (phiCurValue != phiSingleValue) {\r\n            return phi;\r\n        }\r\n    }\r\n    return phiSingleValue;\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.OptimizedOSRLoopNodeTest.testOSRSingleInvocation",
	"Comment": "test that we achieve compilation on the first execution with a loop invoked",
	"Method": "void testOSRSingleInvocation(OSRLoopFactory factory){\r\n    TestRootNode rootNode = new TestRootNode(factory, new TestRepeatingNode());\r\n    CallTarget target = runtime.createCallTarget(rootNode);\r\n    target.call(OSR_THRESHOLD + 1);\r\n    assertCompiled(rootNode.getOSRTarget());\r\n    target.call(2);\r\n    assertCompiled(rootNode.getOSRTarget());\r\n    Assert.assertTrue(rootNode.wasRepeatingCalledCompiled());\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.tregex.dfa.NFATransitionSet.stream",
	"Comment": "returns a stream that will yield the elements contained in this set in insertionorder.",
	"Method": "Stream<NFAStateTransition> stream(){\r\n    return StreamSupport.stream(spliterator(), false);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.java.NewArrayNode.defaultElementValue",
	"Comment": "factored out in a separate method so that subclasses can override it.",
	"Method": "ConstantNode defaultElementValue(){\r\n    return ConstantNode.defaultForKind(elementType().getJavaKind(), graph());\r\n}"
}, {
	"Path": "org.graalvm.collections.EconomicMapImpl.compressLarge",
	"Comment": "compresses the graph and returns the translated new next index.",
	"Method": "int compressLarge(int nextIndex){\r\n    int size = INITIAL_CAPACITY;\r\n    int remaining = totalEntries - deletedEntries;\r\n    while (size <= remaining) {\r\n        size += Math.max(MIN_CAPACITY_INCREASE, size >> 1);\r\n    }\r\n    Object[] newEntries = new Object[size << 1];\r\n    int z = 0;\r\n    int newNextIndex = remaining;\r\n    for (int i = 0; i < totalEntries; ++i) {\r\n        Object key = getKey(i);\r\n        if (i == nextIndex) {\r\n            newNextIndex = z;\r\n        }\r\n        if (key != null) {\r\n            newEntries[z << 1] = key;\r\n            newEntries[(z << 1) + 1] = getValue(i);\r\n            z++;\r\n        }\r\n    }\r\n    this.entries = newEntries;\r\n    totalEntries = z;\r\n    deletedEntries = 0;\r\n    if (z <= getHashThreshold()) {\r\n        this.hashArray = null;\r\n    } else {\r\n        createHash();\r\n    }\r\n    return newNextIndex;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.type.Stamp.tryImproveWith",
	"Comment": "tries to improve this stamp with the stamp given as parameter. if successful, returns the newimproved stamp. otherwise, returns null.",
	"Method": "Stamp tryImproveWith(Stamp other){\r\n    Stamp improved = improveWith(other);\r\n    if (improved.equals(this)) {\r\n        return null;\r\n    }\r\n    return improved;\r\n}"
}, {
	"Path": "org.graalvm.compiler.serviceprovider.GraalServices.isThreadAllocatedMemorySupported",
	"Comment": "determines if the java virtual machine implementation supports thread memory allocationmeasurement.",
	"Method": "boolean isThreadAllocatedMemorySupported(){\r\n    JMXService jmx = JMXService.instance;\r\n    if (jmx == null) {\r\n        return false;\r\n    }\r\n    return jmx.isThreadAllocatedMemorySupported();\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.amd64.AMD64LIRGenerator.toRegisterKind",
	"Comment": "the amd64 backend only uses dword and qword values in registers because of a performancepenalty when accessing word or byte registers. this function converts small integer kinds todword.",
	"Method": "K toRegisterKind(K kind){\r\n    switch((AMD64Kind) kind.getPlatformKind()) {\r\n        case BYTE:\r\n        case WORD:\r\n            return kind.changeType(AMD64Kind.DWORD);\r\n        default:\r\n            return kind;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.type.TypeReference.createTrustedWithoutAssumptions",
	"Comment": "creates a type reference using the given type without assumptions and trusting interfacetypes.",
	"Method": "TypeReference createTrustedWithoutAssumptions(ResolvedJavaType type){\r\n    return createTrusted(null, type);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.type.Stamp.isUnrestricted",
	"Comment": "tests whether this stamp represents all values of this kind.",
	"Method": "boolean isUnrestricted(){\r\n    return this.equals(this.unrestricted());\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.result.PreCalculatedResultFactory.getLength",
	"Comment": "outermost bounds of the result, necessary for expressions where lookaround matches may exceedthe bounds of capture group 0.",
	"Method": "int getLength(){\r\n    return length;\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.tregex.automaton.TransitionBuilder.getTransitionSet",
	"Comment": "represents the set of nfa transitions currently contained in this transition fragment.",
	"Method": "TS getTransitionSet(){\r\n    return transitionSet;\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.MethodFilter.matches",
	"Comment": "determines if a given method is matched by a given array of filters.",
	"Method": "boolean matches(MethodFilter[] filters,JavaMethod method,boolean matches,JavaMethod o,boolean matches,String javaClassName,String name,Signature sig){\r\n    assert sig != null || signature == null;\r\n    if (methodName != null && !methodName.matcher(name).matches()) {\r\n        return false;\r\n    }\r\n    if (clazz != null && !clazz.matcher(javaClassName).matches()) {\r\n        return false;\r\n    }\r\n    return matchesSignature(sig);\r\n}"
}, {
	"Path": "org.graalvm.compiler.java.BytecodeParser.needsExplicitNullCheckException",
	"Comment": "returns true if an explicit null check should be emitted for the given object.",
	"Method": "boolean needsExplicitNullCheckException(ValueNode object){\r\n    return needsExplicitException();\r\n}"
}, {
	"Path": "org.graalvm.compiler.java.BytecodeParser.finishInstruction",
	"Comment": "hook for subclasses to modify the last instruction or add other instructions.",
	"Method": "FixedWithNextNode finishInstruction(FixedWithNextNode instr,FrameStateBuilder state){\r\n    return instr;\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.runtime.CancellableCompileTask.setFuture",
	"Comment": "this means it must be final and initialized before the future can be set.",
	"Method": "void setFuture(Future<?> future){\r\n    synchronized (this) {\r\n        if (this.future == null) {\r\n            this.future = future;\r\n        } else {\r\n            throw new IllegalStateException(\"The future should not be re-set.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.collections.EconomicMapImpl.getHashThreshold",
	"Comment": "number of entries above which a hash table should be constructed.",
	"Method": "int getHashThreshold(){\r\n    if (strategy == null || strategy == Equivalence.IDENTITY_WITH_SYSTEM_HASHCODE) {\r\n        return HASH_THRESHOLD_IDENTITY_COMPARE;\r\n    } else {\r\n        return HASH_THRESHOLD;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.jtt.bytecode.BC_lcmp.run4",
	"Comment": "test with big numbers where it makes difference if the value is handled with 64 bits.",
	"Method": "void run4(){\r\n    runTest(\"test\", -1L, Long.MIN_VALUE);\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.tregex.parser.ast.Group.addSequence",
	"Comment": "creates a new empty alternatives and adds it to the end of the list of alternatives.",
	"Method": "Sequence addSequence(RegexAST ast){\r\n    Sequence sequence = ast.createSequence();\r\n    add(sequence);\r\n    return sequence;\r\n}"
}, {
	"Path": "com.alibaba.json.test.Base64.encodeToString",
	"Comment": "encodes a raw byte array into a base64 string representation i accordance with rfc 2045.",
	"Method": "String encodeToString(byte[] sArr,boolean lineSep){\r\n    return new String(encodeToChar(sArr, lineSep));\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.ConditionalEliminationTestBase.getDefaultHighTierContext",
	"Comment": "these tests assume all code paths in called routines are reachable so disable removal of deadcode based on method profiles.",
	"Method": "HighTierContext getDefaultHighTierContext(){\r\n    return new HighTierContext(getProviders(), getDefaultGraphBuilderSuite(), OptimisticOptimizations.ALL.remove(Optimization.RemoveNeverExecutedCode));\r\n}"
}, {
	"Path": "org.graalvm.compiler.loop.LoopEx.deleteUnusedNodes",
	"Comment": "deletes any nodes created within the scope of this object that have no usages.",
	"Method": "void deleteUnusedNodes(){\r\n    if (ivs != null) {\r\n        for (InductionVariable iv : ivs.getValues()) {\r\n            iv.deleteUnusedNodes();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.common.inlining.walker.ComputeInliningRelevance.compute",
	"Comment": "initializes or updates the relevance computation. if there are no loops within the graph,most computation happens lazily.",
	"Method": "void compute(){\r\n    rootScope = null;\r\n    if (!graph.hasLoops()) {\r\n        rootScope = new Scope(graph.start(), null);\r\n    } else {\r\n        if (nodeRelevances == null) {\r\n            nodeRelevances = EconomicMap.create(Equivalence.IDENTITY, EXPECTED_MIN_INVOKE_COUNT + InliningUtil.getNodeCount(graph) / EXPECTED_INVOKE_RATIO);\r\n        }\r\n        NodeWorkList workList = graph.createNodeWorkList();\r\n        EconomicMap<LoopBeginNode, Scope> loops = EconomicMap.create(Equivalence.IDENTITY, EXPECTED_LOOP_COUNT);\r\n        Scope topScope = new Scope(graph.start(), null);\r\n        for (LoopBeginNode loopBegin : graph.getNodes(LoopBeginNode.TYPE)) {\r\n            createLoopScope(loopBegin, loops, topScope);\r\n        }\r\n        topScope.process(workList);\r\n        for (Scope scope : loops.getValues()) {\r\n            scope.process(workList);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.tregex.automaton.TransitionBuilder.getMatcherBuilder",
	"Comment": "represents the character set matched by this transition fragment.",
	"Method": "MatcherBuilder getMatcherBuilder(){\r\n    return matcherBuilder;\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.tregex.parser.flavors.PythonFlags.fixFlags",
	"Comment": "verifies that there is at most one type flag and that the type flag is compatible with thechosen regular expression mode. if a string pattern is used, ensures that the unicode flag isset by default.",
	"Method": "PythonFlags fixFlags(PythonREMode mode){\r\n    switch(mode) {\r\n        case Str:\r\n            if (hasFlag('L')) {\r\n                throw new RegexSyntaxException(\"cannot use LOCALE flag with a str pattern\");\r\n            }\r\n            if (hasFlag('a') && hasFlag('u')) {\r\n                throw new RegexSyntaxException(\"ASCII and UNICODE flags are incompatible\");\r\n            }\r\n            if (!hasFlag('a')) {\r\n                return addFlag('u');\r\n            } else {\r\n                return this;\r\n            }\r\n        case Bytes:\r\n            if (hasFlag('u')) {\r\n                throw new RegexSyntaxException(\"cannot use UNICODE flag with a bytes pattern\");\r\n            }\r\n            if (hasFlag('a') && hasFlag('L')) {\r\n                throw new RegexSyntaxException(\"ASCII and LOCALE flags are incompatible\");\r\n            }\r\n            return this;\r\n        default:\r\n            throw new IllegalStateException();\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.stubs.UnwindExceptionToCallerStub.preservesRegisters",
	"Comment": "the current frame is unwound by this stub. therefore, it does not need to save any registersas hotspot uses a caller save convention.",
	"Method": "boolean preservesRegisters(){\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.ea.PEAAssertionsTest.getDefaultHighTierContext",
	"Comment": "these tests assume all code paths are reachable so disable profile based dead code removal.",
	"Method": "HighTierContext getDefaultHighTierContext(){\r\n    return new HighTierContext(getProviders(), getDefaultGraphBuilderSuite(), OptimisticOptimizations.ALL.remove(Optimization.RemoveNeverExecutedCode));\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.HotSpotGraalOptionValues.asSystemPropertySetting",
	"Comment": "gets the system property assignment that would set the current value for a given option.",
	"Method": "String asSystemPropertySetting(OptionValues options,OptionKey<?> value){\r\n    return GRAAL_OPTION_PROPERTY_PREFIX + value.getName() + \"=\" + value.getValue(options);\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.lsra.LinearScan.maxRegisterNumber",
	"Comment": "gets the highest operand number for a register operand. this value will never change.",
	"Method": "int maxRegisterNumber(){\r\n    return firstVariableNumber - 1;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.NamedLocationIdentity.immutable",
	"Comment": "creates a named unique location identity for read operations against immutable memory.immutable memory will never have a visible write in the graph, which is more restrictive thanjava final.",
	"Method": "NamedLocationIdentity immutable(String name){\r\n    return create(name, true);\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.common.inlining.walker.ComputeInliningRelevance.computeFastPathMinProbability",
	"Comment": "computes the minimum probability along the most probable path within the scope. duringiteration, the method returns immediately once a loop exit is discovered.",
	"Method": "double computeFastPathMinProbability(FixedNode scopeStart){\r\n    ArrayList<FixedNode> pathBeginNodes = new ArrayList();\r\n    pathBeginNodes.add(scopeStart);\r\n    double minPathProbability = nodeProbabilities.applyAsDouble(scopeStart);\r\n    boolean isLoopScope = scopeStart instanceof LoopBeginNode;\r\n    do {\r\n        Node current = pathBeginNodes.remove(pathBeginNodes.size() - 1);\r\n        do {\r\n            if (isLoopScope && current instanceof LoopExitNode && ((LoopBeginNode) scopeStart).loopExits().contains((LoopExitNode) current)) {\r\n                return minPathProbability;\r\n            } else if (current instanceof LoopBeginNode && current != scopeStart) {\r\n                current = getMaxProbabilityLoopExit((LoopBeginNode) current, pathBeginNodes);\r\n                minPathProbability = getMinPathProbability((FixedNode) current, minPathProbability);\r\n            } else if (current instanceof ControlSplitNode) {\r\n                current = getMaxProbabilitySux((ControlSplitNode) current, pathBeginNodes);\r\n                minPathProbability = getMinPathProbability((FixedNode) current, minPathProbability);\r\n            } else {\r\n                assert current.successors().count() <= 1;\r\n                current = current.successors().first();\r\n            }\r\n        } while (current != null);\r\n    } while (!pathBeginNodes.isEmpty());\r\n    return minPathProbability;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin.getJavaSubstitute",
	"Comment": "gets the reflection api version of the substitution method.",
	"Method": "Method getJavaSubstitute(){\r\n    Method substituteMethod = lookupSubstitute();\r\n    int modifiers = substituteMethod.getModifiers();\r\n    if (Modifier.isAbstract(modifiers) || Modifier.isNative(modifiers)) {\r\n        throw new GraalError(\"Substitution method must not be abstract or native: \" + substituteMethod);\r\n    }\r\n    if (!Modifier.isStatic(modifiers)) {\r\n        throw new GraalError(\"Substitution method must be static: \" + substituteMethod);\r\n    }\r\n    return substituteMethod;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.lsra.Interval.alwaysInMemory",
	"Comment": "returns true if this interval has a shadow copy on the stack that is always correct",
	"Method": "boolean alwaysInMemory(){\r\n    return SpillState.ALWAYS_IN_MEMORY.contains(spillState()) && !canMaterialize();\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.aarch64.AArch64Assembler.isAimm",
	"Comment": "checks whether immediate can be encoded as an arithmetic immediate.",
	"Method": "boolean isAimm(int imm){\r\n    return NumUtil.isUnsignedNbit(12, imm) || NumUtil.isUnsignedNbit(12, imm >>> 12) && (imm & 0xfff) == 0;\r\n}"
}, {
	"Path": "org.graalvm.nativeimage.c.type.CTypeConversion.toCStrings",
	"Comment": "provides access to c pointers for the provided java strings, encoded with the defaultcharset.",
	"Method": "CCharPointerPointerHolder toCStrings(CharSequence[] javaStrings){\r\n    return new CCharPointerPointerHolder(javaStrings);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.amd64.AMD64LIRGenerator.emitCompareMemory",
	"Comment": "this method emits the compare against memory instruction, and may reorder the operands. itreturns true if it did so.",
	"Method": "boolean emitCompareMemory(AMD64Kind cmpKind,Value a,AMD64AddressValue b,LIRFrameState state){\r\n    OperandSize size;\r\n    switch(cmpKind) {\r\n        case BYTE:\r\n            size = OperandSize.BYTE;\r\n            break;\r\n        case WORD:\r\n            size = OperandSize.WORD;\r\n            break;\r\n        case DWORD:\r\n            size = OperandSize.DWORD;\r\n            break;\r\n        case QWORD:\r\n            size = OperandSize.QWORD;\r\n            break;\r\n        case SINGLE:\r\n            append(new AMD64BinaryConsumer.MemoryRMOp(SSEOp.UCOMIS, PS, asAllocatable(a), b, state));\r\n            return false;\r\n        case DOUBLE:\r\n            append(new AMD64BinaryConsumer.MemoryRMOp(SSEOp.UCOMIS, PD, asAllocatable(a), b, state));\r\n            return false;\r\n        default:\r\n            throw GraalError.shouldNotReachHere(\"unexpected kind: \" + cmpKind);\r\n    }\r\n    if (isConstantValue(a)) {\r\n        return emitCompareMemoryConOp(size, asConstantValue(a), b, state);\r\n    } else {\r\n        return emitCompareRegMemoryOp(size, asAllocatable(a), b, state);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.processor.AbstractProcessor.env",
	"Comment": "gets the processing environment available to this processor.",
	"Method": "ProcessingEnvironment env(){\r\n    return processingEnv;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.framemap.FrameMap.alignFrameSize",
	"Comment": "aligns the given frame size to the stack alignment size and return the aligned size.",
	"Method": "int alignFrameSize(int size){\r\n    return NumUtil.roundUp(size, getTarget().stackAlignment);\r\n}"
}, {
	"Path": "org.graalvm.collections.EconomicMapImpl.maybeCompress",
	"Comment": "compresses the graph if there is a large number of deleted entries and returns the translatednew next index.",
	"Method": "int maybeCompress(int nextIndex){\r\n    if (entries.length != INITIAL_CAPACITY << 1 && deletedEntries >= (totalEntries >> 1) + (totalEntries >> 2)) {\r\n        return compressLarge(nextIndex);\r\n    }\r\n    return nextIndex;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.util.GraphUtil.approxSourceStackTraceElement",
	"Comment": "gets approximate stack trace elements for a bytecode position.",
	"Method": "StackTraceElement[] approxSourceStackTraceElement(Node node,StackTraceElement[] approxSourceStackTraceElement,FrameState frameState,StackTraceElement[] approxSourceStackTraceElement,BytecodePosition bytecodePosition){\r\n    ArrayList<StackTraceElement> elements = new ArrayList();\r\n    BytecodePosition position = bytecodePosition;\r\n    while (position != null) {\r\n        ResolvedJavaMethod method = position.getMethod();\r\n        if (method != null) {\r\n            elements.add(method.asStackTraceElement(position.getBCI()));\r\n        }\r\n        position = position.getCaller();\r\n    }\r\n    return elements.toArray(new StackTraceElement[0]);\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.nodes.MethodHandleNode.getMemberName",
	"Comment": "get the membername argument of a methodhandle.linkto call.",
	"Method": "ValueNode getMemberName(ValueNode[] arguments){\r\n    return arguments[arguments.length - 1];\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.test.HotSpotCryptoSubstitutionTest.compileAndInstall",
	"Comment": "compiles and installs the substitution for some specified methods. once installed, the nextexecution of the methods will use the newly installed code.",
	"Method": "boolean compileAndInstall(String className,String methodNames){\r\n    if (!runtime().getVMConfig().useAESIntrinsics) {\r\n        return false;\r\n    }\r\n    Class<?> c;\r\n    try {\r\n        c = Class.forName(className);\r\n    } catch (ClassNotFoundException e) {\r\n        return false;\r\n    }\r\n    boolean atLeastOneCompiled = false;\r\n    for (String methodName : methodNames) {\r\n        if (compileAndInstallSubstitution(c, methodName) != null) {\r\n            atLeastOneCompiled = true;\r\n        }\r\n    }\r\n    return atLeastOneCompiled;\r\n}"
}, {
	"Path": "org.graalvm.compiler.jtt.hotspot.Test6959129.hailstoneLengthImp",
	"Comment": "imperative implementation that returns the length hailstone moves for a given number.",
	"Method": "long hailstoneLengthImp(long n2){\r\n    long n = n2;\r\n    long moves = 0;\r\n    while (n != 1) {\r\n        if (n <= 1) {\r\n            throw new IllegalStateException();\r\n        }\r\n        if (isEven(n)) {\r\n            n = n / 2;\r\n        } else {\r\n            n = 3 * n + 1;\r\n        }\r\n        ++moves;\r\n    }\r\n    return moves;\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.CompilerConfigurationFactory.getName",
	"Comment": "returns a name that should uniquely identify this compiler configuration.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.test.AArch64AddSubShiftTest.testAddShiftInt",
	"Comment": "check whether the addsubshift match rule in aarch64nodematchrules does work for add operationwith int type and check if the expected lir instructions show up.",
	"Method": "void testAddShiftInt(){\r\n    test(\"addShiftInt\", 123);\r\n    checkLIR(\"addShiftInt\", predicate, 6);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.PiNode.piCastNonNull",
	"Comment": "changes the stamp of an object to represent a given type and to indicate that the object isnot null.",
	"Method": "Object piCastNonNull(Object object,GuardingNode guard,Object piCastNonNull,Object object,Class<?> toType){\r\n    return piCast(object, toType, false, true);\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.gen.LIRGenerationResult.getCallingConvention",
	"Comment": "returns the incoming calling convention for the parameters of the method that is compiled.",
	"Method": "CallingConvention getCallingConvention(){\r\n    return callingConvention;\r\n}"
}, {
	"Path": "org.graalvm.compiler.java.FrameStateBuilder.storeLocal",
	"Comment": "stores a given local variable at the specified index. if the value occupies two slots, thenthe next local variable index is also overwritten.",
	"Method": "void storeLocal(int i,JavaKind slotKind,ValueNode x){\r\n    assert verifyKind(slotKind, x);\r\n    if (locals[i] == TWO_SLOT_MARKER) {\r\n        locals[i - 1] = null;\r\n    }\r\n    locals[i] = x;\r\n    if (slotKind.needsTwoSlots()) {\r\n        locals[i + 1] = TWO_SLOT_MARKER;\r\n    } else if (i < locals.length - 1 && locals[i + 1] == TWO_SLOT_MARKER) {\r\n        locals[i + 1] = null;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.GraphEncoder.verifyEncoding",
	"Comment": "verification code that checks that the decoding of an encode graph is the same as theoriginal graph.",
	"Method": "boolean verifyEncoding(StructuredGraph originalGraph,EncodedGraph encodedGraph,Architecture architecture){\r\n    DebugContext debug = originalGraph.getDebug();\r\n    StructuredGraph decodedGraph = new StructuredGraph.Builder(originalGraph.getOptions(), debug, AllowAssumptions.YES).method(originalGraph.method()).setIsSubstitution(originalGraph.isSubstitution()).trackNodeSourcePosition(originalGraph.trackNodeSourcePosition()).build();\r\n    GraphDecoder decoder = new GraphDecoder(architecture, decodedGraph);\r\n    decoder.decode(encodedGraph);\r\n    decodedGraph.verify();\r\n    try {\r\n        GraphComparison.verifyGraphsEqual(originalGraph, decodedGraph);\r\n    } catch (Throwable ex) {\r\n        originalGraph.getDebug();\r\n        try (DebugContext.Scope scope = debug.scope(\"GraphEncoder\")) {\r\n            debug.dump(DebugContext.VERBOSE_LEVEL, originalGraph, \"Original Graph\");\r\n            debug.dump(DebugContext.VERBOSE_LEVEL, decodedGraph, \"Decoded Graph\");\r\n        }\r\n        throw ex;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.processor.MethodSubstitutionHandler.isSubtype",
	"Comment": "tests whether one type is a subtype of another. any type is considered to be a subtype ofitself.",
	"Method": "boolean isSubtype(TypeMirror t1,TypeMirror t2){\r\n    TypeMirror t1Erased = t1;\r\n    TypeMirror t2Erased = t2;\r\n    if (needsErasure(t1Erased)) {\r\n        t1Erased = processor.env().getTypeUtils().erasure(t1Erased);\r\n    }\r\n    if (needsErasure(t2Erased)) {\r\n        t2Erased = processor.env().getTypeUtils().erasure(t2Erased);\r\n    }\r\n    return processor.env().getTypeUtils().isSubtype(t1Erased, t2Erased);\r\n}"
}, {
	"Path": "org.graalvm.compiler.bytecode.Bytecodes.isLoad",
	"Comment": "determines if a given opcode denotes an instruction that loads a local variable to theoperand stack.",
	"Method": "boolean isLoad(int opcode){\r\n    return (flagsArray[opcode & 0xff] & LOAD) != 0;\r\n}"
}, {
	"Path": "org.graalvm.compiler.options.OptionKey.checkDescriptorExists",
	"Comment": "checks that a descriptor exists for this key after triggering loading of descriptors.",
	"Method": "boolean checkDescriptorExists(){\r\n    OptionKey.Lazy.init();\r\n    if (descriptor == null) {\r\n        Formatter buf = new Formatter();\r\n        buf.format(\"Could not find a descriptor for an option key. The most likely cause is \" + \"a dependency on the %s annotation without a dependency on the \" + \"org.graalvm.compiler.options.processor.OptionProcessor annotation processor.\", Option.class.getName());\r\n        StackTraceElement[] stackTrace = new Exception().getStackTrace();\r\n        if (stackTrace.length > 2 && stackTrace[1].getClassName().equals(OptionKey.class.getName()) && stackTrace[1].getMethodName().equals(\"getValue\")) {\r\n            String caller = stackTrace[2].getClassName();\r\n            buf.format(\" In suite.py, add GRAAL_OPTIONS_PROCESSOR to the \\\"annotationProcessors\\\" attribute of the project \" + \"containing %s.\", caller);\r\n        }\r\n        throw new AssertionError(buf.toString());\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.graphio.GraphOutput.close",
	"Comment": "closes the output. closes allocated resources and associated output channel.",
	"Method": "void close(){\r\n    printer.close();\r\n}"
}, {
	"Path": "org.graalvm.polyglot.Context.initialize",
	"Comment": "forces the initialization of a language. it is not necessary to explicitly initialize alanguage, it will be initialized the first time it is used.",
	"Method": "boolean initialize(String languageId){\r\n    return impl.initializeLanguage(languageId);\r\n}"
}, {
	"Path": "org.graalvm.polyglot.PolyglotException.getGuestObject",
	"Comment": "returns an additional guest language object. returns null if no exception objectis available.",
	"Method": "Value getGuestObject(){\r\n    return impl.getGuestObject();\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.runtime.hotspot.HotSpotOptimizedCallTarget.setInstalledCode",
	"Comment": "this method may only be called during compilation, and only by the compiling thread.",
	"Method": "void setInstalledCode(InstalledCode code){\r\n    if (installedCode == code) {\r\n        return;\r\n    }\r\n    invalidateCode();\r\n    if (code instanceof HotSpotNmethod) {\r\n        HotSpotNmethod nmethod = (HotSpotNmethod) code;\r\n        if (nmethod.isDefault()) {\r\n            throw new IllegalArgumentException(\"Cannot install a default nmethod for a \" + getClass().getSimpleName());\r\n        }\r\n    }\r\n    installedCode = code;\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.sparc.SPARCHotSpotBackend.registerSizePredictionValidator",
	"Comment": "registers a verifier which checks if the lirinstructions estimate of constants size isgreater or equal to the actual one.",
	"Method": "boolean registerSizePredictionValidator(CompilationResultBuilder crb,DebugContext debug){\r\n    class ValidationState {\r\n        LIRInstruction op;\r\n        final DebugContext debug;\r\n        int constantSizeBefore;\r\n        ValidationState(DebugContext debug) {\r\n            this.debug = debug;\r\n        }\r\n        public void before(LIRInstruction before) {\r\n            assert op == null : \"LIRInstruction \" + op + \" no after call received\";\r\n            op = before;\r\n            constantSizeBefore = calculateDataSectionSize(crb.compilationResult.getDataSection());\r\n        }\r\n        public void after(LIRInstruction after) {\r\n            assert after.equals(op) : \"Instructions before/after don't match \" + op + \"/\" + after;\r\n            int constantSizeAfter = calculateDataSectionSize(crb.compilationResult.getDataSection());\r\n            int actual = constantSizeAfter - constantSizeBefore;\r\n            if (op instanceof SPARCLIRInstructionMixin) {\r\n                org.graalvm.compiler.lir.sparc.SPARCLIRInstructionMixin.SizeEstimate size = ((SPARCLIRInstructionMixin) op).estimateSize();\r\n                assert size != null : \"No size prediction available for op: \" + op;\r\n                Class<?> c = op.getClass();\r\n                CONSTANT_ESTIMATED_STATS.add(c, size.constantSize, debug);\r\n                CONSTANT_ACTUAL_STATS.add(c, actual, debug);\r\n                assert size.constantSize >= actual : \"Op \" + op + \" exceeded estimated constant size; predicted: \" + size.constantSize + \" actual: \" + actual;\r\n            } else {\r\n                assert actual == 0 : \"Op \" + op + \" emitted to DataSection without any estimate.\";\r\n            }\r\n            op = null;\r\n            constantSizeBefore = 0;\r\n        }\r\n    }\r\n    final ValidationState state = new ValidationState(debug);\r\n    crb.setOpCallback(op -> state.before(op), op -> state.after(op));\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.sparc.SPARCHotSpotBackend.registerSizePredictionValidator",
	"Comment": "registers a verifier which checks if the lirinstructions estimate of constants size isgreater or equal to the actual one.",
	"Method": "boolean registerSizePredictionValidator(CompilationResultBuilder crb,DebugContext debug){\r\n    assert op == null : \"LIRInstruction \" + op + \" no after call received\";\r\n    op = before;\r\n    constantSizeBefore = calculateDataSectionSize(crb.compilationResult.getDataSection());\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.sparc.SPARCHotSpotBackend.registerSizePredictionValidator",
	"Comment": "registers a verifier which checks if the lirinstructions estimate of constants size isgreater or equal to the actual one.",
	"Method": "boolean registerSizePredictionValidator(CompilationResultBuilder crb,DebugContext debug){\r\n    assert after.equals(op) : \"Instructions before/after don't match \" + op + \"/\" + after;\r\n    int constantSizeAfter = calculateDataSectionSize(crb.compilationResult.getDataSection());\r\n    int actual = constantSizeAfter - constantSizeBefore;\r\n    if (op instanceof SPARCLIRInstructionMixin) {\r\n        org.graalvm.compiler.lir.sparc.SPARCLIRInstructionMixin.SizeEstimate size = ((SPARCLIRInstructionMixin) op).estimateSize();\r\n        assert size != null : \"No size prediction available for op: \" + op;\r\n        Class<?> c = op.getClass();\r\n        CONSTANT_ESTIMATED_STATS.add(c, size.constantSize, debug);\r\n        CONSTANT_ACTUAL_STATS.add(c, actual, debug);\r\n        assert size.constantSize >= actual : \"Op \" + op + \" exceeded estimated constant size; predicted: \" + size.constantSize + \" actual: \" + actual;\r\n    } else {\r\n        assert actual == 0 : \"Op \" + op + \" emitted to DataSection without any estimate.\";\r\n    }\r\n    op = null;\r\n    constantSizeBefore = 0;\r\n}"
}, {
	"Path": "org.graalvm.compiler.virtual.phases.ea.PartialEscapeClosure.prepareCanonicalNode",
	"Comment": "nodes created during canonicalizations need to be scanned for values that were replaced.",
	"Method": "boolean prepareCanonicalNode(ValueNode node,BlockT state,GraphEffectList effects){\r\n    assert !node.isAlive();\r\n    for (Position pos : node.inputPositions()) {\r\n        Node input = pos.get(node);\r\n        if (input instanceof ValueNode) {\r\n            if (input.isAlive()) {\r\n                if (!(input instanceof VirtualObjectNode)) {\r\n                    ObjectState obj = getObjectState(state, (ValueNode) input);\r\n                    if (obj != null) {\r\n                        if (obj.isVirtual()) {\r\n                            return false;\r\n                        } else {\r\n                            pos.initialize(node, obj.getMaterializedValue());\r\n                        }\r\n                    } else {\r\n                        pos.initialize(node, getScalarAlias((ValueNode) input));\r\n                    }\r\n                }\r\n            } else {\r\n                if (!prepareCanonicalNode((ValueNode) input, state, effects)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.test.OptimizedOSRLoopNodeTest.testNoInvalidationWithoutFirstExecution",
	"Comment": "test that if osr compilation is forced without any execution we do not deoptimize on firstexecution.",
	"Method": "void testNoInvalidationWithoutFirstExecution(OSRLoopFactory factory){\r\n    TestRootNode rootNode = new TestRootNode(factory, new TestRepeatingNode());\r\n    RootCallTarget target = runtime.createCallTarget(rootNode);\r\n    rootNode.forceOSR();\r\n    assertCompiled(rootNode.getOSRTarget());\r\n    target.call(1);\r\n    assertCompiled(rootNode.getOSRTarget());\r\n    Assert.assertTrue(rootNode.wasRepeatingCalledCompiled());\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.lsra.MoveResolver.unblockRegisters",
	"Comment": "mark assignedreg and assignedreghi of the interval as unblocked",
	"Method": "void unblockRegisters(Interval interval){\r\n    Value location = interval.location();\r\n    if (mightBeBlocked(location)) {\r\n        assert valueBlocked(location) > 0 : \"location already marked as unused: \" + location;\r\n        setValueBlocked(location, -1);\r\n        allocator.getDebug().log(\"unblock %s\", location);\r\n    }\r\n}"
}, {
	"Path": "jdk.tools.jaotc.binformat.BinaryContainer.addSymbol",
	"Comment": "add symbol to the symbol table. if the existing symbol is undefined and the specified symbolis not undefined, replace the existing symbol information with that specified.",
	"Method": "void addSymbol(Symbol symInfo){\r\n    if (symInfo.getName().startsWith(\"got.\") && !(symInfo instanceof GotSymbol)) {\r\n        throw new InternalError(\"adding got. without being GotSymbol\");\r\n    }\r\n    if (symbolTable.containsKey(symInfo.getName())) {\r\n        throw new InternalError(\"Symbol: \" + symInfo.getName() + \" already exists in SymbolTable\");\r\n    } else {\r\n        symbolTable.put(symInfo.getName(), symInfo);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.match.processor.MatchProcessor.fullClassName",
	"Comment": "strip the package off a class name leaving the full class name including any outer classes.",
	"Method": "String fullClassName(Element element){\r\n    assert element.getKind() == ElementKind.CLASS || element.getKind() == ElementKind.INTERFACE : element;\r\n    String pkg = findPackage(element);\r\n    return ((TypeElement) element).getQualifiedName().toString().substring(pkg.length() + 1);\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.aarch64.AArch64HotSpotBackend.emitInvalidatePlaceholder",
	"Comment": "insert a nop at the start of the prolog so we can patch in a branch if we need to invalidatethe method later.",
	"Method": "void emitInvalidatePlaceholder(CompilationResultBuilder crb,AArch64MacroAssembler masm){\r\n    if (!GeneratePIC.getValue(crb.getOptions())) {\r\n        crb.blockComment(\"[nop for method invalidation]\");\r\n        masm.nop();\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.aarch64.AArch64HotSpotLIRGenerator.emitSaveAllRegisters",
	"Comment": "adds a node to the graph that saves all allocatable registers to the stack.",
	"Method": "AArch64SaveRegistersOp emitSaveAllRegisters(Register[] savedRegisters,boolean supportsRemove){\r\n    AllocatableValue[] savedRegisterLocations = new AllocatableValue[savedRegisters.length];\r\n    for (int i = 0; i < savedRegisters.length; i++) {\r\n        savedRegisterLocations[i] = allocateSaveRegisterLocation(savedRegisters[i]);\r\n    }\r\n    return emitSaveRegisters(savedRegisters, savedRegisterLocations, supportsRemove);\r\n}"
}, {
	"Path": "jdk.tools.jaotc.binformat.ByteContainer.putIntAt",
	"Comment": "modify the byte buffer version of the byte output stream. note that after calling this methodall further updates to binarycontainer will be out of sync with byte buffer content.",
	"Method": "void putIntAt(int index,int value){\r\n    if (!bufferModified) {\r\n        updateByteBuffer();\r\n    }\r\n    contentBytes.putInt(index, value);\r\n    bufferModified = true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.serviceprovider.GraalServices.getGlobalTimeStamp",
	"Comment": "gets a time stamp for the current process. this method will always return the same value forthe current vm execution.",
	"Method": "long getGlobalTimeStamp(){\r\n    if (globalTimeStamp.get() == 0) {\r\n        globalTimeStamp.compareAndSet(0, System.currentTimeMillis());\r\n    }\r\n    return globalTimeStamp.get();\r\n}"
}, {
	"Path": "org.graalvm.nativeimage.c.type.CTypeConversion.toBoolean",
	"Comment": "converts a c int containing boolean values into a java boolean.",
	"Method": "boolean toBoolean(int value,boolean toBoolean,PointerBase pointer){\r\n    return pointer.isNonNull();\r\n}"
}, {
	"Path": "jdk.tools.jaotc.CompilationSpec.shouldCompileMethod",
	"Comment": "check if a given method is part of a restrictive compilation.",
	"Method": "boolean shouldCompileMethod(ResolvedJavaMethod method){\r\n    if (compileWithRestrictions()) {\r\n        boolean compileMethod = compileOnlyStrings.isEmpty() && compileOnlyPatterns.isEmpty();\r\n        String methodName = JavaMethodInfo.uniqueMethodName(method);\r\n        if (!compileMethod) {\r\n            compileMethod = compileOnlyStrings.contains(methodName);\r\n        }\r\n        if (!compileMethod) {\r\n            Iterator<Pattern> it = compileOnlyPatterns.iterator();\r\n            while (!compileMethod && it.hasNext()) {\r\n                Pattern pattern = it.next();\r\n                compileMethod = pattern.matcher(methodName).matches();\r\n            }\r\n        }\r\n        if (compileMethod) {\r\n            compileMethod = !excludeStrings.contains(methodName);\r\n        }\r\n        if (compileMethod) {\r\n            Iterator<Pattern> it = excludePatterns.iterator();\r\n            while (compileMethod && it.hasNext()) {\r\n                Pattern pattern = it.next();\r\n                compileMethod = !(pattern.matcher(methodName).matches());\r\n            }\r\n        }\r\n        return compileMethod;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.code.CompilationResult.getTotalFrameSize",
	"Comment": "the total frame size of the method in bytes. this includes the return address pushed onto thestack, if any.",
	"Method": "int getTotalFrameSize(){\r\n    assert totalFrameSize != -1 : \"frame size not yet initialized!\";\r\n    return totalFrameSize;\r\n}"
}, {
	"Path": "org.graalvm.compiler.code.CompilationResult.setTotalFrameSize",
	"Comment": "sets the total frame size in bytes. this includes the return address pushed onto the stack,if any.",
	"Method": "void setTotalFrameSize(int size){\r\n    checkOpen();\r\n    totalFrameSize = size;\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.getAndClearObjectResult",
	"Comment": "gets and clears the object result from a runtime call stored in a thread local.",
	"Method": "Object getAndClearObjectResult(Word thread){\r\n    Object result = thread.readObject(objectResultOffset(INJECTED_VMCONFIG), OBJECT_RESULT_LOCATION);\r\n    thread.writeObject(objectResultOffset(INJECTED_VMCONFIG), null, OBJECT_RESULT_LOCATION);\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.amd64.AMD64LIRGenerator.emitCompare",
	"Comment": "this method emits the compare instruction, and may reorder the operands. it returns true ifit did so.",
	"Method": "Condition emitCompare(PlatformKind cmpKind,Value a,Value b,Condition cond){\r\n    if (LIRValueUtil.isVariable(b)) {\r\n        emitRawCompare(cmpKind, b, a);\r\n        return cond.mirror();\r\n    } else {\r\n        emitRawCompare(cmpKind, a, b);\r\n        return cond;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.util.GraphUtil.approxSourceException",
	"Comment": "gets an approximate source code location for a node, encoded as an exception, if possible.",
	"Method": "RuntimeException approxSourceException(Node node,Throwable cause){\r\n    final StackTraceElement[] elements = approxSourceStackTraceElement(node);\r\n    return createBailoutException(cause == null ? \"\" : cause.getMessage(), cause, elements);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.type.StampFactory.forKind",
	"Comment": "return a stamp for a java kind, as it would be represented on the bytecode stack.",
	"Method": "Stamp forKind(JavaKind kind){\r\n    assert stampCache[kind.ordinal()] != null : \"unexpected forKind(\" + kind + \")\";\r\n    return stampCache[kind.ordinal()];\r\n}"
}, {
	"Path": "org.graalvm.compiler.loop.LoopFragmentInside.insertWithinAfter",
	"Comment": "duplicate the body within the loop after the current copy copy of the body, updating theiteration limit to account for the duplication.",
	"Method": "void insertWithinAfter(LoopEx loop,EconomicMap<LoopBeginNode, OpaqueNode> opaqueUnrolledStrides){\r\n    assert isDuplicate() && original().loop() == loop;\r\n    patchNodes(dataFixWithinAfter);\r\n    LoopBeginNode mainLoopBegin = loop.loopBegin();\r\n    ArrayList<ValueNode> backedgeValues = new ArrayList();\r\n    for (PhiNode mainPhiNode : mainLoopBegin.phis()) {\r\n        ValueNode duplicatedNode = getDuplicatedNode(mainPhiNode.valueAt(1));\r\n        if (duplicatedNode == null) {\r\n            if (mainLoopBegin.isPhiAtMerge(mainPhiNode.valueAt(1))) {\r\n                duplicatedNode = ((PhiNode) (mainPhiNode.valueAt(1))).valueAt(1);\r\n            } else {\r\n                assert mainPhiNode.valueAt(1).isConstant() : mainPhiNode.valueAt(1);\r\n            }\r\n        }\r\n        backedgeValues.add(duplicatedNode);\r\n    }\r\n    int index = 0;\r\n    for (PhiNode mainPhiNode : mainLoopBegin.phis()) {\r\n        ValueNode duplicatedNode = backedgeValues.get(index++);\r\n        if (duplicatedNode != null) {\r\n            mainPhiNode.setValueAt(1, duplicatedNode);\r\n        }\r\n    }\r\n    placeNewSegmentAndCleanup(loop);\r\n    assert loop.whole().nodes().filter(SafepointNode.class).count() == nodes().filter(SafepointNode.class).count();\r\n    for (SafepointNode safepoint : loop.whole().nodes().filter(SafepointNode.class)) {\r\n        graph().removeFixed(safepoint);\r\n    }\r\n    StructuredGraph graph = mainLoopBegin.graph();\r\n    if (opaqueUnrolledStrides != null) {\r\n        OpaqueNode opaque = opaqueUnrolledStrides.get(loop.loopBegin());\r\n        CountedLoopInfo counted = loop.counted();\r\n        ValueNode counterStride = counted.getCounter().strideNode();\r\n        if (opaque == null) {\r\n            opaque = new OpaqueNode(AddNode.add(counterStride, counterStride, NodeView.DEFAULT));\r\n            ValueNode limit = counted.getLimit();\r\n            int bits = ((IntegerStamp) limit.stamp(NodeView.DEFAULT)).getBits();\r\n            ValueNode newLimit = SubNode.create(limit, opaque, NodeView.DEFAULT);\r\n            LogicNode overflowCheck;\r\n            ConstantNode extremum;\r\n            if (counted.getDirection() == InductionVariable.Direction.Up) {\r\n                extremum = ConstantNode.forIntegerBits(bits, CodeUtil.minValue(bits));\r\n                overflowCheck = IntegerBelowNode.create(SubNode.create(limit, extremum, NodeView.DEFAULT), opaque, NodeView.DEFAULT);\r\n            } else {\r\n                assert counted.getDirection() == InductionVariable.Direction.Down;\r\n                extremum = ConstantNode.forIntegerBits(bits, CodeUtil.maxValue(bits));\r\n                overflowCheck = IntegerBelowNode.create(opaque, SubNode.create(limit, extremum, NodeView.DEFAULT), NodeView.DEFAULT);\r\n            }\r\n            newLimit = ConditionalNode.create(overflowCheck, extremum, newLimit, NodeView.DEFAULT);\r\n            CompareNode compareNode = (CompareNode) counted.getLimitTest().condition();\r\n            compareNode.replaceFirstInput(limit, graph.addOrUniqueWithInputs(newLimit));\r\n            opaqueUnrolledStrides.put(loop.loopBegin(), opaque);\r\n        } else {\r\n            assert counted.getCounter().isConstantStride();\r\n            assert Math.addExact(counted.getCounter().constantStride(), counted.getCounter().constantStride()) == counted.getCounter().constantStride() * 2;\r\n            ValueNode previousValue = opaque.getValue();\r\n            opaque.setValue(graph.addOrUniqueWithInputs(AddNode.add(counterStride, previousValue, NodeView.DEFAULT)));\r\n            GraphUtil.tryKillUnused(previousValue);\r\n        }\r\n    }\r\n    mainLoopBegin.setUnrollFactor(mainLoopBegin.getUnrollFactor() * 2);\r\n    mainLoopBegin.setLoopFrequency(mainLoopBegin.loopFrequency() / 2);\r\n    graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, \"LoopPartialUnroll %s\", loop);\r\n    mainLoopBegin.getDebug().dump(DebugContext.VERBOSE_LEVEL, mainLoopBegin.graph(), \"After insertWithinAfter %s\", mainLoopBegin);\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.test.ReplacementsParseTest.test1",
	"Comment": "ensure that calling the original method from the substitution binds correctly.",
	"Method": "void test1(){\r\n    test(\"test1Snippet\", 1.0);\r\n}"
}, {
	"Path": "org.graalvm.compiler.asm.aarch64.AArch64Assembler.ldxr",
	"Comment": "load address exclusive. natural alignment of address is required.",
	"Method": "void ldxr(int size,Register rt,Register rn){\r\n    assert size == 8 || size == 16 || size == 32 || size == 64;\r\n    int transferSize = NumUtil.log2Ceil(size / 8);\r\n    exclusiveLoadInstruction(LDXR, rt, rn, transferSize);\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.IfNode.checkForUnsignedCompare",
	"Comment": "recognize a couple patterns that can be merged into an unsigned compare.",
	"Method": "boolean checkForUnsignedCompare(SimplifierTool tool){\r\n    assert trueSuccessor().hasNoUsages() && falseSuccessor().hasNoUsages();\r\n    if (condition() instanceof IntegerLessThanNode) {\r\n        NodeView view = NodeView.from(tool);\r\n        IntegerLessThanNode lessThan = (IntegerLessThanNode) condition();\r\n        Constant y = lessThan.getY().stamp(view).asConstant();\r\n        if (y instanceof PrimitiveConstant && ((PrimitiveConstant) y).asLong() == 0 && falseSuccessor().next() instanceof IfNode) {\r\n            IfNode ifNode2 = (IfNode) falseSuccessor().next();\r\n            if (ifNode2.condition() instanceof IntegerLessThanNode) {\r\n                IntegerLessThanNode lessThan2 = (IntegerLessThanNode) ifNode2.condition();\r\n                AbstractBeginNode falseSucc = ifNode2.falseSuccessor();\r\n                AbstractBeginNode trueSucc = ifNode2.trueSuccessor();\r\n                IntegerBelowNode below = null;\r\n                if (lessThan2.getX() == lessThan.getX() && lessThan2.getY().stamp(view) instanceof IntegerStamp && ((IntegerStamp) lessThan2.getY().stamp(view)).isPositive() && sameDestination(trueSuccessor(), ifNode2.falseSuccessor)) {\r\n                    below = graph().unique(new IntegerBelowNode(lessThan2.getX(), lessThan2.getY()));\r\n                    AbstractBeginNode tmp = falseSucc;\r\n                    falseSucc = trueSucc;\r\n                    trueSucc = tmp;\r\n                } else if (lessThan2.getY() == lessThan.getX() && sameDestination(trueSuccessor(), ifNode2.trueSuccessor)) {\r\n                    JavaConstant positive = lessThan2.getX().asJavaConstant();\r\n                    if (positive != null && positive.asLong() > 0 && positive.asLong() < positive.getJavaKind().getMaxValue()) {\r\n                        ConstantNode newLimit = ConstantNode.forIntegerStamp(lessThan2.getX().stamp(view), positive.asLong() + 1, graph());\r\n                        below = graph().unique(new IntegerBelowNode(lessThan.getX(), newLimit));\r\n                    }\r\n                }\r\n                if (below != null) {\r\n                    try (DebugCloseable position = ifNode2.withNodeSourcePosition()) {\r\n                        ifNode2.setTrueSuccessor(null);\r\n                        ifNode2.setFalseSuccessor(null);\r\n                        IfNode newIfNode = graph().add(new IfNode(below, falseSucc, trueSucc, 1 - trueSuccessorProbability));\r\n                        tool.deleteBranch(trueSuccessor);\r\n                        graph().removeSplit(this, falseSuccessor);\r\n                        ifNode2.predecessor().replaceFirstSuccessor(ifNode2, newIfNode);\r\n                        ifNode2.safeDelete();\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.compiler.replacements.test.ReplacementsParseTest.test2",
	"Comment": "ensure that calling the substitution method binds to the original method properly.",
	"Method": "void test2(){\r\n    test(\"test2Snippet\", 1.0);\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.stubs.ExceptionHandlerStub.assertionsEnabled",
	"Comment": "determines if either java assertions are enabled for graal or if this is a hotspot buildwhere the assert mechanism is enabled.",
	"Method": "boolean assertionsEnabled(GraalHotSpotVMConfig config){\r\n    return Assertions.assertionsEnabled() || cAssertionsEnabled(config);\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.asm.CompilationResultBuilder.asLongConstRef",
	"Comment": "returns the address of a long constant that is embedded as a data reference into the code.",
	"Method": "AbstractAddress asLongConstRef(JavaConstant value){\r\n    assert value.getJavaKind() == JavaKind.Long;\r\n    return recordDataReferenceInCode(value, 8);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.util.Util.uncheckedCast",
	"Comment": "statically cast an object to an arbitrary object type. dynamically checked.",
	"Method": "T uncheckedCast(Class<T> type,Object object,T uncheckedCast,Object object){\r\n    return (T) object;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.test.GraalCompilerTest.checkMidTierGraph",
	"Comment": "can be overridden by unit tests to verify properties of the graph.",
	"Method": "boolean checkMidTierGraph(StructuredGraph graph){\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.compiler.loop.LoopEx.findInductionVariables",
	"Comment": "collect all the basic induction variables for the loop and the find any induction variableswhich are derived from the basic ones.",
	"Method": "EconomicMap<Node, InductionVariable> findInductionVariables(LoopEx loop){\r\n    EconomicMap<Node, InductionVariable> ivs = EconomicMap.create(Equivalence.IDENTITY);\r\n    Queue<InductionVariable> scanQueue = new LinkedList();\r\n    LoopBeginNode loopBegin = loop.loopBegin();\r\n    AbstractEndNode forwardEnd = loopBegin.forwardEnd();\r\n    for (PhiNode phi : loopBegin.valuePhis()) {\r\n        ValueNode backValue = phi.singleBackValueOrThis();\r\n        if (backValue == phi) {\r\n            continue;\r\n        }\r\n        ValueNode stride = addSub(loop, backValue, phi);\r\n        if (stride != null) {\r\n            BasicInductionVariable biv = new BasicInductionVariable(loop, (ValuePhiNode) phi, phi.valueAt(forwardEnd), stride, (BinaryArithmeticNode<?>) backValue);\r\n            ivs.put(phi, biv);\r\n            scanQueue.add(biv);\r\n        }\r\n    }\r\n    while (!scanQueue.isEmpty()) {\r\n        InductionVariable baseIv = scanQueue.remove();\r\n        ValueNode baseIvNode = baseIv.valueNode();\r\n        for (ValueNode op : baseIvNode.usages().filter(ValueNode.class)) {\r\n            if (loop.isOutsideLoop(op)) {\r\n                continue;\r\n            }\r\n            if (op.usages().count() == 1 && op.usages().first() == baseIvNode) {\r\n                continue;\r\n            }\r\n            InductionVariable iv = null;\r\n            ValueNode offset = addSub(loop, op, baseIvNode);\r\n            ValueNode scale;\r\n            if (offset != null) {\r\n                iv = new DerivedOffsetInductionVariable(loop, baseIv, offset, (BinaryArithmeticNode<?>) op);\r\n            } else if (op instanceof NegateNode) {\r\n                iv = new DerivedScaledInductionVariable(loop, baseIv, (NegateNode) op);\r\n            } else if ((scale = mul(loop, op, baseIvNode)) != null) {\r\n                iv = new DerivedScaledInductionVariable(loop, baseIv, scale, op);\r\n            } else {\r\n                boolean isValidConvert = op instanceof PiNode || op instanceof SignExtendNode;\r\n                if (!isValidConvert && op instanceof ZeroExtendNode) {\r\n                    ZeroExtendNode zeroExtendNode = (ZeroExtendNode) op;\r\n                    isValidConvert = zeroExtendNode.isInputAlwaysPositive() || ((IntegerStamp) zeroExtendNode.stamp(NodeView.DEFAULT)).isPositive();\r\n                }\r\n                if (isValidConvert) {\r\n                    iv = new DerivedConvertedInductionVariable(loop, baseIv, op.stamp(NodeView.DEFAULT), op);\r\n                }\r\n            }\r\n            if (iv != null) {\r\n                ivs.put(op, iv);\r\n                scanQueue.offer(iv);\r\n            }\r\n        }\r\n    }\r\n    return ivs;\r\n}"
}, {
	"Path": "org.graalvm.polyglot.Language.getDefaultMimeType",
	"Comment": "returns the default mime type that is in use by a language. the default mime type specifieswhether a source is loaded as character or binary based source by default. returnsnull if the language does not specify a default mime type.",
	"Method": "String getDefaultMimeType(){\r\n    return impl.getDefaultMimeType();\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.alloc.trace.bu.BottomUpAllocator.allocateSpillSlot",
	"Comment": "returns a new spill slot or a cached entry if there is already one for the variable.",
	"Method": "AllocatableValue allocateSpillSlot(Variable var){\r\n    int variableIndex = var.index;\r\n    AllocatableValue cachedStackSlot = stackSlots[variableIndex];\r\n    if (cachedStackSlot != null) {\r\n        TraceRegisterAllocationPhase.globalStackSlots.increment(debug);\r\n        assert cachedStackSlot.getValueKind().equals(var.getValueKind()) : \"CachedStackSlot: kind mismatch? \" + var.getValueKind() + \" vs. \" + cachedStackSlot.getValueKind();\r\n        return cachedStackSlot;\r\n    }\r\n    VirtualStackSlot slot = lirGenRes.getFrameMapBuilder().allocateSpillSlot(var.getValueKind());\r\n    stackSlots[variableIndex] = slot;\r\n    TraceRegisterAllocationPhase.allocatedStackSlots.increment(debug);\r\n    return slot;\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.HotSpotCounterOp.patchCounterIncrement",
	"Comment": "patches the increment value in the instruction emitted by this instruction. use only, ifpatching is needed after assembly.",
	"Method": "void patchCounterIncrement(Assembler asm,int[] increment){\r\n    throw GraalError.unimplemented();\r\n}"
}, {
	"Path": "org.graalvm.compiler.java.BytecodeParser.needsExplicitStoreCheckException",
	"Comment": "returns true if an explicit null check should be emitted for the given object.",
	"Method": "boolean needsExplicitStoreCheckException(ValueNode array,ValueNode value){\r\n    return needsExplicitException();\r\n}"
}, {
	"Path": "org.graalvm.compiler.java.BciBlockMapping.build",
	"Comment": "builds the block map and conservative cfg and numbers blocks.",
	"Method": "void build(BytecodeStream stream,OptionValues options){\r\n    int codeSize = code.getCodeSize();\r\n    BciBlock[] blockMap = new BciBlock[codeSize];\r\n    makeExceptionEntries(blockMap);\r\n    iterateOverBytecodes(blockMap, stream);\r\n    if (hasJsrBytecodes) {\r\n        if (!SupportJsrBytecodes.getValue(options)) {\r\n            throw new JsrNotSupportedBailout(\"jsr/ret parsing disabled\");\r\n        }\r\n        createJsrAlternatives(blockMap, blockMap[0]);\r\n    }\r\n    if (debug.isLogEnabled()) {\r\n        this.log(blockMap, \"Before BlockOrder\");\r\n    }\r\n    computeBlockOrder(blockMap);\r\n    fixLoopBits(blockMap);\r\n    assert verify();\r\n    startBlock = blockMap[0];\r\n    if (debug.isLogEnabled()) {\r\n        this.log(blockMap, \"Before LivenessAnalysis\");\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayAllocationSize",
	"Comment": "computes the size of the memory chunk allocated for an array. this size accounts for thearray header size, body size and any padding after the last element to satisfy objectalignment requirements.",
	"Method": "int arrayAllocationSize(int length,int headerSize,int log2ElementSize,int arrayAllocationSize,int length,int headerSize,int log2ElementSize,GraalHotSpotVMConfig config){\r\n    int alignment = config.objectAlignment;\r\n    int size = (length << log2ElementSize) + headerSize + (alignment - 1);\r\n    int mask = ~(alignment - 1);\r\n    return size & mask;\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.StructuredGraph.getMethods",
	"Comment": "gets an unmodifiable view of the methods that were inlined while constructing this graph.",
	"Method": "List<ResolvedJavaMethod> getMethods(){\r\n    if (methods != null) {\r\n        assert checkFrameStatesAgainstInlinedMethods();\r\n        return Collections.unmodifiableList(methods);\r\n    }\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.FrameState.monitorIdAt",
	"Comment": "get the monitoridnode that corresponds to the locked object at the specified index.",
	"Method": "MonitorIdNode monitorIdAt(int i){\r\n    assert monitorIds != null && i >= 0 && i < locksSize();\r\n    return monitorIds.get(i);\r\n}"
}, {
	"Path": "org.graalvm.compiler.graph.Edges.initializeNode",
	"Comment": "sets the value of a given edge without notifying the new and old nodes on the other end ofthe edge of the change.",
	"Method": "void initializeNode(Node node,int index,Node value){\r\n    verifyUpdateValid(node, index, value);\r\n    putNodeUnsafe(node, offsets[index], value);\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.PhaseSuite.addBeforeLast",
	"Comment": "inserts a phase before the last phase in the suite. if the suite contains no phases the newphase will be inserted as the first phase.",
	"Method": "void addBeforeLast(BasePhase<? super C> phase){\r\n    ListIterator<BasePhase<? super C>> last = findLastPhase();\r\n    if (last.hasPrevious()) {\r\n        last.previous();\r\n    }\r\n    last.add(phase);\r\n}"
}, {
	"Path": "org.graalvm.polyglot.Engine.create",
	"Comment": "creates a new engine instance with default configuration. the engine is constructed with thesame configuration as it will be as when constructed implicitly using the context builder.",
	"Method": "Engine create(){\r\n    return newBuilder().build();\r\n}"
}, {
	"Path": "org.graalvm.compiler.bytecode.BytecodeStream.readLocalIndex",
	"Comment": "reads the index of a local variable for one of the load or store instructions. the widemodifier is handled internally.",
	"Method": "int readLocalIndex(){\r\n    if (opcode == Bytecodes.WIDE) {\r\n        return Bytes.beU2(code, curBCI + 2);\r\n    }\r\n    return Bytes.beU1(code, curBCI + 1);\r\n}"
}, {
	"Path": "org.graalvm.compiler.phases.util.BlockWorkList.removeFromWorkList",
	"Comment": "removes the next block from this work list. if the blocks have been added in a sorted order,then the block with the lowest number is returned. otherwise, the last block added isreturned.",
	"Method": "AbstractMergeNode removeFromWorkList(){\r\n    if (workListIndex != 0) {\r\n        return workList[--workListIndex];\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.AArch64LIRGenerator.moveSp",
	"Comment": "if val denotes the stackpointer, move it to another location. this is necessary since mostops cannot handle the stackpointer as input or output.",
	"Method": "AllocatableValue moveSp(AllocatableValue val){\r\n    if (val instanceof RegisterValue && ((RegisterValue) val).getRegister().equals(sp)) {\r\n        assert val.getPlatformKind() == AArch64Kind.QWORD : \"Stackpointer must be long\";\r\n        return emitMove(val);\r\n    }\r\n    return val;\r\n}"
}, {
	"Path": "org.graalvm.compiler.serviceprovider.GraalServices.isCurrentThreadCpuTimeSupported",
	"Comment": "determines if the java virtual machine supports cpu time measurement for the current thread.",
	"Method": "boolean isCurrentThreadCpuTimeSupported(){\r\n    JMXService jmx = JMXService.instance;\r\n    if (jmx == null) {\r\n        return false;\r\n    }\r\n    return jmx.isCurrentThreadCpuTimeSupported();\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.aarch64.AArch64LIRGenerator.toRegisterKind",
	"Comment": "aarch64 cannot use anything smaller than a word in any instruction other than load and store.",
	"Method": "K toRegisterKind(K kind){\r\n    switch((AArch64Kind) kind.getPlatformKind()) {\r\n        case BYTE:\r\n        case WORD:\r\n            return kind.changeType(AArch64Kind.DWORD);\r\n        default:\r\n            return kind;\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.compiler.debug.TimeSource.getTimeNS",
	"Comment": "gets the current time of this thread in nanoseconds from the most accurate timer available onthe system. the returned value will be the current time in nanoseconds precision but notnecessarily nanoseconds accuracy.the intended use case of this method is to measure the time a certain action takes by makingsuccessive calls to it. it should not be used to measure total times in the sense of a timestamp.",
	"Method": "long getTimeNS(){\r\n    return USING_THREAD_CPU_TIME ? GraalServices.getCurrentThreadCpuTime() : System.nanoTime();\r\n}"
}, {
	"Path": "org.graalvm.polyglot.Instrument.lookup",
	"Comment": "looks up an additional internal service that is provided by this instrument using a javatype. note that the services returned by this method are implementation specific and subjectto change without notice.",
	"Method": "T lookup(Class<T> type){\r\n    return impl.lookup(type);\r\n}"
}, {
	"Path": "org.graalvm.nativeimage.ProcessProperties.isAlive",
	"Comment": "tests whether the process represented by the given process id is alive.",
	"Method": "boolean isAlive(long processID){\r\n    return ImageSingletons.lookup(ProcessPropertiesSupport.class).isAlive(processID);\r\n}"
}, {
	"Path": "org.graalvm.polyglot.SourceSection.getSource",
	"Comment": "representation of the source program that contains this section.",
	"Method": "Source getSource(){\r\n    return source;\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph.commonDominator",
	"Comment": "calculates the common dominator of two blocks.note that this algorithm makes use of special properties regarding the numbering of blocks.",
	"Method": "AbstractBlockBase<?> commonDominator(AbstractBlockBase<?> a,AbstractBlockBase<?> b){\r\n    if (a == null) {\r\n        return b;\r\n    } else if (b == null) {\r\n        return a;\r\n    } else if (a == b) {\r\n        return a;\r\n    } else {\r\n        int aDomDepth = a.getDominatorDepth();\r\n        int bDomDepth = b.getDominatorDepth();\r\n        AbstractBlockBase<?> aTemp;\r\n        AbstractBlockBase<?> bTemp;\r\n        if (aDomDepth > bDomDepth) {\r\n            aTemp = a;\r\n            bTemp = b;\r\n        } else {\r\n            aTemp = b;\r\n            bTemp = a;\r\n        }\r\n        return commonDominatorHelper(aTemp, bTemp);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.RegexProfile.atEvaluationTripPoint",
	"Comment": "check if the profiling information gathered so far is sufficient for making a decision.",
	"Method": "boolean atEvaluationTripPoint(){\r\n    return calls.getCount() > 0 && (calls.getCount() % EVALUATION_TRIP_POINT) == 0;\r\n}"
}, {
	"Path": "org.graalvm.compiler.jtt.bytecode.BC_irem.test5",
	"Comment": "test if sign extension works on architectures with 64 bit registers only",
	"Method": "int test5(int a,int b){\r\n    return (a + 0xFF) % (b + 0xFF);\r\n}"
}, {
	"Path": "org.graalvm.compiler.jtt.bytecode.BC_irem.test6",
	"Comment": "test if sign extension works on architectures with 64 bit registers only",
	"Method": "int test6(int a,int b){\r\n    return (a - 0xFF) % (b - 0xFF);\r\n}"
}, {
	"Path": "org.graalvm.compiler.core.common.type.IntegerStamp.upperBound",
	"Comment": "the signed inclusive upper bound on the value described by this stamp.",
	"Method": "long upperBound(){\r\n    return upperBound;\r\n}"
}, {
	"Path": "org.graalvm.compiler.jtt.bytecode.BC_irem.test4",
	"Comment": "tests if the zero extension works fine with 64 bit registers behind",
	"Method": "long test4(int a,int b){\r\n    int ra = Math.abs(a % b);\r\n    int rb = Math.abs(a) % b;\r\n    return ra << 32 | rb;\r\n}"
}, {
	"Path": "org.graalvm.compiler.lir.framemap.FrameMap.offsetForStackSlot",
	"Comment": "computes the offset of a stack slot relative to the frame register.",
	"Method": "int offsetForStackSlot(StackSlot slot){\r\n    if (slot.isInCallerFrame()) {\r\n        accessesCallerFrame = true;\r\n    }\r\n    return slot.getOffset(totalFrameSize());\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.closeRegistration",
	"Comment": "processes deferred registrations and then closes this object for future registration.",
	"Method": "void closeRegistration(){\r\n    assert closeLateRegistrations();\r\n    flushDeferrables();\r\n}"
}, {
	"Path": "org.graalvm.compiler.jtt.optimize.ConditionalElimination02.getDefaultHighTierContext",
	"Comment": "these tests assume all code paths are reachable so disable profile based dead code removal.",
	"Method": "HighTierContext getDefaultHighTierContext(){\r\n    return new HighTierContext(getProviders(), getDefaultGraphBuilderSuite(), OptimisticOptimizations.ALL.remove(Optimization.RemoveNeverExecutedCode));\r\n}"
}, {
	"Path": "org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin.isSubstitute",
	"Comment": "determines if a given method is the substitute method of this plugin.",
	"Method": "boolean isSubstitute(Method m){\r\n    if (Modifier.isStatic(m.getModifiers()) && m.getName().equals(name)) {\r\n        if (parameters.length == m.getParameterCount()) {\r\n            Class<?>[] mparams = m.getParameterTypes();\r\n            int start = 0;\r\n            if (!originalIsStatic) {\r\n                start = 1;\r\n                if (!mparams[0].isAssignableFrom(resolveType(parameters[0], false))) {\r\n                    return false;\r\n                }\r\n            }\r\n            for (int i = start; i < mparams.length; i++) {\r\n                if (mparams[i] != resolveType(parameters[i], false)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.compiler.java.BytecodeParser.needsExplicitBoundsCheckException",
	"Comment": "returns true if an explicit null check should be emitted for the given object.",
	"Method": "boolean needsExplicitBoundsCheckException(ValueNode array,ValueNode index){\r\n    return needsExplicitException();\r\n}"
}, {
	"Path": "org.graalvm.compiler.hotspot.CompilationWatchDog.watch",
	"Comment": "opens a scope for watching the compilation of a given method.",
	"Method": "CompilationWatchDog watch(ResolvedJavaMethod method,int id,OptionValues options){\r\n    long startDelayMilliseconds = ms(Options.CompilationWatchDogStartDelay.getValue(options));\r\n    if (startDelayMilliseconds > 0.0D) {\r\n        CompilationWatchDog watchDog = WATCH_DOGS.get();\r\n        if (watchDog == null) {\r\n            Thread currentThread = currentThread();\r\n            long stackTraceIntervalMilliseconds = ms(Options.CompilationWatchDogStackTraceInterval.getValue(options));\r\n            int nonFatalIdenticalCompilationSnapshots = Options.NonFatalIdenticalCompilationSnapshots.getValue(options);\r\n            watchDog = new CompilationWatchDog(currentThread, startDelayMilliseconds, stackTraceIntervalMilliseconds, nonFatalIdenticalCompilationSnapshots);\r\n            WATCH_DOGS.set(watchDog);\r\n            watchDog.start();\r\n        }\r\n        watchDog.startCompilation(method, id);\r\n        return watchDog;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.graalvm.polyglot.Context.newBuilder",
	"Comment": "creates a builder for constructing a context with custom configuration.",
	"Method": "Builder newBuilder(String permittedLanguages){\r\n    return EMPTY.new Builder(permittedLanguages);\r\n}"
}, {
	"Path": "org.graalvm.compiler.truffle.runtime.OptimizedCallTarget.reportLoopCount",
	"Comment": "for compatibility of graal runtime with older truffle runtime. remove after 0.12.",
	"Method": "void reportLoopCount(int count){\r\n    getCompilationProfile().reportLoopCount(count);\r\n}"
}, {
	"Path": "com.oracle.truffle.regex.tregex.parser.ast.GroupBoundaries.applyToResultFactory",
	"Comment": "updates a resultfactory in respect to a single transition and index.",
	"Method": "void applyToResultFactory(PreCalculatedResultFactory resultFactory,int index){\r\n    if (hasIndexUpdates()) {\r\n        resultFactory.updateIndices(updateIndices, index);\r\n    }\r\n}"
}]