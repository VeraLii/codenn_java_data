[{
	"Path": "io.grpc.okhttp.OkHttpClientTransport.toGrpcStatus",
	"Comment": "returns a grpc status corresponding to the given errorcode.",
	"Method": "Status toGrpcStatus(ErrorCode code){\r\n    Status status = ERROR_CODE_TO_STATUS.get(code);\r\n    return status != null ? status : Status.UNKNOWN.withDescription(\"Unknown http2 error code: \" + code.httpCode);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentableNodeTest.testLateMaterializeSyntax",
	"Comment": "first instrument statements and then instrument expressions to test materialization atlocations where there is already a wrapper.",
	"Method": "void testLateMaterializeSyntax(){\r\n    Source source = createSource(\"MATERIALIZE_CHILD_EXPRESSION\");\r\n    SourceSectionFilter filter;\r\n    filter = SourceSectionFilter.newBuilder().tagIs(StandardTags.StatementTag.class).build();\r\n    instrumenter.attachExecutionEventFactory(filter, null, factory);\r\n    execute(source);\r\n    assertOn(ENTER, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof MaterializeChildExpressionNode);\r\n    });\r\n    assertOn(RETURN_VALUE, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof MaterializeChildExpressionNode);\r\n    });\r\n    assertAllEventsConsumed();\r\n    filter = SourceSectionFilter.newBuilder().tagIs(StandardTags.ExpressionTag.class).build();\r\n    instrumenter.attachExecutionEventFactory(filter, null, factory);\r\n    execute(source);\r\n    assertOn(ENTER, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof MaterializedChildExpressionNode);\r\n    });\r\n    assertOn(ENTER, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof ExpressionNode);\r\n    });\r\n    assertOn(RETURN_VALUE, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof ExpressionNode);\r\n    });\r\n    assertOn(RETURN_VALUE, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof MaterializedChildExpressionNode);\r\n    });\r\n}"
}, {
	"Path": "com.google.gson.Gson.newJsonReader",
	"Comment": "returns a new json reader configured for the settings on this gson instance.",
	"Method": "JsonReader newJsonReader(Reader reader){\r\n    JsonReader jsonReader = new JsonReader(reader);\r\n    jsonReader.setLenient(lenient);\r\n    return jsonReader;\r\n}"
}, {
	"Path": "com.oracle.svm.core.jdk8.zipfile.ZipFile.getInflater",
	"Comment": "gets an inflater from the list of available inflaters or allocatesa new one.",
	"Method": "Inflater getInflater(){\r\n    Inflater inf;\r\n    synchronized (inflaterCache) {\r\n        while ((inf = inflaterCache.poll()) != null) {\r\n            if (!KnownIntrinsics.unsafeCast(inf, Target_java_util_zip_Inflater.class).ended()) {\r\n                return inf;\r\n            }\r\n        }\r\n    }\r\n    return new Inflater(true);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.CompilerAsserts.compilationConstant",
	"Comment": "assertion that the corresponding value is reduced to a constant during compilation.",
	"Method": "void compilationConstant(Object value){\r\n    if (!CompilerDirectives.isCompilationConstant(value)) {\r\n        neverPartOfCompilation(\"Value is not compilation constant\");\r\n    }\r\n}"
}, {
	"Path": "io.grpc.ManagedChannelBuilder.disableRetry",
	"Comment": "disables the retry and hedging mechanism provided by the grpc library. this is designed for thecase when users have their own retry implementation and want to avoid their own retry takingplace simultaneously with the grpc library layer retry.",
	"Method": "T disableRetry(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "io.grpc.Context.addListener",
	"Comment": "add a listener that will be notified when the context becomes cancelled.",
	"Method": "void addListener(CancellationListener cancellationListener,Executor executor){\r\n    checkNotNull(cancellationListener, \"cancellationListener\");\r\n    checkNotNull(executor, \"executor\");\r\n    if (canBeCancelled()) {\r\n        ExecutableListener executableListener = new ExecutableListener(executor, cancellationListener);\r\n        synchronized (this) {\r\n            if (isCancelled()) {\r\n                executableListener.deliver();\r\n            } else {\r\n                if (listeners == null) {\r\n                    listeners = new ArrayList();\r\n                    listeners.add(executableListener);\r\n                    if (cancellableAncestor != null) {\r\n                        cancellableAncestor.addListener(parentListener, DirectExecutor.INSTANCE);\r\n                    }\r\n                } else {\r\n                    listeners.add(executableListener);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.grpc.internal.Http2Ping.asRunnable",
	"Comment": "returns a runnable that, when run, invokes the given callback, providing the given cause offailure.",
	"Method": "Runnable asRunnable(ClientTransport.PingCallback callback,long roundTripTimeNanos,Runnable asRunnable,ClientTransport.PingCallback callback,Throwable failureCause){\r\n    return new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            callback.onFailure(failureCause);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.grpc.internal.Http2Ping.asRunnable",
	"Comment": "returns a runnable that, when run, invokes the given callback, providing the given cause offailure.",
	"Method": "Runnable asRunnable(ClientTransport.PingCallback callback,long roundTripTimeNanos,Runnable asRunnable,ClientTransport.PingCallback callback,Throwable failureCause){\r\n    callback.onFailure(failureCause);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.RootNodeBits.isNoSourceSection",
	"Comment": "returns true if there is no source section available in the whole rootnode.",
	"Method": "boolean isNoSourceSection(int bits){\r\n    return (bits & NO_SOURCE_SECTION) > 0;\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.SingleThreadBlockingQpsBenchmark.main",
	"Comment": "useful for triggering a subset of the benchmark in a profiler.",
	"Method": "void main(String[] argv){\r\n    SingleThreadBlockingQpsBenchmark bench = new SingleThreadBlockingQpsBenchmark();\r\n    bench.setup();\r\n    for (int i = 0; i < 10000; i++) {\r\n        bench.blockingUnary();\r\n    }\r\n    Thread.sleep(30000);\r\n    bench.teardown();\r\n    System.exit(0);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.FirstObjectTable.entryToMemoryOffset",
	"Comment": "turn a table entry into a memory offset. this only handles memory offset entries.",
	"Method": "UnsignedWord entryToMemoryOffset(int entry){\r\n    assert isMemoryOffsetEntry(entry) : \"Entry out of bounds.\";\r\n    final UnsignedWord entryUnsigned = WordFactory.unsigned(-entry);\r\n    final UnsignedWord result = entryUnsigned.multiply(memoryOffsetScale());\r\n    assert (result.belowThan(MEMORY_BYTES_PER_ENTRY)) : \"Entry out of bounds.\";\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.DirectoryStorageTest.testLoadGraalVersionSimple",
	"Comment": "test of loadgraalversioninfo method, of class registrystorage.",
	"Method": "void testLoadGraalVersionSimple(){\r\n    try (InputStream is = getClass().getResourceAsStream(\"release_simple.properties\")) {\r\n        Files.copy(is, graalVMPath.resolve(SystemUtils.fileName(\"release\")));\r\n    }\r\n    Map<String, String> result = storage.loadGraalVersionInfo();\r\n    assertEquals(7, result.size());\r\n}"
}, {
	"Path": "com.oracle.svm.core.hub.DynamicHub.toClass",
	"Comment": "note that this method must be a static method and not an instance method, otherwise nullvalues cannot be converted.",
	"Method": "Class<?> toClass(DynamicHub hub){\r\n    return KnownIntrinsics.unsafeCast(hub, Class.class);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.HeapChunkProvider.consumeUnalignedChunk",
	"Comment": "recycle an unalignedheapchunk back to the operating system. they are never recycled to a freelist.",
	"Method": "void consumeUnalignedChunk(UnalignedHeader chunk){\r\n    final UnsignedWord chunkSize = unalignedChunkSize(chunk);\r\n    log().string(\"[HeapChunkProvider.consumeUnalignedChunk  chunk: \").hex(chunk).string(\"  chunkSize: \").hex(chunkSize).newline();\r\n    freeUnalignedChunk(chunk);\r\n    log().string(\" ]\").newline();\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.ObjectHeaderImpl.readHeaderBitsFromObject",
	"Comment": "this method reads the header from the object and returns the header bits.",
	"Method": "UnsignedWord readHeaderBitsFromObject(Object o){\r\n    final UnsignedWord header = ObjectHeader.readHeaderFromObject(o);\r\n    return ObjectHeaderImpl.getHeaderBitsFromHeader(header);\r\n}"
}, {
	"Path": "io.grpc.Context.validateGeneration",
	"Comment": "if the ancestry chain length is unreasonably long, then print an error to the log and recordthe stack trace.",
	"Method": "void validateGeneration(int generation){\r\n    if (generation == CONTEXT_DEPTH_WARN_THRESH) {\r\n        log.log(Level.SEVERE, \"Context ancestry chain length is abnormally long. \" + \"This suggests an error in application code. \" + \"Length exceeded: \" + CONTEXT_DEPTH_WARN_THRESH, new Exception());\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.JsonNull.hashCode",
	"Comment": "all instances of jsonnull have the same hash code since they are indistinguishable",
	"Method": "int hashCode(){\r\n    return JsonNull.class.hashCode();\r\n}"
}, {
	"Path": "org.graalvm.component.installer.model.ComponentRegistryTest.testGetPreservedFiles",
	"Comment": "test of getpreservedfiles method, of class componentregistry.",
	"Method": "void testGetPreservedFiles(){\r\n    mockStorage.installed.add(rubyInfo);\r\n    List<String> ll = registry.getPreservedFiles(rubyInfo);\r\n    assertEquals(Arrays.asList(\"jre/bin/ruby\", CommonConstants.PATH_COMPONENT_STORAGE), ll);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.HeapPolicy.getMaximumYoungGenerationSize",
	"Comment": "the maximum size of the young generation as an unsignedword.",
	"Method": "UnsignedWord getMaximumYoungGenerationSize(){\r\n    final Log trace = Log.noopLog().string(\"[HeapPolicy.getMaximumYoungGenerationSize:\");\r\n    if (maximumYoungGenerationSize.aboveThan(WordFactory.zero())) {\r\n        trace.string(\"  returns: \").unsigned(maximumYoungGenerationSize).string(\" ]\").newline();\r\n        return maximumYoungGenerationSize;\r\n    }\r\n    final XOptions.XFlag xmn = XOptions.getXmn();\r\n    final UnsignedWord result;\r\n    if (xmn.getEpoch() > 0) {\r\n        result = WordFactory.unsigned(xmn.getValue());\r\n    } else {\r\n        result = m(256);\r\n    }\r\n    trace.string(\"  -Xmn.epoch: \").unsigned(xmn.getEpoch()).string(\"  -Xmn.value: \").unsigned(xmn.getValue()).string(\"  returns: \").unsigned(result).string(\"]\").newline();\r\n    return result;\r\n}"
}, {
	"Path": "io.grpc.internal.Http2Ping.addCallback",
	"Comment": "registers a callback that is invoked when the ping operation completes. if this ping operationis already completed, the callback is invoked immediately.",
	"Method": "void addCallback(ClientTransport.PingCallback callback,Executor executor){\r\n    Runnable runnable;\r\n    synchronized (this) {\r\n        if (!completed) {\r\n            callbacks.put(callback, executor);\r\n            return;\r\n        }\r\n        runnable = this.failureCause != null ? asRunnable(callback, failureCause) : asRunnable(callback, roundTripTimeNanos);\r\n    }\r\n    doExecute(executor, runnable);\r\n}"
}, {
	"Path": "io.grpc.okhttp.OkHttpClientTransportTest.nextFrameThrowIoException",
	"Comment": "when nextframe throws ioexception, the transport should be aborted.",
	"Method": "void nextFrameThrowIoException(){\r\n    initTransport();\r\n    MockStreamListener listener1 = new MockStreamListener();\r\n    MockStreamListener listener2 = new MockStreamListener();\r\n    OkHttpClientStream stream1 = clientTransport.newStream(method, new Metadata(), CallOptions.DEFAULT);\r\n    stream1.start(listener1);\r\n    stream1.request(1);\r\n    OkHttpClientStream stream2 = clientTransport.newStream(method, new Metadata(), CallOptions.DEFAULT);\r\n    stream2.start(listener2);\r\n    stream2.request(1);\r\n    assertEquals(2, activeStreamCount());\r\n    assertContainStream(3);\r\n    assertContainStream(5);\r\n    frameReader.throwIoExceptionForNextFrame();\r\n    listener1.waitUntilStreamClosed();\r\n    listener2.waitUntilStreamClosed();\r\n    assertEquals(0, activeStreamCount());\r\n    assertEquals(Status.INTERNAL.getCode(), listener1.status.getCode());\r\n    assertEquals(NETWORK_ISSUE_MESSAGE, listener1.status.getCause().getMessage());\r\n    assertEquals(Status.INTERNAL.getCode(), listener2.status.getCode());\r\n    assertEquals(NETWORK_ISSUE_MESSAGE, listener2.status.getCause().getMessage());\r\n    verify(transportListener, timeout(TIME_OUT_MS)).transportShutdown(isA(Status.class));\r\n    verify(transportListener, timeout(TIME_OUT_MS)).transportTerminated();\r\n    shutdownAndVerify();\r\n}"
}, {
	"Path": "com.google.gson.internal.bind.util.ISO8601Utils.indexOfNonDigit",
	"Comment": "returns the index of the first character in the string that is not a digit, starting at offset.",
	"Method": "int indexOfNonDigit(String string,int offset){\r\n    for (int i = offset; i < string.length(); i++) {\r\n        char c = string.charAt(i);\r\n        if (c < '0' || c > '9')\r\n            return i;\r\n    }\r\n    return string.length();\r\n}"
}, {
	"Path": "com.oracle.svm.core.allocationprofile.AllocationSite.getSites",
	"Comment": "summarizes the total allocation site object count and size and returns those allocationssites that have the allocated size above the threshold.",
	"Method": "List<AllocationSite> getSites(){\r\n    List<AllocationSite> sortedSites = new ArrayList();\r\n    for (AllocationSite site : sites.keySet()) {\r\n        long totalCount = 0;\r\n        long totalSize = 0;\r\n        for (AllocationCounter counter = site.firstCounter.get(); counter != null; counter = counter.getNext()) {\r\n            totalCount += counter.getCount();\r\n            totalSize += counter.getSize();\r\n        }\r\n        site.cachedCount = totalCount;\r\n        site.cachedSize = totalSize;\r\n        if (totalSize >= Options.AllocationProfilingThreshold.getValue()) {\r\n            sortedSites.add(site);\r\n        }\r\n    }\r\n    sortedSites.sort(sitesComparator);\r\n    return sortedSites;\r\n}"
}, {
	"Path": "io.grpc.netty.NettyClientHandlerTest.receivedGoAway_notUtf8",
	"Comment": "propagate exceptions during the ongoawayreceived callback.",
	"Method": "void receivedGoAway_notUtf8(){\r\n    channelRead(goAwayFrame(0, 11, Unpooled.copiedBuffer(new byte[] { (byte) 0xFF, (byte) 0xF0, (byte) 0x0a })));\r\n}"
}, {
	"Path": "io.grpc.internal.Http2ClientStreamTransportState.transportDataReceived",
	"Comment": "called by subclasses whenever a data frame is received from the transport.",
	"Method": "void transportDataReceived(ReadableBuffer frame,boolean endOfStream){\r\n    if (transportError != null) {\r\n        transportError = transportError.augmentDescription(\"DATA-----------------------------\\n\" + ReadableBuffers.readAsString(frame, errorCharset));\r\n        frame.close();\r\n        if (transportError.getDescription().length() > 1000 || endOfStream) {\r\n            http2ProcessingFailed(transportError, false, transportErrorMetadata);\r\n        }\r\n    } else {\r\n        if (!headersReceived) {\r\n            http2ProcessingFailed(Status.INTERNAL.withDescription(\"headers not received before payload\"), false, new Metadata());\r\n            return;\r\n        }\r\n        inboundDataReceived(frame);\r\n        if (endOfStream) {\r\n            transportError = Status.INTERNAL.withDescription(\"Received unexpected EOS on DATA frame from server.\");\r\n            transportErrorMetadata = new Metadata();\r\n            transportReportStatus(transportError, false, transportErrorMetadata);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.grpc.stub.AbstractStub.withInterceptors",
	"Comment": "returns a new stub that has the given interceptors attached to the underlying channel.",
	"Method": "S withInterceptors(ClientInterceptor interceptors){\r\n    return build(ClientInterceptors.intercept(channel, interceptors), callOptions);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.GreyObjectsWalker.haveGreyObjects",
	"Comment": "compare the snapshot to the current state of the space to see if there are grey objects.",
	"Method": "boolean haveGreyObjects(){\r\n    final Log trace = Log.noopLog().string(\"[Space.GreyObjectsWalker.haveGreyObjects:\");\r\n    boolean result = false;\r\n    result |= (getAlignedHeapChunk().notEqual(space.getLastAlignedHeapChunk()));\r\n    result |= (getAlignedHeapChunk().isNonNull() && alignedTop.notEqual(getAlignedHeapChunk().getTop()));\r\n    result |= (getUnalignedHeapChunk().notEqual(space.getLastUnalignedHeapChunk()));\r\n    trace.string(\"  returns: \").bool(result).string(\"]\").newline();\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.nodes.NodeUtil.findChildField",
	"Comment": "finds the field in a parent node, if any, that holds a specified child node.",
	"Method": "NodeFieldAccessor findChildField(Node parent,Node child){\r\n    assert child != null;\r\n    NodeClass parentNodeClass = parent.getNodeClass();\r\n    for (NodeFieldAccessor field : parentNodeClass.getFields()) {\r\n        if (field.getKind() == NodeFieldAccessor.NodeFieldKind.CHILD) {\r\n            if (field.getObject(parent) == child) {\r\n                return field;\r\n            }\r\n        } else if (field.getKind() == NodeFieldAccessor.NodeFieldKind.CHILDREN) {\r\n            Object arrayObject = field.getObject(parent);\r\n            if (arrayObject != null) {\r\n                Object[] array = (Object[]) arrayObject;\r\n                for (int i = 0; i < array.length; i++) {\r\n                    if (array[i] == child) {\r\n                        return field;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.grpc.netty.GrpcSslContexts.forClient",
	"Comment": "creates a sslcontextbuilder with ciphers and apn appropriate for grpc.",
	"Method": "SslContextBuilder forClient(){\r\n    return configure(SslContextBuilder.forClient());\r\n}"
}, {
	"Path": "io.grpc.okhttp.OkHttpProtocolNegotiator.createNegotiator",
	"Comment": "creates corresponding negotiator according to whether on android.",
	"Method": "OkHttpProtocolNegotiator createNegotiator(ClassLoader loader){\r\n    boolean android = true;\r\n    try {\r\n        loader.loadClass(\"com.android.org.conscrypt.OpenSSLSocketImpl\");\r\n    } catch (ClassNotFoundException e1) {\r\n        logger.log(Level.FINE, \"Unable to find Conscrypt. Skipping\", e1);\r\n        try {\r\n            loader.loadClass(\"org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl\");\r\n        } catch (ClassNotFoundException e2) {\r\n            logger.log(Level.FINE, \"Unable to find any OpenSSLSocketImpl. Skipping\", e2);\r\n            android = false;\r\n        }\r\n    }\r\n    return android ? new AndroidNegotiator(DEFAULT_PLATFORM) : new OkHttpProtocolNegotiator(DEFAULT_PLATFORM);\r\n}"
}, {
	"Path": "io.grpc.netty.GrpcHttp2ConnectionHandler.getEagAttributes",
	"Comment": "get the attributes of the equivalentaddressgroup used to create this transport.",
	"Method": "Attributes getEagAttributes(){\r\n    return Attributes.EMPTY;\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.AnalysisObjectScanner.getArrayElementsFlow",
	"Comment": "get the array elements flow given its type and the array constant.",
	"Method": "ArrayElementsTypeFlow getArrayElementsFlow(JavaConstant array,AnalysisType arrayType){\r\n    AnalysisObject arrayObjConstant = bb.analysisPolicy().createConstantObject(bb, array, arrayType);\r\n    return arrayObjConstant.getArrayElementsFlow(bb, true);\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.FlowControlledMessagesPerSecondBenchmark.teardown",
	"Comment": "stop the running calls then stop the server and client channels.",
	"Method": "void teardown(){\r\n    completed.set(true);\r\n    if (!latch.await(5, TimeUnit.SECONDS)) {\r\n        logger.warning(\"Failed to shutdown all calls.\");\r\n    }\r\n    super.teardown();\r\n}"
}, {
	"Path": "com.google.gson.stream.JsonReader.endObject",
	"Comment": "consumes the next token from the json stream and asserts that it is theend of the current object.",
	"Method": "void endObject(){\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    if (p == PEEKED_END_OBJECT) {\r\n        stackSize--;\r\n        pathNames[stackSize] = null;\r\n        pathIndices[stackSize - 1]++;\r\n        peeked = PEEKED_NONE;\r\n    } else {\r\n        throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + locationString());\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.object.DynamicObjectImpl.setShapeAndGrow",
	"Comment": "set shape to an immediate child of the current shape, optionally growing the extension array.typically this would add a single property. cannot shrink or grow more than one property at atime.",
	"Method": "void setShapeAndGrow(Shape oldShape,Shape newShape){\r\n    assert getShape() == oldShape : \"wrong old shape\";\r\n    if (oldShape != newShape) {\r\n        assert checkSetShape(oldShape, newShape);\r\n        growStore(oldShape, newShape);\r\n        setShape(newShape);\r\n        assert checkExtensionArrayInvariants(newShape);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.component.installer.commands.InstallerTest.testInstallExistingFileWillNotRevert",
	"Comment": "check that if the same file is found and skipped, it will not revert on installation abort.",
	"Method": "void testInstallExistingFileWillNotRevert(){\r\n    setupComponentInstall(\"truffleruby2.jar\");\r\n    Path existing = targetPath.resolve(SystemUtils.fromCommonString(\"jre/bin/ruby\"));\r\n    Files.createDirectories(existing.getParent());\r\n    Files.copy(dataFile(\"ruby\"), existing);\r\n    JarEntry entry = componentJarFile.getJarEntry(\"jre/bin/ruby\");\r\n    Path resultPath = installer.installOneFile(installer.translateTargetPath(entry), entry);\r\n    Path relative = targetPath.relativize(resultPath);\r\n    assertEquals(entry.getName(), SystemUtils.toCommonPath(relative));\r\n    Path check = targetPath.resolve(SystemUtils.fromCommonString(\"jre/bin/ruby\"));\r\n    assertTrue(Files.exists(check));\r\n    assertEquals(entry.getSize(), Files.size(check));\r\n    installer.revertInstall();\r\n    assertTrue(Files.exists(check));\r\n}"
}, {
	"Path": "io.grpc.okhttp.OkHttpClientTransport.onException",
	"Comment": "finish all active streams due to an ioexception, then close the transport.",
	"Method": "void onException(Throwable failureCause){\r\n    Preconditions.checkNotNull(failureCause, \"failureCause\");\r\n    Status status = Status.UNAVAILABLE.withCause(failureCause);\r\n    startGoAway(0, ErrorCode.INTERNAL_ERROR, status);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.dsl.test.AmbiguousClassNameTest.testInnerClassReferences",
	"Comment": "tests that ambiguous inner class simple names use more qualified names for the generatedcode. also tests that type checks and casts are not mixed up if dynamic value type simplenames are ambiguous.",
	"Method": "void testInnerClassReferences(){\r\n    InnerClassReferenceNode node = InnerClassReferenceNodeGen.create();\r\n    AmbiguousClassNameTest.OtherObject expected = new AmbiguousClassNameTest.OtherObject();\r\n    Object actual = node.execute(expected);\r\n    Assert.assertSame(expected, actual);\r\n    RopeNodes.OtherObject expected2 = new RopeNodes.OtherObject();\r\n    actual = node.execute(expected2);\r\n    Assert.assertSame(expected2, actual);\r\n}"
}, {
	"Path": "io.grpc.internal.FakeClock.getStopwatchSupplier",
	"Comment": "provides a stopwatch instance that uses the fake clock ticker.",
	"Method": "Supplier<Stopwatch> getStopwatchSupplier(){\r\n    return stopwatchSupplier;\r\n}"
}, {
	"Path": "com.google.gson.protobuf.ProtoTypeAdapter.getCustSerializedName",
	"Comment": "retrieves the custom field name from the given options, and if not found, returns the specifieddefault name.",
	"Method": "String getCustSerializedName(FieldOptions options,String defaultName){\r\n    for (Extension<FieldOptions, String> extension : serializedNameExtensions) {\r\n        if (options.hasExtension(extension)) {\r\n            return options.getExtension(extension);\r\n        }\r\n    }\r\n    return protoFormat.to(jsonFormat, defaultName);\r\n}"
}, {
	"Path": "io.grpc.okhttp.OkHttpClientTransport.stopIfNecessary",
	"Comment": "when the transport is in goaway state, we should stop it once all active streams finish.",
	"Method": "void stopIfNecessary(){\r\n    if (!(goAwayStatus != null && streams.isEmpty() && pendingStreams.isEmpty())) {\r\n        return;\r\n    }\r\n    if (stopped) {\r\n        return;\r\n    }\r\n    stopped = true;\r\n    if (keepAliveManager != null) {\r\n        keepAliveManager.onTransportTermination();\r\n        scheduler = SharedResourceHolder.release(TIMER_SERVICE, scheduler);\r\n    }\r\n    if (ping != null) {\r\n        ping.failed(getPingFailure());\r\n        ping = null;\r\n    }\r\n    if (!goAwaySent) {\r\n        goAwaySent = true;\r\n        frameWriter.goAway(0, ErrorCode.NO_ERROR, new byte[0]);\r\n    }\r\n    frameWriter.close();\r\n}"
}, {
	"Path": "io.grpc.internal.DnsNameResolver.maybeChooseServiceConfig",
	"Comment": "determines if a given service config choice applies, and if so, returns it.",
	"Method": "Map<String, Object> maybeChooseServiceConfig(Map<String, Object> choice,Random random,String hostname){\r\n    for (Entry<String, ?> entry : choice.entrySet()) {\r\n        Verify.verify(SERVICE_CONFIG_CHOICE_KEYS.contains(entry.getKey()), \"Bad key: %s\", entry);\r\n    }\r\n    List<String> clientLanguages = getClientLanguagesFromChoice(choice);\r\n    if (clientLanguages != null && !clientLanguages.isEmpty()) {\r\n        boolean javaPresent = false;\r\n        for (String lang : clientLanguages) {\r\n            if (\"java\".equalsIgnoreCase(lang)) {\r\n                javaPresent = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!javaPresent) {\r\n            return null;\r\n        }\r\n    }\r\n    Double percentage = getPercentageFromChoice(choice);\r\n    if (percentage != null) {\r\n        int pct = percentage.intValue();\r\n        Verify.verify(pct >= 0 && pct <= 100, \"Bad percentage: %s\", percentage);\r\n        if (random.nextInt(100) >= pct) {\r\n            return null;\r\n        }\r\n    }\r\n    List<String> clientHostnames = getHostnamesFromChoice(choice);\r\n    if (clientHostnames != null && !clientHostnames.isEmpty()) {\r\n        boolean hostnamePresent = false;\r\n        for (String clientHostname : clientHostnames) {\r\n            if (clientHostname.equals(hostname)) {\r\n                hostnamePresent = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!hostnamePresent) {\r\n            return null;\r\n        }\r\n    }\r\n    return ServiceConfigUtil.getObject(choice, SERVICE_CONFIG_CHOICE_SERVICE_CONFIG_KEY);\r\n}"
}, {
	"Path": "io.grpc.alts.internal.ProtectedPromise.newPromise",
	"Comment": "allocate a new promise for the write of a protected frame. this will be used to aggregate theoverall success of the unprotected promises.",
	"Method": "ChannelPromise newPromise(){\r\n    checkState(!doneAllocating, \"Done allocating. No more promises can be allocated.\");\r\n    expectedCount++;\r\n    return this;\r\n}"
}, {
	"Path": "io.grpc.ManagedChannel.getState",
	"Comment": "gets the current connectivity state. note the result may soon become outdated.note that the core library did not provide an implementation of this method until v1.6.1.",
	"Method": "ConnectivityState getState(boolean requestConnection){\r\n    throw new UnsupportedOperationException(\"Not implemented\");\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.typestate.TypeStateUtils.union",
	"Comment": "returns the union of the two analysis object arrays of the same type.",
	"Method": "AnalysisObject[] union(BigBang bb,AnalysisObject[] a1,AnalysisObject[] a2){\r\n    if (a1.length == 1 && bb.analysisPolicy().isSummaryObject(a1[0])) {\r\n        bb.analysisPolicy().noteMerge(bb, a1);\r\n        bb.analysisPolicy().noteMerge(bb, a2);\r\n        return a1;\r\n    } else if (a2.length == 1 && bb.analysisPolicy().isSummaryObject(a2[0])) {\r\n        bb.analysisPolicy().noteMerge(bb, a1);\r\n        bb.analysisPolicy().noteMerge(bb, a2);\r\n        return a2;\r\n    } else {\r\n        if (a1.length >= a2.length) {\r\n            return arraysUnion(bb, a1, a2);\r\n        } else {\r\n            return arraysUnion(bb, a2, a1);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.NativeImageGenerator.includedIn",
	"Comment": "returns true if the provided platform is included in at least one of the provided platformgroups defined by the annotation. also returns true if no annotation is provided.",
	"Method": "boolean includedIn(Platform platform,Class<? extends Platform> platformGroup,boolean includedIn,Platform platform,Platforms platformsAnnotation){\r\n    if (platformsAnnotation == null) {\r\n        return true;\r\n    }\r\n    for (Class<? extends Platform> platformGroup : platformsAnnotation.value()) {\r\n        if (includedIn(platform, platformGroup)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.google.common.collect.ObjectCountHashMap.resizeEntries",
	"Comment": "resizes the internal entries array to the specified capacity, which may be greater or less thanthe current capacity.",
	"Method": "void resizeEntries(int newCapacity){\r\n    this.keys = Arrays.copyOf(keys, newCapacity);\r\n    this.values = Arrays.copyOf(values, newCapacity);\r\n    long[] entries = this.entries;\r\n    int oldCapacity = entries.length;\r\n    entries = Arrays.copyOf(entries, newCapacity);\r\n    if (newCapacity > oldCapacity) {\r\n        Arrays.fill(entries, oldCapacity, newCapacity, UNSET);\r\n    }\r\n    this.entries = entries;\r\n}"
}, {
	"Path": "com.oracle.truffle.object.basic.DynamicObjectBasic.checkExtensionArrayInvariants",
	"Comment": "check whether the extension arrays are in accordance with the description in the shape.",
	"Method": "boolean checkExtensionArrayInvariants(Shape newShape){\r\n    assert getShape() == newShape;\r\n    assert (getObjectStore(newShape) == null && ((ShapeImpl) newShape).getObjectArrayCapacity() == 0) || (getObjectStore(newShape) != null && getObjectStore(newShape).length == ((ShapeImpl) newShape).getObjectArrayCapacity());\r\n    if (((ShapeImpl) newShape).hasPrimitiveArray()) {\r\n        assert (getPrimitiveStore(newShape) == null && ((ShapeImpl) newShape).getPrimitiveArrayCapacity() == 0) || (getPrimitiveStore(newShape) != null && getPrimitiveStore(newShape).length == ((ShapeImpl) newShape).getPrimitiveArrayCapacity());\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.HeapChunkProvider.zap",
	"Comment": "write the given value over all the object memory in the chunk.",
	"Method": "void zap(Header<?> chunk,WordBase value){\r\n    Pointer start = chunk.getTop();\r\n    Pointer limit = chunk.getEnd();\r\n    log().string(\"  zap chunk: \").hex(chunk).string(\"  start: \").hex(start).string(\"  limit: \").hex(limit).string(\"  value: \").hex(value).newline();\r\n    for (Pointer p = start; p.belowThan(limit); p = p.add(FrameAccess.wordSize())) {\r\n        p.writeWord(0, value);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.heap.FeebleReferenceList.pop",
	"Comment": "pop a feeblereference off of this list. this method may be called by multiple threads, and sohas to worry about races. so as to not worry about intervening pushes by the collector, thismethod is uninterruptible.",
	"Method": "FeebleReference<? extends T> pop(){\r\n    final FeebleReference<? extends T> result;\r\n    for (; ; ) {\r\n        FeebleReference<? extends T> sampleHead = getHead();\r\n        if (sampleHead == null) {\r\n            result = null;\r\n            break;\r\n        }\r\n        FeebleReference<? extends T> sampleNext = sampleHead.listGetNext();\r\n        if (compareAndSetHead(sampleHead, sampleNext)) {\r\n            result = sampleHead;\r\n            clean(result);\r\n            break;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.AlignedHeapChunk.committedObjectMemoryOfAlignedHeapChunk",
	"Comment": "the committed object memory is the space between start and end.",
	"Method": "UnsignedWord committedObjectMemoryOfAlignedHeapChunk(AlignedHeader that){\r\n    return that.getEnd().subtract(getAlignedHeapChunkStart(that));\r\n}"
}, {
	"Path": "com.oracle.truffle.dsl.processor.parser.MethodSpecParser.parseParameters",
	"Comment": "parameter parsing tries to parse required arguments starting from offset 0 with increasingoffset until it finds a signature end that matches the required specification. if there is noend matching the required arguments, parsing fails. parameters prior to the parsed requiredones are cut and used to parse the optional parameters.",
	"Method": "List<Parameter> parseParameters(MethodSpec spec,List<? extends VariableElement> parameterTypes,boolean varArgs){\r\n    List<Parameter> parsedRequired = null;\r\n    int offset = 0;\r\n    for (; offset <= parameterTypes.size(); offset++) {\r\n        List<VariableElement> parameters = new ArrayList();\r\n        parameters.addAll(parameterTypes.subList(offset, parameterTypes.size()));\r\n        parsedRequired = parseParametersRequired(spec, parameters, varArgs);\r\n        if (parsedRequired != null) {\r\n            break;\r\n        }\r\n    }\r\n    if (parsedRequired == null) {\r\n        return null;\r\n    }\r\n    if (parsedRequired.isEmpty() && offset == 0) {\r\n        offset = parameterTypes.size();\r\n    }\r\n    List<? extends VariableElement> potentialOptionals = parameterTypes.subList(0, offset);\r\n    List<Parameter> parsedOptionals = parseParametersOptional(spec, potentialOptionals);\r\n    if (parsedOptionals == null) {\r\n        return null;\r\n    }\r\n    List<Parameter> finalParameters = new ArrayList();\r\n    finalParameters.addAll(parsedOptionals);\r\n    finalParameters.addAll(parsedRequired);\r\n    return finalParameters;\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.StreamingPingPongsPerSecondBenchmark.teardown",
	"Comment": "stop the running calls then stop the server and client channels.",
	"Method": "void teardown(){\r\n    completed.set(true);\r\n    if (!latch.await(5, TimeUnit.SECONDS)) {\r\n        logger.warning(\"Failed to shutdown all calls.\");\r\n    }\r\n    super.teardown();\r\n}"
}, {
	"Path": "com.oracle.svm.graal.hosted.GraalObjectReplacer.updateDataDuringAnalysis",
	"Comment": "some meta data must be updated during analysis. this is done here.",
	"Method": "boolean updateDataDuringAnalysis(AnalysisMetaAccess metaAccess){\r\n    boolean result = false;\r\n    List<AnalysisMethod> aMethods = new ArrayList();\r\n    aMethods.addAll(methods.keySet());\r\n    int index = 0;\r\n    while (index < aMethods.size()) {\r\n        AnalysisMethod aMethod = aMethods.get(index++);\r\n        SubstrateMethod sMethod = methods.get(aMethod);\r\n        SubstrateMethod[] implementations = new SubstrateMethod[aMethod.getImplementations().length];\r\n        int idx = 0;\r\n        for (AnalysisMethod impl : aMethod.getImplementations()) {\r\n            SubstrateMethod sImpl = methods.get(impl);\r\n            if (sImpl == null) {\r\n                sImpl = createMethod(impl);\r\n                aMethods.add(impl);\r\n                result = true;\r\n            }\r\n            implementations[idx++] = sImpl;\r\n        }\r\n        if (sMethod.setImplementations(implementations)) {\r\n            result = true;\r\n        }\r\n    }\r\n    for (Map.Entry<AnalysisMethod, SubstrateMethod> entry : methods.entrySet()) {\r\n        if (entry.getValue().setAnnotationsEncoding(Inflation.encodeAnnotations(metaAccess, entry.getKey().getAnnotations(), entry.getValue().getAnnotationsEncoding()))) {\r\n            result = true;\r\n        }\r\n    }\r\n    for (Map.Entry<AnalysisField, SubstrateField> entry : fields.entrySet()) {\r\n        if (entry.getValue().setAnnotationsEncoding(Inflation.encodeAnnotations(metaAccess, entry.getKey().getAnnotations(), entry.getValue().getAnnotationsEncoding()))) {\r\n            result = true;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.google.gson.stream.JsonWriter.replaceTop",
	"Comment": "replace the value on the top of the stack with the given value.",
	"Method": "void replaceTop(int topOfStack){\r\n    stack[stackSize - 1] = topOfStack;\r\n}"
}, {
	"Path": "com.oracle.svm.core.deopt.Deoptimizer.constructTargetFrame",
	"Comment": "constructs the frame entries for the deopimization target method.",
	"Method": "VirtualFrame constructTargetFrame(CodeInfoQueryResult targetInfo,FrameInfoQueryResult sourceFrame){\r\n    FrameInfoQueryResult targetFrame = targetInfo.getFrameInfo();\r\n    int savedBasePointerSize = FrameAccess.singleton().savedBasePointerSize();\r\n    long targetFrameSize = targetInfo.getTotalFrameSize() - FrameAccess.returnAddressSize() - savedBasePointerSize;\r\n    VirtualFrame result = new VirtualFrame(targetFrame);\r\n    if (savedBasePointerSize != 0) {\r\n        result.savedBasePointer = new DeoptimizedFrame.SavedBasePointer(targetContentSize, targetContentSize + targetFrameSize);\r\n        targetContentSize += savedBasePointerSize;\r\n    }\r\n    result.returnAddress = new DeoptimizedFrame.ReturnAddress(targetContentSize, targetInfo.getIP().rawValue());\r\n    targetContentSize += FrameAccess.returnAddressSize();\r\n    assert sourceFrame.getNumLocals() == targetFrame.getNumLocals();\r\n    assert sourceFrame.getNumStack() == targetFrame.getNumStack();\r\n    assert sourceFrame.getNumLocks() == targetFrame.getNumLocks();\r\n    assert targetFrame.getVirtualObjects().length == 0;\r\n    assert sourceFrame.getValueInfos().length >= targetFrame.getValueInfos().length;\r\n    int numValues = targetFrame.getValueInfos().length;\r\n    int newEndOfParams = endOfParams;\r\n    for (int idx = 0; idx < numValues; idx++) {\r\n        ValueInfo targetValue = targetFrame.getValueInfos()[idx];\r\n        if (targetValue.getKind() == JavaKind.Illegal) {\r\n        } else {\r\n            JavaConstant con = readValue(sourceFrame.getValueInfos()[idx], sourceFrame);\r\n            assert con.getJavaKind() != JavaKind.Illegal;\r\n            if (con.getJavaKind().isObject() && SubstrateObjectConstant.isCompressed(con) != targetValue.isCompressedReference()) {\r\n                Object obj = SubstrateObjectConstant.asObject(con);\r\n                con = SubstrateObjectConstant.forObject(obj, targetValue.isCompressedReference());\r\n            }\r\n            relockVirtualObject(sourceFrame, idx, con);\r\n            switch(targetValue.getType()) {\r\n                case StackSlot:\r\n                    DeoptimizationCounters.counters().stackValueCount.inc();\r\n                    int targetOffset = TypeConversion.asS4(targetValue.getData());\r\n                    assert targetOffset != targetFrameSize : \"stack slot would overwrite return address\";\r\n                    int totalOffset = targetContentSize + targetOffset;\r\n                    assert totalOffset >= endOfParams : \"stack location overwrites param area\";\r\n                    if (targetOffset < targetFrameSize) {\r\n                        assert totalOffset >= targetContentSize;\r\n                        result.values[idx] = DeoptimizedFrame.ConstantEntry.factory(totalOffset, con);\r\n                    } else if (sourceFrame.getCaller() != null) {\r\n                        assert totalOffset >= targetContentSize;\r\n                        result.values[idx] = DeoptimizedFrame.ConstantEntry.factory(totalOffset, con);\r\n                        int size;\r\n                        if (targetValue.getKind().isObject() && !targetValue.isCompressedReference()) {\r\n                            size = FrameAccess.uncompressedReferenceSize();\r\n                        } else {\r\n                            size = ConfigurationValues.getObjectLayout().sizeInBytes(con.getJavaKind());\r\n                        }\r\n                        int endOffset = totalOffset + size;\r\n                        if (endOffset > newEndOfParams) {\r\n                            newEndOfParams = endOffset;\r\n                        }\r\n                    }\r\n                    break;\r\n                case DefaultConstant:\r\n                case Constant:\r\n                    assert verifyConstant(targetFrame, targetValue, con);\r\n                    DeoptimizationCounters.counters().constantValueCount.inc();\r\n                    break;\r\n                default:\r\n                    throw VMError.shouldNotReachHere(\"unknown deopt target value \" + targetValue);\r\n            }\r\n        }\r\n    }\r\n    targetContentSize += targetFrameSize;\r\n    endOfParams = newEndOfParams;\r\n    return result;\r\n}"
}, {
	"Path": "io.grpc.internal.MessageDeframer.deliver",
	"Comment": "reads and delivers as many messages to the listener as possible.",
	"Method": "void deliver(){\r\n    if (inDelivery) {\r\n        return;\r\n    }\r\n    inDelivery = true;\r\n    try {\r\n        while (!stopDelivery && pendingDeliveries > 0 && readRequiredBytes()) {\r\n            switch(state) {\r\n                case HEADER:\r\n                    processHeader();\r\n                    break;\r\n                case BODY:\r\n                    processBody();\r\n                    pendingDeliveries--;\r\n                    break;\r\n                default:\r\n                    throw new AssertionError(\"Invalid state: \" + state);\r\n            }\r\n        }\r\n        if (stopDelivery) {\r\n            close();\r\n            return;\r\n        }\r\n        if (closeWhenComplete && isStalled()) {\r\n            close();\r\n        }\r\n    } finally {\r\n        inDelivery = false;\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ObjectCountHashMap.insertEntry",
	"Comment": "creates a fresh entry with the specified object at the specified position in the entry array.",
	"Method": "void insertEntry(int entryIndex,K key,int value,int hash){\r\n    this.entries[entryIndex] = ((long) hash << 32) | (NEXT_MASK & UNSET);\r\n    this.keys[entryIndex] = key;\r\n    this.values[entryIndex] = value;\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.context.object.ConstantContextSensitiveObject.noteMerge",
	"Comment": "the object has been in contact with an context insensitive object in an union operation.",
	"Method": "void noteMerge(BigBang bb){\r\n    assert bb.analysisPolicy().isMergingEnabled();\r\n    if (!merged) {\r\n        if (!isEmptyObjectArrayConstant(bb)) {\r\n            super.noteMerge(bb);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.interop.ArityException.getActualArity",
	"Comment": "returns the actual number of arguments provided by the foreign access.",
	"Method": "int getActualArity(){\r\n    return actualArity;\r\n}"
}, {
	"Path": "io.grpc.testing.integration.AbstractInteropTest.assumeEnoughMemory",
	"Comment": "some tests run on memory constrained environments.rather than oom, just give up.64 ischosen as a maximum amount of memory a large test would need.",
	"Method": "void assumeEnoughMemory(){\r\n    Runtime r = Runtime.getRuntime();\r\n    long usedMem = r.totalMemory() - r.freeMemory();\r\n    long actuallyFreeMemory = r.maxMemory() - usedMem;\r\n    Assume.assumeTrue(actuallyFreeMemory + \" is not sufficient to run this test\", actuallyFreeMemory >= 64 * 1024 * 1024);\r\n}"
}, {
	"Path": "com.oracle.truffle.tools.profiler.MemoryTracer.close",
	"Comment": "closes the tracer for fuhrer use, deleting all the gathered data.",
	"Method": "void close(){\r\n    assert Thread.holdsLock(this);\r\n    if (stacksBinding != null) {\r\n        stacksBinding.dispose();\r\n        stacksBinding = null;\r\n    }\r\n    if (shadowStack != null) {\r\n        shadowStack = null;\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.object.LocationImpl.objectArrayCount",
	"Comment": "get the number of object array elements this location requires.",
	"Method": "int objectArrayCount(){\r\n    return 0;\r\n}"
}, {
	"Path": "io.grpc.ContextTest.cancellableContextIsAttached",
	"Comment": "to be visible only for testing. the deprecation is meant for users.",
	"Method": "void cancellableContextIsAttached(){\r\n    Context.CancellableContext base = Context.current().withValue(FOOD, \"fish\").withCancellation();\r\n    assertFalse(base.isCurrent());\r\n    Context toRestore = base.attach();\r\n    Context attached = Context.current();\r\n    assertSame(\"fish\", FOOD.get());\r\n    assertFalse(attached.isCancelled());\r\n    assertNull(attached.cancellationCause());\r\n    assertTrue(attached.canBeCancelled());\r\n    assertTrue(attached.isCurrent());\r\n    assertTrue(base.isCurrent());\r\n    attached.addListener(cancellationListener, MoreExecutors.directExecutor());\r\n    Throwable t = new Throwable();\r\n    base.cancel(t);\r\n    assertTrue(attached.isCancelled());\r\n    assertSame(t, attached.cancellationCause());\r\n    assertSame(attached, listenerNotifedContext);\r\n    base.detach(toRestore);\r\n}"
}, {
	"Path": "io.grpc.MethodDescriptor.getRequestMarshaller",
	"Comment": "returns the marshaller for the request type. allows introspection of the request marshaller.",
	"Method": "Marshaller<ReqT> getRequestMarshaller(){\r\n    return requestMarshaller;\r\n}"
}, {
	"Path": "com.oracle.svm.core.log.RealLog.rawBytes",
	"Comment": "write a raw java array by copying it first to a stack allocated temporary buffer. caller mustensure that the offset and length are within bounds.",
	"Method": "void rawBytes(Object value,int offset,int length,Log rawBytes,CCharPointer bytes,UnsignedWord length){\r\n    ImageSingletons.lookup(LogHandler.class).log(bytes, length);\r\n    return this;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.GCImpl.scavenge",
	"Comment": "scavenge, either just from dirty roots or from all roots.process discovered references while scavenging.",
	"Method": "void scavenge(boolean fromDirtyRoots){\r\n    final Log trace = Log.noopLog().string(\"[GCImpl.scavenge:\").string(\"  fromDirtyRoots: \").bool(fromDirtyRoots).newline();\r\n    DiscoverableReferenceProcessing.clearDiscoveredReferences();\r\n    try (Timer rst = rootScanTimer.open()) {\r\n        trace.string(\"  Cheney scan: \");\r\n        if (fromDirtyRoots) {\r\n            cheneyScanFromDirtyRoots();\r\n        } else {\r\n            cheneyScanFromRoots();\r\n        }\r\n    }\r\n    trace.string(\"  Discovered references: \");\r\n    try (Timer drt = discoverableReferenceTimer.open()) {\r\n        DiscoverableReferenceProcessing.processDiscoveredReferences();\r\n    }\r\n    trace.string(\"  Release spaces: \");\r\n    try (Timer rst = releaseSpacesTimer.open()) {\r\n        releaseSpaces();\r\n    }\r\n    trace.string(\"  Swap spaces: \");\r\n    swapSpaces();\r\n    trace.string(\"]\").newline();\r\n}"
}, {
	"Path": "io.grpc.internal.MessageDeframer.processBody",
	"Comment": "processes the grpc message body, which depending on frame header flags may be compressed.",
	"Method": "void processBody(){\r\n    statsTraceCtx.inboundMessageRead(currentMessageSeqNo, inboundBodyWireSize, -1);\r\n    inboundBodyWireSize = 0;\r\n    InputStream stream = compressedFlag ? getCompressedBody() : getUncompressedBody();\r\n    nextFrame = null;\r\n    listener.messagesAvailable(new SingleMessageProducer(stream));\r\n    state = State.HEADER;\r\n    requiredLength = HEADER_LENGTH;\r\n}"
}, {
	"Path": "io.grpc.alts.internal.AltsHandshakerClient.getKey",
	"Comment": "returns the resulting key of the handshake, if the handshake is completed. note that the keydata returned from the handshake may be more than the key length required for the recordprotocol, thus we need to truncate to the right size.",
	"Method": "byte[] getKey(){\r\n    if (result == null) {\r\n        return null;\r\n    }\r\n    if (result.getKeyData().size() < KEY_LENGTH) {\r\n        throw new IllegalStateException(\"Could not get enough key data from the handshake.\");\r\n    }\r\n    byte[] key = new byte[KEY_LENGTH];\r\n    result.getKeyData().copyTo(key, 0, 0, KEY_LENGTH);\r\n    return key;\r\n}"
}, {
	"Path": "io.grpc.alts.internal.AltsHandshakerClient.setStartServerFields",
	"Comment": "sets the start server fields for the passed handshake request.",
	"Method": "void setStartServerFields(HandshakerReq.Builder req,ByteBuffer inBytes){\r\n    ServerHandshakeParameters serverParameters = ServerHandshakeParameters.newBuilder().addRecordProtocols(RECORD_PROTOCOL).build();\r\n    StartServerHandshakeReq.Builder startServerReq = StartServerHandshakeReq.newBuilder().addApplicationProtocols(APPLICATION_PROTOCOL).putHandshakeParameters(HandshakeProtocol.ALTS.getNumber(), serverParameters).setInBytes(ByteString.copyFrom(inBytes.duplicate()));\r\n    if (handshakerOptions.getRpcProtocolVersions() != null) {\r\n        startServerReq.setRpcVersions(handshakerOptions.getRpcProtocolVersions());\r\n    }\r\n    req.setServerStart(startServerReq);\r\n}"
}, {
	"Path": "io.grpc.testing.TestUtils.preferredTestCiphers",
	"Comment": "returns the ciphers preferred to use during tests. they may be chosen because they are widelyavailable or because they are fast. there is no requirement that they provide confidentialityor integrity.",
	"Method": "List<String> preferredTestCiphers(){\r\n    String[] ciphers;\r\n    try {\r\n        ciphers = SSLContext.getDefault().getDefaultSSLParameters().getCipherSuites();\r\n    } catch (NoSuchAlgorithmException ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n    List<String> ciphersMinusGcm = new ArrayList();\r\n    for (String cipher : ciphers) {\r\n        if (cipher.contains(\"_GCM_\")) {\r\n            continue;\r\n        }\r\n        ciphersMinusGcm.add(cipher);\r\n    }\r\n    return Collections.unmodifiableList(ciphersMinusGcm);\r\n}"
}, {
	"Path": "io.grpc.netty.OutboundHeadersBenchmark.encodeClientHeaders",
	"Comment": "this will encode the random metadata fields, and repeatedly lookup the default other headers.",
	"Method": "ByteBuf encodeClientHeaders(){\r\n    scratchBuffer.clear();\r\n    Http2Headers headers = Utils.convertClientHeaders(metadata, scheme, defaultPath, authority, Utils.HTTP_METHOD, userAgent);\r\n    headersEncoder.encodeHeaders(1, headers, scratchBuffer);\r\n    return scratchBuffer;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.ExecutionEventNode.getSavedInputValues",
	"Comment": "returns all saved input values. for valid input indices that did not save any valuenull is returned. if all inputs were filtered or a null inputfilter was provided then an empty array is returned.",
	"Method": "Object[] getSavedInputValues(VirtualFrame frame){\r\n    EventProviderWithInputChainNode node = getChainNode();\r\n    if (node != null) {\r\n        return node.getSavedInputValues(frame);\r\n    } else {\r\n        return EventProviderWithInputChainNode.EMPTY_ARRAY;\r\n    }\r\n}"
}, {
	"Path": "io.grpc.internal.ServerImpl.shutdown",
	"Comment": "initiates an orderly shutdown in which preexisting calls continue but new calls are rejected.",
	"Method": "ServerImpl shutdown(){\r\n    boolean shutdownTransportServer;\r\n    synchronized (lock) {\r\n        if (shutdown) {\r\n            return this;\r\n        }\r\n        shutdown = true;\r\n        shutdownTransportServer = started;\r\n        if (!shutdownTransportServer) {\r\n            transportServerTerminated = true;\r\n            checkForTermination();\r\n        }\r\n    }\r\n    if (shutdownTransportServer) {\r\n        transportServer.shutdown();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentationTest.testInstrumentException3",
	"Comment": "test that instrumentation exceptions in the onreturnexceptional are attached as suppressedexceptions.",
	"Method": "void testInstrumentException3(){\r\n    TestInstrumentException3.returnedExceptional = 0;\r\n    TestInstrumentException3.onEnter = 0;\r\n    assureEnabled(engine.getInstruments().get(\"testInstrumentException3\"));\r\n    run(\"ROOT(EXPRESSION)\");\r\n    Assert.assertTrue(getErr().contains(\"MyLanguageException\"));\r\n    Assert.assertEquals(0, TestInstrumentException3.returnedExceptional);\r\n    Assert.assertEquals(1, TestInstrumentException3.onEnter);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentableNodeTest.testMaterializeSyntaxNotInstrumented",
	"Comment": "test materialize if the parent node is not instrumented. we need to call materializesyntaxfor all visited instrumentable nodes. not just for instrumented ones.",
	"Method": "void testMaterializeSyntaxNotInstrumented(){\r\n    SourceSectionFilter expressionFilter = SourceSectionFilter.newBuilder().tagIs(StandardTags.ExpressionTag.class).build();\r\n    instrumenter.attachExecutionEventFactory(expressionFilter, null, factory);\r\n    execute(\"MATERIALIZE_CHILD_EXPRESSION\");\r\n    assertOn(ENTER, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof ExpressionNode);\r\n    });\r\n    assertOn(RETURN_VALUE, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof ExpressionNode);\r\n    });\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentationTest.testInstrumentException2",
	"Comment": "we test that instrumentation exceptions are wrapped, onreturnexceptional is invoked properlyand not onreturnvalue,",
	"Method": "void testInstrumentException2(){\r\n    TestInstrumentException2.returnedExceptional = 0;\r\n    TestInstrumentException2.returnedValue = 0;\r\n    assureEnabled(engine.getInstruments().get(\"testInstrumentException2\"));\r\n    run(\"ROOT(EXPRESSION)\");\r\n    String errorText = getErr();\r\n    Assert.assertTrue(errorText, errorText.contains(\"MyLanguageException\"));\r\n    Assert.assertEquals(0, TestInstrumentException2.returnedExceptional);\r\n    Assert.assertEquals(1, TestInstrumentException2.returnedValue);\r\n}"
}, {
	"Path": "io.grpc.internal.Http2ClientStreamTransportState.transportTrailersReceived",
	"Comment": "called by subclasses for the terminal trailer metadata on a stream.",
	"Method": "void transportTrailersReceived(Metadata trailers){\r\n    Preconditions.checkNotNull(trailers, \"trailers\");\r\n    if (transportError == null && !headersReceived) {\r\n        transportError = validateInitialMetadata(trailers);\r\n        if (transportError != null) {\r\n            transportErrorMetadata = trailers;\r\n        }\r\n    }\r\n    if (transportError != null) {\r\n        transportError = transportError.augmentDescription(\"trailers: \" + trailers);\r\n        http2ProcessingFailed(transportError, false, transportErrorMetadata);\r\n    } else {\r\n        Status status = statusFromTrailers(trailers);\r\n        stripTransportDetails(trailers);\r\n        inboundTrailersReceived(trailers, status);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.util.UserError.abort",
	"Comment": "stop compilation immediately and report the message to the user.",
	"Method": "UserException abort(String message,UserException abort,String message,Throwable ex,UserException abort,Iterable<String> messages){\r\n    throw new UserException(messages);\r\n}"
}, {
	"Path": "io.grpc.MethodDescriptor.isSampledToLocalTracing",
	"Comment": "returns whether rpcs for this method may be sampled into the local tracing store.",
	"Method": "boolean isSampledToLocalTracing(){\r\n    return sampledToLocalTracing;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.CompilerDirectives.interpreterOnly",
	"Comment": "directive for the compiler that the given callable should only be executed in theinterpreter.",
	"Method": "void interpreterOnly(Runnable runnable,T interpreterOnly,Callable<T> callable){\r\n    return callable.call();\r\n}"
}, {
	"Path": "com.google.gson.JsonPrimitive.getAsInt",
	"Comment": "convenience method to get this element as a primitive integer.",
	"Method": "int getAsInt(){\r\n    return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString());\r\n}"
}, {
	"Path": "io.grpc.alts.HandshakerServiceChannel.getHandshakerChannelPoolForTesting",
	"Comment": "returns a fixed object pool of handshaker service channel for testing only.",
	"Method": "FixedObjectPool<ManagedChannel> getHandshakerChannelPoolForTesting(String handshakerAddress){\r\n    ThreadFactory clientThreadFactory = new DefaultThreadFactory(\"handshaker pool\", true);\r\n    ManagedChannel channel = NettyChannelBuilder.forTarget(handshakerAddress).directExecutor().eventLoopGroup(new NioEventLoopGroup(1, clientThreadFactory)).usePlaintext().build();\r\n    return new FixedObjectPool<ManagedChannel>(channel);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentationTest.testLazyProbe1",
	"Comment": "test that event nodes are created lazily on first execution.",
	"Method": "void testLazyProbe1(){\r\n    TestLazyProbe1.createCalls = 0;\r\n    TestLazyProbe1.onEnter = 0;\r\n    TestLazyProbe1.onReturnValue = 0;\r\n    TestLazyProbe1.onReturnExceptional = 0;\r\n    assureEnabled(engine.getInstruments().get(\"testLazyProbe1\"));\r\n    run(\"ROOT(DEFINE(foo, EXPRESSION))\");\r\n    run(\"ROOT(DEFINE(bar, ROOT(EXPRESSION,EXPRESSION)))\");\r\n    Assert.assertEquals(0, TestLazyProbe1.createCalls);\r\n    Assert.assertEquals(0, TestLazyProbe1.onEnter);\r\n    Assert.assertEquals(0, TestLazyProbe1.onReturnValue);\r\n    Assert.assertEquals(0, TestLazyProbe1.onReturnExceptional);\r\n    run(\"ROOT(CALL(foo))\");\r\n    Assert.assertEquals(1, TestLazyProbe1.createCalls);\r\n    Assert.assertEquals(1, TestLazyProbe1.onEnter);\r\n    Assert.assertEquals(1, TestLazyProbe1.onReturnValue);\r\n    Assert.assertEquals(0, TestLazyProbe1.onReturnExceptional);\r\n    run(\"ROOT(CALL(bar))\");\r\n    Assert.assertEquals(3, TestLazyProbe1.createCalls);\r\n    Assert.assertEquals(3, TestLazyProbe1.onEnter);\r\n    Assert.assertEquals(3, TestLazyProbe1.onReturnValue);\r\n    Assert.assertEquals(0, TestLazyProbe1.onReturnExceptional);\r\n    run(\"ROOT(CALL(bar))\");\r\n    Assert.assertEquals(3, TestLazyProbe1.createCalls);\r\n    Assert.assertEquals(5, TestLazyProbe1.onEnter);\r\n    Assert.assertEquals(5, TestLazyProbe1.onReturnValue);\r\n    Assert.assertEquals(0, TestLazyProbe1.onReturnExceptional);\r\n    run(\"ROOT(CALL(foo))\");\r\n    Assert.assertEquals(3, TestLazyProbe1.createCalls);\r\n    Assert.assertEquals(6, TestLazyProbe1.onEnter);\r\n    Assert.assertEquals(6, TestLazyProbe1.onReturnValue);\r\n    Assert.assertEquals(0, TestLazyProbe1.onReturnExceptional);\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.context.free.DefaultAnalysisContextPolicy.calleeContext",
	"Comment": "captures the context of a method invocation. since the analysis is not context sensitive, thecontext of the callee is the same as the caller context.",
	"Method": "DefaultAnalysisContext calleeContext(BigBang bb,AnalysisObject receiverObject,DefaultAnalysisContext callerContext,MethodTypeFlow callee){\r\n    assert callerContext.equals(emptyContext());\r\n    assert receiverObject.isContextInsensitiveObject();\r\n    return callerContext;\r\n}"
}, {
	"Path": "io.grpc.netty.NettyClientHandler.goingAway",
	"Comment": "handler for a goaway being received. fails any streams created after thelast known stream.",
	"Method": "void goingAway(Status status){\r\n    lifecycleManager.notifyShutdown(status);\r\n    final Status goAwayStatus = lifecycleManager.getShutdownStatus();\r\n    final int lastKnownStream = connection().local().lastStreamKnownByPeer();\r\n    try {\r\n        connection().forEachActiveStream(new Http2StreamVisitor() {\r\n            @Override\r\n            public boolean visit(Http2Stream stream) throws Http2Exception {\r\n                if (stream.id() > lastKnownStream) {\r\n                    NettyClientStream.TransportState clientStream = clientStream(stream);\r\n                    if (clientStream != null) {\r\n                        clientStream.transportReportStatus(goAwayStatus, RpcProgress.REFUSED, false, new Metadata());\r\n                    }\r\n                    stream.close();\r\n                }\r\n                return true;\r\n            }\r\n        });\r\n    } catch (Http2Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "io.grpc.netty.NettyClientHandler.goingAway",
	"Comment": "handler for a goaway being received. fails any streams created after thelast known stream.",
	"Method": "void goingAway(Status status){\r\n    if (stream.id() > lastKnownStream) {\r\n        NettyClientStream.TransportState clientStream = clientStream(stream);\r\n        if (clientStream != null) {\r\n            clientStream.transportReportStatus(goAwayStatus, RpcProgress.REFUSED, false, new Metadata());\r\n        }\r\n        stream.close();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.runtime.debug.value.LLVMDebugObject.toString",
	"Comment": "a representation of the current value of the referenced variable for the debugger to show.",
	"Method": "String toString(){\r\n    Object currentValue = getValue();\r\n    if (LLVMManagedPointer.isInstance(currentValue)) {\r\n        final LLVMManagedPointer managedPointer = LLVMManagedPointer.cast(currentValue);\r\n        final TruffleObject target = managedPointer.getObject();\r\n        String targetString;\r\n        if (target instanceof LLVMFunctionDescriptor) {\r\n            final LLVMFunctionDescriptor function = (LLVMFunctionDescriptor) target;\r\n            targetString = \"LLVM function \" + function.getName();\r\n        } else {\r\n            targetString = \"<managed pointer>\";\r\n        }\r\n        final long targetOffset = managedPointer.getOffset();\r\n        if (targetOffset != 0L) {\r\n            targetString = String.format(\"%s + %d byte%s\", targetString, targetOffset, targetOffset == 1L ? \"\" : \"s\");\r\n        }\r\n        currentValue = targetString;\r\n    }\r\n    return Objects.toString(currentValue);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.profiles.LongValueProfile.createIdentityProfile",
	"Comment": "returns a value profile that profiles the exact value of an long.",
	"Method": "LongValueProfile createIdentityProfile(){\r\n    if (Profile.isProfilingEnabled()) {\r\n        return Enabled.create();\r\n    } else {\r\n        return Disabled.INSTANCE;\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.test.polyglot.PolyglotCachingTest.testLanguageSourceInstanceIsEqualToEmbedder",
	"Comment": "tests that the outer source instance is never the same as the one passed in. that allows theouter source instance to be collected while the inner one is still referenced strongly. thegarbage collection of the outer source instance will trigger cleanup the cached calltargets.",
	"Method": "void testLanguageSourceInstanceIsEqualToEmbedder(){\r\n    AtomicReference<com.oracle.truffle.api.source.Source> innerSource = new AtomicReference(null);\r\n    ProxyLanguage.setDelegate(new ProxyLanguage() {\r\n        @Override\r\n        protected CallTarget parse(ParsingRequest request) throws Exception {\r\n            innerSource.set(request.getSource());\r\n            return Truffle.getRuntime().createCallTarget(RootNode.createConstantNode(\"\"));\r\n        }\r\n    });\r\n    Context c = Context.create();\r\n    Source source = Source.create(ProxyLanguage.ID, \"testSourceInstanceIsEqual\");\r\n    c.eval(source);\r\n    assertNotNull(innerSource.get());\r\n    Field f = Source.class.getDeclaredField(\"impl\");\r\n    f.setAccessible(true);\r\n    assertEquals(f.get(source), innerSource.get());\r\n    assertEquals(innerSource.get(), f.get(source));\r\n    assertNotSame(innerSource.get(), f.get(source));\r\n}"
}, {
	"Path": "com.oracle.truffle.api.test.polyglot.PolyglotCachingTest.testLanguageSourceInstanceIsEqualToEmbedder",
	"Comment": "tests that the outer source instance is never the same as the one passed in. that allows theouter source instance to be collected while the inner one is still referenced strongly. thegarbage collection of the outer source instance will trigger cleanup the cached calltargets.",
	"Method": "void testLanguageSourceInstanceIsEqualToEmbedder(){\r\n    innerSource.set(request.getSource());\r\n    return Truffle.getRuntime().createCallTarget(RootNode.createConstantNode(\"\"));\r\n}"
}, {
	"Path": "com.google.gson.stream.JsonWriter.setSerializeNulls",
	"Comment": "sets whether object members are serialized when their value is null.this has no impact on array elements. the default is true.",
	"Method": "void setSerializeNulls(boolean serializeNulls){\r\n    this.serializeNulls = serializeNulls;\r\n}"
}, {
	"Path": "com.google.gson.stream.JsonWriter.getSerializeNulls",
	"Comment": "returns true if object members are serialized when their value is null.this has no impact on array elements. the default is true.",
	"Method": "boolean getSerializeNulls(){\r\n    return serializeNulls;\r\n}"
}, {
	"Path": "com.google.gson.JsonElement.getAsLong",
	"Comment": "convenience method to get this element as a primitive long value.",
	"Method": "long getAsLong(){\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.DirectoryStorageTest.testLoadComponentMetadata",
	"Comment": "test of loadcomponentmetadata method, of class registrystorage.",
	"Method": "void testLoadComponentMetadata(){\r\n    copyDir(\"list1\", registryPath);\r\n    ComponentInfo info = storage.loadComponentMetadata(\"fastr\");\r\n    assertEquals(\"org.graalvm.fastr\", info.getId());\r\n    assertEquals(\"1.0\", info.getVersionString());\r\n    assertEquals(\"0.32\", info.getRequiredGraalValues().get(\"graalvm_version\"));\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentationTest.testInstrumentAll",
	"Comment": "test instrument all with any filter. ensure that root nodes are not tried to be instrumented.",
	"Method": "void testInstrumentAll(){\r\n    TestInstrumentAll1.onStatement = 0;\r\n    assureEnabled(engine.getInstruments().get(\"testInstrumentAll\"));\r\n    run(\"STATEMENT\");\r\n    Assert.assertEquals(2, TestInstrumentAll1.onStatement);\r\n}"
}, {
	"Path": "io.grpc.netty.TlsTest.clientRejectsUntrustedServerCert",
	"Comment": "tests that a client configured using grpcsslcontexts refuses to talk to a server that has anan untrusted certificate.",
	"Method": "void clientRejectsUntrustedServerCert(){\r\n    File serverCertFile = TestUtils.loadCert(\"badserver.pem\");\r\n    File serverPrivateKeyFile = TestUtils.loadCert(\"badserver.key\");\r\n    X509Certificate[] serverTrustedCaCerts = { TestUtils.loadX509Cert(\"ca.pem\") };\r\n    server = serverBuilder(0, serverCertFile, serverPrivateKeyFile, serverTrustedCaCerts).addService(new SimpleServiceImpl()).build().start();\r\n    File clientCertChainFile = TestUtils.loadCert(\"client.pem\");\r\n    File clientPrivateKeyFile = TestUtils.loadCert(\"client.key\");\r\n    X509Certificate[] clientTrustedCaCerts = { TestUtils.loadX509Cert(\"ca.pem\") };\r\n    channel = clientChannel(server.getPort(), clientContextBuilder.keyManager(clientCertChainFile, clientPrivateKeyFile).trustManager(clientTrustedCaCerts).build());\r\n    SimpleServiceGrpc.SimpleServiceBlockingStub client = SimpleServiceGrpc.newBlockingStub(channel);\r\n    try {\r\n        client.unaryRpc(SimpleRequest.getDefaultInstance());\r\n        fail(\"TLS handshake should have failed, but didn't; received RPC response\");\r\n    } catch (StatusRuntimeException e) {\r\n        assertEquals(Throwables.getStackTraceAsString(e), Status.Code.UNAVAILABLE, e.getStatus().getCode());\r\n    }\r\n}"
}, {
	"Path": "io.grpc.examples.helloworld.HelloWorldClientTest.greet_messageDeliveredToServer",
	"Comment": "to test the client, call from the client against the fake server, and verify behaviors or statechanges from the server side.",
	"Method": "void greet_messageDeliveredToServer(){\r\n    ArgumentCaptor<HelloRequest> requestCaptor = ArgumentCaptor.forClass(HelloRequest.class);\r\n    client.greet(\"test name\");\r\n    verify(serviceImpl).sayHello(requestCaptor.capture(), Matchers.<StreamObserver<HelloReply>>any());\r\n    assertEquals(\"test name\", requestCaptor.getValue().getName());\r\n}"
}, {
	"Path": "io.grpc.stub.AbstractStub.withMaxOutboundMessageSize",
	"Comment": "returns a new stub that limits the maximum acceptable message size to send a remote peer.",
	"Method": "S withMaxOutboundMessageSize(int maxSize){\r\n    return build(channel, callOptions.withMaxOutboundMessageSize(maxSize));\r\n}"
}, {
	"Path": "com.oracle.truffle.api.CompilerDirectives.inInterpreter",
	"Comment": "returns a boolean value indicating whether the method is executed in the interpreter.",
	"Method": "boolean inInterpreter(){\r\n    return true;\r\n}"
}, {
	"Path": "io.grpc.testing.protobuf.SimpleServiceGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "SimpleServiceStub newStub(io.grpc.Channel channel){\r\n    return new SimpleServiceStub(channel);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.test.polyglot.PolyglotCachingTest.testEngineStrongContextFree",
	"Comment": "test that the language instance is correctly freed if a context is no longer referenced, butwas not closed.",
	"Method": "void testEngineStrongContextFree(){\r\n    Assume.assumeFalse(\"This test is too slow in fastdebug.\", System.getProperty(\"java.vm.version\").contains(\"fastdebug\"));\r\n    setupTestLang(true);\r\n    Engine engine = Engine.create();\r\n    Set<ProxyLanguage> usedInstances = new HashSet();\r\n    GCUtils.assertObjectsCollectible((iteration) -> {\r\n        Context context = Context.newBuilder().engine(engine).build();\r\n        context.eval(ReuseLanguage.ID, String.valueOf(iteration));\r\n        usedInstances.add(lastLanguage);\r\n        return context;\r\n    });\r\n    Assert.assertTrue(String.valueOf(usedInstances.size()), usedInstances.size() < GCUtils.GC_TEST_ITERATIONS);\r\n    engine.close();\r\n}"
}, {
	"Path": "com.oracle.svm.core.util.TimeUtils.maybeFatallyTooLong",
	"Comment": "have i taken too long? returns true if i have, false otherwise.",
	"Method": "boolean maybeFatallyTooLong(long startNanos,long failureNanos,String reason){\r\n    if (0 < failureNanos) {\r\n        final long nanosSinceStart = TimeUtils.nanoSecondsSince(startNanos);\r\n        if (TimeUtils.nanoTimeLessThan(failureNanos, nanosSinceStart)) {\r\n            Log.log().string(\"[TimeUtils.maybeFatallyTooLong:\").string(\"  startNanos: \").signed(startNanos).string(\"  failureNanos: \").signed(failureNanos).string(\" < nanosSinceStart: \").signed(nanosSinceStart).string(\"  reason: \").string(reason).string(\"]\").newline();\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.google.common.collect.HashBiMap.removeEntryValueHashKnown",
	"Comment": "removes the entry at the specified index, given the hash of its value.",
	"Method": "void removeEntryValueHashKnown(int entry,int valueHash){\r\n    removeEntry(entry, Hashing.smearedHash(keys[entry]), valueHash);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.RootNodeBits.isSourceSectionsHierachical",
	"Comment": "returns true if source the source sections of the root node are all contained within thebounds of the root source section.",
	"Method": "boolean isSourceSectionsHierachical(int bits){\r\n    return (bits & SOURCE_SECTION_HIERARCHICAL) > 0;\r\n}"
}, {
	"Path": "io.grpc.okhttp.OkHttpTlsUpgrader.canonicalizeHost",
	"Comment": "converts a host from uri to x509 format.ipv6 host addresses derived from uris are enclosed in square brackets per rfc2732, butomit these brackets in x509 certificate subjectaltname extensions per rfc5280.",
	"Method": "String canonicalizeHost(String host){\r\n    if (host.startsWith(\"[\") && host.endsWith(\"]\")) {\r\n        return host.substring(1, host.length() - 1);\r\n    }\r\n    return host;\r\n}"
}, {
	"Path": "com.google.gson.stream.JsonWriter.beforeValue",
	"Comment": "inserts any necessary separators and whitespace before a literal value,inline array, or inline object. also adjusts the stack to expect either aclosing bracket or another element.",
	"Method": "void beforeValue(){\r\n    switch(peek()) {\r\n        case NONEMPTY_DOCUMENT:\r\n            if (!lenient) {\r\n                throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n            }\r\n        case EMPTY_DOCUMENT:\r\n            replaceTop(NONEMPTY_DOCUMENT);\r\n            break;\r\n        case EMPTY_ARRAY:\r\n            replaceTop(NONEMPTY_ARRAY);\r\n            newline();\r\n            break;\r\n        case NONEMPTY_ARRAY:\r\n            out.append(',');\r\n            newline();\r\n            break;\r\n        case DANGLING_NAME:\r\n            out.append(separator);\r\n            replaceTop(NONEMPTY_OBJECT);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.log.Log.indent",
	"Comment": "change current amount of indentation, and then print a newline.",
	"Method": "Log indent(boolean addOrRemove){\r\n    return redent(addOrRemove).newline();\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.HeapImpl.getUsedObjectBytes",
	"Comment": "return the size, in bytes, of the actual used memory, not the committed memory.",
	"Method": "UnsignedWord getUsedObjectBytes(){\r\n    final Space youngSpace = getYoungGeneration().getSpace();\r\n    final UnsignedWord youngBytes = youngSpace.getObjectBytes();\r\n    final Space fromSpace = getOldGeneration().getFromSpace();\r\n    final UnsignedWord fromBytes = fromSpace.getObjectBytes();\r\n    final Space pinnedSpace = getOldGeneration().getPinnedFromSpace();\r\n    final UnsignedWord pinnedBytes = pinnedSpace.getObjectBytes();\r\n    final UnsignedWord result = youngBytes.add(fromBytes).add(pinnedBytes);\r\n    return result;\r\n}"
}, {
	"Path": "io.grpc.internal.KeepAliveManager.clampKeepAliveTimeoutInNanos",
	"Comment": "bumps keepalive timeout to 10 milliseconds if the specified value was smaller than that.",
	"Method": "long clampKeepAliveTimeoutInNanos(long keepAliveTimeoutInNanos){\r\n    return Math.max(keepAliveTimeoutInNanos, MIN_KEEPALIVE_TIMEOUT_NANOS);\r\n}"
}, {
	"Path": "io.grpc.alts.AltsChannelBuilder.addTargetServiceAccount",
	"Comment": "adds an expected target service accounts. one of the added service accounts should match peerservice account in the handshaker result. otherwise, the handshake fails.",
	"Method": "AltsChannelBuilder addTargetServiceAccount(String targetServiceAccount){\r\n    targetServiceAccountsBuilder.add(targetServiceAccount);\r\n    return this;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.FirstObjectTable.getPointerAtOffset",
	"Comment": "turn an entry from the table into a pointer into a memory region.",
	"Method": "Pointer getPointerAtOffset(Pointer memory,UnsignedWord currentIndex,int currentEntry){\r\n    assert isMemoryOffsetEntry(currentEntry) : \"Entry out of bounds.\";\r\n    final UnsignedWord indexOffset = indexToMemoryOffset(currentIndex);\r\n    final UnsignedWord entryOffset = entryToMemoryOffset(currentEntry);\r\n    return memory.add(indexOffset).subtract(entryOffset);\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.ComponentPackageLoaderTest.testRequiredKeys",
	"Comment": "checks that the parser rejects components, if they have some keys required.",
	"Method": "void testRequiredKeys(){\r\n    info();\r\n    Properties save = new Properties();\r\n    save.putAll(this.data);\r\n    List<String> sorted = new ArrayList((Set) save.keySet());\r\n    Collections.sort(sorted);\r\n    for (String s : save.stringPropertyNames()) {\r\n        data = new Properties();\r\n        data.putAll(save);\r\n        data.remove(s);\r\n        try {\r\n            info();\r\n            Assert.fail(\"Pasrer must reject component without key \" + s);\r\n        } catch (MetadataException ex) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.tck.DebuggerTester.getDebugger",
	"Comment": "get the debugger instance associated with the current engine.",
	"Method": "Debugger getDebugger(){\r\n    return engine.getInstruments().get(\"debugger\").lookup(Debugger.class);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.TruffleLanguage.lookup",
	"Comment": "looks an additional language service up. by default it checks if the language itself isimplementing the requested class and if so, it returns this.in future this method can be made protected and overridable by language implementors tocreate more dynamic service system.",
	"Method": "T lookup(Class<T> clazz,T lookup,Class<T> type,S lookup,InstrumentInfo instrument,Class<S> type,S lookup,LanguageInfo language,Class<S> type,S lookup,TruffleLanguage<?> language,Class<S> type){\r\n    if (clazz.isInterface()) {\r\n        if (clazz.isInstance(this)) {\r\n            return clazz.cast(this);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.nodes.expression.SLLogicalAndNode.execute",
	"Comment": "only if left and right value are true the result of the logical and is true. ifthe second parameter is not evaluated, false is provided.",
	"Method": "boolean execute(boolean left,boolean right){\r\n    return left && right;\r\n}"
}, {
	"Path": "com.google.gson.JsonArray.getAsShort",
	"Comment": "convenience method to get this array as a primitive short if it contains a single element.",
	"Method": "short getAsShort(){\r\n    if (elements.size() == 1) {\r\n        return elements.get(0).getAsShort();\r\n    }\r\n    throw new IllegalStateException();\r\n}"
}, {
	"Path": "com.google.gson.JsonPrimitive.getAsDouble",
	"Comment": "convenience method to get this element as a primitive double.",
	"Method": "double getAsDouble(){\r\n    return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString());\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.UnaryCallQpsBenchmark.unary",
	"Comment": "measure throughput of unary calls. the calls are already running, we just observe a counterof received responses.",
	"Method": "void unary(AdditionalCounters counters){\r\n    Thread.sleep(1001);\r\n}"
}, {
	"Path": "io.grpc.okhttp.OkHttpClientTransport.removePendingStream",
	"Comment": "removes given pending stream, used when a pending stream is cancelled.",
	"Method": "void removePendingStream(OkHttpClientStream pendingStream){\r\n    pendingStreams.remove(pendingStream);\r\n    maybeClearInUse(pendingStream);\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceImpl.interceptors",
	"Comment": "returns interceptors necessary for full service implementation.",
	"Method": "List<ServerInterceptor> interceptors(){\r\n    return Arrays.asList(echoRequestHeadersInterceptor(Util.METADATA_KEY), echoRequestMetadataInHeaders(Util.ECHO_INITIAL_METADATA_KEY), echoRequestMetadataInTrailers(Util.ECHO_TRAILING_METADATA_KEY));\r\n}"
}, {
	"Path": "com.google.gson.JsonArray.remove",
	"Comment": "removes the first occurrence of the specified element from this array, if it is present.if the array does not contain the element, it is unchanged.",
	"Method": "boolean remove(JsonElement element,JsonElement remove,int index){\r\n    return elements.remove(index);\r\n}"
}, {
	"Path": "com.oracle.svm.core.util.TimeUtils.delayNanos",
	"Comment": "turn an absolute deadline in milliseconds, or a relative delay in nanoseconds, into arelative delay in nanoseconds.",
	"Method": "long delayNanos(boolean isAbsolute,long time){\r\n    if (isAbsolute) {\r\n        return millisToNanos(time - System.currentTimeMillis());\r\n    } else {\r\n        return time;\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.thread.VMOperationControl.getVMOperationControl",
	"Comment": "there is only one vmoperation controller. constructed during native image construction.",
	"Method": "VMOperationControl getVMOperationControl(){\r\n    return ImageSingletons.lookup(VMOperationControl.class);\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceImpl.toChunkQueue",
	"Comment": "breaks down the request and creates a queue of response chunks for the given request.",
	"Method": "Queue<Chunk> toChunkQueue(StreamingOutputCallRequest request){\r\n    Queue<Chunk> chunkQueue = new ArrayDeque<Chunk>();\r\n    int offset = 0;\r\n    for (ResponseParameters params : request.getResponseParametersList()) {\r\n        chunkQueue.add(new Chunk(params.getIntervalUs(), offset, params.getSize()));\r\n        offset = (offset + params.getSize()) % compressableBuffer.size();\r\n    }\r\n    return chunkQueue;\r\n}"
}, {
	"Path": "com.oracle.svm.core.code.FrameInfoQueryResult.getEncodedBci",
	"Comment": "returns an encoding of the bytecode index itself plus the duringcall and rethrowexceptionflags.",
	"Method": "long getEncodedBci(){\r\n    return encodedBci;\r\n}"
}, {
	"Path": "com.google.gson.stream.JsonReader.hasNext",
	"Comment": "returns true if the current array or object has another element.",
	"Method": "boolean hasNext(){\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.TypeFlow.addOriginalObserver",
	"Comment": "adds an observer, if not already present, without triggering update.",
	"Method": "boolean addOriginalObserver(BigBang bb,TypeFlow<?> observer){\r\n    return addObserver(bb, observer, false, false);\r\n}"
}, {
	"Path": "com.oracle.truffle.tools.profiler.StackTraceEntry.isInlined",
	"Comment": "returns true if this stack entry was executed in compiled mode and was inlinedin a parent stack entry at the time when the stack trace was captured, elsefalse.",
	"Method": "boolean isInlined(){\r\n    return state == STATE_COMPILED;\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.FileDownloaderTest.testDownloadSlowProxy",
	"Comment": "checks that slow proxy will be used although the direct connection has failed already.",
	"Method": "void testDownloadSlowProxy(){\r\n    URL clu = getClass().getResource(\"data/truffleruby2.jar\");\r\n    URL u = new URL(\"test://graalvm.io/download/truffleruby.zip\");\r\n    ChunkedConnection proxyConnect = new ChunkedConnection(u, clu.openConnection()) {\r\n        @Override\r\n        public void connect() throws IOException {\r\n            try {\r\n                Thread.sleep(1000);\r\n            } catch (InterruptedException ex) {\r\n            }\r\n            super.connect();\r\n        }\r\n    };\r\n    Handler.bindProxy(u.toString(), proxyConnect);\r\n    Check check = new Check();\r\n    delegateFeedback(check);\r\n    FileDownloader dn = new FileDownloader(\"test\", u, this);\r\n    verbose = true;\r\n    dn.setVerbose(true);\r\n    dn.setDisplayProgress(true);\r\n    dn.envHttpProxy = \"http://localhost:11111\";\r\n    dn.envHttpsProxy = \"http://localhost:11111\";\r\n    synchronized (proxyConnect) {\r\n        proxyConnect.nextChunk = 130 * 1024;\r\n        proxyConnect.readException = new FileNotFoundException();\r\n    }\r\n    exception.expect(FileNotFoundException.class);\r\n    dn.download();\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.FileDownloaderTest.testDownloadSlowProxy",
	"Comment": "checks that slow proxy will be used although the direct connection has failed already.",
	"Method": "void testDownloadSlowProxy(){\r\n    try {\r\n        Thread.sleep(1000);\r\n    } catch (InterruptedException ex) {\r\n    }\r\n    super.connect();\r\n}"
}, {
	"Path": "com.oracle.svm.core.heap.NoAllocationVerifier.exit",
	"Comment": "a guard to place before an allocation, giving the call site and the allocation type.",
	"Method": "void exit(String callSite,String typeName){\r\n    Log.log().string(\"[NoAllocationVerifier detected disallowed allocation: \").string(callSite).string(\": \").string(typeName).newline();\r\n    if (openVerifiers.get() != null) {\r\n        Log.log().string(\"[NoAllocationVerifier stack: \");\r\n        for (NoAllocationVerifier rest = openVerifiers.get(); rest != null; rest = rest.next) {\r\n            Log.log().newline().string(\"  \").string(\"  reason: \").string(rest.reason).newline();\r\n        }\r\n        Log.log().string(\"]\").newline();\r\n    }\r\n    Log.log().string(\"]\").newline();\r\n    throw VMError.shouldNotReachHere(ERROR_MSG);\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.UnaryCallQpsBenchmark.main",
	"Comment": "useful for triggering a subset of the benchmark in a profiler.",
	"Method": "void main(String[] argv){\r\n    UnaryCallQpsBenchmark bench = new UnaryCallQpsBenchmark();\r\n    bench.setup();\r\n    Thread.sleep(30000);\r\n    bench.teardown();\r\n    System.exit(0);\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.DirectoryStorageTest.testUpdateReplacedFiles",
	"Comment": "test of updatereplacedfiles method, of class registrystorage.",
	"Method": "void testUpdateReplacedFiles(){\r\n    Map<String, Collection<String>> files = new HashMap();\r\n    files.put(\"whatever/lib.jar\", Arrays.asList(\"fastr\", \"sulong\"));\r\n    storage.updateReplacedFiles(files);\r\n    Path regPath = registryPath.resolve(SystemUtils.fileName(\"replaced-files.properties\"));\r\n    Path goldenPath = dataFile(\"golden-replaced-files.properties\");\r\n    List<String> lines1 = Files.readAllLines(goldenPath);\r\n    List<String> lines2 = Files.readAllLines(regPath).stream().filter((s) -> !s.startsWith(\"#\")).collect(Collectors.toList());\r\n    assertEquals(lines1, lines2);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebugStackTraceElement.getSourceSection",
	"Comment": "returns the source section location of this trace element. the source section isnull if the source location is not available.",
	"Method": "SourceSection getSourceSection(){\r\n    Node node = traceElement.getLocation();\r\n    if (node != null) {\r\n        return session.resolveSection(node.getEncapsulatingSourceSection());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.typestate.TypeStateUtils.isContextInsensitiveTypeState",
	"Comment": "check if a type state contains only context insensitive objects, i.e., the only informationit stores is the set of types.",
	"Method": "boolean isContextInsensitiveTypeState(TypeState state){\r\n    for (AnalysisObject object : state.objects()) {\r\n        if (!object.isContextInsensitiveObject()) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.oracle.svm.core.option.SubstrateOptionsParser.parseHostedOption",
	"Comment": "parses a option at image build time. when the printflags option is found prints all optionsand interrupts compilation.",
	"Method": "boolean parseHostedOption(String optionPrefix,SortedMap<String, OptionDescriptor> options,EconomicMap<OptionKey<?>, Object> valuesMap,BooleanOptionFormat booleanOptionFormat,Set<String> errors,String arg,PrintStream out){\r\n    if (!arg.startsWith(optionPrefix)) {\r\n        return false;\r\n    }\r\n    OptionParseResult optionParseResult = SubstrateOptionsParser.parseOption(options, arg.substring(optionPrefix.length()), valuesMap, optionPrefix, booleanOptionFormat);\r\n    if (optionParseResult.printFlags()) {\r\n        SubstrateOptionsParser.printFlags(optionParseResult::matchesFlagsHosted, options, optionPrefix, out);\r\n        throw new InterruptImageBuilding();\r\n    }\r\n    if (!optionParseResult.isValid()) {\r\n        errors.add(optionParseResult.getError());\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.oracle.svm.core.code.FrameInfoQueryResult.getSourceReference",
	"Comment": "returns the name and source code location of the method, for debugging purposes only.",
	"Method": "StackTraceElement getSourceReference(){\r\n    final String className = sourceClassName != null ? sourceClassName : \"\";\r\n    return new StackTraceElement(className, sourceMethodName, sourceFileName, sourceLineNumber);\r\n}"
}, {
	"Path": "com.oracle.truffle.polyglot.PolyglotContextImpl.initializeStaticContext",
	"Comment": "marks a context used globally. potentially invalidating the global single context assumption.",
	"Method": "void initializeStaticContext(PolyglotContextImpl context){\r\n    SingleContextState state = singleContextState;\r\n    if (state.singleContextAssumption.isValid()) {\r\n        synchronized (state) {\r\n            if (state.singleContextAssumption.isValid()) {\r\n                if (state.singleContext != null) {\r\n                    state.singleContextAssumption.invalidate();\r\n                    state.singleContext = null;\r\n                } else {\r\n                    state.singleContext = context;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.reflect.TypeToken.isAssignableFrom",
	"Comment": "private helper function that performs some assignability checks forthe provided genericarraytype.",
	"Method": "boolean isAssignableFrom(Class<?> cls,boolean isAssignableFrom,Type from,boolean isAssignableFrom,TypeToken<?> token,boolean isAssignableFrom,Type from,GenericArrayType to,boolean isAssignableFrom,Type from,ParameterizedType to,Map<String, Type> typeVarMap){\r\n    if (from == null) {\r\n        return false;\r\n    }\r\n    if (to.equals(from)) {\r\n        return true;\r\n    }\r\n    Class<?> clazz = $Gson$Types.getRawType(from);\r\n    ParameterizedType ptype = null;\r\n    if (from instanceof ParameterizedType) {\r\n        ptype = (ParameterizedType) from;\r\n    }\r\n    if (ptype != null) {\r\n        Type[] tArgs = ptype.getActualTypeArguments();\r\n        TypeVariable<?>[] tParams = clazz.getTypeParameters();\r\n        for (int i = 0; i < tArgs.length; i++) {\r\n            Type arg = tArgs[i];\r\n            TypeVariable<?> var = tParams[i];\r\n            while (arg instanceof TypeVariable<?>) {\r\n                TypeVariable<?> v = (TypeVariable<?>) arg;\r\n                arg = typeVarMap.get(v.getName());\r\n            }\r\n            typeVarMap.put(var.getName(), arg);\r\n        }\r\n        if (typeEquals(ptype, to, typeVarMap)) {\r\n            return true;\r\n        }\r\n    }\r\n    for (Type itype : clazz.getGenericInterfaces()) {\r\n        if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\r\n            return true;\r\n        }\r\n    }\r\n    Type sType = clazz.getGenericSuperclass();\r\n    return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.meta.AnalysisType.getReferencedTypes",
	"Comment": "returns the list of referenced types, i.e., concrete field types or array elements typesdiscovered by the static analysis.since this list is not updated during the analysis, for complete results this should only becalled when the base analysis has finished.",
	"Method": "List<AnalysisType> getReferencedTypes(BigBang bb){\r\n    if (referencedTypes == null) {\r\n        Set<AnalysisType> referencedTypesSet = new HashSet();\r\n        if (this.isArray()) {\r\n            if (this.getContextInsensitiveAnalysisObject().isObjectArray()) {\r\n                for (AnalysisType type : getContextInsensitiveAnalysisObject().getArrayElementsFlow(bb, false).getState().types()) {\r\n                    type.getTypeFlow(bb, false).getState().types().forEach(referencedTypesSet::add);\r\n                }\r\n            }\r\n        } else {\r\n            for (AnalysisField field : getInstanceFields(true)) {\r\n                TypeState state = field.getInstanceFieldTypeState();\r\n                if (!state.isUnknown()) {\r\n                    for (AnalysisType type : state.types()) {\r\n                        type.getTypeFlow(bb, false).getState().types().forEach(referencedTypesSet::add);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        referencedTypes = new ArrayList(referencedTypesSet);\r\n    }\r\n    return referencedTypes;\r\n}"
}, {
	"Path": "com.google.gson.reflect.TypeToken.matches",
	"Comment": "checks if two types are the same or are equivalent under a variable mappinggiven in the type map that was provided.",
	"Method": "boolean matches(Type from,Type to,Map<String, Type> typeMap){\r\n    return to.equals(from) || (from instanceof TypeVariable && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\r\n}"
}, {
	"Path": "com.oracle.svm.core.c.CGlobalDataFactory.createWord",
	"Comment": "create a single word that is initialized to the specified value.",
	"Method": "CGlobalData<T> createWord(WordBase initialValue,CGlobalData<T> createWord,WordBase initialValue,String symbolName,CGlobalData<T> createWord,CGlobalData<T> createWord,String symbolName){\r\n    return new CGlobalDataImpl(symbolName, () -> ConfigurationValues.getTarget().wordSize);\r\n}"
}, {
	"Path": "com.google.gson.JsonPrimitive.getAsShort",
	"Comment": "convenience method to get this element as a primitive short.",
	"Method": "short getAsShort(){\r\n    return isNumber() ? getAsNumber().shortValue() : Short.parseShort(getAsString());\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.UnaryCallQpsBenchmark.setup",
	"Comment": "setup with direct executors, small payloads and a large flow control window.",
	"Method": "void setup(){\r\n    super.setup(ExecutorType.DIRECT, ExecutorType.DIRECT, MessageSize.SMALL, MessageSize.SMALL, FlowWindowSize.LARGE, ChannelType.NIO, maxConcurrentStreams, channelCount);\r\n    callCounter = new AtomicLong();\r\n    completed = new AtomicBoolean();\r\n    startUnaryCalls(maxConcurrentStreams, callCounter, completed, 1);\r\n}"
}, {
	"Path": "io.grpc.cronet.CronetChannelBuilder.forAddress",
	"Comment": "creates a new builder for the given server host, port and cronetengine.",
	"Method": "CronetChannelBuilder forAddress(String host,int port,CronetEngine cronetEngine,CronetChannelBuilder forAddress,String name,int port){\r\n    throw new UnsupportedOperationException(\"call forAddress(String, int, CronetEngine) instead\");\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.DirectoryStorageTest.testMetaToProperties",
	"Comment": "test of metatoproperties method, of class registrystorage.",
	"Method": "void testMetaToProperties(){\r\n    ComponentInfo info = new ComponentInfo(\"x\", \"y\", \"2.0\");\r\n    info.addRequiredValue(\"a\", \"b\");\r\n    Properties props = storage.metaToProperties(info);\r\n    assertEquals(\"x\", props.getProperty(BundleConstants.BUNDLE_ID));\r\n    assertEquals(\"y\", props.getProperty(BundleConstants.BUNDLE_NAME));\r\n    assertEquals(\"2.0\", props.getProperty(BundleConstants.BUNDLE_VERSION));\r\n    assertEquals(\"b\", props.getProperty(BundleConstants.BUNDLE_REQUIRED + \"-a\"));\r\n}"
}, {
	"Path": "com.oracle.truffle.api.CompilerDirectives.transferToInterpreter",
	"Comment": "directive for the compiler to discontinue compilation at this code position and insteadinsert a transfer to the interpreter.",
	"Method": "void transferToInterpreter(){\r\n    if (inInterpreter()) {\r\n        Truffle.getRuntime().notifyTransferToInterpreter();\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.HeapChunk.walkObjectsFrom",
	"Comment": "apply an objectvisitor to all the objects in the given heapchunk.",
	"Method": "boolean walkObjectsFrom(Header<?> that,Pointer offset,ObjectVisitor visitor){\r\n    final Log trace = Log.noopLog().string(\"[HeapChunk.walkObjectsFrom:\");\r\n    trace.string(\"  that: \").hex(that).string(\"  offset: \").hex(offset).string(\"  getTop(): \").hex(that.getTop());\r\n    Object obj = (offset.belowThan(that.getTop()) ? offset.toObject() : null);\r\n    while (obj != null) {\r\n        assert walkObjectsFromAssert(obj, that, offset) : \"HeapChunk.walkObjectsFrom: hub fails to verify.\";\r\n        trace.newline().string(\"  o: \").object(obj).newline();\r\n        if (!visitor.visitObjectInline(obj)) {\r\n            trace.string(\"  visitObject fails\").string(\"  returns false\").string(\"]\").newline();\r\n            return false;\r\n        }\r\n        obj = getNextObject(that, obj);\r\n    }\r\n    trace.string(\"  returns true\").string(\"]\").newline();\r\n    return true;\r\n}"
}, {
	"Path": "io.grpc.internal.ConnectivityStateManager.getState",
	"Comment": "gets the current connectivity state of the channel. this method is threadsafe.",
	"Method": "ConnectivityState getState(){\r\n    ConnectivityState stateCopy = state;\r\n    if (stateCopy == null) {\r\n        throw new UnsupportedOperationException(\"Channel state API is not implemented\");\r\n    }\r\n    return stateCopy;\r\n}"
}, {
	"Path": "io.grpc.grpclb.GrpclbClientLoadRecorder.recordDroppedRequest",
	"Comment": "records that a request has been dropped as instructed by the remote balancer.",
	"Method": "void recordDroppedRequest(String token){\r\n    callsStartedUpdater.getAndIncrement(this);\r\n    callsFinishedUpdater.getAndIncrement(this);\r\n    synchronized (this) {\r\n        LongHolder holder;\r\n        if ((holder = callsDroppedPerToken.get(token)) == null) {\r\n            callsDroppedPerToken.put(token, (holder = new LongHolder()));\r\n        }\r\n        holder.num++;\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.heap.FeebleReferenceList.remove",
	"Comment": "removes the next reference object in this queue, blocking until either one becomes availableor the given timeout period expires.",
	"Method": "FeebleReference<? extends T> remove(long timeoutMillis,FeebleReference<? extends T> remove){\r\n    return remove(0L);\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.image.NativeImageHeap.writeHeap",
	"Comment": "write the model of the native image heap to the relocatablebuffers that represent the nativeimage.",
	"Method": "void writeHeap(DebugContext debug,RelocatableBuffer roBuffer,RelocatableBuffer rwBuffer){\r\n    try (Indent perHeapIndent = debug.logAndIndent(\"BootImageHeap.writeHeap:\")) {\r\n        for (ObjectInfo info : objects.values()) {\r\n            assert !blacklist.contains(info.getObject());\r\n            writeObject(info, roBuffer, rwBuffer);\r\n        }\r\n        writeStaticFields(rwBuffer);\r\n        patchPartitionBoundaries(debug, roBuffer, rwBuffer);\r\n    }\r\n    if (NativeImageOptions.PrintHeapHistogram.getValue()) {\r\n        ObjectGroupHistogram.print(this);\r\n        readOnlyPrimitive.printHistogram();\r\n        readOnlyReference.printHistogram();\r\n        readOnlyRelocatable.printHistogram();\r\n        writablePrimitive.printHistogram();\r\n        writableReference.printHistogram();\r\n    }\r\n    if (NativeImageOptions.PrintImageHeapPartitionSizes.getValue()) {\r\n        readOnlyPrimitive.printSize();\r\n        readOnlyReference.printSize();\r\n        readOnlyRelocatable.printSize();\r\n        writablePrimitive.printSize();\r\n        writableReference.printSize();\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.DirectoryStorageTest.testDeleteComponent",
	"Comment": "test of deletecomponent method, of class registrystorage.",
	"Method": "void testDeleteComponent(){\r\n    copyDir(\"list2\", registryPath);\r\n    storage.deleteComponent(\"fastr\");\r\n    Path fastrComp = registryPath.resolve(SystemUtils.fileName(\"fastr.component\"));\r\n    Path fastrList = registryPath.resolve(SystemUtils.fileName(\"fastr.filelist\"));\r\n    assertFalse(Files.exists(fastrComp));\r\n    assertFalse(Files.exists(fastrList));\r\n    storage.deleteComponent(\"sulong\");\r\n    Path sulongComp = registryPath.resolve(SystemUtils.fileName(\"sulong.component\"));\r\n    assertFalse(Files.exists(sulongComp));\r\n    storage.deleteComponent(\"leftover\");\r\n    Path leftoverList = registryPath.resolve(SystemUtils.fileName(\"leftover.filelist\"));\r\n    assertFalse(Files.exists(leftoverList));\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.typestate.TypeStateUtils.arraysIntersection",
	"Comment": "returns a list containing the intersection of the two object arrays.",
	"Method": "AnalysisObject[] arraysIntersection(BigBang bb,AnalysisObject[] a1,AnalysisObject[] a2){\r\n    assert a1.length <= a2.length : \"Intersection is commutative, must call it with a1 being the shorter array\";\r\n    if (a1 == a2) {\r\n        return a1;\r\n    }\r\n    int idx1 = 0;\r\n    int idx2 = 0;\r\n    while (idx2 < a2.length) {\r\n        AnalysisObject o1 = a1[idx1];\r\n        AnalysisObject o2 = a2[idx2];\r\n        if (o2.getId() < o1.getId()) {\r\n            idx2++;\r\n        } else if (o1.equals(o2)) {\r\n            idx1++;\r\n            idx2++;\r\n            if (idx1 == a1.length) {\r\n                return a1;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    List<AnalysisObject> rList = new ArrayList(a1.length);\r\n    rList.addAll(Arrays.asList(a1).subList(0, idx1));\r\n    while (idx1 < a1.length && idx2 < a2.length) {\r\n        AnalysisObject o1 = a1[idx1];\r\n        AnalysisObject o2 = a2[idx2];\r\n        if (o1.equals(o2)) {\r\n            rList.add(o1);\r\n            idx1++;\r\n            idx2++;\r\n        } else {\r\n            assert o1.getId() != o2.getId();\r\n            if (o1.getId() < o2.getId()) {\r\n                idx1++;\r\n            } else {\r\n                idx2++;\r\n            }\r\n        }\r\n    }\r\n    assert rList.size() <= a1.length && rList.size() <= a2.length;\r\n    assert !PointstoOptions.LimitObjectArrayLength.getValue(bb.getOptions()) || rList.size() <= PointstoOptions.MaxObjectSetSize.getValue(bb.getOptions());\r\n    if (rList.size() == 0) {\r\n        return AnalysisObject.EMPTY_ARRAY;\r\n    } else {\r\n        AnalysisObject[] result = rList.toArray(new AnalysisObject[rList.size()]);\r\n        assert !Arrays.equals(result, a1) && !Arrays.equals(result, a2);\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "io.grpc.netty.TlsTest.basicClientServerIntegrationTest",
	"Comment": "tests that a client and a server configured using grpcsslcontexts can successfullycommunicate with each other.",
	"Method": "void basicClientServerIntegrationTest(){\r\n    File serverCertFile = TestUtils.loadCert(\"server1.pem\");\r\n    File serverPrivateKeyFile = TestUtils.loadCert(\"server1.key\");\r\n    X509Certificate[] serverTrustedCaCerts = { TestUtils.loadX509Cert(\"ca.pem\") };\r\n    server = serverBuilder(0, serverCertFile, serverPrivateKeyFile, serverTrustedCaCerts).addService(new SimpleServiceImpl()).build().start();\r\n    File clientCertChainFile = TestUtils.loadCert(\"client.pem\");\r\n    File clientPrivateKeyFile = TestUtils.loadCert(\"client.key\");\r\n    X509Certificate[] clientTrustedCaCerts = { TestUtils.loadX509Cert(\"ca.pem\") };\r\n    channel = clientChannel(server.getPort(), clientContextBuilder.keyManager(clientCertChainFile, clientPrivateKeyFile).trustManager(clientTrustedCaCerts).build());\r\n    SimpleServiceGrpc.SimpleServiceBlockingStub client = SimpleServiceGrpc.newBlockingStub(channel);\r\n    client.unaryRpc(SimpleRequest.getDefaultInstance());\r\n}"
}, {
	"Path": "io.grpc.internal.MessageFramer.close",
	"Comment": "flushes and closes the framer and releases any buffers. after the framer is closed ordisposed, additional calls to this method will have no affect.",
	"Method": "void close(){\r\n    if (!isClosed()) {\r\n        closed = true;\r\n        if (buffer != null && buffer.readableBytes() == 0) {\r\n            releaseBuffer();\r\n        }\r\n        commitToSink(true, true);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.test.util.ProcessUtil.concatCommand",
	"Comment": "concats a command by introducing whitespaces between the array elements.",
	"Method": "String concatCommand(Object[] command){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < command.length; i++) {\r\n        if (i != 0) {\r\n            sb.append(\" \");\r\n        }\r\n        sb.append(command[i]);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "io.grpc.MethodDescriptor.generateFullMethodName",
	"Comment": "generate the fully qualified method name.this matches the the name",
	"Method": "String generateFullMethodName(String fullServiceName,String methodName){\r\n    return checkNotNull(fullServiceName, \"fullServiceName\") + \"/\" + checkNotNull(methodName, \"methodName\");\r\n}"
}, {
	"Path": "com.oracle.svm.core.jdk.RuntimeSupport.executeTearDownHooks",
	"Comment": "called only internally as part of the isolate tear down process. these hooks clean up allrunning threads to allow proper isolate tear down.although public, this method should not go to the public api.",
	"Method": "void executeTearDownHooks(){\r\n    executeHooks(getRuntimeSupport().tearDownHooks);\r\n}"
}, {
	"Path": "com.oracle.svm.core.graal.meta.SubstrateTargetDescription.allFlags",
	"Comment": "we include all flags that enable cpu instructions as we want best possible performance forthe code.",
	"Method": "EnumSet<AMD64.Flag> allFlags(){\r\n    return EnumSet.of(AMD64.Flag.UseCountLeadingZerosInstruction, AMD64.Flag.UseCountLeadingZerosInstruction);\r\n}"
}, {
	"Path": "io.grpc.alts.internal.MockAltsHandshakerResp.getFinishedResponse",
	"Comment": "returns a mock final handshaker response with handshake result.",
	"Method": "HandshakerResp getFinishedResponse(int bytesConsumed){\r\n    HandshakerResp.Builder resp = HandshakerResp.newBuilder();\r\n    HandshakerResult.Builder result = HandshakerResult.newBuilder().setApplicationProtocol(TEST_APPLICATION_PROTOCOL).setRecordProtocol(TEST_RECORD_PROTOCOL).setPeerIdentity(Identity.newBuilder().setServiceAccount(TEST_PEER_ACCOUNT).build()).setLocalIdentity(Identity.newBuilder().setServiceAccount(TEST_LOCAL_ACCOUNT).build()).setKeyData(ByteString.copyFrom(TEST_KEY_DATA));\r\n    resp.setOutFrames(getOutFrame());\r\n    resp.setBytesConsumed(bytesConsumed);\r\n    resp.setStatus(HandshakerStatus.newBuilder().setCode(Status.Code.OK.value()).build());\r\n    resp.setResult(result.build());\r\n    return resp.build();\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.UnaryCallResponseBandwidthBenchmark.main",
	"Comment": "useful for triggering a subset of the benchmark in a profiler.",
	"Method": "void main(String[] argv){\r\n    UnaryCallResponseBandwidthBenchmark bench = new UnaryCallResponseBandwidthBenchmark();\r\n    bench.setup();\r\n    Thread.sleep(30000);\r\n    bench.teardown();\r\n    System.exit(0);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.Scope.getName",
	"Comment": "human readable name of this scope. a name description like block, name of a function,closure, script, module, etc.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.code.AnalysisMethodCalleeWalker.walkMethod",
	"Comment": "walk a method by applying a visitor to the method and all of its callees. returns true if allthe visits returned true, else returns false.",
	"Method": "boolean walkMethod(AnalysisMethod method,CallPathVisitor visitor){\r\n    if (visitor.prologue() != VisitResult.CONTINUE) {\r\n        return false;\r\n    }\r\n    path.clear();\r\n    walkMethodAndCallees(method, null, null, visitor);\r\n    final VisitResult epilogueResult = visitor.epilogue();\r\n    return (epilogueResult != VisitResult.CONTINUE);\r\n}"
}, {
	"Path": "io.grpc.netty.GrpcSslContexts.defaultSslProvider",
	"Comment": "returns openssl if available, otherwise returns the jdk provider.",
	"Method": "SslProvider defaultSslProvider(){\r\n    if (OpenSsl.isAvailable()) {\r\n        logger.log(Level.FINE, \"Selecting OPENSSL\");\r\n        return SslProvider.OPENSSL;\r\n    }\r\n    Provider provider = findJdkProvider();\r\n    if (provider != null) {\r\n        logger.log(Level.FINE, \"Selecting JDK with provider {0}\", provider);\r\n        return SslProvider.JDK;\r\n    }\r\n    logger.log(Level.INFO, \"netty-tcnative unavailable (this may be normal)\", OpenSsl.unavailabilityCause());\r\n    logger.log(Level.INFO, \"Conscrypt not found (this may be normal)\");\r\n    logger.log(Level.INFO, \"Jetty ALPN unavailable (this may be normal)\", JettyTlsUtil.getJettyAlpnUnavailabilityCause());\r\n    throw new IllegalStateException(\"Could not find TLS ALPN provider; \" + \"no working netty-tcnative, Conscrypt, or Jetty NPN/ALPN available\");\r\n}"
}, {
	"Path": "io.grpc.channelz.v1.ChannelzGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "ChannelzStub newStub(io.grpc.Channel channel){\r\n    return new ChannelzStub(channel);\r\n}"
}, {
	"Path": "com.google.common.collect.HashBiMap.ensureCapacity",
	"Comment": "ensures that all of the internal structures in the hashbimap are ready for this many elements.",
	"Method": "void ensureCapacity(int minCapacity){\r\n    if (nextInBucketKToV.length < minCapacity) {\r\n        int oldCapacity = nextInBucketKToV.length;\r\n        int newCapacity = ImmutableCollection.Builder.expandedCapacity(oldCapacity, minCapacity);\r\n        keys = Arrays.copyOf(keys, newCapacity);\r\n        values = Arrays.copyOf(values, newCapacity);\r\n        nextInBucketKToV = expandAndFillWithAbsent(nextInBucketKToV, newCapacity);\r\n        nextInBucketVToK = expandAndFillWithAbsent(nextInBucketVToK, newCapacity);\r\n        prevInInsertionOrder = expandAndFillWithAbsent(prevInInsertionOrder, newCapacity);\r\n        nextInInsertionOrder = expandAndFillWithAbsent(nextInInsertionOrder, newCapacity);\r\n    }\r\n    if (hashTableKToV.length < minCapacity) {\r\n        int newTableSize = Hashing.closedTableSize(minCapacity, 1.0);\r\n        hashTableKToV = createFilledWithAbsent(newTableSize);\r\n        hashTableVToK = createFilledWithAbsent(newTableSize);\r\n        for (int entryToRehash = 0; entryToRehash < size; entryToRehash++) {\r\n            int keyHash = Hashing.smearedHash(keys[entryToRehash]);\r\n            int keyBucket = bucket(keyHash);\r\n            nextInBucketKToV[entryToRehash] = hashTableKToV[keyBucket];\r\n            hashTableKToV[keyBucket] = entryToRehash;\r\n            int valueHash = Hashing.smearedHash(values[entryToRehash]);\r\n            int valueBucket = bucket(valueHash);\r\n            nextInBucketVToK[entryToRehash] = hashTableVToK[valueBucket];\r\n            hashTableVToK[valueBucket] = entryToRehash;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.CardTable.verifyDirtyCards",
	"Comment": "check that that every object with a pointer to young space has a corresponding dirty card.",
	"Method": "boolean verifyDirtyCards(Pointer ctStart,Pointer objectsStart,Pointer objectsLimit){\r\n    final Log trace = Log.noopLog().string(\"[CardTable.verifyDirtyCards:\");\r\n    trace.string(\"  ctStart: \").hex(ctStart).string(\"  objectsStart: \").hex(objectsStart).string(\"  objectsLimit: \").hex(objectsLimit);\r\n    Pointer ptr = objectsStart;\r\n    while (ptr.belowThan(objectsLimit)) {\r\n        final Object obj = ptr.toObject();\r\n        final boolean containsYoung = containsReferenceToYoungSpace(obj);\r\n        if (containsYoung) {\r\n            final UnsignedWord index = memoryPointerToIndex(objectsStart, objectsLimit, ptr);\r\n            final boolean isClean = isCleanEntryAtIndex(ctStart, index);\r\n            if (isClean) {\r\n                final boolean witnessForDebugging = true;\r\n                final Log witness = (witnessForDebugging ? Log.log() : HeapImpl.getHeapImpl().getHeapVerifierImpl().getTraceLog());\r\n                witness.string(\"[CardTable.verifyDirtyCards:\").string(\"  objectsStart: \").hex(objectsStart).string(\"  objectsLimit: \").hex(objectsLimit).newline();\r\n                witness.string(\"  obj: \").object(obj).string(\"  contains young: \").bool(containsYoung).string(\"  but index: \").unsigned(index).string(\" is clean.\").string(\" returns false\").string(\"]\").newline();\r\n                return false;\r\n            }\r\n        }\r\n        ptr = LayoutEncoding.getObjectEnd(obj);\r\n    }\r\n    trace.string(\"]\").newline();\r\n    return true;\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.FlowControlledMessagesPerSecondBenchmark.main",
	"Comment": "useful for triggering a subset of the benchmark in a profiler.",
	"Method": "void main(String[] argv){\r\n    FlowControlledMessagesPerSecondBenchmark bench = new FlowControlledMessagesPerSecondBenchmark();\r\n    bench.setup();\r\n    Thread.sleep(30000);\r\n    bench.teardown();\r\n    System.exit(0);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.HeapChunk.getNextObject",
	"Comment": "given an object, return the next object in this heapchunk, or null.",
	"Method": "Object getNextObject(Header<?> that,Object obj){\r\n    final Log trace = Log.noopLog().string(\"[HeapChunk.getNextObject:\").newline();\r\n    final Pointer objEnd = LayoutEncoding.getObjectEnd(obj);\r\n    trace.string(\"  o: \").object(obj).string(\"  objEnd: \").hex(objEnd).string(\"  top: \").hex(that.getTop()).newline();\r\n    if (that.getTop().belowOrEqual(objEnd)) {\r\n        trace.string(\"  returns null\").string(\"]\").newline();\r\n        return null;\r\n    }\r\n    final Object result = objEnd.toObject();\r\n    trace.string(\" returns \").object(result).string(\"]\").newline();\r\n    return result;\r\n}"
}, {
	"Path": "io.grpc.ServerMethodDefinition.withServerCallHandler",
	"Comment": "create a new method definition with a different call handler.",
	"Method": "ServerMethodDefinition<ReqT, RespT> withServerCallHandler(ServerCallHandler<ReqT, RespT> handler){\r\n    return new ServerMethodDefinition<ReqT, RespT>(method, handler);\r\n}"
}, {
	"Path": "io.grpc.netty.NettyClientTransportTest.creatingMultipleTlsTransportsShouldSucceed",
	"Comment": "verifies that we can create multiple tls client transports from the same builder.",
	"Method": "void creatingMultipleTlsTransportsShouldSucceed(){\r\n    startServer();\r\n    ProtocolNegotiator negotiator = newNegotiator();\r\n    for (int index = 0; index < 2; ++index) {\r\n        NettyClientTransport transport = newTransport(negotiator);\r\n        callMeMaybe(transport.start(clientTransportListener));\r\n    }\r\n    final List<Rpc> rpcs = new ArrayList(transports.size());\r\n    for (NettyClientTransport transport : transports) {\r\n        rpcs.add(new Rpc(transport).halfClose());\r\n    }\r\n    for (Rpc rpc : rpcs) {\r\n        rpc.waitForResponse();\r\n    }\r\n}"
}, {
	"Path": "io.grpc.okhttp.internal.Platform.findPlatform",
	"Comment": "attempt to match the host runtime to a capable platform implementation.",
	"Method": "Platform findPlatform(){\r\n    Provider androidOrAppEngineProvider = GrpcUtil.IS_RESTRICTED_APPENGINE ? getAppEngineProvider() : getAndroidSecurityProvider();\r\n    if (androidOrAppEngineProvider != null) {\r\n        OptionalMethod<Socket> setUseSessionTickets = new OptionalMethod<Socket>(null, \"setUseSessionTickets\", boolean.class);\r\n        OptionalMethod<Socket> setHostname = new OptionalMethod<Socket>(null, \"setHostname\", String.class);\r\n        Method trafficStatsTagSocket = null;\r\n        Method trafficStatsUntagSocket = null;\r\n        OptionalMethod<Socket> getAlpnSelectedProtocol = new OptionalMethod<Socket>(byte[].class, \"getAlpnSelectedProtocol\");\r\n        OptionalMethod<Socket> setAlpnProtocols = new OptionalMethod<Socket>(null, \"setAlpnProtocols\", byte[].class);\r\n        try {\r\n            Class<?> trafficStats = Class.forName(\"android.net.TrafficStats\");\r\n            trafficStatsTagSocket = trafficStats.getMethod(\"tagSocket\", Socket.class);\r\n            trafficStatsUntagSocket = trafficStats.getMethod(\"untagSocket\", Socket.class);\r\n        } catch (ClassNotFoundException ignored) {\r\n        } catch (NoSuchMethodException ignored) {\r\n        }\r\n        TlsExtensionType tlsExtensionType;\r\n        if (GrpcUtil.IS_RESTRICTED_APPENGINE) {\r\n            tlsExtensionType = TlsExtensionType.ALPN_AND_NPN;\r\n        } else if (androidOrAppEngineProvider.getName().equals(\"GmsCore_OpenSSL\") || androidOrAppEngineProvider.getName().equals(\"Conscrypt\") || androidOrAppEngineProvider.getName().equals(\"Ssl_Guard\")) {\r\n            tlsExtensionType = TlsExtensionType.ALPN_AND_NPN;\r\n        } else if (isAtLeastAndroid5()) {\r\n            tlsExtensionType = TlsExtensionType.ALPN_AND_NPN;\r\n        } else if (isAtLeastAndroid41()) {\r\n            tlsExtensionType = TlsExtensionType.NPN;\r\n        } else {\r\n            tlsExtensionType = TlsExtensionType.NONE;\r\n        }\r\n        return new Android(setUseSessionTickets, setHostname, trafficStatsTagSocket, trafficStatsUntagSocket, getAlpnSelectedProtocol, setAlpnProtocols, androidOrAppEngineProvider, tlsExtensionType);\r\n    }\r\n    Provider sslProvider;\r\n    try {\r\n        sslProvider = SSLContext.getDefault().getProvider();\r\n    } catch (NoSuchAlgorithmException nsae) {\r\n        throw new RuntimeException(nsae);\r\n    }\r\n    try {\r\n        SSLContext context = SSLContext.getInstance(\"TLS\", sslProvider);\r\n        context.init(null, null, null);\r\n        SSLEngine engine = context.createSSLEngine();\r\n        Method getEngineApplicationProtocol = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {\r\n            @Override\r\n            public Method run() throws Exception {\r\n                return SSLEngine.class.getMethod(\"getApplicationProtocol\");\r\n            }\r\n        });\r\n        getEngineApplicationProtocol.invoke(engine);\r\n        Method setApplicationProtocols = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {\r\n            @Override\r\n            public Method run() throws Exception {\r\n                return SSLParameters.class.getMethod(\"setApplicationProtocols\", String[].class);\r\n            }\r\n        });\r\n        Method getApplicationProtocol = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {\r\n            @Override\r\n            public Method run() throws Exception {\r\n                return SSLSocket.class.getMethod(\"getApplicationProtocol\");\r\n            }\r\n        });\r\n        return new JdkAlpnPlatform(sslProvider, setApplicationProtocols, getApplicationProtocol);\r\n    } catch (NoSuchAlgorithmException ignored) {\r\n    } catch (KeyManagementException ignored) {\r\n    } catch (PrivilegedActionException ignored) {\r\n    } catch (IllegalAccessException ignored) {\r\n    } catch (InvocationTargetException ignored) {\r\n    }\r\n    try {\r\n        String negoClassName = \"org.eclipse.jetty.alpn.ALPN\";\r\n        Class<?> negoClass = Class.forName(negoClassName);\r\n        Class<?> providerClass = Class.forName(negoClassName + \"$Provider\");\r\n        Class<?> clientProviderClass = Class.forName(negoClassName + \"$ClientProvider\");\r\n        Class<?> serverProviderClass = Class.forName(negoClassName + \"$ServerProvider\");\r\n        Method putMethod = negoClass.getMethod(\"put\", SSLSocket.class, providerClass);\r\n        Method getMethod = negoClass.getMethod(\"get\", SSLSocket.class);\r\n        Method removeMethod = negoClass.getMethod(\"remove\", SSLSocket.class);\r\n        return new JdkWithJettyBootPlatform(putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass, sslProvider);\r\n    } catch (ClassNotFoundException ignored) {\r\n    } catch (NoSuchMethodException ignored) {\r\n    }\r\n    return new Platform(sslProvider);\r\n}"
}, {
	"Path": "io.grpc.okhttp.internal.Platform.findPlatform",
	"Comment": "attempt to match the host runtime to a capable platform implementation.",
	"Method": "Platform findPlatform(){\r\n    return SSLEngine.class.getMethod(\"getApplicationProtocol\");\r\n}"
}, {
	"Path": "io.grpc.okhttp.internal.Platform.findPlatform",
	"Comment": "attempt to match the host runtime to a capable platform implementation.",
	"Method": "Platform findPlatform(){\r\n    return SSLParameters.class.getMethod(\"setApplicationProtocols\", String[].class);\r\n}"
}, {
	"Path": "io.grpc.okhttp.internal.Platform.findPlatform",
	"Comment": "attempt to match the host runtime to a capable platform implementation.",
	"Method": "Platform findPlatform(){\r\n    return SSLSocket.class.getMethod(\"getApplicationProtocol\");\r\n}"
}, {
	"Path": "io.grpc.testing.integration.AbstractInteropTest.unimplementedMethod",
	"Comment": "sends an rpc to an unimplemented method within testservice.",
	"Method": "void unimplementedMethod(){\r\n    try {\r\n        blockingStub.unimplementedCall(Empty.getDefaultInstance());\r\n        fail();\r\n    } catch (StatusRuntimeException e) {\r\n        assertEquals(Status.UNIMPLEMENTED.getCode(), e.getStatus().getCode());\r\n    }\r\n    assertClientStatsTrace(\"grpc.testing.TestService/UnimplementedCall\", Status.Code.UNIMPLEMENTED);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.HeapChunkProvider.consumeAlignedChunk",
	"Comment": "recycle an alignedheapchunk, either to the free list or back to the operating system.",
	"Method": "void consumeAlignedChunk(AlignedHeader chunk){\r\n    log().string(\"[HeapChunkProvider.consumeAlignedChunk  chunk: \").hex(chunk).newline();\r\n    if (keepAlignedChunk()) {\r\n        cleanAlignedChunk(chunk);\r\n        pushUnusedAlignedChunk(chunk);\r\n    } else {\r\n        log().string(\"  release memory to the OS\").newline();\r\n        freeAlignedChunk(chunk);\r\n    }\r\n    log().string(\"  ]\").newline();\r\n}"
}, {
	"Path": "io.grpc.netty.KeepAliveEnforcer.resetCounters",
	"Comment": "reset any counters because pings are allowed in response to something sent. typically calledwhen sending headers and data frames.",
	"Method": "void resetCounters(){\r\n    lastValidPingTime = epoch;\r\n    pingStrikes = 0;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.frame.FrameDescriptor.removeFrameSlot",
	"Comment": "removes a slot. if the identifier is found, its slot is removed from this descriptor. this isa slow operation.",
	"Method": "void removeFrameSlot(Object identifier){\r\n    CompilerAsserts.neverPartOfCompilation(NEVER_PART_OF_COMPILATION_MESSAGE);\r\n    synchronized (lock) {\r\n        FrameSlot slot = identifierToSlotMap.get(identifier);\r\n        if (slot == null) {\r\n            throw new IllegalArgumentException(\"no such frame slot: \" + identifier);\r\n        }\r\n        slots.remove(slot);\r\n        identifierToSlotMap.removeKey(identifier);\r\n        updateVersion();\r\n        getNotInFrameAssumption(identifier);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.tck.DebuggerTester.close",
	"Comment": "closes the current debugger tester session and all its associated resources like thebackground thread. the debugger tester becomes unusable after closing.",
	"Method": "void close(){\r\n    if (closed) {\r\n        throw new IllegalStateException(\"Already closed.\");\r\n    }\r\n    closed = true;\r\n    trace(\"kill session \" + this);\r\n    notifyNextAction();\r\n    try {\r\n        evalThread.join();\r\n    } catch (InterruptedException iex) {\r\n        throw new AssertionError(\"Interrupted while joining eval thread.\", iex);\r\n    }\r\n    engine.close();\r\n}"
}, {
	"Path": "com.oracle.svm.graal.SubstrateGraalUtils.doCompile",
	"Comment": "actual method compilation.for zone allocation this is where the zone boundary can be placed when the code is onlycompiled. however using the returned compilation result would result into a zone allocationinvariant violation.",
	"Method": "CompilationResult doCompile(DebugContext initialDebug,RuntimeConfiguration runtimeConfig,Suites suites,LIRSuites lirSuites,SubstrateMethod method){\r\n    String methodString = method.format(\"%H.%n(%p)\");\r\n    SubstrateCompilationIdentifier compilationId = new SubstrateCompilationIdentifier();\r\n    return new CompilationWrapper<CompilationResult>(GraalSupport.get().getDebugOutputDirectory(), compilationProblemsPerAction) {\r\n        @SuppressWarnings({ \"unchecked\", \"unused\" })\r\n        <E extends Throwable> RuntimeException silenceThrowable(Class<E> type, Throwable ex) throws E {\r\n            throw (E) ex;\r\n        }\r\n        @Override\r\n        protected CompilationResult handleException(Throwable t) {\r\n            throw silenceThrowable(RuntimeException.class, t);\r\n        }\r\n        @Override\r\n        protected CompilationResult performCompilation(DebugContext debug) {\r\n            StructuredGraph graph = GraalSupport.decodeGraph(debug, null, compilationId, method);\r\n            return compileGraph(runtimeConfig, suites, lirSuites, method, graph);\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return methodString;\r\n        }\r\n        @Override\r\n        protected DebugContext createRetryDebugContext(OptionValues options, PrintStream logStream) {\r\n            return GraalSupport.get().openDebugContext(options, compilationId, method, logStream);\r\n        }\r\n    }.run(initialDebug);\r\n}"
}, {
	"Path": "com.oracle.svm.graal.SubstrateGraalUtils.doCompile",
	"Comment": "actual method compilation.for zone allocation this is where the zone boundary can be placed when the code is onlycompiled. however using the returned compilation result would result into a zone allocationinvariant violation.",
	"Method": "CompilationResult doCompile(DebugContext initialDebug,RuntimeConfiguration runtimeConfig,Suites suites,LIRSuites lirSuites,SubstrateMethod method){\r\n    throw (E) ex;\r\n}"
}, {
	"Path": "com.oracle.svm.graal.SubstrateGraalUtils.doCompile",
	"Comment": "actual method compilation.for zone allocation this is where the zone boundary can be placed when the code is onlycompiled. however using the returned compilation result would result into a zone allocationinvariant violation.",
	"Method": "CompilationResult doCompile(DebugContext initialDebug,RuntimeConfiguration runtimeConfig,Suites suites,LIRSuites lirSuites,SubstrateMethod method){\r\n    throw silenceThrowable(RuntimeException.class, t);\r\n}"
}, {
	"Path": "com.oracle.svm.graal.SubstrateGraalUtils.doCompile",
	"Comment": "actual method compilation.for zone allocation this is where the zone boundary can be placed when the code is onlycompiled. however using the returned compilation result would result into a zone allocationinvariant violation.",
	"Method": "CompilationResult doCompile(DebugContext initialDebug,RuntimeConfiguration runtimeConfig,Suites suites,LIRSuites lirSuites,SubstrateMethod method){\r\n    StructuredGraph graph = GraalSupport.decodeGraph(debug, null, compilationId, method);\r\n    return compileGraph(runtimeConfig, suites, lirSuites, method, graph);\r\n}"
}, {
	"Path": "com.oracle.svm.graal.SubstrateGraalUtils.doCompile",
	"Comment": "actual method compilation.for zone allocation this is where the zone boundary can be placed when the code is onlycompiled. however using the returned compilation result would result into a zone allocationinvariant violation.",
	"Method": "CompilationResult doCompile(DebugContext initialDebug,RuntimeConfiguration runtimeConfig,Suites suites,LIRSuites lirSuites,SubstrateMethod method){\r\n    return methodString;\r\n}"
}, {
	"Path": "com.oracle.svm.graal.SubstrateGraalUtils.doCompile",
	"Comment": "actual method compilation.for zone allocation this is where the zone boundary can be placed when the code is onlycompiled. however using the returned compilation result would result into a zone allocationinvariant violation.",
	"Method": "CompilationResult doCompile(DebugContext initialDebug,RuntimeConfiguration runtimeConfig,Suites suites,LIRSuites lirSuites,SubstrateMethod method){\r\n    return GraalSupport.get().openDebugContext(options, compilationId, method, logStream);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.interop.ForeignAccess.getArguments",
	"Comment": "read only access to foreign call arguments inside of a frame.",
	"Method": "List<Object> getArguments(Frame frame){\r\n    final Object[] arr = frame.getArguments();\r\n    return ReadOnlyArrayList.asList(arr, 1, arr.length);\r\n}"
}, {
	"Path": "io.grpc.okhttp.internal.framed.HpackTest.tooLargeToHPackIsStillEmitted",
	"Comment": "hpack has a max header table size, which can be smaller than the max header message.ensure the larger header content is not lost.",
	"Method": "void tooLargeToHPackIsStillEmitted(){\r\n    bytesIn.writeByte(0x00);\r\n    bytesIn.writeByte(0x0a);\r\n    bytesIn.writeUtf8(\"custom-key\");\r\n    bytesIn.writeByte(0x0d);\r\n    bytesIn.writeUtf8(\"custom-header\");\r\n    hpackReader.headerTableSizeSetting(1);\r\n    hpackReader.readHeaders();\r\n    assertEquals(0, hpackReader.dynamicTableHeaderCount);\r\n    assertEquals(headerEntries(\"custom-key\", \"custom-header\"), hpackReader.getAndResetHeaderList());\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.AlignedHeapChunk.usedObjectMemoryOfAlignedHeapChunk",
	"Comment": "how much space is used for the objects in an alignedheapchunk?",
	"Method": "UnsignedWord usedObjectMemoryOfAlignedHeapChunk(AlignedHeader that){\r\n    return that.getTop().subtract(getAlignedHeapChunkStart(that));\r\n}"
}, {
	"Path": "com.google.gson.stream.JsonReader.skipValue",
	"Comment": "skips the next value recursively. if it is an object or array, all nestedelements are skipped. this method is intended for use when the json tokenstream contains unrecognized or unhandled values.",
	"Method": "void skipValue(){\r\n    int count = 0;\r\n    do {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        if (p == PEEKED_BEGIN_ARRAY) {\r\n            push(JsonScope.EMPTY_ARRAY);\r\n            count++;\r\n        } else if (p == PEEKED_BEGIN_OBJECT) {\r\n            push(JsonScope.EMPTY_OBJECT);\r\n            count++;\r\n        } else if (p == PEEKED_END_ARRAY) {\r\n            stackSize--;\r\n            count--;\r\n        } else if (p == PEEKED_END_OBJECT) {\r\n            stackSize--;\r\n            count--;\r\n        } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\r\n            skipUnquotedValue();\r\n        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\r\n            skipQuotedValue('\\'');\r\n        } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\r\n            skipQuotedValue('\"');\r\n        } else if (p == PEEKED_NUMBER) {\r\n            pos += peekedNumberLength;\r\n        }\r\n        peeked = PEEKED_NONE;\r\n    } while (count != 0);\r\n    pathIndices[stackSize - 1]++;\r\n    pathNames[stackSize - 1] = \"null\";\r\n}"
}, {
	"Path": "io.grpc.testing.integration.AbstractInteropTest.cacheableUnary",
	"Comment": "sends a cacheable unary rpc using get. requires that the server is behind a caching proxy.",
	"Method": "void cacheableUnary(){\r\n    MethodDescriptor<SimpleRequest, SimpleResponse> safeCacheableUnaryCallMethod = TestServiceGrpc.getCacheableUnaryCallMethod().toBuilder().setSafe(true).build();\r\n    Metadata.Key<String> userIpKey = Metadata.Key.of(\"x-user-ip\", Metadata.ASCII_STRING_MARSHALLER);\r\n    Metadata metadata = new Metadata();\r\n    metadata.put(userIpKey, \"1.2.3.4\");\r\n    Channel channelWithUserIpKey = ClientInterceptors.intercept(channel, MetadataUtils.newAttachHeadersInterceptor(metadata));\r\n    SimpleRequest requests1And2 = SimpleRequest.newBuilder().setPayload(Payload.newBuilder().setBody(ByteString.copyFromUtf8(String.valueOf(System.nanoTime())))).build();\r\n    SimpleRequest request3 = SimpleRequest.newBuilder().setPayload(Payload.newBuilder().setBody(ByteString.copyFromUtf8(String.valueOf(System.nanoTime())))).build();\r\n    SimpleResponse response1 = ClientCalls.blockingUnaryCall(channelWithUserIpKey, safeCacheableUnaryCallMethod, CallOptions.DEFAULT, requests1And2);\r\n    SimpleResponse response2 = ClientCalls.blockingUnaryCall(channelWithUserIpKey, safeCacheableUnaryCallMethod, CallOptions.DEFAULT, requests1And2);\r\n    SimpleResponse response3 = ClientCalls.blockingUnaryCall(channelWithUserIpKey, safeCacheableUnaryCallMethod, CallOptions.DEFAULT, request3);\r\n    assertEquals(response1, response2);\r\n    assertNotEquals(response1, response3);\r\n}"
}, {
	"Path": "com.google.gson.JsonObject.getAsJsonArray",
	"Comment": "convenience method to get the specified member as a jsonarray.",
	"Method": "JsonArray getAsJsonArray(String memberName){\r\n    return (JsonArray) members.get(memberName);\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.test.SLInstrumentTest.testRedoIO",
	"Comment": "test that we reenter a node whose execution was interrupted. unwind just the one node off.",
	"Method": "void testRedoIO(){\r\n    String code = \"function main() {\\n\" + \"  a = readln();\\n\" + \"  return a;\\n\" + \"}\\n\";\r\n    final Source ioWait = Source.newBuilder(\"sl\", code, \"testing\").build();\r\n    final TestRedoIO[] redoIOPtr = new TestRedoIO[1];\r\n    InputStream strIn = new ByteArrayInputStream(\"O.K.\".getBytes());\r\n    InputStream delegateInputStream = new InputStream() {\r\n        @Override\r\n        public int read() throws IOException {\r\n            synchronized (SLInstrumentTest.class) {\r\n                if (redoIOPtr[0].beforePop) {\r\n                    redoIOPtr[0].inRead.release();\r\n                    try {\r\n                        SLInstrumentTest.class.wait();\r\n                    } catch (InterruptedException ex) {\r\n                        throw new RuntimeInterruptedException();\r\n                    }\r\n                }\r\n            }\r\n            return strIn.read();\r\n        }\r\n    };\r\n    Engine engine = Engine.newBuilder().in(delegateInputStream).build();\r\n    TestRedoIO redoIO = engine.getInstruments().get(\"testRedoIO\").lookup(TestRedoIO.class);\r\n    redoIOPtr[0] = redoIO;\r\n    redoIO.inRead.drainPermits();\r\n    Context context = Context.newBuilder().engine(engine).build();\r\n    Value ret = context.eval(ioWait);\r\n    assertEquals(\"O.K.\", ret.asString());\r\n    assertFalse(redoIO.beforePop);\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.test.SLInstrumentTest.testRedoIO",
	"Comment": "test that we reenter a node whose execution was interrupted. unwind just the one node off.",
	"Method": "void testRedoIO(){\r\n    synchronized (SLInstrumentTest.class) {\r\n        if (redoIOPtr[0].beforePop) {\r\n            redoIOPtr[0].inRead.release();\r\n            try {\r\n                SLInstrumentTest.class.wait();\r\n            } catch (InterruptedException ex) {\r\n                throw new RuntimeInterruptedException();\r\n            }\r\n        }\r\n    }\r\n    return strIn.read();\r\n}"
}, {
	"Path": "io.grpc.PersistentHashArrayMappedTrie.put",
	"Comment": "returns a new trie where the key is set to the specified value.",
	"Method": "PersistentHashArrayMappedTrie<K, V> put(K key,V value,Node<K, V> put,K key,V value,int hash,int bitsConsumed,Node<K, V> put,K key,V value,int hash,int bitsConsumed,Node<K, V> put,K key,V value,int hash,int bitsConsumed,Node<K, V> put,K key,V value,int hash,int bitsConsumed){\r\n    if (root == null) {\r\n        return new PersistentHashArrayMappedTrie<K, V>(new Leaf<K, V>(key, value));\r\n    } else {\r\n        return new PersistentHashArrayMappedTrie<K, V>(root.put(key, value, key.hashCode(), 0));\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.jni.access.JNINativeLinkage.unsetEntryPoint",
	"Comment": "resets the entry point stored for the native method represented by this object, triggering asymbol lookup when the method is called the next time.",
	"Method": "void unsetEntryPoint(){\r\n    entryPoint = WordFactory.nullPointer();\r\n}"
}, {
	"Path": "io.grpc.cronet.CronetClientTransport.stopIfNecessary",
	"Comment": "when the transport is in goaway state, we should stop it once all active streams finish.",
	"Method": "void stopIfNecessary(){\r\n    synchronized (lock) {\r\n        if (goAway && !stopped && streams.size() == 0) {\r\n            stopped = true;\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n    listener.transportTerminated();\r\n}"
}, {
	"Path": "org.graalvm.component.installer.commands.InstallerTest.testSetDryRun",
	"Comment": "checks that the install does not do anything if dry run is enabled.",
	"Method": "void testSetDryRun(){\r\n    setupComponentInstall(\"truffleruby2.jar\");\r\n    installer.setDryRun(true);\r\n    installer.setPermissions(loader.loadPermissions());\r\n    installer.setSymlinks(loader.loadSymlinks());\r\n    installer.install();\r\n    assertFalse(\"No files should be created under dry run\", Files.list(targetPath).findAny().isPresent());\r\n}"
}, {
	"Path": "com.oracle.truffle.tools.profiler.HeapMonitor.isCollecting",
	"Comment": "returns true if the heap monitor is collecting data, else false.",
	"Method": "boolean isCollecting(){\r\n    return collecting;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebuggerSession.setSteppingFilter",
	"Comment": "set a stepping suspension filter. prepared steps skip code that does not match this filter.",
	"Method": "void setSteppingFilter(SuspensionFilter steppingFilter){\r\n    this.ignoreLanguageContextInitialization.set(steppingFilter.isIgnoreLanguageContextInitialization());\r\n    synchronized (this) {\r\n        boolean oldIncludeInternal = this.includeInternal;\r\n        this.includeInternal = steppingFilter.isInternalIncluded();\r\n        Predicate<Source> oldSourceFilter = this.sourceFilter;\r\n        this.sourceFilter = steppingFilter.getSourcePredicate();\r\n        if (oldIncludeInternal != this.includeInternal || oldSourceFilter != this.sourceFilter) {\r\n            removeBindings();\r\n            addBindings(this.includeInternal, this.sourceFilter);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.grpc.alts.internal.AltsHandshakerClient.setStartClientFields",
	"Comment": "sets the start client fields for the passed handshake request.",
	"Method": "void setStartClientFields(HandshakerReq.Builder req){\r\n    StartClientHandshakeReq.Builder startClientReq = StartClientHandshakeReq.newBuilder().setHandshakeSecurityProtocol(HandshakeProtocol.ALTS).addApplicationProtocols(APPLICATION_PROTOCOL).addRecordProtocols(RECORD_PROTOCOL);\r\n    if (handshakerOptions.getRpcProtocolVersions() != null) {\r\n        startClientReq.setRpcVersions(handshakerOptions.getRpcProtocolVersions());\r\n    }\r\n    if (handshakerOptions instanceof AltsClientOptions) {\r\n        AltsClientOptions clientOptions = (AltsClientOptions) handshakerOptions;\r\n        if (!Strings.isNullOrEmpty(clientOptions.getTargetName())) {\r\n            startClientReq.setTargetName(clientOptions.getTargetName());\r\n        }\r\n        for (String serviceAccount : clientOptions.getTargetServiceAccounts()) {\r\n            startClientReq.addTargetIdentitiesBuilder().setServiceAccount(serviceAccount);\r\n        }\r\n    }\r\n    req.setClientStart(startClientReq);\r\n}"
}, {
	"Path": "io.grpc.internal.InternalSubchannel.updateAddresses",
	"Comment": "replaces the existing addresses, avoiding unnecessary reconnects.",
	"Method": "void updateAddresses(List<EquivalentAddressGroup> newAddressGroups){\r\n    Preconditions.checkNotNull(newAddressGroups, \"newAddressGroups\");\r\n    checkListHasNoNulls(newAddressGroups, \"newAddressGroups contains null entry\");\r\n    Preconditions.checkArgument(!newAddressGroups.isEmpty(), \"newAddressGroups is empty\");\r\n    newAddressGroups = Collections.unmodifiableList(new ArrayList(newAddressGroups));\r\n    ManagedClientTransport savedTransport = null;\r\n    try {\r\n        synchronized (lock) {\r\n            SocketAddress previousAddress = addressIndex.getCurrentAddress();\r\n            addressIndex.updateGroups(newAddressGroups);\r\n            if (state.getState() == READY || state.getState() == CONNECTING) {\r\n                if (!addressIndex.seekTo(previousAddress)) {\r\n                    if (state.getState() == READY) {\r\n                        savedTransport = activeTransport;\r\n                        activeTransport = null;\r\n                        addressIndex.reset();\r\n                        gotoNonErrorState(IDLE);\r\n                    } else {\r\n                        savedTransport = pendingTransport;\r\n                        pendingTransport = null;\r\n                        addressIndex.reset();\r\n                        startNewTransport();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        syncContext.drain();\r\n    }\r\n    if (savedTransport != null) {\r\n        savedTransport.shutdown(Status.UNAVAILABLE.withDescription(\"InternalSubchannel closed transport due to address change\"));\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.JsonElement.getAsDouble",
	"Comment": "convenience method to get this element as a primitive double value.",
	"Method": "double getAsDouble(){\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.ObjectHeaderImpl.getHeaderBitsFromHeader",
	"Comment": "this method returns the header bits from a header that has already been read from an object.",
	"Method": "UnsignedWord getHeaderBitsFromHeader(UnsignedWord header){\r\n    assert !isProducedHeapChunkZapped(header) : \"Produced chunk zap value\";\r\n    assert !isConsumedHeapChunkZapped(header) : \"Consumed chunk zap value\";\r\n    return header.and(ObjectHeader.BITS_MASK);\r\n}"
}, {
	"Path": "com.oracle.objectfile.ObjectFile.flagSetFromLong",
	"Comment": "create an enumset representation of a long integer encoding a set of bitflags.",
	"Method": "EnumSet<E> flagSetFromLong(long flags,Class<E> clazz){\r\n    EnumSet<E> working = EnumSet.noneOf(clazz);\r\n    for (E f : EnumSet.allOf(clazz)) {\r\n        if ((flags & f.value()) != 0) {\r\n            working.add(f);\r\n        }\r\n    }\r\n    return working;\r\n}"
}, {
	"Path": "com.oracle.svm.core.thread.JavaThreads.detachThread",
	"Comment": "detach the provided java thread. note that the java thread might not have been created, inwhich case it is null and we have nothing to do.",
	"Method": "void detachThread(IsolateThread vmThread){\r\n    VMThreads.THREAD_MUTEX.assertIsLocked(\"Should hold the VMThreads mutex.\");\r\n    Heap.getHeap().disableAllocation(vmThread);\r\n    final Thread thread = currentThread.get(vmThread);\r\n    if (thread == null) {\r\n        return;\r\n    }\r\n    detachParkEvent(getUnsafeParkEvent(thread));\r\n    detachParkEvent(getSleepParkEvent(thread));\r\n    if (!thread.isDaemon()) {\r\n        singleton().nonDaemonThreads.decrementAndGet();\r\n    }\r\n}"
}, {
	"Path": "io.grpc.netty.NettyServerBuilder.withChildOption",
	"Comment": "specifies a channel option. as the underlying channel as well as network implementation mayignore this value applications should consider it a hint.",
	"Method": "NettyServerBuilder withChildOption(ChannelOption<T> option,T value){\r\n    this.channelOptions.put(option, value);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.gson.typeadapters.UtcDateTypeAdapter.checkOffset",
	"Comment": "check if the expected character exist at the given offset in the value.",
	"Method": "boolean checkOffset(String value,int offset,char expected){\r\n    return (offset < value.length()) && (value.charAt(offset) == expected);\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.DirectoryStorageTest.testUpdateReplacedFilesNone",
	"Comment": "test of updatereplacedfiles method, of class registrystorage.",
	"Method": "void testUpdateReplacedFilesNone(){\r\n    try (InputStream is = getClass().getResourceAsStream(\"replaced-files.properties\")) {\r\n        Files.copy(is, registryPath.resolve(SystemUtils.fileName(\"replaced-files.properties\")));\r\n    }\r\n    Map<String, Collection<String>> files = new HashMap();\r\n    storage.updateReplacedFiles(files);\r\n    Path regPath = registryPath.resolve(SystemUtils.fileName(\"replaced-files.properties\"));\r\n    assertFalse(Files.exists(regPath));\r\n}"
}, {
	"Path": "io.grpc.Server.getServices",
	"Comment": "returns all services registered with the server, or an empty list if not supported by theimplementation.",
	"Method": "List<ServerServiceDefinition> getServices(){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "com.oracle.svm.core.posix.pthread.PthreadConditionUtils.delayNanosToDeadlineTimespec",
	"Comment": "turn a delay in nanoseconds into a deadline in a time.timespec.",
	"Method": "void delayNanosToDeadlineTimespec(long delayNanos,Time.timespec result){\r\n    timespec currentTimespec = StackValue.get(timespec.class);\r\n    getAbsoluteTimeNanos(currentTimespec);\r\n    assert delayNanos >= 0;\r\n    long sec = TimeUtils.addOrMaxValue(currentTimespec.tv_sec(), TimeUtils.divideNanosToSeconds(delayNanos));\r\n    long nsec = currentTimespec.tv_nsec() + TimeUtils.remainderNanosToSeconds(delayNanos);\r\n    if (nsec >= TimeUtils.nanosPerSecond) {\r\n        sec = TimeUtils.addOrMaxValue(sec, 1);\r\n        nsec -= TimeUtils.nanosPerSecond;\r\n    }\r\n    assert nsec < TimeUtils.nanosPerSecond;\r\n    result.set_tv_sec(sec);\r\n    result.set_tv_nsec(nsec);\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.UnaryCallResponseBandwidthBenchmark.teardown",
	"Comment": "stop the running calls then stop the server and client channels.",
	"Method": "void teardown(){\r\n    completed.set(true);\r\n    Thread.sleep(5000);\r\n    super.teardown();\r\n}"
}, {
	"Path": "com.oracle.svm.core.heap.ObjectVisitor.prologue",
	"Comment": "called before any objects are visited. for example, from the client who creates theobjectvisitor.",
	"Method": "boolean prologue(){\r\n    return true;\r\n}"
}, {
	"Path": "com.google.gson.GsonBuilder.registerTypeAdapterFactory",
	"Comment": "register a factory for type adapters. registering a factory is useful when the typeadapter needs to be configured based on the type of the field being processed. gsonis designed to handle a large number of factories, so you should consider registeringthem to be at par with registering an individual type adapter.",
	"Method": "GsonBuilder registerTypeAdapterFactory(TypeAdapterFactory factory){\r\n    factories.add(factory);\r\n    return this;\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.FlowControlledMessagesPerSecondBenchmark.stream",
	"Comment": "measure the rate of messages received. the calls are already running, we just observe a counterof received responses.",
	"Method": "void stream(AdditionalCounters counters){\r\n    record.set(true);\r\n    Thread.sleep(1001);\r\n    record.set(false);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.UnwindException.fillInStackTrace",
	"Comment": "for performance reasons, this exception does not record any stack trace information.",
	"Method": "Throwable fillInStackTrace(){\r\n    return this;\r\n}"
}, {
	"Path": "com.google.common.collect.HashBiMap.removeEntryKeyHashKnown",
	"Comment": "removes the entry at the specified index, given the hash of its key.",
	"Method": "void removeEntryKeyHashKnown(int entry,int keyHash){\r\n    removeEntry(entry, keyHash, Hashing.smearedHash(values[entry]));\r\n}"
}, {
	"Path": "io.grpc.alts.internal.NettyTsiHandshaker.getBytesToSendToPeer",
	"Comment": "gets data that is ready to be sent to the to the remote peer. this should be called in a loopuntil no bytes are written to the output buffer.",
	"Method": "void getBytesToSendToPeer(ByteBuf out){\r\n    checkState(unwrapper != null, \"protector already created\");\r\n    try (BufUnwrapper unwrapper = this.unwrapper) {\r\n        int bytesWritten = 0;\r\n        for (ByteBuffer nioBuffer : unwrapper.writableNioBuffers(out)) {\r\n            if (!nioBuffer.hasRemaining()) {\r\n                continue;\r\n            }\r\n            int prevPos = nioBuffer.position();\r\n            internalHandshaker.getBytesToSendToPeer(nioBuffer);\r\n            bytesWritten += nioBuffer.position() - prevPos;\r\n            if (nioBuffer.position() == prevPos) {\r\n                break;\r\n            }\r\n        }\r\n        out.writerIndex(out.writerIndex() + bytesWritten);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.test.util.ProcessUtil.executeNativeCommandZeroReturn",
	"Comment": "executes a native command and checks that the return value of the process is 0.",
	"Method": "ProcessResult executeNativeCommandZeroReturn(String command,ProcessResult executeNativeCommandZeroReturn,String command){\r\n    ProcessResult result;\r\n    if (command.length == 1) {\r\n        result = executeNativeCommand(command[0]);\r\n    } else {\r\n        result = executeNativeCommand(concatCommand(command));\r\n    }\r\n    checkNoError(result);\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.FirstObjectTable.getTableSizeForMemoryPointers",
	"Comment": "given the bounds of a memory region, how big is the table to cover it?",
	"Method": "UnsignedWord getTableSizeForMemoryPointers(Pointer memoryStart,Pointer memoryLimit,UnsignedWord getTableSizeForMemoryPointers,Pointer memoryStart,Pointer memoryLimit){\r\n    assert memoryStart.belowOrEqual(memoryLimit) : \"Pointers out of order\";\r\n    final UnsignedWord memorySize = memoryLimit.subtract(memoryStart);\r\n    return getTableSizeForMemorySize(memorySize);\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.runtime.SLFunctionRegistry.getFunctions",
	"Comment": "returns the sorted list of all functions, for printing purposes only.",
	"Method": "List<SLFunction> getFunctions(){\r\n    List<SLFunction> result = new ArrayList(functionsObject.functions.values());\r\n    Collections.sort(result, new Comparator<SLFunction>() {\r\n        public int compare(SLFunction f1, SLFunction f2) {\r\n            return f1.toString().compareTo(f2.toString());\r\n        }\r\n    });\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.runtime.SLFunctionRegistry.getFunctions",
	"Comment": "returns the sorted list of all functions, for printing purposes only.",
	"Method": "List<SLFunction> getFunctions(){\r\n    return f1.toString().compareTo(f2.toString());\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.EventContext.isLanguageContextInitialized",
	"Comment": "test if language context of the source of the event is initialized.",
	"Method": "boolean isLanguageContextInitialized(){\r\n    CompilerAsserts.neverPartOfCompilation();\r\n    Node node = getInstrumentedNode();\r\n    if (node == null) {\r\n        return true;\r\n    }\r\n    RootNode root = node.getRootNode();\r\n    if (root == null) {\r\n        return true;\r\n    }\r\n    LanguageInfo languageInfo = root.getLanguageInfo();\r\n    Env env = AccessorInstrumentHandler.engineAccess().getEnvForInstrument(languageInfo);\r\n    return AccessorInstrumentHandler.langAccess().isContextInitialized(env);\r\n}"
}, {
	"Path": "org.graalvm.component.installer.commands.InstallerTest.testInstallOverwrittemFileWillNotRevert",
	"Comment": "check that if the same file is found and skipped, it will not revert on installation abort.",
	"Method": "void testInstallOverwrittemFileWillNotRevert(){\r\n    setupComponentInstall(\"truffleruby2.jar\");\r\n    installer.setReplaceDiferentFiles(true);\r\n    Path existing = targetPath.resolve(SystemUtils.fromCommonString(\"jre/bin/ruby\"));\r\n    Files.createDirectories(existing.getParent());\r\n    Files.copy(dataFile(\"ruby2\"), existing);\r\n    JarEntry entry = componentJarFile.getJarEntry(\"jre/bin/ruby\");\r\n    Path resultPath = installer.installOneFile(installer.translateTargetPath(entry), entry);\r\n    Path relative = targetPath.relativize(resultPath);\r\n    assertEquals(entry.getName(), SystemUtils.toCommonPath(relative));\r\n    Path check = targetPath.resolve(SystemUtils.fromCommonString(\"jre/bin/ruby\"));\r\n    assertTrue(Files.exists(check));\r\n    assertEquals(entry.getSize(), Files.size(check));\r\n    installer.revertInstall();\r\n    assertTrue(Files.exists(check));\r\n}"
}, {
	"Path": "io.grpc.benchmarks.driver.LoadClient.getStats",
	"Comment": "take a snapshot of the statistics which can be returned to the driver.",
	"Method": "Stats.ClientStats getStats(){\r\n    Histogram intervalHistogram = recorder.getIntervalHistogram();\r\n    Stats.ClientStats.Builder statsBuilder = Stats.ClientStats.newBuilder();\r\n    Stats.HistogramData.Builder latenciesBuilder = statsBuilder.getLatenciesBuilder();\r\n    double resolution = 1.0 + Math.max(config.getHistogramParams().getResolution(), 0.01);\r\n    LogarithmicIterator logIterator = new LogarithmicIterator(intervalHistogram, 1, resolution);\r\n    double base = 1;\r\n    while (logIterator.hasNext()) {\r\n        latenciesBuilder.addBucket((int) logIterator.next().getCountAddedInThisIterationStep());\r\n        base = base * resolution;\r\n    }\r\n    while (base < config.getHistogramParams().getMaxPossible()) {\r\n        latenciesBuilder.addBucket(0);\r\n        base = base * resolution;\r\n    }\r\n    latenciesBuilder.setMaxSeen(intervalHistogram.getMaxValue());\r\n    latenciesBuilder.setMinSeen(intervalHistogram.getMinNonZeroValue());\r\n    latenciesBuilder.setCount(intervalHistogram.getTotalCount());\r\n    latenciesBuilder.setSum(intervalHistogram.getMean() * intervalHistogram.getTotalCount());\r\n    statsBuilder.setTimeElapsed((intervalHistogram.getEndTimeStamp() - intervalHistogram.getStartTimeStamp()) / 1000.0);\r\n    if (osBean != null) {\r\n        long nowCpu = osBean.getProcessCpuTime();\r\n        statsBuilder.setTimeUser(((double) nowCpu - lastMarkCpuTime) / 1000000000.0);\r\n        lastMarkCpuTime = nowCpu;\r\n    }\r\n    return statsBuilder.build();\r\n}"
}, {
	"Path": "com.oracle.svm.core.graal.replacements.SubstrateGraphKit.mergeUnwinds",
	"Comment": "a graph with multiple unwinds is invalid. merge the various unwind paths.",
	"Method": "void mergeUnwinds(){\r\n    List<UnwindNode> unwinds = new ArrayList();\r\n    for (Node node : getGraph().getNodes()) {\r\n        if (node instanceof UnwindNode) {\r\n            unwinds.add((UnwindNode) node);\r\n        }\r\n    }\r\n    if (unwinds.size() > 1) {\r\n        MergeNode unwindMergeNode = add(new MergeNode());\r\n        ValueNode exceptionValue = InliningUtil.mergeValueProducers(unwindMergeNode, unwinds, null, UnwindNode::exception);\r\n        UnwindNode unwindReplacement = add(new UnwindNode(exceptionValue));\r\n        unwindMergeNode.setNext(unwindReplacement);\r\n        FrameStateBuilder exceptionState = getFrameState().copy();\r\n        exceptionState.clearStack();\r\n        exceptionState.push(JavaKind.Object, exceptionValue);\r\n        exceptionState.setRethrowException(true);\r\n        unwindMergeNode.setStateAfter(exceptionState.create(BytecodeFrame.AFTER_EXCEPTION_BCI, unwindMergeNode));\r\n    }\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.context.object.AnalysisObject.getInstanceFieldFilterFlow",
	"Comment": "returns the filter field flow corresponding to an unsafe accessed filed.",
	"Method": "FieldFilterTypeFlow getInstanceFieldFilterFlow(BigBang bb,AnalysisField field){\r\n    assert !Modifier.isStatic(field.getModifiers()) && field.isUnsafeAccessed();\r\n    FieldTypeStore fieldTypeStore = getInstanceFieldTypeStore(bb, field);\r\n    return fieldTypeStore.filterFlow(bb);\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.MethodTypeFlow.addContext",
	"Comment": "add the context, if not already added, and return the method flows clone from that context.",
	"Method": "MethodFlowsGraph addContext(BigBang bb,AnalysisContext calleeContext,InvokeTypeFlow reason){\r\n    this.ensureParsed(bb, reason);\r\n    AnalysisContext newContext = bb.contextPolicy().peel(calleeContext, localCallingContextDepth);\r\n    MethodFlowsGraph methodFlows = clonedMethodFlows.get(newContext);\r\n    if (methodFlows == null) {\r\n        MethodFlowsGraph newFlows = new MethodFlowsGraph(method, newContext);\r\n        newFlows.cloneOriginalFlows(bb);\r\n        MethodFlowsGraph oldFlows = clonedMethodFlows.putIfAbsent(newContext, newFlows);\r\n        methodFlows = oldFlows != null ? oldFlows : newFlows;\r\n        if (oldFlows == null) {\r\n            methodFlows.linkClones(bb);\r\n        }\r\n    }\r\n    return methodFlows;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.Breakpoint.getSuspendAnchor",
	"Comment": "returns the suspended position within the guest language source location.",
	"Method": "SuspendAnchor getSuspendAnchor(SuspendAnchor getSuspendAnchor){\r\n    return suspendAnchor;\r\n}"
}, {
	"Path": "io.grpc.netty.NettyClientHandler.createStream",
	"Comment": "attempts to create a new stream from the given command. if there are too many active streams,the creation request is queued.",
	"Method": "void createStream(CreateStreamCommand command,ChannelPromise promise){\r\n    if (lifecycleManager.getShutdownThrowable() != null) {\r\n        command.stream().transportReportStatus(lifecycleManager.getShutdownStatus(), RpcProgress.REFUSED, true, new Metadata());\r\n        promise.setFailure(lifecycleManager.getShutdownThrowable());\r\n        return;\r\n    }\r\n    final int streamId;\r\n    try {\r\n        streamId = incrementAndGetNextStreamId();\r\n    } catch (StatusException e) {\r\n        promise.setFailure(e);\r\n        if (!connection().goAwaySent()) {\r\n            logger.fine(\"Stream IDs have been exhausted for this connection. \" + \"Initiating graceful shutdown of the connection.\");\r\n            lifecycleManager.notifyShutdown(e.getStatus());\r\n            close(ctx(), ctx().newPromise());\r\n        }\r\n        return;\r\n    }\r\n    final NettyClientStream.TransportState stream = command.stream();\r\n    final Http2Headers headers = command.headers();\r\n    stream.setId(streamId);\r\n    ChannelPromise tempPromise = ctx().newPromise();\r\n    encoder().writeHeaders(ctx(), streamId, headers, 0, command.isGet(), tempPromise).addListener(new ChannelFutureListener() {\r\n        @Override\r\n        public void operationComplete(ChannelFuture future) throws Exception {\r\n            if (future.isSuccess()) {\r\n                Http2Stream http2Stream = connection().stream(streamId);\r\n                if (http2Stream != null) {\r\n                    stream.getStatsTraceContext().clientOutboundHeaders();\r\n                    http2Stream.setProperty(streamKey, stream);\r\n                    if (command.shouldBeCountedForInUse()) {\r\n                        inUseState.updateObjectInUse(http2Stream, true);\r\n                    }\r\n                    stream.setHttp2Stream(http2Stream);\r\n                }\r\n                promise.setSuccess();\r\n            } else {\r\n                final Throwable cause = future.cause();\r\n                if (cause instanceof StreamBufferingEncoder.Http2GoAwayException) {\r\n                    StreamBufferingEncoder.Http2GoAwayException e = (StreamBufferingEncoder.Http2GoAwayException) cause;\r\n                    lifecycleManager.notifyShutdown(statusFromGoAway(e.errorCode(), e.debugData()));\r\n                    promise.setFailure(lifecycleManager.getShutdownThrowable());\r\n                } else {\r\n                    promise.setFailure(cause);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.grpc.netty.NettyClientHandler.createStream",
	"Comment": "attempts to create a new stream from the given command. if there are too many active streams,the creation request is queued.",
	"Method": "void createStream(CreateStreamCommand command,ChannelPromise promise){\r\n    if (future.isSuccess()) {\r\n        Http2Stream http2Stream = connection().stream(streamId);\r\n        if (http2Stream != null) {\r\n            stream.getStatsTraceContext().clientOutboundHeaders();\r\n            http2Stream.setProperty(streamKey, stream);\r\n            if (command.shouldBeCountedForInUse()) {\r\n                inUseState.updateObjectInUse(http2Stream, true);\r\n            }\r\n            stream.setHttp2Stream(http2Stream);\r\n        }\r\n        promise.setSuccess();\r\n    } else {\r\n        final Throwable cause = future.cause();\r\n        if (cause instanceof StreamBufferingEncoder.Http2GoAwayException) {\r\n            StreamBufferingEncoder.Http2GoAwayException e = (StreamBufferingEncoder.Http2GoAwayException) cause;\r\n            lifecycleManager.notifyShutdown(statusFromGoAway(e.errorCode(), e.debugData()));\r\n            promise.setFailure(lifecycleManager.getShutdownThrowable());\r\n        } else {\r\n            promise.setFailure(cause);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.grpc.internal.Http2ClientStreamTransportState.extractCharset",
	"Comment": "inspect the raw metadata and figure out what charset is being used.",
	"Method": "Charset extractCharset(Metadata headers){\r\n    String contentType = headers.get(GrpcUtil.CONTENT_TYPE_KEY);\r\n    if (contentType != null) {\r\n        String[] split = contentType.split(\"charset=\", 2);\r\n        try {\r\n            return Charset.forName(split[split.length - 1].trim());\r\n        } catch (Exception t) {\r\n        }\r\n    }\r\n    return Charsets.UTF_8;\r\n}"
}, {
	"Path": "io.grpc.internal.ServiceConfigUtil.getTimeoutFromMethodConfig",
	"Comment": "returns the number of nanoseconds of timeout for the given method config.",
	"Method": "Long getTimeoutFromMethodConfig(Map<String, Object> methodConfig){\r\n    if (!methodConfig.containsKey(METHOD_CONFIG_TIMEOUT_KEY)) {\r\n        return null;\r\n    }\r\n    String rawTimeout = getString(methodConfig, METHOD_CONFIG_TIMEOUT_KEY);\r\n    try {\r\n        return parseDuration(rawTimeout);\r\n    } catch (ParseException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.test.polyglot.ProxyAPITest.testInvalidArrayCopying",
	"Comment": "tests that if different incompatible argument array types are used, they are properly copied.",
	"Method": "void testInvalidArrayCopying(){\r\n    Value executable = context.asValue(new ProxyExecutable() {\r\n        @Override\r\n        public Object execute(Value... args) {\r\n            return args[0];\r\n        }\r\n    });\r\n    Value instantiable = context.asValue(new ProxyInstantiable() {\r\n        @Override\r\n        public Object newInstance(Value... args) {\r\n            return args[0];\r\n        }\r\n    });\r\n    DummyObject[] arg0 = new DummyObject[] { new DummyObject() };\r\n    DummyObject[] arg1 = new DummyObject[] { new DummyObject(), new DummyObject() };\r\n    assertSame(arg0[0], executable.execute((Object[]) arg0).asHostObject());\r\n    assertSame(arg1[0], executable.execute((Object[]) arg1).asHostObject());\r\n    assertSame(arg0[0], instantiable.newInstance((Object[]) arg0).asHostObject());\r\n    assertSame(arg1[0], instantiable.newInstance((Object[]) arg1).asHostObject());\r\n}"
}, {
	"Path": "com.oracle.truffle.api.test.polyglot.ProxyAPITest.testInvalidArrayCopying",
	"Comment": "tests that if different incompatible argument array types are used, they are properly copied.",
	"Method": "void testInvalidArrayCopying(){\r\n    return args[0];\r\n}"
}, {
	"Path": "com.oracle.truffle.api.test.polyglot.ProxyAPITest.testInvalidArrayCopying",
	"Comment": "tests that if different incompatible argument array types are used, they are properly copied.",
	"Method": "void testInvalidArrayCopying(){\r\n    return args[0];\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentationUpdateTest.testInsertInstrumentableNodes",
	"Comment": "test that we can change instrumentable nodes after the first execute by notifying theframework.",
	"Method": "void testInsertInstrumentableNodes(){\r\n    setEventFilter(SourceSectionFilter.newBuilder().indexIn(0, 6).build());\r\n    MyRoot evalRoot = eval((lang) -> {\r\n        MyRoot root = new MyRoot(language, language.request.getSource().createSection(0, 5));\r\n        return root;\r\n    }, \"abcdef\");\r\n    evalRoot.getCallTarget().call();\r\n    assertLoaded();\r\n    assertExecuted();\r\n    evalRoot.setChild(new InstrumentationUpdateNode(evalRoot.getSourceSection().getSource().createSection(0, 1)));\r\n    evalRoot.notifyChildInsert();\r\n    assertLoaded(evalRoot.getChild());\r\n    assertExecuted();\r\n    evalRoot.getCallTarget().call();\r\n    assertLoaded(evalRoot.getChild());\r\n    assertExecuted(evalRoot.getChild());\r\n    executionEvents.clear();\r\n    loadEvents.clear();\r\n    evalRoot.setChild(new InstrumentationUpdateNode(evalRoot.getSourceSection().getSource().createSection(1, 2)));\r\n    evalRoot.getChild().setChild(new InstrumentationUpdateNode(evalRoot.getSourceSection().getSource().createSection(2, 3)));\r\n    evalRoot.notifyChildInsert();\r\n    assertLoaded(evalRoot.getChild(), evalRoot.getChild().getChild());\r\n    assertExecuted();\r\n    evalRoot.getCallTarget().call();\r\n    assertLoaded(evalRoot.getChild(), evalRoot.getChild().getChild());\r\n    assertExecuted(evalRoot.getChild(), evalRoot.getChild().getChild());\r\n}"
}, {
	"Path": "io.grpc.alts.internal.AltsHandshakerClient.getResult",
	"Comment": "returns the result data of the handshake, if the handshake is completed.",
	"Method": "HandshakerResult getResult(){\r\n    return result;\r\n}"
}, {
	"Path": "io.grpc.MethodDescriptor.isSafe",
	"Comment": "returns whether this method is safe.a safe request does nothing except retrieval so it has no side effects on the server side.",
	"Method": "boolean isSafe(){\r\n    return safe;\r\n}"
}, {
	"Path": "com.oracle.svm.core.thread.VMOperation.enqueueBlockingSafepoint",
	"Comment": "convenience method for thunks that can be run by allocating a vmoperation.",
	"Method": "void enqueueBlockingSafepoint(String name,Thunk thunk){\r\n    ThunkOperation vmOperation = new ThunkOperation(name, CallerEffect.BLOCKS_CALLER, SystemEffect.CAUSES_SAFEPOINT, thunk);\r\n    vmOperation.enqueue();\r\n}"
}, {
	"Path": "com.oracle.truffle.dsl.processor.generator.FlatNodeGenFactory.useSpecializationClass",
	"Comment": "whether a new class should be generated for specialization instance fields.",
	"Method": "boolean useSpecializationClass(SpecializationData specialization){\r\n    for (CacheExpression expression : specialization.getCaches()) {\r\n        if (isNodeInterfaceArray(expression.getExpression().getResolvedType())) {\r\n            return true;\r\n        }\r\n    }\r\n    int size = 0;\r\n    for (CacheExpression expression : specialization.getCaches()) {\r\n        TypeMirror type = expression.getParameter().getType();\r\n        if (ElementUtils.isPrimitive(type)) {\r\n            switch(type.getKind()) {\r\n                case BOOLEAN:\r\n                case BYTE:\r\n                    size++;\r\n                    break;\r\n                case CHAR:\r\n                case SHORT:\r\n                    size += 2;\r\n                    break;\r\n                case INT:\r\n                case FLOAT:\r\n                    size += 4;\r\n                    break;\r\n                case LONG:\r\n                case DOUBLE:\r\n                    size += 8;\r\n                    break;\r\n            }\r\n        } else {\r\n            size += 4;\r\n        }\r\n    }\r\n    if (size > 8) {\r\n        return true;\r\n    }\r\n    return specialization.getMaximumNumberOfInstances() > 1;\r\n}"
}, {
	"Path": "io.grpc.alts.internal.AltsHandshakerStub.send",
	"Comment": "send a handshaker request and return the handshaker response.",
	"Method": "HandshakerResp send(HandshakerReq req){\r\n    maybeThrowIoException();\r\n    if (!responseQueue.isEmpty()) {\r\n        throw new IOException(\"Received an unexpected response.\");\r\n    }\r\n    writer.onNext(req);\r\n    Optional<HandshakerResp> result = responseQueue.take();\r\n    if (!result.isPresent()) {\r\n        maybeThrowIoException();\r\n    }\r\n    return result.get();\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceImpl.streamingOutputCall",
	"Comment": "given a request that specifies chunk size and interval between responses, creates and schedulesthe response stream.",
	"Method": "void streamingOutputCall(StreamingOutputCallRequest request,StreamObserver<StreamingOutputCallResponse> responseObserver){\r\n    new ResponseDispatcher(responseObserver).enqueue(toChunkQueue(request)).completeInput();\r\n}"
}, {
	"Path": "io.grpc.ManagedChannelBuilder.maxHedgedAttempts",
	"Comment": "sets max number of hedged attempts. the total number of hedged attempts for each rpc will notexceed this number even if service config may allow a higher number.this method may not work as expected for the current release because retry is not fullyimplemented yet.",
	"Method": "T maxHedgedAttempts(int maxHedgedAttempts){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.oracle.svm.core.util.TimeUtils.remainderNanosToSeconds",
	"Comment": "return the nanoseconds remaining after taking out all the seconds.",
	"Method": "long remainderNanosToSeconds(long nanos){\r\n    return (nanos % nanosPerSecond);\r\n}"
}, {
	"Path": "com.oracle.truffle.polyglot.ModuleResourceLocator.createLoader",
	"Comment": "creates a class loader than can access all resources in all modules on the module path.",
	"Method": "ClassLoader createLoader(){\r\n    List<URL> urls = new ArrayList();\r\n    for (String name : new String[] { \"java.class.path\", \"jdk.module.path\" }) {\r\n        String value = System.getProperty(name);\r\n        if (value != null) {\r\n            addURLsFromPath(urls, value);\r\n        }\r\n    }\r\n    for (int i = 0; addPatchPaths(urls, i); i++) {\r\n    }\r\n    return new URLClassLoader(urls.toArray(new URL[urls.size()]));\r\n}"
}, {
	"Path": "io.grpc.CallOptions.getMaxOutboundMessageSize",
	"Comment": "gets the maximum allowed message size acceptable to send the remote peer.",
	"Method": "Integer getMaxOutboundMessageSize(){\r\n    return maxOutboundMessageSize;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.SuspensionFilter.isIgnoreLanguageContextInitialization",
	"Comment": "test if execution of language initialization code is to be ignored.",
	"Method": "boolean isIgnoreLanguageContextInitialization(){\r\n    return ignoreLanguageContextInitialization;\r\n}"
}, {
	"Path": "com.oracle.svm.core.c.ProjectHeaderFile.resolve",
	"Comment": "resolves the path to a c header file that is located in a substrate vm project.",
	"Method": "String resolve(String projectName,String headerFile,String resolve,String projectName,String headerFile){\r\n    HeaderResolversRegistry resolvers = ImageSingletons.lookup(HeaderResolversRegistry.class);\r\n    return resolvers.resolve(projectName, headerFile);\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.meta.AnalysisField.getWrittenBy",
	"Comment": "returns all methods where the field is written. it does not include the methods where thefield is written with unsafe access.",
	"Method": "Set<MethodTypeFlow> getWrittenBy(){\r\n    return writtenBy.keySet();\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.UnalignedHeapChunk.getUnalignedHeapOverhead",
	"Comment": "the overhead of an unaligned chunk. all of the overhead is before the start of the object inthe chunk.",
	"Method": "UnsignedWord getUnalignedHeapOverhead(){\r\n    return getObjectStartOffset();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.source.SourceSection.getSource",
	"Comment": "representation of the source program that contains this section.",
	"Method": "Source getSource(){\r\n    return source;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.UnalignedHeapChunk.walkDirtyObjectsOfUnalignedHeapChunk",
	"Comment": "walk the dirty objects in this chunk, passing each to a visitor.",
	"Method": "boolean walkDirtyObjectsOfUnalignedHeapChunk(UnalignedHeader that,ObjectVisitor visitor,boolean clean){\r\n    final Log trace = Log.noopLog().string(\"[UnalignedHeapChunk.walkDirtyObjects:\");\r\n    trace.string(\"  clean: \").bool(clean).string(\"  that: \").hex(that).string(\"  \");\r\n    boolean result = true;\r\n    final Pointer rememberedSetStart = getCardTableStart(that);\r\n    final UnsignedWord objectIndex = getObjectIndex();\r\n    trace.string(\"  rememberedSetStart: \").hex(rememberedSetStart).string(\"  objectIndex: \").unsigned(objectIndex);\r\n    if (CardTable.isDirtyEntryAtIndex(rememberedSetStart, objectIndex)) {\r\n        final Pointer objectsStart = getUnalignedStart(that);\r\n        final Object obj = objectsStart.toObject();\r\n        trace.string(\"  obj: \").object(obj);\r\n        if (!visitor.visitObjectInline(obj)) {\r\n            result = false;\r\n        }\r\n        if (clean) {\r\n            CardTable.cleanEntryAtIndex(rememberedSetStart, objectIndex);\r\n        }\r\n    }\r\n    trace.string(\"  returns: \").bool(result).string(\"]\").newline();\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.truffle.tools.profiler.CPUSampler.setGatherSelfHitTimes",
	"Comment": "sets whether or not to gather timestamp information for the element at the top of the stackfor each sample.",
	"Method": "void setGatherSelfHitTimes(boolean gatherSelfHitTimes){\r\n    enterChangeConfig();\r\n    this.gatherSelfHitTimes = gatherSelfHitTimes;\r\n}"
}, {
	"Path": "io.grpc.examples.helloworld.HelloWorldServer.blockUntilShutdown",
	"Comment": "await termination on the main thread since the grpc library uses daemon threads.",
	"Method": "void blockUntilShutdown(){\r\n    if (server != null) {\r\n        server.awaitTermination();\r\n    }\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceServer.main",
	"Comment": "the main application allowing this server to be launched from the command line.",
	"Method": "void main(String[] args){\r\n    TestUtils.installConscryptIfAvailable();\r\n    final TestServiceServer server = new TestServiceServer();\r\n    server.parseArgs(args);\r\n    if (server.useTls) {\r\n        System.out.println(\"\\nUsing fake CA for TLS certificate. Test clients should expect host\\n\" + \"*.test.google.fr and our test CA. For the Java test client binary, use:\\n\" + \"--server_host_override=foo.test.google.fr --use_test_ca=true\\n\");\r\n    }\r\n    Runtime.getRuntime().addShutdownHook(new Thread() {\r\n        @Override\r\n        @SuppressWarnings(\"CatchAndPrintStackTrace\")\r\n        public void run() {\r\n            try {\r\n                System.out.println(\"Shutting down\");\r\n                server.stop();\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    });\r\n    server.start();\r\n    System.out.println(\"Server started on port \" + server.port);\r\n    server.blockUntilShutdown();\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceServer.main",
	"Comment": "the main application allowing this server to be launched from the command line.",
	"Method": "void main(String[] args){\r\n    try {\r\n        System.out.println(\"Shutting down\");\r\n        server.stop();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.stream.JsonReader.endArray",
	"Comment": "consumes the next token from the json stream and asserts that it is theend of the current array.",
	"Method": "void endArray(){\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    if (p == PEEKED_END_ARRAY) {\r\n        stackSize--;\r\n        pathIndices[stackSize - 1]++;\r\n        peeked = PEEKED_NONE;\r\n    } else {\r\n        throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + locationString());\r\n    }\r\n}"
}, {
	"Path": "io.grpc.ManagedChannelBuilder.keepAliveTimeout",
	"Comment": "sets the time waiting for read activity after sending a keepalive ping. if the time expireswithout any read activity on the connection, the connection is considered dead. an unreasonablysmall value might be increased. defaults to 20 seconds.this value should be at least multiple times the rtt to allow for lost packets.",
	"Method": "T keepAliveTimeout(long keepAliveTimeout,TimeUnit timeUnit){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.gson.Gson.newBuilder",
	"Comment": "returns a new gsonbuilder containing all custom factories and configuration used by the currentinstance.",
	"Method": "GsonBuilder newBuilder(){\r\n    return new GsonBuilder(this);\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.image.NativeImageHeap.forceHashCodeComputation",
	"Comment": "for immutable strings in the native image heap, force eager computation of the hash field.",
	"Method": "void forceHashCodeComputation(String str){\r\n    str.hashCode();\r\n}"
}, {
	"Path": "io.grpc.netty.NettyServerTransport.createHandler",
	"Comment": "creates the netty handler to be used in the channel pipeline.",
	"Method": "NettyServerHandler createHandler(ServerTransportListener transportListener,ChannelPromise channelUnused){\r\n    return NettyServerHandler.newHandler(transportListener, channelUnused, streamTracerFactories, transportTracer, maxStreams, flowControlWindow, maxHeaderListSize, maxMessageSize, keepAliveTimeInNanos, keepAliveTimeoutInNanos, maxConnectionIdleInNanos, maxConnectionAgeInNanos, maxConnectionAgeGraceInNanos, permitKeepAliveWithoutCalls, permitKeepAliveTimeInNanos);\r\n}"
}, {
	"Path": "com.oracle.svm.core.heap.ObjectReferenceVisitor.epilogue",
	"Comment": "called after all object references have been visited. if visiting terminates because avisitor returned false, this method might not be called.",
	"Method": "boolean epilogue(){\r\n    return true;\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.nodes.interop.SLForeignToSLTypeNode.unbox",
	"Comment": "in case the foreign object is a boxed primitive we unbox it using the unbox message.",
	"Method": "Object unbox(TruffleObject value){\r\n    Object unboxed = doUnbox(value);\r\n    return SLContext.fromForeignValue(unboxed);\r\n}"
}, {
	"Path": "io.grpc.internal.Http2Ping.notifyFailed",
	"Comment": "notifies the given callback that the ping operation failed.",
	"Method": "void notifyFailed(PingCallback callback,Executor executor,Throwable cause){\r\n    doExecute(executor, asRunnable(callback, cause));\r\n}"
}, {
	"Path": "com.oracle.truffle.api.test.polyglot.PolyglotCachingTest.testParsedASTIsNotCollectedIfSourceIsAlive",
	"Comment": "test that calltargets stay cached as long as their source instance is alive.",
	"Method": "void testParsedASTIsNotCollectedIfSourceIsAlive(){\r\n    Assume.assumeFalse(\"This test is too slow in fastdebug.\", System.getProperty(\"java.vm.version\").contains(\"fastdebug\"));\r\n    setupTestLang(false);\r\n    Context context = Context.create();\r\n    Source source = Source.create(ProxyLanguage.ID, \"0\");\r\n    WeakReference<CallTarget> parsedRef = new WeakReference(assertParsedEval(context, source));\r\n    for (int i = 0; i < GCUtils.GC_TEST_ITERATIONS; i++) {\r\n        assertCachedEval(context, source);\r\n        System.gc();\r\n    }\r\n    assertNotNull(parsedRef.get());\r\n    context.close();\r\n}"
}, {
	"Path": "io.grpc.lb.v1.LoadBalancerGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "LoadBalancerStub newStub(io.grpc.Channel channel){\r\n    return new LoadBalancerStub(channel);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.HeapPolicy.setMaximumYoungGenerationSize",
	"Comment": "set the maximum young generation size, returning the previous value.",
	"Method": "UnsignedWord setMaximumYoungGenerationSize(UnsignedWord value){\r\n    final UnsignedWord result = maximumYoungGenerationSize;\r\n    maximumYoungGenerationSize = value;\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.SpaceVerifierImpl.factory",
	"Comment": "a factory for a verifierimpl that will be initialized later.",
	"Method": "SpaceVerifierImpl factory(SpaceVerifierImpl.ContainsObjectVisitor factory){\r\n    return new SpaceVerifierImpl();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.EventContext.lookupExecutionEventNode",
	"Comment": "returns the execution event node that was inserted at this location given an event binding.this is useful to disambiguate multiple bindings from each other when installed at the samesource location.",
	"Method": "ExecutionEventNode lookupExecutionEventNode(EventBinding<? extends ExecutionEventNodeFactory> binding){\r\n    if (!(binding.getElement() instanceof ExecutionEventNodeFactory)) {\r\n        throw new IllegalArgumentException(String.format(\"Binding is not a subtype of %s.\", ExecutionEventNodeFactory.class.getSimpleName()));\r\n    }\r\n    return probeNode.lookupExecutionEventNode(binding);\r\n}"
}, {
	"Path": "io.grpc.benchmarks.proto.ReportQpsScenarioServiceGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "ReportQpsScenarioServiceStub newStub(io.grpc.Channel channel){\r\n    return new ReportQpsScenarioServiceStub(channel);\r\n}"
}, {
	"Path": "io.grpc.alts.AltsChannelBuilder.enableUntrustedAltsForTesting",
	"Comment": "enables untrusted alts for testing. if this function is called, we will not check whether altsis running on google cloud platform.",
	"Method": "AltsChannelBuilder enableUntrustedAltsForTesting(){\r\n    enableUntrustedAlts = true;\r\n    return this;\r\n}"
}, {
	"Path": "io.grpc.alts.internal.TsiTest.performHandshake",
	"Comment": "performs a handshake between the client handshaker and server handshaker using a transport oflength transportbuffersize.",
	"Method": "void performHandshake(int transportBufferSize,Handshakers handshakers){\r\n    TsiHandshaker clientHandshaker = handshakers.getClient();\r\n    TsiHandshaker serverHandshaker = handshakers.getServer();\r\n    byte[] transportBufferBytes = new byte[transportBufferSize];\r\n    ByteBuffer transportBuffer = ByteBuffer.wrap(transportBufferBytes);\r\n    transportBuffer.limit(0);\r\n    while (clientHandshaker.isInProgress() || serverHandshaker.isInProgress()) {\r\n        for (TsiHandshaker handshaker : new TsiHandshaker[] { clientHandshaker, serverHandshaker }) {\r\n            if (handshaker.isInProgress()) {\r\n                if (transportBuffer.hasRemaining()) {\r\n                    handshaker.processBytesFromPeer(transportBuffer);\r\n                }\r\n                if (handshaker.isInProgress()) {\r\n                    transportBuffer.clear();\r\n                    handshaker.getBytesToSendToPeer(transportBuffer);\r\n                    transportBuffer.flip();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    clientHandshaker.extractPeer();\r\n    serverHandshaker.extractPeer();\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceServer.blockUntilShutdown",
	"Comment": "await termination on the main thread since the grpc library uses daemon threads.",
	"Method": "void blockUntilShutdown(){\r\n    if (server != null) {\r\n        server.awaitTermination();\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.JsonObject.getAsJsonPrimitive",
	"Comment": "convenience method to get the specified member as a jsonprimitive element.",
	"Method": "JsonPrimitive getAsJsonPrimitive(String memberName){\r\n    return (JsonPrimitive) members.get(memberName);\r\n}"
}, {
	"Path": "com.google.common.collect.Maps.transformEntry",
	"Comment": "returns a view of an entry transformed by the specified transformer.",
	"Method": "V2 transformEntry(K key,V1 value,Entry<K, V2> transformEntry,EntryTransformer<? super K, ? super V1, V2> transformer,Entry<K, V1> entry,Entry<K, V2> transformEntry,Entry<K, V1> entry){\r\n    checkNotNull(transformer);\r\n    checkNotNull(entry);\r\n    return new AbstractMapEntry<K, V2>() {\r\n        @Override\r\n        public K getKey() {\r\n            return entry.getKey();\r\n        }\r\n        @Override\r\n        public V2 getValue() {\r\n            return transformer.transformEntry(entry.getKey(), entry.getValue());\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.google.common.collect.Maps.transformEntry",
	"Comment": "returns a view of an entry transformed by the specified transformer.",
	"Method": "V2 transformEntry(K key,V1 value,Entry<K, V2> transformEntry,EntryTransformer<? super K, ? super V1, V2> transformer,Entry<K, V1> entry,Entry<K, V2> transformEntry,Entry<K, V1> entry){\r\n    return entry.getKey();\r\n}"
}, {
	"Path": "com.google.common.collect.Maps.transformEntry",
	"Comment": "returns a view of an entry transformed by the specified transformer.",
	"Method": "V2 transformEntry(K key,V1 value,Entry<K, V2> transformEntry,EntryTransformer<? super K, ? super V1, V2> transformer,Entry<K, V1> entry,Entry<K, V2> transformEntry,Entry<K, V1> entry){\r\n    return transformer.transformEntry(entry.getKey(), entry.getValue());\r\n}"
}, {
	"Path": "com.oracle.truffle.api.frame.FrameDescriptor.getNotInFrameAssumption",
	"Comment": "make an assumption that no slot with the specified identifier is present in this framedescriptor. invalidated when a frame slot with the identifier is added.",
	"Method": "Assumption getNotInFrameAssumption(Object identifier){\r\n    CompilerAsserts.neverPartOfCompilation(NEVER_PART_OF_COMPILATION_MESSAGE);\r\n    synchronized (lock) {\r\n        if (identifierToSlotMap.containsKey(identifier)) {\r\n            throw new IllegalArgumentException(\"Cannot get not-in-frame assumption for existing frame slot!\");\r\n        }\r\n        if (identifierToNotInFrameAssumptionMap == null) {\r\n            identifierToNotInFrameAssumptionMap = EconomicMap.create();\r\n        } else {\r\n            Assumption assumption = identifierToNotInFrameAssumptionMap.get(identifier);\r\n            if (assumption != null) {\r\n                return assumption;\r\n            }\r\n        }\r\n        Assumption assumption = Truffle.getRuntime().createAssumption(\"identifier not in frame\");\r\n        identifierToNotInFrameAssumptionMap.put(identifier, assumption);\r\n        return assumption;\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.code.CodeInfoQueryResult.getFrameInfo",
	"Comment": "stack frame information used, e.g., for deoptimization and printing of stack frames in debugbuilds.",
	"Method": "FrameInfoQueryResult getFrameInfo(){\r\n    return frameInfo;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentationTest.testMultipleInstruments",
	"Comment": "test oncreate, onfinalize and ondispose invocations for multiple instrument instances.",
	"Method": "void testMultipleInstruments(){\r\n    run(\"\");\r\n    MultipleInstanceInstrument.onCreateCounter = 0;\r\n    MultipleInstanceInstrument.onFinalizeCounter = 0;\r\n    MultipleInstanceInstrument.onDisposeCounter = 0;\r\n    MultipleInstanceInstrument.constructor = 0;\r\n    Instrument instrument1 = engine.getInstruments().get(\"testMultipleInstruments\");\r\n    cleanup();\r\n    Assert.assertEquals(0, MultipleInstanceInstrument.constructor);\r\n    Assert.assertEquals(0, MultipleInstanceInstrument.onCreateCounter);\r\n    Assert.assertEquals(0, MultipleInstanceInstrument.onFinalizeCounter);\r\n    Assert.assertEquals(0, MultipleInstanceInstrument.onDisposeCounter);\r\n    engine = getEngine();\r\n    MultipleInstanceInstrument.onCreateCounter = 0;\r\n    instrument1 = engine.getInstruments().get(\"testMultipleInstruments\");\r\n    instrument1.lookup(Object.class);\r\n    Assert.assertEquals(1, MultipleInstanceInstrument.constructor);\r\n    Assert.assertEquals(1, MultipleInstanceInstrument.onCreateCounter);\r\n    Assert.assertEquals(0, MultipleInstanceInstrument.onFinalizeCounter);\r\n    Assert.assertEquals(0, MultipleInstanceInstrument.onDisposeCounter);\r\n    Instrument instrument2 = engine.getInstruments().get(\"testMultipleInstruments\");\r\n    instrument2.lookup(Object.class);\r\n    Assert.assertEquals(1, MultipleInstanceInstrument.constructor);\r\n    Assert.assertEquals(1, MultipleInstanceInstrument.onCreateCounter);\r\n    Assert.assertEquals(0, MultipleInstanceInstrument.onFinalizeCounter);\r\n    Assert.assertEquals(0, MultipleInstanceInstrument.onDisposeCounter);\r\n    engine.close();\r\n    engine = null;\r\n    Assert.assertEquals(1, MultipleInstanceInstrument.constructor);\r\n    Assert.assertEquals(1, MultipleInstanceInstrument.onCreateCounter);\r\n    Assert.assertEquals(1, MultipleInstanceInstrument.onFinalizeCounter);\r\n    Assert.assertEquals(1, MultipleInstanceInstrument.onDisposeCounter);\r\n}"
}, {
	"Path": "com.oracle.svm.core.heap.FeebleReference.clearList",
	"Comment": "clears the list, returning the previous value, which might be null.",
	"Method": "FeebleReferenceList<T> clearList(){\r\n    return list.getAndSet(null);\r\n}"
}, {
	"Path": "com.oracle.svm.core.jdk8.zipfile.ZipUtils.extendedDosToJavaTime",
	"Comment": "converts extended dos time to java time, where up to 1999 millisecondsmight be encoded into the upper half of the returned long.",
	"Method": "long extendedDosToJavaTime(long xdostime){\r\n    long time = dosToJavaTime(xdostime);\r\n    return time + (xdostime >> 32);\r\n}"
}, {
	"Path": "io.grpc.internal.InternalSubchannelTest.createClientTransportOptions",
	"Comment": "create clienttransportoptions. should not be reused if it may be mutated.",
	"Method": "ClientTransportFactory.ClientTransportOptions createClientTransportOptions(){\r\n    return new ClientTransportFactory.ClientTransportOptions().setAuthority(AUTHORITY).setUserAgent(USER_AGENT);\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.image.NativeImageHeap.recursiveAddObject",
	"Comment": "break recursion using a worklist, to support large object graphs that would lead to a stackoverflow.",
	"Method": "void recursiveAddObject(Object original,boolean immutableFromParent,Object reason){\r\n    if (original != null) {\r\n        addObjectWorklist.push(new AddObjectData(original, immutableFromParent, reason));\r\n    }\r\n}"
}, {
	"Path": "io.grpc.benchmarks.proto.BenchmarkServiceGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "BenchmarkServiceStub newStub(io.grpc.Channel channel){\r\n    return new BenchmarkServiceStub(channel);\r\n}"
}, {
	"Path": "com.oracle.svm.core.code.FrameInfoQueryResult.getDeoptMethodAddress",
	"Comment": "returns the entry point address of the deoptimization target method.",
	"Method": "CodePointer getDeoptMethodAddress(){\r\n    return CodeInfoTable.getImageCodeCache().absoluteIP(deoptMethodOffset);\r\n}"
}, {
	"Path": "com.oracle.svm.core.MonitorSupport.monitorEnter",
	"Comment": "implements the monitorenter bytecode. the null check for the parameter must have already beendone beforehand.this is a static method so that it can be called directly via a foreign call from snippets.",
	"Method": "void monitorEnter(Object obj){\r\n    assert obj != null;\r\n    if (!SubstrateOptions.MultiThreaded.getValue()) {\r\n        return;\r\n    }\r\n    ReentrantLock lockObject = null;\r\n    try (PauseRecurringCallback prc = new PauseRecurringCallback()) {\r\n        try {\r\n            lockObject = ImageSingletons.lookup(MonitorSupport.class).getOrCreateMonitor(obj, true);\r\n            lockObject.lock();\r\n        } catch (Throwable ex) {\r\n            throw shouldNotReachHere(\"monitorEnter\", obj, lockObject, ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.AlignedHeapChunk.getObjectOffset",
	"Comment": "return the offset of an object within the objects part of a chunk.",
	"Method": "UnsignedWord getObjectOffset(AlignedHeader that,Pointer objectPointer){\r\n    final Pointer objectsStart = getObjectsStart(that);\r\n    assert objectsStart.belowOrEqual(objectPointer);\r\n    assert objectPointer.belowOrEqual(that.getEnd());\r\n    return objectPointer.subtract(objectsStart);\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.MethodTypeFlow.foldTypeFlow",
	"Comment": "get a type state containing the union of states over all the clones of the original flow.",
	"Method": "TypeState foldTypeFlow(BigBang bb,TypeFlow<?> originalTypeFlow){\r\n    if (originalTypeFlow == null) {\r\n        return null;\r\n    }\r\n    TypeState result = TypeState.forEmpty();\r\n    for (MethodFlowsGraph methodFlows : clonedMethodFlows.values()) {\r\n        TypeFlow<?> clonedTypeFlow = methodFlows.lookupCloneOf(bb, originalTypeFlow);\r\n        TypeState cloneState = clonedTypeFlow.getState();\r\n        TypeState cloneStateCopy = TypeState.forContextInsensitiveTypeState(bb, cloneState);\r\n        result = TypeState.forUnion(bb, result, cloneStateCopy);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.svm.graal.SubstrateGraalUtils.compile",
	"Comment": "does the compilation of the method and returns the compilation result.",
	"Method": "CompilationResult compile(DebugContext debug,SubstrateMethod method,CompilationResult compile,DebugContext debug,RuntimeConfiguration runtimeConfig,Suites suites,LIRSuites lirSuites,SubstrateMethod method){\r\n    updateGraalArchitectureWithHostCPUFeatures(runtimeConfig.lookupBackend(method));\r\n    return doCompile(debug, runtimeConfig, suites, lirSuites, method);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.OldGeneration.tearDown",
	"Comment": "return all allocated virtual memory chunks to heapchunkprovider.",
	"Method": "void tearDown(){\r\n    fromSpace.tearDown();\r\n    toSpace.tearDown();\r\n    pinnedFromSpace.tearDown();\r\n    pinnedToSpace.tearDown();\r\n}"
}, {
	"Path": "com.oracle.svm.core.deopt.DeoptimizedFrame.getTopFrame",
	"Comment": "the top frame, i.e., the innermost callee of the inlining hierarchy.",
	"Method": "VirtualFrame getTopFrame(){\r\n    return topFrame;\r\n}"
}, {
	"Path": "com.oracle.svm.graal.SubstrateGraalUtils.compileAndInstall",
	"Comment": "compile and install the method. return the installed code descriptor.",
	"Method": "InstalledCode compileAndInstall(OptionValues options,SubstrateMethod method,InstalledCode compileAndInstall,OptionValues options,RuntimeConfiguration runtimeConfig,Suites suites,LIRSuites lirSuites,SubstrateMethod method,InstalledCode compileAndInstall,OptionValues options,SubstrateMethod method,boolean testTrampolineJumps,InstalledCode compileAndInstall,OptionValues options,RuntimeConfiguration runtimeConfig,Suites suites,LIRSuites lirSuites,SubstrateMethod method,boolean testTrampolineJumps){\r\n    updateGraalArchitectureWithHostCPUFeatures(runtimeConfig.lookupBackend(method));\r\n    DebugContext debug = DebugContext.create(options, new GraalDebugHandlersFactory(GraalSupport.getRuntimeConfig().getSnippetReflection()));\r\n    SubstrateInstalledCodeImpl installedCode = new SubstrateInstalledCodeImpl(method);\r\n    SubstrateGraalUtils.doCompileAndInstall(debug, runtimeConfig, suites, lirSuites, method, installedCode, testTrampolineJumps);\r\n    return installedCode;\r\n}"
}, {
	"Path": "com.oracle.svm.core.heap.ObjectVisitor.epilogue",
	"Comment": "called after all objects have been visited. for example, from the client who creates theobjectvisitor. if visiting terminates because a visitor returned false, this method might notbe called.",
	"Method": "boolean epilogue(){\r\n    return true;\r\n}"
}, {
	"Path": "com.oracle.svm.core.heap.DiscoverableReference.setNextDiscoverableReference",
	"Comment": "write access to the next field. must use objectaccess to bypass the write barrier.",
	"Method": "void setNextDiscoverableReference(DiscoverableReference newNext,boolean newIsDiscovered){\r\n    ObjectAccess.writeObject(this, WordFactory.signed(NEXT_FIELD_OFFSET), newNext);\r\n    isDiscovered = newIsDiscovered;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.FirstObjectTable.getTableSizeForMemorySize",
	"Comment": "given the size of a memory block, how big is the table to cover it?",
	"Method": "UnsignedWord getTableSizeForMemorySize(UnsignedWord memorySize,UnsignedWord getTableSizeForMemorySize,UnsignedWord memorySize){\r\n    final UnsignedWord roundedMemory = UnsignedUtils.roundUp(memorySize, WordFactory.unsigned(MEMORY_BYTES_PER_ENTRY));\r\n    final UnsignedWord index = FirstObjectTable.memoryOffsetToIndex(roundedMemory);\r\n    return index.multiply(ENTRY_BYTES);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.UnalignedHeapChunk.committedObjectMemoryOfUnalignedHeapChunk",
	"Comment": "the committed object memory is the space between start and end.",
	"Method": "UnsignedWord committedObjectMemoryOfUnalignedHeapChunk(UnalignedHeader that){\r\n    final Pointer start = getUnalignedHeapChunkStart(that);\r\n    final Pointer end = that.getEnd();\r\n    final UnsignedWord result = end.subtract(start);\r\n    return result;\r\n}"
}, {
	"Path": "io.grpc.examples.routeguide.RouteGuideClient.setRandom",
	"Comment": "only used for unit test, as we do not want to introduce randomness in unit test.",
	"Method": "void setRandom(Random random){\r\n    this.random = random;\r\n}"
}, {
	"Path": "io.grpc.netty.NettyServerBuilder.keepAliveTimeout",
	"Comment": "sets a custom keepalive timeout, the timeout for keepalive ping requests. an unreasonably smallvalue might be increased.",
	"Method": "NettyServerBuilder keepAliveTimeout(long keepAliveTimeout,TimeUnit timeUnit){\r\n    checkArgument(keepAliveTimeout > 0L, \"keepalive timeout must be positive\");\r\n    keepAliveTimeoutInNanos = timeUnit.toNanos(keepAliveTimeout);\r\n    keepAliveTimeoutInNanos = KeepAliveManager.clampKeepAliveTimeoutInNanos(keepAliveTimeoutInNanos);\r\n    if (keepAliveTimeoutInNanos < MIN_KEEPALIVE_TIMEOUT_NANO) {\r\n        keepAliveTimeoutInNanos = MIN_KEEPALIVE_TIMEOUT_NANO;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.CompilerDirectives.isCompilationConstant",
	"Comment": "returns a boolean indicating whether or not a given value is seen as constant in optimizedcode. if this method is called in the interpreter this method will always returntrue.note that optimizations that a compiler will apply to code that is conditional oniscompilationconstant may be limited. for this reasoniscompilationconstant is not recommended for use to select between alternateimplementations of functionality depending on whether a value is constant. instead, it isintended for use as a diagnostic mechanism.",
	"Method": "boolean isCompilationConstant(Object value){\r\n    return CompilerDirectives.inInterpreter();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.TruffleLogger.isLoggable",
	"Comment": "checks if a message of the given level would be logged by this logger.",
	"Method": "boolean isLoggable(Level level,boolean isLoggable,String loggerName,Object currentContext,Level level){\r\n    int value = getLevelNum();\r\n    if (level.intValue() < value || value == OFF_VALUE) {\r\n        return false;\r\n    }\r\n    final Object currentContext = TruffleLanguage.AccessAPI.engineAccess().getCurrentOuterContext();\r\n    if (currentContext == null) {\r\n        return false;\r\n    }\r\n    return isLoggableSlowPath(currentContext, level);\r\n}"
}, {
	"Path": "com.oracle.truffle.tck.TruffleRunner.createTestClass",
	"Comment": "internal method used by the junit framework. do not call directly.",
	"Method": "TestClass createTestClass(Class<?> testClass,TestClass createTestClass,Class<?> testClass){\r\n    return new TruffleTestClass(testClass);\r\n}"
}, {
	"Path": "io.grpc.testing.integration.AbstractInteropTest.timeoutOnSleepingServer",
	"Comment": "start a fullduplexcall which the server will not respond, and verify the deadline expires.",
	"Method": "void timeoutOnSleepingServer(){\r\n    TestServiceGrpc.TestServiceStub stub = asyncStub.withDeadlineAfter(1, TimeUnit.MILLISECONDS);\r\n    StreamRecorder<StreamingOutputCallResponse> responseObserver = StreamRecorder.create();\r\n    StreamObserver<StreamingOutputCallRequest> requestObserver = stub.fullDuplexCall(responseObserver);\r\n    StreamingOutputCallRequest request = StreamingOutputCallRequest.newBuilder().setPayload(Payload.newBuilder().setBody(ByteString.copyFrom(new byte[27182]))).build();\r\n    try {\r\n        requestObserver.onNext(request);\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    assertTrue(responseObserver.awaitCompletion(operationTimeoutMillis(), TimeUnit.MILLISECONDS));\r\n    assertEquals(0, responseObserver.getValues().size());\r\n    assertEquals(Status.DEADLINE_EXCEEDED.getCode(), Status.fromThrowable(responseObserver.getError()).getCode());\r\n    if (metricsExpected()) {\r\n        MetricsRecord clientStartRecord = clientStatsRecorder.pollRecord(5, TimeUnit.SECONDS);\r\n        checkStartTags(clientStartRecord, \"grpc.testing.TestService/FullDuplexCall\");\r\n        MetricsRecord clientEndRecord = clientStatsRecorder.pollRecord(5, TimeUnit.SECONDS);\r\n        checkEndTags(clientEndRecord, \"grpc.testing.TestService/FullDuplexCall\", Status.DEADLINE_EXCEEDED.getCode());\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.Space.tearDown",
	"Comment": "return all allocated virtual memory chunks to heapchunkprovider.",
	"Method": "void tearDown(){\r\n    HeapChunkProvider.freeAlignedChunkList(getFirstAlignedHeapChunk());\r\n    HeapChunkProvider.freeUnalignedChunkList(getFirstUnalignedHeapChunk());\r\n}"
}, {
	"Path": "io.grpc.okhttp.OkHttpClientTransport.startPendingStreams",
	"Comment": "starts pending streams, returns true if at least one pending stream is started.",
	"Method": "boolean startPendingStreams(){\r\n    boolean hasStreamStarted = false;\r\n    while (!pendingStreams.isEmpty() && streams.size() < maxConcurrentStreams) {\r\n        OkHttpClientStream stream = pendingStreams.poll();\r\n        startStream(stream);\r\n        hasStreamStarted = true;\r\n    }\r\n    return hasStreamStarted;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.TruffleContext.getParent",
	"Comment": "get a parent context of this context, if any. this provides the hierarchy of inner contexts.",
	"Method": "TruffleContext getParent(){\r\n    return AccessAPI.engineAccess().getParentContext(impl);\r\n}"
}, {
	"Path": "com.oracle.svm.core.heap.ReferenceMapDecoder.walkOffsetsFromPointer",
	"Comment": "walk the reference map encoding from a pointer, applying a visitor to each object reference.",
	"Method": "boolean walkOffsetsFromPointer(PointerBase baseAddress,byte[] referenceMapEncoding,long referenceMapIndex,ObjectReferenceVisitor visitor){\r\n    assert referenceMapIndex != CodeInfoQueryResult.NO_REFERENCE_MAP;\r\n    assert referenceMapEncoding != null;\r\n    UnsignedWord uncompressedSize = WordFactory.unsigned(FrameAccess.uncompressedReferenceSize());\r\n    UnsignedWord compressedSize = WordFactory.unsigned(ConfigurationValues.getObjectLayout().getReferenceSize());\r\n    Pointer objRef = (Pointer) baseAddress;\r\n    long idx = referenceMapIndex;\r\n    while (true) {\r\n        int shift;\r\n        long b;\r\n        long gap = 0;\r\n        shift = 0;\r\n        do {\r\n            b = ByteArrayReader.getU1(referenceMapEncoding, idx);\r\n            gap |= (b & 0x7f) << shift;\r\n            shift += 7;\r\n            idx++;\r\n        } while ((b & 0x80) != 0);\r\n        long count = 0;\r\n        shift = 0;\r\n        do {\r\n            b = ByteArrayReader.getU1(referenceMapEncoding, idx);\r\n            count |= (b & 0x7f) << shift;\r\n            shift += 7;\r\n            idx++;\r\n        } while ((b & 0x80) != 0);\r\n        if ((b & 0x40) != 0 && shift < 64) {\r\n            count |= -1L << shift;\r\n        }\r\n        if (gap == 0 && count == 0) {\r\n            break;\r\n        }\r\n        objRef = objRef.add(WordFactory.unsigned(gap));\r\n        boolean compressed = (count < 0);\r\n        UnsignedWord refSize = compressed ? compressedSize : uncompressedSize;\r\n        count = (count < 0) ? -count : count;\r\n        for (long c = 0; c < count; c += 1) {\r\n            final boolean visitResult = visitor.visitObjectReferenceInline(objRef, compressed);\r\n            if (!visitResult) {\r\n                return false;\r\n            }\r\n            objRef = objRef.add(refSize);\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.oracle.svm.core.MonitorSupport.monitorExit",
	"Comment": "implements the monitorexit bytecode. the null check for the parameter must have already beendone beforehand.this is a static method so that it can be called directly via a foreign call from snippets.",
	"Method": "void monitorExit(Object obj){\r\n    assert obj != null;\r\n    if (!SubstrateOptions.MultiThreaded.getValue()) {\r\n        return;\r\n    }\r\n    ReentrantLock lockObject = null;\r\n    try (PauseRecurringCallback prc = new PauseRecurringCallback()) {\r\n        try {\r\n            lockObject = ImageSingletons.lookup(MonitorSupport.class).getOrCreateMonitor(obj, true);\r\n            lockObject.unlock();\r\n        } catch (Throwable ex) {\r\n            throw shouldNotReachHere(\"monitorExit\", obj, lockObject, ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.testRegisteredSerializerOverridesJsonAdapter",
	"Comment": "the serializer overrides field adapter, but for deserializer the fieldadapter is used.",
	"Method": "void testRegisteredSerializerOverridesJsonAdapter(){\r\n    JsonSerializer<A> serializer = new JsonSerializer<A>() {\r\n        public JsonElement serialize(A src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(\"registeredSerializer\");\r\n        }\r\n    };\r\n    Gson gson = new GsonBuilder().registerTypeAdapter(A.class, serializer).create();\r\n    String json = gson.toJson(new A(\"abcd\"));\r\n    assertEquals(\"\\\"registeredSerializer\\\"\", json);\r\n    A target = gson.fromJson(\"abcd\", A.class);\r\n    assertEquals(\"jsonAdapter\", target.value);\r\n}"
}, {
	"Path": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.testRegisteredSerializerOverridesJsonAdapter",
	"Comment": "the serializer overrides field adapter, but for deserializer the fieldadapter is used.",
	"Method": "void testRegisteredSerializerOverridesJsonAdapter(){\r\n    return new JsonPrimitive(\"registeredSerializer\");\r\n}"
}, {
	"Path": "io.grpc.okhttp.OkHttpProtocolNegotiator.getSelectedProtocol",
	"Comment": "returns the negotiated protocol, or null if no protocol was negotiated.",
	"Method": "String getSelectedProtocol(SSLSocket socket,String getSelectedProtocol,SSLSocket socket){\r\n    return platform.getSelectedProtocol(socket);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.OldGeneration.classifyPointer",
	"Comment": "this could return an enum, but i want to be able to examine it easily from a debugger.",
	"Method": "int classifyPointer(Pointer p){\r\n    if (p.isNull()) {\r\n        return 0;\r\n    }\r\n    if (slowlyFindPointerInFromSpace(p)) {\r\n        return 1;\r\n    }\r\n    if (slowlyFindPointerInToSpace(p)) {\r\n        return 2;\r\n    }\r\n    if (slowlyFindPointerInPinnedFromSpace(p)) {\r\n        return 3;\r\n    }\r\n    if (slowlyFindPointerInPinnedToSpace(p)) {\r\n        return 4;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.graalvm.component.installer.commands.InstallerTest.testInstallExistingDirectoryWillNotRevert",
	"Comment": "checks that if a directory already exists, it will not be reverted on failed install.",
	"Method": "void testInstallExistingDirectoryWillNotRevert(){\r\n    setupComponentInstall(\"truffleruby2.jar\");\r\n    Path existing = targetPath.resolve(SystemUtils.fromCommonString(\"jre/bin\"));\r\n    Files.createDirectories(existing);\r\n    JarEntry entry = componentJarFile.getJarEntry(\"jre/bin/\");\r\n    installer.installOneEntry(entry);\r\n    Path check = targetPath.resolve(SystemUtils.fromCommonString(\"jre/bin\"));\r\n    assertTrue(Files.exists(check));\r\n    assertTrue(Files.isDirectory(check));\r\n    installer.revertInstall();\r\n    assertTrue(Files.exists(check));\r\n}"
}, {
	"Path": "io.grpc.testing.TestMethodDescriptors.voidMethod",
	"Comment": "creates a new method descriptor that always creates zero length messages, and always parses tonull objects.",
	"Method": "MethodDescriptor<Void, Void> voidMethod(){\r\n    return MethodDescriptor.<Void, Void>newBuilder().setType(MethodType.UNARY).setFullMethodName(MethodDescriptor.generateFullMethodName(\"service_foo\", \"method_bar\")).setRequestMarshaller(TestMethodDescriptors.voidMarshaller()).setResponseMarshaller(TestMethodDescriptors.voidMarshaller()).build();\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.SpaceVerifierImpl.verifyChunkLists",
	"Comment": "verify the chunk list structures, but not the chunks themselves.",
	"Method": "boolean verifyChunkLists(){\r\n    final Log trace = HeapImpl.getHeapImpl().getHeapVerifierImpl().getTraceLog();\r\n    trace.string(\"[SpaceVerifierImpl.VerifierImpl.verifyChunkLists:\");\r\n    boolean result = true;\r\n    result &= verifyAlignedChunkList();\r\n    result &= verifyUnalignedList();\r\n    trace.string(\"  returns: \").bool(result);\r\n    trace.string(\"]\").newline();\r\n    return result;\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.StreamingResponseBandwidthBenchmark.teardown",
	"Comment": "stop the running calls then stop the server and client channels.",
	"Method": "void teardown(){\r\n    completed.set(true);\r\n    if (!latch.await(5, TimeUnit.SECONDS)) {\r\n        System.err.println(\"Failed to shutdown all calls.\");\r\n    }\r\n    super.teardown();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentationUpdateTest.testInsertInstrumentableNode",
	"Comment": "test that we can change an instrumentable node after the first execute by notifying theframework.",
	"Method": "void testInsertInstrumentableNode(){\r\n    setEventFilter(SourceSectionFilter.newBuilder().indexIn(6, 5).build());\r\n    MyRoot evalRoot = eval((lang) -> {\r\n        MyRoot root = new MyRoot(language, language.request.getSource().createSection(0, 5));\r\n        root.child = new InstrumentationUpdateNode(language.request.getSource().createSection(0, 5));\r\n        return root;\r\n    }, \"root1, root2\");\r\n    evalRoot.setChild(new InstrumentationUpdateNode(evalRoot.getSourceSection().getSource().createSection(6, 5)));\r\n    assertLoaded();\r\n    assertExecuted();\r\n    evalRoot.getCallTarget().call();\r\n    assertLoaded();\r\n    assertExecuted();\r\n    evalRoot.notifyChildInsert();\r\n    assertLoaded(evalRoot.getChild());\r\n    assertExecuted();\r\n    evalRoot.getCallTarget().call();\r\n    assertLoaded(evalRoot.getChild());\r\n    assertExecuted(evalRoot.getChild());\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.Space.promoteUnalignedHeapChunk",
	"Comment": "promote an unalignedheapchunk by moving it to this space, if necessary.",
	"Method": "boolean promoteUnalignedHeapChunk(UnalignedHeapChunk.UnalignedHeader uChunk){\r\n    final Log trace = Log.noopLog().string(\"[SpaceImpl.promoteCardRememberedSetUnalignedObjectChunk:\");\r\n    trace.string(\"  uChunk: \").hex(uChunk);\r\n    final Space originalSpace = uChunk.getSpace();\r\n    final boolean promote = (this != originalSpace);\r\n    if (promote) {\r\n        originalSpace.extractUnalignedHeapChunk(uChunk);\r\n        appendUnalignedHeapChunk(uChunk);\r\n        if (HeapImpl.getHeapImpl().isYoungGeneration(originalSpace)) {\r\n            trace.string(\"  setting up remembered set\");\r\n            UnalignedHeapChunk.setUpRememberedSetOfUnalignedHeapChunk(uChunk);\r\n        }\r\n    }\r\n    trace.string(\"  returns: \").bool(promote).string(\"]\").newline();\r\n    return promote;\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.test.SLTestRunner.explodeJarToTempDir",
	"Comment": "unpacks a jar file to a temporary directory that will be removed when the vm exits.",
	"Method": "String explodeJarToTempDir(File jarfilePath){\r\n    try {\r\n        final Path jarfileDir = Files.createTempDirectory(jarfilePath.getName());\r\n        Runtime.getRuntime().addShutdownHook(new Thread() {\r\n            @Override\r\n            public void run() {\r\n                delete(jarfileDir.toFile());\r\n            }\r\n        });\r\n        jarfileDir.toFile().deleteOnExit();\r\n        JarFile jarfile = new JarFile(jarfilePath);\r\n        Enumeration<JarEntry> entries = jarfile.entries();\r\n        while (entries.hasMoreElements()) {\r\n            JarEntry e = entries.nextElement();\r\n            if (!e.isDirectory()) {\r\n                File path = new File(jarfileDir.toFile(), e.getName().replace('/', File.separatorChar));\r\n                File dir = path.getParentFile();\r\n                dir.mkdirs();\r\n                assert dir.exists();\r\n                Files.copy(jarfile.getInputStream(e), path.toPath(), StandardCopyOption.REPLACE_EXISTING);\r\n            }\r\n        }\r\n        return jarfileDir.toFile().getAbsolutePath();\r\n    } catch (IOException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.test.SLTestRunner.explodeJarToTempDir",
	"Comment": "unpacks a jar file to a temporary directory that will be removed when the vm exits.",
	"Method": "String explodeJarToTempDir(File jarfilePath){\r\n    delete(jarfileDir.toFile());\r\n}"
}, {
	"Path": "com.oracle.truffle.tools.profiler.StackTraceEntry.isInterpreted",
	"Comment": "returns true if this stack entry was executed in interpreted mode at the timewhen the stack trace was captured, else false.",
	"Method": "boolean isInterpreted(){\r\n    return state == STATE_INTERPRETED;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.HeapChunkProvider.tearDown",
	"Comment": "return all allocated virtual memory chunks to virtualmemoryprovider.",
	"Method": "void tearDown(){\r\n    freeAlignedChunkList(unusedAlignedChunks.get());\r\n}"
}, {
	"Path": "com.oracle.svm.core.log.Log.string",
	"Comment": "prints the provided range of bytes in the array, without any conversion.",
	"Method": "Log string(String value,Log string,String str,int fill,int align,Log string,char[] value,Log string,byte[] value,Log string,byte[] value,int offset,int length,Log string,CCharPointer value,Log string,String value,Log string,String str,int fill,int align,Log string,char[] value,Log string,byte[] value,int offset,int length,Log string,CCharPointer value){\r\n    return string(value, 0, value.length);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.HeapChunk.setTopCarefully",
	"Comment": "set top, being careful that it is between the current top and end.",
	"Method": "void setTopCarefully(Header<?> that,Pointer newTop){\r\n    assert that.getTop().belowOrEqual(newTop) : \"newTop too low.\";\r\n    assert newTop.belowOrEqual(that.getEnd()) : \"newTop too high.\";\r\n    that.setTop(newTop);\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.StreamingPingPongsPerSecondBenchmark.pingPong",
	"Comment": "measure throughput of unary calls. the calls are already running, we just observe a counterof received responses.",
	"Method": "void pingPong(AdditionalCounters counters){\r\n    record.set(true);\r\n    Thread.sleep(1001);\r\n    record.set(false);\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.runtime.SLContext.getFunctionRegistry",
	"Comment": "returns the registry of all functions that are currently defined.",
	"Method": "SLFunctionRegistry getFunctionRegistry(){\r\n    return functionRegistry;\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.DirectoryStorageTest.testListComponentsSimple",
	"Comment": "test of listcomponentids method, of class registrystorage.",
	"Method": "void testListComponentsSimple(){\r\n    copyDir(\"list1\", registryPath);\r\n    List<String> components = new ArrayList(storage.listComponentIDs());\r\n    Collections.sort(components);\r\n    assertEquals(Arrays.asList(\"fastr\", \"fastr-2\", \"ruby\", \"sulong\"), components);\r\n}"
}, {
	"Path": "io.grpc.internal.TransportTracer.reportMessageReceived",
	"Comment": "reports that a message was successfully received. this method is thread safe.",
	"Method": "void reportMessageReceived(){\r\n    messagesReceived.add(1);\r\n    lastMessageReceivedTimeNanos = timeProvider.currentTimeNanos();\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.ObjectScanner.doScan",
	"Comment": "processes one constant entry. if the constant has an instance class then it scans its fields,using the constant as a receiver. if the constant has an array class then it scans the arrayelement constants.",
	"Method": "void doScan(WorklistEntry entry){\r\n    Object valueObj = bb.getSnippetReflectionProvider().asObject(Object.class, entry.constant);\r\n    assert checkCorrectClassloaders(entry, valueObj) : \"Invalid classloader \" + valueObj.getClass().getClassLoader() + \" for \" + valueObj + \".\\nThis error happens when objects from previous image compilations are reached in the current compilation. \" + \"To prevent this issue reset all static state from the bootclasspath and application classpath that points to the application objects. \" + \"For reference, see com.oracle.svm.truffle.TruffleFeature.cleanup().\";\r\n    AnalysisType type = bb.getMetaAccess().lookupJavaType(valueObj.getClass());\r\n    if (type.isInstanceClass()) {\r\n        for (AnalysisField field : type.getInstanceFields(true)) {\r\n            if (field.getJavaKind() == JavaKind.Object && field.isAccessed()) {\r\n                assert !Modifier.isStatic(field.getModifiers());\r\n                scanField(field, entry.constant, entry);\r\n            }\r\n        }\r\n    } else if (type.isArray() && bb.getProviders().getWordTypes().asKind(type.getComponentType()) == JavaKind.Object) {\r\n        scanArray(entry.constant, entry);\r\n    }\r\n}"
}, {
	"Path": "io.grpc.MethodDescriptor.streamResponse",
	"Comment": "serialize an outgoing response message.the returned inputstream should be closed by the caller.",
	"Method": "InputStream streamResponse(RespT response){\r\n    return responseMarshaller.stream(response);\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.nodes.access.SLWritePropertyCacheNode.writeUncached",
	"Comment": "the generic case is used if the number of shapes accessed overflows the limit of thepolymorphic inline cache.",
	"Method": "void writeUncached(DynamicObject receiver,Object name,Object value){\r\n    receiver.define(name, value);\r\n}"
}, {
	"Path": "org.graalvm.component.installer.CatalogIterableTest.testUnknownComponentButExistingFile",
	"Comment": "checks that if user mistypes a filename instead of component id, an informative note isprinted.",
	"Method": "void testUnknownComponentButExistingFile(){\r\n    exception.expect(FailedOperationException.class);\r\n    exception.expectMessage(\"REMOTE_UnknownComponentMaybeFile\");\r\n    addRemoteComponent(\"persist/data/truffleruby3.jar\", \"test://graalvm.io/download/truffleruby.zip\", false);\r\n    File mistyped = folder.newFile(\"mistyped-component.jar\");\r\n    textParams.add(mistyped.getPath());\r\n    CatalogIterable cit = new CatalogIterable(this, this, this);\r\n    assertTrue(cit.iterator().hasNext());\r\n    cit.iterator().next();\r\n}"
}, {
	"Path": "io.grpc.internal.GzipInflatingBuffer.getAndResetDeflatedBytesConsumed",
	"Comment": "reports bytes consumed by the inflater since the last invocation of this method, then resetsthe count to zero.",
	"Method": "int getAndResetDeflatedBytesConsumed(){\r\n    int savedDeflatedBytesConsumed = deflatedBytesConsumed;\r\n    deflatedBytesConsumed = 0;\r\n    return savedDeflatedBytesConsumed;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.UnalignedHeapChunk.allocateMemory",
	"Comment": "allocate memory within this alignedheapchunk. no initialization of the memory happens here.",
	"Method": "Pointer allocateMemory(UnalignedHeader that,UnsignedWord size){\r\n    final UnsignedWord available = availableObjectMemory(that);\r\n    Pointer result = WordFactory.nullPointer();\r\n    if (size.belowOrEqual(available)) {\r\n        result = that.getTop();\r\n        final Pointer newTop = result.add(size);\r\n        setTopCarefully(that, newTop);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.grpc.Deadline.after",
	"Comment": "create a deadline that will expire at the specified offset from the current system clock.",
	"Method": "Deadline after(long duration,TimeUnit units,Deadline after,long duration,TimeUnit units,Ticker ticker){\r\n    checkNotNull(units, \"units\");\r\n    return new Deadline(ticker, units.toNanos(duration), true);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.EventContext.lookupExecutionEventNodes",
	"Comment": "returns all execution event nodes in the insertion order at this location, whose eventbindings are contained in the given collection. this is useful to be able to sort outmultiple bindings when installed at the same source location.",
	"Method": "Iterator<ExecutionEventNode> lookupExecutionEventNodes(Collection<EventBinding<? extends ExecutionEventNodeFactory>> bindings){\r\n    return probeNode.lookupExecutionEventNodes(bindings);\r\n}"
}, {
	"Path": "com.oracle.truffle.object.ShapeImpl.replaceProperty",
	"Comment": "duplicate shape exchanging existing property with new property.",
	"Method": "ShapeImpl replaceProperty(Property oldProperty,Property newProperty){\r\n    assert oldProperty.getKey().equals(newProperty.getKey());\r\n    onPropertyTransition(oldProperty);\r\n    return layout.getStrategy().replaceProperty(this, oldProperty, newProperty);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.dsl.test.ReplacesTest.testReplaces4",
	"Comment": "tests that if it can be derived that two specializations actually a as powerful as the latterwe can combine them. therefore operation should always become monomorphic in the end.",
	"Method": "void testReplaces4(){\r\n    assertRuns(Replaces4Factory.getInstance(), array(-1, 0, 1, 2), array(1, 0, 1, 2), new TestExecutionListener() {\r\n        public void afterExecution(TestRootNode<? extends ValueNode> node, int index, Object value, Object expectedResult, Object actualResult, boolean last) {\r\n            Assert.assertEquals(NodeCost.MONOMORPHIC, node.getNode().getCost());\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.oracle.truffle.api.dsl.test.ReplacesTest.testReplaces4",
	"Comment": "tests that if it can be derived that two specializations actually a as powerful as the latterwe can combine them. therefore operation should always become monomorphic in the end.",
	"Method": "void testReplaces4(){\r\n    Assert.assertEquals(NodeCost.MONOMORPHIC, node.getNode().getCost());\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.context.object.ContextSensitiveAnalysisObject.getReferencedObjects",
	"Comment": "returns the list of referenced objects, i.e., field objects or array elements discovered bythe static analysis.since this list is not updated during the analysis, for complete results this should only becalled when the base analysis has finished.",
	"Method": "List<AnalysisObject> getReferencedObjects(){\r\n    if (referencedObjects == null) {\r\n        HashSet<AnalysisObject> objectsSet = new HashSet();\r\n        if (this.type().isArray()) {\r\n            for (AnalysisObject object : arrayElementsTypeStore.readFlow().getState().objects()) {\r\n                objectsSet.add(object);\r\n            }\r\n        } else {\r\n            if (instanceFieldsTypeStore != null) {\r\n                for (int i = 0; i < instanceFieldsTypeStore.length(); i++) {\r\n                    FieldTypeStore fieldTypeStore = instanceFieldsTypeStore.get(i);\r\n                    if (fieldTypeStore != null) {\r\n                        FieldTypeFlow fieldFlow = ((UnifiedFieldTypeStore) fieldTypeStore).readWriteFlow();\r\n                        if (!fieldFlow.getState().isUnknown()) {\r\n                            for (AnalysisObject object : fieldFlow.getState().objects()) {\r\n                                objectsSet.add(object);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        referencedObjects = new ArrayList(objectsSet);\r\n    }\r\n    return referencedObjects;\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.meta.UniverseBuilder.collectSubtypes",
	"Comment": "collects all subtypes of the provided type in the provided set.",
	"Method": "Set<HostedType> collectSubtypes(HostedType type,Set<HostedType> allSubtypes){\r\n    if (allSubtypes.add(type)) {\r\n        for (HostedType subtype : type.subTypes) {\r\n            collectSubtypes(subtype, allSubtypes);\r\n        }\r\n    }\r\n    return allSubtypes;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentationTest.testLanguageInstrumentationAndExceptions",
	"Comment": "test exceptions from language instrumentation are not wrapped into instrumentationexceptions.test that one language cannot instrument another.",
	"Method": "void testLanguageInstrumentationAndExceptions(){\r\n    TestLanguageInstrumentationLanguage.installInstrumentsCounter = 0;\r\n    TestLanguageInstrumentationLanguage.createContextCounter = 0;\r\n    try {\r\n        context.eval(Source.create(\"test-language-instrumentation-language\", \"ROOT(EXPRESSION)\"));\r\n        Assert.fail(\"expected exception\");\r\n    } catch (PolyglotException ex) {\r\n        assertEquals(MyLanguageException.class.getName(), ex.getMessage());\r\n    }\r\n    Assert.assertEquals(1, TestLanguageInstrumentationLanguage.installInstrumentsCounter);\r\n    Assert.assertEquals(1, TestLanguageInstrumentationLanguage.createContextCounter);\r\n    run(\"STATEMENT\");\r\n}"
}, {
	"Path": "io.grpc.internal.ServerImpl.transportClosed",
	"Comment": "remove transport service from accounting collection and notify of complete shutdown ifnecessary.",
	"Method": "void transportClosed(ServerTransport transport){\r\n    synchronized (lock) {\r\n        if (!transports.remove(transport)) {\r\n            throw new AssertionError(\"Transport already removed\");\r\n        }\r\n        channelz.removeServerSocket(ServerImpl.this, transport);\r\n        checkForTermination();\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.FileDownloaderTest.testDownloadProxy500",
	"Comment": "checks that a proxy connection which results in http 500 will not override delayed directconnection.",
	"Method": "void testDownloadProxy500(){\r\n    URL clu = getClass().getResource(\"data/truffleruby2.jar\");\r\n    URL u = new URL(\"test://graalvm.io/download/truffleruby.zip\");\r\n    ChunkedConnection directConnect = new ChunkedConnection(u, clu.openConnection()) {\r\n        @Override\r\n        public void connect() throws IOException {\r\n            try {\r\n                Thread.sleep(2000);\r\n            } catch (InterruptedException ex) {\r\n            }\r\n            super.connect();\r\n        }\r\n    };\r\n    HttpURLConnection proxyCon = new HttpURLConnection(u) {\r\n        @Override\r\n        public void disconnect() {\r\n        }\r\n        @Override\r\n        public boolean usingProxy() {\r\n            return true;\r\n        }\r\n        @Override\r\n        public void connect() throws IOException {\r\n            responseCode = 500;\r\n        }\r\n    };\r\n    Handler.bind(u.toString(), directConnect);\r\n    Handler.bindProxy(u.toString(), proxyCon);\r\n    Check check = new Check();\r\n    check.verbose = false;\r\n    delegateFeedback(check);\r\n    FileDownloader dn = new FileDownloader(\"test\", u, this);\r\n    dn.setVerbose(true);\r\n    dn.setDisplayProgress(true);\r\n    dn.envHttpProxy = \"http://localhost:11111\";\r\n    dn.envHttpsProxy = \"http://localhost:11111\";\r\n    dn.download();\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.FileDownloaderTest.testDownloadProxy500",
	"Comment": "checks that a proxy connection which results in http 500 will not override delayed directconnection.",
	"Method": "void testDownloadProxy500(){\r\n    try {\r\n        Thread.sleep(2000);\r\n    } catch (InterruptedException ex) {\r\n    }\r\n    super.connect();\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.FileDownloaderTest.testDownloadProxy500",
	"Comment": "checks that a proxy connection which results in http 500 will not override delayed directconnection.",
	"Method": "void testDownloadProxy500(){\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.FileDownloaderTest.testDownloadProxy500",
	"Comment": "checks that a proxy connection which results in http 500 will not override delayed directconnection.",
	"Method": "void testDownloadProxy500(){\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.FileDownloaderTest.testDownloadProxy500",
	"Comment": "checks that a proxy connection which results in http 500 will not override delayed directconnection.",
	"Method": "void testDownloadProxy500(){\r\n    responseCode = 500;\r\n}"
}, {
	"Path": "io.grpc.netty.NettyServerTransport.getLogLevel",
	"Comment": "accepts a throwable and returns the appropriate logging level. uninteresting exceptionsshould not clutter the log.",
	"Method": "Level getLogLevel(Throwable t){\r\n    if (t instanceof IOException && t.getMessage() != null) {\r\n        for (String msg : QUIET_ERRORS) {\r\n            if (t.getMessage().equals(msg)) {\r\n                return Level.FINE;\r\n            }\r\n        }\r\n    }\r\n    return Level.INFO;\r\n}"
}, {
	"Path": "com.oracle.truffle.dsl.processor.verify.VerifyTruffleProcessor.reportException",
	"Comment": "bugs in an annotation processor can cause silent failure so try to report any exceptionthrows as errors.",
	"Method": "void reportException(Kind kind,Element element,Throwable t){\r\n    StringWriter buf = new StringWriter();\r\n    t.printStackTrace(new PrintWriter(buf));\r\n    message(kind, element, \"Exception thrown during processing: %s\", buf.toString());\r\n}"
}, {
	"Path": "io.grpc.examples.helloworldtls.HelloWorldServerTls.blockUntilShutdown",
	"Comment": "await termination on the main thread since the grpc library uses daemon threads.",
	"Method": "void blockUntilShutdown(){\r\n    if (server != null) {\r\n        server.awaitTermination();\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.component.installer.commands.InstallerTest.testProcessPermissions",
	"Comment": "checks that permissions are correctly changed. works only on unixes.",
	"Method": "void testProcessPermissions(){\r\n    if (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\r\n        return;\r\n    }\r\n    setupComponentInstall(\"truffleruby3.jar\");\r\n    installer.unpackFiles();\r\n    Path check = targetPath.resolve(SystemUtils.fromCommonString(\"jre/bin/ruby\"));\r\n    assertFalse(Files.isExecutable(check));\r\n    installer.processPermissions();\r\n    assertFalse(Files.isExecutable(check));\r\n    installer.setPermissions(loader.loadPermissions());\r\n    installer.processPermissions();\r\n    assertTrue(Files.isExecutable(check));\r\n    assertTrue(Files.isExecutable(targetPath.resolve(SystemUtils.fromCommonString(\"jre/languages/ruby/bin/ri\"))));\r\n}"
}, {
	"Path": "com.oracle.truffle.api.test.polyglot.AbstractPolyglotTest.adoptNode",
	"Comment": "wraps a node in a rootnode and makes sure load listeners are notified, wrappers are insertedand attached execution listeners are applied.",
	"Method": "Supplier<T> adoptNode(T node){\r\n    TestRootNode root = new TestRootNode(this.language, node);\r\n    CallTarget target = Truffle.getRuntime().createCallTarget(root);\r\n    target.call();\r\n    return () -> (T) root.node;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.source.Source.createSection",
	"Comment": "create representation of a contiguous region in the source that does not have the charactercontent available.",
	"Method": "SourceSection createSection(int startLine,int startColumn,int endLine,int endColumn,SourceSection createSection,int lineNumber,SourceSection createSection,int charIndex,int length,SourceSection createSection,int startLine,int startColumn,int length){\r\n    if (hasBytes() || !hasCharacters()) {\r\n        throw new UnsupportedOperationException(\"Operation is only enabled for character based sources.\");\r\n    }\r\n    if (startLine <= 0) {\r\n        throw new IllegalArgumentException(\"startLine < 1\");\r\n    } else if (startColumn <= 0) {\r\n        throw new IllegalArgumentException(\"startColumn < 1\");\r\n    } else if (hasCharacters() && length < 0) {\r\n        throw new IllegalArgumentException(\"length < 0\");\r\n    }\r\n    final int lineStartOffset = getTextMap().lineStartOffset(startLine);\r\n    if (startColumn > getTextMap().lineLength(startLine)) {\r\n        throw new IllegalArgumentException(\"column out of range\");\r\n    }\r\n    final int charIndex = lineStartOffset + startColumn - 1;\r\n    if (charIndex + length > getCharacters().length()) {\r\n        throw new IllegalArgumentException(\"charIndex out of range\");\r\n    }\r\n    SourceSection section = new SourceSectionLoaded(this, charIndex, length);\r\n    assert assertValid(section);\r\n    return section;\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.context.object.AnalysisObject.getArrayElementsFlow",
	"Comment": "returns the array elements type flow corresponding to an analysis object of array type.",
	"Method": "ArrayElementsTypeFlow getArrayElementsFlow(BigBang bb,boolean isStore){\r\n    assert this.isObjectArray();\r\n    arrayElementsTypeStore.init(bb);\r\n    return isStore ? arrayElementsTypeStore.writeFlow() : arrayElementsTypeStore.readFlow();\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.CardTable.tableSizeForMemorySize",
	"Comment": "given the size of a memory block, how big is the table to cover it?",
	"Method": "UnsignedWord tableSizeForMemorySize(UnsignedWord memorySize){\r\n    final UnsignedWord maxIndex = indexLimitForMemorySize(memorySize);\r\n    return maxIndex.multiply(ENTRY_BYTES);\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.nodes.access.SLReadPropertyCacheNode.readUncached",
	"Comment": "the generic case is used if the number of shapes accessed overflows the limit of thepolymorphic inline cache.",
	"Method": "Object readUncached(DynamicObject receiver,Object name){\r\n    Object result = receiver.get(name);\r\n    if (result == null) {\r\n        throw SLUndefinedNameException.undefinedProperty(this, name);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebugValue.getOriginalLanguage",
	"Comment": "get the original language that created the value, if any. this method will returnnull for values representing a primitive value, or objects that are notassociated with any language.",
	"Method": "LanguageInfo getOriginalLanguage(){\r\n    if (!isReadable()) {\r\n        return null;\r\n    }\r\n    Object obj = get();\r\n    if (obj == null) {\r\n        return null;\r\n    }\r\n    return getDebugger().getEnv().findLanguage(obj);\r\n}"
}, {
	"Path": "io.grpc.reflection.testing.ReflectableServiceGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "ReflectableServiceStub newStub(io.grpc.Channel channel){\r\n    return new ReflectableServiceStub(channel);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableClassToInstanceMap.putInstance",
	"Comment": "guaranteed to throw an exception and leave the map unmodified.",
	"Method": "T putInstance(Class<T> type,T value){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.context.object.ContextSensitiveAnalysisObject.getInstanceFieldFilterFlow",
	"Comment": "returns the filter field flow corresponding to an unsafe accessed field.",
	"Method": "FieldFilterTypeFlow getInstanceFieldFilterFlow(BigBang bb,AnalysisField field){\r\n    assert !Modifier.isStatic(field.getModifiers()) && field.isUnsafeAccessed() && PointstoOptions.AllocationSiteSensitiveHeap.getValue(bb.getOptions());\r\n    FieldTypeStore fieldTypeStore = getInstanceFieldTypeStore(bb, field);\r\n    if (merged) {\r\n        mergeInstanceFieldFlow(bb, fieldTypeStore);\r\n    }\r\n    return fieldTypeStore.filterFlow(bb);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.AlignedHeapChunk.verifyHeaders",
	"Comment": "verify that all the objects have headers that say they are aligned.",
	"Method": "boolean verifyHeaders(AlignedHeader that){\r\n    final Log trace = Log.noopLog().string(\"[AlignedHeapChunk.verifyHeaders: \").string(\"  that: \").hex(that);\r\n    Pointer current = getAlignedHeapChunkStart(that);\r\n    while (current.belowThan(that.getTop())) {\r\n        trace.newline().string(\"  current: \").hex(current);\r\n        final UnsignedWord header = ObjectHeader.readHeaderFromPointer(current);\r\n        if (!ObjectHeaderImpl.getObjectHeaderImpl().isAlignedHeader(header)) {\r\n            trace.string(\"  does not have an aligned header: \").hex(header).string(\"  returns: false\").string(\"]\").newline();\r\n            return false;\r\n        }\r\n        current = LayoutEncoding.getObjectEnd(current.toObject());\r\n    }\r\n    trace.string(\"  returns: true]\").newline();\r\n    return true;\r\n}"
}, {
	"Path": "com.oracle.svm.core.code.FrameInfoQueryResult.getLocalVariableName",
	"Comment": "returns the name of the local variable with the given index, for debugging purposes only.",
	"Method": "String getLocalVariableName(int idx){\r\n    return idx < valueInfos.length ? valueInfos[idx].name : null;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.nodes.Node.toString",
	"Comment": "converts this node to a textual representation useful for debugging.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder(getClass().getSimpleName());\r\n    Map<String, Object> properties = getDebugProperties();\r\n    boolean hasProperties = false;\r\n    for (Map.Entry<String, Object> entry : properties.entrySet()) {\r\n        sb.append(hasProperties ? \",\" : \"<\");\r\n        hasProperties = true;\r\n        sb.append(entry.getKey()).append(\"=\").append(entry.getValue());\r\n    }\r\n    if (hasProperties) {\r\n        sb.append(\">\");\r\n    }\r\n    sb.append(\"@\").append(Integer.toHexString(hashCode()));\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentationTest.testEnvParse2",
	"Comment": "test that parsing and executing foreign languages with context work.",
	"Method": "void testEnvParse2(){\r\n    TestEnvParse2.onExpression = 0;\r\n    TestEnvParse2.onStatement = 0;\r\n    assureEnabled(engine.getInstruments().get(\"testEnvParse2\"));\r\n    run(\"STATEMENT\");\r\n    Assert.assertEquals(1, TestEnvParse2.onExpression);\r\n    Assert.assertEquals(1, TestEnvParse2.onStatement);\r\n    run(\"STATEMENT\");\r\n    Assert.assertEquals(2, TestEnvParse2.onExpression);\r\n    Assert.assertEquals(2, TestEnvParse2.onStatement);\r\n}"
}, {
	"Path": "com.google.gson.internal.Streams.parse",
	"Comment": "takes a reader in any state and returns the next value as a jsonelement.",
	"Method": "JsonElement parse(JsonReader reader){\r\n    boolean isEmpty = true;\r\n    try {\r\n        reader.peek();\r\n        isEmpty = false;\r\n        return TypeAdapters.JSON_ELEMENT.read(reader);\r\n    } catch (EOFException e) {\r\n        if (isEmpty) {\r\n            return JsonNull.INSTANCE;\r\n        }\r\n        throw new JsonSyntaxException(e);\r\n    } catch (MalformedJsonException e) {\r\n        throw new JsonSyntaxException(e);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    } catch (NumberFormatException e) {\r\n        throw new JsonSyntaxException(e);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.tools.chromeinspector.test.ScriptsHandlerTest.testNiceURIs",
	"Comment": "test that all possible characters in uris convert correctly.",
	"Method": "void testNiceURIs(){\r\n    char[] characters = new char[126 - 30 - ('9' - '1') - ('Z' - 'B') - ('z' - 'b')];\r\n    int base = 31;\r\n    for (char c = 32; c <= '0'; c++) {\r\n        characters[c - base] = c;\r\n    }\r\n    base += ('9' - '0' - 1);\r\n    for (char c = '9'; c <= 'A'; c++) {\r\n        characters[c - base] = c;\r\n    }\r\n    base += ('Z' - 'A' - 1);\r\n    for (char c = 'Z'; c <= 'a'; c++) {\r\n        characters[c - base] = c;\r\n    }\r\n    base += ('z' - 'a' - 1);\r\n    for (char c = 'z'; c <= 126; c++) {\r\n        characters[c - base] = c;\r\n    }\r\n    String[] all = new String[characters.length];\r\n    for (int i = 0; i < characters.length; i++) {\r\n        char c = characters[i];\r\n        all[i] = (c == 0) ? null : new String(new char[] { c });\r\n    }\r\n    for (String scheme : new String[] { null, \"a\" }) {\r\n        for (String user : all) {\r\n            for (char hostC : characters) {\r\n                if (hostC > 0 && (hostC < '.' || hostC == '/' || '9' < hostC && hostC < 'A') || 'Z' < hostC && hostC < 'a' || '{' <= hostC) {\r\n                    continue;\r\n                }\r\n                String host = (hostC == 0) ? null : new String(new char[] { hostC });\r\n                if (hostC == '.') {\r\n                    host = \"a1\";\r\n                }\r\n                for (int port = -1; port <= 10; port += 11) {\r\n                    for (char pathC : characters) {\r\n                        if (pathC == ':') {\r\n                            continue;\r\n                        }\r\n                        if (scheme != null && pathC == 0) {\r\n                            continue;\r\n                        }\r\n                        String path = (pathC == 0) ? null : (pathC == '/') ? new String(new char[] { pathC }) : new String(new char[] { '/', pathC });\r\n                        for (String query : all) {\r\n                            for (String fragment : new String[] { null, query }) {\r\n                                try {\r\n                                    URI uri = new URI(scheme, user, host, port, path, query, fragment);\r\n                                    checkConvertURINice(uri);\r\n                                } catch (URISyntaxException ex) {\r\n                                    String uriMessage = \"URI(\" + scheme + \", \" + user + \", \" + host + \", \" + port + \", \" + path + \", \" + query + \", \" + fragment + \")\";\r\n                                    throw new AssertionError(uriMessage, ex);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (char sspC : characters) {\r\n            if (sspC == 0 || sspC == ':' || '[' <= sspC && sspC <= ']') {\r\n                continue;\r\n            }\r\n            String ssp = new String(new char[] { sspC });\r\n            for (String fragment : all) {\r\n                try {\r\n                    URI uri = new URI(scheme, ssp, fragment);\r\n                    checkConvertURINice(uri);\r\n                } catch (URISyntaxException ex) {\r\n                    String uriMessage = \"URI(\" + scheme + \", \" + ssp + \", \" + fragment + \")\";\r\n                    throw new AssertionError(uriMessage, ex);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    int l = 4;\r\n    int[] indexes = new int[l];\r\n    Arrays.fill(indexes, 1);\r\n    char[] pathChars = new char[l + 1];\r\n    pathChars[0] = '/';\r\n    Arrays.fill(pathChars, 1, l + 1, characters[1]);\r\n    while (true) {\r\n        String path = new String(pathChars);\r\n        try {\r\n            URI uri = new URI(null, null, path, null);\r\n            String niceStr = checkConvertURINice(uri);\r\n            Assert.assertTrue(path, niceStr.endsWith(path));\r\n        } catch (URISyntaxException ex) {\r\n            String uriMessage = \"URI from path '\" + path + \"'\";\r\n            throw new AssertionError(uriMessage, ex);\r\n        }\r\n        int i;\r\n        for (i = 0; i < l && ++indexes[i] >= characters.length; i++) {\r\n            indexes[i] = 1;\r\n            pathChars[i + 1] = characters[1];\r\n        }\r\n        if (i >= l) {\r\n            break;\r\n        }\r\n        if (i == 0 && characters[indexes[i]] == '/') {\r\n            indexes[i]++;\r\n        }\r\n        pathChars[i + 1] = characters[indexes[i]];\r\n    }\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.typestate.TypeState.containsObject",
	"Comment": "returns true if this type state contains the object, otherwise it returns false.",
	"Method": "boolean containsObject(AnalysisObject object,boolean containsObject,AnalysisObject object,boolean containsObject,AnalysisObject object,boolean containsObject,AnalysisObject object){\r\n    return containsType(object.type()) && Arrays.binarySearch(objects(), object) >= 0;\r\n}"
}, {
	"Path": "io.grpc.netty.GrpcSslContexts.forServer",
	"Comment": "creates a sslcontextbuilder with ciphers and apn appropriate for grpc.",
	"Method": "SslContextBuilder forServer(File keyCertChainFile,File keyFile,SslContextBuilder forServer,File keyCertChainFile,File keyFile,String keyPassword,SslContextBuilder forServer,InputStream keyCertChain,InputStream key,SslContextBuilder forServer,InputStream keyCertChain,InputStream key,String keyPassword){\r\n    return configure(SslContextBuilder.forServer(keyCertChain, key, keyPassword));\r\n}"
}, {
	"Path": "com.oracle.truffle.api.TruffleFile.isSymbolicLink",
	"Comment": "tests if a file is a symbolic link. checks if the file exists and is a symbolic link.",
	"Method": "boolean isSymbolicLink(boolean isSymbolicLink){\r\n    try {\r\n        return getAttributeImpl(\"isSymbolicLink\", Boolean.class);\r\n    } catch (IOException ioe) {\r\n        return false;\r\n    } catch (SecurityException se) {\r\n        throw se;\r\n    } catch (Throwable t) {\r\n        throw wrapHostException(t);\r\n    }\r\n}"
}, {
	"Path": "io.grpc.testing.integration.NettyFlowControlTest.doTest",
	"Comment": "main testing method. streams 2 mb of data from a server and records the final window andaverage bandwidth usage.",
	"Method": "void doTest(int bandwidth,int latency){\r\n    int streamSize = 1 * 1024 * 1024;\r\n    long expectedWindow = latency * (bandwidth / TimeUnit.SECONDS.toMillis(1));\r\n    TestServiceGrpc.TestServiceStub stub = TestServiceGrpc.newStub(channel);\r\n    StreamingOutputCallRequest.Builder builder = StreamingOutputCallRequest.newBuilder().addResponseParameters(ResponseParameters.newBuilder().setSize(streamSize / 16)).addResponseParameters(ResponseParameters.newBuilder().setSize(streamSize / 16)).addResponseParameters(ResponseParameters.newBuilder().setSize(streamSize / 8)).addResponseParameters(ResponseParameters.newBuilder().setSize(streamSize / 4)).addResponseParameters(ResponseParameters.newBuilder().setSize(streamSize / 2));\r\n    StreamingOutputCallRequest request = builder.build();\r\n    TestStreamObserver observer = new TestStreamObserver(expectedWindow);\r\n    stub.streamingOutputCall(request, observer);\r\n    int lastWindow = observer.waitFor();\r\n    expectedWindow = Math.min(MAX_WINDOW, Math.max(expectedWindow, REGULAR_WINDOW));\r\n    assertTrue(\"Window was \" + lastWindow + \" expecting \" + expectedWindow, lastWindow < 2 * expectedWindow);\r\n    assertTrue(\"Window was \" + lastWindow + \" expecting \" + expectedWindow, expectedWindow < 2 * lastWindow);\r\n}"
}, {
	"Path": "io.grpc.testing.GrpcServerRule.after",
	"Comment": "after the test has completed, clean up the channel and server.",
	"Method": "void after(){\r\n    serverName = null;\r\n    serviceRegistry = null;\r\n    channel.shutdown();\r\n    server.shutdown();\r\n    try {\r\n        channel.awaitTermination(1, TimeUnit.MINUTES);\r\n        server.awaitTermination(1, TimeUnit.MINUTES);\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n        throw new RuntimeException(e);\r\n    } finally {\r\n        channel.shutdownNow();\r\n        channel = null;\r\n        server.shutdownNow();\r\n        server = null;\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.Runner.parse",
	"Comment": "parse bitcode data and do first initializations to prepare bitcode execution.",
	"Method": "CallTarget parse(Source source,CallTarget parse,Source source,ByteSequence bytes,ExternalLibrary library,LLVMParserResult parse,List<LLVMParserResult> parserResults,ArrayDeque<ExternalLibrary> dependencyQueue,ExternalLibrary lib,LLVMParserResult parse,List<LLVMParserResult> parserResults,ArrayDeque<ExternalLibrary> dependencyQueue,Source source,ExternalLibrary library,ByteSequence bytes){\r\n    ModelModule module = LLVMScanner.parse(bytes, source, context);\r\n    if (module != null) {\r\n        library.setIsNative(false);\r\n        context.addLibraryPaths(module.getLibraryPaths());\r\n        List<String> libraries = module.getLibraries();\r\n        for (String lib : libraries) {\r\n            ExternalLibrary dependency = context.addExternalLibrary(lib, true);\r\n            if (dependency != null) {\r\n                dependencyQueue.addLast(dependency);\r\n            }\r\n        }\r\n        LLVMScope fileScope = new LLVMScope();\r\n        LLVMParserRuntime runtime = new LLVMParserRuntime(context, library, fileScope);\r\n        LLVMParser parser = new LLVMParser(source, runtime);\r\n        LLVMParserResult parserResult = parser.parse(module);\r\n        parserResults.add(parserResult);\r\n        return parserResult;\r\n    } else if (!library.isNative()) {\r\n        throw new LLVMParserException(\"The file '\" + source.getName() + \"' is not a bitcode file nor an ELF File with an .llvmbc section.\");\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "io.grpc.internal.ManagedChannelImplTest.firstResolvedServerFailedToConnect",
	"Comment": "verify that if the first resolved address points to a server that cannot be connected, the callwill end up with the second address which works.",
	"Method": "void firstResolvedServerFailedToConnect(){\r\n    final SocketAddress goodAddress = new SocketAddress() {\r\n        @Override\r\n        public String toString() {\r\n            return \"goodAddress\";\r\n        }\r\n    };\r\n    final SocketAddress badAddress = new SocketAddress() {\r\n        @Override\r\n        public String toString() {\r\n            return \"badAddress\";\r\n        }\r\n    };\r\n    InOrder inOrder = inOrder(mockLoadBalancer);\r\n    List<SocketAddress> resolvedAddrs = Arrays.asList(badAddress, goodAddress);\r\n    FakeNameResolverFactory nameResolverFactory = new FakeNameResolverFactory.Builder(expectedUri).setServers(Collections.singletonList(new EquivalentAddressGroup(resolvedAddrs))).build();\r\n    channelBuilder.nameResolverFactory(nameResolverFactory);\r\n    createChannel();\r\n    ClientCall<String, Integer> call = channel.newCall(method, CallOptions.DEFAULT);\r\n    Metadata headers = new Metadata();\r\n    call.start(mockCallListener, headers);\r\n    executor.runDueTasks();\r\n    EquivalentAddressGroup addressGroup = new EquivalentAddressGroup(resolvedAddrs);\r\n    inOrder.verify(mockLoadBalancer).handleResolvedAddressGroups(eq(Arrays.asList(addressGroup)), eq(Attributes.EMPTY));\r\n    Subchannel subchannel = createSubchannelSafely(helper, addressGroup, Attributes.EMPTY);\r\n    when(mockPicker.pickSubchannel(any(PickSubchannelArgs.class))).thenReturn(PickResult.withSubchannel(subchannel));\r\n    subchannel.requestConnection();\r\n    inOrder.verify(mockLoadBalancer).handleSubchannelState(same(subchannel), stateInfoCaptor.capture());\r\n    assertEquals(CONNECTING, stateInfoCaptor.getValue().getState());\r\n    verify(mockTransportFactory).newClientTransport(same(badAddress), any(ClientTransportOptions.class));\r\n    verify(mockTransportFactory, times(0)).newClientTransport(same(goodAddress), any(ClientTransportOptions.class));\r\n    MockClientTransportInfo badTransportInfo = transports.poll();\r\n    badTransportInfo.listener.transportShutdown(Status.UNAVAILABLE);\r\n    inOrder.verifyNoMoreInteractions();\r\n    verify(mockTransportFactory).newClientTransport(same(goodAddress), any(ClientTransportOptions.class));\r\n    MockClientTransportInfo goodTransportInfo = transports.poll();\r\n    when(goodTransportInfo.transport.newStream(any(MethodDescriptor.class), any(Metadata.class), any(CallOptions.class))).thenReturn(mock(ClientStream.class));\r\n    goodTransportInfo.listener.transportReady();\r\n    inOrder.verify(mockLoadBalancer).handleSubchannelState(same(subchannel), stateInfoCaptor.capture());\r\n    assertEquals(READY, stateInfoCaptor.getValue().getState());\r\n    helper.updateBalancingState(READY, mockPicker);\r\n    executor.runDueTasks();\r\n    verify(goodTransportInfo.transport).newStream(same(method), same(headers), same(CallOptions.DEFAULT));\r\n    verify(badTransportInfo.transport, times(0)).newStream(any(MethodDescriptor.class), any(Metadata.class), any(CallOptions.class));\r\n}"
}, {
	"Path": "io.grpc.internal.ManagedChannelImplTest.firstResolvedServerFailedToConnect",
	"Comment": "verify that if the first resolved address points to a server that cannot be connected, the callwill end up with the second address which works.",
	"Method": "void firstResolvedServerFailedToConnect(){\r\n    return \"goodAddress\";\r\n}"
}, {
	"Path": "io.grpc.internal.ManagedChannelImplTest.firstResolvedServerFailedToConnect",
	"Comment": "verify that if the first resolved address points to a server that cannot be connected, the callwill end up with the second address which works.",
	"Method": "void firstResolvedServerFailedToConnect(){\r\n    return \"badAddress\";\r\n}"
}, {
	"Path": "org.graalvm.component.installer.model.ComponentRegistryTest.testGetComponentIDs",
	"Comment": "test of getcomponentids method, of class componentregistry.",
	"Method": "void testGetComponentIDs(){\r\n    Collection<String> ids = registry.getComponentIDs();\r\n    assertEquals(1, ids.size());\r\n    assertEquals(\"org.graalvm.fake\", ids.iterator().next());\r\n    registry.addComponent(rubyInfo);\r\n    assertEquals(new HashSet(Arrays.asList(\"org.graalvm.fake\", \"org.graalvm.ruby\")), new HashSet(registry.getComponentIDs()));\r\n    registry.removeComponent(rubyInfo);\r\n    assertEquals(new HashSet(Arrays.asList(\"org.graalvm.fake\")), new HashSet(registry.getComponentIDs()));\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.ObjectHeaderImpl.toStringFromHeader",
	"Comment": "debugging. but maybe not for use in log messages that i expect to be optimized away.",
	"Method": "String toStringFromHeader(UnsignedWord header){\r\n    final UnsignedWord headerBits = ObjectHeaderImpl.getHeaderBitsFromHeader(header);\r\n    if (isNoRememberedSetAlignedHeaderBits(headerBits)) {\r\n        return \"NO_REMEMBERED_SET_ALIGNED\";\r\n    } else if (isNoRememberedSetUnalignedHeaderBits(headerBits)) {\r\n        return \"NO_REMEMBERED_SET_UNALIGNED\";\r\n    } else if (isBootImageHeaderBits(headerBits)) {\r\n        return \"BOOT_IMAGE\";\r\n    } else if (headerBits.equal(UNUSED_100)) {\r\n        return \"UNUSED_100\";\r\n    } else if (headerBits.equal(UNUSED_101)) {\r\n        return \"UNUSED_101\";\r\n    } else if (isCardRememberedSetAlignedHeaderBits(headerBits)) {\r\n        return \"CARD_REMEMBERED_SET_ALIGNED\";\r\n    } else if (isCardRememberedSetUnalignedHeaderBits(headerBits)) {\r\n        return \"CARD_REMEMBERED_SET_UNALIGNED\";\r\n    } else if (isForwardedHeader(headerBits)) {\r\n        return \"FORWARDED\";\r\n    } else {\r\n        return \"UNKNOWN_CARD_REMEMBERED_SET_OBJECT_HEADER_BITS\";\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.Space.getName",
	"Comment": "the name of this space. this method is used in logging and so should not require any work.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebugStackTraceElement.getName",
	"Comment": "a description of the trace element. if the language does not provide such a description thennull is returned.",
	"Method": "String getName(){\r\n    RootNode root = findCurrentRoot();\r\n    if (root == null) {\r\n        return null;\r\n    }\r\n    try {\r\n        return root.getName();\r\n    } catch (ThreadDeath td) {\r\n        throw td;\r\n    } catch (Throwable ex) {\r\n        throw new DebugException(session, ex, root.getLanguageInfo(), null, true, null);\r\n    }\r\n}"
}, {
	"Path": "io.grpc.netty.NettyClientHandler.sendPingFrame",
	"Comment": "sends a ping frame. if a ping operation is already outstanding, the callback in the message isregistered to be called when the existing operation completes, and no new frame is sent.",
	"Method": "void sendPingFrame(ChannelHandlerContext ctx,SendPingCommand msg,ChannelPromise promise){\r\n    PingCallback callback = msg.callback();\r\n    Executor executor = msg.executor();\r\n    if (ping != null) {\r\n        promise.setSuccess();\r\n        ping.addCallback(callback, executor);\r\n        return;\r\n    }\r\n    promise.setSuccess();\r\n    promise = ctx().newPromise();\r\n    long data = USER_PING_PAYLOAD;\r\n    Stopwatch stopwatch = stopwatchFactory.get();\r\n    stopwatch.start();\r\n    ping = new Http2Ping(data, stopwatch);\r\n    ping.addCallback(callback, executor);\r\n    encoder().writePing(ctx, false, USER_PING_PAYLOAD, promise);\r\n    ctx.flush();\r\n    final Http2Ping finalPing = ping;\r\n    promise.addListener(new ChannelFutureListener() {\r\n        @Override\r\n        public void operationComplete(ChannelFuture future) throws Exception {\r\n            if (future.isSuccess()) {\r\n                transportTracer.reportKeepAliveSent();\r\n            } else {\r\n                Throwable cause = future.cause();\r\n                if (cause instanceof ClosedChannelException) {\r\n                    cause = lifecycleManager.getShutdownThrowable();\r\n                    if (cause == null) {\r\n                        cause = Status.UNKNOWN.withDescription(\"Ping failed but for unknown reason.\").withCause(future.cause()).asException();\r\n                    }\r\n                }\r\n                finalPing.failed(cause);\r\n                if (ping == finalPing) {\r\n                    ping = null;\r\n                }\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.grpc.netty.NettyClientHandler.sendPingFrame",
	"Comment": "sends a ping frame. if a ping operation is already outstanding, the callback in the message isregistered to be called when the existing operation completes, and no new frame is sent.",
	"Method": "void sendPingFrame(ChannelHandlerContext ctx,SendPingCommand msg,ChannelPromise promise){\r\n    if (future.isSuccess()) {\r\n        transportTracer.reportKeepAliveSent();\r\n    } else {\r\n        Throwable cause = future.cause();\r\n        if (cause instanceof ClosedChannelException) {\r\n            cause = lifecycleManager.getShutdownThrowable();\r\n            if (cause == null) {\r\n                cause = Status.UNKNOWN.withDescription(\"Ping failed but for unknown reason.\").withCause(future.cause()).asException();\r\n            }\r\n        }\r\n        finalPing.failed(cause);\r\n        if (ping == finalPing) {\r\n            ping = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.SpaceVerifierImpl.verifyUnalignedList",
	"Comment": "verify the unalignedchunks list, but not the chunks themselves.",
	"Method": "boolean verifyUnalignedList(){\r\n    final Log trace = HeapImpl.getHeapImpl().getHeapVerifierImpl().getTraceLog().string(\"[SpaceVerifierImpl.verifyUnalignedChunkList:\");\r\n    boolean result = true;\r\n    UnalignedHeapChunk.UnalignedHeader current = space.getFirstUnalignedHeapChunk();\r\n    UnalignedHeapChunk.UnalignedHeader previous = WordFactory.nullPointer();\r\n    while (current.isNonNull()) {\r\n        result &= current.getPrevious().equal(previous);\r\n        if (!result) {\r\n            final Log failure = HeapImpl.getHeapImpl().getHeapVerifierImpl().getWitnessLog().string(\"[SpaceVerifierImpl.VerifierImpl.verifyUnalignedChunkList:\");\r\n            failure.string(\"  space: \").string(space.getName()).string(\"  doubly-linked list failure\").string(\"]\").newline();\r\n            break;\r\n        }\r\n        previous = current;\r\n        current = current.getNext();\r\n    }\r\n    result &= previous.equal(space.getLastUnalignedHeapChunk());\r\n    if (!result) {\r\n        final Log failure = HeapImpl.getHeapImpl().getHeapVerifierImpl().getWitnessLog().string(\"[SpaceVerifierImpl.VerifierImpl.verifyUnalignedChunkList:\");\r\n        failure.string(\"  space: \").string(space.getName()).string(\"  lastUnalignedHeapChunk failure\").string(\"]\").newline();\r\n        result = false;\r\n    }\r\n    trace.string(\"  returns: \").bool(result).string(\"]\").newline();\r\n    return result;\r\n}"
}, {
	"Path": "io.grpc.okhttp.OutboundFlowController.writeStreams",
	"Comment": "writes as much data for all the streams as possible given the current flow control windows.must be called with holding transport lock.",
	"Method": "void writeStreams(){\r\n    OkHttpClientStream[] streams = transport.getActiveStreams();\r\n    int connectionWindow = connectionState.window();\r\n    for (int numStreams = streams.length; numStreams > 0 && connectionWindow > 0; ) {\r\n        int nextNumStreams = 0;\r\n        int windowSlice = (int) ceil(connectionWindow / (float) numStreams);\r\n        for (int index = 0; index < numStreams && connectionWindow > 0; ++index) {\r\n            OkHttpClientStream stream = streams[index];\r\n            OutboundFlowState state = state(stream);\r\n            int bytesForStream = min(connectionWindow, min(state.unallocatedBytes(), windowSlice));\r\n            if (bytesForStream > 0) {\r\n                state.allocateBytes(bytesForStream);\r\n                connectionWindow -= bytesForStream;\r\n            }\r\n            if (state.unallocatedBytes() > 0) {\r\n                streams[nextNumStreams++] = stream;\r\n            }\r\n        }\r\n        numStreams = nextNumStreams;\r\n    }\r\n    WriteStatus writeStatus = new WriteStatus();\r\n    for (OkHttpClientStream stream : transport.getActiveStreams()) {\r\n        OutboundFlowState state = state(stream);\r\n        state.writeBytes(state.allocatedBytes(), writeStatus);\r\n        state.clearAllocatedBytes();\r\n    }\r\n    if (writeStatus.hasWritten()) {\r\n        flush();\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.jdk.RuntimeSupport.initializeRuntimeSupport",
	"Comment": "construct and register the singleton instance, if necessary.",
	"Method": "void initializeRuntimeSupport(){\r\n    assert ImageSingletons.contains(RuntimeSupport.class) == false : \"Initializing RuntimeSupport again.\";\r\n    ImageSingletons.add(RuntimeSupport.class, new RuntimeSupport());\r\n}"
}, {
	"Path": "com.oracle.svm.core.code.CodeInfoQueryResult.isEntryPoint",
	"Comment": "indicates if the method containing the ip is an entry point method.",
	"Method": "boolean isEntryPoint(){\r\n    return totalFrameSize == ENTRY_POINT_FRAME_SIZE;\r\n}"
}, {
	"Path": "com.oracle.svm.core.SubstrateUtil.uniqueShortName",
	"Comment": "returns a short, reasonably descriptive, but still unique name for the provided method. thename includes a digest of the fully qualified method name, which ensures uniqueness.",
	"Method": "String uniqueShortName(ResolvedJavaMethod m,String uniqueShortName,Member m){\r\n    StringBuilder fullName = new StringBuilder();\r\n    fullName.append(m.getDeclaringClass().getName()).append(\".\");\r\n    if (m instanceof Constructor) {\r\n        fullName.append(\"<init>\");\r\n    } else {\r\n        fullName.append(m.getName());\r\n    }\r\n    if (m instanceof Executable) {\r\n        fullName.append(\"(\");\r\n        for (Class<?> c : ((Executable) m).getParameterTypes()) {\r\n            fullName.append(c.getName()).append(\",\");\r\n        }\r\n        fullName.append(')');\r\n        if (m instanceof Method) {\r\n            fullName.append(((Method) m).getReturnType().getName());\r\n        }\r\n    }\r\n    return stripPackage(m.getDeclaringClass().getTypeName()) + \"_\" + (m instanceof Constructor ? \"constructor\" : m.getName()) + \"_\" + SubstrateUtil.digest(fullName.toString());\r\n}"
}, {
	"Path": "com.oracle.svm.core.jdk8.zipfile.ZipEntry.setComment",
	"Comment": "sets the optional comment string for the entry.zip entry comments have maximum length of 0xffff. if the length of thespecified comment string is greater than 0xffff bytes after encoding, onlythe first 0xffff bytes are output to the zip file entry.",
	"Method": "void setComment(String comment){\r\n    this.comment = comment;\r\n}"
}, {
	"Path": "com.google.gson.JsonObject.entrySet",
	"Comment": "returns a set of members of this object. the set is ordered, and the order is in which theelements were added.",
	"Method": "Set<Map.Entry<String, JsonElement>> entrySet(){\r\n    return members.entrySet();\r\n}"
}, {
	"Path": "io.grpc.okhttp.OkHttpWritableBufferAllocator.allocate",
	"Comment": "for okhttp we will often return a buffer smaller than the requested capacity as this is themechanism for chunking a large grpc message over many data frames.",
	"Method": "WritableBuffer allocate(int capacityHint){\r\n    capacityHint = Math.min(MAX_BUFFER, Math.max(MIN_BUFFER, capacityHint));\r\n    return new OkHttpWritableBuffer(new Buffer(), capacityHint);\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.MethodFlowsGraph.invokeFlow",
	"Comment": "given a context sensitive caller, i.e., another methodflowsgraph, identify the invoketypeflowbelonging to the caller that linked to this callee.",
	"Method": "InvokeTypeFlow invokeFlow(MethodFlowsGraph callerFlowGraph,BigBang bb){\r\n    for (InvokeTypeFlow callerInvoke : callerFlowGraph.getInvokeFlows()) {\r\n        for (MethodFlowsGraph calleeFlowGraph : callerInvoke.getCalleesFlows(bb)) {\r\n            if (calleeFlowGraph.equals(this)) {\r\n                return callerInvoke;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.UnaryCallResponseBandwidthBenchmark.unary",
	"Comment": "measure bandwidth of unary call responses. the calls are already running, we just observe acounter of received responses.",
	"Method": "void unary(AdditionalCounters counters){\r\n    Thread.sleep(1001);\r\n}"
}, {
	"Path": "io.grpc.stub.MetadataUtils.newCaptureMetadataInterceptor",
	"Comment": "captures the last received metadata on a channel. useful for testing.",
	"Method": "ClientInterceptor newCaptureMetadataInterceptor(AtomicReference<Metadata> headersCapture,AtomicReference<Metadata> trailersCapture){\r\n    return new MetadataCapturingClientInterceptor(headersCapture, trailersCapture);\r\n}"
}, {
	"Path": "com.google.gson.protobuf.ProtoTypeAdapter.getCustSerializedEnumValue",
	"Comment": "retrieves the custom enum value name from the given options, and if not found, returns thespecified default value.",
	"Method": "String getCustSerializedEnumValue(EnumValueOptions options,String defaultValue){\r\n    for (Extension<EnumValueOptions, String> extension : serializedEnumValueExtensions) {\r\n        if (options.hasExtension(extension)) {\r\n            return options.getExtension(extension);\r\n        }\r\n    }\r\n    return defaultValue;\r\n}"
}, {
	"Path": "io.grpc.alts.internal.AltsTsiHandshaker.isInProgress",
	"Comment": "returns true if and only if the handshake is still in progress",
	"Method": "boolean isInProgress(){\r\n    return !handshaker.isFinished() || outputFrame.hasRemaining();\r\n}"
}, {
	"Path": "org.graalvm.component.installer.model.ComponentRegistry.addComponent",
	"Comment": "adds a component to the registry. will not save info, but will merge component informationwith the rest.",
	"Method": "void addComponent(ComponentInfo info){\r\n    replaceFilesChanged = false;\r\n    buildFileIndex();\r\n    String id = info.getId();\r\n    for (String p : info.getPaths()) {\r\n        Collection<String> compIds = fileIndex.computeIfAbsent(p, (k) -> new HashSet());\r\n        replaceFilesChanged |= !compIds.isEmpty();\r\n        compIds.add(id);\r\n        if (p.endsWith(\"/\")) {\r\n            componentDirectories.add(p);\r\n        }\r\n    }\r\n    if (allLoaded) {\r\n        components.put(id, info);\r\n    }\r\n    storage.saveComponent(info);\r\n    updateReplacedFiles();\r\n}"
}, {
	"Path": "com.google.gson.stream.JsonReader.nextNull",
	"Comment": "consumes the next token from the json stream and asserts that it is aliteral null.",
	"Method": "void nextNull(){\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    if (p == PEEKED_NULL) {\r\n        peeked = PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n    } else {\r\n        throw new IllegalStateException(\"Expected null but was \" + peek() + locationString());\r\n    }\r\n}"
}, {
	"Path": "io.grpc.examples.errorhandling.ErrorHandlingClient.advancedAsyncCall",
	"Comment": "this is more advanced and does not make use of the stub.you should not normally need to dothis, but here is how you would.",
	"Method": "void advancedAsyncCall(){\r\n    ClientCall<HelloRequest, HelloReply> call = channel.newCall(GreeterGrpc.getSayHelloMethod(), CallOptions.DEFAULT);\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    call.start(new ClientCall.Listener<HelloReply>() {\r\n        @Override\r\n        public void onClose(Status status, Metadata trailers) {\r\n            Verify.verify(status.getCode() == Status.Code.INTERNAL);\r\n            Verify.verify(status.getDescription().contains(\"Narwhal\"));\r\n            latch.countDown();\r\n        }\r\n    }, new Metadata());\r\n    call.sendMessage(HelloRequest.newBuilder().setName(\"Marge\").build());\r\n    call.halfClose();\r\n    if (!Uninterruptibles.awaitUninterruptibly(latch, 1, TimeUnit.SECONDS)) {\r\n        throw new RuntimeException(\"timeout!\");\r\n    }\r\n}"
}, {
	"Path": "io.grpc.examples.errorhandling.ErrorHandlingClient.advancedAsyncCall",
	"Comment": "this is more advanced and does not make use of the stub.you should not normally need to dothis, but here is how you would.",
	"Method": "void advancedAsyncCall(){\r\n    Verify.verify(status.getCode() == Status.Code.INTERNAL);\r\n    Verify.verify(status.getDescription().contains(\"Narwhal\"));\r\n    latch.countDown();\r\n}"
}, {
	"Path": "com.google.common.collect.Iterators.consumingForArray",
	"Comment": "returns an iterator that walks the specified array, nulling out elements behind it. this canavoid memory leaks when an element is no longer necessary.this is mainly just to avoid the intermediate arraydeque in consumingqueueiterator.",
	"Method": "Iterator<T> consumingForArray(T elements){\r\n    return new UnmodifiableIterator<T>() {\r\n        int index = 0;\r\n        @Override\r\n        public boolean hasNext() {\r\n            return index < elements.length;\r\n        }\r\n        @Override\r\n        public T next() {\r\n            if (!hasNext()) {\r\n                throw new NoSuchElementException();\r\n            }\r\n            T result = elements[index];\r\n            elements[index] = null;\r\n            index++;\r\n            return result;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.google.common.collect.Iterators.consumingForArray",
	"Comment": "returns an iterator that walks the specified array, nulling out elements behind it. this canavoid memory leaks when an element is no longer necessary.this is mainly just to avoid the intermediate arraydeque in consumingqueueiterator.",
	"Method": "Iterator<T> consumingForArray(T elements){\r\n    return index < elements.length;\r\n}"
}, {
	"Path": "com.google.common.collect.Iterators.consumingForArray",
	"Comment": "returns an iterator that walks the specified array, nulling out elements behind it. this canavoid memory leaks when an element is no longer necessary.this is mainly just to avoid the intermediate arraydeque in consumingqueueiterator.",
	"Method": "Iterator<T> consumingForArray(T elements){\r\n    if (!hasNext()) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    T result = elements[index];\r\n    elements[index] = null;\r\n    index++;\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.svm.core.heap.ObjectHeader.readHeaderFromPointer",
	"Comment": "read the header of the object at the specified address. when compressed references areenabled, the specified address must be the uncompressed absolute address of the object inmemory.",
	"Method": "UnsignedWord readHeaderFromPointer(Pointer objectPointer){\r\n    if (getReferenceSize() == Integer.BYTES) {\r\n        return WordFactory.unsigned(objectPointer.readInt(getHubOffset()));\r\n    } else {\r\n        return objectPointer.readWord(getHubOffset());\r\n    }\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.typestate.TypeState.forContextInsensitiveTypeState",
	"Comment": "simplifies a type state by replacing all context sensitive objects with context insensitiveobjects.",
	"Method": "TypeState forContextInsensitiveTypeState(BigBang bb,TypeState state){\r\n    if (!PointstoOptions.AllocationSiteSensitiveHeap.getValue(bb.getOptions()) || state.isEmpty() || state.isNull() || state.isUnknown()) {\r\n        return state;\r\n    } else {\r\n        if (state.isSingleTypeState()) {\r\n            AnalysisType type = state.exactType();\r\n            AnalysisObject analysisObject = type.getContextInsensitiveAnalysisObject();\r\n            return new SingleTypeState(bb, state.canBeNull(), bb.analysisPolicy().makePoperties(bb, analysisObject), analysisObject);\r\n        } else {\r\n            MultiTypeState multiState = (MultiTypeState) state;\r\n            AnalysisObject[] objectsArray = new AnalysisObject[multiState.typesCount()];\r\n            int i = 0;\r\n            for (AnalysisType type : multiState.types()) {\r\n                objectsArray[i++] = type.getContextInsensitiveAnalysisObject();\r\n            }\r\n            BitSet typesBitSet = multiState.typesBitSet;\r\n            int properties = bb.analysisPolicy().makePoperties(bb, objectsArray);\r\n            return new MultiTypeState(bb, multiState.canBeNull(), properties, typesBitSet, objectsArray);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.jdk8.zipfile.ZipFile.getInputStream",
	"Comment": "returns an input stream for reading the contents of the specifiedzip file entry.closing this zip file will, in turn, close all input streams thathave been returned by invocations of this method.",
	"Method": "InputStream getInputStream(ZipEntry entry){\r\n    Objects.requireNonNull(entry, \"entry\");\r\n    int pos = -1;\r\n    ZipFileInputStream in = null;\r\n    synchronized (this) {\r\n        ensureOpen();\r\n        if (Objects.equals(lastEntryName, entry.name)) {\r\n            pos = lastEntryPos;\r\n        } else if (!zc.isUTF8() && (entry.flag & EFS) != 0) {\r\n            pos = zsrc.getEntryPos(zc.getBytesUTF8(entry.name), false);\r\n        } else {\r\n            pos = zsrc.getEntryPos(zc.getBytes(entry.name), false);\r\n        }\r\n        if (pos == -1) {\r\n            return null;\r\n        }\r\n        in = new ZipFileInputStream(zsrc.cen, pos);\r\n        switch(CENHOW(zsrc.cen, pos)) {\r\n            case STORED:\r\n                synchronized (streams) {\r\n                    streams.put(in, null);\r\n                }\r\n                return in;\r\n            case DEFLATED:\r\n                long size = CENLEN(zsrc.cen, pos) + 2;\r\n                if (size > 65536) {\r\n                    size = 8192;\r\n                }\r\n                if (size <= 0) {\r\n                    size = 4096;\r\n                }\r\n                Inflater inf = getInflater();\r\n                InputStream is = new ZipFileInflaterInputStream(in, inf, (int) size);\r\n                synchronized (streams) {\r\n                    streams.put(is, inf);\r\n                }\r\n                return is;\r\n            default:\r\n                throw new ZipException(\"invalid compression method\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.component.installer.commands.InstallerTest.testSetIgnoreRequirements",
	"Comment": "checks that the component is installed despite the requirements.",
	"Method": "void testSetIgnoreRequirements(){\r\n    setupComponentInstall(\"truffleruby2.jar\");\r\n    storage.graalInfo.put(CommonConstants.CAP_GRAALVM_VERSION, \"0.30\");\r\n    installer.setIgnoreRequirements(true);\r\n    installer.validateRequirements();\r\n}"
}, {
	"Path": "io.grpc.okhttp.AsyncFrameWriter.getLogLevel",
	"Comment": "accepts a throwable and returns the appropriate logging level. uninteresting exceptionsshould not clutter the log.",
	"Method": "Level getLogLevel(Throwable t){\r\n    if (t instanceof IOException && t.getMessage() != null && QUIET_ERRORS.contains(t.getMessage())) {\r\n        return Level.FINE;\r\n    }\r\n    return Level.INFO;\r\n}"
}, {
	"Path": "com.oracle.truffle.object.ShapeImpl.isRelated",
	"Comment": "are these two shapes related, i.e. do they have the same root?",
	"Method": "boolean isRelated(Shape other){\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (this.getRoot() == getRoot()) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.grpc.okhttp.OkHttpProtocolNegotiator.negotiate",
	"Comment": "start and wait until the negotiation is done, returns the negotiated protocol.",
	"Method": "String negotiate(SSLSocket sslSocket,String hostname,List<Protocol> protocols,String negotiate,SSLSocket sslSocket,String hostname,List<Protocol> protocols){\r\n    if (protocols != null) {\r\n        configureTlsExtensions(sslSocket, hostname, protocols);\r\n    }\r\n    try {\r\n        sslSocket.startHandshake();\r\n        String negotiatedProtocol = getSelectedProtocol(sslSocket);\r\n        if (negotiatedProtocol == null) {\r\n            throw new RuntimeException(\"TLS ALPN negotiation failed with protocols: \" + protocols);\r\n        }\r\n        return negotiatedProtocol;\r\n    } finally {\r\n        platform.afterHandshake(sslSocket);\r\n    }\r\n}"
}, {
	"Path": "io.grpc.netty.AbstractNettyHandler.sendInitialConnectionWindow",
	"Comment": "sends initial connection window to the remote endpoint if necessary.",
	"Method": "void sendInitialConnectionWindow(){\r\n    if (ctx.channel().isActive() && initialConnectionWindow > 0) {\r\n        Http2Stream connectionStream = connection().connectionStream();\r\n        int currentSize = connection().local().flowController().windowSize(connectionStream);\r\n        int delta = initialConnectionWindow - currentSize;\r\n        decoder().flowController().incrementWindowSize(connectionStream, delta);\r\n        initialConnectionWindow = -1;\r\n        ctx.flush();\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.code.MustNotSynchronizeAnnotationChecker.checkMethod",
	"Comment": "check this method for direct synchronizations or calls to methods that synchronize.",
	"Method": "boolean checkMethod(HostedMethod method,HostedMethod methodImpl){\r\n    if (methodImplPath.contains(methodImpl)) {\r\n        return false;\r\n    }\r\n    MustNotSynchronize annotation = methodImpl.getAnnotation(MustNotSynchronize.class);\r\n    if ((annotation != null) && (annotation.list() == MustNotSynchronize.WHITELIST)) {\r\n        return false;\r\n    }\r\n    methodPath.push(method);\r\n    methodImplPath.push(methodImpl);\r\n    try {\r\n        if (synchronizesDirectly(methodImpl)) {\r\n            return true;\r\n        }\r\n        if (synchronizesIndirectly(methodImpl)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    } finally {\r\n        methodPath.pop();\r\n        methodImplPath.pop();\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.util.AtomicWord.getAndSet",
	"Comment": "atomically sets to the given value and returns the old value.",
	"Method": "T getAndSet(T newValue){\r\n    return WordFactory.unsigned(value.getAndSet(newValue.rawValue()));\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.Space.walkDirtyObjects",
	"Comment": "walk the dirty objects in this space, passing each to a visitor.",
	"Method": "boolean walkDirtyObjects(ObjectVisitor visitor,boolean clean){\r\n    final Log trace = Log.noopLog().string(\"[SpaceImpl.walkDirtyObjects:\");\r\n    trace.string(\"  space: \").string(getName()).string(\"  clean: \").bool(clean);\r\n    AlignedHeapChunk.AlignedHeader aChunk = getFirstAlignedHeapChunk();\r\n    while (aChunk.isNonNull()) {\r\n        trace.newline().string(\"  aChunk: \").hex(aChunk);\r\n        if (!AlignedHeapChunk.walkDirtyObjectsOfAlignedHeapChunk(aChunk, visitor, clean)) {\r\n            final Log failureLog = Log.log().string(\"[SpaceImpl.walkDirtyObjects:\");\r\n            failureLog.string(\"  aChunk.walkDirtyObjects fails\").string(\"]\").newline();\r\n            return false;\r\n        }\r\n        aChunk = aChunk.getNext();\r\n    }\r\n    UnalignedHeapChunk.UnalignedHeader uChunk = getFirstUnalignedHeapChunk();\r\n    while (uChunk.isNonNull()) {\r\n        trace.newline().string(\"  uChunk: \").hex(uChunk);\r\n        if (!UnalignedHeapChunk.walkDirtyObjectsOfUnalignedHeapChunk(uChunk, visitor, clean)) {\r\n            final Log failureLog = Log.log().string(\"[SpaceImpl.walkDirtyObjects:\");\r\n            failureLog.string(\"  uChunk.walkDirtyObjects fails\").string(\"]\").newline();\r\n            return false;\r\n        }\r\n        uChunk = uChunk.getNext();\r\n    }\r\n    trace.string(\"]\").newline();\r\n    return true;\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceImpl.streamingInputCall",
	"Comment": "waits until we have received all of the request messages and then returns the aggregate payloadsize for all of the received requests.",
	"Method": "StreamObserver<Messages.StreamingInputCallRequest> streamingInputCall(StreamObserver<Messages.StreamingInputCallResponse> responseObserver){\r\n    return new StreamObserver<StreamingInputCallRequest>() {\r\n        private int totalPayloadSize;\r\n        @Override\r\n        public void onNext(StreamingInputCallRequest message) {\r\n            totalPayloadSize += message.getPayload().getBody().size();\r\n        }\r\n        @Override\r\n        public void onCompleted() {\r\n            responseObserver.onNext(StreamingInputCallResponse.newBuilder().setAggregatedPayloadSize(totalPayloadSize).build());\r\n            responseObserver.onCompleted();\r\n        }\r\n        @Override\r\n        public void onError(Throwable cause) {\r\n            responseObserver.onError(cause);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceImpl.streamingInputCall",
	"Comment": "waits until we have received all of the request messages and then returns the aggregate payloadsize for all of the received requests.",
	"Method": "StreamObserver<Messages.StreamingInputCallRequest> streamingInputCall(StreamObserver<Messages.StreamingInputCallResponse> responseObserver){\r\n    totalPayloadSize += message.getPayload().getBody().size();\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceImpl.streamingInputCall",
	"Comment": "waits until we have received all of the request messages and then returns the aggregate payloadsize for all of the received requests.",
	"Method": "StreamObserver<Messages.StreamingInputCallRequest> streamingInputCall(StreamObserver<Messages.StreamingInputCallResponse> responseObserver){\r\n    responseObserver.onNext(StreamingInputCallResponse.newBuilder().setAggregatedPayloadSize(totalPayloadSize).build());\r\n    responseObserver.onCompleted();\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceImpl.streamingInputCall",
	"Comment": "waits until we have received all of the request messages and then returns the aggregate payloadsize for all of the received requests.",
	"Method": "StreamObserver<Messages.StreamingInputCallRequest> streamingInputCall(StreamObserver<Messages.StreamingInputCallResponse> responseObserver){\r\n    responseObserver.onError(cause);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.StepConfig.getCount",
	"Comment": "get the step count. it specifies the number of times the step repeats itself before itsuspends the execution.",
	"Method": "int getCount(){\r\n    return stepCount;\r\n}"
}, {
	"Path": "com.oracle.truffle.tck.TruffleRunner.methodInvoker",
	"Comment": "internal method used by the junit framework. do not call directly.",
	"Method": "Statement methodInvoker(FrameworkMethod method,Object test,Statement methodInvoker,FrameworkMethod method,Object test){\r\n    Statement ret = truffleTestInvoker.createStatement(getTestClass().getJavaClass().getSimpleName() + \"#\" + testName(method), method, test);\r\n    if (ret == null) {\r\n        ret = super.methodInvoker(method, test);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.CardTable.verifyCleanCards",
	"Comment": "check that every clean card indicates an object with no pointers to young space.",
	"Method": "boolean verifyCleanCards(Pointer ctStart,Pointer fotStart,Pointer objectsStart,Pointer objectsLimit){\r\n    final Log trace = Log.noopLog().string(\"[CardTable.verifyCleanCards:\");\r\n    trace.string(\"  ctStart: \").hex(ctStart).string(\"  fotStart: \").hex(fotStart).string(\"  objectsStart: \").hex(objectsStart).string(\"  objectsLimit: \").hex(objectsLimit);\r\n    final UnsignedWord indexLimit = FirstObjectTable.getTableSizeForMemoryPointers(objectsStart, objectsLimit);\r\n    for (UnsignedWord index = WordFactory.zero(); index.belowThan(indexLimit); index = index.add(1)) {\r\n        trace.newline().string(\"  index: \").unsigned(index);\r\n        if (FirstObjectTable.isUninitializedIndex(fotStart, index)) {\r\n            final Log failure = Log.log().string(\"[CardTable.verifyCleanCards: \");\r\n            failure.string(\"  reached uninitialized first object table entry\").string(\"]\").newline();\r\n            return false;\r\n        }\r\n        final boolean isClean = isCleanEntryAtIndex(ctStart, index);\r\n        if (!isClean) {\r\n            continue;\r\n        }\r\n        final Pointer impreciseStart = FirstObjectTable.getImpreciseFirstObjectPointer(fotStart, objectsStart, objectsLimit, index);\r\n        final Pointer cardLimit = indexToMemoryPointer(objectsStart, index.add(1));\r\n        final Pointer walkLimit = PointerUtils.min(cardLimit, objectsLimit);\r\n        trace.string(\"  impreciseStart: \").hex(impreciseStart).string(\"  cardLimit: \").hex(cardLimit).string(\"  walkLimit: \").hex(walkLimit);\r\n        Pointer ptr = impreciseStart;\r\n        while (ptr.belowThan(walkLimit)) {\r\n            trace.newline().string(\"  \").string(\"  ptr: \").hex(ptr);\r\n            final Object obj = ptr.toObject();\r\n            trace.string(\"  obj: \").object(obj);\r\n            if (LayoutEncoding.isArray(obj)) {\r\n                trace.string(\"  length: \").signed(KnownIntrinsics.readArrayLength(obj));\r\n            }\r\n            final boolean containsYoung = getReferenceToYoungObjectVisitor().containsReferenceToYoungObject(obj);\r\n            if (containsYoung) {\r\n                final boolean witnessForDebugging = true;\r\n                final Log witness = (witnessForDebugging ? Log.log() : HeapImpl.getHeapImpl().getHeapVerifierImpl().getTraceLog());\r\n                witness.string(\"[CardTable.verifyCleanCards:\").string(\"  objectsStart: \").hex(objectsStart).string(\"  objectsLimit: \").hex(objectsLimit).string(\"  indexLimit: \").unsigned(indexLimit).newline();\r\n                witness.string(\"  index: \").unsigned(index);\r\n                final Pointer cardStart = indexToMemoryPointer(objectsStart, index);\r\n                witness.string(\"  cardStart: \").hex(cardStart).string(\"  cardLimit: \").hex(cardLimit).string(\"  walkLimit: \").hex(walkLimit).string(\"  fotEntry: \");\r\n                FirstObjectTable.TestingBackDoor.indexToLog(fotStart, witness, index);\r\n                witness.string(\"  isClean: \").bool(isClean).newline();\r\n                final Pointer crossingOntoPointer = FirstObjectTable.getPreciseFirstObjectPointer(fotStart, objectsStart, objectsLimit, index);\r\n                final Object crossingOntoObject = crossingOntoPointer.toObject();\r\n                witness.string(\"  crossingOntoObject: \").object(crossingOntoObject).string(\"  end: \").hex(LayoutEncoding.getObjectEnd(crossingOntoObject));\r\n                if (LayoutEncoding.isArray(crossingOntoObject)) {\r\n                    witness.string(\"  array length: \").signed(KnownIntrinsics.readArrayLength(crossingOntoObject));\r\n                }\r\n                witness.string(\"  impreciseStart: \").hex(impreciseStart).newline();\r\n                witness.string(\"  obj: \").object(obj).string(\"  end: \").hex(LayoutEncoding.getObjectEnd(obj));\r\n                if (LayoutEncoding.isArray(obj)) {\r\n                    witness.string(\"  array length: \").signed(KnownIntrinsics.readArrayLength(obj));\r\n                }\r\n                witness.newline();\r\n                HeapChunk.Header<?> objChunk = AlignedHeapChunk.getEnclosingAlignedHeapChunk(obj);\r\n                witness.string(\"  objChunk: \").hex(objChunk).string(\"  objChunk space: \").string(objChunk.getSpace().getName()).string(\"  contains young: \").bool(containsYoung).newline();\r\n                getReferenceToYoungObjectVisitor().witnessReferenceToYoungObject(obj);\r\n                witness.string(\" returns false for index: \").unsigned(index).string(\"]\").newline();\r\n                return false;\r\n            }\r\n            ptr = LayoutEncoding.getObjectEnd(obj);\r\n        }\r\n    }\r\n    trace.string(\"]\").newline();\r\n    return true;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.dsl.test.SpecializationFallthroughTest.testFallthrough3",
	"Comment": "tests that the fall through is never triggered twice. in this case mixed fallthrough withnormal specializations.",
	"Method": "void testFallthrough3(){\r\n    assertRuns(FallthroughTest3Factory.getInstance(), array(0, 0, 1, 1, 2, 2), array(0, 0, 1, 1, 2, 2), new TestExecutionListener() {\r\n        public void afterExecution(TestRootNode<? extends ValueNode> node, int index, Object value, Object expectedResult, Object actualResult, boolean last) {\r\n            if (!last) {\r\n                return;\r\n            }\r\n            if (FallthroughTest3.fallthrough1 > 1) {\r\n                Assert.fail(String.valueOf(FallthroughTest3.fallthrough1));\r\n            }\r\n            FallthroughTest3.fallthrough1 = 0;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.oracle.truffle.api.dsl.test.SpecializationFallthroughTest.testFallthrough3",
	"Comment": "tests that the fall through is never triggered twice. in this case mixed fallthrough withnormal specializations.",
	"Method": "void testFallthrough3(){\r\n    if (!last) {\r\n        return;\r\n    }\r\n    if (FallthroughTest3.fallthrough1 > 1) {\r\n        Assert.fail(String.valueOf(FallthroughTest3.fallthrough1));\r\n    }\r\n    FallthroughTest3.fallthrough1 = 0;\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.nodes.access.SLWritePropertyCacheNode.lookupLocation",
	"Comment": "try to find the given property in the shape. also returns null when the value cannot be storeinto the location.",
	"Method": "Location lookupLocation(Shape shape,Object name,Location lookupLocation,Shape shape,Object name,Object value){\r\n    Location location = lookupLocation(shape, name);\r\n    if (location == null || !location.canSet(value)) {\r\n        return null;\r\n    }\r\n    return location;\r\n}"
}, {
	"Path": "io.grpc.alts.internal.NettyTsiHandshaker.isInProgress",
	"Comment": "returns true if and only if the handshake is still in progress",
	"Method": "boolean isInProgress(){\r\n    return internalHandshaker.isInProgress();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebugException.getExceptionObject",
	"Comment": "get a guest language object representing the exception, if any.",
	"Method": "DebugValue getExceptionObject(){\r\n    if (!(exception instanceof TruffleException)) {\r\n        return null;\r\n    }\r\n    Object obj = ((TruffleException) exception).getExceptionObject();\r\n    if (obj == null) {\r\n        return null;\r\n    }\r\n    LanguageInfo language = preferredLanguage;\r\n    if (language == null && throwLocation != null) {\r\n        RootNode throwRoot = throwLocation.getRootNode();\r\n        if (throwRoot != null) {\r\n            language = throwRoot.getLanguageInfo();\r\n        }\r\n    }\r\n    return new DebugValue.HeapValue(session, language, null, obj);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.dsl.test.SpecializationFallthroughTest.testFallthrough1",
	"Comment": "tests that the fall through is never triggered twice for monomorphic cases.",
	"Method": "void testFallthrough1(){\r\n    assertRuns(FallthroughTest1Factory.getInstance(), array(0, 0, 0, 1, 2), array(0, 0, 0, 1, 2), new TestExecutionListener() {\r\n        public void afterExecution(TestRootNode<? extends ValueNode> node, int index, Object value, Object expectedResult, Object actualResult, boolean last) {\r\n            if (!last) {\r\n                return;\r\n            }\r\n            if (FallthroughTest1.fallthroughCount > 1) {\r\n                Assert.fail(\"The fallthrough case must never be triggered twice. Therfore count must be <= 1, but is not.\");\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.oracle.truffle.api.dsl.test.SpecializationFallthroughTest.testFallthrough1",
	"Comment": "tests that the fall through is never triggered twice for monomorphic cases.",
	"Method": "void testFallthrough1(){\r\n    if (!last) {\r\n        return;\r\n    }\r\n    if (FallthroughTest1.fallthroughCount > 1) {\r\n        Assert.fail(\"The fallthrough case must never be triggered twice. Therfore count must be <= 1, but is not.\");\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.dsl.test.SpecializationFallthroughTest.testFallthrough2",
	"Comment": "tests that the fall through is never triggered twice with two falltrhoughs in one operation.",
	"Method": "void testFallthrough2(){\r\n    assertRuns(FallthroughTest2Factory.getInstance(), array(0, 0, 1, 1, 2, 2), array(0, 0, 1, 1, 2, 2), new TestExecutionListener() {\r\n        public void afterExecution(TestRootNode<? extends ValueNode> node, int index, Object value, Object expectedResult, Object actualResult, boolean last) {\r\n            if (!last) {\r\n                return;\r\n            }\r\n            if (FallthroughTest2.fallthrough1 > 1) {\r\n                Assert.fail();\r\n            }\r\n            if (FallthroughTest2.fallthrough2 > 1) {\r\n                Assert.fail();\r\n            }\r\n            FallthroughTest2.fallthrough1 = 0;\r\n            FallthroughTest2.fallthrough2 = 0;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.oracle.truffle.api.dsl.test.SpecializationFallthroughTest.testFallthrough2",
	"Comment": "tests that the fall through is never triggered twice with two falltrhoughs in one operation.",
	"Method": "void testFallthrough2(){\r\n    if (!last) {\r\n        return;\r\n    }\r\n    if (FallthroughTest2.fallthrough1 > 1) {\r\n        Assert.fail();\r\n    }\r\n    if (FallthroughTest2.fallthrough2 > 1) {\r\n        Assert.fail();\r\n    }\r\n    FallthroughTest2.fallthrough1 = 0;\r\n    FallthroughTest2.fallthrough2 = 0;\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.DirectoryStorageTest.testLoadComponentMetadata2",
	"Comment": "test of loadcomponentmetadata method, of class registrystorage.",
	"Method": "void testLoadComponentMetadata2(){\r\n    copyDir(\"list1\", registryPath);\r\n    ComponentInfo info = storage.loadComponentMetadata(\"fastr-2\");\r\n    assertEquals(\"org.graalvm.fastr\", info.getId());\r\n    assertTrue(info.isPolyglotRebuild());\r\n    assertTrue(info.getWorkingDirectories().contains(\"jre/languages/test/scrap\"));\r\n    assertTrue(info.getWorkingDirectories().contains(\"jre/lib/test/scrapdir\"));\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.InstrumentationHandler.lazyInitializeSourcesList",
	"Comment": "initializes sources and sourceslist by populating them from loadedroots.",
	"Method": "void lazyInitializeSourcesList(){\r\n    assert Thread.holdsLock(sources);\r\n    if (sourcesListRef.get() == null) {\r\n        Collection<Source> sourcesList = new WeakAsyncList(16);\r\n        sourcesListRef.set(sourcesList);\r\n        for (RootNode root : loadedRoots) {\r\n            int rootBits = RootNodeBits.get(root);\r\n            if (RootNodeBits.isNoSourceSection(rootBits)) {\r\n                continue;\r\n            } else {\r\n                SourceSection sourceSection = root.getSourceSection();\r\n                if (RootNodeBits.isSameSource(rootBits) && sourceSection != null) {\r\n                    Source source = sourceSection.getSource();\r\n                    if (!sources.containsKey(source)) {\r\n                        sources.put(source, null);\r\n                        sourcesList.add(source);\r\n                    }\r\n                } else {\r\n                    if (sourceSection != null) {\r\n                        findSourcesVisitor.adoptSource(sourceSection.getSource());\r\n                    }\r\n                    visitRoot(root, root, findSourcesVisitor, false);\r\n                    for (Source source : findSourcesVisitor.rootSources) {\r\n                        if (!sources.containsKey(source)) {\r\n                            sources.put(source, null);\r\n                            sourcesList.add(source);\r\n                        }\r\n                    }\r\n                    findSourcesVisitor.rootSources.clear();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.grpc.testing.integration.Http2Client.main",
	"Comment": "the main application allowing this client to be launched from the command line.",
	"Method": "void main(String[] args){\r\n    final Http2Client client = new Http2Client();\r\n    client.parseArgs(args);\r\n    client.setUp();\r\n    Runtime.getRuntime().addShutdownHook(new Thread() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                client.shutdown();\r\n            } catch (Exception e) {\r\n                logger.log(Level.SEVERE, e.getMessage(), e);\r\n            }\r\n        }\r\n    });\r\n    try {\r\n        client.run();\r\n    } finally {\r\n        client.shutdown();\r\n    }\r\n}"
}, {
	"Path": "io.grpc.testing.integration.Http2Client.main",
	"Comment": "the main application allowing this client to be launched from the command line.",
	"Method": "void main(String[] args){\r\n    try {\r\n        client.shutdown();\r\n    } catch (Exception e) {\r\n        logger.log(Level.SEVERE, e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "io.grpc.stub.MetadataUtils.newAttachHeadersInterceptor",
	"Comment": "returns a client interceptor that attaches a set of headers to requests.",
	"Method": "ClientInterceptor newAttachHeadersInterceptor(Metadata extraHeaders){\r\n    return new HeaderAttachingClientInterceptor(extraHeaders);\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.parser.text.LLScanner.continueAfter",
	"Comment": "parse a line and indicate if the scanner should continue after it",
	"Method": "boolean continueAfter(String line){\r\n    currentLine++;\r\n    if (line.isEmpty() || line.charAt(0) == ';') {\r\n        return true;\r\n    }\r\n    if (line.startsWith(\"define\")) {\r\n        beginFunction(line);\r\n    } else if (line.startsWith(\"}\")) {\r\n        endFunction();\r\n    } else if (function != null) {\r\n        parseInstruction(line);\r\n    } else if (line.startsWith(\"@\")) {\r\n        parseGlobal(line);\r\n    } else if (line.startsWith(\"!0\")) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.graalvm.component.installer.ComponentInstallerTest.testOptionClashBetweenCommandAndGlobal",
	"Comment": "checks that no command defines an option that clash with the global one.",
	"Method": "void testOptionClashBetweenCommandAndGlobal(){\r\n    ComponentInstaller.initCommands();\r\n    for (String cmd : ComponentInstaller.commands.keySet()) {\r\n        startCommand(cmd);\r\n        InstallerCommand c = ComponentInstaller.commands.get(cmd);\r\n        Map<String, String> opts = c.supportedOptions();\r\n        for (String k : opts.keySet()) {\r\n            String v = opts.get(k);\r\n            if (\"X\".equals(v)) {\r\n                continue;\r\n            }\r\n            if (ComponentInstaller.globalOptions.containsKey(k)) {\r\n                reportOption(k);\r\n            }\r\n        }\r\n    }\r\n    if (message.length() > 0) {\r\n        Assert.fail(\"Command options clashes with the global: \" + message.toString());\r\n    }\r\n}"
}, {
	"Path": "io.grpc.internal.KeepAliveManager.onTransportActive",
	"Comment": "transport has active streams. start sending keepalives if necessary.",
	"Method": "void onTransportActive(){\r\n    if (state == State.IDLE) {\r\n        state = State.PING_SCHEDULED;\r\n        if (pingFuture == null) {\r\n            pingFuture = scheduler.schedule(sendPing, nextKeepaliveTime - ticker.read(), TimeUnit.NANOSECONDS);\r\n        }\r\n    } else if (state == State.IDLE_AND_PING_SENT) {\r\n        state = State.PING_SENT;\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.meta.HostedMemoryAccessProvider.doRead",
	"Comment": "try to look up the original field from the given displacement, and read the field value.",
	"Method": "JavaConstant doRead(JavaKind stackKind,JavaConstant base,long displacement){\r\n    if (base.getJavaKind() != JavaKind.Object) {\r\n        return null;\r\n    }\r\n    HostedType type = (HostedType) metaAccess.lookupJavaType(base);\r\n    HostedField field = (HostedField) type.findInstanceFieldWithOffset(displacement, null);\r\n    if (field == null) {\r\n        return null;\r\n    }\r\n    assert field.getStorageKind().getStackKind() == stackKind;\r\n    JavaConstant result = field.readValue(base);\r\n    assert result.getJavaKind().getStackKind() == stackKind;\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.component.installer.model.ComponentRegistryTest.testFindComponent",
	"Comment": "test of findcomponent method, of class componentregistry.",
	"Method": "void testFindComponent(){\r\n    assertSame(fakeInfo, registry.findComponent(\"org.graalvm.fake\"));\r\n    assertNull(registry.findComponent(\"org.graalvm.ruby\"));\r\n    registry.addComponent(rubyInfo);\r\n    assertNotNull(registry.findComponent(\"org.graalvm.ruby\"));\r\n    registry.removeComponent(rubyInfo);\r\n    assertNull(registry.findComponent(\"org.graalvm.ruby\"));\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.UnaryCallQpsBenchmark.teardown",
	"Comment": "stop the running calls then stop the server and client channels.",
	"Method": "void teardown(){\r\n    completed.set(true);\r\n    Thread.sleep(5000);\r\n    super.teardown();\r\n}"
}, {
	"Path": "io.grpc.okhttp.OutboundFlowController.windowUpdate",
	"Comment": "update the outbound window for given stream, or for the connection if stream is null. returnsthe new value of the window size.must be called with holding transport lock.",
	"Method": "int windowUpdate(OkHttpClientStream stream,int delta){\r\n    final int updatedWindow;\r\n    if (stream == null) {\r\n        updatedWindow = connectionState.incrementStreamWindow(delta);\r\n        writeStreams();\r\n    } else {\r\n        OutboundFlowState state = state(stream);\r\n        updatedWindow = state.incrementStreamWindow(delta);\r\n        WriteStatus writeStatus = new WriteStatus();\r\n        state.writeBytes(state.writableWindow(), writeStatus);\r\n        if (writeStatus.hasWritten()) {\r\n            flush();\r\n        }\r\n    }\r\n    return updatedWindow;\r\n}"
}, {
	"Path": "com.oracle.svm.core.windows.WindowsUtils.lastErrorString",
	"Comment": "return the error string for the last error, or a default message.",
	"Method": "String lastErrorString(String defaultMsg){\r\n    int error = WinBase.GetLastError();\r\n    return defaultMsg + \" GetLastError: \" + error;\r\n}"
}, {
	"Path": "io.grpc.examples.errorhandling.DetailErrorSample.advancedAsyncCall",
	"Comment": "this is more advanced and does not make use of the stub.you should not normally need to dothis, but here is how you would.",
	"Method": "void advancedAsyncCall(){\r\n    ClientCall<HelloRequest, HelloReply> call = channel.newCall(GreeterGrpc.getSayHelloMethod(), CallOptions.DEFAULT);\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    call.start(new ClientCall.Listener<HelloReply>() {\r\n        @Override\r\n        public void onClose(Status status, Metadata trailers) {\r\n            Verify.verify(status.getCode() == Status.Code.INTERNAL);\r\n            Verify.verify(trailers.containsKey(DEBUG_INFO_TRAILER_KEY));\r\n            try {\r\n                Verify.verify(trailers.get(DEBUG_INFO_TRAILER_KEY).equals(DEBUG_INFO));\r\n            } catch (IllegalArgumentException e) {\r\n                throw new VerifyException(e);\r\n            }\r\n            latch.countDown();\r\n        }\r\n    }, new Metadata());\r\n    call.sendMessage(HelloRequest.newBuilder().build());\r\n    call.halfClose();\r\n    if (!Uninterruptibles.awaitUninterruptibly(latch, 1, TimeUnit.SECONDS)) {\r\n        throw new RuntimeException(\"timeout!\");\r\n    }\r\n}"
}, {
	"Path": "io.grpc.examples.errorhandling.DetailErrorSample.advancedAsyncCall",
	"Comment": "this is more advanced and does not make use of the stub.you should not normally need to dothis, but here is how you would.",
	"Method": "void advancedAsyncCall(){\r\n    Verify.verify(status.getCode() == Status.Code.INTERNAL);\r\n    Verify.verify(trailers.containsKey(DEBUG_INFO_TRAILER_KEY));\r\n    try {\r\n        Verify.verify(trailers.get(DEBUG_INFO_TRAILER_KEY).equals(DEBUG_INFO));\r\n    } catch (IllegalArgumentException e) {\r\n        throw new VerifyException(e);\r\n    }\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.grpc.alts.internal.RpcProtocolVersionsUtil.checkRpcProtocolVersions",
	"Comment": "performs check between local and peer rpc protocol versions. this function returns true and thehighest common version if there exists a common rpc protocol version to use, and returns falseand null otherwise.",
	"Method": "RpcVersionsCheckResult checkRpcProtocolVersions(RpcProtocolVersions localVersions,RpcProtocolVersions peerVersions){\r\n    Version maxCommonVersion;\r\n    Version minCommonVersion;\r\n    if (isGreaterThanOrEqualTo(localVersions.getMaxRpcVersion(), peerVersions.getMaxRpcVersion())) {\r\n        maxCommonVersion = peerVersions.getMaxRpcVersion();\r\n    } else {\r\n        maxCommonVersion = localVersions.getMaxRpcVersion();\r\n    }\r\n    if (isGreaterThanOrEqualTo(localVersions.getMinRpcVersion(), peerVersions.getMinRpcVersion())) {\r\n        minCommonVersion = localVersions.getMinRpcVersion();\r\n    } else {\r\n        minCommonVersion = peerVersions.getMinRpcVersion();\r\n    }\r\n    if (isGreaterThanOrEqualTo(maxCommonVersion, minCommonVersion)) {\r\n        return new RpcVersionsCheckResult.Builder().setResult(true).setHighestCommonVersion(maxCommonVersion).build();\r\n    }\r\n    return new RpcVersionsCheckResult.Builder().setResult(false).build();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebugValue.isArray",
	"Comment": "returns true if this value represents an array, false otherwise.",
	"Method": "boolean isArray(){\r\n    if (!isReadable()) {\r\n        return false;\r\n    }\r\n    Object value = get();\r\n    if (value instanceof TruffleObject) {\r\n        TruffleObject to = (TruffleObject) value;\r\n        return ObjectStructures.isArray(getDebugger().getMessageNodes(), to);\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.deopt.DeoptimizedFrame.getSourceTotalFrameSize",
	"Comment": "the frame size of the deoptimized method. this is the size of the physical stack frame thatis still present on the stack until the actual stack frame rewriting happens.",
	"Method": "long getSourceTotalFrameSize(){\r\n    return sourceTotalFrameSize;\r\n}"
}, {
	"Path": "com.oracle.svm.core.deopt.Deoptimizer.writeValueInMaterializedObj",
	"Comment": "writes an instance field or an array element into a materialized object.",
	"Method": "void writeValueInMaterializedObj(Object materializedObj,UnsignedWord offsetInObj,JavaConstant constant){\r\n    assert offsetInObj.notEqual(0) : \"materialized value would overwrite hub\";\r\n    switch(constant.getJavaKind()) {\r\n        case Boolean:\r\n            BarrieredAccess.writeByte(materializedObj, offsetInObj, constant.asBoolean() ? (byte) 1 : (byte) 0);\r\n            break;\r\n        case Byte:\r\n            BarrieredAccess.writeByte(materializedObj, offsetInObj, (byte) constant.asInt());\r\n            break;\r\n        case Char:\r\n            BarrieredAccess.writeChar(materializedObj, offsetInObj, (char) constant.asInt());\r\n            break;\r\n        case Short:\r\n            BarrieredAccess.writeShort(materializedObj, offsetInObj, (short) constant.asInt());\r\n            break;\r\n        case Int:\r\n            BarrieredAccess.writeInt(materializedObj, offsetInObj, constant.asInt());\r\n            break;\r\n        case Long:\r\n            BarrieredAccess.writeLong(materializedObj, offsetInObj, constant.asLong());\r\n            break;\r\n        case Float:\r\n            BarrieredAccess.writeFloat(materializedObj, offsetInObj, constant.asFloat());\r\n            break;\r\n        case Double:\r\n            BarrieredAccess.writeDouble(materializedObj, offsetInObj, constant.asDouble());\r\n            break;\r\n        case Object:\r\n            BarrieredAccess.writeObject(materializedObj, offsetInObj, SubstrateObjectConstant.asObject(constant));\r\n            break;\r\n        default:\r\n            throw VMError.shouldNotReachHere();\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.image.NativeImageHeap.isImmutable",
	"Comment": "determine if an object in the host heap will be immutable in the native image heap.",
	"Method": "boolean isImmutable(Object obj){\r\n    if (obj instanceof String) {\r\n        return obj.hashCode() != 0;\r\n    } else if (obj instanceof DynamicHub) {\r\n        return true;\r\n    } else if (knownImmutableObjects.contains(obj)) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.runtime.SLFunction.toString",
	"Comment": "this method is, e.g., called when using a function literal in a string concatenation. sochanging it has an effect on sl programs.",
	"Method": "String toString(){\r\n    return name;\r\n}"
}, {
	"Path": "io.grpc.reflection.testing.AnotherDynamicServiceGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "AnotherDynamicServiceStub newStub(io.grpc.Channel channel){\r\n    return new AnotherDynamicServiceStub(channel);\r\n}"
}, {
	"Path": "io.grpc.Server.getMutableServices",
	"Comment": "returns mutable services registered with the server, or an empty list if not supported by theimplementation.",
	"Method": "List<ServerServiceDefinition> getMutableServices(){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "com.google.gson.JsonElement.isJsonNull",
	"Comment": "provides check for verifying if this element represents a null value or not.",
	"Method": "boolean isJsonNull(){\r\n    return this instanceof JsonNull;\r\n}"
}, {
	"Path": "com.google.gson.FieldAttributes.isSynthetic",
	"Comment": "this is exposed internally only for the removing synthetic fields from the json output.",
	"Method": "boolean isSynthetic(){\r\n    return field.isSynthetic();\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.HeapChunkProvider.produceAlignedChunk",
	"Comment": "produce a new alignedheapchunk, either from the free list or from the operating system.",
	"Method": "AlignedHeader produceAlignedChunk(){\r\n    UnsignedWord chunkSize = HeapPolicy.getAlignedHeapChunkSize();\r\n    log().string(\"[HeapChunkProvider.produceAlignedChunk  chunk size: \").unsigned(chunkSize).newline();\r\n    AlignedHeader result = popUnusedAlignedChunk();\r\n    log().string(\"  unused chunk: \").hex(result).newline();\r\n    if (result.isNull()) {\r\n        noteFirstAllocationTime();\r\n        result = (AlignedHeader) CommittedMemoryProvider.get().allocate(chunkSize, HeapPolicy.getAlignedHeapChunkAlignment(), false);\r\n        if (result.isNull()) {\r\n            throw AllocatorOutOfMemoryError.throwError(\"No virtual memory for aligned chunk\");\r\n        }\r\n        log().string(\"  new chunk: \").hex(result).newline();\r\n        initializeChunk(result, chunkSize);\r\n        resetAlignedHeapChunk(result);\r\n    }\r\n    assert result.getTop().equal(AlignedHeapChunk.getAlignedHeapChunkStart(result));\r\n    assert result.getEnd().equal(HeapChunk.asPointer(result).add(chunkSize));\r\n    if (HeapPolicy.getZapProducedHeapChunks()) {\r\n        zap(result, HeapPolicy.getProducedHeapChunkZapWord());\r\n    }\r\n    HeapPolicy.bytesAllocatedSinceLastCollection.addAndGet(chunkSize);\r\n    log().string(\"  result chunk: \").hex(result).string(\"  ]\").newline();\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.TruffleException.getSourceLocation",
	"Comment": "returns a location where this exception occurred in the ast. this method may returnnull to indicate that the location is not available.",
	"Method": "SourceSection getSourceLocation(){\r\n    final Node node = getLocation();\r\n    return node == null ? null : node.getEncapsulatingSourceSection();\r\n}"
}, {
	"Path": "io.grpc.CallOptions.getMaxInboundMessageSize",
	"Comment": "gets the maximum allowed message size acceptable from the remote peer.",
	"Method": "Integer getMaxInboundMessageSize(){\r\n    return maxInboundMessageSize;\r\n}"
}, {
	"Path": "com.google.common.collect.Iterators.emptyListIterator",
	"Comment": "casting to any type is safe since there are no actual elements.",
	"Method": "UnmodifiableListIterator<T> emptyListIterator(){\r\n    return (UnmodifiableListIterator<T>) ArrayItr.EMPTY;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.profiles.IntValueProfile.createIdentityProfile",
	"Comment": "returns a value profile that profiles the exact value of an int.",
	"Method": "IntValueProfile createIdentityProfile(){\r\n    if (Profile.isProfilingEnabled()) {\r\n        return Enabled.create();\r\n    } else {\r\n        return Disabled.INSTANCE;\r\n    }\r\n}"
}, {
	"Path": "io.grpc.netty.TlsTest.noClientAuthFailure",
	"Comment": "tests that a server configured to require client authentication actually does require clientauthentication.",
	"Method": "void noClientAuthFailure(){\r\n    File serverCertFile = TestUtils.loadCert(\"server1.pem\");\r\n    File serverPrivateKeyFile = TestUtils.loadCert(\"server1.key\");\r\n    X509Certificate[] serverTrustedCaCerts = { TestUtils.loadX509Cert(\"ca.pem\") };\r\n    server = serverBuilder(0, serverCertFile, serverPrivateKeyFile, serverTrustedCaCerts).addService(new SimpleServiceImpl()).build().start();\r\n    X509Certificate[] clientTrustedCaCerts = { TestUtils.loadX509Cert(\"ca.pem\") };\r\n    channel = clientChannel(server.getPort(), clientContextBuilder.trustManager(clientTrustedCaCerts).build());\r\n    SimpleServiceGrpc.SimpleServiceBlockingStub client = SimpleServiceGrpc.newBlockingStub(channel);\r\n    try {\r\n        client.unaryRpc(SimpleRequest.getDefaultInstance());\r\n        fail(\"TLS handshake should have failed, but didn't; received RPC response\");\r\n    } catch (StatusRuntimeException e) {\r\n        assertEquals(Throwables.getStackTraceAsString(e), Status.Code.UNAVAILABLE, e.getStatus().getCode());\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.test.polyglot.VirtualizedFileSystemTest.setCwd",
	"Comment": "sets the current working directory to a work folder. used by configurations running on localfile system which have work folder in temp directory.",
	"Method": "void setCwd(Context ctx,Path cwd,Path langHome){\r\n    languageAction = (env) -> {\r\n        env.setCurrentWorkingDirectory(env.getTruffleFile(cwd.toString()));\r\n    };\r\n    if (langHome != null) {\r\n        System.setProperty(LANGAUGE_ID + \".home\", langHome.toString());\r\n        resetLanguageHomes();\r\n    }\r\n    ctx.eval(LANGAUGE_ID, \"\");\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.HeapImpl.exitIfAllocationDisallowed",
	"Comment": "a guard to place before an allocation, giving the call site and the allocation type.",
	"Method": "void exitIfAllocationDisallowed(String callSite,String typeName){\r\n    if (HeapImpl.getHeapImpl().isAllocationDisallowed()) {\r\n        NoAllocationVerifier.exit(callSite, typeName);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.log.RealLog.getOutputFile",
	"Comment": "allow subclasses to customize the file descriptor that we write to.",
	"Method": "FileDescriptor getOutputFile(){\r\n    return FileDescriptor.err;\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.meta.HostedMethod.isEntryPoint",
	"Comment": "returns true if this method is a native entry point, i.e., called from c code. the methodmust not be called from java code then.",
	"Method": "boolean isEntryPoint(){\r\n    return wrapped.isEntryPoint();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.SuspendedEvent.isLanguageContextInitialized",
	"Comment": "test if the language context of the source of the event is initialized.",
	"Method": "boolean isLanguageContextInitialized(){\r\n    verifyValidState(true);\r\n    return context.isLanguageContextInitialized();\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.NativeImageClassLoader.generateClass",
	"Comment": "generate an interface with the given name that extends ghost.",
	"Method": "byte[] generateClass(String internalName){\r\n    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\r\n    // Java 1.8\r\n    cw.visit(V1_8, ACC_PUBLIC + ACC_INTERFACE + ACC_ABSTRACT, internalName, null, \"java/lang/Object\", new String[] { Type.getInternalName(Ghost.class) });\r\n    return cw.toByteArray();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.profiles.ByteValueProfile.createIdentityProfile",
	"Comment": "returns a value profile that profiles the exact value of a byte.",
	"Method": "ByteValueProfile createIdentityProfile(){\r\n    if (Profile.isProfilingEnabled()) {\r\n        return Enabled.create();\r\n    } else {\r\n        return Disabled.INSTANCE;\r\n    }\r\n}"
}, {
	"Path": "io.grpc.ServerStreamTracer.filterContext",
	"Comment": "called before the interceptors and the call handlers and make changes to the context objectif needed.",
	"Method": "Context filterContext(Context context){\r\n    return context;\r\n}"
}, {
	"Path": "io.grpc.cronet.CronetChannelBuilder.alwaysUsePut",
	"Comment": "sets the cronet channel to always use put instead of post. defaults to false.",
	"Method": "CronetChannelBuilder alwaysUsePut(boolean enable){\r\n    this.alwaysUsePut = enable;\r\n    return this;\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.code.CompileQueue.parseAheadOfTimeCompiledMethods",
	"Comment": "regular compiled methods. only entry points and manually marked methods are compiled, alltransitively reachable methods are then identified by looking at the callees of alreadyparsed methods.",
	"Method": "void parseAheadOfTimeCompiledMethods(){\r\n    universe.getMethods().stream().filter(method -> method.isEntryPoint() || CompilationInfoSupport.singleton().isForcedCompilation(method)).forEach(method -> ensureParsed(method, new EntryPointReason()));\r\n    SubstrateForeignCallsProvider foreignCallsProvider = (SubstrateForeignCallsProvider) runtimeConfig.getProviders().getForeignCalls();\r\n    foreignCallsProvider.getForeignCalls().keySet().stream().map(descriptor -> (HostedMethod) descriptor.findMethod(runtimeConfig.getProviders().getMetaAccess())).filter(method -> method.wrapped.isRootMethod()).forEach(method -> ensureParsed(method, new EntryPointReason()));\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.NativeImageGenerator.run",
	"Comment": "executes the image build. only one image can be built with this generator.",
	"Method": "void run(Map<Method, CEntryPointData> entryPoints,Method mainEntryPoint,JavaMainSupport javaMainSupport,String imageName,AbstractBootImage.NativeImageKind k,SubstitutionProcessor harnessSubstitutions,ForkJoinPool compilationExecutor,ForkJoinPool analysisExecutor,EconomicSet<String> allOptionNames){\r\n    try {\r\n        if (!buildStarted.compareAndSet(false, true)) {\r\n            throw UserError.abort(\"An image build has already been performed with this generator.\");\r\n        }\r\n        setSystemPropertiesForImage(k);\r\n        int maxConcurrentThreads = NativeImageOptions.getMaximumNumberOfConcurrentThreads(new OptionValues(optionProvider.getHostedValues()));\r\n        this.imageBuildPool = createForkJoinPool(maxConcurrentThreads);\r\n        imageBuildPool.submit(() -> {\r\n            try {\r\n                ImageSingletons.add(HostedOptionValues.class, new HostedOptionValues(optionProvider.getHostedValues()));\r\n                ImageSingletons.add(RuntimeOptionValues.class, new RuntimeOptionValues(optionProvider.getRuntimeValues(), allOptionNames));\r\n                doRun(entryPoints, mainEntryPoint, javaMainSupport, imageName, k, harnessSubstitutions, compilationExecutor, analysisExecutor);\r\n            } finally {\r\n                try {\r\n                    if (deleteTempDirectory) {\r\n                        deleteAll(tempDirectory());\r\n                    }\r\n                    featureHandler.forEachFeature(Feature::cleanup);\r\n                } catch (Throwable e) {\r\n                }\r\n            }\r\n        }).get();\r\n    } catch (InterruptedException | CancellationException e) {\r\n        System.out.println(\"Interrupted!\");\r\n        throw new InterruptImageBuilding();\r\n    } catch (ExecutionException e) {\r\n        if (e.getCause() instanceof RuntimeException) {\r\n            throw (RuntimeException) e.getCause();\r\n        } else if (e.getCause() instanceof Error) {\r\n            throw (Error) e.getCause();\r\n        }\r\n    } finally {\r\n        shutdownPoolSafe();\r\n        clearSystemPropertiesForImage();\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebugScope.getSourceSection",
	"Comment": "get a source section representing this scope. please note that while this scope does notprovide variables that are valid only after the suspension point, the source section canactually span after the suspension point.",
	"Method": "SourceSection getSourceSection(){\r\n    try {\r\n        Node node = scope.getNode();\r\n        if (node != null) {\r\n            return session.resolveSection(node.getEncapsulatingSourceSection());\r\n        } else {\r\n            return null;\r\n        }\r\n    } catch (ThreadDeath td) {\r\n        throw td;\r\n    } catch (Throwable ex) {\r\n        throw new DebugException(session, ex, language, null, true, null);\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.component.installer.ComponentInstallerTest.testMainHelpConsistent",
	"Comment": "checks that the main help reports all commands and all their options.",
	"Method": "void testMainHelpConsistent(){\r\n    ComponentInstaller.initCommands();\r\n    startCommand(\"Global\");\r\n    String help = ResourceBundle.getBundle(\"org.graalvm.component.installer.Bundle\").getString(\"INFO_Usage\");\r\n    String[] lines = help.split(\"\\n\");\r\n    Map<String, InstallerCommand> allCmds = new HashMap(ComponentInstaller.commands);\r\n    for (String l : lines) {\r\n        if (!l.startsWith(\"\\tgu \")) {\r\n            continue;\r\n        }\r\n        int oS = l.indexOf('[');\r\n        int oE = l.indexOf(']');\r\n        int sp = l.indexOf(' ', 4);\r\n        String cn = l.substring(4, sp);\r\n        InstallerCommand c = allCmds.remove(cn);\r\n        if (c == null) {\r\n            Assert.fail(\"Unknown command: \" + cn);\r\n        }\r\n        startCommand(cn);\r\n        if (oS == -1 || oE == -1) {\r\n            continue;\r\n        }\r\n        Map<String, String> cmdOptions = new HashMap(c.supportedOptions());\r\n        String optString = l.substring(oS + 1, oE);\r\n        if (optString.startsWith(\"-\")) {\r\n            optString = optString.substring(1);\r\n        }\r\n        for (int a = 0; a < optString.length(); a++) {\r\n            char o = optString.charAt(a);\r\n            String s = String.valueOf(o);\r\n            if (cmdOptions.remove(s) == null) {\r\n                if (!ComponentInstaller.globalOptions.containsKey(s)) {\r\n                    reportOption(s);\r\n                }\r\n            }\r\n        }\r\n        if (message.length() > 0) {\r\n            Assert.fail(\"Options do not exist: \" + message.toString());\r\n        }\r\n        for (String s : new ArrayList(cmdOptions.keySet())) {\r\n            if (s.length() > 1 || \"X\".equals(cmdOptions.get(s))) {\r\n                cmdOptions.remove(s);\r\n            }\r\n        }\r\n        for (String s : cmdOptions.keySet()) {\r\n            reportOption(s);\r\n        }\r\n        if (message.length() > 0) {\r\n            Assert.fail(\"Options not documented: \" + message.toString());\r\n        }\r\n    }\r\n    if (!allCmds.isEmpty()) {\r\n        Assert.fail(\"Not all commands documented: \" + allCmds);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.runtime.pointer.LLVMManagedPointer.create",
	"Comment": "create a new managed pointer, pointing to a particular offset of a managed object.",
	"Method": "LLVMManagedPointer create(TruffleObject object,LLVMManagedPointer create,TruffleObject object,long offset){\r\n    return new LLVMPointerImpl(object, offset, null);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.ThreadLocalAllocation.releaseMemory",
	"Comment": "releases all the memory allocated in this tlab, without any safety checks that the memory isno longer referenced from other objects.",
	"Method": "void releaseMemory(Descriptor tlab){\r\n    log().string(\"[ThreadLocalAllocator.releaseMemory: tlab \").hex(tlab).newline();\r\n    retireAllocationChunk(tlab);\r\n    AlignedHeader alignedChunk = tlab.getAlignedChunk();\r\n    UnalignedHeader unalignedChunk = tlab.getUnalignedChunk();\r\n    tlab.setAlignedChunk(WordFactory.nullPointer());\r\n    tlab.setUnalignedChunk(WordFactory.nullPointer());\r\n    while (alignedChunk.isNonNull()) {\r\n        AlignedHeader next = alignedChunk.getNext();\r\n        HeapChunkProvider.resetAlignedHeader(alignedChunk);\r\n        log().string(\"  aligned chunk \").hex(alignedChunk).newline();\r\n        pushToThreadLocalFreeList(alignedChunk);\r\n        alignedChunk = next;\r\n    }\r\n    while (unalignedChunk.isNonNull()) {\r\n        UnalignedHeader next = unalignedChunk.getNext();\r\n        unalignedChunk.setNext(WordFactory.nullPointer());\r\n        log().string(\"  unaligned chunk \").hex(alignedChunk).newline();\r\n        HeapChunkProvider.get().consumeUnalignedChunk(unalignedChunk);\r\n        unalignedChunk = next;\r\n    }\r\n    log().string(\"  ]\").newline();\r\n}"
}, {
	"Path": "io.grpc.internal.InternalSubchannel.getTransport",
	"Comment": "returns a ready transport if there is any, without trying to connect.",
	"Method": "ClientTransport getTransport(){\r\n    return activeTransport;\r\n}"
}, {
	"Path": "com.oracle.truffle.tools.profiler.CPUSampler.setPeriod",
	"Comment": "sets the sampling period i.e. the time between two samples of the shadow stack are taken.",
	"Method": "void setPeriod(long samplePeriod){\r\n    enterChangeConfig();\r\n    if (samplePeriod < 1) {\r\n        throw new IllegalArgumentException(String.format(\"Invalid sample period %s.\", samplePeriod));\r\n    }\r\n    this.period = samplePeriod;\r\n}"
}, {
	"Path": "com.oracle.svm.core.heap.AllocationFreeList.prepend",
	"Comment": "prepend an element to the list. many calls can race to prepend an element.",
	"Method": "void prepend(T element){\r\n    final Element<T> asElement = element;\r\n    if (asElement.getHasBeenOnList()) {\r\n        throw PreviouslyRegisteredElementException.getPreallocatedInstance();\r\n    }\r\n    asElement.hasBeenOnList = true;\r\n    asElement.enabled = true;\r\n    Element<T> headSample;\r\n    do {\r\n        headSample = sampleHead();\r\n        asElement.next = headSample;\r\n    } while (!head.compareAndSet(headSample, asElement));\r\n}"
}, {
	"Path": "com.oracle.truffle.api.TruffleFile.isWritable",
	"Comment": "tests if a file is writable. checks if the file exists and this java virtual machine hasenough privileges to write to the file.",
	"Method": "boolean isWritable(){\r\n    try {\r\n        return checkAccess(AccessMode.WRITE);\r\n    } catch (SecurityException se) {\r\n        throw se;\r\n    } catch (Throwable t) {\r\n        throw wrapHostException(t);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.typestate.PointsToStats.doWrite",
	"Comment": "wrapper for bufferedwriter.out to deal with checked exception. useful for avoiding catchingexceptions in lamdas.",
	"Method": "void doWrite(BufferedWriter out,String str){\r\n    try {\r\n        out.write(str);\r\n    } catch (IOException ex) {\r\n        throw JVMCIError.shouldNotReachHere(ex);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.util.TimeUtils.divideNanosToMillis",
	"Comment": "return the number of milliseconds in the given number of nanoseconds.",
	"Method": "long divideNanosToMillis(long nanos){\r\n    return (nanos / nanosPerMilli);\r\n}"
}, {
	"Path": "io.grpc.netty.TlsTest.serverRejectsUntrustedClientCert",
	"Comment": "tests that a server configured to require client authentication refuses to accept connectionsfrom a client that has an untrusted certificate.",
	"Method": "void serverRejectsUntrustedClientCert(){\r\n    File serverCertFile = TestUtils.loadCert(\"server1.pem\");\r\n    File serverPrivateKeyFile = TestUtils.loadCert(\"server1.key\");\r\n    X509Certificate[] serverTrustedCaCerts = { TestUtils.loadX509Cert(\"ca.pem\") };\r\n    server = serverBuilder(0, serverCertFile, serverPrivateKeyFile, serverTrustedCaCerts).addService(new SimpleServiceImpl()).build().start();\r\n    File clientCertChainFile = TestUtils.loadCert(\"badclient.pem\");\r\n    File clientPrivateKeyFile = TestUtils.loadCert(\"badclient.key\");\r\n    X509Certificate[] clientTrustedCaCerts = { TestUtils.loadX509Cert(\"ca.pem\") };\r\n    channel = clientChannel(server.getPort(), clientContextBuilder.keyManager(clientCertChainFile, clientPrivateKeyFile).trustManager(clientTrustedCaCerts).build());\r\n    SimpleServiceGrpc.SimpleServiceBlockingStub client = SimpleServiceGrpc.newBlockingStub(channel);\r\n    try {\r\n        client.unaryRpc(SimpleRequest.getDefaultInstance());\r\n        fail(\"TLS handshake should have failed, but didn't; received RPC response\");\r\n    } catch (StatusRuntimeException e) {\r\n        assertEquals(Throwables.getStackTraceAsString(e), Status.Code.UNAVAILABLE, e.getStatus().getCode());\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.CompilerDirectives.transferToInterpreterAndInvalidate",
	"Comment": "directive for the compiler to discontinue compilation at this code position and insteadinsert a transfer to the interpreter, invalidating the currently executing machine code.",
	"Method": "void transferToInterpreterAndInvalidate(){\r\n    if (inInterpreter()) {\r\n        Truffle.getRuntime().notifyTransferToInterpreter();\r\n    }\r\n}"
}, {
	"Path": "io.grpc.testing.TestUtils.recordRequestHeadersInterceptor",
	"Comment": "capture the request headers from a client. useful for testing metadata propagation.",
	"Method": "ServerInterceptor recordRequestHeadersInterceptor(AtomicReference<Metadata> headersCapture){\r\n    return new ServerInterceptor() {\r\n        @Override\r\n        public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call, Metadata requestHeaders, ServerCallHandler<ReqT, RespT> next) {\r\n            headersCapture.set(requestHeaders);\r\n            return next.startCall(call, requestHeaders);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.grpc.testing.TestUtils.recordRequestHeadersInterceptor",
	"Comment": "capture the request headers from a client. useful for testing metadata propagation.",
	"Method": "ServerInterceptor recordRequestHeadersInterceptor(AtomicReference<Metadata> headersCapture){\r\n    headersCapture.set(requestHeaders);\r\n    return next.startCall(call, requestHeaders);\r\n}"
}, {
	"Path": "com.oracle.svm.core.jdk8.zipfile.ZipFile.getEntry",
	"Comment": "returns the zip file entry for the specified name, or nullif not found.",
	"Method": "ZipEntry getEntry(String name){\r\n    return getEntry0(name, java.util.zip.ZipEntry::new);\r\n}"
}, {
	"Path": "com.oracle.svm.core.thread.Safepoint.transitionNativeToJava",
	"Comment": "transition from native to java.can only be called from snippets. the fast path is inlined, the slow path is a method call.",
	"Method": "void transitionNativeToJava(){\r\n    boolean needSlowPath = ThreadingSupportImpl.singleton().needsNativeToJavaSlowpath() || !VMThreads.StatusSupport.compareAndSetNativeToJava();\r\n    if (BranchProbabilityNode.probability(BranchProbabilityNode.VERY_SLOW_PATH_PROBABILITY, needSlowPath)) {\r\n        callSlowPathNativeToJava(Safepoint.ENTER_SLOW_PATH_NATIVE_TO_JAVA);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.Breakpoint.newBuilder",
	"Comment": "creates a new breakpoint builder based on the textual region of a guest language sourceelement.",
	"Method": "Builder newBuilder(URI sourceUri,Builder newBuilder,Source source,Builder newBuilder,SourceSection sourceSection){\r\n    return BUILDER_INSTANCE.new Builder(sourceSection);\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.StreamingPingPongsPerSecondBenchmark.main",
	"Comment": "useful for triggering a subset of the benchmark in a profiler.",
	"Method": "void main(String[] argv){\r\n    StreamingPingPongsPerSecondBenchmark bench = new StreamingPingPongsPerSecondBenchmark();\r\n    bench.setup();\r\n    Thread.sleep(30000);\r\n    bench.teardown();\r\n    System.exit(0);\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.runtime.memory.LLVMNativeMemory.isHandleMemory",
	"Comment": "a fast check if the provided address is within the handle space.",
	"Method": "boolean isHandleMemory(long addr){\r\n    return addr < HANDLE_SPACE_END;\r\n}"
}, {
	"Path": "io.grpc.netty.WriteQueue.flush",
	"Comment": "process the queue of commands and dispatch them to the stream. this method is onlycalled in the event loop",
	"Method": "void flush(){\r\n    try {\r\n        QueuedCommand cmd;\r\n        int i = 0;\r\n        boolean flushedOnce = false;\r\n        while ((cmd = queue.poll()) != null) {\r\n            cmd.run(channel);\r\n            if (++i == DEQUE_CHUNK_SIZE) {\r\n                i = 0;\r\n                channel.flush();\r\n                flushedOnce = true;\r\n            }\r\n        }\r\n        if (i != 0 || !flushedOnce) {\r\n            channel.flush();\r\n        }\r\n    } finally {\r\n        scheduled.set(false);\r\n        if (!queue.isEmpty()) {\r\n            scheduleFlush();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.meta.AnalysisType.updateTypeFlows",
	"Comment": "called when the list of assignable types of a type is first initialized.",
	"Method": "void updateTypeFlows(BigBang bb,TypeFlow<?> assignable,TypeFlow<?> assignableNonNull){\r\n    if (isPrimitive() || isJavaLangObject()) {\r\n        return;\r\n    }\r\n    AnalysisType superType;\r\n    if (isInterface()) {\r\n        superType = bb.getObjectType();\r\n    } else {\r\n        superType = getSuperclass();\r\n        while (superType.assignableTypes == null) {\r\n            superType = superType.getSuperclass();\r\n        }\r\n    }\r\n    TypeState superAssignableTypeState = superType.assignableTypes.getState();\r\n    BitSet assignableTypesSet = new BitSet();\r\n    for (AnalysisType type : superAssignableTypeState.types()) {\r\n        if (this.isAssignableFrom(type)) {\r\n            assignableTypesSet.set(type.getId());\r\n        }\r\n    }\r\n    TypeState assignableTypeState = TypeState.forExactTypes(bb, assignableTypesSet, true);\r\n    updateFlow(bb, assignable, assignableTypeState);\r\n    updateFlow(bb, assignableNonNull, assignableTypeState.forNonNull(bb));\r\n}"
}, {
	"Path": "com.google.gson.JsonArray.getAsInt",
	"Comment": "convenience method to get this array as an integer if it contains a single element.",
	"Method": "int getAsInt(){\r\n    if (elements.size() == 1) {\r\n        return elements.get(0).getAsInt();\r\n    }\r\n    throw new IllegalStateException();\r\n}"
}, {
	"Path": "com.oracle.truffle.polyglot.OptionValuesImpl.fuzzyMatch",
	"Comment": "returns the set of options that fuzzy match a given option name.",
	"Method": "List<OptionDescriptor> fuzzyMatch(OptionDescriptors descriptors,String optionKey){\r\n    List<OptionDescriptor> matches = new ArrayList();\r\n    for (org.graalvm.options.OptionDescriptor option : descriptors) {\r\n        float score = stringSimiliarity(option.getName(), optionKey);\r\n        if (score >= FUZZY_MATCH_THRESHOLD) {\r\n            matches.add(option);\r\n        }\r\n    }\r\n    return matches;\r\n}"
}, {
	"Path": "io.grpc.internal.InternalSubchannel.getAuthority",
	"Comment": "returns the authority string associated with this subchannel.",
	"Method": "String getAuthority(){\r\n    return authority;\r\n}"
}, {
	"Path": "com.oracle.svm.core.c.CGlobalDataFactory.createBytes",
	"Comment": "create a chunk of bytes that is dimensioned and initialized to contain the bytes provided bythe specified supplier.",
	"Method": "CGlobalData<T> createBytes(IntSupplier sizeSupplier,CGlobalData<T> createBytes,IntSupplier sizeSupplier,String symbolName,CGlobalData<T> createBytes,Supplier<byte[]> contentSupplier,CGlobalData<T> createBytes,Supplier<byte[]> contentSupplier,String symbolName){\r\n    return new CGlobalDataImpl(symbolName, contentSupplier);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.AlignedHeapChunk.getRememberedSetConstructor",
	"Comment": "retrieve the remembered set constructor that is stored in the heap object.",
	"Method": "GCImpl.RememberedSetConstructor getRememberedSetConstructor(){\r\n    return HeapImpl.getHeapImpl().getGCImpl().getRememberedSetConstructor();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.benchmark.NodeAdoptionBenchmark.createBlock",
	"Comment": "this method aims to produce asts that mimic guest language application asts.",
	"Method": "Expression createBlock(int depth,int blockSize){\r\n    Expression[] expressions = new Expression[blockSize];\r\n    for (int i = 0; i < expressions.length; i++) {\r\n        int statement = depth <= 0 ? i % 3 : i % 4;\r\n        Expression e;\r\n        switch(statement) {\r\n            case 0:\r\n                e = new Binary(new Unary(new Expression()), new Expression());\r\n                break;\r\n            case 1:\r\n                e = new Unary(new Expression());\r\n                break;\r\n            case 2:\r\n                e = new Binary(new Binary(new Unary(new Binary(new Expression(), new Expression())), new Expression()), new Expression());\r\n                break;\r\n            case 3:\r\n                e = createBlock(depth - 1, blockSize);\r\n                break;\r\n            default:\r\n                throw new AssertionError();\r\n        }\r\n        expressions[i] = e;\r\n    }\r\n    return new Block(expressions);\r\n}"
}, {
	"Path": "io.grpc.internal.OobChannel.setSubchannel",
	"Comment": "must be called only once, right after the oobchannel is created.",
	"Method": "void setSubchannel(InternalSubchannel subchannel){\r\n    log.log(Level.FINE, \"[{0}] Created with [{1}]\", new Object[] { this, subchannel });\r\n    this.subchannel = subchannel;\r\n    subchannelImpl = new AbstractSubchannel() {\r\n        @Override\r\n        public void shutdown() {\r\n            subchannel.shutdown(Status.UNAVAILABLE.withDescription(\"OobChannel is shutdown\"));\r\n        }\r\n        @Override\r\n        ClientTransport obtainActiveTransport() {\r\n            return subchannel.obtainActiveTransport();\r\n        }\r\n        @Override\r\n        InternalInstrumented<ChannelStats> getInternalSubchannel() {\r\n            return subchannel;\r\n        }\r\n        @Override\r\n        public void requestConnection() {\r\n            subchannel.obtainActiveTransport();\r\n        }\r\n        @Override\r\n        public List<EquivalentAddressGroup> getAllAddresses() {\r\n            return subchannel.getAddressGroups();\r\n        }\r\n        @Override\r\n        public Attributes getAttributes() {\r\n            return Attributes.EMPTY;\r\n        }\r\n    };\r\n    subchannelPicker = new SubchannelPicker() {\r\n        final PickResult result = PickResult.withSubchannel(subchannelImpl);\r\n        @Override\r\n        public PickResult pickSubchannel(PickSubchannelArgs args) {\r\n            return result;\r\n        }\r\n    };\r\n    delayedTransport.reprocess(subchannelPicker);\r\n}"
}, {
	"Path": "io.grpc.internal.OobChannel.setSubchannel",
	"Comment": "must be called only once, right after the oobchannel is created.",
	"Method": "void setSubchannel(InternalSubchannel subchannel){\r\n    subchannel.shutdown(Status.UNAVAILABLE.withDescription(\"OobChannel is shutdown\"));\r\n}"
}, {
	"Path": "io.grpc.internal.OobChannel.setSubchannel",
	"Comment": "must be called only once, right after the oobchannel is created.",
	"Method": "void setSubchannel(InternalSubchannel subchannel){\r\n    return subchannel.obtainActiveTransport();\r\n}"
}, {
	"Path": "io.grpc.internal.OobChannel.setSubchannel",
	"Comment": "must be called only once, right after the oobchannel is created.",
	"Method": "void setSubchannel(InternalSubchannel subchannel){\r\n    return subchannel;\r\n}"
}, {
	"Path": "io.grpc.internal.OobChannel.setSubchannel",
	"Comment": "must be called only once, right after the oobchannel is created.",
	"Method": "void setSubchannel(InternalSubchannel subchannel){\r\n    subchannel.obtainActiveTransport();\r\n}"
}, {
	"Path": "io.grpc.internal.OobChannel.setSubchannel",
	"Comment": "must be called only once, right after the oobchannel is created.",
	"Method": "void setSubchannel(InternalSubchannel subchannel){\r\n    return subchannel.getAddressGroups();\r\n}"
}, {
	"Path": "io.grpc.internal.OobChannel.setSubchannel",
	"Comment": "must be called only once, right after the oobchannel is created.",
	"Method": "void setSubchannel(InternalSubchannel subchannel){\r\n    return Attributes.EMPTY;\r\n}"
}, {
	"Path": "io.grpc.internal.OobChannel.setSubchannel",
	"Comment": "must be called only once, right after the oobchannel is created.",
	"Method": "void setSubchannel(InternalSubchannel subchannel){\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.context.object.AnalysisObject.noteMerge",
	"Comment": "note that this object has been merged. if it is context sensitive then its contextsensitivity is invalidated. if it is context insensitive then it means that it has beenmerged with some context sensitive objects, i.e., it now represents those objects too andtheir corresponding data, like field and array elements flows.",
	"Method": "void noteMerge(BigBang bb){\r\n    this.merged = true;\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.nodes.access.SLReadPropertyCacheNode.readCached",
	"Comment": "polymorphic inline cache for a limited number of distinct property names and shapes.",
	"Method": "Object readCached(DynamicObject receiver,Object name,Object cachedName,Shape shape,Location location){\r\n    return location.get(receiver, shape);\r\n}"
}, {
	"Path": "io.grpc.internal.MessageFramer.writeKnownLengthUncompressed",
	"Comment": "write an unserialized message with a known length, uncompressed.",
	"Method": "int writeKnownLengthUncompressed(InputStream message,int messageLength){\r\n    if (maxOutboundMessageSize >= 0 && messageLength > maxOutboundMessageSize) {\r\n        throw Status.RESOURCE_EXHAUSTED.withDescription(String.format(\"message too large %d > %d\", messageLength, maxOutboundMessageSize)).asRuntimeException();\r\n    }\r\n    ByteBuffer header = ByteBuffer.wrap(headerScratch);\r\n    header.put(UNCOMPRESSED);\r\n    header.putInt(messageLength);\r\n    if (buffer == null) {\r\n        buffer = bufferAllocator.allocate(header.position() + messageLength);\r\n    }\r\n    writeRaw(headerScratch, 0, header.position());\r\n    return writeToOutputStream(message, outputStreamAdapter);\r\n}"
}, {
	"Path": "com.google.common.collect.RegularImmutableMap.createHashTable",
	"Comment": "returns a hash table for the specified keys and values, and ensures that neither keys norvalues are null.",
	"Method": "int[] createHashTable(Object[] alternatingKeysAndValues,int n,int tableSize,int keyOffset){\r\n    if (n == 1) {\r\n        checkEntryNotNull(alternatingKeysAndValues[keyOffset], alternatingKeysAndValues[keyOffset ^ 1]);\r\n        return null;\r\n    }\r\n    int mask = tableSize - 1;\r\n    int[] hashTable = new int[tableSize];\r\n    Arrays.fill(hashTable, ABSENT);\r\n    for (int i = 0; i < n; i++) {\r\n        Object key = alternatingKeysAndValues[2 * i + keyOffset];\r\n        Object value = alternatingKeysAndValues[2 * i + (keyOffset ^ 1)];\r\n        checkEntryNotNull(key, value);\r\n        for (int h = Hashing.smear(key.hashCode()); ; h++) {\r\n            h &= mask;\r\n            int previous = hashTable[h];\r\n            if (previous == ABSENT) {\r\n                hashTable[h] = 2 * i + keyOffset;\r\n                break;\r\n            } else if (alternatingKeysAndValues[previous].equals(key)) {\r\n                throw new IllegalArgumentException(\"Multiple entries with same key: \" + key + \"=\" + value + \" and \" + alternatingKeysAndValues[previous] + \"=\" + alternatingKeysAndValues[previous ^ 1]);\r\n            }\r\n        }\r\n    }\r\n    return hashTable;\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.image.NativeImageHeap.addObject",
	"Comment": "if necessary, add an object to the model of the native image heap.various transformations are done from objects in the hosted heap to the native image heap.not every object is added to the heap, for various reasons.",
	"Method": "void addObject(Object original,boolean immutableFromParent,Object reason){\r\n    assert addObjectsPhase.isAllowed() : \"Objects cannot be added at phase: \" + addObjectsPhase.toString() + \" with reason: \" + reason;\r\n    if (original == null || original instanceof WordBase) {\r\n        return;\r\n    }\r\n    if (original instanceof Class) {\r\n        throw VMError.shouldNotReachHere(\"Must not have Class in native image heap: \" + original);\r\n    }\r\n    if (original instanceof DynamicHub && ((DynamicHub) original).getClassInitializationInfo() == null) {\r\n        throw VMError.shouldNotReachHere(\"DynamicHub written to the image that has not been seen as reachable during static analysis: \" + original);\r\n    }\r\n    int identityHashCode;\r\n    if (original instanceof DynamicHub) {\r\n        identityHashCode = System.identityHashCode(universe.hostVM().lookupType((DynamicHub) original).getJavaClass());\r\n    } else {\r\n        identityHashCode = System.identityHashCode(original);\r\n    }\r\n    VMError.guarantee(identityHashCode != 0, \"0 is used as a marker value for 'hash code not yet computed'\");\r\n    if (original instanceof String) {\r\n        handleImageString((String) original);\r\n    }\r\n    final ObjectInfo existing = objects.get(original);\r\n    if (existing == null) {\r\n        addObjectToBootImageHeap(original, immutableFromParent, identityHashCode, reason);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebugException.getCatchLocation",
	"Comment": "get source code location where this exception is to be caught. in case this exception isgoing to be caught by guest language code, the catch location is provided. nullis returned for uncaught exceptions.",
	"Method": "CatchLocation getCatchLocation(){\r\n    if (!isCatchNodeComputed) {\r\n        synchronized (this) {\r\n            if (!isCatchNodeComputed) {\r\n                if (exception instanceof TruffleException) {\r\n                    catchLocation = BreakpointExceptionFilter.getCatchNode(session.getDebugger(), throwLocation, exception);\r\n                    if (catchLocation != null) {\r\n                        catchLocation.setSuspendedEvent(suspendedEvent);\r\n                        catchLocation = catchLocation.cloneFor(session);\r\n                    }\r\n                }\r\n                isCatchNodeComputed = true;\r\n            }\r\n        }\r\n    }\r\n    return catchLocation;\r\n}"
}, {
	"Path": "io.grpc.internal.ClientCallImplTest.timeoutShouldNotBeSet",
	"Comment": "without a context or call options deadline,a timeout should not be set in metadata.",
	"Method": "void timeoutShouldNotBeSet(){\r\n    ClientCallImpl<Void, Void> call = new ClientCallImpl<Void, Void>(method, MoreExecutors.directExecutor(), baseCallOptions, provider, deadlineCancellationExecutor, channelCallTracer, false);\r\n    Metadata headers = new Metadata();\r\n    call.start(callListener, headers);\r\n    assertFalse(headers.containsKey(GrpcUtil.TIMEOUT_KEY));\r\n}"
}, {
	"Path": "com.google.gson.JsonObject.getAsJsonObject",
	"Comment": "convenience method to get the specified member as a jsonobject.",
	"Method": "JsonObject getAsJsonObject(String memberName){\r\n    return (JsonObject) members.get(memberName);\r\n}"
}, {
	"Path": "io.grpc.DecompressorRegistry.with",
	"Comment": "registers a decompressor for both decompression and message encoding negotiation.returns anew registry.",
	"Method": "DecompressorRegistry with(Decompressor d,boolean advertised){\r\n    return new DecompressorRegistry(d, advertised, this);\r\n}"
}, {
	"Path": "com.oracle.truffle.object.ShapeImpl.addProperty",
	"Comment": "add a new property in the map, yielding a new or cached shape object.",
	"Method": "ShapeImpl addProperty(Property property){\r\n    assert isValid();\r\n    onPropertyTransition(property);\r\n    return layout.getStrategy().addProperty(this, property);\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceClient.main",
	"Comment": "the main application allowing this client to be launched from the command line.",
	"Method": "void main(String[] args){\r\n    TestUtils.installConscryptIfAvailable();\r\n    final TestServiceClient client = new TestServiceClient();\r\n    client.parseArgs(args);\r\n    client.setUp();\r\n    Runtime.getRuntime().addShutdownHook(new Thread() {\r\n        @Override\r\n        @SuppressWarnings(\"CatchAndPrintStackTrace\")\r\n        public void run() {\r\n            System.out.println(\"Shutting down\");\r\n            try {\r\n                client.tearDown();\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    });\r\n    try {\r\n        client.run();\r\n    } finally {\r\n        client.tearDown();\r\n    }\r\n    System.exit(0);\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceClient.main",
	"Comment": "the main application allowing this client to be launched from the command line.",
	"Method": "void main(String[] args){\r\n    System.out.println(\"Shutting down\");\r\n    try {\r\n        client.tearDown();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.tools.profiler.CPUSampler.clearData",
	"Comment": "erases all the data gathered by the sampler and resets the sample count to 0.",
	"Method": "void clearData(){\r\n    samplesTaken.set(0);\r\n    for (ProfilerNode<Payload> node : rootNodes.values()) {\r\n        Map<StackTraceEntry, ProfilerNode<Payload>> rootChildren = node.children;\r\n        if (rootChildren != null) {\r\n            rootChildren.clear();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebugContext.getParent",
	"Comment": "get a parent context of this context, if any. this provides the hierarchy of inner contexts.",
	"Method": "DebugContext getParent(){\r\n    TruffleContext parent = context.getParent();\r\n    if (parent == null) {\r\n        return null;\r\n    }\r\n    return executionLifecycle.getCachedDebugContext(parent);\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.AnalysisPolicy.createAllocationSite",
	"Comment": "create the allocation site given a unique key and method. the bci might be duplicated due tograal method substitutions and inlining. then we use a unique object key.",
	"Method": "BytecodeLocation createAllocationSite(BigBang bb,int bci,AnalysisMethod method,BytecodeLocation createAllocationSite,BigBang bb,Object key,AnalysisMethod method){\r\n    return createAllocationSite(bb, BytecodeLocation.keyToBci(key), method);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.UnalignedHeapChunk.walkObjectsOfUnalignedHeapChunk",
	"Comment": "walk the objects in the given chunk, starting from the first object.",
	"Method": "boolean walkObjectsOfUnalignedHeapChunk(UnalignedHeader that,ObjectVisitor visitor){\r\n    return walkObjectsFrom(that, getUnalignedStart(that), visitor);\r\n}"
}, {
	"Path": "io.grpc.internal.DelayedStream.cancel",
	"Comment": "when this method returns, passthrough is guaranteed to be true",
	"Method": "void cancel(Status reason){\r\n    checkNotNull(reason, \"reason\");\r\n    boolean delegateToRealStream = true;\r\n    ClientStreamListener listenerToClose = null;\r\n    synchronized (this) {\r\n        if (realStream == null) {\r\n            realStream = NoopClientStream.INSTANCE;\r\n            delegateToRealStream = false;\r\n            listenerToClose = listener;\r\n            error = reason;\r\n        }\r\n    }\r\n    if (delegateToRealStream) {\r\n        delayOrExecute(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                realStream.cancel(reason);\r\n            }\r\n        });\r\n    } else {\r\n        if (listenerToClose != null) {\r\n            listenerToClose.closed(reason, new Metadata());\r\n        }\r\n        drainPendingCalls();\r\n    }\r\n}"
}, {
	"Path": "io.grpc.internal.DelayedStream.cancel",
	"Comment": "when this method returns, passthrough is guaranteed to be true",
	"Method": "void cancel(Status reason){\r\n    realStream.cancel(reason);\r\n}"
}, {
	"Path": "com.oracle.svm.core.heap.DiscoverableReference.getNextDiscoverableReference",
	"Comment": "read access to the next field. must use objectaccess to read the field because it is writtenwith objectaccess only.",
	"Method": "DiscoverableReference getNextDiscoverableReference(DiscoverableReference getNextDiscoverableReference,DiscoverableReference that){\r\n    return KnownIntrinsics.convertUnknownValue(ObjectAccess.readObject(this, WordFactory.signed(NEXT_FIELD_OFFSET)), DiscoverableReference.class);\r\n}"
}, {
	"Path": "com.oracle.svm.graal.meta.SubstrateMetaAccess.getArrayIndexScale",
	"Comment": "the scale used for the index when accessing elements of an array of this kind.",
	"Method": "int getArrayIndexScale(JavaKind elementKind){\r\n    return getObjectLayout().getArrayIndexScale(elementKind);\r\n}"
}, {
	"Path": "com.google.gson.JsonArray.iterator",
	"Comment": "returns an iterator to navigate the elements of the array. since the array is an ordered list,the iterator navigates the elements in the order they were inserted.",
	"Method": "Iterator<JsonElement> iterator(){\r\n    return elements.iterator();\r\n}"
}, {
	"Path": "com.google.common.base.Preconditions.checkNotNull",
	"Comment": "ensures that an object reference passed as a parameter to the calling method is not null.",
	"Method": "T checkNotNull(T reference,T checkNotNull,T reference,Object errorMessage,T checkNotNull,T reference,String errorMessageTemplate,Object errorMessageArgs,T checkNotNull,T obj,String errorMessageTemplate,char p1,T checkNotNull,T obj,String errorMessageTemplate,int p1,T checkNotNull,T obj,String errorMessageTemplate,long p1,T checkNotNull,T obj,String errorMessageTemplate,Object p1,T checkNotNull,T obj,String errorMessageTemplate,char p1,char p2,T checkNotNull,T obj,String errorMessageTemplate,char p1,int p2,T checkNotNull,T obj,String errorMessageTemplate,char p1,long p2,T checkNotNull,T obj,String errorMessageTemplate,char p1,Object p2,T checkNotNull,T obj,String errorMessageTemplate,int p1,char p2,T checkNotNull,T obj,String errorMessageTemplate,int p1,int p2,T checkNotNull,T obj,String errorMessageTemplate,int p1,long p2,T checkNotNull,T obj,String errorMessageTemplate,int p1,Object p2,T checkNotNull,T obj,String errorMessageTemplate,long p1,char p2,T checkNotNull,T obj,String errorMessageTemplate,long p1,int p2,T checkNotNull,T obj,String errorMessageTemplate,long p1,long p2,T checkNotNull,T obj,String errorMessageTemplate,long p1,Object p2,T checkNotNull,T obj,String errorMessageTemplate,Object p1,char p2,T checkNotNull,T obj,String errorMessageTemplate,Object p1,int p2,T checkNotNull,T obj,String errorMessageTemplate,Object p1,long p2,T checkNotNull,T obj,String errorMessageTemplate,Object p1,Object p2,T checkNotNull,T obj,String errorMessageTemplate,Object p1,Object p2,Object p3,T checkNotNull,T obj,String errorMessageTemplate,Object p1,Object p2,Object p3,Object p4){\r\n    if (obj == null) {\r\n        throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "io.grpc.testing.integration.StressTestClient.main",
	"Comment": "the main application allowing this client to be launched from the command line.",
	"Method": "void main(String args){\r\n    final StressTestClient client = new StressTestClient();\r\n    client.parseArgs(args);\r\n    Runtime.getRuntime().addShutdownHook(new Thread() {\r\n        @Override\r\n        public void run() {\r\n            client.shutdown();\r\n        }\r\n    });\r\n    try {\r\n        client.startMetricsService();\r\n        client.runStressTest();\r\n        client.blockUntilStressTestComplete();\r\n    } catch (Exception e) {\r\n        log.log(Level.WARNING, \"The stress test client encountered an error!\", e);\r\n    } finally {\r\n        client.shutdown();\r\n    }\r\n}"
}, {
	"Path": "io.grpc.testing.integration.StressTestClient.main",
	"Comment": "the main application allowing this client to be launched from the command line.",
	"Method": "void main(String args){\r\n    client.shutdown();\r\n}"
}, {
	"Path": "com.google.gson.JsonArray.getAsBoolean",
	"Comment": "convenience method to get this array as a boolean if it contains a single element.",
	"Method": "boolean getAsBoolean(){\r\n    if (elements.size() == 1) {\r\n        return elements.get(0).getAsBoolean();\r\n    }\r\n    throw new IllegalStateException();\r\n}"
}, {
	"Path": "com.oracle.svm.tutorial.CInterfaceTutorial.printDay",
	"Comment": "java function for which c enum values are automatically converted to java enum constants.",
	"Method": "void printDay(IsolateThread thread,DayOfTheWeek day){\r\n    System.out.format(\"Day: %s (Java ordinal: %d, C value: %d)%n\", day.name(), day.ordinal(), day.getCValue());\r\n    System.out.format(\"  follows %s and %s%n\", dayOfTheWeekAdd(day, -2), dayOfTheWeekAdd(day, -1));\r\n    System.out.format(\"  is followed by %s and %s%n\", dayOfTheWeekAdd(day, +1), dayOfTheWeekAdd(day, +2));\r\n}"
}, {
	"Path": "io.grpc.Status.toString",
	"Comment": "a string representation of the status useful for debugging.",
	"Method": "String toString(){\r\n    return MoreObjects.toStringHelper(this).add(\"code\", code.name()).add(\"description\", description).add(\"cause\", cause != null ? getStackTraceAsString(cause) : cause).toString();\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.runtime.LLVMFunctionDescriptor.toNative",
	"Comment": "gets a pointer to this function that can be stored in native memory.",
	"Method": "LLVMFunctionDescriptor toNative(Object obj,LLVMFunctionDescriptor toNative){\r\n    if (nativeWrapper == null) {\r\n        CompilerDirectives.transferToInterpreterAndInvalidate();\r\n        nativeWrapper = getFunction().createNativeWrapper(this);\r\n        try {\r\n            nativePointer = ForeignAccess.sendAsPointer(Message.AS_POINTER.createNode(), nativeWrapper);\r\n        } catch (UnsupportedMessageException ex) {\r\n            nativePointer = tagSulongFunctionPointer(functionId);\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.TruffleFile.isRegularFile",
	"Comment": "tests if a file is a regular file. checks if the file exists and is a regular file.",
	"Method": "boolean isRegularFile(LinkOption options,boolean isRegularFile){\r\n    try {\r\n        return getAttributeImpl(\"isRegularFile\", Boolean.class, options);\r\n    } catch (IOException ioe) {\r\n        return false;\r\n    } catch (SecurityException se) {\r\n        throw se;\r\n    } catch (Throwable t) {\r\n        throw wrapHostException(t);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.ObjectHeaderImpl.installForwardingPointer",
	"Comment": "install in an object, a forwarding pointer to a different object.",
	"Method": "void installForwardingPointer(Object original,Object copy){\r\n    assert !isPointerToForwardedObject(Word.objectToUntrackedPointer(original));\r\n    UnsignedWord forwardHeader;\r\n    if (ReferenceAccess.singleton().haveCompressedReferences()) {\r\n        if (ReferenceAccess.singleton().getCompressEncoding().hasShift()) {\r\n            forwardHeader = WordFactory.unsigned(0xf0f0f0f0f0f0f0f0L);\r\n            ObjectAccess.writeObject(original, getHubOffset() + getReferenceSize(), copy);\r\n        } else {\r\n            forwardHeader = ReferenceAccess.singleton().getCompressedRepresentation(copy);\r\n        }\r\n    } else {\r\n        forwardHeader = Word.objectToUntrackedPointer(copy);\r\n    }\r\n    assert ObjectHeaderImpl.getHeaderBitsFromHeader(forwardHeader).equal(0);\r\n    writeHeaderToObject(original, forwardHeader.or(FORWARDED));\r\n    assert isPointerToForwardedObject(Word.objectToUntrackedPointer(original));\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebuggerSession.close",
	"Comment": "closes the current debugging session and disposes all installed breakpoints.",
	"Method": "void close(){\r\n    if (Debugger.TRACE) {\r\n        trace(\"close session\");\r\n    }\r\n    if (closed) {\r\n        throw new IllegalStateException(\"session already closed\");\r\n    }\r\n    clearStrategies();\r\n    removeBindings();\r\n    for (Breakpoint breakpoint : this.breakpoints) {\r\n        breakpoint.sessionClosed(this);\r\n    }\r\n    currentSuspendedEventMap.clear();\r\n    allBindings.clear();\r\n    debugger.disposedSession(this);\r\n    closed = true;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebugStackFrame.getLanguage",
	"Comment": "returns public information about the language of this frame.",
	"Method": "LanguageInfo getLanguage(){\r\n    verifyValidState(true);\r\n    RootNode root = findCurrentRoot();\r\n    if (root == null) {\r\n        return null;\r\n    }\r\n    return root.getLanguageInfo();\r\n}"
}, {
	"Path": "io.grpc.internal.FakeClock.forwardNanos",
	"Comment": "forward the time by the given nanoseconds and run all due tasks.",
	"Method": "int forwardNanos(long nanos){\r\n    return forwardTime(nanos, TimeUnit.NANOSECONDS);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.nodes.ControlFlowException.fillInStackTrace",
	"Comment": "for performance reasons, this exception does not record any stack trace information.",
	"Method": "Throwable fillInStackTrace(){\r\n    return null;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebuggerSession.evalInContext",
	"Comment": "evaluates a snippet of code in a halted execution context. assumes frame is part of thecurrent execution stack, behavior is undefined if not.",
	"Method": "Object evalInContext(SuspendedEvent ev,String code,FrameInstance frameInstance,Object evalInContext,SuspendedEvent ev,Node node,MaterializedFrame frame,String code){\r\n    RootNode rootNode = node.getRootNode();\r\n    if (rootNode == null) {\r\n        throw new IllegalArgumentException(\"Cannot evaluate in context using a node that is not yet adopated using a RootNode.\");\r\n    }\r\n    LanguageInfo info = rootNode.getLanguageInfo();\r\n    if (info == null) {\r\n        throw new IllegalArgumentException(\"Cannot evaluate in context using a without an associated TruffleLanguage.\");\r\n    }\r\n    if (!info.isInteractive()) {\r\n        throw new IllegalStateException(\"Can not evaluate in a non-interactive language.\");\r\n    }\r\n    final Source source = Source.newBuilder(info.getId(), code, \"eval in context\").build();\r\n    ExecutableNode fragment = ev.getSession().getDebugger().getEnv().parseInline(source, node, frame);\r\n    if (fragment != null) {\r\n        ev.getInsertableNode().setParentOf(fragment);\r\n        return fragment.execute(frame);\r\n    } else {\r\n        return Debugger.ACCESSOR.evalInContext(source, node, frame);\r\n    }\r\n}"
}, {
	"Path": "io.grpc.alts.internal.HandshakerServiceGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "HandshakerServiceStub newStub(io.grpc.Channel channel){\r\n    return new HandshakerServiceStub(channel);\r\n}"
}, {
	"Path": "io.grpc.examples.routeguide.RouteGuideClient.getFeature",
	"Comment": "blocking unary call example.calls getfeature and prints the response.",
	"Method": "void getFeature(int lat,int lon){\r\n    info(\"*** GetFeature: lat={0} lon={1}\", lat, lon);\r\n    Point request = Point.newBuilder().setLatitude(lat).setLongitude(lon).build();\r\n    Feature feature;\r\n    try {\r\n        feature = blockingStub.getFeature(request);\r\n        if (testHelper != null) {\r\n            testHelper.onMessage(feature);\r\n        }\r\n    } catch (StatusRuntimeException e) {\r\n        warning(\"RPC failed: {0}\", e.getStatus());\r\n        if (testHelper != null) {\r\n            testHelper.onRpcError(e);\r\n        }\r\n        return;\r\n    }\r\n    if (RouteGuideUtil.exists(feature)) {\r\n        info(\"Found feature called \\\"{0}\\\" at {1}, {2}\", feature.getName(), RouteGuideUtil.getLatitude(feature.getLocation()), RouteGuideUtil.getLongitude(feature.getLocation()));\r\n    } else {\r\n        info(\"Found no feature at {0}, {1}\", RouteGuideUtil.getLatitude(feature.getLocation()), RouteGuideUtil.getLongitude(feature.getLocation()));\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.Debugger.getRawBreakpoints",
	"Comment": "for package access only, access under synchronized on this.",
	"Method": "List<Breakpoint> getRawBreakpoints(){\r\n    return breakpoints;\r\n}"
}, {
	"Path": "com.google.gson.JsonArray.getAsLong",
	"Comment": "convenience method to get this array as a long if it contains a single element.",
	"Method": "long getAsLong(){\r\n    if (elements.size() == 1) {\r\n        return elements.get(0).getAsLong();\r\n    }\r\n    throw new IllegalStateException();\r\n}"
}, {
	"Path": "io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall",
	"Comment": "sets unimplemented status for method on given response stream for unary call.",
	"Method": "void asyncUnimplementedUnaryCall(MethodDescriptor<?, ?> methodDescriptor,StreamObserver<?> responseObserver){\r\n    checkNotNull(methodDescriptor, \"methodDescriptor\");\r\n    checkNotNull(responseObserver, \"responseObserver\");\r\n    responseObserver.onError(Status.UNIMPLEMENTED.withDescription(String.format(\"Method %s is unimplemented\", methodDescriptor.getFullMethodName())).asRuntimeException());\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.DirectoryStorageTest.testDeleteComponentFailure",
	"Comment": "test of deletecomponent method, of class registrystorage.",
	"Method": "void testDeleteComponentFailure(){\r\n    if (isWindows()) {\r\n        return;\r\n    }\r\n    copyDir(\"list2\", registryPath);\r\n    Files.setPosixFilePermissions(registryPath, PosixFilePermissions.fromString(\"r--r--r--\"));\r\n    exception.expect(IOException.class);\r\n    try {\r\n        storage.deleteComponent(\"fastr\");\r\n    } finally {\r\n        try {\r\n            Files.setPosixFilePermissions(registryPath, PosixFilePermissions.fromString(\"rwxrwxrwx\"));\r\n        } catch (IOException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.AlignedHeapChunk.walkDirtyObjectsOfAlignedHeapChunk",
	"Comment": "walk the dirty objects in this chunk, passing each to a visitor.",
	"Method": "boolean walkDirtyObjectsOfAlignedHeapChunk(AlignedHeader that,ObjectVisitor visitor,boolean clean){\r\n    final Log trace = Log.noopLog().string(\"[AlignedHeapChunk.walkDirtyObjectsOfAlignedHeapChunk:\");\r\n    trace.string(\"  that: \").hex(that).string(\"  clean: \").bool(clean);\r\n    final Pointer cardTableStart = getCardTableStart(that);\r\n    final Pointer fotStart = getFirstObjectTableStart(that);\r\n    final Pointer objectsStart = getAlignedHeapChunkStart(that);\r\n    final Pointer objectsLimit = that.getTop();\r\n    final UnsignedWord memorySize = objectsLimit.subtract(objectsStart);\r\n    final UnsignedWord indexLimit = CardTable.indexLimitForMemorySize(memorySize);\r\n    trace.string(\"  objectsStart: \").hex(objectsStart).string(\"  objectsLimit: \").hex(objectsLimit).string(\"  indexLimit: \").unsigned(indexLimit);\r\n    for (UnsignedWord index = WordFactory.zero(); index.belowThan(indexLimit); index = index.add(1)) {\r\n        trace.newline().string(\"  \").string(\"  index: \").unsigned(index);\r\n        if (CardTable.isDirtyEntryAtIndex(cardTableStart, index)) {\r\n            final Pointer cardLimit = CardTable.indexToMemoryPointer(objectsStart, index.add(1));\r\n            final Pointer crossingOntoPointer = FirstObjectTable.getPreciseFirstObjectPointer(fotStart, objectsStart, objectsLimit, index);\r\n            final Object crossingOntoObject = crossingOntoPointer.toObject();\r\n            assert walkDirtyObjectsOfAlignedHeapChunkAssert(crossingOntoObject, that, cardTableStart, fotStart, objectsStart, objectsLimit, cardLimit) : \"AlignedHeapChunk.walkDirtyObjectsOfAlignedHeapChunk: crossingOntoObject hub fails to verify.\";\r\n            if (trace.isEnabled()) {\r\n                final Pointer cardStart = CardTable.indexToMemoryPointer(objectsStart, index);\r\n                trace.string(\"    \").string(\"  cardStart: \").hex(cardStart);\r\n                trace.string(\"  cardLimit: \").hex(cardLimit);\r\n                trace.string(\"  crossingOntoObject: \").object(crossingOntoObject);\r\n                trace.string(\"  end: \").hex(LayoutEncoding.getObjectEnd(crossingOntoObject));\r\n                if (LayoutEncoding.isArray(crossingOntoObject)) {\r\n                    trace.string(\"  array length: \").signed(KnownIntrinsics.readArrayLength(crossingOntoObject));\r\n                }\r\n            }\r\n            trace.newline();\r\n            final Pointer impreciseStart = FirstObjectTable.getImpreciseFirstObjectPointer(fotStart, objectsStart, objectsLimit, index);\r\n            Pointer ptr = impreciseStart;\r\n            final Pointer walkLimit = PointerUtils.min(cardLimit, objectsLimit);\r\n            trace.string(\"    \");\r\n            trace.string(\"  impreciseStart: \").hex(impreciseStart);\r\n            trace.string(\"  walkLimit: \").hex(walkLimit);\r\n            while (ptr.belowThan(walkLimit)) {\r\n                trace.newline().string(\"      \");\r\n                trace.string(\"  ptr: \").hex(ptr);\r\n                final Object obj = ptr.toObject();\r\n                assert walkDirtyObjectsOfAlignedHeapChunkAssert(obj, that, cardTableStart, fotStart, objectsStart, objectsLimit, cardLimit) : \"AlignedHeapChunk.walkDirtyObjectsOfAlignedHeapChunk: obj hub fails to verify.\";\r\n                final Pointer objEnd = LayoutEncoding.getObjectEnd(obj);\r\n                trace.string(\"  obj: \").object(obj);\r\n                trace.string(\"  objEnd: \").hex(objEnd);\r\n                if (!visitor.visitObjectInline(obj)) {\r\n                    final Log failureLog = Log.log().string(\"[AlignedHeapChunk.walkDirtyObjects:\");\r\n                    failureLog.string(\"  visitor.visitObject fails\").string(\"  obj: \").object(obj).string(\"]\").newline();\r\n                    return false;\r\n                }\r\n                ptr = objEnd;\r\n            }\r\n            if (clean) {\r\n                CardTable.cleanEntryAtIndex(cardTableStart, index);\r\n            }\r\n        }\r\n    }\r\n    trace.string(\"]\").newline();\r\n    return true;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.UnalignedHeapChunk.usedObjectMemoryOfUnalignedHeapChunk",
	"Comment": "how much space is used for the objects in an unalignedheapchunk?",
	"Method": "UnsignedWord usedObjectMemoryOfUnalignedHeapChunk(UnalignedHeader that){\r\n    final Pointer start = getUnalignedHeapChunkStart(that);\r\n    final Pointer top = that.getTop();\r\n    return top.subtract(start);\r\n}"
}, {
	"Path": "com.google.common.collect.Iterators.emptyModifiableIterator",
	"Comment": "casting to any type is safe since there are no actual elements.",
	"Method": "Iterator<T> emptyModifiableIterator(){\r\n    return (Iterator<T>) EmptyModifiableIterator.INSTANCE;\r\n}"
}, {
	"Path": "com.oracle.svm.core.option.XOptions.parseWithNameAndPrefix",
	"Comment": "try to parse the arg as the given xflag. returns true if successful, false otherwise. throwsnumberformatexception if the option was recognized, but the value was not a number.",
	"Method": "boolean parseWithNameAndPrefix(XFlag xFlag,String arg){\r\n    if (arg.startsWith(xFlag.getPrefixAndName())) {\r\n        final String valueString = arg.substring(xFlag.getPrefixAndName().length());\r\n        parseFromValueString(xFlag, valueString);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.TruffleFile.isDirectory",
	"Comment": "tests if a file is a directory. checks if the file exists and is a directory.",
	"Method": "boolean isDirectory(LinkOption options,boolean isDirectory){\r\n    try {\r\n        return getAttributeImpl(\"isDirectory\", Boolean.class, options);\r\n    } catch (IOException ioe) {\r\n        return false;\r\n    } catch (SecurityException se) {\r\n        throw se;\r\n    } catch (Throwable t) {\r\n        throw wrapHostException(t);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.util.TimeUtils.doNotLoopTooLong",
	"Comment": "have i looped for too long? if so, complain, but reset the wait.",
	"Method": "long doNotLoopTooLong(long startNanos,long loopNanos,long warningNanos,String message){\r\n    long result = loopNanos;\r\n    final long waitedNanos = TimeUtils.nanoSecondsSince(loopNanos);\r\n    if ((0 < warningNanos) && TimeUtils.nanoTimeLessThan(warningNanos, waitedNanos)) {\r\n        Log.log().string(\"[TimeUtils.doNotLoopTooLong:\").string(\"  startNanos: \").signed(startNanos).string(\"  warningNanos: \").signed(warningNanos).string(\" < \").string(\" waitedNanos: \").signed(waitedNanos).string(\"  reason: \").string(message).string(\"]\").newline();\r\n        result = System.nanoTime();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.graalvm.word.WordFactory.zero",
	"Comment": "the constant 0, i.e., the word with no bits set. there is no difference between a signed andunsigned zero.",
	"Method": "T zero(){\r\n    return WordBoxFactory.box(0L);\r\n}"
}, {
	"Path": "io.grpc.internal.Http2Ping.complete",
	"Comment": "completes this operation successfully. the stopwatch given during construction is used tomeasure the elapsed time. registered callbacks are invoked and provided the measured elapsedtime.",
	"Method": "boolean complete(){\r\n    Map<ClientTransport.PingCallback, Executor> callbacks;\r\n    long roundTripTimeNanos;\r\n    synchronized (this) {\r\n        if (completed) {\r\n            return false;\r\n        }\r\n        completed = true;\r\n        roundTripTimeNanos = this.roundTripTimeNanos = stopwatch.elapsed(TimeUnit.NANOSECONDS);\r\n        callbacks = this.callbacks;\r\n        this.callbacks = null;\r\n    }\r\n    for (Map.Entry<ClientTransport.PingCallback, Executor> entry : callbacks.entrySet()) {\r\n        doExecute(entry.getValue(), asRunnable(entry.getKey(), roundTripTimeNanos));\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.grpc.internal.KeepAliveManager.onDataReceived",
	"Comment": "transport has received some data so that we can delay sending keepalives.",
	"Method": "void onDataReceived(){\r\n    nextKeepaliveTime = ticker.read() + keepAliveTimeInNanos;\r\n    if (state == State.PING_SCHEDULED) {\r\n        state = State.PING_DELAYED;\r\n    } else if (state == State.PING_SENT || state == State.IDLE_AND_PING_SENT) {\r\n        if (shutdownFuture != null) {\r\n            shutdownFuture.cancel(false);\r\n        }\r\n        if (state == State.IDLE_AND_PING_SENT) {\r\n            state = State.IDLE;\r\n            return;\r\n        }\r\n        state = State.PING_SCHEDULED;\r\n        checkState(pingFuture == null, \"There should be no outstanding pingFuture\");\r\n        pingFuture = scheduler.schedule(sendPing, keepAliveTimeInNanos, TimeUnit.NANOSECONDS);\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.typeadapters.UtcDateTypeAdapterTest.testUtcDatesOnJdkBefore1_7",
	"Comment": "jdk 1.7 introduced support for xxx format to indicate utc date. but android is older jdk.we want to make sure that this date is parseable in android.",
	"Method": "void testUtcDatesOnJdkBefore1_7(){\r\n    Gson gson = new GsonBuilder().registerTypeAdapter(Date.class, new UtcDateTypeAdapter()).create();\r\n    gson.fromJson(\"'2014-12-05T04:00:00.000Z'\", Date.class);\r\n}"
}, {
	"Path": "io.grpc.alts.internal.ProtectedPromise.addUnprotectedPromise",
	"Comment": "adds a promise for a pending unprotected write. this will be notified after all of the writescomplete.",
	"Method": "void addUnprotectedPromise(ChannelPromise promise){\r\n    unprotectedPromises.add(promise);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.AlignedHeapChunk.allocateMemory",
	"Comment": "allocate memory within this alignedheapchunk. no initialization of the memory happens here.",
	"Method": "Pointer allocateMemory(AlignedHeader that,UnsignedWord size){\r\n    Pointer result = WordFactory.nullPointer();\r\n    final UnsignedWord available = availableObjectMemory(that);\r\n    if (size.belowOrEqual(available)) {\r\n        result = that.getTop();\r\n        final Pointer newTop = result.add(size);\r\n        setTopCarefully(that, newTop);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.truffle.polyglot.PolyglotContextImpl.disposeStaticContext",
	"Comment": "marks all code from this context as unusable. its important that a context is only disposedthere is no code that could rely on the singlecontextassumption.",
	"Method": "void disposeStaticContext(PolyglotContextImpl context){\r\n    SingleContextState state = singleContextState;\r\n    if (state.singleContextAssumption.isValid()) {\r\n        synchronized (state) {\r\n            if (state.singleContextAssumption.isValid()) {\r\n                assert state.singleContext == context;\r\n                state.singleContext = null;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.HashBiMap.findEntryByKey",
	"Comment": "given a key and its hash, returns the index of the entry in the tables, or absent if not found.",
	"Method": "int findEntryByKey(Object key,int findEntryByKey,Object key,int keyHash){\r\n    return findEntry(key, keyHash, hashTableKToV, nextInBucketKToV, keys);\r\n}"
}, {
	"Path": "com.google.gson.GsonBuilder.excludeFieldsWithModifiers",
	"Comment": "configures gson to excludes all class fields that have the specified modifiers. by default,gson will exclude all fields marked transient or static. this method will override thatbehavior.",
	"Method": "GsonBuilder excludeFieldsWithModifiers(int modifiers){\r\n    excluder = excluder.withModifiers(modifiers);\r\n    return this;\r\n}"
}, {
	"Path": "io.grpc.MethodDescriptor.getResponseMarshaller",
	"Comment": "returns the marshaller for the response type. allows introspection of the response marshaller.",
	"Method": "Marshaller<RespT> getResponseMarshaller(){\r\n    return responseMarshaller;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.OldGeneration.emptyFromSpaceIntoToSpace",
	"Comment": "extract all the heapchunks from fromspace and append them to tospace.",
	"Method": "void emptyFromSpaceIntoToSpace(){\r\n    getToSpace().absorb(getFromSpace());\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.SuspendedEvent.hasSourceElement",
	"Comment": "returns true if the underlying guest language source location is denoted as thesource element.",
	"Method": "boolean hasSourceElement(SourceElement sourceElement){\r\n    return context.hasTag(sourceElement.getTag());\r\n}"
}, {
	"Path": "com.oracle.svm.core.jdk8.zipfile.ZipUtils.javaToExtendedDosTime",
	"Comment": "converts java time to dos time, encoding any milliseconds lostin the conversion into the upper half of the returned long.",
	"Method": "long javaToExtendedDosTime(long time){\r\n    if (time < 0) {\r\n        return ZipEntry.DOSTIME_BEFORE_1980;\r\n    }\r\n    long dostime = javaToDosTime(time);\r\n    return (dostime != ZipEntry.DOSTIME_BEFORE_1980) ? dostime + ((time % 2000) << 32) : ZipEntry.DOSTIME_BEFORE_1980;\r\n}"
}, {
	"Path": "io.grpc.netty.JettyTlsUtil.isJettyAlpnConfigured",
	"Comment": "indicates whether or not the jetty alpn jar is installed in the boot classloader.",
	"Method": "boolean isJettyAlpnConfigured(){\r\n    try {\r\n        Class.forName(\"org.eclipse.jetty.alpn.ALPN\", true, null);\r\n        return true;\r\n    } catch (ClassNotFoundException e) {\r\n        jettyAlpnUnavailabilityCause = e;\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "io.grpc.netty.NettyClientHandler.returnProcessedBytes",
	"Comment": "returns the given processed bytes back to inbound flow control.",
	"Method": "void returnProcessedBytes(Http2Stream stream,int bytes){\r\n    try {\r\n        decoder().flowController().consumeBytes(stream, bytes);\r\n    } catch (Http2Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.MethodTypeFlowBuilder.markFieldsUsedInComparison",
	"Comment": "if the node corresponding to the compared value is an instance field load then mark thatfield as being used in a comparison.",
	"Method": "void markFieldsUsedInComparison(ValueNode comparedValue){\r\n    if (comparedValue instanceof LoadFieldNode) {\r\n        LoadFieldNode load = (LoadFieldNode) comparedValue;\r\n        AnalysisField field = (AnalysisField) load.field();\r\n        if (!field.isStatic()) {\r\n            field.markAsUsedInComparison();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentableNodeTest.testTagIsNot",
	"Comment": "first instrument statements and then instrument expressions to test materialization atlocations where there is already a wrapper.",
	"Method": "void testTagIsNot(){\r\n    SourceSectionFilter filter;\r\n    filter = SourceSectionFilter.newBuilder().tagIsNot(StandardTags.RootTag.class).build();\r\n    instrumenter.attachExecutionEventFactory(filter, null, factory);\r\n    execute(\"MATERIALIZE_CHILD_EXPRESSION\");\r\n    assertOn(ENTER, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof MaterializedChildExpressionNode);\r\n    });\r\n    assertOn(ENTER, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof ExpressionNode);\r\n    });\r\n    assertOn(RETURN_VALUE, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof ExpressionNode);\r\n    });\r\n    assertOn(RETURN_VALUE, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof MaterializedChildExpressionNode);\r\n    });\r\n}"
}, {
	"Path": "com.oracle.truffle.api.frame.FrameDescriptor.getSlots",
	"Comment": "retrieve the current list of slots in the descriptor. further changes are not reflected inthe returned collection.",
	"Method": "List<? extends FrameSlot> getSlots(){\r\n    CompilerAsserts.neverPartOfCompilation(NEVER_PART_OF_COMPILATION_MESSAGE);\r\n    synchronized (lock) {\r\n        return Collections.unmodifiableList(new ArrayList(slots));\r\n    }\r\n}"
}, {
	"Path": "io.grpc.benchmarks.qps.ClientConfiguration.newBuilder",
	"Comment": "constructs a builder for configuring a client application with supported parameters. if noparameters are provided, all parameters are assumed to be supported.",
	"Method": "Builder newBuilder(ClientParam supportedParams){\r\n    return new Builder(supportedParams);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.frame.FrameDescriptor.findOrAddFrameSlot",
	"Comment": "finds an existing slot or creates new one. this is a slow operation.",
	"Method": "FrameSlot findOrAddFrameSlot(Object identifier,FrameSlot findOrAddFrameSlot,Object identifier,FrameSlotKind kind,FrameSlot findOrAddFrameSlot,Object identifier,Object info,FrameSlotKind kind){\r\n    CompilerAsserts.neverPartOfCompilation(NEVER_PART_OF_COMPILATION_MESSAGE);\r\n    synchronized (lock) {\r\n        FrameSlot result = findFrameSlot(identifier);\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n        return addFrameSlot(identifier, info, kind);\r\n    }\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.UnaryCallResponseBandwidthBenchmark.setup",
	"Comment": "setup with direct executors, small payloads and a large flow control window.",
	"Method": "void setup(){\r\n    super.setup(ExecutorType.DIRECT, ExecutorType.DIRECT, MessageSize.SMALL, responseSize, clientInboundFlowWindow, ChannelType.NIO, maxConcurrentStreams, 1);\r\n    callCounter = new AtomicLong();\r\n    completed = new AtomicBoolean();\r\n    startUnaryCalls(maxConcurrentStreams, callCounter, completed, responseSize.bytes());\r\n}"
}, {
	"Path": "com.google.gson.JsonElement.isJsonPrimitive",
	"Comment": "provides check for verifying if this element is a primitive or not.",
	"Method": "boolean isJsonPrimitive(){\r\n    return this instanceof JsonPrimitive;\r\n}"
}, {
	"Path": "com.oracle.objectfile.pecoff.PECoffRelocationTable.getNativeReloctab",
	"Comment": "this function uses the entries set to create the native byte array that will be written outto disk.",
	"Method": "PECoffRelocTableStruct getNativeReloctab(){\r\n    if (relocTabStruct != null) {\r\n        return relocTabStruct;\r\n    }\r\n    relocTabStruct = new PECoffRelocTableStruct(getOwner().getSections().size());\r\n    for (PECoffSection s : getOwner().getPECoffSections()) {\r\n        Map<Entry, Entry> entries = (Map<Entry, Entry>) s.getRelocEntries();\r\n        if (entries != null) {\r\n            for (Entry ent : entries.keySet()) {\r\n                long offset = ent.getOffset();\r\n                int sectionID = ent.section == null ? 0 : s.getSectionID();\r\n                relocTabStruct.createRelocationEntry(sectionID, (int) offset, syms.indexOf(ent.sym), (int) ent.t.toLong());\r\n            }\r\n        }\r\n    }\r\n    return relocTabStruct;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.HeapVerifierImpl.classifyPointer",
	"Comment": "this could return an enum, but i want to be able to examine it easily from a debugger.",
	"Method": "int classifyPointer(Pointer p){\r\n    final HeapImpl heap = HeapImpl.getHeapImpl();\r\n    final YoungGeneration youngGen = heap.getYoungGeneration();\r\n    final OldGeneration oldGen = heap.getOldGeneration();\r\n    if (p.isNull()) {\r\n        return 0;\r\n    }\r\n    if (slowlyFindPointerInBootImage(p)) {\r\n        return 1;\r\n    }\r\n    if (youngGen.slowlyFindPointer(p)) {\r\n        return 2;\r\n    }\r\n    int oldGenClassification = oldGen.classifyPointer(p);\r\n    if (oldGenClassification > 0) {\r\n        return 2 + oldGenClassification;\r\n    }\r\n    if (slowlyFindPointerInUnusedSpace(p)) {\r\n        return -1;\r\n    }\r\n    return -2;\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.meta.AnalysisMethod.isInvoked",
	"Comment": "returns true if this method is ever used as the target of a call site.",
	"Method": "boolean isInvoked(){\r\n    return isIntrinsicMethod || isEntryPoint() || isInvoked;\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceImpl.generatePayload",
	"Comment": "generates a payload of desired type and size. reads compressablebuffer oruncompressablebuffer as a circular buffer.",
	"Method": "ByteString generatePayload(ByteString dataBuffer,int offset,int size){\r\n    ByteString payload = ByteString.EMPTY;\r\n    int begin = offset;\r\n    int end = 0;\r\n    int bytesLeft = size;\r\n    while (bytesLeft > 0) {\r\n        end = Math.min(begin + bytesLeft, dataBuffer.size());\r\n        payload = payload.concat(dataBuffer.substring(begin, end));\r\n        bytesLeft -= (end - begin);\r\n        begin = end % dataBuffer.size();\r\n    }\r\n    return payload;\r\n}"
}, {
	"Path": "io.grpc.internal.GrpcUtil.getDefaultProxyDetector",
	"Comment": "returns a proxy detector appropriate for the current environment.",
	"Method": "ProxyDetector getDefaultProxyDetector(){\r\n    if (IS_RESTRICTED_APPENGINE) {\r\n        return NOOP_PROXY_DETECTOR;\r\n    } else {\r\n        return DEFAULT_PROXY_DETECTOR;\r\n    }\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.builder.TypeFlowGraphBuilder.build",
	"Comment": "materialize all reachable flows starting from the sinks and working backwards following thedependency chains. unreachable flows will be implicitly pruned.",
	"Method": "void build(){\r\n    HashSet<TypeFlowBuilder<?>> processed = new HashSet();\r\n    ArrayDeque<TypeFlowBuilder<?>> workQueue = new ArrayDeque();\r\n    for (TypeFlowBuilder<?> sinkBuilder : dataFlowSinkBuilders) {\r\n        if (processed.contains(sinkBuilder)) {\r\n            continue;\r\n        }\r\n        workQueue.addLast(sinkBuilder);\r\n        while (!workQueue.isEmpty()) {\r\n            TypeFlowBuilder<?> builder = workQueue.removeFirst();\r\n            TypeFlow<?> flow = builder.get();\r\n            PointsToStats.registerTypeFlowRetainReason(bb, flow, (sinkBuilder.isBuildingAnActualParameter() ? \"ActualParam=\" : \"\") + sinkBuilder.getFlowClass().getSimpleName());\r\n            processed.add(builder);\r\n            for (TypeFlowBuilder<?> useDependency : builder.getUseDependencies()) {\r\n                if (!processed.contains(useDependency)) {\r\n                    workQueue.addLast(useDependency);\r\n                }\r\n                TypeFlow<?> useFlow = useDependency.get();\r\n                useFlow.addOriginalUse(bb, flow);\r\n            }\r\n            for (TypeFlowBuilder<?> observerDependency : builder.getObserverDependencies()) {\r\n                if (!processed.contains(observerDependency)) {\r\n                    workQueue.addLast(observerDependency);\r\n                }\r\n                TypeFlow<?> observerFlow = observerDependency.get();\r\n                observerFlow.addOriginalObserver(bb, flow);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.internal.LinkedTreeMap.find",
	"Comment": "returns the node at or adjacent to the given key, creating it if requested.",
	"Method": "Node<K, V> find(K key,boolean create){\r\n    Comparator<? super K> comparator = this.comparator;\r\n    Node<K, V> nearest = root;\r\n    int comparison = 0;\r\n    if (nearest != null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Comparable<Object> comparableKey = (comparator == NATURAL_ORDER) ? (Comparable<Object>) key : null;\r\n        while (true) {\r\n            comparison = (comparableKey != null) ? comparableKey.compareTo(nearest.key) : comparator.compare(key, nearest.key);\r\n            if (comparison == 0) {\r\n                return nearest;\r\n            }\r\n            Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\r\n            if (child == null) {\r\n                break;\r\n            }\r\n            nearest = child;\r\n        }\r\n    }\r\n    if (!create) {\r\n        return null;\r\n    }\r\n    Node<K, V> header = this.header;\r\n    Node<K, V> created;\r\n    if (nearest == null) {\r\n        if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\r\n            throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\r\n        }\r\n        created = new Node<K, V>(nearest, key, header, header.prev);\r\n        root = created;\r\n    } else {\r\n        created = new Node<K, V>(nearest, key, header, header.prev);\r\n        if (comparison < 0) {\r\n            nearest.left = created;\r\n        } else {\r\n            nearest.right = created;\r\n        }\r\n        rebalance(nearest, true);\r\n    }\r\n    size++;\r\n    modCount++;\r\n    return created;\r\n}"
}, {
	"Path": "io.grpc.Context.notifyAndClearListeners",
	"Comment": "notify all listeners that this context has been cancelled and immediately releaseany reference to them so that they may be garbage collected.",
	"Method": "void notifyAndClearListeners(){\r\n    if (!canBeCancelled()) {\r\n        return;\r\n    }\r\n    ArrayList<ExecutableListener> tmpListeners;\r\n    synchronized (this) {\r\n        if (listeners == null) {\r\n            return;\r\n        }\r\n        tmpListeners = listeners;\r\n        listeners = null;\r\n    }\r\n    for (int i = 0; i < tmpListeners.size(); i++) {\r\n        if (!(tmpListeners.get(i).listener instanceof ParentListener)) {\r\n            tmpListeners.get(i).deliver();\r\n        }\r\n    }\r\n    for (int i = 0; i < tmpListeners.size(); i++) {\r\n        if (tmpListeners.get(i).listener instanceof ParentListener) {\r\n            tmpListeners.get(i).deliver();\r\n        }\r\n    }\r\n    if (cancellableAncestor != null) {\r\n        cancellableAncestor.removeListener(parentListener);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.tools.profiler.CPUTracer.close",
	"Comment": "closes the tracer for fuhrer use, deleting all the gathered data.",
	"Method": "void close(){\r\n    closed = true;\r\n    clearData();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.CompilerDirectives.inCompiledCode",
	"Comment": "returns a boolean value indicating whether the method is executed in the compiled code.",
	"Method": "boolean inCompiledCode(){\r\n    return false;\r\n}"
}, {
	"Path": "com.oracle.truffle.nfi.test.NumericNFITest.testBoxed",
	"Comment": "test boxed primitive types as argument to native functions.",
	"Method": "void testBoxed(CallTarget callTarget){\r\n    Object ret = callTarget.call(new BoxedPrimitive(42));\r\n    checkExpectedRet(43, ret);\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.test.SLInstrumentTest.testEarlyReturn",
	"Comment": "test that we can forcibly return early from call nodes with an arbitrary value.",
	"Method": "void testEarlyReturn(){\r\n    Assume.assumeFalse(\"Crashes on AArch64 in C2 (GR-8733)\", System.getProperty(\"os.arch\").equalsIgnoreCase(\"aarch64\"));\r\n    String code = \"function main() {\\n\" + \"  a = 10;\\n\" + \"  b = a;\\n\" + \"  // Let fce() warm up and specialize:\\n\" + \"  while (a == b && a < 100000) {\\n\" + \"    a = fce(a);\\n\" + \"    b = b + 1;\\n\" + \"  }\\n\" + \"  c = a;\\n\" + \"  // Run fce() and alter it's return type in an instrument:\\n\" + \"  c = fce(c);\\n\" + \"  return c;\\n\" + \"}\\n\" + \"function fce(x) {\\n\" + \"  return x + 1;\\n\" + \"}\\n\";\r\n    final Source source = Source.newBuilder(\"sl\", code, \"testing\").build();\r\n    ByteArrayOutputStream engineOut = new ByteArrayOutputStream();\r\n    Engine engine = Engine.newBuilder().err(engineOut).build();\r\n    Context context = Context.newBuilder().engine(engine).build();\r\n    Value ret = context.eval(source);\r\n    assertTrue(ret.isNumber());\r\n    assertEquals(100001L, ret.asLong());\r\n    EarlyReturnInstrument earlyReturn = context.getEngine().getInstruments().get(\"testEarlyReturn\").lookup(EarlyReturnInstrument.class);\r\n    earlyReturn.fceCode = \"fce(a)\";\r\n    earlyReturn.returnValue = 200000L;\r\n    ret = context.eval(source);\r\n    assertTrue(ret.isNumber());\r\n    assertEquals(200001L, ret.asLong());\r\n    earlyReturn.returnValue = \"Hello!\";\r\n    ret = context.eval(source);\r\n    assertFalse(ret.isNumber());\r\n    assertTrue(ret.isString());\r\n    assertEquals(\"Hello!1\", ret.asString());\r\n    earlyReturn.fceCode = \"<>\";\r\n    ret = context.eval(source);\r\n    assertTrue(ret.isNumber());\r\n    assertEquals(100001L, ret.asLong());\r\n    earlyReturn.fceCode = \"fce(a)\";\r\n    earlyReturn.returnValue = new BigInteger(\"-42\");\r\n    boolean interopFailure;\r\n    try {\r\n        context.eval(source);\r\n        interopFailure = false;\r\n    } catch (PolyglotException err) {\r\n        interopFailure = true;\r\n    }\r\n    assertTrue(interopFailure);\r\n    earlyReturn.returnValue = new SLBigNumber(new BigInteger(\"-42\"));\r\n    ret = context.eval(source);\r\n    assertTrue(ret.isNumber());\r\n    assertEquals(-41L, ret.asLong());\r\n    earlyReturn.fceCode = \"fce(c)\";\r\n    earlyReturn.returnValue = Boolean.TRUE;\r\n    ret = context.eval(source);\r\n    assertTrue(ret.isBoolean());\r\n    assertEquals(Boolean.TRUE, ret.asBoolean());\r\n    earlyReturn.fceCode = \"fce(c)\";\r\n    earlyReturn.returnValue = -42.42;\r\n    ret = context.eval(source);\r\n    assertTrue(ret.isNumber());\r\n    assertEquals(-42.42, ret.asDouble(), 1e-8);\r\n    earlyReturn.fceCode = \"fce(c)\";\r\n    earlyReturn.returnValue = \"Hello!\";\r\n    ret = context.eval(source);\r\n    assertTrue(ret.isString());\r\n    assertEquals(\"Hello!\", ret.asString());\r\n}"
}, {
	"Path": "com.oracle.truffle.object.LocationImpl.primitiveArrayCount",
	"Comment": "get the number of primitive array elements this location requires.",
	"Method": "int primitiveArrayCount(){\r\n    return 0;\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.MethodTypeFlow.getReturnedParameter",
	"Comment": "if the method returns a parameter through all of the return nodes then that parameternode isreturned, otherwise null.",
	"Method": "ParameterNode getReturnedParameter(){\r\n    return returnedParameter;\r\n}"
}, {
	"Path": "io.grpc.testing.integration.CascadingTest.startChainingServer",
	"Comment": "create a chain of client to server calls which can be cancelled top down.",
	"Method": "Future<?> startChainingServer(int depthThreshold){\r\n    final AtomicInteger serversReady = new AtomicInteger();\r\n    final SettableFuture<Void> chainReady = SettableFuture.create();\r\n    class ChainingService extends TestServiceGrpc.TestServiceImplBase {\r\n        @Override\r\n        public void unaryCall(final SimpleRequest request, final StreamObserver<SimpleResponse> responseObserver) {\r\n            ((ServerCallStreamObserver) responseObserver).setOnCancelHandler(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    receivedCancellations.countDown();\r\n                }\r\n            });\r\n            if (serversReady.incrementAndGet() == depthThreshold) {\r\n                chainReady.set(null);\r\n                return;\r\n            }\r\n            Context.currentContextExecutor(otherWork).execute(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    try {\r\n                        blockingStub.unaryCall(request);\r\n                    } catch (StatusRuntimeException e) {\r\n                        Status status = e.getStatus();\r\n                        if (status.getCode() == Status.Code.CANCELLED) {\r\n                            observedCancellations.countDown();\r\n                        } else {\r\n                            responseObserver.onError(e);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    server = InProcessServerBuilder.forName(\"channel\").executor(otherWork).addService(new ChainingService()).build().start();\r\n    return chainReady;\r\n}"
}, {
	"Path": "io.grpc.testing.integration.CascadingTest.startChainingServer",
	"Comment": "create a chain of client to server calls which can be cancelled top down.",
	"Method": "Future<?> startChainingServer(int depthThreshold){\r\n    ((ServerCallStreamObserver) responseObserver).setOnCancelHandler(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            receivedCancellations.countDown();\r\n        }\r\n    });\r\n    if (serversReady.incrementAndGet() == depthThreshold) {\r\n        chainReady.set(null);\r\n        return;\r\n    }\r\n    Context.currentContextExecutor(otherWork).execute(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                blockingStub.unaryCall(request);\r\n            } catch (StatusRuntimeException e) {\r\n                Status status = e.getStatus();\r\n                if (status.getCode() == Status.Code.CANCELLED) {\r\n                    observedCancellations.countDown();\r\n                } else {\r\n                    responseObserver.onError(e);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.grpc.testing.integration.CascadingTest.startChainingServer",
	"Comment": "create a chain of client to server calls which can be cancelled top down.",
	"Method": "Future<?> startChainingServer(int depthThreshold){\r\n    receivedCancellations.countDown();\r\n}"
}, {
	"Path": "io.grpc.testing.integration.CascadingTest.startChainingServer",
	"Comment": "create a chain of client to server calls which can be cancelled top down.",
	"Method": "Future<?> startChainingServer(int depthThreshold){\r\n    try {\r\n        blockingStub.unaryCall(request);\r\n    } catch (StatusRuntimeException e) {\r\n        Status status = e.getStatus();\r\n        if (status.getCode() == Status.Code.CANCELLED) {\r\n            observedCancellations.countDown();\r\n        } else {\r\n            responseObserver.onError(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.metrics.PerformanceTest.disable_testByteArrayDeserialization",
	"Comment": "last i tested, gson was able to deserialize a byte array of 11mb",
	"Method": "void disable_testByteArrayDeserialization(){\r\n    for (int numElements = 10639296; true; numElements += 16384) {\r\n        StringBuilder sb = new StringBuilder(numElements * 2);\r\n        sb.append(\"[\");\r\n        boolean first = true;\r\n        for (int i = 0; i < numElements; ++i) {\r\n            if (first) {\r\n                first = false;\r\n            } else {\r\n                sb.append(\",\");\r\n            }\r\n            sb.append(\"5\");\r\n        }\r\n        sb.append(\"]\");\r\n        String json = sb.toString();\r\n        byte[] ba = gson.fromJson(json, byte[].class);\r\n        System.out.printf(\"Gson could deserialize a byte array of size: %d\\n\", ba.length);\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.JsonElement.getAsByte",
	"Comment": "convenience method to get this element as a primitive byte value.",
	"Method": "byte getAsByte(){\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}"
}, {
	"Path": "com.oracle.truffle.api.interop.ArityException.getExpectedArity",
	"Comment": "returns the number of arguments that the foreign object expects.",
	"Method": "int getExpectedArity(){\r\n    return expectedArity;\r\n}"
}, {
	"Path": "io.grpc.ServerBuilder.handshakeTimeout",
	"Comment": "sets the permitted time for new connections to complete negotiation handshakes before beingkilled.",
	"Method": "T handshakeTimeout(long timeout,TimeUnit unit){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.TypeFlow.addObserver",
	"Comment": "register object that will be notified when the state of this flow changes.",
	"Method": "void addObserver(BigBang bb,TypeFlow<?> observer,boolean addObserver,BigBang bb,TypeFlow<?> observer,boolean triggerUpdate,boolean registerObservees){\r\n    if (doAddObserver(bb, observer, registerObservees)) {\r\n        if (triggerUpdate) {\r\n            observer.onObservedUpdate(bb);\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.oracle.svm.core.heap.NoAllocationVerifier.isActive",
	"Comment": "returns true if there is an open noallocationverifier, i.e., returns true if no allocation isallowed in this thread.",
	"Method": "boolean isActive(){\r\n    return openVerifiers.get() != null;\r\n}"
}, {
	"Path": "com.oracle.svm.core.hub.ClassInitializationInfo.initializeSuperInterfaces",
	"Comment": "eagerly initialize superinterfaces that declare default methods.",
	"Method": "void initializeSuperInterfaces(DynamicHub hub){\r\n    assert hub.hasDefaultMethods() : \"caller should have checked this\";\r\n    for (DynamicHub iface : hub.getInterfaces()) {\r\n        if (iface.hasDefaultMethods()) {\r\n            initializeSuperInterfaces(iface);\r\n        }\r\n        if (iface.declaresDefaultMethods()) {\r\n            iface.ensureInitialized();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.jdk8.zipfile.ZipFile.releaseInflater",
	"Comment": "releases the specified inflater to the list of available inflaters.",
	"Method": "void releaseInflater(Inflater inf){\r\n    if (!KnownIntrinsics.unsafeCast(inf, Target_java_util_zip_Inflater.class).ended()) {\r\n        inf.reset();\r\n        synchronized (inflaterCache) {\r\n            inflaterCache.add(inf);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.grpc.Server.getImmutableServices",
	"Comment": "returns immutable services registered with the server, or an empty list if not supported by theimplementation.",
	"Method": "List<ServerServiceDefinition> getImmutableServices(){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "com.oracle.svm.core.util.AtomicUnsigned.subtractAndGet",
	"Comment": "atomically subtracts the given value from the current value.",
	"Method": "UnsignedWord subtractAndGet(UnsignedWord delta){\r\n    return WordFactory.unsigned(value.addAndGet(-delta.rawValue()));\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.AlignedHeapChunk.availableObjectMemoryOfAlignedHeapChunk",
	"Comment": "how much space is still available for allocation in an alignedheapchunk?",
	"Method": "UnsignedWord availableObjectMemoryOfAlignedHeapChunk(AlignedHeader that){\r\n    return that.getEnd().subtract(that.getTop());\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.FileDownloaderTest.testDownloadFailedProxy",
	"Comment": "checks that if proxy fails, the direct connection, although it connects later, will be used.",
	"Method": "void testDownloadFailedProxy(){\r\n    URL clu = getClass().getResource(\"data/truffleruby2.jar\");\r\n    URL u = new URL(\"test://graalvm.io/download/truffleruby.zip\");\r\n    ChunkedConnection directConnect = new ChunkedConnection(u, clu.openConnection()) {\r\n        @Override\r\n        public void connect() throws IOException {\r\n            try {\r\n                Thread.sleep(2000);\r\n            } catch (InterruptedException ex) {\r\n            }\r\n            super.connect();\r\n        }\r\n    };\r\n    Handler.bind(u.toString(), directConnect);\r\n    Check check = new Check();\r\n    check.verbose = false;\r\n    delegateFeedback(check);\r\n    FileDownloader dn = new FileDownloader(\"test\", u, this);\r\n    dn.setVerbose(true);\r\n    dn.setDisplayProgress(true);\r\n    dn.envHttpProxy = \"http://localhost:11111\";\r\n    dn.envHttpsProxy = \"http://localhost:11111\";\r\n    synchronized (directConnect) {\r\n        directConnect.nextChunk = 130 * 1024;\r\n        directConnect.readException = new FileNotFoundException();\r\n    }\r\n    exception.expect(FileNotFoundException.class);\r\n    dn.download();\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.FileDownloaderTest.testDownloadFailedProxy",
	"Comment": "checks that if proxy fails, the direct connection, although it connects later, will be used.",
	"Method": "void testDownloadFailedProxy(){\r\n    try {\r\n        Thread.sleep(2000);\r\n    } catch (InterruptedException ex) {\r\n    }\r\n    super.connect();\r\n}"
}, {
	"Path": "com.google.gson.stream.JsonReader.beginArray",
	"Comment": "consumes the next token from the json stream and asserts that it is thebeginning of a new array.",
	"Method": "void beginArray(){\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    if (p == PEEKED_BEGIN_ARRAY) {\r\n        push(JsonScope.EMPTY_ARRAY);\r\n        pathIndices[stackSize - 1] = 0;\r\n        peeked = PEEKED_NONE;\r\n    } else {\r\n        throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());\r\n    }\r\n}"
}, {
	"Path": "io.grpc.grpclb.GrpclbClientLoadRecorder.generateLoadReport",
	"Comment": "generate the report with the data recorded this lb stream since the last report.",
	"Method": "ClientStats generateLoadReport(){\r\n    ClientStats.Builder statsBuilder = ClientStats.newBuilder().setTimestamp(Timestamps.fromNanos(time.currentTimeNanos())).setNumCallsStarted(callsStartedUpdater.getAndSet(this, 0)).setNumCallsFinished(callsFinishedUpdater.getAndSet(this, 0)).setNumCallsFinishedWithClientFailedToSend(callsFailedToSendUpdater.getAndSet(this, 0)).setNumCallsFinishedKnownReceived(callsFinishedKnownReceivedUpdater.getAndSet(this, 0));\r\n    Map<String, LongHolder> localCallsDroppedPerToken = Collections.emptyMap();\r\n    synchronized (this) {\r\n        if (!callsDroppedPerToken.isEmpty()) {\r\n            localCallsDroppedPerToken = callsDroppedPerToken;\r\n            callsDroppedPerToken = new HashMap<String, LongHolder>(localCallsDroppedPerToken.size());\r\n        }\r\n    }\r\n    for (Entry<String, LongHolder> entry : localCallsDroppedPerToken.entrySet()) {\r\n        statsBuilder.addCallsFinishedWithDrop(ClientStatsPerToken.newBuilder().setLoadBalanceToken(entry.getKey()).setNumCalls(entry.getValue().num).build());\r\n    }\r\n    return statsBuilder.build();\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.runtime.debug.value.LLVMDebugObject.getMember",
	"Comment": "if this is a complex object return the member that is identified by the given key.",
	"Method": "Object getMember(String identifier){\r\n    if (identifier == null) {\r\n        return null;\r\n    } else {\r\n        return getMemberSafe(identifier);\r\n    }\r\n}"
}, {
	"Path": "io.grpc.reflection.v1alpha.ServerReflectionGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "ServerReflectionStub newStub(io.grpc.Channel channel){\r\n    return new ServerReflectionStub(channel);\r\n}"
}, {
	"Path": "io.grpc.internal.KeepAliveManager.clampKeepAliveTimeInNanos",
	"Comment": "bumps keepalive time to 10 seconds if the specified value was smaller than that.",
	"Method": "long clampKeepAliveTimeInNanos(long keepAliveTimeInNanos){\r\n    return Math.max(keepAliveTimeInNanos, MIN_KEEPALIVE_TIME_NANOS);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.CardTable.indexToMemoryPointer",
	"Comment": "return the memory address of theof this indexed entry. if you want the limit on thememory address of this indexed entry, ask for the start of theindexed entry.",
	"Method": "Pointer indexToMemoryPointer(Pointer memoryStart,UnsignedWord index){\r\n    final UnsignedWord offset = index.multiply(MEMORY_BYTES_PER_ENTRY);\r\n    return memoryStart.add(offset);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebuggerSession.isBreakpointsActive",
	"Comment": "test whether breakpoints of the given kind are active in this session. breakpoints do notbreak execution when not active.",
	"Method": "boolean isBreakpointsActive(boolean isBreakpointsActive,Breakpoint.Kind breakpointKind){\r\n    switch(breakpointKind) {\r\n        case SOURCE_LOCATION:\r\n            return locationBreakpointsActive.get();\r\n        case EXCEPTION:\r\n            return exceptionBreakpointsActive.get();\r\n        case HALT_INSTRUCTION:\r\n            return alwaysHaltBreakpointsActive.get();\r\n        default:\r\n            CompilerDirectives.transferToInterpreter();\r\n            throw new IllegalStateException(\"Unhandled breakpoint kind: \" + breakpointKind);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.AlignedHeapChunk.setUpRememberedSetForObjectOfAlignedHeapChunk",
	"Comment": "initialize the remembered set for a particular object, if this chunk has a remembered set.",
	"Method": "void setUpRememberedSetForObjectOfAlignedHeapChunk(AlignedHeader that,Object obj){\r\n    VMOperation.guaranteeInProgress(\"Should only be called from the collector.\");\r\n    final HeapImpl heap = HeapImpl.getHeapImpl();\r\n    if (!heap.isYoungGeneration(that.getSpace())) {\r\n        final Pointer fotStart = getFirstObjectTableStart(that);\r\n        final Pointer memoryStart = getAlignedHeapChunkStart(that);\r\n        final Pointer objStart = Word.objectToUntrackedPointer(obj);\r\n        final Pointer objEnd = LayoutEncoding.getObjectEnd(obj);\r\n        FirstObjectTable.setTableForObject(fotStart, memoryStart, objStart, objEnd);\r\n        ObjectHeaderImpl.getObjectHeaderImpl().setCardRememberedSetAligned(obj);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.test.polyglot.PolyglotCachingTest.testSourceStrongContextFree",
	"Comment": "test that if the context is freed and the source reference is still strong the gc can collectthe cached calltargets.",
	"Method": "void testSourceStrongContextFree(){\r\n    Assume.assumeFalse(\"This test is too slow in fastdebug.\", System.getProperty(\"java.vm.version\").contains(\"fastdebug\"));\r\n    setupTestLang(false);\r\n    List<Source> survivingSources = new ArrayList();\r\n    GCUtils.assertObjectsCollectible((iteration) -> {\r\n        Context context = Context.create();\r\n        Source source = Source.create(ProxyLanguage.ID, String.valueOf(iteration));\r\n        CallTarget parsedAST = assertParsedEval(context, source);\r\n        assertCachedEval(context, source);\r\n        survivingSources.add(source);\r\n        context.close();\r\n        return parsedAST;\r\n    });\r\n}"
}, {
	"Path": "com.oracle.svm.core.util.AtomicUnsigned.getAndSubtract",
	"Comment": "atomically subtracts the given value from the current value.",
	"Method": "UnsignedWord getAndSubtract(UnsignedWord delta){\r\n    return WordFactory.unsigned(value.getAndAdd(-delta.rawValue()));\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.typestate.TypeStateUtils.intersection",
	"Comment": "returns the intersection of the two analysis object arrays of the same type. if one of themcontains a single context insensitive object, the other array is returned.",
	"Method": "AnalysisObject[] intersection(BigBang bb,AnalysisObject[] a1,AnalysisObject[] a2){\r\n    if (a1.length == 1 && a1[0].isContextInsensitiveObject()) {\r\n        return a2;\r\n    } else if (a2.length == 1 && a2[0].isContextInsensitiveObject()) {\r\n        return a1;\r\n    } else {\r\n        if (a1.length <= a2.length) {\r\n            return arraysIntersection(bb, a1, a2);\r\n        } else {\r\n            return arraysIntersection(bb, a2, a1);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.posix.thread.PosixJavaThreads.setNativeName",
	"Comment": "try to set the native name of the current thread.failures are ignored.",
	"Method": "void setNativeName(Thread thread,String name){\r\n    if (!hasThreadIdentifier(thread)) {\r\n        return;\r\n    }\r\n    if (IsDefined.isDarwin() && thread != Thread.currentThread()) {\r\n        return;\r\n    }\r\n    final int startIndex = Math.max(0, name.length() - 15);\r\n    final String pthreadName = name.substring(startIndex);\r\n    assert pthreadName.length() < 16 : \"thread name for pthread has a maximum length of 16 characters including the terminating 0\";\r\n    try (CCharPointerHolder threadNameHolder = CTypeConversion.toCString(pthreadName)) {\r\n        if (IsDefined.isLinux()) {\r\n            LinuxPthread.pthread_setname_np(getPthreadIdentifier(thread), threadNameHolder.get());\r\n        } else if (IsDefined.isDarwin()) {\r\n            assert thread == Thread.currentThread() : \"Darwin only allows setting the name of the current thread\";\r\n            DarwinPthread.pthread_setname_np(threadNameHolder.get());\r\n        } else {\r\n            VMError.unsupportedFeature(\"PosixJavaThreads.setNativeName on unknown OS\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.runtime.debug.value.LLVMDebugObject.getKeys",
	"Comment": "if this is a complex object return the identifiers for its members.",
	"Method": "String[] getKeys(){\r\n    if (value == null) {\r\n        return NO_KEYS;\r\n    } else {\r\n        return getKeysSafe();\r\n    }\r\n}"
}, {
	"Path": "io.grpc.ManagedChannelBuilder.maxTraceEvents",
	"Comment": "sets the maximum number of channel trace events to keep in the tracer for each channel orsubchannel. if set to 0, channel tracing is effectively disabled.",
	"Method": "T maxTraceEvents(int maxTraceEvents){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "io.grpc.inprocess.InProcessChannelBuilder.forName",
	"Comment": "create a channel builder that will connect to the server with the given name.",
	"Method": "InProcessChannelBuilder forName(String name){\r\n    return new InProcessChannelBuilder(name);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebuggerSession.resumeAll",
	"Comment": "resumes all suspended executions that have not yet been notified.",
	"Method": "void resumeAll(){\r\n    if (Debugger.TRACE) {\r\n        trace(\"resume all threads\");\r\n    }\r\n    if (closed) {\r\n        throw new IllegalStateException(\"session closed\");\r\n    }\r\n    clearStrategies();\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.AlignedHeapChunk.getEnclosingAlignedHeapChunk",
	"Comment": "return the associated alignedheapchunk for a given object.",
	"Method": "AlignedHeader getEnclosingAlignedHeapChunk(Object obj){\r\n    final Pointer ptr = Word.objectToUntrackedPointer(obj);\r\n    return getEnclosingAlignedHeapChunkFromPointer(ptr);\r\n}"
}, {
	"Path": "com.oracle.svm.core.jdk.RuntimeSupport.addTearDownHook",
	"Comment": "adds a tear down hook that is executed before the isolate torn down.",
	"Method": "void addTearDownHook(Runnable tearDownHook){\r\n    addHook(tearDownHooks, tearDownHook);\r\n}"
}, {
	"Path": "io.grpc.health.v1.HealthGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "HealthStub newStub(io.grpc.Channel channel){\r\n    return new HealthStub(channel);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.CompilerDirectives.isPartialEvaluationConstant",
	"Comment": "returns a boolean indicating whether or not a given value is seen as constant during theinitial partial evaluation phase. if this method is called in the interpreter this methodwill always return true.",
	"Method": "boolean isPartialEvaluationConstant(Object value){\r\n    return CompilerDirectives.inInterpreter();\r\n}"
}, {
	"Path": "io.grpc.testing.integration.ReconnectServiceGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "ReconnectServiceStub newStub(io.grpc.Channel channel){\r\n    return new ReconnectServiceStub(channel);\r\n}"
}, {
	"Path": "io.grpc.internal.GrpcUtil.authorityToUri",
	"Comment": "parse an authority into a uri for retrieving the host and port.",
	"Method": "URI authorityToUri(String authority){\r\n    Preconditions.checkNotNull(authority, \"authority\");\r\n    URI uri;\r\n    try {\r\n        uri = new URI(null, authority, null, null, null);\r\n    } catch (URISyntaxException ex) {\r\n        throw new IllegalArgumentException(\"Invalid authority: \" + authority, ex);\r\n    }\r\n    return uri;\r\n}"
}, {
	"Path": "io.grpc.internal.MessageFramer.dispose",
	"Comment": "closes the framer and releases any buffers, but does not flush. after the framer isclosed or disposed, additional calls to this method will have no affect.",
	"Method": "void dispose(){\r\n    closed = true;\r\n    releaseBuffer();\r\n}"
}, {
	"Path": "io.grpc.examples.routeguide.RouteGuideServer.blockUntilShutdown",
	"Comment": "await termination on the main thread since the grpc library uses daemon threads.",
	"Method": "void blockUntilShutdown(){\r\n    if (server != null) {\r\n        server.awaitTermination();\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.thread.VMOperationControl.unsetLockOwner",
	"Comment": "note that this thread is not the owner of the vmoperation lock.",
	"Method": "void unsetLockOwner(){\r\n    assert isLockOwner() : \"VMOperationControl.unsetOwner, but not owner.\";\r\n    isLockOwner.set(0);\r\n}"
}, {
	"Path": "com.google.common.collect.HashBiMap.createFilledWithAbsent",
	"Comment": "returns an int array of the specified size, filled with absent.",
	"Method": "int[] createFilledWithAbsent(int size){\r\n    int[] array = new int[size];\r\n    Arrays.fill(array, ABSENT);\r\n    return array;\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.context.AnalysisContext.asKey",
	"Comment": "creates a wrapper for the context that performs value equality instead of identity equality.the wrapper object is used as a key in the map that keeps track of the contexts to createunique contexts.",
	"Method": "AnalysisContextKey asKey(){\r\n    return new AnalysisContextKey();\r\n}"
}, {
	"Path": "io.grpc.examples.advanced.HelloJsonServer.blockUntilShutdown",
	"Comment": "await termination on the main thread since the grpc library uses daemon threads.",
	"Method": "void blockUntilShutdown(){\r\n    if (server != null) {\r\n        server.awaitTermination();\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.Scope.newBuilder",
	"Comment": "create a new scope builder.the properties representing the variables needs to have deterministic iteration order,variable declaration order is recommended.",
	"Method": "Builder newBuilder(String name,Object variables){\r\n    return EMPTY.new Builder(name, variables);\r\n}"
}, {
	"Path": "io.grpc.internal.DelayedStream.setStream",
	"Comment": "when this method returns, passthrough is guaranteed to be true",
	"Method": "void setStream(ClientStream stream){\r\n    synchronized (this) {\r\n        if (realStream != null) {\r\n            return;\r\n        }\r\n        realStream = checkNotNull(stream, \"stream\");\r\n    }\r\n    drainPendingCalls();\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.FirstObjectTable.getImpreciseFirstObjectPointer",
	"Comment": "return a pointer into a memory region indicated by the entry at a given index.for an imprecise mark, this means i can skip past any object that crosses onto this entry.",
	"Method": "Pointer getImpreciseFirstObjectPointer(Pointer tableStart,Pointer memoryStart,Pointer memoryLimit,UnsignedWord index){\r\n    final Log trace = Log.noopLog().string(\"[FirstObjectTable.getImpreciseFirstObjectPointer:\");\r\n    trace.string(\"  tableStart: \").hex(tableStart).string(\"  memoryStart: \").hex(memoryStart).string(\"  memoryLimit: \").hex(memoryLimit).string(\"  index: \").unsigned(index).newline();\r\n    final Pointer preciseFirstPointer = getPreciseFirstObjectPointer(tableStart, memoryStart, memoryLimit, index);\r\n    final Pointer indexedMemoryStart = indexToMemoryPointer(index, memoryStart);\r\n    final Pointer result;\r\n    if (preciseFirstPointer.belowThan(indexedMemoryStart)) {\r\n        final Object crossingObject = preciseFirstPointer.toObject();\r\n        result = LayoutEncoding.getObjectEnd(crossingObject);\r\n    } else {\r\n        assert preciseFirstPointer.equal(indexedMemoryStart) : \"preciseFirstPointer.equal(indexedMemoryStart)\";\r\n        result = indexedMemoryStart;\r\n    }\r\n    trace.string(\"  returns: \").hex(result);\r\n    assert memoryStart.belowOrEqual(result) : \"memoryStart.belowOrEqual(result)\";\r\n    assert result.belowOrEqual(memoryLimit) : \"result.belowOrEqual(memoryLimit)\";\r\n    trace.string(\"]\").newline();\r\n    return result;\r\n}"
}, {
	"Path": "io.grpc.netty.JettyTlsUtil.isJettyNpnConfigured",
	"Comment": "indicates whether or not the jetty npn jar is installed in the boot classloader.",
	"Method": "boolean isJettyNpnConfigured(){\r\n    try {\r\n        Class.forName(\"org.eclipse.jetty.npn.NextProtoNego\", true, null);\r\n        return true;\r\n    } catch (ClassNotFoundException e) {\r\n        jettyNpnUnavailabilityCause = e;\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.JsonElement.getAsFloat",
	"Comment": "convenience method to get this element as a primitive float value.",
	"Method": "float getAsFloat(){\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.image.NativeBootImage.markDataRelocationSite",
	"Comment": "a reference to data. mark the relocation using the section and addend in the relocation info.",
	"Method": "void markDataRelocationSite(ProgbitsSectionImpl sectionImpl,int offset,RelocatableBuffer.Info info,NativeImageHeap.ObjectInfo targetObjectInfo){\r\n    assert ((info.getRelocationSize() == 4) || (info.getRelocationSize() == 8)) : \"Data relocation size should be 4 or 8 bytes.\";\r\n    assert targetObjectInfo != null;\r\n    HeapPartition partition = targetObjectInfo.getPartition();\r\n    assert partition != null;\r\n    final String targetSectionName = partition.getSectionName();\r\n    final long targetOffsetInSection = targetObjectInfo.getOffsetInSection();\r\n    final long relocationInfoAddend = info.hasExplicitAddend() ? info.getExplicitAddend().longValue() : 0L;\r\n    final long relocationAddend = targetOffsetInSection + relocationInfoAddend;\r\n    sectionImpl.markRelocationSite(offset, info.getRelocationSize(), info.getRelocationKind(), targetSectionName, false, relocationAddend);\r\n}"
}, {
	"Path": "com.oracle.truffle.tools.profiler.CPUSampler.close",
	"Comment": "closes the sampler for further use, deleting all the gathered data.",
	"Method": "void close(){\r\n    closed = true;\r\n    resetSampling();\r\n    clearData();\r\n}"
}, {
	"Path": "org.graalvm.component.installer.commands.InstallCommand.completeInstallers",
	"Comment": "creates installers with complete info. revalidates the installers as they are now complete.",
	"Method": "void completeInstallers(){\r\n    for (ComponentParam p : new ArrayList(realInstallers.keySet())) {\r\n        Installer i = realInstallers.get(p);\r\n        if (i == null) {\r\n            i = createInstaller(p, p.createFileLoader());\r\n            installers.add(i);\r\n            if (validateBeforeInstall) {\r\n                current = i.getComponentInfo().getName();\r\n                i.validateAll();\r\n            } else {\r\n                if (!force) {\r\n                    i.validateRequirements();\r\n                }\r\n            }\r\n            realInstallers.put(p, i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.grpc.alts.internal.AltsTsiHandshaker.createFrameProtector",
	"Comment": "creates a frame protector from a completed handshake. no other methods may be called after theframe protector is created.",
	"Method": "TsiFrameProtector createFrameProtector(int maxFrameSize,ByteBufAllocator alloc,TsiFrameProtector createFrameProtector,ByteBufAllocator alloc){\r\n    return createFrameProtector(AltsTsiFrameProtector.getMaxAllowedFrameBytes(), alloc);\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.MethodTypeFlow.doParse",
	"Comment": "all threads that try to parse the current method synchronize and only the first parses.",
	"Method": "void doParse(BigBang bb,InvokeTypeFlow reason){\r\n    if (!methodParsed) {\r\n        parsingReason = reason;\r\n        try {\r\n            MethodTypeFlowBuilder builder = bb.createMethodTypeFlowBuilder(bb, this);\r\n            builder.apply();\r\n            graphRef = builder.graph;\r\n        } catch (BytecodeParserError ex) {\r\n            if (ex.getCause() instanceof UnsupportedFeatureException) {\r\n                Throwable cause = ex;\r\n                if (ex.getCause().getCause() != null) {\r\n                    cause = ex.getCause();\r\n                }\r\n                String message = cause.getMessage();\r\n                bb.getUnsupportedFeatures().addMessage(method.format(\"%H.%n(%p)\"), method, message, ex.context(), cause.getCause());\r\n            } else {\r\n                throw AnalysisError.parsingError(method, ex);\r\n            }\r\n        } catch (Throwable t) {\r\n            throw AnalysisError.parsingError(method, t);\r\n        }\r\n        originalMethodFlows.linearizeGraph();\r\n        bb.numParsedGraphs.incrementAndGet();\r\n        returnedParameter = computeReturnedParamter();\r\n        methodParsed = true;\r\n    }\r\n}"
}, {
	"Path": "io.grpc.internal.GzipInflatingBuffer.hasPartialData",
	"Comment": "returns true when there is gzippeddata that has not been input to the inflater or the inflaterhas not consumed all of its input, or all data has been consumed but we are at not at theboundary between gzip streams.",
	"Method": "boolean hasPartialData(){\r\n    checkState(!closed, \"GzipInflatingBuffer is closed\");\r\n    return gzipMetadataReader.readableBytes() != 0 || state != State.HEADER;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.RootNodeBits.isSameSource",
	"Comment": "returns true if the same source is used for the whole root node.",
	"Method": "boolean isSameSource(int bits){\r\n    return (bits & SAME_SOURCE) > 0;\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.NullCheckTypeFlow.isFilterNull",
	"Comment": "if true, lets anything but null pass through. if false only null passes through.",
	"Method": "boolean isFilterNull(){\r\n    return filterNull;\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.runtime.SLContext.createObject",
	"Comment": "allocate an empty object. all new objects initially have no properties. properties are addedwhen they are first stored, i.e., the store triggers a shape change of the object.",
	"Method": "DynamicObject createObject(){\r\n    DynamicObject object = null;\r\n    allocationReporter.onEnter(null, 0, AllocationReporter.SIZE_UNKNOWN);\r\n    object = emptyShape.newInstance();\r\n    allocationReporter.onReturnValue(object, 0, AllocationReporter.SIZE_UNKNOWN);\r\n    return object;\r\n}"
}, {
	"Path": "io.grpc.Metadata.discardAll",
	"Comment": "remove all values for the given key without returning them. this is a minor performanceoptimization if you do not need the previous values.",
	"Method": "void discardAll(Key<T> key){\r\n    if (isEmpty()) {\r\n        return;\r\n    }\r\n    int writeIdx = 0;\r\n    int readIdx = 0;\r\n    for (; readIdx < size; readIdx++) {\r\n        if (bytesEqual(key.asciiName(), name(readIdx))) {\r\n            continue;\r\n        }\r\n        name(writeIdx, name(readIdx));\r\n        value(writeIdx, value(readIdx));\r\n        writeIdx++;\r\n    }\r\n    int newSize = writeIdx;\r\n    Arrays.fill(namesAndValues, writeIdx * 2, len(), null);\r\n    size = newSize;\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.runtime.memory.LLVMNativeMemory.checkPointer",
	"Comment": "checks for pointers that are in the negative range or below 1mb, to detect common invalidaddresses before they cause a segmentation fault.",
	"Method": "boolean checkPointer(long ptr){\r\n    assert ptr > 0x100000 : \"trying to access invalid address: \" + ptr + \" 0x\" + Long.toHexString(ptr);\r\n    return true;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.InstrumentationHandler.lazyInitializeSourcesExecutedList",
	"Comment": "initializes sourcesexecuted and sourcesexecutedlist by populating them from executedroots.",
	"Method": "void lazyInitializeSourcesExecutedList(){\r\n    assert Thread.holdsLock(sourcesExecuted);\r\n    if (sourcesExecutedListRef.get() == null) {\r\n        Collection<Source> sourcesExecutedList = new WeakAsyncList(16);\r\n        sourcesExecutedListRef.set(sourcesExecutedList);\r\n        for (RootNode root : executedRoots) {\r\n            int rootBits = RootNodeBits.get(root);\r\n            if (RootNodeBits.isNoSourceSection(rootBits)) {\r\n                continue;\r\n            } else {\r\n                SourceSection sourceSection = root.getSourceSection();\r\n                if (RootNodeBits.isSameSource(rootBits) && sourceSection != null) {\r\n                    Source source = sourceSection.getSource();\r\n                    if (!sourcesExecuted.containsKey(source)) {\r\n                        sourcesExecuted.put(source, null);\r\n                        sourcesExecutedList.add(source);\r\n                    }\r\n                } else {\r\n                    if (sourceSection != null) {\r\n                        findSourcesExecutedVisitor.adoptSource(sourceSection.getSource());\r\n                    }\r\n                    visitRoot(root, root, findSourcesExecutedVisitor, false);\r\n                    for (Source source : findSourcesExecutedVisitor.rootSources) {\r\n                        if (!sourcesExecuted.containsKey(source)) {\r\n                            sourcesExecuted.put(source, null);\r\n                            sourcesExecutedList.add(source);\r\n                        }\r\n                    }\r\n                    findSourcesExecutedVisitor.rootSources.clear();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceImpl.unaryCall",
	"Comment": "immediately responds with a payload of the type and size specified in the request.",
	"Method": "void unaryCall(SimpleRequest req,StreamObserver<SimpleResponse> responseObserver){\r\n    ServerCallStreamObserver<SimpleResponse> obs = (ServerCallStreamObserver<SimpleResponse>) responseObserver;\r\n    SimpleResponse.Builder responseBuilder = SimpleResponse.newBuilder();\r\n    try {\r\n        if (req.hasResponseCompressed() && req.getResponseCompressed().getValue()) {\r\n            obs.setCompression(\"gzip\");\r\n        } else {\r\n            obs.setCompression(\"identity\");\r\n        }\r\n    } catch (IllegalArgumentException e) {\r\n        obs.onError(Status.UNIMPLEMENTED.withDescription(\"compression not supported.\").withCause(e).asRuntimeException());\r\n        return;\r\n    }\r\n    if (req.getResponseSize() != 0) {\r\n        int offset = random.nextInt(compressableBuffer.size());\r\n        ByteString payload = generatePayload(compressableBuffer, offset, req.getResponseSize());\r\n        responseBuilder.setPayload(Payload.newBuilder().setBody(payload));\r\n    }\r\n    if (req.hasResponseStatus()) {\r\n        obs.onError(Status.fromCodeValue(req.getResponseStatus().getCode()).withDescription(req.getResponseStatus().getMessage()).asRuntimeException());\r\n        return;\r\n    }\r\n    responseObserver.onNext(responseBuilder.build());\r\n    responseObserver.onCompleted();\r\n}"
}, {
	"Path": "io.grpc.reflection.testing.DynamicServiceGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "DynamicServiceStub newStub(io.grpc.Channel channel){\r\n    return new DynamicServiceStub(channel);\r\n}"
}, {
	"Path": "com.oracle.svm.core.code.RuntimeCodeInfo.tearDown",
	"Comment": "tear down the heap, return all allocated virtual memory chunks to virtualmemoryprovider.",
	"Method": "void tearDown(){\r\n    for (int i = 0; i < numMethods; i++) {\r\n        methodInfos[i].freeInstalledCode();\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentationTest.testDefaultId",
	"Comment": "test that metadata is properly propagated to instrument handles.",
	"Method": "void testDefaultId(){\r\n    Instrument descriptor1 = engine.getInstruments().get(MetadataInstrument2.class.getSimpleName());\r\n    Assert.assertEquals(\"\", descriptor1.getName());\r\n    Assert.assertEquals(engine.getVersion(), descriptor1.getVersion());\r\n    Assert.assertEquals(MetadataInstrument2.class.getSimpleName(), descriptor1.getId());\r\n    Assert.assertFalse(isInitialized(descriptor1));\r\n}"
}, {
	"Path": "io.grpc.testing.GrpcCleanupRule.setTicker",
	"Comment": "sets a specified time source for monitoring cleanup timeout.",
	"Method": "GrpcCleanupRule setTicker(Ticker ticker){\r\n    this.stopwatch = Stopwatch.createUnstarted(ticker);\r\n    return this;\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.AbstractBenchmark.teardown",
	"Comment": "shutdown all the client channels and then shutdown the server.",
	"Method": "void teardown(){\r\n    logger.fine(\"shutting down channels\");\r\n    for (ManagedChannel channel : channels) {\r\n        channel.shutdown();\r\n    }\r\n    logger.fine(\"shutting down server\");\r\n    server.shutdown();\r\n    if (!server.awaitTermination(5, TimeUnit.SECONDS)) {\r\n        logger.warning(\"Failed to shutdown server\");\r\n    }\r\n    logger.fine(\"server shut down\");\r\n    for (ManagedChannel channel : channels) {\r\n        if (!channel.awaitTermination(1, TimeUnit.SECONDS)) {\r\n            logger.warning(\"Failed to shutdown client\");\r\n        }\r\n    }\r\n    logger.fine(\"channels shut down\");\r\n}"
}, {
	"Path": "com.oracle.truffle.tools.profiler.CPUSampler.takeSample",
	"Comment": "sample all threads and gather their current stack trace entries. the returned map and listsare unmodifiable and represent atomic snapshots of the stack at the time when this method wasinvoked. only active threads are sampled. a thread is active if it has at least one entry onthe stack. the sampling is initialized if this method is invoked for the first time orreinitialized if the configuration changes.",
	"Method": "Map<Thread, List<StackTraceEntry>> takeSample(){\r\n    ShadowStack localShadowStack = shadowStack;\r\n    if (localShadowStack == null) {\r\n        localShadowStack = initializeShadowStack();\r\n    }\r\n    if (delaySamplingUntilNonInternalLangInit && !nonInternalLanguageContextInitialized) {\r\n        return Collections.emptyMap();\r\n    }\r\n    assert localShadowStack != null;\r\n    Map<Thread, List<StackTraceEntry>> stacks = new HashMap();\r\n    for (ShadowStack.ThreadLocalStack stack : localShadowStack.getStacks()) {\r\n        if (stack.hasStackOverflowed()) {\r\n            stackOverflowed = true;\r\n            continue;\r\n        }\r\n        StackTraceEntry[] strace = stack.getStack();\r\n        if (strace != null && strace.length > 0) {\r\n            assert !stacks.containsKey(stack.getThread());\r\n            final List<StackTraceEntry> stackTraceEntries = Arrays.asList(strace);\r\n            Collections.reverse(stackTraceEntries);\r\n            stacks.put(stack.getThread(), Collections.unmodifiableList(stackTraceEntries));\r\n        }\r\n    }\r\n    return Collections.unmodifiableMap(stacks);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.Tag.getIdentifier",
	"Comment": "returns the alias of a particular tag or null if no alias was specified for thistag.",
	"Method": "String getIdentifier(Class<? extends Tag> tag){\r\n    Objects.requireNonNull(tag);\r\n    Tag.Identifier alias = tag.getAnnotation(Tag.Identifier.class);\r\n    if (alias != null) {\r\n        return alias.value();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.grpc.internal.KeepAliveManager.onTransportTermination",
	"Comment": "transport is being terminated. we no longer need to do keepalives.",
	"Method": "void onTransportTermination(){\r\n    if (state != State.DISCONNECTED) {\r\n        state = State.DISCONNECTED;\r\n        if (shutdownFuture != null) {\r\n            shutdownFuture.cancel(false);\r\n        }\r\n        if (pingFuture != null) {\r\n            pingFuture.cancel(false);\r\n            pingFuture = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.windows.WindowsUtils.getNanoCounter",
	"Comment": "retrieve a nanosecond counter for elapsed time measurement.",
	"Method": "long getNanoCounter(){\r\n    if (performanceFrequency == 0L) {\r\n        CLongPointer count = StackValue.get(CLongPointer.class);\r\n        WinBase.QueryPerformanceFrequency(count);\r\n        performanceFrequency = count.read();\r\n    }\r\n    CLongPointer currentCount = StackValue.get(CLongPointer.class);\r\n    WinBase.QueryPerformanceCounter(currentCount);\r\n    double current = currentCount.read();\r\n    double freq = performanceFrequency;\r\n    return (long) ((current / freq) * NANOSECS_PER_SEC);\r\n}"
}, {
	"Path": "io.grpc.testing.GrpcServerRule.getServerName",
	"Comment": "returns the randomly generated server name for this service.",
	"Method": "String getServerName(){\r\n    return serverName;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.TruffleLanguage.getLanguageHome",
	"Comment": "returns the home location for this language. this corresponds to the directory in which thejar file is located, if run from a jar file. for an aot compiled binary, this corresponds tothe location of the language files in the default graalvm distribution layout. executable orshared library.",
	"Method": "String getLanguageHome(){\r\n    return AccessAPI.engineAccess().getLanguageHome(AccessAPI.nodesAccess().getEngineObject(languageInfo));\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.AlignedHeapChunk.walkObjectsOfAlignedHeapChunk",
	"Comment": "walk the objects in the given chunk, starting from the first object.",
	"Method": "boolean walkObjectsOfAlignedHeapChunk(AlignedHeader that,ObjectVisitor visitor){\r\n    return walkObjectsFrom(that, getAlignedHeapChunkStart(that), visitor);\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.ClassInitializationFeature.maybeInitializeHosted",
	"Comment": "initializes the class during image building, unless initialization must be delayed toruntime.",
	"Method": "void maybeInitializeHosted(ResolvedJavaType type){\r\n    computeInitKindAndMaybeInitializeClass(toAnalysisType(type).getJavaClass());\r\n}"
}, {
	"Path": "com.oracle.svm.core.posix.PosixUtils.errorString",
	"Comment": "return the error string for the given error number, or a default message.",
	"Method": "String errorString(int errno,String defaultMsg){\r\n    String result = \"\";\r\n    if (errno != 0) {\r\n        result = CTypeConversion.toJavaString(Errno.strerror(errno));\r\n    }\r\n    return result.length() != 0 ? result : defaultMsg;\r\n}"
}, {
	"Path": "com.google.gson.JsonElement.getAsShort",
	"Comment": "convenience method to get this element as a primitive short value.",
	"Method": "short getAsShort(){\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.PinnedAllocatorImpl.pushPinnedAllocatorImpl",
	"Comment": "atomically push this pinnedallocatorimpl on to the global list.",
	"Method": "void pushPinnedAllocatorImpl(){\r\n    VMOperation.guaranteeInProgress(\"PinnedAllocatorImpl.pushPinnedAllocatorImpl but not in VMOperation.\");\r\n    log().string(\"[PinnedAllocatorImpl.pushPinnedAllocatorImpl: \").object(this);\r\n    assert this.next == null : \"PinnedAllocatorImpl.pushPinnedAllocatorImpl but not .next == null.\";\r\n    this.next = HeapImpl.getHeapImpl().pinnedAllocatorListHead;\r\n    HeapImpl.getHeapImpl().pinnedAllocatorListHead = this;\r\n    log().string(\"]\");\r\n}"
}, {
	"Path": "com.google.gson.JsonObject.has",
	"Comment": "convenience method to check if a member with the specified name is present in this object.",
	"Method": "boolean has(String memberName){\r\n    return members.containsKey(memberName);\r\n}"
}, {
	"Path": "io.grpc.MethodDescriptor.toBuilder",
	"Comment": "turns this descriptor into a builder, replacing the request and response marshallers.",
	"Method": "Builder<ReqT, RespT> toBuilder(Builder<NewReqT, NewRespT> toBuilder,Marshaller<NewReqT> requestMarshaller,Marshaller<NewRespT> responseMarshaller){\r\n    return MethodDescriptor.<NewReqT, NewRespT>newBuilder().setRequestMarshaller(requestMarshaller).setResponseMarshaller(responseMarshaller).setType(type).setFullMethodName(fullMethodName).setIdempotent(idempotent).setSafe(safe).setSampledToLocalTracing(sampledToLocalTracing).setSchemaDescriptor(schemaDescriptor);\r\n}"
}, {
	"Path": "com.oracle.truffle.object.ShapeImpl.makeShapeWithPrimitiveExtensionArray",
	"Comment": "create a new shape that reserves the primitive extension array field.",
	"Method": "ShapeImpl makeShapeWithPrimitiveExtensionArray(ShapeImpl parent,Transition transition){\r\n    assert parent.getLayout().hasPrimitiveExtensionArray();\r\n    assert !parent.hasPrimitiveArray();\r\n    BaseAllocator allocator = parent.allocator().addLocation(parent.getLayout().getPrimitiveArrayLocation());\r\n    ShapeImpl newShape = parent.createShape(parent.layout, parent.sharedData, parent, parent.objectType, parent.propertyMap, transition, allocator, parent.id);\r\n    assert newShape.hasPrimitiveArray();\r\n    assert newShape.depth == allocator.depth;\r\n    return newShape;\r\n}"
}, {
	"Path": "io.grpc.testing.integration.MetricsServiceGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "MetricsServiceStub newStub(io.grpc.Channel channel){\r\n    return new MetricsServiceStub(channel);\r\n}"
}, {
	"Path": "org.graalvm.component.installer.model.ComponentRegistryTest.testRemoveComponent",
	"Comment": "test of removecomponent method, of class componentregistry.",
	"Method": "void testRemoveComponent(){\r\n    mockStorage.installed.add(rubyInfo);\r\n    mockStorage.replacedFiles.put(\"jre/bin/ruby\", Arrays.asList(\"org.graalvm.fake\", \"org.graalvm.ruby\"));\r\n    registry.removeComponent(rubyInfo);\r\n    Assert.assertNotEquals(mockStorage.updatedReplacedFiles, mockStorage.replacedFiles);\r\n    assertNull(mockStorage.updatedReplacedFiles.get(\"jre/bin/ruby\"));\r\n}"
}, {
	"Path": "com.google.gson.metrics.BagOfPrimitivesDeserializationBenchmark.timeBagOfPrimitivesDefault",
	"Comment": "benchmark to measure gson performance for deserializing an object",
	"Method": "void timeBagOfPrimitivesDefault(int reps){\r\n    for (int i = 0; i < reps; ++i) {\r\n        gson.fromJson(json, BagOfPrimitives.class);\r\n    }\r\n}"
}, {
	"Path": "io.grpc.internal.Http2Ping.payload",
	"Comment": "returns the expected ping payload for this outstanding operation.",
	"Method": "long payload(){\r\n    return data;\r\n}"
}, {
	"Path": "io.grpc.testing.integration.TestServiceGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "TestServiceStub newStub(io.grpc.Channel channel){\r\n    return new TestServiceStub(channel);\r\n}"
}, {
	"Path": "io.grpc.benchmarks.proto.WorkerServiceGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "WorkerServiceStub newStub(io.grpc.Channel channel){\r\n    return new WorkerServiceStub(channel);\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.annotation.AnnotationSupport.isClassType",
	"Comment": "used to check the type of fields that need special guarding against missing types.",
	"Method": "boolean isClassType(JavaType type,MetaAccessProvider metaAccess){\r\n    return type.getJavaKind() == JavaKind.Object && (type.equals(metaAccess.lookupJavaType(Class.class)) || type.equals(metaAccess.lookupJavaType(Class[].class)));\r\n}"
}, {
	"Path": "com.oracle.truffle.api.TruffleException.getExceptionObject",
	"Comment": "returns an additional guest language object. the return object must be an interop type so itmust be either implementing truffleobject or be a primitive value. the default implementationreturns null to indicate that no object is available for this exception.",
	"Method": "Object getExceptionObject(){\r\n    return null;\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.TypeFlow.addOriginalUse",
	"Comment": "adds a use, if not already present, without propagating state.",
	"Method": "boolean addOriginalUse(BigBang bb,TypeFlow<?> use){\r\n    return addUse(bb, use, false, false);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.ThreadLocalAllocation.tearDown",
	"Comment": "return all allocated virtual memory chunks to heapchunkprovider.",
	"Method": "void tearDown(){\r\n    final IsolateThread thread;\r\n    if (SubstrateOptions.MultiThreaded.getValue()) {\r\n        thread = VMThreads.firstThread();\r\n        VMError.guarantee(VMThreads.nextThread(thread).isNull(), \"Other isolate threads are still active\");\r\n    } else {\r\n        thread = WordFactory.nullPointer();\r\n    }\r\n    freeHeapChunks(regularTLAB.getAddress(thread));\r\n    freeHeapChunks(pinnedTLAB.getAddress(thread));\r\n    HeapChunkProvider.freeAlignedChunkList(freeList.get());\r\n}"
}, {
	"Path": "com.google.gson.GsonBuilder.disableInnerClassSerialization",
	"Comment": "configures gson to exclude inner classes during serialization.",
	"Method": "GsonBuilder disableInnerClassSerialization(){\r\n    excluder = excluder.disableInnerClassSerialization();\r\n    return this;\r\n}"
}, {
	"Path": "io.grpc.internal.FakeClock.numPendingTasks",
	"Comment": "return the number of queued tasks accepted by the given filter.",
	"Method": "int numPendingTasks(int numPendingTasks,TaskFilter filter){\r\n    int count = 0;\r\n    for (ScheduledTask task : dueTasks) {\r\n        if (filter.shouldAccept(task.command)) {\r\n            count++;\r\n        }\r\n    }\r\n    for (ScheduledTask task : scheduledTasks) {\r\n        if (filter.shouldAccept(task.command)) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.google.common.collect.Maps.asEntryToEntryFunction",
	"Comment": "views an entry transformer as a function from entries to entries.",
	"Method": "Function<Entry<K, V1>, Entry<K, V2>> asEntryToEntryFunction(EntryTransformer<? super K, ? super V1, V2> transformer){\r\n    checkNotNull(transformer);\r\n    return new Function<Entry<K, V1>, Entry<K, V2>>() {\r\n        @Override\r\n        public Entry<K, V2> apply(final Entry<K, V1> entry) {\r\n            return transformEntry(transformer, entry);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.google.common.collect.Maps.asEntryToEntryFunction",
	"Comment": "views an entry transformer as a function from entries to entries.",
	"Method": "Function<Entry<K, V1>, Entry<K, V2>> asEntryToEntryFunction(EntryTransformer<? super K, ? super V1, V2> transformer){\r\n    return transformEntry(transformer, entry);\r\n}"
}, {
	"Path": "org.graalvm.component.installer.commands.InstallerTest.testSetReplaceComponents",
	"Comment": "checks that the component will be uninstalled before installing a new one.",
	"Method": "void testSetReplaceComponents(){\r\n    setupComponentInstall(\"truffleruby2.jar\");\r\n    ComponentInfo fakeInfo = new ComponentInfo(\"org.graalvm.ruby\", \"Fake ruby\", \"1.0\");\r\n    storage.installed.add(fakeInfo);\r\n    installer.setReplaceComponents(true);\r\n    installer.validateRequirements();\r\n    installer.install();\r\n}"
}, {
	"Path": "com.oracle.svm.core.hub.LayoutEncoding.getObjectEnd",
	"Comment": "returns the end of the object when the call started, e.g., for logging.",
	"Method": "Pointer getObjectEnd(Object obj){\r\n    final Pointer objStart = Word.objectToUntrackedPointer(obj);\r\n    final UnsignedWord objSize = getSizeFromObject(obj);\r\n    return objStart.add(objSize);\r\n}"
}, {
	"Path": "io.grpc.netty.GrpcSslContexts.configure",
	"Comment": "set ciphers and apn appropriate for grpc. precisely what is set is permitted to change, so ifan application requires particular settings it should override the options set here.",
	"Method": "SslContextBuilder configure(SslContextBuilder builder,SslContextBuilder configure,SslContextBuilder builder,SslProvider provider,SslContextBuilder configure,SslContextBuilder builder,Provider jdkProvider){\r\n    ApplicationProtocolConfig apc;\r\n    if (SUN_PROVIDER_NAME.equals(jdkProvider.getName())) {\r\n        if (JettyTlsUtil.isJettyAlpnConfigured()) {\r\n            apc = ALPN;\r\n        } else if (JettyTlsUtil.isJettyNpnConfigured()) {\r\n            apc = NPN;\r\n        } else if (JettyTlsUtil.isJava9AlpnAvailable()) {\r\n            apc = ALPN;\r\n        } else {\r\n            throw new IllegalArgumentException(SUN_PROVIDER_NAME + \" selected, but Jetty NPN/ALPN unavailable\");\r\n        }\r\n    } else if (isConscrypt(jdkProvider)) {\r\n        apc = ALPN;\r\n    } else {\r\n        throw new IllegalArgumentException(\"Unknown provider; can't configure: \" + jdkProvider);\r\n    }\r\n    return builder.sslProvider(SslProvider.JDK).ciphers(Http2SecurityUtil.CIPHERS, SupportedCipherSuiteFilter.INSTANCE).applicationProtocolConfig(apc).sslContextProvider(jdkProvider);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.AlignedHeapChunk.getAlignedHeapOverhead",
	"Comment": "the overhead of an aligned chunk. all of the overhead is before the start of the objects inthe chunk.",
	"Method": "UnsignedWord getAlignedHeapOverhead(){\r\n    return getObjectsStartOffset();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.nodes.Node.getDebugProperties",
	"Comment": "returns properties of this node interesting for debugging and can be overwritten bysubclasses to add their own custom properties.",
	"Method": "Map<String, Object> getDebugProperties(){\r\n    Map<String, Object> properties = new HashMap();\r\n    return properties;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.DebugException.getThrowLocation",
	"Comment": "get source code location where this exception was thrown from.",
	"Method": "SourceSection getThrowLocation(){\r\n    if (exception instanceof TruffleException) {\r\n        SourceSection location = ((TruffleException) exception).getSourceLocation();\r\n        if (location != null) {\r\n            return location;\r\n        }\r\n    }\r\n    if (throwLocation != null) {\r\n        return throwLocation.getSourceSection();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.impl.TruffleLocator.loadClass",
	"Comment": "utility method to load a class from one of the located classloaders. please note that thismethod is used in tests using reflection. do not remove.",
	"Method": "Class<?> loadClass(String name){\r\n    for (ClassLoader loader : loaders()) {\r\n        if (loader == null) {\r\n            continue;\r\n        }\r\n        try {\r\n            return loader.loadClass(name);\r\n        } catch (ClassNotFoundException ex) {\r\n            continue;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.gson.JsonArray.set",
	"Comment": "replaces the element at the specified position in this array with the specified element.element can be null.",
	"Method": "JsonElement set(int index,JsonElement element){\r\n    return elements.set(index, element);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.nodes.SlowPathException.fillInStackTrace",
	"Comment": "for performance reasons, this exception does not record any stack trace information.",
	"Method": "Throwable fillInStackTrace(){\r\n    return null;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.GCImpl.printGCSummary",
	"Comment": "invoked by a shutdown hook registered in the gcimpl constructor.",
	"Method": "void printGCSummary(){\r\n    if (!SubstrateOptions.PrintGCSummary.getValue()) {\r\n        return;\r\n    }\r\n    final Log log = Log.log();\r\n    final String prefix = \"PrintGCSummary: \";\r\n    log.string(prefix).string(\"YoungGenerationSize: \").unsigned(HeapPolicy.getMaximumYoungGenerationSize()).newline();\r\n    log.string(prefix).string(\"MinimumHeapSize: \").unsigned(HeapPolicy.getMinimumHeapSize()).newline();\r\n    log.string(prefix).string(\"MaximumHeapSize: \").unsigned(HeapPolicy.getMaximumHeapSize()).newline();\r\n    log.string(prefix).string(\"AlignedChunkSize: \").unsigned(HeapPolicy.getAlignedHeapChunkSize()).newline();\r\n    VMOperation.enqueueBlockingSafepoint(\"PrintGCSummaryShutdownHook\", ThreadLocalAllocation::disableThreadLocalAllocation);\r\n    final HeapImpl heap = HeapImpl.getHeapImpl();\r\n    final Space youngSpace = heap.getYoungGeneration().getSpace();\r\n    final UnsignedWord youngChunkBytes = youngSpace.getChunkBytes();\r\n    final UnsignedWord youngObjectBytes = youngSpace.getObjectBytes();\r\n    final Space pinnedSpace = heap.getOldGeneration().getPinnedFromSpace();\r\n    final UnsignedWord pinnedChunkBytes = pinnedSpace.getChunkBytes().subtract(accounting.getPinnedChunkBytesAfter());\r\n    final UnsignedWord pinnedObjectBytes = pinnedSpace.getObjectBytes().subtract(accounting.getPinnedObjectBytesAfter());\r\n    final UnsignedWord allocatedNormalChunkBytes = accounting.getNormalChunkBytes().add(youngChunkBytes);\r\n    final UnsignedWord allocatedNormalObjectBytes = accounting.getNormalObjectBytes().add(youngObjectBytes);\r\n    final UnsignedWord allocatedPinnedChunkBytes = accounting.getPinnedChunkBytes().add(pinnedChunkBytes);\r\n    final UnsignedWord allocatedPinnedObjectBytes = accounting.getPinnedObjectBytes().add(pinnedObjectBytes);\r\n    final UnsignedWord allocatedTotalChunkBytes = allocatedNormalChunkBytes.add(allocatedPinnedChunkBytes);\r\n    final UnsignedWord allocatedTotalObjectBytes = allocatedNormalObjectBytes.add(allocatedPinnedObjectBytes);\r\n    log.string(prefix).string(\"CollectedTotalChunkBytes: \").signed(accounting.getCollectedTotalChunkBytes()).newline();\r\n    log.string(prefix).string(\"CollectedTotalObjectBytes: \").signed(accounting.getCollectedTotalObjectBytes()).newline();\r\n    log.string(prefix).string(\"AllocatedNormalChunkBytes: \").signed(allocatedNormalChunkBytes).newline();\r\n    log.string(prefix).string(\"AllocatedNormalObjectBytes: \").signed(allocatedNormalObjectBytes).newline();\r\n    log.string(prefix).string(\"AllocatedPinnedChunkBytes: \").signed(allocatedPinnedChunkBytes).newline();\r\n    log.string(prefix).string(\"AllocatedPinnedObjectBytes: \").signed(allocatedPinnedObjectBytes).newline();\r\n    log.string(prefix).string(\"AllocatedTotalChunkBytes: \").signed(allocatedTotalChunkBytes).newline();\r\n    log.string(prefix).string(\"AllocatedTotalObjectBytes: \").signed(allocatedTotalObjectBytes).newline();\r\n    final long incrementalNanos = accounting.getIncrementalCollectionTotalNanos();\r\n    log.string(prefix).string(\"IncrementalGCCount: \").signed(accounting.getIncrementalCollectionCount()).newline();\r\n    log.string(prefix).string(\"IncrementalGCNanos: \").signed(incrementalNanos).newline();\r\n    final long completeNanos = accounting.getCompleteCollectionTotalNanos();\r\n    log.string(prefix).string(\"CompleteGCCount: \").signed(accounting.getCompleteCollectionCount()).newline();\r\n    log.string(prefix).string(\"CompleteGCNanos: \").signed(completeNanos).newline();\r\n    final long gcNanos = incrementalNanos + completeNanos;\r\n    final long mutatorNanos = mutatorTimer.getCollectedNanos();\r\n    final long totalNanos = gcNanos + mutatorNanos;\r\n    final long roundedGCLoad = (0 < totalNanos ? TimeUtils.roundedDivide(100 * gcNanos, totalNanos) : 0);\r\n    log.string(prefix).string(\"GCNanos: \").signed(gcNanos).newline();\r\n    log.string(prefix).string(\"TotalNanos: \").signed(totalNanos).newline();\r\n    log.string(prefix).string(\"GCLoadPercent: \").signed(roundedGCLoad).newline();\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.FirstObjectTable.memoryOffsetScale",
	"Comment": "the multiplier from memory offsets to byte offsets into the previous card.this is the granularity to which i can point to the start of an object.",
	"Method": "int memoryOffsetScale(){\r\n    return ConfigurationValues.getObjectLayout().getAlignment();\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.code.RestrictHeapAccessCallees.setAssertionErrorConstructors",
	"Comment": "this gets called multiple times, but i only need one analysismethod to be happy.",
	"Method": "void setAssertionErrorConstructors(List<ResolvedJavaMethod> resolvedConstructorList){\r\n    if (assertionErrorConstructorList.isEmpty()) {\r\n        assertionErrorConstructorList = resolvedConstructorList;\r\n    }\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.context.BytecodeLocation.keyToBci",
	"Comment": "transform the object key into a bci. the bci might be duplicated due to graal methodsubstitutions and inlining. then we use a unique object key.",
	"Method": "int keyToBci(Object key){\r\n    int bci;\r\n    if (key instanceof Integer) {\r\n        bci = (int) key;\r\n        assert bci >= 0 : \"Negative BCI.\";\r\n    } else {\r\n        bci = BytecodeLocation.UNKNOWN_BCI;\r\n    }\r\n    return bci;\r\n}"
}, {
	"Path": "com.google.gson.GsonBuilder.setLenient",
	"Comment": "by default, gson is strict and only accepts json as specified byrfc 4627. this option makes the parserliberal in what it accepts.",
	"Method": "GsonBuilder setLenient(){\r\n    lenient = true;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.gson.JsonArray.getAsFloat",
	"Comment": "convenience method to get this array as a float if it contains a single element.",
	"Method": "float getAsFloat(){\r\n    if (elements.size() == 1) {\r\n        return elements.get(0).getAsFloat();\r\n    }\r\n    throw new IllegalStateException();\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.substitute.AnnotationSubstitutionProcessor.processComputedValueFields",
	"Comment": "eagerly register all target fields of recomputed value fields as unsafe accessed.",
	"Method": "void processComputedValueFields(BigBang bb){\r\n    for (ResolvedJavaField field : fieldSubstitutions.values()) {\r\n        if (field instanceof ComputedValue) {\r\n            ComputedValue cvField = (ComputedValue) field;\r\n            switch(cvField.getRecomputeValueKind()) {\r\n                case FieldOffset:\r\n                    AnalysisField targetField = bb.getMetaAccess().lookupJavaField(cvField.getTargetField());\r\n                    targetField.registerAsAccessed();\r\n                    targetField.registerAsUnsafeAccessed();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.grpc.examples.header.CustomHeaderServer.blockUntilShutdown",
	"Comment": "await termination on the main thread since the grpc library uses daemon threads.",
	"Method": "void blockUntilShutdown(){\r\n    if (server != null) {\r\n        server.awaitTermination();\r\n    }\r\n}"
}, {
	"Path": "io.grpc.grpclb.GrpclbState.handleAddresses",
	"Comment": "handle new addresses of the balancer and backends from the resolver, and create connection ifnot yet connected.",
	"Method": "void handleAddresses(List<LbAddressGroup> newLbAddressGroups,List<EquivalentAddressGroup> newBackendServers){\r\n    if (newLbAddressGroups.isEmpty()) {\r\n        propagateError(Status.UNAVAILABLE.withDescription(\"NameResolver returned no LB address while asking for GRPCLB\"));\r\n        return;\r\n    }\r\n    LbAddressGroup newLbAddressGroup = flattenLbAddressGroups(newLbAddressGroups);\r\n    startLbComm(newLbAddressGroup);\r\n    if (lbStream == null) {\r\n        startLbRpc();\r\n    }\r\n    fallbackBackendList = newBackendServers;\r\n    if (fallbackTimer == null) {\r\n        fallbackTimer = syncContext.schedule(new FallbackModeTask(), FALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS, timerService);\r\n    }\r\n    if (usingFallbackBackends) {\r\n        useFallbackBackends();\r\n    }\r\n    maybeUpdatePicker();\r\n}"
}, {
	"Path": "com.google.gson.metrics.CollectionsDeserializationBenchmark.timeCollectionsDefault",
	"Comment": "benchmark to measure gson performance for deserializing an object",
	"Method": "void timeCollectionsDefault(int reps){\r\n    for (int i = 0; i < reps; ++i) {\r\n        gson.fromJson(json, LIST_TYPE);\r\n    }\r\n}"
}, {
	"Path": "io.grpc.netty.NettyServerBuilder.maxConcurrentCallsPerConnection",
	"Comment": "the maximum number of concurrent calls permitted for each incoming connection. defaults to nolimit.",
	"Method": "NettyServerBuilder maxConcurrentCallsPerConnection(int maxCalls){\r\n    checkArgument(maxCalls > 0, \"max must be positive: %s\", maxCalls);\r\n    this.maxConcurrentCallsPerConnection = maxCalls;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.testRegisteredDeserializerOverridesJsonAdapter",
	"Comment": "the deserializer overrides json adapter, but for serializer the jsonadapter is used.",
	"Method": "void testRegisteredDeserializerOverridesJsonAdapter(){\r\n    JsonDeserializer<A> deserializer = new JsonDeserializer<A>() {\r\n        public A deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\r\n            return new A(\"registeredDeserializer\");\r\n        }\r\n    };\r\n    Gson gson = new GsonBuilder().registerTypeAdapter(A.class, deserializer).create();\r\n    String json = gson.toJson(new A(\"abcd\"));\r\n    assertEquals(\"\\\"jsonAdapter\\\"\", json);\r\n    A target = gson.fromJson(\"abcd\", A.class);\r\n    assertEquals(\"registeredDeserializer\", target.value);\r\n}"
}, {
	"Path": "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest.testRegisteredDeserializerOverridesJsonAdapter",
	"Comment": "the deserializer overrides json adapter, but for serializer the jsonadapter is used.",
	"Method": "void testRegisteredDeserializerOverridesJsonAdapter(){\r\n    return new A(\"registeredDeserializer\");\r\n}"
}, {
	"Path": "io.grpc.okhttp.internal.framed.Http2.newReader",
	"Comment": "creates a frame reader with max header table size of 4096 and data framecompression disabled.",
	"Method": "FrameReader newReader(BufferedSource source,boolean client){\r\n    return new Reader(source, 4096, client);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.FirstObjectTable.indexMinusDelta",
	"Comment": "compute a delta from an index, carefully staying in unsigned.",
	"Method": "UnsignedWord indexMinusDelta(UnsignedWord index,UnsignedWord delta){\r\n    assert delta.belowOrEqual(index) : \"Delta out of bounds.\";\r\n    return index.subtract(delta);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.Breakpoint.getCondition",
	"Comment": "returns the expression used to create the current breakpoint condition, null if no conditionset.",
	"Method": "String getCondition(String getCondition){\r\n    return condition;\r\n}"
}, {
	"Path": "io.grpc.alts.internal.AltsHandshakerClient.handleResponse",
	"Comment": "parses a handshake response, setting the status, result, and closing the handshaker, as needed.",
	"Method": "void handleResponse(HandshakerResp resp){\r\n    status = resp.getStatus();\r\n    if (resp.hasResult()) {\r\n        result = resp.getResult();\r\n        close();\r\n    }\r\n    if (status.getCode() != Status.Code.OK.value()) {\r\n        String error = \"Handshaker service error: \" + status.getDetails();\r\n        logger.log(Level.INFO, error);\r\n        close();\r\n        throw new GeneralSecurityException(error);\r\n    }\r\n}"
}, {
	"Path": "io.grpc.DecompressorRegistry.getKnownMessageEncodings",
	"Comment": "provides a list of all message encodings that have decompressors available.",
	"Method": "Set<String> getKnownMessageEncodings(){\r\n    return decompressors.keySet();\r\n}"
}, {
	"Path": "com.google.gson.internal.UnsafeAllocatorInstantiationTest.testConcreteClassInstantiation",
	"Comment": "ensure that no exception is thrown when trying to instantiate a concrete class",
	"Method": "void testConcreteClassInstantiation(){\r\n    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\r\n    try {\r\n        unsafeAllocator.newInstance(ConcreteClass.class);\r\n    } catch (Exception e) {\r\n        fail();\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.TruffleFile.isExecutable",
	"Comment": "tests if a file is executable. checks if the file exists and this java virtual machine hasenough privileges to execute the file.",
	"Method": "boolean isExecutable(){\r\n    try {\r\n        return checkAccess(AccessMode.EXECUTE);\r\n    } catch (SecurityException se) {\r\n        throw se;\r\n    } catch (Throwable t) {\r\n        throw wrapHostException(t);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.test.polyglot.PolyglotCachingTest.testSourceFreeContextStrong",
	"Comment": "test that if the context is strongly referenced and the source reference is freed the gc cancollect the source together with the cached calltargets.",
	"Method": "void testSourceFreeContextStrong(){\r\n    Assume.assumeFalse(\"This test is too slow in fastdebug.\", System.getProperty(\"java.vm.version\").contains(\"fastdebug\"));\r\n    setupTestLang(false);\r\n    Context survivingContext = Context.create();\r\n    GCUtils.assertObjectsCollectible((iteration) -> {\r\n        Source source = Source.create(ProxyLanguage.ID, String.valueOf(iteration));\r\n        CallTarget target = assertParsedEval(survivingContext, source);\r\n        assertCachedEval(survivingContext, source);\r\n        return target;\r\n    });\r\n    survivingContext.close();\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.FirstObjectTable.initializeTableToPointer",
	"Comment": "initialize a first object table from tablestart to tablelimit.",
	"Method": "Pointer initializeTableToPointer(Pointer table,Pointer tableLimit){\r\n    final UnsignedWord indexLimit = FirstObjectTable.tableOffsetToIndex(tableLimit.subtract(table));\r\n    return FirstObjectTable.initializeTableToIndex(table, indexLimit);\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.image.RelocatableBuffer.addDirectRelocationWithAddend",
	"Comment": "in the future, this could be used for any offset from a relocated object reference.",
	"Method": "RelocatableBuffer.Info addDirectRelocationWithAddend(int key,int relocationSize,Long explicitAddend,Object targetObject){\r\n    final RelocatableBuffer.Info info = infoFactory(ObjectFile.RelocationKind.DIRECT, relocationSize, explicitAddend, targetObject);\r\n    final RelocatableBuffer.Info result = putInfo(key, info);\r\n    return result;\r\n}"
}, {
	"Path": "io.grpc.alts.internal.TsiHandshakeHandler.sendHandshake",
	"Comment": "sends as many bytes as are available from the handshaker to the remote peer.",
	"Method": "void sendHandshake(ChannelHandlerContext ctx){\r\n    boolean needToFlush = false;\r\n    while (true) {\r\n        buffer = getOrCreateBuffer(ctx.alloc());\r\n        try {\r\n            handshaker.getBytesToSendToPeer(buffer);\r\n        } catch (GeneralSecurityException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        if (!buffer.isReadable()) {\r\n            break;\r\n        }\r\n        needToFlush = true;\r\n        @SuppressWarnings(\"unused\")\r\n        Future<?> possiblyIgnoredError = ctx.write(buffer);\r\n        buffer = null;\r\n    }\r\n    if (needToFlush) {\r\n        ctx.flush();\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.metrics.PerformanceTest.disabled_testByteArraySerialization",
	"Comment": "last i tested, gson was able to serialize upto 14mb byte array",
	"Method": "void disabled_testByteArraySerialization(){\r\n    for (int size = 4145152; true; size += 1036288) {\r\n        byte[] ba = new byte[size];\r\n        for (int i = 0; i < size; ++i) {\r\n            ba[i] = 0x05;\r\n        }\r\n        gson.toJson(ba);\r\n        System.out.printf(\"Gson could serialize a byte array of size: %d\\n\", size);\r\n    }\r\n}"
}, {
	"Path": "io.grpc.testing.integration.AbstractInteropTest.serverCompressedUnary",
	"Comment": "tests if the server can send a compressed unary response. ideally we would assert that theresponses have the requested compression, but this is not supported by the api. given acompliant server, this test will exercise the code path for receiving a compressed response butcannot itself verify that the response was compressed.",
	"Method": "void serverCompressedUnary(){\r\n    assumeEnoughMemory();\r\n    final SimpleRequest responseShouldBeCompressed = SimpleRequest.newBuilder().setResponseCompressed(BoolValue.newBuilder().setValue(true)).setResponseSize(314159).setPayload(Payload.newBuilder().setBody(ByteString.copyFrom(new byte[271828]))).build();\r\n    final SimpleRequest responseShouldBeUncompressed = SimpleRequest.newBuilder().setResponseCompressed(BoolValue.newBuilder().setValue(false)).setResponseSize(314159).setPayload(Payload.newBuilder().setBody(ByteString.copyFrom(new byte[271828]))).build();\r\n    final SimpleResponse goldenResponse = SimpleResponse.newBuilder().setPayload(Payload.newBuilder().setBody(ByteString.copyFrom(new byte[314159]))).build();\r\n    assertResponse(goldenResponse, blockingStub.unaryCall(responseShouldBeCompressed));\r\n    assertStatsTrace(\"grpc.testing.TestService/UnaryCall\", Status.Code.OK, Collections.singleton(responseShouldBeCompressed), Collections.singleton(goldenResponse));\r\n    assertResponse(goldenResponse, blockingStub.unaryCall(responseShouldBeUncompressed));\r\n    assertStatsTrace(\"grpc.testing.TestService/UnaryCall\", Status.Code.OK, Collections.singleton(responseShouldBeUncompressed), Collections.singleton(goldenResponse));\r\n}"
}, {
	"Path": "com.oracle.truffle.tools.profiler.StackTraceEntry.isCompiled",
	"Comment": "returns true if this stack entry was executed in compiled mode at the time whenthe stack trace was captured, else false.",
	"Method": "boolean isCompiled(){\r\n    return state == STATE_COMPILED || state == STATE_COMPILATION_ROOT;\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.flow.context.object.ContextSensitiveAnalysisObject.noteMerge",
	"Comment": "the object has been in contact with an context insensitive object in an union operation.",
	"Method": "void noteMerge(BigBang bb){\r\n    assert bb.analysisPolicy().isMergingEnabled();\r\n    if (!merged) {\r\n        super.noteMerge(bb);\r\n        if (this.type.isArray()) {\r\n            if (this.isObjectArray()) {\r\n                mergeArrayElementsFlow(bb);\r\n            }\r\n        } else {\r\n            mergeInstanceFieldsFlows(bb);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.frame.FrameDescriptor.updateVersion",
	"Comment": "invalidates the current, and create a new version assumption.",
	"Method": "void updateVersion(){\r\n    invalidateVersion(this);\r\n    newVersion(this);\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.runtime.debug.value.LLVMDebugObject.getValue",
	"Comment": "return an object that represents the value of the referenced variable.",
	"Method": "Object getValue(){\r\n    if (value == null) {\r\n        return \"\";\r\n    } else {\r\n        return getValueSafe();\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.Space.promoteAlignedHeapChunk",
	"Comment": "promote an alignedheapchunk by moving it to this space, if necessary.",
	"Method": "boolean promoteAlignedHeapChunk(AlignedHeapChunk.AlignedHeader aChunk){\r\n    final Log trace = Log.noopLog();\r\n    trace.string(\"[SpaceImpl.promoteCardRememberedSetAlignedObjectChunk:\");\r\n    trace.string(\"  aChunk: \").hex(aChunk);\r\n    final Space originalSpace = aChunk.getSpace();\r\n    final boolean promote = (this != originalSpace);\r\n    if (promote) {\r\n        originalSpace.extractAlignedHeapChunk(aChunk);\r\n        appendAlignedHeapChunk(aChunk);\r\n        if (HeapImpl.getHeapImpl().isYoungGeneration(originalSpace)) {\r\n            trace.string(\"  setting up remembered set\");\r\n            AlignedHeapChunk.constructRememberedSetOfAlignedHeapChunk(aChunk);\r\n        }\r\n    }\r\n    trace.string(\"  returns: \").bool(promote).string(\"]\").newline();\r\n    return promote;\r\n}"
}, {
	"Path": "io.grpc.internal.MessageDeframer.processHeader",
	"Comment": "processes the grpc compression header which is composed of the compression flag and the outerframe length.",
	"Method": "void processHeader(){\r\n    int type = nextFrame.readUnsignedByte();\r\n    if ((type & RESERVED_MASK) != 0) {\r\n        throw Status.INTERNAL.withDescription(\"gRPC frame header malformed: reserved bits not zero\").asRuntimeException();\r\n    }\r\n    compressedFlag = (type & COMPRESSED_FLAG_MASK) != 0;\r\n    requiredLength = nextFrame.readInt();\r\n    if (requiredLength < 0 || requiredLength > maxInboundMessageSize) {\r\n        throw Status.RESOURCE_EXHAUSTED.withDescription(String.format(\"gRPC message exceeds maximum size %d: %d\", maxInboundMessageSize, requiredLength)).asRuntimeException();\r\n    }\r\n    currentMessageSeqNo++;\r\n    statsTraceCtx.inboundMessage(currentMessageSeqNo);\r\n    transportTracer.reportMessageReceived();\r\n    state = State.BODY;\r\n}"
}, {
	"Path": "io.grpc.netty.NettyHandlerTestBase.initChannel",
	"Comment": "must be called by subclasses to initialize the handler and channel.",
	"Method": "void initChannel(Http2HeadersDecoder headersDecoder){\r\n    content = Unpooled.copiedBuffer(\"hello world\", UTF_8);\r\n    frameWriter = mock(Http2FrameWriter.class, delegatesTo(new DefaultHttp2FrameWriter()));\r\n    frameReader = new DefaultHttp2FrameReader(headersDecoder);\r\n    channel = new FakeClockSupportedChanel();\r\n    handler = newHandler();\r\n    channel.pipeline().addLast(handler);\r\n    ctx = channel.pipeline().context(handler);\r\n    writeQueue = initWriteQueue();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.TruffleFile.isReadable",
	"Comment": "tests if a file is readable. checks if the file exists and this java virtual machine hasenough privileges to read the file.",
	"Method": "boolean isReadable(){\r\n    try {\r\n        return checkAccess(AccessMode.READ);\r\n    } catch (SecurityException se) {\r\n        throw se;\r\n    } catch (Throwable t) {\r\n        throw wrapHostException(t);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.jdk8.zipfile.ZipEntry.getCompressedSize",
	"Comment": "returns the size of the compressed entry data. in the case of a stored entry, the compressed size will be the sameas the uncompressed size of the entry.",
	"Method": "long getCompressedSize(){\r\n    return csize;\r\n}"
}, {
	"Path": "com.oracle.truffle.tools.profiler.StackTraceEntry.toStackTraceElement",
	"Comment": "converts the stack trace entry to a java stack trace element. no guarantees are providedabout the format of the stack trace element. the format of the stack trace element may changewithout notice.",
	"Method": "StackTraceElement toStackTraceElement(){\r\n    StackTraceElement stack = this.stackTraceElement;\r\n    if (stack != null) {\r\n        return stack;\r\n    }\r\n    LanguageInfo languageInfo = getInstrumentedNode().getRootNode().getLanguageInfo();\r\n    String declaringClass;\r\n    if (languageInfo != null) {\r\n        declaringClass = languageInfo.getId();\r\n    } else {\r\n        declaringClass = \"\";\r\n    }\r\n    SourceSection sourceLocation = getSourceSection();\r\n    String methodName = rootName == null ? \"\" : rootName;\r\n    if (!tags.contains(StandardTags.RootTag.class)) {\r\n        methodName += \"~\" + formatIndices(sourceSection, true);\r\n    }\r\n    String fileName = formatFileName();\r\n    int startLine = sourceLocation != null ? sourceLocation.getStartLine() : -1;\r\n    return this.stackTraceElement = new StackTraceElement(declaringClass, methodName, fileName, startLine);\r\n}"
}, {
	"Path": "com.google.gson.Gson.newJsonWriter",
	"Comment": "returns a new json writer configured for the settings on this gson instance.",
	"Method": "JsonWriter newJsonWriter(Writer writer){\r\n    if (generateNonExecutableJson) {\r\n        writer.write(JSON_NON_EXECUTABLE_PREFIX);\r\n    }\r\n    JsonWriter jsonWriter = new JsonWriter(writer);\r\n    if (prettyPrinting) {\r\n        jsonWriter.setIndent(\"  \");\r\n    }\r\n    jsonWriter.setSerializeNulls(serializeNulls);\r\n    return jsonWriter;\r\n}"
}, {
	"Path": "io.grpc.CallOptions.withOption",
	"Comment": "sets a custom option. any existing value for the key is overwritten.",
	"Method": "CallOptions withOption(Key<T> key,T value){\r\n    Preconditions.checkNotNull(key, \"key\");\r\n    Preconditions.checkNotNull(value, \"value\");\r\n    CallOptions newOptions = new CallOptions(this);\r\n    int existingIdx = -1;\r\n    for (int i = 0; i < customOptions.length; i++) {\r\n        if (key.equals(customOptions[i][0])) {\r\n            existingIdx = i;\r\n            break;\r\n        }\r\n    }\r\n    newOptions.customOptions = new Object[customOptions.length + (existingIdx == -1 ? 1 : 0)][2];\r\n    System.arraycopy(customOptions, 0, newOptions.customOptions, 0, customOptions.length);\r\n    if (existingIdx == -1) {\r\n        newOptions.customOptions[customOptions.length] = new Object[] { key, value };\r\n    } else {\r\n        newOptions.customOptions[existingIdx][1] = value;\r\n    }\r\n    return newOptions;\r\n}"
}, {
	"Path": "org.graalvm.component.installer.commands.CatalogInstallTest.testRejectMetaDontDownloadPackage",
	"Comment": "checks that mismatched version is rejected based on catalog metadata, and the component urlis not opened at all.",
	"Method": "void testRejectMetaDontDownloadPackage(){\r\n    setupVersion(\"0.33-dev\");\r\n    URL rubyURL = new URL(\"test://release/graalvm-ruby.zip\");\r\n    Handler.bind(rubyURL.toString(), new URLConnection(rubyURL) {\r\n        @Override\r\n        public void connect() throws IOException {\r\n            throw new UnsupportedOperationException(\"Should not be touched\");\r\n        }\r\n    });\r\n    exception.expect(DependencyException.Mismatch.class);\r\n    exception.expectMessage(\"VERIFY_Dependency_Failed\");\r\n    setupCatalog(null);\r\n    paramIterable = new CatalogIterable(this, this, downloader);\r\n    textParams.add(\"ruby\");\r\n    InstallCommand cmd = new InstallCommand();\r\n    cmd.init(this, withBundle(InstallCommand.class));\r\n    cmd.execute();\r\n}"
}, {
	"Path": "org.graalvm.component.installer.commands.CatalogInstallTest.testRejectMetaDontDownloadPackage",
	"Comment": "checks that mismatched version is rejected based on catalog metadata, and the component urlis not opened at all.",
	"Method": "void testRejectMetaDontDownloadPackage(){\r\n    throw new UnsupportedOperationException(\"Should not be touched\");\r\n}"
}, {
	"Path": "io.grpc.ContextsTest.statusFromCancelled_StatusUnknownShouldWork",
	"Comment": "this is a whitebox test, to verify a special case of the implementation.",
	"Method": "void statusFromCancelled_StatusUnknownShouldWork(){\r\n    Context.CancellableContext cancellableContext = Context.current().withCancellation();\r\n    Exception e = Status.UNKNOWN.asException();\r\n    cancellableContext.cancel(e);\r\n    assertTrue(cancellableContext.isCancelled());\r\n    Status status = statusFromCancelled(cancellableContext);\r\n    assertNotNull(status);\r\n    assertEquals(Status.Code.UNKNOWN, status.getCode());\r\n    assertSame(e, status.getCause());\r\n}"
}, {
	"Path": "com.google.gson.GsonBuilder.setPrettyPrinting",
	"Comment": "configures gson to output json that fits in a page for pretty printing. this option onlyaffects json serialization.",
	"Method": "GsonBuilder setPrettyPrinting(){\r\n    prettyPrinting = true;\r\n    return this;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.ObjectHeaderImpl.readHeaderBitsFromObjectCarefully",
	"Comment": "this method reads the header from the object and returns the header bits.",
	"Method": "UnsignedWord readHeaderBitsFromObjectCarefully(Object o){\r\n    final UnsignedWord header = readHeaderFromObjectCarefully(o);\r\n    return ObjectHeaderImpl.getHeaderBitsFromHeaderCarefully(header);\r\n}"
}, {
	"Path": "com.google.gson.GsonBuilder.serializeNulls",
	"Comment": "configure gson to serialize null fields. by default, gson omits all fields that are nullduring serialization.",
	"Method": "GsonBuilder serializeNulls(){\r\n    this.serializeNulls = true;\r\n    return this;\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.meta.AnalysisType.registerUnsafeAccessedField",
	"Comment": "add the field to the collection of unsafe accessed fields declared by this type.a field can potentially be registered as unsafe accessed multiple times, depending on thefeature implementation, but we add it to the partition only once, when it is first accessed.this is controlled by the isunsafeaccessed flag in the analysfield. also, a field cannot bepart of more than one partitions.",
	"Method": "void registerUnsafeAccessedField(AnalysisField field,UnsafePartitionKind partitionKind){\r\n    unsafeAccessedFieldsRegistered = true;\r\n    if (unsafeAccessedFields == null) {\r\n        UNSAFE_ACCESS_FIELDS_UPDATER.compareAndSet(this, null, new ConcurrentHashMap());\r\n    }\r\n    Collection<AnalysisField> unsafePartition = unsafeAccessedFields.get(partitionKind);\r\n    if (unsafePartition == null) {\r\n        Collection<AnalysisField> newPartition = new ConcurrentLinkedQueue();\r\n        Collection<AnalysisField> oldPartition = unsafeAccessedFields.putIfAbsent(partitionKind, newPartition);\r\n        unsafePartition = oldPartition != null ? oldPartition : newPartition;\r\n    }\r\n    assert !unsafePartition.contains(field) : \"Field \" + field + \" already registered as unsafe accessed with \" + this;\r\n    unsafePartition.add(field);\r\n}"
}, {
	"Path": "com.oracle.svm.core.thread.Safepoint.checkSafepointRequested",
	"Comment": "check if a safepoint has been requested, and block if it is requested.can only be called from snippets. the fast path is inlined, the slow path is a method call.",
	"Method": "void checkSafepointRequested(){\r\n    final boolean needSlowPath = SafepointCheckNode.test();\r\n    if (BranchProbabilityNode.probability(BranchProbabilityNode.VERY_SLOW_PATH_PROBABILITY, needSlowPath)) {\r\n        callSlowPathSafepointCheck(ENTER_SLOW_PATH_SAFEPOINT_CHECK);\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.JsonArray.getAsDouble",
	"Comment": "convenience method to get this array as a double if it contains a single element.",
	"Method": "double getAsDouble(){\r\n    if (elements.size() == 1) {\r\n        return elements.get(0).getAsDouble();\r\n    }\r\n    throw new IllegalStateException();\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.image.NativeImageHeap.addObjectToBootImageHeap",
	"Comment": "it has been determined that an object should be added to the model of the native image heap.this is the mechanics of recursively adding the object and all its fields and array elementsto the model of the native image heap.",
	"Method": "void addObjectToBootImageHeap(Object object,boolean immutableFromParent,int identityHashCode,Object reason){\r\n    final Optional<HostedType> optionalType = getMetaAccess().optionalLookupJavaType(object.getClass());\r\n    if (!optionalType.isPresent() || !optionalType.get().isInstantiated()) {\r\n        throw UserError.abort(\"Image heap writing found an object whose class was not seen as instantiated during static analysis. \" + \"Did a static field or an object referenced from a static field changed during native image generation? \" + \"For example, a lazily initialized cache could have been initialized during image generation, \" + \"in which case you need to force eager initialization of the cache before static analysis or reset the cache using a field value recomputation.\\n\" + \"  object: \" + object + \"  of class: \" + object.getClass().getTypeName() + \"\\n\" + \"  reachable through:\\n\" + fillReasonStack(new StringBuilder(), reason));\r\n    }\r\n    final HostedType type = optionalType.get();\r\n    final DynamicHub hub = type.getHub();\r\n    final ObjectInfo info;\r\n    boolean immutable = immutableFromParent || isImmutable(object);\r\n    boolean written = false;\r\n    boolean references = false;\r\n    boolean relocatable = false;\r\n    if (type.isInstanceClass()) {\r\n        final HostedInstanceClass clazz = (HostedInstanceClass) type;\r\n        if (clazz.getMonitorFieldOffset() != 0) {\r\n            immutable = false;\r\n            written = true;\r\n            references = true;\r\n        }\r\n        final JavaConstant con = SubstrateObjectConstant.forObject(object);\r\n        HostedField hybridBitsetField = null;\r\n        HostedField hybridArrayField = null;\r\n        Object hybridArray = null;\r\n        final long size;\r\n        if (HybridLayout.isHybrid(clazz)) {\r\n            HybridLayout<?> hybridLayout = hybridLayouts.get(clazz);\r\n            if (hybridLayout == null) {\r\n                hybridLayout = new HybridLayout(clazz, layout);\r\n                hybridLayouts.put(clazz, hybridLayout);\r\n            }\r\n            hybridBitsetField = hybridLayout.getBitsetField();\r\n            if (hybridBitsetField != null) {\r\n                Object bitSet = readObjectField(hybridBitsetField, con);\r\n                if (bitSet != null) {\r\n                    blacklist.add(bitSet);\r\n                }\r\n            }\r\n            hybridArrayField = hybridLayout.getArrayField();\r\n            hybridArray = readObjectField(hybridArrayField, con);\r\n            if (hybridArray != null) {\r\n                blacklist.add(hybridArray);\r\n                written = true;\r\n            }\r\n            size = hybridLayout.getTotalSize(Array.getLength(hybridArray));\r\n        } else {\r\n            size = LayoutEncoding.getInstanceSize(hub.getLayoutEncoding()).rawValue();\r\n        }\r\n        info = addToImageHeap(object, clazz, size, identityHashCode, reason);\r\n        recursiveAddObject(hub, false, info);\r\n        final boolean fieldsAreImmutable = object instanceof String;\r\n        for (HostedField field : clazz.getInstanceFields(true)) {\r\n            if (field.isAccessed() && !field.equals(hybridArrayField) && !field.equals(hybridBitsetField)) {\r\n                boolean fieldRelocatable = false;\r\n                if (field.getJavaKind() == JavaKind.Object) {\r\n                    assert field.hasLocation();\r\n                    JavaConstant fieldValueConstant = field.readValue(con);\r\n                    if (fieldValueConstant.getJavaKind() == JavaKind.Object) {\r\n                        Object fieldValue = SubstrateObjectConstant.asObject(fieldValueConstant);\r\n                        if (spawnIsolates()) {\r\n                            fieldRelocatable = fieldValue instanceof RelocatedPointer;\r\n                        }\r\n                        recursiveAddObject(fieldValue, fieldsAreImmutable, info);\r\n                        references = true;\r\n                    }\r\n                }\r\n                relocatable = relocatable || fieldRelocatable;\r\n                written = written || (field.isWritten() && !field.isFinal() && !fieldRelocatable);\r\n            }\r\n        }\r\n        if (hybridArray instanceof Object[]) {\r\n            relocatable = addArrayElements((Object[]) hybridArray, relocatable, info);\r\n            references = true;\r\n        }\r\n    } else if (type.isArray()) {\r\n        HostedArrayClass clazz = (HostedArrayClass) type;\r\n        final long size = layout.getArraySize(type.getComponentType().getStorageKind(), Array.getLength(object));\r\n        info = addToImageHeap(object, clazz, size, identityHashCode, reason);\r\n        recursiveAddObject(hub, false, info);\r\n        if (object instanceof Object[]) {\r\n            relocatable = addArrayElements((Object[]) object, false, info);\r\n            references = true;\r\n        }\r\n        written = true;\r\n    } else {\r\n        throw shouldNotReachHere();\r\n    }\r\n    final HeapPartition partition = choosePartition(!written || immutable, references, relocatable);\r\n    info.assignToHeapPartition(partition, layout);\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.test.BaseSuiteHarness.getInputArgs",
	"Comment": "this function is used to look up the array of string arguments to be used to run a givenbinary. subclasses should override this to provide their own arguments.",
	"Method": "String[] getInputArgs(Path executable){\r\n    return new String[] {};\r\n}"
}, {
	"Path": "io.grpc.testing.DeadlineSubject.isWithin",
	"Comment": "prepares for a check that the subject is deadline within the given tolerance of anexpected value that will be provided in the next call in the fluent chain.",
	"Method": "TolerantDeadlineComparison isWithin(long delta,TimeUnit timeUnit){\r\n    return new TolerantDeadlineComparison() {\r\n        @Override\r\n        public void of(Deadline expected) {\r\n            Deadline actual = actual();\r\n            checkNotNull(actual, \"actual value cannot be null. expected=%s\", expected);\r\n            BigInteger actualTimeRemaining = BigInteger.valueOf(actual.timeRemaining(NANOSECONDS));\r\n            BigInteger expectedTimeRemaining = BigInteger.valueOf(expected.timeRemaining(NANOSECONDS));\r\n            BigInteger deltaNanos = BigInteger.valueOf(timeUnit.toNanos(delta));\r\n            if (actualTimeRemaining.subtract(expectedTimeRemaining).abs().compareTo(deltaNanos) > 0) {\r\n                failWithoutActual(simpleFact(lenientFormat(\"%s and <%s> should have been within <%sns> of each other\", actualAsString(), expected, deltaNanos)));\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.grpc.testing.DeadlineSubject.isWithin",
	"Comment": "prepares for a check that the subject is deadline within the given tolerance of anexpected value that will be provided in the next call in the fluent chain.",
	"Method": "TolerantDeadlineComparison isWithin(long delta,TimeUnit timeUnit){\r\n    Deadline actual = actual();\r\n    checkNotNull(actual, \"actual value cannot be null. expected=%s\", expected);\r\n    BigInteger actualTimeRemaining = BigInteger.valueOf(actual.timeRemaining(NANOSECONDS));\r\n    BigInteger expectedTimeRemaining = BigInteger.valueOf(expected.timeRemaining(NANOSECONDS));\r\n    BigInteger deltaNanos = BigInteger.valueOf(timeUnit.toNanos(delta));\r\n    if (actualTimeRemaining.subtract(expectedTimeRemaining).abs().compareTo(deltaNanos) > 0) {\r\n        failWithoutActual(simpleFact(lenientFormat(\"%s and <%s> should have been within <%sns> of each other\", actualAsString(), expected, deltaNanos)));\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.graal.hosted.GraalObjectReplacer.updateSubstrateDataAfterCompilation",
	"Comment": "updates all relevant data from universe building. object replacement is done during analysis.therefore all substrate vm related data has to be updated after building the substrateuniverse.",
	"Method": "void updateSubstrateDataAfterCompilation(HostedUniverse hUniverse){\r\n    for (Map.Entry<AnalysisType, SubstrateType> entry : types.entrySet()) {\r\n        AnalysisType aType = entry.getKey();\r\n        SubstrateType sType = entry.getValue();\r\n        if (!hUniverse.contains(aType)) {\r\n            continue;\r\n        }\r\n        HostedType hType = hUniverse.lookup(aType);\r\n        DynamicHub uniqueImplementation = null;\r\n        if (hType.getUniqueConcreteImplementation() != null) {\r\n            uniqueImplementation = hType.getUniqueConcreteImplementation().getHub();\r\n        }\r\n        sType.setTypeCheckData(hType.getInstanceOfFromTypeID(), hType.getInstanceOfNumTypeIDs(), uniqueImplementation);\r\n        if (sType.getInstanceFieldCount() > 1) {\r\n            sType.setRawAllInstanceFields(createAllInstanceFields(hType));\r\n        }\r\n    }\r\n    for (Map.Entry<AnalysisField, SubstrateField> entry : fields.entrySet()) {\r\n        AnalysisField aField = entry.getKey();\r\n        SubstrateField sField = entry.getValue();\r\n        HostedField hField = hUniverse.lookup(aField);\r\n        sField.setSubstrateData(hField.getLocation(), hField.isAccessed(), hField.isWritten(), hField.getConstantValue());\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.nodes.expression.SLLogicalAndNode.isEvaluateRight",
	"Comment": "the right value does not need to be evaluated if the left value is already false",
	"Method": "boolean isEvaluateRight(boolean left){\r\n    return left;\r\n}"
}, {
	"Path": "io.grpc.alts.internal.RpcProtocolVersionsUtil.isGreaterThanOrEqualTo",
	"Comment": "returns true if first rpc protocol version is greater than or equal to the second one. returnsfalse otherwise.",
	"Method": "boolean isGreaterThanOrEqualTo(Version first,Version second){\r\n    if ((first.getMajor() > second.getMajor()) || (first.getMajor() == second.getMajor() && first.getMinor() >= second.getMinor())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.google.gson.functional.ObjectTest.testClassWithObjectFieldSerialization",
	"Comment": "tests that a class field with type object can be serialized properly.see issue 54",
	"Method": "void testClassWithObjectFieldSerialization(){\r\n    ClassWithObjectField obj = new ClassWithObjectField();\r\n    obj.member = \"abc\";\r\n    String json = gson.toJson(obj);\r\n    assertTrue(json.contains(\"abc\"));\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.StreamingResponseBandwidthBenchmark.main",
	"Comment": "useful for triggering a subset of the benchmark in a profiler.",
	"Method": "void main(String[] argv){\r\n    StreamingResponseBandwidthBenchmark bench = new StreamingResponseBandwidthBenchmark();\r\n    bench.setup();\r\n    Thread.sleep(30000);\r\n    bench.teardown();\r\n    System.exit(0);\r\n}"
}, {
	"Path": "com.oracle.truffle.tools.profiler.CPUSampler.setDelay",
	"Comment": "sets the delay period i.e. the time that is allowed to pass between when the first samplewould have been taken and when the sampler actually starts taking samples.",
	"Method": "void setDelay(long delay){\r\n    enterChangeConfig();\r\n    this.delay = delay;\r\n}"
}, {
	"Path": "io.grpc.alts.AltsServerBuilder.enableUntrustedAltsForTesting",
	"Comment": "enables untrusted alts for testing. if this function is called, we will not check whether altsis running on google cloud platform.",
	"Method": "AltsServerBuilder enableUntrustedAltsForTesting(){\r\n    enableUntrustedAlts = true;\r\n    return this;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.frame.FrameDescriptor.getIdentifiers",
	"Comment": "retrieve the current set of all the identifiers associated with this frame descriptor.further changes are not reflected in the returned collection.",
	"Method": "Set<Object> getIdentifiers(){\r\n    CompilerAsserts.neverPartOfCompilation(NEVER_PART_OF_COMPILATION_MESSAGE);\r\n    synchronized (lock) {\r\n        return unmodifiableSetFromEconomicMap(EconomicMap.create(identifierToSlotMap));\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.Debugger.find",
	"Comment": "finds the debugger associated with a given instrument environment.",
	"Method": "Debugger find(TruffleInstrument.Env env,Debugger find,Engine engine,Debugger find,TruffleLanguage.Env env){\r\n    return env.lookup(env.getInstruments().get(\"debugger\"), Debugger.class);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.PinnedObjectImpl.close",
	"Comment": "releases the pin for the object. after this call, the object can be moved or discarded by thecollector.",
	"Method": "void close(){\r\n    assert open : \"Should not call close() on a closed PinnedObject.\";\r\n    open = false;\r\n}"
}, {
	"Path": "com.google.gson.JsonElement.isJsonObject",
	"Comment": "provides check for verifying if this element is a json object or not.",
	"Method": "boolean isJsonObject(){\r\n    return this instanceof JsonObject;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.UnalignedHeapChunk.verifyOnlyCleanCardsOfUnalignedHeapChunk",
	"Comment": "verify that there are only clean cards in the remembered set of the given chunk.",
	"Method": "boolean verifyOnlyCleanCardsOfUnalignedHeapChunk(UnalignedHeader that){\r\n    final Log trace = Log.noopLog().string(\"[UnalignedHeapChunk.verifyOnlyCleanCards:\");\r\n    trace.string(\"  that: \").hex(that);\r\n    boolean result = true;\r\n    final Pointer rememberedSetStart = getCardTableStart(that);\r\n    final UnsignedWord objectIndex = getObjectIndex();\r\n    if (CardTable.isDirtyEntryAtIndex(rememberedSetStart, objectIndex)) {\r\n        result = false;\r\n        final Log witness = Log.log().string(\"[UnalignedHeapChunk.verifyOnlyCleanCards:\");\r\n        witness.string(\"  that: \").hex(that).string(\"  dirty card at index: \").unsigned(objectIndex).string(\"]\").newline();\r\n    }\r\n    trace.string(\"  returns: \").bool(result).string(\"]\").newline();\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.svm.core.jdk.Target_java_lang_Shutdown.runAllFinalizers",
	"Comment": "wormhole for invoking java.lang.ref.finalizer.runallfinalizers",
	"Method": "void runAllFinalizers(){\r\n    throw VMError.unsupportedFeature(\"java.lang.Shudown.runAllFinalizers()\");\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.HeapImpl.tearDown",
	"Comment": "tear down the heap, return all allocated virtual memory chunks to virtualmemoryprovider.",
	"Method": "void tearDown(){\r\n    youngGeneration.tearDown();\r\n    oldGeneration.tearDown();\r\n    HeapChunkProvider.get().tearDown();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.interop.Message.createNode",
	"Comment": "creates an ast node for this message. the node can be inserted into ast of your language andwill handle communication with the foreign language.",
	"Method": "Node createNode(){\r\n    CompilerAsserts.neverPartOfCompilation();\r\n    return InteropAccessNode.create(this);\r\n}"
}, {
	"Path": "com.oracle.truffle.sl.SLLanguage.findExportedSymbol",
	"Comment": "still necessary for the old sl tck to pass. we should remove with the old tck. new languageshould not override this.",
	"Method": "Object findExportedSymbol(SLContext context,String globalName,boolean onlyExplicit){\r\n    return context.getFunctionRegistry().lookup(globalName, false);\r\n}"
}, {
	"Path": "com.oracle.svm.core.posix.PosixUtils.lastErrorString",
	"Comment": "return the error string for the last error, or a default message.",
	"Method": "String lastErrorString(String defaultMsg){\r\n    int errno = Errno.errno();\r\n    return errorString(errno, defaultMsg);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.impl.TVMCI.getCompilerOptionDescriptors",
	"Comment": "returns the compiler options specified available from the runtime.",
	"Method": "OptionDescriptors getCompilerOptionDescriptors(){\r\n    return OptionDescriptors.EMPTY;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentationTest.testMetadata",
	"Comment": "test that metadata is properly propagated to instrument handles.",
	"Method": "void testMetadata(){\r\n    Instrument instrumentHandle1 = engine.getInstruments().get(\"testMetadataType1\");\r\n    Assert.assertEquals(\"name\", instrumentHandle1.getName());\r\n    Assert.assertEquals(\"version\", instrumentHandle1.getVersion());\r\n    Assert.assertEquals(\"testMetadataType1\", instrumentHandle1.getId());\r\n    Assert.assertFalse(isInitialized(instrumentHandle1));\r\n    Assert.assertFalse(isCreated(instrumentHandle1));\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.DirectoryStorageTest.testLoadMissingComponentMetadata",
	"Comment": "test of loadcomponentmetadata method, of class registrystorage.",
	"Method": "void testLoadMissingComponentMetadata(){\r\n    copyDir(\"list1\", registryPath);\r\n    assertNull(storage.loadComponentMetadata(\"rrr\"));\r\n}"
}, {
	"Path": "com.oracle.svm.core.locks.VMCondition.block",
	"Comment": "waits until the condition variable gets signaled or the given number of nanoseconds haselapsed. returns any nanoseconds remaining if it returned early.",
	"Method": "void block(long block,long nanoseconds){\r\n    throw VMError.shouldNotReachHere(\"VMCondition cannot be used during native image generation\");\r\n}"
}, {
	"Path": "io.grpc.grpclb.GrpclbLoadBalancerTest.subtestGrpclbFallbackConnectionLost",
	"Comment": "fallback outside of the initial timeout, where all connections are lost.",
	"Method": "void subtestGrpclbFallbackConnectionLost(boolean balancerBroken,boolean allSubchannelsBroken){\r\n    long loadReportIntervalMillis = 1983;\r\n    InOrder inOrder = inOrder(helper, mockLbService, subchannelPool);\r\n    List<EquivalentAddressGroup> resolutionList = createResolvedServerAddresses(false, true, false);\r\n    Attributes resolutionAttrs = Attributes.EMPTY;\r\n    deliverResolvedAddresses(resolutionList, resolutionAttrs);\r\n    inOrder.verify(helper).createOobChannel(eq(resolutionList.get(1)), eq(lbAuthority(0)));\r\n    assertEquals(1, fakeOobChannels.size());\r\n    fakeOobChannels.poll();\r\n    inOrder.verify(mockLbService).balanceLoad(lbResponseObserverCaptor.capture());\r\n    StreamObserver<LoadBalanceResponse> lbResponseObserver = lbResponseObserverCaptor.getValue();\r\n    assertEquals(1, lbRequestObservers.size());\r\n    StreamObserver<LoadBalanceRequest> lbRequestObserver = lbRequestObservers.poll();\r\n    verify(lbRequestObserver).onNext(eq(LoadBalanceRequest.newBuilder().setInitialRequest(InitialLoadBalanceRequest.newBuilder().setName(SERVICE_AUTHORITY).build()).build()));\r\n    lbResponseObserver.onNext(buildInitialResponse(loadReportIntervalMillis));\r\n    inOrder.verify(helper, atLeast(0)).getSynchronizationContext();\r\n    inOrder.verify(helper, atLeast(0)).getScheduledExecutorService();\r\n    inOrder.verifyNoMoreInteractions();\r\n    List<ServerEntry> serverList = Arrays.asList(new ServerEntry(\"127.0.0.1\", 2000, \"token0001\"), new ServerEntry(\"127.0.0.1\", 2010, \"token0002\"));\r\n    lbResponseObserver.onNext(buildInitialResponse());\r\n    lbResponseObserver.onNext(buildLbResponse(serverList));\r\n    List<Subchannel> subchannels = fallbackTestVerifyUseOfBalancerBackendLists(inOrder, serverList);\r\n    if (balancerBroken) {\r\n        lbResponseObserver.onError(Status.UNAVAILABLE.asException());\r\n        inOrder.verify(mockLbService).balanceLoad(lbResponseObserverCaptor.capture());\r\n        lbResponseObserver = lbResponseObserverCaptor.getValue();\r\n        assertEquals(1, lbRequestObservers.size());\r\n        lbRequestObserver = lbRequestObservers.poll();\r\n    }\r\n    if (allSubchannelsBroken) {\r\n        for (Subchannel subchannel : subchannels) {\r\n            deliverSubchannelState(subchannel, ConnectivityStateInfo.forNonError(IDLE));\r\n        }\r\n    }\r\n    if (balancerBroken && allSubchannelsBroken) {\r\n        subchannels = fallbackTestVerifyUseOfFallbackBackendLists(inOrder, Arrays.asList(resolutionList.get(0), resolutionList.get(2)));\r\n        for (Subchannel subchannel : subchannels) {\r\n            deliverSubchannelState(subchannel, ConnectivityStateInfo.forNonError(IDLE));\r\n        }\r\n        List<ServerEntry> serverList2 = Arrays.asList(new ServerEntry(\"127.0.0.1\", 2001, \"token0003\"), new ServerEntry(\"127.0.0.1\", 2011, \"token0004\"));\r\n        lbResponseObserver.onNext(buildInitialResponse());\r\n        lbResponseObserver.onNext(buildLbResponse(serverList2));\r\n        fallbackTestVerifyUseOfBalancerBackendLists(inOrder, serverList2);\r\n    }\r\n    assertEquals(0, fakeClock.numPendingTasks(FALLBACK_MODE_TASK_FILTER));\r\n    if (!(balancerBroken && allSubchannelsBroken)) {\r\n        verify(subchannelPool, never()).takeOrCreateSubchannel(eq(resolutionList.get(0)), any(Attributes.class));\r\n        verify(subchannelPool, never()).takeOrCreateSubchannel(eq(resolutionList.get(2)), any(Attributes.class));\r\n    }\r\n}"
}, {
	"Path": "io.grpc.internal.SharedResourceHolder.get",
	"Comment": "try to get an existing instance of the given resource. if an instance does not exist, create anew one with the given factory.",
	"Method": "T get(Resource<T> resource){\r\n    return holder.getInternal(resource);\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.typestate.TypeState.objects",
	"Comment": "provides an iterable for the objects corresponding to the type. the objects are returned fromthe internal objects array and are not materialized to a different data structure.",
	"Method": "AnalysisObject[] objects(Iterable<AnalysisObject> objects,AnalysisType type,AnalysisObject[] objects,AnalysisObject[] objects,AnalysisObject[] objects){\r\n    return () -> objectsIterator(type);\r\n}"
}, {
	"Path": "io.grpc.ManagedChannelBuilder.enableRetry",
	"Comment": "enables the retry and hedging mechanism provided by the grpc library.for the current release, this method may have a side effect that disables census stats andtracing. hedging support is not implemented yet.",
	"Method": "T enableRetry(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "io.grpc.internal.testing.TestUtils.installConscryptIfAvailable",
	"Comment": "add conscrypt to the list of security providers, if it is available. if it appears to beavailable but fails to load, this method will throw an exception. since the list of securityproviders is static, this method does nothing if the provider is not available or succeededpreviously.",
	"Method": "void installConscryptIfAvailable(){\r\n    if (conscryptInstallAttempted) {\r\n        return;\r\n    }\r\n    Class<?> conscrypt;\r\n    try {\r\n        conscrypt = Class.forName(\"org.conscrypt.Conscrypt\");\r\n    } catch (ClassNotFoundException ex) {\r\n        conscryptInstallAttempted = true;\r\n        return;\r\n    }\r\n    Method newProvider;\r\n    try {\r\n        newProvider = conscrypt.getMethod(\"newProvider\");\r\n    } catch (NoSuchMethodException ex) {\r\n        throw new RuntimeException(\"Could not find newProvider method on Conscrypt\", ex);\r\n    }\r\n    Provider provider;\r\n    try {\r\n        provider = (Provider) newProvider.invoke(null);\r\n    } catch (IllegalAccessException ex) {\r\n        throw new RuntimeException(\"Could not invoke Conscrypt.newProvider\", ex);\r\n    } catch (InvocationTargetException ex) {\r\n        throw new RuntimeException(\"Could not invoke Conscrypt.newProvider\", ex);\r\n    }\r\n    Security.addProvider(provider);\r\n    conscryptInstallAttempted = true;\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.test.BaseSuiteHarness.validateResults",
	"Comment": "validate the results of the candidate sulong binary against the output of the referencebinary. on failure, the function will throw an unchecked exception.",
	"Method": "void validateResults(Path referenceBinary,ProcessUtil.ProcessResult referenceResult,Path candidateBinary,ProcessUtil.ProcessResult candidateResult){\r\n    String testName = candidateBinary.getFileName().toString() + \" in \" + getTestDirectory().toAbsolutePath().toString();\r\n    try {\r\n        Assert.assertEquals(testName, referenceResult, candidateResult);\r\n    } catch (AssertionError e) {\r\n        throw fail(getTestName(), e);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.util.TimeUtils.roundNanosToMillis",
	"Comment": "round the number of nanoseconds to a number of milliseconds.",
	"Method": "long roundNanosToMillis(long nanos){\r\n    return roundedDivide(nanos, nanosPerMilli);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.CompilerDirectives.inCompilationRoot",
	"Comment": "returns a boolean value indicating whether the method is executed in the root of a trufflecompilation.",
	"Method": "boolean inCompilationRoot(){\r\n    return false;\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.image.NativeBootImage.build",
	"Comment": "create the image sections for code, constants, and the heap.",
	"Method": "void build(DebugContext debug){\r\n    try (DebugContext.Scope buildScope = debug.scope(\"NativeBootImage.build\")) {\r\n        final CGlobalDataFeature cGlobals = CGlobalDataFeature.singleton();\r\n        final int textSectionSize = codeCache.getCodeCacheSize();\r\n        final int roConstantsSize = codeCache.getAlignedConstantsSize();\r\n        final int cglobalsSize = ConfigurationValues.getObjectLayout().alignUp(cGlobals.getSize());\r\n        if (SubstrateOptions.SpawnIsolates.getValue()) {\r\n            heap.alignRelocatablePartition(objectFile.getPageSize());\r\n        }\r\n        long roSectionSize = roConstantsSize;\r\n        long rwSectionSize = cglobalsSize;\r\n        if (!SubstrateOptions.SpawnIsolates.getValue()) {\r\n            roSectionSize += heap.getReadOnlySectionSize();\r\n            rwSectionSize += heap.getWritableSectionSize();\r\n        }\r\n        final RelocatableBuffer textBuffer = RelocatableBuffer.factory(\"text\", textSectionSize, objectFile.getByteOrder());\r\n        final TextImpl textImpl = TextImpl.factory(textBuffer, objectFile, codeCache);\r\n        final String textSectionName = SectionName.TEXT.getFormatDependentName(objectFile.getFormat());\r\n        textSection = objectFile.newProgbitsSection(textSectionName, objectFile.getPageSize(), false, true, textImpl);\r\n        final RelocatableBuffer roDataBuffer = RelocatableBuffer.factory(\"roData\", roSectionSize, objectFile.getByteOrder());\r\n        final ProgbitsSectionImpl roDataImpl = new BasicProgbitsSectionImpl(roDataBuffer.getBytes());\r\n        final String roDataSectionName = SectionName.RODATA.getFormatDependentName(objectFile.getFormat());\r\n        roDataSection = objectFile.newProgbitsSection(roDataSectionName, objectFile.getPageSize(), false, false, roDataImpl);\r\n        final RelocatableBuffer rwDataBuffer = RelocatableBuffer.factory(\"rwData\", rwSectionSize, objectFile.getByteOrder());\r\n        final ProgbitsSectionImpl rwDataImpl = new BasicProgbitsSectionImpl(rwDataBuffer.getBytes());\r\n        final String rwDataSectionName = SectionName.DATA.getFormatDependentName(objectFile.getFormat());\r\n        rwDataSection = objectFile.newProgbitsSection(rwDataSectionName, objectFile.getPageSize(), true, false, rwDataImpl);\r\n        objectFile.createDefinedSymbol(textSection.getName(), textSection, 0, 0, false, false);\r\n        objectFile.createDefinedSymbol(\"__svm_text_end\", textSection, codeCache.getCodeCacheSize(), 0, false, true);\r\n        objectFile.createDefinedSymbol(roDataSection.getName(), roDataSection, 0, 0, false, false);\r\n        objectFile.createDefinedSymbol(rwDataSection.getName(), rwDataSection, 0, 0, false, false);\r\n        final long constantsPartitionOffset = 0L;\r\n        final long roConstantsEndOffset = constantsPartitionOffset + roConstantsSize;\r\n        final long rwGlobalsEndOffset = RWDATA_CGLOBALS_PARTITION_OFFSET + ConfigurationValues.getObjectLayout().alignUp(cGlobals.getSize());\r\n        final RelocatableBuffer heapSectionBuffer;\r\n        final ProgbitsSectionImpl heapSectionImpl;\r\n        if (SubstrateOptions.SpawnIsolates.getValue()) {\r\n            boolean writable = !SubstrateOptions.SpawnIsolates.getValue();\r\n            final long heapSize = heap.getReadOnlySectionSize() + heap.getWritableSectionSize();\r\n            heapSectionBuffer = RelocatableBuffer.factory(\"heap\", heapSize, objectFile.getByteOrder());\r\n            heapSectionImpl = new BasicProgbitsSectionImpl(heapSectionBuffer.getBytes());\r\n            final String heapSectionName = SectionName.SVM_HEAP.getFormatDependentName(objectFile.getFormat());\r\n            heapSection = objectFile.newProgbitsSection(heapSectionName, objectFile.getPageSize(), writable, false, heapSectionImpl);\r\n            objectFile.createDefinedSymbol(heapSection.getName(), heapSection, 0, 0, false, true);\r\n            heap.setReadOnlySection(heapSection.getName(), 0);\r\n            long writableSectionOffset = heap.getReadOnlySectionSize();\r\n            heap.setWritableSection(heapSection.getName(), writableSectionOffset);\r\n            defineDataSymbol(Isolates.IMAGE_HEAP_BEGIN_SYMBOL_NAME, heapSection, 0);\r\n            defineDataSymbol(Isolates.IMAGE_HEAP_END_SYMBOL_NAME, heapSection, heapSize);\r\n            defineDataSymbol(Isolates.IMAGE_HEAP_WRITABLE_BEGIN_SYMBOL_NAME, heapSection, writableSectionOffset);\r\n            defineDataSymbol(Isolates.IMAGE_HEAP_WRITABLE_END_SYMBOL_NAME, heapSection, writableSectionOffset + heap.getWritableSectionSize());\r\n            final long relocatableOffset = heap.getReadOnlyRelocatablePartitionOffset();\r\n            final long relocatableSize = heap.getReadOnlyRelocatablePartitionSize();\r\n            defineDataSymbol(Isolates.IMAGE_HEAP_RELOCATABLE_BEGIN_SYMBOL_NAME, heapSection, relocatableOffset);\r\n            defineDataSymbol(Isolates.IMAGE_HEAP_RELOCATABLE_END_SYMBOL_NAME, heapSection, relocatableOffset + relocatableSize);\r\n        } else {\r\n            heapSectionBuffer = null;\r\n            heapSectionImpl = null;\r\n            heap.setReadOnlySection(roDataSection.getName(), roConstantsEndOffset);\r\n            heap.setWritableSection(rwDataSection.getName(), rwGlobalsEndOffset);\r\n        }\r\n        textImpl.writeTextSection(debug, textSection, entryPoints);\r\n        codeCache.writeConstants(roDataBuffer);\r\n        cGlobals.writeData(rwDataBuffer, (offset, symbolName) -> defineDataSymbol(symbolName, rwDataSection, offset + RWDATA_CGLOBALS_PARTITION_OFFSET));\r\n        defineDataSymbol(CGlobalDataInfo.CGLOBALDATA_BASE_SYMBOL_NAME, rwDataSection, RWDATA_CGLOBALS_PARTITION_OFFSET);\r\n        if (SubstrateOptions.SpawnIsolates.getValue()) {\r\n            heap.writeHeap(debug, heapSectionBuffer, heapSectionBuffer);\r\n            long firstRelocOffset = heap.getFirstRelocatablePointerOffsetInSection();\r\n            defineDataSymbol(Isolates.IMAGE_HEAP_RELOCATABLE_FIRST_RELOC_POINTER_NAME, heapSection, firstRelocOffset);\r\n            assert castToByteBuffer(heapSectionBuffer).getLong((int) firstRelocOffset) == 0;\r\n        } else {\r\n            assert heapSectionBuffer == null;\r\n            heap.writeHeap(debug, roDataBuffer, rwDataBuffer);\r\n        }\r\n        markRelocationSitesFromMaps(textBuffer, textImpl, heap.objects);\r\n        markRelocationSitesFromMaps(roDataBuffer, roDataImpl, heap.objects);\r\n        markRelocationSitesFromMaps(rwDataBuffer, rwDataImpl, heap.objects);\r\n        if (heapSectionBuffer != null) {\r\n            markRelocationSitesFromMaps(heapSectionBuffer, heapSectionImpl, heap.objects);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.stream.JsonReader.getPath",
	"Comment": "returns a jsonpath tothe current location in the json value.",
	"Method": "String getPath(){\r\n    StringBuilder result = new StringBuilder().append('$');\r\n    for (int i = 0, size = stackSize; i < size; i++) {\r\n        switch(stack[i]) {\r\n            case JsonScope.EMPTY_ARRAY:\r\n            case JsonScope.NONEMPTY_ARRAY:\r\n                result.append('[').append(pathIndices[i]).append(']');\r\n                break;\r\n            case JsonScope.EMPTY_OBJECT:\r\n            case JsonScope.DANGLING_NAME:\r\n            case JsonScope.NONEMPTY_OBJECT:\r\n                result.append('.');\r\n                if (pathNames[i] != null) {\r\n                    result.append(pathNames[i]);\r\n                }\r\n                break;\r\n            case JsonScope.NONEMPTY_DOCUMENT:\r\n            case JsonScope.EMPTY_DOCUMENT:\r\n            case JsonScope.CLOSED:\r\n                break;\r\n        }\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "io.grpc.alts.internal.AltsHandshakerStubTest.sendAndExpectUnexpectedMessage",
	"Comment": "send a message and expect an ioexception on unexpected message.",
	"Method": "void sendAndExpectUnexpectedMessage(){\r\n    try {\r\n        stub.send(HandshakerReq.newBuilder().build());\r\n        fail(\"Exception expected\");\r\n    } catch (IOException ex) {\r\n        assertThat(ex).hasMessageThat().contains(\"Received an unexpected response\");\r\n    }\r\n}"
}, {
	"Path": "io.grpc.okhttp.OkHttpClientTransport.onError",
	"Comment": "send goaway to the server, then finish all active streams and close the transport.",
	"Method": "void onError(ErrorCode errorCode,String moreDetail){\r\n    startGoAway(0, errorCode, toGrpcStatus(errorCode).augmentDescription(moreDetail));\r\n}"
}, {
	"Path": "io.grpc.internal.MessageDeframer.isClosedOrScheduledToClose",
	"Comment": "returns true if this deframer has already been closed or scheduled to close.",
	"Method": "boolean isClosedOrScheduledToClose(){\r\n    return isClosed() || closeWhenComplete;\r\n}"
}, {
	"Path": "com.google.gson.internal.ConstructorConstructor.newDefaultImplementationConstructor",
	"Comment": "constructors for common interface types like map and list and theirsubtypes.",
	"Method": "ObjectConstructor<T> newDefaultImplementationConstructor(Type type,Class<? super T> rawType){\r\n    if (Collection.class.isAssignableFrom(rawType)) {\r\n        if (SortedSet.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new TreeSet<Object>();\r\n                }\r\n            };\r\n        } else if (EnumSet.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor<T>() {\r\n                @SuppressWarnings(\"rawtypes\")\r\n                @Override\r\n                public T construct() {\r\n                    if (type instanceof ParameterizedType) {\r\n                        Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\r\n                        if (elementType instanceof Class) {\r\n                            return (T) EnumSet.noneOf((Class) elementType);\r\n                        } else {\r\n                            throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\r\n                        }\r\n                    } else {\r\n                        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\r\n                    }\r\n                }\r\n            };\r\n        } else if (Set.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedHashSet<Object>();\r\n                }\r\n            };\r\n        } else if (Queue.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ArrayDeque<Object>();\r\n                }\r\n            };\r\n        } else {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ArrayList<Object>();\r\n                }\r\n            };\r\n        }\r\n    }\r\n    if (Map.class.isAssignableFrom(rawType)) {\r\n        if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ConcurrentSkipListMap<Object, Object>();\r\n                }\r\n            };\r\n        } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ConcurrentHashMap<Object, Object>();\r\n                }\r\n            };\r\n        } else if (SortedMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new TreeMap<Object, Object>();\r\n                }\r\n            };\r\n        } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedHashMap<Object, Object>();\r\n                }\r\n            };\r\n        } else {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedTreeMap<String, Object>();\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.gson.internal.ConstructorConstructor.newDefaultImplementationConstructor",
	"Comment": "constructors for common interface types like map and list and theirsubtypes.",
	"Method": "ObjectConstructor<T> newDefaultImplementationConstructor(Type type,Class<? super T> rawType){\r\n    return (T) new TreeSet<Object>();\r\n}"
}, {
	"Path": "com.google.gson.internal.ConstructorConstructor.newDefaultImplementationConstructor",
	"Comment": "constructors for common interface types like map and list and theirsubtypes.",
	"Method": "ObjectConstructor<T> newDefaultImplementationConstructor(Type type,Class<? super T> rawType){\r\n    if (type instanceof ParameterizedType) {\r\n        Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\r\n        if (elementType instanceof Class) {\r\n            return (T) EnumSet.noneOf((Class) elementType);\r\n        } else {\r\n            throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\r\n        }\r\n    } else {\r\n        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\r\n    }\r\n}"
}, {
	"Path": "com.google.gson.internal.ConstructorConstructor.newDefaultImplementationConstructor",
	"Comment": "constructors for common interface types like map and list and theirsubtypes.",
	"Method": "ObjectConstructor<T> newDefaultImplementationConstructor(Type type,Class<? super T> rawType){\r\n    return (T) new LinkedHashSet<Object>();\r\n}"
}, {
	"Path": "com.google.gson.internal.ConstructorConstructor.newDefaultImplementationConstructor",
	"Comment": "constructors for common interface types like map and list and theirsubtypes.",
	"Method": "ObjectConstructor<T> newDefaultImplementationConstructor(Type type,Class<? super T> rawType){\r\n    return (T) new ArrayDeque<Object>();\r\n}"
}, {
	"Path": "com.google.gson.internal.ConstructorConstructor.newDefaultImplementationConstructor",
	"Comment": "constructors for common interface types like map and list and theirsubtypes.",
	"Method": "ObjectConstructor<T> newDefaultImplementationConstructor(Type type,Class<? super T> rawType){\r\n    return (T) new ArrayList<Object>();\r\n}"
}, {
	"Path": "com.google.gson.internal.ConstructorConstructor.newDefaultImplementationConstructor",
	"Comment": "constructors for common interface types like map and list and theirsubtypes.",
	"Method": "ObjectConstructor<T> newDefaultImplementationConstructor(Type type,Class<? super T> rawType){\r\n    return (T) new ConcurrentSkipListMap<Object, Object>();\r\n}"
}, {
	"Path": "com.google.gson.internal.ConstructorConstructor.newDefaultImplementationConstructor",
	"Comment": "constructors for common interface types like map and list and theirsubtypes.",
	"Method": "ObjectConstructor<T> newDefaultImplementationConstructor(Type type,Class<? super T> rawType){\r\n    return (T) new ConcurrentHashMap<Object, Object>();\r\n}"
}, {
	"Path": "com.google.gson.internal.ConstructorConstructor.newDefaultImplementationConstructor",
	"Comment": "constructors for common interface types like map and list and theirsubtypes.",
	"Method": "ObjectConstructor<T> newDefaultImplementationConstructor(Type type,Class<? super T> rawType){\r\n    return (T) new TreeMap<Object, Object>();\r\n}"
}, {
	"Path": "com.google.gson.internal.ConstructorConstructor.newDefaultImplementationConstructor",
	"Comment": "constructors for common interface types like map and list and theirsubtypes.",
	"Method": "ObjectConstructor<T> newDefaultImplementationConstructor(Type type,Class<? super T> rawType){\r\n    return (T) new LinkedHashMap<Object, Object>();\r\n}"
}, {
	"Path": "com.google.gson.internal.ConstructorConstructor.newDefaultImplementationConstructor",
	"Comment": "constructors for common interface types like map and list and theirsubtypes.",
	"Method": "ObjectConstructor<T> newDefaultImplementationConstructor(Type type,Class<? super T> rawType){\r\n    return (T) new LinkedTreeMap<String, Object>();\r\n}"
}, {
	"Path": "io.grpc.benchmarks.netty.SingleThreadBlockingQpsBenchmark.setup",
	"Comment": "setup with direct executors, small payloads and the default flow control window.",
	"Method": "void setup(){\r\n    super.setup(ExecutorType.DIRECT, ExecutorType.DIRECT, MessageSize.SMALL, MessageSize.SMALL, FlowWindowSize.MEDIUM, ChannelType.NIO, 1, 1);\r\n}"
}, {
	"Path": "io.grpc.internal.AbstractManagedChannelImplBuilder.makeTargetStringForDirectAddress",
	"Comment": "returns a target string for the socketaddress. it is only used as a placeholder, becausedirectaddressnameresolverfactory will not actually try to use it. however, it must be a validuri.",
	"Method": "String makeTargetStringForDirectAddress(SocketAddress address){\r\n    try {\r\n        return new URI(DIRECT_ADDRESS_SCHEME, \"\", \"/\" + address, null).toString();\r\n    } catch (URISyntaxException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.objectfile.pecoff.PECoffSymtab.getNativeSymtab",
	"Comment": "this function uses the entries set to create the native byte array that will be written outto disk.",
	"Method": "PECoffSymtabStruct getNativeSymtab(){\r\n    if (symtabStruct != null) {\r\n        return symtabStruct;\r\n    }\r\n    symtabStruct = new PECoffSymtabStruct();\r\n    for (Entry e : entries) {\r\n        PECoffSection sect = e.getReferencedSection();\r\n        int sectID = sect == null ? -1 : sect.getSectionID();\r\n        long offset = e.isDefined() ? e.getDefinedOffset() : 0L;\r\n        symtabStruct.addSymbolEntry(e.getName(), (byte) e.getSymType(), (byte) e.getSymClass(), (byte) sectID, offset);\r\n    }\r\n    return symtabStruct;\r\n}"
}, {
	"Path": "io.grpc.Context.withValues",
	"Comment": "create a new context with the given key value set. the new context will cascade cancellationfrom its parent.",
	"Method": "Context withValues(Key<V1> k1,V1 v1,Key<V2> k2,V2 v2,Context withValues,Key<V1> k1,V1 v1,Key<V2> k2,V2 v2,Key<V3> k3,V3 v3,Context withValues,Key<V1> k1,V1 v1,Key<V2> k2,V2 v2,Key<V3> k3,V3 v3,Key<V4> k4,V4 v4){\r\n    PersistentHashArrayMappedTrie<Key<?>, Object> newKeyValueEntries = keyValueEntries.put(k1, v1).put(k2, v2).put(k3, v3).put(k4, v4);\r\n    return new Context(this, newKeyValueEntries);\r\n}"
}, {
	"Path": "io.grpc.LoadBalancerRegistry.getDefaultRegistry",
	"Comment": "returns the default registry that loads providers via the java service loader mechanism.",
	"Method": "LoadBalancerRegistry getDefaultRegistry(){\r\n    if (instance == null) {\r\n        List<LoadBalancerProvider> providerList = ServiceProviders.loadAll(LoadBalancerProvider.class, HARDCODED_CLASSES, LoadBalancerProvider.class.getClassLoader(), new LoadBalancerPriorityAccessor());\r\n        instance = new LoadBalancerRegistry();\r\n        for (LoadBalancerProvider provider : providerList) {\r\n            logger.fine(\"Service loader found \" + provider);\r\n            if (provider.isAvailable()) {\r\n                instance.addProvider(provider);\r\n            }\r\n        }\r\n        instance.refreshProviderMap();\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.GreyObjectsWalker.setScanStart",
	"Comment": "take a snapshot of a space, such that all object in the space are now black, and any newobjects in the space will be grey, and can have an objectvisitor applied to them.",
	"Method": "void setScanStart(Space s){\r\n    final Log trace = Log.noopLog().string(\"[Space.GreyObjectsWalker.setScanStart:\").string(\"  s: \").string(s.getName());\r\n    space = s;\r\n    final AlignedHeapChunk.AlignedHeader aChunk = s.getLastAlignedHeapChunk();\r\n    setAlignedHeapChunk(aChunk);\r\n    trace.string(\"  alignedHeapChunk: \").hex(getAlignedHeapChunk()).string(\"  isNull: \").bool(aChunk.isNull());\r\n    alignedTop = (aChunk.isNonNull() ? aChunk.getTop() : WordFactory.nullPointer());\r\n    trace.string(\"  alignedTop: \").hex(alignedTop);\r\n    final UnalignedHeapChunk.UnalignedHeader uChunk = s.getLastUnalignedHeapChunk();\r\n    setUnalignedHeapChunk(uChunk);\r\n    trace.string(\"  unalignedChunkPointer: \").hex(getUnalignedHeapChunk()).string(\"]\").newline();\r\n}"
}, {
	"Path": "com.oracle.objectfile.ObjectFile.flagSetAsLong",
	"Comment": "create a long integer representation of an enumset of bitflags.",
	"Method": "long flagSetAsLong(EnumSet<E> flags){\r\n    long working = 0;\r\n    for (E f : flags) {\r\n        working |= f.value();\r\n    }\r\n    return working;\r\n}"
}, {
	"Path": "io.grpc.CallOptions.withMaxOutboundMessageSize",
	"Comment": "sets the maximum allowed message size acceptable sent to the remote peer.",
	"Method": "CallOptions withMaxOutboundMessageSize(int maxSize){\r\n    checkArgument(maxSize >= 0, \"invalid maxsize %s\", maxSize);\r\n    CallOptions newOptions = new CallOptions(this);\r\n    newOptions.maxOutboundMessageSize = maxSize;\r\n    return newOptions;\r\n}"
}, {
	"Path": "io.grpc.netty.NettyServerHandler.returnProcessedBytes",
	"Comment": "returns the given processed bytes back to inbound flow control.",
	"Method": "void returnProcessedBytes(Http2Stream http2Stream,int bytes){\r\n    try {\r\n        decoder().flowController().consumeBytes(http2Stream, bytes);\r\n    } catch (Http2Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.ThreadLocalAllocation.getObjectBytes",
	"Comment": "returns the total memory used by the tlab in bytes. it counts only the memory actually used,not the total committed memory.",
	"Method": "UnsignedWord getObjectBytes(Descriptor tlab){\r\n    Log log = log();\r\n    log.newline();\r\n    log.string(\"[ThreadLocalAllocator.usedMemory: tlab \").hex(tlab).newline();\r\n    AlignedHeader aChunk = tlab.getAlignedChunk();\r\n    UnsignedWord alignedUsedMemory = WordFactory.zero();\r\n    while (aChunk.isNonNull()) {\r\n        AlignedHeader next = aChunk.getNext();\r\n        Pointer start = AlignedHeapChunk.getAlignedHeapChunkStart(aChunk);\r\n        Pointer top = aChunk.getTop().isNull() ? tlab.getAllocationTop(TOP_IDENTITY) : aChunk.getTop();\r\n        UnsignedWord aChunkUsedMemory = top.subtract(start);\r\n        alignedUsedMemory = alignedUsedMemory.add(aChunkUsedMemory);\r\n        log.string(\"     aligned chunk: \").hex(aChunk).string(\" | used memory: \").unsigned(aChunkUsedMemory).newline();\r\n        aChunk = next;\r\n    }\r\n    UnsignedWord unalignedUsedMemory = WordFactory.zero();\r\n    UnalignedHeader uChunk = tlab.getUnalignedChunk();\r\n    while (uChunk.isNonNull()) {\r\n        UnalignedHeader next = uChunk.getNext();\r\n        UnsignedWord uChunkUsedMemory = UnalignedHeapChunk.usedObjectMemoryOfUnalignedHeapChunk(uChunk);\r\n        unalignedUsedMemory = unalignedUsedMemory.add(uChunkUsedMemory);\r\n        log.string(\"     unaligned chunk \").hex(uChunk).string(\" | used memory: \").unsigned(uChunkUsedMemory).newline();\r\n        uChunk = next;\r\n    }\r\n    UnsignedWord tlabUsedMemory = alignedUsedMemory.add(unalignedUsedMemory);\r\n    log.newline();\r\n    log.string(\"  aligned used memory: \").unsigned(alignedUsedMemory).newline();\r\n    log.string(\"  unaligned used memory: \").unsigned(unalignedUsedMemory).newline();\r\n    log.string(\"  TLAB used memory: \").unsigned(tlabUsedMemory).newline();\r\n    log.string(\"  ]\").newline();\r\n    return tlabUsedMemory;\r\n}"
}, {
	"Path": "com.oracle.objectfile.io.AssemblyBuffer.ensure",
	"Comment": "ensure there is enough space left in the buffer to write the given number of bytes.",
	"Method": "void ensure(int n){\r\n    if (buf.remaining() < n) {\r\n        final int cap = buf.capacity();\r\n        final int pos = buf.position();\r\n        final int req = pos + n;\r\n        int newCap = (int) (cap * GROWTH_FACTOR);\r\n        while (newCap < req) {\r\n            newCap = (int) (newCap * GROWTH_FACTOR);\r\n        }\r\n        ByteBuffer nbuf = ByteBuffer.allocate(newCap);\r\n        nbuf.order(ByteOrder.nativeOrder());\r\n        byte[] old = new byte[pos];\r\n        buf.rewind();\r\n        buf.get(old);\r\n        nbuf.put(old);\r\n        buf = nbuf;\r\n    }\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.LoadSourceSectionEvent.getNode",
	"Comment": "returns the instrumentable truffle node that caused this event.",
	"Method": "Node getNode(){\r\n    return node;\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.c.query.QueryParserUtil.isNegative",
	"Comment": "only checks the most significant digit in the hexadecimal representation of the integernumber. this method converts the most significant digit from string to int and check if itsvalue if greater or equals to 8, if it is the most significant bit is set. therefore, theinteger number is negative.a unsigned integer should not use this method.",
	"Method": "boolean isNegative(String hex){\r\n    int mostSignificantDigit = Integer.parseInt(hex.substring(0, 1), 16);\r\n    if (mostSignificantDigit >= 8) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.TruffleStackTraceElement.getLocation",
	"Comment": "returns a node representing the callsite on the stack. returns null if nodetailed callsite information is available.",
	"Method": "Node getLocation(){\r\n    return location;\r\n}"
}, {
	"Path": "io.grpc.CompressorRegistry.register",
	"Comment": "registers a compressor for both decompression and message encoding negotiation.",
	"Method": "void register(Compressor c){\r\n    String encoding = c.getMessageEncoding();\r\n    checkArgument(!encoding.contains(\",\"), \"Comma is currently not allowed in message encoding\");\r\n    compressors.put(encoding, c);\r\n}"
}, {
	"Path": "com.oracle.svm.core.deopt.Deoptimizer.rewriteStackStub",
	"Comment": "performs the actual stack rewriting. the custom prologue of this method sets the stackpointer to the new value passed in as the first parameter.the custom epilogue of this method restores the return value registers from the returnedframe handle.",
	"Method": "DeoptimizedFrame rewriteStackStub(Pointer newSp,DeoptimizedFrame frame){\r\n    Pointer bottomSp = newSp.subtract(FrameAccess.returnAddressSize() + FrameAccess.singleton().savedBasePointerSize());\r\n    frame.getTargetContent().copyToPointer(bottomSp);\r\n    if (DeoptimizationCounters.Options.ProfileDeoptimization.getValue()) {\r\n        DeoptimizationCounters.counters().timeSpentInDeopt.add(System.nanoTime() - DeoptimizationCounters.startTime.get());\r\n    }\r\n    return frame;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.YoungGeneration.tearDown",
	"Comment": "return all allocated virtual memory chunks to heapchunkprovider.",
	"Method": "void tearDown(){\r\n    ThreadLocalAllocation.tearDown();\r\n    space.tearDown();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.TruffleException.isCancelled",
	"Comment": "returns true if this exception indicates that guest language application wascancelled during its execution.",
	"Method": "boolean isCancelled(){\r\n    return false;\r\n}"
}, {
	"Path": "com.google.gson.stream.JsonWriter.open",
	"Comment": "enters a new scope by appending any necessary whitespace and the givenbracket.",
	"Method": "JsonWriter open(int empty,String openBracket){\r\n    beforeValue();\r\n    push(empty);\r\n    out.write(openBracket);\r\n    return this;\r\n}"
}, {
	"Path": "com.oracle.truffle.llvm.nodes.cast.LLVMToI64Node.fitsIntoSignedLong",
	"Comment": "these methods are only on the base class as a workaround for a dsl issue",
	"Method": "boolean fitsIntoSignedLong(float from,boolean fitsIntoSignedLong,double from){\r\n    return from < MAX_LONG_AS_DOUBLE;\r\n}"
}, {
	"Path": "io.grpc.Status.getCause",
	"Comment": "the underlying cause of an error.note that the cause is not transmitted from server to client.",
	"Method": "Throwable getCause(){\r\n    return cause;\r\n}"
}, {
	"Path": "io.grpc.benchmarks.driver.LoadClient.delay",
	"Comment": "record the event elapsed time to the histogram and delay initiation of the next event basedon the load distribution.",
	"Method": "void delay(long alreadyElapsed){\r\n    recorder.recordValue(alreadyElapsed);\r\n    if (distribution != null) {\r\n        long nextPermitted = Math.round(distribution.sample() * 1000000000.0);\r\n        if (nextPermitted > alreadyElapsed) {\r\n            LockSupport.parkNanos(nextPermitted - alreadyElapsed);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.util.TimeUtils.divideNanosToSeconds",
	"Comment": "return the number of seconds in the given number of nanoseconds.",
	"Method": "long divideNanosToSeconds(long nanos){\r\n    return (nanos / nanosPerSecond);\r\n}"
}, {
	"Path": "io.grpc.testing.integration.CascadingTest.testCascadingCancellationViaRpcCancel",
	"Comment": "test that cancellation via call cancellation propagates down the call.",
	"Method": "void testCascadingCancellationViaRpcCancel(){\r\n    observedCancellations = new CountDownLatch(2);\r\n    receivedCancellations = new CountDownLatch(3);\r\n    Future<?> chainReady = startChainingServer(3);\r\n    Future<SimpleResponse> future = futureStub.unaryCall(SimpleRequest.getDefaultInstance());\r\n    chainReady.get(5, TimeUnit.SECONDS);\r\n    future.cancel(true);\r\n    assertTrue(future.isCancelled());\r\n    if (!observedCancellations.await(5, TimeUnit.SECONDS)) {\r\n        fail(\"Expected number of cancellations not observed by clients\");\r\n    }\r\n    if (!receivedCancellations.await(5, TimeUnit.SECONDS)) {\r\n        fail(\"Expected number of cancellations to be received by servers not observed\");\r\n    }\r\n}"
}, {
	"Path": "io.grpc.internal.DnsNameResolver.getNetworkAddressCacheTtlNanos",
	"Comment": "returns value of network address cache ttl property if not android environment. for android,dnsnameresolver does not cache the dns lookup result.",
	"Method": "long getNetworkAddressCacheTtlNanos(boolean isAndroid){\r\n    if (isAndroid) {\r\n        return 0;\r\n    }\r\n    String cacheTtlPropertyValue = System.getProperty(NETWORKADDRESS_CACHE_TTL_PROPERTY);\r\n    long cacheTtl = DEFAULT_NETWORK_CACHE_TTL_SECONDS;\r\n    if (cacheTtlPropertyValue != null) {\r\n        try {\r\n            cacheTtl = Long.parseLong(cacheTtlPropertyValue);\r\n        } catch (NumberFormatException e) {\r\n            logger.log(Level.WARNING, \"Property({0}) valid is not valid number format({1}), fall back to default({2})\", new Object[] { NETWORKADDRESS_CACHE_TTL_PROPERTY, cacheTtlPropertyValue, cacheTtl });\r\n        }\r\n    }\r\n    return cacheTtl > 0 ? TimeUnit.SECONDS.toNanos(cacheTtl) : cacheTtl;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.impl.TVMCI.isGuestCallStackFrame",
	"Comment": "returns true if the java stack frame is a representing a guest language call.needs to return true only once per java stack frame per guest language call.",
	"Method": "boolean isGuestCallStackFrame(StackTraceElement e){\r\n    return false;\r\n}"
}, {
	"Path": "org.graalvm.component.installer.model.ComponentRegistryTest.testIsReplacedFilesChanged",
	"Comment": "test of isreplacedfileschanged method, of class componentregistry.",
	"Method": "void testIsReplacedFilesChanged(){\r\n    registry.addComponent(rubyInfo);\r\n    assertTrue(registry.isReplacedFilesChanged());\r\n    ComponentInfo testInfo = new ComponentInfo(\"org.graalvm.test\", \"Test component\", \"1.0\");\r\n    testInfo.addPaths(Arrays.asList(\"jre/bin/ruby2\", \"jre/languages/fake/nothing2\"));\r\n    registry.addComponent(testInfo);\r\n    assertFalse(registry.isReplacedFilesChanged());\r\n}"
}, {
	"Path": "io.grpc.internal.testing.TestUtils.preferredTestCiphers",
	"Comment": "returns the ciphers preferred to use during tests. they may be chosen because they are widelyavailable or because they are fast. there is no requirement that they provide confidentialityor integrity.",
	"Method": "List<String> preferredTestCiphers(){\r\n    String[] ciphers;\r\n    try {\r\n        ciphers = SSLContext.getDefault().getDefaultSSLParameters().getCipherSuites();\r\n    } catch (NoSuchAlgorithmException ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n    List<String> ciphersMinusGcm = new ArrayList();\r\n    for (String cipher : ciphers) {\r\n        if (cipher.contains(\"_GCM_\")) {\r\n            continue;\r\n        }\r\n        ciphersMinusGcm.add(cipher);\r\n    }\r\n    return Collections.unmodifiableList(ciphersMinusGcm);\r\n}"
}, {
	"Path": "com.google.common.collect.Maps.asEntryTransformer",
	"Comment": "views a function as an entry transformer that ignores the entry key.",
	"Method": "EntryTransformer<K, V1, V2> asEntryTransformer(Function<? super V1, V2> function){\r\n    checkNotNull(function);\r\n    return new EntryTransformer<K, V1, V2>() {\r\n        @Override\r\n        public V2 transformEntry(K key, V1 value) {\r\n            return function.apply(value);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.google.common.collect.Maps.asEntryTransformer",
	"Comment": "views a function as an entry transformer that ignores the entry key.",
	"Method": "EntryTransformer<K, V1, V2> asEntryTransformer(Function<? super V1, V2> function){\r\n    return function.apply(value);\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.SourceSectionFilter.getLimitedTags",
	"Comment": "returns which tags are required to be materialized in order for this filter to be correct.returns null to indicate that all provided tags are required.",
	"Method": "Set<Class<?>> getLimitedTags(){\r\n    Set<Class<?>> requiredTags = null;\r\n    for (EventFilterExpression expression : expressions) {\r\n        if (expression instanceof EventFilterExpression.TagIs) {\r\n            if (requiredTags == null) {\r\n                requiredTags = new HashSet();\r\n            }\r\n            expression.collectReferencedTags(requiredTags);\r\n        }\r\n    }\r\n    return requiredTags;\r\n}"
}, {
	"Path": "com.oracle.svm.core.thread.JavaThreads.interruptUnderVMMutex",
	"Comment": "the list of methods to be called under the vmthreads mutex when interrupting a thread.",
	"Method": "void interruptUnderVMMutex(){\r\n    VMThreads.THREAD_MUTEX.guaranteeIsLocked(\"Should hold VMThreads lock when interrupting.\");\r\n    FeebleReferenceList.signalWaiters();\r\n}"
}, {
	"Path": "io.grpc.grpclb.GrpclbState.flattenEquivalentAddressGroup",
	"Comment": "flattens list of equivalentaddressgroup objects into one equivalentaddressgroup object.",
	"Method": "EquivalentAddressGroup flattenEquivalentAddressGroup(List<EquivalentAddressGroup> groupList,Attributes attrs){\r\n    List<SocketAddress> addrs = new ArrayList();\r\n    for (EquivalentAddressGroup group : groupList) {\r\n        addrs.addAll(group.getAddresses());\r\n    }\r\n    return new EquivalentAddressGroup(addrs, attrs);\r\n}"
}, {
	"Path": "io.grpc.Context.fork",
	"Comment": "create a new context which propagates the values of this context but does not cascade itscancellation.",
	"Method": "Context fork(){\r\n    return new Context(keyValueEntries, generation + 1);\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.SpaceVerifierImpl.verifyAlignedChunkList",
	"Comment": "verify the alignedchunk list, but not the chunks themselves.",
	"Method": "boolean verifyAlignedChunkList(){\r\n    final Log trace = HeapImpl.getHeapImpl().getHeapVerifierImpl().getTraceLog().string(\"[SpaceVerifierImpl.VerifierImpl.verifyAlignedChunkList:\");\r\n    trace.string(\"  Space: \").string(space.getName()).newline();\r\n    boolean result = true;\r\n    AlignedHeapChunk.AlignedHeader current = space.getFirstAlignedHeapChunk();\r\n    AlignedHeapChunk.AlignedHeader previous = WordFactory.nullPointer();\r\n    while (current.isNonNull()) {\r\n        final AlignedHeapChunk.AlignedHeader previousOfCurrent = current.getPrevious();\r\n        result &= previousOfCurrent.equal(previous);\r\n        if (!result) {\r\n            final Log failure = HeapImpl.getHeapImpl().getHeapVerifierImpl().getWitnessLog().string(\"[SpaceVerifierImpl.VerifierImpl.verifyAlignedChunkList:\");\r\n            failure.string(\"  space: \").string(space.getName()).string(\"  doubly-linked list failure\").newline();\r\n            failure.string(\"  current: \").hex(current);\r\n            failure.string(\"  current.previous: \").hex(previousOfCurrent);\r\n            failure.string(\"  previous: \").hex(previous);\r\n            failure.string(\"]\").newline();\r\n            break;\r\n        }\r\n        previous = current;\r\n        current = current.getNext();\r\n    }\r\n    result &= previous.equal(space.getLastAlignedHeapChunk());\r\n    if (!result) {\r\n        final Log failure = HeapImpl.getHeapImpl().getHeapVerifierImpl().getWitnessLog().string(\"[SpaceVerifierImpl.VerifierImpl.verifyAlignedChunkList:\");\r\n        failure.string(\"  space: \").string(space.getName()).string(\"  lastAlignedHeapChunk failure\").string(\"]\").newline();\r\n        failure.string(\"  previous: \").hex(previous);\r\n        failure.string(\"  lastAlignedHeapChunk: \").hex(space.getLastAlignedHeapChunk());\r\n        failure.string(\"]\").newline();\r\n        result = false;\r\n    }\r\n    trace.string(\"  returns: \").bool(result).string(\"]\").newline();\r\n    return result;\r\n}"
}, {
	"Path": "io.grpc.ManagedChannelBuilder.retryBufferSize",
	"Comment": "sets the retry buffer size in bytes. if the buffer limit is exceeded, no rpccould retry at the moment, and in hedging case all hedges but one of the same rpc will cancel.the implementation may only estimate the buffer size being used rather than count theexact physical memory allocated. the method does not have any effect if retry is disabled bythe client.this method may not work as expected for the current release because retry is not fullyimplemented yet.",
	"Method": "T retryBufferSize(long bytes){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "io.grpc.ManagedChannelBuilder.usePlaintext",
	"Comment": "use of a plaintext connection to the server. by default a secure connection mechanismsuch as tls will be used.should only be used for testing or for apis where the use of such api or the dataexchanged is not sensitive.",
	"Method": "T usePlaintext(boolean skipNegotiation,T usePlaintext){\r\n    return usePlaintext(true);\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.code.RestrictHeapAccessCallees.methodToKey",
	"Comment": "during analysis, the resolvedjavamethod parameter will be an analysismethod, but duringcompilation it will be a hostedmethod. since i am using the analysismethod as the key to themap, i get an analysismethod to use as the key.",
	"Method": "AnalysisMethod methodToKey(ResolvedJavaMethod method){\r\n    final AnalysisMethod result;\r\n    if (method instanceof AnalysisMethod) {\r\n        result = (AnalysisMethod) method;\r\n    } else if (method instanceof HostedMethod) {\r\n        result = ((HostedMethod) method).getWrapped();\r\n    } else {\r\n        throw VMError.shouldNotReachHere(\"RestrictHeapAccessCallees.methodToKey: ResolvedJavaMethod is neither an AnalysisMethod nor a HostedMethod: \" + method);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.instrumentation.test.InstrumentableNodeTest.testSimpleMaterializeSyntaxWithInput",
	"Comment": "directly instrument and materialize all nodes with input values.",
	"Method": "void testSimpleMaterializeSyntaxWithInput(){\r\n    SourceSectionFilter filter = SourceSectionFilter.newBuilder().tagIs(StandardTags.StatementTag.class, StandardTags.ExpressionTag.class).build();\r\n    instrumenter.attachExecutionEventFactory(filter, filter, factory);\r\n    execute(\"MATERIALIZE_CHILD_EXPRESSION\");\r\n    assertOn(ENTER, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof MaterializedChildExpressionNode);\r\n    });\r\n    assertOn(ENTER, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof ExpressionNode);\r\n    });\r\n    assertOn(RETURN_VALUE, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof ExpressionNode);\r\n    });\r\n    assertOn(INPUT_VALUE, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof MaterializedChildExpressionNode);\r\n    });\r\n    assertOn(RETURN_VALUE, (e) -> {\r\n        assertTrue(e.context.getInstrumentedNode() instanceof MaterializedChildExpressionNode);\r\n    });\r\n}"
}, {
	"Path": "io.grpc.alts.internal.NettyTsiHandshaker.createFrameProtector",
	"Comment": "creates a frame protector from a completed handshake. no other methods may be called after theframe protector is created.",
	"Method": "TsiFrameProtector createFrameProtector(int maxFrameSize,ByteBufAllocator alloc,TsiFrameProtector createFrameProtector,ByteBufAllocator alloc){\r\n    unwrapper = null;\r\n    return internalHandshaker.createFrameProtector(alloc);\r\n}"
}, {
	"Path": "com.google.gson.internal.bind.util.ISO8601Utils.checkOffset",
	"Comment": "check if the expected character exist at the given offset in the value.",
	"Method": "boolean checkOffset(String value,int offset,char expected){\r\n    return (offset < value.length()) && (value.charAt(offset) == expected);\r\n}"
}, {
	"Path": "io.grpc.internal.DelayedClientTransport.shutdownNow",
	"Comment": "shuts down this transport and cancels all streams that it owns, hence immediately terminatesthis transport.",
	"Method": "void shutdownNow(Status status){\r\n    shutdown(status);\r\n    Collection<PendingStream> savedPendingStreams;\r\n    Runnable savedReportTransportTerminated;\r\n    synchronized (lock) {\r\n        savedPendingStreams = pendingStreams;\r\n        savedReportTransportTerminated = reportTransportTerminated;\r\n        reportTransportTerminated = null;\r\n        if (!pendingStreams.isEmpty()) {\r\n            pendingStreams = Collections.<PendingStream>emptyList();\r\n        }\r\n    }\r\n    if (savedReportTransportTerminated != null) {\r\n        for (PendingStream stream : savedPendingStreams) {\r\n            stream.cancel(status);\r\n        }\r\n        syncContext.execute(savedReportTransportTerminated);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.graal.pointsto.meta.AnalysisField.getTypeState",
	"Comment": "returns all possible types that this field can have. the result is not context sensitive,i.e., it is a union of all types found in all contexts.",
	"Method": "TypeState getTypeState(){\r\n    if (getType().getStorageKind() != JavaKind.Object) {\r\n        return null;\r\n    } else if (isStatic()) {\r\n        return staticFieldFlow.getState();\r\n    } else {\r\n        return getInstanceFieldTypeState();\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.component.installer.commands.InstallerTest.testSetIgnoreFailedDeletions",
	"Comment": "checks that the uninstall does not fail even though it cannot delete something.",
	"Method": "void testSetIgnoreFailedDeletions(){\r\n    if (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\r\n        return;\r\n    }\r\n    setupComponentInstall(\"truffleruby2.jar\");\r\n    installer.setPermissions(loader.loadPermissions());\r\n    installer.setSymlinks(loader.loadSymlinks());\r\n    installer.install();\r\n    ComponentInfo savedInfo = installer.getComponentInfo();\r\n    Path p = targetPath.resolve(SystemUtils.fromCommonString(\"jre/languages/ruby/doc/legal\"));\r\n    Files.setPosixFilePermissions(p, PosixFilePermissions.fromString(\"r--r--r--\"));\r\n    Uninstaller uninstaller = new Uninstaller(fb(), savedInfo, registry);\r\n    uninstaller.setInstallPath(targetPath);\r\n    uninstaller.setIgnoreFailedDeletions(true);\r\n    uninstaller.uninstall();\r\n}"
}, {
	"Path": "com.google.common.collect.Iterators.concatNoDefensiveCopy",
	"Comment": "concats a varargs array of iterators without making a defensive copy of the array.",
	"Method": "Iterator<T> concatNoDefensiveCopy(Iterator<? extends T> inputs){\r\n    for (Iterator<? extends T> input : checkNotNull(inputs)) {\r\n        checkNotNull(input);\r\n    }\r\n    return concat(consumingForArray(inputs));\r\n}"
}, {
	"Path": "io.grpc.CompressorRegistry.getDefaultInstance",
	"Comment": "returns the default instance used by grpc when the registry is not specified.currently the registry just contains support for gzip.",
	"Method": "CompressorRegistry getDefaultInstance(){\r\n    return DEFAULT_INSTANCE;\r\n}"
}, {
	"Path": "io.grpc.internal.AbstractManagedChannelImplBuilder.checkAuthority",
	"Comment": "verifies the authority is valid.this method exists as an escape hatch for putting in anauthority that is valid, but would fail the default validation provided by thisimplementation.",
	"Method": "String checkAuthority(String authority){\r\n    return GrpcUtil.checkAuthority(authority);\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.NativeImageGenerator.recordMethodsWithStackValues",
	"Comment": "track methods that have a stack values. this is later used for deoptimization testing duringcompilation.",
	"Method": "void recordMethodsWithStackValues(){\r\n    bigbang.getUniverse().getMethods().parallelStream().forEach(analysisMethod -> {\r\n        if (analysisMethod.getTypeFlow() != null && analysisMethod.getTypeFlow().getGraph() != null && analysisMethod.getTypeFlow().getGraph().getNodes(StackValueNode.TYPE).isNotEmpty()) {\r\n            hUniverse.recordMethodWithStackValues(analysisMethod);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.oracle.svm.core.code.CodeInfoQueryResult.getExceptionOffset",
	"Comment": "returns the exception handler offset, i.e., the ip difference between the regular returnaddress and the exception handler entry point, for the ip.",
	"Method": "long getExceptionOffset(){\r\n    return exceptionOffset;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.PinnedObjectImpl.pushPinnedObject",
	"Comment": "push an element onto the list. may be called by many threads simultaneously, so it uses acompareandset loop.",
	"Method": "PinnedObjectImpl pushPinnedObject(PinnedObjectImpl newHead){\r\n    final Log trace = Log.noopLog().string(\"[PinnedObject.pushPinnedObject:\").string(\"  newHead: \").object(newHead);\r\n    final HeapImpl heap = HeapImpl.getHeapImpl();\r\n    final AtomicReference<PinnedObjectImpl> pinHead = heap.getPinHead();\r\n    PinnedObjectImpl sampleHead;\r\n    do {\r\n        sampleHead = pinHead.get();\r\n        newHead.setNext(sampleHead);\r\n    } while (!pinHead.compareAndSet(sampleHead, newHead));\r\n    trace.string(\"  returns: \").object(newHead).string(\"]\").newline();\r\n    return newHead;\r\n}"
}, {
	"Path": "com.google.gson.JsonElement.getAsInt",
	"Comment": "convenience method to get this element as a primitive integer value.",
	"Method": "int getAsInt(){\r\n    throw new UnsupportedOperationException(getClass().getSimpleName());\r\n}"
}, {
	"Path": "io.grpc.testing.integration.ReconnectTestClient.main",
	"Comment": "the main application allowing this client to be launched from the command line.",
	"Method": "void main(String[] args){\r\n    ReconnectTestClient client = new ReconnectTestClient();\r\n    client.parseArgs(args);\r\n    System.out.println(\"Starting test:\");\r\n    try {\r\n        client.runTest();\r\n        System.out.println(\"Finished successfully\");\r\n        System.exit(0);\r\n    } catch (Throwable e) {\r\n        e.printStackTrace();\r\n        System.err.println(\"Test failed!\");\r\n        System.exit(1);\r\n    }\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.OldGeneration.promoteObject",
	"Comment": "promote an object to tospace if it is not already in tospace or pinnedtospace.",
	"Method": "Object promoteObject(Object original){\r\n    final Log trace = Log.noopLog().string(\"[OldGeneration.promoteObject:\").string(\"  original: \").object(original).newline();\r\n    Object result;\r\n    if (ObjectHeaderImpl.getObjectHeaderImpl().isAlignedObject(original)) {\r\n        trace.string(\"  aligned header: \").hex(ObjectHeader.readHeaderFromObject(original)).newline();\r\n        result = promoteAlignedObject(original);\r\n    } else {\r\n        trace.string(\"  unaligned header: \").hex(ObjectHeader.readHeaderFromObject(original)).newline();\r\n        result = promoteUnalignedObjectChunk(original);\r\n    }\r\n    trace.string(\"  OldGeneration.promoteObject returns: \").object(result).string(\"]\").newline();\r\n    return result;\r\n}"
}, {
	"Path": "com.google.gson.internal.LinkedHashTreeMap.find",
	"Comment": "returns the node at or adjacent to the given key, creating it if requested.",
	"Method": "Node<K, V> find(K key,boolean create){\r\n    Comparator<? super K> comparator = this.comparator;\r\n    Node<K, V>[] table = this.table;\r\n    int hash = secondaryHash(key.hashCode());\r\n    int index = hash & (table.length - 1);\r\n    Node<K, V> nearest = table[index];\r\n    int comparison = 0;\r\n    if (nearest != null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Comparable<Object> comparableKey = (comparator == NATURAL_ORDER) ? (Comparable<Object>) key : null;\r\n        while (true) {\r\n            comparison = (comparableKey != null) ? comparableKey.compareTo(nearest.key) : comparator.compare(key, nearest.key);\r\n            if (comparison == 0) {\r\n                return nearest;\r\n            }\r\n            Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\r\n            if (child == null) {\r\n                break;\r\n            }\r\n            nearest = child;\r\n        }\r\n    }\r\n    if (!create) {\r\n        return null;\r\n    }\r\n    Node<K, V> header = this.header;\r\n    Node<K, V> created;\r\n    if (nearest == null) {\r\n        if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\r\n            throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\r\n        }\r\n        created = new Node<K, V>(nearest, key, hash, header, header.prev);\r\n        table[index] = created;\r\n    } else {\r\n        created = new Node<K, V>(nearest, key, hash, header, header.prev);\r\n        if (comparison < 0) {\r\n            nearest.left = created;\r\n        } else {\r\n            nearest.right = created;\r\n        }\r\n        rebalance(nearest, true);\r\n    }\r\n    if (size++ > threshold) {\r\n        doubleCapacity();\r\n    }\r\n    modCount++;\r\n    return created;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.nodes.NodeUtil.getNthParent",
	"Comment": "get the nth parent of a node, where the 0th parent is the node itself. returns null if thereare less than n ancestors.",
	"Method": "Node getNthParent(Node node,int n){\r\n    Node parent = node;\r\n    for (int i = 0; i < n; i++) {\r\n        parent = parent.getParent();\r\n        if (parent == null) {\r\n            return null;\r\n        }\r\n    }\r\n    return parent;\r\n}"
}, {
	"Path": "com.oracle.svm.core.thread.VMOperation.enqueueBlockingNoSafepoint",
	"Comment": "convenience method for thunks that can be run by allocating a vmoperation.",
	"Method": "void enqueueBlockingNoSafepoint(String name,Thunk thunk){\r\n    ThunkOperation vmOperation = new ThunkOperation(name, CallerEffect.BLOCKS_CALLER, SystemEffect.DOES_NOT_CAUSE_SAFEPOINT, thunk);\r\n    vmOperation.enqueue();\r\n}"
}, {
	"Path": "com.oracle.truffle.api.nodes.RootNode.isInstrumentable",
	"Comment": "does this contain ast content that it is possible to instrument. can be called on any threadand without a language context.",
	"Method": "boolean isInstrumentable(){\r\n    return true;\r\n}"
}, {
	"Path": "com.oracle.truffle.api.debug.test.DebugScopeTest.testTopScope",
	"Comment": "local scopes are well tested by debugstackframetest and others.",
	"Method": "void testTopScope(){\r\n    final Source source = testSource(\"ROOT(DEFINE(function1,ROOT(\\n\" + \"  EXPRESSION()\\n\" + \"  )\\n\" + \"),\\n\" + \"DEFINE(g,ROOT(\\n\" + \"  EXPRESSION()\\n\" + \"  )\\n\" + \"),\\n\" + \"STATEMENT())\\n\");\r\n    try (DebuggerSession session = startSession()) {\r\n        session.suspendNextExecution();\r\n        startEval(source);\r\n        expectSuspended((SuspendedEvent event) -> {\r\n            DebugScope topScope = session.getTopScope(event.getSourceSection().getSource().getLanguage());\r\n            assertNotNull(topScope);\r\n            DebugValue function1 = topScope.getDeclaredValue(\"function1\");\r\n            assertNotNull(function1);\r\n            assertTrue(function1.as(String.class).contains(\"Function\"));\r\n            DebugValue functionType = function1.getMetaObject();\r\n            assertEquals(\"Function\", functionType.as(String.class));\r\n            assertEquals(function1.getOriginalLanguage(), functionType.getOriginalLanguage());\r\n            DebugValue g = topScope.getDeclaredValue(\"g\");\r\n            assertNotNull(g);\r\n            assertTrue(g.as(String.class).contains(\"Function\"));\r\n        });\r\n        expectDone();\r\n    }\r\n}"
}, {
	"Path": "io.grpc.internal.MessageFramer.writeBufferChain",
	"Comment": "write a message that has been serialized to a sequence of buffers.",
	"Method": "void writeBufferChain(BufferChainOutputStream bufferChain,boolean compressed){\r\n    ByteBuffer header = ByteBuffer.wrap(headerScratch);\r\n    header.put(compressed ? COMPRESSED : UNCOMPRESSED);\r\n    int messageLength = bufferChain.readableBytes();\r\n    header.putInt(messageLength);\r\n    WritableBuffer writeableHeader = bufferAllocator.allocate(HEADER_LENGTH);\r\n    writeableHeader.write(headerScratch, 0, header.position());\r\n    if (messageLength == 0) {\r\n        buffer = writeableHeader;\r\n        return;\r\n    }\r\n    sink.deliverFrame(writeableHeader, false, false, messagesBuffered - 1);\r\n    messagesBuffered = 1;\r\n    List<WritableBuffer> bufferList = bufferChain.bufferList;\r\n    for (int i = 0; i < bufferList.size() - 1; i++) {\r\n        sink.deliverFrame(bufferList.get(i), false, false, 0);\r\n    }\r\n    buffer = bufferList.get(bufferList.size() - 1);\r\n    currentMessageWireSize = messageLength;\r\n}"
}, {
	"Path": "io.grpc.ManagedChannelBuilder.perRpcBufferLimit",
	"Comment": "sets the per rpc buffer limit in bytes used for retry. the rpc is not retriable if its bufferlimit is exceeded. the implementation may only estimate the buffer size being used rather thancount the exact physical memory allocated. it does not have any effect if retry is disabled bythe client.this method may not work as expected for the current release because retry is not fullyimplemented yet.",
	"Method": "T perRpcBufferLimit(long bytes){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.oracle.truffle.polyglot.PolyglotContextImpl.resetSingleContextState",
	"Comment": "used from testing using reflection. its invalid to call it anywhere else than testing. usedin contextlookupcompilationtest.",
	"Method": "void resetSingleContextState(){\r\n    singleContextState = new SingleContextState();\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.NativeImageGeneratorRunner.reportFatalError",
	"Comment": "reports an unexpected error caused by a crash in the svm image builder.",
	"Method": "void reportFatalError(Throwable e){\r\n    System.err.print(\"fatal error: \");\r\n    e.printStackTrace();\r\n}"
}, {
	"Path": "org.graalvm.component.installer.commands.InstallerTest.testFailedDeletionAborts",
	"Comment": "checks that the uninstall does not fail even though it cannot delete something.",
	"Method": "void testFailedDeletionAborts(){\r\n    if (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\r\n        return;\r\n    }\r\n    setupComponentInstall(\"truffleruby2.jar\");\r\n    installer.setPermissions(loader.loadPermissions());\r\n    installer.setSymlinks(loader.loadSymlinks());\r\n    installer.install();\r\n    ComponentInfo savedInfo = installer.getComponentInfo();\r\n    Path p = targetPath.resolve(SystemUtils.fromCommonString(\"jre/languages/ruby/doc/legal\"));\r\n    Files.setPosixFilePermissions(p, PosixFilePermissions.fromString(\"r--r--r--\"));\r\n    Uninstaller uninstaller = new Uninstaller(fb(), savedInfo, registry);\r\n    uninstaller.setInstallPath(targetPath);\r\n    exception.expect(IOException.class);\r\n    uninstaller.uninstall();\r\n}"
}, {
	"Path": "com.oracle.svm.hosted.code.CompileQueue.canDeoptForTesting",
	"Comment": "returns true if a method should be considered as deoptimization source. this is only afeature for testing. note that usually all image compiled methods cannot deoptimize.",
	"Method": "boolean canDeoptForTesting(HostedMethod method){\r\n    if (method.getName().equals(\"<clinit>\")) {\r\n        return false;\r\n    }\r\n    if (method.getAnnotation(DeoptTest.class) != null) {\r\n        return true;\r\n    }\r\n    if (method.isEntryPoint()) {\r\n        return false;\r\n    }\r\n    if (method.isNative()) {\r\n        return false;\r\n    }\r\n    if (method.wrapped.isIntrinsicMethod()) {\r\n        return false;\r\n    }\r\n    if (method.getAnnotation(Uninterruptible.class) != null) {\r\n        return false;\r\n    }\r\n    if (method.getAnnotation(RestrictHeapAccess.class) != null) {\r\n        return false;\r\n    }\r\n    if (universe.getMethodsWithStackValues().contains(method.wrapped)) {\r\n        return false;\r\n    }\r\n    if (deoptimizeAll) {\r\n        String className = method.getDeclaringClass().getName();\r\n        if (className.contains(\"/svm/core/code/CodeInfoEncoder\") || className.contains(\"com/oracle/svm/core/heap/\") || className.contains(\"com/oracle/svm/core/genscavenge/\") || className.contains(\"debug/internal/DebugValueMap\") && method.getName().equals(\"registerTopLevel\")) {\r\n            return false;\r\n        }\r\n        if (method.getCode() == null) {\r\n            return false;\r\n        }\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "io.grpc.internal.FakeClock.runDueTasks",
	"Comment": "run all due tasks. immediately due tasks that are queued during the process also get executed.",
	"Method": "int runDueTasks(){\r\n    int count = 0;\r\n    while (true) {\r\n        checkDueTasks();\r\n        if (dueTasks.isEmpty()) {\r\n            break;\r\n        }\r\n        ScheduledTask task;\r\n        while ((task = dueTasks.poll()) != null) {\r\n            task.command.run();\r\n            task.complete();\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.google.gson.JsonElement.isJsonArray",
	"Comment": "provides check for verifying if this element is an array or not.",
	"Method": "boolean isJsonArray(){\r\n    return this instanceof JsonArray;\r\n}"
}, {
	"Path": "com.google.gson.stream.JsonReader.beginObject",
	"Comment": "consumes the next token from the json stream and asserts that it is thebeginning of a new object.",
	"Method": "void beginObject(){\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    if (p == PEEKED_BEGIN_OBJECT) {\r\n        push(JsonScope.EMPTY_OBJECT);\r\n        peeked = PEEKED_NONE;\r\n    } else {\r\n        throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + locationString());\r\n    }\r\n}"
}, {
	"Path": "io.grpc.netty.NettyChannelBuilder.withOption",
	"Comment": "specifies a channel option. as the underlying channel as well as network implementation mayignore this value applications should consider it a hint.",
	"Method": "NettyChannelBuilder withOption(ChannelOption<T> option,T value){\r\n    channelOptions.put(option, value);\r\n    return this;\r\n}"
}, {
	"Path": "com.oracle.svm.core.genscavenge.UnalignedHeapChunk.getChunkSizeForObject",
	"Comment": "how large an unalignedheapchunk is needed to hold an object of the given size?",
	"Method": "UnsignedWord getChunkSizeForObject(UnsignedWord objectSize){\r\n    final UnsignedWord objectStart = getObjectStartOffset();\r\n    final UnsignedWord alignment = WordFactory.unsigned(ConfigurationValues.getObjectLayout().getAlignment());\r\n    final UnsignedWord result = UnsignedUtils.roundUp(objectStart.add(objectSize), alignment);\r\n    return result;\r\n}"
}, {
	"Path": "io.grpc.stub.MetadataUtils.captureMetadata",
	"Comment": "captures the last received metadata for a stub. useful for testing",
	"Method": "T captureMetadata(T stub,AtomicReference<Metadata> headersCapture,AtomicReference<Metadata> trailersCapture){\r\n    return stub.withInterceptors(newCaptureMetadataInterceptor(headersCapture, trailersCapture));\r\n}"
}, {
	"Path": "io.grpc.testing.integration.CascadingTest.testCascadingCancellationViaLeafFailure",
	"Comment": "test that when rpc cancellation propagates up a call chain, the cancellation of the parentrpc triggers cancellation of all of its children.",
	"Method": "void testCascadingCancellationViaLeafFailure(){\r\n    observedCancellations = new CountDownLatch(11);\r\n    receivedCancellations = new CountDownLatch(11);\r\n    startCallTreeServer(3);\r\n    try {\r\n        blockingStub.unaryCall(Messages.SimpleRequest.newBuilder().setResponseSize(3).build());\r\n        fail(\"Expected abort\");\r\n    } catch (StatusRuntimeException sre) {\r\n        Status status = sre.getStatus();\r\n        assertEquals(Status.Code.ABORTED, status.getCode());\r\n        if (!observedCancellations.await(5, TimeUnit.SECONDS)) {\r\n            fail(\"Expected number of cancellations not observed by clients\");\r\n        }\r\n        if (!receivedCancellations.await(5, TimeUnit.SECONDS)) {\r\n            fail(\"Expected number of cancellations to be received by servers not observed\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.graalvm.component.installer.persist.DirectoryStorageTest.testUpdateReplacedFilesEmpty",
	"Comment": "test of updatereplacedfiles method, of class registrystorage.",
	"Method": "void testUpdateReplacedFilesEmpty(){\r\n    Map<String, Collection<String>> files = new HashMap();\r\n    Path goldenPath = dataFile(\"golden-replaced-files.properties\");\r\n    Path regPath = registryPath.resolve(SystemUtils.fileName(\"replaced-files.properties\"));\r\n    Files.copy(goldenPath, regPath, StandardCopyOption.REPLACE_EXISTING);\r\n    storage.updateReplacedFiles(files);\r\n    assertFalse(Files.exists(regPath));\r\n    storage.updateReplacedFiles(files);\r\n    assertFalse(Files.exists(regPath));\r\n}"
}, {
	"Path": "io.grpc.okhttp.internal.ConnectionSpec.nonEmptyIntersection",
	"Comment": "m intersection that terminates if any intersection is found. the sizes of botharguments are assumed to be so small, and the likelihood of an intersection so great, that itis not worth the cpu cost of sorting or the memory cost of hashing.",
	"Method": "boolean nonEmptyIntersection(String[] a,String[] b){\r\n    if (a == null || b == null || a.length == 0 || b.length == 0) {\r\n        return false;\r\n    }\r\n    for (String toFind : a) {\r\n        if (contains(b, toFind)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}]