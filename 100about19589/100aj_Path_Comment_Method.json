[{
	"Path": "org.apache.dubbo.common.utils.ConcurrentHashSet.iterator",
	"Comment": "returns an iterator over the elements in this set. the elements arereturned in no particular order.",
	"Method": "Iterator<E> iterator(){\r\n    return map.keySet().iterator();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableListMultimap.removeAll",
	"Comment": "guaranteed to throw an exception and leave the multimap unmodified.",
	"Method": "ImmutableList<V> removeAll(Object key){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.net.InetAddresses.getCompatIPv4Address",
	"Comment": "returns the ipv4 address embedded in an ipv4 compatible address.",
	"Method": "Inet4Address getCompatIPv4Address(Inet6Address ip){\r\n    checkArgument(isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\r\n    return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\r\n}"
}, {
	"Path": "com.google.inject.internal.SpiUtils.index",
	"Comment": "returns the subset of elements that have keys, indexed by them.",
	"Method": "Map<Key<?>, Binding<?>> index(Iterable<Element> elements){\r\n    ImmutableMap.Builder<Key<?>, Binding<?>> builder = ImmutableMap.builder();\r\n    for (Element element : elements) {\r\n        if (element instanceof Binding) {\r\n            builder.put(((Binding) element).getKey(), (Binding) element);\r\n        }\r\n    }\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultiset.of",
	"Comment": "returns an immutable multiset containing the given elements, in order.",
	"Method": "ImmutableMultiset<E> of(ImmutableMultiset<E> of,E element,ImmutableMultiset<E> of,E e1,E e2,ImmutableMultiset<E> of,E e1,E e2,E e3,ImmutableMultiset<E> of,E e1,E e2,E e3,E e4,ImmutableMultiset<E> of,E e1,E e2,E e3,E e4,E e5,ImmutableMultiset<E> of,E e1,E e2,E e3,E e4,E e5,E e6,E others){\r\n    return new Builder<E>().add(e1).add(e2).add(e3).add(e4).add(e5).add(e6).add(others).build();\r\n}"
}, {
	"Path": "com.google.common.hash.LittleEndianByteArray.load32",
	"Comment": "load 4 bytes from the provided array at the indicated offset.",
	"Method": "int load32(byte[] source,int offset){\r\n    return (source[offset] & 0xFF) | ((source[offset + 1] & 0xFF) << 8) | ((source[offset + 2] & 0xFF) << 16) | ((source[offset + 3] & 0xFF) << 24);\r\n}"
}, {
	"Path": "org.apache.dubbo.common.concurrent.ExecutionList.execute",
	"Comment": "runs this execution list, executing all existing pairs in the order theywere added. however, note that listeners added after this point may beexecuted before those previously added, and note that the execution orderof all listeners is ultimately chosen by the implementations of thesupplied executors.this method is idempotent. calling it several times in parallel issemantically equivalent to calling it exactly once.",
	"Method": "void execute(){\r\n    RunnableExecutorPair list;\r\n    synchronized (this) {\r\n        if (executed) {\r\n            return;\r\n        }\r\n        executed = true;\r\n        list = runnables;\r\n        runnables = null;\r\n    }\r\n    RunnableExecutorPair reversedList = null;\r\n    while (list != null) {\r\n        RunnableExecutorPair tmp = list;\r\n        list = list.next;\r\n        tmp.next = reversedList;\r\n        reversedList = tmp;\r\n    }\r\n    while (reversedList != null) {\r\n        executeListener(reversedList.runnable, reversedList.executor);\r\n        reversedList = reversedList.next;\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultimap.removeAll",
	"Comment": "guaranteed to throw an exception and leave the multimap unmodified.",
	"Method": "ImmutableCollection<V> removeAll(Object key){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.inject.internal.Messages.create",
	"Comment": "creates a new message with the given cause and a binding source stack.",
	"Method": "Message create(String messageFormat,Object arguments,Message create,Throwable cause,String messageFormat,Object arguments,Message create,Throwable cause,List<Object> sources,String messageFormat,Object arguments){\r\n    String message = format(messageFormat, arguments);\r\n    return new Message(sources, message, cause);\r\n}"
}, {
	"Path": "com.google.inject.persist.jpa.JpaPersistModule.properties",
	"Comment": "configures the jpa persistence provider with a set of properties.",
	"Method": "JpaPersistModule properties(Map<?, ?> properties){\r\n    this.properties = properties;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.common.collect.testing.features.FeatureUtil.getTesterAnnotations",
	"Comment": "find all the tester annotations declared on a tester class or method.",
	"Method": "Iterable<Annotation> getTesterAnnotations(AnnotatedElement classOrMethod){\r\n    synchronized (annotationCache) {\r\n        List<Annotation> annotations = annotationCache.get(classOrMethod);\r\n        if (annotations == null) {\r\n            annotations = new ArrayList();\r\n            for (Annotation a : classOrMethod.getDeclaredAnnotations()) {\r\n                if (a.annotationType().isAnnotationPresent(TesterAnnotation.class)) {\r\n                    annotations.add(a);\r\n                }\r\n            }\r\n            annotations = Collections.unmodifiableList(annotations);\r\n            annotationCache.put(classOrMethod, annotations);\r\n        }\r\n        return annotations;\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.ListenableFutureTask.done",
	"Comment": "internal implementation detail used to invoke the listeners.",
	"Method": "void done(){\r\n    executionList.execute();\r\n}"
}, {
	"Path": "org.apache.dubbo.common.extension.ExtensionLoader.getDefaultExtensionName",
	"Comment": "return default extension name, return null if not configured.",
	"Method": "String getDefaultExtensionName(){\r\n    getExtensionClasses();\r\n    return cachedDefaultName;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AtomicDoubleArrayTest.testConstructor",
	"Comment": "constructor creates array of given size with all elements zero",
	"Method": "void testConstructor(){\r\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\r\n    for (int i = 0; i < SIZE; i++) {\r\n        assertBitEquals(0.0, aa.get(i));\r\n    }\r\n}"
}, {
	"Path": "com.google.common.primitives.ImmutableLongArray.copyOf",
	"Comment": "returns an immutable array containing the given values, in order.",
	"Method": "ImmutableLongArray copyOf(long[] values,ImmutableLongArray copyOf,Collection<Long> values,ImmutableLongArray copyOf,Iterable<Long> values,ImmutableLongArray copyOf,LongStream stream){\r\n    long[] array = stream.toArray();\r\n    return (array.length == 0) ? EMPTY : new ImmutableLongArray(array);\r\n}"
}, {
	"Path": "com.google.common.collect.testing.google.UnmodifiableCollectionTests.assertIteratorsInOrder",
	"Comment": "asserts that two iterators contain elements in tandem.this test only works with iterators that iterate over a finite set.",
	"Method": "void assertIteratorsInOrder(Iterator<?> expectedIterator,Iterator<?> actualIterator){\r\n    int i = 0;\r\n    while (expectedIterator.hasNext()) {\r\n        Object expected = expectedIterator.next();\r\n        assertTrue(\"index \" + i + \" expected <\" + expected + \"., actual is exhausted\", actualIterator.hasNext());\r\n        Object actual = actualIterator.next();\r\n        assertEquals(\"index \" + i, expected, actual);\r\n        i++;\r\n    }\r\n    if (actualIterator.hasNext()) {\r\n        fail(\"index \" + i + \", expected is exhausted, actual <\" + actualIterator.next() + \">\");\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.MonitorBasedPriorityBlockingQueue.put",
	"Comment": "inserts the specified element into this priority queue. as the queue is unbounded this methodwill never block.",
	"Method": "void put(E e){\r\n    offer(e);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableBiMap.forcePut",
	"Comment": "guaranteed to throw an exception and leave the bimap unmodified.",
	"Method": "V forcePut(K key,V value){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.zaxxer.hikari.util.UtilityElf.safeIsAssignableFrom",
	"Comment": "checks whether an object is an instance of given type without throwing exception when the class is not loaded.",
	"Method": "boolean safeIsAssignableFrom(Object obj,String className){\r\n    try {\r\n        Class<?> clazz = Class.forName(className);\r\n        return clazz.isAssignableFrom(obj.getClass());\r\n    } catch (ClassNotFoundException ignored) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.GeneralRange.range",
	"Comment": "returns everything between the endpoints relative to the specified comparator, with thespecified endpoint behavior.",
	"Method": "GeneralRange<T> range(Comparator<? super T> comparator,T lower,BoundType lowerType,T upper,BoundType upperType){\r\n    return new GeneralRange<T>(comparator, true, lower, lowerType, true, upper, upperType);\r\n}"
}, {
	"Path": "com.google.common.collect.MapMakerInternalMap.getEntry",
	"Comment": "returns the internal entry for the specified key. the entry may be computing or partiallycollected. does not impact recency ordering.",
	"Method": "E getEntry(E getEntry,E getEntry,Object key,int hash,E getEntry,Object key){\r\n    if (key == null) {\r\n        return null;\r\n    }\r\n    int hash = hash(key);\r\n    return segmentFor(hash).getEntry(key, hash);\r\n}"
}, {
	"Path": "com.google.common.collect.ConcurrentHashMultiset.add",
	"Comment": "adds a number of occurrences of the specified element to this multiset.",
	"Method": "int add(E element,int occurrences){\r\n    checkNotNull(element);\r\n    if (occurrences == 0) {\r\n        return count(element);\r\n    }\r\n    CollectPreconditions.checkPositive(occurrences, \"occurences\");\r\n    while (true) {\r\n        AtomicInteger existingCounter = Maps.safeGet(countMap, element);\r\n        if (existingCounter == null) {\r\n            existingCounter = countMap.putIfAbsent(element, new AtomicInteger(occurrences));\r\n            if (existingCounter == null) {\r\n                return 0;\r\n            }\r\n        }\r\n        while (true) {\r\n            int oldValue = existingCounter.get();\r\n            if (oldValue != 0) {\r\n                try {\r\n                    int newValue = IntMath.checkedAdd(oldValue, occurrences);\r\n                    if (existingCounter.compareAndSet(oldValue, newValue)) {\r\n                        return oldValue;\r\n                    }\r\n                } catch (ArithmeticException overflow) {\r\n                    throw new IllegalArgumentException(\"Overflow adding \" + occurrences + \" occurrences to a count of \" + oldValue);\r\n                }\r\n            } else {\r\n                AtomicInteger newCounter = new AtomicInteger(occurrences);\r\n                if ((countMap.putIfAbsent(element, newCounter) == null) || countMap.replace(element, existingCounter, newCounter)) {\r\n                    return 0;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.base.PreconditionsTest.allSignatures",
	"Comment": "returns a list of parameters for invoking an overload of checkstate, checkargument orchecknotnull",
	"Method": "ImmutableList<ImmutableList<Class<?>>> allSignatures(Class<?> predicateType){\r\n    ImmutableSet.Builder<ImmutableList<Class<?>>> allOverloads = ImmutableSet.builder();\r\n    allOverloads.add(ImmutableList.<Class<?>>of(predicateType));\r\n    allOverloads.add(ImmutableList.<Class<?>>of(predicateType, Object.class));\r\n    List<List<Class<?>>> typesLists = new ArrayList();\r\n    for (int i = 0; i < 2; i++) {\r\n        typesLists.add(possibleParamTypes);\r\n        for (List<Class<?>> curr : Lists.cartesianProduct(typesLists)) {\r\n            allOverloads.add(// the format string\r\n            ImmutableList.<Class<?>>builder().add(predicateType).add(String.class).addAll(curr).build());\r\n        }\r\n    }\r\n    return allOverloads.build().asList();\r\n}"
}, {
	"Path": "com.google.inject.internal.Scoping.isNoScope",
	"Comment": "returns true if this is the default scope. in this case a new instance will be provided foreach injection.",
	"Method": "boolean isNoScope(){\r\n    return getScopeInstance() == Scopes.NO_SCOPE;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AtomicDouble.compareAndSet",
	"Comment": "atomically sets the value to the given updated value if the current value is bitwise equal to the expected value.",
	"Method": "boolean compareAndSet(double expect,double update){\r\n    return updater.compareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.JSR166TestCase.newStartedThread",
	"Comment": "returns a new started daemon thread running the given runnable.",
	"Method": "Thread newStartedThread(Runnable runnable){\r\n    Thread t = new Thread(runnable);\r\n    t.setDaemon(true);\r\n    t.start();\r\n    return t;\r\n}"
}, {
	"Path": "com.google.common.cache.CacheBuilder.toString",
	"Comment": "returns a string representation for this cachebuilder instance. the exact form of the returnedstring is not specified.",
	"Method": "String toString(){\r\n    MoreObjects.ToStringHelper s = MoreObjects.toStringHelper(this);\r\n    if (initialCapacity != UNSET_INT) {\r\n        s.add(\"initialCapacity\", initialCapacity);\r\n    }\r\n    if (concurrencyLevel != UNSET_INT) {\r\n        s.add(\"concurrencyLevel\", concurrencyLevel);\r\n    }\r\n    if (maximumSize != UNSET_INT) {\r\n        s.add(\"maximumSize\", maximumSize);\r\n    }\r\n    if (maximumWeight != UNSET_INT) {\r\n        s.add(\"maximumWeight\", maximumWeight);\r\n    }\r\n    if (expireAfterWriteNanos != UNSET_INT) {\r\n        s.add(\"expireAfterWrite\", expireAfterWriteNanos + \"ns\");\r\n    }\r\n    if (expireAfterAccessNanos != UNSET_INT) {\r\n        s.add(\"expireAfterAccess\", expireAfterAccessNanos + \"ns\");\r\n    }\r\n    if (keyStrength != null) {\r\n        s.add(\"keyStrength\", Ascii.toLowerCase(keyStrength.toString()));\r\n    }\r\n    if (valueStrength != null) {\r\n        s.add(\"valueStrength\", Ascii.toLowerCase(valueStrength.toString()));\r\n    }\r\n    if (keyEquivalence != null) {\r\n        s.addValue(\"keyEquivalence\");\r\n    }\r\n    if (valueEquivalence != null) {\r\n        s.addValue(\"valueEquivalence\");\r\n    }\r\n    if (removalListener != null) {\r\n        s.addValue(\"removalListener\");\r\n    }\r\n    return s.toString();\r\n}"
}, {
	"Path": "com.google.common.reflect.ImmutableTypeToInstanceMap.putAll",
	"Comment": "guaranteed to throw an exception and leave the map unmodified.",
	"Method": "void putAll(Map<? extends TypeToken<? extends B>, ? extends B> map){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.inject.spi.Dependency.getKey",
	"Comment": "returns the key to the binding that satisfies this dependency.",
	"Method": "Key<T> getKey(){\r\n    return this.key;\r\n}"
}, {
	"Path": "com.google.common.collect.testing.testers.NavigableSetNavigationTester.resetWithHole",
	"Comment": "resets the contents of navigableset to have elements a, c, for the navigation tests.",
	"Method": "void resetWithHole(){\r\n    super.resetContainer(getSubjectGenerator().create(a, c));\r\n    navigableSet = (NavigableSet<E>) getSet();\r\n}"
}, {
	"Path": "com.zaxxer.hikari.util.ConcurrentBag.getCount",
	"Comment": "get a count of the number of items in the specified state at the time of this call.",
	"Method": "int getCount(int state){\r\n    int count = 0;\r\n    for (IConcurrentBagEntry e : sharedList) {\r\n        if (e.getState() == state) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.zaxxer.hikari.pool.HikariPool.throwPoolInitializationException",
	"Comment": "log the throwable that caused pool initialization to fail, and then throw a poolinitializationexception with that cause attached.",
	"Method": "void throwPoolInitializationException(Throwable t){\r\n    logger.error(\"{} - Exception during pool initialization.\", poolName, t);\r\n    destroyHouseKeepingExecutorService();\r\n    throw new PoolInitializationException(t);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.enterIfInterruptibly",
	"Comment": "enters this monitor if the guard is satisfied. blocks at most the given time acquiring thelock, but does not wait for the guard to be satisfied, and may be interrupted.",
	"Method": "boolean enterIfInterruptibly(Guard guard,boolean enterIfInterruptibly,Guard guard,long time,TimeUnit unit){\r\n    if (guard.monitor != this) {\r\n        throw new IllegalMonitorStateException();\r\n    }\r\n    final ReentrantLock lock = this.lock;\r\n    if (!lock.tryLock(time, unit)) {\r\n        return false;\r\n    }\r\n    boolean satisfied = false;\r\n    try {\r\n        return satisfied = guard.isSatisfied();\r\n    } finally {\r\n        if (!satisfied) {\r\n            lock.unlock();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.dubbo.common.timer.HashedWheelTimer.start",
	"Comment": "starts the background thread explicitly.the background thread willstart automatically on demand even if you did not call this method.",
	"Method": "void start(){\r\n    switch(WORKER_STATE_UPDATER.get(this)) {\r\n        case WORKER_STATE_INIT:\r\n            if (WORKER_STATE_UPDATER.compareAndSet(this, WORKER_STATE_INIT, WORKER_STATE_STARTED)) {\r\n                workerThread.start();\r\n            }\r\n            break;\r\n        case WORKER_STATE_STARTED:\r\n            break;\r\n        case WORKER_STATE_SHUTDOWN:\r\n            throw new IllegalStateException(\"cannot be started once stopped\");\r\n        default:\r\n            throw new Error(\"Invalid WorkerState\");\r\n    }\r\n    while (startTime == 0) {\r\n        try {\r\n            startTimeInitialized.await();\r\n        } catch (InterruptedException ignore) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.LinkedListMultimap.checkElement",
	"Comment": "helper method for verifying that an iterator element is present.",
	"Method": "void checkElement(Object node){\r\n    if (node == null) {\r\n        throw new NoSuchElementException();\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.remainingNanos",
	"Comment": "returns the remaining nanos until the given timeout, or 0l if the timeout has already elapsed.caller must have previously sanitized timeoutnanos using tosafenanos.",
	"Method": "long remainingNanos(long startTime,long timeoutNanos){\r\n    return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\r\n}"
}, {
	"Path": "com.google.common.math.IntMathTest.testLog10MatchesBigInteger",
	"Comment": "relies on the correctness of bigintegermath.log10 for all modes except unnecessary.",
	"Method": "void testLog10MatchesBigInteger(){\r\n    for (int x : POSITIVE_INTEGER_CANDIDATES) {\r\n        for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\r\n            assertEquals(BigIntegerMath.log10(valueOf(x), mode), IntMath.log10(x, mode));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSet.maxRunBeforeFallback",
	"Comment": "if more than this many consecutive positions are filled in a table of the specified size,report probable hash flooding.",
	"Method": "int maxRunBeforeFallback(int tableSize){\r\n    return MAX_RUN_MULTIPLIER * IntMath.log2(tableSize, RoundingMode.UNNECESSARY);\r\n}"
}, {
	"Path": "com.google.inject.internal.ConstructorBindingImpl.hasAtInject",
	"Comment": "returns true if the inject annotation is on the constructor.",
	"Method": "boolean hasAtInject(Constructor cxtor){\r\n    return cxtor.isAnnotationPresent(Inject.class) || cxtor.isAnnotationPresent(javax.inject.Inject.class);\r\n}"
}, {
	"Path": "com.google.inject.internal.OptionalBinderTest.testKeyHashCodesFixedAtInjectionTime",
	"Comment": "ensure key hash codes are fixed at injection time, not binding time.",
	"Method": "void testKeyHashCodesFixedAtInjectionTime(){\r\n    Module m = new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            OptionalBinder<List<String>> b = OptionalBinder.newOptionalBinder(binder(), listOfStrings);\r\n            List<String> list = Lists.newArrayList();\r\n            b.setDefault().toInstance(list);\r\n            b.setBinding().toInstance(list);\r\n            list.add(\"A\");\r\n            list.add(\"B\");\r\n        }\r\n    };\r\n    Injector injector = Guice.createInjector(m);\r\n    for (Entry<Key<?>, Binding<?>> entry : injector.getAllBindings().entrySet()) {\r\n        Key<?> bindingKey = entry.getKey();\r\n        Key<?> clonedKey;\r\n        if (bindingKey.getAnnotation() != null) {\r\n            clonedKey = Key.get(bindingKey.getTypeLiteral(), bindingKey.getAnnotation());\r\n        } else if (bindingKey.getAnnotationType() != null) {\r\n            clonedKey = Key.get(bindingKey.getTypeLiteral(), bindingKey.getAnnotationType());\r\n        } else {\r\n            clonedKey = Key.get(bindingKey.getTypeLiteral());\r\n        }\r\n        assertEquals(bindingKey, clonedKey);\r\n        assertEquals(\"Incorrect hashcode for \" + bindingKey + \" -> \" + entry.getValue(), bindingKey.hashCode(), clonedKey.hashCode());\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.internal.OptionalBinderTest.testKeyHashCodesFixedAtInjectionTime",
	"Comment": "ensure key hash codes are fixed at injection time, not binding time.",
	"Method": "void testKeyHashCodesFixedAtInjectionTime(){\r\n    OptionalBinder<List<String>> b = OptionalBinder.newOptionalBinder(binder(), listOfStrings);\r\n    List<String> list = Lists.newArrayList();\r\n    b.setDefault().toInstance(list);\r\n    b.setBinding().toInstance(list);\r\n    list.add(\"A\");\r\n    list.add(\"B\");\r\n}"
}, {
	"Path": "com.google.common.math.IntMathTest.testSqrtMatchesBigInteger",
	"Comment": "relies on the correctness of bigintegermath.sqrt for all modes except unnecessary.",
	"Method": "void testSqrtMatchesBigInteger(){\r\n    for (int x : POSITIVE_INTEGER_CANDIDATES) {\r\n        for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\r\n            assertEquals(BigIntegerMath.sqrt(valueOf(x), mode), valueOf(IntMath.sqrt(x, mode)));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ObjectArrays.concat",
	"Comment": "returns a new array that contains the concatenated contents of two arrays.",
	"Method": "T[] concat(T[] first,T[] second,Class<T> type,T[] concat,T element,T[] array,T[] concat,T[] array,T element){\r\n    T[] result = Arrays.copyOf(array, array.length + 1);\r\n    result[array.length] = element;\r\n    return result;\r\n}"
}, {
	"Path": "com.google.common.testing.ClassSanityTester.getFactories",
	"Comment": "factories with the least number of parameters are listed first.",
	"Method": "ImmutableList<Invokable<?, ? extends T>> getFactories(TypeToken<T> type){\r\n    List<Invokable<?, ? extends T>> factories = Lists.newArrayList();\r\n    for (Method method : type.getRawType().getDeclaredMethods()) {\r\n        Invokable<?, ?> invokable = type.method(method);\r\n        if (!invokable.isPrivate() && !invokable.isSynthetic() && invokable.isStatic() && type.isSupertypeOf(invokable.getReturnType())) {\r\n            @SuppressWarnings(\"unchecked\")\r\n            Invokable<?, ? extends T> factory = (Invokable<?, ? extends T>) invokable;\r\n            factories.add(factory);\r\n        }\r\n    }\r\n    if (!Modifier.isAbstract(type.getRawType().getModifiers())) {\r\n        for (Constructor<?> constructor : type.getRawType().getDeclaredConstructors()) {\r\n            Invokable<T, T> invokable = type.constructor(constructor);\r\n            if (!invokable.isPrivate() && !invokable.isSynthetic()) {\r\n                factories.add(invokable);\r\n            }\r\n        }\r\n    }\r\n    for (Invokable<?, ?> factory : factories) {\r\n        factory.setAccessible(true);\r\n    }\r\n    return BY_NUMBER_OF_PARAMETERS.compound(BY_METHOD_NAME).compound(BY_PARAMETERS).immutableSortedCopy(factories);\r\n}"
}, {
	"Path": "com.google.common.math.LongMathTest.testLog2MatchesBigInteger",
	"Comment": "relies on the correctness of bigintegermath.log2 for all modes except unnecessary.",
	"Method": "void testLog2MatchesBigInteger(){\r\n    for (long x : POSITIVE_LONG_CANDIDATES) {\r\n        for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\r\n            assertEquals(BigIntegerMath.log2(valueOf(x), mode), LongMath.log2(x, mode));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.FuturesTest.testAllAsList_logging_multipleExceptions_alreadyDone",
	"Comment": "all as list will log extra exceptions that have already occurred.",
	"Method": "void testAllAsList_logging_multipleExceptions_alreadyDone(){\r\n    try {\r\n        getDone(allAsList(immediateFailedFuture(new MyException()), immediateFailedFuture(new MyException())));\r\n        fail();\r\n    } catch (ExecutionException expected) {\r\n        assertThat(expected.getCause()).isInstanceOf(MyException.class);\r\n        List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\r\n        assertThat(logged).hasSize(1);\r\n        assertThat(logged.get(0).getThrown()).isInstanceOf(MyException.class);\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.internal.ProviderMethodsModule.forObject",
	"Comment": "returns a module which creates bindings for provider methods from the given object. this isuseful notably for ginthis will skip bytecode generation for provider methods, since it is assumed that callersare only interested in module metadata.",
	"Method": "Module forObject(Object object,Module forObject,Object object,boolean skipFastClassGeneration,ModuleAnnotatedMethodScanner scanner){\r\n    if (object instanceof ProviderMethodsModule) {\r\n        return Modules.EMPTY_MODULE;\r\n    }\r\n    return new ProviderMethodsModule(object, skipFastClassGeneration, scanner);\r\n}"
}, {
	"Path": "com.google.inject.internal.Messages.formatMessages",
	"Comment": "returns the formatted message for an exception with the specified messages.",
	"Method": "String formatMessages(String heading,Collection<Message> errorMessages){\r\n    Formatter fmt = new Formatter().format(heading).format(\":%n%n\");\r\n    int index = 1;\r\n    boolean displayCauses = getOnlyCause(errorMessages) == null;\r\n    Map<Equivalence.Wrapper<Throwable>, Integer> causes = Maps.newHashMap();\r\n    for (Message errorMessage : errorMessages) {\r\n        int thisIdx = index++;\r\n        fmt.format(\"%s) %s%n\", thisIdx, errorMessage.getMessage());\r\n        List<Object> dependencies = errorMessage.getSources();\r\n        for (int i = dependencies.size() - 1; i >= 0; i--) {\r\n            Object source = dependencies.get(i);\r\n            formatSource(fmt, source);\r\n        }\r\n        Throwable cause = errorMessage.getCause();\r\n        if (displayCauses && cause != null) {\r\n            Equivalence.Wrapper<Throwable> causeEquivalence = ThrowableEquivalence.INSTANCE.wrap(cause);\r\n            if (!causes.containsKey(causeEquivalence)) {\r\n                causes.put(causeEquivalence, thisIdx);\r\n                fmt.format(\"Caused by: %s\", Throwables.getStackTraceAsString(cause));\r\n            } else {\r\n                int causeIdx = causes.get(causeEquivalence);\r\n                fmt.format(\"Caused by: %s (same stack trace as error #%s)\", cause.getClass().getName(), causeIdx);\r\n            }\r\n        }\r\n        fmt.format(\"%n\");\r\n    }\r\n    if (errorMessages.size() == 1) {\r\n        fmt.format(\"1 error\");\r\n    } else {\r\n        fmt.format(\"%s errors\", errorMessages.size());\r\n    }\r\n    return fmt.toString();\r\n}"
}, {
	"Path": "com.google.common.testing.EqualsTesterTest.testNonreflexiveEquals",
	"Comment": "test proper handling of case where an object is not equal to itself",
	"Method": "void testNonreflexiveEquals(){\r\n    Object obj = new NonReflexiveObject();\r\n    equalsTester.addEqualityGroup(obj);\r\n    try {\r\n        equalsTester.testEquals();\r\n    } catch (AssertionFailedError e) {\r\n        assertErrorMessage(e, obj + \" must be Object#equals to itself\");\r\n        return;\r\n    }\r\n    fail(\"Should get non-reflexive error\");\r\n}"
}, {
	"Path": "com.google.inject.internal.MapBinderTest.testProviderMultimapDependencyInjection",
	"Comment": "ensure there are no initialization race conditions in provider multimap injection.",
	"Method": "void testProviderMultimapDependencyInjection(){\r\n    final AtomicReference<Map<String, Set<Provider<String>>>> injectedMultimap = new AtomicReference<Map<String, Set<Provider<String>>>>();\r\n    final Object anObject = new Object() {\r\n        @Inject\r\n        void initialize(Map<String, Set<Provider<String>>> multimap) {\r\n            injectedMultimap.set(multimap);\r\n        }\r\n    };\r\n    Module abc = new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            requestInjection(anObject);\r\n            MapBinder<String, String> multibinder = MapBinder.newMapBinder(binder(), String.class, String.class);\r\n            multibinder.permitDuplicates();\r\n            multibinder.addBinding(\"a\").toInstance(\"A\");\r\n            multibinder.addBinding(\"b\").toInstance(\"B\");\r\n            multibinder.addBinding(\"c\").toInstance(\"C\");\r\n        }\r\n    };\r\n    Guice.createInjector(abc);\r\n    Map<String, String> map = Maps.transformValues(injectedMultimap.get(), new Function<Set<Provider<String>>, String>() {\r\n        @Override\r\n        public String apply(Set<Provider<String>> stringProvidersSet) {\r\n            return Iterables.getOnlyElement(stringProvidersSet).get();\r\n        }\r\n    });\r\n    assertEquals(mapOf(\"a\", \"A\", \"b\", \"B\", \"c\", \"C\"), map);\r\n}"
}, {
	"Path": "com.google.inject.internal.MapBinderTest.testProviderMultimapDependencyInjection",
	"Comment": "ensure there are no initialization race conditions in provider multimap injection.",
	"Method": "void testProviderMultimapDependencyInjection(){\r\n    injectedMultimap.set(multimap);\r\n}"
}, {
	"Path": "com.google.inject.internal.MapBinderTest.testProviderMultimapDependencyInjection",
	"Comment": "ensure there are no initialization race conditions in provider multimap injection.",
	"Method": "void testProviderMultimapDependencyInjection(){\r\n    requestInjection(anObject);\r\n    MapBinder<String, String> multibinder = MapBinder.newMapBinder(binder(), String.class, String.class);\r\n    multibinder.permitDuplicates();\r\n    multibinder.addBinding(\"a\").toInstance(\"A\");\r\n    multibinder.addBinding(\"b\").toInstance(\"B\");\r\n    multibinder.addBinding(\"c\").toInstance(\"C\");\r\n}"
}, {
	"Path": "com.google.inject.internal.MapBinderTest.testProviderMultimapDependencyInjection",
	"Comment": "ensure there are no initialization race conditions in provider multimap injection.",
	"Method": "void testProviderMultimapDependencyInjection(){\r\n    return Iterables.getOnlyElement(stringProvidersSet).get();\r\n}"
}, {
	"Path": "com.google.inject.internal.ProviderInternalFactory.provision",
	"Comment": "provisions a new instance. subclasses should override this to catch exceptions & rethrow aserrorsexceptions.",
	"Method": "T provision(Provider<? extends T> provider,Dependency<?> dependency,ConstructionContext<T> constructionContext){\r\n    T t = provider.get();\r\n    if (t == null && !dependency.isNullable()) {\r\n        InternalProvisionException.onNullInjectedIntoNonNullableDependency(source, dependency);\r\n    }\r\n    constructionContext.setProxyDelegates(t);\r\n    return t;\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultiset.setCount",
	"Comment": "guaranteed to throw an exception and leave the collection unmodified.",
	"Method": "int setCount(E element,int count,boolean setCount,E element,int oldCount,int newCount,Builder<E> setCount,E element,int count){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.hash.BloomFilter.putAll",
	"Comment": "combines this bloom filter with another bloom filter by performing a bitwise or of theunderlying data. the mutations happen to this instance. callers must ensure the bloomfilters are appropriately sized to avoid saturating them.",
	"Method": "void putAll(BloomFilter<T> that){\r\n    checkNotNull(that);\r\n    checkArgument(this != that, \"Cannot combine a BloomFilter with itself.\");\r\n    checkArgument(this.numHashFunctions == that.numHashFunctions, \"BloomFilters must have the same number of hash functions (%s != %s)\", this.numHashFunctions, that.numHashFunctions);\r\n    checkArgument(this.bitSize() == that.bitSize(), \"BloomFilters must have the same size underlying bit arrays (%s != %s)\", this.bitSize(), that.bitSize());\r\n    checkArgument(this.strategy.equals(that.strategy), \"BloomFilters must have equal strategies (%s != %s)\", this.strategy, that.strategy);\r\n    checkArgument(this.funnel.equals(that.funnel), \"BloomFilters must have equal funnels (%s != %s)\", this.funnel, that.funnel);\r\n    this.bits.putAll(that.bits);\r\n}"
}, {
	"Path": "com.google.common.collect.AbstractTableTest.testPutNull",
	"Comment": "this test assumes that the implementation does not support nulls.",
	"Method": "void testPutNull(){\r\n    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\r\n    assertSize(3);\r\n    try {\r\n        table.put(null, 2, 'd');\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n    try {\r\n        table.put(\"cat\", null, 'd');\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n    if (supportsNullValues()) {\r\n        assertNull(table.put(\"cat\", 2, null));\r\n        assertTrue(table.contains(\"cat\", 2));\r\n    } else {\r\n        try {\r\n            table.put(\"cat\", 2, null);\r\n            fail();\r\n        } catch (NullPointerException expected) {\r\n        }\r\n    }\r\n    assertSize(3);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableList.copyOf",
	"Comment": "returns an immutable list containing the given elements, in order.",
	"Method": "ImmutableList<E> copyOf(Iterable<? extends E> elements,ImmutableList<E> copyOf,Collection<? extends E> elements,ImmutableList<E> copyOf,Iterator<? extends E> elements,ImmutableList<E> copyOf,E[] elements){\r\n    checkNotNull(elements);\r\n    return copyOf(Arrays.asList(elements));\r\n}"
}, {
	"Path": "com.google.inject.assistedinject.AssistedConstructor.newInstance",
	"Comment": "returns an instance of t, constructed using this constructor, with the supplied arguments.",
	"Method": "T newInstance(Object[] args){\r\n    constructor.setAccessible(true);\r\n    try {\r\n        return constructor.newInstance(args);\r\n    } catch (InvocationTargetException e) {\r\n        throw e.getCause();\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.enterInterruptibly",
	"Comment": "enters this monitor. blocks at most the given time, and may be interrupted.",
	"Method": "void enterInterruptibly(boolean enterInterruptibly,long time,TimeUnit unit){\r\n    return lock.tryLock(time, unit);\r\n}"
}, {
	"Path": "com.google.common.eventbus.EventBusTest.testPolymorphicDistribution",
	"Comment": "tests that events are distributed to any subscribers to their type or any supertype, includinginterfaces and superclasses.also checks delivery ordering in such cases.",
	"Method": "void testPolymorphicDistribution(){\r\n    StringCatcher stringCatcher = new StringCatcher();\r\n    final List<Object> objectEvents = Lists.newArrayList();\r\n    Object objCatcher = new Object() {\r\n        @SuppressWarnings(\"unused\")\r\n        @Subscribe\r\n        public void eat(Object food) {\r\n            objectEvents.add(food);\r\n        }\r\n    };\r\n    final List<Comparable<?>> compEvents = Lists.newArrayList();\r\n    Object compCatcher = new Object() {\r\n        @SuppressWarnings(\"unused\")\r\n        @Subscribe\r\n        public void eat(Comparable<?> food) {\r\n            compEvents.add(food);\r\n        }\r\n    };\r\n    bus.register(stringCatcher);\r\n    bus.register(objCatcher);\r\n    bus.register(compCatcher);\r\n    Object objEvent = new Object();\r\n    Object compEvent = new Integer(6);\r\n    bus.post(EVENT);\r\n    bus.post(objEvent);\r\n    bus.post(compEvent);\r\n    List<String> stringEvents = stringCatcher.getEvents();\r\n    assertEquals(\"Only one String should be delivered.\", 1, stringEvents.size());\r\n    assertEquals(\"Correct string should be delivered.\", EVENT, stringEvents.get(0));\r\n    assertEquals(\"Three Objects should be delivered.\", 3, objectEvents.size());\r\n    assertEquals(\"String fixture must be first object delivered.\", EVENT, objectEvents.get(0));\r\n    assertEquals(\"Object fixture must be second object delivered.\", objEvent, objectEvents.get(1));\r\n    assertEquals(\"Comparable fixture must be thirdobject delivered.\", compEvent, objectEvents.get(2));\r\n    assertEquals(\"Two Comparable<?>s should be delivered.\", 2, compEvents.size());\r\n    assertEquals(\"String fixture must be first comparable delivered.\", EVENT, compEvents.get(0));\r\n    assertEquals(\"Comparable fixture must be second comparable delivered.\", compEvent, compEvents.get(1));\r\n}"
}, {
	"Path": "com.google.common.eventbus.EventBusTest.testPolymorphicDistribution",
	"Comment": "tests that events are distributed to any subscribers to their type or any supertype, includinginterfaces and superclasses.also checks delivery ordering in such cases.",
	"Method": "void testPolymorphicDistribution(){\r\n    objectEvents.add(food);\r\n}"
}, {
	"Path": "com.google.common.eventbus.EventBusTest.testPolymorphicDistribution",
	"Comment": "tests that events are distributed to any subscribers to their type or any supertype, includinginterfaces and superclasses.also checks delivery ordering in such cases.",
	"Method": "void testPolymorphicDistribution(){\r\n    compEvents.add(food);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableListMultimap.fromMapEntries",
	"Comment": "creates an immutablelistmultimap from an asmap.entryset.",
	"Method": "ImmutableListMultimap<K, V> fromMapEntries(Collection<? extends Map.Entry<? extends K, ? extends Collection<? extends V>>> mapEntries,Comparator<? super V> valueComparator){\r\n    if (mapEntries.isEmpty()) {\r\n        return of();\r\n    }\r\n    ImmutableMap.Builder<K, ImmutableList<V>> builder = new ImmutableMap.Builder(mapEntries.size());\r\n    int size = 0;\r\n    for (Entry<? extends K, ? extends Collection<? extends V>> entry : mapEntries) {\r\n        K key = entry.getKey();\r\n        Collection<? extends V> values = entry.getValue();\r\n        ImmutableList<V> list = (valueComparator == null) ? ImmutableList.copyOf(values) : ImmutableList.sortedCopyOf(valueComparator, values);\r\n        if (!list.isEmpty()) {\r\n            builder.put(key, list);\r\n            size += list.size();\r\n        }\r\n    }\r\n    return new ImmutableListMultimap(builder.build(), size);\r\n}"
}, {
	"Path": "com.google.inject.internal.MembersInjectorStore.createWithListeners",
	"Comment": "creates a new members injector and attaches both injection listeners and method aspects.",
	"Method": "MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type,Errors errors){\r\n    int numErrorsBefore = errors.size();\r\n    Set<InjectionPoint> injectionPoints;\r\n    try {\r\n        injectionPoints = InjectionPoint.forInstanceMethodsAndFields(type);\r\n    } catch (ConfigurationException e) {\r\n        errors.merge(e.getErrorMessages());\r\n        injectionPoints = e.getPartialValue();\r\n    }\r\n    ImmutableList<SingleMemberInjector> injectors = getInjectors(injectionPoints, errors);\r\n    errors.throwIfNewErrors(numErrorsBefore);\r\n    EncounterImpl<T> encounter = new EncounterImpl(errors, injector.lookups);\r\n    Set<TypeListener> alreadySeenListeners = Sets.newHashSet();\r\n    for (TypeListenerBinding binding : typeListenerBindings) {\r\n        TypeListener typeListener = binding.getListener();\r\n        if (!alreadySeenListeners.contains(typeListener) && binding.getTypeMatcher().matches(type)) {\r\n            alreadySeenListeners.add(typeListener);\r\n            try {\r\n                typeListener.hear(type, encounter);\r\n            } catch (RuntimeException e) {\r\n                errors.errorNotifyingTypeListener(binding, type, e);\r\n            }\r\n        }\r\n    }\r\n    encounter.invalidate();\r\n    errors.throwIfNewErrors(numErrorsBefore);\r\n    return new MembersInjectorImpl<T>(injector, type, encounter, injectors);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.MonitorBasedArrayBlockingQueue.offer",
	"Comment": "inserts the specified element at the tail of this queue, waiting up to the specified wait timefor space to become available if the queue is full.",
	"Method": "boolean offer(E e,boolean offer,E e,long timeout,TimeUnit unit){\r\n    if (e == null)\r\n        throw new NullPointerException();\r\n    final Monitor monitor = this.monitor;\r\n    if (monitor.enterWhen(notFull, timeout, unit)) {\r\n        try {\r\n            insert(e);\r\n            return true;\r\n        } finally {\r\n            monitor.leave();\r\n        }\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.google.common.reflect.ImmutableTypeToInstanceMap.put",
	"Comment": "guaranteed to throw an exception and leave the map unmodified.",
	"Method": "Builder<B> put(Class<T> key,T value,Builder<B> put,TypeToken<T> key,T value,B put,TypeToken<? extends B> key,B value){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.UnmodifiableListIterator.set",
	"Comment": "guaranteed to throw an exception and leave the underlying data unmodified.",
	"Method": "void set(E e){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.primitives.UnsignedBytes.toString",
	"Comment": "returns a string representation of x, where x is treated as unsigned.",
	"Method": "String toString(byte x,String toString,byte x,int radix){\r\n    checkArgument(radix >= Character.MIN_RADIX && radix <= Character.MAX_RADIX, \"radix (%s) must be between Character.MIN_RADIX and Character.MAX_RADIX\", radix);\r\n    return Integer.toString(toInt(x), radix);\r\n}"
}, {
	"Path": "com.google.inject.internal.Annotations.generateAnnotation",
	"Comment": "generates an annotation for the annotation class. requires that the annotation is alloptionals.",
	"Method": "T generateAnnotation(Class<T> annotationType){\r\n    Preconditions.checkState(isAllDefaultMethods(annotationType), \"%s is not all default methods\", annotationType);\r\n    return (T) cache.getUnchecked(annotationType);\r\n}"
}, {
	"Path": "com.google.common.testing.FreshValueGenerator.interfaceMethodCalled",
	"Comment": "subclasses can override to provide different return value for proxied interface methods.",
	"Method": "Object interfaceMethodCalled(Class<?> interfaceType,Method method){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.net.MediaType.withoutParameters",
	"Comment": "returns a new instance with the same type and subtype as this instance, but without anyparameters.",
	"Method": "MediaType withoutParameters(){\r\n    return parameters.isEmpty() ? this : create(type, subtype);\r\n}"
}, {
	"Path": "com.google.common.testing.EqualsTesterTest.testAddTwoEqualObjectsAtOnceWithNull",
	"Comment": "test equalobjects after adding multiple instances at once with a null",
	"Method": "void testAddTwoEqualObjectsAtOnceWithNull(){\r\n    try {\r\n        equalsTester.addEqualityGroup(reference, equalObject1, null);\r\n        fail(\"Should fail on null equal object\");\r\n    } catch (NullPointerException e) {\r\n    }\r\n}"
}, {
	"Path": "com.google.common.hash.LittleEndianByteArray.store64",
	"Comment": "store 8 bytes into the provided array at the indicated offset, using the value provided.",
	"Method": "void store64(byte[] sink,int offset,long value){\r\n    assert offset >= 0 && offset + 8 <= sink.length;\r\n    byteArray.putLongLittleEndian(sink, offset, value);\r\n}"
}, {
	"Path": "com.google.inject.multibindings.Multibinder.permitDuplicates",
	"Comment": "configures the bound set to silently discard duplicate elements. when multiple equal values arebound, the one that gets included is arbitrary. when multiple modules contribute elements tothe set, this configuration option impacts all of them.",
	"Method": "Multibinder<T> permitDuplicates(){\r\n    delegate.permitDuplicates();\r\n    return this;\r\n}"
}, {
	"Path": "com.google.common.graph.ElementOrderTest.edgeOrder_default",
	"Comment": "the default ordering is insertion unless otherwise specified.",
	"Method": "void edgeOrder_default(){\r\n    MutableNetwork<Integer, String> network = NetworkBuilder.directed().build();\r\n    addEdges(network);\r\n    assertThat(network.edgeOrder()).isEqualTo(ElementOrder.insertion());\r\n    assertThat(network.edges()).containsExactly(\"i\", \"e\", \"p\").inOrder();\r\n    assertThat(network.nodeOrder()).isEqualTo(ElementOrder.insertion());\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMap.computeIfAbsent",
	"Comment": "guaranteed to throw an exception and leave the map unmodified.",
	"Method": "V computeIfAbsent(K key,Function<? super K, ? extends V> mappingFunction){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.net.HostSpecifier.toString",
	"Comment": "returns a string representation of the host specifier suitable for inclusion in a uri. if thehost specifier is a domain name, the string will be normalized to all lower case. if thespecifier was an ipv6 address without brackets, brackets are added so that the result will beusable in the host part of a uri.",
	"Method": "String toString(){\r\n    return canonicalForm;\r\n}"
}, {
	"Path": "com.google.inject.ConfigurationException.withPartialValue",
	"Comment": "returns a copy of this configuration exception with the specified partial value.",
	"Method": "ConfigurationException withPartialValue(Object partialValue){\r\n    checkState(this.partialValue == null, \"Can't clobber existing partial value %s with %s\", this.partialValue, partialValue);\r\n    ConfigurationException result = new ConfigurationException(messages);\r\n    result.partialValue = partialValue;\r\n    return result;\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSortedMap.copyOf",
	"Comment": "returns an immutable map containing the given entries, with keys sorted by the providedcomparator.",
	"Method": "ImmutableSortedMap<K, V> copyOf(Map<? extends K, ? extends V> map,ImmutableSortedMap<K, V> copyOf,Map<? extends K, ? extends V> map,Comparator<? super K> comparator,ImmutableSortedMap<K, V> copyOf,Iterable<? extends Entry<? extends K, ? extends V>> entries,ImmutableSortedMap<K, V> copyOf,Iterable<? extends Entry<? extends K, ? extends V>> entries,Comparator<? super K> comparator){\r\n    return new Builder<K, V>(comparator).putAll(entries).build();\r\n}"
}, {
	"Path": "com.google.common.io.MoreFiles.touch",
	"Comment": "like the unix command of the same name, creates an empty file or updates the last modifiedtimestamp of the existing file at the given path to the current system time.",
	"Method": "void touch(Path path){\r\n    checkNotNull(path);\r\n    try {\r\n        Files.setLastModifiedTime(path, FileTime.fromMillis(System.currentTimeMillis()));\r\n    } catch (NoSuchFileException e) {\r\n        try {\r\n            Files.createFile(path);\r\n        } catch (FileAlreadyExistsException ignore) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.math.LongMathTest.testSqrtMatchesBigInteger",
	"Comment": "relies on the correctness of bigintegermath.sqrt for all modes except unnecessary.",
	"Method": "void testSqrtMatchesBigInteger(){\r\n    for (long x : POSITIVE_LONG_CANDIDATES) {\r\n        for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\r\n            assertEquals(BigIntegerMath.sqrt(valueOf(x), mode), valueOf(LongMath.sqrt(x, mode)));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.zaxxer.hikari.HikariConfig.setMetricRegistry",
	"Comment": "set a metricregistry instance to use for registration of metrics used by hikaricp.",
	"Method": "void setMetricRegistry(Object metricRegistry){\r\n    if (metricsTrackerFactory != null) {\r\n        throw new IllegalStateException(\"cannot use setMetricRegistry() and setMetricsTrackerFactory() together\");\r\n    }\r\n    if (metricRegistry != null) {\r\n        metricRegistry = getObjectOrPerformJndiLookup(metricRegistry);\r\n        if (!safeIsAssignableFrom(metricRegistry, \"com.codahale.metrics.MetricRegistry\") && !(safeIsAssignableFrom(metricRegistry, \"io.micrometer.core.instrument.MeterRegistry\"))) {\r\n            throw new IllegalArgumentException(\"Class must be instance of com.codahale.metrics.MetricRegistry or io.micrometer.core.instrument.MeterRegistry\");\r\n        }\r\n    }\r\n    this.metricRegistry = metricRegistry;\r\n}"
}, {
	"Path": "com.google.inject.servlet.ServletDefinition.service",
	"Comment": "wrapper around the service chain to ensure a servlet is servicing what it must and provides itwith a wrapped request.",
	"Method": "boolean service(ServletRequest servletRequest,ServletResponse servletResponse){\r\n    final HttpServletRequest request = (HttpServletRequest) servletRequest;\r\n    final String path = ServletUtils.getContextRelativePath(request);\r\n    final boolean serve = shouldServe(path);\r\n    if (serve) {\r\n        doService(servletRequest, servletResponse);\r\n    }\r\n    return serve;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AbstractFutureTest.testListenersExecuteImmediately_afterWaiterWakesUp",
	"Comment": "this would be observable from a waiter that was just unblocked.",
	"Method": "void testListenersExecuteImmediately_afterWaiterWakesUp(){\r\n    final AbstractFuture<String> f = new AbstractFuture<String>() {\r\n        @Override\r\n        protected void afterDone() {\r\n            try {\r\n                Thread.sleep(TimeUnit.SECONDS.toMillis(10));\r\n            } catch (InterruptedException ignored) {\r\n                Thread.currentThread().interrupt();\r\n            }\r\n        }\r\n    };\r\n    Thread t = new Thread() {\r\n        @Override\r\n        public void run() {\r\n            f.set(\"foo\");\r\n        }\r\n    };\r\n    t.start();\r\n    f.get();\r\n    final AtomicBoolean ranImmediately = new AtomicBoolean();\r\n    f.addListener(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            ranImmediately.set(true);\r\n        }\r\n    }, MoreExecutors.directExecutor());\r\n    assertThat(ranImmediately.get()).isTrue();\r\n    t.interrupt();\r\n    t.join();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AbstractFutureTest.testListenersExecuteImmediately_afterWaiterWakesUp",
	"Comment": "this would be observable from a waiter that was just unblocked.",
	"Method": "void testListenersExecuteImmediately_afterWaiterWakesUp(){\r\n    try {\r\n        Thread.sleep(TimeUnit.SECONDS.toMillis(10));\r\n    } catch (InterruptedException ignored) {\r\n        Thread.currentThread().interrupt();\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AbstractFutureTest.testListenersExecuteImmediately_afterWaiterWakesUp",
	"Comment": "this would be observable from a waiter that was just unblocked.",
	"Method": "void testListenersExecuteImmediately_afterWaiterWakesUp(){\r\n    f.set(\"foo\");\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AbstractFutureTest.testListenersExecuteImmediately_afterWaiterWakesUp",
	"Comment": "this would be observable from a waiter that was just unblocked.",
	"Method": "void testListenersExecuteImmediately_afterWaiterWakesUp(){\r\n    ranImmediately.set(true);\r\n}"
}, {
	"Path": "com.google.common.collect.CompactHashMap.resizeEntries",
	"Comment": "resizes the internal entries array to the specified capacity, which may be greater or less thanthe current capacity.",
	"Method": "void resizeEntries(int newCapacity){\r\n    this.keys = Arrays.copyOf(keys, newCapacity);\r\n    this.values = Arrays.copyOf(values, newCapacity);\r\n    long[] entries = this.entries;\r\n    int oldCapacity = entries.length;\r\n    entries = Arrays.copyOf(entries, newCapacity);\r\n    if (newCapacity > oldCapacity) {\r\n        Arrays.fill(entries, oldCapacity, newCapacity, UNSET);\r\n    }\r\n    this.entries = entries;\r\n}"
}, {
	"Path": "com.google.inject.ProviderInjectionTest.testProvidersAreInjectedBeforeTheyAreUsed",
	"Comment": "when custom providers are used at injector creation time, they should be injected before use.in this testcase, we verify that a provider for list.class is injected before it is used.",
	"Method": "void testProvidersAreInjectedBeforeTheyAreUsed(){\r\n    Injector injector = Guice.createInjector(new AbstractModule() {\r\n        @Override\r\n        public void configure() {\r\n            bind(String.class).toProvider(new Provider<String>() {\r\n                private String value;\r\n                @Inject\r\n                void initialize(List list) {\r\n                    value = list.toString();\r\n                }\r\n                @Override\r\n                public String get() {\r\n                    return value;\r\n                }\r\n            });\r\n            bind(List.class).toProvider(new Provider<List>() {\r\n                @Inject\r\n                Boolean injectedYet = Boolean.FALSE;\r\n                @Override\r\n                public List get() {\r\n                    return Arrays.asList(injectedYet);\r\n                }\r\n            });\r\n            bind(Boolean.class).toInstance(Boolean.TRUE);\r\n        }\r\n    });\r\n    assertEquals(\"Providers not injected before use\", \"[true]\", injector.getInstance(String.class));\r\n}"
}, {
	"Path": "com.google.inject.ProviderInjectionTest.testProvidersAreInjectedBeforeTheyAreUsed",
	"Comment": "when custom providers are used at injector creation time, they should be injected before use.in this testcase, we verify that a provider for list.class is injected before it is used.",
	"Method": "void testProvidersAreInjectedBeforeTheyAreUsed(){\r\n    bind(String.class).toProvider(new Provider<String>() {\r\n        private String value;\r\n        @Inject\r\n        void initialize(List list) {\r\n            value = list.toString();\r\n        }\r\n        @Override\r\n        public String get() {\r\n            return value;\r\n        }\r\n    });\r\n    bind(List.class).toProvider(new Provider<List>() {\r\n        @Inject\r\n        Boolean injectedYet = Boolean.FALSE;\r\n        @Override\r\n        public List get() {\r\n            return Arrays.asList(injectedYet);\r\n        }\r\n    });\r\n    bind(Boolean.class).toInstance(Boolean.TRUE);\r\n}"
}, {
	"Path": "com.google.inject.ProviderInjectionTest.testProvidersAreInjectedBeforeTheyAreUsed",
	"Comment": "when custom providers are used at injector creation time, they should be injected before use.in this testcase, we verify that a provider for list.class is injected before it is used.",
	"Method": "void testProvidersAreInjectedBeforeTheyAreUsed(){\r\n    value = list.toString();\r\n}"
}, {
	"Path": "com.google.inject.ProviderInjectionTest.testProvidersAreInjectedBeforeTheyAreUsed",
	"Comment": "when custom providers are used at injector creation time, they should be injected before use.in this testcase, we verify that a provider for list.class is injected before it is used.",
	"Method": "void testProvidersAreInjectedBeforeTheyAreUsed(){\r\n    return value;\r\n}"
}, {
	"Path": "com.google.inject.ProviderInjectionTest.testProvidersAreInjectedBeforeTheyAreUsed",
	"Comment": "when custom providers are used at injector creation time, they should be injected before use.in this testcase, we verify that a provider for list.class is injected before it is used.",
	"Method": "void testProvidersAreInjectedBeforeTheyAreUsed(){\r\n    return Arrays.asList(injectedYet);\r\n}"
}, {
	"Path": "com.google.common.net.PercentEscaperTest.testPlusForSpace",
	"Comment": "tests the various ways that the space character can be handled",
	"Method": "void testPlusForSpace(){\r\n    UnicodeEscaper basicEscaper = new PercentEscaper(\"\", false);\r\n    UnicodeEscaper plusForSpaceEscaper = new PercentEscaper(\"\", true);\r\n    UnicodeEscaper spaceEscaper = new PercentEscaper(\" \", false);\r\n    assertEquals(\"string with spaces\", basicEscaper.escape(\"string with spaces\"));\r\n    assertEquals(\"string+with+spaces\", plusForSpaceEscaper.escape(\"string with spaces\"));\r\n    assertEquals(\"string with spaces\", spaceEscaper.escape(\"string with spaces\"));\r\n}"
}, {
	"Path": "com.google.common.primitives.ImmutableLongArray.hashCode",
	"Comment": "returns an unspecified hash code for the contents of this immutable array.",
	"Method": "int hashCode(int hashCode){\r\n    int hash = 1;\r\n    for (int i = start; i < end; i++) {\r\n        hash *= 31;\r\n        hash += Longs.hashCode(array[i]);\r\n    }\r\n    return hash;\r\n}"
}, {
	"Path": "com.google.inject.NullableInjectionPointTest.testBindNullAndLinkFromOptionalBinder",
	"Comment": "tests for a regression where dependency objects were not updated properly and optionalbinderwas rejecting nulls from its dependencies.",
	"Method": "void testBindNullAndLinkFromOptionalBinder(){\r\n    Injector injector = Guice.createInjector(new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            bind(Foo.class).toProvider(Providers.<Foo>of(null));\r\n            OptionalBinder.newOptionalBinder(binder(), Foo.class);\r\n        }\r\n        @Provides\r\n        @Named(\"throughProvidesMethod\")\r\n        Foo provideFoo(Optional<Foo> foo) {\r\n            return foo.orNull();\r\n        }\r\n    });\r\n    assertNull(injector.getInstance(Key.get(Foo.class, Names.named(\"throughProvidesMethod\"))));\r\n}"
}, {
	"Path": "com.google.inject.NullableInjectionPointTest.testBindNullAndLinkFromOptionalBinder",
	"Comment": "tests for a regression where dependency objects were not updated properly and optionalbinderwas rejecting nulls from its dependencies.",
	"Method": "void testBindNullAndLinkFromOptionalBinder(){\r\n    bind(Foo.class).toProvider(Providers.<Foo>of(null));\r\n    OptionalBinder.newOptionalBinder(binder(), Foo.class);\r\n}"
}, {
	"Path": "com.google.inject.NullableInjectionPointTest.testBindNullAndLinkFromOptionalBinder",
	"Comment": "tests for a regression where dependency objects were not updated properly and optionalbinderwas rejecting nulls from its dependencies.",
	"Method": "void testBindNullAndLinkFromOptionalBinder(){\r\n    return foo.orNull();\r\n}"
}, {
	"Path": "com.google.inject.internal.ConstructorBindingImpl.getInternalConstructor",
	"Comment": "returns an injection point that can be used to clean up the constructor store.",
	"Method": "InjectionPoint getInternalConstructor(){\r\n    if (factory.constructorInjector != null) {\r\n        return factory.constructorInjector.getConstructionProxy().getInjectionPoint();\r\n    } else {\r\n        return constructorInjectionPoint;\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.MapsTest.testNewLinkedHashMapWithExpectedSize_wontGrow",
	"Comment": "same test as above but for newlinkedhashmapwithexpectedsize",
	"Method": "void testNewLinkedHashMapWithExpectedSize_wontGrow(){\r\n    assertTrue(bucketsOf(Maps.newLinkedHashMapWithExpectedSize(0)) <= 1);\r\n    for (int size = 1; size < 200; size++) {\r\n        assertWontGrow(size, Maps.newLinkedHashMapWithExpectedSize(size), Maps.newLinkedHashMapWithExpectedSize(size));\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.grapher.AbstractInjectorGrapher.getBindings",
	"Comment": "returns the bindings for the root keys and their transitive dependencies.",
	"Method": "Iterable<Binding<?>> getBindings(Injector injector,Set<Key<?>> root){\r\n    Set<Key<?>> keys = Sets.newHashSet(root);\r\n    Set<Key<?>> visitedKeys = Sets.newHashSet();\r\n    List<Binding<?>> bindings = Lists.newArrayList();\r\n    TransitiveDependencyVisitor keyVisitor = new TransitiveDependencyVisitor();\r\n    while (!keys.isEmpty()) {\r\n        Iterator<Key<?>> iterator = keys.iterator();\r\n        Key<?> key = iterator.next();\r\n        iterator.remove();\r\n        if (!visitedKeys.contains(key)) {\r\n            Binding<?> binding = injector.getBinding(key);\r\n            bindings.add(binding);\r\n            visitedKeys.add(key);\r\n            keys.addAll(binding.acceptTargetVisitor(keyVisitor));\r\n        }\r\n    }\r\n    return bindings;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.MonitorBasedArrayBlockingQueue.insert",
	"Comment": "inserts element at current put position, advances, and signals. call only when occupyingmonitor.",
	"Method": "void insert(E x){\r\n    items[putIndex] = x;\r\n    putIndex = inc(putIndex);\r\n    ++count;\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableCollection.remove",
	"Comment": "guaranteed to throw an exception and leave the collection unmodified.",
	"Method": "boolean remove(Object object){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.inject.BinderTest.testSettingBindingTwice",
	"Comment": "binding something to two different things should give an error.",
	"Method": "void testSettingBindingTwice(){\r\n    try {\r\n        Guice.createInjector(new ParentModule());\r\n        fail();\r\n    } catch (CreationException expected) {\r\n        assertContains(expected.getMessage(), \"1) A binding to java.lang.String was already configured at \" + ConstantModule.class.getName(), asModuleChain(ParentModule.class, FooModule.class, ConstantModule.class), \"at \" + ConstantModule.class.getName(), getDeclaringSourcePart(getClass()), asModuleChain(ParentModule.class, BarModule.class, ConstantModule.class));\r\n        assertContains(expected.getMessage(), \"1 error\");\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.spi.InjectionPoint.checkForMisplacedBindingAnnotations",
	"Comment": "returns true if the binding annotation is in the wrong place.",
	"Method": "boolean checkForMisplacedBindingAnnotations(Member member,Errors errors){\r\n    Annotation misplacedBindingAnnotation = Annotations.findBindingAnnotation(errors, member, ((AnnotatedElement) member).getAnnotations());\r\n    if (misplacedBindingAnnotation == null) {\r\n        return false;\r\n    }\r\n    if (member instanceof Method) {\r\n        try {\r\n            if (member.getDeclaringClass().getDeclaredField(member.getName()) != null) {\r\n                return false;\r\n            }\r\n        } catch (NoSuchFieldException ignore) {\r\n        }\r\n    }\r\n    errors.misplacedBindingAnnotation(member, misplacedBindingAnnotation);\r\n    return true;\r\n}"
}, {
	"Path": "com.google.common.collect.AbstractMapBasedMultiset.setBackingMap",
	"Comment": "used during deserialization only. the backing map must be empty.",
	"Method": "void setBackingMap(Map<E, Count> backingMap){\r\n    this.backingMap = backingMap;\r\n}"
}, {
	"Path": "com.google.common.base.Stopwatch.reset",
	"Comment": "sets the elapsed time for this stopwatch to zero, and places it in a stopped state.",
	"Method": "Stopwatch reset(){\r\n    elapsedNanos = 0;\r\n    isRunning = false;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.MonitorBasedArrayBlockingQueue.clear",
	"Comment": "atomically removes all of the elements from this queue. the queue will be empty after this callreturns.",
	"Method": "void clear(){\r\n    final E[] items = this.items;\r\n    final Monitor monitor = this.monitor;\r\n    monitor.enter();\r\n    try {\r\n        int i = takeIndex;\r\n        int k = count;\r\n        while (k-- > 0) {\r\n            items[i] = null;\r\n            i = inc(i);\r\n        }\r\n        count = 0;\r\n        putIndex = 0;\r\n        takeIndex = 0;\r\n    } finally {\r\n        monitor.leave();\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.FuturesTest.testCompletionOrderMixedBagOTypes",
	"Comment": "mostly an example of how it would look like to use a list of mixed types",
	"Method": "void testCompletionOrderMixedBagOTypes(){\r\n    SettableFuture<Long> future1 = SettableFuture.create();\r\n    SettableFuture<String> future2 = SettableFuture.create();\r\n    SettableFuture<Integer> future3 = SettableFuture.create();\r\n    ImmutableList<? extends ListenableFuture<?>> inputs = ImmutableList.<ListenableFuture<?>>of(future1, future2, future3);\r\n    ImmutableList<ListenableFuture<Object>> futures = inCompletionOrder(inputs);\r\n    future2.set(\"1L\");\r\n    future1.set(2L);\r\n    future3.set(3);\r\n    ImmutableList<?> expected = ImmutableList.of(\"1L\", 2L, 3);\r\n    for (int i = 0; i < expected.size(); i++) {\r\n        assertEquals(expected.get(i), getDone(futures.get(i)));\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.SetsTest.verifySetContents",
	"Comment": "utility method that verifies that the given set is equal to and hashes identically to a setconstructed with the elements in the given iterable.",
	"Method": "void verifySetContents(Set<E> set,Iterable<E> contents){\r\n    Set<E> expected = null;\r\n    if (contents instanceof Set) {\r\n        expected = (Set<E>) contents;\r\n    } else {\r\n        expected = new HashSet<E>();\r\n        for (E element : contents) {\r\n            expected.add(element);\r\n        }\r\n    }\r\n    assertEquals(expected, set);\r\n}"
}, {
	"Path": "com.google.common.collect.Platform.newArray",
	"Comment": "returns a new array of the given length with the same type as a reference array.",
	"Method": "T[] newArray(T[] reference,int length){\r\n    T[] clone = Arrays.copyOf(reference, 0);\r\n    resizeArray(clone, length);\r\n    return clone;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.CycleDetectingLockFactory.aboutToAcquire",
	"Comment": "cycledetectinglock implementations must call this method before attempting to acquire the lock.",
	"Method": "void aboutToAcquire(CycleDetectingLock lock){\r\n    if (!lock.isAcquiredByCurrentThread()) {\r\n        ArrayList<LockGraphNode> acquiredLockList = acquiredLocks.get();\r\n        LockGraphNode node = lock.getLockGraphNode();\r\n        node.checkAcquiredLocks(policy, acquiredLockList);\r\n        acquiredLockList.add(node);\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.TreeMultisetTest.testDegenerateComparator",
	"Comment": "test a treemultiset with a comparator that can return 0 when comparing unequal values.",
	"Method": "void testDegenerateComparator(){\r\n    TreeMultiset<String> ms = TreeMultiset.create(DEGENERATE_COMPARATOR);\r\n    ms.add(\"foo\");\r\n    ms.add(\"a\");\r\n    ms.add(\"bar\");\r\n    ms.add(\"b\");\r\n    ms.add(\"c\");\r\n    assertEquals(2, ms.count(\"bar\"));\r\n    assertEquals(3, ms.count(\"b\"));\r\n    Multiset<String> ms2 = TreeMultiset.create(DEGENERATE_COMPARATOR);\r\n    ms2.add(\"cat\", 2);\r\n    ms2.add(\"x\", 3);\r\n    assertEquals(ms, ms2);\r\n    assertEquals(ms2, ms);\r\n    SortedSet<String> elementSet = ms.elementSet();\r\n    assertEquals(\"a\", elementSet.first());\r\n    assertEquals(\"foo\", elementSet.last());\r\n    assertEquals(DEGENERATE_COMPARATOR, elementSet.comparator());\r\n}"
}, {
	"Path": "com.google.inject.ProvisionExceptionTest.testProvisionExceptionsAreWrappedForBindToType",
	"Comment": "this test demonstrates that if the user throws a provisionexception, we wrap it to add context.",
	"Method": "void testProvisionExceptionsAreWrappedForBindToType(){\r\n    try {\r\n        Guice.createInjector().getInstance(F.class);\r\n        fail();\r\n    } catch (ProvisionException e) {\r\n        assertContains(e.getMessage(), \"1) User Exception\", \"at \" + F.class.getName() + \".<init>(ProvisionExceptionTest.java:\");\r\n    }\r\n}"
}, {
	"Path": "com.google.common.hash.HashTestUtils.assertInvariants",
	"Comment": "checks that a hasher returns the same hashcode when given the same input, and also that thecollision rate looks sane.",
	"Method": "void assertInvariants(HashFunction hashFunction){\r\n    int objects = 100;\r\n    Set<HashCode> hashcodes = Sets.newHashSetWithExpectedSize(objects);\r\n    Random random = new Random(314159);\r\n    for (int i = 0; i < objects; i++) {\r\n        int value = random.nextInt();\r\n        HashCode hashcode1 = hashFunction.hashInt(value);\r\n        HashCode hashcode2 = hashFunction.hashInt(value);\r\n        Assert.assertEquals(hashcode1, hashcode2);\r\n        Assert.assertEquals(hashFunction.bits(), hashcode1.bits());\r\n        Assert.assertEquals(hashFunction.bits(), hashcode1.asBytes().length * 8);\r\n        hashcodes.add(hashcode1);\r\n    }\r\n    Assert.assertTrue(hashcodes.size() > objects * 0.95);\r\n    assertHashBytesThrowsCorrectExceptions(hashFunction);\r\n    assertIndependentHashers(hashFunction);\r\n    assertShortcutsAreEquivalent(hashFunction, 512);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMapEntry.isReusable",
	"Comment": "returns true if this entry has no bucket links and can safely be reused as a terminal entry ina bucket in another map.",
	"Method": "boolean isReusable(boolean isReusable){\r\n    return true;\r\n}"
}, {
	"Path": "com.google.common.graph.ElementOrder.unordered",
	"Comment": "returns an instance which specifies that no ordering is guaranteed.",
	"Method": "ElementOrder<S> unordered(){\r\n    return new ElementOrder<S>(Type.UNORDERED, null);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.GeneratedMonitorTest.isBoolean",
	"Comment": "determines whether the given method returns a boolean value.",
	"Method": "boolean isBoolean(Method method){\r\n    return method.getReturnType() == boolean.class;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AtomicDoubleArrayTest.testConstructorEmptyArray",
	"Comment": "constructor with empty array has size 0 and contains no elements",
	"Method": "void testConstructorEmptyArray(){\r\n    AtomicDoubleArray aa = new AtomicDoubleArray(new double[0]);\r\n    assertEquals(0, aa.length());\r\n    try {\r\n        aa.get(0);\r\n        fail();\r\n    } catch (IndexOutOfBoundsException success) {\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSetMultimap.of",
	"Comment": "casting is safe because the multimap will never hold any elements.",
	"Method": "ImmutableSetMultimap<K, V> of(ImmutableSetMultimap<K, V> of,K k1,V v1,ImmutableSetMultimap<K, V> of,K k1,V v1,K k2,V v2,ImmutableSetMultimap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,ImmutableSetMultimap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,ImmutableSetMultimap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,K k5,V v5){\r\n    ImmutableSetMultimap.Builder<K, V> builder = ImmutableSetMultimap.builder();\r\n    builder.put(k1, v1);\r\n    builder.put(k2, v2);\r\n    builder.put(k3, v3);\r\n    builder.put(k4, v4);\r\n    builder.put(k5, v5);\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.google.common.graph.ElementOrder.insertion",
	"Comment": "returns an instance which specifies that insertion ordering is guaranteed.",
	"Method": "ElementOrder<S> insertion(){\r\n    return new ElementOrder<S>(Type.INSERTION, null);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.testing.MockFutureListener.assertSuccess",
	"Comment": "verify that the listener completes in a reasonable amount of time, and asserts that the futurereturns the expected data.",
	"Method": "void assertSuccess(Object expectedData){\r\n    Assert.assertTrue(countDownLatch.await(1L, TimeUnit.SECONDS));\r\n    try {\r\n        Assert.assertEquals(expectedData, future.get());\r\n    } catch (ExecutionException e) {\r\n        throw e.getCause();\r\n    }\r\n}"
}, {
	"Path": "com.google.common.io.ByteStreams.readBytes",
	"Comment": "process the bytes of the given input stream using the given processor.",
	"Method": "T readBytes(InputStream input,ByteProcessor<T> processor){\r\n    checkNotNull(input);\r\n    checkNotNull(processor);\r\n    byte[] buf = createBuffer();\r\n    int read;\r\n    do {\r\n        read = input.read(buf);\r\n    } while (read != -1 && processor.processBytes(buf, 0, read));\r\n    return processor.getResult();\r\n}"
}, {
	"Path": "com.zaxxer.hikari.HikariConfig.setPoolName",
	"Comment": "set the name of the connection pool.this is primarily used for the mbean to uniquely identify the pool configuration.",
	"Method": "void setPoolName(String poolName){\r\n    checkIfSealed();\r\n    this.poolName = poolName;\r\n}"
}, {
	"Path": "com.google.common.collect.TreeMultimapNaturalTest.testCreateFromTreeMultimap",
	"Comment": "test that creating one treemultimap from another does not copy the comparators from the sourcetreemultimap.",
	"Method": "void testCreateFromTreeMultimap(){\r\n    Multimap<Double, Double> tree = TreeMultimap.create(KEY_COMPARATOR, VALUE_COMPARATOR);\r\n    tree.put(1.0, 2.0);\r\n    tree.put(2.0, 3.0);\r\n    tree.put(3.0, 4.0);\r\n    tree.put(4.0, 5.0);\r\n    TreeMultimap<Double, Double> copyFromTree = TreeMultimap.create(tree);\r\n    assertEquals(tree, copyFromTree);\r\n    assertSame(Ordering.natural(), copyFromTree.keyComparator());\r\n    assertSame(Ordering.natural(), copyFromTree.valueComparator());\r\n    assertSame(Ordering.natural(), copyFromTree.get(1.0).comparator());\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.ServiceManagerTest.testSingleFailedServiceCallsStopped",
	"Comment": "this covers a case where if the last service to stop failed then the stopped callback wouldnever be called.",
	"Method": "void testSingleFailedServiceCallsStopped(){\r\n    Service a = new FailStartService();\r\n    ServiceManager manager = new ServiceManager(asList(a));\r\n    RecordingListener listener = new RecordingListener();\r\n    manager.addListener(listener);\r\n    try {\r\n        manager.startAsync().awaitHealthy();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n    assertTrue(listener.stoppedCalled);\r\n}"
}, {
	"Path": "com.google.common.base.PreconditionsTest.getParametersForSignature",
	"Comment": "returns an array containing parameters for invoking a checkargument, checknotnull or checkstatemethod reflectively",
	"Method": "Object[] getParametersForSignature(Object firstParam,ImmutableList<Class<?>> sig){\r\n    Object[] params = new Object[sig.size()];\r\n    params[0] = firstParam;\r\n    if (params.length > 1) {\r\n        params[1] = \"\";\r\n        if (params.length > 2) {\r\n            for (int i = 2; i < params.length; i++) {\r\n                params[i] = ArbitraryInstances.get(sig.get(i));\r\n            }\r\n        }\r\n    }\r\n    return params;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.JSR166TestCase.delayedDate",
	"Comment": "returns a new date instance representing a time delaymillis milliseconds in the future.",
	"Method": "Date delayedDate(long delayMillis){\r\n    return new Date(System.currentTimeMillis() + delayMillis);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSortedSet.pollLast",
	"Comment": "guaranteed to throw an exception and leave the set unmodified.",
	"Method": "E pollLast(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.isOccupied",
	"Comment": "returns whether this monitor is occupied by any thread. this method is designed for use inmonitoring of the system state, not for synchronization control.",
	"Method": "boolean isOccupied(){\r\n    return lock.isLocked();\r\n}"
}, {
	"Path": "com.google.common.escape.testing.EscaperAsserts.assertBasic",
	"Comment": "asserts that an escaper behaves correctly with respect to null inputs.",
	"Method": "void assertBasic(Escaper escaper){\r\n    Assert.assertEquals(\"\", escaper.escape(\"\"));\r\n    try {\r\n        escaper.escape((String) null);\r\n        Assert.fail(\"exception not thrown when escaping a null string\");\r\n    } catch (NullPointerException e) {\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.AbstractBiMap.setDelegates",
	"Comment": "specifies the delegate maps going in each direction. called by the constructor and bysubclasses during deserialization.",
	"Method": "void setDelegates(Map<K, V> forward,Map<V, K> backward){\r\n    checkState(delegate == null);\r\n    checkState(inverse == null);\r\n    checkArgument(forward.isEmpty());\r\n    checkArgument(backward.isEmpty());\r\n    checkArgument(forward != backward);\r\n    delegate = forward;\r\n    inverse = makeInverse(backward);\r\n}"
}, {
	"Path": "org.hswebframework.web.workflow.web.diagram.ProcessInstanceHighlightsResource.getStartTransaction",
	"Comment": "check out the outgoing transition connected to firstactinst from starteventactlist",
	"Method": "PvmTransition getStartTransaction(List<ActivityImpl> startEventActList,HistoricActivityInstance firstActInst){\r\n    for (ActivityImpl startEventAct : startEventActList) {\r\n        for (PvmTransition trans : startEventAct.getOutgoingTransitions()) {\r\n            if (trans.getDestination().getId().equals(firstActInst.getActivityId())) {\r\n                return trans;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.JSR166TestCase.tearDown",
	"Comment": "extra checks that get done for all test cases.triggers test case failure if any thread assertions have failed, by rethrowing, in the testharness thread, any exception recorded earlier by threadrecordfailure.triggers test case failure if interrupt status is set in the main thread.",
	"Method": "void tearDown(){\r\n    Throwable t = threadFailure.getAndSet(null);\r\n    if (t != null) {\r\n        if (t instanceof Error)\r\n            throw (Error) t;\r\n        else if (t instanceof RuntimeException)\r\n            throw (RuntimeException) t;\r\n        else if (t instanceof Exception)\r\n            throw (Exception) t;\r\n        else {\r\n            AssertionFailedError afe = new AssertionFailedError(t.toString());\r\n            afe.initCause(t);\r\n            throw afe;\r\n        }\r\n    }\r\n    if (Thread.interrupted())\r\n        throw new AssertionFailedError(\"interrupt status set in main thread\");\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.FuturesTest.testTransformValueRemainsMemoized",
	"Comment": "tests that the function is invoked only once, even if it throws an exception.",
	"Method": "void testTransformValueRemainsMemoized(){\r\n    class Holder {\r\n        int value = 2;\r\n    }\r\n    final Holder holder = new Holder();\r\n    Function<Integer, Integer> adder = new Function<Integer, Integer>() {\r\n        @Override\r\n        public Integer apply(Integer from) {\r\n            return from + holder.value;\r\n        }\r\n    };\r\n    assertEquals(6, adder.apply(4).intValue());\r\n    ListenableFuture<Integer> immediateFuture = immediateFuture(4);\r\n    Future<Integer> transformedFuture = transform(immediateFuture, adder, directExecutor());\r\n    assertEquals(6, getDone(transformedFuture).intValue());\r\n    holder.value = 3;\r\n    assertEquals(6, getDone(transformedFuture).intValue());\r\n    assertEquals(7, adder.apply(4).intValue());\r\n    holder.value = 4;\r\n    assertEquals(6, getDone(transformedFuture).intValue());\r\n    assertEquals(8, adder.apply(4).intValue());\r\n    assertEquals(6, getDoneFromTimeoutOverload(transformedFuture).intValue());\r\n    assertEquals(8, getDone(transform(immediateFuture, adder, directExecutor())).intValue());\r\n    assertEquals(8, getDoneFromTimeoutOverload(transform(immediateFuture, adder, directExecutor())).intValue());\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.FuturesTest.testTransformValueRemainsMemoized",
	"Comment": "tests that the function is invoked only once, even if it throws an exception.",
	"Method": "void testTransformValueRemainsMemoized(){\r\n    return from + holder.value;\r\n}"
}, {
	"Path": "com.google.inject.Key.withoutAttributes",
	"Comment": "returns this key without annotation attributes, i.e. with only the annotation type.",
	"Method": "Key<T> withoutAttributes(AnnotationStrategy withoutAttributes,AnnotationStrategy withoutAttributes,AnnotationStrategy withoutAttributes){\r\n    return new Key<T>(typeLiteral, annotationStrategy.withoutAttributes());\r\n}"
}, {
	"Path": "com.google.common.collect.SetsTest.verifySortedSetContents",
	"Comment": "utility method to verify that the given sortedset is equal to and hashes identically to a setconstructed with the elements in the given iterable. also verifies that the comparator is thesame as the given comparator.",
	"Method": "void verifySortedSetContents(SortedSet<E> set,Iterable<E> iterable,Comparator<E> comparator){\r\n    assertSame(comparator, set.comparator());\r\n    verifySetContents(set, iterable);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultimap.remove",
	"Comment": "guaranteed to throw an exception and leave the multimap unmodified.",
	"Method": "boolean remove(Object key,Object value){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableRangeSet.subRangeSet",
	"Comment": "returns a view of the intersection of this range set with the given range.",
	"Method": "ImmutableRangeSet<C> subRangeSet(Range<C> range){\r\n    if (!isEmpty()) {\r\n        Range<C> span = span();\r\n        if (range.encloses(span)) {\r\n            return this;\r\n        } else if (range.isConnected(span)) {\r\n            return new ImmutableRangeSet<C>(intersectRanges(range));\r\n        }\r\n    }\r\n    return of();\r\n}"
}, {
	"Path": "com.google.common.reflect.TypesTest.testNewParameterizedTypeImmutability",
	"Comment": "working with arrays requires defensive code. verify that we clone the type array for both inputand output.",
	"Method": "void testNewParameterizedTypeImmutability(){\r\n    Type[] typesIn = { String.class, Integer.class };\r\n    ParameterizedType parameterizedType = Types.newParameterizedType(Map.class, typesIn);\r\n    typesIn[0] = null;\r\n    typesIn[1] = null;\r\n    Type[] typesOut = parameterizedType.getActualTypeArguments();\r\n    typesOut[0] = null;\r\n    typesOut[1] = null;\r\n    assertEquals(String.class, parameterizedType.getActualTypeArguments()[0]);\r\n    assertEquals(Integer.class, parameterizedType.getActualTypeArguments()[1]);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AtomicDoubleArrayTest.testIndexing",
	"Comment": "get and set for out of bound indices throw indexoutofboundsexception",
	"Method": "void testIndexing(){\r\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\r\n    for (int index : new int[] { -1, SIZE }) {\r\n        try {\r\n            aa.get(index);\r\n            fail();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.set(index, 1.0);\r\n            fail();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.lazySet(index, 1.0);\r\n            fail();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.compareAndSet(index, 1.0, 2.0);\r\n            fail();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.weakCompareAndSet(index, 1.0, 2.0);\r\n            fail();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.getAndAdd(index, 1.0);\r\n            fail();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.addAndGet(index, 1.0);\r\n            fail();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.EvictingQueue.add",
	"Comment": "adds the given element to this queue. if the queue is currently full, the element at the headof the queue is evicted to make room.",
	"Method": "boolean add(E e){\r\n    checkNotNull(e);\r\n    if (maxSize == 0) {\r\n        return true;\r\n    }\r\n    if (size() == maxSize) {\r\n        delegate.remove();\r\n    }\r\n    delegate.add(e);\r\n    return true;\r\n}"
}, {
	"Path": "com.google.common.testing.EqualsTesterTest.testInvalidHashCode",
	"Comment": "test for an invalid hashcode method, i.e., one that returns different value for objects thatare equal according to the equals method",
	"Method": "void testInvalidHashCode(){\r\n    Object a = new InvalidHashCodeObject(1, 2);\r\n    Object b = new InvalidHashCodeObject(1, 2);\r\n    equalsTester.addEqualityGroup(a, b);\r\n    try {\r\n        equalsTester.testEquals();\r\n    } catch (AssertionFailedError e) {\r\n        assertErrorMessage(e, \"the Object#hashCode (\" + a.hashCode() + \") of \" + a + \" [group 1, item 1] must be equal to the Object#hashCode (\" + b.hashCode() + \") of \" + b);\r\n        return;\r\n    }\r\n    fail(\"Should get invalid hashCode error\");\r\n}"
}, {
	"Path": "com.google.inject.assistedinject.FactoryProvider2.invoke",
	"Comment": "when a factory method is invoked, we create a child injector that binds all parameters, thenuse that to get an instance of the return type.",
	"Method": "Object invoke(Object proxy,Method method,Object[] args){\r\n    if (methodHandleByMethod.containsKey(method)) {\r\n        return methodHandleByMethod.get(method).invokeWithArguments(args);\r\n    }\r\n    if (method.getDeclaringClass().equals(Object.class)) {\r\n        if (\"equals\".equals(method.getName())) {\r\n            return proxy == args[0];\r\n        } else if (\"hashCode\".equals(method.getName())) {\r\n            return System.identityHashCode(proxy);\r\n        } else {\r\n            return method.invoke(this, args);\r\n        }\r\n    }\r\n    AssistData data = assistDataByMethod.get(method);\r\n    checkState(data != null, \"No data for method: %s\", method);\r\n    Provider<?> provider;\r\n    if (data.cachedBinding != null) {\r\n        provider = data.cachedBinding.getProvider();\r\n    } else {\r\n        provider = getBindingFromNewInjector(method, args, data).getProvider();\r\n    }\r\n    try {\r\n        int p = 0;\r\n        for (ThreadLocalProvider tlp : data.providers) {\r\n            tlp.set(args[p++]);\r\n        }\r\n        return provider.get();\r\n    } catch (ProvisionException e) {\r\n        if (e.getErrorMessages().size() == 1) {\r\n            Message onlyError = getOnlyElement(e.getErrorMessages());\r\n            Throwable cause = onlyError.getCause();\r\n            if (cause != null && canRethrow(method, cause)) {\r\n                throw cause;\r\n            }\r\n        }\r\n        throw e;\r\n    } finally {\r\n        for (ThreadLocalProvider tlp : data.providers) {\r\n            tlp.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.ProvisionException.getErrorMessages",
	"Comment": "returns messages for the errors that caused this exception.",
	"Method": "Collection<Message> getErrorMessages(){\r\n    return messages;\r\n}"
}, {
	"Path": "com.google.common.io.MultiInputStream.advance",
	"Comment": "closes the current input stream and opens the next one, if any.",
	"Method": "void advance(){\r\n    close();\r\n    if (it.hasNext()) {\r\n        in = it.next().openStream();\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.waitForUninterruptibly",
	"Comment": "waits for the guard to be satisfied. waits at most the given time. may be called only by athread currently occupying this monitor.",
	"Method": "void waitForUninterruptibly(Guard guard,boolean waitForUninterruptibly,Guard guard,long time,TimeUnit unit){\r\n    final long timeoutNanos = toSafeNanos(time, unit);\r\n    if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {\r\n        throw new IllegalMonitorStateException();\r\n    }\r\n    if (guard.isSatisfied()) {\r\n        return true;\r\n    }\r\n    boolean signalBeforeWaiting = true;\r\n    final long startTime = initNanoTime(timeoutNanos);\r\n    boolean interrupted = Thread.interrupted();\r\n    try {\r\n        for (long remainingNanos = timeoutNanos; ; ) {\r\n            try {\r\n                return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\r\n            } catch (InterruptedException interrupt) {\r\n                interrupted = true;\r\n                if (guard.isSatisfied()) {\r\n                    return true;\r\n                }\r\n                signalBeforeWaiting = false;\r\n                remainingNanos = remainingNanos(startTime, timeoutNanos);\r\n            }\r\n        }\r\n    } finally {\r\n        if (interrupted) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMap.compute",
	"Comment": "guaranteed to throw an exception and leave the map unmodified.",
	"Method": "V compute(K key,BiFunction<? super K, ? super V, ? extends V> remappingFunction){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.GeneratedMonitorTest.isGuarded",
	"Comment": "determines whether the given method takes a guard as its first parameter.",
	"Method": "boolean isGuarded(Method method){\r\n    Class<?>[] parameterTypes = method.getParameterTypes();\r\n    return parameterTypes.length >= 1 && parameterTypes[0] == Monitor.Guard.class;\r\n}"
}, {
	"Path": "com.google.common.collect.testing.AbstractIteratorTester.internalExecuteAndCompare",
	"Comment": "apply this method to both iterators and return normally only if both produce the same response.",
	"Method": "void internalExecuteAndCompare(T reference,T target,IteratorOperation method){\r\n    Object referenceReturnValue = null;\r\n    PermittedMetaException referenceException = null;\r\n    Object targetReturnValue = null;\r\n    RuntimeException targetException = null;\r\n    try {\r\n        targetReturnValue = method.execute(target);\r\n    } catch (RuntimeException e) {\r\n        targetException = e;\r\n    }\r\n    try {\r\n        if (method == NEXT_METHOD && targetException == null && knownOrder == KnownOrder.UNKNOWN_ORDER) {\r\n            @SuppressWarnings(\"unchecked\")\r\n            E targetReturnValueFromNext = (E) targetReturnValue;\r\n            MultiExceptionListIterator multiExceptionListIterator = (MultiExceptionListIterator) reference;\r\n            multiExceptionListIterator.promoteToNext(targetReturnValueFromNext);\r\n        }\r\n        referenceReturnValue = method.execute(reference);\r\n    } catch (PermittedMetaException e) {\r\n        referenceException = e;\r\n    } catch (UnknownElementException e) {\r\n        Helpers.fail(e, e.getMessage());\r\n    }\r\n    if (referenceException == null) {\r\n        if (targetException != null) {\r\n            Helpers.fail(targetException, \"Target threw exception when reference did not\");\r\n        }\r\n        assertEquals(referenceReturnValue, targetReturnValue);\r\n        return;\r\n    }\r\n    if (targetException == null) {\r\n        fail(\"Target failed to throw \" + referenceException);\r\n    }\r\n    referenceException.assertPermitted(targetException);\r\n}"
}, {
	"Path": "com.google.common.io.ByteSourceTester.testSlice_constrainedRange",
	"Comment": "test that you can not expand the readable data in a previously sliced bytesource.",
	"Method": "void testSlice_constrainedRange(){\r\n    long size = source.read().length;\r\n    if (size >= 2) {\r\n        ByteSource sliced = source.slice(1, size - 2);\r\n        assertEquals(size - 2, sliced.read().length);\r\n        ByteSource resliced = sliced.slice(0, size - 1);\r\n        assertTrue(sliced.contentEquals(resliced));\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultimap.of",
	"Comment": "returns an immutable multimap containing the given entries, in order.",
	"Method": "ImmutableMultimap<K, V> of(ImmutableMultimap<K, V> of,K k1,V v1,ImmutableMultimap<K, V> of,K k1,V v1,K k2,V v2,ImmutableMultimap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,ImmutableMultimap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,ImmutableMultimap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,K k5,V v5){\r\n    return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.StripedTest.testBasicInvariants",
	"Comment": "checks idempotency, and that we observe the promised number of stripes.",
	"Method": "void testBasicInvariants(){\r\n    for (Striped<?> striped : allImplementations()) {\r\n        assertBasicInvariants(striped);\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ComparisonChain.start",
	"Comment": "begins a new chained comparison statement. see example in the class documentation.",
	"Method": "ComparisonChain start(){\r\n    return ACTIVE;\r\n}"
}, {
	"Path": "com.google.common.io.MoreFiles.listFiles",
	"Comment": "returns an immutable list of paths to the files contained in the given directory.",
	"Method": "ImmutableList<Path> listFiles(Path dir){\r\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {\r\n        return ImmutableList.copyOf(stream);\r\n    } catch (DirectoryIteratorException e) {\r\n        throw e.getCause();\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.internal.DeferredLookups.initialize",
	"Comment": "initialize the specified lookups, either immediately or when the injector is created.",
	"Method": "void initialize(Errors errors){\r\n    injector.lookups = injector;\r\n    new LookupProcessor(errors).process(injector, lookups);\r\n}"
}, {
	"Path": "com.google.common.collect.TreeMultimapExplicitTest.testMultimapCreateFromTreeMultimap",
	"Comment": "test that a treemultimap created from another uses the natural ordering.",
	"Method": "void testMultimapCreateFromTreeMultimap(){\r\n    TreeMultimap<String, Integer> tree = TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);\r\n    tree.put(\"google\", 2);\r\n    tree.put(\"google\", 6);\r\n    tree.put(\"tree\", 0);\r\n    tree.put(\"tree\", 3);\r\n    assertThat(tree.keySet()).containsExactly(\"tree\", \"google\").inOrder();\r\n    assertThat(tree.get(\"google\")).containsExactly(6, 2).inOrder();\r\n    TreeMultimap<String, Integer> copy = TreeMultimap.create(tree);\r\n    assertEquals(tree, copy);\r\n    assertThat(copy.keySet()).containsExactly(\"google\", \"tree\").inOrder();\r\n    assertThat(copy.get(\"google\")).containsExactly(2, 6).inOrder();\r\n    assertEquals(Ordering.natural(), copy.keyComparator());\r\n    assertEquals(Ordering.natural(), copy.valueComparator());\r\n    assertEquals(Ordering.natural(), copy.get(\"google\").comparator());\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.InterruptionUtil.requestInterruptIn",
	"Comment": "interrupts the current thread after sleeping for the specified delay.",
	"Method": "void requestInterruptIn(long time,TimeUnit unit){\r\n    checkNotNull(unit);\r\n    final Thread interruptee = Thread.currentThread();\r\n    new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                unit.sleep(time);\r\n            } catch (InterruptedException wontHappen) {\r\n                throw new AssertionError(wontHappen);\r\n            }\r\n            interruptee.interrupt();\r\n        }\r\n    }).start();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.InterruptionUtil.requestInterruptIn",
	"Comment": "interrupts the current thread after sleeping for the specified delay.",
	"Method": "void requestInterruptIn(long time,TimeUnit unit){\r\n    try {\r\n        unit.sleep(time);\r\n    } catch (InterruptedException wontHappen) {\r\n        throw new AssertionError(wontHappen);\r\n    }\r\n    interruptee.interrupt();\r\n}"
}, {
	"Path": "com.google.inject.internal.ConstructorBindingImpl.getInternalDependencies",
	"Comment": "returns a set of dependencies that can be iterated over to clean up stray jit bindings.",
	"Method": "Set<Dependency<?>> getInternalDependencies(){\r\n    ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder();\r\n    if (factory.constructorInjector == null) {\r\n        builder.add(constructorInjectionPoint);\r\n        try {\r\n            builder.addAll(InjectionPoint.forInstanceMethodsAndFields(constructorInjectionPoint.getDeclaringType()));\r\n        } catch (ConfigurationException ignored) {\r\n        }\r\n    } else {\r\n        builder.add(getConstructor()).addAll(getInjectableMembers());\r\n    }\r\n    return Dependency.forInjectionPoints(builder.build());\r\n}"
}, {
	"Path": "org.apache.dubbo.common.utils.ConcurrentHashSet.clear",
	"Comment": "removes all of the elements from this set. the set will be empty afterthis call returns.",
	"Method": "void clear(){\r\n    map.clear();\r\n}"
}, {
	"Path": "com.google.common.io.CharStreamsTest.wrapAsGenericReadable",
	"Comment": "wrap a readable in a readable to defeat any type specific optimizations.",
	"Method": "Readable wrapAsGenericReadable(Readable a){\r\n    return new Readable() {\r\n        @Override\r\n        public int read(CharBuffer cb) throws IOException {\r\n            return a.read(cb);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.google.common.io.CharStreamsTest.wrapAsGenericReadable",
	"Comment": "wrap a readable in a readable to defeat any type specific optimizations.",
	"Method": "Readable wrapAsGenericReadable(Readable a){\r\n    return a.read(cb);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMap.remove",
	"Comment": "guaranteed to throw an exception and leave the map unmodified.",
	"Method": "V remove(Object o,boolean remove,Object key,Object value){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.inject.internal.InjectorShell.bindInjector",
	"Comment": "the injector is a special case because we allow both parent and child injectors to both have abinding for that key.",
	"Method": "void bindInjector(InjectorImpl injector){\r\n    Key<Injector> key = Key.get(Injector.class);\r\n    InjectorFactory injectorFactory = new InjectorFactory(injector);\r\n    injector.state.putBinding(key, new ProviderInstanceBindingImpl<Injector>(injector, key, SourceProvider.UNKNOWN_SOURCE, injectorFactory, Scoping.UNSCOPED, injectorFactory, ImmutableSet.<InjectionPoint>of()));\r\n}"
}, {
	"Path": "org.apache.dubbo.common.threadlocal.InternalThreadLocal.size",
	"Comment": "returns the number of thread local variables bound to the current thread.",
	"Method": "int size(){\r\n    InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.getIfSet();\r\n    if (threadLocalMap == null) {\r\n        return 0;\r\n    } else {\r\n        return threadLocalMap.size();\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSortedMap.entrySet",
	"Comment": "returns an immutable set of the mappings in this map, sorted by the key ordering.",
	"Method": "ImmutableSet<Entry<K, V>> entrySet(){\r\n    return super.entrySet();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSortedSet.pollFirst",
	"Comment": "guaranteed to throw an exception and leave the set unmodified.",
	"Method": "E pollFirst(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.testing.testers.AbstractListTester.reportContext",
	"Comment": "used to delay string formatting until actually required, as it otherwise shows up in the testexecution profile when running an extremely large numbers of tests.",
	"Method": "String reportContext(List<E> expected){\r\n    return Platform.format(\"expected collection %s; actual collection %s\", expected, this.collection);\r\n}"
}, {
	"Path": "com.google.common.collect.Platform.newLinkedHashMapWithExpectedSize",
	"Comment": "returns the platform preferred implementation of an insertion ordered map based on a hashtable.",
	"Method": "Map<K, V> newLinkedHashMapWithExpectedSize(int expectedSize){\r\n    return Maps.newLinkedHashMapWithExpectedSize(expectedSize);\r\n}"
}, {
	"Path": "com.zaxxer.hikari.pool.HikariPool.setHealthCheckRegistry",
	"Comment": "set the health check registry to be used when registering health checks.currently only codahale health checks are supported.",
	"Method": "void setHealthCheckRegistry(Object healthCheckRegistry){\r\n    if (healthCheckRegistry != null) {\r\n        CodahaleHealthChecker.registerHealthChecks(this, config, (HealthCheckRegistry) healthCheckRegistry);\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.waitFor",
	"Comment": "waits for the guard to be satisfied. waits at most the given time, and may be interrupted. maybe called only by a thread currently occupying this monitor.",
	"Method": "void waitFor(Guard guard,boolean waitFor,Guard guard,long time,TimeUnit unit){\r\n    final long timeoutNanos = toSafeNanos(time, unit);\r\n    if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {\r\n        throw new IllegalMonitorStateException();\r\n    }\r\n    if (guard.isSatisfied()) {\r\n        return true;\r\n    }\r\n    if (Thread.interrupted()) {\r\n        throw new InterruptedException();\r\n    }\r\n    return awaitNanos(guard, timeoutNanos, true);\r\n}"
}, {
	"Path": "com.google.common.collect.EvictingQueue.offer",
	"Comment": "adds the given element to this queue. if the queue is currently full, the element at the headof the queue is evicted to make room.",
	"Method": "boolean offer(E e){\r\n    return add(e);\r\n}"
}, {
	"Path": "com.google.common.collect.testing.features.FeatureUtil.incorporateRequirements",
	"Comment": "incorporate additional requirements into an existing requirements object.",
	"Method": "TesterRequirements incorporateRequirements(TesterRequirements requirements,TesterRequirements moreRequirements,Object source){\r\n    Set<Feature<?>> presentFeatures = requirements.getPresentFeatures();\r\n    Set<Feature<?>> absentFeatures = requirements.getAbsentFeatures();\r\n    Set<Feature<?>> morePresentFeatures = moreRequirements.getPresentFeatures();\r\n    Set<Feature<?>> moreAbsentFeatures = moreRequirements.getAbsentFeatures();\r\n    checkConflict(\"absent\", absentFeatures, \"present\", morePresentFeatures, source);\r\n    checkConflict(\"present\", presentFeatures, \"absent\", moreAbsentFeatures, source);\r\n    presentFeatures.addAll(morePresentFeatures);\r\n    absentFeatures.addAll(moreAbsentFeatures);\r\n    return requirements;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.testing.AbstractListenableFutureTest.testAllListenersCompleteSuccessfully",
	"Comment": "tests that all listeners complete, even if they were added before or after the future wasfinishing. also acts as a concurrency test to make sure the locking is done correctly when afuture is finishing so that no listeners can be lost.",
	"Method": "void testAllListenersCompleteSuccessfully(){\r\n    ExecutorService exec = Executors.newCachedThreadPool();\r\n    int listenerCount = 20;\r\n    final CountDownLatch listenerLatch = new CountDownLatch(listenerCount);\r\n    for (int i = 0; i < 20; i++) {\r\n        if (i == 10) {\r\n            new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    latch.countDown();\r\n                }\r\n            }).start();\r\n        }\r\n        future.addListener(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                listenerLatch.countDown();\r\n            }\r\n        }, exec);\r\n    }\r\n    assertSame(Boolean.TRUE, future.get());\r\n    listenerLatch.await(500, TimeUnit.MILLISECONDS);\r\n    exec.shutdown();\r\n    exec.awaitTermination(500, TimeUnit.MILLISECONDS);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.testing.AbstractListenableFutureTest.testAllListenersCompleteSuccessfully",
	"Comment": "tests that all listeners complete, even if they were added before or after the future wasfinishing. also acts as a concurrency test to make sure the locking is done correctly when afuture is finishing so that no listeners can be lost.",
	"Method": "void testAllListenersCompleteSuccessfully(){\r\n    latch.countDown();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.testing.AbstractListenableFutureTest.testAllListenersCompleteSuccessfully",
	"Comment": "tests that all listeners complete, even if they were added before or after the future wasfinishing. also acts as a concurrency test to make sure the locking is done correctly when afuture is finishing so that no listeners can be lost.",
	"Method": "void testAllListenersCompleteSuccessfully(){\r\n    listenerLatch.countDown();\r\n}"
}, {
	"Path": "com.google.common.collect.AbstractBiMap.checkKey",
	"Comment": "returns its input, or throws an exception if this is not a valid key.",
	"Method": "K checkKey(K key,K checkKey,K key){\r\n    return key;\r\n}"
}, {
	"Path": "com.google.common.net.PercentEscaper.createSafeOctets",
	"Comment": "creates a boolean array with entries corresponding to the character values specified insafechars set to true. the array is as small as is required to hold the given characterinformation.",
	"Method": "boolean[] createSafeOctets(String safeChars){\r\n    int maxChar = -1;\r\n    char[] safeCharArray = safeChars.toCharArray();\r\n    for (char c : safeCharArray) {\r\n        maxChar = Math.max(c, maxChar);\r\n    }\r\n    boolean[] octets = new boolean[maxChar + 1];\r\n    for (char c : safeCharArray) {\r\n        octets[c] = true;\r\n    }\r\n    return octets;\r\n}"
}, {
	"Path": "com.google.common.collect.testing.testers.NavigableMapNavigationTester.resetWithHole",
	"Comment": "resets the contents of navigablemap to have entries a, c, for the navigation tests.",
	"Method": "void resetWithHole(){\r\n    Entry<K, V>[] entries = new Entry[] { a, c };\r\n    super.resetMap(entries);\r\n    navigableMap = (NavigableMap<K, V>) getMap();\r\n}"
}, {
	"Path": "com.google.common.net.InetAddresses.increment",
	"Comment": "returns a new inetaddress that is one more than the passed in address. this method works forboth ipv4 and ipv6 addresses.",
	"Method": "InetAddress increment(InetAddress address){\r\n    byte[] addr = address.getAddress();\r\n    int i = addr.length - 1;\r\n    while (i >= 0 && addr[i] == (byte) 0xff) {\r\n        addr[i] = 0;\r\n        i--;\r\n    }\r\n    checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\r\n    addr[i]++;\r\n    return bytesToInetAddress(addr);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableListMultimap.get",
	"Comment": "returns an immutable list of the values for the given key. if no mappings in the multimap havethe provided key, an empty immutable list is returned. the values are in the same order as theparameters used to build this multimap.",
	"Method": "ImmutableList<V> get(K key){\r\n    ImmutableList<V> list = (ImmutableList<V>) map.get(key);\r\n    return (list == null) ? ImmutableList.<V>of() : list;\r\n}"
}, {
	"Path": "com.google.inject.internal.MultibinderTest.testConcurrentMutation_bindingsDiffentAtInjectorCreation",
	"Comment": "verify through gratuitous mutation that key hashcode snapshots and whatnot happens at the righttimes, by binding two lists that are different at injector creation, but compare equal when themodule is configuredwhen the set is instantiated.",
	"Method": "void testConcurrentMutation_bindingsDiffentAtInjectorCreation(){\r\n    final List<String> list1 = Lists.newArrayList();\r\n    final List<String> list2 = Lists.newArrayList();\r\n    Module module = new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            Multibinder<List<String>> multibinder = Multibinder.newSetBinder(binder(), listOfStrings);\r\n            multibinder.addBinding().toInstance(list1);\r\n            multibinder.addBinding().toInstance(list2);\r\n        }\r\n    };\r\n    List<Element> elements = Elements.getElements(module);\r\n    list1.add(\"A\");\r\n    list2.add(\"B\");\r\n    Injector injector = Guice.createInjector(Elements.getModule(elements));\r\n    list1.add(1, \"B\");\r\n    list2.add(0, \"A\");\r\n    try {\r\n        injector.getInstance(Key.get(setOfListOfStrings));\r\n        fail();\r\n    } catch (ProvisionException e) {\r\n        assertEquals(1, e.getErrorMessages().size());\r\n        assertContains(Iterables.getOnlyElement(e.getErrorMessages()).getMessage().toString(), \"Set injection failed due to duplicated element \\\"[A, B]\\\"\");\r\n    }\r\n    list1.remove(\"A\");\r\n    list2.remove(\"B\");\r\n    Set<List<String>> set = injector.getInstance(Key.get(setOfListOfStrings));\r\n    assertEquals(ImmutableSet.of(ImmutableList.of(\"A\"), ImmutableList.of(\"B\")), set);\r\n}"
}, {
	"Path": "com.google.inject.internal.MultibinderTest.testConcurrentMutation_bindingsDiffentAtInjectorCreation",
	"Comment": "verify through gratuitous mutation that key hashcode snapshots and whatnot happens at the righttimes, by binding two lists that are different at injector creation, but compare equal when themodule is configuredwhen the set is instantiated.",
	"Method": "void testConcurrentMutation_bindingsDiffentAtInjectorCreation(){\r\n    Multibinder<List<String>> multibinder = Multibinder.newSetBinder(binder(), listOfStrings);\r\n    multibinder.addBinding().toInstance(list1);\r\n    multibinder.addBinding().toInstance(list2);\r\n}"
}, {
	"Path": "com.google.common.io.MoreFiles.equal",
	"Comment": "returns true if the files located by the given paths exist, are not directories, and containthe same bytes.",
	"Method": "boolean equal(Path path1,Path path2){\r\n    checkNotNull(path1);\r\n    checkNotNull(path2);\r\n    if (Files.isSameFile(path1, path2)) {\r\n        return true;\r\n    }\r\n    ByteSource source1 = asByteSource(path1);\r\n    ByteSource source2 = asByteSource(path2);\r\n    long len1 = source1.sizeIfKnown().or(0L);\r\n    long len2 = source2.sizeIfKnown().or(0L);\r\n    if (len1 != 0 && len2 != 0 && len1 != len2) {\r\n        return false;\r\n    }\r\n    return source1.contentEquals(source2);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.GeneratedMonitorTest.isWaitFor",
	"Comment": "identifies all waitforxxx methods, which must be called while occupying the monitor.",
	"Method": "boolean isWaitFor(Method method){\r\n    return method.getName().startsWith(\"waitFor\");\r\n}"
}, {
	"Path": "com.google.inject.spi.Dependency.get",
	"Comment": "returns a new dependency that is not attached to an injection point. the returned dependency isnullable.",
	"Method": "Dependency<T> get(Key<T> key){\r\n    return new Dependency<T>(null, MoreTypes.canonicalizeKey(key), true, -1);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.JSR166TestCase.getShortDelay",
	"Comment": "returns the shortest timed delay. this could be reimplemented to use for example a property.",
	"Method": "long getShortDelay(){\r\n    return 50;\r\n}"
}, {
	"Path": "com.zaxxer.hikari.util.ConcurrentBag.borrow",
	"Comment": "the method will borrow a bagentry from the bag, blocking for the specified timeout if none are available.",
	"Method": "T borrow(long timeout,TimeUnit timeUnit){\r\n    final List<Object> list = threadList.get();\r\n    for (int i = list.size() - 1; i >= 0; i--) {\r\n        final Object entry = list.remove(i);\r\n        @SuppressWarnings(\"unchecked\")\r\n        final T bagEntry = weakThreadLocals ? ((WeakReference<T>) entry).get() : (T) entry;\r\n        if (bagEntry != null && bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {\r\n            return bagEntry;\r\n        }\r\n    }\r\n    final int waiting = waiters.incrementAndGet();\r\n    try {\r\n        for (T bagEntry : sharedList) {\r\n            if (bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {\r\n                if (waiting > 1) {\r\n                    listener.addBagItem(waiting - 1);\r\n                }\r\n                return bagEntry;\r\n            }\r\n        }\r\n        listener.addBagItem(waiting);\r\n        timeout = timeUnit.toNanos(timeout);\r\n        do {\r\n            final long start = currentTime();\r\n            final T bagEntry = handoffQueue.poll(timeout, NANOSECONDS);\r\n            if (bagEntry == null || bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {\r\n                return bagEntry;\r\n            }\r\n            timeout -= elapsedNanos(start);\r\n        } while (timeout > 10_000);\r\n        return null;\r\n    } finally {\r\n        waiters.decrementAndGet();\r\n    }\r\n}"
}, {
	"Path": "com.google.common.io.MoreFiles.getParentPath",
	"Comment": "returns a path to the parent directory of the given path. if the path actually has a parentpath, this is simple. otherwise, we need to do some trickier things. returns null if the pathis a root or is the empty path.",
	"Method": "Path getParentPath(Path path){\r\n    Path parent = path.getParent();\r\n    if (parent != null) {\r\n        return parent;\r\n    }\r\n    if (path.getNameCount() == 0) {\r\n        return null;\r\n    } else {\r\n        return path.getFileSystem().getPath(\".\");\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultimap.asMap",
	"Comment": "returns an immutable map that associates each key with its corresponding values in themultimap. keys and values appear in the same order as in this multimap.",
	"Method": "ImmutableMap<K, Collection<V>> asMap(){\r\n    return (ImmutableMap) map;\r\n}"
}, {
	"Path": "com.google.common.collect.ArrayTable.rowKeySet",
	"Comment": "returns an immutable set of the valid row keys, including those that are associated with nullvalues only.",
	"Method": "ImmutableSet<R> rowKeySet(){\r\n    return rowKeyToIndex.keySet();\r\n}"
}, {
	"Path": "com.google.common.collect.GeneralRange.reverse",
	"Comment": "returns the same range relative to the reversed comparator.",
	"Method": "GeneralRange<T> reverse(){\r\n    GeneralRange<T> result = reverse;\r\n    if (result == null) {\r\n        result = new GeneralRange<T>(Ordering.from(comparator).reverse(), hasUpperBound, getUpperEndpoint(), getUpperBoundType(), hasLowerBound, getLowerEndpoint(), getLowerBoundType());\r\n        result.reverse = this;\r\n        return this.reverse = result;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSortedMap.copyOfSorted",
	"Comment": "returns an immutable map containing the same entries as the provided sorted map, with the sameordering.despite the method name, this method attempts to avoid actually copying the data when it issafe to do so. the exact circumstances under which a copy will or will not be performed areundocumented and subject to change.",
	"Method": "ImmutableSortedMap<K, V> copyOfSorted(SortedMap<K, ? extends V> map){\r\n    @SuppressWarnings(\"unchecked\")\r\n    Comparator<? super K> comparator = (map.comparator() == null) ? NATURAL_ORDER : map.comparator();\r\n    return copyOfInternal(map, comparator);\r\n}"
}, {
	"Path": "com.google.common.collect.AbstractBiMapTest.testIdentityKeySetIteratorRemove",
	"Comment": "removed, since identityhashmap throws an exception when that occurs.",
	"Method": "void testIdentityKeySetIteratorRemove(){\r\n    BiMap<Integer, String> bimap = new AbstractBiMap<Integer, String>(new IdentityHashMap<Integer, String>(), new IdentityHashMap<String, Integer>()) {\r\n    };\r\n    bimap.put(1, \"one\");\r\n    bimap.put(2, \"two\");\r\n    bimap.put(3, \"three\");\r\n    Iterator<Integer> iterator = bimap.keySet().iterator();\r\n    iterator.next();\r\n    iterator.next();\r\n    iterator.remove();\r\n    iterator.next();\r\n    iterator.remove();\r\n    assertEquals(1, bimap.size());\r\n    assertEquals(1, bimap.inverse().size());\r\n}"
}, {
	"Path": "com.google.common.hash.HashCodeTest.testFromInt",
	"Comment": "expectedhashcodes must contain at least one hash code with 4 bytes",
	"Method": "void testFromInt(){\r\n    for (ExpectedHashCode expected : expectedHashCodes) {\r\n        if (expected.bytes.length == 4) {\r\n            HashCode fromInt = HashCode.fromInt(expected.asInt);\r\n            assertExpectedHashCode(expected, fromInt);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.hash.LongAdder.reset",
	"Comment": "resets variables maintaining the sum to zero. this method may be a useful alternative tocreating a new adder, but is only effective if there are no concurrent updates. because thismethod is intrinsically racy, it should only be used when it is known that no threads areconcurrently updating.",
	"Method": "void reset(){\r\n    internalReset(0L);\r\n}"
}, {
	"Path": "com.zaxxer.hikari.pool.HikariPool.setMetricRegistry",
	"Comment": "set a metrics registry to be used when registering metrics collectors.the hikaridatasource prevents this method from being called more than once.",
	"Method": "void setMetricRegistry(Object metricRegistry){\r\n    if (metricRegistry != null && safeIsAssignableFrom(metricRegistry, \"com.codahale.metrics.MetricRegistry\")) {\r\n        setMetricsTrackerFactory(new CodahaleMetricsTrackerFactory((MetricRegistry) metricRegistry));\r\n    } else if (metricRegistry != null && safeIsAssignableFrom(metricRegistry, \"io.micrometer.core.instrument.MeterRegistry\")) {\r\n        setMetricsTrackerFactory(new MicrometerMetricsTrackerFactory((MeterRegistry) metricRegistry));\r\n    } else {\r\n        setMetricsTrackerFactory(null);\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.internal.MultibinderTest.testModuleOverrideAndMultibindings",
	"Comment": "with overrides, we should get the union of all multibindings.",
	"Method": "void testModuleOverrideAndMultibindings(){\r\n    Module ab = new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);\r\n            multibinder.addBinding().toInstance(\"A\");\r\n            multibinder.addBinding().toInstance(\"B\");\r\n        }\r\n    };\r\n    Module cd = new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);\r\n            multibinder.addBinding().toInstance(\"C\");\r\n            multibinder.addBinding().toInstance(\"D\");\r\n        }\r\n    };\r\n    Module ef = new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);\r\n            multibinder.addBinding().toInstance(\"E\");\r\n            multibinder.addBinding().toInstance(\"F\");\r\n        }\r\n    };\r\n    Module abcd = Modules.override(ab).with(cd);\r\n    Injector injector = Guice.createInjector(abcd, ef);\r\n    assertEquals(ImmutableSet.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"), injector.getInstance(Key.get(setOfString)));\r\n    assertSetVisitor(Key.get(setOfString), stringType, setOf(abcd, ef), BOTH, false, 0, instance(\"A\"), instance(\"B\"), instance(\"C\"), instance(\"D\"), instance(\"E\"), instance(\"F\"));\r\n}"
}, {
	"Path": "com.google.inject.internal.MultibinderTest.testModuleOverrideAndMultibindings",
	"Comment": "with overrides, we should get the union of all multibindings.",
	"Method": "void testModuleOverrideAndMultibindings(){\r\n    Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);\r\n    multibinder.addBinding().toInstance(\"A\");\r\n    multibinder.addBinding().toInstance(\"B\");\r\n}"
}, {
	"Path": "com.google.inject.internal.MultibinderTest.testModuleOverrideAndMultibindings",
	"Comment": "with overrides, we should get the union of all multibindings.",
	"Method": "void testModuleOverrideAndMultibindings(){\r\n    Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);\r\n    multibinder.addBinding().toInstance(\"C\");\r\n    multibinder.addBinding().toInstance(\"D\");\r\n}"
}, {
	"Path": "com.google.inject.internal.MultibinderTest.testModuleOverrideAndMultibindings",
	"Comment": "with overrides, we should get the union of all multibindings.",
	"Method": "void testModuleOverrideAndMultibindings(){\r\n    Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);\r\n    multibinder.addBinding().toInstance(\"E\");\r\n    multibinder.addBinding().toInstance(\"F\");\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.getWaitQueueLength",
	"Comment": "returns an estimate of the number of threads waiting for the given guard to become satisfied.note that because timeouts and interrupts may occur at any time, the estimate serves only as anupper bound on the actual number of waiters. this method is designed for use in monitoring ofthe system state, not for synchronization control.",
	"Method": "int getWaitQueueLength(Guard guard){\r\n    if (guard.monitor != this) {\r\n        throw new IllegalMonitorStateException();\r\n    }\r\n    lock.lock();\r\n    try {\r\n        return guard.waiterCount;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "com.zaxxer.hikari.pool.HikariPool.setMetricsTrackerFactory",
	"Comment": "set the metricstrackerfactory to be used to create the imetricstracker instance used by the pool.",
	"Method": "void setMetricsTrackerFactory(MetricsTrackerFactory metricsTrackerFactory){\r\n    if (metricsTrackerFactory != null) {\r\n        this.metricsTracker = new MetricsTrackerDelegate(metricsTrackerFactory.create(config.getPoolName(), getPoolStats()));\r\n    } else {\r\n        this.metricsTracker = new NopMetricsTrackerDelegate();\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMap.merge",
	"Comment": "guaranteed to throw an exception and leave the map unmodified.",
	"Method": "V merge(K key,V value,BiFunction<? super V, ? super V, ? extends V> remappingFunction){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.ThreadFactoryBuilder.setDaemon",
	"Comment": "sets daemon or not for new threads created with this threadfactory.",
	"Method": "ThreadFactoryBuilder setDaemon(boolean daemon){\r\n    this.daemon = daemon;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.common.testing.GcFinalization.createUnreachableLatchFinalizer",
	"Comment": "creates a garbage object that counts down the latch in its finalizer. sequestered into aseparate method to make it somewhat more likely to be unreachable.",
	"Method": "void createUnreachableLatchFinalizer(CountDownLatch latch){\r\n    new Object() {\r\n        @Override\r\n        protected void finalize() {\r\n            latch.countDown();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.google.common.testing.GcFinalization.createUnreachableLatchFinalizer",
	"Comment": "creates a garbage object that counts down the latch in its finalizer. sequestered into aseparate method to make it somewhat more likely to be unreachable.",
	"Method": "void createUnreachableLatchFinalizer(CountDownLatch latch){\r\n    latch.countDown();\r\n}"
}, {
	"Path": "com.google.common.io.ByteStreams.toByteArray",
	"Comment": "reads all bytes from an input stream into a byte array. the given expected size is used tocreate an initial byte array, but if the actual number of bytes read from the stream differs,the correct result will be returned anyway.",
	"Method": "byte[] toByteArray(InputStream in,byte[] toByteArray,InputStream in,long expectedSize,byte[] toByteArray){\r\n    checkArgument(expectedSize >= 0, \"expectedSize (%s) must be non-negative\", expectedSize);\r\n    if (expectedSize > MAX_ARRAY_LEN) {\r\n        throw new OutOfMemoryError(expectedSize + \" bytes is too large to fit in a byte array\");\r\n    }\r\n    byte[] bytes = new byte[(int) expectedSize];\r\n    int remaining = (int) expectedSize;\r\n    while (remaining > 0) {\r\n        int off = (int) expectedSize - remaining;\r\n        int read = in.read(bytes, off, remaining);\r\n        if (read == -1) {\r\n            return Arrays.copyOf(bytes, off);\r\n        }\r\n        remaining -= read;\r\n    }\r\n    int b = in.read();\r\n    if (b == -1) {\r\n        return bytes;\r\n    }\r\n    Deque<byte[]> bufs = new ArrayDeque<byte[]>(TO_BYTE_ARRAY_DEQUE_SIZE + 2);\r\n    bufs.add(bytes);\r\n    bufs.add(new byte[] { (byte) b });\r\n    return toByteArrayInternal(in, bufs, bytes.length + 1);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultimap.replaceValues",
	"Comment": "guaranteed to throw an exception and leave the multimap unmodified.",
	"Method": "ImmutableCollection<V> replaceValues(K key,Iterable<? extends V> values){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.net.InetAddresses.fromInteger",
	"Comment": "returns an inet4address having the integer value specified by the argument.",
	"Method": "Inet4Address fromInteger(int address){\r\n    return getInet4Address(Ints.toByteArray(address));\r\n}"
}, {
	"Path": "com.google.inject.internal.ConstructorInjectorStore.get",
	"Comment": "returns a new complete constructor injector with injection listeners registered.",
	"Method": "ConstructorInjector<?> get(InjectionPoint constructorInjector,Errors errors){\r\n    return cache.get(constructorInjector, errors);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultiset.remove",
	"Comment": "guaranteed to throw an exception and leave the collection unmodified.",
	"Method": "int remove(Object element,int occurrences){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.testing.google.MultisetNavigationTester.resetWithHole",
	"Comment": "resets the contents of sortedmultiset to have entries a, c, for the navigation tests.",
	"Method": "void resetWithHole(){\r\n    List<E> container = new ArrayList<E>();\r\n    container.addAll(Collections.nCopies(a.getCount(), a.getElement()));\r\n    container.addAll(Collections.nCopies(c.getCount(), c.getElement()));\r\n    super.resetContainer(getSubjectGenerator().create(container.toArray()));\r\n    sortedMultiset = (SortedMultiset<E>) getMultiset();\r\n}"
}, {
	"Path": "com.google.common.collect.CompactHashSet.insertEntry",
	"Comment": "creates a fresh entry with the specified object at the specified position in the entry arrays.",
	"Method": "void insertEntry(int entryIndex,E object,int hash){\r\n    this.entries[entryIndex] = ((long) hash << 32) | (NEXT_MASK & UNSET);\r\n    this.elements[entryIndex] = object;\r\n}"
}, {
	"Path": "com.google.inject.ConfigurationException.getPartialValue",
	"Comment": "returns a value that was only partially computed due to this exception. the caller can use thiswhile collecting additional configuration problems.",
	"Method": "E getPartialValue(){\r\n    return (E) partialValue;\r\n}"
}, {
	"Path": "com.google.common.net.UrlEscapersTest.assertBasicUrlEscaper",
	"Comment": "helper to assert common expected behaviour of uri escapers.",
	"Method": "void assertBasicUrlEscaper(UnicodeEscaper e){\r\n    assertBasicUrlEscaperExceptPercent(e);\r\n    assertEscaping(e, \"%\", '%');\r\n}"
}, {
	"Path": "com.google.common.collect.ArrayTable.columnKeySet",
	"Comment": "returns an immutable set of the valid column keys, including those that are associated withnull values only.",
	"Method": "ImmutableSet<C> columnKeySet(){\r\n    return columnKeyToIndex.keySet();\r\n}"
}, {
	"Path": "com.google.common.collect.testing.AbstractTester.getTestMethodName",
	"Comment": "returns the name of the test method invoked by this test instance.",
	"Method": "String getTestMethodName(){\r\n    return super.getName();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.FuturesTest.testAllAsList_logging_same_exception",
	"Comment": "the same exception happening on multiple futures should not be logged.",
	"Method": "void testAllAsList_logging_same_exception(){\r\n    try {\r\n        MyException sameInstance = new MyException();\r\n        getDone(allAsList(immediateFailedFuture(sameInstance), immediateFailedFuture(sameInstance)));\r\n        fail();\r\n    } catch (ExecutionException expected) {\r\n        assertThat(expected.getCause()).isInstanceOf(MyException.class);\r\n        assertEquals(\"Nothing should be logged\", 0, aggregateFutureLogHandler.getStoredLogRecords().size());\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.ConfigurationException.getErrorMessages",
	"Comment": "returns messages for the errors that caused this exception.",
	"Method": "Collection<Message> getErrorMessages(){\r\n    return messages;\r\n}"
}, {
	"Path": "com.google.common.collect.Platform.newHashMapWithExpectedSize",
	"Comment": "returns the platform preferred implementation of a map based on a hash table.",
	"Method": "Map<K, V> newHashMapWithExpectedSize(int expectedSize){\r\n    return Maps.newHashMapWithExpectedSize(expectedSize);\r\n}"
}, {
	"Path": "com.google.inject.internal.AbstractBindingBuilder.annotatedWithInternal",
	"Comment": "sets the binding to a copy with the specified annotation on the bound key",
	"Method": "BindingImpl<T> annotatedWithInternal(Class<? extends Annotation> annotationType,BindingImpl<T> annotatedWithInternal,Annotation annotation){\r\n    checkNotNull(annotation, \"annotation\");\r\n    checkNotAnnotated();\r\n    return setBinding(binding.withKey(Key.get(this.binding.getKey().getTypeLiteral(), annotation)));\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AtomicDoubleArrayTest.testGetAndSet",
	"Comment": "getandset returns previous value and sets to given value at given index",
	"Method": "void testGetAndSet(){\r\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\r\n    for (int i : new int[] { 0, SIZE - 1 }) {\r\n        double prev = 0.0;\r\n        for (double x : VALUES) {\r\n            assertBitEquals(prev, aa.getAndSet(i, x));\r\n            prev = x;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.base.PredicatesTest.testIn_compilesWithExplicitSupertype",
	"Comment": "tests that compilation will work when applying explicit types.",
	"Method": "void testIn_compilesWithExplicitSupertype(){\r\n    Collection<Number> nums = ImmutableSet.of();\r\n    Predicate<Number> p1 = Predicates.in(nums);\r\n    Predicate<Object> p2 = Predicates.<Object>in(nums);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableCollection.removeAll",
	"Comment": "guaranteed to throw an exception and leave the collection unmodified.",
	"Method": "boolean removeAll(Collection<?> oldElements){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.inject.CreationException.getErrorMessages",
	"Comment": "returns messages for the errors that caused this exception.",
	"Method": "Collection<Message> getErrorMessages(){\r\n    return messages;\r\n}"
}, {
	"Path": "com.google.common.base.JoinerBenchmark.assignDelimiter",
	"Comment": "starts with an empty delimiter and changes to the desired value at the end of the iteration.",
	"Method": "int assignDelimiter(int reps){\r\n    int dummy = 0;\r\n    for (int i = 0; i < reps; i++) {\r\n        StringBuilder sb = new StringBuilder();\r\n        String delim = \"\";\r\n        for (String comp : components) {\r\n            sb.append(delim);\r\n            sb.append(comp);\r\n            delim = DELIMITER_STRING;\r\n        }\r\n        dummy ^= sb.toString().length();\r\n    }\r\n    return dummy;\r\n}"
}, {
	"Path": "com.google.common.collect.IterablesTest.testMergeSorted_skipping_pyramid",
	"Comment": "like the pyramid, but creates more unique values, along with repeated ones.",
	"Method": "void testMergeSorted_skipping_pyramid(){\r\n    List<Iterable<Integer>> iterables = Lists.newLinkedList();\r\n    List<Integer> allIntegers = Lists.newArrayList();\r\n    for (int i = 0; i < 20; i++) {\r\n        List<Integer> list = Lists.newLinkedList();\r\n        for (int j = 0; j < i; j++) {\r\n            list.add(j * i);\r\n            allIntegers.add(j * i);\r\n        }\r\n        iterables.add(Ordering.natural().sortedCopy(list));\r\n    }\r\n    verifyMergeSorted(iterables, allIntegers);\r\n}"
}, {
	"Path": "com.google.common.hash.Hashing.checkPositiveAndMakeMultipleOf32",
	"Comment": "checks that the passed argument is positive, and ceils it to a multiple of 32.",
	"Method": "int checkPositiveAndMakeMultipleOf32(int bits){\r\n    checkArgument(bits > 0, \"Number of bits must be positive\");\r\n    return (bits + 31) & ~31;\r\n}"
}, {
	"Path": "com.zaxxer.hikari.util.FastList.removeLast",
	"Comment": "remove the last element from the list.no bound check is performed, so if this method is called on an empty list and arrayindexoutofbounds exception will be thrown.",
	"Method": "T removeLast(){\r\n    T element = elementData[--size];\r\n    elementData[size] = null;\r\n    return element;\r\n}"
}, {
	"Path": "com.google.common.eventbus.EventBus.handleSubscriberException",
	"Comment": "handles the given exception thrown by a subscriber with the given context.",
	"Method": "void handleSubscriberException(Throwable e,SubscriberExceptionContext context){\r\n    checkNotNull(e);\r\n    checkNotNull(context);\r\n    try {\r\n        exceptionHandler.handleException(e, context);\r\n    } catch (Throwable e2) {\r\n        logger.log(Level.SEVERE, String.format(Locale.ROOT, \"Exception %s thrown while handling exception: %s\", e2, e), e2);\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.testing.features.FeatureUtil.buildDeclaredTesterRequirements",
	"Comment": "construct the set of requirements specified by annotations directly on a tester class ormethod.",
	"Method": "TesterRequirements buildDeclaredTesterRequirements(AnnotatedElement classOrMethod){\r\n    TesterRequirements requirements = new TesterRequirements();\r\n    Iterable<Annotation> testerAnnotations = getTesterAnnotations(classOrMethod);\r\n    for (Annotation testerAnnotation : testerAnnotations) {\r\n        TesterRequirements moreRequirements = buildTesterRequirements(testerAnnotation);\r\n        incorporateRequirements(requirements, moreRequirements, testerAnnotation);\r\n    }\r\n    return requirements;\r\n}"
}, {
	"Path": "com.google.inject.internal.ProviderMethodsModule.getAnnotation",
	"Comment": "returns the annotation that is claimed by the scanner, or null if there is none.",
	"Method": "Annotation getAnnotation(Binder binder,Method method){\r\n    if (method.isBridge() || method.isSynthetic()) {\r\n        return null;\r\n    }\r\n    Annotation annotation = null;\r\n    for (Class<? extends Annotation> annotationClass : scanner.annotationClasses()) {\r\n        Annotation foundAnnotation = method.getAnnotation(annotationClass);\r\n        if (foundAnnotation != null) {\r\n            if (annotation != null) {\r\n                binder.addError(\"More than one annotation claimed by %s on method %s.\" + \" Methods can only have one annotation claimed per scanner.\", scanner, method);\r\n                return null;\r\n            }\r\n            annotation = foundAnnotation;\r\n        }\r\n    }\r\n    return annotation;\r\n}"
}, {
	"Path": "com.google.inject.internal.SpiUtils.assertMapVisitor",
	"Comment": "asserts that mapbinderbinding visitors for work correctly.",
	"Method": "void assertMapVisitor(Key<T> mapKey,TypeLiteral<?> keyType,TypeLiteral<?> valueType,Iterable<? extends Module> modules,VisitType visitType,boolean allowDuplicates,int expectedMapBindings,MapResult results){\r\n    if (visitType == null) {\r\n        fail(\"must test something\");\r\n    }\r\n    if (visitType == BOTH || visitType == INJECTOR) {\r\n        mapInjectorTest(mapKey, keyType, valueType, modules, allowDuplicates, expectedMapBindings, results);\r\n    }\r\n    if (visitType == BOTH || visitType == MODULE) {\r\n        mapModuleTest(mapKey, keyType, valueType, modules, allowDuplicates, expectedMapBindings, results);\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableListMultimap.of",
	"Comment": "returns an immutable multimap containing the given entries, in order.",
	"Method": "ImmutableListMultimap<K, V> of(ImmutableListMultimap<K, V> of,K k1,V v1,ImmutableListMultimap<K, V> of,K k1,V v1,K k2,V v2,ImmutableListMultimap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,ImmutableListMultimap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,ImmutableListMultimap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,K k5,V v5){\r\n    ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();\r\n    builder.put(k1, v1);\r\n    builder.put(k2, v2);\r\n    builder.put(k3, v3);\r\n    builder.put(k4, v4);\r\n    builder.put(k5, v5);\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AtomicDoubleTest.testAddAndGet",
	"Comment": "addandget adds given value to current, and returns current value",
	"Method": "void testAddAndGet(){\r\n    for (double x : VALUES) {\r\n        for (double y : VALUES) {\r\n            AtomicDouble a = new AtomicDouble(x);\r\n            double z = a.addAndGet(y);\r\n            assertBitEquals(x + y, z);\r\n            assertBitEquals(x + y, a.get());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.ServiceManager.servicesByState",
	"Comment": "provides a snapshot of the current state of all the services under management.n.b. this snapshot is guaranteed to be consistent, i.e. the set of states returned willcorrespond to a point in time view of the services.",
	"Method": "ImmutableMultimap<State, Service> servicesByState(ImmutableMultimap<State, Service> servicesByState){\r\n    return state.servicesByState();\r\n}"
}, {
	"Path": "com.google.common.collect.testing.SortedSetTestSuiteBuilder.createSubsetSuite",
	"Comment": "creates a suite whose set has some elements filtered out of view.because the set may be ascending or descending, this test must derive the relative order ofthese extreme values rather than relying on their regular sort ordering.",
	"Method": "TestSuite createSubsetSuite(FeatureSpecificTestSuiteBuilder<?, ? extends OneSizeTestContainerGenerator<Collection<E>, E>> parentBuilder,Bound from,Bound to){\r\n    final TestSortedSetGenerator<E> delegate = (TestSortedSetGenerator<E>) parentBuilder.getSubjectGenerator().getInnerGenerator();\r\n    List<Feature<?>> features = new ArrayList();\r\n    features.addAll(parentBuilder.getFeatures());\r\n    features.remove(CollectionFeature.ALLOWS_NULL_VALUES);\r\n    features.add(CollectionFeature.SUBSET_VIEW);\r\n    return newBuilderUsing(delegate, to, from).named(parentBuilder.getName() + \" subSet \" + from + \"-\" + to).withFeatures(features).suppressing(parentBuilder.getSuppressedTests()).createTestSuite();\r\n}"
}, {
	"Path": "com.google.inject.servlet.ServletScopes.validateAndCanonicalizeValue",
	"Comment": "validates the key and object, ensuring the value matches the key type, and canonicalizing nullobjects to the null sentinel.",
	"Method": "Object validateAndCanonicalizeValue(Key<?> key,Object object){\r\n    if (object == null || object == NullObject.INSTANCE) {\r\n        return NullObject.INSTANCE;\r\n    }\r\n    if (!key.getTypeLiteral().getRawType().isInstance(object)) {\r\n        throw new IllegalArgumentException(\"Value[\" + object + \"] of type[\" + object.getClass().getName() + \"] is not compatible with key[\" + key + \"]\");\r\n    }\r\n    return object;\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMap.of",
	"Comment": "returns an immutable map containing the given entries, in order.",
	"Method": "ImmutableMap<K, V> of(ImmutableMap<K, V> of,K k1,V v1,ImmutableMap<K, V> of,K k1,V v1,K k2,V v2,ImmutableMap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,ImmutableMap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,ImmutableMap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,K k5,V v5){\r\n    return new RegularImmutableMap<K, V>(entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3), entryOf(k4, v4), entryOf(k5, v5));\r\n}"
}, {
	"Path": "com.google.common.base.Utf8Test.testIsWellFormed_2Bytes",
	"Comment": "tests that round tripping of all two byte permutations work.",
	"Method": "void testIsWellFormed_2Bytes(){\r\n    testBytes(2, EXPECTED_TWO_BYTE_ROUNDTRIPPABLE_COUNT);\r\n}"
}, {
	"Path": "com.google.common.collect.testing.AbstractContainerTester.resetContainer",
	"Comment": "replaces the existing container under test with a new container created by the subjectgenerator.",
	"Method": "C resetContainer(C resetContainer,C newValue){\r\n    container = newValue;\r\n    return container;\r\n}"
}, {
	"Path": "com.google.common.net.InetAddresses.getTeredoInfo",
	"Comment": "returns the teredo information embedded in a teredo address.",
	"Method": "TeredoInfo getTeredoInfo(Inet6Address ip){\r\n    checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\r\n    byte[] bytes = ip.getAddress();\r\n    Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\r\n    int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\r\n    int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\r\n    byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\r\n    for (int i = 0; i < clientBytes.length; i++) {\r\n        clientBytes[i] = (byte) ~clientBytes[i];\r\n    }\r\n    Inet4Address client = getInet4Address(clientBytes);\r\n    return new TeredoInfo(server, client, port, flags);\r\n}"
}, {
	"Path": "com.google.inject.spi.InjectionPoint.newDependency",
	"Comment": "this metohd is necessary to create a dependency with proper generic type information",
	"Method": "Dependency<T> newDependency(Key<T> key,boolean allowsNull,int parameterIndex){\r\n    return new Dependency<T>(this, key, allowsNull, parameterIndex);\r\n}"
}, {
	"Path": "com.google.common.base.JoinerBenchmark.alwaysAppendThenBackUp",
	"Comment": "always append the delimiter after the component, and in the very end shortens the buffer to getrid of the extra trailing delimiter.",
	"Method": "int alwaysAppendThenBackUp(int reps){\r\n    int dummy = 0;\r\n    for (int i = 0; i < reps; i++) {\r\n        StringBuilder sb = new StringBuilder();\r\n        for (String comp : components) {\r\n            sb.append(comp);\r\n            sb.append(DELIMITER_STRING);\r\n        }\r\n        if (sb.length() > 0) {\r\n            sb.setLength(sb.length() - DELIMITER_STRING.length());\r\n        }\r\n        dummy ^= sb.toString().length();\r\n    }\r\n    return dummy;\r\n}"
}, {
	"Path": "com.google.inject.spi.ProvisionListenerBinding.getBindingMatcher",
	"Comment": "returns the binding matcher which chooses which bindings the listener should be notified of.",
	"Method": "Matcher<? super Binding<?>> getBindingMatcher(){\r\n    return bindingMatcher;\r\n}"
}, {
	"Path": "com.zaxxer.hikari.HikariConfig.getConnectionTestQuery",
	"Comment": "get the sql query to be executed to test the validity of connections.",
	"Method": "String getConnectionTestQuery(){\r\n    return connectionTestQuery;\r\n}"
}, {
	"Path": "com.google.common.collect.UnmodifiableListIterator.add",
	"Comment": "guaranteed to throw an exception and leave the underlying data unmodified.",
	"Method": "void add(E e){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.inject.internal.Annotations.isBindingAnnotation",
	"Comment": "returns true if annotations of the specified type are binding annotations.",
	"Method": "boolean isBindingAnnotation(Class<? extends Annotation> annotationType){\r\n    return bindingAnnotationChecker.hasAnnotations(annotationType);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.getQueueLength",
	"Comment": "returns an estimate of the number of threads waiting to enter this monitor. the value is onlyan estimate because the number of threads may change dynamically while this method traversesinternal data structures. this method is designed for use in monitoring of the system state,not for synchronization control.",
	"Method": "int getQueueLength(){\r\n    return lock.getQueueLength();\r\n}"
}, {
	"Path": "com.google.common.base.internal.Finalizer.cleanUp",
	"Comment": "cleans up a single reference. catches and logs all throwables.",
	"Method": "boolean cleanUp(Reference<?> reference){\r\n    Method finalizeReferentMethod = getFinalizeReferentMethod();\r\n    if (finalizeReferentMethod == null) {\r\n        return false;\r\n    }\r\n    do {\r\n        reference.clear();\r\n        if (reference == frqReference) {\r\n            return false;\r\n        }\r\n        try {\r\n            finalizeReferentMethod.invoke(reference);\r\n        } catch (Throwable t) {\r\n            logger.log(Level.SEVERE, \"Error cleaning up after reference.\", t);\r\n        }\r\n    } while ((reference = queue.poll()) != null);\r\n    return true;\r\n}"
}, {
	"Path": "com.google.inject.internal.InternalInjectorCreator.primaryInjector",
	"Comment": "returns the injector being constructed. this is not necessarily the root injector.",
	"Method": "Injector primaryInjector(){\r\n    return shells.get(0).getInjector();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableCollection.add",
	"Comment": "guaranteed to throw an exception and leave the collection unmodified.",
	"Method": "boolean add(E e,Builder<E> add,E element,Builder<E> add,E elements){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.isFair",
	"Comment": "returns whether this monitor is using a fair ordering policy.",
	"Method": "boolean isFair(){\r\n    return fair;\r\n}"
}, {
	"Path": "com.google.common.testing.EqualsTesterTest.testAddEqualObjectWithOArgConstructor",
	"Comment": "test adding objects only by addequalitygroup, with no reference object specified in theconstructor.",
	"Method": "void testAddEqualObjectWithOArgConstructor(){\r\n    equalsTester.addEqualityGroup(equalObject1, notEqualObject1);\r\n    try {\r\n        equalsTester.testEquals();\r\n    } catch (AssertionFailedError e) {\r\n        assertErrorMessage(e, equalObject1 + \" [group 1, item 1] must be Object#equals to \" + notEqualObject1 + \" [group 1, item 2]\");\r\n        return;\r\n    }\r\n    fail(\"Should get not equal to equal object error\");\r\n}"
}, {
	"Path": "com.google.common.io.ReaderInputStream.availableCapacity",
	"Comment": "returns the number of elements between the limit and capacity.",
	"Method": "int availableCapacity(Buffer buffer){\r\n    return buffer.capacity() - buffer.limit();\r\n}"
}, {
	"Path": "com.google.common.reflect.ClassPath.getTopLevelClasses",
	"Comment": "returns all top level classes loadable from the current class path.",
	"Method": "ImmutableSet<ClassInfo> getTopLevelClasses(ImmutableSet<ClassInfo> getTopLevelClasses,String packageName){\r\n    checkNotNull(packageName);\r\n    ImmutableSet.Builder<ClassInfo> builder = ImmutableSet.builder();\r\n    for (ClassInfo classInfo : getTopLevelClasses()) {\r\n        if (classInfo.getPackageName().equals(packageName)) {\r\n            builder.add(classInfo);\r\n        }\r\n    }\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMap.put",
	"Comment": "guaranteed to throw an exception and leave the map unmodified.",
	"Method": "Builder<K, V> put(K key,V value,Builder<K, V> put,Entry<? extends K, ? extends V> entry,V put,K k,V v){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.MonitorBasedPriorityBlockingQueue.offer",
	"Comment": "inserts the specified element into this priority queue. as the queue is unbounded this methodwill never block.",
	"Method": "boolean offer(E e,boolean offer,E e,long timeout,TimeUnit unit){\r\n    checkNotNull(unit);\r\n    return offer(e);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSortedMap.of",
	"Comment": "casting to any type is safe because the set will never hold any elements.",
	"Method": "ImmutableSortedMap<K, V> of(ImmutableSortedMap<K, V> of,K k1,V v1,ImmutableSortedMap<K, V> of,Comparator<? super K> comparator,K k1,V v1,ImmutableSortedMap<K, V> of,K k1,V v1,K k2,V v2,ImmutableSortedMap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,ImmutableSortedMap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,ImmutableSortedMap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,K k5,V v5){\r\n    return new Builder<K, V>(Ordering.natural()).put(k1, v1).put(k2, v2).put(k3, v3).put(k4, v4).put(k5, v5).build();\r\n}"
}, {
	"Path": "com.google.common.collect.ComparisonChain.compare",
	"Comment": "compares two objects using a comparator, if the result of this comparison chain has notalready been determined.",
	"Method": "ComparisonChain compare(Comparable left,Comparable right,ComparisonChain compare,T left,T right,Comparator<T> comparator,ComparisonChain compare,int left,int right,ComparisonChain compare,long left,long right,ComparisonChain compare,float left,float right,ComparisonChain compare,double left,double right,ComparisonChain compare,Comparable<?> left,Comparable<?> right,ComparisonChain compare,T left,T right,Comparator<T> comparator,ComparisonChain compare,int left,int right,ComparisonChain compare,long left,long right,ComparisonChain compare,float left,float right,ComparisonChain compare,double left,double right,ComparisonChain compare,Boolean left,Boolean right){\r\n    return compareFalseFirst(left, right);\r\n}"
}, {
	"Path": "com.google.inject.internal.SpiUtils.assertSetVisitor",
	"Comment": "asserts that multibinderbinding visitors work correctly.",
	"Method": "void assertSetVisitor(Key<Set<T>> setKey,TypeLiteral<?> elementType,Iterable<? extends Module> modules,VisitType visitType,boolean allowDuplicates,int expectedMultibindings,BindResult results){\r\n    if (visitType == null) {\r\n        fail(\"must test something\");\r\n    }\r\n    if (visitType == BOTH || visitType == INJECTOR) {\r\n        setInjectorTest(setKey, elementType, modules, allowDuplicates, expectedMultibindings, results);\r\n    }\r\n    if (visitType == BOTH || visitType == MODULE) {\r\n        setModuleTest(setKey, elementType, modules, allowDuplicates, expectedMultibindings, results);\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSetMultimap.replaceValues",
	"Comment": "guaranteed to throw an exception and leave the multimap unmodified.",
	"Method": "ImmutableSet<V> replaceValues(K key,Iterable<? extends V> values){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.inject.internal.ProcessedBindingData.initializeDelayedBindings",
	"Comment": "initialized bindings that need to be delayed until after all injection points and otherbindings are processed. the main current usecase for this is resolving optional dependenciesfor optionalbinder bindings.",
	"Method": "void initializeDelayedBindings(){\r\n    for (Runnable initializer : delayedUninitializedBindings) {\r\n        initializer.run();\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ArrayTable.columnKeyList",
	"Comment": "returns, as an immutable list, the column keys provided when the table was constructed,including those that are mapped to null values only.",
	"Method": "ImmutableList<C> columnKeyList(){\r\n    return columnList;\r\n}"
}, {
	"Path": "com.google.common.collect.testing.MinimalIterable.of",
	"Comment": "returns an iterable whose iterator returns the given elements in order.",
	"Method": "MinimalIterable<E> of(E elements){\r\n    return new MinimalIterable<E>(Arrays.asList(elements).iterator());\r\n}"
}, {
	"Path": "com.google.common.collect.ForwardingSortedMap.unsafeCompare",
	"Comment": "unsafe, but worst case is a cce is thrown, which callers will be expecting",
	"Method": "int unsafeCompare(Object k1,Object k2){\r\n    Comparator<? super K> comparator = comparator();\r\n    if (comparator == null) {\r\n        return ((Comparable<Object>) k1).compareTo(k2);\r\n    } else {\r\n        return ((Comparator<Object>) comparator).compare(k1, k2);\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSortedMultiset.copyOf",
	"Comment": "returns an immutable sorted multiset containing the given elements sorted by their naturalordering.",
	"Method": "ImmutableSortedMultiset<E> copyOf(E[] elements,ImmutableSortedMultiset<E> copyOf,Iterable<? extends E> elements,ImmutableSortedMultiset<E> copyOf,Iterator<? extends E> elements,ImmutableSortedMultiset<E> copyOf,Comparator<? super E> comparator,Iterator<? extends E> elements,ImmutableSortedMultiset<E> copyOf,Comparator<? super E> comparator,Iterable<? extends E> elements){\r\n    if (elements instanceof ImmutableSortedMultiset) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        ImmutableSortedMultiset<E> multiset = (ImmutableSortedMultiset<E>) elements;\r\n        if (comparator.equals(multiset.comparator())) {\r\n            if (multiset.isPartialView()) {\r\n                return copyOfSortedEntries(comparator, multiset.entrySet().asList());\r\n            } else {\r\n                return multiset;\r\n            }\r\n        }\r\n    }\r\n    elements = Lists.newArrayList(elements);\r\n    TreeMultiset<E> sortedCopy = TreeMultiset.create(checkNotNull(comparator));\r\n    Iterables.addAll(sortedCopy, elements);\r\n    return copyOfSortedEntries(comparator, sortedCopy.entrySet());\r\n}"
}, {
	"Path": "com.google.inject.internal.ProxyFactory.getInterceptors",
	"Comment": "returns the interceptors that apply to the constructed type.",
	"Method": "ImmutableMap<Method, List<MethodInterceptor>> getInterceptors(){\r\n    return interceptors;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AtomicDoubleTest.testWeakCompareAndSet",
	"Comment": "repeated weakcompareandset succeeds in changing value when equal to expected",
	"Method": "void testWeakCompareAndSet(){\r\n    double prev = Math.E;\r\n    double unused = Math.E + Math.PI;\r\n    AtomicDouble at = new AtomicDouble(prev);\r\n    for (double x : VALUES) {\r\n        assertBitEquals(prev, at.get());\r\n        assertFalse(at.weakCompareAndSet(unused, x));\r\n        assertBitEquals(prev, at.get());\r\n        while (!at.weakCompareAndSet(prev, x)) {\r\n            ;\r\n        }\r\n        assertBitEquals(x, at.get());\r\n        prev = x;\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.internal.MapBinderTest.testBasicMapDependencyInjection",
	"Comment": "ensure there are no initialization race conditions in basic map injection.",
	"Method": "void testBasicMapDependencyInjection(){\r\n    final AtomicReference<Map<String, String>> injectedMap = new AtomicReference<Map<String, String>>();\r\n    final Object anObject = new Object() {\r\n        @Inject\r\n        void initialize(Map<String, String> map) {\r\n            injectedMap.set(map);\r\n        }\r\n    };\r\n    Module abc = new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            requestInjection(anObject);\r\n            MapBinder<String, String> multibinder = MapBinder.newMapBinder(binder(), String.class, String.class);\r\n            multibinder.addBinding(\"a\").toInstance(\"A\");\r\n            multibinder.addBinding(\"b\").toInstance(\"B\");\r\n            multibinder.addBinding(\"c\").toInstance(\"C\");\r\n        }\r\n    };\r\n    Guice.createInjector(abc);\r\n    assertEquals(mapOf(\"a\", \"A\", \"b\", \"B\", \"c\", \"C\"), injectedMap.get());\r\n}"
}, {
	"Path": "com.google.inject.internal.MapBinderTest.testBasicMapDependencyInjection",
	"Comment": "ensure there are no initialization race conditions in basic map injection.",
	"Method": "void testBasicMapDependencyInjection(){\r\n    injectedMap.set(map);\r\n}"
}, {
	"Path": "com.google.inject.internal.MapBinderTest.testBasicMapDependencyInjection",
	"Comment": "ensure there are no initialization race conditions in basic map injection.",
	"Method": "void testBasicMapDependencyInjection(){\r\n    requestInjection(anObject);\r\n    MapBinder<String, String> multibinder = MapBinder.newMapBinder(binder(), String.class, String.class);\r\n    multibinder.addBinding(\"a\").toInstance(\"A\");\r\n    multibinder.addBinding(\"b\").toInstance(\"B\");\r\n    multibinder.addBinding(\"c\").toInstance(\"C\");\r\n}"
}, {
	"Path": "com.google.common.hash.Crc32cHashFunctionTest.assertCrc",
	"Comment": "verifies that the crc of an array of byte data matches the expected value.",
	"Method": "void assertCrc(int expectedCrc,byte[] data){\r\n    int actualCrc = Hashing.crc32c().hashBytes(data).asInt();\r\n    assertEquals(expectedCrc, actualCrc);\r\n}"
}, {
	"Path": "com.google.common.cache.PopulatedCachesTest.caches",
	"Comment": "most of the tests in this class run against every one of these caches.",
	"Method": "Iterable<LoadingCache<Object, Object>> caches(){\r\n    CacheBuilderFactory factory = cacheFactory();\r\n    return Iterables.transform(factory.buildAllPermutations(), new Function<CacheBuilder<Object, Object>, LoadingCache<Object, Object>>() {\r\n        @Override\r\n        public LoadingCache<Object, Object> apply(CacheBuilder<Object, Object> builder) {\r\n            return builder.recordStats().build(identityLoader());\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.common.cache.PopulatedCachesTest.caches",
	"Comment": "most of the tests in this class run against every one of these caches.",
	"Method": "Iterable<LoadingCache<Object, Object>> caches(){\r\n    return builder.recordStats().build(identityLoader());\r\n}"
}, {
	"Path": "com.google.common.collect.testing.NavigableMapTestSuiteBuilder.createDescendingSuite",
	"Comment": "create a suite whose maps are descending views of other maps.",
	"Method": "TestSuite createDescendingSuite(FeatureSpecificTestSuiteBuilder<?, ? extends OneSizeTestContainerGenerator<Map<K, V>, Entry<K, V>>> parentBuilder){\r\n    final TestSortedMapGenerator<K, V> delegate = (TestSortedMapGenerator<K, V>) parentBuilder.getSubjectGenerator().getInnerGenerator();\r\n    List<Feature<?>> features = new ArrayList();\r\n    features.add(NoRecurse.DESCENDING);\r\n    features.addAll(parentBuilder.getFeatures());\r\n    return subSuiteUsing(new DescendingTestMapGenerator<K, V>(delegate)).named(parentBuilder.getName() + \" descending\").withFeatures(features).suppressing(parentBuilder.getSuppressedTests()).createTestSuite();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMap.putIfAbsent",
	"Comment": "guaranteed to throw an exception and leave the map unmodified.",
	"Method": "V putIfAbsent(K key,V value){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.inject.CircularDependencyTest.testCircularlyDependentMultipleWays",
	"Comment": "as reported by issue 349, we give a lousy trace when a class is circularly dependent on itselfin multiple ways.",
	"Method": "void testCircularlyDependentMultipleWays(){\r\n    Injector injector = Guice.createInjector(new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            binder.bind(A.class).to(E.class);\r\n            binder.bind(B.class).to(E.class);\r\n        }\r\n    });\r\n    injector.getInstance(A.class);\r\n}"
}, {
	"Path": "com.google.inject.CircularDependencyTest.testCircularlyDependentMultipleWays",
	"Comment": "as reported by issue 349, we give a lousy trace when a class is circularly dependent on itselfin multiple ways.",
	"Method": "void testCircularlyDependentMultipleWays(){\r\n    binder.bind(A.class).to(E.class);\r\n    binder.bind(B.class).to(E.class);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AtomicDoubleArrayTest.testAddAndGet",
	"Comment": "addandget adds given value to current, and returns current value",
	"Method": "void testAddAndGet(){\r\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\r\n    for (int i : new int[] { 0, SIZE - 1 }) {\r\n        for (double x : VALUES) {\r\n            for (double y : VALUES) {\r\n                aa.set(i, x);\r\n                double z = aa.addAndGet(i, y);\r\n                assertBitEquals(x + y, z);\r\n                assertBitEquals(x + y, aa.get(i));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.GeneralRange.downTo",
	"Comment": "returns everything above the endpoint relative to the specified comparator, with the specifiedendpoint behavior.",
	"Method": "GeneralRange<T> downTo(Comparator<? super T> comparator,T endpoint,BoundType boundType){\r\n    return new GeneralRange<T>(comparator, true, endpoint, boundType, false, null, OPEN);\r\n}"
}, {
	"Path": "com.google.common.math.LongMathTest.testLog10MatchesBigInteger",
	"Comment": "relies on the correctness of bigintegermath.log10 for all modes except unnecessary.",
	"Method": "void testLog10MatchesBigInteger(){\r\n    for (long x : POSITIVE_LONG_CANDIDATES) {\r\n        for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\r\n            assertEquals(BigIntegerMath.log10(valueOf(x), mode), LongMath.log10(x, mode));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultimap.keySet",
	"Comment": "returns an immutable set of the distinct keys in this multimap, in the same order as theyappear in this multimap.",
	"Method": "ImmutableSet<K> keySet(){\r\n    return map.keySet();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.GeneratedMonitorTest.isInterruptible",
	"Comment": "determines whether the given method can throw interruptedexception.",
	"Method": "boolean isInterruptible(Method method){\r\n    return Arrays.asList(method.getExceptionTypes()).contains(InterruptedException.class);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AbstractFuture.userObjectToString",
	"Comment": "helper for printing user supplied objects into our tostring method.",
	"Method": "String userObjectToString(Object o){\r\n    if (o == this) {\r\n        return \"this future\";\r\n    }\r\n    return String.valueOf(o);\r\n}"
}, {
	"Path": "com.google.inject.internal.Initializer.requestInjection",
	"Comment": "registers an instance for member injection when that step is performed.",
	"Method": "Initializable<T> requestInjection(InjectorImpl injector,T instance,Binding<T> binding,Object source,Set<InjectionPoint> injectionPoints){\r\n    checkNotNull(source);\r\n    Preconditions.checkState(!validationStarted, \"Member injection could not be requested after validation is started\");\r\n    ProvisionListenerStackCallback<T> provisionCallback = binding == null ? null : injector.provisionListenerStore.get(binding);\r\n    if (instance == null || (injectionPoints.isEmpty() && !injector.membersInjectorStore.hasTypeListeners() && provisionCallback == null)) {\r\n        return Initializables.of(instance);\r\n    }\r\n    if (initializablesCache.containsKey(instance)) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Initializable<T> cached = (Initializable<T>) initializablesCache.get(instance);\r\n        return cached;\r\n    }\r\n    InjectableReference<T> injectableReference = new InjectableReference<T>(injector, instance, binding == null ? null : binding.getKey(), provisionCallback, source, cycleDetectingLockFactory.create(instance.getClass()));\r\n    initializablesCache.put(instance, injectableReference);\r\n    pendingInjections.add(injectableReference);\r\n    return injectableReference;\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMap.replace",
	"Comment": "guaranteed to throw an exception and leave the map unmodified.",
	"Method": "boolean replace(K key,V oldValue,V newValue,V replace,K key,V value){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultimap.putAll",
	"Comment": "guaranteed to throw an exception and leave the multimap unmodified.",
	"Method": "Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries,Builder<K, V> putAll,K key,Iterable<? extends V> values,Builder<K, V> putAll,K key,V values,Builder<K, V> putAll,Multimap<? extends K, ? extends V> multimap,boolean putAll,K key,Iterable<? extends V> values,boolean putAll,Multimap<? extends K, ? extends V> multimap){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.inject.Asserts.asModuleChain",
	"Comment": "returns the string that would appear in an error message for this chain of classes as modules.",
	"Method": "String asModuleChain(Class classes){\r\n    return Joiner.on(\" -> \").appendTo(new StringBuilder(\" (via modules: \"), Iterables.transform(ImmutableList.copyOf(classes), new Function<Class, String>() {\r\n        @Override\r\n        public String apply(Class input) {\r\n            return input.getName();\r\n        }\r\n    })).append(\")\").toString();\r\n}"
}, {
	"Path": "com.google.inject.Asserts.asModuleChain",
	"Comment": "returns the string that would appear in an error message for this chain of classes as modules.",
	"Method": "String asModuleChain(Class classes){\r\n    return input.getName();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.GeneratedMonitorTest.isTimed",
	"Comment": "determines whether the given method takes a time and unit as its last two parameters.",
	"Method": "boolean isTimed(Method method){\r\n    Class<?>[] parameterTypes = method.getParameterTypes();\r\n    return parameterTypes.length >= 2 && parameterTypes[parameterTypes.length - 2] == long.class && parameterTypes[parameterTypes.length - 1] == TimeUnit.class;\r\n}"
}, {
	"Path": "com.google.common.hash.Hashing.combineUnordered",
	"Comment": "returns a hash code, having the same bit length as each of the input hash codes, that combinesthe information of these hash codes in an unordered fashion. that is, whenever two equal hashcodes are produced by two calls to this method, it is as likely as possible that eachwas computed from the same input hash codes in some order.",
	"Method": "HashCode combineUnordered(Iterable<HashCode> hashCodes){\r\n    Iterator<HashCode> iterator = hashCodes.iterator();\r\n    checkArgument(iterator.hasNext(), \"Must be at least 1 hash code to combine.\");\r\n    byte[] resultBytes = new byte[iterator.next().bits() / 8];\r\n    for (HashCode hashCode : hashCodes) {\r\n        byte[] nextBytes = hashCode.asBytes();\r\n        checkArgument(nextBytes.length == resultBytes.length, \"All hashcodes must have the same bit length.\");\r\n        for (int i = 0; i < nextBytes.length; i++) {\r\n            resultBytes[i] += nextBytes[i];\r\n        }\r\n    }\r\n    return HashCode.fromBytesNoCopy(resultBytes);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AtomicDouble.getAndSet",
	"Comment": "atomically sets to the given value and returns the old value.",
	"Method": "double getAndSet(double newValue){\r\n    long next = doubleToRawLongBits(newValue);\r\n    return longBitsToDouble(updater.getAndSet(this, next));\r\n}"
}, {
	"Path": "com.google.inject.persist.jpa.JoiningLocalTransactionsTest.tearDown",
	"Comment": "cleanup entitymanager in case some of the rollback tests left it in an open state",
	"Method": "void tearDown(){\r\n    injector.getInstance(UnitOfWork.class).end();\r\n    injector.getInstance(EntityManagerFactory.class).close();\r\n}"
}, {
	"Path": "com.google.common.base.internal.Finalizer.startFinalizer",
	"Comment": "starts the finalizer thread. finalizablereferencequeue calls this method reflectively.",
	"Method": "void startFinalizer(Class<?> finalizableReferenceClass,ReferenceQueue<Object> queue,PhantomReference<Object> frqReference){\r\n    if (!finalizableReferenceClass.getName().equals(FINALIZABLE_REFERENCE)) {\r\n        throw new IllegalArgumentException(\"Expected \" + FINALIZABLE_REFERENCE + \".\");\r\n    }\r\n    Finalizer finalizer = new Finalizer(finalizableReferenceClass, queue, frqReference);\r\n    String threadName = Finalizer.class.getName();\r\n    Thread thread = null;\r\n    if (bigThreadConstructor != null) {\r\n        try {\r\n            boolean inheritThreadLocals = false;\r\n            long defaultStackSize = 0;\r\n            thread = bigThreadConstructor.newInstance((ThreadGroup) null, finalizer, threadName, defaultStackSize, inheritThreadLocals);\r\n        } catch (Throwable t) {\r\n            logger.log(Level.INFO, \"Failed to create a thread without inherited thread-local values\", t);\r\n        }\r\n    }\r\n    if (thread == null) {\r\n        thread = new Thread((ThreadGroup) null, finalizer, threadName);\r\n    }\r\n    thread.setDaemon(true);\r\n    try {\r\n        if (inheritableThreadLocals != null) {\r\n            inheritableThreadLocals.set(thread, null);\r\n        }\r\n    } catch (Throwable t) {\r\n        logger.log(Level.INFO, \"Failed to clear thread local values inherited by reference finalizer thread.\", t);\r\n    }\r\n    thread.start();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMap.clear",
	"Comment": "guaranteed to throw an exception and leave the map unmodified.",
	"Method": "void clear(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableList.set",
	"Comment": "guaranteed to throw an exception and leave the list unmodified.",
	"Method": "E set(int index,E element){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.RateLimiter.reserveAndGetWaitLength",
	"Comment": "reserves next ticket and returns the wait time that the caller must wait for.",
	"Method": "long reserveAndGetWaitLength(int permits,long nowMicros){\r\n    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);\r\n    return max(momentAvailable - nowMicros, 0);\r\n}"
}, {
	"Path": "com.google.common.io.ReaderInputStream.readMoreChars",
	"Comment": "handle the case of underflow caused by needing more input characters.",
	"Method": "void readMoreChars(){\r\n    if (availableCapacity(charBuffer) == 0) {\r\n        if (charBuffer.position() > 0) {\r\n            charBuffer.compact().flip();\r\n        } else {\r\n            charBuffer = grow(charBuffer);\r\n        }\r\n    }\r\n    int limit = charBuffer.limit();\r\n    int numChars = reader.read(charBuffer.array(), limit, availableCapacity(charBuffer));\r\n    if (numChars == -1) {\r\n        endOfInput = true;\r\n    } else {\r\n        charBuffer.limit(limit + numChars);\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.internal.BytecodeGen.canonicalize",
	"Comment": "attempts to canonicalize null references to the system class loader. may return null if forsome reason the system loader is unavailable.",
	"Method": "ClassLoader canonicalize(ClassLoader classLoader){\r\n    return classLoader != null ? classLoader : SystemBridgeHolder.SYSTEM_BRIDGE.getParent();\r\n}"
}, {
	"Path": "com.zaxxer.hikari.pool.PoolBase.setNetworkTimeout",
	"Comment": "set the network timeout, if isusenetworktimeout is true and the driver supports it.",
	"Method": "void setNetworkTimeout(Connection connection,long timeoutMs){\r\n    if (isNetworkTimeoutSupported == TRUE) {\r\n        connection.setNetworkTimeout(netTimeoutExecutor, (int) timeoutMs);\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.Key.ofType",
	"Comment": "returns a new key of the specified type with the same annotation as this key.",
	"Method": "Key<T> ofType(Class<T> type,Key<?> ofType,Type type,Key<T> ofType,TypeLiteral<T> type){\r\n    return new Key<T>(type, annotationStrategy);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.FuturesTest.testAllAsList_logging_same_cause",
	"Comment": "different exceptions happening on multiple futures with the same cause should not be logged.",
	"Method": "void testAllAsList_logging_same_cause(){\r\n    try {\r\n        MyException exception1 = new MyException();\r\n        MyException exception2 = new MyException();\r\n        MyException exception3 = new MyException();\r\n        MyException sameInstance = new MyException();\r\n        exception1.initCause(sameInstance);\r\n        exception2.initCause(sameInstance);\r\n        exception3.initCause(exception2);\r\n        getDone(allAsList(immediateFailedFuture(exception1), immediateFailedFuture(exception3)));\r\n        fail();\r\n    } catch (ExecutionException expected) {\r\n        assertThat(expected.getCause()).isInstanceOf(MyException.class);\r\n        assertEquals(\"Nothing should be logged\", 0, aggregateFutureLogHandler.getStoredLogRecords().size());\r\n    }\r\n}"
}, {
	"Path": "com.google.common.math.Stats.of",
	"Comment": "returns statistics over a dataset containing the given values.",
	"Method": "Stats of(Iterable<? extends Number> values,Stats of,Iterator<? extends Number> values,Stats of,double values,Stats of,int values,Stats of,long values){\r\n    StatsAccumulator acummulator = new StatsAccumulator();\r\n    acummulator.addAll(values);\r\n    return acummulator.snapshot();\r\n}"
}, {
	"Path": "com.google.common.collect.testing.google.SetGenerators.nullCheckedTreeSet",
	"Comment": "setcreationtester has some tests that pass in duplicates. dedup them.",
	"Method": "SortedSet<E> nullCheckedTreeSet(E[] elements){\r\n    SortedSet<E> set = newTreeSet();\r\n    for (E element : elements) {\r\n        set.add(checkNotNull(element));\r\n    }\r\n    return set;\r\n}"
}, {
	"Path": "com.google.common.hash.HashCodeTest.testFromLong",
	"Comment": "expectedhashcodes must contain at least one hash code with 8 bytes",
	"Method": "void testFromLong(){\r\n    for (ExpectedHashCode expected : expectedHashCodes) {\r\n        if (expected.bytes.length == 8) {\r\n            HashCode fromLong = HashCode.fromLong(expected.asLong);\r\n            assertExpectedHashCode(expected, fromLong);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.base.Stopwatch.toString",
	"Comment": "returns a string representation of the current elapsed time.",
	"Method": "String toString(){\r\n    long nanos = elapsedNanos();\r\n    TimeUnit unit = chooseUnit(nanos);\r\n    double value = (double) nanos / NANOSECONDS.convert(1, unit);\r\n    return Platform.formatCompact4Digits(value) + \" \" + abbreviate(unit);\r\n}"
}, {
	"Path": "com.google.common.cache.Striped64.getUnsafe",
	"Comment": "returns a sun.misc.unsafe. suitable for use in a 3rd party package. replace with a simple callto unsafe.getunsafe when integrating into a jdk.",
	"Method": "sun.misc.Unsafe getUnsafe(){\r\n    try {\r\n        return sun.misc.Unsafe.getUnsafe();\r\n    } catch (SecurityException tryReflectionInstead) {\r\n    }\r\n    try {\r\n        return java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\r\n            public sun.misc.Unsafe run() throws Exception {\r\n                Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\r\n                for (java.lang.reflect.Field f : k.getDeclaredFields()) {\r\n                    f.setAccessible(true);\r\n                    Object x = f.get(null);\r\n                    if (k.isInstance(x))\r\n                        return k.cast(x);\r\n                }\r\n                throw new NoSuchFieldError(\"the Unsafe\");\r\n            }\r\n        });\r\n    } catch (java.security.PrivilegedActionException e) {\r\n        throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\r\n    }\r\n}"
}, {
	"Path": "com.google.common.cache.Striped64.getUnsafe",
	"Comment": "returns a sun.misc.unsafe. suitable for use in a 3rd party package. replace with a simple callto unsafe.getunsafe when integrating into a jdk.",
	"Method": "sun.misc.Unsafe getUnsafe(){\r\n    Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\r\n    for (java.lang.reflect.Field f : k.getDeclaredFields()) {\r\n        f.setAccessible(true);\r\n        Object x = f.get(null);\r\n        if (k.isInstance(x))\r\n            return k.cast(x);\r\n    }\r\n    throw new NoSuchFieldError(\"the Unsafe\");\r\n}"
}, {
	"Path": "com.google.common.collect.FluentIterable.concatNoDefensiveCopy",
	"Comment": "concatenates a varargs array of iterables without making a defensive copy of the array.",
	"Method": "FluentIterable<T> concatNoDefensiveCopy(Iterable<? extends T> inputs){\r\n    for (Iterable<? extends T> input : inputs) {\r\n        checkNotNull(input);\r\n    }\r\n    return new FluentIterable<T>() {\r\n        @Override\r\n        public Iterator<T> iterator() {\r\n            return Iterators.concat(new AbstractIndexedListIterator<Iterator<? extends T>>(inputs.length) {\r\n                @Override\r\n                public Iterator<? extends T> get(int i) {\r\n                    return inputs[i].iterator();\r\n                }\r\n            });\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.google.common.collect.FluentIterable.concatNoDefensiveCopy",
	"Comment": "concatenates a varargs array of iterables without making a defensive copy of the array.",
	"Method": "FluentIterable<T> concatNoDefensiveCopy(Iterable<? extends T> inputs){\r\n    return Iterators.concat(new AbstractIndexedListIterator<Iterator<? extends T>>(inputs.length) {\r\n        @Override\r\n        public Iterator<? extends T> get(int i) {\r\n            return inputs[i].iterator();\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.common.collect.FluentIterable.concatNoDefensiveCopy",
	"Comment": "concatenates a varargs array of iterables without making a defensive copy of the array.",
	"Method": "FluentIterable<T> concatNoDefensiveCopy(Iterable<? extends T> inputs){\r\n    return inputs[i].iterator();\r\n}"
}, {
	"Path": "com.google.common.io.CloserTest.assertSuppressed",
	"Comment": "asserts that an exception was thrown when trying to close each of the given throwables and thateach such exception was suppressed because of the given thrown exception.",
	"Method": "void assertSuppressed(Suppression expected){\r\n    assertEquals(ImmutableList.copyOf(expected), suppressor.suppressions);\r\n}"
}, {
	"Path": "com.google.inject.internal.ProviderMethodsModule.forModule",
	"Comment": "returns a module which creates bindings methods in the module that match the scanner.",
	"Method": "Module forModule(Module module,Module forModule,Object module,ModuleAnnotatedMethodScanner scanner){\r\n    return forObject(module, false, scanner);\r\n}"
}, {
	"Path": "com.google.inject.internal.MultibinderTest.testKeyHashCodesFixedAtInjectionTime",
	"Comment": "ensure key hash codes are fixed at injection time, not binding time.",
	"Method": "void testKeyHashCodesFixedAtInjectionTime(){\r\n    Module ab = new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            Multibinder<List<String>> multibinder = Multibinder.newSetBinder(binder(), listOfStrings);\r\n            List<String> list = Lists.newArrayList();\r\n            multibinder.addBinding().toInstance(list);\r\n            list.add(\"A\");\r\n            list.add(\"B\");\r\n        }\r\n    };\r\n    Injector injector = Guice.createInjector(ab);\r\n    for (Entry<Key<?>, Binding<?>> entry : injector.getAllBindings().entrySet()) {\r\n        Key<?> bindingKey = entry.getKey();\r\n        Key<?> clonedKey;\r\n        if (bindingKey.getAnnotation() != null) {\r\n            clonedKey = Key.get(bindingKey.getTypeLiteral(), bindingKey.getAnnotation());\r\n        } else if (bindingKey.getAnnotationType() != null) {\r\n            clonedKey = Key.get(bindingKey.getTypeLiteral(), bindingKey.getAnnotationType());\r\n        } else {\r\n            clonedKey = Key.get(bindingKey.getTypeLiteral());\r\n        }\r\n        assertEquals(bindingKey, clonedKey);\r\n        assertEquals(\"Incorrect hashcode for \" + bindingKey + \" -> \" + entry.getValue(), bindingKey.hashCode(), clonedKey.hashCode());\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.internal.MultibinderTest.testKeyHashCodesFixedAtInjectionTime",
	"Comment": "ensure key hash codes are fixed at injection time, not binding time.",
	"Method": "void testKeyHashCodesFixedAtInjectionTime(){\r\n    Multibinder<List<String>> multibinder = Multibinder.newSetBinder(binder(), listOfStrings);\r\n    List<String> list = Lists.newArrayList();\r\n    multibinder.addBinding().toInstance(list);\r\n    list.add(\"A\");\r\n    list.add(\"B\");\r\n}"
}, {
	"Path": "com.google.common.collect.testing.NavigableSetTestSuiteBuilder.createDescendingSuite",
	"Comment": "create a suite whose maps are descending views of other maps.",
	"Method": "TestSuite createDescendingSuite(FeatureSpecificTestSuiteBuilder<?, ? extends OneSizeTestContainerGenerator<Collection<E>, E>> parentBuilder){\r\n    final TestSetGenerator<E> delegate = (TestSetGenerator<E>) parentBuilder.getSubjectGenerator().getInnerGenerator();\r\n    List<Feature<?>> features = new ArrayList();\r\n    features.add(DESCENDING_VIEW);\r\n    features.addAll(parentBuilder.getFeatures());\r\n    return NavigableSetTestSuiteBuilder.using(new TestSetGenerator<E>() {\r\n        @Override\r\n        public SampleElements<E> samples() {\r\n            return delegate.samples();\r\n        }\r\n        @Override\r\n        public E[] createArray(int length) {\r\n            return delegate.createArray(length);\r\n        }\r\n        @Override\r\n        public Iterable<E> order(List<E> insertionOrder) {\r\n            List<E> list = new ArrayList<E>();\r\n            for (E e : delegate.order(insertionOrder)) {\r\n                list.add(e);\r\n            }\r\n            Collections.reverse(list);\r\n            return list;\r\n        }\r\n        @Override\r\n        public Set<E> create(Object... elements) {\r\n            NavigableSet<E> navigableSet = (NavigableSet<E>) delegate.create(elements);\r\n            return navigableSet.descendingSet();\r\n        }\r\n    }).named(parentBuilder.getName() + \" descending\").withFeatures(features).suppressing(parentBuilder.getSuppressedTests()).createTestSuite();\r\n}"
}, {
	"Path": "com.google.common.collect.testing.NavigableSetTestSuiteBuilder.createDescendingSuite",
	"Comment": "create a suite whose maps are descending views of other maps.",
	"Method": "TestSuite createDescendingSuite(FeatureSpecificTestSuiteBuilder<?, ? extends OneSizeTestContainerGenerator<Collection<E>, E>> parentBuilder){\r\n    return delegate.samples();\r\n}"
}, {
	"Path": "com.google.common.collect.testing.NavigableSetTestSuiteBuilder.createDescendingSuite",
	"Comment": "create a suite whose maps are descending views of other maps.",
	"Method": "TestSuite createDescendingSuite(FeatureSpecificTestSuiteBuilder<?, ? extends OneSizeTestContainerGenerator<Collection<E>, E>> parentBuilder){\r\n    return delegate.createArray(length);\r\n}"
}, {
	"Path": "com.google.common.collect.testing.NavigableSetTestSuiteBuilder.createDescendingSuite",
	"Comment": "create a suite whose maps are descending views of other maps.",
	"Method": "TestSuite createDescendingSuite(FeatureSpecificTestSuiteBuilder<?, ? extends OneSizeTestContainerGenerator<Collection<E>, E>> parentBuilder){\r\n    List<E> list = new ArrayList<E>();\r\n    for (E e : delegate.order(insertionOrder)) {\r\n        list.add(e);\r\n    }\r\n    Collections.reverse(list);\r\n    return list;\r\n}"
}, {
	"Path": "com.google.common.collect.testing.NavigableSetTestSuiteBuilder.createDescendingSuite",
	"Comment": "create a suite whose maps are descending views of other maps.",
	"Method": "TestSuite createDescendingSuite(FeatureSpecificTestSuiteBuilder<?, ? extends OneSizeTestContainerGenerator<Collection<E>, E>> parentBuilder){\r\n    NavigableSet<E> navigableSet = (NavigableSet<E>) delegate.create(elements);\r\n    return navigableSet.descendingSet();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.ServiceManager.startupTimes",
	"Comment": "returns the service load times. this value will only return startup times for services thathave finished starting.",
	"Method": "ImmutableMap<Service, Long> startupTimes(ImmutableMap<Service, Long> startupTimes){\r\n    return state.startupTimes();\r\n}"
}, {
	"Path": "com.google.common.collect.testing.PerCollectionSizeTestSuiteBuilder.createTestSuite",
	"Comment": "creates a runnable junit test suite based on the criteria already given.",
	"Method": "TestSuite createTestSuite(){\r\n    checkCanCreate();\r\n    String name = getName();\r\n    Set<Feature<?>> features = Helpers.copyToSet(getFeatures());\r\n    List<Class<? extends AbstractTester>> testers = getTesters();\r\n    logger.fine(\" Testing: \" + name);\r\n    Set<Feature<?>> sizesToTest = Helpers.<Feature<?>>copyToSet(CollectionSize.values());\r\n    sizesToTest.retainAll(features);\r\n    features.removeAll(sizesToTest);\r\n    FeatureUtil.addImpliedFeatures(sizesToTest);\r\n    sizesToTest.retainAll(Arrays.asList(CollectionSize.ZERO, CollectionSize.ONE, CollectionSize.SEVERAL));\r\n    logger.fine(\"   Sizes: \" + formatFeatureSet(sizesToTest));\r\n    if (sizesToTest.isEmpty()) {\r\n        throw new IllegalStateException(name + \": no CollectionSizes specified (check the argument to \" + \"FeatureSpecificTestSuiteBuilder.withFeatures().)\");\r\n    }\r\n    TestSuite suite = new TestSuite(name);\r\n    for (Feature<?> collectionSize : sizesToTest) {\r\n        String oneSizeName = Platform.format(\"%s [collection size: %s]\", name, collectionSize.toString().toLowerCase());\r\n        OneSizeGenerator<T, E> oneSizeGenerator = new OneSizeGenerator(getSubjectGenerator(), (CollectionSize) collectionSize);\r\n        Set<Feature<?>> oneSizeFeatures = Helpers.copyToSet(features);\r\n        oneSizeFeatures.add(collectionSize);\r\n        Set<Method> oneSizeSuppressedTests = getSuppressedTests();\r\n        OneSizeTestSuiteBuilder<T, E> oneSizeBuilder = new OneSizeTestSuiteBuilder<T, E>(testers).named(oneSizeName).usingGenerator(oneSizeGenerator).withFeatures(oneSizeFeatures).withSetUp(getSetUp()).withTearDown(getTearDown()).suppressing(oneSizeSuppressedTests);\r\n        TestSuite oneSizeSuite = oneSizeBuilder.createTestSuite();\r\n        suite.addTest(oneSizeSuite);\r\n        for (TestSuite derivedSuite : createDerivedSuites(oneSizeBuilder)) {\r\n            oneSizeSuite.addTest(derivedSuite);\r\n        }\r\n    }\r\n    return suite;\r\n}"
}, {
	"Path": "org.apache.dubbo.common.threadlocal.InternalThread.setThreadLocalMap",
	"Comment": "sets the internal data structure that keeps the threadlocal variables bound to this thread.note that this method is for internal use only, and thus is subject to change at any time.",
	"Method": "void setThreadLocalMap(InternalThreadLocalMap threadLocalMap){\r\n    this.threadLocalMap = threadLocalMap;\r\n}"
}, {
	"Path": "com.google.thirdparty.publicsuffix.TrieParser.doParseTrieToBuilder",
	"Comment": "parses a trie node and returns the number of characters consumed.",
	"Method": "int doParseTrieToBuilder(List<CharSequence> stack,CharSequence encoded,int start,ImmutableMap.Builder<String, PublicSuffixType> builder){\r\n    int encodedLen = encoded.length();\r\n    int idx = start;\r\n    char c = '\\0';\r\n    for (; idx < encodedLen; idx++) {\r\n        c = encoded.charAt(idx);\r\n        if (c == '&' || c == '?' || c == '!' || c == ':' || c == ',') {\r\n            break;\r\n        }\r\n    }\r\n    stack.add(0, reverse(encoded.subSequence(start, idx)));\r\n    if (c == '!' || c == '?' || c == ':' || c == ',') {\r\n        String domain = PREFIX_JOINER.join(stack);\r\n        if (domain.length() > 0) {\r\n            builder.put(domain, PublicSuffixType.fromCode(c));\r\n        }\r\n    }\r\n    idx++;\r\n    if (c != '?' && c != ',') {\r\n        while (idx < encodedLen) {\r\n            idx += doParseTrieToBuilder(stack, encoded, idx, builder);\r\n            if (encoded.charAt(idx) == '?' || encoded.charAt(idx) == ',') {\r\n                idx++;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    stack.remove(0);\r\n    return idx - start;\r\n}"
}, {
	"Path": "com.google.common.math.BigIntegerMathBenchmark.oldSlowFactorial",
	"Comment": "previous version of bigintegermath.factorial, kept for timing purposes.",
	"Method": "BigInteger oldSlowFactorial(int n,BigInteger oldSlowFactorial,int n1,int n2){\r\n    assert n1 <= n2;\r\n    if (IntMath.log2(n2, CEILING) * (n2 - n1) < Long.SIZE - 1) {\r\n        long result = 1;\r\n        for (int i = n1 + 1; i <= n2; i++) {\r\n            result *= i;\r\n        }\r\n        return BigInteger.valueOf(result);\r\n    }\r\n    int mid = (n1 + n2) >>> 1;\r\n    return oldSlowFactorial(n1, mid).multiply(oldSlowFactorial(mid, n2));\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.testing.AbstractListenableFutureTest.testCanceledFutureThrowsCancellation",
	"Comment": "tests that a canceled future throws a cancellation exception.this method checks the cancel, iscancelled, and isdone methods.",
	"Method": "void testCanceledFutureThrowsCancellation(){\r\n    assertFalse(future.isDone());\r\n    assertFalse(future.isCancelled());\r\n    final CountDownLatch successLatch = new CountDownLatch(1);\r\n    new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                future.get();\r\n            } catch (CancellationException expected) {\r\n                successLatch.countDown();\r\n            } catch (Exception ignored) {\r\n            }\r\n        }\r\n    }).start();\r\n    assertFalse(future.isDone());\r\n    assertFalse(future.isCancelled());\r\n    future.cancel(true);\r\n    assertTrue(future.isDone());\r\n    assertTrue(future.isCancelled());\r\n    assertTrue(successLatch.await(200, TimeUnit.MILLISECONDS));\r\n    latch.countDown();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.testing.AbstractListenableFutureTest.testCanceledFutureThrowsCancellation",
	"Comment": "tests that a canceled future throws a cancellation exception.this method checks the cancel, iscancelled, and isdone methods.",
	"Method": "void testCanceledFutureThrowsCancellation(){\r\n    try {\r\n        future.get();\r\n    } catch (CancellationException expected) {\r\n        successLatch.countDown();\r\n    } catch (Exception ignored) {\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.endWaitingFor",
	"Comment": "records that the current thread is no longer waiting on the specified guard.",
	"Method": "void endWaitingFor(Guard guard){\r\n    int waiters = --guard.waiterCount;\r\n    if (waiters == 0) {\r\n        for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next) {\r\n            if (p == guard) {\r\n                if (pred == null) {\r\n                    activeGuards = p.next;\r\n                } else {\r\n                    pred.next = p.next;\r\n                }\r\n                p.next = null;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.matcher.Matchers.inPackage",
	"Comment": "returns a matcher which matches classes in the given package. packages are specific to theirclassloader, so classes with the same package name may not have the same package at runtime.",
	"Method": "Matcher<Class> inPackage(Package targetPackage){\r\n    return new InPackage(targetPackage);\r\n}"
}, {
	"Path": "com.google.common.primitives.ImmutableDoubleArray.hashCode",
	"Comment": "returns an unspecified hash code for the contents of this immutable array.",
	"Method": "int hashCode(int hashCode){\r\n    int hash = 1;\r\n    for (int i = start; i < end; i++) {\r\n        hash *= 31;\r\n        hash += Doubles.hashCode(array[i]);\r\n    }\r\n    return hash;\r\n}"
}, {
	"Path": "com.google.common.base.FinalizableReferenceQueue.loadFinalizer",
	"Comment": "iterates through the given loaders until it finds one that can load finalizer.",
	"Method": "Class<?> loadFinalizer(FinalizerLoader loaders,Class<?> loadFinalizer,Class<?> loadFinalizer,Class<?> loadFinalizer,Class<?> loadFinalizer){\r\n    for (FinalizerLoader loader : loaders) {\r\n        Class<?> finalizer = loader.loadFinalizer();\r\n        if (finalizer != null) {\r\n            return finalizer;\r\n        }\r\n    }\r\n    throw new AssertionError();\r\n}"
}, {
	"Path": "com.google.common.hash.HashingInputStream.read",
	"Comment": "reads the specified bytes of data from the underlying input stream and updates the hasher withthe bytes read.",
	"Method": "int read(int read,byte[] bytes,int off,int len){\r\n    int numOfBytesRead = in.read(bytes, off, len);\r\n    if (numOfBytesRead != -1) {\r\n        hasher.putBytes(bytes, off, numOfBytesRead);\r\n    }\r\n    return numOfBytesRead;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.enterWhenUninterruptibly",
	"Comment": "enters this monitor when the guard is satisfied. blocks at most the given time, including boththe time to acquire the lock and the time to wait for the guard to be satisfied.",
	"Method": "void enterWhenUninterruptibly(Guard guard,boolean enterWhenUninterruptibly,Guard guard,long time,TimeUnit unit){\r\n    final long timeoutNanos = toSafeNanos(time, unit);\r\n    if (guard.monitor != this) {\r\n        throw new IllegalMonitorStateException();\r\n    }\r\n    final ReentrantLock lock = this.lock;\r\n    long startTime = 0L;\r\n    boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\r\n    boolean interrupted = Thread.interrupted();\r\n    try {\r\n        if (fair || !lock.tryLock()) {\r\n            startTime = initNanoTime(timeoutNanos);\r\n            for (long remainingNanos = timeoutNanos; ; ) {\r\n                try {\r\n                    if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS)) {\r\n                        break;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                } catch (InterruptedException interrupt) {\r\n                    interrupted = true;\r\n                    remainingNanos = remainingNanos(startTime, timeoutNanos);\r\n                }\r\n            }\r\n        }\r\n        boolean satisfied = false;\r\n        try {\r\n            while (true) {\r\n                try {\r\n                    if (guard.isSatisfied()) {\r\n                        satisfied = true;\r\n                    } else {\r\n                        final long remainingNanos;\r\n                        if (startTime == 0L) {\r\n                            startTime = initNanoTime(timeoutNanos);\r\n                            remainingNanos = timeoutNanos;\r\n                        } else {\r\n                            remainingNanos = remainingNanos(startTime, timeoutNanos);\r\n                        }\r\n                        satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\r\n                    }\r\n                    return satisfied;\r\n                } catch (InterruptedException interrupt) {\r\n                    interrupted = true;\r\n                    signalBeforeWaiting = false;\r\n                }\r\n            }\r\n        } finally {\r\n            if (!satisfied) {\r\n                lock.unlock();\r\n            }\r\n        }\r\n    } finally {\r\n        if (interrupted) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.zaxxer.hikari.pool.HikariPool.getConnection",
	"Comment": "get a connection from the pool, or timeout after the specified number of milliseconds.",
	"Method": "Connection getConnection(Connection getConnection,long hardTimeout){\r\n    suspendResumeLock.acquire();\r\n    final long startTime = currentTime();\r\n    try {\r\n        long timeout = hardTimeout;\r\n        do {\r\n            PoolEntry poolEntry = connectionBag.borrow(timeout, MILLISECONDS);\r\n            if (poolEntry == null) {\r\n                break;\r\n            }\r\n            final long now = currentTime();\r\n            if (poolEntry.isMarkedEvicted() || (elapsedMillis(poolEntry.lastAccessed, now) > aliveBypassWindowMs && !isConnectionAlive(poolEntry.connection))) {\r\n                closeConnection(poolEntry, poolEntry.isMarkedEvicted() ? EVICTED_CONNECTION_MESSAGE : DEAD_CONNECTION_MESSAGE);\r\n                timeout = hardTimeout - elapsedMillis(startTime);\r\n            } else {\r\n                metricsTracker.recordBorrowStats(poolEntry, startTime);\r\n                return poolEntry.createProxyConnection(leakTaskFactory.schedule(poolEntry), now);\r\n            }\r\n        } while (timeout > 0L);\r\n        metricsTracker.recordBorrowTimeoutStats(startTime);\r\n        throw createTimeoutException(startTime);\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n        throw new SQLException(poolName + \" - Interrupted during connection acquisition\", e);\r\n    } finally {\r\n        suspendResumeLock.release();\r\n    }\r\n}"
}, {
	"Path": "com.google.common.base.Utf8Test.testIsWellFormed_3Bytes",
	"Comment": "tests that round tripping of all three byte permutations work.",
	"Method": "void testIsWellFormed_3Bytes(){\r\n    testBytes(3, EXPECTED_THREE_BYTE_ROUNDTRIPPABLE_COUNT);\r\n}"
}, {
	"Path": "com.google.inject.internal.Initializables.of",
	"Comment": "returns an initializable for an instance that requires no initialization.",
	"Method": "Initializable<T> of(T instance){\r\n    return new Initializable<T>() {\r\n        @Override\r\n        public T get() {\r\n            return instance;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.valueOf(instance);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.google.inject.internal.Initializables.of",
	"Comment": "returns an initializable for an instance that requires no initialization.",
	"Method": "Initializable<T> of(T instance){\r\n    return instance;\r\n}"
}, {
	"Path": "com.google.inject.internal.Initializables.of",
	"Comment": "returns an initializable for an instance that requires no initialization.",
	"Method": "Initializable<T> of(T instance){\r\n    return String.valueOf(instance);\r\n}"
}, {
	"Path": "com.google.common.collect.AbstractTableReadTest.testRowNull",
	"Comment": "this test assumes that the implementation does not support null keys.",
	"Method": "void testRowNull(){\r\n    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\r\n    try {\r\n        table.row(null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AbstractService.checkCurrentState",
	"Comment": "checks that the current state is equal to the expected state.",
	"Method": "void checkCurrentState(State expected){\r\n    State actual = state();\r\n    if (actual != expected) {\r\n        if (actual == FAILED) {\r\n            throw new IllegalStateException(\"Expected the service \" + this + \" to be \" + expected + \", but the service has FAILED\", failureCause());\r\n        }\r\n        throw new IllegalStateException(\"Expected the service \" + this + \" to be \" + expected + \", but was \" + actual);\r\n    }\r\n}"
}, {
	"Path": "com.google.common.hash.BloomFilterTest.testBasic",
	"Comment": "sanity checking with many combinations of false positive rates and expected insertions",
	"Method": "void testBasic(){\r\n    for (double fpr = 0.0000001; fpr < 0.1; fpr *= 10) {\r\n        for (int expectedInsertions = 1; expectedInsertions <= 10000; expectedInsertions *= 10) {\r\n            checkSanity(BloomFilter.create(HashTestUtils.BAD_FUNNEL, expectedInsertions, fpr));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.MinMaxPriorityQueueTest.testInvalidatingRemove2",
	"Comment": "this tests a more obscure special case, but otherwise similar to above.",
	"Method": "void testInvalidatingRemove2(){\r\n    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();\r\n    List<Integer> values = Lists.newArrayList(1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 300, 400, 500, 600, 4, 5, 6, 7, 8, 9, 4, 5, 200, 250);\r\n    mmHeap.addAll(values);\r\n    assertEquals(25, mmHeap.size());\r\n    assertTrue(\"Heap is not intact initially\", mmHeap.isIntact());\r\n    mmHeap.remove(2);\r\n    assertEquals(24, mmHeap.size());\r\n    assertTrue(\"Heap is not intact after remove()\", mmHeap.isIntact());\r\n    values.removeAll(Lists.newArrayList(2));\r\n    assertEquals(values.size(), mmHeap.size());\r\n    assertTrue(values.containsAll(mmHeap));\r\n    assertTrue(mmHeap.containsAll(values));\r\n}"
}, {
	"Path": "com.google.common.testing.EqualsTesterTest.testInvalidEqualsIncompatibleClass",
	"Comment": "test proper handling where an object incorrectly tests for an incompatible class",
	"Method": "void testInvalidEqualsIncompatibleClass(){\r\n    Object obj = new InvalidEqualsIncompatibleClassObject();\r\n    equalsTester.addEqualityGroup(obj);\r\n    try {\r\n        equalsTester.testEquals();\r\n    } catch (AssertionFailedError e) {\r\n        assertErrorMessage(e, obj + \" must not be Object#equals to an arbitrary object of another class\");\r\n        return;\r\n    }\r\n    fail(\"Should get equal to incompatible class error\");\r\n}"
}, {
	"Path": "com.google.inject.assistedinject.FactoryProvider2.isValidForOptimizedAssistedInject",
	"Comment": "returns true if all dependencies are suitable for the optimized version of assistedinject. theoptimized version caches the binding & uses a threadlocal provider, so can only be applied ifthe assisted bindings are immediately provided. this looks for hints that the values may belazily retrieved, by looking for injections of injector or a provider for the assisted values.",
	"Method": "boolean isValidForOptimizedAssistedInject(Set<Dependency<?>> dependencies,Class<?> implementation,TypeLiteral<?> factoryType){\r\n    Set<Dependency<?>> badDeps = null;\r\n    for (Dependency<?> dep : dependencies) {\r\n        if (isInjectorOrAssistedProvider(dep)) {\r\n            if (badDeps == null) {\r\n                badDeps = Sets.newHashSet();\r\n            }\r\n            badDeps.add(dep);\r\n        }\r\n    }\r\n    if (badDeps != null && !badDeps.isEmpty()) {\r\n        logger.log(Level.WARNING, \"AssistedInject factory {0} will be slow \" + \"because {1} has assisted Provider dependencies or injects the Injector. \" + \"Stop injecting @Assisted Provider<T> (instead use @Assisted T) \" + \"or Injector to speed things up. (It will be a ~6500% speed bump!)  \" + \"The exact offending deps are: {2}\", new Object[] { factoryType, implementation, badDeps });\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.google.common.collect.Serialization.writeMap",
	"Comment": "stores the contents of a map in an output stream, as part of serialization. it does not supportconcurrent maps whose content may change while the method is running.the serialized output consists of the number of entries, first key, first value, second key,second value, and so on.",
	"Method": "void writeMap(Map<K, V> map,ObjectOutputStream stream){\r\n    stream.writeInt(map.size());\r\n    for (Map.Entry<K, V> entry : map.entrySet()) {\r\n        stream.writeObject(entry.getKey());\r\n        stream.writeObject(entry.getValue());\r\n    }\r\n}"
}, {
	"Path": "com.google.common.math.PairedStatsAccumulator.addAll",
	"Comment": "adds the given statistics to the dataset, as if the individual values used to compute thestatistics had been added directly.",
	"Method": "void addAll(PairedStats values){\r\n    if (values.count() == 0) {\r\n        return;\r\n    }\r\n    xStats.addAll(values.xStats());\r\n    if (yStats.count() == 0) {\r\n        sumOfProductsOfDeltas = values.sumOfProductsOfDeltas();\r\n    } else {\r\n        sumOfProductsOfDeltas += values.sumOfProductsOfDeltas() + (values.xStats().mean() - xStats.mean()) * (values.yStats().mean() - yStats.mean()) * values.count();\r\n    }\r\n    yStats.addAll(values.yStats());\r\n}"
}, {
	"Path": "com.google.common.io.ByteSource.hash",
	"Comment": "hashes the contents of this byte source using the given hash function.",
	"Method": "HashCode hash(HashFunction hashFunction,HashCode hash,HashFunction hashFunction){\r\n    Hasher hasher = hashFunction.newHasher();\r\n    copyTo(Funnels.asOutputStream(hasher));\r\n    return hasher.hash();\r\n}"
}, {
	"Path": "com.google.common.math.LongMathTest.computeMeanSafely",
	"Comment": "computes the mean in a way that is obvious and resilient to overflow by using bigintegerarithmetic.",
	"Method": "long computeMeanSafely(long x,long y){\r\n    BigInteger bigX = BigInteger.valueOf(x);\r\n    BigInteger bigY = BigInteger.valueOf(y);\r\n    BigDecimal bigMean = new BigDecimal(bigX.add(bigY)).divide(BigDecimal.valueOf(2), BigDecimal.ROUND_FLOOR);\r\n    return Long.parseLong(bigMean.toString());\r\n}"
}, {
	"Path": "com.google.common.primitives.ImmutableIntArray.hashCode",
	"Comment": "returns an unspecified hash code for the contents of this immutable array.",
	"Method": "int hashCode(int hashCode){\r\n    int hash = 1;\r\n    for (int i = start; i < end; i++) {\r\n        hash *= 31;\r\n        hash += Ints.hashCode(array[i]);\r\n    }\r\n    return hash;\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultimap.put",
	"Comment": "guaranteed to throw an exception and leave the multimap unmodified.",
	"Method": "Builder<K, V> put(K key,V value,Builder<K, V> put,Entry<? extends K, ? extends V> entry,boolean put,K key,V value){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.TreeBasedTable.createColumnKeyIterator",
	"Comment": "overridden column iterator to return columns values in globally sorted order.",
	"Method": "Iterator<C> createColumnKeyIterator(){\r\n    final Comparator<? super C> comparator = columnComparator();\r\n    final Iterator<C> merged = Iterators.mergeSorted(Iterables.transform(backingMap.values(), new Function<Map<C, V>, Iterator<C>>() {\r\n        @Override\r\n        public Iterator<C> apply(Map<C, V> input) {\r\n            return input.keySet().iterator();\r\n        }\r\n    }), comparator);\r\n    return new AbstractIterator<C>() {\r\n        @Nullable\r\n        C lastValue;\r\n        @Override\r\n        protected C computeNext() {\r\n            while (merged.hasNext()) {\r\n                C next = merged.next();\r\n                boolean duplicate = lastValue != null && comparator.compare(next, lastValue) == 0;\r\n                if (!duplicate) {\r\n                    lastValue = next;\r\n                    return lastValue;\r\n                }\r\n            }\r\n            lastValue = null;\r\n            return endOfData();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.google.common.collect.TreeBasedTable.createColumnKeyIterator",
	"Comment": "overridden column iterator to return columns values in globally sorted order.",
	"Method": "Iterator<C> createColumnKeyIterator(){\r\n    return input.keySet().iterator();\r\n}"
}, {
	"Path": "com.google.common.collect.TreeBasedTable.createColumnKeyIterator",
	"Comment": "overridden column iterator to return columns values in globally sorted order.",
	"Method": "Iterator<C> createColumnKeyIterator(){\r\n    while (merged.hasNext()) {\r\n        C next = merged.next();\r\n        boolean duplicate = lastValue != null && comparator.compare(next, lastValue) == 0;\r\n        if (!duplicate) {\r\n            lastValue = next;\r\n            return lastValue;\r\n        }\r\n    }\r\n    lastValue = null;\r\n    return endOfData();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSortedMap.pollFirstEntry",
	"Comment": "guaranteed to throw an exception and leave the map unmodified.",
	"Method": "Entry<K, V> pollFirstEntry(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.io.MoreFiles.checkAllowsInsecure",
	"Comment": "checks that the given options allow an insecure delete, throwing an exception if not.",
	"Method": "void checkAllowsInsecure(Path path,RecursiveDeleteOption[] options){\r\n    if (!Arrays.asList(options).contains(RecursiveDeleteOption.ALLOW_INSECURE)) {\r\n        throw new InsecureRecursiveDeleteException(path.toString());\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.internal.OptionalBinderTest.testWeakKeySet_integration",
	"Comment": "tests for com.google.inject.internal.weakkeyset not leaking memory.",
	"Method": "void testWeakKeySet_integration(){\r\n    Injector parentInjector = Guice.createInjector(new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            bind(String.class).toInstance(\"hi\");\r\n        }\r\n    });\r\n    WeakKeySetUtils.assertNotBlacklisted(parentInjector, Key.get(Integer.class));\r\n    Injector childInjector = parentInjector.createChildInjector(new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            OptionalBinder.newOptionalBinder(binder(), Integer.class).setDefault().toInstance(4);\r\n        }\r\n    });\r\n    WeakReference<Injector> weakRef = new WeakReference(childInjector);\r\n    WeakKeySetUtils.assertBlacklisted(parentInjector, Key.get(Integer.class));\r\n    childInjector = null;\r\n    Asserts.awaitClear(weakRef);\r\n    WeakKeySetUtils.assertNotBlacklisted(parentInjector, Key.get(Integer.class));\r\n}"
}, {
	"Path": "com.google.inject.internal.OptionalBinderTest.testWeakKeySet_integration",
	"Comment": "tests for com.google.inject.internal.weakkeyset not leaking memory.",
	"Method": "void testWeakKeySet_integration(){\r\n    bind(String.class).toInstance(\"hi\");\r\n}"
}, {
	"Path": "com.google.inject.internal.OptionalBinderTest.testWeakKeySet_integration",
	"Comment": "tests for com.google.inject.internal.weakkeyset not leaking memory.",
	"Method": "void testWeakKeySet_integration(){\r\n    OptionalBinder.newOptionalBinder(binder(), Integer.class).setDefault().toInstance(4);\r\n}"
}, {
	"Path": "com.google.inject.internal.MembersInjectorStore.get",
	"Comment": "returns a new complete members injector with injection listeners registered.",
	"Method": "MembersInjectorImpl<T> get(TypeLiteral<T> key,Errors errors){\r\n    return (MembersInjectorImpl<T>) cache.get(key, errors);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableCollection.internalArray",
	"Comment": "if this collection is backed by an array of its elements in insertion order, returns it.",
	"Method": "Object[] internalArray(){\r\n    return null;\r\n}"
}, {
	"Path": "com.google.common.eventbus.SubscriberRegistry.register",
	"Comment": "registers all subscriber methods on the given listener object.",
	"Method": "void register(Object listener){\r\n    Multimap<Class<?>, Subscriber> listenerMethods = findAllSubscribers(listener);\r\n    for (Entry<Class<?>, Collection<Subscriber>> entry : listenerMethods.asMap().entrySet()) {\r\n        Class<?> eventType = entry.getKey();\r\n        Collection<Subscriber> eventMethodsInListener = entry.getValue();\r\n        CopyOnWriteArraySet<Subscriber> eventSubscribers = subscribers.get(eventType);\r\n        if (eventSubscribers == null) {\r\n            CopyOnWriteArraySet<Subscriber> newSet = new CopyOnWriteArraySet();\r\n            eventSubscribers = MoreObjects.firstNonNull(subscribers.putIfAbsent(eventType, newSet), newSet);\r\n        }\r\n        eventSubscribers.addAll(eventMethodsInListener);\r\n    }\r\n}"
}, {
	"Path": "com.google.common.reflect.ImmutableTypeToInstanceMap.putInstance",
	"Comment": "guaranteed to throw an exception and leave the map unmodified.",
	"Method": "T putInstance(TypeToken<T> type,T value,T putInstance,Class<T> type,T value){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSet.of",
	"Comment": "casting to any type is safe because the set will never hold any elements.",
	"Method": "ImmutableSet<E> of(ImmutableSet<E> of,E element,ImmutableSet<E> of,E e1,E e2,ImmutableSet<E> of,E e1,E e2,E e3,ImmutableSet<E> of,E e1,E e2,E e3,E e4,ImmutableSet<E> of,E e1,E e2,E e3,E e4,E e5,ImmutableSet<E> of,E e1,E e2,E e3,E e4,E e5,E e6,E others){\r\n    int size = others.length + 6;\r\n    List<E> all = new ArrayList<E>(size);\r\n    Collections.addAll(all, e1, e2, e3, e4, e5, e6);\r\n    Collections.addAll(all, others);\r\n    return copyOf(all.iterator());\r\n}"
}, {
	"Path": "com.google.common.graph.ElementOrderTest.nodeOrder_default",
	"Comment": "the default ordering is insertion unless otherwise specified.",
	"Method": "void nodeOrder_default(){\r\n    MutableGraph<Integer> graph = GraphBuilder.directed().build();\r\n    addNodes(graph);\r\n    assertThat(graph.nodeOrder()).isEqualTo(insertion());\r\n    assertThat(graph.nodes()).containsExactly(3, 1, 4).inOrder();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSortedMultiset.of",
	"Comment": "returns an immutable sorted multiset containing the given elements sorted by their naturalordering.",
	"Method": "ImmutableSortedMultiset<E> of(ImmutableSortedMultiset<E> of,E element,ImmutableSortedMultiset<E> of,E e1,E e2,ImmutableSortedMultiset<E> of,E e1,E e2,E e3,ImmutableSortedMultiset<E> of,E e1,E e2,E e3,E e4,ImmutableSortedMultiset<E> of,E e1,E e2,E e3,E e4,E e5,ImmutableSortedMultiset<E> of,E e1,E e2,E e3,E e4,E e5,E e6,E remaining){\r\n    int size = remaining.length + 6;\r\n    List<E> all = Lists.newArrayListWithCapacity(size);\r\n    Collections.addAll(all, e1, e2, e3, e4, e5, e6);\r\n    Collections.addAll(all, remaining);\r\n    return copyOf(Ordering.natural(), all);\r\n}"
}, {
	"Path": "com.google.common.testing.EqualsTesterTest.testInvalidNotEqualsEqualObject",
	"Comment": "test proper handling where an object is not equal to one the user has said should be equal",
	"Method": "void testInvalidNotEqualsEqualObject(){\r\n    equalsTester.addEqualityGroup(reference, notEqualObject1);\r\n    try {\r\n        equalsTester.testEquals();\r\n    } catch (AssertionFailedError e) {\r\n        assertErrorMessage(e, reference + \" [group 1, item 1]\");\r\n        assertErrorMessage(e, notEqualObject1 + \" [group 1, item 2]\");\r\n        return;\r\n    }\r\n    fail(\"Should get not equal to equal object error\");\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableBiMap.of",
	"Comment": "casting to any type is safe because the set will never hold any elements.",
	"Method": "ImmutableBiMap<K, V> of(ImmutableBiMap<K, V> of,K k1,V v1,ImmutableBiMap<K, V> of,K k1,V v1,K k2,V v2,ImmutableBiMap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,ImmutableBiMap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,ImmutableBiMap<K, V> of,K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,K k5,V v5){\r\n    return new RegularImmutableBiMap<K, V>(ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5));\r\n}"
}, {
	"Path": "com.google.common.testing.EquivalenceTester.addEquivalenceGroup",
	"Comment": "adds a group of objects that are supposed to be equivalent to each other and not equivalent toobjects in any other equivalence group added to this tester.",
	"Method": "EquivalenceTester<T> addEquivalenceGroup(T first,T rest,EquivalenceTester<T> addEquivalenceGroup,Iterable<T> group){\r\n    delegate.addRelatedGroup(group);\r\n    items.addAll(ImmutableList.copyOf(group));\r\n    return this;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.TestThread.callAndAssertThrows",
	"Comment": "causes this thread to call the named method, and asserts that the call throws the expected typeof throwable.",
	"Method": "void callAndAssertThrows(Class<? extends Throwable> expected,String methodName,Object arguments){\r\n    checkNotNull(expected);\r\n    checkNotNull(methodName);\r\n    checkNotNull(arguments);\r\n    sendRequest(methodName, arguments);\r\n    assertEquals(expected, getResponse(methodName).getThrowable().getClass());\r\n}"
}, {
	"Path": "com.google.common.cache.CacheBuilderSpec.toString",
	"Comment": "returns a string representation for this cachebuilderspec instance. the form of thisrepresentation is not guaranteed.",
	"Method": "String toString(){\r\n    return MoreObjects.toStringHelper(this).addValue(toParsableString()).toString();\r\n}"
}, {
	"Path": "com.google.common.io.IoTestCase.getTestFile",
	"Comment": "returns the file with the given name under the testdata directory.",
	"Method": "File getTestFile(String name){\r\n    File file = new File(getTestDir(), name);\r\n    if (!file.exists()) {\r\n        URL resourceUrl = IoTestCase.class.getResource(\"testdata/\" + name);\r\n        if (resourceUrl == null) {\r\n            return null;\r\n        }\r\n        copy(resourceUrl, file);\r\n    }\r\n    return file;\r\n}"
}, {
	"Path": "com.google.inject.assistedinject.FactoryProvider2.getDependencies",
	"Comment": "calculates all dependencies required by the implementation and constructor.",
	"Method": "Set<Dependency<?>> getDependencies(Set<Dependency<?>> getDependencies,Set<Dependency<?>> getDependencies,InjectionPoint ctorPoint,TypeLiteral<?> implementation){\r\n    ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder();\r\n    builder.addAll(ctorPoint.getDependencies());\r\n    if (!implementation.getRawType().isInterface()) {\r\n        for (InjectionPoint ip : InjectionPoint.forInstanceMethodsAndFields(implementation)) {\r\n            builder.addAll(ip.getDependencies());\r\n        }\r\n    }\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.ServiceManagerTest.testEmptyServiceManager",
	"Comment": "this is for covering a case where the servicemanager would behave strangely if constructed withno service under management. listeners would never fire because the servicemanager was healthyand stopped at the same time. this test ensures that listeners fire and ishealthy makes sense.",
	"Method": "void testEmptyServiceManager(){\r\n    Logger logger = Logger.getLogger(ServiceManager.class.getName());\r\n    logger.setLevel(Level.FINEST);\r\n    TestLogHandler logHandler = new TestLogHandler();\r\n    logger.addHandler(logHandler);\r\n    ServiceManager manager = new ServiceManager(Arrays.<Service>asList());\r\n    RecordingListener listener = new RecordingListener();\r\n    manager.addListener(listener);\r\n    manager.startAsync().awaitHealthy();\r\n    assertTrue(manager.isHealthy());\r\n    assertTrue(listener.healthyCalled);\r\n    assertFalse(listener.stoppedCalled);\r\n    assertTrue(listener.failedServices.isEmpty());\r\n    manager.stopAsync().awaitStopped();\r\n    assertFalse(manager.isHealthy());\r\n    assertTrue(listener.stoppedCalled);\r\n    assertTrue(listener.failedServices.isEmpty());\r\n    assertEquals(\"ServiceManager{services=[]}\", manager.toString());\r\n    assertTrue(manager.servicesByState().isEmpty());\r\n    assertTrue(manager.startupTimes().isEmpty());\r\n    Formatter logFormatter = new Formatter() {\r\n        @Override\r\n        public String format(LogRecord record) {\r\n            return formatMessage(record);\r\n        }\r\n    };\r\n    for (LogRecord record : logHandler.getStoredLogRecords()) {\r\n        assertThat(logFormatter.format(record)).doesNotContain(\"NoOpService\");\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.ServiceManagerTest.testEmptyServiceManager",
	"Comment": "this is for covering a case where the servicemanager would behave strangely if constructed withno service under management. listeners would never fire because the servicemanager was healthyand stopped at the same time. this test ensures that listeners fire and ishealthy makes sense.",
	"Method": "void testEmptyServiceManager(){\r\n    return formatMessage(record);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSortedMap.values",
	"Comment": "returns an immutable collection of the values in this map, sorted by the ordering of thecorresponding keys.",
	"Method": "ImmutableCollection<V> values(){\r\n    return valueList;\r\n}"
}, {
	"Path": "com.zaxxer.hikari.pool.HikariPool.shutdown",
	"Comment": "shutdown the pool, closing all idle connections and aborting or closing active connections.",
	"Method": "void shutdown(){\r\n    try {\r\n        poolState = POOL_SHUTDOWN;\r\n        if (addConnectionExecutor == null) {\r\n            return;\r\n        }\r\n        logPoolState(\"Before shutdown \");\r\n        if (houseKeeperTask != null) {\r\n            houseKeeperTask.cancel(false);\r\n            houseKeeperTask = null;\r\n        }\r\n        softEvictConnections();\r\n        addConnectionExecutor.shutdown();\r\n        addConnectionExecutor.awaitTermination(getLoginTimeout(), SECONDS);\r\n        destroyHouseKeepingExecutorService();\r\n        connectionBag.close();\r\n        final ExecutorService assassinExecutor = createThreadPoolExecutor(config.getMaximumPoolSize(), poolName + \" connection assassinator\", config.getThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());\r\n        try {\r\n            final long start = currentTime();\r\n            do {\r\n                abortActiveConnections(assassinExecutor);\r\n                softEvictConnections();\r\n            } while (getTotalConnections() > 0 && elapsedMillis(start) < SECONDS.toMillis(10));\r\n        } finally {\r\n            assassinExecutor.shutdown();\r\n            assassinExecutor.awaitTermination(10L, SECONDS);\r\n        }\r\n        shutdownNetworkTimeoutExecutor();\r\n        closeConnectionExecutor.shutdown();\r\n        closeConnectionExecutor.awaitTermination(10L, SECONDS);\r\n    } finally {\r\n        logPoolState(\"After shutdown \");\r\n        handleMBeans(this, false);\r\n        metricsTracker.close();\r\n    }\r\n}"
}, {
	"Path": "org.hswebframework.web.cache.spring.fix.FixUseSupperClassFallbackCacheOperationSource.getCacheKey",
	"Comment": "determine a cache key for the given method and target class.must not produce same key for overloaded methods.must produce same key for different instances of the same method.",
	"Method": "Object getCacheKey(Method method,Class<?> targetClass){\r\n    return new MethodClassKey(method, targetClass);\r\n}"
}, {
	"Path": "com.google.inject.internal.Initializer.validateOustandingInjections",
	"Comment": "prepares member injectors for all injected instances. this prompts guice to do static analysison the injected instances.",
	"Method": "void validateOustandingInjections(Errors errors){\r\n    validationStarted = true;\r\n    initializablesCache.clear();\r\n    for (InjectableReference<?> reference : pendingInjections) {\r\n        try {\r\n            reference.validate(errors);\r\n        } catch (ErrorsException e) {\r\n            errors.merge(e.getErrors());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.hash.SipHashFunctionTest.testCollisionsDueToIncorrectSignExtension",
	"Comment": "a fault implementation will generate collisions for these inputs.",
	"Method": "void testCollisionsDueToIncorrectSignExtension(){\r\n    byte[] col1 = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, (byte) 0x80 };\r\n    byte[] col2 = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, (byte) 0x81 };\r\n    byte[] col3 = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, (byte) 0xff };\r\n    ImmutableSet<HashCode> hashCodes = ImmutableSet.of(SIP_WITH_KEY.hashBytes(col1), SIP_WITH_KEY.hashBytes(col2), SIP_WITH_KEY.hashBytes(col3));\r\n    assertEquals(3, hashCodes.size());\r\n}"
}, {
	"Path": "com.google.inject.internal.TypeConverterBindingProcessor.prepareBuiltInConverters",
	"Comment": "installs default converters for primitives, enums, and class literals.",
	"Method": "void prepareBuiltInConverters(InjectorImpl injector){\r\n    convertToPrimitiveType(injector, int.class, Integer.class);\r\n    convertToPrimitiveType(injector, long.class, Long.class);\r\n    convertToPrimitiveType(injector, boolean.class, Boolean.class);\r\n    convertToPrimitiveType(injector, byte.class, Byte.class);\r\n    convertToPrimitiveType(injector, short.class, Short.class);\r\n    convertToPrimitiveType(injector, float.class, Float.class);\r\n    convertToPrimitiveType(injector, double.class, Double.class);\r\n    convertToClass(injector, Character.class, new TypeConverter() {\r\n        @Override\r\n        public Object convert(String value, TypeLiteral<?> toType) {\r\n            value = value.trim();\r\n            if (value.length() != 1) {\r\n                throw new RuntimeException(\"Length != 1.\");\r\n            }\r\n            return value.charAt(0);\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"TypeConverter<Character>\";\r\n        }\r\n    });\r\n    convertToClasses(injector, Matchers.subclassesOf(Enum.class), new TypeConverter() {\r\n        @Override\r\n        @SuppressWarnings(\"unchecked\")\r\n        public Object convert(String value, TypeLiteral<?> toType) {\r\n            return Enum.valueOf((Class) toType.getRawType(), value);\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"TypeConverter<E extends Enum<E>>\";\r\n        }\r\n    });\r\n    internalConvertToTypes(injector, new AbstractMatcher<TypeLiteral<?>>() {\r\n        @Override\r\n        public boolean matches(TypeLiteral<?> typeLiteral) {\r\n            return typeLiteral.getRawType() == Class.class;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"Class<?>\";\r\n        }\r\n    }, new TypeConverter() {\r\n        @Override\r\n        @SuppressWarnings(\"unchecked\")\r\n        public Object convert(String value, TypeLiteral<?> toType) {\r\n            try {\r\n                return Class.forName(value);\r\n            } catch (ClassNotFoundException e) {\r\n                throw new RuntimeException(e.getMessage());\r\n            }\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"TypeConverter<Class<?>>\";\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.inject.internal.TypeConverterBindingProcessor.prepareBuiltInConverters",
	"Comment": "installs default converters for primitives, enums, and class literals.",
	"Method": "void prepareBuiltInConverters(InjectorImpl injector){\r\n    value = value.trim();\r\n    if (value.length() != 1) {\r\n        throw new RuntimeException(\"Length != 1.\");\r\n    }\r\n    return value.charAt(0);\r\n}"
}, {
	"Path": "com.google.inject.internal.TypeConverterBindingProcessor.prepareBuiltInConverters",
	"Comment": "installs default converters for primitives, enums, and class literals.",
	"Method": "void prepareBuiltInConverters(InjectorImpl injector){\r\n    return \"TypeConverter<Character>\";\r\n}"
}, {
	"Path": "com.google.inject.internal.TypeConverterBindingProcessor.prepareBuiltInConverters",
	"Comment": "installs default converters for primitives, enums, and class literals.",
	"Method": "void prepareBuiltInConverters(InjectorImpl injector){\r\n    return Enum.valueOf((Class) toType.getRawType(), value);\r\n}"
}, {
	"Path": "com.google.inject.internal.TypeConverterBindingProcessor.prepareBuiltInConverters",
	"Comment": "installs default converters for primitives, enums, and class literals.",
	"Method": "void prepareBuiltInConverters(InjectorImpl injector){\r\n    return \"TypeConverter<E extends Enum<E>>\";\r\n}"
}, {
	"Path": "com.google.inject.internal.TypeConverterBindingProcessor.prepareBuiltInConverters",
	"Comment": "installs default converters for primitives, enums, and class literals.",
	"Method": "void prepareBuiltInConverters(InjectorImpl injector){\r\n    return typeLiteral.getRawType() == Class.class;\r\n}"
}, {
	"Path": "com.google.inject.internal.TypeConverterBindingProcessor.prepareBuiltInConverters",
	"Comment": "installs default converters for primitives, enums, and class literals.",
	"Method": "void prepareBuiltInConverters(InjectorImpl injector){\r\n    return \"Class<?>\";\r\n}"
}, {
	"Path": "com.google.inject.internal.TypeConverterBindingProcessor.prepareBuiltInConverters",
	"Comment": "installs default converters for primitives, enums, and class literals.",
	"Method": "void prepareBuiltInConverters(InjectorImpl injector){\r\n    try {\r\n        return Class.forName(value);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new RuntimeException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.internal.TypeConverterBindingProcessor.prepareBuiltInConverters",
	"Comment": "installs default converters for primitives, enums, and class literals.",
	"Method": "void prepareBuiltInConverters(InjectorImpl injector){\r\n    return \"TypeConverter<Class<?>>\";\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableBiMap.copyOf",
	"Comment": "returns an immutable bimap containing the given entries. the returned bimap iterates overentries in the same order as the original iterable.",
	"Method": "ImmutableBiMap<K, V> copyOf(Map<? extends K, ? extends V> map,ImmutableBiMap<K, V> copyOf,Iterable<? extends Entry<? extends K, ? extends V>> entries){\r\n    return new Builder<K, V>().putAll(entries).build();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.ExecutionList.execute",
	"Comment": "runs this execution list, executing all existing pairs in the order they were added. however,note that listeners added after this point may be executed before those previously added, andnote that the execution order of all listeners is ultimately chosen by the implementations ofthe supplied executors.this method is idempotent. calling it several times in parallel is semantically equivalentto calling it exactly once.",
	"Method": "void execute(){\r\n    RunnableExecutorPair list;\r\n    synchronized (this) {\r\n        if (executed) {\r\n            return;\r\n        }\r\n        executed = true;\r\n        list = runnables;\r\n        runnables = null;\r\n    }\r\n    RunnableExecutorPair reversedList = null;\r\n    while (list != null) {\r\n        RunnableExecutorPair tmp = list;\r\n        list = list.next;\r\n        tmp.next = reversedList;\r\n        reversedList = tmp;\r\n    }\r\n    while (reversedList != null) {\r\n        executeListener(reversedList.runnable, reversedList.executor);\r\n        reversedList = reversedList.next;\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.MonitorBasedArrayBlockingQueue.put",
	"Comment": "inserts the specified element at the tail of this queue, waiting for space to become availableif the queue is full.",
	"Method": "void put(E e){\r\n    if (e == null)\r\n        throw new NullPointerException();\r\n    final Monitor monitor = this.monitor;\r\n    monitor.enterWhen(notFull);\r\n    try {\r\n        insert(e);\r\n    } finally {\r\n        monitor.leave();\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.internal.ProviderMethodsModule.overrides",
	"Comment": "returns true if a overrides b, assumes that the signatures match",
	"Method": "boolean overrides(Method a,Method b){\r\n    int modifiers = b.getModifiers();\r\n    if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) {\r\n        return true;\r\n    }\r\n    if (Modifier.isPrivate(modifiers)) {\r\n        return false;\r\n    }\r\n    return a.getDeclaringClass().getPackage().equals(b.getDeclaringClass().getPackage());\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AggregateFuture.addCausalChain",
	"Comment": "adds the chain to the seen set, and returns whether all the chain was new to us.",
	"Method": "boolean addCausalChain(Set<Throwable> seen,Throwable t){\r\n    for (; t != null; t = t.getCause()) {\r\n        boolean firstTimeSeen = seen.add(t);\r\n        if (!firstTimeSeen) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.google.common.io.CharStreamsTest.wrapAsGenericAppendable",
	"Comment": "wrap an appendable in an appendable to defeat any type specific optimizations.",
	"Method": "Appendable wrapAsGenericAppendable(Appendable a){\r\n    return new Appendable() {\r\n        @Override\r\n        public Appendable append(CharSequence csq) throws IOException {\r\n            a.append(csq);\r\n            return this;\r\n        }\r\n        @Override\r\n        public Appendable append(CharSequence csq, int start, int end) throws IOException {\r\n            a.append(csq, start, end);\r\n            return this;\r\n        }\r\n        @Override\r\n        public Appendable append(char c) throws IOException {\r\n            a.append(c);\r\n            return this;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.google.common.io.CharStreamsTest.wrapAsGenericAppendable",
	"Comment": "wrap an appendable in an appendable to defeat any type specific optimizations.",
	"Method": "Appendable wrapAsGenericAppendable(Appendable a){\r\n    a.append(csq);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.common.io.CharStreamsTest.wrapAsGenericAppendable",
	"Comment": "wrap an appendable in an appendable to defeat any type specific optimizations.",
	"Method": "Appendable wrapAsGenericAppendable(Appendable a){\r\n    a.append(csq, start, end);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.common.io.CharStreamsTest.wrapAsGenericAppendable",
	"Comment": "wrap an appendable in an appendable to defeat any type specific optimizations.",
	"Method": "Appendable wrapAsGenericAppendable(Appendable a){\r\n    a.append(c);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.common.net.InetAddresses.decrement",
	"Comment": "returns a new inetaddress that is one less than the passed in address. this method works forboth ipv4 and ipv6 addresses.",
	"Method": "InetAddress decrement(InetAddress address){\r\n    byte[] addr = address.getAddress();\r\n    int i = addr.length - 1;\r\n    while (i >= 0 && addr[i] == (byte) 0x00) {\r\n        addr[i] = (byte) 0xff;\r\n        i--;\r\n    }\r\n    checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\r\n    addr[i]--;\r\n    return bytesToInetAddress(addr);\r\n}"
}, {
	"Path": "com.google.common.collect.CompactHashMap.insertEntry",
	"Comment": "creates a fresh entry with the specified object at the specified position in the entry arrays.",
	"Method": "void insertEntry(int entryIndex,K key,V value,int hash){\r\n    this.entries[entryIndex] = ((long) hash << 32) | (NEXT_MASK & UNSET);\r\n    this.keys[entryIndex] = key;\r\n    this.values[entryIndex] = value;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.enterIf",
	"Comment": "enters this monitor if the guard is satisfied. blocks at most the given time acquiring thelock, but does not wait for the guard to be satisfied.",
	"Method": "boolean enterIf(Guard guard,boolean enterIf,Guard guard,long time,TimeUnit unit){\r\n    if (guard.monitor != this) {\r\n        throw new IllegalMonitorStateException();\r\n    }\r\n    if (!enter(time, unit)) {\r\n        return false;\r\n    }\r\n    boolean satisfied = false;\r\n    try {\r\n        return satisfied = guard.isSatisfied();\r\n    } finally {\r\n        if (!satisfied) {\r\n            lock.unlock();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableTable.clear",
	"Comment": "guaranteed to throw an exception and leave the table unmodified.",
	"Method": "void clear(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableCollection.clear",
	"Comment": "guaranteed to throw an exception and leave the collection unmodified.",
	"Method": "void clear(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.testing.google.UnmodifiableCollectionTests.assertIteratorIsUnmodifiable",
	"Comment": "verifies that an iterator is unmodifiable.this test only works with iterators that iterate over a finite set.",
	"Method": "void assertIteratorIsUnmodifiable(Iterator<?> iterator){\r\n    while (iterator.hasNext()) {\r\n        iterator.next();\r\n        try {\r\n            iterator.remove();\r\n            fail(\"Remove on unmodifiable iterator succeeded\");\r\n        } catch (UnsupportedOperationException expected) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableList.of",
	"Comment": "casting to any type is safe because the list will never hold any elements.",
	"Method": "ImmutableList<E> of(ImmutableList<E> of,E element,ImmutableList<E> of,E e1,E e2,ImmutableList<E> of,E e1,E e2,E e3,ImmutableList<E> of,E e1,E e2,E e3,E e4,ImmutableList<E> of,E e1,E e2,E e3,E e4,E e5,ImmutableList<E> of,E e1,E e2,E e3,E e4,E e5,E e6,ImmutableList<E> of,E e1,E e2,E e3,E e4,E e5,E e6,E e7,ImmutableList<E> of,E e1,E e2,E e3,E e4,E e5,E e6,E e7,E e8,ImmutableList<E> of,E e1,E e2,E e3,E e4,E e5,E e6,E e7,E e8,E e9,ImmutableList<E> of,E e1,E e2,E e3,E e4,E e5,E e6,E e7,E e8,E e9,E e10,ImmutableList<E> of,E e1,E e2,E e3,E e4,E e5,E e6,E e7,E e8,E e9,E e10,E e11,ImmutableList<E> of,E e1,E e2,E e3,E e4,E e5,E e6,E e7,E e8,E e9,E e10,E e11,E e12,E others){\r\n    final int paramCount = 12;\r\n    Object[] array = new Object[paramCount + others.length];\r\n    arrayCopy(array, 0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12);\r\n    arrayCopy(array, paramCount, others);\r\n    return new RegularImmutableList<E>(ImmutableList.<E>nullCheckedList(array));\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSetMultimap.get",
	"Comment": "returns an immutable set of the values for the given key. if no mappings in the multimap havethe provided key, an empty immutable set is returned. the values are in the same order as theparameters used to build this multimap.",
	"Method": "ImmutableSet<V> get(K key){\r\n    ImmutableSet<V> set = (ImmutableSet<V>) map.get(key);\r\n    return MoreObjects.firstNonNull(set, emptySet);\r\n}"
}, {
	"Path": "com.google.common.collect.Multisets.retainOccurrencesImpl",
	"Comment": "delegate implementation which cares about the element type.",
	"Method": "boolean retainOccurrencesImpl(Multiset<E> multisetToModify,Multiset<?> occurrencesToRetain){\r\n    checkNotNull(multisetToModify);\r\n    checkNotNull(occurrencesToRetain);\r\n    Iterator<Entry<E>> entryIterator = multisetToModify.entrySet().iterator();\r\n    boolean changed = false;\r\n    while (entryIterator.hasNext()) {\r\n        Entry<E> entry = entryIterator.next();\r\n        int retainCount = occurrencesToRetain.count(entry.getElement());\r\n        if (retainCount == 0) {\r\n            entryIterator.remove();\r\n            changed = true;\r\n        } else if (retainCount < entry.getCount()) {\r\n            multisetToModify.setCount(entry.getElement(), retainCount);\r\n            changed = true;\r\n        }\r\n    }\r\n    return changed;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AtomicLongMap.containsKey",
	"Comment": "returns true if this map contains a mapping for the specified key.",
	"Method": "boolean containsKey(Object key){\r\n    return map.containsKey(key);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableTable.remove",
	"Comment": "guaranteed to throw an exception and leave the table unmodified.",
	"Method": "V remove(Object rowKey,Object columnKey){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.base.Converter.identity",
	"Comment": "returns a serializable converter that always converts or reverses an object to itself.",
	"Method": "Converter<T, T> identity(){\r\n    return (IdentityConverter<T>) IdentityConverter.INSTANCE;\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSetMultimap.removeAll",
	"Comment": "guaranteed to throw an exception and leave the multimap unmodified.",
	"Method": "ImmutableSet<V> removeAll(Object key){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.StandardTable.createColumnKeyIterator",
	"Comment": "creates an iterator that returns each column value with duplicates omitted.",
	"Method": "Iterator<C> createColumnKeyIterator(){\r\n    return new ColumnKeyIterator();\r\n}"
}, {
	"Path": "com.google.inject.spi.ModuleSource.getPartialCallStackSize",
	"Comment": "returns the size of partial call stack if stack trace collection is on otherwise zero.",
	"Method": "int getPartialCallStackSize(){\r\n    return partialCallStack.length;\r\n}"
}, {
	"Path": "com.google.common.testing.EqualsTesterTest.testTestEqualsEqualsObjects",
	"Comment": "test equalstester after populating equalobjects. this checks proper handling of equality andverifies hashcode for valid objects",
	"Method": "void testTestEqualsEqualsObjects(){\r\n    equalsTester.addEqualityGroup(reference, equalObject1, equalObject2);\r\n    equalsTester.testEquals();\r\n}"
}, {
	"Path": "com.google.common.cache.CacheLoadingTest.testConcurrentLoadingDefault",
	"Comment": "on a successful concurrent computation, only one thread does the work, but all the threads getthe same result.",
	"Method": "void testConcurrentLoadingDefault(CacheBuilder<Object, Object> builder){\r\n    int count = 10;\r\n    final AtomicInteger callCount = new AtomicInteger();\r\n    final CountDownLatch startSignal = new CountDownLatch(count + 1);\r\n    final Object result = new Object();\r\n    LoadingCache<String, Object> cache = builder.build(new CacheLoader<String, Object>() {\r\n        @Override\r\n        public Object load(String key) throws InterruptedException {\r\n            callCount.incrementAndGet();\r\n            startSignal.await();\r\n            return result;\r\n        }\r\n    });\r\n    List<Object> resultArray = doConcurrentGet(cache, \"bar\", count, startSignal);\r\n    assertEquals(1, callCount.get());\r\n    for (int i = 0; i < count; i++) {\r\n        assertSame(\"result(\" + i + \") didn't match expected\", result, resultArray.get(i));\r\n    }\r\n}"
}, {
	"Path": "com.google.common.cache.CacheLoadingTest.testConcurrentLoadingDefault",
	"Comment": "on a successful concurrent computation, only one thread does the work, but all the threads getthe same result.",
	"Method": "void testConcurrentLoadingDefault(CacheBuilder<Object, Object> builder){\r\n    callCount.incrementAndGet();\r\n    startSignal.await();\r\n    return result;\r\n}"
}, {
	"Path": "com.google.inject.internal.util.SourceProvider.get",
	"Comment": "returns the calling line of code. the selected line is the nearest to the top of the stack thatis not skipped.",
	"Method": "StackTraceElement get(StackTraceElement[] stackTraceElements){\r\n    Preconditions.checkNotNull(stackTraceElements, \"The stack trace elements cannot be null.\");\r\n    for (final StackTraceElement element : stackTraceElements) {\r\n        String className = element.getClassName();\r\n        if (!shouldBeSkipped(className)) {\r\n            return element;\r\n        }\r\n    }\r\n    throw new AssertionError();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableList.sort",
	"Comment": "guaranteed to throw an exception and leave the list unmodified.",
	"Method": "void sort(Comparator<? super E> c){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMap.entrySet",
	"Comment": "returns an immutable set of the mappings in this map. the iteration order is specified by themethod used to create this map. typically, this is insertion order.",
	"Method": "ImmutableSet<Entry<K, V>> entrySet(){\r\n    if (cachedEntrySet != null) {\r\n        return cachedEntrySet;\r\n    }\r\n    return cachedEntrySet = createEntrySet();\r\n}"
}, {
	"Path": "com.google.common.escape.ArrayBasedCharEscaper.escape",
	"Comment": "this is overridden to improve performance. rough benchmarking shows that this almost doublesthe speed when processing strings that do not require any escaping.",
	"Method": "String escape(String s,char[] escape,char c){\r\n    if (c < replacementsLength) {\r\n        char[] chars = replacements[c];\r\n        if (chars != null) {\r\n            return chars;\r\n        }\r\n    }\r\n    if (c >= safeMin && c <= safeMax) {\r\n        return null;\r\n    }\r\n    return escapeUnsafe(c);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableList.asImmutableList",
	"Comment": "views the array as an immutable list. copies if the specified range does not cover the completearray. does not check for nulls.",
	"Method": "ImmutableList<E> asImmutableList(Object[] elements,ImmutableList<E> asImmutableList,Object[] elements,int length){\r\n    return unsafeDelegateList((List) Arrays.asList(elements));\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.GeneratedMonitorTest.sortMethods",
	"Comment": "sorts the given methods primarily by name and secondarily by number of parameters.",
	"Method": "void sortMethods(Method[] methods){\r\n    Arrays.sort(methods, new Comparator<Method>() {\r\n        @Override\r\n        public int compare(Method m1, Method m2) {\r\n            int nameComparison = m1.getName().compareTo(m2.getName());\r\n            if (nameComparison != 0) {\r\n                return nameComparison;\r\n            } else {\r\n                return Ints.compare(m1.getParameterTypes().length, m2.getParameterTypes().length);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.GeneratedMonitorTest.sortMethods",
	"Comment": "sorts the given methods primarily by name and secondarily by number of parameters.",
	"Method": "void sortMethods(Method[] methods){\r\n    int nameComparison = m1.getName().compareTo(m2.getName());\r\n    if (nameComparison != 0) {\r\n        return nameComparison;\r\n    } else {\r\n        return Ints.compare(m1.getParameterTypes().length, m2.getParameterTypes().length);\r\n    }\r\n}"
}, {
	"Path": "com.google.common.io.Resources.readLines",
	"Comment": "streams lines from a url, stopping when our callback returns false, or we have read all of thelines.",
	"Method": "T readLines(URL url,Charset charset,LineProcessor<T> callback,List<String> readLines,URL url,Charset charset){\r\n    return readLines(url, charset, new LineProcessor<List<String>>() {\r\n        final List<String> result = Lists.newArrayList();\r\n        @Override\r\n        public boolean processLine(String line) {\r\n            result.add(line);\r\n            return true;\r\n        }\r\n        @Override\r\n        public List<String> getResult() {\r\n            return result;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.common.io.Resources.readLines",
	"Comment": "streams lines from a url, stopping when our callback returns false, or we have read all of thelines.",
	"Method": "T readLines(URL url,Charset charset,LineProcessor<T> callback,List<String> readLines,URL url,Charset charset){\r\n    result.add(line);\r\n    return true;\r\n}"
}, {
	"Path": "com.google.common.io.Resources.readLines",
	"Comment": "streams lines from a url, stopping when our callback returns false, or we have read all of thelines.",
	"Method": "T readLines(URL url,Charset charset,LineProcessor<T> callback,List<String> readLines,URL url,Charset charset){\r\n    return result;\r\n}"
}, {
	"Path": "com.zaxxer.hikari.pool.PoolBase.checkDefaultIsolation",
	"Comment": "check the default transaction isolation of the connection.",
	"Method": "void checkDefaultIsolation(Connection connection){\r\n    try {\r\n        defaultTransactionIsolation = connection.getTransactionIsolation();\r\n        if (transactionIsolation == -1) {\r\n            transactionIsolation = defaultTransactionIsolation;\r\n        }\r\n    } catch (SQLException e) {\r\n        logger.warn(\"{} - Default transaction isolation level detection failed ({}).\", poolName, e.getMessage());\r\n        if (e.getSQLState() != null && !e.getSQLState().startsWith(\"08\")) {\r\n            throw e;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSortedSet.reverseOrder",
	"Comment": "returns a builder that creates immutable sorted sets whose elements are ordered by the reverseof their natural ordering.",
	"Method": "Builder<E> reverseOrder(){\r\n    return new Builder<E>(Ordering.natural().reverse());\r\n}"
}, {
	"Path": "com.google.common.collect.ObjectArrays.newArray",
	"Comment": "returns a new array of the given length with the same type as a reference array.",
	"Method": "T[] newArray(Class<T> type,int length,T[] newArray,T[] reference,int length){\r\n    return Platform.newArray(reference, length);\r\n}"
}, {
	"Path": "org.apache.dubbo.rpc.cluster.support.FailoverClusterInvokerTest.testInvokerDestroyAndReList",
	"Comment": "when invokers in directory changes after a failed request but just before a retry effort,then we should reselect from the latest invokers before retry.",
	"Method": "void testInvokerDestroyAndReList(){\r\n    final URL url = URL.valueOf(\"test://localhost/\" + Demo.class.getName() + \"?loadbalance=roundrobin&retries=\" + retries);\r\n    RpcException exception = new RpcException(RpcException.TIMEOUT_EXCEPTION);\r\n    MockInvoker<Demo> invoker1 = new MockInvoker<Demo>(Demo.class, url);\r\n    invoker1.setException(exception);\r\n    MockInvoker<Demo> invoker2 = new MockInvoker<Demo>(Demo.class, url);\r\n    invoker2.setException(exception);\r\n    final List<Invoker<Demo>> invokers = new ArrayList<Invoker<Demo>>();\r\n    invokers.add(invoker1);\r\n    invokers.add(invoker2);\r\n    Callable<Object> callable = new Callable<Object>() {\r\n        public Object call() throws Exception {\r\n            for (Invoker<Demo> invoker : invokers) {\r\n                invoker.destroy();\r\n            }\r\n            invokers.clear();\r\n            MockInvoker<Demo> invoker3 = new MockInvoker<Demo>(Demo.class, url);\r\n            invokers.add(invoker3);\r\n            return null;\r\n        }\r\n    };\r\n    invoker1.setCallable(callable);\r\n    invoker2.setCallable(callable);\r\n    RpcInvocation inv = new RpcInvocation();\r\n    inv.setMethodName(\"test\");\r\n    Directory<Demo> dic = new MockDirectory<Demo>(url, invokers);\r\n    FailoverClusterInvoker<Demo> clusterinvoker = new FailoverClusterInvoker<Demo>(dic);\r\n    clusterinvoker.invoke(inv);\r\n}"
}, {
	"Path": "org.apache.dubbo.rpc.cluster.support.FailoverClusterInvokerTest.testInvokerDestroyAndReList",
	"Comment": "when invokers in directory changes after a failed request but just before a retry effort,then we should reselect from the latest invokers before retry.",
	"Method": "void testInvokerDestroyAndReList(){\r\n    for (Invoker<Demo> invoker : invokers) {\r\n        invoker.destroy();\r\n    }\r\n    invokers.clear();\r\n    MockInvoker<Demo> invoker3 = new MockInvoker<Demo>(Demo.class, url);\r\n    invokers.add(invoker3);\r\n    return null;\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableRangeMap.of",
	"Comment": "returns an immutable range map mapping a single range to a single value.",
	"Method": "ImmutableRangeMap<K, V> of(ImmutableRangeMap<K, V> of,Range<K> range,V value){\r\n    return new ImmutableRangeMap(ImmutableList.of(range), ImmutableList.of(value));\r\n}"
}, {
	"Path": "com.google.inject.internal.ConstructorBindingImpl.isInitialized",
	"Comment": "true if this binding has been initialized and is ready for use.",
	"Method": "boolean isInitialized(){\r\n    return factory.constructorInjector != null;\r\n}"
}, {
	"Path": "com.google.inject.servlet.ServletUtils.normalizePath",
	"Comment": "normalizes a path by unescaping all safe, percent encoded characters.",
	"Method": "String normalizePath(String path){\r\n    StringBuilder sb = new StringBuilder(path.length());\r\n    int queryStart = path.indexOf('?');\r\n    String query = null;\r\n    if (queryStart != -1) {\r\n        query = path.substring(queryStart);\r\n        path = path.substring(0, queryStart);\r\n    }\r\n    List<String> segments = new ArrayList();\r\n    for (String segment : SLASH_SPLITTER.split(path)) {\r\n        String normalized = UrlEscapers.urlPathSegmentEscaper().escape(lenientDecode(segment, UTF_8, false));\r\n        if (\".\".equals(normalized)) {\r\n        } else if (\"..\".equals(normalized)) {\r\n            if (segments.size() > 1) {\r\n                segments.remove(segments.size() - 1);\r\n            }\r\n        } else {\r\n            segments.add(normalized);\r\n        }\r\n    }\r\n    SLASH_JOINER.appendTo(sb, segments);\r\n    if (query != null) {\r\n        sb.append(query);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.google.common.collect.LinkedHashMultimap.keySet",
	"Comment": "returns a view collection of all distinct keys contained in this multimap. note that thekey set contains a key if and only if this multimap maps that key to at least one value.the iterator generated by the returned set traverses the keys in the order they were firstadded to the multimap.changes to the returned set will update the underlying multimap, and vice versa. however,adding to the returned set is not possible.",
	"Method": "Set<K> keySet(){\r\n    return super.keySet();\r\n}"
}, {
	"Path": "com.google.common.cache.CacheLoadingTest.testLoadingExceptionWithCause",
	"Comment": "make sure loadingcache correctly wraps executionexceptions and uncheckedexecutionexceptions.",
	"Method": "void testLoadingExceptionWithCause(){\r\n    final Exception cause = new Exception();\r\n    final UncheckedExecutionException uee = new UncheckedExecutionException(cause);\r\n    final ExecutionException ee = new ExecutionException(cause);\r\n    LoadingCache<Object, Object> cacheUnchecked = CacheBuilder.newBuilder().build(exceptionLoader(uee));\r\n    LoadingCache<Object, Object> cacheChecked = CacheBuilder.newBuilder().build(exceptionLoader(ee));\r\n    try {\r\n        cacheUnchecked.get(new Object());\r\n        fail();\r\n    } catch (ExecutionException e) {\r\n        fail();\r\n    } catch (UncheckedExecutionException caughtEe) {\r\n        assertThat(caughtEe).hasCauseThat().isSameAs(uee);\r\n    }\r\n    try {\r\n        cacheUnchecked.getUnchecked(new Object());\r\n        fail();\r\n    } catch (UncheckedExecutionException caughtUee) {\r\n        assertThat(caughtUee).hasCauseThat().isSameAs(uee);\r\n    }\r\n    cacheUnchecked.refresh(new Object());\r\n    checkLoggedCause(uee);\r\n    try {\r\n        cacheUnchecked.getAll(asList(new Object()));\r\n        fail();\r\n    } catch (ExecutionException e) {\r\n        fail();\r\n    } catch (UncheckedExecutionException caughtEe) {\r\n        assertThat(caughtEe).hasCauseThat().isSameAs(uee);\r\n    }\r\n    try {\r\n        cacheChecked.get(new Object());\r\n        fail();\r\n    } catch (ExecutionException caughtEe) {\r\n        assertThat(caughtEe).hasCauseThat().isSameAs(ee);\r\n    }\r\n    try {\r\n        cacheChecked.getUnchecked(new Object());\r\n        fail();\r\n    } catch (UncheckedExecutionException caughtUee) {\r\n        assertThat(caughtUee).hasCauseThat().isSameAs(ee);\r\n    }\r\n    cacheChecked.refresh(new Object());\r\n    checkLoggedCause(ee);\r\n    try {\r\n        cacheChecked.getAll(asList(new Object()));\r\n        fail();\r\n    } catch (ExecutionException caughtEe) {\r\n        assertThat(caughtEe).hasCauseThat().isSameAs(ee);\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMap.copyOf",
	"Comment": "returns an immutable map containing the specified entries. the returned map iterates overentries in the same order as the original iterable.",
	"Method": "ImmutableMap<K, V> copyOf(Map<? extends K, ? extends V> map,ImmutableMap<K, V> copyOf,Iterable<? extends Entry<? extends K, ? extends V>> entries){\r\n    if (entries instanceof Collection) {\r\n        return fromEntryList((Collection<? extends Entry<? extends K, ? extends V>>) entries);\r\n    } else {\r\n        return fromEntryList(Lists.newArrayList(entries.iterator()));\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.SetsTest.testCartesianProduct_unary",
	"Comment": "a unary cartesian product is one list of size 1 for each element in the input set.",
	"Method": "void testCartesianProduct_unary(){\r\n    assertThat(Sets.cartesianProduct(set(1, 2))).containsExactly(list(1), list(2));\r\n}"
}, {
	"Path": "com.google.common.collect.HashBiMap.create",
	"Comment": "constructs a new, empty bimap with the specified expected size.",
	"Method": "HashBiMap<K, V> create(HashBiMap<K, V> create,int expectedSize,HashBiMap<K, V> create,Map<? extends K, ? extends V> map){\r\n    HashBiMap<K, V> bimap = create(map.size());\r\n    bimap.putAll(map);\r\n    return bimap;\r\n}"
}, {
	"Path": "com.google.inject.internal.MapBinderTest.testWeakKeySet_integration_mapbinder",
	"Comment": "tests for com.google.inject.internal.weakkeyset not leaking memory.",
	"Method": "void testWeakKeySet_integration_mapbinder(){\r\n    Key<Map<String, String>> mapKey = Key.get(new TypeLiteral<Map<String, String>>() {\r\n    });\r\n    Injector parentInjector = Guice.createInjector(new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            bind(String.class).toInstance(\"hi\");\r\n        }\r\n    });\r\n    WeakKeySetUtils.assertNotBlacklisted(parentInjector, mapKey);\r\n    Injector childInjector = parentInjector.createChildInjector(new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            MapBinder<String, String> binder = MapBinder.newMapBinder(binder(), String.class, String.class);\r\n            binder.addBinding(\"bar\").toInstance(\"foo\");\r\n        }\r\n    });\r\n    WeakReference<Injector> weakRef = new WeakReference(childInjector);\r\n    WeakKeySetUtils.assertBlacklisted(parentInjector, mapKey);\r\n    childInjector = null;\r\n    Asserts.awaitClear(weakRef);\r\n    WeakKeySetUtils.assertNotBlacklisted(parentInjector, mapKey);\r\n}"
}, {
	"Path": "com.google.inject.internal.MapBinderTest.testWeakKeySet_integration_mapbinder",
	"Comment": "tests for com.google.inject.internal.weakkeyset not leaking memory.",
	"Method": "void testWeakKeySet_integration_mapbinder(){\r\n    bind(String.class).toInstance(\"hi\");\r\n}"
}, {
	"Path": "com.google.inject.internal.MapBinderTest.testWeakKeySet_integration_mapbinder",
	"Comment": "tests for com.google.inject.internal.weakkeyset not leaking memory.",
	"Method": "void testWeakKeySet_integration_mapbinder(){\r\n    MapBinder<String, String> binder = MapBinder.newMapBinder(binder(), String.class, String.class);\r\n    binder.addBinding(\"bar\").toInstance(\"foo\");\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.ThreadFactoryBuilder.setPriority",
	"Comment": "sets the priority for new threads created with this threadfactory.",
	"Method": "ThreadFactoryBuilder setPriority(int priority){\r\n    checkArgument(priority >= Thread.MIN_PRIORITY, \"Thread priority (%s) must be >= %s\", priority, Thread.MIN_PRIORITY);\r\n    checkArgument(priority <= Thread.MAX_PRIORITY, \"Thread priority (%s) must be <= %s\", priority, Thread.MAX_PRIORITY);\r\n    this.priority = priority;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.common.primitives.ImmutableDoubleArray.of",
	"Comment": "returns an immutable array containing the given values, in order.",
	"Method": "ImmutableDoubleArray of(ImmutableDoubleArray of,double e0,ImmutableDoubleArray of,double e0,double e1,ImmutableDoubleArray of,double e0,double e1,double e2,ImmutableDoubleArray of,double e0,double e1,double e2,double e3,ImmutableDoubleArray of,double e0,double e1,double e2,double e3,double e4,ImmutableDoubleArray of,double e0,double e1,double e2,double e3,double e4,double e5,ImmutableDoubleArray of,double first,double rest){\r\n    checkArgument(rest.length <= Integer.MAX_VALUE - 1, \"the total number of elements must fit in an int\");\r\n    double[] array = new double[rest.length + 1];\r\n    array[0] = first;\r\n    System.arraycopy(rest, 0, array, 1, rest.length);\r\n    return new ImmutableDoubleArray(array);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultimap.clear",
	"Comment": "guaranteed to throw an exception and leave the multimap unmodified.",
	"Method": "void clear(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.inject.MembersInjectorTest.testRecursiveMemberInjector",
	"Comment": "verifies that member injection injecting itself would get a non initialized instance.",
	"Method": "void testRecursiveMemberInjector(){\r\n    final RecursiveMemberInjection rmi = new RecursiveMemberInjection();\r\n    Guice.createInjector(new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            bind(RecursiveMemberInjection.class).toInstance(rmi);\r\n        }\r\n    });\r\n    assertTrue(\"Member injection should happen\", rmi.called);\r\n}"
}, {
	"Path": "com.google.inject.MembersInjectorTest.testRecursiveMemberInjector",
	"Comment": "verifies that member injection injecting itself would get a non initialized instance.",
	"Method": "void testRecursiveMemberInjector(){\r\n    bind(RecursiveMemberInjection.class).toInstance(rmi);\r\n}"
}, {
	"Path": "com.google.common.collect.MapMakerInternalMap.segmentFor",
	"Comment": "returns the segment that should be used for a key with the given hash.",
	"Method": "Segment<K, V, E, S> segmentFor(int hash){\r\n    return segments[(hash >>> segmentShift) & segmentMask];\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.MonitorBasedPriorityBlockingQueue.clear",
	"Comment": "atomically removes all of the elements from this queue. the queue will be empty after this callreturns.",
	"Method": "void clear(){\r\n    final Monitor monitor = this.monitor;\r\n    monitor.enter();\r\n    try {\r\n        q.clear();\r\n    } finally {\r\n        monitor.leave();\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.UnmodifiableIterator.remove",
	"Comment": "guaranteed to throw an exception and leave the underlying data unmodified.",
	"Method": "void remove(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.inject.internal.BytecodeGen.hasSameVersionOfCglib",
	"Comment": "returns true if the types classloader has the same version of cglib that bytecodegen has. thisonly returns false in strange osgi situations, but it prevents us from using fastclass for nonpublic members.",
	"Method": "boolean hasSameVersionOfCglib(ClassLoader classLoader){\r\n    Class<?> fc = net.sf.cglib.reflect.FastClass.class;\r\n    try {\r\n        return classLoader.loadClass(fc.getName()) == fc;\r\n    } catch (ClassNotFoundException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.google.common.cache.LocalCache.getEntry",
	"Comment": "returns the internal entry for the specified key. the entry may be loading, expired, orpartially collected.",
	"Method": "ReferenceEntry<K, V> getEntry(ReferenceEntry<K, V> getEntry,ReferenceEntry<K, V> getEntry,ReferenceEntry<K, V> getEntry,ReferenceEntry<K, V> getEntry,Object key,int hash,ReferenceEntry<K, V> getEntry,ReferenceEntry<K, V> getEntry,Object key){\r\n    if (key == null) {\r\n        return null;\r\n    }\r\n    int hash = hash(key);\r\n    return segmentFor(hash).getEntry(key, hash);\r\n}"
}, {
	"Path": "com.google.common.collect.AbstractMapBasedMultimap.wrapCollection",
	"Comment": "generates a decorated collection that remains consistent with the values in the multimap forthe provided key. changes to the multimap may alter the returned collection, and vice versa.",
	"Method": "Collection<V> wrapCollection(K key,Collection<V> collection){\r\n    return new WrappedCollection(key, collection, null);\r\n}"
}, {
	"Path": "com.google.common.collect.testing.FeatureSpecificTestSuiteBuilder.named",
	"Comment": "configures this builder produce a testsuite with the given name.",
	"Method": "B named(String name){\r\n    if (name.contains(\"(\")) {\r\n        throw new IllegalArgumentException(\"Eclipse hides all characters after \" + \"'('; please use '[]' or other characters instead of parentheses\");\r\n    }\r\n    this.name = name;\r\n    return self();\r\n}"
}, {
	"Path": "com.google.common.testing.EquivalenceTester.test",
	"Comment": "run tests on equivalence methods, throwing a failure on an invalid test",
	"Method": "EquivalenceTester<T> test(){\r\n    for (int run = 0; run < REPETITIONS; run++) {\r\n        testItems();\r\n        delegate.test();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMap.replaceAll",
	"Comment": "guaranteed to throw an exception and leave the map unmodified.",
	"Method": "void replaceAll(BiFunction<? super K, ? super V, ? extends V> function){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.net.MediaType.charset",
	"Comment": "returns an optional charset for the value of the charset parameter if it is specified.",
	"Method": "Optional<Charset> charset(){\r\n    Optional<Charset> local = parsedCharset;\r\n    if (local == null) {\r\n        String value = null;\r\n        local = Optional.absent();\r\n        for (String currentValue : parameters.get(CHARSET_ATTRIBUTE)) {\r\n            if (value == null) {\r\n                value = currentValue;\r\n                local = Optional.of(Charset.forName(value));\r\n            } else if (!value.equals(currentValue)) {\r\n                throw new IllegalStateException(\"Multiple charset values defined: \" + value + \", \" + currentValue);\r\n            }\r\n        }\r\n        parsedCharset = local;\r\n    }\r\n    return local;\r\n}"
}, {
	"Path": "com.google.common.collect.TreeMultimapNaturalTest.testCreateFromSortedSetMultimap",
	"Comment": "test that creating one treemultimap from a sortedsetmultimap uses natural ordering.",
	"Method": "void testCreateFromSortedSetMultimap(){\r\n    SortedSetMultimap<Double, Double> tree = TreeMultimap.create(KEY_COMPARATOR, VALUE_COMPARATOR);\r\n    tree.put(1.0, 2.0);\r\n    tree.put(2.0, 3.0);\r\n    tree.put(3.0, 4.0);\r\n    tree.put(4.0, 5.0);\r\n    SortedSetMultimap<Double, Double> sorted = Multimaps.unmodifiableSortedSetMultimap(tree);\r\n    TreeMultimap<Double, Double> copyFromSorted = TreeMultimap.create(sorted);\r\n    assertEquals(tree, copyFromSorted);\r\n    assertSame(Ordering.natural(), copyFromSorted.keyComparator());\r\n    assertSame(Ordering.natural(), copyFromSorted.valueComparator());\r\n    assertSame(Ordering.natural(), copyFromSorted.get(1.0).comparator());\r\n}"
}, {
	"Path": "com.google.thirdparty.publicsuffix.TrieParser.parseTrie",
	"Comment": "parses a serialized trie representation of a map of reversed public suffixes into an immutablemap of public suffixes.",
	"Method": "ImmutableMap<String, PublicSuffixType> parseTrie(CharSequence encoded){\r\n    ImmutableMap.Builder<String, PublicSuffixType> builder = ImmutableMap.builder();\r\n    int encodedLen = encoded.length();\r\n    int idx = 0;\r\n    while (idx < encodedLen) {\r\n        idx += doParseTrieToBuilder(Lists.<CharSequence>newLinkedList(), encoded, idx, builder);\r\n    }\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.google.inject.throwingproviders.CheckedProviderMethodsModule.forModule",
	"Comment": "returns a module which creates bindings for provider methods from the given module.",
	"Method": "Module forModule(Module module){\r\n    if (module instanceof CheckedProviderMethodsModule) {\r\n        return Modules.EMPTY_MODULE;\r\n    }\r\n    return new CheckedProviderMethodsModule(module);\r\n}"
}, {
	"Path": "com.google.common.collect.CompactHashSet.resizeEntries",
	"Comment": "resizes the internal entries array to the specified capacity, which may be greater or less thanthe current capacity.",
	"Method": "void resizeEntries(int newCapacity){\r\n    this.elements = Arrays.copyOf(elements, newCapacity);\r\n    long[] entries = this.entries;\r\n    int oldSize = entries.length;\r\n    entries = Arrays.copyOf(entries, newCapacity);\r\n    if (newCapacity > oldSize) {\r\n        Arrays.fill(entries, oldSize, newCapacity, UNSET);\r\n    }\r\n    this.entries = entries;\r\n}"
}, {
	"Path": "com.google.common.io.CharSequenceReaderTest.assertReadsCorrectly",
	"Comment": "creates a charsequencereader wrapping the given charsequence and tests that the reader producesthe same sequence when read using each type of read method it provides.",
	"Method": "void assertReadsCorrectly(CharSequence charSequence){\r\n    String expected = charSequence.toString();\r\n    CharSequenceReader reader = new CharSequenceReader(charSequence);\r\n    for (int i = 0; i < expected.length(); i++) {\r\n        assertEquals(expected.charAt(i), reader.read());\r\n    }\r\n    assertFullyRead(reader);\r\n    reader = new CharSequenceReader(charSequence);\r\n    char[] buf = new char[expected.length()];\r\n    assertEquals(expected.length() == 0 ? -1 : expected.length(), reader.read(buf));\r\n    assertEquals(expected, new String(buf));\r\n    assertFullyRead(reader);\r\n    reader = new CharSequenceReader(charSequence);\r\n    buf = new char[5];\r\n    StringBuilder builder = new StringBuilder();\r\n    int read;\r\n    while ((read = reader.read(buf, 0, buf.length)) != -1) {\r\n        builder.append(buf, 0, read);\r\n    }\r\n    assertEquals(expected, builder.toString());\r\n    assertFullyRead(reader);\r\n    reader = new CharSequenceReader(charSequence);\r\n    CharBuffer buf2 = CharBuffer.allocate(expected.length());\r\n    assertEquals(expected.length() == 0 ? -1 : expected.length(), reader.read(buf2));\r\n    buf2.flip();\r\n    assertEquals(expected, buf2.toString());\r\n    assertFullyRead(reader);\r\n    reader = new CharSequenceReader(charSequence);\r\n    buf2 = CharBuffer.allocate(5);\r\n    builder = new StringBuilder();\r\n    while (reader.read(buf2) != -1) {\r\n        buf2.flip();\r\n        builder.append(buf2);\r\n        buf2.clear();\r\n    }\r\n    assertEquals(expected, builder.toString());\r\n    assertFullyRead(reader);\r\n    reader = new CharSequenceReader(charSequence);\r\n    assertEquals(expected.length(), reader.skip(Long.MAX_VALUE));\r\n    assertFullyRead(reader);\r\n    if (expected.length() > 5) {\r\n        reader = new CharSequenceReader(charSequence);\r\n        assertEquals(5, reader.skip(5));\r\n        buf = new char[expected.length() - 5];\r\n        assertEquals(buf.length, reader.read(buf, 0, buf.length));\r\n        assertEquals(expected.substring(5), new String(buf));\r\n        assertFullyRead(reader);\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.servlet.FilterChainInvocation.findNextFilter",
	"Comment": "iterates over the remaining filter definitions. returns the first applicable filter, or null ifnone apply.",
	"Method": "Filter findNextFilter(HttpServletRequest request){\r\n    while (++index < filterDefinitions.length) {\r\n        Filter filter = filterDefinitions[index].getFilterIfMatching(request);\r\n        if (filter != null) {\r\n            return filter;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.common.collect.LinkedHashMultimap.values",
	"Comment": "returns a collection of all values in the multimap. changes to the returned collection willupdate the underlying multimap, and vice versa.the iterator generated by the returned collection traverses the values in the order theywere added to the multimap.",
	"Method": "Collection<V> values(){\r\n    return super.values();\r\n}"
}, {
	"Path": "com.google.common.io.ReaderInputStream.grow",
	"Comment": "returns a new charbuffer identical to buf, except twice the capacity.",
	"Method": "CharBuffer grow(CharBuffer buf){\r\n    char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);\r\n    CharBuffer bigger = CharBuffer.wrap(copy);\r\n    bigger.position(buf.position());\r\n    bigger.limit(buf.limit());\r\n    return bigger;\r\n}"
}, {
	"Path": "com.google.common.cache.CacheTesting.simulateKeyReclamation",
	"Comment": "poke into the cache internals to simulate garbage collection of the given key. this assumesthat the given entry is a weak or soft reference, and throws an illegalstateexception if thatassumption does not hold.",
	"Method": "void simulateKeyReclamation(Cache<K, V> cache,K key){\r\n    ReferenceEntry<K, V> entry = getReferenceEntry(cache, key);\r\n    Preconditions.checkState(entry instanceof Reference);\r\n    Reference<?> ref = (Reference<?>) entry;\r\n    if (ref != null) {\r\n        ref.clear();\r\n    }\r\n}"
}, {
	"Path": "com.google.common.math.IntMathTest.computeMeanSafely",
	"Comment": "computes the mean in a way that is obvious and resilient to overflow by using bigintegerarithmetic.",
	"Method": "int computeMeanSafely(int x,int y){\r\n    BigInteger bigX = BigInteger.valueOf(x);\r\n    BigInteger bigY = BigInteger.valueOf(y);\r\n    BigDecimal bigMean = new BigDecimal(bigX.add(bigY)).divide(BigDecimal.valueOf(2), BigDecimal.ROUND_FLOOR);\r\n    return Integer.parseInt(bigMean.toString());\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableList.replaceAll",
	"Comment": "guaranteed to throw an exception and leave the list unmodified.",
	"Method": "void replaceAll(UnaryOperator<E> operator){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSortedMap.reverseOrder",
	"Comment": "returns a builder that creates immutable sorted maps whose keys are ordered by the reverse oftheir natural ordering.",
	"Method": "Builder<K, V> reverseOrder(){\r\n    return new Builder<K, V>(Ordering.natural().reverse());\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.beginWaitingFor",
	"Comment": "records that the current thread is about to wait on the specified guard.",
	"Method": "void beginWaitingFor(Guard guard){\r\n    int waiters = guard.waiterCount++;\r\n    if (waiters == 0) {\r\n        guard.next = activeGuards;\r\n        activeGuards = guard;\r\n    }\r\n}"
}, {
	"Path": "com.google.common.primitives.ImmutableDoubleArray.copyOf",
	"Comment": "returns an immutable array containing the given values, in order.",
	"Method": "ImmutableDoubleArray copyOf(double[] values,ImmutableDoubleArray copyOf,Collection<Double> values,ImmutableDoubleArray copyOf,Iterable<Double> values,ImmutableDoubleArray copyOf,DoubleStream stream){\r\n    double[] array = stream.toArray();\r\n    return (array.length == 0) ? EMPTY : new ImmutableDoubleArray(array);\r\n}"
}, {
	"Path": "com.google.common.graph.ElementOrder.natural",
	"Comment": "returns an instance which specifies that the natural ordering of the elements is guaranteed.",
	"Method": "ElementOrder<S> natural(){\r\n    return new ElementOrder<S>(Type.SORTED, Ordering.<S>natural());\r\n}"
}, {
	"Path": "com.google.common.collect.testing.MinimalIterable.from",
	"Comment": "returns an iterable whose iterator returns the given elements in order. the elements are copiedout of the source collection at the time this method is called.",
	"Method": "MinimalIterable<E> from(Collection<E> elements){\r\n    return (MinimalIterable) of(elements.toArray());\r\n}"
}, {
	"Path": "org.apache.dubbo.common.threadlocal.InternalThread.threadLocalMap",
	"Comment": "returns the internal data structure that keeps the threadlocal variables bound to this thread.note that this method is for internal use only, and thus is subject to change at any time.",
	"Method": "InternalThreadLocalMap threadLocalMap(){\r\n    return threadLocalMap;\r\n}"
}, {
	"Path": "com.google.common.testing.EqualsTester.testEquals",
	"Comment": "run tests on equals method, throwing a failure on an invalid test",
	"Method": "EqualsTester testEquals(){\r\n    RelationshipTester<Object> delegate = new RelationshipTester(Equivalence.equals(), \"Object#equals\", \"Object#hashCode\", itemReporter);\r\n    for (List<Object> group : equalityGroups) {\r\n        delegate.addRelatedGroup(group);\r\n    }\r\n    for (int run = 0; run < REPETITIONS; run++) {\r\n        testItems();\r\n        delegate.test();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.awaitNanos",
	"Comment": "caller should check before calling that guard is not satisfied.",
	"Method": "boolean awaitNanos(Guard guard,long nanos,boolean signalBeforeWaiting){\r\n    boolean firstTime = true;\r\n    try {\r\n        do {\r\n            if (nanos <= 0L) {\r\n                return false;\r\n            }\r\n            if (firstTime) {\r\n                if (signalBeforeWaiting) {\r\n                    signalNextWaiter();\r\n                }\r\n                beginWaitingFor(guard);\r\n                firstTime = false;\r\n            }\r\n            nanos = guard.condition.awaitNanos(nanos);\r\n        } while (!guard.isSatisfied());\r\n        return true;\r\n    } finally {\r\n        if (!firstTime) {\r\n            endWaitingFor(guard);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.zaxxer.hikari.pool.HikariPool.checkFailFast",
	"Comment": "if initializationfailfast is configured, check that we have db connectivity.",
	"Method": "void checkFailFast(){\r\n    final long initializationTimeout = config.getInitializationFailTimeout();\r\n    if (initializationTimeout < 0) {\r\n        return;\r\n    }\r\n    final long startTime = currentTime();\r\n    do {\r\n        final PoolEntry poolEntry = createPoolEntry();\r\n        if (poolEntry != null) {\r\n            if (config.getMinimumIdle() > 0) {\r\n                connectionBag.add(poolEntry);\r\n                logger.debug(\"{} - Added connection {}\", poolName, poolEntry.connection);\r\n            } else {\r\n                quietlyCloseConnection(poolEntry.close(), \"(initialization check complete and minimumIdle is zero)\");\r\n            }\r\n            return;\r\n        }\r\n        if (getLastConnectionFailure() instanceof ConnectionSetupException) {\r\n            throwPoolInitializationException(getLastConnectionFailure().getCause());\r\n        }\r\n        quietlySleep(SECONDS.toMillis(1));\r\n    } while (elapsedMillis(startTime) < initializationTimeout);\r\n    if (initializationTimeout > 0) {\r\n        throwPoolInitializationException(getLastConnectionFailure());\r\n    }\r\n}"
}, {
	"Path": "com.google.common.hash.FarmHashFingerprint64Test.fingerprint",
	"Comment": "convenience method to compute a fingerprint on a subset of a byte array.",
	"Method": "long fingerprint(byte[] bytes,long fingerprint,byte[] bytes,int length){\r\n    return HASH_FN.hashBytes(bytes, 0, length).asLong();\r\n}"
}, {
	"Path": "com.google.common.primitives.ImmutableIntArray.of",
	"Comment": "returns an immutable array containing the given values, in order.",
	"Method": "ImmutableIntArray of(ImmutableIntArray of,int e0,ImmutableIntArray of,int e0,int e1,ImmutableIntArray of,int e0,int e1,int e2,ImmutableIntArray of,int e0,int e1,int e2,int e3,ImmutableIntArray of,int e0,int e1,int e2,int e3,int e4,ImmutableIntArray of,int e0,int e1,int e2,int e3,int e4,int e5,ImmutableIntArray of,int first,int rest){\r\n    checkArgument(rest.length <= Integer.MAX_VALUE - 1, \"the total number of elements must fit in an int\");\r\n    int[] array = new int[rest.length + 1];\r\n    array[0] = first;\r\n    System.arraycopy(rest, 0, array, 1, rest.length);\r\n    return new ImmutableIntArray(array);\r\n}"
}, {
	"Path": "com.google.common.base.CharMatcher.ascii",
	"Comment": "determines whether a character is ascii, meaning that its code point is less than 128.",
	"Method": "CharMatcher ascii(){\r\n    return Ascii.INSTANCE;\r\n}"
}, {
	"Path": "com.google.inject.internal.InjectorImpl.createUninitializedBinding",
	"Comment": "creates a binding for an injectable type with the given scope. looks for a scope on the type ifnone is specified.",
	"Method": "BindingImpl<T> createUninitializedBinding(Key<T> key,Scoping scoping,Object source,Errors errors,boolean jitBinding){\r\n    Class<?> rawType = key.getTypeLiteral().getRawType();\r\n    ImplementedBy implementedBy = rawType.getAnnotation(ImplementedBy.class);\r\n    if (rawType.isArray() || (rawType.isEnum() && implementedBy != null)) {\r\n        throw errors.missingImplementationWithHint(key, this).toException();\r\n    }\r\n    if (rawType == TypeLiteral.class) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        BindingImpl<T> binding = (BindingImpl<T>) createTypeLiteralBinding((Key<TypeLiteral<Object>>) key, errors);\r\n        return binding;\r\n    }\r\n    if (implementedBy != null) {\r\n        Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors);\r\n        return createImplementedByBinding(key, scoping, implementedBy, errors);\r\n    }\r\n    ProvidedBy providedBy = rawType.getAnnotation(ProvidedBy.class);\r\n    if (providedBy != null) {\r\n        Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors);\r\n        return createProvidedByBinding(key, scoping, providedBy, errors);\r\n    }\r\n    return ConstructorBindingImpl.create(this, key, null, source, scoping, errors, jitBinding && options.jitDisabled, options.atInjectRequired);\r\n}"
}, {
	"Path": "com.google.common.collect.testing.FeatureSpecificTestSuiteBuilder.withFeatures",
	"Comment": "configures this builder to produce tests appropriate for the given features. this method may becalled more than once to add features in multiple groups.",
	"Method": "B withFeatures(Feature<?> features,B withFeatures,Iterable<? extends Feature<?>> features){\r\n    for (Feature<?> feature : features) {\r\n        this.features.add(feature);\r\n    }\r\n    return self();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.ServiceTest.testStateOrdering",
	"Comment": "assert on the comparison ordering of the state enum since we guarantee it.",
	"Method": "void testStateOrdering(){\r\n    assertLessThan(NEW, STARTING);\r\n    assertLessThan(NEW, TERMINATED);\r\n    assertLessThan(STARTING, RUNNING);\r\n    assertLessThan(STARTING, STOPPING);\r\n    assertLessThan(STARTING, FAILED);\r\n    assertLessThan(RUNNING, STOPPING);\r\n    assertLessThan(RUNNING, FAILED);\r\n    assertLessThan(STOPPING, FAILED);\r\n    assertLessThan(STOPPING, TERMINATED);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.getOccupiedDepth",
	"Comment": "returns the number of times the current thread has entered this monitor in excess of the numberof times it has left. returns 0 if the current thread is not occupying this monitor.",
	"Method": "int getOccupiedDepth(){\r\n    return lock.getHoldCount();\r\n}"
}, {
	"Path": "org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance.getInvokerAddrList",
	"Comment": "get invoker addr list cached for specified invocationfor unit test only",
	"Method": "Collection<String> getInvokerAddrList(List<Invoker<T>> invokers,Invocation invocation){\r\n    String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\r\n    Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);\r\n    if (map != null) {\r\n        return map.keySet();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AtomicDoubleArrayTest.testConstructorZeroLength",
	"Comment": "constructor with length zero has size 0 and contains no elements",
	"Method": "void testConstructorZeroLength(){\r\n    AtomicDoubleArray aa = new AtomicDoubleArray(0);\r\n    assertEquals(0, aa.length());\r\n    try {\r\n        aa.get(0);\r\n        fail();\r\n    } catch (IndexOutOfBoundsException success) {\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.JSR166TestCase.timeoutMillis",
	"Comment": "returns a timeout in milliseconds to be used in tests that verify that operations block or timeout.",
	"Method": "long timeoutMillis(){\r\n    return SHORT_DELAY_MS / 4;\r\n}"
}, {
	"Path": "com.google.common.net.MediaType.parameters",
	"Comment": "returns a multimap containing the parameters of this media type.",
	"Method": "ImmutableListMultimap<String, String> parameters(){\r\n    return parameters;\r\n}"
}, {
	"Path": "com.google.inject.Guice.createInjector",
	"Comment": "creates an injector for the given set of modules, in a given development stage.",
	"Method": "Injector createInjector(Module modules,Injector createInjector,Iterable<? extends Module> modules,Injector createInjector,Stage stage,Module modules,Injector createInjector,Stage stage,Iterable<? extends Module> modules){\r\n    return new InternalInjectorCreator().stage(stage).addModules(modules).build();\r\n}"
}, {
	"Path": "com.google.common.escape.ArrayBasedEscaperMap.create",
	"Comment": "returns a new arraybasedescapermap for creating arraybasedcharescaper orarraybasedunicodeescaper instances.",
	"Method": "ArrayBasedEscaperMap create(Map<Character, String> replacements){\r\n    return new ArrayBasedEscaperMap(createReplacementArray(replacements));\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableCollection.removeIf",
	"Comment": "guaranteed to throw an exception and leave the collection unmodified.",
	"Method": "boolean removeIf(Predicate<? super E> filter){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.inject.internal.SpiUtils.assertOptionalVisitor",
	"Comment": "asserts that optionalbinderbinding visitors for work correctly.",
	"Method": "void assertOptionalVisitor(Key<T> keyType,Iterable<? extends Module> modules,VisitType visitType,int expectedOtherOptionalBindings,BindResult<?> expectedDefault,BindResult<?> expectedActual,BindResult<?> expectedUserLinkedActual){\r\n    if (visitType == null) {\r\n        fail(\"must test something\");\r\n    }\r\n    if (HAS_JAVA_OPTIONAL) {\r\n        expectedOtherOptionalBindings *= 2;\r\n    }\r\n    if (visitType == BOTH || visitType == INJECTOR) {\r\n        optionalInjectorTest(keyType, modules, expectedOtherOptionalBindings, expectedDefault, expectedActual, expectedUserLinkedActual);\r\n    }\r\n    if (visitType == BOTH || visitType == MODULE) {\r\n        optionalModuleTest(keyType, modules, expectedOtherOptionalBindings, expectedDefault, expectedActual, expectedUserLinkedActual);\r\n    }\r\n}"
}, {
	"Path": "com.google.common.io.Files.touch",
	"Comment": "creates an empty file or updates the last updated timestamp on the same as the unix command ofthe same name.",
	"Method": "void touch(File file){\r\n    checkNotNull(file);\r\n    if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis())) {\r\n        throw new IOException(\"Unable to update modification time of \" + file);\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.GeneralRange.upTo",
	"Comment": "returns everything below the endpoint relative to the specified comparator, with the specifiedendpoint behavior.",
	"Method": "GeneralRange<T> upTo(Comparator<? super T> comparator,T endpoint,BoundType boundType){\r\n    return new GeneralRange<T>(comparator, false, null, OPEN, true, endpoint, boundType);\r\n}"
}, {
	"Path": "com.google.common.collect.MapMaker.toString",
	"Comment": "returns a string representation for this mapmaker instance. the exact form of the returnedstring is not specified.",
	"Method": "String toString(){\r\n    MoreObjects.ToStringHelper s = MoreObjects.toStringHelper(this);\r\n    if (initialCapacity != UNSET_INT) {\r\n        s.add(\"initialCapacity\", initialCapacity);\r\n    }\r\n    if (concurrencyLevel != UNSET_INT) {\r\n        s.add(\"concurrencyLevel\", concurrencyLevel);\r\n    }\r\n    if (keyStrength != null) {\r\n        s.add(\"keyStrength\", Ascii.toLowerCase(keyStrength.toString()));\r\n    }\r\n    if (valueStrength != null) {\r\n        s.add(\"valueStrength\", Ascii.toLowerCase(valueStrength.toString()));\r\n    }\r\n    if (keyEquivalence != null) {\r\n        s.addValue(\"keyEquivalence\");\r\n    }\r\n    return s.toString();\r\n}"
}, {
	"Path": "com.google.inject.internal.InjectorImpl.getInternalDependencies",
	"Comment": "safely gets the dependencies of possibly not initialized bindings.",
	"Method": "Set<Dependency<?>> getInternalDependencies(BindingImpl<?> binding){\r\n    if (binding instanceof ConstructorBindingImpl) {\r\n        return ((ConstructorBindingImpl) binding).getInternalDependencies();\r\n    } else if (binding instanceof HasDependencies) {\r\n        return ((HasDependencies) binding).getDependencies();\r\n    } else {\r\n        return ImmutableSet.of();\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.assistedinject.FactoryProvider2.isTypeNotSpecified",
	"Comment": "returns true if the configurationexception is due to an error of typeliteral not being fullyspecified.",
	"Method": "boolean isTypeNotSpecified(TypeLiteral<?> typeLiteral,ConfigurationException ce){\r\n    Collection<Message> messages = ce.getErrorMessages();\r\n    if (messages.size() == 1) {\r\n        Message msg = Iterables.getOnlyElement(new Errors().keyNotFullySpecified(typeLiteral).getMessages());\r\n        return msg.getMessage().equals(Iterables.getOnlyElement(messages).getMessage());\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.google.common.net.InternetDomainName.hasParent",
	"Comment": "indicates whether this domain is composed of two or more parts.",
	"Method": "boolean hasParent(){\r\n    return parts.size() > 1;\r\n}"
}, {
	"Path": "org.apache.dubbo.common.utils.ReflectUtils.isInstance",
	"Comment": "check if one object is the implementation for a given interface.this method will not trigger classloading for the given interface, therefore it will not lead to error whenthe given interface is not visible by the classloader",
	"Method": "boolean isInstance(Object obj,String interfaceClazzName){\r\n    for (Class<?> clazz = obj.getClass(); clazz != null && !clazz.equals(Object.class); clazz = clazz.getSuperclass()) {\r\n        Class<?>[] interfaces = clazz.getInterfaces();\r\n        for (Class<?> itf : interfaces) {\r\n            if (itf.getName().equals(interfaceClazzName)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.google.inject.matcher.Matchers.only",
	"Comment": "returns a matcher which matches objects equal to the given object.",
	"Method": "Matcher<Object> only(Object value){\r\n    return new Only(value);\r\n}"
}, {
	"Path": "com.google.common.primitives.ImmutableIntArray.copyOf",
	"Comment": "returns an immutable array containing the given values, in order.",
	"Method": "ImmutableIntArray copyOf(int[] values,ImmutableIntArray copyOf,Collection<Integer> values,ImmutableIntArray copyOf,Iterable<Integer> values,ImmutableIntArray copyOf,IntStream stream){\r\n    int[] array = stream.toArray();\r\n    return (array.length == 0) ? EMPTY : new ImmutableIntArray(array);\r\n}"
}, {
	"Path": "com.google.common.primitives.SignedBytes.compare",
	"Comment": "one too, which would leave compare methods only on the unsigned classes.",
	"Method": "int compare(byte a,byte b){\r\n    return a - b;\r\n}"
}, {
	"Path": "com.google.common.collect.testing.features.FeatureUtil.buildTesterRequirements",
	"Comment": "find all the constraints explicitly or implicitly specified by a single tester annotation.",
	"Method": "TesterRequirements buildTesterRequirements(Class<?> testerClass,TesterRequirements buildTesterRequirements,Method testerMethod,TesterRequirements buildTesterRequirements,Annotation testerAnnotation){\r\n    Class<? extends Annotation> annotationClass = testerAnnotation.annotationType();\r\n    final Feature<?>[] presentFeatures;\r\n    final Feature<?>[] absentFeatures;\r\n    try {\r\n        presentFeatures = (Feature[]) annotationClass.getMethod(\"value\").invoke(testerAnnotation);\r\n        absentFeatures = (Feature[]) annotationClass.getMethod(\"absent\").invoke(testerAnnotation);\r\n    } catch (Exception e) {\r\n        throw new IllegalArgumentException(\"Error extracting features from tester annotation.\", e);\r\n    }\r\n    Set<Feature<?>> allPresentFeatures = addImpliedFeatures(Helpers.<Feature<?>>copyToSet(presentFeatures));\r\n    Set<Feature<?>> allAbsentFeatures = addImpliedFeatures(Helpers.<Feature<?>>copyToSet(absentFeatures));\r\n    if (!Collections.disjoint(allPresentFeatures, allAbsentFeatures)) {\r\n        throw new ConflictingRequirementsException(\"Annotation explicitly or \" + \"implicitly requires one or more features to be both present \" + \"and absent.\", intersection(allPresentFeatures, allAbsentFeatures), testerAnnotation);\r\n    }\r\n    return new TesterRequirements(allPresentFeatures, allAbsentFeatures);\r\n}"
}, {
	"Path": "com.google.common.collect.testing.features.FeatureUtil.impliedFeatures",
	"Comment": "given a set of features, return a new set of all features directly or indirectly implied by anyof them.",
	"Method": "Set<Feature<?>> impliedFeatures(Set<Feature<?>> features){\r\n    Set<Feature<?>> impliedSet = new LinkedHashSet();\r\n    Queue<Feature<?>> queue = new ArrayDeque(features);\r\n    while (!queue.isEmpty()) {\r\n        Feature<?> feature = queue.remove();\r\n        for (Feature<?> implied : feature.getImpliedFeatures()) {\r\n            if (!features.contains(implied) && impliedSet.add(implied)) {\r\n                queue.add(implied);\r\n            }\r\n        }\r\n    }\r\n    return impliedSet;\r\n}"
}, {
	"Path": "com.google.inject.spi.TypeListenerBinding.getTypeMatcher",
	"Comment": "returns the type matcher which chooses which types the listener should be notified of.",
	"Method": "Matcher<? super TypeLiteral<?>> getTypeMatcher(){\r\n    return typeMatcher;\r\n}"
}, {
	"Path": "com.google.inject.internal.ProviderMethod.doProvision",
	"Comment": "extension point for our subclasses to implement the provisioning strategy.",
	"Method": "T doProvision(InternalContext context,Dependency<?> dependency,T doProvision,Object[] parameters,T doProvision,Object[] parameters,T doProvision,Object[] parameters){\r\n    try {\r\n        T t = doProvision(SingleParameterInjector.getAll(context, parameterInjectors));\r\n        if (t == null && !dependency.isNullable()) {\r\n            InternalProvisionException.onNullInjectedIntoNonNullableDependency(getMethod(), dependency);\r\n        }\r\n        return t;\r\n    } catch (IllegalAccessException e) {\r\n        throw new AssertionError(e);\r\n    } catch (InvocationTargetException userException) {\r\n        Throwable cause = userException.getCause() != null ? userException.getCause() : userException;\r\n        throw InternalProvisionException.errorInProvider(cause).addSource(getSource());\r\n    }\r\n}"
}, {
	"Path": "com.google.common.hash.Striped64.getUnsafe",
	"Comment": "returns a sun.misc.unsafe. suitable for use in a 3rd party package. replace with a simple callto unsafe.getunsafe when integrating into a jdk.",
	"Method": "sun.misc.Unsafe getUnsafe(){\r\n    try {\r\n        return sun.misc.Unsafe.getUnsafe();\r\n    } catch (SecurityException tryReflectionInstead) {\r\n    }\r\n    try {\r\n        return java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\r\n            public sun.misc.Unsafe run() throws Exception {\r\n                Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\r\n                for (java.lang.reflect.Field f : k.getDeclaredFields()) {\r\n                    f.setAccessible(true);\r\n                    Object x = f.get(null);\r\n                    if (k.isInstance(x))\r\n                        return k.cast(x);\r\n                }\r\n                throw new NoSuchFieldError(\"the Unsafe\");\r\n            }\r\n        });\r\n    } catch (java.security.PrivilegedActionException e) {\r\n        throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\r\n    }\r\n}"
}, {
	"Path": "com.google.common.hash.Striped64.getUnsafe",
	"Comment": "returns a sun.misc.unsafe. suitable for use in a 3rd party package. replace with a simple callto unsafe.getunsafe when integrating into a jdk.",
	"Method": "sun.misc.Unsafe getUnsafe(){\r\n    Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\r\n    for (java.lang.reflect.Field f : k.getDeclaredFields()) {\r\n        f.setAccessible(true);\r\n        Object x = f.get(null);\r\n        if (k.isInstance(x))\r\n            return k.cast(x);\r\n    }\r\n    throw new NoSuchFieldError(\"the Unsafe\");\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AtomicDoubleArray.toString",
	"Comment": "returns the string representation of the current values of array.",
	"Method": "String toString(){\r\n    int iMax = length() - 1;\r\n    if (iMax == -1) {\r\n        return \"[]\";\r\n    }\r\n    StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\r\n    b.append('[');\r\n    for (int i = 0; ; i++) {\r\n        b.append(longBitsToDouble(longs.get(i)));\r\n        if (i == iMax) {\r\n            return b.append(']').toString();\r\n        }\r\n        b.append(',').append(' ');\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.testing.SortedMapTestSuiteBuilder.createSubmapSuite",
	"Comment": "creates a suite whose map has some elements filtered out of view.because the map may be ascending or descending, this test must derive the relative order ofthese extreme values rather than relying on their regular sort ordering.",
	"Method": "TestSuite createSubmapSuite(FeatureSpecificTestSuiteBuilder<?, ? extends OneSizeTestContainerGenerator<Map<K, V>, Entry<K, V>>> parentBuilder,Bound from,Bound to){\r\n    final TestSortedMapGenerator<K, V> delegate = (TestSortedMapGenerator<K, V>) parentBuilder.getSubjectGenerator().getInnerGenerator();\r\n    List<Feature<?>> features = new ArrayList();\r\n    features.add(NoRecurse.SUBMAP);\r\n    features.addAll(parentBuilder.getFeatures());\r\n    return newBuilderUsing(delegate, to, from).named(parentBuilder.getName() + \" subMap \" + from + \"-\" + to).withFeatures(features).suppressing(parentBuilder.getSuppressedTests()).createTestSuite();\r\n}"
}, {
	"Path": "com.google.common.testing.CollectorTester.expectCollects",
	"Comment": "verifies that the specified expected result is always produced by collecting the specifiedinputs, regardless of how the elements are divided.",
	"Method": "CollectorTester<T, A, R> expectCollects(R expectedResult,T inputs){\r\n    List<T> list = Arrays.asList(inputs);\r\n    doExpectCollects(expectedResult, list);\r\n    if (collector.characteristics().contains(Collector.Characteristics.UNORDERED)) {\r\n        Collections.reverse(list);\r\n        doExpectCollects(expectedResult, list);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.google.inject.servlet.ServletTestUtils.newFakeHttpServletResponse",
	"Comment": "returns a fake, httpservletresponse which throws an exception if any of its methods are called.",
	"Method": "HttpServletResponse newFakeHttpServletResponse(){\r\n    return (HttpServletResponse) Proxy.newProxyInstance(HttpServletResponse.class.getClassLoader(), new Class[] { HttpServletResponse.class }, new ThrowingInvocationHandler());\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableListMultimap.copyOf",
	"Comment": "returns an immutable multimap containing the specified entries. the returned multimap iteratesover keys in the order they were first encountered in the input, and the values for each keyare iterated in the order they were encountered.",
	"Method": "ImmutableListMultimap<K, V> copyOf(Multimap<? extends K, ? extends V> multimap,ImmutableListMultimap<K, V> copyOf,Iterable<? extends Entry<? extends K, ? extends V>> entries){\r\n    return new Builder<K, V>().putAll(entries).build();\r\n}"
}, {
	"Path": "com.google.common.collect.MinMaxPriorityQueueTest.testIteratorInvalidatingIteratorRemove2",
	"Comment": "this tests a special case where removeat has to trickle an element first down one level from amin to a max level, then up one level above the index of the removed element. it also teststhat skipme in the iterator plays nicely with forgetmenot.",
	"Method": "void testIteratorInvalidatingIteratorRemove2(){\r\n    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();\r\n    mmHeap.addAll(Lists.newArrayList(1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 200, 300, 500, 400));\r\n    assertTrue(\"Heap is not intact initially\", mmHeap.isIntact());\r\n    Iterator<Integer> it = mmHeap.iterator();\r\n    assertEquals((Integer) 1, it.next());\r\n    assertEquals((Integer) 20, it.next());\r\n    assertEquals((Integer) 1000, it.next());\r\n    assertEquals((Integer) 2, it.next());\r\n    it.remove();\r\n    assertTrue(\"Heap is not intact after remove\", mmHeap.isIntact());\r\n    assertEquals((Integer) 10, it.next());\r\n    assertEquals((Integer) 3, it.next());\r\n    it.remove();\r\n    assertTrue(\"Heap is not intact after remove\", mmHeap.isIntact());\r\n    assertEquals((Integer) 12, it.next());\r\n    assertEquals((Integer) 30, it.next());\r\n    assertEquals((Integer) 40, it.next());\r\n    assertEquals((Integer) 11, it.next());\r\n    assertEquals((Integer) 400, it.next());\r\n    assertEquals((Integer) 13, it.next());\r\n    assertEquals((Integer) 200, it.next());\r\n    assertEquals((Integer) 300, it.next());\r\n    assertEquals((Integer) 500, it.next());\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultiset.add",
	"Comment": "guaranteed to throw an exception and leave the collection unmodified.",
	"Method": "int add(E element,int occurrences,Builder<E> add,E element,Builder<E> add,E elements){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.FluentIterableTest.testConcatIterable",
	"Comment": "exhaustive tests are in iteratorstest. these are copied from iterablestest.",
	"Method": "void testConcatIterable(){\r\n    List<Integer> list1 = newArrayList(1);\r\n    List<Integer> list2 = newArrayList(4);\r\n    @SuppressWarnings(\"unchecked\")\r\n    List<List<Integer>> input = newArrayList(list1, list2);\r\n    FluentIterable<Integer> result = FluentIterable.concat(input);\r\n    assertEquals(asList(1, 4), newArrayList(result));\r\n    list1.add(2);\r\n    List<Integer> list3 = newArrayList(3);\r\n    input.add(1, list3);\r\n    assertEquals(asList(1, 2, 3, 4), newArrayList(result));\r\n    assertEquals(\"[1, 2, 3, 4]\", result.toString());\r\n}"
}, {
	"Path": "com.google.common.math.IntMathTest.testLog2MatchesBigInteger",
	"Comment": "relies on the correctness of bigintegrermath.log2 for all modes except unnecessary.",
	"Method": "void testLog2MatchesBigInteger(){\r\n    for (int x : POSITIVE_INTEGER_CANDIDATES) {\r\n        for (RoundingMode mode : ALL_SAFE_ROUNDING_MODES) {\r\n            assertEquals(BigIntegerMath.log2(valueOf(x), mode), IntMath.log2(x, mode));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.Platform.newLinkedHashSetWithExpectedSize",
	"Comment": "returns the platform preferred implementation of an insertion ordered set based on a hashtable.",
	"Method": "Set<E> newLinkedHashSetWithExpectedSize(int expectedSize){\r\n    return Sets.newLinkedHashSetWithExpectedSize(expectedSize);\r\n}"
}, {
	"Path": "com.google.inject.spi.Message.writeReplace",
	"Comment": "when serialized, we eagerly convert sources to strings. this hurts our formatting, but itguarantees that the receiving end will be able to read the message.",
	"Method": "Object writeReplace(){\r\n    Object[] sourcesAsStrings = sources.toArray();\r\n    for (int i = 0; i < sourcesAsStrings.length; i++) {\r\n        sourcesAsStrings[i] = Errors.convert(sourcesAsStrings[i]).toString();\r\n    }\r\n    return new Message(ImmutableList.copyOf(sourcesAsStrings), message, cause);\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.JSR166TestCase.sleep",
	"Comment": "sleeps until the given time has elapsed. throws assertionfailederror if interrupted.",
	"Method": "void sleep(long millis){\r\n    try {\r\n        delay(millis);\r\n    } catch (InterruptedException ie) {\r\n        AssertionFailedError afe = new AssertionFailedError(\"Unexpected InterruptedException\");\r\n        afe.initCause(ie);\r\n        throw afe;\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableCollection.addAll",
	"Comment": "guaranteed to throw an exception and leave the collection unmodified.",
	"Method": "boolean addAll(Collection<? extends E> newElements,Builder<E> addAll,Iterable<? extends E> elements,Builder<E> addAll,Iterator<? extends E> elements){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.math.MathBenchmarking.randomPositiveBigInteger",
	"Comment": "generates values in a distribution equivalent to randomnonnegativebiginteger but omitting zero.",
	"Method": "BigInteger randomPositiveBigInteger(int numBits){\r\n    BigInteger result;\r\n    do {\r\n        result = randomNonNegativeBigInteger(numBits);\r\n    } while (result.signum() == 0);\r\n    return result;\r\n}"
}, {
	"Path": "com.google.common.cache.CacheBuilder.lenientParsing",
	"Comment": "enables lenient parsing. useful for tests and spec parsing.",
	"Method": "CacheBuilder<K, V> lenientParsing(){\r\n    strictParsing = false;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.common.primitives.ImmutableLongArray.of",
	"Comment": "returns an immutable array containing the given values, in order.",
	"Method": "ImmutableLongArray of(ImmutableLongArray of,long e0,ImmutableLongArray of,long e0,long e1,ImmutableLongArray of,long e0,long e1,long e2,ImmutableLongArray of,long e0,long e1,long e2,long e3,ImmutableLongArray of,long e0,long e1,long e2,long e3,long e4,ImmutableLongArray of,long e0,long e1,long e2,long e3,long e4,long e5,ImmutableLongArray of,long first,long rest){\r\n    checkArgument(rest.length <= Integer.MAX_VALUE - 1, \"the total number of elements must fit in an int\");\r\n    long[] array = new long[rest.length + 1];\r\n    array[0] = first;\r\n    System.arraycopy(rest, 0, array, 1, rest.length);\r\n    return new ImmutableLongArray(array);\r\n}"
}, {
	"Path": "com.google.common.base.Joiner.join",
	"Comment": "returns a string containing the string representation of each argument, using the previouslyconfigured separator between each.",
	"Method": "String join(Iterable<?> parts,String join,Iterator<?> parts,String join,Object[] parts,String join,Object first,Object second,Object rest,String join,Map<?, ?> map,String join,Iterable<? extends Entry<?, ?>> entries,String join,Iterator<? extends Entry<?, ?>> entries){\r\n    return join(iterable(first, second, rest));\r\n}"
}, {
	"Path": "com.google.common.eventbus.SubscriberRegistry.findAllSubscribers",
	"Comment": "returns all subscribers for the given listener grouped by the type of event they subscribe to.",
	"Method": "Multimap<Class<?>, Subscriber> findAllSubscribers(Object listener){\r\n    Multimap<Class<?>, Subscriber> methodsInListener = HashMultimap.create();\r\n    Class<?> clazz = listener.getClass();\r\n    for (Method method : getAnnotatedMethods(clazz)) {\r\n        Class<?>[] parameterTypes = method.getParameterTypes();\r\n        Class<?> eventType = parameterTypes[0];\r\n        methodsInListener.put(eventType, Subscriber.create(bus, listener, method));\r\n    }\r\n    return methodsInListener;\r\n}"
}, {
	"Path": "com.google.common.collect.ArrayTable.rowKeyList",
	"Comment": "returns, as an immutable list, the row keys provided when the table was constructed, includingthose that are mapped to null values only.",
	"Method": "ImmutableList<R> rowKeyList(){\r\n    return rowList;\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultimap.copyOf",
	"Comment": "returns an immutable multimap containing the specified entries. the returned multimap iteratesover keys in the order they were first encountered in the input, and the values for each keyare iterated in the order they were encountered.",
	"Method": "ImmutableMultimap<K, V> copyOf(Multimap<? extends K, ? extends V> multimap,ImmutableMultimap<K, V> copyOf,Iterable<? extends Entry<? extends K, ? extends V>> entries){\r\n    return ImmutableListMultimap.copyOf(entries);\r\n}"
}, {
	"Path": "com.google.common.net.MediaType.withParameters",
	"Comment": "replaces all parameters with the given attribute with parameters using the givenvalues. if there are no values, any existing parameters with the given attribute are removed.",
	"Method": "MediaType withParameters(Multimap<String, String> parameters,MediaType withParameters,String attribute,Iterable<String> values){\r\n    checkNotNull(attribute);\r\n    checkNotNull(values);\r\n    String normalizedAttribute = normalizeToken(attribute);\r\n    ImmutableListMultimap.Builder<String, String> builder = ImmutableListMultimap.builder();\r\n    for (Entry<String, String> entry : parameters.entries()) {\r\n        String key = entry.getKey();\r\n        if (!normalizedAttribute.equals(key)) {\r\n            builder.put(key, entry.getValue());\r\n        }\r\n    }\r\n    for (String value : values) {\r\n        builder.put(normalizedAttribute, normalizeParameterValue(normalizedAttribute, value));\r\n    }\r\n    MediaType mediaType = new MediaType(type, subtype, builder.build());\r\n    if (!normalizedAttribute.equals(CHARSET_ATTRIBUTE)) {\r\n        mediaType.parsedCharset = this.parsedCharset;\r\n    }\r\n    return MoreObjects.firstNonNull(KNOWN_TYPES.get(mediaType), mediaType);\r\n}"
}, {
	"Path": "com.google.common.collect.Platform.preservesInsertionOrderOnPutsMap",
	"Comment": "returns the platform preferred map implementation that preserves insertion order when used onlyfor insertions.",
	"Method": "Map<K, V> preservesInsertionOrderOnPutsMap(){\r\n    return Maps.newLinkedHashMap();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.MonitorBasedArrayBlockingQueue.extract",
	"Comment": "extracts element at current take position, advances, and signals. call only when occupyingmonitor.",
	"Method": "E extract(){\r\n    final E[] items = this.items;\r\n    E x = items[takeIndex];\r\n    items[takeIndex] = null;\r\n    takeIndex = inc(takeIndex);\r\n    --count;\r\n    return x;\r\n}"
}, {
	"Path": "com.google.inject.internal.MultibinderTest.testConcurrentMutation_bindingsSameAtInjectorCreation",
	"Comment": "verify through gratuitous mutation that key hashcode snapshots and whatnot happen at the righttimes, by binding two lists that compare equal at injector creation, but are different when themodule is configuredwhen the set is instantiated.",
	"Method": "void testConcurrentMutation_bindingsSameAtInjectorCreation(){\r\n    final List<String> list1 = Lists.newArrayList(\"A\");\r\n    final List<String> list2 = Lists.newArrayList(\"B\");\r\n    Module module = new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            Multibinder<List<String>> multibinder = Multibinder.newSetBinder(binder(), listOfStrings);\r\n            multibinder.addBinding().toInstance(list1);\r\n            multibinder.addBinding().toInstance(list2);\r\n        }\r\n    };\r\n    List<Element> elements = Elements.getElements(module);\r\n    list1.add(1, \"B\");\r\n    list2.add(0, \"A\");\r\n    Injector injector = Guice.createInjector(Elements.getModule(elements));\r\n    list1.remove(\"A\");\r\n    list2.remove(\"B\");\r\n    Set<List<String>> set = injector.getInstance(Key.get(setOfListOfStrings));\r\n    assertTrue(ImmutableSet.of(ImmutableList.of(\"A\")).equals(set) || ImmutableSet.of(ImmutableList.of(\"B\")).equals(set));\r\n}"
}, {
	"Path": "com.google.inject.internal.MultibinderTest.testConcurrentMutation_bindingsSameAtInjectorCreation",
	"Comment": "verify through gratuitous mutation that key hashcode snapshots and whatnot happen at the righttimes, by binding two lists that compare equal at injector creation, but are different when themodule is configuredwhen the set is instantiated.",
	"Method": "void testConcurrentMutation_bindingsSameAtInjectorCreation(){\r\n    Multibinder<List<String>> multibinder = Multibinder.newSetBinder(binder(), listOfStrings);\r\n    multibinder.addBinding().toInstance(list1);\r\n    multibinder.addBinding().toInstance(list2);\r\n}"
}, {
	"Path": "com.google.common.collect.AbstractBiMap.checkValue",
	"Comment": "returns its input, or throws an exception if this is not a valid value.",
	"Method": "V checkValue(V value,V checkValue,V value){\r\n    return value;\r\n}"
}, {
	"Path": "com.google.common.collect.MultimapBuilder.hashKeys",
	"Comment": "uses a hash table to map keys to value collections, initialized to expect the specifiednumber of keys.",
	"Method": "MultimapBuilderWithKeys<Object> hashKeys(MultimapBuilderWithKeys<Object> hashKeys,int expectedKeys){\r\n    checkNonnegative(expectedKeys, \"expectedKeys\");\r\n    return new MultimapBuilderWithKeys<Object>() {\r\n        @Override\r\n        <K, V> Map<K, Collection<V>> createMap() {\r\n            return Platform.newHashMapWithExpectedSize(expectedKeys);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.google.common.collect.MultimapBuilder.hashKeys",
	"Comment": "uses a hash table to map keys to value collections, initialized to expect the specifiednumber of keys.",
	"Method": "MultimapBuilderWithKeys<Object> hashKeys(MultimapBuilderWithKeys<Object> hashKeys,int expectedKeys){\r\n    return Platform.newHashMapWithExpectedSize(expectedKeys);\r\n}"
}, {
	"Path": "com.google.common.hash.Hashing.combineOrdered",
	"Comment": "returns a hash code, having the same bit length as each of the input hash codes, that combinesthe information of these hash codes in an ordered fashion. that is, whenever two equal hashcodes are produced by two calls to this method, it is as likely as possible that eachwas computed from the same input hash codes in the same order.",
	"Method": "HashCode combineOrdered(Iterable<HashCode> hashCodes){\r\n    Iterator<HashCode> iterator = hashCodes.iterator();\r\n    checkArgument(iterator.hasNext(), \"Must be at least 1 hash code to combine.\");\r\n    int bits = iterator.next().bits();\r\n    byte[] resultBytes = new byte[bits / 8];\r\n    for (HashCode hashCode : hashCodes) {\r\n        byte[] nextBytes = hashCode.asBytes();\r\n        checkArgument(nextBytes.length == resultBytes.length, \"All hashcodes must have the same bit length.\");\r\n        for (int i = 0; i < nextBytes.length; i++) {\r\n            resultBytes[i] = (byte) (resultBytes[i] * 37 ^ nextBytes[i]);\r\n        }\r\n    }\r\n    return HashCode.fromBytesNoCopy(resultBytes);\r\n}"
}, {
	"Path": "com.google.common.base.Stopwatch.stop",
	"Comment": "stops the stopwatch. future reads will return the fixed duration that had elapsed up to thispoint.",
	"Method": "Stopwatch stop(){\r\n    long tick = ticker.read();\r\n    checkState(isRunning, \"This stopwatch is already stopped.\");\r\n    isRunning = false;\r\n    elapsedNanos += tick - startTick;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.inject.internal.InjectorImpl.removeFailedJitBinding",
	"Comment": "cleans up any state that may have been cached when constructing the jit binding.",
	"Method": "void removeFailedJitBinding(Binding<?> binding,InjectionPoint ip){\r\n    failedJitBindings.add(binding.getKey());\r\n    jitBindings.remove(binding.getKey());\r\n    membersInjectorStore.remove(binding.getKey().getTypeLiteral());\r\n    provisionListenerStore.remove(binding);\r\n    if (ip != null) {\r\n        constructors.remove(ip);\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.servlet.ServletTestUtils.newFakeHttpServletRequest",
	"Comment": "returns a fake, httpservletrequest which stores attributes in a hashmap.",
	"Method": "HttpServletRequest newFakeHttpServletRequest(){\r\n    HttpServletRequest delegate = (HttpServletRequest) Proxy.newProxyInstance(HttpServletRequest.class.getClassLoader(), new Class[] { HttpServletRequest.class }, new ThrowingInvocationHandler());\r\n    return new HttpServletRequestWrapper(delegate) {\r\n        final Map<String, Object> attributes = Maps.newHashMap();\r\n        final HttpSession session = newFakeHttpSession();\r\n        @Override\r\n        public String getMethod() {\r\n            return \"GET\";\r\n        }\r\n        @Override\r\n        public Object getAttribute(String name) {\r\n            return attributes.get(name);\r\n        }\r\n        @Override\r\n        public void setAttribute(String name, Object value) {\r\n            attributes.put(name, value);\r\n        }\r\n        @Override\r\n        public Map getParameterMap() {\r\n            return ImmutableMap.of();\r\n        }\r\n        @Override\r\n        public String getRequestURI() {\r\n            return \"/\";\r\n        }\r\n        @Override\r\n        public String getContextPath() {\r\n            return \"\";\r\n        }\r\n        @Override\r\n        public HttpSession getSession() {\r\n            return session;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.google.inject.servlet.ServletTestUtils.newFakeHttpServletRequest",
	"Comment": "returns a fake, httpservletrequest which stores attributes in a hashmap.",
	"Method": "HttpServletRequest newFakeHttpServletRequest(){\r\n    return \"GET\";\r\n}"
}, {
	"Path": "com.google.inject.servlet.ServletTestUtils.newFakeHttpServletRequest",
	"Comment": "returns a fake, httpservletrequest which stores attributes in a hashmap.",
	"Method": "HttpServletRequest newFakeHttpServletRequest(){\r\n    return attributes.get(name);\r\n}"
}, {
	"Path": "com.google.inject.servlet.ServletTestUtils.newFakeHttpServletRequest",
	"Comment": "returns a fake, httpservletrequest which stores attributes in a hashmap.",
	"Method": "HttpServletRequest newFakeHttpServletRequest(){\r\n    attributes.put(name, value);\r\n}"
}, {
	"Path": "com.google.inject.servlet.ServletTestUtils.newFakeHttpServletRequest",
	"Comment": "returns a fake, httpservletrequest which stores attributes in a hashmap.",
	"Method": "HttpServletRequest newFakeHttpServletRequest(){\r\n    return ImmutableMap.of();\r\n}"
}, {
	"Path": "com.google.inject.servlet.ServletTestUtils.newFakeHttpServletRequest",
	"Comment": "returns a fake, httpservletrequest which stores attributes in a hashmap.",
	"Method": "HttpServletRequest newFakeHttpServletRequest(){\r\n    return \"/\";\r\n}"
}, {
	"Path": "com.google.inject.servlet.ServletTestUtils.newFakeHttpServletRequest",
	"Comment": "returns a fake, httpservletrequest which stores attributes in a hashmap.",
	"Method": "HttpServletRequest newFakeHttpServletRequest(){\r\n    return \"\";\r\n}"
}, {
	"Path": "com.google.inject.servlet.ServletTestUtils.newFakeHttpServletRequest",
	"Comment": "returns a fake, httpservletrequest which stores attributes in a hashmap.",
	"Method": "HttpServletRequest newFakeHttpServletRequest(){\r\n    return session;\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableListMultimap.replaceValues",
	"Comment": "guaranteed to throw an exception and leave the multimap unmodified.",
	"Method": "ImmutableList<V> replaceValues(K key,Iterable<? extends V> values){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.cache.LocalCache.unset",
	"Comment": "singleton placeholder that indicates a value is being loaded.",
	"Method": "ValueReference<K, V> unset(){\r\n    return (ValueReference<K, V>) UNSET;\r\n}"
}, {
	"Path": "com.google.common.net.HostAndPort.getPortOrDefault",
	"Comment": "returns the current port number, with a default if no port is defined.",
	"Method": "int getPortOrDefault(int defaultPort){\r\n    return hasPort() ? port : defaultPort;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AtomicDoubleTest.testCompareAndSet",
	"Comment": "compareandset succeeds in changing value if equal to expected else fails",
	"Method": "void testCompareAndSet(){\r\n    double prev = Math.E;\r\n    double unused = Math.E + Math.PI;\r\n    AtomicDouble at = new AtomicDouble(prev);\r\n    for (double x : VALUES) {\r\n        assertBitEquals(prev, at.get());\r\n        assertFalse(at.compareAndSet(unused, x));\r\n        assertBitEquals(prev, at.get());\r\n        assertTrue(at.compareAndSet(prev, x));\r\n        assertBitEquals(x, at.get());\r\n        prev = x;\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.Tables.immutableCell",
	"Comment": "returns an immutable cell with the specified row key, column key, and value.the returned cell is serializable.",
	"Method": "Cell<R, C, V> immutableCell(R rowKey,C columnKey,V value){\r\n    return new ImmutableCell(rowKey, columnKey, value);\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableList.addAll",
	"Comment": "guaranteed to throw an exception and leave the list unmodified.",
	"Method": "boolean addAll(int index,Collection<? extends E> newElements,Builder<E> addAll,Iterable<? extends E> elements,Builder<E> addAll,Iterator<? extends E> elements){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.base.internal.Finalizer.run",
	"Comment": "loops continuously, pulling references off the queue and cleaning them up.",
	"Method": "void run(){\r\n    while (true) {\r\n        try {\r\n            if (!cleanUp(queue.remove())) {\r\n                break;\r\n            }\r\n        } catch (InterruptedException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.internal.Scoping.isExplicitlyScoped",
	"Comment": "returns true if this scope was explicitly applied. if no scope was explicitly applied then thescoping annotation will be used.",
	"Method": "boolean isExplicitlyScoped(){\r\n    return this != UNSCOPED;\r\n}"
}, {
	"Path": "com.google.common.io.ByteSource.contentEquals",
	"Comment": "checks that the contents of this byte source are equal to the contents of the given bytesource.",
	"Method": "boolean contentEquals(ByteSource other){\r\n    checkNotNull(other);\r\n    byte[] buf1 = createBuffer();\r\n    byte[] buf2 = createBuffer();\r\n    Closer closer = Closer.create();\r\n    try {\r\n        InputStream in1 = closer.register(openStream());\r\n        InputStream in2 = closer.register(other.openStream());\r\n        while (true) {\r\n            int read1 = ByteStreams.read(in1, buf1, 0, buf1.length);\r\n            int read2 = ByteStreams.read(in2, buf2, 0, buf2.length);\r\n            if (read1 != read2 || !Arrays.equals(buf1, buf2)) {\r\n                return false;\r\n            } else if (read1 != buf1.length) {\r\n                return true;\r\n            }\r\n        }\r\n    } catch (Throwable e) {\r\n        throw closer.rethrow(e);\r\n    } finally {\r\n        closer.close();\r\n    }\r\n}"
}, {
	"Path": "org.apache.dubbo.common.json.Yylex.yytext",
	"Comment": "returns the text matched by the current regular expression.",
	"Method": "String yytext(){\r\n    return new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);\r\n}"
}, {
	"Path": "com.zaxxer.hikari.util.UtilityElf.createInstance",
	"Comment": "create and instance of the specified class using the constructor matching the specified arguments.",
	"Method": "T createInstance(String className,Class<T> clazz,Object args){\r\n    if (className == null) {\r\n        return null;\r\n    }\r\n    try {\r\n        Class<?> loaded = UtilityElf.class.getClassLoader().loadClass(className);\r\n        if (args.length == 0) {\r\n            return clazz.cast(loaded.newInstance());\r\n        }\r\n        Class<?>[] argClasses = new Class<?>[args.length];\r\n        for (int i = 0; i < args.length; i++) {\r\n            argClasses[i] = args[i].getClass();\r\n        }\r\n        Constructor<?> constructor = loaded.getConstructor(argClasses);\r\n        return clazz.cast(constructor.newInstance(args));\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.google.common.reflect.TypeTokenTest.testEquals",
	"Comment": "the a and b type parameters are used inside the test to test type variable",
	"Method": "void testEquals(){\r\n    new EqualsTester().addEqualityGroup(TypeToken.of(String.class), TypeToken.of(String.class), new Entry<String, Integer>() {\r\n    }.keyType(), new Entry<Integer, String>() {\r\n    }.valueType(), new TypeToken<String>() {\r\n    }, new TypeToken<String>() {\r\n    }).addEqualityGroup(TypeToken.of(Integer.class), new TypeToken<Integer>() {\r\n    }, new Entry<Integer, String>() {\r\n    }.keyType(), new Entry<String, Integer>() {\r\n    }.valueType()).addEqualityGroup(new TypeToken<List<String>>() {\r\n    }, new TypeToken<List<String>>() {\r\n    }).addEqualityGroup(new TypeToken<List<?>>() {\r\n    }, new TypeToken<List<?>>() {\r\n    }).addEqualityGroup(new TypeToken<Map<A, ?>>() {\r\n    }, new TypeToken<Map<A, ?>>() {\r\n    }).addEqualityGroup(new TypeToken<Map<B, ?>>() {\r\n    }).addEqualityGroup(TypeToken.of(new TypeCapture<A>() {\r\n    }.capture()), TypeToken.of(new TypeCapture<A>() {\r\n    }.capture())).addEqualityGroup(TypeToken.of(new TypeCapture<B>() {\r\n    }.capture())).testEquals();\r\n}"
}, {
	"Path": "com.google.inject.internal.MultibinderTest.testModuleOverrideAndMultibindingsWithPermitDuplicates",
	"Comment": "with overrides, we should get the union of all multibindings.",
	"Method": "void testModuleOverrideAndMultibindingsWithPermitDuplicates(){\r\n    Module abc = new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);\r\n            multibinder.addBinding().toInstance(\"A\");\r\n            multibinder.addBinding().toInstance(\"B\");\r\n            multibinder.addBinding().toInstance(\"C\");\r\n            multibinder.permitDuplicates();\r\n        }\r\n    };\r\n    Module cd = new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);\r\n            multibinder.addBinding().toInstance(\"C\");\r\n            multibinder.addBinding().toInstance(\"D\");\r\n            multibinder.permitDuplicates();\r\n        }\r\n    };\r\n    Module ef = new AbstractModule() {\r\n        @Override\r\n        protected void configure() {\r\n            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);\r\n            multibinder.addBinding().toInstance(\"E\");\r\n            multibinder.addBinding().toInstance(\"F\");\r\n            multibinder.permitDuplicates();\r\n        }\r\n    };\r\n    Module abcd = Modules.override(abc).with(cd);\r\n    Injector injector = Guice.createInjector(abcd, ef);\r\n    assertEquals(ImmutableSet.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"), injector.getInstance(Key.get(setOfString)));\r\n    assertSetVisitor(Key.get(setOfString), stringType, setOf(abcd, ef), BOTH, true, 0, instance(\"A\"), instance(\"B\"), instance(\"C\"), instance(\"D\"), instance(\"E\"), instance(\"F\"));\r\n}"
}, {
	"Path": "com.google.inject.internal.MultibinderTest.testModuleOverrideAndMultibindingsWithPermitDuplicates",
	"Comment": "with overrides, we should get the union of all multibindings.",
	"Method": "void testModuleOverrideAndMultibindingsWithPermitDuplicates(){\r\n    Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);\r\n    multibinder.addBinding().toInstance(\"A\");\r\n    multibinder.addBinding().toInstance(\"B\");\r\n    multibinder.addBinding().toInstance(\"C\");\r\n    multibinder.permitDuplicates();\r\n}"
}, {
	"Path": "com.google.inject.internal.MultibinderTest.testModuleOverrideAndMultibindingsWithPermitDuplicates",
	"Comment": "with overrides, we should get the union of all multibindings.",
	"Method": "void testModuleOverrideAndMultibindingsWithPermitDuplicates(){\r\n    Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);\r\n    multibinder.addBinding().toInstance(\"C\");\r\n    multibinder.addBinding().toInstance(\"D\");\r\n    multibinder.permitDuplicates();\r\n}"
}, {
	"Path": "com.google.inject.internal.MultibinderTest.testModuleOverrideAndMultibindingsWithPermitDuplicates",
	"Comment": "with overrides, we should get the union of all multibindings.",
	"Method": "void testModuleOverrideAndMultibindingsWithPermitDuplicates(){\r\n    Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);\r\n    multibinder.addBinding().toInstance(\"E\");\r\n    multibinder.addBinding().toInstance(\"F\");\r\n    multibinder.permitDuplicates();\r\n}"
}, {
	"Path": "com.zaxxer.hikari.HikariConfig.setConnectionInitSql",
	"Comment": "set the sql string that will be executed on all new connections when they are created, before they are added to the pool.if this query fails, it will be treated as a failed connection attempt.",
	"Method": "void setConnectionInitSql(String connectionInitSql){\r\n    checkIfSealed();\r\n    this.connectionInitSql = connectionInitSql;\r\n}"
}, {
	"Path": "com.google.common.io.MoreFiles.isDirectory",
	"Comment": "returns whether or not the file with the given name in the given dir is a directory.",
	"Method": "Predicate<Path> isDirectory(LinkOption options,boolean isDirectory,SecureDirectoryStream<Path> dir,Path name,LinkOption options){\r\n    return dir.getFileAttributeView(name, BasicFileAttributeView.class, options).readAttributes().isDirectory();\r\n}"
}, {
	"Path": "com.google.common.cache.EmptyCachesTest.caches",
	"Comment": "most of the tests in this class run against every one of these caches.",
	"Method": "Iterable<LoadingCache<Object, Object>> caches(){\r\n    CacheBuilderFactory factory = cacheFactory();\r\n    return Iterables.transform(factory.buildAllPermutations(), new Function<CacheBuilder<Object, Object>, LoadingCache<Object, Object>>() {\r\n        @Override\r\n        public LoadingCache<Object, Object> apply(CacheBuilder<Object, Object> builder) {\r\n            return builder.build(identityLoader());\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.common.cache.EmptyCachesTest.caches",
	"Comment": "most of the tests in this class run against every one of these caches.",
	"Method": "Iterable<LoadingCache<Object, Object>> caches(){\r\n    return builder.build(identityLoader());\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableMultimap.values",
	"Comment": "returns an immutable collection of the values in this multimap. its iterator traverses thevalues for the first key, the values for the second key, and so on.",
	"Method": "ImmutableCollection<V> values(){\r\n    return (ImmutableCollection<V>) super.values();\r\n}"
}, {
	"Path": "com.google.common.base.SmallCharMatcher.chooseTableSize",
	"Comment": "returns an array size suitable for the backing array of a hash table that uses open addressingwith linear probing in its implementation. the returned size is the smallest power of two thatcan hold setsize elements with the desired load factor.",
	"Method": "int chooseTableSize(int setSize){\r\n    if (setSize == 1) {\r\n        return 2;\r\n    }\r\n    int tableSize = Integer.highestOneBit(setSize - 1) << 1;\r\n    while (tableSize * DESIRED_LOAD_FACTOR < setSize) {\r\n        tableSize <<= 1;\r\n    }\r\n    return tableSize;\r\n}"
}, {
	"Path": "com.google.common.collect.GeneralRange.intersect",
	"Comment": "returns the intersection of the two ranges, or an empty range if their intersection is empty.",
	"Method": "GeneralRange<T> intersect(GeneralRange<T> other){\r\n    checkNotNull(other);\r\n    checkArgument(comparator.equals(other.comparator));\r\n    boolean hasLowBound = this.hasLowerBound;\r\n    @Nullable\r\n    T lowEnd = getLowerEndpoint();\r\n    BoundType lowType = getLowerBoundType();\r\n    if (!hasLowerBound()) {\r\n        hasLowBound = other.hasLowerBound;\r\n        lowEnd = other.getLowerEndpoint();\r\n        lowType = other.getLowerBoundType();\r\n    } else if (other.hasLowerBound()) {\r\n        int cmp = comparator.compare(getLowerEndpoint(), other.getLowerEndpoint());\r\n        if (cmp < 0 || (cmp == 0 && other.getLowerBoundType() == OPEN)) {\r\n            lowEnd = other.getLowerEndpoint();\r\n            lowType = other.getLowerBoundType();\r\n        }\r\n    }\r\n    boolean hasUpBound = this.hasUpperBound;\r\n    @Nullable\r\n    T upEnd = getUpperEndpoint();\r\n    BoundType upType = getUpperBoundType();\r\n    if (!hasUpperBound()) {\r\n        hasUpBound = other.hasUpperBound;\r\n        upEnd = other.getUpperEndpoint();\r\n        upType = other.getUpperBoundType();\r\n    } else if (other.hasUpperBound()) {\r\n        int cmp = comparator.compare(getUpperEndpoint(), other.getUpperEndpoint());\r\n        if (cmp > 0 || (cmp == 0 && other.getUpperBoundType() == OPEN)) {\r\n            upEnd = other.getUpperEndpoint();\r\n            upType = other.getUpperBoundType();\r\n        }\r\n    }\r\n    if (hasLowBound && hasUpBound) {\r\n        int cmp = comparator.compare(lowEnd, upEnd);\r\n        if (cmp > 0 || (cmp == 0 && lowType == OPEN && upType == OPEN)) {\r\n            lowEnd = upEnd;\r\n            lowType = OPEN;\r\n            upType = CLOSED;\r\n        }\r\n    }\r\n    return new GeneralRange<T>(comparator, hasLowBound, lowEnd, lowType, hasUpBound, upEnd, upType);\r\n}"
}, {
	"Path": "com.google.common.escape.ArrayBasedUnicodeEscaper.escape",
	"Comment": "this is overridden to improve performance. rough benchmarking shows that this almost doublesthe speed when processing strings that do not require any escaping.",
	"Method": "String escape(String s,char[] escape,int cp){\r\n    if (cp < replacementsLength) {\r\n        char[] chars = replacements[cp];\r\n        if (chars != null) {\r\n            return chars;\r\n        }\r\n    }\r\n    if (cp >= safeMin && cp <= safeMax) {\r\n        return null;\r\n    }\r\n    return escapeUnsafe(cp);\r\n}"
}, {
	"Path": "com.google.common.collect.Platform.newHashSetWithExpectedSize",
	"Comment": "returns the platform preferred implementation of a set based on a hash table.",
	"Method": "Set<E> newHashSetWithExpectedSize(int expectedSize){\r\n    return Sets.newHashSetWithExpectedSize(expectedSize);\r\n}"
}, {
	"Path": "com.google.inject.internal.RealOptionalBinder.addDirectTypeBinding",
	"Comment": "adds a binding for t. multiple calls to this are safe, and will be collapsed as duplicatebindings.",
	"Method": "void addDirectTypeBinding(Binder binder){\r\n    binder.bind(bindingSelection.getDirectKey()).toProvider(new RealDirectTypeProvider<T>(bindingSelection));\r\n}"
}, {
	"Path": "org.apache.dubbo.common.json.Yylex.yypushback",
	"Comment": "pushes the specified amount of characters back into the input stream.they will be read again by then next call of the scanning method",
	"Method": "void yypushback(int number){\r\n    if (number > yylength()) {\r\n        zzScanError(ZZ_PUSHBACK_2BIG);\r\n    }\r\n    zzMarkedPos -= number;\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableSortedSet.of",
	"Comment": "returns an immutable sorted set containing a single element.",
	"Method": "ImmutableSortedSet<E> of(ImmutableSortedSet<E> of,E element,ImmutableSortedSet<E> of,E e1,E e2,ImmutableSortedSet<E> of,E e1,E e2,E e3,ImmutableSortedSet<E> of,E e1,E e2,E e3,E e4,ImmutableSortedSet<E> of,E e1,E e2,E e3,E e4,E e5,ImmutableSortedSet<E> of,E e1,E e2,E e3,E e4,E e5,E e6,E remaining){\r\n    int size = remaining.length + 6;\r\n    List<E> all = new ArrayList<E>(size);\r\n    Collections.addAll(all, e1, e2, e3, e4, e5, e6);\r\n    Collections.addAll(all, remaining);\r\n    return ofInternal(Ordering.natural(), (E[]) all.toArray(new Comparable[0]));\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableTable.put",
	"Comment": "guaranteed to throw an exception and leave the table unmodified.",
	"Method": "void put(R row,C column,V value,BinaryOperator<V> merger,Builder<R, C, V> put,R rowKey,C columnKey,V value,Builder<R, C, V> put,Cell<? extends R, ? extends C, ? extends V> cell,V put,R rowKey,C columnKey,V value){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.collect.SetsTest.verifyLinkedHashSetContents",
	"Comment": "utility method to verify that the given linkedhashset is equal to and hashes identically to aset constructed with the elements in the given collection. also verifies that the ordering inthe set is the same as the ordering of the given contents.",
	"Method": "void verifyLinkedHashSetContents(LinkedHashSet<E> set,Collection<E> contents){\r\n    assertEquals(\"LinkedHashSet should have preserved order for iteration\", new ArrayList<E>(set), new ArrayList<E>(contents));\r\n    verifySetContents(set, contents);\r\n}"
}, {
	"Path": "com.google.common.collect.Platform.preservesInsertionOrderOnAddsSet",
	"Comment": "returns the platform preferred set implementation that preserves insertion order when used onlyfor insertions.",
	"Method": "Set<E> preservesInsertionOrderOnAddsSet(){\r\n    return Sets.newLinkedHashSet();\r\n}"
}, {
	"Path": "org.apache.dubbo.config.DubboShutdownHook.destroyAll",
	"Comment": "destroy all the resources, including registries and protocols.",
	"Method": "void destroyAll(){\r\n    if (!destroyed.compareAndSet(false, true)) {\r\n        return;\r\n    }\r\n    AbstractRegistryFactory.destroyAll();\r\n    destroyProtocols();\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableCollection.retainAll",
	"Comment": "guaranteed to throw an exception and leave the collection unmodified.",
	"Method": "boolean retainAll(Collection<?> elementsToKeep){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.base.Utf8Test.testIsWellFormed_1Byte",
	"Comment": "tests that round tripping of all two byte permutations work.",
	"Method": "void testIsWellFormed_1Byte(){\r\n    testBytes(1, EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT);\r\n}"
}, {
	"Path": "com.google.common.collect.AbstractTableReadTest.testColumnNull",
	"Comment": "this test assumes that the implementation does not support null keys.",
	"Method": "void testColumnNull(){\r\n    table = create(\"foo\", 1, 'a', \"bar\", 1, 'b', \"foo\", 3, 'c');\r\n    try {\r\n        table.column(null);\r\n        fail();\r\n    } catch (NullPointerException expected) {\r\n    }\r\n}"
}, {
	"Path": "com.google.common.eventbus.SubscriberRegistry.getSubscribers",
	"Comment": "gets an iterator representing an immutable snapshot of all subscribers to the given event atthe time this method is called.",
	"Method": "Iterator<Subscriber> getSubscribers(Object event){\r\n    ImmutableSet<Class<?>> eventTypes = flattenHierarchy(event.getClass());\r\n    List<Iterator<Subscriber>> subscriberIterators = Lists.newArrayListWithCapacity(eventTypes.size());\r\n    for (Class<?> eventType : eventTypes) {\r\n        CopyOnWriteArraySet<Subscriber> eventSubscribers = subscribers.get(eventType);\r\n        if (eventSubscribers != null) {\r\n            subscriberIterators.add(eventSubscribers.iterator());\r\n        }\r\n    }\r\n    return Iterators.concat(subscriberIterators.iterator());\r\n}"
}, {
	"Path": "com.zaxxer.hikari.pool.HikariPool.getPoolStats",
	"Comment": "create a poolstats instance that will be used by metrics tracking, with a pollable resolution of 1 second.",
	"Method": "PoolStats getPoolStats(){\r\n    return new PoolStats(SECONDS.toMillis(1)) {\r\n        @Override\r\n        protected void update() {\r\n            this.pendingThreads = HikariPool.this.getThreadsAwaitingConnection();\r\n            this.idleConnections = HikariPool.this.getIdleConnections();\r\n            this.totalConnections = HikariPool.this.getTotalConnections();\r\n            this.activeConnections = HikariPool.this.getActiveConnections();\r\n            this.maxConnections = config.getMaximumPoolSize();\r\n            this.minConnections = config.getMinimumIdle();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.zaxxer.hikari.pool.HikariPool.getPoolStats",
	"Comment": "create a poolstats instance that will be used by metrics tracking, with a pollable resolution of 1 second.",
	"Method": "PoolStats getPoolStats(){\r\n    this.pendingThreads = HikariPool.this.getThreadsAwaitingConnection();\r\n    this.idleConnections = HikariPool.this.getIdleConnections();\r\n    this.totalConnections = HikariPool.this.getTotalConnections();\r\n    this.activeConnections = HikariPool.this.getActiveConnections();\r\n    this.maxConnections = config.getMaximumPoolSize();\r\n    this.minConnections = config.getMinimumIdle();\r\n}"
}, {
	"Path": "com.google.common.collect.MultimapsTest.prepareUnmodifiableTests",
	"Comment": "prepares the multimap for unmodifiable tests, returning an unmodifiable view of the map.",
	"Method": "Multimap<String, Integer> prepareUnmodifiableTests(Multimap<String, Integer> multimap,boolean permitsDuplicates,String nullKey,Integer nullValue){\r\n    multimap.clear();\r\n    multimap.put(\"foo\", 1);\r\n    multimap.put(\"foo\", 2);\r\n    multimap.put(\"foo\", 3);\r\n    multimap.put(\"bar\", 5);\r\n    multimap.put(\"bar\", -1);\r\n    multimap.put(nullKey, nullValue);\r\n    multimap.put(\"foo\", nullValue);\r\n    multimap.put(nullKey, 5);\r\n    multimap.put(\"foo\", 2);\r\n    if (permitsDuplicates) {\r\n        assertEquals(9, multimap.size());\r\n    } else {\r\n        assertEquals(8, multimap.size());\r\n    }\r\n    Multimap<String, Integer> unmodifiable;\r\n    if (multimap instanceof SortedSetMultimap) {\r\n        unmodifiable = Multimaps.unmodifiableSortedSetMultimap((SortedSetMultimap<String, Integer>) multimap);\r\n    } else if (multimap instanceof SetMultimap) {\r\n        unmodifiable = Multimaps.unmodifiableSetMultimap((SetMultimap<String, Integer>) multimap);\r\n    } else if (multimap instanceof ListMultimap) {\r\n        unmodifiable = Multimaps.unmodifiableListMultimap((ListMultimap<String, Integer>) multimap);\r\n    } else {\r\n        unmodifiable = Multimaps.unmodifiableMultimap(multimap);\r\n    }\r\n    return unmodifiable;\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AbstractFuture.get",
	"Comment": "forwardingfluentfuture needs to override those methods, so they are not final.",
	"Method": "V get(V get,long timeout,TimeUnit unit,V get,long timeout,TimeUnit unit,V get){\r\n    checkNotNull(unit);\r\n    return get();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.leave",
	"Comment": "leaves this monitor. may be called only by a thread currently occupying this monitor.",
	"Method": "void leave(){\r\n    final ReentrantLock lock = this.lock;\r\n    try {\r\n        if (lock.getHoldCount() == 1) {\r\n            signalNextWaiter();\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.util.TypesTest.testCanonicalizeRequiresOwnerTypes",
	"Comment": "ensure that owning types are required when necessary, and forbidden otherwise.",
	"Method": "void testCanonicalizeRequiresOwnerTypes(){\r\n    try {\r\n        Types.newParameterizedType(Owning.class, String.class);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n        assertContains(expected.getMessage(), \"No owner type for enclosed \" + Owning.class);\r\n    }\r\n    try {\r\n        Types.newParameterizedTypeWithOwner(Object.class, Set.class, String.class);\r\n        fail(\"Expected IllegalArgumentException\");\r\n    } catch (IllegalArgumentException expected) {\r\n        assertContains(expected.getMessage(), \"Owner type for unenclosed \" + Set.class);\r\n    }\r\n}"
}, {
	"Path": "com.google.inject.servlet.ServletTestUtils.newFakeHttpSession",
	"Comment": "returns a fake, serializable httpsession which stores attributes in a hashmap.",
	"Method": "HttpSession newFakeHttpSession(){\r\n    return (HttpSession) Proxy.newProxyInstance(HttpSession.class.getClassLoader(), new Class[] { HttpSession.class }, new FakeHttpSessionHandler());\r\n}"
}, {
	"Path": "com.google.common.testing.EqualsTesterTest.testTestEqualsEmptyLists",
	"Comment": "test equalstester with no equals or not equals objects. this checks proper handling of null,incompatible class and reflexive tests",
	"Method": "void testTestEqualsEmptyLists(){\r\n    equalsTester.addEqualityGroup(reference);\r\n    equalsTester.testEquals();\r\n}"
}, {
	"Path": "com.google.common.collect.IteratorsTest.testConcatContainingNull",
	"Comment": "illustrates the somewhat bizarre behavior when a null is passed in.",
	"Method": "void testConcatContainingNull(){\r\n    @SuppressWarnings(\"unchecked\")\r\n    Iterator<Iterator<Integer>> input = asList(iterateOver(1, 2), null, iterateOver(3)).iterator();\r\n    Iterator<Integer> result = Iterators.concat(input);\r\n    assertEquals(1, (int) result.next());\r\n    assertEquals(2, (int) result.next());\r\n    try {\r\n        result.hasNext();\r\n        fail(\"no exception thrown\");\r\n    } catch (NullPointerException e) {\r\n    }\r\n    try {\r\n        result.next();\r\n        fail(\"no exception thrown\");\r\n    } catch (NullPointerException e) {\r\n    }\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.AtomicDoubleArrayTest.testCompareAndSet",
	"Comment": "compareandset succeeds in changing value if equal to expected else fails",
	"Method": "void testCompareAndSet(){\r\n    AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\r\n    for (int i : new int[] { 0, SIZE - 1 }) {\r\n        double prev = 0.0;\r\n        double unused = Math.E + Math.PI;\r\n        for (double x : VALUES) {\r\n            assertBitEquals(prev, aa.get(i));\r\n            assertFalse(aa.compareAndSet(i, unused, x));\r\n            assertBitEquals(prev, aa.get(i));\r\n            assertTrue(aa.compareAndSet(i, prev, x));\r\n            assertBitEquals(x, aa.get(i));\r\n            prev = x;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.collect.ImmutableList.remove",
	"Comment": "guaranteed to throw an exception and leave the list unmodified.",
	"Method": "E remove(int index){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.google.common.util.concurrent.Monitor.enterWhen",
	"Comment": "enters this monitor when the guard is satisfied. blocks at most the given time, including boththe time to acquire the lock and the time to wait for the guard to be satisfied, and may beinterrupted.",
	"Method": "void enterWhen(Guard guard,boolean enterWhen,Guard guard,long time,TimeUnit unit){\r\n    final long timeoutNanos = toSafeNanos(time, unit);\r\n    if (guard.monitor != this) {\r\n        throw new IllegalMonitorStateException();\r\n    }\r\n    final ReentrantLock lock = this.lock;\r\n    boolean reentrant = lock.isHeldByCurrentThread();\r\n    long startTime = 0L;\r\n    locked: {\r\n        if (!fair) {\r\n            if (Thread.interrupted()) {\r\n                throw new InterruptedException();\r\n            }\r\n            if (lock.tryLock()) {\r\n                break locked;\r\n            }\r\n        }\r\n        startTime = initNanoTime(timeoutNanos);\r\n        if (!lock.tryLock(time, unit)) {\r\n            return false;\r\n        }\r\n    }\r\n    boolean satisfied = false;\r\n    boolean threw = true;\r\n    try {\r\n        satisfied = guard.isSatisfied() || awaitNanos(guard, (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos), reentrant);\r\n        threw = false;\r\n        return satisfied;\r\n    } finally {\r\n        if (!satisfied) {\r\n            try {\r\n                if (threw && !reentrant) {\r\n                    signalNextWaiter();\r\n                }\r\n            } finally {\r\n                lock.unlock();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.common.hash.FarmHashFingerprint64.weakHashLength32WithSeeds",
	"Comment": "computes intermediate hash of 32 bytes of byte array from the given offset. results arereturned in the output array because when we last measured, this was 12% faster than allocatingnew arrays every time.",
	"Method": "void weakHashLength32WithSeeds(byte[] bytes,int offset,long seedA,long seedB,long[] output){\r\n    long part1 = load64(bytes, offset);\r\n    long part2 = load64(bytes, offset + 8);\r\n    long part3 = load64(bytes, offset + 16);\r\n    long part4 = load64(bytes, offset + 24);\r\n    seedA += part1;\r\n    seedB = rotateRight(seedB + seedA + part4, 21);\r\n    long c = seedA;\r\n    seedA += part2;\r\n    seedA += part3;\r\n    seedB += rotateRight(seedA, 44);\r\n    output[0] = seedA + part4;\r\n    output[1] = seedB + c;\r\n}"
}]