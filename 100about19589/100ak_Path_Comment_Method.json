[{
	"Path": "sun.nio.ch.NativeObject.getLong",
	"Comment": "reads a long starting at the given offset from base of this nativeobject.",
	"Method": "long getLong(int offset){\r\n    return unsafe.getLong(offset + address);\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testAddAll2_IndexOutOfBoundsException",
	"Comment": "addall throws an indexoutofboundsexception on a too high index",
	"Method": "void testAddAll2_IndexOutOfBoundsException(){\r\n    CopyOnWriteArrayList c = populatedArray(5);\r\n    List[] lists = { c, c.subList(1, c.size() - 1) };\r\n    for (List list : lists) {\r\n        try {\r\n            list.addAll(list.size() + 1, new LinkedList());\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testAwait_IMSE",
	"Comment": "calling await without holding sync throws illegalmonitorstateexception",
	"Method": "void testAwait_IMSE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    for (AwaitMethod awaitMethod : AwaitMethod.values()) {\r\n        long startTime = System.nanoTime();\r\n        try {\r\n            await(c, awaitMethod);\r\n            shouldThrow();\r\n        } catch (IllegalMonitorStateException success) {\r\n        } catch (InterruptedException e) {\r\n            threadUnexpectedException(e);\r\n        }\r\n        assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n    }\r\n}"
}, {
	"Path": "java.text.DigitList.fitsIntoLong",
	"Comment": "return true if the number represented by this object can fit intoa long.",
	"Method": "boolean fitsIntoLong(boolean isPositive,boolean ignoreNegativeZero){\r\n    while (count > 0 && digits[count - 1] == '0') {\r\n        --count;\r\n    }\r\n    if (count == 0) {\r\n        return isPositive || ignoreNegativeZero;\r\n    }\r\n    if (decimalAt < count || decimalAt > MAX_COUNT) {\r\n        return false;\r\n    }\r\n    if (decimalAt < MAX_COUNT)\r\n        return true;\r\n    for (int i = 0; i < count; ++i) {\r\n        char dig = digits[i], max = LONG_MIN_REP[i];\r\n        if (dig > max)\r\n            return false;\r\n        if (dig < max)\r\n            return true;\r\n    }\r\n    if (count < decimalAt)\r\n        return true;\r\n    return !isPositive;\r\n}"
}, {
	"Path": "jsr166.ThreadLocalTest.testRemoveITL",
	"Comment": "remove in inheritablethreadlocal causes next access to returninitial value",
	"Method": "void testRemoveITL(){\r\n    assertSame(itl.get(), zero);\r\n    itl.set(two);\r\n    assertSame(itl.get(), two);\r\n    itl.remove();\r\n    assertSame(itl.get(), zero);\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testScheduleAtFixedRate1_RejectedExecutionException",
	"Comment": "scheduleatfixedrate throws rejectedexecutionexception if shutdown",
	"Method": "void testScheduleAtFixedRate1_RejectedExecutionException(){\r\n    final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        try {\r\n            p.shutdown();\r\n            p.scheduleAtFixedRate(new NoOpRunnable(), MEDIUM_DELAY_MS, MEDIUM_DELAY_MS, MILLISECONDS);\r\n            shouldThrow();\r\n        } catch (RejectedExecutionException success) {\r\n        } catch (SecurityException ok) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.net.InetAddress.isMCGlobal",
	"Comment": "utility routine to check if the multicast address has global scope.",
	"Method": "boolean isMCGlobal(){\r\n    return false;\r\n}"
}, {
	"Path": "javax.net.ssl.SSLParameters.setUseCipherSuitesOrder",
	"Comment": "sets whether the local cipher suites preference should be honored.",
	"Method": "void setUseCipherSuitesOrder(boolean honorOrder){\r\n    this.preferLocalCipherSuites = honorOrder;\r\n}"
}, {
	"Path": "java.util.stream.IntStream.of",
	"Comment": "returns a sequential ordered stream whose elements are the specified values.",
	"Method": "IntStream of(int t,IntStream of,int values){\r\n    return Arrays.stream(values);\r\n}"
}, {
	"Path": "com.google.mockwebserver.MockWebServer.takeRequest",
	"Comment": "awaits the next http request, removes it, and returns it. callers shoulduse this to verify the request sent was as intended.",
	"Method": "RecordedRequest takeRequest(){\r\n    return requestQueue.take();\r\n}"
}, {
	"Path": "sun.security.x509.AuthorityInfoAccessExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(DESCRIPTIONS);\r\n    return elements.elements();\r\n}"
}, {
	"Path": "java.util.TimSort.ensureCapacity",
	"Comment": "ensures that the external array tmp has at least the specifiednumber of elements, increasing its size if necessary.the sizeincreases exponentially to ensure amortized linear time complexity.",
	"Method": "T[] ensureCapacity(int minCapacity){\r\n    if (tmpLen < minCapacity) {\r\n        int newSize = minCapacity;\r\n        newSize |= newSize >> 1;\r\n        newSize |= newSize >> 2;\r\n        newSize |= newSize >> 4;\r\n        newSize |= newSize >> 8;\r\n        newSize |= newSize >> 16;\r\n        newSize++;\r\n        if (newSize < 0)\r\n            newSize = minCapacity;\r\n        else\r\n            newSize = Math.min(newSize, a.length >>> 1);\r\n        @SuppressWarnings({ \"unchecked\", \"UnnecessaryLocalVariable\" })\r\n        T[] newArray = (T[]) java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), newSize);\r\n        tmp = newArray;\r\n        tmpLen = newSize;\r\n        tmpBase = 0;\r\n    }\r\n    return tmp;\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testSchedule3_RejectedExecutionException",
	"Comment": "schedule callable throws rejectedexecutionexception if shutdown",
	"Method": "void testSchedule3_RejectedExecutionException(){\r\n    final CustomExecutor p = new CustomExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        try {\r\n            p.shutdown();\r\n            p.schedule(new NoOpCallable(), MEDIUM_DELAY_MS, MILLISECONDS);\r\n            shouldThrow();\r\n        } catch (RejectedExecutionException success) {\r\n        } catch (SecurityException ok) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.j2objc.net.IosHttpURLConnection.secureConnectionException",
	"Comment": "returns an sslexception if that class is linked into the application,otherwise ioexception.",
	"Method": "IOException secureConnectionException(String description){\r\n    try {\r\n        Class<?> sslExceptionClass = Class.forName(\"javax.net.ssl.SSLException\");\r\n        Constructor<?> constructor = sslExceptionClass.getConstructor(String.class);\r\n        return (IOException) constructor.newInstance(description);\r\n    } catch (ClassNotFoundException e) {\r\n        return new IOException(description);\r\n    } catch (Exception e) {\r\n        throw new AssertionError(\"unexpected exception\", e);\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.BuildStep.getIssuerName",
	"Comment": "return string form of issuer name from certificate associated with thisbuild step, or a default name if no certificate associated with thisbuild step, or if issuer name could not be obtained from the certificate.",
	"Method": "String getIssuerName(String getIssuerName,String defaultName){\r\n    return (cert == null ? defaultName : cert.getIssuerX500Principal().toString());\r\n}"
}, {
	"Path": "java.security.MessageDigest.getInstance",
	"Comment": "returns a messagedigest object that implements the specified digestalgorithm. a new messagedigest object encapsulating themessagedigestspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "MessageDigest getInstance(String algorithm,MessageDigest getInstance,String algorithm,String provider,MessageDigest getInstance,String algorithm,Provider provider){\r\n    if (provider == null)\r\n        throw new IllegalArgumentException(\"missing provider\");\r\n    Object[] objs = Security.getImpl(algorithm, \"MessageDigest\", provider);\r\n    if (objs[0] instanceof MessageDigest) {\r\n        MessageDigest md = (MessageDigest) objs[0];\r\n        md.provider = (Provider) objs[1];\r\n        return md;\r\n    } else {\r\n        MessageDigest delegate = new Delegate((MessageDigestSpi) objs[0], algorithm);\r\n        delegate.provider = (Provider) objs[1];\r\n        return delegate;\r\n    }\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testIndexOf2",
	"Comment": "indexof gives the index based on the given indexat which to start searching",
	"Method": "void testIndexOf2(){\r\n    CopyOnWriteArrayList full = populatedArray(3);\r\n    assertEquals(1, full.indexOf(one, 0));\r\n    assertEquals(-1, full.indexOf(one, 2));\r\n}"
}, {
	"Path": "android.icu.dev.test.rbbi.RBBIAPITest.doTest",
	"Comment": "internal subroutine used for comparision of expected and acquired results",
	"Method": "void doTest(String testString,int start,int gotoffset,int expectedOffset,String expectedString){\r\n    String selected;\r\n    String expected = expectedString;\r\n    if (gotoffset != expectedOffset)\r\n        errln(\"ERROR:****returned #\" + gotoffset + \" instead of #\" + expectedOffset);\r\n    if (start <= gotoffset) {\r\n        selected = testString.substring(start, gotoffset);\r\n    } else {\r\n        selected = testString.substring(gotoffset, start);\r\n    }\r\n    if (!selected.equals(expected))\r\n        errln(\"ERROR:****selected \\\"\" + selected + \"\\\" instead of \\\"\" + expected + \"\\\"\");\r\n    else\r\n        logln(\"****selected \\\"\" + selected + \"\\\"\");\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSubMapTest.testReplaceValue2",
	"Comment": "replace value succeeds when the given key mapped to expected value",
	"Method": "void testReplaceValue2(){\r\n    ConcurrentNavigableMap map = map5();\r\n    assertEquals(\"A\", map.get(one));\r\n    assertTrue(map.replace(one, \"A\", \"Z\"));\r\n    assertEquals(\"Z\", map.get(one));\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testQuietlyCompleteRoot",
	"Comment": "quietlycompleteroot completes root task and only root task",
	"Method": "void testQuietlyCompleteRoot(){\r\n    NoopCC a = new NoopCC();\r\n    NoopCC b = new NoopCC(a);\r\n    NoopCC c = new NoopCC(b);\r\n    a.setPendingCount(1);\r\n    b.setPendingCount(1);\r\n    c.setPendingCount(1);\r\n    c.quietlyCompleteRoot();\r\n    assertTrue(a.isDone());\r\n    assertFalse(b.isDone());\r\n    assertFalse(c.isDone());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.ClassFile.getConstructor",
	"Comment": "returns the procyon method definition for a specified constructor,or null if not found.",
	"Method": "ConstructorDeclaration getConstructor(String signature){\r\n    for (EntityDeclaration node : type.getMembers()) {\r\n        if (node.getEntityType() == EntityType.CONSTRUCTOR) {\r\n            ConstructorDeclaration cons = (ConstructorDeclaration) node;\r\n            if (signature.equals(signature(cons))) {\r\n                return cons;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.util.logging.ConsoleHandler.close",
	"Comment": "override streamhandler.close to do a flush but notto close the output stream.that is, we do notclose system.err.",
	"Method": "void close(){\r\n    flush();\r\n}"
}, {
	"Path": "java.io.LineNumberReader.readLine",
	"Comment": "read a line of text.whenever a line terminator isread the current line number is incremented.",
	"Method": "String readLine(){\r\n    synchronized (lock) {\r\n        String l = super.readLine(skipLF);\r\n        skipLF = false;\r\n        if (l != null)\r\n            lineNumber++;\r\n        return l;\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigDecimalConvertTest.testToEngineeringStringPos",
	"Comment": "convert a positive bigdecimal to an engineering string representation",
	"Method": "void testToEngineeringStringPos(){\r\n    String a = \"123809648392384754573567356745735.63567890295784902768787678287E-501\";\r\n    BigDecimal aNumber = new BigDecimal(a);\r\n    String result = \"123.80964839238475457356735674573563567890295784902768787678287E-471\";\r\n    assertEquals(\"incorrect value\", result, aNumber.toEngineeringString());\r\n}"
}, {
	"Path": "java.util.concurrent.ThreadPoolExecutor.ensurePrestart",
	"Comment": "same as prestartcorethread except arranges that at least onethread is started even if corepoolsize is 0.",
	"Method": "void ensurePrestart(){\r\n    int wc = workerCountOf(ctl.get());\r\n    if (wc < corePoolSize)\r\n        addWorker(null, true);\r\n    else if (wc == 0)\r\n        addWorker(null, false);\r\n}"
}, {
	"Path": "java.security.Provider.toString",
	"Comment": "returns a string with the name and the version numberof this provider.",
	"Method": "String toString(String toString,String toString){\r\n    return name + \" version \" + version;\r\n}"
}, {
	"Path": "java.util.TreeSet.iterator",
	"Comment": "returns an iterator over the elements in this set in ascending order.",
	"Method": "Iterator<E> iterator(){\r\n    return m.navigableKeySet().iterator();\r\n}"
}, {
	"Path": "java.util.stream.AbstractShortCircuitTask.getLocalResult",
	"Comment": "retrieves the local result for this task.if this task is the root,retrieves the shared result instead.",
	"Method": "R getLocalResult(){\r\n    if (isRoot()) {\r\n        R answer = sharedResult.get();\r\n        return (answer == null) ? getEmptyResult() : answer;\r\n    } else\r\n        return super.getLocalResult();\r\n}"
}, {
	"Path": "java.util.EnumSet.allOf",
	"Comment": "creates an enum set containing all of the elements in the specifiedelement type.",
	"Method": "EnumSet<E> allOf(Class<E> elementType){\r\n    EnumSet<E> result = noneOf(elementType);\r\n    result.addAll();\r\n    return result;\r\n}"
}, {
	"Path": "libcore.java.util.Base64Test.assertRoundTrip",
	"Comment": "asserts that the given string decodes to the bytes, and that the bytes encodeto the given string.",
	"Method": "void assertRoundTrip(Encoder encoder,Decoder decoder,String encoded,byte[] bytes){\r\n    assertEquals(encoded, encoder.encodeToString(bytes));\r\n    assertArrayEquals(bytes, decoder.decode(encoded));\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test426074",
	"Comment": "interface parameterization inference problem with intersection types.",
	"Method": "void test426074(){\r\n    this.runConformTest(new String[] { \"X.java\", \"interface Functional<T> {\\n\" + \"    void foo(T t);\\n\" + \"}\\n\" + \"interface I { }\\n\" + \"public class X {\\n\" + \" public static void main(String[] args) {\\n\" + \"     Functional<? extends X> f = (Functional<? extends X> & I) (X c) -> {\\n\" + \"       System.out.println(\\\"main\\\");\\n\" + \"     };\\n\" + \"     f.foo(null);\\n\" + \"    }\\n\" + \"}\\n\" }, \"main\");\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testPoolSizeInvariants",
	"Comment": "configuration changes that allow core pool size greater thanmax pool size result in illegalargumentexception.",
	"Method": "void testPoolSizeInvariants(){\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(1, 1, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        for (int s = 1; s < 5; s++) {\r\n            p.setMaximumPoolSize(s);\r\n            p.setCorePoolSize(s);\r\n            try {\r\n                p.setMaximumPoolSize(s - 1);\r\n                shouldThrow();\r\n            } catch (IllegalArgumentException success) {\r\n            }\r\n            assertEquals(s, p.getCorePoolSize());\r\n            assertEquals(s, p.getMaximumPoolSize());\r\n            try {\r\n                p.setCorePoolSize(s + 1);\r\n            } catch (IllegalArgumentException success) {\r\n            }\r\n            assertEquals(s + 1, p.getCorePoolSize());\r\n            assertEquals(s, p.getMaximumPoolSize());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.normalizer.BasicTest.TestTibetan",
	"Comment": "the tibetan vowel sign aa, 0f71, was messed up prior tounicode version 2.1.9.once 2.1.9 or 3.0 is released, uncomment this test.",
	"Method": "void TestTibetan(){\r\n    String[][] decomp = { { \"?\", \"?\", \"???\" } };\r\n    String[][] compose = { { \"???\", \"???\", \"???\" } };\r\n    staticTest(Normalizer.NFD, decomp, 1);\r\n    staticTest(Normalizer.NFKD, decomp, 2);\r\n    staticTest(Normalizer.NFC, compose, 1);\r\n    staticTest(Normalizer.NFKC, compose, 2);\r\n}"
}, {
	"Path": "java.util.stream.AbstractTask.suggestTargetSize",
	"Comment": "returns a suggested target leaf size based on the initial size estimate.",
	"Method": "long suggestTargetSize(long sizeEstimate){\r\n    long est = sizeEstimate / LEAF_TARGET;\r\n    return est > 0L ? est : 1L;\r\n}"
}, {
	"Path": "android.icu.dev.test.util.LocaleMatcherTest.testExactMatches",
	"Comment": "if all the base languages are the same, then each sublocale matchesitself most closely",
	"Method": "void testExactMatches(){\r\n    String lastBase = \"\";\r\n    TreeSet<ULocale> sorted = new TreeSet<ULocale>();\r\n    for (ULocale loc : ULocale.getAvailableLocales()) {\r\n        String language = loc.getLanguage();\r\n        if (!lastBase.equals(language)) {\r\n            check(sorted);\r\n            sorted.clear();\r\n            lastBase = language;\r\n        }\r\n        sorted.add(loc);\r\n    }\r\n    check(sorted);\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicIntegerFieldUpdater.addAndGet",
	"Comment": "atomically adds the given value to the current value of the field ofthe given object managed by this updater.",
	"Method": "int addAndGet(T obj,int delta,int addAndGet,T obj,int delta){\r\n    int prev, next;\r\n    do {\r\n        prev = get(obj);\r\n        next = prev + delta;\r\n    } while (!compareAndSet(obj, prev, next));\r\n    return next;\r\n}"
}, {
	"Path": "java.net.Socks4Message.getErrorString",
	"Comment": "returns an error string corresponding to the given error value.",
	"Method": "String getErrorString(int error){\r\n    switch(error) {\r\n        case RETURN_FAILURE:\r\n            return \"Failure to connect to SOCKS server\";\r\n        case RETURN_CANNOT_CONNECT_TO_IDENTD:\r\n            return \"Unable to connect to identd to verify user\";\r\n        case RETURN_DIFFERENT_USER_IDS:\r\n            return \"Failure - user ids do not match\";\r\n        default:\r\n            return \"Success\";\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigDecimalArithmeticTest.testMultiplyMathContextDiffScaleNegPos",
	"Comment": "multiply two numbers of different scales using mathcontext",
	"Method": "void testMultiplyMathContextDiffScaleNegPos(){\r\n    String a = \"488757458676796558668876576576579097029810457634781384756794987\";\r\n    int aScale = -63;\r\n    String b = \"747233429293018787918347987234564568\";\r\n    int bScale = 63;\r\n    String c = \"3.6521591193960361339707130098174381429788164316E+98\";\r\n    int cScale = -52;\r\n    BigDecimal aNumber = new BigDecimal(new BigInteger(a), aScale);\r\n    BigDecimal bNumber = new BigDecimal(new BigInteger(b), bScale);\r\n    MathContext mc = new MathContext(47, RoundingMode.HALF_UP);\r\n    BigDecimal result = aNumber.multiply(bNumber, mc);\r\n    assertEquals(\"incorrect value\", c, result.toString());\r\n    assertEquals(\"incorrect scale\", cScale, result.scale());\r\n}"
}, {
	"Path": "android.icu.dev.test.format.DateFormatTest.TestBadInput135",
	"Comment": "verify the correct behavior when handling invalid input strings.",
	"Method": "void TestBadInput135(){\r\n    int[] looks = { DateFormat.SHORT, DateFormat.MEDIUM, DateFormat.LONG, DateFormat.FULL };\r\n    int looks_length = looks.length;\r\n    final String[] strings = { \"Mar 15\", \"Mar 15 1997\", \"asdf\", \"3/1/97 1:23:\", \"3/1/00 1:23:45 AM\" };\r\n    int strings_length = strings.length;\r\n    DateFormat full = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, Locale.US);\r\n    String expected = \"March 1, 2000 at 1:23:45 AM \";\r\n    for (int i = 0; i < strings_length; ++i) {\r\n        final String text = strings[i];\r\n        for (int j = 0; j < looks_length; ++j) {\r\n            int dateLook = looks[j];\r\n            for (int k = 0; k < looks_length; ++k) {\r\n                int timeLook = looks[k];\r\n                DateFormat df = DateFormat.getDateTimeInstance(dateLook, timeLook, Locale.US);\r\n                String prefix = text + \", \" + dateLook + \"/\" + timeLook + \": \";\r\n                try {\r\n                    Date when = df.parse(text);\r\n                    if (when == null) {\r\n                        errln(prefix + \"SHOULD NOT HAPPEN: parse returned null.\");\r\n                        continue;\r\n                    }\r\n                    if (when != null) {\r\n                        String format;\r\n                        format = full.format(when);\r\n                        logln(prefix + \"OK: \" + format);\r\n                        if (!format.substring(0, expected.length()).equals(expected)) {\r\n                            errln(\"FAIL: Expected <\" + expected + \">, but got <\" + format.substring(0, expected.length()) + \">\");\r\n                        }\r\n                    }\r\n                } catch (java.text.ParseException e) {\r\n                    logln(e.getMessage());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testSerialization",
	"Comment": "a serialized aqs deserializes with current state, but no queued threads",
	"Method": "void testSerialization(){\r\n    if (ReflectionUtil.isJreReflectionStripped()) {\r\n        return;\r\n    }\r\n    Mutex sync = new Mutex();\r\n    assertFalse(serialClone(sync).isHeldExclusively());\r\n    sync.acquire();\r\n    Thread t = newStartedThread(new InterruptedSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t);\r\n    assertTrue(sync.isHeldExclusively());\r\n    Mutex clone = serialClone(sync);\r\n    assertTrue(clone.isHeldExclusively());\r\n    assertHasExclusiveQueuedThreads(sync, t);\r\n    assertHasExclusiveQueuedThreads(clone, NO_THREADS);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n    sync.release();\r\n    assertFalse(sync.isHeldExclusively());\r\n    assertTrue(clone.isHeldExclusively());\r\n    assertHasExclusiveQueuedThreads(sync, NO_THREADS);\r\n    assertHasExclusiveQueuedThreads(clone, NO_THREADS);\r\n}"
}, {
	"Path": "java.text.AttributedString.attributeValuesMatch",
	"Comment": "returns whether all specified attributes have equal values in the runs with the given indices",
	"Method": "boolean attributeValuesMatch(Set attributes,int runIndex1,int runIndex2){\r\n    Iterator iterator = attributes.iterator();\r\n    while (iterator.hasNext()) {\r\n        Attribute key = (Attribute) iterator.next();\r\n        if (!valuesMatch(getAttribute(key, runIndex1), getAttribute(key, runIndex2))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "java.util.LinkedList.addFirst",
	"Comment": "inserts the specified element at the beginning of this list.",
	"Method": "void addFirst(E e){\r\n    linkFirst(e);\r\n}"
}, {
	"Path": "java.net.AbstractPlainSocketImpl.available",
	"Comment": "returns the number of bytes that can be read without blocking.",
	"Method": "int available(){\r\n    if (isClosedOrPending()) {\r\n        throw new IOException(\"Stream closed.\");\r\n    }\r\n    if (isConnectionReset()) {\r\n        return 0;\r\n    }\r\n    int n = 0;\r\n    try {\r\n        n = socketAvailable();\r\n        if (n == 0 && isConnectionResetPending()) {\r\n            setConnectionReset();\r\n        }\r\n    } catch (ConnectionResetException exc1) {\r\n        setConnectionResetPending();\r\n        try {\r\n            n = socketAvailable();\r\n            if (n == 0) {\r\n                setConnectionReset();\r\n            }\r\n        } catch (ConnectionResetException exc2) {\r\n        }\r\n    }\r\n    return n;\r\n}"
}, {
	"Path": "java.io.PushbackInputStream.reset",
	"Comment": "repositions this stream to the position at the time themark method was last called on this input stream. the method reset for classpushbackinputstream does nothing except throw anioexception.",
	"Method": "void reset(){\r\n    throw new IOException(\"mark/reset not supported\");\r\n}"
}, {
	"Path": "android.icu.dev.test.UTF16Util.appendCodePoint",
	"Comment": "method appendcodepoint. appends a code pointto a stringbuffer",
	"Method": "void appendCodePoint(StringBuffer buffer,int ch){\r\n    if (ch <= 0xffff) {\r\n        buffer.append((char) ch);\r\n    } else {\r\n        buffer.append((char) (0xd7c0 + (ch >> 10)));\r\n        buffer.append((char) (0xdc00 + (ch & 0x3ff)));\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.InitializationNormalizer.getInitLocation",
	"Comment": "finds the location in a constructor where init statements should be added.",
	"Method": "List<Statement> getInitLocation(MethodDeclaration node){\r\n    List<Statement> stmts = node.getBody().getStatements();\r\n    if (!stmts.isEmpty() && stmts.get(0) instanceof SuperConstructorInvocation) {\r\n        return stmts.subList(0, 1);\r\n    }\r\n    assert TypeUtil.isNone(ElementUtil.getDeclaringClass(node.getExecutableElement()).getSuperclass()) : \"Constructor didn't have a super() call.\";\r\n    return stmts.subList(0, 0);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test426086",
	"Comment": "method reference to an inherited method is invoked from sub class",
	"Method": "void test426086(){\r\n    this.runConformTest(new String[] { \"X.java\", \"interface Functional {\\n\" + \"    Long square(Integer a);\\n\" + \"}\\n\" + \"public class X {\\n\" + \"    static class Base {\\n\" + \"      private Long square(Integer a) {\\n\" + \"             return Long.valueOf(a*a);\\n\" + \"         } \\n\" + \"    }\\n\" + \"    static class SubClass extends Base {\\n\" + \"        public Long callSquare(Integer i) {\\n\" + \"            Functional fi = SubClass.super::square;\\n\" + \"            return fi.square(i);\\n\" + \"        }\\n\" + \"    }\\n\" + \"    public static void main(String argv[]) throws Exception {\\n\" + \"     System.out.println(new SubClass().callSquare(-3));\\n\" + \"    }\\n\" + \"}\\n\" }, \"9\");\r\n}"
}, {
	"Path": "java.util.Hashtable.equals",
	"Comment": "compares the specified object with this map for equality,as per the definition in the map interface.",
	"Method": "boolean equals(Object o,boolean equals,Object o){\r\n    if (o == this)\r\n        return true;\r\n    if (!(o instanceof Map))\r\n        return false;\r\n    Map<K, V> t = (Map<K, V>) o;\r\n    if (t.size() != size())\r\n        return false;\r\n    try {\r\n        Iterator<Map.Entry<K, V>> i = entrySet().iterator();\r\n        while (i.hasNext()) {\r\n            Map.Entry<K, V> e = i.next();\r\n            K key = e.getKey();\r\n            V value = e.getValue();\r\n            if (value == null) {\r\n                if (!(t.get(key) == null && t.containsKey(key)))\r\n                    return false;\r\n            } else {\r\n                if (!value.equals(t.get(key)))\r\n                    return false;\r\n            }\r\n        }\r\n    } catch (ClassCastException unused) {\r\n        return false;\r\n    } catch (NullPointerException unused) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.nio.channels.DatagramChannelTest.assertTimeout",
	"Comment": "fails if the difference between current time and start time is greaterthan timeout.",
	"Method": "void assertTimeout(long startTime,long timeout){\r\n    long currentTime = System.currentTimeMillis();\r\n    if ((currentTime - startTime) > timeout) {\r\n        fail(\"Timeout\");\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.CyclicBarrier.getParties",
	"Comment": "returns the number of parties required to trip this barrier.",
	"Method": "int getParties(){\r\n    return parties;\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceArrayTest.testWeakCompareAndSet",
	"Comment": "repeated weakcompareandset succeeds in changing value when equalto expected",
	"Method": "void testWeakCompareAndSet(){\r\n    AtomicReferenceArray aa = new AtomicReferenceArray(SIZE);\r\n    for (int i = 0; i < SIZE; i++) {\r\n        aa.set(i, one);\r\n        do {\r\n        } while (!aa.weakCompareAndSet(i, one, two));\r\n        do {\r\n        } while (!aa.weakCompareAndSet(i, two, m4));\r\n        assertSame(m4, aa.get(i));\r\n        do {\r\n        } while (!aa.weakCompareAndSet(i, m4, seven));\r\n        assertSame(seven, aa.get(i));\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testForkHelpQuiesceSingleton",
	"Comment": "helpquiesce returns when tasks are complete.getqueuedtaskcount returns 0 when quiescent",
	"Method": "void testForkHelpQuiesceSingleton(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib f = new AsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            helpQuiesce();\r\n            assertEquals(0, getQueuedTaskCount());\r\n            assertEquals(21, f.number);\r\n            checkCompletedNormally(f);\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testForkHelpQuiesceSingleton",
	"Comment": "helpquiesce returns when tasks are complete.getqueuedtaskcount returns 0 when quiescent",
	"Method": "void testForkHelpQuiesceSingleton(){\r\n    AsyncFib f = new AsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    helpQuiesce();\r\n    assertEquals(0, getQueuedTaskCount());\r\n    assertEquals(21, f.number);\r\n    checkCompletedNormally(f);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.text.Support_Format.findFields",
	"Comment": "finds attributes with regards to char index in thisattributedcharacteriterator, and puts them in a vector",
	"Method": "Vector<FieldContainer> findFields(AttributedCharacterIterator iterator){\r\n    Vector<FieldContainer> result = new Vector<FieldContainer>();\r\n    while (iterator.getIndex() != iterator.getEndIndex()) {\r\n        int start = iterator.getRunStart();\r\n        int end = iterator.getRunLimit();\r\n        Iterator<Attribute> it = iterator.getAttributes().keySet().iterator();\r\n        while (it.hasNext()) {\r\n            AttributedCharacterIterator.Attribute attribute = it.next();\r\n            Object value = iterator.getAttribute(attribute);\r\n            result.add(new FieldContainer(start, end, attribute, value));\r\n        }\r\n        iterator.setIndex(end);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.TypeDeclarationGeneratorTest.testEnumConstantAccessorMethods",
	"Comment": "verify that accessor methods for enum constants are generated on request.",
	"Method": "void testEnumConstantAccessorMethods(){\r\n    options.setStaticAccessorMethods(true);\r\n    String source = \"enum Test { ONE, TWO, EOF }\";\r\n    String translation = translateSourceFile(source, \"Test\", \"Test.h\");\r\n    assertTranslation(translation, \"+ (Test *)ONE;\");\r\n    assertTranslation(translation, \"+ (Test *)TWO;\");\r\n    assertTranslation(translation, \"+ (Test *)EOF_;\");\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testCreatePrivilegedCallableUsingCCLWithNoPrivs",
	"Comment": "without class loader permissions, creatingprivilegedcallableusingcurrentclassloader throws ace",
	"Method": "void testCreatePrivilegedCallableUsingCCLWithNoPrivs(){\r\n    Runnable r = new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            if (System.getSecurityManager() == null)\r\n                return;\r\n            try {\r\n                Executors.privilegedCallableUsingCurrentClassLoader(new NoOpCallable());\r\n                shouldThrow();\r\n            } catch (AccessControlException success) {\r\n            }\r\n        }\r\n    };\r\n    runWithoutPermissions(r);\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testCreatePrivilegedCallableUsingCCLWithNoPrivs",
	"Comment": "without class loader permissions, creatingprivilegedcallableusingcurrentclassloader throws ace",
	"Method": "void testCreatePrivilegedCallableUsingCCLWithNoPrivs(){\r\n    if (System.getSecurityManager() == null)\r\n        return;\r\n    try {\r\n        Executors.privilegedCallableUsingCurrentClassLoader(new NoOpCallable());\r\n        shouldThrow();\r\n    } catch (AccessControlException success) {\r\n    }\r\n}"
}, {
	"Path": "java.util.Locale.createConstant",
	"Comment": "this method must be called only for creating the locale. constants due to making shortcuts.",
	"Method": "Locale createConstant(String lang,String country){\r\n    BaseLocale base = BaseLocale.createInstance(lang, country);\r\n    return getInstance(base, null);\r\n}"
}, {
	"Path": "java.util.concurrent.ScheduledThreadPoolExecutor.reExecutePeriodic",
	"Comment": "requeues a periodic task unless current run state precludes it.same idea as delayedexecute except drops task rather than rejecting.",
	"Method": "void reExecutePeriodic(RunnableScheduledFuture<?> task){\r\n    if (canRunInCurrentRunState(true)) {\r\n        super.getQueue().add(task);\r\n        if (!canRunInCurrentRunState(true) && remove(task))\r\n            task.cancel(false);\r\n        else\r\n            ensurePrestart();\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.util.UnicodeMap.get",
	"Comment": "gets the value associated with a given code point.returns null, if there is no such value.",
	"Method": "T get(int codepoint,T get,String value){\r\n    if (UTF16.hasMoreCodePointsThan(value, 1)) {\r\n        if (stringMap == null) {\r\n            return null;\r\n        }\r\n        return stringMap.get(value);\r\n    }\r\n    return getValue(UTF16.charAt(value, 0));\r\n}"
}, {
	"Path": "java.util.zip.DeflaterOutputStream.close",
	"Comment": "writes remaining compressed data to the output stream and closes theunderlying stream.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        finish();\r\n        if (usesDefaultDeflater)\r\n            def.end();\r\n        out.close();\r\n        closed = true;\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.X509CertificatePair.generateCertificatePair",
	"Comment": "create a x509certificatepair from its encoding. uses cache lookupif possible.",
	"Method": "X509CertificatePair generateCertificatePair(byte[] encoded){\r\n    Object key = new Cache.EqualByteArray(encoded);\r\n    X509CertificatePair pair = cache.get(key);\r\n    if (pair != null) {\r\n        return pair;\r\n    }\r\n    pair = new X509CertificatePair(encoded);\r\n    key = new Cache.EqualByteArray(pair.encoded);\r\n    cache.put(key, pair);\r\n    return pair;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.StatementGeneratorTest.testStaticArrayInitializer",
	"Comment": "verify that static array initializers are rewritten as method calls.",
	"Method": "void testStaticArrayInitializer(){\r\n    String translation = translateSourceFile(\"public class Test { static int[] a = { 1, 2, 3 }; static char b[] = { '4', '5' }; }\", \"Test\", \"Test.m\");\r\n    assertTranslation(translation, \"JreStrongAssignAndConsume(&Test_a, \" + \"[IOSIntArray newArrayWithInts:(jint[]){ 1, 2, 3 } count:3]);\");\r\n    assertTranslation(translation, \"JreStrongAssignAndConsume(&Test_b, \" + \"[IOSCharArray newArrayWithChars:(jchar[]){ '4', '5' } count:2]);\");\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testSubList2_IndexOutOfBoundsException",
	"Comment": "sublist throws an indexoutofboundsexception on a too high index",
	"Method": "void testSubList2_IndexOutOfBoundsException(){\r\n    CopyOnWriteArrayList c = populatedArray(5);\r\n    List[] lists = { c, c.subList(1, c.size() - 1) };\r\n    for (List list : lists) {\r\n        try {\r\n            list.subList(0, list.size() + 1);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.Locale.getInstance",
	"Comment": "returns a locale constructed from the givenlanguage, country andvariant. if the same locale instanceis available in the cache, then that instance isreturned. otherwise, a new locale instance iscreated and cached.",
	"Method": "Locale getInstance(String language,String country,String variant,Locale getInstance,String language,String script,String country,String variant,LocaleExtensions extensions,Locale getInstance,BaseLocale baseloc,LocaleExtensions extensions){\r\n    LocaleKey key = new LocaleKey(baseloc, extensions);\r\n    return LOCALECACHE.get(key);\r\n}"
}, {
	"Path": "java.net.URL.hashCode",
	"Comment": "creates an integer suitable for hash table indexing.the hash code is based upon all the url components relevant for urlcomparison. as such, this operation is a blocking operation.",
	"Method": "int hashCode(){\r\n    if (hashCode != -1)\r\n        return hashCode;\r\n    hashCode = handler.hashCode(this);\r\n    return hashCode;\r\n}"
}, {
	"Path": "sun.security.util.Cache.newSoftMemoryCache",
	"Comment": "return a new memory cache with the specified maximum size, unlimitedlifetime for entries, with the values held by softreferences.",
	"Method": "Cache<K, V> newSoftMemoryCache(int size,Cache<K, V> newSoftMemoryCache,int size,int timeout){\r\n    return new MemoryCache(true, size, timeout);\r\n}"
}, {
	"Path": "java.io.WriteAbortedException.getMessage",
	"Comment": "produce the message and include the message from the nestedexception, if there is one.",
	"Method": "String getMessage(){\r\n    if (detail == null)\r\n        return super.getMessage();\r\n    else\r\n        return super.getMessage() + \"; \" + detail.toString();\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testRemove1_IndexOutOfBounds",
	"Comment": "remove throws an indexoutofboundsexception on a negative index",
	"Method": "void testRemove1_IndexOutOfBounds(){\r\n    CopyOnWriteArrayList c = populatedArray(5);\r\n    List[] lists = { c, c.subList(1, c.size() - 1) };\r\n    for (List list : lists) {\r\n        try {\r\n            list.remove(-1);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testSetThreadFactory",
	"Comment": "setthreadfactory sets the thread factory returned by getthreadfactory",
	"Method": "void testSetThreadFactory(){\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(1, 2, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        ThreadFactory threadFactory = new SimpleThreadFactory();\r\n        p.setThreadFactory(threadFactory);\r\n        assertSame(threadFactory, p.getThreadFactory());\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.URIName.nameConstraint",
	"Comment": "create the uriname object with the specified name constraint. uriname constraints syntax is different than subjectaltnames, etc. see4.2.1.11 of rfc 3280.",
	"Method": "URIName nameConstraint(DerValue value){\r\n    URI uri;\r\n    String name = value.getIA5String();\r\n    try {\r\n        uri = new URI(name);\r\n    } catch (URISyntaxException use) {\r\n        throw (IOException) new IOException(\"invalid URI name constraint:\" + name).initCause(use);\r\n    }\r\n    if (uri.getScheme() == null) {\r\n        String host = uri.getSchemeSpecificPart();\r\n        try {\r\n            DNSName hostDNS;\r\n            if (host.charAt(0) == '.') {\r\n                hostDNS = new DNSName(host.substring(1));\r\n            } else {\r\n                hostDNS = new DNSName(host);\r\n            }\r\n            return new URIName(uri, host, hostDNS);\r\n        } catch (IOException ioe) {\r\n            throw (IOException) new IOException(\"invalid URI name constraint:\" + name).initCause(ioe);\r\n        }\r\n    } else {\r\n        throw new IOException(\"invalid URI name constraint (should not \" + \"include scheme):\" + name);\r\n    }\r\n}"
}, {
	"Path": "java.text.DecimalFormat.getMultiplier",
	"Comment": "gets the multiplier for use in percent, per mille, and similarformats.",
	"Method": "int getMultiplier(){\r\n    return multiplier;\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.getDecimalSeparator",
	"Comment": "gets the character used for decimal sign. different for french, etc.",
	"Method": "char getDecimalSeparator(){\r\n    return decimalSeparator;\r\n}"
}, {
	"Path": "jsr166.AtomicLongArrayTest.testAddAndGet",
	"Comment": "addandget adds given value to current, and returns current value",
	"Method": "void testAddAndGet(){\r\n    AtomicLongArray aa = new AtomicLongArray(SIZE);\r\n    for (int i = 0; i < SIZE; i++) {\r\n        aa.set(i, 1);\r\n        assertEquals(3, aa.addAndGet(i, 2));\r\n        assertEquals(3, aa.get(i));\r\n        assertEquals(-1, aa.addAndGet(i, -4));\r\n        assertEquals(-1, aa.get(i));\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testHasContended",
	"Comment": "hascontended reports false if no thread has ever blocked, else true",
	"Method": "void testHasContended(){\r\n    final Mutex sync = new Mutex();\r\n    assertFalse(sync.hasContended());\r\n    sync.acquire();\r\n    assertFalse(sync.hasContended());\r\n    Thread t1 = newStartedThread(new InterruptedSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t1);\r\n    assertTrue(sync.hasContended());\r\n    Thread t2 = newStartedThread(new InterruptibleSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t2);\r\n    assertTrue(sync.hasContended());\r\n    t1.interrupt();\r\n    awaitTermination(t1);\r\n    assertTrue(sync.hasContended());\r\n    sync.release();\r\n    awaitTermination(t2);\r\n    assertTrue(sync.hasContended());\r\n}"
}, {
	"Path": "java.util.ArrayDeque.clear",
	"Comment": "removes all of the elements from this deque.the deque will be empty after this call returns.",
	"Method": "void clear(){\r\n    int h = head;\r\n    int t = tail;\r\n    if (h != t) {\r\n        head = tail = 0;\r\n        int i = h;\r\n        int mask = elements.length - 1;\r\n        do {\r\n            elements[i] = null;\r\n            i = (i + 1) & mask;\r\n        } while (i != t);\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.PolicyMappingsExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(MAP);\r\n    return elements.elements();\r\n}"
}, {
	"Path": "java.text.ChoiceFormat.readObject",
	"Comment": "after reading an object from the input stream, do a simple verificationto maintain class invariants.",
	"Method": "void readObject(ObjectInputStream in){\r\n    in.defaultReadObject();\r\n    if (choiceLimits.length != choiceFormats.length) {\r\n        throw new InvalidObjectException(\"limits and format arrays of different length.\");\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testGetWaitingThreadsIMSE",
	"Comment": "getwaitingthreads throws illegalmonitorstateexception if not synced",
	"Method": "void testGetWaitingThreadsIMSE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    try {\r\n        sync.getWaitingThreads(c);\r\n        shouldThrow();\r\n    } catch (IllegalMonitorStateException success) {\r\n    }\r\n    assertHasWaitersUnlocked(sync, c, NO_THREADS);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.util.EventObjectTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    myObject = new Object();\r\n    myEventObject = new EventObject(myObject);\r\n}"
}, {
	"Path": "sun.security.x509.CertificateExtensions.hasUnsupportedCriticalExtension",
	"Comment": "return true if a critical extension is found that isnot supported, otherwise return false.",
	"Method": "boolean hasUnsupportedCriticalExtension(){\r\n    return unsupportedCritExt;\r\n}"
}, {
	"Path": "sun.security.x509.AlgorithmId.getEncodedParams",
	"Comment": "returns the der encoded parameter, which can then beused to initialize java.security.algorithmparamters.",
	"Method": "byte[] getEncodedParams(){\r\n    return (params == null) ? null : params.toByteArray();\r\n}"
}, {
	"Path": "java.security.CodeSigner.equals",
	"Comment": "tests for equality between the specified object and thiscode signer. two code signers are considered equal if theirsigner certificate paths are equal and if their timestamps are equal,if present in both.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == null || (!(obj instanceof CodeSigner))) {\r\n        return false;\r\n    }\r\n    CodeSigner that = (CodeSigner) obj;\r\n    if (this == that) {\r\n        return true;\r\n    }\r\n    Timestamp thatTimestamp = that.getTimestamp();\r\n    if (timestamp == null) {\r\n        if (thatTimestamp != null) {\r\n            return false;\r\n        }\r\n    } else {\r\n        if (thatTimestamp == null || (!timestamp.equals(thatTimestamp))) {\r\n            return false;\r\n        }\r\n    }\r\n    return signerCertPath.equals(that.getSignerCertPath());\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.testGet",
	"Comment": "get returns the correct element at the given key,or null if not present",
	"Method": "void testGet(){\r\n    ConcurrentSkipListMap map = map5();\r\n    assertEquals(\"A\", (String) map.get(one));\r\n    ConcurrentSkipListMap empty = new ConcurrentSkipListMap();\r\n    assertNull(empty.get(one));\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_diffBetweenDates",
	"Comment": "test to verify the difference between two given dates in terms of days, months and years",
	"Method": "void test_diffBetweenDates(ChronoLocalDate from,ChronoLocalDate to,long days,long months,long years){\r\n    assertEquals(from.until(to, ChronoUnit.DAYS), days);\r\n    assertEquals(from.until(to, ChronoUnit.MONTHS), months);\r\n    assertEquals(from.until(to, ChronoUnit.YEARS), years);\r\n}"
}, {
	"Path": "java.math.BigDecimal.checkScale",
	"Comment": "check a scale for underflow or overflow.if this bigdecimal isnonzero, throw an exception if the scale is outof range. if thisis zero, saturate the scale to the extreme value of the rightsign if the scale is out of range.",
	"Method": "int checkScale(long val,int checkScale,long intCompact,long val,int checkScale,BigInteger intVal,long val){\r\n    int asInt = (int) val;\r\n    if (asInt != val) {\r\n        asInt = val > Integer.MAX_VALUE ? Integer.MAX_VALUE : Integer.MIN_VALUE;\r\n        if (intVal.signum() != 0)\r\n            throw new ArithmeticException(asInt > 0 ? \"Underflow\" : \"Overflow\");\r\n    }\r\n    return asInt;\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes normally.iscompletedabnormally and iscancelled return false for normallycompleted tasks",
	"Method": "void testQuietlyInvoke(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib f = new AsyncFib(8);\r\n            f.quietlyInvoke();\r\n            assertEquals(21, f.number);\r\n            checkCompletedNormally(f);\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes normally.iscompletedabnormally and iscancelled return false for normallycompleted tasks",
	"Method": "void testQuietlyInvoke(){\r\n    AsyncFib f = new AsyncFib(8);\r\n    f.quietlyInvoke();\r\n    assertEquals(21, f.number);\r\n    checkCompletedNormally(f);\r\n}"
}, {
	"Path": "java.math.BigInteger.stripLeadingZeroInts",
	"Comment": "returns a copy of the input array stripped of any leading zero bytes.",
	"Method": "int[] stripLeadingZeroInts(int val){\r\n    int vlen = val.length;\r\n    int keep;\r\n    for (keep = 0; keep < vlen && val[keep] == 0; keep++) ;\r\n    return java.util.Arrays.copyOfRange(val, keep, vlen);\r\n}"
}, {
	"Path": "sun.security.provider.certpath.ForwardState.keyParamsNeeded",
	"Comment": "return boolean flag indicating whether a public key that needs to inheritkey parameters has been encountered.",
	"Method": "boolean keyParamsNeeded(){\r\n    return keyParamsNeededFlag;\r\n}"
}, {
	"Path": "java.sql.DataTruncation.getParameter",
	"Comment": "indicates whether the value truncated was a parameter value ora column value.",
	"Method": "boolean getParameter(){\r\n    return parameter;\r\n}"
}, {
	"Path": "java.util.logging.LogRecord.getResourceBundle",
	"Comment": "get the localization resource bundlethis is the resourcebundle that should be used to localizethe message string before formatting it.the result maybe null if the message is not localizable, or if no suitableresourcebundle is available.",
	"Method": "ResourceBundle getResourceBundle(){\r\n    return resourceBundle;\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.testReplaceValue",
	"Comment": "replace value fails when the given key not mapped to expected value",
	"Method": "void testReplaceValue(){\r\n    ConcurrentSkipListMap map = map5();\r\n    assertEquals(\"A\", map.get(one));\r\n    assertFalse(map.replace(one, \"Z\", \"Z\"));\r\n    assertEquals(\"A\", map.get(one));\r\n}"
}, {
	"Path": "java.math.BitSieve.sieveSingle",
	"Comment": "sieve a single set of multiples out of the sieve. begin to removemultiples of the specified step starting at the specified start index,up to the specified limit.",
	"Method": "void sieveSingle(int limit,int start,int step){\r\n    while (start < limit) {\r\n        set(start);\r\n        start += step;\r\n    }\r\n}"
}, {
	"Path": "sun.nio.ch.NativeObject.getInt",
	"Comment": "reads an int starting at the given offset from base of this nativeobject.",
	"Method": "int getInt(int offset){\r\n    return unsafe.getInt(offset + address);\r\n}"
}, {
	"Path": "javax.net.ssl.SSLEngine.getPeerPort",
	"Comment": "returns the port number of the peer.note that the value is not authenticated, and should not berelied upon.",
	"Method": "int getPeerPort(){\r\n    return peerPort;\r\n}"
}, {
	"Path": "java.util.Random.internalNextLong",
	"Comment": "the form of nextlong used by longstream spliterators.iforigin is greater than bound, acts as unbounded form ofnextlong, else as bounded form.",
	"Method": "long internalNextLong(long origin,long bound){\r\n    long r = nextLong();\r\n    if (origin < bound) {\r\n        long n = bound - origin, m = n - 1;\r\n        if ((n & m) == 0L)\r\n            r = (r & m) + origin;\r\n        else if (n > 0L) {\r\n            for (long u = r >>> 1; u + m - (r = u % n) < 0L; u = nextLong() >>> 1) ;\r\n            r += origin;\r\n        } else {\r\n            while (r < origin || r >= bound) r = nextLong();\r\n        }\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "jsr166.AbstractQueueTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    Succeed q = new Succeed();\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        q.addAll(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.multiply",
	"Comment": "multiply the contents of two mutablebiginteger objects. the result isplaced into mutablebiginteger z. the contents of y are not changed.",
	"Method": "void multiply(MutableBigInteger y,MutableBigInteger z){\r\n    int xLen = intLen;\r\n    int yLen = y.intLen;\r\n    int newLen = xLen + yLen;\r\n    if (z.value.length < newLen)\r\n        z.value = new int[newLen];\r\n    z.offset = 0;\r\n    z.intLen = newLen;\r\n    long carry = 0;\r\n    for (int j = yLen - 1, k = yLen + xLen - 1; j >= 0; j--, k--) {\r\n        long product = (y.value[j + y.offset] & LONG_MASK) * (value[xLen - 1 + offset] & LONG_MASK) + carry;\r\n        z.value[k] = (int) product;\r\n        carry = product >>> 32;\r\n    }\r\n    z.value[xLen - 1] = (int) carry;\r\n    for (int i = xLen - 2; i >= 0; i--) {\r\n        carry = 0;\r\n        for (int j = yLen - 1, k = yLen + i; j >= 0; j--, k--) {\r\n            long product = (y.value[j + y.offset] & LONG_MASK) * (value[i + offset] & LONG_MASK) + (z.value[k] & LONG_MASK) + carry;\r\n            z.value[k] = (int) product;\r\n            carry = product >>> 32;\r\n        }\r\n        z.value[i] = (int) carry;\r\n    }\r\n    z.normalize();\r\n}"
}, {
	"Path": "java.security.SecureRandom.getSeed",
	"Comment": "returns the given number of seed bytes, computed using the seedgeneration algorithm that this class uses to seed itself.thiscall may be used to seed other random number generators.this method is only included for backwards compatibility.the caller is encouraged to use one of the alternativegetinstance methods to obtain a securerandom object, andthen call the generateseed method to obtain seed bytesfrom that object.",
	"Method": "byte[] getSeed(int numBytes){\r\n    if (seedGenerator == null)\r\n        seedGenerator = new SecureRandom();\r\n    return seedGenerator.generateSeed(numBytes);\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerArrayTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    final AtomicIntegerArray a = new AtomicIntegerArray(1);\r\n    a.set(0, 1);\r\n    Thread t = new Thread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!a.compareAndSet(0, 2, 3)) Thread.yield();\r\n        }\r\n    });\r\n    t.start();\r\n    assertTrue(a.compareAndSet(0, 1, 2));\r\n    t.join(LONG_DELAY_MS);\r\n    assertFalse(t.isAlive());\r\n    assertEquals(3, a.get(0));\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerArrayTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    while (!a.compareAndSet(0, 2, 3)) Thread.yield();\r\n}"
}, {
	"Path": "libcore.javax.net.ssl.TestSSLContext.createSSLContext",
	"Comment": "create a sslcontext with a keymanager using the private key andcertificate chain from the given keystore and a trustmanagerusing the certificates authorities from the same keystore.",
	"Method": "SSLContext createSSLContext(String protocol,KeyManager[] keyManagers,TrustManager[] trustManagers){\r\n    try {\r\n        SSLContext context = SSLContext.getInstance(protocol);\r\n        context.init(keyManagers, trustManagers, new SecureRandom());\r\n        return context;\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "sun.util.calendar.CalendarSystem.forName",
	"Comment": "returns a calendarsystem specified by the calendarname. the calendar name has to be one of the supported calendarnames.",
	"Method": "CalendarSystem forName(String calendarName){\r\n    if (\"gregorian\".equals(calendarName)) {\r\n        return GregorianHolder.INSTANCE;\r\n    } else if (\"julian\".equals(calendarName)) {\r\n        return JulianHolder.INSTANCE;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "sun.util.calendar.CalendarDate.setEra",
	"Comment": "sets the era of the date to the specified era. the defaultimplementation of this method accepts any era value, includingnull.",
	"Method": "CalendarDate setEra(Era era){\r\n    if (this.era == era) {\r\n        return this;\r\n    }\r\n    this.era = era;\r\n    normalized = false;\r\n    return this;\r\n}"
}, {
	"Path": "java.lang.ThreadGroup.isDaemon",
	"Comment": "tests if this thread group is a daemon thread group. adaemon thread group is automatically destroyed when its lastthread is stopped or its last thread group is destroyed.",
	"Method": "boolean isDaemon(){\r\n    return daemon;\r\n}"
}, {
	"Path": "javax.crypto.Cipher.getExemptionMechanism",
	"Comment": "returns the exemption mechanism object used with this cipher.",
	"Method": "ExemptionMechanism getExemptionMechanism(){\r\n    updateProviderIfNeeded();\r\n    return exmech;\r\n}"
}, {
	"Path": "sun.security.pkcs.SignerInfo.verify",
	"Comment": "returns null if verify fails, this signerinfo if verify succeeds.",
	"Method": "SignerInfo verify(PKCS7 block,byte[] data,SignerInfo verify,PKCS7 block,InputStream inputStream,SignerInfo verify,PKCS7 block){\r\n    return verify(block, (byte[]) null);\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinTask.quietlyInvoke",
	"Comment": "commences performing this task and awaits its completion ifnecessary, without returning its result or throwing itsexception.",
	"Method": "void quietlyInvoke(){\r\n    doInvoke();\r\n}"
}, {
	"Path": "org.apache.harmony.tests.org.xml.sax.support.MethodLogger.getMethod",
	"Comment": "returns the name of the last method that was invoked. returns null if nomethod calls have been logged so far.",
	"Method": "String getMethod(int index,String getMethod){\r\n    return (size() == 0 ? null : getMethod(size() - 1));\r\n}"
}, {
	"Path": "android.icu.dev.test.format.RbnfTest.TestSwissFrenchSpellout",
	"Comment": "perform a simple spot check on the swiss french spellout rules",
	"Method": "void TestSwissFrenchSpellout(){\r\n    RuleBasedNumberFormat formatter = new RuleBasedNumberFormat(new Locale(\"fr\", \"CH\"), RuleBasedNumberFormat.SPELLOUT);\r\n    String[][] testData = { { \"1\", \"un\" }, { \"15\", \"quinze\" }, { \"20\", \"vingt\" }, { \"21\", \"vingt-et-un\" }, { \"23\", \"vingt-trois\" }, { \"62\", \"soixante-deux\" }, { \"70\", \"septante\" }, { \"71\", \"septante-et-un\" }, { \"73\", \"septante-trois\" }, { \"80\", \"huitante\" }, { \"88\", \"huitante-huit\" }, { \"100\", \"cent\" }, { \"106\", \"cent six\" }, { \"127\", \"cent vingt-sept\" }, { \"200\", \"deux cents\" }, { \"579\", \"cinq cent septante-neuf\" }, { \"1,000\", \"mille\" }, { \"1,123\", \"mille cent vingt-trois\" }, { \"1,594\", \"mille cinq cent nonante-quatre\" }, { \"2,000\", \"deux mille\" }, { \"3,004\", \"trois mille quatre\" }, { \"4,567\", \"quatre mille cinq cent soixante-sept\" }, { \"15,943\", \"quinze mille neuf cent quarante-trois\" }, { \"2,345,678\", \"deux millions trois cent quarante-cinq mille \" + \"six cent septante-huit\" }, { \"-36\", \"moins trente-six\" }, { \"234.567\", \"deux cent trente-quatre virgule cinq six sept\" } };\r\n    doTest(formatter, testData, true);\r\n}"
}, {
	"Path": "java.beans.ChangeListenerMap.remove",
	"Comment": "removes a listener from the list of listeners for the specified property.if the listener was added more than once to the same event source,this listener will be notified one less time after being removed.",
	"Method": "void remove(String name,L listener){\r\n    if (this.map != null) {\r\n        L[] array = this.map.get(name);\r\n        if (array != null) {\r\n            for (int i = 0; i < array.length; i++) {\r\n                if (listener.equals(array[i])) {\r\n                    int size = array.length - 1;\r\n                    if (size > 0) {\r\n                        L[] clone = newArray(size);\r\n                        System.arraycopy(array, 0, clone, 0, i);\r\n                        System.arraycopy(array, i + 1, clone, i, size - i);\r\n                        this.map.put(name, clone);\r\n                    } else {\r\n                        this.map.remove(name);\r\n                        if (this.map.isEmpty()) {\r\n                            this.map = null;\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.jca.ProviderList.removeInvalid",
	"Comment": "try to load all providers and return the providerlist. if one ormore providers could not be loaded, a new providerlist with thoseentries removed is returned. otherwise, the method returns this.",
	"Method": "ProviderList removeInvalid(){\r\n    int n = loadAll();\r\n    if (n == configs.length) {\r\n        return this;\r\n    }\r\n    ProviderConfig[] newConfigs = new ProviderConfig[n];\r\n    for (int i = 0, j = 0; i < configs.length; i++) {\r\n        ProviderConfig config = configs[i];\r\n        if (config.isLoaded()) {\r\n            newConfigs[j++] = config;\r\n        }\r\n    }\r\n    return new ProviderList(newConfigs, true);\r\n}"
}, {
	"Path": "java.text.DecimalFormat.getMinimumFractionDigits",
	"Comment": "gets the minimum number of digits allowed in the fraction portion of anumber.for formatting numbers other than biginteger andbigdecimal objects, the lower of the return value and340 is used.",
	"Method": "int getMinimumFractionDigits(){\r\n    return minimumFractionDigits;\r\n}"
}, {
	"Path": "java.util.concurrent.Phaser.abortWait",
	"Comment": "variant of releasewaiters that additionally tries to remove anynodes no longer waiting for advance due to timeout orinterrupt. currently, nodes are removed only if they are athead of queue, which suffices to reduce memory footprint inmost usages.",
	"Method": "int abortWait(int phase){\r\n    AtomicReference<QNode> head = (phase & 1) == 0 ? evenQ : oddQ;\r\n    for (; ; ) {\r\n        Thread t;\r\n        QNode q = head.get();\r\n        int p = (int) (root.state >>> PHASE_SHIFT);\r\n        if (q == null || ((t = q.thread) != null && q.phase == p))\r\n            return p;\r\n        if (head.compareAndSet(q, q.next) && t != null) {\r\n            q.thread = null;\r\n            LockSupport.unpark(t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.misc.FloatingDecimal.getBinaryToASCIIConverter",
	"Comment": "returns a binarytoasciiconverter for a double.the returned object is a threadlocal variable of this class.",
	"Method": "BinaryToASCIIConverter getBinaryToASCIIConverter(double d,BinaryToASCIIConverter getBinaryToASCIIConverter,double d,boolean isCompatibleFormat,BinaryToASCIIConverter getBinaryToASCIIConverter,float f){\r\n    int fBits = Float.floatToRawIntBits(f);\r\n    boolean isNegative = (fBits & FloatConsts.SIGN_BIT_MASK) != 0;\r\n    int fractBits = fBits & FloatConsts.SIGNIF_BIT_MASK;\r\n    int binExp = (fBits & FloatConsts.EXP_BIT_MASK) >> SINGLE_EXP_SHIFT;\r\n    if (binExp == (FloatConsts.EXP_BIT_MASK >> SINGLE_EXP_SHIFT)) {\r\n        if (fractBits == 0L) {\r\n            return isNegative ? B2AC_NEGATIVE_INFINITY : B2AC_POSITIVE_INFINITY;\r\n        } else {\r\n            return B2AC_NOT_A_NUMBER;\r\n        }\r\n    }\r\n    int nSignificantBits;\r\n    if (binExp == 0) {\r\n        if (fractBits == 0) {\r\n            return isNegative ? B2AC_NEGATIVE_ZERO : B2AC_POSITIVE_ZERO;\r\n        }\r\n        int leadingZeros = Integer.numberOfLeadingZeros(fractBits);\r\n        int shift = leadingZeros - (31 - SINGLE_EXP_SHIFT);\r\n        fractBits <<= shift;\r\n        binExp = 1 - shift;\r\n        nSignificantBits = 32 - leadingZeros;\r\n    } else {\r\n        fractBits |= SINGLE_FRACT_HOB;\r\n        nSignificantBits = SINGLE_EXP_SHIFT + 1;\r\n    }\r\n    binExp -= FloatConsts.EXP_BIAS;\r\n    BinaryToASCIIBuffer buf = getBinaryToASCIIBuffer();\r\n    buf.setSign(isNegative);\r\n    buf.dtoa(binExp, ((long) fractBits) << (EXP_SHIFT - SINGLE_EXP_SHIFT), nSignificantBits, true);\r\n    return buf;\r\n}"
}, {
	"Path": "sun.net.www.MessageHeader.multiValueIterator",
	"Comment": "return an iterator that returns all values of a particularkey in sequence",
	"Method": "Iterator<String> multiValueIterator(String k){\r\n    return new HeaderIterator(k, this);\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testTryUnfork",
	"Comment": "tryunfork returns true for most recent unexecuted task,and suppresses execution",
	"Method": "void testTryUnfork(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() {\r\n            FibTask g = new FibTask(9);\r\n            assertSame(g, g.fork());\r\n            FibTask f = new FibTask(8);\r\n            assertSame(f, f.fork());\r\n            assertTrue(f.tryUnfork());\r\n            helpQuiesce();\r\n            checkNotDone(f);\r\n            checkCompletedNormally(g, 34);\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(singletonPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testTryUnfork",
	"Comment": "tryunfork returns true for most recent unexecuted task,and suppresses execution",
	"Method": "void testTryUnfork(){\r\n    FibTask g = new FibTask(9);\r\n    assertSame(g, g.fork());\r\n    FibTask f = new FibTask(8);\r\n    assertSame(f, f.fork());\r\n    assertTrue(f.tryUnfork());\r\n    helpQuiesce();\r\n    checkNotDone(f);\r\n    checkCompletedNormally(g, 34);\r\n    return NoResult;\r\n}"
}, {
	"Path": "java.util.concurrent.ThreadPoolExecutor.getLargestPoolSize",
	"Comment": "returns the largest number of threads that have eversimultaneously been in the pool.",
	"Method": "int getLargestPoolSize(){\r\n    final ReentrantLock mainLock = this.mainLock;\r\n    mainLock.lock();\r\n    try {\r\n        return largestPoolSize;\r\n    } finally {\r\n        mainLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.Logger.config",
	"Comment": "log a config message.if the logger is currently enabled for the config messagelevel then the given message is forwarded to all theregistered output handler objects.",
	"Method": "void config(String msg){\r\n    if (Level.CONFIG.intValue() < levelValue) {\r\n        return;\r\n    }\r\n    log(Level.CONFIG, msg);\r\n}"
}, {
	"Path": "java.util.concurrent.ThreadPoolExecutor.advanceRunState",
	"Comment": "transitions runstate to given target, or leaves it alone ifalready at least the given target.",
	"Method": "void advanceRunState(int targetState){\r\n    for (; ; ) {\r\n        int c = ctl.get();\r\n        if (runStateAtLeast(c, targetState) || ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalInvoke",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvoke(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingCCF f = new LFCCF(8);\r\n            try {\r\n                f.invoke();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalInvoke",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvoke(){\r\n    FailingCCF f = new LFCCF(8);\r\n    try {\r\n        f.invoke();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "java.util.stream.Stream.concat",
	"Comment": "creates a lazily concatenated stream whose elements are all theelements of the first stream followed by all the elements of thesecond stream.the resulting stream is ordered if bothof the input streams are ordered, and parallel if either of the inputstreams is parallel.when the resulting stream is closed, the closehandlers for both input streams are invoked.",
	"Method": "Stream<T> concat(Stream<? extends T> a,Stream<? extends T> b){\r\n    Objects.requireNonNull(a);\r\n    Objects.requireNonNull(b);\r\n    @SuppressWarnings(\"unchecked\")\r\n    Spliterator<T> split = new Streams.ConcatSpliterator.OfRef((Spliterator<T>) a.spliterator(), (Spliterator<T>) b.spliterator());\r\n    Stream<T> stream = StreamSupport.stream(split, a.isParallel() || b.isParallel());\r\n    return stream.onClose(Streams.composedClose(a, b));\r\n}"
}, {
	"Path": "org.apache.harmony.beans.tests.java.beans.PropertyDescriptorTest.testSetReadMethod_ReadWriteIncompatible",
	"Comment": "read method is incompatible with write method getpropertyon vs.setpropertytow",
	"Method": "void testSetReadMethod_ReadWriteIncompatible(){\r\n    Class<MockJavaBean> beanClass = MockJavaBean.class;\r\n    String propertyName = \"PropertyOne\";\r\n    Method readMethod = beanClass.getMethod(\"get\" + \"PropertyOne\", (Class[]) null);\r\n    Method writeMethod = beanClass.getMethod(\"set\" + \"PropertyTwo\", new Class[] { Integer.class });\r\n    PropertyDescriptor pd = new PropertyDescriptor(propertyName, null, writeMethod);\r\n    assertNull(pd.getReadMethod());\r\n    try {\r\n        pd.setReadMethod(readMethod);\r\n        fail(\"Should throw IntrospectionException.\");\r\n    } catch (IntrospectionException e) {\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.MetadataWriter.getMethodModifiers",
	"Comment": "returns the modifiers for a specified method, including internal ones.all method modifiers are defined in the jvm specification, table 4.5.",
	"Method": "int getMethodModifiers(ExecutableElement method){\r\n    int modifiers = ElementUtil.fromModifierSet(method.getModifiers());\r\n    if (method.isVarArgs()) {\r\n        modifiers |= ElementUtil.ACC_VARARGS;\r\n    }\r\n    if (ElementUtil.isSynthetic(method)) {\r\n        modifiers |= ElementUtil.ACC_SYNTHETIC;\r\n    }\r\n    return modifiers;\r\n}"
}, {
	"Path": "java.net.URLStreamHandler.getDefaultPort",
	"Comment": "returns the default port for a url parsed by this handler. this methodis meant to be overidden by handlers with default port numbers.",
	"Method": "int getDefaultPort(){\r\n    return -1;\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testHasQueuedThreads",
	"Comment": "hasqueuedthreads reports whether there are waiting threads",
	"Method": "void testHasQueuedThreads(){\r\n    final Mutex sync = new Mutex();\r\n    assertFalse(sync.hasQueuedThreads());\r\n    sync.acquire();\r\n    Thread t1 = newStartedThread(new InterruptedSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t1);\r\n    assertTrue(sync.hasQueuedThreads());\r\n    Thread t2 = newStartedThread(new InterruptibleSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t2);\r\n    assertTrue(sync.hasQueuedThreads());\r\n    t1.interrupt();\r\n    awaitTermination(t1);\r\n    assertTrue(sync.hasQueuedThreads());\r\n    sync.release();\r\n    awaitTermination(t2);\r\n    assertFalse(sync.hasQueuedThreads());\r\n}"
}, {
	"Path": "java.security.cert.PKIXParameters.getDate",
	"Comment": "returns the time for which the validity of the certification pathshould be determined. if null, the current time is used.note that the date returned is copied to protect againstsubsequent modifications.",
	"Method": "Date getDate(){\r\n    if (date == null)\r\n        return null;\r\n    else\r\n        return (Date) this.date.clone();\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentLinkedDeque.updateHead",
	"Comment": "guarantees that any node which was unlinked before a call tothis method will be unreachable from head after it returns.does not guarantee to eliminate slack, only that head willpoint to a node that was active while this method was running.",
	"Method": "void updateHead(){\r\n    Node<E> h, p, q;\r\n    restartFromHead: while ((h = head).item == null && (p = h.prev) != null) {\r\n        for (; ; ) {\r\n            if ((q = p.prev) == null || (q = (p = q).prev) == null) {\r\n                if (casHead(h, p))\r\n                    return;\r\n                else\r\n                    continue restartFromHead;\r\n            } else if (h != head)\r\n                continue restartFromHead;\r\n            else\r\n                p = q;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.lang.Character.reverseBytes",
	"Comment": "returns the value obtained by reversing the order of the bytes in thespecified char value.",
	"Method": "char reverseBytes(char ch){\r\n    return (char) (((ch & 0xFF00) >> 8) | (ch << 8));\r\n}"
}, {
	"Path": "java.beans.IndexedPropertyDescriptor.equals",
	"Comment": "determines if this indexedpropertydescriptor is equal tothe specified object. two indexedpropertydescriptor s areequal if the reader, indexed reader, writer, indexed writer, propertytypes, indexed property type, property editor and flags are equal.",
	"Method": "boolean equals(Object obj){\r\n    if (!(obj instanceof IndexedPropertyDescriptor)) {\r\n        return false;\r\n    }\r\n    IndexedPropertyDescriptor other = (IndexedPropertyDescriptor) obj;\r\n    return (super.equals(other) && (indexedPropertyType == null ? other.indexedPropertyType == null : indexedPropertyType.equals(other.indexedPropertyType)) && (indexedGetter == null ? other.indexedGetter == null : indexedGetter.equals(other.indexedGetter)) && (indexedSetter == null ? other.indexedSetter == null : indexedSetter.equals(other.indexedSetter)));\r\n}"
}, {
	"Path": "sun.net.util.IPAddressUtil.textToNumericFormatV4",
	"Comment": "converts ipv4 address in its textual presentation forminto its numeric binary form.",
	"Method": "byte[] textToNumericFormatV4(String src){\r\n    if (src.length() == 0) {\r\n        return null;\r\n    }\r\n    byte[] res = new byte[INADDR4SZ];\r\n    String[] s = src.split(\"\\\\.\", -1);\r\n    long val;\r\n    try {\r\n        switch(s.length) {\r\n            case 4:\r\n                for (int i = 0; i < 4; i++) {\r\n                    val = Integer.parseInt(s[i]);\r\n                    if (val < 0 || val > 0xff)\r\n                        return null;\r\n                    res[i] = (byte) (val & 0xff);\r\n                }\r\n                break;\r\n            default:\r\n                return null;\r\n        }\r\n    } catch (NumberFormatException e) {\r\n        return null;\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "jsr166.TimeUnitTest.testToHours",
	"Comment": "tohours correctly converts sample values in different units tohours",
	"Method": "void testToHours(){\r\n    for (long t = 0; t < 88888; ++t) {\r\n        assertEquals(t * 24, DAYS.toHours(t));\r\n        assertEquals(t, HOURS.toHours(t));\r\n        assertEquals(t, MINUTES.toHours(t * 60));\r\n        assertEquals(t, SECONDS.toHours(t * 60 * 60));\r\n        assertEquals(t, MILLISECONDS.toHours(t * 1000L * 60 * 60));\r\n        assertEquals(t, MICROSECONDS.toHours(t * 1000000L * 60 * 60));\r\n        assertEquals(t, NANOSECONDS.toHours(t * 1000000000L * 60 * 60));\r\n    }\r\n}"
}, {
	"Path": "java.io.PushbackReader.reset",
	"Comment": "resets the stream. the reset method ofpushbackreader always throws an exception.",
	"Method": "void reset(){\r\n    throw new IOException(\"mark/reset not supported\");\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.testReplaceValue2",
	"Comment": "replace value succeeds when the given key mapped to expected value",
	"Method": "void testReplaceValue2(){\r\n    ConcurrentSkipListMap map = map5();\r\n    assertEquals(\"A\", map.get(one));\r\n    assertTrue(map.replace(one, \"A\", \"Z\"));\r\n    assertEquals(\"Z\", map.get(one));\r\n}"
}, {
	"Path": "com.google.j2objc.ReflectionTest.testNonDefaultConstructorAnnotations",
	"Comment": "returned, regardless of whether the constructor had parameters.",
	"Method": "void testNonDefaultConstructorAnnotations(){\r\n    Constructor<?>[] constructors = NoEquals.class.getDeclaredConstructors();\r\n    for (Constructor<?> c : constructors) {\r\n        if (c.getParameterTypes().length == 0) {\r\n            assertNull(c.getAnnotation(Mumble.class));\r\n        } else {\r\n            assertNotNull(c.getAnnotation(Mumble.class));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testAcquireSharedInterruptibly",
	"Comment": "acquiresharedinterruptibly returns after release, but not before",
	"Method": "void testAcquireSharedInterruptibly(){\r\n    final BooleanLatch l = new BooleanLatch();\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            assertFalse(l.isSignalled());\r\n            l.acquireSharedInterruptibly(0);\r\n            assertTrue(l.isSignalled());\r\n            l.acquireSharedInterruptibly(0);\r\n            assertTrue(l.isSignalled());\r\n        }\r\n    });\r\n    waitForQueuedThread(l, t);\r\n    assertFalse(l.isSignalled());\r\n    assertThreadStaysAlive(t);\r\n    assertHasSharedQueuedThreads(l, t);\r\n    assertTrue(l.releaseShared(0));\r\n    assertTrue(l.isSignalled());\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testAcquireSharedInterruptibly",
	"Comment": "acquiresharedinterruptibly returns after release, but not before",
	"Method": "void testAcquireSharedInterruptibly(){\r\n    assertFalse(l.isSignalled());\r\n    l.acquireSharedInterruptibly(0);\r\n    assertTrue(l.isSignalled());\r\n    l.acquireSharedInterruptibly(0);\r\n    assertTrue(l.isSignalled());\r\n}"
}, {
	"Path": "sun.security.provider.certpath.BuildStep.resultToString",
	"Comment": "return a string representing the meaning of the result code associatedwith this build step.",
	"Method": "String resultToString(int res){\r\n    String resultString = \"\";\r\n    switch(res) {\r\n        case POSSIBLE:\r\n            resultString = \"Certificate to be tried.\\n\";\r\n            break;\r\n        case BACK:\r\n            resultString = \"Certificate backed out since path does not \" + \"satisfy build requirements.\\n\";\r\n            break;\r\n        case FOLLOW:\r\n            resultString = \"Certificate satisfies conditions.\\n\";\r\n            break;\r\n        case FAIL:\r\n            resultString = \"Certificate backed out since path does not \" + \"satisfy conditions.\\n\";\r\n            break;\r\n        case SUCCEED:\r\n            resultString = \"Certificate satisfies conditions.\\n\";\r\n            break;\r\n        default:\r\n            resultString = \"Internal error: Invalid step result value.\\n\";\r\n    }\r\n    return resultString;\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testGet2_IndexOutOfBoundsException",
	"Comment": "get throws an indexoutofboundsexception on a too high index",
	"Method": "void testGet2_IndexOutOfBoundsException(){\r\n    CopyOnWriteArrayList c = populatedArray(5);\r\n    List[] lists = { c, c.subList(1, c.size() - 1) };\r\n    for (List list : lists) {\r\n        try {\r\n            list.get(list.size());\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testReferenceFieldUpdaterUpdateAndGet",
	"Comment": "atomicreferencefieldupdater updateandget updates with suppliedfunction and returns result.",
	"Method": "void testReferenceFieldUpdaterUpdateAndGet(){\r\n    AtomicReferenceFieldUpdater<Atomic8Test, Integer> a = anIntegerFieldUpdater();\r\n    a.set(this, one);\r\n    assertEquals(new Integer(18), a.updateAndGet(this, Atomic8Test::addInteger17));\r\n    assertEquals(new Integer(35), a.updateAndGet(this, Atomic8Test::addInteger17));\r\n    assertEquals(new Integer(35), a.get(this));\r\n    assertEquals(new Integer(35), anIntegerField);\r\n}"
}, {
	"Path": "java.util.logging.Logger.addHandler",
	"Comment": "add a log handler to receive logging messages.by default, loggers also send their output to their parent logger.typically the root logger is configured with a set of handlersthat essentially act as default handlers for all loggers.",
	"Method": "void addHandler(Handler handler){\r\n    handler.getClass();\r\n    checkPermission();\r\n    handlers.add(handler);\r\n}"
}, {
	"Path": "libcore.reflect.GenericSignatureParser.parseForField",
	"Comment": "parses the generic signature of a field and creates the data structurerepresenting the signature.",
	"Method": "void parseForField(GenericDeclaration genericDecl,String signature){\r\n    setInput(genericDecl, signature);\r\n    if (!eof) {\r\n        this.fieldType = parseFieldTypeSignature();\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinPool.registerWorker",
	"Comment": "callback from forkjoinworkerthread constructor to establish andrecord its workqueue.",
	"Method": "WorkQueue registerWorker(ForkJoinWorkerThread wt){\r\n    UncaughtExceptionHandler handler;\r\n    AuxState aux;\r\n    wt.setDaemon(true);\r\n    if ((handler = ueh) != null)\r\n        wt.setUncaughtExceptionHandler(handler);\r\n    WorkQueue w = new WorkQueue(this, wt);\r\n    int i = 0;\r\n    int mode = config & MODE_MASK;\r\n    if ((aux = auxState) != null) {\r\n        aux.lock();\r\n        try {\r\n            int s = (int) (aux.indexSeed += SEED_INCREMENT), n, m;\r\n            WorkQueue[] ws = workQueues;\r\n            if (ws != null && (n = ws.length) > 0) {\r\n                i = (m = n - 1) & ((s << 1) | 1);\r\n                if (ws[i] != null) {\r\n                    int probes = 0;\r\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\r\n                    while (ws[i = (i + step) & m] != null) {\r\n                        if (++probes >= n) {\r\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\r\n                            m = n - 1;\r\n                            probes = 0;\r\n                        }\r\n                    }\r\n                }\r\n                w.hint = s;\r\n                w.config = i | mode;\r\n                w.scanState = i | (s & 0x7fff0000);\r\n                ws[i] = w;\r\n            }\r\n        } finally {\r\n            aux.unlock();\r\n        }\r\n    }\r\n    wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\r\n    return w;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.DateFormatTest.TestRunTogetherPattern917",
	"Comment": "verify the behavior of patterns in which digits for different fields run togetherwithout intervening separators.",
	"Method": "void TestRunTogetherPattern917(){\r\n    SimpleDateFormat fmt;\r\n    String myDate;\r\n    fmt = new SimpleDateFormat(\"yyyy/MM/dd\");\r\n    myDate = \"1997/02/03\";\r\n    Calendar cal = Calendar.getInstance();\r\n    cal.clear();\r\n    cal.set(1997, 2 - 1, 3);\r\n    _testIt917(fmt, myDate, cal.getTime());\r\n    fmt = new SimpleDateFormat(\"yyyyMMdd\");\r\n    myDate = \"19970304\";\r\n    cal.clear();\r\n    cal.set(1997, 3 - 1, 4);\r\n    _testIt917(fmt, myDate, cal.getTime());\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testCancelledForkTimedGetSingleton",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGetSingleton(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            AsyncFib f = new AsyncFib(8);\r\n            assertTrue(f.cancel(true));\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (CancellationException success) {\r\n                checkCancelled(f);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testCancelledForkTimedGetSingleton",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGetSingleton(){\r\n    AsyncFib f = new AsyncFib(8);\r\n    assertTrue(f.cancel(true));\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (CancellationException success) {\r\n        checkCancelled(f);\r\n    }\r\n}"
}, {
	"Path": "jsr166.TreeSubSetTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    NavigableSet q = set0();\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i + SIZE);\r\n    try {\r\n        q.addAll(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testMaximumPoolSizeIllegalArgumentException2",
	"Comment": "setmaximumpoolsize throws illegalargumentexceptionif given a negative value",
	"Method": "void testMaximumPoolSizeIllegalArgumentException2(){\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(2, 3, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        try {\r\n            p.setMaximumPoolSize(-1);\r\n            shouldThrow();\r\n        } catch (IllegalArgumentException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.LogManager.removePropertyChangeListener",
	"Comment": "removes an event listener for property change events.if the same listener instance has been added to the listener tablethrough multiple invocations of addpropertychangelistener,then an equivalent number ofremovepropertychangelistener invocations are required to removeall instances of that listener from the listener table.returns silently if the given listener is not found.",
	"Method": "void removePropertyChangeListener(PropertyChangeListener l){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "java.net.Inet4Address.isMCSiteLocal",
	"Comment": "utility routine to check if the multicast address has site scope.",
	"Method": "boolean isMCSiteLocal(){\r\n    int address = holder().getAddress();\r\n    return (((address >>> 24) & 0xFF) == 239) && (((address >>> 16) & 0xFF) == 255);\r\n}"
}, {
	"Path": "jsr166.BlockingQueueTest.testAddAllNullElements",
	"Comment": "addall of a collection with null elements throws nullpointerexception",
	"Method": "void testAddAllNullElements(){\r\n    final Collection q = emptyCollection();\r\n    final Collection<Integer> elements = Arrays.asList(new Integer[SIZE]);\r\n    try {\r\n        q.addAll(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.PKIXParameters.clone",
	"Comment": "makes a copy of this pkixparameters object. changesto the copy will not affect the original and vice versa.",
	"Method": "Object clone(){\r\n    try {\r\n        PKIXParameters copy = (PKIXParameters) super.clone();\r\n        if (certStores != null) {\r\n            copy.certStores = new ArrayList<CertStore>(certStores);\r\n        }\r\n        if (certPathCheckers != null) {\r\n            copy.certPathCheckers = new ArrayList<PKIXCertPathChecker>(certPathCheckers.size());\r\n            for (PKIXCertPathChecker checker : certPathCheckers) {\r\n                copy.certPathCheckers.add((PKIXCertPathChecker) checker.clone());\r\n            }\r\n        }\r\n        return copy;\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new InternalError(e.toString());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSubMapTest.testPutIfAbsent2",
	"Comment": "putifabsent does not add the pair if the key is already present",
	"Method": "void testPutIfAbsent2(){\r\n    ConcurrentNavigableMap map = map5();\r\n    assertEquals(\"A\", map.putIfAbsent(one, \"Z\"));\r\n}"
}, {
	"Path": "sun.security.x509.GeneralSubtrees.createWidestSubtree",
	"Comment": "create a subtree containing an instance of the inputname type that widens all other names of that type.",
	"Method": "GeneralSubtree createWidestSubtree(GeneralNameInterface name){\r\n    try {\r\n        GeneralName newName;\r\n        switch(name.getType()) {\r\n            case GeneralNameInterface.NAME_ANY:\r\n                ObjectIdentifier otherOID = ((OtherName) name).getOID();\r\n                newName = new GeneralName(new OtherName(otherOID, null));\r\n                break;\r\n            case GeneralNameInterface.NAME_RFC822:\r\n                newName = new GeneralName(new RFC822Name(\"\"));\r\n                break;\r\n            case GeneralNameInterface.NAME_DNS:\r\n                newName = new GeneralName(new DNSName(\"\"));\r\n                break;\r\n            case GeneralNameInterface.NAME_X400:\r\n                newName = new GeneralName(new X400Address((byte[]) null));\r\n                break;\r\n            case GeneralNameInterface.NAME_DIRECTORY:\r\n                newName = new GeneralName(new X500Name(\"\"));\r\n                break;\r\n            case GeneralNameInterface.NAME_EDI:\r\n                newName = new GeneralName(new EDIPartyName(\"\"));\r\n                break;\r\n            case GeneralNameInterface.NAME_URI:\r\n                newName = new GeneralName(new URIName(\"\"));\r\n                break;\r\n            case GeneralNameInterface.NAME_IP:\r\n                newName = new GeneralName(new IPAddressName((byte[]) null));\r\n                break;\r\n            case GeneralNameInterface.NAME_OID:\r\n                newName = new GeneralName(new OIDName(new ObjectIdentifier((int[]) null)));\r\n                break;\r\n            default:\r\n                throw new IOException(\"Unsupported GeneralNameInterface type: \" + name.getType());\r\n        }\r\n        return new GeneralSubtree(newName, 0, -1);\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(\"Unexpected error: \" + e, e);\r\n    }\r\n}"
}, {
	"Path": "java.security.MessageDigest.toString",
	"Comment": "returns a string representation of this message digest object.",
	"Method": "String toString(){\r\n    StringBuilder builder = new StringBuilder();\r\n    builder.append(algorithm);\r\n    builder.append(\" Message Digest from \");\r\n    builder.append(provider.getName());\r\n    builder.append(\", \");\r\n    switch(state) {\r\n        case INITIAL:\r\n            builder.append(\"<initialized>\");\r\n            break;\r\n        case IN_PROGRESS:\r\n            builder.append(\"<in progress>\");\r\n            break;\r\n    }\r\n    return builder.toString();\r\n}"
}, {
	"Path": "org.xml.sax.SAXParseException.getLineNumber",
	"Comment": "the line number of the end of the text where the exception occurred.the first line is line 1.",
	"Method": "int getLineNumber(){\r\n    return this.lineNumber;\r\n}"
}, {
	"Path": "java.security.KeyStore.getInstance",
	"Comment": "returns a keystore object of the specified type. a new keystore object encapsulating thekeystorespi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "KeyStore getInstance(String type,KeyStore getInstance,String type,String provider,KeyStore getInstance,String type,Provider provider){\r\n    if (provider == null)\r\n        throw new IllegalArgumentException(\"missing provider\");\r\n    try {\r\n        Object[] objs = Security.getImpl(type, \"KeyStore\", provider);\r\n        return new KeyStore((KeyStoreSpi) objs[0], (Provider) objs[1], type);\r\n    } catch (NoSuchAlgorithmException nsae) {\r\n        throw new KeyStoreException(type + \" not found\", nsae);\r\n    }\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testAbnormalForkGet",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGet(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() throws Exception {\r\n            FailingFibTask f = new FailingFibTask(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                Integer r = f.get();\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(mainPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testAbnormalForkGet",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGet(){\r\n    FailingFibTask f = new FailingFibTask(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        Integer r = f.get();\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n    return NoResult;\r\n}"
}, {
	"Path": "javax.crypto.Cipher.getMaxAllowedParameterSpec",
	"Comment": "returns an algorithmparameterspec object which containsthe maximum cipher parameter value according to thejurisdiction policy file. if jce unlimited strength jurisdictionpolicy files are installed or there is no maximum limit on theparameters for the specified transformation in the policy file,null will be returned.",
	"Method": "AlgorithmParameterSpec getMaxAllowedParameterSpec(String transformation){\r\n    if (transformation == null) {\r\n        throw new NullPointerException(\"transformation == null\");\r\n    }\r\n    tokenizeTransformation(transformation);\r\n    return null;\r\n}"
}, {
	"Path": "jsr166.ThreadLocalRandomTest.testNextDouble",
	"Comment": "repeated calls to nextdouble produce at least two distinct results",
	"Method": "void testNextDouble(){\r\n    double f = ThreadLocalRandom.current().nextDouble();\r\n    int i = 0;\r\n    while (i < NCALLS && ThreadLocalRandom.current().nextDouble() == f) ++i;\r\n    assertTrue(i < NCALLS);\r\n}"
}, {
	"Path": "java.util.concurrent.ThreadPoolExecutor.drainQueue",
	"Comment": "drains the task queue into a new list, normally usingdrainto. but if the queue is a delayqueue or any other kind ofqueue for which poll or drainto may fail to remove someelements, it deletes them one by one.",
	"Method": "List<Runnable> drainQueue(){\r\n    BlockingQueue<Runnable> q = workQueue;\r\n    ArrayList<Runnable> taskList = new ArrayList();\r\n    q.drainTo(taskList);\r\n    if (!q.isEmpty()) {\r\n        for (Runnable r : q.toArray(new Runnable[0])) {\r\n            if (q.remove(r))\r\n                taskList.add(r);\r\n        }\r\n    }\r\n    return taskList;\r\n}"
}, {
	"Path": "java.security.MessageDigest.getDigestLength",
	"Comment": "returns the length of the digest in bytes, or 0 if this operation isnot supported by the provider and the implementation is not cloneable.",
	"Method": "int getDigestLength(){\r\n    int digestLen = engineGetDigestLength();\r\n    if (digestLen == 0) {\r\n        try {\r\n            MessageDigest md = (MessageDigest) clone();\r\n            byte[] digest = md.digest();\r\n            return digest.length;\r\n        } catch (CloneNotSupportedException e) {\r\n            return digestLen;\r\n        }\r\n    }\r\n    return digestLen;\r\n}"
}, {
	"Path": "java.util.Collections.singletonMap",
	"Comment": "returns an immutable map, mapping only the specified key to thespecified value.the returned map is serializable.",
	"Method": "Map<K, V> singletonMap(K key,V value){\r\n    return new SingletonMap(key, value);\r\n}"
}, {
	"Path": "jsr166.AtomicLongArrayTest.testCountingInMultipleThreads",
	"Comment": "multiple threads using same array of counters successfullyupdate a number of times equal to total count",
	"Method": "void testCountingInMultipleThreads(){\r\n    final AtomicLongArray aa = new AtomicLongArray(SIZE);\r\n    long countdown = 10000;\r\n    for (int i = 0; i < SIZE; i++) aa.set(i, countdown);\r\n    Counter c1 = new Counter(aa);\r\n    Counter c2 = new Counter(aa);\r\n    Thread t1 = new Thread(c1);\r\n    Thread t2 = new Thread(c2);\r\n    t1.start();\r\n    t2.start();\r\n    t1.join();\r\n    t2.join();\r\n    assertEquals(c1.counts + c2.counts, SIZE * countdown);\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testRemove2_IndexOutOfBounds",
	"Comment": "remove throws an indexoutofboundsexception on a too high index",
	"Method": "void testRemove2_IndexOutOfBounds(){\r\n    CopyOnWriteArrayList c = populatedArray(5);\r\n    List[] lists = { c, c.subList(1, c.size() - 1) };\r\n    for (List list : lists) {\r\n        try {\r\n            list.remove(list.size());\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberFormatTest.TestSimpleNumberFormatFactory",
	"Comment": "tests the class public static abstract class simplenumberformatfactory extends numberformatfactory",
	"Method": "void TestSimpleNumberFormatFactory(){\r\n    class TestSimpleNumberFormatFactory extends SimpleNumberFormatFactory {\r\n        TestSimpleNumberFormatFactory() {\r\n            super(new Locale(\"\"));\r\n        }\r\n    }\r\n    @SuppressWarnings(\"unused\")\r\n    TestSimpleNumberFormatFactory tsnff = new TestSimpleNumberFormatFactory();\r\n}"
}, {
	"Path": "java.util.Vector.toString",
	"Comment": "returns a string representation of this vector, containingthe string representation of each element.",
	"Method": "String toString(){\r\n    return super.toString();\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testPrivilegedCallableWithNoPrivs",
	"Comment": "without permissions, calling privilegedcallable throws ace",
	"Method": "void testPrivilegedCallableWithNoPrivs(){\r\n    Executors.privilegedCallable(new CheckCCL());\r\n    Runnable r = new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            if (System.getSecurityManager() == null)\r\n                return;\r\n            Callable task = Executors.privilegedCallable(new CheckCCL());\r\n            try {\r\n                task.call();\r\n                shouldThrow();\r\n            } catch (AccessControlException success) {\r\n            }\r\n        }\r\n    };\r\n    runWithoutPermissions(r);\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testPrivilegedCallableWithNoPrivs",
	"Comment": "without permissions, calling privilegedcallable throws ace",
	"Method": "void testPrivilegedCallableWithNoPrivs(){\r\n    if (System.getSecurityManager() == null)\r\n        return;\r\n    Callable task = Executors.privilegedCallable(new CheckCCL());\r\n    try {\r\n        task.call();\r\n        shouldThrow();\r\n    } catch (AccessControlException success) {\r\n    }\r\n}"
}, {
	"Path": "java.util.regex.Pattern.matcher",
	"Comment": "creates a matcher that will match the given input against this pattern.",
	"Method": "Matcher matcher(CharSequence input){\r\n    Matcher m = new Matcher(this, input);\r\n    return m;\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testSerialization",
	"Comment": "a deserialized serialized queue has same elements in same order",
	"Method": "void testSerialization(){\r\n    if (ReflectionUtil.isJreReflectionStripped()) {\r\n        return;\r\n    }\r\n    Queue x = populatedQueue(SIZE);\r\n    Queue y = serialClone(x);\r\n    assertNotSame(y, x);\r\n    assertEquals(x.size(), y.size());\r\n    assertEquals(x.toString(), y.toString());\r\n    assertTrue(Arrays.equals(x.toArray(), y.toArray()));\r\n    while (!x.isEmpty()) {\r\n        assertFalse(y.isEmpty());\r\n        assertEquals(x.remove(), y.remove());\r\n    }\r\n    assertTrue(y.isEmpty());\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.containsKey",
	"Comment": "tests whether the specified object reference is a key in this identityhash map.",
	"Method": "boolean containsKey(Object key){\r\n    Object k = maskNull(key);\r\n    Object[] tab = table;\r\n    int len = tab.length;\r\n    int i = hash(k, len);\r\n    while (true) {\r\n        Object item = tab[i];\r\n        if (item == k)\r\n            return true;\r\n        if (item == null)\r\n            return false;\r\n        i = nextKeyIndex(i, len);\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.CertStore.getInstance",
	"Comment": "returns a certstore object that implements the specifiedcertstore type. a new certstore object encapsulating thecertstorespi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.the certstore that is returned is initialized with thespecified certstoreparameters. the type of parametersneeded may vary between different types of certstores.note that the specified certstoreparameters object iscloned.",
	"Method": "CertStore getInstance(String type,CertStoreParameters params,CertStore getInstance,String type,CertStoreParameters params,String provider,CertStore getInstance,String type,CertStoreParameters params,Provider provider){\r\n    try {\r\n        Instance instance = GetInstance.getInstance(\"CertStore\", CertStoreSpi.class, type, params, provider);\r\n        return new CertStore((CertStoreSpi) instance.impl, instance.provider, type, params);\r\n    } catch (NoSuchAlgorithmException e) {\r\n        return handleException(e);\r\n    }\r\n}"
}, {
	"Path": "java.text.Format.parseObject",
	"Comment": "parses text from the beginning of the given string to produce an object.the method may not use the entire text of the given string.",
	"Method": "Object parseObject(String source,ParsePosition pos,Object parseObject,String source){\r\n    ParsePosition pos = new ParsePosition(0);\r\n    Object result = parseObject(source, pos);\r\n    if (pos.index == 0) {\r\n        throw new ParseException(\"Format.parseObject(String) failed\", pos.errorIndex);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "sun.security.util.DerValue.getPositiveBigInteger",
	"Comment": "returns an asn.1 integer value as a positive biginteger.this is just to deal with implementations that incorrectly encodesome values as negative.",
	"Method": "BigInteger getPositiveBigInteger(){\r\n    if (tag != tag_Integer)\r\n        throw new IOException(\"DerValue.getBigInteger, not an int \" + tag);\r\n    return buffer.getBigInteger(data.available(), true);\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.getCertificateChecking",
	"Comment": "returns the certificate being checked. this is not a criterion. rather,it is optional information that may help a certstorefind crls that would be relevant when checking revocation for thespecified certificate. if the value returned is null, thenno such optional information is provided.",
	"Method": "X509Certificate getCertificateChecking(){\r\n    return certChecking;\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedSynchronizer.addWaiter",
	"Comment": "creates and enqueues node for current thread and given mode.",
	"Method": "Node addWaiter(Node mode){\r\n    Node node = new Node(mode);\r\n    for (; ; ) {\r\n        Node oldTail = tail;\r\n        if (oldTail != null) {\r\n            U.putObject(node, Node.PREV, oldTail);\r\n            if (compareAndSetTail(oldTail, node)) {\r\n                oldTail.next = node;\r\n                return node;\r\n            }\r\n        } else {\r\n            initializeSyncQueue();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.InflaterOutputStream.flush",
	"Comment": "flushes this output stream, forcing any pending buffered output bytes to bewritten.",
	"Method": "void flush(){\r\n    ensureOpen();\r\n    if (!inf.finished()) {\r\n        try {\r\n            while (!inf.finished() && !inf.needsInput()) {\r\n                int n;\r\n                n = inf.inflate(buf, 0, buf.length);\r\n                if (n < 1) {\r\n                    break;\r\n                }\r\n                out.write(buf, 0, n);\r\n            }\r\n            super.flush();\r\n        } catch (DataFormatException ex) {\r\n            String msg = ex.getMessage();\r\n            if (msg == null) {\r\n                msg = \"Invalid ZLIB data format\";\r\n            }\r\n            throw new ZipException(msg);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.text.DecimalFormat.toLocalizedPattern",
	"Comment": "synthesizes a localized pattern string that represents the currentstate of this format object.",
	"Method": "String toLocalizedPattern(){\r\n    return toPattern(true);\r\n}"
}, {
	"Path": "sun.security.provider.certpath.BasicChecker.verifyNameChaining",
	"Comment": "internal method to check that cert has a valid dn to be next in a chain",
	"Method": "void verifyNameChaining(X509Certificate cert){\r\n    if (prevSubject != null) {\r\n        String msg = \"subject/issuer name chaining\";\r\n        if (debug != null)\r\n            debug.println(\"---checking \" + msg + \"...\");\r\n        X500Principal currIssuer = cert.getIssuerX500Principal();\r\n        if (X500Name.asX500Name(currIssuer).isEmpty()) {\r\n            throw new CertPathValidatorException(msg + \" check failed: \" + \"empty/null issuer DN in certificate is invalid\", null, null, -1, PKIXReason.NAME_CHAINING);\r\n        }\r\n        if (!(currIssuer.equals(prevSubject))) {\r\n            throw new CertPathValidatorException(msg + \" check failed\", null, null, -1, PKIXReason.NAME_CHAINING);\r\n        }\r\n        if (debug != null)\r\n            debug.println(msg + \" verified.\");\r\n    }\r\n}"
}, {
	"Path": "jsr166.TreeSubMapTest.testGet",
	"Comment": "get returns the correct element at the given key,or null if not present",
	"Method": "void testGet(){\r\n    NavigableMap map = map5();\r\n    assertEquals(\"A\", (String) map.get(one));\r\n    NavigableMap empty = map0();\r\n    assertNull(empty.get(one));\r\n}"
}, {
	"Path": "java.util.function.Predicate.negate",
	"Comment": "returns a predicate that represents the logical negation of thispredicate.",
	"Method": "Predicate<T> negate(){\r\n    return (t) -> !test(t);\r\n}"
}, {
	"Path": "java.text.NumberFormat.getPercentInstance",
	"Comment": "returns a percentage format for the current default locale.",
	"Method": "NumberFormat getPercentInstance(NumberFormat getPercentInstance,Locale inLocale){\r\n    return getInstance(inLocale, PERCENTSTYLE);\r\n}"
}, {
	"Path": "java.util.logging.Logger.info",
	"Comment": "log an info message.if the logger is currently enabled for the info messagelevel then the given message is forwarded to all theregistered output handler objects.",
	"Method": "void info(String msg){\r\n    if (Level.INFO.intValue() < levelValue) {\r\n        return;\r\n    }\r\n    log(Level.INFO, msg);\r\n}"
}, {
	"Path": "java.util.regex.Matcher.ensureMatch",
	"Comment": "makes sure that a successful match has been made. is invoked internallyfrom various places in the class.",
	"Method": "void ensureMatch(){\r\n    if (!matchFound) {\r\n        throw new IllegalStateException(\"No successful match so far\");\r\n    }\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.toString",
	"Comment": "returns a string representation of this mutablebiginteger in radix 10.",
	"Method": "String toString(){\r\n    BigInteger b = toBigInteger(1);\r\n    return b.toString();\r\n}"
}, {
	"Path": "java.security.cert.PKIXRevocationChecker.getOcspResponses",
	"Comment": "gets the ocsp responses. these responses are used to determinethe revocation status of the specified certificates when ocsp is used.",
	"Method": "Map<X509Certificate, byte[]> getOcspResponses(){\r\n    Map<X509Certificate, byte[]> copy = new HashMap(ocspResponses.size());\r\n    for (Map.Entry<X509Certificate, byte[]> e : ocspResponses.entrySet()) {\r\n        copy.put(e.getKey(), e.getValue().clone());\r\n    }\r\n    return copy;\r\n}"
}, {
	"Path": "javax.net.ssl.SSLEngine.getPeerHost",
	"Comment": "returns the host name of the peer.note that the value is not authenticated, and should not berelied upon.",
	"Method": "String getPeerHost(){\r\n    return peerHost;\r\n}"
}, {
	"Path": "java.beans.Introspector.getBeanInfo",
	"Comment": "gets the beaninfo object which contains the information of\tthe properties, events and methods of the specified bean class.\tthe introspector will cache the beaninfo\tobject. subsequent calls to this method will be answered with the cached\tdata.",
	"Method": "BeanInfo getBeanInfo(Class<?> beanClass,BeanInfo getBeanInfo,Class<?> beanClass,Class<?> stopClass,BeanInfo getBeanInfo,Class<?> beanClass,int flags){\r\n    if (flags == USE_ALL_BEANINFO) {\r\n        return getBeanInfo(beanClass);\r\n    }\r\n    return getBeanInfoImplAndInit(beanClass, null, flags);\r\n}"
}, {
	"Path": "jsr166.ConcurrentHashMapTest.testGet",
	"Comment": "get returns the correct element at the given key,or null if not present",
	"Method": "void testGet(){\r\n    ConcurrentHashMap map = map5();\r\n    assertEquals(\"A\", (String) map.get(one));\r\n    ConcurrentHashMap empty = new ConcurrentHashMap();\r\n    assertNull(map.get(\"anything\"));\r\n    assertNull(empty.get(\"anything\"));\r\n}"
}, {
	"Path": "sun.security.x509.NameConstraintsExtension.clone",
	"Comment": "clone all objects that may be modified during certificate validation.",
	"Method": "Object clone(){\r\n    try {\r\n        NameConstraintsExtension newNCE = (NameConstraintsExtension) super.clone();\r\n        if (permitted != null) {\r\n            newNCE.permitted = (GeneralSubtrees) permitted.clone();\r\n        }\r\n        if (excluded != null) {\r\n            newNCE.excluded = (GeneralSubtrees) excluded.clone();\r\n        }\r\n        return newNCE;\r\n    } catch (CloneNotSupportedException cnsee) {\r\n        throw new RuntimeException(\"CloneNotSupportedException while \" + \"cloning NameConstraintsException. This should never happen.\");\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentLinkedDeque.pred",
	"Comment": "returns the predecessor of p, or the last node if p.prev has beenlinked to self, which will only be true if traversing with astale pointer that is now off the list.",
	"Method": "Node<E> pred(Node<E> p){\r\n    Node<E> q = p.prev;\r\n    return (sentinel() == q) ? last() : q;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.ast.TreeUtil.getOwningStatement",
	"Comment": "returns the statement which is the parent of the specified node.",
	"Method": "Statement getOwningStatement(TreeNode node){\r\n    return getNearestAncestorWithType(Statement.class, node);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.ObjectiveCSourceFileGenerator.pushIgnoreDeprecatedDeclarationsPragma",
	"Comment": "ignores deprecation warnings. deprecation warnings should be visible for human authored code, not transpiled code. this method should be paired with popignoredeprecateddeclarationspragma.",
	"Method": "void pushIgnoreDeprecatedDeclarationsPragma(){\r\n    if (unit.options().generateDeprecatedDeclarations()) {\r\n        newline();\r\n        println(\"#pragma clang diagnostic push\");\r\n        println(\"#pragma GCC diagnostic ignored \\\"-Wdeprecated-declarations\\\"\");\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.PrivateKeyUsageExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(NOT_BEFORE);\r\n    elements.addElement(NOT_AFTER);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.setZeroDigit",
	"Comment": "sets the character used for zero. different for arabic, etc.",
	"Method": "void setZeroDigit(char zeroDigit){\r\n    this.zeroDigit = zeroDigit;\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.getIssuerAlternativeNames",
	"Comment": "this static method is the default implementation of thegetissueralternaitvenames method in x509certificate. ax509certificate provider generally should overwrite this toprovide among other things caching for better performance.",
	"Method": "Collection<List<?>> getIssuerAlternativeNames(Collection<List<?>> getIssuerAlternativeNames,X509Certificate cert){\r\n    try {\r\n        byte[] ext = cert.getExtensionValue(ISSUER_ALT_NAME_OID);\r\n        if (ext == null) {\r\n            return null;\r\n        }\r\n        DerValue val = new DerValue(ext);\r\n        byte[] data = val.getOctetString();\r\n        IssuerAlternativeNameExtension issuerAltNameExt = new IssuerAlternativeNameExtension(Boolean.FALSE, data);\r\n        GeneralNames names;\r\n        try {\r\n            names = issuerAltNameExt.get(IssuerAlternativeNameExtension.ISSUER_NAME);\r\n        } catch (IOException ioe) {\r\n            return Collections.<List<?>>emptySet();\r\n        }\r\n        return makeAltNames(names);\r\n    } catch (IOException ioe) {\r\n        throw new CertificateParsingException(ioe);\r\n    }\r\n}"
}, {
	"Path": "java.time.format.DecimalStyle.getZeroDigit",
	"Comment": "gets the character that represents zero.the character used to represent digits may vary by culture.this method specifies the zero character to use, which implies the characters for one to nine.",
	"Method": "char getZeroDigit(){\r\n    return zeroDigit;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.StatementGeneratorTest.testConstructorReturn",
	"Comment": "verify that return statements in constructors return self.",
	"Method": "void testConstructorReturn(){\r\n    String translation = translateSourceFile(\"public class A { public A() { return; }}\", \"A\", \"A.m\");\r\n    assertTranslation(translation, \"return self;\");\r\n}"
}, {
	"Path": "jsr166.CountDownLatchTest.testCountDown",
	"Comment": "countdown decrements count when positive and has no effect when zero",
	"Method": "void testCountDown(){\r\n    final CountDownLatch l = new CountDownLatch(1);\r\n    assertEquals(1, l.getCount());\r\n    l.countDown();\r\n    assertEquals(0, l.getCount());\r\n    l.countDown();\r\n    assertEquals(0, l.getCount());\r\n}"
}, {
	"Path": "android.icu.dev.test.translit.RegexUtilitiesTest.TestCharacters",
	"Comment": "perform an exhaustive test on all unicode characters to make sure that the unicodeset with eachcharacter works.",
	"Method": "void TestCharacters(){\r\n    UnicodeSet requiresQuote = new UnicodeSet(\"[\\\\$\\\\&\\\\-\\\\:\\\\[\\\\\\\\\\\\]\\\\^\\\\{\\\\}[:pattern_whitespace:]]\");\r\n    boolean skip = TestFmwk.getExhaustiveness() < 10;\r\n    for (int cp = 0; cp < 0x110000; ++cp) {\r\n        if (cp > 0xFF && skip && (cp % 37 != 0)) {\r\n            continue;\r\n        }\r\n        String cpString = UTF16.valueOf(cp);\r\n        String s = requiresQuote.contains(cp) ? \"\\\\\" + cpString : cpString;\r\n        String pattern = null;\r\n        final String rawPattern = \"[\" + s + s + \"]\";\r\n        try {\r\n            pattern = UnicodeRegex.fix(rawPattern);\r\n        } catch (Exception e) {\r\n            errln(e.getMessage());\r\n            continue;\r\n        }\r\n        final String expected = \"[\" + s + \"]\";\r\n        assertEquals(\"Doubled character works\" + hex.transform(s), expected, pattern);\r\n        String shouldNotMatch = UTF16.valueOf((cp + 1) % 0x110000);\r\n        checkCharPattern(Pattern.compile(pattern), pattern, cpString, shouldNotMatch);\r\n        checkCharPattern(UnicodeRegex.compile(rawPattern), pattern, cpString, shouldNotMatch);\r\n    }\r\n}"
}, {
	"Path": "jsr166.PriorityQueueTest.populatedQueue",
	"Comment": "returns a new queue of given size containing consecutiveintegers 0 ... n.",
	"Method": "PriorityQueue<Integer> populatedQueue(int n){\r\n    PriorityQueue<Integer> q = new PriorityQueue<Integer>(n);\r\n    assertTrue(q.isEmpty());\r\n    for (int i = n - 1; i >= 0; i -= 2) assertTrue(q.offer(new Integer(i)));\r\n    for (int i = (n & 1); i < n; i += 2) assertTrue(q.offer(new Integer(i)));\r\n    assertFalse(q.isEmpty());\r\n    assertEquals(n, q.size());\r\n    return q;\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedSynchronizer.findNodeFromTail",
	"Comment": "returns true if node is on sync queue by searching backwards from tail.called only when needed by isonsyncqueue.",
	"Method": "boolean findNodeFromTail(Node node){\r\n    for (Node p = tail; ; ) {\r\n        if (p == node)\r\n            return true;\r\n        if (p == null)\r\n            return false;\r\n        p = p.prev;\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.ObjectiveCSourceFileGenerator.popIgnoreDeprecatedDeclarationsPragma",
	"Comment": "restores deprecation warnings after a call to pushignoredeprecateddeclarationspragma.",
	"Method": "void popIgnoreDeprecatedDeclarationsPragma(){\r\n    if (unit.options().generateDeprecatedDeclarations()) {\r\n        println(\"\\n#pragma clang diagnostic pop\");\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.ZipOutputStream.finish",
	"Comment": "finishes writing the contents of the zip output stream without closingthe underlying stream. use this method when applying multiple filtersin succession to the same output stream.",
	"Method": "void finish(){\r\n    ensureOpen();\r\n    if (finished) {\r\n        return;\r\n    }\r\n    if (xentries.isEmpty()) {\r\n        throw new ZipException(\"No entries\");\r\n    }\r\n    if (current != null) {\r\n        closeEntry();\r\n    }\r\n    long off = written;\r\n    for (XEntry xentry : xentries) writeCEN(xentry);\r\n    writeEND(off, written - off);\r\n    finished = true;\r\n}"
}, {
	"Path": "java.util.ArrayDeque.doubleCapacity",
	"Comment": "doubles the capacity of this deque.call only when full, i.e.,when head and tail have wrapped around to become equal.",
	"Method": "void doubleCapacity(){\r\n    assert head == tail;\r\n    int p = head;\r\n    int n = elements.length;\r\n    int r = n - p;\r\n    int newCapacity = n << 1;\r\n    if (newCapacity < 0)\r\n        throw new IllegalStateException(\"Sorry, deque too big\");\r\n    Object[] a = new Object[newCapacity];\r\n    System.arraycopy(elements, p, a, 0, r);\r\n    System.arraycopy(elements, 0, a, r, p);\r\n    elements = a;\r\n    head = 0;\r\n    tail = n;\r\n}"
}, {
	"Path": "sun.util.calendar.CalendarDate.clone",
	"Comment": "returns a copy of this calendardate. thetimezone object, if any, is not cloned.",
	"Method": "Object clone(){\r\n    try {\r\n        return super.clone();\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new InternalError();\r\n    }\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.divaddLong",
	"Comment": "a primitive used for division by long.specialized version of the method divadd.dh is a high part of the divisor, dl is a low part",
	"Method": "int divaddLong(int dh,int dl,int[] result,int offset){\r\n    long carry = 0;\r\n    long sum = (dl & LONG_MASK) + (result[1 + offset] & LONG_MASK);\r\n    result[1 + offset] = (int) sum;\r\n    sum = (dh & LONG_MASK) + (result[offset] & LONG_MASK) + carry;\r\n    result[offset] = (int) sum;\r\n    carry = sum >>> 32;\r\n    return (int) carry;\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testAwait2_Interrupted_BrokenBarrier",
	"Comment": "an interruption in one party causes others waiting in timed await tothrow brokenbarrierexception",
	"Method": "void testAwait2_Interrupted_BrokenBarrier(){\r\n    final CyclicBarrier c = new CyclicBarrier(3);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(2);\r\n    Thread t1 = new ThreadShouldThrow(InterruptedException.class) {\r\n        public void realRun() throws Exception {\r\n            pleaseInterrupt.countDown();\r\n            c.await(LONG_DELAY_MS, MILLISECONDS);\r\n        }\r\n    };\r\n    Thread t2 = new ThreadShouldThrow(BrokenBarrierException.class) {\r\n        public void realRun() throws Exception {\r\n            pleaseInterrupt.countDown();\r\n            c.await(LONG_DELAY_MS, MILLISECONDS);\r\n        }\r\n    };\r\n    t1.start();\r\n    t2.start();\r\n    await(pleaseInterrupt);\r\n    t1.interrupt();\r\n    awaitTermination(t1);\r\n    awaitTermination(t2);\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testAwait2_Interrupted_BrokenBarrier",
	"Comment": "an interruption in one party causes others waiting in timed await tothrow brokenbarrierexception",
	"Method": "void testAwait2_Interrupted_BrokenBarrier(){\r\n    pleaseInterrupt.countDown();\r\n    c.await(LONG_DELAY_MS, MILLISECONDS);\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testAwait2_Interrupted_BrokenBarrier",
	"Comment": "an interruption in one party causes others waiting in timed await tothrow brokenbarrierexception",
	"Method": "void testAwait2_Interrupted_BrokenBarrier(){\r\n    pleaseInterrupt.countDown();\r\n    c.await(LONG_DELAY_MS, MILLISECONDS);\r\n}"
}, {
	"Path": "java.util.TreeSet.descendingIterator",
	"Comment": "returns an iterator over the elements in this set in descending order.",
	"Method": "Iterator<E> descendingIterator(){\r\n    return m.descendingKeySet().iterator();\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.divideMagnitude",
	"Comment": "divide this mutablebiginteger by the divisor.the quotient will be placed into the provided quotient object &the remainder object is returned.",
	"Method": "MutableBigInteger divideMagnitude(MutableBigInteger div,MutableBigInteger quotient,boolean needRemainder){\r\n    int shift = Integer.numberOfLeadingZeros(div.value[div.offset]);\r\n    final int dlen = div.intLen;\r\n    int[] divisor;\r\n    MutableBigInteger rem;\r\n    if (shift > 0) {\r\n        divisor = new int[dlen];\r\n        copyAndShift(div.value, div.offset, dlen, divisor, 0, shift);\r\n        if (Integer.numberOfLeadingZeros(value[offset]) >= shift) {\r\n            int[] remarr = new int[intLen + 1];\r\n            rem = new MutableBigInteger(remarr);\r\n            rem.intLen = intLen;\r\n            rem.offset = 1;\r\n            copyAndShift(value, offset, intLen, remarr, 1, shift);\r\n        } else {\r\n            int[] remarr = new int[intLen + 2];\r\n            rem = new MutableBigInteger(remarr);\r\n            rem.intLen = intLen + 1;\r\n            rem.offset = 1;\r\n            int rFrom = offset;\r\n            int c = 0;\r\n            int n2 = 32 - shift;\r\n            for (int i = 1; i < intLen + 1; i++, rFrom++) {\r\n                int b = c;\r\n                c = value[rFrom];\r\n                remarr[i] = (b << shift) | (c >>> n2);\r\n            }\r\n            remarr[intLen + 1] = c << shift;\r\n        }\r\n    } else {\r\n        divisor = Arrays.copyOfRange(div.value, div.offset, div.offset + div.intLen);\r\n        rem = new MutableBigInteger(new int[intLen + 1]);\r\n        System.arraycopy(value, offset, rem.value, 1, intLen);\r\n        rem.intLen = intLen;\r\n        rem.offset = 1;\r\n    }\r\n    int nlen = rem.intLen;\r\n    final int limit = nlen - dlen + 1;\r\n    if (quotient.value.length < limit) {\r\n        quotient.value = new int[limit];\r\n        quotient.offset = 0;\r\n    }\r\n    quotient.intLen = limit;\r\n    int[] q = quotient.value;\r\n    if (rem.intLen == nlen) {\r\n        rem.offset = 0;\r\n        rem.value[0] = 0;\r\n        rem.intLen++;\r\n    }\r\n    int dh = divisor[0];\r\n    long dhLong = dh & LONG_MASK;\r\n    int dl = divisor[1];\r\n    for (int j = 0; j < limit - 1; j++) {\r\n        int qhat = 0;\r\n        int qrem = 0;\r\n        boolean skipCorrection = false;\r\n        int nh = rem.value[j + rem.offset];\r\n        int nh2 = nh + 0x80000000;\r\n        int nm = rem.value[j + 1 + rem.offset];\r\n        if (nh == dh) {\r\n            qhat = ~0;\r\n            qrem = nh + nm;\r\n            skipCorrection = qrem + 0x80000000 < nh2;\r\n        } else {\r\n            long nChunk = (((long) nh) << 32) | (nm & LONG_MASK);\r\n            if (nChunk >= 0) {\r\n                qhat = (int) (nChunk / dhLong);\r\n                qrem = (int) (nChunk - (qhat * dhLong));\r\n            } else {\r\n                long tmp = divWord(nChunk, dh);\r\n                qhat = (int) (tmp & LONG_MASK);\r\n                qrem = (int) (tmp >>> 32);\r\n            }\r\n        }\r\n        if (qhat == 0)\r\n            continue;\r\n        if (!skipCorrection) {\r\n            long nl = rem.value[j + 2 + rem.offset] & LONG_MASK;\r\n            long rs = ((qrem & LONG_MASK) << 32) | nl;\r\n            long estProduct = (dl & LONG_MASK) * (qhat & LONG_MASK);\r\n            if (unsignedLongCompare(estProduct, rs)) {\r\n                qhat--;\r\n                qrem = (int) ((qrem & LONG_MASK) + dhLong);\r\n                if ((qrem & LONG_MASK) >= dhLong) {\r\n                    estProduct -= (dl & LONG_MASK);\r\n                    rs = ((qrem & LONG_MASK) << 32) | nl;\r\n                    if (unsignedLongCompare(estProduct, rs))\r\n                        qhat--;\r\n                }\r\n            }\r\n        }\r\n        rem.value[j + rem.offset] = 0;\r\n        int borrow = mulsub(rem.value, divisor, qhat, dlen, j + rem.offset);\r\n        if (borrow + 0x80000000 > nh2) {\r\n            divadd(divisor, rem.value, j + 1 + rem.offset);\r\n            qhat--;\r\n        }\r\n        q[j] = qhat;\r\n    }\r\n    int qhat = 0;\r\n    int qrem = 0;\r\n    boolean skipCorrection = false;\r\n    int nh = rem.value[limit - 1 + rem.offset];\r\n    int nh2 = nh + 0x80000000;\r\n    int nm = rem.value[limit + rem.offset];\r\n    if (nh == dh) {\r\n        qhat = ~0;\r\n        qrem = nh + nm;\r\n        skipCorrection = qrem + 0x80000000 < nh2;\r\n    } else {\r\n        long nChunk = (((long) nh) << 32) | (nm & LONG_MASK);\r\n        if (nChunk >= 0) {\r\n            qhat = (int) (nChunk / dhLong);\r\n            qrem = (int) (nChunk - (qhat * dhLong));\r\n        } else {\r\n            long tmp = divWord(nChunk, dh);\r\n            qhat = (int) (tmp & LONG_MASK);\r\n            qrem = (int) (tmp >>> 32);\r\n        }\r\n    }\r\n    if (qhat != 0) {\r\n        if (!skipCorrection) {\r\n            long nl = rem.value[limit + 1 + rem.offset] & LONG_MASK;\r\n            long rs = ((qrem & LONG_MASK) << 32) | nl;\r\n            long estProduct = (dl & LONG_MASK) * (qhat & LONG_MASK);\r\n            if (unsignedLongCompare(estProduct, rs)) {\r\n                qhat--;\r\n                qrem = (int) ((qrem & LONG_MASK) + dhLong);\r\n                if ((qrem & LONG_MASK) >= dhLong) {\r\n                    estProduct -= (dl & LONG_MASK);\r\n                    rs = ((qrem & LONG_MASK) << 32) | nl;\r\n                    if (unsignedLongCompare(estProduct, rs))\r\n                        qhat--;\r\n                }\r\n            }\r\n        }\r\n        int borrow;\r\n        rem.value[limit - 1 + rem.offset] = 0;\r\n        if (needRemainder)\r\n            borrow = mulsub(rem.value, divisor, qhat, dlen, limit - 1 + rem.offset);\r\n        else\r\n            borrow = mulsubBorrow(rem.value, divisor, qhat, dlen, limit - 1 + rem.offset);\r\n        if (borrow + 0x80000000 > nh2) {\r\n            if (needRemainder)\r\n                divadd(divisor, rem.value, limit - 1 + 1 + rem.offset);\r\n            qhat--;\r\n        }\r\n        q[(limit - 1)] = qhat;\r\n    }\r\n    if (needRemainder) {\r\n        if (shift > 0)\r\n            rem.rightShift(shift);\r\n        rem.normalize();\r\n    }\r\n    quotient.normalize();\r\n    return needRemainder ? rem : null;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.JavaToIOSMethodTranslatorTest.testMethodAndStatementTranslation",
	"Comment": "verify that statements within a translated method get translated, too.",
	"Method": "void testMethodAndStatementTranslation(){\r\n    String translation = translateSourceFile(\"class Test { public String toString(boolean value) { return String.valueOf(value); } }\", \"Test\", \"Test.m\");\r\n    assertTranslatedLines(translation, \"- (NSString *)toStringWithBoolean:(jboolean)value {\", \"return NSString_java_valueOfBool_(value);\");\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.ConstantBranchPruner.extractSideEffects",
	"Comment": "returns an expression containing the side effects of the given expression.the evaluated result of the expression may differ from the original.",
	"Method": "Expression extractSideEffects(Expression expr){\r\n    if (expr.getConstantValue() instanceof Boolean) {\r\n        return null;\r\n    }\r\n    switch(expr.getKind()) {\r\n        case INFIX_EXPRESSION:\r\n            {\r\n                List<Expression> operands = ((InfixExpression) expr).getOperands();\r\n                Expression lastOperand = operands.remove(operands.size() - 1);\r\n                lastOperand = extractSideEffects(lastOperand);\r\n                if (lastOperand != null) {\r\n                    operands.add(lastOperand);\r\n                }\r\n                if (operands.size() == 1) {\r\n                    return operands.remove(0);\r\n                }\r\n                return TreeUtil.remove(expr);\r\n            }\r\n        case PARENTHESIZED_EXPRESSION:\r\n            {\r\n                Expression sideEffects = extractSideEffects(((ParenthesizedExpression) expr).getExpression());\r\n                if (sideEffects != null) {\r\n                    return ParenthesizedExpression.parenthesize(sideEffects);\r\n                }\r\n                return null;\r\n            }\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerArrayTest.testIndexing",
	"Comment": "get and set for out of bound indices throw indexoutofboundsexception",
	"Method": "void testIndexing(){\r\n    AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);\r\n    for (int index : new int[] { -1, SIZE }) {\r\n        try {\r\n            aa.get(index);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.set(index, 1);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.lazySet(index, 1);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.compareAndSet(index, 1, 2);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.weakCompareAndSet(index, 1, 2);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.getAndAdd(index, 1);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.addAndGet(index, 1);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.nio.charset.CharsetEncoder.averageBytesPerChar",
	"Comment": "returns the average number of bytes that will be produced for eachcharacter of input.this heuristic value may be used to estimate the sizeof the output buffer required for a given input sequence.",
	"Method": "float averageBytesPerChar(){\r\n    return averageBytesPerChar;\r\n}"
}, {
	"Path": "java.util.stream.SliceOps.calcSliceFence",
	"Comment": "calculates the slice fence, which is one past the index of the slicerange",
	"Method": "long calcSliceFence(long skip,long limit){\r\n    long sliceFence = limit >= 0 ? skip + limit : Long.MAX_VALUE;\r\n    return (sliceFence >= 0) ? sliceFence : Long.MAX_VALUE;\r\n}"
}, {
	"Path": "java.util.jar.JarFile.getJarEntry",
	"Comment": "returns the jarentry for the given entry name ornull if not found.",
	"Method": "JarEntry getJarEntry(String name){\r\n    return (JarEntry) getEntry(name);\r\n}"
}, {
	"Path": "java.util.ArrayList.retainAll",
	"Comment": "retains only the elements in this list that are contained in thespecified collection.in other words, removes from this list allof its elements that are not contained in the specified collection.",
	"Method": "boolean retainAll(Collection<?> c){\r\n    return batchRemove(c, true);\r\n}"
}, {
	"Path": "java.util.IntSummaryStatistics.getAverage",
	"Comment": "returns the arithmetic mean of values recorded, or zero if no values have beenrecorded.",
	"Method": "double getAverage(){\r\n    return getCount() > 0 ? (double) getSum() / getCount() : 0.0d;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.ast.TreeUtil.trimParentheses",
	"Comment": "returns the first descendant of the given node that is not a parenthesizedexpression.",
	"Method": "Expression trimParentheses(Expression node){\r\n    while (node instanceof ParenthesizedExpression) {\r\n        node = ((ParenthesizedExpression) node).getExpression();\r\n    }\r\n    return node;\r\n}"
}, {
	"Path": "java.util.zip.ZipInputStream.available",
	"Comment": "returns 0 after eof has reached for the current entry data,otherwise always return 1.programs should not count on this method to return the actual numberof bytes that could be read without blocking.",
	"Method": "int available(){\r\n    ensureOpen();\r\n    if (entryEOF || (entry != null && remaining == 0)) {\r\n        return 0;\r\n    } else {\r\n        return 1;\r\n    }\r\n}"
}, {
	"Path": "java.net.AbstractPlainDatagramSocketImpl.disconnect",
	"Comment": "disconnects a previously connected socket. does nothing if the socket wasnot connected already.",
	"Method": "void disconnect(){\r\n    disconnect0(connectedAddress.holder().getFamily());\r\n    connected = false;\r\n    connectedAddress = null;\r\n    connectedPort = -1;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.ClassFile.getName",
	"Comment": "returns the simple name of the type defined by this class file.",
	"Method": "String getName(){\r\n    return type.getName();\r\n}"
}, {
	"Path": "jsr166.ConcurrentLinkedDequeTest.testConstructor6",
	"Comment": "deque contains all elements of collection used to initialize",
	"Method": "void testConstructor6(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = new Integer(i);\r\n    ConcurrentLinkedDeque q = new ConcurrentLinkedDeque(Arrays.asList(ints));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "sun.security.provider.certpath.X509CertPath.getEncoded",
	"Comment": "returns the encoded form of this certification path, using thespecified encoding.",
	"Method": "byte[] getEncoded(byte[] getEncoded,String encoding){\r\n    switch(encoding) {\r\n        case PKIPATH_ENCODING:\r\n            return encodePKIPATH();\r\n        case PKCS7_ENCODING:\r\n            return encodePKCS7();\r\n        default:\r\n            throw new CertificateEncodingException(\"unsupported encoding\");\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.format.DateFormatTest.TestPartialParse994",
	"Comment": "verify that strings which contain incomplete specifications are parsedcorrectly.in some instances, this means not being parsed at all, andreturning an appropriate error.",
	"Method": "void TestPartialParse994(){\r\n    SimpleDateFormat f = new SimpleDateFormat();\r\n    Calendar cal = Calendar.getInstance();\r\n    cal.clear();\r\n    cal.set(1997, 1 - 1, 17, 10, 11, 42);\r\n    Date date = null;\r\n    tryPat994(f, \"yy/MM/dd HH:mm:ss\", \"97/01/17 10:11:42\", cal.getTime());\r\n    tryPat994(f, \"yy/MM/dd HH:mm:ss\", \"97/01/17 10:\", date);\r\n    tryPat994(f, \"yy/MM/dd HH:mm:ss\", \"97/01/17 10\", date);\r\n    tryPat994(f, \"yy/MM/dd HH:mm:ss\", \"97/01/17 \", date);\r\n    tryPat994(f, \"yy/MM/dd HH:mm:ss\", \"97/01/17\", date);\r\n}"
}, {
	"Path": "java.util.WeakHashMap.containsKey",
	"Comment": "returns true if this map contains a mapping for thespecified key.",
	"Method": "boolean containsKey(Object key){\r\n    return getEntry(key) != null;\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkTimedGetCC",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGetCC(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FailingCCF f = new LFCCF(null, 8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkTimedGetCC",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGetCC(){\r\n    FailingCCF f = new LFCCF(null, 8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n}"
}, {
	"Path": "java.math.BigInteger.trustedStripLeadingZeroInts",
	"Comment": "returns the input array stripped of any leading zero bytes.since the source is trusted the copying may be skipped.",
	"Method": "int[] trustedStripLeadingZeroInts(int val){\r\n    int vlen = val.length;\r\n    int keep;\r\n    for (keep = 0; keep < vlen && val[keep] == 0; keep++) ;\r\n    return keep == 0 ? val : java.util.Arrays.copyOfRange(val, keep, vlen);\r\n}"
}, {
	"Path": "java.net.InetAddress.isMCOrgLocal",
	"Comment": "utility routine to check if the multicast address has organization scope.",
	"Method": "boolean isMCOrgLocal(){\r\n    return false;\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.getMinCRL",
	"Comment": "returns the mincrlnumber criterion. the x509crl must have acrl number extension whose value is greater than or equal to thespecified value. if null, no mincrlnumber check will be done.",
	"Method": "BigInteger getMinCRL(){\r\n    return minCRL;\r\n}"
}, {
	"Path": "java.text.DecimalFormat.subformat",
	"Comment": "complete the formatting of a finite number.on entry, the digitlist mustbe filled in with the correct digits.",
	"Method": "StringBuffer subformat(StringBuffer result,FieldDelegate delegate,boolean isNegative,boolean isInteger,int maxIntDigits,int minIntDigits,int maxFraDigits,int minFraDigits){\r\n    char zero = symbols.getZeroDigit();\r\n    int zeroDelta = zero - '0';\r\n    char grouping = symbols.getGroupingSeparator();\r\n    char decimal = isCurrencyFormat ? symbols.getMonetaryDecimalSeparator() : symbols.getDecimalSeparator();\r\n    if (digitList.isZero()) {\r\n        digitList.decimalAt = 0;\r\n    }\r\n    if (isNegative) {\r\n        append(result, negativePrefix, delegate, getNegativePrefixFieldPositions(), Field.SIGN);\r\n    } else {\r\n        append(result, positivePrefix, delegate, getPositivePrefixFieldPositions(), Field.SIGN);\r\n    }\r\n    if (useExponentialNotation) {\r\n        int iFieldStart = result.length();\r\n        int iFieldEnd = -1;\r\n        int fFieldStart = -1;\r\n        int exponent = digitList.decimalAt;\r\n        int repeat = maxIntDigits;\r\n        int minimumIntegerDigits = minIntDigits;\r\n        if (repeat > 1 && repeat > minIntDigits) {\r\n            if (exponent >= 1) {\r\n                exponent = ((exponent - 1) / repeat) * repeat;\r\n            } else {\r\n                exponent = ((exponent - repeat) / repeat) * repeat;\r\n            }\r\n            minimumIntegerDigits = 1;\r\n        } else {\r\n            exponent -= minimumIntegerDigits;\r\n        }\r\n        int minimumDigits = minIntDigits + minFraDigits;\r\n        if (minimumDigits < 0) {\r\n            minimumDigits = Integer.MAX_VALUE;\r\n        }\r\n        int integerDigits = digitList.isZero() ? minimumIntegerDigits : digitList.decimalAt - exponent;\r\n        if (minimumDigits < integerDigits) {\r\n            minimumDigits = integerDigits;\r\n        }\r\n        int totalDigits = digitList.count;\r\n        if (minimumDigits > totalDigits) {\r\n            totalDigits = minimumDigits;\r\n        }\r\n        boolean addedDecimalSeparator = false;\r\n        for (int i = 0; i < totalDigits; ++i) {\r\n            if (i == integerDigits) {\r\n                iFieldEnd = result.length();\r\n                result.append(decimal);\r\n                addedDecimalSeparator = true;\r\n                fFieldStart = result.length();\r\n            }\r\n            result.append((i < digitList.count) ? (char) (digitList.digits[i] + zeroDelta) : zero);\r\n        }\r\n        if (decimalSeparatorAlwaysShown && totalDigits == integerDigits) {\r\n            iFieldEnd = result.length();\r\n            result.append(decimal);\r\n            addedDecimalSeparator = true;\r\n            fFieldStart = result.length();\r\n        }\r\n        if (iFieldEnd == -1) {\r\n            iFieldEnd = result.length();\r\n        }\r\n        delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER, iFieldStart, iFieldEnd, result);\r\n        if (addedDecimalSeparator) {\r\n            delegate.formatted(Field.DECIMAL_SEPARATOR, Field.DECIMAL_SEPARATOR, iFieldEnd, fFieldStart, result);\r\n        }\r\n        if (fFieldStart == -1) {\r\n            fFieldStart = result.length();\r\n        }\r\n        delegate.formatted(FRACTION_FIELD, Field.FRACTION, Field.FRACTION, fFieldStart, result.length(), result);\r\n        int fieldStart = result.length();\r\n        result.append(symbols.getExponentSeparator());\r\n        delegate.formatted(Field.EXPONENT_SYMBOL, Field.EXPONENT_SYMBOL, fieldStart, result.length(), result);\r\n        if (digitList.isZero()) {\r\n            exponent = 0;\r\n        }\r\n        boolean negativeExponent = exponent < 0;\r\n        if (negativeExponent) {\r\n            exponent = -exponent;\r\n            fieldStart = result.length();\r\n            result.append(symbols.getMinusSign());\r\n            delegate.formatted(Field.EXPONENT_SIGN, Field.EXPONENT_SIGN, fieldStart, result.length(), result);\r\n        }\r\n        digitList.set(negativeExponent, exponent);\r\n        int eFieldStart = result.length();\r\n        for (int i = digitList.decimalAt; i < minExponentDigits; ++i) {\r\n            result.append(zero);\r\n        }\r\n        for (int i = 0; i < digitList.decimalAt; ++i) {\r\n            result.append((i < digitList.count) ? (char) (digitList.digits[i] + zeroDelta) : zero);\r\n        }\r\n        delegate.formatted(Field.EXPONENT, Field.EXPONENT, eFieldStart, result.length(), result);\r\n    } else {\r\n        int iFieldStart = result.length();\r\n        int count = minIntDigits;\r\n        int digitIndex = 0;\r\n        if (digitList.decimalAt > 0 && count < digitList.decimalAt) {\r\n            count = digitList.decimalAt;\r\n        }\r\n        if (count > maxIntDigits) {\r\n            count = maxIntDigits;\r\n            digitIndex = digitList.decimalAt - count;\r\n        }\r\n        int sizeBeforeIntegerPart = result.length();\r\n        for (int i = count - 1; i >= 0; --i) {\r\n            if (i < digitList.decimalAt && digitIndex < digitList.count) {\r\n                result.append((char) (digitList.digits[digitIndex++] + zeroDelta));\r\n            } else {\r\n                result.append(zero);\r\n            }\r\n            if (isGroupingUsed() && i > 0 && (groupingSize != 0) && (secondaryGroupingSize > 0 && i > groupingSize ? (i - groupingSize) % secondaryGroupingSize == 0 : i % groupingSize == 0)) {\r\n                int gStart = result.length();\r\n                result.append(grouping);\r\n                delegate.formatted(Field.GROUPING_SEPARATOR, Field.GROUPING_SEPARATOR, gStart, result.length(), result);\r\n            }\r\n        }\r\n        boolean fractionPresent = (minFraDigits > 0) || (!isInteger && digitIndex < digitList.count);\r\n        if (!fractionPresent && result.length() == sizeBeforeIntegerPart) {\r\n            result.append(zero);\r\n        }\r\n        delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER, iFieldStart, result.length(), result);\r\n        int sStart = result.length();\r\n        if (decimalSeparatorAlwaysShown || fractionPresent) {\r\n            result.append(decimal);\r\n        }\r\n        if (sStart != result.length()) {\r\n            delegate.formatted(Field.DECIMAL_SEPARATOR, Field.DECIMAL_SEPARATOR, sStart, result.length(), result);\r\n        }\r\n        int fFieldStart = result.length();\r\n        for (int i = 0; i < maxFraDigits; ++i) {\r\n            if (i >= minFraDigits && (isInteger || digitIndex >= digitList.count)) {\r\n                break;\r\n            }\r\n            if (-1 - i > (digitList.decimalAt - 1)) {\r\n                result.append(zero);\r\n                continue;\r\n            }\r\n            if (!isInteger && digitIndex < digitList.count) {\r\n                result.append((char) (digitList.digits[digitIndex++] + zeroDelta));\r\n            } else {\r\n                result.append(zero);\r\n            }\r\n        }\r\n        delegate.formatted(FRACTION_FIELD, Field.FRACTION, Field.FRACTION, fFieldStart, result.length(), result);\r\n    }\r\n    if (isNegative) {\r\n        append(result, negativeSuffix, delegate, getNegativeSuffixFieldPositions(), Field.SIGN);\r\n    } else {\r\n        append(result, positiveSuffix, delegate, getPositiveSuffixFieldPositions(), Field.SIGN);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "java.util.concurrent.ThreadPoolExecutor.getTaskCount",
	"Comment": "returns the approximate total number of tasks that have ever beenscheduled for execution. because the states of tasks andthreads may change dynamically during computation, the returnedvalue is only an approximation.",
	"Method": "long getTaskCount(){\r\n    final ReentrantLock mainLock = this.mainLock;\r\n    mainLock.lock();\r\n    try {\r\n        long n = completedTaskCount;\r\n        for (Worker w : workers) {\r\n            n += w.completedTasks;\r\n            if (w.isLocked())\r\n                ++n;\r\n        }\r\n        return n + workQueue.size();\r\n    } finally {\r\n        mainLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.format.IntlTestNumberFormatAPI.TestAPI",
	"Comment": "this test checks various generic api methods in decimalformat to achieve 100% api coverage.",
	"Method": "void TestAPI(){\r\n    logln(\"NumberFormat API test---\");\r\n    logln(\"\");\r\n    Locale.setDefault(Locale.ENGLISH);\r\n    logln(\"Testing NumberFormat constructors\");\r\n    NumberFormat def = NumberFormat.getInstance();\r\n    NumberFormat fr = NumberFormat.getInstance(Locale.FRENCH);\r\n    NumberFormat cur = NumberFormat.getCurrencyInstance();\r\n    NumberFormat cur_fr = NumberFormat.getCurrencyInstance(Locale.FRENCH);\r\n    NumberFormat per = NumberFormat.getPercentInstance();\r\n    NumberFormat per_fr = NumberFormat.getPercentInstance(Locale.FRENCH);\r\n    NumberFormat integer = NumberFormat.getIntegerInstance();\r\n    NumberFormat int_fr = NumberFormat.getIntegerInstance(Locale.FRENCH);\r\n    logln(\"Currency : \" + cur.format(1234.5));\r\n    logln(\"Percent : \" + per.format(1234.5));\r\n    logln(\"Integer : \" + integer.format(1234.5));\r\n    logln(\"Int_fr : \" + int_fr.format(1234.5));\r\n    logln(\"Testing equality operator\");\r\n    if (per_fr.equals(cur_fr)) {\r\n        errln(\"ERROR: == failed\");\r\n    }\r\n    logln(\"Testing various format() methods\");\r\n    final double d = -10456.00370000000000;\r\n    final long l = 100000000;\r\n    String res1 = new String();\r\n    String res2 = new String();\r\n    StringBuffer res3 = new StringBuffer();\r\n    StringBuffer res4 = new StringBuffer();\r\n    StringBuffer res5 = new StringBuffer();\r\n    StringBuffer res6 = new StringBuffer();\r\n    FieldPosition pos1 = new FieldPosition(0);\r\n    FieldPosition pos2 = new FieldPosition(0);\r\n    FieldPosition pos3 = new FieldPosition(0);\r\n    FieldPosition pos4 = new FieldPosition(0);\r\n    res1 = cur_fr.format(d);\r\n    logln(\"\" + d + \" formatted to \" + res1);\r\n    res2 = cur_fr.format(l);\r\n    logln(\"\" + l + \" formatted to \" + res2);\r\n    res3 = cur_fr.format(d, res3, pos1);\r\n    logln(\"\" + d + \" formatted to \" + res3);\r\n    res4 = cur_fr.format(l, res4, pos2);\r\n    logln(\"\" + l + \" formatted to \" + res4);\r\n    res5 = cur_fr.format(d, res5, pos3);\r\n    logln(\"\" + d + \" formatted to \" + res5);\r\n    res6 = cur_fr.format(l, res6, pos4);\r\n    logln(\"\" + l + \" formatted to \" + res6);\r\n    logln(\"Testing parse()\");\r\n    String text = new String(\"-10456,0037\");\r\n    ParsePosition pos = new ParsePosition(0);\r\n    ParsePosition pos01 = new ParsePosition(0);\r\n    double d1 = ((Number) fr.parseObject(text, pos)).doubleValue();\r\n    if (d1 != d) {\r\n        errln(\"ERROR: Roundtrip failed (via parse()) for \" + text);\r\n    }\r\n    logln(text + \" parsed into \" + d1);\r\n    double d2 = fr.parse(text, pos01).doubleValue();\r\n    if (d2 != d) {\r\n        errln(\"ERROR: Roundtrip failed (via parse()) for \" + text);\r\n    }\r\n    logln(text + \" parsed into \" + d2);\r\n    double d3 = 0;\r\n    try {\r\n        d3 = fr.parse(text).doubleValue();\r\n    } catch (ParseException e) {\r\n        errln(\"ERROR: parse() failed\");\r\n    }\r\n    if (d3 != d) {\r\n        errln(\"ERROR: Roundtrip failed (via parse()) for \" + text);\r\n    }\r\n    logln(text + \" parsed into \" + d3);\r\n    logln(\"Testing getters and setters\");\r\n    final Locale[] locales = NumberFormat.getAvailableLocales();\r\n    long count = locales.length;\r\n    logln(\"Got \" + count + \" locales\");\r\n    for (int i = 0; i < count; i++) {\r\n        String name;\r\n        name = locales[i].getDisplayName();\r\n        logln(name);\r\n    }\r\n    fr.setParseIntegerOnly(def.isParseIntegerOnly());\r\n    if (fr.isParseIntegerOnly() != def.isParseIntegerOnly()) {\r\n        errln(\"ERROR: setParseIntegerOnly() failed\");\r\n    }\r\n    fr.setGroupingUsed(def.isGroupingUsed());\r\n    if (fr.isGroupingUsed() != def.isGroupingUsed()) {\r\n        errln(\"ERROR: setGroupingUsed() failed\");\r\n    }\r\n    fr.setMaximumIntegerDigits(def.getMaximumIntegerDigits());\r\n    if (fr.getMaximumIntegerDigits() != def.getMaximumIntegerDigits()) {\r\n        errln(\"ERROR: setMaximumIntegerDigits() failed\");\r\n    }\r\n    fr.setMinimumIntegerDigits(def.getMinimumIntegerDigits());\r\n    if (fr.getMinimumIntegerDigits() != def.getMinimumIntegerDigits()) {\r\n        errln(\"ERROR: setMinimumIntegerDigits() failed\");\r\n    }\r\n    fr.setMaximumFractionDigits(def.getMaximumFractionDigits());\r\n    if (fr.getMaximumFractionDigits() != def.getMaximumFractionDigits()) {\r\n        errln(\"ERROR: setMaximumFractionDigits() failed\");\r\n    }\r\n    fr.setMinimumFractionDigits(def.getMinimumFractionDigits());\r\n    if (fr.getMinimumFractionDigits() != def.getMinimumFractionDigits()) {\r\n        errln(\"ERROR: setMinimumFractionDigits() failed\");\r\n    }\r\n}"
}, {
	"Path": "libcore.java.util.Base64Test.decodeToAscii",
	"Comment": "decodes a string, returning the resulting bytes interpreted as an ascii string.",
	"Method": "String decodeToAscii(Decoder decoder,String encoded){\r\n    byte[] plain = decoder.decode(encoded);\r\n    return new String(plain, US_ASCII);\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinPool.tryAddWorker",
	"Comment": "tries to add one worker, incrementing ctl counts before doingso, relying on createworker to back out on failure.",
	"Method": "void tryAddWorker(long c){\r\n    do {\r\n        long nc = ((AC_MASK & (c + AC_UNIT)) | (TC_MASK & (c + TC_UNIT)));\r\n        if (ctl == c && U.compareAndSwapLong(this, CTL, c, nc)) {\r\n            createWorker(false);\r\n            break;\r\n        }\r\n    } while (((c = ctl) & ADD_WORKER) != 0L && (int) c == 0);\r\n}"
}, {
	"Path": "java.time.format.DecimalStyle.getPositiveSign",
	"Comment": "gets the character that represents the positive sign.the character used to represent a positive number may vary by culture.this method specifies the character to use.",
	"Method": "char getPositiveSign(){\r\n    return positiveSign;\r\n}"
}, {
	"Path": "jsr166.ConcurrentLinkedDequeTest.testConstructor5",
	"Comment": "initializing from collection with some null elements throws npe",
	"Method": "void testConstructor5(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        new ConcurrentLinkedDeque(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.util.stream.AbstractPipeline.evaluate",
	"Comment": "evaluate the pipeline with a terminal operation to produce a result.",
	"Method": "R evaluate(TerminalOp<E_OUT, R> terminalOp,Node<E_OUT> evaluate,Spliterator<P_IN> spliterator,boolean flatten,IntFunction<E_OUT[]> generator){\r\n    if (isParallel()) {\r\n        return evaluateToNode(this, spliterator, flatten, generator);\r\n    } else {\r\n        Node.Builder<E_OUT> nb = makeNodeBuilder(exactOutputSizeIfKnown(spliterator), generator);\r\n        return wrapAndCopyInto(nb, spliterator).build();\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.assertHasWaitersUnlocked",
	"Comment": "checks that condition c has exactly the given waiter threads,after acquiring mutex.",
	"Method": "void assertHasWaitersUnlocked(Mutex sync,ConditionObject c,Thread threads){\r\n    sync.acquire();\r\n    assertHasWaitersLocked(sync, c, threads);\r\n    sync.release();\r\n}"
}, {
	"Path": "jsr166.AtomicLongFieldUpdaterTest.testConstructor2",
	"Comment": "construction with field not of given type throws illegalargumentexception",
	"Method": "void testConstructor2(){\r\n    try {\r\n        updaterFor(\"z\");\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.nio.channels.SelectorTest.test_cancelledKeys",
	"Comment": "this test cancels a key while selecting to verify that the cancelledkey set is processed both before and after the call to the underlyingoperating system.",
	"Method": "void test_cancelledKeys(){\r\n    final AtomicReference<Throwable> failure = new AtomicReference<Throwable>();\r\n    final AtomicBoolean complete = new AtomicBoolean();\r\n    final Pipe pipe = Pipe.open();\r\n    pipe.source().configureBlocking(false);\r\n    final SelectionKey key = pipe.source().register(selector, SelectionKey.OP_READ);\r\n    Thread thread = new Thread() {\r\n        public void run() {\r\n            try {\r\n                Thread.sleep(500);\r\n                key.cancel();\r\n                assertFalse(key.isValid());\r\n                pipe.sink().write(ByteBuffer.allocate(4));\r\n            } catch (Throwable e) {\r\n                failure.set(e);\r\n            } finally {\r\n                complete.set(true);\r\n            }\r\n        }\r\n    };\r\n    assertTrue(key.isValid());\r\n    thread.start();\r\n    do {\r\n        assertEquals(0, selector.select(5000));\r\n        assertEquals(0, selector.selectedKeys().size());\r\n    } while (!complete.get());\r\n    assertFalse(key.isValid());\r\n    thread.join();\r\n    assertNull(failure.get());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.nio.channels.SelectorTest.test_cancelledKeys",
	"Comment": "this test cancels a key while selecting to verify that the cancelledkey set is processed both before and after the call to the underlyingoperating system.",
	"Method": "void test_cancelledKeys(){\r\n    try {\r\n        Thread.sleep(500);\r\n        key.cancel();\r\n        assertFalse(key.isValid());\r\n        pipe.sink().write(ByteBuffer.allocate(4));\r\n    } catch (Throwable e) {\r\n        failure.set(e);\r\n    } finally {\r\n        complete.set(true);\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedSynchronizer.fullGetFirstQueuedThread",
	"Comment": "version of getfirstqueuedthread called when fastpath fails.",
	"Method": "Thread fullGetFirstQueuedThread(){\r\n    Node h, s;\r\n    Thread st;\r\n    if (((h = head) != null && (s = h.next) != null && s.prev == head && (st = s.thread) != null) || ((h = head) != null && (s = h.next) != null && s.prev == head && (st = s.thread) != null))\r\n        return st;\r\n    Thread firstThread = null;\r\n    for (Node p = tail; p != null && p != head; p = p.prev) {\r\n        Thread t = p.thread;\r\n        if (t != null)\r\n            firstThread = t;\r\n    }\r\n    return firstThread;\r\n}"
}, {
	"Path": "java.time.format.DateTimeFormatterBuilder.toFormatter",
	"Comment": "completes this builder by creating the formatter.this uses the default locale.",
	"Method": "DateTimeFormatter toFormatter(DateTimeFormatter toFormatter,Locale locale,DateTimeFormatter toFormatter,ResolverStyle resolverStyle,Chronology chrono,DateTimeFormatter toFormatter,Locale locale,ResolverStyle resolverStyle,Chronology chrono){\r\n    Objects.requireNonNull(locale, \"locale\");\r\n    while (active.parent != null) {\r\n        optionalEnd();\r\n    }\r\n    CompositePrinterParser pp = new CompositePrinterParser(printerParsers, false);\r\n    return new DateTimeFormatter(pp, locale, DecimalStyle.STANDARD, resolverStyle, null, chrono, null);\r\n}"
}, {
	"Path": "sun.security.x509.IssuerAlternativeNameExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(ISSUER_NAME);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testCompleteExceptionally",
	"Comment": "invoke task throws exception after invoking completeexceptionally",
	"Method": "void testCompleteExceptionally(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib f = new AsyncFib(8);\r\n            f.completeExceptionally(new FJException());\r\n            try {\r\n                f.invoke();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testCompleteExceptionally",
	"Comment": "invoke task throws exception after invoking completeexceptionally",
	"Method": "void testCompleteExceptionally(){\r\n    AsyncFib f = new AsyncFib(8);\r\n    f.completeExceptionally(new FJException());\r\n    try {\r\n        f.invoke();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "org.xml.sax.helpers.ParserAdapter.setProperty",
	"Comment": "set a parser property.no properties are currently recognized.",
	"Method": "void setProperty(String name,Object value){\r\n    throw new SAXNotRecognizedException(\"Property: \" + name);\r\n}"
}, {
	"Path": "java.util.Date.setDate",
	"Comment": "sets the day of the month of this date object to thespecified value. this date object is modified so thatit represents a point in time within the specified day of themonth, with the year, month, hour, minute, and second the sameas before, as interpreted in the local time zone. if the datewas april 30, for example, and the date is set to 31, then itwill be treated as if it were on may 1, because april has only30 days.",
	"Method": "void setDate(int date){\r\n    getCalendarDate().setDayOfMonth(date);\r\n}"
}, {
	"Path": "java.net.Inet4Address.getHostAddress",
	"Comment": "returns the ip address string in textual presentation form.",
	"Method": "String getHostAddress(){\r\n    return numericToTextFormat(getAddress());\r\n}"
}, {
	"Path": "android.icu.dev.test.timezone.TimeZoneRegressionTest.TestJ5134",
	"Comment": "getoffset returns wrong offset for days in early 20th century",
	"Method": "void TestJ5134(){\r\n    GregorianCalendar testCal = (GregorianCalendar) Calendar.getInstance();\r\n    TimeZone icuEastern = TimeZone.getTimeZone(\"America/New_York\");\r\n    testCal.setTimeZone(icuEastern);\r\n    testCal.set(1900, Calendar.JANUARY, 1, 0, 0, 0);\r\n    long time = testCal.getTimeInMillis();\r\n    int offset = icuEastern.getOffset(time);\r\n    if (offset != -18000000) {\r\n        errln(\"FAIL: UTC offset in time zone America/New_York on Jan 1, 1900 -> \" + offset);\r\n    }\r\n    boolean isDst = icuEastern.inDaylightTime(new Date(time));\r\n    if (isDst) {\r\n        errln(\"FAIL: DST is observed in time zone America/New_York on Jan 1, 1900\");\r\n    }\r\n    if (System.getProperty(\"java.vendor\", \"\").startsWith(\"IBM\") && System.getProperty(\"java.version\", \"\").equals(\"1.4.1\")) {\r\n        return;\r\n    }\r\n    java.util.TimeZone jdkEastern = java.util.TimeZone.getTimeZone(\"America/New_York\");\r\n    testCal.add(Calendar.YEAR, 50);\r\n    long endTime = testCal.getTimeInMillis();\r\n    int jdkOffset;\r\n    boolean isDstJdk;\r\n    while (time < endTime) {\r\n        offset = icuEastern.getOffset(time);\r\n        jdkOffset = jdkEastern.getOffset(time);\r\n        if (offset != jdkOffset) {\r\n            errln(\"FAIL: Incompatible UTC offset -> JDK:\" + jdkOffset + \"/ICU:\" + offset + \" [\" + time + \"]\");\r\n        }\r\n        Date d = new Date(time);\r\n        isDst = icuEastern.inDaylightTime(d);\r\n        isDstJdk = jdkEastern.inDaylightTime(d);\r\n        if (isDst != isDstJdk) {\r\n            errln(\"FAIL: Incompatible DST -> JDK:\" + isDstJdk + \"/ICU:\" + isDst + \" [\" + time + \"]\");\r\n        }\r\n        time += 24 * 60 * 60 * 1000L;\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testElement",
	"Comment": "element returns next element, or throws nosuchelementexception if empty",
	"Method": "void testElement(){\r\n    LinkedTransferQueue<Integer> q = populatedQueue(SIZE);\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(i, (int) q.element());\r\n        assertEquals(i, (int) q.poll());\r\n    }\r\n    try {\r\n        q.element();\r\n        shouldThrow();\r\n    } catch (NoSuchElementException success) {\r\n    }\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "java.util.logging.ErrorManager.error",
	"Comment": "the error method is called when a handler failure occurs.this method may be overridden in subclasses.the defaultbehavior in this base class is that the first call isreported to system.err, and subsequent calls are ignored.",
	"Method": "void error(String msg,Exception ex,int code){\r\n    if (reported) {\r\n        return;\r\n    }\r\n    reported = true;\r\n    String text = \"java.util.logging.ErrorManager: \" + code;\r\n    if (msg != null) {\r\n        text = text + \": \" + msg;\r\n    }\r\n    System.err.println(text);\r\n    if (ex != null) {\r\n        ex.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.SignatureGenerator.createMethodTypeSignature",
	"Comment": "create a method signature string for a specified method or constructor.",
	"Method": "String createMethodTypeSignature(ExecutableElement method){\r\n    if (!hasGenericSignature(method)) {\r\n        return null;\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    genMethodTypeSignature(method, sb);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "java.util.Vector.retainAll",
	"Comment": "retains only the elements in this vector that are contained in thespecified collection.in other words, removes from this vector allof its elements that are not contained in the specified collection.",
	"Method": "boolean retainAll(Collection<?> c){\r\n    return super.retainAll(c);\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedSynchronizer.isOnSyncQueue",
	"Comment": "returns true if a node, always one that was initially placed ona condition queue, is now waiting to reacquire on sync queue.",
	"Method": "boolean isOnSyncQueue(Node node){\r\n    if (node.waitStatus == Node.CONDITION || node.prev == null)\r\n        return false;\r\n    if (node.next != null)\r\n        return true;\r\n    return findNodeFromTail(node);\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentLinkedDeque.screenNullResult",
	"Comment": "returns element unless it is null, in which case throwsnosuchelementexception.",
	"Method": "E screenNullResult(E v){\r\n    if (v == null)\r\n        throw new NoSuchElementException();\r\n    return v;\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    final BlockingQueue q = populatedQueue(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(i, q.take());\r\n            }\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadStaysAlive(t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(i, q.take());\r\n    }\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n}"
}, {
	"Path": "javax.xml.datatype.FactoryFinder.newInstance",
	"Comment": "create an instance of a class using the specified classloader.",
	"Method": "Object newInstance(String className,ClassLoader classLoader){\r\n    try {\r\n        Class spiClass;\r\n        if (classLoader == null) {\r\n            spiClass = Class.forName(className);\r\n        } else {\r\n            spiClass = classLoader.loadClass(className);\r\n        }\r\n        if (debug) {\r\n            debugPrintln(\"Loaded \" + className + \" from \" + which(spiClass));\r\n        }\r\n        return spiClass.newInstance();\r\n    } catch (ClassNotFoundException x) {\r\n        throw new ConfigurationError(\"Provider \" + className + \" not found\", x);\r\n    } catch (Exception x) {\r\n        throw new ConfigurationError(\"Provider \" + className + \" could not be instantiated: \" + x, x);\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.SunCertPathBuilderResult.getAdjacencyList",
	"Comment": "returns the adjacency list containing information about the build.",
	"Method": "AdjacencyList getAdjacencyList(){\r\n    return adjList;\r\n}"
}, {
	"Path": "android.icu.dev.util.UnicodeMap.keySet",
	"Comment": "returns the keyset consisting of all the keys that would produce the given value.the new values.",
	"Method": "UnicodeSet keySet(T value,UnicodeSet result,UnicodeSet keySet,T value,UnicodeSet keySet){\r\n    UnicodeSet result = new UnicodeSet();\r\n    for (int i = 0; i < length - 1; ++i) {\r\n        if (values[i] != null) {\r\n            result.add(transitions[i], transitions[i + 1] - 1);\r\n        }\r\n    }\r\n    if (stringMap != null) {\r\n        result.addAll(stringMap.keySet());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "java.text.SimpleDateFormat.formatToCharacterIterator",
	"Comment": "formats an object producing an attributedcharacteriterator.you can use the returned attributedcharacteriteratorto build the resulting string, as well as to determine informationabout the resulting string.each attribute key of the attributedcharacteriterator will be of typedateformat.field, with the corresponding attribute valuebeing the same as the attribute key.",
	"Method": "AttributedCharacterIterator formatToCharacterIterator(Object obj){\r\n    StringBuffer sb = new StringBuffer();\r\n    CharacterIteratorFieldDelegate delegate = new CharacterIteratorFieldDelegate();\r\n    if (obj instanceof Date) {\r\n        format((Date) obj, sb, delegate);\r\n    } else if (obj instanceof Number) {\r\n        format(new Date(((Number) obj).longValue()), sb, delegate);\r\n    } else if (obj == null) {\r\n        throw new NullPointerException(\"formatToCharacterIterator must be passed non-null object\");\r\n    } else {\r\n        throw new IllegalArgumentException(\"Cannot format given Object as a Date\");\r\n    }\r\n    return delegate.getIterator(sb.toString());\r\n}"
}, {
	"Path": "javax.xml.transform.TransformerException.getLocator",
	"Comment": "method getlocator retrieves an instance of a sourcelocatorobject that specifies where an error occurred.",
	"Method": "SourceLocator getLocator(){\r\n    return locator;\r\n}"
}, {
	"Path": "java.util.zip.ZipFile.getInputStream",
	"Comment": "returns an input stream for reading the contents of the specifiedzip file entry. closing this zip file will, in turn, close all inputstreams that have been returned by invocations of this method.",
	"Method": "InputStream getInputStream(ZipEntry entry){\r\n    if (entry == null) {\r\n        throw new NullPointerException(\"entry\");\r\n    }\r\n    long jzentry = 0;\r\n    ZipFileInputStream in = null;\r\n    synchronized (this) {\r\n        ensureOpen();\r\n        if (!zc.isUTF8() && (entry.flag & EFS) != 0) {\r\n            jzentry = getEntry(jzfile, zc.getBytesUTF8(entry.name), true);\r\n        } else {\r\n            jzentry = getEntry(jzfile, zc.getBytes(entry.name), true);\r\n        }\r\n        if (jzentry == 0) {\r\n            return null;\r\n        }\r\n        in = new ZipFileInputStream(jzentry);\r\n        switch(getEntryMethod(jzentry)) {\r\n            case STORED:\r\n                synchronized (streams) {\r\n                    streams.put(in, null);\r\n                }\r\n                return in;\r\n            case DEFLATED:\r\n                long size = getEntrySize(jzentry) + 2;\r\n                if (size > 65536)\r\n                    size = 8192;\r\n                if (size <= 0)\r\n                    size = 4096;\r\n                Inflater inf = getInflater();\r\n                InputStream is = new ZipFileInflaterInputStream(in, inf, (int) size);\r\n                synchronized (streams) {\r\n                    streams.put(is, inf);\r\n                }\r\n                return is;\r\n            default:\r\n                throw new ZipException(\"invalid compression method\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testIntArrayGetAndUpdate",
	"Comment": "atomicintegerarray getandupdate returns previous value and updatesresult of supplied function",
	"Method": "void testIntArrayGetAndUpdate(){\r\n    AtomicIntegerArray a = new AtomicIntegerArray(1);\r\n    a.set(0, 1);\r\n    assertEquals(1, a.getAndUpdate(0, Atomic8Test::addInt17));\r\n    assertEquals(18, a.getAndUpdate(0, Atomic8Test::addInt17));\r\n    assertEquals(35, a.get(0));\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testLongFieldUpdaterUpdateAndGet",
	"Comment": "atomiclongfieldupdater updateandget updates with supplied function andreturns result.",
	"Method": "void testLongFieldUpdaterUpdateAndGet(){\r\n    AtomicLongFieldUpdater a = aLongFieldUpdater();\r\n    a.set(this, 1);\r\n    assertEquals(18L, a.updateAndGet(this, Atomic8Test::addLong17));\r\n    assertEquals(35L, a.updateAndGet(this, Atomic8Test::addLong17));\r\n    assertEquals(35L, a.get(this));\r\n    assertEquals(35L, aLongField);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkQuietlyJoin",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoin(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingCCF f = new LFCCF(8);\r\n            assertSame(f, f.fork());\r\n            f.quietlyJoin();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkQuietlyJoin",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoin(){\r\n    FailingCCF f = new LFCCF(8);\r\n    assertSame(f, f.fork());\r\n    f.quietlyJoin();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n}"
}, {
	"Path": "java.util.Hashtable.elements",
	"Comment": "returns an enumeration of the values in this hashtable.use the enumeration methods on the returned object to fetch the elementssequentially.",
	"Method": "Enumeration<V> elements(){\r\n    return this.<V>getEnumeration(VALUES);\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testSubList",
	"Comment": "sublists contains elements at indexes offset from their base",
	"Method": "void testSubList(){\r\n    CopyOnWriteArrayList a = populatedArray(10);\r\n    assertTrue(a.subList(1, 1).isEmpty());\r\n    for (int j = 0; j < 9; ++j) {\r\n        for (int i = j; i < 10; ++i) {\r\n            List b = a.subList(j, i);\r\n            for (int k = j; k < i; ++k) {\r\n                assertEquals(new Integer(k), b.get(k - j));\r\n            }\r\n        }\r\n    }\r\n    List s = a.subList(2, 5);\r\n    assertEquals(3, s.size());\r\n    s.set(2, m1);\r\n    assertEquals(a.get(4), m1);\r\n    s.clear();\r\n    assertEquals(7, a.size());\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTransfer5",
	"Comment": "transfer waits until a take occurs. the transfered elementis returned by this associated take.",
	"Method": "void testTransfer5(){\r\n    final LinkedTransferQueue<Integer> q = new LinkedTransferQueue<Integer>();\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            q.transfer(four);\r\n            checkEmpty(q);\r\n        }\r\n    });\r\n    while (q.isEmpty()) Thread.yield();\r\n    assertFalse(q.isEmpty());\r\n    assertEquals(1, q.size());\r\n    assertSame(four, q.take());\r\n    checkEmpty(q);\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTransfer5",
	"Comment": "transfer waits until a take occurs. the transfered elementis returned by this associated take.",
	"Method": "void testTransfer5(){\r\n    q.transfer(four);\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "javax.net.ssl.KeyManagerFactory.getAlgorithm",
	"Comment": "returns the algorithm name of this keymanagerfactory object.this is the same name that was specified in one of thegetinstance calls that created thiskeymanagerfactory object.",
	"Method": "String getAlgorithm(){\r\n    return this.algorithm;\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTransfer4",
	"Comment": "transfer waits until a poll occurs, at which point the pollingthread returns the element",
	"Method": "void testTransfer4(){\r\n    final LinkedTransferQueue q = new LinkedTransferQueue();\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            q.transfer(four);\r\n            assertFalse(q.contains(four));\r\n            assertSame(three, q.poll());\r\n        }\r\n    });\r\n    while (q.isEmpty()) Thread.yield();\r\n    assertFalse(q.isEmpty());\r\n    assertEquals(1, q.size());\r\n    assertTrue(q.offer(three));\r\n    assertSame(four, q.poll());\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTransfer4",
	"Comment": "transfer waits until a poll occurs, at which point the pollingthread returns the element",
	"Method": "void testTransfer4(){\r\n    q.transfer(four);\r\n    assertFalse(q.contains(four));\r\n    assertSame(three, q.poll());\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTransfer3",
	"Comment": "transfer waits until a poll occurs, and then transfers in fifo order",
	"Method": "void testTransfer3(){\r\n    final LinkedTransferQueue<Integer> q = new LinkedTransferQueue<Integer>();\r\n    Thread first = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            q.transfer(four);\r\n            assertTrue(!q.contains(four));\r\n            assertEquals(1, q.size());\r\n        }\r\n    });\r\n    Thread interruptedThread = newStartedThread(new CheckedInterruptedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            while (q.isEmpty()) Thread.yield();\r\n            q.transfer(five);\r\n        }\r\n    });\r\n    while (q.size() < 2) Thread.yield();\r\n    assertEquals(2, q.size());\r\n    assertSame(four, q.poll());\r\n    first.join();\r\n    assertEquals(1, q.size());\r\n    interruptedThread.interrupt();\r\n    interruptedThread.join();\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTransfer3",
	"Comment": "transfer waits until a poll occurs, and then transfers in fifo order",
	"Method": "void testTransfer3(){\r\n    q.transfer(four);\r\n    assertTrue(!q.contains(four));\r\n    assertEquals(1, q.size());\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTransfer3",
	"Comment": "transfer waits until a poll occurs, and then transfers in fifo order",
	"Method": "void testTransfer3(){\r\n    while (q.isEmpty()) Thread.yield();\r\n    q.transfer(five);\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTransfer2",
	"Comment": "transfer waits until a poll occurs. the transfered elementis returned by this associated poll.",
	"Method": "void testTransfer2(){\r\n    final LinkedTransferQueue<Integer> q = new LinkedTransferQueue<Integer>();\r\n    final CountDownLatch threadStarted = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            threadStarted.countDown();\r\n            q.transfer(five);\r\n            checkEmpty(q);\r\n        }\r\n    });\r\n    threadStarted.await();\r\n    waitForThreadToEnterWaitState(t);\r\n    assertEquals(1, q.size());\r\n    assertSame(five, q.poll());\r\n    checkEmpty(q);\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTransfer2",
	"Comment": "transfer waits until a poll occurs. the transfered elementis returned by this associated poll.",
	"Method": "void testTransfer2(){\r\n    threadStarted.countDown();\r\n    q.transfer(five);\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testQuietlyInvokeSingleton",
	"Comment": "quietlyinvoke task returns when task completes normally.iscompletedabnormally and iscancelled return false for normallycompleted tasks",
	"Method": "void testQuietlyInvokeSingleton(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib f = new AsyncFib(8);\r\n            f.quietlyInvoke();\r\n            assertEquals(21, f.number);\r\n            checkCompletedNormally(f);\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testQuietlyInvokeSingleton",
	"Comment": "quietlyinvoke task returns when task completes normally.iscompletedabnormally and iscancelled return false for normallycompleted tasks",
	"Method": "void testQuietlyInvokeSingleton(){\r\n    AsyncFib f = new AsyncFib(8);\r\n    f.quietlyInvoke();\r\n    assertEquals(21, f.number);\r\n    checkCompletedNormally(f);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testCancelledForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGet(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FibAction f = new FibAction(8);\r\n            assertTrue(f.cancel(true));\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get(5L, SECONDS);\r\n                shouldThrow();\r\n            } catch (CancellationException success) {\r\n                checkCancelled(f);\r\n            }\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testCancelledForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGet(){\r\n    FibAction f = new FibAction(8);\r\n    assertTrue(f.cancel(true));\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get(5L, SECONDS);\r\n        shouldThrow();\r\n    } catch (CancellationException success) {\r\n        checkCancelled(f);\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.X509CertInfo.attributeMap",
	"Comment": "returns the integer attribute number for the passed attribute name.",
	"Method": "int attributeMap(String name){\r\n    Integer num = map.get(name);\r\n    if (num == null) {\r\n        return 0;\r\n    }\r\n    return num.intValue();\r\n}"
}, {
	"Path": "jsr166.AtomicLongArrayTest.testCompareAndSet",
	"Comment": "compareandset succeeds in changing value if equal to expected else fails",
	"Method": "void testCompareAndSet(){\r\n    AtomicLongArray aa = new AtomicLongArray(SIZE);\r\n    for (int i = 0; i < SIZE; i++) {\r\n        aa.set(i, 1);\r\n        assertTrue(aa.compareAndSet(i, 1, 2));\r\n        assertTrue(aa.compareAndSet(i, 2, -4));\r\n        assertEquals(-4, aa.get(i));\r\n        assertFalse(aa.compareAndSet(i, -5, 7));\r\n        assertEquals(-4, aa.get(i));\r\n        assertTrue(aa.compareAndSet(i, -4, 7));\r\n        assertEquals(7, aa.get(i));\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testAcquireInterruptibly",
	"Comment": "acquireinterruptibly succeeds when released, else is interruptible",
	"Method": "void testAcquireInterruptibly(){\r\n    final Mutex sync = new Mutex();\r\n    final BooleanLatch threadStarted = new BooleanLatch();\r\n    sync.acquireInterruptibly();\r\n    Thread t = newStartedThread(new CheckedInterruptedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            assertTrue(threadStarted.releaseShared(0));\r\n            sync.acquireInterruptibly();\r\n        }\r\n    });\r\n    threadStarted.acquireShared(0);\r\n    waitForQueuedThread(sync, t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n    assertTrue(sync.isHeldExclusively());\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testAcquireInterruptibly",
	"Comment": "acquireinterruptibly succeeds when released, else is interruptible",
	"Method": "void testAcquireInterruptibly(){\r\n    assertTrue(threadStarted.releaseShared(0));\r\n    sync.acquireInterruptibly();\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    final LinkedBlockingDeque q = populatedDeque(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(i, q.take());\r\n            }\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadStaysAlive(t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(i, q.take());\r\n    }\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testUpdateAndGetNPE",
	"Comment": "all atomic updateandget methods throw nullpointerexception on null function argument",
	"Method": "void testUpdateAndGetNPE(){\r\n    Runnable[] throwingActions = { () -> new AtomicLong().updateAndGet(null), () -> new AtomicInteger().updateAndGet(null), () -> new AtomicReference().updateAndGet(null), () -> new AtomicLongArray(1).updateAndGet(0, null), () -> new AtomicIntegerArray(1).updateAndGet(0, null), () -> new AtomicReferenceArray(1).updateAndGet(0, null), () -> aLongFieldUpdater().updateAndGet(this, null), () -> anIntFieldUpdater().updateAndGet(this, null), () -> anIntegerFieldUpdater().updateAndGet(this, null) };\r\n    assertThrows(NullPointerException.class, throwingActions);\r\n}"
}, {
	"Path": "org.xml.sax.ext.DefaultHandler2.getExternalSubset",
	"Comment": "tells the parser that if no external subset has been declaredin the document text, none should be used.",
	"Method": "InputSource getExternalSubset(String name,String baseURI){\r\n    return null;\r\n}"
}, {
	"Path": "java.security.Provider.keySet",
	"Comment": "returns an unmodifiable set view of the property keys contained inthis provider.",
	"Method": "Set<Object> keySet(){\r\n    checkInitialized();\r\n    return Collections.unmodifiableSet(super.keySet());\r\n}"
}, {
	"Path": "java.io.LineNumberInputStream.read",
	"Comment": "reads up to len bytes of data from this input streaminto an array of bytes. this method blocks until some input is available.the read method oflinenumberinputstream repeatedly calls theread method of zero arguments to fill in the byte array.",
	"Method": "int read(int read,byte b,int off,int len){\r\n    if (b == null) {\r\n        throw new NullPointerException();\r\n    } else if ((off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length) || ((off + len) < 0)) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (len == 0) {\r\n        return 0;\r\n    }\r\n    int c = read();\r\n    if (c == -1) {\r\n        return -1;\r\n    }\r\n    b[off] = (byte) c;\r\n    int i = 1;\r\n    try {\r\n        for (; i < len; i++) {\r\n            c = read();\r\n            if (c == -1) {\r\n                break;\r\n            }\r\n            if (b != null) {\r\n                b[off + i] = (byte) c;\r\n            }\r\n        }\r\n    } catch (IOException ee) {\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "java.util.Date.setMonth",
	"Comment": "sets the month of this date to the specified value. thisdate object is modified so that it represents a pointin time within the specified month, with the year, date, hour,minute, and second the same as before, as interpreted in thelocal time zone. if the date was october 31, for example, andthe month is set to june, then the new date will be treated asif it were on july 1, because june has only 30 days.",
	"Method": "void setMonth(int month){\r\n    int y = 0;\r\n    if (month >= 12) {\r\n        y = month / 12;\r\n        month %= 12;\r\n    } else if (month < 0) {\r\n        y = CalendarUtils.floorDivide(month, 12);\r\n        month = CalendarUtils.mod(month, 12);\r\n    }\r\n    BaseCalendar.Date d = getCalendarDate();\r\n    if (y != 0) {\r\n        d.setNormalizedYear(d.getNormalizedYear() + y);\r\n    }\r\n    d.setMonth(month + 1);\r\n}"
}, {
	"Path": "java.sql.DriverManager.getConnection",
	"Comment": "attempts to establish a connection to the given database url.the drivermanager attempts to select an appropriate driver fromthe set of registered jdbc drivers.",
	"Method": "Connection getConnection(String url,java.util.Properties info,Connection getConnection,String url,String user,String password,Connection getConnection,String url,Connection getConnection,String url,java.util.Properties info,ClassLoader callerCL){\r\n    synchronized (DriverManager.class) {\r\n        if (callerCL == null) {\r\n            callerCL = Thread.currentThread().getContextClassLoader();\r\n        }\r\n    }\r\n    if (url == null) {\r\n        throw new SQLException(\"The url cannot be null\", \"08001\");\r\n    }\r\n    println(\"DriverManager.getConnection(\\\"\" + url + \"\\\")\");\r\n    SQLException reason = null;\r\n    for (DriverInfo aDriver : registeredDrivers) {\r\n        if (isDriverAllowed(aDriver.driver, callerCL)) {\r\n            try {\r\n                println(\"    trying \" + aDriver.driver.getClass().getName());\r\n                Connection con = aDriver.driver.connect(url, info);\r\n                if (con != null) {\r\n                    println(\"getConnection returning \" + aDriver.driver.getClass().getName());\r\n                    return (con);\r\n                }\r\n            } catch (SQLException ex) {\r\n                if (reason == null) {\r\n                    reason = ex;\r\n                }\r\n            }\r\n        } else {\r\n            println(\"    skipping: \" + aDriver.getClass().getName());\r\n        }\r\n    }\r\n    if (reason != null) {\r\n        println(\"getConnection failed: \" + reason);\r\n        throw reason;\r\n    }\r\n    println(\"getConnection: no suitable driver found for \" + url);\r\n    throw new SQLException(\"No suitable driver found for \" + url, \"08001\");\r\n}"
}, {
	"Path": "org.xml.sax.helpers.XMLReaderAdapter.setLocale",
	"Comment": "set the locale for error reporting.this is not supported in sax2, and will always throwan exception.",
	"Method": "void setLocale(Locale locale){\r\n    throw new SAXNotSupportedException(\"setLocale not supported\");\r\n}"
}, {
	"Path": "java.security.cert.Certificate.hashCode",
	"Comment": "returns a hashcode value for this certificate from itsencoded form.",
	"Method": "int hashCode(){\r\n    int retval = 0;\r\n    try {\r\n        byte[] certData = X509CertImpl.getEncodedInternal(this);\r\n        for (int i = 1; i < certData.length; i++) {\r\n            retval += certData[i] * i;\r\n        }\r\n        return retval;\r\n    } catch (CertificateException e) {\r\n        return retval;\r\n    }\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    final AtomicReference ai = new AtomicReference(one);\r\n    Thread t = new Thread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!ai.compareAndSet(two, three)) Thread.yield();\r\n        }\r\n    });\r\n    t.start();\r\n    assertTrue(ai.compareAndSet(one, two));\r\n    t.join(LONG_DELAY_MS);\r\n    assertFalse(t.isAlive());\r\n    assertSame(three, ai.get());\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    while (!ai.compareAndSet(two, three)) Thread.yield();\r\n}"
}, {
	"Path": "android.icu.dev.test.UTF16Util.insertCodePoint",
	"Comment": "method insertcodepoint. inserts a code point ina stringbuffer",
	"Method": "void insertCodePoint(StringBuffer buffer,int i,int ch){\r\n    if (ch <= 0xffff) {\r\n        buffer.insert(i, (char) ch);\r\n    } else {\r\n        buffer.insert(i, (char) (0xd7c0 + (ch >> 10))).insert(i + 1, (char) (0xdc00 + (ch & 0x3ff)));\r\n    }\r\n}"
}, {
	"Path": "jsr166.JSR166TestCase.timeoutMillis",
	"Comment": "returns a timeout in milliseconds to be used in tests thatverify that operations block or time out.",
	"Method": "long timeoutMillis(){\r\n    return SHORT_DELAY_MS / 4;\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.cloneIssuerNames",
	"Comment": "clone an argument of the form passed to setissuernames.throw a runtimeexception if the argument is malformed.this method wraps cloneandcheckissuernames, changing any ioexceptioninto a runtimeexception. this method should be used when the object beingcloned has already been checked, so there should never be any exceptions.",
	"Method": "HashSet<Object> cloneIssuerNames(Collection<Object> names){\r\n    try {\r\n        return cloneAndCheckIssuerNames(names);\r\n    } catch (IOException ioe) {\r\n        throw new RuntimeException(ioe);\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testGetFirstQueuedThread",
	"Comment": "getfirstqueuedthread returns first waiting thread or null if none",
	"Method": "void testGetFirstQueuedThread(){\r\n    final Mutex sync = new Mutex();\r\n    assertNull(sync.getFirstQueuedThread());\r\n    sync.acquire();\r\n    Thread t1 = newStartedThread(new InterruptedSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t1);\r\n    assertEquals(t1, sync.getFirstQueuedThread());\r\n    Thread t2 = newStartedThread(new InterruptibleSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t2);\r\n    assertEquals(t1, sync.getFirstQueuedThread());\r\n    t1.interrupt();\r\n    awaitTermination(t1);\r\n    assertEquals(t2, sync.getFirstQueuedThread());\r\n    sync.release();\r\n    awaitTermination(t2);\r\n    assertNull(sync.getFirstQueuedThread());\r\n}"
}, {
	"Path": "java.util.concurrent.LinkedBlockingDeque.clear",
	"Comment": "atomically removes all of the elements from this deque.the deque will be empty after this call returns.",
	"Method": "void clear(){\r\n    final ReentrantLock lock = this.lock;\r\n    lock.lock();\r\n    try {\r\n        for (Node<E> f = first; f != null; ) {\r\n            f.item = null;\r\n            Node<E> n = f.next;\r\n            f.prev = null;\r\n            f.next = null;\r\n            f = n;\r\n        }\r\n        first = last = null;\r\n        count = 0;\r\n        notFull.signalAll();\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.X509CRLImpl.getIssuerX500Principal",
	"Comment": "return the issuer as x500principal. overrides method in x509crlto provide a slightly more efficient version.",
	"Method": "X500Principal getIssuerX500Principal(X500Principal getIssuerX500Principal,X509CRL crl){\r\n    try {\r\n        byte[] encoded = crl.getEncoded();\r\n        DerInputStream derIn = new DerInputStream(encoded);\r\n        DerValue tbsCert = derIn.getSequence(3)[0];\r\n        DerInputStream tbsIn = tbsCert.data;\r\n        DerValue tmp;\r\n        byte nextByte = (byte) tbsIn.peekByte();\r\n        if (nextByte == DerValue.tag_Integer) {\r\n            tmp = tbsIn.getDerValue();\r\n        }\r\n        tmp = tbsIn.getDerValue();\r\n        tmp = tbsIn.getDerValue();\r\n        byte[] principalBytes = tmp.toByteArray();\r\n        return new X500Principal(principalBytes);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(\"Could not parse issuer\", e);\r\n    }\r\n}"
}, {
	"Path": "jsr166.AtomicLongTest.testCompareAndSet",
	"Comment": "compareandset succeeds in changing value if equal to expected else fails",
	"Method": "void testCompareAndSet(){\r\n    AtomicLong ai = new AtomicLong(1);\r\n    assertTrue(ai.compareAndSet(1, 2));\r\n    assertTrue(ai.compareAndSet(2, -4));\r\n    assertEquals(-4, ai.get());\r\n    assertFalse(ai.compareAndSet(-5, 7));\r\n    assertEquals(-4, ai.get());\r\n    assertTrue(ai.compareAndSet(-4, 7));\r\n    assertEquals(7, ai.get());\r\n}"
}, {
	"Path": "java.util.Observable.deleteObservers",
	"Comment": "clears the observer list so that this object no longer has any observers.",
	"Method": "void deleteObservers(){\r\n    observers.clear();\r\n}"
}, {
	"Path": "java.util.RegularEnumSet.remove",
	"Comment": "removes the specified element from this set if it is present.",
	"Method": "void remove(boolean remove,Object e){\r\n    if (e == null)\r\n        return false;\r\n    Class eClass = e.getClass();\r\n    if (eClass != elementType && eClass.getSuperclass() != elementType)\r\n        return false;\r\n    long oldElements = elements;\r\n    elements &= ~(1L << ((Enum) e).ordinal());\r\n    return elements != oldElements;\r\n}"
}, {
	"Path": "sun.security.pkcs.PKCS9Attribute.isKnown",
	"Comment": "returns if the attribute is known. unknown attributes can be createdfrom der encoding with unknown oids.",
	"Method": "boolean isKnown(){\r\n    return index != -1;\r\n}"
}, {
	"Path": "sun.security.util.ObjectIdentifier.pack8",
	"Comment": "repack from nub 7 to nub 8, remove all unnecessary 0headings, and paste it into an existing byte array.",
	"Method": "int pack8(byte[] in,int ioffset,int ilength,byte[] out,int ooffset){\r\n    byte[] pack = pack(in, ioffset, ilength, 7, 8);\r\n    int firstNonZero = pack.length - 1;\r\n    for (int i = pack.length - 2; i >= 0; i--) {\r\n        if (pack[i] != 0) {\r\n            firstNonZero = i;\r\n        }\r\n    }\r\n    System.arraycopy(pack, firstNonZero, out, ooffset, pack.length - firstNonZero);\r\n    return pack.length - firstNonZero;\r\n}"
}, {
	"Path": "java.util.Collections.get",
	"Comment": "gets the ith element from the given list by repositioning the specifiedlist listiterator.",
	"Method": "T get(ListIterator<? extends T> i,int index,E get,int index,V get,Object key,E get,int index,V get,Object key,E get,int index,V get,Object key,E get,int index,V get,Object key,E get,int index,V get,Object key,E get,int index){\r\n    T obj = null;\r\n    int pos = i.nextIndex();\r\n    if (pos <= index) {\r\n        do {\r\n            obj = i.next();\r\n        } while (pos++ < index);\r\n    } else {\r\n        do {\r\n            obj = i.previous();\r\n        } while (--pos > index);\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.text.DecimalFormatTest.test_formatDouble_maxFractionDigits",
	"Comment": "digits, using numbers that are well within the precision of ieee 754.",
	"Method": "void test_formatDouble_maxFractionDigits(){\r\n    final DecimalFormatSymbols dfs = new DecimalFormatSymbols(Locale.US);\r\n    DecimalFormat format = new DecimalFormat(\"#0.#\", dfs);\r\n    format.setGroupingUsed(false);\r\n    format.setMaximumIntegerDigits(400);\r\n    format.setMaximumFractionDigits(1);\r\n    assertEquals(\"1\", format.format(0.99));\r\n    assertEquals(\"1\", format.format(0.95));\r\n    assertEquals(\"0.9\", format.format(0.94));\r\n    assertEquals(\"0.9\", format.format(0.90));\r\n    assertEquals(\"0.2\", format.format(0.19));\r\n    assertEquals(\"0.2\", format.format(0.15));\r\n    assertEquals(\"0.1\", format.format(0.14));\r\n    assertEquals(\"0.1\", format.format(0.10));\r\n    format.setMaximumFractionDigits(10);\r\n    assertEquals(\"1\", format.format(0.99999999999));\r\n    assertEquals(\"1\", format.format(0.99999999995));\r\n    assertEquals(\"0.9999999999\", format.format(0.99999999994));\r\n    assertEquals(\"0.9999999999\", format.format(0.99999999990));\r\n    assertEquals(\"0.1111111112\", format.format(0.11111111119));\r\n    assertEquals(\"0.1111111112\", format.format(0.11111111115));\r\n    assertEquals(\"0.1111111111\", format.format(0.11111111114));\r\n    assertEquals(\"0.1111111111\", format.format(0.11111111110));\r\n    format.setMaximumFractionDigits(14);\r\n    assertEquals(\"1\", format.format(0.999999999999999));\r\n    assertEquals(\"1\", format.format(0.999999999999995));\r\n    assertEquals(\"0.99999999999999\", format.format(0.999999999999994));\r\n    assertEquals(\"0.99999999999999\", format.format(0.999999999999990));\r\n    assertEquals(\"0.11111111111112\", format.format(0.111111111111119));\r\n    assertEquals(\"0.11111111111112\", format.format(0.111111111111115));\r\n    assertEquals(\"0.11111111111111\", format.format(0.111111111111114));\r\n    assertEquals(\"0.11111111111111\", format.format(0.111111111111110));\r\n}"
}, {
	"Path": "sun.misc.FloatingDecimal.parseDouble",
	"Comment": "converts a string to a double precision floating point value.",
	"Method": "double parseDouble(String s){\r\n    return readJavaFormatString(s).doubleValue();\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_localDateTime",
	"Comment": "test to verify local date time values from various date instances defined in the localdatetime data provider",
	"Method": "void test_localDateTime(TemporalAccessor accessor,HijrahDate expectedDate,LocalTime expectedTime,Class<?> expectedEx){\r\n    if (expectedEx == null) {\r\n        ChronoLocalDateTime<HijrahDate> result = HijrahChronology.INSTANCE.localDateTime(accessor);\r\n        assertEquals(result.toLocalDate(), expectedDate);\r\n        assertEquals(HijrahDate.from(accessor), expectedDate);\r\n        assertEquals(result.toLocalTime(), expectedTime);\r\n    } else {\r\n        try {\r\n            ChronoLocalDateTime<HijrahDate> result = HijrahChronology.INSTANCE.localDateTime(accessor);\r\n            fail();\r\n        } catch (Exception ex) {\r\n            assertTrue(expectedEx.isInstance(ex));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.time.Duration.minusDays",
	"Comment": "returns a copy of this duration with the specified duration in standard 24 hour days subtracted.the number of days is multiplied by 86400 to obtain the number of seconds to subtract.this is based on the standard definition of a day as 24 hours.this instance is immutable and unaffected by this method call.",
	"Method": "Duration minusDays(long daysToSubtract){\r\n    return (daysToSubtract == Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-daysToSubtract));\r\n}"
}, {
	"Path": "java.util.Calendar.isExternallySet",
	"Comment": "returns whether the value of the specified calendar field has been setexternally by calling one of the setter methods rather than by theinternal time calculation.",
	"Method": "boolean isExternallySet(int field){\r\n    return stamp[field] >= MINIMUM_USER_STAMP;\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testAwait5_Timeout_BrokenBarrier",
	"Comment": "a timeout in one party causes others waiting in await tothrow brokenbarrierexception",
	"Method": "void testAwait5_Timeout_BrokenBarrier(){\r\n    final CyclicBarrier c = new CyclicBarrier(3);\r\n    Thread t1 = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            try {\r\n                c.await();\r\n                shouldThrow();\r\n            } catch (BrokenBarrierException success) {\r\n            }\r\n        }\r\n    });\r\n    Thread t2 = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            awaitNumberWaiting(c, 1);\r\n            long startTime = System.nanoTime();\r\n            try {\r\n                c.await(timeoutMillis(), MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (TimeoutException success) {\r\n            }\r\n            assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n        }\r\n    });\r\n    awaitTermination(t1);\r\n    awaitTermination(t2);\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testAwait5_Timeout_BrokenBarrier",
	"Comment": "a timeout in one party causes others waiting in await tothrow brokenbarrierexception",
	"Method": "void testAwait5_Timeout_BrokenBarrier(){\r\n    try {\r\n        c.await();\r\n        shouldThrow();\r\n    } catch (BrokenBarrierException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testAwait5_Timeout_BrokenBarrier",
	"Comment": "a timeout in one party causes others waiting in await tothrow brokenbarrierexception",
	"Method": "void testAwait5_Timeout_BrokenBarrier(){\r\n    awaitNumberWaiting(c, 1);\r\n    long startTime = System.nanoTime();\r\n    try {\r\n        c.await(timeoutMillis(), MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (TimeoutException success) {\r\n    }\r\n    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n}"
}, {
	"Path": "java.security.AlgorithmParameters.getAlgorithm",
	"Comment": "returns the name of the algorithm associated with this parameter object.",
	"Method": "String getAlgorithm(){\r\n    return this.algorithm;\r\n}"
}, {
	"Path": "javax.crypto.Cipher.getParameters",
	"Comment": "returns the parameters used with this cipher.the returned parameters may be the same that were used to initializethis cipher, or may contain a combination of default and randomparameter values used by the underlying cipher implementation if thiscipher requires algorithm parameters but was not initialized with any.",
	"Method": "AlgorithmParameters getParameters(){\r\n    updateProviderIfNeeded();\r\n    return spi.engineGetParameters();\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.ensureCapacity",
	"Comment": "if this mutablebiginteger cannot hold len words, increase the sizeof the value array to len words.",
	"Method": "void ensureCapacity(int len){\r\n    if (value.length < len) {\r\n        value = new int[len];\r\n        offset = 0;\r\n        intLen = len;\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.URICertStore.getMatchingCerts",
	"Comment": "iterates over the specified collection of x509certificates andreturns only those that match the criteria specified in thecertselector.",
	"Method": "Collection<X509Certificate> getMatchingCerts(Collection<X509Certificate> certs,CertSelector selector){\r\n    if (selector == null) {\r\n        return certs;\r\n    }\r\n    List<X509Certificate> matchedCerts = new ArrayList(certs.size());\r\n    for (X509Certificate cert : certs) {\r\n        if (selector.match(cert)) {\r\n            matchedCerts.add(cert);\r\n        }\r\n    }\r\n    return matchedCerts;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerDivideTest.testCase19",
	"Comment": "remainder of division of two numbers of different signs.the first is positive.",
	"Method": "void testCase19(){\r\n    byte[] aBytes = { -127, 100, 56, 7, 98, -1, 39, -128, 127, 75 };\r\n    byte[] bBytes = { 27, -15, 65, 39, 100 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 12, -21, 73, 56, 27 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.remainder(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "java.security.AlgorithmParameterGenerator.getInstance",
	"Comment": "returns an algorithmparametergenerator object for generatinga set of parameters to be used with the specified algorithm. a new algorithmparametergenerator object encapsulating thealgorithmparametergeneratorspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "AlgorithmParameterGenerator getInstance(String algorithm,AlgorithmParameterGenerator getInstance,String algorithm,String provider,AlgorithmParameterGenerator getInstance,String algorithm,Provider provider){\r\n    if (provider == null)\r\n        throw new IllegalArgumentException(\"missing provider\");\r\n    Object[] objs = Security.getImpl(algorithm, \"AlgorithmParameterGenerator\", provider);\r\n    return new AlgorithmParameterGenerator((AlgorithmParameterGeneratorSpi) objs[0], (Provider) objs[1], algorithm);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test426411b",
	"Comment": "runtime due to emission order of casts in intersection casts",
	"Method": "void test426411b(){\r\n    this.runConformTest(new String[] { \"X.java\", \"import java.io.Serializable;\\n\" + \"interface AnotherAutoCloseable extends AutoCloseable {}\\n\" + \"public class X {\\n\" + \" public static void main(String argv[]) throws Exception {\\n\" + \"   ((Serializable & AnotherAutoCloseable) (() -> {})).close();\\n\" + \" }\\n\" + \"}\\n\" }, \"\");\r\n}"
}, {
	"Path": "java.util.Scanner.delimiter",
	"Comment": "returns the pattern this scanner is currentlyusing to match delimiters.",
	"Method": "Pattern delimiter(){\r\n    return delimPattern;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test426411d",
	"Comment": "runtime due to emission order of casts in intersection casts",
	"Method": "void test426411d(){\r\n    this.runConformTest(new String[] { \"X.java\", \"import java.io.Serializable;\\n\" + \"interface AnotherAutoCloseable extends AutoCloseable {}\\n\" + \"public class X {\\n\" + \" public static void main(String argv[]) throws Exception {\\n\" + \"   ((AnotherAutoCloseable & Serializable) (() -> {})).close();\\n\" + \" }\\n\" + \"}\\n\" }, \"\");\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test426411c",
	"Comment": "runtime due to emission order of casts in intersection casts",
	"Method": "void test426411c(){\r\n    this.runConformTest(new String[] { \"X.java\", \"import java.io.Serializable;\\n\" + \"public class X {\\n\" + \" public static void main(String argv[]) throws Exception {\\n\" + \"   ((AutoCloseable & Serializable) (() -> {})).close();\\n\" + \" }\\n\" + \"}\\n\" }, \"\");\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test426411f",
	"Comment": "runtime due to emission order of casts in intersection casts",
	"Method": "void test426411f(){\r\n    this.runConformTest(new String[] { \"X.java\", \"import java.io.Serializable;\\n\" + \"interface I {}\\n\" + \"interface J extends I {\\n\" + \"   final int xyz = 99;\\n\" + \"}\\n\" + \"public class X {\\n\" + \" public static void main(String argv[]) throws Exception {\\n\" + \"   J j = new J() {};\\n\" + \"   System.out.println(((I & J) j).xyz);\\n\" + \" }\\n\" + \"}\\n\" }, \"99\");\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test426411e",
	"Comment": "runtime due to emission order of casts in intersection casts",
	"Method": "void test426411e(){\r\n    this.runConformTest(new String[] { \"X.java\", \"import java.io.Serializable;\\n\" + \"interface I {}\\n\" + \"interface J extends I {\\n\" + \"   static final int xyz = 99;\\n\" + \"}\\n\" + \"public class X {\\n\" + \" public static void main(String argv[]) throws Exception {\\n\" + \"   J j = new J() {};\\n\" + \"   System.out.println(((I & J) j).xyz);\\n\" + \" }\\n\" + \"}\\n\" }, \"99\");\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedLongSynchronizer.transferAfterCancelledWait",
	"Comment": "transfers node, if necessary, to sync queue after a cancelled wait.returns true if thread was cancelled before being signalled.",
	"Method": "boolean transferAfterCancelledWait(Node node){\r\n    if (node.compareAndSetWaitStatus(Node.CONDITION, 0)) {\r\n        enq(node);\r\n        return true;\r\n    }\r\n    while (!isOnSyncQueue(node)) Thread.yield();\r\n    return false;\r\n}"
}, {
	"Path": "sun.security.x509.CertificateExtensions.equals",
	"Comment": "compares this certificateextensions for equality with the specifiedobject. if the other object is aninstanceof certificateextensions, thenall the entries are compared with the entries from this.",
	"Method": "boolean equals(Object other){\r\n    if (this == other)\r\n        return true;\r\n    if (!(other instanceof CertificateExtensions))\r\n        return false;\r\n    Collection<Extension> otherC = ((CertificateExtensions) other).getAllExtensions();\r\n    Object[] objs = otherC.toArray();\r\n    int len = objs.length;\r\n    if (len != map.size())\r\n        return false;\r\n    Extension otherExt, thisExt;\r\n    String key = null;\r\n    for (int i = 0; i < len; i++) {\r\n        if (objs[i] instanceof CertAttrSet)\r\n            key = ((CertAttrSet) objs[i]).getName();\r\n        otherExt = (Extension) objs[i];\r\n        if (key == null)\r\n            key = otherExt.getExtensionId().toString();\r\n        thisExt = map.get(key);\r\n        if (thisExt == null)\r\n            return false;\r\n        if (!thisExt.equals(otherExt))\r\n            return false;\r\n    }\r\n    return this.getUnparseableExtensions().equals(((CertificateExtensions) other).getUnparseableExtensions());\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedLongSynchronizer.addWaiter",
	"Comment": "creates and enqueues node for current thread and given mode.",
	"Method": "Node addWaiter(Node mode){\r\n    Node node = new Node(mode);\r\n    for (; ; ) {\r\n        Node oldTail = tail;\r\n        if (oldTail != null) {\r\n            U.putObject(node, Node.PREV, oldTail);\r\n            if (compareAndSetTail(oldTail, node)) {\r\n                oldTail.next = node;\r\n                return node;\r\n            }\r\n        } else {\r\n            initializeSyncQueue();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.Stack.peek",
	"Comment": "looks at the object at the top of this stack without removing itfrom the stack.",
	"Method": "E peek(){\r\n    int len = size();\r\n    if (len == 0)\r\n        throw new EmptyStackException();\r\n    return elementAt(len - 1);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.UnicodeUtils.isValidCppCharacter",
	"Comment": "returns true if the specified character can be represented in a c stringor character literal declaration. this invalid character range is fromsection the c99specification, section 6.4.3.",
	"Method": "boolean isValidCppCharacter(char c){\r\n    return c < 0xd800 || c > 0xdfff;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.IntlTestSimpleDateFormatAPI.TestAPI",
	"Comment": "this test checks various generic api methods in decimalformat to achieve 100% api coverage.",
	"Method": "void TestAPI(){\r\n    logln(\"SimpleDateFormat API test---\");\r\n    logln(\"\");\r\n    Locale.setDefault(Locale.ENGLISH);\r\n    logln(\"Testing SimpleDateFormat constructors\");\r\n    SimpleDateFormat def = new SimpleDateFormat();\r\n    final String pattern = new String(\"yyyy.MM.dd G 'at' hh:mm:ss z\");\r\n    SimpleDateFormat pat = new SimpleDateFormat(pattern);\r\n    SimpleDateFormat pat_fr = new SimpleDateFormat(pattern, Locale.FRENCH);\r\n    DateFormatSymbols symbols = new DateFormatSymbols(Locale.FRENCH);\r\n    SimpleDateFormat cust1 = new SimpleDateFormat(pattern, symbols);\r\n    logln(\"Testing clone(), assignment and equality operators\");\r\n    Format clone = (Format) def.clone();\r\n    if (!clone.equals(def)) {\r\n        errln(\"ERROR: Format clone or equals failed\");\r\n    }\r\n    logln(\"Testing various format() methods\");\r\n    Date d = new Date((long) 837039928046.0);\r\n    StringBuffer res1 = new StringBuffer();\r\n    StringBuffer res2 = new StringBuffer();\r\n    FieldPosition pos1 = new FieldPosition(0);\r\n    FieldPosition pos2 = new FieldPosition(0);\r\n    res1 = def.format(d, res1, pos1);\r\n    logln(\"\" + d.getTime() + \" formatted to \" + res1);\r\n    res2 = cust1.format(d, res2, pos2);\r\n    logln(\"\" + d.getTime() + \" formatted to \" + res2);\r\n    logln(\"Testing parse()\");\r\n    String text = new String(\"02/03/76, 2:50 AM, CST\");\r\n    Date result1 = new Date();\r\n    Date result2 = new Date();\r\n    ParsePosition pos = new ParsePosition(0);\r\n    result1 = def.parse(text, pos);\r\n    logln(text + \" parsed into \" + result1);\r\n    try {\r\n        result2 = def.parse(text);\r\n    } catch (ParseException e) {\r\n        errln(\"ERROR: parse() failed\");\r\n    }\r\n    logln(text + \" parsed into \" + result2);\r\n    logln(\"Testing getters and setters\");\r\n    final DateFormatSymbols syms = pat.getDateFormatSymbols();\r\n    def.setDateFormatSymbols(syms);\r\n    pat_fr.setDateFormatSymbols(syms);\r\n    if (!pat.getDateFormatSymbols().equals(def.getDateFormatSymbols())) {\r\n        errln(\"ERROR: set DateFormatSymbols() failed\");\r\n    }\r\n    logln(\"Testing applyPattern()\");\r\n    String p1 = new String(\"yyyy.MM.dd G 'at' hh:mm:ss z\");\r\n    logln(\"Applying pattern \" + p1);\r\n    pat.applyPattern(p1);\r\n    String s2 = pat.toPattern();\r\n    logln(\"Extracted pattern is \" + s2);\r\n    if (!s2.equals(p1)) {\r\n        errln(\"ERROR: toPattern() result did not match pattern applied\");\r\n    }\r\n    logln(\"Applying pattern \" + p1);\r\n    pat.applyLocalizedPattern(p1);\r\n    String s3 = pat.toLocalizedPattern();\r\n    logln(\"Extracted pattern is \" + s3);\r\n    if (!s3.equals(p1)) {\r\n        errln(\"ERROR: toLocalizedPattern() result did not match pattern applied\");\r\n    }\r\n    logln(\"Testing parse()\");\r\n    String p2 = new String(\"YYYY'W'wwe\");\r\n    logln(\"Applying pattern \" + p2);\r\n    pat.applyPattern(p2);\r\n    Date dt = pat.parse(\"2007W014\", new ParsePosition(0));\r\n    if (dt == null) {\r\n        errln(\"ERROR: Parsing failed using 'Y' and 'e'\");\r\n    }\r\n}"
}, {
	"Path": "java.lang.StringBuffer.readObject",
	"Comment": "readobject is called to restore the state of the stringbuffer froma stream.",
	"Method": "void readObject(java.io.ObjectInputStream s){\r\n    java.io.ObjectInputStream.GetField fields = s.readFields();\r\n    char[] value = (char[]) fields.get(\"value\", null);\r\n    int count = fields.get(\"count\", 0);\r\n    append(value, 0, count);\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.getCutoverCalendarSystem",
	"Comment": "returns the calendar system for dates before the cutover datein the cutover year. if the cutover date is january 1, themethod returns gregorian. otherwise, julian.",
	"Method": "BaseCalendar getCutoverCalendarSystem(){\r\n    if (gregorianCutoverYearJulian < gregorianCutoverYear) {\r\n        return gcal;\r\n    }\r\n    return getJulianCalendarSystem();\r\n}"
}, {
	"Path": "android.icu.dev.test.TestUtil.isUnprintable",
	"Comment": "return true if the character is not printable ascii.the tab,newline and linefeed characters are considered unprintable.",
	"Method": "boolean isUnprintable(int c){\r\n    return !(c >= 0x20 && c <= 0x7E);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerDivideTest.testCase21",
	"Comment": "divideandremainder of two numbers of different signs.the first is negative.",
	"Method": "void testCase21(){\r\n    byte[] aBytes = { -127, 100, 56, 7, 98, -1, 39, -128, 127, 75 };\r\n    byte[] bBytes = { 27, -15, 65, 39, 100 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[][] rBytes = { { -5, 94, -115, -74, -85, 84 }, { -13, 20, -74, -57, -27 } };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger[] result = aNumber.divideAndRemainder(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result[0].toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        if (resBytes[i] != rBytes[0][i]) {\r\n            fail(\"Incorrect quotation\");\r\n        }\r\n    }\r\n    assertEquals(-1, result[0].signum());\r\n    resBytes = result[1].toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        if (resBytes[i] != rBytes[1][i]) {\r\n            fail(\"Incorrect remainder\");\r\n        }\r\n        assertEquals(-1, result[1].signum());\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.TypeImplementationGeneratorTest.testNoEnumConstantAccessorMethods",
	"Comment": "verify that accessor methods for enum constants are not generated by default.",
	"Method": "void testNoEnumConstantAccessorMethods(){\r\n    String source = \"enum Test { ONE, TWO }\";\r\n    String translation = translateSourceFile(source, \"Test\", \"Test.m\");\r\n    assertNotInTranslation(translation, \"+ (TestEnum *)ONE\");\r\n    assertNotInTranslation(translation, \"+ (TestEnum *)TWO\");\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_badChronology",
	"Comment": "test to check if the exception is thrown for an incorrect chronology id",
	"Method": "void test_badChronology(){\r\n    Chronology test = Chronology.of(\"Hijrah-ummalqura\");\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerDivideTest.testCase20",
	"Comment": "remainder of division of two numbers of different signs.the first is negative.",
	"Method": "void testCase20(){\r\n    byte[] aBytes = { -127, 100, 56, 7, 98, -1, 39, -128, 127, 75 };\r\n    byte[] bBytes = { 27, -15, 65, 39, 100 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -13, 20, -74, -57, -27 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.remainder(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTryTransfer2",
	"Comment": "trytransfer returns false and does not enqueue if there are noconsumers waiting to poll or take.",
	"Method": "void testTryTransfer2(){\r\n    final LinkedTransferQueue q = new LinkedTransferQueue();\r\n    assertFalse(q.tryTransfer(new Object()));\r\n    assertFalse(q.hasWaitingConsumer());\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "java.lang.annotation.IncompleteAnnotationException.annotationType",
	"Comment": "returns the class object for the annotation type with themissing element.",
	"Method": "Class<? extends Annotation> annotationType(){\r\n    return annotationType;\r\n}"
}, {
	"Path": "java.net.URLClassLoader.findResources",
	"Comment": "returns all known urls which point to the specified resource.",
	"Method": "Enumeration<URL> findResources(String name){\r\n    if (name == null) {\r\n        return null;\r\n    }\r\n    return Collections.enumeration(urls);\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTryTransfer4",
	"Comment": "if there is a consumer waiting in take, trytransfer returnstrue while successfully transfering object.",
	"Method": "void testTryTransfer4(){\r\n    final Object hotPotato = new Object();\r\n    final LinkedTransferQueue q = new LinkedTransferQueue();\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!q.hasWaitingConsumer()) Thread.yield();\r\n            assertTrue(q.hasWaitingConsumer());\r\n            checkEmpty(q);\r\n            assertTrue(q.tryTransfer(hotPotato));\r\n        }\r\n    });\r\n    assertSame(q.take(), hotPotato);\r\n    checkEmpty(q);\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTryTransfer4",
	"Comment": "if there is a consumer waiting in take, trytransfer returnstrue while successfully transfering object.",
	"Method": "void testTryTransfer4(){\r\n    while (!q.hasWaitingConsumer()) Thread.yield();\r\n    assertTrue(q.hasWaitingConsumer());\r\n    checkEmpty(q);\r\n    assertTrue(q.tryTransfer(hotPotato));\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTryTransfer3",
	"Comment": "if there is a consumer waiting in timed poll, trytransferreturns true while successfully transfering object.",
	"Method": "void testTryTransfer3(){\r\n    final Object hotPotato = new Object();\r\n    final LinkedTransferQueue q = new LinkedTransferQueue();\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!q.hasWaitingConsumer()) Thread.yield();\r\n            assertTrue(q.hasWaitingConsumer());\r\n            checkEmpty(q);\r\n            assertTrue(q.tryTransfer(hotPotato));\r\n        }\r\n    });\r\n    long startTime = System.nanoTime();\r\n    assertSame(hotPotato, q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n    assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n    checkEmpty(q);\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTryTransfer3",
	"Comment": "if there is a consumer waiting in timed poll, trytransferreturns true while successfully transfering object.",
	"Method": "void testTryTransfer3(){\r\n    while (!q.hasWaitingConsumer()) Thread.yield();\r\n    assertTrue(q.hasWaitingConsumer());\r\n    checkEmpty(q);\r\n    assertTrue(q.tryTransfer(hotPotato));\r\n}"
}, {
	"Path": "sun.nio.ch.DatagramChannelImpl.translateReadyOps",
	"Comment": "translates native poll revent set into a ready operation set",
	"Method": "boolean translateReadyOps(int ops,int initialOps,SelectionKeyImpl sk){\r\n    int intOps = sk.nioInterestOps();\r\n    int oldOps = sk.nioReadyOps();\r\n    int newOps = initialOps;\r\n    if ((ops & PollArrayWrapper.POLLNVAL) != 0) {\r\n        return false;\r\n    }\r\n    if ((ops & (PollArrayWrapper.POLLERR | PollArrayWrapper.POLLHUP)) != 0) {\r\n        newOps = intOps;\r\n        sk.nioReadyOps(newOps);\r\n        return (newOps & ~oldOps) != 0;\r\n    }\r\n    if (((ops & PollArrayWrapper.POLLIN) != 0) && ((intOps & SelectionKey.OP_READ) != 0))\r\n        newOps |= SelectionKey.OP_READ;\r\n    if (((ops & PollArrayWrapper.POLLOUT) != 0) && ((intOps & SelectionKey.OP_WRITE) != 0))\r\n        newOps |= SelectionKey.OP_WRITE;\r\n    sk.nioReadyOps(newOps);\r\n    return (newOps & ~oldOps) != 0;\r\n}"
}, {
	"Path": "java.util.TimeZone.getDefault",
	"Comment": "gets the default timezone for this host.the source of the default timezonemay vary with implementation.",
	"Method": "TimeZone getDefault(){\r\n    return (TimeZone) getDefaultRef().clone();\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTryTransfer8",
	"Comment": "trytransfer attempts to enqueue into the queue and failsreturning false not enqueueing and the successive poll is null",
	"Method": "void testTryTransfer8(){\r\n    final LinkedTransferQueue q = new LinkedTransferQueue();\r\n    assertTrue(q.offer(four));\r\n    assertEquals(1, q.size());\r\n    long startTime = System.nanoTime();\r\n    assertFalse(q.tryTransfer(five, timeoutMillis(), MILLISECONDS));\r\n    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n    assertEquals(1, q.size());\r\n    assertSame(four, q.poll());\r\n    assertNull(q.poll());\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTryTransfer7",
	"Comment": "trytransfer waits for any elements previously in to be removedbefore transfering to a poll or take",
	"Method": "void testTryTransfer7(){\r\n    final LinkedTransferQueue q = new LinkedTransferQueue();\r\n    assertTrue(q.offer(four));\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            long startTime = System.nanoTime();\r\n            assertTrue(q.tryTransfer(five, LONG_DELAY_MS, MILLISECONDS));\r\n            assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n            checkEmpty(q);\r\n        }\r\n    });\r\n    while (q.size() != 2) Thread.yield();\r\n    assertEquals(2, q.size());\r\n    assertSame(four, q.poll());\r\n    assertSame(five, q.poll());\r\n    checkEmpty(q);\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTryTransfer7",
	"Comment": "trytransfer waits for any elements previously in to be removedbefore transfering to a poll or take",
	"Method": "void testTryTransfer7(){\r\n    long startTime = System.nanoTime();\r\n    assertTrue(q.tryTransfer(five, LONG_DELAY_MS, MILLISECONDS));\r\n    assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "java.util.EnumMap.put",
	"Comment": "associates the specified value with the specified key in this map.if the map previously contained a mapping for this key, the oldvalue is replaced.",
	"Method": "V put(K key,V value){\r\n    typeCheck(key);\r\n    int index = key.ordinal();\r\n    Object oldValue = vals[index];\r\n    vals[index] = maskNull(value);\r\n    if (oldValue == null)\r\n        size++;\r\n    return unmaskNull(oldValue);\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testSaturatedExecute4",
	"Comment": "executor using discardoldestpolicy drops oldest task if saturated.",
	"Method": "void testSaturatedExecute4(){\r\n    final CountDownLatch done = new CountDownLatch(1);\r\n    LatchAwaiter r1 = awaiter(done);\r\n    LatchAwaiter r2 = awaiter(done);\r\n    LatchAwaiter r3 = awaiter(done);\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(1, 1, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(1), new ThreadPoolExecutor.DiscardOldestPolicy());\r\n    try (PoolCleaner cleaner = cleaner(p, done)) {\r\n        assertEquals(LatchAwaiter.NEW, r1.state);\r\n        assertEquals(LatchAwaiter.NEW, r2.state);\r\n        assertEquals(LatchAwaiter.NEW, r3.state);\r\n        p.execute(r1);\r\n        p.execute(r2);\r\n        assertTrue(p.getQueue().contains(r2));\r\n        p.execute(r3);\r\n        assertFalse(p.getQueue().contains(r2));\r\n        assertTrue(p.getQueue().contains(r3));\r\n    }\r\n    assertEquals(LatchAwaiter.DONE, r1.state);\r\n    assertEquals(LatchAwaiter.NEW, r2.state);\r\n    assertEquals(LatchAwaiter.DONE, r3.state);\r\n}"
}, {
	"Path": "sun.misc.FloatingDecimal.toJavaFormatString",
	"Comment": "converts a single precision floating point value to a string.",
	"Method": "String toJavaFormatString(double d,String toJavaFormatString,float f,String toJavaFormatString,String toJavaFormatString,String toJavaFormatString){\r\n    return getBinaryToASCIIConverter(f).toJavaFormatString();\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedSynchronizer.owns",
	"Comment": "queries whether the given conditionobjectuses this synchronizer as its lock.",
	"Method": "boolean owns(ConditionObject condition){\r\n    return condition.isOwnedBy(this);\r\n}"
}, {
	"Path": "java.text.DecimalFormat.getNegativeSuffixFieldPositions",
	"Comment": "returns the fieldpositions of the fields in the suffix used fornegative numbers. this is not used if the user has explicitly seta negative suffix via setnegativesuffix. this islazily created.",
	"Method": "FieldPosition[] getNegativeSuffixFieldPositions(){\r\n    if (negativeSuffixFieldPositions == null) {\r\n        if (negSuffixPattern != null) {\r\n            negativeSuffixFieldPositions = expandAffix(negSuffixPattern);\r\n        } else {\r\n            negativeSuffixFieldPositions = EmptyFieldPositionArray;\r\n        }\r\n    }\r\n    return negativeSuffixFieldPositions;\r\n}"
}, {
	"Path": "java.util.concurrent.locks.ReentrantReadWriteLock.getReadLockCount",
	"Comment": "queries the number of read locks held for this lock. thismethod is designed for use in monitoring system state, not forsynchronization control.",
	"Method": "int getReadLockCount(int getReadLockCount){\r\n    return sync.getReadLockCount();\r\n}"
}, {
	"Path": "sun.security.x509.CertificatePolicyId.getIdentifier",
	"Comment": "return the value of the certificatepolicyid as an objectidentifier.",
	"Method": "ObjectIdentifier getIdentifier(){\r\n    return (id);\r\n}"
}, {
	"Path": "java.util.concurrent.Phaser.doArrive",
	"Comment": "main implementation for methods arrive and arriveandderegister.manually tuned to speed up and minimize race windows for thecommon case of just decrementing unarrived field.",
	"Method": "int doArrive(int adjust){\r\n    final Phaser root = this.root;\r\n    for (; ; ) {\r\n        long s = (root == this) ? state : reconcileState();\r\n        int phase = (int) (s >>> PHASE_SHIFT);\r\n        if (phase < 0)\r\n            return phase;\r\n        int counts = (int) s;\r\n        int unarrived = (counts == EMPTY) ? 0 : (counts & UNARRIVED_MASK);\r\n        if (unarrived <= 0)\r\n            throw new IllegalStateException(badArrive(s));\r\n        if (U.compareAndSwapLong(this, STATE, s, s -= adjust)) {\r\n            if (unarrived == 1) {\r\n                long n = s & PARTIES_MASK;\r\n                int nextUnarrived = (int) n >>> PARTIES_SHIFT;\r\n                if (root == this) {\r\n                    if (onAdvance(phase, nextUnarrived))\r\n                        n |= TERMINATION_BIT;\r\n                    else if (nextUnarrived == 0)\r\n                        n |= EMPTY;\r\n                    else\r\n                        n |= nextUnarrived;\r\n                    int nextPhase = (phase + 1) & MAX_PHASE;\r\n                    n |= (long) nextPhase << PHASE_SHIFT;\r\n                    U.compareAndSwapLong(this, STATE, s, n);\r\n                    releaseWaiters(phase);\r\n                } else if (nextUnarrived == 0) {\r\n                    phase = parent.doArrive(ONE_DEREGISTER);\r\n                    U.compareAndSwapLong(this, STATE, s, s | EMPTY);\r\n                } else\r\n                    phase = parent.doArrive(ONE_ARRIVAL);\r\n            }\r\n            return phase;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.containsValue",
	"Comment": "tests whether the specified object reference is a value in this identityhash map.",
	"Method": "boolean containsValue(Object value){\r\n    Object[] tab = table;\r\n    for (int i = 1; i < tab.length; i += 2) if (tab[i] == value && tab[i - 1] != null)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.AtomicMarkableReferenceTest.testCompareAndSet",
	"Comment": "compareandset succeeds in changing values if equal to expected referenceand mark else fails",
	"Method": "void testCompareAndSet(){\r\n    boolean[] mark = new boolean[1];\r\n    AtomicMarkableReference ai = new AtomicMarkableReference(one, false);\r\n    assertSame(one, ai.get(mark));\r\n    assertFalse(ai.isMarked());\r\n    assertFalse(mark[0]);\r\n    assertTrue(ai.compareAndSet(one, two, false, false));\r\n    assertSame(two, ai.get(mark));\r\n    assertFalse(mark[0]);\r\n    assertTrue(ai.compareAndSet(two, m3, false, true));\r\n    assertSame(m3, ai.get(mark));\r\n    assertTrue(mark[0]);\r\n    assertFalse(ai.compareAndSet(two, m3, true, true));\r\n    assertSame(m3, ai.get(mark));\r\n    assertTrue(mark[0]);\r\n}"
}, {
	"Path": "org.xml.sax.helpers.AttributeListImpl.setAttributeList",
	"Comment": "set the attribute list, discarding previous contents.this method allows an application writer to reuse anattribute list easily.",
	"Method": "void setAttributeList(AttributeList atts){\r\n    int count = atts.getLength();\r\n    clear();\r\n    for (int i = 0; i < count; i++) {\r\n        addAttribute(atts.getName(i), atts.getType(i), atts.getValue(i));\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.GenerationTest.compileAsClassFile",
	"Comment": "compiles java source to a jvm class file, then converts it to a compilationunit.",
	"Method": "CompilationUnit compileAsClassFile(String name,String source,CompilationUnit compileAsClassFile,String name,String source,String flags){\r\n    assertTrue(\"Classfile translation not enabled\", options.translateClassfiles());\r\n    InputFile input = createClassFile(name, source, flags);\r\n    if (input == null) {\r\n        return null;\r\n    }\r\n    int errors = ErrorUtil.errorCount();\r\n    CompilationUnit unit = parser.parse(input);\r\n    if (ErrorUtil.errorCount() > errors) {\r\n        int newErrorCount = ErrorUtil.errorCount() - errors;\r\n        String info = String.format(\"%d test compilation error%s\", newErrorCount, (newErrorCount == 1 ? \"\" : \"s\"));\r\n        failWithMessages(info, ErrorUtil.getErrorMessages().subList(errors, ErrorUtil.errorCount()));\r\n    }\r\n    return unit;\r\n}"
}, {
	"Path": "jsr166.ForkJoinTask8Test.testTryUnfork",
	"Comment": "tryunfork returns true for most recent unexecuted task,and suppresses execution",
	"Method": "void testTryUnfork(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib g = new AsyncFib(9);\r\n            assertSame(g, g.fork());\r\n            AsyncFib f = new AsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            assertTrue(f.tryUnfork());\r\n            helpQuiesce();\r\n            checkNotDone(f);\r\n            g.checkCompletedNormally();\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTask8Test.testTryUnfork",
	"Comment": "tryunfork returns true for most recent unexecuted task,and suppresses execution",
	"Method": "void testTryUnfork(){\r\n    AsyncFib g = new AsyncFib(9);\r\n    assertSame(g, g.fork());\r\n    AsyncFib f = new AsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    assertTrue(f.tryUnfork());\r\n    helpQuiesce();\r\n    checkNotDone(f);\r\n    g.checkCompletedNormally();\r\n}"
}, {
	"Path": "jsr166.AbstractExecutorServiceTest.testSubmitPrivilegedExceptionAction",
	"Comment": "a submitted privileged exception action runs to completion",
	"Method": "void testSubmitPrivilegedExceptionAction(){\r\n    Runnable r = new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            ExecutorService e = new DirectExecutorService();\r\n            Future future = e.submit(Executors.callable(new PrivilegedExceptionAction() {\r\n                public Object run() {\r\n                    return TEST_STRING;\r\n                }\r\n            }));\r\n            assertSame(TEST_STRING, future.get());\r\n        }\r\n    };\r\n    runWithPermissions(r);\r\n}"
}, {
	"Path": "jsr166.AbstractExecutorServiceTest.testSubmitPrivilegedExceptionAction",
	"Comment": "a submitted privileged exception action runs to completion",
	"Method": "void testSubmitPrivilegedExceptionAction(){\r\n    ExecutorService e = new DirectExecutorService();\r\n    Future future = e.submit(Executors.callable(new PrivilegedExceptionAction() {\r\n        public Object run() {\r\n            return TEST_STRING;\r\n        }\r\n    }));\r\n    assertSame(TEST_STRING, future.get());\r\n}"
}, {
	"Path": "jsr166.AbstractExecutorServiceTest.testSubmitPrivilegedExceptionAction",
	"Comment": "a submitted privileged exception action runs to completion",
	"Method": "void testSubmitPrivilegedExceptionAction(){\r\n    return TEST_STRING;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.Builder.targetDistance",
	"Comment": "determine how close a given certificate gets you towarda given target.",
	"Method": "int targetDistance(NameConstraintsExtension constraints,X509Certificate cert,GeneralNameInterface target){\r\n    if (constraints != null && !constraints.verify(cert)) {\r\n        throw new IOException(\"certificate does not satisfy existing name \" + \"constraints\");\r\n    }\r\n    X509CertImpl certImpl;\r\n    try {\r\n        certImpl = X509CertImpl.toImpl(cert);\r\n    } catch (CertificateException e) {\r\n        throw new IOException(\"Invalid certificate\", e);\r\n    }\r\n    X500Name subject = X500Name.asX500Name(certImpl.getSubjectX500Principal());\r\n    if (subject.equals(target)) {\r\n        return 0;\r\n    }\r\n    SubjectAlternativeNameExtension altNameExt = certImpl.getSubjectAlternativeNameExtension();\r\n    if (altNameExt != null) {\r\n        GeneralNames altNames = altNameExt.get(SubjectAlternativeNameExtension.SUBJECT_NAME);\r\n        if (altNames != null) {\r\n            for (int j = 0, n = altNames.size(); j < n; j++) {\r\n                GeneralNameInterface altName = altNames.get(j).getName();\r\n                if (altName.equals(target)) {\r\n                    return 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    NameConstraintsExtension ncExt = certImpl.getNameConstraintsExtension();\r\n    if (ncExt == null) {\r\n        return -1;\r\n    }\r\n    if (constraints != null) {\r\n        constraints.merge(ncExt);\r\n    } else {\r\n        constraints = (NameConstraintsExtension) ncExt.clone();\r\n    }\r\n    if (debug != null) {\r\n        debug.println(\"Builder.targetDistance() merged constraints: \" + String.valueOf(constraints));\r\n    }\r\n    GeneralSubtrees permitted = constraints.get(NameConstraintsExtension.PERMITTED_SUBTREES);\r\n    GeneralSubtrees excluded = constraints.get(NameConstraintsExtension.EXCLUDED_SUBTREES);\r\n    if (permitted != null) {\r\n        permitted.reduce(excluded);\r\n    }\r\n    if (debug != null) {\r\n        debug.println(\"Builder.targetDistance() reduced constraints: \" + permitted);\r\n    }\r\n    if (!constraints.verify(target)) {\r\n        throw new IOException(\"New certificate not allowed to sign \" + \"certificate for target\");\r\n    }\r\n    if (permitted == null) {\r\n        return -1;\r\n    }\r\n    for (int i = 0, n = permitted.size(); i < n; i++) {\r\n        GeneralNameInterface perName = permitted.get(i).getName().getName();\r\n        int distance = distance(perName, target, -1);\r\n        if (distance >= 0) {\r\n            return (distance + 1);\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "jsr166.PriorityBlockingQueueTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    final PriorityBlockingQueue q = populatedQueue(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(i, q.take());\r\n            }\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadStaysAlive(t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.PriorityBlockingQueueTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(i, q.take());\r\n    }\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n}"
}, {
	"Path": "jsr166.ExchangerTest.testReplacementAfterExchange",
	"Comment": "if one exchanging thread is interrupted, another succeeds.",
	"Method": "void testReplacementAfterExchange(){\r\n    final Exchanger e = new Exchanger();\r\n    final CountDownLatch exchanged = new CountDownLatch(2);\r\n    final CountDownLatch interrupted = new CountDownLatch(1);\r\n    Thread t1 = newStartedThread(new CheckedInterruptedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            assertSame(two, e.exchange(one));\r\n            exchanged.countDown();\r\n            e.exchange(two);\r\n        }\r\n    });\r\n    Thread t2 = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            assertSame(one, e.exchange(two));\r\n            exchanged.countDown();\r\n            interrupted.await();\r\n            assertSame(three, e.exchange(one));\r\n        }\r\n    });\r\n    Thread t3 = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            interrupted.await();\r\n            assertSame(one, e.exchange(three));\r\n        }\r\n    });\r\n    await(exchanged);\r\n    t1.interrupt();\r\n    awaitTermination(t1);\r\n    interrupted.countDown();\r\n    awaitTermination(t2);\r\n    awaitTermination(t3);\r\n}"
}, {
	"Path": "jsr166.ExchangerTest.testReplacementAfterExchange",
	"Comment": "if one exchanging thread is interrupted, another succeeds.",
	"Method": "void testReplacementAfterExchange(){\r\n    assertSame(two, e.exchange(one));\r\n    exchanged.countDown();\r\n    e.exchange(two);\r\n}"
}, {
	"Path": "jsr166.ExchangerTest.testReplacementAfterExchange",
	"Comment": "if one exchanging thread is interrupted, another succeeds.",
	"Method": "void testReplacementAfterExchange(){\r\n    assertSame(one, e.exchange(two));\r\n    exchanged.countDown();\r\n    interrupted.await();\r\n    assertSame(three, e.exchange(one));\r\n}"
}, {
	"Path": "jsr166.ExchangerTest.testReplacementAfterExchange",
	"Comment": "if one exchanging thread is interrupted, another succeeds.",
	"Method": "void testReplacementAfterExchange(){\r\n    interrupted.await();\r\n    assertSame(one, e.exchange(three));\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testCompleteExceptionally",
	"Comment": "invoke task throws exception after invoking completeexceptionally",
	"Method": "void testCompleteExceptionally(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FibAction f = new FibAction(8);\r\n            f.completeExceptionally(new FJException());\r\n            try {\r\n                f.invoke();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testCompleteExceptionally",
	"Comment": "invoke task throws exception after invoking completeexceptionally",
	"Method": "void testCompleteExceptionally(){\r\n    FibAction f = new FibAction(8);\r\n    f.completeExceptionally(new FJException());\r\n    try {\r\n        f.invoke();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "sun.security.pkcs.PKCS7.getContentInfo",
	"Comment": "returns the content information specified in this pkcs7 block.",
	"Method": "ContentInfo getContentInfo(){\r\n    return contentInfo;\r\n}"
}, {
	"Path": "java.util.concurrent.Phaser.badRegister",
	"Comment": "returns message string for bounds exceptions on registration.",
	"Method": "String badRegister(long s){\r\n    return \"Attempt to register more than \" + MAX_PARTIES + \" parties for \" + stateToString(s);\r\n}"
}, {
	"Path": "java.util.concurrent.DelayQueue.offer",
	"Comment": "inserts the specified element into this delay queue. as the queue isunbounded this method will never block.",
	"Method": "boolean offer(E e,boolean offer,E e,long timeout,TimeUnit unit){\r\n    return offer(e);\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testAdd1_IndexOutOfBoundsException",
	"Comment": "add throws an indexoutofboundsexception on a negative index",
	"Method": "void testAdd1_IndexOutOfBoundsException(){\r\n    CopyOnWriteArrayList c = populatedArray(5);\r\n    List[] lists = { c, c.subList(1, c.size() - 1) };\r\n    for (List list : lists) {\r\n        try {\r\n            list.add(-1, \"qwerty\");\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.setGroupingSeparator",
	"Comment": "sets the character used for thousands separator. different for french, etc.",
	"Method": "void setGroupingSeparator(char groupingSeparator){\r\n    this.groupingSeparator = groupingSeparator;\r\n}"
}, {
	"Path": "java.net.Inet4Address.equals",
	"Comment": "compares this object against the specified object.the result is true if and only if the argument isnot null and it represents the same ip address asthis object.two instances of inetaddress represent the same ipaddress if the length of the byte arrays returned bygetaddress is the same for both, and each of thearray components is the same for the byte arrays.",
	"Method": "boolean equals(Object obj){\r\n    return (obj != null) && (obj instanceof Inet4Address) && (((InetAddress) obj).holder().getAddress() == holder().getAddress());\r\n}"
}, {
	"Path": "sun.util.calendar.CalendarSystem.getGregorianCalendar",
	"Comment": "returns the singleton instance of the gregoriancalendar system.",
	"Method": "Gregorian getGregorianCalendar(){\r\n    return GregorianHolder.INSTANCE;\r\n}"
}, {
	"Path": "java.security.spec.EllipticCurve.getSeed",
	"Comment": "returns the seeding bytes seed usedduring curve generation. may be null if not specified.",
	"Method": "byte[] getSeed(){\r\n    if (seed == null)\r\n        return null;\r\n    else\r\n        return seed.clone();\r\n}"
}, {
	"Path": "tests.support.Support_StringWriter.toString",
	"Comment": "answer the contents of this stringwriter as a string. any changes made to\tthe stringbuffer by the receiver after returning will not be reflected in\tthe string returned to the caller.",
	"Method": "String toString(){\r\n    synchronized (lock) {\r\n        return buf.toString();\r\n    }\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    ConcurrentSkipListSet q = new ConcurrentSkipListSet();\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        q.addAll(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.net.URLConnection.setIfModifiedSince",
	"Comment": "sets the value of the ifmodifiedsince field ofthis urlconnection to the specified value.",
	"Method": "void setIfModifiedSince(long ifmodifiedsince){\r\n    if (connected)\r\n        throw new IllegalStateException(\"Already connected\");\r\n    ifModifiedSince = ifmodifiedsince;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigDecimalArithmeticTest.testMultiplyMathContextDiffScalePosNeg",
	"Comment": "multiply two numbers of different scales using mathcontext",
	"Method": "void testMultiplyMathContextDiffScalePosNeg(){\r\n    String a = \"987667796597975765768768767866756808779810457634781384756794987\";\r\n    int aScale = 100;\r\n    String b = \"747233429293018787918347987234564568\";\r\n    int bScale = -70;\r\n    String c = \"7.3801839465418518653942222612429081498248509257207477E+68\";\r\n    int cScale = -16;\r\n    BigDecimal aNumber = new BigDecimal(new BigInteger(a), aScale);\r\n    BigDecimal bNumber = new BigDecimal(new BigInteger(b), bScale);\r\n    MathContext mc = new MathContext(53, RoundingMode.HALF_UP);\r\n    BigDecimal result = aNumber.multiply(bNumber, mc);\r\n    assertEquals(\"incorrect value\", c, result.toString());\r\n    assertEquals(\"incorrect scale\", cScale, result.scale());\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceArrayTest.testIndexing",
	"Comment": "get and set for out of bound indices throw indexoutofboundsexception",
	"Method": "void testIndexing(){\r\n    AtomicReferenceArray<Integer> aa = new AtomicReferenceArray<Integer>(SIZE);\r\n    for (int index : new int[] { -1, SIZE }) {\r\n        try {\r\n            aa.get(index);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.set(index, null);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.lazySet(index, null);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.compareAndSet(index, null, null);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.weakCompareAndSet(index, null, null);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.Calendar.internalGet",
	"Comment": "returns the value of the given calendar field. this method doesnot involve normalization or validation of the field value.",
	"Method": "int internalGet(int field){\r\n    return fields[field];\r\n}"
}, {
	"Path": "java.time.Duration.plusHours",
	"Comment": "returns a copy of this duration with the specified duration in hours added.this instance is immutable and unaffected by this method call.",
	"Method": "Duration plusHours(long hoursToAdd){\r\n    return plus(Math.multiplyExact(hoursToAdd, SECONDS_PER_HOUR), 0);\r\n}"
}, {
	"Path": "jsr166.ConcurrentHashMapTest.testPutIfAbsent2",
	"Comment": "putifabsent does not add the pair if the key is already present",
	"Method": "void testPutIfAbsent2(){\r\n    ConcurrentHashMap map = map5();\r\n    assertEquals(\"A\", map.putIfAbsent(one, \"Z\"));\r\n}"
}, {
	"Path": "java.security.SecureClassLoader.getProtectionDomain",
	"Comment": "returned cached protectiondomain for the specified codesource.",
	"Method": "ProtectionDomain getProtectionDomain(CodeSource cs){\r\n    if (cs == null)\r\n        return null;\r\n    ProtectionDomain pd = null;\r\n    synchronized (pdcache) {\r\n        pd = pdcache.get(cs);\r\n        if (pd == null) {\r\n            PermissionCollection perms = getPermissions(cs);\r\n            pd = new ProtectionDomain(cs, perms, this, null);\r\n            pdcache.put(cs, pd);\r\n        }\r\n    }\r\n    return pd;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesException1",
	"Comment": "create a number from a sign and an array of bytes.verify an exception thrown if a sign has improper value.",
	"Method": "void testConstructorSignBytesException1(){\r\n    byte[] aBytes = { 123, 45, -3, -76 };\r\n    int aSign = 3;\r\n    try {\r\n        new BigInteger(aSign, aBytes);\r\n        fail(\"NumberFormatException has not been caught\");\r\n    } catch (NumberFormatException e) {\r\n        assertEquals(\"Improper exception message\", \"Invalid signum value\", e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.google.mockwebserver.Dispatcher.peek",
	"Comment": "returns an early guess of the next response, used for policy on how anincoming request should be received. the default implementation returns anempty response. mischievous implementations can return other values to testhttp edge cases, such as unhappy socket policies or throttled requestbodies.",
	"Method": "MockResponse peek(){\r\n    return new MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN);\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testCorePoolSizeIllegalArgumentException",
	"Comment": "setcorepoolsize of negative value throws illegalargumentexception",
	"Method": "void testCorePoolSizeIllegalArgumentException(){\r\n    final ThreadPoolExecutor p = new CustomTPE(1, 2, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        try {\r\n            p.setCorePoolSize(-1);\r\n            shouldThrow();\r\n        } catch (IllegalArgumentException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.util.DerInputBuffer.getInteger",
	"Comment": "returns the integer which takes up the specified numberof bytes in this buffer.",
	"Method": "int getInteger(int len){\r\n    BigInteger result = getBigInteger(len, false);\r\n    if (result.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) < 0) {\r\n        throw new IOException(\"Integer below minimum valid value\");\r\n    }\r\n    if (result.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) > 0) {\r\n        throw new IOException(\"Integer exceeds maximum valid value\");\r\n    }\r\n    return result.intValue();\r\n}"
}, {
	"Path": "java.util.jar.JarOutputStream.hasMagic",
	"Comment": "returns true if specified byte array contains thejar magic extra field id.",
	"Method": "boolean hasMagic(byte[] edata){\r\n    try {\r\n        int i = 0;\r\n        while (i < edata.length) {\r\n            if (get16(edata, i) == JAR_MAGIC) {\r\n                return true;\r\n            }\r\n            i += get16(edata, i + 2) + 4;\r\n        }\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "android.icu.dev.test.timezone.TimeZoneRuleTest.TestRBTZTransition",
	"Comment": "check if an olsontimezone and its equivalent rbtz have the exact sametransitions.",
	"Method": "void TestRBTZTransition(){\r\n    int[] STARTYEARS = { 1950, 1975, 2000, 2010 };\r\n    String[] zids = getTestZIDs();\r\n    for (int i = 0; i < zids.length; i++) {\r\n        TimeZone tz = TimeZone.getTimeZone(zids[i], TimeZone.TIMEZONE_ICU);\r\n        if (tz == null) {\r\n            break;\r\n        }\r\n        for (int j = 0; j < STARTYEARS.length; j++) {\r\n            long startTime = getUTCMillis(STARTYEARS[j], Calendar.JANUARY, 1);\r\n            TimeZoneRule[] rules = ((BasicTimeZone) tz).getTimeZoneRules(startTime);\r\n            RuleBasedTimeZone rbtz = new RuleBasedTimeZone(tz.getID() + \"(RBTZ)\", (InitialTimeZoneRule) rules[0]);\r\n            for (int k = 1; k < rules.length; k++) {\r\n                rbtz.addTransitionRule(rules[k]);\r\n            }\r\n            long until = getUTCMillis(STARTYEARS[j] + 20, Calendar.JANUARY, 1);\r\n            compareTransitionsAscending(tz, rbtz, startTime, until, false);\r\n            compareTransitionsAscending(tz, rbtz, startTime + 1, until, true);\r\n            compareTransitionsDescending(tz, rbtz, startTime, until, false);\r\n            compareTransitionsDescending(tz, rbtz, startTime + 1, until, true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.j2objc.ClassTest.testNoSuchInterfaceMethod",
	"Comment": "verify that lookup of a method in an interface throws nosuchmethod.",
	"Method": "void testNoSuchInterfaceMethod(){\r\n    try {\r\n        Method m = java.io.Serializable.class.getMethod(\"foo\");\r\n        fail(\"method shouldn't have been returned\");\r\n    } catch (NoSuchMethodException e) {\r\n    } catch (Throwable t) {\r\n        fail(\"wrong exception thrown\");\r\n    }\r\n}"
}, {
	"Path": "libcore.javax.net.ssl.TestTrustManager.getAcceptedIssuers",
	"Comment": "returns the list of certificate issuer authorities which are trusted forauthentication of peers.",
	"Method": "X509Certificate[] getAcceptedIssuers(){\r\n    X509Certificate[] result = trustManager.getAcceptedIssuers();\r\n    out.print(\"TestTrustManager.getAcceptedIssuers result=\" + result.length);\r\n    return result;\r\n}"
}, {
	"Path": "java.net.DatagramPacket.getAddress",
	"Comment": "returns the ip address of the machine to which this datagram is beingsent or from which the datagram was received.",
	"Method": "InetAddress getAddress(){\r\n    return address;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.GenerationTest.assertTranslation",
	"Comment": "asserts that translated source contains a specified string.",
	"Method": "void assertTranslation(String translation,String expected){\r\n    if (!translation.contains(expected)) {\r\n        fail(\"expected:\\\"\" + expected + \"\\\" in:\\n\" + translation);\r\n    }\r\n}"
}, {
	"Path": "java.util.EnumMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this map.these mappings will replace any mappings that this map had forany of the keys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> m){\r\n    if (m instanceof EnumMap) {\r\n        EnumMap<? extends K, ? extends V> em = (EnumMap<? extends K, ? extends V>) m;\r\n        if (em.keyType != keyType) {\r\n            if (em.isEmpty())\r\n                return;\r\n            throw new ClassCastException(em.keyType + \" != \" + keyType);\r\n        }\r\n        for (int i = 0; i < keyUniverse.length; i++) {\r\n            Object emValue = em.vals[i];\r\n            if (emValue != null) {\r\n                if (vals[i] == null)\r\n                    size++;\r\n                vals[i] = emValue;\r\n            }\r\n        }\r\n    } else {\r\n        super.putAll(m);\r\n    }\r\n}"
}, {
	"Path": "java.net.NetworkInterface.getDisplayName",
	"Comment": "get the display name of this network interface.a display name is a human readable string describing the networkdevice.",
	"Method": "String getDisplayName(){\r\n    return \"\".equals(displayName) ? null : displayName;\r\n}"
}, {
	"Path": "java.text.DateFormatSymbols.getInstanceRef",
	"Comment": "returns a dateformatsymbols provided by a provider or found inthe cache. note that this method returns a cached instance,not its clone. therefore, the instance should never be given toan application.",
	"Method": "DateFormatSymbols getInstanceRef(Locale locale){\r\n    return getCachedInstance(locale);\r\n}"
}, {
	"Path": "java.util.ArrayList.ensureCapacity",
	"Comment": "increases the capacity of this arraylist instance, ifnecessary, to ensure that it can hold at least the number of elementsspecified by the minimum capacity argument.",
	"Method": "void ensureCapacity(int minCapacity){\r\n    int minExpand = (elementData != EMPTY_ELEMENTDATA) ? 0 : DEFAULT_CAPACITY;\r\n    if (minCapacity > minExpand) {\r\n        ensureExplicitCapacity(minCapacity);\r\n    }\r\n}"
}, {
	"Path": "java.util.OptionalDouble.ifPresent",
	"Comment": "have the specified consumer accept the value if a value is present,otherwise do nothing.",
	"Method": "void ifPresent(DoubleConsumer consumer){\r\n    if (isPresent)\r\n        consumer.accept(value);\r\n}"
}, {
	"Path": "java.net.Socket.bind",
	"Comment": "binds the socket to a local address.if the address is null, then the system will pick upan ephemeral port and a valid local address to bind the socket.",
	"Method": "void bind(SocketAddress bindpoint){\r\n    if (isClosed())\r\n        throw new SocketException(\"Socket is closed\");\r\n    if (!oldImpl && isBound())\r\n        throw new SocketException(\"Already bound\");\r\n    if (bindpoint != null && (!(bindpoint instanceof InetSocketAddress)))\r\n        throw new IllegalArgumentException(\"Unsupported address type\");\r\n    InetSocketAddress epoint = (InetSocketAddress) bindpoint;\r\n    if (epoint != null && epoint.isUnresolved())\r\n        throw new SocketException(\"Unresolved address\");\r\n    if (epoint == null) {\r\n        epoint = new InetSocketAddress(0);\r\n    }\r\n    InetAddress addr = epoint.getAddress();\r\n    int port = epoint.getPort();\r\n    checkAddress(addr, \"bind\");\r\n    getImpl().bind(addr, port);\r\n    bound = true;\r\n}"
}, {
	"Path": "sun.security.x509.DistributionPointName.equals",
	"Comment": "compare an object to this distribution point name for equality.",
	"Method": "boolean equals(Object obj,boolean equals,Object a,Object b){\r\n    return (a == null) ? (b == null) : a.equals(b);\r\n}"
}, {
	"Path": "java.lang.Thread.dumpStack",
	"Comment": "prints to the standard error stream a text representation of the currentstack for this thread.",
	"Method": "void dumpStack(){\r\n    new Throwable(\"stack dump\").printStackTrace();\r\n}"
}, {
	"Path": "java.util.stream.IntStream.concat",
	"Comment": "creates a lazily concatenated stream whose elements are all theelements of the first stream followed by all the elements of thesecond stream.the resulting stream is ordered if bothof the input streams are ordered, and parallel if either of the inputstreams is parallel.when the resulting stream is closed, the closehandlers for both input streams are invoked.",
	"Method": "IntStream concat(IntStream a,IntStream b){\r\n    Objects.requireNonNull(a);\r\n    Objects.requireNonNull(b);\r\n    Spliterator.OfInt split = new Streams.ConcatSpliterator.OfInt(a.spliterator(), b.spliterator());\r\n    IntStream stream = StreamSupport.intStream(split, a.isParallel() || b.isParallel());\r\n    return stream.onClose(Streams.composedClose(a, b));\r\n}"
}, {
	"Path": "java.lang.ThreadGroup.addUnstarted",
	"Comment": "increments the count of unstarted threads in the thread group.unstarted threads are not added to the thread group so that theycan be collected if they are never started, but they must becounted so that daemon thread groups with unstarted threads inthem are not destroyed.",
	"Method": "void addUnstarted(){\r\n    synchronized (this) {\r\n        if (destroyed) {\r\n            throw new IllegalThreadStateException();\r\n        }\r\n        nUnstartedThreads++;\r\n    }\r\n}"
}, {
	"Path": "java.security.spec.X509EncodedKeySpec.getFormat",
	"Comment": "returns the name of the encoding format associated with thiskey specification.",
	"Method": "String getFormat(){\r\n    return \"X.509\";\r\n}"
}, {
	"Path": "javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory",
	"Comment": "sets the default sslsocketfactory inherited by newinstances of this class.the socket factories are used when creating sockets for securehttps url connections.",
	"Method": "void setDefaultSSLSocketFactory(SSLSocketFactory sf){\r\n    if (sf == null) {\r\n        throw new IllegalArgumentException(\"no default SSLSocketFactory specified\");\r\n    }\r\n    SecurityManager sm = System.getSecurityManager();\r\n    if (sm != null) {\r\n        sm.checkSetFactory();\r\n    }\r\n    defaultSSLSocketFactory = sf;\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testBlockingTakeLast",
	"Comment": "takelast removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTakeLast(){\r\n    final LinkedBlockingDeque q = populatedDeque(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(SIZE - i - 1, q.takeLast());\r\n            }\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.takeLast();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.takeLast();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadStaysAlive(t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testBlockingTakeLast",
	"Comment": "takelast removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTakeLast(){\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(SIZE - i - 1, q.takeLast());\r\n    }\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.takeLast();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.takeLast();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicLongFieldUpdater.getAndSet",
	"Comment": "atomically sets the field of the given object managed by this updaterto the given value and returns the old value.",
	"Method": "long getAndSet(T obj,long newValue,long getAndSet,T obj,long newValue){\r\n    long prev;\r\n    do {\r\n        prev = get(obj);\r\n    } while (!compareAndSet(obj, prev, newValue));\r\n    return prev;\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testConstructorDefaultValues",
	"Comment": "empty constructor builds a new phaser with no parent, no registeredparties and initial phase number of 0",
	"Method": "void testConstructorDefaultValues(){\r\n    Phaser phaser = new Phaser();\r\n    assertNull(phaser.getParent());\r\n    assertEquals(0, phaser.getRegisteredParties());\r\n    assertEquals(0, phaser.getArrivedParties());\r\n    assertEquals(0, phaser.getUnarrivedParties());\r\n    assertEquals(0, phaser.getPhase());\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testAbnormalInvoke",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvoke(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingFibAction f = new FailingFibAction(8);\r\n            try {\r\n                f.invoke();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testAbnormalInvoke",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvoke(){\r\n    FailingFibAction f = new FailingFibAction(8);\r\n    try {\r\n        f.invoke();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "okio.ByteString.base64",
	"Comment": "returns this byte string encoded as base64. in violation of therfc, the returned string does not wrap lines at 76 columns.",
	"Method": "String base64(){\r\n    return Base64.encode(data);\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testSetRejectedExecutionHandler",
	"Comment": "setrejectedexecutionhandler sets the handler returned bygetrejectedexecutionhandler",
	"Method": "void testSetRejectedExecutionHandler(){\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(1, 2, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        RejectedExecutionHandler handler = new NoOpREHandler();\r\n        p.setRejectedExecutionHandler(handler);\r\n        assertSame(handler, p.getRejectedExecutionHandler());\r\n    }\r\n}"
}, {
	"Path": "com.google.mockwebserver.RecordedRequest.getSequenceNumber",
	"Comment": "returns the index of this request on its http connection. since a singlehttp connection may serve multiple requests, each request is assigned itsown sequence number.",
	"Method": "int getSequenceNumber(){\r\n    return sequenceNumber;\r\n}"
}, {
	"Path": "java.text.MessageFormat.toPattern",
	"Comment": "returns a pattern representing the current state of the message format.the string is constructed from internal information and thereforedoes not necessarily equal the previously applied pattern.",
	"Method": "String toPattern(){\r\n    int lastOffset = 0;\r\n    StringBuilder result = new StringBuilder();\r\n    for (int i = 0; i <= maxOffset; ++i) {\r\n        copyAndFixQuotes(pattern, lastOffset, offsets[i], result);\r\n        lastOffset = offsets[i];\r\n        result.append('{').append(argumentNumbers[i]);\r\n        Format fmt = formats[i];\r\n        if (fmt == null) {\r\n        } else if (fmt instanceof NumberFormat) {\r\n            if (fmt.equals(NumberFormat.getInstance(locale))) {\r\n                result.append(\",number\");\r\n            } else if (fmt.equals(NumberFormat.getCurrencyInstance(locale))) {\r\n                result.append(\",number,currency\");\r\n            } else if (fmt.equals(NumberFormat.getPercentInstance(locale))) {\r\n                result.append(\",number,percent\");\r\n            } else if (fmt.equals(NumberFormat.getIntegerInstance(locale))) {\r\n                result.append(\",number,integer\");\r\n            } else {\r\n                if (fmt instanceof DecimalFormat) {\r\n                    result.append(\",number,\").append(((DecimalFormat) fmt).toPattern());\r\n                } else if (fmt instanceof ChoiceFormat) {\r\n                    result.append(\",choice,\").append(((ChoiceFormat) fmt).toPattern());\r\n                } else {\r\n                }\r\n            }\r\n        } else if (fmt instanceof DateFormat) {\r\n            int index;\r\n            for (index = MODIFIER_DEFAULT; index < DATE_TIME_MODIFIERS.length; index++) {\r\n                DateFormat df = DateFormat.getDateInstance(DATE_TIME_MODIFIERS[index], locale);\r\n                if (fmt.equals(df)) {\r\n                    result.append(\",date\");\r\n                    break;\r\n                }\r\n                df = DateFormat.getTimeInstance(DATE_TIME_MODIFIERS[index], locale);\r\n                if (fmt.equals(df)) {\r\n                    result.append(\",time\");\r\n                    break;\r\n                }\r\n            }\r\n            if (index >= DATE_TIME_MODIFIERS.length) {\r\n                if (fmt instanceof SimpleDateFormat) {\r\n                    result.append(\",date,\").append(((SimpleDateFormat) fmt).toPattern());\r\n                } else {\r\n                }\r\n            } else if (index != MODIFIER_DEFAULT) {\r\n                result.append(',').append(DATE_TIME_MODIFIER_KEYWORDS[index]);\r\n            }\r\n        } else {\r\n        }\r\n        result.append('}');\r\n    }\r\n    copyAndFixQuotes(pattern, lastOffset, pattern.length(), result);\r\n    return result.toString();\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkTimedGetSingleton",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGetSingleton(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FailingAsyncFib f = new FailingAsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkTimedGetSingleton",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGetSingleton(){\r\n    FailingAsyncFib f = new FailingAsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.Logger.removeHandler",
	"Comment": "remove a log handler.returns silently if the given handler is not found or is null",
	"Method": "void removeHandler(Handler handler){\r\n    checkPermission();\r\n    if (handler == null) {\r\n        return;\r\n    }\r\n    handlers.remove(handler);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testDoubleValuePosRounded1",
	"Comment": "convert a positive number to a double value. rounding is needed.the rounding bit is 1 and the next bit to the left is 1.",
	"Method": "void testDoubleValuePosRounded1(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = 1;\r\n    double result = 1.54747264387948E26;\r\n    double aNumber = new BigInteger(aSign, a).doubleValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testMaximumPoolSizeIllegalArgumentException2",
	"Comment": "setmaximumpoolsize throws illegalargumentexceptionif given a negative value",
	"Method": "void testMaximumPoolSizeIllegalArgumentException2(){\r\n    final ThreadPoolExecutor p = new CustomTPE(2, 3, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        try {\r\n            p.setMaximumPoolSize(-1);\r\n            shouldThrow();\r\n        } catch (IllegalArgumentException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testDoubleValuePosRounded2",
	"Comment": "convert a positive number to a double value. rounding is needed.the rounding bit is 1 and the next bit to the left is 0but some of dropped bits are 1s.",
	"Method": "void testDoubleValuePosRounded2(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, 36, 23, 1, -3, -5 };\r\n    int aSign = 1;\r\n    double result = 1.547472643879479E26;\r\n    double aNumber = new BigInteger(aSign, a).doubleValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "sun.security.x509.CRLDistributionPointsExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(POINTS);\r\n    return elements.elements();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.Parser.addClasspathEntry",
	"Comment": "adds a single path to the classpath for the next compilation.",
	"Method": "void addClasspathEntry(String entry){\r\n    classpathEntries.add(entry);\r\n}"
}, {
	"Path": "java.util.jar.JarVerifier.getCerts",
	"Comment": "return an array of java.security.cert.certificate objects forthe given file in the jar.",
	"Method": "java.security.cert.Certificate[] getCerts(String name,java.security.cert.Certificate[] getCerts,JarFile jar,JarEntry entry){\r\n    return mapSignersToCertArray(getCodeSigners(jar, entry));\r\n}"
}, {
	"Path": "java.util.Calendar.isSet",
	"Comment": "determines if the given calendar field has a value set,including cases that the value has been set by internal fieldscalculations triggered by a get method call.",
	"Method": "boolean isSet(int field){\r\n    return stamp[field] != UNSET;\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedSynchronizer.enq",
	"Comment": "inserts node into queue, initializing if necessary. see picture above.",
	"Method": "Node enq(Node node){\r\n    for (; ; ) {\r\n        Node oldTail = tail;\r\n        if (oldTail != null) {\r\n            U.putObject(node, Node.PREV, oldTail);\r\n            if (compareAndSetTail(oldTail, node)) {\r\n                oldTail.next = node;\r\n                return oldTail;\r\n            }\r\n        } else {\r\n            initializeSyncQueue();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.text.Format.formatToCharacterIterator",
	"Comment": "formats an object producing an attributedcharacteriterator.you can use the returned attributedcharacteriteratorto build the resulting string, as well as to determine informationabout the resulting string.each attribute key of the attributedcharacteriterator will be of typefield. it is up to each format implementationto define what the legal values are for each attribute in theattributedcharacteriterator, but typically the attributekey is also used as the attribute value.the default implementation creates anattributedcharacteriterator with no attributes. subclassesthat support fields should override this and create anattributedcharacteriterator with meaningful attributes.",
	"Method": "AttributedCharacterIterator formatToCharacterIterator(Object obj){\r\n    return createAttributedCharacterIterator(format(obj));\r\n}"
}, {
	"Path": "java.util.zip.GZIPInputStream.readHeader",
	"Comment": "reads gzip member header and returns the total byte numberof this member header.",
	"Method": "int readHeader(InputStream this_in){\r\n    CheckedInputStream in = new CheckedInputStream(this_in, crc);\r\n    crc.reset();\r\n    if (readUShort(in) != GZIP_MAGIC) {\r\n        throw new ZipException(\"Not in GZIP format\");\r\n    }\r\n    if (readUByte(in) != 8) {\r\n        throw new ZipException(\"Unsupported compression method\");\r\n    }\r\n    int flg = readUByte(in);\r\n    skipBytes(in, 6);\r\n    int n = 2 + 2 + 6;\r\n    if ((flg & FEXTRA) == FEXTRA) {\r\n        int m = readUShort(in);\r\n        skipBytes(in, m);\r\n        n += m + 2;\r\n    }\r\n    if ((flg & FNAME) == FNAME) {\r\n        do {\r\n            n++;\r\n        } while (readUByte(in) != 0);\r\n    }\r\n    if ((flg & FCOMMENT) == FCOMMENT) {\r\n        do {\r\n            n++;\r\n        } while (readUByte(in) != 0);\r\n    }\r\n    if ((flg & FHCRC) == FHCRC) {\r\n        int v = (int) crc.getValue() & 0xffff;\r\n        if (readUShort(in) != v) {\r\n            throw new ZipException(\"Corrupt GZIP header\");\r\n        }\r\n        n += 2;\r\n    }\r\n    crc.reset();\r\n    return n;\r\n}"
}, {
	"Path": "java.security.KeyStore.getEntry",
	"Comment": "gets a keystore entry for the specified aliaswith the specified protection parameter.",
	"Method": "Entry getEntry(String alias,ProtectionParameter protParam){\r\n    if (alias == null) {\r\n        throw new NullPointerException(\"invalid null input\");\r\n    }\r\n    if (!initialized) {\r\n        throw new KeyStoreException(\"Uninitialized keystore\");\r\n    }\r\n    return keyStoreSpi.engineGetEntry(alias, protParam);\r\n}"
}, {
	"Path": "java.lang.ClassLoader.getPackage",
	"Comment": "returns a package that has been defined by this class loaderor any of its ancestors.",
	"Method": "Package getPackage(String name){\r\n    Package pkg;\r\n    synchronized (packages) {\r\n        pkg = packages.get(name);\r\n    }\r\n    return pkg;\r\n}"
}, {
	"Path": "jsr166.ArrayDequeTest.testConstructor5",
	"Comment": "initializing from collection with some null elements throws npe",
	"Method": "void testConstructor5(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        new ArrayDeque(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ArrayDequeTest.testConstructor6",
	"Comment": "deque contains all elements of collection used to initialize",
	"Method": "void testConstructor6(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = new Integer(i);\r\n    ArrayDeque q = new ArrayDeque(Arrays.asList(ints));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.pollFirst());\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testFixedDelaySequence",
	"Comment": "schedulewithfixeddelay executes series of tasks with given period.eventually, it must hold that each task starts at least delay and atdelay after the termination of the previous task.",
	"Method": "void testFixedDelaySequence(){\r\n    final CustomExecutor p = new CustomExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        for (int delay = 1; delay <= LONG_DELAY_MS; delay *= 3) {\r\n            final long startTime = System.nanoTime();\r\n            final AtomicLong previous = new AtomicLong(startTime);\r\n            final AtomicBoolean tryLongerDelay = new AtomicBoolean(false);\r\n            final int cycles = 8;\r\n            final CountDownLatch done = new CountDownLatch(cycles);\r\n            final int d = delay;\r\n            final Runnable task = new CheckedRunnable() {\r\n                public void realRun() {\r\n                    long now = System.nanoTime();\r\n                    long elapsedMillis = NANOSECONDS.toMillis(now - previous.get());\r\n                    if (done.getCount() == cycles) {\r\n                        if (elapsedMillis >= d)\r\n                            tryLongerDelay.set(true);\r\n                    } else {\r\n                        assertTrue(elapsedMillis >= d);\r\n                        if (elapsedMillis >= 2 * d)\r\n                            tryLongerDelay.set(true);\r\n                    }\r\n                    previous.set(now);\r\n                    done.countDown();\r\n                }\r\n            };\r\n            final ScheduledFuture periodicTask = p.scheduleWithFixedDelay(task, 0, delay, MILLISECONDS);\r\n            final int totalDelayMillis = (cycles - 1) * delay;\r\n            await(done, totalDelayMillis + cycles * LONG_DELAY_MS);\r\n            periodicTask.cancel(true);\r\n            final long elapsedMillis = millisElapsedSince(startTime);\r\n            assertTrue(elapsedMillis >= totalDelayMillis);\r\n            if (!tryLongerDelay.get())\r\n                return;\r\n        }\r\n        fail(\"unexpected execution rate\");\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testFixedDelaySequence",
	"Comment": "schedulewithfixeddelay executes series of tasks with given period.eventually, it must hold that each task starts at least delay and atdelay after the termination of the previous task.",
	"Method": "void testFixedDelaySequence(){\r\n    long now = System.nanoTime();\r\n    long elapsedMillis = NANOSECONDS.toMillis(now - previous.get());\r\n    if (done.getCount() == cycles) {\r\n        if (elapsedMillis >= d)\r\n            tryLongerDelay.set(true);\r\n    } else {\r\n        assertTrue(elapsedMillis >= d);\r\n        if (elapsedMillis >= 2 * d)\r\n            tryLongerDelay.set(true);\r\n    }\r\n    previous.set(now);\r\n    done.countDown();\r\n}"
}, {
	"Path": "java.time.OffsetTime.format",
	"Comment": "formats this time using the specified formatter.this time will be passed to the formatter to produce a string.",
	"Method": "String format(DateTimeFormatter formatter){\r\n    Objects.requireNonNull(formatter, \"formatter\");\r\n    return formatter.format(this);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTask8Test.testPollNextLocalTask",
	"Comment": "pollnextlocaltask returns most recent unexecuted task withoutexecuting it",
	"Method": "void testPollNextLocalTask(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib g = new AsyncFib(9);\r\n            assertSame(g, g.fork());\r\n            AsyncFib f = new AsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(f, pollNextLocalTask());\r\n            helpQuiesce();\r\n            checkNotDone(f);\r\n            g.checkCompletedNormally();\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTask8Test.testPollNextLocalTask",
	"Comment": "pollnextlocaltask returns most recent unexecuted task withoutexecuting it",
	"Method": "void testPollNextLocalTask(){\r\n    AsyncFib g = new AsyncFib(9);\r\n    assertSame(g, g.fork());\r\n    AsyncFib f = new AsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(f, pollNextLocalTask());\r\n    helpQuiesce();\r\n    checkNotDone(f);\r\n    g.checkCompletedNormally();\r\n}"
}, {
	"Path": "java.util.regex.Pattern.pattern",
	"Comment": "returns the regular expression from which this pattern was compiled.",
	"Method": "String pattern(){\r\n    return pattern;\r\n}"
}, {
	"Path": "jsr166.ReentrantReadWriteLockTest.assertHasWaiters",
	"Comment": "checks that condition c has exactly the given waiter threads.",
	"Method": "void assertHasWaiters(PublicReentrantReadWriteLock lock,Condition c,Thread threads){\r\n    lock.writeLock().lock();\r\n    assertEquals(threads.length > 0, lock.hasWaiters(c));\r\n    assertEquals(threads.length, lock.getWaitQueueLength(c));\r\n    assertEquals(threads.length == 0, lock.getWaitingThreads(c).isEmpty());\r\n    assertEquals(threads.length, lock.getWaitingThreads(c).size());\r\n    assertEquals(new HashSet<Thread>(lock.getWaitingThreads(c)), new HashSet<Thread>(Arrays.asList(threads)));\r\n    lock.writeLock().unlock();\r\n}"
}, {
	"Path": "java.security.cert.PKIXParameters.setExplicitPolicyRequired",
	"Comment": "sets the explicitpolicyrequired flag. if this flag is true, anacceptable policy needs to be explicitly identified in every certificate.by default, the explicitpolicyrequired flag is false.",
	"Method": "void setExplicitPolicyRequired(boolean val){\r\n    explicitPolicyRequired = val;\r\n}"
}, {
	"Path": "sun.security.x509.PolicyConstraintsExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(REQUIRE);\r\n    elements.addElement(INHIBIT);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testGetWaitingThreadsIMSE",
	"Comment": "getwaitingthreads throws illegalmonitorstateexception if not synced",
	"Method": "void testGetWaitingThreadsIMSE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    try {\r\n        sync.getWaitingThreads(c);\r\n        shouldThrow();\r\n    } catch (IllegalMonitorStateException success) {\r\n    }\r\n    assertHasWaitersUnlocked(sync, c, NO_THREADS);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testNextComplete",
	"Comment": "firstcomplete.nextcomplete returns parent if pending count iszero else null",
	"Method": "void testNextComplete(){\r\n    NoopCC a = new NoopCC();\r\n    NoopCC b = new NoopCC(a);\r\n    a.setPendingCount(1);\r\n    b.setPendingCount(1);\r\n    assertNull(b.firstComplete());\r\n    assertSame(b, b.firstComplete());\r\n    assertNull(b.nextComplete());\r\n    a.checkIncomplete();\r\n    b.checkIncomplete();\r\n    assertSame(a, b.nextComplete());\r\n    assertSame(a, b.nextComplete());\r\n    a.checkIncomplete();\r\n    b.checkIncomplete();\r\n    assertNull(a.nextComplete());\r\n    b.checkIncomplete();\r\n    checkCompletedNormally(a);\r\n}"
}, {
	"Path": "java.util.concurrent.CopyOnWriteArraySet.retainAll",
	"Comment": "retains only the elements in this set that are contained in thespecified collection.in other words, removes from this set all ofits elements that are not contained in the specified collection.ifthe specified collection is also a set, this operation effectivelymodifies this set so that its value is the intersection of thetwo sets.",
	"Method": "boolean retainAll(Collection<?> c){\r\n    return al.retainAll(c);\r\n}"
}, {
	"Path": "java.net.Inet6Address.isSiteLocalAddress",
	"Comment": "utility routine to check if the inetaddress is a site local address.",
	"Method": "boolean isSiteLocalAddress(){\r\n    return ((ipaddress[0] & 0xff) == 0xfe && (ipaddress[1] & 0xc0) == 0xc0);\r\n}"
}, {
	"Path": "libcore.java.util.Base64Test.assertDecodeThrowsIAe",
	"Comment": "assert that decoding the specific string throws illegalargumentexception.",
	"Method": "void assertDecodeThrowsIAe(Decoder decoder,String invalidEncoded){\r\n    try {\r\n        decoder.decode(invalidEncoded);\r\n        fail(\"should have failed to decode\");\r\n    } catch (IllegalArgumentException e) {\r\n    }\r\n}"
}, {
	"Path": "sun.net.www.MessageHeader.add",
	"Comment": "adds a key value pair to the end of theheader.duplicates are allowed",
	"Method": "void add(String k,String v){\r\n    grow();\r\n    keys[nkeys] = k;\r\n    values[nkeys] = v;\r\n    nkeys++;\r\n}"
}, {
	"Path": "java.util.stream.AbstractTask.getParent",
	"Comment": "returns the parent of this task, or null if this task is the root",
	"Method": "K getParent(){\r\n    return (K) getCompleter();\r\n}"
}, {
	"Path": "java.io.BufferedInputStream.read1",
	"Comment": "read characters into a portion of an array, reading from the underlyingstream at most once if necessary.",
	"Method": "int read1(byte[] b,int off,int len){\r\n    int avail = count - pos;\r\n    if (avail <= 0) {\r\n        if (len >= getBufIfOpen().length && markpos < 0) {\r\n            return getInIfOpen().read(b, off, len);\r\n        }\r\n        fill();\r\n        avail = count - pos;\r\n        if (avail <= 0)\r\n            return -1;\r\n    }\r\n    int cnt = (avail < len) ? avail : len;\r\n    System.arraycopy(getBufIfOpen(), pos, b, off, cnt);\r\n    pos += cnt;\r\n    return cnt;\r\n}"
}, {
	"Path": "sun.security.x509.OtherName.subtreeDepth",
	"Comment": "return subtree depth of this name for purposes of determiningnameconstraints minimum and maximum bounds.",
	"Method": "int subtreeDepth(){\r\n    throw new UnsupportedOperationException(\"subtreeDepth() not supported for generic OtherName\");\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testShutdownNow",
	"Comment": "shutdownnow returns a list containing tasks that were not run,and those tasks are drained from the queue",
	"Method": "void testShutdownNow(){\r\n    final int poolSize = 2;\r\n    final int count = 5;\r\n    final AtomicInteger ran = new AtomicInteger(0);\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(poolSize, poolSize, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    final CountDownLatch threadsStarted = new CountDownLatch(poolSize);\r\n    Runnable waiter = new CheckedRunnable() {\r\n        public void realRun() {\r\n            threadsStarted.countDown();\r\n            try {\r\n                MILLISECONDS.sleep(2 * LONG_DELAY_MS);\r\n            } catch (InterruptedException success) {\r\n            }\r\n            ran.getAndIncrement();\r\n        }\r\n    };\r\n    for (int i = 0; i < count; i++) p.execute(waiter);\r\n    await(threadsStarted);\r\n    assertEquals(poolSize, p.getActiveCount());\r\n    assertEquals(0, p.getCompletedTaskCount());\r\n    final List<Runnable> queuedTasks;\r\n    try {\r\n        queuedTasks = p.shutdownNow();\r\n    } catch (SecurityException ok) {\r\n        return;\r\n    }\r\n    assertTrue(p.isShutdown());\r\n    assertTrue(p.getQueue().isEmpty());\r\n    assertEquals(count - poolSize, queuedTasks.size());\r\n    assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));\r\n    assertTrue(p.isTerminated());\r\n    assertEquals(poolSize, ran.get());\r\n    assertEquals(poolSize, p.getCompletedTaskCount());\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testShutdownNow",
	"Comment": "shutdownnow returns a list containing tasks that were not run,and those tasks are drained from the queue",
	"Method": "void testShutdownNow(){\r\n    threadsStarted.countDown();\r\n    try {\r\n        MILLISECONDS.sleep(2 * LONG_DELAY_MS);\r\n    } catch (InterruptedException success) {\r\n    }\r\n    ran.getAndIncrement();\r\n}"
}, {
	"Path": "java.net.Socks4Message.setIP",
	"Comment": "set the ip address. this expects an array of four bytes in host order.",
	"Method": "void setIP(byte[] ip){\r\n    buffer[INDEX_IP] = ip[0];\r\n    buffer[INDEX_IP + 1] = ip[1];\r\n    buffer[INDEX_IP + 2] = ip[2];\r\n    buffer[INDEX_IP + 3] = ip[3];\r\n}"
}, {
	"Path": "sun.security.x509.NameConstraintsExtension.verify",
	"Comment": "check whether a name conforms to these nameconstraints.this involves verifying that the name is consistent with thepermitted and excluded subtrees variables.",
	"Method": "boolean verify(X509Certificate cert,boolean verify,GeneralNameInterface name){\r\n    if (name == null) {\r\n        throw new IOException(\"name is null\");\r\n    }\r\n    if (excluded != null && excluded.size() > 0) {\r\n        for (int i = 0; i < excluded.size(); i++) {\r\n            GeneralSubtree gs = excluded.get(i);\r\n            if (gs == null)\r\n                continue;\r\n            GeneralName gn = gs.getName();\r\n            if (gn == null)\r\n                continue;\r\n            GeneralNameInterface exName = gn.getName();\r\n            if (exName == null)\r\n                continue;\r\n            switch(exName.constrains(name)) {\r\n                case GeneralNameInterface.NAME_DIFF_TYPE:\r\n                case GeneralNameInterface.NAME_WIDENS:\r\n                case GeneralNameInterface.NAME_SAME_TYPE:\r\n                    break;\r\n                case GeneralNameInterface.NAME_MATCH:\r\n                case GeneralNameInterface.NAME_NARROWS:\r\n                    return false;\r\n            }\r\n        }\r\n    }\r\n    if (permitted != null && permitted.size() > 0) {\r\n        boolean sameType = false;\r\n        for (int i = 0; i < permitted.size(); i++) {\r\n            GeneralSubtree gs = permitted.get(i);\r\n            if (gs == null)\r\n                continue;\r\n            GeneralName gn = gs.getName();\r\n            if (gn == null)\r\n                continue;\r\n            GeneralNameInterface perName = gn.getName();\r\n            if (perName == null)\r\n                continue;\r\n            switch(perName.constrains(name)) {\r\n                case GeneralNameInterface.NAME_DIFF_TYPE:\r\n                    continue;\r\n                case GeneralNameInterface.NAME_WIDENS:\r\n                case GeneralNameInterface.NAME_SAME_TYPE:\r\n                    sameType = true;\r\n                    continue;\r\n                case GeneralNameInterface.NAME_MATCH:\r\n                case GeneralNameInterface.NAME_NARROWS:\r\n                    return true;\r\n            }\r\n        }\r\n        if (sameType) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "java.io.BufferedReader.read1",
	"Comment": "reads characters into a portion of an array, reading from the underlyingstream if necessary.",
	"Method": "int read1(char[] cbuf,int off,int len){\r\n    if (nextChar >= nChars) {\r\n        if (len >= cb.length && markedChar <= UNMARKED && !skipLF) {\r\n            return in.read(cbuf, off, len);\r\n        }\r\n        fill();\r\n    }\r\n    if (nextChar >= nChars)\r\n        return -1;\r\n    if (skipLF) {\r\n        skipLF = false;\r\n        if (cb[nextChar] == '\\n') {\r\n            nextChar++;\r\n            if (nextChar >= nChars)\r\n                fill();\r\n            if (nextChar >= nChars)\r\n                return -1;\r\n        }\r\n    }\r\n    int n = Math.min(len, nChars - nextChar);\r\n    System.arraycopy(cb, nextChar, cbuf, off, n);\r\n    nextChar += n;\r\n    return n;\r\n}"
}, {
	"Path": "java.util.concurrent.PriorityBlockingQueue.put",
	"Comment": "inserts the specified element into this priority queue.as the queue is unbounded, this method will never block.",
	"Method": "void put(E e){\r\n    offer(e);\r\n}"
}, {
	"Path": "sun.security.x509.OIDMap.getClass",
	"Comment": "return the java class object associated with the object identifier.",
	"Method": "Class getClass(String name,Class getClass,ObjectIdentifier oid){\r\n    OIDInfo info = oidMap.get(oid);\r\n    return (info == null) ? null : info.getClazz();\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testListIterator2",
	"Comment": "listiterator only returns those elements after the given index",
	"Method": "void testListIterator2(){\r\n    CopyOnWriteArrayList full = populatedArray(3);\r\n    ListIterator i = full.listIterator(1);\r\n    int j;\r\n    for (j = 0; i.hasNext(); j++) assertEquals(j + 1, i.next());\r\n    assertEquals(2, j);\r\n}"
}, {
	"Path": "java.time.temporal.ValueRange.isValidValue",
	"Comment": "checks if the value is within the valid range.this checks that the value is within the stored range of values.",
	"Method": "boolean isValidValue(long value){\r\n    return (value >= getMinimum() && value <= getMaximum());\r\n}"
}, {
	"Path": "java.io.PipedWriter.close",
	"Comment": "closes this piped output stream and releases any system resourcesassociated with this stream. this stream may no longer be used forwriting characters.",
	"Method": "void close(){\r\n    closed = true;\r\n    if (sink != null) {\r\n        sink.receivedLast();\r\n    }\r\n}"
}, {
	"Path": "java.net.URLConnection.getRequestProperty",
	"Comment": "returns the value of the named general request property for thisconnection.",
	"Method": "String getRequestProperty(String key){\r\n    if (connected)\r\n        throw new IllegalStateException(\"Already connected\");\r\n    if (requests == null)\r\n        return null;\r\n    return requests.findValue(key);\r\n}"
}, {
	"Path": "java.nio.LongBuffer.equals",
	"Comment": "tells whether or not this buffer is equal to another object. two long buffers are equal if, and only if, they have the same element type, they have the same number of remaining elements, and the two sequences of remaining elements, consideredindependently of their starting positions, are pointwise equal. a long buffer is not equal to any other type of object.",
	"Method": "boolean equals(Object ob,boolean equals,long x,long y){\r\n    return x == y;\r\n}"
}, {
	"Path": "java.util.regex.Matcher.matches",
	"Comment": "attempts to match the entire region against the pattern. if the match succeeds then more information can be obtained via thestart, end, and group methods.",
	"Method": "boolean matches(){\r\n    matchFound = matchesImpl(address, matchOffsets);\r\n    return matchFound;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.SerializationStripper.visit",
	"Comment": "only modify serializable types when stripping reflection metadata.",
	"Method": "boolean visit(TypeDeclaration node,boolean visit,FieldDeclaration node,boolean visit,MethodDeclaration node){\r\n    if (isSerializationMethod(node.getExecutableElement())) {\r\n        node.remove();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.getIssuerX500Principal",
	"Comment": "get issuer name as x500principal. overrides implementation inx509certificate with a slightly more efficient version that isalso aware of x509certimpl mutability.",
	"Method": "X500Principal getIssuerX500Principal(X500Principal getIssuerX500Principal,X509Certificate cert){\r\n    try {\r\n        return getX500Principal(cert, true);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(\"Could not parse issuer\", e);\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testHasWaitersIMSE",
	"Comment": "haswaiters throws illegalmonitorstateexception if not synced",
	"Method": "void testHasWaitersIMSE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    try {\r\n        sync.hasWaiters(c);\r\n        shouldThrow();\r\n    } catch (IllegalMonitorStateException success) {\r\n    }\r\n    assertHasWaitersUnlocked(sync, c, NO_THREADS);\r\n}"
}, {
	"Path": "java.lang.ThreadGroup.getMaxPriority",
	"Comment": "returns the maximum priority of this thread group. threads that arepart of this group cannot have a higher priority than the maximumpriority.",
	"Method": "int getMaxPriority(){\r\n    return maxPriority;\r\n}"
}, {
	"Path": "libcore.java.text.NumberFormatTest.test_setCurrency",
	"Comment": "are not updated because decimalformat.setcurrency agrees not to change it.",
	"Method": "void test_setCurrency(){\r\n    NumberFormat nf = NumberFormat.getCurrencyInstance(Locale.US);\r\n    Currency amd = Currency.getInstance(\"AMD\");\r\n    assertEquals(0, amd.getDefaultFractionDigits());\r\n    nf.setCurrency(amd);\r\n    assertEquals(2, nf.getMinimumFractionDigits());\r\n    assertEquals(2, nf.getMaximumFractionDigits());\r\n    assertEquals(\"AMD50.00\", nf.format(50.00));\r\n    nf.setMaximumFractionDigits(amd.getDefaultFractionDigits());\r\n    assertEquals(\"AMD50\", nf.format(50.00));\r\n    nf = NumberFormat.getCurrencyInstance(Locale.US);\r\n    nf.setCurrency(Currency.getInstance(\"EUR\"));\r\n    assertEquals(\"?50.00\", nf.format(50.00));\r\n    nf.setCurrency(Currency.getInstance(\"JPY\"));\r\n    assertEquals(\"50.00\", nf.format(50.00));\r\n    nf.setCurrency(Currency.getInstance(\"CHF\"));\r\n    assertEquals(\"CHF50.00\", nf.format(50.00));\r\n}"
}, {
	"Path": "org.xml.sax.helpers.AttributeListImpl.clear",
	"Comment": "clear the attribute list.sax parser writers can use this method to reset the attributelist between documenthandler.startelement events.normally,it will make sense to reuse the same attributelistimpl objectrather than allocating a new one each time.",
	"Method": "void clear(){\r\n    names.clear();\r\n    types.clear();\r\n    values.clear();\r\n}"
}, {
	"Path": "sun.security.x509.X500Name.subtreeDepth",
	"Comment": "return subtree depth of this name for purposes of determiningnameconstraints minimum and maximum bounds and for calculatingpath lengths in name subtrees.",
	"Method": "int subtreeDepth(){\r\n    return names.length;\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.data_patternMonthNames",
	"Comment": "data provider for the 12 islamic month names in a formatted date",
	"Method": "Object[][] data_patternMonthNames(){\r\n    return new Object[][] { // the actual month name is Rabi Al-Awwal, but the locale data contains short form.\r\n    { 1434, 1, 1, \"01 AH Thu Muharram 1434\" }, { 1434, 2, 1, \"01 AH Fri Safar 1434\" }, { 1434, 3, 1, \"01 AH Sun Rabi? I 1434\" }, { 1434, 4, 1, \"01 AH Mon Rabi? II 1434\" }, { 1434, 5, 1, \"01 AH Wed Jumada I 1434\" }, { 1434, 6, 1, \"01 AH Thu Jumada II 1434\" }, { 1434, 7, 1, \"01 AH Sat Rajab 1434\" }, { 1434, 8, 1, \"01 AH Mon Sha?ban 1434\" }, { 1434, 9, 1, \"01 AH Tue Ramadan 1434\" }, { 1434, 10, 1, \"01 AH Thu Shawwal 1434\" }, { 1434, 11, 1, \"01 AH Sat Dhu?l-Qi?dah 1434\" }, { 1434, 12, 1, \"01 AH Sun Dhu?l-Hijjah 1434\" } };\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.lang.reflect.BoundedGenericMethodsTests.parameterType",
	"Comment": "tests whether the specified method declares a parameter with the type ofthe type parameter.",
	"Method": "void parameterType(Method method){\r\n    TypeVariable<Method> typeParameter = getTypeParameter(method);\r\n    assertLenghtOne(method.getGenericParameterTypes());\r\n    Type genericParameterType = method.getGenericParameterTypes()[0];\r\n    assertEquals(typeParameter, genericParameterType);\r\n    assertTrue(genericParameterType instanceof TypeVariable);\r\n    TypeVariable<?> typeVariable = (TypeVariable<?>) genericParameterType;\r\n    assertEquals(method, typeVariable.getGenericDeclaration());\r\n    Type[] paramBounds = typeVariable.getBounds();\r\n    assertLenghtOne(paramBounds);\r\n    Type paramBound = paramBounds[0];\r\n    assertEquals(BoundedGenericMethods.class, paramBound);\r\n}"
}, {
	"Path": "java.net.URLConnection.setDefaultAllowUserInteraction",
	"Comment": "sets the default value of theallowuserinteraction field for all futureurlconnection objects to the specified value.",
	"Method": "void setDefaultAllowUserInteraction(boolean defaultallowuserinteraction){\r\n    defaultAllowUserInteraction = defaultallowuserinteraction;\r\n}"
}, {
	"Path": "javax.crypto.CipherInputStream.close",
	"Comment": "closes this input stream and releases any system resourcesassociated with the stream.the close method of cipherinputstreamcalls the close method of its underlying inputstream.",
	"Method": "void close(){\r\n    input.close();\r\n    try {\r\n        cipher.doFinal();\r\n    } catch (BadPaddingException ex) {\r\n    } catch (IllegalBlockSizeException ex) {\r\n    }\r\n    ostart = 0;\r\n    ofinish = 0;\r\n}"
}, {
	"Path": "java.time.format.DateTimeTextProvider.getText",
	"Comment": "gets the text for the specified chrono, field, locale and stylefor the purpose of formatting.the text associated with the value is returned.the null return value should be used if there is no applicable text, orif the text would be a numeric representation of the value.",
	"Method": "String getText(TemporalField field,long value,TextStyle style,Locale locale,String getText,Chronology chrono,TemporalField field,long value,TextStyle style,Locale locale,String getText,long value,TextStyle style){\r\n    if (chrono == IsoChronology.INSTANCE || !(field instanceof ChronoField)) {\r\n        return getText(field, value, style, locale);\r\n    }\r\n    int fieldIndex;\r\n    int fieldValue;\r\n    if (field == ERA) {\r\n        fieldIndex = Calendar.ERA;\r\n        fieldValue = (int) value;\r\n    } else if (field == MONTH_OF_YEAR) {\r\n        fieldIndex = Calendar.MONTH;\r\n        fieldValue = (int) value - 1;\r\n    } else if (field == DAY_OF_WEEK) {\r\n        fieldIndex = Calendar.DAY_OF_WEEK;\r\n        fieldValue = (int) value + 1;\r\n        if (fieldValue > 7) {\r\n            fieldValue = Calendar.SUNDAY;\r\n        }\r\n    } else if (field == AMPM_OF_DAY) {\r\n        fieldIndex = Calendar.AM_PM;\r\n        fieldValue = (int) value;\r\n    } else {\r\n        return null;\r\n    }\r\n    return CalendarDataUtility.retrieveJavaTimeFieldValueName(chrono.getCalendarType(), fieldIndex, fieldValue, style.toCalendarStyle(), locale);\r\n}"
}, {
	"Path": "sun.security.x509.CRLNumberExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(NUMBER);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "org.xml.sax.helpers.ParserAdapter.getProperty",
	"Comment": "get a parser property.no properties are currently recognized.",
	"Method": "Object getProperty(String name){\r\n    throw new SAXNotRecognizedException(\"Property: \" + name);\r\n}"
}, {
	"Path": "java.security.cert.PKIXParameters.addCertStore",
	"Comment": "adds a certstore to the end of the list ofcertstores used in finding certificates and crls.",
	"Method": "void addCertStore(CertStore store){\r\n    if (store != null) {\r\n        this.certStores.add(store);\r\n    }\r\n}"
}, {
	"Path": "sun.misc.CharacterEncoder.encodeLineSuffix",
	"Comment": "encode the suffix that ends every output line. by defaultthis method just prints ainto the output stream.",
	"Method": "void encodeLineSuffix(OutputStream aStream){\r\n    pStream.println();\r\n}"
}, {
	"Path": "java.net.URLConnection.getAllowUserInteraction",
	"Comment": "returns the value of the allowuserinteraction field forthis object.",
	"Method": "boolean getAllowUserInteraction(){\r\n    return allowUserInteraction;\r\n}"
}, {
	"Path": "java.util.Calendar.isPartiallyNormalized",
	"Comment": "returns whether the calendar fields are partially in sync with the timevalue or fully in sync but not stamp values are not normalized yet.",
	"Method": "boolean isPartiallyNormalized(){\r\n    return areFieldsSet && !areAllFieldsSet;\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testSignal_IMSE",
	"Comment": "calling signal without holding sync throws illegalmonitorstateexception",
	"Method": "void testSignal_IMSE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    try {\r\n        c.signal();\r\n        shouldThrow();\r\n    } catch (IllegalMonitorStateException success) {\r\n    }\r\n    assertHasWaitersUnlocked(sync, c, NO_THREADS);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvoke(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingFibAction f = new FailingFibAction(8);\r\n            f.quietlyInvoke();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvoke(){\r\n    FailingFibAction f = new FailingFibAction(8);\r\n    f.quietlyInvoke();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceArrayTest.testConstructor",
	"Comment": "constructor creates array of given size with all elements null",
	"Method": "void testConstructor(){\r\n    AtomicReferenceArray<Integer> aa = new AtomicReferenceArray<Integer>(SIZE);\r\n    for (int i = 0; i < SIZE; i++) {\r\n        assertNull(aa.get(i));\r\n    }\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testAbnormalForkQuietlyJoin",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoin(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() {\r\n            FailingFibTask f = new FailingFibTask(8);\r\n            assertSame(f, f.fork());\r\n            f.quietlyJoin();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(mainPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testAbnormalForkQuietlyJoin",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoin(){\r\n    FailingFibTask f = new FailingFibTask(8);\r\n    assertSame(f, f.fork());\r\n    f.quietlyJoin();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n    return NoResult;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.GenerationTest.assertEqualSrcClassfile",
	"Comment": "compiles java source, as contained in a source file, and compares the generated objective cfrom the source and class files.",
	"Method": "void assertEqualSrcClassfile(String type,String source){\r\n    options.setEmitSourceHeaders(false);\r\n    String fileRoot = type.replace('.', '/');\r\n    CompilationUnit srcUnit = translateType(type, source);\r\n    String srcHeader = generateFromUnit(srcUnit, fileRoot + \".h\");\r\n    String srcImpl = getTranslatedFile(fileRoot + \".m\");\r\n    Options.OutputLanguageOption language = options.getLanguage();\r\n    options.setOutputLanguage(Options.OutputLanguageOption.TEST_OBJECTIVE_C);\r\n    CompilationUnit classfileUnit = compileAsClassFile(fileRoot, source);\r\n    TranslationProcessor.applyMutations(classfileUnit, deadCodeMap, options.externalAnnotations(), TimeTracker.noop());\r\n    String clsHeader = generateFromUnit(classfileUnit, fileRoot + \".h2\");\r\n    String clsImpl = getTranslatedFile(fileRoot + \".m2\");\r\n    options.setOutputLanguage(language);\r\n    if (!srcHeader.equals(clsHeader)) {\r\n        fail(\"source and classfile headers differ:\\n\" + diff(fileRoot + \".h\", fileRoot + \".h2\"));\r\n    }\r\n    if (!srcImpl.equals(clsImpl)) {\r\n        fail(\"source and classfile impls differ:\\n\" + diff(fileRoot + \".m\", fileRoot + \".m2\"));\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testBeforeAfter",
	"Comment": "beforeexecute and afterexecute are called when executing task",
	"Method": "void testBeforeAfter(){\r\n    CustomTPE p = new CustomTPE();\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        final CountDownLatch done = new CountDownLatch(1);\r\n        p.execute(new CheckedRunnable() {\r\n            public void realRun() {\r\n                done.countDown();\r\n            }\r\n        });\r\n        await(p.afterCalled);\r\n        assertEquals(0, done.getCount());\r\n        assertTrue(p.afterCalled());\r\n        assertTrue(p.beforeCalled());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testBeforeAfter",
	"Comment": "beforeexecute and afterexecute are called when executing task",
	"Method": "void testBeforeAfter(){\r\n    done.countDown();\r\n}"
}, {
	"Path": "java.io.BufferedReader.ready",
	"Comment": "tells whether this stream is ready to be read.a buffered characterstream is ready if the buffer is not empty, or if the underlyingcharacter stream is ready.",
	"Method": "boolean ready(){\r\n    synchronized (lock) {\r\n        ensureOpen();\r\n        if (skipLF) {\r\n            if (nextChar >= nChars && in.ready()) {\r\n                fill();\r\n            }\r\n            if (nextChar < nChars) {\r\n                if (cb[nextChar] == '\\n')\r\n                    nextChar++;\r\n                skipLF = false;\r\n            }\r\n        }\r\n        return (nextChar < nChars) || in.ready();\r\n    }\r\n}"
}, {
	"Path": "java.sql.Timestamp.equals",
	"Comment": "tests to see if this timestamp object isequal to the given timestamp object.",
	"Method": "boolean equals(Timestamp ts,boolean equals,java.lang.Object ts){\r\n    if (ts instanceof Timestamp) {\r\n        return this.equals((Timestamp) ts);\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.put",
	"Comment": "associates the specified value with the specified key in this identityhash map.if the map previously contained a mapping for the key, theold value is replaced.",
	"Method": "V put(K key,V value){\r\n    Object k = maskNull(key);\r\n    Object[] tab = table;\r\n    int len = tab.length;\r\n    int i = hash(k, len);\r\n    Object item;\r\n    while ((item = tab[i]) != null) {\r\n        if (item == k) {\r\n            @SuppressWarnings(\"unchecked\")\r\n            V oldValue = (V) tab[i + 1];\r\n            tab[i + 1] = value;\r\n            return oldValue;\r\n        }\r\n        i = nextKeyIndex(i, len);\r\n    }\r\n    modCount++;\r\n    tab[i] = k;\r\n    tab[i + 1] = value;\r\n    if (++size >= threshold)\r\n        resize(len);\r\n    return null;\r\n}"
}, {
	"Path": "java.util.Iterator.forEachRemaining",
	"Comment": "performs the given action for each remaining element until all elementshave been processed or the action throws an exception.actions areperformed in the order of iteration, if that order is specified.exceptions thrown by the action are relayed to the caller.",
	"Method": "void forEachRemaining(Consumer<? super E> action){\r\n    Objects.requireNonNull(action);\r\n    while (hasNext()) action.accept(next());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.StatementGeneratorTest.testFunctionReferencesStaticVariable",
	"Comment": "their accessors in functions, since their class may not have loaded.",
	"Method": "void testFunctionReferencesStaticVariable(){\r\n    String translation = translateSourceFile(\"public class HelloWorld {\" + \"  static String staticString = \\\"hello world\\\";\" + \"  public static void main(String[] args) {\" + \"    System.out.println(staticString);\" + \"  }}\", \"HelloWorld\", \"HelloWorld.m\");\r\n    assertTranslation(translation, \"printlnWithNSString:HelloWorld_staticString];\");\r\n}"
}, {
	"Path": "java.time.format.DecimalStyle.of",
	"Comment": "obtains the decimalstyle for the specified locale.this method provides access to locale sensitive decimal style symbols.",
	"Method": "DecimalStyle of(Locale locale){\r\n    Objects.requireNonNull(locale, \"locale\");\r\n    DecimalStyle info = CACHE.get(locale);\r\n    if (info == null) {\r\n        info = create(locale);\r\n        CACHE.putIfAbsent(locale, info);\r\n        info = CACHE.get(locale);\r\n    }\r\n    return info;\r\n}"
}, {
	"Path": "sun.security.x509.X500Name.asX500Principal",
	"Comment": "get an x500principal backed by this x500name.note that we are using privileged reflection to access the hiddenpackage private constructor in x500principal.",
	"Method": "X500Principal asX500Principal(){\r\n    if (x500Principal == null) {\r\n        try {\r\n            Object[] args = new Object[] { this };\r\n            x500Principal = (X500Principal) principalConstructor.newInstance(args);\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"Unexpected exception\", e);\r\n        }\r\n    }\r\n    return x500Principal;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.ClassFile.getMethod",
	"Comment": "returns the procyon method definition for a specified method,or null if not found.",
	"Method": "MethodDeclaration getMethod(String name,String signature){\r\n    for (EntityDeclaration node : type.getMembers()) {\r\n        if (node.getEntityType() == EntityType.METHOD) {\r\n            MethodDeclaration method = (MethodDeclaration) node;\r\n            if (method.getName().equals(name) && signature.equals(signature(method))) {\r\n                return method;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.GeneratedType.getSuperTypes",
	"Comment": "the list of type names that must be declared prior to this type because itinherits from them.",
	"Method": "List<String> getSuperTypes(){\r\n    return superTypes;\r\n}"
}, {
	"Path": "test.java.time.chrono.TestJapaneseChronoImpl.provider_rangeVersusCalendar",
	"Comment": "range of years to check consistency with java.util.calendar",
	"Method": "Object[][] provider_rangeVersusCalendar(){\r\n    return new Object[][] { { LocalDate.of(1873, 1, 1), LocalDate.of(2100, 1, 1) } };\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.text.DateFormatSymbolsTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    dfs = new DateFormatSymbols(new Locale(\"en\", \"us\"));\r\n}"
}, {
	"Path": "javax.net.ssl.SSLParameters.setWantClientAuth",
	"Comment": "sets whether client authentication should be requested. callingthis method clears the needclientauth flag.",
	"Method": "void setWantClientAuth(boolean wantClientAuth){\r\n    this.wantClientAuth = wantClientAuth;\r\n    this.needClientAuth = false;\r\n}"
}, {
	"Path": "sun.security.x509.OIDName.subtreeDepth",
	"Comment": "return subtree depth of this name for purposes of determiningnameconstraints minimum and maximum bounds and for calculatingpath lengths in name subtrees.",
	"Method": "int subtreeDepth(){\r\n    throw new UnsupportedOperationException(\"subtreeDepth() not supported for OIDName.\");\r\n}"
}, {
	"Path": "java.io.StringReader.reset",
	"Comment": "resets the stream to the most recent mark, or to the beginning of thestring if it has never been marked.",
	"Method": "void reset(){\r\n    synchronized (lock) {\r\n        ensureOpen();\r\n        next = mark;\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.CertificateFactory.getInstance",
	"Comment": "returns a certificate factory object for the specifiedcertificate type. a new certificatefactory object encapsulating thecertificatefactoryspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "CertificateFactory getInstance(String type,CertificateFactory getInstance,String type,String provider,CertificateFactory getInstance,String type,Provider provider){\r\n    try {\r\n        Instance instance = GetInstance.getInstance(\"CertificateFactory\", CertificateFactorySpi.class, type, provider);\r\n        return new CertificateFactory((CertificateFactorySpi) instance.impl, instance.provider, type);\r\n    } catch (NoSuchAlgorithmException e) {\r\n        throw new CertificateException(type + \" not found\", e);\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.X509CertPath.readAllBytes",
	"Comment": "reads the entire contents of an inputstream into a byte array.",
	"Method": "byte[] readAllBytes(InputStream is){\r\n    byte[] buffer = new byte[8192];\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream(2048);\r\n    int n;\r\n    while ((n = is.read(buffer)) != -1) {\r\n        baos.write(buffer, 0, n);\r\n    }\r\n    return baos.toByteArray();\r\n}"
}, {
	"Path": "java.util.concurrent.ScheduledThreadPoolExecutor.decorateTask",
	"Comment": "modifies or replaces the task used to execute a callable.this method can be used to override the concreteclass used for managing internal tasks.the default implementation simply returns the given task.",
	"Method": "RunnableScheduledFuture<V> decorateTask(Runnable runnable,RunnableScheduledFuture<V> task,RunnableScheduledFuture<V> decorateTask,Callable<V> callable,RunnableScheduledFuture<V> task){\r\n    return task;\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.toLong",
	"Comment": "convert this mutablebiginteger to a long value. the caller has to makesure this mutablebiginteger can be fit into long.",
	"Method": "long toLong(){\r\n    assert (intLen <= 2) : \"this MutableBigInteger exceeds the range of long\";\r\n    if (intLen == 0)\r\n        return 0;\r\n    long d = value[offset] & LONG_MASK;\r\n    return (intLen == 2) ? d << 32 | (value[offset + 1] & LONG_MASK) : d;\r\n}"
}, {
	"Path": "android.icu.dev.test.translit.TransliteratorTest.TestPositionHandling",
	"Comment": "confirm that the contextstart, contextlimit, start, and limitbehave correctly.",
	"Method": "void TestPositionHandling(){\r\n    String[] DATA = { \"a{t} > SS ; {t}b > UU ; {t} > TT ;\", // pos 2,9,3,8\r\n    \"xtat txtb\", // pos 2,9,3,8\r\n    \"xTTaSS TTxUUb\", \"a{t} > SS ; {t}b > UU ; {t} > TT ;\", // pos 3,8,3,8\r\n    \"xtat txtb\", // pos 3,8,3,8\r\n    \"xtaSS TTxUUb\", \"a{t} > SS ; {t}b > UU ; {t} > TT ;\", \"xtat txtb\", \"xtaTT TTxTTb\" };\r\n    int[] POS = { 0, 9, 0, 9, 2, 9, 3, 8, 3, 8, 3, 8 };\r\n    int n = DATA.length / 3;\r\n    for (int i = 0; i < n; i++) {\r\n        Transliterator t = Transliterator.createFromRules(\"<ID>\", DATA[3 * i], Transliterator.FORWARD);\r\n        Transliterator.Position pos = new Transliterator.Position(POS[4 * i], POS[4 * i + 1], POS[4 * i + 2], POS[4 * i + 3]);\r\n        ReplaceableString rsource = new ReplaceableString(DATA[3 * i + 1]);\r\n        t.transliterate(rsource, pos);\r\n        t.finishTransliteration(rsource, pos);\r\n        String result = rsource.toString();\r\n        String exp = DATA[3 * i + 2];\r\n        expectAux(Utility.escape(DATA[3 * i]), DATA[3 * i + 1], result, result.equals(exp), exp);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testGetCorePoolSize",
	"Comment": "getcorepoolsize returns size given in constructor if not otherwise set",
	"Method": "void testGetCorePoolSize(){\r\n    final ThreadPoolExecutor p = new CustomTPE(1, 1, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertEquals(1, p.getCorePoolSize());\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.luni.tests.java.util.AbstractListTest.test_remove",
	"Comment": "test remove for failure by inconsistency of modcount and expectedmodcount",
	"Method": "void test_remove(){\r\n    MockRemoveFailureArrayList<String> mrfal = new MockRemoveFailureArrayList<String>();\r\n    Iterator<String> imrfal = mrfal.iterator();\r\n    imrfal.next();\r\n    imrfal.remove();\r\n    try {\r\n        imrfal.remove();\r\n    } catch (ConcurrentModificationException e) {\r\n        fail(\"Excepted to catch IllegalStateException not ConcurrentModificationException\");\r\n    } catch (IllegalStateException e) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalInvokeSingleton",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvokeSingleton(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingAsyncFib f = new FailingAsyncFib(8);\r\n            try {\r\n                f.invoke();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalInvokeSingleton",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvokeSingleton(){\r\n    FailingAsyncFib f = new FailingAsyncFib(8);\r\n    try {\r\n        f.invoke();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testGetFirstQueuedThread",
	"Comment": "getfirstqueuedthread returns first waiting thread or null if none",
	"Method": "void testGetFirstQueuedThread(){\r\n    final Mutex sync = new Mutex();\r\n    assertNull(sync.getFirstQueuedThread());\r\n    sync.acquire();\r\n    Thread t1 = newStartedThread(new InterruptedSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t1);\r\n    assertEquals(t1, sync.getFirstQueuedThread());\r\n    Thread t2 = newStartedThread(new InterruptibleSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t2);\r\n    assertEquals(t1, sync.getFirstQueuedThread());\r\n    t1.interrupt();\r\n    awaitTermination(t1);\r\n    assertEquals(t2, sync.getFirstQueuedThread());\r\n    sync.release();\r\n    awaitTermination(t2);\r\n    assertNull(sync.getFirstQueuedThread());\r\n}"
}, {
	"Path": "java.text.DecimalFormat.formatToCharacterIterator",
	"Comment": "formats an object producing an attributedcharacteriterator.you can use the returned attributedcharacteriteratorto build the resulting string, as well as to determine informationabout the resulting string.each attribute key of the attributedcharacteriterator will be of typenumberformat.field, with the attribute value being thesame as the attribute key.",
	"Method": "AttributedCharacterIterator formatToCharacterIterator(Object obj){\r\n    CharacterIteratorFieldDelegate delegate = new CharacterIteratorFieldDelegate();\r\n    StringBuffer sb = new StringBuffer();\r\n    if (obj instanceof Double || obj instanceof Float) {\r\n        format(((Number) obj).doubleValue(), sb, delegate);\r\n    } else if (obj instanceof Long || obj instanceof Integer || obj instanceof Short || obj instanceof Byte || obj instanceof AtomicInteger || obj instanceof AtomicLong) {\r\n        format(((Number) obj).longValue(), sb, delegate);\r\n    } else if (obj instanceof BigDecimal) {\r\n        format((BigDecimal) obj, sb, delegate);\r\n    } else if (obj instanceof BigInteger) {\r\n        format((BigInteger) obj, sb, delegate, false);\r\n    } else if (obj == null) {\r\n        throw new NullPointerException(\"formatToCharacterIterator must be passed non-null object\");\r\n    } else {\r\n        throw new IllegalArgumentException(\"Cannot format given Object as a Number\");\r\n    }\r\n    return delegate.getIterator(sb.toString());\r\n}"
}, {
	"Path": "java.util.logging.Logger.isLoggable",
	"Comment": "check if a message of the given level would actually be loggedby this logger.this check is based on the loggers effective level,which may be inherited from its parent.",
	"Method": "boolean isLoggable(Level level){\r\n    if (level.intValue() < levelValue || levelValue == offValue) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "java.util.Locale.writeObject",
	"Comment": "serializes this locale to the specified objectoutputstream.",
	"Method": "void writeObject(ObjectOutputStream out){\r\n    ObjectOutputStream.PutField fields = out.putFields();\r\n    fields.put(\"language\", baseLocale.getLanguage());\r\n    fields.put(\"script\", baseLocale.getScript());\r\n    fields.put(\"country\", baseLocale.getRegion());\r\n    fields.put(\"variant\", baseLocale.getVariant());\r\n    fields.put(\"extensions\", localeExtensions == null ? \"\" : localeExtensions.getID());\r\n    fields.put(\"hashcode\", -1);\r\n    out.writeFields();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.GenerationTest.enableDebuggingSupport",
	"Comment": "enables both javac and j2objc gidebugging support in a test.",
	"Method": "void enableDebuggingSupport(){\r\n    javacFlags.add(\"-parameters\");\r\n    javacFlags.add(\"-g\");\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinTask.helpExpungeStaleExceptions",
	"Comment": "if lock is available, polls stale refs and removes them.called from forkjoinpool when pools become quiescent.",
	"Method": "void helpExpungeStaleExceptions(){\r\n    final ReentrantLock lock = exceptionTableLock;\r\n    if (lock.tryLock()) {\r\n        try {\r\n            expungeStaleExceptions();\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "javax.net.ssl.SSLParameters.getWantClientAuth",
	"Comment": "returns whether client authentication should be requested.",
	"Method": "boolean getWantClientAuth(){\r\n    return wantClientAuth;\r\n}"
}, {
	"Path": "java.net.DatagramPacket.getPort",
	"Comment": "returns the port number on the remote host to which this datagram isbeing sent or from which the datagram was received.",
	"Method": "int getPort(){\r\n    return port;\r\n}"
}, {
	"Path": "sun.security.x509.CertificateExtensions.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<Extension> getElements(){\r\n    return Collections.enumeration(map.values());\r\n}"
}, {
	"Path": "sun.security.x509.NetscapeCertTypeExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    return mAttributeNames.elements();\r\n}"
}, {
	"Path": "sun.security.x509.URIName.subtreeDepth",
	"Comment": "return subtree depth of this name for purposes of determiningnameconstraints minimum and maximum bounds and for calculatingpath lengths in name subtrees.",
	"Method": "int subtreeDepth(){\r\n    DNSName dnsName = null;\r\n    try {\r\n        dnsName = new DNSName(host);\r\n    } catch (IOException ioe) {\r\n        throw new UnsupportedOperationException(ioe.getMessage());\r\n    }\r\n    return dnsName.subtreeDepth();\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedLongSynchronizer.findNodeFromTail",
	"Comment": "returns true if node is on sync queue by searching backwards from tail.called only when needed by isonsyncqueue.",
	"Method": "boolean findNodeFromTail(Node node){\r\n    for (Node p = tail; ; ) {\r\n        if (p == node)\r\n            return true;\r\n        if (p == null)\r\n            return false;\r\n        p = p.prev;\r\n    }\r\n}"
}, {
	"Path": "sun.nio.ch.Net.anyInet4Address",
	"Comment": "returns any ipv4 address of the given network interface, ornull if the interface does not have any ipv4 addresses.",
	"Method": "Inet4Address anyInet4Address(NetworkInterface interf){\r\n    return AccessController.doPrivileged(new PrivilegedAction<Inet4Address>() {\r\n        public Inet4Address run() {\r\n            Enumeration<InetAddress> addrs = interf.getInetAddresses();\r\n            while (addrs.hasMoreElements()) {\r\n                InetAddress addr = addrs.nextElement();\r\n                if (addr instanceof Inet4Address) {\r\n                    return (Inet4Address) addr;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "sun.nio.ch.Net.anyInet4Address",
	"Comment": "returns any ipv4 address of the given network interface, ornull if the interface does not have any ipv4 addresses.",
	"Method": "Inet4Address anyInet4Address(NetworkInterface interf){\r\n    Enumeration<InetAddress> addrs = interf.getInetAddresses();\r\n    while (addrs.hasMoreElements()) {\r\n        InetAddress addr = addrs.nextElement();\r\n        if (addr instanceof Inet4Address) {\r\n            return (Inet4Address) addr;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "javax.xml.transform.dom.DOMResult.setSystemId",
	"Comment": "set the systemid that may be used in association with the node.",
	"Method": "void setSystemId(String systemId){\r\n    this.systemId = systemId;\r\n}"
}, {
	"Path": "java.util.Date.equals",
	"Comment": "compares two dates for equality.the result is true if and only if the argument isnot null and is a date object thatrepresents the same point in time, to the millisecond, as this object.thus, two date objects are equal if and only if thegettime method returns the same longvalue for both.",
	"Method": "boolean equals(Object obj){\r\n    return obj instanceof Date && getTime() == ((Date) obj).getTime();\r\n}"
}, {
	"Path": "javax.crypto.ExemptionMechanism.getInstance",
	"Comment": "returns an exemptionmechanism object that implements thespecified exemption mechanism algorithm. a new exemptionmechanism object encapsulating theexemptionmechanismspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "ExemptionMechanism getInstance(String algorithm,ExemptionMechanism getInstance,String algorithm,String provider,ExemptionMechanism getInstance,String algorithm,Provider provider){\r\n    Instance instance = JceSecurity.getInstance(\"ExemptionMechanism\", ExemptionMechanismSpi.class, algorithm, provider);\r\n    return new ExemptionMechanism((ExemptionMechanismSpi) instance.impl, instance.provider, algorithm);\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testFixedDelaySequence",
	"Comment": "schedulewithfixeddelay executes series of tasks with given period.eventually, it must hold that each task starts at least delay and atdelay after the termination of the previous task.",
	"Method": "void testFixedDelaySequence(){\r\n    final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        for (int delay = 1; delay <= LONG_DELAY_MS; delay *= 3) {\r\n            final long startTime = System.nanoTime();\r\n            final AtomicLong previous = new AtomicLong(startTime);\r\n            final AtomicBoolean tryLongerDelay = new AtomicBoolean(false);\r\n            final int cycles = 8;\r\n            final CountDownLatch done = new CountDownLatch(cycles);\r\n            final int d = delay;\r\n            final Runnable task = new CheckedRunnable() {\r\n                public void realRun() {\r\n                    long now = System.nanoTime();\r\n                    long elapsedMillis = NANOSECONDS.toMillis(now - previous.get());\r\n                    if (done.getCount() == cycles) {\r\n                        if (elapsedMillis >= d)\r\n                            tryLongerDelay.set(true);\r\n                    } else {\r\n                        assertTrue(elapsedMillis >= d);\r\n                        if (elapsedMillis >= 2 * d)\r\n                            tryLongerDelay.set(true);\r\n                    }\r\n                    previous.set(now);\r\n                    done.countDown();\r\n                }\r\n            };\r\n            final ScheduledFuture periodicTask = p.scheduleWithFixedDelay(task, 0, delay, MILLISECONDS);\r\n            final int totalDelayMillis = (cycles - 1) * delay;\r\n            await(done, totalDelayMillis + cycles * LONG_DELAY_MS);\r\n            periodicTask.cancel(true);\r\n            final long elapsedMillis = millisElapsedSince(startTime);\r\n            assertTrue(elapsedMillis >= totalDelayMillis);\r\n            if (!tryLongerDelay.get())\r\n                return;\r\n        }\r\n        fail(\"unexpected execution rate\");\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testFixedDelaySequence",
	"Comment": "schedulewithfixeddelay executes series of tasks with given period.eventually, it must hold that each task starts at least delay and atdelay after the termination of the previous task.",
	"Method": "void testFixedDelaySequence(){\r\n    long now = System.nanoTime();\r\n    long elapsedMillis = NANOSECONDS.toMillis(now - previous.get());\r\n    if (done.getCount() == cycles) {\r\n        if (elapsedMillis >= d)\r\n            tryLongerDelay.set(true);\r\n    } else {\r\n        assertTrue(elapsedMillis >= d);\r\n        if (elapsedMillis >= 2 * d)\r\n            tryLongerDelay.set(true);\r\n    }\r\n    previous.set(now);\r\n    done.countDown();\r\n}"
}, {
	"Path": "jsr166.AtomicLongTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    final AtomicLong ai = new AtomicLong(1);\r\n    Thread t = new Thread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!ai.compareAndSet(2, 3)) Thread.yield();\r\n        }\r\n    });\r\n    t.start();\r\n    assertTrue(ai.compareAndSet(1, 2));\r\n    t.join(LONG_DELAY_MS);\r\n    assertFalse(t.isAlive());\r\n    assertEquals(3, ai.get());\r\n}"
}, {
	"Path": "jsr166.AtomicLongTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    while (!ai.compareAndSet(2, 3)) Thread.yield();\r\n}"
}, {
	"Path": "sun.security.util.Debug.marshal",
	"Comment": "change a string into lower case except permission classes and urls.",
	"Method": "String marshal(String args){\r\n    if (args != null) {\r\n        StringBuffer target = new StringBuffer();\r\n        StringBuffer source = new StringBuffer(args);\r\n        String keyReg = \"[Pp][Ee][Rr][Mm][Ii][Ss][Ss][Ii][Oo][Nn]=\";\r\n        String keyStr = \"permission=\";\r\n        String reg = keyReg + \"[a-zA-Z_$][a-zA-Z0-9_$]*([.][a-zA-Z_$][a-zA-Z0-9_$]*)*\";\r\n        Pattern pattern = Pattern.compile(reg);\r\n        Matcher matcher = pattern.matcher(source);\r\n        StringBuffer left = new StringBuffer();\r\n        while (matcher.find()) {\r\n            String matched = matcher.group();\r\n            target.append(matched.replaceFirst(keyReg, keyStr));\r\n            target.append(\"  \");\r\n            matcher.appendReplacement(left, \"\");\r\n        }\r\n        matcher.appendTail(left);\r\n        source = left;\r\n        keyReg = \"[Cc][Oo][Dd][Ee][Bb][Aa][Ss][Ee]=\";\r\n        keyStr = \"codebase=\";\r\n        reg = keyReg + \"[^, ;]*\";\r\n        pattern = Pattern.compile(reg);\r\n        matcher = pattern.matcher(source);\r\n        left = new StringBuffer();\r\n        while (matcher.find()) {\r\n            String matched = matcher.group();\r\n            target.append(matched.replaceFirst(keyReg, keyStr));\r\n            target.append(\"  \");\r\n            matcher.appendReplacement(left, \"\");\r\n        }\r\n        matcher.appendTail(left);\r\n        source = left;\r\n        target.append(source.toString().toLowerCase(Locale.ENGLISH));\r\n        return target.toString();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberRegressionTests.Test4069754",
	"Comment": "bugs 4069754, 4067878null pointer thrown when accessing a deserialized decimalformatobject.",
	"Method": "void Test4069754(){\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n    myformat it = new myformat();\r\n    logln(it.Now());\r\n    oos.writeObject(it);\r\n    oos.flush();\r\n    baos.close();\r\n    logln(\"Save OK!\");\r\n    byte[] bytes = baos.toByteArray();\r\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));\r\n    myformat o = (myformat) ois.readObject();\r\n    ois.close();\r\n    it.Now();\r\n    logln(\"Load OK!\");\r\n    if (!o._dateFormat.equals(it._dateFormat)) {\r\n        throw new Exception(\"The saved and loaded object are not equals!\");\r\n    }\r\n    logln(\"Compare OK!\");\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testNewSingleThreadExecutor3",
	"Comment": "a new singlethreadexecutor with null threadfactory throws npe",
	"Method": "void testNewSingleThreadExecutor3(){\r\n    try {\r\n        ExecutorService e = Executors.newSingleThreadExecutor(null);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testNewSingleThreadExecutor2",
	"Comment": "a new singlethreadexecutor with given threadfactory can execute runnables",
	"Method": "void testNewSingleThreadExecutor2(){\r\n    final ExecutorService e = Executors.newSingleThreadExecutor(new SimpleThreadFactory());\r\n    try (PoolCleaner cleaner = cleaner(e)) {\r\n        e.execute(new NoOpRunnable());\r\n        e.execute(new NoOpRunnable());\r\n        e.execute(new NoOpRunnable());\r\n    }\r\n}"
}, {
	"Path": "java.beans.ChangeListenerMap.add",
	"Comment": "adds a listener to the list of listeners for the specified property.this listener is called as many times as it was added.",
	"Method": "void add(String name,L listener){\r\n    if (this.map == null) {\r\n        this.map = new HashMap<String, L[]>();\r\n    }\r\n    L[] array = this.map.get(name);\r\n    int size = (array != null) ? array.length : 0;\r\n    L[] clone = newArray(size + 1);\r\n    clone[size] = listener;\r\n    if (array != null) {\r\n        System.arraycopy(array, 0, clone, 0, size);\r\n    }\r\n    this.map.put(name, clone);\r\n}"
}, {
	"Path": "java.time.zone.ZoneOffsetTransition.isValidOffset",
	"Comment": "checks if the specified offset is valid during this transition.this checks to see if the given offset will be valid at some point in the transition.a gap will always return false.an overlap will return true if the offset is either the before or after offset.",
	"Method": "boolean isValidOffset(ZoneOffset offset){\r\n    return isGap() ? false : (getOffsetBefore().equals(offset) || getOffsetAfter().equals(offset));\r\n}"
}, {
	"Path": "java.util.Collections.singletonList",
	"Comment": "returns an immutable list containing only the specified object.the returned list is serializable.",
	"Method": "List<E> singletonList(E o){\r\n    return new SingletonList(o);\r\n}"
}, {
	"Path": "java.util.LinkedHashMap.clear",
	"Comment": "removes all of the mappings from this map.the map will be empty after this call returns.",
	"Method": "void clear(){\r\n    super.clear();\r\n    header.before = header.after = header;\r\n}"
}, {
	"Path": "sun.security.util.DerIndefLenConverter.isIndefinite",
	"Comment": "checks whether the given length byte is of the formindefinite.",
	"Method": "boolean isIndefinite(int lengthByte){\r\n    return (isLongForm(lengthByte) && ((lengthByte & LEN_MASK) == 0));\r\n}"
}, {
	"Path": "java.io.SequenceInputStream.close",
	"Comment": "closes this input stream and releases any system resourcesassociated with the stream.a closed sequenceinputstreamcannotperform input operations and cannotbe reopened.if this stream was createdfrom an enumeration, all remaining elementsare requested from the enumeration and closedbefore the close method returns.",
	"Method": "void close(){\r\n    do {\r\n        nextStream();\r\n    } while (in != null);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testForkHelpQuiesce",
	"Comment": "helpquiesce returns when tasks are complete.getqueuedtaskcount returns 0 when quiescent",
	"Method": "void testForkHelpQuiesce(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            CCF f = new LCCF(8);\r\n            assertSame(f, f.fork());\r\n            helpQuiesce();\r\n            assertEquals(21, f.number);\r\n            assertEquals(0, getQueuedTaskCount());\r\n            checkCompletedNormally(f);\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testForkHelpQuiesce",
	"Comment": "helpquiesce returns when tasks are complete.getqueuedtaskcount returns 0 when quiescent",
	"Method": "void testForkHelpQuiesce(){\r\n    CCF f = new LCCF(8);\r\n    assertSame(f, f.fork());\r\n    helpQuiesce();\r\n    assertEquals(21, f.number);\r\n    assertEquals(0, getQueuedTaskCount());\r\n    checkCompletedNormally(f);\r\n}"
}, {
	"Path": "javax.net.ssl.SSLParameters.getProtocols",
	"Comment": "returns a copy of the array of protocols or null if nonehave been set.",
	"Method": "String[] getProtocols(){\r\n    return clone(protocols);\r\n}"
}, {
	"Path": "libcore.java.text.DecimalFormatTest.testBug71369",
	"Comment": "confirm the fraction digits do not change when the currency is changed.",
	"Method": "void testBug71369(){\r\n    final String nonBreakingSpace = \"?\";\r\n    NumberFormat numberFormat = NumberFormat.getCurrencyInstance(Locale.GERMAN);\r\n    numberFormat.setCurrency(Currency.getInstance(\"USD\"));\r\n    assertEquals(\"2,01\" + nonBreakingSpace + \"$\", numberFormat.format(2.01));\r\n    numberFormat.setMinimumFractionDigits(0);\r\n    numberFormat.setMaximumFractionDigits(0);\r\n    String expected = \"2\" + nonBreakingSpace + \"$\";\r\n    assertEquals(expected, numberFormat.format(2.01));\r\n    numberFormat.setCurrency(Currency.getInstance(\"EUR\"));\r\n    numberFormat.setCurrency(Currency.getInstance(\"USD\"));\r\n    assertEquals(expected, numberFormat.format(2.01));\r\n}"
}, {
	"Path": "java.util.Calendar.getInstance",
	"Comment": "gets a calendar with the specified time zone and locale.the calendar returned is based on the current timein the given time zone with the given locale.",
	"Method": "Calendar getInstance(Calendar getInstance,TimeZone zone,Calendar getInstance,Locale aLocale,Calendar getInstance,TimeZone zone,Locale aLocale){\r\n    return createCalendar(zone, aLocale);\r\n}"
}, {
	"Path": "java.security.KeyStoreSpi.engineEntryInstanceOf",
	"Comment": "determines if the keystore entry for the specifiedalias is an instance or subclass of the specifiedentryclass.",
	"Method": "boolean engineEntryInstanceOf(String alias,Class<? extends KeyStore.Entry> entryClass){\r\n    if (entryClass == KeyStore.TrustedCertificateEntry.class) {\r\n        return engineIsCertificateEntry(alias);\r\n    }\r\n    if (entryClass == KeyStore.PrivateKeyEntry.class) {\r\n        return engineIsKeyEntry(alias) && engineGetCertificate(alias) != null;\r\n    }\r\n    if (entryClass == KeyStore.SecretKeyEntry.class) {\r\n        return engineIsKeyEntry(alias) && engineGetCertificate(alias) == null;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.Vector.get",
	"Comment": "returns the element at the specified position in this vector.",
	"Method": "E get(int index){\r\n    if (index >= elementCount)\r\n        throw new ArrayIndexOutOfBoundsException(index);\r\n    return elementData(index);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.ObjectiveCSourceFileGeneratorTest.testExistingStaticReaderDetected",
	"Comment": "verify that a static reader method is not added to a class that alreadyhas one.",
	"Method": "void testExistingStaticReaderDetected(){\r\n    String translation = translateSourceFile(\"class Test { private static int foo; public static int foo() { return foo; }}\", \"Test\", \"Test.h\");\r\n    assertOccurrences(translation, \"+ (jint)foo;\", 1);\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testIntUpdateAndGet",
	"Comment": "atomicinteger updateandget updates with supplied function andreturns result.",
	"Method": "void testIntUpdateAndGet(){\r\n    AtomicInteger a = new AtomicInteger(1);\r\n    assertEquals(18, a.updateAndGet(Atomic8Test::addInt17));\r\n    assertEquals(35, a.updateAndGet(Atomic8Test::addInt17));\r\n    assertEquals(35, a.get());\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceValuesToInt",
	"Comment": "returns the result of accumulating the given transformationof all values using the given reducer to combine values,and the given basis as an identity value.",
	"Method": "int reduceValuesToInt(long parallelismThreshold,ToIntFunction<? super V> transformer,int basis,IntBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceValuesToIntTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.javac.ClassFileConverter.setClassPath",
	"Comment": "set classpath to the root path of the input file, to support typeelement lookup.",
	"Method": "void setClassPath(){\r\n    String fullPath = file.getAbsolutePath();\r\n    String rootPath = fullPath.substring(0, fullPath.lastIndexOf(classFile.getRelativePath()));\r\n    List<File> classPath = new ArrayList();\r\n    classPath.add(new File(rootPath));\r\n    parserEnv.fileManager().setLocation(StandardLocation.CLASS_PATH, classPath);\r\n}"
}, {
	"Path": "java.text.MessageFormat.append",
	"Comment": "convenience method to append all the characters initerator to the stringbuffer result.",
	"Method": "void append(StringBuffer result,CharacterIterator iterator){\r\n    if (iterator.first() != CharacterIterator.DONE) {\r\n        char aChar;\r\n        result.append(iterator.first());\r\n        while ((aChar = iterator.next()) != CharacterIterator.DONE) {\r\n            result.append(aChar);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.security.spec.ECFieldF2m.getFieldSize",
	"Comment": "returns the field size in bits which is mfor this characteristic 2 finite field.",
	"Method": "int getFieldSize(){\r\n    return m;\r\n}"
}, {
	"Path": "java.time.format.DecimalStyle.withNegativeSign",
	"Comment": "returns a copy of the info with a new character that represents the negative sign.the character used to represent a negative number may vary by culture.this method specifies the character to use.",
	"Method": "DecimalStyle withNegativeSign(char negativeSign){\r\n    if (negativeSign == this.negativeSign) {\r\n        return this;\r\n    }\r\n    return new DecimalStyle(zeroDigit, positiveSign, negativeSign, decimalSeparator);\r\n}"
}, {
	"Path": "java.util.HashMap.containsKey",
	"Comment": "returns true if this map contains a mapping for thespecified key.",
	"Method": "boolean containsKey(Object key){\r\n    return getEntry(key) != null;\r\n}"
}, {
	"Path": "java.util.zip.InflaterOutputStream.finish",
	"Comment": "finishes writing uncompressed data to the output stream without closingthe underlying stream.use this method when applying multiple filters insuccession to the same output stream.",
	"Method": "void finish(){\r\n    ensureOpen();\r\n    flush();\r\n    if (usesDefaultInflater) {\r\n        inf.end();\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.BasicChecker.updateState",
	"Comment": "internal method to manage state information at each iteration",
	"Method": "void updateState(X509Certificate currCert){\r\n    PublicKey cKey = currCert.getPublicKey();\r\n    if (debug != null) {\r\n        debug.println(\"BasicChecker.updateState issuer: \" + currCert.getIssuerX500Principal().toString() + \"; subject: \" + currCert.getSubjectX500Principal() + \"; serial#: \" + currCert.getSerialNumber().toString());\r\n    }\r\n    if (PKIX.isDSAPublicKeyWithoutParams(cKey)) {\r\n        cKey = makeInheritedParamsKey(cKey, prevPubKey);\r\n        if (debug != null)\r\n            debug.println(\"BasicChecker.updateState Made \" + \"key with inherited params\");\r\n    }\r\n    prevPubKey = cKey;\r\n    prevSubject = currCert.getSubjectX500Principal();\r\n}"
}, {
	"Path": "android.icu.dev.test.format.RbnfLenientScannerTest.TestDefaultProvider",
	"Comment": "ensure that the default provider is instantiated and used if none is setand lenient parse is on.",
	"Method": "void TestDefaultProvider(){\r\n    RuleBasedNumberFormat formatter = new RuleBasedNumberFormat(Locale.US, RuleBasedNumberFormat.SPELLOUT);\r\n    formatter.setLenientScannerProvider(null);\r\n    formatter.setLenientParseMode(true);\r\n    String[][] lpTestData = { { \"2 thousand six HUNDRED   fifty-7\", \"2,657\" } };\r\n    doLenientParseTest(formatter, lpTestData);\r\n}"
}, {
	"Path": "java.time.zone.ZoneOffsetTransition.compareTo",
	"Comment": "compares this transition to another based on the transition instant.this compares the instants of each transition.the offsets are ignored, making this order inconsistent with equals.",
	"Method": "int compareTo(ZoneOffsetTransition transition){\r\n    return this.getInstant().compareTo(transition.getInstant());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.JavaToIOSMethodTranslatorTest.testHugeBuilderExpression",
	"Comment": "the test below would have taken about 100 days to run before this was fixed.",
	"Method": "void testHugeBuilderExpression(){\r\n    translateSourceFile(\"public class Example { \" + \"  static class Builder { \" + \"    Example build() { return new Example(); } \" + \"    Builder add(int i) { return this; } \" + \"  } \" + \"  static Example create() { \" + \"    return new Builder()\" + \"      .add(10).add(11).add(12).add(13).add(14).add(15).add(16).add(17).add(18).add(19)\" + \"      .add(20).add(21).add(22).add(23).add(24).add(25).add(26).add(27).add(28).add(29)\" + \"      .add(30).add(31).add(32).add(33).add(34).add(35).add(36).add(37).add(38).add(39)\" + \"      .add(40).add(41).add(42).add(43).add(44).add(45).add(46).add(47).add(48).add(49)\" + \"      .build(); \" + \"} }\", \"Example\", \"Example.m\");\r\n}"
}, {
	"Path": "java.lang.ref.ReferenceQueue.enqueueLocked",
	"Comment": "enqueue the given reference onto this queue.the caller is responsible for ensuring the lock is held on this queue,and for calling notifyall on this queue after the reference has beenenqueued. returns true if the reference was enqueued successfully,false if the reference had already been enqueued.",
	"Method": "boolean enqueueLocked(Reference<? extends T> r){\r\n    if (r.queueNext != null) {\r\n        return false;\r\n    }\r\n    if (tail == null) {\r\n        head = r;\r\n    } else {\r\n        tail.queueNext = r;\r\n    }\r\n    tail = r;\r\n    tail.queueNext = SENTINEL;\r\n    return true;\r\n}"
}, {
	"Path": "java.security.KeyStore.setCertificateEntry",
	"Comment": "assigns the given trusted certificate to the given alias. if the given alias identifies an existing entrycreated by a call to setcertificateentry,or created by a call to setentry with atrustedcertificateentry,the trusted certificate in the existing entryis overridden by the given certificate.",
	"Method": "void setCertificateEntry(String alias,Certificate cert){\r\n    if (!initialized) {\r\n        throw new KeyStoreException(\"Uninitialized keystore\");\r\n    }\r\n    keyStoreSpi.engineSetCertificateEntry(alias, cert);\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.getEncodedInternal",
	"Comment": "returned the encoding as an uncloned byte array. callers mustguarantee that they neither modify it nor expose it to untrustedcode.",
	"Method": "byte[] getEncodedInternal(byte[] getEncodedInternal,Certificate cert){\r\n    if (cert instanceof X509CertImpl) {\r\n        return ((X509CertImpl) cert).getEncodedInternal();\r\n    } else {\r\n        return cert.getEncoded();\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testSchedule3_RejectedExecutionException",
	"Comment": "schedule callable throws rejectedexecutionexception if shutdown",
	"Method": "void testSchedule3_RejectedExecutionException(){\r\n    final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        try {\r\n            p.shutdown();\r\n            p.schedule(new NoOpCallable(), MEDIUM_DELAY_MS, MILLISECONDS);\r\n            shouldThrow();\r\n        } catch (RejectedExecutionException success) {\r\n        } catch (SecurityException ok) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.computeIfPresent",
	"Comment": "if the value for the specified key is present, attempts tocompute a new mapping given the key and its current mappedvalue.the entire method invocation is performed atomically.some attempted update operations on this map by other threadsmay be blocked while computation is in progress, so thecomputation should be short and simple, and must not attempt toupdate any other mappings of this map.",
	"Method": "V computeIfPresent(K key,BiFunction<? super K, ? super V, ? extends V> remappingFunction){\r\n    if (key == null || remappingFunction == null)\r\n        throw new NullPointerException();\r\n    int h = spread(key.hashCode());\r\n    V val = null;\r\n    int delta = 0;\r\n    int binCount = 0;\r\n    for (Node<K, V>[] tab = table; ; ) {\r\n        Node<K, V> f;\r\n        int n, i, fh;\r\n        if (tab == null || (n = tab.length) == 0)\r\n            tab = initTable();\r\n        else if ((f = tabAt(tab, i = (n - 1) & h)) == null)\r\n            break;\r\n        else if ((fh = f.hash) == MOVED)\r\n            tab = helpTransfer(tab, f);\r\n        else {\r\n            synchronized (f) {\r\n                if (tabAt(tab, i) == f) {\r\n                    if (fh >= 0) {\r\n                        binCount = 1;\r\n                        for (Node<K, V> e = f, pred = null; ; ++binCount) {\r\n                            K ek;\r\n                            if (e.hash == h && ((ek = e.key) == key || (ek != null && key.equals(ek)))) {\r\n                                val = remappingFunction.apply(key, e.val);\r\n                                if (val != null)\r\n                                    e.val = val;\r\n                                else {\r\n                                    delta = -1;\r\n                                    Node<K, V> en = e.next;\r\n                                    if (pred != null)\r\n                                        pred.next = en;\r\n                                    else\r\n                                        setTabAt(tab, i, en);\r\n                                }\r\n                                break;\r\n                            }\r\n                            pred = e;\r\n                            if ((e = e.next) == null)\r\n                                break;\r\n                        }\r\n                    } else if (f instanceof TreeBin) {\r\n                        binCount = 2;\r\n                        TreeBin<K, V> t = (TreeBin<K, V>) f;\r\n                        TreeNode<K, V> r, p;\r\n                        if ((r = t.root) != null && (p = r.findTreeNode(h, key, null)) != null) {\r\n                            val = remappingFunction.apply(key, p.val);\r\n                            if (val != null)\r\n                                p.val = val;\r\n                            else {\r\n                                delta = -1;\r\n                                if (t.removeTreeNode(p))\r\n                                    setTabAt(tab, i, untreeify(t.first));\r\n                            }\r\n                        }\r\n                    } else if (f instanceof ReservationNode)\r\n                        throw new IllegalStateException(\"Recursive update\");\r\n                }\r\n            }\r\n            if (binCount != 0)\r\n                break;\r\n        }\r\n    }\r\n    if (delta != 0)\r\n        addCount((long) delta, binCount);\r\n    return val;\r\n}"
}, {
	"Path": "java.net.URI.getRawQuery",
	"Comment": "returns the raw query component of this uri. the query component of a uri, if defined, only contains legal uricharacters.",
	"Method": "String getRawQuery(){\r\n    return query;\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testGetWaitingThreadsIAE",
	"Comment": "getwaitingthreads throws illegalargumentexception if not owned",
	"Method": "void testGetWaitingThreadsIAE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    final Mutex sync2 = new Mutex();\r\n    try {\r\n        sync2.getWaitingThreads(c);\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n    assertHasWaitersUnlocked(sync, c, NO_THREADS);\r\n}"
}, {
	"Path": "java.util.concurrent.PriorityBlockingQueue.siftDownComparable",
	"Comment": "inserts item x at position k, maintaining heap invariant bydemoting x down the tree repeatedly until it is less than orequal to its children or is a leaf.",
	"Method": "void siftDownComparable(int k,T x,Object[] array,int n){\r\n    if (n > 0) {\r\n        Comparable<? super T> key = (Comparable<? super T>) x;\r\n        int half = n >>> 1;\r\n        while (k < half) {\r\n            int child = (k << 1) + 1;\r\n            Object c = array[child];\r\n            int right = child + 1;\r\n            if (right < n && ((Comparable<? super T>) c).compareTo((T) array[right]) > 0)\r\n                c = array[child = right];\r\n            if (key.compareTo((T) c) <= 0)\r\n                break;\r\n            array[k] = c;\r\n            k = child;\r\n        }\r\n        array[k] = key;\r\n    }\r\n}"
}, {
	"Path": "java.time.LocalDate.lengthOfYear",
	"Comment": "returns the length of the year represented by this date.this returns the length of the year in days, either 365 or 366.",
	"Method": "int lengthOfYear(){\r\n    return (isLeapYear() ? 366 : 365);\r\n}"
}, {
	"Path": "sun.security.util.DerInputBuffer.getUTCTime",
	"Comment": "returns the utc time value that takes up the specified numberof bytes in this buffer.",
	"Method": "Date getUTCTime(int len){\r\n    if (len > available())\r\n        throw new IOException(\"short read of DER UTC Time\");\r\n    if (len < 11 || len > 17)\r\n        throw new IOException(\"DER UTC Time length error\");\r\n    return getTime(len, false);\r\n}"
}, {
	"Path": "java.util.stream.DoubleStream.concat",
	"Comment": "creates a lazily concatenated stream whose elements are all theelements of the first stream followed by all the elements of thesecond stream.the resulting stream is ordered if bothof the input streams are ordered, and parallel if either of the inputstreams is parallel.when the resulting stream is closed, the closehandlers for both input streams are invoked.",
	"Method": "DoubleStream concat(DoubleStream a,DoubleStream b){\r\n    Objects.requireNonNull(a);\r\n    Objects.requireNonNull(b);\r\n    Spliterator.OfDouble split = new Streams.ConcatSpliterator.OfDouble(a.spliterator(), b.spliterator());\r\n    DoubleStream stream = StreamSupport.doubleStream(split, a.isParallel() || b.isParallel());\r\n    return stream.onClose(Streams.composedClose(a, b));\r\n}"
}, {
	"Path": "javax.crypto.Cipher.getInstance",
	"Comment": "returns a cipher object that implements the specifiedtransformation. a new cipher object encapsulating thecipherspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "Cipher getInstance(String transformation,Cipher getInstance,String transformation,String provider,Cipher getInstance,String transformation,Provider provider){\r\n    if (provider == null) {\r\n        throw new IllegalArgumentException(\"Missing provider\");\r\n    }\r\n    return createCipher(transformation, provider);\r\n}"
}, {
	"Path": "java.util.logging.Handler.setLevel",
	"Comment": "set the log level specifying which message levels will belogged by this handler.message levels lower than thisvalue will be discarded.the intention is to allow developers to turn on voluminouslogging, but to limit the messages that are sent to certainhandlers.",
	"Method": "void setLevel(Level newLevel){\r\n    if (newLevel == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    checkPermission();\r\n    logLevel = newLevel;\r\n}"
}, {
	"Path": "java.text.MessageFormat.setFormatByArgumentIndex",
	"Comment": "sets the format to use for the format elements within thepreviously set pattern string that use the given argumentindex.the argument index is part of the format element definition andrepresents an index into the arguments array passedto the format methods or the result array returnedby the parse methods.if the argument index is used for more than one format elementin the pattern string, then the new format is used for all suchformat elements. if the argument index is not used for any formatelement in the pattern string, then the new format is ignored.",
	"Method": "void setFormatByArgumentIndex(int argumentIndex,Format newFormat){\r\n    for (int j = 0; j <= maxOffset; j++) {\r\n        if (argumentNumbers[j] == argumentIndex) {\r\n            formats[j] = newFormat;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testSetThreadFactory",
	"Comment": "setthreadfactory sets the thread factory returned by getthreadfactory",
	"Method": "void testSetThreadFactory(){\r\n    final ThreadFactory threadFactory = new SimpleThreadFactory();\r\n    final CustomExecutor p = new CustomExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        p.setThreadFactory(threadFactory);\r\n        assertSame(threadFactory, p.getThreadFactory());\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingQueueTest.testAddAll5",
	"Comment": "queue contains all elements, in traversal order, of successful addall",
	"Method": "void testAddAll5(){\r\n    Integer[] empty = new Integer[0];\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = new Integer(i);\r\n    LinkedBlockingQueue q = new LinkedBlockingQueue(SIZE);\r\n    assertFalse(q.addAll(Arrays.asList(empty)));\r\n    assertTrue(q.addAll(Arrays.asList(ints)));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "java.util.concurrent.locks.ReentrantReadWriteLock.getWaitQueueLength",
	"Comment": "returns an estimate of the number of threads waiting on thegiven condition associated with the write lock. note that becausetimeouts and interrupts may occur at any time, the estimateserves only as an upper bound on the actual number of waiters.this method is designed for use in monitoring of the systemstate, not for synchronization control.",
	"Method": "int getWaitQueueLength(Condition condition){\r\n    if (condition == null)\r\n        throw new NullPointerException();\r\n    if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))\r\n        throw new IllegalArgumentException(\"not owner\");\r\n    return sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject) condition);\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingQueueTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    LinkedBlockingQueue q = new LinkedBlockingQueue(SIZE);\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    Collection<Integer> elements = Arrays.asList(ints);\r\n    try {\r\n        q.addAll(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "javax.net.ssl.SSLContext.getProtocol",
	"Comment": "returns the protocol name of this sslcontext object.this is the same name that was specified in one of thegetinstance calls that created thissslcontext object.",
	"Method": "String getProtocol(){\r\n    return this.protocol;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.FunctionizerTest.testPrivateToPrivate",
	"Comment": "verify one function calls another with the instance parameter.",
	"Method": "void testPrivateToPrivate(){\r\n    String translation = translateSourceFile(\"class A { private String test(String msg) { return str(); } \" + \"  private String str() { return toString(); }}\", \"A\", \"A.m\");\r\n    assertTranslation(translation, \"return A_str(self);\");\r\n    assertTranslation(translation, \"return [self description];\");\r\n}"
}, {
	"Path": "java.net.Socks4Message.getString",
	"Comment": "get a string from the buffer at the offset given. the method reads untilit encounters a null value or reaches the maxlength given.",
	"Method": "String getString(int offset,int maxLength){\r\n    int index = offset;\r\n    int lastIndex = index + maxLength;\r\n    while (index < lastIndex && (buffer[index] != 0)) {\r\n        index++;\r\n    }\r\n    return new String(buffer, offset, index - offset, StandardCharsets.ISO_8859_1);\r\n}"
}, {
	"Path": "java.util.ListResourceBundle.handleKeySet",
	"Comment": "returns a set of the keys containedonly in this resourcebundle.",
	"Method": "Set<String> handleKeySet(){\r\n    if (lookup == null) {\r\n        loadLookup();\r\n    }\r\n    return lookup.keySet();\r\n}"
}, {
	"Path": "com.google.mockwebserver.RecordedRequest.getBody",
	"Comment": "returns the body of this post request. this may be truncated.",
	"Method": "byte[] getBody(){\r\n    return body;\r\n}"
}, {
	"Path": "java.util.Calendar.toString",
	"Comment": "return a string representation of this calendar. this methodis intended to be used only for debugging purposes, and theformat of the returned string may vary between implementations.the returned string may be empty but may not be null.",
	"Method": "String toString(){\r\n    StringBuilder buffer = new StringBuilder(800);\r\n    buffer.append(getClass().getName()).append('[');\r\n    appendValue(buffer, \"time\", isTimeSet, time);\r\n    buffer.append(\",areFieldsSet=\").append(areFieldsSet);\r\n    buffer.append(\",areAllFieldsSet=\").append(areAllFieldsSet);\r\n    buffer.append(\",lenient=\").append(lenient);\r\n    buffer.append(\",zone=\").append(zone);\r\n    appendValue(buffer, \",firstDayOfWeek\", true, (long) firstDayOfWeek);\r\n    appendValue(buffer, \",minimalDaysInFirstWeek\", true, (long) minimalDaysInFirstWeek);\r\n    for (int i = 0; i < FIELD_COUNT; ++i) {\r\n        buffer.append(',');\r\n        appendValue(buffer, FIELD_NAME[i], isSet(i), (long) fields[i]);\r\n    }\r\n    buffer.append(']');\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testCompleteExceptionally2CC",
	"Comment": "invoke task throws exception after invoking completeexceptionally",
	"Method": "void testCompleteExceptionally2CC(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            CCF f = new LCCF(null, 8);\r\n            f.completeExceptionally(new FJException());\r\n            try {\r\n                f.invoke();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testCompleteExceptionally2CC",
	"Comment": "invoke task throws exception after invoking completeexceptionally",
	"Method": "void testCompleteExceptionally2CC(){\r\n    CCF f = new LCCF(null, 8);\r\n    f.completeExceptionally(new FJException());\r\n    try {\r\n        f.invoke();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinTask8Test.testPollNextLocalTaskAsync",
	"Comment": "pollnextlocaltask returns least recent unexecuted task withoutexecuting it, in async mode",
	"Method": "void testPollNextLocalTaskAsync(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib g = new AsyncFib(9);\r\n            assertSame(g, g.fork());\r\n            AsyncFib f = new AsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, pollNextLocalTask());\r\n            helpQuiesce();\r\n            f.checkCompletedNormally();\r\n            checkNotDone(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(asyncSingletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTask8Test.testPollNextLocalTaskAsync",
	"Comment": "pollnextlocaltask returns least recent unexecuted task withoutexecuting it, in async mode",
	"Method": "void testPollNextLocalTaskAsync(){\r\n    AsyncFib g = new AsyncFib(9);\r\n    assertSame(g, g.fork());\r\n    AsyncFib f = new AsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, pollNextLocalTask());\r\n    helpQuiesce();\r\n    f.checkCompletedNormally();\r\n    checkNotDone(g);\r\n}"
}, {
	"Path": "android.icu.dev.test.format.DateFormatTest.TestRunTogetherPattern985",
	"Comment": "verify the behavior of patterns in which digits for different fields run togetherwithout intervening separators.",
	"Method": "void TestRunTogetherPattern985(){\r\n    String format = \"yyyyMMddHHmmssSSS\";\r\n    String now, then;\r\n    SimpleDateFormat formatter = new SimpleDateFormat(format);\r\n    Date date1 = new Date();\r\n    now = ((DateFormat) formatter).format(date1);\r\n    logln(now);\r\n    ParsePosition pos = new ParsePosition(0);\r\n    Date date2 = formatter.parse(now, pos);\r\n    if (date2 == null)\r\n        then = \"Parse stopped at \" + pos.getIndex();\r\n    else\r\n        then = ((DateFormat) formatter).format(date2);\r\n    logln(then);\r\n    if (date2 == null || !date2.equals(date1))\r\n        errln(\"FAIL\");\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinPool.makeCommonPool",
	"Comment": "creates and returns the common pool, respecting user settingsspecified via system properties.",
	"Method": "ForkJoinPool makeCommonPool(){\r\n    int parallelism = -1;\r\n    ForkJoinWorkerThreadFactory factory = null;\r\n    UncaughtExceptionHandler handler = null;\r\n    try {\r\n        String pp = System.getProperty(\"java.util.concurrent.ForkJoinPool.common.parallelism\");\r\n        String fp = System.getProperty(\"java.util.concurrent.ForkJoinPool.common.threadFactory\");\r\n        String hp = System.getProperty(\"java.util.concurrent.ForkJoinPool.common.exceptionHandler\");\r\n        if (pp != null)\r\n            parallelism = Integer.parseInt(pp);\r\n        if (fp != null)\r\n            factory = ((ForkJoinWorkerThreadFactory) ClassLoader.getSystemClassLoader().loadClass(fp).newInstance());\r\n        if (hp != null)\r\n            handler = ((UncaughtExceptionHandler) ClassLoader.getSystemClassLoader().loadClass(hp).newInstance());\r\n    } catch (Exception ignore) {\r\n    }\r\n    if (factory == null) {\r\n        factory = defaultForkJoinWorkerThreadFactory;\r\n    }\r\n    if (parallelism < 0 && (parallelism = Runtime.getRuntime().availableProcessors() - 1) <= 0)\r\n        parallelism = 1;\r\n    if (parallelism > MAX_CAP)\r\n        parallelism = MAX_CAP;\r\n    return new ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE, \"ForkJoinPool.commonPool-worker-\");\r\n}"
}, {
	"Path": "java.util.InvalidPropertiesFormatException.readObject",
	"Comment": "throws notserializableexception, since invalidpropertiesformatexceptionobjects are not intended to be serializable.",
	"Method": "void readObject(java.io.ObjectInputStream in){\r\n    throw new NotSerializableException(\"Not serializable.\");\r\n}"
}, {
	"Path": "java.security.spec.ECPoint.equals",
	"Comment": "compares this elliptic curve point for equality withthe specified object.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj)\r\n        return true;\r\n    if (this == POINT_INFINITY)\r\n        return false;\r\n    if (obj instanceof ECPoint) {\r\n        return ((x.equals(((ECPoint) obj).x)) && (y.equals(((ECPoint) obj).y)));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.AtomicMarkableReferenceTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for reference valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    final AtomicMarkableReference ai = new AtomicMarkableReference(one, false);\r\n    Thread t = new Thread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!ai.compareAndSet(two, three, false, false)) Thread.yield();\r\n        }\r\n    });\r\n    t.start();\r\n    assertTrue(ai.compareAndSet(one, two, false, false));\r\n    t.join(LONG_DELAY_MS);\r\n    assertFalse(t.isAlive());\r\n    assertSame(three, ai.getReference());\r\n    assertFalse(ai.isMarked());\r\n}"
}, {
	"Path": "jsr166.AtomicMarkableReferenceTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for reference valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    while (!ai.compareAndSet(two, three, false, false)) Thread.yield();\r\n}"
}, {
	"Path": "java.net.InetAddress.isMCNodeLocal",
	"Comment": "utility routine to check if the multicast address has node scope.",
	"Method": "boolean isMCNodeLocal(){\r\n    return false;\r\n}"
}, {
	"Path": "java.util.concurrent.Phaser.internalAwaitAdvance",
	"Comment": "possibly blocks and waits for phase to advance unless aborted.call only on root phaser.",
	"Method": "int internalAwaitAdvance(int phase,QNode node){\r\n    releaseWaiters(phase - 1);\r\n    boolean queued = false;\r\n    int lastUnarrived = 0;\r\n    int spins = SPINS_PER_ARRIVAL;\r\n    long s;\r\n    int p;\r\n    while ((p = (int) ((s = state) >>> PHASE_SHIFT)) == phase) {\r\n        if (node == null) {\r\n            int unarrived = (int) s & UNARRIVED_MASK;\r\n            if (unarrived != lastUnarrived && (lastUnarrived = unarrived) < NCPU)\r\n                spins += SPINS_PER_ARRIVAL;\r\n            boolean interrupted = Thread.interrupted();\r\n            if (interrupted || --spins < 0) {\r\n                node = new QNode(this, phase, false, false, 0L);\r\n                node.wasInterrupted = interrupted;\r\n            }\r\n        } else if (node.isReleasable())\r\n            break;\r\n        else if (!queued) {\r\n            AtomicReference<QNode> head = (phase & 1) == 0 ? evenQ : oddQ;\r\n            QNode q = node.next = head.get();\r\n            if ((q == null || q.phase == phase) && (int) (state >>> PHASE_SHIFT) == phase)\r\n                queued = head.compareAndSet(q, node);\r\n        } else {\r\n            try {\r\n                ForkJoinPool.managedBlock(node);\r\n            } catch (InterruptedException cantHappen) {\r\n                node.wasInterrupted = true;\r\n            }\r\n        }\r\n    }\r\n    if (node != null) {\r\n        if (node.thread != null)\r\n            node.thread = null;\r\n        if (node.wasInterrupted && !node.interruptible)\r\n            Thread.currentThread().interrupt();\r\n        if (p == phase && (p = (int) (state >>> PHASE_SHIFT)) == phase)\r\n            return abortWait(phase);\r\n    }\r\n    releaseWaiters(phase);\r\n    return p;\r\n}"
}, {
	"Path": "java.text.NumberFormat.readObject",
	"Comment": "first, read in the default serializable data.then, if serialversiononstream is less than 1, indicating thatthe stream was written by jdk 1.1,set the int fields such as maximumintegerdigitsto be equal to the byte fields such as maxintegerdigits,since the int fields were not present in jdk 1.1.finally, set serialversiononstream back to the maximum allowed value so thatdefault serialization will work properly if this object is streamed out again.if minimumintegerdigits is greater thanmaximumintegerdigits or minimumfractiondigitsis greater than maximumfractiondigits, then the stream datais invalid and this method throws an invalidobjectexception.in addition, if any of these values is negative, then this method throwsan invalidobjectexception.",
	"Method": "void readObject(ObjectInputStream stream){\r\n    stream.defaultReadObject();\r\n    if (serialVersionOnStream < 1) {\r\n        maximumIntegerDigits = maxIntegerDigits;\r\n        minimumIntegerDigits = minIntegerDigits;\r\n        maximumFractionDigits = maxFractionDigits;\r\n        minimumFractionDigits = minFractionDigits;\r\n    }\r\n    if (minimumIntegerDigits > maximumIntegerDigits || minimumFractionDigits > maximumFractionDigits || minimumIntegerDigits < 0 || minimumFractionDigits < 0) {\r\n        throw new InvalidObjectException(\"Digit count range invalid\");\r\n    }\r\n    serialVersionOnStream = currentSerialVersion;\r\n}"
}, {
	"Path": "java.security.cert.X509CRLEntry.getRevocationReason",
	"Comment": "returns the reason the certificate has been revoked, as specifiedin the reason code extension of this crl entry.",
	"Method": "CRLReason getRevocationReason(){\r\n    if (!hasExtensions()) {\r\n        return null;\r\n    }\r\n    return X509CRLEntryImpl.getRevocationReason(this);\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_hijrahToJapanese",
	"Comment": "test to verify the date conversion from hijrah to japanese chronology",
	"Method": "void test_hijrahToJapanese(HijrahDate hijrah,String japanese){\r\n    assertEquals(JapaneseChronology.INSTANCE.date(hijrah).toString(), japanese);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testHasWaitersIMSE",
	"Comment": "haswaiters throws illegalmonitorstateexception if not synced",
	"Method": "void testHasWaitersIMSE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    try {\r\n        sync.hasWaiters(c);\r\n        shouldThrow();\r\n    } catch (IllegalMonitorStateException success) {\r\n    }\r\n    assertHasWaitersUnlocked(sync, c, NO_THREADS);\r\n}"
}, {
	"Path": "java.beans.PropertyChangeListenerProxy.getPropertyName",
	"Comment": "returns the name of the named property associated with the listener.",
	"Method": "String getPropertyName(){\r\n    return this.propertyName;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.PKIXCertPathValidator.engineValidate",
	"Comment": "validates a certification path consisting exclusively ofx509certificates using the pkix validation algorithm,which uses the specified input parameter set.the input parameter set must be a pkixparameters object.",
	"Method": "CertPathValidatorResult engineValidate(CertPath cp,CertPathParameters params){\r\n    ValidatorParams valParams = PKIX.checkParams(cp, params);\r\n    return validate(valParams);\r\n}"
}, {
	"Path": "java.util.concurrent.ThreadPoolExecutor.getActiveCount",
	"Comment": "returns the approximate number of threads that are activelyexecuting tasks.",
	"Method": "int getActiveCount(){\r\n    final ReentrantLock mainLock = this.mainLock;\r\n    mainLock.lock();\r\n    try {\r\n        int n = 0;\r\n        for (Worker w : workers) if (w.isLocked())\r\n            ++n;\r\n        return n;\r\n    } finally {\r\n        mainLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.CertStoreHelper.isCausedByNetworkIssue",
	"Comment": "returns true if the cause of the certstoreexception is a networkrelated issue.",
	"Method": "boolean isCausedByNetworkIssue(String type,CertStoreException cse,boolean isCausedByNetworkIssue,CertStoreException e){\r\n    switch(type) {\r\n        case \"SSLServer\":\r\n            try {\r\n                CertStoreHelper csh = CertStoreHelper.getInstance(type);\r\n                return csh.isCausedByNetworkIssue(cse);\r\n            } catch (NoSuchAlgorithmException nsae) {\r\n                return false;\r\n            }\r\n        case \"URI\":\r\n            Throwable t = cse.getCause();\r\n            return (t != null && t instanceof IOException);\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "jsr166.JSR166TestCase.delayedDate",
	"Comment": "returns a new date instance representing a time at leastdelaymillis milliseconds in the future.",
	"Method": "Date delayedDate(long delayMillis){\r\n    return new Date(System.currentTimeMillis() + delayMillis + 1);\r\n}"
}, {
	"Path": "java.lang.ClassLoader.findLoadedClass",
	"Comment": "returns the class with the given binary name if thisloader has been recorded by the java virtual machine as an initiatingloader of a class with that binary name.otherwisenull is returned.",
	"Method": "Class<?> findLoadedClass(String name){\r\n    try {\r\n        return SystemClassLoader.loader.findClass(name);\r\n    } catch (ClassNotFoundException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.time.Period.getDays",
	"Comment": "gets the amount of days of this period.this returns the days unit.",
	"Method": "int getDays(){\r\n    return days;\r\n}"
}, {
	"Path": "java.util.JumboEnumSet.removeAll",
	"Comment": "removes from this set all of its elements that are contained inthe specified collection.",
	"Method": "boolean removeAll(Collection<?> c){\r\n    if (!(c instanceof JumboEnumSet))\r\n        return super.removeAll(c);\r\n    JumboEnumSet es = (JumboEnumSet) c;\r\n    if (es.elementType != elementType)\r\n        return false;\r\n    for (int i = 0; i < elements.length; i++) elements[i] &= ~es.elements[i];\r\n    return recalculateSize();\r\n}"
}, {
	"Path": "tests.support.Support_StringReader.close",
	"Comment": "this method closes this stringreader. once it is closed, you can no\tlonger read from it. only the first invocation of this method has any\teffect.",
	"Method": "void close(){\r\n    synchronized (lock) {\r\n        if (isOpen()) {\r\n            str = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.BasicChecker.makeInheritedParamsKey",
	"Comment": "internal method to create a new key with inherited key parameters.",
	"Method": "PublicKey makeInheritedParamsKey(PublicKey keyValueKey,PublicKey keyParamsKey){\r\n    if (!(keyValueKey instanceof DSAPublicKey) || !(keyParamsKey instanceof DSAPublicKey))\r\n        throw new CertPathValidatorException(\"Input key is not \" + \"appropriate type for \" + \"inheriting parameters\");\r\n    DSAParams params = ((DSAPublicKey) keyParamsKey).getParams();\r\n    if (params == null)\r\n        throw new CertPathValidatorException(\"Key parameters missing\");\r\n    try {\r\n        BigInteger y = ((DSAPublicKey) keyValueKey).getY();\r\n        KeyFactory kf = KeyFactory.getInstance(\"DSA\");\r\n        DSAPublicKeySpec ks = new DSAPublicKeySpec(y, params.getP(), params.getQ(), params.getG());\r\n        return kf.generatePublic(ks);\r\n    } catch (GeneralSecurityException e) {\r\n        throw new CertPathValidatorException(\"Unable to generate key with\" + \" inherited parameters: \" + e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testTryAcquireSharedNanos",
	"Comment": "tryacquiresharednanos returns after release, but not before",
	"Method": "void testTryAcquireSharedNanos(){\r\n    final BooleanLatch l = new BooleanLatch();\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            assertFalse(l.isSignalled());\r\n            long nanos = MILLISECONDS.toNanos(2 * LONG_DELAY_MS);\r\n            assertTrue(l.tryAcquireSharedNanos(0, nanos));\r\n            assertTrue(l.isSignalled());\r\n            assertTrue(l.tryAcquireSharedNanos(0, nanos));\r\n            assertTrue(l.isSignalled());\r\n        }\r\n    });\r\n    waitForQueuedThread(l, t);\r\n    assertFalse(l.isSignalled());\r\n    assertThreadStaysAlive(t);\r\n    assertTrue(l.releaseShared(0));\r\n    assertTrue(l.isSignalled());\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testTryAcquireSharedNanos",
	"Comment": "tryacquiresharednanos returns after release, but not before",
	"Method": "void testTryAcquireSharedNanos(){\r\n    assertFalse(l.isSignalled());\r\n    long nanos = MILLISECONDS.toNanos(2 * LONG_DELAY_MS);\r\n    assertTrue(l.tryAcquireSharedNanos(0, nanos));\r\n    assertTrue(l.isSignalled());\r\n    assertTrue(l.tryAcquireSharedNanos(0, nanos));\r\n    assertTrue(l.isSignalled());\r\n}"
}, {
	"Path": "javax.net.SocketFactory.createSocket",
	"Comment": "creates a socket and connect it to the specified remote addresson the specified remote port.the socket will also be boundto the local address and port suplied.the socket is configured usingthe socket options established for this factory.if there is a security manager, its checkconnectmethod is called with the host address and portas its arguments. this could result in a securityexception.",
	"Method": "Socket createSocket(Socket createSocket,String host,int port,Socket createSocket,String host,int port,InetAddress localHost,int localPort,Socket createSocket,InetAddress host,int port,Socket createSocket,InetAddress address,int port,InetAddress localAddress,int localPort,Socket createSocket,Socket createSocket,String host,int port,Socket createSocket,InetAddress address,int port,Socket createSocket,String host,int port,InetAddress clientAddress,int clientPort,Socket createSocket,InetAddress address,int port,InetAddress clientAddress,int clientPort){\r\n    UnsupportedOperationException uop = new UnsupportedOperationException();\r\n    SocketException se = new SocketException(\"Unconnected sockets not implemented\");\r\n    se.initCause(uop);\r\n    throw se;\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_leapYears",
	"Comment": "test to verify whether a given hijrah year is a leap year or not",
	"Method": "void test_leapYears(int y,boolean leapyear){\r\n    HijrahDate date = HijrahDate.of(y, 1, 1);\r\n    assertEquals(date.isLeapYear(), leapyear);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.util.LocaleTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    defaultLocale = Locale.getDefault();\r\n    Locale.setDefault(Locale.US);\r\n    testLocale = new Locale(\"en\", \"CA\", \"WIN32\");\r\n    l = new Locale(\"fr\", \"CA\", \"WIN32\");\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.lang.reflect.GenericMethodsTests.checkTypeParameter",
	"Comment": "tests whether the specified method declares a type parameter t.",
	"Method": "void checkTypeParameter(Method method){\r\n    TypeVariable<Method> typeParameter = getTypeParameter(method);\r\n    assertEquals(\"T\", typeParameter.getName());\r\n    assertEquals(method, typeParameter.getGenericDeclaration());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.MetadataWriter.getTypeModifiers",
	"Comment": "returns the modifiers for a specified type, including internal ones.all class modifiers are defined in the jvm specification, table 4.1.",
	"Method": "int getTypeModifiers(TypeElement type){\r\n    int modifiers = ElementUtil.fromModifierSet(type.getModifiers());\r\n    if (type.getKind().isInterface()) {\r\n        modifiers |= java.lang.reflect.Modifier.INTERFACE | java.lang.reflect.Modifier.ABSTRACT | java.lang.reflect.Modifier.STATIC;\r\n    }\r\n    if (ElementUtil.isSynthetic(type)) {\r\n        modifiers |= ElementUtil.ACC_SYNTHETIC;\r\n    }\r\n    if (ElementUtil.isAnnotationType(type)) {\r\n        modifiers |= ElementUtil.ACC_ANNOTATION;\r\n    }\r\n    if (ElementUtil.isEnum(type)) {\r\n        modifiers |= ElementUtil.ACC_ENUM;\r\n    }\r\n    if (ElementUtil.isAnonymous(type)) {\r\n        modifiers |= ElementUtil.ACC_ANONYMOUS | java.lang.reflect.Modifier.STATIC;\r\n        modifiers |= java.lang.reflect.Modifier.FINAL;\r\n    }\r\n    return modifiers;\r\n}"
}, {
	"Path": "org.apache.harmony.luni.tests.java.util.CollectionsTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    ll = new LinkedList();\r\n    myll = new LinkedList();\r\n    s = new HashSet();\r\n    mys = new HashSet();\r\n    reversedLinkedList = new LinkedList();\r\n    myReversedLinkedList = new LinkedList();\r\n    hm = new HashMap();\r\n    for (int i = 0; i < objArray.length; i++) {\r\n        ll.add(objArray[i]);\r\n        myll.add(myobjArray[i]);\r\n        s.add(objArray[i]);\r\n        mys.add(myobjArray[i]);\r\n        reversedLinkedList.add(objArray[objArray.length - i - 1]);\r\n        myReversedLinkedList.add(myobjArray[myobjArray.length - i - 1]);\r\n        hm.put(objArray[i].toString(), objArray[i]);\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicIntegerFieldUpdater.getAndIncrement",
	"Comment": "atomically increments by one the current value of the field of thegiven object managed by this updater.",
	"Method": "int getAndIncrement(T obj,int getAndIncrement,T obj){\r\n    int prev, next;\r\n    do {\r\n        prev = get(obj);\r\n        next = prev + 1;\r\n    } while (!compareAndSet(obj, prev, next));\r\n    return prev;\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkQuietlyJoinSingleton",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoinSingleton(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingAsyncFib f = new FailingAsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            f.quietlyJoin();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkQuietlyJoinSingleton",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoinSingleton(){\r\n    FailingAsyncFib f = new FailingAsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    f.quietlyJoin();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentLinkedDeque.updateTail",
	"Comment": "guarantees that any node which was unlinked before a call tothis method will be unreachable from tail after it returns.does not guarantee to eliminate slack, only that tail willpoint to a node that was active while this method was running.",
	"Method": "void updateTail(){\r\n    Node<E> t, p, q;\r\n    restartFromTail: while ((t = tail).item == null && (p = t.next) != null) {\r\n        for (; ; ) {\r\n            if ((q = p.next) == null || (q = (p = q).next) == null) {\r\n                if (casTail(t, p))\r\n                    return;\r\n                else\r\n                    continue restartFromTail;\r\n            } else if (t != tail)\r\n                continue restartFromTail;\r\n            else\r\n                p = q;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.X509Factory.readFully",
	"Comment": "read from the stream until length bytes have been read or eof hasbeen reached. return the number of bytes actually read.",
	"Method": "int readFully(InputStream in,ByteArrayOutputStream bout,int length){\r\n    int read = 0;\r\n    byte[] buffer = new byte[2048];\r\n    while (length > 0) {\r\n        int n = in.read(buffer, 0, length < 2048 ? length : 2048);\r\n        if (n <= 0) {\r\n            break;\r\n        }\r\n        bout.write(buffer, 0, n);\r\n        read += n;\r\n        length -= n;\r\n    }\r\n    return read;\r\n}"
}, {
	"Path": "sun.security.util.DerInputBuffer.equals",
	"Comment": "compares this derinputbuffer for equality with the specifiedobject.",
	"Method": "boolean equals(Object other,boolean equals,DerInputBuffer other){\r\n    if (this == other)\r\n        return true;\r\n    int max = this.available();\r\n    if (other.available() != max)\r\n        return false;\r\n    for (int i = 0; i < max; i++) {\r\n        if (this.buf[this.pos + i] != other.buf[other.pos + i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "java.lang.Thread.setDefaultUncaughtExceptionHandler",
	"Comment": "sets the default uncaught exception handler. this handler is invoked incase any thread dies due to an unhandled exception.",
	"Method": "void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler handler){\r\n    Thread.defaultUncaughtHandler = handler;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.TranslationUtil.hasSideEffect",
	"Comment": "reterns whether the expression might have any side effects. if true, itwould be unsafe to prune the given node from the tree.",
	"Method": "boolean hasSideEffect(Expression expr){\r\n    VariableElement var = TreeUtil.getVariableElement(expr);\r\n    if (var != null && ElementUtil.isVolatile(var)) {\r\n        return true;\r\n    }\r\n    switch(expr.getKind()) {\r\n        case BOOLEAN_LITERAL:\r\n        case CHARACTER_LITERAL:\r\n        case NULL_LITERAL:\r\n        case NUMBER_LITERAL:\r\n        case QUALIFIED_NAME:\r\n        case SIMPLE_NAME:\r\n        case STRING_LITERAL:\r\n        case SUPER_FIELD_ACCESS:\r\n        case THIS_EXPRESSION:\r\n            return false;\r\n        case CAST_EXPRESSION:\r\n            return hasSideEffect(((CastExpression) expr).getExpression());\r\n        case CONDITIONAL_EXPRESSION:\r\n            {\r\n                ConditionalExpression condExpr = (ConditionalExpression) expr;\r\n                return hasSideEffect(condExpr.getExpression()) || hasSideEffect(condExpr.getThenExpression()) || hasSideEffect(condExpr.getElseExpression());\r\n            }\r\n        case FIELD_ACCESS:\r\n            return hasSideEffect(((FieldAccess) expr).getExpression());\r\n        case INFIX_EXPRESSION:\r\n            for (Expression operand : ((InfixExpression) expr).getOperands()) {\r\n                if (hasSideEffect(operand)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        case PARENTHESIZED_EXPRESSION:\r\n            return hasSideEffect(((ParenthesizedExpression) expr).getExpression());\r\n        case PREFIX_EXPRESSION:\r\n            {\r\n                PrefixExpression preExpr = (PrefixExpression) expr;\r\n                PrefixExpression.Operator op = preExpr.getOperator();\r\n                return op == PrefixExpression.Operator.INCREMENT || op == PrefixExpression.Operator.DECREMENT || hasSideEffect(preExpr.getOperand());\r\n            }\r\n        default:\r\n            return true;\r\n    }\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testIntegerFieldUpdaterGetAndAccumulate",
	"Comment": "atomicintegerfieldupdater getandaccumulate returns previous valueand updates with supplied function.",
	"Method": "void testIntegerFieldUpdaterGetAndAccumulate(){\r\n    AtomicIntegerFieldUpdater a = anIntFieldUpdater();\r\n    a.set(this, 1);\r\n    assertEquals(1, a.getAndAccumulate(this, 2, Integer::sum));\r\n    assertEquals(3, a.getAndAccumulate(this, 3, Integer::sum));\r\n    assertEquals(6, a.get(this));\r\n    assertEquals(6, anIntField);\r\n}"
}, {
	"Path": "java.util.zip.GZIPOutputStream.writeInt",
	"Comment": "writes integer in intel byte order to a byte array, starting at agiven offset.",
	"Method": "void writeInt(int i,byte[] buf,int offset){\r\n    writeShort(i & 0xffff, buf, offset);\r\n    writeShort((i >> 16) & 0xffff, buf, offset + 2);\r\n}"
}, {
	"Path": "javax.net.ssl.SNIServerName.hashCode",
	"Comment": "returns a hash code value for this server name.the hash code value is generated using the name type and encodedvalue of this server name.",
	"Method": "int hashCode(){\r\n    int result = 17;\r\n    result = 31 * result + type;\r\n    result = 31 * result + Arrays.hashCode(encoded);\r\n    return result;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test430040",
	"Comment": "cannot convert from junk13.expressionhelper to junk13.expressionhelper",
	"Method": "void test430040(){\r\n    this.runConformTest(new String[] { \"X.java\", \"public class X {\\n\" + \"    public static void main(String [] args) {\\n\" + \"        System.out.println(\\\"OK\\\");\\n\" + \"    }\\n\" + \"    class Observable<T> {}\\n\" + \"    class ObservableValue<T> {}\\n\" + \"    interface InvalidationListener {\\n\" + \"        public void invalidated(Observable observable);\\n\" + \"    }\\n\" + \"    public interface ChangeListener<T> {\\n\" + \"        void changed(ObservableValue<? extends T> observable, T oldValue, T newValue);\\n\" + \"    }\\n\" + \"    static class ExpressionHelper<T> {}\\n\" + \"    public static <T> ExpressionHelper<T> addListener(ExpressionHelper<T> helper, ObservableValue<T> observable, InvalidationListener listener) {\\n\" + \"        return helper;\\n\" + \"    }\\n\" + \"    public static <T> ExpressionHelper<T> addListener(ExpressionHelper<T> helper, ObservableValue<T> observable, ChangeListener<? super T> listener) {\\n\" + \"        return helper;\\n\" + \"    }\\n\" + \"    private ExpressionHelper<Object> helper;\\n\" + \"    public void junk() {\\n\" + \"        helper = (ExpressionHelper<Object>) addListener(helper, null, (Observable o) -> {throw new RuntimeException();});\\n\" + \"        helper = addListener(helper, null, (Observable o) -> {throw new RuntimeException();});\\n\" + \"    }\\n\" + \"}\\n\" }, \"OK\");\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.lang.reflect.BoundedGenericMethodsTests.checkBoundedTypeParameter",
	"Comment": "tests whether the type parameter is upper bounded by boundedgenericmethods..",
	"Method": "void checkBoundedTypeParameter(Method method){\r\n    TypeVariable<Method> typeParameter = getTypeParameter(method);\r\n    assertEquals(\"T\", typeParameter.getName());\r\n    assertEquals(method, typeParameter.getGenericDeclaration());\r\n    Type[] bounds = typeParameter.getBounds();\r\n    assertLenghtOne(bounds);\r\n    Type bound = bounds[0];\r\n    assertEquals(BoundedGenericMethods.class, bound);\r\n}"
}, {
	"Path": "java.security.KeyFactory.nextSpi",
	"Comment": "update the active keyfactoryspi of this class and return the nextimplementation for failover. if no more implemenations areavailable, this method returns null. however, the active spi ofthis class is never set to null.",
	"Method": "KeyFactorySpi nextSpi(KeyFactorySpi oldSpi){\r\n    synchronized (lock) {\r\n        if ((oldSpi != null) && (oldSpi != spi)) {\r\n            return spi;\r\n        }\r\n        if (serviceIterator == null) {\r\n            return null;\r\n        }\r\n        while (serviceIterator.hasNext()) {\r\n            Service s = serviceIterator.next();\r\n            try {\r\n                Object obj = s.newInstance(null);\r\n                if (obj instanceof KeyFactorySpi == false) {\r\n                    continue;\r\n                }\r\n                KeyFactorySpi spi = (KeyFactorySpi) obj;\r\n                provider = s.getProvider();\r\n                this.spi = spi;\r\n                return spi;\r\n            } catch (NoSuchAlgorithmException e) {\r\n            }\r\n        }\r\n        serviceIterator = null;\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.Executors.newScheduledThreadPool",
	"Comment": "creates a thread pool that can schedule commands to run after agiven delay, or to execute periodically.",
	"Method": "ScheduledExecutorService newScheduledThreadPool(int corePoolSize,ScheduledExecutorService newScheduledThreadPool,int corePoolSize,ThreadFactory threadFactory){\r\n    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);\r\n}"
}, {
	"Path": "sun.security.provider.certpath.ReverseBuilder.isPathCompleted",
	"Comment": "verifies whether the input certificate completes the path.this checks whether the cert is the target certificate.",
	"Method": "boolean isPathCompleted(X509Certificate cert){\r\n    return cert.getSubjectX500Principal().equals(buildParams.targetSubject());\r\n}"
}, {
	"Path": "sun.security.util.DerIndefLenConverter.convert",
	"Comment": "converts a indefinite length der encoded byte array toa definte length der encoding.",
	"Method": "byte[] convert(byte[] indefData){\r\n    data = indefData;\r\n    dataPos = 0;\r\n    index = 0;\r\n    dataSize = data.length;\r\n    int len = 0;\r\n    int unused = 0;\r\n    while (dataPos < dataSize) {\r\n        parseTag();\r\n        len = parseLength();\r\n        parseValue(len);\r\n        if (unresolved == 0) {\r\n            unused = dataSize - dataPos;\r\n            dataSize = dataPos;\r\n            break;\r\n        }\r\n    }\r\n    if (unresolved != 0) {\r\n        throw new IOException(\"not all indef len BER resolved\");\r\n    }\r\n    newData = new byte[dataSize + numOfTotalLenBytes + unused];\r\n    dataPos = 0;\r\n    newDataPos = 0;\r\n    index = 0;\r\n    while (dataPos < dataSize) {\r\n        writeTag();\r\n        writeLengthAndValue();\r\n    }\r\n    System.arraycopy(indefData, dataSize, newData, dataSize + numOfTotalLenBytes, unused);\r\n    return newData;\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerFieldUpdaterTest.testCompareAndSetProtected",
	"Comment": "compareandset succeeds in changing protected field value ifequal to expected else fails",
	"Method": "void testCompareAndSetProtected(){\r\n    AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;\r\n    a = updaterFor(\"protectedField\");\r\n    protectedField = 1;\r\n    assertTrue(a.compareAndSet(this, 1, 2));\r\n    assertTrue(a.compareAndSet(this, 2, -4));\r\n    assertEquals(-4, a.get(this));\r\n    assertFalse(a.compareAndSet(this, -5, 7));\r\n    assertEquals(-4, a.get(this));\r\n    assertTrue(a.compareAndSet(this, -4, 7));\r\n    assertEquals(7, a.get(this));\r\n}"
}, {
	"Path": "sun.security.util.DerInputStream.reset",
	"Comment": "return to the position of the last markcall.a mark is implicitly set at the beginning ofthe stream when it is created.",
	"Method": "void reset(){\r\n    buffer.reset();\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testLongUpdateAndGet",
	"Comment": "atomiclong updateandget updates with supplied function andreturns result.",
	"Method": "void testLongUpdateAndGet(){\r\n    AtomicLong a = new AtomicLong(1L);\r\n    assertEquals(18L, a.updateAndGet(Atomic8Test::addLong17));\r\n    assertEquals(35L, a.updateAndGet(Atomic8Test::addLong17));\r\n}"
}, {
	"Path": "java.text.SimpleDateFormat.zeroPaddingNumber",
	"Comment": "formats a number with the specified minimum and maximum number of digits.",
	"Method": "void zeroPaddingNumber(int value,int minDigits,int maxDigits,StringBuffer buffer){\r\n    try {\r\n        if (zeroDigit == 0) {\r\n            zeroDigit = ((DecimalFormat) numberFormat).getDecimalFormatSymbols().getZeroDigit();\r\n        }\r\n        if (value >= 0) {\r\n            if (value < 100 && minDigits >= 1 && minDigits <= 2) {\r\n                if (value < 10) {\r\n                    if (minDigits == 2) {\r\n                        buffer.append(zeroDigit);\r\n                    }\r\n                    buffer.append((char) (zeroDigit + value));\r\n                } else {\r\n                    buffer.append((char) (zeroDigit + value / 10));\r\n                    buffer.append((char) (zeroDigit + value % 10));\r\n                }\r\n                return;\r\n            } else if (value >= 1000 && value < 10000) {\r\n                if (minDigits == 4) {\r\n                    buffer.append((char) (zeroDigit + value / 1000));\r\n                    value %= 1000;\r\n                    buffer.append((char) (zeroDigit + value / 100));\r\n                    value %= 100;\r\n                    buffer.append((char) (zeroDigit + value / 10));\r\n                    buffer.append((char) (zeroDigit + value % 10));\r\n                    return;\r\n                }\r\n                if (minDigits == 2 && maxDigits == 2) {\r\n                    zeroPaddingNumber(value % 100, 2, 2, buffer);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n    }\r\n    numberFormat.setMinimumIntegerDigits(minDigits);\r\n    numberFormat.setMaximumIntegerDigits(maxDigits);\r\n    numberFormat.format((long) value, buffer, DontCareFieldPosition.INSTANCE);\r\n}"
}, {
	"Path": "java.util.Hashtable.hashCode",
	"Comment": "returns the hash code value for this map as per the definition in themap interface.",
	"Method": "int hashCode(int hashCode){\r\n    int h = 0;\r\n    if (count == 0 || loadFactor < 0)\r\n        return h;\r\n    loadFactor = -loadFactor;\r\n    HashtableEntry[] tab = table;\r\n    for (HashtableEntry<K, V> entry : tab) while (entry != null) {\r\n        h += entry.hashCode();\r\n        entry = entry.next;\r\n    }\r\n    loadFactor = -loadFactor;\r\n    return h;\r\n}"
}, {
	"Path": "java.lang.ThreadLocal.createInheritedMap",
	"Comment": "factory method to create map of inherited thread locals.designed to be called only from thread constructor.",
	"Method": "ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap){\r\n    return new ThreadLocalMap(parentMap);\r\n}"
}, {
	"Path": "sun.net.www.URLConnection.canCache",
	"Comment": "returns true if the data associated with this url can be cached.",
	"Method": "boolean canCache(){\r\n    return url.getFile().indexOf('?') < 0;\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testDecrementPendingCountUnlessZero",
	"Comment": "decrementpendingcountunlesszero decrements reported pendingcount unless zero",
	"Method": "void testDecrementPendingCountUnlessZero(){\r\n    NoopCC a = new NoopCC(null, 2);\r\n    assertEquals(2, a.getPendingCount());\r\n    assertEquals(2, a.decrementPendingCountUnlessZero());\r\n    assertEquals(1, a.getPendingCount());\r\n    assertEquals(1, a.decrementPendingCountUnlessZero());\r\n    assertEquals(0, a.getPendingCount());\r\n    assertEquals(0, a.decrementPendingCountUnlessZero());\r\n    assertEquals(0, a.getPendingCount());\r\n    a.setPendingCount(-1);\r\n    assertEquals(-1, a.decrementPendingCountUnlessZero());\r\n    assertEquals(-2, a.getPendingCount());\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinTask.expungeStaleExceptions",
	"Comment": "polls stale refs and removes them. call only while holding lock.",
	"Method": "void expungeStaleExceptions(){\r\n    for (Object x; (x = exceptionTableRefQueue.poll()) != null; ) {\r\n        if (x instanceof ExceptionNode) {\r\n            int hashCode = ((ExceptionNode) x).hashCode;\r\n            ExceptionNode[] t = exceptionTable;\r\n            int i = hashCode & (t.length - 1);\r\n            ExceptionNode e = t[i];\r\n            ExceptionNode pred = null;\r\n            while (e != null) {\r\n                ExceptionNode next = e.next;\r\n                if (e == x) {\r\n                    if (pred == null)\r\n                        t[i] = next;\r\n                    else\r\n                        pred.next = next;\r\n                    break;\r\n                }\r\n                pred = e;\r\n                e = next;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.toBigDecimal",
	"Comment": "convert this mutablebiginteger to bigdecimal object with the specified signand scale.",
	"Method": "BigDecimal toBigDecimal(int sign,int scale){\r\n    if (intLen == 0 || sign == 0)\r\n        return BigDecimal.zeroValueOf(scale);\r\n    int[] mag = getMagnitudeArray();\r\n    int len = mag.length;\r\n    int d = mag[0];\r\n    if (len > 2 || (d < 0 && len == 2))\r\n        return new BigDecimal(new BigInteger(mag, sign), INFLATED, scale, 0);\r\n    long v = (len == 2) ? ((mag[1] & LONG_MASK) | (d & LONG_MASK) << 32) : d & LONG_MASK;\r\n    return BigDecimal.valueOf(sign == -1 ? -v : v, scale);\r\n}"
}, {
	"Path": "java.util.zip.InflaterInputStream.reset",
	"Comment": "repositions this stream to the position at the time themark method was last called on this input stream. the method reset for classinflaterinputstream does nothing except throw anioexception.",
	"Method": "void reset(){\r\n    throw new IOException(\"mark/reset not supported\");\r\n}"
}, {
	"Path": "org.xml.sax.InputSource.getEncoding",
	"Comment": "get the character encoding for a byte stream or uri.this value will be ignored when the application provides acharacter stream.",
	"Method": "String getEncoding(){\r\n    return encoding;\r\n}"
}, {
	"Path": "java.util.PriorityQueue.initFromCollection",
	"Comment": "initializes queue array with elements from the given collection.",
	"Method": "void initFromCollection(Collection<? extends E> c){\r\n    initElementsFromCollection(c);\r\n    heapify();\r\n}"
}, {
	"Path": "sun.security.util.SignatureFileVerifier.setSignatureFile",
	"Comment": "used to set the raw bytes of the .sf file when itis external to the signature block file.",
	"Method": "void setSignatureFile(byte sfBytes){\r\n    this.sfBytes = sfBytes;\r\n}"
}, {
	"Path": "java.sql.DriverManager.setLoginTimeout",
	"Comment": "sets the maximum time in seconds that a driver will waitwhile attempting to connect to a database.",
	"Method": "void setLoginTimeout(int seconds){\r\n    loginTimeout = seconds;\r\n}"
}, {
	"Path": "java.time.format.DateTimeFormatterBuilder.appendLiteral",
	"Comment": "appends a string literal to the formatter.this string will be output during a format.if the literal is empty, nothing is added to the formatter.",
	"Method": "DateTimeFormatterBuilder appendLiteral(char literal,DateTimeFormatterBuilder appendLiteral,String literal){\r\n    Objects.requireNonNull(literal, \"literal\");\r\n    if (literal.length() > 0) {\r\n        if (literal.length() == 1) {\r\n            appendInternal(new CharLiteralPrinterParser(literal.charAt(0)));\r\n        } else {\r\n            appendInternal(new StringLiteralPrinterParser(literal));\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testAwaitAdvanceBeforeInterrupt",
	"Comment": "awaitadvance continues waiting if interrupted while waiting",
	"Method": "void testAwaitAdvanceBeforeInterrupt(){\r\n    final Phaser phaser = new Phaser();\r\n    assertEquals(0, phaser.register());\r\n    final CountDownLatch pleaseArrive = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            assertEquals(0, phaser.register());\r\n            assertEquals(0, phaser.arrive());\r\n            assertFalse(Thread.currentThread().isInterrupted());\r\n            pleaseArrive.countDown();\r\n            assertEquals(1, phaser.awaitAdvance(0));\r\n            assertTrue(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseArrive);\r\n    waitForThreadToEnterWaitState(t, SHORT_DELAY_MS);\r\n    t.interrupt();\r\n    assertEquals(0, phaser.arrive());\r\n    awaitTermination(t);\r\n    Thread.currentThread().interrupt();\r\n    assertEquals(1, phaser.awaitAdvance(0));\r\n    assertTrue(Thread.interrupted());\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testAwaitAdvanceBeforeInterrupt",
	"Comment": "awaitadvance continues waiting if interrupted while waiting",
	"Method": "void testAwaitAdvanceBeforeInterrupt(){\r\n    assertEquals(0, phaser.register());\r\n    assertEquals(0, phaser.arrive());\r\n    assertFalse(Thread.currentThread().isInterrupted());\r\n    pleaseArrive.countDown();\r\n    assertEquals(1, phaser.awaitAdvance(0));\r\n    assertTrue(Thread.interrupted());\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testCompleteExceptionally",
	"Comment": "invoke task throws exception after invoking completeexceptionally",
	"Method": "void testCompleteExceptionally(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() {\r\n            FibTask f = new FibTask(8);\r\n            f.completeExceptionally(new FJException());\r\n            try {\r\n                Integer r = f.invoke();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(mainPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testCompleteExceptionally",
	"Comment": "invoke task throws exception after invoking completeexceptionally",
	"Method": "void testCompleteExceptionally(){\r\n    FibTask f = new FibTask(8);\r\n    f.completeExceptionally(new FJException());\r\n    try {\r\n        Integer r = f.invoke();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n    return NoResult;\r\n}"
}, {
	"Path": "java.lang.reflect.Array.get",
	"Comment": "returns the value of the indexed component in the specifiedarray object.the value is automatically wrapped in an objectif it has a primitive type.",
	"Method": "Object get(Object array,int index){\r\n    if (array instanceof Object[]) {\r\n        return ((Object[]) array)[index];\r\n    }\r\n    if (array instanceof boolean[]) {\r\n        return ((boolean[]) array)[index] ? Boolean.TRUE : Boolean.FALSE;\r\n    }\r\n    if (array instanceof byte[]) {\r\n        return Byte.valueOf(((byte[]) array)[index]);\r\n    }\r\n    if (array instanceof char[]) {\r\n        return Character.valueOf(((char[]) array)[index]);\r\n    }\r\n    if (array instanceof short[]) {\r\n        return Short.valueOf(((short[]) array)[index]);\r\n    }\r\n    if (array instanceof int[]) {\r\n        return Integer.valueOf(((int[]) array)[index]);\r\n    }\r\n    if (array instanceof long[]) {\r\n        return Long.valueOf(((long[]) array)[index]);\r\n    }\r\n    if (array instanceof float[]) {\r\n        return new Float(((float[]) array)[index]);\r\n    }\r\n    if (array instanceof double[]) {\r\n        return new Double(((double[]) array)[index]);\r\n    }\r\n    if (array == null) {\r\n        throw new NullPointerException(\"array == null\");\r\n    }\r\n    throw notAnArray(array);\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicLongFieldUpdater.getAndDecrement",
	"Comment": "atomically decrements by one the current value of the field of thegiven object managed by this updater.",
	"Method": "long getAndDecrement(T obj,long getAndDecrement,T obj){\r\n    long prev, next;\r\n    do {\r\n        prev = get(obj);\r\n        next = prev - 1;\r\n    } while (!compareAndSet(obj, prev, next));\r\n    return prev;\r\n}"
}, {
	"Path": "java.io.PushbackInputStream.skip",
	"Comment": "skips over and discards n bytes of data from thisinput stream. the skip method may, for a variety ofreasons, end up skipping over some smaller number of bytes,possibly zero.if n is negative, no bytes are skipped. the skip method of pushbackinputstreamfirst skips over the bytes in the pushback buffer, if any.it thencalls the skip method of the underlying input stream ifmore bytes need to be skipped.the actual number of bytes skippedis returned.",
	"Method": "long skip(long n){\r\n    ensureOpen();\r\n    if (n <= 0) {\r\n        return 0;\r\n    }\r\n    long pskip = buf.length - pos;\r\n    if (pskip > 0) {\r\n        if (n < pskip) {\r\n            pskip = n;\r\n        }\r\n        pos += pskip;\r\n        n -= pskip;\r\n    }\r\n    if (n > 0) {\r\n        pskip += super.skip(n);\r\n    }\r\n    return pskip;\r\n}"
}, {
	"Path": "android.icu.dev.test.timezone.TimeZoneRuleTest.compareTransitionsAscending",
	"Comment": "compare all time transitions in 2 time zones in the specified time range in ascending order",
	"Method": "void compareTransitionsAscending(TimeZone tz1,TimeZone tz2,long start,long end,boolean inclusive){\r\n    BasicTimeZone z1 = (BasicTimeZone) tz1;\r\n    BasicTimeZone z2 = (BasicTimeZone) tz2;\r\n    String zid1 = tz1.getID();\r\n    String zid2 = tz2.getID();\r\n    long time = start;\r\n    while (true) {\r\n        TimeZoneTransition tzt1 = z1.getNextTransition(time, inclusive);\r\n        TimeZoneTransition tzt2 = z2.getNextTransition(time, inclusive);\r\n        boolean inRange1 = false;\r\n        boolean inRange2 = false;\r\n        if (tzt1 != null) {\r\n            if (tzt1.getTime() < end || (inclusive && tzt1.getTime() == end)) {\r\n                inRange1 = true;\r\n            }\r\n        }\r\n        if (tzt2 != null) {\r\n            if (tzt2.getTime() < end || (inclusive && tzt2.getTime() == end)) {\r\n                inRange2 = true;\r\n            }\r\n        }\r\n        if (!inRange1 && !inRange2) {\r\n            break;\r\n        }\r\n        if (!inRange1) {\r\n            errln(\"FAIL: \" + zid1 + \" does not have any transitions after \" + time + \" before \" + end);\r\n            break;\r\n        }\r\n        if (!inRange2) {\r\n            errln(\"FAIL: \" + zid2 + \" does not have any transitions after \" + time + \" before \" + end);\r\n            break;\r\n        }\r\n        if (tzt1.getTime() != tzt2.getTime()) {\r\n            errln(\"FAIL: First transition after \" + time + \" \" + zid1 + \"[\" + tzt1.getTime() + \"] \" + zid2 + \"[\" + tzt2.getTime() + \"]\");\r\n            break;\r\n        }\r\n        time = tzt1.getTime();\r\n        if (inclusive) {\r\n            time++;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.ZipInputStream.getNextEntry",
	"Comment": "reads the next zip file entry and positions the stream at thebeginning of the entry data.",
	"Method": "ZipEntry getNextEntry(){\r\n    ensureOpen();\r\n    if (entry != null) {\r\n        closeEntry();\r\n    }\r\n    crc.reset();\r\n    inf.reset();\r\n    if ((entry = readLOC()) == null) {\r\n        return null;\r\n    }\r\n    if (entry.method == STORED || entry.method == DEFLATED) {\r\n        remaining = entry.size;\r\n    }\r\n    entryEOF = false;\r\n    return entry;\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.divide",
	"Comment": "internally usedto calculate the quotient of this div v and places thequotient in the provided mutablebiginteger object and the remainder isreturned.",
	"Method": "MutableBigInteger divide(MutableBigInteger b,MutableBigInteger quotient,MutableBigInteger divide,MutableBigInteger b,MutableBigInteger quotient,boolean needRemainder,long divide,long v,MutableBigInteger quotient){\r\n    if (v == 0)\r\n        throw new ArithmeticException(\"BigInteger divide by zero\");\r\n    if (intLen == 0) {\r\n        quotient.intLen = quotient.offset = 0;\r\n        return 0;\r\n    }\r\n    if (v < 0)\r\n        v = -v;\r\n    int d = (int) (v >>> 32);\r\n    quotient.clear();\r\n    if (d == 0)\r\n        return divideOneWord((int) v, quotient) & LONG_MASK;\r\n    else {\r\n        return divideLongMagnitude(v, quotient).toLong();\r\n    }\r\n}"
}, {
	"Path": "java.util.jar.JarInputStream.getNextEntry",
	"Comment": "reads the next zip file entry and positions the stream at thebeginning of the entry data. if verification has been enabled,any invalid signature detected while positioning the stream forthe next entry will result in an exception.",
	"Method": "ZipEntry getNextEntry(){\r\n    JarEntry e;\r\n    if (first == null) {\r\n        e = (JarEntry) super.getNextEntry();\r\n        if (tryManifest) {\r\n            e = checkManifest(e);\r\n            tryManifest = false;\r\n        }\r\n    } else {\r\n        e = first;\r\n        if (first.getName().equalsIgnoreCase(INDEX_NAME))\r\n            tryManifest = true;\r\n        first = null;\r\n    }\r\n    if (jv != null && e != null) {\r\n        if (jv.nothingToVerify() == true) {\r\n            jv = null;\r\n            mev = null;\r\n        } else {\r\n            jv.beginEntry(e, mev);\r\n        }\r\n    }\r\n    return e;\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.divideOneWord",
	"Comment": "this method is used for division of an n word dividend by a one worddivisor. the quotient is placed into quotient. the one word divisor isspecified by divisor.",
	"Method": "int divideOneWord(int divisor,MutableBigInteger quotient){\r\n    long divisorLong = divisor & LONG_MASK;\r\n    if (intLen == 1) {\r\n        long dividendValue = value[offset] & LONG_MASK;\r\n        int q = (int) (dividendValue / divisorLong);\r\n        int r = (int) (dividendValue - q * divisorLong);\r\n        quotient.value[0] = q;\r\n        quotient.intLen = (q == 0) ? 0 : 1;\r\n        quotient.offset = 0;\r\n        return r;\r\n    }\r\n    if (quotient.value.length < intLen)\r\n        quotient.value = new int[intLen];\r\n    quotient.offset = 0;\r\n    quotient.intLen = intLen;\r\n    int shift = Integer.numberOfLeadingZeros(divisor);\r\n    int rem = value[offset];\r\n    long remLong = rem & LONG_MASK;\r\n    if (remLong < divisorLong) {\r\n        quotient.value[0] = 0;\r\n    } else {\r\n        quotient.value[0] = (int) (remLong / divisorLong);\r\n        rem = (int) (remLong - (quotient.value[0] * divisorLong));\r\n        remLong = rem & LONG_MASK;\r\n    }\r\n    int xlen = intLen;\r\n    while (--xlen > 0) {\r\n        long dividendEstimate = (remLong << 32) | (value[offset + intLen - xlen] & LONG_MASK);\r\n        int q;\r\n        if (dividendEstimate >= 0) {\r\n            q = (int) (dividendEstimate / divisorLong);\r\n            rem = (int) (dividendEstimate - q * divisorLong);\r\n        } else {\r\n            long tmp = divWord(dividendEstimate, divisor);\r\n            q = (int) (tmp & LONG_MASK);\r\n            rem = (int) (tmp >>> 32);\r\n        }\r\n        quotient.value[intLen - xlen] = q;\r\n        remLong = rem & LONG_MASK;\r\n    }\r\n    quotient.normalize();\r\n    if (shift > 0)\r\n        return rem % divisor;\r\n    else\r\n        return rem;\r\n}"
}, {
	"Path": "java.util.StringTokenizer.nextElement",
	"Comment": "returns the same value as the nexttoken method,except that its declared return value is object rather thanstring. it exists so that this class can implement theenumeration interface.",
	"Method": "Object nextElement(){\r\n    return nextToken();\r\n}"
}, {
	"Path": "java.util.zip.InflaterInputStream.close",
	"Comment": "closes this input stream and releases any system resources associatedwith the stream.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        inf.end();\r\n        in.close();\r\n        closed = true;\r\n    }\r\n}"
}, {
	"Path": "java.text.FieldPosition.matchesField",
	"Comment": "return true if the receiver wants a format.field value andattribute is equal to it, or true if the receiverrepresents an inteter constant and field equals it.",
	"Method": "boolean matchesField(Format.Field attribute,boolean matchesField,Format.Field attribute,int field){\r\n    if (this.attribute != null) {\r\n        return this.attribute.equals(attribute);\r\n    }\r\n    return (field == this.field);\r\n}"
}, {
	"Path": "java.net.Proxy.equals",
	"Comment": "compares this object against the specified object.the result is true if and only if the argument isnot null and it represents the same proxy asthis object.two instances of proxy represent the sameaddress if both the socketaddresses and type are equal.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == null || !(obj instanceof Proxy))\r\n        return false;\r\n    Proxy p = (Proxy) obj;\r\n    if (p.type() == type()) {\r\n        if (address() == null) {\r\n            return (p.address() == null);\r\n        } else\r\n            return address().equals(p.address());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.TypeDeclarationGeneratorTest.testEmptyStatementsIgnored",
	"Comment": "the jdt parser discards them, while javac includes them in the compilation unit.",
	"Method": "void testEmptyStatementsIgnored(){\r\n    String source = \"public interface A { void bar(); };\";\r\n    CompilationUnit unit = translateType(\"A\", source);\r\n    assertEquals(1, unit.getTypes().size());\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testAwaitAdvance2",
	"Comment": "awaitadvance with a negative parameter will return without affecting thephaser",
	"Method": "void testAwaitAdvance2(){\r\n    Phaser phaser = new Phaser();\r\n    assertTrue(phaser.awaitAdvance(-1) < 0);\r\n    assertState(phaser, 0, 0, 0);\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testAwaitAdvance4",
	"Comment": "awaitadvance atomically waits for all parties within the same phase tocomplete before continuing",
	"Method": "void testAwaitAdvance4(){\r\n    final Phaser phaser = new Phaser(4);\r\n    final AtomicInteger count = new AtomicInteger(0);\r\n    List<Thread> threads = new ArrayList<Thread>();\r\n    for (int i = 0; i < 4; i++) threads.add(newStartedThread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            for (int k = 0; k < 3; k++) {\r\n                assertEquals(2 * k + 1, phaser.arriveAndAwaitAdvance());\r\n                count.incrementAndGet();\r\n                assertEquals(2 * k + 1, phaser.arrive());\r\n                assertEquals(2 * k + 2, phaser.awaitAdvance(2 * k + 1));\r\n                assertEquals(4 * (k + 1), count.get());\r\n            }\r\n        }\r\n    }));\r\n    for (Thread thread : threads) awaitTermination(thread);\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testAwaitAdvance4",
	"Comment": "awaitadvance atomically waits for all parties within the same phase tocomplete before continuing",
	"Method": "void testAwaitAdvance4(){\r\n    for (int k = 0; k < 3; k++) {\r\n        assertEquals(2 * k + 1, phaser.arriveAndAwaitAdvance());\r\n        count.incrementAndGet();\r\n        assertEquals(2 * k + 1, phaser.arrive());\r\n        assertEquals(2 * k + 2, phaser.awaitAdvance(2 * k + 1));\r\n        assertEquals(4 * (k + 1), count.get());\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testGetExclusiveQueuedThreads",
	"Comment": "getexclusivequeuedthreads returns all exclusive waiting threads",
	"Method": "void testGetExclusiveQueuedThreads(){\r\n    final Mutex sync = new Mutex();\r\n    Thread t1 = new Thread(new InterruptedSyncRunnable(sync));\r\n    Thread t2 = new Thread(new InterruptibleSyncRunnable(sync));\r\n    assertHasExclusiveQueuedThreads(sync, NO_THREADS);\r\n    sync.acquire();\r\n    assertHasExclusiveQueuedThreads(sync, NO_THREADS);\r\n    t1.start();\r\n    waitForQueuedThread(sync, t1);\r\n    assertHasExclusiveQueuedThreads(sync, t1);\r\n    assertTrue(sync.getExclusiveQueuedThreads().contains(t1));\r\n    assertFalse(sync.getExclusiveQueuedThreads().contains(t2));\r\n    t2.start();\r\n    waitForQueuedThread(sync, t2);\r\n    assertHasExclusiveQueuedThreads(sync, t1, t2);\r\n    assertTrue(sync.getExclusiveQueuedThreads().contains(t1));\r\n    assertTrue(sync.getExclusiveQueuedThreads().contains(t2));\r\n    t1.interrupt();\r\n    awaitTermination(t1);\r\n    assertHasExclusiveQueuedThreads(sync, t2);\r\n    sync.release();\r\n    awaitTermination(t2);\r\n    assertHasExclusiveQueuedThreads(sync, NO_THREADS);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkQuietlyJoinCC",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoinCC(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingCCF f = new LFCCF(null, 8);\r\n            assertSame(f, f.fork());\r\n            f.quietlyJoin();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkQuietlyJoinCC",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoinCC(){\r\n    FailingCCF f = new LFCCF(null, 8);\r\n    assertSame(f, f.fork());\r\n    f.quietlyJoin();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n}"
}, {
	"Path": "java.time.zone.ZoneOffsetTransitionRule.getMonth",
	"Comment": "gets the month of the transition.if the rule defines an exact date then the month is the month of that date.if the rule defines a week where the transition might occur, then the monthif the month of either the earliest or latest possible date of the cutover.",
	"Method": "Month getMonth(){\r\n    return month;\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testAwaitAdvance6",
	"Comment": "awaitadvance returns when the phaser is externally terminated",
	"Method": "void testAwaitAdvance6(){\r\n    final Phaser phaser = new Phaser(3);\r\n    final CountDownLatch pleaseForceTermination = new CountDownLatch(2);\r\n    final List<Thread> threads = new ArrayList<Thread>();\r\n    for (int i = 0; i < 2; i++) {\r\n        Runnable r = new CheckedRunnable() {\r\n            public void realRun() {\r\n                assertEquals(0, phaser.arrive());\r\n                pleaseForceTermination.countDown();\r\n                assertTrue(phaser.awaitAdvance(0) < 0);\r\n                assertTrue(phaser.isTerminated());\r\n                assertTrue(phaser.getPhase() < 0);\r\n                assertEquals(0, phaser.getPhase() + Integer.MIN_VALUE);\r\n                assertEquals(3, phaser.getRegisteredParties());\r\n            }\r\n        };\r\n        threads.add(newStartedThread(r));\r\n    }\r\n    await(pleaseForceTermination);\r\n    phaser.forceTermination();\r\n    assertTrue(phaser.isTerminated());\r\n    assertEquals(0, phaser.getPhase() + Integer.MIN_VALUE);\r\n    for (Thread thread : threads) awaitTermination(thread);\r\n    assertEquals(3, phaser.getRegisteredParties());\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testAwaitAdvance6",
	"Comment": "awaitadvance returns when the phaser is externally terminated",
	"Method": "void testAwaitAdvance6(){\r\n    assertEquals(0, phaser.arrive());\r\n    pleaseForceTermination.countDown();\r\n    assertTrue(phaser.awaitAdvance(0) < 0);\r\n    assertTrue(phaser.isTerminated());\r\n    assertTrue(phaser.getPhase() < 0);\r\n    assertEquals(0, phaser.getPhase() + Integer.MIN_VALUE);\r\n    assertEquals(3, phaser.getRegisteredParties());\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberFormatTest.TestFormatAbstractImplCoverage",
	"Comment": "coverage tests for the implementation of abstract format methods not being called otherwise",
	"Method": "void TestFormatAbstractImplCoverage(){\r\n    NumberFormat df = DecimalFormat.getInstance(Locale.ENGLISH);\r\n    NumberFormat cdf = CompactDecimalFormat.getInstance(Locale.ENGLISH, CompactDecimalFormat.CompactStyle.SHORT);\r\n    NumberFormat rbf = new RuleBasedNumberFormat(ULocale.ENGLISH, RuleBasedNumberFormat.SPELLOUT);\r\n    StringBuffer sb = new StringBuffer();\r\n    String result = df.format(new BigDecimal(2000.43), sb, new FieldPosition(0)).toString();\r\n    if (!\"2,000.43\".equals(result)) {\r\n        errln(\"DecimalFormat failed. Expected: 2,000.43 - Actual: \" + result);\r\n    }\r\n    sb.delete(0, sb.length());\r\n    result = cdf.format(new BigDecimal(2000.43), sb, new FieldPosition(0)).toString();\r\n    if (!\"2K\".equals(result)) {\r\n        errln(\"DecimalFormat failed. Expected: 2K - Actual: \" + result);\r\n    }\r\n    sb.delete(0, sb.length());\r\n    result = rbf.format(new BigDecimal(2000.43), sb, new FieldPosition(0)).toString();\r\n    if (!\"two thousand point four three\".equals(result)) {\r\n        errln(\"DecimalFormat failed. Expected: 'two thousand point four three' - Actual: '\" + result + \"'\");\r\n    }\r\n}"
}, {
	"Path": "jsr166.ConcurrentHashMapTest.testReplaceValue2",
	"Comment": "replace value succeeds when the given key mapped to expected value",
	"Method": "void testReplaceValue2(){\r\n    ConcurrentHashMap map = map5();\r\n    assertEquals(\"A\", map.get(one));\r\n    assertTrue(map.replace(one, \"A\", \"Z\"));\r\n    assertEquals(\"Z\", map.get(one));\r\n}"
}, {
	"Path": "okio.Segment.compact",
	"Comment": "call this when the tail and its predecessor may both be less than halffull. this will copy data so that segments can be recycled.",
	"Method": "void compact(){\r\n    if (prev == this)\r\n        throw new IllegalStateException();\r\n    if (!prev.owner)\r\n        return;\r\n    int byteCount = limit - pos;\r\n    int availableByteCount = SIZE - prev.limit + (prev.shared ? 0 : prev.pos);\r\n    if (byteCount > availableByteCount)\r\n        return;\r\n    writeTo(prev, byteCount);\r\n    pop();\r\n    SegmentPool.recycle(this);\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingQueueTest.testConstructor6",
	"Comment": "queue contains all elements of collection used to initialize",
	"Method": "void testConstructor6(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = new Integer(i);\r\n    LinkedBlockingQueue q = new LinkedBlockingQueue(Arrays.asList(ints));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingQueueTest.testConstructor5",
	"Comment": "initializing from collection with some null elements throwsnullpointerexception",
	"Method": "void testConstructor5(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    Collection<Integer> elements = Arrays.asList(ints);\r\n    try {\r\n        new LinkedBlockingQueue(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingQueueTest.testConstructor4",
	"Comment": "initializing from collection of null elements throws nullpointerexception",
	"Method": "void testConstructor4(){\r\n    Collection<Integer> elements = Arrays.asList(new Integer[SIZE]);\r\n    try {\r\n        new LinkedBlockingQueue(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.PolicyNodeImpl.addExpectedPolicy",
	"Comment": "adds an expectedpolicy to the expected policy set.if this is the original expected policy set initializedby the constructor, then the expected policy set is clearedbefore the expected policy is added.",
	"Method": "void addExpectedPolicy(String expectedPolicy){\r\n    if (isImmutable) {\r\n        throw new IllegalStateException(\"PolicyNode is immutable\");\r\n    }\r\n    if (mOriginalExpectedPolicySet) {\r\n        mExpectedPolicySet.clear();\r\n        mOriginalExpectedPolicySet = false;\r\n    }\r\n    mExpectedPolicySet.add(expectedPolicy);\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingQueueTest.testConstructor3",
	"Comment": "initializing from null collection throws nullpointerexception",
	"Method": "void testConstructor3(){\r\n    try {\r\n        new LinkedBlockingQueue(null);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingQueueTest.testConstructor2",
	"Comment": "constructor throws illegalargumentexception if capacity argument nonpositive",
	"Method": "void testConstructor2(){\r\n    try {\r\n        new LinkedBlockingQueue(0);\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.luni.tests.java.util.LinkedListTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this method\tis called before a test is executed.",
	"Method": "void setUp(){\r\n    super.setUp();\r\n    ll = new LinkedList();\r\n    for (int i = 0; i < objArray.length; i++) {\r\n        ll.add(objArray[i]);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkJoin",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoin(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingFibAction f = new FailingFibAction(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.join();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkJoin",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoin(){\r\n    FailingFibAction f = new FailingFibAction(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.join();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testPrivilegedCallableUsingCCLWithPrivs",
	"Comment": "with class loader permissions, callingprivilegedcallableusingcurrentclassloader does not throw ace",
	"Method": "void testPrivilegedCallableUsingCCLWithPrivs(){\r\n    Runnable r = new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            Executors.privilegedCallableUsingCurrentClassLoader(new NoOpCallable()).call();\r\n        }\r\n    };\r\n    runWithPermissions(r, new RuntimePermission(\"getClassLoader\"), new RuntimePermission(\"setContextClassLoader\"));\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testPrivilegedCallableUsingCCLWithPrivs",
	"Comment": "with class loader permissions, callingprivilegedcallableusingcurrentclassloader does not throw ace",
	"Method": "void testPrivilegedCallableUsingCCLWithPrivs(){\r\n    Executors.privilegedCallableUsingCurrentClassLoader(new NoOpCallable()).call();\r\n}"
}, {
	"Path": "jsr166.ThreadTest.testGetAndSetDefaultUncaughtExceptionHandler",
	"Comment": "getdefaultuncaughtexceptionhandler returns value of lastsetdefaultuncaughtexceptionhandler.",
	"Method": "void testGetAndSetDefaultUncaughtExceptionHandler(){\r\n    Thread.UncaughtExceptionHandler defaultHandler = Thread.getDefaultUncaughtExceptionHandler();\r\n    MyHandler eh = new MyHandler();\r\n    try {\r\n        Thread.setDefaultUncaughtExceptionHandler(eh);\r\n        try {\r\n            assertSame(eh, Thread.getDefaultUncaughtExceptionHandler());\r\n        } finally {\r\n            Thread.setDefaultUncaughtExceptionHandler(defaultHandler);\r\n        }\r\n    } catch (SecurityException ok) {\r\n        assertNotNull(System.getSecurityManager());\r\n    }\r\n    assertSame(defaultHandler, Thread.getDefaultUncaughtExceptionHandler());\r\n}"
}, {
	"Path": "libcore.java.util.zip.OldZipFileTest.tearDown",
	"Comment": "tears down the fixture, for example, close a network connection. thismethod is called after a test is executed.",
	"Method": "void tearDown(){\r\n    zfile.close();\r\n}"
}, {
	"Path": "javax.crypto.KeyGenerator.nextSpi",
	"Comment": "update the active spi of this class and return the nextimplementation for failover. if no more implemenations areavailable, this method returns null. however, the active spi ofthis class is never set to null.",
	"Method": "KeyGeneratorSpi nextSpi(KeyGeneratorSpi oldSpi,boolean reinit){\r\n    synchronized (lock) {\r\n        if ((oldSpi != null) && (oldSpi != spi)) {\r\n            return spi;\r\n        }\r\n        if (serviceIterator == null) {\r\n            return null;\r\n        }\r\n        while (serviceIterator.hasNext()) {\r\n            Service s = (Service) serviceIterator.next();\r\n            if (JceSecurity.canUseProvider(s.getProvider()) == false) {\r\n                continue;\r\n            }\r\n            try {\r\n                Object inst = s.newInstance(null);\r\n                if (inst instanceof KeyGeneratorSpi == false) {\r\n                    continue;\r\n                }\r\n                KeyGeneratorSpi spi = (KeyGeneratorSpi) inst;\r\n                if (reinit) {\r\n                    if (initType == I_SIZE) {\r\n                        spi.engineInit(initKeySize, initRandom);\r\n                    } else if (initType == I_PARAMS) {\r\n                        spi.engineInit(initParams, initRandom);\r\n                    } else if (initType == I_RANDOM) {\r\n                        spi.engineInit(initRandom);\r\n                    } else if (initType != I_NONE) {\r\n                        throw new AssertionError(\"KeyGenerator initType: \" + initType);\r\n                    }\r\n                }\r\n                provider = s.getProvider();\r\n                this.spi = spi;\r\n                return spi;\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        disableFailover();\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.lang.UCharacterCaseTest.TestCharacter",
	"Comment": "testing the uppercase and lowercase function of ucharacter",
	"Method": "void TestCharacter(){\r\n    for (int i = 0; i < CHARACTER_LOWER_.length; i++) {\r\n        if (UCharacter.isLetter(CHARACTER_LOWER_[i]) && !UCharacter.isLowerCase(CHARACTER_LOWER_[i])) {\r\n            errln(\"FAIL isLowerCase test for \\\%u\" + hex(CHARACTER_LOWER_[i]));\r\n            break;\r\n        }\r\n        if (UCharacter.isLetter(CHARACTER_UPPER_[i]) && !(UCharacter.isUpperCase(CHARACTER_UPPER_[i]) || UCharacter.isTitleCase(CHARACTER_UPPER_[i]))) {\r\n            errln(\"FAIL isUpperCase test for \\\%u\" + hex(CHARACTER_UPPER_[i]));\r\n            break;\r\n        }\r\n        if (CHARACTER_LOWER_[i] != UCharacter.toLowerCase(CHARACTER_UPPER_[i]) || (CHARACTER_UPPER_[i] != UCharacter.toUpperCase(CHARACTER_LOWER_[i]) && CHARACTER_UPPER_[i] != UCharacter.toTitleCase(CHARACTER_LOWER_[i]))) {\r\n            errln(\"FAIL case conversion test for \\\%u\" + hex(CHARACTER_UPPER_[i]) + \" to \\\%u\" + hex(CHARACTER_LOWER_[i]));\r\n            break;\r\n        }\r\n        if (CHARACTER_LOWER_[i] != UCharacter.toLowerCase(CHARACTER_LOWER_[i])) {\r\n            errln(\"FAIL lower case conversion test for \\\%u\" + hex(CHARACTER_LOWER_[i]));\r\n            break;\r\n        }\r\n        if (CHARACTER_UPPER_[i] != UCharacter.toUpperCase(CHARACTER_UPPER_[i]) && CHARACTER_UPPER_[i] != UCharacter.toTitleCase(CHARACTER_UPPER_[i])) {\r\n            errln(\"FAIL upper case conversion test for \\\%u\" + hex(CHARACTER_UPPER_[i]));\r\n            break;\r\n        }\r\n        logln(\"Ok    \\\%u\" + hex(CHARACTER_UPPER_[i]) + \" and \\\%u\" + hex(CHARACTER_LOWER_[i]));\r\n    }\r\n}"
}, {
	"Path": "java.net.Authenticator.getRequestingSite",
	"Comment": "gets the inetaddress of thesite requesting authorization, or nullif not available.",
	"Method": "InetAddress getRequestingSite(){\r\n    return requestingSite;\r\n}"
}, {
	"Path": "javax.net.ssl.HandshakeCompletedEvent.getLocalPrincipal",
	"Comment": "returns the principal that was sent to the peer during handshaking.",
	"Method": "Principal getLocalPrincipal(){\r\n    Principal principal;\r\n    try {\r\n        principal = session.getLocalPrincipal();\r\n    } catch (AbstractMethodError e) {\r\n        principal = null;\r\n        Certificate[] certs = getLocalCertificates();\r\n        if (certs != null) {\r\n            principal = (X500Principal) ((X509Certificate) certs[0]).getSubjectX500Principal();\r\n        }\r\n    }\r\n    return principal;\r\n}"
}, {
	"Path": "sun.security.x509.X500Name.isWithinSubtree",
	"Comment": "compares this name with another and determines ifit is within the subtree of the other. useful forchecking against the name constraints extension.",
	"Method": "boolean isWithinSubtree(X500Name other){\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other == null) {\r\n        return false;\r\n    }\r\n    if (other.names.length == 0) {\r\n        return true;\r\n    }\r\n    if (this.names.length == 0) {\r\n        return false;\r\n    }\r\n    if (names.length < other.names.length) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < other.names.length; i++) {\r\n        if (!names[i].equals(other.names[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "sun.nio.ch.NativeObject.getShort",
	"Comment": "reads a short starting at the given offset from base of this nativeobject.",
	"Method": "short getShort(int offset){\r\n    return unsafe.getShort(offset + address);\r\n}"
}, {
	"Path": "sun.security.x509.Extension.newExtension",
	"Comment": "constructs an extension from individual components of objectidentifier,criticality and the raw encoded extension value.",
	"Method": "Extension newExtension(ObjectIdentifier extensionId,boolean critical,byte[] rawExtensionValue){\r\n    Extension ext = new Extension();\r\n    ext.extensionId = extensionId;\r\n    ext.critical = critical;\r\n    ext.extensionValue = rawExtensionValue;\r\n    return ext;\r\n}"
}, {
	"Path": "java.util.OptionalDouble.orElseThrow",
	"Comment": "return the contained value, if present, otherwise throw an exceptionto be created by the provided supplier.",
	"Method": "double orElseThrow(Supplier<X> exceptionSupplier){\r\n    if (isPresent) {\r\n        return value;\r\n    } else {\r\n        throw exceptionSupplier.get();\r\n    }\r\n}"
}, {
	"Path": "java.util.BitSet.checkRange",
	"Comment": "checks that fromindex ... toindex is a valid range of bit indices.",
	"Method": "void checkRange(int fromIndex,int toIndex){\r\n    if (fromIndex < 0)\r\n        throw new IndexOutOfBoundsException(\"fromIndex < 0: \" + fromIndex);\r\n    if (toIndex < 0)\r\n        throw new IndexOutOfBoundsException(\"toIndex < 0: \" + toIndex);\r\n    if (fromIndex > toIndex)\r\n        throw new IndexOutOfBoundsException(\"fromIndex: \" + fromIndex + \" > toIndex: \" + toIndex);\r\n}"
}, {
	"Path": "sun.security.pkcs.SignerInfo.derEncode",
	"Comment": "der encode this object onto an output stream.implements the derencoder interface.",
	"Method": "void derEncode(OutputStream out){\r\n    DerOutputStream seq = new DerOutputStream();\r\n    seq.putInteger(version);\r\n    DerOutputStream issuerAndSerialNumber = new DerOutputStream();\r\n    issuerName.encode(issuerAndSerialNumber);\r\n    issuerAndSerialNumber.putInteger(certificateSerialNumber);\r\n    seq.write(DerValue.tag_Sequence, issuerAndSerialNumber);\r\n    digestAlgorithmId.encode(seq);\r\n    if (authenticatedAttributes != null)\r\n        authenticatedAttributes.encode((byte) 0xA0, seq);\r\n    digestEncryptionAlgorithmId.encode(seq);\r\n    seq.putOctetString(encryptedDigest);\r\n    if (unauthenticatedAttributes != null)\r\n        unauthenticatedAttributes.encode((byte) 0xA1, seq);\r\n    DerOutputStream tmp = new DerOutputStream();\r\n    tmp.write(DerValue.tag_Sequence, seq);\r\n    out.write(tmp.toByteArray());\r\n}"
}, {
	"Path": "java.net.AbstractPlainDatagramSocketImpl.connect",
	"Comment": "connects a datagram socket to a remote destination. this associates the remoteaddress with the local socket so that datagrams may only be sent to this destinationand received from this destination.",
	"Method": "void connect(InetAddress address,int port){\r\n    BlockGuard.getThreadPolicy().onNetwork();\r\n    connect0(address, port);\r\n    connectedAddress = address;\r\n    connectedPort = port;\r\n    connected = true;\r\n}"
}, {
	"Path": "javax.crypto.spec.RC2ParameterSpec.hashCode",
	"Comment": "calculates a hash code value for the object.objects that are equal will also have the same hashcode.",
	"Method": "int hashCode(){\r\n    int retval = 0;\r\n    if (iv != null) {\r\n        for (int i = 1; i < iv.length; i++) {\r\n            retval += iv[i] * i;\r\n        }\r\n    }\r\n    return (retval += effectiveKeyBits);\r\n}"
}, {
	"Path": "java.util.zip.InflaterInputStream.available",
	"Comment": "returns 0 after eof has been reached, otherwise always return 1.programs should not count on this method to return the actual numberof bytes that could be read without blocking.",
	"Method": "int available(){\r\n    ensureOpen();\r\n    if (reachEOF) {\r\n        return 0;\r\n    } else {\r\n        return 1;\r\n    }\r\n}"
}, {
	"Path": "java.security.spec.EllipticCurve.equals",
	"Comment": "compares this elliptic curve for equality with thespecified object.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj)\r\n        return true;\r\n    if (obj instanceof EllipticCurve) {\r\n        EllipticCurve curve = (EllipticCurve) obj;\r\n        if ((field.equals(curve.field)) && (a.equals(curve.a)) && (b.equals(curve.b))) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.logging.LogManager.doSetParent",
	"Comment": "if necessary, we raise privilege before doing the setparent call.",
	"Method": "void doSetParent(Logger logger,Logger parent){\r\n    logger.setParent(parent);\r\n}"
}, {
	"Path": "sun.security.x509.CertificatePolicyMap.toString",
	"Comment": "returns a printable representation of the certificatepolicyid.",
	"Method": "String toString(){\r\n    String s = \"CertificatePolicyMap: [\\n\" + \"IssuerDomain:\" + issuerDomain.toString() + \"SubjectDomain:\" + subjectDomain.toString() + \"]\\n\";\r\n    return (s);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.ClassFile.getFieldNode",
	"Comment": "returns the procyon field definition for a specified variable,or null if not found.",
	"Method": "FieldDeclaration getFieldNode(String name,String signature){\r\n    for (EntityDeclaration node : type.getMembers()) {\r\n        if (node.getEntityType() == EntityType.FIELD) {\r\n            FieldDeclaration field = (FieldDeclaration) node;\r\n            if (field.getName().equals(name) && signature(field.getReturnType()).equals(signature)) {\r\n                return field;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.util.function.UnaryOperator.identity",
	"Comment": "returns a unary operator that always returns its input argument.",
	"Method": "UnaryOperator<T> identity(){\r\n    return t -> t;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testIntValuePositive3",
	"Comment": "convert a positive biginteger to an integer value. the low digit is negative.",
	"Method": "void testIntValuePositive3(){\r\n    byte[] aBytes = { 56, 13, 78, -12, -5, 56, 100 };\r\n    int sign = 1;\r\n    int resInt = -184862620;\r\n    int aNumber = new BigInteger(sign, aBytes).intValue();\r\n    assertTrue(aNumber == resInt);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testIntValuePositive1",
	"Comment": "convert a positive biginteger to an integer value. the low digit is positive",
	"Method": "void testIntValuePositive1(){\r\n    byte[] aBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3 };\r\n    int resInt = 1496144643;\r\n    int aNumber = new BigInteger(aBytes).intValue();\r\n    assertTrue(aNumber == resInt);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testIntValuePositive2",
	"Comment": "convert a positive biginteger to an integer value. the low digit is positive",
	"Method": "void testIntValuePositive2(){\r\n    byte[] aBytes = { 12, 56, 100 };\r\n    int resInt = 800868;\r\n    int aNumber = new BigInteger(aBytes).intValue();\r\n    assertTrue(aNumber == resInt);\r\n}"
}, {
	"Path": "java.util.PriorityQueue.siftDown",
	"Comment": "inserts item x at position k, maintaining heap invariant bydemoting x down the tree repeatedly until it is less than orequal to its children or is a leaf.",
	"Method": "void siftDown(int k,E x){\r\n    if (comparator != null)\r\n        siftDownUsingComparator(k, x);\r\n    else\r\n        siftDownComparable(k, x);\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testSchedule5",
	"Comment": "schedulewithfixeddelay executes runnable after given initial delay",
	"Method": "void testSchedule5(){\r\n    final CustomExecutor p = new CustomExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        final long startTime = System.nanoTime();\r\n        final CountDownLatch done = new CountDownLatch(1);\r\n        Runnable task = new CheckedRunnable() {\r\n            public void realRun() {\r\n                done.countDown();\r\n                assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n            }\r\n        };\r\n        ScheduledFuture f = p.scheduleWithFixedDelay(task, timeoutMillis(), LONG_DELAY_MS, MILLISECONDS);\r\n        await(done);\r\n        assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n        f.cancel(true);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testSchedule5",
	"Comment": "schedulewithfixeddelay executes runnable after given initial delay",
	"Method": "void testSchedule5(){\r\n    done.countDown();\r\n    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testSchedule4",
	"Comment": "scheduleatfixedrate executes runnable after given initial delay",
	"Method": "void testSchedule4(){\r\n    final CustomExecutor p = new CustomExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        final long startTime = System.nanoTime();\r\n        final CountDownLatch done = new CountDownLatch(1);\r\n        Runnable task = new CheckedRunnable() {\r\n            public void realRun() {\r\n                done.countDown();\r\n                assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n            }\r\n        };\r\n        ScheduledFuture f = p.scheduleAtFixedRate(task, timeoutMillis(), LONG_DELAY_MS, MILLISECONDS);\r\n        await(done);\r\n        assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n        f.cancel(true);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testSchedule4",
	"Comment": "scheduleatfixedrate executes runnable after given initial delay",
	"Method": "void testSchedule4(){\r\n    done.countDown();\r\n    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testReferenceUpdateAndGet",
	"Comment": "atomicreference updateandget updates with supplied function andreturns result.",
	"Method": "void testReferenceUpdateAndGet(){\r\n    AtomicReference<Integer> a = new AtomicReference<Integer>(one);\r\n    assertEquals(new Integer(18), a.updateAndGet(Atomic8Test::addInteger17));\r\n    assertEquals(new Integer(35), a.updateAndGet(Atomic8Test::addInteger17));\r\n    assertEquals(new Integer(35), a.get());\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testSchedule3",
	"Comment": "delayed schedule of runnable successfully executes after delay",
	"Method": "void testSchedule3(){\r\n    final CustomExecutor p = new CustomExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        final long startTime = System.nanoTime();\r\n        final CountDownLatch done = new CountDownLatch(1);\r\n        Runnable task = new CheckedRunnable() {\r\n            public void realRun() {\r\n                done.countDown();\r\n                assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n            }\r\n        };\r\n        Future f = p.schedule(task, timeoutMillis(), MILLISECONDS);\r\n        await(done);\r\n        assertNull(f.get(LONG_DELAY_MS, MILLISECONDS));\r\n        assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testSchedule3",
	"Comment": "delayed schedule of runnable successfully executes after delay",
	"Method": "void testSchedule3(){\r\n    done.countDown();\r\n    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n}"
}, {
	"Path": "java.util.jar.JarFile.getEntry",
	"Comment": "returns the zipentry for the given entry name ornull if not found.",
	"Method": "ZipEntry getEntry(String name){\r\n    ZipEntry ze = super.getEntry(name);\r\n    if (ze != null) {\r\n        return new JarFileEntry(ze);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.dev.util.UnicodeMapIterator.reset",
	"Comment": "sets this iterator to visit the elements of the given set andresets it to the start of that set.the iterator is valid onlyso long as set is valid.",
	"Method": "void reset(UnicodeMap set,UnicodeMapIterator<T> reset){\r\n    endRange = map.getRangeCount() - 1;\r\n    nextElement = 0;\r\n    endElement = -1;\r\n    range = -1;\r\n    stringIterator = null;\r\n    Set<String> strings = map.getNonRangeStrings();\r\n    if (strings != null) {\r\n        stringIterator = strings.iterator();\r\n        if (!stringIterator.hasNext())\r\n            stringIterator = null;\r\n    }\r\n    value = null;\r\n    return this;\r\n}"
}, {
	"Path": "java.util.logging.Logger.getResourceBundleName",
	"Comment": "retrieve the localization resource bundle name for thislogger.note that if the result is null, then the loggerwill use a resource bundle name inherited from its parent.",
	"Method": "String getResourceBundleName(){\r\n    return resourceBundleName;\r\n}"
}, {
	"Path": "org.apache.harmony.security.tests.support.TestCertUtils.getCert",
	"Comment": "returns new instance of test certificate each time the method is called.",
	"Method": "Certificate getCert(){\r\n    return new TestCertificate();\r\n}"
}, {
	"Path": "jsr166.ArrayBlockingQueueTest.testInterruptedTimedPoll",
	"Comment": "interrupted timed poll throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPoll(){\r\n    final BlockingQueue<Integer> q = populatedQueue(SIZE);\r\n    final CountDownLatch aboutToWait = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            long startTime = System.nanoTime();\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n            }\r\n            aboutToWait.countDown();\r\n            try {\r\n                q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n                assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n            }\r\n        }\r\n    });\r\n    await(aboutToWait);\r\n    waitForThreadToEnterWaitState(t, LONG_DELAY_MS);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "jsr166.ArrayBlockingQueueTest.testInterruptedTimedPoll",
	"Comment": "interrupted timed poll throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPoll(){\r\n    long startTime = System.nanoTime();\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n    }\r\n    aboutToWait.countDown();\r\n    try {\r\n        q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n        assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testShutdownNow",
	"Comment": "shutdownnow returns a list containing tasks that were not run,and those tasks are drained from the queue",
	"Method": "void testShutdownNow(){\r\n    final int poolSize = 2;\r\n    final int count = 5;\r\n    final AtomicInteger ran = new AtomicInteger(0);\r\n    final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(poolSize);\r\n    final CountDownLatch threadsStarted = new CountDownLatch(poolSize);\r\n    Runnable waiter = new CheckedRunnable() {\r\n        public void realRun() {\r\n            threadsStarted.countDown();\r\n            try {\r\n                MILLISECONDS.sleep(2 * LONG_DELAY_MS);\r\n            } catch (InterruptedException success) {\r\n            }\r\n            ran.getAndIncrement();\r\n        }\r\n    };\r\n    for (int i = 0; i < count; i++) p.execute(waiter);\r\n    await(threadsStarted);\r\n    assertEquals(poolSize, p.getActiveCount());\r\n    assertEquals(0, p.getCompletedTaskCount());\r\n    final List<Runnable> queuedTasks;\r\n    try {\r\n        queuedTasks = p.shutdownNow();\r\n    } catch (SecurityException ok) {\r\n        return;\r\n    }\r\n    assertTrue(p.isShutdown());\r\n    assertTrue(p.getQueue().isEmpty());\r\n    assertEquals(count - poolSize, queuedTasks.size());\r\n    assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));\r\n    assertTrue(p.isTerminated());\r\n    assertEquals(poolSize, ran.get());\r\n    assertEquals(poolSize, p.getCompletedTaskCount());\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testShutdownNow",
	"Comment": "shutdownnow returns a list containing tasks that were not run,and those tasks are drained from the queue",
	"Method": "void testShutdownNow(){\r\n    threadsStarted.countDown();\r\n    try {\r\n        MILLISECONDS.sleep(2 * LONG_DELAY_MS);\r\n    } catch (InterruptedException success) {\r\n    }\r\n    ran.getAndIncrement();\r\n}"
}, {
	"Path": "libcore.java.text.NumberFormatTest.test_currencyWithPatternDigits",
	"Comment": "test the setting of locale specific patterns which have different fractional digits.",
	"Method": "void test_currencyWithPatternDigits(){\r\n    if (!EnvironmentUtil.onMacOSX() || EnvironmentUtil.onMinimumOSVersion(\"10.12\")) {\r\n        NumberFormat nf = NumberFormat.getCurrencyInstance(Locale.JAPAN);\r\n        String result = nf.format(50.00);\r\n        assertTrue(result.equals(\"?50\") || result.equals(\"50\"));\r\n        nf = NumberFormat.getCurrencyInstance(Locale.forLanguageTag(\"hy-AM\"));\r\n        result = nf.format(50.00);\r\n        assertTrue(result.equals(\"?50\") || result.equals(\"50?\"));\r\n        nf = NumberFormat.getCurrencyInstance(Locale.forLanguageTag(\"de-CH\"));\r\n        assertEquals(\"CHF?50.00\", nf.format(50.00));\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.assertHasWaitersLocked",
	"Comment": "checks that condition c has exactly the given waiter threads.",
	"Method": "void assertHasWaitersLocked(Mutex sync,ConditionObject c,Thread threads){\r\n    assertEquals(threads.length > 0, sync.hasWaiters(c));\r\n    assertEquals(threads.length, sync.getWaitQueueLength(c));\r\n    assertEquals(threads.length == 0, sync.getWaitingThreads(c).isEmpty());\r\n    assertEquals(threads.length, sync.getWaitingThreads(c).size());\r\n    assertEquals(new HashSet<Thread>(sync.getWaitingThreads(c)), new HashSet<Thread>(Arrays.asList(threads)));\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testAddAllAbsent",
	"Comment": "addallabsent adds each element from the given collection that did notalready exist in the list",
	"Method": "void testAddAllAbsent(){\r\n    CopyOnWriteArrayList full = populatedArray(3);\r\n    assertEquals(2, full.addAllAbsent(Arrays.asList(three, four, one)));\r\n    assertEquals(5, full.size());\r\n    assertEquals(0, full.addAllAbsent(Arrays.asList(three, four, one)));\r\n    assertEquals(5, full.size());\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceEntriesToLong",
	"Comment": "returns the result of accumulating the given transformationof all entries using the given reducer to combine values,and the given basis as an identity value.",
	"Method": "long reduceEntriesToLong(long parallelismThreshold,ToLongFunction<Map.Entry<K, V>> transformer,long basis,LongBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceEntriesToLongTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test428003",
	"Comment": "expression when preceded by another explicit lambda expression",
	"Method": "void test428003(){\r\n    this.runConformTest(new String[] { \"X.java\", \"import java.util.Arrays;\\n\" + \"public class X {\\n\" + \"    public static void main(String[] args) {\\n\" + \"        Arrays.sort(args, (String x, String y) -> x.length() - y.length());\\n\" + \"        Arrays.sort(args, (x, y) -> Integer.compare(x.length(), y.length()));\\n\" + \"    }\\n\" + \"}\\n\" }, \"\");\r\n}"
}, {
	"Path": "java.security.cert.PolicyQualifierInfo.getEncoded",
	"Comment": "returns the asn.1 der encoded form of thispolicyqualifierinfo.",
	"Method": "byte[] getEncoded(){\r\n    return mEncoded.clone();\r\n}"
}, {
	"Path": "sun.security.provider.certpath.PolicyNodeImpl.getPolicyNodesValid",
	"Comment": "finds all nodes at the specified depth that contains thespecified valid oid",
	"Method": "Set<PolicyNodeImpl> getPolicyNodesValid(int depth,String validOID){\r\n    HashSet<PolicyNodeImpl> set = new HashSet();\r\n    if (mDepth < depth) {\r\n        for (PolicyNodeImpl node : mChildren) {\r\n            set.addAll(node.getPolicyNodesValid(depth, validOID));\r\n        }\r\n    } else {\r\n        if (mValidPolicy.equals(validOID))\r\n            set.add(this);\r\n    }\r\n    return set;\r\n}"
}, {
	"Path": "java.util.logging.LogRecord.getResourceBundleName",
	"Comment": "get the localization resource bundle namethis is the name for the resourcebundle that should beused to localize the message string before formatting it.the result may be null if the message is not localizable.",
	"Method": "String getResourceBundleName(){\r\n    return resourceBundleName;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.nio.channels.DatagramChannelTest.test_bind_socketSync",
	"Comment": "checks that the socketchannel and associated socket agree on the socket state.",
	"Method": "void test_bind_socketSync(){\r\n    DatagramChannel dc = DatagramChannel.open();\r\n    assertNull(dc.socket().getLocalSocketAddress());\r\n    DatagramSocket socket = dc.socket();\r\n    assertNull(socket.getLocalSocketAddress());\r\n    assertFalse(socket.isBound());\r\n    InetSocketAddress bindAddr = new InetSocketAddress(\"localhost\", 0);\r\n    dc.socket().bind(bindAddr);\r\n    InetSocketAddress actualAddr = (InetSocketAddress) dc.socket().getLocalSocketAddress();\r\n    assertEquals(actualAddr, socket.getLocalSocketAddress());\r\n    assertEquals(bindAddr.getHostName(), actualAddr.getHostName());\r\n    assertTrue(socket.isBound());\r\n    assertFalse(socket.isConnected());\r\n    assertFalse(socket.isClosed());\r\n    dc.close();\r\n    assertFalse(dc.isOpen());\r\n    assertTrue(socket.isClosed());\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkTimedGetSingleton",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGetSingleton(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FailingCCF f = new LFCCF(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkTimedGetSingleton",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGetSingleton(){\r\n    FailingCCF f = new LFCCF(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingQueueTest.testSerialization",
	"Comment": "a deserialized serialized queue has same elements in same order",
	"Method": "void testSerialization(){\r\n    if (ReflectionUtil.isJreReflectionStripped()) {\r\n        return;\r\n    }\r\n    Queue x = populatedQueue(SIZE);\r\n    Queue y = serialClone(x);\r\n    assertNotSame(x, y);\r\n    assertEquals(x.size(), y.size());\r\n    assertEquals(x.toString(), y.toString());\r\n    assertTrue(Arrays.equals(x.toArray(), y.toArray()));\r\n    while (!x.isEmpty()) {\r\n        assertFalse(y.isEmpty());\r\n        assertEquals(x.remove(), y.remove());\r\n    }\r\n    assertTrue(y.isEmpty());\r\n}"
}, {
	"Path": "android.icu.dev.test.util.CharsTrieTest.checkNextString",
	"Comment": "but here we try to go partway through the string, and then beyond it.",
	"Method": "void checkNextString(CharsTrie trie,StringAndValue[] data,int dataLength){\r\n    for (int i = 0; i < dataLength; ++i) {\r\n        String expectedString = data[i].s;\r\n        int stringLength = expectedString.length();\r\n        if (!trie.next(expectedString, 0, stringLength / 2).matches()) {\r\n            errln(\"trie.next(up to middle of string)=BytesTrie.Result.NO_MATCH for \" + data[i].s);\r\n            continue;\r\n        }\r\n        trie.next(expectedString, stringLength / 2, stringLength);\r\n        if (trie.next(0).matches()) {\r\n            errln(\"trie.next(string+NUL)!=BytesTrie.Result.NO_MATCH for \" + data[i].s);\r\n        }\r\n        trie.reset();\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.CertId.equals",
	"Comment": "compares this certid for equality with the specifiedobject. two certid objects are considered equal if their hash algorithms,their issuer name and issuer key hash values and their serial numbersare equal.",
	"Method": "boolean equals(Object other){\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other == null || (!(other instanceof CertId))) {\r\n        return false;\r\n    }\r\n    CertId that = (CertId) other;\r\n    if (hashAlgId.equals(that.getHashAlgorithm()) && Arrays.equals(issuerNameHash, that.getIssuerNameHash()) && Arrays.equals(issuerKeyHash, that.getIssuerKeyHash()) && certSerialNumber.getNumber().equals(that.getSerialNumber())) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "sun.security.jca.ProviderList.getJarList",
	"Comment": "construct a special providerlist for jar verification. it consistsof the providers specified via jarclassnames, which must be on thebootclasspath and cannot be in signed jar files. this is to avoidpossible recursion and deadlock during verification.",
	"Method": "ProviderList getJarList(String[] jarClassNames){\r\n    List<ProviderConfig> newConfigs = new ArrayList();\r\n    for (String className : jarClassNames) {\r\n        ProviderConfig newConfig = new ProviderConfig(className);\r\n        for (ProviderConfig config : configs) {\r\n            if (config.equals(newConfig)) {\r\n                newConfig = config;\r\n                break;\r\n            }\r\n        }\r\n        newConfigs.add(newConfig);\r\n    }\r\n    ProviderConfig[] configArray = newConfigs.toArray(PC0);\r\n    return new ProviderList(configArray, false);\r\n}"
}, {
	"Path": "java.lang.ClassLoader.getPackages",
	"Comment": "returns all of the packages defined by this class loader andits ancestors.",
	"Method": "Package[] getPackages(){\r\n    Map<String, Package> map;\r\n    synchronized (packages) {\r\n        map = new HashMap(packages);\r\n    }\r\n    Package[] pkgs;\r\n    return map.values().toArray(new Package[map.size()]);\r\n}"
}, {
	"Path": "sun.net.www.MessageHeader.findValue",
	"Comment": "find the value that corresponds to this key.it finds only the first occurrence of the key.",
	"Method": "String findValue(String k){\r\n    if (k == null) {\r\n        for (int i = nkeys; --i >= 0; ) if (keys[i] == null)\r\n            return values[i];\r\n    } else\r\n        for (int i = nkeys; --i >= 0; ) {\r\n            if (k.equalsIgnoreCase(keys[i]))\r\n                return values[i];\r\n        }\r\n    return null;\r\n}"
}, {
	"Path": "java.text.SimpleDateFormat.hashCode",
	"Comment": "returns the hash code value for this simpledateformat object.",
	"Method": "int hashCode(){\r\n    return pattern.hashCode();\r\n}"
}, {
	"Path": "org.mockito.internal.configuration.ClassPathLoader.findPlatformMockMaker",
	"Comment": "scans the classpath to find a mock maker plugin if one is available,allowing mockito to run on alternative platforms like android.",
	"Method": "MockMaker findPlatformMockMaker(){\r\n    return findPluginImplementation(MockMaker.class, new IosMockMaker());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.TypeDeclarationGeneratorTest.testEnumNullabilityPragmas",
	"Comment": "verify that enums always have nullability completeness suppressed.",
	"Method": "void testEnumNullabilityPragmas(){\r\n    options.setNullability(true);\r\n    String translation = translateSourceFile(\"enum Test { A, B, C; }\", \"Test\", \"Test.h\");\r\n    assertTranslatedLines(translation, \"#if __has_feature(nullability)\", \"#pragma clang diagnostic push\", \"#pragma GCC diagnostic ignored \\\"-Wnullability\\\"\", \"#pragma GCC diagnostic ignored \\\"-Wnullability-completeness\\\"\", \"#endif\");\r\n    assertTranslatedLines(translation, \"#if __has_feature(nullability)\", \"#pragma clang diagnostic pop\", \"#endif\");\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingQueueTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    final BlockingQueue q = populatedQueue(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(i, q.take());\r\n            }\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadStaysAlive(t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingQueueTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(i, q.take());\r\n    }\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n}"
}, {
	"Path": "java.text.DecimalFormat.getMaximumIntegerDigits",
	"Comment": "gets the maximum number of digits allowed in the integer portion of anumber.for formatting numbers other than biginteger andbigdecimal objects, the lower of the return value and309 is used.",
	"Method": "int getMaximumIntegerDigits(){\r\n    return maximumIntegerDigits;\r\n}"
}, {
	"Path": "java.text.AttributedString.valuesMatch",
	"Comment": "returns whether the two objects are either both null or equal",
	"Method": "boolean valuesMatch(Object value1,Object value2){\r\n    if (value1 == null) {\r\n        return value2 == null;\r\n    } else {\r\n        return value1.equals(value2);\r\n    }\r\n}"
}, {
	"Path": "java.nio.IntBuffer.equals",
	"Comment": "tells whether or not this buffer is equal to another object. two int buffers are equal if, and only if, they have the same element type, they have the same number of remaining elements, and the two sequences of remaining elements, consideredindependently of their starting positions, are pointwise equal. a int buffer is not equal to any other type of object.",
	"Method": "boolean equals(Object ob,boolean equals,int x,int y){\r\n    return x == y;\r\n}"
}, {
	"Path": "java.util.jar.JarVerifier.mapSignersToCodeSource",
	"Comment": "create a unique mapping from codesigner cache entries to codesource.in theory, multiple urls origins could map to a single locally cachedand shared jar file although in practice there will be a single url in use.",
	"Method": "CodeSource mapSignersToCodeSource(URL url,CodeSigner[] signers){\r\n    Map map;\r\n    if (url == lastURL) {\r\n        map = lastURLMap;\r\n    } else {\r\n        map = (Map) urlToCodeSourceMap.get(url);\r\n        if (map == null) {\r\n            map = new HashMap();\r\n            urlToCodeSourceMap.put(url, map);\r\n        }\r\n        lastURLMap = map;\r\n        lastURL = url;\r\n    }\r\n    CodeSource cs = (CodeSource) map.get(signers);\r\n    if (cs == null) {\r\n        cs = new VerifierCodeSource(csdomain, url, signers);\r\n        signerToCodeSource.put(signers, cs);\r\n    }\r\n    return cs;\r\n}"
}, {
	"Path": "java.util.concurrent.DelayQueue.poll",
	"Comment": "retrieves and removes the head of this queue, waiting if necessaryuntil an element with an expired delay is available on this queue,or the specified wait time expires.",
	"Method": "E poll(E poll,long timeout,TimeUnit unit){\r\n    long nanos = unit.toNanos(timeout);\r\n    final ReentrantLock lock = this.lock;\r\n    lock.lockInterruptibly();\r\n    try {\r\n        for (; ; ) {\r\n            E first = q.peek();\r\n            if (first == null) {\r\n                if (nanos <= 0L)\r\n                    return null;\r\n                else\r\n                    nanos = available.awaitNanos(nanos);\r\n            } else {\r\n                long delay = first.getDelay(NANOSECONDS);\r\n                if (delay <= 0L)\r\n                    return q.poll();\r\n                if (nanos <= 0L)\r\n                    return null;\r\n                first = null;\r\n                if (nanos < delay || leader != null)\r\n                    nanos = available.awaitNanos(nanos);\r\n                else {\r\n                    Thread thisThread = Thread.currentThread();\r\n                    leader = thisThread;\r\n                    try {\r\n                        long timeLeft = available.awaitNanos(delay);\r\n                        nanos -= delay - timeLeft;\r\n                    } finally {\r\n                        if (leader == thisThread)\r\n                            leader = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        if (leader == null && q.peek() != null)\r\n            available.signal();\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedLongSynchronizer.isOnSyncQueue",
	"Comment": "returns true if a node, always one that was initially placed ona condition queue, is now waiting to reacquire on sync queue.",
	"Method": "boolean isOnSyncQueue(Node node){\r\n    if (node.waitStatus == Node.CONDITION || node.prev == null)\r\n        return false;\r\n    if (node.next != null)\r\n        return true;\r\n    return findNodeFromTail(node);\r\n}"
}, {
	"Path": "java.util.ArrayList.fastRemove",
	"Comment": "private remove method that skips bounds checking and does notreturn the value removed.",
	"Method": "void fastRemove(int index){\r\n    modCount++;\r\n    int numMoved = size - index - 1;\r\n    if (numMoved > 0)\r\n        System.arraycopy(elementData, index + 1, elementData, index, numMoved);\r\n    elementData[--size] = null;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.ConstraintsChecker.checkBasicConstraints",
	"Comment": "internal method to check that a given cert meets basic constraints.",
	"Method": "void checkBasicConstraints(X509Certificate currCert){\r\n    String msg = \"basic constraints\";\r\n    if (debug != null) {\r\n        debug.println(\"---checking \" + msg + \"...\");\r\n        debug.println(\"i = \" + i);\r\n        debug.println(\"maxPathLength = \" + maxPathLength);\r\n    }\r\n    if (i < certPathLength) {\r\n        int pathLenConstraint = -1;\r\n        if (currCert.getVersion() < 3) {\r\n            if (i == 1) {\r\n                if (X509CertImpl.isSelfIssued(currCert)) {\r\n                    pathLenConstraint = Integer.MAX_VALUE;\r\n                }\r\n            }\r\n        } else {\r\n            pathLenConstraint = currCert.getBasicConstraints();\r\n        }\r\n        if (pathLenConstraint == -1) {\r\n            throw new CertPathValidatorException(msg + \" check failed: this is not a CA certificate\", null, null, -1, PKIXReason.NOT_CA_CERT);\r\n        }\r\n        if (!X509CertImpl.isSelfIssued(currCert)) {\r\n            if (maxPathLength <= 0) {\r\n                throw new CertPathValidatorException(msg + \" check failed: pathLenConstraint violated - \" + \"this cert must be the last cert in the \" + \"certification path\", null, null, -1, PKIXReason.PATH_TOO_LONG);\r\n            }\r\n            maxPathLength--;\r\n        }\r\n        if (pathLenConstraint < maxPathLength)\r\n            maxPathLength = pathLenConstraint;\r\n    }\r\n    if (debug != null) {\r\n        debug.println(\"after processing, maxPathLength = \" + maxPathLength);\r\n        debug.println(msg + \" verified.\");\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicLongFieldUpdater.getAndAdd",
	"Comment": "atomically adds the given value to the current value of the field ofthe given object managed by this updater.",
	"Method": "long getAndAdd(T obj,long delta,long getAndAdd,T obj,long delta){\r\n    long prev, next;\r\n    do {\r\n        prev = get(obj);\r\n        next = prev + delta;\r\n    } while (!compareAndSet(obj, prev, next));\r\n    return prev;\r\n}"
}, {
	"Path": "java.util.logging.LogManager.parseClassNames",
	"Comment": "get a list of whitespace separated classnames from a property.",
	"Method": "String[] parseClassNames(String propertyName){\r\n    String hands = getProperty(propertyName);\r\n    if (hands == null) {\r\n        return new String[0];\r\n    }\r\n    hands = hands.trim();\r\n    int ix = 0;\r\n    Vector<String> result = new Vector();\r\n    while (ix < hands.length()) {\r\n        int end = ix;\r\n        while (end < hands.length()) {\r\n            if (Character.isWhitespace(hands.charAt(end))) {\r\n                break;\r\n            }\r\n            if (hands.charAt(end) == ',') {\r\n                break;\r\n            }\r\n            end++;\r\n        }\r\n        String word = hands.substring(ix, end);\r\n        ix = end + 1;\r\n        word = word.trim();\r\n        if (word.length() == 0) {\r\n            continue;\r\n        }\r\n        result.add(word);\r\n    }\r\n    return result.toArray(new String[result.size()]);\r\n}"
}, {
	"Path": "libcore.java.util.SimpleTimeZoneTest.findDstEntryAndExit",
	"Comment": "scan from the start of the year to the end to find the dst transition points.",
	"Method": "long[] findDstEntryAndExit(TimeZone timeZone,long startOfYearMillis){\r\n    if (!timeZone.useDaylightTime()) {\r\n        throw new IllegalStateException(\"Time zone \" + timeZone + \" doesn't support daylight savings time\");\r\n    }\r\n    long[] transitions = new long[2];\r\n    GregorianCalendar cal = new GregorianCalendar(timeZone, Locale.ENGLISH);\r\n    cal.setTimeInMillis(startOfYearMillis);\r\n    int year = cal.get(Calendar.YEAR);\r\n    while (!timeZone.inDaylightTime(new Date(cal.getTimeInMillis()))) {\r\n        if (cal.get(Calendar.YEAR) != year) {\r\n            throw new IllegalStateException(\"Doesn't enter daylight savings time in \" + year + \" in \" + timeZone);\r\n        }\r\n        cal.add(Calendar.HOUR_OF_DAY, 1);\r\n    }\r\n    cal.add(Calendar.MILLISECOND, -1);\r\n    assertFalse(timeZone.inDaylightTime(cal.getTime()));\r\n    cal.add(Calendar.MILLISECOND, 1);\r\n    long entryPoint = cal.getTimeInMillis();\r\n    while (timeZone.inDaylightTime(new Date(cal.getTimeInMillis()))) {\r\n        if (cal.get(Calendar.YEAR) != year) {\r\n            throw new IllegalStateException(\"Doesn't exit daylight savings time in \" + year + \" in \" + timeZone);\r\n        }\r\n        cal.add(Calendar.HOUR_OF_DAY, 1);\r\n    }\r\n    cal.add(Calendar.MILLISECOND, -1);\r\n    assertTrue(timeZone.inDaylightTime(cal.getTime()));\r\n    cal.add(Calendar.MILLISECOND, 1);\r\n    long exitPoint = cal.getTimeInMillis();\r\n    transitions[0] = entryPoint;\r\n    transitions[1] = exitPoint;\r\n    return transitions;\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.getExtensionValue",
	"Comment": "gets the der encoded extension identified by the givenoid string.",
	"Method": "byte[] getExtensionValue(String oid){\r\n    try {\r\n        ObjectIdentifier findOID = new ObjectIdentifier(oid);\r\n        String extAlias = OIDMap.getName(findOID);\r\n        Extension certExt = null;\r\n        CertificateExtensions exts = (CertificateExtensions) info.get(CertificateExtensions.NAME);\r\n        if (extAlias == null) {\r\n            if (exts == null) {\r\n                return null;\r\n            }\r\n            for (Extension ex : exts.getAllExtensions()) {\r\n                ObjectIdentifier inCertOID = ex.getExtensionId();\r\n                if (inCertOID.equals((Object) findOID)) {\r\n                    certExt = ex;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            try {\r\n                certExt = (Extension) this.get(extAlias);\r\n            } catch (CertificateException e) {\r\n            }\r\n        }\r\n        if (certExt == null) {\r\n            if (exts != null) {\r\n                certExt = exts.getUnparseableExtensions().get(oid);\r\n            }\r\n            if (certExt == null) {\r\n                return null;\r\n            }\r\n        }\r\n        byte[] extData = certExt.getExtensionValue();\r\n        if (extData == null) {\r\n            return null;\r\n        }\r\n        DerOutputStream out = new DerOutputStream();\r\n        out.putOctetString(extData);\r\n        return out.toByteArray();\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    Collection<Integer> elements = Arrays.asList(ints);\r\n    try {\r\n        q.addAll(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "org.xml.sax.helpers.XMLFilterImpl.setProperty",
	"Comment": "set the value of a property.this will always fail if the parent is null.",
	"Method": "void setProperty(String name,Object value){\r\n    if (parent != null) {\r\n        parent.setProperty(name, value);\r\n    } else {\r\n        throw new SAXNotRecognizedException(\"Property: \" + name);\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testAddAll5",
	"Comment": "deque contains all elements, in traversal order, of successful addall",
	"Method": "void testAddAll5(){\r\n    Integer[] empty = new Integer[0];\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = new Integer(i);\r\n    LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);\r\n    assertFalse(q.addAll(Arrays.asList(empty)));\r\n    assertTrue(q.addAll(Arrays.asList(ints)));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "java.security.KeyPair.getPrivate",
	"Comment": "returns a reference to the private key component of this key pair.",
	"Method": "PrivateKey getPrivate(){\r\n    return privateKey;\r\n}"
}, {
	"Path": "sun.nio.ch.NativeObject.getDouble",
	"Comment": "reads a double starting at the given offset from base of this nativeobject.",
	"Method": "double getDouble(int offset){\r\n    return unsafe.getDouble(offset + address);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testPeekNextLocalTaskAsync",
	"Comment": "peeknextlocaltask returns least recent unexecuted task in async mode",
	"Method": "void testPeekNextLocalTaskAsync(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib g = new AsyncFib(9);\r\n            assertSame(g, g.fork());\r\n            AsyncFib f = new AsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, peekNextLocalTask());\r\n            assertNull(f.join());\r\n            helpQuiesce();\r\n            checkCompletedNormally(f);\r\n            assertEquals(34, g.number);\r\n            checkCompletedNormally(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(asyncSingletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testPeekNextLocalTaskAsync",
	"Comment": "peeknextlocaltask returns least recent unexecuted task in async mode",
	"Method": "void testPeekNextLocalTaskAsync(){\r\n    AsyncFib g = new AsyncFib(9);\r\n    assertSame(g, g.fork());\r\n    AsyncFib f = new AsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, peekNextLocalTask());\r\n    assertNull(f.join());\r\n    helpQuiesce();\r\n    checkCompletedNormally(f);\r\n    assertEquals(34, g.number);\r\n    checkCompletedNormally(g);\r\n}"
}, {
	"Path": "sun.security.x509.X500Name.getString",
	"Comment": "returns the name component as a java string, regardless of itsencoding restrictions.",
	"Method": "String getString(DerValue attribute){\r\n    if (attribute == null)\r\n        return null;\r\n    String value = attribute.getAsString();\r\n    if (value == null)\r\n        throw new IOException(\"not a DER string encoding, \" + attribute.tag);\r\n    else\r\n        return value;\r\n}"
}, {
	"Path": "java.util.Collections.enumeration",
	"Comment": "returns an enumeration over the specified collection.this providesinteroperability with legacy apis that require an enumerationas input.",
	"Method": "Enumeration<T> enumeration(Collection<T> c){\r\n    return new Enumeration<T>() {\r\n        private final Iterator<T> i = c.iterator();\r\n        public boolean hasMoreElements() {\r\n            return i.hasNext();\r\n        }\r\n        public T nextElement() {\r\n            return i.next();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "java.util.Collections.enumeration",
	"Comment": "returns an enumeration over the specified collection.this providesinteroperability with legacy apis that require an enumerationas input.",
	"Method": "Enumeration<T> enumeration(Collection<T> c){\r\n    return i.hasNext();\r\n}"
}, {
	"Path": "java.util.Collections.enumeration",
	"Comment": "returns an enumeration over the specified collection.this providesinteroperability with legacy apis that require an enumerationas input.",
	"Method": "Enumeration<T> enumeration(Collection<T> c){\r\n    return i.next();\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.normalize",
	"Comment": "ensure that the mutablebiginteger is in normal form, specificallymaking sure that there are no leading zeros, and that if themagnitude is zero, then intlen is zero.",
	"Method": "void normalize(){\r\n    if (intLen == 0) {\r\n        offset = 0;\r\n        return;\r\n    }\r\n    int index = offset;\r\n    if (value[index] != 0)\r\n        return;\r\n    int indexBound = index + intLen;\r\n    do {\r\n        index++;\r\n    } while (index < indexBound && value[index] == 0);\r\n    int numZeros = index - offset;\r\n    intLen -= numZeros;\r\n    offset = (intLen == 0 ? 0 : offset + numZeros);\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testInterruptedTimedPoll",
	"Comment": "interrupted timed poll throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPoll(){\r\n    final BlockingQueue<Integer> q = populatedDeque(SIZE);\r\n    final CountDownLatch aboutToWait = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            long startTime = System.nanoTime();\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n            }\r\n            aboutToWait.countDown();\r\n            try {\r\n                q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n                assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n            }\r\n        }\r\n    });\r\n    aboutToWait.await();\r\n    waitForThreadToEnterWaitState(t, LONG_DELAY_MS);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testInterruptedTimedPoll",
	"Comment": "interrupted timed poll throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPoll(){\r\n    long startTime = System.nanoTime();\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n    }\r\n    aboutToWait.countDown();\r\n    try {\r\n        q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n        assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n    }\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.setDSTSavings",
	"Comment": "sets the amount of time in milliseconds that the clock is advancedduring daylight saving time.",
	"Method": "void setDSTSavings(int millisSavedDuringDST){\r\n    if (millisSavedDuringDST <= 0) {\r\n        throw new IllegalArgumentException(\"Illegal daylight saving value: \" + millisSavedDuringDST);\r\n    }\r\n    dstSavings = millisSavedDuringDST;\r\n}"
}, {
	"Path": "sun.security.x509.OIDMap.addInternal",
	"Comment": "add attributes to the table. for internal use in the staticinitializer.",
	"Method": "void addInternal(String name,ObjectIdentifier oid,Class clazz){\r\n    OIDInfo info = new OIDInfo(name, oid, clazz);\r\n    oidMap.put(oid, info);\r\n    nameMap.put(name, info);\r\n}"
}, {
	"Path": "org.apache.harmony.luni.tests.java.util.LinkedHashSetTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this method\tis called before a test is executed.",
	"Method": "void setUp(){\r\n    hs = new LinkedHashSet();\r\n    for (int i = 0; i < objArray.length; i++) hs.add(objArray[i]);\r\n    hs.add(null);\r\n}"
}, {
	"Path": "java.util.concurrent.SynchronousQueue.offer",
	"Comment": "inserts the specified element into this queue, if another thread iswaiting to receive it.",
	"Method": "boolean offer(E e,long timeout,TimeUnit unit,boolean offer,E e){\r\n    if (e == null)\r\n        throw new NullPointerException();\r\n    return transferer.transfer(e, true, 0) != null;\r\n}"
}, {
	"Path": "java.net.SocketOutputStream.socketWrite",
	"Comment": "writes to the socket with appropriate locking of thefiledescriptor.",
	"Method": "void socketWrite(byte b,int off,int len){\r\n    if (len <= 0 || off < 0 || off + len > b.length) {\r\n        if (len == 0) {\r\n            return;\r\n        }\r\n        throw new ArrayIndexOutOfBoundsException();\r\n    }\r\n    Object traceContext = IoTrace.socketWriteBegin();\r\n    int bytesWritten = 0;\r\n    FileDescriptor fd = impl.acquireFD();\r\n    try {\r\n        BlockGuard.getThreadPolicy().onNetwork();\r\n        socketWrite0(fd, b, off, len);\r\n        bytesWritten = len;\r\n    } catch (SocketException se) {\r\n        if (se instanceof sun.net.ConnectionResetException) {\r\n            impl.setConnectionResetPending();\r\n            se = new SocketException(\"Connection reset\");\r\n        }\r\n        if (impl.isClosedOrPending()) {\r\n            throw new SocketException(\"Socket closed\");\r\n        } else {\r\n            throw se;\r\n        }\r\n    } finally {\r\n        IoTrace.socketWriteEnd(traceContext, impl.address, impl.port, bytesWritten);\r\n    }\r\n}"
}, {
	"Path": "jsr166.PriorityBlockingQueueTest.populatedQueue",
	"Comment": "returns a new queue of given size containing consecutiveintegers 0 ... n.",
	"Method": "PriorityBlockingQueue<Integer> populatedQueue(int n){\r\n    PriorityBlockingQueue<Integer> q = new PriorityBlockingQueue<Integer>(n);\r\n    assertTrue(q.isEmpty());\r\n    for (int i = n - 1; i >= 0; i -= 2) assertTrue(q.offer(new Integer(i)));\r\n    for (int i = (n & 1); i < n; i += 2) assertTrue(q.offer(new Integer(i)));\r\n    assertFalse(q.isEmpty());\r\n    assertEquals(Integer.MAX_VALUE, q.remainingCapacity());\r\n    assertEquals(n, q.size());\r\n    return q;\r\n}"
}, {
	"Path": "java.beans.PropertyChangeListenerProxy.propertyChange",
	"Comment": "forwards the property change event to the listener delegate.",
	"Method": "void propertyChange(PropertyChangeEvent event){\r\n    getListener().propertyChange(event);\r\n}"
}, {
	"Path": "jsr166.DelayQueueTest.testConstructor6",
	"Comment": "queue contains all elements of collection used to initialize",
	"Method": "void testConstructor6(){\r\n    PDelay[] ints = new PDelay[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = new PDelay(i);\r\n    DelayQueue q = new DelayQueue(Arrays.asList(ints));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "java.util.Observable.deleteObserver",
	"Comment": "deletes an observer from the set of observers of this object.passing null to this method will have no effect.",
	"Method": "void deleteObserver(Observer o){\r\n    observers.remove(o);\r\n}"
}, {
	"Path": "jsr166.DelayQueueTest.testConstructor5",
	"Comment": "initializing from collection with some null elements throws npe",
	"Method": "void testConstructor5(){\r\n    PDelay[] a = new PDelay[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) a[i] = new PDelay(i);\r\n    try {\r\n        new DelayQueue(Arrays.asList(a));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.tryPresize",
	"Comment": "tries to presize table to accommodate the given number of elements.",
	"Method": "void tryPresize(int size){\r\n    int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size >>> 1) + 1);\r\n    int sc;\r\n    while ((sc = sizeCtl) >= 0) {\r\n        Node<K, V>[] tab = table;\r\n        int n;\r\n        if (tab == null || (n = tab.length) == 0) {\r\n            n = (sc > c) ? sc : c;\r\n            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\r\n                try {\r\n                    if (table == tab) {\r\n                        @SuppressWarnings(\"unchecked\")\r\n                        Node<K, V>[] nt = (Node<K, V>[]) new Node<?, ?>[n];\r\n                        table = nt;\r\n                        sc = n - (n >>> 2);\r\n                    }\r\n                } finally {\r\n                    sizeCtl = sc;\r\n                }\r\n            }\r\n        } else if (c <= sc || n >= MAXIMUM_CAPACITY)\r\n            break;\r\n        else if (tab == table) {\r\n            int rs = resizeStamp(n);\r\n            if (U.compareAndSwapInt(this, SIZECTL, sc, (rs << RESIZE_STAMP_SHIFT) + 2))\r\n                transfer(tab, null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.jca.GetInstance.checkSuperClass",
	"Comment": "check is subclass is a subclass of superclass. if not,throw a nosuchalgorithmexception.",
	"Method": "void checkSuperClass(Service s,Class subClass,Class superClass){\r\n    if (superClass == null) {\r\n        return;\r\n    }\r\n    if (superClass.isAssignableFrom(subClass) == false) {\r\n        throw new NoSuchAlgorithmException(\"class configured for \" + s.getType() + \": \" + s.getClassName() + \" not a \" + s.getType());\r\n    }\r\n}"
}, {
	"Path": "sun.misc.FloatingDecimal.getHexDigit",
	"Comment": "extracts a hexadecimal digit from position positionof string s.",
	"Method": "int getHexDigit(String s,int position){\r\n    int value = Character.digit(s.charAt(position), 16);\r\n    if (value <= -1 || value >= 16) {\r\n        throw new AssertionError(\"Unexpected failure of digit conversion of \" + s.charAt(position));\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getSubjectPublicKeyAlgID",
	"Comment": "returns the subjectpublickeyalgid criterion. thex509certificate must contain a subject public keywith the specified algorithm. if null, nosubjectpublickeyalgid check will be done.",
	"Method": "String getSubjectPublicKeyAlgID(){\r\n    if (subjectPublicKeyAlgID == null) {\r\n        return null;\r\n    }\r\n    return subjectPublicKeyAlgID.toString();\r\n}"
}, {
	"Path": "java.text.SimpleDateFormat.getDateFormatSymbols",
	"Comment": "gets a copy of the date and time format symbols of this date format.",
	"Method": "DateFormatSymbols getDateFormatSymbols(){\r\n    return (DateFormatSymbols) formatData.clone();\r\n}"
}, {
	"Path": "jsr166.CountDownLatchTest.testGetCount",
	"Comment": "getcount returns initial count and decreases after countdown",
	"Method": "void testGetCount(){\r\n    final CountDownLatch l = new CountDownLatch(2);\r\n    assertEquals(2, l.getCount());\r\n    l.countDown();\r\n    assertEquals(1, l.getCount());\r\n}"
}, {
	"Path": "java.text.DecimalFormat.getNegativePrefixFieldPositions",
	"Comment": "returns the fieldpositions of the fields in the prefix used fornegative numbers. this is not used if the user has explicitly seta negative prefix via setnegativeprefix. this islazily created.",
	"Method": "FieldPosition[] getNegativePrefixFieldPositions(){\r\n    if (negativePrefixFieldPositions == null) {\r\n        if (negPrefixPattern != null) {\r\n            negativePrefixFieldPositions = expandAffix(negPrefixPattern);\r\n        } else {\r\n            negativePrefixFieldPositions = EmptyFieldPositionArray;\r\n        }\r\n    }\r\n    return negativePrefixFieldPositions;\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testSchedule1",
	"Comment": "delayed schedule of callable successfully executes after delay",
	"Method": "void testSchedule1(){\r\n    final CountDownLatch done = new CountDownLatch(1);\r\n    final CustomExecutor p = new CustomExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p, done)) {\r\n        final long startTime = System.nanoTime();\r\n        Callable task = new CheckedCallable<Boolean>() {\r\n            public Boolean realCall() {\r\n                done.countDown();\r\n                assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n                return Boolean.TRUE;\r\n            }\r\n        };\r\n        Future f = p.schedule(task, timeoutMillis(), MILLISECONDS);\r\n        assertSame(Boolean.TRUE, f.get());\r\n        assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testSchedule1",
	"Comment": "delayed schedule of callable successfully executes after delay",
	"Method": "void testSchedule1(){\r\n    done.countDown();\r\n    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n    return Boolean.TRUE;\r\n}"
}, {
	"Path": "java.lang.ref.Reference.isEnqueued",
	"Comment": "tells whether or not this reference object has been enqueued, either bythe program or by the garbage collector.if this reference object wasnot registered with a queue when it was created, then this method willalways return false.",
	"Method": "boolean isEnqueued(){\r\n    return queue != null && queue.isEnqueued(this);\r\n}"
}, {
	"Path": "java.util.Date.setHours",
	"Comment": "sets the hour of this date object to the specified value.this date object is modified so that it represents a pointin time within the specified hour of the day, with the year, month,date, minute, and second the same as before, as interpreted in thelocal time zone.",
	"Method": "void setHours(int hours){\r\n    getCalendarDate().setHours(hours);\r\n}"
}, {
	"Path": "java.util.Observable.clearChanged",
	"Comment": "indicates that this object has no longer changed, or that it hasalready notified all of its observers of its most recent change,so that the haschanged method will now return false.this method is called automatically by thenotifyobservers methods.",
	"Method": "void clearChanged(){\r\n    changed = false;\r\n}"
}, {
	"Path": "java.util.logging.LogManager.getProperty",
	"Comment": "get the value of a logging property.the method returns null if the property is not found.",
	"Method": "String getProperty(String name){\r\n    Object oval = props.get(name);\r\n    String sval = (oval instanceof String) ? (String) oval : null;\r\n    return sval;\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.divideLongMagnitude",
	"Comment": "divide this mutablebiginteger by the divisor represented by positive longvalue. the quotient will be placed into the provided quotient object &the remainder object is returned.",
	"Method": "MutableBigInteger divideLongMagnitude(long ldivisor,MutableBigInteger quotient){\r\n    MutableBigInteger rem = new MutableBigInteger(new int[intLen + 1]);\r\n    System.arraycopy(value, offset, rem.value, 1, intLen);\r\n    rem.intLen = intLen;\r\n    rem.offset = 1;\r\n    int nlen = rem.intLen;\r\n    int limit = nlen - 2 + 1;\r\n    if (quotient.value.length < limit) {\r\n        quotient.value = new int[limit];\r\n        quotient.offset = 0;\r\n    }\r\n    quotient.intLen = limit;\r\n    int[] q = quotient.value;\r\n    int shift = Long.numberOfLeadingZeros(ldivisor);\r\n    if (shift > 0) {\r\n        ldivisor <<= shift;\r\n        rem.leftShift(shift);\r\n    }\r\n    if (rem.intLen == nlen) {\r\n        rem.offset = 0;\r\n        rem.value[0] = 0;\r\n        rem.intLen++;\r\n    }\r\n    int dh = (int) (ldivisor >>> 32);\r\n    long dhLong = dh & LONG_MASK;\r\n    int dl = (int) (ldivisor & LONG_MASK);\r\n    for (int j = 0; j < limit; j++) {\r\n        int qhat = 0;\r\n        int qrem = 0;\r\n        boolean skipCorrection = false;\r\n        int nh = rem.value[j + rem.offset];\r\n        int nh2 = nh + 0x80000000;\r\n        int nm = rem.value[j + 1 + rem.offset];\r\n        if (nh == dh) {\r\n            qhat = ~0;\r\n            qrem = nh + nm;\r\n            skipCorrection = qrem + 0x80000000 < nh2;\r\n        } else {\r\n            long nChunk = (((long) nh) << 32) | (nm & LONG_MASK);\r\n            if (nChunk >= 0) {\r\n                qhat = (int) (nChunk / dhLong);\r\n                qrem = (int) (nChunk - (qhat * dhLong));\r\n            } else {\r\n                long tmp = divWord(nChunk, dh);\r\n                qhat = (int) (tmp & LONG_MASK);\r\n                qrem = (int) (tmp >>> 32);\r\n            }\r\n        }\r\n        if (qhat == 0)\r\n            continue;\r\n        if (!skipCorrection) {\r\n            long nl = rem.value[j + 2 + rem.offset] & LONG_MASK;\r\n            long rs = ((qrem & LONG_MASK) << 32) | nl;\r\n            long estProduct = (dl & LONG_MASK) * (qhat & LONG_MASK);\r\n            if (unsignedLongCompare(estProduct, rs)) {\r\n                qhat--;\r\n                qrem = (int) ((qrem & LONG_MASK) + dhLong);\r\n                if ((qrem & LONG_MASK) >= dhLong) {\r\n                    estProduct -= (dl & LONG_MASK);\r\n                    rs = ((qrem & LONG_MASK) << 32) | nl;\r\n                    if (unsignedLongCompare(estProduct, rs))\r\n                        qhat--;\r\n                }\r\n            }\r\n        }\r\n        rem.value[j + rem.offset] = 0;\r\n        int borrow = mulsubLong(rem.value, dh, dl, qhat, j + rem.offset);\r\n        if (borrow + 0x80000000 > nh2) {\r\n            divaddLong(dh, dl, rem.value, j + 1 + rem.offset);\r\n            qhat--;\r\n        }\r\n        q[j] = qhat;\r\n    }\r\n    if (shift > 0)\r\n        rem.rightShift(shift);\r\n    quotient.normalize();\r\n    rem.normalize();\r\n    return rem;\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testInterruptedTimedPollFirst",
	"Comment": "interrupted timed pollfirst throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPollFirst(){\r\n    final LinkedBlockingDeque q = populatedDeque(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            long startTime = System.nanoTime();\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(i, q.pollFirst(LONG_DELAY_MS, MILLISECONDS));\r\n            }\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.pollFirst(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.pollFirst(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadStaysAlive(t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testInterruptedTimedPollFirst",
	"Comment": "interrupted timed pollfirst throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPollFirst(){\r\n    long startTime = System.nanoTime();\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(i, q.pollFirst(LONG_DELAY_MS, MILLISECONDS));\r\n    }\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.pollFirst(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.pollFirst(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n}"
}, {
	"Path": "java.text.DateFormatSymbols.copyMembers",
	"Comment": "clones all the data members from the source dateformatsymbols tothe target dateformatsymbols. this is only for subclasses.",
	"Method": "void copyMembers(DateFormatSymbols src,DateFormatSymbols dst){\r\n    dst.eras = Arrays.copyOf(src.eras, src.eras.length);\r\n    dst.months = Arrays.copyOf(src.months, src.months.length);\r\n    dst.shortMonths = Arrays.copyOf(src.shortMonths, src.shortMonths.length);\r\n    dst.weekdays = Arrays.copyOf(src.weekdays, src.weekdays.length);\r\n    dst.shortWeekdays = Arrays.copyOf(src.shortWeekdays, src.shortWeekdays.length);\r\n    dst.ampms = Arrays.copyOf(src.ampms, src.ampms.length);\r\n    if (src.zoneStrings != null) {\r\n        dst.zoneStrings = src.getZoneStringsImpl(true);\r\n    } else {\r\n        dst.zoneStrings = null;\r\n    }\r\n    dst.localPatternChars = src.localPatternChars;\r\n    dst.tinyMonths = src.tinyMonths;\r\n    dst.tinyWeekdays = src.tinyWeekdays;\r\n    dst.standAloneMonths = src.standAloneMonths;\r\n    dst.shortStandAloneMonths = src.shortStandAloneMonths;\r\n    dst.tinyStandAloneMonths = src.tinyStandAloneMonths;\r\n    dst.standAloneWeekdays = src.standAloneWeekdays;\r\n    dst.shortStandAloneWeekdays = src.shortStandAloneWeekdays;\r\n    dst.tinyStandAloneWeekdays = src.tinyStandAloneWeekdays;\r\n}"
}, {
	"Path": "java.lang.annotation.AnnotationTypeMismatchException.foundType",
	"Comment": "returns the type of data found in the incorrectly typed element.the returned string may, but is not required to, contain the valueas well.the exact format of the string is unspecified.",
	"Method": "String foundType(){\r\n    return this.foundType;\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.setPatternSeparator",
	"Comment": "sets the character used to separate positive and negative subpatternsin a pattern.",
	"Method": "void setPatternSeparator(char patternSeparator){\r\n    this.patternSeparator = patternSeparator;\r\n}"
}, {
	"Path": "java.util.Arrays.equals",
	"Comment": "returns true if the two specified arrays of booleans areequal to one another.two arrays are considered equal if botharrays contain the same number of elements, and all corresponding pairsof elements in the two arrays are equal.in other words, two arraysare equal if they contain the same elements in the same order.also,two array references are considered equal if both are null.",
	"Method": "boolean equals(long[] a,long[] a2,boolean equals,int[] a,int[] a2,boolean equals,short[] a,short a2,boolean equals,char[] a,char[] a2,boolean equals,byte[] a,byte[] a2,boolean equals,boolean[] a,boolean[] a2,boolean equals,double[] a,double[] a2,boolean equals,float[] a,float[] a2,boolean equals,Object[] a,Object[] a2){\r\n    if (a == a2)\r\n        return true;\r\n    if (a == null || a2 == null)\r\n        return false;\r\n    int length = a.length;\r\n    if (a2.length != length)\r\n        return false;\r\n    for (int i = 0; i < length; i++) {\r\n        Object o1 = a[i];\r\n        Object o2 = a2[i];\r\n        if (!(o1 == null ? o2 == null : o1.equals(o2)))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "sun.security.pkcs.PKCS7.populateCertIssuerNames",
	"Comment": "populate array of issuer dns from certificates and converteach principal to type x500name if necessary.",
	"Method": "void populateCertIssuerNames(){\r\n    if (certificates == null)\r\n        return;\r\n    certIssuerNames = new Principal[certificates.length];\r\n    for (int i = 0; i < certificates.length; i++) {\r\n        X509Certificate cert = certificates[i];\r\n        Principal certIssuerName = cert.getIssuerDN();\r\n        if (!(certIssuerName instanceof X500Name)) {\r\n            try {\r\n                X509CertInfo tbsCert = new X509CertInfo(cert.getTBSCertificate());\r\n                certIssuerName = (Principal) tbsCert.get(CertificateIssuerName.NAME + \".\" + CertificateIssuerName.DN_NAME);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        certIssuerNames[i] = certIssuerName;\r\n    }\r\n}"
}, {
	"Path": "java.math.BigInteger.stripLeadingZeroBytes",
	"Comment": "returns a copy of the input array stripped of any leading zero bytes.",
	"Method": "int[] stripLeadingZeroBytes(byte a){\r\n    int byteLength = a.length;\r\n    int keep;\r\n    for (keep = 0; keep < byteLength && a[keep] == 0; keep++) ;\r\n    int intLength = ((byteLength - keep) + 3) >>> 2;\r\n    int[] result = new int[intLength];\r\n    int b = byteLength - 1;\r\n    for (int i = intLength - 1; i >= 0; i--) {\r\n        result[i] = a[b--] & 0xff;\r\n        int bytesRemaining = b - keep + 1;\r\n        int bytesToTransfer = Math.min(3, bytesRemaining);\r\n        for (int j = 8; j <= (bytesToTransfer << 3); j += 8) result[i] |= ((a[b--] & 0xff) << j);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "java.time.temporal.ValueRange.readObject",
	"Comment": "restore the state of an valuerange from the stream.check that the values are valid.",
	"Method": "void readObject(ObjectInputStream s){\r\n    s.defaultReadObject();\r\n    if (minSmallest > minLargest) {\r\n        throw new InvalidObjectException(\"Smallest minimum value must be less than largest minimum value\");\r\n    }\r\n    if (maxSmallest > maxLargest) {\r\n        throw new InvalidObjectException(\"Smallest maximum value must be less than largest maximum value\");\r\n    }\r\n    if (minLargest > maxLargest) {\r\n        throw new InvalidObjectException(\"Minimum value must be less than maximum value\");\r\n    }\r\n}"
}, {
	"Path": "java.net.DatagramPacket.getOffset",
	"Comment": "returns the offset of the data to be sent or the offset of thedata received.",
	"Method": "int getOffset(){\r\n    return offset;\r\n}"
}, {
	"Path": "java.util.zip.GZIPOutputStream.writeTrailer",
	"Comment": "writes gzip member trailer to a byte array, starting at a givenoffset.",
	"Method": "void writeTrailer(byte[] buf,int offset){\r\n    writeInt((int) crc.getValue(), buf, offset);\r\n    writeInt(def.getTotalIn(), buf, offset + 4);\r\n}"
}, {
	"Path": "java.text.NumberFormat.getMaximumIntegerDigits",
	"Comment": "returns the maximum number of digits allowed in the integer portion of anumber.",
	"Method": "int getMaximumIntegerDigits(){\r\n    return maximumIntegerDigits;\r\n}"
}, {
	"Path": "okio.Buffer.segmentSizes",
	"Comment": "for testing. this returns the sizes of the segments in this buffer.",
	"Method": "List<Integer> segmentSizes(){\r\n    if (head == null)\r\n        return Collections.emptyList();\r\n    List<Integer> result = new ArrayList();\r\n    result.add(head.limit - head.pos);\r\n    for (Segment s = head.next; s != head; s = s.next) {\r\n        result.add(s.limit - s.pos);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "javax.crypto.SecretKeyFactory.getInstance",
	"Comment": "returns a secretkeyfactory object that convertssecret keys of the specified algorithm. a new secretkeyfactory object encapsulating thesecretkeyfactoryspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "SecretKeyFactory getInstance(String algorithm,SecretKeyFactory getInstance,String algorithm,String provider,SecretKeyFactory getInstance,String algorithm,Provider provider){\r\n    Instance instance = JceSecurity.getInstance(\"SecretKeyFactory\", SecretKeyFactorySpi.class, algorithm, provider);\r\n    return new SecretKeyFactory((SecretKeyFactorySpi) instance.impl, instance.provider, algorithm);\r\n}"
}, {
	"Path": "java.util.concurrent.CopyOnWriteArraySet.removeAll",
	"Comment": "removes from this set all of its elements that are contained in thespecified collection.if the specified collection is also a set,this operation effectively modifies this set so that its value is theasymmetric set difference of the two sets.",
	"Method": "boolean removeAll(Collection<?> c){\r\n    return al.removeAll(c);\r\n}"
}, {
	"Path": "java.lang.Character.codePointAtImpl",
	"Comment": "throws arrayindexoutofboundsexception if index out of bounds",
	"Method": "int codePointAtImpl(char[] a,int index,int limit){\r\n    char c1 = a[index];\r\n    if (isHighSurrogate(c1) && ++index < limit) {\r\n        char c2 = a[index];\r\n        if (isLowSurrogate(c2)) {\r\n            return toCodePoint(c1, c2);\r\n        }\r\n    }\r\n    return c1;\r\n}"
}, {
	"Path": "java.util.stream.SliceOps.calcSize",
	"Comment": "calculates the sliced size given the current size, number of elementsskip, and the number of elements to limit.",
	"Method": "long calcSize(long size,long skip,long limit){\r\n    return size >= 0 ? Math.max(-1, Math.min(size - skip, limit)) : -1;\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerFieldUpdaterTest.testConstructor2",
	"Comment": "construction with field not of given type throws illegalargumentexception",
	"Method": "void testConstructor2(){\r\n    try {\r\n        updaterFor(\"z\");\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "java.text.NumberFormat.getMinimumFractionDigits",
	"Comment": "returns the minimum number of digits allowed in the fraction portion of anumber.",
	"Method": "int getMinimumFractionDigits(){\r\n    return minimumFractionDigits;\r\n}"
}, {
	"Path": "sun.security.x509.DNSName.subtreeDepth",
	"Comment": "return subtree depth of this name for purposes of determiningnameconstraints minimum and maximum bounds and for calculatingpath lengths in name subtrees.",
	"Method": "int subtreeDepth(){\r\n    String subtree = name;\r\n    int i = 1;\r\n    for (; subtree.lastIndexOf('.') >= 0; i++) {\r\n        subtree = subtree.substring(0, subtree.lastIndexOf('.'));\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "jsr166.DelayQueueTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    final DelayQueue q = populatedQueue(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(new PDelay(i), ((PDelay) q.take()));\r\n            }\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadStaysAlive(t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.DelayQueueTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(new PDelay(i), ((PDelay) q.take()));\r\n    }\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n}"
}, {
	"Path": "java.net.HttpRetryException.getLocation",
	"Comment": "returns the value of the location header field if theerror resulted from redirection.",
	"Method": "String getLocation(){\r\n    return location;\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.add",
	"Comment": "adds the contents of two mutablebiginteger objects.the resultis placed within this mutablebiginteger.the contents of the addend are not changed.",
	"Method": "void add(MutableBigInteger addend){\r\n    int x = intLen;\r\n    int y = addend.intLen;\r\n    int resultLen = (intLen > addend.intLen ? intLen : addend.intLen);\r\n    int[] result = (value.length < resultLen ? new int[resultLen] : value);\r\n    int rstart = result.length - 1;\r\n    long sum;\r\n    long carry = 0;\r\n    while (x > 0 && y > 0) {\r\n        x--;\r\n        y--;\r\n        sum = (value[x + offset] & LONG_MASK) + (addend.value[y + addend.offset] & LONG_MASK) + carry;\r\n        result[rstart--] = (int) sum;\r\n        carry = sum >>> 32;\r\n    }\r\n    while (x > 0) {\r\n        x--;\r\n        if (carry == 0 && result == value && rstart == (x + offset))\r\n            return;\r\n        sum = (value[x + offset] & LONG_MASK) + carry;\r\n        result[rstart--] = (int) sum;\r\n        carry = sum >>> 32;\r\n    }\r\n    while (y > 0) {\r\n        y--;\r\n        sum = (addend.value[y + addend.offset] & LONG_MASK) + carry;\r\n        result[rstart--] = (int) sum;\r\n        carry = sum >>> 32;\r\n    }\r\n    if (carry > 0) {\r\n        resultLen++;\r\n        if (result.length < resultLen) {\r\n            int[] temp = new int[resultLen];\r\n            System.arraycopy(result, 0, temp, 1, result.length);\r\n            temp[0] = 1;\r\n            result = temp;\r\n        } else {\r\n            result[rstart--] = 1;\r\n        }\r\n    }\r\n    value = result;\r\n    intLen = resultLen;\r\n    offset = result.length - resultLen;\r\n}"
}, {
	"Path": "dalvik.system.CloseGuard.warnIfOpen",
	"Comment": "if closeguard is enabled, logs a warning if the caller did notproperly cleanup by calling an explicit close methodbefore finalization. if closeguard is disabled, no action isperformed.",
	"Method": "void warnIfOpen(){\r\n    if (allocationSite == null || !ENABLED) {\r\n        return;\r\n    }\r\n    String message = (\"A resource was acquired at attached stack trace but never released. \" + \"See java.io.Closeable for information on avoiding resource leaks.\");\r\n    REPORTER.report(message, allocationSite);\r\n}"
}, {
	"Path": "javax.crypto.spec.RC2ParameterSpec.getIV",
	"Comment": "returns the iv or null if this parameter set does not contain an iv.",
	"Method": "byte[] getIV(){\r\n    return (iv == null ? null : (byte[]) iv.clone());\r\n}"
}, {
	"Path": "java.lang.ThreadLocal.getMap",
	"Comment": "get the map associated with a threadlocal. overridden ininheritablethreadlocal.",
	"Method": "ThreadLocalMap getMap(Thread t){\r\n    return t.threadLocals;\r\n}"
}, {
	"Path": "org.xml.sax.helpers.AttributesImpl.setAttributes",
	"Comment": "copy an entire attributes object.it may be more efficient to reuse an existing objectrather than constantly allocating new ones.",
	"Method": "void setAttributes(Attributes atts){\r\n    clear();\r\n    length = atts.getLength();\r\n    if (length > 0) {\r\n        data = new String[length * 5];\r\n        for (int i = 0; i < length; i++) {\r\n            data[i * 5] = atts.getURI(i);\r\n            data[i * 5 + 1] = atts.getLocalName(i);\r\n            data[i * 5 + 2] = atts.getQName(i);\r\n            data[i * 5 + 3] = atts.getType(i);\r\n            data[i * 5 + 4] = atts.getValue(i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.misc.CharacterDecoder.decodeBuffer",
	"Comment": "alternate decode interface that takes a string containing the encodedbuffer and returns a byte array containing the data.",
	"Method": "void decodeBuffer(InputStream aStream,OutputStream bStream,byte decodeBuffer,String inputString,byte decodeBuffer,InputStream in){\r\n    ByteArrayOutputStream outStream = new ByteArrayOutputStream();\r\n    decodeBuffer(in, outStream);\r\n    return (outStream.toByteArray());\r\n}"
}, {
	"Path": "java.security.spec.ECFieldF2m.hashCode",
	"Comment": "returns a hash code value for this characteristic 2finite field.",
	"Method": "int hashCode(){\r\n    int value = m << 5;\r\n    value += (rp == null ? 0 : rp.hashCode());\r\n    return value;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerAddTest.testCase6",
	"Comment": "add two numbers of the same length.the first one is negative and the second is positive.the first one is less in absolute value.",
	"Method": "void testCase6(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 3, 4, 5, 6, 7, 8, 9 };\r\n    byte[] rBytes = { 2, 2, 2, 2, 2, 2, 2 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerAddTest.testCase7",
	"Comment": "add two positive numbers of different length.the first is longer.",
	"Method": "void testCase7(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 1, 2, 3, 4, 15, 26, 37, 41, 52, 63, 74, 15, 26, 37 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerAddTest.testCase4",
	"Comment": "add two numbers of the same length.the first one is negative and the second is positive.the first one is greater in absolute value.",
	"Method": "void testCase4(){\r\n    byte[] aBytes = { 3, 4, 5, 6, 7, 8, 9 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] rBytes = { -3, -3, -3, -3, -3, -3, -2 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerAddTest.testCase5",
	"Comment": "add two numbers of the same length.the first is positive and the second is negative.the first is less in absolute value.",
	"Method": "void testCase5(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 3, 4, 5, 6, 7, 8, 9 };\r\n    byte[] rBytes = { -3, -3, -3, -3, -3, -3, -2 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorBytesException",
	"Comment": "create a number from an array of bytes.verify an exception thrown if an array is zero bytes long",
	"Method": "void testConstructorBytesException(){\r\n    byte[] aBytes = {};\r\n    try {\r\n        new BigInteger(aBytes);\r\n        fail(\"NumberFormatException has not been caught\");\r\n    } catch (NumberFormatException e) {\r\n        assertEquals(\"Improper exception message\", \"Zero length BigInteger\", e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerAddTest.testCase3",
	"Comment": "add two numbers of the same length.the first one is positive and the second is negative.the first one is greater in absolute value.",
	"Method": "void testCase3(){\r\n    byte[] aBytes = { 3, 4, 5, 6, 7, 8, 9 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] rBytes = { 2, 2, 2, 2, 2, 2, 2 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "java.net.MulticastSocket.setNetworkInterface",
	"Comment": "specify the network interface for outgoing multicast datagramssent on this socket.",
	"Method": "void setNetworkInterface(NetworkInterface netIf){\r\n    synchronized (infLock) {\r\n        getImpl().setOption(SocketOptions.IP_MULTICAST_IF2, netIf);\r\n        infAddress = null;\r\n        interfaceSet = true;\r\n    }\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.divadd",
	"Comment": "a primitive used for division. this method adds in one multiple of thedivisor a back to the dividend result at a specified offset. it is usedwhen qhat was estimated too large, and must be adjusted.",
	"Method": "int divadd(int[] a,int[] result,int offset){\r\n    long carry = 0;\r\n    for (int j = a.length - 1; j >= 0; j--) {\r\n        long sum = (a[j] & LONG_MASK) + (result[j + offset] & LONG_MASK) + carry;\r\n        result[j + offset] = (int) sum;\r\n        carry = sum >>> 32;\r\n    }\r\n    return (int) carry;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.treeifyBin",
	"Comment": "replaces all linked nodes in bin at given index unless table istoo small, in which case resizes instead.",
	"Method": "void treeifyBin(Node<K, V>[] tab,int index){\r\n    Node<K, V> b;\r\n    int n;\r\n    if (tab != null) {\r\n        if ((n = tab.length) < MIN_TREEIFY_CAPACITY)\r\n            tryPresize(n << 1);\r\n        else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {\r\n            synchronized (b) {\r\n                if (tabAt(tab, index) == b) {\r\n                    TreeNode<K, V> hd = null, tl = null;\r\n                    for (Node<K, V> e = b; e != null; e = e.next) {\r\n                        TreeNode<K, V> p = new TreeNode<K, V>(e.hash, e.key, e.val, null, null);\r\n                        if ((p.prev = tl) == null)\r\n                            hd = p;\r\n                        else\r\n                            tl.next = p;\r\n                        tl = p;\r\n                    }\r\n                    setTabAt(tab, index, new TreeBin<K, V>(hd));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.j2objc.AssertTest.testTranslationCorrectness",
	"Comment": "ensure that the condition and the expression passed to the jreassert macro are wrapped withparentheses in the translated code.",
	"Method": "void testTranslationCorrectness(){\r\n    assert new Integer[] { 1, 2 } != null;\r\n    assert true : new Integer[] { 1, 2 };\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerAddTest.testCase8",
	"Comment": "add two positive numbers of different length.the second is longer.",
	"Method": "void testCase8(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] rBytes = { 1, 2, 3, 4, 15, 26, 37, 41, 52, 63, 74, 15, 26, 37 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    BigInteger bNumber = new BigInteger(bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerAddTest.testCase9",
	"Comment": "add two negative numbers of different length.the first is longer.",
	"Method": "void testCase9(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { -2, -3, -4, -5, -16, -27, -38, -42, -53, -64, -75, -16, -27, -37 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "java.util.EnumSet.of",
	"Comment": "creates an enum set initially containing the specified elements.this factory, whose parameter list uses the varargs feature, maybe used to create an enum set initially containing an arbitrarynumber of elements, but it is likely to run slower than the overloadingsthat do not use varargs.",
	"Method": "EnumSet<E> of(E e,EnumSet<E> of,E e1,E e2,EnumSet<E> of,E e1,E e2,E e3,EnumSet<E> of,E e1,E e2,E e3,E e4,EnumSet<E> of,E e1,E e2,E e3,E e4,E e5,EnumSet<E> of,E first,E rest){\r\n    EnumSet<E> result = noneOf(first.getDeclaringClass());\r\n    result.add(first);\r\n    for (E e : rest) result.add(e);\r\n    return result;\r\n}"
}, {
	"Path": "sun.security.x509.X500Name.allAvas",
	"Comment": "return an immutable list of the the avas contained in all therdns of this x500name.",
	"Method": "List<AVA> allAvas(){\r\n    List<AVA> list = allAvaList;\r\n    if (list == null) {\r\n        list = new ArrayList<AVA>();\r\n        for (int i = 0; i < names.length; i++) {\r\n            list.addAll(names[i].avas());\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "libcore.reflect.GenericSignatureParser.parseForMethod",
	"Comment": "parses the generic signature of a method and creates the data structurerepresenting the signature.",
	"Method": "void parseForMethod(GenericDeclaration genericDecl,String signature,Class<?>[] rawExceptionTypes){\r\n    setInput(genericDecl, signature);\r\n    if (!eof) {\r\n        parseMethodTypeSignature(rawExceptionTypes);\r\n    } else {\r\n        Method m = (Method) genericDecl;\r\n        this.formalTypeParameters = EmptyArray.TYPE_VARIABLE;\r\n        Class<?>[] parameterTypes = m.getParameterTypes();\r\n        if (parameterTypes.length == 0) {\r\n            this.parameterTypes = ListOfTypes.EMPTY;\r\n        } else {\r\n            this.parameterTypes = new ListOfTypes(parameterTypes);\r\n        }\r\n        Class<?>[] exceptionTypes = m.getExceptionTypes();\r\n        if (exceptionTypes.length == 0) {\r\n            this.exceptionTypes = ListOfTypes.EMPTY;\r\n        } else {\r\n            this.exceptionTypes = new ListOfTypes(exceptionTypes);\r\n        }\r\n        this.returnType = m.getReturnType();\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.Certificate.equals",
	"Comment": "compares this certificate for equality with the specifiedobject. if the other object is aninstanceof certificate, thenits encoded form is retrieved and compared with theencoded form of this certificate.",
	"Method": "boolean equals(Object other){\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (!(other instanceof Certificate)) {\r\n        return false;\r\n    }\r\n    try {\r\n        byte[] thisCert = X509CertImpl.getEncodedInternal(this);\r\n        byte[] otherCert = X509CertImpl.getEncodedInternal((Certificate) other);\r\n        return Arrays.equals(thisCert, otherCert);\r\n    } catch (CertificateException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.PackagePrefixes.addPrefixesFile",
	"Comment": "add a file map of packages to their respective prefixes, using the properties file format.",
	"Method": "void addPrefixesFile(String filename){\r\n    try (Reader r = Files.newBufferedReader(Paths.get(filename), StandardCharsets.UTF_8)) {\r\n        addPrefixProperties(r);\r\n    }\r\n}"
}, {
	"Path": "java.util.Locale.equals",
	"Comment": "returns true if this locale is equal to another object.a locale isdeemed equal to another locale with identical language, script, country,variant and extensions, and unequal to all other objects.",
	"Method": "boolean equals(Object obj,boolean equals,Object obj){\r\n    if (this == obj)\r\n        return true;\r\n    if (!(obj instanceof Locale))\r\n        return false;\r\n    BaseLocale otherBase = ((Locale) obj).baseLocale;\r\n    if (!baseLocale.equals(otherBase)) {\r\n        return false;\r\n    }\r\n    if (localeExtensions == null) {\r\n        return ((Locale) obj).localeExtensions == null;\r\n    }\r\n    return localeExtensions.equals(((Locale) obj).localeExtensions);\r\n}"
}, {
	"Path": "sun.security.x509.CertificateIssuerName.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(DN_NAME);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testPollTaskAsync",
	"Comment": "polltask returns an unexecuted task without executing it, inasync mode",
	"Method": "void testPollTaskAsync(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib g = new AsyncFib(9);\r\n            assertSame(g, g.fork());\r\n            AsyncFib f = new AsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, pollTask());\r\n            helpQuiesce();\r\n            assertEquals(21, f.number);\r\n            checkCompletedNormally(f);\r\n            checkNotDone(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(asyncSingletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testPollTaskAsync",
	"Comment": "polltask returns an unexecuted task without executing it, inasync mode",
	"Method": "void testPollTaskAsync(){\r\n    AsyncFib g = new AsyncFib(9);\r\n    assertSame(g, g.fork());\r\n    AsyncFib f = new AsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, pollTask());\r\n    helpQuiesce();\r\n    assertEquals(21, f.number);\r\n    checkCompletedNormally(f);\r\n    checkNotDone(g);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test428003a",
	"Comment": "expression when preceded by another explicit lambda expression",
	"Method": "void test428003a(){\r\n    this.runConformTest(new String[] { \"X.java\", \"import java.util.Arrays;\\n\" + \"public class X {\\n\" + \"    public static void main(String[] args) {\\n\" + \"        String[] words = {\\\"java\\\", \\\"interface\\\", \\\"lambda\\\", \\\"expression\\\" };\\n\" + \"        Arrays.sort(words, (String word1, String word2) -> {\\n\" + \"                    if (word1.length() < word2.length())\\n\" + \"                        return -1;\\n\" + \"                    else if (word1.length() > word2.length())\\n\" + \"                        return 1;\\n\" + \"                    else\\n\" + \"                        return 0;\\n\" + \"                  });\\n\" + \"        for (String word : words)\\n\" + \"            System.out.println(word);\\n\" + \"        words = new String [] {\\\"java\\\", \\\"interface\\\", \\\"lambda\\\", \\\"expression\\\" };\\n\" + \"        Arrays.sort(words, (word1, word2) -> Integer.compare(word1.length(), word2.length()));\\n\" + \"        for (String word : words)\\n\" + \"            System.out.println(word);\\n\" + \"        words = new String [] {\\\"java\\\", \\\"interface\\\", \\\"lambda\\\", \\\"expression\\\" };\\n\" + \"        Arrays.sort(words, (String word1, String word2) -> Integer.compare(word1.length(), word2.length()));\\n\" + \"        for (String word : words)\\n\" + \"            System.out.println(word);\\n\" + \"      }\\n\" + \"  }\\n\" }, \"java\\n\" + \"lambda\\n\" + \"interface\\n\" + \"expression\\n\" + \"java\\n\" + \"lambda\\n\" + \"interface\\n\" + \"expression\\n\" + \"java\\n\" + \"lambda\\n\" + \"interface\\n\" + \"expression\");\r\n}"
}, {
	"Path": "java.lang.Math.toRadians",
	"Comment": "converts an angle measured in degrees to an approximatelyequivalent angle measured in radians.the conversion fromdegrees to radians is generally inexact.",
	"Method": "double toRadians(double angdeg){\r\n    return angdeg / 180.0 * PI;\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testCancelledForkTimedGetCC",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGetCC(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            CCF f = new LCCF(null, 8);\r\n            assertTrue(f.cancel(true));\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (CancellationException success) {\r\n                checkCancelled(f);\r\n            }\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testCancelledForkTimedGetCC",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGetCC(){\r\n    CCF f = new LCCF(null, 8);\r\n    assertTrue(f.cancel(true));\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (CancellationException success) {\r\n        checkCancelled(f);\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.CertPath.toString",
	"Comment": "returns a string representation of this certification path.this calls the tostring method on each of thecertificates in the path.",
	"Method": "String toString(){\r\n    StringBuffer sb = new StringBuffer();\r\n    Iterator<? extends Certificate> stringIterator = getCertificates().iterator();\r\n    sb.append(\"\\n\" + type + \" Cert Path: length = \" + getCertificates().size() + \".\\n\");\r\n    sb.append(\"[\\n\");\r\n    int i = 1;\r\n    while (stringIterator.hasNext()) {\r\n        sb.append(\"==========================================\" + \"===============Certificate \" + i + \" start.\\n\");\r\n        Certificate stringCert = stringIterator.next();\r\n        sb.append(stringCert.toString());\r\n        sb.append(\"\\n========================================\" + \"=================Certificate \" + i + \" end.\\n\\n\\n\");\r\n        i++;\r\n    }\r\n    sb.append(\"\\n]\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_LocalDateTime_adjustToHijrahDate",
	"Comment": "test to get the local date time by applying the min adjustment with hijrah date",
	"Method": "void test_LocalDateTime_adjustToHijrahDate(ChronoLocalDate hijrahDate,LocalDate localDate){\r\n    LocalDateTime test = LocalDateTime.MIN.with(hijrahDate);\r\n    assertEquals(test, LocalDateTime.of(localDate, LocalTime.MIDNIGHT));\r\n}"
}, {
	"Path": "java.util.TimeZone.setID",
	"Comment": "sets the time zone id. this does not change any other data inthe time zone object.",
	"Method": "void setID(String ID){\r\n    if (ID == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    this.ID = ID;\r\n}"
}, {
	"Path": "java.util.function.DoublePredicate.negate",
	"Comment": "returns a predicate that represents the logical negation of thispredicate.",
	"Method": "DoublePredicate negate(){\r\n    return (value) -> !test(value);\r\n}"
}, {
	"Path": "java.security.cert.CertPathBuilder.build",
	"Comment": "attempts to build a certification path using the specified algorithmparameter set.",
	"Method": "CertPathBuilderResult build(CertPathParameters params){\r\n    return builderSpi.engineBuild(params);\r\n}"
}, {
	"Path": "java.util.Hashtable.reconstitutionPut",
	"Comment": "the put method used by readobject. this is provided because putis overridable and should not be called in readobject since thesubclass will not yet be initialized.this differs from the regular put method in several ways. nochecking for rehashing is necessary since the number of elementsinitially in the table is known. the modcount is not incrementedbecause we are creating a new instance. also, no return valueis needed.",
	"Method": "void reconstitutionPut(HashtableEntry<K, V>[] tab,K key,V value){\r\n    if (value == null) {\r\n        throw new java.io.StreamCorruptedException();\r\n    }\r\n    int hash = hash(key);\r\n    int index = (hash & 0x7FFFFFFF) % tab.length;\r\n    for (HashtableEntry<K, V> e = tab[index]; e != null; e = e.next) {\r\n        if ((e.hash == hash) && e.key.equals(key)) {\r\n            throw new java.io.StreamCorruptedException();\r\n        }\r\n    }\r\n    HashtableEntry<K, V> e = tab[index];\r\n    tab[index] = new HashtableEntry(hash, key, value, e);\r\n    count++;\r\n}"
}, {
	"Path": "java.util.concurrent.ThreadPoolExecutor.isRunningOrShutdown",
	"Comment": "state check needed by scheduledthreadpoolexecutor toenable running tasks during shutdown.",
	"Method": "boolean isRunningOrShutdown(boolean shutdownOK){\r\n    int rs = runStateOf(ctl.get());\r\n    return rs == RUNNING || (rs == SHUTDOWN && shutdownOK);\r\n}"
}, {
	"Path": "sun.security.x509.AlgorithmId.toString",
	"Comment": "returns a string describing the algorithm and its parameters.",
	"Method": "String toString(){\r\n    return getName() + paramsToString();\r\n}"
}, {
	"Path": "jsr166.TreeMapTest.testGet",
	"Comment": "get returns the correct element at the given key,or null if not present",
	"Method": "void testGet(){\r\n    TreeMap map = map5();\r\n    assertEquals(\"A\", (String) map.get(one));\r\n    TreeMap empty = new TreeMap();\r\n    assertNull(empty.get(one));\r\n}"
}, {
	"Path": "libcore.java.text.NumberFormatTest.test_currencyFromLocale",
	"Comment": "test to ensure currency formatting from specified locale works.",
	"Method": "void test_currencyFromLocale(){\r\n    NumberFormat nf = NumberFormat.getCurrencyInstance(Locale.FRANCE);\r\n    assertEquals(\"50,00??\", nf.format(50));\r\n    nf = NumberFormat.getCurrencyInstance(Locale.UK);\r\n    assertEquals(\"50.00\", nf.format(50));\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedSynchronizer.isQueued",
	"Comment": "returns true if the given thread is currently queued.this implementation traverses the queue to determinepresence of the given thread.",
	"Method": "boolean isQueued(Thread thread){\r\n    if (thread == null)\r\n        throw new NullPointerException();\r\n    for (Node p = tail; p != null; p = p.prev) if (p.thread == thread)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "java.util.logging.Logger.finer",
	"Comment": "log a finer message.if the logger is currently enabled for the finer messagelevel then the given message is forwarded to all theregistered output handler objects.",
	"Method": "void finer(String msg){\r\n    if (Level.FINER.intValue() < levelValue) {\r\n        return;\r\n    }\r\n    log(Level.FINER, msg);\r\n}"
}, {
	"Path": "java.util.Calendar.setFieldsComputed",
	"Comment": "sets the state of the specified calendar fields tocomputed. this state means that the specified calendar fieldshave valid values that have been set by internal time calculationrather than by calling one of the setter methods.",
	"Method": "void setFieldsComputed(int fieldMask){\r\n    if (fieldMask == ALL_FIELDS) {\r\n        for (int i = 0; i < fields.length; i++) {\r\n            stamp[i] = COMPUTED;\r\n            isSet[i] = true;\r\n        }\r\n        areFieldsSet = areAllFieldsSet = true;\r\n    } else {\r\n        for (int i = 0; i < fields.length; i++) {\r\n            if ((fieldMask & 1) == 1) {\r\n                stamp[i] = COMPUTED;\r\n                isSet[i] = true;\r\n            } else {\r\n                if (areAllFieldsSet && !isSet[i]) {\r\n                    areAllFieldsSet = false;\r\n                }\r\n            }\r\n            fieldMask >>>= 1;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.net.URLStreamHandler.sameFile",
	"Comment": "compare two urls to see whether they refer to the same file,i.e., having the same protocol, host, port, and path.this method requires that none of its arguments is null. this isguaranteed by the fact that it is only called indirectlyby java.net.url class.",
	"Method": "boolean sameFile(URL u1,URL u2){\r\n    if (!((u1.getProtocol() == u2.getProtocol()) || (u1.getProtocol() != null && u1.getProtocol().equalsIgnoreCase(u2.getProtocol()))))\r\n        return false;\r\n    if (!(u1.getFile() == u2.getFile() || (u1.getFile() != null && u1.getFile().equals(u2.getFile()))))\r\n        return false;\r\n    int port1, port2;\r\n    port1 = (u1.getPort() != -1) ? u1.getPort() : u1.handler.getDefaultPort();\r\n    port2 = (u2.getPort() != -1) ? u2.getPort() : u2.handler.getDefaultPort();\r\n    if (port1 != port2)\r\n        return false;\r\n    if (!hostsEqual(u1, u2))\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testInterruptedSubmit",
	"Comment": "get of submitted callable throws interruptedexception if interrupted",
	"Method": "void testInterruptedSubmit(){\r\n    final CountDownLatch done = new CountDownLatch(1);\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(1, 1, 60, SECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p, done)) {\r\n        final CountDownLatch threadStarted = new CountDownLatch(1);\r\n        Thread t = newStartedThread(new CheckedInterruptedRunnable() {\r\n            public void realRun() throws Exception {\r\n                Callable task = new CheckedCallable<Boolean>() {\r\n                    public Boolean realCall() throws InterruptedException {\r\n                        threadStarted.countDown();\r\n                        await(done);\r\n                        return Boolean.TRUE;\r\n                    }\r\n                };\r\n                p.submit(task).get();\r\n            }\r\n        });\r\n        await(threadStarted);\r\n        t.interrupt();\r\n        awaitTermination(t);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testInterruptedSubmit",
	"Comment": "get of submitted callable throws interruptedexception if interrupted",
	"Method": "void testInterruptedSubmit(){\r\n    Callable task = new CheckedCallable<Boolean>() {\r\n        public Boolean realCall() throws InterruptedException {\r\n            threadStarted.countDown();\r\n            await(done);\r\n            return Boolean.TRUE;\r\n        }\r\n    };\r\n    p.submit(task).get();\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testInterruptedSubmit",
	"Comment": "get of submitted callable throws interruptedexception if interrupted",
	"Method": "void testInterruptedSubmit(){\r\n    threadStarted.countDown();\r\n    await(done);\r\n    return Boolean.TRUE;\r\n}"
}, {
	"Path": "sun.security.x509.PolicyInformation.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(ID);\r\n    elements.addElement(QUALIFIERS);\r\n    return elements.elements();\r\n}"
}, {
	"Path": "jsr166.TimeUnitTest.testToDays",
	"Comment": "todays correctly converts sample values in different units todays",
	"Method": "void testToDays(){\r\n    for (long t = 0; t < 88888; ++t) {\r\n        assertEquals(t, DAYS.toDays(t));\r\n        assertEquals(t, HOURS.toDays(t * 24));\r\n        assertEquals(t, MINUTES.toDays(t * 60 * 24));\r\n        assertEquals(t, SECONDS.toDays(t * 60 * 60 * 24));\r\n        assertEquals(t, MILLISECONDS.toDays(t * 1000L * 60 * 60 * 24));\r\n        assertEquals(t, MICROSECONDS.toDays(t * 1000000L * 60 * 60 * 24));\r\n        assertEquals(t, NANOSECONDS.toDays(t * 1000000000L * 60 * 60 * 24));\r\n    }\r\n}"
}, {
	"Path": "java.util.stream.AbstractShortCircuitTask.compute",
	"Comment": "overrides abstracttask version to include checks for earlyexits while splitting or computing.",
	"Method": "void compute(){\r\n    Spliterator<P_IN> rs = spliterator, ls;\r\n    long sizeEstimate = rs.estimateSize();\r\n    long sizeThreshold = getTargetSize(sizeEstimate);\r\n    boolean forkRight = false;\r\n    @SuppressWarnings(\"unchecked\")\r\n    K task = (K) this;\r\n    AtomicReference<R> sr = sharedResult;\r\n    R result;\r\n    while ((result = sr.get()) == null) {\r\n        if (task.taskCanceled()) {\r\n            result = task.getEmptyResult();\r\n            break;\r\n        }\r\n        if (sizeEstimate <= sizeThreshold || (ls = rs.trySplit()) == null) {\r\n            result = task.doLeaf();\r\n            break;\r\n        }\r\n        K leftChild, rightChild, taskToFork;\r\n        task.leftChild = leftChild = task.makeChild(ls);\r\n        task.rightChild = rightChild = task.makeChild(rs);\r\n        task.setPendingCount(1);\r\n        if (forkRight) {\r\n            forkRight = false;\r\n            rs = ls;\r\n            task = leftChild;\r\n            taskToFork = rightChild;\r\n        } else {\r\n            forkRight = true;\r\n            task = rightChild;\r\n            taskToFork = leftChild;\r\n        }\r\n        taskToFork.fork();\r\n        sizeEstimate = rs.estimateSize();\r\n    }\r\n    task.setLocalResult(result);\r\n    task.tryComplete();\r\n}"
}, {
	"Path": "javax.crypto.spec.SecretKeySpec.hashCode",
	"Comment": "calculates a hash code value for the object.objects that are equal will also have the same hashcode.",
	"Method": "int hashCode(){\r\n    int retval = 0;\r\n    for (int i = 1; i < this.key.length; i++) {\r\n        retval += this.key[i] * i;\r\n    }\r\n    if (this.algorithm.equalsIgnoreCase(\"TripleDES\"))\r\n        return (retval ^= \"desede\".hashCode());\r\n    else\r\n        return (retval ^= this.algorithm.toLowerCase().hashCode());\r\n}"
}, {
	"Path": "sun.nio.ch.SocketChannelImpl.translateAndSetInterestOps",
	"Comment": "translates an interest operation set into a native poll event set",
	"Method": "void translateAndSetInterestOps(int ops,SelectionKeyImpl sk){\r\n    int newOps = 0;\r\n    if ((ops & SelectionKey.OP_READ) != 0)\r\n        newOps |= PollArrayWrapper.POLLIN;\r\n    if ((ops & SelectionKey.OP_WRITE) != 0)\r\n        newOps |= PollArrayWrapper.POLLOUT;\r\n    if ((ops & SelectionKey.OP_CONNECT) != 0)\r\n        newOps |= PollArrayWrapper.POLLCONN;\r\n    sk.selector.putEventOps(sk, newOps);\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.Test_UmmAlQuraVsISODates",
	"Comment": "test to verify the epoch days for given hijrah & iso date instances",
	"Method": "void Test_UmmAlQuraVsISODates(HijrahDate hd,LocalDate ld){\r\n    assertEquals(hd.toEpochDay(), ld.toEpochDay(), \"Umm alQura date and ISO date should have same epochDay\");\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.setRawOffset",
	"Comment": "sets the base time zone offset to gmt.this is the offset to add to utc to get local time.",
	"Method": "void setRawOffset(int offsetMillis){\r\n    this.rawOffset = offsetMillis;\r\n}"
}, {
	"Path": "javax.crypto.JceSecurity.canUseProvider",
	"Comment": "return whether this provider is properly signed and can be used by jce",
	"Method": "boolean canUseProvider(Provider p){\r\n    return true;\r\n}"
}, {
	"Path": "sun.security.x509.NameConstraintsExtension.verifyRFC822SpecialCase",
	"Comment": "perform the rfc 822 special case check. we have a certificatethat does not contain any subject alternative names. check thatany emailaddress attributes in its subject name conform to thesenameconstraints.",
	"Method": "boolean verifyRFC822SpecialCase(X500Name subject){\r\n    for (AVA ava : subject.allAvas()) {\r\n        ObjectIdentifier attrOID = ava.getObjectIdentifier();\r\n        if (attrOID.equals((Object) PKCS9Attribute.EMAIL_ADDRESS_OID)) {\r\n            String attrValue = ava.getValueString();\r\n            if (attrValue != null) {\r\n                RFC822Name emailName;\r\n                try {\r\n                    emailName = new RFC822Name(attrValue);\r\n                } catch (IOException ioe) {\r\n                    continue;\r\n                }\r\n                if (!verify(emailName)) {\r\n                    return (false);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testKeepAliveTimeIllegalArgumentException",
	"Comment": "setkeepalivetime throws illegalargumentexceptionwhen given a negative value",
	"Method": "void testKeepAliveTimeIllegalArgumentException(){\r\n    final ThreadPoolExecutor p = new CustomTPE(2, 3, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        try {\r\n            p.setKeepAliveTime(-1, MILLISECONDS);\r\n            shouldThrow();\r\n        } catch (IllegalArgumentException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.SubjectAlternativeNameExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(SUBJECT_NAME);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "jsr166.ArrayBlockingQueueTest.testConstructor5",
	"Comment": "initializing from collection with some null elements throws npe",
	"Method": "void testConstructor5(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = i;\r\n    Collection<Integer> elements = Arrays.asList(ints);\r\n    try {\r\n        new ArrayBlockingQueue(SIZE, false, elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ArrayBlockingQueueTest.testConstructor7",
	"Comment": "queue contains all elements of collection used to initialize",
	"Method": "void testConstructor7(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = i;\r\n    Collection<Integer> elements = Arrays.asList(ints);\r\n    ArrayBlockingQueue q = new ArrayBlockingQueue(SIZE, true, elements);\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "java.security.SecureRandom.generateSeed",
	"Comment": "returns the given number of seed bytes, computed using the seedgeneration algorithm that this class uses to seed itself.thiscall may be used to seed other random number generators.",
	"Method": "byte[] generateSeed(int numBytes){\r\n    return secureRandomSpi.engineGenerateSeed(numBytes);\r\n}"
}, {
	"Path": "android.icu.dev.test.format.IntlTestDecimalFormatAPIC.TestAPI",
	"Comment": "this test checks various generic api methods in decimalformat to achieve 100% api coverage.",
	"Method": "void TestAPI(){\r\n    logln(\"DecimalFormat API test---\");\r\n    logln(\"\");\r\n    Locale.setDefault(Locale.ENGLISH);\r\n    logln(\"Testing DecimalFormat constructors\");\r\n    DecimalFormat def = new DecimalFormat();\r\n    final String pattern = new String(\"#,##0.# FF\");\r\n    final DecimalFormatSymbols symbols = new DecimalFormatSymbols(Locale.FRENCH);\r\n    final CurrencyPluralInfo infoInput = new CurrencyPluralInfo(ULocale.FRENCH);\r\n    DecimalFormat pat = null;\r\n    try {\r\n        pat = new DecimalFormat(pattern);\r\n    } catch (IllegalArgumentException e) {\r\n        errln(\"ERROR: Could not create DecimalFormat (pattern)\");\r\n    }\r\n    DecimalFormat cust1 = null;\r\n    try {\r\n        cust1 = new DecimalFormat(pattern, symbols);\r\n    } catch (IllegalArgumentException e) {\r\n        errln(\"ERROR: Could not create DecimalFormat (pattern, symbols)\");\r\n    }\r\n    @SuppressWarnings(\"unused\")\r\n    DecimalFormat cust2 = null;\r\n    try {\r\n        cust2 = new DecimalFormat(pattern, symbols, infoInput, NumberFormat.PLURALCURRENCYSTYLE);\r\n    } catch (IllegalArgumentException e) {\r\n        errln(\"ERROR: Could not create DecimalFormat (pattern, symbols, infoInput, style)\");\r\n    }\r\n    logln(\"Testing clone() and equality operators\");\r\n    Format clone = (Format) def.clone();\r\n    if (!def.equals(clone)) {\r\n        errln(\"ERROR: Clone() failed\");\r\n    }\r\n    logln(\"Testing various format() methods\");\r\n    final double d = -10456.00370000000000;\r\n    final long l = 100000000;\r\n    logln(\"\" + Double.toString(d) + \" is the double value\");\r\n    StringBuffer res1 = new StringBuffer();\r\n    StringBuffer res2 = new StringBuffer();\r\n    StringBuffer res3 = new StringBuffer();\r\n    StringBuffer res4 = new StringBuffer();\r\n    FieldPosition pos1 = new FieldPosition(0);\r\n    FieldPosition pos2 = new FieldPosition(0);\r\n    FieldPosition pos3 = new FieldPosition(0);\r\n    FieldPosition pos4 = new FieldPosition(0);\r\n    res1 = def.format(d, res1, pos1);\r\n    logln(\"\" + Double.toString(d) + \" formatted to \" + res1);\r\n    res2 = pat.format(l, res2, pos2);\r\n    logln(\"\" + l + \" formatted to \" + res2);\r\n    res3 = cust1.format(d, res3, pos3);\r\n    logln(\"\" + Double.toString(d) + \" formatted to \" + res3);\r\n    res4 = cust1.format(l, res4, pos4);\r\n    logln(\"\" + l + \" formatted to \" + res4);\r\n    logln(\"Testing parse()\");\r\n    String text = new String(\"-10,456.0037\");\r\n    ParsePosition pos = new ParsePosition(0);\r\n    String patt = new String(\"#,##0.#\");\r\n    pat.applyPattern(patt);\r\n    double d2 = pat.parse(text, pos).doubleValue();\r\n    if (d2 != d) {\r\n        errln(\"ERROR: Roundtrip failed (via parse(\" + Double.toString(d2) + \" != \" + Double.toString(d) + \")) for \" + text);\r\n    }\r\n    logln(text + \" parsed into \" + (long) d2);\r\n    logln(\"Testing getters and setters\");\r\n    final DecimalFormatSymbols syms = pat.getDecimalFormatSymbols();\r\n    def.setDecimalFormatSymbols(syms);\r\n    if (!pat.getDecimalFormatSymbols().equals(def.getDecimalFormatSymbols())) {\r\n        errln(\"ERROR: set DecimalFormatSymbols() failed\");\r\n    }\r\n    String posPrefix;\r\n    pat.setPositivePrefix(\"+\");\r\n    posPrefix = pat.getPositivePrefix();\r\n    logln(\"Positive prefix (should be +): \" + posPrefix);\r\n    if (posPrefix != \"+\") {\r\n        errln(\"ERROR: setPositivePrefix() failed\");\r\n    }\r\n    String negPrefix;\r\n    pat.setNegativePrefix(\"-\");\r\n    negPrefix = pat.getNegativePrefix();\r\n    logln(\"Negative prefix (should be -): \" + negPrefix);\r\n    if (negPrefix != \"-\") {\r\n        errln(\"ERROR: setNegativePrefix() failed\");\r\n    }\r\n    String posSuffix;\r\n    pat.setPositiveSuffix(\"_\");\r\n    posSuffix = pat.getPositiveSuffix();\r\n    logln(\"Positive suffix (should be _): \" + posSuffix);\r\n    if (posSuffix != \"_\") {\r\n        errln(\"ERROR: setPositiveSuffix() failed\");\r\n    }\r\n    String negSuffix;\r\n    pat.setNegativeSuffix(\"~\");\r\n    negSuffix = pat.getNegativeSuffix();\r\n    logln(\"Negative suffix (should be ~): \" + negSuffix);\r\n    if (negSuffix != \"~\") {\r\n        errln(\"ERROR: setNegativeSuffix() failed\");\r\n    }\r\n    long multiplier = 0;\r\n    pat.setMultiplier(8);\r\n    multiplier = pat.getMultiplier();\r\n    logln(\"Multiplier (should be 8): \" + multiplier);\r\n    if (multiplier != 8) {\r\n        errln(\"ERROR: setMultiplier() failed\");\r\n    }\r\n    int groupingSize = 0;\r\n    pat.setGroupingSize(2);\r\n    groupingSize = pat.getGroupingSize();\r\n    logln(\"Grouping size (should be 2): \" + (long) groupingSize);\r\n    if (groupingSize != 2) {\r\n        errln(\"ERROR: setGroupingSize() failed\");\r\n    }\r\n    pat.setDecimalSeparatorAlwaysShown(true);\r\n    boolean tf = pat.isDecimalSeparatorAlwaysShown();\r\n    logln(\"DecimalSeparatorIsAlwaysShown (should be true) is \" + (tf ? \"true\" : \"false\"));\r\n    if (tf != true) {\r\n        errln(\"ERROR: setDecimalSeparatorAlwaysShown() failed\");\r\n    }\r\n    String funkyPat;\r\n    funkyPat = pat.toPattern();\r\n    logln(\"Pattern is \" + funkyPat);\r\n    String locPat;\r\n    locPat = pat.toLocalizedPattern();\r\n    logln(\"Localized pattern is \" + locPat);\r\n    pat.setCurrencyPluralInfo(infoInput);\r\n    if (!infoInput.equals(pat.getCurrencyPluralInfo())) {\r\n        errln(\"ERROR: set/get CurrencyPluralInfo() failed\");\r\n    }\r\n    pat.setCurrencyPluralInfo(infoInput);\r\n    if (!infoInput.equals(pat.getCurrencyPluralInfo())) {\r\n        errln(\"ERROR: set/get CurrencyPluralInfo() failed\");\r\n    }\r\n    logln(\"Testing applyPattern()\");\r\n    String p1 = new String(\"#,##0.0#;(#,##0.0#)\");\r\n    logln(\"Applying pattern \" + p1);\r\n    pat.applyPattern(p1);\r\n    String s2;\r\n    s2 = pat.toPattern();\r\n    logln(\"Extracted pattern is \" + s2);\r\n    if (!s2.equals(p1)) {\r\n        errln(\"ERROR: toPattern() result did not match pattern applied\");\r\n    }\r\n    String p2 = new String(\"#,##0.0# FF;(#,##0.0# FF)\");\r\n    logln(\"Applying pattern \" + p2);\r\n    pat.applyLocalizedPattern(p2);\r\n    String s3;\r\n    s3 = pat.toLocalizedPattern();\r\n    logln(\"Extracted pattern is \" + s3);\r\n    if (!s3.equals(p2)) {\r\n        errln(\"ERROR: toLocalizedPattern() result did not match pattern applied\");\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.get",
	"Comment": "return the requested attribute from the certificate.note that the x509certinfo is not cloned for performance reasons.callers must ensure that they do not modify it. all otherattributes are cloned.",
	"Method": "Object get(String name){\r\n    X509AttributeName attr = new X509AttributeName(name);\r\n    String id = attr.getPrefix();\r\n    if (!(id.equalsIgnoreCase(NAME))) {\r\n        throw new CertificateParsingException(\"Invalid root of \" + \"attribute name, expected [\" + NAME + \"], received \" + \"[\" + id + \"]\");\r\n    }\r\n    attr = new X509AttributeName(attr.getSuffix());\r\n    id = attr.getPrefix();\r\n    if (id.equalsIgnoreCase(INFO)) {\r\n        if (info == null) {\r\n            return null;\r\n        }\r\n        if (attr.getSuffix() != null) {\r\n            try {\r\n                return info.get(attr.getSuffix());\r\n            } catch (IOException e) {\r\n                throw new CertificateParsingException(e.toString());\r\n            } catch (CertificateException e) {\r\n                throw new CertificateParsingException(e.toString());\r\n            }\r\n        } else {\r\n            return info;\r\n        }\r\n    } else if (id.equalsIgnoreCase(ALG_ID)) {\r\n        return (algId);\r\n    } else if (id.equalsIgnoreCase(SIGNATURE)) {\r\n        if (signature != null)\r\n            return signature.clone();\r\n        else\r\n            return null;\r\n    } else if (id.equalsIgnoreCase(SIGNED_CERT)) {\r\n        if (signedCert != null)\r\n            return signedCert.clone();\r\n        else\r\n            return null;\r\n    } else {\r\n        throw new CertificateParsingException(\"Attribute name not \" + \"recognized or get() not allowed for the same: \" + id);\r\n    }\r\n}"
}, {
	"Path": "javax.net.ssl.SSLSessionBindingEvent.getSession",
	"Comment": "returns the sslsession into which the listener is being bound orfrom which the listener is being unbound.",
	"Method": "SSLSession getSession(){\r\n    return (SSLSession) getSource();\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.getMagnitudeArray",
	"Comment": "internal helper method to return the magnitude array. the caller is notsupposed to modify the returned array.",
	"Method": "int[] getMagnitudeArray(){\r\n    if (offset > 0 || value.length != intLen)\r\n        return Arrays.copyOfRange(value, offset, offset + intLen);\r\n    return value;\r\n}"
}, {
	"Path": "sun.security.x509.PolicyInformation.toString",
	"Comment": "return a printable representation of the policyinformation.",
	"Method": "String toString(){\r\n    StringBuilder s = new StringBuilder(\"  [\" + policyIdentifier.toString());\r\n    s.append(policyQualifiers + \"  ]\\n\");\r\n    return s.toString();\r\n}"
}, {
	"Path": "java.nio.CharBuffer.charAt",
	"Comment": "reads the character at the given index relative to the currentposition.",
	"Method": "char charAt(int index){\r\n    return get(position() + checkIndex(index, 1));\r\n}"
}, {
	"Path": "sun.security.pkcs.ContentInfo.getContentBytes",
	"Comment": "returns a byte array representation of the data held inthe content field.",
	"Method": "byte[] getContentBytes(){\r\n    if (content == null)\r\n        return null;\r\n    DerInputStream dis = new DerInputStream(content.toByteArray());\r\n    return dis.getOctetString();\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testListIterator2_IndexOutOfBoundsException",
	"Comment": "listiterator throws an indexoutofboundsexception on a too high index",
	"Method": "void testListIterator2_IndexOutOfBoundsException(){\r\n    CopyOnWriteArrayList c = populatedArray(5);\r\n    List[] lists = { c, c.subList(1, c.size() - 1) };\r\n    for (List list : lists) {\r\n        try {\r\n            list.listIterator(list.size() + 1);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinPool.tryInitialize",
	"Comment": "instantiates fields upon first submission, or upon shutdown ifno submissions. if checktermination true, also responds totermination by external calls submitting tasks.",
	"Method": "void tryInitialize(boolean checkTermination){\r\n    if (runState == 0) {\r\n        int p = config & SMASK;\r\n        int n = (p > 1) ? p - 1 : 1;\r\n        n |= n >>> 1;\r\n        n |= n >>> 2;\r\n        n |= n >>> 4;\r\n        n |= n >>> 8;\r\n        n |= n >>> 16;\r\n        n = ((n + 1) << 1) & SMASK;\r\n        AuxState aux = new AuxState();\r\n        WorkQueue[] ws = new WorkQueue[n];\r\n        synchronized (modifyThreadPermission) {\r\n            if (runState == 0) {\r\n                workQueues = ws;\r\n                auxState = aux;\r\n                runState = STARTED;\r\n            }\r\n        }\r\n    }\r\n    if (checkTermination && runState < 0) {\r\n        tryTerminate(false, false);\r\n        throw new RejectedExecutionException();\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvoke(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingAsyncFib f = new FailingAsyncFib(8);\r\n            f.quietlyInvoke();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvoke(){\r\n    FailingAsyncFib f = new FailingAsyncFib(8);\r\n    f.quietlyInvoke();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.FunctionizerTest.testThisParameters",
	"Comment": "verify this expressions are changed to self parameters in functions.",
	"Method": "void testThisParameters(){\r\n    String translation = translateSourceFile(\"class A { private void test(java.util.List list) { list.add(this); }}\", \"A\", \"A.m\");\r\n    assertTranslatedLines(translation, \"[((id<JavaUtilList>) nil_chk(list)) addWithId:self];\");\r\n}"
}, {
	"Path": "jsr166.JSR166TestCase.tearDown",
	"Comment": "extra checks that get done for all test cases.triggers test case failure if any thread assertions have failed,by rethrowing, in the test harness thread, any exception recordedearlier by threadrecordfailure.triggers test case failure if interrupt status is set in the main thread.",
	"Method": "void tearDown(){\r\n    Throwable t = threadFailure.getAndSet(null);\r\n    if (t != null) {\r\n        if (t instanceof Error)\r\n            throw (Error) t;\r\n        else if (t instanceof RuntimeException)\r\n            throw (RuntimeException) t;\r\n        else if (t instanceof Exception)\r\n            throw (Exception) t;\r\n        else {\r\n            AssertionFailedError afe = new AssertionFailedError(t.toString());\r\n            afe.initCause(t);\r\n            throw afe;\r\n        }\r\n    }\r\n    if (Thread.interrupted())\r\n        tearDownFail(\"interrupt status set in main thread\");\r\n    checkForkJoinPoolThreadLeaks();\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testPollNextLocalTask",
	"Comment": "pollnextlocaltask returns most recent unexecuted task withoutexecuting it",
	"Method": "void testPollNextLocalTask(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib g = new AsyncFib(9);\r\n            assertSame(g, g.fork());\r\n            AsyncFib f = new AsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(f, pollNextLocalTask());\r\n            helpQuiesce();\r\n            checkNotDone(f);\r\n            assertEquals(34, g.number);\r\n            checkCompletedNormally(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testPollNextLocalTask",
	"Comment": "pollnextlocaltask returns most recent unexecuted task withoutexecuting it",
	"Method": "void testPollNextLocalTask(){\r\n    AsyncFib g = new AsyncFib(9);\r\n    assertSame(g, g.fork());\r\n    AsyncFib f = new AsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(f, pollNextLocalTask());\r\n    helpQuiesce();\r\n    checkNotDone(f);\r\n    assertEquals(34, g.number);\r\n    checkCompletedNormally(g);\r\n}"
}, {
	"Path": "sun.security.util.SignatureFileVerifier.verifyTimestamp",
	"Comment": "check that the signature timestamp applies to this signature.match the hash present in the signature timestamp token against the hashof this signature.",
	"Method": "void verifyTimestamp(TimestampToken token,byte[] signature){\r\n    MessageDigest md = MessageDigest.getInstance(token.getHashAlgorithm().getName());\r\n    if (!Arrays.equals(token.getHashedMessage(), md.digest(signature))) {\r\n        throw new SignatureException(\"Signature timestamp (#\" + token.getSerialNumber() + \") generated on \" + token.getDate() + \" is inapplicable\");\r\n    }\r\n    if (debug != null) {\r\n        debug.println();\r\n        debug.println(\"Detected signature timestamp (#\" + token.getSerialNumber() + \") generated on \" + token.getDate());\r\n        debug.println();\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testFloatValueNegRounded2",
	"Comment": "convert a positive number to a float value. rounding is needed.the rounding bit is 1 and the next bit to the left is 0but some of dropped bits are 1s.",
	"Method": "void testFloatValueNegRounded2(){\r\n    byte[] a = { -128, 1, 2, -128, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = -1;\r\n    float result = -1.5474728E26f;\r\n    float aNumber = new BigInteger(aSign, a).floatValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.subtract",
	"Comment": "subtracts the smaller of this and b from the larger and places theresult into this mutablebiginteger.",
	"Method": "int subtract(MutableBigInteger b){\r\n    MutableBigInteger a = this;\r\n    int[] result = value;\r\n    int sign = a.compare(b);\r\n    if (sign == 0) {\r\n        reset();\r\n        return 0;\r\n    }\r\n    if (sign < 0) {\r\n        MutableBigInteger tmp = a;\r\n        a = b;\r\n        b = tmp;\r\n    }\r\n    int resultLen = a.intLen;\r\n    if (result.length < resultLen)\r\n        result = new int[resultLen];\r\n    long diff = 0;\r\n    int x = a.intLen;\r\n    int y = b.intLen;\r\n    int rstart = result.length - 1;\r\n    while (y > 0) {\r\n        x--;\r\n        y--;\r\n        diff = (a.value[x + a.offset] & LONG_MASK) - (b.value[y + b.offset] & LONG_MASK) - ((int) -(diff >> 32));\r\n        result[rstart--] = (int) diff;\r\n    }\r\n    while (x > 0) {\r\n        x--;\r\n        diff = (a.value[x + a.offset] & LONG_MASK) - ((int) -(diff >> 32));\r\n        result[rstart--] = (int) diff;\r\n    }\r\n    value = result;\r\n    intLen = resultLen;\r\n    offset = value.length - resultLen;\r\n    normalize();\r\n    return sign;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testFloatValueNegRounded1",
	"Comment": "convert a positive number to a float value. rounding is needed.",
	"Method": "void testFloatValueNegRounded1(){\r\n    byte[] a = { -128, 1, -1, -4, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = -1;\r\n    float result = -1.5475195E26f;\r\n    float aNumber = new BigInteger(aSign, a).floatValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "jsr166.ArrayBlockingQueueTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    ArrayBlockingQueue q = new ArrayBlockingQueue(SIZE);\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        q.addAll(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.X509Factory.engineGenerateCertPath",
	"Comment": "generates a certpath object and initializes it witha list of certificates.the certificates supplied must be of a type supported by thecertificatefactory. they will be copied out of the suppliedlist object.",
	"Method": "CertPath engineGenerateCertPath(InputStream inStream,CertPath engineGenerateCertPath,InputStream inStream,String encoding,CertPath engineGenerateCertPath,List<? extends Certificate> certificates){\r\n    return (new X509CertPath(certificates));\r\n}"
}, {
	"Path": "jsr166.FutureTaskTest.testConstructor",
	"Comment": "creating a future with a null callable throws nullpointerexception",
	"Method": "void testConstructor(){\r\n    try {\r\n        new FutureTask(null);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentLinkedDeque.succ",
	"Comment": "returns the successor of p, or the first node if p.next has beenlinked to self, which will only be true if traversing with astale pointer that is now off the list.",
	"Method": "Node<E> succ(Node<E> p){\r\n    Node<E> q = p.next;\r\n    return (sentinel() == q) ? first() : q;\r\n}"
}, {
	"Path": "java.util.concurrent.LinkedTransferQueue.xfer",
	"Comment": "implements all queuing methods. see above for explanation.",
	"Method": "E xfer(E e,boolean haveData,int how,long nanos){\r\n    if (haveData && (e == null))\r\n        throw new NullPointerException();\r\n    Node s = null;\r\n    retry: for (; ; ) {\r\n        for (Node h = head, p = h; p != null; ) {\r\n            boolean isData = p.isData;\r\n            Object item = p.item;\r\n            if (item != FORGOTTEN && (item != null) == isData) {\r\n                if (isData == haveData)\r\n                    break;\r\n                if (p.casItem(item, e)) {\r\n                    for (Node q = p; q != h; ) {\r\n                        Node n = q.next;\r\n                        if (head == h && casHead(h, n == null ? q : n)) {\r\n                            h.forgetNext();\r\n                            break;\r\n                        }\r\n                        if ((h = head) == null || (q = h.next) == null || !q.isMatched())\r\n                            break;\r\n                    }\r\n                    LockSupport.unpark(p.waiter);\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    E itemE = (E) item;\r\n                    return itemE;\r\n                }\r\n            }\r\n            Node n = p.next;\r\n            p = (UNLINKED != n) ? n : (h = head);\r\n        }\r\n        if (how != NOW) {\r\n            if (s == null)\r\n                s = new Node(e, haveData);\r\n            Node pred = tryAppend(s, haveData);\r\n            if (pred == null)\r\n                continue retry;\r\n            if (how != ASYNC)\r\n                return awaitMatch(s, pred, e, (how == TIMED), nanos);\r\n        }\r\n        return e;\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ThreadLocalRandom.internalNextLong",
	"Comment": "the form of nextlong used by longstream spliterators.iforigin is greater than bound, acts as unbounded form ofnextlong, else as bounded form.",
	"Method": "long internalNextLong(long origin,long bound){\r\n    long r = mix64(nextSeed());\r\n    if (origin < bound) {\r\n        long n = bound - origin, m = n - 1;\r\n        if ((n & m) == 0L)\r\n            r = (r & m) + origin;\r\n        else if (n > 0L) {\r\n            for (long u = r >>> 1; u + m - (r = u % n) < 0L; u = mix64(nextSeed()) >>> 1) ;\r\n            r += origin;\r\n        } else {\r\n            while (r < origin || r >= bound) r = mix64(nextSeed());\r\n        }\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "sun.security.util.SignatureFileVerifier.process",
	"Comment": "process the signature block file. goes through the .sf fileand adds code signers for each section where the .sf sectionhash was verified against the manifest section.",
	"Method": "void process(Hashtable<String, CodeSigner[]> signers,List manifestDigests){\r\n    Object obj = null;\r\n    try {\r\n        obj = Providers.startJarVerification();\r\n        processImpl(signers, manifestDigests);\r\n    } finally {\r\n        Providers.stopJarVerification(obj);\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.getOrDefault",
	"Comment": "returns the value to which the specified key is mapped, or thegiven default value if this map contains no mapping for thekey.",
	"Method": "V getOrDefault(Object key,V defaultValue){\r\n    V v;\r\n    return (v = get(key)) == null ? defaultValue : v;\r\n}"
}, {
	"Path": "java.util.HashMap.getEntry",
	"Comment": "returns the entry associated with the specified key in thehashmap.returns null if the hashmap contains no mappingfor the key.",
	"Method": "Entry<K, V> getEntry(Object key){\r\n    if (size == 0) {\r\n        return null;\r\n    }\r\n    int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key);\r\n    for (HashMapEntry<K, V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) {\r\n        Object k;\r\n        if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))\r\n            return e;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jsr166.ArrayBlockingQueueTest.testAddAll5",
	"Comment": "queue contains all elements, in traversal order, of successful addall",
	"Method": "void testAddAll5(){\r\n    Integer[] empty = new Integer[0];\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = new Integer(i);\r\n    ArrayBlockingQueue q = new ArrayBlockingQueue(SIZE);\r\n    assertFalse(q.addAll(Arrays.asList(empty)));\r\n    assertTrue(q.addAll(Arrays.asList(ints)));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testSaturatedExecute",
	"Comment": "execute throws rejectedexecutionexception if saturated.",
	"Method": "void testSaturatedExecute(){\r\n    final CountDownLatch done = new CountDownLatch(1);\r\n    final ThreadPoolExecutor p = new CustomTPE(1, 1, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(1));\r\n    try (PoolCleaner cleaner = cleaner(p, done)) {\r\n        Runnable task = new CheckedRunnable() {\r\n            public void realRun() throws InterruptedException {\r\n                await(done);\r\n            }\r\n        };\r\n        for (int i = 0; i < 2; ++i) p.execute(task);\r\n        for (int i = 0; i < 2; ++i) {\r\n            try {\r\n                p.execute(task);\r\n                shouldThrow();\r\n            } catch (RejectedExecutionException success) {\r\n            }\r\n            assertTrue(p.getTaskCount() <= 2);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testSaturatedExecute",
	"Comment": "execute throws rejectedexecutionexception if saturated.",
	"Method": "void testSaturatedExecute(){\r\n    await(done);\r\n}"
}, {
	"Path": "java.beans.ChangeListenerMap.getEntries",
	"Comment": "returns a set of entries from the map.each entry is a pair consisted of the property nameand the corresponding list of listeners.",
	"Method": "Set<Entry<String, L[]>> getEntries(){\r\n    return (this.map != null) ? this.map.entrySet() : Collections.<Entry<String, L[]>>emptySet();\r\n}"
}, {
	"Path": "jsr166.AtomicLongArrayTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    final AtomicLongArray a = new AtomicLongArray(1);\r\n    a.set(0, 1);\r\n    Thread t = new Thread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!a.compareAndSet(0, 2, 3)) Thread.yield();\r\n        }\r\n    });\r\n    t.start();\r\n    assertTrue(a.compareAndSet(0, 1, 2));\r\n    t.join(LONG_DELAY_MS);\r\n    assertFalse(t.isAlive());\r\n    assertEquals(3, a.get(0));\r\n}"
}, {
	"Path": "jsr166.AtomicLongArrayTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    while (!a.compareAndSet(0, 2, 3)) Thread.yield();\r\n}"
}, {
	"Path": "java.util.RegularEnumSet.equals",
	"Comment": "compares the specified object with this set for equality.returnstrue if the given object is also a set, the two sets havethe same size, and every member of the given set is contained inthis set.",
	"Method": "boolean equals(Object o){\r\n    if (!(o instanceof RegularEnumSet))\r\n        return super.equals(o);\r\n    RegularEnumSet es = (RegularEnumSet) o;\r\n    if (es.elementType != elementType)\r\n        return elements == 0 && es.elements == 0;\r\n    return es.elements == elements;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.setSubjectPublicKeyAlgID",
	"Comment": "sets the subjectpublickeyalgid criterion. thex509certificate must contain a subject public keywith the specified algorithm. if null, nosubjectpublickeyalgid check will be done.",
	"Method": "void setSubjectPublicKeyAlgID(String oid){\r\n    if (oid == null) {\r\n        subjectPublicKeyAlgID = null;\r\n    } else {\r\n        subjectPublicKeyAlgID = new ObjectIdentifier(oid);\r\n    }\r\n}"
}, {
	"Path": "java.io.BufferedInputStream.markSupported",
	"Comment": "tests if this input stream supports the markand reset methods. the marksupportedmethod of bufferedinputstream returnstrue.",
	"Method": "boolean markSupported(){\r\n    return true;\r\n}"
}, {
	"Path": "java.time.Period.toTotalMonths",
	"Comment": "gets the total number of months in this period.this returns the total number of months in the period by multiplying thenumber of years by 12 and adding the number of months.this instance is immutable and unaffected by this method call.",
	"Method": "long toTotalMonths(){\r\n    return years * 12L + months;\r\n}"
}, {
	"Path": "java.util.zip.Inflater.getRemaining",
	"Comment": "returns the total number of bytes remaining in the input buffer.this can be used to find out what bytes still remain in the inputbuffer after decompression has finished.",
	"Method": "int getRemaining(){\r\n    synchronized (zsRef) {\r\n        return len;\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.luni.tests.java.util.StackTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this method\tis called before a test is executed.",
	"Method": "void setUp(){\r\n    s = new Stack();\r\n}"
}, {
	"Path": "android.icu.dev.util.CollectionUtilities.compare",
	"Comment": "compare, with shortest first, and otherwise lexicographically",
	"Method": "int compare(T a,T b,int compare,Iterator<T> iterator1,Iterator<T> iterator2,int compare,U o1,U o2,int compare,U o1,U o2,int compare,Set<T> o1,Set<T> o2,int compare,Collection<T> o1,Collection<T> o2,int compare,T a,T b,int compare,Map<K, V> o1,Map<K, V> o2,int compare,T arg0,T arg1){\r\n    if (a == null) {\r\n        return b == null ? 0 : -1;\r\n    } else if (b == null) {\r\n        return 1;\r\n    }\r\n    int diff = compare(a.getKey(), b.getKey());\r\n    if (diff != 0) {\r\n        return diff;\r\n    }\r\n    return compare(a.getValue(), b.getValue());\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testHasWaiters",
	"Comment": "haswaiters returns true when a thread is waiting, else false",
	"Method": "void testHasWaiters(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    final BooleanLatch acquired = new BooleanLatch();\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            sync.acquire();\r\n            assertHasWaitersLocked(sync, c, NO_THREADS);\r\n            assertFalse(sync.hasWaiters(c));\r\n            assertTrue(acquired.releaseShared(0));\r\n            c.await();\r\n            sync.release();\r\n        }\r\n    });\r\n    acquired.acquireShared(0);\r\n    sync.acquire();\r\n    assertHasWaitersLocked(sync, c, t);\r\n    assertHasExclusiveQueuedThreads(sync, NO_THREADS);\r\n    assertTrue(sync.hasWaiters(c));\r\n    c.signal();\r\n    assertHasWaitersLocked(sync, c, NO_THREADS);\r\n    assertHasExclusiveQueuedThreads(sync, t);\r\n    assertFalse(sync.hasWaiters(c));\r\n    sync.release();\r\n    awaitTermination(t);\r\n    assertHasWaitersUnlocked(sync, c, NO_THREADS);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testHasWaiters",
	"Comment": "haswaiters returns true when a thread is waiting, else false",
	"Method": "void testHasWaiters(){\r\n    sync.acquire();\r\n    assertHasWaitersLocked(sync, c, NO_THREADS);\r\n    assertFalse(sync.hasWaiters(c));\r\n    assertTrue(acquired.releaseShared(0));\r\n    c.await();\r\n    sync.release();\r\n}"
}, {
	"Path": "java.io.ByteArrayOutputStream.reset",
	"Comment": "resets the count field of this byte array outputstream to zero, so that all currently accumulated output in theoutput stream is discarded. the output stream can be used again,reusing the already allocated buffer space.",
	"Method": "void reset(){\r\n    count = 0;\r\n}"
}, {
	"Path": "sun.security.x509.SubjectInfoAccessExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(DESCRIPTIONS);\r\n    return elements.elements();\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testConstructor15",
	"Comment": "constructor throws if corepoolsize is greater than the maximumpoolsize",
	"Method": "void testConstructor15(){\r\n    try {\r\n        new CustomTPE(2, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10), new NoOpREHandler());\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testConstructor11",
	"Comment": "constructor throws if corepoolsize argument is less than zero",
	"Method": "void testConstructor11(){\r\n    try {\r\n        new CustomTPE(-1, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10), new NoOpREHandler());\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testConstructor10",
	"Comment": "constructor throws if corepoolsize is greater than the maximumpoolsize",
	"Method": "void testConstructor10(){\r\n    try {\r\n        new CustomTPE(2, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10), new SimpleThreadFactory());\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testConstructor16",
	"Comment": "constructor throws if corepoolsize argument is less than zero",
	"Method": "void testConstructor16(){\r\n    try {\r\n        new CustomTPE(-1, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10), new SimpleThreadFactory(), new NoOpREHandler());\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "java.text.NumberFormat.getMaximumFractionDigits",
	"Comment": "returns the maximum number of digits allowed in the fraction portion of anumber.",
	"Method": "int getMaximumFractionDigits(){\r\n    return maximumFractionDigits;\r\n}"
}, {
	"Path": "java.util.concurrent.ThreadPoolExecutor.toString",
	"Comment": "returns a string identifying this pool, as well as its state,including indications of run state and estimated worker andtask counts.",
	"Method": "String toString(){\r\n    long ncompleted;\r\n    int nworkers, nactive;\r\n    final ReentrantLock mainLock = this.mainLock;\r\n    mainLock.lock();\r\n    try {\r\n        ncompleted = completedTaskCount;\r\n        nactive = 0;\r\n        nworkers = workers.size();\r\n        for (Worker w : workers) {\r\n            ncompleted += w.completedTasks;\r\n            if (w.isLocked())\r\n                ++nactive;\r\n        }\r\n    } finally {\r\n        mainLock.unlock();\r\n    }\r\n    int c = ctl.get();\r\n    String runState = runStateLessThan(c, SHUTDOWN) ? \"Running\" : runStateAtLeast(c, TERMINATED) ? \"Terminated\" : \"Shutting down\";\r\n    return super.toString() + \"[\" + runState + \", pool size = \" + nworkers + \", active threads = \" + nactive + \", queued tasks = \" + workQueue.size() + \", completed tasks = \" + ncompleted + \"]\";\r\n}"
}, {
	"Path": "java.net.InetAddress.isMulticastAddress",
	"Comment": "utility routine to check if the inetaddress is anip multicast address.",
	"Method": "boolean isMulticastAddress(){\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testConstructor20",
	"Comment": "constructor throws if corepoolsize is greater than the maximumpoolsize",
	"Method": "void testConstructor20(){\r\n    try {\r\n        new CustomTPE(2, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10), new SimpleThreadFactory(), new NoOpREHandler());\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.parseIssuerNames",
	"Comment": "parse an argument of the form passed to setissuernames,returning a collection of issuerx500principals.throw an ioexception if the argument is malformed.",
	"Method": "HashSet<X500Principal> parseIssuerNames(Collection<Object> names){\r\n    HashSet<X500Principal> x500Principals = new HashSet<X500Principal>();\r\n    for (Iterator<Object> t = names.iterator(); t.hasNext(); ) {\r\n        Object nameObject = t.next();\r\n        if (nameObject instanceof String) {\r\n            x500Principals.add(new X500Name((String) nameObject).asX500Principal());\r\n        } else {\r\n            try {\r\n                x500Principals.add(new X500Principal((byte[]) nameObject));\r\n            } catch (IllegalArgumentException e) {\r\n                throw (IOException) new IOException(\"Invalid name\").initCause(e);\r\n            }\r\n        }\r\n    }\r\n    return x500Principals;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.setSerialNumber",
	"Comment": "sets the serialnumber criterion. the specified serial numbermust match the certificate serial number in thex509certificate. if null, any certificateserial number will do.",
	"Method": "void setSerialNumber(BigInteger serial){\r\n    serialNumber = serial;\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicLongFieldUpdater.getAndIncrement",
	"Comment": "atomically increments by one the current value of the field of thegiven object managed by this updater.",
	"Method": "long getAndIncrement(T obj,long getAndIncrement,T obj){\r\n    long prev, next;\r\n    do {\r\n        prev = get(obj);\r\n        next = prev + 1;\r\n    } while (!compareAndSet(obj, prev, next));\r\n    return prev;\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkGet",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGet(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FailingAsyncFib f = new FailingAsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get();\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkGet",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGet(){\r\n    FailingAsyncFib f = new FailingAsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get();\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.ast.TreeUtil.getVariableElement",
	"Comment": "gets a variable element for the given expression if the expressionrepresents a variable. returns null otherwise.",
	"Method": "VariableElement getVariableElement(Expression node,VariableElement getVariableElement,Name node){\r\n    Element element = node.getElement();\r\n    return element != null && ElementUtil.isVariable(element) ? (VariableElement) element : null;\r\n}"
}, {
	"Path": "libcore.io.PosixTest.testPreadBytes",
	"Comment": "verify issue 554 fix, where posix.preadbytes used incorrect system call.",
	"Method": "void testPreadBytes(){\r\n    final String testString = \"hello, world!\";\r\n    byte[] bytesToWrite = testString.getBytes(\"UTF-8\");\r\n    ByteBuffer buf = ByteBuffer.allocate(bytesToWrite.length);\r\n    File tmpFile = File.createTempFile(\"preadbug-\", \".tmp\");\r\n    tmpFile.deleteOnExit();\r\n    try (FileOutputStream fos = new FileOutputStream(tmpFile)) {\r\n        fos.write(bytesToWrite);\r\n    }\r\n    try (RandomAccessFile raf = new RandomAccessFile(tmpFile, \"r\");\r\n        FileChannel channel = raf.getChannel()) {\r\n        channel.read(buf, 0);\r\n    }\r\n    String dstString = new String(buf.array(), \"UTF-8\");\r\n    assertEquals(testString, dstString);\r\n}"
}, {
	"Path": "java.util.EnumMap.containsKey",
	"Comment": "returns true if this map contains a mapping for the specifiedkey.",
	"Method": "boolean containsKey(Object key){\r\n    return isValidKey(key) && vals[((Enum) key).ordinal()] != null;\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testTryUnfork",
	"Comment": "tryunfork returns true for most recent unexecuted task,and suppresses execution",
	"Method": "void testTryUnfork(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib g = new AsyncFib(9);\r\n            assertSame(g, g.fork());\r\n            AsyncFib f = new AsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            assertTrue(f.tryUnfork());\r\n            helpQuiesce();\r\n            checkNotDone(f);\r\n            checkCompletedNormally(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testTryUnfork",
	"Comment": "tryunfork returns true for most recent unexecuted task,and suppresses execution",
	"Method": "void testTryUnfork(){\r\n    AsyncFib g = new AsyncFib(9);\r\n    assertSame(g, g.fork());\r\n    AsyncFib f = new AsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    assertTrue(f.tryUnfork());\r\n    helpQuiesce();\r\n    checkNotDone(f);\r\n    checkCompletedNormally(g);\r\n}"
}, {
	"Path": "sun.security.provider.certpath.BuildStep.getSubjectName",
	"Comment": "return string form of subject name from certificate associated with thisbuild step, or a default name if no certificate associated with thisbuild step, or if subject name could not be obtained from thecertificate.",
	"Method": "String getSubjectName(String getSubjectName,String defaultName){\r\n    return (cert == null ? defaultName : cert.getSubjectX500Principal().toString());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testFloatValueNegNotRounded",
	"Comment": "convert a positive number to a float value. rounding is not needed.",
	"Method": "void testFloatValueNegNotRounded(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = -1;\r\n    float result = -1.5474726E26f;\r\n    float aNumber = new BigInteger(aSign, a).floatValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "java.time.Period.isNegative",
	"Comment": "checks if any of the three units of this period are negative.this checks whether the years, months or days units are less than zero.",
	"Method": "boolean isNegative(){\r\n    return years < 0 || months < 0 || days < 0;\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceTest.testWeakCompareAndSet",
	"Comment": "repeated weakcompareandset succeeds in changing value when equalto expected",
	"Method": "void testWeakCompareAndSet(){\r\n    AtomicReference ai = new AtomicReference(one);\r\n    do {\r\n    } while (!ai.weakCompareAndSet(one, two));\r\n    do {\r\n    } while (!ai.weakCompareAndSet(two, m4));\r\n    assertSame(m4, ai.get());\r\n    do {\r\n    } while (!ai.weakCompareAndSet(m4, seven));\r\n    assertSame(seven, ai.get());\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testBulkRegister1",
	"Comment": "invoking bulkregister with a negative parameter throws anillegalargumentexception",
	"Method": "void testBulkRegister1(){\r\n    try {\r\n        new Phaser().bulkRegister(-1);\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testBulkRegister3",
	"Comment": "registering with a number of parties greater than or equal to 116throws illegalstateexception.",
	"Method": "void testBulkRegister3(){\r\n    assertEquals(0, new Phaser().bulkRegister((1 << 16) - 1));\r\n    try {\r\n        new Phaser().bulkRegister(1 << 16);\r\n        shouldThrow();\r\n    } catch (IllegalStateException success) {\r\n    }\r\n    try {\r\n        new Phaser(2).bulkRegister((1 << 16) - 2);\r\n        shouldThrow();\r\n    } catch (IllegalStateException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testBulkRegister2",
	"Comment": "bulkregister should correctly record the number of unarrivedparties with the number of parties being registered",
	"Method": "void testBulkRegister2(){\r\n    Phaser phaser = new Phaser();\r\n    assertEquals(0, phaser.bulkRegister(0));\r\n    assertState(phaser, 0, 0, 0);\r\n    assertEquals(0, phaser.bulkRegister(20));\r\n    assertState(phaser, 0, 20, 20);\r\n}"
}, {
	"Path": "javax.crypto.KeyAgreement.getInstance",
	"Comment": "returns a keyagreement object that implements thespecified key agreement algorithm. a new keyagreement object encapsulating thekeyagreementspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "KeyAgreement getInstance(String algorithm,KeyAgreement getInstance,String algorithm,String provider,KeyAgreement getInstance,String algorithm,Provider provider){\r\n    Instance instance = JceSecurity.getInstance(\"KeyAgreement\", KeyAgreementSpi.class, algorithm, provider);\r\n    return new KeyAgreement((KeyAgreementSpi) instance.impl, instance.provider, algorithm);\r\n}"
}, {
	"Path": "java.text.MessageFormat.setFormatsByArgumentIndex",
	"Comment": "sets the formats to use for the values passed intoformat methods or returned from parsemethods. the indices of elements in newformatscorrespond to the argument indices used in the previously setpattern string.the order of formats in newformats thus corresponds tothe order of elements in the arguments array passedto the format methods or the result array returnedby the parse methods.if an argument index is used for more than one format elementin the pattern string, then the corresponding new format is usedfor all such format elements. if an argument index is not usedfor any format element in the pattern string, then thecorresponding new format is ignored. if fewer formats are providedthan needed, then only the formats for argument indices lessthan newformats.length are replaced.",
	"Method": "void setFormatsByArgumentIndex(Format[] newFormats){\r\n    for (int i = 0; i <= maxOffset; i++) {\r\n        int j = argumentNumbers[i];\r\n        if (j < newFormats.length) {\r\n            formats[i] = newFormats[j];\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.time.format.DateTimeParseContext.addChronoChangedListener",
	"Comment": "adds a consumer to the list of listeners to be notifiedif the chronology changes.",
	"Method": "void addChronoChangedListener(Consumer<Chronology> listener){\r\n    if (chronoListeners == null) {\r\n        chronoListeners = new ArrayList<Consumer<Chronology>>();\r\n    }\r\n    chronoListeners.add(listener);\r\n}"
}, {
	"Path": "jsr166.ThreadLocalRandomTest.testNextLong",
	"Comment": "repeated calls to nextlong produce at least two distinct results",
	"Method": "void testNextLong(){\r\n    long f = ThreadLocalRandom.current().nextLong();\r\n    int i = 0;\r\n    while (i < NCALLS && ThreadLocalRandom.current().nextLong() == f) ++i;\r\n    assertTrue(i < NCALLS);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testPollNextLocalTaskAsync",
	"Comment": "pollnextlocaltask returns least recent unexecuted task withoutexecuting it, in async mode",
	"Method": "void testPollNextLocalTaskAsync(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FibAction g = new FibAction(9);\r\n            assertSame(g, g.fork());\r\n            FibAction f = new FibAction(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, pollNextLocalTask());\r\n            helpQuiesce();\r\n            checkCompletedNormally(f);\r\n            checkNotDone(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(asyncSingletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testPollNextLocalTaskAsync",
	"Comment": "pollnextlocaltask returns least recent unexecuted task withoutexecuting it, in async mode",
	"Method": "void testPollNextLocalTaskAsync(){\r\n    FibAction g = new FibAction(9);\r\n    assertSame(g, g.fork());\r\n    FibAction f = new FibAction(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, pollNextLocalTask());\r\n    helpQuiesce();\r\n    checkCompletedNormally(f);\r\n    checkNotDone(g);\r\n}"
}, {
	"Path": "java.util.RegularEnumSet.add",
	"Comment": "adds the specified element to this set if it is not already present.",
	"Method": "boolean add(E e){\r\n    typeCheck(e);\r\n    long oldElements = elements;\r\n    elements |= (1L << ((Enum) e).ordinal());\r\n    return elements != oldElements;\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.mulsub",
	"Comment": "this method is used for division. it multiplies an n word input a by oneword input x, and subtracts the n word product from q. this is neededwhen subtracting qhatdivisor from dividend.",
	"Method": "int mulsub(int[] q,int[] a,int x,int len,int offset){\r\n    long xLong = x & LONG_MASK;\r\n    long carry = 0;\r\n    offset += len;\r\n    for (int j = len - 1; j >= 0; j--) {\r\n        long product = (a[j] & LONG_MASK) * xLong + carry;\r\n        long difference = q[offset] - product;\r\n        q[offset--] = (int) difference;\r\n        carry = (product >>> 32) + (((difference & LONG_MASK) > (((~(int) product) & LONG_MASK))) ? 1 : 0);\r\n    }\r\n    return (int) carry;\r\n}"
}, {
	"Path": "test.java.time.chrono.TestExampleCode.next",
	"Comment": "simple function based on a date, returning a chronodate of the same type.",
	"Method": "D next(D date){\r\n    return (D) date.plus(1, ChronoUnit.DAYS);\r\n}"
}, {
	"Path": "java.security.spec.ECFieldF2m.equals",
	"Comment": "compares this finite field for equality with thespecified object.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj)\r\n        return true;\r\n    if (obj instanceof ECFieldF2m) {\r\n        return ((m == ((ECFieldF2m) obj).m) && (Arrays.equals(ks, ((ECFieldF2m) obj).ks)));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.rightShift",
	"Comment": "right shift this mutablebiginteger n bits. the mutablebiginteger is leftin normal form.",
	"Method": "void rightShift(int n){\r\n    if (intLen == 0)\r\n        return;\r\n    int nInts = n >>> 5;\r\n    int nBits = n & 0x1F;\r\n    this.intLen -= nInts;\r\n    if (nBits == 0)\r\n        return;\r\n    int bitsInHighWord = BigInteger.bitLengthForInt(value[offset]);\r\n    if (nBits >= bitsInHighWord) {\r\n        this.primitiveLeftShift(32 - nBits);\r\n        this.intLen--;\r\n    } else {\r\n        primitiveRightShift(nBits);\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.PolicyQualifierInfo.getPolicyQualifier",
	"Comment": "returns the asn.1 der encoded form of the qualifierfield of this policyqualifierinfo.",
	"Method": "byte[] getPolicyQualifier(){\r\n    return (mData == null ? null : mData.clone());\r\n}"
}, {
	"Path": "sun.security.x509.CertificateVersion.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(VERSION);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "java.security.cert.PKIXParameters.isAnyPolicyInhibited",
	"Comment": "checks whether the any policy oid should be processed if itis included in a certificate.",
	"Method": "boolean isAnyPolicyInhibited(){\r\n    return anyPolicyInhibited;\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testToArray_ArrayStoreException",
	"Comment": "toarray throws an arraystoreexception when the given arraycan not store the objects inside the list",
	"Method": "void testToArray_ArrayStoreException(){\r\n    CopyOnWriteArrayList c = new CopyOnWriteArrayList();\r\n    c.add(\"zfasdfsdf\");\r\n    c.add(\"asdadasd\");\r\n    try {\r\n        c.toArray(new Long[5]);\r\n        shouldThrow();\r\n    } catch (ArrayStoreException success) {\r\n    }\r\n}"
}, {
	"Path": "tests.support.Support_StringWriter.getBuffer",
	"Comment": "answer the contents of this stringwriter as a stringbuffer. any changes\tmade to the stringbuffer by the receiver or the caller are reflected in\tthis stringwriter.",
	"Method": "StringBuffer getBuffer(){\r\n    synchronized (lock) {\r\n        return buf;\r\n    }\r\n}"
}, {
	"Path": "java.io.PushbackInputStream.markSupported",
	"Comment": "tests if this input stream supports the mark andreset methods, which it does not.",
	"Method": "boolean markSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testPollTaskAsync",
	"Comment": "polltask returns an unexecuted task without executing it, inasync mode",
	"Method": "void testPollTaskAsync(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() {\r\n            FibTask g = new FibTask(9);\r\n            assertSame(g, g.fork());\r\n            FibTask f = new FibTask(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, pollTask());\r\n            helpQuiesce();\r\n            checkCompletedNormally(f, 21);\r\n            checkNotDone(g);\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(asyncSingletonPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testPollTaskAsync",
	"Comment": "polltask returns an unexecuted task without executing it, inasync mode",
	"Method": "void testPollTaskAsync(){\r\n    FibTask g = new FibTask(9);\r\n    assertSame(g, g.fork());\r\n    FibTask f = new FibTask(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, pollTask());\r\n    helpQuiesce();\r\n    checkCompletedNormally(f, 21);\r\n    checkNotDone(g);\r\n    return NoResult;\r\n}"
}, {
	"Path": "javax.net.ssl.SSLParameters.setNeedClientAuth",
	"Comment": "sets whether client authentication should be required. callingthis method clears the wantclientauth flag.",
	"Method": "void setNeedClientAuth(boolean needClientAuth){\r\n    this.wantClientAuth = false;\r\n    this.needClientAuth = needClientAuth;\r\n}"
}, {
	"Path": "java.util.regex.Pattern.quote",
	"Comment": "returns a literal pattern string for the specifiedstring.this method produces a string that can be used tocreate a pattern that would match the strings as if it were a literal pattern. metacharactersor escape sequences in the input sequence will be given no specialmeaning.",
	"Method": "String quote(String s){\r\n    int slashEIndex = s.indexOf(\"\\\\E\");\r\n    if (slashEIndex == -1)\r\n        return \"\\\\Q\" + s + \"\\\\E\";\r\n    StringBuilder sb = new StringBuilder(s.length() * 2);\r\n    sb.append(\"\\\\Q\");\r\n    slashEIndex = 0;\r\n    int current = 0;\r\n    while ((slashEIndex = s.indexOf(\"\\\\E\", current)) != -1) {\r\n        sb.append(s.substring(current, slashEIndex));\r\n        current = slashEIndex + 2;\r\n        sb.append(\"\\\\E\\\\\\\\E\\\\Q\");\r\n    }\r\n    sb.append(s.substring(current, s.length()));\r\n    sb.append(\"\\\\E\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "jsr166.TreeSubSetTest.populatedSet",
	"Comment": "returns a new set of given size containing consecutiveintegers 0 ... n.",
	"Method": "NavigableSet<Integer> populatedSet(int n){\r\n    TreeSet<Integer> q = new TreeSet<Integer>();\r\n    assertTrue(q.isEmpty());\r\n    for (int i = n - 1; i >= 0; i -= 2) assertTrue(q.add(new Integer(i)));\r\n    for (int i = (n & 1); i < n; i += 2) assertTrue(q.add(new Integer(i)));\r\n    assertTrue(q.add(new Integer(-n)));\r\n    assertTrue(q.add(new Integer(n)));\r\n    NavigableSet s = q.subSet(new Integer(0), true, new Integer(n), false);\r\n    assertFalse(s.isEmpty());\r\n    assertEquals(n, s.size());\r\n    return s;\r\n}"
}, {
	"Path": "libcore.reflect.GenericSignatureParser.parseForConstructor",
	"Comment": "parses the generic signature of a constructor and creates the datastructure representing the signature.",
	"Method": "void parseForConstructor(GenericDeclaration genericDecl,String signature,Class<?>[] rawExceptionTypes){\r\n    setInput(genericDecl, signature);\r\n    if (!eof) {\r\n        parseMethodTypeSignature(rawExceptionTypes);\r\n    } else {\r\n        Constructor c = (Constructor) genericDecl;\r\n        this.formalTypeParameters = EmptyArray.TYPE_VARIABLE;\r\n        Class<?>[] parameterTypes = c.getParameterTypes();\r\n        if (parameterTypes.length == 0) {\r\n            this.parameterTypes = ListOfTypes.EMPTY;\r\n        } else {\r\n            this.parameterTypes = new ListOfTypes(parameterTypes);\r\n        }\r\n        Class<?>[] exceptionTypes = c.getExceptionTypes();\r\n        if (exceptionTypes.length == 0) {\r\n            this.exceptionTypes = ListOfTypes.EMPTY;\r\n        } else {\r\n            this.exceptionTypes = new ListOfTypes(exceptionTypes);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "javax.net.ssl.HandshakeCompletedEvent.getPeerPrincipal",
	"Comment": "returns the identity of the peer which was established as part ofdefining the session.",
	"Method": "Principal getPeerPrincipal(){\r\n    Principal principal;\r\n    try {\r\n        principal = session.getPeerPrincipal();\r\n    } catch (AbstractMethodError e) {\r\n        Certificate[] certs = getPeerCertificates();\r\n        principal = (X500Principal) ((X509Certificate) certs[0]).getSubjectX500Principal();\r\n    }\r\n    return principal;\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinTask.pollNextLocalTask",
	"Comment": "unschedules and returns, without executing, the next taskqueued by the current thread but not yet executed, if thecurrent thread is operating in a forkjoinpool.this method isdesigned primarily to support extensions, and is unlikely to beuseful otherwise.",
	"Method": "ForkJoinTask<?> pollNextLocalTask(){\r\n    Thread t;\r\n    return ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ? ((ForkJoinWorkerThread) t).workQueue.nextLocalTask() : null;\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkJoinSingleton",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoinSingleton(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingAsyncFib f = new FailingAsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.join();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkJoinSingleton",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoinSingleton(){\r\n    FailingAsyncFib f = new FailingAsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.join();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.util.UnicodeMap.addInverseTo",
	"Comment": "gets the inverse of this map, adding to the target. like putallin",
	"Method": "U addInverseTo(U target){\r\n    for (T value : values()) {\r\n        UnicodeSet uset = getSet(value);\r\n        target.put(value, uset);\r\n    }\r\n    return target;\r\n}"
}, {
	"Path": "jsr166.AtomicLongTest.testWeakCompareAndSet",
	"Comment": "repeated weakcompareandset succeeds in changing value when equalto expected",
	"Method": "void testWeakCompareAndSet(){\r\n    AtomicLong ai = new AtomicLong(1);\r\n    do {\r\n    } while (!ai.weakCompareAndSet(1, 2));\r\n    do {\r\n    } while (!ai.weakCompareAndSet(2, -4));\r\n    assertEquals(-4, ai.get());\r\n    do {\r\n    } while (!ai.weakCompareAndSet(-4, 7));\r\n    assertEquals(7, ai.get());\r\n}"
}, {
	"Path": "java.util.jar.JarFile.initializeVerifier",
	"Comment": "initializes the verifier object by reading all the manifestentries and passing them to the verifier.",
	"Method": "void initializeVerifier(){\r\n    ManifestEntryVerifier mev = null;\r\n    try {\r\n        String[] names = getMetaInfEntryNames();\r\n        if (names != null) {\r\n            for (int i = 0; i < names.length; i++) {\r\n                JarEntry e = getJarEntry(names[i]);\r\n                if (e == null) {\r\n                    throw new JarException(\"corrupted jar file\");\r\n                }\r\n                if (!e.isDirectory()) {\r\n                    if (mev == null) {\r\n                        mev = new ManifestEntryVerifier(getManifestFromReference());\r\n                    }\r\n                    byte[] b = getBytes(e);\r\n                    if (b != null && b.length > 0) {\r\n                        jv.beginEntry(e, mev);\r\n                        jv.update(b.length, b, 0, b.length, mev);\r\n                        jv.update(-1, null, 0, 0, mev);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        jv = null;\r\n        verify = false;\r\n        if (JarVerifier.debug != null) {\r\n            JarVerifier.debug.println(\"jarfile parsing error!\");\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n    if (jv != null) {\r\n        jv.doneWithMeta();\r\n        if (JarVerifier.debug != null) {\r\n            JarVerifier.debug.println(\"done with meta!\");\r\n        }\r\n        if (jv.nothingToVerify()) {\r\n            if (JarVerifier.debug != null) {\r\n                JarVerifier.debug.println(\"nothing to verify!\");\r\n            }\r\n            jv = null;\r\n            verify = false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.beans.ChangeListenerMap.hasListeners",
	"Comment": "indicates whether the map containsat least one listener to be notified.",
	"Method": "boolean hasListeners(String name){\r\n    if (this.map == null) {\r\n        return false;\r\n    }\r\n    L[] array = this.map.get(null);\r\n    return (array != null) || ((name != null) && (null != this.map.get(name)));\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedLongSynchronizer.enq",
	"Comment": "inserts node into queue, initializing if necessary. see picture above.",
	"Method": "Node enq(Node node){\r\n    for (; ; ) {\r\n        Node oldTail = tail;\r\n        if (oldTail != null) {\r\n            U.putObject(node, Node.PREV, oldTail);\r\n            if (compareAndSetTail(oldTail, node)) {\r\n                oldTail.next = node;\r\n                return oldTail;\r\n            }\r\n        } else {\r\n            initializeSyncQueue();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.Handler.isLoggable",
	"Comment": "check if this handler would actually log a given logrecord.this method checks if the logrecord has an appropriatelevel andwhether it satisfies any filter.it alsomay make other handler specific checks that might prevent ahandler from logging the logrecord. it will return false ifthe logrecord is null.",
	"Method": "boolean isLoggable(LogRecord record){\r\n    int levelValue = getLevel().intValue();\r\n    if (record.getLevel().intValue() < levelValue || levelValue == offValue) {\r\n        return false;\r\n    }\r\n    Filter filter = getFilter();\r\n    if (filter == null) {\r\n        return true;\r\n    }\r\n    return filter.isLoggable(record);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.ErrorUtil.fatalError",
	"Comment": "report that an internal error happened when translating a specific source.",
	"Method": "void fatalError(Throwable error,String path){\r\n    StringWriter msg = new StringWriter();\r\n    PrintWriter writer = new PrintWriter(msg);\r\n    writer.println(String.format(\"internal error translating \\\"%s\\\"\", path));\r\n    error.printStackTrace(writer);\r\n    writer.flush();\r\n    error(msg.toString());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.text.DecimalFormatSymbolsTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    dfs = new DecimalFormatSymbols();\r\n    dfsUS = new DecimalFormatSymbols(new Locale(\"en\", \"us\"));\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalInvokeSingleton",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvokeSingleton(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingCCF f = new LFCCF(8);\r\n            try {\r\n                f.invoke();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalInvokeSingleton",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvokeSingleton(){\r\n    FailingCCF f = new LFCCF(8);\r\n    try {\r\n        f.invoke();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "java.util.jar.Manifest.equals",
	"Comment": "returns true if the specified object is also a manifest and hasthe same main attributes and entries.",
	"Method": "boolean equals(Object o){\r\n    if (o instanceof Manifest) {\r\n        Manifest m = (Manifest) o;\r\n        return attr.equals(m.getMainAttributes()) && entries.equals(m.getEntries());\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinPool.tryDropSpare",
	"Comment": "if the given worker is a spare with no queued tasks, and thereare enough existing workers, drops it from ctl counts and setsits state to terminated.",
	"Method": "boolean tryDropSpare(WorkQueue w){\r\n    if (w != null && w.isEmpty()) {\r\n        long c;\r\n        int sp, wl;\r\n        WorkQueue[] ws;\r\n        WorkQueue v;\r\n        while ((short) ((c = ctl) >> TC_SHIFT) > 0 && ((sp = (int) c) != 0 || (int) (c >> AC_SHIFT) > 0) && (ws = workQueues) != null && (wl = ws.length) > 0) {\r\n            boolean dropped, canDrop;\r\n            if (sp == 0) {\r\n                long nc = ((AC_MASK & (c - AC_UNIT)) | (TC_MASK & (c - TC_UNIT)) | (SP_MASK & c));\r\n                dropped = U.compareAndSwapLong(this, CTL, c, nc);\r\n            } else if ((v = ws[(wl - 1) & sp]) == null || v.scanState != sp)\r\n                dropped = false;\r\n            else {\r\n                long nc = v.stackPred & SP_MASK;\r\n                if (w == v || w.scanState >= 0) {\r\n                    canDrop = true;\r\n                    nc |= ((AC_MASK & c) | (TC_MASK & (c - TC_UNIT)));\r\n                } else {\r\n                    canDrop = false;\r\n                    nc |= ((AC_MASK & (c + AC_UNIT)) | (TC_MASK & c));\r\n                }\r\n                if (U.compareAndSwapLong(this, CTL, c, nc)) {\r\n                    v.scanState = sp & ~UNSIGNALLED;\r\n                    LockSupport.unpark(v.parker);\r\n                    dropped = canDrop;\r\n                } else\r\n                    dropped = false;\r\n            }\r\n            if (dropped) {\r\n                int cfg = w.config, idx = cfg & SMASK;\r\n                if (idx >= 0 && idx < ws.length && ws[idx] == w)\r\n                    ws[idx] = null;\r\n                w.config = cfg | UNREGISTERED;\r\n                w.qlock = -1;\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.getExponentialSymbol",
	"Comment": "returns the character used to separate the mantissa from the exponent.",
	"Method": "char getExponentialSymbol(){\r\n    return exponential;\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.divideKnuth",
	"Comment": "calculates the quotient of this div b and places the quotient in theprovided mutablebiginteger objects and the remainder object is returned.uses algorithm d in knuth section 4.3.1.many optimizations to that algorithm have been adapted from the colinplumb c library.it special cases one word divisors for speed. the content of b is notchanged.",
	"Method": "MutableBigInteger divideKnuth(MutableBigInteger b,MutableBigInteger quotient,MutableBigInteger divideKnuth,MutableBigInteger b,MutableBigInteger quotient,boolean needRemainder){\r\n    if (b.intLen == 0)\r\n        throw new ArithmeticException(\"BigInteger divide by zero\");\r\n    if (intLen == 0) {\r\n        quotient.intLen = quotient.offset = 0;\r\n        return needRemainder ? new MutableBigInteger() : null;\r\n    }\r\n    int cmp = compare(b);\r\n    if (cmp < 0) {\r\n        quotient.intLen = quotient.offset = 0;\r\n        return needRemainder ? new MutableBigInteger(this) : null;\r\n    }\r\n    if (cmp == 0) {\r\n        quotient.value[0] = quotient.intLen = 1;\r\n        quotient.offset = 0;\r\n        return needRemainder ? new MutableBigInteger() : null;\r\n    }\r\n    quotient.clear();\r\n    if (b.intLen == 1) {\r\n        int r = divideOneWord(b.value[b.offset], quotient);\r\n        if (needRemainder) {\r\n            if (r == 0)\r\n                return new MutableBigInteger();\r\n            return new MutableBigInteger(r);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    if (intLen >= KNUTH_POW2_THRESH_LEN) {\r\n        int trailingZeroBits = Math.min(getLowestSetBit(), b.getLowestSetBit());\r\n        if (trailingZeroBits >= KNUTH_POW2_THRESH_ZEROS * 32) {\r\n            MutableBigInteger a = new MutableBigInteger(this);\r\n            b = new MutableBigInteger(b);\r\n            a.rightShift(trailingZeroBits);\r\n            b.rightShift(trailingZeroBits);\r\n            MutableBigInteger r = a.divideKnuth(b, quotient);\r\n            r.leftShift(trailingZeroBits);\r\n            return r;\r\n        }\r\n    }\r\n    return divideMagnitude(b, quotient, needRemainder);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigDecimalConvertTest.testToEngineeringStringNeg",
	"Comment": "convert a negative bigdecimal to an engineering string representation",
	"Method": "void testToEngineeringStringNeg(){\r\n    String a = \"-123809648392384754573567356745735.63567890295784902768787678287E-501\";\r\n    BigDecimal aNumber = new BigDecimal(a);\r\n    String result = \"-123.80964839238475457356735674573563567890295784902768787678287E-471\";\r\n    assertEquals(\"incorrect value\", result, aNumber.toEngineeringString());\r\n}"
}, {
	"Path": "android.icu.dev.test.format.IntlTestDecimalFormatAPIC.compare",
	"Comment": "compares two vectors regardless of the order of their elements",
	"Method": "boolean compare(List vector1,List vector2){\r\n    return vector1.size() == vector2.size() && vector1.containsAll(vector2);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSubMapTest.testGet",
	"Comment": "get returns the correct element at the given key,or null if not present",
	"Method": "void testGet(){\r\n    ConcurrentNavigableMap map = map5();\r\n    assertEquals(\"A\", (String) map.get(one));\r\n    ConcurrentNavigableMap empty = map0();\r\n    assertNull(empty.get(one));\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalInvoke",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvoke(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingAsyncFib f = new FailingAsyncFib(8);\r\n            try {\r\n                f.invoke();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalInvoke",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvoke(){\r\n    FailingAsyncFib f = new FailingAsyncFib(8);\r\n    try {\r\n        f.invoke();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "java.util.WeakHashMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this map.these mappings will replace any mappings that this map had for anyof the keys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> m){\r\n    int numKeysToBeAdded = m.size();\r\n    if (numKeysToBeAdded == 0)\r\n        return;\r\n    if (numKeysToBeAdded > threshold) {\r\n        int targetCapacity = (int) (numKeysToBeAdded / loadFactor + 1);\r\n        if (targetCapacity > MAXIMUM_CAPACITY)\r\n            targetCapacity = MAXIMUM_CAPACITY;\r\n        int newCapacity = table.length;\r\n        while (newCapacity < targetCapacity) newCapacity <<= 1;\r\n        if (newCapacity > table.length)\r\n            resize(newCapacity);\r\n    }\r\n    for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) put(e.getKey(), e.getValue());\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testLongFieldUpdaterGetAndUpdate",
	"Comment": "atomiclongfieldupdater getandupdate returns previous value and updatesresult of supplied function",
	"Method": "void testLongFieldUpdaterGetAndUpdate(){\r\n    AtomicLongFieldUpdater a = aLongFieldUpdater();\r\n    a.set(this, 1);\r\n    assertEquals(1L, a.getAndUpdate(this, Atomic8Test::addLong17));\r\n    assertEquals(18L, a.getAndUpdate(this, Atomic8Test::addLong17));\r\n    assertEquals(35L, a.get(this));\r\n    assertEquals(35L, aLongField);\r\n}"
}, {
	"Path": "java.util.Date.getMonth",
	"Comment": "returns a number representing the month that contains or beginswith the instant in time represented by this date object.the value returned is between 0 and 11,with the value 0 representing january.",
	"Method": "int getMonth(){\r\n    return normalize().getMonth() - 1;\r\n}"
}, {
	"Path": "android.icu.dev.test.timezone.TimeZoneRuleTest.TestVTimeZoneRoundTripPartial",
	"Comment": "write out time zone rules of olsontimezone after a cutoff date into vtimezone format,create a new vtimezone from the vtimezone data, then compare transitions",
	"Method": "void TestVTimeZoneRoundTripPartial(){\r\n    long[] startTimes = new long[] { getUTCMillis(1900, Calendar.JANUARY, 1), getUTCMillis(1950, Calendar.JANUARY, 1), getUTCMillis(2020, Calendar.JANUARY, 1) };\r\n    long endTime = getUTCMillis(2050, Calendar.JANUARY, 1);\r\n    String[] tzids = getTestZIDs();\r\n    for (int n = 0; n < startTimes.length; n++) {\r\n        long startTime = startTimes[n];\r\n        for (int i = 0; i < tzids.length; i++) {\r\n            BasicTimeZone olsontz = (BasicTimeZone) TimeZone.getTimeZone(tzids[i], TimeZone.TIMEZONE_ICU);\r\n            VTimeZone vtz_org = VTimeZone.create(tzids[i]);\r\n            VTimeZone vtz_new = null;\r\n            try {\r\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                OutputStreamWriter writer = new OutputStreamWriter(baos);\r\n                vtz_org.write(writer, startTime);\r\n                writer.close();\r\n                byte[] vtzdata = baos.toByteArray();\r\n                ByteArrayInputStream bais = new ByteArrayInputStream(vtzdata);\r\n                InputStreamReader reader = new InputStreamReader(bais);\r\n                vtz_new = VTimeZone.create(reader);\r\n                reader.close();\r\n            } catch (IOException ioe) {\r\n                errln(\"FAIL: IO error while writing/reading VTIMEZONE data\");\r\n            }\r\n            if (vtz_new.getOffset(startTime) != olsontz.getOffset(startTime)) {\r\n                errln(\"FAIL: VTimeZone for \" + tzids[i] + \" is not equivalent to its OlsonTimeZone corresponding at \" + startTime);\r\n            }\r\n            TimeZoneTransition tzt = olsontz.getNextTransition(startTime, false);\r\n            if (tzt != null) {\r\n                if (!vtz_new.hasEquivalentTransitions(olsontz, tzt.getTime(), endTime, true)) {\r\n                    int maxDelta = 1000;\r\n                    if (!hasEquivalentTransitions(vtz_new, olsontz, tzt.getTime() + maxDelta, endTime, true, maxDelta)) {\r\n                        errln(\"FAIL: VTimeZone for \" + tzids[i] + \"(>=\" + startTime + \") is not equivalent to its OlsonTimeZone corresponding.\");\r\n                    } else {\r\n                        logln(\"VTimeZone for \" + tzids[i] + \"(>=\" + startTime + \")  differs from its OlsonTimeZone corresponding with maximum transition time delta - \" + maxDelta);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ConcurrentHashMapTest.testEnumeration",
	"Comment": "enumeration returns an enumeration containing the correctelements",
	"Method": "void testEnumeration(){\r\n    ConcurrentHashMap map = map5();\r\n    Enumeration e = map.elements();\r\n    int count = 0;\r\n    while (e.hasMoreElements()) {\r\n        count++;\r\n        e.nextElement();\r\n    }\r\n    assertEquals(5, count);\r\n}"
}, {
	"Path": "sun.security.util.Debug.getInstance",
	"Comment": "get a debug object corresponding to whether or not the givenoption is set. set the prefix to be prefix.",
	"Method": "Debug getInstance(String option,Debug getInstance,String option,String prefix){\r\n    if (isOn(option)) {\r\n        Debug d = new Debug(prefix);\r\n        return d;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.BasicChecker.verifySignature",
	"Comment": "verifies the signature on the certificate using the previous public key.",
	"Method": "void verifySignature(X509Certificate cert){\r\n    String msg = \"signature\";\r\n    if (debug != null)\r\n        debug.println(\"---checking \" + msg + \"...\");\r\n    try {\r\n        if (sigProvider != null) {\r\n            cert.verify(prevPubKey, sigProvider);\r\n        } else {\r\n            cert.verify(prevPubKey);\r\n        }\r\n    } catch (SignatureException e) {\r\n        throw new CertPathValidatorException(msg + \" check failed\", e, null, -1, BasicReason.INVALID_SIGNATURE);\r\n    } catch (GeneralSecurityException e) {\r\n        throw new CertPathValidatorException(msg + \" check failed\", e);\r\n    }\r\n    if (debug != null)\r\n        debug.println(msg + \" verified.\");\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinPool.getQueuedSubmissionCount",
	"Comment": "returns an estimate of the number of tasks submitted to thispool that have not yet begun executing.this method may taketime proportional to the number of submissions.",
	"Method": "int getQueuedSubmissionCount(){\r\n    int count = 0;\r\n    WorkQueue[] ws;\r\n    WorkQueue w;\r\n    if ((ws = workQueues) != null) {\r\n        for (int i = 0; i < ws.length; i += 2) {\r\n            if ((w = ws[i]) != null)\r\n                count += w.queueSize();\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "java.io.CharArrayWriter.reset",
	"Comment": "resets the buffer so that you can use it again withoutthrowing away the already allocated buffer.",
	"Method": "void reset(){\r\n    count = 0;\r\n}"
}, {
	"Path": "android.icu.dev.test.normalizer.UnicodeNormalizer.internalDecompose",
	"Comment": "decomposes text, either canonical or compatibility, replacing contents of the target buffer.",
	"Method": "void internalDecompose(String source,StringBuffer target){\r\n    StringBuffer buffer = new StringBuffer();\r\n    boolean canonical = (form & COMPATIBILITY_MASK) == 0;\r\n    int ch;\r\n    for (int i = 0; i < source.length(); ) {\r\n        buffer.setLength(0);\r\n        ch = UTF16Util.nextCodePoint(source, i);\r\n        i += UTF16Util.codePointLength(ch);\r\n        data.getRecursiveDecomposition(canonical, ch, buffer);\r\n        for (int j = 0; j < buffer.length(); ) {\r\n            ch = UTF16Util.nextCodePoint(buffer, j);\r\n            j += UTF16Util.codePointLength(ch);\r\n            int chClass = data.getCanonicalClass(ch);\r\n            int k = target.length();\r\n            if (chClass != 0) {\r\n                int ch2;\r\n                for (; k > 0; k -= UTF16Util.codePointLength(ch2)) {\r\n                    ch2 = UTF16Util.prevCodePoint(target, k);\r\n                    if (data.getCanonicalClass(ch2) <= chClass)\r\n                        break;\r\n                }\r\n            }\r\n            UTF16Util.insertCodePoint(target, k, ch);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.xml.sax.helpers.ParserAdapter.checkNotParsing",
	"Comment": "throw an exception if we are parsing.use this method to detect illegal feature orproperty changes.",
	"Method": "void checkNotParsing(String type,String name){\r\n    if (parsing) {\r\n        throw new SAXNotSupportedException(\"Cannot change \" + type + ' ' + name + \" while parsing\");\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.Deflater.finish",
	"Comment": "when called, indicates that compression should end with the currentcontents of the input buffer.",
	"Method": "void finish(){\r\n    synchronized (zsRef) {\r\n        finish = true;\r\n    }\r\n}"
}, {
	"Path": "java.util.Locale.getUnicodeLocaleAttributes",
	"Comment": "returns the set of unicode locale attributes associated withthis locale, or the empty set if it has no attributes. thereturned set is unmodifiable.",
	"Method": "Set<String> getUnicodeLocaleAttributes(){\r\n    if (localeExtensions == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    return localeExtensions.getUnicodeLocaleAttributes();\r\n}"
}, {
	"Path": "libcore.java.util.CalendarTest.test_nullLocale_getInstance_TimeZone_Locale",
	"Comment": "here. we should add a targetsdkversion based check and throw for this case.",
	"Method": "void test_nullLocale_getInstance_TimeZone_Locale(){\r\n    assertCalendarConfigEquals(Calendar.getInstance(TimeZone.getDefault(), Locale.getDefault()), Calendar.getInstance(TimeZone.getDefault(), null));\r\n}"
}, {
	"Path": "android.icu.dev.test.util.BytesTrieTest.checkNextString",
	"Comment": "but here we try to go partway through the string, and then beyond it.",
	"Method": "void checkNextString(BytesTrie trie,StringAndValue data,int dataLength){\r\n    for (int i = 0; i < dataLength; ++i) {\r\n        byte[] expectedString = data[i].bytes;\r\n        int stringLength = data[i].s.length();\r\n        if (!trie.next(expectedString, 0, stringLength / 2).matches()) {\r\n            errln(\"trie.next(up to middle of string)=BytesTrie.Result.NO_MATCH for \" + data[i].s);\r\n            continue;\r\n        }\r\n        trie.next(expectedString, stringLength / 2, stringLength);\r\n        if (trie.next(0).matches()) {\r\n            errln(\"trie.next(string+NUL)!=BytesTrie.Result.NO_MATCH for \" + data[i].s);\r\n        }\r\n        trie.reset();\r\n    }\r\n}"
}, {
	"Path": "java.security.AlgorithmParameters.getEncoded",
	"Comment": "returns the parameters encoded in the specified scheme.if format is null, theprimary encoding format for parameters is used. the primary encodingformat is asn.1, if an asn.1 specification for these parametersexists.",
	"Method": "byte[] getEncoded(byte[] getEncoded,String format){\r\n    if (this.initialized == false) {\r\n        throw new IOException(\"not initialized\");\r\n    }\r\n    return paramSpi.engineGetEncoded(format);\r\n}"
}, {
	"Path": "java.util.function.BiPredicate.negate",
	"Comment": "returns a predicate that represents the logical negation of thispredicate.",
	"Method": "BiPredicate<T, U> negate(){\r\n    return (T t, U u) -> !test(t, u);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testAbnormalQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvoke(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingFibAction f = new FailingFibAction(8);\r\n            f.quietlyInvoke();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testAbnormalQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvoke(){\r\n    FailingFibAction f = new FailingFibAction(8);\r\n    f.quietlyInvoke();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceArrayTest.testGetAndSet",
	"Comment": "getandset returns previous value and sets to given value at given index",
	"Method": "void testGetAndSet(){\r\n    AtomicReferenceArray aa = new AtomicReferenceArray(SIZE);\r\n    for (int i = 0; i < SIZE; i++) {\r\n        aa.set(i, one);\r\n        assertSame(one, aa.getAndSet(i, zero));\r\n        assertSame(zero, aa.getAndSet(i, m10));\r\n        assertSame(m10, aa.getAndSet(i, one));\r\n    }\r\n}"
}, {
	"Path": "jsr166.AtomicBooleanTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    final AtomicBoolean ai = new AtomicBoolean(true);\r\n    Thread t = new Thread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!ai.compareAndSet(false, true)) Thread.yield();\r\n        }\r\n    });\r\n    t.start();\r\n    assertTrue(ai.compareAndSet(true, false));\r\n    t.join(LONG_DELAY_MS);\r\n    assertFalse(t.isAlive());\r\n}"
}, {
	"Path": "jsr166.AtomicBooleanTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    while (!ai.compareAndSet(false, true)) Thread.yield();\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceEntries",
	"Comment": "returns the result of accumulating the given transformationof all entries using the given reducer to combine values,or null if none.",
	"Method": "Map.Entry<K, V> reduceEntries(long parallelismThreshold,BiFunction<Map.Entry<K, V>, Map.Entry<K, V>, ? extends Map.Entry<K, V>> reducer,U reduceEntries,long parallelismThreshold,Function<Map.Entry<K, V>, ? extends U> transformer,BiFunction<? super U, ? super U, ? extends U> reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceEntriesTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, reducer).invoke();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.Functionizer.setFunctionCaller",
	"Comment": "replace method block statements with single statement that invokes function.",
	"Method": "void setFunctionCaller(MethodDeclaration method,ExecutableElement methodElement){\r\n    TypeMirror returnType = methodElement.getReturnType();\r\n    TypeElement declaringClass = ElementUtil.getDeclaringClass(methodElement);\r\n    Block body = new Block();\r\n    method.setBody(body);\r\n    method.removeModifiers(Modifier.NATIVE);\r\n    List<Statement> stmts = body.getStatements();\r\n    FunctionInvocation invocation = new FunctionInvocation(newFunctionElement(methodElement), returnType);\r\n    List<Expression> args = invocation.getArguments();\r\n    if (!ElementUtil.isStatic(methodElement)) {\r\n        args.add(new ThisExpression(declaringClass.asType()));\r\n    }\r\n    for (SingleVariableDeclaration param : method.getParameters()) {\r\n        args.add(new SimpleName(param.getVariableElement()));\r\n    }\r\n    if (TypeUtil.isVoid(returnType)) {\r\n        stmts.add(new ExpressionStatement(invocation));\r\n        if (ElementUtil.isConstructor(methodElement)) {\r\n            stmts.add(new ReturnStatement(new ThisExpression(declaringClass.asType())));\r\n        }\r\n    } else {\r\n        stmts.add(new ReturnStatement(invocation));\r\n    }\r\n}"
}, {
	"Path": "java.nio.CharBuffer.equals",
	"Comment": "tells whether or not this buffer is equal to another object. two char buffers are equal if, and only if, they have the same element type, they have the same number of remaining elements, and the two sequences of remaining elements, consideredindependently of their starting positions, are pointwise equal. a char buffer is not equal to any other type of object.",
	"Method": "boolean equals(Object ob,boolean equals,char x,char y){\r\n    return x == y;\r\n}"
}, {
	"Path": "sun.nio.ch.ServerSocketChannelImpl.translateAndSetInterestOps",
	"Comment": "translates an interest operation set into a native poll event set",
	"Method": "void translateAndSetInterestOps(int ops,SelectionKeyImpl sk){\r\n    int newOps = 0;\r\n    if ((ops & SelectionKey.OP_ACCEPT) != 0)\r\n        newOps |= PollArrayWrapper.POLLIN;\r\n    sk.selector.putEventOps(sk, newOps);\r\n}"
}, {
	"Path": "sun.security.provider.certpath.SunCertPathBuilder.anchorIsTarget",
	"Comment": "returns true if trust anchor certificate matches specifiedcertificate constraints.",
	"Method": "boolean anchorIsTarget(TrustAnchor anchor,CertSelector sel){\r\n    X509Certificate anchorCert = anchor.getTrustedCert();\r\n    if (anchorCert != null) {\r\n        return sel.match(anchorCert);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.setMaxCRLNumber",
	"Comment": "sets the maxcrlnumber criterion. the x509crl must have acrl number extension whose value is less than or equal to thespecified value. if null, no maxcrlnumber check will bedone.",
	"Method": "void setMaxCRLNumber(BigInteger maxCRL){\r\n    this.maxCRL = maxCRL;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberFormatTest.Test11621",
	"Comment": "test that the decimal is shown even when there are no fractional digits",
	"Method": "void Test11621(){\r\n    String pat = \"0.##E0\";\r\n    DecimalFormatSymbols icuSym = new DecimalFormatSymbols(Locale.US);\r\n    DecimalFormat icuFmt = new DecimalFormat(pat, icuSym);\r\n    icuFmt.setDecimalSeparatorAlwaysShown(true);\r\n    String icu = ((NumberFormat) icuFmt).format(299792458);\r\n    java.text.DecimalFormatSymbols jdkSym = new java.text.DecimalFormatSymbols(Locale.US);\r\n    java.text.DecimalFormat jdkFmt = new java.text.DecimalFormat(pat, jdkSym);\r\n    jdkFmt.setDecimalSeparatorAlwaysShown(true);\r\n    String jdk = ((java.text.NumberFormat) jdkFmt).format(299792458);\r\n    assertEquals(\"ICU and JDK placement of decimal in exponent\", jdk, icu);\r\n}"
}, {
	"Path": "jsr166.ConcurrentHashMapTest.testReplaceValue",
	"Comment": "replace value fails when the given key not mapped to expected value",
	"Method": "void testReplaceValue(){\r\n    ConcurrentHashMap map = map5();\r\n    assertEquals(\"A\", map.get(one));\r\n    assertFalse(map.replace(one, \"Z\", \"Z\"));\r\n    assertEquals(\"A\", map.get(one));\r\n}"
}, {
	"Path": "java.lang.reflect.Type.getTypeName",
	"Comment": "returns a string describing this type, including informationabout any type parameters.",
	"Method": "String getTypeName(){\r\n    return toString();\r\n}"
}, {
	"Path": "java.util.zip.InflaterInputStream.markSupported",
	"Comment": "tests if this input stream supports the mark andreset methods. the marksupportedmethod of inflaterinputstream returnsfalse.",
	"Method": "boolean markSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "android.icu.dev.util.CollectionUtilities.matchesAt",
	"Comment": "does one string contain another, starting at a specific offset?",
	"Method": "int matchesAt(CharSequence text,int offset,CharSequence other){\r\n    int len = other.length();\r\n    int i = 0;\r\n    int j = offset;\r\n    for (; i < len; ++i, ++j) {\r\n        char pc = other.charAt(i);\r\n        char tc = text.charAt(j);\r\n        if (pc != tc)\r\n            return -1;\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testShutdownNow",
	"Comment": "shutdownnow returns a list containing tasks that were not run,and those tasks are drained from the queue",
	"Method": "void testShutdownNow(){\r\n    final int poolSize = 2;\r\n    final int count = 5;\r\n    final AtomicInteger ran = new AtomicInteger(0);\r\n    final ThreadPoolExecutor p = new CustomTPE(poolSize, poolSize, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    final CountDownLatch threadsStarted = new CountDownLatch(poolSize);\r\n    Runnable waiter = new CheckedRunnable() {\r\n        public void realRun() {\r\n            threadsStarted.countDown();\r\n            try {\r\n                MILLISECONDS.sleep(2 * LONG_DELAY_MS);\r\n            } catch (InterruptedException success) {\r\n            }\r\n            ran.getAndIncrement();\r\n        }\r\n    };\r\n    for (int i = 0; i < count; i++) p.execute(waiter);\r\n    await(threadsStarted);\r\n    assertEquals(poolSize, p.getActiveCount());\r\n    assertEquals(0, p.getCompletedTaskCount());\r\n    final List<Runnable> queuedTasks;\r\n    try {\r\n        queuedTasks = p.shutdownNow();\r\n    } catch (SecurityException ok) {\r\n        return;\r\n    }\r\n    assertTrue(p.isShutdown());\r\n    assertTrue(p.getQueue().isEmpty());\r\n    assertEquals(count - poolSize, queuedTasks.size());\r\n    assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));\r\n    assertTrue(p.isTerminated());\r\n    assertEquals(poolSize, ran.get());\r\n    assertEquals(poolSize, p.getCompletedTaskCount());\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testShutdownNow",
	"Comment": "shutdownnow returns a list containing tasks that were not run,and those tasks are drained from the queue",
	"Method": "void testShutdownNow(){\r\n    threadsStarted.countDown();\r\n    try {\r\n        MILLISECONDS.sleep(2 * LONG_DELAY_MS);\r\n    } catch (InterruptedException success) {\r\n    }\r\n    ran.getAndIncrement();\r\n}"
}, {
	"Path": "java.net.URLConnection.setDefaultUseCaches",
	"Comment": "sets the default value of the usecaches field to thespecified value.",
	"Method": "void setDefaultUseCaches(boolean defaultusecaches){\r\n    defaultUseCaches = defaultusecaches;\r\n}"
}, {
	"Path": "sun.security.x509.GeneralSubtrees.minimize",
	"Comment": "minimize this generalsubtrees by removing all redundant entries.internal method used by intersect and reduce.",
	"Method": "void minimize(){\r\n    for (int i = 0; i < size(); i++) {\r\n        GeneralNameInterface current = getGeneralNameInterface(i);\r\n        boolean remove1 = false;\r\n        for (int j = i + 1; j < size(); j++) {\r\n            GeneralNameInterface subsequent = getGeneralNameInterface(j);\r\n            switch(current.constrains(subsequent)) {\r\n                case GeneralNameInterface.NAME_DIFF_TYPE:\r\n                    continue;\r\n                case GeneralNameInterface.NAME_MATCH:\r\n                    remove1 = true;\r\n                    break;\r\n                case GeneralNameInterface.NAME_NARROWS:\r\n                    remove(j);\r\n                    j--;\r\n                    continue;\r\n                case GeneralNameInterface.NAME_WIDENS:\r\n                    remove1 = true;\r\n                    break;\r\n                case GeneralNameInterface.NAME_SAME_TYPE:\r\n                    continue;\r\n            }\r\n            break;\r\n        }\r\n        if (remove1) {\r\n            remove(i);\r\n            i--;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.AtomicLongArrayTest.testWeakCompareAndSet",
	"Comment": "repeated weakcompareandset succeeds in changing value when equalto expected",
	"Method": "void testWeakCompareAndSet(){\r\n    AtomicLongArray aa = new AtomicLongArray(SIZE);\r\n    for (int i = 0; i < SIZE; i++) {\r\n        aa.set(i, 1);\r\n        do {\r\n        } while (!aa.weakCompareAndSet(i, 1, 2));\r\n        do {\r\n        } while (!aa.weakCompareAndSet(i, 2, -4));\r\n        assertEquals(-4, aa.get(i));\r\n        do {\r\n        } while (!aa.weakCompareAndSet(i, -4, 7));\r\n        assertEquals(7, aa.get(i));\r\n    }\r\n}"
}, {
	"Path": "java.util.jar.Attributes.read",
	"Comment": "reads attributes from the specified input stream.xxx need to handle utf8 values.",
	"Method": "void read(Manifest.FastInputStream is,byte[] lbuf){\r\n    String name = null, value = null;\r\n    byte[] lastline = null;\r\n    int len;\r\n    while ((len = is.readLine(lbuf)) != -1) {\r\n        boolean lineContinued = false;\r\n        if (lbuf[--len] != '\\n') {\r\n            throw new IOException(\"line too long\");\r\n        }\r\n        if (len > 0 && lbuf[len - 1] == '\\r') {\r\n            --len;\r\n        }\r\n        if (len == 0) {\r\n            break;\r\n        }\r\n        int i = 0;\r\n        if (lbuf[0] == ' ') {\r\n            if (name == null) {\r\n                throw new IOException(\"misplaced continuation line\");\r\n            }\r\n            lineContinued = true;\r\n            byte[] buf = new byte[lastline.length + len - 1];\r\n            System.arraycopy(lastline, 0, buf, 0, lastline.length);\r\n            System.arraycopy(lbuf, 1, buf, lastline.length, len - 1);\r\n            if (is.peek() == ' ') {\r\n                lastline = buf;\r\n                continue;\r\n            }\r\n            value = new String(buf, 0, buf.length, \"UTF8\");\r\n            lastline = null;\r\n        } else {\r\n            while (lbuf[i++] != ':') {\r\n                if (i >= len) {\r\n                    throw new IOException(\"invalid header field\");\r\n                }\r\n            }\r\n            if (lbuf[i++] != ' ') {\r\n                throw new IOException(\"invalid header field\");\r\n            }\r\n            name = new String(lbuf, 0, 0, i - 2);\r\n            if (is.peek() == ' ') {\r\n                lastline = new byte[len - i];\r\n                System.arraycopy(lbuf, i, lastline, 0, len - i);\r\n                continue;\r\n            }\r\n            value = new String(lbuf, i, len - i, \"UTF8\");\r\n        }\r\n        try {\r\n            if ((putValue(name, value) != null) && (!lineContinued)) {\r\n                PlatformLogger.getLogger(\"java.util.jar\").warning(\"Duplicate name in Manifest: \" + name + \".\\n\" + \"Ensure that the manifest does not \" + \"have duplicate entries, and\\n\" + \"that blank lines separate \" + \"individual sections in both your\\n\" + \"manifest and in the META-INF/MANIFEST.MF \" + \"entry in the jar file.\");\r\n            }\r\n        } catch (IllegalArgumentException e) {\r\n            throw new IOException(\"invalid header field name: \" + name);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.DistributionPoint.getRelativeName",
	"Comment": "return the relative distribution point name or null if not set.",
	"Method": "RDN getRelativeName(){\r\n    return relativeName;\r\n}"
}, {
	"Path": "java.net.URLStreamHandler.getHostAddress",
	"Comment": "get the ip address of our host. an empty host field or a dns failurewill result in a null return.",
	"Method": "InetAddress getHostAddress(URL u){\r\n    if (u.hostAddress != null)\r\n        return u.hostAddress;\r\n    String host = u.getHost();\r\n    if (host == null || host.equals(\"\")) {\r\n        return null;\r\n    } else {\r\n        try {\r\n            u.hostAddress = InetAddress.getByName(host);\r\n        } catch (UnknownHostException ex) {\r\n            return null;\r\n        } catch (SecurityException se) {\r\n            return null;\r\n        }\r\n    }\r\n    return u.hostAddress;\r\n}"
}, {
	"Path": "java.time.format.DecimalStyle.convertToDigit",
	"Comment": "checks whether the character is a digit, based on the currently set zero character.",
	"Method": "int convertToDigit(char ch){\r\n    int val = ch - zeroDigit;\r\n    return (val >= 0 && val <= 9) ? val : -1;\r\n}"
}, {
	"Path": "java.text.DateFormat.format",
	"Comment": "overrides format.formats a time object into a time string. examples of time objectsare a time value expressed in milliseconds and a date object.",
	"Method": "StringBuffer format(Object obj,StringBuffer toAppendTo,FieldPosition fieldPosition,StringBuffer format,Date date,StringBuffer toAppendTo,FieldPosition fieldPosition,String format,Date date){\r\n    return format(date, new StringBuffer(), DontCareFieldPosition.INSTANCE).toString();\r\n}"
}, {
	"Path": "java.net.DatagramSocket.getImpl",
	"Comment": "get the datagramsocketimpl attached to this socket,creating it if necessary.",
	"Method": "DatagramSocketImpl getImpl(){\r\n    if (!created)\r\n        createImpl();\r\n    return impl;\r\n}"
}, {
	"Path": "java.security.spec.EllipticCurve.getField",
	"Comment": "returns the finite field field that thiselliptic curve is over.",
	"Method": "ECField getField(){\r\n    return field;\r\n}"
}, {
	"Path": "java.util.InvalidPropertiesFormatException.writeObject",
	"Comment": "throws notserializableexception, since invalidpropertiesformatexceptionobjects are not intended to be serializable.",
	"Method": "void writeObject(java.io.ObjectOutputStream out){\r\n    throw new NotSerializableException(\"Not serializable.\");\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testFirstComplete",
	"Comment": "firstcomplete returns this if pending count is zero else null",
	"Method": "void testFirstComplete(){\r\n    NoopCC a = new NoopCC();\r\n    a.setPendingCount(1);\r\n    assertNull(a.firstComplete());\r\n    a.checkIncomplete();\r\n    assertSame(a, a.firstComplete());\r\n    a.checkIncomplete();\r\n}"
}, {
	"Path": "java.text.ChoiceFormat.previousDouble",
	"Comment": "finds the greatest double less than d.if nan, returns same value.",
	"Method": "double previousDouble(double d){\r\n    return nextDouble(d, false);\r\n}"
}, {
	"Path": "java.util.Calendar.updateTime",
	"Comment": "recomputes the time and updates the status fields istimesetand arefieldsset.callers should check istimeset and onlycall this method if istimeset is false.",
	"Method": "void updateTime(){\r\n    computeTime();\r\n    isTimeSet = true;\r\n}"
}, {
	"Path": "jsr166.ReentrantLockTest.assertHasWaiters",
	"Comment": "checks that condition c has exactly the given waiter threads.",
	"Method": "void assertHasWaiters(PublicReentrantLock lock,Condition c,Thread threads){\r\n    lock.lock();\r\n    assertEquals(threads.length > 0, lock.hasWaiters(c));\r\n    assertEquals(threads.length, lock.getWaitQueueLength(c));\r\n    assertEquals(threads.length == 0, lock.getWaitingThreads(c).isEmpty());\r\n    assertEquals(threads.length, lock.getWaitingThreads(c).size());\r\n    assertEquals(new HashSet<Thread>(lock.getWaitingThreads(c)), new HashSet<Thread>(Arrays.asList(threads)));\r\n    lock.unlock();\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testPollNextLocalTask",
	"Comment": "pollnextlocaltask returns most recent unexecuted taskwithout executing it",
	"Method": "void testPollNextLocalTask(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FibAction g = new FibAction(9);\r\n            assertSame(g, g.fork());\r\n            FibAction f = new FibAction(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(f, pollNextLocalTask());\r\n            helpQuiesce();\r\n            checkNotDone(f);\r\n            checkCompletedNormally(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testPollNextLocalTask",
	"Comment": "pollnextlocaltask returns most recent unexecuted taskwithout executing it",
	"Method": "void testPollNextLocalTask(){\r\n    FibAction g = new FibAction(9);\r\n    assertSame(g, g.fork());\r\n    FibAction f = new FibAction(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(f, pollNextLocalTask());\r\n    helpQuiesce();\r\n    checkNotDone(f);\r\n    checkCompletedNormally(g);\r\n}"
}, {
	"Path": "java.util.concurrent.DelayQueue.take",
	"Comment": "retrieves and removes the head of this queue, waiting if necessaryuntil an element with an expired delay is available on this queue.",
	"Method": "E take(){\r\n    final ReentrantLock lock = this.lock;\r\n    lock.lockInterruptibly();\r\n    try {\r\n        for (; ; ) {\r\n            E first = q.peek();\r\n            if (first == null)\r\n                available.await();\r\n            else {\r\n                long delay = first.getDelay(NANOSECONDS);\r\n                if (delay <= 0L)\r\n                    return q.poll();\r\n                first = null;\r\n                if (leader != null)\r\n                    available.await();\r\n                else {\r\n                    Thread thisThread = Thread.currentThread();\r\n                    leader = thisThread;\r\n                    try {\r\n                        available.awaitNanos(delay);\r\n                    } finally {\r\n                        if (leader == thisThread)\r\n                            leader = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        if (leader == null && q.peek() != null)\r\n            available.signal();\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "java.time.format.DateTimeParseContext.copy",
	"Comment": "creates a copy of this context.this retains the case sensitive and strict flags.",
	"Method": "DateTimeParseContext copy(){\r\n    DateTimeParseContext newContext = new DateTimeParseContext(formatter);\r\n    newContext.caseSensitive = caseSensitive;\r\n    newContext.strict = strict;\r\n    return newContext;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.RbnfTest.TestMultiplePluralRules",
	"Comment": "perform a simple spot check on the parsing going into an infinite loop for alternate rules.",
	"Method": "void TestMultiplePluralRules(){\r\n    String ruRules = \"%spellout-cardinal-feminine-genitive:\" + \"-x:  >>;\" + \"x.x: <<  >>;\" + \"0: ;\" + \"1: ;\" + \"2: ;\" + \"3: ;\" + \"4: ;\" + \"5: ;\" + \"6: ;\" + \"7: ;\" + \"8: ;\" + \"9: ;\" + \"10: ;\" + \"11: ;\" + \"12: ;\" + \"13: ;\" + \"14: ;\" + \"15: ;\" + \"16: ;\" + \"17: ;\" + \"18: ;\" + \"19: ;\" + \"20: [ >>];\" + \"30: [ >>];\" + \"40: [ >>];\" + \"50: [ >>];\" + \"60: [ >>];\" + \"70: [ >>];\" + \"80: [ >>];\" + \"90: [ >>];\" + \"100: [ >>];\" + \"200: <<[ >>];\" + \"1000: << $(cardinal,one{}few{}other{})$[ >>];\" + \"1000000: =#,##0=;\" + \"%spellout-cardinal-feminine:\" + \"-x:  >>;\" + \"x.x: <<  >>;\" + \"0: ;\" + \"1: ;\" + \"2: ;\" + \"3: ;\" + \"4: ;\" + \"5: ;\" + \"6: ;\" + \"7: ;\" + \"8: ;\" + \"9: ;\" + \"10: ;\" + \"11: ;\" + \"12: ;\" + \"13: ;\" + \"14: ;\" + \"15: ;\" + \"16: ;\" + \"17: ;\" + \"18: ;\" + \"19: ;\" + \"20: [ >>];\" + \"30: [ >>];\" + \"40: [ >>];\" + \"50: [ >>];\" + \"60: [ >>];\" + \"70: [ >>];\" + \"80: [ >>];\" + \"90: [ >>];\" + \"100: [ >>];\" + \"200: <<[ >>];\" + \"300: <<[ >>];\" + \"500: <<[ >>];\" + \"1000: << $(cardinal,one{}few{}other{})$[ >>];\" + \"1000000: =#,##0=;\";\r\n    RuleBasedNumberFormat ruFormatter = new RuleBasedNumberFormat(ruRules, new ULocale(\"ru\"));\r\n    try {\r\n        Number result;\r\n        if (1000 != (result = ruFormatter.parse(ruFormatter.format(1000))).doubleValue()) {\r\n            errln(\"RuleBasedNumberFormat did not return the correct value. Got: \" + result);\r\n        }\r\n        if (1000 != (result = ruFormatter.parse(ruFormatter.format(1000, \"%spellout-cardinal-feminine-genitive\"))).doubleValue()) {\r\n            errln(\"RuleBasedNumberFormat did not return the correct value. Got: \" + result);\r\n        }\r\n        if (1000 != (result = ruFormatter.parse(ruFormatter.format(1000, \"%spellout-cardinal-feminine\"))).doubleValue()) {\r\n            errln(\"RuleBasedNumberFormat did not return the correct value. Got: \" + result);\r\n        }\r\n    } catch (ParseException e) {\r\n        errln(e.toString());\r\n    }\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArriveAndAwaitAdvanceAfterInterrupt",
	"Comment": "arriveandawaitadvance continues waiting if interrupted before waiting",
	"Method": "void testArriveAndAwaitAdvanceAfterInterrupt(){\r\n    final Phaser phaser = new Phaser();\r\n    assertEquals(0, phaser.register());\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            Thread.currentThread().interrupt();\r\n            assertEquals(0, phaser.register());\r\n            pleaseInterrupt.countDown();\r\n            assertTrue(Thread.currentThread().isInterrupted());\r\n            assertEquals(1, phaser.arriveAndAwaitAdvance());\r\n            assertTrue(Thread.currentThread().isInterrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    waitForThreadToEnterWaitState(t, SHORT_DELAY_MS);\r\n    Thread.currentThread().interrupt();\r\n    assertEquals(1, phaser.arriveAndAwaitAdvance());\r\n    assertTrue(Thread.interrupted());\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArriveAndAwaitAdvanceAfterInterrupt",
	"Comment": "arriveandawaitadvance continues waiting if interrupted before waiting",
	"Method": "void testArriveAndAwaitAdvanceAfterInterrupt(){\r\n    Thread.currentThread().interrupt();\r\n    assertEquals(0, phaser.register());\r\n    pleaseInterrupt.countDown();\r\n    assertTrue(Thread.currentThread().isInterrupted());\r\n    assertEquals(1, phaser.arriveAndAwaitAdvance());\r\n    assertTrue(Thread.currentThread().isInterrupted());\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.unmaskNull",
	"Comment": "returns internal representation of null key back to caller as null.",
	"Method": "Object unmaskNull(Object key){\r\n    return (key == NULL_KEY ? null : key);\r\n}"
}, {
	"Path": "java.net.Inet4Address.isMulticastAddress",
	"Comment": "utility routine to check if the inetaddress is anip multicast address. ip multicast address is a class daddress i.e first four bits of the address are 1110.",
	"Method": "boolean isMulticastAddress(){\r\n    return ((holder().getAddress() & 0xf0000000) == 0xe0000000);\r\n}"
}, {
	"Path": "jsr166.TimeUnitTest.testTimedWait_IllegalMonitorException",
	"Comment": "timed wait without holding lock throwsillegalmonitorstateexception",
	"Method": "void testTimedWait_IllegalMonitorException(){\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            Object o = new Object();\r\n            TimeUnit tu = MILLISECONDS;\r\n            try {\r\n                tu.timedWait(o, LONG_DELAY_MS);\r\n                threadShouldThrow();\r\n            } catch (IllegalMonitorStateException success) {\r\n            }\r\n        }\r\n    });\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.TimeUnitTest.testTimedWait_IllegalMonitorException",
	"Comment": "timed wait without holding lock throwsillegalmonitorstateexception",
	"Method": "void testTimedWait_IllegalMonitorException(){\r\n    Object o = new Object();\r\n    TimeUnit tu = MILLISECONDS;\r\n    try {\r\n        tu.timedWait(o, LONG_DELAY_MS);\r\n        threadShouldThrow();\r\n    } catch (IllegalMonitorStateException success) {\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.X509CRLEntryImpl.getRevocationDate",
	"Comment": "gets the revocation date from this x509crlentry,the revocationdate.",
	"Method": "Date getRevocationDate(){\r\n    return new Date(revocationDate.getTime());\r\n}"
}, {
	"Path": "sun.util.calendar.CalendarUtils.isGregorianLeapYear",
	"Comment": "returns whether the specified year is a leap year in the gregoriancalendar system.",
	"Method": "boolean isGregorianLeapYear(int gregorianYear){\r\n    return (((gregorianYear % 4) == 0) && (((gregorianYear % 100) != 0) || ((gregorianYear % 400) == 0)));\r\n}"
}, {
	"Path": "java.time.Year.format",
	"Comment": "formats this year using the specified formatter.this year will be passed to the formatter to produce a string.",
	"Method": "String format(DateTimeFormatter formatter){\r\n    Objects.requireNonNull(formatter, \"formatter\");\r\n    return formatter.format(this);\r\n}"
}, {
	"Path": "java.util.ListResourceBundle.loadLookup",
	"Comment": "we lazily load the lookup hashtable.this function does theloading.",
	"Method": "void loadLookup(){\r\n    if (lookup != null)\r\n        return;\r\n    Object[][] contents = getContents();\r\n    HashMap<String, Object> temp = new HashMap(contents.length);\r\n    for (int i = 0; i < contents.length; ++i) {\r\n        String key = (String) contents[i][0];\r\n        Object value = contents[i][1];\r\n        if (key == null || value == null) {\r\n            throw new NullPointerException();\r\n        }\r\n        temp.put(key, value);\r\n    }\r\n    lookup = temp;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.setCertificateValid",
	"Comment": "sets the certificatevalid criterion. the specified date must fallwithin the certificate validity period for thex509certificate. if null, no certificatevalidcheck will be done.note that the date supplied here is cloned to protectagainst subsequent modifications.",
	"Method": "void setCertificateValid(Date certValid){\r\n    if (certValid == null) {\r\n        certificateValid = null;\r\n    } else {\r\n        certificateValid = (Date) certValid.clone();\r\n    }\r\n}"
}, {
	"Path": "java.security.KeyPair.getPublic",
	"Comment": "returns a reference to the public key component of this key pair.",
	"Method": "PublicKey getPublic(){\r\n    return publicKey;\r\n}"
}, {
	"Path": "org.kxml2.io.KXmlParser.readQuotedId",
	"Comment": "reads a quoted string, performing no entity escaping of the contents.",
	"Method": "String readQuotedId(boolean returnText){\r\n    int quote = peekCharacter();\r\n    char[] delimiter;\r\n    if (quote == '\"') {\r\n        delimiter = DOUBLE_QUOTE;\r\n    } else if (quote == '\\'') {\r\n        delimiter = SINGLE_QUOTE;\r\n    } else {\r\n        throw new XmlPullParserException(\"Expected a quoted string\", this, null);\r\n    }\r\n    position++;\r\n    return readUntil(delimiter, returnText);\r\n}"
}, {
	"Path": "java.security.cert.PKIXParameters.setCertStores",
	"Comment": "sets the list of certstores to be used in findingcertificates and crls. may be null, in which caseno certstores will be used. the firstcertstores in the list may be preferred to those thatappear later.note that the list is copied to protect againstsubsequent modifications.",
	"Method": "void setCertStores(List<CertStore> stores){\r\n    if (stores == null) {\r\n        this.certStores = new ArrayList<CertStore>();\r\n    } else {\r\n        for (Iterator<CertStore> i = stores.iterator(); i.hasNext(); ) {\r\n            if (!(i.next() instanceof CertStore)) {\r\n                throw new ClassCastException(\"all elements of list must be \" + \"of type java.security.cert.CertStore\");\r\n            }\r\n        }\r\n        this.certStores = new ArrayList<CertStore>(stores);\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicMarkableReference.set",
	"Comment": "unconditionally sets the value of both the reference and mark.",
	"Method": "void set(V newReference,boolean newMark){\r\n    Pair<V> current = pair;\r\n    if (newReference != current.reference || newMark != current.mark)\r\n        this.pair = Pair.of(newReference, newMark);\r\n}"
}, {
	"Path": "android.icu.dev.test.TestFmwk.sourceLocation",
	"Comment": "return the source code location of the caller located calldepth frames up the stack.",
	"Method": "String sourceLocation(){\r\n    for (StackTraceElement st : new Throwable().getStackTrace()) {\r\n        String source = st.getFileName();\r\n        if (source != null && !source.equals(\"TestFmwk.java\") && !source.equals(\"AbstractTestLog.java\")) {\r\n            String methodName = st.getMethodName();\r\n            if (methodName != null && (methodName.startsWith(\"Test\") || methodName.startsWith(\"test\") || methodName.equals(\"main\"))) {\r\n                return \"(\" + source + \":\" + st.getLineNumber() + \") \";\r\n            }\r\n        }\r\n    }\r\n    throw new InternalError();\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.testConstructor5",
	"Comment": "initializing from collection with some null elements throws npe",
	"Method": "void testConstructor5(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        new ConcurrentSkipListSet(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.net.Inet6Address.isLinkLocalAddress",
	"Comment": "utility routine to check if the inetaddress is an link local address.",
	"Method": "boolean isLinkLocalAddress(){\r\n    return ((ipaddress[0] & 0xff) == 0xfe && (ipaddress[1] & 0xc0) == 0x80);\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.getFixedDate",
	"Comment": "computes the fixed date under either the gregorian or thejulian calendar, using the given year and the specified calendar fields.",
	"Method": "long getFixedDate(BaseCalendar cal,int year,int fieldMask){\r\n    int month = JANUARY;\r\n    if (isFieldSet(fieldMask, MONTH)) {\r\n        month = internalGet(MONTH);\r\n        if (month > DECEMBER) {\r\n            year += month / 12;\r\n            month %= 12;\r\n        } else if (month < JANUARY) {\r\n            int[] rem = new int[1];\r\n            year += CalendarUtils.floorDivide(month, 12, rem);\r\n            month = rem[0];\r\n        }\r\n    }\r\n    long fixedDate = cal.getFixedDate(year, month + 1, 1, cal == gcal ? gdate : null);\r\n    if (isFieldSet(fieldMask, MONTH)) {\r\n        if (isFieldSet(fieldMask, DAY_OF_MONTH)) {\r\n            if (isSet(DAY_OF_MONTH)) {\r\n                fixedDate += internalGet(DAY_OF_MONTH);\r\n                fixedDate--;\r\n            }\r\n        } else {\r\n            if (isFieldSet(fieldMask, WEEK_OF_MONTH)) {\r\n                long firstDayOfWeek = cal.getDayOfWeekDateOnOrBefore(fixedDate + 6, getFirstDayOfWeek());\r\n                if ((firstDayOfWeek - fixedDate) >= getMinimalDaysInFirstWeek()) {\r\n                    firstDayOfWeek -= 7;\r\n                }\r\n                if (isFieldSet(fieldMask, DAY_OF_WEEK)) {\r\n                    firstDayOfWeek = cal.getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6, internalGet(DAY_OF_WEEK));\r\n                }\r\n                fixedDate = firstDayOfWeek + 7 * (internalGet(WEEK_OF_MONTH) - 1);\r\n            } else {\r\n                int dayOfWeek;\r\n                if (isFieldSet(fieldMask, DAY_OF_WEEK)) {\r\n                    dayOfWeek = internalGet(DAY_OF_WEEK);\r\n                } else {\r\n                    dayOfWeek = getFirstDayOfWeek();\r\n                }\r\n                int dowim;\r\n                if (isFieldSet(fieldMask, DAY_OF_WEEK_IN_MONTH)) {\r\n                    dowim = internalGet(DAY_OF_WEEK_IN_MONTH);\r\n                } else {\r\n                    dowim = 1;\r\n                }\r\n                if (dowim >= 0) {\r\n                    fixedDate = cal.getDayOfWeekDateOnOrBefore(fixedDate + (7 * dowim) - 1, dayOfWeek);\r\n                } else {\r\n                    int lastDate = monthLength(month, year) + (7 * (dowim + 1));\r\n                    fixedDate = cal.getDayOfWeekDateOnOrBefore(fixedDate + lastDate - 1, dayOfWeek);\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        if (year == gregorianCutoverYear && cal == gcal && fixedDate < gregorianCutoverDate && gregorianCutoverYear != gregorianCutoverYearJulian) {\r\n            fixedDate = gregorianCutoverDate;\r\n        }\r\n        if (isFieldSet(fieldMask, DAY_OF_YEAR)) {\r\n            fixedDate += internalGet(DAY_OF_YEAR);\r\n            fixedDate--;\r\n        } else {\r\n            long firstDayOfWeek = cal.getDayOfWeekDateOnOrBefore(fixedDate + 6, getFirstDayOfWeek());\r\n            if ((firstDayOfWeek - fixedDate) >= getMinimalDaysInFirstWeek()) {\r\n                firstDayOfWeek -= 7;\r\n            }\r\n            if (isFieldSet(fieldMask, DAY_OF_WEEK)) {\r\n                int dayOfWeek = internalGet(DAY_OF_WEEK);\r\n                if (dayOfWeek != getFirstDayOfWeek()) {\r\n                    firstDayOfWeek = cal.getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6, dayOfWeek);\r\n                }\r\n            }\r\n            fixedDate = firstDayOfWeek + 7 * ((long) internalGet(WEEK_OF_YEAR) - 1);\r\n        }\r\n    }\r\n    return fixedDate;\r\n}"
}, {
	"Path": "java.time.Instant.minusSeconds",
	"Comment": "returns a copy of this instant with the specified duration in seconds subtracted.this instance is immutable and unaffected by this method call.",
	"Method": "Instant minusSeconds(long secondsToSubtract){\r\n    if (secondsToSubtract == Long.MIN_VALUE) {\r\n        return plusSeconds(Long.MAX_VALUE).plusSeconds(1);\r\n    }\r\n    return plusSeconds(-secondsToSubtract);\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.getExtension",
	"Comment": "gets the extension identified by the given objectidentifier",
	"Method": "Extension getExtension(ObjectIdentifier oid){\r\n    if (info == null) {\r\n        return null;\r\n    }\r\n    try {\r\n        CertificateExtensions extensions;\r\n        try {\r\n            extensions = (CertificateExtensions) info.get(CertificateExtensions.NAME);\r\n        } catch (CertificateException ce) {\r\n            return null;\r\n        }\r\n        if (extensions == null) {\r\n            return null;\r\n        } else {\r\n            Extension ex = extensions.getExtension(oid.toString());\r\n            if (ex != null) {\r\n                return ex;\r\n            }\r\n            for (Extension ex2 : extensions.getAllExtensions()) {\r\n                if (ex2.getExtensionId().equals((Object) oid)) {\r\n                    return ex2;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    } catch (IOException ioe) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.time.zone.ZoneRules.isFixedOffset",
	"Comment": "checks of the zone rules are fixed, such that the offset never varies.",
	"Method": "boolean isFixedOffset(){\r\n    return savingsInstantTransitions.length == 0;\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testCancelledForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGet(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() throws Exception {\r\n            FibTask f = new FibTask(8);\r\n            assertTrue(f.cancel(true));\r\n            assertSame(f, f.fork());\r\n            try {\r\n                Integer r = f.get(5L, SECONDS);\r\n                shouldThrow();\r\n            } catch (CancellationException success) {\r\n                checkCancelled(f);\r\n            }\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(mainPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testCancelledForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGet(){\r\n    FibTask f = new FibTask(8);\r\n    assertTrue(f.cancel(true));\r\n    assertSame(f, f.fork());\r\n    try {\r\n        Integer r = f.get(5L, SECONDS);\r\n        shouldThrow();\r\n    } catch (CancellationException success) {\r\n        checkCancelled(f);\r\n    }\r\n    return NoResult;\r\n}"
}, {
	"Path": "android.icu.dev.test.normalizer.NormalizerData.getRecursiveDecomposition",
	"Comment": "gets recursive decomposition of a character from the unicode character database.",
	"Method": "void getRecursiveDecomposition(boolean canonical,int ch,StringBuffer buffer){\r\n    String decomp = decompose.get(ch);\r\n    if (decomp != null && !(canonical && isCompatibility.get(ch))) {\r\n        for (int i = 0; i < decomp.length(); i += UTF16Util.codePointLength(ch)) {\r\n            ch = UTF16Util.nextCodePoint(decomp, i);\r\n            getRecursiveDecomposition(canonical, ch, buffer);\r\n        }\r\n    } else {\r\n        UTF16Util.appendCodePoint(buffer, ch);\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigDecimalConvertTest.testToEngineeringStringZeroPosExponent",
	"Comment": "convert a negative bigdecimal to an engineering string representation",
	"Method": "void testToEngineeringStringZeroPosExponent(){\r\n    String a = \"0.0E+16\";\r\n    BigDecimal aNumber = new BigDecimal(a);\r\n    String result = \"0E+15\";\r\n    assertEquals(\"incorrect value\", result, aNumber.toEngineeringString());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.util.ObservableTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    observable = new TestObservable();\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testLongArrayGetAndUpdate",
	"Comment": "atomiclongarray getandupdate returns previous value and updatesresult of supplied function",
	"Method": "void testLongArrayGetAndUpdate(){\r\n    AtomicLongArray a = new AtomicLongArray(1);\r\n    a.set(0, 1);\r\n    assertEquals(1L, a.getAndUpdate(0, Atomic8Test::addLong17));\r\n    assertEquals(18L, a.getAndUpdate(0, Atomic8Test::addLong17));\r\n    assertEquals(35L, a.get(0));\r\n}"
}, {
	"Path": "java.util.OptionalInt.orElseThrow",
	"Comment": "return the contained value, if present, otherwise throw an exceptionto be created by the provided supplier.",
	"Method": "int orElseThrow(Supplier<X> exceptionSupplier){\r\n    if (isPresent) {\r\n        return value;\r\n    } else {\r\n        throw exceptionSupplier.get();\r\n    }\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testPollTaskAsync",
	"Comment": "polltask returns an unexecuted task without executing it, inasync mode",
	"Method": "void testPollTaskAsync(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            CCF g = new LCCF(9);\r\n            assertSame(g, g.fork());\r\n            CCF f = new LCCF(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, pollTask());\r\n            helpQuiesce();\r\n            assertEquals(21, f.number);\r\n            checkCompletedNormally(f);\r\n            checkNotDone(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(asyncSingletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testPollTaskAsync",
	"Comment": "polltask returns an unexecuted task without executing it, inasync mode",
	"Method": "void testPollTaskAsync(){\r\n    CCF g = new LCCF(9);\r\n    assertSame(g, g.fork());\r\n    CCF f = new LCCF(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, pollTask());\r\n    helpQuiesce();\r\n    assertEquals(21, f.number);\r\n    checkCompletedNormally(f);\r\n    checkNotDone(g);\r\n}"
}, {
	"Path": "java.util.StringTokenizer.setMaxDelimCodePoint",
	"Comment": "set maxdelimcodepoint to the highest char in the delimiter set.",
	"Method": "void setMaxDelimCodePoint(){\r\n    if (delimiters == null) {\r\n        maxDelimCodePoint = 0;\r\n        return;\r\n    }\r\n    int m = 0;\r\n    int c;\r\n    int count = 0;\r\n    for (int i = 0; i < delimiters.length(); i += Character.charCount(c)) {\r\n        c = delimiters.charAt(i);\r\n        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {\r\n            c = delimiters.codePointAt(i);\r\n            hasSurrogates = true;\r\n        }\r\n        if (m < c)\r\n            m = c;\r\n        count++;\r\n    }\r\n    maxDelimCodePoint = m;\r\n    if (hasSurrogates) {\r\n        delimiterCodePoints = new int[count];\r\n        for (int i = 0, j = 0; i < count; i++, j += Character.charCount(c)) {\r\n            c = delimiters.codePointAt(j);\r\n            delimiterCodePoints[i] = c;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testPollNextLocalTaskAsync",
	"Comment": "pollnextlocaltask returns least recent unexecuted task withoutexecuting it, in async mode",
	"Method": "void testPollNextLocalTaskAsync(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib g = new AsyncFib(9);\r\n            assertSame(g, g.fork());\r\n            AsyncFib f = new AsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, pollNextLocalTask());\r\n            helpQuiesce();\r\n            assertEquals(21, f.number);\r\n            checkCompletedNormally(f);\r\n            checkNotDone(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(asyncSingletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testPollNextLocalTaskAsync",
	"Comment": "pollnextlocaltask returns least recent unexecuted task withoutexecuting it, in async mode",
	"Method": "void testPollNextLocalTaskAsync(){\r\n    AsyncFib g = new AsyncFib(9);\r\n    assertSame(g, g.fork());\r\n    AsyncFib f = new AsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, pollNextLocalTask());\r\n    helpQuiesce();\r\n    assertEquals(21, f.number);\r\n    checkCompletedNormally(f);\r\n    checkNotDone(g);\r\n}"
}, {
	"Path": "java.security.cert.CertStore.getCertStoreParameters",
	"Comment": "returns the parameters used to initialize this certstore.note that the certstoreparameters object is cloned beforeit is returned.",
	"Method": "CertStoreParameters getCertStoreParameters(){\r\n    return (params == null ? null : (CertStoreParameters) params.clone());\r\n}"
}, {
	"Path": "java.util.jar.JarEntry.getCodeSigners",
	"Comment": "returns the codesigner objects for this entry, ornull if none. this method can only be called oncethe jarentry has been completely verified by readingfrom the entry input stream until the end of the stream has beenreached. otherwise, this method will return null.the returned array comprises all the code signers that have signedthis entry.",
	"Method": "CodeSigner[] getCodeSigners(){\r\n    return signers == null ? null : signers.clone();\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testGetSharedQueuedThreads_Exclusive",
	"Comment": "getsharedqueuedthreads does not include exclusively waiting threads",
	"Method": "void testGetSharedQueuedThreads_Exclusive(){\r\n    final Mutex sync = new Mutex();\r\n    assertTrue(sync.getSharedQueuedThreads().isEmpty());\r\n    sync.acquire();\r\n    assertTrue(sync.getSharedQueuedThreads().isEmpty());\r\n    Thread t1 = newStartedThread(new InterruptedSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t1);\r\n    assertTrue(sync.getSharedQueuedThreads().isEmpty());\r\n    Thread t2 = newStartedThread(new InterruptibleSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t2);\r\n    assertTrue(sync.getSharedQueuedThreads().isEmpty());\r\n    t1.interrupt();\r\n    awaitTermination(t1);\r\n    assertTrue(sync.getSharedQueuedThreads().isEmpty());\r\n    sync.release();\r\n    awaitTermination(t2);\r\n    assertTrue(sync.getSharedQueuedThreads().isEmpty());\r\n}"
}, {
	"Path": "javax.crypto.KeyAgreement.generateSecret",
	"Comment": "creates the shared secret and returns it as a secretkeyobject of the specified algorithm.this method resets this keyagreement object, so that itcan be reused for further key agreements. unless this key agreement isreinitialized with one of the init methods, the sameprivate information and algorithm parameters will be used forsubsequent key agreements.",
	"Method": "byte[] generateSecret(int generateSecret,byte[] sharedSecret,int offset,SecretKey generateSecret,String algorithm){\r\n    chooseFirstProvider();\r\n    return spi.engineGenerateSecret(algorithm);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testAbnormalForkGet",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGet(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FailingFibAction f = new FailingFibAction(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get();\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testAbnormalForkGet",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGet(){\r\n    FailingFibAction f = new FailingFibAction(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get();\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n}"
}, {
	"Path": "java.net.Socket.getImpl",
	"Comment": "get the socketimpl attached to this socket, creatingit if necessary.",
	"Method": "SocketImpl getImpl(){\r\n    if (!created)\r\n        createImpl(true);\r\n    return impl;\r\n}"
}, {
	"Path": "sun.security.util.DerInputStream.readString",
	"Comment": "private helper routine to read an encoded string from the inputstream.",
	"Method": "String readString(byte stringTag,String stringName,String enc){\r\n    if (buffer.read() != stringTag)\r\n        throw new IOException(\"DER input not a \" + stringName + \" string\");\r\n    int length = getLength(buffer);\r\n    byte[] retval = new byte[length];\r\n    if ((length != 0) && (buffer.read(retval) != length))\r\n        throw new IOException(\"short read of DER \" + stringName + \" string\");\r\n    return new String(retval, enc);\r\n}"
}, {
	"Path": "java.util.JumboEnumSet.equals",
	"Comment": "compares the specified object with this set for equality.returnstrue if the given object is also a set, the two sets havethe same size, and every member of the given set is contained inthis set.",
	"Method": "boolean equals(Object o){\r\n    if (!(o instanceof JumboEnumSet))\r\n        return super.equals(o);\r\n    JumboEnumSet es = (JumboEnumSet) o;\r\n    if (es.elementType != elementType)\r\n        return size == 0 && es.size == 0;\r\n    return Arrays.equals(es.elements, elements);\r\n}"
}, {
	"Path": "java.math.BigInteger.add",
	"Comment": "adds the contents of the int arrays x and y. this method allocatesa new int array to hold the answer and returns a reference to thatarray.",
	"Method": "BigInteger add(BigInteger val,BigInteger add,long val,int[] add,int[] x,long val,int[] add,int[] x,int[] y){\r\n    if (x.length < y.length) {\r\n        int[] tmp = x;\r\n        x = y;\r\n        y = tmp;\r\n    }\r\n    int xIndex = x.length;\r\n    int yIndex = y.length;\r\n    int[] result = new int[xIndex];\r\n    long sum = 0;\r\n    if (yIndex == 1) {\r\n        sum = (x[--xIndex] & LONG_MASK) + (y[0] & LONG_MASK);\r\n        result[xIndex] = (int) sum;\r\n    } else {\r\n        while (yIndex > 0) {\r\n            sum = (x[--xIndex] & LONG_MASK) + (y[--yIndex] & LONG_MASK) + (sum >>> 32);\r\n            result[xIndex] = (int) sum;\r\n        }\r\n    }\r\n    boolean carry = (sum >>> 32 != 0);\r\n    while (xIndex > 0 && carry) carry = ((result[--xIndex] = x[xIndex] + 1) == 0);\r\n    while (xIndex > 0) result[--xIndex] = x[xIndex];\r\n    if (carry) {\r\n        int[] bigger = new int[result.length + 1];\r\n        System.arraycopy(result, 0, bigger, 1, result.length);\r\n        bigger[0] = 0x01;\r\n        return bigger;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "sun.security.x509.X509CRLImpl.getEncodedInternal",
	"Comment": "returned the encoding as an uncloned byte array. callers mustguarantee that they neither modify it nor expose it to untrustedcode.",
	"Method": "byte[] getEncodedInternal(byte[] getEncodedInternal,X509CRL crl){\r\n    if (crl instanceof X509CRLImpl) {\r\n        return ((X509CRLImpl) crl).getEncodedInternal();\r\n    } else {\r\n        return crl.getEncoded();\r\n    }\r\n}"
}, {
	"Path": "sun.misc.CharacterEncoder.encodeBufferPrefix",
	"Comment": "encode the prefix for the entire buffer. by default is simplyopens the printstream for use by the other functions.",
	"Method": "void encodeBufferPrefix(OutputStream aStream){\r\n    pStream = new PrintStream(aStream);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.AbstractRegressionTest.getImplementationFileList",
	"Comment": "takes a list of .java files and returns a list with the .java extension replaced with .m.",
	"Method": "List<String> getImplementationFileList(List<String> fileArgs){\r\n    List<String> mFileArgs = Lists.newArrayListWithCapacity(fileArgs.size());\r\n    for (String s : fileArgs) {\r\n        String newString = s.substring(0, s.lastIndexOf('/'));\r\n        newString += s.substring(s.lastIndexOf('/'), s.lastIndexOf('.')) + \".m\";\r\n        mFileArgs.add(newString);\r\n    }\r\n    return mFileArgs;\r\n}"
}, {
	"Path": "java.sql.DriverManager.getDriver",
	"Comment": "attempts to locate a driver that understands the given url.the drivermanager attempts to select an appropriate driver fromthe set of registered jdbc drivers.",
	"Method": "Driver getDriver(String url){\r\n    println(\"DriverManager.getDriver(\\\"\" + url + \"\\\")\");\r\n    ClassLoader callerClassLoader = ClassLoader.getSystemClassLoader();\r\n    for (DriverInfo aDriver : registeredDrivers) {\r\n        if (isDriverAllowed(aDriver.driver, callerClassLoader)) {\r\n            try {\r\n                if (aDriver.driver.acceptsURL(url)) {\r\n                    println(\"getDriver returning \" + aDriver.driver.getClass().getName());\r\n                    return (aDriver.driver);\r\n                }\r\n            } catch (SQLException sqe) {\r\n            }\r\n        } else {\r\n            println(\"    skipping: \" + aDriver.driver.getClass().getName());\r\n        }\r\n    }\r\n    println(\"getDriver: no suitable driver\");\r\n    throw new SQLException(\"No suitable driver\", \"08001\");\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testAddIfAbsent",
	"Comment": "addifabsent will not add the element if it already exists in the list",
	"Method": "void testAddIfAbsent(){\r\n    CopyOnWriteArrayList full = populatedArray(SIZE);\r\n    full.addIfAbsent(one);\r\n    assertEquals(SIZE, full.size());\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testPropagateCompletion",
	"Comment": "propagatecompletion decrements pending count unless zero, inwhich case causes completion, without invoking oncompletion",
	"Method": "void testPropagateCompletion(){\r\n    NoopCC a = new NoopCC();\r\n    assertEquals(0, a.getPendingCount());\r\n    int n = 3;\r\n    a.setPendingCount(n);\r\n    for (; n > 0; n--) {\r\n        assertEquals(n, a.getPendingCount());\r\n        a.propagateCompletion();\r\n        a.checkIncomplete();\r\n        assertEquals(n - 1, a.getPendingCount());\r\n    }\r\n    a.propagateCompletion();\r\n    assertEquals(0, a.computeN());\r\n    assertEquals(0, a.onCompletionN());\r\n    assertEquals(0, a.onExceptionalCompletionN());\r\n    assertEquals(0, a.setRawResultN());\r\n    checkCompletedNormally(a);\r\n}"
}, {
	"Path": "java.util.zip.ZipInputStream.close",
	"Comment": "closes this input stream and releases any system resources associatedwith the stream.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        super.close();\r\n        closed = true;\r\n    }\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.getPercent",
	"Comment": "gets the character used for percent sign. different for arabic, etc.",
	"Method": "char getPercent(){\r\n    return percent;\r\n}"
}, {
	"Path": "java.text.DateFormat.getTimeInstance",
	"Comment": "gets the time formatter with the given formatting stylefor the given locale.",
	"Method": "DateFormat getTimeInstance(DateFormat getTimeInstance,int style,DateFormat getTimeInstance,int style,Locale aLocale){\r\n    return get(style, 0, 1, aLocale);\r\n}"
}, {
	"Path": "java.math.BigInteger.abs",
	"Comment": "returns a biginteger whose value is the absolute value of thisbiginteger.",
	"Method": "BigInteger abs(){\r\n    return (signum >= 0 ? this : this.negate());\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testIntGetAndUpdate",
	"Comment": "atomicinteger getandupdate returns previous value and updatesresult of supplied function",
	"Method": "void testIntGetAndUpdate(){\r\n    AtomicInteger a = new AtomicInteger(1);\r\n    assertEquals(1, a.getAndUpdate(Atomic8Test::addInt17));\r\n    assertEquals(18, a.getAndUpdate(Atomic8Test::addInt17));\r\n    assertEquals(35, a.get());\r\n}"
}, {
	"Path": "java.time.format.DecimalStyle.getDecimalSeparator",
	"Comment": "gets the character that represents the decimal point.the character used to represent a decimal point may vary by culture.this method specifies the character to use.",
	"Method": "char getDecimalSeparator(){\r\n    return decimalSeparator;\r\n}"
}, {
	"Path": "java.util.concurrent.locks.ReentrantLock.getQueueLength",
	"Comment": "returns an estimate of the number of threads waiting to acquirethis lock.the value is only an estimate because the number ofthreads may change dynamically while this method traversesinternal data structures.this method is designed for use inmonitoring system state, not for synchronization control.",
	"Method": "int getQueueLength(){\r\n    return sync.getQueueLength();\r\n}"
}, {
	"Path": "java.util.stream.AbstractShortCircuitTask.taskCanceled",
	"Comment": "queries whether this task is canceled.a task is considered canceled ifit or any of its parents have been canceled.",
	"Method": "boolean taskCanceled(){\r\n    boolean cancel = canceled;\r\n    if (!cancel) {\r\n        for (K parent = getParent(); !cancel && parent != null; parent = parent.getParent()) cancel = parent.canceled;\r\n    }\r\n    return cancel;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberRegressionTests.Test4075713",
	"Comment": "numberformat.equals comparing with null should always return false.",
	"Method": "void Test4075713(){\r\n    try {\r\n        MyNumberFormat tmp = new MyNumberFormat();\r\n        if (!tmp.equals(null))\r\n            logln(\"NumberFormat.equals passed\");\r\n    } catch (NullPointerException e) {\r\n        errln(\"(new MyNumberFormatTest()).equals(null) throws unexpected exception\");\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test430241",
	"Comment": "in incorrect covariant return bridge request to lambdametafactory",
	"Method": "void test430241(){\r\n    this.runConformTest(new String[] { \"X.java\", \"interface K extends I, J {\\n\" + \"}\\n\" + \"interface I {\\n\" + \"    Comparable<Integer> foo();\\n\" + \"}\\n\" + \"interface J {\\n\" + \"    Comparable foo();\\n\" + \"}\\n\" + \"public class X {\\n\" + \" public static void main(String[] args) {\\n\" + \"   K k = () -> null;\\n\" + \"   System.out.println(k.foo());\\n\" + \" }\\n\" + \"}\\n\" }, \"null\");\r\n}"
}, {
	"Path": "sun.security.x509.X500Name.asX500Name",
	"Comment": "get the x500name contained in the given x500principal.note that the x500name is retrieved using reflection.",
	"Method": "X500Name asX500Name(X500Principal p){\r\n    try {\r\n        X500Name name = (X500Name) principalField.get(p);\r\n        name.x500Principal = p;\r\n        return name;\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(\"Unexpected exception\", e);\r\n    }\r\n}"
}, {
	"Path": "java.security.AlgorithmParameters.getInstance",
	"Comment": "returns a parameter object for the specified algorithm. a new algorithmparameters object encapsulating thealgorithmparametersspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.the returned parameter object must be initialized via a call toinit, using an appropriate parameter specification orparameter encoding.",
	"Method": "AlgorithmParameters getInstance(String algorithm,AlgorithmParameters getInstance,String algorithm,String provider,AlgorithmParameters getInstance,String algorithm,Provider provider){\r\n    if (provider == null)\r\n        throw new IllegalArgumentException(\"missing provider\");\r\n    Object[] objs = Security.getImpl(algorithm, \"AlgorithmParameters\", provider);\r\n    return new AlgorithmParameters((AlgorithmParametersSpi) objs[0], (Provider) objs[1], algorithm);\r\n}"
}, {
	"Path": "java.security.spec.MGF1ParameterSpec.getDigestAlgorithm",
	"Comment": "returns the algorithm name of the message digest used by the maskgeneration function.",
	"Method": "String getDigestAlgorithm(){\r\n    return mdName;\r\n}"
}, {
	"Path": "jsr166.AtomicMarkableReferenceTest.testCompareAndSetInMultipleThreads2",
	"Comment": "compareandset in one thread enables another waiting for mark valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads2(){\r\n    final AtomicMarkableReference ai = new AtomicMarkableReference(one, false);\r\n    Thread t = new Thread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!ai.compareAndSet(one, one, true, false)) Thread.yield();\r\n        }\r\n    });\r\n    t.start();\r\n    assertTrue(ai.compareAndSet(one, one, false, true));\r\n    t.join(LONG_DELAY_MS);\r\n    assertFalse(t.isAlive());\r\n    assertSame(one, ai.getReference());\r\n    assertFalse(ai.isMarked());\r\n}"
}, {
	"Path": "jsr166.AtomicMarkableReferenceTest.testCompareAndSetInMultipleThreads2",
	"Comment": "compareandset in one thread enables another waiting for mark valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads2(){\r\n    while (!ai.compareAndSet(one, one, true, false)) Thread.yield();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.pipeline.BuildClosureQueue.addProcessedName",
	"Comment": "adds the name of a file that has been processed to ensure that this name isnot searched for in the future.",
	"Method": "void addProcessedName(String name){\r\n    processedNames.add(name);\r\n    queuedNames.remove(name);\r\n}"
}, {
	"Path": "dalvik.system.CloseGuard.setEnabled",
	"Comment": "used to enable or disable closeguard. note that closeguard onlywarns if it is enabled for both allocation and finalization.",
	"Method": "void setEnabled(boolean enabled){\r\n    ENABLED = enabled;\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.getCurrencySymbol",
	"Comment": "returns the currency symbol for the currency of thesedecimalformatsymbols in their locale.",
	"Method": "String getCurrencySymbol(){\r\n    return currencySymbol;\r\n}"
}, {
	"Path": "libcore.java.nio.charset.CharsetDecoderTest.test_replaceWith",
	"Comment": "none of the harmony or jtreg tests actually check that replacewith does the right thing!",
	"Method": "void test_replaceWith(){\r\n    CharsetDecoder d = Charset.forName(\"UTF-16\").newDecoder();\r\n    d.replaceWith(\"x\");\r\n    d.onMalformedInput(CodingErrorAction.REPLACE);\r\n    d.onUnmappableCharacter(CodingErrorAction.REPLACE);\r\n    ByteBuffer in = ByteBuffer.wrap(new byte[] { 109, 97, 109 });\r\n    assertEquals(\"x\", d.decode(in).toString());\r\n}"
}, {
	"Path": "java.nio.ShortBuffer.equals",
	"Comment": "tells whether or not this buffer is equal to another object. two short buffers are equal if, and only if, they have the same element type, they have the same number of remaining elements, and the two sequences of remaining elements, consideredindependently of their starting positions, are pointwise equal. a short buffer is not equal to any other type of object.",
	"Method": "boolean equals(Object ob,boolean equals,short x,short y){\r\n    return x == y;\r\n}"
}, {
	"Path": "java.security.cert.CertPathHelperImpl.initialize",
	"Comment": "initialize the helper framework. this method must be called fromthe static initializer of each class that is the target of one ofthe methods in this class. this ensures that the helper is initializedprior to a tunneled call from the sun provider.",
	"Method": "void initialize(){\r\n    if (CertPathHelper.instance == null) {\r\n        CertPathHelper.instance = new CertPathHelperImpl();\r\n    }\r\n}"
}, {
	"Path": "java.text.MessageFormat.readObject",
	"Comment": "after reading an object from the input stream, do a simple verificationto maintain class invariants.",
	"Method": "void readObject(ObjectInputStream in){\r\n    in.defaultReadObject();\r\n    boolean isValid = maxOffset >= -1 && formats.length > maxOffset && offsets.length > maxOffset && argumentNumbers.length > maxOffset;\r\n    if (isValid) {\r\n        int lastOffset = pattern.length() + 1;\r\n        for (int i = maxOffset; i >= 0; --i) {\r\n            if ((offsets[i] < 0) || (offsets[i] > lastOffset)) {\r\n                isValid = false;\r\n                break;\r\n            } else {\r\n                lastOffset = offsets[i];\r\n            }\r\n        }\r\n    }\r\n    if (!isValid) {\r\n        throw new InvalidObjectException(\"Could not reconstruct MessageFormat from corrupt stream.\");\r\n    }\r\n}"
}, {
	"Path": "java.time.format.DateTimeParseContext.getDecimalStyle",
	"Comment": "gets the decimalstyle.the decimalstyle controls the numeric parsing.",
	"Method": "DecimalStyle getDecimalStyle(){\r\n    return formatter.getDecimalStyle();\r\n}"
}, {
	"Path": "java.lang.StrictMath.toRadians",
	"Comment": "converts an angle measured in degrees to an approximatelyequivalent angle measured in radians.the conversion fromdegrees to radians is generally inexact.",
	"Method": "double toRadians(double angdeg){\r\n    return angdeg / 180.0 * PI;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.TypeImplementationGeneratorTest.enumConstantAccessorMethodValidation",
	"Comment": "verify that accessor methods for enum constants are generated on request.",
	"Method": "void enumConstantAccessorMethodValidation(){\r\n    String source = \"enum Test { ONE, TWO, EOF }\";\r\n    String translation = translateSourceFile(source, \"Test\", \"Test.m\");\r\n    assertTranslatedLines(translation, \"+ (Test *)ONE {\", \"return JreEnum(Test, ONE);\");\r\n    assertTranslatedLines(translation, \"+ (Test *)TWO {\", \"return JreEnum(Test, TWO);\");\r\n    assertTranslatedLines(translation, \"+ (Test *)EOF_ {\", \"return JreEnum(Test, EOF);\");\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testCancelledForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGet(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FibAction f = new FibAction(8);\r\n            assertTrue(f.cancel(true));\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get(5L, SECONDS);\r\n                shouldThrow();\r\n            } catch (CancellationException success) {\r\n                checkCancelled(f);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testCancelledForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGet(){\r\n    FibAction f = new FibAction(8);\r\n    assertTrue(f.cancel(true));\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get(5L, SECONDS);\r\n        shouldThrow();\r\n    } catch (CancellationException success) {\r\n        checkCancelled(f);\r\n    }\r\n}"
}, {
	"Path": "jsr166.PriorityQueueTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    PriorityQueue q = new PriorityQueue(SIZE);\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        q.addAll(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.sql.Timestamp.compareTo",
	"Comment": "compares this timestamp object to the giventimestamp object.",
	"Method": "int compareTo(Timestamp ts,int compareTo,java.util.Date o){\r\n    if (o instanceof Timestamp) {\r\n        return compareTo((Timestamp) o);\r\n    } else {\r\n        Timestamp ts = new Timestamp(o.getTime());\r\n        return this.compareTo(ts);\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.URICertStore.engineGetCertificates",
	"Comment": "returns a collection of x509certificates thatmatch the specified selector. if no x509certificatesmatch the selector, an empty collection will be returned.",
	"Method": "Collection<X509Certificate> engineGetCertificates(CertSelector selector){\r\n    long time = System.currentTimeMillis();\r\n    if (time - lastChecked < CHECK_INTERVAL) {\r\n        if (debug != null) {\r\n            debug.println(\"Returning certificates from cache\");\r\n        }\r\n        return getMatchingCerts(certs, selector);\r\n    }\r\n    lastChecked = time;\r\n    try {\r\n        URLConnection connection = uri.toURL().openConnection();\r\n        if (lastModified != 0) {\r\n            connection.setIfModifiedSince(lastModified);\r\n        }\r\n        long oldLastModified = lastModified;\r\n        try (InputStream in = connection.getInputStream()) {\r\n            lastModified = connection.getLastModified();\r\n            if (oldLastModified != 0) {\r\n                if (oldLastModified == lastModified) {\r\n                    if (debug != null) {\r\n                        debug.println(\"Not modified, using cached copy\");\r\n                    }\r\n                    return getMatchingCerts(certs, selector);\r\n                } else if (connection instanceof HttpURLConnection) {\r\n                    HttpURLConnection hconn = (HttpURLConnection) connection;\r\n                    if (hconn.getResponseCode() == HttpURLConnection.HTTP_NOT_MODIFIED) {\r\n                        if (debug != null) {\r\n                            debug.println(\"Not modified, using cached copy\");\r\n                        }\r\n                        return getMatchingCerts(certs, selector);\r\n                    }\r\n                }\r\n            }\r\n            if (debug != null) {\r\n                debug.println(\"Downloading new certificates...\");\r\n            }\r\n            certs = (Collection<X509Certificate>) factory.generateCertificates(in);\r\n        }\r\n        return getMatchingCerts(certs, selector);\r\n    } catch (IOException | CertificateException e) {\r\n        if (debug != null) {\r\n            debug.println(\"Exception fetching certificates:\");\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    lastModified = 0;\r\n    certs = Collections.emptySet();\r\n    return certs;\r\n}"
}, {
	"Path": "jsr166.ArrayBlockingQueueTest.testSerialization",
	"Comment": "a deserialized serialized queue has same elements in same order",
	"Method": "void testSerialization(){\r\n    if (ReflectionUtil.isJreReflectionStripped()) {\r\n        return;\r\n    }\r\n    Queue x = populatedQueue(SIZE);\r\n    Queue y = serialClone(x);\r\n    assertNotSame(x, y);\r\n    assertEquals(x.size(), y.size());\r\n    assertEquals(x.toString(), y.toString());\r\n    assertTrue(Arrays.equals(x.toArray(), y.toArray()));\r\n    while (!x.isEmpty()) {\r\n        assertFalse(y.isEmpty());\r\n        assertEquals(x.remove(), y.remove());\r\n    }\r\n    assertTrue(y.isEmpty());\r\n}"
}, {
	"Path": "java.security.AlgorithmParameterGenerator.getProvider",
	"Comment": "returns the provider of this algorithm parameter generator object.",
	"Method": "Provider getProvider(){\r\n    return this.provider;\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testAbnormalInvoke",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvoke(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() {\r\n            FailingFibTask f = new FailingFibTask(8);\r\n            try {\r\n                f.invoke();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(mainPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testAbnormalInvoke",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvoke(){\r\n    FailingFibTask f = new FailingFibTask(8);\r\n    try {\r\n        f.invoke();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n    return NoResult;\r\n}"
}, {
	"Path": "java.time.Duration.dividedBy",
	"Comment": "returns a copy of this duration divided by the specified value.this instance is immutable and unaffected by this method call.",
	"Method": "Duration dividedBy(long divisor){\r\n    if (divisor == 0) {\r\n        throw new ArithmeticException(\"Cannot divide by zero\");\r\n    }\r\n    if (divisor == 1) {\r\n        return this;\r\n    }\r\n    return create(toSeconds().divide(BigDecimal.valueOf(divisor), RoundingMode.DOWN));\r\n}"
}, {
	"Path": "sun.security.x509.CertificateIssuerExtension.toString",
	"Comment": "returns a printable representation of the certificate issuer.",
	"Method": "String toString(){\r\n    return super.toString() + \"Certificate Issuer [\\n\" + String.valueOf(names) + \"]\\n\";\r\n}"
}, {
	"Path": "sun.security.x509.CRLExtensions.equals",
	"Comment": "compares this crlextensions for equality with the specifiedobject. if the other object is aninstanceof crlextensions, thenall the entries are compared with the entries from this.",
	"Method": "boolean equals(Object other){\r\n    if (this == other)\r\n        return true;\r\n    if (!(other instanceof CRLExtensions))\r\n        return false;\r\n    Collection<Extension> otherC = ((CRLExtensions) other).getAllExtensions();\r\n    Object[] objs = otherC.toArray();\r\n    int len = objs.length;\r\n    if (len != map.size())\r\n        return false;\r\n    Extension otherExt, thisExt;\r\n    String key = null;\r\n    for (int i = 0; i < len; i++) {\r\n        if (objs[i] instanceof CertAttrSet)\r\n            key = ((CertAttrSet) objs[i]).getName();\r\n        otherExt = (Extension) objs[i];\r\n        if (key == null)\r\n            key = otherExt.getExtensionId().toString();\r\n        thisExt = map.get(key);\r\n        if (thisExt == null)\r\n            return false;\r\n        if (!thisExt.equals(otherExt))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.isZero",
	"Comment": "returns true iff this mutablebiginteger has a value of zero.",
	"Method": "boolean isZero(){\r\n    return (intLen == 0);\r\n}"
}, {
	"Path": "sun.security.x509.AlgorithmId.makeSigAlg",
	"Comment": "creates a signature algorithm name from a digest algorithmname and a encryption algorithm name.",
	"Method": "String makeSigAlg(String digAlg,String encAlg){\r\n    digAlg = digAlg.replace(\"-\", \"\").toUpperCase(Locale.ENGLISH);\r\n    if (digAlg.equalsIgnoreCase(\"SHA\"))\r\n        digAlg = \"SHA1\";\r\n    encAlg = encAlg.toUpperCase(Locale.ENGLISH);\r\n    if (encAlg.equals(\"EC\"))\r\n        encAlg = \"ECDSA\";\r\n    return digAlg + \"with\" + encAlg;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentLinkedQueue.succ",
	"Comment": "returns the successor of p, or the head node if p.next has beenlinked to self, which will only be true if traversing with astale pointer that is now off the list.",
	"Method": "Node<E> succ(Node<E> p){\r\n    Node<E> next = p.next;\r\n    return (sentinel() == next) ? head : next;\r\n}"
}, {
	"Path": "java.text.FieldPosition.getFieldAttribute",
	"Comment": "returns the field identifier as an attribute constantfrom one of the field subclasses. may return null ifthe field is specified only by an integer field id.",
	"Method": "Format.Field getFieldAttribute(){\r\n    return attribute;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase4",
	"Comment": "subtract two numbers of the same length and different signs.the first is positive.the second is greater in absolute value.",
	"Method": "void testCase4(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 11, 22, 33, 44, 55, 66, 77, 11, 22, 33 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase3",
	"Comment": "subtract two numbers of the same length and different signs.the first is positive.the first is greater in absolute value.",
	"Method": "void testCase3(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 11, 22, 33, 44, 55, 66, 77, 11, 22, 33 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase6",
	"Comment": "subtract two negative numbers of the same length.the second is greater in absolute value.",
	"Method": "void testCase6(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 9, 18, 27, 36, 45, 54, 63, 9, 18, 27 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase5",
	"Comment": "subtract two negative numbers of the same length.the first is greater in absolute value.",
	"Method": "void testCase5(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    int aSign = -1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { -10, -19, -28, -37, -46, -55, -64, -10, -19, -27 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase2",
	"Comment": "subtract two positive numbers of the same length.the second is greater.",
	"Method": "void testCase2(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -10, -19, -28, -37, -46, -55, -64, -10, -19, -27 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testGetMaximumPoolSize",
	"Comment": "getmaximumpoolsize returns value given in constructor if nototherwise set",
	"Method": "void testGetMaximumPoolSize(){\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(2, 3, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertEquals(3, p.getMaximumPoolSize());\r\n        p.setMaximumPoolSize(5);\r\n        assertEquals(5, p.getMaximumPoolSize());\r\n        p.setMaximumPoolSize(4);\r\n        assertEquals(4, p.getMaximumPoolSize());\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase1",
	"Comment": "subtract two positive numbers of the same length.the first is greater.",
	"Method": "void testCase1(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 9, 18, 27, 36, 45, 54, 63, 9, 18, 27 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "java.net.DatagramPacket.getData",
	"Comment": "returns the data buffer. the data received or the data to be sentstarts from the offset in the buffer,and runs for length long.",
	"Method": "byte[] getData(){\r\n    return buf;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase8",
	"Comment": "subtract two numbers of the same length and different signs.the first is negative.the second is greater in absolute value.",
	"Method": "void testCase8(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -12, -23, -34, -45, -56, -67, -78, -12, -23, -33 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase7",
	"Comment": "subtract two numbers of the same length and different signs.the first is negative.the first is greater in absolute value.",
	"Method": "void testCase7(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -12, -23, -34, -45, -56, -67, -78, -12, -23, -33 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.putForCreate",
	"Comment": "the put method for readobject.it does not resize the table,update modcount, etc.",
	"Method": "void putForCreate(K key,V value){\r\n    Object k = maskNull(key);\r\n    Object[] tab = table;\r\n    int len = tab.length;\r\n    int i = hash(k, len);\r\n    Object item;\r\n    while ((item = tab[i]) != null) {\r\n        if (item == k)\r\n            throw new java.io.StreamCorruptedException();\r\n        i = nextKeyIndex(i, len);\r\n    }\r\n    tab[i] = k;\r\n    tab[i + 1] = value;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase9",
	"Comment": "subtract two positive numbers of different length.the first is longer.",
	"Method": "void testCase9(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 1, 2, 3, 3, -6, -15, -24, -40, -49, -58, -67, -6, -15, -23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "java.security.Security.getProviders",
	"Comment": "returns an array containing all the installed providers. the order ofthe providers in the array is their preference order.",
	"Method": "Provider[] getProviders(Provider[] getProviders,String filter,Provider[] getProviders,Map<String, String> filter){\r\n    Provider[] allProviders = Security.getProviders();\r\n    Set<String> keySet = filter.keySet();\r\n    LinkedHashSet<Provider> candidates = new LinkedHashSet(5);\r\n    if ((keySet == null) || (allProviders == null)) {\r\n        return allProviders;\r\n    }\r\n    boolean firstSearch = true;\r\n    for (Iterator<String> ite = keySet.iterator(); ite.hasNext(); ) {\r\n        String key = ite.next();\r\n        String value = filter.get(key);\r\n        LinkedHashSet<Provider> newCandidates = getAllQualifyingCandidates(key, value, allProviders);\r\n        if (firstSearch) {\r\n            candidates = newCandidates;\r\n            firstSearch = false;\r\n        }\r\n        if ((newCandidates != null) && !newCandidates.isEmpty()) {\r\n            for (Iterator<Provider> cansIte = candidates.iterator(); cansIte.hasNext(); ) {\r\n                Provider prov = cansIte.next();\r\n                if (!newCandidates.contains(prov)) {\r\n                    cansIte.remove();\r\n                }\r\n            }\r\n        } else {\r\n            candidates = null;\r\n            break;\r\n        }\r\n    }\r\n    if ((candidates == null) || (candidates.isEmpty()))\r\n        return null;\r\n    Object[] candidatesArray = candidates.toArray();\r\n    Provider[] result = new Provider[candidatesArray.length];\r\n    for (int i = 0; i < result.length; i++) {\r\n        result[i] = (Provider) candidatesArray[i];\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "sun.security.x509.NetscapeCertTypeExtension.getKeyUsageMappedBits",
	"Comment": "get a boolean array representing the bits of this extension,as it maps to the keyusage extension.",
	"Method": "boolean[] getKeyUsageMappedBits(){\r\n    KeyUsageExtension keyUsage = new KeyUsageExtension();\r\n    Boolean val = Boolean.TRUE;\r\n    try {\r\n        if (isSet(getPosition(SSL_CLIENT)) || isSet(getPosition(S_MIME)) || isSet(getPosition(OBJECT_SIGNING)))\r\n            keyUsage.set(keyUsage.DIGITAL_SIGNATURE, val);\r\n        if (isSet(getPosition(SSL_SERVER)))\r\n            keyUsage.set(keyUsage.KEY_ENCIPHERMENT, val);\r\n        if (isSet(getPosition(SSL_CA)) || isSet(getPosition(S_MIME_CA)) || isSet(getPosition(OBJECT_SIGNING_CA)))\r\n            keyUsage.set(keyUsage.KEY_CERTSIGN, val);\r\n    } catch (IOException e) {\r\n    }\r\n    return keyUsage.getBits();\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedLongSynchronizer.isQueued",
	"Comment": "returns true if the given thread is currently queued.this implementation traverses the queue to determinepresence of the given thread.",
	"Method": "boolean isQueued(Thread thread){\r\n    if (thread == null)\r\n        throw new NullPointerException();\r\n    for (Node p = tail; p != null; p = p.prev) if (p.thread == thread)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "java.lang.annotation.AnnotationTypeMismatchException.element",
	"Comment": "returns the method object for the incorrectly typed element.",
	"Method": "Method element(){\r\n    return this.element;\r\n}"
}, {
	"Path": "javax.xml.transform.stream.StreamResult.setWriter",
	"Comment": "set the writer that is to receive the result.normally,a stream should be used rather than a writer, so thatthe transformer may use instructions contained in thetransformation instructions to control the encoding.however,there are times when it is useful to write to a writer,such as when using a stringwriter.",
	"Method": "void setWriter(Writer writer){\r\n    this.writer = writer;\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testGetAndUpdateNPE",
	"Comment": "all atomic getandupdate methods throw nullpointerexception onnull function argument",
	"Method": "void testGetAndUpdateNPE(){\r\n    Runnable[] throwingActions = { () -> new AtomicLong().getAndUpdate(null), () -> new AtomicInteger().getAndUpdate(null), () -> new AtomicReference().getAndUpdate(null), () -> new AtomicLongArray(1).getAndUpdate(0, null), () -> new AtomicIntegerArray(1).getAndUpdate(0, null), () -> new AtomicReferenceArray(1).getAndUpdate(0, null), () -> aLongFieldUpdater().getAndUpdate(this, null), () -> anIntFieldUpdater().getAndUpdate(this, null), () -> anIntegerFieldUpdater().getAndUpdate(this, null) };\r\n    assertThrows(NullPointerException.class, throwingActions);\r\n}"
}, {
	"Path": "jsr166.FutureTaskTest.testGet_ExecutionException",
	"Comment": "a runtime exception in task causes get to throw executionexception",
	"Method": "void testGet_ExecutionException(){\r\n    final ArithmeticException e = new ArithmeticException();\r\n    final PublicFutureTask task = new PublicFutureTask(new Callable() {\r\n        public Object call() {\r\n            throw e;\r\n        }\r\n    });\r\n    task.run();\r\n    assertEquals(1, task.runCount());\r\n    assertEquals(0, task.setCount());\r\n    assertEquals(1, task.setExceptionCount());\r\n    try {\r\n        task.get();\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        assertSame(e, success.getCause());\r\n        tryToConfuseDoneTask(task);\r\n        checkCompletedAbnormally(task, success.getCause());\r\n    }\r\n}"
}, {
	"Path": "jsr166.FutureTaskTest.testGet_ExecutionException",
	"Comment": "a runtime exception in task causes get to throw executionexception",
	"Method": "void testGet_ExecutionException(){\r\n    throw e;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testGetRejectedExecutionHandler",
	"Comment": "getrejectedexecutionhandler returns handler in constructor if not set",
	"Method": "void testGetRejectedExecutionHandler(){\r\n    final RejectedExecutionHandler handler = new NoOpREHandler();\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(1, 2, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10), handler);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertSame(handler, p.getRejectedExecutionHandler());\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testSerialization",
	"Comment": "a deserialized serialized deque has same elements in same order",
	"Method": "void testSerialization(){\r\n    if (ReflectionUtil.isJreReflectionStripped()) {\r\n        return;\r\n    }\r\n    Queue x = populatedDeque(SIZE);\r\n    Queue y = serialClone(x);\r\n    assertNotSame(y, x);\r\n    assertEquals(x.size(), y.size());\r\n    assertEquals(x.toString(), y.toString());\r\n    assertTrue(Arrays.equals(x.toArray(), y.toArray()));\r\n    while (!x.isEmpty()) {\r\n        assertFalse(y.isEmpty());\r\n        assertEquals(x.remove(), y.remove());\r\n    }\r\n    assertTrue(y.isEmpty());\r\n}"
}, {
	"Path": "java.util.OptionalLong.orElseThrow",
	"Comment": "return the contained value, if present, otherwise throw an exceptionto be created by the provided supplier.",
	"Method": "long orElseThrow(Supplier<X> exceptionSupplier){\r\n    if (isPresent) {\r\n        return value;\r\n    } else {\r\n        throw exceptionSupplier.get();\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.DistributionPointName.getRelativeName",
	"Comment": "returns the relative name for the distribution point or null if not set.",
	"Method": "RDN getRelativeName(){\r\n    return relativeName;\r\n}"
}, {
	"Path": "sun.security.pkcs.PKCS7.getDigestAlgorithmIds",
	"Comment": "returns the message digest algorithms specified in this pkcs7 block.",
	"Method": "AlgorithmId[] getDigestAlgorithmIds(){\r\n    return digestAlgorithmIds;\r\n}"
}, {
	"Path": "java.net.Inet6Address.equals",
	"Comment": "compares this object against the specified object.the result is true if and only if the argument isnot null and it represents the same ip address asthis object.two instances of inetaddress represent the same ipaddress if the length of the byte arrays returned bygetaddress is the same for both, and each of thearray components is the same for the byte arrays.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == null || !(obj instanceof Inet6Address))\r\n        return false;\r\n    Inet6Address inetAddr = (Inet6Address) obj;\r\n    for (int i = 0; i < INADDRSZ; i++) {\r\n        if (ipaddress[i] != inetAddr.ipaddress[i])\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.J2ObjCTest.testSpecifiedAnnotationProcessingWithProcessorPath",
	"Comment": "test an explicitly invoked annotation processor on the processor path.",
	"Method": "void testSpecifiedAnnotationProcessingWithProcessorPath(){\r\n    String processorPath = getResourceAsFile(\"annotations/ExplicitProcessor.jar\");\r\n    options.getProcessorPathEntries().add(processorPath);\r\n    options.setProcessors(\"com.google.devtools.j2objc.annotations.J2ObjCTestExplicitProcessor\");\r\n    String examplePath = addSourceFile(EXAMPLE_JAVA_SOURCE, \"annotations/Example.java\");\r\n    J2ObjC.run(Collections.singletonList(examplePath), options);\r\n    assertErrorCount(0);\r\n    assertSpecifiedAnnotationProcessorOutput();\r\n}"
}, {
	"Path": "sun.net.www.URLConnection.getHeaderField",
	"Comment": "return the value for the nth header field. returns null ifthere are fewer than n fields.this can be used in conjunctionwith getheaderfieldkey to iterate through all the headers in the message.",
	"Method": "String getHeaderField(String name,String getHeaderField,int n){\r\n    try {\r\n        getInputStream();\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n    MessageHeader props = properties;\r\n    return props == null ? null : props.getValue(n);\r\n}"
}, {
	"Path": "java.io.BufferedReader.fill",
	"Comment": "fills the input buffer, taking the mark into account if it is valid.",
	"Method": "void fill(){\r\n    int dst;\r\n    if (markedChar <= UNMARKED) {\r\n        dst = 0;\r\n    } else {\r\n        int delta = nextChar - markedChar;\r\n        if (delta >= readAheadLimit) {\r\n            markedChar = INVALIDATED;\r\n            readAheadLimit = 0;\r\n            dst = 0;\r\n        } else {\r\n            if (readAheadLimit <= cb.length) {\r\n                System.arraycopy(cb, markedChar, cb, 0, delta);\r\n                markedChar = 0;\r\n                dst = delta;\r\n            } else {\r\n                int nlength = cb.length * 2;\r\n                if (nlength > readAheadLimit) {\r\n                    nlength = readAheadLimit;\r\n                }\r\n                char[] ncb = new char[nlength];\r\n                System.arraycopy(cb, markedChar, ncb, 0, delta);\r\n                cb = ncb;\r\n                markedChar = 0;\r\n                dst = delta;\r\n            }\r\n            nextChar = nChars = delta;\r\n        }\r\n    }\r\n    int n;\r\n    do {\r\n        n = in.read(cb, dst, cb.length - dst);\r\n    } while (n == 0);\r\n    if (n > 0) {\r\n        nChars = dst + n;\r\n        nextChar = dst;\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testGetSharedQueuedThreads_Shared",
	"Comment": "getsharedqueuedthreads returns all shared waiting threads",
	"Method": "void testGetSharedQueuedThreads_Shared(){\r\n    final BooleanLatch l = new BooleanLatch();\r\n    assertHasSharedQueuedThreads(l, NO_THREADS);\r\n    Thread t1 = newStartedThread(new CheckedInterruptedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            l.acquireSharedInterruptibly(0);\r\n        }\r\n    });\r\n    waitForQueuedThread(l, t1);\r\n    assertHasSharedQueuedThreads(l, t1);\r\n    Thread t2 = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            l.acquireSharedInterruptibly(0);\r\n        }\r\n    });\r\n    waitForQueuedThread(l, t2);\r\n    assertHasSharedQueuedThreads(l, t1, t2);\r\n    t1.interrupt();\r\n    awaitTermination(t1);\r\n    assertHasSharedQueuedThreads(l, t2);\r\n    assertTrue(l.releaseShared(0));\r\n    awaitTermination(t2);\r\n    assertHasSharedQueuedThreads(l, NO_THREADS);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testGetSharedQueuedThreads_Shared",
	"Comment": "getsharedqueuedthreads returns all shared waiting threads",
	"Method": "void testGetSharedQueuedThreads_Shared(){\r\n    l.acquireSharedInterruptibly(0);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testGetSharedQueuedThreads_Shared",
	"Comment": "getsharedqueuedthreads returns all shared waiting threads",
	"Method": "void testGetSharedQueuedThreads_Shared(){\r\n    l.acquireSharedInterruptibly(0);\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArrive2",
	"Comment": "arriveandderegister does not wait for others to arrive at barrier",
	"Method": "void testArrive2(){\r\n    final Phaser phaser = new Phaser();\r\n    assertEquals(0, phaser.register());\r\n    List<Thread> threads = new ArrayList<Thread>();\r\n    for (int i = 0; i < 10; i++) {\r\n        assertEquals(0, phaser.register());\r\n        threads.add(newStartedThread(new CheckedRunnable() {\r\n            public void realRun() {\r\n                assertEquals(0, phaser.arriveAndDeregister());\r\n            }\r\n        }));\r\n    }\r\n    for (Thread thread : threads) awaitTermination(thread);\r\n    assertState(phaser, 0, 1, 1);\r\n    assertEquals(0, phaser.arrive());\r\n    assertState(phaser, 1, 1, 1);\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArrive2",
	"Comment": "arriveandderegister does not wait for others to arrive at barrier",
	"Method": "void testArrive2(){\r\n    assertEquals(0, phaser.arriveAndDeregister());\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedSynchronizer.setHead",
	"Comment": "sets head of queue to be node, thus dequeuing. called only byacquire methods.also nulls out unused fields for sake of gcand to suppress unnecessary signals and traversals.",
	"Method": "void setHead(Node node){\r\n    head = node;\r\n    node.thread = null;\r\n    node.prev = null;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceEntriesToDouble",
	"Comment": "returns the result of accumulating the given transformationof all entries using the given reducer to combine values,and the given basis as an identity value.",
	"Method": "double reduceEntriesToDouble(long parallelismThreshold,ToDoubleFunction<Map.Entry<K, V>> transformer,double basis,DoubleBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceEntriesToDoubleTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "javax.crypto.Mac.getInstance",
	"Comment": "returns a mac object that implements thespecified mac algorithm. a new mac object encapsulating themacspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "Mac getInstance(String algorithm,Mac getInstance,String algorithm,String provider,Mac getInstance,String algorithm,Provider provider){\r\n    Instance instance = JceSecurity.getInstance(\"Mac\", MacSpi.class, algorithm, provider);\r\n    return new Mac((MacSpi) instance.impl, instance.provider, algorithm);\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testScheduleAtFixedRate1_RejectedExecutionException",
	"Comment": "scheduleatfixedrate throws rejectedexecutionexception if shutdown",
	"Method": "void testScheduleAtFixedRate1_RejectedExecutionException(){\r\n    final CustomExecutor p = new CustomExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        try {\r\n            p.shutdown();\r\n            p.scheduleAtFixedRate(new NoOpRunnable(), MEDIUM_DELAY_MS, MEDIUM_DELAY_MS, MILLISECONDS);\r\n            shouldThrow();\r\n        } catch (RejectedExecutionException success) {\r\n        } catch (SecurityException ok) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedSynchronizer.transferForSignal",
	"Comment": "transfers a node from a condition queue onto sync queue.returns true if successful.",
	"Method": "boolean transferForSignal(Node node){\r\n    if (!node.compareAndSetWaitStatus(Node.CONDITION, 0))\r\n        return false;\r\n    Node p = enq(node);\r\n    int ws = p.waitStatus;\r\n    if (ws > 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))\r\n        LockSupport.unpark(node.thread);\r\n    return true;\r\n}"
}, {
	"Path": "java.io.BufferedOutputStream.flush",
	"Comment": "flushes this buffered output stream. this forces any bufferedoutput bytes to be written out to the underlying output stream.",
	"Method": "void flush(){\r\n    flushBuffer();\r\n    out.flush();\r\n}"
}, {
	"Path": "java.math.BigDecimal.bigDigitLength",
	"Comment": "returns the length of the absolute value of a biginteger, indecimal digits.",
	"Method": "int bigDigitLength(BigInteger b){\r\n    if (b.signum == 0)\r\n        return 1;\r\n    int r = (int) ((((long) b.bitLength() + 1) * 646456993) >>> 31);\r\n    return b.compareMagnitude(bigTenToThe(r)) < 0 ? r : r + 1;\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testCompareAndSetPendingCount",
	"Comment": "compareandsetpendingcount compares and sets the reportedpending count",
	"Method": "void testCompareAndSetPendingCount(){\r\n    NoopCC a = new NoopCC();\r\n    assertEquals(0, a.getPendingCount());\r\n    assertTrue(a.compareAndSetPendingCount(0, 1));\r\n    assertEquals(1, a.getPendingCount());\r\n    assertTrue(a.compareAndSetPendingCount(1, 2));\r\n    assertEquals(2, a.getPendingCount());\r\n    assertFalse(a.compareAndSetPendingCount(1, 3));\r\n    assertEquals(2, a.getPendingCount());\r\n}"
}, {
	"Path": "java.time.Duration.plus",
	"Comment": "returns a copy of this duration with the specified duration added.this instance is immutable and unaffected by this method call.",
	"Method": "Duration plus(Duration duration,Duration plus,long amountToAdd,TemporalUnit unit,Duration plus,long secondsToAdd,long nanosToAdd){\r\n    if ((secondsToAdd | nanosToAdd) == 0) {\r\n        return this;\r\n    }\r\n    long epochSec = Math.addExact(seconds, secondsToAdd);\r\n    epochSec = Math.addExact(epochSec, nanosToAdd / NANOS_PER_SECOND);\r\n    nanosToAdd = nanosToAdd % NANOS_PER_SECOND;\r\n    long nanoAdjustment = nanos + nanosToAdd;\r\n    return ofSeconds(epochSec, nanoAdjustment);\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArraySetTest.testContainsAll",
	"Comment": "containsall returns true for collections with subset of elements",
	"Method": "void testContainsAll(){\r\n    Collection full = populatedSet(3);\r\n    assertTrue(full.containsAll(full));\r\n    assertTrue(full.containsAll(Arrays.asList()));\r\n    assertTrue(full.containsAll(Arrays.asList(one)));\r\n    assertTrue(full.containsAll(Arrays.asList(one, two)));\r\n    assertFalse(full.containsAll(Arrays.asList(one, two, six)));\r\n    assertFalse(full.containsAll(Arrays.asList(six)));\r\n    CopyOnWriteArraySet empty1 = new CopyOnWriteArraySet(Arrays.asList());\r\n    CopyOnWriteArraySet empty2 = new CopyOnWriteArraySet(Arrays.asList());\r\n    assertTrue(empty1.containsAll(empty2));\r\n    assertTrue(empty1.containsAll(empty1));\r\n    assertFalse(empty1.containsAll(full));\r\n    assertTrue(full.containsAll(empty1));\r\n    try {\r\n        full.containsAll(null);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.X509CRLEntryImpl.hasExtensions",
	"Comment": "returns true if this revoked certificate entry hasextensions, otherwise false.",
	"Method": "boolean hasExtensions(){\r\n    return (extensions != null);\r\n}"
}, {
	"Path": "sun.security.x509.GeneralSubtrees.getGeneralNameInterface",
	"Comment": "return the generalnameinterface form of the generalname in one ofthe generalsubtrees.",
	"Method": "GeneralNameInterface getGeneralNameInterface(int ndx,GeneralNameInterface getGeneralNameInterface,GeneralSubtree gs){\r\n    GeneralName gn = gs.getName();\r\n    GeneralNameInterface gni = gn.getName();\r\n    return gni;\r\n}"
}, {
	"Path": "org.apache.harmony.luni.tests.java.util.ArraysTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this method\tis called before a test is executed.",
	"Method": "void setUp(){\r\n    booleanArray = new boolean[arraySize];\r\n    byteArray = new byte[arraySize];\r\n    charArray = new char[arraySize];\r\n    doubleArray = new double[arraySize];\r\n    floatArray = new float[arraySize];\r\n    intArray = new int[arraySize];\r\n    longArray = new long[arraySize];\r\n    objectArray = new Object[arraySize];\r\n    shortArray = new short[arraySize];\r\n    for (int counter = 0; counter < arraySize; counter++) {\r\n        byteArray[counter] = (byte) counter;\r\n        charArray[counter] = (char) (counter + 1);\r\n        doubleArray[counter] = counter;\r\n        floatArray[counter] = counter;\r\n        intArray[counter] = counter;\r\n        longArray[counter] = counter;\r\n        objectArray[counter] = objArray[counter];\r\n        shortArray[counter] = (short) counter;\r\n    }\r\n    for (int counter = 0; counter < arraySize; counter += 2) {\r\n        booleanArray[counter] = false;\r\n        booleanArray[counter + 1] = true;\r\n    }\r\n}"
}, {
	"Path": "sun.security.util.Cache.newHardMemoryCache",
	"Comment": "return a new memory cache with the specified maximum size, unlimitedlifetime for entries, with the values held by standard references.",
	"Method": "Cache<K, V> newHardMemoryCache(int size,Cache<K, V> newHardMemoryCache,int size,int timeout){\r\n    return new MemoryCache(false, size, timeout);\r\n}"
}, {
	"Path": "java.util.jar.JarOutputStream.putNextEntry",
	"Comment": "begins writing a new jar file entry and positions the streamto the start of the entry data. this method will also closeany previous entry. the default compression method will beused if no compression method was specified for the entry.the current time will be used if the entry has no set modificationtime.",
	"Method": "void putNextEntry(ZipEntry ze){\r\n    if (firstEntry) {\r\n        byte[] edata = ze.getExtra();\r\n        if (edata == null || !hasMagic(edata)) {\r\n            if (edata == null) {\r\n                edata = new byte[4];\r\n            } else {\r\n                byte[] tmp = new byte[edata.length + 4];\r\n                System.arraycopy(edata, 0, tmp, 4, edata.length);\r\n                edata = tmp;\r\n            }\r\n            set16(edata, 0, JAR_MAGIC);\r\n            set16(edata, 2, 0);\r\n            ze.setExtra(edata);\r\n        }\r\n        firstEntry = false;\r\n    }\r\n    super.putNextEntry(ze);\r\n}"
}, {
	"Path": "java.text.DecimalFormat.expandAffixes",
	"Comment": "expand the affix pattern strings into the expanded affix strings.if anyaffix pattern string is null, do not expand it.this method should becalled any time the symbols or the affix patterns change in order to keepthe expanded affix strings up to date.",
	"Method": "void expandAffixes(){\r\n    StringBuffer buffer = new StringBuffer();\r\n    if (posPrefixPattern != null) {\r\n        positivePrefix = expandAffix(posPrefixPattern, buffer);\r\n        positivePrefixFieldPositions = null;\r\n    }\r\n    if (posSuffixPattern != null) {\r\n        positiveSuffix = expandAffix(posSuffixPattern, buffer);\r\n        positiveSuffixFieldPositions = null;\r\n    }\r\n    if (negPrefixPattern != null) {\r\n        negativePrefix = expandAffix(negPrefixPattern, buffer);\r\n        negativePrefixFieldPositions = null;\r\n    }\r\n    if (negSuffixPattern != null) {\r\n        negativeSuffix = expandAffix(negSuffixPattern, buffer);\r\n        negativeSuffixFieldPositions = null;\r\n    }\r\n}"
}, {
	"Path": "sun.nio.ch.NativeObject.getChar",
	"Comment": "reads a char starting at the given offset from base of this nativeobject.",
	"Method": "char getChar(int offset){\r\n    return unsafe.getChar(offset + address);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.Functionizer.makeAllocatingConstructor",
	"Comment": "create a wrapper for a constructor that does the object allocation.",
	"Method": "FunctionDeclaration makeAllocatingConstructor(MethodDeclaration method,boolean releasing){\r\n    assert method.isConstructor();\r\n    ExecutableElement element = method.getExecutableElement();\r\n    TypeElement declaringClass = ElementUtil.getDeclaringClass(element);\r\n    String name = releasing ? nameTable.getReleasingConstructorName(element) : nameTable.getAllocatingConstructorName(element);\r\n    FunctionDeclaration function = new FunctionDeclaration(name, declaringClass.asType());\r\n    function.setLineNumber(method.getLineNumber());\r\n    function.setModifiers(ElementUtil.isPrivate(element) ? Modifier.PRIVATE : Modifier.PUBLIC);\r\n    function.setReturnsRetained(!releasing);\r\n    TreeUtil.copyList(method.getParameters(), function.getParameters());\r\n    Block body = new Block();\r\n    function.setBody(body);\r\n    StringBuilder sb = new StringBuilder(releasing ? \"J2OBJC_CREATE_IMPL(\" : \"J2OBJC_NEW_IMPL(\");\r\n    sb.append(nameTable.getFullName(declaringClass));\r\n    sb.append(\", \").append(nameTable.getFunctionName(element));\r\n    for (SingleVariableDeclaration param : function.getParameters()) {\r\n        sb.append(\", \").append(nameTable.getVariableQualifiedName(param.getVariableElement()));\r\n    }\r\n    sb.append(\")\");\r\n    body.addStatement(new NativeStatement(sb.toString()));\r\n    return function;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.PolicyNodeImpl.setImmutable",
	"Comment": "sets the immutability flag of this node and all of its childrento true.",
	"Method": "void setImmutable(){\r\n    if (isImmutable)\r\n        return;\r\n    for (PolicyNodeImpl node : mChildren) {\r\n        node.setImmutable();\r\n    }\r\n    isImmutable = true;\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGet(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FailingFibAction f = new FailingFibAction(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get(5L, SECONDS);\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGet(){\r\n    FailingFibAction f = new FailingFibAction(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get(5L, SECONDS);\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n}"
}, {
	"Path": "java.util.stream.Streams.composeWithExceptions",
	"Comment": "given two runnables, return a runnable that executes both in sequence,even if the first throws an exception, and if both throw exceptions, addany exceptions thrown by the second as suppressed exceptions of the first.",
	"Method": "Runnable composeWithExceptions(Runnable a,Runnable b){\r\n    return new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                a.run();\r\n            } catch (Throwable e1) {\r\n                try {\r\n                    b.run();\r\n                } catch (Throwable e2) {\r\n                    try {\r\n                        e1.addSuppressed(e2);\r\n                    } catch (Throwable ignore) {\r\n                    }\r\n                }\r\n                throw e1;\r\n            }\r\n            b.run();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "java.util.stream.Streams.composeWithExceptions",
	"Comment": "given two runnables, return a runnable that executes both in sequence,even if the first throws an exception, and if both throw exceptions, addany exceptions thrown by the second as suppressed exceptions of the first.",
	"Method": "Runnable composeWithExceptions(Runnable a,Runnable b){\r\n    try {\r\n        a.run();\r\n    } catch (Throwable e1) {\r\n        try {\r\n            b.run();\r\n        } catch (Throwable e2) {\r\n            try {\r\n                e1.addSuppressed(e2);\r\n            } catch (Throwable ignore) {\r\n            }\r\n        }\r\n        throw e1;\r\n    }\r\n    b.run();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.SwitchRewriter.fixVariableDeclarations",
	"Comment": "moves all variable declarations above the first case statement.",
	"Method": "void fixVariableDeclarations(SwitchStatement node){\r\n    List<Statement> statements = node.getStatements();\r\n    Block block = new Block();\r\n    List<Statement> blockStmts = block.getStatements();\r\n    for (int i = 0; i < statements.size(); i++) {\r\n        Statement stmt = statements.get(i);\r\n        if (stmt instanceof VariableDeclarationStatement) {\r\n            VariableDeclarationStatement declStmt = (VariableDeclarationStatement) stmt;\r\n            statements.remove(i--);\r\n            List<VariableDeclarationFragment> fragments = declStmt.getFragments();\r\n            for (VariableDeclarationFragment decl : fragments) {\r\n                Expression initializer = decl.getInitializer();\r\n                if (initializer != null) {\r\n                    Assignment assignment = new Assignment(new SimpleName(decl.getVariableElement()), TreeUtil.remove(initializer));\r\n                    statements.add(++i, new ExpressionStatement(assignment));\r\n                }\r\n            }\r\n            blockStmts.add(declStmt);\r\n        }\r\n    }\r\n    if (blockStmts.size() > 0) {\r\n        node.replaceWith(block);\r\n        blockStmts.add(node);\r\n    }\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArriveAndAwaitAdvance1",
	"Comment": "arriveandawaitadvance throws illegalstateexception with nounarrived parties",
	"Method": "void testArriveAndAwaitAdvance1(){\r\n    Phaser phaser = new Phaser();\r\n    try {\r\n        phaser.arriveAndAwaitAdvance();\r\n        shouldThrow();\r\n    } catch (IllegalStateException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArriveAndAwaitAdvance3",
	"Comment": "arriveandawaitadvance waits for all threads to arrive, thenumber of arrived parties is the same number that is accountedfor when the main thread awaitsadvance",
	"Method": "void testArriveAndAwaitAdvance3(){\r\n    final Phaser phaser = new Phaser(1);\r\n    final int THREADS = 3;\r\n    final CountDownLatch pleaseArrive = new CountDownLatch(THREADS);\r\n    final List<Thread> threads = new ArrayList<Thread>();\r\n    for (int i = 0; i < THREADS; i++) threads.add(newStartedThread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            assertEquals(0, phaser.register());\r\n            pleaseArrive.countDown();\r\n            assertEquals(1, phaser.arriveAndAwaitAdvance());\r\n        }\r\n    }));\r\n    await(pleaseArrive);\r\n    long startTime = System.nanoTime();\r\n    while (phaser.getArrivedParties() < THREADS) Thread.yield();\r\n    assertEquals(THREADS, phaser.getArrivedParties());\r\n    assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n    for (Thread thread : threads) waitForThreadToEnterWaitState(thread, SHORT_DELAY_MS);\r\n    for (Thread thread : threads) assertTrue(thread.isAlive());\r\n    assertState(phaser, 0, THREADS + 1, 1);\r\n    phaser.arriveAndAwaitAdvance();\r\n    for (Thread thread : threads) awaitTermination(thread);\r\n    assertState(phaser, 1, THREADS + 1, THREADS + 1);\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArriveAndAwaitAdvance3",
	"Comment": "arriveandawaitadvance waits for all threads to arrive, thenumber of arrived parties is the same number that is accountedfor when the main thread awaitsadvance",
	"Method": "void testArriveAndAwaitAdvance3(){\r\n    assertEquals(0, phaser.register());\r\n    pleaseArrive.countDown();\r\n    assertEquals(1, phaser.arriveAndAwaitAdvance());\r\n}"
}, {
	"Path": "java.util.stream.LongStream.concat",
	"Comment": "creates a lazily concatenated stream whose elements are all theelements of the first stream followed by all the elements of thesecond stream.the resulting stream is ordered if bothof the input streams are ordered, and parallel if either of the inputstreams is parallel.when the resulting stream is closed, the closehandlers for both input streams are invoked.",
	"Method": "LongStream concat(LongStream a,LongStream b){\r\n    Objects.requireNonNull(a);\r\n    Objects.requireNonNull(b);\r\n    Spliterator.OfLong split = new Streams.ConcatSpliterator.OfLong(a.spliterator(), b.spliterator());\r\n    LongStream stream = StreamSupport.longStream(split, a.isParallel() || b.isParallel());\r\n    return stream.onClose(Streams.composedClose(a, b));\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testCorePoolSizeIllegalArgumentException",
	"Comment": "setcorepoolsize of negative value throws illegalargumentexception",
	"Method": "void testCorePoolSizeIllegalArgumentException(){\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(1, 2, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        try {\r\n            p.setCorePoolSize(-1);\r\n            shouldThrow();\r\n        } catch (IllegalArgumentException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.jar.JarFile.getInputStream",
	"Comment": "returns an input stream for reading the contents of the specifiedzip file entry.",
	"Method": "InputStream getInputStream(ZipEntry ze){\r\n    maybeInstantiateVerifier();\r\n    if (jv == null) {\r\n        return super.getInputStream(ze);\r\n    }\r\n    if (!jvInitialized) {\r\n        initializeVerifier();\r\n        jvInitialized = true;\r\n        if (jv == null)\r\n            return super.getInputStream(ze);\r\n    }\r\n    return new JarVerifier.VerifierStream(getManifestFromReference(), ze instanceof JarFileEntry ? (JarEntry) ze : getJarEntry(ze.getName()), super.getInputStream(ze), jv);\r\n}"
}, {
	"Path": "java.util.TimeZone.getAvailableIDs",
	"Comment": "gets the available ids according to the given time zone offset in milliseconds.",
	"Method": "String[] getAvailableIDs(int rawOffset,String[] getAvailableIDs){\r\n    return AvailableIDsGetter.IDS;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberRegressionTests.Test4062486",
	"Comment": "api tests for api addition request a23. fieldposition.getbeginindex andfieldposition.getendindex.",
	"Method": "void Test4062486(){\r\n    DecimalFormat fmt = new DecimalFormat(\"#,##0.00\");\r\n    StringBuffer formatted = new StringBuffer();\r\n    FieldPosition field = new FieldPosition(0);\r\n    Double num = new Double(1234.5);\r\n    fmt.format(num, formatted, field);\r\n    if (field.getBeginIndex() != 0 && field.getEndIndex() != 5)\r\n        errln(\"Format 1234.5 failed. Begin index: \" + field.getBeginIndex() + \" End index: \" + field.getEndIndex());\r\n    field.setBeginIndex(7);\r\n    field.setEndIndex(4);\r\n    if (field.getBeginIndex() != 7 && field.getEndIndex() != 4)\r\n        errln(\"Set begin/end field indexes failed. Begin index: \" + field.getBeginIndex() + \" End index: \" + field.getEndIndex());\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.getSubjectAlternativeNames",
	"Comment": "this static method is the default implementation of thegetsubjectalternaitvenames method in x509certificate. ax509certificate provider generally should overwrite this toprovide among other things caching for better performance.",
	"Method": "Collection<List<?>> getSubjectAlternativeNames(Collection<List<?>> getSubjectAlternativeNames,X509Certificate cert){\r\n    try {\r\n        byte[] ext = cert.getExtensionValue(SUBJECT_ALT_NAME_OID);\r\n        if (ext == null) {\r\n            return null;\r\n        }\r\n        DerValue val = new DerValue(ext);\r\n        byte[] data = val.getOctetString();\r\n        SubjectAlternativeNameExtension subjectAltNameExt = new SubjectAlternativeNameExtension(Boolean.FALSE, data);\r\n        GeneralNames names;\r\n        try {\r\n            names = subjectAltNameExt.get(SubjectAlternativeNameExtension.SUBJECT_NAME);\r\n        } catch (IOException ioe) {\r\n            return Collections.<List<?>>emptySet();\r\n        }\r\n        return makeAltNames(names);\r\n    } catch (IOException ioe) {\r\n        throw new CertificateParsingException(ioe);\r\n    }\r\n}"
}, {
	"Path": "java.net.Inet6Address.isMCNodeLocal",
	"Comment": "utility routine to check if the multicast address has node scope.",
	"Method": "boolean isMCNodeLocal(){\r\n    return ((ipaddress[0] & 0xff) == 0xff && (ipaddress[1] & 0x0f) == 0x01);\r\n}"
}, {
	"Path": "sun.nio.ch.NativeObject.putObject",
	"Comment": "writes the base address of the given native object at the given offsetof this native object.",
	"Method": "void putObject(int offset,NativeObject ob){\r\n    switch(addressSize()) {\r\n        case 8:\r\n            putLong(offset, ob.address);\r\n            break;\r\n        case 4:\r\n            putInt(offset, (int) (ob.address & 0x00000000FFFFFFFF));\r\n            break;\r\n        default:\r\n            throw new InternalError(\"Address size not supported\");\r\n    }\r\n}"
}, {
	"Path": "java.time.Duration.plusDays",
	"Comment": "returns a copy of this duration with the specified duration in standard 24 hour days added.the number of days is multiplied by 86400 to obtain the number of seconds to add.this is based on the standard definition of a day as 24 hours.this instance is immutable and unaffected by this method call.",
	"Method": "Duration plusDays(long daysToAdd){\r\n    return plus(Math.multiplyExact(daysToAdd, SECONDS_PER_DAY), 0);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testAwait_IMSE",
	"Comment": "calling await without holding sync throws illegalmonitorstateexception",
	"Method": "void testAwait_IMSE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    for (AwaitMethod awaitMethod : AwaitMethod.values()) {\r\n        long startTime = System.nanoTime();\r\n        try {\r\n            await(c, awaitMethod);\r\n            shouldThrow();\r\n        } catch (IllegalMonitorStateException success) {\r\n        } catch (InterruptedException e) {\r\n            threadUnexpectedException(e);\r\n        }\r\n        assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n    }\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testCancelledForkTimedGetSingleton",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGetSingleton(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            CCF f = new LCCF(8);\r\n            assertTrue(f.cancel(true));\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (CancellationException success) {\r\n                checkCancelled(f);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testCancelledForkTimedGetSingleton",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGetSingleton(){\r\n    CCF f = new LCCF(8);\r\n    assertTrue(f.cancel(true));\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (CancellationException success) {\r\n        checkCancelled(f);\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.URICertStore.getMatchingCRLs",
	"Comment": "checks if the specified x509crl matches the criteria specified in thecrlselector.",
	"Method": "Collection<X509CRL> getMatchingCRLs(X509CRL crl,CRLSelector selector){\r\n    if (selector == null || (crl != null && selector.match(crl))) {\r\n        return Collections.singletonList(crl);\r\n    } else {\r\n        return Collections.emptyList();\r\n    }\r\n}"
}, {
	"Path": "java.security.Signature.toString",
	"Comment": "returns a string representation of this signature object,providing information that includes the state of the objectand the name of the algorithm used.",
	"Method": "String toString(){\r\n    String initState = \"\";\r\n    switch(state) {\r\n        case UNINITIALIZED:\r\n            initState = \"<not initialized>\";\r\n            break;\r\n        case VERIFY:\r\n            initState = \"<initialized for verifying>\";\r\n            break;\r\n        case SIGN:\r\n            initState = \"<initialized for signing>\";\r\n            break;\r\n    }\r\n    return \"Signature object: \" + getAlgorithm() + initState;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesZeroNull2",
	"Comment": "create a zero number from a sign and an array of zero length.the sign is 0.",
	"Method": "void testConstructorSignBytesZeroNull2(){\r\n    byte[] aBytes = {};\r\n    int aSign = 0;\r\n    byte[] rBytes = { 0 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 0, aNumber.signum());\r\n}"
}, {
	"Path": "java.lang.Package.getSpecificationVendor",
	"Comment": "return the name of the organization, vendor,or company that owns and maintains the specificationof the classes that implement this package.",
	"Method": "String getSpecificationVendor(){\r\n    return specVendor;\r\n}"
}, {
	"Path": "java.text.FieldPosition.getEndIndex",
	"Comment": "retrieves the index of the character following the last character in therequested field.",
	"Method": "int getEndIndex(){\r\n    return endIndex;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesZeroNull3",
	"Comment": "create a zero number from a sign and an array of zero length.the sign is 1.",
	"Method": "void testConstructorSignBytesZeroNull3(){\r\n    byte[] aBytes = {};\r\n    int aSign = 1;\r\n    byte[] rBytes = { 0 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 0, aNumber.signum());\r\n}"
}, {
	"Path": "sun.security.provider.certpath.URICertStore.initializeTimeout",
	"Comment": "initialize the timeout length by getting the crl timeoutsystem property. if the property has not been set, or if itsvalue is negative, set the timeout length to the default.",
	"Method": "int initializeTimeout(){\r\n    Integer tmp = Integer.getInteger(\"com.sun.security.crl.timeout\");\r\n    if (tmp == null || tmp < 0) {\r\n        return DEFAULT_CRL_CONNECT_TIMEOUT;\r\n    }\r\n    return tmp * 1000;\r\n}"
}, {
	"Path": "android.icu.dev.test.util.DisplayNameTest.addUnknown",
	"Comment": "add two unknown strings, just to make sure they get passed through without colliding",
	"Method": "String[] addUnknown(String[] strings,int len){\r\n    String[] result = new String[strings.length + 2];\r\n    result[0] = \"x1unknown\".substring(0, len);\r\n    result[1] = \"y1nknown\".substring(0, len);\r\n    System.arraycopy(strings, 0, result, 2, strings.length);\r\n    return result;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.GenerationUnit.incrementInputs",
	"Comment": "increments the number of inputs for this generationunit. this is calledfor each new processingcontext created with this generationunit.",
	"Method": "void incrementInputs(){\r\n    numUnits++;\r\n}"
}, {
	"Path": "java.util.stream.SpinedBuffer.asArray",
	"Comment": "create a new array using the specified array factory, and copy theelements into it.",
	"Method": "E[] asArray(IntFunction<E[]> arrayFactory){\r\n    long size = count();\r\n    if (size >= Nodes.MAX_ARRAY_SIZE)\r\n        throw new IllegalArgumentException(Nodes.BAD_SIZE);\r\n    E[] result = arrayFactory.apply((int) size);\r\n    copyInto(result, 0);\r\n    return result;\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testTryComplete",
	"Comment": "trycomplete decrements pending count unless zero, in which casecauses completion",
	"Method": "void testTryComplete(){\r\n    NoopCC a = new NoopCC();\r\n    assertEquals(0, a.getPendingCount());\r\n    int n = 3;\r\n    a.setPendingCount(n);\r\n    for (; n > 0; n--) {\r\n        assertEquals(n, a.getPendingCount());\r\n        a.tryComplete();\r\n        a.checkIncomplete();\r\n        assertEquals(n - 1, a.getPendingCount());\r\n    }\r\n    a.tryComplete();\r\n    assertEquals(0, a.computeN());\r\n    assertEquals(1, a.onCompletionN());\r\n    assertEquals(0, a.onExceptionalCompletionN());\r\n    assertEquals(0, a.setRawResultN());\r\n    checkCompletedNormally(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPoolTest.testIsQuiescent",
	"Comment": "after invoking a single task, isquiescent eventually becomestrue, at which time queues are empty, threads are not active,the task has completed successfully, and constructionparameters continue to hold",
	"Method": "void testIsQuiescent(){\r\n    ForkJoinPool p = new ForkJoinPool(2);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertTrue(p.isQuiescent());\r\n        long startTime = System.nanoTime();\r\n        FibTask f = new FibTask(20);\r\n        p.invoke(f);\r\n        assertSame(ForkJoinPool.defaultForkJoinWorkerThreadFactory, p.getFactory());\r\n        while (!p.isQuiescent()) {\r\n            if (millisElapsedSince(startTime) > LONG_DELAY_MS)\r\n                throw new AssertionFailedError(\"timed out\");\r\n            assertFalse(p.getAsyncMode());\r\n            assertFalse(p.isShutdown());\r\n            assertFalse(p.isTerminating());\r\n            assertFalse(p.isTerminated());\r\n            Thread.yield();\r\n        }\r\n        assertTrue(p.isQuiescent());\r\n        assertFalse(p.getAsyncMode());\r\n        assertEquals(0, p.getQueuedTaskCount());\r\n        assertEquals(0, p.getQueuedSubmissionCount());\r\n        assertFalse(p.hasQueuedSubmissions());\r\n        while (p.getActiveThreadCount() != 0 && millisElapsedSince(startTime) < LONG_DELAY_MS) Thread.yield();\r\n        assertFalse(p.isShutdown());\r\n        assertFalse(p.isTerminating());\r\n        assertFalse(p.isTerminated());\r\n        assertTrue(f.isDone());\r\n        assertEquals(6765, (int) f.get());\r\n        assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n    }\r\n}"
}, {
	"Path": "java.net.ContentHandler.getContent",
	"Comment": "given a url connect stream positioned at the beginning of therepresentation of an object, this method reads that stream andcreates an object from it.",
	"Method": "Object getContent(URLConnection urlc,Object getContent,URLConnection urlc,Class[] classes){\r\n    Object obj = getContent(urlc);\r\n    for (int i = 0; i < classes.length; i++) {\r\n        if (classes[i].isInstance(obj)) {\r\n            return obj;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.time.format.DateTimePrintContext.getValue",
	"Comment": "gets the value of the specified field.this will return the value for the specified field.",
	"Method": "R getValue(TemporalQuery<R> query,Long getValue,TemporalField field){\r\n    try {\r\n        return temporal.getLong(field);\r\n    } catch (DateTimeException ex) {\r\n        if (optional > 0) {\r\n            return null;\r\n        }\r\n        throw ex;\r\n    }\r\n}"
}, {
	"Path": "jsr166.AtomicLongFieldUpdaterTest.testCompareAndSet",
	"Comment": "compareandset succeeds in changing value if equal to expected else fails",
	"Method": "void testCompareAndSet(){\r\n    AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;\r\n    a = updaterFor(\"x\");\r\n    x = 1;\r\n    assertTrue(a.compareAndSet(this, 1, 2));\r\n    assertTrue(a.compareAndSet(this, 2, -4));\r\n    assertEquals(-4, a.get(this));\r\n    assertFalse(a.compareAndSet(this, -5, 7));\r\n    assertEquals(-4, a.get(this));\r\n    assertTrue(a.compareAndSet(this, -4, 7));\r\n    assertEquals(7, a.get(this));\r\n}"
}, {
	"Path": "org.apache.harmony.regex.tests.java.util.regex.PatternTest.testFlagsCompileValid",
	"Comment": "check that flags specified during compile are set properly this is asimple implementation that does not use flags combinations. need toimprove.",
	"Method": "void testFlagsCompileValid(){\r\n    for (String pat : testPatternsAlt) {\r\n        for (int flags : flagsSet) {\r\n            try {\r\n                Pattern p = Pattern.compile(pat, flags);\r\n                assertEquals(p.flags(), flags);\r\n            } catch (Exception e) {\r\n                fail(\"Unexpected exception: \" + e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "javax.crypto.KeyGenerator.getAlgorithm",
	"Comment": "returns the algorithm name of this keygenerator object.this is the same name that was specified in one of thegetinstance calls that created thiskeygenerator object.",
	"Method": "String getAlgorithm(){\r\n    return this.algorithm;\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testTryUnfork",
	"Comment": "tryunfork returns true for most recent unexecuted task,and suppresses execution",
	"Method": "void testTryUnfork(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FibAction g = new FibAction(9);\r\n            assertSame(g, g.fork());\r\n            FibAction f = new FibAction(8);\r\n            assertSame(f, f.fork());\r\n            assertTrue(f.tryUnfork());\r\n            helpQuiesce();\r\n            checkNotDone(f);\r\n            checkCompletedNormally(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testTryUnfork",
	"Comment": "tryunfork returns true for most recent unexecuted task,and suppresses execution",
	"Method": "void testTryUnfork(){\r\n    FibAction g = new FibAction(9);\r\n    assertSame(g, g.fork());\r\n    FibAction f = new FibAction(8);\r\n    assertSame(f, f.fork());\r\n    assertTrue(f.tryUnfork());\r\n    helpQuiesce();\r\n    checkNotDone(f);\r\n    checkCompletedNormally(g);\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinTask.get",
	"Comment": "waits if necessary for at most the given time for the computationto complete, and then retrieves its result, if available.",
	"Method": "V get(V get,long timeout,TimeUnit unit){\r\n    int s;\r\n    long nanos = unit.toNanos(timeout);\r\n    if (Thread.interrupted())\r\n        throw new InterruptedException();\r\n    if ((s = status) >= 0 && nanos > 0L) {\r\n        long d = System.nanoTime() + nanos;\r\n        long deadline = (d == 0L) ? 1L : d;\r\n        Thread t = Thread.currentThread();\r\n        if (t instanceof ForkJoinWorkerThread) {\r\n            ForkJoinWorkerThread wt = (ForkJoinWorkerThread) t;\r\n            s = wt.pool.awaitJoin(wt.workQueue, this, deadline);\r\n        } else if ((s = ((this instanceof CountedCompleter) ? ForkJoinPool.common.externalHelpComplete((CountedCompleter<?>) this, 0) : ForkJoinPool.common.tryExternalUnpush(this) ? doExec() : 0)) >= 0) {\r\n            long ns, ms;\r\n            while ((s = status) >= 0 && (ns = deadline - System.nanoTime()) > 0L) {\r\n                if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) > 0L && U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {\r\n                    synchronized (this) {\r\n                        if (status >= 0)\r\n                            wait(ms);\r\n                        else\r\n                            notifyAll();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (s >= 0)\r\n        s = status;\r\n    if ((s &= DONE_MASK) != NORMAL) {\r\n        if (s == CANCELLED)\r\n            throw new CancellationException();\r\n        if (s != EXCEPTIONAL)\r\n            throw new TimeoutException();\r\n        throw new ExecutionException(getThrowableException());\r\n    }\r\n    return getRawResult();\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.cloneNames",
	"Comment": "clone an object of the form passed tosetsubjectalternativenames and setpathtonames.throw a runtimeexception if the argument is malformed.this method wraps cloneandchecknames, changing anyioexception into a runtimeexception. thismethod should be used when the object beingcloned has already been checked, so there should never be any exceptions.",
	"Method": "Set<List<?>> cloneNames(Collection<List<?>> names){\r\n    try {\r\n        return cloneAndCheckNames(names);\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(\"cloneNames encountered IOException: \" + e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(NAME + DOT + INFO);\r\n    elements.addElement(NAME + DOT + ALG_ID);\r\n    elements.addElement(NAME + DOT + SIGNATURE);\r\n    elements.addElement(NAME + DOT + SIGNED_CERT);\r\n    return elements.elements();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.TypeUtil.getObjcFormatSpecifier",
	"Comment": "returns a format specifier that is supported by the nsstring, cfstring and nslog formattingmethods.",
	"Method": "String getObjcFormatSpecifier(TypeMirror t){\r\n    switch(t.getKind()) {\r\n        case BOOLEAN:\r\n        case BYTE:\r\n        case INT:\r\n            return \"d\";\r\n        case CHAR:\r\n            return \"c\";\r\n        case DOUBLE:\r\n            return \"lf\";\r\n        case FLOAT:\r\n            return \"f\";\r\n        case LONG:\r\n            return \"lld\";\r\n        case SHORT:\r\n            return \"hd\";\r\n        default:\r\n            return \"@\";\r\n    }\r\n}"
}, {
	"Path": "jsr166.ConcurrentLinkedQueueTest.testConstructor5",
	"Comment": "initializing from collection with some null elements throws npe",
	"Method": "void testConstructor5(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        new ConcurrentLinkedQueue(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ConcurrentLinkedQueueTest.testConstructor6",
	"Comment": "queue contains all elements of collection used to initialize",
	"Method": "void testConstructor6(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = new Integer(i);\r\n    ConcurrentLinkedQueue q = new ConcurrentLinkedQueue(Arrays.asList(ints));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "jsr166.TreeSetTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    TreeSet q = new TreeSet();\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        q.addAll(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.security.SecureClassLoader.getPermissions",
	"Comment": "returns the permissions for the given codesource object.this method is invoked by the defineclass method which takesa codesource as an argument when it is constructing theprotectiondomain for the class being defined.",
	"Method": "PermissionCollection getPermissions(CodeSource codesource){\r\n    check();\r\n    return new Permissions();\r\n}"
}, {
	"Path": "sun.security.x509.KeyIdentifier.hashCode",
	"Comment": "returns a hash code value for this object.objects that are equal will also have the same hashcode.",
	"Method": "int hashCode(){\r\n    int retval = 0;\r\n    for (int i = 0; i < octetString.length; i++) retval += octetString[i] * i;\r\n    return retval;\r\n}"
}, {
	"Path": "java.util.zip.ZipOutputStream.putNextEntry",
	"Comment": "begins writing a new zip file entry and positions the stream to thestart of the entry data. closes the current entry if still active.the default compression method will be used if no compression methodwas specified for the entry, and the current time will be used ifthe entry has no set modification time.",
	"Method": "void putNextEntry(ZipEntry e){\r\n    ensureOpen();\r\n    if (current != null) {\r\n        closeEntry();\r\n    }\r\n    if (e.time == -1) {\r\n        e.setTime(System.currentTimeMillis());\r\n    }\r\n    if (e.method == -1) {\r\n        e.method = method;\r\n    }\r\n    e.flag = 0;\r\n    switch(e.method) {\r\n        case DEFLATED:\r\n            if (e.size == -1 || e.csize == -1 || e.crc == -1)\r\n                e.flag = 8;\r\n            break;\r\n        case STORED:\r\n            if (e.size == -1) {\r\n                e.size = e.csize;\r\n            } else if (e.csize == -1) {\r\n                e.csize = e.size;\r\n            } else if (e.size != e.csize) {\r\n                throw new ZipException(\"STORED entry where compressed != uncompressed size\");\r\n            }\r\n            if (e.size == -1 || e.crc == -1) {\r\n                throw new ZipException(\"STORED entry missing size, compressed size, or crc-32\");\r\n            }\r\n            break;\r\n        default:\r\n            throw new ZipException(\"unsupported compression method\");\r\n    }\r\n    if (!names.add(e.name)) {\r\n        throw new ZipException(\"duplicate entry: \" + e.name);\r\n    }\r\n    if (zc.isUTF8())\r\n        e.flag |= EFS;\r\n    current = new XEntry(e, written);\r\n    xentries.add(current);\r\n    writeLOC(current);\r\n}"
}, {
	"Path": "java.util.concurrent.locks.ReentrantReadWriteLock.getWriteHoldCount",
	"Comment": "queries the number of reentrant write holds on this lock by thecurrent thread.a writer thread has a hold on a lock foreach lock action that is not matched by an unlock action.",
	"Method": "int getWriteHoldCount(int getWriteHoldCount){\r\n    return sync.getWriteHoldCount();\r\n}"
}, {
	"Path": "android.icu.dev.test.translit.TransliteratorTest.TestVariableRange",
	"Comment": "test the use variable range pragma, making sure that use ofvariable range characters is detected and flagged as an error.",
	"Method": "void TestVariableRange(){\r\n    String rule = \"use variable range 0x70 0x72; a > A; b > B; q > Q;\";\r\n    try {\r\n        Transliterator t = Transliterator.createFromRules(\"ID\", rule, Transliterator.FORWARD);\r\n        if (t != null) {\r\n            errln(\"FAIL: Did not get the expected exception\");\r\n        }\r\n    } catch (IllegalArgumentException e) {\r\n        logln(\"Ok: \" + e.getMessage());\r\n        return;\r\n    }\r\n    errln(\"FAIL: No syntax error\");\r\n}"
}, {
	"Path": "java.lang.StringBuilder.readObject",
	"Comment": "readobject is called to restore the state of the stringbuffer froma stream.",
	"Method": "void readObject(java.io.ObjectInputStream s){\r\n    s.defaultReadObject();\r\n    int count = s.readInt();\r\n    char[] value = (char[]) s.readObject();\r\n    append(value, 0, count);\r\n}"
}, {
	"Path": "sun.security.x509.NetscapeCertTypeExtension.toString",
	"Comment": "returns a printable representation of the netscapecerttype.",
	"Method": "String toString(){\r\n    String s = super.toString() + \"NetscapeCertType [\\n\";\r\n    try {\r\n        if (isSet(getPosition(SSL_CLIENT)))\r\n            s += \"   SSL client\\n\";\r\n        if (isSet(getPosition(SSL_SERVER)))\r\n            s += \"   SSL server\\n\";\r\n        if (isSet(getPosition(S_MIME)))\r\n            s += \"   S/MIME\\n\";\r\n        if (isSet(getPosition(OBJECT_SIGNING)))\r\n            s += \"   Object Signing\\n\";\r\n        if (isSet(getPosition(SSL_CA)))\r\n            s += \"   SSL CA\\n\";\r\n        if (isSet(getPosition(S_MIME_CA)))\r\n            s += \"   S/MIME CA\\n\";\r\n        if (isSet(getPosition(OBJECT_SIGNING_CA)))\r\n            s += \"   Object Signing CA\";\r\n    } catch (Exception e) {\r\n    }\r\n    s += \"]\\n\";\r\n    return (s);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkQuietlyJoin",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoin(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingFibAction f = new FailingFibAction(8);\r\n            assertSame(f, f.fork());\r\n            f.quietlyJoin();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkQuietlyJoin",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoin(){\r\n    FailingFibAction f = new FailingFibAction(8);\r\n    assertSame(f, f.fork());\r\n    f.quietlyJoin();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n}"
}, {
	"Path": "java.text.SimpleDateFormat.applyLocalizedPattern",
	"Comment": "applies the given localized pattern string to this date format.",
	"Method": "void applyLocalizedPattern(String pattern){\r\n    String p = translatePattern(pattern, formatData.getLocalPatternChars(), DateFormatSymbols.patternChars);\r\n    compiledPattern = compile(p);\r\n    this.pattern = p;\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testGet1_IndexOutOfBoundsException",
	"Comment": "get throws an indexoutofboundsexception on a negative index",
	"Method": "void testGet1_IndexOutOfBoundsException(){\r\n    CopyOnWriteArrayList c = populatedArray(5);\r\n    List[] lists = { c, c.subList(1, c.size() - 1) };\r\n    for (List list : lists) {\r\n        try {\r\n            list.get(-1);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.net.SocksSocketImpl.authenticate",
	"Comment": "provides the authentication machanism required by the proxy.",
	"Method": "boolean authenticate(byte method,InputStream in,BufferedOutputStream out,boolean authenticate,byte method,InputStream in,BufferedOutputStream out,long deadlineMillis){\r\n    if (method == NO_AUTH)\r\n        return true;\r\n    if (method == USER_PASSW) {\r\n        String userName;\r\n        String password = null;\r\n        final InetAddress addr = InetAddress.getByName(server);\r\n        PasswordAuthentication pw = Authenticator.requestPasswordAuthentication(server, addr, serverPort, \"SOCKS5\", \"SOCKS authentication\", null);\r\n        if (pw != null) {\r\n            userName = pw.getUserName();\r\n            password = new String(pw.getPassword());\r\n        } else {\r\n            userName = System.getProperty(\"user.name\");\r\n        }\r\n        if (userName == null)\r\n            return false;\r\n        out.write(1);\r\n        out.write(userName.length());\r\n        try {\r\n            out.write(userName.getBytes(\"ISO-8859-1\"));\r\n        } catch (java.io.UnsupportedEncodingException uee) {\r\n            assert false;\r\n        }\r\n        if (password != null) {\r\n            out.write(password.length());\r\n            try {\r\n                out.write(password.getBytes(\"ISO-8859-1\"));\r\n            } catch (java.io.UnsupportedEncodingException uee) {\r\n                assert false;\r\n            }\r\n        } else\r\n            out.write(0);\r\n        out.flush();\r\n        byte[] data = new byte[2];\r\n        int i = readSocksReply(in, data, deadlineMillis);\r\n        if (i != 2 || data[1] != 0) {\r\n            out.close();\r\n            in.close();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "android.icu.dev.test.lang.UTF16Test.TestfindOffset",
	"Comment": "testing findoffsetfromcodepoint and findcodepointoffset",
	"Method": "void TestfindOffset(){\r\n    String str = \"a?b\";\r\n    StringBuffer strbuff = new StringBuffer(str);\r\n    char[] array = str.toCharArray();\r\n    int limit = str.length();\r\n    if (UTF16.findCodePointOffset(str, 0) != 0 || UTF16.findOffsetFromCodePoint(str, 0) != 0 || UTF16.findCodePointOffset(strbuff, 0) != 0 || UTF16.findOffsetFromCodePoint(strbuff, 0) != 0 || UTF16.findCodePointOffset(array, 0, limit, 0) != 0 || UTF16.findOffsetFromCodePoint(array, 0, limit, 0) != 0) {\r\n        errln(\"FAIL Getting the first codepoint offset to a string with \" + \"supplementary characters\");\r\n    }\r\n    if (UTF16.findCodePointOffset(str, 1) != 1 || UTF16.findOffsetFromCodePoint(str, 1) != 1 || UTF16.findCodePointOffset(strbuff, 1) != 1 || UTF16.findOffsetFromCodePoint(strbuff, 1) != 1 || UTF16.findCodePointOffset(array, 0, limit, 1) != 1 || UTF16.findOffsetFromCodePoint(array, 0, limit, 1) != 1) {\r\n        errln(\"FAIL Getting the second codepoint offset to a string with \" + \"supplementary characters\");\r\n    }\r\n    if (UTF16.findCodePointOffset(str, 2) != 1 || UTF16.findOffsetFromCodePoint(str, 2) != 3 || UTF16.findCodePointOffset(strbuff, 2) != 1 || UTF16.findOffsetFromCodePoint(strbuff, 2) != 3 || UTF16.findCodePointOffset(array, 0, limit, 2) != 1 || UTF16.findOffsetFromCodePoint(array, 0, limit, 2) != 3) {\r\n        errln(\"FAIL Getting the third codepoint offset to a string with \" + \"supplementary characters\");\r\n    }\r\n    if (UTF16.findCodePointOffset(str, 3) != 2 || UTF16.findOffsetFromCodePoint(str, 3) != 4 || UTF16.findCodePointOffset(strbuff, 3) != 2 || UTF16.findOffsetFromCodePoint(strbuff, 3) != 4 || UTF16.findCodePointOffset(array, 0, limit, 3) != 2 || UTF16.findOffsetFromCodePoint(array, 0, limit, 3) != 4) {\r\n        errln(\"FAIL Getting the last codepoint offset to a string with \" + \"supplementary characters\");\r\n    }\r\n    if (UTF16.findCodePointOffset(str, 4) != 3 || UTF16.findCodePointOffset(strbuff, 4) != 3 || UTF16.findCodePointOffset(array, 0, limit, 4) != 3) {\r\n        errln(\"FAIL Getting the length offset to a string with \" + \"supplementary characters\");\r\n    }\r\n    try {\r\n        UTF16.findCodePointOffset(str, 5);\r\n        errln(\"FAIL Getting the a non-existence codepoint to a string \" + \"with supplementary characters\");\r\n    } catch (Exception e) {\r\n        logln(\"Passed out of bounds codepoint offset\");\r\n    }\r\n    try {\r\n        UTF16.findOffsetFromCodePoint(str, 4);\r\n        errln(\"FAIL Getting the a non-existence codepoint to a string \" + \"with supplementary characters\");\r\n    } catch (Exception e) {\r\n        logln(\"Passed out of bounds codepoint offset\");\r\n    }\r\n    try {\r\n        UTF16.findCodePointOffset(strbuff, 5);\r\n        errln(\"FAIL Getting the a non-existence codepoint to a string \" + \"with supplementary characters\");\r\n    } catch (Exception e) {\r\n        logln(\"Passed out of bounds codepoint offset\");\r\n    }\r\n    try {\r\n        UTF16.findOffsetFromCodePoint(strbuff, 4);\r\n        errln(\"FAIL Getting the a non-existence codepoint to a string \" + \"with supplementary characters\");\r\n    } catch (Exception e) {\r\n        logln(\"Passed out of bounds codepoint offset\");\r\n    }\r\n    try {\r\n        UTF16.findCodePointOffset(array, 0, limit, 5);\r\n        errln(\"FAIL Getting the a non-existence codepoint to a string \" + \"with supplementary characters\");\r\n    } catch (Exception e) {\r\n        logln(\"Passed out of bounds codepoint offset\");\r\n    }\r\n    try {\r\n        UTF16.findOffsetFromCodePoint(array, 0, limit, 4);\r\n        errln(\"FAIL Getting the a non-existence codepoint to a string \" + \"with supplementary characters\");\r\n    } catch (Exception e) {\r\n        logln(\"Passed out of bounds codepoint offset\");\r\n    }\r\n    if (UTF16.findCodePointOffset(array, 1, 3, 0) != 0 || UTF16.findOffsetFromCodePoint(array, 1, 3, 0) != 0 || UTF16.findCodePointOffset(array, 1, 3, 1) != 0 || UTF16.findCodePointOffset(array, 1, 3, 2) != 1 || UTF16.findOffsetFromCodePoint(array, 1, 3, 1) != 2) {\r\n        errln(\"FAIL Getting valid codepoint offset in sub array\");\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testKeepAliveTimeIllegalArgumentException",
	"Comment": "setkeepalivetime throws illegalargumentexceptionwhen given a negative value",
	"Method": "void testKeepAliveTimeIllegalArgumentException(){\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(2, 3, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        try {\r\n            p.setKeepAliveTime(-1, MILLISECONDS);\r\n            shouldThrow();\r\n        } catch (IllegalArgumentException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ConcurrentLinkedDequeTest.testSerialization",
	"Comment": "a deserialized serialized deque has same elements in same order",
	"Method": "void testSerialization(){\r\n    if (ReflectionUtil.isJreReflectionStripped()) {\r\n        return;\r\n    }\r\n    Queue x = populatedDeque(SIZE);\r\n    Queue y = serialClone(x);\r\n    assertNotSame(x, y);\r\n    assertEquals(x.size(), y.size());\r\n    assertEquals(x.toString(), y.toString());\r\n    assertTrue(Arrays.equals(x.toArray(), y.toArray()));\r\n    while (!x.isEmpty()) {\r\n        assertFalse(y.isEmpty());\r\n        assertEquals(x.remove(), y.remove());\r\n    }\r\n    assertTrue(y.isEmpty());\r\n}"
}, {
	"Path": "sun.security.x509.X509Key.hashCode",
	"Comment": "calculates a hash code value for the object. objectswhich are equal will also have the same hashcode.",
	"Method": "int hashCode(){\r\n    try {\r\n        byte[] b1 = getEncodedInternal();\r\n        int r = b1.length;\r\n        for (int i = 0; i < b1.length; i++) {\r\n            r += (b1[i] & 0xff) * 37;\r\n        }\r\n        return r;\r\n    } catch (InvalidKeyException e) {\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testTryAcquireSharedNanos_Timeout",
	"Comment": "tryacquiresharednanos times out if not released before timeout",
	"Method": "void testTryAcquireSharedNanos_Timeout(){\r\n    final BooleanLatch l = new BooleanLatch();\r\n    final BooleanLatch observedQueued = new BooleanLatch();\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            assertFalse(l.isSignalled());\r\n            for (long millis = timeoutMillis(); !observedQueued.isSignalled(); millis *= 2) {\r\n                long nanos = MILLISECONDS.toNanos(millis);\r\n                long startTime = System.nanoTime();\r\n                assertFalse(l.tryAcquireSharedNanos(0, nanos));\r\n                assertTrue(millisElapsedSince(startTime) >= millis);\r\n            }\r\n            assertFalse(l.isSignalled());\r\n        }\r\n    });\r\n    waitForQueuedThread(l, t);\r\n    observedQueued.releaseShared(0);\r\n    assertFalse(l.isSignalled());\r\n    awaitTermination(t);\r\n    assertFalse(l.isSignalled());\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testTryAcquireSharedNanos_Timeout",
	"Comment": "tryacquiresharednanos times out if not released before timeout",
	"Method": "void testTryAcquireSharedNanos_Timeout(){\r\n    assertFalse(l.isSignalled());\r\n    for (long millis = timeoutMillis(); !observedQueued.isSignalled(); millis *= 2) {\r\n        long nanos = MILLISECONDS.toNanos(millis);\r\n        long startTime = System.nanoTime();\r\n        assertFalse(l.tryAcquireSharedNanos(0, nanos));\r\n        assertTrue(millisElapsedSince(startTime) >= millis);\r\n    }\r\n    assertFalse(l.isSignalled());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testDoubleValuePosNotRounded",
	"Comment": "convert a positive number to a double value. rounding is not needed.",
	"Method": "void testDoubleValuePosNotRounded(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, -128, 23, 1, -3, -5 };\r\n    int aSign = 1;\r\n    double result = 1.5474726438794828E26;\r\n    double aNumber = new BigInteger(aSign, a).doubleValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "java.time.Period.isZero",
	"Comment": "checks if all three units of this period are zero.a zero period has the value zero for the years, months and days units.",
	"Method": "boolean isZero(){\r\n    return (this == ZERO);\r\n}"
}, {
	"Path": "java.util.concurrent.SynchronousQueue.put",
	"Comment": "adds the specified element to this queue, waiting if necessary foranother thread to receive it.",
	"Method": "void put(E e){\r\n    if (e == null)\r\n        throw new NullPointerException();\r\n    if (transferer.transfer(e, false, 0) == null) {\r\n        Thread.interrupted();\r\n        throw new InterruptedException();\r\n    }\r\n}"
}, {
	"Path": "java.text.SimpleDateFormat.readObject",
	"Comment": "after reading an object from the input stream, the formatpattern in the object is verified.",
	"Method": "void readObject(ObjectInputStream stream){\r\n    stream.defaultReadObject();\r\n    try {\r\n        compiledPattern = compile(pattern);\r\n    } catch (Exception e) {\r\n        throw new InvalidObjectException(\"invalid pattern\");\r\n    }\r\n    if (serialVersionOnStream < 1) {\r\n        initializeDefaultCentury();\r\n    } else {\r\n        parseAmbiguousDatesAsAfter(defaultCenturyStart);\r\n    }\r\n    serialVersionOnStream = currentSerialVersion;\r\n    TimeZone tz = getTimeZone();\r\n    if (tz instanceof SimpleTimeZone) {\r\n        String id = tz.getID();\r\n        TimeZone zi = TimeZone.getTimeZone(id);\r\n        if (zi != null && zi.hasSameRules(tz) && zi.getID().equals(id)) {\r\n            setTimeZone(zi);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.X500Name.hashCode",
	"Comment": "calculates a hash code value for the object.objectswhich are equal will also have the same hashcode.",
	"Method": "int hashCode(){\r\n    return getRFC2253CanonicalName().hashCode();\r\n}"
}, {
	"Path": "java.text.DecimalFormat.setMinimumIntegerDigits",
	"Comment": "sets the minimum number of digits allowed in the integer portion of anumber.for formatting numbers other than biginteger andbigdecimal objects, the lower of newvalue and309 is used. negative input values are replaced with 0.",
	"Method": "void setMinimumIntegerDigits(int newValue){\r\n    minimumIntegerDigits = Math.min(Math.max(0, newValue), MAXIMUM_INTEGER_DIGITS);\r\n    super.setMinimumIntegerDigits((minimumIntegerDigits > DOUBLE_INTEGER_DIGITS) ? DOUBLE_INTEGER_DIGITS : minimumIntegerDigits);\r\n    if (minimumIntegerDigits > maximumIntegerDigits) {\r\n        maximumIntegerDigits = minimumIntegerDigits;\r\n        super.setMaximumIntegerDigits((maximumIntegerDigits > DOUBLE_INTEGER_DIGITS) ? DOUBLE_INTEGER_DIGITS : maximumIntegerDigits);\r\n    }\r\n    fastPathCheckNeeded = true;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testConstructor15",
	"Comment": "constructor throws if corepoolsize is greater than the maximumpoolsize",
	"Method": "void testConstructor15(){\r\n    try {\r\n        new ThreadPoolExecutor(2, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10), new NoOpREHandler());\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.lang.reflect.FieldTest.tearDown",
	"Comment": "tears down the fixture, for example, close a network connection. thismethod is called after a test is executed.",
	"Method": "void tearDown(){\r\n    TestField.booleanSField = true;\r\n    TestField.byteSField = Byte.MAX_VALUE;\r\n    TestField.charSField = 'T';\r\n    TestField.doubleSField = Double.MAX_VALUE;\r\n    TestField.floatSField = Float.MAX_VALUE;\r\n    TestField.intSField = Integer.MAX_VALUE;\r\n    TestField.longSField = Long.MAX_VALUE;\r\n    TestField.shortSField = Short.MAX_VALUE;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testConstructor11",
	"Comment": "constructor throws if corepoolsize argument is less than zero",
	"Method": "void testConstructor11(){\r\n    try {\r\n        new ThreadPoolExecutor(-1, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10), new NoOpREHandler());\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "java.text.DecimalFormat.getPositivePrefixFieldPositions",
	"Comment": "returns the fieldpositions of the fields in the prefix used forpositive numbers. this is not used if the user has explicitly seta positive prefix via setpositiveprefix. this islazily created.",
	"Method": "FieldPosition[] getPositivePrefixFieldPositions(){\r\n    if (positivePrefixFieldPositions == null) {\r\n        if (posPrefixPattern != null) {\r\n            positivePrefixFieldPositions = expandAffix(posPrefixPattern);\r\n        } else {\r\n            positivePrefixFieldPositions = EmptyFieldPositionArray;\r\n        }\r\n    }\r\n    return positivePrefixFieldPositions;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testConstructor10",
	"Comment": "constructor throws if corepoolsize is greater than the maximumpoolsize",
	"Method": "void testConstructor10(){\r\n    try {\r\n        new ThreadPoolExecutor(2, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10), new SimpleThreadFactory());\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "java.nio.charset.CharsetDecoder.averageCharsPerByte",
	"Comment": "returns the average number of characters that will be produced for eachbyte of input.this heuristic value may be used to estimate the sizeof the output buffer required for a given input sequence.",
	"Method": "float averageCharsPerByte(){\r\n    return averageCharsPerByte;\r\n}"
}, {
	"Path": "java.net.AbstractPlainSocketImpl.bind",
	"Comment": "binds the socket to the specified address of the specified local port.",
	"Method": "void bind(InetAddress address,int lport){\r\n    synchronized (fdLock) {\r\n        if (!closePending && (socket == null || !socket.isBound())) {\r\n            NetHooks.beforeTcpBind(fd, address, lport);\r\n        }\r\n    }\r\n    socketBind(address, lport);\r\n    if (socket != null)\r\n        socket.setBound();\r\n    if (serverSocket != null)\r\n        serverSocket.setBound();\r\n}"
}, {
	"Path": "sun.security.provider.certpath.ConstraintsChecker.verifyNameConstraints",
	"Comment": "internal method to check the name constraints against a cert",
	"Method": "void verifyNameConstraints(X509Certificate currCert){\r\n    String msg = \"name constraints\";\r\n    if (debug != null) {\r\n        debug.println(\"---checking \" + msg + \"...\");\r\n    }\r\n    if (prevNC != null && ((i == certPathLength) || !X509CertImpl.isSelfIssued(currCert))) {\r\n        if (debug != null) {\r\n            debug.println(\"prevNC = \" + prevNC);\r\n            debug.println(\"currDN = \" + currCert.getSubjectX500Principal());\r\n        }\r\n        try {\r\n            if (!prevNC.verify(currCert)) {\r\n                throw new CertPathValidatorException(msg + \" check failed\", null, null, -1, PKIXReason.INVALID_NAME);\r\n            }\r\n        } catch (IOException ioe) {\r\n            throw new CertPathValidatorException(ioe);\r\n        }\r\n    }\r\n    prevNC = mergeNameConstraints(currCert, prevNC);\r\n    if (debug != null)\r\n        debug.println(msg + \" verified.\");\r\n}"
}, {
	"Path": "sun.nio.ch.ServerSocketChannelImpl.translateReadyOps",
	"Comment": "translates native poll revent set into a ready operation set",
	"Method": "boolean translateReadyOps(int ops,int initialOps,SelectionKeyImpl sk){\r\n    int intOps = sk.nioInterestOps();\r\n    int oldOps = sk.nioReadyOps();\r\n    int newOps = initialOps;\r\n    if ((ops & PollArrayWrapper.POLLNVAL) != 0) {\r\n        return false;\r\n    }\r\n    if ((ops & (PollArrayWrapper.POLLERR | PollArrayWrapper.POLLHUP)) != 0) {\r\n        newOps = intOps;\r\n        sk.nioReadyOps(newOps);\r\n        return (newOps & ~oldOps) != 0;\r\n    }\r\n    if (((ops & PollArrayWrapper.POLLIN) != 0) && ((intOps & SelectionKey.OP_ACCEPT) != 0))\r\n        newOps |= SelectionKey.OP_ACCEPT;\r\n    sk.nioReadyOps(newOps);\r\n    return (newOps & ~oldOps) != 0;\r\n}"
}, {
	"Path": "java.util.Locale.composeList",
	"Comment": "given a list of strings, return a list shortened to three elements.shorten it by applying the given format to the first two elementsrecursively.",
	"Method": "String[] composeList(MessageFormat format,String[] list){\r\n    if (list.length <= 3)\r\n        return list;\r\n    String[] listItems = { list[0], list[1] };\r\n    String newItem = format.format(listItems);\r\n    String[] newList = new String[list.length - 1];\r\n    System.arraycopy(list, 2, newList, 1, newList.length - 1);\r\n    newList[0] = newItem;\r\n    return composeList(format, newList);\r\n}"
}, {
	"Path": "sun.util.calendar.AbstractCalendar.getDayOfWeekDateAfter",
	"Comment": "returns a date of the given day of week that is closest to andafter the given fixed date.",
	"Method": "long getDayOfWeekDateAfter(long fixedDate,int dayOfWeek){\r\n    return getDayOfWeekDateOnOrBefore(fixedDate + 7, dayOfWeek);\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.getAvailableLocales",
	"Comment": "returns an array of all locales for which thegetinstance methods of this class can returnlocalized instances.",
	"Method": "Locale[] getAvailableLocales(){\r\n    return ICU.getAvailableLocales();\r\n}"
}, {
	"Path": "sun.security.provider.certpath.DistributionPointFetcher.getCRLs",
	"Comment": "download crls from the given distribution point, verify and return them.see the top of the class for current limitations.",
	"Method": "Collection<X509CRL> getCRLs(X509CRLSelector selector,boolean signFlag,PublicKey prevKey,String provider,List<CertStore> certStores,boolean[] reasonsMask,Set<TrustAnchor> trustAnchors,Date validity,Collection<X509CRL> getCRLs,X509CRLSelector selector,boolean signFlag,PublicKey prevKey,X509Certificate prevCert,String provider,List<CertStore> certStores,boolean[] reasonsMask,Set<TrustAnchor> trustAnchors,Date validity,Collection<X509CRL> getCRLs,X509CRLSelector selector,X509CertImpl certImpl,DistributionPoint point,boolean[] reasonsMask,boolean signFlag,PublicKey prevKey,X509Certificate prevCert,String provider,List<CertStore> certStores,Set<TrustAnchor> trustAnchors,Date validity,Collection<X509CRL> getCRLs,X500Name name,X500Principal certIssuer,List<CertStore> certStores){\r\n    if (debug != null) {\r\n        debug.println(\"Trying to fetch CRL from DP \" + name);\r\n    }\r\n    X509CRLSelector xcs = new X509CRLSelector();\r\n    xcs.addIssuer(name.asX500Principal());\r\n    xcs.addIssuer(certIssuer);\r\n    Collection<X509CRL> crls = new ArrayList();\r\n    CertStoreException savedCSE = null;\r\n    for (CertStore store : certStores) {\r\n        try {\r\n            for (CRL crl : store.getCRLs(xcs)) {\r\n                crls.add((X509CRL) crl);\r\n            }\r\n        } catch (CertStoreException cse) {\r\n            if (debug != null) {\r\n                debug.println(\"Exception while retrieving \" + \"CRLs: \" + cse);\r\n                cse.printStackTrace();\r\n            }\r\n            savedCSE = new PKIX.CertStoreTypeException(store.getType(), cse);\r\n        }\r\n    }\r\n    if (crls.isEmpty() && savedCSE != null) {\r\n        throw savedCSE;\r\n    } else {\r\n        return crls;\r\n    }\r\n}"
}, {
	"Path": "java.net.Authenticator.getRequestingHost",
	"Comment": "gets the hostname of thesite or proxy requesting authentication, or nullif not available.",
	"Method": "String getRequestingHost(){\r\n    return requestingHost;\r\n}"
}, {
	"Path": "java.lang.Character.isValidCodePoint",
	"Comment": "determines whether the specified code point is a validunicode code point value.",
	"Method": "boolean isValidCodePoint(int codePoint){\r\n    int plane = codePoint >>> 16;\r\n    return plane < ((MAX_CODE_POINT + 1) >>> 16);\r\n}"
}, {
	"Path": "java.util.concurrent.Phaser.getUnarrivedParties",
	"Comment": "returns the number of registered parties that have not yetarrived at the current phase of this phaser. if this phaser hasterminated, the returned value is meaningless and arbitrary.",
	"Method": "int getUnarrivedParties(){\r\n    return unarrivedOf(reconcileState());\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testConstructor16",
	"Comment": "constructor throws if corepoolsize argument is less than zero",
	"Method": "void testConstructor16(){\r\n    try {\r\n        new ThreadPoolExecutor(-1, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10), new SimpleThreadFactory(), new NoOpREHandler());\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "java.time.LocalDate.format",
	"Comment": "formats this date using the specified formatter.this date will be passed to the formatter to produce a string.",
	"Method": "String format(DateTimeFormatter formatter){\r\n    Objects.requireNonNull(formatter, \"formatter\");\r\n    return formatter.format(this);\r\n}"
}, {
	"Path": "java.util.Date.getDate",
	"Comment": "returns the day of the month represented by this date object.the value returned is between 1 and 31representing the day of the month that contains or begins with theinstant in time represented by this date object, asinterpreted in the local time zone.",
	"Method": "int getDate(){\r\n    return normalize().getDayOfMonth();\r\n}"
}, {
	"Path": "java.security.KeyFactory.getAlgorithm",
	"Comment": "gets the name of the algorithmassociated with this keyfactory.",
	"Method": "String getAlgorithm(){\r\n    return this.algorithm;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.util.PropertyResourceBundleTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    InputStream propertiesStream = new ByteArrayInputStream(\"p1=one\\np2=two\".getBytes(\"ISO-8859-1\"));\r\n    try {\r\n        prb = new PropertyResourceBundle(propertiesStream);\r\n    } catch (java.io.IOException e) {\r\n        fail(\"Construction of PropertyResourceBundle threw IOException\");\r\n    }\r\n}"
}, {
	"Path": "java.util.ArrayList.clear",
	"Comment": "removes all of the elements from this list.the list willbe empty after this call returns.",
	"Method": "void clear(){\r\n    modCount++;\r\n    for (int i = 0; i < size; i++) elementData[i] = null;\r\n    size = 0;\r\n}"
}, {
	"Path": "java.beans.PropertyChangeSupport.getPropertyChangeListeners",
	"Comment": "returns an array of all the listeners which have been associatedwith the named property.",
	"Method": "PropertyChangeListener[] getPropertyChangeListeners(PropertyChangeListener[] getPropertyChangeListeners,String propertyName){\r\n    return this.map.getListeners(propertyName);\r\n}"
}, {
	"Path": "sun.security.x509.X509CRLImpl.hasUnsupportedCriticalExtension",
	"Comment": "return true if a critical extension is found that isnot supported, otherwise return false.",
	"Method": "boolean hasUnsupportedCriticalExtension(){\r\n    if (extensions == null)\r\n        return false;\r\n    return extensions.hasUnsupportedCriticalExtension();\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getPrivateKeyValid",
	"Comment": "returns the privatekeyvalid criterion. the specified date must fallwithin the private key validity period for thex509certificate. if null, no privatekeyvalidcheck will be done.note that the date returned is cloned to protect againstsubsequent modifications.",
	"Method": "Date getPrivateKeyValid(){\r\n    if (privateKeyValid == null) {\r\n        return null;\r\n    }\r\n    return (Date) privateKeyValid.clone();\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.getMinusSignString",
	"Comment": "gets the string used to represent minus sign. if no explicitnegative format is specified, one is formed by prefixingminussign to the positive format.",
	"Method": "String getMinusSignString(){\r\n    return String.valueOf(minusSign);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkGet",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGet(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FailingCCF f = new LFCCF(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get();\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkGet",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGet(){\r\n    FailingCCF f = new LFCCF(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get();\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testLongValuePositive1",
	"Comment": "convert a biginteger to a positive long valuethe biginteger is longer than int.",
	"Method": "void testLongValuePositive1(){\r\n    byte[] aBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3, 120, -34, -12, 45, 98 };\r\n    long result = 3268209772258930018L;\r\n    long aNumber = new BigInteger(aBytes).longValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testLongValuePositive2",
	"Comment": "convert a number to a positive long valuethe number fits in a long.",
	"Method": "void testLongValuePositive2(){\r\n    byte[] aBytes = { 12, 56, 100, 18, -105, 34, -18, 45 };\r\n    long result = 880563758158769709L;\r\n    long aNumber = new BigInteger(aBytes).longValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.setPercent",
	"Comment": "sets the character used for percent sign. different for arabic, etc.",
	"Method": "void setPercent(char percent){\r\n    this.percent = percent;\r\n}"
}, {
	"Path": "jsr166.ForkJoinTask8Test.testPeekNextLocalTaskAsync",
	"Comment": "peeknextlocaltask returns least recent unexecuted task in async mode",
	"Method": "void testPeekNextLocalTaskAsync(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib g = new AsyncFib(9);\r\n            assertSame(g, g.fork());\r\n            AsyncFib f = new AsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, peekNextLocalTask());\r\n            assertNull(f.join());\r\n            helpQuiesce();\r\n            f.checkCompletedNormally();\r\n            g.checkCompletedNormally();\r\n        }\r\n    };\r\n    testInvokeOnPool(asyncSingletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTask8Test.testPeekNextLocalTaskAsync",
	"Comment": "peeknextlocaltask returns least recent unexecuted task in async mode",
	"Method": "void testPeekNextLocalTaskAsync(){\r\n    AsyncFib g = new AsyncFib(9);\r\n    assertSame(g, g.fork());\r\n    AsyncFib f = new AsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, peekNextLocalTask());\r\n    assertNull(f.join());\r\n    helpQuiesce();\r\n    f.checkCompletedNormally();\r\n    g.checkCompletedNormally();\r\n}"
}, {
	"Path": "sun.security.util.DerInputStream.subStream",
	"Comment": "creates a new der input stream from part of this input stream.",
	"Method": "DerInputStream subStream(int len,boolean do_skip){\r\n    DerInputBuffer newbuf = buffer.dup();\r\n    newbuf.truncate(len);\r\n    if (do_skip) {\r\n        buffer.skip(len);\r\n    }\r\n    return new DerInputStream(newbuf);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.assertHasWaitersUnlocked",
	"Comment": "checks that condition c has exactly the given waiter threads,after acquiring mutex.",
	"Method": "void assertHasWaitersUnlocked(Mutex sync,ConditionObject c,Thread threads){\r\n    sync.acquire();\r\n    assertHasWaitersLocked(sync, c, threads);\r\n    sync.release();\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testGetRejectedExecutionHandler",
	"Comment": "getrejectedexecutionhandler returns handler in constructor if not set",
	"Method": "void testGetRejectedExecutionHandler(){\r\n    final RejectedExecutionHandler handler = new NoOpREHandler();\r\n    final ThreadPoolExecutor p = new CustomTPE(1, 2, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10), handler);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertSame(handler, p.getRejectedExecutionHandler());\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.Handler.getLevel",
	"Comment": "get the log level specifying which messages will belogged by this handler.message levels lowerthan this level will be discarded.",
	"Method": "Level getLevel(){\r\n    return logLevel;\r\n}"
}, {
	"Path": "java.time.Instant.plusNanos",
	"Comment": "returns a copy of this instant with the specified duration in nanoseconds added.this instance is immutable and unaffected by this method call.",
	"Method": "Instant plusNanos(long nanosToAdd){\r\n    return plus(0, nanosToAdd);\r\n}"
}, {
	"Path": "java.util.EnumMap.containsValue",
	"Comment": "returns true if this map maps one or more keys to thespecified value.",
	"Method": "boolean containsValue(Object value){\r\n    value = maskNull(value);\r\n    for (Object val : vals) if (value.equals(val))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.xmlpull.v1.XmlPullParserFactory.newPullParser",
	"Comment": "creates a new instance of a xml pull parserusing the currently configured factory features.",
	"Method": "XmlPullParser newPullParser(){\r\n    final XmlPullParser pp = getParserInstance();\r\n    for (Map.Entry<String, Boolean> entry : features.entrySet()) {\r\n        if (entry.getValue()) {\r\n            pp.setFeature(entry.getKey(), entry.getValue());\r\n        }\r\n    }\r\n    return pp;\r\n}"
}, {
	"Path": "java.net.HttpCookie.header",
	"Comment": "returns the original header this cookie was consructed from, if it wasconstructed by parsing a header, otherwise null.",
	"Method": "String header(){\r\n    return header;\r\n}"
}, {
	"Path": "sun.security.x509.CertificatePolicyId.toString",
	"Comment": "returns a printable representation of the certificatepolicyid.",
	"Method": "String toString(){\r\n    String s = \"CertificatePolicyId: [\" + id.toString() + \"]\\n\";\r\n    return (s);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.MetadataWriterTest.testNSTypesNotInMetadata",
	"Comment": "verify that the stub ns types, such as nsfastenumeration, are not included in metadata.",
	"Method": "void testNSTypesNotInMetadata(){\r\n    String translation = translateSourceFile(\"interface Test<T> extends com.google.j2objc.NSFastEnumeration {}\", \"Test\", \"Test.m\");\r\n    assertNotInTranslation(translation, \"NSFastEnumeration\");\r\n}"
}, {
	"Path": "java.util.jar.Attributes.write",
	"Comment": "writes the current attributes to the specified data output stream.xxx need to handle utf8 values and break up lines longer than 72 bytes",
	"Method": "void write(DataOutputStream os){\r\n    Iterator it = entrySet().iterator();\r\n    while (it.hasNext()) {\r\n        Map.Entry e = (Map.Entry) it.next();\r\n        StringBuffer buffer = new StringBuffer(((Name) e.getKey()).toString());\r\n        buffer.append(\": \");\r\n        String value = (String) e.getValue();\r\n        if (value != null) {\r\n            byte[] vb = value.getBytes(\"UTF8\");\r\n            value = new String(vb, 0, 0, vb.length);\r\n        }\r\n        buffer.append(value);\r\n        buffer.append(\"\\r\\n\");\r\n        Manifest.make72Safe(buffer);\r\n        os.writeBytes(buffer.toString());\r\n    }\r\n    os.writeBytes(\"\\r\\n\");\r\n}"
}, {
	"Path": "jsr166.ConcurrentLinkedDequeTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        q.addAll(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.security.Signature.getInstance",
	"Comment": "returns a signature object that implements the specifiedsignature algorithm. a new signature object encapsulating thesignaturespi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "Signature getInstance(String algorithm,Signature getInstance,Instance instance,String algorithm,Signature getInstance,String algorithm,String provider,Signature getInstance,String algorithm,Provider provider){\r\n    if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {\r\n        if (provider == null) {\r\n            throw new IllegalArgumentException(\"missing provider\");\r\n        }\r\n        return getInstanceRSA(provider);\r\n    }\r\n    Instance instance = GetInstance.getInstance(\"Signature\", SignatureSpi.class, algorithm, provider);\r\n    return getInstance(instance, algorithm);\r\n}"
}, {
	"Path": "java.util.EnumMap.typeCheck",
	"Comment": "throws an exception if e is not of the correct type for this enum set.",
	"Method": "void typeCheck(K key){\r\n    Class keyClass = key.getClass();\r\n    if (keyClass != keyType && keyClass.getSuperclass() != keyType)\r\n        throw new ClassCastException(keyClass + \" != \" + keyType);\r\n}"
}, {
	"Path": "jsr166.LinkedListTest.testConstructor6",
	"Comment": "queue contains all elements of collection used to initialize",
	"Method": "void testConstructor6(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = i;\r\n    LinkedList q = new LinkedList(Arrays.asList(ints));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "java.util.logging.Logger.getPlatformLogger",
	"Comment": "i.e. caller of sun.util.logging.platformlogger.getlogger",
	"Method": "Logger getPlatformLogger(String name){\r\n    LogManager manager = LogManager.getLogManager();\r\n    Logger result = manager.demandSystemLogger(name, SYSTEM_LOGGER_RB_NAME);\r\n    return result;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceValuesToDouble",
	"Comment": "returns the result of accumulating the given transformationof all values using the given reducer to combine values,and the given basis as an identity value.",
	"Method": "double reduceValuesToDouble(long parallelismThreshold,ToDoubleFunction<? super V> transformer,double basis,DoubleBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceValuesToDoubleTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "java.net.URI.isAbsolute",
	"Comment": "tells whether or not this uri is absolute. a uri is absolute if, and only if, it has a scheme component.",
	"Method": "boolean isAbsolute(){\r\n    return scheme != null;\r\n}"
}, {
	"Path": "java.time.YearMonth.lengthOfMonth",
	"Comment": "returns the length of the month, taking account of the year.this returns the length of the month in days.for example, a date in january would return 31.",
	"Method": "int lengthOfMonth(){\r\n    return getMonth().length(isLeapYear());\r\n}"
}, {
	"Path": "jsr166.AtomicLongArrayTest.testIndexing",
	"Comment": "get and set for out of bound indices throw indexoutofboundsexception",
	"Method": "void testIndexing(){\r\n    AtomicLongArray aa = new AtomicLongArray(SIZE);\r\n    for (int index : new int[] { -1, SIZE }) {\r\n        try {\r\n            aa.get(index);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.set(index, 1);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.lazySet(index, 1);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.compareAndSet(index, 1, 2);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.weakCompareAndSet(index, 1, 2);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.getAndAdd(index, 1);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n        try {\r\n            aa.addAndGet(index, 1);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.mulsubLong",
	"Comment": "this method is used for division by long.specialized version of the method sulsub.dh is a high part of the divisor, dl is a low part",
	"Method": "int mulsubLong(int[] q,int dh,int dl,int x,int offset){\r\n    long xLong = x & LONG_MASK;\r\n    offset += 2;\r\n    long product = (dl & LONG_MASK) * xLong;\r\n    long difference = q[offset] - product;\r\n    q[offset--] = (int) difference;\r\n    long carry = (product >>> 32) + (((difference & LONG_MASK) > (((~(int) product) & LONG_MASK))) ? 1 : 0);\r\n    product = (dh & LONG_MASK) * xLong + carry;\r\n    difference = q[offset] - product;\r\n    q[offset--] = (int) difference;\r\n    carry = (product >>> 32) + (((difference & LONG_MASK) > (((~(int) product) & LONG_MASK))) ? 1 : 0);\r\n    return (int) carry;\r\n}"
}, {
	"Path": "jsr166.ConcurrentLinkedDequeTest.testAddAll5",
	"Comment": "deque contains all elements, in traversal order, of successful addall",
	"Method": "void testAddAll5(){\r\n    Integer[] empty = new Integer[0];\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = new Integer(i);\r\n    ConcurrentLinkedDeque q = new ConcurrentLinkedDeque();\r\n    assertFalse(q.addAll(Arrays.asList(empty)));\r\n    assertTrue(q.addAll(Arrays.asList(ints)));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "javax.crypto.spec.RC5ParameterSpec.getIV",
	"Comment": "returns the iv or null if this parameter set does not contain an iv.",
	"Method": "byte[] getIV(){\r\n    return (iv == null ? null : (byte[]) iv.clone());\r\n}"
}, {
	"Path": "jsr166.ConcurrentHashMapTest.testKeys",
	"Comment": "keys returns an enumeration containing all the keys from the map",
	"Method": "void testKeys(){\r\n    ConcurrentHashMap map = map5();\r\n    Enumeration e = map.keys();\r\n    int count = 0;\r\n    while (e.hasMoreElements()) {\r\n        count++;\r\n        e.nextElement();\r\n    }\r\n    assertEquals(5, count);\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater",
	"Comment": "creates and returns an updater for objects with the given field.the class arguments are needed to check that reflective types andgeneric types match.",
	"Method": "AtomicReferenceFieldUpdater<U, W> newUpdater(Class<U> tclass,Class<W> vclass,String fieldName){\r\n    return new AtomicReferenceFieldUpdaterImpl<U, W>(tclass, vclass, fieldName, null);\r\n}"
}, {
	"Path": "jsr166.BlockingQueueTest.makeElement",
	"Comment": "returns an element suitable for insertion in the collection.override for collections with unusual element types.",
	"Method": "Object makeElement(int i){\r\n    return Integer.valueOf(i);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.populatedSet",
	"Comment": "returns a new set of given size containing consecutiveintegers 0 ... n.",
	"Method": "ConcurrentSkipListSet<Integer> populatedSet(int n){\r\n    ConcurrentSkipListSet<Integer> q = new ConcurrentSkipListSet<Integer>();\r\n    assertTrue(q.isEmpty());\r\n    for (int i = n - 1; i >= 0; i -= 2) assertTrue(q.add(new Integer(i)));\r\n    for (int i = (n & 1); i < n; i += 2) assertTrue(q.add(new Integer(i)));\r\n    assertFalse(q.isEmpty());\r\n    assertEquals(n, q.size());\r\n    return q;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase16",
	"Comment": "subtract two negative numbers of different length.the second is longer.",
	"Method": "void testCase16(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    int aSign = -1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 1, 2, 3, 3, -6, -15, -24, -40, -49, -58, -67, -6, -15, -23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase14",
	"Comment": "subtract two numbers of the same length and different signs.the first is negative.the second is longer.",
	"Method": "void testCase14(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -2, -3, -4, -5, -16, -27, -38, -42, -53, -64, -75, -16, -27, -37 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase15",
	"Comment": "subtract two negative numbers of different length.the first is longer.",
	"Method": "void testCase15(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { -2, -3, -4, -4, 5, 14, 23, 39, 48, 57, 66, 5, 14, 23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase12",
	"Comment": "subtract two numbers of the same length and different signs.the first is positive.the second is greater in absolute value.",
	"Method": "void testCase12(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 1, 2, 3, 4, 15, 26, 37, 41, 52, 63, 74, 15, 26, 37 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase13",
	"Comment": "subtract two numbers of different length and different signs.the first is negative.the first is longer.",
	"Method": "void testCase13(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -2, -3, -4, -5, -16, -27, -38, -42, -53, -64, -75, -16, -27, -37 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "java.time.Period.withDays",
	"Comment": "returns a copy of this period with the specified amount of days.this sets the amount of the days unit in a copy of this period.the years and months units are unaffected.this instance is immutable and unaffected by this method call.",
	"Method": "Period withDays(int days){\r\n    if (days == this.days) {\r\n        return this;\r\n    }\r\n    return create(years, months, days);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase10",
	"Comment": "subtract two positive numbers of different length.the second is longer.",
	"Method": "void testCase10(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -2, -3, -4, -4, 5, 14, 23, 39, 48, 57, 66, 5, 14, 23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(-1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerSubtractTest.testCase11",
	"Comment": "subtract two numbers of different length and different signs.the first is positive.the first is greater in absolute value.",
	"Method": "void testCase11(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 1, 2, 3, 4, 15, 26, 37, 41, 52, 63, 74, 15, 26, 37 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.subtract(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(1, result.signum());\r\n}"
}, {
	"Path": "java.beans.Introspector.loadBeanInfo",
	"Comment": "method which attempts to instantiate a beaninfo object of the suppliedclassname",
	"Method": "BeanInfo loadBeanInfo(String beanInfoClassName,Class<?> beanClass){\r\n    try {\r\n        ClassLoader cl = beanClass.getClassLoader();\r\n        if (cl != null) {\r\n            return (BeanInfo) Class.forName(beanInfoClassName, true, beanClass.getClassLoader()).newInstance();\r\n        }\r\n    } catch (Exception e) {\r\n    }\r\n    try {\r\n        return (BeanInfo) Class.forName(beanInfoClassName, true, ClassLoader.getSystemClassLoader()).newInstance();\r\n    } catch (Exception e) {\r\n    }\r\n    return (BeanInfo) Class.forName(beanInfoClassName, true, Thread.currentThread().getContextClassLoader()).newInstance();\r\n}"
}, {
	"Path": "java.util.function.IntPredicate.negate",
	"Comment": "returns a predicate that represents the logical negation of thispredicate.",
	"Method": "IntPredicate negate(){\r\n    return (value) -> !test(value);\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testGetCorePoolSize",
	"Comment": "getcorepoolsize returns size given in constructor if not otherwise set",
	"Method": "void testGetCorePoolSize(){\r\n    final CustomExecutor p = new CustomExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertEquals(1, p.getCorePoolSize());\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.DeflaterInputStream.read",
	"Comment": "reads compressed data into a byte array.this method will block until some input can be read and compressed.",
	"Method": "int read(int read,byte[] b,int off,int len){\r\n    ensureOpen();\r\n    if (b == null) {\r\n        throw new NullPointerException(\"Null buffer for read\");\r\n    } else if (off < 0 || len < 0 || len > b.length - off) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (len == 0) {\r\n        return 0;\r\n    }\r\n    int cnt = 0;\r\n    while (len > 0 && !def.finished()) {\r\n        int n;\r\n        if (def.needsInput()) {\r\n            n = in.read(buf, 0, buf.length);\r\n            if (n < 0) {\r\n                def.finish();\r\n            } else if (n > 0) {\r\n                def.setInput(buf, 0, n);\r\n            }\r\n        }\r\n        n = def.deflate(b, off, len);\r\n        cnt += n;\r\n        off += n;\r\n        len -= n;\r\n    }\r\n    if (def.finished()) {\r\n        reachEOF = true;\r\n        if (cnt == 0) {\r\n            cnt = -1;\r\n        }\r\n    }\r\n    return cnt;\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    final AtomicInteger ai = new AtomicInteger(1);\r\n    Thread t = new Thread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!ai.compareAndSet(2, 3)) Thread.yield();\r\n        }\r\n    });\r\n    t.start();\r\n    assertTrue(ai.compareAndSet(1, 2));\r\n    t.join(LONG_DELAY_MS);\r\n    assertFalse(t.isAlive());\r\n    assertEquals(3, ai.get());\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    while (!ai.compareAndSet(2, 3)) Thread.yield();\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerArrayTest.testCountingInMultipleThreads",
	"Comment": "multiple threads using same array of counters successfullyupdate a number of times equal to total count",
	"Method": "void testCountingInMultipleThreads(){\r\n    final AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);\r\n    int countdown = 10000;\r\n    for (int i = 0; i < SIZE; i++) aa.set(i, countdown);\r\n    Counter c1 = new Counter(aa);\r\n    Counter c2 = new Counter(aa);\r\n    Thread t1 = new Thread(c1);\r\n    Thread t2 = new Thread(c2);\r\n    t1.start();\r\n    t2.start();\r\n    t1.join();\r\n    t2.join();\r\n    assertEquals(c1.counts + c2.counts, SIZE * countdown);\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.getTBSCertificate",
	"Comment": "gets the der encoded certificate informations, thetbscertificate from this certificate.this can be used to verify the signature independently.",
	"Method": "byte[] getTBSCertificate(){\r\n    if (info != null) {\r\n        return info.getEncodedInfo();\r\n    } else\r\n        throw new CertificateEncodingException(\"Uninitialized certificate\");\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testConstructor3",
	"Comment": "the parent provided to the constructor should be returned froma later call to getparent",
	"Method": "void testConstructor3(){\r\n    Phaser parent = new Phaser();\r\n    assertSame(parent, new Phaser(parent).getParent());\r\n    assertNull(new Phaser(null).getParent());\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testConstructor5",
	"Comment": "the parent being input into the parameter should equal the originalparent when being returned",
	"Method": "void testConstructor5(){\r\n    Phaser parent = new Phaser();\r\n    assertSame(parent, new Phaser(parent, 0).getParent());\r\n    assertNull(new Phaser(null, 0).getParent());\r\n}"
}, {
	"Path": "java.util.stream.LongStream.of",
	"Comment": "returns a sequential ordered stream whose elements are the specified values.",
	"Method": "LongStream of(long t,LongStream of,long values){\r\n    return Arrays.stream(values);\r\n}"
}, {
	"Path": "com.google.j2objc.net.IosHttpURLConnection.getHeaderField",
	"Comment": "returns the value of the named header field.if called on a connection that sets the same header multiple times withpossibly different values, only the last value is returned.",
	"Method": "String getHeaderField(int pos,String getHeaderField,String key){\r\n    try {\r\n        getResponse();\r\n        return getHeaderFieldDoNotForceResponse(key);\r\n    } catch (IOException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.util.Properties.setProperty",
	"Comment": "calls the hashtable method put. provided forparallelism with the getproperty method. enforces use ofstrings for property keys and values. the value returned is theresult of the hashtable call to put.",
	"Method": "Object setProperty(String key,String value){\r\n    return put(key, value);\r\n}"
}, {
	"Path": "java.text.DecimalFormat.getDecimalFormatSymbols",
	"Comment": "returns a copy of the decimal format symbols, which is generally notchanged by the programmer or user.",
	"Method": "DecimalFormatSymbols getDecimalFormatSymbols(){\r\n    try {\r\n        return (DecimalFormatSymbols) symbols.clone();\r\n    } catch (Exception foo) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.SunCertPathBuilderException.getAdjacencyList",
	"Comment": "returns the adjacency list containing information about the build.",
	"Method": "AdjacencyList getAdjacencyList(){\r\n    return adjList;\r\n}"
}, {
	"Path": "java.time.Duration.plusMillis",
	"Comment": "returns a copy of this duration with the specified duration in milliseconds added.this instance is immutable and unaffected by this method call.",
	"Method": "Duration plusMillis(long millisToAdd){\r\n    return plus(millisToAdd / 1000, (millisToAdd % 1000) * 1000_000);\r\n}"
}, {
	"Path": "sun.misc.Unsafe.getUnsafe",
	"Comment": "gets the unique instance of this class. this is only allowed invery limited situations.",
	"Method": "Unsafe getUnsafe(){\r\n    return THE_ONE;\r\n}"
}, {
	"Path": "java.net.URLConnection.setAllowUserInteraction",
	"Comment": "set the value of the allowuserinteraction field ofthis urlconnection.",
	"Method": "void setAllowUserInteraction(boolean allowuserinteraction){\r\n    if (connected)\r\n        throw new IllegalStateException(\"Already connected\");\r\n    allowUserInteraction = allowuserinteraction;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.AbstractRegressionTest.className",
	"Comment": "takes a .java file name and possibly path and returns the name of the represented class.",
	"Method": "String className(String path){\r\n    int pathIndex = path.lastIndexOf('/');\r\n    int extensionIndex = path.lastIndexOf('.');\r\n    return path.substring(Math.max(0, pathIndex), extensionIndex);\r\n}"
}, {
	"Path": "java.util.zip.ZipInputStream.closeEntry",
	"Comment": "closes the current zip entry and positions the stream for reading thenext entry.",
	"Method": "void closeEntry(){\r\n    ensureOpen();\r\n    while (read(tmpbuf, 0, tmpbuf.length) != -1) ;\r\n    entryEOF = true;\r\n}"
}, {
	"Path": "java.util.logging.Formatter.getHead",
	"Comment": "return the header string for a set of formatted records.this base class returns an empty string, but this may beoverridden by subclasses.",
	"Method": "String getHead(Handler h){\r\n    return \"\";\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testPollTaskAsync",
	"Comment": "polltask returns an unexecuted task without executing it, inasync mode",
	"Method": "void testPollTaskAsync(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FibAction g = new FibAction(9);\r\n            assertSame(g, g.fork());\r\n            FibAction f = new FibAction(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, pollTask());\r\n            helpQuiesce();\r\n            checkCompletedNormally(f);\r\n            checkNotDone(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(asyncSingletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testPollTaskAsync",
	"Comment": "polltask returns an unexecuted task without executing it, inasync mode",
	"Method": "void testPollTaskAsync(){\r\n    FibAction g = new FibAction(9);\r\n    assertSame(g, g.fork());\r\n    FibAction f = new FibAction(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, pollTask());\r\n    helpQuiesce();\r\n    checkCompletedNormally(f);\r\n    checkNotDone(g);\r\n}"
}, {
	"Path": "java.lang.ClassLoader.defineClass",
	"Comment": "converts an array of bytes into an instance of class class.before the class can be used it must be resolved.this methodis deprecated in favor of the version that takes a binary name as its first argument, and is more secure.",
	"Method": "Class<?> defineClass(byte[] b,int off,int len,Class<?> defineClass,String name,byte[] b,int off,int len,Class<?> defineClass,String name,byte[] b,int off,int len,ProtectionDomain protectionDomain,Class<?> defineClass,String name,java.nio.ByteBuffer b,ProtectionDomain protectionDomain){\r\n    throw new UnsupportedOperationException(\"can't load this type of class file\");\r\n}"
}, {
	"Path": "java.math.BigInteger.multiply",
	"Comment": "package private methods used by bigdecimal code to multiply a bigintegerwith a long. assumes v is not equal to inflated.",
	"Method": "BigInteger multiply(BigInteger val,BigInteger multiply,long v){\r\n    if (v == 0 || signum == 0)\r\n        return ZERO;\r\n    if (v == BigDecimal.INFLATED)\r\n        return multiply(BigInteger.valueOf(v));\r\n    int rsign = (v > 0 ? signum : -signum);\r\n    if (v < 0)\r\n        v = -v;\r\n    long dh = v >>> 32;\r\n    long dl = v & LONG_MASK;\r\n    int xlen = mag.length;\r\n    int[] value = mag;\r\n    int[] rmag = (dh == 0L) ? (new int[xlen + 1]) : (new int[xlen + 2]);\r\n    long carry = 0;\r\n    int rstart = rmag.length - 1;\r\n    for (int i = xlen - 1; i >= 0; i--) {\r\n        long product = (value[i] & LONG_MASK) * dl + carry;\r\n        rmag[rstart--] = (int) product;\r\n        carry = product >>> 32;\r\n    }\r\n    rmag[rstart] = (int) carry;\r\n    if (dh != 0L) {\r\n        carry = 0;\r\n        rstart = rmag.length - 2;\r\n        for (int i = xlen - 1; i >= 0; i--) {\r\n            long product = (value[i] & LONG_MASK) * dh + (rmag[rstart] & LONG_MASK) + carry;\r\n            rmag[rstart--] = (int) product;\r\n            carry = product >>> 32;\r\n        }\r\n        rmag[0] = (int) carry;\r\n    }\r\n    if (carry == 0L)\r\n        rmag = java.util.Arrays.copyOfRange(rmag, 1, rmag.length);\r\n    return new BigInteger(rmag, rsign);\r\n}"
}, {
	"Path": "java.security.cert.PolicyQualifierInfo.toString",
	"Comment": "return a printable representation of thispolicyqualifierinfo.",
	"Method": "String toString(){\r\n    if (pqiString != null)\r\n        return pqiString;\r\n    HexDumpEncoder enc = new HexDumpEncoder();\r\n    StringBuffer sb = new StringBuffer();\r\n    sb.append(\"PolicyQualifierInfo: [\\n\");\r\n    sb.append(\"  qualifierID: \" + mId + \"\\n\");\r\n    sb.append(\"  qualifier: \" + (mData == null ? \"null\" : enc.encodeBuffer(mData)) + \"\\n\");\r\n    sb.append(\"]\");\r\n    pqiString = sb.toString();\r\n    return pqiString;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.DestructorGeneratorTest.testFieldReleaseReferenceCounting",
	"Comment": "verify fields are released in a dealloc for reference counted code.",
	"Method": "void testFieldReleaseReferenceCounting(){\r\n    options.setMemoryManagementOption(Options.MemoryManagementOption.REFERENCE_COUNTING);\r\n    String translation = translateSourceFile(\"class Test { Object o; Runnable r; }\", \"Test\", \"Test.m\");\r\n    assertTranslatedLines(translation, \"- (void)dealloc {\", \"RELEASE_(o_);\", \"RELEASE_(r_);\", \"[super dealloc];\", \"}\");\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.util.DateTest.tearDown",
	"Comment": "tears down the fixture, for example, close a network connection. thismethod is called after a test is executed.",
	"Method": "void tearDown(){\r\n    TimeZone.setDefault(defaultTimeZone);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.InitializationNormalizerTest.testNullInitializationIsStripped",
	"Comment": "initialize method, since static variables are always zeroed in c.",
	"Method": "void testNullInitializationIsStripped(){\r\n    String translation = translateSourceFile(\"class test { private static Object CLASS_LOCK = null; }\", \"Test\", \"Test.m\");\r\n    assertNotInTranslation(translation, \"static id test_CLASS_LOCK = nil;\");\r\n    assertNotInTranslation(translation, \"JreStrongAssign(&test_CLASS_LOCK, nil);\");\r\n}"
}, {
	"Path": "sun.security.x509.SubjectKeyIdentifierExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(KEY_ID);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "jsr166.TreeSetTest.testConstructor5",
	"Comment": "initializing from collection with some null elements throws npe",
	"Method": "void testConstructor5(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        new TreeSet(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.io.ByteArrayInputStream.reset",
	"Comment": "resets the buffer to the marked position.the marked positionis 0 unless another position was marked or an offset was specifiedin the constructor.",
	"Method": "void reset(){\r\n    pos = mark;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberRegressionTests.Test4141750",
	"Comment": "bigdecimal numbers get their fractions truncated by numberformat.",
	"Method": "void Test4141750(){\r\n    try {\r\n        String str = \"12345.67\";\r\n        java.math.BigDecimal bd = new java.math.BigDecimal(str);\r\n        String sd = NumberFormat.getInstance(Locale.US).format(bd);\r\n        if (!sd.endsWith(\"67\"))\r\n            errln(\"Fail: \" + str + \" x format -> \" + sd);\r\n    } catch (Exception e) {\r\n        warnln(e.toString());\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.StatementGeneratorTest.testTryMultiResourcesNoCatchOrFinally",
	"Comment": "verify that multiple resources are closed in reverse order from opening.",
	"Method": "void testTryMultiResourcesNoCatchOrFinally(){\r\n    String translation = translateSourceFile(\"import java.io.*; public class Test { \" + \"static class Resource implements AutoCloseable { \" + \"  public void close() throws Exception {}} \" + \"void test() throws Exception { \" + \"  try (Resource r1 = new Resource();\" + \"       Resource r2 = new Resource();\" + \"       Resource r3 = new Resource()) {\" + \"  }}}\", \"Test\", \"Test.m\");\r\n    assertTranslatedSegments(translation, \"Test_Resource *r1\", \"Test_Resource *r2\", \"Test_Resource *r3\");\r\n    assertTranslatedSegments(translation, \"[r3 close]\", \"[r2 close]\", \"[r1 close]\");\r\n}"
}, {
	"Path": "jsr166.AtomicLongFieldUpdaterTest.testWeakCompareAndSet",
	"Comment": "repeated weakcompareandset succeeds in changing value when equalto expected",
	"Method": "void testWeakCompareAndSet(){\r\n    AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;\r\n    a = updaterFor(\"x\");\r\n    x = 1;\r\n    do {\r\n    } while (!a.weakCompareAndSet(this, 1, 2));\r\n    do {\r\n    } while (!a.weakCompareAndSet(this, 2, -4));\r\n    assertEquals(-4, a.get(this));\r\n    do {\r\n    } while (!a.weakCompareAndSet(this, -4, 7));\r\n    assertEquals(7, a.get(this));\r\n}"
}, {
	"Path": "sun.security.x509.X509CRLImpl.toImpl",
	"Comment": "utility method to convert an arbitrary instance of x509crlto a x509crlimpl. does a cast if possible, otherwise reparsesthe encoding.",
	"Method": "X509CRLImpl toImpl(X509CRL crl){\r\n    if (crl instanceof X509CRLImpl) {\r\n        return (X509CRLImpl) crl;\r\n    } else {\r\n        return X509Factory.intern(crl);\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.format.TimeZoneFormatTest.TestTimeZoneRoundTrip",
	"Comment": "test case for checking if a timezone is properly set in the result calendarand if the result timezone has the expected behavior.",
	"Method": "void TestTimeZoneRoundTrip(){\r\n    boolean TEST_ALL = getBooleanProperty(\"TimeZoneRoundTripAll\", false);\r\n    TimeZone unknownZone = new SimpleTimeZone(-31415, \"Etc/Unknown\");\r\n    int badDstOffset = -1234;\r\n    int badZoneOffset = -2345;\r\n    int[][] testDateData = { { 2007, 1, 15 }, { 2007, 6, 15 }, { 1990, 1, 15 }, { 1990, 6, 15 }, { 1960, 1, 15 }, { 1960, 6, 15 } };\r\n    Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\r\n    cal.clear();\r\n    long low, high;\r\n    cal.set(1900, 0, 1);\r\n    low = cal.getTimeInMillis();\r\n    cal.set(2040, 0, 1);\r\n    high = cal.getTimeInMillis();\r\n    Date[] DATES = new Date[testDateData.length];\r\n    cal.clear();\r\n    for (int i = 0; i < DATES.length; i++) {\r\n        cal.set(testDateData[i][0], testDateData[i][1], testDateData[i][2]);\r\n        DATES[i] = cal.getTime();\r\n    }\r\n    ULocale[] LOCALES = null;\r\n    if (TEST_ALL || TestFmwk.getExhaustiveness() > 5) {\r\n        LOCALES = ULocale.getAvailableLocales();\r\n    } else {\r\n        LOCALES = new ULocale[] { new ULocale(\"en\"), new ULocale(\"en_CA\"), new ULocale(\"fr\"), new ULocale(\"zh_Hant\") };\r\n    }\r\n    String[] tzids;\r\n    if (JDKTZ) {\r\n        tzids = java.util.TimeZone.getAvailableIDs();\r\n    } else {\r\n        tzids = TimeZone.getAvailableIDs();\r\n    }\r\n    int[] inOffsets = new int[2];\r\n    int[] outOffsets = new int[2];\r\n    for (int locidx = 0; locidx < LOCALES.length; locidx++) {\r\n        logln(\"Locale: \" + LOCALES[locidx].toString());\r\n        String localGMTString = TimeZoneFormat.getInstance(LOCALES[locidx]).formatOffsetLocalizedGMT(0);\r\n        for (int patidx = 0; patidx < PATTERNS.length; patidx++) {\r\n            logln(\"    pattern: \" + PATTERNS[patidx]);\r\n            SimpleDateFormat sdf = new SimpleDateFormat(PATTERNS[patidx], LOCALES[locidx]);\r\n            for (int tzidx = 0; tzidx < tzids.length; tzidx++) {\r\n                if (EXCL_TZ_PATTERN.matcher(tzids[tzidx]).matches()) {\r\n                    continue;\r\n                }\r\n                TimeZone tz = TimeZone.getTimeZone(tzids[tzidx]);\r\n                for (int datidx = 0; datidx < DATES.length; datidx++) {\r\n                    sdf.setTimeZone(tz);\r\n                    String tzstr = sdf.format(DATES[datidx]);\r\n                    sdf.setTimeZone(unknownZone);\r\n                    ParsePosition pos = new ParsePosition(0);\r\n                    Calendar outcal = Calendar.getInstance(unknownZone);\r\n                    outcal.set(Calendar.DST_OFFSET, badDstOffset);\r\n                    outcal.set(Calendar.ZONE_OFFSET, badZoneOffset);\r\n                    sdf.parse(tzstr, outcal, pos);\r\n                    TimeZone outtz = outcal.getTimeZone();\r\n                    tz.getOffset(DATES[datidx].getTime(), false, inOffsets);\r\n                    outtz.getOffset(DATES[datidx].getTime(), false, outOffsets);\r\n                    if (PATTERNS[patidx].equals(\"V\")) {\r\n                        String canonicalID = TimeZone.getCanonicalID(tzids[tzidx]);\r\n                        if (!outtz.getID().equals(canonicalID)) {\r\n                            if (outtz.getID().equals(\"Etc/Unknown\")) {\r\n                                if (REALLY_VERBOSE_LOG) {\r\n                                    logln(\"Canonical round trip failed (probably as expected); tz=\" + tzids[tzidx] + \", locale=\" + LOCALES[locidx] + \", pattern=\" + PATTERNS[patidx] + \", time=\" + DATES[datidx].getTime() + \", str=\" + tzstr + \", outtz=\" + outtz.getID());\r\n                                }\r\n                            } else {\r\n                                errln(\"Canonical round trip failed; tz=\" + tzids[tzidx] + \", locale=\" + LOCALES[locidx] + \", pattern=\" + PATTERNS[patidx] + \", time=\" + DATES[datidx].getTime() + \", str=\" + tzstr + \", outtz=\" + outtz.getID());\r\n                            }\r\n                        }\r\n                    } else if (PATTERNS[patidx].equals(\"VV\")) {\r\n                        if (!outtz.getID().equals(tzids[tzidx])) {\r\n                            errln(\"Zone ID round trip failed; tz=\" + tzids[tzidx] + \", locale=\" + LOCALES[locidx] + \", pattern=\" + PATTERNS[patidx] + \", time=\" + DATES[datidx].getTime() + \", str=\" + tzstr + \", outtz=\" + outtz.getID());\r\n                        }\r\n                    } else if (PATTERNS[patidx].equals(\"VVV\") || PATTERNS[patidx].equals(\"VVVV\")) {\r\n                        String canonicalID = TimeZone.getCanonicalID(tzids[tzidx]);\r\n                        if (canonicalID != null && !outtz.getID().equals(canonicalID)) {\r\n                            boolean bFailure = false;\r\n                            if ((tz instanceof BasicTimeZone) && (outtz instanceof BasicTimeZone)) {\r\n                                boolean hasNoLocation = TimeZone.getRegion(tzids[tzidx]).equals(\"001\");\r\n                                bFailure = !hasNoLocation && !((BasicTimeZone) outtz).hasEquivalentTransitions(tz, low, high);\r\n                            }\r\n                            if (bFailure) {\r\n                                errln(\"Canonical round trip failed; tz=\" + tzids[tzidx] + \", locale=\" + LOCALES[locidx] + \", pattern=\" + PATTERNS[patidx] + \", time=\" + DATES[datidx].getTime() + \", str=\" + tzstr + \", outtz=\" + outtz.getID());\r\n                            } else if (REALLY_VERBOSE_LOG) {\r\n                                logln(\"Canonical round trip failed (as expected); tz=\" + tzids[tzidx] + \", locale=\" + LOCALES[locidx] + \", pattern=\" + PATTERNS[patidx] + \", time=\" + DATES[datidx].getTime() + \", str=\" + tzstr + \", outtz=\" + outtz.getID());\r\n                            }\r\n                        }\r\n                    } else {\r\n                        boolean isOffsetFormat = (PATTERNS[patidx].charAt(0) == 'Z' || PATTERNS[patidx].charAt(0) == 'O' || PATTERNS[patidx].charAt(0) == 'X' || PATTERNS[patidx].charAt(0) == 'x');\r\n                        boolean minutesOffset = false;\r\n                        if (PATTERNS[patidx].charAt(0) == 'X' || PATTERNS[patidx].charAt(0) == 'x') {\r\n                            minutesOffset = PATTERNS[patidx].length() <= 3;\r\n                        }\r\n                        if (!isOffsetFormat) {\r\n                            int numDigits = 0;\r\n                            for (int n = 0; n < tzstr.length(); n++) {\r\n                                if (UCharacter.isDigit(tzstr.charAt(n))) {\r\n                                    numDigits++;\r\n                                }\r\n                            }\r\n                            isOffsetFormat = (numDigits > 0);\r\n                        }\r\n                        if (isOffsetFormat || tzstr.equals(localGMTString)) {\r\n                            int inOffset = inOffsets[0] + inOffsets[1];\r\n                            int outOffset = outOffsets[0] + outOffsets[1];\r\n                            int diff = outOffset - inOffset;\r\n                            if (minutesOffset) {\r\n                                diff = (diff / 60000) * 60000;\r\n                            }\r\n                            if (diff != 0) {\r\n                                errln(\"Offset round trip failed; tz=\" + tzids[tzidx] + \", locale=\" + LOCALES[locidx] + \", pattern=\" + PATTERNS[patidx] + \", time=\" + DATES[datidx].getTime() + \", str=\" + tzstr + \", inOffset=\" + inOffset + \", outOffset=\" + outOffset);\r\n                            }\r\n                        } else {\r\n                            if (inOffsets[0] != outOffsets[0]) {\r\n                                if (JDKTZ && tzids[tzidx].startsWith(\"SystemV/\")) {\r\n                                    if (REALLY_VERBOSE_LOG) {\r\n                                        logln(\"Raw offset round trip failed; tz=\" + tzids[tzidx] + \", locale=\" + LOCALES[locidx] + \", pattern=\" + PATTERNS[patidx] + \", time=\" + DATES[datidx].getTime() + \", str=\" + tzstr + \", inRawOffset=\" + inOffsets[0] + \", outRawOffset=\" + outOffsets[0]);\r\n                                    }\r\n                                } else {\r\n                                    errln(\"Raw offset round trip failed; tz=\" + tzids[tzidx] + \", locale=\" + LOCALES[locidx] + \", pattern=\" + PATTERNS[patidx] + \", time=\" + DATES[datidx].getTime() + \", str=\" + tzstr + \", inRawOffset=\" + inOffsets[0] + \", outRawOffset=\" + outOffsets[0]);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadLocalRandomTest.testNextFloat",
	"Comment": "repeated calls to nextfloat produce at least two distinct results",
	"Method": "void testNextFloat(){\r\n    float f = ThreadLocalRandom.current().nextFloat();\r\n    int i = 0;\r\n    while (i < NCALLS && ThreadLocalRandom.current().nextFloat() == f) ++i;\r\n    assertTrue(i < NCALLS);\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.data_Period",
	"Comment": "data provider to get the difference between two dates as a period",
	"Method": "Object[][] data_Period(){\r\n    return new Object[][] { { HijrahDate.of(1350, 5, 15), HijrahDate.of(1434, 7, 20), HijrahChronology.INSTANCE.period(84, 2, 5) }, { HijrahDate.of(1403, 5, 28), HijrahDate.of(1434, 7, 20), HijrahChronology.INSTANCE.period(31, 1, 22) }, { HijrahDate.of(1434, 7, 20), HijrahDate.of(1484, 2, 15), HijrahChronology.INSTANCE.period(49, 6, 24) }, { HijrahDate.of(1500, 6, 12), HijrahDate.of(1450, 4, 21), HijrahChronology.INSTANCE.period(-50, -1, -20) }, { HijrahDate.of(1549, 3, 11), HijrahDate.of(1550, 3, 10), HijrahChronology.INSTANCE.period(0, 11, 28) } };\r\n}"
}, {
	"Path": "com.google.mockwebserver.MockWebServer.getRequestCount",
	"Comment": "returns the number of http requests received thus far by this server.this may exceed the number of http connections when connection reuse isin practice.",
	"Method": "int getRequestCount(){\r\n    return requestCount.get();\r\n}"
}, {
	"Path": "java.text.DecimalFormat.setMinimumFractionDigits",
	"Comment": "sets the minimum number of digits allowed in the fraction portion of anumber.for formatting numbers other than biginteger andbigdecimal objects, the lower of newvalue and340 is used. negative input values are replaced with 0.",
	"Method": "void setMinimumFractionDigits(int newValue){\r\n    minimumFractionDigits = Math.min(Math.max(0, newValue), MAXIMUM_FRACTION_DIGITS);\r\n    super.setMinimumFractionDigits((minimumFractionDigits > DOUBLE_FRACTION_DIGITS) ? DOUBLE_FRACTION_DIGITS : minimumFractionDigits);\r\n    if (minimumFractionDigits > maximumFractionDigits) {\r\n        maximumFractionDigits = minimumFractionDigits;\r\n        super.setMaximumFractionDigits((maximumFractionDigits > DOUBLE_FRACTION_DIGITS) ? DOUBLE_FRACTION_DIGITS : maximumFractionDigits);\r\n    }\r\n    fastPathCheckNeeded = true;\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedLongSynchronizer.setHead",
	"Comment": "sets head of queue to be node, thus dequeuing. called only byacquire methods.also nulls out unused fields for sake of gcand to suppress unnecessary signals and traversals.",
	"Method": "void setHead(Node node){\r\n    head = node;\r\n    node.thread = null;\r\n    node.prev = null;\r\n}"
}, {
	"Path": "org.xml.sax.SAXParseException.getColumnNumber",
	"Comment": "the column number of the end of the text where the exception occurred.the first column in a line is position 1.",
	"Method": "int getColumnNumber(){\r\n    return this.columnNumber;\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedLongSynchronizer.transferForSignal",
	"Comment": "transfers a node from a condition queue onto sync queue.returns true if successful.",
	"Method": "boolean transferForSignal(Node node){\r\n    if (!node.compareAndSetWaitStatus(Node.CONDITION, 0))\r\n        return false;\r\n    Node p = enq(node);\r\n    int ws = p.waitStatus;\r\n    if (ws > 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))\r\n        LockSupport.unpark(node.thread);\r\n    return true;\r\n}"
}, {
	"Path": "java.time.format.DateTimeFormatterBuilder.convertStyle",
	"Comment": "converts the given formatstyle to the java.text.dateformat style.",
	"Method": "int convertStyle(FormatStyle style){\r\n    if (style == null) {\r\n        return -1;\r\n    }\r\n    return style.ordinal();\r\n}"
}, {
	"Path": "java.text.DecimalFormat.subparse",
	"Comment": "parse the given text into a number.the text is parsed beginning atparseposition, until an unparseable character is seen.",
	"Method": "boolean subparse(String text,ParsePosition parsePosition,String positivePrefix,String negativePrefix,DigitList digits,boolean isExponent,boolean status){\r\n    int position = parsePosition.index;\r\n    int oldStart = parsePosition.index;\r\n    int backup;\r\n    boolean gotPositive, gotNegative;\r\n    gotPositive = text.regionMatches(position, positivePrefix, 0, positivePrefix.length());\r\n    gotNegative = text.regionMatches(position, negativePrefix, 0, negativePrefix.length());\r\n    if (gotPositive && gotNegative) {\r\n        if (positivePrefix.length() > negativePrefix.length()) {\r\n            gotNegative = false;\r\n        } else if (positivePrefix.length() < negativePrefix.length()) {\r\n            gotPositive = false;\r\n        }\r\n    }\r\n    if (gotPositive) {\r\n        position += positivePrefix.length();\r\n    } else if (gotNegative) {\r\n        position += negativePrefix.length();\r\n    } else {\r\n        parsePosition.errorIndex = position;\r\n        return false;\r\n    }\r\n    status[STATUS_INFINITE] = false;\r\n    if (!isExponent && text.regionMatches(position, symbols.getInfinity(), 0, symbols.getInfinity().length())) {\r\n        position += symbols.getInfinity().length();\r\n        status[STATUS_INFINITE] = true;\r\n    } else {\r\n        digits.decimalAt = digits.count = 0;\r\n        char zero = symbols.getZeroDigit();\r\n        char decimal = isCurrencyFormat ? symbols.getMonetaryDecimalSeparator() : symbols.getDecimalSeparator();\r\n        char grouping = symbols.getGroupingSeparator();\r\n        String exponentString = symbols.getExponentSeparator();\r\n        boolean sawDecimal = false;\r\n        boolean sawExponent = false;\r\n        boolean sawDigit = false;\r\n        int exponent = 0;\r\n        int digitCount = 0;\r\n        backup = -1;\r\n        for (; position < text.length(); ++position) {\r\n            char ch = text.charAt(position);\r\n            int digit = ch - zero;\r\n            if (digit < 0 || digit > 9) {\r\n                digit = Character.digit(ch, 10);\r\n            }\r\n            if (digit == 0) {\r\n                backup = -1;\r\n                sawDigit = true;\r\n                if (digits.count == 0) {\r\n                    if (!sawDecimal) {\r\n                        continue;\r\n                    }\r\n                    --digits.decimalAt;\r\n                } else {\r\n                    ++digitCount;\r\n                    digits.append((char) (digit + '0'));\r\n                }\r\n            } else if (digit > 0 && digit <= 9) {\r\n                sawDigit = true;\r\n                ++digitCount;\r\n                digits.append((char) (digit + '0'));\r\n                backup = -1;\r\n            } else if (!isExponent && ch == decimal) {\r\n                if (isParseIntegerOnly() || sawDecimal) {\r\n                    break;\r\n                }\r\n                digits.decimalAt = digitCount;\r\n                sawDecimal = true;\r\n            } else if (!isExponent && ch == grouping && isGroupingUsed()) {\r\n                if (sawDecimal) {\r\n                    break;\r\n                }\r\n                backup = position;\r\n            } else if (!isExponent && text.regionMatches(position, exponentString, 0, exponentString.length()) && !sawExponent) {\r\n                ParsePosition pos = new ParsePosition(position + exponentString.length());\r\n                boolean[] stat = new boolean[STATUS_LENGTH];\r\n                DigitList exponentDigits = new DigitList();\r\n                if (subparse(text, pos, \"\", Character.toString(symbols.getMinusSign()), exponentDigits, true, stat) && exponentDigits.fitsIntoLong(stat[STATUS_POSITIVE], true)) {\r\n                    position = pos.index;\r\n                    exponent = (int) exponentDigits.getLong();\r\n                    if (!stat[STATUS_POSITIVE]) {\r\n                        exponent = -exponent;\r\n                    }\r\n                    sawExponent = true;\r\n                }\r\n                break;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        if (backup != -1) {\r\n            position = backup;\r\n        }\r\n        if (!sawDecimal) {\r\n            digits.decimalAt = digitCount;\r\n        }\r\n        digits.decimalAt += exponent;\r\n        if (!sawDigit && digitCount == 0) {\r\n            parsePosition.index = oldStart;\r\n            parsePosition.errorIndex = oldStart;\r\n            return false;\r\n        }\r\n    }\r\n    if (!isExponent) {\r\n        if (gotPositive) {\r\n            gotPositive = text.regionMatches(position, positiveSuffix, 0, positiveSuffix.length());\r\n        }\r\n        if (gotNegative) {\r\n            gotNegative = text.regionMatches(position, negativeSuffix, 0, negativeSuffix.length());\r\n        }\r\n        if (gotPositive && gotNegative) {\r\n            if (positiveSuffix.length() > negativeSuffix.length()) {\r\n                gotNegative = false;\r\n            } else if (positiveSuffix.length() < negativeSuffix.length()) {\r\n                gotPositive = false;\r\n            }\r\n        }\r\n        if (gotPositive == gotNegative) {\r\n            parsePosition.errorIndex = position;\r\n            return false;\r\n        }\r\n        parsePosition.index = position + (gotPositive ? positiveSuffix.length() : negativeSuffix.length());\r\n    } else {\r\n        parsePosition.index = position;\r\n    }\r\n    status[STATUS_POSITIVE] = gotPositive;\r\n    if (parsePosition.index == oldStart) {\r\n        parsePosition.errorIndex = position;\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.javac.JavadocConverter.convertJavadoc",
	"Comment": "returns an ast node for the javadoc comment of a specified class,method, or field element.",
	"Method": "Javadoc convertJavadoc(Element element,String source,JavacEnvironment env,boolean reportWarnings){\r\n    DocTrees docTrees = DocTrees.instance(env.task());\r\n    TreePath path = docTrees.getPath(element);\r\n    if (path == null) {\r\n        throw new AssertionError(\"could not find tree path for element\");\r\n    }\r\n    DCTree.DCDocComment docComment = (DCTree.DCDocComment) docTrees.getDocCommentTree(path);\r\n    if (docComment == null) {\r\n        return null;\r\n    }\r\n    JavadocConverter converter = new JavadocConverter(element, docComment, source, docTrees, path.getCompilationUnit(), reportWarnings);\r\n    Javadoc result = new Javadoc();\r\n    TagElement newTag = new TagElement().setTagKind(TagElement.TagKind.DESCRIPTION);\r\n    converter.scan(docComment.getFirstSentence(), newTag);\r\n    converter.scan(docComment.getBody(), newTag);\r\n    if (!newTag.getFragments().isEmpty()) {\r\n        List<TreeNode> fragments = newTag.getFragments();\r\n        int start = fragments.get(0).getStartPosition();\r\n        TreeNode lastFragment = fragments.get(fragments.size() - 1);\r\n        int end = start + lastFragment.getLength();\r\n        converter.setPos(newTag, start, end);\r\n        result.addTag(newTag);\r\n    }\r\n    for (DocTree tag : docComment.getBlockTags()) {\r\n        if (tag.getKind() != DocTree.Kind.ERRONEOUS) {\r\n            newTag = new TagElement();\r\n            converter.scan(tag, newTag);\r\n            result.addTag(newTag);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testSubList3_IndexOutOfBoundsException",
	"Comment": "sublist throws indexoutofboundsexception when the second indexis lower then the first",
	"Method": "void testSubList3_IndexOutOfBoundsException(){\r\n    CopyOnWriteArrayList c = populatedArray(5);\r\n    List[] lists = { c, c.subList(1, c.size() - 1) };\r\n    for (List list : lists) {\r\n        try {\r\n            list.subList(list.size() - 1, 1);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkJoinCC",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoinCC(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingCCF f = new LFCCF(null, 8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.join();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkJoinCC",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoinCC(){\r\n    FailingCCF f = new LFCCF(null, 8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.join();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.getLastJulianDate",
	"Comment": "returns the day before the gregorian cutover date as abasecalendar.date. the date is a julian date.",
	"Method": "BaseCalendar.Date getLastJulianDate(){\r\n    return getCalendarDate(gregorianCutoverDate - 1);\r\n}"
}, {
	"Path": "jsr166.TreeMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    class ReferenceSet {\r\n        int lower(int key) {\r\n            return ascending ? lowerAscending(key) : higherAscending(key);\r\n        }\r\n        int floor(int key) {\r\n            return ascending ? floorAscending(key) : ceilingAscending(key);\r\n        }\r\n        int ceiling(int key) {\r\n            return ascending ? ceilingAscending(key) : floorAscending(key);\r\n        }\r\n        int higher(int key) {\r\n            return ascending ? higherAscending(key) : lowerAscending(key);\r\n        }\r\n        int first() {\r\n            return ascending ? firstAscending() : lastAscending();\r\n        }\r\n        int last() {\r\n            return ascending ? lastAscending() : firstAscending();\r\n        }\r\n        int lowerAscending(int key) {\r\n            return floorAscending(key - 1);\r\n        }\r\n        int floorAscending(int key) {\r\n            if (key < min)\r\n                return -1;\r\n            else if (key > max)\r\n                key = max;\r\n            while (key >= min) {\r\n                if (bs.get(key))\r\n                    return key;\r\n                key--;\r\n            }\r\n            return -1;\r\n        }\r\n        int ceilingAscending(int key) {\r\n            if (key < min)\r\n                key = min;\r\n            else if (key > max)\r\n                return -1;\r\n            int result = bs.nextSetBit(key);\r\n            return result > max ? -1 : result;\r\n        }\r\n        int higherAscending(int key) {\r\n            return ceilingAscending(key + 1);\r\n        }\r\n        private int firstAscending() {\r\n            int result = ceilingAscending(min);\r\n            return result > max ? -1 : result;\r\n        }\r\n        private int lastAscending() {\r\n            int result = floorAscending(max);\r\n            return result < min ? -1 : result;\r\n        }\r\n    }\r\n    ReferenceSet rs = new ReferenceSet();\r\n    int size = 0;\r\n    for (int i = min; i <= max; i++) {\r\n        boolean bsContainsI = bs.get(i);\r\n        assertEquals(bsContainsI, map.containsKey(i));\r\n        if (bsContainsI)\r\n            size++;\r\n    }\r\n    assertEquals(size, map.size());\r\n    int size2 = 0;\r\n    int previousKey = -1;\r\n    for (int key : map.keySet()) {\r\n        assertTrue(bs.get(key));\r\n        size2++;\r\n        assertTrue(previousKey < 0 || (ascending ? key - previousKey > 0 : key - previousKey < 0));\r\n        previousKey = key;\r\n    }\r\n    assertEquals(size2, size);\r\n    for (int key = min - 1; key <= max + 1; key++) {\r\n        assertEq(map.lowerKey(key), rs.lower(key));\r\n        assertEq(map.floorKey(key), rs.floor(key));\r\n        assertEq(map.higherKey(key), rs.higher(key));\r\n        assertEq(map.ceilingKey(key), rs.ceiling(key));\r\n    }\r\n    if (map.size() != 0) {\r\n        assertEq(map.firstKey(), rs.first());\r\n        assertEq(map.lastKey(), rs.last());\r\n    } else {\r\n        assertEq(rs.first(), -1);\r\n        assertEq(rs.last(), -1);\r\n        try {\r\n            map.firstKey();\r\n            shouldThrow();\r\n        } catch (NoSuchElementException success) {\r\n        }\r\n        try {\r\n            map.lastKey();\r\n            shouldThrow();\r\n        } catch (NoSuchElementException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.TreeMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return ascending ? lowerAscending(key) : higherAscending(key);\r\n}"
}, {
	"Path": "jsr166.TreeMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return ascending ? floorAscending(key) : ceilingAscending(key);\r\n}"
}, {
	"Path": "jsr166.TreeMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return ascending ? ceilingAscending(key) : floorAscending(key);\r\n}"
}, {
	"Path": "jsr166.TreeMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return ascending ? higherAscending(key) : lowerAscending(key);\r\n}"
}, {
	"Path": "jsr166.TreeMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return ascending ? firstAscending() : lastAscending();\r\n}"
}, {
	"Path": "jsr166.TreeMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return ascending ? lastAscending() : firstAscending();\r\n}"
}, {
	"Path": "jsr166.TreeMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return floorAscending(key - 1);\r\n}"
}, {
	"Path": "jsr166.TreeMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    if (key < min)\r\n        return -1;\r\n    else if (key > max)\r\n        key = max;\r\n    while (key >= min) {\r\n        if (bs.get(key))\r\n            return key;\r\n        key--;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "jsr166.TreeMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    if (key < min)\r\n        key = min;\r\n    else if (key > max)\r\n        return -1;\r\n    int result = bs.nextSetBit(key);\r\n    return result > max ? -1 : result;\r\n}"
}, {
	"Path": "jsr166.TreeMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return ceilingAscending(key + 1);\r\n}"
}, {
	"Path": "jsr166.TreeMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    int result = ceilingAscending(min);\r\n    return result > max ? -1 : result;\r\n}"
}, {
	"Path": "jsr166.TreeMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    int result = floorAscending(max);\r\n    return result < min ? -1 : result;\r\n}"
}, {
	"Path": "java.io.InputStreamReader.ready",
	"Comment": "tells whether this stream is ready to be read.an inputstreamreader isready if its input buffer is not empty, or if bytes are available to beread from the underlying byte stream.",
	"Method": "boolean ready(){\r\n    return sd.ready();\r\n}"
}, {
	"Path": "java.security.KeyStore.deleteEntry",
	"Comment": "deletes the entry identified by the given alias from this keystore.",
	"Method": "void deleteEntry(String alias){\r\n    if (!initialized) {\r\n        throw new KeyStoreException(\"Uninitialized keystore\");\r\n    }\r\n    keyStoreSpi.engineDeleteEntry(alias);\r\n}"
}, {
	"Path": "java.util.zip.DeflaterInputStream.close",
	"Comment": "closes this input stream and its underlying input stream, discardingany pending uncompressed data.",
	"Method": "void close(){\r\n    if (in != null) {\r\n        try {\r\n            if (usesDefaultDeflater) {\r\n                def.end();\r\n            }\r\n            in.close();\r\n        } finally {\r\n            in = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.EntryTest.testSetValue2",
	"Comment": "setvalue for simpleimmutableentry throws unsupportedoperationexception",
	"Method": "void testSetValue2(){\r\n    Map.Entry s2 = new AbstractMap.SimpleImmutableEntry(k1, v1);\r\n    Map.Entry s = new AbstractMap.SimpleImmutableEntry(s2);\r\n    assertEquals(k1, s.getKey());\r\n    assertEquals(v1, s.getValue());\r\n    try {\r\n        s.setValue(k2);\r\n        shouldThrow();\r\n    } catch (UnsupportedOperationException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkGet",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGet(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FailingFibAction f = new FailingFibAction(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get();\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkGet",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGet(){\r\n    FailingFibAction f = new FailingFibAction(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get();\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n}"
}, {
	"Path": "jsr166.JSR166TestCase.testInParallel",
	"Comment": "runs all the given actions in parallel, failing if any fail.useful for running multiple variants of tests that arenecessarily individually slow because they must block.",
	"Method": "void testInParallel(Action actions){\r\n    ExecutorService pool = Executors.newCachedThreadPool();\r\n    try (PoolCleaner cleaner = cleaner(pool)) {\r\n        ArrayList<Future<?>> futures = new ArrayList(actions.length);\r\n        for (final Action action : actions) futures.add(pool.submit(new CheckedRunnable() {\r\n            public void realRun() throws Throwable {\r\n                action.run();\r\n            }\r\n        }));\r\n        for (Future<?> future : futures) try {\r\n            assertNull(future.get(LONG_DELAY_MS, MILLISECONDS));\r\n        } catch (ExecutionException ex) {\r\n            threadUnexpectedException(ex.getCause());\r\n        } catch (Exception ex) {\r\n            threadUnexpectedException(ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.JSR166TestCase.testInParallel",
	"Comment": "runs all the given actions in parallel, failing if any fail.useful for running multiple variants of tests that arenecessarily individually slow because they must block.",
	"Method": "void testInParallel(Action actions){\r\n    action.run();\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testGetMaximumPoolSize",
	"Comment": "getmaximumpoolsize returns value given in constructor if nototherwise set",
	"Method": "void testGetMaximumPoolSize(){\r\n    final ThreadPoolExecutor p = new CustomTPE(2, 3, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertEquals(3, p.getMaximumPoolSize());\r\n        p.setMaximumPoolSize(5);\r\n        assertEquals(5, p.getMaximumPoolSize());\r\n        p.setMaximumPoolSize(4);\r\n        assertEquals(4, p.getMaximumPoolSize());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ArrayBlockingQueueTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    final ArrayBlockingQueue q = populatedQueue(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(i, q.take());\r\n            }\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.take();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadStaysAlive(t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.ArrayBlockingQueueTest.testBlockingTake",
	"Comment": "take removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTake(){\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(i, q.take());\r\n    }\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.take();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.StatementGenerator.assertIncompleteJava8Support",
	"Comment": "a temporary stub to show pseudocode in place of java 8 features.",
	"Method": "boolean assertIncompleteJava8Support(TreeNode node){\r\n    buffer.append(node.toString());\r\n    return false;\r\n}"
}, {
	"Path": "tests.util.SerializationTester.assertSame",
	"Comment": "tests the serialization and deserialization of const objects.",
	"Method": "boolean assertSame(Object inputObject){\r\n    return inputObject == getDeserilizedObject(inputObject);\r\n}"
}, {
	"Path": "java.util.Hashtable.clone",
	"Comment": "creates a shallow copy of this hashtable. all the structure of thehashtable itself is copied, but the keys and values are not cloned.this is a relatively expensive operation.",
	"Method": "Object clone(Object clone){\r\n    try {\r\n        Hashtable<K, V> t = (Hashtable<K, V>) super.clone();\r\n        t.table = new HashtableEntry[table.length];\r\n        for (int i = table.length; i-- > 0; ) {\r\n            t.table[i] = (table[i] != null) ? (HashtableEntry<K, V>) table[i].clone() : null;\r\n        }\r\n        t.keySet = null;\r\n        t.entrySet = null;\r\n        t.values = null;\r\n        t.modCount = 0;\r\n        return t;\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new InternalError();\r\n    }\r\n}"
}, {
	"Path": "java.security.Provider.ensureLegacyParsed",
	"Comment": "ensure all the legacy string properties are fully parsed intoservice objects.",
	"Method": "void ensureLegacyParsed(){\r\n    if ((legacyChanged == false) || (legacyStrings == null)) {\r\n        return;\r\n    }\r\n    serviceSet = null;\r\n    if (legacyMap == null) {\r\n        legacyMap = new LinkedHashMap<ServiceKey, Service>();\r\n    } else {\r\n        legacyMap.clear();\r\n    }\r\n    for (Map.Entry<String, String> entry : legacyStrings.entrySet()) {\r\n        parseLegacyPut(entry.getKey(), entry.getValue());\r\n    }\r\n    removeInvalidServices(legacyMap);\r\n    legacyChanged = false;\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testLongFieldUpdaterGetAndAccumulate",
	"Comment": "atomiclongfieldupdater getandaccumulate returns previous valueand updates with supplied function.",
	"Method": "void testLongFieldUpdaterGetAndAccumulate(){\r\n    AtomicLongFieldUpdater a = aLongFieldUpdater();\r\n    a.set(this, 1);\r\n    assertEquals(1L, a.getAndAccumulate(this, 2L, Long::sum));\r\n    assertEquals(3L, a.getAndAccumulate(this, 3L, Long::sum));\r\n    assertEquals(6L, a.get(this));\r\n    assertEquals(6L, aLongField);\r\n}"
}, {
	"Path": "org.apache.harmony.luni.tests.java.util.TreeSetTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this method\tis called before a test is executed.",
	"Method": "void setUp(){\r\n    ts = new TreeSet();\r\n    for (int i = 0; i < objArray.length; i++) {\r\n        Object x = objArray[i] = new Integer(i);\r\n        ts.add(x);\r\n    }\r\n}"
}, {
	"Path": "java.time.chrono.ChronoLocalDateTimeImpl.writeReplace",
	"Comment": "writes the chronolocaldatetime using adedicated serialized form.",
	"Method": "Object writeReplace(){\r\n    return new Ser(Ser.CHRONO_LOCAL_DATE_TIME_TYPE, this);\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.byte2hex",
	"Comment": "converts a byte to hex digit and writes to the supplied buffer",
	"Method": "void byte2hex(byte b,StringBuffer buf){\r\n    char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\r\n    int high = ((b & 0xf0) >> 4);\r\n    int low = (b & 0x0f);\r\n    buf.append(hexChars[high]);\r\n    buf.append(hexChars[low]);\r\n}"
}, {
	"Path": "android.icu.dev.test.lang.UCharacterTest.TestIteration",
	"Comment": "this method is a little different from the type test in icu4c. but combined with testunicodedata, they basically do the same thing.",
	"Method": "void TestIteration(){\r\n    int limit = 0;\r\n    int prevtype = -1;\r\n    int shouldBeDir;\r\n    int[][] test = { { 0x41, UCharacterCategory.UPPERCASE_LETTER }, { 0x308, UCharacterCategory.NON_SPACING_MARK }, { 0xfffe, UCharacterCategory.GENERAL_OTHER_TYPES }, { 0xe0041, UCharacterCategory.FORMAT }, { 0xeffff, UCharacterCategory.UNASSIGNED } };\r\n    int[][] defaultBidi = { { 0x0590, UCharacterDirection.LEFT_TO_RIGHT }, { 0x0600, UCharacterDirection.RIGHT_TO_LEFT }, { 0x07C0, UCharacterDirection.RIGHT_TO_LEFT_ARABIC }, { 0x08A0, UCharacterDirection.RIGHT_TO_LEFT }, { 0x0900, UCharacterDirection.RIGHT_TO_LEFT_ARABIC }, { 0x20A0, UCharacterDirection.LEFT_TO_RIGHT }, { 0x20D0, UCharacterDirection.EUROPEAN_NUMBER_TERMINATOR }, { 0xFB1D, UCharacterDirection.LEFT_TO_RIGHT }, { 0xFB50, UCharacterDirection.RIGHT_TO_LEFT }, { 0xFE00, UCharacterDirection.RIGHT_TO_LEFT_ARABIC }, { 0xFE70, UCharacterDirection.LEFT_TO_RIGHT }, { 0xFF00, UCharacterDirection.RIGHT_TO_LEFT_ARABIC }, { 0x10800, UCharacterDirection.LEFT_TO_RIGHT }, { 0x11000, UCharacterDirection.RIGHT_TO_LEFT }, { 0x1E800, UCharacterDirection.LEFT_TO_RIGHT }, { 0x1EE00, UCharacterDirection.RIGHT_TO_LEFT }, { 0x1EF00, UCharacterDirection.RIGHT_TO_LEFT_ARABIC }, { 0x1F000, UCharacterDirection.RIGHT_TO_LEFT }, { 0x110000, UCharacterDirection.LEFT_TO_RIGHT } };\r\n    RangeValueIterator iterator = UCharacter.getTypeIterator();\r\n    RangeValueIterator.Element result = new RangeValueIterator.Element();\r\n    while (iterator.next(result)) {\r\n        if (result.start != limit) {\r\n            errln(\"UCharacterIteration failed: Ranges not continuous \" + \"0x\" + Integer.toHexString(result.start));\r\n        }\r\n        limit = result.limit;\r\n        if (result.value == prevtype) {\r\n            errln(\"Type of the next set of enumeration should be different\");\r\n        }\r\n        prevtype = result.value;\r\n        for (int i = result.start; i < limit; i++) {\r\n            int temptype = UCharacter.getType(i);\r\n            if (temptype != result.value) {\r\n                errln(\"UCharacterIteration failed: Codepoint \\\%u\" + Integer.toHexString(i) + \" should be of type \" + temptype + \" not \" + result.value);\r\n            }\r\n        }\r\n        for (int i = 0; i < test.length; ++i) {\r\n            if (result.start <= test[i][0] && test[i][0] < result.limit) {\r\n                if (result.value != test[i][1]) {\r\n                    errln(\"error: getTypes() has range [\" + Integer.toHexString(result.start) + \", \" + Integer.toHexString(result.limit) + \"] with type \" + result.value + \" instead of [\" + Integer.toHexString(test[i][0]) + \", \" + Integer.toHexString(test[i][1]));\r\n                }\r\n            }\r\n        }\r\n        if (result.value != UCharacterCategory.UNASSIGNED && result.value != UCharacterCategory.PRIVATE_USE) {\r\n            int c = result.start;\r\n            while (c < result.limit) {\r\n                if (0 == UCharacter.getIntPropertyValue(c, UProperty.LINE_BREAK)) {\r\n                    logln(\"error UProperty.LINE_BREAK(assigned \\\%u\" + Utility.hex(c, 4) + \")=XX\");\r\n                }\r\n                ++c;\r\n            }\r\n        }\r\n        if (result.value == UCharacterCategory.UNASSIGNED || result.value == UCharacterCategory.PRIVATE_USE) {\r\n            int c = result.start;\r\n            for (int i = 0; i < defaultBidi.length && c < result.limit; ++i) {\r\n                if (c < defaultBidi[i][0]) {\r\n                    while (c < result.limit && c < defaultBidi[i][0]) {\r\n                        if (android.icu.impl.UCharacterUtility.isNonCharacter(c) || UCharacter.hasBinaryProperty(c, UProperty.DEFAULT_IGNORABLE_CODE_POINT)) {\r\n                            shouldBeDir = UCharacter.BOUNDARY_NEUTRAL;\r\n                        } else {\r\n                            shouldBeDir = defaultBidi[i][1];\r\n                        }\r\n                        if (UCharacter.getDirection(c) != shouldBeDir || UCharacter.getIntPropertyValue(c, UProperty.BIDI_CLASS) != shouldBeDir) {\r\n                            errln(\"error: getDirection(unassigned/PUA \" + Integer.toHexString(c) + \") should be \" + shouldBeDir);\r\n                        }\r\n                        ++c;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    iterator.reset();\r\n    if (iterator.next(result) == false || result.start != 0) {\r\n        System.out.println(\"result \" + result.start);\r\n        errln(\"UCharacterIteration reset() failed\");\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicIntegerFieldUpdater.decrementAndGet",
	"Comment": "atomically decrements by one the current value of the field of thegiven object managed by this updater.",
	"Method": "int decrementAndGet(T obj,int decrementAndGet,T obj){\r\n    int prev, next;\r\n    do {\r\n        prev = get(obj);\r\n        next = prev - 1;\r\n    } while (!compareAndSet(obj, prev, next));\r\n    return next;\r\n}"
}, {
	"Path": "java.io.FilterOutputStream.flush",
	"Comment": "flushes this output stream and forces any buffered output bytesto be written out to the stream.the flush method of filteroutputstreamcalls the flush method of its underlying output stream.",
	"Method": "void flush(){\r\n    out.flush();\r\n}"
}, {
	"Path": "java.lang.Package.getImplementationVendor",
	"Comment": "returns the name of the organization,vendor or company that provided this implementation.",
	"Method": "String getImplementationVendor(){\r\n    return implVendor;\r\n}"
}, {
	"Path": "org.kxml2.io.KXmlParser.readUntil",
	"Comment": "reads text until the specified delimiter is encountered. consumes thetext and the delimiter.",
	"Method": "String readUntil(char[] delimiter,boolean returnText){\r\n    int start = position;\r\n    StringBuilder result = null;\r\n    if (returnText && text != null) {\r\n        result = new StringBuilder();\r\n        result.append(text);\r\n    }\r\n    search: while (true) {\r\n        if (position + delimiter.length > limit) {\r\n            if (start < position && returnText) {\r\n                if (result == null) {\r\n                    result = new StringBuilder();\r\n                }\r\n                result.append(buffer, start, position - start);\r\n            }\r\n            if (!fillBuffer(delimiter.length)) {\r\n                checkRelaxed(UNEXPECTED_EOF);\r\n                type = COMMENT;\r\n                return null;\r\n            }\r\n            start = position;\r\n        }\r\n        for (int i = 0; i < delimiter.length; i++) {\r\n            if (buffer[position + i] != delimiter[i]) {\r\n                position++;\r\n                continue search;\r\n            }\r\n        }\r\n        break;\r\n    }\r\n    int end = position;\r\n    position += delimiter.length;\r\n    if (!returnText) {\r\n        return null;\r\n    } else if (result == null) {\r\n        return stringPool.get(buffer, start, end - start);\r\n    } else {\r\n        result.append(buffer, start, end - start);\r\n        return result.toString();\r\n    }\r\n}"
}, {
	"Path": "java.net.InetAddress.isMCSiteLocal",
	"Comment": "utility routine to check if the multicast address has site scope.",
	"Method": "boolean isMCSiteLocal(){\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArriveAndDeregister",
	"Comment": "arriveandderegister does not wait for others to arrive at barrier",
	"Method": "void testArriveAndDeregister(){\r\n    final Phaser phaser = new Phaser(1);\r\n    for (int i = 0; i < 10; i++) {\r\n        assertState(phaser, 0, 1, 1);\r\n        assertEquals(0, phaser.register());\r\n        assertState(phaser, 0, 2, 2);\r\n        assertEquals(0, phaser.arriveAndDeregister());\r\n        assertState(phaser, 0, 1, 1);\r\n    }\r\n    assertEquals(0, phaser.arriveAndDeregister());\r\n    assertTerminated(phaser, 1);\r\n}"
}, {
	"Path": "java.util.logging.LogRecord.getSequenceNumber",
	"Comment": "get the sequence number.sequence numbers are normally assigned in the logrecordconstructor, which assigns unique sequence numbers toeach new logrecord in increasing order.",
	"Method": "long getSequenceNumber(){\r\n    return sequenceNumber;\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testPollNextLocalTaskAsync",
	"Comment": "pollnextlocaltask returns least recent unexecuted task withoutexecuting it, in async mode",
	"Method": "void testPollNextLocalTaskAsync(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            CCF g = new LCCF(9);\r\n            assertSame(g, g.fork());\r\n            CCF f = new LCCF(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, pollNextLocalTask());\r\n            helpQuiesce();\r\n            assertEquals(21, f.number);\r\n            checkCompletedNormally(f);\r\n            checkNotDone(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(asyncSingletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testPollNextLocalTaskAsync",
	"Comment": "pollnextlocaltask returns least recent unexecuted task withoutexecuting it, in async mode",
	"Method": "void testPollNextLocalTaskAsync(){\r\n    CCF g = new LCCF(9);\r\n    assertSame(g, g.fork());\r\n    CCF f = new LCCF(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, pollNextLocalTask());\r\n    helpQuiesce();\r\n    assertEquals(21, f.number);\r\n    checkCompletedNormally(f);\r\n    checkNotDone(g);\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testAwaitAdvanceAfterInterrupt",
	"Comment": "awaitadvance continues waiting if interrupted before waiting",
	"Method": "void testAwaitAdvanceAfterInterrupt(){\r\n    final Phaser phaser = new Phaser();\r\n    assertEquals(0, phaser.register());\r\n    final CountDownLatch pleaseArrive = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            Thread.currentThread().interrupt();\r\n            assertEquals(0, phaser.register());\r\n            assertEquals(0, phaser.arrive());\r\n            pleaseArrive.countDown();\r\n            assertTrue(Thread.currentThread().isInterrupted());\r\n            assertEquals(1, phaser.awaitAdvance(0));\r\n            assertTrue(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseArrive);\r\n    waitForThreadToEnterWaitState(t, SHORT_DELAY_MS);\r\n    assertEquals(0, phaser.arrive());\r\n    awaitTermination(t);\r\n    Thread.currentThread().interrupt();\r\n    assertEquals(1, phaser.awaitAdvance(0));\r\n    assertTrue(Thread.interrupted());\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testAwaitAdvanceAfterInterrupt",
	"Comment": "awaitadvance continues waiting if interrupted before waiting",
	"Method": "void testAwaitAdvanceAfterInterrupt(){\r\n    Thread.currentThread().interrupt();\r\n    assertEquals(0, phaser.register());\r\n    assertEquals(0, phaser.arrive());\r\n    pleaseArrive.countDown();\r\n    assertTrue(Thread.currentThread().isInterrupted());\r\n    assertEquals(1, phaser.awaitAdvance(0));\r\n    assertTrue(Thread.interrupted());\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testInterruptedTimedPoll",
	"Comment": "interrupted timed poll throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPoll(){\r\n    final BlockingQueue<Integer> q = populatedQueue(SIZE);\r\n    final CountDownLatch aboutToWait = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            long startTime = System.nanoTime();\r\n            for (int i = 0; i < SIZE; ++i) assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n            aboutToWait.countDown();\r\n            try {\r\n                q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n        }\r\n    });\r\n    aboutToWait.await();\r\n    waitForThreadToEnterWaitState(t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testInterruptedTimedPoll",
	"Comment": "interrupted timed poll throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPoll(){\r\n    long startTime = System.nanoTime();\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n    aboutToWait.countDown();\r\n    try {\r\n        q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n}"
}, {
	"Path": "org.xmlpull.v1.XmlPullParserFactory.setNamespaceAware",
	"Comment": "specifies that the parser produced by this factory will providesupport for xml namespaces.by default the value of this is set to false.",
	"Method": "void setNamespaceAware(boolean awareness){\r\n    features.put(XmlPullParser.FEATURE_PROCESS_NAMESPACES, awareness);\r\n}"
}, {
	"Path": "java.util.HashMap.containsValue",
	"Comment": "returns true if this map maps one or more keys to thespecified value.",
	"Method": "boolean containsValue(Object value){\r\n    if (value == null)\r\n        return containsNullValue();\r\n    HashMapEntry[] tab = table;\r\n    for (int i = 0; i < tab.length; i++) for (HashMapEntry e = tab[i]; e != null; e = e.next) if (value.equals(e.value))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTimedPollAfterInterrupt",
	"Comment": "timed poll after thread interrupted throws interruptedexceptioninstead of returning timeout status",
	"Method": "void testTimedPollAfterInterrupt(){\r\n    final BlockingQueue<Integer> q = populatedQueue(SIZE);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            long startTime = System.nanoTime();\r\n            Thread.currentThread().interrupt();\r\n            for (int i = 0; i < SIZE; ++i) assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n            try {\r\n                q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n        }\r\n    });\r\n    awaitTermination(t);\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testTimedPollAfterInterrupt",
	"Comment": "timed poll after thread interrupted throws interruptedexceptioninstead of returning timeout status",
	"Method": "void testTimedPollAfterInterrupt(){\r\n    long startTime = System.nanoTime();\r\n    Thread.currentThread().interrupt();\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n    try {\r\n        q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorBytesPositive1",
	"Comment": "create a positive number from an array of bytes.the number fits in an array of integers.",
	"Method": "void testConstructorBytesPositive1(){\r\n    byte[] aBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 35, 26, 3, 91 };\r\n    byte[] rBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 35, 26, 3, 91 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "java.util.JumboEnumSet.containsAll",
	"Comment": "returns true if this set contains all of the elementsin the specified collection.",
	"Method": "boolean containsAll(Collection<?> c){\r\n    if (!(c instanceof JumboEnumSet))\r\n        return super.containsAll(c);\r\n    JumboEnumSet es = (JumboEnumSet) c;\r\n    if (es.elementType != elementType)\r\n        return es.isEmpty();\r\n    for (int i = 0; i < elements.length; i++) if ((es.elements[i] & ~elements[i]) != 0)\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "java.time.Instant.plus",
	"Comment": "returns a copy of this instant with the specified duration added.this instance is immutable and unaffected by this method call.",
	"Method": "Instant plus(TemporalAmount amountToAdd,Instant plus,long amountToAdd,TemporalUnit unit,Instant plus,long secondsToAdd,long nanosToAdd){\r\n    if ((secondsToAdd | nanosToAdd) == 0) {\r\n        return this;\r\n    }\r\n    long epochSec = Math.addExact(seconds, secondsToAdd);\r\n    epochSec = Math.addExact(epochSec, nanosToAdd / NANOS_PER_SECOND);\r\n    nanosToAdd = nanosToAdd % NANOS_PER_SECOND;\r\n    long nanoAdjustment = nanos + nanosToAdd;\r\n    return ofEpochSecond(epochSec, nanoAdjustment);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorBytesPositive3",
	"Comment": "create a positive number from an array of bytes.the number of bytes is 4.",
	"Method": "void testConstructorBytesPositive3(){\r\n    byte[] aBytes = { 127, 56, 100, -1 };\r\n    byte[] rBytes = { 127, 56, 100, -1 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "java.security.Signature.getParameters",
	"Comment": "returns the parameters used with this signature object.the returned parameters may be the same that were used to initializethis signature, or may contain a combination of default and randomlygenerated parameter values used by the underlying signatureimplementation if this signature requires algorithm parameters butwas not initialized with any.",
	"Method": "AlgorithmParameters getParameters(){\r\n    return engineGetParameters();\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorBytesPositive2",
	"Comment": "create a positive number from an array of bytes.the number fits in an integer.",
	"Method": "void testConstructorBytesPositive2(){\r\n    byte[] aBytes = { 12, 56, 100 };\r\n    byte[] rBytes = { 12, 56, 100 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "java.util.EnumMap.getKeyUniverse",
	"Comment": "returns all of the values comprising k.the result is uncloned, cached, and shared by all callers.",
	"Method": "K[] getKeyUniverse(Class<K> keyType){\r\n    return JavaLangAccess.getEnumConstantsShared(keyType);\r\n}"
}, {
	"Path": "java.io.PrintStream.flush",
	"Comment": "flushes the stream.this is done by writing any buffered output bytes tothe underlying output stream and then flushing that stream.",
	"Method": "void flush(){\r\n    synchronized (this) {\r\n        try {\r\n            ensureOpen();\r\n            out.flush();\r\n        } catch (IOException x) {\r\n            trouble = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedListTest.populatedQueue",
	"Comment": "returns a new queue of given size containing consecutiveintegers 0 ... n.",
	"Method": "LinkedList<Integer> populatedQueue(int n){\r\n    LinkedList<Integer> q = new LinkedList<Integer>();\r\n    assertTrue(q.isEmpty());\r\n    for (int i = 0; i < n; ++i) assertTrue(q.offer(new Integer(i)));\r\n    assertFalse(q.isEmpty());\r\n    assertEquals(n, q.size());\r\n    return q;\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.setCertificateChecking",
	"Comment": "sets the certificate being checked. this is not a criterion. rather,it is optional information that may help a certstorefind crls that would be relevant when checking revocation for thespecified certificate. if null is specified, then nosuch optional information is provided.",
	"Method": "void setCertificateChecking(X509Certificate cert){\r\n    certChecking = cert;\r\n}"
}, {
	"Path": "sun.security.x509.CertificatePoliciesExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(POLICIES);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "java.util.jar.Manifest.read",
	"Comment": "reads the manifest from the specified inputstream. the entrynames and attributes read will be merged in with the currentmanifest entries.",
	"Method": "void read(InputStream is,int read,int read,byte[] b,int off,int len){\r\n    FastInputStream fis = new FastInputStream(is);\r\n    byte[] lbuf = new byte[512];\r\n    attr.read(fis, lbuf);\r\n    int ecount = 0, acount = 0;\r\n    int asize = 2;\r\n    int len;\r\n    String name = null;\r\n    boolean skipEmptyLines = true;\r\n    byte[] lastline = null;\r\n    while ((len = fis.readLine(lbuf)) != -1) {\r\n        if (lbuf[--len] != '\\n') {\r\n            throw new IOException(\"manifest line too long\");\r\n        }\r\n        if (len > 0 && lbuf[len - 1] == '\\r') {\r\n            --len;\r\n        }\r\n        if (len == 0 && skipEmptyLines) {\r\n            continue;\r\n        }\r\n        skipEmptyLines = false;\r\n        if (name == null) {\r\n            name = parseName(lbuf, len);\r\n            if (name == null) {\r\n                throw new IOException(\"invalid manifest format\");\r\n            }\r\n            if (fis.peek() == ' ') {\r\n                lastline = new byte[len - 6];\r\n                System.arraycopy(lbuf, 6, lastline, 0, len - 6);\r\n                continue;\r\n            }\r\n        } else {\r\n            byte[] buf = new byte[lastline.length + len - 1];\r\n            System.arraycopy(lastline, 0, buf, 0, lastline.length);\r\n            System.arraycopy(lbuf, 1, buf, lastline.length, len - 1);\r\n            if (fis.peek() == ' ') {\r\n                lastline = buf;\r\n                continue;\r\n            }\r\n            name = new String(buf, 0, buf.length, \"UTF8\");\r\n            lastline = null;\r\n        }\r\n        Attributes attr = getAttributes(name);\r\n        if (attr == null) {\r\n            attr = new Attributes(asize);\r\n            entries.put(name, attr);\r\n        }\r\n        attr.read(fis, lbuf);\r\n        ecount++;\r\n        acount += attr.size();\r\n        asize = Math.max(2, acount / ecount);\r\n        name = null;\r\n        skipEmptyLines = true;\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.ReverseState.keyParamsNeeded",
	"Comment": "returns a boolean flag indicating if a key lacking necessary keyalgorithm parameters has been encountered.",
	"Method": "boolean keyParamsNeeded(){\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testReferenceArrayAccumulateAndGet",
	"Comment": "atomicreferencearray accumulateandget updates with supplied function andreturns result.",
	"Method": "void testReferenceArrayAccumulateAndGet(){\r\n    AtomicReferenceArray<Integer> a = new AtomicReferenceArray<Integer>(1);\r\n    a.set(0, one);\r\n    assertEquals(new Integer(7), a.accumulateAndGet(0, 6, Atomic8Test::sumInteger));\r\n    assertEquals(new Integer(10), a.accumulateAndGet(0, 3, Atomic8Test::sumInteger));\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testGetThreadFactory",
	"Comment": "getthreadfactory returns factory in constructor if not set",
	"Method": "void testGetThreadFactory(){\r\n    final ThreadFactory threadFactory = new SimpleThreadFactory();\r\n    final CustomExecutor p = new CustomExecutor(1, threadFactory);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertSame(threadFactory, p.getThreadFactory());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinTask8Test.testPollTaskAsync",
	"Comment": "polltask returns an unexecuted task without executing it, inasync mode",
	"Method": "void testPollTaskAsync(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib g = new AsyncFib(9);\r\n            assertSame(g, g.fork());\r\n            AsyncFib f = new AsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, pollTask());\r\n            helpQuiesce();\r\n            f.checkCompletedNormally();\r\n            checkNotDone(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(asyncSingletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTask8Test.testPollTaskAsync",
	"Comment": "polltask returns an unexecuted task without executing it, inasync mode",
	"Method": "void testPollTaskAsync(){\r\n    AsyncFib g = new AsyncFib(9);\r\n    assertSame(g, g.fork());\r\n    AsyncFib f = new AsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, pollTask());\r\n    helpQuiesce();\r\n    f.checkCompletedNormally();\r\n    checkNotDone(g);\r\n}"
}, {
	"Path": "java.time.zone.ZoneRules.getStandardOffset",
	"Comment": "gets the standard offset for the specified instant in this zone.this provides access to historic information on how the standard offsethas changed over time.the standard offset is the offset before any daylight saving time is applied.this is typically the offset applicable during winter.",
	"Method": "ZoneOffset getStandardOffset(Instant instant){\r\n    if (savingsInstantTransitions.length == 0) {\r\n        return standardOffsets[0];\r\n    }\r\n    long epochSec = instant.getEpochSecond();\r\n    int index = Arrays.binarySearch(standardTransitions, epochSec);\r\n    if (index < 0) {\r\n        index = -index - 2;\r\n    }\r\n    return standardOffsets[index + 1];\r\n}"
}, {
	"Path": "java.security.KeyStore.setEntry",
	"Comment": "saves a keystore entry under the specified alias.the protection parameter is used to protect theentry. if an entry already exists for the specified alias,it is overridden.",
	"Method": "void setEntry(String alias,Entry entry,ProtectionParameter protParam){\r\n    if (alias == null || entry == null) {\r\n        throw new NullPointerException(\"invalid null input\");\r\n    }\r\n    if (!initialized) {\r\n        throw new KeyStoreException(\"Uninitialized keystore\");\r\n    }\r\n    keyStoreSpi.engineSetEntry(alias, entry, protParam);\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testConstructor20",
	"Comment": "constructor throws if corepoolsize is greater than the maximumpoolsize",
	"Method": "void testConstructor20(){\r\n    try {\r\n        new ThreadPoolExecutor(2, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10), new SimpleThreadFactory(), new NoOpREHandler());\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testLongFieldUpdaterAccumulateAndGet",
	"Comment": "atomiclongfieldupdater accumulateandget updates with suppliedfunction and returns result.",
	"Method": "void testLongFieldUpdaterAccumulateAndGet(){\r\n    AtomicLongFieldUpdater a = aLongFieldUpdater();\r\n    a.set(this, 1);\r\n    assertEquals(7L, a.accumulateAndGet(this, 6L, Long::sum));\r\n    assertEquals(10L, a.accumulateAndGet(this, 3L, Long::sum));\r\n    assertEquals(10L, a.get(this));\r\n    assertEquals(10L, aLongField);\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinTask.setCompletion",
	"Comment": "marks completion and wakes up threads waiting to join thistask.",
	"Method": "int setCompletion(int completion){\r\n    for (int s; ; ) {\r\n        if ((s = status) < 0)\r\n            return s;\r\n        if (U.compareAndSwapInt(this, STATUS, s, s | completion)) {\r\n            if ((s >>> 16) != 0)\r\n                synchronized (this) {\r\n                    notifyAll();\r\n                }\r\n            return completion;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testAbnormalForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGet(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() throws Exception {\r\n            FailingFibTask f = new FailingFibTask(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                Integer r = f.get(5L, SECONDS);\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(mainPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testAbnormalForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGet(){\r\n    FailingFibTask f = new FailingFibTask(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        Integer r = f.get(5L, SECONDS);\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n    return NoResult;\r\n}"
}, {
	"Path": "java.util.concurrent.DelayQueue.peekExpired",
	"Comment": "returns first element only if it is expired.used only by drainto.call only when holding lock.",
	"Method": "E peekExpired(){\r\n    E first = q.peek();\r\n    return (first == null || first.getDelay(NANOSECONDS) > 0) ? null : first;\r\n}"
}, {
	"Path": "java.time.YearMonth.lengthOfYear",
	"Comment": "returns the length of the year.this returns the length of the year in days, either 365 or 366.",
	"Method": "int lengthOfYear(){\r\n    return (isLeapYear() ? 366 : 365);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.nio.channels.ChannelsTest.assertFileSizeSame",
	"Comment": "this private method is to assert if the file size is the same as thecompare number in the test",
	"Method": "void assertFileSizeSame(File fileToTest,int compareNumber){\r\n    FileInputStream file = new FileInputStream(fileToTest);\r\n    assertEquals(file.available(), compareNumber);\r\n    file.close();\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testLongGetAndUpdate",
	"Comment": "atomiclong getandupdate returns previous value and updatesresult of supplied function",
	"Method": "void testLongGetAndUpdate(){\r\n    AtomicLong a = new AtomicLong(1L);\r\n    assertEquals(1L, a.getAndUpdate(Atomic8Test::addLong17));\r\n    assertEquals(18L, a.getAndUpdate(Atomic8Test::addLong17));\r\n    assertEquals(35L, a.get());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.TypeDeclarationGeneratorTest.testNoEnumConstantAccessorMethods",
	"Comment": "verify that accessor methods for enum constants are not generated by default.",
	"Method": "void testNoEnumConstantAccessorMethods(){\r\n    String source = \"enum Test { ONE, TWO, EOF_ }\";\r\n    String translation = translateSourceFile(source, \"Test\", \"Test.h\");\r\n    assertNotInTranslation(translation, \"+ (TestEnum *)ONE\");\r\n    assertNotInTranslation(translation, \"+ (TestEnum *)TWO\");\r\n    assertNotInTranslation(translation, \"+ (TestEnum *)EOF\");\r\n}"
}, {
	"Path": "java.net.URLConnection.getContentHandlerPkgPrefixes",
	"Comment": "returns a vertical bar separated list of package prefixes for potentialcontent handlers.tries to get the java.content.handler.pkgs propertyto use as a set of package prefixes to search.whether or notthat property has been defined, the sun.net.www.content is alwaysthe last one on the returned package list.",
	"Method": "String getContentHandlerPkgPrefixes(){\r\n    String packagePrefixList = System.getProperty(contentPathProp, \"\");\r\n    if (packagePrefixList != \"\") {\r\n        packagePrefixList += \"|\";\r\n    }\r\n    return packagePrefixList + contentClassPrefix;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getAuthorityKeyIdentifier",
	"Comment": "returns the authoritykeyidentifier criterion. thex509certificate must contain a authoritykeyidentifierextension with the specified value. if null, noauthoritykeyidentifier check will be done.note that the byte array returned is cloned to protect againstsubsequent modifications.",
	"Method": "byte[] getAuthorityKeyIdentifier(){\r\n    if (authorityKeyID == null) {\r\n        return null;\r\n    }\r\n    return authorityKeyID.clone();\r\n}"
}, {
	"Path": "sun.security.provider.certpath.AdaptableX509CertSelector.match",
	"Comment": "decides whether a certificate should be selected.for the purpose of compatibility, when a certificate is ofversion 1 and version 2, or the certificate does not includea subject key identifier extension, the selection criterionof subjectkeyidentifier will be disabled.",
	"Method": "boolean match(Certificate cert){\r\n    if (!(cert instanceof X509Certificate)) {\r\n        return false;\r\n    }\r\n    X509Certificate xcert = (X509Certificate) cert;\r\n    int version = xcert.getVersion();\r\n    if (version < 3) {\r\n        if (startDate != null) {\r\n            try {\r\n                xcert.checkValidity(startDate);\r\n            } catch (CertificateException ce) {\r\n                return false;\r\n            }\r\n        }\r\n        if (endDate != null) {\r\n            try {\r\n                xcert.checkValidity(endDate);\r\n            } catch (CertificateException ce) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    if (isSKIDSensitive && (version < 3 || xcert.getExtensionValue(\"2.5.29.14\") == null)) {\r\n        setSubjectKeyIdentifier(null);\r\n    }\r\n    if (isSNSensitive && version < 3) {\r\n        setSerialNumber(null);\r\n    }\r\n    return super.match(cert);\r\n}"
}, {
	"Path": "java.util.concurrent.ThreadLocalRandom.internalNextInt",
	"Comment": "the form of nextint used by intstream spliterators.exactly the same as long version, except for types.",
	"Method": "int internalNextInt(int origin,int bound){\r\n    int r = mix32(nextSeed());\r\n    if (origin < bound) {\r\n        int n = bound - origin, m = n - 1;\r\n        if ((n & m) == 0)\r\n            r = (r & m) + origin;\r\n        else if (n > 0) {\r\n            for (int u = r >>> 1; u + m - (r = u % n) < 0; u = mix32(nextSeed()) >>> 1) ;\r\n            r += origin;\r\n        } else {\r\n            while (r < origin || r >= bound) r = mix32(nextSeed());\r\n        }\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "sun.security.x509.AlgorithmId.getDigAlgFromSigAlg",
	"Comment": "extracts the digest algorithm name from a signaturealgorithm name.",
	"Method": "String getDigAlgFromSigAlg(String signatureAlgorithm){\r\n    signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);\r\n    int with = signatureAlgorithm.indexOf(\"WITH\");\r\n    if (with > 0) {\r\n        return signatureAlgorithm.substring(0, with);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "sun.security.pkcs.PKCS7.getCertificate",
	"Comment": "returns the x.509 certificate listed in this pkcs7 blockwhich has a matching serial number and issuer name, ornull if one is not found.",
	"Method": "X509Certificate getCertificate(BigInteger serial,X500Name issuerName){\r\n    if (certificates != null) {\r\n        if (certIssuerNames == null)\r\n            populateCertIssuerNames();\r\n        for (int i = 0; i < certificates.length; i++) {\r\n            X509Certificate cert = certificates[i];\r\n            BigInteger thisSerial = cert.getSerialNumber();\r\n            if (serial.equals(thisSerial) && issuerName.equals(certIssuerNames[i])) {\r\n                return cert;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "sun.security.x509.X500Name.getEncodedInternal",
	"Comment": "returned the encoding as an uncloned byte array. callers mustguarantee that they neither modify it not expose it to untrustedcode.",
	"Method": "byte[] getEncodedInternal(){\r\n    if (encoded == null) {\r\n        DerOutputStream out = new DerOutputStream();\r\n        DerOutputStream tmp = new DerOutputStream();\r\n        for (int i = 0; i < names.length; i++) {\r\n            names[i].encode(tmp);\r\n        }\r\n        out.write(DerValue.tag_Sequence, tmp);\r\n        encoded = out.toByteArray();\r\n    }\r\n    return encoded;\r\n}"
}, {
	"Path": "sun.nio.ch.SocketChannelImpl.translateReadyOps",
	"Comment": "translates native poll revent ops into a ready operation ops",
	"Method": "boolean translateReadyOps(int ops,int initialOps,SelectionKeyImpl sk){\r\n    int intOps = sk.nioInterestOps();\r\n    int oldOps = sk.nioReadyOps();\r\n    int newOps = initialOps;\r\n    if ((ops & PollArrayWrapper.POLLNVAL) != 0) {\r\n        return false;\r\n    }\r\n    if ((ops & (PollArrayWrapper.POLLERR | PollArrayWrapper.POLLHUP)) != 0) {\r\n        newOps = intOps;\r\n        sk.nioReadyOps(newOps);\r\n        readyToConnect = true;\r\n        return (newOps & ~oldOps) != 0;\r\n    }\r\n    if (((ops & PollArrayWrapper.POLLIN) != 0) && ((intOps & SelectionKey.OP_READ) != 0) && (state == ST_CONNECTED))\r\n        newOps |= SelectionKey.OP_READ;\r\n    if (((ops & PollArrayWrapper.POLLCONN) != 0) && ((intOps & SelectionKey.OP_CONNECT) != 0) && ((state == ST_UNCONNECTED) || (state == ST_PENDING))) {\r\n        newOps |= SelectionKey.OP_CONNECT;\r\n        readyToConnect = true;\r\n    }\r\n    if (((ops & PollArrayWrapper.POLLOUT) != 0) && ((intOps & SelectionKey.OP_WRITE) != 0) && (state == ST_CONNECTED))\r\n        newOps |= SelectionKey.OP_WRITE;\r\n    sk.nioReadyOps(newOps);\r\n    return (newOps & ~oldOps) != 0;\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.getSerialNumberObject",
	"Comment": "gets the serial number from the certificate asa serialnumber object.",
	"Method": "SerialNumber getSerialNumberObject(){\r\n    if (info == null)\r\n        return null;\r\n    try {\r\n        SerialNumber ser = (SerialNumber) info.get(CertificateSerialNumber.NAME + DOT + CertificateSerialNumber.NUMBER);\r\n        return ser;\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.Executors.newCachedThreadPool",
	"Comment": "creates a thread pool that creates new threads as needed, butwill reuse previously constructed threads when they areavailable, and uses the providedthreadfactory to create new threads when needed.",
	"Method": "ExecutorService newCachedThreadPool(ExecutorService newCachedThreadPool,ThreadFactory threadFactory){\r\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), threadFactory);\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testIntegerFieldUpdaterGetAndUpdate",
	"Comment": "atomicintegerfieldupdater getandupdate returns previous value and updatesresult of supplied function",
	"Method": "void testIntegerFieldUpdaterGetAndUpdate(){\r\n    AtomicIntegerFieldUpdater a = anIntFieldUpdater();\r\n    a.set(this, 1);\r\n    assertEquals(1, a.getAndUpdate(this, Atomic8Test::addInt17));\r\n    assertEquals(18, a.getAndUpdate(this, Atomic8Test::addInt17));\r\n    assertEquals(35, a.get(this));\r\n    assertEquals(35, anIntField);\r\n}"
}, {
	"Path": "sun.net.www.ParseUtil.match",
	"Comment": "tell whether the given character is permitted by the given mask pair",
	"Method": "boolean match(char c,long lowMask,long highMask){\r\n    if (c < 64)\r\n        return ((1L << c) & lowMask) != 0;\r\n    if (c < 128)\r\n        return ((1L << (c - 64)) & highMask) != 0;\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testReferenceArrayGetAndAccumulate",
	"Comment": "atomicreferencearray getandaccumulate returns previous value and updateswith supplied function.",
	"Method": "void testReferenceArrayGetAndAccumulate(){\r\n    AtomicReferenceArray<Integer> a = new AtomicReferenceArray<Integer>(1);\r\n    a.set(0, one);\r\n    assertEquals(new Integer(1), a.getAndAccumulate(0, 2, Atomic8Test::sumInteger));\r\n    assertEquals(new Integer(3), a.getAndAccumulate(0, 3, Atomic8Test::sumInteger));\r\n    assertEquals(new Integer(6), a.get(0));\r\n}"
}, {
	"Path": "java.util.concurrent.locks.ReentrantReadWriteLock.getReadHoldCount",
	"Comment": "queries the number of reentrant read holds on this lock by thecurrent thread.a reader thread has a hold on a lock foreach lock action that is not matched by an unlock action.",
	"Method": "int getReadHoldCount(int getReadHoldCount){\r\n    return sync.getReadHoldCount();\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.lang.reflect.GenericMethodsTests.checkParameterType",
	"Comment": "tests whether the specified method declares a parameter with thetype of the type parameter.",
	"Method": "void checkParameterType(Method method){\r\n    TypeVariable<Method> typeParameter = getTypeParameter(method);\r\n    assertLenghtOne(method.getGenericParameterTypes());\r\n    Type genericParameterType = method.getGenericParameterTypes()[0];\r\n    assertEquals(typeParameter, genericParameterType);\r\n    assertInstanceOf(TypeVariable.class, genericParameterType);\r\n    assertEquals(method, ((TypeVariable<?>) genericParameterType).getGenericDeclaration());\r\n}"
}, {
	"Path": "org.xml.sax.SAXParseException.getSystemId",
	"Comment": "get the system identifier of the entity where the exception occurred.if the system identifier is a url, it will have been resolvedfully.",
	"Method": "String getSystemId(){\r\n    return this.systemId;\r\n}"
}, {
	"Path": "java.security.Timestamp.getSignerCertPath",
	"Comment": "returns the certificate path for the timestamping authority.",
	"Method": "CertPath getSignerCertPath(){\r\n    return signerCertPath;\r\n}"
}, {
	"Path": "java.net.Inet6Address.isIPv4CompatibleAddress",
	"Comment": "utility routine to check if the inetaddress is anipv4 compatible ipv6 address.",
	"Method": "boolean isIPv4CompatibleAddress(){\r\n    if ((ipaddress[0] == 0x00) && (ipaddress[1] == 0x00) && (ipaddress[2] == 0x00) && (ipaddress[3] == 0x00) && (ipaddress[4] == 0x00) && (ipaddress[5] == 0x00) && (ipaddress[6] == 0x00) && (ipaddress[7] == 0x00) && (ipaddress[8] == 0x00) && (ipaddress[9] == 0x00) && (ipaddress[10] == 0x00) && (ipaddress[11] == 0x00)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testGetKeepAliveTime",
	"Comment": "getkeepalivetime returns value given in constructor if not otherwise set",
	"Method": "void testGetKeepAliveTime(){\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(2, 2, 1000, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertEquals(1, p.getKeepAliveTime(SECONDS));\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.CollectionCertStore.engineGetCertificates",
	"Comment": "returns a collection of certificates thatmatch the specified selector. if no certificatesmatch the selector, an empty collection will be returned.",
	"Method": "Collection<Certificate> engineGetCertificates(CertSelector selector){\r\n    if (coll == null) {\r\n        throw new CertStoreException(\"Collection is null\");\r\n    }\r\n    for (int c = 0; c < 10; c++) {\r\n        try {\r\n            HashSet<Certificate> result = new HashSet();\r\n            if (selector != null) {\r\n                for (Object o : coll) {\r\n                    if ((o instanceof Certificate) && selector.match((Certificate) o))\r\n                        result.add((Certificate) o);\r\n                }\r\n            } else {\r\n                for (Object o : coll) {\r\n                    if (o instanceof Certificate)\r\n                        result.add((Certificate) o);\r\n                }\r\n            }\r\n            return (result);\r\n        } catch (ConcurrentModificationException e) {\r\n        }\r\n    }\r\n    throw new ConcurrentModificationException(\"Too many \" + \"ConcurrentModificationExceptions\");\r\n}"
}, {
	"Path": "android.icu.dev.test.format.TimeZoneFormatTest.TestDefaultTimeZoneNames",
	"Comment": "coverage for default implementation and abstract methods in base class.",
	"Method": "void TestDefaultTimeZoneNames(){\r\n    long date = System.currentTimeMillis();\r\n    TimeZoneNames.Factory factory;\r\n    try {\r\n        Class cls = Class.forName(\"android.icu.text.TimeZoneNames$DefaultTimeZoneNames$FactoryImpl\");\r\n        factory = (Factory) cls.newInstance();\r\n    } catch (Exception e) {\r\n        errln(\"Could not create class DefaultTimeZoneNames.FactoryImpl: \" + e.getClass() + \": \" + e.getMessage());\r\n        return;\r\n    }\r\n    TimeZoneNames tzn = factory.getTimeZoneNames(ULocale.ENGLISH);\r\n    assertEquals(\"Abstract: getAvailableMetaZoneIDs()\", tzn.getAvailableMetaZoneIDs(), Collections.emptySet());\r\n    assertEquals(\"Abstract: getAvailableMetaZoneIDs(String tzID)\", tzn.getAvailableMetaZoneIDs(\"America/Chicago\"), Collections.emptySet());\r\n    assertEquals(\"Abstract: getMetaZoneID(String tzID, long date)\", tzn.getMetaZoneID(\"America/Chicago\", date), null);\r\n    assertEquals(\"Abstract: getReferenceZoneID(String mzID, String region)\", tzn.getReferenceZoneID(\"America_Central\", \"IT\"), null);\r\n    assertEquals(\"Abstract: getMetaZoneDisplayName(String mzID, NameType type)\", tzn.getMetaZoneDisplayName(\"America_Central\", NameType.LONG_DAYLIGHT), null);\r\n    assertEquals(\"Abstract: getTimeZoneDisplayName(String mzID, NameType type)\", tzn.getTimeZoneDisplayName(\"America/Chicago\", NameType.LONG_DAYLIGHT), null);\r\n    assertEquals(\"Abstract: find(CharSequence text, int start, EnumSet<NameType> nameTypes)\", tzn.find(\"foo\", 0, EnumSet.noneOf(NameType.class)), Collections.emptyList());\r\n    tzn = new TimeZoneNamesInheriter();\r\n    try {\r\n        tzn.find(null, 0, null);\r\n    } catch (UnsupportedOperationException e) {\r\n        assertEquals(\"find() exception\", \"The method is not implemented in TimeZoneNames base class.\", e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceFieldUpdaterTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    x = one;\r\n    final AtomicReferenceFieldUpdater<AtomicReferenceFieldUpdaterTest, Integer> a;\r\n    a = updaterFor(\"x\");\r\n    Thread t = new Thread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!a.compareAndSet(AtomicReferenceFieldUpdaterTest.this, two, three)) Thread.yield();\r\n        }\r\n    });\r\n    t.start();\r\n    assertTrue(a.compareAndSet(this, one, two));\r\n    t.join(LONG_DELAY_MS);\r\n    assertFalse(t.isAlive());\r\n    assertSame(three, a.get(this));\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceFieldUpdaterTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    while (!a.compareAndSet(AtomicReferenceFieldUpdaterTest.this, two, three)) Thread.yield();\r\n}"
}, {
	"Path": "jsr166.ForkJoinPoolTest.testSubmitFailedPrivilegedExceptionAction",
	"Comment": "a submitted failed privileged exception action reports exception",
	"Method": "void testSubmitFailedPrivilegedExceptionAction(){\r\n    final Callable callable = Executors.callable(new PrivilegedExceptionAction() {\r\n        public Object run() {\r\n            throw new IndexOutOfBoundsException();\r\n        }\r\n    });\r\n    Runnable r = new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            ExecutorService e = new ForkJoinPool(1);\r\n            try (PoolCleaner cleaner = cleaner(e)) {\r\n                Future future = e.submit(callable);\r\n                try {\r\n                    future.get();\r\n                    shouldThrow();\r\n                } catch (ExecutionException success) {\r\n                    assertTrue(success.toString().contains(\"IndexOutOfBoundsException\"));\r\n                }\r\n            }\r\n        }\r\n    };\r\n    runWithPermissions(r, new RuntimePermission(\"modifyThread\"));\r\n}"
}, {
	"Path": "jsr166.ForkJoinPoolTest.testSubmitFailedPrivilegedExceptionAction",
	"Comment": "a submitted failed privileged exception action reports exception",
	"Method": "void testSubmitFailedPrivilegedExceptionAction(){\r\n    throw new IndexOutOfBoundsException();\r\n}"
}, {
	"Path": "jsr166.ForkJoinPoolTest.testSubmitFailedPrivilegedExceptionAction",
	"Comment": "a submitted failed privileged exception action reports exception",
	"Method": "void testSubmitFailedPrivilegedExceptionAction(){\r\n    ExecutorService e = new ForkJoinPool(1);\r\n    try (PoolCleaner cleaner = cleaner(e)) {\r\n        Future future = e.submit(callable);\r\n        try {\r\n            future.get();\r\n            shouldThrow();\r\n        } catch (ExecutionException success) {\r\n            assertTrue(success.toString().contains(\"IndexOutOfBoundsException\"));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testLongGetAndAccumulate",
	"Comment": "atomiclong getandaccumulate returns previous value and updateswith supplied function.",
	"Method": "void testLongGetAndAccumulate(){\r\n    AtomicLong a = new AtomicLong(1L);\r\n    assertEquals(1L, a.getAndAccumulate(2L, Long::sum));\r\n    assertEquals(3L, a.getAndAccumulate(3L, Long::sum));\r\n    assertEquals(6L, a.get());\r\n}"
}, {
	"Path": "java.io.PrintStream.format",
	"Comment": "writes a formatted string to this output stream using the specifiedformat string and arguments.",
	"Method": "PrintStream format(String format,Object args,PrintStream format,Locale l,String format,Object args){\r\n    try {\r\n        synchronized (this) {\r\n            ensureOpen();\r\n            if ((formatter == null) || (formatter.locale() != l))\r\n                formatter = new Formatter(WeakProxy.forObject(this), l);\r\n            formatter.format(l, format, args);\r\n        }\r\n    } catch (InterruptedIOException x) {\r\n        Thread.currentThread().interrupt();\r\n    } catch (IOException x) {\r\n        trouble = true;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "javax.xml.transform.TransformerException.getException",
	"Comment": "this method retrieves an exception that this exception wraps.",
	"Method": "Throwable getException(){\r\n    return containedException;\r\n}"
}, {
	"Path": "sun.security.util.SignatureFileVerifier.isBlockOrSF",
	"Comment": "utility method used by jarverifier and jarsignerto determine the signature file names and pkcs7 blockfiles names that are supported",
	"Method": "boolean isBlockOrSF(String s){\r\n    if (s.endsWith(\".SF\") || s.endsWith(\".DSA\") || s.endsWith(\".RSA\") || s.endsWith(\".EC\")) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "sun.security.jca.ProviderList.getServices",
	"Comment": "this method exists for compatibility with jce only. it will be removedonce jce has been changed to use the replacement method.",
	"Method": "List<Service> getServices(String type,String algorithm,List<Service> getServices,String type,List<String> algorithms,List<Service> getServices,List<ServiceId> ids){\r\n    return new ServiceList(ids);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.CaptureInfo.getImplicitPrefixParams",
	"Comment": "returns all the implicit params that come before explicit params in a constructor.",
	"Method": "Iterable<VariableElement> getImplicitPrefixParams(TypeElement type){\r\n    return Iterables.transform(getCaptures(type), Capture::getParam);\r\n}"
}, {
	"Path": "java.time.Duration.toDays",
	"Comment": "gets the number of days in this duration.this returns the total number of days in the duration by dividing thenumber of seconds by 86400.this is based on the standard definition of a day as 24 hours.this instance is immutable and unaffected by this method call.",
	"Method": "long toDays(){\r\n    return seconds / SECONDS_PER_DAY;\r\n}"
}, {
	"Path": "sun.security.util.DerOutputStream.writeString",
	"Comment": "private helper routine for writing der encoded string values.",
	"Method": "void writeString(String s,byte stringTag,String enc){\r\n    byte[] data = s.getBytes(enc);\r\n    write(stringTag);\r\n    putLength(data.length);\r\n    write(data);\r\n}"
}, {
	"Path": "java.math.BigInteger.squareToLen",
	"Comment": "squares the contents of the int array x. the result is placed into theint array z.the contents of x are not changed.",
	"Method": "int[] squareToLen(int[] x,int len,int[] z){\r\n    int zlen = len << 1;\r\n    if (z == null || z.length < zlen)\r\n        z = new int[zlen];\r\n    int lastProductLowWord = 0;\r\n    for (int j = 0, i = 0; j < len; j++) {\r\n        long piece = (x[j] & LONG_MASK);\r\n        long product = piece * piece;\r\n        z[i++] = (lastProductLowWord << 31) | (int) (product >>> 33);\r\n        z[i++] = (int) (product >>> 1);\r\n        lastProductLowWord = (int) product;\r\n    }\r\n    for (int i = len, offset = 1; i > 0; i--, offset += 2) {\r\n        int t = x[i - 1];\r\n        t = mulAdd(z, x, offset, i - 1, t);\r\n        addOne(z, offset - 1, i, t);\r\n    }\r\n    primitiveLeftShift(z, zlen, 1);\r\n    z[zlen - 1] |= x[len - 1] & 1;\r\n    return z;\r\n}"
}, {
	"Path": "android.icu.dev.test.lang.UCharacterTest.TestXSymbolTable",
	"Comment": "tests the class abstract public static class xsymboltable implements symboltable",
	"Method": "void TestXSymbolTable(){\r\n    class MyXSymbolTable extends UnicodeSet.XSymbolTable {\r\n    }\r\n    MyXSymbolTable st = new MyXSymbolTable();\r\n    if (st.lookupMatcher(0) != null)\r\n        errln(\"XSymbolTable.lookupMatcher(int i) was suppose to return null.\");\r\n    if (st.applyPropertyAlias(\"\", \"\", new UnicodeSet()) != false)\r\n        errln(\"XSymbolTable.applyPropertyAlias(String propertyName, String propertyValue, UnicodeSet result) was suppose to return false.\");\r\n    if (st.lookup(\"\") != null)\r\n        errln(\"XSymbolTable.lookup(String s) was suppose to return null.\");\r\n    if (st.parseReference(\"\", null, 0) != null)\r\n        errln(\"XSymbolTable.parseReference(String text, ParsePosition pos, int limit) was suppose to return null.\");\r\n}"
}, {
	"Path": "java.util.UUID.compareTo",
	"Comment": "compares this uuid with the specified uuid. the first of two uuids is greater than the second if the mostsignificant field in which the uuids differ is greater for the firstuuid.",
	"Method": "int compareTo(UUID val){\r\n    return (this.mostSigBits < val.mostSigBits ? -1 : (this.mostSigBits > val.mostSigBits ? 1 : (this.leastSigBits < val.leastSigBits ? -1 : (this.leastSigBits > val.leastSigBits ? 1 : 0))));\r\n}"
}, {
	"Path": "java.security.KeyStore.entryInstanceOf",
	"Comment": "determines if the keystore entry for the specifiedalias is an instance or subclass of the specifiedentryclass.",
	"Method": "boolean entryInstanceOf(String alias,Class<? extends KeyStore.Entry> entryClass){\r\n    if (alias == null || entryClass == null) {\r\n        throw new NullPointerException(\"invalid null input\");\r\n    }\r\n    if (!initialized) {\r\n        throw new KeyStoreException(\"Uninitialized keystore\");\r\n    }\r\n    return keyStoreSpi.engineEntryInstanceOf(alias, entryClass);\r\n}"
}, {
	"Path": "java.io.PushbackReader.mark",
	"Comment": "marks the present position in the stream. the markfor class pushbackreader always throws an exception.",
	"Method": "void mark(int readAheadLimit){\r\n    throw new IOException(\"mark/reset not supported\");\r\n}"
}, {
	"Path": "java.util.RegularEnumSet.containsAll",
	"Comment": "returns true if this set contains all of the elementsin the specified collection.",
	"Method": "boolean containsAll(Collection<?> c){\r\n    if (!(c instanceof RegularEnumSet))\r\n        return super.containsAll(c);\r\n    RegularEnumSet es = (RegularEnumSet) c;\r\n    if (es.elementType != elementType)\r\n        return es.isEmpty();\r\n    return (es.elements & ~elements) == 0;\r\n}"
}, {
	"Path": "java.text.NumberFormat.getMinimumIntegerDigits",
	"Comment": "returns the minimum number of digits allowed in the integer portion of anumber.",
	"Method": "int getMinimumIntegerDigits(){\r\n    return minimumIntegerDigits;\r\n}"
}, {
	"Path": "java.util.concurrent.Semaphore.availablePermits",
	"Comment": "returns the current number of permits available in this semaphore.this method is typically used for debugging and testing purposes.",
	"Method": "int availablePermits(){\r\n    return sync.getPermits();\r\n}"
}, {
	"Path": "java.util.AbstractCollection.finishToArray",
	"Comment": "reallocates the array being used within toarray when the iteratorreturned more elements than expected, and finishes filling it fromthe iterator.",
	"Method": "T[] finishToArray(T[] r,Iterator<?> it){\r\n    int i = r.length;\r\n    while (it.hasNext()) {\r\n        int cap = r.length;\r\n        if (i == cap) {\r\n            int newCap = cap + (cap >> 1) + 1;\r\n            if (newCap - MAX_ARRAY_SIZE > 0)\r\n                newCap = hugeCapacity(cap + 1);\r\n            r = Arrays.copyOf(r, newCap);\r\n        }\r\n        r[i++] = (T) it.next();\r\n    }\r\n    return (i == r.length) ? r : Arrays.copyOf(r, i);\r\n}"
}, {
	"Path": "java.util.stream.Node.truncate",
	"Comment": "return a node describing a subsequence of the elements of this node,starting at the given inclusive start offset and ending at the givenexclusive end offset.",
	"Method": "Node<T> truncate(long from,long to,IntFunction<T[]> generator,T_NODE truncate,long from,long to,IntFunction<T[]> generator,Node.OfInt truncate,long from,long to,IntFunction<Integer[]> generator,Node.OfLong truncate,long from,long to,IntFunction<Long[]> generator,Node.OfDouble truncate,long from,long to,IntFunction<Double[]> generator){\r\n    if (from == 0 && to == count())\r\n        return this;\r\n    Spliterator<T> spliterator = spliterator();\r\n    long size = to - from;\r\n    Node.Builder<T> nodeBuilder = Nodes.builder(size, generator);\r\n    nodeBuilder.begin(size);\r\n    for (int i = 0; i < from && spliterator.tryAdvance(e -> {\r\n    }); i++) {\r\n    }\r\n    for (int i = 0; (i < size) && spliterator.tryAdvance(nodeBuilder); i++) {\r\n    }\r\n    nodeBuilder.end();\r\n    return nodeBuilder.build();\r\n}"
}, {
	"Path": "java.util.stream.AbstractPipeline.getStreamFlags",
	"Comment": "returns the composition of stream flags of the stream source and allintermediate operations.",
	"Method": "int getStreamFlags(){\r\n    return StreamOpFlag.toStreamFlags(combinedFlags);\r\n}"
}, {
	"Path": "java.util.stream.SliceOps.sliceSpliterator",
	"Comment": "creates a slice spliterator given a stream shape governing thespliterator type.requires that the underlying spliteratorbe subsized.",
	"Method": "Spliterator<P_IN> sliceSpliterator(StreamShape shape,Spliterator<P_IN> s,long skip,long limit){\r\n    assert s.hasCharacteristics(Spliterator.SUBSIZED);\r\n    long sliceFence = calcSliceFence(skip, limit);\r\n    switch(shape) {\r\n        case REFERENCE:\r\n            return new StreamSpliterators.SliceSpliterator.OfRef(s, skip, sliceFence);\r\n        case INT_VALUE:\r\n            return (Spliterator<P_IN>) new StreamSpliterators.SliceSpliterator.OfInt((Spliterator.OfInt) s, skip, sliceFence);\r\n        case LONG_VALUE:\r\n            return (Spliterator<P_IN>) new StreamSpliterators.SliceSpliterator.OfLong((Spliterator.OfLong) s, skip, sliceFence);\r\n        case DOUBLE_VALUE:\r\n            return (Spliterator<P_IN>) new StreamSpliterators.SliceSpliterator.OfDouble((Spliterator.OfDouble) s, skip, sliceFence);\r\n        default:\r\n            throw new IllegalStateException(\"Unknown shape \" + shape);\r\n    }\r\n}"
}, {
	"Path": "sun.security.util.DerIndefLenConverter.writeLengthAndValue",
	"Comment": "write the length and if it is an indefinite lengththen calculate the definite length from the positionsof the indefinite length and its matching eoc terminator.then, write the value.",
	"Method": "void writeLengthAndValue(){\r\n    if (dataPos == dataSize)\r\n        return;\r\n    int curLen = 0;\r\n    int lenByte = data[dataPos++] & 0xff;\r\n    if (isIndefinite(lenByte)) {\r\n        byte[] lenBytes = (byte[]) ndefsList.get(index++);\r\n        System.arraycopy(lenBytes, 0, newData, newDataPos, lenBytes.length);\r\n        newDataPos += lenBytes.length;\r\n        return;\r\n    }\r\n    if (isLongForm(lenByte)) {\r\n        lenByte &= LEN_MASK;\r\n        for (int i = 0; i < lenByte; i++) {\r\n            curLen = (curLen << 8) + (data[dataPos++] & 0xff);\r\n        }\r\n        if (curLen < 0) {\r\n            throw new IOException(\"Invalid length bytes\");\r\n        }\r\n    } else {\r\n        curLen = (lenByte & LEN_MASK);\r\n    }\r\n    writeLength(curLen);\r\n    writeValue(curLen);\r\n}"
}, {
	"Path": "java.util.concurrent.locks.ReentrantLock.getWaitQueueLength",
	"Comment": "returns an estimate of the number of threads waiting on thegiven condition associated with this lock. note that becausetimeouts and interrupts may occur at any time, the estimateserves only as an upper bound on the actual number of waiters.this method is designed for use in monitoring of the systemstate, not for synchronization control.",
	"Method": "int getWaitQueueLength(Condition condition){\r\n    if (condition == null)\r\n        throw new NullPointerException();\r\n    if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))\r\n        throw new IllegalArgumentException(\"not owner\");\r\n    return sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject) condition);\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinPool.inactivate",
	"Comment": "if worker w exists and is active, enqueues and sets status to inactive.",
	"Method": "void inactivate(WorkQueue w,int ss){\r\n    int ns = (ss + SS_SEQ) | UNSIGNALLED;\r\n    long lc = ns & SP_MASK, nc, c;\r\n    if (w != null) {\r\n        w.scanState = ns;\r\n        do {\r\n            nc = lc | (UC_MASK & ((c = ctl) - AC_UNIT));\r\n            w.stackPred = (int) c;\r\n        } while (!U.compareAndSwapLong(this, CTL, c, nc));\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.ZipOutputStream.write",
	"Comment": "writes an array of bytes to the current zip entry data. this methodwill block until all the bytes are written.",
	"Method": "void write(byte[] b,int off,int len){\r\n    ensureOpen();\r\n    if (off < 0 || len < 0 || off > b.length - len) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (len == 0) {\r\n        return;\r\n    }\r\n    if (current == null) {\r\n        throw new ZipException(\"no current ZIP entry\");\r\n    }\r\n    ZipEntry entry = current.entry;\r\n    switch(entry.method) {\r\n        case DEFLATED:\r\n            super.write(b, off, len);\r\n            break;\r\n        case STORED:\r\n            written += len;\r\n            if (written - locoff > entry.size) {\r\n                throw new ZipException(\"attempt to write past end of STORED entry\");\r\n            }\r\n            out.write(b, off, len);\r\n            break;\r\n        default:\r\n            throw new ZipException(\"invalid compression method\");\r\n    }\r\n    crc.update(b, off, len);\r\n}"
}, {
	"Path": "java.util.concurrent.ArrayBlockingQueue.offer",
	"Comment": "inserts the specified element at the tail of this queue, waitingup to the specified wait time for space to become available ifthe queue is full.",
	"Method": "boolean offer(E e,boolean offer,E e,long timeout,TimeUnit unit){\r\n    Objects.requireNonNull(e);\r\n    long nanos = unit.toNanos(timeout);\r\n    final ReentrantLock lock = this.lock;\r\n    lock.lockInterruptibly();\r\n    try {\r\n        while (count == items.length) {\r\n            if (nanos <= 0L)\r\n                return false;\r\n            nanos = notFull.awaitNanos(nanos);\r\n        }\r\n        enqueue(e);\r\n        return true;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.StreamHandler.isLoggable",
	"Comment": "check if this handler would actually log a given logrecord.this method checks if the logrecord has an appropriate level andwhether it satisfies any filter.it will also return false ifno output stream has been assigned yet or the logrecord is null.",
	"Method": "boolean isLoggable(LogRecord record){\r\n    if (writer == null || record == null) {\r\n        return false;\r\n    }\r\n    return super.isLoggable(record);\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceEntriesToInt",
	"Comment": "returns the result of accumulating the given transformationof all entries using the given reducer to combine values,and the given basis as an identity value.",
	"Method": "int reduceEntriesToInt(long parallelismThreshold,ToIntFunction<Map.Entry<K, V>> transformer,int basis,IntBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceEntriesToIntTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "org.apache.harmony.regex.tests.java.util.regex.PatternTest.testFlagsCompileDefault",
	"Comment": "check default flags when they are not specified in pattern. based on risince could not find that info",
	"Method": "void testFlagsCompileDefault(){\r\n    for (String pat : testPatternsAlt) {\r\n        try {\r\n            Pattern p = Pattern.compile(pat);\r\n            assertEquals(p.flags(), DEFAULT_FLAGS);\r\n        } catch (Exception e) {\r\n            fail(\"Unexpected exception: \" + e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.List.replaceAll",
	"Comment": "replaces each element of this list with the result of applying theoperator to that element.errors or runtime exceptions thrown bythe operator are relayed to the caller.",
	"Method": "void replaceAll(UnaryOperator<E> operator){\r\n    Objects.requireNonNull(operator);\r\n    final ListIterator<E> li = this.listIterator();\r\n    while (li.hasNext()) {\r\n        li.set(operator.apply(li.next()));\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceKeys",
	"Comment": "returns the result of accumulating the given transformationof all keys using the given reducer to combine values, ornull if none.",
	"Method": "K reduceKeys(long parallelismThreshold,BiFunction<? super K, ? super K, ? extends K> reducer,U reduceKeys,long parallelismThreshold,Function<? super K, ? extends U> transformer,BiFunction<? super U, ? super U, ? extends U> reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceKeysTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, reducer).invoke();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.GenerationTest.translateSourceFile",
	"Comment": "translate a java source file contents, returning the contents of eitherthe generated header or implementation file.",
	"Method": "String translateSourceFile(String typeName,String fileName,String translateSourceFile,String source,String typeName,String fileName){\r\n    return generateFromUnit(translateType(typeName, source), fileName);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.ElementUtil.isGlobalVar",
	"Comment": "returns whether this variable will be declared in global scope in objc.",
	"Method": "boolean isGlobalVar(VariableElement element){\r\n    return isStatic(element) || isPrimitiveConstant(element);\r\n}"
}, {
	"Path": "java.net.InetAddress.isSiteLocalAddress",
	"Comment": "utility routine to check if the inetaddress is a site local address.",
	"Method": "boolean isSiteLocalAddress(){\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testAddAll5",
	"Comment": "queue contains all elements, in traversal order, of successful addall",
	"Method": "void testAddAll5(){\r\n    Integer[] empty = new Integer[0];\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        ints[i] = i;\r\n    }\r\n    LinkedTransferQueue q = new LinkedTransferQueue();\r\n    assertFalse(q.addAll(Arrays.asList(empty)));\r\n    assertTrue(q.addAll(Arrays.asList(ints)));\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(ints[i], q.poll());\r\n    }\r\n}"
}, {
	"Path": "java.lang.reflect.Proxy.getProxyClass0",
	"Comment": "generate a proxy class.must call the checkproxyaccess methodto perform permission checks before calling this.",
	"Method": "Class<?> getProxyClass0(ClassLoader loader,Class<?> interfaces){\r\n    if (interfaces.length > 65535) {\r\n        throw new IllegalArgumentException(\"interface limit exceeded\");\r\n    }\r\n    Class<?> proxyClass = null;\r\n    String[] interfaceNames = new String[interfaces.length];\r\n    Set<Class<?>> interfaceSet = new HashSet();\r\n    for (int i = 0; i < interfaces.length; i++) {\r\n        String interfaceName = interfaces[i].getName();\r\n        Class<?> interfaceClass = null;\r\n        try {\r\n            interfaceClass = Class.forName(interfaceName, false, loader);\r\n        } catch (ClassNotFoundException e) {\r\n        }\r\n        if (interfaceClass != interfaces[i]) {\r\n            throw new IllegalArgumentException(interfaces[i] + \" is not visible from class loader\");\r\n        }\r\n        if (!interfaceClass.isInterface()) {\r\n            throw new IllegalArgumentException(interfaceClass.getName() + \" is not an interface\");\r\n        }\r\n        if (interfaceSet.contains(interfaceClass)) {\r\n            throw new IllegalArgumentException(\"repeated interface: \" + interfaceClass.getName());\r\n        }\r\n        interfaceSet.add(interfaceClass);\r\n        interfaceNames[i] = interfaceName;\r\n    }\r\n    List<String> key = Arrays.asList(interfaceNames);\r\n    Map<List<String>, Object> cache;\r\n    synchronized (loaderToCache) {\r\n        cache = loaderToCache.get(loader);\r\n        if (cache == null) {\r\n            cache = new HashMap();\r\n            loaderToCache.put(loader, cache);\r\n        }\r\n    }\r\n    synchronized (cache) {\r\n        do {\r\n            Object value = cache.get(key);\r\n            if (value instanceof Reference) {\r\n                proxyClass = (Class<?>) ((Reference<?>) value).get();\r\n            }\r\n            if (proxyClass != null) {\r\n                return proxyClass;\r\n            } else if (value == pendingGenerationMarker) {\r\n                try {\r\n                    cache.wait();\r\n                } catch (InterruptedException e) {\r\n                }\r\n                continue;\r\n            } else {\r\n                cache.put(key, pendingGenerationMarker);\r\n                break;\r\n            }\r\n        } while (true);\r\n    }\r\n    try {\r\n        String proxyPkg = null;\r\n        for (int i = 0; i < interfaces.length; i++) {\r\n            int flags = interfaces[i].getModifiers();\r\n            if (!Modifier.isPublic(flags)) {\r\n                String name = interfaces[i].getName();\r\n                int n = name.lastIndexOf('.');\r\n                String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1));\r\n                if (proxyPkg == null) {\r\n                    proxyPkg = pkg;\r\n                } else if (!pkg.equals(proxyPkg)) {\r\n                    throw new IllegalArgumentException(\"non-public interfaces from different packages\");\r\n                }\r\n            }\r\n        }\r\n        if (proxyPkg == null) {\r\n            proxyPkg = \"\";\r\n        }\r\n        {\r\n            final long num;\r\n            synchronized (nextUniqueNumberLock) {\r\n                num = nextUniqueNumber++;\r\n            }\r\n            String proxyName = proxyPkg + proxyClassNamePrefix + num;\r\n            proxyClass = generateProxy(proxyName, interfaces, loader);\r\n        }\r\n        proxyClasses.put(proxyClass, null);\r\n    } finally {\r\n        synchronized (cache) {\r\n            if (proxyClass != null) {\r\n                cache.put(key, new WeakReference<Class<?>>(proxyClass));\r\n            } else {\r\n                cache.remove(key);\r\n            }\r\n            cache.notifyAll();\r\n        }\r\n    }\r\n    return proxyClass;\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throwsnullpointerexception after possibly adding some elements",
	"Method": "void testAddAll3(){\r\n    LinkedTransferQueue q = new LinkedTransferQueue();\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = i;\r\n    try {\r\n        q.addAll(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.StatementGeneratorTest.testEmptyStatementFormatting",
	"Comment": "verify that empty statements line offset to owning statement is preserved.",
	"Method": "void testEmptyStatementFormatting(){\r\n    String translation = translateSourceFile(\"class Test {\\n\" + \"  void foo(int a, int b) {\\n\" + \"    if (a < b) ;\\n\" + \"  }\\n\" + \"  void bar(int c, int d) {\\n\" + \"    if (c < d)\\n\" + \"      ;\\n\" + \"  }}\", \"Test\", \"Test.m\");\r\n    assertTranslation(translation, \"if (a < b) ;\");\r\n    assertTranslatedLines(translation, \"if (c < d)\", \";\");\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.ExternalAnnotationInjectorTest.testInjectNullability_returnType_primitiveType",
	"Comment": "nullability specifiers should not be applied to primitive types.",
	"Method": "void testInjectNullability_returnType_primitiveType(){\r\n    options.setNullability(true);\r\n    String externalNullabilityAnnotations = \"package p: \" + \"annotation @NonNull: \" + \"class Test: \" + \"  method foo()Z:\" + \"    return: @p.NonNull \";\r\n    options.addExternalAnnotationFileContents(externalNullabilityAnnotations);\r\n    String source = \"package p;\" + \"public class Test { \" + \"  public boolean foo() { return true; } \" + \"}\";\r\n    String translation = translateSourceFile(source, \"p.Test\", \"p/Test.h\");\r\n    assertTranslation(translation, \"- (jboolean)foo;\");\r\n}"
}, {
	"Path": "jsr166.ConcurrentHashMapTest.testGenericComparable",
	"Comment": "elements of classes with erased generic type parameters basedon comparable can be inserted and found.",
	"Method": "void testGenericComparable(){\r\n    int size = 120;\r\n    ConcurrentHashMap<Object, Boolean> m = new ConcurrentHashMap<Object, Boolean>();\r\n    for (int i = 0; i < size; i++) {\r\n        BI bi = new BI(i);\r\n        BS bs = new BS(String.valueOf(i));\r\n        LexicographicList<BI> bis = new LexicographicList<BI>(bi);\r\n        LexicographicList<BS> bss = new LexicographicList<BS>(bs);\r\n        assertTrue(m.putIfAbsent(bis, true) == null);\r\n        assertTrue(m.containsKey(bis));\r\n        if (m.putIfAbsent(bss, true) == null)\r\n            assertTrue(m.containsKey(bss));\r\n        assertTrue(m.containsKey(bis));\r\n    }\r\n    for (int i = 0; i < size; i++) {\r\n        assertTrue(m.containsKey(Collections.singletonList(new BI(i))));\r\n    }\r\n}"
}, {
	"Path": "java.lang.ref.ReferenceQueue.poll",
	"Comment": "polls this queue to see if a reference object is available.if one isavailable without further delay then it is removed from the queue andreturned.otherwise this method immediately returns null.",
	"Method": "Reference<? extends T> poll(){\r\n    synchronized (lock) {\r\n        if (head == null)\r\n            return null;\r\n        return reallyPollLocked();\r\n    }\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testPhaseIncrement1",
	"Comment": "the phase number increments correctly when tripping the barrier",
	"Method": "void testPhaseIncrement1(){\r\n    for (int size = 1; size < nine; size++) {\r\n        final Phaser phaser = new Phaser(size);\r\n        for (int index = 0; index <= (1 << size); index++) {\r\n            int phase = phaser.arrive();\r\n            assertTrue(index % size == 0 ? (index / size) == phase : index - (phase * size) > 0);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.time.zone.ZoneOffsetTransition.getOffsetBefore",
	"Comment": "gets the offset before the transition.this is the offset in use before the instant of the transition.",
	"Method": "ZoneOffset getOffsetBefore(){\r\n    return offsetBefore;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberRegressionTests.Test4106662",
	"Comment": "decimalformat.parse returns 0 if string parameter is incorrect.",
	"Method": "void Test4106662(){\r\n    DecimalFormat df = new DecimalFormat();\r\n    String text = \"x\";\r\n    ParsePosition pos1 = new ParsePosition(0), pos2 = new ParsePosition(0);\r\n    logln(\"pattern: \\\"\" + df.toPattern() + \"\\\"\");\r\n    Number num = df.parse(text, pos1);\r\n    if (num != null) {\r\n        errln(\"Test Failed: \\\"\" + text + \"\\\" is parsed as \" + num);\r\n    }\r\n    df = null;\r\n    df = new DecimalFormat(\"$###.00\");\r\n    num = df.parse(\"$\", pos2);\r\n    if (num != null) {\r\n        errln(\"Test Failed: \\\"$\\\" is parsed as \" + num);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ConcurrentHashMapTest.testComparableFamily",
	"Comment": "inserted elements that are subclasses of the same comparableclass are found.",
	"Method": "void testComparableFamily(){\r\n    int size = 500;\r\n    ConcurrentHashMap<BI, Boolean> m = new ConcurrentHashMap<BI, Boolean>();\r\n    for (int i = 0; i < size; i++) {\r\n        assertTrue(m.put(new CI(i), true) == null);\r\n    }\r\n    for (int i = 0; i < size; i++) {\r\n        assertTrue(m.containsKey(new CI(i)));\r\n        assertTrue(m.containsKey(new DI(i)));\r\n    }\r\n}"
}, {
	"Path": "java.io.InputStream.markSupported",
	"Comment": "tests if this input stream supports the mark andreset methods. whether or not mark andreset are supported is an invariant property of aparticular input stream instance. the marksupported methodof inputstream returns false.",
	"Method": "boolean markSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "java.util.zip.Deflater.finished",
	"Comment": "returns true if the end of the compressed data output stream hasbeen reached.",
	"Method": "boolean finished(){\r\n    synchronized (zsRef) {\r\n        return finished;\r\n    }\r\n}"
}, {
	"Path": "java.util.jar.Attributes.values",
	"Comment": "returns a collection view of the attribute values contained in this map.",
	"Method": "Collection<Object> values(){\r\n    return map.values();\r\n}"
}, {
	"Path": "javax.crypto.CipherOutputStream.close",
	"Comment": "closes this output stream and releases any system resourcesassociated with this stream.this method invokes the dofinal method of the encapsulatedcipher object, which causes any bytes buffered by the encapsulatedcipher to be processed. the result is written out by calling theflush method of this output stream.this method resets the encapsulated cipher object to its initial stateand calls the close method of the underlying outputstream.",
	"Method": "void close(){\r\n    try {\r\n        obuffer = cipher.doFinal();\r\n    } catch (IllegalBlockSizeException e) {\r\n        obuffer = null;\r\n    } catch (BadPaddingException e) {\r\n        obuffer = null;\r\n    }\r\n    try {\r\n        flush();\r\n    } catch (IOException ignored) {\r\n    }\r\n    out.close();\r\n}"
}, {
	"Path": "jsr166.ArrayDequeTest.testSerialization",
	"Comment": "a deserialized serialized deque has same elements in same order",
	"Method": "void testSerialization(){\r\n    if (ReflectionUtil.isJreReflectionStripped()) {\r\n        return;\r\n    }\r\n    Queue x = populatedDeque(SIZE);\r\n    Queue y = serialClone(x);\r\n    assertNotSame(y, x);\r\n    assertEquals(x.size(), y.size());\r\n    assertEquals(x.toString(), y.toString());\r\n    assertTrue(Arrays.equals(x.toArray(), y.toArray()));\r\n    while (!x.isEmpty()) {\r\n        assertFalse(y.isEmpty());\r\n        assertEquals(x.remove(), y.remove());\r\n    }\r\n    assertTrue(y.isEmpty());\r\n}"
}, {
	"Path": "libcore.javax.net.ssl.TestSSLContext.create",
	"Comment": "testsslcontext creation method that allows separate creation of client and server key store",
	"Method": "TestSSLContext create(TestSSLContext create,KeyStore clientKeyStore,char[] clientStorePassword,KeyStore serverKeyStore,char[] serverStorePassword,KeyManager[] clientKeyManagers,KeyManager[] serverKeyManagers,TrustManager clientTrustManagers,TrustManager serverTrustManagers,SSLContext clientContext,SSLContext serverContext){\r\n    try {\r\n        SSLServerSocket serverSocket = (SSLServerSocket) serverContext.getServerSocketFactory().createServerSocket(0);\r\n        InetAddress host = InetAddress.getLocalHost();\r\n        int port = serverSocket.getLocalPort();\r\n        return new TestSSLContext(clientKeyStore, clientStorePassword, serverKeyStore, serverStorePassword, clientKeyManagers, serverKeyManagers, (X509ExtendedTrustManager) clientTrustManagers, (X509ExtendedTrustManager) serverTrustManagers, clientContext, serverContext, serverSocket, host, port);\r\n    } catch (RuntimeException e) {\r\n        throw e;\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "java.lang.Enum.getSharedConstants",
	"Comment": "returns a shared, mutable array containing the constants of this enum. itis an error to modify the returned array.",
	"Method": "T[] getSharedConstants(Class<T> enumType){\r\n    return (T[]) sharedConstantsCache.get(enumType);\r\n}"
}, {
	"Path": "java.util.LinkedHashMap.containsValue",
	"Comment": "returns true if this map maps one or more keys to thespecified value.",
	"Method": "boolean containsValue(Object value){\r\n    if (value == null) {\r\n        for (LinkedHashMapEntry e = header.after; e != header; e = e.after) if (e.value == null)\r\n            return true;\r\n    } else {\r\n        for (LinkedHashMapEntry e = header.after; e != header; e = e.after) if (value.equals(e.value))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "sun.security.pkcs.PKCS9Attributes.encode",
	"Comment": "put the der encoding of this pkcs9 attribute set on anderoutputstream, tagged with the given implicit tag.",
	"Method": "void encode(byte tag,OutputStream out){\r\n    out.write(tag);\r\n    out.write(derEncoding, 1, derEncoding.length - 1);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testForkHelpQuiesce",
	"Comment": "helpquiesce returns when tasks are complete.getqueuedtaskcount returns 0 when quiescent",
	"Method": "void testForkHelpQuiesce(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FibAction f = new FibAction(8);\r\n            assertSame(f, f.fork());\r\n            helpQuiesce();\r\n            while (!f.isDone()) ;\r\n            assertEquals(21, f.result);\r\n            assertEquals(0, getQueuedTaskCount());\r\n            checkCompletedNormally(f);\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testForkHelpQuiesce",
	"Comment": "helpquiesce returns when tasks are complete.getqueuedtaskcount returns 0 when quiescent",
	"Method": "void testForkHelpQuiesce(){\r\n    FibAction f = new FibAction(8);\r\n    assertSame(f, f.fork());\r\n    helpQuiesce();\r\n    while (!f.isDone()) ;\r\n    assertEquals(21, f.result);\r\n    assertEquals(0, getQueuedTaskCount());\r\n    checkCompletedNormally(f);\r\n}"
}, {
	"Path": "java.security.cert.X509CRL.getRevokedCertificate",
	"Comment": "get the crl entry, if any, for the given certificate.this method can be used to lookup crl entries in indirect crls,that means crls that contain entries from issuers other than the crlissuer. the default implementation will only return entries forcertificates issued by the crl issuer. subclasses that wish tosupport indirect crls should override this method.",
	"Method": "X509CRLEntry getRevokedCertificate(BigInteger serialNumber,X509CRLEntry getRevokedCertificate,X509Certificate certificate){\r\n    X500Principal certIssuer = certificate.getIssuerX500Principal();\r\n    X500Principal crlIssuer = getIssuerX500Principal();\r\n    if (certIssuer.equals(crlIssuer) == false) {\r\n        return null;\r\n    }\r\n    return getRevokedCertificate(certificate.getSerialNumber());\r\n}"
}, {
	"Path": "sun.security.x509.ExtendedKeyUsageExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(USAGES);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "java.util.logging.Logger.getResourceBundle",
	"Comment": "retrieve the localization resource bundle for thislogger for the current default locale.note that ifthe result is null, then the logger will use a resourcebundle inherited from its parent.",
	"Method": "ResourceBundle getResourceBundle(){\r\n    return findResourceBundle(getResourceBundleName(), true);\r\n}"
}, {
	"Path": "java.net.Inet4Address.isAnyLocalAddress",
	"Comment": "utility routine to check if the inetaddress in a wildcard address.",
	"Method": "boolean isAnyLocalAddress(){\r\n    return holder().getAddress() == 0;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.ConstraintsChecker.mergeBasicConstraints",
	"Comment": "merges the specified maxpathlength with the pathlenconstraintobtained from the certificate.",
	"Method": "int mergeBasicConstraints(X509Certificate cert,int maxPathLength){\r\n    int pathLenConstraint = cert.getBasicConstraints();\r\n    if (!X509CertImpl.isSelfIssued(cert)) {\r\n        maxPathLength--;\r\n    }\r\n    if (pathLenConstraint < maxPathLength) {\r\n        maxPathLength = pathLenConstraint;\r\n    }\r\n    return maxPathLength;\r\n}"
}, {
	"Path": "java.lang.reflect.Array.set",
	"Comment": "sets the value of the indexed component of the specified arrayobject to the specified new value.the new value is firstautomatically unwrapped if the array has a primitive componenttype.",
	"Method": "void set(Object array,int index,Object value){\r\n    if (!array.getClass().isArray()) {\r\n        throw notAnArray(array);\r\n    }\r\n    if (array instanceof Object[]) {\r\n        if (value != null && !array.getClass().getComponentType().isInstance(value)) {\r\n            throw incompatibleType(array);\r\n        }\r\n        ((Object[]) array)[index] = value;\r\n    } else {\r\n        if (value == null) {\r\n            throw new IllegalArgumentException(\"Primitive array can't take null values.\");\r\n        }\r\n        if (value instanceof Boolean) {\r\n            setBoolean(array, index, ((Boolean) value).booleanValue());\r\n        } else if (value instanceof Byte) {\r\n            setByte(array, index, ((Byte) value).byteValue());\r\n        } else if (value instanceof Character) {\r\n            setChar(array, index, ((Character) value).charValue());\r\n        } else if (value instanceof Short) {\r\n            setShort(array, index, ((Short) value).shortValue());\r\n        } else if (value instanceof Integer) {\r\n            setInt(array, index, ((Integer) value).intValue());\r\n        } else if (value instanceof Long) {\r\n            setLong(array, index, ((Long) value).longValue());\r\n        } else if (value instanceof Float) {\r\n            setFloat(array, index, ((Float) value).floatValue());\r\n        } else if (value instanceof Double) {\r\n            setDouble(array, index, ((Double) value).doubleValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.JSR166TestCase.sleep",
	"Comment": "sleeps until the given time has elapsed.throws assertionfailederror if interrupted.",
	"Method": "void sleep(long millis){\r\n    try {\r\n        delay(millis);\r\n    } catch (InterruptedException fail) {\r\n        AssertionFailedError afe = new AssertionFailedError(\"Unexpected InterruptedException\");\r\n        afe.initCause(fail);\r\n        throw afe;\r\n    }\r\n}"
}, {
	"Path": "libcore.java.util.CalendarTest.test_nullLocale_GregorianCalendar_Locale",
	"Comment": "here. we should add a targetsdkversion based check and throw for this case.",
	"Method": "void test_nullLocale_GregorianCalendar_Locale(){\r\n    assertCalendarConfigEquals(new GregorianCalendar(Locale.getDefault()), new GregorianCalendar((Locale) null));\r\n}"
}, {
	"Path": "sun.security.x509.IssuerAlternativeNameExtension.toString",
	"Comment": "returns a printable representation of the issueralternativename.",
	"Method": "String toString(){\r\n    String result = super.toString() + \"IssuerAlternativeName [\\n\";\r\n    if (names == null) {\r\n        result += \"  null\\n\";\r\n    } else {\r\n        for (GeneralName name : names.names()) {\r\n            result += \"  \" + name + \"\\n\";\r\n        }\r\n    }\r\n    result += \"]\\n\";\r\n    return result;\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testSerialization",
	"Comment": "a serialized aqs deserializes with current state, but no queued threads",
	"Method": "void testSerialization(){\r\n    if (ReflectionUtil.isJreReflectionStripped()) {\r\n        return;\r\n    }\r\n    Mutex sync = new Mutex();\r\n    assertFalse(serialClone(sync).isHeldExclusively());\r\n    sync.acquire();\r\n    Thread t = newStartedThread(new InterruptedSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t);\r\n    assertTrue(sync.isHeldExclusively());\r\n    Mutex clone = serialClone(sync);\r\n    assertTrue(clone.isHeldExclusively());\r\n    assertHasExclusiveQueuedThreads(sync, t);\r\n    assertHasExclusiveQueuedThreads(clone, NO_THREADS);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n    sync.release();\r\n    assertFalse(sync.isHeldExclusively());\r\n    assertTrue(clone.isHeldExclusively());\r\n    assertHasExclusiveQueuedThreads(sync, NO_THREADS);\r\n    assertHasExclusiveQueuedThreads(clone, NO_THREADS);\r\n}"
}, {
	"Path": "java.math.BigInteger.leftShift",
	"Comment": "left shift int array a up to len by n bits. returns the array thatresults from the shift since space may have to be reallocated.",
	"Method": "int[] leftShift(int[] a,int len,int n){\r\n    int nInts = n >>> 5;\r\n    int nBits = n & 0x1F;\r\n    int bitsInHighWord = bitLengthForInt(a[0]);\r\n    if (n <= (32 - bitsInHighWord)) {\r\n        primitiveLeftShift(a, len, nBits);\r\n        return a;\r\n    } else {\r\n        if (nBits <= (32 - bitsInHighWord)) {\r\n            int[] result = new int[nInts + len];\r\n            System.arraycopy(a, 0, result, 0, len);\r\n            primitiveLeftShift(result, result.length, nBits);\r\n            return result;\r\n        } else {\r\n            int[] result = new int[nInts + len + 1];\r\n            System.arraycopy(a, 0, result, 0, len);\r\n            primitiveRightShift(result, result.length, 32 - nBits);\r\n            return result;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "javax.crypto.Mac.clone",
	"Comment": "returns a clone if the provider implementation is cloneable.",
	"Method": "Object clone(){\r\n    chooseFirstProvider();\r\n    Mac that = (Mac) super.clone();\r\n    that.spi = (MacSpi) this.spi.clone();\r\n    return that;\r\n}"
}, {
	"Path": "sun.security.x509.X509CRLEntryImpl.toImpl",
	"Comment": "utility method to convert an arbitrary instance of x509crlentryto a x509crlentryimpl. does a cast if possible, otherwise reparsesthe encoding.",
	"Method": "X509CRLEntryImpl toImpl(X509CRLEntry entry){\r\n    if (entry instanceof X509CRLEntryImpl) {\r\n        return (X509CRLEntryImpl) entry;\r\n    } else {\r\n        return new X509CRLEntryImpl(entry.getEncoded());\r\n    }\r\n}"
}, {
	"Path": "java.awt.font.TextAttribute.readResolve",
	"Comment": "resolves instances being deserialized to the predefined constants.",
	"Method": "Object readResolve(){\r\n    if (this.getClass() != TextAttribute.class) {\r\n        throw new InvalidObjectException(\"subclass didn't correctly implement readResolve\");\r\n    }\r\n    TextAttribute instance = (TextAttribute) instanceMap.get(getName());\r\n    if (instance != null) {\r\n        return instance;\r\n    } else {\r\n        throw new InvalidObjectException(\"unknown attribute name\");\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.LogManager.addLogger",
	"Comment": "add a named logger.this does nothing and returns false if a loggerwith the same name is already registered.the logger factory methods call this method to register eachnewly created logger.the application should retain its own reference to the loggerobject to avoid it being garbage collected.the logmanagermay only retain a weak reference.",
	"Method": "boolean addLogger(Logger logger){\r\n    final String name = logger.getName();\r\n    if (name == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    drainLoggerRefQueueBounded();\r\n    LoggerContext cx = getUserContext();\r\n    if (cx.addLocalLogger(logger, this)) {\r\n        loadLoggerHandlers(logger, name, name + \".handlers\");\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.ast.MethodReferenceTest.testCreationReferenceBlockWrapper",
	"Comment": "test the creation of explicit blocks for lambdas with expression bodies.",
	"Method": "void testCreationReferenceBlockWrapper(){\r\n    String creationReferenceHeader = \"class I { I() { } I(int x) { } I(int x, I j, String s, Object o) { } }\\n\" + \"interface FunInt<T> { T apply(int x); }\" + \"interface FunInt4<T> { T apply(int x, I j, String s, Object o); }\" + \"interface Call<T> { T call(); }\";\r\n    String noArgumentTranslation = translateSourceFile(creationReferenceHeader + \"class Test { Call<I> iInit = I::new; }\", \"Test\", \"Test.m\");\r\n    assertTranslatedLines(noArgumentTranslation, \"- (id)call {\", \"  return create_I_init();\", \"}\");\r\n    String oneArgumentTranslation = translateSourceFile(creationReferenceHeader + \"class Test { FunInt<I> iInit2 = I::new; }\", \"Test\", \"Test.m\");\r\n    assertTranslatedLines(oneArgumentTranslation, \"- (id)applyWithInt:(jint)a {\", \"  return create_I_initWithInt_(a);\", \"}\");\r\n    String mixedArgumentTranslation = translateSourceFile(creationReferenceHeader + \"class Test { FunInt4<I> iInit3 = I::new; }\", \"Test\", \"Test.m\");\r\n    assertTranslatedLines(mixedArgumentTranslation, \"- (id)applyWithInt:(jint)a\", \"             withI:(I *)b\", \"      withNSString:(NSString *)c\", \"            withId:(id)d {\", \"  return create_I_initWithInt_withI_withNSString_withId_(a, b, c, d);\", \"}\");\r\n}"
}, {
	"Path": "java.security.Provider.removeInvalidServices",
	"Comment": "remove all invalid services from the map. invalid services can onlyoccur if the legacy properties are inconsistent or incomplete.",
	"Method": "void removeInvalidServices(Map<ServiceKey, Service> map){\r\n    for (Iterator t = map.entrySet().iterator(); t.hasNext(); ) {\r\n        Map.Entry entry = (Map.Entry) t.next();\r\n        Service s = (Service) entry.getValue();\r\n        if (s.isValid() == false) {\r\n            t.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.text.MessageFormat.getFormatsByArgumentIndex",
	"Comment": "gets the formats used for the values passed intoformat methods or returned from parsemethods. the indices of elements in the returned arraycorrespond to the argument indices used in the previously setpattern string.the order of formats in the returned array thus corresponds tothe order of elements in the arguments array passedto the format methods or the result array returnedby the parse methods.if an argument index is used for more than one format elementin the pattern string, then the format used for the last suchformat element is returned in the array. if an argument indexis not used for any format element in the pattern string, thennull is returned in the array.",
	"Method": "Format[] getFormatsByArgumentIndex(){\r\n    int maximumArgumentNumber = -1;\r\n    for (int i = 0; i <= maxOffset; i++) {\r\n        if (argumentNumbers[i] > maximumArgumentNumber) {\r\n            maximumArgumentNumber = argumentNumbers[i];\r\n        }\r\n    }\r\n    Format[] resultArray = new Format[maximumArgumentNumber + 1];\r\n    for (int i = 0; i <= maxOffset; i++) {\r\n        resultArray[argumentNumbers[i]] = formats[i];\r\n    }\r\n    return resultArray;\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkGetSingleton",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGetSingleton(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FailingAsyncFib f = new FailingAsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get();\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkGetSingleton",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGetSingleton(){\r\n    FailingAsyncFib f = new FailingAsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get();\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n}"
}, {
	"Path": "jsr166.DelayQueueTest.populatedQueue",
	"Comment": "returns a new queue of given size containing consecutivepdelays 0 ... n.",
	"Method": "DelayQueue<PDelay> populatedQueue(int n){\r\n    DelayQueue<PDelay> q = new DelayQueue<PDelay>();\r\n    assertTrue(q.isEmpty());\r\n    for (int i = n - 1; i >= 0; i -= 2) assertTrue(q.offer(new PDelay(i)));\r\n    for (int i = (n & 1); i < n; i += 2) assertTrue(q.offer(new PDelay(i)));\r\n    assertFalse(q.isEmpty());\r\n    assertEquals(Integer.MAX_VALUE, q.remainingCapacity());\r\n    assertEquals(n, q.size());\r\n    return q;\r\n}"
}, {
	"Path": "java.security.cert.PKIXCertPathValidatorResult.getTrustAnchor",
	"Comment": "returns the trustanchor describing the ca that servedas a trust anchor for the certification path.",
	"Method": "TrustAnchor getTrustAnchor(){\r\n    return trustAnchor;\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicReferenceArray.toString",
	"Comment": "returns the string representation of the current values of array.",
	"Method": "String toString(){\r\n    int iMax = array.length - 1;\r\n    if (iMax == -1)\r\n        return \"[]\";\r\n    StringBuilder b = new StringBuilder();\r\n    b.append('[');\r\n    for (int i = 0; ; i++) {\r\n        b.append(getUnchecked(i));\r\n        if (i == iMax)\r\n            return b.append(']').toString();\r\n        b.append(',').append(' ');\r\n    }\r\n}"
}, {
	"Path": "java.lang.StringBuffer.writeObject",
	"Comment": "readobject is called to restore the state of the stringbuffer froma stream.",
	"Method": "void writeObject(java.io.ObjectOutputStream s){\r\n    java.io.ObjectOutputStream.PutField fields = s.putFields();\r\n    fields.put(\"value\", getValue());\r\n    fields.put(\"count\", length());\r\n    fields.put(\"shared\", false);\r\n    s.writeFields();\r\n}"
}, {
	"Path": "java.util.ArrayList.removeAll",
	"Comment": "removes from this list all of its elements that are contained in thespecified collection.",
	"Method": "boolean removeAll(Collection<?> c){\r\n    return batchRemove(c, false);\r\n}"
}, {
	"Path": "org.apache.harmony.luni.tests.java.util.ArrayListTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    super.setUp();\r\n    alist = new ArrayList();\r\n    for (int i = 0; i < objArray.length; i++) alist.add(objArray[i]);\r\n}"
}, {
	"Path": "java.net.JarURLConnection.getCertificates",
	"Comment": "return the certificate object for this connection if the urlfor it points to a jar file entry, null otherwise. this methodcan only be called oncethe connection has been completely verified by readingfrom the input stream until the end of the stream has beenreached. otherwise, this method will return null",
	"Method": "java.security.cert.Certificate[] getCertificates(){\r\n    JarEntry e = getJarEntry();\r\n    return e != null ? e.getCertificates() : null;\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testAbnormalForkQuietlyJoin",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoin(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingFibAction f = new FailingFibAction(8);\r\n            assertSame(f, f.fork());\r\n            f.quietlyJoin();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testAbnormalForkQuietlyJoin",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoin(){\r\n    FailingFibAction f = new FailingFibAction(8);\r\n    assertSame(f, f.fork());\r\n    f.quietlyJoin();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n}"
}, {
	"Path": "java.security.Security.getAllQualifyingCandidates",
	"Comment": "returns all providers who satisfy the specified criterion.",
	"Method": "LinkedHashSet<Provider> getAllQualifyingCandidates(String filterKey,String filterValue,Provider[] allProviders){\r\n    String[] filterComponents = getFilterComponents(filterKey, filterValue);\r\n    String serviceName = filterComponents[0];\r\n    String algName = filterComponents[1];\r\n    String attrName = filterComponents[2];\r\n    return getProvidersNotUsingCache(serviceName, algName, attrName, filterValue, allProviders);\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.hasUnsupportedCriticalExtension",
	"Comment": "return true if a critical extension is found that isnot supported, otherwise return false.",
	"Method": "boolean hasUnsupportedCriticalExtension(){\r\n    if (info == null)\r\n        return false;\r\n    try {\r\n        CertificateExtensions exts = (CertificateExtensions) info.get(CertificateExtensions.NAME);\r\n        if (exts == null)\r\n            return false;\r\n        return exts.hasUnsupportedCriticalExtension();\r\n    } catch (Exception e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "java.lang.ThreadGroup.activeGroupCount",
	"Comment": "returns an estimate of the number of active groups in thisthread group and its subgroups. recursively iterates overall subgroups in this thread group. the value returned is only an estimate because the number ofthread groups may change dynamically while this method traversesinternal data structures. this method is intended primarily fordebugging and monitoring purposes.",
	"Method": "int activeGroupCount(){\r\n    int ngroupsSnapshot;\r\n    ThreadGroup[] groupsSnapshot;\r\n    synchronized (this) {\r\n        if (destroyed) {\r\n            return 0;\r\n        }\r\n        ngroupsSnapshot = ngroups;\r\n        if (groups != null) {\r\n            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);\r\n        } else {\r\n            groupsSnapshot = null;\r\n        }\r\n    }\r\n    int n = ngroupsSnapshot;\r\n    for (int i = 0; i < ngroupsSnapshot; i++) {\r\n        n += groupsSnapshot[i].activeGroupCount();\r\n    }\r\n    return n;\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testReferenceFieldUpdaterGetAndAccumulate",
	"Comment": "atomicreferencefieldupdater returns previous value and updateswith supplied function.",
	"Method": "void testReferenceFieldUpdaterGetAndAccumulate(){\r\n    AtomicReferenceFieldUpdater<Atomic8Test, Integer> a = anIntegerFieldUpdater();\r\n    a.set(this, one);\r\n    assertEquals(new Integer(1), a.getAndAccumulate(this, 2, Atomic8Test::sumInteger));\r\n    assertEquals(new Integer(3), a.getAndAccumulate(this, 3, Atomic8Test::sumInteger));\r\n    assertEquals(new Integer(6), a.get(this));\r\n    assertEquals(new Integer(6), anIntegerField);\r\n}"
}, {
	"Path": "sun.security.provider.certpath.SunCertPathBuilderParameters.setBuildForward",
	"Comment": "sets the value of the buildforward flag. if true, pathsare built from the target subject to the trusted anchor.if false, paths are built from the trusted anchor to thetarget subject. the default value if not specified is true.",
	"Method": "void setBuildForward(boolean buildForward){\r\n    this.buildForward = buildForward;\r\n}"
}, {
	"Path": "javax.xml.transform.stream.StreamSource.setInputStream",
	"Comment": "set the byte stream to be used as input.normally,a stream should be used rather than a reader, so thatthe xml parser can resolve character encoding specifiedby the xml declaration.if this source object is used to process a stylesheet, normallysetsystemid should also be called, so that relative url referencescan be resolved.",
	"Method": "void setInputStream(InputStream inputStream){\r\n    this.inputStream = inputStream;\r\n}"
}, {
	"Path": "java.util.LinkedHashMap.transfer",
	"Comment": "transfers all entries to new table array.this method is calledby superclass resize.it is overridden for performance, as it isfaster to iterate using our linked list.",
	"Method": "void transfer(HashMapEntry[] newTable){\r\n    int newCapacity = newTable.length;\r\n    for (LinkedHashMapEntry<K, V> e = header.after; e != header; e = e.after) {\r\n        int index = indexFor(e.hash, newCapacity);\r\n        e.next = newTable[index];\r\n        newTable[index] = e;\r\n    }\r\n}"
}, {
	"Path": "com.google.mockwebserver.MockResponse.getBody",
	"Comment": "returns the raw http payload, or null if this response is streamed.",
	"Method": "byte[] getBody(){\r\n    return body;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.AlgorithmChecker.trySetTrustAnchor",
	"Comment": "try to set the trust anchor of the checker.if there is no trust anchor specified and the checker has not started,set the trust anchor.",
	"Method": "void trySetTrustAnchor(TrustAnchor anchor){\r\n    if (prevPubKey == null) {\r\n        if (anchor == null) {\r\n            throw new IllegalArgumentException(\"The trust anchor cannot be null\");\r\n        }\r\n        if (anchor.getTrustedCert() != null) {\r\n            prevPubKey = anchor.getTrustedCert().getPublicKey();\r\n        } else {\r\n            prevPubKey = anchor.getCAPublicKey();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.util.KeyUtil.isOracleJCEProvider",
	"Comment": "returns whether the specified provider is oracle provider or not.note that this method is only apply to sunjce and sunpkcs11 at present.",
	"Method": "boolean isOracleJCEProvider(String providerName){\r\n    return providerName != null && (providerName.equals(\"SunJCE\") || providerName.startsWith(\"SunPKCS11\"));\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testGetThreadFactory",
	"Comment": "getthreadfactory returns factory in constructor if not set",
	"Method": "void testGetThreadFactory(){\r\n    final ThreadFactory threadFactory = new SimpleThreadFactory();\r\n    final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1, threadFactory);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertSame(threadFactory, p.getThreadFactory());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadLocalRandomTest.testNextBoolean",
	"Comment": "repeated calls to nextboolean produce at least two distinct results",
	"Method": "void testNextBoolean(){\r\n    boolean f = ThreadLocalRandom.current().nextBoolean();\r\n    int i = 0;\r\n    while (i < NCALLS && ThreadLocalRandom.current().nextBoolean() == f) ++i;\r\n    assertTrue(i < NCALLS);\r\n}"
}, {
	"Path": "jsr166.TimeUnitTest.testToMillis",
	"Comment": "tomillis correctly converts sample values in different units tomilliseconds",
	"Method": "void testToMillis(){\r\n    for (long t = 0; t < 88888; ++t) {\r\n        assertEquals(t * 1000L * 60 * 60 * 24, DAYS.toMillis(t));\r\n        assertEquals(t * 1000L * 60 * 60, HOURS.toMillis(t));\r\n        assertEquals(t * 1000L * 60, MINUTES.toMillis(t));\r\n        assertEquals(1000L * t, SECONDS.toMillis(t));\r\n        assertEquals(t, MILLISECONDS.toMillis(t));\r\n        assertEquals(t, MICROSECONDS.toMillis(t * 1000L));\r\n        assertEquals(t, NANOSECONDS.toMillis(t * 1000000L));\r\n    }\r\n}"
}, {
	"Path": "java.util.Collection.removeIf",
	"Comment": "removes all of the elements of this collection that satisfy the givenpredicate.errors or runtime exceptions thrown during iteration or bythe predicate are relayed to the caller.",
	"Method": "boolean removeIf(Predicate<? super E> filter){\r\n    Objects.requireNonNull(filter);\r\n    boolean removed = false;\r\n    final Iterator<E> each = iterator();\r\n    while (each.hasNext()) {\r\n        if (filter.test(each.next())) {\r\n            each.remove();\r\n            removed = true;\r\n        }\r\n    }\r\n    return removed;\r\n}"
}, {
	"Path": "jsr166.TimeUnitTest.testToMicros",
	"Comment": "tomicros correctly converts sample values in different units tomicroseconds",
	"Method": "void testToMicros(){\r\n    for (long t = 0; t < 88888; ++t) {\r\n        assertEquals(t * 1000000L * 60 * 60 * 24, DAYS.toMicros(t));\r\n        assertEquals(t * 1000000L * 60 * 60, HOURS.toMicros(t));\r\n        assertEquals(t * 1000000L * 60, MINUTES.toMicros(t));\r\n        assertEquals(1000000L * t, SECONDS.toMicros(t));\r\n        assertEquals(1000L * t, MILLISECONDS.toMicros(t));\r\n        assertEquals(t, MICROSECONDS.toMicros(t));\r\n        assertEquals(t, NANOSECONDS.toMicros(t * 1000L));\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.AlgorithmId.getAlgorithmId",
	"Comment": "returns one of the algorithm ids most commonly associatedwith this algorithm name.",
	"Method": "AlgorithmId getAlgorithmId(String algname){\r\n    return get(algname);\r\n}"
}, {
	"Path": "sun.security.pkcs.PKCS9Attribute.throwTagException",
	"Comment": "throw an exception when the tag on a value encoding iswrong for the attribute whose value it is. this methodwill only be called for known tags.",
	"Method": "void throwTagException(Byte tag){\r\n    Byte[] expectedTags = PKCS9_VALUE_TAGS[index];\r\n    StringBuffer msg = new StringBuffer(100);\r\n    msg.append(\"Value of attribute \");\r\n    msg.append(oid.toString());\r\n    msg.append(\" (\");\r\n    msg.append(getName());\r\n    msg.append(\") has wrong tag: \");\r\n    msg.append(tag.toString());\r\n    msg.append(\".  Expected tags: \");\r\n    msg.append(expectedTags[0].toString());\r\n    for (int i = 1; i < expectedTags.length; i++) {\r\n        msg.append(\", \");\r\n        msg.append(expectedTags[i].toString());\r\n    }\r\n    msg.append(\".\");\r\n    throw new IOException(msg.toString());\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.initialize",
	"Comment": "initializes the symbols from the formatdata resource bundle.",
	"Method": "void initialize(Locale locale){\r\n    this.locale = locale;\r\n    boolean needCacheUpdate = false;\r\n    Object[] data = cachedLocaleData.get(locale);\r\n    if (data == null) {\r\n        locale = LocaleData.mapInvalidAndNullLocales(locale);\r\n        LocaleData localeData = LocaleData.get(locale);\r\n        data = new Object[3];\r\n        String[] values = new String[11];\r\n        values[0] = String.valueOf(localeData.decimalSeparator);\r\n        values[1] = String.valueOf(localeData.groupingSeparator);\r\n        values[2] = String.valueOf(localeData.patternSeparator);\r\n        values[3] = String.valueOf(localeData.percent);\r\n        values[4] = String.valueOf(localeData.zeroDigit);\r\n        values[5] = \"#\";\r\n        values[6] = localeData.minusSign;\r\n        values[7] = localeData.exponentSeparator;\r\n        values[8] = String.valueOf(localeData.perMill);\r\n        values[9] = localeData.infinity;\r\n        values[10] = localeData.NaN;\r\n        data[0] = values;\r\n        needCacheUpdate = true;\r\n    }\r\n    String[] numberElements = (String[]) data[0];\r\n    decimalSeparator = numberElements[0].charAt(0);\r\n    groupingSeparator = numberElements[1].charAt(0);\r\n    patternSeparator = numberElements[2].charAt(0);\r\n    percent = maybeStripMarkers(numberElements[3], '%');\r\n    zeroDigit = numberElements[4].charAt(0);\r\n    digit = numberElements[5].charAt(0);\r\n    minusSign = maybeStripMarkers(numberElements[6], '-');\r\n    exponential = numberElements[7].charAt(0);\r\n    exponentialSeparator = numberElements[7];\r\n    perMill = numberElements[8].charAt(0);\r\n    infinity = numberElements[9];\r\n    NaN = numberElements[10];\r\n    if (!\"\".equals(locale.getCountry())) {\r\n        try {\r\n            currency = Currency.getInstance(locale);\r\n        } catch (IllegalArgumentException e) {\r\n        }\r\n    }\r\n    if (currency != null) {\r\n        intlCurrencySymbol = currency.getCurrencyCode();\r\n        if (data[1] != null && data[1] == intlCurrencySymbol) {\r\n            currencySymbol = (String) data[2];\r\n        } else {\r\n            currencySymbol = currency.getSymbol(locale);\r\n            data[1] = intlCurrencySymbol;\r\n            data[2] = currencySymbol;\r\n            needCacheUpdate = true;\r\n        }\r\n    } else {\r\n        intlCurrencySymbol = \"XXX\";\r\n        try {\r\n            currency = Currency.getInstance(intlCurrencySymbol);\r\n        } catch (IllegalArgumentException e) {\r\n        }\r\n        currencySymbol = \"\";\r\n    }\r\n    monetarySeparator = decimalSeparator;\r\n    if (needCacheUpdate) {\r\n        cachedLocaleData.putIfAbsent(locale, data);\r\n    }\r\n}"
}, {
	"Path": "sun.util.calendar.BaseCalendar.getYearLength",
	"Comment": "returns 366 if the specified date is in a leap year, or 365otherwise this method does not perform the normalization withthe specified calendardate. thecalendardate must be normalized to get a correctvalue.",
	"Method": "int getYearLength(CalendarDate date){\r\n    return isLeapYear(((Date) date).getNormalizedYear()) ? 366 : 365;\r\n}"
}, {
	"Path": "java.beans.PropertyChangeEvent.getPropertyName",
	"Comment": "gets the programmatic name of the property that was changed.",
	"Method": "String getPropertyName(){\r\n    return propertyName;\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinTask.peekNextLocalTask",
	"Comment": "returns, but does not unschedule or execute, a task queued bythe current thread but not yet executed, if one is immediatelyavailable. there is no guarantee that this task will actuallybe polled or executed next. conversely, this method may returnnull even if a task exists but cannot be accessed withoutcontention with other threads.this method is designedprimarily to support extensions, and is unlikely to be usefulotherwise.",
	"Method": "ForkJoinTask<?> peekNextLocalTask(){\r\n    Thread t;\r\n    ForkJoinPool.WorkQueue q;\r\n    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\r\n        q = ((ForkJoinWorkerThread) t).workQueue;\r\n    else\r\n        q = ForkJoinPool.commonSubmitterQueue();\r\n    return (q == null) ? null : q.peek();\r\n}"
}, {
	"Path": "java.sql.Timestamp.valueOf",
	"Comment": "converts a string object in jdbc timestamp escape format to atimestamp value.",
	"Method": "Timestamp valueOf(String s){\r\n    final int YEAR_LENGTH = 4;\r\n    final int MONTH_LENGTH = 2;\r\n    final int DAY_LENGTH = 2;\r\n    final int MAX_MONTH = 12;\r\n    final int MAX_DAY = 31;\r\n    String date_s;\r\n    String time_s;\r\n    String nanos_s;\r\n    int year = 0;\r\n    int month = 0;\r\n    int day = 0;\r\n    int hour;\r\n    int minute;\r\n    int second;\r\n    int a_nanos = 0;\r\n    int firstDash;\r\n    int secondDash;\r\n    int dividingSpace;\r\n    int firstColon = 0;\r\n    int secondColon = 0;\r\n    int period = 0;\r\n    String formatError = \"Timestamp format must be yyyy-mm-dd hh:mm:ss[.fffffffff]\";\r\n    String zeros = \"000000000\";\r\n    String delimiterDate = \"-\";\r\n    String delimiterTime = \":\";\r\n    if (s == null)\r\n        throw new java.lang.IllegalArgumentException(\"null string\");\r\n    s = s.trim();\r\n    dividingSpace = s.indexOf(' ');\r\n    if (dividingSpace > 0) {\r\n        date_s = s.substring(0, dividingSpace);\r\n        time_s = s.substring(dividingSpace + 1);\r\n    } else {\r\n        throw new java.lang.IllegalArgumentException(formatError);\r\n    }\r\n    firstDash = date_s.indexOf('-');\r\n    secondDash = date_s.indexOf('-', firstDash + 1);\r\n    if (time_s == null)\r\n        throw new java.lang.IllegalArgumentException(formatError);\r\n    firstColon = time_s.indexOf(':');\r\n    secondColon = time_s.indexOf(':', firstColon + 1);\r\n    period = time_s.indexOf('.', secondColon + 1);\r\n    boolean parsedDate = false;\r\n    if ((firstDash > 0) && (secondDash > 0) && (secondDash < date_s.length() - 1)) {\r\n        String yyyy = date_s.substring(0, firstDash);\r\n        String mm = date_s.substring(firstDash + 1, secondDash);\r\n        String dd = date_s.substring(secondDash + 1);\r\n        if (yyyy.length() == YEAR_LENGTH && (mm.length() >= 1 && mm.length() <= MONTH_LENGTH) && (dd.length() >= 1 && dd.length() <= DAY_LENGTH)) {\r\n            year = Integer.parseInt(yyyy);\r\n            month = Integer.parseInt(mm);\r\n            day = Integer.parseInt(dd);\r\n            if ((month >= 1 && month <= MAX_MONTH) && (day >= 1 && day <= MAX_DAY)) {\r\n                parsedDate = true;\r\n            }\r\n        }\r\n    }\r\n    if (!parsedDate) {\r\n        throw new java.lang.IllegalArgumentException(formatError);\r\n    }\r\n    if ((firstColon > 0) & (secondColon > 0) & (secondColon < time_s.length() - 1)) {\r\n        hour = Integer.parseInt(time_s.substring(0, firstColon));\r\n        minute = Integer.parseInt(time_s.substring(firstColon + 1, secondColon));\r\n        if ((period > 0) & (period < time_s.length() - 1)) {\r\n            second = Integer.parseInt(time_s.substring(secondColon + 1, period));\r\n            nanos_s = time_s.substring(period + 1);\r\n            if (nanos_s.length() > 9)\r\n                throw new java.lang.IllegalArgumentException(formatError);\r\n            if (!Character.isDigit(nanos_s.charAt(0)))\r\n                throw new java.lang.IllegalArgumentException(formatError);\r\n            nanos_s = nanos_s + zeros.substring(0, 9 - nanos_s.length());\r\n            a_nanos = Integer.parseInt(nanos_s);\r\n        } else if (period > 0) {\r\n            throw new java.lang.IllegalArgumentException(formatError);\r\n        } else {\r\n            second = Integer.parseInt(time_s.substring(secondColon + 1));\r\n        }\r\n    } else {\r\n        throw new java.lang.IllegalArgumentException(formatError);\r\n    }\r\n    return new Timestamp(year - 1900, month - 1, day, hour, minute, second, a_nanos);\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.setPrivateKeyValid",
	"Comment": "sets the privatekeyvalid criterion. the specified date must fallwithin the private key validity period for thex509certificate. if null, no privatekeyvalidcheck will be done.note that the date supplied here is cloned to protectagainst subsequent modifications.",
	"Method": "void setPrivateKeyValid(Date privateKeyValid){\r\n    if (privateKeyValid == null) {\r\n        this.privateKeyValid = null;\r\n    } else {\r\n        this.privateKeyValid = (Date) privateKeyValid.clone();\r\n    }\r\n}"
}, {
	"Path": "java.time.format.DateTimePrintContext.getLocale",
	"Comment": "gets the locale.this locale is used to control localization in the format output exceptwhere localization is controlled by the decimalstyle.",
	"Method": "Locale getLocale(){\r\n    return formatter.getLocale();\r\n}"
}, {
	"Path": "okio.Buffer.completeSegmentByteCount",
	"Comment": "returns the number of bytes in segments that are not writable. this is thenumber of bytes that can be flushed immediately to an underlying sinkwithout harming throughput.",
	"Method": "long completeSegmentByteCount(){\r\n    long result = size;\r\n    if (result == 0)\r\n        return 0;\r\n    Segment tail = head.prev;\r\n    if (tail.limit < Segment.SIZE && tail.owner) {\r\n        result -= tail.limit - tail.pos;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "javax.crypto.spec.SecretKeySpec.getAlgorithm",
	"Comment": "returns the name of the algorithm associated with this secret key.",
	"Method": "String getAlgorithm(){\r\n    return this.algorithm;\r\n}"
}, {
	"Path": "java.util.Stack.pop",
	"Comment": "removes the object at the top of this stack and returns thatobject as the value of this function.",
	"Method": "E pop(){\r\n    E obj;\r\n    int len = size();\r\n    obj = peek();\r\n    removeElementAt(len - 1);\r\n    return obj;\r\n}"
}, {
	"Path": "javax.crypto.CipherInputStream.available",
	"Comment": "returns the number of bytes that can be read from this inputstream without blocking. the available method ofinputstream returns 0. this methodshould be overridden by subclasses.",
	"Method": "int available(){\r\n    return (ofinish - ostart);\r\n}"
}, {
	"Path": "java.util.regex.Pattern.readObject",
	"Comment": "recompile the pattern instance from a stream.the original patternstring is read in and the object tree is recompiled from it.",
	"Method": "void readObject(java.io.ObjectInputStream s){\r\n    s.defaultReadObject();\r\n    compile();\r\n}"
}, {
	"Path": "sun.security.util.DerInputStream.available",
	"Comment": "returns the number of bytes available for reading.this is most useful for testing whether the stream isempty.",
	"Method": "int available(){\r\n    return buffer.available();\r\n}"
}, {
	"Path": "org.xml.sax.helpers.NewInstance.getClassLoader",
	"Comment": "figure out which classloader to use.for jdk 1.2 and later usethe context classloader.",
	"Method": "ClassLoader getClassLoader(){\r\n    Method m = null;\r\n    try {\r\n        m = Thread.class.getMethod(\"getContextClassLoader\");\r\n    } catch (NoSuchMethodException e) {\r\n        return NewInstance.class.getClassLoader();\r\n    }\r\n    try {\r\n        return (ClassLoader) m.invoke(Thread.currentThread());\r\n    } catch (IllegalAccessException e) {\r\n        throw new UnknownError(e.getMessage());\r\n    } catch (InvocationTargetException e) {\r\n        throw new UnknownError(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ConcurrentLinkedQueueTest.testAddAll5",
	"Comment": "queue contains all elements, in traversal order, of successful addall",
	"Method": "void testAddAll5(){\r\n    Integer[] empty = new Integer[0];\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = new Integer(i);\r\n    ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();\r\n    assertFalse(q.addAll(Arrays.asList(empty)));\r\n    assertTrue(q.addAll(Arrays.asList(ints)));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "android.icu.dev.test.UTF16Util.nextCodePoint",
	"Comment": "method nextcodepoint. returns the next code pointin a string.",
	"Method": "int nextCodePoint(String s,int i,int nextCodePoint,StringBuffer s,int i){\r\n    int ch = s.charAt(i);\r\n    if (0xd800 <= ch && ch <= 0xdbff && ++i < s.length()) {\r\n        int ch2 = s.charAt(i);\r\n        if (0xdc00 <= ch2 && ch2 <= 0xdfff) {\r\n            ch = (ch << 10) + ch2 - suppOffset;\r\n        }\r\n    }\r\n    return ch;\r\n}"
}, {
	"Path": "jsr166.ConcurrentLinkedQueueTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        q.addAll(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test017",
	"Comment": "incompatibleclasschangeerror when running code with lambda method",
	"Method": "void test017(){\r\n    this.runConformTest(new String[] { \"X.java\", \"interface I {\\n\" + \"  void foo(int x, int y);\\n\" + \"}\\n\" + \"public class X {\\n\" + \"  public static void main(String[] args) {\\n\" + \"    BinaryOperator<String> binOp = (x,y) -> { return x+y; }; \\n\" + \"    System.out.println(binOp.apply(\\\"SUCC\\\", \\\"ESS\\\")); // when lambdas run\\n\" + \"  }\\n\" + \"}\\n\" + \"@FunctionalInterface\\n\" + \"interface BiFunction<T, U, R> { \\n\" + \"    R apply(T t, U u);\\n\" + \"}\\n\" + \"@FunctionalInterface \\n\" + \"interface BinaryOperator<T> extends BiFunction<T,T,T> { \\n\" + \"}\\n\" }, \"SUCCESS\");\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testTryAcquireSharedNanos_Timeout",
	"Comment": "tryacquiresharednanos times out if not released before timeout",
	"Method": "void testTryAcquireSharedNanos_Timeout(){\r\n    final BooleanLatch l = new BooleanLatch();\r\n    final BooleanLatch observedQueued = new BooleanLatch();\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            assertFalse(l.isSignalled());\r\n            for (long millis = timeoutMillis(); !observedQueued.isSignalled(); millis *= 2) {\r\n                long nanos = MILLISECONDS.toNanos(millis);\r\n                long startTime = System.nanoTime();\r\n                assertFalse(l.tryAcquireSharedNanos(0, nanos));\r\n                assertTrue(millisElapsedSince(startTime) >= millis);\r\n            }\r\n            assertFalse(l.isSignalled());\r\n        }\r\n    });\r\n    waitForQueuedThread(l, t);\r\n    observedQueued.releaseShared(0);\r\n    assertFalse(l.isSignalled());\r\n    awaitTermination(t);\r\n    assertFalse(l.isSignalled());\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testTryAcquireSharedNanos_Timeout",
	"Comment": "tryacquiresharednanos times out if not released before timeout",
	"Method": "void testTryAcquireSharedNanos_Timeout(){\r\n    assertFalse(l.isSignalled());\r\n    for (long millis = timeoutMillis(); !observedQueued.isSignalled(); millis *= 2) {\r\n        long nanos = MILLISECONDS.toNanos(millis);\r\n        long startTime = System.nanoTime();\r\n        assertFalse(l.tryAcquireSharedNanos(0, nanos));\r\n        assertTrue(millisElapsedSince(startTime) >= millis);\r\n    }\r\n    assertFalse(l.isSignalled());\r\n}"
}, {
	"Path": "java.util.concurrent.CountedCompleter.helpComplete",
	"Comment": "if this task has not completed, attempts to process at most thegiven number of other unprocessed tasks for which this task ison the completion path, if any are known to exist.",
	"Method": "void helpComplete(int maxTasks){\r\n    Thread t;\r\n    ForkJoinWorkerThread wt;\r\n    if (maxTasks > 0 && status >= 0) {\r\n        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\r\n            (wt = (ForkJoinWorkerThread) t).pool.helpComplete(wt.workQueue, this, maxTasks);\r\n        else\r\n            ForkJoinPool.common.externalHelpComplete(this, maxTasks);\r\n    }\r\n}"
}, {
	"Path": "java.security.KeyStore.getCreationDate",
	"Comment": "returns the creation date of the entry identified by the given alias.",
	"Method": "Date getCreationDate(String alias){\r\n    if (!initialized) {\r\n        throw new KeyStoreException(\"Uninitialized keystore\");\r\n    }\r\n    return keyStoreSpi.engineGetCreationDate(alias);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.ExternalAnnotationInjectorTest.testForwardDeclaration",
	"Comment": "verify that visited methods generate the expected forward declarations.",
	"Method": "void testForwardDeclaration(){\r\n    options.setNullability(true);\r\n    String externalNullabilityAnnotations = \"package p: \" + \"annotation @AnAnnotation: \" + \"class Test: \" + \"  method foo(Ljava/lang/Thread;)V: @p.AnAnnotation\";\r\n    options.addExternalAnnotationFileContents(externalNullabilityAnnotations);\r\n    String source = \"package p;\" + \"public class Test { \" + \"  public void foo(Thread t) {} \" + \"  public void bar(ThreadGroup t) {} \" + \"}\";\r\n    String translation = translateSourceFile(source, \"p.Test\", \"p/Test.h\");\r\n    assertTranslation(translation, \"@class JavaLangThread;\");\r\n    assertTranslation(translation, \"@class JavaLangThreadGroup;\");\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testNewCachedThreadPool2",
	"Comment": "a newcachedthreadpool with given threadfactory can execute runnables",
	"Method": "void testNewCachedThreadPool2(){\r\n    final ExecutorService e = Executors.newCachedThreadPool(new SimpleThreadFactory());\r\n    try (PoolCleaner cleaner = cleaner(e)) {\r\n        e.execute(new NoOpRunnable());\r\n        e.execute(new NoOpRunnable());\r\n        e.execute(new NoOpRunnable());\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.ReverseBuilder.getMatchingCACerts",
	"Comment": "retrieves all ca certificates which satisfy constraintsand requirements specified in the parameters and pkix state.",
	"Method": "Collection<X509Certificate> getMatchingCACerts(ReverseState currentState,List<CertStore> certStores){\r\n    X509CertSelector sel = new X509CertSelector();\r\n    sel.setIssuer(currentState.subjectDN);\r\n    sel.setCertificateValid(buildParams.date());\r\n    byte[] subject = targetCertConstraints.getSubjectAsBytes();\r\n    if (subject != null) {\r\n        sel.addPathToName(4, subject);\r\n    } else {\r\n        X509Certificate cert = targetCertConstraints.getCertificate();\r\n        if (cert != null) {\r\n            sel.addPathToName(4, cert.getSubjectX500Principal().getEncoded());\r\n        }\r\n    }\r\n    if (currentState.explicitPolicy == 0)\r\n        sel.setPolicy(getMatchingPolicies());\r\n    sel.setBasicConstraints(0);\r\n    ArrayList<X509Certificate> reverseCerts = new ArrayList();\r\n    addMatchingCerts(sel, certStores, reverseCerts, true);\r\n    Collections.sort(reverseCerts, new PKIXCertComparator());\r\n    if (debug != null)\r\n        debug.println(\"ReverseBuilder.getMatchingCACerts got \" + reverseCerts.size() + \" certs.\");\r\n    return reverseCerts;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.DateFormatTest.TestCzechMonths459",
	"Comment": "verify the handling of czech june and july, which have the unique attribute thatone is a proper prefix substring of the other.",
	"Method": "void TestCzechMonths459(){\r\n    DateFormat fmt = DateFormat.getDateInstance(DateFormat.FULL, new Locale(\"cs\", \"\", \"\"));\r\n    logln(\"Pattern \" + ((SimpleDateFormat) fmt).toPattern());\r\n    Calendar cal = Calendar.getInstance();\r\n    cal.clear();\r\n    cal.set(1997, Calendar.JUNE, 15);\r\n    Date june = cal.getTime();\r\n    cal.clear();\r\n    cal.set(1997, Calendar.JULY, 15);\r\n    Date july = cal.getTime();\r\n    String juneStr = fmt.format(june);\r\n    String julyStr = fmt.format(july);\r\n    try {\r\n        logln(\"format(June 15 1997) = \" + juneStr);\r\n        Date d = fmt.parse(juneStr);\r\n        String s = fmt.format(d);\r\n        int month, yr, day;\r\n        cal.setTime(d);\r\n        yr = cal.get(Calendar.YEAR);\r\n        month = cal.get(Calendar.MONTH);\r\n        day = cal.get(Calendar.DAY_OF_MONTH);\r\n        logln(\"  . parse . \" + s + \" (month = \" + month + \")\");\r\n        if (month != Calendar.JUNE)\r\n            errln(\"FAIL: Month should be June\");\r\n        if (yr != 1997)\r\n            errln(\"FAIL: Year should be 1997\");\r\n        if (day != 15)\r\n            errln(\"FAIL: day should be 15\");\r\n        logln(\"format(July 15 1997) = \" + julyStr);\r\n        d = fmt.parse(julyStr);\r\n        s = fmt.format(d);\r\n        cal.setTime(d);\r\n        yr = cal.get(Calendar.YEAR) - 1900;\r\n        month = cal.get(Calendar.MONTH);\r\n        day = cal.get(Calendar.DAY_OF_WEEK);\r\n        logln(\"  . parse . \" + s + \" (month = \" + month + \")\");\r\n        if (month != Calendar.JULY)\r\n            errln(\"FAIL: Month should be July\");\r\n    } catch (ParseException e) {\r\n        errln(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.xml.sax.InputSource.getSystemId",
	"Comment": "get the system identifier for this input source.the getencoding method will return the character encodingof the object pointed to, or null if unknown.if the system id is a url, it will be fully resolved.",
	"Method": "String getSystemId(){\r\n    return systemId;\r\n}"
}, {
	"Path": "java.text.NumberFormat.setCurrency",
	"Comment": "sets the currency used by this number format when formattingcurrency values. this does not update the minimum or maximumnumber of fraction digits used by the number format.the default implementation throwsunsupportedoperationexception.",
	"Method": "void setCurrency(Currency currency){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "java.util.Date.getYear",
	"Comment": "returns a value that is the result of subtracting 1900 from theyear that contains or begins with the instant in time representedby this date object, as interpreted in the localtime zone.",
	"Method": "int getYear(){\r\n    return normalize().getYear() - 1900;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.nio.channels.SocketChannelTest.assertTimeout",
	"Comment": "fails if the difference between current time and start time is greaterthan timeout.",
	"Method": "void assertTimeout(long startTime,long timeout){\r\n    long currentTime = System.currentTimeMillis();\r\n    if ((currentTime - startTime) > timeout) {\r\n        fail(\"Timeout\");\r\n    }\r\n}"
}, {
	"Path": "javax.xml.transform.stream.StreamSource.setReader",
	"Comment": "set the input to be a character reader.normally,a stream should be used rather than a reader, so thatthe xml parser can resolve character encoding specifiedby the xml declaration.however, in many cases the encodingof the input stream is already resolved, as in the case ofreading xml from a stringreader.",
	"Method": "void setReader(Reader reader){\r\n    this.reader = reader;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testRejectedRecycledTask",
	"Comment": "execute allows the same task to be submitted multiple times, evenif rejected",
	"Method": "void testRejectedRecycledTask(){\r\n    final int nTasks = 1000;\r\n    final CountDownLatch done = new CountDownLatch(nTasks);\r\n    final Runnable recycledTask = new Runnable() {\r\n        public void run() {\r\n            done.countDown();\r\n        }\r\n    };\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(1, 30, 60, SECONDS, new ArrayBlockingQueue(30));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        for (int i = 0; i < nTasks; ++i) {\r\n            for (; ; ) {\r\n                try {\r\n                    p.execute(recycledTask);\r\n                    break;\r\n                } catch (RejectedExecutionException ignore) {\r\n                }\r\n            }\r\n        }\r\n        assertTrue(done.await(nTasks * SHORT_DELAY_MS, MILLISECONDS));\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testRejectedRecycledTask",
	"Comment": "execute allows the same task to be submitted multiple times, evenif rejected",
	"Method": "void testRejectedRecycledTask(){\r\n    done.countDown();\r\n}"
}, {
	"Path": "java.net.InetAddress.isMCLinkLocal",
	"Comment": "utility routine to check if the multicast address has link scope.",
	"Method": "boolean isMCLinkLocal(){\r\n    return false;\r\n}"
}, {
	"Path": "java.util.stream.AbstractPipeline.sourceStageSpliterator",
	"Comment": "gets the source stage spliterator if this pipeline stage is the sourcestage.the pipeline is consumed after this method is called andreturns successfully.",
	"Method": "Spliterator<E_OUT> sourceStageSpliterator(){\r\n    if (this != sourceStage)\r\n        throw new IllegalStateException();\r\n    if (linkedOrConsumed)\r\n        throw new IllegalStateException(MSG_STREAM_LINKED);\r\n    linkedOrConsumed = true;\r\n    if (sourceStage.sourceSpliterator != null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Spliterator<E_OUT> s = sourceStage.sourceSpliterator;\r\n        sourceStage.sourceSpliterator = null;\r\n        return s;\r\n    } else if (sourceStage.sourceSupplier != null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Spliterator<E_OUT> s = (Spliterator<E_OUT>) sourceStage.sourceSupplier.get();\r\n        sourceStage.sourceSupplier = null;\r\n        return s;\r\n    } else {\r\n        throw new IllegalStateException(MSG_CONSUMED);\r\n    }\r\n}"
}, {
	"Path": "org.xml.sax.SAXException.getMessage",
	"Comment": "return a detail message for this exception.if there is an embedded exception, and if the saxexceptionhas no detail message of its own, this method will returnthe detail message from the embedded exception.",
	"Method": "String getMessage(){\r\n    String message = super.getMessage();\r\n    if (message == null && exception != null) {\r\n        return exception.getMessage();\r\n    } else {\r\n        return message;\r\n    }\r\n}"
}, {
	"Path": "jsr166.ArrayDequeTest.populatedDeque",
	"Comment": "returns a new deque of given size containing consecutiveintegers 0 ... n.",
	"Method": "ArrayDeque<Integer> populatedDeque(int n){\r\n    ArrayDeque<Integer> q = new ArrayDeque<Integer>();\r\n    assertTrue(q.isEmpty());\r\n    for (int i = 0; i < n; ++i) assertTrue(q.offerLast(new Integer(i)));\r\n    assertFalse(q.isEmpty());\r\n    assertEquals(n, q.size());\r\n    return q;\r\n}"
}, {
	"Path": "java.io.FilterOutputStream.close",
	"Comment": "closes this output stream and releases any system resourcesassociated with the stream.the close method of filteroutputstreamcalls its flush method, and then calls theclose method of its underlying output stream.",
	"Method": "void close(){\r\n    try {\r\n        flush();\r\n    } catch (IOException ignored) {\r\n    }\r\n    out.close();\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.binaryGCD",
	"Comment": "calculate gcd of this and v.assumes that this and v are not zero.",
	"Method": "MutableBigInteger binaryGCD(MutableBigInteger v){\r\n    MutableBigInteger u = this;\r\n    MutableBigInteger r = new MutableBigInteger();\r\n    int s1 = u.getLowestSetBit();\r\n    int s2 = v.getLowestSetBit();\r\n    int k = (s1 < s2) ? s1 : s2;\r\n    if (k != 0) {\r\n        u.rightShift(k);\r\n        v.rightShift(k);\r\n    }\r\n    boolean uOdd = (k == s1);\r\n    MutableBigInteger t = uOdd ? v : u;\r\n    int tsign = uOdd ? -1 : 1;\r\n    int lb;\r\n    while ((lb = t.getLowestSetBit()) >= 0) {\r\n        t.rightShift(lb);\r\n        if (tsign > 0)\r\n            u = t;\r\n        else\r\n            v = t;\r\n        if (u.intLen < 2 && v.intLen < 2) {\r\n            int x = u.value[u.offset];\r\n            int y = v.value[v.offset];\r\n            x = binaryGcd(x, y);\r\n            r.value[0] = x;\r\n            r.intLen = 1;\r\n            r.offset = 0;\r\n            if (k > 0)\r\n                r.leftShift(k);\r\n            return r;\r\n        }\r\n        if ((tsign = u.difference(v)) == 0)\r\n            break;\r\n        t = (tsign >= 0) ? u : v;\r\n    }\r\n    if (k > 0)\r\n        u.leftShift(k);\r\n    return u;\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceTest.testCompareAndSet",
	"Comment": "compareandset succeeds in changing value if equal to expected else fails",
	"Method": "void testCompareAndSet(){\r\n    AtomicReference ai = new AtomicReference(one);\r\n    assertTrue(ai.compareAndSet(one, two));\r\n    assertTrue(ai.compareAndSet(two, m4));\r\n    assertSame(m4, ai.get());\r\n    assertFalse(ai.compareAndSet(m5, seven));\r\n    assertSame(m4, ai.get());\r\n    assertTrue(ai.compareAndSet(m4, seven));\r\n    assertSame(seven, ai.get());\r\n}"
}, {
	"Path": "java.util.function.DoubleUnaryOperator.identity",
	"Comment": "returns a unary operator that always returns its input argument.",
	"Method": "DoubleUnaryOperator identity(){\r\n    return t -> t;\r\n}"
}, {
	"Path": "java.security.cert.X509CRL.equals",
	"Comment": "compares this crl for equality with the givenobject. if the other object is aninstanceof x509crl, thenits encoded form is retrieved and compared with theencoded form of this crl.",
	"Method": "boolean equals(Object other){\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (!(other instanceof X509CRL)) {\r\n        return false;\r\n    }\r\n    try {\r\n        byte[] thisCRL = X509CRLImpl.getEncodedInternal(this);\r\n        byte[] otherCRL = X509CRLImpl.getEncodedInternal((X509CRL) other);\r\n        return Arrays.equals(thisCRL, otherCRL);\r\n    } catch (CRLException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.setDecimalSeparator",
	"Comment": "sets the character used for decimal sign. different for french, etc.",
	"Method": "void setDecimalSeparator(char decimalSeparator){\r\n    this.decimalSeparator = decimalSeparator;\r\n}"
}, {
	"Path": "java.util.logging.MemoryHandler.setPushLevel",
	"Comment": "set the pushlevel.after a logrecord is copiedinto our internal buffer, if its level is greater than or equal tothe pushlevel, then push will be called.",
	"Method": "void setPushLevel(Level newLevel){\r\n    if (newLevel == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    LogManager manager = LogManager.getLogManager();\r\n    checkPermission();\r\n    pushLevel = newLevel;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.IndexedCollectionCertStore.matchX509CRLs",
	"Comment": "iterate through all the x509crls and add matches to thecollection.",
	"Method": "void matchX509CRLs(CRLSelector selector,Collection<CRL> matches){\r\n    for (Object obj : crlIssuers.values()) {\r\n        if (obj instanceof X509CRL) {\r\n            X509CRL crl = (X509CRL) obj;\r\n            if (selector.match(crl)) {\r\n                matches.add(crl);\r\n            }\r\n        } else {\r\n            @SuppressWarnings(\"unchecked\")\r\n            List<X509CRL> list = (List<X509CRL>) obj;\r\n            for (X509CRL crl : list) {\r\n                if (selector.match(crl)) {\r\n                    matches.add(crl);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.TreeSet.addAll",
	"Comment": "adds all of the elements in the specified collection to this set.",
	"Method": "boolean addAll(Collection<? extends E> c){\r\n    if (m.size() == 0 && c.size() > 0 && c instanceof SortedSet && m instanceof TreeMap) {\r\n        SortedSet<? extends E> set = (SortedSet<? extends E>) c;\r\n        TreeMap<E, Object> map = (TreeMap<E, Object>) m;\r\n        Comparator<?> cc = set.comparator();\r\n        Comparator<? super E> mc = map.comparator();\r\n        if (cc == mc || (cc != null && cc.equals(mc))) {\r\n            map.addAllForTreeSet(set, PRESENT);\r\n            return true;\r\n        }\r\n    }\r\n    return super.addAll(c);\r\n}"
}, {
	"Path": "org.apache.harmony.luni.tests.java.util.VectorTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this method\tis called before a test is executed.",
	"Method": "void setUp(){\r\n    for (int i = 0; i < 100; i++) {\r\n        tVector.addElement(\"Test \" + i);\r\n    }\r\n    objArray = new Object[100];\r\n    for (int i = 0; i < 100; i++) {\r\n        objArray[i] = \"Test \" + i;\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.AlgorithmId.getEncAlgFromSigAlg",
	"Comment": "extracts the encryption algorithm name from a signaturealgorithm name.",
	"Method": "String getEncAlgFromSigAlg(String signatureAlgorithm){\r\n    signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);\r\n    int with = signatureAlgorithm.indexOf(\"WITH\");\r\n    String keyAlgorithm = null;\r\n    if (with > 0) {\r\n        int and = signatureAlgorithm.indexOf(\"AND\", with + 4);\r\n        if (and > 0) {\r\n            keyAlgorithm = signatureAlgorithm.substring(with + 4, and);\r\n        } else {\r\n            keyAlgorithm = signatureAlgorithm.substring(with + 4);\r\n        }\r\n        if (keyAlgorithm.equalsIgnoreCase(\"ECDSA\")) {\r\n            keyAlgorithm = \"EC\";\r\n        }\r\n    }\r\n    return keyAlgorithm;\r\n}"
}, {
	"Path": "java.util.concurrent.Semaphore.drainPermits",
	"Comment": "acquires and returns all permits that are immediately available.",
	"Method": "int drainPermits(int drainPermits){\r\n    return sync.drainPermits();\r\n}"
}, {
	"Path": "java.time.format.DecimalStyle.withDecimalSeparator",
	"Comment": "returns a copy of the info with a new character that represents the decimal point.the character used to represent a decimal point may vary by culture.this method specifies the character to use.",
	"Method": "DecimalStyle withDecimalSeparator(char decimalSeparator){\r\n    if (decimalSeparator == this.decimalSeparator) {\r\n        return this;\r\n    }\r\n    return new DecimalStyle(zeroDigit, positiveSign, negativeSign, decimalSeparator);\r\n}"
}, {
	"Path": "java.util.concurrent.locks.ReentrantLock.isLocked",
	"Comment": "queries if this lock is held by any thread. this method isdesigned for use in monitoring of the system state,not for synchronization control.",
	"Method": "boolean isLocked(boolean isLocked){\r\n    return sync.isLocked();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.StatementGeneratorTest.testReturnReservedWord",
	"Comment": "verify that return statements output correctly for reserved words.",
	"Method": "void testReturnReservedWord(){\r\n    String translation = translateSourceFile(\"public class Test { static final String BOOL = \\\"bool\\\"; String test() { return BOOL; }}\", \"Test\", \"Test.m\");\r\n    assertTranslation(translation, \"return Test_BOOL;\");\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.io.InputStreamReaderTest.test_getEncoding",
	"Comment": "unlike the ri, we return a canonical encoding name and not somethingjava specific.",
	"Method": "void test_getEncoding(){\r\n    InputStreamReader isr = new InputStreamReader(fis, \"8859_1\");\r\n    assertEquals(\"ISO-8859-1\", isr.getEncoding());\r\n    isr = new InputStreamReader(fis, \"ISO-8859-1\");\r\n    assertEquals(\"ISO-8859-1\", isr.getEncoding());\r\n    byte[] b = new byte[5];\r\n    isr = new InputStreamReader(new ByteArrayInputStream(b), \"UTF-16BE\");\r\n    isr.close();\r\n    assertNull(isr.getEncoding());\r\n    try {\r\n        isr = new InputStreamReader(System.in, \"UTF-16BE\");\r\n    } catch (UnsupportedEncodingException e) {\r\n    }\r\n    assertEquals(\"UTF-16BE\", isr.getEncoding());\r\n}"
}, {
	"Path": "java.text.Format.format",
	"Comment": "formats an object and appends the resulting text to a given stringbuffer.if the pos argument identifies a field used by the format,then its indices are set to the beginning and end of the first suchfield encountered.",
	"Method": "String format(Object obj,StringBuffer format,Object obj,StringBuffer toAppendTo,FieldPosition pos){\r\n    return format(obj, new StringBuffer(), new FieldPosition(0)).toString();\r\n}"
}, {
	"Path": "sun.security.x509.OCSPNoCheckExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    return (new AttributeNameEnumeration()).elements();\r\n}"
}, {
	"Path": "libcore.java.util.CalendarTest.test_nullLocale_getInstance_Locale",
	"Comment": "here. we should add a targetsdkversion based check and throw for this case.",
	"Method": "void test_nullLocale_getInstance_Locale(){\r\n    assertCalendarConfigEquals(Calendar.getInstance(Locale.getDefault()), Calendar.getInstance((Locale) null));\r\n}"
}, {
	"Path": "java.security.KeyFactory.translateKey",
	"Comment": "translates a key object, whose provider may be unknown or potentiallyuntrusted, into a corresponding key object of this key factory.",
	"Method": "Key translateKey(Key key){\r\n    if (serviceIterator == null) {\r\n        return spi.engineTranslateKey(key);\r\n    }\r\n    Exception failure = null;\r\n    KeyFactorySpi mySpi = spi;\r\n    do {\r\n        try {\r\n            return mySpi.engineTranslateKey(key);\r\n        } catch (Exception e) {\r\n            if (failure == null) {\r\n                failure = e;\r\n            }\r\n            mySpi = nextSpi(mySpi);\r\n        }\r\n    } while (mySpi != null);\r\n    if (failure instanceof RuntimeException) {\r\n        throw (RuntimeException) failure;\r\n    }\r\n    if (failure instanceof InvalidKeyException) {\r\n        throw (InvalidKeyException) failure;\r\n    }\r\n    throw new InvalidKeyException(\"Could not translate key\", failure);\r\n}"
}, {
	"Path": "java.util.jar.JarVerifier.getCodeSigners",
	"Comment": "return an array of codesigner objects forthe given file in the jar. this array is not cloned.",
	"Method": "CodeSigner[] getCodeSigners(String name,CodeSigner[] getCodeSigners,JarFile jar,JarEntry entry){\r\n    String name = entry.getName();\r\n    if (eagerValidation && sigFileSigners.get(name) != null) {\r\n        try {\r\n            InputStream s = jar.getInputStream(entry);\r\n            byte[] buffer = new byte[1024];\r\n            int n = buffer.length;\r\n            while (n != -1) {\r\n                n = s.read(buffer, 0, buffer.length);\r\n            }\r\n            s.close();\r\n        } catch (IOException e) {\r\n        }\r\n    }\r\n    return getCodeSigners(name);\r\n}"
}, {
	"Path": "java.net.DatagramPacket.setPort",
	"Comment": "sets the port number on the remote host to which this datagramis being sent.",
	"Method": "void setPort(int iport){\r\n    if (iport < 0 || iport > 0xFFFF) {\r\n        throw new IllegalArgumentException(\"Port out of range:\" + iport);\r\n    }\r\n    port = iport;\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testReferenceGetAndUpdate",
	"Comment": "atomicreference getandupdate returns previous value and updatesresult of supplied function",
	"Method": "void testReferenceGetAndUpdate(){\r\n    AtomicReference<Integer> a = new AtomicReference<Integer>(one);\r\n    assertEquals(new Integer(1), a.getAndUpdate(Atomic8Test::addInteger17));\r\n    assertEquals(new Integer(18), a.getAndUpdate(Atomic8Test::addInteger17));\r\n    assertEquals(new Integer(35), a.get());\r\n}"
}, {
	"Path": "javax.security.auth.callback.PasswordCallback.isEchoOn",
	"Comment": "return whether the passwordshould be displayed as it is being typed.",
	"Method": "boolean isEchoOn(){\r\n    return echoOn;\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testCompleteExceptionally2",
	"Comment": "invoke task throws exception after invoking completeexceptionally",
	"Method": "void testCompleteExceptionally2(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            CCF n = new LCCF(8);\r\n            CCF f = new LCCF(n, 8);\r\n            FJException ex = new FJException();\r\n            f.completeExceptionally(ex);\r\n            f.checkCompletedExceptionally(ex);\r\n            n.checkCompletedExceptionally(ex);\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testCompleteExceptionally2",
	"Comment": "invoke task throws exception after invoking completeexceptionally",
	"Method": "void testCompleteExceptionally2(){\r\n    CCF n = new LCCF(8);\r\n    CCF f = new LCCF(n, 8);\r\n    FJException ex = new FJException();\r\n    f.completeExceptionally(ex);\r\n    f.checkCompletedExceptionally(ex);\r\n    n.checkCompletedExceptionally(ex);\r\n}"
}, {
	"Path": "sun.security.x509.EDIPartyName.subtreeDepth",
	"Comment": "return subtree depth of this name for purposes of determiningnameconstraints minimum and maximum bounds and for calculatingpath lengths in name subtrees.",
	"Method": "int subtreeDepth(){\r\n    throw new UnsupportedOperationException(\"subtreeDepth() not supported for EDIPartyName\");\r\n}"
}, {
	"Path": "libcore.java.util.Base64Test.testRoundTrip_allBytes_mime_lineLength_isRoundedDown",
	"Comment": "checks that the specified line length is rounded down to the nearest multiple of 4.",
	"Method": "void testRoundTrip_allBytes_mime_lineLength_isRoundedDown(){\r\n    Decoder decoder = Base64.getMimeDecoder();\r\n    byte[] separator = new byte[] { '\\r', '\\n' };\r\n    checkRoundTrip_allBytes(Base64.getMimeEncoder(60, separator), decoder, wrapLines(\"\\r\\n\", ALL_BYTE_VALUES_ENCODED, 60));\r\n    checkRoundTrip_allBytes(Base64.getMimeEncoder(63, separator), decoder, wrapLines(\"\\r\\n\", ALL_BYTE_VALUES_ENCODED, 60));\r\n    checkRoundTrip_allBytes(Base64.getMimeEncoder(10, separator), decoder, wrapLines(\"\\r\\n\", ALL_BYTE_VALUES_ENCODED, 8));\r\n}"
}, {
	"Path": "java.net.Inet6Address.isMCLinkLocal",
	"Comment": "utility routine to check if the multicast address has link scope.",
	"Method": "boolean isMCLinkLocal(){\r\n    return ((ipaddress[0] & 0xff) == 0xff && (ipaddress[1] & 0x0f) == 0x02);\r\n}"
}, {
	"Path": "android.icu.dev.test.timezone.TimeZoneRegressionTest.Test4162593",
	"Comment": "timezone broken at midnight.the timezone code fails to handletransitions at midnight correctly.",
	"Method": "void Test4162593(){\r\n    SimpleDateFormat fmt = new SimpleDateFormat(\"z\", Locale.US);\r\n    final int ONE_HOUR = 60 * 60 * 1000;\r\n    final float H = (float) ONE_HOUR;\r\n    TimeZone initialZone = TimeZone.getDefault();\r\n    SimpleDateFormat sdf = new SimpleDateFormat(\"MMM dd yyyy HH:mm z\");\r\n    SimpleTimeZone asuncion = new SimpleTimeZone(-4 * ONE_HOUR, \"America/Asuncion\", Calendar.OCTOBER, 1, 0, 0 * ONE_HOUR, Calendar.MARCH, 1, 0, 0 * ONE_HOUR, 1 * ONE_HOUR);\r\n    Object[] DATA = { new SimpleTimeZone(2 * ONE_HOUR, \"Asia/Damascus\", Calendar.APRIL, 1, 0, 0 * ONE_HOUR, Calendar.OCTOBER, 1, 0, 0 * ONE_HOUR, 1 * ONE_HOUR), new int[] { 1998, Calendar.SEPTEMBER, 30, 22, 0 }, Boolean.TRUE, asuncion, new int[] { 2000, Calendar.FEBRUARY, 28, 22, 0 }, Boolean.FALSE, asuncion, new int[] { 2000, Calendar.FEBRUARY, 29, 22, 0 }, Boolean.TRUE };\r\n    String[] zone = new String[4];\r\n    for (int j = 0; j < DATA.length; j += 3) {\r\n        TimeZone tz = (TimeZone) DATA[j];\r\n        TimeZone.setDefault(tz);\r\n        fmt.setTimeZone(tz);\r\n        sdf.setTimeZone(tz);\r\n        int[] p = (int[]) DATA[j + 1];\r\n        Calendar cal = Calendar.getInstance();\r\n        cal.clear();\r\n        cal.set(p[0], p[1], p[2], p[3], p[4]);\r\n        long start = cal.getTime().getTime();\r\n        boolean transitionExpected = ((Boolean) DATA[j + 2]).booleanValue();\r\n        logln(tz.getID() + \":\");\r\n        for (int i = 0; i < 4; ++i) {\r\n            Date d = new Date(start + i * ONE_HOUR);\r\n            zone[i] = fmt.format(d);\r\n            logln(\"\" + i + \": \" + sdf.format(d) + \" => \" + zone[i] + \" (\" + d.getTime() / H + \")\");\r\n        }\r\n        cal.set(p[0], p[1], p[2], 0, 0);\r\n        for (int i = 0; i < 4; ++i) {\r\n            int h = 22 + i;\r\n            int dom = p[2] + (h >= 24 ? 1 : 0);\r\n            h %= 24;\r\n            int ms = h * ONE_HOUR;\r\n            cal.clear();\r\n            cal.set(p[0], p[1], dom, 0, 0);\r\n            int off = tz.getOffset(GregorianCalendar.AD, cal.get(Calendar.YEAR), cal.get(Calendar.MONTH), cal.get(Calendar.DATE), cal.get(Calendar.DAY_OF_WEEK), ms);\r\n            cal.add(Calendar.HOUR, h);\r\n            int dstOffset = cal.get(Calendar.DST_OFFSET);\r\n            logln(\"h=\" + h + \"; dom=\" + dom + \"; ZONE_OFFSET=\" + cal.get(Calendar.ZONE_OFFSET) / H + \"; DST_OFFSET=\" + dstOffset / H + \"; getOffset()=\" + off / H + \" (\" + cal.getTime().getTime() / H + \")\");\r\n        }\r\n        if (zone[0].equals(zone[1]) && (zone[1].equals(zone[2]) != transitionExpected) && zone[2].equals(zone[3])) {\r\n            logln(\"Ok: transition \" + transitionExpected);\r\n        } else {\r\n            errln(\"FAIL: expected \" + (transitionExpected ? \"transition\" : \"no transition\"));\r\n        }\r\n    }\r\n    TimeZone.setDefault(initialZone);\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.decodeRules",
	"Comment": "given a set of encoded rules in startday and startdayofmonth, decodethem and set the startmode appropriately.do the same for endday andenddayofmonth.upon entry, the day of week variables may be zero ornegative, in order to indicate special modes.the day of monthvariables may also be negative.upon exit, the mode variables will beset, and the day of week and day of month variables will be positive.this method also recognizes a startday or endday of zero as indicatingno dst.",
	"Method": "void decodeRules(){\r\n    decodeStartRule();\r\n    decodeEndRule();\r\n}"
}, {
	"Path": "java.util.zip.GZIPOutputStream.write",
	"Comment": "writes array of bytes to the compressed output stream. this methodwill block until all the bytes are written.",
	"Method": "void write(byte[] buf,int off,int len){\r\n    super.write(buf, off, len);\r\n    crc.update(buf, off, len);\r\n}"
}, {
	"Path": "java.util.stream.AbstractTask.getTargetSize",
	"Comment": "returns the targetsize, initializing it via the suppliedsize estimate if not already initialized.",
	"Method": "long getTargetSize(long sizeEstimate){\r\n    long s;\r\n    return ((s = targetSize) != 0 ? s : (targetSize = suggestTargetSize(sizeEstimate)));\r\n}"
}, {
	"Path": "java.util.Hashtable.putAll",
	"Comment": "copies all of the mappings from the specified map to this hashtable.these mappings will replace any mappings that this hashtable had for anyof the keys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> t){\r\n    for (Map.Entry<? extends K, ? extends V> e : t.entrySet()) put(e.getKey(), e.getValue());\r\n}"
}, {
	"Path": "jsr166.ArrayBlockingQueueTest.populatedQueue",
	"Comment": "returns a new queue of given size containing consecutiveintegers 0 ... n.",
	"Method": "ArrayBlockingQueue<Integer> populatedQueue(int n){\r\n    ArrayBlockingQueue<Integer> q = new ArrayBlockingQueue<Integer>(n);\r\n    assertTrue(q.isEmpty());\r\n    for (int i = 0; i < n; i++) assertTrue(q.offer(new Integer(i)));\r\n    assertFalse(q.isEmpty());\r\n    assertEquals(0, q.remainingCapacity());\r\n    assertEquals(n, q.size());\r\n    return q;\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testPeekNextLocalTaskAsync",
	"Comment": "peeknextlocaltask returns least recent unexecuted task in async mode",
	"Method": "void testPeekNextLocalTaskAsync(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() {\r\n            FibTask g = new FibTask(9);\r\n            assertSame(g, g.fork());\r\n            FibTask f = new FibTask(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, peekNextLocalTask());\r\n            assertEquals(21, (int) f.join());\r\n            helpQuiesce();\r\n            checkCompletedNormally(f, 21);\r\n            checkCompletedNormally(g, 34);\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(asyncSingletonPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testPeekNextLocalTaskAsync",
	"Comment": "peeknextlocaltask returns least recent unexecuted task in async mode",
	"Method": "void testPeekNextLocalTaskAsync(){\r\n    FibTask g = new FibTask(9);\r\n    assertSame(g, g.fork());\r\n    FibTask f = new FibTask(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, peekNextLocalTask());\r\n    assertEquals(21, (int) f.join());\r\n    helpQuiesce();\r\n    checkCompletedNormally(f, 21);\r\n    checkCompletedNormally(g, 34);\r\n    return NoResult;\r\n}"
}, {
	"Path": "java.net.Inet4Address.isSiteLocalAddress",
	"Comment": "utility routine to check if the inetaddress is a site local address.",
	"Method": "boolean isSiteLocalAddress(){\r\n    int address = holder().getAddress();\r\n    return (((address >>> 24) & 0xFF) == 10) || ((((address >>> 24) & 0xFF) == 172) && (((address >>> 16) & 0xF0) == 16)) || ((((address >>> 24) & 0xFF) == 192) && (((address >>> 16) & 0xFF) == 168));\r\n}"
}, {
	"Path": "java.time.ZoneOffset.getTotalSeconds",
	"Comment": "gets the total zone offset in seconds.this is the primary way to access the offset amount.it returns the total of the hours, minutes and seconds fields as asingle offset that can be added to a time.",
	"Method": "int getTotalSeconds(){\r\n    return totalSeconds;\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSubSetTest.testDescendingAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testDescendingAddAll3(){\r\n    NavigableSet q = dset0();\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i + SIZE);\r\n    try {\r\n        q.addAll(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "tests.util.SerializationTester.assertEquals",
	"Comment": "tests the serialization and deserialization of instance objects.",
	"Method": "boolean assertEquals(Object inputObject){\r\n    return inputObject.equals(getDeserilizedObject(inputObject));\r\n}"
}, {
	"Path": "java.util.TimeZone.hasSameRules",
	"Comment": "returns true if this zone has the same rule and offset as another zone.that is, if this zone differs only in id, if at all.returns falseif the other zone is null.",
	"Method": "boolean hasSameRules(TimeZone other){\r\n    return other != null && getRawOffset() == other.getRawOffset() && useDaylightTime() == other.useDaylightTime();\r\n}"
}, {
	"Path": "javax.crypto.spec.RC5ParameterSpec.hashCode",
	"Comment": "calculates a hash code value for the object.objects that are equal will also have the same hashcode.",
	"Method": "int hashCode(){\r\n    int retval = 0;\r\n    if (iv != null) {\r\n        for (int i = 1; i < iv.length; i++) {\r\n            retval += iv[i] * i;\r\n        }\r\n    }\r\n    retval += (version + rounds + wordSize);\r\n    return retval;\r\n}"
}, {
	"Path": "java.util.concurrent.ArrayBlockingQueue.enqueue",
	"Comment": "inserts element at current put position, advances, and signals.call only when holding lock.",
	"Method": "void enqueue(E x){\r\n    final Object[] items = this.items;\r\n    items[putIndex] = x;\r\n    if (++putIndex == items.length)\r\n        putIndex = 0;\r\n    count++;\r\n    notEmpty.signal();\r\n}"
}, {
	"Path": "java.io.StringBufferInputStream.skip",
	"Comment": "skips n bytes of input from this input stream. fewerbytes might be skipped if the end of the input stream is reached.",
	"Method": "long skip(long n){\r\n    if (n < 0) {\r\n        return 0;\r\n    }\r\n    if (n > count - pos) {\r\n        n = count - pos;\r\n    }\r\n    pos += n;\r\n    return n;\r\n}"
}, {
	"Path": "java.time.format.DateTimePrintContext.getDecimalStyle",
	"Comment": "gets the decimalstyle.the decimalstyle controls the localization of numeric output.",
	"Method": "DecimalStyle getDecimalStyle(){\r\n    return formatter.getDecimalStyle();\r\n}"
}, {
	"Path": "java.security.KeyStore.getKey",
	"Comment": "returns the key associated with the given alias, using the givenpassword to recover it.the key must have been associated withthe alias by a call to setkeyentry,or by a call to setentry with aprivatekeyentry or secretkeyentry.",
	"Method": "Key getKey(String alias,char[] password){\r\n    if (!initialized) {\r\n        throw new KeyStoreException(\"Uninitialized keystore\");\r\n    }\r\n    return keyStoreSpi.engineGetKey(alias, password);\r\n}"
}, {
	"Path": "java.security.SignatureSpi.engineSign",
	"Comment": "returns the signature bytes of all the dataupdated so far.the format of the signature depends on the underlyingsignature scheme.",
	"Method": "byte[] engineSign(int engineSign,byte[] outbuf,int offset,int len){\r\n    byte[] sig = engineSign();\r\n    if (len < sig.length) {\r\n        throw new SignatureException(\"partial signatures not returned\");\r\n    }\r\n    if (outbuf.length - offset < sig.length) {\r\n        throw new SignatureException(\"insufficient space in the output buffer to store the \" + \"signature\");\r\n    }\r\n    System.arraycopy(sig, 0, outbuf, offset, sig.length);\r\n    return sig.length;\r\n}"
}, {
	"Path": "java.util.concurrent.ThreadPoolExecutor.getCompletedTaskCount",
	"Comment": "returns the approximate total number of tasks that havecompleted execution. because the states of tasks and threadsmay change dynamically during computation, the returned valueis only an approximation, but one that does not ever decreaseacross successive calls.",
	"Method": "long getCompletedTaskCount(){\r\n    final ReentrantLock mainLock = this.mainLock;\r\n    mainLock.lock();\r\n    try {\r\n        long n = completedTaskCount;\r\n        for (Worker w : workers) n += w.completedTasks;\r\n        return n;\r\n    } finally {\r\n        mainLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.GeneralSubtrees.reduce",
	"Comment": "reduce this generalsubtrees by contents of another.this functionis used in merging excluded nameconstraints with permitted nameconstraintsto obtain a minimal form of permitted nameconstraints.it is anoptimization, and does not affect correctness of the results.",
	"Method": "void reduce(GeneralSubtrees excluded){\r\n    if (excluded == null) {\r\n        return;\r\n    }\r\n    for (int i = 0, n = excluded.size(); i < n; i++) {\r\n        GeneralNameInterface excludedName = excluded.getGeneralNameInterface(i);\r\n        for (int j = 0; j < size(); j++) {\r\n            GeneralNameInterface permitted = getGeneralNameInterface(j);\r\n            switch(excludedName.constrains(permitted)) {\r\n                case GeneralNameInterface.NAME_DIFF_TYPE:\r\n                    break;\r\n                case GeneralNameInterface.NAME_MATCH:\r\n                    remove(j);\r\n                    j--;\r\n                    break;\r\n                case GeneralNameInterface.NAME_NARROWS:\r\n                    remove(j);\r\n                    j--;\r\n                    break;\r\n                case GeneralNameInterface.NAME_WIDENS:\r\n                    break;\r\n                case GeneralNameInterface.NAME_SAME_TYPE:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.mutableModInverse",
	"Comment": "returns the modinverse of this mod p. this and p are not affected bythe operation.",
	"Method": "MutableBigInteger mutableModInverse(MutableBigInteger p){\r\n    if (p.isOdd())\r\n        return modInverse(p);\r\n    if (isEven())\r\n        throw new ArithmeticException(\"BigInteger not invertible.\");\r\n    int powersOf2 = p.getLowestSetBit();\r\n    MutableBigInteger oddMod = new MutableBigInteger(p);\r\n    oddMod.rightShift(powersOf2);\r\n    if (oddMod.isOne())\r\n        return modInverseMP2(powersOf2);\r\n    MutableBigInteger oddPart = modInverse(oddMod);\r\n    MutableBigInteger evenPart = modInverseMP2(powersOf2);\r\n    MutableBigInteger y1 = modInverseBP2(oddMod, powersOf2);\r\n    MutableBigInteger y2 = oddMod.modInverseMP2(powersOf2);\r\n    MutableBigInteger temp1 = new MutableBigInteger();\r\n    MutableBigInteger temp2 = new MutableBigInteger();\r\n    MutableBigInteger result = new MutableBigInteger();\r\n    oddPart.leftShift(powersOf2);\r\n    oddPart.multiply(y1, result);\r\n    evenPart.multiply(oddMod, temp1);\r\n    temp1.multiply(y2, temp2);\r\n    result.add(temp2);\r\n    return result.divide(p, temp1);\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.modInverseBP2",
	"Comment": "calculate the multiplicative inverse of 2^k mod mod, where mod is odd.",
	"Method": "MutableBigInteger modInverseBP2(MutableBigInteger mod,int k){\r\n    return fixup(new MutableBigInteger(1), new MutableBigInteger(mod), k);\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testSet2",
	"Comment": "set throws an indexoutofboundsexception on a too high index",
	"Method": "void testSet2(){\r\n    CopyOnWriteArrayList c = populatedArray(5);\r\n    List[] lists = { c, c.subList(1, c.size() - 1) };\r\n    for (List list : lists) {\r\n        try {\r\n            list.set(list.size(), \"qwerty\");\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testCompleteExceptionally",
	"Comment": "invoke task throws exception after invoking completeexceptionally",
	"Method": "void testCompleteExceptionally(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FibAction f = new FibAction(8);\r\n            f.completeExceptionally(new FJException());\r\n            try {\r\n                f.invoke();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testCompleteExceptionally",
	"Comment": "invoke task throws exception after invoking completeexceptionally",
	"Method": "void testCompleteExceptionally(){\r\n    FibAction f = new FibAction(8);\r\n    f.completeExceptionally(new FJException());\r\n    try {\r\n        f.invoke();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "jsr166.AtomicStampedReferenceTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for reference valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    final AtomicStampedReference ai = new AtomicStampedReference(one, 0);\r\n    Thread t = new Thread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!ai.compareAndSet(two, three, 0, 0)) Thread.yield();\r\n        }\r\n    });\r\n    t.start();\r\n    assertTrue(ai.compareAndSet(one, two, 0, 0));\r\n    t.join(LONG_DELAY_MS);\r\n    assertFalse(t.isAlive());\r\n    assertSame(three, ai.getReference());\r\n    assertEquals(0, ai.getStamp());\r\n}"
}, {
	"Path": "jsr166.AtomicStampedReferenceTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for reference valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    while (!ai.compareAndSet(two, three, 0, 0)) Thread.yield();\r\n}"
}, {
	"Path": "java.util.zip.ZipFile.getEntry",
	"Comment": "returns the zip file entry for the specified name, or nullif not found.",
	"Method": "ZipEntry getEntry(String name,long getEntry,long jzfile,byte[] name,boolean addSlash){\r\n    if (name == null) {\r\n        throw new NullPointerException(\"name\");\r\n    }\r\n    long jzentry = 0;\r\n    synchronized (this) {\r\n        ensureOpen();\r\n        jzentry = getEntry(jzfile, zc.getBytes(name), true);\r\n        if (jzentry != 0) {\r\n            ZipEntry ze = getZipEntry(name, jzentry);\r\n            freeEntry(jzfile, jzentry);\r\n            return ze;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.assertHasWaitersLocked",
	"Comment": "checks that condition c has exactly the given waiter threads.",
	"Method": "void assertHasWaitersLocked(Mutex sync,ConditionObject c,Thread threads){\r\n    assertEquals(threads.length > 0, sync.hasWaiters(c));\r\n    assertEquals(threads.length, sync.getWaitQueueLength(c));\r\n    assertEquals(threads.length == 0, sync.getWaitingThreads(c).isEmpty());\r\n    assertEquals(threads.length, sync.getWaitingThreads(c).size());\r\n    assertEquals(new HashSet<Thread>(sync.getWaitingThreads(c)), new HashSet<Thread>(Arrays.asList(threads)));\r\n}"
}, {
	"Path": "java.net.Inet6Address.isMCOrgLocal",
	"Comment": "utility routine to check if the multicast address has organization scope.",
	"Method": "boolean isMCOrgLocal(){\r\n    return ((ipaddress[0] & 0xff) == 0xff && (ipaddress[1] & 0x0f) == 0x08);\r\n}"
}, {
	"Path": "java.lang.Enum.equals",
	"Comment": "returns true if the specified object is equal to thisenum constant.",
	"Method": "boolean equals(Object other){\r\n    return this == other;\r\n}"
}, {
	"Path": "java.util.concurrent.Exchanger.arenaExchange",
	"Comment": "exchange function when arenas enabled. see above for explanation.",
	"Method": "Object arenaExchange(Object item,boolean timed,long ns){\r\n    Node[] a = arena;\r\n    Node p = participant.get();\r\n    for (int i = p.index; ; ) {\r\n        int b, m, c;\r\n        long j;\r\n        Node q = (Node) U.getObjectVolatile(a, j = (i << ASHIFT) + ABASE);\r\n        if (q != null && U.compareAndSwapObject(a, j, q, null)) {\r\n            Object v = q.item;\r\n            q.match = item;\r\n            Thread w = q.parked;\r\n            if (w != null)\r\n                U.unpark(w);\r\n            return v;\r\n        } else if (i <= (m = (b = bound) & MMASK) && q == null) {\r\n            p.item = item;\r\n            if (U.compareAndSwapObject(a, j, null, p)) {\r\n                long end = (timed && m == 0) ? System.nanoTime() + ns : 0L;\r\n                Thread t = Thread.currentThread();\r\n                for (int h = p.hash, spins = SPINS; ; ) {\r\n                    Object v = p.match;\r\n                    if (v != null) {\r\n                        U.putOrderedObject(p, MATCH, null);\r\n                        p.item = null;\r\n                        p.hash = h;\r\n                        return v;\r\n                    } else if (spins > 0) {\r\n                        h ^= h << 1;\r\n                        h ^= h >>> 3;\r\n                        h ^= h << 10;\r\n                        if (h == 0)\r\n                            h = SPINS | (int) t.getId();\r\n                        else if (h < 0 && (--spins & ((SPINS >>> 1) - 1)) == 0)\r\n                            Thread.yield();\r\n                    } else if (U.getObjectVolatile(a, j) != p)\r\n                        spins = SPINS;\r\n                    else if (!t.isInterrupted() && m == 0 && (!timed || (ns = end - System.nanoTime()) > 0L)) {\r\n                        U.putObject(t, BLOCKER, this);\r\n                        p.parked = t;\r\n                        if (U.getObjectVolatile(a, j) == p)\r\n                            U.park(false, ns);\r\n                        p.parked = null;\r\n                        U.putObject(t, BLOCKER, null);\r\n                    } else if (U.getObjectVolatile(a, j) == p && U.compareAndSwapObject(a, j, p, null)) {\r\n                        if (m != 0)\r\n                            U.compareAndSwapInt(this, BOUND, b, b + SEQ - 1);\r\n                        p.item = null;\r\n                        p.hash = h;\r\n                        i = p.index >>>= 1;\r\n                        if (Thread.interrupted())\r\n                            return null;\r\n                        if (timed && m == 0 && ns <= 0L)\r\n                            return TIMED_OUT;\r\n                        break;\r\n                    }\r\n                }\r\n            } else\r\n                p.item = null;\r\n        } else {\r\n            if (p.bound != b) {\r\n                p.bound = b;\r\n                p.collides = 0;\r\n                i = (i != m || m == 0) ? m : m - 1;\r\n            } else if ((c = p.collides) < m || m == FULL || !U.compareAndSwapInt(this, BOUND, b, b + SEQ + 1)) {\r\n                p.collides = c + 1;\r\n                i = (i == 0) ? m : i - 1;\r\n            } else\r\n                i = m + 1;\r\n            p.index = i;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.net.URLConnection.checkfpx",
	"Comment": "check for flashpix image data in inputstream is.return true ifthe stream has flashpix data, false otherwise.before calling thismethod, the stream should have already been checked to be sure itcontains microsoft structured storage data.",
	"Method": "boolean checkfpx(InputStream is){\r\n    is.mark(0x100);\r\n    long toSkip = (long) 0x1C;\r\n    long posn;\r\n    if ((posn = skipForward(is, toSkip)) < toSkip) {\r\n        is.reset();\r\n        return false;\r\n    }\r\n    int[] c = new int[16];\r\n    if (readBytes(c, 2, is) < 0) {\r\n        is.reset();\r\n        return false;\r\n    }\r\n    int byteOrder = c[0];\r\n    posn += 2;\r\n    int uSectorShift;\r\n    if (readBytes(c, 2, is) < 0) {\r\n        is.reset();\r\n        return false;\r\n    }\r\n    if (byteOrder == 0xFE) {\r\n        uSectorShift = c[0];\r\n        uSectorShift += c[1] << 8;\r\n    } else {\r\n        uSectorShift = c[0] << 8;\r\n        uSectorShift += c[1];\r\n    }\r\n    posn += 2;\r\n    toSkip = (long) 0x30 - posn;\r\n    long skipped = 0;\r\n    if ((skipped = skipForward(is, toSkip)) < toSkip) {\r\n        is.reset();\r\n        return false;\r\n    }\r\n    posn += skipped;\r\n    if (readBytes(c, 4, is) < 0) {\r\n        is.reset();\r\n        return false;\r\n    }\r\n    int sectDirStart;\r\n    if (byteOrder == 0xFE) {\r\n        sectDirStart = c[0];\r\n        sectDirStart += c[1] << 8;\r\n        sectDirStart += c[2] << 16;\r\n        sectDirStart += c[3] << 24;\r\n    } else {\r\n        sectDirStart = c[0] << 24;\r\n        sectDirStart += c[1] << 16;\r\n        sectDirStart += c[2] << 8;\r\n        sectDirStart += c[3];\r\n    }\r\n    posn += 4;\r\n    is.reset();\r\n    toSkip = 0x200L + (long) (1 << uSectorShift) * sectDirStart + 0x50L;\r\n    if (toSkip < 0) {\r\n        return false;\r\n    }\r\n    is.mark((int) toSkip + 0x30);\r\n    if ((skipForward(is, toSkip)) < toSkip) {\r\n        is.reset();\r\n        return false;\r\n    }\r\n    if (readBytes(c, 16, is) < 0) {\r\n        is.reset();\r\n        return false;\r\n    }\r\n    if (byteOrder == 0xFE && c[0] == 0x00 && c[2] == 0x61 && c[3] == 0x56 && c[4] == 0x54 && c[5] == 0xC1 && c[6] == 0xCE && c[7] == 0x11 && c[8] == 0x85 && c[9] == 0x53 && c[10] == 0x00 && c[11] == 0xAA && c[12] == 0x00 && c[13] == 0xA1 && c[14] == 0xF9 && c[15] == 0x5B) {\r\n        is.reset();\r\n        return true;\r\n    } else if (c[3] == 0x00 && c[1] == 0x61 && c[0] == 0x56 && c[5] == 0x54 && c[4] == 0xC1 && c[7] == 0xCE && c[6] == 0x11 && c[8] == 0x85 && c[9] == 0x53 && c[10] == 0x00 && c[11] == 0xAA && c[12] == 0x00 && c[13] == 0xA1 && c[14] == 0xF9 && c[15] == 0x5B) {\r\n        is.reset();\r\n        return true;\r\n    }\r\n    is.reset();\r\n    return false;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.BuildStep.verboseToString",
	"Comment": "return a string representation of this build step, showing all detail ofthe vertex state appropriate to the result of this build step, and thecertificate contents.",
	"Method": "String verboseToString(){\r\n    String out = resultToString(getResult());\r\n    switch(result) {\r\n        case BACK:\r\n        case FAIL:\r\n            out = out + vertex.throwableToString();\r\n            break;\r\n        case FOLLOW:\r\n        case SUCCEED:\r\n            out = out + vertex.moreToString();\r\n            break;\r\n        case POSSIBLE:\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    out = out + \"Certificate contains:\\n\" + vertex.certToString();\r\n    return out;\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.getMaxCRL",
	"Comment": "returns the maxcrlnumber criterion. the x509crl must have acrl number extension whose value is less than or equal to thespecified value. if null, no maxcrlnumber check will bedone.",
	"Method": "BigInteger getMaxCRL(){\r\n    return maxCRL;\r\n}"
}, {
	"Path": "java.util.jar.JarVerifier.mapSignersToCertArray",
	"Comment": "convert an array of signers into an array of concatenated certificatearrays.",
	"Method": "java.security.cert.Certificate[] mapSignersToCertArray(CodeSigner[] signers){\r\n    if (signers != null) {\r\n        ArrayList certChains = new ArrayList();\r\n        for (int i = 0; i < signers.length; i++) {\r\n            certChains.addAll(signers[i].getSignerCertPath().getCertificates());\r\n        }\r\n        return (java.security.cert.Certificate[]) certChains.toArray(new java.security.cert.Certificate[certChains.size()]);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.io.PrintStream.close",
	"Comment": "closes the stream.this is done by flushing the stream and then closingthe underlying output stream.",
	"Method": "void close(){\r\n    synchronized (this) {\r\n        if (!closing) {\r\n            closing = true;\r\n            try {\r\n                if (textOut != null) {\r\n                    textOut.close();\r\n                }\r\n                out.close();\r\n            } catch (IOException x) {\r\n                trouble = true;\r\n            }\r\n            textOut = null;\r\n            charOut = null;\r\n            out = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.net.util.IPAddressUtil.isIPv4MappedAddress",
	"Comment": "utility routine to check if the inetaddress is anipv4 mapped ipv6 address.",
	"Method": "boolean isIPv4MappedAddress(byte[] addr){\r\n    if (addr.length < INADDR16SZ) {\r\n        return false;\r\n    }\r\n    if ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) && (addr[3] == 0x00) && (addr[4] == 0x00) && (addr[5] == 0x00) && (addr[6] == 0x00) && (addr[7] == 0x00) && (addr[8] == 0x00) && (addr[9] == 0x00) && (addr[10] == (byte) 0xff) && (addr[11] == (byte) 0xff)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testLastIndexOf2",
	"Comment": "lastindexof returns the index from the given starting point",
	"Method": "void testLastIndexOf2(){\r\n    CopyOnWriteArrayList full = populatedArray(3);\r\n    full.add(one);\r\n    full.add(three);\r\n    assertEquals(3, full.lastIndexOf(one, 4));\r\n    assertEquals(-1, full.lastIndexOf(three, 3));\r\n}"
}, {
	"Path": "sun.security.util.DisabledAlgorithmConstraints.loadDisabledAlgorithmsMap",
	"Comment": "get disabled algorithm constraints from the specified security property.",
	"Method": "void loadDisabledAlgorithmsMap(String propertyName){\r\n    String property = AccessController.doPrivileged(new PrivilegedAction<String>() {\r\n        public String run() {\r\n            return Security.getProperty(propertyName);\r\n        }\r\n    });\r\n    String[] algorithmsInProperty = null;\r\n    if (property != null && !property.isEmpty()) {\r\n        if (property.charAt(0) == '\"' && property.charAt(property.length() - 1) == '\"') {\r\n            property = property.substring(1, property.length() - 1);\r\n        }\r\n        algorithmsInProperty = property.split(\",\");\r\n        for (int i = 0; i < algorithmsInProperty.length; i++) {\r\n            algorithmsInProperty[i] = algorithmsInProperty[i].trim();\r\n        }\r\n    }\r\n    if (algorithmsInProperty == null) {\r\n        algorithmsInProperty = new String[0];\r\n    }\r\n    disabledAlgorithmsMap.put(propertyName, algorithmsInProperty);\r\n    KeySizeConstraints keySizeConstraints = new KeySizeConstraints(algorithmsInProperty);\r\n    keySizeConstraintsMap.put(propertyName, keySizeConstraints);\r\n}"
}, {
	"Path": "sun.security.util.DisabledAlgorithmConstraints.loadDisabledAlgorithmsMap",
	"Comment": "get disabled algorithm constraints from the specified security property.",
	"Method": "void loadDisabledAlgorithmsMap(String propertyName){\r\n    return Security.getProperty(propertyName);\r\n}"
}, {
	"Path": "java.util.AbstractMap.eq",
	"Comment": "utility method for simpleentry and simpleimmutableentry.test for equality, checking for nulls.",
	"Method": "boolean eq(Object o1,Object o2){\r\n    return o1 == null ? o2 == null : o1.equals(o2);\r\n}"
}, {
	"Path": "javax.xml.transform.stream.StreamResult.setOutputStream",
	"Comment": "set the bytestream that is to be written to.normally,a stream should be used rather than a reader, so thatthe transformer may use instructions contained in thetransformation instructions to control the encoding.",
	"Method": "void setOutputStream(OutputStream outputStream){\r\n    this.outputStream = outputStream;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.OcniExtractor.findBlockComments",
	"Comment": "finds all block comments and associates them with their containing type.this is trickier than you might expect because of inner types.",
	"Method": "ListMultimap<TreeNode, Comment> findBlockComments(CompilationUnit unit){\r\n    ListMultimap<TreeNode, Comment> blockComments = MultimapBuilder.hashKeys().arrayListValues().build();\r\n    for (Comment comment : unit.getCommentList()) {\r\n        if (!comment.isBlockComment()) {\r\n            continue;\r\n        }\r\n        int commentPos = comment.getStartPosition();\r\n        AbstractTypeDeclaration containingType = null;\r\n        int containingTypePos = -1;\r\n        for (AbstractTypeDeclaration type : unit.getTypes()) {\r\n            int typePos = type.getStartPosition();\r\n            if (typePos < 0) {\r\n                continue;\r\n            }\r\n            int typeEnd = typePos + type.getLength();\r\n            if (commentPos > typePos && commentPos < typeEnd && typePos > containingTypePos) {\r\n                containingType = type;\r\n                containingTypePos = typePos;\r\n            }\r\n        }\r\n        blockComments.put(containingType != null ? containingType : unit, comment);\r\n    }\r\n    return blockComments;\r\n}"
}, {
	"Path": "org.xml.sax.SAXParseException.getPublicId",
	"Comment": "get the public identifier of the entity where the exception occurred.",
	"Method": "String getPublicId(){\r\n    return this.publicId;\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.mulsubBorrow",
	"Comment": "the method is the same as mulsun, except the fact that q array is notupdated, the only result of the method is borrow flag.",
	"Method": "int mulsubBorrow(int[] q,int[] a,int x,int len,int offset){\r\n    long xLong = x & LONG_MASK;\r\n    long carry = 0;\r\n    offset += len;\r\n    for (int j = len - 1; j >= 0; j--) {\r\n        long product = (a[j] & LONG_MASK) * xLong + carry;\r\n        long difference = q[offset--] - product;\r\n        carry = (product >>> 32) + (((difference & LONG_MASK) > (((~(int) product) & LONG_MASK))) ? 1 : 0);\r\n    }\r\n    return (int) carry;\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testPollNextLocalTask",
	"Comment": "pollnextlocaltask returns most recent unexecuted task withoutexecuting it",
	"Method": "void testPollNextLocalTask(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            CCF g = new LCCF(9);\r\n            assertSame(g, g.fork());\r\n            CCF f = new LCCF(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(f, pollNextLocalTask());\r\n            helpQuiesce();\r\n            checkNotDone(f);\r\n            assertEquals(34, g.number);\r\n            checkCompletedNormally(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testPollNextLocalTask",
	"Comment": "pollnextlocaltask returns most recent unexecuted task withoutexecuting it",
	"Method": "void testPollNextLocalTask(){\r\n    CCF g = new LCCF(9);\r\n    assertSame(g, g.fork());\r\n    CCF f = new LCCF(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(f, pollNextLocalTask());\r\n    helpQuiesce();\r\n    checkNotDone(f);\r\n    assertEquals(34, g.number);\r\n    checkCompletedNormally(g);\r\n}"
}, {
	"Path": "sun.security.provider.X509Factory.engineGetCertPathEncodings",
	"Comment": "returns an iteration of the certpath encodings supportedby this certificate factory, with the default encoding first.attempts to modify the returned iterator via itsremove method result in anunsupportedoperationexception.",
	"Method": "Iterator<String> engineGetCertPathEncodings(){\r\n    return (X509CertPath.getEncodingsStatic());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.OperatorRewriter.getPromotionSuffix",
	"Comment": "some operator functions are given a suffix indicating the promotion type ofthe operands according to jls 5.6.2.",
	"Method": "String getPromotionSuffix(Assignment node){\r\n    if (!needsPromotionSuffix(node.getOperator())) {\r\n        return \"\";\r\n    }\r\n    TypeKind lhsKind = node.getLeftHandSide().getTypeMirror().getKind();\r\n    TypeKind rhsKind = node.getRightHandSide().getTypeMirror().getKind();\r\n    if (lhsKind == TypeKind.DOUBLE || rhsKind == TypeKind.DOUBLE) {\r\n        return \"D\";\r\n    }\r\n    if (lhsKind == TypeKind.FLOAT || rhsKind == TypeKind.FLOAT) {\r\n        return \"F\";\r\n    }\r\n    if (lhsKind == TypeKind.LONG || rhsKind == TypeKind.LONG) {\r\n        return \"J\";\r\n    }\r\n    return \"I\";\r\n}"
}, {
	"Path": "tests.net.DelegatingSocketFactory.configureSocket",
	"Comment": "invoked after obtaining a socket from the delegate and before returning it to the caller.the default implementation does nothing.",
	"Method": "Socket configureSocket(Socket socket){\r\n    return socket;\r\n}"
}, {
	"Path": "java.net.InetAddress.isAnyLocalAddress",
	"Comment": "utility routine to check if the inetaddress in a wildcard address.",
	"Method": "boolean isAnyLocalAddress(){\r\n    return false;\r\n}"
}, {
	"Path": "java.io.CharArrayWriter.writeTo",
	"Comment": "writes the contents of the buffer to another character stream.",
	"Method": "void writeTo(Writer out){\r\n    synchronized (lock) {\r\n        out.write(buf, 0, count);\r\n    }\r\n}"
}, {
	"Path": "java.util.function.LongPredicate.negate",
	"Comment": "returns a predicate that represents the logical negation of thispredicate.",
	"Method": "LongPredicate negate(){\r\n    return (value) -> !test(value);\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.hashCode",
	"Comment": "generates the hash code for this gregoriancalendar object.",
	"Method": "int hashCode(){\r\n    return super.hashCode() ^ (int) gregorianCutoverDate;\r\n}"
}, {
	"Path": "android.icu.dev.util.UnicodeMap.getNonRangeStrings",
	"Comment": "get the strings that are not in the ranges. returns null if there are none.",
	"Method": "Set<String> getNonRangeStrings(){\r\n    if (stringMap == null || stringMap.isEmpty()) {\r\n        return null;\r\n    }\r\n    return Collections.unmodifiableSet(stringMap.keySet());\r\n}"
}, {
	"Path": "java.util.Properties.propertyNames",
	"Comment": "returns an enumeration of all the keys in this property list,including distinct keys in the default property list if a keyof the same name has not already been found from the mainproperties list.",
	"Method": "Enumeration<?> propertyNames(){\r\n    Hashtable h = new Hashtable();\r\n    enumerate(h);\r\n    return h.keys();\r\n}"
}, {
	"Path": "android.icu.dev.test.translit.AnyScriptTest.TestForWidth",
	"Comment": "check to make sure that wide characters are converted when going to narrow scripts.",
	"Method": "void TestForWidth(){\r\n    Transliterator widen = Transliterator.getInstance(\"halfwidth-fullwidth\");\r\n    Transliterator narrow = Transliterator.getInstance(\"fullwidth-halfwidth\");\r\n    UnicodeSet ASCII = new UnicodeSet(\"[:ascii:]\");\r\n    String lettersAndSpace = \"abc def\";\r\n    final String punctOnly = \"( )\";\r\n    String wideLettersAndSpace = widen.transform(lettersAndSpace);\r\n    String widePunctOnly = widen.transform(punctOnly);\r\n    assertContainsNone(\"Should be wide\", ASCII, wideLettersAndSpace);\r\n    assertContainsNone(\"Should be wide\", ASCII, widePunctOnly);\r\n    String back;\r\n    back = narrow.transform(wideLettersAndSpace);\r\n    assertEquals(\"Should be narrow\", lettersAndSpace, back);\r\n    back = narrow.transform(widePunctOnly);\r\n    assertEquals(\"Should be narrow\", punctOnly, back);\r\n    Transliterator latin = Transliterator.getInstance(\"any-Latn\");\r\n    back = latin.transform(wideLettersAndSpace);\r\n    assertEquals(\"Should be ascii\", lettersAndSpace, back);\r\n    back = latin.transform(widePunctOnly);\r\n    assertEquals(\"Should be ascii\", punctOnly, back);\r\n}"
}, {
	"Path": "java.time.format.DecimalStyle.withZeroDigit",
	"Comment": "returns a copy of the info with a new character that represents zero.the character used to represent digits may vary by culture.this method specifies the zero character to use, which implies the characters for one to nine.",
	"Method": "DecimalStyle withZeroDigit(char zeroDigit){\r\n    if (zeroDigit == this.zeroDigit) {\r\n        return this;\r\n    }\r\n    return new DecimalStyle(zeroDigit, positiveSign, negativeSign, decimalSeparator);\r\n}"
}, {
	"Path": "jsr166.ArrayDequeTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    ArrayDeque q = new ArrayDeque();\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        q.addAll(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ArrayDequeTest.testAddAll5",
	"Comment": "deque contains all elements, in traversal order, of successful addall",
	"Method": "void testAddAll5(){\r\n    Integer[] empty = new Integer[0];\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = new Integer(i);\r\n    ArrayDeque q = new ArrayDeque();\r\n    assertFalse(q.addAll(Arrays.asList(empty)));\r\n    assertTrue(q.addAll(Arrays.asList(ints)));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.pollFirst());\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentSkipListSet.descendingIterator",
	"Comment": "returns an iterator over the elements in this set in descending order.",
	"Method": "Iterator<E> descendingIterator(){\r\n    return m.descendingKeySet().iterator();\r\n}"
}, {
	"Path": "java.util.concurrent.PriorityBlockingQueue.clear",
	"Comment": "atomically removes all of the elements from this queue.the queue will be empty after this call returns.",
	"Method": "void clear(){\r\n    final ReentrantLock lock = this.lock;\r\n    lock.lock();\r\n    try {\r\n        Object[] array = queue;\r\n        int n = size;\r\n        size = 0;\r\n        for (int i = 0; i < n; i++) array[i] = null;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "libcore.java.text.NumberFormatTest.test_customCurrencySymbol",
	"Comment": "test to ensure explicitly setting a currency symbol will overwrite the defaults.",
	"Method": "void test_customCurrencySymbol(){\r\n    NumberFormat nf = NumberFormat.getCurrencyInstance(Locale.US);\r\n    DecimalFormatSymbols dfs = ((DecimalFormat) nf).getDecimalFormatSymbols();\r\n    dfs.setCurrencySymbol(\"SPECIAL\");\r\n    ((DecimalFormat) nf).setDecimalFormatSymbols(dfs);\r\n    assertEquals(\"SPECIAL3.14\", nf.format(3.14));\r\n    nf.setCurrency(Currency.getInstance(\"USD\"));\r\n    assertEquals(\"$3.14\", nf.format(3.14));\r\n    dfs.setCurrencySymbol(\"NEW\");\r\n    ((DecimalFormat) nf).setDecimalFormatSymbols(dfs);\r\n    assertEquals(\"NEW3.14\", nf.format(3.14));\r\n}"
}, {
	"Path": "java.util.zip.ZipOutputStream.setMethod",
	"Comment": "sets the default compression method for subsequent entries. thisdefault will be used whenever the compression method is not specifiedfor an individual zip file entry, and is initially set to deflated.",
	"Method": "void setMethod(int method){\r\n    if (method != DEFLATED && method != STORED) {\r\n        throw new IllegalArgumentException(\"invalid compression method\");\r\n    }\r\n    this.method = method;\r\n}"
}, {
	"Path": "sun.security.jca.ProviderList.getService",
	"Comment": "return a service describing an implementation of the specifiedalgorithm from the provider with the highest precedence thatsupports that algorithm. return null if no provider supports thisalgorithm.",
	"Method": "Service getService(String type,String name){\r\n    for (int i = 0; i < configs.length; i++) {\r\n        Provider p = getProvider(i);\r\n        Service s = p.getService(type, name);\r\n        if (s != null) {\r\n            return s;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jsr166.AtomicBooleanTest.testWeakCompareAndSet",
	"Comment": "repeated weakcompareandset succeeds in changing value when equalto expected",
	"Method": "void testWeakCompareAndSet(){\r\n    AtomicBoolean ai = new AtomicBoolean(true);\r\n    do {\r\n    } while (!ai.weakCompareAndSet(true, false));\r\n    assertFalse(ai.get());\r\n    do {\r\n    } while (!ai.weakCompareAndSet(false, false));\r\n    assertFalse(ai.get());\r\n    do {\r\n    } while (!ai.weakCompareAndSet(false, true));\r\n    assertTrue(ai.get());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.ConstantBranchPrunerTest.testParentheses",
	"Comment": "verify parentheses surround boolean constants are removed.",
	"Method": "void testParentheses(){\r\n    String translation = translateSourceFile(\"class Test { int test() { if (((false))) { return 1; } else { return 0; } }}\", \"Test\", \"Test.m\");\r\n    assertTranslatedLines(translation, \"- (jint)test {\", \"{\", \"return 0;\", \"}\", \"}\");\r\n}"
}, {
	"Path": "java.net.DatagramPacket.getLength",
	"Comment": "returns the length of the data to be sent or the length of thedata received.",
	"Method": "int getLength(){\r\n    return length;\r\n}"
}, {
	"Path": "sun.security.x509.AuthorityKeyIdentifierExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(KEY_ID);\r\n    elements.addElement(AUTH_NAME);\r\n    elements.addElement(SERIAL_NUMBER);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "java.net.JarURLConnection.getEntryName",
	"Comment": "return the entry name for this connection. this methodreturns null if the jar file url corresponding to thisconnection points to a jar file and not a jar file entry.",
	"Method": "String getEntryName(){\r\n    return entryName;\r\n}"
}, {
	"Path": "java.net.DatagramSocket.bind",
	"Comment": "binds this datagramsocket to a specific address & port.if the address is null, then the system will pick upan ephemeral port and a valid local address to bind the socket.",
	"Method": "void bind(SocketAddress addr){\r\n    if (isClosed())\r\n        throw new SocketException(\"Socket is closed\");\r\n    if (isBound())\r\n        throw new SocketException(\"already bound\");\r\n    if (addr == null)\r\n        addr = new InetSocketAddress(0);\r\n    if (!(addr instanceof InetSocketAddress))\r\n        throw new IllegalArgumentException(\"Unsupported address type!\");\r\n    InetSocketAddress epoint = (InetSocketAddress) addr;\r\n    if (epoint.isUnresolved())\r\n        throw new SocketException(\"Unresolved address\");\r\n    InetAddress iaddr = epoint.getAddress();\r\n    int port = epoint.getPort();\r\n    checkAddress(iaddr, \"bind\");\r\n    SecurityManager sec = System.getSecurityManager();\r\n    if (sec != null) {\r\n        sec.checkListen(port);\r\n    }\r\n    try {\r\n        getImpl().bind(port, iaddr);\r\n    } catch (SocketException e) {\r\n        getImpl().close();\r\n        throw e;\r\n    }\r\n    bound = true;\r\n}"
}, {
	"Path": "java.util.JumboEnumSet.addAll",
	"Comment": "adds all of the elements in the specified collection to this set.",
	"Method": "void addAll(boolean addAll,Collection<? extends E> c){\r\n    if (!(c instanceof JumboEnumSet))\r\n        return super.addAll(c);\r\n    JumboEnumSet es = (JumboEnumSet) c;\r\n    if (es.elementType != elementType) {\r\n        if (es.isEmpty())\r\n            return false;\r\n        else\r\n            throw new ClassCastException(es.elementType + \" != \" + elementType);\r\n    }\r\n    for (int i = 0; i < elements.length; i++) elements[i] |= es.elements[i];\r\n    return recalculateSize();\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    class ReferenceSet {\r\n        int lower(int key) {\r\n            return ascending ? lowerAscending(key) : higherAscending(key);\r\n        }\r\n        int floor(int key) {\r\n            return ascending ? floorAscending(key) : ceilingAscending(key);\r\n        }\r\n        int ceiling(int key) {\r\n            return ascending ? ceilingAscending(key) : floorAscending(key);\r\n        }\r\n        int higher(int key) {\r\n            return ascending ? higherAscending(key) : lowerAscending(key);\r\n        }\r\n        int first() {\r\n            return ascending ? firstAscending() : lastAscending();\r\n        }\r\n        int last() {\r\n            return ascending ? lastAscending() : firstAscending();\r\n        }\r\n        int lowerAscending(int key) {\r\n            return floorAscending(key - 1);\r\n        }\r\n        int floorAscending(int key) {\r\n            if (key < min)\r\n                return -1;\r\n            else if (key > max)\r\n                key = max;\r\n            while (key >= min) {\r\n                if (bs.get(key))\r\n                    return key;\r\n                key--;\r\n            }\r\n            return -1;\r\n        }\r\n        int ceilingAscending(int key) {\r\n            if (key < min)\r\n                key = min;\r\n            else if (key > max)\r\n                return -1;\r\n            int result = bs.nextSetBit(key);\r\n            return result > max ? -1 : result;\r\n        }\r\n        int higherAscending(int key) {\r\n            return ceilingAscending(key + 1);\r\n        }\r\n        private int firstAscending() {\r\n            int result = ceilingAscending(min);\r\n            return result > max ? -1 : result;\r\n        }\r\n        private int lastAscending() {\r\n            int result = floorAscending(max);\r\n            return result < min ? -1 : result;\r\n        }\r\n    }\r\n    ReferenceSet rs = new ReferenceSet();\r\n    int size = 0;\r\n    for (int i = min; i <= max; i++) {\r\n        boolean bsContainsI = bs.get(i);\r\n        assertEquals(bsContainsI, map.containsKey(i));\r\n        if (bsContainsI)\r\n            size++;\r\n    }\r\n    assertEquals(size, map.size());\r\n    int size2 = 0;\r\n    int previousKey = -1;\r\n    for (int key : map.keySet()) {\r\n        assertTrue(bs.get(key));\r\n        size2++;\r\n        assertTrue(previousKey < 0 || (ascending ? key - previousKey > 0 : key - previousKey < 0));\r\n        previousKey = key;\r\n    }\r\n    assertEquals(size2, size);\r\n    for (int key = min - 1; key <= max + 1; key++) {\r\n        assertEq(map.lowerKey(key), rs.lower(key));\r\n        assertEq(map.floorKey(key), rs.floor(key));\r\n        assertEq(map.higherKey(key), rs.higher(key));\r\n        assertEq(map.ceilingKey(key), rs.ceiling(key));\r\n    }\r\n    if (map.size() != 0) {\r\n        assertEq(map.firstKey(), rs.first());\r\n        assertEq(map.lastKey(), rs.last());\r\n    } else {\r\n        assertEq(rs.first(), -1);\r\n        assertEq(rs.last(), -1);\r\n        try {\r\n            map.firstKey();\r\n            shouldThrow();\r\n        } catch (NoSuchElementException success) {\r\n        }\r\n        try {\r\n            map.lastKey();\r\n            shouldThrow();\r\n        } catch (NoSuchElementException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return ascending ? lowerAscending(key) : higherAscending(key);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return ascending ? floorAscending(key) : ceilingAscending(key);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return ascending ? ceilingAscending(key) : floorAscending(key);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return ascending ? higherAscending(key) : lowerAscending(key);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return ascending ? firstAscending() : lastAscending();\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return ascending ? lastAscending() : firstAscending();\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return floorAscending(key - 1);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    if (key < min)\r\n        return -1;\r\n    else if (key > max)\r\n        key = max;\r\n    while (key >= min) {\r\n        if (bs.get(key))\r\n            return key;\r\n        key--;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    if (key < min)\r\n        key = min;\r\n    else if (key > max)\r\n        return -1;\r\n    int result = bs.nextSetBit(key);\r\n    return result > max ? -1 : result;\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    return ceilingAscending(key + 1);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    int result = ceilingAscending(min);\r\n    return result > max ? -1 : result;\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableMap<Integer, Integer> map,int min,int max,boolean ascending){\r\n    int result = floorAscending(max);\r\n    return result < min ? -1 : result;\r\n}"
}, {
	"Path": "java.util.TimeZone.getOffsets",
	"Comment": "gets the raw gmt offset and the amount of daylight saving of thistime zone at the given time.",
	"Method": "int getOffsets(long date,int[] offsets){\r\n    int rawoffset = getRawOffset();\r\n    int dstoffset = 0;\r\n    if (inDaylightTime(new Date(date))) {\r\n        dstoffset = getDSTSavings();\r\n    }\r\n    if (offsets != null) {\r\n        offsets[0] = rawoffset;\r\n        offsets[1] = dstoffset;\r\n    }\r\n    return rawoffset + dstoffset;\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.monthLength",
	"Comment": "returns the length of the specified month in the specifiedyear. the year number must be normalized.",
	"Method": "int monthLength(int month,int year,int monthLength,int month){\r\n    int year = internalGet(YEAR);\r\n    if (internalGetEra() == BCE) {\r\n        year = 1 - year;\r\n    }\r\n    return monthLength(month, year);\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinPool.getUncaughtExceptionHandler",
	"Comment": "returns the handler for internal worker threads that terminatedue to unrecoverable errors encountered while executing tasks.",
	"Method": "UncaughtExceptionHandler getUncaughtExceptionHandler(){\r\n    return ueh;\r\n}"
}, {
	"Path": "java.util.ComparableTimSort.mergeForceCollapse",
	"Comment": "merges all runs on the stack until only one remains.this method iscalled once, to complete the sort.",
	"Method": "void mergeForceCollapse(){\r\n    while (stackSize > 1) {\r\n        int n = stackSize - 2;\r\n        if (n > 0 && runLen[n - 1] < runLen[n + 1])\r\n            n--;\r\n        mergeAt(n);\r\n    }\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testGetAndAccumulateNPE",
	"Comment": "all atomic getandaccumulate methods throw nullpointerexceptionon null function argument",
	"Method": "void testGetAndAccumulateNPE(){\r\n    Runnable[] throwingActions = { () -> new AtomicLong().getAndAccumulate(1L, null), () -> new AtomicInteger().getAndAccumulate(1, null), () -> new AtomicReference().getAndAccumulate(one, null), () -> new AtomicLongArray(1).getAndAccumulate(0, 1L, null), () -> new AtomicIntegerArray(1).getAndAccumulate(0, 1, null), () -> new AtomicReferenceArray(1).getAndAccumulate(0, one, null), () -> aLongFieldUpdater().getAndAccumulate(this, 1L, null), () -> anIntFieldUpdater().getAndAccumulate(this, 1, null), () -> anIntegerFieldUpdater().getAndAccumulate(this, one, null) };\r\n    assertThrows(NullPointerException.class, throwingActions);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSubSetTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    NavigableSet q = set0();\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i + SIZE);\r\n    try {\r\n        q.addAll(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testCancelledForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGet(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            AsyncFib f = new AsyncFib(8);\r\n            assertTrue(f.cancel(true));\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (CancellationException success) {\r\n                checkCancelled(f);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testCancelledForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGet(){\r\n    AsyncFib f = new AsyncFib(8);\r\n    assertTrue(f.cancel(true));\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (CancellationException success) {\r\n        checkCancelled(f);\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.AlgorithmId.get",
	"Comment": "returns one of the algorithm ids most commonly associatedwith this algorithm parameters.",
	"Method": "AlgorithmId get(String algname,AlgorithmId get,AlgorithmParameters algparams){\r\n    ObjectIdentifier oid;\r\n    String algname = algparams.getAlgorithm();\r\n    try {\r\n        oid = algOID(algname);\r\n    } catch (IOException ioe) {\r\n        throw new NoSuchAlgorithmException(\"Invalid ObjectIdentifier \" + algname);\r\n    }\r\n    if (oid == null) {\r\n        throw new NoSuchAlgorithmException(\"unrecognized algorithm name: \" + algname);\r\n    }\r\n    return new AlgorithmId(oid, algparams);\r\n}"
}, {
	"Path": "sun.nio.ch.NativeObject.getObject",
	"Comment": "reads an address from this native object at the given offset andconstructs a native object using that address.",
	"Method": "NativeObject getObject(int offset){\r\n    long newAddress = 0L;\r\n    switch(addressSize()) {\r\n        case 8:\r\n            newAddress = unsafe.getLong(offset + address);\r\n            break;\r\n        case 4:\r\n            newAddress = unsafe.getInt(offset + address) & 0x00000000FFFFFFFF;\r\n            break;\r\n        default:\r\n            throw new InternalError(\"Address size not supported\");\r\n    }\r\n    return new NativeObject(newAddress);\r\n}"
}, {
	"Path": "android.icu.dev.test.timezone.TimeZoneRuleTest.TestGetSimpleRules",
	"Comment": "extract simple rules from an olsontimezone and make sure the rule format matchesthe expected format.",
	"Method": "void TestGetSimpleRules(){\r\n    long[] testTimes = new long[] { getUTCMillis(1970, Calendar.JANUARY, 1), getUTCMillis(2000, Calendar.MARCH, 31), getUTCMillis(2005, Calendar.JULY, 1), getUTCMillis(2010, Calendar.NOVEMBER, 1) };\r\n    String[] tzids = getTestZIDs();\r\n    for (int n = 0; n < testTimes.length; n++) {\r\n        long time = testTimes[n];\r\n        for (int i = 0; i < tzids.length; i++) {\r\n            BasicTimeZone tz = (BasicTimeZone) TimeZone.getTimeZone(tzids[i], TimeZone.TIMEZONE_ICU);\r\n            TimeZoneRule[] rules = tz.getSimpleTimeZoneRulesNear(time);\r\n            if (rules == null) {\r\n                errln(\"FAIL: Failed to extract simple rules for \" + tzids[i] + \" at \" + time);\r\n            } else {\r\n                if (rules.length == 1) {\r\n                    if (!(rules[0] instanceof InitialTimeZoneRule)) {\r\n                        errln(\"FAIL: Unexpected rule object type is returned for \" + tzids[i] + \" at \" + time);\r\n                    }\r\n                } else if (rules.length == 3) {\r\n                    if (!(rules[0] instanceof InitialTimeZoneRule) || !(rules[1] instanceof AnnualTimeZoneRule) || !(rules[2] instanceof AnnualTimeZoneRule)) {\r\n                        errln(\"FAIL: Unexpected rule object type is returned for \" + tzids[i] + \" at \" + time);\r\n                    }\r\n                    for (int idx = 1; idx <= 2; idx++) {\r\n                        DateTimeRule dtr = ((AnnualTimeZoneRule) rules[idx]).getRule();\r\n                        if (dtr.getTimeRuleType() != DateTimeRule.WALL_TIME) {\r\n                            errln(\"FAIL: WALL_TIME is not used as the time rule in the time zone rule(\" + idx + \") for \" + tzids[i] + \" at \" + time);\r\n                        }\r\n                        if (dtr.getDateRuleType() != DateTimeRule.DOW) {\r\n                            errln(\"FAIL: DOW is not used as the date rule in the time zone rule(\" + idx + \") for \" + tzids[i] + \" at \" + time);\r\n                        }\r\n                    }\r\n                } else {\r\n                    errln(\"FAIL: Unexpected number of rules returned for \" + tzids[i] + \" at \" + time);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.io.ByteArrayOutputStream.toByteArray",
	"Comment": "creates a newly allocated byte array. its size is the currentsize of this output stream and the valid contents of the bufferhave been copied into it.",
	"Method": "byte toByteArray(){\r\n    return Arrays.copyOf(buf, count);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkGetCC",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGetCC(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FailingCCF f = new LFCCF(null, 8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get();\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalForkGetCC",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGetCC(){\r\n    FailingCCF f = new LFCCF(null, 8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get();\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalQuietlyInvokeCC",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvokeCC(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingCCF f = new LFCCF(null, 8);\r\n            f.quietlyInvoke();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalQuietlyInvokeCC",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvokeCC(){\r\n    FailingCCF f = new LFCCF(null, 8);\r\n    f.quietlyInvoke();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.getGroupingSeparator",
	"Comment": "gets the character used for thousands separator. different for french, etc.",
	"Method": "char getGroupingSeparator(){\r\n    return groupingSeparator;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.PKIXMasterCertPathValidator.validate",
	"Comment": "validates a certification path consisting exclusively ofx509certificates using the specifiedpkixcertpathcheckers. it is assumed that thepkixcertpathcheckershave been initialized with any input parameters they may need.",
	"Method": "void validate(CertPath cpOriginal,List<X509Certificate> reversedCertList,List<PKIXCertPathChecker> certPathCheckers){\r\n    int cpSize = reversedCertList.size();\r\n    if (debug != null) {\r\n        debug.println(\"--------------------------------------------------\" + \"------------\");\r\n        debug.println(\"Executing PKIX certification path validation \" + \"algorithm.\");\r\n    }\r\n    for (int i = 0; i < cpSize; i++) {\r\n        if (debug != null)\r\n            debug.println(\"Checking cert\" + (i + 1) + \" ...\");\r\n        X509Certificate currCert = reversedCertList.get(i);\r\n        Set<String> unresCritExts = currCert.getCriticalExtensionOIDs();\r\n        if (unresCritExts == null) {\r\n            unresCritExts = Collections.<String>emptySet();\r\n        }\r\n        if (debug != null && !unresCritExts.isEmpty()) {\r\n            debug.println(\"Set of critical extensions:\");\r\n            for (String oid : unresCritExts) {\r\n                debug.println(oid);\r\n            }\r\n        }\r\n        for (int j = 0; j < certPathCheckers.size(); j++) {\r\n            PKIXCertPathChecker currChecker = certPathCheckers.get(j);\r\n            if (debug != null) {\r\n                debug.println(\"-Using checker\" + (j + 1) + \" ... [\" + currChecker.getClass().getName() + \"]\");\r\n            }\r\n            if (i == 0)\r\n                currChecker.init(false);\r\n            try {\r\n                currChecker.check(currCert, unresCritExts);\r\n                if (debug != null) {\r\n                    debug.println(\"-checker\" + (j + 1) + \" validation succeeded\");\r\n                }\r\n            } catch (CertPathValidatorException cpve) {\r\n                throw new CertPathValidatorException(cpve.getMessage(), cpve.getCause(), cpOriginal, cpSize - (i + 1), cpve.getReason());\r\n            }\r\n        }\r\n        if (!unresCritExts.isEmpty()) {\r\n            throw new CertPathValidatorException(\"unrecognized \" + \"critical extension(s)\", null, cpOriginal, cpSize - (i + 1), PKIXReason.UNRECOGNIZED_CRIT_EXT);\r\n        }\r\n        if (debug != null)\r\n            debug.println(\"\\ncert\" + (i + 1) + \" validation succeeded.\\n\");\r\n    }\r\n    if (debug != null) {\r\n        debug.println(\"Cert path validation succeeded. (PKIX validation \" + \"algorithm)\");\r\n        debug.println(\"-------------------------------------------------\" + \"-------------\");\r\n    }\r\n}"
}, {
	"Path": "java.net.Authenticator.getRequestingURL",
	"Comment": "returns the url that resulted in thisrequest for authentication.",
	"Method": "URL getRequestingURL(){\r\n    return requestingURL;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testFailingThreadFactory",
	"Comment": "execution continues if there is at least one thread even ifthread factory fails to create more",
	"Method": "void testFailingThreadFactory(){\r\n    final ExecutorService e = new ThreadPoolExecutor(100, 100, LONG_DELAY_MS, MILLISECONDS, new LinkedBlockingQueue<Runnable>(), new FailingThreadFactory());\r\n    try (PoolCleaner cleaner = cleaner(e)) {\r\n        final int TASKS = 100;\r\n        final CountDownLatch done = new CountDownLatch(TASKS);\r\n        for (int k = 0; k < TASKS; ++k) e.execute(new CheckedRunnable() {\r\n            public void realRun() {\r\n                done.countDown();\r\n            }\r\n        });\r\n        assertTrue(done.await(LONG_DELAY_MS, MILLISECONDS));\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testFailingThreadFactory",
	"Comment": "execution continues if there is at least one thread even ifthread factory fails to create more",
	"Method": "void testFailingThreadFactory(){\r\n    done.countDown();\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinPool.getActiveThreadCount",
	"Comment": "returns an estimate of the number of threads that are currentlystealing or executing tasks. this method may overestimate thenumber of active threads.",
	"Method": "int getActiveThreadCount(){\r\n    int r = (config & SMASK) + (int) (ctl >> AC_SHIFT);\r\n    return (r <= 0) ? 0 : r;\r\n}"
}, {
	"Path": "jsr166.ThreadLocalRandomTest.testNextInt",
	"Comment": "repeated calls to nextint produce at least two distinct results",
	"Method": "void testNextInt(){\r\n    int f = ThreadLocalRandom.current().nextInt();\r\n    int i = 0;\r\n    while (i < NCALLS && ThreadLocalRandom.current().nextInt() == f) ++i;\r\n    assertTrue(i < NCALLS);\r\n}"
}, {
	"Path": "org.apache.harmony.security.tests.java.security.DigestInputStream2Test.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    inStream = new ByteArrayInputStream(\"This is a test string for digesting\".getBytes());\r\n    inStream1 = new ByteArrayInputStream(\"This is a test string for digesting\".getBytes());\r\n    try {\r\n        digest = MessageDigest.getInstance(\"SHA-1\");\r\n    } catch (NoSuchAlgorithmException e) {\r\n        fail(\"Unable to find SHA-1 algorithm\");\r\n    }\r\n}"
}, {
	"Path": "java.util.Vector.toArray",
	"Comment": "returns an array containing all of the elements in this vectorin the correct order.",
	"Method": "Object[] toArray(T[] toArray,T[] a){\r\n    if (a.length < elementCount)\r\n        return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass());\r\n    System.arraycopy(elementData, 0, a, 0, elementCount);\r\n    if (a.length > elementCount)\r\n        a[elementCount] = null;\r\n    return a;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.StatementGeneratorTest.testConcatDoubleQuoteChar",
	"Comment": "verify that double quote character constants are concatenated correctly.",
	"Method": "void testConcatDoubleQuoteChar(){\r\n    String translation = translateSourceFile(\"public class Test { \" + \"static final char QUOTE = '\\\"'; static final String TEST = QUOTE + \\\"\\\"; }\", \"Test\", \"Test.m\");\r\n    assertTranslation(translation, \"Test_TEST = @\\\"\\\\\\\"\\\";\");\r\n}"
}, {
	"Path": "jsr166.ConcurrentLinkedQueueTest.testSerialization",
	"Comment": "a deserialized serialized queue has same elements in same order",
	"Method": "void testSerialization(){\r\n    if (ReflectionUtil.isJreReflectionStripped()) {\r\n        return;\r\n    }\r\n    Queue x = populatedQueue(SIZE);\r\n    Queue y = serialClone(x);\r\n    assertNotSame(x, y);\r\n    assertEquals(x.size(), y.size());\r\n    assertEquals(x.toString(), y.toString());\r\n    assertTrue(Arrays.equals(x.toArray(), y.toArray()));\r\n    while (!x.isEmpty()) {\r\n        assertFalse(y.isEmpty());\r\n        assertEquals(x.remove(), y.remove());\r\n    }\r\n    assertTrue(y.isEmpty());\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkJoinSingleton",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoinSingleton(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingCCF f = new LFCCF(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.join();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkJoinSingleton",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoinSingleton(){\r\n    FailingCCF f = new LFCCF(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.join();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testDefaultThreadFactory",
	"Comment": "threadpoolexecutor using defaultthreadfactory hasspecified group, priority, daemon status, and name",
	"Method": "void testDefaultThreadFactory(){\r\n    final ThreadGroup egroup = Thread.currentThread().getThreadGroup();\r\n    final CountDownLatch done = new CountDownLatch(1);\r\n    Runnable r = new CheckedRunnable() {\r\n        public void realRun() {\r\n            try {\r\n                Thread current = Thread.currentThread();\r\n                assertTrue(!current.isDaemon());\r\n                assertTrue(current.getPriority() <= Thread.NORM_PRIORITY);\r\n                ThreadGroup g = current.getThreadGroup();\r\n                SecurityManager s = System.getSecurityManager();\r\n                if (s != null)\r\n                    assertTrue(g == s.getThreadGroup());\r\n                else\r\n                    assertTrue(g == egroup);\r\n                String name = current.getName();\r\n                assertTrue(name.endsWith(\"thread-1\"));\r\n            } catch (SecurityException ok) {\r\n            }\r\n            done.countDown();\r\n        }\r\n    };\r\n    ExecutorService e = Executors.newSingleThreadExecutor(Executors.defaultThreadFactory());\r\n    try (PoolCleaner cleaner = cleaner(e)) {\r\n        e.execute(r);\r\n        await(done);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testDefaultThreadFactory",
	"Comment": "threadpoolexecutor using defaultthreadfactory hasspecified group, priority, daemon status, and name",
	"Method": "void testDefaultThreadFactory(){\r\n    try {\r\n        Thread current = Thread.currentThread();\r\n        assertTrue(!current.isDaemon());\r\n        assertTrue(current.getPriority() <= Thread.NORM_PRIORITY);\r\n        ThreadGroup g = current.getThreadGroup();\r\n        SecurityManager s = System.getSecurityManager();\r\n        if (s != null)\r\n            assertTrue(g == s.getThreadGroup());\r\n        else\r\n            assertTrue(g == egroup);\r\n        String name = current.getName();\r\n        assertTrue(name.endsWith(\"thread-1\"));\r\n    } catch (SecurityException ok) {\r\n    }\r\n    done.countDown();\r\n}"
}, {
	"Path": "java.util.jar.Attributes.equals",
	"Comment": "compares the specified attributes object with this map for equality.returns true if the given object is also an instance of attributesand the two attributes objects represent the same mappings.",
	"Method": "boolean equals(Object o,boolean equals,Object o){\r\n    return map.equals(o);\r\n}"
}, {
	"Path": "java.util.TreeSet.clear",
	"Comment": "removes all of the elements from this set.the set will be empty after this call returns.",
	"Method": "void clear(){\r\n    m.clear();\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testConstructor1",
	"Comment": "constructor throws if corepoolsize argument is less than zero",
	"Method": "void testConstructor1(){\r\n    try {\r\n        new ThreadPoolExecutor(-1, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "java.util.HashSet.clear",
	"Comment": "removes all of the elements from this set.the set will be empty after this call returns.",
	"Method": "void clear(){\r\n    map.clear();\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testConstructor5",
	"Comment": "constructor throws if corepoolsize is greater than the maximumpoolsize",
	"Method": "void testConstructor5(){\r\n    try {\r\n        new ThreadPoolExecutor(2, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testConstructor6",
	"Comment": "constructor throws if corepoolsize argument is less than zero",
	"Method": "void testConstructor6(){\r\n    try {\r\n        new ThreadPoolExecutor(-1, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10), new SimpleThreadFactory());\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "java.util.Date.getSeconds",
	"Comment": "returns the number of seconds past the minute represented by this date.the value returned is between 0 and 61. thevalues 60 and 61 can only occur on thosejava virtual machines that take leap seconds into account.",
	"Method": "int getSeconds(){\r\n    return normalize().getSeconds();\r\n}"
}, {
	"Path": "org.xml.sax.InputSource.setByteStream",
	"Comment": "set the byte stream for this input source.the sax parser will ignore this if there is also a characterstream specified, but it will use a byte stream in preferenceto opening a uri connection itself.if the application knows the character encoding of thebyte stream, it should set it with the setencoding method.",
	"Method": "void setByteStream(InputStream byteStream){\r\n    this.byteStream = byteStream;\r\n}"
}, {
	"Path": "java.security.Provider.entrySet",
	"Comment": "returns an unmodifiable set view of the property entries containedin this provider.",
	"Method": "Set<Map.Entry<Object, Object>> entrySet(){\r\n    checkInitialized();\r\n    if (entrySet == null) {\r\n        if (entrySetCallCount++ == 0)\r\n            entrySet = Collections.unmodifiableMap(this).entrySet();\r\n        else\r\n            return super.entrySet();\r\n    }\r\n    if (entrySetCallCount != 2)\r\n        throw new RuntimeException(\"Internal error.\");\r\n    return entrySet;\r\n}"
}, {
	"Path": "com.google.j2objc.ClassTest.testCertainSuperclasses",
	"Comment": "verify that mapped classes return the correct superclass from a java view.",
	"Method": "void testCertainSuperclasses(){\r\n    assertNull(\"Non-null Object superclass\", Object.class.getSuperclass());\r\n    assertNull(\"Non-null Cloneable superclass\", Cloneable.class.getSuperclass());\r\n    assertNull(\"Non-null Iterable superclass\", Iterable.class.getSuperclass());\r\n    assertNull(\"Non-null Resource superclass\", Resource.class.getSuperclass());\r\n    assertEquals(\"Bad String superclass\", Object.class, String.class.getSuperclass());\r\n    assertEquals(\"Bad Number superclass\", Object.class, Number.class.getSuperclass());\r\n    assertEquals(\"Bad Throwable superclass\", Object.class, Throwable.class.getSuperclass());\r\n    assertEquals(\"Bad AccessibleObject superclass\", Object.class, AccessibleObject.class.getSuperclass());\r\n    assertEquals(\"Bad String superclass\", Object.class, \"foo\".getClass().getSuperclass());\r\n}"
}, {
	"Path": "javax.net.ssl.SSLParameters.getCipherSuites",
	"Comment": "returns a copy of the array of ciphersuites or null if nonehave been set.",
	"Method": "String[] getCipherSuites(){\r\n    return clone(cipherSuites);\r\n}"
}, {
	"Path": "java.util.LongSummaryStatistics.getSum",
	"Comment": "returns the sum of values recorded, or zero if no values have beenrecorded.",
	"Method": "long getSum(){\r\n    return sum;\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicIntegerFieldUpdater.incrementAndGet",
	"Comment": "atomically increments by one the current value of the field of thegiven object managed by this updater.",
	"Method": "int incrementAndGet(T obj,int incrementAndGet,T obj){\r\n    int prev, next;\r\n    do {\r\n        prev = get(obj);\r\n        next = prev + 1;\r\n    } while (!compareAndSet(obj, prev, next));\r\n    return next;\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testHasQueuedThreads",
	"Comment": "hasqueuedthreads reports whether there are waiting threads",
	"Method": "void testHasQueuedThreads(){\r\n    final Mutex sync = new Mutex();\r\n    assertFalse(sync.hasQueuedThreads());\r\n    sync.acquire();\r\n    Thread t1 = newStartedThread(new InterruptedSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t1);\r\n    assertTrue(sync.hasQueuedThreads());\r\n    Thread t2 = newStartedThread(new InterruptibleSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t2);\r\n    assertTrue(sync.hasQueuedThreads());\r\n    t1.interrupt();\r\n    awaitTermination(t1);\r\n    assertTrue(sync.hasQueuedThreads());\r\n    sync.release();\r\n    awaitTermination(t2);\r\n    assertFalse(sync.hasQueuedThreads());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.InnerClassExtractorTest.testInnerSubClassOfOtherInnerWithOuterRefsExtraction2",
	"Comment": "identical sample code to above test, except the order of b and a is switched.",
	"Method": "void testInnerSubClassOfOtherInnerWithOuterRefsExtraction2(){\r\n    String source = \"public class Test { \" + \"int i; \" + \"class B extends A { \" + \"  public class BInner extends A.Inner { } } \" + \"class A { \" + \"  private void foo() { i++; } \" + \"  public class Inner { Inner() { foo(); } } } \" + \"public static void main(String[] args) { B b = new Test().new B(); }}\";\r\n    String translation = translateSourceFile(source, \"Test\", \"Test.m\");\r\n    assertTranslation(translation, \"Test *this$0_;\");\r\n    assertTranslatedLines(translation, \"@interface Test_A () {\", \"@public\", \"Test *this$0_;\", \"}\");\r\n    assertNotInTranslation(translation, \"@interface Test_B () {\");\r\n    assertTranslatedLines(translation, \"void Test_mainWithNSStringArray_(IOSObjectArray *args) {\", \"Test_initialize();\", \"Test_B *b = create_Test_B_initWithTest_(create_Test_init());\");\r\n    assertTranslatedLines(translation, \"void Test_B_BInner_initWithTest_B_(Test_B_BInner *self, Test_B *outer$) {\", \"  Test_A_Inner_initWithTest_A_(self, outer$);\", \"}\");\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.DefaultMethodShimGenerator.getOverrideSignature",
	"Comment": "otherwise. used as a key to group inherited methods together.",
	"Method": "String getOverrideSignature(ExecutablePair method){\r\n    StringBuilder sb = new StringBuilder(ElementUtil.getName(method.element()));\r\n    sb.append('(');\r\n    for (TypeMirror pType : method.type().getParameterTypes()) {\r\n        sb.append(typeUtil.getSignatureName(pType));\r\n    }\r\n    sb.append(')');\r\n    return sb.toString();\r\n}"
}, {
	"Path": "jsr166.DelayQueueTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    DelayQueue q = new DelayQueue();\r\n    PDelay[] a = new PDelay[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) a[i] = new PDelay(i);\r\n    try {\r\n        q.addAll(Arrays.asList(a));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.ZipInputStream.readEnd",
	"Comment": "reads end of deflated entry as well as ext descriptor if present.",
	"Method": "void readEnd(ZipEntry e){\r\n    int n = inf.getRemaining();\r\n    if (n > 0) {\r\n        ((PushbackInputStream) in).unread(buf, len - n, n);\r\n    }\r\n    if ((flag & 8) == 8) {\r\n        if (inf.getBytesWritten() > ZIP64_MAGICVAL || inf.getBytesRead() > ZIP64_MAGICVAL) {\r\n            readFully(tmpbuf, 0, ZIP64_EXTHDR);\r\n            long sig = get32(tmpbuf, 0);\r\n            if (sig != EXTSIG) {\r\n                e.crc = sig;\r\n                e.csize = get64(tmpbuf, ZIP64_EXTSIZ - ZIP64_EXTCRC);\r\n                e.size = get64(tmpbuf, ZIP64_EXTLEN - ZIP64_EXTCRC);\r\n                ((PushbackInputStream) in).unread(tmpbuf, ZIP64_EXTHDR - ZIP64_EXTCRC - 1, ZIP64_EXTCRC);\r\n            } else {\r\n                e.crc = get32(tmpbuf, ZIP64_EXTCRC);\r\n                e.csize = get64(tmpbuf, ZIP64_EXTSIZ);\r\n                e.size = get64(tmpbuf, ZIP64_EXTLEN);\r\n            }\r\n        } else {\r\n            readFully(tmpbuf, 0, EXTHDR);\r\n            long sig = get32(tmpbuf, 0);\r\n            if (sig != EXTSIG) {\r\n                e.crc = sig;\r\n                e.csize = get32(tmpbuf, EXTSIZ - EXTCRC);\r\n                e.size = get32(tmpbuf, EXTLEN - EXTCRC);\r\n                ((PushbackInputStream) in).unread(tmpbuf, EXTHDR - EXTCRC - 1, EXTCRC);\r\n            } else {\r\n                e.crc = get32(tmpbuf, EXTCRC);\r\n                e.csize = get32(tmpbuf, EXTSIZ);\r\n                e.size = get32(tmpbuf, EXTLEN);\r\n            }\r\n        }\r\n    }\r\n    if (e.size != inf.getBytesWritten()) {\r\n        throw new ZipException(\"invalid entry size (expected \" + e.size + \" but got \" + inf.getBytesWritten() + \" bytes)\");\r\n    }\r\n    if (e.csize != inf.getBytesRead()) {\r\n        throw new ZipException(\"invalid entry compressed size (expected \" + e.csize + \" but got \" + inf.getBytesRead() + \" bytes)\");\r\n    }\r\n    if (e.crc != crc.getValue()) {\r\n        throw new ZipException(\"invalid entry CRC (expected 0x\" + Long.toHexString(e.crc) + \" but got 0x\" + Long.toHexString(crc.getValue()) + \")\");\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.LogRecord.setThreadID",
	"Comment": "set an identifier for the thread where the message originated.",
	"Method": "void setThreadID(int threadID){\r\n    this.threadID = threadID;\r\n}"
}, {
	"Path": "java.util.logging.Logger.getUseParentHandlers",
	"Comment": "discover whether or not this logger is sending its outputto its parent logger.",
	"Method": "boolean getUseParentHandlers(){\r\n    return useParentHandlers;\r\n}"
}, {
	"Path": "android.icu.dev.util.UnicodeMap._put",
	"Comment": "associates code point with value. removes any previous association.all code that calls this must check for frozen first!",
	"Method": "UnicodeMap _put(int codepoint,T value){\r\n    int baseIndex;\r\n    if (transitions[lastIndex] <= codepoint && codepoint < transitions[lastIndex + 1]) {\r\n        baseIndex = lastIndex;\r\n    } else {\r\n        baseIndex = _findIndex(codepoint);\r\n    }\r\n    int limitIndex = baseIndex + 1;\r\n    if (areEqual(values[baseIndex], value))\r\n        return this;\r\n    if (locked) {\r\n        throw new UnsupportedOperationException(\"Attempt to modify locked object\");\r\n    }\r\n    if (errorOnReset && values[baseIndex] != null) {\r\n        throw new UnsupportedOperationException(\"Attempt to reset value for \" + Utility.hex(codepoint) + \" when that is disallowed. Old: \" + values[baseIndex] + \"; New: \" + value);\r\n    }\r\n    staleAvailableValues = true;\r\n    availableValues.add(value);\r\n    int baseCP = transitions[baseIndex];\r\n    int limitCP = transitions[limitIndex];\r\n    if (baseCP == codepoint) {\r\n        boolean connectsWithPrevious = baseIndex != 0 && areEqual(value, values[baseIndex - 1]);\r\n        if (limitCP == codepoint + 1) {\r\n            // was -1\r\n            boolean connectsWithFollowing = baseIndex < length - 2 && areEqual(value, values[limitIndex]);\r\n            if (connectsWithPrevious) {\r\n                if (connectsWithFollowing) {\r\n                    _removeAt(baseIndex, 2);\r\n                } else {\r\n                    _removeAt(baseIndex, 1);\r\n                }\r\n                --baseIndex;\r\n            } else if (connectsWithFollowing) {\r\n                _removeAt(baseIndex, 1);\r\n                transitions[baseIndex] = codepoint;\r\n            } else {\r\n                values[baseIndex] = value;\r\n            }\r\n        } else if (connectsWithPrevious) {\r\n            ++transitions[baseIndex];\r\n        } else {\r\n            transitions[baseIndex] = codepoint + 1;\r\n            _insertGapAt(baseIndex, 1);\r\n            values[baseIndex] = value;\r\n            transitions[baseIndex] = codepoint;\r\n        }\r\n    } else if (limitCP == codepoint + 1) {\r\n        // was -1\r\n        boolean connectsWithFollowing = baseIndex < length - 2 && areEqual(value, values[limitIndex]);\r\n        if (connectsWithFollowing) {\r\n            --transitions[limitIndex];\r\n            return this;\r\n        } else {\r\n            _insertGapAt(limitIndex, 1);\r\n            transitions[limitIndex] = codepoint;\r\n            values[limitIndex] = value;\r\n        }\r\n    } else {\r\n        _insertGapAt(++baseIndex, 2);\r\n        transitions[baseIndex] = codepoint;\r\n        values[baseIndex] = value;\r\n        transitions[baseIndex + 1] = codepoint + 1;\r\n        values[baseIndex + 1] = values[baseIndex - 1];\r\n    }\r\n    lastIndex = baseIndex;\r\n    return this;\r\n}"
}, {
	"Path": "java.time.temporal.WeekFields.readObject",
	"Comment": "restore the state of a weekfields from the stream.check that the values are valid.",
	"Method": "void readObject(ObjectInputStream s){\r\n    s.defaultReadObject();\r\n    if (firstDayOfWeek == null) {\r\n        throw new InvalidObjectException(\"firstDayOfWeek is null\");\r\n    }\r\n    if (minimalDays < 1 || minimalDays > 7) {\r\n        throw new InvalidObjectException(\"Minimal number of days is invalid\");\r\n    }\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.setInfinity",
	"Comment": "sets the string used to represent infinity. almost always leftunchanged.",
	"Method": "void setInfinity(String infinity){\r\n    this.infinity = infinity;\r\n}"
}, {
	"Path": "jsr166.AtomicLongFieldUpdaterTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    x = 1;\r\n    final AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;\r\n    a = updaterFor(\"x\");\r\n    Thread t = new Thread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!a.compareAndSet(AtomicLongFieldUpdaterTest.this, 2, 3)) Thread.yield();\r\n        }\r\n    });\r\n    t.start();\r\n    assertTrue(a.compareAndSet(this, 1, 2));\r\n    t.join(LONG_DELAY_MS);\r\n    assertFalse(t.isAlive());\r\n    assertEquals(3, a.get(this));\r\n}"
}, {
	"Path": "jsr166.AtomicLongFieldUpdaterTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    while (!a.compareAndSet(AtomicLongFieldUpdaterTest.this, 2, 3)) Thread.yield();\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorStringException1",
	"Comment": "create a number from a string value and radix.verify an exception thrown if a radix is out of range",
	"Method": "void testConstructorStringException1(){\r\n    String value = \"9234853876401\";\r\n    int radix = 45;\r\n    try {\r\n        new BigInteger(value, radix);\r\n        fail(\"NumberFormatException has not been caught\");\r\n    } catch (NumberFormatException e) {\r\n        assertEquals(\"Improper exception message\", \"Radix out of range\", e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorStringException3",
	"Comment": "create a number from a string value and radix.verify an exception thrown if the string contains improper characters.",
	"Method": "void testConstructorStringException3(){\r\n    String value = \"92348$*#78987\";\r\n    int radix = 34;\r\n    try {\r\n        new BigInteger(value, radix);\r\n        fail(\"NumberFormatException has not been caught\");\r\n    } catch (NumberFormatException e) {\r\n    }\r\n}"
}, {
	"Path": "java.time.zone.ZoneOffsetTransition.getValidOffsets",
	"Comment": "gets the valid offsets during this transition.a gap will return an empty list, while an overlap will return both offsets.",
	"Method": "List<ZoneOffset> getValidOffsets(){\r\n    if (isGap()) {\r\n        return Collections.emptyList();\r\n    }\r\n    return Arrays.asList(getOffsetBefore(), getOffsetAfter());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorStringException2",
	"Comment": "create a number from a string value and radix.verify an exception thrown if the string starts with a space.",
	"Method": "void testConstructorStringException2(){\r\n    String value = \"   9234853876401\";\r\n    int radix = 10;\r\n    try {\r\n        new BigInteger(value, radix);\r\n        fail(\"NumberFormatException has not been caught\");\r\n    } catch (NumberFormatException e) {\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.CertificateFactory.getType",
	"Comment": "returns the name of the certificate type associated with thiscertificate factory.",
	"Method": "String getType(){\r\n    return this.type;\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testSet1_IndexOutOfBoundsException",
	"Comment": "set throws an indexoutofboundsexception on a negative index",
	"Method": "void testSet1_IndexOutOfBoundsException(){\r\n    CopyOnWriteArrayList c = populatedArray(5);\r\n    List[] lists = { c, c.subList(1, c.size() - 1) };\r\n    for (List list : lists) {\r\n        try {\r\n            list.set(-1, \"qwerty\");\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorStringException4",
	"Comment": "create a number from a string value and radix.verify an exception thrown if some digits are greater than radix.",
	"Method": "void testConstructorStringException4(){\r\n    String value = \"98zv765hdsaiy\";\r\n    int radix = 20;\r\n    try {\r\n        new BigInteger(value, radix);\r\n        fail(\"NumberFormatException has not been caught\");\r\n    } catch (NumberFormatException e) {\r\n    }\r\n}"
}, {
	"Path": "javax.xml.datatype.Duration.isShorterThan",
	"Comment": "checks if this duration object is strictly shorter thananother duration object.",
	"Method": "boolean isShorterThan(Duration duration){\r\n    return compare(duration) == DatatypeConstants.LESSER;\r\n}"
}, {
	"Path": "android.icu.dev.util.UnicodeMap.setErrorOnReset",
	"Comment": "puts the unicodemap into a state whereby new mappings are accepted, but changes to old mappings cause an exception.",
	"Method": "UnicodeMap<T> setErrorOnReset(boolean errorOnReset){\r\n    this.errorOnReset = errorOnReset;\r\n    return this;\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testPrivilegedThreadFactory",
	"Comment": "threadpoolexecutor using privilegedthreadfactory hasspecified group, priority, daemon status, name,access control context and context class loader",
	"Method": "void testPrivilegedThreadFactory(){\r\n    final CountDownLatch done = new CountDownLatch(1);\r\n    Runnable r = new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            final ThreadGroup egroup = Thread.currentThread().getThreadGroup();\r\n            final ClassLoader thisccl = Thread.currentThread().getContextClassLoader();\r\n            Runnable r = new CheckedRunnable() {\r\n                public void realRun() {\r\n                    Thread current = Thread.currentThread();\r\n                    assertTrue(!current.isDaemon());\r\n                    assertTrue(current.getPriority() <= Thread.NORM_PRIORITY);\r\n                    ThreadGroup g = current.getThreadGroup();\r\n                    SecurityManager s = System.getSecurityManager();\r\n                    if (s != null)\r\n                        assertTrue(g == s.getThreadGroup());\r\n                    else\r\n                        assertTrue(g == egroup);\r\n                    String name = current.getName();\r\n                    assertTrue(name.endsWith(\"thread-1\"));\r\n                    assertSame(thisccl, current.getContextClassLoader());\r\n                    done.countDown();\r\n                }\r\n            };\r\n            ExecutorService e = Executors.newSingleThreadExecutor(Executors.privilegedThreadFactory());\r\n            try (PoolCleaner cleaner = cleaner(e)) {\r\n                e.execute(r);\r\n                await(done);\r\n            }\r\n        }\r\n    };\r\n    runWithPermissions(r, new RuntimePermission(\"getClassLoader\"), new RuntimePermission(\"setContextClassLoader\"), new RuntimePermission(\"modifyThread\"));\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testPrivilegedThreadFactory",
	"Comment": "threadpoolexecutor using privilegedthreadfactory hasspecified group, priority, daemon status, name,access control context and context class loader",
	"Method": "void testPrivilegedThreadFactory(){\r\n    final ThreadGroup egroup = Thread.currentThread().getThreadGroup();\r\n    final ClassLoader thisccl = Thread.currentThread().getContextClassLoader();\r\n    Runnable r = new CheckedRunnable() {\r\n        public void realRun() {\r\n            Thread current = Thread.currentThread();\r\n            assertTrue(!current.isDaemon());\r\n            assertTrue(current.getPriority() <= Thread.NORM_PRIORITY);\r\n            ThreadGroup g = current.getThreadGroup();\r\n            SecurityManager s = System.getSecurityManager();\r\n            if (s != null)\r\n                assertTrue(g == s.getThreadGroup());\r\n            else\r\n                assertTrue(g == egroup);\r\n            String name = current.getName();\r\n            assertTrue(name.endsWith(\"thread-1\"));\r\n            assertSame(thisccl, current.getContextClassLoader());\r\n            done.countDown();\r\n        }\r\n    };\r\n    ExecutorService e = Executors.newSingleThreadExecutor(Executors.privilegedThreadFactory());\r\n    try (PoolCleaner cleaner = cleaner(e)) {\r\n        e.execute(r);\r\n        await(done);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testPrivilegedThreadFactory",
	"Comment": "threadpoolexecutor using privilegedthreadfactory hasspecified group, priority, daemon status, name,access control context and context class loader",
	"Method": "void testPrivilegedThreadFactory(){\r\n    Thread current = Thread.currentThread();\r\n    assertTrue(!current.isDaemon());\r\n    assertTrue(current.getPriority() <= Thread.NORM_PRIORITY);\r\n    ThreadGroup g = current.getThreadGroup();\r\n    SecurityManager s = System.getSecurityManager();\r\n    if (s != null)\r\n        assertTrue(g == s.getThreadGroup());\r\n    else\r\n        assertTrue(g == egroup);\r\n    String name = current.getName();\r\n    assertTrue(name.endsWith(\"thread-1\"));\r\n    assertSame(thisccl, current.getContextClassLoader());\r\n    done.countDown();\r\n}"
}, {
	"Path": "java.net.InterfaceAddress.getBroadcast",
	"Comment": "returns an inetaddress for the brodcast addressfor this interfaceaddress.only ipv4 networks have broadcast address therefore, in the caseof an ipv6 network, null will be returned.",
	"Method": "InetAddress getBroadcast(){\r\n    return broadcast;\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.getYearOffsetInMillis",
	"Comment": "returns the millisecond offset from the beginning of thisyear. this calendar object must have been normalized.",
	"Method": "long getYearOffsetInMillis(){\r\n    long t = (internalGet(DAY_OF_YEAR) - 1) * 24;\r\n    t += internalGet(HOUR_OF_DAY);\r\n    t *= 60;\r\n    t += internalGet(MINUTE);\r\n    t *= 60;\r\n    t += internalGet(SECOND);\r\n    t *= 1000;\r\n    return t + internalGet(MILLISECOND) - (internalGet(ZONE_OFFSET) + internalGet(DST_OFFSET));\r\n}"
}, {
	"Path": "sun.security.x509.CertificateIssuerExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(ISSUER);\r\n    return elements.elements();\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_dayOfWeekEqualIsoDayOfWeek",
	"Comment": "test to verify the day of week of a given hijrahdate and localdate",
	"Method": "void test_dayOfWeekEqualIsoDayOfWeek(ChronoLocalDate hijrahDate,LocalDate iso){\r\n    assertEquals(hijrahDate.get(ChronoField.DAY_OF_WEEK), iso.get(ChronoField.DAY_OF_WEEK), \"Hijrah day of week should be same as ISO day of week\");\r\n}"
}, {
	"Path": "jsr166.AtomicLongFieldUpdaterTest.testAddAndGet",
	"Comment": "addandget adds given value to current, and returns current value",
	"Method": "void testAddAndGet(){\r\n    AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;\r\n    a = updaterFor(\"x\");\r\n    x = 1;\r\n    assertEquals(3, a.addAndGet(this, 2));\r\n    assertEquals(3, a.get(this));\r\n    assertEquals(-1, a.addAndGet(this, -4));\r\n    assertEquals(-1, a.get(this));\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkJoin",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoin(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingAsyncFib f = new FailingAsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.join();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkJoin",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoin(){\r\n    FailingAsyncFib f = new FailingAsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.join();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "java.nio.ByteBuffer.equals",
	"Comment": "tells whether or not this buffer is equal to another object. two byte buffers are equal if, and only if, they have the same element type, they have the same number of remaining elements, and the two sequences of remaining elements, consideredindependently of their starting positions, are pointwise equal. a byte buffer is not equal to any other type of object.",
	"Method": "boolean equals(Object ob,boolean equals,byte x,byte y){\r\n    return x == y;\r\n}"
}, {
	"Path": "java.text.DateFormat.getDateInstance",
	"Comment": "gets the date formatter with the given formatting stylefor the given locale.",
	"Method": "DateFormat getDateInstance(DateFormat getDateInstance,int style,DateFormat getDateInstance,int style,Locale aLocale){\r\n    return get(0, style, 2, aLocale);\r\n}"
}, {
	"Path": "sun.security.x509.InhibitAnyPolicyExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(SKIP_CERTS);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "sun.security.provider.certpath.X509CertPath.getEncodings",
	"Comment": "returns an iteration of the encodings supported by this certificationpath, with the default encoding first.attempts to modify the returned iterator via itsremove method result in anunsupportedoperationexception.",
	"Method": "Iterator<String> getEncodings(){\r\n    return getEncodingsStatic();\r\n}"
}, {
	"Path": "java.io.PrintWriter.close",
	"Comment": "closes the stream and releases any system resources associatedwith it. closing a previously closed stream has no effect.",
	"Method": "void close(){\r\n    try {\r\n        synchronized (lock) {\r\n            if (out == null)\r\n                return;\r\n            out.close();\r\n            out = null;\r\n        }\r\n    } catch (IOException x) {\r\n        trouble = true;\r\n    }\r\n}"
}, {
	"Path": "java.time.Instant.minusMillis",
	"Comment": "returns a copy of this instant with the specified duration in milliseconds subtracted.this instance is immutable and unaffected by this method call.",
	"Method": "Instant minusMillis(long millisToSubtract){\r\n    if (millisToSubtract == Long.MIN_VALUE) {\r\n        return plusMillis(Long.MAX_VALUE).plusMillis(1);\r\n    }\r\n    return plusMillis(-millisToSubtract);\r\n}"
}, {
	"Path": "android.icu.dev.test.compression.DecompressionTest.logln",
	"Comment": "print out a segment of a character array, followed by a newline",
	"Method": "void logln(char[] chars,int start,int count){\r\n    log(chars, start, count);\r\n    logln(\"\");\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testSchedule5",
	"Comment": "schedulewithfixeddelay executes runnable after given initial delay",
	"Method": "void testSchedule5(){\r\n    final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        final long startTime = System.nanoTime();\r\n        final CountDownLatch done = new CountDownLatch(1);\r\n        Runnable task = new CheckedRunnable() {\r\n            public void realRun() {\r\n                done.countDown();\r\n                assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n            }\r\n        };\r\n        ScheduledFuture f = p.scheduleWithFixedDelay(task, timeoutMillis(), LONG_DELAY_MS, MILLISECONDS);\r\n        await(done);\r\n        assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n        f.cancel(true);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testSchedule5",
	"Comment": "schedulewithfixeddelay executes runnable after given initial delay",
	"Method": "void testSchedule5(){\r\n    done.countDown();\r\n    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n}"
}, {
	"Path": "org.xml.sax.helpers.NewInstance.newInstance",
	"Comment": "creates a new instance of the specified class namepackage private so this code is not exposed at the api level.",
	"Method": "Object newInstance(ClassLoader classLoader,String className){\r\n    Class driverClass;\r\n    if (classLoader == null) {\r\n        driverClass = Class.forName(className);\r\n    } else {\r\n        driverClass = classLoader.loadClass(className);\r\n    }\r\n    return driverClass.newInstance();\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testSchedule3",
	"Comment": "delayed schedule of runnable successfully executes after delay",
	"Method": "void testSchedule3(){\r\n    final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        final long startTime = System.nanoTime();\r\n        final CountDownLatch done = new CountDownLatch(1);\r\n        Runnable task = new CheckedRunnable() {\r\n            public void realRun() {\r\n                done.countDown();\r\n                assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n            }\r\n        };\r\n        Future f = p.schedule(task, timeoutMillis(), MILLISECONDS);\r\n        await(done);\r\n        assertNull(f.get(LONG_DELAY_MS, MILLISECONDS));\r\n        assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testSchedule3",
	"Comment": "delayed schedule of runnable successfully executes after delay",
	"Method": "void testSchedule3(){\r\n    done.countDown();\r\n    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testSchedule4",
	"Comment": "scheduleatfixedrate executes runnable after given initial delay",
	"Method": "void testSchedule4(){\r\n    final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        final long startTime = System.nanoTime();\r\n        final CountDownLatch done = new CountDownLatch(1);\r\n        Runnable task = new CheckedRunnable() {\r\n            public void realRun() {\r\n                done.countDown();\r\n                assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n            }\r\n        };\r\n        ScheduledFuture f = p.scheduleAtFixedRate(task, timeoutMillis(), LONG_DELAY_MS, MILLISECONDS);\r\n        await(done);\r\n        assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n        f.cancel(true);\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testSchedule4",
	"Comment": "scheduleatfixedrate executes runnable after given initial delay",
	"Method": "void testSchedule4(){\r\n    done.countDown();\r\n    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testSchedule1",
	"Comment": "delayed schedule of callable successfully executes after delay",
	"Method": "void testSchedule1(){\r\n    final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        final long startTime = System.nanoTime();\r\n        final CountDownLatch done = new CountDownLatch(1);\r\n        Callable task = new CheckedCallable<Boolean>() {\r\n            public Boolean realCall() {\r\n                done.countDown();\r\n                assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n                return Boolean.TRUE;\r\n            }\r\n        };\r\n        Future f = p.schedule(task, timeoutMillis(), MILLISECONDS);\r\n        assertSame(Boolean.TRUE, f.get());\r\n        assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n        assertTrue(done.await(0L, MILLISECONDS));\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testSchedule1",
	"Comment": "delayed schedule of callable successfully executes after delay",
	"Method": "void testSchedule1(){\r\n    done.countDown();\r\n    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n    return Boolean.TRUE;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.GenerationTest.compileAndTranslateSourceFile",
	"Comment": "compile java source and translate the resulting class file, returning thecontents of either the generated header or implementation file.",
	"Method": "String compileAndTranslateSourceFile(String source,String typeName,String fileName){\r\n    CompilationUnit newUnit = compileAsClassFile(typeName, source);\r\n    TranslationProcessor.applyMutations(newUnit, deadCodeMap, options.externalAnnotations(), TimeTracker.noop());\r\n    return generateFromUnit(newUnit, fileName);\r\n}"
}, {
	"Path": "java.time.Instant.plusMillis",
	"Comment": "returns a copy of this instant with the specified duration in milliseconds added.this instance is immutable and unaffected by this method call.",
	"Method": "Instant plusMillis(long millisToAdd){\r\n    return plus(millisToAdd / 1000, (millisToAdd % 1000) * 1000_000);\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicIntegerArray.toString",
	"Comment": "returns the string representation of the current values of array.",
	"Method": "String toString(){\r\n    int iMax = array.length - 1;\r\n    if (iMax == -1)\r\n        return \"[]\";\r\n    StringBuilder b = new StringBuilder();\r\n    b.append('[');\r\n    for (int i = 0; ; i++) {\r\n        b.append(getUnchecked(i));\r\n        if (i == iMax)\r\n            return b.append(']').toString();\r\n        b.append(',').append(' ');\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinTask.setForkJoinTaskTag",
	"Comment": "atomically sets the tag value for this task and returns the old value.",
	"Method": "short setForkJoinTaskTag(short newValue){\r\n    for (int s; ; ) {\r\n        if (U.compareAndSwapInt(this, STATUS, s = status, (s & ~SMASK) | (newValue & SMASK)))\r\n            return (short) s;\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedLongSynchronizer.acquireQueued",
	"Comment": "acquires in exclusive uninterruptible mode for thread already inqueue. used by condition wait methods as well as acquire.",
	"Method": "boolean acquireQueued(Node node,long arg){\r\n    try {\r\n        boolean interrupted = false;\r\n        for (; ; ) {\r\n            final Node p = node.predecessor();\r\n            if (p == head && tryAcquire(arg)) {\r\n                setHead(node);\r\n                p.next = null;\r\n                return interrupted;\r\n            }\r\n            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\r\n                interrupted = true;\r\n        }\r\n    } catch (Throwable t) {\r\n        cancelAcquire(node);\r\n        throw t;\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalInvokeCC",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvokeCC(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingCCF f = new LFCCF(null, 8);\r\n            try {\r\n                f.invoke();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalInvokeCC",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvokeCC(){\r\n    FailingCCF f = new LFCCF(null, 8);\r\n    try {\r\n        f.invoke();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.Logger.fine",
	"Comment": "log a fine message.if the logger is currently enabled for the fine messagelevel then the given message is forwarded to all theregistered output handler objects.",
	"Method": "void fine(String msg){\r\n    if (Level.FINE.intValue() < levelValue) {\r\n        return;\r\n    }\r\n    log(Level.FINE, msg);\r\n}"
}, {
	"Path": "jsr166.PriorityQueueTest.testConstructor5",
	"Comment": "initializing from collection with some null elements throws npe",
	"Method": "void testConstructor5(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        new PriorityQueue(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.PriorityQueueTest.testConstructor6",
	"Comment": "queue contains all elements of collection used to initialize",
	"Method": "void testConstructor6(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = new Integer(i);\r\n    PriorityQueue q = new PriorityQueue(Arrays.asList(ints));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "android.icu.dev.test.timezone.TimeZoneRuleTest.TestSimpleTimeZoneCoverage",
	"Comment": "api coverage test for basictimezone apis in simpletimezone",
	"Method": "void TestSimpleTimeZoneCoverage(){\r\n    long time1 = getUTCMillis(1990, Calendar.JUNE, 1);\r\n    long time2 = getUTCMillis(2000, Calendar.JUNE, 1);\r\n    TimeZoneTransition tzt1, tzt2;\r\n    SimpleTimeZone stz1 = new SimpleTimeZone(-5 * HOUR, \"GMT-5\");\r\n    tzt1 = stz1.getNextTransition(time1, false);\r\n    if (tzt1 != null) {\r\n        errln(\"FAIL: No transition must be returned by getNextTranstion for SimpleTimeZone with no DST rule\");\r\n    }\r\n    tzt1 = stz1.getPreviousTransition(time1, false);\r\n    if (tzt1 != null) {\r\n        errln(\"FAIL: No transition must be returned by getPreviousTransition  for SimpleTimeZone with no DST rule\");\r\n    }\r\n    TimeZoneRule[] tzrules = stz1.getTimeZoneRules();\r\n    if (tzrules.length != 1 || !(tzrules[0] instanceof InitialTimeZoneRule)) {\r\n        errln(\"FAIL: Invalid results returned by SimpleTimeZone#getTimeZoneRules\");\r\n    }\r\n    stz1.setStartRule(Calendar.MARCH, 11, 2 * HOUR);\r\n    stz1.setEndRule(Calendar.NOVEMBER, 1, Calendar.SUNDAY, 2 * HOUR);\r\n    tzt1 = stz1.getNextTransition(time1, false);\r\n    if (tzt1 == null) {\r\n        errln(\"FAIL: Non-null transition must be returned by getNextTranstion for SimpleTimeZone with a DST rule\");\r\n    } else {\r\n        String str = tzt1.toString();\r\n        if (str == null || str.length() == 0) {\r\n            errln(\"FAIL: TimeZoneTransition#toString returns null or empty string\");\r\n        } else {\r\n            logln(str);\r\n        }\r\n    }\r\n    tzt1 = stz1.getPreviousTransition(time1, false);\r\n    if (tzt1 == null) {\r\n        errln(\"FAIL: Non-null transition must be returned by getPreviousTransition  for SimpleTimeZone with a DST rule\");\r\n    }\r\n    tzrules = stz1.getTimeZoneRules();\r\n    if (tzrules.length != 3 || !(tzrules[0] instanceof InitialTimeZoneRule) || !(tzrules[1] instanceof AnnualTimeZoneRule) || !(tzrules[2] instanceof AnnualTimeZoneRule)) {\r\n        errln(\"FAIL: Invalid results returned by SimpleTimeZone#getTimeZoneRules for a SimpleTimeZone with DST\");\r\n    }\r\n    stz1.setStartYear(2007);\r\n    tzt1 = stz1.getPreviousTransition(time1, false);\r\n    if (tzt1 != null) {\r\n        errln(\"FAIL: No transition must be returned before 1990\");\r\n    }\r\n    tzt1 = stz1.getNextTransition(time1, false);\r\n    tzt2 = stz1.getNextTransition(time2, false);\r\n    if (tzt1 == null || tzt2 == null || !tzt1.equals(tzt2)) {\r\n        errln(\"FAIL: Bad transition returned by SimpleTimeZone#getNextTransition\");\r\n    }\r\n}"
}, {
	"Path": "java.text.DateFormatSymbols.writeObject",
	"Comment": "write out the default serializable data, after ensuring thezonestrings field is initialized in order to makesure the backward compatibility.",
	"Method": "void writeObject(ObjectOutputStream stream){\r\n    internalZoneStrings();\r\n    stream.defaultWriteObject();\r\n}"
}, {
	"Path": "sun.security.provider.certpath.ForwardBuilder.getMatchingCACerts",
	"Comment": "retrieves all ca certificates which satisfy constraintsand requirements specified in the parameters and pkix state.",
	"Method": "void getMatchingCACerts(ForwardState currentState,List<CertStore> certStores,Collection<X509Certificate> caCerts){\r\n    if (debug != null) {\r\n        debug.println(\"ForwardBuilder.getMatchingCACerts()...\");\r\n    }\r\n    int initialSize = caCerts.size();\r\n    X509CertSelector sel = null;\r\n    if (currentState.isInitial()) {\r\n        if (targetCertConstraints.getBasicConstraints() == -2) {\r\n            return;\r\n        }\r\n        if (debug != null) {\r\n            debug.println(\"ForwardBuilder.getMatchingCACerts(): ca is target\");\r\n        }\r\n        if (caTargetSelector == null) {\r\n            caTargetSelector = (X509CertSelector) targetCertConstraints.clone();\r\n            if (buildParams.explicitPolicyRequired())\r\n                caTargetSelector.setPolicy(getMatchingPolicies());\r\n        }\r\n        sel = caTargetSelector;\r\n    } else {\r\n        if (caSelector == null) {\r\n            caSelector = new AdaptableX509CertSelector();\r\n            if (buildParams.explicitPolicyRequired())\r\n                caSelector.setPolicy(getMatchingPolicies());\r\n        }\r\n        caSelector.setSubject(currentState.issuerDN);\r\n        CertPathHelper.setPathToNames(caSelector, currentState.subjectNamesTraversed);\r\n        AuthorityKeyIdentifierExtension akidext = currentState.cert.getAuthorityKeyIdentifierExtension();\r\n        caSelector.parseAuthorityKeyIdentifierExtension(akidext);\r\n        caSelector.setValidityPeriod(currentState.cert.getNotBefore(), currentState.cert.getNotAfter());\r\n        sel = caSelector;\r\n    }\r\n    sel.setBasicConstraints(-1);\r\n    for (X509Certificate trustedCert : trustedCerts) {\r\n        if (sel.match(trustedCert)) {\r\n            if (debug != null) {\r\n                debug.println(\"ForwardBuilder.getMatchingCACerts: \" + \"found matching trust anchor\");\r\n            }\r\n            if (caCerts.add(trustedCert) && !searchAllCertStores) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    sel.setCertificateValid(buildParams.date());\r\n    sel.setBasicConstraints(currentState.traversedCACerts);\r\n    if (currentState.isInitial() || (buildParams.maxPathLength() == -1) || (buildParams.maxPathLength() > currentState.traversedCACerts)) {\r\n        if (addMatchingCerts(sel, certStores, caCerts, searchAllCertStores) && !searchAllCertStores) {\r\n            return;\r\n        }\r\n    }\r\n    if (!currentState.isInitial() && Builder.USE_AIA) {\r\n        AuthorityInfoAccessExtension aiaExt = currentState.cert.getAuthorityInfoAccessExtension();\r\n        if (aiaExt != null) {\r\n            getCerts(aiaExt, caCerts);\r\n        }\r\n    }\r\n    if (debug != null) {\r\n        int numCerts = caCerts.size() - initialSize;\r\n        debug.println(\"ForwardBuilder.getMatchingCACerts: found \" + numCerts + \" CA certs\");\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.derEncode",
	"Comment": "der encode this object onto an output stream.implements the derencoder interface.",
	"Method": "void derEncode(OutputStream out){\r\n    if (signedCert == null)\r\n        throw new IOException(\"Null certificate to encode\");\r\n    out.write(signedCert.clone());\r\n}"
}, {
	"Path": "java.beans.ChangeListenerMap.getListeners",
	"Comment": "returns listeners that have been associated with the named property.",
	"Method": "L[] getListeners(L[] getListeners,String name){\r\n    if (name != null) {\r\n        L[] listeners = get(name);\r\n        if (listeners != null) {\r\n            return listeners.clone();\r\n        }\r\n    }\r\n    return newArray(0);\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.data_datesForDiffs",
	"Comment": "data provider to get the difference between two dates in terms of days, months and years",
	"Method": "Object[][] data_datesForDiffs(){\r\n    return new Object[][] { { HijrahDate.of(1350, 5, 15), HijrahDate.of(1351, 12, 29), 574, 19, 1 }, { HijrahDate.of(1434, 5, 1), HijrahDate.of(1434, 6, 12), 40, 1, 0 }, { HijrahDate.of(1436, 1, 1), HijrahDate.of(1475, 12, 29), 14173, 479, 39 }, { HijrahDate.of(1500, 6, 12), HijrahDate.of(1551, 7, 12), 18102, 613, 51 }, { HijrahDate.of(1550, 3, 11), HijrahDate.of(1551, 4, 11), 384, 13, 1 } };\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testListIterator1_IndexOutOfBoundsException",
	"Comment": "listiterator throws an indexoutofboundsexception on a negative index",
	"Method": "void testListIterator1_IndexOutOfBoundsException(){\r\n    CopyOnWriteArrayList c = populatedArray(5);\r\n    List[] lists = { c, c.subList(1, c.size() - 1) };\r\n    for (List list : lists) {\r\n        try {\r\n            list.listIterator(-1);\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testAcquireSharedInterruptibly",
	"Comment": "acquiresharedinterruptibly returns after release, but not before",
	"Method": "void testAcquireSharedInterruptibly(){\r\n    final BooleanLatch l = new BooleanLatch();\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            assertFalse(l.isSignalled());\r\n            l.acquireSharedInterruptibly(0);\r\n            assertTrue(l.isSignalled());\r\n            l.acquireSharedInterruptibly(0);\r\n            assertTrue(l.isSignalled());\r\n        }\r\n    });\r\n    waitForQueuedThread(l, t);\r\n    assertFalse(l.isSignalled());\r\n    assertThreadStaysAlive(t);\r\n    assertHasSharedQueuedThreads(l, t);\r\n    assertTrue(l.releaseShared(0));\r\n    assertTrue(l.isSignalled());\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testAcquireSharedInterruptibly",
	"Comment": "acquiresharedinterruptibly returns after release, but not before",
	"Method": "void testAcquireSharedInterruptibly(){\r\n    assertFalse(l.isSignalled());\r\n    l.acquireSharedInterruptibly(0);\r\n    assertTrue(l.isSignalled());\r\n    l.acquireSharedInterruptibly(0);\r\n    assertTrue(l.isSignalled());\r\n}"
}, {
	"Path": "java.net.Inet4Address.isMCGlobal",
	"Comment": "utility routine to check if the multicast address has global scope.",
	"Method": "boolean isMCGlobal(){\r\n    byte[] byteAddr = getAddress();\r\n    return ((byteAddr[0] & 0xff) >= 224 && (byteAddr[0] & 0xff) <= 238) && !((byteAddr[0] & 0xff) == 224 && byteAddr[1] == 0 && byteAddr[2] == 0);\r\n}"
}, {
	"Path": "jsr166.TimeUnitTest.testToNanos",
	"Comment": "tonanos correctly converts sample values in different units tonanoseconds",
	"Method": "void testToNanos(){\r\n    for (long t = 0; t < 88888; ++t) {\r\n        assertEquals(t * 1000000000L * 60 * 60 * 24, DAYS.toNanos(t));\r\n        assertEquals(t * 1000000000L * 60 * 60, HOURS.toNanos(t));\r\n        assertEquals(t * 1000000000L * 60, MINUTES.toNanos(t));\r\n        assertEquals(1000000000L * t, SECONDS.toNanos(t));\r\n        assertEquals(1000000L * t, MILLISECONDS.toNanos(t));\r\n        assertEquals(1000L * t, MICROSECONDS.toNanos(t));\r\n        assertEquals(t, NANOSECONDS.toNanos(t));\r\n    }\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_hijrahToMinguo",
	"Comment": "test to verify the date conversion from hijrah to minguo chronology",
	"Method": "void test_hijrahToMinguo(HijrahDate hijrah,MinguoDate minguo){\r\n    assertEquals(MinguoChronology.INSTANCE.date(hijrah), minguo);\r\n}"
}, {
	"Path": "sun.security.provider.certpath.IndexedCollectionCertStore.engineGetCertificates",
	"Comment": "returns a collection of certificates thatmatch the specified selector. if no certificatesmatch the selector, an empty collection will be returned.",
	"Method": "Collection<? extends Certificate> engineGetCertificates(CertSelector selector){\r\n    if (selector == null) {\r\n        Set<Certificate> matches = new HashSet();\r\n        matchX509Certs(new X509CertSelector(), matches);\r\n        matches.addAll(otherCertificates);\r\n        return matches;\r\n    }\r\n    if (selector instanceof X509CertSelector == false) {\r\n        Set<Certificate> matches = new HashSet();\r\n        matchX509Certs(selector, matches);\r\n        for (Certificate cert : otherCertificates) {\r\n            if (selector.match(cert)) {\r\n                matches.add(cert);\r\n            }\r\n        }\r\n        return matches;\r\n    }\r\n    if (certSubjects.isEmpty()) {\r\n        return Collections.<X509Certificate>emptySet();\r\n    }\r\n    X509CertSelector x509Selector = (X509CertSelector) selector;\r\n    X500Principal subject;\r\n    X509Certificate matchCert = x509Selector.getCertificate();\r\n    if (matchCert != null) {\r\n        subject = matchCert.getSubjectX500Principal();\r\n    } else {\r\n        subject = x509Selector.getSubject();\r\n    }\r\n    if (subject != null) {\r\n        Object entry = certSubjects.get(subject);\r\n        if (entry == null) {\r\n            return Collections.<X509Certificate>emptySet();\r\n        }\r\n        if (entry instanceof X509Certificate) {\r\n            X509Certificate x509Entry = (X509Certificate) entry;\r\n            if (x509Selector.match(x509Entry)) {\r\n                return Collections.singleton(x509Entry);\r\n            } else {\r\n                return Collections.<X509Certificate>emptySet();\r\n            }\r\n        } else {\r\n            @SuppressWarnings(\"unchecked\")\r\n            List<X509Certificate> list = (List<X509Certificate>) entry;\r\n            Set<X509Certificate> matches = new HashSet(16);\r\n            for (X509Certificate cert : list) {\r\n                if (x509Selector.match(cert)) {\r\n                    matches.add(cert);\r\n                }\r\n            }\r\n            return matches;\r\n        }\r\n    }\r\n    Set<Certificate> matches = new HashSet(16);\r\n    matchX509Certs(x509Selector, matches);\r\n    return matches;\r\n}"
}, {
	"Path": "java.util.zip.ZipOutputStream.closeEntry",
	"Comment": "closes the current zip entry and positions the stream for writingthe next entry.",
	"Method": "void closeEntry(){\r\n    ensureOpen();\r\n    if (current != null) {\r\n        ZipEntry e = current.entry;\r\n        switch(e.method) {\r\n            case DEFLATED:\r\n                def.finish();\r\n                while (!def.finished()) {\r\n                    deflate();\r\n                }\r\n                if ((e.flag & 8) == 0) {\r\n                    if (e.size != def.getBytesRead()) {\r\n                        throw new ZipException(\"invalid entry size (expected \" + e.size + \" but got \" + def.getBytesRead() + \" bytes)\");\r\n                    }\r\n                    if (e.csize != def.getBytesWritten()) {\r\n                        throw new ZipException(\"invalid entry compressed size (expected \" + e.csize + \" but got \" + def.getBytesWritten() + \" bytes)\");\r\n                    }\r\n                    if (e.crc != crc.getValue()) {\r\n                        throw new ZipException(\"invalid entry CRC-32 (expected 0x\" + Long.toHexString(e.crc) + \" but got 0x\" + Long.toHexString(crc.getValue()) + \")\");\r\n                    }\r\n                } else {\r\n                    e.size = def.getBytesRead();\r\n                    e.csize = def.getBytesWritten();\r\n                    e.crc = crc.getValue();\r\n                    writeEXT(e);\r\n                }\r\n                def.reset();\r\n                written += e.csize;\r\n                break;\r\n            case STORED:\r\n                if (e.size != written - locoff) {\r\n                    throw new ZipException(\"invalid entry size (expected \" + e.size + \" but got \" + (written - locoff) + \" bytes)\");\r\n                }\r\n                if (e.crc != crc.getValue()) {\r\n                    throw new ZipException(\"invalid entry crc-32 (expected 0x\" + Long.toHexString(e.crc) + \" but got 0x\" + Long.toHexString(crc.getValue()) + \")\");\r\n                }\r\n                break;\r\n            default:\r\n                throw new ZipException(\"invalid compression method\");\r\n        }\r\n        crc.reset();\r\n        current = null;\r\n    }\r\n}"
}, {
	"Path": "java.sql.DriverManager.getLoginTimeout",
	"Comment": "gets the maximum time in seconds that a driver can waitwhen attempting to log in to a database.",
	"Method": "int getLoginTimeout(){\r\n    return (loginTimeout);\r\n}"
}, {
	"Path": "java.security.cert.CertificateFactorySpi.engineGenerateCertPath",
	"Comment": "generates a certpath object and initializes it witha list of certificates.the certificates supplied must be of a type supported by thecertificatefactory. they will be copied out of the suppliedlist object. this method was added to version 1.4 of the java 2 platformstandard edition. in order to maintain backwards compatibility withexisting service providers, this method cannot be abstractand by default throws an unsupportedoperationexception.",
	"Method": "CertPath engineGenerateCertPath(InputStream inStream,CertPath engineGenerateCertPath,InputStream inStream,String encoding,CertPath engineGenerateCertPath,List<? extends Certificate> certificates){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "java.util.zip.DeflaterInputStream.available",
	"Comment": "returns 0 after eof has been reached, otherwise always return 1.programs should not count on this method to return the actual numberof bytes that could be read without blocking",
	"Method": "int available(){\r\n    ensureOpen();\r\n    if (reachEOF) {\r\n        return 0;\r\n    }\r\n    return 1;\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.getInfinity",
	"Comment": "gets the string used to represent infinity. almost always leftunchanged.",
	"Method": "String getInfinity(){\r\n    return infinity;\r\n}"
}, {
	"Path": "okio.Timeout.clearTimeout",
	"Comment": "clears the timeout. operating system timeouts may still apply.",
	"Method": "Timeout clearTimeout(){\r\n    this.timeoutNanos = 0;\r\n    return this;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.ast.ParenthesizedExpression.parenthesizeAndReplace",
	"Comment": "wraps the given expression with a parenthesizedexpression and replaces itin the tree.",
	"Method": "ParenthesizedExpression parenthesizeAndReplace(Expression expression){\r\n    ParenthesizedExpression newExpr = new ParenthesizedExpression();\r\n    expression.replaceWith(newExpr);\r\n    newExpr.setExpression(expression);\r\n    return newExpr;\r\n}"
}, {
	"Path": "android.icu.dev.test.util.LocaleDataTest.TestEnglishExemplarCharacters",
	"Comment": "simple test case for checking exemplar character type coverage",
	"Method": "void TestEnglishExemplarCharacters(){\r\n    final char[] testChars = { 0x61, 0xE1, 0x41, 0, 0x2D };\r\n    LocaleData ld = LocaleData.getInstance(ULocale.ENGLISH);\r\n    for (int type = 0; type < LocaleData.ES_COUNT; type++) {\r\n        UnicodeSet exSet = ld.getExemplarSet(0, type);\r\n        if (exSet != null) {\r\n            if (testChars[type] > 0 && !exSet.contains(testChars[type])) {\r\n                errln(\"Character '\" + testChars[type] + \"' is not included in exemplar type \" + type);\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        ld.getExemplarSet(0, LocaleData.ES_COUNT);\r\n        throw new ICUException(\"Test failure; should throw exception\");\r\n    } catch (IllegalArgumentException e) {\r\n        assertEquals(\"\", \"java.lang.ArrayIndexOutOfBoundsException\", e.getCause().getClass().getName());\r\n    }\r\n}"
}, {
	"Path": "javax.net.ssl.HttpsURLConnection.getDefaultSSLSocketFactory",
	"Comment": "gets the default static sslsocketfactory that isinherited by new instances of this class.the socket factories are used when creating sockets for securehttps url connections.",
	"Method": "SSLSocketFactory getDefaultSSLSocketFactory(){\r\n    if (defaultSSLSocketFactory == null) {\r\n        defaultSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\r\n    }\r\n    return defaultSSLSocketFactory;\r\n}"
}, {
	"Path": "java.util.concurrent.Exchanger.slotExchange",
	"Comment": "exchange function used until arenas enabled. see above for explanation.",
	"Method": "Object slotExchange(Object item,boolean timed,long ns){\r\n    Node p = participant.get();\r\n    Thread t = Thread.currentThread();\r\n    if (t.isInterrupted())\r\n        return null;\r\n    for (Node q; ; ) {\r\n        if ((q = slot) != null) {\r\n            if (U.compareAndSwapObject(this, SLOT, q, null)) {\r\n                Object v = q.item;\r\n                q.match = item;\r\n                Thread w = q.parked;\r\n                if (w != null)\r\n                    U.unpark(w);\r\n                return v;\r\n            }\r\n            if (NCPU > 1 && bound == 0 && U.compareAndSwapInt(this, BOUND, 0, SEQ))\r\n                arena = new Node[(FULL + 2) << ASHIFT];\r\n        } else if (arena != null)\r\n            return null;\r\n        else {\r\n            p.item = item;\r\n            if (U.compareAndSwapObject(this, SLOT, null, p))\r\n                break;\r\n            p.item = null;\r\n        }\r\n    }\r\n    int h = p.hash;\r\n    long end = timed ? System.nanoTime() + ns : 0L;\r\n    int spins = (NCPU > 1) ? SPINS : 1;\r\n    Object v;\r\n    while ((v = p.match) == null) {\r\n        if (spins > 0) {\r\n            h ^= h << 1;\r\n            h ^= h >>> 3;\r\n            h ^= h << 10;\r\n            if (h == 0)\r\n                h = SPINS | (int) t.getId();\r\n            else if (h < 0 && (--spins & ((SPINS >>> 1) - 1)) == 0)\r\n                Thread.yield();\r\n        } else if (slot != p)\r\n            spins = SPINS;\r\n        else if (!t.isInterrupted() && arena == null && (!timed || (ns = end - System.nanoTime()) > 0L)) {\r\n            U.putObject(t, BLOCKER, this);\r\n            p.parked = t;\r\n            if (slot == p)\r\n                U.park(false, ns);\r\n            p.parked = null;\r\n            U.putObject(t, BLOCKER, null);\r\n        } else if (U.compareAndSwapObject(this, SLOT, p, null)) {\r\n            v = timed && ns <= 0L && !t.isInterrupted() ? TIMED_OUT : null;\r\n            break;\r\n        }\r\n    }\r\n    U.putOrderedObject(p, MATCH, null);\r\n    p.item = null;\r\n    p.hash = h;\r\n    return v;\r\n}"
}, {
	"Path": "sun.security.x509.X509CertInfo.hashCode",
	"Comment": "calculates a hash code value for the object.objectswhich are equal will also have the same hashcode.",
	"Method": "int hashCode(){\r\n    int retval = 0;\r\n    for (int i = 1; i < rawCertInfo.length; i++) {\r\n        retval += rawCertInfo[i] * i;\r\n    }\r\n    return (retval);\r\n}"
}, {
	"Path": "sun.security.util.DerInputStream.toByteArray",
	"Comment": "return what has been written to this derinputstreamas a byte array. useful for debugging.",
	"Method": "byte[] toByteArray(){\r\n    return buffer.toByteArray();\r\n}"
}, {
	"Path": "sun.security.x509.X509CRLImpl.getBaseCRLNumber",
	"Comment": "return the base crl number from the deltacrlindicatorextension, if any.",
	"Method": "BigInteger getBaseCRLNumber(){\r\n    DeltaCRLIndicatorExtension dciExt = getDeltaCRLIndicatorExtension();\r\n    if (dciExt != null) {\r\n        BigInteger num = (BigInteger) dciExt.get(dciExt.NUMBER);\r\n        return num;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.lang.NumberFormatException.forInputString",
	"Comment": "factory method for making a numberformatexceptiongiven the specified input which caused the error.",
	"Method": "NumberFormatException forInputString(String s){\r\n    return new NumberFormatException(\"For input string: \\\"\" + s + \"\\\"\");\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigDecimalArithmeticTest.testSubtractMathContextEqualScalePosPos",
	"Comment": "subtract two numbers of equal positive scales using mathcontext",
	"Method": "void testSubtractMathContextEqualScalePosPos(){\r\n    String a = \"1231212478987482988429808779810457634781384756794987\";\r\n    int aScale = 10;\r\n    String b = \"747233429293018787918347987234564568\";\r\n    int bScale = 10;\r\n    String c = \"1.23121247898749E+41\";\r\n    int cScale = -27;\r\n    BigDecimal aNumber = new BigDecimal(new BigInteger(a), aScale);\r\n    BigDecimal bNumber = new BigDecimal(new BigInteger(b), bScale);\r\n    MathContext mc = new MathContext(15, RoundingMode.CEILING);\r\n    BigDecimal result = aNumber.subtract(bNumber, mc);\r\n    assertEquals(\"incorrect value\", c, result.toString());\r\n    assertEquals(\"incorrect scale\", cScale, result.scale());\r\n}"
}, {
	"Path": "java.util.IllegalFormatFlagsException.getFlags",
	"Comment": "returns the set of flags which contains an illegal combination.",
	"Method": "String getFlags(){\r\n    return flags;\r\n}"
}, {
	"Path": "java.util.regex.Matcher.hitEnd",
	"Comment": "returns true if the end of input was hit by the search engine inthe last match operation performed by this matcher.when this method returns true, then it is possible that more inputwould have changed the result of the last search.",
	"Method": "boolean hitEnd(){\r\n    return hitEndImpl(address);\r\n}"
}, {
	"Path": "sun.security.x509.CRLReasonCodeExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(REASON);\r\n    return elements.elements();\r\n}"
}, {
	"Path": "java.util.Locale.hashCode",
	"Comment": "override hashcode.since locales are often used in hashtables, caches the valuefor speed.",
	"Method": "int hashCode(int hashCode){\r\n    int hc = hashCodeValue;\r\n    if (hc == 0) {\r\n        hc = baseLocale.hashCode();\r\n        if (localeExtensions != null) {\r\n            hc ^= localeExtensions.hashCode();\r\n        }\r\n        hashCodeValue = hc;\r\n    }\r\n    return hc;\r\n}"
}, {
	"Path": "java.net.Inet4Address.isMCNodeLocal",
	"Comment": "utility routine to check if the multicast address has node scope.",
	"Method": "boolean isMCNodeLocal(){\r\n    return false;\r\n}"
}, {
	"Path": "sun.security.x509.CertificateAlgorithmId.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(ALGORITHM);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "java.util.concurrent.Phaser.awaitAdvance",
	"Comment": "awaits the phase of this phaser to advance from the given phasevalue, returning immediately if the current phase is not equalto the given phase value or this phaser is terminated.",
	"Method": "int awaitAdvance(int phase){\r\n    final Phaser root = this.root;\r\n    long s = (root == this) ? state : reconcileState();\r\n    int p = (int) (s >>> PHASE_SHIFT);\r\n    if (phase < 0)\r\n        return phase;\r\n    if (p == phase)\r\n        return root.internalAwaitAdvance(phase, null);\r\n    return p;\r\n}"
}, {
	"Path": "java.text.DigitList.append",
	"Comment": "appends a digit to the list, extending the list when necessary.",
	"Method": "void append(char digit){\r\n    if (count == digits.length) {\r\n        char[] data = new char[count + 100];\r\n        System.arraycopy(digits, 0, data, 0, count);\r\n        digits = data;\r\n    }\r\n    digits[count++] = digit;\r\n}"
}, {
	"Path": "com.google.mockwebserver.MockResponse.addHeader",
	"Comment": "adds a new header with the name and value. this may be used to addmultiple headers with the same name.",
	"Method": "MockResponse addHeader(String header,MockResponse addHeader,String name,Object value){\r\n    return addHeader(name + \": \" + String.valueOf(value));\r\n}"
}, {
	"Path": "sun.security.jca.Providers.stopJarVerification",
	"Comment": "stop jar verification. call once you have completed jar verification.",
	"Method": "void stopJarVerification(Object obj){\r\n    endThreadProviderList((ProviderList) obj);\r\n}"
}, {
	"Path": "java.net.InetSocketAddress.createUnresolved",
	"Comment": "creates an unresolved socket address from a hostname and a port number.no attempt will be made to resolve the hostname into an inetaddress.the address will be flagged as unresolved.a valid port value is between 0 and 65535.a port number of zero will let the system pick up anephemeral port in a bind operation.",
	"Method": "InetSocketAddress createUnresolved(String host,int port){\r\n    return new InetSocketAddress(checkPort(port), checkHost(host));\r\n}"
}, {
	"Path": "java.time.temporal.ValueRange.checkValidValue",
	"Comment": "checks that the specified value is valid.this validates that the value is within the valid range of values.the field is only used to improve the error message.",
	"Method": "long checkValidValue(long value,TemporalField field){\r\n    if (isValidValue(value) == false) {\r\n        throw new DateTimeException(genInvalidFieldMessage(field, value));\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "java.util.StringTokenizer.scanToken",
	"Comment": "skips ahead from startpos and returns the index of the next delimitercharacter encountered, or maxposition if no such delimiter is found.",
	"Method": "int scanToken(int startPos){\r\n    int position = startPos;\r\n    while (position < maxPosition) {\r\n        if (!hasSurrogates) {\r\n            char c = str.charAt(position);\r\n            if ((c <= maxDelimCodePoint) && (delimiters.indexOf(c) >= 0))\r\n                break;\r\n            position++;\r\n        } else {\r\n            int c = str.codePointAt(position);\r\n            if ((c <= maxDelimCodePoint) && isDelimiter(c))\r\n                break;\r\n            position += Character.charCount(c);\r\n        }\r\n    }\r\n    if (retDelims && (startPos == position)) {\r\n        if (!hasSurrogates) {\r\n            char c = str.charAt(position);\r\n            if ((c <= maxDelimCodePoint) && (delimiters.indexOf(c) >= 0))\r\n                position++;\r\n        } else {\r\n            int c = str.codePointAt(position);\r\n            if ((c <= maxDelimCodePoint) && isDelimiter(c))\r\n                position += Character.charCount(c);\r\n        }\r\n    }\r\n    return position;\r\n}"
}, {
	"Path": "java.net.InterfaceAddress.equals",
	"Comment": "compares this object against the specified object.the result is true if and only if the argument isnot null and it represents the same interface address asthis object.two instances of interfaceaddress represent the sameaddress if the inetaddress, the prefix length and the broadcast arethe same for both.",
	"Method": "boolean equals(Object obj){\r\n    if (!(obj instanceof InterfaceAddress)) {\r\n        return false;\r\n    }\r\n    InterfaceAddress cmp = (InterfaceAddress) obj;\r\n    if (!(address == null ? cmp.address == null : address.equals(cmp.address)))\r\n        return false;\r\n    if (!(broadcast == null ? cmp.broadcast == null : broadcast.equals(cmp.broadcast)))\r\n        return false;\r\n    if (maskLength != cmp.maskLength)\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "java.text.DecimalFormat.setMaximumFractionDigits",
	"Comment": "sets the maximum number of digits allowed in the fraction portion of anumber.for formatting numbers other than biginteger andbigdecimal objects, the lower of newvalue and340 is used. negative input values are replaced with 0.",
	"Method": "void setMaximumFractionDigits(int newValue){\r\n    maximumFractionDigits = Math.min(Math.max(0, newValue), MAXIMUM_FRACTION_DIGITS);\r\n    super.setMaximumFractionDigits((maximumFractionDigits > DOUBLE_FRACTION_DIGITS) ? DOUBLE_FRACTION_DIGITS : maximumFractionDigits);\r\n    if (minimumFractionDigits > maximumFractionDigits) {\r\n        minimumFractionDigits = maximumFractionDigits;\r\n        super.setMinimumFractionDigits((minimumFractionDigits > DOUBLE_FRACTION_DIGITS) ? DOUBLE_FRACTION_DIGITS : minimumFractionDigits);\r\n    }\r\n    fastPathCheckNeeded = true;\r\n}"
}, {
	"Path": "java.net.URLConnection.skipForward",
	"Comment": "skips through the specified number of bytes from the streamuntil either eof is reached, or the specifiednumber of bytes have been skipped",
	"Method": "long skipForward(InputStream is,long toSkip){\r\n    long eachSkip = 0;\r\n    long skipped = 0;\r\n    while (skipped != toSkip) {\r\n        eachSkip = is.skip(toSkip - skipped);\r\n        if (eachSkip <= 0) {\r\n            if (is.read() == -1) {\r\n                return skipped;\r\n            } else {\r\n                skipped++;\r\n            }\r\n        }\r\n        skipped += eachSkip;\r\n    }\r\n    return skipped;\r\n}"
}, {
	"Path": "android.icu.dev.test.collator.G7CollationTest.doTest",
	"Comment": "main test routine, tests comparisons for a set of strings against sets of expected results",
	"Method": "void doTest(Collator myCollation,String source,String target,int result){\r\n    int compareResult = myCollation.compare(source, target);\r\n    CollationKey sortKey1, sortKey2;\r\n    sortKey1 = myCollation.getCollationKey(source);\r\n    sortKey2 = myCollation.getCollationKey(target);\r\n    int keyResult = sortKey1.compareTo(sortKey2);\r\n    reportCResult(source, target, sortKey1, sortKey2, compareResult, keyResult, compareResult, result);\r\n}"
}, {
	"Path": "java.util.PriorityQueue.removeEq",
	"Comment": "version of remove using reference equality, not equals.needed by iterator.remove.",
	"Method": "boolean removeEq(Object o){\r\n    for (int i = 0; i < size; i++) {\r\n        if (o == queue[i]) {\r\n            removeAt(i);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testGetWaitQueueLengthIMSE",
	"Comment": "getwaitqueuelength throws illegalmonitorstateexception if not synced",
	"Method": "void testGetWaitQueueLengthIMSE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    try {\r\n        sync.getWaitQueueLength(c);\r\n        shouldThrow();\r\n    } catch (IllegalMonitorStateException success) {\r\n    }\r\n    assertHasWaitersUnlocked(sync, c, NO_THREADS);\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getQueueLength",
	"Comment": "returns an estimate of the number of threads waiting toacquire.the value is only an estimate because the number ofthreads may change dynamically while this method traversesinternal data structures.this method is designed for use inmonitoring system state, not for synchronization control.",
	"Method": "int getQueueLength(){\r\n    int n = 0;\r\n    for (Node p = tail; p != null; p = p.prev) {\r\n        if (p.thread != null)\r\n            ++n;\r\n    }\r\n    return n;\r\n}"
}, {
	"Path": "javax.security.auth.callback.PasswordCallback.getPassword",
	"Comment": "get the retrieved password. this method returns a copy of the retrieved password.",
	"Method": "char[] getPassword(){\r\n    return (inputPassword == null ? null : inputPassword.clone());\r\n}"
}, {
	"Path": "org.xml.sax.helpers.XMLReaderAdapter.setDocumentHandler",
	"Comment": "register the sax1 document event handler.note that the sax1 document handler has no namespacesupport.",
	"Method": "void setDocumentHandler(DocumentHandler handler){\r\n    documentHandler = handler;\r\n}"
}, {
	"Path": "java.security.DigestInputStream.on",
	"Comment": "turns the digest function on or off. the default is on.whenit is on, a call to one of the read methods results in anupdate on the message digest.but when it is off, the messagedigest is not updated.",
	"Method": "void on(boolean on){\r\n    this.on = on;\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.setMinCRLNumber",
	"Comment": "sets the mincrlnumber criterion. the x509crl must have acrl number extension whose value is greater than or equal to thespecified value. if null, no mincrlnumber check will bedone.",
	"Method": "void setMinCRLNumber(BigInteger minCRL){\r\n    this.minCRL = minCRL;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentSkipListSet.iterator",
	"Comment": "returns an iterator over the elements in this set in ascending order.",
	"Method": "Iterator<E> iterator(){\r\n    return m.navigableKeySet().iterator();\r\n}"
}, {
	"Path": "java.security.cert.CertificateRevokedException.getExtensions",
	"Comment": "returns a map of x.509 extensions containing additional informationabout the revoked certificate, such as the invalidity dateextension. each key is an oid string that maps to the correspondingextension.",
	"Method": "Map<String, Extension> getExtensions(){\r\n    return Collections.unmodifiableMap(extensions);\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testUnconfigurableScheduledExecutorService",
	"Comment": "an unconfigurable newscheduledthreadpool successfully runs delayed task",
	"Method": "void testUnconfigurableScheduledExecutorService(){\r\n    final ScheduledExecutorService p = Executors.unconfigurableScheduledExecutorService(Executors.newScheduledThreadPool(2));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        final CountDownLatch proceed = new CountDownLatch(1);\r\n        final Runnable task = new CheckedRunnable() {\r\n            public void realRun() {\r\n                await(proceed);\r\n            }\r\n        };\r\n        long startTime = System.nanoTime();\r\n        Future f = p.schedule(Executors.callable(task, Boolean.TRUE), timeoutMillis(), MILLISECONDS);\r\n        assertFalse(f.isDone());\r\n        proceed.countDown();\r\n        assertSame(Boolean.TRUE, f.get(LONG_DELAY_MS, MILLISECONDS));\r\n        assertSame(Boolean.TRUE, f.get());\r\n        assertTrue(f.isDone());\r\n        assertFalse(f.isCancelled());\r\n        assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testUnconfigurableScheduledExecutorService",
	"Comment": "an unconfigurable newscheduledthreadpool successfully runs delayed task",
	"Method": "void testUnconfigurableScheduledExecutorService(){\r\n    await(proceed);\r\n}"
}, {
	"Path": "java.text.SimpleDateFormat.equals",
	"Comment": "compares the given object with this simpledateformat forequality.",
	"Method": "boolean equals(Object obj){\r\n    if (!super.equals(obj))\r\n        return false;\r\n    SimpleDateFormat that = (SimpleDateFormat) obj;\r\n    return (pattern.equals(that.pattern) && formatData.equals(that.formatData));\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicIntegerFieldUpdater.getAndAdd",
	"Comment": "atomically adds the given value to the current value of the field ofthe given object managed by this updater.",
	"Method": "int getAndAdd(T obj,int delta,int getAndAdd,T obj,int delta){\r\n    int prev, next;\r\n    do {\r\n        prev = get(obj);\r\n        next = prev + delta;\r\n    } while (!compareAndSet(obj, prev, next));\r\n    return prev;\r\n}"
}, {
	"Path": "java.lang.Package.getSpecificationTitle",
	"Comment": "return the title of the specification that this package implements.",
	"Method": "String getSpecificationTitle(){\r\n    return specTitle;\r\n}"
}, {
	"Path": "java.security.Provider.implPutAll",
	"Comment": "copies all of the mappings from the specified map to this provider.internal method to be called after the security check has beenperformed.",
	"Method": "void implPutAll(Map t){\r\n    for (Map.Entry e : ((Map<?, ?>) t).entrySet()) {\r\n        implPut(e.getKey(), e.getValue());\r\n    }\r\n    if (registered) {\r\n        Security.increaseVersion();\r\n    }\r\n}"
}, {
	"Path": "java.time.zone.ZoneRules.getOffset",
	"Comment": "gets the offset applicable at the specified instant in these rules.the mapping from an instant to an offset is simple, there is onlyone valid offset for each instant.this method returns that offset.",
	"Method": "ZoneOffset getOffset(Instant instant,ZoneOffset getOffset,LocalDateTime localDateTime){\r\n    Object info = getOffsetInfo(localDateTime);\r\n    if (info instanceof ZoneOffsetTransition) {\r\n        return ((ZoneOffsetTransition) info).getOffsetBefore();\r\n    }\r\n    return (ZoneOffset) info;\r\n}"
}, {
	"Path": "java.util.Properties.getProperty",
	"Comment": "searches for the property with the specified key in this property list.if the key is not found in this property list, the default property list,and its defaults, recursively, are then checked. the method returns thedefault value argument if the property is not found.",
	"Method": "String getProperty(String key,String getProperty,String key,String defaultValue){\r\n    String val = getProperty(key);\r\n    return (val == null) ? defaultValue : val;\r\n}"
}, {
	"Path": "java.math.BigDecimal.bigMultiplyPowerTen",
	"Comment": "compute this10 ^ n.needed mainly to allow special casing to trap zero value",
	"Method": "BigInteger bigMultiplyPowerTen(int n,BigInteger bigMultiplyPowerTen,long value,int n,BigInteger bigMultiplyPowerTen,BigInteger value,int n){\r\n    if (n <= 0)\r\n        return value;\r\n    if (n < LONG_TEN_POWERS_TABLE.length) {\r\n        return value.multiply(LONG_TEN_POWERS_TABLE[n]);\r\n    }\r\n    return value.multiply(bigTenToThe(n));\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.ast.TreeUtil.getSourceFileName",
	"Comment": "gets the relative file path of the source java file for this compilationunit.",
	"Method": "String getSourceFileName(CompilationUnit unit){\r\n    return getQualifiedMainTypeName(unit).replace('.', File.separatorChar) + \".java\";\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberRegressionTests.Test4074620",
	"Comment": "numberformat.equals comparing two obj equal even the setgroupingusedflag is different.",
	"Method": "void Test4074620(){\r\n    MyNumberFormat nf1 = new MyNumberFormat();\r\n    MyNumberFormat nf2 = new MyNumberFormat();\r\n    nf1.setGroupingUsed(false);\r\n    nf2.setGroupingUsed(true);\r\n    if (nf1.equals(nf2))\r\n        errln(\"Test for bug 4074620 failed\");\r\n    else\r\n        logln(\"Test for bug 4074620 passed.\");\r\n    return;\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.getCurrentFixedDate",
	"Comment": "returns the fixed date value of this object. the time value andcalendar fields must be in synch.",
	"Method": "long getCurrentFixedDate(){\r\n    return (calsys == gcal) ? cachedFixedDate : calsys.getFixedDate(cdate);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testQuietlyInvokeSingleton",
	"Comment": "quietlyinvoke task returns when task completes normally.iscompletedabnormally and iscancelled return false for normallycompleted tasks",
	"Method": "void testQuietlyInvokeSingleton(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            CCF f = new LCCF(8);\r\n            f.quietlyInvoke();\r\n            assertEquals(21, f.number);\r\n            checkCompletedNormally(f);\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testQuietlyInvokeSingleton",
	"Comment": "quietlyinvoke task returns when task completes normally.iscompletedabnormally and iscancelled return false for normallycompleted tasks",
	"Method": "void testQuietlyInvokeSingleton(){\r\n    CCF f = new LCCF(8);\r\n    f.quietlyInvoke();\r\n    assertEquals(21, f.number);\r\n    checkCompletedNormally(f);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.lang.reflect.GenericMethodsTests.checkReturnType",
	"Comment": "tests whether the type of the return type is the declared type parameter.",
	"Method": "void checkReturnType(Method method){\r\n    TypeVariable<Method> typeParameter = getTypeParameter(method);\r\n    Type genericReturnType = method.getGenericReturnType();\r\n    assertEquals(typeParameter, genericReturnType);\r\n    assertInstanceOf(TypeVariable.class, genericReturnType);\r\n    assertEquals(method, ((TypeVariable<?>) genericReturnType).getGenericDeclaration());\r\n}"
}, {
	"Path": "java.lang.ThreadGroup.activeCount",
	"Comment": "returns an estimate of the number of active threads in this threadgroup and its subgroups. recursively iterates over all subgroups inthis thread group. the value returned is only an estimate because the number ofthreads may change dynamically while this method traverses internaldata structures, and might be affected by the presence of certainsystem threads. this method is intended primarily for debuggingand monitoring purposes.",
	"Method": "int activeCount(){\r\n    int result;\r\n    int ngroupsSnapshot;\r\n    ThreadGroup[] groupsSnapshot;\r\n    synchronized (this) {\r\n        if (destroyed) {\r\n            return 0;\r\n        }\r\n        result = nthreads;\r\n        ngroupsSnapshot = ngroups;\r\n        if (groups != null) {\r\n            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);\r\n        } else {\r\n            groupsSnapshot = null;\r\n        }\r\n    }\r\n    for (int i = 0; i < ngroupsSnapshot; i++) {\r\n        result += groupsSnapshot[i].activeCount();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "java.time.zone.ZoneOffsetTransition.equals",
	"Comment": "checks if this object equals another.the entire state of the object is compared.",
	"Method": "boolean equals(Object other){\r\n    if (other == this) {\r\n        return true;\r\n    }\r\n    if (other instanceof ZoneOffsetTransition) {\r\n        ZoneOffsetTransition d = (ZoneOffsetTransition) other;\r\n        return transition.equals(d.transition) && offsetBefore.equals(d.offsetBefore) && offsetAfter.equals(d.offsetAfter);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "okio.SegmentSharingTest.cloneSegmentsAreNotRecycled",
	"Comment": "clones share their backing byte arrays with the source buffers. those byte arrays must notbe recycled, otherwise the new writer could corrupt the segment.",
	"Method": "void cloneSegmentsAreNotRecycled(){\r\n    Buffer buffer = concatenateBuffers(xs, ys, zs);\r\n    Buffer clone = buffer.clone();\r\n    synchronized (SegmentPool.class) {\r\n        SegmentPool.next = null;\r\n        SegmentPool.byteCount = 0L;\r\n        buffer.clear();\r\n        assertEquals(null, SegmentPool.next);\r\n        clone.clear();\r\n        assertEquals(null, SegmentPool.next);\r\n    }\r\n}"
}, {
	"Path": "javax.net.ssl.SSLContext.getInstance",
	"Comment": "returns a sslcontext object that implements thespecified secure socket protocol. a new sslcontext object encapsulating thesslcontextspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "SSLContext getInstance(String protocol,SSLContext getInstance,String protocol,String provider,SSLContext getInstance,String protocol,Provider provider){\r\n    GetInstance.Instance instance = GetInstance.getInstance(\"SSLContext\", SSLContextSpi.class, protocol, provider);\r\n    return new SSLContext((SSLContextSpi) instance.impl, instance.provider, protocol);\r\n}"
}, {
	"Path": "java.time.Instant.minusNanos",
	"Comment": "returns a copy of this instant with the specified duration in nanoseconds subtracted.this instance is immutable and unaffected by this method call.",
	"Method": "Instant minusNanos(long nanosToSubtract){\r\n    if (nanosToSubtract == Long.MIN_VALUE) {\r\n        return plusNanos(Long.MAX_VALUE).plusNanos(1);\r\n    }\r\n    return plusNanos(-nanosToSubtract);\r\n}"
}, {
	"Path": "java.util.IntSummaryStatistics.getSum",
	"Comment": "returns the sum of values recorded, or zero if no values have beenrecorded.",
	"Method": "long getSum(){\r\n    return sum;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.JavadocGeneratorTest.testStyleTagsSkipped",
	"Comment": "verify style tags are skipped, since quick help displays them.",
	"Method": "void testStyleTagsSkipped(){\r\n    String translation = translateSourceFile(\"/** <h3>Regular expression syntax<\/h3>\\n\" + \" * <span class=\\\"datatable\\\">\\n\" + \" * <style type=\\\"text/css\\\">\\n\" + \" * .datatable td { padding-right: 20px; }\\n\" + \" * <\/style>\\n\" + \" */\\n\" + \"class Test {}\", \"Test\", \"Test.h\");\r\n    assertNotInTranslation(translation, \"<style\");\r\n    assertTranslatedLines(translation, \"/*!\", \"@brief <h3>Regular expression syntax<\/h3>\", \"<span class=\\\"datatable\\\">\", \"*/\");\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.setKeyUsage",
	"Comment": "sets the keyusage criterion. the x509certificatemust allow the specified keyusage values. if null, nokeyusage check will be done. note that an x509certificatethat has no keyusage extension implicitly allows all keyusage values.note that the boolean array supplied here is cloned to protect againstsubsequent modifications.",
	"Method": "void setKeyUsage(boolean[] keyUsage){\r\n    if (keyUsage == null) {\r\n        this.keyUsage = null;\r\n    } else {\r\n        this.keyUsage = keyUsage.clone();\r\n    }\r\n}"
}, {
	"Path": "java.security.spec.PKCS8EncodedKeySpec.getFormat",
	"Comment": "returns the name of the encoding format associated with thiskey specification.",
	"Method": "String getFormat(){\r\n    return \"PKCS#8\";\r\n}"
}, {
	"Path": "java.util.zip.GZIPOutputStream.finish",
	"Comment": "finishes writing compressed data to the output stream without closingthe underlying stream. use this method when applying multiple filtersin succession to the same output stream.",
	"Method": "void finish(){\r\n    if (!def.finished()) {\r\n        def.finish();\r\n        while (!def.finished()) {\r\n            int len = def.deflate(buf, 0, buf.length);\r\n            if (def.finished() && len <= buf.length - TRAILER_SIZE) {\r\n                writeTrailer(buf, len);\r\n                len = len + TRAILER_SIZE;\r\n                out.write(buf, 0, len);\r\n                return;\r\n            }\r\n            if (len > 0)\r\n                out.write(buf, 0, len);\r\n        }\r\n        byte[] trailer = new byte[TRAILER_SIZE];\r\n        writeTrailer(trailer, 0);\r\n        out.write(trailer);\r\n    }\r\n}"
}, {
	"Path": "jsr166.PriorityBlockingQueueTest.testAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testAddAll3(){\r\n    PriorityBlockingQueue q = new PriorityBlockingQueue(SIZE);\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i);\r\n    try {\r\n        q.addAll(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.sql.Timestamp.after",
	"Comment": "indicates whether this timestamp object islater than the given timestamp object.",
	"Method": "boolean after(Timestamp ts){\r\n    return compareTo(ts) > 0;\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testIntArrayGetAndAccumulate",
	"Comment": "atomicintegerarray getandaccumulate returns previous value and updateswith supplied function.",
	"Method": "void testIntArrayGetAndAccumulate(){\r\n    AtomicIntegerArray a = new AtomicIntegerArray(1);\r\n    a.set(0, 1);\r\n    assertEquals(1, a.getAndAccumulate(0, 2, Integer::sum));\r\n    assertEquals(3, a.getAndAccumulate(0, 3, Integer::sum));\r\n    assertEquals(6, a.get(0));\r\n}"
}, {
	"Path": "java.util.zip.ZipFile.releaseInflater",
	"Comment": "releases the specified inflater to the list of available inflaters.",
	"Method": "void releaseInflater(Inflater inf){\r\n    if (false == inf.ended()) {\r\n        inf.reset();\r\n        synchronized (inflaterCache) {\r\n            inflaterCache.add(inf);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.PolicyInformation.equals",
	"Comment": "compare this policyinformation with another object for equality",
	"Method": "boolean equals(Object other){\r\n    if (!(other instanceof PolicyInformation))\r\n        return false;\r\n    PolicyInformation piOther = (PolicyInformation) other;\r\n    if (!policyIdentifier.equals(piOther.getPolicyIdentifier()))\r\n        return false;\r\n    return policyQualifiers.equals(piOther.getPolicyQualifiers());\r\n}"
}, {
	"Path": "android.icu.dev.test.format.DateFormatTest.TestPatterns",
	"Comment": "verify that patterns have the correct values and could produce thethe dateformat instances that contain the correct localized patterns.",
	"Method": "void TestPatterns(){\r\n    final String[][] EXPECTED = { // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.YEAR, \"y\", \"en\", \"y\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.QUARTER, \"QQQQ\", \"en\", \"QQQQ\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.ABBR_QUARTER, \"QQQ\", \"en\", \"QQQ\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.YEAR_QUARTER, \"yQQQQ\", \"en\", \"QQQQ y\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.YEAR_ABBR_QUARTER, \"yQQQ\", \"en\", \"QQQ y\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.MONTH, \"MMMM\", \"en\", \"LLLL\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.ABBR_MONTH, \"MMM\", \"en\", \"LLL\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.NUM_MONTH, \"M\", \"en\", \"L\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.YEAR_MONTH, \"yMMMM\", \"en\", \"MMMM y\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.YEAR_ABBR_MONTH, \"yMMM\", \"en\", \"MMM y\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.YEAR_NUM_MONTH, \"yM\", \"en\", \"M/y\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.DAY, \"d\", \"en\", \"d\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.YEAR_MONTH_DAY, \"yMMMMd\", \"en\", \"MMMM d, y\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.YEAR_ABBR_MONTH_DAY, \"yMMMd\", \"en\", \"MMM d, y\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.YEAR_NUM_MONTH_DAY, \"yMd\", \"en\", \"M/d/y\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.WEEKDAY, \"EEEE\", \"en\", \"cccc\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.ABBR_WEEKDAY, \"E\", \"en\", \"ccc\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.YEAR_MONTH_WEEKDAY_DAY, \"yMMMMEEEEd\", \"en\", \"EEEE, MMMM d, y\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.YEAR_ABBR_MONTH_WEEKDAY_DAY, \"yMMMEd\", \"en\", \"EEE, MMM d, y\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.YEAR_NUM_MONTH_WEEKDAY_DAY, \"yMEd\", \"en\", \"EEE, M/d/y\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.MONTH_DAY, \"MMMMd\", \"en\", \"MMMM d\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.ABBR_MONTH_DAY, \"MMMd\", \"en\", \"MMM d\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.NUM_MONTH_DAY, \"Md\", \"en\", \"M/d\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.MONTH_WEEKDAY_DAY, \"MMMMEEEEd\", \"en\", \"EEEE, MMMM d\" }, // (fixed expected result per ticket 6872<-6626)\r\n    { DateFormat.ABBR_MONTH_WEEKDAY_DAY, \"MMMEd\", \"en\", \"EEE, MMM d\" }, { DateFormat.NUM_MONTH_WEEKDAY_DAY, \"MEd\", \"en\", \"EEE, M/d\" }, { DateFormat.HOUR, \"j\", \"en\", \"h a\" }, // (fixed expected result per ticket 6872<-7180)\r\n    { DateFormat.HOUR24, \"H\", \"en\", \"HH\" }, { DateFormat.MINUTE, \"m\", \"en\", \"m\" }, { DateFormat.HOUR_MINUTE, \"jm\", \"en\", \"h:mm a\" }, // (fixed expected result per ticket 6872<-7180)\r\n    { DateFormat.HOUR24_MINUTE, \"Hm\", \"en\", \"HH:mm\" }, { DateFormat.SECOND, \"s\", \"en\", \"s\" }, { DateFormat.HOUR_MINUTE_SECOND, \"jms\", \"en\", \"h:mm:ss a\" }, { DateFormat.HOUR24_MINUTE_SECOND, \"Hms\", \"en\", \"HH:mm:ss\" }, // marker for starting combinations\r\n    { DateFormat.MINUTE_SECOND, \"ms\", \"en\", \"mm:ss\" }, // marker for starting combinations\r\n    { DateFormat.LOCATION_TZ, \"VVVV\", \"en\", \"VVVV\" }, // marker for starting combinations\r\n    { DateFormat.GENERIC_TZ, \"vvvv\", \"en\", \"vvvv\" }, // marker for starting combinations\r\n    { DateFormat.ABBR_GENERIC_TZ, \"v\", \"en\", \"v\" }, // marker for starting combinations\r\n    { DateFormat.SPECIFIC_TZ, \"zzzz\", \"en\", \"zzzz\" }, // marker for starting combinations\r\n    { DateFormat.ABBR_SPECIFIC_TZ, \"z\", \"en\", \"z\" }, { DateFormat.ABBR_UTC_TZ, \"ZZZZ\", \"en\", \"ZZZZ\" }, {}, { DateFormat.YEAR_NUM_MONTH_DAY + DateFormat.ABBR_UTC_TZ, \"yMdZZZZ\", \"en\", \"M/d/y, ZZZZ\" }, { DateFormat.MONTH_DAY + DateFormat.LOCATION_TZ, \"MMMMdVVVV\", \"en\", \"MMMM d, VVVV\" } };\r\n    Date testDate = new Date(2012 - 1900, 6, 1, 14, 58, 59);\r\n    List<String> expectedSkeletons = new ArrayList<String>(DateFormat.DATE_SKELETONS);\r\n    expectedSkeletons.addAll(DateFormat.TIME_SKELETONS);\r\n    expectedSkeletons.addAll(DateFormat.ZONE_SKELETONS);\r\n    boolean combinations = false;\r\n    List<String> testedSkeletons = new ArrayList<String>();\r\n    for (int i = 0; i < EXPECTED.length; i++) {\r\n        if (EXPECTED[i].length == 0) {\r\n            combinations = true;\r\n            continue;\r\n        }\r\n        boolean ok = true;\r\n        String actualPattern = EXPECTED[i][0];\r\n        if (!combinations) {\r\n            testedSkeletons.add(actualPattern);\r\n        }\r\n        String expectedPattern = EXPECTED[i][1];\r\n        ULocale locale = new ULocale(EXPECTED[i][2], \"\", \"\");\r\n        if (!actualPattern.equals(expectedPattern)) {\r\n            errln(\"FAILURE! Expected pattern: \" + expectedPattern + \" but was: \" + actualPattern);\r\n            ok = false;\r\n        }\r\n        DateFormat date1 = DateFormat.getPatternInstance(actualPattern, locale);\r\n        DateFormat date2 = DateFormat.getPatternInstance(Calendar.getInstance(locale), actualPattern, locale);\r\n        String expectedLocalPattern = EXPECTED[i][3];\r\n        String actualLocalPattern1 = ((SimpleDateFormat) date1).toLocalizedPattern();\r\n        String actualLocalPattern2 = ((SimpleDateFormat) date2).toLocalizedPattern();\r\n        if (!actualLocalPattern1.equals(expectedLocalPattern)) {\r\n            errln(\"FAILURE! Expected local pattern: \" + expectedLocalPattern + \" but was: \" + actualLocalPattern1);\r\n            ok = false;\r\n        }\r\n        if (!actualLocalPattern2.equals(expectedLocalPattern)) {\r\n            errln(\"FAILURE! Expected local pattern: \" + expectedLocalPattern + \" but was: \" + actualLocalPattern2);\r\n            ok = false;\r\n        }\r\n        if (ok && isVerbose()) {\r\n            logln(date1.format(testDate) + \"\\t\\t\" + Arrays.asList(EXPECTED[i]));\r\n        }\r\n    }\r\n    assertEquals(\"All skeletons are tested (and in an iterable list)\", new HashSet<String>(expectedSkeletons), new HashSet<String>(testedSkeletons));\r\n    assertEquals(\"All skeletons are tested (and in an iterable list), and in the right order.\", expectedSkeletons, testedSkeletons);\r\n}"
}, {
	"Path": "android.icu.dev.test.util.Trie2Test.checkTrieRanges",
	"Comment": "was testtrieranges in icu4c.renamed to not conflict with icu4j test framework.",
	"Method": "void checkTrieRanges(String testName,String serializedName,boolean withClone,int[][] setRanges,int[][] checkRanges){\r\n    String fileName16 = \"Trie2Test.\" + serializedName + \".16.tri2\";\r\n    String fileName32 = \"Trie2Test.\" + serializedName + \".32.tri2\";\r\n    InputStream is = Trie2Test.class.getResourceAsStream(fileName16);\r\n    Trie2 trie16;\r\n    try {\r\n        trie16 = Trie2.createFromSerialized(ICUBinary.getByteBufferFromInputStreamAndCloseStream(is));\r\n    } finally {\r\n        is.close();\r\n    }\r\n    trieGettersTest(testName, trie16, checkRanges);\r\n    is = Trie2Test.class.getResourceAsStream(fileName32);\r\n    Trie2 trie32;\r\n    try {\r\n        trie32 = Trie2.createFromSerialized(ICUBinary.getByteBufferFromInputStreamAndCloseStream(is));\r\n    } finally {\r\n        is.close();\r\n    }\r\n    trieGettersTest(testName, trie32, checkRanges);\r\n    Trie2Writable trieW = genTrieFromSetRanges(setRanges);\r\n    trieGettersTest(testName, trieW, checkRanges);\r\n    assertEquals(\"\", trieW, trie16);\r\n    assertEquals(\"\", trieW, trie32);\r\n    Trie2_32 trie32a = trieW.toTrie2_32();\r\n    trieGettersTest(testName, trie32a, checkRanges);\r\n    Trie2_16 trie16a = trieW.toTrie2_16();\r\n    trieGettersTest(testName, trie16a, checkRanges);\r\n}"
}, {
	"Path": "java.security.KeyStore.getCertificate",
	"Comment": "returns the certificate associated with the given alias. if the given alias name identifies an entrycreated by a call to setcertificateentry,or created by a call to setentry with atrustedcertificateentry,then the trusted certificate contained in that entry is returned. if the given alias name identifies an entrycreated by a call to setkeyentry,or created by a call to setentry with aprivatekeyentry,then the first element of the certificate chain in that entryis returned.",
	"Method": "Certificate getCertificate(Certificate getCertificate,String alias){\r\n    if (!initialized) {\r\n        throw new KeyStoreException(\"Uninitialized keystore\");\r\n    }\r\n    return keyStoreSpi.engineGetCertificate(alias);\r\n}"
}, {
	"Path": "java.util.concurrent.Phaser.getArrivedParties",
	"Comment": "returns the number of registered parties that have arrived atthe current phase of this phaser. if this phaser has terminated,the returned value is meaningless and arbitrary.",
	"Method": "int getArrivedParties(){\r\n    return arrivedOf(reconcileState());\r\n}"
}, {
	"Path": "okio.TestUtil.reserialize",
	"Comment": "serializes original to bytes, then deserializes those bytes and returns the result.",
	"Method": "T reserialize(T original){\r\n    Buffer buffer = new Buffer();\r\n    ObjectOutputStream out = new ObjectOutputStream(buffer.outputStream());\r\n    out.writeObject(original);\r\n    ObjectInputStream in = new ObjectInputStream(buffer.inputStream());\r\n    return (T) in.readObject();\r\n}"
}, {
	"Path": "android.icu.dev.test.sample.ModuleTestSample.printArray",
	"Comment": "utility print functions to display the data from the resource",
	"Method": "String printArray(String[] a,String printArray,int[] a,String printArray,boolean[] a){\r\n    StringBuffer buf = new StringBuffer(\"boolean[] {\");\r\n    for (int i = 0; i < a.length; ++i) {\r\n        if (i != 0) {\r\n            buf.append(\",\");\r\n        }\r\n        buf.append(\" \" + a[i]);\r\n    }\r\n    buf.append(\" }\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "java.util.WeakHashMap.getEntry",
	"Comment": "returns the entry associated with the specified key in this map.returns null if the map contains no mapping for this key.",
	"Method": "Entry<K, V> getEntry(Object key){\r\n    Object k = maskNull(key);\r\n    int h = sun.misc.Hashing.singleWordWangJenkinsHash(k);\r\n    Entry<K, V>[] tab = getTable();\r\n    int index = indexFor(h, tab.length);\r\n    Entry<K, V> e = tab[index];\r\n    while (e != null && !(e.hash == h && eq(k, e.get()))) e = e.next;\r\n    return e;\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_LocalDate_adjustToHijrahDate",
	"Comment": "test to get the local date by applying the min adjustment with hijrah date",
	"Method": "void test_LocalDate_adjustToHijrahDate(ChronoLocalDate hijrahDate,LocalDate localDate){\r\n    LocalDate test = LocalDate.MIN.with(hijrahDate);\r\n    assertEquals(test, localDate);\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testRemove",
	"Comment": "remove removes next element, or throws nosuchelementexception if empty",
	"Method": "void testRemove(){\r\n    LinkedTransferQueue<Integer> q = populatedQueue(SIZE);\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(i, (int) q.remove());\r\n    }\r\n    try {\r\n        q.remove();\r\n        shouldThrow();\r\n    } catch (NoSuchElementException success) {\r\n    }\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "java.time.format.DateTimeParseContext.isStrict",
	"Comment": "checks if parsing is strict.strict parsing requires exact matching of the text and sign styles.",
	"Method": "boolean isStrict(){\r\n    return strict;\r\n}"
}, {
	"Path": "java.security.SecureRandom.getPrngAlgorithm",
	"Comment": "gets a default prng algorithm by looking through all registeredproviders. returns the first prng algorithm of the first provider thathas registered a securerandom implementation, or null if none of theregistered providers supplies a securerandom implementation.",
	"Method": "String getPrngAlgorithm(){\r\n    for (Provider p : Providers.getProviderList().providers()) {\r\n        for (Service s : p.getServices()) {\r\n            if (s.getType().equals(\"SecureRandom\")) {\r\n                return s.getAlgorithm();\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.security.cert.PKIXParameters.setTargetCertConstraints",
	"Comment": "sets the required constraints on the target certificate.the constraints are specified as an instance ofcertselector. if null, no constraints aredefined.note that the certselector specified is clonedto protect against subsequent modifications.",
	"Method": "void setTargetCertConstraints(CertSelector selector){\r\n    if (selector != null)\r\n        certSelector = (CertSelector) selector.clone();\r\n    else\r\n        certSelector = null;\r\n}"
}, {
	"Path": "java.time.LocalDate.lengthOfMonth",
	"Comment": "returns the length of the month represented by this date.this returns the length of the month in days.for example, a date in january would return 31.",
	"Method": "int lengthOfMonth(){\r\n    switch(month) {\r\n        case 2:\r\n            return (isLeapYear() ? 29 : 28);\r\n        case 4:\r\n        case 6:\r\n        case 9:\r\n        case 11:\r\n            return 30;\r\n        default:\r\n            return 31;\r\n    }\r\n}"
}, {
	"Path": "sun.nio.ch.Net.inet4FromInt",
	"Comment": "returns an inetaddress from the given ipv4 addressrepresented as an int.",
	"Method": "InetAddress inet4FromInt(int address){\r\n    byte[] addr = new byte[4];\r\n    addr[0] = (byte) ((address >>> 24) & 0xFF);\r\n    addr[1] = (byte) ((address >>> 16) & 0xFF);\r\n    addr[2] = (byte) ((address >>> 8) & 0xFF);\r\n    addr[3] = (byte) (address & 0xFF);\r\n    try {\r\n        return InetAddress.getByAddress(addr);\r\n    } catch (UnknownHostException uhe) {\r\n        throw new AssertionError(\"Should not reach here\");\r\n    }\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerTest.testCompareAndSet",
	"Comment": "compareandset succeeds in changing value if equal to expected else fails",
	"Method": "void testCompareAndSet(){\r\n    AtomicInteger ai = new AtomicInteger(1);\r\n    assertTrue(ai.compareAndSet(1, 2));\r\n    assertTrue(ai.compareAndSet(2, -4));\r\n    assertEquals(-4, ai.get());\r\n    assertFalse(ai.compareAndSet(-5, 7));\r\n    assertEquals(-4, ai.get());\r\n    assertTrue(ai.compareAndSet(-4, 7));\r\n    assertEquals(7, ai.get());\r\n}"
}, {
	"Path": "sun.nio.ch.NativeObject.subObject",
	"Comment": "creates a new native object starting at the given offset from the baseof this native object.",
	"Method": "NativeObject subObject(int offset){\r\n    return new NativeObject(offset + address);\r\n}"
}, {
	"Path": "sun.security.x509.X509CRLEntryImpl.getRevocationReason",
	"Comment": "this static method is the default implementation of thegetrevocationreason method in x509crlentry.",
	"Method": "CRLReason getRevocationReason(CRLReason getRevocationReason,X509CRLEntry crlEntry){\r\n    try {\r\n        byte[] ext = crlEntry.getExtensionValue(\"2.5.29.21\");\r\n        if (ext == null) {\r\n            return null;\r\n        }\r\n        DerValue val = new DerValue(ext);\r\n        byte[] data = val.getOctetString();\r\n        CRLReasonCodeExtension rcExt = new CRLReasonCodeExtension(Boolean.FALSE, data);\r\n        return rcExt.getReasonCode();\r\n    } catch (IOException ioe) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinPoolTest.testPollSubmission",
	"Comment": "pollsubmission returns unexecuted submitted task, if present",
	"Method": "void testPollSubmission(){\r\n    final CountDownLatch done = new CountDownLatch(1);\r\n    SubFJP p = new SubFJP();\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        ForkJoinTask a = p.submit(awaiter(done));\r\n        ForkJoinTask b = p.submit(awaiter(done));\r\n        ForkJoinTask c = p.submit(awaiter(done));\r\n        ForkJoinTask r = p.pollSubmission();\r\n        assertTrue(r == a || r == b || r == c);\r\n        assertFalse(r.isDone());\r\n        done.countDown();\r\n    }\r\n}"
}, {
	"Path": "java.time.zone.ZoneOffsetTransition.getOffsetAfter",
	"Comment": "gets the offset after the transition.this is the offset in use on and after the instant of the transition.",
	"Method": "ZoneOffset getOffsetAfter(){\r\n    return offsetAfter;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.PolicyNodeImpl.toString",
	"Comment": "return a printable representation of the policynode.starting at the node on which this method is called,it recurses through the tree and prints out each node.",
	"Method": "String toString(){\r\n    StringBuilder buffer = new StringBuilder(this.asString());\r\n    for (PolicyNodeImpl node : mChildren) {\r\n        buffer.append(node);\r\n    }\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "android.icu.dev.test.rbbi.RBBITestMonkey.moveIndex32",
	"Comment": "move an index into a string by n code points.similar to utf16.movecodepointoffset, but without the exceptions, which werecomplicating usage.",
	"Method": "int moveIndex32(StringBuffer s,int pos,int amt){\r\n    int i;\r\n    char c;\r\n    if (amt > 0) {\r\n        for (i = 0; i < amt; i++) {\r\n            if (pos >= s.length()) {\r\n                return s.length();\r\n            }\r\n            c = s.charAt(pos);\r\n            pos++;\r\n            if (UTF16.isLeadSurrogate(c) && pos < s.length()) {\r\n                c = s.charAt(pos);\r\n                if (UTF16.isTrailSurrogate(c)) {\r\n                    pos++;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        for (i = 0; i > amt; i--) {\r\n            if (pos <= 0) {\r\n                return 0;\r\n            }\r\n            pos--;\r\n            c = s.charAt(pos);\r\n            if (UTF16.isTrailSurrogate(c) && pos >= 0) {\r\n                c = s.charAt(pos);\r\n                if (UTF16.isLeadSurrogate(c)) {\r\n                    pos--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return pos;\r\n}"
}, {
	"Path": "java.text.DecimalFormat.setMaximumIntegerDigits",
	"Comment": "sets the maximum number of digits allowed in the integer portion of anumber.for formatting numbers other than biginteger andbigdecimal objects, the lower of newvalue and309 is used. negative input values are replaced with 0.",
	"Method": "void setMaximumIntegerDigits(int newValue){\r\n    maximumIntegerDigits = Math.min(Math.max(0, newValue), MAXIMUM_INTEGER_DIGITS);\r\n    super.setMaximumIntegerDigits((maximumIntegerDigits > DOUBLE_INTEGER_DIGITS) ? DOUBLE_INTEGER_DIGITS : maximumIntegerDigits);\r\n    if (minimumIntegerDigits > maximumIntegerDigits) {\r\n        minimumIntegerDigits = maximumIntegerDigits;\r\n        super.setMinimumIntegerDigits((minimumIntegerDigits > DOUBLE_INTEGER_DIGITS) ? DOUBLE_INTEGER_DIGITS : minimumIntegerDigits);\r\n    }\r\n    fastPathCheckNeeded = true;\r\n}"
}, {
	"Path": "java.time.format.DecimalStyle.getNegativeSign",
	"Comment": "gets the character that represents the negative sign.the character used to represent a negative number may vary by culture.this method specifies the character to use.",
	"Method": "char getNegativeSign(){\r\n    return negativeSign;\r\n}"
}, {
	"Path": "libcore.java.util.zip.ZipOutputStreamTest.testNullComment",
	"Comment": "regression test for null comment causing a nullpointerexception during write.",
	"Method": "void testNullComment(){\r\n    ZipOutputStream out = new ZipOutputStream(new ByteArrayOutputStream());\r\n    out.setComment(null);\r\n    out.putNextEntry(new ZipEntry(\"name\"));\r\n    out.write(new byte[1]);\r\n    out.closeEntry();\r\n    out.finish();\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.lang.reflect.WildcardTypeTest.testBoundedGenericMethods",
	"Comment": "tests that there are is one type parameter on the class itself.",
	"Method": "void testBoundedGenericMethods(){\r\n    assertLenghtOne(clazz.getTypeParameters());\r\n}"
}, {
	"Path": "libcore.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return new SSLSocketFactory() {\r\n        private SSLSocket set(Socket socket) {\r\n            SSLSocket s = (SSLSocket) socket;\r\n            s.setWantClientAuth(want);\r\n            s.setNeedClientAuth(need);\r\n            return s;\r\n        }\r\n        public Socket createSocket(String host, int port) throws IOException, UnknownHostException {\r\n            return set(sf.createSocket(host, port));\r\n        }\r\n        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {\r\n            return set(sf.createSocket(host, port, localHost, localPort));\r\n        }\r\n        public Socket createSocket(InetAddress host, int port) throws IOException {\r\n            return set(sf.createSocket(host, port));\r\n        }\r\n        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\r\n            return set(sf.createSocket(address, port));\r\n        }\r\n        public String[] getDefaultCipherSuites() {\r\n            return sf.getDefaultCipherSuites();\r\n        }\r\n        public String[] getSupportedCipherSuites() {\r\n            return sf.getSupportedCipherSuites();\r\n        }\r\n        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {\r\n            return set(sf.createSocket(s, host, port, autoClose));\r\n        }\r\n    };\r\n}"
}, {
	"Path": "libcore.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    SSLSocket s = (SSLSocket) socket;\r\n    s.setWantClientAuth(want);\r\n    s.setNeedClientAuth(need);\r\n    return s;\r\n}"
}, {
	"Path": "libcore.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return set(sf.createSocket(host, port));\r\n}"
}, {
	"Path": "libcore.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return set(sf.createSocket(host, port, localHost, localPort));\r\n}"
}, {
	"Path": "libcore.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return set(sf.createSocket(host, port));\r\n}"
}, {
	"Path": "libcore.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return set(sf.createSocket(address, port));\r\n}"
}, {
	"Path": "libcore.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return sf.getDefaultCipherSuites();\r\n}"
}, {
	"Path": "libcore.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return sf.getSupportedCipherSuites();\r\n}"
}, {
	"Path": "libcore.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return set(sf.createSocket(s, host, port, autoClose));\r\n}"
}, {
	"Path": "org.apache.harmony.tests.org.xml.sax.support.MethodLogger.getArgs",
	"Comment": "returns the argument array of the last method that was invoked. returnsnull if no method has been invoked so far.",
	"Method": "Object[] getArgs(int index,Object[] getArgs){\r\n    return (size() == 0 ? null : getArgs(size() - 1));\r\n}"
}, {
	"Path": "android.icu.dev.test.format.PluralRulesTest.TestGetAllKeywordValues",
	"Comment": "returns the empty set if the keyword is not defined, null if there are an unlimited number of values for thekeyword, or the set of values that trigger the keyword.",
	"Method": "void TestGetAllKeywordValues(){\r\n    String[] data = { // ignore 'other' here on out, always null\r\n    \"other: ; a: n mod 3 is 0\", // ignore 'other' here on out, always null\r\n    \"a: null\", // ignore 'other' here on out, always null\r\n    \"a: n in 2..5 and n within 5..8\", // ignore 'other' here on out, always null\r\n    \"a: 5\", // ignore 'other' here on out, always null\r\n    \"a: n in 2..5\", // ignore 'other' here on out, always null\r\n    \"a: 2,3,4,5; other: null\", // ignore 'other' here on out, always null\r\n    \"a: n not in 2..5\", // ignore 'other' here on out, always null\r\n    \"a: null; other: null\", // ignore 'other' here on out, always null\r\n    \"a: n within 2..5\", // ignore 'other' here on out, always null\r\n    \"a: 2,3,4,5; other: null\", // ignore 'other' here on out, always null\r\n    \"a: n not within 2..5\", // ignore 'other' here on out, always null\r\n    \"a: null; other: null\", \"a: n in 2..5 or n within 6..8\", // \"a: n mod 3 is 0 and n within 0..5\", \"a: 0,3\",\r\n    \"a: 2,3,4,5,6,7,8\", // \"a: n mod 3 is 0 and n within 0..5\", \"a: 0,3\",\r\n    \"a: n in 2..5 and n within 6..8\", \"a: null\", \"a: n within 1..2 and n within 2..3 or n within 3..4 and n within 4..5 or n within 5..6 and n within 6..7\", \"a: 2,4,6\", \"a: n mod 3 is 0 and n within 1..2\", \"a: null\", \"a: n mod 3 is 0 and n within 0..6\", \"a: 0,3,6\", \"a: n mod 3 is 0 and n in 3..12\", \"a: 3,6,9,12\", \"a: n in 2,4..6 and n is not 5\", \"a: 2,4,6\" };\r\n    for (int i = 0; i < data.length; i += 2) {\r\n        String ruleDescription = data[i];\r\n        String result = data[i + 1];\r\n        PluralRules p = PluralRules.createRules(ruleDescription);\r\n        if (p == null) {\r\n            PluralRules.createRules(ruleDescription);\r\n        }\r\n        for (String ruleResult : result.split(\";\")) {\r\n            String[] ruleAndValues = ruleResult.split(\":\");\r\n            String keyword = ruleAndValues[0].trim();\r\n            String valueList = ruleAndValues.length < 2 ? null : ruleAndValues[1];\r\n            if (valueList != null) {\r\n                valueList = valueList.trim();\r\n            }\r\n            Collection<Double> values;\r\n            if (valueList == null || valueList.length() == 0) {\r\n                values = Collections.EMPTY_SET;\r\n            } else if (\"null\".equals(valueList)) {\r\n                values = null;\r\n            } else {\r\n                values = new TreeSet<Double>();\r\n                for (String value : valueList.split(\",\")) {\r\n                    values.add(Double.parseDouble(value));\r\n                }\r\n            }\r\n            Collection<Double> results = p.getAllKeywordValues(keyword);\r\n            assertEquals(keyword + \" in \" + ruleDescription, values, results == null ? null : new HashSet(results));\r\n            if (results != null) {\r\n                try {\r\n                    results.add(PluralRules.NO_UNIQUE_VALUE);\r\n                    fail(\"returned set is modifiable\");\r\n                } catch (UnsupportedOperationException e) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.time.format.DecimalStyle.convertNumberToI18N",
	"Comment": "converts the input numeric text to the internationalized form using the zero character.",
	"Method": "String convertNumberToI18N(String numericText){\r\n    if (zeroDigit == '0') {\r\n        return numericText;\r\n    }\r\n    int diff = zeroDigit - '0';\r\n    char[] array = numericText.toCharArray();\r\n    for (int i = 0; i < array.length; i++) {\r\n        array[i] = (char) (array[i] + diff);\r\n    }\r\n    return new String(array);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testPeekNextLocalTaskAsync",
	"Comment": "peeknextlocaltask returns least recent unexecuted task in async mode",
	"Method": "void testPeekNextLocalTaskAsync(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            CCF g = new LCCF(9);\r\n            assertSame(g, g.fork());\r\n            CCF f = new LCCF(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, peekNextLocalTask());\r\n            assertNull(f.join());\r\n            helpQuiesce();\r\n            checkCompletedNormally(f);\r\n            assertEquals(34, g.number);\r\n            checkCompletedNormally(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(asyncSingletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testPeekNextLocalTaskAsync",
	"Comment": "peeknextlocaltask returns least recent unexecuted task in async mode",
	"Method": "void testPeekNextLocalTaskAsync(){\r\n    CCF g = new LCCF(9);\r\n    assertSame(g, g.fork());\r\n    CCF f = new LCCF(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, peekNextLocalTask());\r\n    assertNull(f.join());\r\n    helpQuiesce();\r\n    checkCompletedNormally(f);\r\n    assertEquals(34, g.number);\r\n    checkCompletedNormally(g);\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.setPolicy",
	"Comment": "sets the policy constraint. the x509certificate mustinclude at least one of the specified policies in its certificatepolicies extension. if certpolicyset is empty, then thex509certificate must include at least some specified policyin its certificate policies extension. if certpolicyset isnull, no policy check will be performed.note that the set is cloned to protect againstsubsequent modifications.",
	"Method": "void setPolicy(Set<String> certPolicySet){\r\n    if (certPolicySet == null) {\r\n        policySet = null;\r\n        policy = null;\r\n    } else {\r\n        Set<String> tempSet = Collections.unmodifiableSet(new HashSet<String>(certPolicySet));\r\n        Iterator<String> i = tempSet.iterator();\r\n        Vector<CertificatePolicyId> polIdVector = new Vector<CertificatePolicyId>();\r\n        while (i.hasNext()) {\r\n            Object o = i.next();\r\n            if (!(o instanceof String)) {\r\n                throw new IOException(\"non String in certPolicySet\");\r\n            }\r\n            polIdVector.add(new CertificatePolicyId(new ObjectIdentifier((String) o)));\r\n        }\r\n        policySet = tempSet;\r\n        policy = new CertificatePolicySet(polIdVector);\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getCertificate",
	"Comment": "returns the certificateequals criterion. the specifiedx509certificate must be equal to thex509certificate passed to the match method.if null, this check is not applied.",
	"Method": "X509Certificate getCertificate(){\r\n    return x509Cert;\r\n}"
}, {
	"Path": "java.beans.StandardBeanInfo.introspectEvents",
	"Comment": "introspects the supplied bean class and returns a list of the events ofthe class",
	"Method": "EventSetDescriptor[] introspectEvents(){\r\n    MethodDescriptor[] theMethods = introspectMethods();\r\n    if (theMethods == null)\r\n        return null;\r\n    HashMap<String, HashMap> eventTable = new HashMap<String, HashMap>(theMethods.length);\r\n    for (int i = 0; i < theMethods.length; i++) {\r\n        introspectListenerMethods(PREFIX_ADD, theMethods[i].getMethod(), eventTable);\r\n        introspectListenerMethods(PREFIX_REMOVE, theMethods[i].getMethod(), eventTable);\r\n        introspectGetListenerMethods(theMethods[i].getMethod(), eventTable);\r\n    }\r\n    ArrayList<EventSetDescriptor> eventList = new ArrayList<EventSetDescriptor>();\r\n    for (Map.Entry<String, HashMap> entry : eventTable.entrySet()) {\r\n        HashMap table = entry.getValue();\r\n        Method add = (Method) table.get(PREFIX_ADD);\r\n        Method remove = (Method) table.get(PREFIX_REMOVE);\r\n        if ((add == null) || (remove == null)) {\r\n            continue;\r\n        }\r\n        Method get = (Method) table.get(PREFIX_GET);\r\n        Class<?> listenerType = (Class) table.get(\"listenerType\");\r\n        Method[] listenerMethods = (Method[]) table.get(\"listenerMethods\");\r\n        EventSetDescriptor eventSetDescriptor = new EventSetDescriptor(decapitalize(entry.getKey()), listenerType, listenerMethods, add, remove, get);\r\n        eventSetDescriptor.setUnicast(table.get(\"isUnicast\") != null);\r\n        eventList.add(eventSetDescriptor);\r\n    }\r\n    EventSetDescriptor[] theEvents = new EventSetDescriptor[eventList.size()];\r\n    eventList.toArray(theEvents);\r\n    return theEvents;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.IndexedCollectionCertStore.engineGetCRLs",
	"Comment": "returns a collection of crls thatmatch the specified selector. if no crlsmatch the selector, an empty collection will be returned.",
	"Method": "Collection<CRL> engineGetCRLs(CRLSelector selector){\r\n    if (selector == null) {\r\n        Set<CRL> matches = new HashSet();\r\n        matchX509CRLs(new X509CRLSelector(), matches);\r\n        matches.addAll(otherCRLs);\r\n        return matches;\r\n    }\r\n    if (selector instanceof X509CRLSelector == false) {\r\n        Set<CRL> matches = new HashSet();\r\n        matchX509CRLs(selector, matches);\r\n        for (CRL crl : otherCRLs) {\r\n            if (selector.match(crl)) {\r\n                matches.add(crl);\r\n            }\r\n        }\r\n        return matches;\r\n    }\r\n    if (crlIssuers.isEmpty()) {\r\n        return Collections.<CRL>emptySet();\r\n    }\r\n    X509CRLSelector x509Selector = (X509CRLSelector) selector;\r\n    Collection<X500Principal> issuers = x509Selector.getIssuers();\r\n    if (issuers != null) {\r\n        HashSet<CRL> matches = new HashSet(16);\r\n        for (X500Principal issuer : issuers) {\r\n            Object entry = crlIssuers.get(issuer);\r\n            if (entry == null) {\r\n            } else if (entry instanceof X509CRL) {\r\n                X509CRL crl = (X509CRL) entry;\r\n                if (x509Selector.match(crl)) {\r\n                    matches.add(crl);\r\n                }\r\n            } else {\r\n                @SuppressWarnings(\"unchecked\")\r\n                List<X509CRL> list = (List<X509CRL>) entry;\r\n                for (X509CRL crl : list) {\r\n                    if (x509Selector.match(crl)) {\r\n                        matches.add(crl);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return matches;\r\n    }\r\n    Set<CRL> matches = new HashSet(16);\r\n    matchX509CRLs(x509Selector, matches);\r\n    return matches;\r\n}"
}, {
	"Path": "javax.xml.datatype.FactoryFinder.findClassLoader",
	"Comment": "find the appropriate classloader to use.the context classloader is preferred.",
	"Method": "ClassLoader findClassLoader(){\r\n    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\r\n    if (debug)\r\n        debugPrintln(\"Using context class loader: \" + classLoader);\r\n    if (classLoader == null) {\r\n        classLoader = FactoryFinder.class.getClassLoader();\r\n        if (debug)\r\n            debugPrintln(\"Using the class loader of FactoryFinder: \" + classLoader);\r\n    }\r\n    return classLoader;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.OCSPResponse.initializeClockSkew",
	"Comment": "initialize the maximum allowable clock skew by getting the ocspclock skew system property. if the property has not been set, or if itsvalue is negative, set the skew to the default.",
	"Method": "int initializeClockSkew(){\r\n    Integer tmp = Integer.getInteger(\"com.sun.security.ocsp.clockSkew\");\r\n    if (tmp == null || tmp < 0) {\r\n        return DEFAULT_MAX_CLOCK_SKEW;\r\n    }\r\n    return tmp * 1000;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.FunctionizerTest.testOuterCall",
	"Comment": "verify that a call to a private method in an outer class is converted correctly.",
	"Method": "void testOuterCall(){\r\n    String translation = translateSourceFile(\"class A { int outerN = str(); private int str() { return 0; }\" + \"  class B { \" + \"    private int test1() { return str(); } \" + \"    private int test2() { return A.this.str(); }\" + \"    private int test3() { return A.this.outerN; }}}\", \"A\", \"A.m\");\r\n    assertTranslatedLines(translation, \"int A_str(A *self) {\", \"return 0;\");\r\n    assertTranslatedLines(translation, \"jint A_B_test1(A_B *self) {\", \"return A_str(self->this$0_);\");\r\n    assertTranslatedLines(translation, \"jint A_B_test2(A_B *self) {\", \"return A_str(self->this$0_);\");\r\n    assertTranslatedLines(translation, \"jint A_B_test3(A_B *self) {\", \"return self->this$0_->outerN_;\");\r\n}"
}, {
	"Path": "java.util.concurrent.FutureTask.runAndReset",
	"Comment": "executes the computation without setting its result, and thenresets this future to initial state, failing to do so if thecomputation encounters an exception or is cancelled.this isdesigned for use with tasks that intrinsically execute morethan once.",
	"Method": "boolean runAndReset(){\r\n    if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))\r\n        return false;\r\n    boolean ran = false;\r\n    int s = state;\r\n    try {\r\n        Callable<V> c = callable;\r\n        if (c != null && s == NEW) {\r\n            try {\r\n                c.call();\r\n                ran = true;\r\n            } catch (Throwable ex) {\r\n                setException(ex);\r\n            }\r\n        }\r\n    } finally {\r\n        runner = null;\r\n        s = state;\r\n        if (s >= INTERRUPTING)\r\n            handlePossibleCancellationInterrupt(s);\r\n    }\r\n    return ran && s == NEW;\r\n}"
}, {
	"Path": "javax.net.ssl.SSLParameters.getUseCipherSuitesOrder",
	"Comment": "returns whether the local cipher suites preference should be honored.",
	"Method": "boolean getUseCipherSuitesOrder(){\r\n    return preferLocalCipherSuites;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.KeyChecker.check",
	"Comment": "checks that keyusage and target constraints are satisfied bythe specified certificate.",
	"Method": "void check(Certificate cert,Collection<String> unresCritExts){\r\n    X509Certificate currCert = (X509Certificate) cert;\r\n    remainingCerts--;\r\n    if (remainingCerts == 0) {\r\n        if (targetConstraints != null && targetConstraints.match(currCert) == false) {\r\n            throw new CertPathValidatorException(\"target certificate \" + \"constraints check failed\");\r\n        }\r\n    } else {\r\n        verifyCAKeyUsage(currCert);\r\n    }\r\n    if (unresCritExts != null && !unresCritExts.isEmpty()) {\r\n        unresCritExts.remove(KeyUsage_Id.toString());\r\n        unresCritExts.remove(ExtendedKeyUsage_Id.toString());\r\n        unresCritExts.remove(SubjectAlternativeName_Id.toString());\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.translit.TransliteratorTest.TestCompoundKana",
	"Comment": "compose the kana transliterator forward and reverse and trysome strings that should come out unchanged.",
	"Method": "void TestCompoundKana(){\r\n    Transliterator t = Transliterator.getInstance(\"Latin-Katakana;Katakana-Latin\");\r\n    expect(t, \"aaaaa\", \"aaaaa\");\r\n}"
}, {
	"Path": "java.security.DigestOutputStream.toString",
	"Comment": "prints a string representation of this digest output stream andits associated message digest object.",
	"Method": "String toString(){\r\n    return \"[Digest Output Stream] \" + digest.toString();\r\n}"
}, {
	"Path": "java.util.Date.setSeconds",
	"Comment": "sets the seconds of this date to the specified value.this date object is modified so that it represents apoint in time within the specified second of the minute, withthe year, month, date, hour, and minute the same as before, asinterpreted in the local time zone.",
	"Method": "void setSeconds(int seconds){\r\n    getCalendarDate().setSeconds(seconds);\r\n}"
}, {
	"Path": "java.security.Security.getProvider",
	"Comment": "returns the provider installed with the specified name, ifany. returns null if no provider with the specified name isinstalled or if name is null.",
	"Method": "Provider getProvider(String name){\r\n    return Providers.getProviderList().getProvider(name);\r\n}"
}, {
	"Path": "java.util.logging.Formatter.getTail",
	"Comment": "return the tail string for a set of formatted records.this base class returns an empty string, but this may beoverridden by subclasses.",
	"Method": "String getTail(Handler h){\r\n    return \"\";\r\n}"
}, {
	"Path": "sun.security.x509.X500Name.avaSize",
	"Comment": "return the total number of avas contained in all the rdns ofthis x500name.",
	"Method": "int avaSize(){\r\n    return allAvas().size();\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceArrayTest.testCompareAndSet",
	"Comment": "compareandset succeeds in changing value if equal to expected else fails",
	"Method": "void testCompareAndSet(){\r\n    AtomicReferenceArray aa = new AtomicReferenceArray(SIZE);\r\n    for (int i = 0; i < SIZE; i++) {\r\n        aa.set(i, one);\r\n        assertTrue(aa.compareAndSet(i, one, two));\r\n        assertTrue(aa.compareAndSet(i, two, m4));\r\n        assertSame(m4, aa.get(i));\r\n        assertFalse(aa.compareAndSet(i, m5, seven));\r\n        assertSame(m4, aa.get(i));\r\n        assertTrue(aa.compareAndSet(i, m4, seven));\r\n        assertSame(seven, aa.get(i));\r\n    }\r\n}"
}, {
	"Path": "java.io.PrintStream.requireNonNull",
	"Comment": "requirenonnull is explicitly declared here so as not to create an extradependency on java.util.objects.requirenonnull. printstream is loadedearly during system initialization.",
	"Method": "T requireNonNull(T obj,String message){\r\n    if (obj == null)\r\n        throw new NullPointerException(message);\r\n    return obj;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testFailingThreadFactory",
	"Comment": "execution continues if there is at least one thread even ifthread factory fails to create more",
	"Method": "void testFailingThreadFactory(){\r\n    final ExecutorService e = new CustomTPE(100, 100, LONG_DELAY_MS, MILLISECONDS, new LinkedBlockingQueue<Runnable>(), new FailingThreadFactory());\r\n    try (PoolCleaner cleaner = cleaner(e)) {\r\n        final int TASKS = 100;\r\n        final CountDownLatch done = new CountDownLatch(TASKS);\r\n        for (int k = 0; k < TASKS; ++k) e.execute(new CheckedRunnable() {\r\n            public void realRun() {\r\n                done.countDown();\r\n            }\r\n        });\r\n        assertTrue(done.await(LONG_DELAY_MS, MILLISECONDS));\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testFailingThreadFactory",
	"Comment": "execution continues if there is at least one thread even ifthread factory fails to create more",
	"Method": "void testFailingThreadFactory(){\r\n    done.countDown();\r\n}"
}, {
	"Path": "java.util.Hashtable.put",
	"Comment": "maps the specified key to the specifiedvalue in this hashtable. neither the key nor thevalue can be null. the value can be retrieved by calling the get methodwith a key that is equal to the original key.",
	"Method": "V put(K key,V value){\r\n    if (value == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    HashtableEntry[] tab = table;\r\n    int hash = hash(key);\r\n    int index = (hash & 0x7FFFFFFF) % tab.length;\r\n    for (HashtableEntry<K, V> e = tab[index]; e != null; e = e.next) {\r\n        if ((e.hash == hash) && e.key.equals(key)) {\r\n            V old = e.value;\r\n            e.value = value;\r\n            return old;\r\n        }\r\n    }\r\n    modCount++;\r\n    if (count >= threshold) {\r\n        rehash();\r\n        tab = table;\r\n        hash = hash(key);\r\n        index = (hash & 0x7FFFFFFF) % tab.length;\r\n    }\r\n    HashtableEntry<K, V> e = tab[index];\r\n    tab[index] = new HashtableEntry(hash, key, value, e);\r\n    count++;\r\n    return null;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testSetRejectedExecutionHandler",
	"Comment": "setrejectedexecutionhandler sets the handler returned bygetrejectedexecutionhandler",
	"Method": "void testSetRejectedExecutionHandler(){\r\n    final ThreadPoolExecutor p = new CustomTPE(1, 2, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        RejectedExecutionHandler handler = new NoOpREHandler();\r\n        p.setRejectedExecutionHandler(handler);\r\n        assertSame(handler, p.getRejectedExecutionHandler());\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testFloatValuePosRounded1",
	"Comment": "convert a positive number to a float value. rounding is needed.the rounding bit is 1 and the next bit to the left is 1.",
	"Method": "void testFloatValuePosRounded1(){\r\n    byte[] a = { -128, 1, -1, -4, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = 1;\r\n    float result = 1.5475195E26f;\r\n    float aNumber = new BigInteger(aSign, a).floatValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testFloatValuePosRounded2",
	"Comment": "convert a positive number to a float value. rounding is needed.the rounding bit is 1 and the next bit to the left is 0but some of dropped bits are 1s.",
	"Method": "void testFloatValuePosRounded2(){\r\n    byte[] a = { -128, 1, 2, -128, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = 1;\r\n    float result = 1.5474728E26f;\r\n    float aNumber = new BigInteger(aSign, a).floatValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.tableSizeFor",
	"Comment": "returns a power of two table size for the given desired capacity.see hackers delight, sec 3.2",
	"Method": "int tableSizeFor(int c){\r\n    int n = c - 1;\r\n    n |= n >>> 1;\r\n    n |= n >>> 2;\r\n    n |= n >>> 4;\r\n    n |= n >>> 8;\r\n    n |= n >>> 16;\r\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\r\n}"
}, {
	"Path": "java.util.jar.Attributes.get",
	"Comment": "returns the value of the specified attribute name, or null if theattribute name was not found.",
	"Method": "Object get(Object name){\r\n    return map.get(name);\r\n}"
}, {
	"Path": "sun.security.x509.CertificateValidity.encode",
	"Comment": "encode the certificatevalidity period in der form to the stream.",
	"Method": "void encode(OutputStream out){\r\n    if (notBefore == null || notAfter == null) {\r\n        throw new IOException(\"CertAttrSet:CertificateValidity:\" + \" null values to encode.\\n\");\r\n    }\r\n    DerOutputStream pair = new DerOutputStream();\r\n    if (notBefore.getTime() < YR_2050) {\r\n        pair.putUTCTime(notBefore);\r\n    } else\r\n        pair.putGeneralizedTime(notBefore);\r\n    if (notAfter.getTime() < YR_2050) {\r\n        pair.putUTCTime(notAfter);\r\n    } else {\r\n        pair.putGeneralizedTime(notAfter);\r\n    }\r\n    DerOutputStream seq = new DerOutputStream();\r\n    seq.write(DerValue.tag_Sequence, pair);\r\n    out.write(seq.toByteArray());\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testSignal_IMSE",
	"Comment": "calling signal without holding sync throws illegalmonitorstateexception",
	"Method": "void testSignal_IMSE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    try {\r\n        c.signal();\r\n        shouldThrow();\r\n    } catch (IllegalMonitorStateException success) {\r\n    }\r\n    assertHasWaitersUnlocked(sync, c, NO_THREADS);\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testConstructor3",
	"Comment": "initializing from null collection throws nullpointerexception",
	"Method": "void testConstructor3(){\r\n    try {\r\n        new LinkedBlockingDeque(null);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testConstructor2",
	"Comment": "constructor throws illegalargumentexception if capacity argument nonpositive",
	"Method": "void testConstructor2(){\r\n    try {\r\n        new LinkedBlockingDeque(0);\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.AnnotationRewriter.addMemberProperties",
	"Comment": "generate the property declarations and synthesize statements.",
	"Method": "void addMemberProperties(AnnotationTypeDeclaration node,List<AnnotationTypeMemberDeclaration> members,Map<ExecutableElement, VariableElement> fieldElements){\r\n    if (members.isEmpty()) {\r\n        return;\r\n    }\r\n    StringBuilder propertyDecls = new StringBuilder();\r\n    StringBuilder propertyImpls = new StringBuilder();\r\n    for (AnnotationTypeMemberDeclaration member : members) {\r\n        ExecutableElement memberElement = member.getExecutableElement();\r\n        String propName = NameTable.getAnnotationPropertyName(memberElement);\r\n        String memberTypeStr = nameTable.getObjCType(memberElement.getReturnType());\r\n        String fieldName = nameTable.getVariableShortName(fieldElements.get(memberElement));\r\n        propertyDecls.append(UnicodeUtils.format(\"@property (readonly) %s%s%s;\\n\", memberTypeStr, memberTypeStr.endsWith(\"*\") ? \"\" : \" \", propName));\r\n        if (NameTable.needsObjcMethodFamilyNoneAttribute(propName)) {\r\n            propertyDecls.append(UnicodeUtils.format(\"- (%s)%s OBJC_METHOD_FAMILY_NONE;\\n\", memberTypeStr, propName));\r\n        }\r\n        propertyImpls.append(UnicodeUtils.format(\"@synthesize %s = %s;\\n\", propName, fieldName));\r\n    }\r\n    node.addBodyDeclaration(NativeDeclaration.newInnerDeclaration(propertyDecls.toString(), propertyImpls.toString()));\r\n}"
}, {
	"Path": "java.util.HashMap.put",
	"Comment": "associates the specified value with the specified key in this map.if the map previously contained a mapping for the key, the oldvalue is replaced.",
	"Method": "V put(K key,V value){\r\n    if (table == EMPTY_TABLE) {\r\n        inflateTable(threshold);\r\n    }\r\n    if (key == null)\r\n        return putForNullKey(value);\r\n    int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key);\r\n    int i = indexFor(hash, table.length);\r\n    for (HashMapEntry<K, V> e = table[i]; e != null; e = e.next) {\r\n        Object k;\r\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\r\n            V oldValue = e.value;\r\n            e.value = value;\r\n            e.recordAccess(this);\r\n            return oldValue;\r\n        }\r\n    }\r\n    modCount++;\r\n    addEntry(hash, key, value, i);\r\n    return null;\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testConstructor6",
	"Comment": "deque contains all elements of collection used to initialize",
	"Method": "void testConstructor6(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = i;\r\n    LinkedBlockingDeque q = new LinkedBlockingDeque(Arrays.asList(ints));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.TypeImplementationGeneratorTest.staticFieldAccessorMethodValidation",
	"Comment": "verify that accessor methods for static vars and constants are generated on request.",
	"Method": "void staticFieldAccessorMethodValidation(){\r\n    String source = \"class Test { \" + \"static String ID; \" + \"private static int i; \" + \"public static final int VERSION = 1; \" + \"static final Test DEFAULT = new Test(); }\";\r\n    String translation = translateSourceFile(source, \"Test\", \"Test.m\");\r\n    assertTranslatedLines(translation, \"+ (NSString *)ID {\", \"return Test_ID;\");\r\n    assertTranslatedLines(translation, \"+ (void)setID:(NSString *)value {\", \"JreStrongAssign(&Test_ID, value);\");\r\n    assertTranslatedLines(translation, \"+ (jint)VERSION {\", \"return Test_VERSION;\");\r\n    assertTranslatedLines(translation, \"+ (Test *)DEFAULT {\", \"return Test_DEFAULT;\");\r\n    assertNotInTranslation(translation, \"+ (void)setDEFAULT:(Test *)value\");\r\n    assertNotInTranslation(translation, \"+ (jint)i\");\r\n    assertNotInTranslation(translation, \"+ (void)setI:(jint)value\");\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testConstructor5",
	"Comment": "initializing from collection with some null elements throwsnullpointerexception",
	"Method": "void testConstructor5(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = i;\r\n    Collection<Integer> elements = Arrays.asList(ints);\r\n    try {\r\n        new LinkedBlockingDeque(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testConstructor4",
	"Comment": "initializing from collection of null elements throws nullpointerexception",
	"Method": "void testConstructor4(){\r\n    Collection<Integer> elements = Arrays.asList(new Integer[SIZE]);\r\n    try {\r\n        new LinkedBlockingDeque(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.util.HashMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this map.these mappings will replace any mappings that this map had forany of the keys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> m){\r\n    int numKeysToBeAdded = m.size();\r\n    if (numKeysToBeAdded == 0)\r\n        return;\r\n    if (table == EMPTY_TABLE) {\r\n        inflateTable((int) Math.max(numKeysToBeAdded * loadFactor, threshold));\r\n    }\r\n    if (numKeysToBeAdded > threshold) {\r\n        int targetCapacity = (int) (numKeysToBeAdded / loadFactor + 1);\r\n        if (targetCapacity > MAXIMUM_CAPACITY)\r\n            targetCapacity = MAXIMUM_CAPACITY;\r\n        int newCapacity = table.length;\r\n        while (newCapacity < targetCapacity) newCapacity <<= 1;\r\n        if (newCapacity > table.length)\r\n            resize(newCapacity);\r\n    }\r\n    for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) put(e.getKey(), e.getValue());\r\n}"
}, {
	"Path": "java.util.TimSort.gallopRight",
	"Comment": "like gallopleft, except that if the range contains an element equal tokey, gallopright returns the index after the rightmost equal element.",
	"Method": "int gallopRight(T key,T[] a,int base,int len,int hint,Comparator<? super T> c){\r\n    assert len > 0 && hint >= 0 && hint < len;\r\n    int ofs = 1;\r\n    int lastOfs = 0;\r\n    if (c.compare(key, a[base + hint]) < 0) {\r\n        int maxOfs = hint + 1;\r\n        while (ofs < maxOfs && c.compare(key, a[base + hint - ofs]) < 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        int tmp = lastOfs;\r\n        lastOfs = hint - ofs;\r\n        ofs = hint - tmp;\r\n    } else {\r\n        int maxOfs = len - hint;\r\n        while (ofs < maxOfs && c.compare(key, a[base + hint + ofs]) >= 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        lastOfs += hint;\r\n        ofs += hint;\r\n    }\r\n    assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;\r\n    lastOfs++;\r\n    while (lastOfs < ofs) {\r\n        int m = lastOfs + ((ofs - lastOfs) >>> 1);\r\n        if (c.compare(key, a[base + m]) < 0)\r\n            ofs = m;\r\n        else\r\n            lastOfs = m + 1;\r\n    }\r\n    assert lastOfs == ofs;\r\n    return ofs;\r\n}"
}, {
	"Path": "java.net.InetAddress.isLinkLocalAddress",
	"Comment": "utility routine to check if the inetaddress is an link local address.",
	"Method": "boolean isLinkLocalAddress(){\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testAddAll",
	"Comment": "addall adds each element from the given collection, including duplicates",
	"Method": "void testAddAll(){\r\n    CopyOnWriteArrayList full = populatedArray(3);\r\n    assertTrue(full.addAll(Arrays.asList(three, four, five)));\r\n    assertEquals(6, full.size());\r\n    assertTrue(full.addAll(Arrays.asList(three, four, five)));\r\n    assertEquals(9, full.size());\r\n}"
}, {
	"Path": "sun.security.provider.certpath.PolicyChecker.mergeInhibitAnyPolicy",
	"Comment": "merges the specified inhibitanypolicy value with theskipcerts value of the inhibitanypolicyextension obtained from the certificate.",
	"Method": "int mergeInhibitAnyPolicy(int inhibitAnyPolicy,X509CertImpl currCert){\r\n    if ((inhibitAnyPolicy > 0) && !X509CertImpl.isSelfIssued(currCert)) {\r\n        inhibitAnyPolicy--;\r\n    }\r\n    try {\r\n        InhibitAnyPolicyExtension inhAnyPolExt = (InhibitAnyPolicyExtension) currCert.getExtension(InhibitAnyPolicy_Id);\r\n        if (inhAnyPolExt == null)\r\n            return inhibitAnyPolicy;\r\n        int skipCerts = inhAnyPolExt.get(InhibitAnyPolicyExtension.SKIP_CERTS).intValue();\r\n        if (debug != null)\r\n            debug.println(\"PolicyChecker.mergeInhibitAnyPolicy() \" + \"skipCerts Index from cert = \" + skipCerts);\r\n        if (skipCerts != -1) {\r\n            if (skipCerts < inhibitAnyPolicy) {\r\n                inhibitAnyPolicy = skipCerts;\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        if (debug != null) {\r\n            debug.println(\"PolicyChecker.mergeInhibitAnyPolicy \" + \"unexpected exception\");\r\n            e.printStackTrace();\r\n        }\r\n        throw new CertPathValidatorException(e);\r\n    }\r\n    return inhibitAnyPolicy;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.testGenericArrayCreation",
	"Comment": "creation of generic array creation with unbounded wildcard type arguments",
	"Method": "void testGenericArrayCreation(){\r\n    this.runConformTest(new String[] { \"X.java\", \"interface I {\\n\" + \" X<?, ?, ?>[] makeArray(int i);\\n\" + \"}\\n\" + \"public class X<T, U, V> {\\n\" + \" public static void main(String [] args) {\\n\" + \"   I i = X<?, ?, ?>[]::new; // OK.\\n\" + \"   System.out.println(i.makeArray(1024).length);\\n\" + \" }\\n\" + \"}\\n\" + \"\" }, \"1024\");\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.DeadCodeEliminator.removeDeadClasses",
	"Comment": "remove empty classes marked as dead. this needs to be done after translationto avoid inner class references in the ast returned by deadcodeeliminator.",
	"Method": "void removeDeadClasses(CompilationUnit unit,CodeReferenceMap deadCodeMap){\r\n    ElementUtil elementUtil = unit.getEnv().elementUtil();\r\n    Iterator<AbstractTypeDeclaration> iter = unit.getTypes().iterator();\r\n    while (iter.hasNext()) {\r\n        AbstractTypeDeclaration type = iter.next();\r\n        TypeElement typeElement = type.getTypeElement();\r\n        if (!ElementUtil.isGeneratedAnnotation(typeElement)) {\r\n            if (deadCodeMap.containsClass(typeElement, elementUtil)) {\r\n                type.setDeadClass(true);\r\n            } else {\r\n                if (typeElement.getInterfaces().size() > 0) {\r\n                    GeneratedTypeElement replacement = GeneratedTypeElement.mutableCopy(typeElement);\r\n                    for (TypeElement intrface : ElementUtil.getInterfaces(typeElement)) {\r\n                        if (!deadCodeMap.containsClass(intrface, elementUtil)) {\r\n                            replacement.addInterface(intrface.asType());\r\n                        }\r\n                    }\r\n                    if (typeElement.getInterfaces().size() > replacement.getInterfaces().size()) {\r\n                        type.setTypeElement(replacement);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.SunCertPathBuilder.addVertices",
	"Comment": "adds a collection of matching certificates to theadjacency list.",
	"Method": "List<Vertex> addVertices(Collection<X509Certificate> certs,List<List<Vertex>> adjList){\r\n    List<Vertex> l = adjList.get(adjList.size() - 1);\r\n    for (X509Certificate cert : certs) {\r\n        Vertex v = new Vertex(cert);\r\n        l.add(v);\r\n    }\r\n    return l;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.Functionizer.makeFunction",
	"Comment": "create an equivalent function declaration for a given method.",
	"Method": "FunctionDeclaration makeFunction(MethodDeclaration method){\r\n    ExecutableElement elem = method.getExecutableElement();\r\n    TypeElement declaringClass = ElementUtil.getDeclaringClass(elem);\r\n    boolean isInstanceMethod = !ElementUtil.isStatic(elem) && !ElementUtil.isConstructor(elem);\r\n    FunctionDeclaration function = new FunctionDeclaration(nameTable.getFullFunctionName(elem), elem.getReturnType());\r\n    function.setJniSignature(signatureGenerator.createJniFunctionSignature(elem));\r\n    function.setLineNumber(method.getLineNumber());\r\n    if (!ElementUtil.isStatic(elem)) {\r\n        VariableElement var = GeneratedVariableElement.newParameter(NameTable.SELF_NAME, declaringClass.asType(), null);\r\n        function.addParameter(new SingleVariableDeclaration(var));\r\n    }\r\n    TreeUtil.copyList(method.getParameters(), function.getParameters());\r\n    function.setModifiers(method.getModifiers() & Modifier.STATIC);\r\n    if (ElementUtil.isPrivate(elem) || (isInstanceMethod && !ElementUtil.isDefault(elem))) {\r\n        function.addModifiers(Modifier.PRIVATE);\r\n    } else {\r\n        function.addModifiers(Modifier.PUBLIC);\r\n    }\r\n    if (Modifier.isNative(method.getModifiers())) {\r\n        function.addModifiers(Modifier.NATIVE);\r\n        return function;\r\n    }\r\n    function.setBody(TreeUtil.remove(method.getBody()));\r\n    if (ElementUtil.isStatic(elem) || ElementUtil.isDefault(elem)) {\r\n        String initName = UnicodeUtils.format(\"%s_initialize\", nameTable.getFullName(declaringClass));\r\n        TypeMirror voidType = typeUtil.getVoid();\r\n        FunctionElement initElement = new FunctionElement(initName, voidType, declaringClass);\r\n        FunctionInvocation initCall = new FunctionInvocation(initElement, voidType);\r\n        function.getBody().addStatement(0, new ExpressionStatement(initCall));\r\n    } else {\r\n        FunctionConverter.convert(function);\r\n    }\r\n    return function;\r\n}"
}, {
	"Path": "java.net.URI.getRawFragment",
	"Comment": "returns the raw fragment component of this uri. the fragment component of a uri, if defined, only contains legal uricharacters.",
	"Method": "String getRawFragment(){\r\n    return fragment;\r\n}"
}, {
	"Path": "java.lang.reflect.Proxy.getInvocationHandler",
	"Comment": "returns the invocation handler for the specified proxy instance.",
	"Method": "InvocationHandler getInvocationHandler(Object proxy){\r\n    if (!(proxy instanceof Proxy)) {\r\n        throw new IllegalArgumentException(\"not a proxy instance\");\r\n    }\r\n    return ((Proxy) proxy).h;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.OCSPResponse.getSingleResponse",
	"Comment": "returns the singleresponse of the specified certid, or null ifthere is no response for that certid.",
	"Method": "SingleResponse getSingleResponse(CertId certId){\r\n    return singleResponseMap.get(certId);\r\n}"
}, {
	"Path": "java.security.cert.CertificateRevokedException.getRevocationDate",
	"Comment": "returns the date on which the certificate was revoked. a new copy isreturned each time the method is invoked to protect against subsequentmodification.",
	"Method": "Date getRevocationDate(){\r\n    return (Date) revocationDate.clone();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.ExternalAnnotationInjectorTest.testVisitingConstructor",
	"Comment": "verify that visiting a constructor does not affect the generated code.",
	"Method": "void testVisitingConstructor(){\r\n    options.setNullability(true);\r\n    String externalNullabilityAnnotations = \"package p: \" + \"annotation @AnAnnotation: \" + \"class Test: \" + \"  method <init>()V: @p.AnAnnotation\";\r\n    options.addExternalAnnotationFileContents(externalNullabilityAnnotations);\r\n    String source = \"package p; public class Test { public Test() {} }\";\r\n    String translation = translateSourceFile(source, \"p.Test\", \"p/Test.h\");\r\n    assertTranslation(translation, \"- (instancetype __nonnull)init;\");\r\n    assertTranslation(translation, \"FOUNDATION_EXPORT void PTest_init(PTest *self);\");\r\n    assertTranslation(translation, \"FOUNDATION_EXPORT PTest *new_PTest_init(void) NS_RETURNS_RETAINED;\");\r\n    assertTranslation(translation, \"FOUNDATION_EXPORT PTest *create_PTest_init(void);\");\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testGetWaitQueueLengthIMSE",
	"Comment": "getwaitqueuelength throws illegalmonitorstateexception if not synced",
	"Method": "void testGetWaitQueueLengthIMSE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    try {\r\n        sync.getWaitQueueLength(c);\r\n        shouldThrow();\r\n    } catch (IllegalMonitorStateException success) {\r\n    }\r\n    assertHasWaitersUnlocked(sync, c, NO_THREADS);\r\n}"
}, {
	"Path": "okio.AsyncTimeout.remainingNanos",
	"Comment": "returns the amount of time left until the time out. this will be negativeif the timeout has elapsed and the timeout should occur immediately.",
	"Method": "long remainingNanos(long now){\r\n    return timeoutAt - now;\r\n}"
}, {
	"Path": "java.net.SocketInputStream.available",
	"Comment": "returns the number of bytes that can be read without blocking.",
	"Method": "int available(){\r\n    if (eof) {\r\n        return 0;\r\n    } else {\r\n        return impl.available();\r\n    }\r\n}"
}, {
	"Path": "java.text.AttributedString.appendContents",
	"Comment": "appends the contents of the characteriterator iterator into thestringbuffer buf.",
	"Method": "void appendContents(StringBuffer buf,CharacterIterator iterator){\r\n    int index = iterator.getBeginIndex();\r\n    int end = iterator.getEndIndex();\r\n    while (index < end) {\r\n        iterator.setIndex(index++);\r\n        buf.append(iterator.current());\r\n    }\r\n}"
}, {
	"Path": "java.time.chrono.ChronoZonedDateTimeImpl.writeReplace",
	"Comment": "writes the chronozoneddatetime using adedicated serialized form.",
	"Method": "Object writeReplace(){\r\n    return new Ser(Ser.CHRONO_ZONE_DATE_TIME_TYPE, this);\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinPool.createWorker",
	"Comment": "tries to construct and start one worker. assumes that totalcount has already been incremented as a reservation.invokesderegisterworker on any failure.",
	"Method": "boolean createWorker(boolean isSpare){\r\n    ForkJoinWorkerThreadFactory fac = factory;\r\n    Throwable ex = null;\r\n    ForkJoinWorkerThread wt = null;\r\n    WorkQueue q;\r\n    try {\r\n        if (fac != null && (wt = fac.newThread(this)) != null) {\r\n            if (isSpare && (q = wt.workQueue) != null)\r\n                q.config |= SPARE_WORKER;\r\n            wt.start();\r\n            return true;\r\n        }\r\n    } catch (Throwable rex) {\r\n        ex = rex;\r\n    }\r\n    deregisterWorker(wt, ex);\r\n    return false;\r\n}"
}, {
	"Path": "java.util.Locale.getUnicodeLocaleKeys",
	"Comment": "returns the set of unicode locale keys defined by this locale, or the empty set ifthis locale has none.the returned set is immutable.keys are all lower case.",
	"Method": "Set<String> getUnicodeLocaleKeys(){\r\n    if (localeExtensions == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    return localeExtensions.getUnicodeLocaleKeys();\r\n}"
}, {
	"Path": "java.security.cert.CollectionCertStoreParameters.getCollection",
	"Comment": "returns the collection from which certificatesand crls are retrieved. this is not a copy of thecollection, it is a reference. this allows the caller tosubsequently add or remove certificates orcrls from the collection.",
	"Method": "Collection<?> getCollection(){\r\n    return coll;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getSerialNumber",
	"Comment": "returns the serialnumber criterion. the specified serial numbermust match the certificate serial number in thex509certificate. if null, any certificateserial number will do.",
	"Method": "BigInteger getSerialNumber(){\r\n    return serialNumber;\r\n}"
}, {
	"Path": "java.util.concurrent.ThreadPoolExecutor.prestartAllCoreThreads",
	"Comment": "starts all core threads, causing them to idly wait for work. thisoverrides the default policy of starting core threads only whennew tasks are executed.",
	"Method": "int prestartAllCoreThreads(){\r\n    int n = 0;\r\n    while (addWorker(null, true)) ++n;\r\n    return n;\r\n}"
}, {
	"Path": "java.net.URISyntaxException.getReason",
	"Comment": "returns a string explaining why the input string could not be parsed.",
	"Method": "String getReason(){\r\n    return super.getMessage();\r\n}"
}, {
	"Path": "sun.security.provider.certpath.ForwardState.clone",
	"Comment": "clone current state. the state is cloned as each cert isadded to the path. this is necessary if backtracking occurs,and a prior state needs to be restored.note that this is a smart clone. not all fields are fully copied,because some of them willnot have their contents modified by subsequent calls to updatestate.",
	"Method": "Object clone(){\r\n    try {\r\n        ForwardState clonedState = (ForwardState) super.clone();\r\n        clonedState.forwardCheckers = (ArrayList<PKIXCertPathChecker>) forwardCheckers.clone();\r\n        ListIterator<PKIXCertPathChecker> li = clonedState.forwardCheckers.listIterator();\r\n        while (li.hasNext()) {\r\n            PKIXCertPathChecker checker = li.next();\r\n            if (checker instanceof Cloneable) {\r\n                li.set((PKIXCertPathChecker) checker.clone());\r\n            }\r\n        }\r\n        clonedState.subjectNamesTraversed = (HashSet<GeneralNameInterface>) subjectNamesTraversed.clone();\r\n        return clonedState;\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new InternalError(e.toString(), e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.nio.channels.DatagramChannelTest.readWriteReadData",
	"Comment": "sender write the sourcearray whose size is datasize, and receiver readthe data into targetarray",
	"Method": "void readWriteReadData(DatagramChannel sender,byte[] sourceArray,DatagramChannel receiver,byte[] targetArray,int dataSize,String methodName){\r\n    ByteBuffer sourceBuf = ByteBuffer.wrap(sourceArray);\r\n    assertEquals(dataSize, sender.write(sourceBuf));\r\n    ByteBuffer targetBuf = ByteBuffer.wrap(targetArray);\r\n    int count = 0;\r\n    int total = 0;\r\n    long beginTime = System.currentTimeMillis();\r\n    while (total < dataSize && (count = receiver.read(targetBuf)) != -1) {\r\n        total = total + count;\r\n        if (System.currentTimeMillis() - beginTime > 3000) {\r\n            break;\r\n        }\r\n    }\r\n    assertEquals(dataSize, total);\r\n    assertEquals(targetBuf.position(), total);\r\n    targetBuf.flip();\r\n    targetArray = targetBuf.array();\r\n    for (int i = 0; i < targetArray.length; i++) {\r\n        assertEquals(targetArray[i], (byte) i);\r\n    }\r\n}"
}, {
	"Path": "javax.xml.transform.sax.SAXSource.sourceToInputSource",
	"Comment": "attempt to obtain a sax inputsource object from a sourceobject.",
	"Method": "InputSource sourceToInputSource(Source source){\r\n    if (source instanceof SAXSource) {\r\n        return ((SAXSource) source).getInputSource();\r\n    } else if (source instanceof StreamSource) {\r\n        StreamSource ss = (StreamSource) source;\r\n        InputSource isource = new InputSource(ss.getSystemId());\r\n        isource.setByteStream(ss.getInputStream());\r\n        isource.setCharacterStream(ss.getReader());\r\n        isource.setPublicId(ss.getPublicId());\r\n        return isource;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.SynchronousQueue.poll",
	"Comment": "retrieves and removes the head of this queue, if another threadis currently making an element available.",
	"Method": "E poll(long timeout,TimeUnit unit,E poll){\r\n    return transferer.transfer(null, true, 0);\r\n}"
}, {
	"Path": "org.xml.sax.helpers.NamespaceSupport.isNamespaceDeclUris",
	"Comment": "returns true if namespace declaration attributes are placed intoa namespace.this behavior is not the default.",
	"Method": "boolean isNamespaceDeclUris(){\r\n    return namespaceDeclUris;\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerArrayTest.testGetAndSet",
	"Comment": "getandset returns previous value and sets to given value at given index",
	"Method": "void testGetAndSet(){\r\n    AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);\r\n    for (int i = 0; i < SIZE; i++) {\r\n        aa.set(i, 1);\r\n        assertEquals(1, aa.getAndSet(i, 0));\r\n        assertEquals(0, aa.getAndSet(i, -10));\r\n        assertEquals(-10, aa.getAndSet(i, 1));\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.GenerationTest.assertWarningCount",
	"Comment": "asserts that the correct number of warnings were reported during thelast translation.",
	"Method": "void assertWarningCount(int expectedCount){\r\n    if (expectedCount != ErrorUtil.warningCount()) {\r\n        failWithMessages(String.format(\"Wrong number of warnings. Expected:%d but was:%d\", expectedCount, ErrorUtil.warningCount()), ErrorUtil.getWarningMessages());\r\n    }\r\n}"
}, {
	"Path": "java.io.ByteArrayOutputStream.ensureCapacity",
	"Comment": "increases the capacity if necessary to ensure that it can holdat least the number of elements specified by the minimumcapacity argument.",
	"Method": "void ensureCapacity(int minCapacity){\r\n    if (minCapacity - buf.length > 0)\r\n        grow(minCapacity);\r\n}"
}, {
	"Path": "javax.crypto.SecretKeyFactory.nextSpi",
	"Comment": "update the active spi of this class and return the nextimplementation for failover. if no more implemenations areavailable, this method returns null. however, the active spi ofthis class is never set to null.",
	"Method": "SecretKeyFactorySpi nextSpi(SecretKeyFactorySpi oldSpi){\r\n    synchronized (lock) {\r\n        if ((oldSpi != null) && (oldSpi != spi)) {\r\n            return spi;\r\n        }\r\n        if (serviceIterator == null) {\r\n            return null;\r\n        }\r\n        while (serviceIterator.hasNext()) {\r\n            Service s = (Service) serviceIterator.next();\r\n            if (JceSecurity.canUseProvider(s.getProvider()) == false) {\r\n                continue;\r\n            }\r\n            try {\r\n                Object obj = s.newInstance(null);\r\n                if (obj instanceof SecretKeyFactorySpi == false) {\r\n                    continue;\r\n                }\r\n                SecretKeyFactorySpi spi = (SecretKeyFactorySpi) obj;\r\n                provider = s.getProvider();\r\n                this.spi = spi;\r\n                return spi;\r\n            } catch (NoSuchAlgorithmException e) {\r\n            }\r\n        }\r\n        serviceIterator = null;\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.google.j2objc.ClassTest.testPackagePrefixAnnotation",
	"Comment": "verify that a class with a package that has been renamed using anobjectivecname annotation can be reflexively loaded.",
	"Method": "void testPackagePrefixAnnotation(){\r\n    Class<?> cls = Class.forName(\"java.lang.test.Example\");\r\n    Object instance = cls.newInstance();\r\n    Method m = cls.getMethod(\"nativeClassName\");\r\n    String nativeName = (String) m.invoke(instance);\r\n    assertEquals(\"OKExample\", nativeName);\r\n}"
}, {
	"Path": "java.util.Vector.containsAll",
	"Comment": "returns true if this vector contains all of the elements in thespecified collection.",
	"Method": "boolean containsAll(Collection<?> c){\r\n    return super.containsAll(c);\r\n}"
}, {
	"Path": "java.util.PropertyResourceBundle.getKeys",
	"Comment": "returns an enumeration of the keys contained inthis resourcebundle and its parent bundles.",
	"Method": "Enumeration<String> getKeys(){\r\n    ResourceBundle parent = this.parent;\r\n    return new ResourceBundleEnumeration(lookup.keySet(), (parent != null) ? parent.getKeys() : null);\r\n}"
}, {
	"Path": "java.security.KeyPairGenerator.getAlgorithm",
	"Comment": "returns the standard name of the algorithm for this key pair generator.see the keypairgenerator section in the java cryptography architecture standard algorithm name documentationfor information about standard algorithm names.",
	"Method": "String getAlgorithm(){\r\n    return this.algorithm;\r\n}"
}, {
	"Path": "java.io.PipedReader.receivedLast",
	"Comment": "notifies all waiting threads that the last character of data has beenreceived.",
	"Method": "void receivedLast(){\r\n    closedByWriter = true;\r\n    notifyAll();\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.data_leapyears",
	"Comment": "data provider to verify whether a given hijrah year is a leap year or not",
	"Method": "Object[][] data_leapyears(){\r\n    return new Object[][] { { 1302, true }, { 1305, false }, { 1315, false }, { 1534, false }, { 1411, true }, { 1429, false }, { 1433, true }, { 1443, true } };\r\n}"
}, {
	"Path": "java.util.zip.GZIPOutputStream.writeShort",
	"Comment": "writes short integer in intel byte order to a byte array, startingat a given offset",
	"Method": "void writeShort(int s,byte[] buf,int offset){\r\n    buf[offset] = (byte) (s & 0xff);\r\n    buf[offset + 1] = (byte) ((s >> 8) & 0xff);\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testLongAccumulateAndGet",
	"Comment": "atomiclong accumulateandget updates with supplied function andreturns result.",
	"Method": "void testLongAccumulateAndGet(){\r\n    AtomicLong a = new AtomicLong(1L);\r\n    assertEquals(7L, a.accumulateAndGet(6L, Long::sum));\r\n    assertEquals(10L, a.accumulateAndGet(3L, Long::sum));\r\n    assertEquals(10L, a.get());\r\n}"
}, {
	"Path": "jsr166.AtomicMarkableReferenceTest.testWeakCompareAndSet",
	"Comment": "repeated weakcompareandset succeeds in changing values when equalto expected",
	"Method": "void testWeakCompareAndSet(){\r\n    boolean[] mark = new boolean[1];\r\n    AtomicMarkableReference ai = new AtomicMarkableReference(one, false);\r\n    assertSame(one, ai.get(mark));\r\n    assertFalse(ai.isMarked());\r\n    assertFalse(mark[0]);\r\n    do {\r\n    } while (!ai.weakCompareAndSet(one, two, false, false));\r\n    assertSame(two, ai.get(mark));\r\n    assertFalse(mark[0]);\r\n    do {\r\n    } while (!ai.weakCompareAndSet(two, m3, false, true));\r\n    assertSame(m3, ai.get(mark));\r\n    assertTrue(mark[0]);\r\n}"
}, {
	"Path": "java.security.cert.CertificateFactory.generateCertPath",
	"Comment": "generates a certpath object and initializes it witha list of certificates.the certificates supplied must be of a type supported by thecertificatefactory. they will be copied out of the suppliedlist object.",
	"Method": "CertPath generateCertPath(InputStream inStream,CertPath generateCertPath,InputStream inStream,String encoding,CertPath generateCertPath,List<? extends Certificate> certificates){\r\n    return (certFacSpi.engineGenerateCertPath(certificates));\r\n}"
}, {
	"Path": "sun.misc.FDBigInt.mult",
	"Comment": "multiply a fdbigint by another fdbigint.result is a new fdbigint.",
	"Method": "FDBigInt mult(int iv,FDBigInt mult,FDBigInt other){\r\n    int[] r = new int[nWords + other.nWords];\r\n    int i;\r\n    for (i = 0; i < this.nWords; i++) {\r\n        long v = (long) this.data[i] & 0xffffffffL;\r\n        long p = 0L;\r\n        int j;\r\n        for (j = 0; j < other.nWords; j++) {\r\n            p += ((long) r[i + j] & 0xffffffffL) + v * ((long) other.data[j] & 0xffffffffL);\r\n            r[i + j] = (int) p;\r\n            p >>>= 32;\r\n        }\r\n        r[i + j] = (int) p;\r\n    }\r\n    for (i = r.length - 1; i > 0; i--) if (r[i] != 0)\r\n        break;\r\n    return new FDBigInt(r, i + 1);\r\n}"
}, {
	"Path": "java.net.Inet4Address.isMCLinkLocal",
	"Comment": "utility routine to check if the multicast address has link scope.",
	"Method": "boolean isMCLinkLocal(){\r\n    int address = holder().getAddress();\r\n    return (((address >>> 24) & 0xFF) == 224) && (((address >>> 16) & 0xFF) == 0) && (((address >>> 8) & 0xFF) == 0);\r\n}"
}, {
	"Path": "sun.security.util.DerIndefLenConverter.parseLength",
	"Comment": "parse the length and if it is an indefinite length then addthe current position to the ndefslist vector.",
	"Method": "int parseLength(){\r\n    int curLen = 0;\r\n    if (dataPos == dataSize)\r\n        return curLen;\r\n    int lenByte = data[dataPos++] & 0xff;\r\n    if (isIndefinite(lenByte)) {\r\n        ndefsList.add(new Integer(dataPos));\r\n        unresolved++;\r\n        return curLen;\r\n    }\r\n    if (isLongForm(lenByte)) {\r\n        lenByte &= LEN_MASK;\r\n        if (lenByte > 4) {\r\n            throw new IOException(\"Too much data\");\r\n        }\r\n        if ((dataSize - dataPos) < (lenByte + 1)) {\r\n            throw new IOException(\"Too little data\");\r\n        }\r\n        for (int i = 0; i < lenByte; i++) {\r\n            curLen = (curLen << 8) + (data[dataPos++] & 0xff);\r\n        }\r\n        if (curLen < 0) {\r\n            throw new IOException(\"Invalid length bytes\");\r\n        }\r\n    } else {\r\n        curLen = (lenByte & LEN_MASK);\r\n    }\r\n    return curLen;\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalInvoke",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvoke(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingFibAction f = new FailingFibAction(8);\r\n            try {\r\n                f.invoke();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testAbnormalInvoke",
	"Comment": "invoke task throws exception when task completes abnormally",
	"Method": "void testAbnormalInvoke(){\r\n    FailingFibAction f = new FailingFibAction(8);\r\n    try {\r\n        f.invoke();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "java.time.zone.ZoneOffsetTransitionRule.getTimeDefinition",
	"Comment": "gets the time definition, specifying how to convert the time to an instant.the local time can be converted to an instant using the standard offset,the wall offset or utc.",
	"Method": "TimeDefinition getTimeDefinition(){\r\n    return timeDefinition;\r\n}"
}, {
	"Path": "sun.security.x509.GeneralSubtrees.equals",
	"Comment": "compare two general subtrees by comparing the subtreesof each.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof GeneralSubtrees == false) {\r\n        return false;\r\n    }\r\n    GeneralSubtrees other = (GeneralSubtrees) obj;\r\n    return this.trees.equals(other.trees);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testQuietlyInvokeCC",
	"Comment": "quietlyinvoke task returns when task completes normally.iscompletedabnormally and iscancelled return false for normallycompleted tasks",
	"Method": "void testQuietlyInvokeCC(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            CCF f = new LCCF(null, 8);\r\n            f.quietlyInvoke();\r\n            assertEquals(21, f.number);\r\n            checkCompletedNormally(f);\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testQuietlyInvokeCC",
	"Comment": "quietlyinvoke task returns when task completes normally.iscompletedabnormally and iscancelled return false for normallycompleted tasks",
	"Method": "void testQuietlyInvokeCC(){\r\n    CCF f = new LCCF(null, 8);\r\n    f.quietlyInvoke();\r\n    assertEquals(21, f.number);\r\n    checkCompletedNormally(f);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testAbnormalForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGet(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FailingFibAction f = new FailingFibAction(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get(5L, SECONDS);\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testAbnormalForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGet(){\r\n    FailingFibAction f = new FailingFibAction(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get(5L, SECONDS);\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.getInt",
	"Comment": "return the int in use in this mutablebiginteger at the specifiedindex. this method is not used because it is not inlined on allplatforms.",
	"Method": "int getInt(int index){\r\n    return value[offset + index];\r\n}"
}, {
	"Path": "java.math.BigInteger.largePrime",
	"Comment": "find a random number of the specified bitlength that is probably prime.this method is more appropriate for larger bitlengths since it usesa sieve to eliminate most composites before using a more expensivetest.",
	"Method": "BigInteger largePrime(int bitLength,int certainty,Random rnd){\r\n    BigInteger p;\r\n    p = new BigInteger(bitLength, rnd).setBit(bitLength - 1);\r\n    p.mag[p.mag.length - 1] &= 0xfffffffe;\r\n    int searchLen = getPrimeSearchLen(bitLength);\r\n    BitSieve searchSieve = new BitSieve(p, searchLen);\r\n    BigInteger candidate = searchSieve.retrieve(p, certainty, rnd);\r\n    while ((candidate == null) || (candidate.bitLength() != bitLength)) {\r\n        p = p.add(BigInteger.valueOf(2 * searchLen));\r\n        if (p.bitLength() != bitLength)\r\n            p = new BigInteger(bitLength, rnd).setBit(bitLength - 1);\r\n        p.mag[p.mag.length - 1] &= 0xfffffffe;\r\n        searchSieve = new BitSieve(p, searchLen);\r\n        candidate = searchSieve.retrieve(p, certainty, rnd);\r\n    }\r\n    return candidate;\r\n}"
}, {
	"Path": "java.sql.SQLClientInfoException.getFailedProperties",
	"Comment": "returns the list of client info properties that could not be set.thekeys in the mapcontain the names of the client infoproperties that could not be set and the values contain one of thereason codes defined in clientinfostatus",
	"Method": "Map<String, ClientInfoStatus> getFailedProperties(){\r\n    return this.failedProperties;\r\n}"
}, {
	"Path": "java.net.HttpURLConnection.setChunkedStreamingMode",
	"Comment": "this method is used to enable streaming of a http request bodywithout internal buffering, when the content length is notknown in advance. in this mode, chunked transfer encodingis used to send the request body. note, not all http serverssupport this mode.when output streaming is enabled, authenticationand redirection cannot be handled automatically.a httpretryexception will be thrown when readingthe response if authentication or redirection are required.this exception can be queried for the details of the error.this method must be called before the urlconnection is connected.",
	"Method": "void setChunkedStreamingMode(int chunklen){\r\n    if (connected) {\r\n        throw new IllegalStateException(\"Can't set streaming mode: already connected\");\r\n    }\r\n    if (fixedContentLength != -1 || fixedContentLengthLong != -1) {\r\n        throw new IllegalStateException(\"Fixed length streaming mode set\");\r\n    }\r\n    chunkLength = chunklen <= 0 ? DEFAULT_CHUNK_SIZE : chunklen;\r\n}"
}, {
	"Path": "java.util.Optional.ifPresent",
	"Comment": "if a value is present, invoke the specified consumer with the value,otherwise do nothing.",
	"Method": "void ifPresent(Consumer<? super T> consumer){\r\n    if (value != null)\r\n        consumer.accept(value);\r\n}"
}, {
	"Path": "sun.util.calendar.CalendarDate.isSameDate",
	"Comment": "returns whether the specified date is the same date of thiscalendardate. the time of the day fields areignored for the comparison.",
	"Method": "boolean isSameDate(CalendarDate date){\r\n    return getDayOfWeek() == date.getDayOfWeek() && getMonth() == date.getMonth() && getYear() == date.getYear() && getEra() == date.getEra();\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.addCount",
	"Comment": "adds to count, and if table is too small and not alreadyresizing, initiates transfer. if already resizing, helpsperform transfer if work is available.rechecks occupancyafter a transfer to see if another resize is already neededbecause resizings are lagging additions.",
	"Method": "void addCount(long x,int check){\r\n    CounterCell[] as;\r\n    long b, s;\r\n    if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {\r\n        CounterCell a;\r\n        long v;\r\n        int m;\r\n        boolean uncontended = true;\r\n        if (as == null || (m = as.length - 1) < 0 || (a = as[ThreadLocalRandom.getProbe() & m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {\r\n            fullAddCount(x, uncontended);\r\n            return;\r\n        }\r\n        if (check <= 1)\r\n            return;\r\n        s = sumCount();\r\n    }\r\n    if (check >= 0) {\r\n        Node<K, V>[] tab, nt;\r\n        int n, sc;\r\n        while (s >= (long) (sc = sizeCtl) && (tab = table) != null && (n = tab.length) < MAXIMUM_CAPACITY) {\r\n            int rs = resizeStamp(n);\r\n            if (sc < 0) {\r\n                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex <= 0)\r\n                    break;\r\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\r\n                    transfer(tab, nt);\r\n            } else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs << RESIZE_STAMP_SHIFT) + 2))\r\n                transfer(tab, null);\r\n            s = sumCount();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.io.ByteArrayOutputStream.grow",
	"Comment": "increases the capacity to ensure that it can hold at least thenumber of elements specified by the minimum capacity argument.",
	"Method": "void grow(int minCapacity){\r\n    int oldCapacity = buf.length;\r\n    int newCapacity = oldCapacity << 1;\r\n    if (newCapacity - minCapacity < 0)\r\n        newCapacity = minCapacity;\r\n    if (newCapacity < 0) {\r\n        if (minCapacity < 0)\r\n            throw new OutOfMemoryError();\r\n        newCapacity = Integer.MAX_VALUE;\r\n    }\r\n    buf = Arrays.copyOf(buf, newCapacity);\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.data_samples",
	"Comment": "date samples to convert hijrahdate to localdate and vice versa",
	"Method": "Object[][] data_samples(){\r\n    return new Object[][] { { HijrahChronology.INSTANCE.date(1319, 12, 30), LocalDate.of(1902, 4, 9) }, { HijrahChronology.INSTANCE.date(1320, 1, 1), LocalDate.of(1902, 4, 10) }, { HijrahChronology.INSTANCE.date(1321, 12, 30), LocalDate.of(1904, 3, 18) }, { HijrahChronology.INSTANCE.date(1433, 7, 29), LocalDate.of(2012, 6, 19) }, { HijrahChronology.INSTANCE.date(1434, 10, 12), LocalDate.of(2013, 8, 19) }, { HijrahChronology.INSTANCE.date(1500, 3, 3), LocalDate.of(2077, 1, 28) } };\r\n}"
}, {
	"Path": "java.util.concurrent.ScheduledThreadPoolExecutor.onShutdown",
	"Comment": "cancels and clears the queue of all tasks that should not be rundue to shutdown policy.invoked within super.shutdown.",
	"Method": "void onShutdown(){\r\n    BlockingQueue<Runnable> q = super.getQueue();\r\n    boolean keepDelayed = getExecuteExistingDelayedTasksAfterShutdownPolicy();\r\n    boolean keepPeriodic = getContinueExistingPeriodicTasksAfterShutdownPolicy();\r\n    if (!keepDelayed && !keepPeriodic) {\r\n        for (Object e : q.toArray()) if (e instanceof RunnableScheduledFuture<?>)\r\n            ((RunnableScheduledFuture<?>) e).cancel(false);\r\n        q.clear();\r\n    } else {\r\n        for (Object e : q.toArray()) {\r\n            if (e instanceof RunnableScheduledFuture) {\r\n                RunnableScheduledFuture<?> t = (RunnableScheduledFuture<?>) e;\r\n                if ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) || t.isCancelled()) {\r\n                    if (q.remove(t))\r\n                        t.cancel(false);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    tryTerminate();\r\n}"
}, {
	"Path": "java.util.PriorityQueue.clear",
	"Comment": "removes all of the elements from this priority queue.the queue will be empty after this call returns.",
	"Method": "void clear(){\r\n    modCount++;\r\n    for (int i = 0; i < size; i++) queue[i] = null;\r\n    size = 0;\r\n}"
}, {
	"Path": "android.icu.dev.test.timezone.TimeZoneRuleTest.verifyTransitions",
	"Comment": "check if a time shift really happens on each transition returned by getnexttransition orgetprevioustransition in the specified time range",
	"Method": "void verifyTransitions(TimeZone tz,long start,long end){\r\n    BasicTimeZone icutz = (BasicTimeZone) tz;\r\n    long time;\r\n    int[] before = new int[2];\r\n    int[] after = new int[2];\r\n    TimeZoneTransition tzt0;\r\n    tzt0 = null;\r\n    time = start;\r\n    while (true) {\r\n        TimeZoneTransition tzt = icutz.getNextTransition(time, false);\r\n        if (tzt == null) {\r\n            break;\r\n        }\r\n        time = tzt.getTime();\r\n        if (time >= end) {\r\n            break;\r\n        }\r\n        icutz.getOffset(time, false, after);\r\n        icutz.getOffset(time - 1, false, before);\r\n        if (after[0] == before[0] && after[1] == before[1]) {\r\n            errln(\"FAIL: False transition returned by getNextTransition for \" + icutz.getID() + \" at \" + time);\r\n        }\r\n        if (tzt0 != null && (tzt0.getTo().getRawOffset() != tzt.getFrom().getRawOffset() || tzt0.getTo().getDSTSavings() != tzt.getFrom().getDSTSavings())) {\r\n            errln(\"FAIL: TO rule of the previous transition does not match FROM rule of this transtion at \" + time + \" for \" + icutz.getID());\r\n        }\r\n        tzt0 = tzt;\r\n    }\r\n    tzt0 = null;\r\n    time = end;\r\n    while (true) {\r\n        TimeZoneTransition tzt = icutz.getPreviousTransition(time, false);\r\n        if (tzt == null) {\r\n            break;\r\n        }\r\n        time = tzt.getTime();\r\n        if (time <= start) {\r\n            break;\r\n        }\r\n        icutz.getOffset(time, false, after);\r\n        icutz.getOffset(time - 1, false, before);\r\n        if (after[0] == before[0] && after[1] == before[1]) {\r\n            errln(\"FAIL: False transition returned by getPreviousTransition for \" + icutz.getID() + \" at \" + time);\r\n        }\r\n        if (tzt0 != null && (tzt0.getFrom().getRawOffset() != tzt.getTo().getRawOffset() || tzt0.getFrom().getDSTSavings() != tzt.getTo().getDSTSavings())) {\r\n            errln(\"FAIL: TO rule of the next transition does not match FROM rule in this transtion at \" + time + \" for \" + icutz.getID());\r\n        }\r\n        tzt0 = tzt;\r\n    }\r\n}"
}, {
	"Path": "java.lang.ClassLoader.definePackage",
	"Comment": "defines a package by name in this classloader.this allowsclass loaders to define the packages for their classes. packages mustbe created before the class is defined, and package names must beunique within a class loader and cannot be redefined or changed oncecreated.",
	"Method": "Package definePackage(String name,String specTitle,String specVersion,String specVendor,String implTitle,String implVersion,String implVendor,URL sealBase){\r\n    synchronized (packages) {\r\n        Package pkg = packages.get(name);\r\n        if (pkg != null) {\r\n            throw new IllegalArgumentException(name);\r\n        }\r\n        pkg = new Package(name, specTitle, specVersion, specVendor, implTitle, implVersion, implVendor, sealBase, this);\r\n        packages.put(name, pkg);\r\n        return pkg;\r\n    }\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_toString",
	"Comment": "test to verify the returned string value of a given date instance",
	"Method": "void test_toString(ChronoLocalDate hijrahDate,String expected){\r\n    assertEquals(hijrahDate.toString(), expected);\r\n}"
}, {
	"Path": "java.lang.ref.ReferenceQueue.remove",
	"Comment": "removes the next reference object in this queue, blocking until onebecomes available.",
	"Method": "Reference<? extends T> remove(long timeout,Reference<? extends T> remove){\r\n    return remove(0);\r\n}"
}, {
	"Path": "java.text.DecimalFormat.setDecimalFormatSymbols",
	"Comment": "sets the decimal format symbols, which is generally not changedby the programmer or user.",
	"Method": "void setDecimalFormatSymbols(DecimalFormatSymbols newSymbols){\r\n    try {\r\n        symbols = (DecimalFormatSymbols) newSymbols.clone();\r\n        expandAffixes();\r\n        fastPathCheckNeeded = true;\r\n    } catch (Exception foo) {\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.DeflaterOutputStream.finish",
	"Comment": "finishes writing compressed data to the output stream without closingthe underlying stream. use this method when applying multiple filtersin succession to the same output stream.",
	"Method": "void finish(){\r\n    if (!def.finished()) {\r\n        def.finish();\r\n        while (!def.finished()) {\r\n            deflate();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.security.KeyStoreSpi.engineSetEntry",
	"Comment": "saves a keystore.entry under the specified alias.the specified protection parameter is used to protect theentry. if an entry already exists for the specified alias,it is overridden.",
	"Method": "void engineSetEntry(String alias,KeyStore.Entry entry,KeyStore.ProtectionParameter protParam){\r\n    if (protParam != null && !(protParam instanceof KeyStore.PasswordProtection)) {\r\n        throw new KeyStoreException(\"unsupported protection parameter\");\r\n    }\r\n    KeyStore.PasswordProtection pProtect = null;\r\n    if (protParam != null) {\r\n        pProtect = (KeyStore.PasswordProtection) protParam;\r\n    }\r\n    char[] password = (pProtect == null) ? null : pProtect.getPassword();\r\n    if (entry instanceof KeyStore.TrustedCertificateEntry) {\r\n        KeyStore.TrustedCertificateEntry tce = (KeyStore.TrustedCertificateEntry) entry;\r\n        engineSetCertificateEntry(alias, tce.getTrustedCertificate());\r\n        return;\r\n    } else if (entry instanceof KeyStore.PrivateKeyEntry) {\r\n        engineSetKeyEntry(alias, ((KeyStore.PrivateKeyEntry) entry).getPrivateKey(), password, ((KeyStore.PrivateKeyEntry) entry).getCertificateChain());\r\n        return;\r\n    } else if (entry instanceof KeyStore.SecretKeyEntry) {\r\n        engineSetKeyEntry(alias, ((KeyStore.SecretKeyEntry) entry).getSecretKey(), password, (Certificate[]) null);\r\n        return;\r\n    }\r\n    throw new KeyStoreException(\"unsupported entry type: \" + entry.getClass().getName());\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testAwait1_Interrupted_BrokenBarrier",
	"Comment": "an interruption in one party causes others waiting in await tothrow brokenbarrierexception",
	"Method": "void testAwait1_Interrupted_BrokenBarrier(){\r\n    final CyclicBarrier c = new CyclicBarrier(3);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(2);\r\n    Thread t1 = new ThreadShouldThrow(InterruptedException.class) {\r\n        public void realRun() throws Exception {\r\n            pleaseInterrupt.countDown();\r\n            c.await();\r\n        }\r\n    };\r\n    Thread t2 = new ThreadShouldThrow(BrokenBarrierException.class) {\r\n        public void realRun() throws Exception {\r\n            pleaseInterrupt.countDown();\r\n            c.await();\r\n        }\r\n    };\r\n    t1.start();\r\n    t2.start();\r\n    await(pleaseInterrupt);\r\n    t1.interrupt();\r\n    awaitTermination(t1);\r\n    awaitTermination(t2);\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testAwait1_Interrupted_BrokenBarrier",
	"Comment": "an interruption in one party causes others waiting in await tothrow brokenbarrierexception",
	"Method": "void testAwait1_Interrupted_BrokenBarrier(){\r\n    pleaseInterrupt.countDown();\r\n    c.await();\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testAwait1_Interrupted_BrokenBarrier",
	"Comment": "an interruption in one party causes others waiting in await tothrow brokenbarrierexception",
	"Method": "void testAwait1_Interrupted_BrokenBarrier(){\r\n    pleaseInterrupt.countDown();\r\n    c.await();\r\n}"
}, {
	"Path": "sun.nio.ch.InheritedChannel.getChannel",
	"Comment": "returns a channel representing the inherited channel if theinherited channel is a stream connected to a network socket.",
	"Method": "Channel getChannel(){\r\n    if (devnull < 0) {\r\n        devnull = open0(\"/dev/null\", O_RDWR);\r\n    }\r\n    if (!haveChannel) {\r\n        channel = createChannel();\r\n        haveChannel = true;\r\n    }\r\n    if (channel != null) {\r\n        checkAccess(channel);\r\n    }\r\n    return channel;\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testAwait4_Timeout_BrokenBarrier",
	"Comment": "a timeout in one party causes others waiting in timed await tothrow brokenbarrierexception",
	"Method": "void testAwait4_Timeout_BrokenBarrier(){\r\n    final CyclicBarrier c = new CyclicBarrier(3);\r\n    Thread t1 = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            try {\r\n                c.await(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (BrokenBarrierException success) {\r\n            }\r\n        }\r\n    });\r\n    Thread t2 = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            awaitNumberWaiting(c, 1);\r\n            long startTime = System.nanoTime();\r\n            try {\r\n                c.await(timeoutMillis(), MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (TimeoutException success) {\r\n            }\r\n            assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n        }\r\n    });\r\n    awaitTermination(t1);\r\n    awaitTermination(t2);\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testAwait4_Timeout_BrokenBarrier",
	"Comment": "a timeout in one party causes others waiting in timed await tothrow brokenbarrierexception",
	"Method": "void testAwait4_Timeout_BrokenBarrier(){\r\n    try {\r\n        c.await(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (BrokenBarrierException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testAwait4_Timeout_BrokenBarrier",
	"Comment": "a timeout in one party causes others waiting in timed await tothrow brokenbarrierexception",
	"Method": "void testAwait4_Timeout_BrokenBarrier(){\r\n    awaitNumberWaiting(c, 1);\r\n    long startTime = System.nanoTime();\r\n    try {\r\n        c.await(timeoutMillis(), MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (TimeoutException success) {\r\n    }\r\n    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.getSubjectX500Principal",
	"Comment": "get subject name as x500principal. overrides implementation inx509certificate with a slightly more efficient version that isalso aware of x509certimpl mutability.",
	"Method": "X500Principal getSubjectX500Principal(X500Principal getSubjectX500Principal,X509Certificate cert){\r\n    try {\r\n        return getX500Principal(cert, false);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(\"Could not parse subject\", e);\r\n    }\r\n}"
}, {
	"Path": "sun.security.util.ObjectIdentifier.toIntArray",
	"Comment": "private helper method for serialization. to be compatible with oldversions of jdk.",
	"Method": "int[] toIntArray(){\r\n    int length = encoding.length;\r\n    int[] result = new int[20];\r\n    int which = 0;\r\n    int fromPos = 0;\r\n    for (int i = 0; i < length; i++) {\r\n        if ((encoding[i] & 0x80) == 0) {\r\n            if (i - fromPos + 1 > 4) {\r\n                BigInteger big = new BigInteger(pack(encoding, fromPos, i - fromPos + 1, 7, 8));\r\n                if (fromPos == 0) {\r\n                    result[which++] = 2;\r\n                    BigInteger second = big.subtract(BigInteger.valueOf(80));\r\n                    if (second.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) == 1) {\r\n                        return null;\r\n                    } else {\r\n                        result[which++] = second.intValue();\r\n                    }\r\n                } else {\r\n                    if (big.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) == 1) {\r\n                        return null;\r\n                    } else {\r\n                        result[which++] = big.intValue();\r\n                    }\r\n                }\r\n            } else {\r\n                int retval = 0;\r\n                for (int j = fromPos; j <= i; j++) {\r\n                    retval <<= 7;\r\n                    byte tmp = encoding[j];\r\n                    retval |= (tmp & 0x07f);\r\n                }\r\n                if (fromPos == 0) {\r\n                    if (retval < 80) {\r\n                        result[which++] = retval / 40;\r\n                        result[which++] = retval % 40;\r\n                    } else {\r\n                        result[which++] = 2;\r\n                        result[which++] = retval - 80;\r\n                    }\r\n                } else {\r\n                    result[which++] = retval;\r\n                }\r\n            }\r\n            fromPos = i + 1;\r\n        }\r\n        if (which >= result.length) {\r\n            result = Arrays.copyOf(result, which + 10);\r\n        }\r\n    }\r\n    return Arrays.copyOf(result, which);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test426411",
	"Comment": "runtime due to emission order of casts in intersection casts",
	"Method": "void test426411(){\r\n    this.runConformTest(new String[] { \"X.java\", \"import java.io.Serializable;\\n\" + \"public class X {\\n\" + \" public static void main(String argv[]) throws Exception {\\n\" + \"   ((Serializable & AutoCloseable) (() -> {})).close();\\n\" + \" }\\n\" + \"}\\n\" }, \"\");\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.getIssuers",
	"Comment": "returns the issuernames criterion. the issuer distinguishedname in the x509crl must match at least one of the specifieddistinguished names. if the value returned is null, anyissuer distinguished name will do.if the value returned is not null, it is aunmodifiable collection of x500principals.",
	"Method": "Collection<X500Principal> getIssuers(){\r\n    if (issuerX500Principals == null) {\r\n        return null;\r\n    }\r\n    return Collections.unmodifiableCollection(issuerX500Principals);\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.getGregorianCutoverDate",
	"Comment": "returns the gregorian cutover date as a basecalendar.date. thedate is a gregorian date.",
	"Method": "BaseCalendar.Date getGregorianCutoverDate(){\r\n    return getCalendarDate(gregorianCutoverDate);\r\n}"
}, {
	"Path": "javax.crypto.Mac.getAlgorithm",
	"Comment": "returns the algorithm name of this mac object.this is the same name that was specified in one of thegetinstance calls that created thismac object.",
	"Method": "String getAlgorithm(){\r\n    return this.algorithm;\r\n}"
}, {
	"Path": "jsr166.ForkJoinPoolTest.testDefaultInitialState",
	"Comment": "successfully constructed pool reports default factory,parallelism and async mode policies, no active threads ortasks, and quiescent running state.",
	"Method": "void testDefaultInitialState(){\r\n    ForkJoinPool p = new ForkJoinPool(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertSame(ForkJoinPool.defaultForkJoinWorkerThreadFactory, p.getFactory());\r\n        assertFalse(p.getAsyncMode());\r\n        assertEquals(0, p.getActiveThreadCount());\r\n        assertEquals(0, p.getStealCount());\r\n        assertEquals(0, p.getQueuedTaskCount());\r\n        assertEquals(0, p.getQueuedSubmissionCount());\r\n        assertFalse(p.hasQueuedSubmissions());\r\n        assertFalse(p.isShutdown());\r\n        assertFalse(p.isTerminating());\r\n        assertFalse(p.isTerminated());\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testConstructor5",
	"Comment": "queue contains all elements of the collection it is initialized by",
	"Method": "void testConstructor5(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        ints[i] = i;\r\n    }\r\n    List intList = Arrays.asList(ints);\r\n    LinkedTransferQueue q = new LinkedTransferQueue(intList);\r\n    assertEquals(q.size(), intList.size());\r\n    assertEquals(q.toString(), intList.toString());\r\n    assertTrue(Arrays.equals(q.toArray(), intList.toArray()));\r\n    assertTrue(Arrays.equals(q.toArray(new Object[0]), intList.toArray(new Object[0])));\r\n    assertTrue(Arrays.equals(q.toArray(new Object[SIZE]), intList.toArray(new Object[SIZE])));\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(ints[i], q.poll());\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testConstructor3",
	"Comment": "initializing from collection of null elements throwsnullpointerexception",
	"Method": "void testConstructor3(){\r\n    Collection<Integer> elements = Arrays.asList(new Integer[SIZE]);\r\n    try {\r\n        new LinkedTransferQueue(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.getDateAndTime",
	"Comment": "returns the dateandtime criterion. the specified date must beequal to or later than the value of the thisupdate componentof the x509crl and earlier than the value of thenextupdate component. there is no match if thex509crl does not contain a nextupdate component.if null, no dateandtime check will be done.note that the date returned is cloned to protect againstsubsequent modifications.",
	"Method": "Date getDateAndTime(){\r\n    if (dateAndTime == null)\r\n        return null;\r\n    return (Date) dateAndTime.clone();\r\n}"
}, {
	"Path": "sun.security.provider.certpath.KeyChecker.init",
	"Comment": "initializes the internal state of the checker from parametersspecified in the constructor",
	"Method": "void init(boolean forward){\r\n    if (!forward) {\r\n        remainingCerts = certPathLen;\r\n    } else {\r\n        throw new CertPathValidatorException(\"forward checking not supported\");\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testConstructor4",
	"Comment": "initializing constructor with a collection containing some null elementsthrows nullpointerexception",
	"Method": "void testConstructor4(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = i;\r\n    Collection<Integer> elements = Arrays.asList(ints);\r\n    try {\r\n        new LinkedTransferQueue(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testIntegerFieldUpdaterUpdateAndGet",
	"Comment": "atomicintegerfieldupdater updateandget updates with supplied function andreturns result.",
	"Method": "void testIntegerFieldUpdaterUpdateAndGet(){\r\n    AtomicIntegerFieldUpdater a = anIntFieldUpdater();\r\n    a.set(this, 1);\r\n    assertEquals(18, a.updateAndGet(this, Atomic8Test::addInt17));\r\n    assertEquals(35, a.updateAndGet(this, Atomic8Test::addInt17));\r\n    assertEquals(35, a.get(this));\r\n    assertEquals(35, anIntField);\r\n}"
}, {
	"Path": "java.time.Duration.minus",
	"Comment": "returns a copy of this duration with the specified duration subtracted.this instance is immutable and unaffected by this method call.",
	"Method": "Duration minus(Duration duration,Duration minus,long amountToSubtract,TemporalUnit unit){\r\n    return (amountToSubtract == Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\r\n}"
}, {
	"Path": "sun.security.util.DerValue.equals",
	"Comment": "bitwise equality comparison.der encoded values have a singleencoding, so that bitwise equality of the encoded values is anefficient way to establish equivalence of the unencoded values.",
	"Method": "boolean equals(Object other,boolean equals,DerValue other){\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (tag != other.tag) {\r\n        return false;\r\n    }\r\n    if (data == other.data) {\r\n        return true;\r\n    }\r\n    return (System.identityHashCode(this.data) > System.identityHashCode(other.data)) ? doEquals(this, other) : doEquals(other, this);\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.toString",
	"Comment": "returns a printable representation of the x509crlselector.",
	"Method": "String toString(){\r\n    StringBuffer sb = new StringBuffer();\r\n    sb.append(\"X509CRLSelector: [\\n\");\r\n    if (issuerNames != null) {\r\n        sb.append(\"  IssuerNames:\\n\");\r\n        Iterator<Object> i = issuerNames.iterator();\r\n        while (i.hasNext()) sb.append(\"    \" + i.next() + \"\\n\");\r\n    }\r\n    if (minCRL != null)\r\n        sb.append(\"  minCRLNumber: \" + minCRL + \"\\n\");\r\n    if (maxCRL != null)\r\n        sb.append(\"  maxCRLNumber: \" + maxCRL + \"\\n\");\r\n    if (dateAndTime != null)\r\n        sb.append(\"  dateAndTime: \" + dateAndTime + \"\\n\");\r\n    if (certChecking != null)\r\n        sb.append(\"  Certificate being checked: \" + certChecking + \"\\n\");\r\n    sb.append(\"]\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "android.icu.dev.test.format.DateFormatTest.TestBadInput135a",
	"Comment": "verify the correct behavior when parsing an array of inputs against anarray of patterns, with known results.the results are encoded afterthe input strings in each row.",
	"Method": "void TestBadInput135a(){\r\n    SimpleDateFormat dateParse = new SimpleDateFormat(\"\", Locale.US);\r\n    final String ss;\r\n    Date date;\r\n    String[] parseFormats = { \"MMMM d, yyyy\", \"MMMM d yyyy\", \"M/d/yy\", \"d MMMM, yyyy\", \"d MMMM yyyy\", \"d MMMM\", \"MMMM d\", \"yyyy\", \"h:mm a MMMM d, yyyy\" };\r\n    String[] inputStrings = { \"bogus string\", null, null, null, null, null, null, null, null, null, \"April 1, 1997\", \"April 1, 1997\", null, null, null, null, null, \"April 1\", null, null, \"Jan 1, 1970\", \"January 1, 1970\", null, null, null, null, null, \"January 1\", null, null, \"Jan 1 2037\", null, \"January 1 2037\", null, null, null, null, \"January 1\", null, null, \"1/1/70\", null, null, \"1/1/70\", null, null, null, null, \"0001\", null, \"5 May 1997\", null, null, null, null, \"5 May 1997\", \"5 May\", null, \"0005\", null, \"16 May\", null, null, null, null, null, \"16 May\", null, \"0016\", null, \"April 30\", null, null, null, null, null, null, \"April 30\", null, null, \"1998\", null, null, null, null, null, null, null, \"1998\", null, \"1\", null, null, null, null, null, null, null, \"0001\", null, \"3:00 pm Jan 1, 1997\", null, null, null, null, null, null, null, \"0003\", \"3:00 PM January 1, 1997\" };\r\n    final int PF_LENGTH = parseFormats.length;\r\n    final int INPUT_LENGTH = inputStrings.length;\r\n    dateParse.applyPattern(\"d MMMM, yyyy\");\r\n    dateParse.setTimeZone(TimeZone.getDefault());\r\n    ss = \"not parseable\";\r\n    logln(\"Trying to parse \\\"\" + ss + \"\\\" with \" + dateParse.toPattern());\r\n    try {\r\n        date = dateParse.parse(ss);\r\n    } catch (Exception ex) {\r\n        logln(\"FAIL:\" + ex);\r\n    }\r\n    for (int i = 0; i < INPUT_LENGTH; i += (PF_LENGTH + 1)) {\r\n        ParsePosition parsePosition = new ParsePosition(0);\r\n        String s = inputStrings[i];\r\n        for (int index = 0; index < PF_LENGTH; ++index) {\r\n            final String expected = inputStrings[i + 1 + index];\r\n            dateParse.applyPattern(parseFormats[index]);\r\n            dateParse.setTimeZone(TimeZone.getDefault());\r\n            try {\r\n                parsePosition.setIndex(0);\r\n                date = dateParse.parse(s, parsePosition);\r\n                if (parsePosition.getIndex() != 0) {\r\n                    String s1, s2;\r\n                    s1 = s.substring(0, parsePosition.getIndex());\r\n                    s2 = s.substring(parsePosition.getIndex(), s.length());\r\n                    if (date == null) {\r\n                        errln(\"ERROR: null result fmt=\\\"\" + parseFormats[index] + \"\\\" pos=\" + parsePosition.getIndex() + \" \" + s1 + \"|\" + s2);\r\n                    } else {\r\n                        String result = ((DateFormat) dateParse).format(date);\r\n                        logln(\"Parsed \\\"\" + s + \"\\\" using \\\"\" + dateParse.toPattern() + \"\\\" to: \" + result);\r\n                        if (expected == null)\r\n                            errln(\"FAIL: Expected parse failure for <\" + result + \">\");\r\n                        else if (!result.equals(expected))\r\n                            errln(\"FAIL: Expected \" + expected);\r\n                    }\r\n                } else if (expected != null) {\r\n                    errln(\"FAIL: Expected \" + expected + \" from \\\"\" + s + \"\\\" with \\\"\" + dateParse.toPattern() + \"\\\"\");\r\n                }\r\n            } catch (Exception ex) {\r\n                logln(\"FAIL:\" + ex);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testConstructorNegativeParties2",
	"Comment": "constructing with a negative number of parties throwsillegalargumentexception",
	"Method": "void testConstructorNegativeParties2(){\r\n    try {\r\n        new Phaser(new Phaser(), -1);\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.PolicyChecker.init",
	"Comment": "initializes the internal state of the checker from parametersspecified in the constructor",
	"Method": "void init(boolean forward){\r\n    if (forward) {\r\n        throw new CertPathValidatorException(\"forward checking not supported\");\r\n    }\r\n    certIndex = 1;\r\n    explicitPolicy = (expPolicyRequired ? 0 : certPathLen + 1);\r\n    policyMapping = (polMappingInhibited ? 0 : certPathLen + 1);\r\n    inhibitAnyPolicy = (anyPolicyInhibited ? 0 : certPathLen + 1);\r\n}"
}, {
	"Path": "javax.net.ssl.TrustManagerFactory.getAlgorithm",
	"Comment": "returns the algorithm name of this trustmanagerfactoryobject.this is the same name that was specified in one of thegetinstance calls that created thistrustmanagerfactory object.",
	"Method": "String getAlgorithm(){\r\n    return this.algorithm;\r\n}"
}, {
	"Path": "java.util.EnumSet.complementOf",
	"Comment": "creates an enum set with the same element type as the specified enumset, initially containing all the elements of this type that arenot contained in the specified set.",
	"Method": "EnumSet<E> complementOf(EnumSet<E> s){\r\n    EnumSet<E> result = copyOf(s);\r\n    result.complement();\r\n    return result;\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testReset_BrokenBarrier",
	"Comment": "a reset of an active barrier causes waiting threads to throwbrokenbarrierexception",
	"Method": "void testReset_BrokenBarrier(){\r\n    final CyclicBarrier c = new CyclicBarrier(3);\r\n    final CountDownLatch pleaseReset = new CountDownLatch(2);\r\n    Thread t1 = new ThreadShouldThrow(BrokenBarrierException.class) {\r\n        public void realRun() throws Exception {\r\n            pleaseReset.countDown();\r\n            c.await();\r\n        }\r\n    };\r\n    Thread t2 = new ThreadShouldThrow(BrokenBarrierException.class) {\r\n        public void realRun() throws Exception {\r\n            pleaseReset.countDown();\r\n            c.await();\r\n        }\r\n    };\r\n    t1.start();\r\n    t2.start();\r\n    await(pleaseReset);\r\n    awaitNumberWaiting(c, 2);\r\n    c.reset();\r\n    awaitTermination(t1);\r\n    awaitTermination(t2);\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testReset_BrokenBarrier",
	"Comment": "a reset of an active barrier causes waiting threads to throwbrokenbarrierexception",
	"Method": "void testReset_BrokenBarrier(){\r\n    pleaseReset.countDown();\r\n    c.await();\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testReset_BrokenBarrier",
	"Comment": "a reset of an active barrier causes waiting threads to throwbrokenbarrierexception",
	"Method": "void testReset_BrokenBarrier(){\r\n    pleaseReset.countDown();\r\n    c.await();\r\n}"
}, {
	"Path": "java.math.BitSieve.retrieve",
	"Comment": "test probable primes in the sieve and return successful candidates.",
	"Method": "BigInteger retrieve(BigInteger initValue,int certainty,java.util.Random random){\r\n    int offset = 1;\r\n    for (int i = 0; i < bits.length; i++) {\r\n        long nextLong = ~bits[i];\r\n        for (int j = 0; j < 64; j++) {\r\n            if ((nextLong & 1) == 1) {\r\n                BigInteger candidate = initValue.add(BigInteger.valueOf(offset));\r\n                if (candidate.primeToCertainty(certainty, random))\r\n                    return candidate;\r\n            }\r\n            nextLong >>>= 1;\r\n            offset += 2;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.dev.test.lang.UnicodeSetTest.checkSpan",
	"Comment": "check that there are no gaps, when we alternate spanning. that is, thereshould only be a zero length span at the very start.",
	"Method": "int checkSpan(String longString,UnicodeSet us,SpanCondition spanCondition){\r\n    int start = 0;\r\n    while (start < longString.length()) {\r\n        int limit = us.span(longString, start, spanCondition);\r\n        if (limit == longString.length()) {\r\n            break;\r\n        } else if (limit == start && start != 0) {\r\n            return start;\r\n        }\r\n        start = limit;\r\n        limit = us.span(longString, start, SpanCondition.NOT_CONTAINED);\r\n        if (limit == start) {\r\n            return start;\r\n        }\r\n        start = limit;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testConstructor1",
	"Comment": "constructor builds new queue with size being zero and emptybeing true",
	"Method": "void testConstructor1(){\r\n    assertEquals(0, new LinkedTransferQueue().size());\r\n    assertTrue(new LinkedTransferQueue().isEmpty());\r\n}"
}, {
	"Path": "jsr166.LinkedTransferQueueTest.testConstructor2",
	"Comment": "initializing constructor with null collection throwsnullpointerexception",
	"Method": "void testConstructor2(){\r\n    try {\r\n        new LinkedTransferQueue(null);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.TreeSubSetTest.testDescendingAddAll3",
	"Comment": "addall of a collection with any null elements throws npe afterpossibly adding some elements",
	"Method": "void testDescendingAddAll3(){\r\n    NavigableSet q = dset0();\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = new Integer(i + SIZE);\r\n    try {\r\n        q.addAll(Arrays.asList(ints));\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testAddIfAbsent2",
	"Comment": "addifabsent adds the element when it does not exist in the list",
	"Method": "void testAddIfAbsent2(){\r\n    CopyOnWriteArrayList full = populatedArray(SIZE);\r\n    full.addIfAbsent(three);\r\n    assertTrue(full.contains(three));\r\n}"
}, {
	"Path": "javax.crypto.ExemptionMechanism.getName",
	"Comment": "returns the exemption mechanism name of thisexemptionmechanism object.this is the same name that was specified in one of thegetinstance calls that created thisexemptionmechanism object.",
	"Method": "String getName(){\r\n    return this.mechanism;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceKeysToInt",
	"Comment": "returns the result of accumulating the given transformationof all keys using the given reducer to combine values, andthe given basis as an identity value.",
	"Method": "int reduceKeysToInt(long parallelismThreshold,ToIntFunction<? super K> transformer,int basis,IntBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceKeysToIntTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testGetWaitQueueLengthIAE",
	"Comment": "getwaitqueuelength throws illegalargumentexception if not owned",
	"Method": "void testGetWaitQueueLengthIAE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    final Mutex sync2 = new Mutex();\r\n    try {\r\n        sync2.getWaitQueueLength(c);\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n    assertHasWaitersUnlocked(sync, c, NO_THREADS);\r\n}"
}, {
	"Path": "com.google.j2objc.AssertTest.testNonEvaluationOfExpression2",
	"Comment": "ensure that jreassert only evaluates expression2 when expression1 is false, in accordance withthe java language specification.",
	"Method": "void testNonEvaluationOfExpression2(){\r\n    assertNull(evaluationResult);\r\n    assert true : \"msg: \" + setMessage(\"error\");\r\n    assertNull(\"evalutationResult should not be set\", evaluationResult);\r\n    try {\r\n        assert false : \"msg: \" + setMessage(\"real error\");\r\n    } catch (AssertionError e) {\r\n        assertEquals(\"msg: real error\", e.getMessage());\r\n    }\r\n    assertEquals(\"real error\", evaluationResult);\r\n    String x = null;\r\n    assert x == null : \"x should be null, but is a string of length \" + x.length();\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testGetWaitQueueLengthIAE",
	"Comment": "getwaitqueuelength throws illegalargumentexception if not owned",
	"Method": "void testGetWaitQueueLengthIAE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    final Mutex sync2 = new Mutex();\r\n    try {\r\n        sync2.getWaitQueueLength(c);\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n    assertHasWaitersUnlocked(sync, c, NO_THREADS);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.MetadataWriter.getFieldModifiers",
	"Comment": "returns the modifiers for a specified field, including internal ones.all method modifiers are defined in the jvm specification, table 4.4.",
	"Method": "int getFieldModifiers(VariableElement var){\r\n    int modifiers = ElementUtil.fromModifierSet(var.getModifiers());\r\n    if (ElementUtil.isSynthetic(var)) {\r\n        modifiers |= ElementUtil.ACC_SYNTHETIC;\r\n    }\r\n    if (ElementUtil.isEnumConstant(var)) {\r\n        modifiers |= ElementUtil.ACC_ENUM;\r\n    }\r\n    return modifiers;\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testHasContended",
	"Comment": "hascontended reports false if no thread has ever blocked, else true",
	"Method": "void testHasContended(){\r\n    final Mutex sync = new Mutex();\r\n    assertFalse(sync.hasContended());\r\n    sync.acquire();\r\n    assertFalse(sync.hasContended());\r\n    Thread t1 = newStartedThread(new InterruptedSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t1);\r\n    assertTrue(sync.hasContended());\r\n    Thread t2 = newStartedThread(new InterruptibleSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t2);\r\n    assertTrue(sync.hasContended());\r\n    t1.interrupt();\r\n    awaitTermination(t1);\r\n    assertTrue(sync.hasContended());\r\n    sync.release();\r\n    awaitTermination(t2);\r\n    assertTrue(sync.hasContended());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.text.ParsePositionTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this method\tis called before a test is executed.",
	"Method": "void setUp(){\r\n    pp = new ParsePosition(Integer.MAX_VALUE);\r\n}"
}, {
	"Path": "java.util.Spliterators.checkFromToBounds",
	"Comment": "validate inclusive start index and exclusive end index against the lengthof an array.",
	"Method": "void checkFromToBounds(int arrayLength,int origin,int fence){\r\n    if (origin > fence) {\r\n        throw new ArrayIndexOutOfBoundsException(\"origin(\" + origin + \") > fence(\" + fence + \")\");\r\n    }\r\n    if (origin < 0) {\r\n        throw new ArrayIndexOutOfBoundsException(origin);\r\n    }\r\n    if (fence > arrayLength) {\r\n        throw new ArrayIndexOutOfBoundsException(fence);\r\n    }\r\n}"
}, {
	"Path": "java.time.format.DateTimeFormatterBuilder.append",
	"Comment": "appends all the elements of a formatter to the builder.this method has the same effect as appending each of the constituentparts of the formatter directly to this builder.",
	"Method": "DateTimeFormatterBuilder append(DateTimeFormatter formatter){\r\n    Objects.requireNonNull(formatter, \"formatter\");\r\n    appendInternal(formatter.toPrinterParser(false));\r\n    return this;\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.packTimes",
	"Comment": "pack the start and end times into an array of bytes.this is requiredas of serial version 2.",
	"Method": "int[] packTimes(){\r\n    int[] times = new int[2];\r\n    times[0] = startTime;\r\n    times[1] = endTime;\r\n    return times;\r\n}"
}, {
	"Path": "okio.SegmentSharingTest.snapshotSegmentsAreNotRecycled",
	"Comment": "snapshots share their backing byte arrays with the source buffers. those byte arrays must notbe recycled, otherwise the new writer could corrupt the segment.",
	"Method": "void snapshotSegmentsAreNotRecycled(){\r\n    Buffer buffer = concatenateBuffers(xs, ys, zs);\r\n    ByteString snapshot = buffer.snapshot();\r\n    assertEquals(xs + ys + zs, snapshot.utf8());\r\n    synchronized (SegmentPool.class) {\r\n        SegmentPool.next = null;\r\n        SegmentPool.byteCount = 0L;\r\n        buffer.clear();\r\n        assertEquals(null, SegmentPool.next);\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.Extension.equals",
	"Comment": "compares this extension for equality with the specifiedobject. if the other object is aninstanceof extension, thenits encoded form is retrieved and compared with theencoded form of this extension.",
	"Method": "boolean equals(Object other){\r\n    if (this == other)\r\n        return true;\r\n    if (!(other instanceof Extension))\r\n        return false;\r\n    Extension otherExt = (Extension) other;\r\n    if (critical != otherExt.critical)\r\n        return false;\r\n    if (!extensionId.equals((Object) otherExt.extensionId))\r\n        return false;\r\n    return Arrays.equals(extensionValue, otherExt.extensionValue);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testTryAcquireSharedNanos",
	"Comment": "tryacquiresharednanos returns after release, but not before",
	"Method": "void testTryAcquireSharedNanos(){\r\n    final BooleanLatch l = new BooleanLatch();\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            assertFalse(l.isSignalled());\r\n            long nanos = MILLISECONDS.toNanos(2 * LONG_DELAY_MS);\r\n            assertTrue(l.tryAcquireSharedNanos(0, nanos));\r\n            assertTrue(l.isSignalled());\r\n            assertTrue(l.tryAcquireSharedNanos(0, nanos));\r\n            assertTrue(l.isSignalled());\r\n        }\r\n    });\r\n    waitForQueuedThread(l, t);\r\n    assertFalse(l.isSignalled());\r\n    assertThreadStaysAlive(t);\r\n    assertTrue(l.releaseShared(0));\r\n    assertTrue(l.isSignalled());\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testTryAcquireSharedNanos",
	"Comment": "tryacquiresharednanos returns after release, but not before",
	"Method": "void testTryAcquireSharedNanos(){\r\n    assertFalse(l.isSignalled());\r\n    long nanos = MILLISECONDS.toNanos(2 * LONG_DELAY_MS);\r\n    assertTrue(l.tryAcquireSharedNanos(0, nanos));\r\n    assertTrue(l.isSignalled());\r\n    assertTrue(l.tryAcquireSharedNanos(0, nanos));\r\n    assertTrue(l.isSignalled());\r\n}"
}, {
	"Path": "javax.crypto.SecretKeyFactory.getAlgorithm",
	"Comment": "returns the algorithm name of this secretkeyfactory object.this is the same name that was specified in one of thegetinstance calls that created thissecretkeyfactory object.",
	"Method": "String getAlgorithm(){\r\n    return this.algorithm;\r\n}"
}, {
	"Path": "android.icu.dev.test.translit.TransliteratorTest.TestSourceTargetSet",
	"Comment": "test the source and target set api.these are only implementedfor rbt and compoundtransliterator at this time.",
	"Method": "void TestSourceTargetSet(){\r\n    String r = \"a > b; \" + \"r [x{lu}] > q;\";\r\n    UnicodeSet expSrc = new UnicodeSet(\"[arx{lu}]\");\r\n    UnicodeSet expTrg = new UnicodeSet(\"[bq]\");\r\n    Transliterator t = Transliterator.createFromRules(\"test\", r, Transliterator.FORWARD);\r\n    UnicodeSet src = t.getSourceSet();\r\n    UnicodeSet trg = t.getTargetSet();\r\n    if (src.equals(expSrc) && trg.equals(expTrg)) {\r\n        logln(\"Ok: \" + r + \" => source = \" + src.toPattern(true) + \", target = \" + trg.toPattern(true));\r\n    } else {\r\n        errln(\"FAIL: \" + r + \" => source = \" + src.toPattern(true) + \", expected \" + expSrc.toPattern(true) + \"; target = \" + trg.toPattern(true) + \", expected \" + expTrg.toPattern(true));\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.Handler.setFormatter",
	"Comment": "set a formatter.this formatter will be usedto format logrecords for this handler.some handlers may not use formatters, inwhich case the formatter will be remembered, but not used.",
	"Method": "void setFormatter(Formatter newFormatter){\r\n    checkPermission();\r\n    newFormatter.getClass();\r\n    formatter = newFormatter;\r\n}"
}, {
	"Path": "java.util.UUID.digits",
	"Comment": "returns val represented by the specified number of hex digits.",
	"Method": "String digits(long val,int digits){\r\n    long hi = 1L << (digits * 4);\r\n    return Long.toHexString(hi | (val & (hi - 1))).substring(1);\r\n}"
}, {
	"Path": "java.util.concurrent.CyclicBarrier.breakBarrier",
	"Comment": "sets current barrier generation as broken and wakes up everyone.called only while holding lock.",
	"Method": "void breakBarrier(){\r\n    generation.broken = true;\r\n    count = parties;\r\n    trip.signalAll();\r\n}"
}, {
	"Path": "jsr166.AtomicLongTest.testAddAndGet",
	"Comment": "addandget adds given value to current, and returns current value",
	"Method": "void testAddAndGet(){\r\n    AtomicLong ai = new AtomicLong(1);\r\n    assertEquals(3, ai.addAndGet(2));\r\n    assertEquals(3, ai.get());\r\n    assertEquals(-1, ai.addAndGet(-4));\r\n    assertEquals(-1, ai.get());\r\n}"
}, {
	"Path": "org.xml.sax.InputSource.getByteStream",
	"Comment": "get the byte stream for this input source.the getencoding method will return the characterencoding for this byte stream, or null if unknown.",
	"Method": "InputStream getByteStream(){\r\n    return byteStream;\r\n}"
}, {
	"Path": "java.net.URL.sameFile",
	"Comment": "compares two urls, excluding the fragment component.returns true if this url and theother argument are equal without taking thefragment component into consideration.",
	"Method": "boolean sameFile(URL other){\r\n    return handler.sameFile(this, other);\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testBeforeAfter",
	"Comment": "beforeexecute and afterexecute are called when executing task",
	"Method": "void testBeforeAfter(){\r\n    ExtendedTPE p = new ExtendedTPE();\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        final CountDownLatch done = new CountDownLatch(1);\r\n        p.execute(new CheckedRunnable() {\r\n            public void realRun() {\r\n                done.countDown();\r\n            }\r\n        });\r\n        await(p.afterCalled);\r\n        assertEquals(0, done.getCount());\r\n        assertTrue(p.afterCalled());\r\n        assertTrue(p.beforeCalled());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testBeforeAfter",
	"Comment": "beforeexecute and afterexecute are called when executing task",
	"Method": "void testBeforeAfter(){\r\n    done.countDown();\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkJoin",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoin(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingCCF f = new LFCCF(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.join();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkJoin",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoin(){\r\n    FailingCCF f = new LFCCF(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.join();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_temporalDayAdjustments",
	"Comment": "test to get the adjusted date from a given date using temporaladjuster methods",
	"Method": "void test_temporalDayAdjustments(){\r\n    HijrahDate date = HijrahDate.of(1554, 7, 21);\r\n    assertEquals(date.with(TemporalAdjusters.firstDayOfMonth()), HijrahDate.of(1554, 7, 1));\r\n    assertEquals(date.with(TemporalAdjusters.lastDayOfMonth()), HijrahDate.of(1554, 7, 29));\r\n    assertEquals(date.with(TemporalAdjusters.firstDayOfNextMonth()), HijrahDate.of(1554, 8, 1));\r\n    assertEquals(date.with(TemporalAdjusters.firstDayOfNextYear()), HijrahDate.of(1555, 1, 1));\r\n    assertEquals(date.with(TemporalAdjusters.firstDayOfYear()), HijrahDate.of(1554, 1, 1));\r\n    assertEquals(date.with(TemporalAdjusters.lastDayOfYear()), HijrahDate.of(1554, 12, 30));\r\n}"
}, {
	"Path": "java.util.OptionalLong.ifPresent",
	"Comment": "have the specified consumer accept the value if a value is present,otherwise do nothing.",
	"Method": "void ifPresent(LongConsumer consumer){\r\n    if (isPresent)\r\n        consumer.accept(value);\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testIntegerFieldUpdaterAccumulateAndGet",
	"Comment": "atomicintegerfieldupdater accumulateandget updates with suppliedfunction and returns result.",
	"Method": "void testIntegerFieldUpdaterAccumulateAndGet(){\r\n    AtomicIntegerFieldUpdater a = anIntFieldUpdater();\r\n    a.set(this, 1);\r\n    assertEquals(7, a.accumulateAndGet(this, 6, Integer::sum));\r\n    assertEquals(10, a.accumulateAndGet(this, 3, Integer::sum));\r\n    assertEquals(10, a.get(this));\r\n    assertEquals(10, anIntField);\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.data_dayOfweek",
	"Comment": "the day of the week varies if the week starts with a saturday or sunday",
	"Method": "Object[][] data_dayOfweek(){\r\n    return new Object[][] { { HijrahDate.of(1434, 6, 24), 1, 7 }, { HijrahDate.of(1432, 9, 3), 5, 4 }, { HijrahDate.of(1334, 12, 29), 7, 6 }, { HijrahDate.of(1354, 5, 24), 1, 7 }, { HijrahDate.of(1465, 10, 2), 2, 1 } };\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testIntValueNegative1",
	"Comment": "convert a negative biginteger to an integer value.the low digit is negative.",
	"Method": "void testIntValueNegative1(){\r\n    byte[] aBytes = { 12, 56, 100, -2, -76, -128, 45, 91, 3 };\r\n    int sign = -1;\r\n    int resInt = 2144511229;\r\n    int aNumber = new BigInteger(sign, aBytes).intValue();\r\n    assertTrue(aNumber == resInt);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testIntValueNegative2",
	"Comment": "convert a negative biginteger to an integer value.the low digit is negative.",
	"Method": "void testIntValueNegative2(){\r\n    byte[] aBytes = { -12, 56, 100 };\r\n    int result = -771996;\r\n    int aNumber = new BigInteger(aBytes).intValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testIntValueNegative3",
	"Comment": "convert a negative biginteger to an integer value. the low digit is positive.",
	"Method": "void testIntValueNegative3(){\r\n    byte[] aBytes = { 12, 56, 100, -2, -76, 127, 45, 91, 3 };\r\n    int sign = -1;\r\n    int resInt = -2133678851;\r\n    int aNumber = new BigInteger(sign, aBytes).intValue();\r\n    assertTrue(aNumber == resInt);\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.packRules",
	"Comment": "pack the start and end rules into an array of bytes.only packdata which is not preserved by makerulescompatible.",
	"Method": "byte[] packRules(){\r\n    byte[] rules = new byte[6];\r\n    rules[0] = (byte) startDay;\r\n    rules[1] = (byte) startDayOfWeek;\r\n    rules[2] = (byte) endDay;\r\n    rules[3] = (byte) endDayOfWeek;\r\n    rules[4] = (byte) startTimeMode;\r\n    rules[5] = (byte) endTimeMode;\r\n    return rules;\r\n}"
}, {
	"Path": "jsr166.FutureTaskTest.testConstructor2",
	"Comment": "creating a future with null runnable throws nullpointerexception",
	"Method": "void testConstructor2(){\r\n    try {\r\n        new FutureTask(null, Boolean.TRUE);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.getNotBefore",
	"Comment": "gets the notbefore date from the validity period of the certificate.",
	"Method": "Date getNotBefore(){\r\n    if (info == null)\r\n        return null;\r\n    try {\r\n        Date d = (Date) info.get(CertificateValidity.NAME + DOT + CertificateValidity.NOT_BEFORE);\r\n        return d;\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testReferenceGetAndAccumulate",
	"Comment": "atomicreference getandaccumulate returns previous value and updateswith supplied function.",
	"Method": "void testReferenceGetAndAccumulate(){\r\n    AtomicReference<Integer> a = new AtomicReference<Integer>(one);\r\n    assertEquals(new Integer(1), a.getAndAccumulate(2, Atomic8Test::sumInteger));\r\n    assertEquals(new Integer(3), a.getAndAccumulate(3, Atomic8Test::sumInteger));\r\n    assertEquals(new Integer(6), a.get());\r\n}"
}, {
	"Path": "java.util.concurrent.ThreadPoolExecutor.setMaximumPoolSize",
	"Comment": "sets the maximum allowed number of threads. this overrides anyvalue set in the constructor. if the new value is smaller thanthe current value, excess existing threads will beterminated when they next become idle.",
	"Method": "void setMaximumPoolSize(int maximumPoolSize){\r\n    if (maximumPoolSize <= 0 || maximumPoolSize < corePoolSize)\r\n        throw new IllegalArgumentException();\r\n    this.maximumPoolSize = maximumPoolSize;\r\n    if (workerCountOf(ctl.get()) > maximumPoolSize)\r\n        interruptIdleWorkers();\r\n}"
}, {
	"Path": "android.icu.dev.test.format.IntlTestDecimalFormatAPIC.findFields",
	"Comment": "finds attributes with regards to char index in thisattributedcharacteriterator, and puts them in a vector",
	"Method": "List<FieldContainer> findFields(AttributedCharacterIterator iterator){\r\n    List<FieldContainer> result = new ArrayList<FieldContainer>();\r\n    while (iterator.getIndex() != iterator.getEndIndex()) {\r\n        int start = iterator.getRunStart();\r\n        int end = iterator.getRunLimit();\r\n        Iterator it = iterator.getAttributes().keySet().iterator();\r\n        while (it.hasNext()) {\r\n            AttributedCharacterIterator.Attribute attribute = (AttributedCharacterIterator.Attribute) it.next();\r\n            Object value = iterator.getAttribute(attribute);\r\n            result.add(new FieldContainer(start, end, attribute, value));\r\n        }\r\n        iterator.setIndex(end);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.dev.test.util.CurrencyTest.TestCurrMetaInfoBaseClass",
	"Comment": "test methods of base class currencymetainfo. icu4j only creates subclasses,never an instance of the base class.",
	"Method": "void TestCurrMetaInfoBaseClass(){\r\n    CurrencyFilter usFilter = CurrencyFilter.onRegion(\"US\");\r\n    assertEquals(\"Empty list expected\", 0, tcurrMetaInfo.currencyInfo(usFilter).size());\r\n    assertEquals(\"Empty list expected\", 0, tcurrMetaInfo.currencies(usFilter).size());\r\n    assertEquals(\"Empty list expected\", 0, tcurrMetaInfo.regions(usFilter).size());\r\n    assertEquals(\"Iso format for digits expected\", \"CurrencyDigits(fractionDigits='2',roundingIncrement='0')\", tcurrMetaInfo.currencyDigits(\"isoCode\").toString());\r\n}"
}, {
	"Path": "okio.SegmentSharingTest.mutateAfterClone",
	"Comment": "even though some segments are shared, clones can be mutated independently.",
	"Method": "void mutateAfterClone(){\r\n    Buffer bufferA = new Buffer();\r\n    bufferA.writeUtf8(\"abc\");\r\n    Buffer bufferB = bufferA.clone();\r\n    bufferA.writeUtf8(\"def\");\r\n    bufferB.writeUtf8(\"DEF\");\r\n    assertEquals(\"abcdef\", bufferA.readUtf8());\r\n    assertEquals(\"abcDEF\", bufferB.readUtf8());\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerTest.testWeakCompareAndSet",
	"Comment": "repeated weakcompareandset succeeds in changing value when equalto expected",
	"Method": "void testWeakCompareAndSet(){\r\n    AtomicInteger ai = new AtomicInteger(1);\r\n    do {\r\n    } while (!ai.weakCompareAndSet(1, 2));\r\n    do {\r\n    } while (!ai.weakCompareAndSet(2, -4));\r\n    assertEquals(-4, ai.get());\r\n    do {\r\n    } while (!ai.weakCompareAndSet(-4, 7));\r\n    assertEquals(7, ai.get());\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testCompleteExceptionallySingleton",
	"Comment": "invoke task throws exception after invoking completeexceptionally",
	"Method": "void testCompleteExceptionallySingleton(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib f = new AsyncFib(8);\r\n            f.completeExceptionally(new FJException());\r\n            try {\r\n                f.invoke();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testCompleteExceptionallySingleton",
	"Comment": "invoke task throws exception after invoking completeexceptionally",
	"Method": "void testCompleteExceptionallySingleton(){\r\n    AsyncFib f = new AsyncFib(8);\r\n    f.completeExceptionally(new FJException());\r\n    try {\r\n        f.invoke();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.X509CertPath.getEncodingsStatic",
	"Comment": "returns the encodings supported by this certification path, with thedefault encoding first.",
	"Method": "Iterator<String> getEncodingsStatic(){\r\n    return encodingList.iterator();\r\n}"
}, {
	"Path": "sun.security.x509.X509CRLImpl.getTBSCertList",
	"Comment": "gets the der encoded crl information, thetbscertlist from this crl.this can be used to verify the signature independently.",
	"Method": "byte[] getTBSCertList(){\r\n    if (tbsCertList == null)\r\n        throw new CRLException(\"Uninitialized CRL\");\r\n    byte[] dup = new byte[tbsCertList.length];\r\n    System.arraycopy(tbsCertList, 0, dup, 0, dup.length);\r\n    return dup;\r\n}"
}, {
	"Path": "sun.security.x509.IssuingDistributionPointExtension.encode",
	"Comment": "encodes the issuing distribution point extension and writes it to thederoutputstream.",
	"Method": "void encode(OutputStream out){\r\n    DerOutputStream tmp = new DerOutputStream();\r\n    if (this.extensionValue == null) {\r\n        this.extensionId = PKIXExtensions.IssuingDistributionPoint_Id;\r\n        this.critical = false;\r\n        encodeThis();\r\n    }\r\n    super.encode(tmp);\r\n    out.write(tmp.toByteArray());\r\n}"
}, {
	"Path": "java.time.format.DateTimeFormatter.withDecimalStyle",
	"Comment": "returns a copy of this formatter with a new decimalstyle.this instance is immutable and unaffected by this method call.",
	"Method": "DateTimeFormatter withDecimalStyle(DecimalStyle decimalStyle){\r\n    if (this.decimalStyle.equals(decimalStyle)) {\r\n        return this;\r\n    }\r\n    return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\r\n}"
}, {
	"Path": "java.util.RegularEnumSet.removeAll",
	"Comment": "removes from this set all of its elements that are contained inthe specified collection.",
	"Method": "boolean removeAll(Collection<?> c){\r\n    if (!(c instanceof RegularEnumSet))\r\n        return super.removeAll(c);\r\n    RegularEnumSet es = (RegularEnumSet) c;\r\n    if (es.elementType != elementType)\r\n        return false;\r\n    long oldElements = elements;\r\n    elements &= ~es.elements;\r\n    return elements != oldElements;\r\n}"
}, {
	"Path": "sun.security.x509.KeyUsageExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(DIGITAL_SIGNATURE);\r\n    elements.addElement(NON_REPUDIATION);\r\n    elements.addElement(KEY_ENCIPHERMENT);\r\n    elements.addElement(DATA_ENCIPHERMENT);\r\n    elements.addElement(KEY_AGREEMENT);\r\n    elements.addElement(KEY_CERTSIGN);\r\n    elements.addElement(CRL_SIGN);\r\n    elements.addElement(ENCIPHER_ONLY);\r\n    elements.addElement(DECIPHER_ONLY);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "java.time.Duration.minusNanos",
	"Comment": "returns a copy of this duration with the specified duration in nanoseconds subtracted.this instance is immutable and unaffected by this method call.",
	"Method": "Duration minusNanos(long nanosToSubtract){\r\n    return (nanosToSubtract == Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanosToSubtract));\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSubMapTest.testDescendingPutIfAbsent2",
	"Comment": "putifabsent does not add the pair if the key is already present",
	"Method": "void testDescendingPutIfAbsent2(){\r\n    ConcurrentNavigableMap map = dmap5();\r\n    assertEquals(\"A\", map.putIfAbsent(m1, \"Z\"));\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testNewSingleThreadScheduledExecutor",
	"Comment": "a newsinglethreadscheduledexecutor successfully runs delayed task",
	"Method": "void testNewSingleThreadScheduledExecutor(){\r\n    final ScheduledExecutorService p = Executors.newSingleThreadScheduledExecutor();\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        final CountDownLatch proceed = new CountDownLatch(1);\r\n        final Runnable task = new CheckedRunnable() {\r\n            public void realRun() {\r\n                await(proceed);\r\n            }\r\n        };\r\n        long startTime = System.nanoTime();\r\n        Future f = p.schedule(Executors.callable(task, Boolean.TRUE), timeoutMillis(), MILLISECONDS);\r\n        assertFalse(f.isDone());\r\n        proceed.countDown();\r\n        assertSame(Boolean.TRUE, f.get(LONG_DELAY_MS, MILLISECONDS));\r\n        assertSame(Boolean.TRUE, f.get());\r\n        assertTrue(f.isDone());\r\n        assertFalse(f.isCancelled());\r\n        assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testNewSingleThreadScheduledExecutor",
	"Comment": "a newsinglethreadscheduledexecutor successfully runs delayed task",
	"Method": "void testNewSingleThreadScheduledExecutor(){\r\n    await(proceed);\r\n}"
}, {
	"Path": "android.icu.dev.util.UnicodeMap.cloneAsThawed",
	"Comment": "standard clone. warning, as with collections, does not do deep clone.",
	"Method": "UnicodeMap<T> cloneAsThawed(){\r\n    UnicodeMap<T> that = new UnicodeMap<T>();\r\n    that.length = length;\r\n    that.transitions = (int[]) transitions.clone();\r\n    that.values = (T[]) values.clone();\r\n    that.availableValues = new LinkedHashSet<T>(availableValues);\r\n    that.locked = false;\r\n    that.stringMap = stringMap == null ? null : (TreeMap<String, T>) stringMap.clone();\r\n    return that;\r\n}"
}, {
	"Path": "java.security.cert.PKIXCertPathValidatorResult.toString",
	"Comment": "return a printable representation of thispkixcertpathvalidatorresult.",
	"Method": "String toString(){\r\n    StringBuffer sb = new StringBuffer();\r\n    sb.append(\"PKIXCertPathValidatorResult: [\\n\");\r\n    sb.append(\"  Trust Anchor: \" + trustAnchor.toString() + \"\\n\");\r\n    sb.append(\"  Policy Tree: \" + String.valueOf(policyTree) + \"\\n\");\r\n    sb.append(\"  Subject Public Key: \" + subjectPublicKey + \"\\n\");\r\n    sb.append(\"]\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "java.security.cert.PKIXParameters.setDate",
	"Comment": "sets the time for which the validity of the certification pathshould be determined. if null, the current time is used.note that the date supplied here is copied to protectagainst subsequent modifications.",
	"Method": "void setDate(Date date){\r\n    if (date != null)\r\n        this.date = (Date) date.clone();\r\n    else\r\n        date = null;\r\n}"
}, {
	"Path": "java.text.SimpleDateFormat.translatePattern",
	"Comment": "translates a pattern, mapping each character in the from string to thecorresponding character in the to string.",
	"Method": "String translatePattern(String pattern,String from,String to){\r\n    StringBuilder result = new StringBuilder();\r\n    boolean inQuote = false;\r\n    for (int i = 0; i < pattern.length(); ++i) {\r\n        char c = pattern.charAt(i);\r\n        if (inQuote) {\r\n            if (c == '\\'')\r\n                inQuote = false;\r\n        } else {\r\n            if (c == '\\'')\r\n                inQuote = true;\r\n            else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\r\n                int ci = from.indexOf(c);\r\n                if (ci >= 0) {\r\n                    if (ci < to.length()) {\r\n                        c = to.charAt(ci);\r\n                    }\r\n                } else {\r\n                    throw new IllegalArgumentException(\"Illegal pattern \" + \" character '\" + c + \"'\");\r\n                }\r\n            }\r\n        }\r\n        result.append(c);\r\n    }\r\n    if (inQuote)\r\n        throw new IllegalArgumentException(\"Unfinished quote in pattern\");\r\n    return result.toString();\r\n}"
}, {
	"Path": "java.util.regex.Matcher.toString",
	"Comment": "returns the string representation of this matcher. thestring representation of a matcher contains informationthat may be useful for debugging. the exact format is unspecified.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"java.util.regex.Matcher\");\r\n    sb.append(\"[pattern=\" + pattern());\r\n    sb.append(\" region=\");\r\n    sb.append(regionStart() + \",\" + regionEnd());\r\n    sb.append(\" lastmatch=\");\r\n    if (matchFound && (group() != null)) {\r\n        sb.append(group());\r\n    }\r\n    sb.append(\"]\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.ObjectiveCHeaderGenerator.popIgnoreNullabilityPragmas",
	"Comment": "restores warnings after a call to pushignorenullabilitypragmas.",
	"Method": "void popIgnoreNullabilityPragmas(){\r\n    if (getGenerationUnit().options().nullability() || getGenerationUnit().hasNullabilityAnnotations()) {\r\n        newline();\r\n        println(\"#if __has_feature(nullability)\");\r\n        println(\"#pragma clang diagnostic pop\");\r\n        println(\"#endif\");\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.util.CollectionUtilities.spanNot",
	"Comment": "returns the ending offset found by matching characters with testset, until a position is found that does match",
	"Method": "int spanNot(CharSequence string,int offset,UnicodeSet testSet){\r\n    while (true) {\r\n        int newOffset = testSet.matchesAt(string, offset);\r\n        if (newOffset >= 0)\r\n            return offset;\r\n        ++offset;\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test424628",
	"Comment": "references to inherited method throws lambdaconversionexception",
	"Method": "void test424628(){\r\n    this.runConformTest(new String[] { \"X.java\", \"public class X {\\n\" + \"    public static interface Consumer<T> {\\n\" + \"        void accept(T t);\\n\" + \"    }\\n\" + \"    \\n\" + \"    public static class Base {\\n\" + \"        public void method () { System.out.println(123); }\\n\" + \"    }\\n\" + \"    public static class Foo extends Base {}\\n\" + \"    public static class Bar extends Base {}\\n\" + \"\\n\" + \"    public static void main (String[] args) {\\n\" + \"        Consumer<Foo> foo = Foo::method;\\n\" + \"        Consumer<Bar> bar = Bar::method;\\n\" + \"        foo.accept(new Foo());\\n\" + \"        bar.accept(new Bar());\\n\" + \"    }\\n\" + \"}\\n\" }, \"123\\n123\");\r\n}"
}, {
	"Path": "java.util.Vector.removeAll",
	"Comment": "removes from this vector all of its elements that are contained in thespecified collection.",
	"Method": "boolean removeAll(Collection<?> c){\r\n    return super.removeAll(c);\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testReferenceAccumulateAndGet",
	"Comment": "atomicreference accumulateandget updates with supplied function andreturns result.",
	"Method": "void testReferenceAccumulateAndGet(){\r\n    AtomicReference<Integer> a = new AtomicReference<Integer>(one);\r\n    assertEquals(new Integer(7), a.accumulateAndGet(6, Atomic8Test::sumInteger));\r\n    assertEquals(new Integer(10), a.accumulateAndGet(3, Atomic8Test::sumInteger));\r\n    assertEquals(new Integer(10), a.get());\r\n}"
}, {
	"Path": "javax.net.ssl.TrustManagerFactory.getInstance",
	"Comment": "returns a trustmanagerfactory object that acts as afactory for trust managers. a new trustmanagerfactory object encapsulating thetrustmanagerfactoryspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "TrustManagerFactory getInstance(String algorithm,TrustManagerFactory getInstance,String algorithm,String provider,TrustManagerFactory getInstance,String algorithm,Provider provider){\r\n    GetInstance.Instance instance = GetInstance.getInstance(\"TrustManagerFactory\", TrustManagerFactorySpi.class, algorithm, provider);\r\n    return new TrustManagerFactory((TrustManagerFactorySpi) instance.impl, instance.provider, algorithm);\r\n}"
}, {
	"Path": "java.math.BigInteger.addOne",
	"Comment": "add one word to the number a mlen words into a. return the resultingcarry.",
	"Method": "int addOne(int[] a,int offset,int mlen,int carry){\r\n    offset = a.length - 1 - mlen - offset;\r\n    long t = (a[offset] & LONG_MASK) + (carry & LONG_MASK);\r\n    a[offset] = (int) t;\r\n    if ((t >>> 32) == 0)\r\n        return 0;\r\n    while (--mlen >= 0) {\r\n        if (--offset < 0) {\r\n            return 1;\r\n        } else {\r\n            a[offset]++;\r\n            if (a[offset] != 0)\r\n                return 0;\r\n        }\r\n    }\r\n    return 1;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.InnerClassExtractorTest.testInnerSubClassOfOtherInnerWithOuterRefsWithGenerics",
	"Comment": "identical sample code to above test, except a is a generic class.",
	"Method": "void testInnerSubClassOfOtherInnerWithOuterRefsWithGenerics(){\r\n    String source = \"public class Test { \" + \"class B extends A<B.BInner> { \" + \"  public class BInner extends A<B.BInner>.Inner { BInner() { super(null); } } } \" + \"class A<T extends A<T>.Inner> { \" + \"  private void foo() { } \" + \"  public class Inner { Inner(T t) { foo(); } } } \" + \"public static void main(String[] args) { B b = new Test().new B(); }}\";\r\n    String translation = translateSourceFile(source, \"Test\", \"Test.m\");\r\n    assertTranslation(translation, \"Test_A_Inner_initWithTest_A_withTest_A_Inner_(self, outer$, nil);\");\r\n}"
}, {
	"Path": "java.io.LineNumberInputStream.skip",
	"Comment": "skips over and discards n bytes of data from thisinput stream. the skip method may, for a variety ofreasons, end up skipping over some smaller number of bytes,possibly 0. the actual number of bytes skipped isreturned.if n is negative, no bytes are skipped.the skip method of linenumberinputstream createsa byte array and then repeatedly reads into it untiln bytes have been read or the end of the stream hasbeen reached.",
	"Method": "long skip(long n){\r\n    int chunk = 2048;\r\n    long remaining = n;\r\n    byte[] data;\r\n    int nr;\r\n    if (n <= 0) {\r\n        return 0;\r\n    }\r\n    data = new byte[chunk];\r\n    while (remaining > 0) {\r\n        nr = read(data, 0, (int) Math.min(chunk, remaining));\r\n        if (nr < 0) {\r\n            break;\r\n        }\r\n        remaining -= nr;\r\n    }\r\n    return n - remaining;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testSaturatedExecute",
	"Comment": "execute throws rejectedexecutionexception if saturated.",
	"Method": "void testSaturatedExecute(){\r\n    final CountDownLatch done = new CountDownLatch(1);\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(1, 1, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(1));\r\n    try (PoolCleaner cleaner = cleaner(p, done)) {\r\n        Runnable task = new CheckedRunnable() {\r\n            public void realRun() throws InterruptedException {\r\n                await(done);\r\n            }\r\n        };\r\n        for (int i = 0; i < 2; ++i) p.execute(task);\r\n        for (int i = 0; i < 2; ++i) {\r\n            try {\r\n                p.execute(task);\r\n                shouldThrow();\r\n            } catch (RejectedExecutionException success) {\r\n            }\r\n            assertTrue(p.getTaskCount() <= 2);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testSaturatedExecute",
	"Comment": "execute throws rejectedexecutionexception if saturated.",
	"Method": "void testSaturatedExecute(){\r\n    await(done);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testForkHelpQuiesce",
	"Comment": "helpquiesce returns when tasks are complete.getqueuedtaskcount returns 0 when quiescent",
	"Method": "void testForkHelpQuiesce(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            AsyncFib f = new AsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            helpQuiesce();\r\n            assertEquals(21, f.number);\r\n            assertEquals(0, getQueuedTaskCount());\r\n            checkCompletedNormally(f);\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testForkHelpQuiesce",
	"Comment": "helpquiesce returns when tasks are complete.getqueuedtaskcount returns 0 when quiescent",
	"Method": "void testForkHelpQuiesce(){\r\n    AsyncFib f = new AsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    helpQuiesce();\r\n    assertEquals(21, f.number);\r\n    assertEquals(0, getQueuedTaskCount());\r\n    checkCompletedNormally(f);\r\n}"
}, {
	"Path": "java.util.Observable.addObserver",
	"Comment": "adds an observer to the set of observers for this object, providedthat it is not the same as some observer already in the set.the order in which notifications will be delivered to multipleobservers is not specified. see the class comment.",
	"Method": "void addObserver(Observer o){\r\n    if (o == null)\r\n        throw new NullPointerException();\r\n    if (!observers.contains(o)) {\r\n        observers.add(o);\r\n    }\r\n}"
}, {
	"Path": "java.lang.ClassLoader.findResource",
	"Comment": "finds the resource with the given name. class loader implementationsshould override this method to specify where to find resources.",
	"Method": "URL findResource(String name,URL findResource,String name){\r\n    return null;\r\n}"
}, {
	"Path": "java.net.DatagramPacket.setAddress",
	"Comment": "sets the ip address of the machine to which this datagramis being sent.",
	"Method": "void setAddress(InetAddress iaddr){\r\n    address = iaddr;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.NameTable.getVariableQualifiedName",
	"Comment": "gets the name of the variable as it is declared in objc, fully qualified.",
	"Method": "String getVariableQualifiedName(VariableElement var){\r\n    String shortName = getVariableShortName(var);\r\n    if (ElementUtil.isGlobalVar(var)) {\r\n        String className = getFullName(ElementUtil.getDeclaringClass(var));\r\n        if (ElementUtil.isEnumConstant(var)) {\r\n            return \"JreEnum(\" + className + \", \" + shortName + \")\";\r\n        }\r\n        return className + '_' + shortName;\r\n    }\r\n    return shortName;\r\n}"
}, {
	"Path": "sun.security.x509.AlgorithmId.derEncode",
	"Comment": "der encode this object onto an output stream.implements the derencoder interface.",
	"Method": "void derEncode(OutputStream out){\r\n    DerOutputStream bytes = new DerOutputStream();\r\n    DerOutputStream tmp = new DerOutputStream();\r\n    bytes.putOID(algid);\r\n    if (constructedFromDer == false) {\r\n        if (algParams != null) {\r\n            params = new DerValue(algParams.getEncoded());\r\n        } else {\r\n            params = null;\r\n        }\r\n    }\r\n    if (params == null) {\r\n        bytes.putNull();\r\n    } else {\r\n        bytes.putDerValue(params);\r\n    }\r\n    tmp.write(DerValue.tag_Sequence, bytes);\r\n    out.write(tmp.toByteArray());\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinPool.toString",
	"Comment": "returns a string identifying this pool, as well as its state,including indications of run state, parallelism level, andworker and task counts.",
	"Method": "String toString(){\r\n    long qt = 0L, qs = 0L;\r\n    int rc = 0;\r\n    AuxState sc = auxState;\r\n    long st = (sc == null) ? 0L : sc.stealCount;\r\n    long c = ctl;\r\n    WorkQueue[] ws;\r\n    WorkQueue w;\r\n    if ((ws = workQueues) != null) {\r\n        for (int i = 0; i < ws.length; ++i) {\r\n            if ((w = ws[i]) != null) {\r\n                int size = w.queueSize();\r\n                if ((i & 1) == 0)\r\n                    qs += size;\r\n                else {\r\n                    qt += size;\r\n                    st += w.nsteals;\r\n                    if (w.isApparentlyUnblocked())\r\n                        ++rc;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    int pc = (config & SMASK);\r\n    int tc = pc + (short) (c >>> TC_SHIFT);\r\n    int ac = pc + (int) (c >> AC_SHIFT);\r\n    if (ac < 0)\r\n        ac = 0;\r\n    int rs = runState;\r\n    String level = ((rs & TERMINATED) != 0 ? \"Terminated\" : (rs & STOP) != 0 ? \"Terminating\" : (rs & SHUTDOWN) != 0 ? \"Shutting down\" : \"Running\");\r\n    return super.toString() + \"[\" + level + \", parallelism = \" + pc + \", size = \" + tc + \", active = \" + ac + \", running = \" + rc + \", steals = \" + st + \", tasks = \" + qt + \", submissions = \" + qs + \"]\";\r\n}"
}, {
	"Path": "sun.security.util.DerValue.getDataBytes",
	"Comment": "helper routine to return all the bytes contained in thederinputstream associated with this object.",
	"Method": "byte[] getDataBytes(){\r\n    byte[] retVal = new byte[length];\r\n    synchronized (data) {\r\n        data.reset();\r\n        data.getBytes(retVal);\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "sun.security.x509.X509CRLImpl.getRevokedCertificate",
	"Comment": "gets the crl entry with the given serial number from this crl.",
	"Method": "X509CRLEntry getRevokedCertificate(BigInteger serialNumber,X509CRLEntry getRevokedCertificate,X509Certificate cert){\r\n    if (revokedMap.isEmpty()) {\r\n        return null;\r\n    }\r\n    X509IssuerSerial issuerSerial = new X509IssuerSerial(cert);\r\n    return revokedMap.get(issuerSerial);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerDivideTest.testCase6",
	"Comment": "divide two positive numbers of the same length.the second is greater.",
	"Method": "void testCase6(){\r\n    byte[] aBytes = { 1, 100, 56, 7, 98, -1, 39, -128, 127 };\r\n    byte[] bBytes = { 15, 100, 56, 7, 98, -1, 39, -128, 127 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 0 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.divide(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 0, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerDivideTest.testCase5",
	"Comment": "divide two numbers of different length and different signs.the second is longer.",
	"Method": "void testCase5(){\r\n    byte[] aBytes = { -127, 100, 56, 7, 98, -1, 39, -128, 127 };\r\n    byte[] bBytes = { -127, 100, 56, 7, 98, -1, 39, -128, 127, 1, 2, 3, 4, 5 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 0 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.divide(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 0, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerDivideTest.testCase4",
	"Comment": "divide two equal in absolute value numbers of different signs.",
	"Method": "void testCase4(){\r\n    byte[] aBytes = { -127, 100, 56, 7, 98, -1, 39, -128, 127 };\r\n    byte[] bBytes = { -127, 100, 56, 7, 98, -1, 39, -128, 127 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -1 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.divide(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "java.util.Vector.ensureCapacityHelper",
	"Comment": "this implements the unsynchronized semantics of ensurecapacity.synchronized methods in this class can internally call thismethod for ensuring capacity without incurring the cost of anextra synchronization.",
	"Method": "void ensureCapacityHelper(int minCapacity){\r\n    if (minCapacity - elementData.length > 0)\r\n        grow(minCapacity);\r\n}"
}, {
	"Path": "sun.security.util.DerInputStream.getPrintableString",
	"Comment": "read a string that was encoded as a printablestring der value.",
	"Method": "String getPrintableString(){\r\n    return readString(DerValue.tag_PrintableString, \"Printable\", \"ASCII\");\r\n}"
}, {
	"Path": "java.util.Collections.reverse",
	"Comment": "reverses the order of the elements in the specified list.this method runs in linear time.",
	"Method": "void reverse(List<?> list){\r\n    int size = list.size();\r\n    if (size < REVERSE_THRESHOLD || list instanceof RandomAccess) {\r\n        for (int i = 0, mid = size >> 1, j = size - 1; i < mid; i++, j--) swap(list, i, j);\r\n    } else {\r\n        ListIterator fwd = list.listIterator();\r\n        ListIterator rev = list.listIterator(size);\r\n        for (int i = 0, mid = list.size() >> 1; i < mid; i++) {\r\n            Object tmp = fwd.next();\r\n            fwd.set(rev.previous());\r\n            rev.set(tmp);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testGetParties",
	"Comment": "getparties returns the number of parties given in constructor",
	"Method": "void testGetParties(){\r\n    CyclicBarrier b = new CyclicBarrier(2);\r\n    assertEquals(2, b.getParties());\r\n    assertEquals(0, b.getNumberWaiting());\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.getInternationalCurrencySymbol",
	"Comment": "returns the iso 4217 currency code of the currency of thesedecimalformatsymbols.",
	"Method": "String getInternationalCurrencySymbol(){\r\n    return intlCurrencySymbol;\r\n}"
}, {
	"Path": "java.util.ComparableTimSort.gallopRight",
	"Comment": "like gallopleft, except that if the range contains an element equal tokey, gallopright returns the index after the rightmost equal element.",
	"Method": "int gallopRight(Comparable<Object> key,Object[] a,int base,int len,int hint){\r\n    assert len > 0 && hint >= 0 && hint < len;\r\n    int ofs = 1;\r\n    int lastOfs = 0;\r\n    if (key.compareTo(a[base + hint]) < 0) {\r\n        int maxOfs = hint + 1;\r\n        while (ofs < maxOfs && key.compareTo(a[base + hint - ofs]) < 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        int tmp = lastOfs;\r\n        lastOfs = hint - ofs;\r\n        ofs = hint - tmp;\r\n    } else {\r\n        int maxOfs = len - hint;\r\n        while (ofs < maxOfs && key.compareTo(a[base + hint + ofs]) >= 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        lastOfs += hint;\r\n        ofs += hint;\r\n    }\r\n    assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;\r\n    lastOfs++;\r\n    while (lastOfs < ofs) {\r\n        int m = lastOfs + ((ofs - lastOfs) >>> 1);\r\n        if (key.compareTo(a[base + m]) < 0)\r\n            ofs = m;\r\n        else\r\n            lastOfs = m + 1;\r\n    }\r\n    assert lastOfs == ofs;\r\n    return ofs;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesNegative1",
	"Comment": "create a negative number from a sign and an array of bytes.the number fits in an array of integers.the most significant byte is positive.",
	"Method": "void testConstructorSignBytesNegative1(){\r\n    byte[] aBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3, -15 };\r\n    int aSign = -1;\r\n    byte[] rBytes = { -13, -57, -101, 1, 75, -90, -46, -92, -4, 15 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesNegative2",
	"Comment": "create a negative number from a sign and an array of bytes.the number fits in an array of integers.the most significant byte is negative.",
	"Method": "void testConstructorSignBytesNegative2(){\r\n    byte[] aBytes = { -12, 56, 100, -2, -76, 89, 45, 91, 3, -15 };\r\n    int aSign = -1;\r\n    byte[] rBytes = { -1, 11, -57, -101, 1, 75, -90, -46, -92, -4, 15 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesNegative5",
	"Comment": "create a negative number from a sign and an array of bytes.the number of bytes is 4.the most significant byte is negative.",
	"Method": "void testConstructorSignBytesNegative5(){\r\n    byte[] aBytes = { -127, 56, 100, -2 };\r\n    int aSign = -1;\r\n    byte[] rBytes = { -1, 126, -57, -101, 2 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesNegative6",
	"Comment": "create a negative number from a sign and an array of bytes.the number of bytes is multiple of 4.the most significant byte is positive.",
	"Method": "void testConstructorSignBytesNegative6(){\r\n    byte[] aBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 23, -101 };\r\n    int aSign = -1;\r\n    byte[] rBytes = { -13, -57, -101, 1, 75, -90, -46, -92, -4, 14, -24, 101 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesNegative3",
	"Comment": "create a negative number from a sign and an array of bytes.the number fits in an integer.",
	"Method": "void testConstructorSignBytesNegative3(){\r\n    byte[] aBytes = { -12, 56, 100 };\r\n    int aSign = -1;\r\n    byte[] rBytes = { -1, 11, -57, -100 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesNegative4",
	"Comment": "create a negative number from a sign and an array of bytes.the number of bytes is 4.the most significant byte is positive.",
	"Method": "void testConstructorSignBytesNegative4(){\r\n    byte[] aBytes = { 127, 56, 100, -2 };\r\n    int aSign = -1;\r\n    byte[] rBytes = { -128, -57, -101, 2 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "java.time.Duration.minusMinutes",
	"Comment": "returns a copy of this duration with the specified duration in minutes subtracted.the number of hours is multiplied by 60 to obtain the number of seconds to subtract.this instance is immutable and unaffected by this method call.",
	"Method": "Duration minusMinutes(long minutesToSubtract){\r\n    return (minutesToSubtract == Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutesToSubtract));\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesNegative7",
	"Comment": "create a negative number from a sign and an array of bytes.the number of bytes is multiple of 4.the most significant byte is negative.",
	"Method": "void testConstructorSignBytesNegative7(){\r\n    byte[] aBytes = { -12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 23, -101 };\r\n    int aSign = -1;\r\n    byte[] rBytes = { -1, 11, -57, -101, 1, 75, -90, -46, -92, -4, 14, -24, 101 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "javax.crypto.CipherInputStream.read",
	"Comment": "reads up to len bytes of data from this input streaminto an array of bytes. this method blocks until some input isavailable. if the first argument is null, up tolen bytes are read and discarded.",
	"Method": "int read(int read,byte b,int read,byte b,int off,int len){\r\n    if (ostart >= ofinish) {\r\n        int i = 0;\r\n        while (i == 0) i = getMoreData();\r\n        if (i == -1)\r\n            return -1;\r\n    }\r\n    if (len <= 0) {\r\n        return 0;\r\n    }\r\n    int available = ofinish - ostart;\r\n    if (len < available)\r\n        available = len;\r\n    if (b != null) {\r\n        System.arraycopy(obuffer, ostart, b, off, available);\r\n    }\r\n    ostart = ostart + available;\r\n    return available;\r\n}"
}, {
	"Path": "java.security.cert.PKIXParameters.getCertStores",
	"Comment": "returns an immutable list of certstores thatare used to find certificates and crls.",
	"Method": "List<CertStore> getCertStores(){\r\n    return Collections.unmodifiableList(new ArrayList<CertStore>(this.certStores));\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this one.these mappings replace any mappings that this map had for any of thekeys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> m){\r\n    tryPresize(m.size());\r\n    for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) putVal(e.getKey(), e.getValue(), false);\r\n}"
}, {
	"Path": "java.util.stream.AbstractPipeline.sourceSpliterator",
	"Comment": "get the source spliterator for this pipeline stage.for a sequential orstateless parallel pipeline, this is the source spliterator.for astateful parallel pipeline, this is a spliterator describing the resultsof all computations up to and including the most recent statefuloperation.",
	"Method": "Spliterator<?> sourceSpliterator(int terminalFlags){\r\n    Spliterator<?> spliterator = null;\r\n    if (sourceStage.sourceSpliterator != null) {\r\n        spliterator = sourceStage.sourceSpliterator;\r\n        sourceStage.sourceSpliterator = null;\r\n    } else if (sourceStage.sourceSupplier != null) {\r\n        spliterator = (Spliterator<?>) sourceStage.sourceSupplier.get();\r\n        sourceStage.sourceSupplier = null;\r\n    } else {\r\n        throw new IllegalStateException(MSG_CONSUMED);\r\n    }\r\n    if (isParallel() && sourceStage.sourceAnyStateful) {\r\n        int depth = 1;\r\n        for (@SuppressWarnings(\"rawtypes\") AbstractPipeline u = sourceStage, p = sourceStage.nextStage, e = this; u != e; u = p, p = p.nextStage) {\r\n            int thisOpFlags = p.sourceOrOpFlags;\r\n            if (p.opIsStateful()) {\r\n                depth = 0;\r\n                if (StreamOpFlag.SHORT_CIRCUIT.isKnown(thisOpFlags)) {\r\n                    thisOpFlags = thisOpFlags & ~StreamOpFlag.IS_SHORT_CIRCUIT;\r\n                }\r\n                spliterator = p.opEvaluateParallelLazy(u, spliterator);\r\n                thisOpFlags = spliterator.hasCharacteristics(Spliterator.SIZED) ? (thisOpFlags & ~StreamOpFlag.NOT_SIZED) | StreamOpFlag.IS_SIZED : (thisOpFlags & ~StreamOpFlag.IS_SIZED) | StreamOpFlag.NOT_SIZED;\r\n            }\r\n            p.depth = depth++;\r\n            p.combinedFlags = StreamOpFlag.combineOpFlags(thisOpFlags, u.combinedFlags);\r\n        }\r\n    }\r\n    if (terminalFlags != 0) {\r\n        combinedFlags = StreamOpFlag.combineOpFlags(terminalFlags, combinedFlags);\r\n    }\r\n    return spliterator;\r\n}"
}, {
	"Path": "java.security.Signature.getAlgorithm",
	"Comment": "returns the name of the algorithm for this signature object.",
	"Method": "String getAlgorithm(){\r\n    return this.algorithm;\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.divWord",
	"Comment": "this method divides a long quantity by an int to estimateqhat for two multi precision numbers. it is used whenthe signed value of n is less than zero.returns long value where high 32 bits contain remainder value andlow 32 bits contain quotient value.",
	"Method": "long divWord(long n,int d){\r\n    long dLong = d & LONG_MASK;\r\n    long r;\r\n    long q;\r\n    if (dLong == 1) {\r\n        q = (int) n;\r\n        r = 0;\r\n        return (r << 32) | (q & LONG_MASK);\r\n    }\r\n    q = (n >>> 1) / (dLong >>> 1);\r\n    r = n - q * dLong;\r\n    while (r < 0) {\r\n        r += dLong;\r\n        q--;\r\n    }\r\n    while (r >= dLong) {\r\n        r -= dLong;\r\n        q++;\r\n    }\r\n    return (r << 32) | (q & LONG_MASK);\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.getExtendedKeyUsage",
	"Comment": "this static method is the default implementation of thegetextendedkeyusage method in x509certificate. ax509certificate provider generally should overwrite this toprovide among other things caching for better performance.",
	"Method": "List<String> getExtendedKeyUsage(List<String> getExtendedKeyUsage,X509Certificate cert){\r\n    try {\r\n        byte[] ext = cert.getExtensionValue(EXTENDED_KEY_USAGE_OID);\r\n        if (ext == null)\r\n            return null;\r\n        DerValue val = new DerValue(ext);\r\n        byte[] data = val.getOctetString();\r\n        ExtendedKeyUsageExtension ekuExt = new ExtendedKeyUsageExtension(Boolean.FALSE, data);\r\n        return Collections.unmodifiableList(ekuExt.getExtendedKeyUsage());\r\n    } catch (IOException ioe) {\r\n        throw new CertificateParsingException(ioe);\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.BuildStep.toString",
	"Comment": "return a string representation of this build step, showing minimaldetail.",
	"Method": "String toString(){\r\n    String out = \"Internal Error\\n\";\r\n    switch(result) {\r\n        case BACK:\r\n        case FAIL:\r\n            out = resultToString(result);\r\n            out = out + vertex.throwableToString();\r\n            break;\r\n        case FOLLOW:\r\n        case SUCCEED:\r\n        case POSSIBLE:\r\n            out = resultToString(result);\r\n            break;\r\n        default:\r\n            out = \"Internal Error: Invalid step result\\n\";\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testAbnormalQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvoke(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() {\r\n            FailingFibTask f = new FailingFibTask(8);\r\n            f.quietlyInvoke();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(mainPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testAbnormalQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvoke(){\r\n    FailingFibTask f = new FailingFibTask(8);\r\n    f.quietlyInvoke();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n    return NoResult;\r\n}"
}, {
	"Path": "java.net.URL.writeObject",
	"Comment": "writeobject is called to save the state of the url to anobjectoutputstream. the handler is not saved since it isspecific to this system.",
	"Method": "void writeObject(java.io.ObjectOutputStream s){\r\n    s.defaultWriteObject();\r\n}"
}, {
	"Path": "java.text.DecimalFormat.getMaximumFractionDigits",
	"Comment": "gets the maximum number of digits allowed in the fraction portion of anumber.for formatting numbers other than biginteger andbigdecimal objects, the lower of the return value and340 is used.",
	"Method": "int getMaximumFractionDigits(){\r\n    return maximumFractionDigits;\r\n}"
}, {
	"Path": "java.io.CharArrayReader.reset",
	"Comment": "resets the stream to the most recent mark, or to the beginning if it hasnever been marked.",
	"Method": "void reset(){\r\n    synchronized (lock) {\r\n        ensureOpen();\r\n        pos = markedPos;\r\n    }\r\n}"
}, {
	"Path": "java.text.DecimalFormat.getMinimumIntegerDigits",
	"Comment": "gets the minimum number of digits allowed in the integer portion of anumber.for formatting numbers other than biginteger andbigdecimal objects, the lower of the return value and309 is used.",
	"Method": "int getMinimumIntegerDigits(){\r\n    return minimumIntegerDigits;\r\n}"
}, {
	"Path": "java.util.concurrent.CountedCompleter.exec",
	"Comment": "implements execution conventions for countedcompleters.",
	"Method": "boolean exec(){\r\n    compute();\r\n    return false;\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicLongFieldUpdater.incrementAndGet",
	"Comment": "atomically increments by one the current value of the field of thegiven object managed by this updater.",
	"Method": "long incrementAndGet(T obj,long incrementAndGet,T obj){\r\n    long prev, next;\r\n    do {\r\n        prev = get(obj);\r\n        next = prev + 1;\r\n    } while (!compareAndSet(obj, prev, next));\r\n    return next;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.DateFormatTest.TestGetPatternInstance",
	"Comment": "tests the method public final static dateformat getpatterninstance",
	"Method": "void TestGetPatternInstance(){\r\n    try {\r\n        @SuppressWarnings(\"unused\")\r\n        DateFormat df = DateFormat.getPatternInstance(\"\");\r\n        df = DateFormat.getPatternInstance(\"\", new Locale(\"en_US\"));\r\n        df = DateFormat.getPatternInstance(null, \"\", new Locale(\"en_US\"));\r\n    } catch (Exception e) {\r\n        errln(\"DateFormat.getPatternInstance is not suppose to return an exception.\");\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.X509CRLEntry.getCertificateIssuer",
	"Comment": "get the issuer of the x509certificate described by this entry. ifthe certificate issuer is also the crl issuer, this method returnsnull.this method is used with indirect crls. the default implementationalways returns null. subclasses that wish to support indirect crlsshould override it.",
	"Method": "X500Principal getCertificateIssuer(){\r\n    return null;\r\n}"
}, {
	"Path": "java.math.BigInteger.getLower",
	"Comment": "returns a new biginteger representing n lower ints of the number.this is used by karatsuba multiplication and karatsuba squaring.",
	"Method": "BigInteger getLower(int n){\r\n    int len = mag.length;\r\n    if (len <= n) {\r\n        return abs();\r\n    }\r\n    int[] lowerInts = new int[n];\r\n    System.arraycopy(mag, len - n, lowerInts, 0, n);\r\n    return new BigInteger(trustedStripLeadingZeroInts(lowerInts), 1);\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testConstructorNegativeParties",
	"Comment": "constructing with a negative number of parties throwsillegalargumentexception",
	"Method": "void testConstructorNegativeParties(){\r\n    try {\r\n        new Phaser(-1);\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinTask.getQueuedTaskCount",
	"Comment": "returns an estimate of the number of tasks that have beenforked by the current worker thread but not yet executed. thisvalue may be useful for heuristic decisions about whether tofork other tasks.",
	"Method": "int getQueuedTaskCount(){\r\n    Thread t;\r\n    ForkJoinPool.WorkQueue q;\r\n    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\r\n        q = ((ForkJoinWorkerThread) t).workQueue;\r\n    else\r\n        q = ForkJoinPool.commonSubmitterQueue();\r\n    return (q == null) ? 0 : q.queueSize();\r\n}"
}, {
	"Path": "java.net.HttpRetryException.getReason",
	"Comment": "returns a string explaining why the http request couldnot be retried.",
	"Method": "String getReason(){\r\n    return super.getMessage();\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.text.DecimalFormatSymbolsTest.test_RIHarmony_compatible",
	"Comment": "assert that harmony can correct read an instance that was created bythe java 1.5 ri. the actual values may differ on harmony and other jres,so we only assert the values that are known to be in the serialized data.",
	"Method": "void test_RIHarmony_compatible(){\r\n    DecimalFormatSymbols dfs;\r\n    ObjectInputStream i = null;\r\n    try {\r\n        i = new ObjectInputStream(getClass().getClassLoader().getResourceAsStream(\"serialization/org/apache/harmony/tests/java/text/DecimalFormatSymbols.ser\"));\r\n        dfs = (DecimalFormatSymbols) i.readObject();\r\n    } finally {\r\n        try {\r\n            if (i != null) {\r\n                i.close();\r\n            }\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    assertDecimalFormatSymbolsRIFrance(dfs);\r\n}"
}, {
	"Path": "java.security.Provider.values",
	"Comment": "returns an unmodifiable collection view of the property valuescontained in this provider.",
	"Method": "Collection<Object> values(){\r\n    checkInitialized();\r\n    return Collections.unmodifiableCollection(super.values());\r\n}"
}, {
	"Path": "sun.nio.ch.Util.releaseTemporaryDirectBuffer",
	"Comment": "releases a temporary buffer by returning to the cache or freeing it.",
	"Method": "void releaseTemporaryDirectBuffer(ByteBuffer buf){\r\n    offerFirstTemporaryDirectBuffer(buf);\r\n}"
}, {
	"Path": "java.math.BigInteger.smallToString",
	"Comment": "this method is used to perform tostring when arguments are small.",
	"Method": "String smallToString(int radix){\r\n    if (signum == 0) {\r\n        return \"0\";\r\n    }\r\n    int maxNumDigitGroups = (4 * mag.length + 6) / 7;\r\n    String[] digitGroup = new String[maxNumDigitGroups];\r\n    BigInteger tmp = this.abs();\r\n    int numGroups = 0;\r\n    while (tmp.signum != 0) {\r\n        BigInteger d = longRadix[radix];\r\n        MutableBigInteger q = new MutableBigInteger(), a = new MutableBigInteger(tmp.mag), b = new MutableBigInteger(d.mag);\r\n        MutableBigInteger r = a.divide(b, q);\r\n        BigInteger q2 = q.toBigInteger(tmp.signum * d.signum);\r\n        BigInteger r2 = r.toBigInteger(tmp.signum * d.signum);\r\n        digitGroup[numGroups++] = Long.toString(r2.longValue(), radix);\r\n        tmp = q2;\r\n    }\r\n    StringBuilder buf = new StringBuilder(numGroups * digitsPerLong[radix] + 1);\r\n    if (signum < 0) {\r\n        buf.append('-');\r\n    }\r\n    buf.append(digitGroup[numGroups - 1]);\r\n    for (int i = numGroups - 2; i >= 0; i--) {\r\n        int numLeadingZeros = digitsPerLong[radix] - digitGroup[i].length();\r\n        if (numLeadingZeros != 0) {\r\n            buf.append(zeros[numLeadingZeros]);\r\n        }\r\n        buf.append(digitGroup[i]);\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "java.lang.Package.getImplementationVersion",
	"Comment": "return the version of this implementation. it consists of any stringassigned by the vendor of this implementation and doesnot have any particular syntax specified or expected by the javaruntime. it may be compared for equality with otherpackage version strings used for this implementationby this vendor for this package.",
	"Method": "String getImplementationVersion(){\r\n    return implVersion;\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testInterruptedTimedPollLast",
	"Comment": "interrupted timed polllast throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPollLast(){\r\n    final LinkedBlockingDeque q = populatedDeque(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            long startTime = System.nanoTime();\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(SIZE - i - 1, q.pollLast(LONG_DELAY_MS, MILLISECONDS));\r\n            }\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.pollLast(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.pollLast(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadStaysAlive(t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testInterruptedTimedPollLast",
	"Comment": "interrupted timed polllast throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPollLast(){\r\n    long startTime = System.nanoTime();\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(SIZE - i - 1, q.pollLast(LONG_DELAY_MS, MILLISECONDS));\r\n    }\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.pollLast(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.pollLast(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n}"
}, {
	"Path": "java.util.TimSort.mergeForceCollapse",
	"Comment": "merges all runs on the stack until only one remains.this method iscalled once, to complete the sort.",
	"Method": "void mergeForceCollapse(){\r\n    while (stackSize > 1) {\r\n        int n = stackSize - 2;\r\n        if (n > 0 && runLen[n - 1] < runLen[n + 1])\r\n            n--;\r\n        mergeAt(n);\r\n    }\r\n}"
}, {
	"Path": "jsr166.AtomicLongArrayTest.testGetAndSet",
	"Comment": "getandset returns previous value and sets to given value at given index",
	"Method": "void testGetAndSet(){\r\n    AtomicLongArray aa = new AtomicLongArray(SIZE);\r\n    for (int i = 0; i < SIZE; i++) {\r\n        aa.set(i, 1);\r\n        assertEquals(1, aa.getAndSet(i, 0));\r\n        assertEquals(0, aa.getAndSet(i, -10));\r\n        assertEquals(-10, aa.getAndSet(i, 1));\r\n    }\r\n}"
}, {
	"Path": "java.util.function.IntUnaryOperator.identity",
	"Comment": "returns a unary operator that always returns its input argument.",
	"Method": "IntUnaryOperator identity(){\r\n    return t -> t;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testDoubleValueNegRounded2",
	"Comment": "convert a positive number to a double value. rounding is needed.the rounding bit is 1 and the next bit to the left is 0but some of dropped bits are 1s.",
	"Method": "void testDoubleValueNegRounded2(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, 36, 23, 1, -3, -5 };\r\n    int aSign = -1;\r\n    double result = -1.547472643879479E26;\r\n    double aNumber = new BigInteger(aSign, a).doubleValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.TypeDeclarationGeneratorTest.testMethodSignatureMappingWithParameters",
	"Comment": "verify that generated source mappings are correct for methods that take arguments.",
	"Method": "void testMethodSignatureMappingWithParameters(){\r\n    String source = \"class A { void zebra(int foo, int bar) {} }\";\r\n    CompilationUnit compilationUnit = translateType(\"A\", source);\r\n    GeneratedType generatedType = GeneratedType.fromTypeDeclaration(compilationUnit.getTypes().get(0));\r\n    GeneratedSourceMappings mappings = generatedType.getGeneratedSourceMappings();\r\n    boolean foundZebra = false;\r\n    for (GeneratedSourceMappings.Mapping mapping : mappings.getMappings()) {\r\n        if (mapping.getIdentifier().equals(\"zebra\")) {\r\n            foundZebra = true;\r\n            assertEquals(\"zebra\", source.substring(mapping.getSourceBegin(), mapping.getSourceEnd()));\r\n            assertEquals(\"zebraWithInt\", generatedType.getPublicDeclarationCode().substring(mapping.getTargetBegin(), mapping.getTargetEnd()));\r\n        }\r\n    }\r\n    if (!foundZebra) {\r\n        fail(\"No mapping found for zebra(int, int) method\");\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testDoubleValueNegRounded1",
	"Comment": "convert a positive number to a double value. rounding is needed.",
	"Method": "void testDoubleValueNegRounded1(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = -1;\r\n    double result = -1.54747264387948E26;\r\n    double aNumber = new BigInteger(aSign, a).doubleValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "java.sql.Timestamp.before",
	"Comment": "indicates whether this timestamp object isearlier than the given timestamp object.",
	"Method": "boolean before(Timestamp ts){\r\n    return compareTo(ts) < 0;\r\n}"
}, {
	"Path": "java.security.cert.X509CRLEntry.hashCode",
	"Comment": "returns a hashcode value for this crl entry from itsencoded form.",
	"Method": "int hashCode(){\r\n    int retval = 0;\r\n    try {\r\n        byte[] entryData = this.getEncoded();\r\n        for (int i = 1; i < entryData.length; i++) retval += entryData[i] * i;\r\n    } catch (CRLException ce) {\r\n        return (retval);\r\n    }\r\n    return (retval);\r\n}"
}, {
	"Path": "java.util.concurrent.ThreadPoolExecutor.getQueue",
	"Comment": "returns the task queue used by this executor. access to thetask queue is intended primarily for debugging and monitoring.this queue may be in active use.retrieving the task queuedoes not prevent queued tasks from executing.",
	"Method": "BlockingQueue<Runnable> getQueue(){\r\n    return workQueue;\r\n}"
}, {
	"Path": "sun.security.x509.CertificateX509Key.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(KEY);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "jsr166.AtomicLongFieldUpdaterTest.testCompareAndSetProtected",
	"Comment": "compareandset succeeds in changing protected field value ifequal to expected else fails",
	"Method": "void testCompareAndSetProtected(){\r\n    AtomicLongFieldUpdater<AtomicLongFieldUpdaterTest> a;\r\n    a = updaterFor(\"protectedField\");\r\n    protectedField = 1;\r\n    assertTrue(a.compareAndSet(this, 1, 2));\r\n    assertTrue(a.compareAndSet(this, 2, -4));\r\n    assertEquals(-4, a.get(this));\r\n    assertFalse(a.compareAndSet(this, -5, 7));\r\n    assertEquals(-4, a.get(this));\r\n    assertTrue(a.compareAndSet(this, -4, 7));\r\n    assertEquals(7, a.get(this));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testPollNextLocalTask",
	"Comment": "pollnextlocaltask returns most recent unexecuted taskwithout executing it",
	"Method": "void testPollNextLocalTask(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() {\r\n            FibTask g = new FibTask(9);\r\n            assertSame(g, g.fork());\r\n            FibTask f = new FibTask(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(f, pollNextLocalTask());\r\n            helpQuiesce();\r\n            checkNotDone(f);\r\n            checkCompletedNormally(g, 34);\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(singletonPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testPollNextLocalTask",
	"Comment": "pollnextlocaltask returns most recent unexecuted taskwithout executing it",
	"Method": "void testPollNextLocalTask(){\r\n    FibTask g = new FibTask(9);\r\n    assertSame(g, g.fork());\r\n    FibTask f = new FibTask(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(f, pollNextLocalTask());\r\n    helpQuiesce();\r\n    checkNotDone(f);\r\n    checkCompletedNormally(g, 34);\r\n    return NoResult;\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testSubList1_IndexOutOfBoundsException",
	"Comment": "sublist throws an indexoutofboundsexception on a negative index",
	"Method": "void testSubList1_IndexOutOfBoundsException(){\r\n    CopyOnWriteArrayList c = populatedArray(5);\r\n    List[] lists = { c, c.subList(1, c.size() - 1) };\r\n    for (List list : lists) {\r\n        try {\r\n            list.subList(-1, list.size());\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicIntegerFieldUpdater.getAndSet",
	"Comment": "atomically sets the field of the given object managed by this updaterto the given value and returns the old value.",
	"Method": "int getAndSet(T obj,int newValue,int getAndSet,T obj,int newValue){\r\n    int prev;\r\n    do {\r\n        prev = get(obj);\r\n    } while (!compareAndSet(obj, prev, newValue));\r\n    return prev;\r\n}"
}, {
	"Path": "java.net.MulticastSocket.setInterface",
	"Comment": "set the multicast network interface used by methodswhose behavior would be affected by the value of thenetwork interface. useful for multihomed hosts.",
	"Method": "void setInterface(InetAddress inf){\r\n    if (isClosed()) {\r\n        throw new SocketException(\"Socket is closed\");\r\n    }\r\n    checkAddress(inf, \"setInterface\");\r\n    synchronized (infLock) {\r\n        getImpl().setOption(SocketOptions.IP_MULTICAST_IF, inf);\r\n        infAddress = inf;\r\n        interfaceSet = true;\r\n    }\r\n}"
}, {
	"Path": "jsr166.DelayQueueTest.testInterruptedTimedPoll",
	"Comment": "interrupted timed poll throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPoll(){\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    final DelayQueue q = populatedQueue(SIZE);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            long startTime = System.nanoTime();\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(new PDelay(i), ((PDelay) q.poll(LONG_DELAY_MS, MILLISECONDS)));\r\n            }\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadStaysAlive(t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "jsr166.DelayQueueTest.testInterruptedTimedPoll",
	"Comment": "interrupted timed poll throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPoll(){\r\n    long startTime = System.nanoTime();\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(new PDelay(i), ((PDelay) q.poll(LONG_DELAY_MS, MILLISECONDS)));\r\n    }\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n}"
}, {
	"Path": "java.util.zip.Inflater.needsDictionary",
	"Comment": "returns true if a preset dictionary is needed for decompression.",
	"Method": "boolean needsDictionary(){\r\n    synchronized (zsRef) {\r\n        return needDict;\r\n    }\r\n}"
}, {
	"Path": "java.math.BigDecimal.inflated",
	"Comment": "returns appropriate biginteger from intval field if intval isnull, i.e. the compact representation is in use.",
	"Method": "BigInteger inflated(){\r\n    if (intVal == null) {\r\n        return BigInteger.valueOf(intCompact);\r\n    }\r\n    return intVal;\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.getPercentString",
	"Comment": "gets the string used for percent sign. different for arabic, etc.",
	"Method": "String getPercentString(){\r\n    return String.valueOf(percent);\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.unpackTimes",
	"Comment": "unpack the start and end times from an array of bytes.this is requiredas of serial version 2.",
	"Method": "void unpackTimes(int[] times){\r\n    startTime = times[0];\r\n    endTime = times[1];\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testAbnormalForkJoin",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoin(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingFibAction f = new FailingFibAction(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.join();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testAbnormalForkJoin",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoin(){\r\n    FailingFibAction f = new FailingFibAction(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.join();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n}"
}, {
	"Path": "libcore.reflect.GenericSignatureParser.parseForClass",
	"Comment": "parses the generic signature of a class and creates the data structurerepresenting the signature.",
	"Method": "void parseForClass(GenericDeclaration genericDecl,String signature){\r\n    setInput(genericDecl, signature);\r\n    if (!eof) {\r\n        parseClassSignature();\r\n    } else {\r\n        if (genericDecl instanceof Class) {\r\n            Class c = (Class) genericDecl;\r\n            this.formalTypeParameters = EmptyArray.TYPE_VARIABLE;\r\n            this.superclassType = c.getSuperclass();\r\n            Class<?>[] interfaces = c.getInterfaces();\r\n            if (interfaces.length == 0) {\r\n                this.interfaceTypes = ListOfTypes.EMPTY;\r\n            } else {\r\n                this.interfaceTypes = new ListOfTypes(interfaces);\r\n            }\r\n        } else {\r\n            this.formalTypeParameters = EmptyArray.TYPE_VARIABLE;\r\n            this.superclassType = Object.class;\r\n            this.interfaceTypes = ListOfTypes.EMPTY;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.misc.FormattedFloatingDecimal.getExponentRounded",
	"Comment": "returns the exponent after rounding has been done by applyprecision",
	"Method": "int getExponentRounded(){\r\n    return decExponentRounded - 1;\r\n}"
}, {
	"Path": "java.security.spec.ECFieldFp.getFieldSize",
	"Comment": "returns the field size in bits which is size of prime pfor this prime finite field.",
	"Method": "int getFieldSize(){\r\n    return p.bitLength();\r\n}"
}, {
	"Path": "java.time.Duration.minusMillis",
	"Comment": "returns a copy of this duration with the specified duration in milliseconds subtracted.this instance is immutable and unaffected by this method call.",
	"Method": "Duration minusMillis(long millisToSubtract){\r\n    return (millisToSubtract == Long.MIN_VALUE ? plusMillis(Long.MAX_VALUE).plusMillis(1) : plusMillis(-millisToSubtract));\r\n}"
}, {
	"Path": "sun.util.calendar.AbstractCalendar.getDayOfWeekDateBefore",
	"Comment": "returns a date of the given day of week before the given fixeddate.",
	"Method": "long getDayOfWeekDateBefore(long fixedDate,int dayOfWeek){\r\n    return getDayOfWeekDateOnOrBefore(fixedDate - 1, dayOfWeek);\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.getDSTSavings",
	"Comment": "returns the amount of time in milliseconds that the clock isadvanced during daylight saving time.",
	"Method": "int getDSTSavings(){\r\n    return useDaylight ? dstSavings : 0;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.TypeDeclarationGeneratorTest.testConstructorMapping",
	"Comment": "verify that generated source mappings are correct for constructors.",
	"Method": "void testConstructorMapping(){\r\n    String source = \"class MyClass { public MyClass() {} }\";\r\n    CompilationUnit compilationUnit = translateType(\"MyClass\", source);\r\n    GeneratedType generatedType = GeneratedType.fromTypeDeclaration(compilationUnit.getTypes().get(0));\r\n    GeneratedSourceMappings mappings = generatedType.getGeneratedSourceMappings();\r\n    boolean foundType = false;\r\n    for (GeneratedSourceMappings.Mapping mapping : mappings.getMappings()) {\r\n        if (mapping.getIdentifier().equals(\"<init>\")) {\r\n            foundType = true;\r\n            assertEquals(\"MyClass\", source.substring(mapping.getSourceBegin(), mapping.getSourceEnd()));\r\n            assertEquals(\"init\", generatedType.getPublicDeclarationCode().substring(mapping.getTargetBegin(), mapping.getTargetEnd()));\r\n        }\r\n    }\r\n    if (!foundType) {\r\n        fail(\"No mapping found for MyClass() constructor\");\r\n    }\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.setExponentialSymbol",
	"Comment": "sets the character used to separate the mantissa from the exponent.",
	"Method": "void setExponentialSymbol(char exp){\r\n    exponential = exp;\r\n}"
}, {
	"Path": "sun.security.util.DerInputStream.getPositiveBigInteger",
	"Comment": "returns an asn.1 integer value as a positive biginteger.this is just to deal with implementations that incorrectly encodesome values as negative.",
	"Method": "BigInteger getPositiveBigInteger(){\r\n    if (buffer.read() != DerValue.tag_Integer) {\r\n        throw new IOException(\"DER input, Integer tag error\");\r\n    }\r\n    return buffer.getBigInteger(getLength(buffer), true);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.DestructorGeneratorTest.testFieldReleaseARC",
	"Comment": "verify fields are not released for arc code, and a dealloc method is not created.",
	"Method": "void testFieldReleaseARC(){\r\n    options.setMemoryManagementOption(Options.MemoryManagementOption.ARC);\r\n    String translation = translateSourceFile(\"class Test { Object o; Runnable r; }\", \"Test\", \"Test.m\");\r\n    assertNotInTranslation(translation, \"dealloc\");\r\n}"
}, {
	"Path": "jsr166.JSR166TestCase.newStartedThread",
	"Comment": "returns a new started daemon thread running the given runnable.",
	"Method": "Thread newStartedThread(Runnable runnable){\r\n    Thread t = new Thread(runnable);\r\n    t.setDaemon(true);\r\n    t.start();\r\n    return t;\r\n}"
}, {
	"Path": "java.net.Proxy.address",
	"Comment": "returns the socket address of the proxy, ornull if its a direct connection.",
	"Method": "SocketAddress address(){\r\n    return sa;\r\n}"
}, {
	"Path": "jsr166.AtomicStampedReferenceTest.testCompareAndSetInMultipleThreads2",
	"Comment": "compareandset in one thread enables another waiting for stamp valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads2(){\r\n    final AtomicStampedReference ai = new AtomicStampedReference(one, 0);\r\n    Thread t = new Thread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!ai.compareAndSet(one, one, 1, 2)) Thread.yield();\r\n        }\r\n    });\r\n    t.start();\r\n    assertTrue(ai.compareAndSet(one, one, 0, 1));\r\n    t.join(LONG_DELAY_MS);\r\n    assertFalse(t.isAlive());\r\n    assertSame(one, ai.getReference());\r\n    assertEquals(2, ai.getStamp());\r\n}"
}, {
	"Path": "jsr166.AtomicStampedReferenceTest.testCompareAndSetInMultipleThreads2",
	"Comment": "compareandset in one thread enables another waiting for stamp valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads2(){\r\n    while (!ai.compareAndSet(one, one, 1, 2)) Thread.yield();\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.testEntryImmutability",
	"Comment": "lowerentry, higherentry, ceilingentry, and floorentry returnimmutable entries",
	"Method": "void testEntryImmutability(){\r\n    ConcurrentSkipListMap map = map5();\r\n    Map.Entry e = map.lowerEntry(three);\r\n    assertEquals(two, e.getKey());\r\n    try {\r\n        e.setValue(\"X\");\r\n        shouldThrow();\r\n    } catch (UnsupportedOperationException success) {\r\n    }\r\n    e = map.higherEntry(zero);\r\n    assertEquals(one, e.getKey());\r\n    try {\r\n        e.setValue(\"X\");\r\n        shouldThrow();\r\n    } catch (UnsupportedOperationException success) {\r\n    }\r\n    e = map.floorEntry(one);\r\n    assertEquals(one, e.getKey());\r\n    try {\r\n        e.setValue(\"X\");\r\n        shouldThrow();\r\n    } catch (UnsupportedOperationException success) {\r\n    }\r\n    e = map.ceilingEntry(five);\r\n    assertEquals(five, e.getKey());\r\n    try {\r\n        e.setValue(\"X\");\r\n        shouldThrow();\r\n    } catch (UnsupportedOperationException success) {\r\n    }\r\n}"
}, {
	"Path": "java.security.GuardedObject.getObject",
	"Comment": "retrieves the guarded object, or throws an exception if accessto the guarded object is denied by the guard.",
	"Method": "Object getObject(){\r\n    if (guard != null)\r\n        guard.checkGuard(object);\r\n    return object;\r\n}"
}, {
	"Path": "org.xml.sax.InputSource.setCharacterStream",
	"Comment": "set the character stream for this input source.if there is a character stream specified, the sax parserwill ignore any byte stream and will not attempt to opena uri connection to the system identifier.",
	"Method": "void setCharacterStream(Reader characterStream){\r\n    this.characterStream = characterStream;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberFormatTest.TestNPEIssue11914",
	"Comment": "testing for issue 11914, missing fieldpositions for some field types.",
	"Method": "void TestNPEIssue11914(){\r\n    List<FieldContainer> v1 = new ArrayList<FieldContainer>(7);\r\n    v1.add(new FieldContainer(0, 3, NumberFormat.Field.INTEGER));\r\n    v1.add(new FieldContainer(3, 4, NumberFormat.Field.GROUPING_SEPARATOR));\r\n    v1.add(new FieldContainer(4, 7, NumberFormat.Field.INTEGER));\r\n    v1.add(new FieldContainer(7, 8, NumberFormat.Field.GROUPING_SEPARATOR));\r\n    v1.add(new FieldContainer(8, 11, NumberFormat.Field.INTEGER));\r\n    v1.add(new FieldContainer(11, 12, NumberFormat.Field.DECIMAL_SEPARATOR));\r\n    v1.add(new FieldContainer(12, 15, NumberFormat.Field.FRACTION));\r\n    Number number = new Double(123456789.9753);\r\n    ULocale usLoc = new ULocale(\"en-US\");\r\n    DecimalFormatSymbols US = new DecimalFormatSymbols(usLoc);\r\n    NumberFormat outFmt = NumberFormat.getNumberInstance(usLoc);\r\n    String numFmtted = outFmt.format(number);\r\n    AttributedCharacterIterator iterator = outFmt.formatToCharacterIterator(number);\r\n    CompareAttributedCharacterFormatOutput(iterator, v1, numFmtted);\r\n    List<FieldContainer> v2 = new ArrayList<FieldContainer>(7);\r\n    v2.add(new FieldContainer(0, 1, NumberFormat.Field.INTEGER));\r\n    v2.add(new FieldContainer(1, 2, NumberFormat.Field.DECIMAL_SEPARATOR));\r\n    v2.add(new FieldContainer(2, 5, NumberFormat.Field.FRACTION));\r\n    v2.add(new FieldContainer(5, 6, NumberFormat.Field.EXPONENT_SYMBOL));\r\n    v2.add(new FieldContainer(6, 7, NumberFormat.Field.EXPONENT_SIGN));\r\n    v2.add(new FieldContainer(7, 8, NumberFormat.Field.EXPONENT));\r\n    DecimalFormat fmt2 = new DecimalFormat(\"0.###E+0\", US);\r\n    numFmtted = fmt2.format(number);\r\n    iterator = fmt2.formatToCharacterIterator(number);\r\n    CompareAttributedCharacterFormatOutput(iterator, v2, numFmtted);\r\n    List<FieldContainer> v3 = new ArrayList<FieldContainer>(7);\r\n    v3.add(new FieldContainer(0, 1, NumberFormat.Field.SIGN));\r\n    v3.add(new FieldContainer(1, 2, NumberFormat.Field.INTEGER));\r\n    v3.add(new FieldContainer(2, 3, NumberFormat.Field.GROUPING_SEPARATOR));\r\n    v3.add(new FieldContainer(3, 6, NumberFormat.Field.INTEGER));\r\n    v3.add(new FieldContainer(6, 7, NumberFormat.Field.GROUPING_SEPARATOR));\r\n    v3.add(new FieldContainer(7, 10, NumberFormat.Field.INTEGER));\r\n    v3.add(new FieldContainer(10, 11, NumberFormat.Field.GROUPING_SEPARATOR));\r\n    v3.add(new FieldContainer(11, 14, NumberFormat.Field.INTEGER));\r\n    v3.add(new FieldContainer(14, 15, NumberFormat.Field.GROUPING_SEPARATOR));\r\n    v3.add(new FieldContainer(15, 18, NumberFormat.Field.INTEGER));\r\n    v3.add(new FieldContainer(18, 19, NumberFormat.Field.GROUPING_SEPARATOR));\r\n    v3.add(new FieldContainer(19, 22, NumberFormat.Field.INTEGER));\r\n    v3.add(new FieldContainer(22, 23, NumberFormat.Field.GROUPING_SEPARATOR));\r\n    v3.add(new FieldContainer(23, 26, NumberFormat.Field.INTEGER));\r\n    BigInteger bigNumberInt = new BigInteger(\"-1234567890246813579\");\r\n    String fmtNumberBigInt = outFmt.format(bigNumberInt);\r\n    iterator = outFmt.formatToCharacterIterator(bigNumberInt);\r\n    CompareAttributedCharacterFormatOutput(iterator, v3, fmtNumberBigInt);\r\n    List<FieldContainer> v4 = new ArrayList<FieldContainer>(7);\r\n    v4.add(new FieldContainer(0, 1, NumberFormat.Field.SIGN));\r\n    v4.add(new FieldContainer(1, 2, NumberFormat.Field.INTEGER));\r\n    v4.add(new FieldContainer(2, 3, NumberFormat.Field.DECIMAL_SEPARATOR));\r\n    v4.add(new FieldContainer(3, 6, NumberFormat.Field.FRACTION));\r\n    v4.add(new FieldContainer(6, 7, NumberFormat.Field.EXPONENT_SYMBOL));\r\n    v4.add(new FieldContainer(7, 8, NumberFormat.Field.EXPONENT_SIGN));\r\n    v4.add(new FieldContainer(8, 9, NumberFormat.Field.EXPONENT));\r\n    java.math.BigDecimal numberBigD = new java.math.BigDecimal(-123456789);\r\n    String fmtNumberBigDExp = fmt2.format(numberBigD);\r\n    iterator = fmt2.formatToCharacterIterator(numberBigD);\r\n    CompareAttributedCharacterFormatOutput(iterator, v4, fmtNumberBigDExp);\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testGetKeepAliveTime",
	"Comment": "getkeepalivetime returns value given in constructor if not otherwise set",
	"Method": "void testGetKeepAliveTime(){\r\n    final ThreadPoolExecutor p = new CustomTPE(2, 2, 1000, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertEquals(1, p.getKeepAliveTime(SECONDS));\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getCertificateValid",
	"Comment": "returns the certificatevalid criterion. the specified date must fallwithin the certificate validity period for thex509certificate. if null, no certificatevalidcheck will be done.note that the date returned is cloned to protect againstsubsequent modifications.",
	"Method": "Date getCertificateValid(){\r\n    if (certificateValid == null) {\r\n        return null;\r\n    }\r\n    return (Date) certificateValid.clone();\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testAddAll1_IndexOutOfBoundsException",
	"Comment": "addall throws an indexoutofboundsexception on a negative index",
	"Method": "void testAddAll1_IndexOutOfBoundsException(){\r\n    CopyOnWriteArrayList c = populatedArray(5);\r\n    List[] lists = { c, c.subList(1, c.size() - 1) };\r\n    for (List list : lists) {\r\n        try {\r\n            list.addAll(-1, new LinkedList());\r\n            shouldThrow();\r\n        } catch (IndexOutOfBoundsException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkQuietlyJoin",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoin(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingAsyncFib f = new FailingAsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            f.quietlyJoin();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkQuietlyJoin",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoin(){\r\n    FailingAsyncFib f = new FailingAsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    f.quietlyJoin();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n}"
}, {
	"Path": "java.net.URL.readObject",
	"Comment": "readobject is called to restore the state of the url from thestream.it reads the components of the url and finds the localstream handler.",
	"Method": "void readObject(java.io.ObjectInputStream s){\r\n    s.defaultReadObject();\r\n    if ((handler = getURLStreamHandler(protocol)) == null) {\r\n        throw new IOException(\"unknown protocol: \" + protocol);\r\n    }\r\n    if (authority == null && ((host != null && host.length() > 0) || port != -1)) {\r\n        if (host == null)\r\n            host = \"\";\r\n        authority = (port == -1) ? host : host + \":\" + port;\r\n        int at = host.lastIndexOf('@');\r\n        if (at != -1) {\r\n            userInfo = host.substring(0, at);\r\n            host = host.substring(at + 1);\r\n        }\r\n    } else if (authority != null) {\r\n        int ind = authority.indexOf('@');\r\n        if (ind != -1)\r\n            userInfo = authority.substring(0, ind);\r\n    }\r\n    path = null;\r\n    query = null;\r\n    if (file != null) {\r\n        int q = file.lastIndexOf('?');\r\n        if (q != -1) {\r\n            query = file.substring(q + 1);\r\n            path = file.substring(0, q);\r\n        } else\r\n            path = file;\r\n    }\r\n    hashCode = -1;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.TypeDeclarationGeneratorTest.testStaticFieldAccessorMethods",
	"Comment": "verify that accessor methods for static vars and constants are generated on request.",
	"Method": "void testStaticFieldAccessorMethods(){\r\n    options.setStaticAccessorMethods(true);\r\n    String source = \"class Test { \" + \"static String ID; \" + \"private static int i; \" + \"static final Test DEFAULT = new Test(); \" + \"static boolean DEBUG; }\";\r\n    String translation = translateSourceFile(source, \"Test\", \"Test.h\");\r\n    assertTranslation(translation, \"+ (NSString *)ID;\");\r\n    assertTranslation(translation, \"+ (void)setID:(NSString *)value;\");\r\n    assertTranslation(translation, \"+ (Test *)DEFAULT;\");\r\n    assertTranslation(translation, \"+ (jboolean)DEBUG_;\");\r\n    assertTranslation(translation, \"+ (void)setDEBUG_:(jboolean)value\");\r\n    assertNotInTranslation(translation, \"+ (jint)i\");\r\n    assertNotInTranslation(translation, \"+ (void)setI:(jint)value\");\r\n    assertNotInTranslation(translation, \"+ (void)setDEFAULT:(Test *)value\");\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.ErrorUtil.setTestMode",
	"Comment": "to be called by unit tests. in test mode errors and warnings are notprinted to system.err.",
	"Method": "void setTestMode(){\r\n    errorStream = new PrintStream(new OutputStream() {\r\n        @Override\r\n        public void write(int b) {\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.ErrorUtil.setTestMode",
	"Comment": "to be called by unit tests. in test mode errors and warnings are notprinted to system.err.",
	"Method": "void setTestMode(){\r\n}"
}, {
	"Path": "java.net.InMemoryCookieStore.getURIs",
	"Comment": "get all uris, which are associated with at least one cookieof this cookie store.",
	"Method": "List<URI> getURIs(){\r\n    List<URI> uris = new ArrayList<URI>();\r\n    lock.lock();\r\n    try {\r\n        List<URI> result = new ArrayList<URI>(uriIndex.keySet());\r\n        result.remove(null);\r\n        return Collections.unmodifiableList(result);\r\n    } finally {\r\n        uris.addAll(uriIndex.keySet());\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.Test_UmmAlQuraChronoRange",
	"Comment": "ummalqura chronology ranges for year, month and days for the hijrahchronology",
	"Method": "void Test_UmmAlQuraChronoRange(){\r\n    HijrahChronology chrono = HijrahChronology.INSTANCE;\r\n    ValueRange year = chrono.range(YEAR);\r\n    assertEquals(year.getMinimum(), 1300, \"Minimum year\");\r\n    assertEquals(year.getLargestMinimum(), 1300, \"Largest minimum year\");\r\n    assertEquals(year.getMaximum(), 1600, \"Largest year\");\r\n    assertEquals(year.getSmallestMaximum(), 1600, \"Smallest Maximum year\");\r\n    ValueRange month = chrono.range(MONTH_OF_YEAR);\r\n    assertEquals(month.getMinimum(), 1, \"Minimum month\");\r\n    assertEquals(month.getLargestMinimum(), 1, \"Largest minimum month\");\r\n    assertEquals(month.getMaximum(), 12, \"Largest month\");\r\n    assertEquals(month.getSmallestMaximum(), 12, \"Smallest Maximum month\");\r\n    ValueRange day = chrono.range(DAY_OF_MONTH);\r\n    assertEquals(day.getMinimum(), 1, \"Minimum day\");\r\n    assertEquals(day.getLargestMinimum(), 1, \"Largest minimum day\");\r\n    assertEquals(day.getMaximum(), 30, \"Largest day\");\r\n    assertEquals(day.getSmallestMaximum(), 29, \"Smallest Maximum day\");\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test432531",
	"Comment": "inside of lambda expression in the superclass constructor call",
	"Method": "void test432531(){\r\n    this.runConformTest(new String[] { \"Y.java\", \"import java.util.function.Supplier;\\n\" + \"class E {\\n\" + \" E(Supplier<Object> factory) { }\\n\" + \"}\\n\" + \"public class Y extends E {\\n\" + \" Y() {\\n\" + \"   super(() -> new Object() {\\n\" + \"   });\\n\" + \" }\\n\" + \" public static void main(String[] args) {\\n\" + \"   new Y();\\n\" + \" }\\n\" + \"}\" });\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testSaturatedExecute4",
	"Comment": "executor using discardoldestpolicy drops oldest task if saturated.",
	"Method": "void testSaturatedExecute4(){\r\n    final CountDownLatch done = new CountDownLatch(1);\r\n    LatchAwaiter r1 = awaiter(done);\r\n    LatchAwaiter r2 = awaiter(done);\r\n    LatchAwaiter r3 = awaiter(done);\r\n    final ThreadPoolExecutor p = new CustomTPE(1, 1, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(1), new CustomTPE.DiscardOldestPolicy());\r\n    try (PoolCleaner cleaner = cleaner(p, done)) {\r\n        assertEquals(LatchAwaiter.NEW, r1.state);\r\n        assertEquals(LatchAwaiter.NEW, r2.state);\r\n        assertEquals(LatchAwaiter.NEW, r3.state);\r\n        p.execute(r1);\r\n        p.execute(r2);\r\n        assertTrue(p.getQueue().contains(r2));\r\n        p.execute(r3);\r\n        assertFalse(p.getQueue().contains(r2));\r\n        assertTrue(p.getQueue().contains(r3));\r\n    }\r\n    assertEquals(LatchAwaiter.DONE, r1.state);\r\n    assertEquals(LatchAwaiter.NEW, r2.state);\r\n    assertEquals(LatchAwaiter.DONE, r3.state);\r\n}"
}, {
	"Path": "javax.net.ssl.HttpsURLConnection.getSSLSocketFactory",
	"Comment": "gets the ssl socket factory to be used when creating socketsfor secure https url connections.",
	"Method": "SSLSocketFactory getSSLSocketFactory(){\r\n    return sslSocketFactory;\r\n}"
}, {
	"Path": "java.util.EnumSet.range",
	"Comment": "creates an enum set initially containing all of the elements in therange defined by the two specified endpoints.the returned set willcontain the endpoints themselves, which may be identical but must notbe out of order.",
	"Method": "EnumSet<E> range(E from,E to){\r\n    if (from.compareTo(to) > 0)\r\n        throw new IllegalArgumentException(from + \" > \" + to);\r\n    EnumSet<E> result = noneOf(from.getDeclaringClass());\r\n    result.addRange(from, to);\r\n    return result;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.BasicChecker.init",
	"Comment": "initializes the internal state of the checker from parametersspecified in the constructor.",
	"Method": "void init(boolean forward){\r\n    if (!forward) {\r\n        prevPubKey = trustedPubKey;\r\n        if (PKIX.isDSAPublicKeyWithoutParams(prevPubKey)) {\r\n            throw new CertPathValidatorException(\"Key parameters missing\");\r\n        }\r\n        prevSubject = caName;\r\n    } else {\r\n        throw new CertPathValidatorException(\"forward checking not supported\");\r\n    }\r\n}"
}, {
	"Path": "java.util.LinkedList.isPositionIndex",
	"Comment": "tells if the argument is the index of a valid position for aniterator or an add operation.",
	"Method": "boolean isPositionIndex(int index){\r\n    return index >= 0 && index <= size;\r\n}"
}, {
	"Path": "java.security.cert.CertificateFactorySpi.engineGetCertPathEncodings",
	"Comment": "returns an iteration of the certpath encodings supportedby this certificate factory, with the default encoding first. seethe certpath encodings section in the java cryptography architecture standard algorithm name documentationfor information about standard encoding names.attempts to modify the returned iterator via itsremove method result in anunsupportedoperationexception. this method was added to version 1.4 of the java 2 platformstandard edition. in order to maintain backwards compatibility withexisting service providers, this method cannot be abstractand by default throws an unsupportedoperationexception.",
	"Method": "Iterator<String> engineGetCertPathEncodings(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "android.icu.dev.test.timezone.TimeZoneRuleTest.TestVTimeZoneSimpleWrite",
	"Comment": "write out simple time zone rules from an olsontimezone at various time into vtimezoneformat and create a new vtimezone from the vtimezone data, then make sure the raw offsetand dst savings are same in these two time zones.",
	"Method": "void TestVTimeZoneSimpleWrite(){\r\n    long[] testTimes = new long[] { getUTCMillis(2006, Calendar.JANUARY, 1), getUTCMillis(2006, Calendar.MARCH, 15), getUTCMillis(2006, Calendar.MARCH, 31), getUTCMillis(2006, Calendar.APRIL, 5), getUTCMillis(2006, Calendar.OCTOBER, 25), getUTCMillis(2006, Calendar.NOVEMBER, 1), getUTCMillis(2006, Calendar.NOVEMBER, 5), getUTCMillis(2007, Calendar.JANUARY, 1) };\r\n    String[] tzids = getTestZIDs();\r\n    for (int n = 0; n < testTimes.length; n++) {\r\n        long time = testTimes[n];\r\n        int[] offsets1 = new int[2];\r\n        int[] offsets2 = new int[2];\r\n        for (int i = 0; i < tzids.length; i++) {\r\n            VTimeZone vtz_org = VTimeZone.create(tzids[i]);\r\n            VTimeZone vtz_new = null;\r\n            try {\r\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                OutputStreamWriter writer = new OutputStreamWriter(baos);\r\n                vtz_org.writeSimple(writer, time);\r\n                writer.close();\r\n                byte[] vtzdata = baos.toByteArray();\r\n                ByteArrayInputStream bais = new ByteArrayInputStream(vtzdata);\r\n                InputStreamReader reader = new InputStreamReader(bais);\r\n                vtz_new = VTimeZone.create(reader);\r\n                reader.close();\r\n            } catch (IOException ioe) {\r\n                errln(\"FAIL: IO error while writing/reading VTIMEZONE data\");\r\n            }\r\n            vtz_org.getOffset(time, false, offsets1);\r\n            vtz_new.getOffset(time, false, offsets2);\r\n            if (offsets1[0] != offsets2[0] || offsets1[1] != offsets2[1]) {\r\n                errln(\"FAIL: VTimeZone writeSimple for \" + tzids[i] + \" at time \" + time + \" failed to the round trip.\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ConcurrentLinkedQueueTest.populatedQueue",
	"Comment": "returns a new queue of given size containing consecutiveintegers 0 ... n.",
	"Method": "ConcurrentLinkedQueue<Integer> populatedQueue(int n){\r\n    ConcurrentLinkedQueue<Integer> q = new ConcurrentLinkedQueue<Integer>();\r\n    assertTrue(q.isEmpty());\r\n    for (int i = 0; i < n; ++i) assertTrue(q.offer(new Integer(i)));\r\n    assertFalse(q.isEmpty());\r\n    assertEquals(n, q.size());\r\n    return q;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.pipeline.BuildClosureQueue.getNextFile",
	"Comment": "returns the next java source file to be processed. returns null if thequeue is empty.",
	"Method": "InputFile getNextFile(){\r\n    for (Iterator<String> iter = queuedNames.iterator(); iter.hasNext(); ) {\r\n        String name = iter.next();\r\n        iter.remove();\r\n        processedNames.add(name);\r\n        InputFile file = getFileForName(name);\r\n        if (file != null) {\r\n            return file;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testSetThreadFactory",
	"Comment": "setthreadfactory sets the thread factory returned by getthreadfactory",
	"Method": "void testSetThreadFactory(){\r\n    final ThreadPoolExecutor p = new CustomTPE(1, 2, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        ThreadFactory threadFactory = new SimpleThreadFactory();\r\n        p.setThreadFactory(threadFactory);\r\n        assertSame(threadFactory, p.getThreadFactory());\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.CertPathValidatorException.getCertPath",
	"Comment": "returns the certification path that was being validated whenthe exception was thrown.",
	"Method": "CertPath getCertPath(){\r\n    return this.certPath;\r\n}"
}, {
	"Path": "java.util.ComparableTimSort.ensureCapacity",
	"Comment": "ensures that the external array tmp has at least the specifiednumber of elements, increasing its size if necessary.the sizeincreases exponentially to ensure amortized linear time complexity.",
	"Method": "Object[] ensureCapacity(int minCapacity){\r\n    if (tmpLen < minCapacity) {\r\n        int newSize = minCapacity;\r\n        newSize |= newSize >> 1;\r\n        newSize |= newSize >> 2;\r\n        newSize |= newSize >> 4;\r\n        newSize |= newSize >> 8;\r\n        newSize |= newSize >> 16;\r\n        newSize++;\r\n        if (newSize < 0)\r\n            newSize = minCapacity;\r\n        else\r\n            newSize = Math.min(newSize, a.length >>> 1);\r\n        @SuppressWarnings({ \"unchecked\", \"UnnecessaryLocalVariable\" })\r\n        Object[] newArray = new Object[newSize];\r\n        tmp = newArray;\r\n        tmpLen = newSize;\r\n        tmpBase = 0;\r\n    }\r\n    return tmp;\r\n}"
}, {
	"Path": "sun.security.util.DerIndefLenConverter.isLongForm",
	"Comment": "if bit 8 is set then it implies either indefinite length or long form",
	"Method": "boolean isLongForm(int lengthByte){\r\n    return ((lengthByte & LEN_LONG) == LEN_LONG);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSubMapTest.testDescendingReplaceValue2",
	"Comment": "replace value succeeds when the given key mapped to expected value",
	"Method": "void testDescendingReplaceValue2(){\r\n    ConcurrentNavigableMap map = dmap5();\r\n    assertEquals(\"A\", map.get(m1));\r\n    assertTrue(map.replace(m1, \"A\", \"Z\"));\r\n    assertEquals(\"Z\", map.get(m1));\r\n}"
}, {
	"Path": "java.time.format.DateTimeFormatter.withLocale",
	"Comment": "returns a copy of this formatter with a new locale.this is used to lookup any part of the formatter needing specificlocalization, such as the text or localized pattern.this instance is immutable and unaffected by this method call.",
	"Method": "DateTimeFormatter withLocale(Locale locale){\r\n    if (this.locale.equals(locale)) {\r\n        return this;\r\n    }\r\n    return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\r\n}"
}, {
	"Path": "jsr166.AtomicLongArrayTest.testConstructor",
	"Comment": "constructor creates array of given size with all elements zero",
	"Method": "void testConstructor(){\r\n    AtomicLongArray aa = new AtomicLongArray(SIZE);\r\n    for (int i = 0; i < SIZE; i++) assertEquals(0, aa.get(i));\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.getMinusSign",
	"Comment": "gets the character used to represent minus sign. if no explicitnegative format is specified, one is formed by prefixingminussign to the positive format.",
	"Method": "char getMinusSign(){\r\n    return minusSign;\r\n}"
}, {
	"Path": "java.net.HttpURLConnection.getErrorStream",
	"Comment": "returns the error stream if the connection failed but the server sent useful data nonetheless. the typical example is when an http server responds with a 404, which will cause a filenotfoundexception to be thrown in connect, but the server sent an html help page with suggestions as to what to do. this method will not cause a connection to be initiated.if the connection was not connected, or if the server did not have an error while connecting or if the server had an error but no error data was sent, this method will return null. this is the default.",
	"Method": "InputStream getErrorStream(){\r\n    return null;\r\n}"
}, {
	"Path": "test.java.time.chrono.TestThaiBuddhistChronoImpl.provider_rangeVersusCalendar",
	"Comment": "range of years to check consistency with java.util.calendar",
	"Method": "Object[][] provider_rangeVersusCalendar(){\r\n    return new Object[][] { { LocalDate.of(1583, 1, 1), LocalDate.of(2100, 1, 1) } };\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testAccumulateAndGetNPE",
	"Comment": "all atomic accumulateandget methods throw nullpointerexceptionon null function argument",
	"Method": "void testAccumulateAndGetNPE(){\r\n    Runnable[] throwingActions = { () -> new AtomicLong().accumulateAndGet(1L, null), () -> new AtomicInteger().accumulateAndGet(1, null), () -> new AtomicReference().accumulateAndGet(one, null), () -> new AtomicLongArray(1).accumulateAndGet(0, 1L, null), () -> new AtomicIntegerArray(1).accumulateAndGet(0, 1, null), () -> new AtomicReferenceArray(1).accumulateAndGet(0, one, null), () -> aLongFieldUpdater().accumulateAndGet(this, 1L, null), () -> anIntFieldUpdater().accumulateAndGet(this, 1, null), () -> anIntegerFieldUpdater().accumulateAndGet(this, one, null) };\r\n    assertThrows(NullPointerException.class, throwingActions);\r\n}"
}, {
	"Path": "java.time.format.DecimalStyle.withPositiveSign",
	"Comment": "returns a copy of the info with a new character that represents the positive sign.the character used to represent a positive number may vary by culture.this method specifies the character to use.",
	"Method": "DecimalStyle withPositiveSign(char positiveSign){\r\n    if (positiveSign == this.positiveSign) {\r\n        return this;\r\n    }\r\n    return new DecimalStyle(zeroDigit, positiveSign, negativeSign, decimalSeparator);\r\n}"
}, {
	"Path": "java.util.jar.JarInputStream.getNextJarEntry",
	"Comment": "reads the next jar file entry and positions the stream at thebeginning of the entry data. if verification has been enabled,any invalid signature detected while positioning the stream forthe next entry will result in an exception.",
	"Method": "JarEntry getNextJarEntry(){\r\n    return (JarEntry) getNextEntry();\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testScheduleWithFixedDelay1_RejectedExecutionException",
	"Comment": "schedulewithfixeddelay throws rejectedexecutionexception if shutdown",
	"Method": "void testScheduleWithFixedDelay1_RejectedExecutionException(){\r\n    final CustomExecutor p = new CustomExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        try {\r\n            p.shutdown();\r\n            p.scheduleWithFixedDelay(new NoOpRunnable(), MEDIUM_DELAY_MS, MEDIUM_DELAY_MS, MILLISECONDS);\r\n            shouldThrow();\r\n        } catch (RejectedExecutionException success) {\r\n        } catch (SecurityException ok) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.X509CRLEntryImpl.getSerialNumber",
	"Comment": "gets the serial number from this x509crlentry,i.e. the usercertificate.",
	"Method": "BigInteger getSerialNumber(){\r\n    return serialNumber.getNumber();\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerFieldUpdaterTest.testCompareAndSet",
	"Comment": "compareandset succeeds in changing value if equal to expected else fails",
	"Method": "void testCompareAndSet(){\r\n    AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;\r\n    a = updaterFor(\"x\");\r\n    x = 1;\r\n    assertTrue(a.compareAndSet(this, 1, 2));\r\n    assertTrue(a.compareAndSet(this, 2, -4));\r\n    assertEquals(-4, a.get(this));\r\n    assertFalse(a.compareAndSet(this, -5, 7));\r\n    assertEquals(-4, a.get(this));\r\n    assertTrue(a.compareAndSet(this, -4, 7));\r\n    assertEquals(7, a.get(this));\r\n}"
}, {
	"Path": "java.util.PropertyResourceBundle.handleKeySet",
	"Comment": "returns a set of the keys containedonly in this resourcebundle.",
	"Method": "Set<String> handleKeySet(){\r\n    return lookup.keySet();\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGet(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FailingCCF f = new LFCCF(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGet(){\r\n    FailingCCF f = new LFCCF(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.OCSPResponse.getSignerCertificate",
	"Comment": "returns the certificate for the authority that signed the ocsp response.",
	"Method": "X509Certificate getSignerCertificate(){\r\n    return signerCert;\r\n}"
}, {
	"Path": "java.util.concurrent.LinkedBlockingQueue.offer",
	"Comment": "inserts the specified element at the tail of this queue, waiting ifnecessary up to the specified wait time for space to become available.",
	"Method": "boolean offer(E e,long timeout,TimeUnit unit,boolean offer,E e){\r\n    if (e == null)\r\n        throw new NullPointerException();\r\n    final AtomicInteger count = this.count;\r\n    if (count.get() == capacity)\r\n        return false;\r\n    int c = -1;\r\n    Node<E> node = new Node<E>(e);\r\n    final ReentrantLock putLock = this.putLock;\r\n    putLock.lock();\r\n    try {\r\n        if (count.get() < capacity) {\r\n            enqueue(node);\r\n            c = count.getAndIncrement();\r\n            if (c + 1 < capacity)\r\n                notFull.signal();\r\n        }\r\n    } finally {\r\n        putLock.unlock();\r\n    }\r\n    if (c == 0)\r\n        signalNotEmpty();\r\n    return c >= 0;\r\n}"
}, {
	"Path": "sun.security.x509.X509CRLImpl.getRevokedCertificates",
	"Comment": "gets all the revoked certificates from the crl.a set of x509crlentry.",
	"Method": "Set<X509CRLEntry> getRevokedCertificates(){\r\n    if (revokedList.isEmpty()) {\r\n        return null;\r\n    } else {\r\n        return new TreeSet<X509CRLEntry>(revokedList);\r\n    }\r\n}"
}, {
	"Path": "java.util.EnumSet.getUniverse",
	"Comment": "returns all of the values comprising e.the result is uncloned, cached, and shared by all callers.",
	"Method": "E[] getUniverse(Class<E> elementType){\r\n    return java.lang.JavaLangAccess.getEnumConstantsShared(elementType);\r\n}"
}, {
	"Path": "android.icu.dev.test.format.DateFormatTest._testIt917",
	"Comment": "internal test subroutine, used by testruntogetherpattern917",
	"Method": "void _testIt917(SimpleDateFormat fmt,String str,Date expected){\r\n    logln(\"pattern=\" + fmt.toPattern() + \"   string=\" + str);\r\n    Date o = new Date();\r\n    o = (Date) ((DateFormat) fmt).parseObject(str, new ParsePosition(0));\r\n    logln(\"Parsed object: \" + o);\r\n    if (o == null || !o.equals(expected))\r\n        errln(\"FAIL: Expected \" + expected);\r\n    String formatted = o == null ? \"null\" : ((DateFormat) fmt).format(o);\r\n    logln(\"Formatted string: \" + formatted);\r\n    if (!formatted.equals(str))\r\n        errln(\"FAIL: Expected \" + str);\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testReferenceFieldUpdaterAccumulateAndGet",
	"Comment": "atomicreferencefieldupdater accumulateandget updates withsupplied function and returns result.",
	"Method": "void testReferenceFieldUpdaterAccumulateAndGet(){\r\n    AtomicReferenceFieldUpdater<Atomic8Test, Integer> a = anIntegerFieldUpdater();\r\n    a.set(this, one);\r\n    assertEquals(new Integer(7), a.accumulateAndGet(this, 6, Atomic8Test::sumInteger));\r\n    assertEquals(new Integer(10), a.accumulateAndGet(this, 3, Atomic8Test::sumInteger));\r\n    assertEquals(new Integer(10), a.get(this));\r\n    assertEquals(new Integer(10), anIntegerField);\r\n}"
}, {
	"Path": "javax.xml.transform.TransformerException.setLocator",
	"Comment": "method setlocator sets an instance of a sourcelocatorobject that specifies where an error occurred.",
	"Method": "void setLocator(SourceLocator location){\r\n    locator = location;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test426086a",
	"Comment": "method reference to an inherited method is invoked from sub class",
	"Method": "void test426086a(){\r\n    this.runConformTest(new String[] { \"X.java\", \"interface Functional {\\n\" + \"    Long square(Integer a);\\n\" + \"}\\n\" + \"public class X {\\n\" + \"    static class Base {\\n\" + \"      private Long square(Integer a) {\\n\" + \"             return Long.valueOf(a*a);\\n\" + \"         } \\n\" + \"    }\\n\" + \"    static class SubClass extends Base {\\n\" + \"        public Long callSquare(Integer i) {\\n\" + \"            Functional fi = super::square;\\n\" + \"            return fi.square(i);\\n\" + \"        }\\n\" + \"    }\\n\" + \"    public static void main(String argv[]) throws Exception {\\n\" + \"     System.out.println(new SubClass().callSquare(-3));\\n\" + \"    }\\n\" + \"}\\n\" }, \"9\");\r\n}"
}, {
	"Path": "java.text.DateFormatSymbols.hashCode",
	"Comment": "override hashcode.generates a hash code for the dateformatsymbols object.",
	"Method": "int hashCode(){\r\n    int hashcode = 0;\r\n    String[][] zoneStrings = getZoneStringsWrapper();\r\n    for (int index = 0; index < zoneStrings[0].length; ++index) hashcode ^= zoneStrings[0][index].hashCode();\r\n    return hashcode;\r\n}"
}, {
	"Path": "java.time.Instant.plusSeconds",
	"Comment": "returns a copy of this instant with the specified duration in seconds added.this instance is immutable and unaffected by this method call.",
	"Method": "Instant plusSeconds(long secondsToAdd){\r\n    return plus(secondsToAdd, 0);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigDecimalConvertTest.testToEngineeringStringZeroNegExponent",
	"Comment": "convert a negative bigdecimal to an engineering string representation",
	"Method": "void testToEngineeringStringZeroNegExponent(){\r\n    String a = \"0.0E-16\";\r\n    BigDecimal aNumber = new BigDecimal(a);\r\n    String result = \"0.00E-15\";\r\n    assertEquals(\"incorrect value\", result, aNumber.toEngineeringString());\r\n}"
}, {
	"Path": "com.google.j2objc.net.DataEnqueuedOutputStream.offerData",
	"Comment": "offers data from the queue to the outputstream piped to the adapted nsinputstream.",
	"Method": "void offerData(OutputStream stream){\r\n    byte[] next = null;\r\n    try {\r\n        next = queue.poll(timeoutMillis, TimeUnit.MILLISECONDS);\r\n    } catch (InterruptedException ignored) {\r\n    }\r\n    try {\r\n        if (next != null && next != CLOSED) {\r\n            stream.write(next);\r\n            return;\r\n        }\r\n    } catch (IOException ignored) {\r\n    }\r\n    try {\r\n        stream.close();\r\n    } catch (IOException ignored) {\r\n    }\r\n}"
}, {
	"Path": "java.util.JumboEnumSet.add",
	"Comment": "adds the specified element to this set if it is not already present.",
	"Method": "boolean add(E e){\r\n    typeCheck(e);\r\n    int eOrdinal = e.ordinal();\r\n    int eWordNum = eOrdinal >>> 6;\r\n    long oldElements = elements[eWordNum];\r\n    elements[eWordNum] |= (1L << eOrdinal);\r\n    boolean result = (elements[eWordNum] != oldElements);\r\n    if (result)\r\n        size++;\r\n    return result;\r\n}"
}, {
	"Path": "android.icu.dev.test.UTF16Util.getRawSupplementary",
	"Comment": "forms a supplementary code point from the argument character note this is for internal use hence no checks for the validity of the surrogate characters are done",
	"Method": "int getRawSupplementary(char lead,char trail){\r\n    return (lead << LEAD_SURROGATE_SHIFT_) + trail + SURROGATE_OFFSET_;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testDoubleValueNegNotRounded",
	"Comment": "convert a positive number to a double value. rounding is not needed.",
	"Method": "void testDoubleValueNegNotRounded(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, -128, 23, 1, -3, -5 };\r\n    int aSign = -1;\r\n    double result = -1.5474726438794828E26;\r\n    double aNumber = new BigInteger(aSign, a).doubleValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getSubject",
	"Comment": "returns the subject criterion as an x500principal. thisdistinguished name must match the subject distinguished name in thex509certificate. if null, the subject criterionis disabled and any subject distinguished name will do.",
	"Method": "X500Principal getSubject(){\r\n    return subject;\r\n}"
}, {
	"Path": "java.util.concurrent.SynchronousQueue.take",
	"Comment": "retrieves and removes the head of this queue, waiting if necessaryfor another thread to insert it.",
	"Method": "E take(){\r\n    E e = transferer.transfer(null, false, 0);\r\n    if (e != null)\r\n        return e;\r\n    Thread.interrupted();\r\n    throw new InterruptedException();\r\n}"
}, {
	"Path": "org.apache.harmony.luni.tests.java.util.HashSetTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this method\tis called before a test is executed.",
	"Method": "void setUp(){\r\n    hs = new HashSet();\r\n    for (int i = 0; i < objArray.length; i++) hs.add(objArray[i]);\r\n    hs.add(null);\r\n}"
}, {
	"Path": "java.math.BigInteger.bitLength",
	"Comment": "calculate bitlength of contents of the first len elements an int array,assuming there are no leading zero ints.",
	"Method": "int bitLength(int[] val,int len,int bitLength){\r\n    @SuppressWarnings(\"deprecation\")\r\n    int n = bitLength - 1;\r\n    if (n == -1) {\r\n        int[] m = mag;\r\n        int len = m.length;\r\n        if (len == 0) {\r\n            n = 0;\r\n        } else {\r\n            int magBitLength = ((len - 1) << 5) + bitLengthForInt(mag[0]);\r\n            if (signum < 0) {\r\n                boolean pow2 = (Integer.bitCount(mag[0]) == 1);\r\n                for (int i = 1; i < len && pow2; i++) pow2 = (mag[i] == 0);\r\n                n = (pow2 ? magBitLength - 1 : magBitLength);\r\n            } else {\r\n                n = magBitLength;\r\n            }\r\n        }\r\n        bitLength = n + 1;\r\n    }\r\n    return n;\r\n}"
}, {
	"Path": "sun.security.x509.CertificateValidity.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(NOT_BEFORE);\r\n    elements.addElement(NOT_AFTER);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "java.time.Duration.toHours",
	"Comment": "gets the number of hours in this duration.this returns the total number of hours in the duration by dividing thenumber of seconds by 3600.this instance is immutable and unaffected by this method call.",
	"Method": "long toHours(){\r\n    return seconds / SECONDS_PER_HOUR;\r\n}"
}, {
	"Path": "sun.nio.ch.DatagramChannelImpl.translateAndSetInterestOps",
	"Comment": "translates an interest operation set into a native poll event set",
	"Method": "void translateAndSetInterestOps(int ops,SelectionKeyImpl sk){\r\n    int newOps = 0;\r\n    if ((ops & SelectionKey.OP_READ) != 0)\r\n        newOps |= PollArrayWrapper.POLLIN;\r\n    if ((ops & SelectionKey.OP_WRITE) != 0)\r\n        newOps |= PollArrayWrapper.POLLOUT;\r\n    if ((ops & SelectionKey.OP_CONNECT) != 0)\r\n        newOps |= PollArrayWrapper.POLLIN;\r\n    sk.selector.putEventOps(sk, newOps);\r\n}"
}, {
	"Path": "sun.security.provider.certpath.BuildStep.fullToString",
	"Comment": "return a string representation of this build step, including all possibledetail of the vertex state, but not including the certificate contents.",
	"Method": "String fullToString(){\r\n    return resultToString(getResult()) + vertex.toString();\r\n}"
}, {
	"Path": "java.lang.Package.isSealed",
	"Comment": "returns true if this package is sealed with respect to the specifiedcode source url.",
	"Method": "boolean isSealed(boolean isSealed,URL url){\r\n    return url.equals(sealBase);\r\n}"
}, {
	"Path": "libcore.java.net.AbstractCookiesTest.test_Put_Get_LURI_LMap",
	"Comment": "unlike the ri, we flatten all matching cookies into a single cookie headerinstead of sending down multiple cookie headers. also, when no cookies matcha given uri, we leave the requestheaders unmodified.",
	"Method": "void test_Put_Get_LURI_LMap(){\r\n    String[][] cookies = { { \"Set-cookie\", \"Set-cookie:PREF=test;path=/;domain=.b.c;\", \"http://a.b.c/\", \"Set-cookie:PREF1=test2;path=/;domain=.beg.com;\", \"http://a.b.c/\" }, { \"Set-cookie2\", \"Set-cookie2:NAME1=VALUE1;path=/te;domain=.b.c;\", \"http://a.b.c/test\" }, { \"Set-cookie\", \"Set-cookie2:NAME=VALUE;path=/;domain=.beg.com;\", \"http://a.beg.com/test\", \"Set-cookie2:NAME1=VALUE1;path=/;domain=.beg.com;\", \"http://a.beg.com/test\" }, { \"Set-cookie2\", \"Set-cookie3:NAME=VALUE;path=/;domain=.test.org;\", \"http://a.test.org/test\" }, { null, \"Set-cookie3:NAME=VALUE;path=/te;domain=.test.org;\", \"http://a.test.org/test\" }, { \"Set-cookie2\", \"lala\", \"http://a.test.org/test\" } };\r\n    Map<String, List<String>> responseHeaders = addCookie(new String[][] { cookies[0], cookies[1] });\r\n    CookieManager manager = store(new String[][] { cookies[0], cookies[1] }, responseHeaders, null);\r\n    HashMap<String, List<String>> dummyMap = new HashMap<String, List<String>>();\r\n    Map<String, List<String>> map = manager.get(new URI(\"http://a.b.c/\"), dummyMap);\r\n    assertEquals(1, map.size());\r\n    List<String> list = map.get(\"Cookie\");\r\n    assertEquals(1, list.size());\r\n    map = manager.get(new URI(\"http://a.b.c/te\"), dummyMap);\r\n    list = map.get(\"Cookie\");\r\n    assertEquals(1, list.size());\r\n    assertTrue(list.get(0).contains(\"PREF=test\"));\r\n    assertFalse(list.get(0).contains(\"NAME=VALUE\"));\r\n    responseHeaders = addCookie(new String[][] { cookies[2] });\r\n    manager = store(new String[][] { cookies[2] }, responseHeaders, null);\r\n    map = manager.get(new URI(\"http://a.beg.com/test\"), dummyMap);\r\n    list = map.get(\"Cookie\");\r\n    assertEquals(1, list.size());\r\n    assertTrue(list.get(0).startsWith(\"$Version=\\\"1\\\"\"));\r\n    responseHeaders = addCookie(new String[][] { cookies[3] });\r\n    manager = store(new String[][] { cookies[3] }, responseHeaders, null);\r\n    map = manager.get(new URI(\"http://a.test.org/\"), responseHeaders);\r\n    list = map.get(\"Cookie\");\r\n    assertEquals(1, list.size());\r\n    assertEquals(\"Set-cookie3:NAME=VALUE\", list.get(0));\r\n    responseHeaders = addCookie(new String[][] { cookies[4] });\r\n    manager = store(new String[][] { cookies[4] }, responseHeaders, CookiePolicy.ACCEPT_ALL);\r\n    map = manager.get(new URI(\"http://a.test.org/\"), responseHeaders);\r\n    list = map.get(\"Cookie\");\r\n    assertNull(list);\r\n    responseHeaders = addCookie(new String[][] { cookies[3] });\r\n    manager = store(new String[][] { cookies[3] }, responseHeaders, CookiePolicy.ACCEPT_NONE);\r\n    map = manager.get(new URI(\"http://a.test.org/\"), responseHeaders);\r\n    list = map.get(\"Cookie\");\r\n    assertNull(list);\r\n    responseHeaders = addCookie(new String[][] { cookies[5] });\r\n    manager = store(new String[][] { cookies[5] }, responseHeaders, CookiePolicy.ACCEPT_ALL);\r\n    list = map.get(\"Cookie\");\r\n    assertNull(list);\r\n    try {\r\n        map.put(null, null);\r\n        fail(\"Should throw UnsupportedOperationException\");\r\n    } catch (UnsupportedOperationException e) {\r\n    }\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.inverseMod32",
	"Comment": "returns the multiplicative inverse of val mod 2^32.assumes val is odd.",
	"Method": "int inverseMod32(int val){\r\n    int t = val;\r\n    t *= 2 - val * t;\r\n    t *= 2 - val * t;\r\n    t *= 2 - val * t;\r\n    t *= 2 - val * t;\r\n    return t;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.URICertStore.engineGetCRLs",
	"Comment": "returns a collection of x509crls thatmatch the specified selector. if no x509crlsmatch the selector, an empty collection will be returned.",
	"Method": "Collection<X509CRL> engineGetCRLs(CRLSelector selector){\r\n    long time = System.currentTimeMillis();\r\n    if (time - lastChecked < CHECK_INTERVAL) {\r\n        if (debug != null) {\r\n            debug.println(\"Returning CRL from cache\");\r\n        }\r\n        return getMatchingCRLs(crl, selector);\r\n    }\r\n    lastChecked = time;\r\n    try {\r\n        URLConnection connection = uri.toURL().openConnection();\r\n        if (lastModified != 0) {\r\n            connection.setIfModifiedSince(lastModified);\r\n        }\r\n        long oldLastModified = lastModified;\r\n        connection.setConnectTimeout(CRL_CONNECT_TIMEOUT);\r\n        try (InputStream in = connection.getInputStream()) {\r\n            lastModified = connection.getLastModified();\r\n            if (oldLastModified != 0) {\r\n                if (oldLastModified == lastModified) {\r\n                    if (debug != null) {\r\n                        debug.println(\"Not modified, using cached copy\");\r\n                    }\r\n                    return getMatchingCRLs(crl, selector);\r\n                } else if (connection instanceof HttpURLConnection) {\r\n                    HttpURLConnection hconn = (HttpURLConnection) connection;\r\n                    if (hconn.getResponseCode() == HttpURLConnection.HTTP_NOT_MODIFIED) {\r\n                        if (debug != null) {\r\n                            debug.println(\"Not modified, using cached copy\");\r\n                        }\r\n                        return getMatchingCRLs(crl, selector);\r\n                    }\r\n                }\r\n            }\r\n            if (debug != null) {\r\n                debug.println(\"Downloading new CRL...\");\r\n            }\r\n            crl = (X509CRL) factory.generateCRL(in);\r\n        }\r\n        return getMatchingCRLs(crl, selector);\r\n    } catch (IOException | CRLException e) {\r\n        if (debug != null) {\r\n            debug.println(\"Exception fetching CRL:\");\r\n            e.printStackTrace();\r\n        }\r\n        lastModified = 0;\r\n        crl = null;\r\n        throw new PKIX.CertStoreTypeException(\"URI\", new CertStoreException(e));\r\n    }\r\n}"
}, {
	"Path": "java.util.TimeZone.getOffset",
	"Comment": "returns the offset of this time zone from utc at the specifieddate. if daylight saving time is in effect at the specifieddate, the offset value is adjusted with the amount of daylightsaving.this method returns a historically correct offset value if anunderlying timezone implementation subclass supports historicaldaylight saving time schedule and gmt offset changes.",
	"Method": "int getOffset(int era,int year,int month,int day,int dayOfWeek,int milliseconds,int getOffset,long date){\r\n    if (inDaylightTime(new Date(date))) {\r\n        return getRawOffset() + getDSTSavings();\r\n    }\r\n    return getRawOffset();\r\n}"
}, {
	"Path": "sun.security.provider.X509Factory.engineGenerateCertificate",
	"Comment": "generates an x.509 certificate object and initializes it withthe data read from the input stream is.",
	"Method": "Certificate engineGenerateCertificate(InputStream is){\r\n    if (is == null) {\r\n        certCache.clear();\r\n        X509CertificatePair.clearCache();\r\n    }\r\n    try {\r\n        byte[] encoding = readOneBlock(is);\r\n        if (encoding != null) {\r\n            X509CertImpl cert = (X509CertImpl) getFromCache(certCache, encoding);\r\n            if (cert != null) {\r\n                return cert;\r\n            }\r\n            cert = new X509CertImpl(encoding);\r\n            addToCache(certCache, cert.getEncodedInternal(), cert);\r\n            return cert;\r\n        } else {\r\n            throw new IOException(\"Empty input\");\r\n        }\r\n    } catch (IOException ioe) {\r\n        throw (CertificateException) new CertificateException(\"Could not parse certificate: \" + ioe.toString()).initCause(ioe);\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.PKIXParameters.getTargetCertConstraints",
	"Comment": "returns the required constraints on the target certificate.the constraints are returned as an instance of certselector.if null, no constraints are defined.note that the certselector returned is clonedto protect against subsequent modifications.",
	"Method": "CertSelector getTargetCertConstraints(){\r\n    if (certSelector != null) {\r\n        return (CertSelector) certSelector.clone();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorBytesPositive",
	"Comment": "create a positive number from an array of bytes.the number of bytes is multiple of 4.",
	"Method": "void testConstructorBytesPositive(){\r\n    byte[] aBytes = { 127, 56, 100, -1, 14, 75, -24, -100 };\r\n    byte[] rBytes = { 127, 56, 100, -1, 14, 75, -24, -100 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerFieldUpdaterTest.testAddAndGet",
	"Comment": "addandget adds given value to current, and returns current value",
	"Method": "void testAddAndGet(){\r\n    AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;\r\n    a = updaterFor(\"x\");\r\n    x = 1;\r\n    assertEquals(3, a.addAndGet(this, 2));\r\n    assertEquals(3, a.get(this));\r\n    assertEquals(-1, a.addAndGet(this, -4));\r\n    assertEquals(-1, a.get(this));\r\n}"
}, {
	"Path": "android.icu.dev.test.lang.TestUScript.getCharScript",
	"Comment": "maps a special script code to the most common script of its encoded characters.",
	"Method": "int getCharScript(int script){\r\n    switch(script) {\r\n        case UScript.HAN_WITH_BOPOMOFO:\r\n        case UScript.SIMPLIFIED_HAN:\r\n        case UScript.TRADITIONAL_HAN:\r\n            return UScript.HAN;\r\n        case UScript.JAPANESE:\r\n            return UScript.HIRAGANA;\r\n        case UScript.JAMO:\r\n        case UScript.KOREAN:\r\n            return UScript.HANGUL;\r\n        case UScript.SYMBOLS_EMOJI:\r\n            return UScript.SYMBOLS;\r\n        default:\r\n            return script;\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.Vertex.setIndex",
	"Comment": "set the index for this vertex, where the index is the row of theadjacency list that contains certificates that could follow thiscertificate.",
	"Method": "void setIndex(int ndx){\r\n    index = ndx;\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testIntGetAndAccumulate",
	"Comment": "atomicinteger getandaccumulate returns previous value and updateswith supplied function.",
	"Method": "void testIntGetAndAccumulate(){\r\n    AtomicInteger a = new AtomicInteger(1);\r\n    assertEquals(1, a.getAndAccumulate(2, Integer::sum));\r\n    assertEquals(3, a.getAndAccumulate(3, Integer::sum));\r\n    assertEquals(6, a.get());\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerFieldUpdaterTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    x = 1;\r\n    final AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;\r\n    a = updaterFor(\"x\");\r\n    Thread t = new Thread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!a.compareAndSet(AtomicIntegerFieldUpdaterTest.this, 2, 3)) Thread.yield();\r\n        }\r\n    });\r\n    t.start();\r\n    assertTrue(a.compareAndSet(this, 1, 2));\r\n    t.join(LONG_DELAY_MS);\r\n    assertFalse(t.isAlive());\r\n    assertEquals(3, a.get(this));\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerFieldUpdaterTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    while (!a.compareAndSet(AtomicIntegerFieldUpdaterTest.this, 2, 3)) Thread.yield();\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater",
	"Comment": "creates and returns an updater for objects with the given field.the class argument is needed to check that reflective types andgeneric types match.",
	"Method": "AtomicIntegerFieldUpdater<U> newUpdater(Class<U> tclass,String fieldName){\r\n    return new AtomicIntegerFieldUpdaterImpl<U>(tclass, fieldName, null);\r\n}"
}, {
	"Path": "java.util.concurrent.DelayQueue.put",
	"Comment": "inserts the specified element into this delay queue. as the queue isunbounded this method will never block.",
	"Method": "void put(E e){\r\n    offer(e);\r\n}"
}, {
	"Path": "java.util.concurrent.ArrayBlockingQueue.dequeue",
	"Comment": "extracts element at current take position, advances, and signals.call only when holding lock.",
	"Method": "E dequeue(){\r\n    final Object[] items = this.items;\r\n    @SuppressWarnings(\"unchecked\")\r\n    E x = (E) items[takeIndex];\r\n    items[takeIndex] = null;\r\n    if (++takeIndex == items.length)\r\n        takeIndex = 0;\r\n    count--;\r\n    if (itrs != null)\r\n        itrs.elementDequeued();\r\n    notFull.signal();\r\n    return x;\r\n}"
}, {
	"Path": "java.text.AttributedString.getIterator",
	"Comment": "creates an attributedcharacteriterator instance that provides access toselected contents of this string.information about attributes not listed in attributes that theimplementor may have need not be made accessible through the iterator.if the list is null, all available attribute information should be madeaccessible.",
	"Method": "AttributedCharacterIterator getIterator(AttributedCharacterIterator getIterator,Attribute[] attributes,AttributedCharacterIterator getIterator,Attribute[] attributes,int beginIndex,int endIndex){\r\n    return new AttributedStringIterator(attributes, beginIndex, endIndex);\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testUnconfigurableExecutorService",
	"Comment": "an unconfigurable newfixedthreadpool can execute runnables",
	"Method": "void testUnconfigurableExecutorService(){\r\n    final ExecutorService e = Executors.unconfigurableExecutorService(Executors.newFixedThreadPool(2));\r\n    try (PoolCleaner cleaner = cleaner(e)) {\r\n        e.execute(new NoOpRunnable());\r\n        e.execute(new NoOpRunnable());\r\n        e.execute(new NoOpRunnable());\r\n    }\r\n}"
}, {
	"Path": "java.util.ArrayList.grow",
	"Comment": "increases the capacity to ensure that it can hold at least thenumber of elements specified by the minimum capacity argument.",
	"Method": "void grow(int minCapacity){\r\n    int oldCapacity = elementData.length;\r\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\r\n    if (newCapacity - minCapacity < 0)\r\n        newCapacity = minCapacity;\r\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\r\n        newCapacity = hugeCapacity(minCapacity);\r\n    elementData = Arrays.copyOf(elementData, newCapacity);\r\n}"
}, {
	"Path": "java.util.WeakHashMap.unmaskNull",
	"Comment": "returns internal representation of null key back to caller as null.",
	"Method": "Object unmaskNull(Object key){\r\n    return (key == NULL_KEY) ? null : key;\r\n}"
}, {
	"Path": "jsr166.PriorityBlockingQueueTest.testInterruptedTimedPoll",
	"Comment": "interrupted timed poll throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPoll(){\r\n    final BlockingQueue<Integer> q = populatedQueue(SIZE);\r\n    final CountDownLatch aboutToWait = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            long startTime = System.nanoTime();\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n            }\r\n            aboutToWait.countDown();\r\n            try {\r\n                q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n                assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n            }\r\n        }\r\n    });\r\n    aboutToWait.await();\r\n    waitForThreadToEnterWaitState(t, LONG_DELAY_MS);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.PriorityBlockingQueueTest.testInterruptedTimedPoll",
	"Comment": "interrupted timed poll throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPoll(){\r\n    long startTime = System.nanoTime();\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n    }\r\n    aboutToWait.countDown();\r\n    try {\r\n        q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n        assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n    }\r\n}"
}, {
	"Path": "java.util.Calendar.internalSet",
	"Comment": "sets the value of the given calendar field. this method doesnot affect any setting state of the field in thiscalendar instance.",
	"Method": "void internalSet(int field,int value){\r\n    fields[field] = value;\r\n}"
}, {
	"Path": "java.net.URL.toExternalForm",
	"Comment": "constructs a string representation of this url. thestring is created by calling the toexternalformmethod of the stream protocol handler for this object.",
	"Method": "String toExternalForm(){\r\n    return handler.toExternalForm(this);\r\n}"
}, {
	"Path": "java.util.logging.ConsoleHandler.publish",
	"Comment": "publish a logrecord.the logging request was made initially to a logger object,which initialized the logrecord and forwarded it here.",
	"Method": "void publish(LogRecord record){\r\n    super.publish(record);\r\n    flush();\r\n}"
}, {
	"Path": "java.util.logging.Logger.warning",
	"Comment": "log a warning message.if the logger is currently enabled for the warning messagelevel then the given message is forwarded to all theregistered output handler objects.",
	"Method": "void warning(String msg){\r\n    if (Level.WARNING.intValue() < levelValue) {\r\n        return;\r\n    }\r\n    log(Level.WARNING, msg);\r\n}"
}, {
	"Path": "java.math.BigInteger.mulAdd",
	"Comment": "multiply an array by one word k and add to result, return the carry",
	"Method": "int mulAdd(int[] out,int[] in,int offset,int len,int k){\r\n    long kLong = k & LONG_MASK;\r\n    long carry = 0;\r\n    offset = out.length - offset - 1;\r\n    for (int j = len - 1; j >= 0; j--) {\r\n        long product = (in[j] & LONG_MASK) * kLong + (out[offset] & LONG_MASK) + carry;\r\n        out[offset--] = (int) product;\r\n        carry = product >>> 32;\r\n    }\r\n    return (int) carry;\r\n}"
}, {
	"Path": "java.util.concurrent.PriorityBlockingQueue.iterator",
	"Comment": "returns an iterator over the elements in this queue. theiterator does not return the elements in any particular order.the returned iterator isweakly consistent.",
	"Method": "Iterator<E> iterator(){\r\n    return new Itr(toArray());\r\n}"
}, {
	"Path": "java.util.OptionalInt.ifPresent",
	"Comment": "have the specified consumer accept the value if a value is present,otherwise do nothing.",
	"Method": "void ifPresent(IntConsumer consumer){\r\n    if (isPresent)\r\n        consumer.accept(value);\r\n}"
}, {
	"Path": "sun.security.x509.X509CertInfo.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(VERSION);\r\n    elements.addElement(SERIAL_NUMBER);\r\n    elements.addElement(ALGORITHM_ID);\r\n    elements.addElement(ISSUER);\r\n    elements.addElement(VALIDITY);\r\n    elements.addElement(SUBJECT);\r\n    elements.addElement(KEY);\r\n    elements.addElement(ISSUER_ID);\r\n    elements.addElement(SUBJECT_ID);\r\n    elements.addElement(EXTENSIONS);\r\n    return elements.elements();\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentSkipListSet.removeAll",
	"Comment": "removes from this set all of its elements that are contained inthe specified collection.if the specified collection is alsoa set, this operation effectively modifies this set so that itsvalue is the asymmetric set difference of the two sets.",
	"Method": "boolean removeAll(Collection<?> c){\r\n    boolean modified = false;\r\n    for (Object e : c) if (remove(e))\r\n        modified = true;\r\n    return modified;\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinTask.uncheckedThrow",
	"Comment": "the sneaky part of sneaky throw, relying on genericslimitations to evade compiler complaints about rethrowingunchecked exceptions.",
	"Method": "void uncheckedThrow(Throwable t){\r\n    if (t != null)\r\n        throw (T) t;\r\n    else\r\n        throw new Error(\"Unknown Exception\");\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSubMapTest.testDescendingReplaceValue",
	"Comment": "replace value fails when the given key not mapped to expected value",
	"Method": "void testDescendingReplaceValue(){\r\n    ConcurrentNavigableMap map = dmap5();\r\n    assertEquals(\"A\", map.get(m1));\r\n    assertFalse(map.replace(m1, \"Z\", \"Z\"));\r\n    assertEquals(\"A\", map.get(m1));\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.NameTable.getVariableBaseName",
	"Comment": "gets the variable name without any qualifying class name or other prefixor suffix attached.",
	"Method": "String getVariableBaseName(VariableElement var){\r\n    return getVarBaseName(var, ElementUtil.isGlobalVar(var));\r\n}"
}, {
	"Path": "java.util.logging.Handler.setEncoding",
	"Comment": "set the character encoding used by this handler.the encoding should be set before any logrecords are writtento the handler.",
	"Method": "void setEncoding(String encoding){\r\n    checkPermission();\r\n    if (encoding != null) {\r\n        try {\r\n            if (!java.nio.charset.Charset.isSupported(encoding)) {\r\n                throw new UnsupportedEncodingException(encoding);\r\n            }\r\n        } catch (java.nio.charset.IllegalCharsetNameException e) {\r\n            throw new UnsupportedEncodingException(encoding);\r\n        }\r\n    }\r\n    this.encoding = encoding;\r\n}"
}, {
	"Path": "java.security.cert.PKIXCertPathBuilderResult.toString",
	"Comment": "return a printable representation of thispkixcertpathbuilderresult.",
	"Method": "String toString(){\r\n    StringBuffer sb = new StringBuffer();\r\n    sb.append(\"PKIXCertPathBuilderResult: [\\n\");\r\n    sb.append(\"  Certification Path: \" + certPath + \"\\n\");\r\n    sb.append(\"  Trust Anchor: \" + getTrustAnchor().toString() + \"\\n\");\r\n    sb.append(\"  Policy Tree: \" + String.valueOf(getPolicyTree()) + \"\\n\");\r\n    sb.append(\"  Subject Public Key: \" + getPublicKey() + \"\\n\");\r\n    sb.append(\"]\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "sun.misc.FDBigInt.multaddMe",
	"Comment": "multiply a fdbigint by an int and add another int.result is computed in place.hope it fits!",
	"Method": "void multaddMe(int iv,int addend){\r\n    long v = iv;\r\n    long p;\r\n    p = v * ((long) data[0] & 0xffffffffL) + ((long) addend & 0xffffffffL);\r\n    data[0] = (int) p;\r\n    p >>>= 32;\r\n    for (int i = 1; i < nWords; i++) {\r\n        p += v * ((long) data[i] & 0xffffffffL);\r\n        data[i] = (int) p;\r\n        p >>>= 32;\r\n    }\r\n    if (p != 0L) {\r\n        data[nWords] = (int) p;\r\n        nWords++;\r\n    }\r\n}"
}, {
	"Path": "java.net.URI.match",
	"Comment": "tell whether the given character is permitted by the given mask pair",
	"Method": "boolean match(char c,long lowMask,long highMask){\r\n    if (c == 0)\r\n        return false;\r\n    if (c < 64)\r\n        return ((1L << c) & lowMask) != 0;\r\n    if (c < 128)\r\n        return ((1L << (c - 64)) & highMask) != 0;\r\n    return false;\r\n}"
}, {
	"Path": "libcore.icu.TimeZoneNames.getZoneStrings",
	"Comment": "returns an array of time zone strings, as used by dateformatsymbols.getzonestrings.",
	"Method": "String[][] getZoneStrings(Locale locale){\r\n    if (locale == null) {\r\n        locale = Locale.getDefault();\r\n    }\r\n    return cachedZoneStrings.get(locale);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkGetSingleton",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGetSingleton(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FailingCCF f = new LFCCF(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get();\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkGetSingleton",
	"Comment": "get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkGetSingleton(){\r\n    FailingCCF f = new LFCCF(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get();\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n}"
}, {
	"Path": "java.time.Duration.multipliedBy",
	"Comment": "returns a copy of this duration multiplied by the scalar.this instance is immutable and unaffected by this method call.",
	"Method": "Duration multipliedBy(long multiplicand){\r\n    if (multiplicand == 0) {\r\n        return ZERO;\r\n    }\r\n    if (multiplicand == 1) {\r\n        return this;\r\n    }\r\n    return create(toSeconds().multiply(BigDecimal.valueOf(multiplicand)));\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.unsignedLongCompare",
	"Comment": "compare two longs as if they were unsigned.returns true iff one is bigger than two.",
	"Method": "boolean unsignedLongCompare(long one,long two){\r\n    return (one + Long.MIN_VALUE) > (two + Long.MIN_VALUE);\r\n}"
}, {
	"Path": "sun.security.provider.certpath.PolicyChecker.removeInvalidNodes",
	"Comment": "removes those nodes which do not intersect with the initial policiesspecified by the user.",
	"Method": "PolicyNodeImpl removeInvalidNodes(PolicyNodeImpl rootNode,int certIndex,Set<String> initPolicies,CertificatePoliciesExtension currCertPolicies){\r\n    List<PolicyInformation> policyInfo = null;\r\n    try {\r\n        policyInfo = currCertPolicies.get(CertificatePoliciesExtension.POLICIES);\r\n    } catch (IOException ioe) {\r\n        throw new CertPathValidatorException(\"Exception while \" + \"retrieving policyOIDs\", ioe);\r\n    }\r\n    boolean childDeleted = false;\r\n    for (PolicyInformation curPolInfo : policyInfo) {\r\n        String curPolicy = curPolInfo.getPolicyIdentifier().getIdentifier().toString();\r\n        if (debug != null)\r\n            debug.println(\"PolicyChecker.processPolicies() \" + \"processing policy second time: \" + curPolicy);\r\n        Set<PolicyNodeImpl> validNodes = rootNode.getPolicyNodesValid(certIndex, curPolicy);\r\n        for (PolicyNodeImpl curNode : validNodes) {\r\n            PolicyNodeImpl parentNode = (PolicyNodeImpl) curNode.getParent();\r\n            if (parentNode.getValidPolicy().equals(ANY_POLICY)) {\r\n                if ((!initPolicies.contains(curPolicy)) && (!curPolicy.equals(ANY_POLICY))) {\r\n                    if (debug != null)\r\n                        debug.println(\"PolicyChecker.processPolicies() \" + \"before deleting: policy tree = \" + rootNode);\r\n                    parentNode.deleteChild(curNode);\r\n                    childDeleted = true;\r\n                    if (debug != null)\r\n                        debug.println(\"PolicyChecker.processPolicies() \" + \"after deleting: policy tree = \" + rootNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (childDeleted) {\r\n        rootNode.prune(certIndex);\r\n        if (!rootNode.getChildren().hasNext()) {\r\n            rootNode = null;\r\n        }\r\n    }\r\n    return rootNode;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.NameTable.getFunctionName",
	"Comment": "returns an appropriate name to use for this method as a function. this nameis guaranteed to be unique within the declaring class, if no methods in theclass have a renaming. the returned name should be given an appropriateprefix to avoid collisions with methods from other classes.",
	"Method": "String getFunctionName(ExecutableElement method){\r\n    String name = ElementUtil.getSelector(method);\r\n    if (name == null) {\r\n        name = getRenamedMethodName(method);\r\n    }\r\n    if (name != null) {\r\n        return name.replaceAll(\":\", \"_\");\r\n    } else {\r\n        return addParamNames(method, getMethodName(method), '_');\r\n    }\r\n}"
}, {
	"Path": "java.lang.ThreadLocal.createMap",
	"Comment": "create the map associated with a threadlocal. overridden ininheritablethreadlocal.",
	"Method": "void createMap(Thread t,T firstValue){\r\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\r\n}"
}, {
	"Path": "javax.net.ssl.SNIServerName.getEncoded",
	"Comment": "returns a copy of the encoded server name value of this server name.",
	"Method": "byte[] getEncoded(){\r\n    return encoded.clone();\r\n}"
}, {
	"Path": "java.util.Scanner.hasTokenInBuffer",
	"Comment": "means that there will be another token with or without more input.",
	"Method": "boolean hasTokenInBuffer(){\r\n    matchValid = false;\r\n    matcher.usePattern(delimPattern);\r\n    matcher.region(position, buf.limit());\r\n    if (matcher.lookingAt())\r\n        position = matcher.end();\r\n    if (position == buf.limit())\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.ObjectiveCHeaderGeneratorTest.testConstructorsDisallowed",
	"Comment": "so a subclass that only implements one should have the other three disallowed.",
	"Method": "void testConstructorsDisallowed(){\r\n    options.setDisallowInheritedConstructors(true);\r\n    String translation = translateSourceFile(\"class Test extends Exception { Test(String s) { super(s); } }\", \"Test\", \"Test.h\");\r\n    assertTranslation(translation, \"- (instancetype)initWithNSString:(NSString *)s;\");\r\n    assertTranslation(translation, \"- (instancetype)init NS_UNAVAILABLE;\");\r\n    assertTranslation(translation, \"- (instancetype)initWithJavaLangThrowable:(JavaLangThrowable *)arg0 NS_UNAVAILABLE;\");\r\n    assertTranslatedLines(translation, \"- (instancetype)initWithNSString:(NSString *)arg0\", \"withJavaLangThrowable:(JavaLangThrowable *)arg1 NS_UNAVAILABLE;\");\r\n    assertTranslatedLines(translation, \"- (instancetype)initWithNSString:(NSString *)arg0\", \"withJavaLangThrowable:(JavaLangThrowable *)arg1\", \"withBoolean:(jboolean)arg2\", \"withBoolean:(jboolean)arg3 NS_UNAVAILABLE;\");\r\n}"
}, {
	"Path": "android.icu.dev.test.timezone.TimeZoneRuleTest.compareTransitionsDescending",
	"Comment": "compare all time transitions in 2 time zones in the specified time range in descending order",
	"Method": "void compareTransitionsDescending(TimeZone tz1,TimeZone tz2,long start,long end,boolean inclusive){\r\n    BasicTimeZone z1 = (BasicTimeZone) tz1;\r\n    BasicTimeZone z2 = (BasicTimeZone) tz2;\r\n    String zid1 = tz1.getID();\r\n    String zid2 = tz2.getID();\r\n    long time = end;\r\n    while (true) {\r\n        TimeZoneTransition tzt1 = z1.getPreviousTransition(time, inclusive);\r\n        TimeZoneTransition tzt2 = z2.getPreviousTransition(time, inclusive);\r\n        boolean inRange1 = false;\r\n        boolean inRange2 = false;\r\n        if (tzt1 != null) {\r\n            if (tzt1.getTime() > start || (inclusive && tzt1.getTime() == start)) {\r\n                inRange1 = true;\r\n            }\r\n        }\r\n        if (tzt2 != null) {\r\n            if (tzt2.getTime() > start || (inclusive && tzt2.getTime() == start)) {\r\n                inRange2 = true;\r\n            }\r\n        }\r\n        if (!inRange1 && !inRange2) {\r\n            break;\r\n        }\r\n        if (!inRange1) {\r\n            errln(\"FAIL: \" + zid1 + \" does not have any transitions before \" + time + \" after \" + start);\r\n            break;\r\n        }\r\n        if (!inRange2) {\r\n            errln(\"FAIL: \" + zid2 + \" does not have any transitions before \" + time + \" after \" + start);\r\n            break;\r\n        }\r\n        if (tzt1.getTime() != tzt2.getTime()) {\r\n            errln(\"FAIL: Last transition before \" + time + \" \" + zid1 + \"[\" + tzt1.getTime() + \"] \" + zid2 + \"[\" + tzt2.getTime() + \"]\");\r\n            break;\r\n        }\r\n        time = tzt1.getTime();\r\n        if (inclusive) {\r\n            time--;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.nio.Buffer.remaining",
	"Comment": "returns the number of elements between the current position and thelimit.",
	"Method": "int remaining(){\r\n    return limit - position;\r\n}"
}, {
	"Path": "java.text.DecimalFormat.toPattern",
	"Comment": "synthesizes a pattern string that represents the current stateof this format object.",
	"Method": "String toPattern(String toPattern,boolean localized){\r\n    StringBuffer result = new StringBuffer();\r\n    for (int j = 1; j >= 0; --j) {\r\n        if (j == 1)\r\n            appendAffix(result, posPrefixPattern, positivePrefix, localized);\r\n        else\r\n            appendAffix(result, negPrefixPattern, negativePrefix, localized);\r\n        int i;\r\n        int digitCount = useExponentialNotation ? getMaximumIntegerDigits() : Math.max(groupingSize + secondaryGroupingSize, getMinimumIntegerDigits()) + 1;\r\n        for (i = digitCount; i > 0; --i) {\r\n            if (i != digitCount && isGroupingUsed() && groupingSize != 0 && (secondaryGroupingSize > 0 && i > groupingSize ? (i - groupingSize) % secondaryGroupingSize == 0 : i % groupingSize == 0)) {\r\n                result.append(localized ? symbols.getGroupingSeparator() : PATTERN_GROUPING_SEPARATOR);\r\n            }\r\n            result.append(i <= getMinimumIntegerDigits() ? (localized ? symbols.getZeroDigit() : PATTERN_ZERO_DIGIT) : (localized ? symbols.getDigit() : PATTERN_DIGIT));\r\n        }\r\n        if (getMaximumFractionDigits() > 0 || decimalSeparatorAlwaysShown)\r\n            result.append(localized ? symbols.getDecimalSeparator() : PATTERN_DECIMAL_SEPARATOR);\r\n        for (i = 0; i < getMaximumFractionDigits(); ++i) {\r\n            if (i < getMinimumFractionDigits()) {\r\n                result.append(localized ? symbols.getZeroDigit() : PATTERN_ZERO_DIGIT);\r\n            } else {\r\n                result.append(localized ? symbols.getDigit() : PATTERN_DIGIT);\r\n            }\r\n        }\r\n        if (useExponentialNotation) {\r\n            result.append(localized ? symbols.getExponentSeparator() : PATTERN_EXPONENT);\r\n            for (i = 0; i < minExponentDigits; ++i) result.append(localized ? symbols.getZeroDigit() : PATTERN_ZERO_DIGIT);\r\n        }\r\n        if (j == 1) {\r\n            appendAffix(result, posSuffixPattern, positiveSuffix, localized);\r\n            if ((negSuffixPattern == posSuffixPattern && negativeSuffix.equals(positiveSuffix)) || (negSuffixPattern != null && negSuffixPattern.equals(posSuffixPattern))) {\r\n                if ((negPrefixPattern != null && posPrefixPattern != null && negPrefixPattern.equals(\"'-\" + posPrefixPattern)) || (negPrefixPattern == posPrefixPattern && negativePrefix.equals(symbols.getMinusSign() + positivePrefix)))\r\n                    break;\r\n            }\r\n            result.append(localized ? symbols.getPatternSeparator() : PATTERN_SEPARATOR);\r\n        } else\r\n            appendAffix(result, negSuffixPattern, negativeSuffix, localized);\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "java.net.Socket.sendUrgentData",
	"Comment": "send one byte of urgent data on the socket. the byte to be sent is the lowest eightbits of the data parameter. the urgent byte issent after any preceding writes to the socket outputstreamand before any future writes to the outputstream.",
	"Method": "void sendUrgentData(int data){\r\n    if (!getImpl().supportsUrgentData()) {\r\n        throw new SocketException(\"Urgent data not supported\");\r\n    }\r\n    getImpl().sendUrgentData(data);\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArriveAndDeregister2",
	"Comment": "arriveandderegister reduces the number of arrived parties",
	"Method": "void testArriveAndDeregister2(){\r\n    final Phaser phaser = new Phaser(1);\r\n    assertEquals(0, phaser.register());\r\n    assertEquals(0, phaser.arrive());\r\n    assertState(phaser, 0, 2, 1);\r\n    assertEquals(0, phaser.arriveAndDeregister());\r\n    assertState(phaser, 1, 1, 1);\r\n}"
}, {
	"Path": "javax.crypto.Cipher.getAlgorithm",
	"Comment": "returns the algorithm name of this cipher object.this is the same name that was specified in one of thegetinstance calls that created this cipherobject..",
	"Method": "String getAlgorithm(){\r\n    return this.transformation;\r\n}"
}, {
	"Path": "java.util.concurrent.CyclicBarrier.nextGeneration",
	"Comment": "updates state on barrier trip and wakes up everyone.called only while holding lock.",
	"Method": "void nextGeneration(){\r\n    trip.signalAll();\r\n    count = parties;\r\n    generation = new Generation();\r\n}"
}, {
	"Path": "jsr166.TimeUnitTest.testTimedSleep_Interruptible",
	"Comment": "timedsleep throws interruptedexception when interrupted",
	"Method": "void testTimedSleep_Interruptible(){\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            TimeUnit tu = MILLISECONDS;\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                tu.sleep(LONG_DELAY_MS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                tu.sleep(LONG_DELAY_MS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadStaysAlive(t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.TimeUnitTest.testTimedSleep_Interruptible",
	"Comment": "timedsleep throws interruptedexception when interrupted",
	"Method": "void testTimedSleep_Interruptible(){\r\n    TimeUnit tu = MILLISECONDS;\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        tu.sleep(LONG_DELAY_MS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        tu.sleep(LONG_DELAY_MS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n}"
}, {
	"Path": "java.time.zone.ZoneRulesProvider.provideRefresh",
	"Comment": "spi method to refresh the rules from the underlying data provider.this method provides the opportunity for a provider to dynamicallyrecheck the underlying data provider to find the latest rules.this could be used to load new rules without stopping the jvm.dynamic behavior is entirely optional and most providers do not support it.this implementation returns false.",
	"Method": "boolean provideRefresh(){\r\n    return false;\r\n}"
}, {
	"Path": "java.util.logging.MemoryHandler.close",
	"Comment": "close the handler and free all associated resources.this will also close the target handler.",
	"Method": "void close(){\r\n    target.close();\r\n    setLevel(Level.OFF);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testGetSharedQueuedThreads_Shared",
	"Comment": "getsharedqueuedthreads returns all shared waiting threads",
	"Method": "void testGetSharedQueuedThreads_Shared(){\r\n    final BooleanLatch l = new BooleanLatch();\r\n    assertHasSharedQueuedThreads(l, NO_THREADS);\r\n    Thread t1 = newStartedThread(new CheckedInterruptedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            l.acquireSharedInterruptibly(0);\r\n        }\r\n    });\r\n    waitForQueuedThread(l, t1);\r\n    assertHasSharedQueuedThreads(l, t1);\r\n    Thread t2 = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            l.acquireSharedInterruptibly(0);\r\n        }\r\n    });\r\n    waitForQueuedThread(l, t2);\r\n    assertHasSharedQueuedThreads(l, t1, t2);\r\n    t1.interrupt();\r\n    awaitTermination(t1);\r\n    assertHasSharedQueuedThreads(l, t2);\r\n    assertTrue(l.releaseShared(0));\r\n    awaitTermination(t2);\r\n    assertHasSharedQueuedThreads(l, NO_THREADS);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testGetSharedQueuedThreads_Shared",
	"Comment": "getsharedqueuedthreads returns all shared waiting threads",
	"Method": "void testGetSharedQueuedThreads_Shared(){\r\n    l.acquireSharedInterruptibly(0);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testGetSharedQueuedThreads_Shared",
	"Comment": "getsharedqueuedthreads returns all shared waiting threads",
	"Method": "void testGetSharedQueuedThreads_Shared(){\r\n    l.acquireSharedInterruptibly(0);\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testAbnormalForkJoin",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoin(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() {\r\n            FailingFibTask f = new FailingFibTask(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                Integer r = f.join();\r\n                shouldThrow();\r\n            } catch (FJException success) {\r\n                checkCompletedAbnormally(f, success);\r\n            }\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(mainPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testAbnormalForkJoin",
	"Comment": "join of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkJoin(){\r\n    FailingFibTask f = new FailingFibTask(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        Integer r = f.join();\r\n        shouldThrow();\r\n    } catch (FJException success) {\r\n        checkCompletedAbnormally(f, success);\r\n    }\r\n    return NoResult;\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.getPatternSeparator",
	"Comment": "gets the character used to separate positive and negative subpatternsin a pattern.",
	"Method": "char getPatternSeparator(){\r\n    return patternSeparator;\r\n}"
}, {
	"Path": "java.net.JarURLConnection.getJarEntry",
	"Comment": "return the jar entry object for this connection, if any. thismethod returns null if the jar file url corresponding to thisconnection points to a jar file and not a jar file entry.",
	"Method": "JarEntry getJarEntry(){\r\n    return getJarFile().getJarEntry(entryName);\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArriveAndDeregister5",
	"Comment": "arriveandderegister deregisters one party from its parent whenthe number of parties of root is nonzero after deregistration.",
	"Method": "void testArriveAndDeregister5(){\r\n    Phaser root = new Phaser();\r\n    Phaser parent = new Phaser(root);\r\n    Phaser child = new Phaser(parent);\r\n    assertState(root, 0, 0, 0);\r\n    assertState(parent, 0, 0, 0);\r\n    assertState(child, 0, 0, 0);\r\n    assertEquals(0, child.register());\r\n    assertState(root, 0, 1, 1);\r\n    assertState(parent, 0, 1, 1);\r\n    assertState(child, 0, 1, 1);\r\n    assertEquals(0, child.arriveAndDeregister());\r\n    assertTerminated(child, 1);\r\n    assertTerminated(parent, 1);\r\n    assertTerminated(root, 1);\r\n}"
}, {
	"Path": "java.util.Calendar.getActualMaximum",
	"Comment": "returns the maximum value that the specified calendar fieldcould have, given the time value of thiscalendar. for example, the actual maximum value ofthe month field is 12 in some years, and 13 inother years in the hebrew calendar system.the default implementation of this method uses an iterativealgorithm to determine the actual maximum value for thecalendar field. subclasses should, if possible, override thiswith a more efficient implementation.",
	"Method": "int getActualMaximum(int field){\r\n    int fieldValue = getLeastMaximum(field);\r\n    int endValue = getMaximum(field);\r\n    if (fieldValue == endValue) {\r\n        return fieldValue;\r\n    }\r\n    Calendar work = (Calendar) this.clone();\r\n    work.setLenient(true);\r\n    if (field == WEEK_OF_YEAR || field == WEEK_OF_MONTH) {\r\n        work.set(DAY_OF_WEEK, firstDayOfWeek);\r\n    }\r\n    int result = fieldValue;\r\n    do {\r\n        work.set(field, fieldValue);\r\n        if (work.get(field) != fieldValue) {\r\n            break;\r\n        } else {\r\n            result = fieldValue;\r\n            fieldValue++;\r\n        }\r\n    } while (fieldValue <= endValue);\r\n    return result;\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArriveAndDeregister6",
	"Comment": "arriveandderegister returns the phase in which it leaves thephaser in after deregistration",
	"Method": "void testArriveAndDeregister6(){\r\n    final Phaser phaser = new Phaser(2);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            assertEquals(0, phaser.arrive());\r\n        }\r\n    });\r\n    assertEquals(1, phaser.arriveAndAwaitAdvance());\r\n    assertState(phaser, 1, 2, 2);\r\n    assertEquals(1, phaser.arriveAndDeregister());\r\n    assertState(phaser, 1, 1, 1);\r\n    assertEquals(1, phaser.arriveAndDeregister());\r\n    assertTerminated(phaser, 2);\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArriveAndDeregister6",
	"Comment": "arriveandderegister returns the phase in which it leaves thephaser in after deregistration",
	"Method": "void testArriveAndDeregister6(){\r\n    assertEquals(0, phaser.arrive());\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArriveAndDeregister3",
	"Comment": "arriveandderegister arrives at the barrier on a phaser with a parent andwhen a deregistration occurs and causes the phaser to have zero partiesits parent will be deregistered as well",
	"Method": "void testArriveAndDeregister3(){\r\n    Phaser parent = new Phaser();\r\n    Phaser child = new Phaser(parent);\r\n    assertState(child, 0, 0, 0);\r\n    assertState(parent, 0, 0, 0);\r\n    assertEquals(0, child.register());\r\n    assertState(child, 0, 1, 1);\r\n    assertState(parent, 0, 1, 1);\r\n    assertEquals(0, child.arriveAndDeregister());\r\n    assertTerminated(child, 1);\r\n    assertTerminated(parent, 1);\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArriveAndDeregister4",
	"Comment": "arriveandderegister deregisters one party from its parent whenthe number of parties of child is zero after deregistration",
	"Method": "void testArriveAndDeregister4(){\r\n    Phaser parent = new Phaser();\r\n    Phaser child = new Phaser(parent);\r\n    assertEquals(0, parent.register());\r\n    assertEquals(0, child.register());\r\n    assertState(child, 0, 1, 1);\r\n    assertState(parent, 0, 2, 2);\r\n    assertEquals(0, child.arriveAndDeregister());\r\n    assertState(child, 0, 0, 0);\r\n    assertState(parent, 0, 1, 1);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSubSetTest.populatedSet",
	"Comment": "returns a new set of given size containing consecutiveintegers 0 ... n.",
	"Method": "NavigableSet<Integer> populatedSet(int n){\r\n    ConcurrentSkipListSet<Integer> q = new ConcurrentSkipListSet<Integer>();\r\n    assertTrue(q.isEmpty());\r\n    for (int i = n - 1; i >= 0; i -= 2) assertTrue(q.add(new Integer(i)));\r\n    for (int i = (n & 1); i < n; i += 2) assertTrue(q.add(new Integer(i)));\r\n    assertTrue(q.add(new Integer(-n)));\r\n    assertTrue(q.add(new Integer(n)));\r\n    NavigableSet s = q.subSet(new Integer(0), true, new Integer(n), false);\r\n    assertFalse(s.isEmpty());\r\n    assertEquals(n, s.size());\r\n    return s;\r\n}"
}, {
	"Path": "java.io.StringBufferInputStream.available",
	"Comment": "returns the number of bytes that can be read from the inputstream without blocking.",
	"Method": "int available(){\r\n    return count - pos;\r\n}"
}, {
	"Path": "java.util.logging.Logger.setParent",
	"Comment": "set the parent for this logger.this method is used bythe logmanager to update a logger when the namespace changes.it should not be called from application code.",
	"Method": "void setParent(Logger parent){\r\n    if (parent == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    manager.checkPermission();\r\n    doSetParent(parent);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListMapTest.testPutIfAbsent2",
	"Comment": "putifabsent does not add the pair if the key is already present",
	"Method": "void testPutIfAbsent2(){\r\n    ConcurrentSkipListMap map = map5();\r\n    assertEquals(\"A\", map.putIfAbsent(one, \"Z\"));\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getExtendedKeyUsage",
	"Comment": "returns the extendedkeyusage criterion. the x509certificatemust allow the specified key purposes in its extended key usageextension. if the keypurposeset returned is empty ornull, no extendedkeyusage check will be done. note that anx509certificate that has no extendedkeyusage extensionimplicitly allows all key purposes.",
	"Method": "Set<String> getExtendedKeyUsage(){\r\n    return keyPurposeSet;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.ast.ChildList.modifiableDelegate",
	"Comment": "returns an arraylistimpl that is safe to modify. if delegate.count does not equal to zero,returns a copy of delegate.",
	"Method": "ArrayListImpl<ChildLink<T>> modifiableDelegate(){\r\n    if (delegate.getCount() != 0) {\r\n        delegate = new ArrayListImpl(delegate);\r\n    }\r\n    return delegate;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberRegressionTests.Test4134034",
	"Comment": "decimalformat produces extra zeros when formatting numbers.",
	"Method": "void Test4134034(){\r\n    DecimalFormat nf = new DecimalFormat(\"##,###,###.00\");\r\n    String f = nf.format(9.02);\r\n    if (f.equals(\"9.02\"))\r\n        logln(f + \" ok\");\r\n    else\r\n        errln(\"9.02 -> \" + f + \"; want 9.02\");\r\n    f = nf.format(0);\r\n    if (f.equals(\".00\"))\r\n        logln(f + \" ok\");\r\n    else\r\n        errln(\"0 -> \" + f + \"; want .00\");\r\n}"
}, {
	"Path": "java.net.URLStreamHandler.hashCode",
	"Comment": "provides the default hash calculation. may be overidden by handlers forother protocols that have different requirements for hashcodecalculation.",
	"Method": "int hashCode(URL u){\r\n    return Objects.hash(u.getRef(), u.getQuery(), u.getProtocol(), u.getFile(), u.getHost(), u.getPort());\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceArrayTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    final AtomicReferenceArray a = new AtomicReferenceArray(1);\r\n    a.set(0, one);\r\n    Thread t = new Thread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            while (!a.compareAndSet(0, two, three)) Thread.yield();\r\n        }\r\n    });\r\n    t.start();\r\n    assertTrue(a.compareAndSet(0, one, two));\r\n    t.join(LONG_DELAY_MS);\r\n    assertFalse(t.isAlive());\r\n    assertSame(three, a.get(0));\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceArrayTest.testCompareAndSetInMultipleThreads",
	"Comment": "compareandset in one thread enables another waiting for valueto succeed",
	"Method": "void testCompareAndSetInMultipleThreads(){\r\n    while (!a.compareAndSet(0, two, three)) Thread.yield();\r\n}"
}, {
	"Path": "android.icu.dev.test.timezone.TimeZoneRuleTest.TestVTimeZoneRoundTrip",
	"Comment": "write out time zone rules of olsontimezone into vtimezone format, create a newvtimezone from the vtimezone data, then compare transitions",
	"Method": "void TestVTimeZoneRoundTrip(){\r\n    long startTime = getUTCMillis(1850, Calendar.JANUARY, 1);\r\n    long endTime = getUTCMillis(2050, Calendar.JANUARY, 1);\r\n    String[] tzids = getTestZIDs();\r\n    for (int i = 0; i < tzids.length; i++) {\r\n        BasicTimeZone olsontz = (BasicTimeZone) TimeZone.getTimeZone(tzids[i], TimeZone.TIMEZONE_ICU);\r\n        VTimeZone vtz_org = VTimeZone.create(tzids[i]);\r\n        vtz_org.setTZURL(\"http://source.icu-project.org/timezone\");\r\n        vtz_org.setLastModified(new Date());\r\n        VTimeZone vtz_new = null;\r\n        try {\r\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n            OutputStreamWriter writer = new OutputStreamWriter(baos);\r\n            vtz_org.write(writer);\r\n            writer.close();\r\n            byte[] vtzdata = baos.toByteArray();\r\n            ByteArrayInputStream bais = new ByteArrayInputStream(vtzdata);\r\n            InputStreamReader reader = new InputStreamReader(bais);\r\n            vtz_new = VTimeZone.create(reader);\r\n            reader.close();\r\n            ByteArrayOutputStream baos1 = new ByteArrayOutputStream();\r\n            OutputStreamWriter writer1 = new OutputStreamWriter(baos1);\r\n            vtz_new.write(writer1);\r\n            writer1.close();\r\n            byte[] vtzdata1 = baos1.toByteArray();\r\n            if (vtzdata.length != vtzdata1.length) {\r\n                errln(\"FAIL: different VTIMEZONE data length\");\r\n            }\r\n            for (int j = 0; j < vtzdata.length; j++) {\r\n                if (vtzdata[j] != vtzdata1[j]) {\r\n                    errln(\"FAIL: different VTIMEZONE data\");\r\n                    break;\r\n                }\r\n            }\r\n        } catch (IOException ioe) {\r\n            errln(\"FAIL: IO error while writing/reading VTIMEZONE data\");\r\n        }\r\n        if (vtz_new.getOffset(startTime) != olsontz.getOffset(startTime)) {\r\n            errln(\"FAIL: VTimeZone for \" + tzids[i] + \" is not equivalent to its OlsonTimeZone corresponding at \" + startTime);\r\n        }\r\n        TimeZoneTransition tzt = olsontz.getNextTransition(startTime, false);\r\n        if (tzt != null) {\r\n            if (!vtz_new.hasEquivalentTransitions(olsontz, tzt.getTime(), endTime, true)) {\r\n                int maxDelta = 1000;\r\n                if (!hasEquivalentTransitions(vtz_new, olsontz, tzt.getTime() + maxDelta, endTime, true, maxDelta)) {\r\n                    errln(\"FAIL: VTimeZone for \" + tzids[i] + \" is not equivalent to its OlsonTimeZone corresponding.\");\r\n                } else {\r\n                    logln(\"VTimeZone for \" + tzids[i] + \" differs from its OlsonTimeZone corresponding with maximum transition time delta - \" + maxDelta);\r\n                }\r\n            }\r\n            if (!vtz_new.hasEquivalentTransitions(olsontz, tzt.getTime(), endTime, false)) {\r\n                logln(\"VTimeZone for \" + tzids[i] + \" is not equivalent to its OlsonTimeZone corresponding in strict comparison mode.\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingQueueTest.testInterruptedTimedPoll",
	"Comment": "interrupted timed poll throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPoll(){\r\n    final BlockingQueue<Integer> q = populatedQueue(SIZE);\r\n    final CountDownLatch aboutToWait = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            long startTime = System.nanoTime();\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n            }\r\n            aboutToWait.countDown();\r\n            try {\r\n                q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n                assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n            }\r\n        }\r\n    });\r\n    await(aboutToWait);\r\n    waitForThreadToEnterWaitState(t, LONG_DELAY_MS);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n    checkEmpty(q);\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingQueueTest.testInterruptedTimedPoll",
	"Comment": "interrupted timed poll throws interruptedexception instead ofreturning timeout status",
	"Method": "void testInterruptedTimedPoll(){\r\n    long startTime = System.nanoTime();\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));\r\n    }\r\n    aboutToWait.countDown();\r\n    try {\r\n        q.poll(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n        assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);\r\n    }\r\n}"
}, {
	"Path": "java.time.Duration.minusSeconds",
	"Comment": "returns a copy of this duration with the specified duration in seconds subtracted.this instance is immutable and unaffected by this method call.",
	"Method": "Duration minusSeconds(long secondsToSubtract){\r\n    return (secondsToSubtract == Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-secondsToSubtract));\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testLongArrayUpdateAndGet",
	"Comment": "atomiclongarray updateandget updates with supplied function andreturns result.",
	"Method": "void testLongArrayUpdateAndGet(){\r\n    AtomicLongArray a = new AtomicLongArray(1);\r\n    a.set(0, 1);\r\n    assertEquals(18L, a.updateAndGet(0, Atomic8Test::addLong17));\r\n    assertEquals(35L, a.updateAndGet(0, Atomic8Test::addLong17));\r\n    assertEquals(35L, a.get(0));\r\n}"
}, {
	"Path": "java.text.AttributedString.length",
	"Comment": "access it without creating an attributedcharacteriterator.",
	"Method": "int length(){\r\n    return text.length();\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testIntArrayAccumulateAndGet",
	"Comment": "atomicintegerarray accumulateandget updates with supplied function andreturns result.",
	"Method": "void testIntArrayAccumulateAndGet(){\r\n    AtomicIntegerArray a = new AtomicIntegerArray(1);\r\n    a.set(0, 1);\r\n    assertEquals(7, a.accumulateAndGet(0, 6, Integer::sum));\r\n    assertEquals(10, a.accumulateAndGet(0, 3, Integer::sum));\r\n}"
}, {
	"Path": "java.util.concurrent.Phaser.forceTermination",
	"Comment": "forces this phaser to enter termination state.counts ofregistered parties are unaffected.if this phaser is a memberof a tiered set of phasers, then all of the phasers in the setare terminated.if this phaser is already terminated, thismethod has no effect.this method may be useful forcoordinating recovery after one or more tasks encounterunexpected exceptions.",
	"Method": "void forceTermination(){\r\n    final Phaser root = this.root;\r\n    long s;\r\n    while ((s = root.state) >= 0) {\r\n        if (U.compareAndSwapLong(root, STATE, s, s | TERMINATION_BIT)) {\r\n            releaseWaiters(0);\r\n            releaseWaiters(1);\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testGetQueue",
	"Comment": "getqueue returns the work queue, which contains queued tasks",
	"Method": "void testGetQueue(){\r\n    final CountDownLatch done = new CountDownLatch(1);\r\n    final ScheduledThreadPoolExecutor p = new CustomExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p, done)) {\r\n        final CountDownLatch threadStarted = new CountDownLatch(1);\r\n        ScheduledFuture[] tasks = new ScheduledFuture[5];\r\n        for (int i = 0; i < tasks.length; i++) {\r\n            Runnable r = new CheckedRunnable() {\r\n                public void realRun() throws InterruptedException {\r\n                    threadStarted.countDown();\r\n                    await(done);\r\n                }\r\n            };\r\n            tasks[i] = p.schedule(r, 1, MILLISECONDS);\r\n        }\r\n        await(threadStarted);\r\n        BlockingQueue<Runnable> q = p.getQueue();\r\n        assertTrue(q.contains(tasks[tasks.length - 1]));\r\n        assertFalse(q.contains(tasks[0]));\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testGetQueue",
	"Comment": "getqueue returns the work queue, which contains queued tasks",
	"Method": "void testGetQueue(){\r\n    threadStarted.countDown();\r\n    await(done);\r\n}"
}, {
	"Path": "java.io.PipedWriter.flush",
	"Comment": "flushes this output stream and forces any buffered output charactersto be written out.this will notify any readers that characters are waiting in the pipe.",
	"Method": "void flush(){\r\n    if (sink != null) {\r\n        if (sink.closedByReader || closed) {\r\n            throw new IOException(\"Pipe closed\");\r\n        }\r\n        synchronized (sink) {\r\n            sink.notifyAll();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.Collections.fill",
	"Comment": "replaces all of the elements of the specified list with the specifiedelement. this method runs in linear time.",
	"Method": "void fill(List<? super T> list,T obj){\r\n    int size = list.size();\r\n    if (size < FILL_THRESHOLD || list instanceof RandomAccess) {\r\n        for (int i = 0; i < size; i++) list.set(i, obj);\r\n    } else {\r\n        ListIterator<? super T> itr = list.listIterator();\r\n        for (int i = 0; i < size; i++) {\r\n            itr.next();\r\n            itr.set(obj);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.time.chrono.ChronoPeriod.isNegative",
	"Comment": "checks if any of the supported units of this period are negative.",
	"Method": "boolean isNegative(){\r\n    for (TemporalUnit unit : getUnits()) {\r\n        if (get(unit) < 0) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "sun.security.pkcs.PKCS9Attributes.decode",
	"Comment": "decode this set of pkcs9 attributes from the contents of itsder encoding. ignores unsupported attributes when directed.",
	"Method": "byte[] decode(DerInputStream in){\r\n    DerValue val = in.getDerValue();\r\n    byte[] derEncoding = val.toByteArray();\r\n    derEncoding[0] = DerValue.tag_SetOf;\r\n    DerInputStream derIn = new DerInputStream(derEncoding);\r\n    DerValue[] derVals = derIn.getSet(3, true);\r\n    PKCS9Attribute attrib;\r\n    ObjectIdentifier oid;\r\n    boolean reuseEncoding = true;\r\n    for (int i = 0; i < derVals.length; i++) {\r\n        try {\r\n            attrib = new PKCS9Attribute(derVals[i]);\r\n        } catch (ParsingException e) {\r\n            if (ignoreUnsupportedAttributes) {\r\n                reuseEncoding = false;\r\n                continue;\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n        oid = attrib.getOID();\r\n        if (attributes.get(oid) != null)\r\n            throw new IOException(\"Duplicate PKCS9 attribute: \" + oid);\r\n        if (permittedAttributes != null && !permittedAttributes.containsKey(oid))\r\n            throw new IOException(\"Attribute \" + oid + \" not permitted in this attribute set\");\r\n        attributes.put(oid, attrib);\r\n    }\r\n    return reuseEncoding ? derEncoding : generateDerEncoding();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.TypeDeclarationGeneratorTest.testMethodSignatureMappingWithoutParameters",
	"Comment": "verify that generated source mappings are correct for methods that take no arguments.",
	"Method": "void testMethodSignatureMappingWithoutParameters(){\r\n    String source = \"class A { void zebra() {} }\";\r\n    CompilationUnit compilationUnit = translateType(\"A\", source);\r\n    GeneratedType generatedType = GeneratedType.fromTypeDeclaration(compilationUnit.getTypes().get(0));\r\n    GeneratedSourceMappings mappings = generatedType.getGeneratedSourceMappings();\r\n    boolean foundZebra = false;\r\n    for (GeneratedSourceMappings.Mapping mapping : mappings.getMappings()) {\r\n        if (mapping.getIdentifier().equals(\"zebra\")) {\r\n            foundZebra = true;\r\n            assertEquals(\"zebra\", source.substring(mapping.getSourceBegin(), mapping.getSourceEnd()));\r\n            assertEquals(\"zebra\", generatedType.getPublicDeclarationCode().substring(mapping.getTargetBegin(), mapping.getTargetEnd()));\r\n        }\r\n    }\r\n    if (!foundZebra) {\r\n        fail(\"No mapping found for zebra() method\");\r\n    }\r\n}"
}, {
	"Path": "java.net.JarURLConnection.getAttributes",
	"Comment": "return the attributes object for this connection if the urlfor it points to a jar file entry, null otherwise.",
	"Method": "Attributes getAttributes(){\r\n    JarEntry e = getJarEntry();\r\n    return e != null ? e.getAttributes() : null;\r\n}"
}, {
	"Path": "jsr166.ForkJoinPoolTest.testDrainTasksTo",
	"Comment": "draintasksto transfers unexecuted submitted tasks, if present",
	"Method": "void testDrainTasksTo(){\r\n    final CountDownLatch done = new CountDownLatch(1);\r\n    SubFJP p = new SubFJP();\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        ForkJoinTask a = p.submit(awaiter(done));\r\n        ForkJoinTask b = p.submit(awaiter(done));\r\n        ForkJoinTask c = p.submit(awaiter(done));\r\n        ArrayList<ForkJoinTask> al = new ArrayList();\r\n        p.drainTasksTo(al);\r\n        assertTrue(al.size() > 0);\r\n        for (ForkJoinTask r : al) {\r\n            assertTrue(r == a || r == b || r == c);\r\n            assertFalse(r.isDone());\r\n        }\r\n        done.countDown();\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getWaitQueueLength",
	"Comment": "returns an estimate of the number of threads waiting on thegiven condition associated with this synchronizer. note thatbecause timeouts and interrupts may occur at any time, theestimate serves only as an upper bound on the actual number ofwaiters.this method is designed for use in monitoring systemstate, not for synchronization control.",
	"Method": "int getWaitQueueLength(ConditionObject condition,int getWaitQueueLength){\r\n    if (!owns(condition))\r\n        throw new IllegalArgumentException(\"Not owner\");\r\n    return condition.getWaitQueueLength();\r\n}"
}, {
	"Path": "sun.security.x509.X500Name.countQuotes",
	"Comment": "counts double quotes in string.escaped quotes are ignored.",
	"Method": "int countQuotes(String string,int from,int to){\r\n    int count = 0;\r\n    int escape = 0;\r\n    for (int i = from; i < to; i++) {\r\n        if (string.charAt(i) == '\"' && escape % 2 == 0) {\r\n            count++;\r\n        }\r\n        escape = (string.charAt(i) == '\\\\') ? escape + 1 : 0;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "sun.security.x509.IPAddressName.subtreeDepth",
	"Comment": "return subtree depth of this name for purposes of determiningnameconstraints minimum and maximum bounds and for calculatingpath lengths in name subtrees.",
	"Method": "int subtreeDepth(){\r\n    throw new UnsupportedOperationException(\"subtreeDepth() not defined for IPAddressName\");\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.pipeline.TranslationProcessor.applyMutations",
	"Comment": "translates a parsed source file, modifying the compilation unit by substituting core java typeand method references with ios equivalents. for example, java.lang.object maps tonsobject, and java.lang.string to nsstring. the sourceis also modified to add support for ios memory management, extract inner classes, etc.",
	"Method": "void applyMutations(CompilationUnit unit,CodeReferenceMap deadCodeMap,ExternalAnnotations externalAnnotations,TimeTracker ticker){\r\n    ticker.push();\r\n    new LambdaTypeElementAdder(unit).run();\r\n    ticker.tick(\"LambdaTypeElementAdder\");\r\n    if (deadCodeMap != null) {\r\n        new DeadCodeEliminator(unit, deadCodeMap).run();\r\n        ticker.tick(\"DeadCodeEliminator\");\r\n    }\r\n    new ExternalAnnotationInjector(unit, externalAnnotations).run();\r\n    ticker.tick(\"ExternalAnnotationInjector\");\r\n    new OuterReferenceResolver(unit).run();\r\n    ticker.tick(\"OuterReferenceResolver\");\r\n    new GwtConverter(unit).run();\r\n    ticker.tick(\"GwtConverter\");\r\n    new SerializationStripper(unit).run();\r\n    ticker.tick(\"SerializationStripper\");\r\n    new NumberMethodRewriter(unit).run();\r\n    ticker.tick(\"NumberMethodRewriter\");\r\n    new ConstantBranchPruner(unit).run();\r\n    ticker.tick(\"ConstantBranchPruner\");\r\n    new Rewriter(unit).run();\r\n    ticker.tick(\"Rewriter\");\r\n    new AbstractMethodRewriter(unit, deadCodeMap).run();\r\n    ticker.tick(\"AbstractMethodRewriter\");\r\n    new VariableRenamer(unit).run();\r\n    ticker.tick(\"VariableRenamer\");\r\n    new EnhancedForRewriter(unit).run();\r\n    ticker.tick(\"EnhancedForRewriter\");\r\n    new LambdaRewriter(unit).run();\r\n    ticker.tick(\"LambdaRewriter\");\r\n    new Autoboxer(unit).run();\r\n    ticker.tick(\"Autoboxer\");\r\n    new InnerClassExtractor(unit).run();\r\n    ticker.tick(\"InnerClassExtractor\");\r\n    new DefaultMethodShimGenerator(unit, deadCodeMap).run();\r\n    ticker.tick(\"DefaultMethodShimGenerator\");\r\n    new InitializationNormalizer(unit).run();\r\n    ticker.tick(\"InitializationNormalizer\");\r\n    new NilCheckResolver(unit).run();\r\n    ticker.tick(\"NilCheckResolver\");\r\n    if (unit.getEnv().options().extractUnsequencedModifications()) {\r\n        new UnsequencedExpressionRewriter(unit).run();\r\n        ticker.tick(\"UnsequencedExpressionRewriter\");\r\n    }\r\n    unit.accept(new LabelRewriter());\r\n    ticker.tick(\"LabelRewriter\");\r\n    new VarargsRewriter(unit).run();\r\n    ticker.tick(\"VarargsRewriter\");\r\n    new JavaCloneWriter(unit).run();\r\n    ticker.tick(\"JavaCloneWriter\");\r\n    new OcniExtractor(unit, deadCodeMap).run();\r\n    ticker.tick(\"OcniExtractor\");\r\n    PackageInfoRewriter.run(unit);\r\n    ticker.tick(\"PackageInfoRewriter\");\r\n    new AnnotationRewriter(unit).run();\r\n    ticker.tick(\"AnnotationRewriter\");\r\n    new EnumRewriter(unit).run();\r\n    ticker.tick(\"EnumRewriter\");\r\n    new DestructorGenerator(unit).run();\r\n    ticker.tick(\"DestructorGenerator\");\r\n    new MetadataWriter(unit, deadCodeMap).run();\r\n    ticker.tick(\"MetadataWriter\");\r\n    new JavaToIOSMethodTranslator(unit).run();\r\n    ticker.tick(\"JavaToIOSMethodTranslator\");\r\n    new Functionizer(unit).run();\r\n    ticker.tick(\"Functionizer\");\r\n    new SuperMethodInvocationRewriter(unit).run();\r\n    ticker.tick(\"SuperMethodInvocationRewriter\");\r\n    new OperatorRewriter(unit).run();\r\n    ticker.tick(\"OperatorRewriter\");\r\n    new StaticVarRewriter(unit).run();\r\n    ticker.tick(\"StaticVarRewriter\");\r\n    new ArrayRewriter(unit).run();\r\n    ticker.tick(\"ArrayRewriter\");\r\n    new SwitchRewriter(unit).run();\r\n    ticker.tick(\"SwitchRewriter\");\r\n    unit.accept(new ComplexExpressionExtractor());\r\n    ticker.tick(\"ComplexExpressionExtractor\");\r\n    new CastResolver(unit).run();\r\n    ticker.tick(\"CastResolver\");\r\n    new PrivateDeclarationResolver(unit).run();\r\n    ticker.tick(\"PrivateDeclarationResolver\");\r\n    if (deadCodeMap != null) {\r\n        DeadCodeEliminator.removeDeadClasses(unit, deadCodeMap);\r\n        ticker.tick(\"removeDeadClasses\");\r\n    }\r\n    unit.validate();\r\n    ticker.pop();\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArrayListTest.testContainsAll",
	"Comment": "containsall returns true for collections with subset of elements",
	"Method": "void testContainsAll(){\r\n    CopyOnWriteArrayList full = populatedArray(3);\r\n    assertTrue(full.containsAll(Arrays.asList()));\r\n    assertTrue(full.containsAll(Arrays.asList(one)));\r\n    assertTrue(full.containsAll(Arrays.asList(one, two)));\r\n    assertFalse(full.containsAll(Arrays.asList(one, two, six)));\r\n    assertFalse(full.containsAll(Arrays.asList(six)));\r\n    try {\r\n        full.containsAll(null);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGet(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            FailingAsyncFib f = new FailingAsyncFib(8);\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                Throwable cause = success.getCause();\r\n                assertTrue(cause instanceof FJException);\r\n                checkCompletedAbnormally(f, cause);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task completes abnormally",
	"Method": "void testAbnormalForkTimedGet(){\r\n    FailingAsyncFib f = new FailingAsyncFib(8);\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        Throwable cause = success.getCause();\r\n        assertTrue(cause instanceof FJException);\r\n        checkCompletedAbnormally(f, cause);\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorBytesNegative3",
	"Comment": "create a negative number from an array of bytes.the number of bytes is 4.",
	"Method": "void testConstructorBytesNegative3(){\r\n    byte[] aBytes = { -128, -12, 56, 100 };\r\n    byte[] rBytes = { -128, -12, 56, 100 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorBytesNegative2",
	"Comment": "create a negative number from an array of bytes.the number fits in an integer.",
	"Method": "void testConstructorBytesNegative2(){\r\n    byte[] aBytes = { -12, 56, 100 };\r\n    byte[] rBytes = { -12, 56, 100 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "java.util.Properties.stringPropertyNames",
	"Comment": "returns a set of keys in this property list wherethe key and its corresponding value are strings,including distinct keys in the default property list if a keyof the same name has not already been found from the mainproperties list.properties whose key or value is notof type string are omitted.the returned set is not backed by the properties object.changes to this properties are not reflected in the set,or vice versa.",
	"Method": "Set<String> stringPropertyNames(){\r\n    Hashtable<String, String> h = new Hashtable();\r\n    enumerateStringProperties(h);\r\n    return h.keySet();\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorBytesNegative1",
	"Comment": "create a negative number from an array of bytes.the number fits in an array of integers.",
	"Method": "void testConstructorBytesNegative1(){\r\n    byte[] aBytes = { -12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 35, 26, 3, 91 };\r\n    byte[] rBytes = { -12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 35, 26, 3, 91 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorBytesNegative4",
	"Comment": "create a negative number from an array of bytes.the number of bytes is multiple of 4.",
	"Method": "void testConstructorBytesNegative4(){\r\n    byte[] aBytes = { -128, -12, 56, 100, -13, 56, 93, -78 };\r\n    byte[] rBytes = { -128, -12, 56, 100, -13, 56, 93, -78 };\r\n    BigInteger aNumber = new BigInteger(aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, aNumber.signum());\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testReferenceArrayUpdateAndGet",
	"Comment": "atomicreferencearray updateandget updates with supplied function andreturns result.",
	"Method": "void testReferenceArrayUpdateAndGet(){\r\n    AtomicReferenceArray<Integer> a = new AtomicReferenceArray<Integer>(1);\r\n    a.set(0, one);\r\n    assertEquals(new Integer(18), a.updateAndGet(0, Atomic8Test::addInteger17));\r\n    assertEquals(new Integer(35), a.updateAndGet(0, Atomic8Test::addInteger17));\r\n}"
}, {
	"Path": "java.util.concurrent.ArrayBlockingQueue.put",
	"Comment": "inserts the specified element at the tail of this queue, waitingfor space to become available if the queue is full.",
	"Method": "void put(E e){\r\n    Objects.requireNonNull(e);\r\n    final ReentrantLock lock = this.lock;\r\n    lock.lockInterruptibly();\r\n    try {\r\n        while (count == items.length) notFull.await();\r\n        enqueue(e);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "java.util.stream.Nodes.emptyNode",
	"Comment": "produces an empty node whose count is zero, has no children and no content.",
	"Method": "Node<T> emptyNode(StreamShape shape){\r\n    switch(shape) {\r\n        case REFERENCE:\r\n            return (Node<T>) EMPTY_NODE;\r\n        case INT_VALUE:\r\n            return (Node<T>) EMPTY_INT_NODE;\r\n        case LONG_VALUE:\r\n            return (Node<T>) EMPTY_LONG_NODE;\r\n        case DOUBLE_VALUE:\r\n            return (Node<T>) EMPTY_DOUBLE_NODE;\r\n        default:\r\n            throw new IllegalStateException(\"Unknown shape \" + shape);\r\n    }\r\n}"
}, {
	"Path": "java.net.URL.toString",
	"Comment": "constructs a string representation of this url. thestring is created by calling the toexternalformmethod of the stream protocol handler for this object.",
	"Method": "String toString(){\r\n    return toExternalForm();\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalQuietlyInvokeSingleton",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvokeSingleton(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingAsyncFib f = new FailingAsyncFib(8);\r\n            f.quietlyInvoke();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinTaskTest.testAbnormalQuietlyInvokeSingleton",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvokeSingleton(){\r\n    FailingAsyncFib f = new FailingAsyncFib(8);\r\n    f.quietlyInvoke();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n}"
}, {
	"Path": "javax.net.ssl.SSLParameters.getNeedClientAuth",
	"Comment": "returns whether client authentication should be required.",
	"Method": "boolean getNeedClientAuth(){\r\n    return needClientAuth;\r\n}"
}, {
	"Path": "jsr166.TimeUnitTest.testToSeconds",
	"Comment": "toseconds correctly converts sample values in different units toseconds",
	"Method": "void testToSeconds(){\r\n    for (long t = 0; t < 88888; ++t) {\r\n        assertEquals(t * 60 * 60 * 24, DAYS.toSeconds(t));\r\n        assertEquals(t * 60 * 60, HOURS.toSeconds(t));\r\n        assertEquals(t * 60, MINUTES.toSeconds(t));\r\n        assertEquals(t, SECONDS.toSeconds(t));\r\n        assertEquals(t, MILLISECONDS.toSeconds(t * 1000L));\r\n        assertEquals(t, MICROSECONDS.toSeconds(t * 1000000L));\r\n        assertEquals(t, NANOSECONDS.toSeconds(t * 1000000000L));\r\n    }\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.data_toString",
	"Comment": "data provider for string representation of the date instances",
	"Method": "Object[][] data_toString(){\r\n    return new Object[][] { { HijrahChronology.INSTANCE.date(1320, 1, 1), \"Hijrah-umalqura AH 1320-01-01\" }, { HijrahChronology.INSTANCE.date(1500, 10, 28), \"Hijrah-umalqura AH 1500-10-28\" }, { HijrahChronology.INSTANCE.date(1500, 10, 29), \"Hijrah-umalqura AH 1500-10-29\" }, { HijrahChronology.INSTANCE.date(1434, 12, 5), \"Hijrah-umalqura AH 1434-12-05\" }, { HijrahChronology.INSTANCE.date(1434, 12, 6), \"Hijrah-umalqura AH 1434-12-06\" } };\r\n}"
}, {
	"Path": "java.net.InetAddress.equals",
	"Comment": "compares this object against the specified object.the result is true if and only if the argument isnot null and it represents the same ip address asthis object.two instances of inetaddress represent the same ipaddress if the length of the byte arrays returned bygetaddress is the same for both, and each of thearray components is the same for the byte arrays.",
	"Method": "boolean equals(Object obj){\r\n    return false;\r\n}"
}, {
	"Path": "sun.security.util.DerValue.resetTag",
	"Comment": "set the tag of the attribute. commonly used to reset thetag value used for implicit encodings.",
	"Method": "void resetTag(byte tag){\r\n    this.tag = tag;\r\n}"
}, {
	"Path": "java.net.URLConnection.getHeaderField",
	"Comment": "returns the value of the named header field.if called on a connection that sets the same header multiple timeswith possibly different values, only the last value is returned.",
	"Method": "String getHeaderField(String name,String getHeaderField,int n){\r\n    return null;\r\n}"
}, {
	"Path": "java.util.LongSummaryStatistics.getAverage",
	"Comment": "returns the arithmetic mean of values recorded, or zero if no values have beenrecorded.",
	"Method": "double getAverage(){\r\n    return getCount() > 0 ? (double) getSum() / getCount() : 0.0d;\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this map.these mappings will replace any mappings that this map had forany of the keys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> m){\r\n    int n = m.size();\r\n    if (n == 0)\r\n        return;\r\n    if (n > threshold)\r\n        resize(capacity(n));\r\n    for (Entry<? extends K, ? extends V> e : m.entrySet()) put(e.getKey(), e.getValue());\r\n}"
}, {
	"Path": "java.util.LinkedHashMap.addEntry",
	"Comment": "this override alters behavior of superclass put method. it causes newlyallocated entry to get inserted at the end of the linked list andremoves the eldest entry if appropriate.",
	"Method": "void addEntry(int hash,K key,V value,int bucketIndex){\r\n    LinkedHashMapEntry<K, V> eldest = header.after;\r\n    if (eldest != header) {\r\n        boolean removeEldest;\r\n        size++;\r\n        try {\r\n            removeEldest = removeEldestEntry(eldest);\r\n        } finally {\r\n            size--;\r\n        }\r\n        if (removeEldest) {\r\n            removeEntryForKey(eldest.key);\r\n        }\r\n    }\r\n    super.addEntry(hash, key, value, bucketIndex);\r\n}"
}, {
	"Path": "java.security.cert.PKIXRevocationChecker.setOcspResponses",
	"Comment": "sets the ocsp responses. these responses are used to determinethe revocation status of the specified certificates when ocsp is used.",
	"Method": "void setOcspResponses(Map<X509Certificate, byte[]> responses){\r\n    if (responses == null) {\r\n        this.ocspResponses = Collections.<X509Certificate, byte[]>emptyMap();\r\n    } else {\r\n        Map<X509Certificate, byte[]> copy = new HashMap(responses.size());\r\n        for (Map.Entry<X509Certificate, byte[]> e : responses.entrySet()) {\r\n            copy.put(e.getKey(), e.getValue().clone());\r\n        }\r\n        this.ocspResponses = copy;\r\n    }\r\n}"
}, {
	"Path": "sun.nio.ch.AbstractPollSelectorImpl.updateSelectedKeys",
	"Comment": "copy the information in the pollfd structs into the opssof the corresponding channels. add the ready keys to theready queue.",
	"Method": "int updateSelectedKeys(){\r\n    int numKeysUpdated = 0;\r\n    for (int i = channelOffset; i < totalChannels; i++) {\r\n        int rOps = pollWrapper.getReventOps(i);\r\n        if (rOps != 0) {\r\n            SelectionKeyImpl sk = channelArray[i];\r\n            pollWrapper.putReventOps(i, 0);\r\n            if (selectedKeys.contains(sk)) {\r\n                if (sk.channel.translateAndSetReadyOps(rOps, sk)) {\r\n                    numKeysUpdated++;\r\n                }\r\n            } else {\r\n                sk.channel.translateAndSetReadyOps(rOps, sk);\r\n                if ((sk.nioReadyOps() & sk.nioInterestOps()) != 0) {\r\n                    selectedKeys.add(sk);\r\n                    numKeysUpdated++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return numKeysUpdated;\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_periodUntilDiffChrono",
	"Comment": "test to get the period between dates in different chronologies",
	"Method": "void test_periodUntilDiffChrono(HijrahDate h1,HijrahDate h2,ChronoPeriod p){\r\n    MinguoDate m = MinguoChronology.INSTANCE.date(h2);\r\n    ChronoPeriod period = h1.until(m);\r\n    assertEquals(period, p);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.NilCheckResolver.isBoxingMethod",
	"Comment": "checks if the given method is a primitive boxing or unboxing method.",
	"Method": "boolean isBoxingMethod(ExecutableElement method){\r\n    TypeElement declaringClass = ElementUtil.getDeclaringClass(method);\r\n    if (typeUtil.isBoxedType(declaringClass.asType())) {\r\n        String name = ElementUtil.getName(method);\r\n        TypeMirror returnType = method.getReturnType();\r\n        List<? extends VariableElement> params = method.getParameters();\r\n        if (name.equals(\"valueOf\") && params.size() == 1 && params.get(0).asType().getKind().isPrimitive()) {\r\n            return true;\r\n        }\r\n        if (params.isEmpty() && returnType.getKind().isPrimitive() && name.equals(TypeUtil.getName(returnType) + \"Value\")) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.net.Inet6Address.isMCGlobal",
	"Comment": "utility routine to check if the multicast address has global scope.",
	"Method": "boolean isMCGlobal(){\r\n    return ((ipaddress[0] & 0xff) == 0xff && (ipaddress[1] & 0x0f) == 0x0e);\r\n}"
}, {
	"Path": "java.net.Authenticator.getPasswordAuthentication",
	"Comment": "called when password authorization is needed.subclasses shouldoverride the default implementation, which returns null.",
	"Method": "PasswordAuthentication getPasswordAuthentication(){\r\n    return null;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getKeyUsage",
	"Comment": "returns the keyusage criterion. the x509certificatemust allow the specified keyusage values. if null, no keyusagecheck will be done.note that the boolean array returned is cloned to protect againstsubsequent modifications.",
	"Method": "boolean[] getKeyUsage(){\r\n    if (keyUsage == null) {\r\n        return null;\r\n    }\r\n    return keyUsage.clone();\r\n}"
}, {
	"Path": "com.google.j2objc.util.NativeTimeZoneTest.testAustraliaEasternTimeZoneTransitions",
	"Comment": "new south wales observed dst during world war i and world war ii, and has been observing dstsince 1971.",
	"Method": "void testAustraliaEasternTimeZoneTransitions(){\r\n    TimeZone sydney = TimeZone.getTimeZone(\"Australia/Sydney\");\r\n    assertEquals(36000000, sydney.getOffset(1459612800000L));\r\n    assertEquals(39600000, sydney.getOffset(1443888000000L));\r\n    assertEquals(36000000, sydney.getOffset(1428163200000L));\r\n    assertEquals(39600000, sydney.getOffset(1412438400000L));\r\n    assertEquals(36000000, sydney.getOffset(1396713600000L));\r\n    assertEquals(39600000, sydney.getOffset(1380988800000L));\r\n    assertEquals(36000000, sydney.getOffset(1365264000000L));\r\n    assertEquals(39600000, sydney.getOffset(1349539200000L));\r\n    assertEquals(36000000, sydney.getOffset(1333209600000L));\r\n    assertEquals(39600000, sydney.getOffset(1317484800000L));\r\n    assertEquals(36000000, sydney.getOffset(1301760000000L));\r\n    assertEquals(39600000, sydney.getOffset(1286035200000L));\r\n    assertEquals(36000000, sydney.getOffset(1270310400000L));\r\n    assertEquals(39600000, sydney.getOffset(1254585600000L));\r\n    assertEquals(36000000, sydney.getOffset(1238860800000L));\r\n    assertEquals(39600000, sydney.getOffset(1223136000000L));\r\n    assertEquals(36000000, sydney.getOffset(1207411200000L));\r\n    assertEquals(39600000, sydney.getOffset(1193500800000L));\r\n    assertEquals(36000000, sydney.getOffset(1174752000000L));\r\n    assertEquals(39600000, sydney.getOffset(1162051200000L));\r\n    assertEquals(36000000, sydney.getOffset(1143907200000L));\r\n    assertEquals(39600000, sydney.getOffset(1130601600000L));\r\n    assertEquals(36000000, sydney.getOffset(1111852800000L));\r\n    assertEquals(39600000, sydney.getOffset(1099152000000L));\r\n    assertEquals(36000000, sydney.getOffset(1080403200000L));\r\n    assertEquals(39600000, sydney.getOffset(1067097600000L));\r\n    assertEquals(36000000, sydney.getOffset(1048953600000L));\r\n    assertEquals(39600000, sydney.getOffset(1035648000000L));\r\n    assertEquals(36000000, sydney.getOffset(1017504000000L));\r\n    assertEquals(39600000, sydney.getOffset(1004198400000L));\r\n    assertEquals(36000000, sydney.getOffset(985449600000L));\r\n    assertEquals(39600000, sydney.getOffset(967305600000L));\r\n    assertEquals(36000000, sydney.getOffset(954000000000L));\r\n    assertEquals(39600000, sydney.getOffset(941299200000L));\r\n    assertEquals(36000000, sydney.getOffset(922550400000L));\r\n    assertEquals(39600000, sydney.getOffset(909244800000L));\r\n    assertEquals(36000000, sydney.getOffset(891100800000L));\r\n    assertEquals(39600000, sydney.getOffset(877795200000L));\r\n    assertEquals(36000000, sydney.getOffset(859651200000L));\r\n    assertEquals(39600000, sydney.getOffset(846345600000L));\r\n    assertEquals(36000000, sydney.getOffset(828201600000L));\r\n    assertEquals(39600000, sydney.getOffset(814896000000L));\r\n    assertEquals(36000000, sydney.getOffset(794332800000L));\r\n    assertEquals(39600000, sydney.getOffset(783446400000L));\r\n    assertEquals(36000000, sydney.getOffset(762883200000L));\r\n    assertEquals(39600000, sydney.getOffset(751996800000L));\r\n    assertEquals(36000000, sydney.getOffset(731433600000L));\r\n    assertEquals(39600000, sydney.getOffset(719942400000L));\r\n    assertEquals(36000000, sydney.getOffset(699379200000L));\r\n    assertEquals(39600000, sydney.getOffset(688492800000L));\r\n    assertEquals(36000000, sydney.getOffset(667929600000L));\r\n    assertEquals(39600000, sydney.getOffset(657043200000L));\r\n    assertEquals(36000000, sydney.getOffset(636480000000L));\r\n    assertEquals(39600000, sydney.getOffset(625593600000L));\r\n    assertEquals(36000000, sydney.getOffset(606240000000L));\r\n    assertEquals(39600000, sydney.getOffset(594144000000L));\r\n    assertEquals(36000000, sydney.getOffset(574790400000L));\r\n    assertEquals(39600000, sydney.getOffset(562089600000L));\r\n    assertEquals(36000000, sydney.getOffset(542736000000L));\r\n    assertEquals(39600000, sydney.getOffset(530035200000L));\r\n    assertEquals(36000000, sydney.getOffset(511286400000L));\r\n    assertEquals(39600000, sydney.getOffset(499190400000L));\r\n    assertEquals(36000000, sydney.getOffset(478627200000L));\r\n    assertEquals(39600000, sydney.getOffset(467740800000L));\r\n    assertEquals(36000000, sydney.getOffset(447177600000L));\r\n    assertEquals(39600000, sydney.getOffset(436291200000L));\r\n    assertEquals(36000000, sydney.getOffset(415728000000L));\r\n    assertEquals(39600000, sydney.getOffset(404841600000L));\r\n    assertEquals(36000000, sydney.getOffset(386697600000L));\r\n    assertEquals(39600000, sydney.getOffset(372787200000L));\r\n    assertEquals(36000000, sydney.getOffset(352224000000L));\r\n    assertEquals(39600000, sydney.getOffset(341337600000L));\r\n    assertEquals(36000000, sydney.getOffset(320774400000L));\r\n    assertEquals(39600000, sydney.getOffset(309888000000L));\r\n    assertEquals(36000000, sydney.getOffset(289324800000L));\r\n    assertEquals(39600000, sydney.getOffset(278438400000L));\r\n    assertEquals(36000000, sydney.getOffset(257875200000L));\r\n    assertEquals(39600000, sydney.getOffset(246988800000L));\r\n    assertEquals(36000000, sydney.getOffset(226425600000L));\r\n    assertEquals(39600000, sydney.getOffset(215539200000L));\r\n    assertEquals(36000000, sydney.getOffset(194976000000L));\r\n    assertEquals(39600000, sydney.getOffset(183484800000L));\r\n    assertEquals(36000000, sydney.getOffset(162921600000L));\r\n    assertEquals(39600000, sydney.getOffset(152035200000L));\r\n    assertEquals(36000000, sydney.getOffset(131472000000L));\r\n    assertEquals(39600000, sydney.getOffset(120585600000L));\r\n    assertEquals(36000000, sydney.getOffset(100022400000L));\r\n    assertEquals(39600000, sydney.getOffset(89136000000L));\r\n    assertEquals(36000000, sydney.getOffset(67968000000L));\r\n    assertEquals(39600000, sydney.getOffset(57686400000L));\r\n    assertEquals(36000000, sydney.getOffset(-813229200000L));\r\n    assertEquals(39600000, sydney.getOffset(-828345600000L));\r\n    assertEquals(36000000, sydney.getOffset(-844678800000L));\r\n    assertEquals(39600000, sydney.getOffset(-860400000000L));\r\n    assertEquals(36000000, sydney.getOffset(-876128400000L));\r\n    assertEquals(39600000, sydney.getOffset(-883641600000L));\r\n    assertEquals(36000000, sydney.getOffset(-1665392400000L));\r\n    assertEquals(39600000, sydney.getOffset(-1672567140000L));\r\n    assertEquals(36000000, sydney.getOffset(-1672567140001L));\r\n}"
}, {
	"Path": "java.util.EnumMap.hashCode",
	"Comment": "returns the hash code value for this map.the hash code of a map isdefined to be the sum of the hash codes of each entry in the map.",
	"Method": "int hashCode(int hashCode){\r\n    int h = 0;\r\n    for (int i = 0; i < keyUniverse.length; i++) {\r\n        if (null != vals[i]) {\r\n            h += entryHashCode(i);\r\n        }\r\n    }\r\n    return h;\r\n}"
}, {
	"Path": "sun.util.logging.PlatformLogger.isLoggable",
	"Comment": "returns true if a message of the given level would actuallybe logged by this logger.",
	"Method": "boolean isLoggable(int levelValue,boolean isLoggable,Level level,boolean isLoggable,Level level,boolean isLoggable,Level level,boolean isLoggable,Level level){\r\n    if (level == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    JavaLoggerProxy jlp = javaLoggerProxy;\r\n    return jlp != null ? jlp.isLoggable(level) : loggerProxy.isLoggable(level);\r\n}"
}, {
	"Path": "java.util.zip.InflaterOutputStream.close",
	"Comment": "writes any remaining uncompressed data to the output stream and closesthe underlying output stream.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        try {\r\n            finish();\r\n        } finally {\r\n            out.close();\r\n            closed = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.time.ZoneOffset.equals",
	"Comment": "checks if this offset is equal to another offset.the comparison is based on the amount of the offset in seconds.this is equivalent to a comparison by id.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof ZoneOffset) {\r\n        return totalSeconds == ((ZoneOffset) obj).totalSeconds;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "sun.nio.ch.NativeObject.getFloat",
	"Comment": "reads a float starting at the given offset from base of this nativeobject.",
	"Method": "float getFloat(int offset){\r\n    return unsafe.getFloat(offset + address);\r\n}"
}, {
	"Path": "sun.security.util.DerValue.isContextSpecific",
	"Comment": "returns true iff the context specific tag matches the passed tag.",
	"Method": "boolean isContextSpecific(boolean isContextSpecific,byte cntxtTag){\r\n    if (!isContextSpecific()) {\r\n        return false;\r\n    }\r\n    return ((tag & 0x01f) == cntxtTag);\r\n}"
}, {
	"Path": "java.time.Duration.minusHours",
	"Comment": "returns a copy of this duration with the specified duration in hours subtracted.the number of hours is multiplied by 3600 to obtain the number of seconds to subtract.this instance is immutable and unaffected by this method call.",
	"Method": "Duration minusHours(long hoursToSubtract){\r\n    return (hoursToSubtract == Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hoursToSubtract));\r\n}"
}, {
	"Path": "java.nio.MappedByteBuffer.mappingOffset",
	"Comment": "of the mapping. computed each time to avoid storing in every direct buffer.",
	"Method": "long mappingOffset(){\r\n    int ps = Bits.pageSize();\r\n    long offset = address % ps;\r\n    return (offset >= 0) ? offset : (ps + offset);\r\n}"
}, {
	"Path": "java.net.Socks4Message.getLength",
	"Comment": "returns the total number of bytes used for the request. this methodsearches for the end of the user id, then searches for the end of thepassword and returns the final index as the requests length.",
	"Method": "int getLength(){\r\n    int index = 0;\r\n    for (index = INDEX_USER_ID; buffer[index] != 0; index++) {\r\n    }\r\n    index++;\r\n    return index;\r\n}"
}, {
	"Path": "java.net.URLConnection.getDefaultRequestProperty",
	"Comment": "returns the value of the default request property. default requestproperties are set for every connection.",
	"Method": "String getDefaultRequestProperty(String key){\r\n    return null;\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArriveAndAwaitAdvanceBeforeInterrupt",
	"Comment": "arriveandawaitadvance continues waiting if interrupted while waiting",
	"Method": "void testArriveAndAwaitAdvanceBeforeInterrupt(){\r\n    final Phaser phaser = new Phaser();\r\n    assertEquals(0, phaser.register());\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() {\r\n            assertEquals(0, phaser.register());\r\n            assertFalse(Thread.currentThread().isInterrupted());\r\n            pleaseInterrupt.countDown();\r\n            assertEquals(1, phaser.arriveAndAwaitAdvance());\r\n            assertTrue(Thread.currentThread().isInterrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    waitForThreadToEnterWaitState(t, SHORT_DELAY_MS);\r\n    t.interrupt();\r\n    Thread.currentThread().interrupt();\r\n    assertEquals(1, phaser.arriveAndAwaitAdvance());\r\n    assertTrue(Thread.interrupted());\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testArriveAndAwaitAdvanceBeforeInterrupt",
	"Comment": "arriveandawaitadvance continues waiting if interrupted while waiting",
	"Method": "void testArriveAndAwaitAdvanceBeforeInterrupt(){\r\n    assertEquals(0, phaser.register());\r\n    assertFalse(Thread.currentThread().isInterrupted());\r\n    pleaseInterrupt.countDown();\r\n    assertEquals(1, phaser.arriveAndAwaitAdvance());\r\n    assertTrue(Thread.currentThread().isInterrupted());\r\n}"
}, {
	"Path": "sun.net.www.URLConnection.getHeaderFieldKey",
	"Comment": "return the key for the nth header field. returns null ifthere are fewer than n fields.this can be used to iteratethrough all the headers in the message.",
	"Method": "String getHeaderFieldKey(int n){\r\n    try {\r\n        getInputStream();\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n    MessageHeader props = properties;\r\n    return props == null ? null : props.getKey(n);\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceValuesToLong",
	"Comment": "returns the result of accumulating the given transformationof all values using the given reducer to combine values,and the given basis as an identity value.",
	"Method": "long reduceValuesToLong(long parallelismThreshold,ToLongFunction<? super V> transformer,long basis,LongBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceValuesToLongTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes normally.iscompletedabnormally and iscancelled return false for normallycompleted tasks",
	"Method": "void testQuietlyInvoke(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FibAction f = new FibAction(8);\r\n            f.quietlyInvoke();\r\n            assertEquals(21, f.result);\r\n            checkCompletedNormally(f);\r\n        }\r\n    };\r\n    checkInvoke(a);\r\n}"
}, {
	"Path": "jsr166.ForkJoinPool8Test.testQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes normally.iscompletedabnormally and iscancelled return false for normallycompleted tasks",
	"Method": "void testQuietlyInvoke(){\r\n    FibAction f = new FibAction(8);\r\n    f.quietlyInvoke();\r\n    assertEquals(21, f.result);\r\n    checkCompletedNormally(f);\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.hybridGCD",
	"Comment": "calculate gcd of this and b. this and b are changed by the computation.",
	"Method": "MutableBigInteger hybridGCD(MutableBigInteger b){\r\n    MutableBigInteger a = this;\r\n    MutableBigInteger q = new MutableBigInteger();\r\n    while (b.intLen != 0) {\r\n        if (Math.abs(a.intLen - b.intLen) < 2)\r\n            return a.binaryGCD(b);\r\n        MutableBigInteger r = a.divide(b, q);\r\n        a = b;\r\n        b = r;\r\n    }\r\n    return a;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceKeysToLong",
	"Comment": "returns the result of accumulating the given transformationof all keys using the given reducer to combine values, andthe given basis as an identity value.",
	"Method": "long reduceKeysToLong(long parallelismThreshold,ToLongFunction<? super K> transformer,long basis,LongBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceKeysToLongTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testShutdownNow_delayedTasks",
	"Comment": "shutdownnow returns a list containing tasks that were not run,and those tasks are drained from the queue",
	"Method": "void testShutdownNow_delayedTasks(){\r\n    final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);\r\n    List<ScheduledFuture> tasks = new ArrayList();\r\n    for (int i = 0; i < 3; i++) {\r\n        Runnable r = new NoOpRunnable();\r\n        tasks.add(p.schedule(r, 9, SECONDS));\r\n        tasks.add(p.scheduleAtFixedRate(r, 9, 9, SECONDS));\r\n        tasks.add(p.scheduleWithFixedDelay(r, 9, 9, SECONDS));\r\n    }\r\n    if (testImplementationDetails)\r\n        assertEquals(new HashSet(tasks), new HashSet(p.getQueue()));\r\n    final List<Runnable> queuedTasks;\r\n    try {\r\n        queuedTasks = p.shutdownNow();\r\n    } catch (SecurityException ok) {\r\n        return;\r\n    }\r\n    assertTrue(p.isShutdown());\r\n    assertTrue(p.getQueue().isEmpty());\r\n    if (testImplementationDetails)\r\n        assertEquals(new HashSet(tasks), new HashSet(queuedTasks));\r\n    assertEquals(tasks.size(), queuedTasks.size());\r\n    for (ScheduledFuture task : tasks) {\r\n        assertFalse(task.isDone());\r\n        assertFalse(task.isCancelled());\r\n    }\r\n    assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));\r\n    assertTrue(p.isTerminated());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesZero2",
	"Comment": "create a zero number from a sign and an array of zero bytes.the sign is 0.",
	"Method": "void testConstructorSignBytesZero2(){\r\n    byte[] aBytes = { -0, 0, +0, 0, 0, 00, 000 };\r\n    int aSign = 0;\r\n    byte[] rBytes = { 0 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 0, aNumber.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesZero3",
	"Comment": "create a zero number from a sign and an array of zero bytes.the sign is 1.",
	"Method": "void testConstructorSignBytesZero3(){\r\n    byte[] aBytes = { -0, 0, +0, 0, 0, 00, 000 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 0 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 0, aNumber.signum());\r\n}"
}, {
	"Path": "java.time.format.DateTimeParseContext.getLocale",
	"Comment": "gets the locale.this locale is used to control localization in the parse exceptwhere localization is controlled by the decimalstyle.",
	"Method": "Locale getLocale(){\r\n    return formatter.getLocale();\r\n}"
}, {
	"Path": "sun.security.x509.ReasonFlags.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    for (int i = 0; i < NAMES.length; i++) {\r\n        elements.addElement(NAMES[i]);\r\n    }\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testIntArrayUpdateAndGet",
	"Comment": "atomicintegerarray updateandget updates with supplied function andreturns result.",
	"Method": "void testIntArrayUpdateAndGet(){\r\n    AtomicIntegerArray a = new AtomicIntegerArray(1);\r\n    a.set(0, 1);\r\n    assertEquals(18, a.updateAndGet(0, Atomic8Test::addInt17));\r\n    assertEquals(35, a.updateAndGet(0, Atomic8Test::addInt17));\r\n    assertEquals(35, a.get(0));\r\n}"
}, {
	"Path": "java.util.concurrent.CyclicBarrier.getNumberWaiting",
	"Comment": "returns the number of parties currently waiting at the barrier.this method is primarily useful for debugging and assertions.",
	"Method": "int getNumberWaiting(){\r\n    final ReentrantLock lock = this.lock;\r\n    lock.lock();\r\n    try {\r\n        return parties - count;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinPool.getRunningThreadCount",
	"Comment": "returns an estimate of the number of worker threads that arenot blocked waiting to join tasks or for other managedsynchronization. this method may overestimate thenumber of running threads.",
	"Method": "int getRunningThreadCount(){\r\n    int rc = 0;\r\n    WorkQueue[] ws;\r\n    WorkQueue w;\r\n    if ((ws = workQueues) != null) {\r\n        for (int i = 1; i < ws.length; i += 2) {\r\n            if ((w = ws[i]) != null && w.isApparentlyUnblocked())\r\n                ++rc;\r\n        }\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "java.security.KeyStore.getCertificateChain",
	"Comment": "returns the certificate chain associated with the given alias.the certificate chain must have been associated with the aliasby a call to setkeyentry,or by a call to setentry with aprivatekeyentry.",
	"Method": "Certificate[] getCertificateChain(Certificate[] getCertificateChain,String alias){\r\n    if (!initialized) {\r\n        throw new KeyStoreException(\"Uninitialized keystore\");\r\n    }\r\n    return keyStoreSpi.engineGetCertificateChain(alias);\r\n}"
}, {
	"Path": "java.lang.ThreadGroup.parentOf",
	"Comment": "tests if this thread group is either the thread groupargument or one of its ancestor thread groups.",
	"Method": "boolean parentOf(ThreadGroup g){\r\n    for (; g != null; g = g.parent) {\r\n        if (g == this) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.jar.JarEntry.getAttributes",
	"Comment": "returns the manifest attributes for thisentry, or null if none.",
	"Method": "Attributes getAttributes(){\r\n    return attr;\r\n}"
}, {
	"Path": "java.security.DigestInputStream.toString",
	"Comment": "prints a string representation of this digest input stream andits associated message digest object.",
	"Method": "String toString(){\r\n    return \"[Digest Input Stream] \" + digest.toString();\r\n}"
}, {
	"Path": "sun.security.pkcs.SignerInfo.getCertificateChain",
	"Comment": "returns the certificate chain pertaining to this signerinfo.",
	"Method": "ArrayList<X509Certificate> getCertificateChain(PKCS7 block){\r\n    X509Certificate userCert;\r\n    userCert = block.getCertificate(certificateSerialNumber, issuerName);\r\n    if (userCert == null)\r\n        return null;\r\n    ArrayList<X509Certificate> certList = new ArrayList<X509Certificate>();\r\n    certList.add(userCert);\r\n    X509Certificate[] pkcsCerts = block.getCertificates();\r\n    if (pkcsCerts == null || userCert.getSubjectDN().equals(userCert.getIssuerDN())) {\r\n        return certList;\r\n    }\r\n    Principal issuer = userCert.getIssuerDN();\r\n    int start = 0;\r\n    while (true) {\r\n        boolean match = false;\r\n        int i = start;\r\n        while (i < pkcsCerts.length) {\r\n            if (issuer.equals(pkcsCerts[i].getSubjectDN())) {\r\n                certList.add(pkcsCerts[i]);\r\n                if (pkcsCerts[i].getSubjectDN().equals(pkcsCerts[i].getIssuerDN())) {\r\n                    start = pkcsCerts.length;\r\n                } else {\r\n                    issuer = pkcsCerts[i].getIssuerDN();\r\n                    X509Certificate tmpCert = pkcsCerts[start];\r\n                    pkcsCerts[start] = pkcsCerts[i];\r\n                    pkcsCerts[i] = tmpCert;\r\n                    start++;\r\n                }\r\n                match = true;\r\n                break;\r\n            } else {\r\n                i++;\r\n            }\r\n        }\r\n        if (!match)\r\n            break;\r\n    }\r\n    return certList;\r\n}"
}, {
	"Path": "java.security.MessageDigest.digest",
	"Comment": "completes the hash computation by performing final operationssuch as padding. the digest is reset after this call is made.",
	"Method": "byte[] digest(int digest,byte[] buf,int offset,int len,byte[] digest,byte[] input){\r\n    update(input);\r\n    return digest();\r\n}"
}, {
	"Path": "sun.security.x509.X509CertInfo.equals",
	"Comment": "compares two certificates, returning false if any datadiffers between the two.",
	"Method": "boolean equals(Object other,boolean equals,X509CertInfo other){\r\n    if (this == other) {\r\n        return (true);\r\n    } else if (rawCertInfo == null || other.rawCertInfo == null) {\r\n        return (false);\r\n    } else if (rawCertInfo.length != other.rawCertInfo.length) {\r\n        return (false);\r\n    }\r\n    for (int i = 0; i < rawCertInfo.length; i++) {\r\n        if (rawCertInfo[i] != other.rawCertInfo[i]) {\r\n            return (false);\r\n        }\r\n    }\r\n    return (true);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSubMapTest.testReplaceValue",
	"Comment": "replace value fails when the given key not mapped to expected value",
	"Method": "void testReplaceValue(){\r\n    ConcurrentNavigableMap map = map5();\r\n    assertEquals(\"A\", map.get(one));\r\n    assertFalse(map.replace(one, \"Z\", \"Z\"));\r\n    assertEquals(\"A\", map.get(one));\r\n}"
}, {
	"Path": "java.time.format.DateTimeFormatterBuilder.appendChronologyText",
	"Comment": "appends the chronology name to the formatter.the calendar system name will be output during a format.if the chronology cannot be obtained then an exception will be thrown.",
	"Method": "DateTimeFormatterBuilder appendChronologyText(TextStyle textStyle){\r\n    Objects.requireNonNull(textStyle, \"textStyle\");\r\n    appendInternal(new ChronoPrinterParser(textStyle));\r\n    return this;\r\n}"
}, {
	"Path": "java.net.InetAddress.isLoopbackAddress",
	"Comment": "utility routine to check if the inetaddress is a loopback address.",
	"Method": "boolean isLoopbackAddress(){\r\n    return false;\r\n}"
}, {
	"Path": "sun.security.x509.AlgorithmId.equals",
	"Comment": "compares two algorithm ids for equality.returns true iffthey are the same algorithm, ignoring algorithm parameters.",
	"Method": "boolean equals(AlgorithmId other,boolean equals,Object other,boolean equals,ObjectIdentifier id){\r\n    return algid.equals(id);\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testCastNewSingleThreadExecutor",
	"Comment": "a new singlethreadexecutor cannot be casted to concrete implementation",
	"Method": "void testCastNewSingleThreadExecutor(){\r\n    final ExecutorService e = Executors.newSingleThreadExecutor();\r\n    try (PoolCleaner cleaner = cleaner(e)) {\r\n        try {\r\n            ThreadPoolExecutor tpe = (ThreadPoolExecutor) e;\r\n            shouldThrow();\r\n        } catch (ClassCastException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.AtomicBooleanTest.testCompareAndSet",
	"Comment": "compareandset succeeds in changing value if equal to expected else fails",
	"Method": "void testCompareAndSet(){\r\n    AtomicBoolean ai = new AtomicBoolean(true);\r\n    assertTrue(ai.compareAndSet(true, false));\r\n    assertFalse(ai.get());\r\n    assertTrue(ai.compareAndSet(false, false));\r\n    assertFalse(ai.get());\r\n    assertFalse(ai.compareAndSet(true, false));\r\n    assertFalse(ai.get());\r\n    assertTrue(ai.compareAndSet(false, true));\r\n    assertTrue(ai.get());\r\n}"
}, {
	"Path": "java.util.logging.MemoryHandler.push",
	"Comment": "push any buffered output to the target handler.the buffer is then cleared.",
	"Method": "void push(){\r\n    for (int i = 0; i < count; i++) {\r\n        int ix = (start + i) % buffer.length;\r\n        LogRecord record = buffer[ix];\r\n        target.publish(record);\r\n    }\r\n    start = 0;\r\n    count = 0;\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_valueRange_monthDays",
	"Comment": "test to verify the maximum number of days by adding one month to a given date",
	"Method": "void test_valueRange_monthDays(int year,int month,int maxlength){\r\n    ChronoLocalDate date = HijrahChronology.INSTANCE.date(year, month, 1);\r\n    ValueRange range = null;\r\n    for (int i = 1; i <= 12; i++) {\r\n        range = date.range(ChronoField.DAY_OF_MONTH);\r\n        date = date.plus(1, ChronoUnit.MONTHS);\r\n        assertEquals(range.getMaximum(), month, maxlength);\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.ConstantBranchPruner.getSideEffects",
	"Comment": "extracts side effects from the given expression and returns the statementto insert.",
	"Method": "Statement getSideEffects(Expression expr){\r\n    Expression sideEffectsExpr = extractSideEffects(expr);\r\n    return sideEffectsExpr == null ? null : new ExpressionStatement(sideEffectsExpr);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.ast.TreeUtil.getQualifiedMainTypeName",
	"Comment": "gets the fully qualified name of the main type in this compilation unit.",
	"Method": "String getQualifiedMainTypeName(CompilationUnit unit){\r\n    PackageDeclaration pkg = unit.getPackage();\r\n    if (pkg.isDefaultPackage()) {\r\n        return unit.getMainTypeName();\r\n    } else {\r\n        return pkg.getName().getFullyQualifiedName() + '.' + unit.getMainTypeName();\r\n    }\r\n}"
}, {
	"Path": "java.time.Duration.toMinutes",
	"Comment": "gets the number of minutes in this duration.this returns the total number of minutes in the duration by dividing thenumber of seconds by 60.this instance is immutable and unaffected by this method call.",
	"Method": "long toMinutes(){\r\n    return seconds / SECONDS_PER_MINUTE;\r\n}"
}, {
	"Path": "java.util.logging.Logger.finest",
	"Comment": "log a finest message.if the logger is currently enabled for the finest messagelevel then the given message is forwarded to all theregistered output handler objects.",
	"Method": "void finest(String msg){\r\n    if (Level.FINEST.intValue() < levelValue) {\r\n        return;\r\n    }\r\n    log(Level.FINEST, msg);\r\n}"
}, {
	"Path": "org.xml.sax.helpers.AttributeListImpl.addAttribute",
	"Comment": "add an attribute to an attribute list.this method is provided for sax parser writers, to allow themto build up an attribute list incrementally before deliveringit to the application.",
	"Method": "void addAttribute(String name,String type,String value){\r\n    names.add(name);\r\n    types.add(type);\r\n    values.add(value);\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testGetCorePoolSize",
	"Comment": "getcorepoolsize returns size given in constructor if not otherwise set",
	"Method": "void testGetCorePoolSize(){\r\n    ThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertEquals(1, p.getCorePoolSize());\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.ElementUtil.findGetterMethod",
	"Comment": "locate method which matches either java or objective c getter name patterns.",
	"Method": "ExecutableElement findGetterMethod(String propertyName,TypeMirror propertyType,TypeElement declaringClass,boolean isStatic){\r\n    ExecutableElement getter = ElementUtil.findMethod(declaringClass, propertyName);\r\n    if (getter == null) {\r\n        String prefix = TypeUtil.isBoolean(propertyType) ? \"is\" : \"get\";\r\n        getter = ElementUtil.findMethod(declaringClass, prefix + NameTable.capitalize(propertyName));\r\n    }\r\n    return getter != null && isStatic == isStatic(getter) ? getter : null;\r\n}"
}, {
	"Path": "java.net.ServerSocket.getImpl",
	"Comment": "get the socketimpl attached to this socket, creatingit if necessary.",
	"Method": "SocketImpl getImpl(){\r\n    if (!created)\r\n        createImpl();\r\n    return impl;\r\n}"
}, {
	"Path": "sun.security.x509.SubjectAlternativeNameExtension.toString",
	"Comment": "returns a printable representation of the subjectalternativename.",
	"Method": "String toString(){\r\n    String result = super.toString() + \"SubjectAlternativeName [\\n\";\r\n    if (names == null) {\r\n        result += \"  null\\n\";\r\n    } else {\r\n        for (GeneralName name : names.names()) {\r\n            result += \"  \" + name + \"\\n\";\r\n        }\r\n    }\r\n    result += \"]\\n\";\r\n    return result;\r\n}"
}, {
	"Path": "libcore.java.security.StandardNames.assertDefaultCipherSuites",
	"Comment": "assert cipher suites match the default list in content and priority order and containonly cipher suites permitted by default.",
	"Method": "void assertDefaultCipherSuites(String[] cipherSuites){\r\n    assertValidCipherSuites(cipherSuites);\r\n    assertEquals(CIPHER_SUITES_DEFAULT, Arrays.asList(cipherSuites));\r\n    if (!IS_RI) {\r\n        List<String> disallowedDefaultCipherSuites = new ArrayList<String>();\r\n        for (String cipherSuite : cipherSuites) {\r\n            if (!isPermittedDefaultCipherSuite(cipherSuite)) {\r\n                disallowedDefaultCipherSuites.add(cipherSuite);\r\n            }\r\n        }\r\n        assertEquals(Collections.EMPTY_LIST, disallowedDefaultCipherSuites);\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.getNotAfter",
	"Comment": "gets the notafter date from the validity period of the certificate.",
	"Method": "Date getNotAfter(){\r\n    if (info == null)\r\n        return null;\r\n    try {\r\n        Date d = (Date) info.get(CertificateValidity.NAME + DOT + CertificateValidity.NOT_AFTER);\r\n        return d;\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.nio.Buffer.getElementSizeShift",
	"Comment": "for testing only. this field is accessed directly via jni from frameworks code.",
	"Method": "int getElementSizeShift(){\r\n    return _elementSizeShift;\r\n}"
}, {
	"Path": "javax.xml.datatype.FactoryFinder.find",
	"Comment": "finds the implementation class object in the specified order.mainentry point.package private so this code can be shared.",
	"Method": "Object find(String factoryId,String fallbackClassName){\r\n    ClassLoader classLoader = findClassLoader();\r\n    String systemProp = System.getProperty(factoryId);\r\n    if (systemProp != null && systemProp.length() > 0) {\r\n        if (debug)\r\n            debugPrintln(\"found \" + systemProp + \" in the system property \" + factoryId);\r\n        return newInstance(systemProp, classLoader);\r\n    }\r\n    try {\r\n        String factoryClassName = CacheHolder.cacheProps.getProperty(factoryId);\r\n        if (debug)\r\n            debugPrintln(\"found \" + factoryClassName + \" in $java.home/jaxp.properties\");\r\n        if (factoryClassName != null) {\r\n            return newInstance(factoryClassName, classLoader);\r\n        }\r\n    } catch (Exception ex) {\r\n        if (debug) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n    Object provider = findJarServiceProvider(factoryId);\r\n    if (provider != null) {\r\n        return provider;\r\n    }\r\n    if (fallbackClassName == null) {\r\n        throw new ConfigurationError(\"Provider for \" + factoryId + \" cannot be found\", null);\r\n    }\r\n    if (debug)\r\n        debugPrintln(\"loaded from fallback value: \" + fallbackClassName);\r\n    return newInstance(fallbackClassName, classLoader);\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicIntegerFieldUpdater.getAndDecrement",
	"Comment": "atomically decrements by one the current value of the field of thegiven object managed by this updater.",
	"Method": "int getAndDecrement(T obj,int getAndDecrement,T obj){\r\n    int prev, next;\r\n    do {\r\n        prev = get(obj);\r\n        next = prev - 1;\r\n    } while (!compareAndSet(obj, prev, next));\r\n    return prev;\r\n}"
}, {
	"Path": "javax.crypto.KeyAgreement.getAlgorithm",
	"Comment": "returns the algorithm name of this keyagreement object.this is the same name that was specified in one of thegetinstance calls that created thiskeyagreement object.",
	"Method": "String getAlgorithm(){\r\n    return this.algorithm;\r\n}"
}, {
	"Path": "sun.security.x509.RFC822Name.subtreeDepth",
	"Comment": "return subtree depth of this name for purposes of determiningnameconstraints minimum and maximum bounds.",
	"Method": "int subtreeDepth(){\r\n    String subtree = name;\r\n    int i = 1;\r\n    int atNdx = subtree.lastIndexOf('@');\r\n    if (atNdx >= 0) {\r\n        i++;\r\n        subtree = subtree.substring(atNdx + 1);\r\n    }\r\n    for (; subtree.lastIndexOf('.') >= 0; i++) {\r\n        subtree = subtree.substring(0, subtree.lastIndexOf('.'));\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "javax.net.ssl.HttpsURLConnection.getDefaultHostnameVerifier",
	"Comment": "gets the default hostnameverifier that is inheritedby new instances of this class.",
	"Method": "HostnameVerifier getDefaultHostnameVerifier(){\r\n    return NoPreloadHolder.defaultHostnameVerifier;\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinPool.tryCreateExternalQueue",
	"Comment": "constructs and tries to install a new external queue,failing if the workqueues array already has a queue atthe given index.",
	"Method": "void tryCreateExternalQueue(int index){\r\n    AuxState aux;\r\n    if ((aux = auxState) != null && index >= 0) {\r\n        WorkQueue q = new WorkQueue(this, null);\r\n        q.config = index;\r\n        q.scanState = ~UNSIGNALLED;\r\n        q.qlock = 1;\r\n        boolean installed = false;\r\n        aux.lock();\r\n        try {\r\n            WorkQueue[] ws;\r\n            if ((ws = workQueues) != null && index < ws.length && ws[index] == null) {\r\n                ws[index] = q;\r\n                installed = true;\r\n            }\r\n        } finally {\r\n            aux.unlock();\r\n        }\r\n        if (installed) {\r\n            try {\r\n                q.growArray();\r\n            } finally {\r\n                q.qlock = 0;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.Collections.singleton",
	"Comment": "returns an immutable set containing only the specified object.the returned set is serializable.",
	"Method": "Set<E> singleton(E o){\r\n    return new SingletonSet(o);\r\n}"
}, {
	"Path": "android.icu.dev.test.normalizer.NormalizerData.getCanonicalClass",
	"Comment": "gets the combining class of a character from the unicode character database.",
	"Method": "int getCanonicalClass(int ch){\r\n    return canonicalClass.get(ch);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalQuietlyInvokeSingleton",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvokeSingleton(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingCCF f = new LFCCF(8);\r\n            f.quietlyInvoke();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalQuietlyInvokeSingleton",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvokeSingleton(){\r\n    FailingCCF f = new LFCCF(8);\r\n    f.quietlyInvoke();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n}"
}, {
	"Path": "javax.net.ssl.KeyManagerFactory.getInstance",
	"Comment": "returns a keymanagerfactory object that acts as afactory for key managers. a new keymanagerfactory object encapsulating thekeymanagerfactoryspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "KeyManagerFactory getInstance(String algorithm,KeyManagerFactory getInstance,String algorithm,String provider,KeyManagerFactory getInstance,String algorithm,Provider provider){\r\n    GetInstance.Instance instance = GetInstance.getInstance(\"KeyManagerFactory\", KeyManagerFactorySpi.class, algorithm, provider);\r\n    return new KeyManagerFactory((KeyManagerFactorySpi) instance.impl, instance.provider, algorithm);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testFloatValuePosNotRounded",
	"Comment": "convert a positive number to a float value. rounding is not needed.",
	"Method": "void testFloatValuePosNotRounded(){\r\n    byte[] a = { -128, 1, 2, 3, 4, 5, 60, 23, 1, -3, -5 };\r\n    int aSign = 1;\r\n    float result = 1.5474726E26f;\r\n    float aNumber = new BigInteger(aSign, a).floatValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "jsr166.FutureTaskTest.testTimedGet_ExecutionException2",
	"Comment": "a runtime exception in task causes timed get to throw executionexception",
	"Method": "void testTimedGet_ExecutionException2(){\r\n    final ArithmeticException e = new ArithmeticException();\r\n    final PublicFutureTask task = new PublicFutureTask(new Callable() {\r\n        public Object call() {\r\n            throw e;\r\n        }\r\n    });\r\n    task.run();\r\n    try {\r\n        task.get(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        assertSame(e, success.getCause());\r\n        tryToConfuseDoneTask(task);\r\n        checkCompletedAbnormally(task, success.getCause());\r\n    }\r\n}"
}, {
	"Path": "jsr166.FutureTaskTest.testTimedGet_ExecutionException2",
	"Comment": "a runtime exception in task causes timed get to throw executionexception",
	"Method": "void testTimedGet_ExecutionException2(){\r\n    throw e;\r\n}"
}, {
	"Path": "java.util.zip.InflaterInputStream.read",
	"Comment": "reads a byte of uncompressed data. this method will block untilenough input is available for decompression.",
	"Method": "int read(int read,byte[] b,int off,int len){\r\n    ensureOpen();\r\n    if (b == null) {\r\n        throw new NullPointerException();\r\n    } else if (off < 0 || len < 0 || len > b.length - off) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (len == 0) {\r\n        return 0;\r\n    }\r\n    try {\r\n        int n;\r\n        while ((n = inf.inflate(b, off, len)) == 0) {\r\n            if (inf.finished() || inf.needsDictionary()) {\r\n                reachEOF = true;\r\n                return -1;\r\n            }\r\n            if (inf.needsInput()) {\r\n                fill();\r\n            }\r\n        }\r\n        if (inf.finished()) {\r\n            reachEOF = true;\r\n        }\r\n        return n;\r\n    } catch (DataFormatException e) {\r\n        String s = e.getMessage();\r\n        throw new ZipException(s != null ? s : \"Invalid ZLIB data format\");\r\n    }\r\n}"
}, {
	"Path": "java.nio.Bits.reserveMemory",
	"Comment": "which a process may access.all sizes are specified in bytes.",
	"Method": "void reserveMemory(long size,int cap){\r\n    synchronized (Bits.class) {\r\n        reservedMemory += size;\r\n        totalCapacity += cap;\r\n        count++;\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "java.util.PriorityQueue.iterator",
	"Comment": "returns an iterator over the elements in this queue. the iteratordoes not return the elements in any particular order.",
	"Method": "Iterator<E> iterator(){\r\n    return new Itr();\r\n}"
}, {
	"Path": "jsr166.ExchangerTest.testExchange_TimeoutException",
	"Comment": "timeout during wait for timed exchange throws timeoutexception",
	"Method": "void testExchange_TimeoutException(){\r\n    final Exchanger e = new Exchanger();\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            long startTime = System.nanoTime();\r\n            try {\r\n                e.exchange(null, timeoutMillis(), MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (TimeoutException success) {\r\n            }\r\n            assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n        }\r\n    });\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.ExchangerTest.testExchange_TimeoutException",
	"Comment": "timeout during wait for timed exchange throws timeoutexception",
	"Method": "void testExchange_TimeoutException(){\r\n    long startTime = System.nanoTime();\r\n    try {\r\n        e.exchange(null, timeoutMillis(), MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (TimeoutException success) {\r\n    }\r\n    assertTrue(millisElapsedSince(startTime) >= timeoutMillis());\r\n}"
}, {
	"Path": "android.icu.dev.test.normalizer.ConformanceTest.iterativeNorm",
	"Comment": "do a normalization using the iterative api in the given direction.",
	"Method": "String iterativeNorm(String str,Normalizer.Mode mode,StringBuffer buf,int dir,int options,String iterativeNorm,StringCharacterIterator str,Normalizer.Mode mode,StringBuffer buf,int dir,int options){\r\n    normalizer.setText(str);\r\n    normalizer.setMode(mode);\r\n    buf.setLength(0);\r\n    normalizer.setOption(-1, false);\r\n    normalizer.setOption(options, true);\r\n    int ch;\r\n    if (dir > 0) {\r\n        for (ch = normalizer.first(); ch != Normalizer.DONE; ch = normalizer.next()) {\r\n            buf.append(UTF16.valueOf(ch));\r\n        }\r\n    } else {\r\n        for (ch = normalizer.last(); ch != Normalizer.DONE; ch = normalizer.previous()) {\r\n            buf.insert(0, UTF16.valueOf(ch));\r\n        }\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "tests.support.Support_TimeZone.getOffset",
	"Comment": "return 0 to keep it simple, since this subclass is not used to test this method..",
	"Method": "int getOffset(int p1,int p2,int p3,int p4,int p5,int p6){\r\n    return 0;\r\n}"
}, {
	"Path": "java.util.zip.ZipOutputStream.close",
	"Comment": "closes the zip output stream as well as the stream being filtered.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        super.close();\r\n        closed = true;\r\n    }\r\n}"
}, {
	"Path": "java.text.CharacterIteratorFieldDelegate.getIterator",
	"Comment": "returns an attributedcharacteriterator that can be usedto iterate over the resulting formatted string.",
	"Method": "AttributedCharacterIterator getIterator(String string){\r\n    if (string.length() > size) {\r\n        attributedStrings.add(new AttributedString(string.substring(size)));\r\n        size = string.length();\r\n    }\r\n    int iCount = attributedStrings.size();\r\n    AttributedCharacterIterator[] iterators = new AttributedCharacterIterator[iCount];\r\n    for (int counter = 0; counter < iCount; counter++) {\r\n        iterators[counter] = ((AttributedString) attributedStrings.get(counter)).getIterator();\r\n    }\r\n    return new AttributedString(iterators).getIterator();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.StatementGeneratorTest.testFunctionalizedStringStringStatement",
	"Comment": "verify that string constants used in switch statements can be generated after functionizing.",
	"Method": "void testFunctionalizedStringStringStatement(){\r\n    String source = \"class A { \" + \"private static final String STR = \\\"\\\"; \" + \"private void f(String s) { switch(s) { case STR: return; } } \" + \"public void g() { f(\\\"\\\"); } }\";\r\n    translateSourceFile(source, \"A\", \"A.m\");\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberRegressionTests.Test4179818",
	"Comment": "decimalformat is incorrectly rounding numbers like 1.2501 to 1.2",
	"Method": "void Test4179818(){\r\n    String[] DATA = { \"1.2511\", \"#.#\", \"1.3\", \"1.2501\", \"#.#\", \"1.3\", \"0.9999\", \"#\", \"1\" };\r\n    DecimalFormat fmt = new DecimalFormat(\"#\", new DecimalFormatSymbols(Locale.US));\r\n    for (int i = 0; i < DATA.length; i += 3) {\r\n        double in = Double.valueOf(DATA[i]).doubleValue();\r\n        String pat = DATA[i + 1];\r\n        String exp = DATA[i + 2];\r\n        fmt.applyPattern(pat);\r\n        String out = fmt.format(in);\r\n        if (out.equals(exp)) {\r\n            logln(\"Ok: \" + in + \" x \" + pat + \" = \" + out);\r\n        } else {\r\n            errln(\"FAIL: \" + in + \" x  \" + pat + \" = \" + out + \", expected \" + exp);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.nio.ch.PollArrayWrapper.replaceEntry",
	"Comment": "writes the pollfd entry from the source wrapper at the source indexover the entry in the target wrapper at the target index. the sourcearray remains unchanged unless the source array and the target arethe same array.",
	"Method": "void replaceEntry(PollArrayWrapper source,int sindex,PollArrayWrapper target,int tindex){\r\n    target.putDescriptor(tindex, source.getDescriptor(sindex));\r\n    target.putEventOps(tindex, source.getEventOps(sindex));\r\n    target.putReventOps(tindex, source.getReventOps(sindex));\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.HeaderMap.useSourceDirectories",
	"Comment": "if true, generated source locations are determined as a function of the input source locationand not the package of the input source.",
	"Method": "boolean useSourceDirectories(){\r\n    return outputStyle == OutputStyleOption.SOURCE;\r\n}"
}, {
	"Path": "java.security.KeyStore.isKeyEntry",
	"Comment": "returns true if the entry identified by the given aliaswas created by a call to setkeyentry,or created by a call to setentry with aprivatekeyentry or a secretkeyentry.",
	"Method": "boolean isKeyEntry(String alias){\r\n    if (!initialized) {\r\n        throw new KeyStoreException(\"Uninitialized keystore\");\r\n    }\r\n    return keyStoreSpi.engineIsKeyEntry(alias);\r\n}"
}, {
	"Path": "android.icu.dev.test.timezone.TimeZoneTest.TestFebruary",
	"Comment": "test that a transition at the end of february is handled correctly.",
	"Method": "void TestFebruary(){\r\n    SimpleTimeZone tz1 = new SimpleTimeZone(// start: November, first, Sunday\r\n    -3 * MILLIS_PER_HOUR, \"nov-feb\", Calendar.NOVEMBER, 1, Calendar.SUNDAY, 0, Calendar.FEBRUARY, -1, Calendar.SUNDAY, 0);\r\n    SimpleTimeZone tz2 = new SimpleTimeZone(// start: November, 1 or after, Sunday\r\n    -3 * MILLIS_PER_HOUR, \"nov-feb2\", Calendar.NOVEMBER, 1, -Calendar.SUNDAY, 0, Calendar.FEBRUARY, -29, -Calendar.SUNDAY, 0);\r\n    GregorianCalendar gc = new GregorianCalendar(TimeZone.getTimeZone(\"Etc/GMT\"));\r\n    int[] data = { 2006, Calendar.NOVEMBER, 5, 02, 59, 59, -3, 2006, Calendar.NOVEMBER, 5, 03, 00, 00, -2, 2007, Calendar.FEBRUARY, 25, 01, 59, 59, -2, 2007, Calendar.FEBRUARY, 25, 02, 00, 00, -3, 2007, Calendar.NOVEMBER, 4, 02, 59, 59, -3, 2007, Calendar.NOVEMBER, 4, 03, 00, 00, -2, 2008, Calendar.FEBRUARY, 24, 01, 59, 59, -2, 2008, Calendar.FEBRUARY, 24, 02, 00, 00, -3, 2008, Calendar.NOVEMBER, 2, 02, 59, 59, -3, 2008, Calendar.NOVEMBER, 2, 03, 00, 00, -2, 2009, Calendar.FEBRUARY, 22, 01, 59, 59, -2, 2009, Calendar.FEBRUARY, 22, 02, 00, 00, -3, 2009, Calendar.NOVEMBER, 1, 02, 59, 59, -3, 2009, Calendar.NOVEMBER, 1, 03, 00, 00, -2, 2010, Calendar.FEBRUARY, 28, 01, 59, 59, -2, 2010, Calendar.FEBRUARY, 28, 02, 00, 00, -3 };\r\n    TimeZone[] timezones = { tz1, tz2 };\r\n    TimeZone tz;\r\n    Date dt;\r\n    int t, i, raw, dst;\r\n    int[] offsets = new int[2];\r\n    for (t = 0; t < timezones.length; ++t) {\r\n        tz = timezones[t];\r\n        for (i = 0; i < data.length; i += 7) {\r\n            gc.set(data[i], data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5]);\r\n            dt = gc.getTime();\r\n            tz.getOffset(dt.getTime(), false, offsets);\r\n            raw = offsets[0];\r\n            dst = offsets[1];\r\n            if ((raw + dst) != data[i + 6] * MILLIS_PER_HOUR) {\r\n                errln(\"test case \" + t + \".\" + (i / 7) + \": \" + \"tz.getOffset(\" + data[i] + \"-\" + (data[i + 1] + 1) + \"-\" + data[i + 2] + \" \" + data[i + 3] + \":\" + data[i + 4] + \":\" + data[i + 5] + \") returns \" + raw + \"+\" + dst + \" != \" + data[i + 6] * MILLIS_PER_HOUR);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testBlockingTakeFirst",
	"Comment": "takefirst removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTakeFirst(){\r\n    final LinkedBlockingDeque q = populatedDeque(SIZE);\r\n    final CountDownLatch pleaseInterrupt = new CountDownLatch(1);\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            for (int i = 0; i < SIZE; ++i) {\r\n                assertEquals(i, q.takeFirst());\r\n            }\r\n            Thread.currentThread().interrupt();\r\n            try {\r\n                q.takeFirst();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n            pleaseInterrupt.countDown();\r\n            try {\r\n                q.takeFirst();\r\n                shouldThrow();\r\n            } catch (InterruptedException success) {\r\n            }\r\n            assertFalse(Thread.interrupted());\r\n        }\r\n    });\r\n    await(pleaseInterrupt);\r\n    assertThreadStaysAlive(t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingDequeTest.testBlockingTakeFirst",
	"Comment": "takefirst removes existing elements until empty, then blocks interruptibly",
	"Method": "void testBlockingTakeFirst(){\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        assertEquals(i, q.takeFirst());\r\n    }\r\n    Thread.currentThread().interrupt();\r\n    try {\r\n        q.takeFirst();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n    pleaseInterrupt.countDown();\r\n    try {\r\n        q.takeFirst();\r\n        shouldThrow();\r\n    } catch (InterruptedException success) {\r\n    }\r\n    assertFalse(Thread.interrupted());\r\n}"
}, {
	"Path": "java.security.spec.X509EncodedKeySpec.getEncoded",
	"Comment": "returns the key bytes, encoded according to the x.509 standard.",
	"Method": "byte[] getEncoded(){\r\n    return super.getEncoded();\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testLongValueNegative1",
	"Comment": "convert a number to a negative long valuethe biginteger is longer than int.",
	"Method": "void testLongValueNegative1(){\r\n    byte[] aBytes = { 12, -1, 100, -2, -76, -128, 45, 91, 3 };\r\n    long result = -43630045168837885L;\r\n    long aNumber = new BigInteger(aBytes).longValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "sun.security.util.ManifestEntryVerifier.verify",
	"Comment": "go through all the digests, calculating the final digestand comparing it to the one in the manifest. if this isthe first time we have verified this object, remove itscode signers from sigfilesigners and place in verifiedsigners.",
	"Method": "CodeSigner[] verify(Hashtable<String, CodeSigner[]> verifiedSigners,Hashtable<String, CodeSigner[]> sigFileSigners){\r\n    if (skip) {\r\n        return null;\r\n    }\r\n    if (signers != null)\r\n        return signers;\r\n    for (int i = 0; i < digests.size(); i++) {\r\n        MessageDigest digest = digests.get(i);\r\n        byte[] manHash = manifestHashes.get(i);\r\n        byte[] theHash = digest.digest();\r\n        if (debug != null) {\r\n            debug.println(\"Manifest Entry: \" + name + \" digest=\" + digest.getAlgorithm());\r\n            debug.println(\"  manifest \" + toHex(manHash));\r\n            debug.println(\"  computed \" + toHex(theHash));\r\n            debug.println();\r\n        }\r\n        if (!MessageDigest.isEqual(theHash, manHash))\r\n            throw new SecurityException(digest.getAlgorithm() + \" digest error for \" + name);\r\n    }\r\n    signers = sigFileSigners.remove(name);\r\n    if (signers != null) {\r\n        verifiedSigners.put(name, signers);\r\n    }\r\n    return signers;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConvertTest.testLongValueNegative2",
	"Comment": "convert a number to a negative long valuethe number fits in a long.",
	"Method": "void testLongValueNegative2(){\r\n    byte[] aBytes = { -12, 56, 100, 45, -101, 45, 98 };\r\n    long result = -3315696807498398L;\r\n    long aNumber = new BigInteger(aBytes).longValue();\r\n    assertTrue(aNumber == result);\r\n}"
}, {
	"Path": "sun.security.jca.GetInstance.getServices",
	"Comment": "this method exists for compatibility with jce only. it will be removedonce jce has been changed to use the replacement method.",
	"Method": "List<Service> getServices(String type,String algorithm,List<Service> getServices,String type,List<String> algorithms,List<Service> getServices,List<ServiceId> ids){\r\n    ProviderList list = Providers.getProviderList();\r\n    return list.getServices(ids);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testGetSharedQueuedThreads_Exclusive",
	"Comment": "getsharedqueuedthreads does not include exclusively waiting threads",
	"Method": "void testGetSharedQueuedThreads_Exclusive(){\r\n    final Mutex sync = new Mutex();\r\n    assertTrue(sync.getSharedQueuedThreads().isEmpty());\r\n    sync.acquire();\r\n    assertTrue(sync.getSharedQueuedThreads().isEmpty());\r\n    Thread t1 = newStartedThread(new InterruptedSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t1);\r\n    assertTrue(sync.getSharedQueuedThreads().isEmpty());\r\n    Thread t2 = newStartedThread(new InterruptibleSyncRunnable(sync));\r\n    waitForQueuedThread(sync, t2);\r\n    assertTrue(sync.getSharedQueuedThreads().isEmpty());\r\n    t1.interrupt();\r\n    awaitTermination(t1);\r\n    assertTrue(sync.getSharedQueuedThreads().isEmpty());\r\n    sync.release();\r\n    awaitTermination(t2);\r\n    assertTrue(sync.getSharedQueuedThreads().isEmpty());\r\n}"
}, {
	"Path": "android.icu.dev.test.format.DataDrivenNumberFormatTestUtility.runFormatSuiteIncludingKnownFailures",
	"Comment": "runs every format test in data driven test suite including thosethat are known to fail.",
	"Method": "void runFormatSuiteIncludingKnownFailures(String fileName,CodeUnderTest codeUnderTest){\r\n    new DataDrivenNumberFormatTestUtility(codeUnderTest).run(fileName, RunMode.INCLUDE_KNOWN_FAILURES);\r\n}"
}, {
	"Path": "java.util.concurrent.Phaser.getRoot",
	"Comment": "returns the root ancestor of this phaser, which is the same asthis phaser if it has no parent.",
	"Method": "Phaser getRoot(){\r\n    return root;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.IndexedCollectionCertStore.matchX509Certs",
	"Comment": "iterate through all the x509certificates and add matches to thecollection.",
	"Method": "void matchX509Certs(CertSelector selector,Collection<Certificate> matches){\r\n    for (Object obj : certSubjects.values()) {\r\n        if (obj instanceof X509Certificate) {\r\n            X509Certificate cert = (X509Certificate) obj;\r\n            if (selector.match(cert)) {\r\n                matches.add(cert);\r\n            }\r\n        } else {\r\n            @SuppressWarnings(\"unchecked\")\r\n            List<X509Certificate> list = (List<X509Certificate>) obj;\r\n            for (X509Certificate cert : list) {\r\n                if (selector.match(cert)) {\r\n                    matches.add(cert);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.BuildStep.getResult",
	"Comment": "return the result code associated with this build step.the result codesare possible, follow, back, fail, succeed.",
	"Method": "int getResult(){\r\n    return result;\r\n}"
}, {
	"Path": "java.net.Inet6Address.isMCSiteLocal",
	"Comment": "utility routine to check if the multicast address has site scope.",
	"Method": "boolean isMCSiteLocal(){\r\n    return ((ipaddress[0] & 0xff) == 0xff && (ipaddress[1] & 0x0f) == 0x05);\r\n}"
}, {
	"Path": "sun.security.x509.CertificateSerialNumber.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(NUMBER);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicLongFieldUpdater.decrementAndGet",
	"Comment": "atomically decrements by one the current value of the field of thegiven object managed by this updater.",
	"Method": "long decrementAndGet(T obj,long decrementAndGet,T obj){\r\n    long prev, next;\r\n    do {\r\n        prev = get(obj);\r\n        next = prev - 1;\r\n    } while (!compareAndSet(obj, prev, next));\r\n    return next;\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedSynchronizerTest.testSignalAll_IMSE",
	"Comment": "calling signalall without holding sync throws illegalmonitorstateexception",
	"Method": "void testSignalAll_IMSE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    try {\r\n        c.signalAll();\r\n        shouldThrow();\r\n    } catch (IllegalMonitorStateException success) {\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.util.ICUServiceThreadTest.getFactoryCollection",
	"Comment": "return a collection of unique factories, might be fewer than requested",
	"Method": "Collection getFactoryCollection(int requested){\r\n    Set locales = new HashSet();\r\n    for (int i = 0; i < requested; ++i) {\r\n        locales.add(getCLV());\r\n    }\r\n    List factories = new ArrayList(locales.size());\r\n    Iterator iter = locales.iterator();\r\n    while (iter.hasNext()) {\r\n        factories.add(new TestFactory((String) iter.next()));\r\n    }\r\n    return factories;\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testCancelledForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGet(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() throws Exception {\r\n            CCF f = new LCCF(8);\r\n            assertTrue(f.cancel(true));\r\n            assertSame(f, f.fork());\r\n            try {\r\n                f.get(LONG_DELAY_MS, MILLISECONDS);\r\n                shouldThrow();\r\n            } catch (CancellationException success) {\r\n                checkCancelled(f);\r\n            }\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testCancelledForkTimedGet",
	"Comment": "timed get of a forked task throws exception when task cancelled",
	"Method": "void testCancelledForkTimedGet(){\r\n    CCF f = new LCCF(8);\r\n    assertTrue(f.cancel(true));\r\n    assertSame(f, f.fork());\r\n    try {\r\n        f.get(LONG_DELAY_MS, MILLISECONDS);\r\n        shouldThrow();\r\n    } catch (CancellationException success) {\r\n        checkCancelled(f);\r\n    }\r\n}"
}, {
	"Path": "sun.net.ProgressMonitor.shouldMeterInput",
	"Comment": "return true if metering should be turned onfor a particular url input stream.",
	"Method": "boolean shouldMeterInput(URL url,String method,boolean shouldMeterInput,URL url,String method){\r\n    return meteringPolicy.shouldMeterInput(url, method);\r\n}"
}, {
	"Path": "jsr166.AtomicStampedReferenceTest.testWeakCompareAndSet",
	"Comment": "repeated weakcompareandset succeeds in changing values when equalto expected",
	"Method": "void testWeakCompareAndSet(){\r\n    int[] mark = new int[1];\r\n    AtomicStampedReference ai = new AtomicStampedReference(one, 0);\r\n    assertSame(one, ai.get(mark));\r\n    assertEquals(0, ai.getStamp());\r\n    assertEquals(0, mark[0]);\r\n    do {\r\n    } while (!ai.weakCompareAndSet(one, two, 0, 0));\r\n    assertSame(two, ai.get(mark));\r\n    assertEquals(0, mark[0]);\r\n    do {\r\n    } while (!ai.weakCompareAndSet(two, m3, 0, 1));\r\n    assertSame(m3, ai.get(mark));\r\n    assertEquals(1, mark[0]);\r\n}"
}, {
	"Path": "org.apache.harmony.luni.tests.java.util.EmptyStackExceptionTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this method\tis called before a test is executed.",
	"Method": "void setUp(){\r\n    s = new Stack();\r\n    for (int counter = 0; counter < objArray.length; counter++) s.push(objArray[counter]);\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testTimedCallable",
	"Comment": "future.get on submitted tasks will time out if they compute too long.",
	"Method": "void testTimedCallable(){\r\n    final ExecutorService[] executors = { Executors.newSingleThreadExecutor(), Executors.newCachedThreadPool(), Executors.newFixedThreadPool(2), Executors.newScheduledThreadPool(2) };\r\n    final Runnable sleeper = new CheckedInterruptedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            delay(LONG_DELAY_MS);\r\n        }\r\n    };\r\n    List<Thread> threads = new ArrayList<Thread>();\r\n    for (final ExecutorService executor : executors) {\r\n        threads.add(newStartedThread(new CheckedRunnable() {\r\n            public void realRun() {\r\n                Future future = executor.submit(sleeper);\r\n                assertFutureTimesOut(future);\r\n            }\r\n        }));\r\n    }\r\n    for (Thread thread : threads) awaitTermination(thread);\r\n    for (ExecutorService executor : executors) joinPool(executor);\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testTimedCallable",
	"Comment": "future.get on submitted tasks will time out if they compute too long.",
	"Method": "void testTimedCallable(){\r\n    delay(LONG_DELAY_MS);\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testTimedCallable",
	"Comment": "future.get on submitted tasks will time out if they compute too long.",
	"Method": "void testTimedCallable(){\r\n    Future future = executor.submit(sleeper);\r\n    assertFutureTimesOut(future);\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.checkCompletesNormally",
	"Comment": "waits for the task to complete, and checks that when it does,it will have an integer result equals to the given int.",
	"Method": "void checkCompletesNormally(RecursiveTask<Integer> a,int expected){\r\n    Integer r = a.join();\r\n    assertEquals(expected, (int) r);\r\n    checkCompletedNormally(a, r);\r\n}"
}, {
	"Path": "jsr166.PriorityBlockingQueueTest.testConstructor5",
	"Comment": "initializing from collection with some null elements throws npe",
	"Method": "void testConstructor5(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE - 1; ++i) ints[i] = i;\r\n    Collection<Integer> elements = Arrays.asList(ints);\r\n    try {\r\n        new PriorityBlockingQueue(elements);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "sun.security.util.DerInputBuffer.getGeneralizedTime",
	"Comment": "returns the generalized time value that takes up the specifiednumber of bytes in this buffer.",
	"Method": "Date getGeneralizedTime(int len){\r\n    if (len > available())\r\n        throw new IOException(\"short read of DER Generalized Time\");\r\n    if (len < 13 || len > 23)\r\n        throw new IOException(\"DER Generalized Time length error\");\r\n    return getTime(len, true);\r\n}"
}, {
	"Path": "java.lang.ThreadLocal.childValue",
	"Comment": "method childvalue is visibly defined in subclassinheritablethreadlocal, but is internally defined here for thesake of providing createinheritedmap factory method withoutneeding to subclass the map class in inheritablethreadlocal.this technique is preferable to the alternative of embeddinginstanceof tests in methods.",
	"Method": "T childValue(T parentValue){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "java.util.ListResourceBundle.getKeys",
	"Comment": "returns an enumeration of the keys contained inthis resourcebundle and its parent bundles.",
	"Method": "Enumeration<String> getKeys(){\r\n    if (lookup == null) {\r\n        loadLookup();\r\n    }\r\n    ResourceBundle parent = this.parent;\r\n    return new ResourceBundleEnumeration(lookup.keySet(), (parent != null) ? parent.getKeys() : null);\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicLongArray.toString",
	"Comment": "returns the string representation of the current values of array.",
	"Method": "String toString(){\r\n    int iMax = array.length - 1;\r\n    if (iMax == -1)\r\n        return \"[]\";\r\n    StringBuilder b = new StringBuilder();\r\n    b.append('[');\r\n    for (int i = 0; ; i++) {\r\n        b.append(getUnchecked(i));\r\n        if (i == iMax)\r\n            return b.append(']').toString();\r\n        b.append(',').append(' ');\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.DistributionPointName.getFullName",
	"Comment": "returns the full name for the distribution point or null if not set.",
	"Method": "GeneralNames getFullName(){\r\n    return fullName;\r\n}"
}, {
	"Path": "jsr166.PriorityBlockingQueueTest.testConstructor6",
	"Comment": "queue contains all elements of collection used to initialize",
	"Method": "void testConstructor6(){\r\n    Integer[] ints = new Integer[SIZE];\r\n    for (int i = 0; i < SIZE; ++i) ints[i] = i;\r\n    PriorityBlockingQueue q = new PriorityBlockingQueue(Arrays.asList(ints));\r\n    for (int i = 0; i < SIZE; ++i) assertEquals(ints[i], q.poll());\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedLongSynchronizer.owns",
	"Comment": "queries whether the given conditionobjectuses this synchronizer as its lock.",
	"Method": "boolean owns(ConditionObject condition){\r\n    return condition.isOwnedBy(this);\r\n}"
}, {
	"Path": "java.net.ServerSocket.toString",
	"Comment": "returns the implementation address and implementation port ofthis socket as a string.",
	"Method": "String toString(){\r\n    if (!isBound())\r\n        return \"ServerSocket[unbound]\";\r\n    InetAddress in;\r\n    if (!NetUtil.doRevealLocalAddress() && System.getSecurityManager() != null) {\r\n        in = InetAddress.getLoopbackAddress();\r\n    } else {\r\n        in = impl.getInetAddress();\r\n    }\r\n    return \"ServerSocket[addr=\" + in + \",localport=\" + impl.getLocalPort() + \"]\";\r\n}"
}, {
	"Path": "android.icu.dev.test.normalizer.UnicodeNormalizer.normalize",
	"Comment": "normalizes text according to the chosen form, replacing contents of the target buffer.",
	"Method": "StringBuffer normalize(String source,StringBuffer target,String normalize,String source){\r\n    return normalize(source, new StringBuffer()).toString();\r\n}"
}, {
	"Path": "java.security.Provider.putAll",
	"Comment": "copies all of the mappings from the specified map to this provider.these mappings will replace any properties that this provider hadfor any of the keys currently in the specified map.",
	"Method": "void putAll(Map<?, ?> t){\r\n    check(\"putProviderProperty.\" + name);\r\n    implPutAll(t);\r\n}"
}, {
	"Path": "android.icu.dev.test.normalizer.UnicodeNormalizer.internalCompose",
	"Comment": "composes text in place. target must already have been decomposed.",
	"Method": "void internalCompose(StringBuffer target){\r\n    int starterPos = 0;\r\n    int starterCh = UTF16Util.nextCodePoint(target, 0);\r\n    int compPos = UTF16Util.codePointLength(starterCh);\r\n    int lastClass = data.getCanonicalClass(starterCh);\r\n    if (lastClass != 0)\r\n        lastClass = 256;\r\n    for (int decompPos = UTF16Util.codePointLength(starterCh); decompPos < target.length(); ) {\r\n        int ch = UTF16Util.nextCodePoint(target, decompPos);\r\n        decompPos += UTF16Util.codePointLength(ch);\r\n        int chClass = data.getCanonicalClass(ch);\r\n        int composite = data.getPairwiseComposition(starterCh, ch);\r\n        if (composite != NormalizerData.NOT_COMPOSITE && (lastClass < chClass || lastClass == 0)) {\r\n            UTF16Util.setCodePointAt(target, starterPos, composite);\r\n            starterCh = composite;\r\n        } else {\r\n            if (chClass == 0) {\r\n                starterPos = compPos;\r\n                starterCh = ch;\r\n            }\r\n            lastClass = chClass;\r\n            decompPos += UTF16Util.setCodePointAt(target, compPos, ch);\r\n            compPos += UTF16Util.codePointLength(ch);\r\n        }\r\n    }\r\n    target.setLength(compPos);\r\n}"
}, {
	"Path": "java.util.zip.ZipFile.getInflater",
	"Comment": "gets an inflater from the list of available inflaters or allocatesa new one.",
	"Method": "Inflater getInflater(){\r\n    Inflater inf;\r\n    synchronized (inflaterCache) {\r\n        while (null != (inf = inflaterCache.poll())) {\r\n            if (false == inf.ended()) {\r\n                return inf;\r\n            }\r\n        }\r\n    }\r\n    return new Inflater(true);\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testGetThreadFactory",
	"Comment": "getthreadfactory returns factory in constructor if not set",
	"Method": "void testGetThreadFactory(){\r\n    ThreadFactory threadFactory = new SimpleThreadFactory();\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(1, 2, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10), threadFactory, new NoOpREHandler());\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertSame(threadFactory, p.getThreadFactory());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSubMapTest.testDescendingGet",
	"Comment": "get returns the correct element at the given key,or null if not present",
	"Method": "void testDescendingGet(){\r\n    ConcurrentNavigableMap map = dmap5();\r\n    assertEquals(\"A\", (String) map.get(m1));\r\n    ConcurrentNavigableMap empty = dmap0();\r\n    assertNull(empty.get(m1));\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinTask.reportException",
	"Comment": "throws exception, if any, associated with the given status.",
	"Method": "void reportException(int s){\r\n    if (s == CANCELLED)\r\n        throw new CancellationException();\r\n    if (s == EXCEPTIONAL)\r\n        rethrow(getThrowableException());\r\n}"
}, {
	"Path": "java.text.DecimalFormat.getPositiveSuffixFieldPositions",
	"Comment": "returns the fieldpositions of the fields in the suffix used forpositive numbers. this is not used if the user has explicitly seta positive suffix via setpositivesuffix. this islazily created.",
	"Method": "FieldPosition[] getPositiveSuffixFieldPositions(){\r\n    if (positiveSuffixFieldPositions == null) {\r\n        if (posSuffixPattern != null) {\r\n            positiveSuffixFieldPositions = expandAffix(posSuffixPattern);\r\n        } else {\r\n            positiveSuffixFieldPositions = EmptyFieldPositionArray;\r\n        }\r\n    }\r\n    return positiveSuffixFieldPositions;\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedSynchronizer.getWaitQueueLength",
	"Comment": "returns an estimate of the number of threads waiting on thegiven condition associated with this synchronizer. note thatbecause timeouts and interrupts may occur at any time, theestimate serves only as an upper bound on the actual number ofwaiters.this method is designed for use in monitoring systemstate, not for synchronization control.",
	"Method": "int getWaitQueueLength(ConditionObject condition,int getWaitQueueLength){\r\n    if (!owns(condition))\r\n        throw new IllegalArgumentException(\"Not owner\");\r\n    return condition.getWaitQueueLength();\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_adjustInto",
	"Comment": "test to verify the returned hijrah date after adjusting the day of week as saturday",
	"Method": "void test_adjustInto(){\r\n    assertEquals(DayOfWeek.SATURDAY.adjustInto(HijrahDate.of(1434, 6, 28)), HijrahDate.of(1434, 7, 1));\r\n    assertEquals(DayOfWeek.SATURDAY.adjustInto(HijrahDate.of(1432, 4, 13)), HijrahDate.of(1432, 4, 14));\r\n    assertEquals(DayOfWeek.SATURDAY.adjustInto(HijrahDate.of(1433, 11, 29)), HijrahDate.of(1433, 12, 4));\r\n    assertEquals(DayOfWeek.SATURDAY.adjustInto(HijrahDate.of(1434, 5, 10)), HijrahDate.of(1434, 5, 11));\r\n    assertEquals(DayOfWeek.SATURDAY.adjustInto(HijrahDate.of(1434, 9, 11)), HijrahDate.of(1434, 9, 12));\r\n}"
}, {
	"Path": "org.apache.harmony.luni.tests.java.util.RandomTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this method\tis called before a test is executed.",
	"Method": "void setUp(){\r\n    r = new Random();\r\n}"
}, {
	"Path": "javax.crypto.ExemptionMechanism.isCryptoAllowed",
	"Comment": "returns whether the result blob has been generated successfully by thisexemption mechanism.the method also makes sure that the key passed in is the same asthe one this exemption mechanism used in initializing and generatingphases.",
	"Method": "boolean isCryptoAllowed(Key key){\r\n    boolean ret = false;\r\n    if (done && (key != null)) {\r\n        ret = keyStored.equals(key);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "jsr166.ForkJoinPoolTest.testSubmitPrivilegedExceptionAction",
	"Comment": "a submitted privileged exception action runs to completion",
	"Method": "void testSubmitPrivilegedExceptionAction(){\r\n    final Callable callable = Executors.callable(new PrivilegedExceptionAction() {\r\n        public Object run() {\r\n            return TEST_STRING;\r\n        }\r\n    });\r\n    Runnable r = new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            ExecutorService e = new ForkJoinPool(1);\r\n            try (PoolCleaner cleaner = cleaner(e)) {\r\n                Future future = e.submit(callable);\r\n                assertSame(TEST_STRING, future.get());\r\n            }\r\n        }\r\n    };\r\n    runWithPermissions(r, new RuntimePermission(\"modifyThread\"));\r\n}"
}, {
	"Path": "jsr166.ForkJoinPoolTest.testSubmitPrivilegedExceptionAction",
	"Comment": "a submitted privileged exception action runs to completion",
	"Method": "void testSubmitPrivilegedExceptionAction(){\r\n    return TEST_STRING;\r\n}"
}, {
	"Path": "jsr166.ForkJoinPoolTest.testSubmitPrivilegedExceptionAction",
	"Comment": "a submitted privileged exception action runs to completion",
	"Method": "void testSubmitPrivilegedExceptionAction(){\r\n    ExecutorService e = new ForkJoinPool(1);\r\n    try (PoolCleaner cleaner = cleaner(e)) {\r\n        Future future = e.submit(callable);\r\n        assertSame(TEST_STRING, future.get());\r\n    }\r\n}"
}, {
	"Path": "jsr166.JSR166TestCase.permissivePolicy",
	"Comment": "returns a policy containing all the permissions we ever need.",
	"Method": "Policy permissivePolicy(){\r\n    return new AdjustablePolicy(// Permissions needed to change permissions!\r\n    new RuntimePermission(\"modifyThread\"), // Permissions needed to change permissions!\r\n    new RuntimePermission(\"getClassLoader\"), new RuntimePermission(\"setContextClassLoader\"), // Permissions needed by the junit test harness\r\n    new SecurityPermission(\"getPolicy\"), // Permissions needed by the junit test harness\r\n    new SecurityPermission(\"setPolicy\"), new RuntimePermission(\"setSecurityManager\"), new RuntimePermission(\"accessDeclaredMembers\"), new PropertyPermission(\"*\", \"read\"), new java.io.FilePermission(\"<<ALL FILES>>\", \"read\"));\r\n}"
}, {
	"Path": "java.util.concurrent.LinkedTransferQueue.countOfMode",
	"Comment": "traverses and counts unmatched nodes of the given mode.used by methods size and getwaitingconsumercount.",
	"Method": "int countOfMode(boolean data){\r\n    restartFromHead: for (; ; ) {\r\n        int count = 0;\r\n        for (Node p = head; p != null; ) {\r\n            if (!p.isMatched()) {\r\n                if (p.isData != data)\r\n                    return 0;\r\n                if (++count == Integer.MAX_VALUE)\r\n                    break;\r\n            }\r\n            if (UNLINKED == (p = p.next))\r\n                continue restartFromHead;\r\n        }\r\n        return count;\r\n    }\r\n}"
}, {
	"Path": "test.java.time.chrono.TestExampleCode.tomorrowNoon",
	"Comment": "simple function based on a date, returning a chronolocaldatetime of thesame chronology.",
	"Method": "ChronoLocalDateTime<D> tomorrowNoon(D date){\r\n    return (ChronoLocalDateTime<D>) date.plus(1, ChronoUnit.DAYS).atTime(LocalTime.of(12, 0));\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testGetThreadFactory",
	"Comment": "getthreadfactory returns factory in constructor if not set",
	"Method": "void testGetThreadFactory(){\r\n    final ThreadFactory threadFactory = new SimpleThreadFactory();\r\n    final ThreadPoolExecutor p = new CustomTPE(1, 2, LONG_DELAY_MS, MILLISECONDS, new ArrayBlockingQueue<Runnable>(10), threadFactory, new NoOpREHandler());\r\n    try (PoolCleaner cleaner = cleaner(p)) {\r\n        assertSame(threadFactory, p.getThreadFactory());\r\n    }\r\n}"
}, {
	"Path": "java.security.SignatureSpi.engineGetParameters",
	"Comment": "this method is overridden by providers to return theparameters used with this signature engine, or nullif this signature engine does not use any parameters.the returned parameters may be the same that were used to initializethis signature engine, or may contain a combination of default andrandomly generated parameter values used by the underlying signatureimplementation if this signature engine requires algorithm parametersbut was not initialized with any.",
	"Method": "AlgorithmParameters engineGetParameters(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "java.sql.SQLWarning.getNextWarning",
	"Comment": "retrieves the warning chained to this sqlwarning object bysetnextwarning.",
	"Method": "SQLWarning getNextWarning(){\r\n    try {\r\n        return ((SQLWarning) getNextException());\r\n    } catch (ClassCastException ex) {\r\n        throw new Error(\"SQLWarning chain holds value that is not a SQLWarning\");\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.format.TestMessageFormat.TestUnlimitedArgsAndSubformats",
	"Comment": "verify that messageformat accomodates more than 10 arguments andmore than 10 subformats.",
	"Method": "void TestUnlimitedArgsAndSubformats(){\r\n    final String pattern = \"On {0,date} (aka {0,date,short}, aka {0,date,long}) \" + \"at {0,time} (aka {0,time,short}, aka {0,time,long}) \" + \"there were {1,number} werjes \" + \"(a {3,number,percent} increase over {2,number}) \" + \"despite the {4}''s efforts \" + \"and to delight of {5}, {6}, {7}, {8}, {9}, and {10} {11}.\";\r\n    try {\r\n        MessageFormat msg = new MessageFormat(pattern);\r\n        final Object[] ARGS = { new Date(10000000000000L), new Integer(1303), new Integer(1202), new Double(1303.0 / 1202 - 1), \"Glimmung\", \"the printers\", \"Nick\", \"his father\", \"his mother\", \"the spiddles\", \"of course\", \"Horace\" };\r\n        String expected = \"On Nov 20, 2286 (aka 11/20/86, aka November 20, 2286) \" + \"at 9:46:40 AM (aka 9:46 AM, aka 9:46:40 AM PST) \" + \"there were 1,303 werjes \" + \"(a 8% increase over 1,202) \" + \"despite the Glimmung's efforts \" + \"and to delight of the printers, Nick, his father, \" + \"his mother, the spiddles, and of course Horace.\";\r\n        assertEquals(\"format\", expected, msg.format(ARGS));\r\n    } catch (IllegalArgumentException e1) {\r\n        errln(\"FAIL: constructor failed\");\r\n    }\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.setCurrencySymbol",
	"Comment": "sets the currency symbol for the currency of thesedecimalformatsymbols in their locale.",
	"Method": "void setCurrencySymbol(String currency){\r\n    currencySymbol = currency;\r\n}"
}, {
	"Path": "sun.security.util.SignatureFileVerifier.matches",
	"Comment": "returns true if signer contains exactly the same code signers asoldsigner and newsigner, false otherwise. oldsigneris allowed to be null.",
	"Method": "boolean matches(CodeSigner[] signers,CodeSigner[] oldSigners,CodeSigner[] newSigners){\r\n    if ((oldSigners == null) && (signers == newSigners))\r\n        return true;\r\n    boolean match;\r\n    if ((oldSigners != null) && !isSubSet(oldSigners, signers))\r\n        return false;\r\n    if (!isSubSet(newSigners, signers)) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < signers.length; i++) {\r\n        boolean found = ((oldSigners != null) && contains(oldSigners, signers[i])) || contains(newSigners, signers[i]);\r\n        if (!found)\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "java.util.concurrent.ArrayBlockingQueue.clear",
	"Comment": "atomically removes all of the elements from this queue.the queue will be empty after this call returns.",
	"Method": "void clear(){\r\n    final ReentrantLock lock = this.lock;\r\n    lock.lock();\r\n    try {\r\n        int k = count;\r\n        if (k > 0) {\r\n            final Object[] items = this.items;\r\n            final int putIndex = this.putIndex;\r\n            int i = takeIndex;\r\n            do {\r\n                items[i] = null;\r\n                if (++i == items.length)\r\n                    i = 0;\r\n            } while (i != putIndex);\r\n            takeIndex = putIndex;\r\n            count = 0;\r\n            if (itrs != null)\r\n                itrs.queueIsEmpty();\r\n            for (; k > 0 && lock.hasWaiters(notFull); k--) notFull.signal();\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "java.net.MulticastSocket.getInterface",
	"Comment": "retrieve the address of the network interface used formulticast packets.",
	"Method": "InetAddress getInterface(){\r\n    if (isClosed()) {\r\n        throw new SocketException(\"Socket is closed\");\r\n    }\r\n    synchronized (infLock) {\r\n        InetAddress ia = (InetAddress) getImpl().getOption(SocketOptions.IP_MULTICAST_IF);\r\n        if (infAddress == null) {\r\n            return ia;\r\n        }\r\n        if (ia.equals(infAddress)) {\r\n            return ia;\r\n        }\r\n        try {\r\n            NetworkInterface ni = NetworkInterface.getByInetAddress(ia);\r\n            Enumeration addrs = ni.getInetAddresses();\r\n            while (addrs.hasMoreElements()) {\r\n                InetAddress addr = (InetAddress) (addrs.nextElement());\r\n                if (addr.equals(infAddress)) {\r\n                    return infAddress;\r\n                }\r\n            }\r\n            infAddress = null;\r\n            return ia;\r\n        } catch (Exception e) {\r\n            return ia;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.LinkedBlockingQueueTest.populatedQueue",
	"Comment": "returns a new queue of given size containing consecutiveintegers 0 ... n.",
	"Method": "LinkedBlockingQueue<Integer> populatedQueue(int n){\r\n    LinkedBlockingQueue<Integer> q = new LinkedBlockingQueue<Integer>(n);\r\n    assertTrue(q.isEmpty());\r\n    for (int i = 0; i < n; i++) assertTrue(q.offer(new Integer(i)));\r\n    assertFalse(q.isEmpty());\r\n    assertEquals(0, q.remainingCapacity());\r\n    assertEquals(n, q.size());\r\n    return q;\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testReferenceArrayGetAndUpdate",
	"Comment": "atomicreferencearray getandupdate returns previous value and updatesresult of supplied function",
	"Method": "void testReferenceArrayGetAndUpdate(){\r\n    AtomicReferenceArray<Integer> a = new AtomicReferenceArray<Integer>(1);\r\n    a.set(0, one);\r\n    assertEquals(new Integer(1), a.getAndUpdate(0, Atomic8Test::addInteger17));\r\n    assertEquals(new Integer(18), a.getAndUpdate(0, Atomic8Test::addInteger17));\r\n    assertEquals(new Integer(35), a.get(0));\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberRegressionTests.Test4108738",
	"Comment": "decimalformat.parse incorrectly works with a group separator.",
	"Method": "void Test4108738(){\r\n    DecimalFormat df = new DecimalFormat(\"#,##0.###\", new DecimalFormatSymbols(java.util.Locale.US));\r\n    String text = \"1.222,111\";\r\n    Number num = df.parse(text, new ParsePosition(0));\r\n    if (!num.toString().equals(\"1.222\"))\r\n        errln(\"\\\"\" + text + \"\\\"  is parsed as \" + num);\r\n    text = \"1.222x111\";\r\n    num = df.parse(text, new ParsePosition(0));\r\n    if (!num.toString().equals(\"1.222\"))\r\n        errln(\"\\\"\" + text + \"\\\"  is parsed as \" + num);\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.toImpl",
	"Comment": "utility method to convert an arbitrary instance of x509certificateto a x509certimpl. does a cast if possible, otherwise reparsesthe encoding.",
	"Method": "X509CertImpl toImpl(X509Certificate cert){\r\n    if (cert instanceof X509CertImpl) {\r\n        return (X509CertImpl) cert;\r\n    } else {\r\n        return X509Factory.intern(cert);\r\n    }\r\n}"
}, {
	"Path": "sun.security.x509.X509CertImpl.toString",
	"Comment": "returns a printable representation of the certificate.this does notcontain all the information available to distinguish this from anyother certificate.the certificate must be fully constructedbefore this function may be called.",
	"Method": "String toString(){\r\n    if (info == null || algId == null || signature == null)\r\n        return \"\";\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"[\\n\");\r\n    sb.append(info.toString() + \"\\n\");\r\n    sb.append(\"  Algorithm: [\" + algId.toString() + \"]\\n\");\r\n    HexDumpEncoder encoder = new HexDumpEncoder();\r\n    sb.append(\"  Signature:\\n\" + encoder.encodeBuffer(signature));\r\n    sb.append(\"\\n]\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "java.security.SecureRandom.getAlgorithm",
	"Comment": "returns the name of the algorithm implemented by this securerandomobject.",
	"Method": "String getAlgorithm(){\r\n    return (algorithm != null) ? algorithm : \"unknown\";\r\n}"
}, {
	"Path": "java.net.Inet6Address.readObject",
	"Comment": "restore the state of this object from streamincluding the scope information, only if thescoped interface name is valid on this system",
	"Method": "void readObject(ObjectInputStream s){\r\n    scope_ifname = null;\r\n    scope_ifname_set = false;\r\n    if (getClass().getClassLoader() != Class.class.getClassLoader()) {\r\n        throw new SecurityException(\"invalid address type\");\r\n    }\r\n    s.defaultReadObject();\r\n    if (ifname != null && !\"\".equals(ifname)) {\r\n        try {\r\n            scope_ifname = NetworkInterface.getByName(ifname);\r\n            if (scope_ifname == null) {\r\n                scope_id_set = false;\r\n                scope_ifname_set = false;\r\n                scope_id = 0;\r\n            } else {\r\n                try {\r\n                    scope_id = deriveNumericScope(scope_ifname);\r\n                } catch (UnknownHostException e) {\r\n                }\r\n            }\r\n        } catch (SocketException e) {\r\n        }\r\n    }\r\n    ipaddress = ipaddress.clone();\r\n    if (ipaddress.length != INADDRSZ) {\r\n        throw new InvalidObjectException(\"invalid address length: \" + ipaddress.length);\r\n    }\r\n    if (holder().getFamily() != AF_INET6) {\r\n        throw new InvalidObjectException(\"invalid address family type\");\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.OuterReferenceResolver.whenNeedsOuterParam",
	"Comment": "executes the runnable if or when the given type needs an outer param.",
	"Method": "void whenNeedsOuterParam(TypeElement type,Runnable runnable){\r\n    if (captureInfo.needsOuterParam(type)) {\r\n        runnable.run();\r\n    } else if (ElementUtil.isLocal(type)) {\r\n        Scope scope = findScopeForType(type);\r\n        if (scope != null) {\r\n            scope.onOuterParam.add(captureCurrentScope(runnable));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.mockwebserver.MockWebServer.setBodyLimit",
	"Comment": "sets the number of bytes of the post body to keep in memory to the givenlimit.",
	"Method": "void setBodyLimit(int maxBodyLength){\r\n    this.bodyLimit = maxBodyLength;\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testReset_NoBrokenBarrier",
	"Comment": "a reset before threads enter barrier does not throwbrokenbarrierexception",
	"Method": "void testReset_NoBrokenBarrier(){\r\n    final CyclicBarrier c = new CyclicBarrier(3);\r\n    c.reset();\r\n    Thread t1 = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            c.await();\r\n        }\r\n    });\r\n    Thread t2 = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            c.await();\r\n        }\r\n    });\r\n    c.await();\r\n    awaitTermination(t1);\r\n    awaitTermination(t2);\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testReset_NoBrokenBarrier",
	"Comment": "a reset before threads enter barrier does not throwbrokenbarrierexception",
	"Method": "void testReset_NoBrokenBarrier(){\r\n    c.await();\r\n}"
}, {
	"Path": "jsr166.CyclicBarrierTest.testReset_NoBrokenBarrier",
	"Comment": "a reset before threads enter barrier does not throwbrokenbarrierexception",
	"Method": "void testReset_NoBrokenBarrier(){\r\n    c.await();\r\n}"
}, {
	"Path": "java.util.Collections.copy",
	"Comment": "copies all of the elements from one list into another.after theoperation, the index of each copied element in the destination listwill be identical to its index in the source list.the destinationlist must be at least as long as the source list.if it is longer, theremaining elements in the destination list are unaffected. this method runs in linear time.",
	"Method": "void copy(List<? super T> dest,List<? extends T> src){\r\n    int srcSize = src.size();\r\n    if (srcSize > dest.size())\r\n        throw new IndexOutOfBoundsException(\"Source does not fit in dest\");\r\n    if (srcSize < COPY_THRESHOLD || (src instanceof RandomAccess && dest instanceof RandomAccess)) {\r\n        for (int i = 0; i < srcSize; i++) dest.set(i, src.get(i));\r\n    } else {\r\n        ListIterator<? super T> di = dest.listIterator();\r\n        ListIterator<? extends T> si = src.listIterator();\r\n        for (int i = 0; i < srcSize; i++) {\r\n            di.next();\r\n            di.set(si.next());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getSubjectPublicKey",
	"Comment": "returns the subjectpublickey criterion. thex509certificate must contain the specified subjectpublic key. if null, no subjectpublickey check will be done.",
	"Method": "PublicKey getSubjectPublicKey(){\r\n    return subjectPublicKey;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.ConstraintsChecker.check",
	"Comment": "performs the basic constraints and name constraintschecks on the certificate using its internal state.",
	"Method": "void check(Certificate cert,Collection<String> unresCritExts){\r\n    X509Certificate currCert = (X509Certificate) cert;\r\n    i++;\r\n    checkBasicConstraints(currCert);\r\n    verifyNameConstraints(currCert);\r\n    if (unresCritExts != null && !unresCritExts.isEmpty()) {\r\n        unresCritExts.remove(BasicConstraints_Id.toString());\r\n        unresCritExts.remove(NameConstraints_Id.toString());\r\n    }\r\n}"
}, {
	"Path": "java.time.Duration.plusSeconds",
	"Comment": "returns a copy of this duration with the specified duration in seconds added.this instance is immutable and unaffected by this method call.",
	"Method": "Duration plusSeconds(long secondsToAdd){\r\n    return plus(secondsToAdd, 0);\r\n}"
}, {
	"Path": "java.security.Provider.getServices",
	"Comment": "get an unmodifiable set of all services supported bythis provider.",
	"Method": "Set<Service> getServices(){\r\n    checkInitialized();\r\n    if (legacyChanged || servicesChanged) {\r\n        serviceSet = null;\r\n    }\r\n    if (serviceSet == null) {\r\n        ensureLegacyParsed();\r\n        Set<Service> set = new LinkedHashSet();\r\n        if (serviceMap != null) {\r\n            set.addAll(serviceMap.values());\r\n        }\r\n        if (legacyMap != null) {\r\n            set.addAll(legacyMap.values());\r\n        }\r\n        serviceSet = Collections.unmodifiableSet(set);\r\n        servicesChanged = false;\r\n    }\r\n    return serviceSet;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberFormatTest.TestNumberFormatFactory",
	"Comment": "tests the class public static abstract class numberformatfactory",
	"Method": "void TestNumberFormatFactory(){\r\n    class TestFactory extends NumberFormatFactory {\r\n        @Override\r\n        public Set<String> getSupportedLocaleNames() {\r\n            return null;\r\n        }\r\n        @Override\r\n        public NumberFormat createFormat(ULocale loc, int formatType) {\r\n            return null;\r\n        }\r\n    }\r\n    class TestFactory1 extends NumberFormatFactory {\r\n        @Override\r\n        public Set<String> getSupportedLocaleNames() {\r\n            return null;\r\n        }\r\n        @Override\r\n        public NumberFormat createFormat(Locale loc, int formatType) {\r\n            return null;\r\n        }\r\n    }\r\n    TestFactory tf = new TestFactory();\r\n    TestFactory1 tf1 = new TestFactory1();\r\n    if (tf.visible() != true) {\r\n        errln(\"NumberFormatFactory.visible() was suppose to return true.\");\r\n    }\r\n    if (tf.createFormat(new Locale(\"\"), 0) != null) {\r\n        errln(\"NumberFormatFactory.createFormat(Locale loc, int formatType) \" + \"was suppose to return null\");\r\n    }\r\n    if (tf1.createFormat(new ULocale(\"\"), 0) != null) {\r\n        errln(\"NumberFormatFactory.createFormat(ULocale loc, int formatType) \" + \"was suppose to return null\");\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberFormatTest.TestNumberFormatFactory",
	"Comment": "tests the class public static abstract class numberformatfactory",
	"Method": "void TestNumberFormatFactory(){\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberFormatTest.TestNumberFormatFactory",
	"Comment": "tests the class public static abstract class numberformatfactory",
	"Method": "void TestNumberFormatFactory(){\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberFormatTest.TestNumberFormatFactory",
	"Comment": "tests the class public static abstract class numberformatfactory",
	"Method": "void TestNumberFormatFactory(){\r\n    return null;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.NumberFormatTest.TestNumberFormatFactory",
	"Comment": "tests the class public static abstract class numberformatfactory",
	"Method": "void TestNumberFormatFactory(){\r\n    return null;\r\n}"
}, {
	"Path": "java.net.URLConnection.getInputStream",
	"Comment": "returns an input stream that reads from this open connection.a sockettimeoutexception can be thrown when reading from thereturned input stream if the read timeout expires before datais available for read.",
	"Method": "InputStream getInputStream(){\r\n    throw new UnknownServiceException(\"protocol doesn't support input\");\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testReferenceFieldUpdaterGetAndUpdate",
	"Comment": "atomicreferencefieldupdater getandupdate returns previous valueand updates result of supplied function",
	"Method": "void testReferenceFieldUpdaterGetAndUpdate(){\r\n    AtomicReferenceFieldUpdater<Atomic8Test, Integer> a = anIntegerFieldUpdater();\r\n    a.set(this, one);\r\n    assertEquals(new Integer(1), a.getAndUpdate(this, Atomic8Test::addInteger17));\r\n    assertEquals(new Integer(18), a.getAndUpdate(this, Atomic8Test::addInteger17));\r\n    assertEquals(new Integer(35), a.get(this));\r\n    assertEquals(new Integer(35), anIntegerField);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testSignalAll_IMSE",
	"Comment": "calling signalall without holding sync throws illegalmonitorstateexception",
	"Method": "void testSignalAll_IMSE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    try {\r\n        c.signalAll();\r\n        shouldThrow();\r\n    } catch (IllegalMonitorStateException success) {\r\n    }\r\n}"
}, {
	"Path": "java.util.WeakHashMap.containsValue",
	"Comment": "returns true if this map maps one or more keys to thespecified value.",
	"Method": "boolean containsValue(Object value){\r\n    if (value == null)\r\n        return containsNullValue();\r\n    Entry<K, V>[] tab = getTable();\r\n    for (int i = tab.length; i-- > 0; ) for (Entry<K, V> e = tab[i]; e != null; e = e.next) if (value.equals(e.value))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "java.util.JumboEnumSet.retainAll",
	"Comment": "retains only the elements in this set that are contained in thespecified collection.",
	"Method": "boolean retainAll(Collection<?> c){\r\n    if (!(c instanceof JumboEnumSet))\r\n        return super.retainAll(c);\r\n    JumboEnumSet<?> es = (JumboEnumSet<?>) c;\r\n    if (es.elementType != elementType) {\r\n        boolean changed = (size != 0);\r\n        clear();\r\n        return changed;\r\n    }\r\n    for (int i = 0; i < elements.length; i++) elements[i] &= es.elements[i];\r\n    return recalculateSize();\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.parseNames",
	"Comment": "parse an argument of the form passed to setsubjectalternativenames,returning a collection ofgeneralnameinterfaces.throw an illegalargumentexception or a classcastexceptionif the argument is malformed.",
	"Method": "Set<GeneralNameInterface> parseNames(Collection<List<?>> names){\r\n    Set<GeneralNameInterface> genNames = new HashSet<GeneralNameInterface>();\r\n    for (List<?> nameList : names) {\r\n        if (nameList.size() != 2) {\r\n            throw new IOException(\"name list size not 2\");\r\n        }\r\n        Object o = nameList.get(0);\r\n        if (!(o instanceof Integer)) {\r\n            throw new IOException(\"expected an Integer\");\r\n        }\r\n        int nameType = ((Integer) o).intValue();\r\n        o = nameList.get(1);\r\n        genNames.add(makeGeneralNameInterface(nameType, o));\r\n    }\r\n    return genNames;\r\n}"
}, {
	"Path": "android.icu.dev.test.format.IntlTestDecimalFormatAPI.TestAPI",
	"Comment": "this test checks various generic api methods in decimalformat to achieve 100% api coverage.",
	"Method": "void TestAPI(){\r\n    logln(\"DecimalFormat API test---\");\r\n    logln(\"\");\r\n    Locale.setDefault(Locale.ENGLISH);\r\n    logln(\"Testing DecimalFormat constructors\");\r\n    DecimalFormat def = new DecimalFormat();\r\n    final String pattern = new String(\"#,##0.# FF\");\r\n    DecimalFormat pat = null;\r\n    try {\r\n        pat = new DecimalFormat(pattern);\r\n    } catch (IllegalArgumentException e) {\r\n        errln(\"ERROR: Could not create DecimalFormat (pattern)\");\r\n    }\r\n    DecimalFormatSymbols symbols = new DecimalFormatSymbols(Locale.FRENCH);\r\n    DecimalFormat cust1 = new DecimalFormat(pattern, symbols);\r\n    logln(\"Testing clone() and equality operators\");\r\n    Format clone = (Format) def.clone();\r\n    if (!def.equals(clone)) {\r\n        errln(\"ERROR: Clone() failed\");\r\n    }\r\n    logln(\"Testing various format() methods\");\r\n    final double d = -10456.00370000000000;\r\n    final long l = 100000000;\r\n    logln(\"\" + d + \" is the double value\");\r\n    StringBuffer res1 = new StringBuffer();\r\n    StringBuffer res2 = new StringBuffer();\r\n    StringBuffer res3 = new StringBuffer();\r\n    StringBuffer res4 = new StringBuffer();\r\n    FieldPosition pos1 = new FieldPosition(0);\r\n    FieldPosition pos2 = new FieldPosition(0);\r\n    FieldPosition pos3 = new FieldPosition(0);\r\n    FieldPosition pos4 = new FieldPosition(0);\r\n    res1 = def.format(d, res1, pos1);\r\n    logln(\"\" + d + \" formatted to \" + res1);\r\n    res2 = pat.format(l, res2, pos2);\r\n    logln(\"\" + l + \" formatted to \" + res2);\r\n    res3 = cust1.format(d, res3, pos3);\r\n    logln(\"\" + d + \" formatted to \" + res3);\r\n    res4 = cust1.format(l, res4, pos4);\r\n    logln(\"\" + l + \" formatted to \" + res4);\r\n    logln(\"Testing parse()\");\r\n    String text = new String(\"-10,456.0037\");\r\n    ParsePosition pos = new ParsePosition(0);\r\n    String patt = new String(\"#,##0.#\");\r\n    pat.applyPattern(patt);\r\n    double d2 = pat.parse(text, pos).doubleValue();\r\n    if (d2 != d) {\r\n        errln(\"ERROR: Roundtrip failed (via parse(\" + d2 + \" != \" + d + \")) for \" + text);\r\n    }\r\n    logln(text + \" parsed into \" + (long) d2);\r\n    logln(\"Testing getters and setters\");\r\n    final DecimalFormatSymbols syms = pat.getDecimalFormatSymbols();\r\n    def.setDecimalFormatSymbols(syms);\r\n    if (!pat.getDecimalFormatSymbols().equals(def.getDecimalFormatSymbols())) {\r\n        errln(\"ERROR: set DecimalFormatSymbols() failed\");\r\n    }\r\n    String posPrefix;\r\n    pat.setPositivePrefix(\"+\");\r\n    posPrefix = pat.getPositivePrefix();\r\n    logln(\"Positive prefix (should be +): \" + posPrefix);\r\n    if (posPrefix != \"+\") {\r\n        errln(\"ERROR: setPositivePrefix() failed\");\r\n    }\r\n    String negPrefix;\r\n    pat.setNegativePrefix(\"-\");\r\n    negPrefix = pat.getNegativePrefix();\r\n    logln(\"Negative prefix (should be -): \" + negPrefix);\r\n    if (negPrefix != \"-\") {\r\n        errln(\"ERROR: setNegativePrefix() failed\");\r\n    }\r\n    String posSuffix;\r\n    pat.setPositiveSuffix(\"_\");\r\n    posSuffix = pat.getPositiveSuffix();\r\n    logln(\"Positive suffix (should be _): \" + posSuffix);\r\n    if (posSuffix != \"_\") {\r\n        errln(\"ERROR: setPositiveSuffix() failed\");\r\n    }\r\n    String negSuffix;\r\n    pat.setNegativeSuffix(\"~\");\r\n    negSuffix = pat.getNegativeSuffix();\r\n    logln(\"Negative suffix (should be ~): \" + negSuffix);\r\n    if (negSuffix != \"~\") {\r\n        errln(\"ERROR: setNegativeSuffix() failed\");\r\n    }\r\n    long multiplier = 0;\r\n    pat.setMultiplier(8);\r\n    multiplier = pat.getMultiplier();\r\n    logln(\"Multiplier (should be 8): \" + multiplier);\r\n    if (multiplier != 8) {\r\n        errln(\"ERROR: setMultiplier() failed\");\r\n    }\r\n    int groupingSize = 0;\r\n    pat.setGroupingSize(2);\r\n    groupingSize = pat.getGroupingSize();\r\n    logln(\"Grouping size (should be 2): \" + (long) groupingSize);\r\n    if (groupingSize != 2) {\r\n        errln(\"ERROR: setGroupingSize() failed\");\r\n    }\r\n    pat.setDecimalSeparatorAlwaysShown(true);\r\n    boolean tf = pat.isDecimalSeparatorAlwaysShown();\r\n    logln(\"DecimalSeparatorIsAlwaysShown (should be true) is \" + (tf ? \"true\" : \"false\"));\r\n    if (tf != true) {\r\n        errln(\"ERROR: setDecimalSeparatorAlwaysShown() failed\");\r\n    }\r\n    String funkyPat;\r\n    funkyPat = pat.toPattern();\r\n    logln(\"Pattern is \" + funkyPat);\r\n    String locPat;\r\n    locPat = pat.toLocalizedPattern();\r\n    logln(\"Localized pattern is \" + locPat);\r\n    logln(\"Testing applyPattern()\");\r\n    String p1 = new String(\"#,##0.0#;(#,##0.0#)\");\r\n    logln(\"Applying pattern \" + p1);\r\n    pat.applyPattern(p1);\r\n    String s2;\r\n    s2 = pat.toPattern();\r\n    logln(\"Extracted pattern is \" + s2);\r\n    if (!s2.equals(p1)) {\r\n        errln(\"ERROR: toPattern() result did not match pattern applied\");\r\n    }\r\n    String p2 = new String(\"#,##0.0# FF;(#,##0.0# FF)\");\r\n    logln(\"Applying pattern \" + p2);\r\n    pat.applyLocalizedPattern(p2);\r\n    String s3;\r\n    s3 = pat.toLocalizedPattern();\r\n    logln(\"Extracted pattern is \" + s3);\r\n    if (!s3.equals(p2)) {\r\n        errln(\"ERROR: toLocalizedPattern() result did not match pattern applied\");\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.beans.tests.java.beans.IntrospectorTest.testBeanInfo_1",
	"Comment": "test introspection with beaninfo no immediate beaninfo have superbeaninfo",
	"Method": "void testBeanInfo_1(){\r\n    Class<FakeFox011> beanClass = FakeFox011.class;\r\n    BeanInfo info = Introspector.getBeanInfo(beanClass);\r\n    assertNull(info.getAdditionalBeanInfo());\r\n    BeanDescriptor beanDesc = info.getBeanDescriptor();\r\n    assertEquals(\"FakeFox011\", beanDesc.getName());\r\n    assertEquals(0, info.getEventSetDescriptors().length);\r\n    assertEquals(-1, info.getDefaultEventIndex());\r\n    assertEquals(0, info.getDefaultPropertyIndex());\r\n    MethodDescriptor[] methodDesc = info.getMethodDescriptors();\r\n    assertEquals(4, methodDesc.length);\r\n    PropertyDescriptor[] propertyDesc = info.getPropertyDescriptors();\r\n    assertEquals(2, propertyDesc.length);\r\n    for (PropertyDescriptor element : propertyDesc) {\r\n        if (element.getName().equals(\"class\")) {\r\n            assertNull(element.getWriteMethod());\r\n            assertNotNull(element.getReadMethod());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.NameTable.getAnnotationPropertyName",
	"Comment": "returns the name of an annotation property variable, extracted from its accessor element.",
	"Method": "String getAnnotationPropertyName(ExecutableElement element){\r\n    return getMethodName(element);\r\n}"
}, {
	"Path": "java.util.jar.Manifest.clear",
	"Comment": "clears the main attributes as well as the entries in this manifest.",
	"Method": "void clear(){\r\n    attr.clear();\r\n    entries.clear();\r\n}"
}, {
	"Path": "java.util.concurrent.LinkedTransferQueue.put",
	"Comment": "inserts the specified element at the tail of this queue.as the queue is unbounded, this method will never block.",
	"Method": "void put(E e){\r\n    xfer(e, true, ASYNC, 0);\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.cloneAndCheckIssuerNames",
	"Comment": "clone and check an argument of the form passed tosetissuernames. throw an ioexception if the argument is malformed.",
	"Method": "HashSet<Object> cloneAndCheckIssuerNames(Collection<?> names){\r\n    HashSet<Object> namesCopy = new HashSet<Object>();\r\n    Iterator<?> i = names.iterator();\r\n    while (i.hasNext()) {\r\n        Object nameObject = i.next();\r\n        if (!(nameObject instanceof byte[]) && !(nameObject instanceof String))\r\n            throw new IOException(\"name not byte array or String\");\r\n        if (nameObject instanceof byte[])\r\n            namesCopy.add(((byte[]) nameObject).clone());\r\n        else\r\n            namesCopy.add(nameObject);\r\n    }\r\n    return (namesCopy);\r\n}"
}, {
	"Path": "java.text.MessageFormat.applyPattern",
	"Comment": "sets the pattern used by this message format.the method parses the pattern and creates a list of subformatsfor the format elements contained in it.patterns and their interpretation are specified in theclass description.",
	"Method": "void applyPattern(String pattern){\r\n    StringBuilder[] segments = new StringBuilder[4];\r\n    segments[SEG_RAW] = new StringBuilder();\r\n    int part = SEG_RAW;\r\n    int formatNumber = 0;\r\n    boolean inQuote = false;\r\n    int braceStack = 0;\r\n    maxOffset = -1;\r\n    for (int i = 0; i < pattern.length(); ++i) {\r\n        char ch = pattern.charAt(i);\r\n        if (part == SEG_RAW) {\r\n            if (ch == '\\'') {\r\n                if (i + 1 < pattern.length() && pattern.charAt(i + 1) == '\\'') {\r\n                    segments[part].append(ch);\r\n                    ++i;\r\n                } else {\r\n                    inQuote = !inQuote;\r\n                }\r\n            } else if (ch == '{' && !inQuote) {\r\n                part = SEG_INDEX;\r\n                if (segments[SEG_INDEX] == null) {\r\n                    segments[SEG_INDEX] = new StringBuilder();\r\n                }\r\n            } else {\r\n                segments[part].append(ch);\r\n            }\r\n        } else {\r\n            if (inQuote) {\r\n                segments[part].append(ch);\r\n                if (ch == '\\'') {\r\n                    inQuote = false;\r\n                }\r\n            } else {\r\n                switch(ch) {\r\n                    case ',':\r\n                        if (part < SEG_MODIFIER) {\r\n                            if (segments[++part] == null) {\r\n                                segments[part] = new StringBuilder();\r\n                            }\r\n                        } else {\r\n                            segments[part].append(ch);\r\n                        }\r\n                        break;\r\n                    case '{':\r\n                        ++braceStack;\r\n                        segments[part].append(ch);\r\n                        break;\r\n                    case '}':\r\n                        if (braceStack == 0) {\r\n                            part = SEG_RAW;\r\n                            makeFormat(i, formatNumber, segments);\r\n                            formatNumber++;\r\n                            segments[SEG_INDEX] = null;\r\n                            segments[SEG_TYPE] = null;\r\n                            segments[SEG_MODIFIER] = null;\r\n                        } else {\r\n                            --braceStack;\r\n                            segments[part].append(ch);\r\n                        }\r\n                        break;\r\n                    case ' ':\r\n                        if (part != SEG_TYPE || segments[SEG_TYPE].length() > 0) {\r\n                            segments[part].append(ch);\r\n                        }\r\n                        break;\r\n                    case '\\'':\r\n                        inQuote = true;\r\n                    default:\r\n                        segments[part].append(ch);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (braceStack == 0 && part != 0) {\r\n        maxOffset = -1;\r\n        throw new IllegalArgumentException(\"Unmatched braces in the pattern.\");\r\n    }\r\n    this.pattern = segments[0].toString();\r\n}"
}, {
	"Path": "sun.security.util.DerInputStream.mark",
	"Comment": "mark the current position in the buffer, so thata later call to reset will return here.",
	"Method": "void mark(int value){\r\n    buffer.mark(value);\r\n}"
}, {
	"Path": "java.nio.channels.FileLock.overlaps",
	"Comment": "tells whether or not this lock overlaps the given lock range.",
	"Method": "boolean overlaps(long position,long size){\r\n    if (position + size <= this.position)\r\n        return false;\r\n    if (this.position + this.size <= position)\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "java.util.RegularEnumSet.addAll",
	"Comment": "adds all of the elements in the specified collection to this set.",
	"Method": "void addAll(boolean addAll,Collection<? extends E> c){\r\n    if (!(c instanceof RegularEnumSet))\r\n        return super.addAll(c);\r\n    RegularEnumSet es = (RegularEnumSet) c;\r\n    if (es.elementType != elementType) {\r\n        if (es.isEmpty())\r\n            return false;\r\n        else\r\n            throw new ClassCastException(es.elementType + \" != \" + elementType);\r\n    }\r\n    long oldElements = elements;\r\n    elements |= es.elements;\r\n    return elements != oldElements;\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.toCompactValue",
	"Comment": "this is for internal use in converting from a mutablebigintegerobject into a long value given a specified sign.returns inflated if value is not fit into long",
	"Method": "long toCompactValue(int sign){\r\n    if (intLen == 0 || sign == 0)\r\n        return 0L;\r\n    int[] mag = getMagnitudeArray();\r\n    int len = mag.length;\r\n    int d = mag[0];\r\n    if (len > 2 || (d < 0 && len == 2))\r\n        return INFLATED;\r\n    long v = (len == 2) ? ((mag[1] & LONG_MASK) | (d & LONG_MASK) << 32) : d & LONG_MASK;\r\n    return sign == -1 ? -v : v;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.OperatorRewriter.getRetainedWithTarget",
	"Comment": "gets the target object for a call to the retainedwith wrapper.",
	"Method": "Expression getRetainedWithTarget(Assignment node,VariableElement var){\r\n    Expression lhs = node.getLeftHandSide();\r\n    if (!(lhs instanceof FieldAccess)) {\r\n        return new ThisExpression(ElementUtil.getDeclaringClass(var).asType());\r\n    }\r\n    FieldAccess fieldAccess = (FieldAccess) lhs;\r\n    Expression target = fieldAccess.getExpression();\r\n    VariableElement targetVar = GeneratedVariableElement.newLocalVar(\"__rw$\" + rwCount++, target.getTypeMirror(), null);\r\n    TreeUtil.asStatementList(TreeUtil.getOwningStatement(lhs)).add(0, new VariableDeclarationStatement(targetVar, null));\r\n    fieldAccess.setExpression(new SimpleName(targetVar));\r\n    CommaExpression commaExpr = new CommaExpression(new Assignment(new SimpleName(targetVar), target));\r\n    node.replaceWith(commaExpr);\r\n    commaExpr.addExpression(node);\r\n    return new SimpleName(targetVar);\r\n}"
}, {
	"Path": "sun.security.provider.certpath.BasicChecker.getPublicKey",
	"Comment": "return the public key associated with the last certificate processed",
	"Method": "PublicKey getPublicKey(){\r\n    return prevPubKey;\r\n}"
}, {
	"Path": "sun.security.x509.NameConstraintsExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(PERMITTED_SUBTREES);\r\n    elements.addElement(EXCLUDED_SUBTREES);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "java.lang.Enum.compareTo",
	"Comment": "compares this enum with the specified object for order.returns anegative integer, zero, or a positive integer as this object is lessthan, equal to, or greater than the specified object.enum constants are only comparable to other enum constants of thesame enum type.the natural order implemented by thismethod is the order in which the constants are declared.",
	"Method": "int compareTo(E o){\r\n    Enum other = (Enum) o;\r\n    Enum self = this;\r\n    if (self.getClass() != other.getClass() && self.getDeclaringClass() != other.getDeclaringClass())\r\n        throw new ClassCastException();\r\n    return self.ordinal - other.ordinal;\r\n}"
}, {
	"Path": "java.nio.channels.FileLock.toString",
	"Comment": "returns a string describing the range, type, and validity of this lock.",
	"Method": "String toString(){\r\n    return (this.getClass().getName() + \"[\" + position + \":\" + size + \" \" + (shared ? \"shared\" : \"exclusive\") + \" \" + (isValid() ? \"valid\" : \"invalid\") + \"]\");\r\n}"
}, {
	"Path": "sun.security.x509.X509CRLEntryImpl.hasUnsupportedCriticalExtension",
	"Comment": "return true if a critical extension is found that isnot supported, otherwise return false.",
	"Method": "boolean hasUnsupportedCriticalExtension(){\r\n    if (extensions == null)\r\n        return false;\r\n    return extensions.hasUnsupportedCriticalExtension();\r\n}"
}, {
	"Path": "java.net.JarURLConnection.getMainAttributes",
	"Comment": "returns the main attributes for the jar file for thisconnection.",
	"Method": "Attributes getMainAttributes(){\r\n    Manifest man = getManifest();\r\n    return man != null ? man.getMainAttributes() : null;\r\n}"
}, {
	"Path": "java.time.LocalTime.format",
	"Comment": "formats this time using the specified formatter.this time will be passed to the formatter to produce a string.",
	"Method": "String format(DateTimeFormatter formatter){\r\n    Objects.requireNonNull(formatter, \"formatter\");\r\n    return formatter.format(this);\r\n}"
}, {
	"Path": "sun.security.x509.DistributionPointName.encode",
	"Comment": "encodes the distribution point name and writes it to the deroutputstream.",
	"Method": "void encode(DerOutputStream out){\r\n    DerOutputStream theChoice = new DerOutputStream();\r\n    if (fullName != null) {\r\n        fullName.encode(theChoice);\r\n        out.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT, true, TAG_FULL_NAME), theChoice);\r\n    } else {\r\n        relativeName.encode(theChoice);\r\n        out.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT, true, TAG_RELATIVE_NAME), theChoice);\r\n    }\r\n}"
}, {
	"Path": "java.time.Duration.plusMinutes",
	"Comment": "returns a copy of this duration with the specified duration in minutes added.this instance is immutable and unaffected by this method call.",
	"Method": "Duration plusMinutes(long minutesToAdd){\r\n    return plus(Math.multiplyExact(minutesToAdd, SECONDS_PER_MINUTE), 0);\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceValues",
	"Comment": "returns the result of accumulating the given transformationof all values using the given reducer to combine values, ornull if none.",
	"Method": "V reduceValues(long parallelismThreshold,BiFunction<? super V, ? super V, ? extends V> reducer,U reduceValues,long parallelismThreshold,Function<? super V, ? extends U> transformer,BiFunction<? super U, ? super U, ? extends U> reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceValuesTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, reducer).invoke();\r\n}"
}, {
	"Path": "java.util.LinkedList.clear",
	"Comment": "removes all of the elements from this list.the list will be empty after this call returns.",
	"Method": "void clear(){\r\n    for (Node<E> x = first; x != null; ) {\r\n        Node<E> next = x.next;\r\n        x.item = null;\r\n        x.next = null;\r\n        x.prev = null;\r\n        x = next;\r\n    }\r\n    first = last = null;\r\n    size = 0;\r\n    modCount++;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testGetQueue",
	"Comment": "getqueue returns the work queue, which contains queued tasks",
	"Method": "void testGetQueue(){\r\n    final CountDownLatch done = new CountDownLatch(1);\r\n    final BlockingQueue<Runnable> q = new ArrayBlockingQueue<Runnable>(10);\r\n    final ThreadPoolExecutor p = new ThreadPoolExecutor(1, 1, LONG_DELAY_MS, MILLISECONDS, q);\r\n    try (PoolCleaner cleaner = cleaner(p, done)) {\r\n        final CountDownLatch threadStarted = new CountDownLatch(1);\r\n        FutureTask[] tasks = new FutureTask[5];\r\n        for (int i = 0; i < tasks.length; i++) {\r\n            Callable task = new CheckedCallable<Boolean>() {\r\n                public Boolean realCall() throws InterruptedException {\r\n                    threadStarted.countDown();\r\n                    assertSame(q, p.getQueue());\r\n                    await(done);\r\n                    return Boolean.TRUE;\r\n                }\r\n            };\r\n            tasks[i] = new FutureTask(task);\r\n            p.execute(tasks[i]);\r\n        }\r\n        await(threadStarted);\r\n        assertSame(q, p.getQueue());\r\n        assertFalse(q.contains(tasks[0]));\r\n        assertTrue(q.contains(tasks[tasks.length - 1]));\r\n        assertEquals(tasks.length - 1, q.size());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorTest.testGetQueue",
	"Comment": "getqueue returns the work queue, which contains queued tasks",
	"Method": "void testGetQueue(){\r\n    threadStarted.countDown();\r\n    assertSame(q, p.getQueue());\r\n    await(done);\r\n    return Boolean.TRUE;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.GenerationTest.assertEqualSignatures",
	"Comment": "verify that two ast nodes are equal excepting methoddeclaration bodies, by comparing theirsignatures.",
	"Method": "void assertEqualSignatures(TreeNode first,TreeNode second){\r\n    String firstStr = SignatureASTPrinter.toString(first);\r\n    String secondStr = SignatureASTPrinter.toString(second);\r\n    if (!firstStr.equals(secondStr)) {\r\n        fail(\"unmatched:\\n\" + firstStr + \"vs:\\n\" + secondStr);\r\n    }\r\n}"
}, {
	"Path": "java.awt.font.NumericShaper.isContextual",
	"Comment": "returns a boolean indicating whether or notthis shaper shapes contextually.",
	"Method": "boolean isContextual(){\r\n    return (mask & CONTEXTUAL_MASK) != 0;\r\n}"
}, {
	"Path": "javax.crypto.KeyAgreement.doPhase",
	"Comment": "executes the next phase of this key agreement with the givenkey that was received from one of the other parties involved in this keyagreement.",
	"Method": "Key doPhase(Key key,boolean lastPhase){\r\n    chooseFirstProvider();\r\n    return spi.engineDoPhase(key, lastPhase);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvoke(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingCCF f = new LFCCF(8);\r\n            f.quietlyInvoke();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes abnormally",
	"Method": "void testAbnormalQuietlyInvoke(){\r\n    FailingCCF f = new LFCCF(8);\r\n    f.quietlyInvoke();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n}"
}, {
	"Path": "java.util.concurrent.locks.ReentrantReadWriteLock.isWriteLocked",
	"Comment": "queries if the write lock is held by any thread. this method isdesigned for use in monitoring system state, not forsynchronization control.",
	"Method": "boolean isWriteLocked(boolean isWriteLocked){\r\n    return sync.isWriteLocked();\r\n}"
}, {
	"Path": "jsr166.FutureTaskTest.testGetRun",
	"Comment": "run in one thread causes get in another thread to retrieve value",
	"Method": "void testGetRun(){\r\n    final CountDownLatch pleaseRun = new CountDownLatch(2);\r\n    final PublicFutureTask task = new PublicFutureTask(new CheckedCallable<Object>() {\r\n        public Object realCall() {\r\n            return two;\r\n        }\r\n    });\r\n    Thread t1 = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            pleaseRun.countDown();\r\n            assertSame(two, task.get());\r\n        }\r\n    });\r\n    Thread t2 = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            pleaseRun.countDown();\r\n            assertSame(two, task.get(2 * LONG_DELAY_MS, MILLISECONDS));\r\n        }\r\n    });\r\n    await(pleaseRun);\r\n    checkNotDone(task);\r\n    assertTrue(t1.isAlive());\r\n    assertTrue(t2.isAlive());\r\n    task.run();\r\n    checkCompletedNormally(task, two);\r\n    assertEquals(1, task.runCount());\r\n    assertEquals(1, task.setCount());\r\n    assertEquals(0, task.setExceptionCount());\r\n    awaitTermination(t1);\r\n    awaitTermination(t2);\r\n    tryToConfuseDoneTask(task);\r\n    checkCompletedNormally(task, two);\r\n}"
}, {
	"Path": "jsr166.FutureTaskTest.testGetRun",
	"Comment": "run in one thread causes get in another thread to retrieve value",
	"Method": "void testGetRun(){\r\n    return two;\r\n}"
}, {
	"Path": "jsr166.FutureTaskTest.testGetRun",
	"Comment": "run in one thread causes get in another thread to retrieve value",
	"Method": "void testGetRun(){\r\n    pleaseRun.countDown();\r\n    assertSame(two, task.get());\r\n}"
}, {
	"Path": "jsr166.FutureTaskTest.testGetRun",
	"Comment": "run in one thread causes get in another thread to retrieve value",
	"Method": "void testGetRun(){\r\n    pleaseRun.countDown();\r\n    assertSame(two, task.get(2 * LONG_DELAY_MS, MILLISECONDS));\r\n}"
}, {
	"Path": "java.io.PipedReader.ready",
	"Comment": "tell whether this stream is ready to be read.a piped characterstream is ready if the circular buffer is not empty.",
	"Method": "boolean ready(){\r\n    if (!connected) {\r\n        throw new IOException(\"Pipe not connected\");\r\n    } else if (closedByReader) {\r\n        throw new IOException(\"Pipe closed\");\r\n    } else if (writeSide != null && !writeSide.isAlive() && !closedByWriter && (in < 0)) {\r\n        throw new IOException(\"Write end dead\");\r\n    }\r\n    if (in < 0) {\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "java.time.format.DateTimeFormatter.getLocale",
	"Comment": "gets the locale to be used during formatting.this is used to lookup any part of the formatter needing specificlocalization, such as the text or localized pattern.",
	"Method": "Locale getLocale(){\r\n    return locale;\r\n}"
}, {
	"Path": "sun.misc.CharacterDecoder.decodeLinePrefix",
	"Comment": "this method should return, if it knows, the number of bytesthat will be decoded. many formats such as uuencoding providethis information. by default we return the maximum bytes thatcould have been encoded on the line.",
	"Method": "int decodeLinePrefix(PushbackInputStream aStream,OutputStream bStream){\r\n    return (bytesPerLine());\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater",
	"Comment": "creates and returns an updater for objects with the given field.the class argument is needed to check that reflective types andgeneric types match.",
	"Method": "AtomicLongFieldUpdater<U> newUpdater(Class<U> tclass,String fieldName){\r\n    Class<?> caller = null;\r\n    if (AtomicLong.VM_SUPPORTS_LONG_CAS)\r\n        return new CASUpdater<U>(tclass, fieldName, caller);\r\n    else\r\n        return new LockedUpdater<U>(tclass, fieldName, caller);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableSet<Integer> set,int min,int max,boolean ascending,BitSet bs){\r\n    class ReferenceSet {\r\n        int lower(int element) {\r\n            return ascending ? lowerAscending(element) : higherAscending(element);\r\n        }\r\n        int floor(int element) {\r\n            return ascending ? floorAscending(element) : ceilingAscending(element);\r\n        }\r\n        int ceiling(int element) {\r\n            return ascending ? ceilingAscending(element) : floorAscending(element);\r\n        }\r\n        int higher(int element) {\r\n            return ascending ? higherAscending(element) : lowerAscending(element);\r\n        }\r\n        int first() {\r\n            return ascending ? firstAscending() : lastAscending();\r\n        }\r\n        int last() {\r\n            return ascending ? lastAscending() : firstAscending();\r\n        }\r\n        int lowerAscending(int element) {\r\n            return floorAscending(element - 1);\r\n        }\r\n        int floorAscending(int element) {\r\n            if (element < min)\r\n                return -1;\r\n            else if (element > max)\r\n                element = max;\r\n            while (element >= min) {\r\n                if (bs.get(element))\r\n                    return element;\r\n                element--;\r\n            }\r\n            return -1;\r\n        }\r\n        int ceilingAscending(int element) {\r\n            if (element < min)\r\n                element = min;\r\n            else if (element > max)\r\n                return -1;\r\n            int result = bs.nextSetBit(element);\r\n            return result > max ? -1 : result;\r\n        }\r\n        int higherAscending(int element) {\r\n            return ceilingAscending(element + 1);\r\n        }\r\n        private int firstAscending() {\r\n            int result = ceilingAscending(min);\r\n            return result > max ? -1 : result;\r\n        }\r\n        private int lastAscending() {\r\n            int result = floorAscending(max);\r\n            return result < min ? -1 : result;\r\n        }\r\n    }\r\n    ReferenceSet rs = new ReferenceSet();\r\n    int size = 0;\r\n    for (int i = min; i <= max; i++) {\r\n        boolean bsContainsI = bs.get(i);\r\n        assertEquals(bsContainsI, set.contains(i));\r\n        if (bsContainsI)\r\n            size++;\r\n    }\r\n    assertEquals(size, set.size());\r\n    int size2 = 0;\r\n    int previousElement = -1;\r\n    for (int element : set) {\r\n        assertTrue(bs.get(element));\r\n        size2++;\r\n        assertTrue(previousElement < 0 || (ascending ? element - previousElement > 0 : element - previousElement < 0));\r\n        previousElement = element;\r\n    }\r\n    assertEquals(size2, size);\r\n    for (int element = min - 1; element <= max + 1; element++) {\r\n        assertEq(set.lower(element), rs.lower(element));\r\n        assertEq(set.floor(element), rs.floor(element));\r\n        assertEq(set.higher(element), rs.higher(element));\r\n        assertEq(set.ceiling(element), rs.ceiling(element));\r\n    }\r\n    if (set.size() != 0) {\r\n        assertEq(set.first(), rs.first());\r\n        assertEq(set.last(), rs.last());\r\n    } else {\r\n        assertEq(rs.first(), -1);\r\n        assertEq(rs.last(), -1);\r\n        try {\r\n            set.first();\r\n            shouldThrow();\r\n        } catch (NoSuchElementException success) {\r\n        }\r\n        try {\r\n            set.last();\r\n            shouldThrow();\r\n        } catch (NoSuchElementException success) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableSet<Integer> set,int min,int max,boolean ascending,BitSet bs){\r\n    return ascending ? lowerAscending(element) : higherAscending(element);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableSet<Integer> set,int min,int max,boolean ascending,BitSet bs){\r\n    return ascending ? floorAscending(element) : ceilingAscending(element);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableSet<Integer> set,int min,int max,boolean ascending,BitSet bs){\r\n    return ascending ? ceilingAscending(element) : floorAscending(element);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableSet<Integer> set,int min,int max,boolean ascending,BitSet bs){\r\n    return ascending ? higherAscending(element) : lowerAscending(element);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableSet<Integer> set,int min,int max,boolean ascending,BitSet bs){\r\n    return ascending ? firstAscending() : lastAscending();\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableSet<Integer> set,int min,int max,boolean ascending,BitSet bs){\r\n    return ascending ? lastAscending() : firstAscending();\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableSet<Integer> set,int min,int max,boolean ascending,BitSet bs){\r\n    return floorAscending(element - 1);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableSet<Integer> set,int min,int max,boolean ascending,BitSet bs){\r\n    if (element < min)\r\n        return -1;\r\n    else if (element > max)\r\n        element = max;\r\n    while (element >= min) {\r\n        if (bs.get(element))\r\n            return element;\r\n        element--;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableSet<Integer> set,int min,int max,boolean ascending,BitSet bs){\r\n    if (element < min)\r\n        element = min;\r\n    else if (element > max)\r\n        return -1;\r\n    int result = bs.nextSetBit(element);\r\n    return result > max ? -1 : result;\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableSet<Integer> set,int min,int max,boolean ascending,BitSet bs){\r\n    return ceilingAscending(element + 1);\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableSet<Integer> set,int min,int max,boolean ascending,BitSet bs){\r\n    int result = ceilingAscending(min);\r\n    return result > max ? -1 : result;\r\n}"
}, {
	"Path": "jsr166.ConcurrentSkipListSetTest.check",
	"Comment": "min and max are both inclusive.if maxmin, interval is empty.",
	"Method": "void check(NavigableSet<Integer> set,int min,int max,boolean ascending,BitSet bs){\r\n    int result = floorAscending(max);\r\n    return result < min ? -1 : result;\r\n}"
}, {
	"Path": "android.icu.dev.test.lang.UnicodeSetStringSpanTest.matches16CPB",
	"Comment": "that is, each edge of a match must not be in the middle of a surrogate pair.",
	"Method": "boolean matches16CPB(String s,int start,int limit,String t){\r\n    limit -= start;\r\n    int length = t.length();\r\n    return t.equals(s.substring(start, start + length)) && !(0 < start && UTF16.isLeadSurrogate(s.charAt(start - 1)) && UTF16.isTrailSurrogate(s.charAt(start))) && !(length < limit && UTF16.isLeadSurrogate(s.charAt(start + length - 1)) && UTF16.isTrailSurrogate(s.charAt(start + length)));\r\n}"
}, {
	"Path": "java.math.BigInteger.equals",
	"Comment": "compares this biginteger with the specified object for equality.",
	"Method": "boolean equals(Object x){\r\n    if (x == this)\r\n        return true;\r\n    if (!(x instanceof BigInteger))\r\n        return false;\r\n    BigInteger xInt = (BigInteger) x;\r\n    if (xInt.signum != signum)\r\n        return false;\r\n    int[] m = mag;\r\n    int len = m.length;\r\n    int[] xm = xInt.mag;\r\n    if (len != xm.length)\r\n        return false;\r\n    for (int i = 0; i < len; i++) if (xm[i] != m[i])\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "java.util.logging.LogRecord.getThrown",
	"Comment": "get any throwable associated with the log record.if the event involved an exception, this will be theexception object. otherwise null.",
	"Method": "Throwable getThrown(){\r\n    return thrown;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.ast.MethodReferenceTest.testCreationReferenceVoidReturn",
	"Comment": "creation references can be initialized only for side effects, and have a void return.",
	"Method": "void testCreationReferenceVoidReturn(){\r\n    String header = \"interface V { void f(); }\";\r\n    String translation = translateSourceFile(header + \"class Test { V v = Test::new; }\", \"Test\", \"Test.m\");\r\n    assertTranslatedLines(translation, \"- (void)f {\", \"  create_Test_init();\", \"}\");\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.TypeDeclarationGeneratorTest.testEnumConstantClassProperties",
	"Comment": "verify that class properties for enum constants are generated on request.",
	"Method": "void testEnumConstantClassProperties(){\r\n    options.setClassProperties(true);\r\n    options.setNullability(true);\r\n    String source = \"enum Test { ONE, TWO, EOF }\";\r\n    String translation = translateSourceFile(source, \"Test\", \"Test.h\");\r\n    assertTranslation(translation, \"@property (readonly, class, nonnull) Test *ONE NS_SWIFT_NAME(ONE);\");\r\n    assertTranslation(translation, \"@property (readonly, class, nonnull) Test *TWO NS_SWIFT_NAME(TWO);\");\r\n    assertTranslation(translation, \"@property (readonly, class, nonnull) Test *EOF_ NS_SWIFT_NAME(EOF_);\");\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerFieldUpdaterTest.testWeakCompareAndSet",
	"Comment": "repeated weakcompareandset succeeds in changing value when equalto expected",
	"Method": "void testWeakCompareAndSet(){\r\n    AtomicIntegerFieldUpdater<AtomicIntegerFieldUpdaterTest> a;\r\n    a = updaterFor(\"x\");\r\n    x = 1;\r\n    do {\r\n    } while (!a.weakCompareAndSet(this, 1, 2));\r\n    do {\r\n    } while (!a.weakCompareAndSet(this, 2, -4));\r\n    assertEquals(-4, a.get(this));\r\n    do {\r\n    } while (!a.weakCompareAndSet(this, -4, 7));\r\n    assertEquals(7, a.get(this));\r\n}"
}, {
	"Path": "javax.crypto.Cipher.matchAttribute",
	"Comment": "if the attribute listed exists, check that it matches the regularexpression.",
	"Method": "boolean matchAttribute(Provider.Service service,String attr,String value){\r\n    if (value == null) {\r\n        return true;\r\n    }\r\n    final String pattern = service.getAttribute(attr);\r\n    if (pattern == null) {\r\n        return true;\r\n    }\r\n    final String valueUc = value.toUpperCase(Locale.US);\r\n    return valueUc.matches(pattern.toUpperCase(Locale.US));\r\n}"
}, {
	"Path": "sun.security.provider.certpath.Vertex.getIndex",
	"Comment": "get the index for this vertex, where the index is the row of theadjacency list that contains certificates that could follow thiscertificate.",
	"Method": "int getIndex(){\r\n    return index;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.GenerationTest.assertErrorCount",
	"Comment": "asserts that the correct number of errors were reported during thelast translation.",
	"Method": "void assertErrorCount(int expectedCount){\r\n    if (expectedCount != ErrorUtil.errorCount()) {\r\n        failWithMessages(String.format(\"Wrong number of errors. Expected:%d but was:%d\", expectedCount, ErrorUtil.errorCount()), ErrorUtil.getErrorMessages());\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.test.lang.UnicodeSetTest.TestScriptNames",
	"Comment": "make sure each script name and abbreviated name can be usedto construct a unicodeset.",
	"Method": "void TestScriptNames(){\r\n    for (int i = 0; i < UScript.CODE_LIMIT; ++i) {\r\n        for (int j = 0; j < 2; ++j) {\r\n            String pat = \"\";\r\n            try {\r\n                String name = (j == 0) ? UScript.getName(i) : UScript.getShortName(i);\r\n                pat = \"[:\" + name + \":]\";\r\n                UnicodeSet set = new UnicodeSet(pat);\r\n                logln(\"Ok: \" + pat + \" -> \" + set.toPattern(false));\r\n            } catch (IllegalArgumentException e) {\r\n                if (pat.length() == 0) {\r\n                    errln(\"FAIL (in UScript): No name for script \" + i);\r\n                } else {\r\n                    errln(\"FAIL: Couldn't create \" + pat);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.jca.ProviderConfig.getProvider",
	"Comment": "get the provider object. loads the provider if it is not already loaded.",
	"Method": "Provider getProvider(){\r\n    Provider p = provider;\r\n    if (p != null) {\r\n        return p;\r\n    }\r\n    if (shouldLoad() == false) {\r\n        return null;\r\n    }\r\n    if (isLoading) {\r\n        return null;\r\n    }\r\n    try {\r\n        isLoading = true;\r\n        tries++;\r\n        p = doLoadProvider();\r\n    } finally {\r\n        isLoading = false;\r\n    }\r\n    provider = p;\r\n    return p;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.ElementUtil.isInstanceVar",
	"Comment": "returns whether this variable will be an objc instance variable.",
	"Method": "boolean isInstanceVar(VariableElement element){\r\n    return element.getKind() == ElementKind.FIELD && !isGlobalVar(element);\r\n}"
}, {
	"Path": "javax.crypto.KeyGenerator.getInstance",
	"Comment": "returns a keygenerator object that generates secret keysfor the specified algorithm. a new keygenerator object encapsulating thekeygeneratorspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "KeyGenerator getInstance(String algorithm,KeyGenerator getInstance,String algorithm,String provider,KeyGenerator getInstance,String algorithm,Provider provider){\r\n    Instance instance = JceSecurity.getInstance(\"KeyGenerator\", KeyGeneratorSpi.class, algorithm, provider);\r\n    return new KeyGenerator((KeyGeneratorSpi) instance.impl, instance.provider, algorithm);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerMultiplyTest.testCase2",
	"Comment": "multiply two numbers of the same length and different signs.the first is negative.",
	"Method": "void testCase2(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -11, -41, -101, 54, -97, -52, -77, -41, 44, -86, -106, -5, -29, 85, 116, 51, -101, -121, -90 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.multiply(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "android.icu.dev.test.normalizer.BasicTest.TestCompositionExclusion",
	"Comment": "make sure characters in the compositionexclusion.txt list do not getcomposed to.",
	"Method": "void TestCompositionExclusion(){\r\n    String EXCLUDED = \"????????\" + \"????????\" + \"????????\" + \"????????\" + \"????????\" + \"????????\" + \"????????\" + \"????????\" + \"????????\" + \"??I?????\" + \"????????\" + \"????????\" + \"????????\" + \"????????\";\r\n    for (int i = 0; i < EXCLUDED.length(); ++i) {\r\n        String a = String.valueOf(EXCLUDED.charAt(i));\r\n        String b = Normalizer.normalize(a, Normalizer.NFKD);\r\n        String c = Normalizer.normalize(b, Normalizer.NFC);\r\n        if (c.equals(a)) {\r\n            errln(\"FAIL: \" + hex(a) + \" x DECOMP_COMPAT => \" + hex(b) + \" x COMPOSE => \" + hex(c));\r\n        } else if (isVerbose()) {\r\n            logln(\"Ok: \" + hex(a) + \" x DECOMP_COMPAT => \" + hex(b) + \" x COMPOSE => \" + hex(c));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerMultiplyTest.testCase5",
	"Comment": "multiply two numbers of different length and different signs.the first is positive.the first is longer.",
	"Method": "void testCase5(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 1, 2, 3, 4, 5 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { -11, -41, -101, 54, -97, -52, -77, -41, 44, -86, -116, -45, 126, -116, 20, 61, 14, -86, -65, 86, 1, 35, 35, 106 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.multiply(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "sun.security.x509.CRLNumberExtension.toString",
	"Comment": "returns a printable representation of the crlnumberextension.",
	"Method": "String toString(){\r\n    String s = super.toString() + extensionLabel + \": \" + ((crlNumber == null) ? \"\" : Debug.toHexString(crlNumber)) + \"\\n\";\r\n    return (s);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerMultiplyTest.testCase6",
	"Comment": "multiply two numbers of different length and different signs.the first is positive.the second is longer.",
	"Method": "void testCase6(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 1, 2, 3, 4, 5 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { -11, -41, -101, 54, -97, -52, -77, -41, 44, -86, -116, -45, 126, -116, 20, 61, 14, -86, -65, 86, 1, 35, 35, 106 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.multiply(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerMultiplyTest.testCase3",
	"Comment": "multiply two positive numbers of different length.the first is longer.",
	"Method": "void testCase3(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 1, 2, 3, 4, 5 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 10, 40, 100, -55, 96, 51, 76, 40, -45, 85, 115, 44, -127, 115, -21, -62, -15, 85, 64, -87, -2, -36, -36, -106 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.multiply(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerMultiplyTest.testCase4",
	"Comment": "multiply two positive numbers of different length.the second is longer.",
	"Method": "void testCase4(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 1, 2, 3, 4, 5 };\r\n    int aSign = 1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 10, 40, 100, -55, 96, 51, 76, 40, -45, 85, 115, 44, -127, 115, -21, -62, -15, 85, 64, -87, -2, -36, -36, -106 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.multiply(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "java.nio.Buffer.hasRemaining",
	"Comment": "tells whether there are any elements between the current position andthe limit.",
	"Method": "boolean hasRemaining(){\r\n    return position < limit;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerAddTest.testCase13",
	"Comment": "add two numbers of different length and sign.the first is negative.the first is longer.",
	"Method": "void testCase13(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { -2, -3, -4, -4, 5, 14, 23, 39, 48, 57, 66, 5, 14, 23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerAddTest.testCase14",
	"Comment": "add two numbers of different length and sign.the first is negative.the second is longer.",
	"Method": "void testCase14(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    int aSign = -1;\r\n    int bSign = 1;\r\n    byte[] rBytes = { 1, 2, 3, 3, -6, -15, -24, -40, -49, -58, -67, -6, -15, -23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerAddTest.testCase11",
	"Comment": "add two numbers of different length and sign.the first is positive.the first is longer.",
	"Method": "void testCase11(){\r\n    byte[] aBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    byte[] bBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { 1, 2, 3, 3, -6, -15, -24, -40, -49, -58, -67, -6, -15, -23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, result.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerAddTest.testCase12",
	"Comment": "add two numbers of different length and sign.the first is positive.the second is longer.",
	"Method": "void testCase12(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    int aSign = 1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { -2, -3, -4, -4, 5, 14, 23, 39, 48, 57, 66, 5, 14, 23 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.CaptureInfo.getImplicitPostfixParams",
	"Comment": "returns all the implicit params that come after explicit params in a constructor.",
	"Method": "Iterable<VariableElement> getImplicitPostfixParams(TypeElement type){\r\n    if (ElementUtil.isEnum(type)) {\r\n        return implicitEnumParams;\r\n    }\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes normally.iscompletedabnormally and iscancelled return false for normallycompleted tasks",
	"Method": "void testQuietlyInvoke(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() {\r\n            FibTask f = new FibTask(8);\r\n            f.quietlyInvoke();\r\n            checkCompletedNormally(f, 21);\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(mainPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes normally.iscompletedabnormally and iscancelled return false for normallycompleted tasks",
	"Method": "void testQuietlyInvoke(){\r\n    FibTask f = new FibTask(8);\r\n    f.quietlyInvoke();\r\n    checkCompletedNormally(f, 21);\r\n    return NoResult;\r\n}"
}, {
	"Path": "java.text.AttributedString.mapsDiffer",
	"Comment": "returns true if the attributes specified in last and attrs differ.",
	"Method": "boolean mapsDiffer(Map last,Map attrs){\r\n    if (last == null) {\r\n        return (attrs != null && attrs.size() > 0);\r\n    }\r\n    return (!last.equals(attrs));\r\n}"
}, {
	"Path": "java.text.NumberFormat.setParseIntegerOnly",
	"Comment": "sets whether or not numbers should be parsed as integers only.",
	"Method": "void setParseIntegerOnly(boolean value){\r\n    parseIntegerOnly = value;\r\n}"
}, {
	"Path": "android.icu.dev.test.timezone.TimeZoneBoundaryTest.verifyDST",
	"Comment": "given a date, a timezone, and expected values for indaylighttime,usedaylighttime, zone and dst offset, verify that this is the case.",
	"Method": "void verifyDST(String tag,Calendar cal,TimeZone time_zone,boolean expUseDaylightTime,boolean expInDaylightTime,int expRawOffset,int expOffset){\r\n    Date d = cal.getTime();\r\n    logln(\"-- \" + tag + \": \" + d + \" in zone \" + time_zone.getID() + \" (\" + d.getTime() / 3600000.0 + \")\");\r\n    if (time_zone.inDaylightTime(d) == expInDaylightTime)\r\n        logln(\"PASS: inDaylightTime = \" + time_zone.inDaylightTime(d));\r\n    else\r\n        errln(\"FAIL: inDaylightTime = \" + time_zone.inDaylightTime(d));\r\n    if (time_zone.useDaylightTime() == expUseDaylightTime)\r\n        logln(\"PASS: useDaylightTime = \" + time_zone.useDaylightTime());\r\n    else\r\n        errln(\"FAIL: useDaylightTime = \" + time_zone.useDaylightTime());\r\n    if (time_zone.getRawOffset() == expRawOffset)\r\n        logln(\"PASS: getRawOffset() = \" + expRawOffset / (double) ONE_HOUR);\r\n    else\r\n        errln(\"FAIL: getRawOffset() = \" + time_zone.getRawOffset() / (double) ONE_HOUR + \"; expected \" + expRawOffset / (double) ONE_HOUR);\r\n    int offset = time_zone.getOffset(cal.get(Calendar.ERA), cal.get(Calendar.YEAR), cal.get(Calendar.MONTH), cal.get(Calendar.DAY_OF_MONTH), cal.get(Calendar.DAY_OF_WEEK), ((cal.get(Calendar.HOUR_OF_DAY) * 60 + cal.get(Calendar.MINUTE)) * 60 + cal.get(Calendar.SECOND)) * 1000 + cal.get(Calendar.MILLISECOND));\r\n    if (offset == expOffset)\r\n        logln(\"PASS: getOffset() = \" + offset / (double) ONE_HOUR);\r\n    else {\r\n        logln(\"era=\" + cal.get(Calendar.ERA) + \", year=\" + cal.get(Calendar.YEAR) + \", month=\" + cal.get(Calendar.MONTH) + \", dom=\" + cal.get(Calendar.DAY_OF_MONTH) + \", dow=\" + cal.get(Calendar.DAY_OF_WEEK) + \", time-of-day=\" + (((cal.get(Calendar.HOUR_OF_DAY) * 60 + cal.get(Calendar.MINUTE)) * 60 + cal.get(Calendar.SECOND)) * 1000 + cal.get(Calendar.MILLISECOND)) / 3600000.0 + \" hours\");\r\n        errln(\"FAIL: getOffset() = \" + offset / (double) ONE_HOUR + \"; expected \" + expOffset / (double) ONE_HOUR);\r\n    }\r\n}"
}, {
	"Path": "java.util.StringTokenizer.hasMoreElements",
	"Comment": "returns the same value as the hasmoretokensmethod. it exists so that this class can implement theenumeration interface.",
	"Method": "boolean hasMoreElements(){\r\n    return hasMoreTokens();\r\n}"
}, {
	"Path": "java.net.DatagramSocket.disconnect",
	"Comment": "disconnects the socket. if the socket is closed or not connected,then this method has no effect.",
	"Method": "void disconnect(){\r\n    synchronized (this) {\r\n        if (isClosed())\r\n            return;\r\n        if (connectState == ST_CONNECTED) {\r\n            impl.disconnect();\r\n        }\r\n        connectedAddress = null;\r\n        connectedPort = -1;\r\n        connectState = ST_NOT_CONNECTED;\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerAddTest.testCase10",
	"Comment": "add two negative numbers of different length.the second is longer.",
	"Method": "void testCase10(){\r\n    byte[] aBytes = { 10, 20, 30, 40, 50, 60, 70, 10, 20, 30 };\r\n    byte[] bBytes = { 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7 };\r\n    int aSign = -1;\r\n    int bSign = -1;\r\n    byte[] rBytes = { -2, -3, -4, -5, -16, -27, -38, -42, -53, -64, -75, -16, -27, -37 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    BigInteger bNumber = new BigInteger(bSign, bBytes);\r\n    BigInteger result = aNumber.add(bNumber);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = result.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", -1, result.signum());\r\n}"
}, {
	"Path": "sun.nio.ch.Util.offerFirstTemporaryDirectBuffer",
	"Comment": "releases a temporary buffer by returning to the cache or freeing it. ifreturning to the cache then insert it at the start so that it islikely to be returned by a subsequent call to gettemporarydirectbuffer.",
	"Method": "void offerFirstTemporaryDirectBuffer(ByteBuffer buf){\r\n    assert buf != null;\r\n    BufferCache cache = bufferCache.get();\r\n    if (!cache.offerFirst(buf)) {\r\n        free(buf);\r\n    }\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.getCalendarDate",
	"Comment": "returns a calendardate produced from the specified fixed date.",
	"Method": "BaseCalendar.Date getCalendarDate(long fd){\r\n    BaseCalendar cal = (fd >= gregorianCutoverDate) ? gcal : getJulianCalendarSystem();\r\n    BaseCalendar.Date d = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.NO_TIMEZONE);\r\n    cal.getCalendarDateFromFixedDate(d, fd);\r\n    return d;\r\n}"
}, {
	"Path": "java.lang.Throwable.printEnclosedStackTrace",
	"Comment": "print our stack trace as an enclosed exception for the specifiedstack trace.",
	"Method": "void printEnclosedStackTrace(PrintStreamOrWriter s,StackTraceElement[] enclosingTrace,String caption,String prefix,Set<Throwable> dejaVu){\r\n    if (dejaVu.contains(this)) {\r\n        s.println(\"\\t[CIRCULAR REFERENCE:\" + this + \"]\");\r\n    } else {\r\n        dejaVu.add(this);\r\n        StackTraceElement[] trace = getOurStackTrace();\r\n        int m = trace.length - 1;\r\n        int n = enclosingTrace.length - 1;\r\n        while (m >= 0 && n >= 0 && trace[m].equals(enclosingTrace[n])) {\r\n            m--;\r\n            n--;\r\n        }\r\n        int framesInCommon = trace.length - 1 - m;\r\n        s.println(prefix + caption + this);\r\n        for (int i = 0; i <= m; i++) s.println(prefix + \"\\tat \" + trace[i]);\r\n        if (framesInCommon != 0)\r\n            s.println(prefix + \"\\t... \" + framesInCommon + \" more\");\r\n        for (Throwable se : getSuppressed()) se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, prefix + \"\\t\", dejaVu);\r\n        Throwable ourCause = getCause();\r\n        if (ourCause != null)\r\n            ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, prefix, dejaVu);\r\n    }\r\n}"
}, {
	"Path": "jsr166.CopyOnWriteArraySetTest.testToArray_ArrayStoreException",
	"Comment": "toarray throws an arraystoreexception when the given array cannot store the objects inside the set",
	"Method": "void testToArray_ArrayStoreException(){\r\n    CopyOnWriteArraySet c = new CopyOnWriteArraySet();\r\n    c.add(\"zfasdfsdf\");\r\n    c.add(\"asdadasd\");\r\n    try {\r\n        c.toArray(new Long[5]);\r\n        shouldThrow();\r\n    } catch (ArrayStoreException success) {\r\n    }\r\n}"
}, {
	"Path": "java.beans.EventSetDescriptor.checkEventType",
	"Comment": "checks that given listener method has an argument of the valid type.",
	"Method": "void checkEventType(String eventSetName,Method listenerMethod){\r\n    Class<?>[] params = listenerMethod.getParameterTypes();\r\n    String firstParamTypeName = null;\r\n    String eventTypeName = prepareEventTypeName(eventSetName);\r\n    if (params.length > 0) {\r\n        firstParamTypeName = extractShortClassName(params[0].getName());\r\n    }\r\n    if (firstParamTypeName == null || !firstParamTypeName.equals(eventTypeName)) {\r\n        throw new IntrospectionException(\"Listener method \" + listenerMethod.getName() + \" should have parameter of type \" + eventTypeName);\r\n    }\r\n}"
}, {
	"Path": "java.util.EnumMap.isValidKey",
	"Comment": "returns true if key is of the proper type to be a key in thisenum map.",
	"Method": "boolean isValidKey(Object key){\r\n    if (key == null)\r\n        return false;\r\n    Class keyClass = key.getClass();\r\n    return keyClass == keyType || keyClass.getSuperclass() == keyType;\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testNewFixedThreadPool2",
	"Comment": "a new newfixedthreadpool with given threadfactory can execute runnables",
	"Method": "void testNewFixedThreadPool2(){\r\n    final ExecutorService e = Executors.newFixedThreadPool(2, new SimpleThreadFactory());\r\n    try (PoolCleaner cleaner = cleaner(e)) {\r\n        e.execute(new NoOpRunnable());\r\n        e.execute(new NoOpRunnable());\r\n        e.execute(new NoOpRunnable());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ExecutorsTest.testNewFixedThreadPool3",
	"Comment": "a new newfixedthreadpool with null threadfactory throws npe",
	"Method": "void testNewFixedThreadPool3(){\r\n    try {\r\n        ExecutorService e = Executors.newFixedThreadPool(2, null);\r\n        shouldThrow();\r\n    } catch (NullPointerException success) {\r\n    }\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.setMinusSign",
	"Comment": "sets the character used to represent minus sign. if no explicitnegative format is specified, one is formed by prefixingminussign to the positive format.",
	"Method": "void setMinusSign(char minusSign){\r\n    this.minusSign = minusSign;\r\n}"
}, {
	"Path": "java.util.HashSet.iterator",
	"Comment": "returns an iterator over the elements in this set.the elementsare returned in no particular order.",
	"Method": "Iterator<E> iterator(){\r\n    return map.keySet().iterator();\r\n}"
}, {
	"Path": "java.util.regex.Pattern.toString",
	"Comment": "returns the string representation of this pattern. thisis the regular expression from which this pattern wascompiled.",
	"Method": "String toString(){\r\n    return pattern;\r\n}"
}, {
	"Path": "java.util.Date.setMinutes",
	"Comment": "sets the minutes of this date object to the specified value.this date object is modified so that it represents a pointin time within the specified minute of the hour, with the year, month,date, hour, and second the same as before, as interpreted in thelocal time zone.",
	"Method": "void setMinutes(int minutes){\r\n    getCalendarDate().setMinutes(minutes);\r\n}"
}, {
	"Path": "java.time.temporal.ValueRange.of",
	"Comment": "obtains a fully variable value range.this factory obtains a range where both the minimum and maximum value may vary.",
	"Method": "ValueRange of(long min,long max,ValueRange of,long min,long maxSmallest,long maxLargest,ValueRange of,long minSmallest,long minLargest,long maxSmallest,long maxLargest){\r\n    if (minSmallest > minLargest) {\r\n        throw new IllegalArgumentException(\"Smallest minimum value must be less than largest minimum value\");\r\n    }\r\n    if (maxSmallest > maxLargest) {\r\n        throw new IllegalArgumentException(\"Smallest maximum value must be less than largest maximum value\");\r\n    }\r\n    if (minLargest > maxLargest) {\r\n        throw new IllegalArgumentException(\"Minimum value must be less than maximum value\");\r\n    }\r\n    return new ValueRange(minSmallest, minLargest, maxSmallest, maxLargest);\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater.getAndSet",
	"Comment": "atomically sets the field of the given object managed by this updaterto the given value and returns the old value.",
	"Method": "V getAndSet(T obj,V newValue,V getAndSet,T obj,V newValue){\r\n    V prev;\r\n    do {\r\n        prev = get(obj);\r\n    } while (!compareAndSet(obj, prev, newValue));\r\n    return prev;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.AbstractMethodRewriterTest.testAbstractMethodsAdded",
	"Comment": "verifies that a pragma ignored is added when an abstract class does notimplement all interface methods.",
	"Method": "void testAbstractMethodsAdded(){\r\n    String source = \"import java.util.Iterator; public abstract class Test implements Iterator<Test> { \" + \"public boolean hasNext() { return true; } }\";\r\n    String translation = translateSourceFile(source, \"Test\", \"Test.m\");\r\n    assertTranslation(translation, \"#pragma clang diagnostic ignored \\\"-Wprotocol\\\"\");\r\n}"
}, {
	"Path": "java.security.DigestOutputStream.on",
	"Comment": "turns the digest function on or off. the default is on.whenit is on, a call to one of the write methods results in anupdate on the message digest.but when it is off, the messagedigest is not updated.",
	"Method": "void on(boolean on){\r\n    this.on = on;\r\n}"
}, {
	"Path": "java.util.zip.GZIPInputStream.close",
	"Comment": "closes this input stream and releases any system resources associatedwith the stream.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        super.close();\r\n        eos = true;\r\n        closed = true;\r\n    }\r\n}"
}, {
	"Path": "libcore.java.util.zip.OldZipFileTest.setUp",
	"Comment": "sets up the fixture, for example, open a network connection. this methodis called before a test is executed.",
	"Method": "void setUp(){\r\n    File tempFile = File.createTempFile(\"OldZipFileTest\", \"zip\");\r\n    tempFileName = tempFile.getAbsolutePath();\r\n    InputStream is = Support_Resources.getStream(\"hyts_ZipFile.zip\");\r\n    FileOutputStream fos = new FileOutputStream(tempFile);\r\n    byte[] rbuf = getAllBytesFromStream(is);\r\n    fos.write(rbuf, 0, rbuf.length);\r\n    is.close();\r\n    fos.close();\r\n    zfile = new ZipFile(tempFile);\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerArrayTest.testAddAndGet",
	"Comment": "addandget adds given value to current, and returns current value",
	"Method": "void testAddAndGet(){\r\n    AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);\r\n    for (int i = 0; i < SIZE; i++) {\r\n        aa.set(i, 1);\r\n        assertEquals(3, aa.addAndGet(i, 2));\r\n        assertEquals(3, aa.get(i));\r\n        assertEquals(-1, aa.addAndGet(i, -4));\r\n        assertEquals(-1, aa.get(i));\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesPositive7",
	"Comment": "create a positive number from a sign and an array of bytes.the number of bytes is multiple of 4.the most significant byte is negative.",
	"Method": "void testConstructorSignBytesPositive7(){\r\n    byte[] aBytes = { -12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 23, -101 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 0, -12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 23, -101 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "java.util.zip.Inflater.getBytesWritten",
	"Comment": "returns the total number of uncompressed bytes output so far.",
	"Method": "long getBytesWritten(){\r\n    synchronized (zsRef) {\r\n        ensureOpen();\r\n        return bytesWritten;\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadLocalRandomTest.testNextGaussian",
	"Comment": "repeated calls to nextgaussian produce at least two distinct results",
	"Method": "void testNextGaussian(){\r\n    double f = ThreadLocalRandom.current().nextGaussian();\r\n    int i = 0;\r\n    while (i < NCALLS && ThreadLocalRandom.current().nextGaussian() == f) ++i;\r\n    assertTrue(i < NCALLS);\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesPositive1",
	"Comment": "create a positive number from a sign and an array of bytes.the number fits in an array of integers.the most significant byte is positive.",
	"Method": "void testConstructorSignBytesPositive1(){\r\n    byte[] aBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3, -15 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3, -15 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesPositive2",
	"Comment": "create a positive number from a sign and an array of bytes.the number fits in an array of integers.the most significant byte is negative.",
	"Method": "void testConstructorSignBytesPositive2(){\r\n    byte[] aBytes = { -12, 56, 100, -2, -76, 89, 45, 91, 3, -15 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 0, -12, 56, 100, -2, -76, 89, 45, 91, 3, -15 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesPositive3",
	"Comment": "create a positive number from a sign and an array of bytes.the number fits in an integer.",
	"Method": "void testConstructorSignBytesPositive3(){\r\n    byte[] aBytes = { -12, 56, 100 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 0, -12, 56, 100 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "java.io.PrintWriter.format",
	"Comment": "writes a formatted string to this writer using the specified formatstring and arguments.if automatic flushing is enabled, calls to thismethod will flush the output buffer.",
	"Method": "PrintWriter format(String format,Object args,PrintWriter format,Locale l,String format,Object args){\r\n    try {\r\n        synchronized (lock) {\r\n            ensureOpen();\r\n            if ((formatter == null) || (formatter.locale() != l))\r\n                formatter = new Formatter(WeakProxy.forObject(this), l);\r\n            formatter.format(l, format, args);\r\n            if (autoFlush)\r\n                out.flush();\r\n        }\r\n    } catch (InterruptedIOException x) {\r\n        Thread.currentThread().interrupt();\r\n    } catch (IOException x) {\r\n        trouble = true;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesPositive4",
	"Comment": "create a positive number from a sign and an array of bytes.the number of bytes is 4.the most significant byte is positive.",
	"Method": "void testConstructorSignBytesPositive4(){\r\n    byte[] aBytes = { 127, 56, 100, -2 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 127, 56, 100, -2 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "java.util.RegularEnumSet.retainAll",
	"Comment": "retains only the elements in this set that are contained in thespecified collection.",
	"Method": "boolean retainAll(Collection<?> c){\r\n    if (!(c instanceof RegularEnumSet))\r\n        return super.retainAll(c);\r\n    RegularEnumSet<?> es = (RegularEnumSet<?>) c;\r\n    if (es.elementType != elementType) {\r\n        boolean changed = (elements != 0);\r\n        elements = 0;\r\n        return changed;\r\n    }\r\n    long oldElements = elements;\r\n    elements &= es.elements;\r\n    return elements != oldElements;\r\n}"
}, {
	"Path": "sun.security.util.DerInputBuffer.getBitString",
	"Comment": "returns the bit string which takes up the rest of this buffer.",
	"Method": "byte[] getBitString(int len,byte[] getBitString){\r\n    return getBitString(available());\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesPositive5",
	"Comment": "create a positive number from a sign and an array of bytes.the number of bytes is 4.the most significant byte is negative.",
	"Method": "void testConstructorSignBytesPositive5(){\r\n    byte[] aBytes = { -127, 56, 100, -2 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 0, -127, 56, 100, -2 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerArrayTest.testCompareAndSet",
	"Comment": "compareandset succeeds in changing value if equal to expected else fails",
	"Method": "void testCompareAndSet(){\r\n    AtomicIntegerArray aa = new AtomicIntegerArray(SIZE);\r\n    for (int i = 0; i < SIZE; i++) {\r\n        aa.set(i, 1);\r\n        assertTrue(aa.compareAndSet(i, 1, 2));\r\n        assertTrue(aa.compareAndSet(i, 2, -4));\r\n        assertEquals(-4, aa.get(i));\r\n        assertFalse(aa.compareAndSet(i, -5, 7));\r\n        assertEquals(-4, aa.get(i));\r\n        assertTrue(aa.compareAndSet(i, -4, 7));\r\n        assertEquals(7, aa.get(i));\r\n    }\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.math.BigIntegerConstructorsTest.testConstructorSignBytesPositive6",
	"Comment": "create a positive number from a sign and an array of bytes.the number of bytes is multiple of 4.the most significant byte is positive.",
	"Method": "void testConstructorSignBytesPositive6(){\r\n    byte[] aBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 23, -101 };\r\n    int aSign = 1;\r\n    byte[] rBytes = { 12, 56, 100, -2, -76, 89, 45, 91, 3, -15, 23, -101 };\r\n    BigInteger aNumber = new BigInteger(aSign, aBytes);\r\n    byte[] resBytes = new byte[rBytes.length];\r\n    resBytes = aNumber.toByteArray();\r\n    for (int i = 0; i < resBytes.length; i++) {\r\n        assertTrue(resBytes[i] == rBytes[i]);\r\n    }\r\n    assertEquals(\"incorrect sign\", 1, aNumber.signum());\r\n}"
}, {
	"Path": "java.net.URLStreamHandler.parseURL",
	"Comment": "parses the string representation of a url into aurl object.if there is any inherited context, then it has already beencopied into the url argument.the parseurl method of urlstreamhandlerparses the string representation as if it were anhttp specification. most url protocol families have asimilar parsing. a stream protocol handler for a protocol that hasa different syntax must override this routine.",
	"Method": "void parseURL(URL u,String spec,int start,int limit){\r\n    String protocol = u.getProtocol();\r\n    String authority = u.getAuthority();\r\n    String userInfo = u.getUserInfo();\r\n    String host = u.getHost();\r\n    int port = u.getPort();\r\n    String path = u.getPath();\r\n    String query = u.getQuery();\r\n    String ref = u.getRef();\r\n    boolean isRelPath = false;\r\n    boolean queryOnly = false;\r\n    boolean querySet = false;\r\n    if (start < limit) {\r\n        int queryStart = spec.indexOf('?');\r\n        queryOnly = queryStart == start;\r\n        if ((queryStart != -1) && (queryStart < limit)) {\r\n            query = spec.substring(queryStart + 1, limit);\r\n            if (limit > queryStart)\r\n                limit = queryStart;\r\n            spec = spec.substring(0, queryStart);\r\n            querySet = true;\r\n        }\r\n    }\r\n    int i = 0;\r\n    boolean isUNCName = false;\r\n    if (!isUNCName && (start <= limit - 2) && (spec.charAt(start) == '/') && (spec.charAt(start + 1) == '/')) {\r\n        start += 2;\r\n        i = spec.indexOf('/', start);\r\n        if (i < 0) {\r\n            i = spec.indexOf('?', start);\r\n            if (i < 0)\r\n                i = limit;\r\n        }\r\n        host = authority = spec.substring(start, i);\r\n        int ind = authority.indexOf('@');\r\n        if (ind != -1) {\r\n            userInfo = authority.substring(0, ind);\r\n            host = authority.substring(ind + 1);\r\n        } else {\r\n            userInfo = null;\r\n        }\r\n        if (host != null) {\r\n            if (host.length() > 0 && (host.charAt(0) == '[')) {\r\n                if ((ind = host.indexOf(']')) > 2) {\r\n                    String nhost = host;\r\n                    host = nhost.substring(0, ind + 1);\r\n                    if (!IPAddressUtil.isIPv6LiteralAddress(host.substring(1, ind))) {\r\n                        throw new IllegalArgumentException(\"Invalid host: \" + host);\r\n                    }\r\n                    port = -1;\r\n                    if (nhost.length() > ind + 1) {\r\n                        if (nhost.charAt(ind + 1) == ':') {\r\n                            ++ind;\r\n                            if (nhost.length() > (ind + 1)) {\r\n                                port = Integer.parseInt(nhost.substring(ind + 1));\r\n                            }\r\n                        } else {\r\n                            throw new IllegalArgumentException(\"Invalid authority field: \" + authority);\r\n                        }\r\n                    }\r\n                } else {\r\n                    throw new IllegalArgumentException(\"Invalid authority field: \" + authority);\r\n                }\r\n            } else {\r\n                ind = host.indexOf(':');\r\n                port = -1;\r\n                if (ind >= 0) {\r\n                    if (host.length() > (ind + 1)) {\r\n                        char firstPortChar = host.charAt(ind + 1);\r\n                        if (firstPortChar >= '0' && firstPortChar <= '9') {\r\n                            port = Integer.parseInt(host.substring(ind + 1));\r\n                        } else {\r\n                            throw new IllegalArgumentException(\"invalid port: \" + host.substring(ind + 1));\r\n                        }\r\n                    }\r\n                    host = host.substring(0, ind);\r\n                }\r\n            }\r\n        } else {\r\n            host = \"\";\r\n        }\r\n        if (port < -1)\r\n            throw new IllegalArgumentException(\"Invalid port number :\" + port);\r\n        start = i;\r\n        path = null;\r\n        if (!querySet) {\r\n            query = null;\r\n        }\r\n    }\r\n    if (host == null) {\r\n        host = \"\";\r\n    }\r\n    if (start < limit) {\r\n        if (spec.charAt(start) == '/') {\r\n            path = spec.substring(start, limit);\r\n        } else if (path != null && path.length() > 0) {\r\n            isRelPath = true;\r\n            int ind = path.lastIndexOf('/');\r\n            String seperator = \"\";\r\n            if (ind == -1 && authority != null)\r\n                seperator = \"/\";\r\n            path = path.substring(0, ind + 1) + seperator + spec.substring(start, limit);\r\n        } else {\r\n            String seperator = (authority != null) ? \"/\" : \"\";\r\n            path = seperator + spec.substring(start, limit);\r\n        }\r\n    }\r\n    if (path == null)\r\n        path = \"\";\r\n    if (true) {\r\n        while ((i = path.indexOf(\"/./\")) >= 0) {\r\n            path = path.substring(0, i) + path.substring(i + 2);\r\n        }\r\n        i = 0;\r\n        while ((i = path.indexOf(\"/../\", i)) >= 0) {\r\n            if (i == 0) {\r\n                path = path.substring(i + 3);\r\n                i = 0;\r\n            } else if (i > 0 && (limit = path.lastIndexOf('/', i - 1)) >= 0 && (path.indexOf(\"/../\", limit) != 0)) {\r\n                path = path.substring(0, limit) + path.substring(i + 3);\r\n                i = 0;\r\n            } else {\r\n                i = i + 3;\r\n            }\r\n        }\r\n        while (path.endsWith(\"/..\")) {\r\n            i = path.indexOf(\"/..\");\r\n            if ((limit = path.lastIndexOf('/', i - 1)) >= 0) {\r\n                path = path.substring(0, limit + 1);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        if (path.startsWith(\"./\") && path.length() > 2)\r\n            path = path.substring(2);\r\n        if (path.endsWith(\"/.\"))\r\n            path = path.substring(0, path.length() - 1);\r\n        if (path.endsWith(\"?\"))\r\n            path = path.substring(0, path.length() - 1);\r\n    }\r\n    setURL(u, protocol, host, port, authority, userInfo, path, query, ref);\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.setExtendedKeyUsage",
	"Comment": "sets the extendedkeyusage criterion. the x509certificatemust allow the specified key purposes in its extended key usageextension. if keypurposeset is empty or null,no extendedkeyusage check will be done. note that anx509certificate that has no extendedkeyusage extensionimplicitly allows all key purposes.note that the set is cloned to protect againstsubsequent modifications.",
	"Method": "void setExtendedKeyUsage(Set<String> keyPurposeSet){\r\n    if ((keyPurposeSet == null) || keyPurposeSet.isEmpty()) {\r\n        this.keyPurposeSet = null;\r\n        keyPurposeOIDSet = null;\r\n    } else {\r\n        this.keyPurposeSet = Collections.unmodifiableSet(new HashSet<String>(keyPurposeSet));\r\n        keyPurposeOIDSet = new HashSet<ObjectIdentifier>();\r\n        for (String s : this.keyPurposeSet) {\r\n            keyPurposeOIDSet.add(new ObjectIdentifier(s));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.beans.StandardBeanInfo.introspectProperties",
	"Comment": "introspects the supplied class and returns a list of the properties ofthe class",
	"Method": "PropertyDescriptor[] introspectProperties(Class<?> stopClass){\r\n    MethodDescriptor[] methodDescriptors = introspectMethods();\r\n    if (methodDescriptors == null) {\r\n        return null;\r\n    }\r\n    ArrayList<MethodDescriptor> methodList = new ArrayList<MethodDescriptor>();\r\n    for (int index = 0; index < methodDescriptors.length; index++) {\r\n        int modifiers = methodDescriptors[index].getMethod().getModifiers();\r\n        if (!Modifier.isStatic(modifiers)) {\r\n            methodList.add(methodDescriptors[index]);\r\n        }\r\n    }\r\n    int methodCount = methodList.size();\r\n    MethodDescriptor[] theMethods = null;\r\n    if (methodCount > 0) {\r\n        theMethods = new MethodDescriptor[methodCount];\r\n        theMethods = methodList.toArray(theMethods);\r\n    }\r\n    if (theMethods == null) {\r\n        return null;\r\n    }\r\n    HashMap<String, HashMap> propertyTable = new HashMap<String, HashMap>(theMethods.length);\r\n    for (int i = 0; i < theMethods.length; i++) {\r\n        introspectGet(theMethods[i].getMethod(), propertyTable);\r\n        introspectSet(theMethods[i].getMethod(), propertyTable);\r\n    }\r\n    fixGetSet(propertyTable);\r\n    MethodDescriptor[] allMethods = introspectMethods(true);\r\n    if (stopClass != null) {\r\n        MethodDescriptor[] excludeMethods = introspectMethods(true, stopClass);\r\n        if (excludeMethods != null) {\r\n            ArrayList<MethodDescriptor> tempMethods = new ArrayList<MethodDescriptor>();\r\n            for (MethodDescriptor method : allMethods) {\r\n                if (!isInSuper(method, excludeMethods)) {\r\n                    tempMethods.add(method);\r\n                }\r\n            }\r\n            allMethods = tempMethods.toArray(new MethodDescriptor[0]);\r\n        }\r\n    }\r\n    for (int i = 0; i < allMethods.length; i++) {\r\n        introspectPropertyListener(allMethods[i].getMethod());\r\n    }\r\n    ArrayList<PropertyDescriptor> propertyList = new ArrayList<PropertyDescriptor>();\r\n    for (Map.Entry<String, HashMap> entry : propertyTable.entrySet()) {\r\n        String propertyName = entry.getKey();\r\n        HashMap table = entry.getValue();\r\n        if (table == null) {\r\n            continue;\r\n        }\r\n        String normalTag = (String) table.get(STR_NORMAL);\r\n        String indexedTag = (String) table.get(STR_INDEXED);\r\n        if ((normalTag == null) && (indexedTag == null)) {\r\n            continue;\r\n        }\r\n        Method get = (Method) table.get(STR_NORMAL + PREFIX_GET);\r\n        Method set = (Method) table.get(STR_NORMAL + PREFIX_SET);\r\n        Method indexedGet = (Method) table.get(STR_INDEXED + PREFIX_GET);\r\n        Method indexedSet = (Method) table.get(STR_INDEXED + PREFIX_SET);\r\n        PropertyDescriptor propertyDesc = null;\r\n        if (indexedTag == null) {\r\n            propertyDesc = new PropertyDescriptor(propertyName, get, set);\r\n        } else {\r\n            try {\r\n                propertyDesc = new IndexedPropertyDescriptor(propertyName, get, set, indexedGet, indexedSet);\r\n            } catch (IntrospectionException e) {\r\n                propertyDesc = new IndexedPropertyDescriptor(propertyName, null, null, indexedGet, indexedSet);\r\n            }\r\n        }\r\n        if (canAddPropertyChangeListener && canRemovePropertyChangeListener) {\r\n            propertyDesc.setBound(true);\r\n        } else {\r\n            propertyDesc.setBound(false);\r\n        }\r\n        if (table.get(STR_IS_CONSTRAINED) == Boolean.TRUE) {\r\n            propertyDesc.setConstrained(true);\r\n        }\r\n        propertyList.add(propertyDesc);\r\n    }\r\n    PropertyDescriptor[] theProperties = new PropertyDescriptor[propertyList.size()];\r\n    propertyList.toArray(theProperties);\r\n    return theProperties;\r\n}"
}, {
	"Path": "java.net.Inet4Address.isMCOrgLocal",
	"Comment": "utility routine to check if the multicast address has organization scope.",
	"Method": "boolean isMCOrgLocal(){\r\n    int address = holder().getAddress();\r\n    return (((address >>> 24) & 0xFF) == 239) && (((address >>> 16) & 0xFF) >= 192) && (((address >>> 16) & 0xFF) <= 195);\r\n}"
}, {
	"Path": "java.util.concurrent.LinkedBlockingQueue.clear",
	"Comment": "atomically removes all of the elements from this queue.the queue will be empty after this call returns.",
	"Method": "void clear(){\r\n    fullyLock();\r\n    try {\r\n        for (Node<E> p, h = head; (p = h.next) != null; h = p) {\r\n            h.next = sentinel();\r\n            p.item = null;\r\n        }\r\n        head = last;\r\n        if (count.getAndSet(0) == capacity)\r\n            notFull.signal();\r\n    } finally {\r\n        fullyUnlock();\r\n    }\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.euclidModInverse",
	"Comment": "uses the extended euclidean algorithm to compute the modinverse of basemod a modulus that is a power of 2. the modulus is 2^k.",
	"Method": "MutableBigInteger euclidModInverse(int k){\r\n    MutableBigInteger b = new MutableBigInteger(1);\r\n    b.leftShift(k);\r\n    MutableBigInteger mod = new MutableBigInteger(b);\r\n    MutableBigInteger a = new MutableBigInteger(this);\r\n    MutableBigInteger q = new MutableBigInteger();\r\n    MutableBigInteger r = b.divide(a, q);\r\n    MutableBigInteger swapper = b;\r\n    b = r;\r\n    r = swapper;\r\n    MutableBigInteger t1 = new MutableBigInteger(q);\r\n    MutableBigInteger t0 = new MutableBigInteger(1);\r\n    MutableBigInteger temp = new MutableBigInteger();\r\n    while (!b.isOne()) {\r\n        r = a.divide(b, q);\r\n        if (r.intLen == 0)\r\n            throw new ArithmeticException(\"BigInteger not invertible.\");\r\n        swapper = r;\r\n        a = swapper;\r\n        if (q.intLen == 1)\r\n            t1.mul(q.value[q.offset], temp);\r\n        else\r\n            q.multiply(t1, temp);\r\n        swapper = q;\r\n        q = temp;\r\n        temp = swapper;\r\n        t0.add(q);\r\n        if (a.isOne())\r\n            return t0;\r\n        r = b.divide(a, q);\r\n        if (r.intLen == 0)\r\n            throw new ArithmeticException(\"BigInteger not invertible.\");\r\n        swapper = b;\r\n        b = r;\r\n        if (q.intLen == 1)\r\n            t0.mul(q.value[q.offset], temp);\r\n        else\r\n            q.multiply(t0, temp);\r\n        swapper = q;\r\n        q = temp;\r\n        temp = swapper;\r\n        t1.add(q);\r\n    }\r\n    mod.subtract(t1);\r\n    return mod;\r\n}"
}, {
	"Path": "sun.security.jca.Providers.getSunProvider",
	"Comment": "sun.security.util.manifestentryverifier and java.security.securerandom.",
	"Method": "Provider getSunProvider(){\r\n    try {\r\n        Class clazz = Class.forName(jarVerificationProviders[0]);\r\n        return (Provider) clazz.newInstance();\r\n    } catch (Exception e) {\r\n        try {\r\n            Class clazz = Class.forName(BACKUP_PROVIDER_CLASSNAME);\r\n            return (Provider) clazz.newInstance();\r\n        } catch (Exception ee) {\r\n            throw new RuntimeException(\"Sun provider not found\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.security.provider.certpath.PolicyChecker.check",
	"Comment": "performs the policy processing checks on the certificate using itsinternal state.",
	"Method": "void check(Certificate cert,Collection<String> unresCritExts){\r\n    checkPolicy((X509Certificate) cert);\r\n    if (unresCritExts != null && !unresCritExts.isEmpty()) {\r\n        unresCritExts.remove(CertificatePolicies_Id.toString());\r\n        unresCritExts.remove(PolicyMappings_Id.toString());\r\n        unresCritExts.remove(PolicyConstraints_Id.toString());\r\n        unresCritExts.remove(InhibitAnyPolicy_Id.toString());\r\n    }\r\n}"
}, {
	"Path": "java.util.Locale.isAsciiAlphaNum",
	"Comment": "checks whether a given string is an ascii alphanumeric string.",
	"Method": "boolean isAsciiAlphaNum(String string){\r\n    for (int i = 0; i < string.length(); i++) {\r\n        final char character = string.charAt(i);\r\n        if (!(character >= 'a' && character <= 'z' || character >= 'A' && character <= 'Z' || character >= '0' && character <= '9')) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.harmony.tests.java.lang.reflect.BoundedGenericMethodsTests.testBoundedGenericMethods",
	"Comment": "tests that there are is one type parameter on the class itself.",
	"Method": "void testBoundedGenericMethods(){\r\n    assertLenghtOne(clazz.getTypeParameters());\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getPolicy",
	"Comment": "returns the policy criterion. the x509certificate mustinclude at least one of the specified policies in its certificate policiesextension. if the set returned is empty, then thex509certificate must include at least some specified policyin its certificate policies extension. if the set returned isnull, no policy check will be performed.",
	"Method": "Set<String> getPolicy(){\r\n    return policySet;\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.data_invalid_leapyears",
	"Comment": "the values are dependent on the currently configured ummalqura calendar data",
	"Method": "Object[][] data_invalid_leapyears(){\r\n    return new Object[][] { { 1299 }, { 1601 }, { Integer.MAX_VALUE }, { Integer.MIN_VALUE } };\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_chronoFields",
	"Comment": "test to verify the values of various chrono fields for a given hijrah date instance",
	"Method": "void test_chronoFields(){\r\n    ChronoLocalDate hdate = HijrahChronology.INSTANCE.date(1434, 6, 28);\r\n    assertEquals(hdate.get(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH), 3);\r\n    assertEquals(hdate.get(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 7);\r\n    assertEquals(hdate.get(ChronoField.ALIGNED_WEEK_OF_MONTH), 4);\r\n    assertEquals(hdate.get(ChronoField.ALIGNED_WEEK_OF_YEAR), 25);\r\n    assertEquals(hdate.get(ChronoField.ERA), 1);\r\n    assertEquals(hdate.get(ChronoField.YEAR_OF_ERA), 1434);\r\n    assertEquals(hdate.get(ChronoField.MONTH_OF_YEAR), 6);\r\n    assertEquals(hdate.get(ChronoField.DAY_OF_MONTH), 28);\r\n    assertEquals(hdate.get(ChronoField.DAY_OF_WEEK), 3);\r\n    assertEquals(hdate.get(ChronoField.DAY_OF_YEAR), 175);\r\n}"
}, {
	"Path": "com.google.j2objc.net.DataEnqueuedInputStream.read",
	"Comment": "reads from the current chunk or polls a next chunk from the queue. this is synchronized toallow reads to be used on different thread while still guaranteeing their sequentiality.",
	"Method": "int read(int read,byte[] buf,int read,byte[] buf,int offset,int length){\r\n    if (buf == null) {\r\n        throw new IllegalArgumentException(\"buf must not be null\");\r\n    }\r\n    if (!(offset >= 0 && length > 0 && offset < buf.length && length <= (buf.length - offset))) {\r\n        throw new IllegalArgumentException(\"invalid offset and lengeth\");\r\n    }\r\n    if (closed) {\r\n        if (exception != null) {\r\n            throw exception;\r\n        }\r\n        return -1;\r\n    }\r\n    if (currentChunk == null) {\r\n        if (currentChunkReadPos != -1) {\r\n            throw new IllegalStateException(\"currentChunk is null but currentChunkReadPos is not -1\");\r\n        }\r\n        byte[] next = null;\r\n        try {\r\n            if (timeoutMillis >= 0) {\r\n                next = queue.poll(timeoutMillis, TimeUnit.MILLISECONDS);\r\n            } else {\r\n                next = queue.take();\r\n            }\r\n        } catch (InterruptedException e) {\r\n            throw new AssertionError(e);\r\n        }\r\n        if (next == null) {\r\n            closed = true;\r\n            SocketTimeoutException timeoutException = new SocketTimeoutException();\r\n            if (exception == null) {\r\n                exception = timeoutException;\r\n            }\r\n            throw timeoutException;\r\n        }\r\n        if (next == CLOSED) {\r\n            closed = true;\r\n            if (exception != null) {\r\n                throw exception;\r\n            }\r\n            return -1;\r\n        }\r\n        currentChunk = next;\r\n        currentChunkReadPos = 0;\r\n    }\r\n    int available = currentChunk.length - currentChunkReadPos;\r\n    if (length < available) {\r\n        System.arraycopy(currentChunk, currentChunkReadPos, buf, offset, length);\r\n        currentChunkReadPos += length;\r\n        return length;\r\n    } else {\r\n        System.arraycopy(currentChunk, currentChunkReadPos, buf, offset, available);\r\n        currentChunk = null;\r\n        currentChunkReadPos = -1;\r\n        return available;\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.cloneAndCheckNames",
	"Comment": "clone and check an argument of the form passed tosetsubjectalternativenames and setpathtonames.throw an ioexception if the argument is malformed.",
	"Method": "Set<List<?>> cloneAndCheckNames(Collection<List<?>> names){\r\n    Set<List<?>> namesCopy = new HashSet<List<?>>();\r\n    Iterator<List<?>> i = names.iterator();\r\n    while (i.hasNext()) {\r\n        Object o = i.next();\r\n        if (!(o instanceof List)) {\r\n            throw new IOException(\"expected a List\");\r\n        }\r\n        namesCopy.add(new ArrayList<Object>((List<?>) o));\r\n    }\r\n    i = namesCopy.iterator();\r\n    while (i.hasNext()) {\r\n        List<Object> nameList = (List<Object>) i.next();\r\n        if (nameList.size() != 2) {\r\n            throw new IOException(\"name list size not 2\");\r\n        }\r\n        Object o = nameList.get(0);\r\n        if (!(o instanceof Integer)) {\r\n            throw new IOException(\"expected an Integer\");\r\n        }\r\n        int nameType = ((Integer) o).intValue();\r\n        if ((nameType < 0) || (nameType > 8)) {\r\n            throw new IOException(\"name type not 0-8\");\r\n        }\r\n        Object nameObject = nameList.get(1);\r\n        if (!(nameObject instanceof byte[]) && !(nameObject instanceof String)) {\r\n            if (debug != null) {\r\n                debug.println(\"X509CertSelector.cloneAndCheckNames() \" + \"name not byte array\");\r\n            }\r\n            throw new IOException(\"name not byte array or String\");\r\n        }\r\n        if (nameObject instanceof byte[]) {\r\n            nameList.set(1, ((byte[]) nameObject).clone());\r\n        }\r\n    }\r\n    return namesCopy;\r\n}"
}, {
	"Path": "javax.crypto.CipherInputStream.markSupported",
	"Comment": "tests if this input stream supports the markand reset methods, which it does not.",
	"Method": "boolean markSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testIntAccumulateAndGet",
	"Comment": "atomicinteger accumulateandget updates with supplied function andreturns result.",
	"Method": "void testIntAccumulateAndGet(){\r\n    AtomicInteger a = new AtomicInteger(1);\r\n    assertEquals(7, a.accumulateAndGet(6, Integer::sum));\r\n    assertEquals(10, a.accumulateAndGet(3, Integer::sum));\r\n    assertEquals(10, a.get());\r\n}"
}, {
	"Path": "java.io.PipedReader.close",
	"Comment": "closes this piped stream and releases any system resourcesassociated with the stream.",
	"Method": "void close(){\r\n    in = -1;\r\n    closedByReader = true;\r\n}"
}, {
	"Path": "sun.security.x509.CRLExtensions.hasUnsupportedCriticalExtension",
	"Comment": "return true if a critical extension is found that isnot supported, otherwise return false.",
	"Method": "boolean hasUnsupportedCriticalExtension(){\r\n    return unsupportedCritExt;\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testAcquireInterruptibly",
	"Comment": "acquireinterruptibly succeeds when released, else is interruptible",
	"Method": "void testAcquireInterruptibly(){\r\n    final Mutex sync = new Mutex();\r\n    final BooleanLatch threadStarted = new BooleanLatch();\r\n    sync.acquireInterruptibly();\r\n    Thread t = newStartedThread(new CheckedInterruptedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            assertTrue(threadStarted.releaseShared(0));\r\n            sync.acquireInterruptibly();\r\n        }\r\n    });\r\n    threadStarted.acquireShared(0);\r\n    waitForQueuedThread(sync, t);\r\n    t.interrupt();\r\n    awaitTermination(t);\r\n    assertTrue(sync.isHeldExclusively());\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testAcquireInterruptibly",
	"Comment": "acquireinterruptibly succeeds when released, else is interruptible",
	"Method": "void testAcquireInterruptibly(){\r\n    assertTrue(threadStarted.releaseShared(0));\r\n    sync.acquireInterruptibly();\r\n}"
}, {
	"Path": "sun.security.x509.InvalidityDateExtension.toString",
	"Comment": "returns a printable representation of the invalidity date.",
	"Method": "String toString(){\r\n    return super.toString() + \"    Invalidity Date: \" + String.valueOf(date);\r\n}"
}, {
	"Path": "java.security.cert.CollectionCertStoreParameters.clone",
	"Comment": "returns a copy of this object. note that only a reference to thecollection is copied, and not the contents.",
	"Method": "Object clone(){\r\n    try {\r\n        return super.clone();\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new InternalError(e.toString());\r\n    }\r\n}"
}, {
	"Path": "javax.crypto.ExemptionMechanism.finalize",
	"Comment": "ensures that the key stored away by this exemptionmechanismobject will be wiped out when there are no more references to it.",
	"Method": "void finalize(){\r\n    keyStored = null;\r\n}"
}, {
	"Path": "sun.security.util.DerValue.isConstructed",
	"Comment": "returns true iff the constructed tag matches the passed tag.",
	"Method": "boolean isConstructed(boolean isConstructed,byte constructedTag){\r\n    if (!isConstructed()) {\r\n        return false;\r\n    }\r\n    return ((tag & 0x01f) == constructedTag);\r\n}"
}, {
	"Path": "jsr166.TreeSetTest.populatedSet",
	"Comment": "returns a new set of given size containing consecutiveintegers 0 ... n.",
	"Method": "TreeSet<Integer> populatedSet(int n){\r\n    TreeSet<Integer> q = new TreeSet<Integer>();\r\n    assertTrue(q.isEmpty());\r\n    for (int i = n - 1; i >= 0; i -= 2) assertTrue(q.add(new Integer(i)));\r\n    for (int i = (n & 1); i < n; i += 2) assertTrue(q.add(new Integer(i)));\r\n    assertFalse(q.isEmpty());\r\n    assertEquals(n, q.size());\r\n    return q;\r\n}"
}, {
	"Path": "java.util.HashMap.addEntry",
	"Comment": "adds a new entry with the specified key, value and hash code tothe specified bucket.it is the responsibility of thismethod to resize the table if appropriate.subclass overrides this to alter the behavior of put method.",
	"Method": "void addEntry(int hash,K key,V value,int bucketIndex){\r\n    if ((size >= threshold) && (null != table[bucketIndex])) {\r\n        resize(2 * table.length);\r\n        hash = (null != key) ? sun.misc.Hashing.singleWordWangJenkinsHash(key) : 0;\r\n        bucketIndex = indexFor(hash, table.length);\r\n    }\r\n    createEntry(hash, key, value, bucketIndex);\r\n}"
}, {
	"Path": "sun.security.util.DerInputBuffer.getBigInteger",
	"Comment": "returns the integer which takes up the specified numberof bytes in this buffer as a biginteger.",
	"Method": "BigInteger getBigInteger(int len,boolean makePositive){\r\n    if (len > available())\r\n        throw new IOException(\"short read of integer\");\r\n    if (len == 0) {\r\n        throw new IOException(\"Invalid encoding: zero length Int value\");\r\n    }\r\n    byte[] bytes = new byte[len];\r\n    System.arraycopy(buf, pos, bytes, 0, len);\r\n    skip(len);\r\n    if (makePositive) {\r\n        return new BigInteger(1, bytes);\r\n    } else {\r\n        return new BigInteger(bytes);\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test421712",
	"Comment": "java.lang.nosuchmethoderror with lambda expression in interface default method.",
	"Method": "void test421712(){\r\n    runConformTest(new String[] { \"X.java\", \"interface F {\\n\" + \" void foo();\\n\" + \"}\\n\" + \"interface I {\\n\" + \" default void foo() {\\n\" + \"   F f = () -> {\\n\" + \"   };\\n\" + \"   System.out.println(\\\"Lambda instantiated\\\");\\n\" + \" }\\n\" + \"}\\n\" + \"public class X implements I {\\n\" + \" public static void main(String argv[]) {\\n\" + \"   X x = new X();\\n\" + \"   x.foo();\\n\" + \" }\\n\" + \"}\\n\" }, \"Lambda instantiated\");\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkQuietlyJoinSingleton",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoinSingleton(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FailingCCF f = new LFCCF(8);\r\n            assertSame(f, f.fork());\r\n            f.quietlyJoin();\r\n            assertTrue(f.getException() instanceof FJException);\r\n            checkCompletedAbnormally(f, f.getException());\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testAbnormalForkQuietlyJoinSingleton",
	"Comment": "quietlyjoin of a forked task returns when task completes abnormally",
	"Method": "void testAbnormalForkQuietlyJoinSingleton(){\r\n    FailingCCF f = new LFCCF(8);\r\n    assertSame(f, f.fork());\r\n    f.quietlyJoin();\r\n    assertTrue(f.getException() instanceof FJException);\r\n    checkCompletedAbnormally(f, f.getException());\r\n}"
}, {
	"Path": "jsr166.AtomicStampedReferenceTest.testCompareAndSet",
	"Comment": "compareandset succeeds in changing values if equal to expected referenceand stamp else fails",
	"Method": "void testCompareAndSet(){\r\n    int[] mark = new int[1];\r\n    AtomicStampedReference ai = new AtomicStampedReference(one, 0);\r\n    assertSame(one, ai.get(mark));\r\n    assertEquals(0, ai.getStamp());\r\n    assertEquals(0, mark[0]);\r\n    assertTrue(ai.compareAndSet(one, two, 0, 0));\r\n    assertSame(two, ai.get(mark));\r\n    assertEquals(0, mark[0]);\r\n    assertTrue(ai.compareAndSet(two, m3, 0, 1));\r\n    assertSame(m3, ai.get(mark));\r\n    assertEquals(1, mark[0]);\r\n    assertFalse(ai.compareAndSet(two, m3, 1, 1));\r\n    assertSame(m3, ai.get(mark));\r\n    assertEquals(1, mark[0]);\r\n}"
}, {
	"Path": "sun.security.provider.certpath.IndexedCollectionCertStore.buildIndex",
	"Comment": "index the specified collection copying all references to certificatesand crls.",
	"Method": "void buildIndex(Collection<?> coll){\r\n    certSubjects = new HashMap<X500Principal, Object>();\r\n    crlIssuers = new HashMap<X500Principal, Object>();\r\n    otherCertificates = null;\r\n    otherCRLs = null;\r\n    for (Object obj : coll) {\r\n        if (obj instanceof X509Certificate) {\r\n            indexCertificate((X509Certificate) obj);\r\n        } else if (obj instanceof X509CRL) {\r\n            indexCRL((X509CRL) obj);\r\n        } else if (obj instanceof Certificate) {\r\n            if (otherCertificates == null) {\r\n                otherCertificates = new HashSet<Certificate>();\r\n            }\r\n            otherCertificates.add((Certificate) obj);\r\n        } else if (obj instanceof CRL) {\r\n            if (otherCRLs == null) {\r\n                otherCRLs = new HashSet<CRL>();\r\n            }\r\n            otherCRLs.add((CRL) obj);\r\n        } else {\r\n        }\r\n    }\r\n    if (otherCertificates == null) {\r\n        otherCertificates = Collections.<Certificate>emptySet();\r\n    }\r\n    if (otherCRLs == null) {\r\n        otherCRLs = Collections.<CRL>emptySet();\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.AutoboxerTest.testUnboxedDoubleParameter",
	"Comment": "verify that passing a new double to a method that takes a double is unboxed.",
	"Method": "void testUnboxedDoubleParameter(){\r\n    String translation = translateSourceFile(\"class Test { void takesDouble(double d) {} void test() { takesDouble(new Double(1.2)); }}\", \"Test\", \"Test.m\");\r\n    assertTranslation(translation, \"[self takesDoubleWithDouble:[create_JavaLangDouble_initWithDouble_(1.2) doubleValue]];\");\r\n}"
}, {
	"Path": "sun.security.x509.X500Name.getRFC1779Name",
	"Comment": "returns a string form of the x.500 distinguished nameusing the algorithm defined in rfc 1779. only standard attribute typekeywords defined in rfc 1779 are emitted.",
	"Method": "String getRFC1779Name(String getRFC1779Name,Map<String, String> oidMap){\r\n    if (oidMap.isEmpty()) {\r\n        if (rfc1779Dn != null) {\r\n            return rfc1779Dn;\r\n        } else {\r\n            rfc1779Dn = generateRFC1779DN(oidMap);\r\n            return rfc1779Dn;\r\n        }\r\n    }\r\n    return generateRFC1779DN(oidMap);\r\n}"
}, {
	"Path": "javax.xml.datatype.XMLGregorianCalendar.hashCode",
	"Comment": "returns a hash code consistent with the definition of the equals method.",
	"Method": "int hashCode(){\r\n    int timezone = getTimezone();\r\n    if (timezone == DatatypeConstants.FIELD_UNDEFINED) {\r\n        timezone = 0;\r\n    }\r\n    XMLGregorianCalendar gc = this;\r\n    if (timezone != 0) {\r\n        gc = this.normalize();\r\n    }\r\n    return gc.getYear() + gc.getMonth() + gc.getDay() + gc.getHour() + gc.getMinute() + gc.getSecond();\r\n}"
}, {
	"Path": "sun.security.x509.X500Name.isEmpty",
	"Comment": "return whether this x500name is empty. an x500name is not emptyif it has at least one rdn containing at least one ava.",
	"Method": "boolean isEmpty(){\r\n    int n = names.length;\r\n    if (n == 0) {\r\n        return true;\r\n    }\r\n    for (int i = 0; i < n; i++) {\r\n        if (names[i].assertion.length != 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testConstructor1",
	"Comment": "constructor throws if corepoolsize argument is less than zero",
	"Method": "void testConstructor1(){\r\n    try {\r\n        new CustomTPE(-1, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "libcore.java.util.SimpleTimeZoneTest.describeTransitions",
	"Comment": "create a string representation of the transition information to allow all aspects to becompared in one go providing a better error message.",
	"Method": "String describeTransitions(String utcEntryTime,String utcExitTime){\r\n    return \"{Entry: \" + utcEntryTime + \", Exit: \" + utcExitTime + \"}\";\r\n}"
}, {
	"Path": "java.util.IllformedLocaleException.getErrorIndex",
	"Comment": "returns the index where the error was found. a negative value indicateseither the error index is not applicable or unknown.",
	"Method": "int getErrorIndex(){\r\n    return _errIdx;\r\n}"
}, {
	"Path": "jsr166.AbstractExecutorServiceTest.testSubmitFailedPrivilegedExceptionAction",
	"Comment": "a submitted failed privileged exception action reports exception",
	"Method": "void testSubmitFailedPrivilegedExceptionAction(){\r\n    Runnable r = new CheckedRunnable() {\r\n        public void realRun() throws Exception {\r\n            ExecutorService e = new DirectExecutorService();\r\n            Future future = e.submit(Executors.callable(new PrivilegedExceptionAction() {\r\n                public Object run() throws Exception {\r\n                    throw new IndexOutOfBoundsException();\r\n                }\r\n            }));\r\n            try {\r\n                future.get();\r\n                shouldThrow();\r\n            } catch (ExecutionException success) {\r\n                assertTrue(success.getCause() instanceof IndexOutOfBoundsException);\r\n            }\r\n        }\r\n    };\r\n    runWithPermissions(r);\r\n}"
}, {
	"Path": "jsr166.AbstractExecutorServiceTest.testSubmitFailedPrivilegedExceptionAction",
	"Comment": "a submitted failed privileged exception action reports exception",
	"Method": "void testSubmitFailedPrivilegedExceptionAction(){\r\n    ExecutorService e = new DirectExecutorService();\r\n    Future future = e.submit(Executors.callable(new PrivilegedExceptionAction() {\r\n        public Object run() throws Exception {\r\n            throw new IndexOutOfBoundsException();\r\n        }\r\n    }));\r\n    try {\r\n        future.get();\r\n        shouldThrow();\r\n    } catch (ExecutionException success) {\r\n        assertTrue(success.getCause() instanceof IndexOutOfBoundsException);\r\n    }\r\n}"
}, {
	"Path": "jsr166.AbstractExecutorServiceTest.testSubmitFailedPrivilegedExceptionAction",
	"Comment": "a submitted failed privileged exception action reports exception",
	"Method": "void testSubmitFailedPrivilegedExceptionAction(){\r\n    throw new IndexOutOfBoundsException();\r\n}"
}, {
	"Path": "javax.security.auth.callback.PasswordCallback.setPassword",
	"Comment": "set the retrieved password. this method makes a copy of the input passwordbefore storing it.",
	"Method": "void setPassword(char[] password){\r\n    this.inputPassword = (password == null ? null : password.clone());\r\n}"
}, {
	"Path": "java.util.Date.getCalendarSystem",
	"Comment": "returns the gregorian or julian calendar system to use with thegiven date. use gregorian from october 15, 1582.",
	"Method": "BaseCalendar getCalendarSystem(int year,BaseCalendar getCalendarSystem,long utc,BaseCalendar getCalendarSystem,BaseCalendar.Date cdate){\r\n    if (jcal == null) {\r\n        return GcalHolder.INSTANCE;\r\n    }\r\n    if (cdate.getEra() != null) {\r\n        return jcal;\r\n    }\r\n    return GcalHolder.INSTANCE;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.Vertex.throwableToString",
	"Comment": "return vertex throwable as string compatible withthe way tostring returns other information",
	"Method": "String throwableToString(){\r\n    StringBuilder sb = new StringBuilder(\"Exception:  \");\r\n    if (throwable != null)\r\n        sb.append(throwable.toString());\r\n    else\r\n        sb.append(\"null\");\r\n    sb.append(\"\\n\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "jsr166.ConcurrentLinkedDequeTest.populatedDeque",
	"Comment": "returns a new deque of given size containing consecutiveintegers 0 ... n.",
	"Method": "ConcurrentLinkedDeque<Integer> populatedDeque(int n){\r\n    ConcurrentLinkedDeque<Integer> q = new ConcurrentLinkedDeque<Integer>();\r\n    assertTrue(q.isEmpty());\r\n    for (int i = 0; i < n; ++i) assertTrue(q.offer(new Integer(i)));\r\n    assertFalse(q.isEmpty());\r\n    assertEquals(n, q.size());\r\n    return q;\r\n}"
}, {
	"Path": "jsr166.ThreadTest.testGetAndSetUncaughtExceptionHandler",
	"Comment": "getuncaughtexceptionhandler returns threadgroup unless set,otherwise returning value of last setuncaughtexceptionhandler.",
	"Method": "void testGetAndSetUncaughtExceptionHandler(){\r\n    Thread current = Thread.currentThread();\r\n    ThreadGroup tg = current.getThreadGroup();\r\n    MyHandler eh = new MyHandler();\r\n    assertSame(tg, current.getUncaughtExceptionHandler());\r\n    current.setUncaughtExceptionHandler(eh);\r\n    try {\r\n        assertSame(eh, current.getUncaughtExceptionHandler());\r\n    } finally {\r\n        current.setUncaughtExceptionHandler(null);\r\n    }\r\n    assertSame(tg, current.getUncaughtExceptionHandler());\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceFieldUpdaterTest.testConstructor2",
	"Comment": "construction with field not of given type throws classcastexception",
	"Method": "void testConstructor2(){\r\n    try {\r\n        updaterFor(\"z\");\r\n        shouldThrow();\r\n    } catch (ClassCastException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testConstructor6",
	"Comment": "constructor throws if corepoolsize argument is less than zero",
	"Method": "void testConstructor6(){\r\n    try {\r\n        new CustomTPE(-1, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10), new SimpleThreadFactory());\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testConstructor5",
	"Comment": "constructor throws if corepoolsize is greater than the maximumpoolsize",
	"Method": "void testConstructor5(){\r\n    try {\r\n        new CustomTPE(2, 1, 1L, SECONDS, new ArrayBlockingQueue<Runnable>(10));\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n}"
}, {
	"Path": "android.icu.dev.util.UnicodeMap.setMissing",
	"Comment": "set the currently unmapped unicode code points to the given value.",
	"Method": "UnicodeMap<T> setMissing(T value){\r\n    if (!getAvailableValues().contains(value)) {\r\n        staleAvailableValues = true;\r\n        availableValues.add(value);\r\n        for (int i = 0; i < length; ++i) {\r\n            if (values[i] == null)\r\n                values[i] = value;\r\n        }\r\n        return this;\r\n    } else {\r\n        return putAll(keySet(null), value);\r\n    }\r\n}"
}, {
	"Path": "java.util.stream.DoubleStream.of",
	"Comment": "returns a sequential ordered stream whose elements are the specified values.",
	"Method": "DoubleStream of(double t,DoubleStream of,double values){\r\n    return Arrays.stream(values);\r\n}"
}, {
	"Path": "sun.misc.FloatingDecimal.parseFloat",
	"Comment": "converts a string to a single precision floating point value.",
	"Method": "float parseFloat(String s){\r\n    return readJavaFormatString(s).floatValue();\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.unpackRules",
	"Comment": "given an array of bytes produced by packrules, interpret themas the start and end rules.",
	"Method": "void unpackRules(byte[] rules){\r\n    startDay = rules[0];\r\n    startDayOfWeek = rules[1];\r\n    endDay = rules[2];\r\n    endDayOfWeek = rules[3];\r\n    if (rules.length >= 6) {\r\n        startTimeMode = rules[4];\r\n        endTimeMode = rules[5];\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.X509CRLSelector.addIssuer",
	"Comment": "adds a name to the issuernames criterion. the issuer distinguishedname in the x509crl must match at least one of the specifieddistinguished names.this method allows the caller to add a name to the set of issuer nameswhich x509crls may contain. the specified name is added toany previous value for the issuernames criterion.if the specified name is a duplicate, it may be ignored.",
	"Method": "void addIssuer(X500Principal issuer){\r\n    addIssuerNameInternal(issuer.getEncoded(), issuer);\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testPollNextLocalTaskAsync",
	"Comment": "pollnextlocaltask returns least recent unexecuted task withoutexecuting it, in async mode",
	"Method": "void testPollNextLocalTaskAsync(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() {\r\n            FibTask g = new FibTask(9);\r\n            assertSame(g, g.fork());\r\n            FibTask f = new FibTask(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, pollNextLocalTask());\r\n            helpQuiesce();\r\n            checkCompletedNormally(f, 21);\r\n            checkNotDone(g);\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(asyncSingletonPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testPollNextLocalTaskAsync",
	"Comment": "pollnextlocaltask returns least recent unexecuted task withoutexecuting it, in async mode",
	"Method": "void testPollNextLocalTaskAsync(){\r\n    FibTask g = new FibTask(9);\r\n    assertSame(g, g.fork());\r\n    FibTask f = new FibTask(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, pollNextLocalTask());\r\n    helpQuiesce();\r\n    checkCompletedNormally(f, 21);\r\n    checkNotDone(g);\r\n    return NoResult;\r\n}"
}, {
	"Path": "jsr166.TreeSubMapTest.testDescendingGet",
	"Comment": "get returns the correct element at the given key,or null if not present",
	"Method": "void testDescendingGet(){\r\n    NavigableMap map = dmap5();\r\n    assertEquals(\"A\", (String) map.get(m1));\r\n    NavigableMap empty = dmap0();\r\n    assertNull(empty.get(m1));\r\n}"
}, {
	"Path": "java.util.logging.Logger.severe",
	"Comment": "log a severe message.if the logger is currently enabled for the severe messagelevel then the given message is forwarded to all theregistered output handler objects.",
	"Method": "void severe(String msg){\r\n    if (Level.SEVERE.intValue() < levelValue) {\r\n        return;\r\n    }\r\n    log(Level.SEVERE, msg);\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testRegister4",
	"Comment": "register causes the next arrive to not increment the phaserather retain the phase number",
	"Method": "void testRegister4(){\r\n    Phaser phaser = new Phaser(1);\r\n    assertEquals(0, phaser.arrive());\r\n    assertEquals(1, phaser.register());\r\n    assertEquals(1, phaser.arrive());\r\n    assertState(phaser, 1, 2, 1);\r\n}"
}, {
	"Path": "java.util.logging.LogRecord.getThreadID",
	"Comment": "get an identifier for the thread where the message originated.this is a thread identifier within the java vm and may ormay not map to any operating system id.",
	"Method": "int getThreadID(){\r\n    return threadID;\r\n}"
}, {
	"Path": "java.beans.StandardBeanInfo.introspectMethods",
	"Comment": "introspects the supplied class and returns a list of the public methodsof the class",
	"Method": "MethodDescriptor[] introspectMethods(MethodDescriptor[] introspectMethods,boolean includeSuper,MethodDescriptor[] introspectMethods,boolean includeSuper,Class<?> introspectorClass){\r\n    Method[] basicMethods = includeSuper ? introspectorClass.getMethods() : introspectorClass.getDeclaredMethods();\r\n    if (basicMethods == null || basicMethods.length == 0)\r\n        return null;\r\n    ArrayList<MethodDescriptor> methodList = new ArrayList<MethodDescriptor>(basicMethods.length);\r\n    for (int i = 0; i < basicMethods.length; i++) {\r\n        int modifiers = basicMethods[i].getModifiers();\r\n        if (Modifier.isPublic(modifiers)) {\r\n            MethodDescriptor theDescriptor = new MethodDescriptor(basicMethods[i]);\r\n            methodList.add(theDescriptor);\r\n        }\r\n    }\r\n    int methodCount = methodList.size();\r\n    MethodDescriptor[] theMethods = null;\r\n    if (methodCount > 0) {\r\n        theMethods = new MethodDescriptor[methodCount];\r\n        theMethods = methodList.toArray(theMethods);\r\n    }\r\n    return theMethods;\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinTask.quietlyJoin",
	"Comment": "joins this task, without returning its result or throwing itsexception. this method may be useful when processingcollections of tasks when some have been cancelled or otherwiseknown to have aborted.",
	"Method": "void quietlyJoin(){\r\n    doJoin();\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.javac.JavacJ2ObjCIncompatibleStripper.checkAnnotations",
	"Comment": "checks for any j2objcincompatible annotations. returns whetherthe caller should to continue scanning this node.",
	"Method": "boolean checkAnnotations(List<JCAnnotation> annotations,JCTree node){\r\n    for (JCAnnotation annotation : annotations) {\r\n        if (isJ2ObjCIncompatible(annotation)) {\r\n            nodesToStrip.add(node);\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testHasWaiters",
	"Comment": "haswaiters returns true when a thread is waiting, else false",
	"Method": "void testHasWaiters(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    final BooleanLatch acquired = new BooleanLatch();\r\n    Thread t = newStartedThread(new CheckedRunnable() {\r\n        public void realRun() throws InterruptedException {\r\n            sync.acquire();\r\n            assertHasWaitersLocked(sync, c, NO_THREADS);\r\n            assertFalse(sync.hasWaiters(c));\r\n            assertTrue(acquired.releaseShared(0));\r\n            c.await();\r\n            sync.release();\r\n        }\r\n    });\r\n    acquired.acquireShared(0);\r\n    sync.acquire();\r\n    assertHasWaitersLocked(sync, c, t);\r\n    assertHasExclusiveQueuedThreads(sync, NO_THREADS);\r\n    assertTrue(sync.hasWaiters(c));\r\n    c.signal();\r\n    assertHasWaitersLocked(sync, c, NO_THREADS);\r\n    assertHasExclusiveQueuedThreads(sync, t);\r\n    assertFalse(sync.hasWaiters(c));\r\n    sync.release();\r\n    awaitTermination(t);\r\n    assertHasWaitersUnlocked(sync, c, NO_THREADS);\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testHasWaiters",
	"Comment": "haswaiters returns true when a thread is waiting, else false",
	"Method": "void testHasWaiters(){\r\n    sync.acquire();\r\n    assertHasWaitersLocked(sync, c, NO_THREADS);\r\n    assertFalse(sync.hasWaiters(c));\r\n    assertTrue(acquired.releaseShared(0));\r\n    c.await();\r\n    sync.release();\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.getLong",
	"Comment": "return a long which is equal to the unsigned value of the int inuse in this mutablebiginteger at the specified index. this method isnot used because it is not inlined on all platforms.",
	"Method": "long getLong(int index){\r\n    return value[offset + index] & LONG_MASK;\r\n}"
}, {
	"Path": "org.kxml2.io.KXmlParser.popContentSource",
	"Comment": "replaces the current exhausted buffer with the next buffer in the chain.",
	"Method": "void popContentSource(){\r\n    buffer = nextContentSource.buffer;\r\n    position = nextContentSource.position;\r\n    limit = nextContentSource.limit;\r\n    nextContentSource = nextContentSource.next;\r\n}"
}, {
	"Path": "java.util.zip.ZipEntry.setComment",
	"Comment": "sets the optional comment string for the entry.zip entry comments have maximum length of 0xffff. if the length of thespecified comment string is greater than 0xffff bytes after encoding, onlythe first 0xffff bytes are output to the zip file entry.",
	"Method": "void setComment(String comment){\r\n    if (comment == null) {\r\n        this.comment = null;\r\n        return;\r\n    }\r\n    if (comment.getBytes(StandardCharsets.UTF_8).length > 0xffff) {\r\n        throw new IllegalArgumentException(comment + \" too long: \" + comment.getBytes(StandardCharsets.UTF_8).length);\r\n    }\r\n    this.comment = comment;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.setCertificate",
	"Comment": "sets the certificateequals criterion. the specifiedx509certificate must be equal to thex509certificate passed to the match method.if null, then this check is not applied.this method is particularly useful when it is necessary tomatch a single certificate. although other criteria can be specifiedin conjunction with the certificateequals criterion, it is usually notpractical or necessary.",
	"Method": "void setCertificate(X509Certificate cert){\r\n    x509Cert = cert;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.ConstantBranchPruner.removeUnreachable",
	"Comment": "removes all unreachable statements that occur after a return statement inthe given block. also recurses into child blocks.",
	"Method": "boolean removeUnreachable(Block block){\r\n    List<Statement> stmts = block.getStatements();\r\n    for (int i = 0; i < stmts.size(); i++) {\r\n        Statement stmt = stmts.get(i);\r\n        if (stmt instanceof ReturnStatement || (stmt instanceof Block && removeUnreachable((Block) stmt))) {\r\n            stmts.subList(i + 1, stmts.size()).clear();\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testPeekNextLocalTaskAsync",
	"Comment": "peeknextlocaltask returns least recent unexecuted task in async mode",
	"Method": "void testPeekNextLocalTaskAsync(){\r\n    RecursiveAction a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            FibAction g = new FibAction(9);\r\n            assertSame(g, g.fork());\r\n            FibAction f = new FibAction(8);\r\n            assertSame(f, f.fork());\r\n            assertSame(g, peekNextLocalTask());\r\n            assertNull(f.join());\r\n            helpQuiesce();\r\n            checkCompletedNormally(f);\r\n            checkCompletedNormally(g);\r\n        }\r\n    };\r\n    testInvokeOnPool(asyncSingletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.RecursiveActionTest.testPeekNextLocalTaskAsync",
	"Comment": "peeknextlocaltask returns least recent unexecuted task in async mode",
	"Method": "void testPeekNextLocalTaskAsync(){\r\n    FibAction g = new FibAction(9);\r\n    assertSame(g, g.fork());\r\n    FibAction f = new FibAction(8);\r\n    assertSame(f, f.fork());\r\n    assertSame(g, peekNextLocalTask());\r\n    assertNull(f.join());\r\n    helpQuiesce();\r\n    checkCompletedNormally(f);\r\n    checkCompletedNormally(g);\r\n}"
}, {
	"Path": "java.util.stream.Stream.of",
	"Comment": "returns a sequential ordered stream whose elements are the specified values.",
	"Method": "Stream<T> of(T t,Stream<T> of,T values){\r\n    return Arrays.stream(values);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.ElementUtil.hasOuterContext",
	"Comment": "determines if a type element can access fields and methods from an outer class.",
	"Method": "boolean hasOuterContext(TypeElement type){\r\n    switch(type.getNestingKind()) {\r\n        case ANONYMOUS:\r\n        case LOCAL:\r\n            return !isStatic(type.getEnclosingElement());\r\n        case MEMBER:\r\n            return !isStatic(type);\r\n        case TOP_LEVEL:\r\n            return false;\r\n    }\r\n    throw new AssertionError(\"Unknown NestingKind\");\r\n}"
}, {
	"Path": "java.util.ServiceLoader.load",
	"Comment": "creates a new service loader for the given service type and classloader.",
	"Method": "ServiceLoader<S> load(Class<S> service,ClassLoader loader,ServiceLoader<S> load,Class<S> service){\r\n    return ServiceLoader.load(service, ClassLoader.getSystemClassLoader());\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testForkHelpQuiesce",
	"Comment": "helpquiesce returns when tasks are complete.getqueuedtaskcount returns 0 when quiescent",
	"Method": "void testForkHelpQuiesce(){\r\n    RecursiveTask<Integer> a = new CheckedRecursiveTask<Integer>() {\r\n        public Integer realCompute() {\r\n            FibTask f = new FibTask(8);\r\n            assertSame(f, f.fork());\r\n            helpQuiesce();\r\n            while (!f.isDone()) ;\r\n            assertEquals(0, getQueuedTaskCount());\r\n            checkCompletedNormally(f, 21);\r\n            return NoResult;\r\n        }\r\n    };\r\n    assertSame(NoResult, testInvokeOnPool(mainPool(), a));\r\n}"
}, {
	"Path": "jsr166.RecursiveTaskTest.testForkHelpQuiesce",
	"Comment": "helpquiesce returns when tasks are complete.getqueuedtaskcount returns 0 when quiescent",
	"Method": "void testForkHelpQuiesce(){\r\n    FibTask f = new FibTask(8);\r\n    assertSame(f, f.fork());\r\n    helpQuiesce();\r\n    while (!f.isDone()) ;\r\n    assertEquals(0, getQueuedTaskCount());\r\n    checkCompletedNormally(f, 21);\r\n    return NoResult;\r\n}"
}, {
	"Path": "java.util.Optional.orElseThrow",
	"Comment": "return the contained value, if present, otherwise throw an exceptionto be created by the provided supplier.",
	"Method": "T orElseThrow(Supplier<? extends X> exceptionSupplier){\r\n    if (value != null) {\r\n        return value;\r\n    } else {\r\n        throw exceptionSupplier.get();\r\n    }\r\n}"
}, {
	"Path": "java.security.KeyStoreSpi.engineGetEntry",
	"Comment": "gets a keystore.entry for the specified aliaswith the specified protection parameter.",
	"Method": "KeyStore.Entry engineGetEntry(String alias,KeyStore.ProtectionParameter protParam){\r\n    if (!engineContainsAlias(alias)) {\r\n        return null;\r\n    }\r\n    if (protParam != null && !(protParam instanceof KeyStore.PasswordProtection)) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n    if (engineIsCertificateEntry(alias)) {\r\n        if (protParam == null) {\r\n            return new KeyStore.TrustedCertificateEntry(engineGetCertificate(alias));\r\n        } else {\r\n            throw new UnsupportedOperationException(\"trusted certificate entries are not password-protected\");\r\n        }\r\n    } else if (engineIsKeyEntry(alias)) {\r\n        char[] password = null;\r\n        if (protParam != null) {\r\n            KeyStore.PasswordProtection pp = (KeyStore.PasswordProtection) protParam;\r\n            password = pp.getPassword();\r\n        }\r\n        Key key = engineGetKey(alias, password);\r\n        if (key instanceof PrivateKey) {\r\n            Certificate[] chain = engineGetCertificateChain(alias);\r\n            return new KeyStore.PrivateKeyEntry((PrivateKey) key, chain);\r\n        } else if (key instanceof SecretKey) {\r\n            return new KeyStore.SecretKeyEntry((SecretKey) key);\r\n        }\r\n    }\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "jsr166.PhaserTest.testRegister2",
	"Comment": "registering more than 65536 parties causes illegalstateexception",
	"Method": "void testRegister2(){\r\n    Phaser phaser = new Phaser(0);\r\n    assertState(phaser, 0, 0, 0);\r\n    assertEquals(0, phaser.bulkRegister(maxParties - 10));\r\n    assertState(phaser, 0, maxParties - 10, maxParties - 10);\r\n    for (int i = 0; i < 10; i++) {\r\n        assertState(phaser, 0, maxParties - 10 + i, maxParties - 10 + i);\r\n        assertEquals(0, phaser.register());\r\n    }\r\n    assertState(phaser, 0, maxParties, maxParties);\r\n    try {\r\n        phaser.register();\r\n        shouldThrow();\r\n    } catch (IllegalStateException success) {\r\n    }\r\n    try {\r\n        phaser.bulkRegister(Integer.MAX_VALUE);\r\n        shouldThrow();\r\n    } catch (IllegalStateException success) {\r\n    }\r\n    assertEquals(0, phaser.bulkRegister(0));\r\n    assertState(phaser, 0, maxParties, maxParties);\r\n}"
}, {
	"Path": "android.icu.dev.test.format.DateFormatRegressionTestJ.Test4358730",
	"Comment": "simpledateformat inconsistent for number of digits for years",
	"Method": "void Test4358730(){\r\n    SimpleDateFormat sdf = new SimpleDateFormat();\r\n    Calendar cal = Calendar.getInstance();\r\n    cal.clear();\r\n    cal.set(2001, 11, 10);\r\n    Date today = cal.getTime();\r\n    sdf.applyPattern(\"MM d y\");\r\n    logln(sdf.format(today));\r\n    sdf.applyPattern(\"MM d yy\");\r\n    logln(sdf.format(today));\r\n    sdf.applyPattern(\"MM d yyy\");\r\n    logln(sdf.format(today));\r\n    sdf.applyPattern(\"MM d yyyy\");\r\n    logln(sdf.format(today));\r\n    sdf.applyPattern(\"MM d yyyyy\");\r\n    logln(sdf.format(today));\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedSynchronizer.getQueueLength",
	"Comment": "returns an estimate of the number of threads waiting toacquire.the value is only an estimate because the number ofthreads may change dynamically while this method traversesinternal data structures.this method is designed for use inmonitoring system state, not for synchronization control.",
	"Method": "int getQueueLength(){\r\n    int n = 0;\r\n    for (Node p = tail; p != null; p = p.prev) {\r\n        if (p.thread != null)\r\n            ++n;\r\n    }\r\n    return n;\r\n}"
}, {
	"Path": "sun.security.provider.certpath.OCSP.check",
	"Comment": "checks the revocation status of a list of certificates using ocsp.",
	"Method": "RevocationStatus check(X509Certificate cert,X509Certificate issuerCert,RevocationStatus check,X509Certificate cert,X509Certificate issuerCert,URI responderURI,X509Certificate responderCert,Date date,RevocationStatus check,X509Certificate cert,X509Certificate issuerCert,URI responderURI,X509Certificate responderCert,Date date,List<Extension> extensions,OCSPResponse check,List<CertId> certIds,URI responderURI,X509Certificate issuerCert,X509Certificate responderCert,Date date,List<Extension> extensions){\r\n    byte[] bytes = null;\r\n    OCSPRequest request = null;\r\n    try {\r\n        request = new OCSPRequest(certIds, extensions);\r\n        bytes = request.encodeBytes();\r\n    } catch (IOException ioe) {\r\n        throw new CertPathValidatorException(\"Exception while encoding OCSPRequest\", ioe);\r\n    }\r\n    InputStream in = null;\r\n    OutputStream out = null;\r\n    byte[] response = null;\r\n    try {\r\n        URL url = responderURI.toURL();\r\n        if (debug != null) {\r\n            debug.println(\"connecting to OCSP service at: \" + url);\r\n        }\r\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\r\n        con.setConnectTimeout(CONNECT_TIMEOUT);\r\n        con.setReadTimeout(CONNECT_TIMEOUT);\r\n        con.setDoOutput(true);\r\n        con.setDoInput(true);\r\n        con.setRequestMethod(\"POST\");\r\n        con.setRequestProperty(\"Content-type\", \"application/ocsp-request\");\r\n        con.setRequestProperty(\"Content-length\", String.valueOf(bytes.length));\r\n        out = con.getOutputStream();\r\n        out.write(bytes);\r\n        out.flush();\r\n        if (debug != null && con.getResponseCode() != HttpURLConnection.HTTP_OK) {\r\n            debug.println(\"Received HTTP error: \" + con.getResponseCode() + \" - \" + con.getResponseMessage());\r\n        }\r\n        in = con.getInputStream();\r\n        int contentLength = con.getContentLength();\r\n        if (contentLength == -1) {\r\n            contentLength = Integer.MAX_VALUE;\r\n        }\r\n        response = new byte[contentLength > 2048 ? 2048 : contentLength];\r\n        int total = 0;\r\n        while (total < contentLength) {\r\n            int count = in.read(response, total, response.length - total);\r\n            if (count < 0)\r\n                break;\r\n            total += count;\r\n            if (total >= response.length && total < contentLength) {\r\n                response = Arrays.copyOf(response, total * 2);\r\n            }\r\n        }\r\n        response = Arrays.copyOf(response, total);\r\n    } catch (IOException ioe) {\r\n        throw new CertPathValidatorException(\"Unable to determine revocation status due to network error\", ioe, null, -1, BasicReason.UNDETERMINED_REVOCATION_STATUS);\r\n    } finally {\r\n        if (in != null) {\r\n            try {\r\n                in.close();\r\n            } catch (IOException ioe) {\r\n                throw ioe;\r\n            }\r\n        }\r\n        if (out != null) {\r\n            try {\r\n                out.close();\r\n            } catch (IOException ioe) {\r\n                throw ioe;\r\n            }\r\n        }\r\n    }\r\n    OCSPResponse ocspResponse = null;\r\n    try {\r\n        ocspResponse = new OCSPResponse(response);\r\n    } catch (IOException ioe) {\r\n        throw new CertPathValidatorException(ioe);\r\n    }\r\n    ocspResponse.verify(certIds, issuerCert, responderCert, date, request.getNonce());\r\n    return ocspResponse;\r\n}"
}, {
	"Path": "tests.util.SerializationTester.assertCompabilitySame",
	"Comment": "tests the serialization compatibility with reference const objects.",
	"Method": "boolean assertCompabilitySame(Object obj,String fileName){\r\n    return obj == readObject(obj, fileName);\r\n}"
}, {
	"Path": "java.util.Collections.list",
	"Comment": "returns an array list containing the elements returned by thespecified enumeration in the order they are returned by theenumeration.this method provides interoperability betweenlegacy apis that return enumerations and new apis that requirecollections.",
	"Method": "ArrayList<T> list(Enumeration<T> e){\r\n    ArrayList<T> l = new ArrayList();\r\n    while (e.hasMoreElements()) l.add(e.nextElement());\r\n    return l;\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testShutdownNow",
	"Comment": "shutdownnow returns a list containing tasks that were not run,and those tasks are drained from the queue",
	"Method": "void testShutdownNow(){\r\n    final int poolSize = 2;\r\n    final int count = 5;\r\n    final AtomicInteger ran = new AtomicInteger(0);\r\n    final CustomExecutor p = new CustomExecutor(poolSize);\r\n    final CountDownLatch threadsStarted = new CountDownLatch(poolSize);\r\n    Runnable waiter = new CheckedRunnable() {\r\n        public void realRun() {\r\n            threadsStarted.countDown();\r\n            try {\r\n                MILLISECONDS.sleep(2 * LONG_DELAY_MS);\r\n            } catch (InterruptedException success) {\r\n            }\r\n            ran.getAndIncrement();\r\n        }\r\n    };\r\n    for (int i = 0; i < count; i++) p.execute(waiter);\r\n    await(threadsStarted);\r\n    assertEquals(poolSize, p.getActiveCount());\r\n    assertEquals(0, p.getCompletedTaskCount());\r\n    final List<Runnable> queuedTasks;\r\n    try {\r\n        queuedTasks = p.shutdownNow();\r\n    } catch (SecurityException ok) {\r\n        return;\r\n    }\r\n    assertTrue(p.isShutdown());\r\n    assertTrue(p.getQueue().isEmpty());\r\n    assertEquals(count - poolSize, queuedTasks.size());\r\n    assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));\r\n    assertTrue(p.isTerminated());\r\n    assertEquals(poolSize, ran.get());\r\n    assertEquals(poolSize, p.getCompletedTaskCount());\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testShutdownNow",
	"Comment": "shutdownnow returns a list containing tasks that were not run,and those tasks are drained from the queue",
	"Method": "void testShutdownNow(){\r\n    threadsStarted.countDown();\r\n    try {\r\n        MILLISECONDS.sleep(2 * LONG_DELAY_MS);\r\n    } catch (InterruptedException success) {\r\n    }\r\n    ran.getAndIncrement();\r\n}"
}, {
	"Path": "java.util.Date.getMinutes",
	"Comment": "returns the number of minutes past the hour represented by this date,as interpreted in the local time zone.the value returned is between 0 and 59.",
	"Method": "int getMinutes(){\r\n    return normalize().getMinutes();\r\n}"
}, {
	"Path": "jsr166.AbstractQueuedLongSynchronizerTest.testGetWaitingThreadsIAE",
	"Comment": "getwaitingthreads throws illegalargumentexception if not owned",
	"Method": "void testGetWaitingThreadsIAE(){\r\n    final Mutex sync = new Mutex();\r\n    final ConditionObject c = sync.newCondition();\r\n    final Mutex sync2 = new Mutex();\r\n    try {\r\n        sync2.getWaitingThreads(c);\r\n        shouldThrow();\r\n    } catch (IllegalArgumentException success) {\r\n    }\r\n    assertHasWaitersUnlocked(sync, c, NO_THREADS);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testForkHelpQuiesceSingleton",
	"Comment": "helpquiesce returns when tasks are complete.getqueuedtaskcount returns 0 when quiescent",
	"Method": "void testForkHelpQuiesceSingleton(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            CCF f = new LCCF(8);\r\n            assertSame(f, f.fork());\r\n            helpQuiesce();\r\n            assertEquals(0, getQueuedTaskCount());\r\n            assertEquals(21, f.number);\r\n            checkCompletedNormally(f);\r\n        }\r\n    };\r\n    testInvokeOnPool(singletonPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testForkHelpQuiesceSingleton",
	"Comment": "helpquiesce returns when tasks are complete.getqueuedtaskcount returns 0 when quiescent",
	"Method": "void testForkHelpQuiesceSingleton(){\r\n    CCF f = new LCCF(8);\r\n    assertSame(f, f.fork());\r\n    helpQuiesce();\r\n    assertEquals(0, getQueuedTaskCount());\r\n    assertEquals(21, f.number);\r\n    checkCompletedNormally(f);\r\n}"
}, {
	"Path": "java.net.NetworkInterface.getByName",
	"Comment": "searches for the network interface with the specified name.",
	"Method": "NetworkInterface getByName(String name){\r\n    if (name == null)\r\n        throw new NullPointerException();\r\n    return getByName0(name);\r\n}"
}, {
	"Path": "java.util.Calendar.isFullyNormalized",
	"Comment": "returns whether the calendar fields are fully in sync with the timevalue.",
	"Method": "boolean isFullyNormalized(){\r\n    return areFieldsSet && areAllFieldsSet;\r\n}"
}, {
	"Path": "java.math.MutableBigInteger.mul",
	"Comment": "multiply the contents of this mutablebiginteger by the word y. theresult is placed into z.",
	"Method": "void mul(int y,MutableBigInteger z){\r\n    if (y == 1) {\r\n        z.copyValue(this);\r\n        return;\r\n    }\r\n    if (y == 0) {\r\n        z.clear();\r\n        return;\r\n    }\r\n    long ylong = y & LONG_MASK;\r\n    int[] zval = (z.value.length < intLen + 1 ? new int[intLen + 1] : z.value);\r\n    long carry = 0;\r\n    for (int i = intLen - 1; i >= 0; i--) {\r\n        long product = ylong * (value[i + offset] & LONG_MASK) + carry;\r\n        zval[i + 1] = (int) product;\r\n        carry = product >>> 32;\r\n    }\r\n    if (carry == 0) {\r\n        z.offset = 1;\r\n        z.intLen = intLen;\r\n    } else {\r\n        z.offset = 0;\r\n        z.intLen = intLen + 1;\r\n        zval[0] = (int) carry;\r\n    }\r\n    z.value = zval;\r\n}"
}, {
	"Path": "jsr166.Atomic8Test.testLongArrayGetAndAccumulate",
	"Comment": "atomiclongarray getandaccumulate returns previous value and updateswith supplied function.",
	"Method": "void testLongArrayGetAndAccumulate(){\r\n    AtomicLongArray a = new AtomicLongArray(1);\r\n    a.set(0, 1);\r\n    assertEquals(1L, a.getAndAccumulate(0, 2L, Long::sum));\r\n    assertEquals(3L, a.getAndAccumulate(0, 3L, Long::sum));\r\n    assertEquals(6L, a.get(0));\r\n}"
}, {
	"Path": "test.java.time.chrono.TestUmmAlQuraChronology.test_hijrahToThai",
	"Comment": "test to verify the date conversion from hijrah to thai chronology",
	"Method": "void test_hijrahToThai(HijrahDate hijrah,ThaiBuddhistDate thai){\r\n    assertEquals(ThaiBuddhistChronology.INSTANCE.date(hijrah), thai);\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceKeysToDouble",
	"Comment": "returns the result of accumulating the given transformationof all keys using the given reducer to combine values, andthe given basis as an identity value.",
	"Method": "double reduceKeysToDouble(long parallelismThreshold,ToDoubleFunction<? super K> transformer,double basis,DoubleBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceKeysToDoubleTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.getPerMill",
	"Comment": "gets the character used for per mille sign. different for arabic, etc.",
	"Method": "char getPerMill(){\r\n    return perMill;\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes normally.iscompletedabnormally and iscancelled return false for normallycompleted tasks",
	"Method": "void testQuietlyInvoke(){\r\n    ForkJoinTask a = new CheckedRecursiveAction() {\r\n        protected void realCompute() {\r\n            CCF f = new LCCF(8);\r\n            f.quietlyInvoke();\r\n            assertEquals(21, f.number);\r\n            checkCompletedNormally(f);\r\n        }\r\n    };\r\n    testInvokeOnPool(mainPool(), a);\r\n}"
}, {
	"Path": "jsr166.CountedCompleterTest.testQuietlyInvoke",
	"Comment": "quietlyinvoke task returns when task completes normally.iscompletedabnormally and iscancelled return false for normallycompleted tasks",
	"Method": "void testQuietlyInvoke(){\r\n    CCF f = new LCCF(8);\r\n    f.quietlyInvoke();\r\n    assertEquals(21, f.number);\r\n    checkCompletedNormally(f);\r\n}"
}, {
	"Path": "java.time.chrono.Chronology.getDisplayName",
	"Comment": "gets the textual representation of this chronology.this returns the textual name used to identify the chronology,suitable for presentation to the user.the parameters control the style of the returned text and the locale.",
	"Method": "String getDisplayName(TextStyle style,Locale locale){\r\n    TemporalAccessor temporal = new TemporalAccessor() {\r\n        @Override\r\n        public boolean isSupported(TemporalField field) {\r\n            return false;\r\n        }\r\n        @Override\r\n        public long getLong(TemporalField field) {\r\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\r\n        }\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public <R> R query(TemporalQuery<R> query) {\r\n            if (query == TemporalQueries.chronology()) {\r\n                return (R) Chronology.this;\r\n            }\r\n            return TemporalAccessor.super.query(query);\r\n        }\r\n    };\r\n    return new DateTimeFormatterBuilder().appendChronologyText(style).toFormatter(locale).format(temporal);\r\n}"
}, {
	"Path": "java.time.chrono.Chronology.getDisplayName",
	"Comment": "gets the textual representation of this chronology.this returns the textual name used to identify the chronology,suitable for presentation to the user.the parameters control the style of the returned text and the locale.",
	"Method": "String getDisplayName(TextStyle style,Locale locale){\r\n    return false;\r\n}"
}, {
	"Path": "java.time.chrono.Chronology.getDisplayName",
	"Comment": "gets the textual representation of this chronology.this returns the textual name used to identify the chronology,suitable for presentation to the user.the parameters control the style of the returned text and the locale.",
	"Method": "String getDisplayName(TextStyle style,Locale locale){\r\n    throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\r\n}"
}, {
	"Path": "java.time.chrono.Chronology.getDisplayName",
	"Comment": "gets the textual representation of this chronology.this returns the textual name used to identify the chronology,suitable for presentation to the user.the parameters control the style of the returned text and the locale.",
	"Method": "String getDisplayName(TextStyle style,Locale locale){\r\n    if (query == TemporalQueries.chronology()) {\r\n        return (R) Chronology.this;\r\n    }\r\n    return TemporalAccessor.super.query(query);\r\n}"
}, {
	"Path": "android.icu.dev.test.timezone.TimeZoneRuleTest.TestHistoricalRuleBasedTimeZone",
	"Comment": "test equivalency between olsontimezone and custom rbtz representing theequivalent rules in a certain time range",
	"Method": "void TestHistoricalRuleBasedTimeZone(){\r\n    TimeZone ny = TimeZone.getTimeZone(\"America/New_York\", TimeZone.TIMEZONE_ICU);\r\n    InitialTimeZoneRule ir = new InitialTimeZoneRule(\"EST\", -5 * HOUR, 0);\r\n    RuleBasedTimeZone rbtz = new RuleBasedTimeZone(\"EST5EDT\", ir);\r\n    DateTimeRule dtr;\r\n    AnnualTimeZoneRule tzr;\r\n    dtr = new // Last Sunday in October, at 2AM wall time\r\n    DateTimeRule(// Last Sunday in October, at 2AM wall time\r\n    Calendar.OCTOBER, // Last Sunday in October, at 2AM wall time\r\n    -1, // Last Sunday in October, at 2AM wall time\r\n    Calendar.SUNDAY, 2 * HOUR, DateTimeRule.WALL_TIME);\r\n    tzr = new AnnualTimeZoneRule(\"EST\", -5 * HOUR, 0, dtr, 1967, 2006);\r\n    rbtz.addTransitionRule(tzr);\r\n    dtr = new // SUN>=1 in November, at 2AM wall time\r\n    DateTimeRule(// SUN>=1 in November, at 2AM wall time\r\n    Calendar.NOVEMBER, // SUN>=1 in November, at 2AM wall time\r\n    1, // SUN>=1 in November, at 2AM wall time\r\n    Calendar.SUNDAY, // SUN>=1 in November, at 2AM wall time\r\n    true, 2 * HOUR, DateTimeRule.WALL_TIME);\r\n    tzr = new AnnualTimeZoneRule(\"EST\", -5 * HOUR, 0, dtr, 2007, AnnualTimeZoneRule.MAX_YEAR);\r\n    rbtz.addTransitionRule(tzr);\r\n    dtr = new // Last Sunday in April, at 2AM wall time\r\n    DateTimeRule(// Last Sunday in April, at 2AM wall time\r\n    Calendar.APRIL, // Last Sunday in April, at 2AM wall time\r\n    -1, // Last Sunday in April, at 2AM wall time\r\n    Calendar.SUNDAY, 2 * HOUR, DateTimeRule.WALL_TIME);\r\n    tzr = new AnnualTimeZoneRule(\"EDT\", -5 * HOUR, 1 * HOUR, dtr, 1967, 1973);\r\n    rbtz.addTransitionRule(tzr);\r\n    dtr = new // January 6, at 2AM wall time\r\n    DateTimeRule(// January 6, at 2AM wall time\r\n    Calendar.JANUARY, // January 6, at 2AM wall time\r\n    6, 2 * HOUR, DateTimeRule.WALL_TIME);\r\n    tzr = new AnnualTimeZoneRule(\"EDT\", -5 * HOUR, 1 * HOUR, dtr, 1974, 1974);\r\n    rbtz.addTransitionRule(tzr);\r\n    dtr = new // February 23, at 2AM wall time\r\n    DateTimeRule(// February 23, at 2AM wall time\r\n    Calendar.FEBRUARY, // February 23, at 2AM wall time\r\n    23, 2 * HOUR, DateTimeRule.WALL_TIME);\r\n    tzr = new AnnualTimeZoneRule(\"EDT\", -5 * HOUR, 1 * HOUR, dtr, 1975, 1975);\r\n    rbtz.addTransitionRule(tzr);\r\n    dtr = new // Last Sunday in April, at 2AM wall time\r\n    DateTimeRule(// Last Sunday in April, at 2AM wall time\r\n    Calendar.APRIL, // Last Sunday in April, at 2AM wall time\r\n    -1, // Last Sunday in April, at 2AM wall time\r\n    Calendar.SUNDAY, 2 * HOUR, DateTimeRule.WALL_TIME);\r\n    tzr = new AnnualTimeZoneRule(\"EDT\", -5 * HOUR, 1 * HOUR, dtr, 1976, 1986);\r\n    rbtz.addTransitionRule(tzr);\r\n    dtr = new // SUN>=1 in April, at 2AM wall time\r\n    DateTimeRule(// SUN>=1 in April, at 2AM wall time\r\n    Calendar.APRIL, // SUN>=1 in April, at 2AM wall time\r\n    1, // SUN>=1 in April, at 2AM wall time\r\n    Calendar.SUNDAY, // SUN>=1 in April, at 2AM wall time\r\n    true, 2 * HOUR, DateTimeRule.WALL_TIME);\r\n    tzr = new AnnualTimeZoneRule(\"EDT\", -5 * HOUR, 1 * HOUR, dtr, 1987, 2006);\r\n    rbtz.addTransitionRule(tzr);\r\n    dtr = new // SUN>=8 in March, at 2AM wall time\r\n    DateTimeRule(// SUN>=8 in March, at 2AM wall time\r\n    Calendar.MARCH, // SUN>=8 in March, at 2AM wall time\r\n    8, // SUN>=8 in March, at 2AM wall time\r\n    Calendar.SUNDAY, // SUN>=8 in March, at 2AM wall time\r\n    true, 2 * HOUR, DateTimeRule.WALL_TIME);\r\n    tzr = new AnnualTimeZoneRule(\"EDT\", -5 * HOUR, 1 * HOUR, dtr, 2007, AnnualTimeZoneRule.MAX_YEAR);\r\n    rbtz.addTransitionRule(tzr);\r\n    long jan1_1950 = getUTCMillis(1950, Calendar.JANUARY, 1);\r\n    long jan1_1967 = getUTCMillis(1971, Calendar.JANUARY, 1);\r\n    long jan1_2010 = getUTCMillis(2010, Calendar.JANUARY, 1);\r\n    if (!(((BasicTimeZone) ny).hasEquivalentTransitions(rbtz, jan1_1967, jan1_2010))) {\r\n        errln(\"FAIL: The RBTZ must be equivalent to America/New_York between 1967 and 2010\");\r\n    }\r\n    if (((BasicTimeZone) ny).hasEquivalentTransitions(rbtz, jan1_1950, jan1_2010)) {\r\n        errln(\"FAIL: The RBTZ must not be equivalent to America/New_York between 1950 and 2010\");\r\n    }\r\n    if (!rbtz.hasEquivalentTransitions(ny, jan1_1967, jan1_2010)) {\r\n        errln(\"FAIL: The RBTZ must be equivalent to America/New_York between 1967 and 2010\");\r\n    }\r\n    if (rbtz.hasEquivalentTransitions(ny, jan1_1950, jan1_2010)) {\r\n        errln(\"FAIL: The RBTZ must not be equivalent to America/New_York between 1950 and 2010\");\r\n    }\r\n    if (ny.hasSameRules(rbtz) || rbtz.hasSameRules(ny)) {\r\n        errln(\"FAIL: hasSameRules must return false\");\r\n    }\r\n    RuleBasedTimeZone rbtzc = (RuleBasedTimeZone) rbtz.clone();\r\n    if (!rbtz.hasSameRules(rbtzc) || !rbtz.hasEquivalentTransitions(rbtzc, jan1_1950, jan1_2010)) {\r\n        errln(\"FAIL: hasSameRules/hasEquivalentTransitions must return true for cloned RBTZs\");\r\n    }\r\n    long[] times = { getUTCMillis(2006, Calendar.MARCH, 15), getUTCMillis(2006, Calendar.NOVEMBER, 1), getUTCMillis(2007, Calendar.MARCH, 15), getUTCMillis(2007, Calendar.NOVEMBER, 1), getUTCMillis(2008, Calendar.MARCH, 15), getUTCMillis(2008, Calendar.NOVEMBER, 1) };\r\n    int[] offsets1 = new int[2];\r\n    int[] offsets2 = new int[2];\r\n    for (int i = 0; i < times.length; i++) {\r\n        rbtz.getOffset(times[i], false, offsets1);\r\n        ny.getOffset(times[i], false, offsets2);\r\n        if (offsets1[0] != offsets2[0] || offsets1[1] != offsets2[1]) {\r\n            errln(\"FAIL: Incompatible time zone offsets for ny and rbtz\");\r\n        }\r\n        Date d = new Date(times[i]);\r\n        if (rbtz.inDaylightTime(d) != ny.inDaylightTime(d)) {\r\n            errln(\"FAIL: Incompatible daylight saving time for ny and rbtz\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.Semaphore.getQueueLength",
	"Comment": "returns an estimate of the number of threads waiting to acquire.the value is only an estimate because the number of threads maychange dynamically while this method traverses internal datastructures.this method is designed for use in monitoringsystem state, not for synchronization control.",
	"Method": "int getQueueLength(){\r\n    return sync.getQueueLength();\r\n}"
}, {
	"Path": "sun.net.www.MessageHeader.prepend",
	"Comment": "prepends a key value pair to the beginning of theheader.duplicates are allowed",
	"Method": "void prepend(String k,String v){\r\n    grow();\r\n    for (int i = nkeys; i > 0; i--) {\r\n        keys[i] = keys[i - 1];\r\n        values[i] = values[i - 1];\r\n    }\r\n    keys[0] = k;\r\n    values[0] = v;\r\n    nkeys++;\r\n}"
}, {
	"Path": "java.security.cert.CertificateFactory.getCertPathEncodings",
	"Comment": "returns an iteration of the certpath encodings supportedby this certificate factory, with the default encoding first. seethe certpath encodings section in the java cryptography architecture standard algorithm name documentationfor information about standard encoding names and their formats.attempts to modify the returned iterator via itsremove method result in anunsupportedoperationexception.",
	"Method": "Iterator<String> getCertPathEncodings(){\r\n    return (certFacSpi.engineGetCertPathEncodings());\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testGetQueue",
	"Comment": "getqueue returns the work queue, which contains queued tasks",
	"Method": "void testGetQueue(){\r\n    final CountDownLatch done = new CountDownLatch(1);\r\n    final ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);\r\n    try (PoolCleaner cleaner = cleaner(p, done)) {\r\n        final CountDownLatch threadStarted = new CountDownLatch(1);\r\n        ScheduledFuture[] tasks = new ScheduledFuture[5];\r\n        for (int i = 0; i < tasks.length; i++) {\r\n            Runnable r = new CheckedRunnable() {\r\n                public void realRun() throws InterruptedException {\r\n                    threadStarted.countDown();\r\n                    await(done);\r\n                }\r\n            };\r\n            tasks[i] = p.schedule(r, 1, MILLISECONDS);\r\n        }\r\n        await(threadStarted);\r\n        BlockingQueue<Runnable> q = p.getQueue();\r\n        assertTrue(q.contains(tasks[tasks.length - 1]));\r\n        assertFalse(q.contains(tasks[0]));\r\n    }\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorTest.testGetQueue",
	"Comment": "getqueue returns the work queue, which contains queued tasks",
	"Method": "void testGetQueue(){\r\n    threadStarted.countDown();\r\n    await(done);\r\n}"
}, {
	"Path": "java.net.Inet6Address.isLoopbackAddress",
	"Comment": "utility routine to check if the inetaddress is a loopback address.",
	"Method": "boolean isLoopbackAddress(){\r\n    byte test = 0x00;\r\n    for (int i = 0; i < 15; i++) {\r\n        test |= ipaddress[i];\r\n    }\r\n    return (test == 0x00) && (ipaddress[15] == 0x01);\r\n}"
}, {
	"Path": "sun.nio.ch.InheritedChannel.createChannel",
	"Comment": "if standard inherited channel is connected to a socket then return a channelof the appropriate type based standard input.",
	"Method": "Channel createChannel(){\r\n    int fdVal = dup(0);\r\n    int st;\r\n    st = soType0(fdVal);\r\n    if (st != SOCK_STREAM && st != SOCK_DGRAM) {\r\n        close0(fdVal);\r\n        return null;\r\n    }\r\n    Class[] paramTypes = { int.class };\r\n    Constructor ctr = Reflect.lookupConstructor(\"java.io.FileDescriptor\", paramTypes);\r\n    Object[] args = { new Integer(fdVal) };\r\n    FileDescriptor fd = (FileDescriptor) Reflect.invoke(ctr, args);\r\n    SelectorProvider provider = SelectorProvider.provider();\r\n    assert provider instanceof sun.nio.ch.SelectorProviderImpl;\r\n    Channel c;\r\n    if (st == SOCK_STREAM) {\r\n        InetAddress ia = peerAddress0(fdVal);\r\n        if (ia == null) {\r\n            c = new InheritedServerSocketChannelImpl(provider, fd);\r\n        } else {\r\n            int port = peerPort0(fdVal);\r\n            assert port > 0;\r\n            InetSocketAddress isa = new InetSocketAddress(ia, port);\r\n            c = new InheritedSocketChannelImpl(provider, fd, isa);\r\n        }\r\n    } else {\r\n        c = new InheritedDatagramChannelImpl(provider, fd);\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "tests.util.SerializationTester.assertCompabilityEquals",
	"Comment": "tests the serialization compatibility with reference for instance\tobjects.",
	"Method": "boolean assertCompabilityEquals(Object obj,String fileName){\r\n    return obj.equals(readObject(obj, fileName));\r\n}"
}, {
	"Path": "java.util.concurrent.locks.ReentrantReadWriteLock.getQueueLength",
	"Comment": "returns an estimate of the number of threads waiting to acquireeither the read or write lock.the value is only an estimatebecause the number of threads may change dynamically while thismethod traverses internal data structures.this method isdesigned for use in monitoring system state, not forsynchronization control.",
	"Method": "int getQueueLength(){\r\n    return sync.getQueueLength();\r\n}"
}, {
	"Path": "jsr166.AtomicReferenceFieldUpdaterTest.testWeakCompareAndSet",
	"Comment": "repeated weakcompareandset succeeds in changing value when equalto expected",
	"Method": "void testWeakCompareAndSet(){\r\n    AtomicReferenceFieldUpdater<AtomicReferenceFieldUpdaterTest, Integer> a;\r\n    a = updaterFor(\"x\");\r\n    x = one;\r\n    do {\r\n    } while (!a.weakCompareAndSet(this, one, two));\r\n    do {\r\n    } while (!a.weakCompareAndSet(this, two, m4));\r\n    assertSame(m4, a.get(this));\r\n    do {\r\n    } while (!a.weakCompareAndSet(this, m4, seven));\r\n    assertSame(seven, a.get(this));\r\n}"
}, {
	"Path": "android.icu.dev.test.UTF16Util.setCodePointAt",
	"Comment": "method setcodepointat. changes a code point at agiven index. can change the length of the string.",
	"Method": "int setCodePointAt(StringBuffer buffer,int i,int ch){\r\n    int cp = nextCodePoint(buffer, i);\r\n    if (ch <= 0xffff && cp <= 0xffff) {\r\n        buffer.setCharAt(i, (char) ch);\r\n        return 0;\r\n    } else if (ch > 0xffff && cp > 0xffff) {\r\n        buffer.setCharAt(i, (char) (0xd7c0 + (ch >> 10)));\r\n        buffer.setCharAt(i + 1, (char) (0xdc00 + (ch & 0x3ff)));\r\n        return 0;\r\n    } else if (ch <= 0xffff && cp > 0xffff) {\r\n        buffer.setCharAt(i, (char) ch);\r\n        buffer.deleteCharAt(i + 1);\r\n        return -1;\r\n    } else {\r\n        buffer.setCharAt(i, (char) (0xd7c0 + (ch >> 10)));\r\n        buffer.insert(i + 1, (char) (0xdc00 + (ch & 0x3ff)));\r\n        return 1;\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ForkJoinPool.deregisterWorker",
	"Comment": "final callback from terminating worker, as well as upon failureto construct or start a worker.removes record of worker fromarray, and adjusts counts. if pool is shutting down, tries tocomplete termination.",
	"Method": "void deregisterWorker(ForkJoinWorkerThread wt,Throwable ex){\r\n    WorkQueue w = null;\r\n    if (wt != null && (w = wt.workQueue) != null) {\r\n        AuxState aux;\r\n        WorkQueue[] ws;\r\n        int idx = w.config & SMASK;\r\n        int ns = w.nsteals;\r\n        if ((aux = auxState) != null) {\r\n            aux.lock();\r\n            try {\r\n                if ((ws = workQueues) != null && ws.length > idx && ws[idx] == w)\r\n                    ws[idx] = null;\r\n                aux.stealCount += ns;\r\n            } finally {\r\n                aux.unlock();\r\n            }\r\n        }\r\n    }\r\n    if (w == null || (w.config & UNREGISTERED) == 0) {\r\n        long c;\r\n        do {\r\n        } while (!U.compareAndSwapLong(this, CTL, c = ctl, ((AC_MASK & (c - AC_UNIT)) | (TC_MASK & (c - TC_UNIT)) | (SP_MASK & c))));\r\n    }\r\n    if (w != null) {\r\n        w.currentSteal = null;\r\n        w.qlock = -1;\r\n        w.cancelAll();\r\n    }\r\n    while (tryTerminate(false, false) >= 0) {\r\n        WorkQueue[] ws;\r\n        int wl, sp;\r\n        long c;\r\n        if (w == null || w.array == null || (ws = workQueues) == null || (wl = ws.length) <= 0)\r\n            break;\r\n        else if ((sp = (int) (c = ctl)) != 0) {\r\n            if (tryRelease(c, ws[(wl - 1) & sp], AC_UNIT))\r\n                break;\r\n        } else if (ex != null && (c & ADD_WORKER) != 0L) {\r\n            tryAddWorker(c);\r\n            break;\r\n        } else\r\n            break;\r\n    }\r\n    if (ex == null)\r\n        ForkJoinTask.helpExpungeStaleExceptions();\r\n    else\r\n        ForkJoinTask.rethrow(ex);\r\n}"
}, {
	"Path": "org.xml.sax.helpers.XMLReaderFactory.createXMLReader",
	"Comment": "attempt to create an xml reader from a class name.given a class name, this method attempts to loadand instantiate the class as an xml reader.",
	"Method": "XMLReader createXMLReader(XMLReader createXMLReader,String className){\r\n    return loadClass(NewInstance.getClassLoader(), className);\r\n}"
}, {
	"Path": "java.util.concurrent.CopyOnWriteArraySet.clear",
	"Comment": "removes all of the elements from this set.the set will be empty after this call returns.",
	"Method": "void clear(){\r\n    al.clear();\r\n}"
}, {
	"Path": "sun.security.x509.CertificateVersion.encode",
	"Comment": "encode the certificateversion period in der form to the stream.",
	"Method": "void encode(OutputStream out){\r\n    if (version == V1) {\r\n        return;\r\n    }\r\n    DerOutputStream tmp = new DerOutputStream();\r\n    tmp.putInteger(version);\r\n    DerOutputStream seq = new DerOutputStream();\r\n    seq.write(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte) 0), tmp);\r\n    out.write(seq.toByteArray());\r\n}"
}, {
	"Path": "jsr166.TimeUnitTest.testToMinutes",
	"Comment": "tominutes correctly converts sample values in different units tominutes",
	"Method": "void testToMinutes(){\r\n    for (long t = 0; t < 88888; ++t) {\r\n        assertEquals(t * 60 * 24, DAYS.toMinutes(t));\r\n        assertEquals(t * 60, HOURS.toMinutes(t));\r\n        assertEquals(t, MINUTES.toMinutes(t));\r\n        assertEquals(t, SECONDS.toMinutes(t * 60));\r\n        assertEquals(t, MILLISECONDS.toMinutes(t * 1000L * 60));\r\n        assertEquals(t, MICROSECONDS.toMinutes(t * 1000000L * 60));\r\n        assertEquals(t, NANOSECONDS.toMinutes(t * 1000000000L * 60));\r\n    }\r\n}"
}, {
	"Path": "java.security.cert.CertPath.writeReplace",
	"Comment": "replaces the certpath to be serialized with acertpathrep object.",
	"Method": "Object writeReplace(){\r\n    try {\r\n        return new CertPathRep(type, getEncoded());\r\n    } catch (CertificateException ce) {\r\n        NotSerializableException nse = new NotSerializableException(\"java.security.cert.CertPath: \" + type);\r\n        nse.initCause(ce);\r\n        throw nse;\r\n    }\r\n}"
}, {
	"Path": "java.security.KeyStore.isCertificateEntry",
	"Comment": "returns true if the entry identified by the given aliaswas created by a call to setcertificateentry,or created by a call to setentry with atrustedcertificateentry.",
	"Method": "boolean isCertificateEntry(String alias){\r\n    if (!initialized) {\r\n        throw new KeyStoreException(\"Uninitialized keystore\");\r\n    }\r\n    return keyStoreSpi.engineIsCertificateEntry(alias);\r\n}"
}, {
	"Path": "java.util.zip.GZIPInputStream.skipBytes",
	"Comment": "skips bytes of input data blocking until all bytes are skipped.does not assume that the input stream is capable of seeking.",
	"Method": "void skipBytes(InputStream in,int n){\r\n    while (n > 0) {\r\n        int len = in.read(tmpbuf, 0, n < tmpbuf.length ? n : tmpbuf.length);\r\n        if (len == -1) {\r\n            throw new EOFException();\r\n        }\r\n        n -= len;\r\n    }\r\n}"
}, {
	"Path": "sun.util.calendar.JulianCalendar.getYearFromFixedDate",
	"Comment": "returns the normalized julian year number of the given fixed date.",
	"Method": "int getYearFromFixedDate(long fixedDate){\r\n    int year = (int) CalendarUtils.floorDivide(4 * (fixedDate - JULIAN_EPOCH) + 1464, 1461);\r\n    return year;\r\n}"
}, {
	"Path": "java.util.concurrent.atomic.AtomicStampedReference.set",
	"Comment": "unconditionally sets the value of both the reference and stamp.",
	"Method": "void set(V newReference,int newStamp){\r\n    Pair<V> current = pair;\r\n    if (newReference != current.reference || newStamp != current.stamp)\r\n        this.pair = Pair.of(newReference, newStamp);\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedLongSynchronizer.fullGetFirstQueuedThread",
	"Comment": "version of getfirstqueuedthread called when fastpath fails.",
	"Method": "Thread fullGetFirstQueuedThread(){\r\n    Node h, s;\r\n    Thread st;\r\n    if (((h = head) != null && (s = h.next) != null && s.prev == head && (st = s.thread) != null) || ((h = head) != null && (s = h.next) != null && s.prev == head && (st = s.thread) != null))\r\n        return st;\r\n    Thread firstThread = null;\r\n    for (Node p = tail; p != null && p != head; p = p.prev) {\r\n        Thread t = p.thread;\r\n        if (t != null)\r\n            firstThread = t;\r\n    }\r\n    return firstThread;\r\n}"
}, {
	"Path": "sun.security.x509.BasicConstraintsExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(IS_CA);\r\n    elements.addElement(PATH_LEN);\r\n    return (elements.elements());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.gen.GenerationUnit.addPackageJavadoc",
	"Comment": "collect javadoc from the package declarations to display in the header.",
	"Method": "void addPackageJavadoc(CompilationUnit unit,String qualifiedMainType){\r\n    Javadoc javadoc = unit.getPackage().getJavadoc();\r\n    if (javadoc == null) {\r\n        return;\r\n    }\r\n    SourceBuilder builder = new SourceBuilder(false);\r\n    JavadocGenerator.printDocComment(builder, javadoc);\r\n    javadocBlocks.put(qualifiedMainType, builder.toString());\r\n}"
}, {
	"Path": "sun.security.provider.certpath.DistributionPointFetcher.getFullNames",
	"Comment": "append relative name to the issuer name and return a newgeneralnames object.",
	"Method": "GeneralNames getFullNames(X500Name issuer,RDN rdn){\r\n    List<RDN> rdns = new ArrayList(issuer.rdns());\r\n    rdns.add(rdn);\r\n    X500Name fullName = new X500Name(rdns.toArray(new RDN[0]));\r\n    GeneralNames fullNames = new GeneralNames();\r\n    fullNames.add(new GeneralName(fullName));\r\n    return fullNames;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getExtensionObject",
	"Comment": "returns an extension object given any x509certificate and extension oid.throw an ioexception if the extension byte value ismalformed.",
	"Method": "Extension getExtensionObject(X509Certificate cert,int extId){\r\n    if (cert instanceof X509CertImpl) {\r\n        X509CertImpl impl = (X509CertImpl) cert;\r\n        switch(extId) {\r\n            case PRIVATE_KEY_USAGE_ID:\r\n                return impl.getPrivateKeyUsageExtension();\r\n            case SUBJECT_ALT_NAME_ID:\r\n                return impl.getSubjectAlternativeNameExtension();\r\n            case NAME_CONSTRAINTS_ID:\r\n                return impl.getNameConstraintsExtension();\r\n            case CERT_POLICIES_ID:\r\n                return impl.getCertificatePoliciesExtension();\r\n            case EXTENDED_KEY_USAGE_ID:\r\n                return impl.getExtendedKeyUsageExtension();\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n    byte[] rawExtVal = cert.getExtensionValue(EXTENSION_OIDS[extId]);\r\n    if (rawExtVal == null) {\r\n        return null;\r\n    }\r\n    DerInputStream in = new DerInputStream(rawExtVal);\r\n    byte[] encoded = in.getOctetString();\r\n    switch(extId) {\r\n        case PRIVATE_KEY_USAGE_ID:\r\n            try {\r\n                return new PrivateKeyUsageExtension(FALSE, encoded);\r\n            } catch (CertificateException ex) {\r\n                throw new IOException(ex.getMessage());\r\n            }\r\n        case SUBJECT_ALT_NAME_ID:\r\n            return new SubjectAlternativeNameExtension(FALSE, encoded);\r\n        case NAME_CONSTRAINTS_ID:\r\n            return new NameConstraintsExtension(FALSE, encoded);\r\n        case CERT_POLICIES_ID:\r\n            return new CertificatePoliciesExtension(FALSE, encoded);\r\n        case EXTENDED_KEY_USAGE_ID:\r\n            return new ExtendedKeyUsageExtension(FALSE, encoded);\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.locks.AbstractQueuedSynchronizer.transferAfterCancelledWait",
	"Comment": "transfers node, if necessary, to sync queue after a cancelled wait.returns true if thread was cancelled before being signalled.",
	"Method": "boolean transferAfterCancelledWait(Node node){\r\n    if (node.compareAndSetWaitStatus(Node.CONDITION, 0)) {\r\n        enq(node);\r\n        return true;\r\n    }\r\n    while (!isOnSyncQueue(node)) Thread.yield();\r\n    return false;\r\n}"
}, {
	"Path": "java.text.DecimalFormatSymbols.getZeroDigit",
	"Comment": "gets the character used for zero. different for arabic, etc.",
	"Method": "char getZeroDigit(){\r\n    return zeroDigit;\r\n}"
}, {
	"Path": "java.net.Inet6Address.getScopedInterface",
	"Comment": "returns the scoped interface, if this instance was created withwith a scoped interface.",
	"Method": "NetworkInterface getScopedInterface(){\r\n    return scope_ifname;\r\n}"
}, {
	"Path": "java.util.logging.Level.intValue",
	"Comment": "get the integer value for this level.this integer valuecan be used for efficient ordering comparisons betweenlevel objects.",
	"Method": "int intValue(){\r\n    return value;\r\n}"
}, {
	"Path": "java.security.MessageDigest.isEqual",
	"Comment": "compares two digests for equality. does a simple byte compare.",
	"Method": "boolean isEqual(byte[] digesta,byte[] digestb){\r\n    if (digesta.length != digestb.length) {\r\n        return false;\r\n    }\r\n    int result = 0;\r\n    for (int i = 0; i < digesta.length; i++) {\r\n        result |= digesta[i] ^ digestb[i];\r\n    }\r\n    return result == 0;\r\n}"
}, {
	"Path": "java.util.zip.Inflater.finished",
	"Comment": "returns true if the end of the compressed data stream has beenreached.",
	"Method": "boolean finished(){\r\n    synchronized (zsRef) {\r\n        return finished;\r\n    }\r\n}"
}, {
	"Path": "javax.net.ssl.SSLSessionBindingEvent.getName",
	"Comment": "returns the name to which the object is being bound, or the namefrom which the object is being unbound.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "java.security.cert.X509CertSelector.getSubjectKeyIdentifier",
	"Comment": "returns the subjectkeyidentifier criterion. thex509certificate must contain a subjectkeyidentifierextension with the specified value. if null, nosubjectkeyidentifier check will be done.note that the byte array returned is cloned to protect againstsubsequent modifications.",
	"Method": "byte[] getSubjectKeyIdentifier(){\r\n    if (subjectKeyID == null) {\r\n        return null;\r\n    }\r\n    return subjectKeyID.clone();\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testGetQueue",
	"Comment": "getqueue returns the work queue, which contains queued tasks",
	"Method": "void testGetQueue(){\r\n    final CountDownLatch done = new CountDownLatch(1);\r\n    final BlockingQueue<Runnable> q = new ArrayBlockingQueue<Runnable>(10);\r\n    final ThreadPoolExecutor p = new CustomTPE(1, 1, LONG_DELAY_MS, MILLISECONDS, q);\r\n    try (PoolCleaner cleaner = cleaner(p, done)) {\r\n        final CountDownLatch threadStarted = new CountDownLatch(1);\r\n        FutureTask[] tasks = new FutureTask[5];\r\n        for (int i = 0; i < tasks.length; i++) {\r\n            Callable task = new CheckedCallable<Boolean>() {\r\n                public Boolean realCall() throws InterruptedException {\r\n                    threadStarted.countDown();\r\n                    assertSame(q, p.getQueue());\r\n                    await(done);\r\n                    return Boolean.TRUE;\r\n                }\r\n            };\r\n            tasks[i] = new FutureTask(task);\r\n            p.execute(tasks[i]);\r\n        }\r\n        await(threadStarted);\r\n        assertSame(q, p.getQueue());\r\n        assertFalse(q.contains(tasks[0]));\r\n        assertTrue(q.contains(tasks[tasks.length - 1]));\r\n        assertEquals(tasks.length - 1, q.size());\r\n    }\r\n}"
}, {
	"Path": "jsr166.ThreadPoolExecutorSubclassTest.testGetQueue",
	"Comment": "getqueue returns the work queue, which contains queued tasks",
	"Method": "void testGetQueue(){\r\n    threadStarted.countDown();\r\n    assertSame(q, p.getQueue());\r\n    await(done);\r\n    return Boolean.TRUE;\r\n}"
}, {
	"Path": "java.time.LocalTime.create",
	"Comment": "creates a local time from the hour, minute, second and nanosecond fields.this factory may return a cached value, but applications must not rely on this.",
	"Method": "LocalTime create(int hour,int minute,int second,int nanoOfSecond){\r\n    if ((minute | second | nanoOfSecond) == 0) {\r\n        return HOURS[hour];\r\n    }\r\n    return new LocalTime(hour, minute, second, nanoOfSecond);\r\n}"
}, {
	"Path": "java.text.FieldPosition.getBeginIndex",
	"Comment": "retrieves the index of the first character in the requested field.",
	"Method": "int getBeginIndex(){\r\n    return beginIndex;\r\n}"
}, {
	"Path": "java.math.BigDecimal.needIncrement",
	"Comment": "tests if quotient has to be incremented according the roundingmode",
	"Method": "boolean needIncrement(long ldivisor,int roundingMode,int qsign,long q,long r,boolean needIncrement,long ldivisor,int roundingMode,int qsign,MutableBigInteger mq,long r,boolean needIncrement,MutableBigInteger mdivisor,int roundingMode,int qsign,MutableBigInteger mq,MutableBigInteger mr){\r\n    assert !mr.isZero();\r\n    int cmpFracHalf = mr.compareHalf(mdivisor);\r\n    return commonNeedIncrement(roundingMode, qsign, cmpFracHalf, mq.isOdd());\r\n}"
}, {
	"Path": "java.time.Duration.plusNanos",
	"Comment": "returns a copy of this duration with the specified duration in nanoseconds added.this instance is immutable and unaffected by this method call.",
	"Method": "Duration plusNanos(long nanosToAdd){\r\n    return plus(0, nanosToAdd);\r\n}"
}, {
	"Path": "java.util.function.LongUnaryOperator.identity",
	"Comment": "returns a unary operator that always returns its input argument.",
	"Method": "LongUnaryOperator identity(){\r\n    return t -> t;\r\n}"
}, {
	"Path": "java.net.NetworkInterface.equals",
	"Comment": "compares this object against the specified object.the result is true if and only if the argument isnot null and it represents the same networkinterfaceas this object.two instances of networkinterface represent the samenetworkinterface if both name and addrs are the same for both.",
	"Method": "boolean equals(Object obj){\r\n    if (!(obj instanceof NetworkInterface)) {\r\n        return false;\r\n    }\r\n    NetworkInterface that = (NetworkInterface) obj;\r\n    if (this.name != null) {\r\n        if (!this.name.equals(that.name)) {\r\n            return false;\r\n        }\r\n    } else {\r\n        if (that.name != null) {\r\n            return false;\r\n        }\r\n    }\r\n    if (this.addrs == null) {\r\n        return that.addrs == null;\r\n    } else if (that.addrs == null) {\r\n        return false;\r\n    }\r\n    if (this.addrs.length != that.addrs.length) {\r\n        return false;\r\n    }\r\n    InetAddress[] thatAddrs = that.addrs;\r\n    int count = thatAddrs.length;\r\n    for (int i = 0; i < count; i++) {\r\n        boolean found = false;\r\n        for (int j = 0; j < count; j++) {\r\n            if (addrs[i].equals(thatAddrs[j])) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "android.icu.dev.test.TestFmwk.checkArray",
	"Comment": "check the given array to see that all the locales in the expected arrayare present.",
	"Method": "int checkArray(String msg,String array,String expected,int checkArray,String msg,Locale array,String expected,int checkArray,String msg,ULocale array,String expected){\r\n    String[] strs = new String[array.length];\r\n    for (int i = 0; i < array.length; ++i) {\r\n        strs[i] = array[i].toString();\r\n    }\r\n    return checkArray(msg, strs, expected);\r\n}"
}, {
	"Path": "org.xml.sax.helpers.XMLFilterImpl.getFeature",
	"Comment": "look up the value of a feature.this will always fail if the parent is null.",
	"Method": "boolean getFeature(String name){\r\n    if (parent != null) {\r\n        return parent.getFeature(name);\r\n    } else {\r\n        throw new SAXNotRecognizedException(\"Feature: \" + name);\r\n    }\r\n}"
}, {
	"Path": "java.time.format.DecimalStyle.equals",
	"Comment": "checks if this decimalstyle is equal to another decimalstyle.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof DecimalStyle) {\r\n        DecimalStyle other = (DecimalStyle) obj;\r\n        return (zeroDigit == other.zeroDigit && positiveSign == other.positiveSign && negativeSign == other.negativeSign && decimalSeparator == other.decimalSeparator);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.regression.LambdaExpressionsTest.test448802",
	"Comment": "interleaved by a impertinent lambda may need some more changes,",
	"Method": "void test448802(){\r\n    this.runConformTest(new String[] { \"X.java\", \"import java.util.Optional;\\n\" + \"public class X {\\n\" + \" public static void main(String[] args) {\\n\" + \"   Optional<String> userName = Optional.of(\\\"sa\\\");\\n\" + \"   Optional<String> password = Optional.of(\\\"sa\\\");\\n\" + \"   boolean isValid = userName.flatMap((String u) -> {\\n\" + \"     return password.map((String p) -> {\\n\" + \"       return u.equals(\\\"sa\\\") && p.equals(\\\"sa\\\");\\n\" + \"     });\\n\" + \"   }).orElse(false);\\n\" + \"   System.out.println(isValid);\\n\" + \" }\\n\" + \"}\\n\" }, \"true\");\r\n}"
}, {
	"Path": "java.net.Inet6Address.isAnyLocalAddress",
	"Comment": "utility routine to check if the inetaddress in a wildcard address.",
	"Method": "boolean isAnyLocalAddress(){\r\n    byte test = 0x00;\r\n    for (int i = 0; i < INADDRSZ; i++) {\r\n        test |= ipaddress[i];\r\n    }\r\n    return (test == 0x00);\r\n}"
}, {
	"Path": "sun.security.provider.certpath.OCSP.initializeTimeout",
	"Comment": "initialize the timeout length by getting the ocsp timeoutsystem property. if the property has not been set, or if itsvalue is negative, set the timeout length to the default.",
	"Method": "int initializeTimeout(){\r\n    Integer tmp = Integer.getInteger(\"com.sun.security.ocsp.timeout\");\r\n    if (tmp == null || tmp < 0) {\r\n        return DEFAULT_CONNECT_TIMEOUT;\r\n    }\r\n    return tmp * 1000;\r\n}"
}, {
	"Path": "jsr166.ScheduledExecutorSubclassTest.testShutdownNow_delayedTasks",
	"Comment": "shutdownnow returns a list containing tasks that were not run,and those tasks are drained from the queue",
	"Method": "void testShutdownNow_delayedTasks(){\r\n    final CustomExecutor p = new CustomExecutor(1);\r\n    List<ScheduledFuture> tasks = new ArrayList();\r\n    for (int i = 0; i < 3; i++) {\r\n        Runnable r = new NoOpRunnable();\r\n        tasks.add(p.schedule(r, 9, SECONDS));\r\n        tasks.add(p.scheduleAtFixedRate(r, 9, 9, SECONDS));\r\n        tasks.add(p.scheduleWithFixedDelay(r, 9, 9, SECONDS));\r\n    }\r\n    if (testImplementationDetails)\r\n        assertEquals(new HashSet(tasks), new HashSet(p.getQueue()));\r\n    final List<Runnable> queuedTasks;\r\n    try {\r\n        queuedTasks = p.shutdownNow();\r\n    } catch (SecurityException ok) {\r\n        return;\r\n    }\r\n    assertTrue(p.isShutdown());\r\n    assertTrue(p.getQueue().isEmpty());\r\n    if (testImplementationDetails)\r\n        assertEquals(new HashSet(tasks), new HashSet(queuedTasks));\r\n    assertEquals(tasks.size(), queuedTasks.size());\r\n    for (ScheduledFuture task : tasks) {\r\n        assertFalse(((CustomTask) task).ran);\r\n        assertFalse(task.isDone());\r\n        assertFalse(task.isCancelled());\r\n    }\r\n    assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));\r\n    assertTrue(p.isTerminated());\r\n}"
}, {
	"Path": "tests.support.Support_StringReader.isOpen",
	"Comment": "answer a boolean indicating whether or not this stringreader is open.",
	"Method": "boolean isOpen(){\r\n    return str != null;\r\n}"
}, {
	"Path": "java.util.Date.getMillisOf",
	"Comment": "returns the millisecond value of this date objectwithout affecting its internal state.",
	"Method": "long getMillisOf(Date date){\r\n    if (date.cdate == null || date.cdate.isNormalized()) {\r\n        return date.fastTime;\r\n    }\r\n    BaseCalendar.Date d = (BaseCalendar.Date) date.cdate.clone();\r\n    return GcalHolder.INSTANCE.getTime(d);\r\n}"
}, {
	"Path": "sun.security.provider.certpath.X509CertificatePair.toString",
	"Comment": "return a printable representation of the certificate pair.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"X.509 Certificate Pair: [\\n\");\r\n    if (forward != null)\r\n        sb.append(\"  Forward: \").append(forward).append(\"\\n\");\r\n    if (reverse != null)\r\n        sb.append(\"  Reverse: \").append(reverse).append(\"\\n\");\r\n    sb.append(\"]\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "sun.util.logging.PlatformLogger.redirectToJavaLoggerProxy",
	"Comment": "creates a new javaloggerproxy and redirects the platform logger to it",
	"Method": "void redirectToJavaLoggerProxy(){\r\n    DefaultLoggerProxy lp = DefaultLoggerProxy.class.cast(this.loggerProxy);\r\n    JavaLoggerProxy jlp = new JavaLoggerProxy(lp.name, lp.level);\r\n    this.javaLoggerProxy = jlp;\r\n    this.loggerProxy = jlp;\r\n}"
}, {
	"Path": "jsr166.AtomicIntegerTest.testAddAndGet",
	"Comment": "addandget adds given value to current, and returns current value",
	"Method": "void testAddAndGet(){\r\n    AtomicInteger ai = new AtomicInteger(1);\r\n    assertEquals(3, ai.addAndGet(2));\r\n    assertEquals(3, ai.get());\r\n    assertEquals(-1, ai.addAndGet(-4));\r\n    assertEquals(-1, ai.get());\r\n}"
}, {
	"Path": "java.security.spec.ECFieldFp.equals",
	"Comment": "compares this prime finite field for equality with thespecified object.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj)\r\n        return true;\r\n    if (obj instanceof ECFieldFp) {\r\n        return (p.equals(((ECFieldFp) obj).p));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "sun.security.x509.InvalidityDateExtension.getElements",
	"Comment": "return an enumeration of names of attributes existing within thisattribute.",
	"Method": "Enumeration<String> getElements(){\r\n    AttributeNameEnumeration elements = new AttributeNameEnumeration();\r\n    elements.addElement(DATE);\r\n    return elements.elements();\r\n}"
}, {
	"Path": "java.util.zip.Deflater.getBytesRead",
	"Comment": "returns the total number of uncompressed bytes input so far.",
	"Method": "long getBytesRead(){\r\n    synchronized (zsRef) {\r\n        ensureOpen();\r\n        return bytesRead;\r\n    }\r\n}"
}]