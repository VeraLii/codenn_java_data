[{
	"Path": "org.apache.xpath.res.XPATHMessages.createXPATHWarning",
	"Comment": "creates a message from the specified key and replacementarguments, localized to the given locale.",
	"Method": "String createXPATHWarning(String msgKey,Object args){\r\n    return createXPATHMsg(XPATHBundle, msgKey, args);\r\n}"
}, {
	"Path": "org.java_websocket.WebSocketImpl.generateHttpResponseDueToError",
	"Comment": "generate a simple response for the corresponding endpoint to indicate some error",
	"Method": "ByteBuffer generateHttpResponseDueToError(int errorCode){\r\n    String errorCodeDescription;\r\n    switch(errorCode) {\r\n        case 404:\r\n            errorCodeDescription = \"404 WebSocket Upgrade Failure\";\r\n            break;\r\n        case 500:\r\n        default:\r\n            errorCodeDescription = \"500 Internal Server Error\";\r\n    }\r\n    return ByteBuffer.wrap(Charsetfunctions.asciiBytes(\"HTTP/1.1 \" + errorCodeDescription + \"\\r\\nContent-Type: text/html\\nServer: TooTallNate Java-WebSocket\\r\\nContent-Length: \" + (48 + errorCodeDescription.length()) + \"\\r\\n\\r\\n<html><head><\/head><body><h1>\" + errorCodeDescription + \"<\/h1><\/body><\/html>\"));\r\n}"
}, {
	"Path": "com.sun.jna.contrib.demo.BalloonManager.getBalloon",
	"Comment": "get a balloon pointing to the given location.the coordinates are relative to owner, which if null, indicates the coordinatesare absolute.",
	"Method": "Popup getBalloon(Component owner,Component content,int x,int y){\r\n    final Point origin = owner == null ? new Point(0, 0) : (owner.isShowing() ? owner.getLocationOnScreen() : owner.getLocation());\r\n    final Window parent = owner != null ? SwingUtilities.getWindowAncestor(owner) : null;\r\n    origin.translate(x, y);\r\n    return new Popup() {\r\n        private BubbleWindow w;\r\n        public void show() {\r\n            w = new BubbleWindow(parent, content);\r\n            w.pack();\r\n            Point where = new Point(origin);\r\n            where.translate(-w.getWidth() / 3, -w.getHeight());\r\n            w.setAnchorLocation(where.x, where.y);\r\n            w.setVisible(true);\r\n        }\r\n        public void hide() {\r\n            w.setVisible(false);\r\n            w.dispose();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jna.contrib.demo.BalloonManager.getBalloon",
	"Comment": "get a balloon pointing to the given location.the coordinates are relative to owner, which if null, indicates the coordinatesare absolute.",
	"Method": "Popup getBalloon(Component owner,Component content,int x,int y){\r\n    w = new BubbleWindow(parent, content);\r\n    w.pack();\r\n    Point where = new Point(origin);\r\n    where.translate(-w.getWidth() / 3, -w.getHeight());\r\n    w.setAnchorLocation(where.x, where.y);\r\n    w.setVisible(true);\r\n}"
}, {
	"Path": "com.sun.jna.contrib.demo.BalloonManager.getBalloon",
	"Comment": "get a balloon pointing to the given location.the coordinates are relative to owner, which if null, indicates the coordinatesare absolute.",
	"Method": "Popup getBalloon(Component owner,Component content,int x,int y){\r\n    w.setVisible(false);\r\n    w.dispose();\r\n}"
}, {
	"Path": "redis.clients.jedis.BinaryJedis.flushAll",
	"Comment": "delete all the keys of all the existing databases, not just the currently selected one. thiscommand never fails.",
	"Method": "String flushAll(){\r\n    checkIsInMultiOrPipeline();\r\n    client.flushAll();\r\n    return client.getStatusCodeReply();\r\n}"
}, {
	"Path": "com.iluwatar.observer.WeatherObserverTest.testObserver",
	"Comment": "verify if the weather has the expected influence on the observer",
	"Method": "void testObserver(WeatherType weather,String response){\r\n    final O observer = this.factory.get();\r\n    assertEquals(0, appender.getLogSize());\r\n    observer.update(weather);\r\n    assertEquals(response, appender.getLastMessage());\r\n    assertEquals(1, appender.getLogSize());\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XObject.numWithSideEffects",
	"Comment": "cast result object to a number, but allow side effects, such as the incrementing of an iterator.",
	"Method": "double numWithSideEffects(){\r\n    return num();\r\n}"
}, {
	"Path": "hudson.PluginManager.parseRequestedPlugins",
	"Comment": "parses configuration xml files and picks up references to xml files.",
	"Method": "Map<String, VersionNumber> parseRequestedPlugins(InputStream configXml){\r\n    final Map<String, VersionNumber> requestedPlugins = new TreeMap<String, VersionNumber>();\r\n    try {\r\n        SAXParserFactory.newInstance().newSAXParser().parse(configXml, new DefaultHandler() {\r\n            @Override\r\n            public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\r\n                String plugin = attributes.getValue(\"plugin\");\r\n                if (plugin == null) {\r\n                    return;\r\n                }\r\n                if (!plugin.matches(\"[^@]+@[^@]+\")) {\r\n                    throw new SAXException(\"Malformed plugin attribute: \" + plugin);\r\n                }\r\n                int at = plugin.indexOf('@');\r\n                String shortName = plugin.substring(0, at);\r\n                VersionNumber existing = requestedPlugins.get(shortName);\r\n                VersionNumber requested = new VersionNumber(plugin.substring(at + 1));\r\n                if (existing == null || existing.compareTo(requested) < 0) {\r\n                    requestedPlugins.put(shortName, requested);\r\n                }\r\n            }\r\n            @Override\r\n            public InputSource resolveEntity(String publicId, String systemId) throws IOException, SAXException {\r\n                return RestrictiveEntityResolver.INSTANCE.resolveEntity(publicId, systemId);\r\n            }\r\n        });\r\n    } catch (SAXException x) {\r\n        throw new IOException(\"Failed to parse XML\", x);\r\n    } catch (ParserConfigurationException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n    return requestedPlugins;\r\n}"
}, {
	"Path": "hudson.PluginManager.parseRequestedPlugins",
	"Comment": "parses configuration xml files and picks up references to xml files.",
	"Method": "Map<String, VersionNumber> parseRequestedPlugins(InputStream configXml){\r\n    String plugin = attributes.getValue(\"plugin\");\r\n    if (plugin == null) {\r\n        return;\r\n    }\r\n    if (!plugin.matches(\"[^@]+@[^@]+\")) {\r\n        throw new SAXException(\"Malformed plugin attribute: \" + plugin);\r\n    }\r\n    int at = plugin.indexOf('@');\r\n    String shortName = plugin.substring(0, at);\r\n    VersionNumber existing = requestedPlugins.get(shortName);\r\n    VersionNumber requested = new VersionNumber(plugin.substring(at + 1));\r\n    if (existing == null || existing.compareTo(requested) < 0) {\r\n        requestedPlugins.put(shortName, requested);\r\n    }\r\n}"
}, {
	"Path": "hudson.PluginManager.parseRequestedPlugins",
	"Comment": "parses configuration xml files and picks up references to xml files.",
	"Method": "Map<String, VersionNumber> parseRequestedPlugins(InputStream configXml){\r\n    return RestrictiveEntityResolver.INSTANCE.resolveEntity(publicId, systemId);\r\n}"
}, {
	"Path": "jenkins.util.MarkFindingOutputStreamTest.closeInTheMiddle",
	"Comment": "if a stream closes without completing a match, the partial match should be sent to the output.",
	"Method": "void closeInTheMiddle(){\r\n    write(\"foo\" + markHead);\r\n    m.close();\r\n    assertCount(0);\r\n    assertOutput(\"foo\" + markHead);\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncQname.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    int context = getArg0AsNode(xctxt);\r\n    XObject val;\r\n    if (DTM.NULL != context) {\r\n        DTM dtm = xctxt.getDTM(context);\r\n        String qname = dtm.getNodeNameX(context);\r\n        val = (null == qname) ? XString.EMPTYSTRING : new XString(qname);\r\n    } else {\r\n        val = XString.EMPTYSTRING;\r\n    }\r\n    return val;\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XString.toLowerCase",
	"Comment": "converts all of the characters in this string to lowercase using the rules of the default locale, which is returnedby locale.getdefault.",
	"Method": "XMLString toLowerCase(Locale locale,XMLString toLowerCase){\r\n    return new XString(str().toLowerCase());\r\n}"
}, {
	"Path": "hudson.model.DependencyGraphTest.testItemReadPermission",
	"Comment": "tests that all dependencies are found even when some projects have restricted visibility.",
	"Method": "void testItemReadPermission(){\r\n    jenkins.rebuildDependencyGraph();\r\n    try {\r\n        ACL.impersonate(ACL.SYSTEM);\r\n        AbstractProject up = (AbstractProject) jenkins.getItem(\"hiddenUpstream\");\r\n        assertNotNull(\"hiddenUpstream project not found\", up);\r\n        List<AbstractProject> down = jenkins.getDependencyGraph().getDownstream(up);\r\n        assertEquals(\"Should have one downstream project\", 1, down.size());\r\n    } finally {\r\n        SecurityContextHolder.clearContext();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.countAncestors",
	"Comment": "count the number of ancestors that a elemtemplateelement has.",
	"Method": "int countAncestors(ElemTemplateElement elem){\r\n    int count = 0;\r\n    while (null != elem) {\r\n        count++;\r\n        elem = elem.getParentElem();\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ObjectFactory.findJarServiceProviderName",
	"Comment": "find the name of service provider using jar service provider mechanism",
	"Method": "String findJarServiceProviderName(String factoryId){\r\n    SecuritySupport ss = SecuritySupport.getInstance();\r\n    String serviceId = SERVICES_PATH + factoryId;\r\n    InputStream is = null;\r\n    ClassLoader cl = findClassLoader();\r\n    is = ss.getResourceAsStream(cl, serviceId);\r\n    if (is == null) {\r\n        ClassLoader current = ObjectFactory.class.getClassLoader();\r\n        if (cl != current) {\r\n            cl = current;\r\n            is = ss.getResourceAsStream(cl, serviceId);\r\n        }\r\n    }\r\n    if (is == null) {\r\n        return null;\r\n    }\r\n    debugPrintln(\"found jar resource=\" + serviceId + \" using ClassLoader: \" + cl);\r\n    BufferedReader rd;\r\n    try {\r\n        rd = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n    } catch (java.io.UnsupportedEncodingException e) {\r\n        rd = new BufferedReader(new InputStreamReader(is));\r\n    }\r\n    String factoryClassName = null;\r\n    try {\r\n        factoryClassName = rd.readLine();\r\n    } catch (IOException x) {\r\n        return null;\r\n    } finally {\r\n        try {\r\n            rd.close();\r\n        } catch (IOException exc) {\r\n        }\r\n    }\r\n    if (factoryClassName != null && !\"\".equals(factoryClassName)) {\r\n        debugPrintln(\"found in resource, value=\" + factoryClassName);\r\n        return factoryClassName;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "hudson.tools.ToolInstallation.getHome",
	"Comment": "gets the home directory of this tool.the path can be in unix format as well as in windows format.must be absolute.",
	"Method": "String getHome(){\r\n    return home;\r\n}"
}, {
	"Path": "hudson.util.XStream2.getDefaultDriver",
	"Comment": "convenience method so we only have to change the driver in one placeif we switch to something new in the future",
	"Method": "HierarchicalStreamDriver getDefaultDriver(){\r\n    return new KXml2Driver();\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.setNewLine",
	"Comment": "sets the end of line characters to be used during serialization",
	"Method": "void setNewLine(char[] eolChars){\r\n    m_lineSep = eolChars;\r\n    m_lineSepLen = eolChars.length;\r\n}"
}, {
	"Path": "hudson.model.ParameterValue.isSensitive",
	"Comment": "returns whether the information contained in this parametervalue issensitive or security related. used to determine whether the valueprovided by this object should be masked in output.subclasses can override this to control the return value.",
	"Method": "boolean isSensitive(){\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FunctionDef1Arg.reportWrongNumberArgs",
	"Comment": "constructs and throws a wrongnumberargexception with the appropriatemessage for this function object.",
	"Method": "void reportWrongNumberArgs(){\r\n    throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_ZERO_OR_ONE, null));\r\n}"
}, {
	"Path": "hudson.search.SearchTest.findClosestSuggestedItem",
	"Comment": "this test verifies that if 2 search results are found with the samesearch name, that the one with the search query in the url is returned",
	"Method": "void findClosestSuggestedItem(){\r\n    final String query = \"foobar 123\";\r\n    final String searchName = \"sameDisplayName\";\r\n    SearchItem searchItemHit = new SearchItem() {\r\n        public SearchIndex getSearchIndex() {\r\n            return null;\r\n        }\r\n        public String getSearchName() {\r\n            return searchName;\r\n        }\r\n        public String getSearchUrl() {\r\n            return \"/job/\" + Util.rawEncode(query) + \"/\";\r\n        }\r\n    };\r\n    SearchItem searchItemNoHit = new SearchItem() {\r\n        public SearchIndex getSearchIndex() {\r\n            return null;\r\n        }\r\n        public String getSearchName() {\r\n            return searchName;\r\n        }\r\n        public String getSearchUrl() {\r\n            return \"/job/someotherJob/\";\r\n        }\r\n    };\r\n    SuggestedItem suggestedHit = new SuggestedItem(searchItemHit);\r\n    SuggestedItem suggestedNoHit = new SuggestedItem(searchItemNoHit);\r\n    ArrayList<SuggestedItem> list = new ArrayList<SuggestedItem>();\r\n    list.add(suggestedNoHit);\r\n    list.add(suggestedHit);\r\n    SuggestedItem found = Search.findClosestSuggestedItem(list, query);\r\n    assertEquals(searchItemHit, found.item);\r\n    SuggestedItem found2 = Search.findClosestSuggestedItem(list, \"abcd\");\r\n    assertEquals(searchItemNoHit, found2.item);\r\n}"
}, {
	"Path": "hudson.search.SearchTest.findClosestSuggestedItem",
	"Comment": "this test verifies that if 2 search results are found with the samesearch name, that the one with the search query in the url is returned",
	"Method": "void findClosestSuggestedItem(){\r\n    return null;\r\n}"
}, {
	"Path": "hudson.search.SearchTest.findClosestSuggestedItem",
	"Comment": "this test verifies that if 2 search results are found with the samesearch name, that the one with the search query in the url is returned",
	"Method": "void findClosestSuggestedItem(){\r\n    return searchName;\r\n}"
}, {
	"Path": "hudson.search.SearchTest.findClosestSuggestedItem",
	"Comment": "this test verifies that if 2 search results are found with the samesearch name, that the one with the search query in the url is returned",
	"Method": "void findClosestSuggestedItem(){\r\n    return \"/job/\" + Util.rawEncode(query) + \"/\";\r\n}"
}, {
	"Path": "hudson.search.SearchTest.findClosestSuggestedItem",
	"Comment": "this test verifies that if 2 search results are found with the samesearch name, that the one with the search query in the url is returned",
	"Method": "void findClosestSuggestedItem(){\r\n    return null;\r\n}"
}, {
	"Path": "hudson.search.SearchTest.findClosestSuggestedItem",
	"Comment": "this test verifies that if 2 search results are found with the samesearch name, that the one with the search query in the url is returned",
	"Method": "void findClosestSuggestedItem(){\r\n    return searchName;\r\n}"
}, {
	"Path": "hudson.search.SearchTest.findClosestSuggestedItem",
	"Comment": "this test verifies that if 2 search results are found with the samesearch name, that the one with the search query in the url is returned",
	"Method": "void findClosestSuggestedItem(){\r\n    return \"/job/someotherJob/\";\r\n}"
}, {
	"Path": "com.iluwatar.servicelocator.ServiceLocatorTest.testServiceCache",
	"Comment": "verify if we get the same cached instance when requesting the same service twice",
	"Method": "void testServiceCache(){\r\n    final String[] serviceNames = new String[] { \"jndi/serviceA\", \"jndi/serviceB\" };\r\n    for (final String serviceName : serviceNames) {\r\n        final Service service = ServiceLocator.getService(serviceName);\r\n        assertNotNull(service);\r\n        assertEquals(serviceName, service.getName());\r\n        assertTrue(service.getId() > 0);\r\n        assertSame(service, ServiceLocator.getService(serviceName));\r\n    }\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.isQuietingDown",
	"Comment": "returns true if jenkins is quieting down.no further jobs will be executed unless itcan be finished while other current pending buildsare still in progress.",
	"Method": "boolean isQuietingDown(){\r\n    return isQuietingDown;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.dom2dtm.DOM2DTMdefaultNamespaceDeclarationNode.setUserData",
	"Comment": "associate an object to a key on this node. the object can later beretrieved from this node by calling getuserdata with thesame key.",
	"Method": "Object setUserData(String key,Object data,UserDataHandler handler){\r\n    return getOwnerDocument().setUserData(key, data, handler);\r\n}"
}, {
	"Path": "hudson.model.ParameterDefinition.createValue",
	"Comment": "create a parameter value from a form submission.this method is invoked when the user fills in the parameter values in the html formand submits it to the server.",
	"Method": "ParameterValue createValue(StaplerRequest req,JSONObject jo,ParameterValue createValue,StaplerRequest req,ParameterValue createValue,CLICommand command,String value){\r\n    throw new AbortException(\"CLI parameter submission is not supported for the \" + getClass() + \" type. Please file a bug report for this\");\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.getNextPreceding",
	"Comment": "given a node handle, advance to the next node on the preceding axis.",
	"Method": "int getNextPreceding(int axisContextHandle,int nodeHandle){\r\n    nodeHandle &= NODEHANDLE_MASK;\r\n    while (nodeHandle > 1) {\r\n        nodeHandle--;\r\n        if (ATTRIBUTE_NODE == (nodes.readEntry(nodeHandle, 0) & 0xFFFF))\r\n            continue;\r\n        return (m_docHandle | nodes.specialFind(axisContextHandle, nodeHandle));\r\n    }\r\n    return NULL;\r\n}"
}, {
	"Path": "hudson.util.CopyOnWriteListTest.serialization",
	"Comment": "verify that the serialization form of list and copyonwritelist are the same.",
	"Method": "void serialization(){\r\n    XStream2 xs = new XStream2();\r\n    TestData td = new TestData();\r\n    String out = xs.toXML(td);\r\n    assertEquals(\"empty lists\", \"<hudson.util.CopyOnWriteListTest_-TestData>\" + \"<list1/><list2/><\/hudson.util.CopyOnWriteListTest_-TestData>\", out.replaceAll(\"\\\\s+\", \"\"));\r\n    TestData td2 = (TestData) xs.fromXML(out.toString());\r\n    assertTrue(td2.list1.isEmpty());\r\n    assertTrue(td2.list2.isEmpty());\r\n    td.list1.add(\"foobar1\");\r\n    td.list2.add(\"foobar2\");\r\n    out = xs.toXML(td);\r\n    assertEquals(\"lists\", \"<hudson.util.CopyOnWriteListTest_-TestData>\" + \"<list1><string>foobar1<\/string><\/list1><list2><string>foobar2\" + \"<\/string><\/list2><\/hudson.util.CopyOnWriteListTest_-TestData>\", out.replaceAll(\"\\\\s+\", \"\"));\r\n    td2 = (TestData) xs.fromXML(out.toString());\r\n    assertEquals(\"foobar1\", td2.list1.getView().get(0));\r\n    assertEquals(\"foobar2\", td2.list2.get(0));\r\n}"
}, {
	"Path": "org.apache.xml.utils.NodeVector.removeElementAt",
	"Comment": "deletes the component at the specified index. each component inthis vector with an index greater or equal to the specifiedindex is shifted downward to have an index one smaller thanthe value it had previously.",
	"Method": "void removeElementAt(int i){\r\n    if (null == m_map)\r\n        return;\r\n    if (i > m_firstFree)\r\n        System.arraycopy(m_map, i + 1, m_map, i - 1, m_firstFree - i);\r\n    else\r\n        m_map[i] = DTM.NULL;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.Encodings.getWriter",
	"Comment": "returns a writer for the specified encoding based onan output stream.this is not a public api.",
	"Method": "Writer getWriter(OutputStream output,String encoding){\r\n    for (int i = 0; i < _encodings.length; ++i) {\r\n        if (_encodings[i].name.equalsIgnoreCase(encoding)) {\r\n            try {\r\n                String javaName = _encodings[i].javaName;\r\n                OutputStreamWriter osw = new OutputStreamWriter(output, javaName);\r\n                return osw;\r\n            } catch (java.lang.IllegalArgumentException iae) {\r\n            } catch (UnsupportedEncodingException usee) {\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        return new OutputStreamWriter(output, encoding);\r\n    } catch (java.lang.IllegalArgumentException iae) {\r\n        throw new UnsupportedEncodingException(encoding);\r\n    }\r\n}"
}, {
	"Path": "jnacontrib.win32.Win32Service.init",
	"Comment": "initialize the service, connect to the servicecontrolmanager.",
	"Method": "void init(){\r\n    serviceMain = new ServiceMain();\r\n    SERVICE_TABLE_ENTRY entry = new SERVICE_TABLE_ENTRY();\r\n    entry.lpServiceName = serviceName;\r\n    entry.lpServiceProc = serviceMain;\r\n    Advapi32.INSTANCE.StartServiceCtrlDispatcher((SERVICE_TABLE_ENTRY[]) entry.toArray(2));\r\n}"
}, {
	"Path": "org.apache.xpath.operations.Variable.isStableNumber",
	"Comment": "tell if this expression returns a stable number that will not change during iterations within the expression.this is used to determine if a proximity position predicate can indicate that no more searching has to occur.",
	"Method": "boolean isStableNumber(){\r\n    return true;\r\n}"
}, {
	"Path": "hudson.security.PermissionScope.isContainedBy",
	"Comment": "returns true if this scope is directly or indirectly contained by the given scope.a scope always contains itself.",
	"Method": "boolean isContainedBy(PermissionScope s){\r\n    if (this == s)\r\n        return true;\r\n    for (PermissionScope c : containers) {\r\n        if (c.isContainedBy(s))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "hudson.os.solaris.ZFSInstaller.createZfsFileSystem",
	"Comment": "creates a zfs file system to migrate the data to.this has to be done while we still have an interactive access with the user, since it involves the password.an exception will be thrown if the operation fails. a normal completion means a success.",
	"Method": "String createZfsFileSystem(TaskListener listener,String rootUsername,String rootPassword){\r\n    final int uid = LIBC.geteuid();\r\n    final int gid = LIBC.getegid();\r\n    passwd pwd = LIBC.getpwuid(uid);\r\n    if (pwd == null)\r\n        throw new IOException(\"Failed to obtain the current user information for \" + uid);\r\n    final String userName = pwd.pw_name;\r\n    final File home = Jenkins.getInstance().getRootDir();\r\n    return SU.execute(listener, rootUsername, rootPassword, new Create(listener, home, uid, gid, userName));\r\n}"
}, {
	"Path": "org.apache.xalan.templates.XUnresolvedVariable.setVarStackContext",
	"Comment": "set an index into the variable stack where the variable context ends, i.e. at the point we should terminate the search.",
	"Method": "void setVarStackContext(int bottom){\r\n    m_varStackContext = bottom;\r\n}"
}, {
	"Path": "org.apache.xpath.VariableStack.elementAt",
	"Comment": "get the element at the given index, regardless of stackframe.",
	"Method": "XObject elementAt(int i){\r\n    return _stackFrames[i];\r\n}"
}, {
	"Path": "hudson.model.AbstractProjectTest.configuringBlockBuildWhenUpstreamBuildingRoundtrip",
	"Comment": "tests round trip configuration of the blockbuildwhenupstreambuildingfield",
	"Method": "void configuringBlockBuildWhenUpstreamBuildingRoundtrip(){\r\n    FreeStyleProject p = j.createFreeStyleProject();\r\n    p.setBlockBuildWhenUpstreamBuilding(false);\r\n    HtmlForm form = j.createWebClient().getPage(p, \"configure\").getFormByName(\"config\");\r\n    HtmlInput input = form.getInputByName(\"blockBuildWhenUpstreamBuilding\");\r\n    assertFalse(\"blockBuildWhenUpstreamBuilding check box is checked.\", input.isChecked());\r\n    input.setChecked(true);\r\n    j.submit(form);\r\n    assertTrue(\"blockBuildWhenUpstreamBuilding was not updated from configuration form\", p.blockBuildWhenUpstreamBuilding());\r\n    form = j.createWebClient().getPage(p, \"configure\").getFormByName(\"config\");\r\n    input = form.getInputByName(\"blockBuildWhenUpstreamBuilding\");\r\n    assert input.isChecked() : \"blockBuildWhenUpstreamBuilding check box is not checked.\";\r\n}"
}, {
	"Path": "hudson.PluginWrapper.setOptionalDependants",
	"Comment": "set the list of components that depend optionally on this plugin.",
	"Method": "void setOptionalDependants(Set<String> optionalDependants){\r\n    this.optionalDependants = optionalDependants;\r\n}"
}, {
	"Path": "hudson.model.AbstractProject.getTransitiveUpstreamProjects",
	"Comment": "gets all the upstream projects including transitive upstream projects.",
	"Method": "Set<AbstractProject> getTransitiveUpstreamProjects(){\r\n    return Jenkins.getInstance().getDependencyGraph().getTransitiveUpstream(this);\r\n}"
}, {
	"Path": "hudson.model.UpdateCenter.isDowngradable",
	"Comment": "returns true if backup of jenkins.war exists on the hard drive",
	"Method": "boolean isDowngradable(){\r\n    return new File(Lifecycle.get().getHudsonWar() + \".bak\").exists();\r\n}"
}, {
	"Path": "hudson.console.ConsoleAnnotatorTest.scriptInclusion",
	"Comment": "script.js defined in the annotator needs to be incorporated into the console page.",
	"Method": "void scriptInclusion(){\r\n    FreeStyleProject p = r.createFreeStyleProject();\r\n    FreeStyleBuild b = r.buildAndAssertSuccess(p);\r\n    HtmlPage html = r.createWebClient().getPage(b, \"console\");\r\n    assertNotNull(html.getElementById(\"inserted-by-test1\"));\r\n    assertNotNull(html.getElementById(\"inserted-by-test2\"));\r\n    for (DomElement e : html.getElementsByTagName(\"script\")) {\r\n        String src = e.getAttribute(\"src\");\r\n        if (!src.isEmpty()) {\r\n            assertThat(src, containsString(Jenkins.SESSION_HASH));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "hudson.model.ViewTest.getAllItems",
	"Comment": "get all items recursively when view implements viewgroup at the same time",
	"Method": "void getAllItems(){\r\n    final View leftView = Mockito.mock(View.class);\r\n    final View rightView = Mockito.mock(View.class);\r\n    CompositeView rootView = new CompositeView(\"rootJob\", leftView, rightView);\r\n    Mockito.when(leftView.getAllItems()).thenCallRealMethod();\r\n    Mockito.when(rightView.getAllItems()).thenCallRealMethod();\r\n    final TopLevelItem rootJob = createJob(\"rootJob\");\r\n    final TopLevelItem sharedJob = createJob(\"sharedJob\");\r\n    rootView = rootView.withJobs(rootJob, sharedJob);\r\n    final TopLevelItem leftJob = createJob(\"leftJob\");\r\n    final TopLevelItem rightJob = createJob(\"rightJob\");\r\n    Mockito.when(leftView.getItems()).thenReturn(Arrays.asList(leftJob, sharedJob));\r\n    Mockito.when(rightView.getItems()).thenReturn(Collections.singletonList(rightJob));\r\n    final TopLevelItem[] expected = new TopLevelItem[] { rootJob, sharedJob, leftJob, rightJob };\r\n    assertArrayEquals(expected, rootView.getAllItems().toArray());\r\n}"
}, {
	"Path": "hudson.model.AbstractProject.getSomeWorkspace",
	"Comment": "gets a workspace for some build of this project.this is useful for obtaining a workspace for the purpose of form field validation, where exactlywhich build the workspace belonged is less important. the implementation makes a cursory effortto find some workspace.",
	"Method": "FilePath getSomeWorkspace(){\r\n    R b = getSomeBuildWithWorkspace();\r\n    if (b != null)\r\n        return b.getWorkspace();\r\n    for (WorkspaceBrowser browser : ExtensionList.lookup(WorkspaceBrowser.class)) {\r\n        FilePath f = browser.getWorkspace(this);\r\n        if (f != null)\r\n            return f;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.ProcessorImport.getStylesheetType",
	"Comment": "get the stylesheet type associated with an imported stylesheet",
	"Method": "int getStylesheetType(){\r\n    return StylesheetHandler.STYPE_IMPORT;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.getCurrentNode",
	"Comment": "return the last fetched node.needed to support the unionpathiterator.",
	"Method": "int getCurrentNode(){\r\n    if (!m_cacheNodes)\r\n        throw new RuntimeException(\"This NodeSetDTM can not do indexing or counting functions!\");\r\n    int saved = m_next;\r\n    int current = (m_next > 0) ? m_next - 1 : m_next;\r\n    int n = (current < m_firstFree) ? elementAt(current) : DTM.NULL;\r\n    m_next = saved;\r\n    return n;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.getDocumentEncoding",
	"Comment": "return the name of the character encoding scheme in which the document entity is expressed.",
	"Method": "String getDocumentEncoding(int nodeHandle){\r\n    return \"UTF-8\";\r\n}"
}, {
	"Path": "org.apache.xalan.processor.XSLTElementDef.getProcessorFor",
	"Comment": "given a namespace uri, and a local name, get the processorfor the element, or return null if not allowed.",
	"Method": "XSLTElementProcessor getProcessorFor(String uri,String localName){\r\n    XSLTElementProcessor elemDef = null;\r\n    if (null == m_elements)\r\n        return null;\r\n    int n = m_elements.length;\r\n    int order = -1;\r\n    boolean multiAllowed = true;\r\n    for (int i = 0; i < n; i++) {\r\n        XSLTElementDef def = m_elements[i];\r\n        if (def.m_name.equals(\"*\")) {\r\n            if (!equalsMayBeNullOrZeroLen(uri, Constants.S_XSLNAMESPACEURL)) {\r\n                elemDef = def.m_elementProcessor;\r\n                order = def.getOrder();\r\n                multiAllowed = def.getMultiAllowed();\r\n            }\r\n        } else if (def.QNameEquals(uri, localName)) {\r\n            if (def.getRequired())\r\n                this.setRequiredFound(def.getName(), true);\r\n            order = def.getOrder();\r\n            multiAllowed = def.getMultiAllowed();\r\n            elemDef = def.m_elementProcessor;\r\n            break;\r\n        }\r\n    }\r\n    if (elemDef != null && this.isOrdered()) {\r\n        int lastOrder = getLastOrder();\r\n        if (order > lastOrder)\r\n            setLastOrder(order);\r\n        else if (order == lastOrder && !multiAllowed) {\r\n            return null;\r\n        } else if (order < lastOrder && order > 0) {\r\n            return null;\r\n        }\r\n    }\r\n    return elemDef;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.ignorableWhitespace",
	"Comment": "receive notification of ignorable whitespace in element content.not sure how to get this invoked quite yet.",
	"Method": "void ignorableWhitespace(char ch,int start,int length){\r\n    if (0 == length)\r\n        return;\r\n    characters(ch, start, length);\r\n}"
}, {
	"Path": "hudson.PluginManagerCheckUpdateCenterTest.changeLogLevelInLog",
	"Comment": "checks if the message to activate the warnings is written in the log when the log level is higher than warningand the attempts higher than 1.",
	"Method": "void changeLogLevelInLog(){\r\n    Logger pmLogger = Logger.getLogger(PluginManager.class.getName());\r\n    Logger rLogger = Logger.getLogger(Retrier.class.getName());\r\n    Level pmLevel = pmLogger.getLevel();\r\n    Level rLevel = rLogger.getLevel();\r\n    try {\r\n        pmLogger.setLevel(Level.SEVERE);\r\n        rLogger.setLevel(Level.SEVERE);\r\n        PluginManager.CHECK_UPDATE_ATTEMPTS = 2;\r\n        updateSiteWrongJsonTest();\r\n        assertThat(logging, LoggerRule.recorded(is(Messages.PluginManager_UpdateSiteChangeLogLevel(Retrier.class.getName()))));\r\n    } finally {\r\n        pmLogger.setLevel(pmLevel);\r\n        rLogger.setLevel(rLevel);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemVariable.accept",
	"Comment": "accept a visitor and call the appropriate method for this class.",
	"Method": "boolean accept(XSLTVisitor visitor){\r\n    return visitor.visitVariableOrParamDecl(this);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.getNextDescendant",
	"Comment": "given a node handle, advance to its next descendant.if not yet resolved, waits for more nodes to be added to the document andtries again.",
	"Method": "int getNextDescendant(int subtreeRootHandle,int nodeHandle){\r\n    subtreeRootHandle &= NODEHANDLE_MASK;\r\n    nodeHandle &= NODEHANDLE_MASK;\r\n    if (nodeHandle == 0)\r\n        return NULL;\r\n    while (!m_isError) {\r\n        if (done && (nodeHandle > nodes.slotsUsed()))\r\n            break;\r\n        if (nodeHandle > subtreeRootHandle) {\r\n            nodes.readSlot(nodeHandle + 1, gotslot);\r\n            if (gotslot[2] != 0) {\r\n                short type = (short) (gotslot[0] & 0xFFFF);\r\n                if (type == ATTRIBUTE_NODE) {\r\n                    nodeHandle += 2;\r\n                } else {\r\n                    int nextParentPos = gotslot[1];\r\n                    if (nextParentPos >= subtreeRootHandle)\r\n                        return (m_docHandle | (nodeHandle + 1));\r\n                    else\r\n                        break;\r\n                }\r\n            } else if (!done) {\r\n            } else\r\n                break;\r\n        } else {\r\n            nodeHandle++;\r\n        }\r\n    }\r\n    return NULL;\r\n}"
}, {
	"Path": "hudson.lifecycle.WindowsInstallerLink.runElevated",
	"Comment": "invokes jenkins.exe with a scm management command.if it fails in a way that indicates the presence of uac, retry in an uac compatible manner.",
	"Method": "int runElevated(File jenkinsExe,String command,TaskListener out,File pwd){\r\n    try {\r\n        return new LocalLauncher(out).launch().cmds(jenkinsExe, command).stdout(out).pwd(pwd).join();\r\n    } catch (IOException e) {\r\n        if (e.getMessage().contains(\"CreateProcess\") && e.getMessage().contains(\"=740\")) {\r\n        } else {\r\n            throw e;\r\n        }\r\n    }\r\n    SHELLEXECUTEINFO sei = new SHELLEXECUTEINFO();\r\n    sei.fMask = SEE_MASK_NOCLOSEPROCESS;\r\n    sei.lpVerb = \"runas\";\r\n    sei.lpFile = jenkinsExe.getAbsolutePath();\r\n    sei.lpParameters = \"/redirect redirect.log \" + command;\r\n    sei.lpDirectory = pwd.getAbsolutePath();\r\n    sei.nShow = SW_HIDE;\r\n    if (!Shell32.INSTANCE.ShellExecuteEx(sei))\r\n        throw new IOException(\"Failed to shellExecute: \" + Native.getLastError());\r\n    try {\r\n        return Kernel32Utils.waitForExitProcess(sei.hProcess);\r\n    } finally {\r\n        try (InputStream fin = Files.newInputStream(new File(pwd, \"redirect.log\").toPath())) {\r\n            IOUtils.copy(fin, out.getLogger());\r\n        } catch (InvalidPathException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.canStripWhiteSpace",
	"Comment": "get information about whether or not whitespace can be stripped.",
	"Method": "boolean canStripWhiteSpace(){\r\n    StylesheetRoot sroot = this.getStylesheetRoot();\r\n    return (null != sroot) ? sroot.canStripWhiteSpace() : false;\r\n}"
}, {
	"Path": "hudson.model.Executor.getIdleStartMilliseconds",
	"Comment": "returns when this executor started or should start being idle.",
	"Method": "long getIdleStartMilliseconds(){\r\n    if (isIdle())\r\n        return Math.max(creationTime, owner.getConnectTime());\r\n    else {\r\n        return Math.max(startTime + Math.max(0, executableEstimatedDuration), System.currentTimeMillis() + 15000);\r\n    }\r\n}"
}, {
	"Path": "hudson.tasks.Publisher.all",
	"Comment": "for backward compatibility, the signature is not buildstepdescriptor",
	"Method": "DescriptorExtensionList<Publisher, Descriptor<Publisher>> all(){\r\n    return Jenkins.getInstance().<Publisher, Descriptor<Publisher>>getDescriptorList(Publisher.class);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.ProcessorText.appendAndPush",
	"Comment": "append the current template element to the currenttemplate element, and then push it onto the current templateelement stack.",
	"Method": "void appendAndPush(StylesheetHandler handler,ElemTemplateElement elem){\r\n    ProcessorCharacters charProcessor = (ProcessorCharacters) handler.getProcessorFor(null, \"text()\", \"text\");\r\n    charProcessor.setXslTextElement((ElemText) elem);\r\n    ElemTemplateElement parent = handler.getElemTemplateElement();\r\n    parent.appendChild(elem);\r\n    elem.setDOMBackPointer(handler.getOriginatingNode());\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XBoolean.getTypeString",
	"Comment": "given a request type, return the equivalent string.for diagnostic purposes.",
	"Method": "String getTypeString(){\r\n    return \"#BOOLEAN\";\r\n}"
}, {
	"Path": "hudson.model.UpdateCenter.updateAllSites",
	"Comment": "ensure that all updatesites are up to date, without requiring a user tobrowse to the instance.",
	"Method": "List<FormValidation> updateAllSites(){\r\n    List<Future<FormValidation>> futures = new ArrayList<Future<FormValidation>>();\r\n    for (UpdateSite site : getSites()) {\r\n        Future<FormValidation> future = site.updateDirectly(DownloadService.signatureCheck);\r\n        if (future != null) {\r\n            futures.add(future);\r\n        }\r\n    }\r\n    List<FormValidation> results = new ArrayList<FormValidation>();\r\n    for (Future<FormValidation> f : futures) {\r\n        results.add(f.get());\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.getCurrentNode",
	"Comment": "return the last fetched node.needed to support the unionpathiterator.",
	"Method": "int getCurrentNode(){\r\n    return m_lastFetched;\r\n}"
}, {
	"Path": "hudson.model.Computer.isManualLaunchAllowed",
	"Comment": "this method is called to determine whether manual launching of the agent is allowed at this point in time.",
	"Method": "boolean isManualLaunchAllowed(){\r\n    return getRetentionStrategy().isManualLaunchAllowed(this);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMNodeIterator.getWhatToShow",
	"Comment": "return a mask describing which node types are presented via theiterator.",
	"Method": "int getWhatToShow(){\r\n    return dtm_iter.getWhatToShow();\r\n}"
}, {
	"Path": "org.java_websocket.client.WebSocketClient.getURI",
	"Comment": "returns the uri that this websocketclient is connected to.",
	"Method": "URI getURI(){\r\n    return uri;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.XMLChar.isValid",
	"Comment": "returns true if the specified character is valid. this methodalso checks the surrogate character range from 0x10000 to 0x10ffff.if the program chooses to apply the mask directly to thechars array, then they are responsible for checkingthe surrogate character range.",
	"Method": "boolean isValid(int c){\r\n    return (c < 0x10000 && (CHARS[c] & MASK_VALID) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.TransformerFactoryImpl.newTransformerHandler",
	"Comment": "get a transformerhandler object that can process saxcontenthandler events into a result.",
	"Method": "TransformerHandler newTransformerHandler(Source src,TransformerHandler newTransformerHandler,Templates templates,TransformerHandler newTransformerHandler){\r\n    return new TransformerIdentityImpl(m_isSecureProcessing);\r\n}"
}, {
	"Path": "org.apache.xpath.axes.NodeSequence.getVector",
	"Comment": "if this iterator needs to cache nodes that are fetched, theyare stored in the vector in the generic object.",
	"Method": "NodeVector getVector(NodeVector getVector){\r\n    NodeVector nv = (m_cache != null) ? m_cache.getVector() : null;\r\n    return nv;\r\n}"
}, {
	"Path": "jenkins.security.apitoken.ApiTokenStore.reconfigure",
	"Comment": "defensive approach to avoid involuntary change since the uuids are generated at startup only for uiand so between restart they change",
	"Method": "void reconfigure(Map<String, JSONObject> tokenStoreDataMap){\r\n    tokenList.forEach(hashedToken -> {\r\n        JSONObject receivedTokenData = tokenStoreDataMap.get(hashedToken.uuid);\r\n        if (receivedTokenData == null) {\r\n            LOGGER.log(Level.INFO, \"No token received for {0}\", hashedToken.uuid);\r\n            return;\r\n        }\r\n        String name = receivedTokenData.getString(\"tokenName\");\r\n        if (StringUtils.isBlank(name)) {\r\n            LOGGER.log(Level.INFO, \"Empty name received for {0}, we do not care about it\", hashedToken.uuid);\r\n            return;\r\n        }\r\n        hashedToken.setName(name);\r\n    });\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.getLastChild",
	"Comment": "given a node handle, advance to its last child. if not yet resolved, waits for more nodes to be added to the document and tries again.",
	"Method": "int getLastChild(int nodeHandle){\r\n    nodeHandle &= NODEHANDLE_MASK;\r\n    int lastChild = NULL;\r\n    for (int nextkid = getFirstChild(nodeHandle); nextkid != NULL; nextkid = getNextSibling(nextkid)) {\r\n        lastChild = nextkid;\r\n    }\r\n    return lastChild | m_docHandle;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.Function2Args.setArg",
	"Comment": "set an argument expression for a function.this method is called by the xpath compiler.",
	"Method": "void setArg(Expression arg,int argNum){\r\n    if (argNum == 0)\r\n        super.setArg(arg, argNum);\r\n    else if (1 == argNum) {\r\n        m_arg1 = arg;\r\n        arg.exprSetParent(this);\r\n    } else\r\n        reportWrongNumberArgs();\r\n}"
}, {
	"Path": "com.iluwatar.reactor.framework.NioReactor.processKey",
	"Comment": "initiation dispatcher logic, it checks the type of event and notifier application specific event handler to handlethe event.",
	"Method": "void processKey(SelectionKey key){\r\n    if (key.isAcceptable()) {\r\n        onChannelAcceptable(key);\r\n    } else if (key.isReadable()) {\r\n        onChannelReadable(key);\r\n    } else if (key.isWritable()) {\r\n        onChannelWritable(key);\r\n    }\r\n}"
}, {
	"Path": "jadx.core.dex.visitors.ConstInlineVisitor.fixTypes",
	"Comment": "this is method similar to posttypeinference.process method,\tbut contains some expensive operations needed only after constant inline",
	"Method": "void fixTypes(MethodNode mth,InsnNode insn,LiteralArg litArg){\r\n    DexNode dex = mth.dex();\r\n    PostTypeInference.process(mth, insn);\r\n    switch(insn.getType()) {\r\n        case CONST:\r\n            insn.getArg(0).merge(dex, insn.getResult());\r\n            break;\r\n        case MOVE:\r\n            insn.getResult().merge(dex, insn.getArg(0));\r\n            insn.getArg(0).merge(dex, insn.getResult());\r\n            break;\r\n        case IPUT:\r\n        case SPUT:\r\n            IndexInsnNode node = (IndexInsnNode) insn;\r\n            insn.getArg(0).merge(dex, ((FieldInfo) node.getIndex()).getType());\r\n            break;\r\n        case IF:\r\n            InsnArg firstArg = insn.getArg(0);\r\n            InsnArg secondArg = insn.getArg(1);\r\n            if (firstArg == litArg) {\r\n                firstArg.merge(dex, secondArg);\r\n            } else {\r\n                secondArg.merge(dex, firstArg);\r\n            }\r\n            break;\r\n        case CMP_G:\r\n        case CMP_L:\r\n            InsnArg arg0 = insn.getArg(0);\r\n            InsnArg arg1 = insn.getArg(1);\r\n            if (arg0 == litArg) {\r\n                arg0.merge(dex, arg1);\r\n            } else {\r\n                arg1.merge(dex, arg0);\r\n            }\r\n            break;\r\n        case RETURN:\r\n            if (insn.getArgsCount() != 0) {\r\n                insn.getArg(0).merge(dex, mth.getReturnType());\r\n            }\r\n            break;\r\n        case INVOKE:\r\n            InvokeNode inv = (InvokeNode) insn;\r\n            List<ArgType> types = inv.getCallMth().getArgumentsTypes();\r\n            int count = insn.getArgsCount();\r\n            int k = types.size() == count ? 0 : -1;\r\n            for (int i = 0; i < count; i++) {\r\n                InsnArg arg = insn.getArg(i);\r\n                if (!arg.getType().isTypeKnown()) {\r\n                    ArgType type;\r\n                    if (k >= 0) {\r\n                        type = types.get(k);\r\n                    } else {\r\n                        type = mth.getParentClass().getClassInfo().getType();\r\n                    }\r\n                    arg.merge(dex, type);\r\n                }\r\n                k++;\r\n            }\r\n            break;\r\n        case ARITH:\r\n            litArg.merge(dex, insn.getResult());\r\n            break;\r\n        case APUT:\r\n        case AGET:\r\n            if (litArg == insn.getArg(1)) {\r\n                litArg.merge(dex, ArgType.INT);\r\n            }\r\n            break;\r\n        case NEW_ARRAY:\r\n            if (litArg == insn.getArg(0)) {\r\n                litArg.merge(dex, ArgType.INT);\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "hudson.init.TaskMethodFinder.lookUp",
	"Comment": "determines the parameter injection of the initialization method.",
	"Method": "Object lookUp(Class<?> type){\r\n    Jenkins j = Jenkins.getInstance();\r\n    assert j != null : \"This method is only invoked after the Jenkins singleton instance has been set\";\r\n    if (type == Jenkins.class || type == Hudson.class)\r\n        return j;\r\n    Injector i = j.getInjector();\r\n    if (i != null)\r\n        return i.getInstance(type);\r\n    throw new IllegalArgumentException(\"Unable to inject \" + type);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.XSLTElementDef.getProcessorForUnknown",
	"Comment": "given an unknown element, get the processorfor the element.",
	"Method": "XSLTElementProcessor getProcessorForUnknown(String uri,String localName){\r\n    if (null == m_elements)\r\n        return null;\r\n    int n = m_elements.length;\r\n    for (int i = 0; i < n; i++) {\r\n        XSLTElementDef def = m_elements[i];\r\n        if (def.m_name.equals(\"unknown\") && uri.length() > 0) {\r\n            return def.m_elementProcessor;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "ciphers.AESEncryption.decryptText",
	"Comment": "decrypts encrypted byte array using the key used for encryption.",
	"Method": "String decryptText(byte[] byteCipherText,SecretKey secKey){\r\n    Cipher aesCipher = Cipher.getInstance(\"AES\");\r\n    aesCipher.init(Cipher.DECRYPT_MODE, secKey);\r\n    byte[] bytePlainText = aesCipher.doFinal(byteCipherText);\r\n    return new String(bytePlainText);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToUnknownStream.setDoctypeSystem",
	"Comment": "set the doctype in the underlying xml handler. remember that this methodwas called, just in case we need to transfer this doctype to an html handler",
	"Method": "void setDoctypeSystem(String doctype){\r\n    m_handler.setDoctypeSystem(doctype);\r\n    m_setDoctypeSystem_called = true;\r\n}"
}, {
	"Path": "com.iluwatar.model.view.controller.GiantModelTest.testSetNourishment",
	"Comment": "verify if the nourishment level is set properly though the constructor and setter",
	"Method": "void testSetNourishment(){\r\n    final GiantModel model = new GiantModel(Health.HEALTHY, Fatigue.ALERT, Nourishment.SATURATED);\r\n    assertEquals(Nourishment.SATURATED, model.getNourishment());\r\n    for (final Nourishment nourishment : Nourishment.values()) {\r\n        model.setNourishment(nourishment);\r\n        assertEquals(nourishment, model.getNourishment());\r\n        assertEquals(\"The giant looks healthy, alert and \" + nourishment.toString() + \".\", model.toString());\r\n    }\r\n}"
}, {
	"Path": "jenkins.util.ResourceBundleUtil.getBundle",
	"Comment": "get a plugin bundle using the supplied locale and classloader",
	"Method": "JSONObject getBundle(String baseName,JSONObject getBundle,String baseName,Locale locale,ResourceBundle getBundle,String baseName,Locale locale,ClassLoader classLoader){\r\n    try {\r\n        return ResourceBundle.getBundle(baseName, locale, classLoader);\r\n    } catch (MissingResourceException e) {\r\n        logger.finer(e.getMessage());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncCount.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    DTMIterator nl = m_arg0.asIterator(xctxt, xctxt.getCurrentNode());\r\n    int i = nl.getLength();\r\n    nl.detach();\r\n    return new XNumber((double) i);\r\n}"
}, {
	"Path": "hudson.PluginWrapper.disableWithoutCheck",
	"Comment": "disable a plugin wihout checking any dependency. only add the disable file.",
	"Method": "void disableWithoutCheck(){\r\n    try (OutputStream os = Files.newOutputStream(disableFile.toPath())) {\r\n        os.close();\r\n    } catch (InvalidPathException e) {\r\n        throw new IOException(e);\r\n    }\r\n}"
}, {
	"Path": "hudson.model.Node.getDynamicLabels",
	"Comment": "return all the labels assigned dynamically to this node.this calls all the labelfinder implementations with the node convertsthe results into labels.",
	"Method": "HashSet<LabelAtom> getDynamicLabels(){\r\n    HashSet<LabelAtom> result = new HashSet<LabelAtom>();\r\n    for (LabelFinder labeler : LabelFinder.all()) {\r\n        for (Label label : labeler.findLabels(this)) if (label instanceof LabelAtom)\r\n            result.add((LabelAtom) label);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.insertElementAt",
	"Comment": "inserts the specified node in this vector at the specified index.each component in this vector with an index greater or equal tothe specified index is shifted upward to have an index one greaterthan the value it had previously.",
	"Method": "void insertElementAt(int value,int at){\r\n    if (!m_mutable)\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null));\r\n    super.insertElementAt(value, at);\r\n}"
}, {
	"Path": "hudson.model.ParameterDefinition.getFormattedDescription",
	"Comment": "return parameter description, applying the configured markupformatter for jenkins instance.",
	"Method": "String getFormattedDescription(){\r\n    try {\r\n        return Jenkins.getInstance().getMarkupFormatter().translate(description);\r\n    } catch (IOException e) {\r\n        LOGGER.warning(\"failed to translate description using configured markup formatter\");\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.functions.Function3Args.checkNumberArgs",
	"Comment": "check that the number of arguments passed to this function is correct.",
	"Method": "void checkNumberArgs(int argNum){\r\n    if (argNum != 3)\r\n        reportWrongNumberArgs();\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerImpl.getCurrentNode",
	"Comment": "this method retrieves the current context nodein the source tree.",
	"Method": "int getCurrentNode(){\r\n    return m_xcontext.getCurrentNode();\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.removeAllElements",
	"Comment": "inserts the specified node in this vector at the specified index.each component in this vector with an index greater or equal tothe specified index is shifted upward to have an index one greaterthan the value it had previously.",
	"Method": "void removeAllElements(){\r\n    if (!m_mutable)\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null));\r\n    super.removeAllElements();\r\n}"
}, {
	"Path": "hudson.util.LineEndingConversion.convertEOL",
	"Comment": "convert line endings of a string to the given type.default to unix type.",
	"Method": "String convertEOL(String input,EOLType type){\r\n    if (null == input || 0 == input.length()) {\r\n        return input;\r\n    }\r\n    input = input.replace(\"\\r\\n\", \"\\n\");\r\n    input = input.replace(\"\\r\", \"\\n\");\r\n    switch(type) {\r\n        case CR:\r\n        case Mac:\r\n            input = input.replace(\"\\n\", \"\\r\");\r\n            break;\r\n        case CRLF:\r\n        case Windows:\r\n            input = input.replace(\"\\n\", \"\\r\\n\");\r\n            break;\r\n        default:\r\n        case LF:\r\n        case Unix:\r\n            return input;\r\n        case LFCR:\r\n            input = input.replace(\"\\n\", \"\\n\\r\");\r\n            break;\r\n    }\r\n    return input;\r\n}"
}, {
	"Path": "org.java_websocket.server.WebSocketServer.doBroadcast",
	"Comment": "private method to cache all the frames to improve memory footprint and conversion time",
	"Method": "void doBroadcast(Object data,Collection<WebSocket> clients){\r\n    String sData = null;\r\n    if (data instanceof String) {\r\n        sData = (String) data;\r\n    }\r\n    ByteBuffer bData = null;\r\n    if (data instanceof ByteBuffer) {\r\n        bData = (ByteBuffer) data;\r\n    }\r\n    if (sData == null && bData == null) {\r\n        return;\r\n    }\r\n    Map<Draft, List<Framedata>> draftFrames = new HashMap<Draft, List<Framedata>>();\r\n    for (WebSocket client : clients) {\r\n        if (client != null) {\r\n            Draft draft = client.getDraft();\r\n            fillFrames(draft, draftFrames, sData, bData);\r\n            try {\r\n                client.sendFrame(draftFrames.get(draft));\r\n            } catch (WebsocketNotConnectedException e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.insertElementAt",
	"Comment": "inserts the specified node in this vector at the specified index.each component in this vector with an index greater or equal tothe specified index is shifted upward to have an index one greaterthan the value it had previously.",
	"Method": "void insertElementAt(Node value,int at){\r\n    if (!m_mutable)\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null));\r\n    if (null == m_map) {\r\n        m_map = new Node[m_blocksize];\r\n        m_mapSize = m_blocksize;\r\n    } else if ((m_firstFree + 1) >= m_mapSize) {\r\n        m_mapSize += m_blocksize;\r\n        Node[] newMap = new Node[m_mapSize];\r\n        System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);\r\n        m_map = newMap;\r\n    }\r\n    if (at <= (m_firstFree - 1)) {\r\n        System.arraycopy(m_map, at, m_map, at + 1, m_firstFree - at);\r\n    }\r\n    m_map[at] = value;\r\n    m_firstFree++;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerImpl.getCurrentElement",
	"Comment": "retrieves the current elemtemplateelement that isbeing executed.",
	"Method": "ElemTemplateElement getCurrentElement(){\r\n    return (m_currentTemplateElements.size() > 0) ? (ElemTemplateElement) m_currentTemplateElements.peek() : null;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.configuration.DockerHealthCheck.getStartPeriod",
	"Comment": "gets the optional healthcheck start period. a missing command means that it will be inheritedfrom the base image.",
	"Method": "Optional<Duration> getStartPeriod(){\r\n    return Optional.ofNullable(startPeriod);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.getAttributeNode",
	"Comment": "retrieves an attribute node by by qualified name and namespace uri.",
	"Method": "int getAttributeNode(int nodeHandle,String namespaceURI,String name){\r\n    int nsIndex = m_nsNames.stringToIndex(namespaceURI), nameIndex = m_localNames.stringToIndex(name);\r\n    nodeHandle &= NODEHANDLE_MASK;\r\n    nodes.readSlot(nodeHandle, gotslot);\r\n    short type = (short) (gotslot[0] & 0xFFFF);\r\n    if (type == ELEMENT_NODE)\r\n        nodeHandle++;\r\n    while (type == ATTRIBUTE_NODE) {\r\n        if ((nsIndex == (gotslot[0] << 16)) && (gotslot[3] == nameIndex))\r\n            return nodeHandle | m_docHandle;\r\n        nodeHandle = gotslot[2];\r\n        nodes.readSlot(nodeHandle, gotslot);\r\n    }\r\n    return NULL;\r\n}"
}, {
	"Path": "hudson.node_monitors.AbstractDiskSpaceMonitor.markNodeOfflineIfDiskspaceIsTooLow",
	"Comment": "marks the given node as offline if free disk space is below the configured threshold.",
	"Method": "DiskSpace markNodeOfflineIfDiskspaceIsTooLow(Computer c){\r\n    DiskSpace size = (DiskSpace) super.data(c);\r\n    if (size != null && size.size < getThresholdBytes()) {\r\n        size.setTriggered(this.getClass(), true);\r\n        if (getDescriptor().markOffline(c, size)) {\r\n            LOGGER.warning(Messages.DiskSpaceMonitor_MarkedOffline(c.getName()));\r\n        }\r\n    }\r\n    return size;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.processingInstruction",
	"Comment": "receive notification of a processing instruction.by default, do nothing.application writers may override thismethod in a subclass to take specific actions for eachprocessing instruction, such as setting status variables orinvoking other methods.",
	"Method": "void processingInstruction(String target,String data){\r\n    if (DEBUG)\r\n        System.out.println(\"processingInstruction: target: \" + target + \", data: \" + data);\r\n    charactersFlush();\r\n    int exName = m_expandedNameTable.getExpandedTypeID(null, target, DTM.PROCESSING_INSTRUCTION_NODE);\r\n    int dataIndex = m_valuesOrPrefixes.stringToIndex(data);\r\n    m_previous = addNode(DTM.PROCESSING_INSTRUCTION_NODE, exName, m_parents.peek(), m_previous, dataIndex, false);\r\n}"
}, {
	"Path": "com.iluwatar.strategy.DragonSlayerTest.testChangeStrategy",
	"Comment": "verify if the dragon slayer uses the new strategy during battle after a change of strategy",
	"Method": "void testChangeStrategy(){\r\n    final DragonSlayingStrategy initialStrategy = mock(DragonSlayingStrategy.class);\r\n    final DragonSlayer dragonSlayer = new DragonSlayer(initialStrategy);\r\n    dragonSlayer.goToBattle();\r\n    verify(initialStrategy).execute();\r\n    final DragonSlayingStrategy newStrategy = mock(DragonSlayingStrategy.class);\r\n    dragonSlayer.changeStrategy(newStrategy);\r\n    dragonSlayer.goToBattle();\r\n    verify(newStrategy).execute();\r\n    verifyNoMoreInteractions(initialStrategy, newStrategy);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.EncodingInfo.inEncoding",
	"Comment": "this is heart of the code that determines if a given characteris in the given encoding. this method is probably expensive,and the answer should be cached.this method is not a public api,and should only be used internally within the serializer.",
	"Method": "boolean inEncoding(char ch,String encoding,boolean inEncoding,char high,char low,String encoding,boolean inEncoding,char ch,byte[] data){\r\n    final boolean isInEncoding;\r\n    if (data == null || data.length == 0) {\r\n        isInEncoding = false;\r\n    } else {\r\n        if (data[0] == 0)\r\n            isInEncoding = false;\r\n        else if (data[0] == '?' && ch != '?')\r\n            isInEncoding = false;\r\n        else {\r\n            isInEncoding = true;\r\n        }\r\n    }\r\n    return isInEncoding;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.WalkerFactory.isDownwardAxisOfMany",
	"Comment": "tell if the given axis goes downword.bogus name, if you can think of a better one, please do tell.this really has to do with inverting attribute axis.",
	"Method": "boolean isDownwardAxisOfMany(int axis){\r\n    return ((Axis.DESCENDANTORSELF == axis) || (Axis.DESCENDANT == axis) || (Axis.FOLLOWING == axis) || (Axis.PRECEDING == axis));\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.OpMap.getNextStepPos",
	"Comment": "given a location step position, return the end position, i.e. thebeginning of the next step.",
	"Method": "int getNextStepPos(int opPos){\r\n    int stepType = getOp(opPos);\r\n    if ((stepType >= OpCodes.AXES_START_TYPES) && (stepType <= OpCodes.AXES_END_TYPES)) {\r\n        return getNextOpPos(opPos);\r\n    } else if ((stepType >= OpCodes.FIRST_NODESET_OP) && (stepType <= OpCodes.LAST_NODESET_OP)) {\r\n        int newOpPos = getNextOpPos(opPos);\r\n        while (OpCodes.OP_PREDICATE == getOp(newOpPos)) {\r\n            newOpPos = getNextOpPos(newOpPos);\r\n        }\r\n        stepType = getOp(newOpPos);\r\n        if (!((stepType >= OpCodes.AXES_START_TYPES) && (stepType <= OpCodes.AXES_END_TYPES))) {\r\n            return OpCodes.ENDOP;\r\n        }\r\n        return newOpPos;\r\n    } else {\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_UNKNOWN_STEP, new Object[] { String.valueOf(stepType) }));\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.doubledispatch.RectangleTest.testConstructor",
	"Comment": "test if the values passed through the constructor matches the values fetched from the getters",
	"Method": "void testConstructor(){\r\n    final Rectangle rectangle = new Rectangle(1, 2, 3, 4);\r\n    assertEquals(1, rectangle.getLeft());\r\n    assertEquals(2, rectangle.getTop());\r\n    assertEquals(3, rectangle.getRight());\r\n    assertEquals(4, rectangle.getBottom());\r\n}"
}, {
	"Path": "org.apache.xalan.res.XSLTErrorResources.getResourceSuffix",
	"Comment": "return the resource file suffic for the indicated localefor most locales, this will be based the language code.howeverfor chinese, we do distinguish between taiwan and prc",
	"Method": "String getResourceSuffix(Locale locale){\r\n    String suffix = \"_\" + locale.getLanguage();\r\n    String country = locale.getCountry();\r\n    if (country.equals(\"TW\"))\r\n        suffix += \"_\" + country;\r\n    return suffix;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.getRoot",
	"Comment": "the root node of the iterator, as specified when it was created.",
	"Method": "int getRoot(){\r\n    return m_context;\r\n}"
}, {
	"Path": "com.sun.jna.contrib.demo.FilteredTextField.clearCharacters",
	"Comment": "clears the list of allowable characters for entry validation.",
	"Method": "void clearCharacters(){\r\n    allowable.clear();\r\n}"
}, {
	"Path": "com.sun.jna.contrib.demo.FilteredTextField.removeCharacters",
	"Comment": "removes the character array from the list used for entry validation.",
	"Method": "void removeCharacters(Character[] characters){\r\n    for (int i = 0; i < characters.length; i++) {\r\n        removeCharacter(characters[i]);\r\n    }\r\n}"
}, {
	"Path": "jenkins.install.SetupWizard.hasSetupWizardFilter",
	"Comment": "returns whether the setup wizard filter is currently registered.",
	"Method": "boolean hasSetupWizardFilter(){\r\n    return PluginServletFilter.hasFilter(FORCE_SETUP_WIZARD_FILTER);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetRoot.getImportNumber",
	"Comment": "given a stylesheet, return the number of the stylesheetin the global import list.",
	"Method": "int getImportNumber(StylesheetComposed sheet){\r\n    if (this == sheet)\r\n        return 0;\r\n    int n = getGlobalImportCount();\r\n    for (int i = 0; i < n; i++) {\r\n        if (sheet == getGlobalImport(i))\r\n            return i;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "hudson.util.NoClientBindSSLProtocolSocketFactory.getSocketFactory",
	"Comment": "gets an singleton instance of the sslprotocolsocketfactory.",
	"Method": "NoClientBindSSLProtocolSocketFactory getSocketFactory(){\r\n    return factory;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMManagerDefault.getDTMIdentity",
	"Comment": "given a dtm, find the id number in the dtm tables which addressesthe start of the document. if overflow addressing is in use, otherdtm ids may also be assigned to this dtm.",
	"Method": "int getDTMIdentity(DTM dtm){\r\n    if (dtm instanceof DTMDefaultBase) {\r\n        DTMDefaultBase dtmdb = (DTMDefaultBase) dtm;\r\n        if (dtmdb.getManager() == this)\r\n            return dtmdb.getDTMIDs().elementAt(0);\r\n        else\r\n            return -1;\r\n    }\r\n    int n = m_dtms.length;\r\n    for (int i = 0; i < n; i++) {\r\n        DTM tdtm = m_dtms[i];\r\n        if (tdtm == dtm && m_dtm_offsets[i] == 0)\r\n            return i << IDENT_DTM_NODE_BITS;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemParam.execute",
	"Comment": "execute a variable declaration and push it onto the variable stack.",
	"Method": "void execute(TransformerImpl transformer){\r\n    VariableStack vars = transformer.getXPathContext().getVarStack();\r\n    if (!vars.isLocalSet(m_index)) {\r\n        int sourceNode = transformer.getXPathContext().getCurrentNode();\r\n        XObject var = getValue(transformer, sourceNode);\r\n        transformer.getXPathContext().getVarStack().setLocalVariable(m_index, var);\r\n    }\r\n}"
}, {
	"Path": "jadx.core.dex.regions.loops.LoopRegion.mergePreCondition",
	"Comment": "move all precondition block instructions before conditionblock instructions",
	"Method": "void mergePreCondition(){\r\n    if (preCondition != null && conditionBlock != null) {\r\n        List<InsnNode> condInsns = conditionBlock.getInstructions();\r\n        List<InsnNode> preCondInsns = preCondition.getInstructions();\r\n        preCondInsns.addAll(condInsns);\r\n        condInsns.clear();\r\n        condInsns.addAll(preCondInsns);\r\n        preCondInsns.clear();\r\n        preCondition = null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.declAlreadyDeclared",
	"Comment": "check if a declaration has already been made for a given prefix.",
	"Method": "boolean declAlreadyDeclared(String prefix){\r\n    int startDecls = m_contextIndexes.peek();\r\n    java.util.Vector prefixMappings = m_prefixMappings;\r\n    int nDecls = prefixMappings.size();\r\n    for (int i = startDecls; i < nDecls; i += 2) {\r\n        String prefixDecl = (String) prefixMappings.elementAt(i);\r\n        if (prefixDecl == null)\r\n            continue;\r\n        if (prefixDecl.equals(prefix))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.addNode",
	"Comment": "add a node to the nodeset. not all types of nodesets support thisoperation",
	"Method": "void addNode(Node n){\r\n    if (!m_mutable)\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null));\r\n    this.addElement(n);\r\n}"
}, {
	"Path": "hudson.AbstractMarkupText.findToken",
	"Comment": "find the first occurrence of the given pattern in this text, or null.",
	"Method": "MarkupText.SubText findToken(Pattern pattern){\r\n    String text = getText();\r\n    Matcher m = pattern.matcher(text);\r\n    if (m.find())\r\n        return createSubText(m);\r\n    return null;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.configuration.DockerHealthCheck.getTimeout",
	"Comment": "gets the optional healthcheck timeout. a missing command means that it will be inherited fromthe base image.",
	"Method": "Optional<Duration> getTimeout(){\r\n    return Optional.ofNullable(timeout);\r\n}"
}, {
	"Path": "redis.clients.jedis.params.ZAddParams.ch",
	"Comment": "modify the return value from the number of new elements added to the total number of elementschanged",
	"Method": "ZAddParams ch(){\r\n    addParam(CH);\r\n    return this;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMNamedNodeMap.removeNamedItem",
	"Comment": "removes a node specified by name. when this map contains the attributesattached to an element, if the removed attribute is known to have adefault value, an attribute immediately appears containing thedefault value as well as the corresponding namespace uri, local name,and prefix when applicable.",
	"Method": "Node removeNamedItem(String name){\r\n    throw new DTMException(DTMException.NO_MODIFICATION_ALLOWED_ERR);\r\n}"
}, {
	"Path": "org.apache.xml.utils.NodeVector.pushPair",
	"Comment": "push a pair of nodes into the stack.special purpose method for transformerimpl, pushelemtemplateelement.performance critical.",
	"Method": "void pushPair(int v1,int v2){\r\n    if (null == m_map) {\r\n        m_map = new int[m_blocksize];\r\n        m_mapSize = m_blocksize;\r\n    } else {\r\n        if ((m_firstFree + 2) >= m_mapSize) {\r\n            m_mapSize += m_blocksize;\r\n            int[] newMap = new int[m_mapSize];\r\n            System.arraycopy(m_map, 0, newMap, 0, m_firstFree);\r\n            m_map = newMap;\r\n        }\r\n    }\r\n    m_map[m_firstFree] = v1;\r\n    m_map[m_firstFree + 1] = v2;\r\n    m_firstFree += 2;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerHandlerImpl.getTransformer",
	"Comment": "get the transformer associated with this handler, whichis needed in order to set parameters and output properties.",
	"Method": "Transformer getTransformer(){\r\n    return m_transformer;\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.Advapi32Util.getUserName",
	"Comment": "retrieves the name of the user associated with the current thread.",
	"Method": "String getUserName(){\r\n    char[] buffer = new char[128];\r\n    IntByReference len = new IntByReference(buffer.length);\r\n    boolean result = Advapi32.INSTANCE.GetUserNameW(buffer, len);\r\n    if (!result) {\r\n        switch(Kernel32.INSTANCE.GetLastError()) {\r\n            case W32Errors.ERROR_INSUFFICIENT_BUFFER:\r\n                buffer = new char[len.getValue()];\r\n                break;\r\n            default:\r\n                throw new Win32Exception(Native.getLastError());\r\n        }\r\n        result = Advapi32.INSTANCE.GetUserNameW(buffer, len);\r\n    }\r\n    if (!result) {\r\n        throw new Win32Exception(Native.getLastError());\r\n    }\r\n    return Native.toString(buffer);\r\n}"
}, {
	"Path": "com.iluwatar.dao.InMemoryCustomerDaoTest.getNonExistingCustomerId",
	"Comment": "an arbitrary number which does not correspond to an active customer id.",
	"Method": "int getNonExistingCustomerId(){\r\n    return 999;\r\n}"
}, {
	"Path": "hudson.Functions.advertiseHeaders",
	"Comment": "advertises the minimum set of http headers that assist programmaticdiscovery of jenkins.",
	"Method": "void advertiseHeaders(HttpServletResponse rsp){\r\n    Jenkins j = Jenkins.getInstanceOrNull();\r\n    if (j != null) {\r\n        rsp.setHeader(\"X-Hudson\", \"1.395\");\r\n        rsp.setHeader(\"X-Jenkins\", Jenkins.VERSION);\r\n        rsp.setHeader(\"X-Jenkins-Session\", Jenkins.SESSION_HASH);\r\n        TcpSlaveAgentListener tal = j.tcpSlaveAgentListener;\r\n        if (tal != null) {\r\n            int p = tal.getAdvertisedPort();\r\n            rsp.setIntHeader(\"X-Hudson-CLI-Port\", p);\r\n            rsp.setIntHeader(\"X-Jenkins-CLI-Port\", p);\r\n            rsp.setIntHeader(\"X-Jenkins-CLI2-Port\", p);\r\n            rsp.setHeader(\"X-Jenkins-CLI-Host\", TcpSlaveAgentListener.CLI_HOST_NAME);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLChar.isContent",
	"Comment": "returns true if the specified character can be considered content.",
	"Method": "boolean isContent(int c){\r\n    return (c < 0x10000 && (CHARS[c] & MASK_CONTENT) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "jadx.core.utils.BlockUtils.getNextBlock",
	"Comment": "return first successor which not exception handler and not follow loop back edge",
	"Method": "BlockNode getNextBlock(BlockNode block){\r\n    List<BlockNode> s = block.getCleanSuccessors();\r\n    return s.isEmpty() ? null : s.get(0);\r\n}"
}, {
	"Path": "org.java_websocket.drafts.Draft_6455.getByteBufferListSize",
	"Comment": "get the current size of the resulting bytebuffer in the bytebuffer list",
	"Method": "long getByteBufferListSize(){\r\n    long totalSize = 0;\r\n    synchronized (byteBufferList) {\r\n        for (ByteBuffer buffer : byteBufferList) {\r\n            totalSize += buffer.limit();\r\n        }\r\n    }\r\n    return totalSize;\r\n}"
}, {
	"Path": "org.apache.xpath.operations.UnaryOperation.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    m_right.fixupVariables(vars, globalsSize);\r\n}"
}, {
	"Path": "hudson.bugs.seasar.Operation2174Test.testBuildChains",
	"Comment": "tests that configuring a dependency from a freestyle to a maven project actually works.",
	"Method": "void testBuildChains(){\r\n    FreeStyleProject up = createFreeStyleProject(\"up\");\r\n    MavenModuleSet dp = jenkins.createProject(MavenModuleSet.class, \"dp\");\r\n    WebClient webClient = new WebClient();\r\n    webClient.getPage(up, \"configure\");\r\n    up.getPublishersList().add(new BuildTrigger(\"dp\", false));\r\n    configRoundtrip((Item) up);\r\n    BuildTrigger trigger = up.getPublishersList().get(BuildTrigger.class);\r\n    assertEquals(trigger.getChildProjects(up), Collections.singletonList(dp));\r\n    configRoundtrip((Item) dp);\r\n    trigger = up.getPublishersList().get(BuildTrigger.class);\r\n    assertNotNull(trigger);\r\n    assertEquals(trigger.getChildProjects(up), Collections.singletonList(dp));\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.eleminateRedundent",
	"Comment": "method to be called after the all expressions within annode context have been visited.it eliminates redundent expressions by creating a variable in the psuedovarrecipient for each redundent expression, and then rewriting the redundent expression to be a variable reference.",
	"Method": "void eleminateRedundent(ElemTemplateElement psuedoVarRecipient,Vector paths){\r\n    int n = paths.size();\r\n    int numPathsEliminated = 0;\r\n    int numUniquePathsEliminated = 0;\r\n    for (int i = 0; i < n; i++) {\r\n        ExpressionOwner owner = (ExpressionOwner) paths.elementAt(i);\r\n        if (null != owner) {\r\n            int found = findAndEliminateRedundant(i + 1, i, owner, psuedoVarRecipient, paths);\r\n            if (found > 0)\r\n                numUniquePathsEliminated++;\r\n            numPathsEliminated += found;\r\n        }\r\n    }\r\n    eleminateSharedPartialPaths(psuedoVarRecipient, paths);\r\n    if (DIAGNOSE_NUM_PATHS_REDUCED)\r\n        diagnoseNumPaths(paths, numPathsEliminated, numUniquePathsEliminated);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetRoot.recomposeVariables",
	"Comment": "recompose the top level variable and parameter declarations.",
	"Method": "void recomposeVariables(ElemVariable elemVar){\r\n    if (getVariableOrParamComposed(elemVar.getName()) == null) {\r\n        elemVar.setIsTopLevel(true);\r\n        elemVar.setIndex(m_variables.size());\r\n        m_variables.addElement(elemVar);\r\n    }\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.putItem",
	"Comment": "overwrites the existing item by new one.this is a short cut for deleting an existing job and adding a new one.",
	"Method": "void putItem(TopLevelItem item){\r\n    String name = item.getName();\r\n    TopLevelItem old = items.get(name);\r\n    if (old == item)\r\n        return;\r\n    checkPermission(Item.CREATE);\r\n    if (old != null)\r\n        old.delete();\r\n    items.put(name, item);\r\n    ItemListener.fireOnCreated(item);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.isEscapingDisabled",
	"Comment": "tell if the character escaping should be disabled for the current state.",
	"Method": "boolean isEscapingDisabled(){\r\n    return m_disableOutputEscapingStates.peekOrFalse();\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.setStandaloneInternal",
	"Comment": "sets the xsl standalone attribute, but does not remember if this is adefault or explicite setting.",
	"Method": "void setStandaloneInternal(String standalone){\r\n    if (\"yes\".equals(standalone))\r\n        m_standalone = \"yes\";\r\n    else\r\n        m_standalone = \"no\";\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemVariable.appendChild",
	"Comment": "add a child to the child list. if the select attributeis present, an error will be raised.",
	"Method": "ElemTemplateElement appendChild(ElemTemplateElement elem){\r\n    if (m_selectPattern != null) {\r\n        error(XSLTErrorResources.ER_CANT_HAVE_CONTENT_AND_SELECT, new Object[] { \"xsl:\" + this.getNodeName() });\r\n        return null;\r\n    }\r\n    return super.appendChild(elem);\r\n}"
}, {
	"Path": "com.sun.jna.contrib.demo.FilteredTextField.setEntryError",
	"Comment": "sets the message that is displayed when there is an entry error.",
	"Method": "void setEntryError(String entryError){\r\n    this.entryError = entryError;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.ensureSizeOfIndex",
	"Comment": "ensure that the size of the element indexes can hold the information.",
	"Method": "void ensureSizeOfIndex(int namespaceID,int LocalNameID){\r\n    if (null == m_elemIndexes) {\r\n        m_elemIndexes = new int[namespaceID + 20][][];\r\n    } else if (m_elemIndexes.length <= namespaceID) {\r\n        int[][][] indexes = m_elemIndexes;\r\n        m_elemIndexes = new int[namespaceID + 20][][];\r\n        System.arraycopy(indexes, 0, m_elemIndexes, 0, indexes.length);\r\n    }\r\n    int[][] localNameIndex = m_elemIndexes[namespaceID];\r\n    if (null == localNameIndex) {\r\n        localNameIndex = new int[LocalNameID + 100][];\r\n        m_elemIndexes[namespaceID] = localNameIndex;\r\n    } else if (localNameIndex.length <= LocalNameID) {\r\n        int[][] indexes = localNameIndex;\r\n        localNameIndex = new int[LocalNameID + 100][];\r\n        System.arraycopy(indexes, 0, localNameIndex, 0, indexes.length);\r\n        m_elemIndexes[namespaceID] = localNameIndex;\r\n    }\r\n    int[] elemHandles = localNameIndex[LocalNameID];\r\n    if (null == elemHandles) {\r\n        elemHandles = new int[128];\r\n        localNameIndex[LocalNameID] = elemHandles;\r\n        elemHandles[0] = 1;\r\n    } else if (elemHandles.length <= elemHandles[0] + 1) {\r\n        int[] indexes = elemHandles;\r\n        elemHandles = new int[elemHandles[0] + 1024];\r\n        System.arraycopy(indexes, 0, elemHandles, 0, indexes.length);\r\n        localNameIndex[LocalNameID] = elemHandles;\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.lazy.DecoratingIterator.hasNext",
	"Comment": "precomputes and saves the next element of the iterable. null is considered as end of data.",
	"Method": "boolean hasNext(){\r\n    next = computeNext();\r\n    return next != null;\r\n}"
}, {
	"Path": "com.iluwatar.model.view.presenter.FileSelectorStub.getMessagesSent",
	"Comment": "returns the number of messages that were displayed to the user.",
	"Method": "int getMessagesSent(){\r\n    return this.numOfMessageSent;\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.forceLoadClass",
	"Comment": "loads a class through this class loader even if that class is availableon the parent classpath.this ensures that any classes which are loaded by the returned classwill use this classloader.",
	"Method": "Class forceLoadClass(String classname){\r\n    log(\"force loading \" + classname, Project.MSG_DEBUG);\r\n    Class theClass = findLoadedClass(classname);\r\n    if (theClass == null) {\r\n        theClass = findClass(classname);\r\n    }\r\n    return theClass;\r\n}"
}, {
	"Path": "org.apache.xpath.operations.Variable.getIndex",
	"Comment": "set the index for the variable into the stack.for advanced use only.",
	"Method": "int getIndex(){\r\n    return m_index;\r\n}"
}, {
	"Path": "hudson.model.Descriptor.getDescriptorFullUrl",
	"Comment": "gets the url that this descriptor is bound to, relative to the context path.",
	"Method": "String getDescriptorFullUrl(){\r\n    return getCurrentDescriptorByNameUrl() + '/' + getDescriptorUrl();\r\n}"
}, {
	"Path": "hudson.slaves.NodePropertyDescriptor.isApplicableAsGlobal",
	"Comment": "is this node property one where it makes sense to permit it as a global node property.",
	"Method": "boolean isApplicableAsGlobal(){\r\n    return isApplicable(Jenkins.getInstance().getClass());\r\n}"
}, {
	"Path": "org.apache.xml.serializer.NamespaceMappings.pushNamespace",
	"Comment": "declare a mapping of a prefix to namespace uri at the given element depth.",
	"Method": "boolean pushNamespace(String prefix,String uri,int elemDepth){\r\n    if (prefix.startsWith(XML_PREFIX)) {\r\n        return false;\r\n    }\r\n    Stack stack;\r\n    if ((stack = (Stack) m_namespaces.get(prefix)) == null) {\r\n        m_namespaces.put(prefix, stack = new Stack());\r\n    }\r\n    if (!stack.empty()) {\r\n        MappingRecord mr = (MappingRecord) stack.peek();\r\n        if (uri.equals(mr.m_uri) || elemDepth == mr.m_declarationDepth) {\r\n            return false;\r\n        }\r\n    }\r\n    MappingRecord map = new MappingRecord(prefix, uri, elemDepth);\r\n    stack.push(map);\r\n    m_nodeStack.push(map);\r\n    return true;\r\n}"
}, {
	"Path": "hudson.slaves.JNLPLauncherTest.launchJnlpAndVerify",
	"Comment": "launches the jnlp slave agent and asserts its basic operations.",
	"Method": "void launchJnlpAndVerify(Computer c,ArgumentListBuilder args){\r\n    Proc proc = j.createLocalLauncher().launch().cmds(args).stdout(System.out).pwd(\".\").start();\r\n    try {\r\n        for (int i = 0; i < 200; i++) {\r\n            Thread.sleep(100);\r\n            if (!c.isOffline())\r\n                break;\r\n        }\r\n        if (c.isOffline()) {\r\n            System.out.println(c.getLog());\r\n            fail(\"Slave failed to go online\");\r\n        }\r\n        System.err.println(\"Calling task...\");\r\n        assertEquals(\"done\", c.getChannel().callAsync(new NoopTask()).get(5 * 60, TimeUnit.SECONDS));\r\n        System.err.println(\"...done.\");\r\n    } finally {\r\n        proc.kill();\r\n    }\r\n    Thread.sleep(500);\r\n    assertTrue(c.isOffline());\r\n}"
}, {
	"Path": "com.iluwatar.tls.DateFormatCallableTestIncorrectDateFormat.testExceptions",
	"Comment": "test exceptions after the run of dateformatrunnalbe. a correct run should deliver 5 times thesame exception",
	"Method": "void testExceptions(){\r\n    assertEquals(expectedExceptions, result.getExceptionList());\r\n}"
}, {
	"Path": "hudson.security.AccessDeniedException2.reportAsHeaders",
	"Comment": "reports the details of the access failure in http headers to assist diagnosis.",
	"Method": "void reportAsHeaders(HttpServletResponse rsp){\r\n    rsp.addHeader(\"X-You-Are-Authenticated-As\", authentication.getName());\r\n    if (REPORT_GROUP_HEADERS) {\r\n        for (GrantedAuthority auth : authentication.getAuthorities()) {\r\n            rsp.addHeader(\"X-You-Are-In-Group\", auth.getAuthority());\r\n        }\r\n    } else {\r\n        rsp.addHeader(\"X-You-Are-In-Group-Disabled\", \"JENKINS-39402: use -Dhudson.security.AccessDeniedException2.REPORT_GROUP_HEADERS=true or use /whoAmI to diagnose\");\r\n    }\r\n    rsp.addHeader(\"X-Required-Permission\", permission.getId());\r\n    for (Permission p = permission.impliedBy; p != null; p = p.impliedBy) {\r\n        rsp.addHeader(\"X-Permission-Implied-By\", p.getId());\r\n    }\r\n}"
}, {
	"Path": "hudson.cli.DisablePluginCommand.printResult",
	"Comment": "print the result of a plugin disablement with the indent passed.",
	"Method": "void printResult(PluginWrapper.PluginDisableResult oneResult,int indent){\r\n    PluginWrapper.PluginDisableStatus status = oneResult.getStatus();\r\n    if (quiet && (PluginWrapper.PluginDisableStatus.DISABLED.equals(status) || PluginWrapper.PluginDisableStatus.ALREADY_DISABLED.equals(status))) {\r\n        return;\r\n    }\r\n    printIndented(indent, Messages.DisablePluginCommand_StatusMessage(oneResult.getPlugin(), oneResult.getStatus(), oneResult.getMessage()));\r\n    if (oneResult.getDependantsDisableStatus().size() > 0) {\r\n        indent += INDENT_SPACE;\r\n        for (PluginWrapper.PluginDisableResult oneDependantResult : oneResult.getDependantsDisableStatus()) {\r\n            printResult(oneDependantResult, indent);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "hudson.UDPBroadcastThreadTest.receiveAndVerify",
	"Comment": "reads a reply from the socket and makes sure its shape is in order.",
	"Method": "void receiveAndVerify(DatagramSocket s){\r\n    DatagramPacket p = new DatagramPacket(new byte[1024], 1024);\r\n    s.receive(p);\r\n    String xml = new String(p.getData(), 0, p.getLength(), \"UTF-8\");\r\n    System.out.println(xml);\r\n    SAXParserFactory spf = SAXParserFactory.newInstance();\r\n    spf.setNamespaceAware(true);\r\n    spf.newSAXParser().parse(new InputSource(new StringReader(xml)), new DefaultHandler());\r\n}"
}, {
	"Path": "com.iluwatar.builder.HeroTest.testMissingName",
	"Comment": "test if we get the expected exception when trying to create a hero without a name",
	"Method": "void testMissingName(){\r\n    assertThrows(IllegalArgumentException.class, () -> new Hero.Builder(Profession.THIEF, null));\r\n}"
}, {
	"Path": "hudson.widgets.HistoryWidget.doAjax",
	"Comment": "handles ajax requests from browsers to update build history.",
	"Method": "void doAjax(StaplerRequest req,StaplerResponse rsp,String n){\r\n    rsp.setContentType(\"text/html;charset=UTF-8\");\r\n    List<T> items = new ArrayList<T>();\r\n    if (n != null) {\r\n        String nn = null;\r\n        for (T t : baseList) {\r\n            if (adapter.compare(t, n) >= 0) {\r\n                items.add(t);\r\n                if (adapter.isBuilding(t))\r\n                    nn = adapter.getKey(t);\r\n            } else\r\n                break;\r\n        }\r\n        if (nn == null) {\r\n            if (items.isEmpty()) {\r\n                nn = n;\r\n            } else {\r\n                nn = adapter.getNextKey(adapter.getKey(items.get(0)));\r\n            }\r\n        }\r\n        baseList = items;\r\n        rsp.setHeader(\"n\", nn);\r\n        firstTransientBuildKey = nn;\r\n    }\r\n    HistoryPageFilter page = getHistoryPageFilter();\r\n    req.getView(page, \"ajaxBuildHistory.jelly\").forward(req, rsp);\r\n}"
}, {
	"Path": "org.apache.xml.utils.DOMHelper.isNodeTheSame",
	"Comment": "use dtmnodeproxy to determine whether two nodes are the same.",
	"Method": "boolean isNodeTheSame(Node node1,Node node2){\r\n    if (node1 instanceof DTMNodeProxy && node2 instanceof DTMNodeProxy)\r\n        return ((DTMNodeProxy) node1).equals((DTMNodeProxy) node2);\r\n    else\r\n        return (node1 == node2);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetRoot.shouldCheckWhitespace",
	"Comment": "check to see if the caller should bother with check forwhitespace nodes.",
	"Method": "boolean shouldCheckWhitespace(){\r\n    return null != m_whiteSpaceInfoList;\r\n}"
}, {
	"Path": "com.iluwatar.poison.pill.ConsumerTest.createMessage",
	"Comment": "create a new message from the given sender with the given message body",
	"Method": "Message createMessage(String sender,String message){\r\n    final SimpleMessage msg = new SimpleMessage();\r\n    msg.addHeader(Message.Headers.SENDER, sender);\r\n    msg.addHeader(Message.Headers.DATE, LocalDateTime.now().toString());\r\n    msg.setBody(message);\r\n    return msg;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.Stylesheet.getStylesheetRoot",
	"Comment": "get the root of the stylesheet, where all the tables commonto all stylesheets are kept.",
	"Method": "StylesheetRoot getStylesheetRoot(){\r\n    return m_stylesheetRoot;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.WalkerFactory.isOptimizableForDescendantIterator",
	"Comment": "special purpose function to see if we can optimize the pattern for a descendantiterator.",
	"Method": "boolean isOptimizableForDescendantIterator(Compiler compiler,int stepOpCodePos,int stepIndex){\r\n    int stepType;\r\n    int stepCount = 0;\r\n    boolean foundDorDS = false;\r\n    boolean foundSelf = false;\r\n    boolean foundDS = false;\r\n    int nodeTestType = OpCodes.NODETYPE_NODE;\r\n    while (OpCodes.ENDOP != (stepType = compiler.getOp(stepOpCodePos))) {\r\n        if (nodeTestType != OpCodes.NODETYPE_NODE && nodeTestType != OpCodes.NODETYPE_ROOT)\r\n            return false;\r\n        stepCount++;\r\n        if (stepCount > 3)\r\n            return false;\r\n        boolean mightBeProximate = mightBeProximate(compiler, stepOpCodePos, stepType);\r\n        if (mightBeProximate)\r\n            return false;\r\n        switch(stepType) {\r\n            case OpCodes.FROM_FOLLOWING:\r\n            case OpCodes.FROM_FOLLOWING_SIBLINGS:\r\n            case OpCodes.FROM_PRECEDING:\r\n            case OpCodes.FROM_PRECEDING_SIBLINGS:\r\n            case OpCodes.FROM_PARENT:\r\n            case OpCodes.OP_VARIABLE:\r\n            case OpCodes.OP_EXTFUNCTION:\r\n            case OpCodes.OP_FUNCTION:\r\n            case OpCodes.OP_GROUP:\r\n            case OpCodes.FROM_NAMESPACE:\r\n            case OpCodes.FROM_ANCESTORS:\r\n            case OpCodes.FROM_ANCESTORS_OR_SELF:\r\n            case OpCodes.FROM_ATTRIBUTES:\r\n            case OpCodes.MATCH_ATTRIBUTE:\r\n            case OpCodes.MATCH_ANY_ANCESTOR:\r\n            case OpCodes.MATCH_IMMEDIATE_ANCESTOR:\r\n                return false;\r\n            case OpCodes.FROM_ROOT:\r\n                if (1 != stepCount)\r\n                    return false;\r\n                break;\r\n            case OpCodes.FROM_CHILDREN:\r\n                if (!foundDS && !(foundDorDS && foundSelf))\r\n                    return false;\r\n                break;\r\n            case OpCodes.FROM_DESCENDANTS_OR_SELF:\r\n                foundDS = true;\r\n            case OpCodes.FROM_DESCENDANTS:\r\n                if (3 == stepCount)\r\n                    return false;\r\n                foundDorDS = true;\r\n                break;\r\n            case OpCodes.FROM_SELF:\r\n                if (1 != stepCount)\r\n                    return false;\r\n                foundSelf = true;\r\n                break;\r\n            default:\r\n                throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[] { Integer.toString(stepType) }));\r\n        }\r\n        nodeTestType = compiler.getStepTestType(stepOpCodePos);\r\n        int nextStepOpCodePos = compiler.getNextStepPos(stepOpCodePos);\r\n        if (nextStepOpCodePos < 0)\r\n            break;\r\n        if (OpCodes.ENDOP != compiler.getOp(nextStepOpCodePos)) {\r\n            if (compiler.countPredicates(stepOpCodePos) > 0) {\r\n                return false;\r\n            }\r\n        }\r\n        stepOpCodePos = nextStepOpCodePos;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "hudson.lifecycle.SolarisSMFLifecycle.restart",
	"Comment": "in smf managed environment, just commit a suicide and the service will be restarted by smf.",
	"Method": "void restart(){\r\n    Jenkins jenkins = Jenkins.getInstanceOrNull();\r\n    try {\r\n        if (jenkins != null) {\r\n            jenkins.cleanUp();\r\n        }\r\n    } catch (Exception e) {\r\n        LOGGER.log(Level.SEVERE, \"Failed to clean up. Restart will continue.\", e);\r\n    }\r\n    System.exit(0);\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprWalker.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    super.fixupVariables(vars, globalsSize);\r\n    m_expr.fixupVariables(vars, globalsSize);\r\n}"
}, {
	"Path": "com.winterbe.java8.samples.misc.CheckedFunctions.predicate",
	"Comment": "return a predicate which rethrows possible checked exceptions as runtime exception.",
	"Method": "Predicate<T> predicate(CheckedPredicate<T> predicate){\r\n    return input -> {\r\n        try {\r\n            return predicate.test(input);\r\n        } catch (Exception e) {\r\n            if (e instanceof RuntimeException) {\r\n                throw (RuntimeException) e;\r\n            }\r\n            throw new RuntimeException(e);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncStringLength.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    return new XNumber(getArg0AsString(xctxt).length());\r\n}"
}, {
	"Path": "org.apache.xpath.axes.ReverseAxesWalker.detach",
	"Comment": "detaches the walker from the set which it iterated over, releasingany computational resources and placing the iterator in the invalidstate.",
	"Method": "void detach(){\r\n    m_iterator = null;\r\n    super.detach();\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.getPlugin",
	"Comment": "gets the plugin object from its class.this allows easy storage of plugin information in the plugin singleton withoutevery plugin reimplementing the singleton pattern.",
	"Method": "Plugin getPlugin(String shortName,P getPlugin,Class<P> clazz){\r\n    PluginWrapper p = pluginManager.getPlugin(clazz);\r\n    if (p == null)\r\n        return null;\r\n    return (P) p.getPlugin();\r\n}"
}, {
	"Path": "hudson.model.NodeTest.testGetAssignedLabelWhenLabelRemoveFromProject",
	"Comment": "verify that when a label is removed from a job that the tied job count does not include the removed job.",
	"Method": "void testGetAssignedLabelWhenLabelRemoveFromProject(){\r\n    final Node node = j.createOnlineSlave();\r\n    node.setLabelString(\"label1\");\r\n    MavenModuleSet project = j.jenkins.createProject(MavenModuleSet.class, \"p\");\r\n    final Label label = j.jenkins.getLabel(\"label1\");\r\n    project.setAssignedLabel(label);\r\n    j.assertBuildStatus(Result.FAILURE, project.scheduleBuild2(0).get());\r\n    project.setAssignedLabel(null);\r\n    label.reset();\r\n    assertEquals(\"Label1 should have no tied jobs after the job label was removed.\", 0, label.getTiedJobCount());\r\n}"
}, {
	"Path": "hudson.util.FormFillFailure.withSelectionCleared",
	"Comment": "flags this failure as requiring that the select options should be cleared out.",
	"Method": "FormFillFailure withSelectionCleared(){\r\n    this.selectionCleared = true;\r\n    return this;\r\n}"
}, {
	"Path": "jenkins.model.ParameterizedJobMixIn.getBuildCause",
	"Comment": "computes the build cause, using remotecause or usercause as appropriate.",
	"Method": "CauseAction getBuildCause(ParameterizedJob job,StaplerRequest req){\r\n    Cause cause;\r\n    @SuppressWarnings(\"deprecation\")\r\n    hudson.model.BuildAuthorizationToken authToken = job.getAuthToken();\r\n    if (authToken != null && authToken.getToken() != null && req.getParameter(\"token\") != null) {\r\n        String causeText = req.getParameter(\"cause\");\r\n        cause = new Cause.RemoteCause(req.getRemoteAddr(), causeText);\r\n    } else {\r\n        cause = new Cause.UserIdCause();\r\n    }\r\n    return new CauseAction(cause);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.TransformerFactoryImpl.newTemplatesHandler",
	"Comment": "create a new transformer object that performs a copyof the source to the result.",
	"Method": "TemplatesHandler newTemplatesHandler(){\r\n    return new StylesheetHandler(this);\r\n}"
}, {
	"Path": "com.iluwatar.memento.StarTest.testSetMemento",
	"Comment": "verify some stage of a dying sun, but go back in time to test the memento",
	"Method": "void testSetMemento(){\r\n    final Star star = new Star(StarType.SUN, 1, 2);\r\n    final StarMemento firstMemento = star.getMemento();\r\n    assertEquals(\"sun age: 1 years mass: 2 tons\", star.toString());\r\n    star.timePasses();\r\n    final StarMemento secondMemento = star.getMemento();\r\n    assertEquals(\"red giant age: 2 years mass: 16 tons\", star.toString());\r\n    star.timePasses();\r\n    final StarMemento thirdMemento = star.getMemento();\r\n    assertEquals(\"white dwarf age: 4 years mass: 128 tons\", star.toString());\r\n    star.timePasses();\r\n    assertEquals(\"supernova age: 8 years mass: 1024 tons\", star.toString());\r\n    star.setMemento(thirdMemento);\r\n    assertEquals(\"white dwarf age: 4 years mass: 128 tons\", star.toString());\r\n    star.timePasses();\r\n    assertEquals(\"supernova age: 8 years mass: 1024 tons\", star.toString());\r\n    star.setMemento(secondMemento);\r\n    assertEquals(\"red giant age: 2 years mass: 16 tons\", star.toString());\r\n    star.setMemento(firstMemento);\r\n    assertEquals(\"sun age: 1 years mass: 2 tons\", star.toString());\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToXMLStream.getXMLVersion",
	"Comment": "this method checks for the xml version of output document.if xml version of output document is not specified, then output document is of version xml 1.0.if xml version of output doucment is specified, but it is not either xml 1.0 or xml 1.1, a warning message is generated, the xml version ofoutput document is set to xml 1.0 and processing continues.",
	"Method": "String getXMLVersion(){\r\n    String xmlVersion = getVersion();\r\n    if (xmlVersion == null || xmlVersion.equals(XMLVERSION10)) {\r\n        xmlVersion = XMLVERSION10;\r\n    } else if (xmlVersion.equals(XMLVERSION11)) {\r\n        xmlVersion = XMLVERSION11;\r\n    } else {\r\n        String msg = Utils.messages.createMessage(MsgKey.ER_XML_VERSION_NOT_SUPPORTED, new Object[] { xmlVersion });\r\n        try {\r\n            Transformer tran = super.getTransformer();\r\n            ErrorListener errHandler = tran.getErrorListener();\r\n            if (null != errHandler && m_sourceLocator != null)\r\n                errHandler.warning(new TransformerException(msg, m_sourceLocator));\r\n            else\r\n                System.out.println(msg);\r\n        } catch (Exception e) {\r\n        }\r\n        xmlVersion = XMLVERSION10;\r\n    }\r\n    return xmlVersion;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.Stylesheet.setStylesheetRoot",
	"Comment": "set the root of the stylesheet, where all the tables commonto all stylesheets are kept.",
	"Method": "void setStylesheetRoot(StylesheetRoot v){\r\n    m_stylesheetRoot = v;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.XML11Char.isXML11Space",
	"Comment": "returns true if the specified character is a space characteras amdended in the xml 1.1 specification.",
	"Method": "boolean isXML11Space(int c){\r\n    return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_SPACE) != 0);\r\n}"
}, {
	"Path": "org.apache.xpath.Expression.exprGetChild",
	"Comment": "this method returns a child node.the children are numbered from zero, left to right.",
	"Method": "ExpressionNode exprGetChild(int i){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLStringDefault.equalsIgnoreCase",
	"Comment": "compares this string to another string,ignoring case considerations.two strings are considered equalignoring case if they are of the same length, and correspondingcharacters in the two strings are equal ignoring case.",
	"Method": "boolean equalsIgnoreCase(String anotherString){\r\n    return m_str.equalsIgnoreCase(anotherString);\r\n}"
}, {
	"Path": "jenkins.org.apache.commons.validator.routines.RegexValidator.match",
	"Comment": "validate a value against the set of regular expressionsreturning the array of matched groups.",
	"Method": "String[] match(String value){\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    for (int i = 0; i < patterns.length; i++) {\r\n        Matcher matcher = patterns[i].matcher(value);\r\n        if (matcher.matches()) {\r\n            int count = matcher.groupCount();\r\n            String[] groups = new String[count];\r\n            for (int j = 0; j < count; j++) {\r\n                groups[j] = matcher.group(j + 1);\r\n            }\r\n            return groups;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.java_websocket.WebSocketImpl.closeConnectionDueToInternalServerError",
	"Comment": "close the connection if there was a server error by a runtimeexception",
	"Method": "void closeConnectionDueToInternalServerError(RuntimeException exception){\r\n    write(generateHttpResponseDueToError(500));\r\n    flushAndClose(CloseFrame.NEVER_CONNECTED, exception.getMessage(), false);\r\n}"
}, {
	"Path": "hudson.model.Computer.buildEnvironment",
	"Comment": "creates an environment variable override to be used for launching processes on this node.",
	"Method": "EnvVars buildEnvironment(TaskListener listener){\r\n    EnvVars env = new EnvVars();\r\n    Node node = getNode();\r\n    if (node == null)\r\n        return env;\r\n    for (NodeProperty nodeProperty : Jenkins.getInstance().getGlobalNodeProperties()) {\r\n        nodeProperty.buildEnvVars(env, listener);\r\n    }\r\n    for (NodeProperty nodeProperty : node.getNodeProperties()) {\r\n        nodeProperty.buildEnvVars(env, listener);\r\n    }\r\n    String rootUrl = Jenkins.getInstance().getRootUrl();\r\n    if (rootUrl != null) {\r\n        env.put(\"HUDSON_URL\", rootUrl);\r\n        env.put(\"JENKINS_URL\", rootUrl);\r\n    }\r\n    return env;\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.doCheckDisplayName",
	"Comment": "checks to see if the candidate displayname collides with anyexisting display names or project names",
	"Method": "FormValidation doCheckDisplayName(String displayName,String jobName){\r\n    displayName = displayName.trim();\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.log(Level.FINE, \"Current job name is \" + jobName);\r\n    }\r\n    if (!isNameUnique(displayName, jobName)) {\r\n        return FormValidation.warning(Messages.Jenkins_CheckDisplayName_NameNotUniqueWarning(displayName));\r\n    } else if (!isDisplayNameUnique(displayName, jobName)) {\r\n        return FormValidation.warning(Messages.Jenkins_CheckDisplayName_DisplayNameNotUniqueWarning(displayName));\r\n    } else {\r\n        return FormValidation.ok();\r\n    }\r\n}"
}, {
	"Path": "hudson.util.ArgumentListBuilder.toMaskArray",
	"Comment": "returns an array of booleans where the masked arguments are marked as true",
	"Method": "boolean[] toMaskArray(){\r\n    boolean[] mask = new boolean[args.size()];\r\n    for (int i = 0; i < mask.length; i++) mask[i] = this.mask.get(i);\r\n    return mask;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.Stylesheet.getStylesheet",
	"Comment": "get the owning stylesheet.this looks up theinheritance chain until it calls getstylesheeton a stylesheet object, which will return itself.",
	"Method": "Stylesheet getStylesheet(){\r\n    return this;\r\n}"
}, {
	"Path": "com.iluwatar.promise.Promise.fulfillInAsync",
	"Comment": "executes the task using the executor in other thread and fulfills the promise returnedonce the task completes either successfully or with an exception.",
	"Method": "Promise<T> fulfillInAsync(Callable<T> task,Executor executor){\r\n    executor.execute(() -> {\r\n        try {\r\n            fulfill(task.call());\r\n        } catch (Exception ex) {\r\n            fulfillExceptionally(ex);\r\n        }\r\n    });\r\n    return this;\r\n}"
}, {
	"Path": "hudson.Util.resolveSymlink",
	"Comment": "resolves symlink, if the given file is a symlink. otherwise return null.if the resolution fails, report an error.",
	"Method": "String resolveSymlink(File link,TaskListener listener,String resolveSymlink,File link){\r\n    try {\r\n        Path path = fileToPath(link);\r\n        return Files.readSymbolicLink(path).toString();\r\n    } catch (UnsupportedOperationException | FileSystemException x) {\r\n        return null;\r\n    } catch (IOException x) {\r\n        throw x;\r\n    } catch (Exception x) {\r\n        throw new IOException(x);\r\n    }\r\n}"
}, {
	"Path": "jenkins.security.apitoken.ApiTokenStore.searchMatch",
	"Comment": "search in the store if there is a matching token that has the same secret.",
	"Method": "HashedToken searchMatch(String plainSecret){\r\n    byte[] hashedBytes = plainSecretToHashBytes(plainSecret);\r\n    for (HashedToken token : tokenList) {\r\n        if (token.match(hashedBytes)) {\r\n            return token;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xml.utils.ObjectFactory.findClassLoader",
	"Comment": "figure out which classloader to use.for jdk 1.2 and later usethe context classloader.",
	"Method": "ClassLoader findClassLoader(){\r\n    SecuritySupport ss = SecuritySupport.getInstance();\r\n    ClassLoader context = ss.getContextClassLoader();\r\n    ClassLoader system = ss.getSystemClassLoader();\r\n    ClassLoader chain = system;\r\n    while (true) {\r\n        if (context == chain) {\r\n            ClassLoader current = ObjectFactory.class.getClassLoader();\r\n            chain = system;\r\n            while (true) {\r\n                if (current == chain) {\r\n                    return system;\r\n                }\r\n                if (chain == null) {\r\n                    break;\r\n                }\r\n                chain = ss.getParentClassLoader(chain);\r\n            }\r\n            return current;\r\n        }\r\n        if (chain == null) {\r\n            break;\r\n        }\r\n        chain = ss.getParentClassLoader(chain);\r\n    }\r\n    ;\r\n    return context;\r\n}"
}, {
	"Path": "com.iluwatar.promise.App.calculateLineCount",
	"Comment": "calculate the line count and when that promise is fulfilled, consume the resultin a consumer",
	"Method": "void calculateLineCount(){\r\n    countLines().thenAccept(count -> {\r\n        LOGGER.info(\"Line count is: {}\", count);\r\n        taskCompleted();\r\n    });\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ObjectFactory.newInstance",
	"Comment": "create an instance of a class using the specified classloader",
	"Method": "Object newInstance(String className,ClassLoader cl,boolean doFallback){\r\n    try {\r\n        Class providerClass = findProviderClass(className, cl, doFallback);\r\n        Object instance = providerClass.newInstance();\r\n        debugPrintln(\"created new instance of \" + providerClass + \" using ClassLoader: \" + cl);\r\n        return instance;\r\n    } catch (ClassNotFoundException x) {\r\n        throw new ConfigurationError(\"Provider \" + className + \" not found\", x);\r\n    } catch (Exception x) {\r\n        throw new ConfigurationError(\"Provider \" + className + \" could not be instantiated: \" + x, x);\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.event.queue.Audio.init",
	"Comment": "starts the thread for the update method pattern if it was not started previously.also when the thread is is ready initializes the indexes of the queue",
	"Method": "void init(){\r\n    if (updateThread == null) {\r\n        updateThread = new Thread(() -> {\r\n            while (!Thread.currentThread().isInterrupted()) {\r\n                update();\r\n            }\r\n        });\r\n    }\r\n    startThread();\r\n}"
}, {
	"Path": "hudson.Functions.getRelativeDisplayNameFrom",
	"Comment": "gets the relative display name to the given item from the specified group.",
	"Method": "String getRelativeDisplayNameFrom(Item p,ItemGroup g){\r\n    return getRelativeNameFrom(p, g, true);\r\n}"
}, {
	"Path": "ciphers.AES.mixColumns",
	"Comment": "applies the rijndael mixcolumns to the input and returns the result.",
	"Method": "BigInteger mixColumns(BigInteger ciphertext){\r\n    int[] cells = splitBlockIntoCells(ciphertext);\r\n    int[] outputCells = new int[16];\r\n    for (int i = 0; i < 4; i++) {\r\n        int[] row = { cells[i * 4], cells[i * 4 + 1], cells[i * 4 + 2], cells[i * 4 + 3] };\r\n        outputCells[i * 4] = MULT2[row[0]] ^ MULT3[row[1]] ^ row[2] ^ row[3];\r\n        outputCells[i * 4 + 1] = row[0] ^ MULT2[row[1]] ^ MULT3[row[2]] ^ row[3];\r\n        outputCells[i * 4 + 2] = row[0] ^ row[1] ^ MULT2[row[2]] ^ MULT3[row[3]];\r\n        outputCells[i * 4 + 3] = MULT3[row[0]] ^ row[1] ^ row[2] ^ MULT2[row[3]];\r\n    }\r\n    return mergeCellsIntoBlock(outputCells);\r\n}"
}, {
	"Path": "hudson.PluginWrapper.hasOptionalDependants",
	"Comment": "does this plugin have anything that depends optionally on it.",
	"Method": "boolean hasOptionalDependants(){\r\n    return !optionalDependants.isEmpty();\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.startDTD",
	"Comment": "report the start of dtd declarations, if any.any declarations are assumed to be in the internal subset unlessotherwise indicated.",
	"Method": "void startDTD(String name,String publicId,String systemId){\r\n    setDoctypeSystem(systemId);\r\n    setDoctypePublic(publicId);\r\n    m_elemContext.m_elementName = name;\r\n    m_inDoctype = true;\r\n}"
}, {
	"Path": "jadx.core.dex.regions.loops.LoopRegion.setPreCondition",
	"Comment": "set instructions which must be executed before condition in every loop",
	"Method": "void setPreCondition(BlockNode preCondition){\r\n    this.preCondition = preCondition;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.TransformerFactoryImpl.getAttribute",
	"Comment": "allows the user to retrieve specific attributes on the underlyingimplementation.",
	"Method": "Object getAttribute(String name){\r\n    if (name.equals(FEATURE_INCREMENTAL)) {\r\n        return new Boolean(m_incremental);\r\n    } else if (name.equals(FEATURE_OPTIMIZE)) {\r\n        return new Boolean(m_optimize);\r\n    } else if (name.equals(FEATURE_SOURCE_LOCATION)) {\r\n        return new Boolean(m_source_location);\r\n    } else\r\n        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_ATTRIB_VALUE_NOT_RECOGNIZED, new Object[] { name }));\r\n}"
}, {
	"Path": "hudson.scm.ChangeLogAnnotator.register",
	"Comment": "registers this annotator, so that hudson starts using this objectfor adding markup.",
	"Method": "void register(){\r\n    all().add(this);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.XUnresolvedVariableSimple.getTypeString",
	"Comment": "given a request type, return the equivalent string.for diagnostic purposes.",
	"Method": "String getTypeString(){\r\n    return \"XUnresolvedVariableSimple (\" + object().getClass().getName() + \")\";\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.LSSerializerImpl.write",
	"Comment": "serializes the specified node to the specified lsoutput and returns true if the node was successfully serialized.",
	"Method": "boolean write(Node nodeArg,LSOutput destination){\r\n    if (destination == null) {\r\n        String msg = Utils.messages.createMessage(MsgKey.ER_NO_OUTPUT_SPECIFIED, null);\r\n        if (fDOMErrorHandler != null) {\r\n            fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, msg, MsgKey.ER_NO_OUTPUT_SPECIFIED));\r\n        }\r\n        throw new LSException(LSException.SERIALIZE_ERR, msg);\r\n    }\r\n    if (nodeArg == null) {\r\n        return false;\r\n    }\r\n    Serializer serializer = fXMLSerializer;\r\n    serializer.reset();\r\n    if (nodeArg != fVisitedNode) {\r\n        String xmlVersion = getXMLVersion(nodeArg);\r\n        fEncoding = destination.getEncoding();\r\n        if (fEncoding == null) {\r\n            fEncoding = getInputEncoding(nodeArg);\r\n            fEncoding = fEncoding != null ? fEncoding : getXMLEncoding(nodeArg) == null ? \"UTF-8\" : getXMLEncoding(nodeArg);\r\n        }\r\n        if (!Encodings.isRecognizedEncoding(fEncoding)) {\r\n            String msg = Utils.messages.createMessage(MsgKey.ER_UNSUPPORTED_ENCODING, null);\r\n            if (fDOMErrorHandler != null) {\r\n                fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, msg, MsgKey.ER_UNSUPPORTED_ENCODING));\r\n            }\r\n            throw new LSException(LSException.SERIALIZE_ERR, msg);\r\n        }\r\n        serializer.getOutputFormat().setProperty(\"version\", xmlVersion);\r\n        fDOMConfigProperties.setProperty(DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.S_XML_VERSION, xmlVersion);\r\n        fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_ENCODING, fEncoding);\r\n        if ((nodeArg.getNodeType() != Node.DOCUMENT_NODE || nodeArg.getNodeType() != Node.ELEMENT_NODE || nodeArg.getNodeType() != Node.ENTITY_NODE) && ((fFeatures & XMLDECL) != 0)) {\r\n            fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL, DOMConstants.DOM3_DEFAULT_FALSE);\r\n        }\r\n        fVisitedNode = nodeArg;\r\n    }\r\n    fXMLSerializer.setOutputFormat(fDOMConfigProperties);\r\n    try {\r\n        Writer writer = destination.getCharacterStream();\r\n        if (writer == null) {\r\n            OutputStream outputStream = destination.getByteStream();\r\n            if (outputStream == null) {\r\n                String uri = destination.getSystemId();\r\n                if (uri == null) {\r\n                    String msg = Utils.messages.createMessage(MsgKey.ER_NO_OUTPUT_SPECIFIED, null);\r\n                    if (fDOMErrorHandler != null) {\r\n                        fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, msg, MsgKey.ER_NO_OUTPUT_SPECIFIED));\r\n                    }\r\n                    throw new LSException(LSException.SERIALIZE_ERR, msg);\r\n                } else {\r\n                    String absoluteURI = SystemIDResolver.getAbsoluteURI(uri);\r\n                    URL url = new URL(absoluteURI);\r\n                    OutputStream urlOutStream = null;\r\n                    String protocol = url.getProtocol();\r\n                    String host = url.getHost();\r\n                    if (protocol.equalsIgnoreCase(\"file\") && (host == null || host.length() == 0 || host.equals(\"localhost\"))) {\r\n                        urlOutStream = new FileOutputStream(getPathWithoutEscapes(url.getPath()));\r\n                    } else {\r\n                        URLConnection urlCon = url.openConnection();\r\n                        urlCon.setDoInput(false);\r\n                        urlCon.setDoOutput(true);\r\n                        urlCon.setUseCaches(false);\r\n                        urlCon.setAllowUserInteraction(false);\r\n                        if (urlCon instanceof HttpURLConnection) {\r\n                            HttpURLConnection httpCon = (HttpURLConnection) urlCon;\r\n                            httpCon.setRequestMethod(\"PUT\");\r\n                        }\r\n                        urlOutStream = urlCon.getOutputStream();\r\n                    }\r\n                    serializer.setOutputStream(urlOutStream);\r\n                }\r\n            } else {\r\n                serializer.setOutputStream(outputStream);\r\n            }\r\n        } else {\r\n            serializer.setWriter(writer);\r\n        }\r\n        if (fDOMSerializer == null) {\r\n            fDOMSerializer = (DOM3Serializer) serializer.asDOM3Serializer();\r\n        }\r\n        if (fDOMErrorHandler != null) {\r\n            fDOMSerializer.setErrorHandler(fDOMErrorHandler);\r\n        }\r\n        if (fSerializerFilter != null) {\r\n            fDOMSerializer.setNodeFilter(fSerializerFilter);\r\n        }\r\n        fDOMSerializer.setNewLine(fEndOfLine.toCharArray());\r\n        fDOMSerializer.serializeDOM3(nodeArg);\r\n    } catch (UnsupportedEncodingException ue) {\r\n        String msg = Utils.messages.createMessage(MsgKey.ER_UNSUPPORTED_ENCODING, null);\r\n        if (fDOMErrorHandler != null) {\r\n            fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, msg, MsgKey.ER_UNSUPPORTED_ENCODING, ue));\r\n        }\r\n        throw (LSException) createLSException(LSException.SERIALIZE_ERR, ue).fillInStackTrace();\r\n    } catch (LSException lse) {\r\n        throw lse;\r\n    } catch (RuntimeException e) {\r\n        throw (LSException) createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();\r\n    } catch (Exception e) {\r\n        if (fDOMErrorHandler != null) {\r\n            fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, e.getMessage(), null, e));\r\n        }\r\n        throw (LSException) createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.buildFinished",
	"Comment": "cleans up any resources held by this classloader at the endof a build.",
	"Method": "void buildFinished(BuildEvent event){\r\n    cleanup();\r\n}"
}, {
	"Path": "hudson.model.AbstractProjectTest.configDotXmlSubmissionToDifferentType",
	"Comment": "trying to post to config.xml by a different job type should fail.",
	"Method": "void configDotXmlSubmissionToDifferentType(){\r\n    TestPluginManager tpm = (TestPluginManager) j.jenkins.pluginManager;\r\n    tpm.installDetachedPlugin(\"javadoc\");\r\n    tpm.installDetachedPlugin(\"junit\");\r\n    tpm.installDetachedPlugin(\"display-url-api\");\r\n    tpm.installDetachedPlugin(\"mailer\");\r\n    tpm.installDetachedPlugin(\"maven-plugin\");\r\n    j.jenkins.setCrumbIssuer(null);\r\n    FreeStyleProject p = j.createFreeStyleProject();\r\n    HttpURLConnection con = postConfigDotXml(p, \"<maven2-moduleset />\");\r\n    assertEquals(500, con.getResponseCode());\r\n    String msg = IOUtils.toString(con.getErrorStream());\r\n    System.out.println(msg);\r\n    assertThat(msg, allOf(containsString(FreeStyleProject.class.getName()), containsString(MavenModuleSet.class.getName())));\r\n    con = postConfigDotXml(p, \"<project />\");\r\n    assertEquals(200, con.getResponseCode());\r\n}"
}, {
	"Path": "jadx.core.dex.nodes.BlockNode.cleanSuccessors",
	"Comment": "return all successor which are not exception handler or followed by loop back edge",
	"Method": "List<BlockNode> cleanSuccessors(BlockNode block){\r\n    List<BlockNode> sucList = block.getSuccessors();\r\n    if (sucList.isEmpty()) {\r\n        return sucList;\r\n    }\r\n    List<BlockNode> toRemove = new ArrayList(sucList.size());\r\n    for (BlockNode b : sucList) {\r\n        if (BlockUtils.isBlockMustBeCleared(b)) {\r\n            toRemove.add(b);\r\n        }\r\n    }\r\n    if (block.contains(AFlag.LOOP_END)) {\r\n        List<LoopInfo> loops = block.getAll(AType.LOOP);\r\n        for (LoopInfo loop : loops) {\r\n            toRemove.add(loop.getStart());\r\n        }\r\n    }\r\n    IgnoreEdgeAttr ignoreEdgeAttr = block.get(AType.IGNORE_EDGE);\r\n    if (ignoreEdgeAttr != null) {\r\n        toRemove.addAll(ignoreEdgeAttr.getBlocks());\r\n    }\r\n    if (toRemove.isEmpty()) {\r\n        return sucList;\r\n    }\r\n    List<BlockNode> result = new ArrayList(sucList);\r\n    result.removeAll(toRemove);\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.xalan.extensions.ExtensionNamespacesManager.getExtensions",
	"Comment": "get the vector of extension namespaces. used to providethe extensions table access to a list of extensionnamespaces encountered during composition of a stylesheet.",
	"Method": "Vector getExtensions(){\r\n    return m_extensions;\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.setURIResolver",
	"Comment": "set the uriresolver associated with this execution context.",
	"Method": "void setURIResolver(URIResolver resolver){\r\n    m_uriResolver = resolver;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.getDTMManager",
	"Comment": "get an instance of the dtmmanager.since a node iterator may be passed without a dtmmanager, this allows the caller to easily get the dtmmanager using just the iterator.",
	"Method": "DTMManager getDTMManager(){\r\n    return m_execContext.getDTMManager();\r\n}"
}, {
	"Path": "com.iluwatar.model.view.presenter.FileSelectorPresenterTest.wiring",
	"Comment": "tests if the presenter was successfully connected with the view.",
	"Method": "void wiring(){\r\n    presenter.start();\r\n    assertNotNull(stub.getPresenter());\r\n    assertTrue(stub.isOpened());\r\n}"
}, {
	"Path": "hudson.model.Computer.isPartiallyIdle",
	"Comment": "returns true if this computer has some idle executors that can take more workload.",
	"Method": "boolean isPartiallyIdle(){\r\n    for (Executor e : executors) if (e.isIdle())\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xpath.SourceTreeManager.findURIFromDoc",
	"Comment": "given a document, find the url associated with that document.",
	"Method": "String findURIFromDoc(int owner){\r\n    int n = m_sourceTree.size();\r\n    for (int i = 0; i < n; i++) {\r\n        SourceTree sTree = (SourceTree) m_sourceTree.elementAt(i);\r\n        if (owner == sTree.m_root)\r\n            return sTree.m_url;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.iluwatar.hexagonal.sampledata.SampleData.submitTickets",
	"Comment": "inserts lottery tickets into the database based on the sample data",
	"Method": "void submitTickets(LotteryService lotteryService,int numTickets){\r\n    for (int i = 0; i < numTickets; i++) {\r\n        LotteryTicket ticket = new LotteryTicket(new LotteryTicketId(), getRandomPlayerDetails(), LotteryNumbers.createRandom());\r\n        lotteryService.submitTicket(ticket);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XNodeSet.boolWithSideEffects",
	"Comment": "cast result object to a boolean, but allow side effects, such as the incrementing of an iterator.",
	"Method": "boolean boolWithSideEffects(){\r\n    return (nextNode() != DTM.NULL);\r\n}"
}, {
	"Path": "jadx.core.xmlgen.XMLChar.isContent",
	"Comment": "returns true if the specified character can be considered content.",
	"Method": "boolean isContent(int c){\r\n    return (c < 0x10000 && (CHARS[c] & MASK_CONTENT) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.AVT.getRawName",
	"Comment": "get the raw name of the attribute, with the prefix unprocessed.",
	"Method": "String getRawName(){\r\n    return m_rawName;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.previousNode",
	"Comment": "returns the previous node in the set and moves the position of theiterator backwards in the set.",
	"Method": "int previousNode(){\r\n    throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_CANNOT_ITERATE, null));\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.setPrimaryReader",
	"Comment": "set primary xmlreader associated with this execution context.",
	"Method": "void setPrimaryReader(XMLReader reader){\r\n    m_primaryReader = reader;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.Encodings.getHighChar",
	"Comment": "characters with values at or below the high code point arein the encoding. code point values above this one may or maynot be in the encoding, but lower ones certainly are.this is for performance.",
	"Method": "char getHighChar(String encoding){\r\n    final char highCodePoint;\r\n    EncodingInfo ei;\r\n    String normalizedEncoding = toUpperCaseFast(encoding);\r\n    ei = (EncodingInfo) _encodingTableKeyJava.get(normalizedEncoding);\r\n    if (ei == null)\r\n        ei = (EncodingInfo) _encodingTableKeyMime.get(normalizedEncoding);\r\n    if (ei != null)\r\n        highCodePoint = ei.getHighChar();\r\n    else\r\n        highCodePoint = 0;\r\n    return highCodePoint;\r\n}"
}, {
	"Path": "org.apache.xpath.operations.Variable.isPsuedoVarRef",
	"Comment": "tell if this is a psuedo variable reference, declared by xalan instead of by the user.",
	"Method": "boolean isPsuedoVarRef(){\r\n    java.lang.String ns = m_qname.getNamespaceURI();\r\n    if ((null != ns) && ns.equals(PSUEDOVARNAMESPACE)) {\r\n        if (m_qname.getLocalName().startsWith(\"#\"))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.StepPattern.getRelativePathPattern",
	"Comment": "get the reference to nodetest and predicate forparent or ancestor.",
	"Method": "StepPattern getRelativePathPattern(){\r\n    return m_relativePathPattern;\r\n}"
}, {
	"Path": "hudson.model.AbstractProject.getTrigger",
	"Comment": "gets the specific trigger, or null if the property is not configured for this job.",
	"Method": "T getTrigger(Class<T> clazz){\r\n    for (Trigger p : triggers()) {\r\n        if (clazz.isInstance(p))\r\n            return clazz.cast(p);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.UnionChildIterator.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    super.fixupVariables(vars, globalsSize);\r\n    if (m_nodeTests != null) {\r\n        for (int i = 0; i < m_nodeTests.length; i++) {\r\n            m_nodeTests[i].fixupVariables(vars, globalsSize);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.java_websocket.client.WebSocketClient.reconnect",
	"Comment": "reinitiates the websocket connection. this method does not block.",
	"Method": "void reconnect(){\r\n    reset();\r\n    connect();\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemLiteralResult.getIsLiteralResultAsStylesheet",
	"Comment": "return whether this element represents a root elementthat is also the stylesheet element.",
	"Method": "boolean getIsLiteralResultAsStylesheet(){\r\n    return isLiteralResultAsStylesheet;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.DTMException.setLocator",
	"Comment": "method setlocator sets an instance of a sourcelocatorobject that specifies where an error occured.",
	"Method": "void setLocator(SourceLocator location){\r\n    locator = location;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.error",
	"Comment": "receive notification of a recoverable parser error.the default implementation does nothing.application writersmay override this method in a subclass to take specific actionsfor each error, such as inserting the message in a log file orprinting it to the console.",
	"Method": "void error(SAXParseException e){\r\n    throw e;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.NameTableTest.testGetReservedEnumConstantName",
	"Comment": "this is necessary for compatibility with proto compiler output.",
	"Method": "void testGetReservedEnumConstantName(){\r\n    String translation = translateSourceFile(\"enum E { HUGE }\", \"E\", \"E.h\");\r\n    assertTranslation(translation, \"HUGE\");\r\n    assertNotInTranslation(translation, \"HUGE_\");\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XNodeSet.numWithSideEffects",
	"Comment": "cast result object to a number, but allow side effects, such as the incrementing of an iterator.",
	"Method": "double numWithSideEffects(){\r\n    int node = nextNode();\r\n    return (node != DTM.NULL) ? getNumberFromNode(node) : Double.NaN;\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XStringForFSB.equalsIgnoreCase",
	"Comment": "compares this string to another string,ignoring case considerations.two strings are considered equalignoring case if they are of the same length, and correspondingcharacters in the two strings are equal ignoring case.",
	"Method": "boolean equalsIgnoreCase(String anotherString){\r\n    return (m_length == anotherString.length()) ? str().equalsIgnoreCase(anotherString) : false;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.DOM3SerializerImpl.getNodeFilter",
	"Comment": "returns a lsserializerfilter set on the dom level 3 serializer to filter nodesduring serialization.this interface is a public api.",
	"Method": "LSSerializerFilter getNodeFilter(){\r\n    return fSerializerFilter;\r\n}"
}, {
	"Path": "hudson.model.AsyncAperiodicWork.getNormalLoggingLevel",
	"Comment": "returns the logging level at which normal messages are displayed.",
	"Method": "Level getNormalLoggingLevel(){\r\n    return Level.INFO;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemApplyTemplates.transformSelectedNodes",
	"Comment": "perform a query if needed, and call transformnode for each child.",
	"Method": "void transformSelectedNodes(TransformerImpl transformer){\r\n    final XPathContext xctxt = transformer.getXPathContext();\r\n    final int sourceNode = xctxt.getCurrentNode();\r\n    DTMIterator sourceNodes = m_selectExpression.asIterator(xctxt, sourceNode);\r\n    VariableStack vars = xctxt.getVarStack();\r\n    int nParams = getParamElemCount();\r\n    int thisframe = vars.getStackFrame();\r\n    boolean pushContextNodeListFlag = false;\r\n    try {\r\n        xctxt.pushCurrentNode(DTM.NULL);\r\n        xctxt.pushCurrentExpressionNode(DTM.NULL);\r\n        xctxt.pushSAXLocatorNull();\r\n        transformer.pushElemTemplateElement(null);\r\n        final Vector keys = (m_sortElems == null) ? null : transformer.processSortKeys(this, sourceNode);\r\n        if (null != keys)\r\n            sourceNodes = sortNodes(xctxt, keys, sourceNodes);\r\n        final SerializationHandler rth = transformer.getSerializationHandler();\r\n        final StylesheetRoot sroot = transformer.getStylesheet();\r\n        final TemplateList tl = sroot.getTemplateListComposed();\r\n        final boolean quiet = transformer.getQuietConflictWarnings();\r\n        DTM dtm = xctxt.getDTM(sourceNode);\r\n        int argsFrame = -1;\r\n        if (nParams > 0) {\r\n            argsFrame = vars.link(nParams);\r\n            vars.setStackFrame(thisframe);\r\n            for (int i = 0; i < nParams; i++) {\r\n                ElemWithParam ewp = m_paramElems[i];\r\n                XObject obj = ewp.getValue(transformer, sourceNode);\r\n                vars.setLocalVariable(i, obj, argsFrame);\r\n            }\r\n            vars.setStackFrame(argsFrame);\r\n        }\r\n        xctxt.pushContextNodeList(sourceNodes);\r\n        pushContextNodeListFlag = true;\r\n        IntStack currentNodes = xctxt.getCurrentNodeStack();\r\n        IntStack currentExpressionNodes = xctxt.getCurrentExpressionNodeStack();\r\n        int child;\r\n        while (DTM.NULL != (child = sourceNodes.nextNode())) {\r\n            currentNodes.setTop(child);\r\n            currentExpressionNodes.setTop(child);\r\n            if (xctxt.getDTM(child) != dtm) {\r\n                dtm = xctxt.getDTM(child);\r\n            }\r\n            final int exNodeType = dtm.getExpandedTypeID(child);\r\n            final int nodeType = dtm.getNodeType(child);\r\n            final QName mode = transformer.getMode();\r\n            ElemTemplate template = tl.getTemplateFast(xctxt, child, exNodeType, mode, -1, quiet, dtm);\r\n            if (null == template) {\r\n                switch(nodeType) {\r\n                    case DTM.DOCUMENT_FRAGMENT_NODE:\r\n                    case DTM.ELEMENT_NODE:\r\n                        template = sroot.getDefaultRule();\r\n                        break;\r\n                    case DTM.ATTRIBUTE_NODE:\r\n                    case DTM.CDATA_SECTION_NODE:\r\n                    case DTM.TEXT_NODE:\r\n                        transformer.pushPairCurrentMatched(sroot.getDefaultTextRule(), child);\r\n                        transformer.setCurrentElement(sroot.getDefaultTextRule());\r\n                        dtm.dispatchCharactersEvents(child, rth, false);\r\n                        transformer.popCurrentMatched();\r\n                        continue;\r\n                    case DTM.DOCUMENT_NODE:\r\n                        template = sroot.getDefaultRootRule();\r\n                        break;\r\n                    default:\r\n                        continue;\r\n                }\r\n            } else {\r\n                transformer.setCurrentElement(template);\r\n            }\r\n            transformer.pushPairCurrentMatched(template, child);\r\n            int currentFrameBottom;\r\n            if (template.m_frameSize > 0) {\r\n                xctxt.pushRTFContext();\r\n                currentFrameBottom = vars.getStackFrame();\r\n                vars.link(template.m_frameSize);\r\n                if (template.m_inArgsSize > 0) {\r\n                    int paramIndex = 0;\r\n                    for (ElemTemplateElement elem = template.getFirstChildElem(); null != elem; elem = elem.getNextSiblingElem()) {\r\n                        if (Constants.ELEMNAME_PARAMVARIABLE == elem.getXSLToken()) {\r\n                            ElemParam ep = (ElemParam) elem;\r\n                            int i;\r\n                            for (i = 0; i < nParams; i++) {\r\n                                ElemWithParam ewp = m_paramElems[i];\r\n                                if (ewp.m_qnameID == ep.m_qnameID) {\r\n                                    XObject obj = vars.getLocalVariable(i, argsFrame);\r\n                                    vars.setLocalVariable(paramIndex, obj);\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (i == nParams)\r\n                                vars.setLocalVariable(paramIndex, null);\r\n                        } else\r\n                            break;\r\n                        paramIndex++;\r\n                    }\r\n                }\r\n            } else\r\n                currentFrameBottom = 0;\r\n            for (ElemTemplateElement t = template.m_firstChild; t != null; t = t.m_nextSibling) {\r\n                xctxt.setSAXLocator(t);\r\n                try {\r\n                    transformer.pushElemTemplateElement(t);\r\n                    t.execute(transformer);\r\n                } finally {\r\n                    transformer.popElemTemplateElement();\r\n                }\r\n            }\r\n            if (template.m_frameSize > 0) {\r\n                vars.unlink(currentFrameBottom);\r\n                xctxt.popRTFContext();\r\n            }\r\n            transformer.popCurrentMatched();\r\n        }\r\n    } catch (SAXException se) {\r\n        transformer.getErrorListener().fatalError(new TransformerException(se));\r\n    } finally {\r\n        if (nParams > 0)\r\n            vars.unlink(thisframe);\r\n        xctxt.popSAXLocator();\r\n        if (pushContextNodeListFlag)\r\n            xctxt.popContextNodeList();\r\n        transformer.popElemTemplateElement();\r\n        xctxt.popCurrentExpressionNode();\r\n        xctxt.popCurrentNode();\r\n        sourceNodes.detach();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemParam.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n    m_qnameID = sroot.getComposeState().getQNameID(m_qname);\r\n    int parentToken = m_parentNode.getXSLToken();\r\n    if (parentToken == Constants.ELEMNAME_TEMPLATE || parentToken == Constants.EXSLT_ELEMNAME_FUNCTION)\r\n        ((ElemTemplate) m_parentNode).m_inArgsSize++;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncNormalizeSpace.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    XMLString s1 = getArg0AsString(xctxt);\r\n    return (XString) s1.fixWhiteSpace(true, true, false);\r\n}"
}, {
	"Path": "hudson.tasks.MavenTest.globalConfigAjax",
	"Comment": "simulates the addition of the new maven via ui and makes sure it works.",
	"Method": "void globalConfigAjax(){\r\n    HtmlPage p = j.createWebClient().goTo(\"configureTools\");\r\n    HtmlForm f = p.getFormByName(\"config\");\r\n    HtmlButton b = j.getButtonByCaption(f, \"Add Maven\");\r\n    b.click();\r\n    j.findPreviousInputElement(b, \"name\").setValueAttribute(\"myMaven\");\r\n    j.findPreviousInputElement(b, \"home\").setValueAttribute(\"/tmp/foo\");\r\n    j.submit(f);\r\n    verify();\r\n    p = j.createWebClient().goTo(\"configure\");\r\n    f = p.getFormByName(\"config\");\r\n    j.submit(f);\r\n    verify();\r\n}"
}, {
	"Path": "hudson.Functions.determineRows",
	"Comment": "counts the number of rows needed for textarea to fit the content.minimum 5 rows.",
	"Method": "int determineRows(String s){\r\n    if (s == null)\r\n        return 5;\r\n    return Math.max(5, LINE_END.split(s).length);\r\n}"
}, {
	"Path": "org.java_websocket.AbstractWebSocket.getConnectionLostTimeout",
	"Comment": "get the interval checking for lost connectionsdefault is 60 seconds",
	"Method": "int getConnectionLostTimeout(){\r\n    return connectionLostTimeout;\r\n}"
}, {
	"Path": "org.apache.xpath.operations.Variable.getGlobal",
	"Comment": "set the index for the variable into the stack.for advanced use only.",
	"Method": "boolean getGlobal(){\r\n    return m_isGlobal;\r\n}"
}, {
	"Path": "hudson.security.HudsonPrivateSecurityRealm.getUser",
	"Comment": "this is to map users under the security realm url.this in turn helps us set up the right navigation breadcrumb.",
	"Method": "User getUser(String id,User getUser){\r\n    return User.getById(id, User.ALLOW_USER_CREATION_VIA_URL && hasPermission(Jenkins.ADMINISTER));\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.cleanup",
	"Comment": "cleans up any resources held by this classloader. any open archivefiles are closed.",
	"Method": "void cleanup(){\r\n    for (Enumeration e = jarFiles.elements(); e.hasMoreElements(); ) {\r\n        JarFile jarFile = (JarFile) e.nextElement();\r\n        try {\r\n            jarFile.close();\r\n        } catch (IOException ioe) {\r\n        }\r\n    }\r\n    jarFiles = new Hashtable();\r\n    if (project != null) {\r\n        project.removeBuildListener(this);\r\n    }\r\n    project = null;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.getExpandEntityReferences",
	"Comment": "the value of this flag determines whether the children of entityreference nodes are visible to the iterator. if false, they will beskipped over. to produce a view of the document that has entity referencesexpanded and does not expose the entity reference node itself, use thewhattoshow flags to hide the entity reference node and setexpandentityreferences to true when creating the iterator. to producea view of the document that has entity reference nodes but no entityexpansion, use the whattoshow flags to show the entity reference nodeand set expandentityreferences to false.",
	"Method": "boolean getExpandEntityReferences(){\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetComposed.recomposeIncludes",
	"Comment": "recompose the value of the composed include list.builds a compositelist of all stylesheets included by this stylesheet to any depth.",
	"Method": "void recomposeIncludes(Stylesheet including){\r\n    int n = including.getIncludeCount();\r\n    if (n > 0) {\r\n        if (null == m_includesComposed)\r\n            m_includesComposed = new Vector();\r\n        for (int i = 0; i < n; i++) {\r\n            Stylesheet included = including.getInclude(i);\r\n            m_includesComposed.addElement(included);\r\n            recomposeIncludes(included);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.event.aggregator.EventEmitterTest.testAllDaysWithDefaultObserver",
	"Comment": "go over every day of the month, and check if the event is emitted on the given day.",
	"Method": "void testAllDaysWithDefaultObserver(Weekday specialDay,Event event){\r\n    final EventObserver defaultObserver = mock(EventObserver.class);\r\n    final EventObserver observer1 = mock(EventObserver.class);\r\n    final EventObserver observer2 = mock(EventObserver.class);\r\n    final E emitter = this.factoryWithDefaultObserver.apply(defaultObserver);\r\n    emitter.registerObserver(observer1);\r\n    emitter.registerObserver(observer2);\r\n    testAllDays(specialDay, event, emitter, defaultObserver, observer1, observer2);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.LSSerializerImpl.getPathWithoutEscapes",
	"Comment": "replaces all escape sequences in the given path with their literal characters.",
	"Method": "String getPathWithoutEscapes(String origPath){\r\n    if (origPath != null && origPath.length() != 0 && origPath.indexOf('%') != -1) {\r\n        StringTokenizer tokenizer = new StringTokenizer(origPath, \"%\");\r\n        StringBuffer result = new StringBuffer(origPath.length());\r\n        int size = tokenizer.countTokens();\r\n        result.append(tokenizer.nextToken());\r\n        for (int i = 1; i < size; ++i) {\r\n            String token = tokenizer.nextToken();\r\n            if (token.length() >= 2 && isHexDigit(token.charAt(0)) && isHexDigit(token.charAt(1))) {\r\n                result.append((char) Integer.valueOf(token.substring(0, 2), 16).intValue());\r\n                token = token.substring(2);\r\n            }\r\n            result.append(token);\r\n        }\r\n        return result.toString();\r\n    }\r\n    return origPath;\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLChar.isValidJavaEncoding",
	"Comment": "returns true if the encoding name is a valid java encoding.this method does not verify that there is a decoder availablefor this encoding, only that the characters are valid for anjava encoding name.",
	"Method": "boolean isValidJavaEncoding(String javaEncoding){\r\n    if (javaEncoding != null) {\r\n        int length = javaEncoding.length();\r\n        if (length > 0) {\r\n            for (int i = 1; i < length; i++) {\r\n                char c = javaEncoding.charAt(i);\r\n                if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') && (c < '0' || c > '9') && c != '.' && c != '_' && c != '-') {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.setDocumentLocator",
	"Comment": "receive a locator object for document events.by default, do nothing.application writers may override thismethod in a subclass if they wish to store the locator for usewith other document events.",
	"Method": "void setDocumentLocator(Locator locator){\r\n    m_locator = locator;\r\n    m_systemId = locator.getSystemId();\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ElemDesc.is",
	"Comment": "tell if this element type has the basic bit properties that are passedas an argument.",
	"Method": "boolean is(int flags){\r\n    return (m_flags & flags) != 0;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.processDirty",
	"Comment": "process a dirty character and any preeceding clean charactersthat were not yet processed.",
	"Method": "int processDirty(char[] chars,int end,int i,char ch,int lastDirty,boolean fromTextNode){\r\n    int startClean = lastDirty + 1;\r\n    if (i > startClean) {\r\n        int lengthClean = i - startClean;\r\n        m_writer.write(chars, startClean, lengthClean);\r\n    }\r\n    if (CharInfo.S_LINEFEED == ch && fromTextNode) {\r\n        m_writer.write(m_lineSep, 0, m_lineSepLen);\r\n    } else {\r\n        startClean = accumDefaultEscape(m_writer, (char) ch, i, chars, end, fromTextNode, false);\r\n        i = startClean - 1;\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "hudson.model.Computer.getIdleStartMilliseconds",
	"Comment": "returns the time when this computer last became idle.if this computer is already idle, the return value will point to thetime in the past since when this computer has been idle.if this computer is busy, the return value will point to thetime in the future where this computer will be expected to become free.",
	"Method": "long getIdleStartMilliseconds(){\r\n    long firstIdle = Long.MIN_VALUE;\r\n    for (Executor e : oneOffExecutors) {\r\n        firstIdle = Math.max(firstIdle, e.getIdleStartMilliseconds());\r\n    }\r\n    for (Executor e : executors) {\r\n        firstIdle = Math.max(firstIdle, e.getIdleStartMilliseconds());\r\n    }\r\n    return firstIdle;\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.safeRestart",
	"Comment": "queues up a restart to be performed once there are no builds currently running.",
	"Method": "void safeRestart(){\r\n    final Lifecycle lifecycle = Lifecycle.get();\r\n    lifecycle.verifyRestartable();\r\n    isQuietingDown = true;\r\n    new Thread(\"safe-restart thread\") {\r\n        final String exitUser = getAuthentication().getName();\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                ACL.impersonate(ACL.SYSTEM);\r\n                doQuietDown(true, 0);\r\n                if (isQuietingDown) {\r\n                    servletContext.setAttribute(\"app\", new HudsonIsRestarting());\r\n                    LOGGER.info(\"Restart in 10 seconds\");\r\n                    Thread.sleep(10000);\r\n                    LOGGER.info(String.format(\"Restarting VM as requested by %s\", exitUser));\r\n                    for (RestartListener listener : RestartListener.all()) listener.onRestart();\r\n                    lifecycle.restart();\r\n                } else {\r\n                    LOGGER.info(\"Safe-restart mode cancelled\");\r\n                }\r\n            } catch (Throwable e) {\r\n                LOGGER.log(Level.WARNING, \"Failed to restart Jenkins\", e);\r\n            }\r\n        }\r\n    }.start();\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.safeRestart",
	"Comment": "queues up a restart to be performed once there are no builds currently running.",
	"Method": "void safeRestart(){\r\n    try {\r\n        ACL.impersonate(ACL.SYSTEM);\r\n        doQuietDown(true, 0);\r\n        if (isQuietingDown) {\r\n            servletContext.setAttribute(\"app\", new HudsonIsRestarting());\r\n            LOGGER.info(\"Restart in 10 seconds\");\r\n            Thread.sleep(10000);\r\n            LOGGER.info(String.format(\"Restarting VM as requested by %s\", exitUser));\r\n            for (RestartListener listener : RestartListener.all()) listener.onRestart();\r\n            lifecycle.restart();\r\n        } else {\r\n            LOGGER.info(\"Safe-restart mode cancelled\");\r\n        }\r\n    } catch (Throwable e) {\r\n        LOGGER.log(Level.WARNING, \"Failed to restart Jenkins\", e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.DefaultErrorHandler.getErrorWriter",
	"Comment": "retrieve java.io.printwriter to which errors are beingdirected.",
	"Method": "PrintWriter getErrorWriter(){\r\n    if (m_pw == null) {\r\n        m_pw = new PrintWriter(System.err, true);\r\n    }\r\n    return m_pw;\r\n}"
}, {
	"Path": "hudson.model.UpdateCenter.getBackupVersion",
	"Comment": "returns string with version of backup .war file,if the file does not exists returns null",
	"Method": "String getBackupVersion(){\r\n    try {\r\n        try (JarFile backupWar = new JarFile(new File(Lifecycle.get().getHudsonWar() + \".bak\"))) {\r\n            Attributes attrs = backupWar.getManifest().getMainAttributes();\r\n            String v = attrs.getValue(\"Jenkins-Version\");\r\n            if (v == null)\r\n                v = attrs.getValue(\"Hudson-Version\");\r\n            return v;\r\n        }\r\n    } catch (IOException e) {\r\n        LOGGER.log(Level.WARNING, \"Failed to read backup version \", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "jadx.core.dex.visitors.blocksmaker.BlockFinish.fixSplitterBlock",
	"Comment": "for evey exception handler must be only one splitter block,\tselect correct one and remove others if necessary.",
	"Method": "void fixSplitterBlock(BlockNode block){\r\n    ExcHandlerAttr excHandlerAttr = block.get(AType.EXC_HANDLER);\r\n    if (excHandlerAttr == null) {\r\n        return;\r\n    }\r\n    BlockNode handlerBlock = excHandlerAttr.getHandler().getHandlerBlock();\r\n    if (handlerBlock.getPredecessors().size() < 2) {\r\n        return;\r\n    }\r\n    Map<BlockNode, SplitterBlockAttr> splitters = new HashMap();\r\n    for (BlockNode pred : handlerBlock.getPredecessors()) {\r\n        pred = BlockUtils.skipSyntheticPredecessor(pred);\r\n        SplitterBlockAttr splitterAttr = pred.get(AType.SPLITTER_BLOCK);\r\n        if (splitterAttr != null && pred == splitterAttr.getBlock()) {\r\n            splitters.put(pred, splitterAttr);\r\n        }\r\n    }\r\n    if (splitters.size() < 2) {\r\n        return;\r\n    }\r\n    BlockNode topSplitter = BlockUtils.getTopBlock(splitters.keySet());\r\n    if (topSplitter == null) {\r\n        LOG.warn(\"Unknown top splitter block from list: {}\", splitters);\r\n        return;\r\n    }\r\n    for (Map.Entry<BlockNode, SplitterBlockAttr> entry : splitters.entrySet()) {\r\n        BlockNode pred = entry.getKey();\r\n        SplitterBlockAttr splitterAttr = entry.getValue();\r\n        if (pred == topSplitter) {\r\n            block.addAttr(splitterAttr);\r\n        } else {\r\n            pred.remove(AType.SPLITTER_BLOCK);\r\n            for (BlockNode s : pred.getCleanSuccessors()) {\r\n                s.remove(AType.SPLITTER_BLOCK);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "redis.clients.jedis.tests.collections.SetFromListTest.setFromList",
	"Comment": "instantiate setfromlist class by reflection because it is protected static inner class ofbinaryjedis.",
	"Method": "Set<E> setFromList(List<E> list){\r\n    return (Set<E>) method.invoke(null, list);\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncConcat.reportWrongNumberArgs",
	"Comment": "constructs and throws a wrongnumberargexception with the appropriatemessage for this function object.",
	"Method": "void reportWrongNumberArgs(){\r\n    throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(\"gtone\", null));\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XNodeSet.getTypeString",
	"Comment": "given a request type, return the equivalent string.for diagnostic purposes.",
	"Method": "String getTypeString(){\r\n    return \"#NODESET\";\r\n}"
}, {
	"Path": "org.apache.xalan.processor.XSLTElementDef.getClassObject",
	"Comment": "return the class object that should in instantiated fora xalan instance of this element.",
	"Method": "Class getClassObject(){\r\n    return m_classObject;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.TemplateList.getPriorityOrScore",
	"Comment": "given a match pattern and template association, return the score of that match.this score or priority can always be statically calculated.",
	"Method": "double getPriorityOrScore(TemplateSubPatternAssociation matchPat){\r\n    double priority = matchPat.getTemplate().getPriority();\r\n    if (priority == XPath.MATCH_SCORE_NONE) {\r\n        Expression ex = matchPat.getStepPattern();\r\n        if (ex instanceof NodeTest) {\r\n            return ((NodeTest) ex).getDefaultScore();\r\n        }\r\n    }\r\n    return priority;\r\n}"
}, {
	"Path": "org.apache.xpath.XPath.execute",
	"Comment": "given an expression and a context, evaluate the xpathand return the result.",
	"Method": "XObject execute(XPathContext xctxt,org.w3c.dom.Node contextNode,PrefixResolver namespaceContext,XObject execute,XPathContext xctxt,int contextNode,PrefixResolver namespaceContext){\r\n    xctxt.pushNamespaceContext(namespaceContext);\r\n    xctxt.pushCurrentNodeAndExpression(contextNode, contextNode);\r\n    XObject xobj = null;\r\n    try {\r\n        xobj = m_mainExp.execute(xctxt);\r\n    } catch (TransformerException te) {\r\n        te.setLocator(this.getLocator());\r\n        ErrorListener el = xctxt.getErrorListener();\r\n        if (null != el) {\r\n            el.error(te);\r\n        } else\r\n            throw te;\r\n    } catch (Exception e) {\r\n        while (e instanceof org.apache.xml.utils.WrappedRuntimeException) {\r\n            e = ((org.apache.xml.utils.WrappedRuntimeException) e).getException();\r\n        }\r\n        String msg = e.getMessage();\r\n        if (msg == null || msg.length() == 0) {\r\n            msg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_XPATH_ERROR, null);\r\n        }\r\n        TransformerException te = new TransformerException(msg, getLocator(), e);\r\n        ErrorListener el = xctxt.getErrorListener();\r\n        if (null != el) {\r\n            el.fatalError(te);\r\n        } else\r\n            throw te;\r\n    } finally {\r\n        xctxt.popNamespaceContext();\r\n        xctxt.popCurrentNodeAndExpression();\r\n    }\r\n    return xobj;\r\n}"
}, {
	"Path": "com.iluwatar.object.pool.OliphauntPoolTest.testConcurrentCheckinCheckout",
	"Comment": "use the same object 100 times subsequently. this should not take much time since the heavyobject instantiation is done only once. verify if we get the same object each time.",
	"Method": "void testConcurrentCheckinCheckout(){\r\n    assertTimeout(ofMillis(5000), () -> {\r\n        final OliphauntPool pool = new OliphauntPool();\r\n        assertEquals(pool.toString(), \"Pool available=0 inUse=0\");\r\n        final Oliphaunt firstOliphaunt = pool.checkOut();\r\n        assertEquals(pool.toString(), \"Pool available=0 inUse=1\");\r\n        final Oliphaunt secondOliphaunt = pool.checkOut();\r\n        assertEquals(pool.toString(), \"Pool available=0 inUse=2\");\r\n        assertNotSame(firstOliphaunt, secondOliphaunt);\r\n        assertEquals(firstOliphaunt.getId() + 1, secondOliphaunt.getId());\r\n        pool.checkIn(secondOliphaunt);\r\n        assertEquals(pool.toString(), \"Pool available=1 inUse=1\");\r\n        final Oliphaunt oliphaunt3 = pool.checkOut();\r\n        assertEquals(pool.toString(), \"Pool available=0 inUse=2\");\r\n        assertSame(secondOliphaunt, oliphaunt3);\r\n        pool.checkIn(firstOliphaunt);\r\n        assertEquals(pool.toString(), \"Pool available=1 inUse=1\");\r\n        final Oliphaunt oliphaunt4 = pool.checkOut();\r\n        assertEquals(pool.toString(), \"Pool available=0 inUse=2\");\r\n        assertSame(firstOliphaunt, oliphaunt4);\r\n        pool.checkIn(firstOliphaunt);\r\n        assertEquals(pool.toString(), \"Pool available=1 inUse=1\");\r\n        pool.checkIn(secondOliphaunt);\r\n        assertEquals(pool.toString(), \"Pool available=2 inUse=0\");\r\n        final List<Oliphaunt> oliphaunts = Arrays.asList(pool.checkOut(), pool.checkOut());\r\n        assertEquals(pool.toString(), \"Pool available=0 inUse=2\");\r\n        assertTrue(oliphaunts.contains(firstOliphaunt));\r\n        assertTrue(oliphaunts.contains(secondOliphaunt));\r\n    });\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.NodeTest.execute",
	"Comment": "test the current node to see if it matches the given node test.",
	"Method": "XObject execute(XPathContext xctxt,int context,XObject execute,XPathContext xctxt,int context,DTM dtm,int expType,XObject execute,XPathContext xctxt){\r\n    return execute(xctxt, xctxt.getCurrentNode());\r\n}"
}, {
	"Path": "hudson.util.CopyOnWriteMap.replaceBy",
	"Comment": "atomically replaces the entire map by the copy of the specified map.",
	"Method": "void replaceBy(Map<? extends K, ? extends V> data){\r\n    Map<K, V> d = copy();\r\n    d.clear();\r\n    d.putAll(data);\r\n    update(d);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.LSSerializerImpl.getParameterNames",
	"Comment": "this method returns a of the parameters supported by this domconfiguration object and for which at least one value can be set by the application",
	"Method": "DOMStringList getParameterNames(){\r\n    return new DOMStringListImpl(fRecognizedParameters);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.FuncFormatNumb.reportWrongNumberArgs",
	"Comment": "constructs and throws a wrongnumberargexception with the appropriatemessage for this function object.",
	"Method": "void reportWrongNumberArgs(){\r\n    throw new WrongNumberArgsException(XSLMessages.createMessage(XSLTErrorResources.ER_TWO_OR_THREE, null));\r\n}"
}, {
	"Path": "hudson.scheduler.CronTabList.checkSanity",
	"Comment": "checks if this crontab entry looks reasonable,and if not, return an warning message.the point of this method is to catch syntactically correctbut semantically suspicious combinations, like",
	"Method": "String checkSanity(){\r\n    for (CronTab tab : tabs) {\r\n        String s = tab.checkSanity();\r\n        if (s != null)\r\n            return s;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "hudson.model.ResourceList.isCollidingWith",
	"Comment": "checks if this resource list and that resource list has any conflictingresource access.",
	"Method": "boolean isCollidingWith(ResourceList that){\r\n    return getConflict(that) != null;\r\n}"
}, {
	"Path": "jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract.splitBlock",
	"Comment": "split one block into connected 2 blocks with same connections.",
	"Method": "BlockNode splitBlock(MethodNode mth,BlockNode block,int splitIndex){\r\n    BlockNode newBlock = BlockSplitter.startNewBlock(mth, -1);\r\n    newBlock.getSuccessors().addAll(block.getSuccessors());\r\n    for (BlockNode s : new ArrayList(block.getSuccessors())) {\r\n        removeConnection(block, s);\r\n        connect(newBlock, s);\r\n    }\r\n    block.getSuccessors().clear();\r\n    connect(block, newBlock);\r\n    block.updateCleanSuccessors();\r\n    newBlock.updateCleanSuccessors();\r\n    List<InsnNode> insns = block.getInstructions();\r\n    int size = insns.size();\r\n    for (int i = splitIndex; i < size; i++) {\r\n        InsnNode insnNode = insns.get(i);\r\n        insnNode.add(AFlag.SKIP);\r\n        newBlock.getInstructions().add(insnNode);\r\n    }\r\n    Iterator<InsnNode> it = insns.iterator();\r\n    while (it.hasNext()) {\r\n        InsnNode insnNode = it.next();\r\n        if (insnNode.contains(AFlag.SKIP)) {\r\n            it.remove();\r\n        }\r\n    }\r\n    for (InsnNode insnNode : newBlock.getInstructions()) {\r\n        insnNode.remove(AFlag.SKIP);\r\n    }\r\n    return newBlock;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplate.getSystemId",
	"Comment": "return the system identifier for the current document event.if the system identifier is a url, the parser must resolve itfully before passing it to the application.",
	"Method": "String getSystemId(){\r\n    return m_systemId;\r\n}"
}, {
	"Path": "hudson.security.SecurityRealm.getFrom",
	"Comment": "perform a calculation where we should go back after successful login",
	"Method": "String getFrom(){\r\n    String from = null, returnValue = null;\r\n    final StaplerRequest request = Stapler.getCurrentRequest();\r\n    if (request != null && request.getSession(false) != null) {\r\n        from = (String) request.getSession().getAttribute(\"from\");\r\n    } else if (request != null) {\r\n        from = request.getParameter(\"from\");\r\n    }\r\n    if (from == null && request != null && request.getRequestURI() != null && !request.getRequestURI().equals(\"/loginError\") && !request.getRequestURI().equals(\"/login\")) {\r\n        from = request.getRequestURI();\r\n    }\r\n    from = StringUtils.defaultIfBlank(from, \"/\").trim();\r\n    try {\r\n        returnValue = java.net.URLEncoder.encode(from, \"UTF-8\");\r\n    } catch (UnsupportedEncodingException e) {\r\n    }\r\n    return StringUtils.isBlank(returnValue) ? \"/\" : returnValue;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerImpl.waitTransformThread",
	"Comment": "used by sourcetreehandler to wait until the transformcompletes",
	"Method": "void waitTransformThread(){\r\n    Thread transformThread = this.getTransformThread();\r\n    if (null != transformThread) {\r\n        try {\r\n            ThreadControllerWrapper.waitThread(transformThread, this);\r\n            if (!this.hasTransformThreadErrorCatcher()) {\r\n                Exception e = this.getExceptionThrown();\r\n                if (null != e) {\r\n                    e.printStackTrace();\r\n                    throw new org.xml.sax.SAXException(e);\r\n                }\r\n            }\r\n            this.setTransformThread(null);\r\n        } catch (InterruptedException ie) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.event.events.TimerEvent.getElapsed",
	"Comment": "gets the total elapsed duration since this timer was created.",
	"Method": "Duration getElapsed(){\r\n    return elapsed;\r\n}"
}, {
	"Path": "jadx.core.xmlgen.XMLChar.isSupplemental",
	"Comment": "returns true if the specified character is a supplemental character.",
	"Method": "boolean isSupplemental(int c){\r\n    return (c >= 0x10000 && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "org.apache.xml.utils.DOM2Helper.getElementByID",
	"Comment": "given an xml id, return the element. this requires assistance from thedom and parser, and is meaningful only in the context of a dtd or schema which declares attributes as being of type id. thisinformation may or may not be available in all parsers, may ormay not be available for specific documents, and may or may notbe available when validation is not turned on.",
	"Method": "Element getElementByID(String id,Document doc){\r\n    return doc.getElementById(id);\r\n}"
}, {
	"Path": "hudson.slaves.AbstractCloudImpl.getInstanceCapStr",
	"Comment": "gets the instance cap as string. used primarily for form binding.",
	"Method": "String getInstanceCapStr(){\r\n    if (instanceCap == Integer.MAX_VALUE)\r\n        return \"\";\r\n    else\r\n        return String.valueOf(instanceCap);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.UnicodeUtilsTest.testSingleUnicodeEscapeSequence",
	"Comment": "verify that a string with just a unicode escape sequence is converted.",
	"Method": "void testSingleUnicodeEscapeSequence(){\r\n    String fragment = \"?\";\r\n    String escaped = UnicodeUtils.escapeStringLiteral(fragment);\r\n    assertEquals(\"\\\\", escaped);\r\n}"
}, {
	"Path": "org.apache.xml.utils.WrappedRuntimeException.getException",
	"Comment": "get the checked exception that this runtime exception wraps.",
	"Method": "Exception getException(){\r\n    return m_exception;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.item",
	"Comment": "returns the index th item in the collection. ifindex is greater than or equal to the number of nodes inthe list, this returns null .",
	"Method": "int item(int index){\r\n    assertion(false, \"item(int index) not supported by this iterator!\");\r\n    return 0;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.peepOrNull",
	"Comment": "return the node at the top of the stack without popping the stack.special purpose method for transformerimpl, pushelemtemplateelement.performance critical.",
	"Method": "Node peepOrNull(){\r\n    return ((null != m_map) && (m_firstFree > 0)) ? m_map[m_firstFree - 1] : null;\r\n}"
}, {
	"Path": "org.java_websocket.drafts.Draft_6455.processFrameContinuousAndNonFin",
	"Comment": "process the frame if it is a continuous frame or the fin bit is not set",
	"Method": "void processFrameContinuousAndNonFin(WebSocketImpl webSocketImpl,Framedata frame,Opcode curop){\r\n    if (curop != Opcode.CONTINUOUS) {\r\n        processFrameIsNotFin(frame);\r\n    } else if (frame.isFin()) {\r\n        processFrameIsFin(webSocketImpl, frame);\r\n    } else if (currentContinuousFrame == null) {\r\n        log.error(\"Protocol error: Continuous frame sequence was not started.\");\r\n        throw new InvalidDataException(CloseFrame.PROTOCOL_ERROR, \"Continuous frame sequence was not started.\");\r\n    }\r\n    if (curop == Opcode.TEXT && !Charsetfunctions.isValidUTF8(frame.getPayloadData())) {\r\n        log.error(\"Protocol error: Payload is not UTF8\");\r\n        throw new InvalidDataException(CloseFrame.NO_UTF8);\r\n    }\r\n    if (curop == Opcode.CONTINUOUS && currentContinuousFrame != null) {\r\n        addToBufferList(frame.getPayloadData());\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToHTMLStream.processAttributes",
	"Comment": "process the attributes, which means to write out the currentlycollected attributes to the writer. the attributes are notcleared by this method",
	"Method": "void processAttributes(java.io.Writer writer,int nAttrs){\r\n    for (int i = 0; i < nAttrs; i++) {\r\n        processAttribute(writer, m_attributes.getQName(i), m_attributes.getValue(i), m_elemContext.m_elementDesc);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.getPrimaryReader",
	"Comment": "get primary xmlreader associated with this execution context.",
	"Method": "XMLReader getPrimaryReader(){\r\n    return m_primaryReader;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.OneStepIterator.setRoot",
	"Comment": "initialize the context values for this expressionafter it is cloned.",
	"Method": "void setRoot(int context,Object environment){\r\n    super.setRoot(context, environment);\r\n    if (m_axis > -1)\r\n        m_iterator = m_cdtm.getAxisIterator(m_axis);\r\n    m_iterator.setStartNode(m_context);\r\n}"
}, {
	"Path": "hudson.model.DependencyGraph.getTopologicallySorted",
	"Comment": "returns all the projects in the topological order of the dependency.intuitively speaking, the first one in the list is the source of the dependency graph,and the last one is the sink.",
	"Method": "List<AbstractProject<?, ?>> getTopologicallySorted(){\r\n    return topologicallySorted;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.SelfIteratorNoPredicate.getLastPos",
	"Comment": "get the index of the last node that can be itterated to.this probably will need to be overridded by derived classes.",
	"Method": "int getLastPos(XPathContext xctxt){\r\n    return 1;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.getElemFromExpression",
	"Comment": "from an xpath expression component, get the elemtemplateelement owner.",
	"Method": "ElemTemplateElement getElemFromExpression(Expression expr){\r\n    ExpressionNode parent = expr.exprGetParent();\r\n    while (null != parent) {\r\n        if (parent instanceof ElemTemplateElement)\r\n            return (ElemTemplateElement) parent;\r\n        parent = parent.exprGetParent();\r\n    }\r\n    throw new RuntimeException(XSLMessages.createMessage(XSLTErrorResources.ER_ASSERT_NO_TEMPLATE_PARENT, null));\r\n}"
}, {
	"Path": "org.apache.xml.serializer.CharInfo.shouldMapAttrChar",
	"Comment": "tell if the character argument that is froman attribute value has a mapping to a string.",
	"Method": "boolean shouldMapAttrChar(int value){\r\n    if (value < ASCII_MAX)\r\n        return shouldMapAttrChar_ASCII[value];\r\n    return get(value);\r\n}"
}, {
	"Path": "com.iluwatar.templatemethod.HalflingThiefTest.testChangeMethod",
	"Comment": "verify if the thief uses the provided stealing method, and the new method after changing it",
	"Method": "void testChangeMethod(){\r\n    final StealingMethod initialMethod = mock(StealingMethod.class);\r\n    final HalflingThief thief = new HalflingThief(initialMethod);\r\n    thief.steal();\r\n    verify(initialMethod).steal();\r\n    final StealingMethod newMethod = mock(StealingMethod.class);\r\n    thief.changeMethod(newMethod);\r\n    thief.steal();\r\n    verify(newMethod).steal();\r\n    verifyNoMoreInteractions(initialMethod, newMethod);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.DOM2Helper.getLocalNameOfNode",
	"Comment": "returns the local name of the given node, as defined by thexml namespaces specification. this is prepared to handle documentsbuilt using dom level 1 methods by falling back upon explicitlyparsing the node name.",
	"Method": "String getLocalNameOfNode(Node n){\r\n    String name = n.getLocalName();\r\n    return (null == name) ? getLocalNameOfNodeFallback(n) : name;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FunctionMultiArgs.reportWrongNumberArgs",
	"Comment": "constructs and throws a wrongnumberargexception with the appropriatemessage for this function object.this class supports an arbitrarynumber of arguments, so this method must never be called.",
	"Method": "void reportWrongNumberArgs(){\r\n    String fMsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION, new Object[] { \"Programmer's assertion:  the method FunctionMultiArgs.reportWrongNumberArgs() should never be called.\" });\r\n    throw new RuntimeException(fMsg);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemNumber.int2alphaCount",
	"Comment": "convert a long integer into alphabetic counting, in other wordscount using the sequence a b c ... z aa ab ac.... etc.",
	"Method": "void int2alphaCount(long val,CharArrayWrapper aTable,FastStringBuffer stringBuf){\r\n    int radix = aTable.getLength();\r\n    char[] table = new char[radix];\r\n    int i;\r\n    for (i = 0; i < radix - 1; i++) {\r\n        table[i + 1] = aTable.getChar(i);\r\n    }\r\n    table[0] = aTable.getChar(i);\r\n    char[] buf = new char[100];\r\n    int charPos;\r\n    charPos = buf.length - 1;\r\n    int lookupIndex = 1;\r\n    long correction = 0;\r\n    do {\r\n        correction = ((lookupIndex == 0) || (correction != 0 && lookupIndex == radix - 1)) ? (radix - 1) : 0;\r\n        lookupIndex = (int) (val + correction) % radix;\r\n        val = (val / radix);\r\n        if (lookupIndex == 0 && val == 0)\r\n            break;\r\n        buf[charPos--] = table[lookupIndex];\r\n    } while (val > 0);\r\n    stringBuf.append(buf, charPos + 1, (buf.length - charPos - 1));\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.XMLChar.supplemental",
	"Comment": "returns true the supplemental character corresponding to the givensurrogates.",
	"Method": "int supplemental(char h,char l){\r\n    return (h - 0xD800) * 0x400 + (l - 0xDC00) + 0x10000;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.getPublicId",
	"Comment": "return the public identifier for the current document event.this will be the public identifier",
	"Method": "String getPublicId(){\r\n    return (null != m_parentNode) ? m_parentNode.getPublicId() : null;\r\n}"
}, {
	"Path": "redis.clients.jedis.util.Pool.getMaxBorrowWaitTimeMillis",
	"Comment": "returns the maximum waiting time spent by threads to obtain a resourcefrom this pool.",
	"Method": "long getMaxBorrowWaitTimeMillis(){\r\n    if (poolInactive()) {\r\n        return -1;\r\n    }\r\n    return this.internalPool.getMaxBorrowWaitTimeMillis();\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.filesystem.RelativeUnixPath.getRelativePathComponents",
	"Comment": "gets the relative unix path this represents, in a list of components.",
	"Method": "ImmutableList<String> getRelativePathComponents(){\r\n    return pathComponents;\r\n}"
}, {
	"Path": "org.apache.xml.utils.UnImplNode.compareDocumentPosition",
	"Comment": "compares a node with this node with regard to their position in thedocument.",
	"Method": "short compareDocumentPosition(Node other){\r\n    return 0;\r\n}"
}, {
	"Path": "com.sun.jna.platform.dnd.DragHandler.createDragImage",
	"Comment": "create an image from the given icon.the image is provided to thenative handler if drag images are supported natively.",
	"Method": "Image createDragImage(GraphicsConfiguration gc,Icon icon){\r\n    int w = icon.getIconWidth();\r\n    int h = icon.getIconHeight();\r\n    BufferedImage image = gc.createCompatibleImage(w, h, Transparency.TRANSLUCENT);\r\n    Graphics2D g = (Graphics2D) image.getGraphics();\r\n    g.setComposite(AlphaComposite.Clear);\r\n    g.fillRect(0, 0, w, h);\r\n    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC, ghostAlpha));\r\n    icon.paintIcon(dragSource, g, 0, 0);\r\n    g.dispose();\r\n    return image;\r\n}"
}, {
	"Path": "org.apache.xpath.operations.Operation.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    m_left.fixupVariables(vars, globalsSize);\r\n    m_right.fixupVariables(vars, globalsSize);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.XSLTElementDef.getLastOrder",
	"Comment": "get the highest order of child elements have appeared so far .",
	"Method": "int getLastOrder(){\r\n    return m_lastOrder;\r\n}"
}, {
	"Path": "org.apache.xml.utils.DOM2Helper.setDocument",
	"Comment": "specify which document this helper is currently operating on.",
	"Method": "void setDocument(Document doc){\r\n    m_doc = doc;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMNodeProxy.isSameNode",
	"Comment": "returns whether this node is the same node as the given one.this method provides a way to determine whether twonode references returned by the implementation referencethe same object. when two node references are referencesto the same object, even if through a proxy, the references may beused completely interchangably, such that all attributes have thesame values and calling the same dom method on either referencealways has exactly the same effect.",
	"Method": "boolean isSameNode(Node other){\r\n    return this == other;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.UnionPathIterator.setRoot",
	"Comment": "initialize the context values for this expression after it is cloned.",
	"Method": "void setRoot(int context,Object environment){\r\n    super.setRoot(context, environment);\r\n    try {\r\n        if (null != m_exprs) {\r\n            int n = m_exprs.length;\r\n            DTMIterator[] newIters = new DTMIterator[n];\r\n            for (int i = 0; i < n; i++) {\r\n                DTMIterator iter = m_exprs[i].asIterator(m_execContext, context);\r\n                newIters[i] = iter;\r\n                iter.nextNode();\r\n            }\r\n            m_iterators = newIters;\r\n        }\r\n    } catch (Exception e) {\r\n        throw new org.apache.xml.utils.WrappedRuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.NodeVector.insertElementAt",
	"Comment": "inserts the specified node in this vector at the specified index.each component in this vector with an index greater or equal tothe specified index is shifted upward to have an index one greaterthan the value it had previously.",
	"Method": "void insertElementAt(int value,int at){\r\n    if (null == m_map) {\r\n        m_map = new int[m_blocksize];\r\n        m_mapSize = m_blocksize;\r\n    } else if ((m_firstFree + 1) >= m_mapSize) {\r\n        m_mapSize += m_blocksize;\r\n        int[] newMap = new int[m_mapSize];\r\n        System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);\r\n        m_map = newMap;\r\n    }\r\n    if (at <= (m_firstFree - 1)) {\r\n        System.arraycopy(m_map, at, m_map, at + 1, m_firstFree - at);\r\n    }\r\n    m_map[at] = value;\r\n    m_firstFree++;\r\n}"
}, {
	"Path": "hudson.scheduler.CronTab.checkSanity",
	"Comment": "checks if this crontab entry looks reasonable,and if not, return an warning message.the point of this method is to catch syntactically correctbut semantically suspicious combinations, like",
	"Method": "String checkSanity(){\r\n    OUTER: for (int i = 0; i < 5; i++) {\r\n        long bitMask = (i < 4) ? bits[i] : (long) dayOfWeek;\r\n        for (int j = BaseParser.LOWER_BOUNDS[i]; j <= BaseParser.UPPER_BOUNDS[i]; j++) {\r\n            if (!checkBits(bitMask, j)) {\r\n                if (i > 0)\r\n                    return Messages.CronTab_do_you_really_mean_every_minute_when_you(spec, \"H \" + spec.substring(spec.indexOf(' ') + 1));\r\n                break OUTER;\r\n            }\r\n        }\r\n    }\r\n    int daysOfMonth = 0;\r\n    for (int i = 1; i < 31; i++) {\r\n        if (checkBits(bits[2], i)) {\r\n            daysOfMonth++;\r\n        }\r\n    }\r\n    if (daysOfMonth > 5 && daysOfMonth < 28) {\r\n        return Messages.CronTab_short_cycles_in_the_day_of_month_field_w();\r\n    }\r\n    String hashified = hashify(spec);\r\n    if (hashified != null) {\r\n        return Messages.CronTab_spread_load_evenly_by_using_rather_than_(hashified, spec);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.plugins.common.BuildStepsRunner.forBuildToDockerDaemon",
	"Comment": "creates a runner to build to the docker daemon. creates a directory for the cache, if needed.",
	"Method": "BuildStepsRunner forBuildToDockerDaemon(ImageReference targetImageReference,Set<String> additionalTags){\r\n    return new BuildStepsRunner(buildMessageWithTargetImageReferences(targetImageReference, additionalTags, STARTUP_MESSAGE_PREFIX_FOR_DOCKER_DAEMON, \"...\"), buildMessageWithTargetImageReferences(targetImageReference, additionalTags, SUCCESS_MESSAGE_PREFIX_FOR_DOCKER_DAEMON, \"\"));\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.getTypedAxisIterator",
	"Comment": "get an iterator that can navigate over an xpath axis, predicated bythe extended type id.",
	"Method": "DTMAxisIterator getTypedAxisIterator(int axis,int type){\r\n    return null;\r\n}"
}, {
	"Path": "redis.clients.jedis.Jedis.move",
	"Comment": "move the specified key from the currently selected db to the specified destination db. notethat this command returns 1 only if the key was successfully moved, and 0 if the target key wasalready there or if the source key was not found at all, so it is possible to use move as alocking primitive.",
	"Method": "Long move(String key,int dbIndex){\r\n    checkIsInMultiOrPipeline();\r\n    client.move(key, dbIndex);\r\n    return client.getIntegerReply();\r\n}"
}, {
	"Path": "org.apache.xml.utils.IntStack.peek",
	"Comment": "looks at the object at the position the stack counting down n items.",
	"Method": "int peek(int peek,int n){\r\n    try {\r\n        return m_map[m_firstFree - (1 + n)];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new EmptyStackException();\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.plugins.common.BuildStepsRunner.forBuildImage",
	"Comment": "creates a runner to build an image. creates a directory for the cache, if needed.",
	"Method": "BuildStepsRunner forBuildImage(ImageReference targetImageReference,Set<String> additionalTags){\r\n    return new BuildStepsRunner(buildMessageWithTargetImageReferences(targetImageReference, additionalTags, STARTUP_MESSAGE_PREFIX_FOR_DOCKER_REGISTRY, \"...\"), buildMessageWithTargetImageReferences(targetImageReference, additionalTags, SUCCESS_MESSAGE_PREFIX_FOR_DOCKER_REGISTRY, \"\"));\r\n}"
}, {
	"Path": "org.apache.xalan.templates.Stylesheet.getHref",
	"Comment": "get the base identifier with which this stylesheet is associated.",
	"Method": "String getHref(){\r\n    return m_href;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprWalker.callPredicateVisitors",
	"Comment": "this will traverse the heararchy, calling the visitor for \teach member.if the called visitor method returns \tfalse, the subtree should not be called.",
	"Method": "void callPredicateVisitors(XPathVisitor visitor){\r\n    m_expr.callVisitors(new filterExprOwner(), visitor);\r\n    super.callPredicateVisitors(visitor);\r\n}"
}, {
	"Path": "jadx.core.dex.visitors.regions.LoopRegionVisitor.checkInvoke",
	"Comment": "check if instruction is a interface invoke with corresponding parameters.",
	"Method": "boolean checkInvoke(InsnNode insn,String declClsFullName,String mthId,int argsCount){\r\n    if (insn.getType() == InsnType.INVOKE) {\r\n        InvokeNode inv = (InvokeNode) insn;\r\n        MethodInfo callMth = inv.getCallMth();\r\n        if (callMth.getArgsCount() == argsCount && callMth.getShortId().equals(mthId) && inv.getInvokeType() == InvokeType.INTERFACE) {\r\n            return declClsFullName == null || callMth.getDeclClass().getFullName().equals(declClsFullName);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.iluwatar.reader.writer.lock.ReaderWriterLock.doesWriterOwnThisLock",
	"Comment": "return true when globalmutex hold the reference of writerlock",
	"Method": "boolean doesWriterOwnThisLock(){\r\n    return globalMutex.contains(writerLock);\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.setErrorListener",
	"Comment": "set the errorlistener where errors and warnings are to be reported.",
	"Method": "void setErrorListener(ErrorListener listener){\r\n    if (listener == null)\r\n        throw new IllegalArgumentException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, null));\r\n    m_errorListener = listener;\r\n}"
}, {
	"Path": "hudson.model.View.getDescription",
	"Comment": "message displayed in the top page. can be null. includes html.",
	"Method": "String getDescription(){\r\n    return description;\r\n}"
}, {
	"Path": "org.apache.xml.utils.IntVector.indexOf",
	"Comment": "searches for the first occurence of the given argument,beginning the search at index, and testing for equalityusing the equals method.",
	"Method": "int indexOf(int elem,int index,int indexOf,int elem){\r\n    for (int i = 0; i < m_firstFree; i++) {\r\n        if (m_map[i] == elem)\r\n            return i;\r\n    }\r\n    return java.lang.Integer.MIN_VALUE;\r\n}"
}, {
	"Path": "jadx.core.xmlgen.XMLChar.isValidIANAEncoding",
	"Comment": "returns true if the encoding name is a valid iana encoding.\tthis method does not verify that there is a decoder available\tfor this encoding, only that the characters are valid for an\tiana encoding name.",
	"Method": "boolean isValidIANAEncoding(String ianaEncoding){\r\n    if (ianaEncoding != null) {\r\n        int length = ianaEncoding.length();\r\n        if (length > 0) {\r\n            char c = ianaEncoding.charAt(0);\r\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\r\n                for (int i = 1; i < length; i++) {\r\n                    c = ianaEncoding.charAt(i);\r\n                    if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') && (c < '0' || c > '9') && c != '.' && c != '_' && c != '-') {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "hudson.tools.PropertyDescriptor.isApplicable",
	"Comment": "returns true if this property type is applicable to thegiven target type.the default implementation of this method checks if the given node type is assignableaccording to the parameterization, but subtypes can extend this to change this behavior.",
	"Method": "boolean isApplicable(Class<? extends T> targetType){\r\n    Class<? extends T> applicable = Functions.getTypeParameter(clazz, getP(), 0);\r\n    return applicable.isAssignableFrom(targetType);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.eleminateRedundentLocals",
	"Comment": "method to be called after the all expressions within annode context have been visited.it eliminates redundent expressions by creating a variable in the psuedovarrecipient for each redundent expression, and then rewriting the redundent expression to be a variable reference.",
	"Method": "void eleminateRedundentLocals(ElemTemplateElement psuedoVarRecipient){\r\n    eleminateRedundent(psuedoVarRecipient, m_paths);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.KeyDeclaration.recompose",
	"Comment": "this function is called during recomposition tocontrol how this element is composed.",
	"Method": "void recompose(StylesheetRoot root){\r\n    root.recomposeKeys(this);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.Stylesheet.setHref",
	"Comment": "set the base identifier with which this stylesheet is associated.",
	"Method": "void setHref(String baseIdent){\r\n    m_href = baseIdent;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.LSSerializerImpl.writeToString",
	"Comment": "serializes the specified node and returns a string with the serializeddata to the caller.",
	"Method": "String writeToString(Node nodeArg){\r\n    if (nodeArg == null) {\r\n        return null;\r\n    }\r\n    Serializer serializer = fXMLSerializer;\r\n    serializer.reset();\r\n    if (nodeArg != fVisitedNode) {\r\n        String xmlVersion = getXMLVersion(nodeArg);\r\n        serializer.getOutputFormat().setProperty(\"version\", xmlVersion);\r\n        fDOMConfigProperties.setProperty(DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.S_XML_VERSION, xmlVersion);\r\n        fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_ENCODING, \"UTF-16\");\r\n        if ((nodeArg.getNodeType() != Node.DOCUMENT_NODE || nodeArg.getNodeType() != Node.ELEMENT_NODE || nodeArg.getNodeType() != Node.ENTITY_NODE) && ((fFeatures & XMLDECL) != 0)) {\r\n            fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL, DOMConstants.DOM3_DEFAULT_FALSE);\r\n        }\r\n        fVisitedNode = nodeArg;\r\n    }\r\n    fXMLSerializer.setOutputFormat(fDOMConfigProperties);\r\n    StringWriter output = new StringWriter();\r\n    try {\r\n        serializer.setWriter(output);\r\n        if (fDOMSerializer == null) {\r\n            fDOMSerializer = (DOM3Serializer) serializer.asDOM3Serializer();\r\n        }\r\n        if (fDOMErrorHandler != null) {\r\n            fDOMSerializer.setErrorHandler(fDOMErrorHandler);\r\n        }\r\n        if (fSerializerFilter != null) {\r\n            fDOMSerializer.setNodeFilter(fSerializerFilter);\r\n        }\r\n        fDOMSerializer.setNewLine(fEndOfLine.toCharArray());\r\n        fDOMSerializer.serializeDOM3(nodeArg);\r\n    } catch (LSException lse) {\r\n        throw lse;\r\n    } catch (RuntimeException e) {\r\n        throw (LSException) createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();\r\n    } catch (Exception e) {\r\n        if (fDOMErrorHandler != null) {\r\n            fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, e.getMessage(), null, e));\r\n        }\r\n        throw (LSException) createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();\r\n    }\r\n    return output.toString();\r\n}"
}, {
	"Path": "hudson.util.CopyOnWriteMapTest.hashSerialization",
	"Comment": "verify that serialization form of copyonwritemap.hash and hashmap are the same.",
	"Method": "void hashSerialization(){\r\n    HashData td = new HashData();\r\n    XStream2 xs = new XStream2();\r\n    String out = xs.toXML(td);\r\n    assertEquals(\"empty maps\", \"<hudson.util.CopyOnWriteMapTest_-HashData>\" + \"<map1/><map2/><\/hudson.util.CopyOnWriteMapTest_-HashData>\", out.replaceAll(\"\\\\s+\", \"\"));\r\n    HashData td2 = (HashData) xs.fromXML(out);\r\n    assertTrue(td2.map1.isEmpty());\r\n    assertTrue(td2.map2.isEmpty());\r\n    td.map1.put(\"foo1\", \"bar1\");\r\n    td.map2.put(\"foo2\", \"bar2\");\r\n    out = xs.toXML(td);\r\n    assertEquals(\"maps\", \"<hudson.util.CopyOnWriteMapTest_-HashData><map1>\" + \"<entry><string>foo1<\/string><string>bar1<\/string><\/entry><\/map1>\" + \"<map2><entry><string>foo2<\/string><string>bar2<\/string><\/entry>\" + \"<\/map2><\/hudson.util.CopyOnWriteMapTest_-HashData>\", out.replaceAll(\"\\\\s+\", \"\"));\r\n    td2 = (HashData) xs.fromXML(out);\r\n    assertEquals(\"bar1\", td2.map1.get(\"foo1\"));\r\n    assertEquals(\"bar2\", td2.map2.get(\"foo2\"));\r\n}"
}, {
	"Path": "org.apache.xalan.processor.XSLTElementProcessor.setPropertiesFromAttributes",
	"Comment": "set the properties of an object from the given attribute list.",
	"Method": "void setPropertiesFromAttributes(StylesheetHandler handler,String rawName,Attributes attributes,ElemTemplateElement target,Attributes setPropertiesFromAttributes,StylesheetHandler handler,String rawName,Attributes attributes,ElemTemplateElement target,boolean throwError){\r\n    XSLTElementDef def = getElemDef();\r\n    AttributesImpl undefines = null;\r\n    boolean isCompatibleMode = ((null != handler.getStylesheet() && handler.getStylesheet().getCompatibleMode()) || !throwError);\r\n    if (isCompatibleMode)\r\n        undefines = new AttributesImpl();\r\n    List processedDefs = new ArrayList();\r\n    List errorDefs = new ArrayList();\r\n    int nAttrs = attributes.getLength();\r\n    for (int i = 0; i < nAttrs; i++) {\r\n        String attrUri = attributes.getURI(i);\r\n        if ((null != attrUri) && (attrUri.length() == 0) && (attributes.getQName(i).startsWith(\"xmlns:\") || attributes.getQName(i).equals(\"xmlns\"))) {\r\n            attrUri = org.apache.xalan.templates.Constants.S_XMLNAMESPACEURI;\r\n        }\r\n        String attrLocalName = attributes.getLocalName(i);\r\n        XSLTAttributeDef attrDef = def.getAttributeDef(attrUri, attrLocalName);\r\n        if (null == attrDef) {\r\n            if (!isCompatibleMode) {\r\n                handler.error(XSLTErrorResources.ER_ATTR_NOT_ALLOWED, new Object[] { attributes.getQName(i), rawName }, null);\r\n            } else {\r\n                undefines.addAttribute(attrUri, attrLocalName, attributes.getQName(i), attributes.getType(i), attributes.getValue(i));\r\n            }\r\n        } else {\r\n            if (handler.getStylesheetProcessor() == null)\r\n                System.out.println(\"stylesheet processor null\");\r\n            if (attrDef.getName().compareTo(\"*\") == 0 && handler.getStylesheetProcessor().isSecureProcessing()) {\r\n                handler.error(XSLTErrorResources.ER_ATTR_NOT_ALLOWED, new Object[] { attributes.getQName(i), rawName }, null);\r\n            } else {\r\n                boolean success = attrDef.setAttrValue(handler, attrUri, attrLocalName, attributes.getQName(i), attributes.getValue(i), target);\r\n                if (success)\r\n                    processedDefs.add(attrDef);\r\n                else\r\n                    errorDefs.add(attrDef);\r\n            }\r\n        }\r\n    }\r\n    XSLTAttributeDef[] attrDefs = def.getAttributes();\r\n    int nAttrDefs = attrDefs.length;\r\n    for (int i = 0; i < nAttrDefs; i++) {\r\n        XSLTAttributeDef attrDef = attrDefs[i];\r\n        String defVal = attrDef.getDefault();\r\n        if (null != defVal) {\r\n            if (!processedDefs.contains(attrDef)) {\r\n                attrDef.setDefAttrValue(handler, target);\r\n            }\r\n        }\r\n        if (attrDef.getRequired()) {\r\n            if ((!processedDefs.contains(attrDef)) && (!errorDefs.contains(attrDef)))\r\n                handler.error(XSLMessages.createMessage(XSLTErrorResources.ER_REQUIRES_ATTRIB, new Object[] { rawName, attrDef.getName() }), null);\r\n        }\r\n    }\r\n    return undefines;\r\n}"
}, {
	"Path": "hudson.Main.open",
	"Comment": "connects to the given http url and configure time out, to avoid infinite hang.",
	"Method": "HttpURLConnection open(URL url){\r\n    HttpURLConnection c = (HttpURLConnection) url.openConnection();\r\n    c.setReadTimeout(TIMEOUT);\r\n    c.setConnectTimeout(TIMEOUT);\r\n    return c;\r\n}"
}, {
	"Path": "hudson.util.IsOverriddenTest.isOverriddenNegativeTest",
	"Comment": "negative test.trying to check for a method which does not exist in the hierarchy,",
	"Method": "void isOverriddenNegativeTest(){\r\n    Util.isOverridden(Base.class, Derived.class, \"method2\");\r\n}"
}, {
	"Path": "hudson.ClassicPluginStrategy.getImpliedDependencies",
	"Comment": "returns all the plugin dependencies that are implicit based on a particular jenkins version",
	"Method": "List<PluginWrapper.Dependency> getImpliedDependencies(String pluginName,String jenkinsVersion){\r\n    List<PluginWrapper.Dependency> out = new ArrayList();\r\n    for (DetachedPlugin detached : DETACHED_LIST) {\r\n        if (detached.shortName.equals(pluginName)) {\r\n            continue;\r\n        }\r\n        if (BREAK_CYCLES.contains(pluginName + ' ' + detached.shortName)) {\r\n            LOGGER.log(Level.FINE, \"skipping implicit dependency {0} ? {1}\", new Object[] { pluginName, detached.shortName });\r\n            continue;\r\n        }\r\n        if (jenkinsVersion == null || jenkinsVersion.equals(\"null\") || new VersionNumber(jenkinsVersion).compareTo(detached.splitWhen) <= 0) {\r\n            out.add(new PluginWrapper.Dependency(detached.shortName + ':' + detached.requiredVersion));\r\n            LOGGER.log(Level.FINE, \"adding implicit dependency {0} ? {1} because of {2}\", new Object[] { pluginName, detached.shortName, jenkinsVersion });\r\n        }\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "hudson.ClassicPluginStrategy.getDetachedPlugins",
	"Comment": "get the list of plugins that have been detached since a specific jenkins release version.",
	"Method": "List<DetachedPlugin> getDetachedPlugins(List<DetachedPlugin> getDetachedPlugins,VersionNumber since){\r\n    List<DetachedPlugin> detachedPlugins = new ArrayList();\r\n    for (DetachedPlugin detachedPlugin : DETACHED_LIST) {\r\n        if (!detachedPlugin.getSplitWhen().isOlderThan(since)) {\r\n            detachedPlugins.add(detachedPlugin);\r\n        }\r\n    }\r\n    return detachedPlugins;\r\n}"
}, {
	"Path": "hudson.Functions.getRelativeNameFrom",
	"Comment": "gets the relative name or display name to the given item from the specified group.",
	"Method": "String getRelativeNameFrom(Item p,ItemGroup g,boolean useDisplayName,String getRelativeNameFrom,Item p,ItemGroup g){\r\n    return getRelativeNameFrom(p, g, false);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM2.getNodeValue",
	"Comment": "given a node handle, return its node value. this is mostlyas defined by the dom, but may ignore some conveniences.",
	"Method": "String getNodeValue(int nodeHandle){\r\n    int identity = makeNodeIdentity(nodeHandle);\r\n    int type = _type2(identity);\r\n    if (type == DTM.TEXT_NODE || type == DTM.CDATA_SECTION_NODE) {\r\n        int dataIndex = _dataOrQName(identity);\r\n        if (dataIndex > 0) {\r\n            return m_chars.getString(dataIndex >>> TEXT_LENGTH_BITS, dataIndex & TEXT_LENGTH_MAX);\r\n        } else {\r\n            return m_chars.getString(m_data.elementAt(-dataIndex), m_data.elementAt(-dataIndex + 1));\r\n        }\r\n    } else if (DTM.ELEMENT_NODE == type || DTM.DOCUMENT_FRAGMENT_NODE == type || DTM.DOCUMENT_NODE == type) {\r\n        return null;\r\n    } else {\r\n        int dataIndex = m_dataOrQName.elementAt(identity);\r\n        if (dataIndex < 0) {\r\n            dataIndex = -dataIndex;\r\n            dataIndex = m_data.elementAt(dataIndex + 1);\r\n        }\r\n        return (String) m_values.elementAt(dataIndex);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.axes.AxesWalker.detach",
	"Comment": "detaches the walker from the set which it iterated over, releasingany computational resources and placing the iterator in the invalidstate.",
	"Method": "void detach(){\r\n    m_currentNode = DTM.NULL;\r\n    m_dtm = null;\r\n    m_traverser = null;\r\n    m_isFresh = true;\r\n    m_root = DTM.NULL;\r\n}"
}, {
	"Path": "hudson.model.Fingerprint.getRangeSet",
	"Comment": "gets the build range set for the given job name.these builds of this job has used this file.",
	"Method": "RangeSet getRangeSet(String jobFullName,RangeSet getRangeSet,Job job){\r\n    return getRangeSet(job.getFullName());\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.registry.credentials.DockerConfigCredentialRetriever.retrieve",
	"Comment": "retrieves credentials for a registry. tries all possible known aliases.",
	"Method": "Optional<Credential> retrieve(Optional<Credential> retrieve,DockerConfig dockerConfig){\r\n    for (String registryAlias : RegistryAliasGroup.getAliasesGroup(registry)) {\r\n        String auth = dockerConfig.getAuthFor(registryAlias);\r\n        if (auth != null) {\r\n            String usernameColonPassword = new String(Base64.decodeBase64(auth), StandardCharsets.UTF_8);\r\n            String username = usernameColonPassword.substring(0, usernameColonPassword.indexOf(\":\"));\r\n            String password = usernameColonPassword.substring(usernameColonPassword.indexOf(\":\") + 1);\r\n            return Optional.of(Credential.basic(username, password));\r\n        }\r\n        DockerCredentialHelper dockerCredentialHelper = dockerConfig.getCredentialHelperFor(registryAlias);\r\n        if (dockerCredentialHelper != null) {\r\n            try {\r\n                return Optional.of(dockerCredentialHelper.retrieve());\r\n            } catch (IOException | CredentialHelperUnhandledServerUrlException | CredentialHelperNotFoundException ex) {\r\n            }\r\n        }\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.setDocumentLocator",
	"Comment": "receive an object for locating the origin of sax document events.",
	"Method": "void setDocumentLocator(Locator locator){\r\n    return;\r\n}"
}, {
	"Path": "hudson.util.SecretRewriter.rewriteRecursive",
	"Comment": "synchronized to prevent accidental concurrent use. this instance is not thread safe",
	"Method": "int rewriteRecursive(File dir,TaskListener listener,int rewriteRecursive,File dir,String relative,TaskListener listener){\r\n    String canonical;\r\n    try {\r\n        canonical = dir.toPath().toRealPath(new LinkOption[0]).toString();\r\n    } catch (IOException | InvalidPathException e) {\r\n        canonical = dir.getAbsolutePath();\r\n    }\r\n    if (!callstack.add(canonical)) {\r\n        listener.getLogger().println(\"Cycle detected: \" + dir);\r\n        return 0;\r\n    }\r\n    try {\r\n        File[] children = dir.listFiles();\r\n        if (children == null)\r\n            return 0;\r\n        int rewritten = 0;\r\n        for (File child : children) {\r\n            String cn = child.getName();\r\n            if (cn.endsWith(\".xml\")) {\r\n                if ((count++) % 100 == 0)\r\n                    listener.getLogger().println(\"Scanning \" + child);\r\n                try {\r\n                    if (rewrite(child)) {\r\n                        listener.getLogger().println(\"Rewritten \" + child);\r\n                        rewritten++;\r\n                    }\r\n                } catch (IOException e) {\r\n                    Functions.printStackTrace(e, listener.error(\"Failed to rewrite \" + child));\r\n                }\r\n            }\r\n            if (child.isDirectory()) {\r\n                if (!isIgnoredDir(child))\r\n                    rewritten += rewriteRecursive(child, relative.length() == 0 ? cn : relative + '/' + cn, listener);\r\n            }\r\n        }\r\n        return rewritten;\r\n    } finally {\r\n        callstack.remove(canonical);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.axes.WalkingIteratorSorted.canBeWalkedInNaturalDocOrderStatic",
	"Comment": "tell if the nodeset can be walked in doc order, via static analysis.",
	"Method": "boolean canBeWalkedInNaturalDocOrderStatic(){\r\n    if (null != m_firstWalker) {\r\n        AxesWalker walker = m_firstWalker;\r\n        int prevAxis = -1;\r\n        boolean prevIsSimpleDownAxis = true;\r\n        for (int i = 0; null != walker; i++) {\r\n            int axis = walker.getAxis();\r\n            if (walker.isDocOrdered()) {\r\n                boolean isSimpleDownAxis = ((axis == Axis.CHILD) || (axis == Axis.SELF) || (axis == Axis.ROOT));\r\n                if (isSimpleDownAxis || (axis == -1))\r\n                    walker = walker.getNextWalker();\r\n                else {\r\n                    boolean isLastWalker = (null == walker.getNextWalker());\r\n                    if (isLastWalker) {\r\n                        if (walker.isDocOrdered() && (axis == Axis.DESCENDANT || axis == Axis.DESCENDANTORSELF || axis == Axis.DESCENDANTSFROMROOT || axis == Axis.DESCENDANTSORSELFFROMROOT) || (axis == Axis.ATTRIBUTE))\r\n                            return true;\r\n                    }\r\n                    return false;\r\n                }\r\n            } else\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jenkins.install.SetupWizard.checkFilter",
	"Comment": "sets up the setup wizard filter if the current state requires it.",
	"Method": "void checkFilter(){\r\n    if (!Jenkins.get().getInstallState().isSetupComplete()) {\r\n        setUpFilter();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemNumber.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n    StylesheetRoot.ComposeState cstate = sroot.getComposeState();\r\n    java.util.Vector vnames = cstate.getVariableNames();\r\n    if (null != m_countMatchPattern)\r\n        m_countMatchPattern.fixupVariables(vnames, cstate.getGlobalsSize());\r\n    if (null != m_format_avt)\r\n        m_format_avt.fixupVariables(vnames, cstate.getGlobalsSize());\r\n    if (null != m_fromMatchPattern)\r\n        m_fromMatchPattern.fixupVariables(vnames, cstate.getGlobalsSize());\r\n    if (null != m_groupingSeparator_avt)\r\n        m_groupingSeparator_avt.fixupVariables(vnames, cstate.getGlobalsSize());\r\n    if (null != m_groupingSize_avt)\r\n        m_groupingSize_avt.fixupVariables(vnames, cstate.getGlobalsSize());\r\n    if (null != m_lang_avt)\r\n        m_lang_avt.fixupVariables(vnames, cstate.getGlobalsSize());\r\n    if (null != m_lettervalue_avt)\r\n        m_lettervalue_avt.fixupVariables(vnames, cstate.getGlobalsSize());\r\n    if (null != m_valueExpr)\r\n        m_valueExpr.fixupVariables(vnames, cstate.getGlobalsSize());\r\n}"
}, {
	"Path": "org.apache.xml.serializer.NamespaceMappings.lookupAllPrefixes",
	"Comment": "given a namespace uri, get all prefixes bound to the namespace uri in the current scope.",
	"Method": "String[] lookupAllPrefixes(String uri){\r\n    java.util.ArrayList foundPrefixes = new java.util.ArrayList();\r\n    Enumeration prefixes = m_namespaces.keys();\r\n    while (prefixes.hasMoreElements()) {\r\n        String prefix = (String) prefixes.nextElement();\r\n        String uri2 = lookupNamespace(prefix);\r\n        if (uri2 != null && uri2.equals(uri)) {\r\n            foundPrefixes.add(prefix);\r\n        }\r\n    }\r\n    String[] prefixArray = new String[foundPrefixes.size()];\r\n    foundPrefixes.toArray(prefixArray);\r\n    return prefixArray;\r\n}"
}, {
	"Path": "jenkins.model.RunIdMigratorTest.logging",
	"Comment": "todo could use loggerrule only if it were extracted to an independent library",
	"Method": "void logging(){\r\n    RunIdMigrator.LOGGER.setLevel(Level.ALL);\r\n    Handler handler = new ConsoleHandler();\r\n    handler.setLevel(Level.ALL);\r\n    RunIdMigrator.LOGGER.addHandler(handler);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.skippedEntity",
	"Comment": "receive notification of a skipped entity.by default, do nothing.application writers may override thismethod in a subclass to take specific actions for eachprocessing instruction, such as setting status variables orinvoking other methods.",
	"Method": "void skippedEntity(String name){\r\n    if (!m_shouldProcess)\r\n        return;\r\n    getCurrentProcessor().skippedEntity(this, name);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.ProcessorImport.getStylesheetInclErr",
	"Comment": "get the error number associated with this type of stylesheet importing itself",
	"Method": "String getStylesheetInclErr(){\r\n    return XSLTErrorResources.ER_IMPORTING_ITSELF;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.getNextSibling",
	"Comment": "given a node handle, advance to its next sibling.if not yet resolved, waits for more nodes to be added to the document andtries again.",
	"Method": "int getNextSibling(int nodeHandle){\r\n    if (nodeHandle == DTM.NULL)\r\n        return DTM.NULL;\r\n    return makeNodeHandle(_nextsib(makeNodeIdentity(nodeHandle)));\r\n}"
}, {
	"Path": "jenkins.org.apache.commons.validator.routines.UrlValidator.isValidFragment",
	"Comment": "returns true if the given fragment is null or fragments are allowed.",
	"Method": "boolean isValidFragment(String fragment){\r\n    if (fragment == null) {\r\n        return true;\r\n    }\r\n    return isOff(NO_FRAGMENTS);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.shouldStripWhiteSpace",
	"Comment": "get information about whether or not an element should strip whitespace.",
	"Method": "boolean shouldStripWhiteSpace(org.apache.xpath.XPathContext support,org.w3c.dom.Element targetElement){\r\n    StylesheetRoot sroot = this.getStylesheetRoot();\r\n    return (null != sroot) ? sroot.shouldStripWhiteSpace(support, targetElement) : false;\r\n}"
}, {
	"Path": "hudson.model.AdministrativeMonitor.disable",
	"Comment": "mark this monitor as disabled, to prevent this from showing up in the ui.",
	"Method": "void disable(boolean value){\r\n    AbstractCIBase hudson = Jenkins.getInstance();\r\n    Set<String> set = hudson.disabledAdministrativeMonitors;\r\n    if (value)\r\n        set.add(id);\r\n    else\r\n        set.remove(id);\r\n    hudson.save();\r\n}"
}, {
	"Path": "com.sun.jna.platform.linux.XAttrUtil.lGetXAttrAsMemory",
	"Comment": "get extended attribute value but in case of symbolic link get the value from the linkitself instead of linked file.",
	"Method": "Memory lGetXAttrAsMemory(String path,String name){\r\n    ssize_t retval;\r\n    Memory valueMem;\r\n    int eno = 0;\r\n    do {\r\n        retval = XAttr.INSTANCE.lgetxattr(path, name, (Memory) null, size_t.ZERO);\r\n        if (retval.longValue() < 0) {\r\n            eno = Native.getLastError();\r\n            throw new IOException(\"errno: \" + eno);\r\n        }\r\n        valueMem = new Memory(retval.longValue());\r\n        retval = XAttr.INSTANCE.lgetxattr(path, name, valueMem, new size_t(valueMem.size()));\r\n        if (retval.longValue() < 0) {\r\n            eno = Native.getLastError();\r\n            if (eno != XAttr.ERANGE) {\r\n                throw new IOException(\"errno: \" + eno);\r\n            }\r\n        }\r\n    } while (retval.longValue() < 0 && eno == XAttr.ERANGE);\r\n    return valueMem;\r\n}"
}, {
	"Path": "jenkins.install.InstallUtil.getPersistedInstallStatus",
	"Comment": "returns a list of any plugins that are persisted in the installing list",
	"Method": "Map<String, String> getPersistedInstallStatus(){\r\n    File installingPluginsFile = getInstallingPluginsFile();\r\n    if (installingPluginsFile == null || !installingPluginsFile.exists()) {\r\n        return null;\r\n    }\r\n    return (Map<String, String>) new XStream().fromXML(installingPluginsFile);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.DTMAxisTraverser.first",
	"Comment": "by the nature of the stateless traversal, the context node can not bereturned or the iteration will go into an infinate loop.so to traverse an axis, the first function must be used to get the first node.this method needs to be overloaded only by those axis that processthe self node.",
	"Method": "int first(int context,int first,int context,int extendedTypeID){\r\n    return next(context, context, extendedTypeID);\r\n}"
}, {
	"Path": "jenkins.security.Security218Test.check",
	"Comment": "the attack scenario here is that a master sends a normal command to a slave and a slaveinserts a malicious response.",
	"Method": "void check(DumbSlave s){\r\n    try {\r\n        Object o = s.getComputer().getChannel().call(new EvilReturnValue());\r\n        fail(\"Expected the connection to die: \" + o);\r\n    } catch (Exception e) {\r\n        assertThat(e.getMessage(), containsString(MethodClosure.class.getName()));\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncRound.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    final XObject obj = m_arg0.execute(xctxt);\r\n    final double val = obj.num();\r\n    if (val >= -0.5 && val < 0)\r\n        return new XNumber(-0.0);\r\n    if (val == 0.0)\r\n        return new XNumber(val);\r\n    return new XNumber(java.lang.Math.floor(val + 0.5));\r\n}"
}, {
	"Path": "jenkins.model.lazy.FakeMapBuilder.addUnloadable",
	"Comment": "adds a build record under the givn id but make it unloadable,which will cause a failure when a load is attempted on this build id.",
	"Method": "FakeMapBuilder addUnloadable(int n){\r\n    File build = new File(dir, Integer.toString(n));\r\n    build.mkdir();\r\n    return this;\r\n}"
}, {
	"Path": "com.iluwatar.servicelayer.hibernate.HibernateUtil.getSessionFactory",
	"Comment": "create the current session factory instance, create a new one when there is none yet.",
	"Method": "SessionFactory getSessionFactory(){\r\n    if (sessionFactory == null) {\r\n        try {\r\n            sessionFactory = new Configuration().addAnnotatedClass(Wizard.class).addAnnotatedClass(Spellbook.class).addAnnotatedClass(Spell.class).setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.H2Dialect\").setProperty(\"hibernate.connection.url\", \"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\").setProperty(\"hibernate.current_session_context_class\", \"thread\").setProperty(\"hibernate.show_sql\", \"false\").setProperty(\"hibernate.hbm2ddl.auto\", \"create-drop\").buildSessionFactory();\r\n        } catch (Throwable ex) {\r\n            LOGGER.error(\"Initial SessionFactory creation failed.\", ex);\r\n            throw new ExceptionInInitializerError(ex);\r\n        }\r\n    }\r\n    return sessionFactory;\r\n}"
}, {
	"Path": "hudson.model.ViewTest.testAddDisplayNamesToSearchIndex",
	"Comment": "this test verifies that urls and displaynames in the toplevelitem listare added to the searchindexbuilder",
	"Method": "void testAddDisplayNamesToSearchIndex(){\r\n    final String url1 = \"url1\";\r\n    final String displayName1 = \"displayName1\";\r\n    final String url2 = \"url2\";\r\n    final String displayName2 = \"displayName2\";\r\n    SearchIndexBuilder sib = new SearchIndexBuilder();\r\n    TopLevelItem item1 = Mockito.mock(TopLevelItem.class);\r\n    Mockito.when(item1.getSearchUrl()).thenReturn(url1);\r\n    Mockito.when(item1.getDisplayName()).thenReturn(displayName1);\r\n    TopLevelItem item2 = Mockito.mock(TopLevelItem.class);\r\n    Mockito.when(item2.getSearchUrl()).thenReturn(url2);\r\n    Mockito.when(item2.getDisplayName()).thenReturn(displayName2);\r\n    Collection<TopLevelItem> items = new ArrayList<TopLevelItem>();\r\n    items.add(item1);\r\n    items.add(item2);\r\n    View view = Mockito.mock(View.class);\r\n    Mockito.doCallRealMethod().when(view).addDisplayNamesToSearchIndex(sib, items);\r\n    view.addDisplayNamesToSearchIndex(sib, items);\r\n    SearchIndex index = sib.make();\r\n    List<SearchItem> result = new ArrayList<SearchItem>();\r\n    index.find(displayName1, result);\r\n    assertEquals(1, result.size());\r\n    SearchItem actual = result.get(0);\r\n    assertEquals(actual.getSearchName(), item1.getDisplayName());\r\n    assertEquals(actual.getSearchUrl(), item1.getSearchUrl());\r\n    result.clear();\r\n    index.find(displayName2, result);\r\n    assertEquals(1, result.size());\r\n    actual = result.get(0);\r\n    assertEquals(actual.getSearchName(), item2.getDisplayName());\r\n    assertEquals(actual.getSearchUrl(), item2.getSearchUrl());\r\n}"
}, {
	"Path": "org.apache.xalan.xslt.ObjectFactory.findJarServiceProviderName",
	"Comment": "find the name of service provider using jar service provider mechanism",
	"Method": "String findJarServiceProviderName(String factoryId){\r\n    SecuritySupport ss = SecuritySupport.getInstance();\r\n    String serviceId = SERVICES_PATH + factoryId;\r\n    InputStream is = null;\r\n    ClassLoader cl = findClassLoader();\r\n    is = ss.getResourceAsStream(cl, serviceId);\r\n    if (is == null) {\r\n        ClassLoader current = ObjectFactory.class.getClassLoader();\r\n        if (cl != current) {\r\n            cl = current;\r\n            is = ss.getResourceAsStream(cl, serviceId);\r\n        }\r\n    }\r\n    if (is == null) {\r\n        return null;\r\n    }\r\n    debugPrintln(\"found jar resource=\" + serviceId + \" using ClassLoader: \" + cl);\r\n    BufferedReader rd;\r\n    try {\r\n        rd = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n    } catch (java.io.UnsupportedEncodingException e) {\r\n        rd = new BufferedReader(new InputStreamReader(is));\r\n    }\r\n    String factoryClassName = null;\r\n    try {\r\n        factoryClassName = rd.readLine();\r\n    } catch (IOException x) {\r\n        return null;\r\n    } finally {\r\n        try {\r\n            rd.close();\r\n        } catch (IOException exc) {\r\n        }\r\n    }\r\n    if (factoryClassName != null && !\"\".equals(factoryClassName)) {\r\n        debugPrintln(\"found in resource, value=\" + factoryClassName);\r\n        return factoryClassName;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "hudson.util.spring.BeanBuilder.manageMapIfNecessary",
	"Comment": "checks whether there are any runtime refs inside a map and converts\tit to a managedmap if necessary",
	"Method": "Object manageMapIfNecessary(Map<Object, Object> value){\r\n    boolean containsRuntimeRefs = false;\r\n    for (Entry<Object, Object> e : value.entrySet()) {\r\n        Object v = e.getValue();\r\n        if (v instanceof RuntimeBeanReference) {\r\n            containsRuntimeRefs = true;\r\n        }\r\n        if (v instanceof BeanConfiguration) {\r\n            BeanConfiguration c = (BeanConfiguration) v;\r\n            e.setValue(c.getBeanDefinition());\r\n            containsRuntimeRefs = true;\r\n        }\r\n    }\r\n    if (containsRuntimeRefs) {\r\n        ManagedMap m = new ManagedMap();\r\n        m.putAll(value);\r\n        return m;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FunctionOneArg.setArg",
	"Comment": "set an argument expression for a function.this method is called by the xpath compiler.",
	"Method": "void setArg(Expression arg,int argNum){\r\n    if (0 == argNum) {\r\n        m_arg0 = arg;\r\n        arg.exprSetParent(this);\r\n    } else\r\n        reportWrongNumberArgs();\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.FunctionTable.getFunctionName",
	"Comment": "return the name of the a function in the static table. needed to avoidmaking the table publicly available.",
	"Method": "String getFunctionName(int funcID){\r\n    if (funcID < NUM_BUILT_IN_FUNCS)\r\n        return m_functions[funcID].getName();\r\n    else\r\n        return m_functions_customer[funcID - NUM_BUILT_IN_FUNCS].getName();\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FunctionMultiArgs.getArgs",
	"Comment": "return an expression array containing arguments at index 3 or greater.",
	"Method": "Expression[] getArgs(){\r\n    return m_args;\r\n}"
}, {
	"Path": "jenkins.org.apache.commons.validator.routines.DomainValidator.getInstance",
	"Comment": "returns the singleton instance of this validator, with local validation as required.",
	"Method": "DomainValidator getInstance(DomainValidator getInstance,boolean allowLocal){\r\n    inUse = true;\r\n    if (allowLocal) {\r\n        return DOMAIN_VALIDATOR_WITH_LOCAL;\r\n    }\r\n    return DOMAIN_VALIDATOR;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.getElemTemplateElement",
	"Comment": "get the current elemtemplateelement at the top of the stack.",
	"Method": "ElemTemplateElement getElemTemplateElement(){\r\n    try {\r\n        return (ElemTemplateElement) m_elems.peek();\r\n    } catch (java.util.EmptyStackException ese) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.extensions.ExtensionNamespacesManager.registerUnregisteredNamespaces",
	"Comment": "attempt to register any unregistered extension namespaces.",
	"Method": "void registerUnregisteredNamespaces(){\r\n    for (int i = 0; i < m_unregisteredExtensions.size(); i++) {\r\n        String ns = (String) m_unregisteredExtensions.get(i);\r\n        ExtensionNamespaceSupport extNsSpt = defineJavaNamespace(ns);\r\n        if (extNsSpt != null)\r\n            m_extensions.add(extNsSpt);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.XPathParser.lookbehind",
	"Comment": "look behind the first character of the current token in order tomake a branching decision.",
	"Method": "boolean lookbehind(char c,int n){\r\n    boolean isToken;\r\n    int lookBehindPos = m_queueMark - (n + 1);\r\n    if (lookBehindPos >= 0) {\r\n        String lookbehind = (String) m_ops.m_tokenQueue.elementAt(lookBehindPos);\r\n        if (lookbehind.length() == 1) {\r\n            char c0 = (lookbehind == null) ? '|' : lookbehind.charAt(0);\r\n            isToken = (c0 == '|') ? false : (c0 == c);\r\n        } else {\r\n            isToken = false;\r\n        }\r\n    } else {\r\n        isToken = false;\r\n    }\r\n    return isToken;\r\n}"
}, {
	"Path": "hudson.model.AsyncPeriodicWork.getErrorLoggingLevel",
	"Comment": "returns the logging level at which error messages are displayed.",
	"Method": "Level getErrorLoggingLevel(){\r\n    return Level.SEVERE;\r\n}"
}, {
	"Path": "jenkins.security.s2m.CallableRejectionConfig.report",
	"Comment": "this method gets called every time we see a new type of callable that we reject,so that we can persist the list.",
	"Method": "void report(Class c){\r\n    if (!get().contains(c)) {\r\n        try {\r\n            append(c.getName());\r\n        } catch (IOException e) {\r\n            LOGGER.log(Level.WARNING, \"Failed to persist \" + file, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemElement.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n    StylesheetRoot.ComposeState cstate = sroot.getComposeState();\r\n    java.util.Vector vnames = cstate.getVariableNames();\r\n    if (null != m_name_avt)\r\n        m_name_avt.fixupVariables(vnames, cstate.getGlobalsSize());\r\n    if (null != m_namespace_avt)\r\n        m_namespace_avt.fixupVariables(vnames, cstate.getGlobalsSize());\r\n}"
}, {
	"Path": "org.apache.xalan.res.XSLMessages.createWarning",
	"Comment": "creates a message from the specified key and replacementarguments, localized to the given locale.",
	"Method": "String createWarning(String msgKey,Object args){\r\n    return createMsg(XSLTBundle, msgKey, args);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.getStylesheet",
	"Comment": "get the owning stylesheet.this looks up theinheritance chain until it calls getstylesheeton a stylesheet object, which will return itself.",
	"Method": "Stylesheet getStylesheet(){\r\n    return (null == m_parentNode) ? null : m_parentNode.getStylesheet();\r\n}"
}, {
	"Path": "org.apache.xml.utils.StringBufferPool.get",
	"Comment": "get the first free instance of a string buffer, or create one if there are no free instances.",
	"Method": "FastStringBuffer get(){\r\n    return (FastStringBuffer) m_stringBufPool.getInstance();\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerIdentityImpl.processingInstruction",
	"Comment": "receive notification of a processing instruction.by default, do nothing.application writers may override thismethod in a subclass to take specific actions for eachprocessing instruction, such as setting status variables orinvoking other methods.",
	"Method": "void processingInstruction(String target,String data){\r\n    flushStartDoc();\r\n    m_resultContentHandler.processingInstruction(target, data);\r\n}"
}, {
	"Path": "jenkins.security.apitoken.ApiTokenStore.revokeToken",
	"Comment": "remove a token given its identifier. effectively make it unusable for future connection.",
	"Method": "HashedToken revokeToken(String tokenUuid){\r\n    for (Iterator<HashedToken> iterator = tokenList.iterator(); iterator.hasNext(); ) {\r\n        HashedToken token = iterator.next();\r\n        if (token.uuid.equals(tokenUuid)) {\r\n            iterator.remove();\r\n            return token;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "hudson.model.ItemGroupMixInTest.xmlFileFailsToLoad",
	"Comment": "this test unit makes sure that if part of the config.xml file isdeleted it will still load everything else inside the folder.the test unit expects an ioexception is thrown, and the one failedjob fails to load.",
	"Method": "void xmlFileFailsToLoad(){\r\n    MockFolder folder = r.createFolder(\"folder\");\r\n    assertNotNull(folder);\r\n    AbstractProject project = folder.createProject(FreeStyleProject.class, \"job1\");\r\n    AbstractProject project2 = folder.createProject(FreeStyleProject.class, \"job2\");\r\n    AbstractProject project3 = folder.createProject(FreeStyleProject.class, \"job3\");\r\n    File configFile = project.getConfigFile().getFile();\r\n    List<String> lines = FileUtils.readLines(configFile).subList(0, 5);\r\n    configFile.delete();\r\n    FileUtils.writeByteArrayToFile(configFile, lines.toString().getBytes());\r\n    for (int i = lines.size() / 2; i < lines.size(); i++) {\r\n        FileUtils.writeStringToFile(configFile, lines.get(i), true);\r\n    }\r\n    r.jenkins.reload();\r\n    assertNotNull(\"Folder failed to load.\", r.jenkins.getItemByFullName(\"folder\"));\r\n    assertNull(\"Job should have failed to load.\", r.jenkins.getItemByFullName(\"folder/job1\"));\r\n    assertNotNull(\"Other job in folder should have loaded.\", r.jenkins.getItemByFullName(\"folder/job2\"));\r\n    assertNotNull(\"Other job in folder should have loaded.\", r.jenkins.getItemByFullName(\"folder/job3\"));\r\n}"
}, {
	"Path": "org.apache.xalan.templates.TemplateList.compose",
	"Comment": "after all templates have been added, this functionshould be called.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    if (DEBUG) {\r\n        System.out.println(\"Before wildcard insert...\");\r\n        dumpAssociationTables();\r\n    }\r\n    if (null != m_wildCardPatterns) {\r\n        Enumeration associations = m_patternTable.elements();\r\n        while (associations.hasMoreElements()) {\r\n            TemplateSubPatternAssociation head = (TemplateSubPatternAssociation) associations.nextElement();\r\n            TemplateSubPatternAssociation wild = m_wildCardPatterns;\r\n            while (null != wild) {\r\n                try {\r\n                    head = insertAssociationIntoList(head, (TemplateSubPatternAssociation) wild.clone(), true);\r\n                } catch (CloneNotSupportedException cnse) {\r\n                }\r\n                wild = wild.getNext();\r\n            }\r\n        }\r\n    }\r\n    if (DEBUG) {\r\n        System.out.println(\"After wildcard insert...\");\r\n        dumpAssociationTables();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.CoroutineManager.co_exit_to",
	"Comment": "make the id available for reuse and terminate this coroutine,transferring control to the specified coroutine. note that thisreturns immediately rather than waiting for any further coroutinetraffic, so the thread can proceed with other shutdown activities.",
	"Method": "void co_exit_to(Object arg_object,int thisCoroutine,int toCoroutine){\r\n    if (!m_activeIDs.get(toCoroutine))\r\n        throw new java.lang.NoSuchMethodException(XMLMessages.createXMLMessage(XMLErrorResources.ER_COROUTINE_NOT_AVAIL, new Object[] { Integer.toString(toCoroutine) }));\r\n    m_yield = arg_object;\r\n    m_nextCoroutine = toCoroutine;\r\n    m_activeIDs.clear(thisCoroutine);\r\n    notify();\r\n}"
}, {
	"Path": "org.apache.xpath.axes.UnionPathIterator.createUnionIterator",
	"Comment": "this will return an iterator capable of handling the union of paths given.",
	"Method": "LocPathIterator createUnionIterator(Compiler compiler,int opPos){\r\n    UnionPathIterator upi = new UnionPathIterator(compiler, opPos);\r\n    int nPaths = upi.m_exprs.length;\r\n    boolean isAllChildIterators = true;\r\n    for (int i = 0; i < nPaths; i++) {\r\n        LocPathIterator lpi = upi.m_exprs[i];\r\n        if (lpi.getAxis() != Axis.CHILD) {\r\n            isAllChildIterators = false;\r\n            break;\r\n        } else {\r\n            if (HasPositionalPredChecker.check(lpi)) {\r\n                isAllChildIterators = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (isAllChildIterators) {\r\n        UnionChildIterator uci = new UnionChildIterator();\r\n        for (int i = 0; i < nPaths; i++) {\r\n            PredicatedNodeTest lpi = upi.m_exprs[i];\r\n            uci.addNodeTest(lpi);\r\n        }\r\n        return uci;\r\n    } else\r\n        return upi;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.WalkerFactory.getAxisFromStep",
	"Comment": "special purpose function to see if we can optimize the pattern for a descendantiterator.",
	"Method": "int getAxisFromStep(Compiler compiler,int stepOpCodePos){\r\n    int stepType = compiler.getOp(stepOpCodePos);\r\n    switch(stepType) {\r\n        case OpCodes.FROM_FOLLOWING:\r\n            return Axis.FOLLOWING;\r\n        case OpCodes.FROM_FOLLOWING_SIBLINGS:\r\n            return Axis.FOLLOWINGSIBLING;\r\n        case OpCodes.FROM_PRECEDING:\r\n            return Axis.PRECEDING;\r\n        case OpCodes.FROM_PRECEDING_SIBLINGS:\r\n            return Axis.PRECEDINGSIBLING;\r\n        case OpCodes.FROM_PARENT:\r\n            return Axis.PARENT;\r\n        case OpCodes.FROM_NAMESPACE:\r\n            return Axis.NAMESPACE;\r\n        case OpCodes.FROM_ANCESTORS:\r\n            return Axis.ANCESTOR;\r\n        case OpCodes.FROM_ANCESTORS_OR_SELF:\r\n            return Axis.ANCESTORORSELF;\r\n        case OpCodes.FROM_ATTRIBUTES:\r\n            return Axis.ATTRIBUTE;\r\n        case OpCodes.FROM_ROOT:\r\n            return Axis.ROOT;\r\n        case OpCodes.FROM_CHILDREN:\r\n            return Axis.CHILD;\r\n        case OpCodes.FROM_DESCENDANTS_OR_SELF:\r\n            return Axis.DESCENDANTORSELF;\r\n        case OpCodes.FROM_DESCENDANTS:\r\n            return Axis.DESCENDANT;\r\n        case OpCodes.FROM_SELF:\r\n            return Axis.SELF;\r\n        case OpCodes.OP_EXTFUNCTION:\r\n        case OpCodes.OP_FUNCTION:\r\n        case OpCodes.OP_GROUP:\r\n        case OpCodes.OP_VARIABLE:\r\n            return Axis.FILTEREDLIST;\r\n    }\r\n    throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[] { Integer.toString(stepType) }));\r\n}"
}, {
	"Path": "org.apache.xpath.XPath.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    m_mainExp.fixupVariables(vars, globalsSize);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.Encodings.toUpperCaseFast",
	"Comment": "a fast and cheap way to uppercase a string that isonly made of printable ascii characters.this is not a public api.",
	"Method": "String toUpperCaseFast(String s){\r\n    boolean different = false;\r\n    final int mx = s.length();\r\n    char[] chars = new char[mx];\r\n    for (int i = 0; i < mx; i++) {\r\n        char ch = s.charAt(i);\r\n        if ('a' <= ch && ch <= 'z') {\r\n            ch = (char) (ch + ('A' - 'a'));\r\n            different = true;\r\n        }\r\n        chars[i] = ch;\r\n    }\r\n    final String upper;\r\n    if (different)\r\n        upper = String.valueOf(chars);\r\n    else\r\n        upper = s;\r\n    return upper;\r\n}"
}, {
	"Path": "hudson.model.Queue.clear",
	"Comment": "wipes out all the items currently in the queue, as if all of them are cancelled at once.",
	"Method": "void clear(){\r\n    Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\r\n    lock.lock();\r\n    try {\r\n        try {\r\n            for (WaitingItem i : new ArrayList<WaitingItem>(waitingList)) i.cancel(this);\r\n            blockedProjects.cancelAll();\r\n            pendings.cancelAll();\r\n            buildables.cancelAll();\r\n        } finally {\r\n            updateSnapshot();\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n    scheduleMaintenance();\r\n}"
}, {
	"Path": "hudson.console.ConsoleAnnotator._for",
	"Comment": "list all the console annotators that can work for the specified context type.",
	"Method": "List<ConsoleAnnotator<T>> _for(T context){\r\n    List<ConsoleAnnotator<T>> r = new ArrayList();\r\n    for (ConsoleAnnotatorFactory f : ConsoleAnnotatorFactory.all()) {\r\n        if (f.type().isInstance(context)) {\r\n            ConsoleAnnotator ca = f.newInstance(context);\r\n            if (ca != null)\r\n                r.add(ca);\r\n        }\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "org.java_websocket.exceptions.InvalidEncodingException.getEncodingException",
	"Comment": "get the exception which includes more information on the unsupported encoding",
	"Method": "UnsupportedEncodingException getEncodingException(){\r\n    return encodingException;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncLang.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    String lang = m_arg0.execute(xctxt).str();\r\n    int parent = xctxt.getCurrentNode();\r\n    boolean isLang = false;\r\n    DTM dtm = xctxt.getDTM(parent);\r\n    while (DTM.NULL != parent) {\r\n        if (DTM.ELEMENT_NODE == dtm.getNodeType(parent)) {\r\n            int langAttr = dtm.getAttributeNode(parent, \"http://www.w3.org/XML/1998/namespace\", \"lang\");\r\n            if (DTM.NULL != langAttr) {\r\n                String langVal = dtm.getNodeValue(langAttr);\r\n                if (langVal.toLowerCase().startsWith(lang.toLowerCase())) {\r\n                    int valLen = lang.length();\r\n                    if ((langVal.length() == valLen) || (langVal.charAt(valLen) == '-')) {\r\n                        isLang = true;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        parent = dtm.getParent(parent);\r\n    }\r\n    return isLang ? XBoolean.S_TRUE : XBoolean.S_FALSE;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.createPseudoVarDecl",
	"Comment": "create a psuedo variable reference that will represent the shared redundent xpath, and add it to the stylesheet.",
	"Method": "ElemVariable createPseudoVarDecl(ElemTemplateElement psuedoVarRecipient,LocPathIterator lpi,boolean isGlobal){\r\n    QName uniquePseudoVarName = new QName(PSUEDOVARNAMESPACE, \"#\" + getPseudoVarID());\r\n    if (isGlobal) {\r\n        return createGlobalPseudoVarDecl(uniquePseudoVarName, (StylesheetRoot) psuedoVarRecipient, lpi);\r\n    } else\r\n        return createLocalPseudoVarDecl(uniquePseudoVarName, psuedoVarRecipient, lpi);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemLiteralResult.setNamespace",
	"Comment": "set the namespace uri of the result element to be created.note that after resolveprefixtables has been called, this willreturn the aliased result namespace, not the original stylesheetnamespace.",
	"Method": "void setNamespace(String ns){\r\n    if (null == ns)\r\n        ns = \"\";\r\n    m_namespace = ns;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.gradle.EmptyProjectIntegrationTest.assertDockerInspect",
	"Comment": "asserts that the test project has the required exposed ports and labels.",
	"Method": "void assertDockerInspect(String imageReference){\r\n    String dockerInspect = new Command(\"docker\", \"inspect\", imageReference).run();\r\n    Assert.assertThat(dockerInspect, CoreMatchers.containsString(\"            \\\"ExposedPorts\\\": {\\n\" + \"                \\\"1000/tcp\\\": {},\\n\" + \"                \\\"2000/udp\\\": {},\\n\" + \"                \\\"2001/udp\\\": {},\\n\" + \"                \\\"2002/udp\\\": {},\\n\" + \"                \\\"2003/udp\\\": {}\"));\r\n    Assert.assertThat(dockerInspect, CoreMatchers.containsString(\"            \\\"Labels\\\": {\\n\" + \"                \\\"key1\\\": \\\"value1\\\",\\n\" + \"                \\\"key2\\\": \\\"value2\\\"\\n\" + \"            }\"));\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XString.concat",
	"Comment": "concatenates the specified string to the end of this string.",
	"Method": "XMLString concat(String str){\r\n    return new XString(str().concat(str));\r\n}"
}, {
	"Path": "org.apache.xml.utils.NodeVector.peepTailSub1",
	"Comment": "return the node one position from the tail without popping.special purpose method for transformerimpl, pushelemtemplateelement.performance critical.",
	"Method": "int peepTailSub1(){\r\n    return m_map[m_firstFree - 2];\r\n}"
}, {
	"Path": "org.apache.xml.serializer.CharInfo.arrayIndex",
	"Comment": "returns the array element holding the bit value for thegiven integer",
	"Method": "int arrayIndex(int i){\r\n    return (i >> SHIFT_PER_WORD);\r\n}"
}, {
	"Path": "hudson.security.csrf.CrumbIssuer.getCrumbRequestField",
	"Comment": "get the name of the request parameter the crumb will be stored in. exposedhere for the remote api.",
	"Method": "String getCrumbRequestField(){\r\n    return getDescriptor().getCrumbRequestField();\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XRTreeFragSelectWrapper.detach",
	"Comment": "detaches the dtmiterator from the set which it iteratedover, releasing any computational resources and placing the iteratorin the invalid state. after detach has been invoked,calls to nextnode or previousnode willraise a runtime exception.in general, detach should only be called once on the object.",
	"Method": "void detach(){\r\n    throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_DETACH_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER, null));\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.cache.DefaultCacheStorageFiles.getTemporaryLayerFile",
	"Comment": "resolves a file to use as a temporary file to write layer contents to.",
	"Method": "Path getTemporaryLayerFile(Path layerDirectory){\r\n    Path temporaryLayerFile = layerDirectory.resolve(TEMPORARY_LAYER_FILE_NAME);\r\n    temporaryLayerFile.toFile().deleteOnExit();\r\n    return temporaryLayerFile;\r\n}"
}, {
	"Path": "redis.clients.jedis.BinaryJedis.sort",
	"Comment": "sort a set or a list and store the result at dstkey.sort the elements contained in the list, set, or sorted set value at key and store the resultat dstkey. by default sorting is numeric with elements being compared as double precisionfloating point numbers. this is the simplest form of sort.",
	"Method": "List<byte[]> sort(byte[] key,List<byte[]> sort,byte[] key,SortingParams sortingParameters,Long sort,byte[] key,SortingParams sortingParameters,byte[] dstkey,Long sort,byte[] key,byte[] dstkey){\r\n    checkIsInMultiOrPipeline();\r\n    client.sort(key, dstkey);\r\n    return client.getIntegerReply();\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.maven.BuildImageMojoIntegrationTest.pullAndRunBuiltImage",
	"Comment": "pulls a built image and attempts to run it. also verifies the container configuration andhistory of the built image.",
	"Method": "String pullAndRunBuiltImage(String imageReference){\r\n    new Command(\"docker\", \"pull\", imageReference).run();\r\n    assertDockerInspectParameters(imageReference);\r\n    return new Command(\"docker\", \"run\", \"--rm\", imageReference).run();\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToXMLSAXHandler.popNamespace",
	"Comment": "undeclare the namespace that is currently pointed to by a givenprefix. inform sax handler if prefix was previously mapped.",
	"Method": "boolean popNamespace(String prefix){\r\n    try {\r\n        if (m_prefixMap.popNamespace(prefix)) {\r\n            m_saxHandler.endPrefixMapping(prefix);\r\n            return true;\r\n        }\r\n    } catch (SAXException e) {\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "hudson.model.queue.BackFiller.newInstance",
	"Comment": "once this feature stabilizes, move it to the heavyjob plugin",
	"Method": "BackFiller newInstance(){\r\n    if (SystemProperties.getBoolean(BackFiller.class.getName()))\r\n        return new BackFiller();\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.Compiler.stepPattern",
	"Comment": "compile a step pattern unit expression, used for both location paths and match patterns.",
	"Method": "StepPattern stepPattern(int opPos,int stepCount,StepPattern ancestorPattern){\r\n    int startOpPos = opPos;\r\n    int stepType = getOp(opPos);\r\n    if (OpCodes.ENDOP == stepType) {\r\n        return null;\r\n    }\r\n    boolean addMagicSelf = true;\r\n    int endStep = getNextOpPos(opPos);\r\n    StepPattern pattern;\r\n    int argLen;\r\n    switch(stepType) {\r\n        case OpCodes.OP_FUNCTION:\r\n            if (DEBUG)\r\n                System.out.println(\"MATCH_FUNCTION: \" + m_currentPattern);\r\n            addMagicSelf = false;\r\n            argLen = getOp(opPos + OpMap.MAPINDEX_LENGTH);\r\n            pattern = new FunctionPattern(compileFunction(opPos), Axis.PARENT, Axis.CHILD);\r\n            break;\r\n        case OpCodes.FROM_ROOT:\r\n            if (DEBUG)\r\n                System.out.println(\"FROM_ROOT, \" + m_currentPattern);\r\n            addMagicSelf = false;\r\n            argLen = getArgLengthOfStep(opPos);\r\n            opPos = getFirstChildPosOfStep(opPos);\r\n            pattern = new StepPattern(DTMFilter.SHOW_DOCUMENT | DTMFilter.SHOW_DOCUMENT_FRAGMENT, Axis.PARENT, Axis.CHILD);\r\n            break;\r\n        case OpCodes.MATCH_ATTRIBUTE:\r\n            if (DEBUG)\r\n                System.out.println(\"MATCH_ATTRIBUTE: \" + getStepLocalName(startOpPos) + \", \" + m_currentPattern);\r\n            argLen = getArgLengthOfStep(opPos);\r\n            opPos = getFirstChildPosOfStep(opPos);\r\n            pattern = new StepPattern(DTMFilter.SHOW_ATTRIBUTE, getStepNS(startOpPos), getStepLocalName(startOpPos), Axis.PARENT, Axis.ATTRIBUTE);\r\n            break;\r\n        case OpCodes.MATCH_ANY_ANCESTOR:\r\n            if (DEBUG)\r\n                System.out.println(\"MATCH_ANY_ANCESTOR: \" + getStepLocalName(startOpPos) + \", \" + m_currentPattern);\r\n            argLen = getArgLengthOfStep(opPos);\r\n            opPos = getFirstChildPosOfStep(opPos);\r\n            int what = getWhatToShow(startOpPos);\r\n            if (0x00000500 == what)\r\n                addMagicSelf = false;\r\n            pattern = new StepPattern(getWhatToShow(startOpPos), getStepNS(startOpPos), getStepLocalName(startOpPos), Axis.ANCESTOR, Axis.CHILD);\r\n            break;\r\n        case OpCodes.MATCH_IMMEDIATE_ANCESTOR:\r\n            if (DEBUG)\r\n                System.out.println(\"MATCH_IMMEDIATE_ANCESTOR: \" + getStepLocalName(startOpPos) + \", \" + m_currentPattern);\r\n            argLen = getArgLengthOfStep(opPos);\r\n            opPos = getFirstChildPosOfStep(opPos);\r\n            pattern = new StepPattern(getWhatToShow(startOpPos), getStepNS(startOpPos), getStepLocalName(startOpPos), Axis.PARENT, Axis.CHILD);\r\n            break;\r\n        default:\r\n            error(XPATHErrorResources.ER_UNKNOWN_MATCH_OPERATION, null);\r\n            return null;\r\n    }\r\n    pattern.setPredicates(getCompiledPredicates(opPos + argLen));\r\n    if (null == ancestorPattern) {\r\n    } else {\r\n        pattern.setRelativePathPattern(ancestorPattern);\r\n    }\r\n    StepPattern relativePathPattern = stepPattern(endStep, stepCount + 1, pattern);\r\n    return (null != relativePathPattern) ? relativePathPattern : pattern;\r\n}"
}, {
	"Path": "hudson.model.Fingerprint.isAlive",
	"Comment": "returns true if any of the builds recorded in this fingerprintis still retained.this is used to find out old fingerprint records that can be removedwithout losing too much information.",
	"Method": "boolean isAlive(boolean isAlive){\r\n    if (original != null && original.isAlive())\r\n        return true;\r\n    for (Entry<String, RangeSet> e : usages.entrySet()) {\r\n        Job j = Jenkins.getInstance().getItemByFullName(e.getKey(), Job.class);\r\n        if (j == null)\r\n            continue;\r\n        Run firstBuild = j.getFirstBuild();\r\n        if (firstBuild == null)\r\n            continue;\r\n        int oldest = firstBuild.getNumber();\r\n        if (!e.getValue().isSmallerThan(oldest))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "hudson.bugs.LoginRedirectTest.testRedirect2",
	"Comment": "verifies that hudson is sending 403 first. this is important for machine agents.",
	"Method": "void testRedirect2(){\r\n    new WebClient().assertFails(\"/\", HttpURLConnection.HTTP_FORBIDDEN);\r\n}"
}, {
	"Path": "hudson.ClassicPluginStrategy.createClassLoader",
	"Comment": "creates the classloader that can load all the specified jar files and delegate to the given parent.",
	"Method": "ClassLoader createClassLoader(List<File> paths,ClassLoader parent,ClassLoader createClassLoader,List<File> paths,ClassLoader parent,Attributes atts){\r\n    if (atts != null) {\r\n        String usePluginFirstClassLoader = atts.getValue(\"PluginFirstClassLoader\");\r\n        if (Boolean.valueOf(usePluginFirstClassLoader)) {\r\n            PluginFirstClassLoader classLoader = new PluginFirstClassLoader();\r\n            classLoader.setParentFirst(false);\r\n            classLoader.setParent(parent);\r\n            classLoader.addPathFiles(paths);\r\n            return classLoader;\r\n        }\r\n    }\r\n    AntClassLoader2 classLoader = new AntClassLoader2(parent);\r\n    classLoader.addPathFiles(paths);\r\n    return classLoader;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.Function2Args.reportWrongNumberArgs",
	"Comment": "constructs and throws a wrongnumberargexception with the appropriatemessage for this function object.",
	"Method": "void reportWrongNumberArgs(){\r\n    throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(\"two\", null));\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.log",
	"Comment": "logs a message through the project object if one has been provided.",
	"Method": "void log(String message,int priority){\r\n    if (project != null) {\r\n        project.log(message, priority);\r\n    }\r\n}"
}, {
	"Path": "hudson.model.AbstractProject.getAssignedLabelString",
	"Comment": "gets the textual representation of the assigned label as it was entered by the user.",
	"Method": "String getAssignedLabelString(){\r\n    if (canRoam || assignedNode == null)\r\n        return null;\r\n    try {\r\n        LabelExpression.parseExpression(assignedNode);\r\n        return assignedNode;\r\n    } catch (ANTLRException e) {\r\n        return LabelAtom.escape(assignedNode);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XString.equalsIgnoreCase",
	"Comment": "compares this string to another string,ignoring case considerations.two strings are considered equalignoring case if they are of the same length, and correspondingcharacters in the two strings are equal ignoring case.",
	"Method": "boolean equalsIgnoreCase(String anotherString){\r\n    return str().equalsIgnoreCase(anotherString);\r\n}"
}, {
	"Path": "org.apache.xpath.Expression.exprSetParent",
	"Comment": "this pair of methods are used to inform the node of itsparent.",
	"Method": "void exprSetParent(ExpressionNode n){\r\n    assertion(n != this, \"Can not parent an expression to itself!\");\r\n    m_parent = n;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.getNodeValue",
	"Comment": "given a node handle, return its node value. this is mostlyas defined by the dom, but may ignore some conveniences.",
	"Method": "String getNodeValue(int nodeHandle){\r\n    nodes.readSlot(nodeHandle, gotslot);\r\n    int nodetype = gotslot[0] & 0xFF;\r\n    String value = null;\r\n    switch(nodetype) {\r\n        case ATTRIBUTE_NODE:\r\n            nodes.readSlot(nodeHandle + 1, gotslot);\r\n        case TEXT_NODE:\r\n        case COMMENT_NODE:\r\n        case CDATA_SECTION_NODE:\r\n            value = m_char.getString(gotslot[2], gotslot[3]);\r\n            break;\r\n        case PROCESSING_INSTRUCTION_NODE:\r\n        case ELEMENT_NODE:\r\n        case ENTITY_REFERENCE_NODE:\r\n        default:\r\n            break;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.getNamespaceForPrefix",
	"Comment": "given a namespace, get the corrisponding prefix from the currentnamespace support context.",
	"Method": "String getNamespaceForPrefix(String prefix,String getNamespaceForPrefix,String prefix,org.w3c.dom.Node context){\r\n    assertion(true, \"can't process a context node in StylesheetHandler!\");\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToXMLStream.pushNamespace",
	"Comment": "from xsltcdeclare a prefix to point to a namespace uri. inform sax handlerif this is a new prefix mapping.",
	"Method": "boolean pushNamespace(String prefix,String uri){\r\n    try {\r\n        if (m_prefixMap.pushNamespace(prefix, uri, m_elemContext.m_currentElemDepth)) {\r\n            startPrefixMapping(prefix, uri);\r\n            return true;\r\n        }\r\n    } catch (SAXException e) {\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.HasPositionalPredChecker.check",
	"Comment": "process the locpathiterator to see if it contains variables \tor functions that may make it context dependent.",
	"Method": "boolean check(LocPathIterator path){\r\n    HasPositionalPredChecker hppc = new HasPositionalPredChecker();\r\n    path.callVisitors(null, hppc);\r\n    return hppc.m_hasPositionalPred;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.indexOf",
	"Comment": "searches for the first occurence of the given argument,beginning the search at index, and testing for equalityusing the equals method.",
	"Method": "int indexOf(int elem,int index,int indexOf,int elem){\r\n    runTo(-1);\r\n    return super.indexOf(elem);\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerIdentityImpl.skippedEntity",
	"Comment": "receive notification of a skipped entity.by default, do nothing.application writers may override thismethod in a subclass to take specific actions for eachprocessing instruction, such as setting status variables orinvoking other methods.",
	"Method": "void skippedEntity(String name){\r\n    flushStartDoc();\r\n    m_resultContentHandler.skippedEntity(name);\r\n}"
}, {
	"Path": "hudson.model.AbstractProject.getDelay",
	"Comment": "computes the delay by taking the default value and the override in the request parameter into the account.",
	"Method": "int getDelay(StaplerRequest req){\r\n    String delay = req.getParameter(\"delay\");\r\n    if (delay == null)\r\n        return getQuietPeriod();\r\n    try {\r\n        if (delay.endsWith(\"sec\"))\r\n            delay = delay.substring(0, delay.length() - 3);\r\n        if (delay.endsWith(\"secs\"))\r\n            delay = delay.substring(0, delay.length() - 4);\r\n        return Integer.parseInt(delay);\r\n    } catch (NumberFormatException e) {\r\n        throw new ServletException(\"Invalid delay parameter value: \" + delay);\r\n    }\r\n}"
}, {
	"Path": "jenkins.model.RunIdMigrator.main",
	"Comment": "reverses the migration, in case you want to revert to the older format.",
	"Method": "void main(String args){\r\n    if (args.length != 1) {\r\n        throw new Exception(\"pass one parameter, $JENKINS_HOME\");\r\n    }\r\n    File root = new File(args[0]);\r\n    File jobs = new File(root, \"jobs\");\r\n    if (!jobs.isDirectory()) {\r\n        throw new FileNotFoundException(\"no such $JENKINS_HOME \" + root);\r\n    }\r\n    new RunIdMigrator().unmigrateJobsDir(jobs);\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprIteratorSimple.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    super.fixupVariables(vars, globalsSize);\r\n    m_expr.fixupVariables(vars, globalsSize);\r\n}"
}, {
	"Path": "hudson.model.Label.matches",
	"Comment": "evaluates whether the current label name is equal to the name parameter.",
	"Method": "boolean matches(VariableResolver<Boolean> resolver,boolean matches,Collection<LabelAtom> labels,boolean matches,Node n,boolean matches,String name){\r\n    return this.name.equals(name);\r\n}"
}, {
	"Path": "jenkins.util.MemoryReductionUtil.preallocatedHashmapCapacity",
	"Comment": "returns the capacity we need to allocate for a hashmap so it will hold all elements without needing to resize.",
	"Method": "int preallocatedHashmapCapacity(int elementsToHold){\r\n    if (elementsToHold <= 0) {\r\n        return 0;\r\n    } else if (elementsToHold < 3) {\r\n        return elementsToHold + 1;\r\n    } else {\r\n        return elementsToHold + elementsToHold / 3;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.pushPair",
	"Comment": "push a pair of nodes into the stack.special purpose method for transformerimpl, pushelemtemplateelement.performance critical.",
	"Method": "void pushPair(Node v1,Node v2){\r\n    if (null == m_map) {\r\n        m_map = new Node[m_blocksize];\r\n        m_mapSize = m_blocksize;\r\n    } else {\r\n        if ((m_firstFree + 2) >= m_mapSize) {\r\n            m_mapSize += m_blocksize;\r\n            Node[] newMap = new Node[m_mapSize];\r\n            System.arraycopy(m_map, 0, newMap, 0, m_firstFree);\r\n            m_map = newMap;\r\n        }\r\n    }\r\n    m_map[m_firstFree] = v1;\r\n    m_map[m_firstFree + 1] = v2;\r\n    m_firstFree += 2;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetRoot.getTemplateListComposed",
	"Comment": "accessor method to retrieve the templatelist associated withthis stylesheetroot.",
	"Method": "TemplateList getTemplateListComposed(){\r\n    return m_templateList;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetRoot.getWhiteSpaceInfo",
	"Comment": "get information about whether or not an element should strip whitespace.",
	"Method": "WhiteSpaceInfo getWhiteSpaceInfo(XPathContext support,int targetElement,DTM dtm){\r\n    if (null != m_whiteSpaceInfoList)\r\n        return (WhiteSpaceInfo) m_whiteSpaceInfoList.getTemplate(support, targetElement, null, false, dtm);\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "org.java_websocket.drafts.Draft_6455.translateSingleFrameCheckPacketSize",
	"Comment": "check if the max packet size is smaller than the real packet size",
	"Method": "void translateSingleFrameCheckPacketSize(int maxpacketsize,int realpacketsize){\r\n    if (maxpacketsize < realpacketsize) {\r\n        log.trace(\"Incomplete frame: maxpacketsize < realpacketsize\");\r\n        throw new IncompleteException(realpacketsize);\r\n    }\r\n}"
}, {
	"Path": "hudson.util.StackedAreaRenderer2.generateToolTip",
	"Comment": "override this method to specify the tool tip text of the given data point.",
	"Method": "String generateToolTip(CategoryDataset dataset,int row,int column){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLStringDefault.equals",
	"Comment": "compares this string to the specified object.the result is true if and only if the argument is notnull and is a string object that representsthe same sequence of characters as this object.",
	"Method": "boolean equals(String obj2,boolean equals,XMLString anObject,boolean equals,Object anObject){\r\n    return m_str.equals(anObject);\r\n}"
}, {
	"Path": "hudson.model.queue.SubTask.getEstimatedDuration",
	"Comment": "estimate of how long will it take to execute this task.measured in milliseconds.",
	"Method": "long getEstimatedDuration(){\r\n    return -1;\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.StepPattern.getPredicates",
	"Comment": "set the list of predicate expressions for this pattern step.",
	"Method": "Expression[] getPredicates(){\r\n    return m_predicates;\r\n}"
}, {
	"Path": "hudson.slaves.JNLPLauncherTest.testLaunch",
	"Comment": "starts a jnlp agent and makes sure it successfully connects to jenkins.",
	"Method": "void testLaunch(){\r\n    Assume.assumeFalse(\"Skipping JNLPLauncherTest.testLaunch because we are running headless\", GraphicsEnvironment.isHeadless());\r\n    Computer c = addTestSlave(false);\r\n    launchJnlpAndVerify(c, buildJnlpArgs(c));\r\n}"
}, {
	"Path": "hudson.ExtensionFinderTest.testInjection",
	"Comment": "extensions are guice components, so it should support injection.",
	"Method": "void testInjection(){\r\n    InjectingExtension i = PageDecorator.all().get(InjectingExtension.class);\r\n    assertNotNull(i.foo);\r\n    assertEquals(\"lion king\", i.value);\r\n}"
}, {
	"Path": "hudson.Util.isOverridden",
	"Comment": "checks if the method defined on the base type with the given argumentsis overridden in the given derived type.",
	"Method": "boolean isOverridden(Class base,Class derived,String methodName,Class types){\r\n    return !getMethod(base, methodName, types).equals(getMethod(derived, methodName, types));\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.getSystemId",
	"Comment": "return the system identifier for the current document event.if the system identifier is a url, the parser must resolve itfully before passing it to the application.",
	"Method": "String getSystemId(){\r\n    Stylesheet sheet = getStylesheet();\r\n    return (sheet == null) ? null : sheet.getHref();\r\n}"
}, {
	"Path": "org.apache.xml.serializer.CharInfo.bit",
	"Comment": "for a given integer in the set it returns the single bitvalue used within a given word that represents whetherthe integer is in the set or not.",
	"Method": "int bit(int i){\r\n    int ret = (1 << (i & LOW_ORDER_BITMASK));\r\n    return ret;\r\n}"
}, {
	"Path": "redis.clients.jedis.Jedis.setbit",
	"Comment": "sets or clears the bit at offset in the string value stored at key",
	"Method": "Boolean setbit(String key,long offset,boolean value,Boolean setbit,String key,long offset,String value){\r\n    checkIsInMultiOrPipeline();\r\n    client.setbit(key, offset, value);\r\n    return client.getIntegerReply() == 1;\r\n}"
}, {
	"Path": "jenkins.model.lazy.AbstractLazyLoadRunMap.updateBaseDir",
	"Comment": "updates base directory location after directory changes.this method should be used on jobs renaming, etc.",
	"Method": "void updateBaseDir(File dir){\r\n    this.dir = dir;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.tar.TarStreamBuilderTest.setUpWithStringsAndTarEntries",
	"Comment": "creates a tarstreambuilder using strings and tararchiveentries.",
	"Method": "void setUpWithStringsAndTarEntries(){\r\n    testTarStreamBuilder.addByteEntry(fileAContents, \"some/path/to/resourceFileA\");\r\n    testTarStreamBuilder.addTarArchiveEntry(new TarArchiveEntry(fileB.toFile(), \"crepecake\"));\r\n    testTarStreamBuilder.addTarArchiveEntry(new TarArchiveEntry(directoryA.toFile(), \"some/path/to\"));\r\n    testTarStreamBuilder.addByteEntry(fileAContents, \"some/really/long/path/that/exceeds/100/characters/abcdefghijklmnopqrstuvwxyz0123456789012345678901234567890\");\r\n}"
}, {
	"Path": "org.apache.xpath.operations.Or.execute",
	"Comment": "or two expressions and return the boolean result. overridesuperclass method for optimization purposes.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    XObject expr1 = m_left.execute(xctxt);\r\n    if (!expr1.bool()) {\r\n        XObject expr2 = m_right.execute(xctxt);\r\n        return expr2.bool() ? XBoolean.S_TRUE : XBoolean.S_FALSE;\r\n    } else\r\n        return XBoolean.S_TRUE;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncSystemProperty.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    String fullName = m_arg0.execute(xctxt).str();\r\n    int indexOfNSSep = fullName.indexOf(':');\r\n    String result = null;\r\n    String propName = \"\";\r\n    Properties xsltInfo = new Properties();\r\n    loadPropertyFile(XSLT_PROPERTIES, xsltInfo);\r\n    if (indexOfNSSep > 0) {\r\n        String prefix = (indexOfNSSep >= 0) ? fullName.substring(0, indexOfNSSep) : \"\";\r\n        String namespace;\r\n        namespace = xctxt.getNamespaceContext().getNamespaceForPrefix(prefix);\r\n        propName = (indexOfNSSep < 0) ? fullName : fullName.substring(indexOfNSSep + 1);\r\n        if (namespace.startsWith(\"http://www.w3.org/XSL/Transform\") || namespace.equals(\"http://www.w3.org/1999/XSL/Transform\")) {\r\n            result = xsltInfo.getProperty(propName);\r\n            if (null == result) {\r\n                warn(// \"XSL Property not supported: \"+fullName);\r\n                xctxt, XPATHErrorResources.WG_PROPERTY_NOT_SUPPORTED, new Object[] { fullName });\r\n                return XString.EMPTYSTRING;\r\n            }\r\n        } else {\r\n            warn(xctxt, XPATHErrorResources.WG_DONT_DO_ANYTHING_WITH_NS, new Object[] { namespace, fullName });\r\n            try {\r\n                if (!xctxt.isSecureProcessing()) {\r\n                    result = System.getProperty(propName);\r\n                } else {\r\n                    warn(// \"SecurityException when trying to access XSL system property: \"+fullName);\r\n                    xctxt, XPATHErrorResources.WG_SECURITY_EXCEPTION, new Object[] { fullName });\r\n                }\r\n                if (null == result) {\r\n                    return XString.EMPTYSTRING;\r\n                }\r\n            } catch (SecurityException se) {\r\n                warn(xctxt, XPATHErrorResources.WG_SECURITY_EXCEPTION, new Object[] { fullName });\r\n                return XString.EMPTYSTRING;\r\n            }\r\n        }\r\n    } else {\r\n        try {\r\n            if (!xctxt.isSecureProcessing()) {\r\n                result = System.getProperty(fullName);\r\n            } else {\r\n                warn(// \"SecurityException when trying to access XSL system property: \"+fullName);\r\n                xctxt, XPATHErrorResources.WG_SECURITY_EXCEPTION, new Object[] { fullName });\r\n            }\r\n            if (null == result) {\r\n                return XString.EMPTYSTRING;\r\n            }\r\n        } catch (SecurityException se) {\r\n            warn(xctxt, XPATHErrorResources.WG_SECURITY_EXCEPTION, new Object[] { fullName });\r\n            return XString.EMPTYSTRING;\r\n        }\r\n    }\r\n    if (propName.equals(\"version\") && result.length() > 0) {\r\n        try {\r\n            return new XString(\"1.0\");\r\n        } catch (Exception ex) {\r\n            return new XString(result);\r\n        }\r\n    } else\r\n        return new XString(result);\r\n}"
}, {
	"Path": "com.iluwatar.tls.DateFormatCallableTest.setup",
	"Comment": "run callable and prepare results for usage in the test methods",
	"Method": "void setup(){\r\n    DateFormatCallable callableDf = new DateFormatCallable(\"dd/MM/yyyy\", \"15/12/2015\");\r\n    ExecutorService executor = Executors.newCachedThreadPool();\r\n    Future<Result> futureResult = executor.submit(callableDf);\r\n    try {\r\n        result = futureResult.get();\r\n        createdDateValues = convertDatesToString(result);\r\n    } catch (Exception e) {\r\n        fail(\"Setup failed: \" + e);\r\n    }\r\n    executor.shutdown();\r\n}"
}, {
	"Path": "hudson.model.AbstractBuild.getDownstreamBuilds",
	"Comment": "gets the downstream builds of this build, which are the builds of thedownstream projects that use artifacts of this build.",
	"Method": "Iterable<AbstractBuild<?, ?>> getDownstreamBuilds(AbstractProject<?, ?> that,Map<AbstractProject, RangeSet> getDownstreamBuilds){\r\n    Map<AbstractProject, RangeSet> r = new HashMap<AbstractProject, RangeSet>();\r\n    for (AbstractProject p : getParent().getDownstreamProjects()) {\r\n        if (p.isFingerprintConfigured())\r\n            r.put(p, getDownstreamRelationship(p));\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "com.iluwatar.retry.Retry.errors",
	"Comment": "the errors encountered while retrying, in the encounter order.",
	"Method": "List<Exception> errors(){\r\n    return Collections.unmodifiableList(this.errors);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.TransformerFactoryImpl.newTransformer",
	"Comment": "create a new transformer object that performs a copyof the source to the result.",
	"Method": "Transformer newTransformer(Source source,Transformer newTransformer){\r\n    return new TransformerIdentityImpl(m_isSecureProcessing);\r\n}"
}, {
	"Path": "hudson.console.ConsoleLogFilter.decorateLogger",
	"Comment": "called on the start of each build, giving extensions a chance to interceptthe data that is written to the log.",
	"Method": "OutputStream decorateLogger(AbstractBuild build,OutputStream logger,OutputStream decorateLogger,Run build,OutputStream logger,OutputStream decorateLogger,Computer computer,OutputStream logger){\r\n    return logger;\r\n}"
}, {
	"Path": "hudson.model.queue.WorkUnitContext.abort",
	"Comment": "when one of the work unit is aborted, call this method to abort all the other work units.",
	"Method": "void abort(Throwable cause){\r\n    if (cause == null)\r\n        throw new IllegalArgumentException();\r\n    if (aborted != null)\r\n        return;\r\n    aborted = cause;\r\n    startLatch.abort(cause);\r\n    endLatch.abort(cause);\r\n    Thread c = Thread.currentThread();\r\n    for (WorkUnit wu : workUnits) {\r\n        Executor e = wu.getExecutor();\r\n        if (e != null && e != c)\r\n            e.interrupt();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemVariable.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    if (null == m_selectPattern && sroot.getOptimizer()) {\r\n        XPath newSelect = rewriteChildToExpression(this);\r\n        if (null != newSelect)\r\n            m_selectPattern = newSelect;\r\n    }\r\n    StylesheetRoot.ComposeState cstate = sroot.getComposeState();\r\n    java.util.Vector vnames = cstate.getVariableNames();\r\n    if (null != m_selectPattern)\r\n        m_selectPattern.fixupVariables(vnames, cstate.getGlobalsSize());\r\n    if (!(m_parentNode instanceof Stylesheet) && m_qname != null) {\r\n        m_index = cstate.addVariableName(m_qname) - cstate.getGlobalsSize();\r\n    } else if (m_parentNode instanceof Stylesheet) {\r\n        cstate.resetStackFrameSize();\r\n    }\r\n    super.compose(sroot);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.TemplateList.getHead",
	"Comment": "get the head of the most likely list of associations to check, based on the name and type of the targetnode argument.",
	"Method": "TemplateSubPatternAssociation getHead(XPathContext xctxt,int targetNode,DTM dtm,TemplateSubPatternAssociation getHead,String key){\r\n    return (TemplateSubPatternAssociation) m_patternTable.get(key);\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FunctionDef1Arg.checkNumberArgs",
	"Comment": "check that the number of arguments passed to this function is correct.",
	"Method": "void checkNumberArgs(int argNum){\r\n    if (argNum > 1)\r\n        reportWrongNumberArgs();\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XString.startsWith",
	"Comment": "tests if this string starts with the specified prefix beginninga specified index.",
	"Method": "boolean startsWith(String prefix,int toffset,boolean startsWith,String prefix,boolean startsWith,XMLString prefix,int toffset,boolean startsWith,XMLString prefix){\r\n    return startsWith(prefix, 0);\r\n}"
}, {
	"Path": "hudson.slaves.EnvironmentVariableNodePropertyTest.executeBuild",
	"Comment": "launches project on this node, waits for the result, and returns the environment that is used",
	"Method": "Map<String, String> executeBuild(Node node){\r\n    CaptureEnvironmentBuilder builder = new CaptureEnvironmentBuilder();\r\n    project.getBuildersList().add(builder);\r\n    project.setAssignedLabel(node.getSelfLabel());\r\n    FreeStyleBuild build = project.scheduleBuild2(0).get();\r\n    System.out.println(build.getLog());\r\n    assertEquals(Result.SUCCESS, build.getResult());\r\n    return builder.getEnvVars();\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FunctionOneArg.reportWrongNumberArgs",
	"Comment": "constructs and throws a wrongnumberargexception with the appropriatemessage for this function object.",
	"Method": "void reportWrongNumberArgs(){\r\n    throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(\"one\", null));\r\n}"
}, {
	"Path": "jenkins.model.lazy.AbstractLazyLoadRunMap.copy",
	"Comment": "creates a duplicate for the cow data structure in preparation for mutation.",
	"Method": "Index copy(){\r\n    return new Index(index);\r\n}"
}, {
	"Path": "org.apache.xml.utils.NodeVector.setTailSub1",
	"Comment": "set the given node one position from the tail.special purpose method for transformerimpl, pushelemtemplateelement.performance critical.",
	"Method": "void setTailSub1(int n){\r\n    m_map[m_firstFree - 2] = n;\r\n}"
}, {
	"Path": "hudson.util.ArgumentListBuilder.add",
	"Comment": "optionally hide this part of the command line from being printed to the log.",
	"Method": "ArgumentListBuilder add(Object a,ArgumentListBuilder add,Object a,boolean mask,ArgumentListBuilder add,File f,ArgumentListBuilder add,String a,ArgumentListBuilder add,String a,boolean mask,ArgumentListBuilder add,String args,ArgumentListBuilder add,Iterable<String> args){\r\n    for (String arg : args) {\r\n        add(arg);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.java_websocket.WebSocketImpl.closeConnectionDueToWrongHandshake",
	"Comment": "close the connection if the received handshake was not correct",
	"Method": "void closeConnectionDueToWrongHandshake(InvalidDataException exception){\r\n    write(generateHttpResponseDueToError(404));\r\n    flushAndClose(exception.getCloseCode(), exception.getMessage(), false);\r\n}"
}, {
	"Path": "hudson.tasks.Builder.all",
	"Comment": "for backward compatibility, the signature is not buildstepdescriptor",
	"Method": "DescriptorExtensionList<Builder, Descriptor<Builder>> all(){\r\n    return Jenkins.getInstance().<Builder, Descriptor<Builder>>getDescriptorList(Builder.class);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemApplyTemplates.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n}"
}, {
	"Path": "hudson.model.Computer.getLogDir",
	"Comment": "directory where rotated agent logs are stored.the method also creates a log directory if required.",
	"Method": "File getLogDir(){\r\n    File dir = new File(Jenkins.getInstance().getRootDir(), \"logs/slaves/\" + nodeName);\r\n    if (!dir.exists() && !dir.mkdirs()) {\r\n        LOGGER.severe(\"Failed to create agent log directory \" + dir.getAbsolutePath());\r\n    }\r\n    return dir;\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.findClass",
	"Comment": "searches for and load a class on the classpath of this class loader.",
	"Method": "Class findClass(String name){\r\n    log(\"Finding class \" + name, Project.MSG_DEBUG);\r\n    return findClassInComponents(name);\r\n}"
}, {
	"Path": "hudson.model.ExecutorTest.abortCause",
	"Comment": "makes sure that the cause of interruption is properly recorded.",
	"Method": "void abortCause(){\r\n    FreeStyleProject p = j.createFreeStyleProject();\r\n    Future<FreeStyleBuild> r = startBlockingBuild(p);\r\n    User johnny = User.get(\"Johnny\");\r\n    // test the merge semantics\r\n    p.getLastBuild().getExecutor().interrupt(Result.FAILURE, new UserInterruption(johnny), new UserInterruption(johnny));\r\n    FreeStyleBuild b = r.get();\r\n    assertEquals(b.getResult(), Result.FAILURE);\r\n    InterruptedBuildAction iba = b.getAction(InterruptedBuildAction.class);\r\n    assertEquals(1, iba.getCauses().size());\r\n    assertEquals(((UserInterruption) iba.getCauses().get(0)).getUser(), johnny);\r\n    assertTrue(b.getLog().contains(johnny.getId()));\r\n}"
}, {
	"Path": "com.sun.jna.platform.RasterRangesUtils.outputOccupiedRanges",
	"Comment": "outputs ranges of occupied pixels.in a raster that has an alpha layer, a pixel is occupied if its alpha value is not null.in a raster without alpha layer, a pixel is occupied if it is not completely black.",
	"Method": "boolean outputOccupiedRanges(Raster raster,RangesOutput out,boolean outputOccupiedRanges,int[] pixels,int w,int h,int occupationMask,RangesOutput out){\r\n    Set<Rectangle> rects = new HashSet<Rectangle>();\r\n    Set<Rectangle> prevLine = Collections.<Rectangle>emptySet();\r\n    for (int row = 0; row < h; row++) {\r\n        Set<Rectangle> curLine = new TreeSet<Rectangle>(COMPARATOR);\r\n        int idxOffset = row * w;\r\n        int startCol = -1;\r\n        for (int col = 0; col < w; col++) {\r\n            if ((pixels[idxOffset + col] & occupationMask) != 0) {\r\n                if (startCol < 0) {\r\n                    startCol = col;\r\n                }\r\n            } else {\r\n                if (startCol >= 0) {\r\n                    curLine.add(new Rectangle(startCol, row, col - startCol, 1));\r\n                    startCol = -1;\r\n                }\r\n            }\r\n        }\r\n        if (startCol >= 0) {\r\n            curLine.add(new Rectangle(startCol, row, w - startCol, 1));\r\n        }\r\n        Set<Rectangle> unmerged = mergeRects(prevLine, curLine);\r\n        rects.addAll(unmerged);\r\n        prevLine = curLine;\r\n    }\r\n    rects.addAll(prevLine);\r\n    for (Iterator<Rectangle> i = rects.iterator(); i.hasNext(); ) {\r\n        Rectangle r = i.next();\r\n        if (!out.outputRange(r.x, r.y, r.width, r.height)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "hudson.Plugin.save",
	"Comment": "saves serializable fields of this instance to the persisted storage.",
	"Method": "void save(){\r\n    if (BulkChange.contains(this))\r\n        return;\r\n    XmlFile config = getConfigXml();\r\n    config.write(this);\r\n    SaveableListener.fireOnChange(this, config);\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncFloor.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    return new XNumber(java.lang.Math.floor(m_arg0.execute(xctxt).num()));\r\n}"
}, {
	"Path": "hudson.security.HudsonPrivateSecurityRealmTest.dataCompatibilityWith1_282",
	"Comment": "tests the data compatibility with hudson before 1.283.starting 1.283, passwords are now stored hashed.",
	"Method": "void dataCompatibilityWith1_282(){\r\n    WebClient wc = j.createWebClient().login(\"alice\", \"alice\");\r\n    try {\r\n        j.createWebClient().login(\"bob\", \"bob\");\r\n        fail();\r\n    } catch (FailingHttpStatusCodeException e) {\r\n        assertEquals(401, e.getStatusCode());\r\n    }\r\n    HtmlPage p = wc.goTo(\"user/alice/configure\");\r\n    j.submit(p.getFormByName(\"config\"));\r\n    j.createWebClient().login(\"alice\", \"alice\");\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.pushProcessor",
	"Comment": "push the current xsltelementprocessor onto the top of the stack.",
	"Method": "void pushProcessor(XSLTElementProcessor processor){\r\n    m_processors.push(processor);\r\n}"
}, {
	"Path": "com.iluwatar.factory.method.FactoryMethodTest.verifyWeapon",
	"Comment": "this method asserts that the weapon object that is passed is an instance of the clazz and theweapon is of type expectedweapontype.",
	"Method": "void verifyWeapon(Weapon weapon,WeaponType expectedWeaponType,Class<?> clazz){\r\n    assertTrue(clazz.isInstance(weapon), \"Weapon must be an object of: \" + clazz.getName());\r\n    assertEquals(expectedWeaponType, weapon.getWeaponType(), \"Weapon must be of weaponType: \" + expectedWeaponType);\r\n}"
}, {
	"Path": "redis.clients.jedis.util.Pool.getMeanBorrowWaitTimeMillis",
	"Comment": "returns the mean waiting time spent by threads to obtain a resource fromthis pool.",
	"Method": "long getMeanBorrowWaitTimeMillis(){\r\n    if (poolInactive()) {\r\n        return -1;\r\n    }\r\n    return this.internalPool.getMeanBorrowWaitTimeMillis();\r\n}"
}, {
	"Path": "org.apache.xpath.axes.WalkingIteratorSorted.isDocOrdered",
	"Comment": "returns true if all the nodes in the iteration well be returned in document order.",
	"Method": "boolean isDocOrdered(){\r\n    return m_inNaturalOrderStatic;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemExtensionDecl.getElementCount",
	"Comment": "return the count of elements defined for this extension element",
	"Method": "int getElementCount(){\r\n    return (null != m_elements) ? m_elements.size() : 0;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.DTMException.getLocator",
	"Comment": "method getlocator retrieves an instance of a sourcelocatorobject that specifies where an error occured.",
	"Method": "SourceLocator getLocator(){\r\n    return locator;\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.StepPattern.toString",
	"Comment": "get the string represenentation of this step for diagnostic purposes.",
	"Method": "String toString(){\r\n    StringBuffer buf = new StringBuffer();\r\n    for (StepPattern pat = this; pat != null; pat = pat.m_relativePathPattern) {\r\n        if (pat != this)\r\n            buf.append(\"/\");\r\n        buf.append(Axis.getNames(pat.m_axis));\r\n        buf.append(\"::\");\r\n        if (0x000005000 == pat.m_whatToShow) {\r\n            buf.append(\"doc()\");\r\n        } else if (DTMFilter.SHOW_BYFUNCTION == pat.m_whatToShow) {\r\n            buf.append(\"function()\");\r\n        } else if (DTMFilter.SHOW_ALL == pat.m_whatToShow) {\r\n            buf.append(\"node()\");\r\n        } else if (DTMFilter.SHOW_TEXT == pat.m_whatToShow) {\r\n            buf.append(\"text()\");\r\n        } else if (DTMFilter.SHOW_PROCESSING_INSTRUCTION == pat.m_whatToShow) {\r\n            buf.append(\"processing-instruction(\");\r\n            if (null != pat.m_name) {\r\n                buf.append(pat.m_name);\r\n            }\r\n            buf.append(\")\");\r\n        } else if (DTMFilter.SHOW_COMMENT == pat.m_whatToShow) {\r\n            buf.append(\"comment()\");\r\n        } else if (null != pat.m_name) {\r\n            if (DTMFilter.SHOW_ATTRIBUTE == pat.m_whatToShow) {\r\n                buf.append(\"@\");\r\n            }\r\n            if (null != pat.m_namespace) {\r\n                buf.append(\"{\");\r\n                buf.append(pat.m_namespace);\r\n                buf.append(\"}\");\r\n            }\r\n            buf.append(pat.m_name);\r\n        } else if (DTMFilter.SHOW_ATTRIBUTE == pat.m_whatToShow) {\r\n            buf.append(\"@\");\r\n        } else if ((DTMFilter.SHOW_DOCUMENT | DTMFilter.SHOW_DOCUMENT_FRAGMENT) == pat.m_whatToShow) {\r\n            buf.append(\"doc-root()\");\r\n        } else {\r\n            buf.append(\"?\" + Integer.toHexString(pat.m_whatToShow));\r\n        }\r\n        if (null != pat.m_predicates) {\r\n            for (int i = 0; i < pat.m_predicates.length; i++) {\r\n                buf.append(\"[\");\r\n                buf.append(pat.m_predicates[i]);\r\n                buf.append(\"]\");\r\n            }\r\n        }\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "hudson.tasks.ArtifactArchiver.setFingerprint",
	"Comment": "whether to fingerprint the artifacts after we archive them.",
	"Method": "void setFingerprint(boolean fingerprint){\r\n    this.fingerprint = fingerprint;\r\n}"
}, {
	"Path": "hudson.ClassicPluginStrategy.getBaseClassLoader",
	"Comment": "computes the classloader that takes the class masking into account.this mechanism allows plugins to have their own versions for libraries that core bundles.",
	"Method": "ClassLoader getBaseClassLoader(Attributes atts,ClassLoader base){\r\n    String masked = atts.getValue(\"Mask-Classes\");\r\n    if (masked != null)\r\n        base = new MaskingClassLoader(base, masked.trim().split(\"[ \\t\\r\\n]+\"));\r\n    return base;\r\n}"
}, {
	"Path": "hudson.model.AbstractProject.newBuild",
	"Comment": "creates a new build of this project for immediate execution.",
	"Method": "R newBuild(){\r\n    return buildMixIn.newBuild();\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XStringForChars.object",
	"Comment": "since this object is incomplete without the length and the offset, we have to convert to a string when this function is called.",
	"Method": "Object object(){\r\n    return str();\r\n}"
}, {
	"Path": "hudson.model.Job.supportsLogRotator",
	"Comment": "true if this instance supports log rotation configuration.",
	"Method": "boolean supportsLogRotator(){\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xpath.Expression.isStableNumber",
	"Comment": "tell if this expression returns a stable number that will not change during iterations within the expression.this is used to determine if a proximity position predicate can indicate that no more searching has to occur.",
	"Method": "boolean isStableNumber(){\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.AVT.setRawName",
	"Comment": "get the raw name of the attribute, with the prefix unprocessed.",
	"Method": "void setRawName(String rawName){\r\n    m_rawName = rawName;\r\n}"
}, {
	"Path": "hudson.util.MultipartFormDataParser.cleanUp",
	"Comment": "if any file is created on the disk, delete them all.even if this method is not called, the resource will be still cleaned up later by gc.",
	"Method": "void cleanUp(){\r\n    for (FileItem item : byName.values()) item.delete();\r\n}"
}, {
	"Path": "jenkins.model.FingerprintFacet.getTimestamp",
	"Comment": "gets the timestamp associated with this facet.the rendering of facets are sorted by their chronological order.",
	"Method": "long getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "hudson.util.FormFieldValidatorTest.negative",
	"Comment": "make sure that the validation methods are really called by testing a negative case.",
	"Method": "void negative(){\r\n    DescriptorImpl d = new DescriptorImpl();\r\n    Publisher.all().add(d);\r\n    try {\r\n        FreeStyleProject p = j.createFreeStyleProject();\r\n        p.getPublishersList().add(new BrokenFormValidatorBuilder());\r\n        JenkinsRule.WebClient webclient = j.createWebClient();\r\n        WebResponseListener.StatusListener statusListener = new WebResponseListener.StatusListener(500);\r\n        webclient.addWebResponseListener(statusListener);\r\n        webclient.getPage(p, \"configure\");\r\n        statusListener.assertHasResponses();\r\n        String contentAsString = statusListener.getResponses().get(0).getContentAsString();\r\n        Assert.assertTrue(contentAsString.contains(\"doCheckXyz is broken\"));\r\n    } finally {\r\n        Publisher.all().remove(d);\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.RewriterTest.testStaticArrayInitializerRewrite",
	"Comment": "verify that static array initializers are rewritten as method calls.",
	"Method": "void testStaticArrayInitializerRewrite(){\r\n    String translation = translateSourceFile(\"public class Test { static int[] a = { 1, 2, 3 }; static char b[] = { '4', '5' }; }\", \"Test\", \"Test.m\");\r\n    assertTranslatedLines(translation, \"+ (void)initialize {\", \"if (self == [Test class]) {\", \"JreStrongAssignAndConsume(&Test_a, \" + \"[IOSIntArray newArrayWithInts:(jint[]){ 1, 2, 3 } count:3]);\", \"JreStrongAssignAndConsume(&Test_b, \" + \"[IOSCharArray newArrayWithChars:(jchar[]){ '4', '5' } count:2]);\");\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.pushSAXLocatorNull",
	"Comment": "push a slot on the locations stack so that setsaxlocator can be repeatedly called.",
	"Method": "void pushSAXLocatorNull(){\r\n    m_saxLocations.push(null);\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.gradle.JibRunHelper.pullAndRunBuiltImage",
	"Comment": "pulls a built image and attempts to run it. also verifies the container configuration andhistory of the built image.",
	"Method": "String pullAndRunBuiltImage(String imageReference,String extraRunArguments){\r\n    new Command(\"docker\", \"pull\", imageReference).run();\r\n    String history = new Command(\"docker\", \"history\", imageReference).run();\r\n    Assert.assertThat(history, CoreMatchers.containsString(\"jib-gradle-plugin\"));\r\n    List<String> command = new ArrayList(Arrays.asList(\"docker\", \"run\", \"--rm\"));\r\n    command.addAll(Arrays.asList(extraRunArguments));\r\n    command.add(imageReference);\r\n    return new Command(command).run();\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.notationDecl",
	"Comment": "if this method is called, the serializer is used as adtdhandler, which changes behavior how the serializer handles document entities.",
	"Method": "void notationDecl(String name,String pubID,String sysID){\r\n    try {\r\n        DTDprolog();\r\n        m_writer.write(\"<!NOTATION \");\r\n        m_writer.write(name);\r\n        if (pubID != null) {\r\n            m_writer.write(\" PUBLIC \\\"\");\r\n            m_writer.write(pubID);\r\n        } else {\r\n            m_writer.write(\" SYSTEM \\\"\");\r\n            m_writer.write(sysID);\r\n        }\r\n        m_writer.write(\"\\\" >\");\r\n        m_writer.write(m_lineSep, 0, m_lineSepLen);\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "hudson.util.ProcessTreeKiller.createCookie",
	"Comment": "creates a magic cookie that can be used as the model environment variablewhen we later kill the processes.",
	"Method": "EnvVars createCookie(){\r\n    return EnvVars.createCookie();\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.pushExpressionState",
	"Comment": "push the current context node, expression node, and prefix resolver.",
	"Method": "void pushExpressionState(int cn,int en,PrefixResolver nc){\r\n    m_currentNodes.push(cn);\r\n    m_currentExpressionNodes.push(cn);\r\n    m_prefixResolvers.push(nc);\r\n}"
}, {
	"Path": "com.iluwatar.trampoline.TrampolineApp.main",
	"Comment": "main program for showing pattern. it does loop with factorial function.",
	"Method": "void main(String[] args){\r\n    log.info(\"start pattern\");\r\n    Integer result = loop(10, 1).result();\r\n    log.info(\"result {}\", result);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.DOM3TreeWalker.recordLocalNSDecl",
	"Comment": "records local namespace declarations, to be used for normalization later",
	"Method": "void recordLocalNSDecl(Node node){\r\n    NamedNodeMap atts = ((Element) node).getAttributes();\r\n    int length = atts.getLength();\r\n    for (int i = 0; i < length; i++) {\r\n        Node attr = atts.item(i);\r\n        String localName = attr.getLocalName();\r\n        String attrPrefix = attr.getPrefix();\r\n        String attrValue = attr.getNodeValue();\r\n        String attrNS = attr.getNamespaceURI();\r\n        localName = localName == null || XMLNS_PREFIX.equals(localName) ? \"\" : localName;\r\n        attrPrefix = attrPrefix == null ? \"\" : attrPrefix;\r\n        attrValue = attrValue == null ? \"\" : attrValue;\r\n        attrNS = attrNS == null ? \"\" : attrNS;\r\n        if (XMLNS_URI.equals(attrNS)) {\r\n            if (XMLNS_URI.equals(attrValue)) {\r\n                String msg = Utils.messages.createMessage(MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND, new Object[] { attrPrefix, XMLNS_URI });\r\n                if (fErrorHandler != null) {\r\n                    fErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_ERROR, msg, MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND, null, null, null));\r\n                }\r\n            } else {\r\n                if (XMLNS_PREFIX.equals(attrPrefix)) {\r\n                    if (attrValue.length() != 0) {\r\n                        fNSBinder.declarePrefix(localName, attrValue);\r\n                    } else {\r\n                    }\r\n                } else {\r\n                    fNSBinder.declarePrefix(\"\", attrValue);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.PackageInfoLookupTest.testParametersAreNonnullByDefaultNotSet",
	"Comment": "verify that parametersarenonnullbydefault is not set on packages by default.",
	"Method": "void testParametersAreNonnullByDefaultNotSet(){\r\n    CompilationUnit unit = translateType(\"foo.A\", \"package foo; public class A {}\");\r\n    PackageInfoLookup packageInfoLookup = unit.getEnv().options().getPackageInfoLookup();\r\n    assertFalse(packageInfoLookup.hasParametersAreNonnullByDefault(\"foo\"));\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.plugins.common.BuildStepsRunner.forBuildTar",
	"Comment": "creates a runner to build an image tarball. creates a directory for the cache, if needed.",
	"Method": "BuildStepsRunner forBuildTar(Path outputPath){\r\n    return new BuildStepsRunner(String.format(STARTUP_MESSAGE_FORMAT_FOR_TARBALL, outputPath.toString()), String.format(SUCCESS_MESSAGE_FORMAT_FOR_TARBALL, outputPath.toString()));\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.UnionPattern.execute",
	"Comment": "test a node to see if it matches any of the patterns in the union.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    XObject bestScore = null;\r\n    int n = m_patterns.length;\r\n    for (int i = 0; i < n; i++) {\r\n        XObject score = m_patterns[i].execute(xctxt);\r\n        if (score != NodeTest.SCORE_NONE) {\r\n            if (null == bestScore)\r\n                bestScore = score;\r\n            else if (score.num() > bestScore.num())\r\n                bestScore = score;\r\n        }\r\n    }\r\n    if (null == bestScore) {\r\n        bestScore = NodeTest.SCORE_NONE;\r\n    }\r\n    return bestScore;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemAttributeSet.recompose",
	"Comment": "this function is called during recomposition tocontrol how this element is composed.",
	"Method": "void recompose(StylesheetRoot root){\r\n    root.recomposeAttributeSets(this);\r\n}"
}, {
	"Path": "hudson.model.Item.getRelativeNameFrom",
	"Comment": "gets the relative name to this item from the specified group.",
	"Method": "String getRelativeNameFrom(ItemGroup g,String getRelativeNameFrom,Item item){\r\n    return getRelativeNameFrom(item.getParent());\r\n}"
}, {
	"Path": "hudson.Launcher.inherit",
	"Comment": "expands the list of environment variables by inheriting current env variables.",
	"Method": "EnvVars inherit(String[] env,EnvVars inherit,Map<String, String> overrides){\r\n    EnvVars m = new EnvVars(EnvVars.masterEnvVars);\r\n    m.overrideExpandingAll(overrides);\r\n    return m;\r\n}"
}, {
	"Path": "com.iluwatar.iterator.bst.TreeNode.getParentNodeOfValueToBeInserted",
	"Comment": "fetch the parent treenode for a given value to insert into the bst.",
	"Method": "TreeNode<T> getParentNodeOfValueToBeInserted(T valToInsert){\r\n    TreeNode<T> parent = null;\r\n    TreeNode<T> curr = this;\r\n    while (curr != null) {\r\n        parent = curr;\r\n        curr = curr.traverseOneLevelDown(valToInsert);\r\n    }\r\n    return parent;\r\n}"
}, {
	"Path": "hudson.model.Queue.getDiscoverableItems",
	"Comment": "returns an array of item for which it is only visible the name of the task.generally speaking the array is sorted such that the items that are most likely built sooner areat the end.",
	"Method": "StubItem[] getDiscoverableItems(){\r\n    Snapshot s = this.snapshot;\r\n    List<StubItem> r = new ArrayList<StubItem>();\r\n    for (WaitingItem p : s.waitingList) {\r\n        r = filterDiscoverableItemListBasedOnPermissions(r, p);\r\n    }\r\n    for (BlockedItem p : s.blockedProjects) {\r\n        r = filterDiscoverableItemListBasedOnPermissions(r, p);\r\n    }\r\n    for (BuildableItem p : reverse(s.buildables)) {\r\n        r = filterDiscoverableItemListBasedOnPermissions(r, p);\r\n    }\r\n    for (BuildableItem p : reverse(s.pendings)) {\r\n        r = filterDiscoverableItemListBasedOnPermissions(r, p);\r\n    }\r\n    StubItem[] items = new StubItem[r.size()];\r\n    r.toArray(items);\r\n    return items;\r\n}"
}, {
	"Path": "org.java_websocket.drafts.Draft_6455.checkBufferLimit",
	"Comment": "check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size",
	"Method": "void checkBufferLimit(){\r\n    long totalSize = getByteBufferListSize();\r\n    if (totalSize > maxFrameSize) {\r\n        clearBufferList();\r\n        log.trace(\"Payload limit reached. Allowed: {} Current: {}\", maxFrameSize, totalSize);\r\n        throw new LimitExceededException(maxFrameSize);\r\n    }\r\n}"
}, {
	"Path": "hudson.model.ViewDescriptor.isInstantiable",
	"Comment": "some special views are not instantiable, and for thosethis method returns false.",
	"Method": "boolean isInstantiable(){\r\n    return true;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.registry.ManifestPusher.makeUnexpectedImageDigestWarning",
	"Comment": "makes the warning for when the registry responds with an image digest that is not the expecteddigest of the image.",
	"Method": "String makeUnexpectedImageDigestWarning(DescriptorDigest expectedDigest,List<String> receivedDigests){\r\n    if (receivedDigests.isEmpty()) {\r\n        return \"Expected image digest \" + expectedDigest + \", but received none\";\r\n    }\r\n    StringJoiner message = new StringJoiner(\", \", \"Expected image digest \" + expectedDigest + \", but received: \", \"\");\r\n    for (String receivedDigest : receivedDigests) {\r\n        message.add(receivedDigest);\r\n    }\r\n    return message.toString();\r\n}"
}, {
	"Path": "org.apache.xml.utils.QName.getPrefix",
	"Comment": "returns the namespace prefix. returns null if the namespaceprefix is not known.",
	"Method": "String getPrefix(){\r\n    return _prefix;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FunctionMultiArgs.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    super.fixupVariables(vars, globalsSize);\r\n    if (null != m_args) {\r\n        for (int i = 0; i < m_args.length; i++) {\r\n            m_args[i].fixupVariables(vars, globalsSize);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.LSSerializerImpl.createLSException",
	"Comment": "creates an lsexception. on j2se 1.4 and above the cause for the exception will be set.",
	"Method": "LSException createLSException(short code,Throwable cause){\r\n    LSException lse = new LSException(code, cause != null ? cause.getMessage() : null);\r\n    if (cause != null && ThrowableMethods.fgThrowableMethodsAvailable) {\r\n        try {\r\n            ThrowableMethods.fgThrowableInitCauseMethod.invoke(lse, new Object[] { cause });\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return lse;\r\n}"
}, {
	"Path": "hudson.model.Fingerprint.canDiscoverItem",
	"Comment": "checks if the current user can discover the item.if yes, it may be displayed as a text in fingerprint uis.",
	"Method": "boolean canDiscoverItem(String fullName){\r\n    final Jenkins jenkins = Jenkins.getInstance();\r\n    Item item = null;\r\n    try {\r\n        item = jenkins.getItemByFullName(fullName);\r\n    } catch (AccessDeniedException ex) {\r\n    }\r\n    if (item != null) {\r\n        return true;\r\n    }\r\n    final Authentication userAuth = Jenkins.getAuthentication();\r\n    try (ACLContext acl = ACL.as(ACL.SYSTEM)) {\r\n        final Item itemBySystemUser = jenkins.getItemByFullName(fullName);\r\n        if (itemBySystemUser == null) {\r\n            return false;\r\n        }\r\n        boolean canDiscoverTheItem = itemBySystemUser.hasPermission(userAuth, Item.DISCOVER);\r\n        if (canDiscoverTheItem) {\r\n            ItemGroup<?> current = itemBySystemUser.getParent();\r\n            do {\r\n                if (current instanceof Item) {\r\n                    final Item i = (Item) current;\r\n                    current = i.getParent();\r\n                    if (!i.hasPermission(userAuth, Item.READ)) {\r\n                        canDiscoverTheItem = false;\r\n                    }\r\n                } else {\r\n                    current = null;\r\n                }\r\n            } while (canDiscoverTheItem && current != null);\r\n        }\r\n        return canDiscoverTheItem;\r\n    }\r\n}"
}, {
	"Path": "hudson.util.DoubleLaunchChecker.getId",
	"Comment": "figures out a string that identifies this instance of hudson.",
	"Method": "String getId(){\r\n    Jenkins h = Jenkins.getInstance();\r\n    String contextPath = \"\";\r\n    try {\r\n        Method m = ServletContext.class.getMethod(\"getContextPath\");\r\n        contextPath = \" contextPath=\\\"\" + m.invoke(h.servletContext) + \"\\\"\";\r\n    } catch (Exception e) {\r\n    }\r\n    return h.hashCode() + contextPath + \" at \" + ManagementFactory.getRuntimeMXBean().getName();\r\n}"
}, {
	"Path": "hudson.slaves.WorkspaceList.record",
	"Comment": "just record that this workspace is being used, without paying any attention to the synchronization support.",
	"Method": "Lease record(FilePath p){\r\n    if (LOGGER.isLoggable(Level.FINE)) {\r\n        LOGGER.log(Level.FINE, \"recorded \" + p, new Throwable(\"from \" + this));\r\n    }\r\n    Entry old = inUse.put(p, new Entry(p, false));\r\n    if (old != null)\r\n        throw new AssertionError(\"Tried to record a workspace already owned: \" + old);\r\n    return lease(p);\r\n}"
}, {
	"Path": "org.apache.xml.utils.DOMBuilder.setNextSibling",
	"Comment": "set the next sibling node, which is where the result nodes should be inserted before.",
	"Method": "void setNextSibling(Node nextSibling){\r\n    m_nextSibling = nextSibling;\r\n}"
}, {
	"Path": "redis.clients.jedis.JedisClusterInfoCache.reset",
	"Comment": "clear discovered nodes collections and gently release allocated resources",
	"Method": "void reset(){\r\n    w.lock();\r\n    try {\r\n        for (JedisPool pool : nodes.values()) {\r\n            try {\r\n                if (pool != null) {\r\n                    pool.destroy();\r\n                }\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        nodes.clear();\r\n        slots.clear();\r\n    } finally {\r\n        w.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLStringDefault.startsWith",
	"Comment": "tests if this string starts with the specified prefix beginninga specified index.",
	"Method": "boolean startsWith(String prefix,int toffset,boolean startsWith,XMLString prefix,int toffset,boolean startsWith,String prefix,boolean startsWith,XMLString prefix){\r\n    return m_str.startsWith(prefix.toString());\r\n}"
}, {
	"Path": "org.apache.xpath.axes.WalkerFactory.createDefaultStepPattern",
	"Comment": "create a steppattern that is contained within a locationpath.",
	"Method": "StepPattern createDefaultStepPattern(Compiler compiler,int opPos,MatchPatternIterator mpi,int analysis,StepPattern tail,StepPattern head){\r\n    int stepType = compiler.getOp(opPos);\r\n    boolean simpleInit = false;\r\n    boolean prevIsOneStepDown = true;\r\n    int whatToShow = compiler.getWhatToShow(opPos);\r\n    StepPattern ai = null;\r\n    int axis, predicateAxis;\r\n    switch(stepType) {\r\n        case OpCodes.OP_VARIABLE:\r\n        case OpCodes.OP_EXTFUNCTION:\r\n        case OpCodes.OP_FUNCTION:\r\n        case OpCodes.OP_GROUP:\r\n            prevIsOneStepDown = false;\r\n            Expression expr;\r\n            switch(stepType) {\r\n                case OpCodes.OP_VARIABLE:\r\n                case OpCodes.OP_EXTFUNCTION:\r\n                case OpCodes.OP_FUNCTION:\r\n                case OpCodes.OP_GROUP:\r\n                    expr = compiler.compile(opPos);\r\n                    break;\r\n                default:\r\n                    expr = compiler.compile(opPos + 2);\r\n            }\r\n            axis = Axis.FILTEREDLIST;\r\n            predicateAxis = Axis.FILTEREDLIST;\r\n            ai = new FunctionPattern(expr, axis, predicateAxis);\r\n            simpleInit = true;\r\n            break;\r\n        case OpCodes.FROM_ROOT:\r\n            whatToShow = DTMFilter.SHOW_DOCUMENT | DTMFilter.SHOW_DOCUMENT_FRAGMENT;\r\n            axis = Axis.ROOT;\r\n            predicateAxis = Axis.ROOT;\r\n            ai = new StepPattern(DTMFilter.SHOW_DOCUMENT | DTMFilter.SHOW_DOCUMENT_FRAGMENT, axis, predicateAxis);\r\n            break;\r\n        case OpCodes.FROM_ATTRIBUTES:\r\n            whatToShow = DTMFilter.SHOW_ATTRIBUTE;\r\n            axis = Axis.PARENT;\r\n            predicateAxis = Axis.ATTRIBUTE;\r\n            break;\r\n        case OpCodes.FROM_NAMESPACE:\r\n            whatToShow = DTMFilter.SHOW_NAMESPACE;\r\n            axis = Axis.PARENT;\r\n            predicateAxis = Axis.NAMESPACE;\r\n            break;\r\n        case OpCodes.FROM_ANCESTORS:\r\n            axis = Axis.DESCENDANT;\r\n            predicateAxis = Axis.ANCESTOR;\r\n            break;\r\n        case OpCodes.FROM_CHILDREN:\r\n            axis = Axis.PARENT;\r\n            predicateAxis = Axis.CHILD;\r\n            break;\r\n        case OpCodes.FROM_ANCESTORS_OR_SELF:\r\n            axis = Axis.DESCENDANTORSELF;\r\n            predicateAxis = Axis.ANCESTORORSELF;\r\n            break;\r\n        case OpCodes.FROM_SELF:\r\n            axis = Axis.SELF;\r\n            predicateAxis = Axis.SELF;\r\n            break;\r\n        case OpCodes.FROM_PARENT:\r\n            axis = Axis.CHILD;\r\n            predicateAxis = Axis.PARENT;\r\n            break;\r\n        case OpCodes.FROM_PRECEDING_SIBLINGS:\r\n            axis = Axis.FOLLOWINGSIBLING;\r\n            predicateAxis = Axis.PRECEDINGSIBLING;\r\n            break;\r\n        case OpCodes.FROM_PRECEDING:\r\n            axis = Axis.FOLLOWING;\r\n            predicateAxis = Axis.PRECEDING;\r\n            break;\r\n        case OpCodes.FROM_FOLLOWING_SIBLINGS:\r\n            axis = Axis.PRECEDINGSIBLING;\r\n            predicateAxis = Axis.FOLLOWINGSIBLING;\r\n            break;\r\n        case OpCodes.FROM_FOLLOWING:\r\n            axis = Axis.PRECEDING;\r\n            predicateAxis = Axis.FOLLOWING;\r\n            break;\r\n        case OpCodes.FROM_DESCENDANTS_OR_SELF:\r\n            axis = Axis.ANCESTORORSELF;\r\n            predicateAxis = Axis.DESCENDANTORSELF;\r\n            break;\r\n        case OpCodes.FROM_DESCENDANTS:\r\n            axis = Axis.ANCESTOR;\r\n            predicateAxis = Axis.DESCENDANT;\r\n            break;\r\n        default:\r\n            throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[] { Integer.toString(stepType) }));\r\n    }\r\n    if (null == ai) {\r\n        whatToShow = compiler.getWhatToShow(opPos);\r\n        ai = new StepPattern(whatToShow, compiler.getStepNS(opPos), compiler.getStepLocalName(opPos), axis, predicateAxis);\r\n    }\r\n    if (false || DEBUG_PATTERN_CREATION) {\r\n        System.out.print(\"new step: \" + ai);\r\n        System.out.print(\", axis: \" + Axis.getNames(ai.getAxis()));\r\n        System.out.print(\", predAxis: \" + Axis.getNames(ai.getAxis()));\r\n        System.out.print(\", what: \");\r\n        System.out.print(\"    \");\r\n        ai.debugWhatToShow(ai.getWhatToShow());\r\n    }\r\n    int argLen = compiler.getFirstPredicateOpPos(opPos);\r\n    ai.setPredicates(compiler.getCompiledPredicates(argLen));\r\n    return ai;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.getOutputStream",
	"Comment": "get the output stream where the events will be serialized to.",
	"Method": "OutputStream getOutputStream(){\r\n    return m_outputStream;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.NodeSequence.addNodeInDocOrder",
	"Comment": "add the node into a vector of nodes where it should occur indocument order.",
	"Method": "int addNodeInDocOrder(int node){\r\n    assertion(hasCache(), \"addNodeInDocOrder must be done on a mutable sequence!\");\r\n    int insertIndex = -1;\r\n    NodeVector vec = getVector();\r\n    int size = vec.size(), i;\r\n    for (i = size - 1; i >= 0; i--) {\r\n        int child = vec.elementAt(i);\r\n        if (child == node) {\r\n            i = -2;\r\n            break;\r\n        }\r\n        DTM dtm = m_dtmMgr.getDTM(node);\r\n        if (!dtm.isNodeAfter(node, child)) {\r\n            break;\r\n        }\r\n    }\r\n    if (i != -2) {\r\n        insertIndex = i + 1;\r\n        vec.insertElementAt(node, insertIndex);\r\n    }\r\n    return insertIndex;\r\n}"
}, {
	"Path": "com.iluwatar.promise.App.download",
	"Comment": "return a promise to provide the local absolute path of the file downloaded in background.this is an async method and does not wait until the file is downloaded.",
	"Method": "Promise<String> download(String urlString){\r\n    return new Promise<String>().fulfillInAsync(() -> Utility.downloadFile(urlString), executor).onError(throwable -> {\r\n        throwable.printStackTrace();\r\n        taskCompleted();\r\n    });\r\n}"
}, {
	"Path": "org.java_websocket.framing.CloseFrame.updatePayload",
	"Comment": "update the payload to represent the close code and the reason",
	"Method": "void updatePayload(){\r\n    byte[] by = Charsetfunctions.utf8Bytes(reason);\r\n    ByteBuffer buf = ByteBuffer.allocate(4);\r\n    buf.putInt(code);\r\n    buf.position(2);\r\n    ByteBuffer pay = ByteBuffer.allocate(2 + by.length);\r\n    pay.put(buf);\r\n    pay.put(by);\r\n    pay.rewind();\r\n    super.setPayload(pay);\r\n}"
}, {
	"Path": "hudson.ClassicPluginStrategy.isDetachedPlugin",
	"Comment": "is the named plugin a plugin that was detached from jenkins at some point in the past.",
	"Method": "boolean isDetachedPlugin(String pluginId){\r\n    for (DetachedPlugin detachedPlugin : DETACHED_LIST) {\r\n        if (detachedPlugin.getShortName().equals(pluginId)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.Compiler.getLocationPathDepth",
	"Comment": "get the level of the location path or union being constructed.",
	"Method": "int getLocationPathDepth(){\r\n    return locPathDepth;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.OutputProperties.getProperty",
	"Comment": "searches for the property with the specified key in the property list.if the key is not found in this property list, the default property list,and its defaults, recursively, are then checked. the method returnsnull if the property is not found.",
	"Method": "String getProperty(QName key,String getProperty,String key){\r\n    if (key.startsWith(OutputPropertiesFactory.S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL))\r\n        key = OutputPropertiesFactory.S_BUILTIN_EXTENSIONS_UNIVERSAL + key.substring(OutputPropertiesFactory.S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL_LEN);\r\n    return m_properties.getProperty(key);\r\n}"
}, {
	"Path": "hudson.model.labels.LabelExpression.paren",
	"Comment": "puts the label name into a parenthesis if the given operator will have a higher precedence.",
	"Method": "String paren(LabelOperatorPrecedence op,Label l){\r\n    if (op.compareTo(l.precedence()) < 0)\r\n        return '(' + l.getExpression() + ')';\r\n    return l.getExpression();\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.accumDefaultEntity",
	"Comment": "handle one of the default entities, return false if itis not a default entity.",
	"Method": "int accumDefaultEntity(java.io.Writer writer,char ch,int i,char[] chars,int len,boolean fromTextNode,boolean escLF){\r\n    if (!escLF && CharInfo.S_LINEFEED == ch) {\r\n        writer.write(m_lineSep, 0, m_lineSepLen);\r\n    } else {\r\n        if ((fromTextNode && m_charInfo.shouldMapTextChar(ch)) || (!fromTextNode && m_charInfo.shouldMapAttrChar(ch))) {\r\n            String outputStringForChar = m_charInfo.getOutputStringForChar(ch);\r\n            if (null != outputStringForChar) {\r\n                writer.write(outputStringForChar);\r\n            } else\r\n                return i;\r\n        } else\r\n            return i;\r\n    }\r\n    return i + 1;\r\n}"
}, {
	"Path": "org.apache.xml.utils.ObjectVector.insertElementAt",
	"Comment": "inserts the specified object in this vector at the specified index.each component in this vector with an index greater or equal tothe specified index is shifted upward to have an index one greaterthan the value it had previously.",
	"Method": "void insertElementAt(Object value,int at){\r\n    if ((m_firstFree + 1) >= m_mapSize) {\r\n        m_mapSize += m_blocksize;\r\n        Object[] newMap = new Object[m_mapSize];\r\n        System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);\r\n        m_map = newMap;\r\n    }\r\n    if (at <= (m_firstFree - 1)) {\r\n        System.arraycopy(m_map, at, m_map, at + 1, m_firstFree - at);\r\n    }\r\n    m_map[at] = value;\r\n    m_firstFree++;\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XStringForFSB.startsWith",
	"Comment": "tests if this string starts with the specified prefix beginninga specified index.",
	"Method": "boolean startsWith(XMLString prefix,int toffset,boolean startsWith,XMLString prefix){\r\n    return startsWith(prefix, 0);\r\n}"
}, {
	"Path": "hudson.cli.DisablePluginCommandTest.quietModeEmptyOutputSucceed",
	"Comment": "in quiet mode, no message is printed if all plugins are disabled or were already disabled.",
	"Method": "void quietModeEmptyOutputSucceed(){\r\n    CLICommandInvoker.Result result = disablePluginsCLiCommand(\"-strategy\", \"all\", \"-quiet\", \"dependee\");\r\n    assertThat(result, succeeded());\r\n    assertPluginDisabled(\"dependee\");\r\n    assertPluginDisabled(\"depender\");\r\n    assertPluginDisabled(\"mandatory-depender\");\r\n    assertTrue(\"No log in quiet mode if all plugins disabled\", StringUtils.isEmpty(result.stdout()));\r\n}"
}, {
	"Path": "org.apache.xpath.axes.DescendantIterator.setRoot",
	"Comment": "initialize the context values for this expressionafter it is cloned.",
	"Method": "void setRoot(int context,Object environment){\r\n    super.setRoot(context, environment);\r\n    m_traverser = m_cdtm.getAxisTraverser(m_axis);\r\n    String localName = getLocalName();\r\n    String namespace = getNamespace();\r\n    int what = m_whatToShow;\r\n    if (DTMFilter.SHOW_ALL == what || NodeTest.WILD.equals(localName) || NodeTest.WILD.equals(namespace)) {\r\n        m_extendedTypeID = 0;\r\n    } else {\r\n        int type = getNodeTypeTest(what);\r\n        m_extendedTypeID = m_cdtm.getExpandedTypeID(namespace, localName, type);\r\n    }\r\n}"
}, {
	"Path": "hudson.model.Slave.getWorkspaceRoot",
	"Comment": "root directory on this agent where all the job workspaces are laid out.",
	"Method": "FilePath getWorkspaceRoot(){\r\n    FilePath r = getRootPath();\r\n    if (r == null)\r\n        return null;\r\n    return r.child(WORKSPACE_ROOT);\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.setSourceTreeManager",
	"Comment": "set the sourcetreemanager associated with this execution context.",
	"Method": "void setSourceTreeManager(SourceTreeManager mgr){\r\n    m_sourceTreeManager = mgr;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncSum.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    DTMIterator nodes = m_arg0.asIterator(xctxt, xctxt.getCurrentNode());\r\n    double sum = 0.0;\r\n    int pos;\r\n    while (DTM.NULL != (pos = nodes.nextNode())) {\r\n        DTM dtm = nodes.getDTM(pos);\r\n        XMLString s = dtm.getStringValue(pos);\r\n        if (null != s)\r\n            sum += s.toDouble();\r\n    }\r\n    nodes.detach();\r\n    return new XNumber(sum);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemVariable.execute",
	"Comment": "execute a variable declaration and push it onto the variable stack.",
	"Method": "void execute(TransformerImpl transformer){\r\n    int sourceNode = transformer.getXPathContext().getCurrentNode();\r\n    XObject var = getValue(transformer, sourceNode);\r\n    transformer.getXPathContext().getVarStack().setLocalVariable(m_index, var);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetComposed.recompose",
	"Comment": "adds all recomposable values for this precedence level into the recomposableelements vectorthat was passed in as the first parameter.all elements added to therecomposableelements vector should extend elemtemplateelement.",
	"Method": "void recompose(Vector recomposableElements){\r\n    int n = getIncludeCountComposed();\r\n    for (int i = -1; i < n; i++) {\r\n        Stylesheet included = getIncludeComposed(i);\r\n        int s = included.getOutputCount();\r\n        for (int j = 0; j < s; j++) {\r\n            recomposableElements.addElement(included.getOutput(j));\r\n        }\r\n        s = included.getAttributeSetCount();\r\n        for (int j = 0; j < s; j++) {\r\n            recomposableElements.addElement(included.getAttributeSet(j));\r\n        }\r\n        s = included.getDecimalFormatCount();\r\n        for (int j = 0; j < s; j++) {\r\n            recomposableElements.addElement(included.getDecimalFormat(j));\r\n        }\r\n        s = included.getKeyCount();\r\n        for (int j = 0; j < s; j++) {\r\n            recomposableElements.addElement(included.getKey(j));\r\n        }\r\n        s = included.getNamespaceAliasCount();\r\n        for (int j = 0; j < s; j++) {\r\n            recomposableElements.addElement(included.getNamespaceAlias(j));\r\n        }\r\n        s = included.getTemplateCount();\r\n        for (int j = 0; j < s; j++) {\r\n            recomposableElements.addElement(included.getTemplate(j));\r\n        }\r\n        s = included.getVariableOrParamCount();\r\n        for (int j = 0; j < s; j++) {\r\n            recomposableElements.addElement(included.getVariableOrParam(j));\r\n        }\r\n        s = included.getStripSpaceCount();\r\n        for (int j = 0; j < s; j++) {\r\n            recomposableElements.addElement(included.getStripSpace(j));\r\n        }\r\n        s = included.getPreserveSpaceCount();\r\n        for (int j = 0; j < s; j++) {\r\n            recomposableElements.addElement(included.getPreserveSpace(j));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.bridge.HammerTest.testHammer",
	"Comment": "invoke all possible actions on the weapon and check if the actions are executed on the actualunderlying weapon implementation.",
	"Method": "void testHammer(){\r\n    final Hammer hammer = spy(new Hammer(mock(FlyingEnchantment.class)));\r\n    testBasicWeaponActions(hammer);\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.isUseCrumbs",
	"Comment": "if true, all the post requests to jenkins would have to have crumb in it to protectjenkins from csrf vulnerabilities.",
	"Method": "boolean isUseCrumbs(){\r\n    return crumbIssuer != null;\r\n}"
}, {
	"Path": "hudson.model.Computer.getLogFile",
	"Comment": "this is where the log from the remote agent goes.the method also creates a log directory if required.",
	"Method": "File getLogFile(){\r\n    return new File(getLogDir(), \"slave.log\");\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.setVarStack",
	"Comment": "get the variable stack, which is in charge of variables andparameters.",
	"Method": "void setVarStack(VariableStack varStack){\r\n    m_variableStacks = varStack;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.MatchPatternIterator.getNextNode",
	"Comment": "get the next node via getnextxxx.bottlenecked for derived class override.",
	"Method": "int getNextNode(){\r\n    m_lastFetched = (DTM.NULL == m_lastFetched) ? m_traverser.first(m_context) : m_traverser.next(m_context, m_lastFetched);\r\n    return m_lastFetched;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.dom2dtm.DOM2DTM.getSourceLocatorFor",
	"Comment": "no source information is available for dom2dtm, so returnnull here.",
	"Method": "SourceLocator getSourceLocatorFor(int node){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerImpl.createSerializationHandler",
	"Comment": "create a contenthandler from a result object and an outputproperties.",
	"Method": "SerializationHandler createSerializationHandler(Result outputTarget,SerializationHandler createSerializationHandler,Result outputTarget,OutputProperties format){\r\n    SerializationHandler xoh;\r\n    org.w3c.dom.Node outputNode = null;\r\n    if (outputTarget instanceof DOMResult) {\r\n        outputNode = ((DOMResult) outputTarget).getNode();\r\n        org.w3c.dom.Node nextSibling = ((DOMResult) outputTarget).getNextSibling();\r\n        org.w3c.dom.Document doc;\r\n        short type;\r\n        if (null != outputNode) {\r\n            type = outputNode.getNodeType();\r\n            doc = (org.w3c.dom.Node.DOCUMENT_NODE == type) ? (org.w3c.dom.Document) outputNode : outputNode.getOwnerDocument();\r\n        } else {\r\n            boolean isSecureProcessing = m_stylesheetRoot.isSecureProcessing();\r\n            doc = org.apache.xml.utils.DOMHelper.createDocument(isSecureProcessing);\r\n            outputNode = doc;\r\n            type = outputNode.getNodeType();\r\n            ((DOMResult) outputTarget).setNode(outputNode);\r\n        }\r\n        DOMBuilder handler = (org.w3c.dom.Node.DOCUMENT_FRAGMENT_NODE == type) ? new DOMBuilder(doc, (org.w3c.dom.DocumentFragment) outputNode) : new DOMBuilder(doc, outputNode);\r\n        if (nextSibling != null)\r\n            handler.setNextSibling(nextSibling);\r\n        String encoding = format.getProperty(OutputKeys.ENCODING);\r\n        xoh = new ToXMLSAXHandler(handler, (LexicalHandler) handler, encoding);\r\n    } else if (outputTarget instanceof SAXResult) {\r\n        ContentHandler handler = ((SAXResult) outputTarget).getHandler();\r\n        if (null == handler)\r\n            throw new IllegalArgumentException(\"handler can not be null for a SAXResult\");\r\n        LexicalHandler lexHandler;\r\n        if (handler instanceof LexicalHandler)\r\n            lexHandler = (LexicalHandler) handler;\r\n        else\r\n            lexHandler = null;\r\n        String encoding = format.getProperty(OutputKeys.ENCODING);\r\n        String method = format.getProperty(OutputKeys.METHOD);\r\n        ToXMLSAXHandler toXMLSAXHandler = new ToXMLSAXHandler(handler, lexHandler, encoding);\r\n        toXMLSAXHandler.setShouldOutputNSAttr(false);\r\n        xoh = toXMLSAXHandler;\r\n        String publicID = format.getProperty(OutputKeys.DOCTYPE_PUBLIC);\r\n        String systemID = format.getProperty(OutputKeys.DOCTYPE_SYSTEM);\r\n        if (systemID != null)\r\n            xoh.setDoctypeSystem(systemID);\r\n        if (publicID != null)\r\n            xoh.setDoctypePublic(publicID);\r\n        if (handler instanceof TransformerClient) {\r\n            XalanTransformState state = new XalanTransformState();\r\n            ((TransformerClient) handler).setTransformState(state);\r\n            ((ToSAXHandler) xoh).setTransformState(state);\r\n        }\r\n    } else if (outputTarget instanceof StreamResult) {\r\n        StreamResult sresult = (StreamResult) outputTarget;\r\n        try {\r\n            SerializationHandler serializer = (SerializationHandler) SerializerFactory.getSerializer(format.getProperties());\r\n            if (null != sresult.getWriter())\r\n                serializer.setWriter(sresult.getWriter());\r\n            else if (null != sresult.getOutputStream())\r\n                serializer.setOutputStream(sresult.getOutputStream());\r\n            else if (null != sresult.getSystemId()) {\r\n                String fileURL = sresult.getSystemId();\r\n                if (fileURL.startsWith(\"file:///\")) {\r\n                    if (fileURL.substring(8).indexOf(\":\") > 0)\r\n                        fileURL = fileURL.substring(8);\r\n                    else\r\n                        fileURL = fileURL.substring(7);\r\n                } else if (fileURL.startsWith(\"file:/\")) {\r\n                    if (fileURL.substring(6).indexOf(\":\") > 0)\r\n                        fileURL = fileURL.substring(6);\r\n                    else\r\n                        fileURL = fileURL.substring(5);\r\n                }\r\n                m_outputStream = new java.io.FileOutputStream(fileURL);\r\n                serializer.setOutputStream(m_outputStream);\r\n                xoh = serializer;\r\n            } else\r\n                throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_OUTPUT_SPECIFIED, null));\r\n            xoh = serializer;\r\n        } catch (IOException ioe) {\r\n            throw new TransformerException(ioe);\r\n        }\r\n    } else {\r\n        throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_TRANSFORM_TO_RESULT_TYPE, new Object[] { outputTarget.getClass().getName() }));\r\n    }\r\n    xoh.setTransformer(this);\r\n    SourceLocator srcLocator = getStylesheet();\r\n    xoh.setSourceLocator(srcLocator);\r\n    return xoh;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncContains.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    String s1 = m_arg0.execute(xctxt).str();\r\n    String s2 = m_arg1.execute(xctxt).str();\r\n    if (s1.length() == 0 && s2.length() == 0)\r\n        return XBoolean.S_TRUE;\r\n    int index = s1.indexOf(s2);\r\n    return (index > -1) ? XBoolean.S_TRUE : XBoolean.S_FALSE;\r\n}"
}, {
	"Path": "com.iluwatar.builder.HeroTest.testMissingProfession",
	"Comment": "test if we get the expected exception when trying to create a hero without a profession",
	"Method": "void testMissingProfession(){\r\n    assertThrows(IllegalArgumentException.class, () -> new Hero.Builder(null, \"Sir without a job\"));\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.inTemporaryOutputState",
	"Comment": "returns true if the serializer is used for temporary output rather thanfinal output.this concept is made clear in the xslt 2.0 draft.",
	"Method": "boolean inTemporaryOutputState(){\r\n    return (getEncoding() == null);\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.cloneWithReset",
	"Comment": "get a cloned iterator, and reset its state to the beginning of theiteration.",
	"Method": "NodeIterator cloneWithReset(){\r\n    NodeSet clone = (NodeSet) clone();\r\n    clone.reset();\r\n    return clone;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemElement.resolvePrefix",
	"Comment": "resolve the namespace into a prefix.meant to beoveridded by elemattribute if this class is derived.",
	"Method": "String resolvePrefix(SerializationHandler rhandler,String prefix,String nodeNamespace){\r\n    return prefix;\r\n}"
}, {
	"Path": "org.apache.xpath.operations.Variable.execute",
	"Comment": "dereference the variable, and return the reference value.note that lazy evaluation will occur.if a variable within scope is not found, a warning will be sent to the error listener, and an empty nodeset will be returned.",
	"Method": "XObject execute(XPathContext xctxt,XObject execute,XPathContext xctxt,boolean destructiveOK){\r\n    org.apache.xml.utils.PrefixResolver xprefixResolver = xctxt.getNamespaceContext();\r\n    XObject result;\r\n    if (m_fixUpWasCalled) {\r\n        if (m_isGlobal)\r\n            result = xctxt.getVarStack().getGlobalVariable(xctxt, m_index, destructiveOK);\r\n        else\r\n            result = xctxt.getVarStack().getLocalVariable(xctxt, m_index, destructiveOK);\r\n    } else {\r\n        result = xctxt.getVarStack().getVariableOrParam(xctxt, m_qname);\r\n    }\r\n    if (null == result) {\r\n        warn(// \"VariableReference given for variable out \"+\r\n        xctxt, XPATHErrorResources.WG_ILLEGAL_VARIABLE_REFERENCE, new Object[] { m_qname.getLocalPart() });\r\n        result = new XNodeSet(xctxt.getDTMManager());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.setClassPath",
	"Comment": "set the classpath to search for classes to load. this should not bechanged once the classloader starts to server classes",
	"Method": "void setClassPath(Path classpath){\r\n    pathComponents.removeAllElements();\r\n    if (classpath != null) {\r\n        Path actualClasspath = classpath.concatSystemClasspath(\"ignore\");\r\n        String[] pathElements = actualClasspath.list();\r\n        for (int i = 0; i < pathElements.length; ++i) {\r\n            try {\r\n                addPathElement(pathElements[i]);\r\n            } catch (BuildException e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncId.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    int context = xctxt.getCurrentNode();\r\n    DTM dtm = xctxt.getDTM(context);\r\n    int docContext = dtm.getDocument();\r\n    if (DTM.NULL == docContext)\r\n        error(xctxt, XPATHErrorResources.ER_CONTEXT_HAS_NO_OWNERDOC, null);\r\n    XObject arg = m_arg0.execute(xctxt);\r\n    int argType = arg.getType();\r\n    XNodeSet nodes = new XNodeSet(xctxt.getDTMManager());\r\n    NodeSetDTM nodeSet = nodes.mutableNodeset();\r\n    if (XObject.CLASS_NODESET == argType) {\r\n        DTMIterator ni = arg.iter();\r\n        StringVector usedrefs = null;\r\n        int pos = ni.nextNode();\r\n        while (DTM.NULL != pos) {\r\n            DTM ndtm = ni.getDTM(pos);\r\n            String refval = ndtm.getStringValue(pos).toString();\r\n            pos = ni.nextNode();\r\n            usedrefs = getNodesByID(xctxt, docContext, refval, usedrefs, nodeSet, DTM.NULL != pos);\r\n        }\r\n    } else if (XObject.CLASS_NULL == argType) {\r\n        return nodes;\r\n    } else {\r\n        String refval = arg.str();\r\n        getNodesByID(xctxt, docContext, refval, null, nodeSet, false);\r\n    }\r\n    return nodes;\r\n}"
}, {
	"Path": "redis.clients.jedis.util.Pool.getNumWaiters",
	"Comment": "returns an estimate of the number of threads currently blocked waiting fora resource from this pool.",
	"Method": "int getNumWaiters(){\r\n    if (poolInactive()) {\r\n        return -1;\r\n    }\r\n    return this.internalPool.getNumWaiters();\r\n}"
}, {
	"Path": "hudson.util.ReflectionUtils.getPublicMethodNamed",
	"Comment": "finds a public method of the given name, regardless of its parameter definitions,",
	"Method": "Method getPublicMethodNamed(Class c,String methodName){\r\n    for (Method m : c.getMethods()) if (m.getName().equals(methodName))\r\n        return m;\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.ProcessorGlobalParamDecl.appendAndPush",
	"Comment": "append the current template element to the currenttemplate element, and then push it onto the current templateelement stack.",
	"Method": "void appendAndPush(StylesheetHandler handler,ElemTemplateElement elem){\r\n    handler.pushElemTemplateElement(elem);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.ProcessorInclude.getHref",
	"Comment": "get the base identifier with which this stylesheet is associated.",
	"Method": "String getHref(){\r\n    return m_href;\r\n}"
}, {
	"Path": "hudson.model.Computer.isJnlpAgent",
	"Comment": "returns true if this computer is supposed to be launched via jnlp.",
	"Method": "boolean isJnlpAgent(){\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.StepPattern.execute",
	"Comment": "execute an expression in the xpath runtime context, and return theresult of the expression.",
	"Method": "XObject execute(XPathContext xctxt,int currentNode,XObject execute,XPathContext xctxt,XObject execute,XPathContext xctxt,int currentNode,DTM dtm,int expType){\r\n    if (m_whatToShow == NodeTest.SHOW_BYFUNCTION) {\r\n        if (null != m_relativePathPattern) {\r\n            return m_relativePathPattern.execute(xctxt);\r\n        } else\r\n            return NodeTest.SCORE_NONE;\r\n    }\r\n    XObject score;\r\n    score = super.execute(xctxt, currentNode, dtm, expType);\r\n    if (score == NodeTest.SCORE_NONE)\r\n        return NodeTest.SCORE_NONE;\r\n    if (getPredicateCount() != 0) {\r\n        if (!executePredicates(xctxt, dtm, currentNode))\r\n            return NodeTest.SCORE_NONE;\r\n    }\r\n    if (null != m_relativePathPattern)\r\n        return m_relativePathPattern.executeRelativePathPattern(xctxt, dtm, currentNode);\r\n    return score;\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.StepPattern.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frameindexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    super.fixupVariables(vars, globalsSize);\r\n    if (null != m_predicates) {\r\n        for (int i = 0; i < m_predicates.length; i++) {\r\n            m_predicates[i].fixupVariables(vars, globalsSize);\r\n        }\r\n    }\r\n    if (null != m_relativePathPattern) {\r\n        m_relativePathPattern.fixupVariables(vars, globalsSize);\r\n    }\r\n}"
}, {
	"Path": "hudson.model.AsyncAperiodicWork.getSlowLoggingLevel",
	"Comment": "returns the logging level at which previous task still executing messages is displayed.",
	"Method": "Level getSlowLoggingLevel(){\r\n    return getNormalLoggingLevel();\r\n}"
}, {
	"Path": "org.apache.xpath.axes.WalkingIterator.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    m_predicateIndex = -1;\r\n    AxesWalker walker = m_firstWalker;\r\n    while (null != walker) {\r\n        walker.fixupVariables(vars, globalsSize);\r\n        walker = walker.getNextWalker();\r\n    }\r\n}"
}, {
	"Path": "jenkins.model.Nodes.addNode",
	"Comment": "adds a node. if a node of the same name already exists then that node will be replaced.",
	"Method": "void addNode(Node node){\r\n    Node oldNode = nodes.get(node.getNodeName());\r\n    if (node != oldNode) {\r\n        Queue.withLock(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                nodes.put(node.getNodeName(), node);\r\n                jenkins.updateComputerList();\r\n                jenkins.trimLabels();\r\n            }\r\n        });\r\n        try {\r\n            persistNode(node);\r\n        } catch (IOException | RuntimeException e) {\r\n            Queue.withLock(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    nodes.compute(node.getNodeName(), (ignoredNodeName, ignoredNode) -> oldNode);\r\n                    jenkins.updateComputerList();\r\n                    jenkins.trimLabels();\r\n                }\r\n            });\r\n            throw e;\r\n        }\r\n        NodeListener.fireOnCreated(node);\r\n    }\r\n}"
}, {
	"Path": "jenkins.model.Nodes.addNode",
	"Comment": "adds a node. if a node of the same name already exists then that node will be replaced.",
	"Method": "void addNode(Node node){\r\n    nodes.put(node.getNodeName(), node);\r\n    jenkins.updateComputerList();\r\n    jenkins.trimLabels();\r\n}"
}, {
	"Path": "jenkins.model.Nodes.addNode",
	"Comment": "adds a node. if a node of the same name already exists then that node will be replaced.",
	"Method": "void addNode(Node node){\r\n    nodes.compute(node.getNodeName(), (ignoredNodeName, ignoredNode) -> oldNode);\r\n    jenkins.updateComputerList();\r\n    jenkins.trimLabels();\r\n}"
}, {
	"Path": "lib.form.ApplyButtonTest.editDescription",
	"Comment": "editing code mirror should still gets reflected when you click apply.",
	"Method": "void editDescription(){\r\n    j.jenkins.setMarkupFormatter(RawHtmlMarkupFormatter.INSTANCE);\r\n    FreeStyleProject p = j.createFreeStyleProject();\r\n    FreeStyleBuild b = j.assertBuildStatusSuccess(p.scheduleBuild2(0));\r\n    HtmlPage config = j.createWebClient().getPage(b, \"configure\");\r\n    HtmlForm form = config.getFormByName(\"config\");\r\n    config.executeJavaScript(IOUtils.toString(ApplyButtonTest.class.getResource(\"JSON.js\")));\r\n    config.executeJavaScript(\"document.getElementsByTagName('TEXTAREA')[0].codemirrorObject.setLine(0,'foobar')\");\r\n    j.getButtonByCaption(form, \"Apply\").click();\r\n    assertEquals(\"foobar\", b.getDescription());\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.addNodeInDocOrder",
	"Comment": "add the node into a vector of nodes where it should occur indocument order.",
	"Method": "int addNodeInDocOrder(Node node,boolean test,XPathContext support,int addNodeInDocOrder,Node node,XPathContext support){\r\n    if (!m_mutable)\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null));\r\n    return addNodeInDocOrder(node, true, support);\r\n}"
}, {
	"Path": "hudson.cli.CLI.upgrade",
	"Comment": "attempts to lift the security restriction on the underlying channel.this requires the administer privilege on the server.",
	"Method": "void upgrade(){\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    if (execute(Arrays.asList(\"groovy\", \"=\"), new ByteArrayInputStream(\"hudson.remoting.Channel.current().setRestricted(false)\".getBytes()), out, out) != 0)\r\n        throw new SecurityException(out.toString());\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.createIteratorFromSteps",
	"Comment": "create a new walkingiterator from the steps in another walkingiterator.",
	"Method": "WalkingIterator createIteratorFromSteps(WalkingIterator wi,int numSteps){\r\n    WalkingIterator newIter = new WalkingIterator(wi.getPrefixResolver());\r\n    try {\r\n        AxesWalker walker = (AxesWalker) wi.getFirstWalker().clone();\r\n        newIter.setFirstWalker(walker);\r\n        walker.setLocPathIterator(newIter);\r\n        for (int i = 1; i < numSteps; i++) {\r\n            AxesWalker next = (AxesWalker) walker.getNextWalker().clone();\r\n            walker.setNextWalker(next);\r\n            next.setLocPathIterator(newIter);\r\n            walker = next;\r\n        }\r\n        walker.setNextWalker(null);\r\n    } catch (CloneNotSupportedException cnse) {\r\n        throw new WrappedRuntimeException(cnse);\r\n    }\r\n    return newIter;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.getLastPoppedStylesheet",
	"Comment": "return the last stylesheet that was popped off the stylesheets stack.",
	"Method": "Stylesheet getLastPoppedStylesheet(){\r\n    return m_lastPoppedStylesheet;\r\n}"
}, {
	"Path": "hudson.ExtensionList.getLoadLock",
	"Comment": "chooses the object that locks the loading of the extension instances.",
	"Method": "Object getLoadLock(){\r\n    return jenkins.lookup.setIfNull(Lock.class, new Lock());\r\n}"
}, {
	"Path": "org.apache.xml.utils.NodeVector.popAndTop",
	"Comment": "pop a node from the tail of the vector and return thetop of the stack after the pop.",
	"Method": "int popAndTop(){\r\n    m_firstFree--;\r\n    m_map[m_firstFree] = DTM.NULL;\r\n    return (m_firstFree == 0) ? DTM.NULL : m_map[m_firstFree - 1];\r\n}"
}, {
	"Path": "jenkins.AgentProtocolTest.testShouldNotDisableProtocolsForMigratedInstances",
	"Comment": "checks that jenkins does not disable agent protocols by default after the upgrade.",
	"Method": "void testShouldNotDisableProtocolsForMigratedInstances(){\r\n    assertProtocols(true, \"Legacy Non-encrypted JNLP/CLI protocols should be enabled\", \"JNLP-connect\", \"JNLP2-connect\", \"JNLP4-connect\", \"CLI-connect\");\r\n    assertProtocols(true, \"Default encrypted protocols should be enabled\", \"JNLP4-connect\", \"CLI2-connect\");\r\n    assertProtocols(true, \"Protocol should be enabled due to CLI settings\", \"CLI2-connect\");\r\n    assertProtocols(false, \"JNLP3-connect protocol should be disabled by default\", \"JNLP3-connect\");\r\n    assertMonitorTriggered(\"JNLP-connect\", \"JNLP2-connect\", \"CLI-connect\");\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.dom2dtm.DOM2DTM.isSpace",
	"Comment": "returns whether the specified ch conforms to the xml 1.0 definitionof whitespace.refer to the definition of s for details.",
	"Method": "boolean isSpace(char ch){\r\n    return XMLCharacterRecognizer.isWhiteSpace(ch);\r\n}"
}, {
	"Path": "org.apache.xml.utils.NodeVector.removeAllElements",
	"Comment": "inserts the specified node in this vector at the specified index.each component in this vector with an index greater or equal tothe specified index is shifted upward to have an index one greaterthan the value it had previously.",
	"Method": "void removeAllElements(){\r\n    if (null == m_map)\r\n        return;\r\n    for (int i = 0; i < m_firstFree; i++) {\r\n        m_map[i] = DTM.NULL;\r\n    }\r\n    m_firstFree = 0;\r\n}"
}, {
	"Path": "org.apache.xml.utils.ObjectVector.setElementAt",
	"Comment": "sets the component at the specified index of this vector to be thespecified object. the previous component at that position is discarded.the index must be a value greater than or equal to 0 and lessthan the current size of the vector.",
	"Method": "void setElementAt(Object value,int index){\r\n    m_map[index] = value;\r\n}"
}, {
	"Path": "jenkins.model.ExtensionTypeHierarchyTest.sameExtensionCanImplementMultipleExtensionPoints",
	"Comment": "swan is both white and animal, so a single swan instance gets listed to both.",
	"Method": "void sameExtensionCanImplementMultipleExtensionPoints(){\r\n    Animal[] animals = sort(j.jenkins.getExtensionList(Animal.class).toArray(new Animal[2]));\r\n    assertTrue(animals[0] instanceof Crow);\r\n    assertTrue(animals[1] instanceof Swan);\r\n    assertEquals(2, animals.length);\r\n    White[] whites = sort(j.jenkins.getExtensionList(White.class).toArray(new White[1]));\r\n    assertTrue(whites[0] instanceof Swan);\r\n    assertEquals(1, whites.length);\r\n    assertSame(animals[1], whites[0]);\r\n}"
}, {
	"Path": "hudson.util.spring.DefaultRuntimeSpringConfiguration.addAbstractBean",
	"Comment": "adds an abstract bean and returns the beanconfiguration instance",
	"Method": "BeanConfiguration addAbstractBean(String name){\r\n    BeanConfiguration bc = new DefaultBeanConfiguration(name);\r\n    bc.setAbstract(true);\r\n    registerBeanConfiguration(name, bc);\r\n    return bc;\r\n}"
}, {
	"Path": "org.apache.xml.utils.SystemIDResolver.getAbsoluteURI",
	"Comment": "take a systemid string and try to turn it into a good absolute uri.",
	"Method": "String getAbsoluteURI(String systemId,String getAbsoluteURI,String urlString,String base){\r\n    if (base == null)\r\n        return getAbsoluteURI(urlString);\r\n    String absoluteBase = getAbsoluteURI(base);\r\n    URI uri = null;\r\n    try {\r\n        URI baseURI = new URI(absoluteBase);\r\n        uri = new URI(baseURI, urlString);\r\n    } catch (MalformedURIException mue) {\r\n        throw new TransformerException(mue);\r\n    }\r\n    return replaceChars(uri.toString());\r\n}"
}, {
	"Path": "com.sun.jna.platform.dnd.DropHandler.isSupported",
	"Comment": "return whether any of the flavors in the given list are accepted. the list is compared against the accepted list provided in theconstructor.",
	"Method": "boolean isSupported(DataFlavor[] flavors){\r\n    Set<DataFlavor> set = new HashSet<DataFlavor>(Arrays.asList(flavors));\r\n    set.retainAll(acceptedFlavors);\r\n    return !set.isEmpty();\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetRoot.recomposeOutput",
	"Comment": "recompose the output format object from the included elements.",
	"Method": "void recomposeOutput(OutputProperties oprops){\r\n    m_outputProperties.copyFrom(oprops);\r\n}"
}, {
	"Path": "hudson.org.apache.tools.tar.TarInputStream.getNextEntry",
	"Comment": "get the next entry in this tar archive. this will skipover any remaining data in the current entry, if thereis one, and place the input stream at the header of thenext entry, and read the header and instantiate a newtarentry from the header bytes and return that entry.if there are no more entries in the archive, null willbe returned to indicate that the end of the archive hasbeen reached.",
	"Method": "TarEntry getNextEntry(){\r\n    if (this.hasHitEOF) {\r\n        return null;\r\n    }\r\n    if (this.currEntry != null) {\r\n        long numToSkip = this.entrySize - this.entryOffset;\r\n        if (this.debug) {\r\n            System.err.println(\"TarInputStream: SKIP currENTRY '\" + this.currEntry.getName() + \"' SZ \" + this.entrySize + \" OFF \" + this.entryOffset + \"  skipping \" + numToSkip + \" bytes\");\r\n        }\r\n        if (numToSkip > 0) {\r\n            this.skip(numToSkip);\r\n        }\r\n        this.readBuf = null;\r\n    }\r\n    byte[] headerBuf = this.buffer.readRecord();\r\n    if (headerBuf == null) {\r\n        if (this.debug) {\r\n            System.err.println(\"READ NULL RECORD\");\r\n        }\r\n        this.hasHitEOF = true;\r\n    } else if (this.buffer.isEOFRecord(headerBuf)) {\r\n        if (this.debug) {\r\n            System.err.println(\"READ EOF RECORD\");\r\n        }\r\n        this.hasHitEOF = true;\r\n    }\r\n    if (this.hasHitEOF) {\r\n        this.currEntry = null;\r\n    } else {\r\n        this.currEntry = new TarEntry(headerBuf);\r\n        if (this.debug) {\r\n            System.err.println(\"TarInputStream: SET currENTRY '\" + this.currEntry.getName() + \"' size = \" + this.currEntry.getSize());\r\n        }\r\n        this.entryOffset = 0;\r\n        this.entrySize = this.currEntry.getSize();\r\n    }\r\n    if (this.currEntry != null && this.currEntry.isGNULongNameEntry()) {\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n        byte[] buf = new byte[256];\r\n        int length;\r\n        while ((length = read(buf)) >= 0) {\r\n            baos.write(buf, 0, length);\r\n        }\r\n        getNextEntry();\r\n        if (this.currEntry == null) {\r\n            return null;\r\n        }\r\n        String longName = baos.toString(\"UTF-8\");\r\n        if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\r\n            longName = longName.substring(0, longName.length() - 1);\r\n        }\r\n        this.currEntry.setName(longName);\r\n    }\r\n    return this.currEntry;\r\n}"
}, {
	"Path": "jenkins.model.lazy.AbstractLazyLoadRunMap.purgeCache",
	"Comment": "let go of all the loaded references.this is a bit more sophisticated version of forcing gc.primarily for debugging and testing lazy loading behaviour.",
	"Method": "void purgeCache(){\r\n    index = new Index();\r\n    fullyLoaded = false;\r\n    loadNumberOnDisk();\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetRoot.newTransformer",
	"Comment": "create a new transformation context for this templates object.",
	"Method": "Transformer newTransformer(){\r\n    return new TransformerImpl(this);\r\n}"
}, {
	"Path": "hudson.util.StackedAreaRenderer2.generateURL",
	"Comment": "override this method to specify the hyperlink target of the given data point.",
	"Method": "String generateURL(CategoryDataset dataset,int row,int column){\r\n    return null;\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.rebuildDependencyGraphAsync",
	"Comment": "rebuilds the dependency map asynchronously.this would keep the ui thread more responsive and helps avoid the deadlocks,as dependency graph recomputation tends to touch a lot of other things.",
	"Method": "Future<DependencyGraph> rebuildDependencyGraphAsync(){\r\n    dependencyGraphDirty.set(true);\r\n    return Timer.get().schedule(new java.util.concurrent.Callable<DependencyGraph>() {\r\n        @Override\r\n        public DependencyGraph call() throws Exception {\r\n            if (dependencyGraphDirty.get()) {\r\n                rebuildDependencyGraph();\r\n            }\r\n            return dependencyGraph;\r\n        }\r\n    }, 500, TimeUnit.MILLISECONDS);\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.rebuildDependencyGraphAsync",
	"Comment": "rebuilds the dependency map asynchronously.this would keep the ui thread more responsive and helps avoid the deadlocks,as dependency graph recomputation tends to touch a lot of other things.",
	"Method": "Future<DependencyGraph> rebuildDependencyGraphAsync(){\r\n    if (dependencyGraphDirty.get()) {\r\n        rebuildDependencyGraph();\r\n    }\r\n    return dependencyGraph;\r\n}"
}, {
	"Path": "org.apache.xalan.extensions.ExtensionNamespaceSupport.launch",
	"Comment": "launch the extensionhandler that this extensionnamespacesupport object defines.",
	"Method": "ExtensionHandler launch(){\r\n    ExtensionHandler handler = null;\r\n    try {\r\n        Class cl = ExtensionHandler.getClassForName(m_handlerClass);\r\n        Constructor con = null;\r\n        if (m_sig != null)\r\n            con = cl.getConstructor(m_sig);\r\n        else {\r\n            Constructor[] cons = cl.getConstructors();\r\n            for (int i = 0; i < cons.length; i++) {\r\n                if (cons[i].getParameterTypes().length == m_args.length) {\r\n                    con = cons[i];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (con != null)\r\n            handler = (ExtensionHandler) con.newInstance(m_args);\r\n        else\r\n            throw new TransformerException(\"ExtensionHandler constructor not found\");\r\n    } catch (Exception e) {\r\n        throw new TransformerException(e);\r\n    }\r\n    return handler;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.subPartMatch",
	"Comment": "tell if two strings are equal, without worry if the first string is null.",
	"Method": "boolean subPartMatch(String p,String t){\r\n    return (p == t) || ((null != p) && (p.equals(t)));\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XRTreeFrag.detach",
	"Comment": "detaches the dtmiterator from the set which it iteratedover, releasing any computational resources and placing the iteratorin the invalid state. after detach has been invoked,calls to nextnode or previousnode willraise a runtime exception.in general, detach should only be called once on the object.",
	"Method": "void detach(){\r\n    if (m_allowRelease) {\r\n        m_DTMXRTreeFrag.destruct();\r\n        setObject(null);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.peepTail",
	"Comment": "return the node at the tail of the vector without poppingspecial purpose method for transformerimpl, pushelemtemplateelement.performance critical.",
	"Method": "Node peepTail(){\r\n    return m_map[m_firstFree - 1];\r\n}"
}, {
	"Path": "hudson.util.AtomicFileWriter.getTemporaryPath",
	"Comment": "until the data is committed, this file capturesthe written content.",
	"Method": "Path getTemporaryPath(){\r\n    return tmpPath;\r\n}"
}, {
	"Path": "jenkins.install.SetupWizard.getPlatformPluginUpdates",
	"Comment": "provides the list of platform plugin updates from the last timethe upgrade was run.",
	"Method": "JSONArray getPlatformPluginUpdates(){\r\n    final VersionNumber version = getCurrentLevel();\r\n    if (version == null) {\r\n        return null;\r\n    }\r\n    return getPlatformPluginsForUpdate(version, Jenkins.getVersion());\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncExtFunction.reportWrongNumberArgs",
	"Comment": "constructs and throws a wrongnumberargexception with the appropriatemessage for this function object.this class supports an arbitrarynumber of arguments, so this method must never be called.",
	"Method": "void reportWrongNumberArgs(){\r\n    String fMsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION, new Object[] { \"Programmer's assertion:  the method FunctionMultiArgs.reportWrongNumberArgs() should never be called.\" });\r\n    throw new RuntimeException(fMsg);\r\n}"
}, {
	"Path": "org.apache.xml.utils.BoolStack.peekOrTrue",
	"Comment": "looks at the object at the top of this stack without removing itfrom the stack.if the stack is empty, it returns true.",
	"Method": "boolean peekOrTrue(){\r\n    return (m_index > -1) ? m_values[m_index] : true;\r\n}"
}, {
	"Path": "jadx.core.xmlgen.XMLChar.isValidJavaEncoding",
	"Comment": "returns true if the encoding name is a valid java encoding.\tthis method does not verify that there is a decoder available\tfor this encoding, only that the characters are valid for an\tjava encoding name.",
	"Method": "boolean isValidJavaEncoding(String javaEncoding){\r\n    if (javaEncoding != null) {\r\n        int length = javaEncoding.length();\r\n        if (length > 0) {\r\n            for (int i = 1; i < length; i++) {\r\n                char c = javaEncoding.charAt(i);\r\n                if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') && (c < '0' || c > '9') && c != '.' && c != '_' && c != '-') {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.getNextAttribute",
	"Comment": "given a node handle, advance to the next attribute.if an attr, we advance tothe next attr on the same node.if not an attribute, we return null.",
	"Method": "int getNextAttribute(int nodeHandle){\r\n    int nodeID = makeNodeIdentity(nodeHandle);\r\n    if (_type(nodeID) == DTM.ATTRIBUTE_NODE) {\r\n        return makeNodeHandle(getNextAttributeIdentity(nodeID));\r\n    }\r\n    return DTM.NULL;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemForEach.transformSelectedNodes",
	"Comment": "perform a query if needed, and call transformnode for each child.",
	"Method": "void transformSelectedNodes(TransformerImpl transformer){\r\n    final XPathContext xctxt = transformer.getXPathContext();\r\n    final int sourceNode = xctxt.getCurrentNode();\r\n    DTMIterator sourceNodes = m_selectExpression.asIterator(xctxt, sourceNode);\r\n    try {\r\n        final Vector keys = (m_sortElems == null) ? null : transformer.processSortKeys(this, sourceNode);\r\n        if (null != keys)\r\n            sourceNodes = sortNodes(xctxt, keys, sourceNodes);\r\n        xctxt.pushCurrentNode(DTM.NULL);\r\n        IntStack currentNodes = xctxt.getCurrentNodeStack();\r\n        xctxt.pushCurrentExpressionNode(DTM.NULL);\r\n        IntStack currentExpressionNodes = xctxt.getCurrentExpressionNodeStack();\r\n        xctxt.pushSAXLocatorNull();\r\n        xctxt.pushContextNodeList(sourceNodes);\r\n        transformer.pushElemTemplateElement(null);\r\n        DTM dtm = xctxt.getDTM(sourceNode);\r\n        int docID = sourceNode & DTMManager.IDENT_DTM_DEFAULT;\r\n        int child;\r\n        while (DTM.NULL != (child = sourceNodes.nextNode())) {\r\n            currentNodes.setTop(child);\r\n            currentExpressionNodes.setTop(child);\r\n            if ((child & DTMManager.IDENT_DTM_DEFAULT) != docID) {\r\n                dtm = xctxt.getDTM(child);\r\n                docID = child & DTMManager.IDENT_DTM_DEFAULT;\r\n            }\r\n            final int nodeType = dtm.getNodeType(child);\r\n            for (ElemTemplateElement t = this.m_firstChild; t != null; t = t.m_nextSibling) {\r\n                xctxt.setSAXLocator(t);\r\n                transformer.setCurrentElement(t);\r\n                t.execute(transformer);\r\n            }\r\n            if (m_doc_cache_off) {\r\n                if (DEBUG)\r\n                    System.out.println(\"JJK***** CACHE RELEASE *****\\n\" + \"\\tdtm=\" + dtm.getDocumentBaseURI());\r\n                xctxt.getSourceTreeManager().removeDocumentFromCache(dtm.getDocument());\r\n                xctxt.release(dtm, false);\r\n            }\r\n        }\r\n    } finally {\r\n        xctxt.popSAXLocator();\r\n        xctxt.popContextNodeList();\r\n        transformer.popElemTemplateElement();\r\n        xctxt.popCurrentExpressionNode();\r\n        xctxt.popCurrentNode();\r\n        sourceNodes.detach();\r\n    }\r\n}"
}, {
	"Path": "jenkins.security.apitoken.ApiTokenStore.isLegacyToken",
	"Comment": "determine if the given token was generated by the legacy system or the new one",
	"Method": "boolean isLegacyToken(String token){\r\n    return token.length() != TOKEN_LENGTH_V2;\r\n}"
}, {
	"Path": "hudson.model.TopLevelItemDescriptor.getDescription",
	"Comment": "a description of this kind of item type. this description can contain html code but it is recommended thatyou use plain text in order to be consistent with the rest of jenkins.this method should be called from a thread where stapler is handling an http request, otherwise it willreturn an empty string.",
	"Method": "String getDescription(){\r\n    Stapler stapler = Stapler.getCurrent();\r\n    if (stapler != null) {\r\n        try {\r\n            WebApp webapp = WebApp.getCurrent();\r\n            MetaClass meta = webapp.getMetaClass(this);\r\n            Script s = meta.loadTearOff(JellyClassTearOff.class).findScript(\"newInstanceDetail\");\r\n            if (s == null) {\r\n                return \"\";\r\n            }\r\n            DefaultScriptInvoker dsi = new DefaultScriptInvoker();\r\n            StringWriter sw = new StringWriter();\r\n            XMLOutput xml = dsi.createXMLOutput(sw, true);\r\n            dsi.invokeScript(Stapler.getCurrentRequest(), Stapler.getCurrentResponse(), s, this, xml);\r\n            return sw.toString();\r\n        } catch (Exception e) {\r\n            LOGGER.log(Level.WARNING, null, e);\r\n            return \"\";\r\n        }\r\n    } else {\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.getErrorListener",
	"Comment": "get the errorlistener where errors and warnings are to be reported.",
	"Method": "ErrorListener getErrorListener(ErrorListener getErrorListener){\r\n    if (null != m_errorListener)\r\n        return m_errorListener;\r\n    ErrorListener retval = null;\r\n    try {\r\n        if (null != m_ownerGetErrorListener)\r\n            retval = (ErrorListener) m_ownerGetErrorListener.invoke(m_owner, new Object[] {});\r\n    } catch (Exception e) {\r\n    }\r\n    if (null == retval) {\r\n        if (null == m_defaultErrorListener)\r\n            m_defaultErrorListener = new org.apache.xml.utils.DefaultErrorHandler();\r\n        retval = m_defaultErrorListener;\r\n    }\r\n    return retval;\r\n}"
}, {
	"Path": "jadx.core.utils.BlockUtils.isEmptySimplePath",
	"Comment": "return true if on path from start to end no instructions and no branches.",
	"Method": "boolean isEmptySimplePath(BlockNode start,BlockNode end){\r\n    if (start == end && start.getInstructions().isEmpty()) {\r\n        return true;\r\n    }\r\n    if (!start.getInstructions().isEmpty() || start.getCleanSuccessors().size() != 1) {\r\n        return false;\r\n    }\r\n    BlockNode block = getNextBlock(start);\r\n    while (block != null && block != end && block.getCleanSuccessors().size() < 2 && block.getPredecessors().size() == 1 && block.getInstructions().isEmpty()) {\r\n        block = getNextBlock(block);\r\n    }\r\n    return block == end;\r\n}"
}, {
	"Path": "com.iluwatar.eip.wiretap.routes.WireTapRouteTest.testWireTap",
	"Comment": "test if both endpoints receive exactly one message containing the same, unchanged body.",
	"Method": "void testWireTap(){\r\n    entry.sendBody(\"TEST\");\r\n    endpoint.expectedMessageCount(1);\r\n    wireTapEndpoint.expectedMessageCount(1);\r\n    endpoint.assertIsSatisfied();\r\n    wireTapEndpoint.assertIsSatisfied();\r\n    Message endpointIn = endpoint.getExchanges().get(0).getIn();\r\n    Message wireTapEndpointIn = wireTapEndpoint.getExchanges().get(0).getIn();\r\n    assertEquals(\"TEST\", endpointIn.getBody());\r\n    assertEquals(\"TEST\", wireTapEndpointIn.getBody());\r\n}"
}, {
	"Path": "hudson.EnvVars.createCookie",
	"Comment": "creates a magic cookie that can be used as the model environment variablewhen we later kill the processes.",
	"Method": "EnvVars createCookie(){\r\n    return new EnvVars(\"HUDSON_COOKIE\", UUID.randomUUID().toString());\r\n}"
}, {
	"Path": "hudson.util.JVMBuilder.pwd",
	"Comment": "sets the current directory for the new jvm.this overloaded version only makes sense when you are launching jvm locally.",
	"Method": "JVMBuilder pwd(FilePath pwd,JVMBuilder pwd,File pwd){\r\n    return pwd(new FilePath(pwd));\r\n}"
}, {
	"Path": "redis.clients.jedis.Jedis.sort",
	"Comment": "sort a set or a list and store the result at dstkey.sort the elements contained in the list, set, or sorted set value at key and store the resultat dstkey. by default sorting is numeric with elements being compared as double precisionfloating point numbers. this is the simplest form of sort.",
	"Method": "List<String> sort(String key,List<String> sort,String key,SortingParams sortingParameters,Long sort,String key,SortingParams sortingParameters,String dstkey,Long sort,String key,String dstkey){\r\n    checkIsInMultiOrPipeline();\r\n    client.sort(key, dstkey);\r\n    return client.getIntegerReply();\r\n}"
}, {
	"Path": "hudson.model.Queue.cancel",
	"Comment": "cancels the item in the queue. if the item is scheduled more than once, cancels the first occurrence.",
	"Method": "boolean cancel(Task p,boolean cancel,Item item,boolean cancel,Queue q,T cancel,Task p){\r\n    LOGGER.log(Level.FINE, \"Cancelling {0} item#{1}\", new Object[] { item.task, item.id });\r\n    lock.lock();\r\n    try {\r\n        try {\r\n            return item.cancel(this);\r\n        } finally {\r\n            updateSnapshot();\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprIterator.callPredicateVisitors",
	"Comment": "this will traverse the heararchy, calling the visitor for each member.if the called visitor method returns false, the subtree should not be called.",
	"Method": "void callPredicateVisitors(XPathVisitor visitor){\r\n    m_expr.callVisitors(new filterExprOwner(), visitor);\r\n    super.callPredicateVisitors(visitor);\r\n}"
}, {
	"Path": "hudson.FilePath.deleteContents",
	"Comment": "deletes all the contents of this directory, but not the directory itself",
	"Method": "void deleteContents(){\r\n    act(new DeleteContents());\r\n}"
}, {
	"Path": "hudson.model.FileParameterValue.getLocationUnderBuild",
	"Comment": "get the location under the build directory to store the file parameter.",
	"Method": "File getLocationUnderBuild(AbstractBuild build){\r\n    return new File(getFileParameterFolderUnderBuild(build), location);\r\n}"
}, {
	"Path": "hudson.model.Fingerprint.getXStream",
	"Comment": "provides the xstream instance this class is using for serialization.",
	"Method": "XStream2 getXStream(){\r\n    return XSTREAM;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprIterator.detach",
	"Comment": "detaches the walker from the set which it iterated over, releasingany computational resources and placing the iterator in the invalidstate.",
	"Method": "void detach(){\r\n    super.detach();\r\n    m_exprObj.detach();\r\n    m_exprObj = null;\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.pushNamespaceContextNull",
	"Comment": "just increment the namespace contest stack, so that setnamespacecontextcan be used on the slot.",
	"Method": "void pushNamespaceContextNull(){\r\n    m_prefixResolvers.push(null);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.ProcessorKey.setPropertiesFromAttributes",
	"Comment": "set the properties of an object from the given attribute list.",
	"Method": "void setPropertiesFromAttributes(StylesheetHandler handler,String rawName,Attributes attributes,org.apache.xalan.templates.ElemTemplateElement target){\r\n    XSLTElementDef def = getElemDef();\r\n    List processedDefs = new ArrayList();\r\n    int nAttrs = attributes.getLength();\r\n    for (int i = 0; i < nAttrs; i++) {\r\n        String attrUri = attributes.getURI(i);\r\n        String attrLocalName = attributes.getLocalName(i);\r\n        XSLTAttributeDef attrDef = def.getAttributeDef(attrUri, attrLocalName);\r\n        if (null == attrDef) {\r\n            handler.error(attributes.getQName(i) + \"attribute is not allowed on the \" + rawName + \" element!\", null);\r\n        } else {\r\n            String valueString = attributes.getValue(i);\r\n            if (valueString.indexOf(org.apache.xpath.compiler.Keywords.FUNC_KEY_STRING + \"(\") >= 0)\r\n                handler.error(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_KEY_CALL, null), null);\r\n            processedDefs.add(attrDef);\r\n            attrDef.setAttrValue(handler, attrUri, attrLocalName, attributes.getQName(i), attributes.getValue(i), target);\r\n        }\r\n    }\r\n    XSLTAttributeDef[] attrDefs = def.getAttributes();\r\n    int nAttrDefs = attrDefs.length;\r\n    for (int i = 0; i < nAttrDefs; i++) {\r\n        XSLTAttributeDef attrDef = attrDefs[i];\r\n        String defVal = attrDef.getDefault();\r\n        if (null != defVal) {\r\n            if (!processedDefs.contains(attrDef)) {\r\n                attrDef.setDefAttrValue(handler, target);\r\n            }\r\n        }\r\n        if (attrDef.getRequired()) {\r\n            if (!processedDefs.contains(attrDef))\r\n                handler.error(XSLMessages.createMessage(XSLTErrorResources.ER_REQUIRES_ATTRIB, new Object[] { rawName, attrDef.getName() }), null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.XML11Char.isXML11Content",
	"Comment": "returns true if the specified character can be considered content in an external parsed entity.",
	"Method": "boolean isXML11Content(int c){\r\n    return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_CONTENT) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "hudson.util.io.TarArchiverTest.permission",
	"Comment": "makes sure that permissions are properly stored in the tar file.",
	"Method": "void permission(){\r\n    assumeTrue(!Functions.isWindows());\r\n    File tar = File.createTempFile(\"test\", \"tar\");\r\n    File zip = File.createTempFile(\"test\", \"zip\");\r\n    FilePath dir = new FilePath(File.createTempFile(\"test\", \"dir\"));\r\n    try {\r\n        dir.delete();\r\n        dir.child(\"subdir\").mkdirs();\r\n        FilePath f = dir.child(\"a.txt\");\r\n        f.touch(0);\r\n        f.chmod(0755);\r\n        f = dir.child(\"subdir/b.txt\");\r\n        f.touch(0);\r\n        f.chmod(0644);\r\n        int dirMode = dir.child(\"subdir\").mode();\r\n        dir.tar(Files.newOutputStream(tar.toPath()), \"**/*\");\r\n        dir.zip(Files.newOutputStream(zip.toPath()));\r\n        FilePath e = dir.child(\"extract\");\r\n        e.mkdirs();\r\n        run(e, \"tar\", \"xvpf\", tar.getAbsolutePath());\r\n        assertEquals(0755, e.child(\"a.txt\").mode());\r\n        assertEquals(dirMode, e.child(\"subdir\").mode());\r\n        assertEquals(0644, e.child(\"subdir/b.txt\").mode());\r\n        e.deleteContents();\r\n        run(e, \"unzip\", zip.getAbsolutePath());\r\n        e = e.listDirectories().get(0);\r\n        assertEquals(0755, e.child(\"a.txt\").mode());\r\n        assertEquals(dirMode, e.child(\"subdir\").mode());\r\n        assertEquals(0644, e.child(\"subdir/b.txt\").mode());\r\n    } finally {\r\n        tar.delete();\r\n        zip.delete();\r\n        dir.deleteRecursive();\r\n    }\r\n}"
}, {
	"Path": "hudson.scm.SCM._for",
	"Comment": "determines which kinds of scms are applicable to a given project.",
	"Method": "List<SCMDescriptor<?>> _for(Job project,List<SCMDescriptor<?>> _for,AbstractProject project){\r\n    return _for((Job) project);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.getProcessorFor",
	"Comment": "given a namespace uri, and a local name or a node type, get the processorfor the element, or return null if not allowed.",
	"Method": "XSLTElementProcessor getProcessorFor(String uri,String localName,String rawName){\r\n    XSLTElementProcessor currentProcessor = getCurrentProcessor();\r\n    XSLTElementDef def = currentProcessor.getElemDef();\r\n    XSLTElementProcessor elemProcessor = def.getProcessorFor(uri, localName);\r\n    if (null == elemProcessor && !(currentProcessor instanceof ProcessorStylesheetDoc) && ((null == getStylesheet() || Double.valueOf(getStylesheet().getVersion()).doubleValue() > Constants.XSLTVERSUPPORTED) || (!uri.equals(Constants.S_XSLNAMESPACEURL) && currentProcessor instanceof ProcessorStylesheetElement) || getElemVersion() > Constants.XSLTVERSUPPORTED)) {\r\n        elemProcessor = def.getProcessorForUnknown(uri, localName);\r\n    }\r\n    if (null == elemProcessor)\r\n        error(XSLMessages.createMessage(XSLTErrorResources.ER_NOT_ALLOWED_IN_POSITION, new Object[] { rawName }), null);\r\n    return elemProcessor;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.CharInfo.setASCIItextDirty",
	"Comment": "if the character is in the ascii range thenmark it as needing replacement witha string on output if it occurs in a text node.",
	"Method": "void setASCIItextDirty(int j){\r\n    if (0 <= j && j < ASCII_MAX) {\r\n        shouldMapTextChar_ASCII[j] = true;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.XPathParser.insertOp",
	"Comment": "insert room for operation.this will not setthe length value of the operation, but will updatethe length value for the total expression.",
	"Method": "void insertOp(int pos,int length,int op){\r\n    int totalLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH);\r\n    for (int i = totalLen - 1; i >= pos; i--) {\r\n        m_ops.setOp(i + length, m_ops.getOp(i));\r\n    }\r\n    m_ops.setOp(pos, op);\r\n    m_ops.setOp(OpMap.MAPINDEX_LENGTH, totalLen + length);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.Messages.getResourceSuffix",
	"Comment": "return the resource file suffic for the indicated localefor most locales, this will be based the language code.howeverfor chinese, we do distinguish between taiwan and prc",
	"Method": "String getResourceSuffix(Locale locale){\r\n    String suffix = \"_\" + locale.getLanguage();\r\n    String country = locale.getCountry();\r\n    if (country.equals(\"TW\"))\r\n        suffix += \"_\" + country;\r\n    return suffix;\r\n}"
}, {
	"Path": "org.java_websocket.client.WebSocketClient.reconnectBlocking",
	"Comment": "same as reconnect but blocks until the websocket reconnected or failed to do so.",
	"Method": "boolean reconnectBlocking(){\r\n    reset();\r\n    return connectBlocking();\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncTrue.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    return XBoolean.S_TRUE;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToHTMLStream.addUniqueAttribute",
	"Comment": "this method is used to add an attribute to the currently open element. the caller has guaranted that this attribute is unique, which means that itnot been seen before and will not be seen again.",
	"Method": "void addUniqueAttribute(String name,String value,int flags){\r\n    try {\r\n        final java.io.Writer writer = m_writer;\r\n        if ((flags & NO_BAD_CHARS) > 0 && m_htmlcharInfo.onlyQuotAmpLtGt) {\r\n            writer.write(' ');\r\n            writer.write(name);\r\n            writer.write(\"=\\\"\");\r\n            writer.write(value);\r\n            writer.write('\"');\r\n        } else if ((flags & HTML_ATTREMPTY) > 0 && (value.length() == 0 || value.equalsIgnoreCase(name))) {\r\n            writer.write(' ');\r\n            writer.write(name);\r\n        } else {\r\n            writer.write(' ');\r\n            writer.write(name);\r\n            writer.write(\"=\\\"\");\r\n            if ((flags & HTML_ATTRURL) > 0) {\r\n                writeAttrURI(writer, value, m_specialEscapeURLs);\r\n            } else {\r\n                writeAttrString(writer, value, this.getEncoding());\r\n            }\r\n            writer.write('\"');\r\n        }\r\n    } catch (IOException e) {\r\n        throw new SAXException(e);\r\n    }\r\n}"
}, {
	"Path": "hudson.model.FreestyleJobPublisherTest.testFreestyleWithExceptionPublisher",
	"Comment": "execute all publishers even one of them throws abortexception.",
	"Method": "void testFreestyleWithExceptionPublisher(){\r\n    FreeStyleProject p = j.createFreeStyleProject();\r\n    p.getPublishersList().add(new TrueFalsePublisher(true));\r\n    p.getPublishersList().add(new AbortExceptionPublisher());\r\n    p.getPublishersList().add(new ResultWriterPublisher(\"result.txt\"));\r\n    final ArtifactArchiver artifactArchiver = new ArtifactArchiver(\"result.txt\");\r\n    artifactArchiver.setOnlyIfSuccessful(false);\r\n    p.getPublishersList().add(artifactArchiver);\r\n    FreeStyleBuild b = p.scheduleBuild2(0).get();\r\n    assertEquals(\"Build must fail, because we used AbortExceptionPublisher\", b.getResult(), Result.FAILURE);\r\n    j.assertLogNotContains(\"\\tat\", b);\r\n    j.assertLogContains(\"Threw AbortException from publisher!\", b);\r\n    File file = new File(b.getArtifactsDir(), \"result.txt\");\r\n    assertTrue(\"ArtifactArchiver is executed even prior publisher fails\", file.exists());\r\n    assertTrue(\"Third publisher must see FAILURE status\", FileUtils.readFileToString(file).equals(Result.FAILURE.toString()));\r\n}"
}, {
	"Path": "org.apache.xml.utils.QName.getNamespaceURI",
	"Comment": "returns the namespace uri. returns null if the namespace uriis not known.",
	"Method": "String getNamespaceURI(){\r\n    return _namespaceURI;\r\n}"
}, {
	"Path": "hudson.model.QueueTest.resetQueueState",
	"Comment": "forces a reset of the private queue counter.could make changes to queue to make that easier, but decided against that.",
	"Method": "void resetQueueState(){\r\n    File queueFile = r.jenkins.getQueue().getXMLQueueFile();\r\n    XmlFile xmlFile = new XmlFile(Queue.XSTREAM, queueFile);\r\n    xmlFile.write(new Queue.State());\r\n    r.jenkins.getQueue().load();\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncExtFunction.getArgCount",
	"Comment": "return the number of arguments that were passedinto this extension function.",
	"Method": "int getArgCount(){\r\n    return m_argVec.size();\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncBoolean.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    return m_arg0.execute(xctxt).bool() ? XBoolean.S_TRUE : XBoolean.S_FALSE;\r\n}"
}, {
	"Path": "org.apache.xml.utils.SuballocatedIntVector.insertElementAt",
	"Comment": "inserts the specified node in this vector at the specified index.each component in this vector with an index greater or equal tothe specified index is shifted upward to have an index one greaterthan the value it had previously.insertion may be an expensive operation!",
	"Method": "void insertElementAt(int value,int at){\r\n    if (at == m_firstFree)\r\n        addElement(value);\r\n    else if (at > m_firstFree) {\r\n        int index = at >>> m_SHIFT;\r\n        if (index >= m_map.length) {\r\n            int newsize = index + m_numblocks;\r\n            int[][] newMap = new int[newsize][];\r\n            System.arraycopy(m_map, 0, newMap, 0, m_map.length);\r\n            m_map = newMap;\r\n        }\r\n        int[] block = m_map[index];\r\n        if (null == block)\r\n            block = m_map[index] = new int[m_blocksize];\r\n        int offset = at & m_MASK;\r\n        block[offset] = value;\r\n        m_firstFree = offset + 1;\r\n    } else {\r\n        int index = at >>> m_SHIFT;\r\n        int maxindex = m_firstFree >>> m_SHIFT;\r\n        ++m_firstFree;\r\n        int offset = at & m_MASK;\r\n        int push;\r\n        while (index <= maxindex) {\r\n            int copylen = m_blocksize - offset - 1;\r\n            int[] block = m_map[index];\r\n            if (null == block) {\r\n                push = 0;\r\n                block = m_map[index] = new int[m_blocksize];\r\n            } else {\r\n                push = block[m_blocksize - 1];\r\n                System.arraycopy(block, offset, block, offset + 1, copylen);\r\n            }\r\n            block[offset] = value;\r\n            value = push;\r\n            offset = 0;\r\n            ++index;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.throttling.timer.ThrottleTimerImpl.start",
	"Comment": "a timer is initiated with this method. the timer runs every second and resets thecounter.",
	"Method": "void start(){\r\n    new Timer(true).schedule(new TimerTask() {\r\n        @Override\r\n        public void run() {\r\n            callsCount.reset();\r\n        }\r\n    }, 0, throttlePeriod);\r\n}"
}, {
	"Path": "com.iluwatar.throttling.timer.ThrottleTimerImpl.start",
	"Comment": "a timer is initiated with this method. the timer runs every second and resets thecounter.",
	"Method": "void start(){\r\n    callsCount.reset();\r\n}"
}, {
	"Path": "org.apache.xpath.Expression.getPublicId",
	"Comment": "return the public identifier for the current document event.the return value is the public identifier of the documententity or of the external parsed entity in which the markup thattriggered the event appears.",
	"Method": "String getPublicId(){\r\n    if (null == m_parent)\r\n        return null;\r\n    return m_parent.getPublicId();\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.LSSerializerImpl.writeToURI",
	"Comment": "serializes the specified node to the specified uri and returns true if the node was successfully serialized.",
	"Method": "boolean writeToURI(Node nodeArg,String uri){\r\n    if (nodeArg == null) {\r\n        return false;\r\n    }\r\n    Serializer serializer = fXMLSerializer;\r\n    serializer.reset();\r\n    if (nodeArg != fVisitedNode) {\r\n        String xmlVersion = getXMLVersion(nodeArg);\r\n        fEncoding = getInputEncoding(nodeArg);\r\n        if (fEncoding == null) {\r\n            fEncoding = fEncoding != null ? fEncoding : getXMLEncoding(nodeArg) == null ? \"UTF-8\" : getXMLEncoding(nodeArg);\r\n        }\r\n        serializer.getOutputFormat().setProperty(\"version\", xmlVersion);\r\n        fDOMConfigProperties.setProperty(DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.S_XML_VERSION, xmlVersion);\r\n        fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_ENCODING, fEncoding);\r\n        if ((nodeArg.getNodeType() != Node.DOCUMENT_NODE || nodeArg.getNodeType() != Node.ELEMENT_NODE || nodeArg.getNodeType() != Node.ENTITY_NODE) && ((fFeatures & XMLDECL) != 0)) {\r\n            fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL, DOMConstants.DOM3_DEFAULT_FALSE);\r\n        }\r\n        fVisitedNode = nodeArg;\r\n    }\r\n    fXMLSerializer.setOutputFormat(fDOMConfigProperties);\r\n    try {\r\n        if (uri == null) {\r\n            String msg = Utils.messages.createMessage(MsgKey.ER_NO_OUTPUT_SPECIFIED, null);\r\n            if (fDOMErrorHandler != null) {\r\n                fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, msg, MsgKey.ER_NO_OUTPUT_SPECIFIED));\r\n            }\r\n            throw new LSException(LSException.SERIALIZE_ERR, msg);\r\n        } else {\r\n            String absoluteURI = SystemIDResolver.getAbsoluteURI(uri);\r\n            URL url = new URL(absoluteURI);\r\n            OutputStream urlOutStream = null;\r\n            String protocol = url.getProtocol();\r\n            String host = url.getHost();\r\n            if (protocol.equalsIgnoreCase(\"file\") && (host == null || host.length() == 0 || host.equals(\"localhost\"))) {\r\n                urlOutStream = new FileOutputStream(getPathWithoutEscapes(url.getPath()));\r\n            } else {\r\n                URLConnection urlCon = url.openConnection();\r\n                urlCon.setDoInput(false);\r\n                urlCon.setDoOutput(true);\r\n                urlCon.setUseCaches(false);\r\n                urlCon.setAllowUserInteraction(false);\r\n                if (urlCon instanceof HttpURLConnection) {\r\n                    HttpURLConnection httpCon = (HttpURLConnection) urlCon;\r\n                    httpCon.setRequestMethod(\"PUT\");\r\n                }\r\n                urlOutStream = urlCon.getOutputStream();\r\n            }\r\n            serializer.setOutputStream(urlOutStream);\r\n        }\r\n        if (fDOMSerializer == null) {\r\n            fDOMSerializer = (DOM3Serializer) serializer.asDOM3Serializer();\r\n        }\r\n        if (fDOMErrorHandler != null) {\r\n            fDOMSerializer.setErrorHandler(fDOMErrorHandler);\r\n        }\r\n        if (fSerializerFilter != null) {\r\n            fDOMSerializer.setNodeFilter(fSerializerFilter);\r\n        }\r\n        fDOMSerializer.setNewLine(fEndOfLine.toCharArray());\r\n        fDOMSerializer.serializeDOM3(nodeArg);\r\n    } catch (LSException lse) {\r\n        throw lse;\r\n    } catch (RuntimeException e) {\r\n        throw (LSException) createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();\r\n    } catch (Exception e) {\r\n        if (fDOMErrorHandler != null) {\r\n            fDOMErrorHandler.handleError(new DOMErrorImpl(DOMError.SEVERITY_FATAL_ERROR, e.getMessage(), null, e));\r\n        }\r\n        throw (LSException) createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.UnionPathIterator.clone",
	"Comment": "get a cloned locpathiterator that holds the same position as this iterator.",
	"Method": "Object clone(){\r\n    UnionPathIterator clone = (UnionPathIterator) super.clone();\r\n    if (m_iterators != null) {\r\n        int n = m_iterators.length;\r\n        clone.m_iterators = new DTMIterator[n];\r\n        for (int i = 0; i < n; i++) {\r\n            clone.m_iterators[i] = (DTMIterator) m_iterators[i].clone();\r\n        }\r\n    }\r\n    return clone;\r\n}"
}, {
	"Path": "hudson.ClassicPluginStrategy.createClassJarFromWebInfClasses",
	"Comment": "repackage classes directory into a jar file to make it remoting friendly.the remoting layer can cache jar files but not class files.",
	"Method": "void createClassJarFromWebInfClasses(File archive,File destDir,Project prj){\r\n    File classesJar = new File(destDir, \"WEB-INF/lib/classes.jar\");\r\n    ZipFileSet zfs = new ZipFileSet();\r\n    zfs.setProject(prj);\r\n    zfs.setSrc(archive);\r\n    zfs.setIncludes(\"WEB-INF/classes/\");\r\n    MappedResourceCollection mapper = new MappedResourceCollection();\r\n    mapper.add(zfs);\r\n    GlobPatternMapper gm = new GlobPatternMapper();\r\n    gm.setFrom(\"WEB-INF/classes/*\");\r\n    gm.setTo(\"*\");\r\n    mapper.add(gm);\r\n    final long dirTime = archive.lastModified();\r\n    try (ZipOutputStream wrappedZOut = new ZipOutputStream(new NullOutputStream()) {\r\n        @Override\r\n        public void putNextEntry(ZipEntry ze) throws IOException {\r\n            ze.setTime(dirTime + 1999);\r\n            super.putNextEntry(ze);\r\n        }\r\n    }) {\r\n        Zip z = new Zip() {\r\n            protected void zipDir(Resource dir, ZipOutputStream zOut, String vPath, int mode, ZipExtraField[] extra) throws IOException {\r\n                super.zipDir(dir, wrappedZOut, vPath, mode, extra);\r\n            }\r\n        };\r\n        z.setProject(prj);\r\n        z.setTaskType(\"zip\");\r\n        classesJar.getParentFile().mkdirs();\r\n        z.setDestFile(classesJar);\r\n        z.add(mapper);\r\n        z.execute();\r\n    }\r\n    if (classesJar.isFile()) {\r\n        LOGGER.log(Level.WARNING, \"Created {0}; update plugin to a version created with a newer harness\", classesJar);\r\n    }\r\n}"
}, {
	"Path": "hudson.ClassicPluginStrategy.createClassJarFromWebInfClasses",
	"Comment": "repackage classes directory into a jar file to make it remoting friendly.the remoting layer can cache jar files but not class files.",
	"Method": "void createClassJarFromWebInfClasses(File archive,File destDir,Project prj){\r\n    ze.setTime(dirTime + 1999);\r\n    super.putNextEntry(ze);\r\n}"
}, {
	"Path": "hudson.ClassicPluginStrategy.createClassJarFromWebInfClasses",
	"Comment": "repackage classes directory into a jar file to make it remoting friendly.the remoting layer can cache jar files but not class files.",
	"Method": "void createClassJarFromWebInfClasses(File archive,File destDir,Project prj){\r\n    super.zipDir(dir, wrappedZOut, vPath, mode, extra);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemExtensionCall.accept",
	"Comment": "accept a visitor and call the appropriate method for this class.",
	"Method": "boolean accept(XSLTVisitor visitor){\r\n    return visitor.visitExtensionElement(this);\r\n}"
}, {
	"Path": "jenkins.install.InstallUtilTest.test_typeTransitions",
	"Comment": "test jenkins startup sequences and the changes to the startup type..",
	"Method": "void test_typeTransitions(){\r\n    InstallUtil.getLastExecVersionFile().delete();\r\n    InstallUtil.getConfigFile().delete();\r\n    Assert.assertEquals(InstallState.INITIAL_SECURITY_SETUP, InstallUtil.getNextInstallState(InstallState.UNKNOWN));\r\n    Assert.assertEquals(InstallState.NEW, InstallUtil.getNextInstallState(InstallState.INITIAL_SECURITY_SETUP));\r\n    InstallUtil.saveLastExecVersion();\r\n    Assert.assertEquals(InstallState.RESTART, InstallUtil.getNextInstallState(InstallState.UNKNOWN));\r\n    InstallUtil.saveLastExecVersion(\"1.584\");\r\n    Assert.assertEquals(InstallState.UPGRADE, InstallUtil.getNextInstallState(InstallState.UNKNOWN));\r\n    InstallUtil.saveLastExecVersion(\"1000.0\");\r\n    Assert.assertEquals(InstallState.DOWNGRADE, InstallUtil.getNextInstallState(InstallState.UNKNOWN));\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.getWriter",
	"Comment": "get the character stream where the events will be serialized to.",
	"Method": "Writer getWriter(){\r\n    return m_writer;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncNumber.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    return new XNumber(getArg0AsNumber(xctxt));\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.registry.ErrorResponseUtilTest.testGetErrorCode_multipleErrors",
	"Comment": "multiple error objects should cause original exception to be rethrown.",
	"Method": "void testGetErrorCode_multipleErrors(){\r\n    HttpResponseException httpResponseException = new HttpResponseException.Builder(HttpStatus.SC_BAD_REQUEST, \"Bad Request\", new HttpHeaders()).setContent(\"{\\\"errors\\\":[\" + \"{\\\"code\\\":\\\"MANIFEST_INVALID\\\",\\\"message\\\":\\\"message 1\\\",\\\"detail\\\":{}},\" + \"{\\\"code\\\":\\\"TAG_INVALID\\\",\\\"message\\\":\\\"message 2\\\",\\\"detail\\\":{}}\" + \"]}\").build();\r\n    try {\r\n        ErrorResponseUtil.getErrorCode(httpResponseException);\r\n        Assert.fail();\r\n    } catch (HttpResponseException ex) {\r\n        Assert.assertSame(httpResponseException, ex);\r\n    }\r\n}"
}, {
	"Path": "hudson.model.Run.onEndBuilding",
	"Comment": "called when a job finished building normally or abnormally.",
	"Method": "void onEndBuilding(){\r\n    state = State.COMPLETED;\r\n    LOGGER.log(FINER, \"moving to COMPLETED on {0}\", this);\r\n    if (runner != null) {\r\n        runner.checkpoints.allDone();\r\n        runner = null;\r\n        RunnerStack.INSTANCE.pop();\r\n    }\r\n    if (result == null) {\r\n        result = Result.FAILURE;\r\n        LOGGER.log(WARNING, \"{0}: No build result is set, so marking as failure. This should not happen.\", this);\r\n    }\r\n    RunListener.fireFinalized(this);\r\n}"
}, {
	"Path": "hudson.Launcher.printCommandLine",
	"Comment": "prints out the command line to the listener so that users know what we are doing.",
	"Method": "void printCommandLine(String[] cmd,FilePath workDir){\r\n    StringBuilder buf = new StringBuilder();\r\n    if (workDir != null) {\r\n        buf.append('[');\r\n        if (showFullPath)\r\n            buf.append(workDir.getRemote());\r\n        else\r\n            buf.append(workDir.getRemote().replaceFirst(\"^.+[/\\\\\\\\]\", \"\"));\r\n        buf.append(\"] \");\r\n    }\r\n    buf.append('$');\r\n    for (String c : cmd) {\r\n        buf.append(' ');\r\n        if (c.indexOf(' ') >= 0) {\r\n            if (c.indexOf('\"') >= 0)\r\n                buf.append('\\'').append(c).append('\\'');\r\n            else\r\n                buf.append('\"').append(c).append('\"');\r\n        } else\r\n            buf.append(c);\r\n    }\r\n    listener.getLogger().println(buf.toString());\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.getTypedNextSibling",
	"Comment": "given a node handle, advance to its next sibling.if not yet resolved, waits for more nodes to be added to the document andtries again.",
	"Method": "int getTypedNextSibling(int nodeHandle,int nodeType){\r\n    if (nodeHandle == DTM.NULL)\r\n        return DTM.NULL;\r\n    int node = makeNodeIdentity(nodeHandle);\r\n    int eType;\r\n    while ((node = _nextsib(node)) != DTM.NULL && ((eType = _exptype(node)) != nodeType && m_expandedNameTable.getType(eType) != nodeType)) ;\r\n    return (node == DTM.NULL ? DTM.NULL : makeNodeHandle(node));\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.shouldIndent",
	"Comment": "tell if, based on space preservation constraints and the doindent property,if an indent should occur.",
	"Method": "boolean shouldIndent(){\r\n    return m_doIndent && (!m_ispreserve && !m_isprevtext) && m_elemContext.m_currentElemDepth > 0;\r\n}"
}, {
	"Path": "hudson.Functions.getIconFilePath",
	"Comment": "computes the path to the icon of the given actionfrom the context path.",
	"Method": "String getIconFilePath(Action a){\r\n    String name = a.getIconFileName();\r\n    if (name == null)\r\n        return null;\r\n    if (name.startsWith(\"/\"))\r\n        return name.substring(1);\r\n    else\r\n        return \"images/24x24/\" + name;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.asNode",
	"Comment": "return the first node out of the nodeset, if this expression is a nodeset expression.this is the default implementation for nodesets.derived classes should try and override this and return a value without having to do a clone operation.",
	"Method": "int asNode(XPathContext xctxt){\r\n    DTMIterator iter = (DTMIterator) m_clones.getInstance();\r\n    int current = xctxt.getCurrentNode();\r\n    iter.setRoot(current, xctxt);\r\n    int next = iter.nextNode();\r\n    iter.detach();\r\n    return next;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.AxesWalker.getAnalysisBits",
	"Comment": "get the analysis bits for this walker, as defined in the walkerfactory.",
	"Method": "int getAnalysisBits(){\r\n    int axis = getAxis();\r\n    int bit = WalkerFactory.getAnalysisBitFromAxes(axis);\r\n    return bit;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerImpl.transformToString",
	"Comment": "take the contents of a template element, process it, andconvert it to a string.",
	"Method": "String transformToString(ElemTemplateElement elem){\r\n    ElemTemplateElement firstChild = elem.getFirstChildElem();\r\n    if (null == firstChild)\r\n        return \"\";\r\n    if (elem.hasTextLitOnly() && m_optimizer) {\r\n        return ((ElemTextLiteral) firstChild).getNodeValue();\r\n    }\r\n    SerializationHandler savedRTreeHandler = this.m_serializationHandler;\r\n    StringWriter sw = (StringWriter) m_stringWriterObjectPool.getInstance();\r\n    m_serializationHandler = (ToTextStream) m_textResultHandlerObjectPool.getInstance();\r\n    if (null == m_serializationHandler) {\r\n        Serializer serializer = org.apache.xml.serializer.SerializerFactory.getSerializer(m_textformat.getProperties());\r\n        m_serializationHandler = (SerializationHandler) serializer;\r\n    }\r\n    m_serializationHandler.setTransformer(this);\r\n    m_serializationHandler.setWriter(sw);\r\n    String result;\r\n    try {\r\n        executeChildTemplates(elem, true);\r\n        this.m_serializationHandler.endDocument();\r\n        result = sw.toString();\r\n    } catch (org.xml.sax.SAXException se) {\r\n        throw new TransformerException(se);\r\n    } finally {\r\n        sw.getBuffer().setLength(0);\r\n        try {\r\n            sw.close();\r\n        } catch (Exception ioe) {\r\n        }\r\n        m_stringWriterObjectPool.freeInstance(sw);\r\n        m_serializationHandler.reset();\r\n        m_textResultHandlerObjectPool.freeInstance(m_serializationHandler);\r\n        m_serializationHandler = savedRTreeHandler;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.lazy.LazyFluentIterable.map",
	"Comment": "transforms this fluentiterable into a new one containing objects of the type t.",
	"Method": "FluentIterable<T> map(Function<? super E, T> function){\r\n    return new LazyFluentIterable<T>() {\r\n        @Override\r\n        public Iterator<T> iterator() {\r\n            return new DecoratingIterator<T>(null) {\r\n                Iterator<E> oldTypeIterator = iterable.iterator();\r\n                @Override\r\n                public T computeNext() {\r\n                    if (oldTypeIterator.hasNext()) {\r\n                        E candidate = oldTypeIterator.next();\r\n                        return function.apply(candidate);\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.lazy.LazyFluentIterable.map",
	"Comment": "transforms this fluentiterable into a new one containing objects of the type t.",
	"Method": "FluentIterable<T> map(Function<? super E, T> function){\r\n    return new DecoratingIterator<T>(null) {\r\n        Iterator<E> oldTypeIterator = iterable.iterator();\r\n        @Override\r\n        public T computeNext() {\r\n            if (oldTypeIterator.hasNext()) {\r\n                E candidate = oldTypeIterator.next();\r\n                return function.apply(candidate);\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.lazy.LazyFluentIterable.map",
	"Comment": "transforms this fluentiterable into a new one containing objects of the type t.",
	"Method": "FluentIterable<T> map(Function<? super E, T> function){\r\n    if (oldTypeIterator.hasNext()) {\r\n        E candidate = oldTypeIterator.next();\r\n        return function.apply(candidate);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.unparsedEntityDecl",
	"Comment": "if this method is called, the serializer is used as adtdhandler, which changes behavior how the serializer handles document entities.",
	"Method": "void unparsedEntityDecl(String name,String pubID,String sysID,String notationName){\r\n    try {\r\n        DTDprolog();\r\n        m_writer.write(\"<!ENTITY \");\r\n        m_writer.write(name);\r\n        if (pubID != null) {\r\n            m_writer.write(\" PUBLIC \\\"\");\r\n            m_writer.write(pubID);\r\n        } else {\r\n            m_writer.write(\" SYSTEM \\\"\");\r\n            m_writer.write(sysID);\r\n        }\r\n        m_writer.write(\"\\\" NDATA \");\r\n        m_writer.write(notationName);\r\n        m_writer.write(\" >\");\r\n        m_writer.write(m_lineSep, 0, m_lineSepLen);\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.BoolStack.pop",
	"Comment": "removes the object at the top of this stack and returns thatobject as the value of this function.",
	"Method": "boolean pop(){\r\n    return m_values[m_index--];\r\n}"
}, {
	"Path": "redis.clients.jedis.SortingParams.asc",
	"Comment": "get the sorting in ascending order. this is the default order.",
	"Method": "SortingParams asc(){\r\n    params.add(ASC.raw);\r\n    return this;\r\n}"
}, {
	"Path": "hudson.util.spring.BeanBuilder.beans",
	"Comment": "when an methods argument is only a closure it is a set of bean definitions",
	"Method": "BeanBuilder beans(Closure callable){\r\n    callable.setDelegate(this);\r\n    callable.call();\r\n    finalizeDeferredProperties();\r\n    return this;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.DOMLocatorImpl.getUri",
	"Comment": "the uri where the error occured, or null if there is no uri available.",
	"Method": "String getUri(){\r\n    return fUri;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncCurrent.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    SubContextList subContextList = xctxt.getCurrentNodeList();\r\n    int currentNode = DTM.NULL;\r\n    if (null != subContextList) {\r\n        if (subContextList instanceof PredicatedNodeTest) {\r\n            LocPathIterator iter = ((PredicatedNodeTest) subContextList).getLocPathIterator();\r\n            currentNode = iter.getCurrentContextNode();\r\n        } else if (subContextList instanceof StepPattern) {\r\n            throw new RuntimeException(XSLMessages.createMessage(XSLTErrorResources.ER_PROCESSOR_ERROR, null));\r\n        }\r\n    } else {\r\n        currentNode = xctxt.getContextNode();\r\n    }\r\n    return new XNodeSet(currentNode, xctxt.getDTMManager());\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.partialIsVariable",
	"Comment": "check if results of partial reduction will just be a variable, in which case, skip it.",
	"Method": "boolean partialIsVariable(MultistepExprHolder testee,int lengthToTest){\r\n    if (1 == lengthToTest) {\r\n        WalkingIterator wi = (WalkingIterator) testee.m_exprOwner.getExpression();\r\n        if (wi.getFirstWalker() instanceof FilterExprWalker)\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.addPathFile",
	"Comment": "add a file to the path.reads the manifest, if available, and adds any additional class path jarsspecified in the manifest.",
	"Method": "void addPathFile(File pathComponent){\r\n    if (!pathComponents.contains(pathComponent)) {\r\n        pathComponents.addElement(pathComponent);\r\n    }\r\n    if (pathComponent.isDirectory()) {\r\n        return;\r\n    }\r\n    String absPathPlusTimeAndLength = pathComponent.getAbsolutePath() + pathComponent.lastModified() + \"-\" + pathComponent.length();\r\n    String classpath = (String) pathMap.get(absPathPlusTimeAndLength);\r\n    if (classpath == null) {\r\n        JarFile jarFile = null;\r\n        try {\r\n            jarFile = new JarFile(pathComponent);\r\n            Manifest manifest = jarFile.getManifest();\r\n            if (manifest == null) {\r\n                return;\r\n            }\r\n            classpath = manifest.getMainAttributes().getValue(Attributes.Name.CLASS_PATH);\r\n        } finally {\r\n            if (jarFile != null) {\r\n                jarFile.close();\r\n            }\r\n        }\r\n        if (classpath == null) {\r\n            classpath = \"\";\r\n        }\r\n        pathMap.put(absPathPlusTimeAndLength, classpath);\r\n    }\r\n    if (!\"\".equals(classpath)) {\r\n        URL baseURL = FILE_UTILS.getFileURL(pathComponent);\r\n        StringTokenizer st = new StringTokenizer(classpath);\r\n        while (st.hasMoreTokens()) {\r\n            String classpathElement = st.nextToken();\r\n            URL libraryURL = new URL(baseURL, classpathElement);\r\n            if (!libraryURL.getProtocol().equals(\"file\")) {\r\n                log(\"Skipping jar library \" + classpathElement + \" since only relative URLs are supported by this\" + \" loader\", Project.MSG_VERBOSE);\r\n                continue;\r\n            }\r\n            String decodedPath = Locator.decodeUri(libraryURL.getFile());\r\n            File libraryFile = new File(decodedPath);\r\n            if (libraryFile.exists() && !isInPath(libraryFile)) {\r\n                addPathFile(libraryFile);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.setParentFirst",
	"Comment": "control whether class lookup is delegated to the parent loader firstor after this loader. use with extreme caution. setting this tofalse violates the class loader hierarchy and can lead to linkage errors",
	"Method": "void setParentFirst(boolean parentFirst){\r\n    this.parentFirst = parentFirst;\r\n}"
}, {
	"Path": "com.iluwatar.retry.RetryTest.ignore",
	"Comment": "final number of attempts should be equal to the number of attempts asked because we are asking it to ignore the exception that will be thrown.",
	"Method": "void ignore(){\r\n    final BusinessException e = new CustomerNotFoundException(\"customer not found\");\r\n    final Retry<String> retry = new Retry(() -> {\r\n        throw e;\r\n    }, 2, 0, ex -> CustomerNotFoundException.class.isAssignableFrom(ex.getClass()));\r\n    try {\r\n        retry.perform();\r\n    } catch (BusinessException ex) {\r\n    }\r\n    assertThat(retry.attempts(), is(2));\r\n}"
}, {
	"Path": "org.apache.xalan.templates.TemplateList.getTemplate",
	"Comment": "given a target element, find the template that bestmatches in the given xsl document, accordingto the rules specified in the xsl draft.",
	"Method": "ElemTemplate getTemplate(QName qname,ElemTemplate getTemplate,XPathContext xctxt,int targetNode,QName mode,boolean quietConflictWarnings,DTM dtm,ElemTemplate getTemplate,XPathContext xctxt,int targetNode,QName mode,int maxImportLevel,int endImportLevel,boolean quietConflictWarnings,DTM dtm){\r\n    TemplateSubPatternAssociation head = getHead(xctxt, targetNode, dtm);\r\n    if (null != head) {\r\n        xctxt.pushNamespaceContextNull();\r\n        xctxt.pushCurrentNodeAndExpression(targetNode, targetNode);\r\n        try {\r\n            do {\r\n                if ((maxImportLevel > -1) && (head.getImportLevel() > maxImportLevel)) {\r\n                    continue;\r\n                }\r\n                if (head.getImportLevel() <= maxImportLevel - endImportLevel)\r\n                    return null;\r\n                ElemTemplate template = head.getTemplate();\r\n                xctxt.setNamespaceContext(template);\r\n                if ((head.m_stepPattern.execute(xctxt, targetNode) != NodeTest.SCORE_NONE) && head.matchMode(mode)) {\r\n                    if (quietConflictWarnings)\r\n                        checkConflicts(head, xctxt, targetNode, mode);\r\n                    return template;\r\n                }\r\n            } while (null != (head = head.getNext()));\r\n        } finally {\r\n            xctxt.popCurrentNodeAndExpression();\r\n            xctxt.popNamespaceContext();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "hudson.model.labels.LabelExpressionTest.composite",
	"Comment": "the name should have parenthesis at the right place to preserve the tree structure.",
	"Method": "void composite(){\r\n    LabelAtom x = j.jenkins.getLabelAtom(\"x\");\r\n    assertEquals(\"!!x\", x.not().not().getName());\r\n    assertEquals(\"(x||x)&&x\", x.or(x).and(x).getName());\r\n    assertEquals(\"x&&x||x\", x.and(x).or(x).getName());\r\n}"
}, {
	"Path": "ciphers.AESEncryption.getSecretEncryptionKey",
	"Comment": "gets the aes encryption key. in your actual programs, this should be safely\tstored.",
	"Method": "SecretKey getSecretEncryptionKey(){\r\n    KeyGenerator aesKeyGenerator = KeyGenerator.getInstance(\"AES\");\r\n    aesKeyGenerator.init(128);\r\n    SecretKey secKey = aesKeyGenerator.generateKey();\r\n    return secKey;\r\n}"
}, {
	"Path": "org.java_websocket.WebSocketAdapter.onWebsocketPing",
	"Comment": "this default implementation will send a pong in response to the received ping.\tthe pong frame will have the same payload as the ping frame.",
	"Method": "void onWebsocketPing(WebSocket conn,Framedata f){\r\n    conn.sendFrame(new PongFrame((PingFrame) f));\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.dom2dtm.DOM2DTM.nextNode",
	"Comment": "this method iterates to the next node that will be added to the table.each call to this method adds a new node to the table, unless the endis reached, in which case it returns null.",
	"Method": "boolean nextNode(){\r\n    if (m_nodesAreProcessed)\r\n        return false;\r\n    Node pos = m_pos;\r\n    Node next = null;\r\n    int nexttype = NULL;\r\n    do {\r\n        if (pos.hasChildNodes()) {\r\n            next = pos.getFirstChild();\r\n            if (next != null && DOCUMENT_TYPE_NODE == next.getNodeType())\r\n                next = next.getNextSibling();\r\n            if (ENTITY_REFERENCE_NODE != pos.getNodeType()) {\r\n                m_last_parent = m_last_kid;\r\n                m_last_kid = NULL;\r\n                if (null != m_wsfilter) {\r\n                    short wsv = m_wsfilter.getShouldStripSpace(makeNodeHandle(m_last_parent), this);\r\n                    boolean shouldStrip = (DTMWSFilter.INHERIT == wsv) ? getShouldStripWhitespace() : (DTMWSFilter.STRIP == wsv);\r\n                    pushShouldStripWhitespace(shouldStrip);\r\n                }\r\n            }\r\n        } else {\r\n            if (m_last_kid != NULL) {\r\n                if (m_firstch.elementAt(m_last_kid) == NOTPROCESSED)\r\n                    m_firstch.setElementAt(NULL, m_last_kid);\r\n            }\r\n            while (m_last_parent != NULL) {\r\n                next = pos.getNextSibling();\r\n                if (next != null && DOCUMENT_TYPE_NODE == next.getNodeType())\r\n                    next = next.getNextSibling();\r\n                if (next != null)\r\n                    break;\r\n                pos = pos.getParentNode();\r\n                if (pos == null) {\r\n                    if (JJK_DEBUG) {\r\n                        System.out.println(\"***** DOM2DTM Pop Control Flow problem\");\r\n                        for (; ; ) ;\r\n                    }\r\n                }\r\n                if (pos != null && ENTITY_REFERENCE_NODE == pos.getNodeType()) {\r\n                    if (JJK_DEBUG)\r\n                        System.out.println(\"***** DOM2DTM popping EntRef\");\r\n                } else {\r\n                    popShouldStripWhitespace();\r\n                    if (m_last_kid == NULL)\r\n                        m_firstch.setElementAt(NULL, m_last_parent);\r\n                    else\r\n                        m_nextsib.setElementAt(NULL, m_last_kid);\r\n                    m_last_parent = m_parent.elementAt(m_last_kid = m_last_parent);\r\n                }\r\n            }\r\n            if (m_last_parent == NULL)\r\n                next = null;\r\n        }\r\n        if (next != null)\r\n            nexttype = next.getNodeType();\r\n        if (ENTITY_REFERENCE_NODE == nexttype)\r\n            pos = next;\r\n    } while (ENTITY_REFERENCE_NODE == nexttype);\r\n    if (next == null) {\r\n        m_nextsib.setElementAt(NULL, 0);\r\n        m_nodesAreProcessed = true;\r\n        m_pos = null;\r\n        if (JJK_DEBUG) {\r\n            System.out.println(\"***** DOM2DTM Crosscheck:\");\r\n            for (int i = 0; i < m_nodes.size(); ++i) System.out.println(i + \":\\t\" + m_firstch.elementAt(i) + \"\\t\" + m_nextsib.elementAt(i));\r\n        }\r\n        return false;\r\n    }\r\n    boolean suppressNode = false;\r\n    Node lastTextNode = null;\r\n    nexttype = next.getNodeType();\r\n    if (TEXT_NODE == nexttype || CDATA_SECTION_NODE == nexttype) {\r\n        suppressNode = ((null != m_wsfilter) && getShouldStripWhitespace());\r\n        Node n = next;\r\n        while (n != null) {\r\n            lastTextNode = n;\r\n            if (TEXT_NODE == n.getNodeType())\r\n                nexttype = TEXT_NODE;\r\n            suppressNode &= XMLCharacterRecognizer.isWhiteSpace(n.getNodeValue());\r\n            n = logicalNextDOMTextNode(n);\r\n        }\r\n    } else if (PROCESSING_INSTRUCTION_NODE == nexttype) {\r\n        suppressNode = (pos.getNodeName().toLowerCase().equals(\"xml\"));\r\n    }\r\n    if (!suppressNode) {\r\n        int nextindex = addNode(next, m_last_parent, m_last_kid, nexttype);\r\n        m_last_kid = nextindex;\r\n        if (ELEMENT_NODE == nexttype) {\r\n            int attrIndex = NULL;\r\n            NamedNodeMap attrs = next.getAttributes();\r\n            int attrsize = (attrs == null) ? 0 : attrs.getLength();\r\n            if (attrsize > 0) {\r\n                for (int i = 0; i < attrsize; ++i) {\r\n                    attrIndex = addNode(attrs.item(i), nextindex, attrIndex, NULL);\r\n                    m_firstch.setElementAt(DTM.NULL, attrIndex);\r\n                    if (!m_processedFirstElement && \"xmlns:xml\".equals(attrs.item(i).getNodeName()))\r\n                        m_processedFirstElement = true;\r\n                }\r\n            }\r\n            if (!m_processedFirstElement) {\r\n                attrIndex = addNode(new DOM2DTMdefaultNamespaceDeclarationNode((Element) next, \"xml\", NAMESPACE_DECL_NS, makeNodeHandle(((attrIndex == NULL) ? nextindex : attrIndex) + 1)), nextindex, attrIndex, NULL);\r\n                m_firstch.setElementAt(DTM.NULL, attrIndex);\r\n                m_processedFirstElement = true;\r\n            }\r\n            if (attrIndex != NULL)\r\n                m_nextsib.setElementAt(DTM.NULL, attrIndex);\r\n        }\r\n    }\r\n    if (TEXT_NODE == nexttype || CDATA_SECTION_NODE == nexttype) {\r\n        next = lastTextNode;\r\n    }\r\n    m_pos = next;\r\n    return true;\r\n}"
}, {
	"Path": "jadx.core.dex.visitors.regions.RegionMaker.processHandlersOutBlocks",
	"Comment": "search handlers successor blocks not included in any region.",
	"Method": "IRegion processHandlersOutBlocks(MethodNode mth,Set<TryCatchBlock> tcs){\r\n    Set<IBlock> allRegionBlocks = new HashSet();\r\n    RegionUtils.getAllRegionBlocks(mth.getRegion(), allRegionBlocks);\r\n    Set<IBlock> succBlocks = new HashSet();\r\n    for (TryCatchBlock tc : tcs) {\r\n        for (ExceptionHandler handler : tc.getHandlers()) {\r\n            IContainer region = handler.getHandlerRegion();\r\n            if (region != null) {\r\n                IBlock lastBlock = RegionUtils.getLastBlock(region);\r\n                if (lastBlock instanceof BlockNode) {\r\n                    succBlocks.addAll(((BlockNode) lastBlock).getSuccessors());\r\n                }\r\n                RegionUtils.getAllRegionBlocks(region, allRegionBlocks);\r\n            }\r\n        }\r\n    }\r\n    succBlocks.removeAll(allRegionBlocks);\r\n    if (succBlocks.isEmpty()) {\r\n        return null;\r\n    }\r\n    Region excOutRegion = new Region(mth.getRegion());\r\n    for (IBlock block : succBlocks) {\r\n        if (block instanceof BlockNode) {\r\n            excOutRegion.add(makeRegion((BlockNode) block, new RegionStack(mth)));\r\n        }\r\n    }\r\n    return excOutRegion;\r\n}"
}, {
	"Path": "hudson.util.ChunkedOutputStream.flush",
	"Comment": "flushes the underlying stream, but leaves the internal buffer alone.",
	"Method": "void flush(){\r\n    flushCache();\r\n    stream.flush();\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.isTerminating",
	"Comment": "returns true if the container initiated the termination of the web application.",
	"Method": "boolean isTerminating(){\r\n    return terminating;\r\n}"
}, {
	"Path": "com.sun.jna.platform.linux.XAttrUtil.lRemoveXAttr",
	"Comment": "remove extended attribute from file but in case of symbolic link remove extended attributefrom the link itself instead of linked file.",
	"Method": "void lRemoveXAttr(String path,String name){\r\n    final int retval = XAttr.INSTANCE.lremovexattr(path, name);\r\n    if (retval != 0) {\r\n        final int eno = Native.getLastError();\r\n        throw new IOException(\"errno: \" + eno);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemLiteralResult.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n    StylesheetRoot.ComposeState cstate = sroot.getComposeState();\r\n    java.util.Vector vnames = cstate.getVariableNames();\r\n    if (null != m_avts) {\r\n        int nAttrs = m_avts.size();\r\n        for (int i = (nAttrs - 1); i >= 0; i--) {\r\n            AVT avt = (AVT) m_avts.get(i);\r\n            avt.fixupVariables(vnames, cstate.getGlobalsSize());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.tls.DateFormatCallableTestIncorrectDateFormat.setup",
	"Comment": "run callable and prepare results for usage in the test methods",
	"Method": "void setup(){\r\n    DateFormatCallable callableDf = new DateFormatCallable(\"dd/MM/yyyy\", \"15.12.2015\");\r\n    ExecutorService executor = Executors.newCachedThreadPool();\r\n    Future<Result> futureResult = executor.submit(callableDf);\r\n    try {\r\n        result = futureResult.get();\r\n    } catch (Exception e) {\r\n        fail(\"Setup failed: \" + e);\r\n    }\r\n    executor.shutdown();\r\n}"
}, {
	"Path": "hudson.model.UpdateCenter.init",
	"Comment": "initializes the update center.this has to wait until after all plugins load, to let custom updatecenterconfiguration take effect first.",
	"Method": "void init(Jenkins h){\r\n    h.getUpdateCenter().load();\r\n}"
}, {
	"Path": "org.apache.xml.utils.BoolStack.peek",
	"Comment": "looks at the object at the top of this stack without removing itfrom the stack.",
	"Method": "boolean peek(){\r\n    return m_values[m_index];\r\n}"
}, {
	"Path": "org.apache.xml.utils.UnImplNode.isSameNode",
	"Comment": "returns whether this node is the same node as the given one.this method provides a way to determine whether twonode references returned by the implementation referencethe same object. when two node references are referencesto the same object, even if through a proxy, the references may beused completely interchangably, such that all attributes have thesame values and calling the same dom method on either referencealways has exactly the same effect.",
	"Method": "boolean isSameNode(Node other){\r\n    return this == other;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerIdentityImpl.createResultContentHandler",
	"Comment": "create a result contenthandler from a result object, basedon the current outputproperties.",
	"Method": "void createResultContentHandler(Result outputTarget){\r\n    if (outputTarget instanceof SAXResult) {\r\n        SAXResult saxResult = (SAXResult) outputTarget;\r\n        m_resultContentHandler = saxResult.getHandler();\r\n        m_resultLexicalHandler = saxResult.getLexicalHandler();\r\n        if (m_resultContentHandler instanceof Serializer) {\r\n            m_serializer = (Serializer) m_resultContentHandler;\r\n        }\r\n    } else if (outputTarget instanceof DOMResult) {\r\n        DOMResult domResult = (DOMResult) outputTarget;\r\n        Node outputNode = domResult.getNode();\r\n        Node nextSibling = domResult.getNextSibling();\r\n        Document doc;\r\n        short type;\r\n        if (null != outputNode) {\r\n            type = outputNode.getNodeType();\r\n            doc = (Node.DOCUMENT_NODE == type) ? (Document) outputNode : outputNode.getOwnerDocument();\r\n        } else {\r\n            try {\r\n                DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\r\n                dbf.setNamespaceAware(true);\r\n                if (m_isSecureProcessing) {\r\n                    try {\r\n                        dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\r\n                    } catch (ParserConfigurationException pce) {\r\n                    }\r\n                }\r\n                DocumentBuilder db = dbf.newDocumentBuilder();\r\n                doc = db.newDocument();\r\n            } catch (ParserConfigurationException pce) {\r\n                throw new TransformerException(pce);\r\n            }\r\n            outputNode = doc;\r\n            type = outputNode.getNodeType();\r\n            ((DOMResult) outputTarget).setNode(outputNode);\r\n        }\r\n        DOMBuilder domBuilder = (Node.DOCUMENT_FRAGMENT_NODE == type) ? new DOMBuilder(doc, (DocumentFragment) outputNode) : new DOMBuilder(doc, outputNode);\r\n        if (nextSibling != null)\r\n            domBuilder.setNextSibling(nextSibling);\r\n        m_resultContentHandler = domBuilder;\r\n        m_resultLexicalHandler = domBuilder;\r\n    } else if (outputTarget instanceof StreamResult) {\r\n        StreamResult sresult = (StreamResult) outputTarget;\r\n        try {\r\n            Serializer serializer = SerializerFactory.getSerializer(m_outputFormat.getProperties());\r\n            m_serializer = serializer;\r\n            if (null != sresult.getWriter())\r\n                serializer.setWriter(sresult.getWriter());\r\n            else if (null != sresult.getOutputStream())\r\n                serializer.setOutputStream(sresult.getOutputStream());\r\n            else if (null != sresult.getSystemId()) {\r\n                String fileURL = sresult.getSystemId();\r\n                if (fileURL.startsWith(\"file:///\")) {\r\n                    if (fileURL.substring(8).indexOf(\":\") > 0) {\r\n                        fileURL = fileURL.substring(8);\r\n                    } else {\r\n                        fileURL = fileURL.substring(7);\r\n                    }\r\n                } else if (fileURL.startsWith(\"file:/\")) {\r\n                    if (fileURL.substring(6).indexOf(\":\") > 0) {\r\n                        fileURL = fileURL.substring(6);\r\n                    } else {\r\n                        fileURL = fileURL.substring(5);\r\n                    }\r\n                }\r\n                m_outputStream = new java.io.FileOutputStream(fileURL);\r\n                serializer.setOutputStream(m_outputStream);\r\n            } else\r\n                throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_OUTPUT_SPECIFIED, null));\r\n            m_resultContentHandler = serializer.asContentHandler();\r\n        } catch (IOException ioe) {\r\n            throw new TransformerException(ioe);\r\n        }\r\n    } else {\r\n        throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_TRANSFORM_TO_RESULT_TYPE, new Object[] { outputTarget.getClass().getName() }));\r\n    }\r\n    if (m_resultContentHandler instanceof DTDHandler)\r\n        m_resultDTDHandler = (DTDHandler) m_resultContentHandler;\r\n    if (m_resultContentHandler instanceof DeclHandler)\r\n        m_resultDeclHandler = (DeclHandler) m_resultContentHandler;\r\n    if (m_resultContentHandler instanceof LexicalHandler)\r\n        m_resultLexicalHandler = (LexicalHandler) m_resultContentHandler;\r\n}"
}, {
	"Path": "org.java_websocket.client.WebSocketClient.connectBlocking",
	"Comment": "same as connect but blocks with a timeout until the websocket connected or failed to do so.",
	"Method": "boolean connectBlocking(boolean connectBlocking,long timeout,TimeUnit timeUnit){\r\n    connect();\r\n    return connectLatch.await(timeout, timeUnit) && engine.isOpen();\r\n}"
}, {
	"Path": "hudson.model.queue.QueueSorter.sortBlockedItems",
	"Comment": "sorts the blocked items list. the items at the beginning will be considered for removal from the blocked statebefore the items at the end of the list.",
	"Method": "void sortBlockedItems(List<Queue.BlockedItem> blockedItems){\r\n    Collections.sort(blockedItems, DEFAULT_BLOCKED_ITEM_COMPARATOR);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.needToCheckExclude",
	"Comment": "return whether we need to check namespace prefixes against and exclude result prefixes list.",
	"Method": "boolean needToCheckExclude(){\r\n    return false;\r\n}"
}, {
	"Path": "jadx.core.xmlgen.XMLChar.isValid",
	"Comment": "returns true if the specified character is valid. this method\talso checks the surrogate character range from 0x10000 to 0x10ffff.\tif the program chooses to apply the mask directly to the\tchars array, then they are responsible for checking\tthe surrogate character range.",
	"Method": "boolean isValid(int c){\r\n    return (c < 0x10000 && (CHARS[c] & MASK_VALID) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToXMLStream.addUniqueAttribute",
	"Comment": "this method is used to add an attribute to the currently open element. the caller has guaranted that this attribute is unique, which means that itnot been seen before and will not be seen again.",
	"Method": "void addUniqueAttribute(String name,String value,int flags){\r\n    if (m_elemContext.m_startTagOpen) {\r\n        try {\r\n            final String patchedName = patchName(name);\r\n            final java.io.Writer writer = m_writer;\r\n            if ((flags & NO_BAD_CHARS) > 0 && m_xmlcharInfo.onlyQuotAmpLtGt) {\r\n                writer.write(' ');\r\n                writer.write(patchedName);\r\n                writer.write(\"=\\\"\");\r\n                writer.write(value);\r\n                writer.write('\"');\r\n            } else {\r\n                writer.write(' ');\r\n                writer.write(patchedName);\r\n                writer.write(\"=\\\"\");\r\n                writeAttrString(writer, value, this.getEncoding());\r\n                writer.write('\"');\r\n            }\r\n        } catch (IOException e) {\r\n            throw new SAXException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.java_websocket.client.WebSocketClient.handleIOException",
	"Comment": "method to give some additional info for specific ioexceptions",
	"Method": "void handleIOException(IOException e){\r\n    if (e instanceof SSLException) {\r\n        onError(e);\r\n    }\r\n    engine.eot();\r\n}"
}, {
	"Path": "hudson.model.Descriptor.isSubTypeOf",
	"Comment": "checks if the type represented by this descriptor is a subtype of the given type.",
	"Method": "boolean isSubTypeOf(Class type){\r\n    return type.isAssignableFrom(clazz);\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.getDTMManager",
	"Comment": "return the dtmmanager object.though xpathcontext context extends the dtmmanager, it really is a proxy for the real dtmmanager.if a caller needs to make a lot of calls to the dtmmanager, it is faster if it gets the real one from this function.",
	"Method": "DTMManager getDTMManager(DTMManager getDTMManager){\r\n    return m_dtmManager;\r\n}"
}, {
	"Path": "org.java_websocket.AbstractWebSocket.restartConnectionLostTimer",
	"Comment": "this methods allows the reset of the connection lost timer in case of a changed parameter",
	"Method": "void restartConnectionLostTimer(){\r\n    cancelConnectionLostTimer();\r\n    connectionLostTimer = new Timer(\"WebSocketTimer\");\r\n    connectionLostTimerTask = new TimerTask() {\r\n        private ArrayList<WebSocket> connections = new ArrayList<WebSocket>();\r\n        @Override\r\n        public void run() {\r\n            connections.clear();\r\n            try {\r\n                connections.addAll(getConnections());\r\n                long current = (System.currentTimeMillis() - (connectionLostTimeout * 1500));\r\n                for (WebSocket conn : connections) {\r\n                    executeConnectionLostDetection(conn, current);\r\n                }\r\n            } catch (Exception e) {\r\n            }\r\n            connections.clear();\r\n        }\r\n    };\r\n    connectionLostTimer.scheduleAtFixedRate(connectionLostTimerTask, 1000L * connectionLostTimeout, 1000L * connectionLostTimeout);\r\n}"
}, {
	"Path": "org.java_websocket.AbstractWebSocket.restartConnectionLostTimer",
	"Comment": "this methods allows the reset of the connection lost timer in case of a changed parameter",
	"Method": "void restartConnectionLostTimer(){\r\n    connections.clear();\r\n    try {\r\n        connections.addAll(getConnections());\r\n        long current = (System.currentTimeMillis() - (connectionLostTimeout * 1500));\r\n        for (WebSocket conn : connections) {\r\n            executeConnectionLostDetection(conn, current);\r\n        }\r\n    } catch (Exception e) {\r\n    }\r\n    connections.clear();\r\n}"
}, {
	"Path": "org.apache.xml.utils.SuballocatedIntVector.removeElementAt",
	"Comment": "deletes the component at the specified index. each component inthis vector with an index greater or equal to the specifiedindex is shifted downward to have an index one smaller thanthe value it had previously.",
	"Method": "void removeElementAt(int at){\r\n    if (at < m_firstFree) {\r\n        int index = at >>> m_SHIFT;\r\n        int maxindex = m_firstFree >>> m_SHIFT;\r\n        int offset = at & m_MASK;\r\n        while (index <= maxindex) {\r\n            int copylen = m_blocksize - offset - 1;\r\n            int[] block = m_map[index];\r\n            if (null == block)\r\n                block = m_map[index] = new int[m_blocksize];\r\n            else\r\n                System.arraycopy(block, offset + 1, block, offset, copylen);\r\n            if (index < maxindex) {\r\n                int[] next = m_map[index + 1];\r\n                if (next != null)\r\n                    block[m_blocksize - 1] = (next != null) ? next[0] : 0;\r\n            } else\r\n                block[m_blocksize - 1] = 0;\r\n            offset = 0;\r\n            ++index;\r\n        }\r\n    }\r\n    --m_firstFree;\r\n}"
}, {
	"Path": "hudson.model.Descriptor.getPropertyType",
	"Comment": "used by jelly to abstract away the handling of global.jelly vs config.jelly databinding difference.",
	"Method": "PropertyType getPropertyType(Object instance,String field,PropertyType getPropertyType,String field){\r\n    if (propertyTypes == null)\r\n        propertyTypes = buildPropertyTypes(clazz);\r\n    return propertyTypes.get(field);\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.KeyManager.getNodeSetDTMByKey",
	"Comment": "given a valid element key, return the corresponding node list.",
	"Method": "XNodeSet getNodeSetDTMByKey(XPathContext xctxt,int doc,QName name,XMLString ref,PrefixResolver nscontext){\r\n    XNodeSet nl = null;\r\n    ElemTemplateElement template = (ElemTemplateElement) nscontext;\r\n    if ((null != template) && null != template.getStylesheetRoot().getKeysComposed()) {\r\n        boolean foundDoc = false;\r\n        if (null == m_key_tables) {\r\n            m_key_tables = new Vector(4);\r\n        } else {\r\n            int nKeyTables = m_key_tables.size();\r\n            for (int i = 0; i < nKeyTables; i++) {\r\n                KeyTable kt = (KeyTable) m_key_tables.elementAt(i);\r\n                if (kt.getKeyTableName().equals(name) && doc == kt.getDocKey()) {\r\n                    nl = kt.getNodeSetDTMByKey(name, ref);\r\n                    if (nl != null) {\r\n                        foundDoc = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if ((null == nl) && !foundDoc) {\r\n            KeyTable kt = new KeyTable(doc, nscontext, name, template.getStylesheetRoot().getKeysComposed(), xctxt);\r\n            m_key_tables.addElement(kt);\r\n            if (doc == kt.getDocKey()) {\r\n                foundDoc = true;\r\n                nl = kt.getNodeSetDTMByKey(name, ref);\r\n            }\r\n        }\r\n    }\r\n    return nl;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.configuration.DockerHealthCheck.getRetries",
	"Comment": "gets the optional healthcheck retry count. a missing command means that it will be inheritedfrom the base image.",
	"Method": "Optional<Integer> getRetries(){\r\n    return Optional.ofNullable(retries);\r\n}"
}, {
	"Path": "org.apache.xml.utils.ObjectFactory.findJarServiceProviderName",
	"Comment": "find the name of service provider using jar service provider mechanism",
	"Method": "String findJarServiceProviderName(String factoryId){\r\n    SecuritySupport ss = SecuritySupport.getInstance();\r\n    String serviceId = SERVICES_PATH + factoryId;\r\n    InputStream is = null;\r\n    ClassLoader cl = findClassLoader();\r\n    is = ss.getResourceAsStream(cl, serviceId);\r\n    if (is == null) {\r\n        ClassLoader current = ObjectFactory.class.getClassLoader();\r\n        if (cl != current) {\r\n            cl = current;\r\n            is = ss.getResourceAsStream(cl, serviceId);\r\n        }\r\n    }\r\n    if (is == null) {\r\n        return null;\r\n    }\r\n    debugPrintln(\"found jar resource=\" + serviceId + \" using ClassLoader: \" + cl);\r\n    BufferedReader rd;\r\n    try {\r\n        rd = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n    } catch (java.io.UnsupportedEncodingException e) {\r\n        rd = new BufferedReader(new InputStreamReader(is));\r\n    }\r\n    String factoryClassName = null;\r\n    try {\r\n        factoryClassName = rd.readLine();\r\n    } catch (IOException x) {\r\n        return null;\r\n    } finally {\r\n        try {\r\n            rd.close();\r\n        } catch (IOException exc) {\r\n        }\r\n    }\r\n    if (factoryClassName != null && !\"\".equals(factoryClassName)) {\r\n        debugPrintln(\"found in resource, value=\" + factoryClassName);\r\n        return factoryClassName;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.XPathParser.error",
	"Comment": "notify the user of an error, and probably throw anexception.",
	"Method": "void error(String msg,Object[] args){\r\n    String fmsg = XSLMessages.createXPATHMessage(msg, args);\r\n    ErrorListener ehandler = this.getErrorListener();\r\n    TransformerException te = new TransformerException(fmsg, m_sourceLocator);\r\n    if (null != ehandler) {\r\n        ehandler.fatalError(te);\r\n    } else {\r\n        throw te;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ElemDesc.isAttrFlagSet",
	"Comment": "tell if any of the bits of interest are set for a named attribute type.",
	"Method": "boolean isAttrFlagSet(String name,int flags){\r\n    return (null != m_attrs) ? ((m_attrs.getIgnoreCase(name) & flags) != 0) : false;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToHTMLStream.writeAttrURI",
	"Comment": "write the specified string after substituting non ascii characters,with %hh, where hh is the hex of the byte value.",
	"Method": "void writeAttrURI(java.io.Writer writer,String string,boolean doURLEscaping){\r\n    final int end = string.length();\r\n    if (end > m_attrBuff.length) {\r\n        m_attrBuff = new char[end * 2 + 1];\r\n    }\r\n    string.getChars(0, end, m_attrBuff, 0);\r\n    final char[] chars = m_attrBuff;\r\n    int cleanStart = 0;\r\n    int cleanLength = 0;\r\n    char ch = 0;\r\n    for (int i = 0; i < end; i++) {\r\n        ch = chars[i];\r\n        if ((ch < 32) || (ch > 126)) {\r\n            if (cleanLength > 0) {\r\n                writer.write(chars, cleanStart, cleanLength);\r\n                cleanLength = 0;\r\n            }\r\n            if (doURLEscaping) {\r\n                if (ch <= 0x7F) {\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(ch));\r\n                } else if (ch <= 0x7FF) {\r\n                    int high = (ch >> 6) | 0xC0;\r\n                    int low = (ch & 0x3F) | 0x80;\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(high));\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(low));\r\n                } else if (Encodings.isHighUTF16Surrogate(ch)) {\r\n                    int highSurrogate = ((int) ch) & 0x03FF;\r\n                    int wwww = ((highSurrogate & 0x03C0) >> 6);\r\n                    int uuuuu = wwww + 1;\r\n                    int zzzz = (highSurrogate & 0x003C) >> 2;\r\n                    int yyyyyy = ((highSurrogate & 0x0003) << 4) & 0x30;\r\n                    ch = chars[++i];\r\n                    int lowSurrogate = ((int) ch) & 0x03FF;\r\n                    yyyyyy = yyyyyy | ((lowSurrogate & 0x03C0) >> 6);\r\n                    int xxxxxx = (lowSurrogate & 0x003F);\r\n                    int byte1 = 0xF0 | (uuuuu >> 2);\r\n                    int byte2 = 0x80 | (((uuuuu & 0x03) << 4) & 0x30) | zzzz;\r\n                    int byte3 = 0x80 | yyyyyy;\r\n                    int byte4 = 0x80 | xxxxxx;\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(byte1));\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(byte2));\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(byte3));\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(byte4));\r\n                } else {\r\n                    int high = (ch >> 12) | 0xE0;\r\n                    int middle = ((ch & 0x0FC0) >> 6) | 0x80;\r\n                    int low = (ch & 0x3F) | 0x80;\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(high));\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(middle));\r\n                    writer.write('%');\r\n                    writer.write(makeHHString(low));\r\n                }\r\n            } else if (escapingNotNeeded(ch)) {\r\n                writer.write(ch);\r\n            } else {\r\n                writer.write(\"&#\");\r\n                writer.write(Integer.toString(ch));\r\n                writer.write(';');\r\n            }\r\n            cleanStart = i + 1;\r\n        } else if (ch == '\"') {\r\n            if (cleanLength > 0) {\r\n                writer.write(chars, cleanStart, cleanLength);\r\n                cleanLength = 0;\r\n            }\r\n            if (doURLEscaping)\r\n                writer.write(\""\
	");\r\n            else\r\n                writer.write(\"&quot;\");\r\n            cleanStart = i + 1;\r\n        } else if (ch == '&') {\r\n            if (cleanLength > 0) {\r\n                writer.write(chars, cleanStart, cleanLength);\r\n                cleanLength = 0;\r\n            }\r\n            writer.write(\"&amp;\");\r\n            cleanStart = i + 1;\r\n        } else {\r\n            cleanLength++;\r\n        }\r\n    }\r\n    if (cleanLength > 1) {\r\n        if (cleanStart == 0)\r\n            writer.write(string);\r\n        else\r\n            writer.write(chars, cleanStart, cleanLength);\r\n    } else if (cleanLength == 1) {\r\n        writer.write(ch);\r\n    }\r\n}"
}, {
	"Path": "hudson.model.AbstractBuild.getUpstreamBuilds",
	"Comment": "gets the upstream builds of this build, which are the builds of theupstream projects whose artifacts feed into this build.",
	"Method": "Map<AbstractProject, Integer> getUpstreamBuilds(){\r\n    return _getUpstreamBuilds(getParent().getUpstreamProjects());\r\n}"
}, {
	"Path": "hudson.model.Computer.getSystemProperties",
	"Comment": "gets the system properties of the jvm on this computer.if this is the master, it returns the system property of the master computer.",
	"Method": "Map<Object, Object> getSystemProperties(){\r\n    return RemotingDiagnostics.getSystemProperties(getChannel());\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncFalse.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    return XBoolean.S_FALSE;\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XString.getTypeString",
	"Comment": "given a request type, return the equivalent string.for diagnostic purposes.",
	"Method": "String getTypeString(){\r\n    return \"#STRING\";\r\n}"
}, {
	"Path": "hudson.scheduler.CronTab.getTimeZone",
	"Comment": "returns the configured time zone, or null if none is configured",
	"Method": "TimeZone getTimeZone(){\r\n    if (this.specTimezone == null) {\r\n        return null;\r\n    }\r\n    return TimeZone.getTimeZone(this.specTimezone);\r\n}"
}, {
	"Path": "org.apache.xalan.extensions.ExpressionVisitor.visitFunction",
	"Comment": "if the function is an extension function, register the namespace.",
	"Method": "boolean visitFunction(ExpressionOwner owner,Function func){\r\n    if (func instanceof FuncExtFunction) {\r\n        String namespace = ((FuncExtFunction) func).getNamespace();\r\n        m_sroot.getExtensionNamespacesManager().registerExtension(namespace);\r\n    } else if (func instanceof FuncExtFunctionAvailable) {\r\n        String arg = ((FuncExtFunctionAvailable) func).getArg0().toString();\r\n        if (arg.indexOf(\":\") > 0) {\r\n            String prefix = arg.substring(0, arg.indexOf(\":\"));\r\n            String namespace = this.m_sroot.getNamespaceForPrefix(prefix);\r\n            m_sroot.getExtensionNamespacesManager().registerExtension(namespace);\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.getFilter",
	"Comment": "the filter used to screen nodes.not used at this time,this is here only to fullfill the dom nodeiteratorinterface.",
	"Method": "DTMFilter getFilter(){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.unparsedEntityDecl",
	"Comment": "receive notification of an unparsed entity declaration.by default, do nothing.application writers may override thismethod in a subclass to keep track of the unparsed entitiesdeclared in a document.",
	"Method": "void unparsedEntityDecl(String name,String publicId,String systemId,String notationName){\r\n    if (null == m_entities) {\r\n        m_entities = new Vector();\r\n    }\r\n    try {\r\n        systemId = SystemIDResolver.getAbsoluteURI(systemId, getDocumentBaseURI());\r\n    } catch (Exception e) {\r\n        throw new org.xml.sax.SAXException(e);\r\n    }\r\n    m_entities.addElement(publicId);\r\n    m_entities.addElement(systemId);\r\n    m_entities.addElement(notationName);\r\n    m_entities.addElement(name);\r\n}"
}, {
	"Path": "org.apache.xml.utils.BoolStack.peekOrFalse",
	"Comment": "looks at the object at the top of this stack without removing itfrom the stack.if the stack is empty, it returns false.",
	"Method": "boolean peekOrFalse(){\r\n    return (m_index > -1) ? m_values[m_index] : false;\r\n}"
}, {
	"Path": "com.iluwatar.tls.DateFormatCallableTestMultiThread.testCounterDateValues",
	"Comment": "test number of dates in the list after the run of dateformatrunnalbe. a correct run should deliver 5 date values by each thread",
	"Method": "void testCounterDateValues(){\r\n    for (int i = 0; i < result.length; i++) {\r\n        assertEquals(expectedCounterDateValues, result[i].getDateList().size());\r\n    }\r\n}"
}, {
	"Path": "jenkins.management.AdministrativeMonitorsDecorator.shouldDisplay",
	"Comment": "whether the administrative monitors notifier should be shown.",
	"Method": "boolean shouldDisplay(){\r\n    if (!Functions.hasPermission(Jenkins.ADMINISTER)) {\r\n        return false;\r\n    }\r\n    StaplerRequest req = Stapler.getCurrentRequest();\r\n    if (req == null) {\r\n        return false;\r\n    }\r\n    List<Ancestor> ancestors = req.getAncestors();\r\n    if (ancestors == null || ancestors.size() == 0) {\r\n        return false;\r\n    }\r\n    Ancestor a = ancestors.get(ancestors.size() - 1);\r\n    Object o = a.getObject();\r\n    if (o instanceof HudsonIsLoading) {\r\n        return false;\r\n    }\r\n    if (o instanceof HudsonIsRestarting) {\r\n        return false;\r\n    }\r\n    if (o instanceof Jenkins) {\r\n        String url = a.getRestOfUrl();\r\n        if (ignoredJenkinsRestOfUrls.contains(url)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (getActiveAdministrativeMonitorsCount() == 0) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ObjectFactory.findClassLoader",
	"Comment": "figure out which classloader to use.for jdk 1.2 and later usethe context classloader.",
	"Method": "ClassLoader findClassLoader(){\r\n    SecuritySupport ss = SecuritySupport.getInstance();\r\n    ClassLoader context = ss.getContextClassLoader();\r\n    ClassLoader system = ss.getSystemClassLoader();\r\n    ClassLoader chain = system;\r\n    while (true) {\r\n        if (context == chain) {\r\n            ClassLoader current = ObjectFactory.class.getClassLoader();\r\n            chain = system;\r\n            while (true) {\r\n                if (current == chain) {\r\n                    return system;\r\n                }\r\n                if (chain == null) {\r\n                    break;\r\n                }\r\n                chain = ss.getParentClassLoader(chain);\r\n            }\r\n            return current;\r\n        }\r\n        if (chain == null) {\r\n            break;\r\n        }\r\n        chain = ss.getParentClassLoader(chain);\r\n    }\r\n    ;\r\n    return context;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToUnknownStream.setDoctypePublic",
	"Comment": "set the doctype in the underlying xml handler. remember that this methodwas called, just in case we need to transfer this doctype to an html handler",
	"Method": "void setDoctypePublic(String doctype){\r\n    m_handler.setDoctypePublic(doctype);\r\n    m_setDoctypePublic_called = true;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncExtFunction.setArg",
	"Comment": "set an argument expression for a function.this method is called by thexpath compiler.",
	"Method": "void setArg(Expression arg,int argNum){\r\n    m_argVec.addElement(arg);\r\n    arg.exprSetParent(this);\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.CountersTable.appendBtoFList",
	"Comment": "add a list of counted nodes that were built in backwards documentorder, or a list of counted nodes that are in forwards documentorder.",
	"Method": "void appendBtoFList(NodeSetDTM flist,NodeSetDTM blist){\r\n    int n = blist.size();\r\n    for (int i = (n - 1); i >= 0; i--) {\r\n        flist.addElement(blist.item(i));\r\n    }\r\n}"
}, {
	"Path": "hudson.model.View.getPeople",
	"Comment": "gets the users that show up in the changelog of this job collection.",
	"Method": "People getPeople(){\r\n    return new People(this);\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.configuration.DockerHealthCheck.getCommand",
	"Comment": "gets the optional healthcheck command. a missing command means that it will be inherited fromthe base image.",
	"Method": "List<String> getCommand(){\r\n    return command;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ElemContext.push",
	"Comment": "push an element context on the stack. this context keeps track ofinformation gathered about the element.",
	"Method": "ElemContext push(ElemContext push,String uri,String localName,String qName){\r\n    ElemContext frame = this.m_next;\r\n    if (frame == null) {\r\n        frame = new ElemContext(this);\r\n        this.m_next = frame;\r\n    }\r\n    frame.m_elementName = qName;\r\n    frame.m_elementLocalName = localName;\r\n    frame.m_elementURI = uri;\r\n    frame.m_isCdataSection = false;\r\n    frame.m_startTagOpen = true;\r\n    return frame;\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.lazy.LazyFluentIterable.asList",
	"Comment": "collects all remaining objects of this iteration into a list.",
	"Method": "List<E> asList(){\r\n    return FluentIterable.copyToList(iterable);\r\n}"
}, {
	"Path": "hudson.scheduler.CronTabList.getValidTimezone",
	"Comment": "checks if given timezone string is supported by timezone and returnsthe same string if valid, null otherwise",
	"Method": "String getValidTimezone(String timezone){\r\n    String[] validIDs = TimeZone.getAvailableIDs();\r\n    for (String str : validIDs) {\r\n        if (str != null && str.equals(timezone)) {\r\n            return timezone;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.ignorableWhitespace",
	"Comment": "receive notification of ignorable whitespace in element content.",
	"Method": "void ignorableWhitespace(char ch,int start,int length){\r\n    if (!m_shouldProcess)\r\n        return;\r\n    getCurrentProcessor().ignorableWhitespace(this, ch, start, length);\r\n}"
}, {
	"Path": "hudson.node_monitors.NodeMonitorUpdater.onOnline",
	"Comment": "triggers the update with 5 seconds quiet period, to avoid triggering data check too oftenwhen multiple agents become online at about the same time.",
	"Method": "void onOnline(Computer c,TaskListener listener){\r\n    synchronized (this) {\r\n        future.cancel(false);\r\n        future = Timer.get().schedule(MONITOR_UPDATER, 5, TimeUnit.SECONDS);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.getStylesheetRoot",
	"Comment": "get the owning root stylesheet.this looks up theinheritance chain until it calls stylesheetrooton a stylesheet object, which will return a referenceto the root stylesheet.",
	"Method": "StylesheetRoot getStylesheetRoot(){\r\n    return m_parentNode.getStylesheetRoot();\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerIdentityImpl.setDocumentLocator",
	"Comment": "receive a locator object for document events.by default, do nothing.application writers may override thismethod in a subclass if they wish to store the locator for usewith other document events.",
	"Method": "void setDocumentLocator(Locator locator){\r\n    try {\r\n        if (null == m_resultContentHandler)\r\n            createResultContentHandler(m_result);\r\n    } catch (TransformerException te) {\r\n        throw new org.apache.xml.utils.WrappedRuntimeException(te);\r\n    }\r\n    m_resultContentHandler.setDocumentLocator(locator);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.changePartToRef",
	"Comment": "change a given number of steps to a single variable reference.",
	"Method": "LocPathIterator changePartToRef(QName uniquePseudoVarName,WalkingIterator wi,int numSteps,boolean isGlobal){\r\n    Variable var = new Variable();\r\n    var.setQName(uniquePseudoVarName);\r\n    var.setIsGlobal(isGlobal);\r\n    if (isGlobal) {\r\n        ElemTemplateElement elem = getElemFromExpression(wi);\r\n        StylesheetRoot root = elem.getStylesheetRoot();\r\n        Vector vars = root.getVariablesAndParamsComposed();\r\n        var.setIndex(vars.size() - 1);\r\n    }\r\n    AxesWalker walker = wi.getFirstWalker();\r\n    for (int i = 0; i < numSteps; i++) {\r\n        assertion(null != walker, \"Walker should not be null!\");\r\n        walker = walker.getNextWalker();\r\n    }\r\n    if (null != walker) {\r\n        FilterExprWalker few = new FilterExprWalker(wi);\r\n        few.setInnerExpression(var);\r\n        few.exprSetParent(wi);\r\n        few.setNextWalker(walker);\r\n        walker.setPrevWalker(few);\r\n        wi.setFirstWalker(few);\r\n        return wi;\r\n    } else {\r\n        FilterExprIteratorSimple feis = new FilterExprIteratorSimple(var);\r\n        feis.exprSetParent(wi.exprGetParent());\r\n        return feis;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncSubstring.reportWrongNumberArgs",
	"Comment": "constructs and throws a wrongnumberargexception with the appropriatemessage for this function object.",
	"Method": "void reportWrongNumberArgs(){\r\n    throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_TWO_OR_THREE, null));\r\n}"
}, {
	"Path": "hudson.util.ArgumentListBuilder.addTokenized",
	"Comment": "decomposes the given token into multiple arguments by splitting via whitespace.",
	"Method": "ArgumentListBuilder addTokenized(String s){\r\n    if (s == null)\r\n        return this;\r\n    add(Util.tokenize(s));\r\n    return this;\r\n}"
}, {
	"Path": "jenkins.model.RunIdMigratorTest.timezone",
	"Comment": "ensures that legacy timestamps are interpreted in a predictable time zone.",
	"Method": "void timezone(){\r\n    TimeZone.setDefault(TimeZone.getTimeZone(\"EST\"));\r\n}"
}, {
	"Path": "org.apache.xalan.templates.AVTPartXPath.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    m_xpath.fixupVariables(vars, globalsSize);\r\n}"
}, {
	"Path": "hudson.tools.ToolInstaller.getLabel",
	"Comment": "label to limit which nodes this installation can be performed on.can be null to not impose a limit.",
	"Method": "String getLabel(){\r\n    return label;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.Function3Args.setArg",
	"Comment": "set an argument expression for a function.this method is called by the xpath compiler.",
	"Method": "void setArg(Expression arg,int argNum){\r\n    if (argNum < 2)\r\n        super.setArg(arg, argNum);\r\n    else if (2 == argNum) {\r\n        m_arg2 = arg;\r\n        arg.exprSetParent(this);\r\n    } else\r\n        reportWrongNumberArgs();\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.simple.SimpleFluentIterable.toList",
	"Comment": "collects the remaining objects of the given iterator into a list.",
	"Method": "List<E> toList(Iterator<E> iterator){\r\n    List<E> copy = new ArrayList();\r\n    while (iterator.hasNext()) {\r\n        copy.add(iterator.next());\r\n    }\r\n    return copy;\r\n}"
}, {
	"Path": "org.java_websocket.drafts.Draft_6455.getMaxFrameSize",
	"Comment": "getter for the maximum allowed payload size which is used by this draft",
	"Method": "int getMaxFrameSize(){\r\n    return maxFrameSize;\r\n}"
}, {
	"Path": "hudson.model.NodeTest.assertThatCloudLabelDoesNotContain",
	"Comment": "assert that a tag cloud does not contain the label name and weight.",
	"Method": "void assertThatCloudLabelDoesNotContain(TagCloud<LabelAtom> tagCloud,String expectedLabel,int expectedWeight){\r\n    assertThatCloudLabel(false, tagCloud, expectedLabel, expectedWeight);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.ProcessorTemplateElem.appendAndPush",
	"Comment": "append the current template element to the currenttemplate element, and then push it onto the current templateelement stack.",
	"Method": "void appendAndPush(StylesheetHandler handler,ElemTemplateElement elem){\r\n    ElemTemplateElement parent = handler.getElemTemplateElement();\r\n    if (null != parent) {\r\n        parent.appendChild(elem);\r\n        handler.pushElemTemplateElement(elem);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.XML11Char.isXML11InternalEntityContent",
	"Comment": "returns true if the specified character can be considered content in an internal parsed entity.",
	"Method": "boolean isXML11InternalEntityContent(int c){\r\n    return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_CONTENT_INTERNAL) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerImpl.setStylesheet",
	"Comment": "set the stylesheet for this processor.if this is set, then theprocess calls that take only the input .xml will usethis instead of looking for a stylesheet pi.also,setting the stylesheet is needed if you are goingto use the processor as a sax contenthandler.",
	"Method": "void setStylesheet(StylesheetRoot stylesheetRoot){\r\n    m_stylesheetRoot = stylesheetRoot;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.getNamespaceMappings",
	"Comment": "some users of the serializer may need the current namespace mappings",
	"Method": "NamespaceMappings getNamespaceMappings(){\r\n    return m_prefixMap;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM2.copyTextNode",
	"Comment": "copy the string value of a text node to a serializationhandler",
	"Method": "void copyTextNode(int nodeID,SerializationHandler handler){\r\n    if (nodeID != DTM.NULL) {\r\n        int dataIndex = m_dataOrQName.elementAt(nodeID);\r\n        if (dataIndex >= 0) {\r\n            m_chars.sendSAXcharacters(handler, dataIndex >>> TEXT_LENGTH_BITS, dataIndex & TEXT_LENGTH_MAX);\r\n        } else {\r\n            m_chars.sendSAXcharacters(handler, m_data.elementAt(-dataIndex), m_data.elementAt(-dataIndex + 1));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "lib.form.ComboBoxTest.testCompoundFieldDependentComboBox",
	"Comment": "confirms that relative paths work when prefilling a combobox text field",
	"Method": "void testCompoundFieldDependentComboBox(){\r\n    Descriptor d1 = new CompoundFieldComboBoxBuilder.DescriptorImpl();\r\n    Publisher.all().add(d1);\r\n    Descriptor d2 = new CompoundField.DescriptorImpl();\r\n    Publisher.all().add(d2);\r\n    FreeStyleProject p = createFreeStyleProject();\r\n    p.getPublishersList().add(new CompoundFieldComboBoxBuilder(new CompoundField(\"AABBCC\", \"XXYYZZ\"), null));\r\n    try {\r\n        new WebClient().getPage(p, \"configure\");\r\n    } catch (AssertionError e) {\r\n        if (e.getMessage().contains(\"doFillFooItems is broken\")) {\r\n            fail(\"Nested field values required for prefill were null\");\r\n        } else {\r\n            throw e;\r\n        }\r\n    } finally {\r\n        Publisher.all().remove(d1);\r\n        Publisher.all().remove(d2);\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.tls.DateFormatCallableTest.testCounterExceptions",
	"Comment": "test number of exceptions in the list after the run of dateformatrunnalbe. a correct run should deliver no exceptions",
	"Method": "void testCounterExceptions(){\r\n    assertEquals(expectedCounterExceptions, result.getExceptionList().size());\r\n}"
}, {
	"Path": "org.apache.xml.utils.ObjectVector.removeElementAt",
	"Comment": "deletes the component at the specified index. each component inthis vector with an index greater or equal to the specifiedindex is shifted downward to have an index one smaller thanthe value it had previously.",
	"Method": "void removeElementAt(int i){\r\n    if (i > m_firstFree)\r\n        System.arraycopy(m_map, i + 1, m_map, i, m_firstFree);\r\n    else\r\n        m_map[i] = null;\r\n    m_firstFree--;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMNodeIterator.getExpandEntityReferences",
	"Comment": "the value of this flag determines whether the childrenof entity reference nodes are visible to the iterator.",
	"Method": "boolean getExpandEntityReferences(){\r\n    return false;\r\n}"
}, {
	"Path": "hudson.Util.makeWritable",
	"Comment": "makes the file at the given path writable by any means possible.",
	"Method": "void makeWritable(Path path){\r\n    if (!Functions.isWindows()) {\r\n        try {\r\n            PosixFileAttributes attrs = Files.readAttributes(path, PosixFileAttributes.class);\r\n            Set<PosixFilePermission> newPermissions = attrs.permissions();\r\n            newPermissions.add(PosixFilePermission.OWNER_WRITE);\r\n            Files.setPosixFilePermissions(path, newPermissions);\r\n            return;\r\n        } catch (NoSuchFileException e) {\r\n            return;\r\n        } catch (UnsupportedOperationException e) {\r\n        }\r\n    }\r\n    path.toFile().setWritable(true);\r\n}"
}, {
	"Path": "hudson.scm.SCMDescriptor.load",
	"Comment": "causing the field to be persisted and overwritten on the load method.",
	"Method": "void load(){\r\n    Class<? extends RepositoryBrowser> rb = repositoryBrowser;\r\n    super.load();\r\n    if (repositoryBrowser != rb) {\r\n        try {\r\n            Field f = SCMDescriptor.class.getDeclaredField(\"repositoryBrowser\");\r\n            f.setAccessible(true);\r\n            f.set(this, rb);\r\n        } catch (NoSuchFieldException e) {\r\n            LOGGER.log(WARNING, \"Failed to overwrite the repositoryBrowser field\", e);\r\n        } catch (IllegalAccessException e) {\r\n            LOGGER.log(WARNING, \"Failed to overwrite the repositoryBrowser field\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.StylesheetPIHandler.getAssociatedStylesheet",
	"Comment": "return the last stylesheet found that match the constraints.",
	"Method": "Source getAssociatedStylesheet(){\r\n    int sz = m_stylesheets.size();\r\n    if (sz > 0) {\r\n        Source source = (Source) m_stylesheets.elementAt(sz - 1);\r\n        return source;\r\n    } else\r\n        return null;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.ProcessorInclude.getStylesheetType",
	"Comment": "get the stylesheet type associated with an included stylesheet",
	"Method": "int getStylesheetType(){\r\n    return StylesheetHandler.STYPE_INCLUDE;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.dom2dtm.DOM2DTM.getAttributeNode",
	"Comment": "retrieves an attribute node by by qualified name and namespace uri.",
	"Method": "int getAttributeNode(int nodeHandle,String namespaceURI,String name){\r\n    if (null == namespaceURI)\r\n        namespaceURI = \"\";\r\n    int type = getNodeType(nodeHandle);\r\n    if (DTM.ELEMENT_NODE == type) {\r\n        int identity = makeNodeIdentity(nodeHandle);\r\n        while (DTM.NULL != (identity = getNextNodeIdentity(identity))) {\r\n            type = _type(identity);\r\n            if (type == DTM.ATTRIBUTE_NODE || type == DTM.NAMESPACE_NODE) {\r\n                Node node = lookupNode(identity);\r\n                String nodeuri = node.getNamespaceURI();\r\n                if (null == nodeuri)\r\n                    nodeuri = \"\";\r\n                String nodelocalname = node.getLocalName();\r\n                if (nodeuri.equals(namespaceURI) && name.equals(nodelocalname))\r\n                    return makeNodeHandle(identity);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return DTM.NULL;\r\n}"
}, {
	"Path": "hudson.model.Job.doBuildStatus",
	"Comment": "returns the image that shows the current buildcommand status.",
	"Method": "void doBuildStatus(StaplerRequest req,StaplerResponse rsp){\r\n    rsp.sendRedirect2(req.getContextPath() + \"/images/48x48/\" + getBuildStatusUrl());\r\n}"
}, {
	"Path": "hudson.slaves.JNLPLauncherTest.testLaunchWithWorkDir",
	"Comment": "starts a jnlp agent and makes sure it successfully connects to jenkins.",
	"Method": "void testLaunchWithWorkDir(){\r\n    Assume.assumeFalse(\"Skipping JNLPLauncherTest.testLaunch because we are running headless\", GraphicsEnvironment.isHeadless());\r\n    File workDir = tmpDir.newFolder(\"workDir\");\r\n    Computer c = addTestSlave(false);\r\n    launchJnlpAndVerify(c, buildJnlpArgs(c).add(\"-workDir\", workDir.getAbsolutePath()));\r\n    assertTrue(\"Remoting work dir should have been created\", new File(workDir, \"remoting\").exists());\r\n}"
}, {
	"Path": "hudson.slaves.Channels.forProcess",
	"Comment": "creates a channel that wraps a remote process, so that when we shut down the connectionwe kill the process.",
	"Method": "Channel forProcess(String name,ExecutorService execService,InputStream in,OutputStream out,Proc proc,Channel forProcess,String name,ExecutorService execService,InputStream in,OutputStream out,OutputStream header,Proc proc,Channel forProcess,String name,ExecutorService execService,Process proc,OutputStream header){\r\n    final Thread thread = new StreamCopyThread(name + \" stderr\", proc.getErrorStream(), header);\r\n    thread.start();\r\n    ChannelBuilder cb = new ChannelBuilder(name, execService) {\r\n        @Override\r\n        public Channel build(CommandTransport transport) throws IOException {\r\n            return new Channel(this, transport) {\r\n                @Override\r\n                public synchronized void terminate(IOException e) {\r\n                    super.terminate(e);\r\n                    proc.destroy();\r\n                }\r\n                @Override\r\n                public synchronized void join() throws InterruptedException {\r\n                    super.join();\r\n                    proc.waitFor();\r\n                    thread.join();\r\n                }\r\n            };\r\n        }\r\n    };\r\n    cb.withHeaderStream(header);\r\n    for (ChannelConfigurator cc : ChannelConfigurator.all()) {\r\n        cc.onChannelBuilding(cb, null);\r\n    }\r\n    return cb.build(proc.getInputStream(), proc.getOutputStream());\r\n}"
}, {
	"Path": "hudson.slaves.Channels.forProcess",
	"Comment": "creates a channel that wraps a remote process, so that when we shut down the connectionwe kill the process.",
	"Method": "Channel forProcess(String name,ExecutorService execService,InputStream in,OutputStream out,Proc proc,Channel forProcess,String name,ExecutorService execService,InputStream in,OutputStream out,OutputStream header,Proc proc,Channel forProcess,String name,ExecutorService execService,Process proc,OutputStream header){\r\n    return new Channel(this, transport) {\r\n        @Override\r\n        public synchronized void terminate(IOException e) {\r\n            super.terminate(e);\r\n            proc.destroy();\r\n        }\r\n        @Override\r\n        public synchronized void join() throws InterruptedException {\r\n            super.join();\r\n            proc.waitFor();\r\n            thread.join();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "hudson.slaves.Channels.forProcess",
	"Comment": "creates a channel that wraps a remote process, so that when we shut down the connectionwe kill the process.",
	"Method": "Channel forProcess(String name,ExecutorService execService,InputStream in,OutputStream out,Proc proc,Channel forProcess,String name,ExecutorService execService,InputStream in,OutputStream out,OutputStream header,Proc proc,Channel forProcess,String name,ExecutorService execService,Process proc,OutputStream header){\r\n    super.terminate(e);\r\n    proc.destroy();\r\n}"
}, {
	"Path": "hudson.slaves.Channels.forProcess",
	"Comment": "creates a channel that wraps a remote process, so that when we shut down the connectionwe kill the process.",
	"Method": "Channel forProcess(String name,ExecutorService execService,InputStream in,OutputStream out,Proc proc,Channel forProcess,String name,ExecutorService execService,InputStream in,OutputStream out,OutputStream header,Proc proc,Channel forProcess,String name,ExecutorService execService,Process proc,OutputStream header){\r\n    super.join();\r\n    proc.waitFor();\r\n    thread.join();\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemCopyOf.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n    StylesheetRoot.ComposeState cstate = sroot.getComposeState();\r\n    m_selectExpression.fixupVariables(cstate.getVariableNames(), cstate.getGlobalsSize());\r\n}"
}, {
	"Path": "org.apache.xpath.operations.UnaryOperation.execute",
	"Comment": "execute the operand and apply the unary operation to the result.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    return operate(m_right.execute(xctxt));\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.gradle.DefaultTargetProjectIntegrationTest.assertDockerInspect",
	"Comment": "asserts that the test project has the required exposed ports, labels and volumes.",
	"Method": "void assertDockerInspect(String imageReference){\r\n    String dockerInspect = new Command(\"docker\", \"inspect\", imageReference).run();\r\n    Assert.assertThat(dockerInspect, CoreMatchers.containsString(\"            \\\"ExposedPorts\\\": {\\n\" + \"                \\\"1000/tcp\\\": {},\\n\" + \"                \\\"2000/udp\\\": {},\\n\" + \"                \\\"2001/udp\\\": {},\\n\" + \"                \\\"2002/udp\\\": {},\\n\" + \"                \\\"2003/udp\\\": {}\"));\r\n    Assert.assertThat(dockerInspect, CoreMatchers.containsString(\"            \\\"Labels\\\": {\\n\" + \"                \\\"key1\\\": \\\"value1\\\",\\n\" + \"                \\\"key2\\\": \\\"value2\\\"\\n\" + \"            }\"));\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncExtFunctionAvailable.setFunctionTable",
	"Comment": "the function table is an instance field. in order to access this instance field during evaluation, this method is called at compilation time toinsert function table information for later usage. it should only be usedduring compiling of xpath expressions.",
	"Method": "void setFunctionTable(FunctionTable aTable){\r\n    m_functionTable = aTable;\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XStringForFSB.isSpace",
	"Comment": "returns whether the specified ch conforms to the xml 1.0 definitionof whitespace.refer to the definition of s for details.",
	"Method": "boolean isSpace(char ch){\r\n    return XMLCharacterRecognizer.isWhiteSpace(ch);\r\n}"
}, {
	"Path": "hudson.security.ACL.checkPermission",
	"Comment": "checks if the current security principal has this permission.this is just a convenience function.",
	"Method": "void checkPermission(Permission p){\r\n    Authentication a = Jenkins.getAuthentication();\r\n    if (a == SYSTEM) {\r\n        return;\r\n    }\r\n    if (!hasPermission(a, p))\r\n        throw new AccessDeniedException2(a, p);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemWithParam.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    if (null == m_selectPattern && sroot.getOptimizer()) {\r\n        XPath newSelect = ElemVariable.rewriteChildToExpression(this);\r\n        if (null != newSelect)\r\n            m_selectPattern = newSelect;\r\n    }\r\n    m_qnameID = sroot.getComposeState().getQNameID(m_qname);\r\n    super.compose(sroot);\r\n    java.util.Vector vnames = sroot.getComposeState().getVariableNames();\r\n    if (null != m_selectPattern)\r\n        m_selectPattern.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());\r\n}"
}, {
	"Path": "org.apache.xml.utils.ObjectStack.peek",
	"Comment": "looks at the object at the position the stack counting down n items.",
	"Method": "Object peek(Object peek,int n){\r\n    try {\r\n        return m_map[m_firstFree - (1 + n)];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new EmptyStackException();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.Expression.getSystemId",
	"Comment": "return the system identifier for the current document event.the return value is the system identifier of the documententity or of the external parsed entity in which the markup thattriggered the event appears.if the system identifier is a url, the parser must resolve itfully before passing it to the application.",
	"Method": "String getSystemId(){\r\n    if (null == m_parent)\r\n        return null;\r\n    return m_parent.getSystemId();\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.doSimulateOutOfMemory",
	"Comment": "simulates outofmemoryerror.useful to make sure outofmemoryheapdump setting.",
	"Method": "void doSimulateOutOfMemory(){\r\n    checkPermission(ADMINISTER);\r\n    System.out.println(\"Creating artificial OutOfMemoryError situation\");\r\n    List<Object> args = new ArrayList<Object>();\r\n    while (true) args.add(new byte[1024 * 1024]);\r\n}"
}, {
	"Path": "hudson.model.labels.LabelExpressionTest.queueBehavior1",
	"Comment": "verifies the queueing behavior in the presence of the expression.",
	"Method": "void queueBehavior1(){\r\n    DumbSlave w32 = j.createSlave(\"win 32bit\", null);\r\n    DumbSlave w64 = j.createSlave(\"win 64bit\", null);\r\n    j.createSlave(\"linux 32bit\", null);\r\n    final SequenceLock seq = new SequenceLock();\r\n    FreeStyleProject p1 = j.createFreeStyleProject();\r\n    p1.getBuildersList().add(new TestBuilder() {\r\n        public boolean perform(AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) throws InterruptedException, IOException {\r\n            seq.phase(0);\r\n            seq.phase(2);\r\n            seq.done();\r\n            return true;\r\n        }\r\n    });\r\n    p1.setAssignedLabel(j.jenkins.getLabel(\"win && 32bit\"));\r\n    FreeStyleProject p2 = j.createFreeStyleProject();\r\n    p2.setAssignedLabel(j.jenkins.getLabel(\"win && 32bit\"));\r\n    FreeStyleProject p3 = j.createFreeStyleProject();\r\n    p3.setAssignedLabel(j.jenkins.getLabel(\"win\"));\r\n    Future<FreeStyleBuild> f1 = p1.scheduleBuild2(0);\r\n    seq.phase(1);\r\n    Future<FreeStyleBuild> f2 = p2.scheduleBuild2(0);\r\n    Thread.sleep(1000);\r\n    FreeStyleBuild b3 = j.assertBuildStatusSuccess(p3.scheduleBuild2(0));\r\n    assertSame(w64, b3.getBuiltOn());\r\n    seq.phase(3);\r\n    FreeStyleBuild b1 = j.assertBuildStatusSuccess(f1);\r\n    assertSame(w32, b1.getBuiltOn());\r\n    FreeStyleBuild b2 = j.assertBuildStatusSuccess(f2);\r\n    assertSame(w32, b2.getBuiltOn());\r\n}"
}, {
	"Path": "hudson.model.labels.LabelExpressionTest.queueBehavior1",
	"Comment": "verifies the queueing behavior in the presence of the expression.",
	"Method": "void queueBehavior1(){\r\n    seq.phase(0);\r\n    seq.phase(2);\r\n    seq.done();\r\n    return true;\r\n}"
}, {
	"Path": "hudson.model.labels.LabelExpressionTest.queueBehavior2",
	"Comment": "push the build around to different nodes via the assignmentto make sure it gets where we need it to.",
	"Method": "void queueBehavior2(){\r\n    DumbSlave s = j.createSlave(\"win\", null);\r\n    FreeStyleProject p = j.createFreeStyleProject();\r\n    p.setAssignedLabel(j.jenkins.getLabel(\"!win\"));\r\n    FreeStyleBuild b = j.assertBuildStatusSuccess(p.scheduleBuild2(0));\r\n    assertSame(j.jenkins, b.getBuiltOn());\r\n    p.setAssignedLabel(j.jenkins.getLabel(\"win\"));\r\n    b = j.assertBuildStatusSuccess(p.scheduleBuild2(0));\r\n    assertSame(s, b.getBuiltOn());\r\n    p.setAssignedLabel(j.jenkins.getLabel(\"!win\"));\r\n    b = j.assertBuildStatusSuccess(p.scheduleBuild2(0));\r\n    assertSame(j.jenkins, b.getBuiltOn());\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.getNextFollowing",
	"Comment": "given a node handle, advance to the next node on the following axis.",
	"Method": "int getNextFollowing(int axisContextHandle,int nodeHandle){\r\n    return NULL;\r\n}"
}, {
	"Path": "hudson.model.Executor.isLikelyStuck",
	"Comment": "returns true if the current build is likely stuck.this is a heuristics based approach, but if the build is suspiciously taking for a long time,this method returns true.",
	"Method": "boolean isLikelyStuck(){\r\n    lock.readLock().lock();\r\n    try {\r\n        if (executable == null) {\r\n            return false;\r\n        }\r\n    } finally {\r\n        lock.readLock().unlock();\r\n    }\r\n    long elapsed = getElapsedTime();\r\n    long d = executableEstimatedDuration;\r\n    if (d >= 0) {\r\n        return d * 10 < elapsed;\r\n    } else {\r\n        return TimeUnit.MILLISECONDS.toHours(elapsed) > 24;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.FuncDocument.reportWrongNumberArgs",
	"Comment": "constructs and throws a wrongnumberargexception with the appropriatemessage for this function object.",
	"Method": "void reportWrongNumberArgs(){\r\n    throw new WrongNumberArgsException(XSLMessages.createMessage(XSLTErrorResources.ER_ONE_OR_TWO, null));\r\n}"
}, {
	"Path": "hudson.util.CopyOnWriteMapTest.treeSerialization",
	"Comment": "verify that an empty copyonwritemap.tree can be serialized,and that serialization form is the same as a standard treemap.",
	"Method": "void treeSerialization(){\r\n    TreeData td = new TreeData();\r\n    XStream2 xs = new XStream2();\r\n    String out = xs.toXML(td);\r\n    assertEquals(\"empty maps\", \"<hudson.util.CopyOnWriteMapTest_-TreeData>\" + \"<map1/><map2/>\" + \"<\/hudson.util.CopyOnWriteMapTest_-TreeData>\", out.replaceAll(\"\\\\s+\", \"\"));\r\n    TreeData td2 = (TreeData) xs.fromXML(out);\r\n    assertTrue(td2.map1.isEmpty());\r\n    assertTrue(td2.map2.isEmpty());\r\n    td = new TreeData(String.CASE_INSENSITIVE_ORDER);\r\n    td.map1.put(\"foo1\", \"bar1\");\r\n    td.map2.put(\"foo2\", \"bar2\");\r\n    out = xs.toXML(td);\r\n    assertEquals(\"maps\", \"<hudson.util.CopyOnWriteMapTest_-TreeData><map1>\" + \"<comparator class=\\\"java.lang.String$CaseInsensitiveComparator\\\"/>\" + \"<entry><string>foo1<\/string><string>bar1<\/string><\/entry><\/map1>\" + \"<map2><comparator class=\\\"java.lang.String$CaseInsensitiveComparator\\\"\" + \" reference=\\\"../../map1/comparator\\\"/>\" + \"<entry><string>foo2<\/string><string>bar2<\/string><\/entry><\/map2>\" + \"<\/hudson.util.CopyOnWriteMapTest_-TreeData>\", out.replaceAll(\">\\\\s+<\", \"><\"));\r\n    td2 = (TreeData) xs.fromXML(out);\r\n    assertEquals(\"bar1\", td2.map1.get(\"foo1\"));\r\n    assertEquals(\"bar2\", td2.map2.get(\"foo2\"));\r\n}"
}, {
	"Path": "hudson.console.LineTransformationOutputStream.forceEol",
	"Comment": "forces the eol behavior.useful if the caller wants to make sure the buffered content is all processed, but withoutactually neither flushing nor closing the stream.",
	"Method": "void forceEol(){\r\n    if (buf.size() > 0) {\r\n        eol();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.axes.UnionPathIterator.getAnalysisBits",
	"Comment": "get the analysis bits for this walker, as defined in the walkerfactory.",
	"Method": "int getAnalysisBits(){\r\n    int bits = 0;\r\n    if (m_exprs != null) {\r\n        int n = m_exprs.length;\r\n        for (int i = 0; i < n; i++) {\r\n            int bit = m_exprs[i].getAnalysisBits();\r\n            bits |= bit;\r\n        }\r\n    }\r\n    return bits;\r\n}"
}, {
	"Path": "com.iluwatar.interpreter.App.main",
	"Comment": "program entry point.expressions can be evaluated using prefix, infix or postfix notations this sample uses postfix,where operator comes after the operands",
	"Method": "void main(String[] args){\r\n    String tokenString = \"4 3 2 - 1 + *\";\r\n    Stack<Expression> stack = new Stack();\r\n    String[] tokenList = tokenString.split(\" \");\r\n    for (String s : tokenList) {\r\n        if (isOperator(s)) {\r\n            Expression rightExpression = stack.pop();\r\n            Expression leftExpression = stack.pop();\r\n            LOGGER.info(\"popped from stack left: {} right: {}\", leftExpression.interpret(), rightExpression.interpret());\r\n            Expression operator = getOperatorInstance(s, leftExpression, rightExpression);\r\n            LOGGER.info(\"operator: {}\", operator);\r\n            int result = operator.interpret();\r\n            NumberExpression resultExpression = new NumberExpression(result);\r\n            stack.push(resultExpression);\r\n            LOGGER.info(\"push result to stack: {}\", resultExpression.interpret());\r\n        } else {\r\n            Expression i = new NumberExpression(s);\r\n            stack.push(i);\r\n            LOGGER.info(\"push to stack: {}\", i.interpret());\r\n        }\r\n    }\r\n    LOGGER.info(\"result: {}\", stack.pop().interpret());\r\n}"
}, {
	"Path": "jenkins.tasks.SimpleBuildWrapper.setUp",
	"Comment": "called when a segment of a build is started that is to be enhanced with this wrapper.",
	"Method": "void setUp(Context context,Run<?, ?> build,FilePath workspace,Launcher launcher,TaskListener listener,EnvVars initialEnvironment,Environment setUp,AbstractBuild build,Launcher launcher,BuildListener listener){\r\n    if (runPreCheckout()) {\r\n        return new Environment() {\r\n        };\r\n    } else {\r\n        final Context c = new Context();\r\n        setUp(c, build, build.getWorkspace(), launcher, listener, build.getEnvironment(listener));\r\n        return new EnvironmentWrapper(c, launcher);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprIterator.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    super.fixupVariables(vars, globalsSize);\r\n    m_expr.fixupVariables(vars, globalsSize);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.WriterToASCI.getOutputStream",
	"Comment": "get the output stream where the events will be serialized to.",
	"Method": "OutputStream getOutputStream(){\r\n    return m_os;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.TransformerFactoryImpl.newXMLFilter",
	"Comment": "create an xmlfilter that uses the given source as thetransformation instructions.",
	"Method": "XMLFilter newXMLFilter(Source src,XMLFilter newXMLFilter,Templates templates){\r\n    try {\r\n        return new TrAXFilter(templates);\r\n    } catch (TransformerConfigurationException ex) {\r\n        if (m_errorListener != null) {\r\n            try {\r\n                m_errorListener.fatalError(ex);\r\n                return null;\r\n            } catch (TransformerConfigurationException ex1) {\r\n                throw ex1;\r\n            } catch (TransformerException ex1) {\r\n                throw new TransformerConfigurationException(ex1);\r\n            }\r\n        }\r\n        throw ex;\r\n    }\r\n}"
}, {
	"Path": "hudson.security.HudsonPrivateSecurityRealm.createAccount",
	"Comment": "creates a new user account by registering a password to the user.",
	"Method": "User createAccount(StaplerRequest req,StaplerResponse rsp,boolean validateCaptcha,String formView,User createAccount,SignupInfo si,User createAccount,String userName,String password){\r\n    User user = User.getById(userName, true);\r\n    user.addProperty(Details.fromPlainPassword(password));\r\n    return user;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemNumber.int2singlealphaCount",
	"Comment": "convert a long integer into alphabetic counting, in other wordscount using the sequence a b c ... z.",
	"Method": "String int2singlealphaCount(long val,CharArrayWrapper table){\r\n    int radix = table.getLength();\r\n    if (val > radix) {\r\n        return getZeroString();\r\n    } else\r\n        return (new Character(table.getChar((int) val - 1))).toString();\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetComposed.getImportCountComposed",
	"Comment": "get the precedence of this stylesheet in the global import list.the lowest precedence is 0.a higher number has a higher precedence.",
	"Method": "int getImportCountComposed(){\r\n    return m_importCountComposed;\r\n}"
}, {
	"Path": "jadx.core.dex.instructions.args.RegisterArg.getConstValue",
	"Comment": "return constant value from register assign or null if not constant",
	"Method": "Object getConstValue(DexNode dex){\r\n    InsnNode parInsn = getAssignInsn();\r\n    if (parInsn == null) {\r\n        return null;\r\n    }\r\n    return InsnUtils.getConstValueByInsn(dex, parInsn);\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerIdentityImpl.unparsedEntityDecl",
	"Comment": "receive notification of an unparsed entity declaration.by default, do nothing.application writers may override thismethod in a subclass to keep track of the unparsed entitiesdeclared in a document.",
	"Method": "void unparsedEntityDecl(String name,String publicId,String systemId,String notationName){\r\n    if (null != m_resultDTDHandler)\r\n        m_resultDTDHandler.unparsedEntityDecl(name, publicId, systemId, notationName);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.getDTMIDs",
	"Comment": "query which dtmids this dtm is currently using within the dtmmanager.\t %revew% should this become part of the base dtm api?",
	"Method": "SuballocatedIntVector getDTMIDs(){\r\n    if (m_mgr == null)\r\n        return null;\r\n    return m_dtmIdent;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.Counter.getPreviouslyCounted",
	"Comment": "try and find a node that was previously counted. if found,return a positive integer that corresponds to the count.",
	"Method": "int getPreviouslyCounted(XPathContext support,int node){\r\n    int n = m_countNodes.size();\r\n    m_countResult = 0;\r\n    for (int i = n - 1; i >= 0; i--) {\r\n        int countedNode = m_countNodes.elementAt(i);\r\n        if (node == countedNode) {\r\n            m_countResult = i + 1 + m_countNodesStartCount;\r\n            break;\r\n        }\r\n        DTM dtm = support.getDTM(countedNode);\r\n        if (dtm.isNodeAfter(countedNode, node))\r\n            break;\r\n    }\r\n    return m_countResult;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMNodeProxy.getDomConfig",
	"Comment": "the configuration used when document.normalizedocument isinvoked.",
	"Method": "DOMConfiguration getDomConfig(){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncUnparsedEntityURI.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    String name = m_arg0.execute(xctxt).str();\r\n    int context = xctxt.getCurrentNode();\r\n    DTM dtm = xctxt.getDTM(context);\r\n    int doc = dtm.getDocument();\r\n    String uri = dtm.getUnparsedEntityURI(name);\r\n    return new XString(uri);\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLStringDefault.getChars",
	"Comment": "copies characters from this string into the destination characterarray.",
	"Method": "void getChars(int srcBegin,int srcEnd,char dst,int dstBegin){\r\n    int destIndex = dstBegin;\r\n    for (int i = srcBegin; i < srcEnd; i++) {\r\n        dst[destIndex++] = m_str.charAt(i);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.StylesheetPIHandler.setBaseId",
	"Comment": "added additional getter and setter methods for the base id to fix bugzilla bug 24187",
	"Method": "void setBaseId(String baseId){\r\n    m_baseID = baseId;\r\n}"
}, {
	"Path": "hudson.model.labels.LabelAtomPropertyTest.configRoundtrip",
	"Comment": "tests the configuration persistence between disk, memory, and ui.",
	"Method": "void configRoundtrip(){\r\n    LabelAtom foo = j.jenkins.getLabelAtom(\"foo\");\r\n    LabelAtomPropertyImpl old = new LabelAtomPropertyImpl(\"value\");\r\n    foo.getProperties().add(old);\r\n    assertTrue(foo.getConfigFile().exists());\r\n    foo.load();\r\n    j.submit(j.createWebClient().goTo(\"label/foo/configure\").getFormByName(\"config\"));\r\n    assertEquals(1, foo.getProperties().size());\r\n    j.assertEqualDataBoundBeans(old, foo.getProperties().get(LabelAtomPropertyImpl.class));\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.dom2dtm.DOM2DTMdefaultNamespaceDeclarationNode.isSameNode",
	"Comment": "returns whether this node is the same node as the given one.this method provides a way to determine whether twonode references returned by the implementation referencethe same object. when two node references are referencesto the same object, even if through a proxy, the references may beused completely interchangably, such that all attributes have thesame values and calling the same dom method on either referencealways has exactly the same effect.",
	"Method": "boolean isSameNode(Node other){\r\n    return this == other;\r\n}"
}, {
	"Path": "hudson.PluginManager.getLastErrorCheckUpdateCenters",
	"Comment": "returns the last error raised during the update sites checking.",
	"Method": "String getLastErrorCheckUpdateCenters(){\r\n    return lastErrorCheckUpdateCenters;\r\n}"
}, {
	"Path": "com.squareup.javapoet.LineWrapper.flush",
	"Comment": "write the space followed by any buffered text that follows it.",
	"Method": "void flush(FlushType flushType){\r\n    switch(flushType) {\r\n        case WRAP:\r\n            out.append('\\n');\r\n            for (int i = 0; i < indentLevel; i++) {\r\n                out.append(indent);\r\n            }\r\n            column = indentLevel * indent.length();\r\n            column += buffer.length();\r\n            break;\r\n        case SPACE:\r\n            out.append(' ');\r\n            break;\r\n        case EMPTY:\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown FlushType: \" + flushType);\r\n    }\r\n    out.append(buffer);\r\n    buffer.delete(0, buffer.length());\r\n    indentLevel = -1;\r\n    nextFlush = null;\r\n}"
}, {
	"Path": "hudson.util.ConsistentHashTest.basic",
	"Comment": "just some random tests to ensure that we have no silly npe or that kind of error.",
	"Method": "void basic(){\r\n    ConsistentHash<String> hash = new ConsistentHash<String>();\r\n    hash.add(\"data1\");\r\n    hash.add(\"data2\");\r\n    hash.add(\"data3\");\r\n    System.out.println(hash.lookup(0));\r\n    String x = hash.lookup(Integer.MIN_VALUE);\r\n    String y = hash.lookup(Integer.MAX_VALUE);\r\n    assertEquals(x, y);\r\n    Iterator<String> itr = hash.list(Integer.MIN_VALUE).iterator();\r\n    Set<String> all = new HashSet<String>();\r\n    String z = itr.next();\r\n    all.add(z);\r\n    assertEquals(z, x);\r\n    all.add(itr.next());\r\n    all.add(itr.next());\r\n    assertTrue(!itr.hasNext());\r\n    assertEquals(3, all.size());\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetComposed.recomposeImports",
	"Comment": "recalculate the precedence of this stylesheet in the globalimport list.the lowest precedence stylesheet is 0.a highernumber has a higher precedence.",
	"Method": "void recomposeImports(){\r\n    m_importNumber = getStylesheetRoot().getImportNumber(this);\r\n    StylesheetRoot root = getStylesheetRoot();\r\n    int globalImportCount = root.getGlobalImportCount();\r\n    m_importCountComposed = (globalImportCount - m_importNumber) - 1;\r\n    int count = getImportCount();\r\n    if (count > 0) {\r\n        m_endImportCountComposed += count;\r\n        while (count > 0) m_endImportCountComposed += this.getImport(--count).getEndImportCountComposed();\r\n    }\r\n    count = getIncludeCountComposed();\r\n    while (count > 0) {\r\n        int imports = getIncludeComposed(--count).getImportCount();\r\n        m_endImportCountComposed += imports;\r\n        while (imports > 0) m_endImportCountComposed += getIncludeComposed(count).getImport(--imports).getEndImportCountComposed();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.XML11Char.isXML11Valid",
	"Comment": "returns true if the specified character is valid. this methodalso checks the surrogate character range from 0x10000 to 0x10ffff.if the program chooses to apply the mask directly to thexml11chars array, then they are responsible for checkingthe surrogate character range.",
	"Method": "boolean isXML11Valid(int c){\r\n    return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_VALID) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "hudson.security.csrf.CrumbIssuer.getCrumb",
	"Comment": "get a crumb value based on user specific information in the request.",
	"Method": "String getCrumb(String getCrumb,ServletRequest request){\r\n    String crumb = null;\r\n    if (request != null) {\r\n        crumb = (String) request.getAttribute(CRUMB_ATTRIBUTE);\r\n    }\r\n    if (crumb == null) {\r\n        crumb = issueCrumb(request, getDescriptor().getCrumbSalt());\r\n        if (request != null) {\r\n            if ((crumb != null) && crumb.length() > 0) {\r\n                request.setAttribute(CRUMB_ATTRIBUTE, crumb);\r\n            } else {\r\n                request.removeAttribute(CRUMB_ATTRIBUTE);\r\n            }\r\n        }\r\n    }\r\n    return crumb;\r\n}"
}, {
	"Path": "com.sun.jna.contrib.demo.FilteredTextField.setMaximumLength",
	"Comment": "sets the maximum number of characters for the length of the entry string.",
	"Method": "void setMaximumLength(int maximumLength){\r\n    this.maximumLength = maximumLength;\r\n}"
}, {
	"Path": "hudson.model.UpdateCenter.persistInstallStatus",
	"Comment": "called to persist the currently installing plugin states. this allowsus to support install resume if jenkins is restarted while plugins arebeing installed.",
	"Method": "void persistInstallStatus(){\r\n    List<UpdateCenterJob> jobs = getJobs();\r\n    boolean activeInstalls = false;\r\n    for (UpdateCenterJob job : jobs) {\r\n        if (job instanceof InstallationJob) {\r\n            InstallationJob installationJob = (InstallationJob) job;\r\n            if (!installationJob.status.isSuccess()) {\r\n                activeInstalls = true;\r\n            }\r\n        }\r\n    }\r\n    if (activeInstalls) {\r\n        InstallUtil.persistInstallStatus(jobs);\r\n    } else {\r\n        InstallUtil.clearInstallStatus();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncCeiling.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    return new XNumber(Math.ceil(m_arg0.execute(xctxt).num()));\r\n}"
}, {
	"Path": "org.apache.xalan.xslt.EnvironmentCheck.checkSAXVersion",
	"Comment": "report version info from sax interfaces. currently distinguishes between sax 2, sax 2.0beta2, sax1, and not found.",
	"Method": "void checkSAXVersion(Hashtable h){\r\n    if (null == h)\r\n        h = new Hashtable();\r\n    final String SAX_VERSION1_CLASS = \"org.xml.sax.Parser\";\r\n    final String SAX_VERSION1_METHOD = \"parse\";\r\n    final String SAX_VERSION2_CLASS = \"org.xml.sax.XMLReader\";\r\n    final String SAX_VERSION2_METHOD = \"parse\";\r\n    final String SAX_VERSION2BETA_CLASSNF = \"org.xml.sax.helpers.AttributesImpl\";\r\n    final String SAX_VERSION2BETA_METHODNF = \"setAttributes\";\r\n    final Class[] oneStringArg = { java.lang.String.class };\r\n    final Class[] attributesArg = { org.xml.sax.Attributes.class };\r\n    try {\r\n        Class clazz = ObjectFactory.findProviderClass(SAX_VERSION2BETA_CLASSNF, ObjectFactory.findClassLoader(), true);\r\n        Method method = clazz.getMethod(SAX_VERSION2BETA_METHODNF, attributesArg);\r\n        h.put(VERSION + \"SAX\", \"2.0\");\r\n    } catch (Exception e) {\r\n        h.put(ERROR + VERSION + \"SAX\", \"ERROR attempting to load SAX version 2 class: \" + e.toString());\r\n        h.put(ERROR, ERROR_FOUND);\r\n        try {\r\n            Class clazz = ObjectFactory.findProviderClass(SAX_VERSION2_CLASS, ObjectFactory.findClassLoader(), true);\r\n            Method method = clazz.getMethod(SAX_VERSION2_METHOD, oneStringArg);\r\n            h.put(VERSION + \"SAX-backlevel\", \"2.0beta2-or-earlier\");\r\n        } catch (Exception e2) {\r\n            h.put(ERROR + VERSION + \"SAX\", \"ERROR attempting to load SAX version 2 class: \" + e.toString());\r\n            h.put(ERROR, ERROR_FOUND);\r\n            try {\r\n                Class clazz = ObjectFactory.findProviderClass(SAX_VERSION1_CLASS, ObjectFactory.findClassLoader(), true);\r\n                Method method = clazz.getMethod(SAX_VERSION1_METHOD, oneStringArg);\r\n                h.put(VERSION + \"SAX-backlevel\", \"1.0\");\r\n            } catch (Exception e3) {\r\n                h.put(ERROR + VERSION + \"SAX-backlevel\", \"ERROR attempting to load SAX version 1 class: \" + e3.toString());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMChildIterNodeList.item",
	"Comment": "returns the indexth item in the collection. if index is greater than or equal to the number of nodes in the list, this returns null.",
	"Method": "Node item(int index){\r\n    int handle = m_firstChild;\r\n    while (--index >= 0 && handle != DTM.NULL) {\r\n        handle = m_parentDTM.getNextSibling(handle);\r\n    }\r\n    if (handle == DTM.NULL) {\r\n        return null;\r\n    }\r\n    return m_parentDTM.getNode(handle);\r\n}"
}, {
	"Path": "hudson.os.solaris.ZFSInstaller.doStart",
	"Comment": "called from the confirmation screen to actually initiate the migration.",
	"Method": "void doStart(StaplerRequest req,StaplerResponse rsp,String username,String password){\r\n    Jenkins hudson = Jenkins.getInstance();\r\n    hudson.checkPermission(Jenkins.ADMINISTER);\r\n    final String datasetName;\r\n    ByteArrayOutputStream log = new ByteArrayOutputStream();\r\n    StreamTaskListener listener = new StreamTaskListener(log);\r\n    try {\r\n        datasetName = createZfsFileSystem(listener, username, password);\r\n    } catch (Exception e) {\r\n        Functions.printStackTrace(e, listener.error(e.getMessage()));\r\n        if (e instanceof ZFSException) {\r\n            ZFSException ze = (ZFSException) e;\r\n            if (ze.getCode() == ErrorCode.EZFS_PERM) {\r\n                req.setAttribute(\"message\", log.toString());\r\n                rsp.forward(this, \"askRootPassword\", req);\r\n                return;\r\n            }\r\n        }\r\n        req.setAttribute(\"pre\", true);\r\n        sendError(log.toString(), req, rsp);\r\n        return;\r\n    }\r\n    hudson.servletContext.setAttribute(\"app\", new HudsonIsRestarting());\r\n    rsp.sendRedirect2(req.getContextPath() + \"/manage\");\r\n    new Thread(\"restart thread\") {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                Thread.sleep(5000);\r\n                int sz = LIBC.getdtablesize();\r\n                for (int i = 3; i < sz; i++) {\r\n                    int flags = LIBC.fcntl(i, F_GETFD);\r\n                    if (flags < 0)\r\n                        continue;\r\n                    LIBC.fcntl(i, F_SETFD, flags | FD_CLOEXEC);\r\n                }\r\n                JavaVMArguments args = JavaVMArguments.current();\r\n                args.setSystemProperty(ZFSInstaller.class.getName() + \".migrate\", datasetName);\r\n                Daemon.selfExec(args);\r\n            } catch (InterruptedException | IOException e) {\r\n                LOGGER.log(Level.SEVERE, \"Restart failed\", e);\r\n            }\r\n        }\r\n    }.start();\r\n}"
}, {
	"Path": "hudson.os.solaris.ZFSInstaller.doStart",
	"Comment": "called from the confirmation screen to actually initiate the migration.",
	"Method": "void doStart(StaplerRequest req,StaplerResponse rsp,String username,String password){\r\n    try {\r\n        Thread.sleep(5000);\r\n        int sz = LIBC.getdtablesize();\r\n        for (int i = 3; i < sz; i++) {\r\n            int flags = LIBC.fcntl(i, F_GETFD);\r\n            if (flags < 0)\r\n                continue;\r\n            LIBC.fcntl(i, F_SETFD, flags | FD_CLOEXEC);\r\n        }\r\n        JavaVMArguments args = JavaVMArguments.current();\r\n        args.setSystemProperty(ZFSInstaller.class.getName() + \".migrate\", datasetName);\r\n        Daemon.selfExec(args);\r\n    } catch (InterruptedException | IOException e) {\r\n        LOGGER.log(Level.SEVERE, \"Restart failed\", e);\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.threadpool.TaskTest.testTimeMs",
	"Comment": "verify if the time per execution of a task matches the actual time required to execute the taska given number of times",
	"Method": "void testTimeMs(){\r\n    for (int i = 0; i < 10; i++) {\r\n        assertEquals(this.expectedExecutionTime * i, this.factory.apply(i).getTimeMs());\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.promise.App.lowestFrequencyChar",
	"Comment": "calculate the character frequency of a file and when that promise is fulfilled,then promise to apply function to calculate lowest character frequency.",
	"Method": "Promise<Character> lowestFrequencyChar(){\r\n    return characterFrequency().thenApply(Utility::lowestFrequencyChar);\r\n}"
}, {
	"Path": "hudson.model.QueueTest.permissionSensitiveSlaveAllocations",
	"Comment": "make sure that the slave assignment honors the permissions.we do this test by letting a build run twice to determine its natural home,and then introduce a security restriction to prohibit that.",
	"Method": "void permissionSensitiveSlaveAllocations(){\r\n    r.jenkins.setNumExecutors(0);\r\n    DumbSlave s1 = r.createSlave();\r\n    DumbSlave s2 = r.createSlave();\r\n    FreeStyleProject p = r.createFreeStyleProject();\r\n    QueueItemAuthenticatorConfiguration.get().getAuthenticators().add(new MockQueueItemAuthenticator(Collections.singletonMap(p.getFullName(), alice)));\r\n    p.getBuildersList().add(new TestBuilder() {\r\n        @Override\r\n        public boolean perform(AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) throws InterruptedException, IOException {\r\n            assertEquals(alice, Jenkins.getAuthentication());\r\n            return true;\r\n        }\r\n    });\r\n    final FreeStyleBuild b1 = r.assertBuildStatusSuccess(p.scheduleBuild2(0));\r\n    final FreeStyleBuild b2 = r.assertBuildStatusSuccess(p.scheduleBuild2(0));\r\n    r.jenkins.setAuthorizationStrategy(new AliceCannotBuild(b1.getBuiltOnStr()));\r\n    for (int i = 0; i < 3; i++) {\r\n        FreeStyleBuild b3 = r.assertBuildStatusSuccess(p.scheduleBuild2(0));\r\n        assertNotSame(b3.getBuiltOnStr(), b1.getBuiltOnStr());\r\n    }\r\n}"
}, {
	"Path": "hudson.model.QueueTest.permissionSensitiveSlaveAllocations",
	"Comment": "make sure that the slave assignment honors the permissions.we do this test by letting a build run twice to determine its natural home,and then introduce a security restriction to prohibit that.",
	"Method": "void permissionSensitiveSlaveAllocations(){\r\n    assertEquals(alice, Jenkins.getAuthentication());\r\n    return true;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.api.JibContainer.getImageId",
	"Comment": "gets the digest of the container configuration built by jib.",
	"Method": "DescriptorDigest getImageId(){\r\n    return imageId;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.DOM3SerializerImpl.setSerializationHandler",
	"Comment": "sets a serializationhandler on the dom serializer.this interface is a public api.",
	"Method": "void setSerializationHandler(SerializationHandler handler){\r\n    fSerializationHandler = handler;\r\n}"
}, {
	"Path": "org.apache.xpath.XPath.callVisitors",
	"Comment": "this will traverse the heararchy, calling the visitor for each member.if the called visitor method returns false, the subtree should not be called.",
	"Method": "void callVisitors(ExpressionOwner owner,XPathVisitor visitor){\r\n    m_mainExp.callVisitors(this, visitor);\r\n}"
}, {
	"Path": "com.iluwatar.featuretoggle.pattern.tieredversion.TieredFeatureToggleVersion.isEnhanced",
	"Comment": "method that checks if the welcome message to be returned is the enhanced version. for this instance as the logicis driven by the user group. this method is a little redundant. however can be used to show that there is anenhanced version available.",
	"Method": "boolean isEnhanced(){\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.XMLChar.isSupplemental",
	"Comment": "returns true if the specified character is a supplemental character.",
	"Method": "boolean isSupplemental(int c){\r\n    return (c >= 0x10000 && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "redis.clients.jedis.BinaryJedis.monitor",
	"Comment": "dump all the received requests in real time.monitor is a debugging command that outputs the whole sequence of commands received by theredis server. is very handy in order to understand what is happening into the database. thiscommand is used directly via telnet.",
	"Method": "void monitor(JedisMonitor jedisMonitor){\r\n    client.monitor();\r\n    client.getStatusCodeReply();\r\n    jedisMonitor.proceed(client);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemLiteralResult.resolvePrefixTables",
	"Comment": "augment resolveprefixtables, resolving the namespace aliases oncethe superclass has resolved the tables.",
	"Method": "void resolvePrefixTables(){\r\n    super.resolvePrefixTables();\r\n    StylesheetRoot stylesheet = getStylesheetRoot();\r\n    if ((null != m_namespace) && (m_namespace.length() > 0)) {\r\n        NamespaceAlias nsa = stylesheet.getNamespaceAliasComposed(m_namespace);\r\n        if (null != nsa) {\r\n            m_namespace = nsa.getResultNamespace();\r\n            String resultPrefix = nsa.getStylesheetPrefix();\r\n            if ((null != resultPrefix) && (resultPrefix.length() > 0))\r\n                m_rawName = resultPrefix + \":\" + m_localName;\r\n            else\r\n                m_rawName = m_localName;\r\n        }\r\n    }\r\n    if (null != m_avts) {\r\n        int n = m_avts.size();\r\n        for (int i = 0; i < n; i++) {\r\n            AVT avt = (AVT) m_avts.get(i);\r\n            String ns = avt.getURI();\r\n            if ((null != ns) && (ns.length() > 0)) {\r\n                // %REVIEW% ns?\r\n                NamespaceAlias nsa = stylesheet.getNamespaceAliasComposed(m_namespace);\r\n                if (null != nsa) {\r\n                    String namespace = nsa.getResultNamespace();\r\n                    String resultPrefix = nsa.getStylesheetPrefix();\r\n                    String rawName = avt.getName();\r\n                    if ((null != resultPrefix) && (resultPrefix.length() > 0))\r\n                        rawName = resultPrefix + \":\" + rawName;\r\n                    avt.setURI(namespace);\r\n                    avt.setRawName(rawName);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.isDisplayNameUnique",
	"Comment": "this method checks all existing jobs to see if displayname isunique. it does not check the displayname against the displayname of thejob that the user is configuring though to prevent a validation warningif the user sets the displayname to what it currently is.",
	"Method": "boolean isDisplayNameUnique(String displayName,String currentJobName){\r\n    Collection<TopLevelItem> itemCollection = items.values();\r\n    for (TopLevelItem item : itemCollection) {\r\n        if (item.getName().equals(currentJobName)) {\r\n            continue;\r\n        } else if (displayName.equals(item.getDisplayName())) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.XML11Char.isXML11InternalEntityContent",
	"Comment": "returns true if the specified character can be considered content in an internal parsed entity.",
	"Method": "boolean isXML11InternalEntityContent(int c){\r\n    return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_CONTENT_INTERNAL) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.getInjector",
	"Comment": "gets the dependency injection container that hosts all the extension implementations and othercomponents in jenkins.",
	"Method": "Injector getInjector(){\r\n    return lookup(Injector.class);\r\n}"
}, {
	"Path": "com.iluwatar.datamapper.DataMapperTest.testFirstDataMapper",
	"Comment": "this test verify that first data mapper is able to perform all crud operations on student",
	"Method": "void testFirstDataMapper(){\r\n    final StudentDataMapper mapper = new StudentDataMapperImpl();\r\n    int studentId = 1;\r\n    Student student = new Student(studentId, \"Adam\", 'A');\r\n    mapper.insert(student);\r\n    assertEquals(studentId, mapper.find(student.getStudentId()).get().getStudentId());\r\n    String updatedName = \"AdamUpdated\";\r\n    student = new Student(student.getStudentId(), updatedName, 'A');\r\n    mapper.update(student);\r\n    assertEquals(updatedName, mapper.find(student.getStudentId()).get().getName());\r\n    mapper.delete(student);\r\n    assertFalse(mapper.find(student.getStudentId()).isPresent());\r\n}"
}, {
	"Path": "Sorts.SortAlgorithm.sort",
	"Comment": "auxiliary method for algorithms what wanted to work with lists from jcf",
	"Method": "T[] sort(T[] unsorted,List<T> sort,List<T> unsorted){\r\n    return Arrays.asList(sort(unsorted.toArray((T[]) new Comparable[unsorted.size()])));\r\n}"
}, {
	"Path": "hudson.model.Descriptor.getJsonSafeClassName",
	"Comment": "gets the class name nicely escaped to be usable as a key in the structured form submission.",
	"Method": "String getJsonSafeClassName(){\r\n    return getId().replace('.', '-');\r\n}"
}, {
	"Path": "jenkins.org.apache.commons.validator.routines.RegexValidator.validate",
	"Comment": "validate a value against the set of regular expressionsreturning a string value of the aggregated groups.",
	"Method": "String validate(String value){\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    for (int i = 0; i < patterns.length; i++) {\r\n        Matcher matcher = patterns[i].matcher(value);\r\n        if (matcher.matches()) {\r\n            int count = matcher.groupCount();\r\n            if (count == 1) {\r\n                return matcher.group(1);\r\n            }\r\n            StringBuilder buffer = new StringBuilder();\r\n            for (int j = 0; j < count; j++) {\r\n                String component = matcher.group(j + 1);\r\n                if (component != null) {\r\n                    buffer.append(component);\r\n                }\r\n            }\r\n            return buffer.toString();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.XPathParser.appendOp",
	"Comment": "insert room for operation.this will setthe length value of the operation, and will updatethe length value for the total expression.",
	"Method": "void appendOp(int length,int op){\r\n    int totalLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH);\r\n    m_ops.setOp(totalLen, op);\r\n    m_ops.setOp(totalLen + OpMap.MAPINDEX_LENGTH, length);\r\n    m_ops.setOp(OpMap.MAPINDEX_LENGTH, totalLen + length);\r\n}"
}, {
	"Path": "hudson.model.QueueTest.accessControl",
	"Comment": "make sure that the running build actually carries an credential.",
	"Method": "void accessControl(){\r\n    FreeStyleProject p = r.createFreeStyleProject();\r\n    QueueItemAuthenticatorConfiguration.get().getAuthenticators().add(new MockQueueItemAuthenticator(Collections.singletonMap(p.getFullName(), alice)));\r\n    p.getBuildersList().add(new TestBuilder() {\r\n        @Override\r\n        public boolean perform(AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) throws InterruptedException, IOException {\r\n            assertEquals(alice, Jenkins.getAuthentication());\r\n            return true;\r\n        }\r\n    });\r\n    r.assertBuildStatusSuccess(p.scheduleBuild2(0));\r\n}"
}, {
	"Path": "hudson.model.QueueTest.accessControl",
	"Comment": "make sure that the running build actually carries an credential.",
	"Method": "void accessControl(){\r\n    assertEquals(alice, Jenkins.getAuthentication());\r\n    return true;\r\n}"
}, {
	"Path": "jenkins.security.apitoken.ApiTokenStore.renameToken",
	"Comment": "given a token identifier and a name, the system will try to find a corresponding token and rename it",
	"Method": "boolean renameToken(String tokenUuid,String newName){\r\n    for (HashedToken token : tokenList) {\r\n        if (token.uuid.equals(tokenUuid)) {\r\n            token.rename(newName);\r\n            return true;\r\n        }\r\n    }\r\n    LOGGER.log(Level.FINER, \"The target token for rename does not exist, for uuid = {0}, with desired name = {1}\", new Object[] { tokenUuid, newName });\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.WalkingIterator.setRoot",
	"Comment": "initialize the context values for this expressionafter it is cloned.",
	"Method": "void setRoot(int context,Object environment){\r\n    super.setRoot(context, environment);\r\n    if (null != m_firstWalker) {\r\n        m_firstWalker.setRoot(context);\r\n        m_lastUsedWalker = m_firstWalker;\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.tls.DateFormatCallableTestIncorrectDateFormat.testCounterDateValues",
	"Comment": "test number of dates in the list after the run of dateformatrunnalbe. a correct run should deliver no date values",
	"Method": "void testCounterDateValues(){\r\n    assertEquals(expectedCounterDateValues, result.getDateList().size());\r\n}"
}, {
	"Path": "hudson.Util.loadFile",
	"Comment": "reads the entire contents of the text file at logfile into astring using charset for decoding. if no such file exists,an empty string is returned.",
	"Method": "String loadFile(File logfile,String loadFile,File logfile,Charset charset){\r\n    try {\r\n        return FileUtils.readFileToString(logfile, charset);\r\n    } catch (FileNotFoundException e) {\r\n        return \"\";\r\n    } catch (Exception e) {\r\n        throw new IOException(\"Failed to fully read \" + logfile, e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.serializer.WriterToUTF8Buffered.getOutputStream",
	"Comment": "get the output stream where the events will be serialized to.",
	"Method": "OutputStream getOutputStream(){\r\n    return m_os;\r\n}"
}, {
	"Path": "com.sun.jna.contrib.demo.FilteredTextField.setValidError",
	"Comment": "sets the message that is displayed when there is a validation error.",
	"Method": "void setValidError(String validError){\r\n    this.validError = validError;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2RTFDTM._documentRoot",
	"Comment": "given a node identifier, find the owning document node.unlike the dom,this considers the owningdocument of a document to be itself. note thatin shared dtms this may not be zero.",
	"Method": "int _documentRoot(int nodeIdentifier){\r\n    if (nodeIdentifier == NULL)\r\n        return NULL;\r\n    for (int parent = _parent(nodeIdentifier); parent != NULL; nodeIdentifier = parent, parent = _parent(nodeIdentifier)) ;\r\n    return nodeIdentifier;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemVariablePsuedo.execute",
	"Comment": "execute a variable declaration and push it onto the variable stack.",
	"Method": "void execute(TransformerImpl transformer){\r\n    transformer.getXPathContext().getVarStack().setLocalVariable(m_index, m_lazyVar);\r\n}"
}, {
	"Path": "com.iluwatar.datamapper.StudentTest.testEquality",
	"Comment": "this api tests the equality behaviour of student objectobject equality should work as per logic defined in equals method",
	"Method": "void testEquality(){\r\n    final Student firstStudent = new Student(1, \"Adam\", 'A');\r\n    final Student secondStudent = new Student(2, \"Donald\", 'B');\r\n    final Student secondSameStudent = new Student(2, \"Donald\", 'B');\r\n    assertEquals(firstStudent, firstStudent);\r\n    assertNotEquals(firstStudent, secondStudent);\r\n    assertEquals(secondStudent, secondSameStudent);\r\n}"
}, {
	"Path": "org.apache.xpath.axes.WalkingIterator.getAnalysisBits",
	"Comment": "get the analysis bits for this walker, as defined in the walkerfactory.",
	"Method": "int getAnalysisBits(){\r\n    int bits = 0;\r\n    if (null != m_firstWalker) {\r\n        AxesWalker walker = m_firstWalker;\r\n        while (null != walker) {\r\n            int bit = walker.getAnalysisBits();\r\n            bits |= bit;\r\n            walker = walker.getNextWalker();\r\n        }\r\n    }\r\n    return bits;\r\n}"
}, {
	"Path": "hudson.model.ItemGroupMixInTest.xmlFileReadExceptionOnLoad",
	"Comment": "this test unit makes sure that jobs that contain bad getaction methods will continue toload the project.",
	"Method": "void xmlFileReadExceptionOnLoad(){\r\n    MockFolder d = r.jenkins.getItemByFullName(\"d\", MockFolder.class);\r\n    assertNotNull(d);\r\n    Collection<TopLevelItem> items = d.getItems();\r\n    assertEquals(5, items.size());\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemUnknown.execute",
	"Comment": "execute an unknown element.execute fallback if fallback child exists or do nothing",
	"Method": "void execute(TransformerImpl transformer){\r\n    try {\r\n        if (hasFallbackChildren()) {\r\n            executeFallbacks(transformer);\r\n        } else {\r\n        }\r\n    } catch (TransformerException e) {\r\n        transformer.getErrorListener().fatalError(e);\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.doubledispatch.CollisionTest.testOnFire",
	"Comment": "test if the fire state of the target matches the expected state after colliding with the givenobject",
	"Method": "void testOnFire(GameObject target,GameObject other,boolean expectTargetOnFire){\r\n    final String targetName = target.getClass().getSimpleName();\r\n    final String otherName = other.getClass().getSimpleName();\r\n    final String errorMessage = expectTargetOnFire ? \"Expected [\" + targetName + \"] to be on fire after colliding with [\" + otherName + \"] but it was not!\" : \"Expected [\" + targetName + \"] not to be on fire after colliding with [\" + otherName + \"] but it was!\";\r\n    assertEquals(expectTargetOnFire, target.isOnFire(), errorMessage);\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncLocalPart.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    int context = getArg0AsNode(xctxt);\r\n    if (DTM.NULL == context)\r\n        return XString.EMPTYSTRING;\r\n    DTM dtm = xctxt.getDTM(context);\r\n    String s = (context != DTM.NULL) ? dtm.getLocalName(context) : \"\";\r\n    if (s.startsWith(\"#\") || s.equals(\"xmlns\"))\r\n        return XString.EMPTYSTRING;\r\n    return new XString(s);\r\n}"
}, {
	"Path": "hudson.model.AsyncPeriodicWork.getLogFile",
	"Comment": "determines the log file that records the result of this task.",
	"Method": "File getLogFile(){\r\n    return new File(getLogsRoot(), \"/tasks/\" + name + \".log\");\r\n}"
}, {
	"Path": "hudson.model.Computer.doScriptText",
	"Comment": "run arbitrary groovy script and return result as plain text.",
	"Method": "void doScriptText(StaplerRequest req,StaplerResponse rsp){\r\n    _doScript(req, rsp, \"_scriptText.jelly\");\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.getExpandEntityReferences",
	"Comment": "the value of this flag determines whether the children of entityreference nodes are visible to the iterator. if false, they will beskipped over. to produce a view of the document that has entity referencesexpanded and does not expose the entity reference node itself, use thewhattoshow flags to hide the entity reference node and setexpandentityreferences to true when creating the iterator. to producea view of the document that has entity reference nodes but no entityexpansion, use the whattoshow flags to show the entity reference nodeand set expandentityreferences to false.",
	"Method": "boolean getExpandEntityReferences(){\r\n    return true;\r\n}"
}, {
	"Path": "org.java_websocket.client.WebSocketClient.setSocketFactory",
	"Comment": "accepts a socketfactory.\tthis method must be called before connect.\tthe socket will be bound to the uri specified in the constructor.",
	"Method": "void setSocketFactory(SocketFactory socketFactory){\r\n    this.socketFactory = socketFactory;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.Encodings.isHighUTF16Surrogate",
	"Comment": "return true if the character is the high member of a surrogate pair.this is not a public api.",
	"Method": "boolean isHighUTF16Surrogate(char ch){\r\n    return ('?' <= ch && ch <= '?');\r\n}"
}, {
	"Path": "hudson.model.Node.getNodeProperty",
	"Comment": "gets the property from the given classname or null if the property is not configured for this node.",
	"Method": "T getNodeProperty(Class<T> clazz,NodeProperty getNodeProperty,String className){\r\n    for (NodeProperty p : getNodeProperties()) {\r\n        if (p.getClass().getName().equals(className)) {\r\n            return p;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMManagerDefault.getFirstFreeDTMID",
	"Comment": "get the first free dtm id available. %opt% linear search is inefficient!",
	"Method": "int getFirstFreeDTMID(){\r\n    int n = m_dtms.length;\r\n    for (int i = 1; i < n; i++) {\r\n        if (null == m_dtms[i]) {\r\n            return i;\r\n        }\r\n    }\r\n    return n;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.TemplateList.getTemplateFast",
	"Comment": "given a target element, find the template that bestmatches in the given xsl document, accordingto the rules specified in the xsl draft.this variation of gettemplate assumes the current node and current expression node have already been pushed.",
	"Method": "ElemTemplate getTemplateFast(XPathContext xctxt,int targetNode,int expTypeID,QName mode,int maxImportLevel,boolean quietConflictWarnings,DTM dtm){\r\n    TemplateSubPatternAssociation head;\r\n    switch(dtm.getNodeType(targetNode)) {\r\n        case DTM.ELEMENT_NODE:\r\n        case DTM.ATTRIBUTE_NODE:\r\n            head = (TemplateSubPatternAssociation) m_patternTable.get(dtm.getLocalNameFromExpandedNameID(expTypeID));\r\n            break;\r\n        case DTM.TEXT_NODE:\r\n        case DTM.CDATA_SECTION_NODE:\r\n            head = m_textPatterns;\r\n            break;\r\n        case DTM.ENTITY_REFERENCE_NODE:\r\n        case DTM.ENTITY_NODE:\r\n            head = (TemplateSubPatternAssociation) // %REVIEW% I think this is right\r\n            m_patternTable.get(dtm.getNodeName(targetNode));\r\n            break;\r\n        case DTM.PROCESSING_INSTRUCTION_NODE:\r\n            head = (TemplateSubPatternAssociation) m_patternTable.get(dtm.getLocalName(targetNode));\r\n            break;\r\n        case DTM.COMMENT_NODE:\r\n            head = m_commentPatterns;\r\n            break;\r\n        case DTM.DOCUMENT_NODE:\r\n        case DTM.DOCUMENT_FRAGMENT_NODE:\r\n            head = m_docPatterns;\r\n            break;\r\n        case DTM.NOTATION_NODE:\r\n        default:\r\n            head = (TemplateSubPatternAssociation) // %REVIEW% I think this is right\r\n            m_patternTable.get(dtm.getNodeName(targetNode));\r\n    }\r\n    if (null == head) {\r\n        head = m_wildCardPatterns;\r\n        if (null == head)\r\n            return null;\r\n    }\r\n    xctxt.pushNamespaceContextNull();\r\n    try {\r\n        do {\r\n            if ((maxImportLevel > -1) && (head.getImportLevel() > maxImportLevel)) {\r\n                continue;\r\n            }\r\n            ElemTemplate template = head.getTemplate();\r\n            xctxt.setNamespaceContext(template);\r\n            if ((head.m_stepPattern.execute(xctxt, targetNode, dtm, expTypeID) != NodeTest.SCORE_NONE) && head.matchMode(mode)) {\r\n                if (quietConflictWarnings)\r\n                    checkConflicts(head, xctxt, targetNode, mode);\r\n                return template;\r\n            }\r\n        } while (null != (head = head.getNext()));\r\n    } finally {\r\n        xctxt.popNamespaceContext();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "redis.clients.jedis.tests.SSLJedisTest.createTrustNoOneSslSocketFactory",
	"Comment": "creates an sslsocketfactory with a trust manager that does not trust anycertificates.",
	"Method": "SSLSocketFactory createTrustNoOneSslSocketFactory(){\r\n    TrustManager[] unTrustManagers = new TrustManager[] { new X509TrustManager() {\r\n        public X509Certificate[] getAcceptedIssuers() {\r\n            return new X509Certificate[0];\r\n        }\r\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {\r\n            throw new RuntimeException(new InvalidAlgorithmParameterException());\r\n        }\r\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {\r\n            throw new RuntimeException(new InvalidAlgorithmParameterException());\r\n        }\r\n    } };\r\n    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\r\n    sslContext.init(null, unTrustManagers, new SecureRandom());\r\n    return sslContext.getSocketFactory();\r\n}"
}, {
	"Path": "redis.clients.jedis.tests.SSLJedisTest.createTrustNoOneSslSocketFactory",
	"Comment": "creates an sslsocketfactory with a trust manager that does not trust anycertificates.",
	"Method": "SSLSocketFactory createTrustNoOneSslSocketFactory(){\r\n    return new X509Certificate[0];\r\n}"
}, {
	"Path": "redis.clients.jedis.tests.SSLJedisTest.createTrustNoOneSslSocketFactory",
	"Comment": "creates an sslsocketfactory with a trust manager that does not trust anycertificates.",
	"Method": "SSLSocketFactory createTrustNoOneSslSocketFactory(){\r\n    throw new RuntimeException(new InvalidAlgorithmParameterException());\r\n}"
}, {
	"Path": "redis.clients.jedis.tests.SSLJedisTest.createTrustNoOneSslSocketFactory",
	"Comment": "creates an sslsocketfactory with a trust manager that does not trust anycertificates.",
	"Method": "SSLSocketFactory createTrustNoOneSslSocketFactory(){\r\n    throw new RuntimeException(new InvalidAlgorithmParameterException());\r\n}"
}, {
	"Path": "redis.clients.jedis.Jedis.getbit",
	"Comment": "returns the bit value at offset in the string value stored at key",
	"Method": "Boolean getbit(String key,long offset){\r\n    checkIsInMultiOrPipeline();\r\n    client.getbit(key, offset);\r\n    return client.getIntegerReply() == 1;\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XRTreeFrag.getTypeString",
	"Comment": "given a request type, return the equivalent string.for diagnostic purposes.",
	"Method": "String getTypeString(){\r\n    return \"#RTREEFRAG\";\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemLiteralResult.setIsLiteralResultAsStylesheet",
	"Comment": "set whether this element represents a root elementthat is also the stylesheet element.",
	"Method": "void setIsLiteralResultAsStylesheet(boolean b){\r\n    isLiteralResultAsStylesheet = b;\r\n}"
}, {
	"Path": "org.apache.xml.utils.NodeVector.setTail",
	"Comment": "set the tail of the stack to the given node.special purpose method for transformerimpl, pushelemtemplateelement.performance critical.",
	"Method": "void setTail(int n){\r\n    m_map[m_firstFree - 1] = n;\r\n}"
}, {
	"Path": "redis.clients.jedis.BinaryJedis.setbit",
	"Comment": "sets or clears the bit at offset in the string value stored at key",
	"Method": "Boolean setbit(byte[] key,long offset,boolean value,Boolean setbit,byte[] key,long offset,byte[] value){\r\n    checkIsInMultiOrPipeline();\r\n    client.setbit(key, offset, value);\r\n    return client.getIntegerReply() == 1;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.stepsEqual",
	"Comment": "compare a given number of steps between two iterators, to see if they are equal.",
	"Method": "boolean stepsEqual(WalkingIterator iter1,WalkingIterator iter2,int numSteps){\r\n    AxesWalker aw1 = iter1.getFirstWalker();\r\n    AxesWalker aw2 = iter2.getFirstWalker();\r\n    for (int i = 0; (i < numSteps); i++) {\r\n        if ((null == aw1) || (null == aw2))\r\n            return false;\r\n        if (!aw1.deepEquals(aw2))\r\n            return false;\r\n        aw1 = aw1.getNextWalker();\r\n        aw2 = aw2.getNextWalker();\r\n    }\r\n    assertion((null != aw1) || (null != aw2), \"Total match is incorrect!\");\r\n    return true;\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.getJarManifest",
	"Comment": "get the manifest from the given jar, if it is indeed a jar and it has amanifest",
	"Method": "Manifest getJarManifest(File container){\r\n    if (container.isDirectory()) {\r\n        return null;\r\n    }\r\n    JarFile jarFile = (JarFile) jarFiles.get(container);\r\n    if (jarFile == null) {\r\n        return null;\r\n    }\r\n    return jarFile.getManifest();\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.StepPattern.setRelativePathPattern",
	"Comment": "set the reference to nodetest and predicate forparent or ancestor.",
	"Method": "void setRelativePathPattern(StepPattern expr){\r\n    m_relativePathPattern = expr;\r\n    expr.exprSetParent(this);\r\n    calcScore();\r\n}"
}, {
	"Path": "com.iluwatar.model.view.controller.GiantControllerTest.testSetFatigue",
	"Comment": "verify if the controller passes the fatigue level through to the model and vice versa",
	"Method": "void testSetFatigue(){\r\n    final GiantModel model = mock(GiantModel.class);\r\n    final GiantView view = mock(GiantView.class);\r\n    final GiantController controller = new GiantController(model, view);\r\n    verifyZeroInteractions(model, view);\r\n    for (final Fatigue fatigue : Fatigue.values()) {\r\n        controller.setFatigue(fatigue);\r\n        verify(model).setFatigue(fatigue);\r\n        verifyZeroInteractions(view);\r\n    }\r\n    controller.getFatigue();\r\n    verify(model).getFatigue();\r\n    verifyNoMoreInteractions(model, view);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.ProcessorInclude.setHref",
	"Comment": "get the base identifier with which this stylesheet is associated.",
	"Method": "void setHref(String baseIdent){\r\n    m_href = baseIdent;\r\n}"
}, {
	"Path": "jadx.cli.JadxCLIArgs.overrideProvided",
	"Comment": "set values only for options provided in cmd.\tused to merge saved options and options passed in command line.",
	"Method": "boolean overrideProvided(String[] args){\r\n    JCommanderWrapper<JadxCLIArgs> jcw = new JCommanderWrapper(new JadxCLIArgs());\r\n    if (!jcw.parse(args)) {\r\n        return false;\r\n    }\r\n    jcw.overrideProvided(this);\r\n    return process(jcw);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerTraceWriter.getOutputStream",
	"Comment": "get the outputstream that is the at the end of thechain of writers.",
	"Method": "OutputStream getOutputStream(){\r\n    OutputStream retval = null;\r\n    if (m_writer instanceof WriterChain)\r\n        retval = ((WriterChain) m_writer).getOutputStream();\r\n    return retval;\r\n}"
}, {
	"Path": "org.apache.xml.utils.DOMHelper.isIgnorableWhitespace",
	"Comment": "tell if the node is ignorable whitespace. note that this canbe determined only in the context of a dtd or other schema,and that dom level 2 has nostandardized dom api which canreturn that information.",
	"Method": "boolean isIgnorableWhitespace(Text node){\r\n    boolean isIgnorable = false;\r\n    return isIgnorable;\r\n}"
}, {
	"Path": "hudson.Util.tryOnceDeleteFile",
	"Comment": "deletes this file, working around most problems which might makethis difficult.",
	"Method": "void tryOnceDeleteFile(File f){\r\n    Path path = fileToPath(f);\r\n    try {\r\n        Files.deleteIfExists(path);\r\n    } catch (IOException e) {\r\n        makeWritable(path);\r\n        Path parent = path.getParent();\r\n        if (parent != null) {\r\n            makeWritable(parent);\r\n        }\r\n        try {\r\n            Files.deleteIfExists(path);\r\n        } catch (IOException e2) {\r\n            File[] files = f.listFiles();\r\n            if (files != null && files.length > 0)\r\n                throw new IOException(\"Unable to delete \" + f.getPath() + \" - files in dir: \" + Arrays.asList(files), e2);\r\n            throw e2;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.OpMapVector.setElementAt",
	"Comment": "sets the component at the specified index of this vector to be thespecified object. the previous component at that position is discarded.the index must be a value greater than or equal to 0 and lessthan the current size of the vector.",
	"Method": "void setElementAt(int value,int index){\r\n    if (index >= m_mapSize) {\r\n        int oldSize = m_mapSize;\r\n        m_mapSize += m_blocksize;\r\n        int[] newMap = new int[m_mapSize];\r\n        System.arraycopy(m_map, 0, newMap, 0, oldSize);\r\n        m_map = newMap;\r\n    }\r\n    m_map[index] = value;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerIdentityImpl.notationDecl",
	"Comment": "receive notification of a notation declaration.by default, do nothing.application writers may override thismethod in a subclass if they wish to keep track of the notationsdeclared in a document.",
	"Method": "void notationDecl(String name,String publicId,String systemId){\r\n    if (null != m_resultDTDHandler)\r\n        m_resultDTDHandler.notationDecl(name, publicId, systemId);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.XSLTAttributeDef.getListOfEnums",
	"Comment": "stringbuffer containing comma delimited list of valid values for enum type.used to build error message.",
	"Method": "StringBuffer getListOfEnums(){\r\n    StringBuffer enumNamesList = new StringBuffer();\r\n    String[] enumValues = this.getEnumNames();\r\n    for (int i = 0; i < enumValues.length; i++) {\r\n        if (i > 0) {\r\n            enumNamesList.append(' ');\r\n        }\r\n        enumNamesList.append(enumValues[i]);\r\n    }\r\n    return enumNamesList;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FunctionMultiArgs.setArg",
	"Comment": "set an argument expression for a function.this method is called by thexpath compiler.",
	"Method": "void setArg(Expression arg,int argNum){\r\n    if (argNum < 3)\r\n        super.setArg(arg, argNum);\r\n    else {\r\n        if (null == m_args) {\r\n            m_args = new Expression[1];\r\n            m_args[0] = arg;\r\n        } else {\r\n            Expression[] args = new Expression[m_args.length + 1];\r\n            System.arraycopy(m_args, 0, args, 0, m_args.length);\r\n            args[m_args.length] = arg;\r\n            m_args = args;\r\n        }\r\n        arg.exprSetParent(this);\r\n    }\r\n}"
}, {
	"Path": "hudson.util.AtomicFileWriter.getTemporaryFile",
	"Comment": "until the data is committed, this file capturesthe written content.",
	"Method": "File getTemporaryFile(){\r\n    return tmpPath.toFile();\r\n}"
}, {
	"Path": "hudson.model.AbstractItem.setDisplayNameOrNull",
	"Comment": "this method exists so that the job configuration pages can use getdisplaynameornull so that nothing is shown in the display name textbox if the display name is not set.",
	"Method": "void setDisplayNameOrNull(String displayName){\r\n    setDisplayName(displayName);\r\n}"
}, {
	"Path": "hudson.scheduler.CronTab.hashify",
	"Comment": "checks a prospective crontab specification to see if it could benefit from balanced hashes.",
	"Method": "String hashify(String spec){\r\n    if (spec.contains(\"H\")) {\r\n        return null;\r\n    } else if (spec.startsWith(\"*/\")) {\r\n        return \"H\" + spec.substring(1);\r\n    } else if (spec.matches(\"\\\\d+ .+\")) {\r\n        return \"H \" + spec.substring(spec.indexOf(' ') + 1);\r\n    } else {\r\n        Matcher m = Pattern.compile(\"0(,(\\\\d+)(,\\\\d+)*)( .+)\").matcher(spec);\r\n        if (m.matches()) {\r\n            int period = Integer.parseInt(m.group(2));\r\n            if (period > 0) {\r\n                StringBuilder b = new StringBuilder();\r\n                for (int i = period; i < 60; i += period) {\r\n                    b.append(',').append(i);\r\n                }\r\n                if (b.toString().equals(m.group(1))) {\r\n                    return \"H/\" + period + m.group(4);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "hudson.FilePath.moveAllChildrenTo",
	"Comment": "moves all the contents of this directory into the specified directory, then delete this directory itself.",
	"Method": "void moveAllChildrenTo(FilePath target){\r\n    if (this.channel != target.channel) {\r\n        throw new IOException(\"pullUpTo target must be on the same host\");\r\n    }\r\n    act(new MoveAllChildrenTo(target));\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemIf.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n    java.util.Vector vnames = sroot.getComposeState().getVariableNames();\r\n    if (null != m_test)\r\n        m_test.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());\r\n}"
}, {
	"Path": "org.apache.xpath.axes.ReverseAxesWalker.getLastPos",
	"Comment": "get the number of nodes in this node list.the function is probably illnamed?",
	"Method": "int getLastPos(XPathContext xctxt){\r\n    int count = 0;\r\n    AxesWalker savedWalker = wi().getLastUsedWalker();\r\n    try {\r\n        ReverseAxesWalker clone = (ReverseAxesWalker) this.clone();\r\n        clone.setRoot(this.getRoot());\r\n        clone.setPredicateCount(m_predicateIndex);\r\n        clone.setPrevWalker(null);\r\n        clone.setNextWalker(null);\r\n        wi().setLastUsedWalker(clone);\r\n        int next;\r\n        while (DTM.NULL != (next = clone.nextNode())) {\r\n            count++;\r\n        }\r\n    } catch (CloneNotSupportedException cnse) {\r\n    } finally {\r\n        wi().setLastUsedWalker(savedWalker);\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.iluwatar.promise.Promise.thenAccept",
	"Comment": "returns a new promise that, when this promise is fulfilled normally, is fulfilled with result of this promise as argument to the action provided.",
	"Method": "Promise<Void> thenAccept(Consumer<? super T> action){\r\n    Promise<Void> dest = new Promise();\r\n    fulfillmentAction = new ConsumeAction(this, dest, action);\r\n    return dest;\r\n}"
}, {
	"Path": "com.iluwatar.semaphore.FruitShop.takeBowl",
	"Comment": "method called by customer to get a fruitbowl from the shop. this methodwill try to acquire the semaphore before returning the first available fruitbowl.",
	"Method": "FruitBowl takeBowl(){\r\n    FruitBowl bowl = null;\r\n    try {\r\n        semaphore.acquire();\r\n        if (available[0]) {\r\n            bowl = bowls[0];\r\n            available[0] = false;\r\n        } else if (available[1]) {\r\n            bowl = bowls[1];\r\n            available[1] = false;\r\n        } else if (available[2]) {\r\n            bowl = bowls[2];\r\n            available[2] = false;\r\n        }\r\n    } catch (InterruptedException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        semaphore.release();\r\n    }\r\n    return bowl;\r\n}"
}, {
	"Path": "org.java_websocket.AbstractWebSocket.cancelConnectionLostTimer",
	"Comment": "cancel any running timer for the connection lost detection",
	"Method": "void cancelConnectionLostTimer(){\r\n    if (connectionLostTimer != null) {\r\n        connectionLostTimer.cancel();\r\n        connectionLostTimer = null;\r\n    }\r\n    if (connectionLostTimerTask != null) {\r\n        connectionLostTimerTask.cancel();\r\n        connectionLostTimerTask = null;\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.types.ImplementationImportCollectorTest.testPrimitiveTypeLiteral",
	"Comment": "verify that a primitive type literal has a wrapper class import.",
	"Method": "void testPrimitiveTypeLiteral(){\r\n    String translation = translateSourceFile(\"import com.google.j2objc.annotations.Weak; \" + \"class Test { @Weak Object o; void test() { o = double.class; } }\", \"Test\", \"Test.m\");\r\n    assertTranslation(translation, \"#include \\\"IOSClass.h\\\"\");\r\n}"
}, {
	"Path": "jenkins.util.groovy.GroovyHookScript.createShell",
	"Comment": "can be used to customize the environment in which the script runs.",
	"Method": "GroovyShell createShell(){\r\n    return new GroovyShell(loader, bindings);\r\n}"
}, {
	"Path": "jadx.core.utils.BlockUtils.skipSyntheticSuccessor",
	"Comment": "return successor of synthetic block or same block otherwise.",
	"Method": "BlockNode skipSyntheticSuccessor(BlockNode block){\r\n    if (block.isSynthetic() && block.getSuccessors().size() == 1) {\r\n        return block.getSuccessors().get(0);\r\n    }\r\n    return block;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.getWhatToShow",
	"Comment": "this attribute determines which node types are presented via theiterator. the available set of constants is defined in thedtmfilter interface. for nodesetdtms, the mask has beenhardcoded to show all nodes except entityreference nodes, which haveno equivalent in the xpath data model.",
	"Method": "int getWhatToShow(){\r\n    return DTMFilter.SHOW_ALL & ~DTMFilter.SHOW_ENTITY_REFERENCE;\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XString.toUpperCase",
	"Comment": "converts all of the characters in this string to uppercase using the rules of the given locale.",
	"Method": "XMLString toUpperCase(Locale locale,XMLString toUpperCase){\r\n    return new XString(str().toUpperCase());\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XString.lastIndexOf",
	"Comment": "returns the index within this string of the last occurrence ofthe specified substring.",
	"Method": "int lastIndexOf(int ch,int lastIndexOf,int ch,int fromIndex,int lastIndexOf,String str,int lastIndexOf,String str,int fromIndex){\r\n    return str().lastIndexOf(str, fromIndex);\r\n}"
}, {
	"Path": "org.apache.xpath.Expression.executeCharsToContentHandler",
	"Comment": "execute an expression in the xpath runtime context, and return theresult of the expression.",
	"Method": "void executeCharsToContentHandler(XPathContext xctxt,ContentHandler handler){\r\n    XObject obj = execute(xctxt);\r\n    obj.dispatchCharactersEvents(handler);\r\n    obj.detach();\r\n}"
}, {
	"Path": "org.apache.xml.utils.IntVector.setElementAt",
	"Comment": "sets the component at the specified index of this vector to be thespecified object. the previous component at that position is discarded.the index must be a value greater than or equal to 0 and lessthan the current size of the vector.",
	"Method": "void setElementAt(int value,int index){\r\n    m_map[index] = value;\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLReaderManager.releaseXMLReader",
	"Comment": "mark the cached xmlreader as available.if the reader was notactually in the cache, do nothing.",
	"Method": "void releaseXMLReader(XMLReader reader){\r\n    if (m_readers.get() == reader && reader != null) {\r\n        m_inUse.remove(reader);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.diagnoseMultistepList",
	"Comment": "print out diagnostics about partial multistep evaluation.",
	"Method": "void diagnoseMultistepList(int matchCount,int lengthToTest,boolean isGlobal){\r\n    if (matchCount > 0) {\r\n        System.err.print(\"Found multistep matches: \" + matchCount + \", \" + lengthToTest + \" length\");\r\n        if (isGlobal)\r\n            System.err.println(\" (global)\");\r\n        else\r\n            System.err.println();\r\n    }\r\n}"
}, {
	"Path": "hudson.Functions.toCCStatus",
	"Comment": "converts the hudson build status to cruisecontrol build status,which is either success, failure, exception, or unknown.",
	"Method": "String toCCStatus(Item i){\r\n    if (i instanceof Job) {\r\n        Job j = (Job) i;\r\n        switch(j.getIconColor()) {\r\n            case ABORTED:\r\n            case ABORTED_ANIME:\r\n            case RED:\r\n            case RED_ANIME:\r\n            case YELLOW:\r\n            case YELLOW_ANIME:\r\n                return \"Failure\";\r\n            case BLUE:\r\n            case BLUE_ANIME:\r\n                return \"Success\";\r\n            case DISABLED:\r\n            case DISABLED_ANIME:\r\n            case GREY:\r\n            case GREY_ANIME:\r\n            case NOTBUILT:\r\n            case NOTBUILT_ANIME:\r\n                return \"Unknown\";\r\n        }\r\n    }\r\n    return \"Unknown\";\r\n}"
}, {
	"Path": "hudson.PluginManager.doInstallPluginsDone",
	"Comment": "called to progress status beyond installing plugins, e.g. if there were failures that prevented installation from naturally proceeding",
	"Method": "void doInstallPluginsDone(){\r\n    Jenkins j = Jenkins.getInstance();\r\n    j.checkPermission(Jenkins.ADMINISTER);\r\n    InstallUtil.proceedToNextStateFrom(InstallState.INITIAL_PLUGINS_INSTALLING);\r\n}"
}, {
	"Path": "hudson.util.ReflectionUtils.getVmDefaultValueForPrimitiveType",
	"Comment": "given the primitive type, returns the vm default value for that type in a boxed form.",
	"Method": "Object getVmDefaultValueForPrimitiveType(Class<?> type){\r\n    return defaultPrimitiveValue.get(type);\r\n}"
}, {
	"Path": "com.iluwatar.event.aggregator.EventEmitterTest.testAllDaysWithoutDefaultObserver",
	"Comment": "go over every day of the month, and check if the event is emitted on the given day. use anevent emitter without a default observer",
	"Method": "void testAllDaysWithoutDefaultObserver(Weekday specialDay,Event event){\r\n    final EventObserver observer1 = mock(EventObserver.class);\r\n    final EventObserver observer2 = mock(EventObserver.class);\r\n    final E emitter = this.factoryWithoutDefaultObserver.get();\r\n    emitter.registerObserver(observer1);\r\n    emitter.registerObserver(observer2);\r\n    testAllDays(specialDay, event, emitter, observer1, observer2);\r\n}"
}, {
	"Path": "hudson.Functions.getGlobalNodePropertyDescriptors",
	"Comment": "returns those node properties which can be configured as global node properties.",
	"Method": "List<NodePropertyDescriptor> getGlobalNodePropertyDescriptors(){\r\n    List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>();\r\n    Collection<NodePropertyDescriptor> list = (Collection) Jenkins.getInstance().getDescriptorList(NodeProperty.class);\r\n    for (NodePropertyDescriptor npd : list) {\r\n        if (npd.isApplicableAsGlobal()) {\r\n            result.add(npd);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.xml.utils.IntVector.removeAllElements",
	"Comment": "inserts the specified node in this vector at the specified index.each component in this vector with an index greater or equal tothe specified index is shifted upward to have an index one greaterthan the value it had previously.",
	"Method": "void removeAllElements(){\r\n    for (int i = 0; i < m_firstFree; i++) {\r\n        m_map[i] = java.lang.Integer.MIN_VALUE;\r\n    }\r\n    m_firstFree = 0;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerTraceWriter.setBufferSize",
	"Comment": "creates or replaces the internal buffer, and makes sure it has a fewextra bytes slight overflow of the last utf8 encoded character.",
	"Method": "void setBufferSize(int size){\r\n    buf = new byte[size + 3];\r\n    buf_length = size;\r\n    count = 0;\r\n}"
}, {
	"Path": "org.apache.xpath.operations.Variable.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    m_fixUpWasCalled = true;\r\n    int sz = vars.size();\r\n    for (int i = vars.size() - 1; i >= 0; i--) {\r\n        QName qn = (QName) vars.elementAt(i);\r\n        if (qn.equals(m_qname)) {\r\n            if (i < globalsSize) {\r\n                m_isGlobal = true;\r\n                m_index = i;\r\n            } else {\r\n                m_index = i - globalsSize;\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    java.lang.String msg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_COULD_NOT_FIND_VAR, new Object[] { m_qname.toString() });\r\n    TransformerException te = new TransformerException(msg, this);\r\n    throw new org.apache.xml.utils.WrappedRuntimeException(te);\r\n}"
}, {
	"Path": "redis.clients.jedis.util.Sharded.getKeyTag",
	"Comment": "a key tag is a special pattern inside a key that, if preset, is the only part of the key hashedin order to select the server for this key.",
	"Method": "String getKeyTag(String key){\r\n    if (tagPattern != null) {\r\n        Matcher m = tagPattern.matcher(key);\r\n        if (m.find())\r\n            return m.group(1);\r\n    }\r\n    return key;\r\n}"
}, {
	"Path": "hudson.model.Executor.currentExecutor",
	"Comment": "returns the executor of the current thread or null if current thread is not an executor.",
	"Method": "Executor currentExecutor(){\r\n    Thread t = Thread.currentThread();\r\n    if (t instanceof Executor)\r\n        return (Executor) t;\r\n    return IMPERSONATION.get();\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncNamespace.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    int context = getArg0AsNode(xctxt);\r\n    String s;\r\n    if (context != DTM.NULL) {\r\n        DTM dtm = xctxt.getDTM(context);\r\n        int t = dtm.getNodeType(context);\r\n        if (t == DTM.ELEMENT_NODE) {\r\n            s = dtm.getNamespaceURI(context);\r\n        } else if (t == DTM.ATTRIBUTE_NODE) {\r\n            s = dtm.getNodeName(context);\r\n            if (s.startsWith(\"xmlns:\") || s.equals(\"xmlns\"))\r\n                return XString.EMPTYSTRING;\r\n            s = dtm.getNamespaceURI(context);\r\n        } else\r\n            return XString.EMPTYSTRING;\r\n    } else\r\n        return XString.EMPTYSTRING;\r\n    return ((null == s) ? XString.EMPTYSTRING : new XString(s));\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerImpl.setExtensionsTable",
	"Comment": "if the stylesheet contains extensions, set the extensions table object.",
	"Method": "void setExtensionsTable(StylesheetRoot sroot){\r\n    try {\r\n        if (sroot.getExtensions() != null)\r\n            if (!sroot.isSecureProcessing())\r\n                m_extensionsTable = new ExtensionsTable(sroot);\r\n    } catch (javax.xml.transform.TransformerException te) {\r\n        te.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.setUseSourceLocation",
	"Comment": "set whether information about document source locationshould be maintained or not.",
	"Method": "void setUseSourceLocation(boolean useSourceLocation){\r\n    m_useSourceLocationProperty = useSourceLocation;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.popAndTop",
	"Comment": "pop a node from the tail of the vector and return thetop of the stack after the pop.",
	"Method": "Node popAndTop(){\r\n    m_firstFree--;\r\n    m_map[m_firstFree] = null;\r\n    return (m_firstFree == 0) ? null : m_map[m_firstFree - 1];\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XObject.getTypeString",
	"Comment": "given a request type, return the equivalent string.for diagnostic purposes.",
	"Method": "String getTypeString(){\r\n    return \"#UNKNOWN (\" + object().getClass().getName() + \")\";\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.getEncoding",
	"Comment": "returns the character encoding to be used in the output document.",
	"Method": "String getEncoding(){\r\n    return getOutputProperty(OutputKeys.ENCODING);\r\n}"
}, {
	"Path": "hudson.security.ACL.isAnonymous",
	"Comment": "checks if the given authentication is anonymous by checking its class.",
	"Method": "boolean isAnonymous(Authentication authentication){\r\n    return authentication instanceof AnonymousAuthenticationToken;\r\n}"
}, {
	"Path": "com.sun.jna.platform.linux.XAttrUtil.lGetXAttr",
	"Comment": "get extended attribute value but in case of symbolic link get the value from the linkitself instead of linked file.",
	"Method": "String lGetXAttr(String path,String name,String lGetXAttr,String path,String name,String encoding){\r\n    byte[] valueMem = lGetXAttrBytes(path, name);\r\n    return new String(valueMem, Charset.forName(encoding));\r\n}"
}, {
	"Path": "com.iluwatar.reader.writer.lock.ReaderAndWriterTest.testReadAndWrite",
	"Comment": "verify reader and writer can only get the lock to read and write orderly",
	"Method": "void testReadAndWrite(){\r\n    ReaderWriterLock lock = new ReaderWriterLock();\r\n    Reader reader1 = new Reader(\"Reader 1\", lock.readLock());\r\n    Writer writer1 = new Writer(\"Writer 1\", lock.writeLock());\r\n    ExecutorService executeService = Executors.newFixedThreadPool(2);\r\n    executeService.submit(reader1);\r\n    Thread.sleep(150);\r\n    executeService.submit(writer1);\r\n    executeService.shutdown();\r\n    try {\r\n        executeService.awaitTermination(10, TimeUnit.SECONDS);\r\n    } catch (InterruptedException e) {\r\n        LOGGER.error(\"Error waiting for ExecutorService shutdown\", e);\r\n    }\r\n    assertTrue(appender.logContains(\"Reader 1 begin\"));\r\n    assertTrue(appender.logContains(\"Reader 1 finish\"));\r\n    assertTrue(appender.logContains(\"Writer 1 begin\"));\r\n    assertTrue(appender.logContains(\"Writer 1 finish\"));\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerImpl.popCurrentMatched",
	"Comment": "pop the elements that were pushed via pushpaircurrentmatched.",
	"Method": "void popCurrentMatched(){\r\n    m_currentMatchTemplates.pop();\r\n    m_currentMatchedNodes.pop();\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.initializeClass",
	"Comment": "forces initialization of a class in a jdk 1.1 compatible, albeit hackyway.",
	"Method": "void initializeClass(Class theClass){\r\n    final Constructor[] cons = theClass.getDeclaredConstructors();\r\n    if (cons != null) {\r\n        if (cons.length > 0 && cons[0] != null) {\r\n            final String[] strs = new String[NUMBER_OF_STRINGS];\r\n            try {\r\n                cons[0].newInstance((Object[]) strs);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.operations.Variable.setIsGlobal",
	"Comment": "set whether or not this is a global reference.for advanced use only.",
	"Method": "void setIsGlobal(boolean isGlobal){\r\n    m_isGlobal = isGlobal;\r\n}"
}, {
	"Path": "hudson.util.KeyedDataStorage.get",
	"Comment": "finds the data object that matches the given key if available, or nullif not found.",
	"Method": "T get(T get,String key,T get,String key,boolean createIfNotExist,P createParams){\r\n    while (true) {\r\n        totalQuery.incrementAndGet();\r\n        Object value = core.get(key);\r\n        if (value instanceof SoftReference) {\r\n            SoftReference<T> wfp = (SoftReference<T>) value;\r\n            T t = wfp.get();\r\n            if (t != null) {\r\n                cacheHit.incrementAndGet();\r\n                return t;\r\n            }\r\n            weakRefLost.incrementAndGet();\r\n        }\r\n        if (value instanceof Loading) {\r\n            T t = ((Loading<T>) value).get();\r\n            if (t != null || !createIfNotExist)\r\n                return t;\r\n        }\r\n        Loading<T> l = new Loading<T>();\r\n        if (value == null ? core.putIfAbsent(key, l) != null : !core.replace(key, value, l)) {\r\n            continue;\r\n        }\r\n        T t = null;\r\n        try {\r\n            t = load(key);\r\n            if (t == null && createIfNotExist) {\r\n                t = create(key, createParams);\r\n                if (t == null)\r\n                    throw new IllegalStateException(\"Bug in the derived class\");\r\n            }\r\n        } catch (IOException e) {\r\n            loadFailure.incrementAndGet();\r\n            throw e;\r\n        } finally {\r\n            l.set(t);\r\n        }\r\n        if (t != null)\r\n            core.put(key, new SoftReference<T>(t));\r\n        else\r\n            core.remove(key);\r\n        return t;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.getAnalysisBits",
	"Comment": "get the analysis bits for this walker, as defined in the walkerfactory.",
	"Method": "int getAnalysisBits(){\r\n    int axis = getAxis();\r\n    int bit = WalkerFactory.getAnalysisBitFromAxes(axis);\r\n    return bit;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.addNodeInDocOrder",
	"Comment": "add the node into a vector of nodes where it should occur indocument order.",
	"Method": "int addNodeInDocOrder(int node,boolean test,XPathContext support,int addNodeInDocOrder,int node,XPathContext support){\r\n    if (!m_mutable)\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null));\r\n    return addNodeInDocOrder(node, true, support);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.VarNameCollector.getVarCount",
	"Comment": "get the number of variable references that were collected.",
	"Method": "int getVarCount(){\r\n    return m_refs.size();\r\n}"
}, {
	"Path": "org.apache.xalan.processor.TransformerFactoryImpl.getErrorListener",
	"Comment": "get the error listener in effect for the transformerfactory.",
	"Method": "ErrorListener getErrorListener(){\r\n    return m_errorListener;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.gradle.FilesTask.printProjectFiles",
	"Comment": "prints build files, sources, and resources associated with a project.",
	"Method": "void printProjectFiles(Project project){\r\n    JavaPluginConvention javaConvention = project.getConvention().getPlugin(JavaPluginConvention.class);\r\n    SourceSet mainSourceSet = javaConvention.getSourceSets().findByName(SourceSet.MAIN_SOURCE_SET_NAME);\r\n    if (mainSourceSet == null) {\r\n        return;\r\n    }\r\n    printGradleFiles(project);\r\n    mainSourceSet.getAllSource().getSourceDirectories().forEach(sourceDirectory -> {\r\n        if (sourceDirectory.exists()) {\r\n            System.out.println(sourceDirectory);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.apache.xml.serializer.Encodings.toCodePoint",
	"Comment": "return the unicode code point represented by the char.a bit of a dummy method, since all it does is return the char,but as an int value.this is not a public api.",
	"Method": "int toCodePoint(char highSurrogate,char lowSurrogate,int toCodePoint,char ch){\r\n    int codePoint = ch;\r\n    return codePoint;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.Function.checkNumberArgs",
	"Comment": "check that the number of arguments passed to this function is correct.this method is meant to be overloaded by derived classes, to check for the number of arguments for a specific function type.this method is called by the compiler for static number of arguments checking.",
	"Method": "void checkNumberArgs(int argNum){\r\n    if (argNum != 0)\r\n        reportWrongNumberArgs();\r\n}"
}, {
	"Path": "org.apache.xml.utils.NodeVector.peepTail",
	"Comment": "return the node at the tail of the vector without poppingspecial purpose method for transformerimpl, pushelemtemplateelement.performance critical.",
	"Method": "int peepTail(){\r\n    return m_map[m_firstFree - 1];\r\n}"
}, {
	"Path": "org.apache.xpath.SourceTreeManager.reset",
	"Comment": "reset the list of sourcetree objects that this manager manages.",
	"Method": "void reset(){\r\n    m_sourceTree = new Vector();\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncSubstring.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    XMLString s1 = m_arg0.execute(xctxt).xstr();\r\n    double start = m_arg1.execute(xctxt).num();\r\n    int lenOfS1 = s1.length();\r\n    XMLString substr;\r\n    if (lenOfS1 <= 0)\r\n        return XString.EMPTYSTRING;\r\n    else {\r\n        int startIndex;\r\n        if (Double.isNaN(start)) {\r\n            start = -1000000;\r\n            startIndex = 0;\r\n        } else {\r\n            start = Math.round(start);\r\n            startIndex = (start > 0) ? (int) start - 1 : 0;\r\n        }\r\n        if (null != m_arg2) {\r\n            double len = m_arg2.num(xctxt);\r\n            int end = (int) (Math.round(len) + start) - 1;\r\n            if (end < 0)\r\n                end = 0;\r\n            else if (end > lenOfS1)\r\n                end = lenOfS1;\r\n            if (startIndex > lenOfS1)\r\n                startIndex = lenOfS1;\r\n            substr = s1.substring(startIndex, end);\r\n        } else {\r\n            if (startIndex > lenOfS1)\r\n                startIndex = lenOfS1;\r\n            substr = s1.substring(startIndex);\r\n        }\r\n    }\r\n    return (XString) substr;\r\n}"
}, {
	"Path": "org.apache.xpath.jaxp.XPathFactoryImpl.newXPath",
	"Comment": "returns a new xpath object using the underlyingobject model determined when the factory was instantiated.",
	"Method": "javax.xml.xpath.XPath newXPath(){\r\n    return new org.apache.xpath.jaxp.XPathImpl(xPathVariableResolver, xPathFunctionResolver, featureSecureProcessing);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMAxisIteratorBase.resetPosition",
	"Comment": "reset the position to zero. note that this does not change the iterationstate, only the position number associated with that state.%review% document when this would be used?",
	"Method": "DTMAxisIterator resetPosition(){\r\n    _position = 0;\r\n    return this;\r\n}"
}, {
	"Path": "com.iluwatar.converter.ConverterTest.testConversionsStartingFromDto",
	"Comment": "tests whether a converter created of opposite functions holds equality as a bijection.",
	"Method": "void testConversionsStartingFromDto(){\r\n    UserDto u1 = new UserDto(\"Tom\", \"Hanks\", true, \"tom@hanks.com\");\r\n    UserDto u2 = userConverter.convertFromEntity(userConverter.convertFromDto(u1));\r\n    assertEquals(u1, u2);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.Stylesheet.accept",
	"Comment": "accept a visitor and call the appropriate method for this class.",
	"Method": "boolean accept(XSLTVisitor visitor){\r\n    return visitor.visitStylesheet(this);\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.gradle.JibRunHelper.assertBuildSuccess",
	"Comment": "asserts that the test project build output indicates a success.",
	"Method": "void assertBuildSuccess(BuildResult buildResult,String taskName,String successMessage){\r\n    BuildTask classesTask = buildResult.task(\":classes\");\r\n    BuildTask jibTask = buildResult.task(\":\" + taskName);\r\n    Assert.assertNotNull(classesTask);\r\n    Assert.assertEquals(TaskOutcome.SUCCESS, classesTask.getOutcome());\r\n    Assert.assertNotNull(jibTask);\r\n    Assert.assertEquals(TaskOutcome.SUCCESS, jibTask.getOutcome());\r\n    Assert.assertThat(buildResult.getOutput(), CoreMatchers.containsString(successMessage));\r\n}"
}, {
	"Path": "hudson.model.Fingerprint.getTimestampString",
	"Comment": "gets the string that says how long since this build has scheduled.",
	"Method": "String getTimestampString(){\r\n    long duration = System.currentTimeMillis() - timestamp.getTime();\r\n    return Util.getPastTimeString(duration);\r\n}"
}, {
	"Path": "hudson.model.ParametersAction.shouldSchedule",
	"Comment": "allow an other build of the same project to be scheduled, if it has other parameters.",
	"Method": "boolean shouldSchedule(List<Action> actions){\r\n    List<ParametersAction> others = Util.filter(actions, ParametersAction.class);\r\n    if (others.isEmpty()) {\r\n        return !parameters.isEmpty();\r\n    } else {\r\n        Set<ParameterValue> params = new HashSet<ParameterValue>();\r\n        for (ParametersAction other : others) {\r\n            params.addAll(other.parameters);\r\n        }\r\n        return !params.equals(new HashSet<ParameterValue>(this.parameters));\r\n    }\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.setIsolated",
	"Comment": "sets whether this classloader should run in isolated mode. inisolated mode, classes not found on the given classpath willnot be referred to the parent class loader but will cause aclassnotfoundexception.",
	"Method": "void setIsolated(boolean isolated){\r\n    ignoreBase = isolated;\r\n}"
}, {
	"Path": "redis.clients.jedis.util.Pool.getNumActive",
	"Comment": "returns the number of instances currently borrowed from this pool.",
	"Method": "int getNumActive(){\r\n    if (poolInactive()) {\r\n        return -1;\r\n    }\r\n    return this.internalPool.getNumActive();\r\n}"
}, {
	"Path": "hudson.model.ResourceController.execute",
	"Comment": "performs the task that requires the given list of resources.the execution is blocked until the resource is available.",
	"Method": "void execute(Runnable task,ResourceActivity activity){\r\n    final ResourceList resources = activity.getResourceList();\r\n    _withLock(new NotReallyRoleSensitiveCallable<Void, InterruptedException>() {\r\n        @Override\r\n        public Void call() throws InterruptedException {\r\n            while (inUse.isCollidingWith(resources)) {\r\n                _await();\r\n            }\r\n            inProgress.add(activity);\r\n            inUse = ResourceList.union(inUse, resources);\r\n            return null;\r\n        }\r\n    });\r\n    try {\r\n        task.run();\r\n    } finally {\r\n        _withLock(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                inProgress.remove(activity);\r\n                inUse = ResourceList.union(resourceView);\r\n                _signalAll();\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "hudson.model.ResourceController.execute",
	"Comment": "performs the task that requires the given list of resources.the execution is blocked until the resource is available.",
	"Method": "void execute(Runnable task,ResourceActivity activity){\r\n    while (inUse.isCollidingWith(resources)) {\r\n        _await();\r\n    }\r\n    inProgress.add(activity);\r\n    inUse = ResourceList.union(inUse, resources);\r\n    return null;\r\n}"
}, {
	"Path": "hudson.model.ResourceController.execute",
	"Comment": "performs the task that requires the given list of resources.the execution is blocked until the resource is available.",
	"Method": "void execute(Runnable task,ResourceActivity activity){\r\n    inProgress.remove(activity);\r\n    inUse = ResourceList.union(resourceView);\r\n    _signalAll();\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.NodeSorter.sort",
	"Comment": "given a vector of nodes, sort each node according tothe criteria in the keys.",
	"Method": "void sort(DTMIterator v,Vector keys,XPathContext support){\r\n    m_keys = keys;\r\n    int n = v.getLength();\r\n    Vector nodes = new Vector();\r\n    for (int i = 0; i < n; i++) {\r\n        NodeCompareElem elem = new NodeCompareElem(v.item(i));\r\n        nodes.addElement(elem);\r\n    }\r\n    Vector scratchVector = new Vector();\r\n    mergesort(nodes, scratchVector, 0, n - 1, support);\r\n    for (int i = 0; i < n; i++) {\r\n        v.setItem(((NodeCompareElem) nodes.elementAt(i)).m_node, i);\r\n    }\r\n    v.setCurrentPos(0);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.XSLTElementDef.setLastOrder",
	"Comment": "set the highest order of child elements have appeared so far .",
	"Method": "void setLastOrder(int order){\r\n    m_lastOrder = order;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.SystemIDResolver.getAbsoluteURI",
	"Comment": "take a systemid string and try to turn it into a good absolute uri.",
	"Method": "String getAbsoluteURI(String systemId,String getAbsoluteURI,String urlString,String base){\r\n    if (base == null)\r\n        return getAbsoluteURI(urlString);\r\n    String absoluteBase = getAbsoluteURI(base);\r\n    URI uri = null;\r\n    try {\r\n        URI baseURI = new URI(absoluteBase);\r\n        uri = new URI(baseURI, urlString);\r\n    } catch (MalformedURIException mue) {\r\n        throw new TransformerException(mue);\r\n    }\r\n    return replaceChars(uri.toString());\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.getEndLineNumber",
	"Comment": "return the line number where the current document event ends.note that this is the line position of the first characterafter the text associated with the document event.",
	"Method": "int getEndLineNumber(){\r\n    return m_endLineNumber;\r\n}"
}, {
	"Path": "com.iluwatar.converter.ConverterTest.testConversionsStartingFromDomain",
	"Comment": "tests whether a converter created of opposite functions holds equality as a bijection.",
	"Method": "void testConversionsStartingFromDomain(){\r\n    User u1 = new User(\"Tom\", \"Hanks\", true, \"tom@hanks.com\");\r\n    User u2 = userConverter.convertFromDto(userConverter.convertFromEntity(u1));\r\n    assertEquals(u1, u2);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.setPrefixNameTable",
	"Comment": "set a reference pointer to the prefix name symbol table.%review% should this really be public? changing it whiledtm is in use would be a disaster.",
	"Method": "void setPrefixNameTable(DTMStringPool poolRef){\r\n    m_prefixNames = poolRef;\r\n}"
}, {
	"Path": "org.apache.xpath.res.XPATHMessages.createXPATHMsg",
	"Comment": "creates a message from the specified key and replacementarguments, localized to the given locale.",
	"Method": "String createXPATHMsg(ListResourceBundle fResourceBundle,String msgKey,Object args){\r\n    String fmsg = null;\r\n    boolean throwex = false;\r\n    String msg = null;\r\n    if (msgKey != null)\r\n        msg = fResourceBundle.getString(msgKey);\r\n    if (msg == null) {\r\n        msg = fResourceBundle.getString(XPATHErrorResources.BAD_CODE);\r\n        throwex = true;\r\n    }\r\n    if (args != null) {\r\n        try {\r\n            int n = args.length;\r\n            for (int i = 0; i < n; i++) {\r\n                if (null == args[i])\r\n                    args[i] = \"\";\r\n            }\r\n            fmsg = java.text.MessageFormat.format(msg, args);\r\n        } catch (Exception e) {\r\n            fmsg = fResourceBundle.getString(XPATHErrorResources.FORMAT_FAILED);\r\n            fmsg += \" \" + msg;\r\n        }\r\n    } else\r\n        fmsg = msg;\r\n    if (throwex) {\r\n        throw new RuntimeException(fmsg);\r\n    }\r\n    return fmsg;\r\n}"
}, {
	"Path": "com.iluwatar.reader.writer.lock.ReaderAndWriterTest.testWriteAndRead",
	"Comment": "verify reader and writer can only get the lock to read and write orderly",
	"Method": "void testWriteAndRead(){\r\n    ExecutorService executeService = Executors.newFixedThreadPool(2);\r\n    ReaderWriterLock lock = new ReaderWriterLock();\r\n    Reader reader1 = new Reader(\"Reader 1\", lock.readLock());\r\n    Writer writer1 = new Writer(\"Writer 1\", lock.writeLock());\r\n    executeService.submit(writer1);\r\n    Thread.sleep(150);\r\n    executeService.submit(reader1);\r\n    executeService.shutdown();\r\n    try {\r\n        executeService.awaitTermination(10, TimeUnit.SECONDS);\r\n    } catch (InterruptedException e) {\r\n        LOGGER.error(\"Error waiting for ExecutorService shutdown\", e);\r\n    }\r\n    assertTrue(appender.logContains(\"Writer 1 begin\"));\r\n    assertTrue(appender.logContains(\"Writer 1 finish\"));\r\n    assertTrue(appender.logContains(\"Reader 1 begin\"));\r\n    assertTrue(appender.logContains(\"Reader 1 finish\"));\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.image.json.HistoryEntry.hasCorrespondingLayer",
	"Comment": "returns whether or not the history object corresponds to a layer in the container.",
	"Method": "boolean hasCorrespondingLayer(){\r\n    return emptyLayer == null ? false : emptyLayer;\r\n}"
}, {
	"Path": "com.iluwatar.composite.MessengerTest.testMessage",
	"Comment": "test if the given composed message matches the expected message",
	"Method": "void testMessage(LetterComposite composedMessage,String message){\r\n    final String[] words = message.split(\" \");\r\n    assertNotNull(composedMessage);\r\n    assertEquals(words.length, composedMessage.count());\r\n    composedMessage.print();\r\n    assertEquals(message, new String(this.stdOutBuffer.toByteArray()).trim());\r\n}"
}, {
	"Path": "jenkins.security.apitoken.ApiTokenStore.findMatchingToken",
	"Comment": "search in the store if there is a token with the same secret as the one given",
	"Method": "HashedToken findMatchingToken(String token){\r\n    String plainToken;\r\n    if (isLegacyToken(token)) {\r\n        plainToken = token;\r\n    } else {\r\n        plainToken = getHashOfToken(token);\r\n    }\r\n    return searchMatch(plainToken);\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLCharacterRecognizer.isWhiteSpace",
	"Comment": "returns whether the specified ch conforms to the xml 1.0 definitionof whitespace.refer to the definition of s for details.",
	"Method": "boolean isWhiteSpace(char ch,boolean isWhiteSpace,char ch,int start,int length,boolean isWhiteSpace,StringBuffer buf,boolean isWhiteSpace,String s){\r\n    if (null != s) {\r\n        int n = s.length();\r\n        for (int i = 0; i < n; i++) {\r\n            if (!isWhiteSpace(s.charAt(i)))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xml.utils.DOM2Helper.getDocument",
	"Comment": "query which document this helper is currently operating on.",
	"Method": "Document getDocument(){\r\n    return m_doc;\r\n}"
}, {
	"Path": "org.apache.xml.utils.DOMBuilder.getRootDocument",
	"Comment": "get the root document or documentfragment of the dom being created.",
	"Method": "Node getRootDocument(){\r\n    return (null != m_docFrag) ? (Node) m_docFrag : (Node) m_doc;\r\n}"
}, {
	"Path": "jadx.core.xmlgen.XMLChar.supplemental",
	"Comment": "returns true the supplemental character corresponding to the given\tsurrogates.",
	"Method": "int supplemental(char h,char l){\r\n    return (h - 0xD800) * 0x400 + (l - 0xDC00) + 0x10000;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.getStylesheetType",
	"Comment": "get the type of stylesheet that should be builtor is being processed.",
	"Method": "int getStylesheetType(){\r\n    return m_stylesheetType;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.ObjectFactory.findClassLoader",
	"Comment": "figure out which classloader to use.for jdk 1.2 and later usethe context classloader.",
	"Method": "ClassLoader findClassLoader(){\r\n    SecuritySupport ss = SecuritySupport.getInstance();\r\n    ClassLoader context = ss.getContextClassLoader();\r\n    ClassLoader system = ss.getSystemClassLoader();\r\n    ClassLoader chain = system;\r\n    while (true) {\r\n        if (context == chain) {\r\n            ClassLoader current = ObjectFactory.class.getClassLoader();\r\n            chain = system;\r\n            while (true) {\r\n                if (current == chain) {\r\n                    return system;\r\n                }\r\n                if (chain == null) {\r\n                    break;\r\n                }\r\n                chain = ss.getParentClassLoader(chain);\r\n            }\r\n            return current;\r\n        }\r\n        if (chain == null) {\r\n            break;\r\n        }\r\n        chain = ss.getParentClassLoader(chain);\r\n    }\r\n    ;\r\n    return context;\r\n}"
}, {
	"Path": "hudson.util.ssh.SFTPClient.mkdirs",
	"Comment": "makes sure that the directory exists, by creating it if necessary.",
	"Method": "void mkdirs(String path,int posixPermission){\r\n    SFTPv3FileAttributes atts = _stat(path);\r\n    if (atts != null && atts.isDirectory())\r\n        return;\r\n    int idx = path.lastIndexOf(\"/\");\r\n    if (idx > 0)\r\n        mkdirs(path.substring(0, idx), posixPermission);\r\n    try {\r\n        mkdir(path, posixPermission);\r\n    } catch (IOException e) {\r\n        throw new IOException(\"Failed to mkdir \" + path, e);\r\n    }\r\n}"
}, {
	"Path": "lib.layout.RenderOnDemandTest.testBehaviour",
	"Comment": "makes sure that the behavior rules are applied to newly inserted nodes,even when multiple nodes are added.",
	"Method": "void testBehaviour(){\r\n    HtmlPage p = createWebClient().goTo(\"self/testBehaviour\");\r\n    p.executeJavaScript(\"renderOnDemand(document.getElementsBySelector('.lazy')[0])\");\r\n    WebClientUtil.waitForJSExec(p.getWebClient());\r\n    ScriptResult r = p.executeJavaScript(\"var r=document.getElementsBySelector('DIV.a'); r[0].innerHTML+r[1].innerHTML+r[2].innerHTML\");\r\n    WebClientUtil.waitForJSExec(p.getWebClient());\r\n    assertEquals(\"AlphaBravoCharlie\", r.getJavaScriptResult().toString());\r\n}"
}, {
	"Path": "org.apache.xpath.axes.NodeSequence.markCacheComplete",
	"Comment": "if this nodesequence has a cache, mark that it is complete.this method should be called after the iterator is exhausted.",
	"Method": "void markCacheComplete(){\r\n    NodeVector nv = getVector();\r\n    if (nv != null) {\r\n        m_cache.setCacheComplete(true);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.dtm.DTMException.getException",
	"Comment": "this method retrieves an exception that this exception wraps.",
	"Method": "Throwable getException(){\r\n    return containedException;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.nextNode",
	"Comment": "this method should try and build one or more nodes in the table.",
	"Method": "boolean nextNode(){\r\n    if (null == m_incrementalSAXSource)\r\n        return false;\r\n    if (m_endDocumentOccured) {\r\n        clearCoRoutine();\r\n        return false;\r\n    }\r\n    Object gotMore = m_incrementalSAXSource.deliverMoreNodes(true);\r\n    if (!(gotMore instanceof Boolean)) {\r\n        if (gotMore instanceof RuntimeException) {\r\n            throw (RuntimeException) gotMore;\r\n        } else if (gotMore instanceof Exception) {\r\n            throw new WrappedRuntimeException((Exception) gotMore);\r\n        }\r\n        clearCoRoutine();\r\n        return false;\r\n    }\r\n    if (gotMore != Boolean.TRUE) {\r\n        clearCoRoutine();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.Function3Args.reportWrongNumberArgs",
	"Comment": "constructs and throws a wrongnumberargexception with the appropriatemessage for this function object.",
	"Method": "void reportWrongNumberArgs(){\r\n    throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(\"three\", null));\r\n}"
}, {
	"Path": "com.iluwatar.threadpool.TaskTest.testIdGeneration",
	"Comment": "verify if the generated id is unique for each task, even if the tasks are created in separatethreads",
	"Method": "void testIdGeneration(){\r\n    assertTimeout(ofMillis(10000), () -> {\r\n        final ExecutorService service = Executors.newFixedThreadPool(THREAD_COUNT);\r\n        final List<Callable<Integer>> tasks = new ArrayList();\r\n        for (int i = 0; i < TASK_COUNT; i++) {\r\n            tasks.add(() -> factory.apply(1).getId());\r\n        }\r\n        final List<Integer> ids = service.invokeAll(tasks).stream().map(TaskTest::get).filter(Objects::nonNull).collect(Collectors.toList());\r\n        service.shutdownNow();\r\n        final long uniqueIdCount = ids.stream().distinct().count();\r\n        assertEquals(TASK_COUNT, ids.size());\r\n        assertEquals(TASK_COUNT, uniqueIdCount);\r\n    });\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.addAttributes",
	"Comment": "add the given attributes to the currently collected ones. theseattributes are always added, regardless of whether on not an elementis currently open.",
	"Method": "void addAttributes(Attributes atts){\r\n    int nAtts = atts.getLength();\r\n    for (int i = 0; i < nAtts; i++) {\r\n        String uri = atts.getURI(i);\r\n        if (null == uri)\r\n            uri = \"\";\r\n        addAttributeAlways(uri, atts.getLocalName(i), atts.getQName(i), atts.getType(i), atts.getValue(i), false);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XStringForFSB.equals",
	"Comment": "compares this string to the specified object.the result is true if and only if the argument is notnull and is a string object that representsthe same sequence of characters as this object.",
	"Method": "boolean equals(XMLString obj2,boolean equals,XObject obj2,boolean equals,String anotherString,boolean equals,Object obj2){\r\n    if (null == obj2)\r\n        return false;\r\n    if (obj2 instanceof XNumber)\r\n        return obj2.equals(this);\r\n    else if (obj2 instanceof XNodeSet)\r\n        return obj2.equals(this);\r\n    else if (obj2 instanceof XStringForFSB)\r\n        return equals((XMLString) obj2);\r\n    else\r\n        return equals(obj2.toString());\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.simple.SimpleFluentIterable.filter",
	"Comment": "filters the contents of iterable using the given predicate, leaving only the ones which satisfythe predicate.",
	"Method": "FluentIterable<E> filter(Predicate<? super E> predicate){\r\n    Iterator<E> iterator = iterator();\r\n    while (iterator.hasNext()) {\r\n        E nextElement = iterator.next();\r\n        if (!predicate.test(nextElement)) {\r\n            iterator.remove();\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.apache.xpath.operations.VariableSafeAbsRef.execute",
	"Comment": "dereference the variable, and return the reference value.note that lazy evaluation will occur.if a variable within scope is not found, a warning will be sent to the error listener, and an empty nodeset will be returned.",
	"Method": "XObject execute(XPathContext xctxt,boolean destructiveOK){\r\n    XNodeSet xns = (XNodeSet) super.execute(xctxt, destructiveOK);\r\n    DTMManager dtmMgr = xctxt.getDTMManager();\r\n    int context = xctxt.getContextNode();\r\n    if (dtmMgr.getDTM(xns.getRoot()).getDocument() != dtmMgr.getDTM(context).getDocument()) {\r\n        Expression expr = (Expression) xns.getContainedIter();\r\n        xns = (XNodeSet) expr.asIterator(xctxt, context);\r\n    }\r\n    return xns;\r\n}"
}, {
	"Path": "hudson.UDPBroadcastThreadTest.multicast",
	"Comment": "multicast based clients should be able to receive multiple replies.",
	"Method": "void multicast(){\r\n    UDPBroadcastThread second = new UDPBroadcastThread(j.jenkins);\r\n    second.start();\r\n    UDPBroadcastThread third = new UDPBroadcastThread(j.jenkins);\r\n    third.start();\r\n    second.ready.block();\r\n    third.ready.block();\r\n    try {\r\n        DatagramSocket s = new DatagramSocket();\r\n        sendQueryTo(s, UDPBroadcastThread.MULTICAST);\r\n        s.setSoTimeout(15000);\r\n        try {\r\n            receiveAndVerify(s);\r\n            receiveAndVerify(s);\r\n        } catch (SocketTimeoutException x) {\r\n            Assume.assumeFalse(UDPBroadcastThread.udpHandlingProblem);\r\n            throw x;\r\n        }\r\n    } finally {\r\n        third.interrupt();\r\n        second.interrupt();\r\n    }\r\n}"
}, {
	"Path": "hudson.node_monitors.NodeMonitor.data",
	"Comment": "obtains the monitoring result currently available, or null if no data is available.",
	"Method": "Object data(Computer c){\r\n    return getDescriptor().get(c);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.ProcessorInclude.getStylesheetInclErr",
	"Comment": "get the error number associated with this type of stylesheet including itself",
	"Method": "String getStylesheetInclErr(){\r\n    return XSLTErrorResources.ER_STYLESHEET_INCLUDES_ITSELF;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.importStackContains",
	"Comment": "see if the imported stylesheet stack already containsthe given url.used to test for recursive imports.",
	"Method": "boolean importStackContains(String hrefUrl){\r\n    return stackContains(m_importStack, hrefUrl);\r\n}"
}, {
	"Path": "hudson.model.AsyncAperiodicWork.getErrorLoggingLevel",
	"Comment": "returns the logging level at which error messages are displayed.",
	"Method": "Level getErrorLoggingLevel(){\r\n    return Level.SEVERE;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.Messages.createMsg",
	"Comment": "creates a message from the specified key and replacementarguments, localized to the given locale.",
	"Method": "String createMsg(ListResourceBundle fResourceBundle,String msgKey,Object args){\r\n    String fmsg = null;\r\n    boolean throwex = false;\r\n    String msg = null;\r\n    if (msgKey != null)\r\n        msg = fResourceBundle.getString(msgKey);\r\n    else\r\n        msgKey = \"\";\r\n    if (msg == null) {\r\n        throwex = true;\r\n        try {\r\n            msg = java.text.MessageFormat.format(MsgKey.BAD_MSGKEY, new Object[] { msgKey, m_resourceBundleName });\r\n        } catch (Exception e) {\r\n            msg = \"The message key '\" + msgKey + \"' is not in the message class '\" + m_resourceBundleName + \"'\";\r\n        }\r\n    } else if (args != null) {\r\n        try {\r\n            int n = args.length;\r\n            for (int i = 0; i < n; i++) {\r\n                if (null == args[i])\r\n                    args[i] = \"\";\r\n            }\r\n            fmsg = java.text.MessageFormat.format(msg, args);\r\n        } catch (Exception e) {\r\n            throwex = true;\r\n            try {\r\n                fmsg = java.text.MessageFormat.format(MsgKey.BAD_MSGFORMAT, new Object[] { msgKey, m_resourceBundleName });\r\n                fmsg += \" \" + msg;\r\n            } catch (Exception formatfailed) {\r\n                fmsg = \"The format of message '\" + msgKey + \"' in message class '\" + m_resourceBundleName + \"' failed.\";\r\n            }\r\n        }\r\n    } else\r\n        fmsg = msg;\r\n    if (throwex) {\r\n        throw new RuntimeException(fmsg);\r\n    }\r\n    return fmsg;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.getLastChild",
	"Comment": "given a node handle, advance to its last child.if not yet resolved, waits for more nodes to be added to the document andtries again.",
	"Method": "int getLastChild(int nodeHandle){\r\n    int identity = makeNodeIdentity(nodeHandle);\r\n    int child = _firstch(identity);\r\n    int lastChild = DTM.NULL;\r\n    while (child != DTM.NULL) {\r\n        lastChild = child;\r\n        child = _nextsib(child);\r\n    }\r\n    return makeNodeHandle(lastChild);\r\n}"
}, {
	"Path": "hudson.scm.ChangeLogAnnotator.unregister",
	"Comment": "unregisters this annotator, so that hudson stops using this object.",
	"Method": "boolean unregister(){\r\n    return all().remove(this);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.getAttributeNode",
	"Comment": "retrieves an attribute node by by qualified name and namespace uri.",
	"Method": "int getAttributeNode(int nodeHandle,String namespaceURI,String name){\r\n    for (int attrH = getFirstAttribute(nodeHandle); DTM.NULL != attrH; attrH = getNextAttribute(attrH)) {\r\n        String attrNS = getNamespaceURI(attrH);\r\n        String attrName = getLocalName(attrH);\r\n        boolean nsMatch = namespaceURI == attrNS || (namespaceURI != null && namespaceURI.equals(attrNS));\r\n        if (nsMatch && name.equals(attrName))\r\n            return attrH;\r\n    }\r\n    return DTM.NULL;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.setElementAt",
	"Comment": "sets the component at the specified index of this vector to be thespecified object. the previous component at that position is discarded.the index must be a value greater than or equal to 0 and lessthan the current size of the vector.",
	"Method": "void setElementAt(Node node,int index){\r\n    if (!m_mutable)\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null));\r\n    if (null == m_map) {\r\n        m_map = new Node[m_blocksize];\r\n        m_mapSize = m_blocksize;\r\n    }\r\n    m_map[index] = node;\r\n}"
}, {
	"Path": "org.apache.xml.utils.NodeVector.indexOf",
	"Comment": "searches for the first occurence of the given argument,beginning the search at index, and testing for equalityusing the equals method.",
	"Method": "int indexOf(int elem,int index,int indexOf,int elem){\r\n    if (null == m_map)\r\n        return -1;\r\n    for (int i = 0; i < m_firstFree; i++) {\r\n        int node = m_map[i];\r\n        if (node == elem)\r\n            return i;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.getEndColumnNumber",
	"Comment": "return the column number where the current document event ends.note that this is the column number of the firstcharacter after the text associated with the documentevent.the first column in a line is position 1.",
	"Method": "int getEndColumnNumber(){\r\n    return m_endColumnNumber;\r\n}"
}, {
	"Path": "hudson.security.HudsonPrivateSecurityRealm.hasSomeUser",
	"Comment": "computes if this hudson has some user accounts configured.this is used to check for the initial",
	"Method": "boolean hasSomeUser(){\r\n    for (User u : User.getAll()) if (u.getProperty(Details.class) != null)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.LSSerializerImpl.isHexDigit",
	"Comment": "returns true if the given character is a valid hex character.",
	"Method": "boolean isHexDigit(char c){\r\n    return (c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F');\r\n}"
}, {
	"Path": "com.sun.jna.BuildArmSoftFloatDetector.setTargetProperty",
	"Comment": "targetproperty receives the name of the property, that should take thenew property",
	"Method": "void setTargetProperty(String targetProperty){\r\n    this.targetProperty = targetProperty;\r\n}"
}, {
	"Path": "hudson.model.Job.getProperty",
	"Comment": "gets the specific property, or null if the property is not configured forthis job.",
	"Method": "T getProperty(Class<T> clazz,JobProperty getProperty,String className){\r\n    for (JobProperty p : properties) if (p.getClass().getName().equals(className))\r\n        return p;\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.setDocumentLocator",
	"Comment": "receive a locator object for document events.this is called by the parser to push a locator for thestylesheet being parsed. the stack needs to be poppedafter the stylesheet has been parsed. we pop inpopstylesheet.",
	"Method": "void setDocumentLocator(Locator locator){\r\n    m_stylesheetLocatorStack.push(new SAXSourceLocator(locator));\r\n}"
}, {
	"Path": "hudson.util.jelly.MorphTagLibrary.createTag",
	"Comment": "this code is really only used for dealing with dynamic tag libraries, so no point in implementingthis for statically used tag libraries.",
	"Method": "Tag createTag(String name,Attributes attributes){\r\n    return null;\r\n}"
}, {
	"Path": "hudson.PluginManagerCheckUpdateCenterTest.updateSiteReturn502Test",
	"Comment": "check if the page contains the right message after checking an update site with an url that returns a 502 error code.",
	"Method": "void updateSiteReturn502Test(){\r\n    checkUpdateSite(Jenkins.get().getRootUrl() + \"updateSite502/getJson\", \"IOException: Server returned HTTP response code: 502 for URL\", false);\r\n}"
}, {
	"Path": "org.apache.xpath.functions.Function.setArg",
	"Comment": "set an argument expression for a function.this method is called by the xpath compiler.",
	"Method": "void setArg(Expression arg,int argNum){\r\n    reportWrongNumberArgs();\r\n}"
}, {
	"Path": "jenkins.util.ProgressiveRendering.executorService",
	"Comment": "may be overridden to provide an alternate executor service.",
	"Method": "ExecutorService executorService(){\r\n    return Timer.get();\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.getDOMBackPointer",
	"Comment": "if this stylesheet was created from a dom, get thedom backpointer that this element originated from.for tooling use.",
	"Method": "org.w3c.dom.Node getDOMBackPointer(){\r\n    return m_DOMBackPointer;\r\n}"
}, {
	"Path": "com.sun.jna.contrib.demo.FilteredTextField.setValidRegex",
	"Comment": "sets the regular expression that is used for string validation.stringvalidation is checked when exiting the text field.",
	"Method": "void setValidRegex(String validRegex){\r\n    this.validRegex = validRegex;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.ObjectFactory.findJarServiceProviderName",
	"Comment": "find the name of service provider using jar service provider mechanism",
	"Method": "String findJarServiceProviderName(String factoryId){\r\n    SecuritySupport ss = SecuritySupport.getInstance();\r\n    String serviceId = SERVICES_PATH + factoryId;\r\n    InputStream is = null;\r\n    ClassLoader cl = findClassLoader();\r\n    is = ss.getResourceAsStream(cl, serviceId);\r\n    if (is == null) {\r\n        ClassLoader current = ObjectFactory.class.getClassLoader();\r\n        if (cl != current) {\r\n            cl = current;\r\n            is = ss.getResourceAsStream(cl, serviceId);\r\n        }\r\n    }\r\n    if (is == null) {\r\n        return null;\r\n    }\r\n    debugPrintln(\"found jar resource=\" + serviceId + \" using ClassLoader: \" + cl);\r\n    BufferedReader rd;\r\n    try {\r\n        rd = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n    } catch (java.io.UnsupportedEncodingException e) {\r\n        rd = new BufferedReader(new InputStreamReader(is));\r\n    }\r\n    String factoryClassName = null;\r\n    try {\r\n        factoryClassName = rd.readLine();\r\n    } catch (IOException x) {\r\n        return null;\r\n    } finally {\r\n        try {\r\n            rd.close();\r\n        } catch (IOException exc) {\r\n        }\r\n    }\r\n    if (factoryClassName != null && !\"\".equals(factoryClassName)) {\r\n        debugPrintln(\"found in resource, value=\" + factoryClassName);\r\n        return factoryClassName;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "redis.clients.jedis.ScanResult.isCompleteIteration",
	"Comment": "is the iteration complete. i.e. was the complete dataset scanned.",
	"Method": "boolean isCompleteIteration(){\r\n    return ScanParams.SCAN_POINTER_START.equals(getCursor());\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    resolvePrefixTables();\r\n    ElemTemplateElement t = getFirstChildElem();\r\n    m_hasTextLitOnly = ((t != null) && (t.getXSLToken() == Constants.ELEMNAME_TEXTLITERALRESULT) && (t.getNextSiblingElem() == null));\r\n    StylesheetRoot.ComposeState cstate = sroot.getComposeState();\r\n    cstate.pushStackMark();\r\n}"
}, {
	"Path": "org.apache.xpath.axes.SelfIteratorNoPredicate.asNode",
	"Comment": "return the first node out of the nodeset, if this expression is a nodeset expression.this is the default implementation for nodesets.derived classes should try and override this and return a value without having to do a clone operation.",
	"Method": "int asNode(XPathContext xctxt){\r\n    return xctxt.getCurrentNode();\r\n}"
}, {
	"Path": "jenkins.install.UpgradeWizard.applyForcedChanges",
	"Comment": "put here the different changes that are enforced after an update.",
	"Method": "void applyForcedChanges(){\r\n    ApiTokenPropertyConfiguration apiTokenPropertyConfiguration = ApiTokenPropertyConfiguration.get();\r\n    if (!apiTokenPropertyConfiguration.hasExistingConfigFile()) {\r\n        LOGGER.log(Level.INFO, \"New API token system configured with insecure options to keep legacy behavior\");\r\n        apiTokenPropertyConfiguration.setCreationOfLegacyTokenEnabled(false);\r\n        apiTokenPropertyConfiguration.setTokenGenerationOnCreationEnabled(false);\r\n    }\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.addJavaLibraries",
	"Comment": "add any libraries that come with different java versionshere",
	"Method": "void addJavaLibraries(){\r\n    Vector packages = JavaEnvUtils.getJrePackages();\r\n    Enumeration e = packages.elements();\r\n    while (e.hasMoreElements()) {\r\n        String packageName = (String) e.nextElement();\r\n        addSystemPackageRoot(packageName);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.MsgMgr.message",
	"Comment": "warn the user of a problem.this is public for access by extensions.",
	"Method": "void message(SourceLocator srcLctr,String msg,boolean terminate){\r\n    ErrorListener errHandler = m_transformer.getErrorListener();\r\n    if (null != errHandler) {\r\n        errHandler.warning(new TransformerException(msg, srcLctr));\r\n    } else {\r\n        if (terminate)\r\n            throw new TransformerException(msg, srcLctr);\r\n        else\r\n            System.out.println(msg);\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.collectionpipeline.ImperativeProgramming.getModelsAfter2000",
	"Comment": "method to return the car models built after year 2000 using for loops.",
	"Method": "List<String> getModelsAfter2000(List<Car> cars){\r\n    List<Car> carsSortedByYear = new ArrayList();\r\n    for (Car car : cars) {\r\n        if (car.getYear() > 2000) {\r\n            carsSortedByYear.add(car);\r\n        }\r\n    }\r\n    Collections.sort(carsSortedByYear, new Comparator<Car>() {\r\n        public int compare(Car car1, Car car2) {\r\n            return new Integer(car1.getYear()).compareTo(car2.getYear());\r\n        }\r\n    });\r\n    List<String> models = new ArrayList();\r\n    for (Car car : carsSortedByYear) {\r\n        models.add(car.getModel());\r\n    }\r\n    return models;\r\n}"
}, {
	"Path": "com.iluwatar.collectionpipeline.ImperativeProgramming.getModelsAfter2000",
	"Comment": "method to return the car models built after year 2000 using for loops.",
	"Method": "List<String> getModelsAfter2000(List<Car> cars){\r\n    return new Integer(car1.getYear()).compareTo(car2.getYear());\r\n}"
}, {
	"Path": "org.apache.xml.serializer.NamespaceMappings.lookupPrefix",
	"Comment": "given a namespace uri, and the namespaces mappings for thecurrent element, return the current prefix for that uri.",
	"Method": "String lookupPrefix(String uri){\r\n    String foundPrefix = null;\r\n    Enumeration prefixes = m_namespaces.keys();\r\n    while (prefixes.hasMoreElements()) {\r\n        String prefix = (String) prefixes.nextElement();\r\n        String uri2 = lookupNamespace(prefix);\r\n        if (uri2 != null && uri2.equals(uri)) {\r\n            foundPrefix = prefix;\r\n            break;\r\n        }\r\n    }\r\n    return foundPrefix;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.popPair",
	"Comment": "pop a pair of nodes from the tail of the stack. special purpose method for transformerimpl, pushelemtemplateelement.performance critical.",
	"Method": "void popPair(){\r\n    m_firstFree -= 2;\r\n    m_map[m_firstFree] = null;\r\n    m_map[m_firstFree + 1] = null;\r\n}"
}, {
	"Path": "redis.clients.jedis.BinaryJedis.eval",
	"Comment": "evaluates scripts using the lua interpreter built into redis starting from version 2.6.0.",
	"Method": "Object eval(byte[] script,List<byte[]> keys,List<byte[]> args,Object eval,byte[] script,byte[] keyCount,byte[] params,Object eval,byte[] script,int keyCount,byte[] params,Object eval,byte[] script){\r\n    return eval(script, 0);\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.checkGoodName",
	"Comment": "check if the given name is suitable as a namefor job, view, etc.",
	"Method": "void checkGoodName(String name){\r\n    if (name == null || name.length() == 0)\r\n        throw new Failure(Messages.Hudson_NoName());\r\n    if (\".\".equals(name.trim()))\r\n        throw new Failure(Messages.Jenkins_NotAllowedName(\".\"));\r\n    if (\"..\".equals(name.trim()))\r\n        throw new Failure(Messages.Jenkins_NotAllowedName(\"..\"));\r\n    for (int i = 0; i < name.length(); i++) {\r\n        char ch = name.charAt(i);\r\n        if (Character.isISOControl(ch)) {\r\n            throw new Failure(Messages.Hudson_ControlCodeNotAllowed(toPrintableName(name)));\r\n        }\r\n        if (\"?*/\\\\%!@#$^&|<>[]:;\".indexOf(ch) != -1)\r\n            throw new Failure(Messages.Hudson_UnsafeChar(ch));\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.assertIsLocPathIterator",
	"Comment": "assert that the expression is a locpathiterator, and, if not, try to give some diagnostic info.",
	"Method": "void assertIsLocPathIterator(Expression expr1,ExpressionOwner eo){\r\n    if (!(expr1 instanceof LocPathIterator)) {\r\n        String errMsg;\r\n        if (expr1 instanceof Variable) {\r\n            errMsg = \"Programmer's assertion: expr1 not an iterator: \" + ((Variable) expr1).getQName();\r\n        } else {\r\n            errMsg = \"Programmer's assertion: expr1 not an iterator: \" + expr1.getClass().getName();\r\n        }\r\n        throw new RuntimeException(errMsg + \", \" + eo.getClass().getName() + \" \" + expr1.exprGetParent());\r\n    }\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.getResourceURL",
	"Comment": "returns the url of a given resource in the given file which mayeither be a directory or a zip file.",
	"Method": "URL getResourceURL(File file,String resourceName){\r\n    try {\r\n        JarFile jarFile = (JarFile) jarFiles.get(file);\r\n        if (jarFile == null && file.isDirectory()) {\r\n            File resource = new File(file, resourceName);\r\n            if (resource.exists()) {\r\n                try {\r\n                    return FILE_UTILS.getFileURL(resource);\r\n                } catch (MalformedURLException ex) {\r\n                    return null;\r\n                }\r\n            }\r\n        } else {\r\n            if (jarFile == null) {\r\n                if (file.exists()) {\r\n                    jarFile = new JarFile(file);\r\n                    jarFiles.put(file, jarFile);\r\n                } else {\r\n                    return null;\r\n                }\r\n                jarFile = (JarFile) jarFiles.get(file);\r\n            }\r\n            JarEntry entry = jarFile.getJarEntry(resourceName);\r\n            if (entry != null) {\r\n                try {\r\n                    return new URL(\"jar:\" + FILE_UTILS.getFileURL(file) + \"!/\" + entry);\r\n                } catch (MalformedURLException ex) {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        String msg = \"Unable to obtain resource from \" + file + \": \";\r\n        log(msg + e, Project.MSG_WARN);\r\n        System.err.println(msg);\r\n        e.printStackTrace();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "hudson.security.HudsonPrivateSecurityRealm.doCreateFirstAccount",
	"Comment": "creates a first admin user account.this can be run by anyone, but only to create the very first user account.",
	"Method": "void doCreateFirstAccount(StaplerRequest req,StaplerResponse rsp){\r\n    if (hasSomeUser()) {\r\n        rsp.sendError(SC_UNAUTHORIZED, \"First user was already created\");\r\n        return;\r\n    }\r\n    User u = createAccount(req, rsp, false, \"firstUser.jelly\");\r\n    if (u != null) {\r\n        tryToMakeAdmin(u);\r\n        loginAndTakeBack(req, rsp, u);\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.model.view.controller.GiantControllerTest.testSetHealth",
	"Comment": "verify if the controller passes the health level through to the model and vice versa",
	"Method": "void testSetHealth(){\r\n    final GiantModel model = mock(GiantModel.class);\r\n    final GiantView view = mock(GiantView.class);\r\n    final GiantController controller = new GiantController(model, view);\r\n    verifyZeroInteractions(model, view);\r\n    for (final Health health : Health.values()) {\r\n        controller.setHealth(health);\r\n        verify(model).setHealth(health);\r\n        verifyZeroInteractions(view);\r\n    }\r\n    controller.getHealth();\r\n    verify(model).getHealth();\r\n    verifyNoMoreInteractions(model, view);\r\n}"
}, {
	"Path": "hudson.model.AbstractModelObject.requirePOST",
	"Comment": "convenience method to verify that the current request is a post request.",
	"Method": "void requirePOST(){\r\n    StaplerRequest req = Stapler.getCurrentRequest();\r\n    if (req == null)\r\n        return;\r\n    String method = req.getMethod();\r\n    if (!method.equalsIgnoreCase(\"POST\"))\r\n        throw new ServletException(\"Must be POST, Can't be \" + method);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.getNodeValue",
	"Comment": "given a node handle, return its node value. this is mostlyas defined by the dom, but may ignore some conveniences.",
	"Method": "String getNodeValue(int nodeHandle){\r\n    int identity = makeNodeIdentity(nodeHandle);\r\n    int type = _type(identity);\r\n    if (isTextType(type)) {\r\n        int dataIndex = _dataOrQName(identity);\r\n        int offset = m_data.elementAt(dataIndex);\r\n        int length = m_data.elementAt(dataIndex + 1);\r\n        return m_chars.getString(offset, length);\r\n    } else if (DTM.ELEMENT_NODE == type || DTM.DOCUMENT_FRAGMENT_NODE == type || DTM.DOCUMENT_NODE == type) {\r\n        return null;\r\n    } else {\r\n        int dataIndex = _dataOrQName(identity);\r\n        if (dataIndex < 0) {\r\n            dataIndex = -dataIndex;\r\n            dataIndex = m_data.elementAt(dataIndex + 1);\r\n        }\r\n        return m_valuesOrPrefixes.indexToString(dataIndex);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.FuncFormatNumb.checkNumberArgs",
	"Comment": "overide the superclass method to allow one or two arguments.",
	"Method": "void checkNumberArgs(int argNum){\r\n    if ((argNum > 3) || (argNum < 2))\r\n        reportWrongNumberArgs();\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.setOutputFormat",
	"Comment": "specifies an output format for this serializer. it theserializer has already been associated with an output format,it will switch to the new format. this method should not becalled while the serializer is in the process of serializinga document.",
	"Method": "void setOutputFormat(Properties format){\r\n    boolean shouldFlush = m_shouldFlush;\r\n    if (format != null) {\r\n        Enumeration propNames;\r\n        propNames = format.propertyNames();\r\n        while (propNames.hasMoreElements()) {\r\n            String key = (String) propNames.nextElement();\r\n            String value = format.getProperty(key);\r\n            String explicitValue = (String) format.get(key);\r\n            if (explicitValue == null && value != null) {\r\n                this.setOutputPropertyDefault(key, value);\r\n            }\r\n            if (explicitValue != null) {\r\n                this.setOutputProperty(key, explicitValue);\r\n            }\r\n        }\r\n    }\r\n    String entitiesFileName = (String) format.get(OutputPropertiesFactory.S_KEY_ENTITIES);\r\n    if (null != entitiesFileName) {\r\n        String method = (String) format.get(OutputKeys.METHOD);\r\n        m_charInfo = CharInfo.getCharInfo(entitiesFileName, method);\r\n    }\r\n    m_shouldFlush = shouldFlush;\r\n}"
}, {
	"Path": "hudson.slaves.EnvironmentVariableNodePropertyTest.testSlaveAndMasterPropertyOnSlave",
	"Comment": "both slave and master properties are available, but slave properties have priority",
	"Method": "void testSlaveAndMasterPropertyOnSlave(){\r\n    jenkins.getGlobalNodeProperties().replaceBy(Collections.singleton(new EnvironmentVariablesNodeProperty(new Entry(\"KEY\", \"masterValue\"))));\r\n    setVariables(slave, new Entry(\"KEY\", \"slaveValue\"));\r\n    Map<String, String> envVars = executeBuild(slave);\r\n    assertEquals(\"slaveValue\", envVars.get(\"KEY\"));\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.setOutputStream",
	"Comment": "specifies an output stream to which the document should beserialized. this method should not be called while theserializer is in the process of serializing a document.the encoding specified in the output properties is used, orif no encoding was specified, the default for the selectedoutput method.",
	"Method": "void setOutputStream(OutputStream output){\r\n    setOutputStreamInternal(output, true);\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.getActiveAdministrativeMonitors",
	"Comment": "returns the enabled and activated administrative monitors.",
	"Method": "List<AdministrativeMonitor> getActiveAdministrativeMonitors(){\r\n    return administrativeMonitors.stream().filter(m -> m.isEnabled() && m.isActivated()).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.previousNode",
	"Comment": "returns the previous node in the set and moves the position of theiterator backwards in the set.",
	"Method": "int previousNode(){\r\n    if (!m_cacheNodes)\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_CANNOT_ITERATE, null));\r\n    if ((m_next - 1) > 0) {\r\n        m_next--;\r\n        return this.elementAt(m_next);\r\n    } else\r\n        return DTM.NULL;\r\n}"
}, {
	"Path": "hudson.triggers.Trigger.getSpec",
	"Comment": "gets the crontab specification.if you are not using cron service, just ignore it.",
	"Method": "String getSpec(){\r\n    return spec;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemSort.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n    StylesheetRoot.ComposeState cstate = sroot.getComposeState();\r\n    java.util.Vector vnames = cstate.getVariableNames();\r\n    if (null != m_caseorder_avt)\r\n        m_caseorder_avt.fixupVariables(vnames, cstate.getGlobalsSize());\r\n    if (null != m_dataType_avt)\r\n        m_dataType_avt.fixupVariables(vnames, cstate.getGlobalsSize());\r\n    if (null != m_lang_avt)\r\n        m_lang_avt.fixupVariables(vnames, cstate.getGlobalsSize());\r\n    if (null != m_order_avt)\r\n        m_order_avt.fixupVariables(vnames, cstate.getGlobalsSize());\r\n    if (null != m_selectExpression)\r\n        m_selectExpression.fixupVariables(vnames, cstate.getGlobalsSize());\r\n}"
}, {
	"Path": "org.apache.xalan.processor.XSLTElementDef.equalsMayBeNull",
	"Comment": "tell if two objects are equal, when either one may be null.if both are null, they are considered equal.",
	"Method": "boolean equalsMayBeNull(Object obj1,Object obj2){\r\n    return (obj2 == obj1) || ((null != obj1) && (null != obj2) && obj2.equals(obj1));\r\n}"
}, {
	"Path": "hudson.org.apache.tools.tar.TarInputStream.copyEntryContents",
	"Comment": "copies the contents of the current tar archive entry directly intoan output stream.",
	"Method": "void copyEntryContents(OutputStream out){\r\n    byte[] buf = new byte[32 * 1024];\r\n    while (true) {\r\n        int numRead = this.read(buf, 0, buf.length);\r\n        if (numRead == -1) {\r\n            break;\r\n        }\r\n        out.write(buf, 0, numRead);\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.dao.DbCustomerDaoTest.getNonExistingCustomerId",
	"Comment": "an arbitrary number which does not correspond to an active customer id.",
	"Method": "int getNonExistingCustomerId(){\r\n    return 999;\r\n}"
}, {
	"Path": "hudson.Functions.getRelativeLinkTo",
	"Comment": "computes the relative path from the current page to the given item.",
	"Method": "String getRelativeLinkTo(Item p){\r\n    Map<Object, String> ancestors = new HashMap<Object, String>();\r\n    View view = null;\r\n    StaplerRequest request = Stapler.getCurrentRequest();\r\n    for (Ancestor a : request.getAncestors()) {\r\n        ancestors.put(a.getObject(), a.getRelativePath());\r\n        if (a.getObject() instanceof View)\r\n            view = (View) a.getObject();\r\n    }\r\n    String path = ancestors.get(p);\r\n    if (path != null) {\r\n        return normalizeURI(path + '/');\r\n    }\r\n    Item i = p;\r\n    String url = \"\";\r\n    while (true) {\r\n        ItemGroup ig = i.getParent();\r\n        url = i.getShortUrl() + url;\r\n        if (ig == Jenkins.getInstance() || (view != null && ig == view.getOwner().getItemGroup())) {\r\n            assert i instanceof TopLevelItem;\r\n            if (view != null) {\r\n                return normalizeURI(ancestors.get(view) + '/' + url);\r\n            } else {\r\n                return normalizeURI(request.getContextPath() + '/' + p.getUrl());\r\n            }\r\n        }\r\n        path = ancestors.get(ig);\r\n        if (path != null) {\r\n            return normalizeURI(path + '/' + url);\r\n        }\r\n        assert ig instanceof Item;\r\n        i = (Item) ig;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.axes.AxesWalker.callVisitors",
	"Comment": "this will traverse the heararchy, calling the visitor for each member.if the called visitor method returns false, the subtree should not be called.",
	"Method": "void callVisitors(ExpressionOwner owner,XPathVisitor visitor){\r\n    if (visitor.visitStep(owner, this)) {\r\n        callPredicateVisitors(visitor);\r\n        if (null != m_nextWalker) {\r\n            m_nextWalker.callVisitors(this, visitor);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.model.view.controller.GiantModelTest.testSetHealth",
	"Comment": "verify if the health value is set properly though the constructor and setter",
	"Method": "void testSetHealth(){\r\n    final GiantModel model = new GiantModel(Health.HEALTHY, Fatigue.ALERT, Nourishment.SATURATED);\r\n    assertEquals(Health.HEALTHY, model.getHealth());\r\n    for (final Health health : Health.values()) {\r\n        model.setHealth(health);\r\n        assertEquals(health, model.getHealth());\r\n        assertEquals(\"The giant looks \" + health.toString() + \", alert and saturated.\", model.toString());\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.findCommonAncestor",
	"Comment": "given a linked list of expressions, find the common ancestor that is suitable for holding a psuedo variable for shared access.",
	"Method": "ElemTemplateElement findCommonAncestor(MultistepExprHolder head){\r\n    int numExprs = head.getLength();\r\n    ElemTemplateElement[] elems = new ElemTemplateElement[numExprs];\r\n    int[] ancestorCounts = new int[numExprs];\r\n    MultistepExprHolder next = head;\r\n    int shortestAncestorCount = 10000;\r\n    for (int i = 0; i < numExprs; i++) {\r\n        ElemTemplateElement elem = getElemFromExpression(next.m_exprOwner.getExpression());\r\n        elems[i] = elem;\r\n        int numAncestors = countAncestors(elem);\r\n        ancestorCounts[i] = numAncestors;\r\n        if (numAncestors < shortestAncestorCount) {\r\n            shortestAncestorCount = numAncestors;\r\n        }\r\n        next = next.m_next;\r\n    }\r\n    for (int i = 0; i < numExprs; i++) {\r\n        if (ancestorCounts[i] > shortestAncestorCount) {\r\n            int numStepCorrection = ancestorCounts[i] - shortestAncestorCount;\r\n            for (int j = 0; j < numStepCorrection; j++) {\r\n                elems[i] = elems[i].getParentElem();\r\n            }\r\n        }\r\n    }\r\n    ElemTemplateElement first = null;\r\n    while (shortestAncestorCount-- >= 0) {\r\n        boolean areEqual = true;\r\n        first = elems[0];\r\n        for (int i = 1; i < numExprs; i++) {\r\n            if (first != elems[i]) {\r\n                areEqual = false;\r\n                break;\r\n            }\r\n        }\r\n        if (areEqual && isNotSameAsOwner(head, first) && first.canAcceptVariables()) {\r\n            if (DIAGNOSE_MULTISTEPLIST) {\r\n                System.err.print(first.getClass().getName());\r\n                System.err.println(\" at   \" + first.getSystemId() + \" Line \" + first.getLineNumber());\r\n            }\r\n            return first;\r\n        }\r\n        for (int i = 0; i < numExprs; i++) {\r\n            elems[i] = elems[i].getParentElem();\r\n        }\r\n    }\r\n    assertion(false, \"Could not find common ancestor!!!\");\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.XPathParser.assertion",
	"Comment": "notify the user of an assertion error, and probably throw anexception.",
	"Method": "void assertion(boolean b,String msg){\r\n    if (!b) {\r\n        String fMsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION, new Object[] { msg });\r\n        throw new RuntimeException(fMsg);\r\n    }\r\n}"
}, {
	"Path": "hudson.FilePath.readToString",
	"Comment": "reads this file into a string, by using the current system encoding.",
	"Method": "String readToString(){\r\n    try (InputStream in = read()) {\r\n        return org.apache.commons.io.IOUtils.toString(in);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.axes.ChildTestIterator.setRoot",
	"Comment": "initialize the context values for this expressionafter it is cloned.",
	"Method": "void setRoot(int context,Object environment){\r\n    super.setRoot(context, environment);\r\n    m_traverser = m_cdtm.getAxisTraverser(Axis.CHILD);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.EncodingInfo.isInEncoding",
	"Comment": "this is not a public api. it returns true if thechar in question is in the encoding.",
	"Method": "boolean isInEncoding(char ch,boolean isInEncoding,char high,char low,boolean isInEncoding,char ch,boolean isInEncoding,char high,char low,boolean isInEncoding,char ch1,boolean isInEncoding,char high,char low){\r\n    if (m_encoding == null) {\r\n        m_encoding = new EncodingImpl();\r\n    }\r\n    return m_encoding.isInEncoding(high, low);\r\n}"
}, {
	"Path": "hudson.util.spring.BeanBuilder.getSpringConfig",
	"Comment": "retrieves the runtimespringconfiguration instance used by the beanbuilder",
	"Method": "RuntimeSpringConfiguration getSpringConfig(){\r\n    return springConfig;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.getExpandEntityReferences",
	"Comment": "the value of this flag determines whether the children of entityreference nodes are visible to the iterator. if false, they will beskipped over. to produce a view of the document that has entity referencesexpanded and does not expose the entity reference node itself, use thewhattoshow flags to hide the entity reference node and setexpandentityreferences to true when creating the iterator. to producea view of the document that has entity reference nodes but no entityexpansion, use the whattoshow flags to show the entity reference nodeand set expandentityreferences to false.",
	"Method": "boolean getExpandEntityReferences(){\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.setDOMBackPointer",
	"Comment": "if this stylesheet was created from a dom, set thedom backpointer that this element originated from.for tooling use.",
	"Method": "void setDOMBackPointer(org.w3c.dom.Node n){\r\n    m_DOMBackPointer = n;\r\n}"
}, {
	"Path": "com.iluwatar.tls.DateFormatCallableTestMultiThread.testDateValues",
	"Comment": "test date values after the run of dateformatrunnalbe. a correct run should deliver 5 times 15.12.2015by each thread",
	"Method": "void testDateValues(){\r\n    for (int i = 0; i < createdDateValues.length; i++) {\r\n        assertEquals(expectedDateValues, createdDateValues[i]);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.serialize.SerializerUtils.outputResultTreeFragment",
	"Comment": "given a result tree fragment, walk the tree andoutput it to the serializationhandler.",
	"Method": "void outputResultTreeFragment(SerializationHandler handler,XObject obj,XPathContext support){\r\n    int doc = obj.rtf();\r\n    DTM dtm = support.getDTM(doc);\r\n    if (null != dtm) {\r\n        for (int n = dtm.getFirstChild(doc); DTM.NULL != n; n = dtm.getNextSibling(n)) {\r\n            handler.flushPending();\r\n            if (dtm.getNodeType(n) == DTM.ELEMENT_NODE && dtm.getNamespaceURI(n) == null)\r\n                handler.startPrefixMapping(\"\", \"\");\r\n            dtm.dispatchToEvents(n, handler);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "jenkins.security.security218.ysoserial.payloads.JSON1.makeCallerChain",
	"Comment": "will call all getter methods on payload that are defined in the given interfaces",
	"Method": "Map makeCallerChain(Object payload,Class ifaces){\r\n    CompositeType rt = new CompositeType(\"a\", \"b\", new String[] { \"a\" }, new String[] { \"a\" }, new OpenType[] { javax.management.openmbean.SimpleType.INTEGER });\r\n    TabularType tt = new TabularType(\"a\", \"b\", rt, new String[] { \"a\" });\r\n    TabularDataSupport t1 = new TabularDataSupport(tt);\r\n    TabularDataSupport t2 = new TabularDataSupport(tt);\r\n    AdvisedSupport as = new AdvisedSupport();\r\n    as.setTarget(payload);\r\n    InvocationHandler delegateInvocationHandler = (InvocationHandler) Reflections.getFirstCtor(\"org.springframework.aop.framework.JdkDynamicAopProxy\").newInstance(as);\r\n    InvocationHandler cdsInvocationHandler = Gadgets.createMemoizedInvocationHandler(Gadgets.createMap(\"getCompositeType\", rt));\r\n    CompositeInvocationHandlerImpl invocationHandler = new CompositeInvocationHandlerImpl();\r\n    invocationHandler.addInvocationHandler(CompositeData.class, cdsInvocationHandler);\r\n    invocationHandler.setDefaultHandler(delegateInvocationHandler);\r\n    final CompositeData cdsProxy = Gadgets.createProxy(invocationHandler, CompositeData.class, ifaces);\r\n    JSONObject jo = new JSONObject();\r\n    Map m = new HashMap();\r\n    m.put(\"t\", cdsProxy);\r\n    Reflections.setFieldValue(jo, \"properties\", m);\r\n    Reflections.setFieldValue(jo, \"properties\", m);\r\n    Reflections.setFieldValue(t1, \"dataMap\", jo);\r\n    Reflections.setFieldValue(t2, \"dataMap\", jo);\r\n    return Gadgets.makeMap(t1, t2);\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerIdentityImpl.getParameter",
	"Comment": "get a parameter that was explicitly set with setparameteror setparameters.this method does not return a default parameter value, whichcannot be determined until the node context is evaluated duringthe transformation process.",
	"Method": "Object getParameter(String name){\r\n    if (null == m_params)\r\n        return null;\r\n    return m_params.get(name);\r\n}"
}, {
	"Path": "jenkins.slaves.RemotingWorkDirSettings.toCommandLineString",
	"Comment": "gets a command line string, which can be passed to agent start command.",
	"Method": "String toCommandLineString(SlaveComputer computer){\r\n    if (disabled) {\r\n        return \"\";\r\n    }\r\n    StringBuilder bldr = new StringBuilder();\r\n    bldr.append(\"-workDir \\\"\");\r\n    if (workDirPath == null) {\r\n        Slave node = computer.getNode();\r\n        if (node == null) {\r\n            return \"\";\r\n        }\r\n        bldr.append(node.getRemoteFS());\r\n    } else {\r\n        bldr.append(workDirPath);\r\n    }\r\n    bldr.append(\"\\\"\");\r\n    if (!DEFAULT_INTERNAL_DIR.equals(internalDir)) {\r\n        bldr.append(\" -internalDir \\\"\");\r\n        bldr.append(internalDir);\r\n        bldr.append(\"\\\"\");\r\n    }\r\n    if (failIfWorkDirIsMissing) {\r\n        bldr.append(\" -failIfWorkDirIsMissing\");\r\n    }\r\n    return bldr.toString();\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FunctionDef1Arg.getArg0AsNode",
	"Comment": "execute the first argument expression that is expected to return anodeset.if the argument is null, then return the current context node.",
	"Method": "int getArg0AsNode(XPathContext xctxt){\r\n    return (null == m_arg0) ? xctxt.getCurrentNode() : m_arg0.asNode(xctxt);\r\n}"
}, {
	"Path": "org.apache.xml.utils.ObjectStack.pop",
	"Comment": "removes the object at the top of this stack and returns thatobject as the value of this function.",
	"Method": "Object pop(){\r\n    Object val = m_map[--m_firstFree];\r\n    m_map[m_firstFree] = null;\r\n    return val;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.Function2Args.checkNumberArgs",
	"Comment": "check that the number of arguments passed to this function is correct.",
	"Method": "void checkNumberArgs(int argNum){\r\n    if (argNum != 2)\r\n        reportWrongNumberArgs();\r\n}"
}, {
	"Path": "com.iluwatar.chain.Request.getRequestType",
	"Comment": "get the type of this request, used by each person in the chain of command to see if they shouldor can handle this particular request",
	"Method": "RequestType getRequestType(){\r\n    return requestType;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.PredicatedNodeTest.setLocPathIterator",
	"Comment": "set the location path iterator owner for this walker.besides initialization, this function is called during cloning operations.",
	"Method": "void setLocPathIterator(LocPathIterator li){\r\n    m_lpi = li;\r\n    if (this != li)\r\n        li.exprSetParent(this);\r\n}"
}, {
	"Path": "hudson.model.Queue.liveGetItems",
	"Comment": "gets the information about the queue item for the given project.",
	"Method": "List<Item> liveGetItems(Task t){\r\n    lock.lock();\r\n    try {\r\n        List<Item> result = new ArrayList<Item>();\r\n        result.addAll(blockedProjects.getAll(t));\r\n        result.addAll(buildables.getAll(t));\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            List<BuildableItem> thePendings = pendings.getAll(t);\r\n            if (!thePendings.isEmpty()) {\r\n                LOGGER.log(Level.FINE, \"ignoring {0} during scheduleInternal\", thePendings);\r\n            }\r\n        }\r\n        for (Item item : waitingList) {\r\n            if (item.task.equals(t)) {\r\n                result.add(item);\r\n            }\r\n        }\r\n        return result;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.getSchema",
	"Comment": "get the root of the xslt schema, which tells us how totransition content handlers, create elements, etc.",
	"Method": "XSLTSchema getSchema(){\r\n    return m_schema;\r\n}"
}, {
	"Path": "hudson.FilePath.copyToWithPermission",
	"Comment": "copies this file to the specified target, with file permissions and other meta attributes intact.",
	"Method": "void copyToWithPermission(FilePath target){\r\n    if (this.channel == target.channel) {\r\n        act(new CopyToWithPermission(target));\r\n        return;\r\n    }\r\n    copyTo(target);\r\n    target.chmod(mode());\r\n    target.setLastModifiedIfPossible(lastModified());\r\n}"
}, {
	"Path": "hudson.util.ClockDifference.isDangerous",
	"Comment": "returns true if the difference is big enough to be considered dangerous.",
	"Method": "boolean isDangerous(){\r\n    return Math.abs(diff) > 5000;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.Stylesheet.setStylesheetParent",
	"Comment": "set the parent of the stylesheet.this should be null if thisis the root stylesheet.",
	"Method": "void setStylesheetParent(Stylesheet v){\r\n    m_stylesheetParent = v;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.cloneWithReset",
	"Comment": "get a cloned iterator that is reset to the beginningof the query.",
	"Method": "DTMIterator cloneWithReset(){\r\n    LocPathIterator clone;\r\n    clone = (LocPathIterator) m_clones.getInstanceOrThrow();\r\n    clone.m_execContext = m_execContext;\r\n    clone.m_cdtm = m_cdtm;\r\n    clone.m_context = m_context;\r\n    clone.m_currentContextNode = m_currentContextNode;\r\n    clone.m_stackFrame = m_stackFrame;\r\n    return clone;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.warning",
	"Comment": "receive notification of a parser warning.the default implementation does nothing.application writersmay override this method in a subclass to take specific actionsfor each warning, such as inserting the message in a log file orprinting it to the console.",
	"Method": "void warning(SAXParseException e){\r\n    System.err.println(e.getMessage());\r\n}"
}, {
	"Path": "org.apache.xpath.axes.AxesWalker.setPrevWalker",
	"Comment": "set or clear the previous walker reference in the location step chain.",
	"Method": "void setPrevWalker(AxesWalker walker){\r\n    m_prevWalker = walker;\r\n}"
}, {
	"Path": "ciphers.AES.shiftRows",
	"Comment": "cell permutation step. shifts cells within the rows of the input and returns\tthe result.",
	"Method": "BigInteger shiftRows(BigInteger ciphertext){\r\n    int[] cells = splitBlockIntoCells(ciphertext);\r\n    int[] output = new int[16];\r\n    output[0] = cells[0];\r\n    output[4] = cells[4];\r\n    output[8] = cells[8];\r\n    output[12] = cells[12];\r\n    output[1] = cells[5];\r\n    output[5] = cells[9];\r\n    output[9] = cells[13];\r\n    output[13] = cells[1];\r\n    output[2] = cells[10];\r\n    output[6] = cells[14];\r\n    output[10] = cells[2];\r\n    output[14] = cells[6];\r\n    output[3] = cells[15];\r\n    output[7] = cells[3];\r\n    output[11] = cells[7];\r\n    output[15] = cells[11];\r\n    return mergeCellsIntoBlock(output);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemAttribute.resolvePrefix",
	"Comment": "resolve the namespace into a prefix.at this level, if no prefix exists, then return a manufactured prefix.",
	"Method": "String resolvePrefix(SerializationHandler rhandler,String prefix,String nodeNamespace){\r\n    if (null != prefix && (prefix.length() == 0 || prefix.equals(\"xmlns\"))) {\r\n        prefix = rhandler.getPrefix(nodeNamespace);\r\n        if (null == prefix || prefix.length() == 0 || prefix.equals(\"xmlns\")) {\r\n            if (nodeNamespace.length() > 0) {\r\n                NamespaceMappings prefixMapping = rhandler.getNamespaceMappings();\r\n                prefix = prefixMapping.generateNextPrefix();\r\n            } else\r\n                prefix = \"\";\r\n        }\r\n    }\r\n    return prefix;\r\n}"
}, {
	"Path": "hudson.cli.DisablePluginCommand.getResultCode",
	"Comment": "calculate the result code of the disablement of one plugin based in what went on during the process of this oneand its dependant plugins.",
	"Method": "int getResultCode(List<PluginWrapper.PluginDisableResult> results,int getResultCode,PluginWrapper.PluginDisableResult result){\r\n    int returnCode = 0;\r\n    switch(result.getStatus()) {\r\n        case NOT_DISABLED_DEPENDANTS:\r\n            returnCode = RETURN_CODE_NOT_DISABLED_DEPENDANTS;\r\n            break;\r\n        case NO_SUCH_PLUGIN:\r\n            returnCode = RETURN_CODE_NO_SUCH_PLUGIN;\r\n    }\r\n    if (returnCode == 0) {\r\n        for (PluginWrapper.PluginDisableResult oneDependantResult : result.getDependantsDisableStatus()) {\r\n            returnCode = getResultCode(oneDependantResult);\r\n            if (returnCode != 0) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return returnCode;\r\n}"
}, {
	"Path": "org.apache.xalan.Version.getMaintenanceVersionNum",
	"Comment": "maintenance drop number.optional identifier used to designate maintenance drop applied to a specific release and contains fixes for defects reported. it maintains compatibility with the release and contains no api changes. when missing, it designates the final and complete development drop for a release.",
	"Method": "int getMaintenanceVersionNum(){\r\n    return 1;\r\n}"
}, {
	"Path": "hudson.model.listeners.ItemListener.register",
	"Comment": "registers this instance to hudson and start getting notifications.",
	"Method": "void register(){\r\n    all().add(this);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemWhen.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n    java.util.Vector vnames = sroot.getComposeState().getVariableNames();\r\n    if (null != m_test)\r\n        m_test.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());\r\n}"
}, {
	"Path": "jenkins.security.apitoken.ApiTokenStore.regenerateTokenFromLegacy",
	"Comment": "remove the legacy token present and generate a new one using the given secret.",
	"Method": "void regenerateTokenFromLegacy(Secret newLegacyApiToken){\r\n    deleteAllLegacyAndGenerateNewOne(newLegacyApiToken, false);\r\n}"
}, {
	"Path": "com.iluwatar.collectionpipeline.ImperativeProgramming.getSedanCarsOwnedSortedByDate",
	"Comment": "method to get all sedan cars belonging to a group of persons sorted by year of manufacture using for loops",
	"Method": "List<Car> getSedanCarsOwnedSortedByDate(List<Person> persons){\r\n    List<Car> cars = new ArrayList();\r\n    for (Person person : persons) {\r\n        cars.addAll(person.getCars());\r\n    }\r\n    List<Car> sedanCars = new ArrayList();\r\n    for (Car car : cars) {\r\n        if (Category.SEDAN.equals(car.getCategory())) {\r\n            sedanCars.add(car);\r\n        }\r\n    }\r\n    sedanCars.sort(new Comparator<Car>() {\r\n        @Override\r\n        public int compare(Car o1, Car o2) {\r\n            return o1.getYear() - o2.getYear();\r\n        }\r\n    });\r\n    return sedanCars;\r\n}"
}, {
	"Path": "com.iluwatar.collectionpipeline.ImperativeProgramming.getSedanCarsOwnedSortedByDate",
	"Comment": "method to get all sedan cars belonging to a group of persons sorted by year of manufacture using for loops",
	"Method": "List<Car> getSedanCarsOwnedSortedByDate(List<Person> persons){\r\n    return o1.getYear() - o2.getYear();\r\n}"
}, {
	"Path": "org.apache.xpath.axes.PredicatedNodeTest.callPredicateVisitors",
	"Comment": "this will traverse the heararchy, calling the visitor for \teach member.if the called visitor method returns \tfalse, the subtree should not be called.",
	"Method": "void callPredicateVisitors(XPathVisitor visitor){\r\n    if (null != m_predicates) {\r\n        int n = m_predicates.length;\r\n        for (int i = 0; i < n; i++) {\r\n            ExpressionOwner predOwner = new PredOwner(i);\r\n            if (visitor.visitPredicate(predOwner, m_predicates[i])) {\r\n                m_predicates[i].callVisitors(predOwner, visitor);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.KeyTable.getNodeSetDTMByKey",
	"Comment": "given a valid element key, return the corresponding node list.",
	"Method": "XNodeSet getNodeSetDTMByKey(QName name,XMLString ref){\r\n    XNodeSet refNodes = (XNodeSet) getRefsTable().get(ref);\r\n    try {\r\n        if (refNodes != null) {\r\n            refNodes = (XNodeSet) refNodes.cloneWithReset();\r\n        }\r\n    } catch (CloneNotSupportedException e) {\r\n        refNodes = null;\r\n    }\r\n    if (refNodes == null) {\r\n        KeyIterator ki = (KeyIterator) (m_keyNodes).getContainedIter();\r\n        XPathContext xctxt = ki.getXPathContext();\r\n        refNodes = new XNodeSet(xctxt.getDTMManager()) {\r\n            public void setRoot(int nodeHandle, Object environment) {\r\n            }\r\n        };\r\n        refNodes.reset();\r\n    }\r\n    return refNodes;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.KeyTable.getNodeSetDTMByKey",
	"Comment": "given a valid element key, return the corresponding node list.",
	"Method": "XNodeSet getNodeSetDTMByKey(QName name,XMLString ref){\r\n}"
}, {
	"Path": "org.apache.xpath.Expression.assertion",
	"Comment": "tell the user of an assertion error, and probably throw anexception.",
	"Method": "void assertion(boolean b,java.lang.String msg){\r\n    if (!b) {\r\n        java.lang.String fMsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION, new Object[] { msg });\r\n        throw new RuntimeException(fMsg);\r\n    }\r\n}"
}, {
	"Path": "hudson.cli.FullDuplexHttpStream.tryToResolveRedirects",
	"Comment": "as this transport mode is using post, it is necessary to resolve possible redirections using get first.",
	"Method": "URL tryToResolveRedirects(URL base,String authorization){\r\n    try {\r\n        HttpURLConnection con = (HttpURLConnection) base.openConnection();\r\n        if (authorization != null) {\r\n            con.addRequestProperty(\"Authorization\", authorization);\r\n        }\r\n        con.getInputStream().close();\r\n        base = con.getURL();\r\n    } catch (Exception ex) {\r\n        LOGGER.log(Level.FINE, \"Failed to resolve potential redirects\", ex);\r\n    }\r\n    return base;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.Stylesheet.isAggregatedType",
	"Comment": "tell if this can be cast to a stylesheetcomposed, meaning, youcan ask questions from getxxxcomposed functions.",
	"Method": "boolean isAggregatedType(){\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.FuncKey.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    TransformerImpl transformer = (TransformerImpl) xctxt.getOwnerObject();\r\n    XNodeSet nodes = null;\r\n    int context = xctxt.getCurrentNode();\r\n    DTM dtm = xctxt.getDTM(context);\r\n    int docContext = dtm.getDocumentRoot(context);\r\n    if (DTM.NULL == docContext) {\r\n    }\r\n    String xkeyname = getArg0().execute(xctxt).str();\r\n    QName keyname = new QName(xkeyname, xctxt.getNamespaceContext());\r\n    XObject arg = getArg1().execute(xctxt);\r\n    boolean argIsNodeSetDTM = (XObject.CLASS_NODESET == arg.getType());\r\n    KeyManager kmgr = transformer.getKeyManager();\r\n    if (argIsNodeSetDTM) {\r\n        XNodeSet ns = (XNodeSet) arg;\r\n        ns.setShouldCacheNodes(true);\r\n        int len = ns.getLength();\r\n        if (len <= 1)\r\n            argIsNodeSetDTM = false;\r\n    }\r\n    if (argIsNodeSetDTM) {\r\n        Hashtable usedrefs = null;\r\n        DTMIterator ni = arg.iter();\r\n        int pos;\r\n        UnionPathIterator upi = new UnionPathIterator();\r\n        upi.exprSetParent(this);\r\n        while (DTM.NULL != (pos = ni.nextNode())) {\r\n            dtm = xctxt.getDTM(pos);\r\n            XMLString ref = dtm.getStringValue(pos);\r\n            if (null == ref)\r\n                continue;\r\n            if (null == usedrefs)\r\n                usedrefs = new Hashtable();\r\n            if (usedrefs.get(ref) != null) {\r\n                continue;\r\n            } else {\r\n                usedrefs.put(ref, ISTRUE);\r\n            }\r\n            XNodeSet nl = kmgr.getNodeSetDTMByKey(xctxt, docContext, keyname, ref, xctxt.getNamespaceContext());\r\n            nl.setRoot(xctxt.getCurrentNode(), xctxt);\r\n            upi.addIterator(nl);\r\n        }\r\n        int current = xctxt.getCurrentNode();\r\n        upi.setRoot(current, xctxt);\r\n        nodes = new XNodeSet(upi);\r\n    } else {\r\n        XMLString ref = arg.xstr();\r\n        nodes = kmgr.getNodeSetDTMByKey(xctxt, docContext, keyname, ref, xctxt.getNamespaceContext());\r\n        nodes.setRoot(xctxt.getCurrentNode(), xctxt);\r\n    }\r\n    return nodes;\r\n}"
}, {
	"Path": "hudson.model.ManagementLink.getRequiresPOST",
	"Comment": "define if the rendered link will use the default get method or post.",
	"Method": "boolean getRequiresPOST(){\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.XPathParser.lookahead",
	"Comment": "look ahead of the current token in order tomake a branching decision.",
	"Method": "boolean lookahead(char c,int n,boolean lookahead,String s,int n){\r\n    boolean isToken;\r\n    if ((m_queueMark + n) <= m_ops.getTokenQueueSize()) {\r\n        String lookahead = (String) m_ops.m_tokenQueue.elementAt(m_queueMark + (n - 1));\r\n        isToken = (lookahead != null) ? lookahead.equals(s) : (s == null);\r\n    } else {\r\n        isToken = (null == s);\r\n    }\r\n    return isToken;\r\n}"
}, {
	"Path": "hudson.node_monitors.AbstractNodeMonitorDescriptor.getTimestamp",
	"Comment": "the timestamp that indicates when the last round of the monitoring has completed.",
	"Method": "long getTimestamp(){\r\n    return record == null ? 0L : record.timestamp;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.execute",
	"Comment": "execute this iterator, meaning create a clone that canstore state, and initialize it for fast execution fromthe current runtime state.when this is called, no actualquery from the current context node is performed.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    XNodeSet iter = new XNodeSet((LocPathIterator) m_clones.getInstance());\r\n    iter.setRoot(xctxt.getCurrentNode(), xctxt);\r\n    return iter;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMNodeProxy.getUserData",
	"Comment": "retrieves the object associated to a key on a this node. the objectmust first have been set to this node by callingsetuserdata with the same key.",
	"Method": "Object getUserData(String key){\r\n    return getOwnerDocument().getUserData(key);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.dom2dtm.DOM2DTM.getNodeValue",
	"Comment": "given a node handle, return its node value. this is mostlyas defined by the dom, but may ignore some conveniences.",
	"Method": "String getNodeValue(int nodeHandle){\r\n    int type = _exptype(makeNodeIdentity(nodeHandle));\r\n    type = (NULL != type) ? getNodeType(nodeHandle) : NULL;\r\n    if (TEXT_NODE != type && CDATA_SECTION_NODE != type)\r\n        return getNode(nodeHandle).getNodeValue();\r\n    Node node = getNode(nodeHandle);\r\n    Node n = logicalNextDOMTextNode(node);\r\n    if (n == null)\r\n        return node.getNodeValue();\r\n    FastStringBuffer buf = StringBufferPool.get();\r\n    buf.append(node.getNodeValue());\r\n    while (n != null) {\r\n        buf.append(n.getNodeValue());\r\n        n = logicalNextDOMTextNode(n);\r\n    }\r\n    String s = (buf.length() > 0) ? buf.toString() : \"\";\r\n    StringBufferPool.free(buf);\r\n    return s;\r\n}"
}, {
	"Path": "org.java_websocket.server.WebSocketServer.onConnect",
	"Comment": "returns whether a new connection shall be accepted or not.\ttherefore method is well suited to implement some kind of connection limitation.",
	"Method": "boolean onConnect(SelectionKey key){\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.WhitespaceInfoPaths.setElements",
	"Comment": "set from the elements attribute.this is a list of whitespace delimited element qualified names that specifypreservation of whitespace.",
	"Method": "void setElements(Vector elems){\r\n    m_elements = elems;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplate.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n    StylesheetRoot.ComposeState cstate = sroot.getComposeState();\r\n    java.util.Vector vnames = cstate.getVariableNames();\r\n    if (null != m_matchPattern)\r\n        m_matchPattern.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());\r\n    cstate.resetStackFrameSize();\r\n    m_inArgsSize = 0;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.TemplateList.getWalker",
	"Comment": "get a templatewalker for use by a compiler.see the documentation forthe treewalker inner class for further details.",
	"Method": "TemplateWalker getWalker(){\r\n    return new TemplateWalker();\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.createDTMIterator",
	"Comment": "create a new dtmiterator based only on a whattoshow anda dtmfilter.the traversal semantics are defined as the descendantaccess.",
	"Method": "DTMIterator createDTMIterator(Object xpathCompiler,int pos,DTMIterator createDTMIterator,String xpathString,PrefixResolver presolver,DTMIterator createDTMIterator,int whatToShow,DTMFilter filter,boolean entityReferenceExpansion,DTMIterator createDTMIterator,int node){\r\n    DTMIterator iter = new org.apache.xpath.axes.OneStepIteratorForward(Axis.SELF);\r\n    iter.setRoot(node, this);\r\n    return iter;\r\n}"
}, {
	"Path": "hudson.scm.SCM.poll",
	"Comment": "convenience method for the caller to handle the backward compatibility between pre 1.345 scms.",
	"Method": "PollingResult poll(AbstractProject<?, ?> project,Launcher launcher,FilePath workspace,TaskListener listener,SCMRevisionState baseline){\r\n    if (is1_346OrLater()) {\r\n        SCMRevisionState baseline2;\r\n        if (baseline != SCMRevisionState.NONE) {\r\n            baseline2 = baseline;\r\n        } else {\r\n            baseline2 = calcRevisionsFromBuild(project.getLastBuild(), launcher, listener);\r\n        }\r\n        return compareRemoteRevisionWith(project, launcher, workspace, listener, baseline2);\r\n    } else {\r\n        return pollChanges(project, launcher, workspace, listener) ? PollingResult.SIGNIFICANT : PollingResult.NO_CHANGES;\r\n    }\r\n}"
}, {
	"Path": "hudson.model.User.getFullName",
	"Comment": "gets the human readable name of this user.this is configurable by the user.",
	"Method": "String getFullName(){\r\n    return fullName;\r\n}"
}, {
	"Path": "hudson.model.UsageStatisticsTest.warmUpNodeMonitorCache",
	"Comment": "node monitoring uses a cache for retrieved values. querying it the first time will return null, while triggeringa background update of that cache.this method triggers that update and waits until the cache is filled during roughly 1 second max.",
	"Method": "void warmUpNodeMonitorCache(){\r\n    Jenkins j = Jenkins.getActiveInstance();\r\n    ArchitectureMonitor.DescriptorImpl descriptor = j.getDescriptorByType(ArchitectureMonitor.DescriptorImpl.class);\r\n    String value = null;\r\n    int count = 1;\r\n    while (value == null && count++ <= 5) {\r\n        final Computer master = j.getComputers()[0];\r\n        value = descriptor.get(master);\r\n        Thread.sleep(200);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.getNamespaceForPrefix",
	"Comment": "fullfill the prefixresolver interface.calling this for this class will throw an error.",
	"Method": "String getNamespaceForPrefix(String prefix,org.w3c.dom.Node context,String getNamespaceForPrefix,String prefix){\r\n    List nsDecls = m_declaredPrefixes;\r\n    if (null != nsDecls) {\r\n        int n = nsDecls.size();\r\n        if (prefix.equals(Constants.ATTRVAL_DEFAULT_PREFIX)) {\r\n            prefix = \"\";\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            XMLNSDecl decl = (XMLNSDecl) nsDecls.get(i);\r\n            if (prefix.equals(decl.getPrefix()))\r\n                return decl.getURI();\r\n        }\r\n    }\r\n    if (null != m_parentNode)\r\n        return m_parentNode.getNamespaceForPrefix(prefix);\r\n    if (\"xml\".equals(prefix))\r\n        return \"http://www.w3.org/XML/1998/namespace\";\r\n    return null;\r\n}"
}, {
	"Path": "hudson.node_monitors.AbstractNodeMonitorDescriptor.markOffline",
	"Comment": "utility method to mark the computer offline for derived classes.",
	"Method": "boolean markOffline(Computer c,OfflineCause oc,boolean markOffline,Computer c){\r\n    return markOffline(c, null);\r\n}"
}, {
	"Path": "com.iluwatar.reader.writer.lock.ReaderTest.testRead",
	"Comment": "verify that multiple readers can get the read lock concurrently",
	"Method": "void testRead(){\r\n    ExecutorService executeService = Executors.newFixedThreadPool(2);\r\n    ReaderWriterLock lock = new ReaderWriterLock();\r\n    Reader reader1 = spy(new Reader(\"Reader 1\", lock.readLock()));\r\n    Reader reader2 = spy(new Reader(\"Reader 2\", lock.readLock()));\r\n    executeService.submit(reader1);\r\n    Thread.sleep(150);\r\n    executeService.submit(reader2);\r\n    executeService.shutdown();\r\n    try {\r\n        executeService.awaitTermination(10, TimeUnit.SECONDS);\r\n    } catch (InterruptedException e) {\r\n        LOGGER.error(\"Error waiting for ExecutorService shutdown\", e);\r\n    }\r\n    assertTrue(appender.logContains(\"Reader 1 begin\"));\r\n    assertTrue(appender.logContains(\"Reader 2 begin\"));\r\n    assertTrue(appender.logContains(\"Reader 1 finish\"));\r\n    assertTrue(appender.logContains(\"Reader 2 finish\"));\r\n}"
}, {
	"Path": "hudson.cli.FullDuplexHttpStream.getInputStream",
	"Comment": "a way to get data from the server.there will be an initial zero byte used as a handshake which you should expect and ignore.",
	"Method": "InputStream getInputStream(){\r\n    return input;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FunctionOneArg.checkNumberArgs",
	"Comment": "check that the number of arguments passed to this function is correct.",
	"Method": "void checkNumberArgs(int argNum){\r\n    if (argNum != 1)\r\n        reportWrongNumberArgs();\r\n}"
}, {
	"Path": "hudson.org.apache.tools.tar.TarOutputStream.finish",
	"Comment": "ends the tar archive without closing the underlying outputstream.the result is that the two eof records of nulls are written.",
	"Method": "void finish(){\r\n    this.writeEOFRecord();\r\n    this.writeEOFRecord();\r\n}"
}, {
	"Path": "hudson.PluginWrapper.isOlderThan",
	"Comment": "returns true if the version of this plugin is older than the given version.",
	"Method": "boolean isOlderThan(VersionNumber v){\r\n    try {\r\n        return getVersionNumber().compareTo(v) < 0;\r\n    } catch (IllegalArgumentException e) {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.getDocumentSystemIdentifier",
	"Comment": "return the system identifier of the document entity. ifit is not known, the value of this property is unknown.",
	"Method": "String getDocumentSystemIdentifier(int nodeHandle){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.XPathParser.lookbehindHasToken",
	"Comment": "look behind the current token in order tosee if there is a useable token.",
	"Method": "boolean lookbehindHasToken(int n){\r\n    boolean hasToken;\r\n    if ((m_queueMark - n) > 0) {\r\n        String lookbehind = (String) m_ops.m_tokenQueue.elementAt(m_queueMark - (n - 1));\r\n        char c0 = (lookbehind == null) ? '|' : lookbehind.charAt(0);\r\n        hasToken = (c0 == '|') ? false : true;\r\n    } else {\r\n        hasToken = false;\r\n    }\r\n    return hasToken;\r\n}"
}, {
	"Path": "hudson.model.DescriptorVisibilityFilter.filterType",
	"Comment": "decides if the given descriptor should be visible to the user.",
	"Method": "boolean filterType(Class<?> contextClass,Descriptor descriptor){\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.NodeSequence.allowDetachToRelease",
	"Comment": "calling this with a value of false will cause the nodeset to be cached.",
	"Method": "void allowDetachToRelease(boolean allowRelease){\r\n    if ((false == allowRelease) && !hasCache()) {\r\n        setShouldCacheNodes(true);\r\n    }\r\n    if (null != m_iter)\r\n        m_iter.allowDetachToRelease(allowRelease);\r\n    super.allowDetachToRelease(allowRelease);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.getColumnNumber",
	"Comment": "return the column number where the current document event ends.note that this is the column number of the firstcharacter after the text associated with the documentevent.the first column in a line is position 1.",
	"Method": "int getColumnNumber(){\r\n    return m_columnNumber;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMNodeProxy.compareDocumentPosition",
	"Comment": "compares a node with this node with regard to their position in thedocument.",
	"Method": "short compareDocumentPosition(Node other){\r\n    return 0;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.getDocumentRoot",
	"Comment": "given a node handle, find the owning document node.unlike the dom,this considers the owningdocument of a document to be itself.",
	"Method": "int getDocumentRoot(int nodeHandle){\r\n    return getManager().getDTM(nodeHandle).getDocument();\r\n}"
}, {
	"Path": "hudson.console.ConsoleAnnotationDescriptor.hasScript",
	"Comment": "returns true if this descriptor has a javascript to be inserted on applicable console page.",
	"Method": "boolean hasScript(){\r\n    return hasResource(\"/script.js\") != null;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.setItem",
	"Comment": "sets the node at the specified index of this vector to be thespecified node. the previous component at that position is discarded.the index must be a value greater than or equal to 0 and lessthan the current size of the vector.the iterator must be in cached mode.meant to be used for sorted iterators.",
	"Method": "void setItem(int node,int index){\r\n    assertion(false, \"setItem not supported by this iterator!\");\r\n}"
}, {
	"Path": "hudson.tasks.CommandInterpreter.createScriptFile",
	"Comment": "creates a script file in a temporary name in the specified directory.",
	"Method": "FilePath createScriptFile(FilePath dir){\r\n    return dir.createTextTempFile(\"jenkins\", getFileExtension(), getContents(), false);\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.StepPattern.executePredicates",
	"Comment": "execute the predicates on this step to determine if the current node should be filtered or accepted.",
	"Method": "boolean executePredicates(XPathContext xctxt,DTM dtm,int currentNode){\r\n    boolean result = true;\r\n    boolean positionAlreadySeen = false;\r\n    int n = getPredicateCount();\r\n    try {\r\n        xctxt.pushSubContextList(this);\r\n        for (int i = 0; i < n; i++) {\r\n            xctxt.pushPredicatePos(i);\r\n            try {\r\n                XObject pred = m_predicates[i].execute(xctxt);\r\n                try {\r\n                    if (XObject.CLASS_NUMBER == pred.getType()) {\r\n                        int pos = (int) pred.num();\r\n                        if (positionAlreadySeen) {\r\n                            result = (pos == 1);\r\n                            break;\r\n                        } else {\r\n                            positionAlreadySeen = true;\r\n                            if (!checkProximityPosition(xctxt, i, dtm, currentNode, pos)) {\r\n                                result = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    } else if (!pred.boolWithSideEffects()) {\r\n                        result = false;\r\n                        break;\r\n                    }\r\n                } finally {\r\n                    pred.detach();\r\n                }\r\n            } finally {\r\n                xctxt.popPredicatePos();\r\n            }\r\n        }\r\n    } finally {\r\n        xctxt.popSubContextList();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.setParent",
	"Comment": "set the parent for this class loader. this is the class loader to whichthis class loader will delegate to load classes",
	"Method": "void setParent(ClassLoader parent){\r\n    this.parent = parent == null ? AntClassLoader.class.getClassLoader() : parent;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerImpl.applyTemplateToNode",
	"Comment": "given an element and mode, find the correspondingtemplate and process the contents.",
	"Method": "boolean applyTemplateToNode(ElemTemplateElement xslInstruction,ElemTemplate template,int child){\r\n    DTM dtm = m_xcontext.getDTM(child);\r\n    short nodeType = dtm.getNodeType(child);\r\n    boolean isDefaultTextRule = false;\r\n    boolean isApplyImports = false;\r\n    isApplyImports = ((xslInstruction == null) ? false : xslInstruction.getXSLToken() == Constants.ELEMNAME_APPLY_IMPORTS);\r\n    if (null == template || isApplyImports) {\r\n        int maxImportLevel, endImportLevel = 0;\r\n        if (isApplyImports) {\r\n            maxImportLevel = template.getStylesheetComposed().getImportCountComposed() - 1;\r\n            endImportLevel = template.getStylesheetComposed().getEndImportCountComposed();\r\n        } else {\r\n            maxImportLevel = -1;\r\n        }\r\n        if (isApplyImports && (maxImportLevel == -1)) {\r\n            template = null;\r\n        } else {\r\n            XPathContext xctxt = m_xcontext;\r\n            try {\r\n                xctxt.pushNamespaceContext(xslInstruction);\r\n                QName mode = this.getMode();\r\n                if (isApplyImports)\r\n                    template = m_stylesheetRoot.getTemplateComposed(xctxt, child, mode, maxImportLevel, endImportLevel, m_quietConflictWarnings, dtm);\r\n                else\r\n                    template = m_stylesheetRoot.getTemplateComposed(xctxt, child, mode, m_quietConflictWarnings, dtm);\r\n            } finally {\r\n                xctxt.popNamespaceContext();\r\n            }\r\n        }\r\n        if (null == template) {\r\n            switch(nodeType) {\r\n                case DTM.DOCUMENT_FRAGMENT_NODE:\r\n                case DTM.ELEMENT_NODE:\r\n                    template = m_stylesheetRoot.getDefaultRule();\r\n                    break;\r\n                case DTM.CDATA_SECTION_NODE:\r\n                case DTM.TEXT_NODE:\r\n                case DTM.ATTRIBUTE_NODE:\r\n                    template = m_stylesheetRoot.getDefaultTextRule();\r\n                    isDefaultTextRule = true;\r\n                    break;\r\n                case DTM.DOCUMENT_NODE:\r\n                    template = m_stylesheetRoot.getDefaultRootRule();\r\n                    break;\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        pushElemTemplateElement(template);\r\n        m_xcontext.pushCurrentNode(child);\r\n        pushPairCurrentMatched(template, child);\r\n        if (!isApplyImports) {\r\n            DTMIterator cnl = new org.apache.xpath.NodeSetDTM(child, m_xcontext.getDTMManager());\r\n            m_xcontext.pushContextNodeList(cnl);\r\n        }\r\n        if (isDefaultTextRule) {\r\n            switch(nodeType) {\r\n                case DTM.CDATA_SECTION_NODE:\r\n                case DTM.TEXT_NODE:\r\n                    ClonerToResultTree.cloneToResultTree(child, nodeType, dtm, getResultTreeHandler(), false);\r\n                    break;\r\n                case DTM.ATTRIBUTE_NODE:\r\n                    dtm.dispatchCharactersEvents(child, getResultTreeHandler(), false);\r\n                    break;\r\n            }\r\n        } else {\r\n            m_xcontext.setSAXLocator(template);\r\n            m_xcontext.getVarStack().link(template.m_frameSize);\r\n            executeChildTemplates(template, true);\r\n        }\r\n    } catch (org.xml.sax.SAXException se) {\r\n        throw new TransformerException(se);\r\n    } finally {\r\n        if (!isDefaultTextRule)\r\n            m_xcontext.getVarStack().unlink();\r\n        m_xcontext.popCurrentNode();\r\n        if (!isApplyImports) {\r\n            m_xcontext.popContextNodeList();\r\n        }\r\n        popCurrentMatched();\r\n        popElemTemplateElement();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.winterbe.java8.samples.misc.CheckedFunctions.function",
	"Comment": "return a function which rethrows possible checked exceptions as runtime exception.",
	"Method": "Function<F, T> function(CheckedFunction<F, T> function){\r\n    return input -> {\r\n        try {\r\n            return function.apply(input);\r\n        } catch (Exception e) {\r\n            if (e instanceof RuntimeException) {\r\n                throw (RuntimeException) e;\r\n            }\r\n            throw new RuntimeException(e);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.java_websocket.AbstractWebSocket.executeConnectionLostDetection",
	"Comment": "send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping",
	"Method": "void executeConnectionLostDetection(WebSocket webSocket,long current){\r\n    if (!(webSocket instanceof WebSocketImpl)) {\r\n        return;\r\n    }\r\n    WebSocketImpl webSocketImpl = (WebSocketImpl) webSocket;\r\n    if (webSocketImpl.getLastPong() < current) {\r\n        log.trace(\"Closing connection due to no pong received: {}\", webSocketImpl);\r\n        webSocketImpl.closeConnection(CloseFrame.ABNORMAL_CLOSE, \"The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection\");\r\n    } else {\r\n        if (webSocketImpl.isOpen()) {\r\n            webSocketImpl.sendPing();\r\n        } else {\r\n            log.trace(\"Trying to ping a non open connection: {}\", webSocketImpl);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.UnImplNode.getUserData",
	"Comment": "retrieves the object associated to a key on a this node. the objectmust first have been set to this node by callingsetuserdata with the same key.",
	"Method": "Object getUserData(String key){\r\n    return getOwnerDocument().getUserData(key);\r\n}"
}, {
	"Path": "com.iluwatar.semaphore.FruitShop.returnBowl",
	"Comment": "method called by a customer instance to return a fruitbowl to the shop. this method releases the semaphore, making the fruitbowl available to another customer.",
	"Method": "void returnBowl(FruitBowl bowl){\r\n    if (bowl == bowls[0]) {\r\n        available[0] = true;\r\n    } else if (bowl == bowls[1]) {\r\n        available[1] = true;\r\n    } else if (bowl == bowls[2]) {\r\n        available[2] = true;\r\n    }\r\n}"
}, {
	"Path": "redis.clients.jedis.util.MurmurHash.hash",
	"Comment": "hashes the bytes in a buffer from the current position to the limit.",
	"Method": "int hash(byte[] data,int seed,int hash,byte[] data,int offset,int length,int seed,int hash,ByteBuffer buf,int seed,long hash,byte[] key,long hash,String key){\r\n    return hash(SafeEncoder.encode(key));\r\n}"
}, {
	"Path": "com.sun.jna.contrib.demo.FilteredTextField.removeCharacter",
	"Comment": "removes the character from the list used for entry validation.",
	"Method": "void removeCharacter(Character character){\r\n    if (allowable.contains(character)) {\r\n        allowable.remove(character);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.axes.WalkerFactory.newDTMIterator",
	"Comment": "create a new locpathiterator iterator.the exact type of iteratorreturned is based on an analysis of the xpath operations.",
	"Method": "DTMIterator newDTMIterator(Compiler compiler,int opPos,boolean isTopLevel){\r\n    int firstStepPos = OpMap.getFirstChildPos(opPos);\r\n    int analysis = analyze(compiler, firstStepPos, 0);\r\n    boolean isOneStep = isOneStep(analysis);\r\n    DTMIterator iter;\r\n    if (isOneStep && walksSelfOnly(analysis) && isWild(analysis) && !hasPredicate(analysis)) {\r\n        if (DEBUG_ITERATOR_CREATION)\r\n            diagnoseIterator(\"SelfIteratorNoPredicate\", analysis, compiler);\r\n        iter = new SelfIteratorNoPredicate(compiler, opPos, analysis);\r\n    } else if (walksChildrenOnly(analysis) && isOneStep) {\r\n        if (isWild(analysis) && !hasPredicate(analysis)) {\r\n            if (DEBUG_ITERATOR_CREATION)\r\n                diagnoseIterator(\"ChildIterator\", analysis, compiler);\r\n            iter = new ChildIterator(compiler, opPos, analysis);\r\n        } else {\r\n            if (DEBUG_ITERATOR_CREATION)\r\n                diagnoseIterator(\"ChildTestIterator\", analysis, compiler);\r\n            iter = new ChildTestIterator(compiler, opPos, analysis);\r\n        }\r\n    } else if (isOneStep && walksAttributes(analysis)) {\r\n        if (DEBUG_ITERATOR_CREATION)\r\n            diagnoseIterator(\"AttributeIterator\", analysis, compiler);\r\n        iter = new AttributeIterator(compiler, opPos, analysis);\r\n    } else if (isOneStep && !walksFilteredList(analysis)) {\r\n        if (!walksNamespaces(analysis) && (walksInDocOrder(analysis) || isSet(analysis, BIT_PARENT))) {\r\n            if (false || DEBUG_ITERATOR_CREATION)\r\n                diagnoseIterator(\"OneStepIteratorForward\", analysis, compiler);\r\n            iter = new OneStepIteratorForward(compiler, opPos, analysis);\r\n        } else {\r\n            if (false || DEBUG_ITERATOR_CREATION)\r\n                diagnoseIterator(\"OneStepIterator\", analysis, compiler);\r\n            iter = new OneStepIterator(compiler, opPos, analysis);\r\n        }\r\n    } else if (isOptimizableForDescendantIterator(compiler, firstStepPos, 0)) {\r\n        if (DEBUG_ITERATOR_CREATION)\r\n            diagnoseIterator(\"DescendantIterator\", analysis, compiler);\r\n        iter = new DescendantIterator(compiler, opPos, analysis);\r\n    } else {\r\n        if (isNaturalDocOrder(compiler, firstStepPos, 0, analysis)) {\r\n            if (false || DEBUG_ITERATOR_CREATION) {\r\n                diagnoseIterator(\"WalkingIterator\", analysis, compiler);\r\n            }\r\n            iter = new WalkingIterator(compiler, opPos, analysis, true);\r\n        } else {\r\n            if (DEBUG_ITERATOR_CREATION)\r\n                diagnoseIterator(\"WalkingIteratorSorted\", analysis, compiler);\r\n            iter = new WalkingIteratorSorted(compiler, opPos, analysis, true);\r\n        }\r\n    }\r\n    if (iter instanceof LocPathIterator)\r\n        ((LocPathIterator) iter).setIsTopLevel(isTopLevel);\r\n    return iter;\r\n}"
}, {
	"Path": "com.iluwatar.iterator.bst.TreeNode.insert",
	"Comment": "inserts new treenode based on a given value into the subtree represented by self",
	"Method": "void insert(T valToInsert){\r\n    TreeNode<T> parent = getParentNodeOfValueToBeInserted(valToInsert);\r\n    parent.insertNewChild(valToInsert);\r\n}"
}, {
	"Path": "hudson.FilePath.toURI",
	"Comment": "converts this file to the uri, relative to the machineon which this file is available.",
	"Method": "URI toURI(){\r\n    return act(new ToURI());\r\n}"
}, {
	"Path": "org.apache.xpath.axes.WalkingIteratorSorted.fixupVariables",
	"Comment": "this function is used to perform some extra analysis of the iterator.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    super.fixupVariables(vars, globalsSize);\r\n    int analysis = getAnalysisBits();\r\n    if (WalkerFactory.isNaturalDocOrder(analysis)) {\r\n        m_inNaturalOrderStatic = true;\r\n    } else {\r\n        m_inNaturalOrderStatic = false;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.FunctionPattern.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    super.fixupVariables(vars, globalsSize);\r\n    m_functionExpr.fixupVariables(vars, globalsSize);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.DOM3TreeWalker.initProperties",
	"Comment": "initializes ffeatures based on the domconfiguration parameters set.",
	"Method": "void initProperties(Properties properties){\r\n    for (Enumeration keys = properties.keys(); keys.hasMoreElements(); ) {\r\n        final String key = (String) keys.nextElement();\r\n        final Object iobj = s_propKeys.get(key);\r\n        if (iobj != null) {\r\n            if (iobj instanceof Integer) {\r\n                final int BITFLAG = ((Integer) iobj).intValue();\r\n                if ((properties.getProperty(key).endsWith(\"yes\"))) {\r\n                    fFeatures = fFeatures | BITFLAG;\r\n                } else {\r\n                    fFeatures = fFeatures & ~BITFLAG;\r\n                }\r\n            } else {\r\n                if ((DOMConstants.S_DOM3_PROPERTIES_NS + DOMConstants.DOM_FORMAT_PRETTY_PRINT).equals(key)) {\r\n                    if ((properties.getProperty(key).endsWith(\"yes\"))) {\r\n                        fSerializer.setIndent(true);\r\n                        fSerializer.setIndentAmount(3);\r\n                    } else {\r\n                        fSerializer.setIndent(false);\r\n                    }\r\n                } else if ((DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL).equals(key)) {\r\n                    if ((properties.getProperty(key).endsWith(\"yes\"))) {\r\n                        fSerializer.setOmitXMLDeclaration(true);\r\n                    } else {\r\n                        fSerializer.setOmitXMLDeclaration(false);\r\n                    }\r\n                } else if ((DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.S_XML_VERSION).equals(key)) {\r\n                    String version = properties.getProperty(key);\r\n                    if (\"1.1\".equals(version)) {\r\n                        fIsXMLVersion11 = true;\r\n                        fSerializer.setVersion(version);\r\n                    } else {\r\n                        fSerializer.setVersion(\"1.0\");\r\n                    }\r\n                } else if ((DOMConstants.S_XSL_OUTPUT_ENCODING).equals(key)) {\r\n                    String encoding = properties.getProperty(key);\r\n                    if (encoding != null) {\r\n                        fSerializer.setEncoding(encoding);\r\n                    }\r\n                } else if ((DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.DOM_ENTITIES).equals(key)) {\r\n                    if ((properties.getProperty(key).endsWith(\"yes\"))) {\r\n                        fSerializer.setDTDEntityExpansion(false);\r\n                    } else {\r\n                        fSerializer.setDTDEntityExpansion(true);\r\n                    }\r\n                } else {\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (fNewLine != null) {\r\n        fSerializer.setOutputProperty(OutputPropertiesFactory.S_KEY_LINE_SEPARATOR, fNewLine);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.res.XMLMessages.createXMLMessage",
	"Comment": "creates a message from the specified key and replacementarguments, localized to the given locale.",
	"Method": "String createXMLMessage(String msgKey,Object args){\r\n    return createMsg(XMLBundle, msgKey, args);\r\n}"
}, {
	"Path": "hudson.cli.CLICommand.getCurrent",
	"Comment": "if the calling thread is in the middle of executing a cli command, return it. otherwise null.",
	"Method": "CLICommand getCurrent(){\r\n    return CURRENT_COMMAND.get();\r\n}"
}, {
	"Path": "jenkins.security.Security857Test.checkResponse",
	"Comment": "check the response of the parse of the jelly. depending on the escape parameter, the response page should haveescaped characters or unescaped characters.",
	"Method": "void checkResponse(String response,Boolean escape){\r\n    if (escape == null) {\r\n        Assert.assertFalse(\"There is no escape-by-default tag in the jelly (true is assumed) but there are unescaped characters in the response.\", response.contains(EVIDENCE));\r\n    } else if (escape) {\r\n        Assert.assertFalse(\"Set explicitly the <?jelly escape-by-default='true' in the jelly but there are unescaped characters in the response. Jenkins is not escaping the characters and it should to.\", response.contains(EVIDENCE));\r\n    } else {\r\n        Assert.assertTrue(\"Set explicitly the <?jelly escape-by-default='false' in the jelly but there are escaped characters in the response. Jenkins is escaping the characters and it shouldn't to.\", response.contains(EVIDENCE));\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.res.XSLMessages.createMessage",
	"Comment": "creates a message from the specified key and replacementarguments, localized to the given locale.",
	"Method": "String createMessage(String msgKey,Object args){\r\n    return createMsg(XSLTBundle, msgKey, args);\r\n}"
}, {
	"Path": "jenkins.security.HMACConfidentialKey.mac",
	"Comment": "computes the message authentication code and return it as a string.while redundant, often convenient.",
	"Method": "byte[] mac(byte[] message,String mac,String message){\r\n    try {\r\n        return Util.toHexString(mac(message.getBytes(\"UTF-8\")));\r\n    } catch (UnsupportedEncodingException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.simple.SimpleFluentIterable.first",
	"Comment": "can be used to collect objects from the iterable. is a terminating operation.",
	"Method": "Optional<E> first(FluentIterable<E> first,int count){\r\n    Iterator<E> iterator = iterator();\r\n    int currentCount = 0;\r\n    while (iterator.hasNext()) {\r\n        iterator.next();\r\n        if (currentCount >= count) {\r\n            iterator.remove();\r\n        }\r\n        currentCount++;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "hudson.util.SecretTest.testCompatibilityFromString",
	"Comment": "makes sure the serialization form is backward compatible with string.",
	"Method": "void testCompatibilityFromString(){\r\n    String tagName = Foo.class.getName().replace(\"$\", \"_-\");\r\n    String xml = \"<\" + tagName + \"><password>secret<\/password><\/\" + tagName + \">\";\r\n    Foo foo = new Foo();\r\n    Jenkins.XSTREAM.fromXML(xml, foo);\r\n    assertEquals(\"secret\", Secret.toString(foo.password));\r\n}"
}, {
	"Path": "hudson.cli.DisablePluginCommandTest.returnCodeFirstErrorIsDependants",
	"Comment": "the return code is the first error distinct of 0 found during the process. in this case dependant plugins notdisabled.",
	"Method": "void returnCodeFirstErrorIsDependants(){\r\n    CLICommandInvoker.Result result = disablePluginsCLiCommand(\"dependee\", \"badplugin\");\r\n    assertThat(result, failedWith(RETURN_CODE_NOT_DISABLED_DEPENDANTS));\r\n    assertPluginEnabled(\"dependee\");\r\n}"
}, {
	"Path": "org.apache.xalan.templates.OutputProperties.recompose",
	"Comment": "this function is called to recompose all of the output format extended elements.",
	"Method": "void recompose(StylesheetRoot root){\r\n    root.recomposeOutput(this);\r\n}"
}, {
	"Path": "hudson.util.ByteBuffer.writeTo",
	"Comment": "writes the contents of this buffer to another outputstream.",
	"Method": "void writeTo(OutputStream os){\r\n    os.write(buf, 0, size);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.setStylesheetType",
	"Comment": "set the type of stylesheet that should be builtor is being processed.",
	"Method": "void setStylesheetType(int type){\r\n    m_stylesheetType = type;\r\n}"
}, {
	"Path": "org.java_websocket.server.WebSocketServer.getConnections",
	"Comment": "returnsall currently connected clients.\tthis collection does not allow any modification e.g. removing a client.",
	"Method": "Collection<WebSocket> getConnections(){\r\n    return Collections.unmodifiableCollection(new ArrayList<WebSocket>(connections));\r\n}"
}, {
	"Path": "org.java_websocket.client.WebSocketClient.closeBlocking",
	"Comment": "same as close but blocks until the websocket closed or failed to do so.",
	"Method": "void closeBlocking(){\r\n    close();\r\n    closeLatch.await();\r\n}"
}, {
	"Path": "org.apache.xpath.Expression.execute",
	"Comment": "execute an expression in the xpath runtime context, and return theresult of the expression.",
	"Method": "XObject execute(XPathContext xctxt,int currentNode,XObject execute,XPathContext xctxt,int currentNode,DTM dtm,int expType,XObject execute,XPathContext xctxt,XObject execute,XPathContext xctxt,boolean destructiveOK){\r\n    return execute(xctxt);\r\n}"
}, {
	"Path": "jadx.core.dex.visitors.ExtractFieldInit.processStaticFieldAssign",
	"Comment": "remove final field in place initialization if it assign in class init method",
	"Method": "void processStaticFieldAssign(ClassNode cls,IndexInsnNode insn){\r\n    FieldInfo field = (FieldInfo) insn.getIndex();\r\n    String thisClass = cls.getClassInfo().getFullName();\r\n    if (field.getDeclClass().getFullName().equals(thisClass)) {\r\n        FieldNode fn = cls.searchField(field);\r\n        if (fn != null && fn.getAccessFlags().isFinal()) {\r\n            fn.remove(AType.FIELD_INIT);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "hudson.markup.MarkupFormatter.doPreviewDescription",
	"Comment": "generate html for preview, using markup formatter.can be called from other views.",
	"Method": "HttpResponse doPreviewDescription(String text){\r\n    StringWriter w = new StringWriter();\r\n    translate(text, w);\r\n    return HttpResponses.html(w.toString());\r\n}"
}, {
	"Path": "org.java_websocket.server.WebSocketServer.getSocket",
	"Comment": "getter to return the socket used by this specific connection",
	"Method": "Socket getSocket(WebSocket conn){\r\n    WebSocketImpl impl = (WebSocketImpl) conn;\r\n    return ((SocketChannel) impl.getSelectionKey().channel()).socket();\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.dom2dtm.DOM2DTMdefaultNamespaceDeclarationNode.getUserData",
	"Comment": "retrieves the object associated to a key on a this node. the objectmust first have been set to this node by callingsetuserdata with the same key.",
	"Method": "Object getUserData(String key){\r\n    return getOwnerDocument().getUserData(key);\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerImpl.pushCurrentTemplateRuleIsNull",
	"Comment": "push true if the current template rule is null, falseotherwise.",
	"Method": "void pushCurrentTemplateRuleIsNull(boolean b){\r\n    m_currentTemplateRuleIsNull.push(b);\r\n}"
}, {
	"Path": "org.java_websocket.drafts.Draft_6455.getPayloadFromByteBufferList",
	"Comment": "method to generate a full bytebuffer out of all the fragmented frame payload",
	"Method": "ByteBuffer getPayloadFromByteBufferList(){\r\n    long totalSize = 0;\r\n    ByteBuffer resultingByteBuffer;\r\n    synchronized (byteBufferList) {\r\n        for (ByteBuffer buffer : byteBufferList) {\r\n            totalSize += buffer.limit();\r\n        }\r\n        checkBufferLimit();\r\n        resultingByteBuffer = ByteBuffer.allocate((int) totalSize);\r\n        for (ByteBuffer buffer : byteBufferList) {\r\n            resultingByteBuffer.put(buffer);\r\n        }\r\n    }\r\n    resultingByteBuffer.flip();\r\n    return resultingByteBuffer;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.eleminateRedundentGlobals",
	"Comment": "method to be called after the all global expressions within a stylesheet have been collected.it eliminates redundent expressions by creating a variable in the psuedovarrecipient for each redundent expression, and then rewriting the redundent expression to be a variable reference.",
	"Method": "void eleminateRedundentGlobals(StylesheetRoot stylesheet){\r\n    eleminateRedundent(stylesheet, m_absPaths);\r\n}"
}, {
	"Path": "hudson.model.UsageStatisticsTest.sortPlugins",
	"Comment": "plugins can be retrieved in any order, so sorting them so that the test is stable",
	"Method": "List<JSONObject> sortPlugins(List<JSONObject> list){\r\n    List<JSONObject> sorted = new ArrayList(list);\r\n    Collections.sort(sorted, new Comparator<JSONObject>() {\r\n        public int compare(JSONObject j1, JSONObject j2) {\r\n            return j1.getString(\"name\").compareTo(j2.getString(\"name\"));\r\n        }\r\n    });\r\n    return sorted;\r\n}"
}, {
	"Path": "hudson.model.UsageStatisticsTest.sortPlugins",
	"Comment": "plugins can be retrieved in any order, so sorting them so that the test is stable",
	"Method": "List<JSONObject> sortPlugins(List<JSONObject> list){\r\n    return j1.getString(\"name\").compareTo(j2.getString(\"name\"));\r\n}"
}, {
	"Path": "hudson.XmlFileTest.xml1_0_withSpecialCharsShouldFail",
	"Comment": "should be illegal.ignoring this test until we switch to a more compliant driver",
	"Method": "void xml1_0_withSpecialCharsShouldFail(){\r\n    URL configUrl = getClass().getResource(\"/hudson/config_1_0_with_special_chars.xml\");\r\n    XStream2 xs = new XStream2();\r\n    xs.alias(\"hudson\", Jenkins.class);\r\n    XmlFile xmlFile = new XmlFile(xs, new File(configUrl.getFile()));\r\n    if (xmlFile.exists()) {\r\n        Node n = (Node) xmlFile.read();\r\n        assertThat(n.getNumExecutors(), is(2));\r\n        assertThat(n.getMode().toString(), is(\"NORMAL\"));\r\n    }\r\n}"
}, {
	"Path": "hudson.security.HudsonPrivateSecurityRealm.getDisplayName",
	"Comment": "this is used primarily when the object is listed in the breadcrumb, in the user management screen.",
	"Method": "String getDisplayName(String getDisplayName,String getDisplayName,String getDisplayName){\r\n    return Messages.HudsonPrivateSecurityRealm_DisplayName();\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.getCurrentProcessor",
	"Comment": "get the current xsltelementprocessor at the top of the stack.",
	"Method": "XSLTElementProcessor getCurrentProcessor(){\r\n    return (XSLTElementProcessor) m_processors.peek();\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XNull.getTypeString",
	"Comment": "given a request type, return the equivalent string.for diagnostic purposes.",
	"Method": "String getTypeString(){\r\n    return \"#CLASS_NULL\";\r\n}"
}, {
	"Path": "hudson.cli.ClientAuthenticationCache.getPropertyKey",
	"Comment": "computes the key that identifies this hudson among other hudsons that the user has a credential for.",
	"Method": "String getPropertyKey(){\r\n    Jenkins j = Jenkins.getActiveInstance();\r\n    String url = j.getRootUrl();\r\n    if (url != null)\r\n        return url;\r\n    return j.getLegacyInstanceId();\r\n}"
}, {
	"Path": "org.apache.xpath.jaxp.XPathFactoryImpl.setXPathFunctionResolver",
	"Comment": "establish a default function resolver.any xpath objects constructed from this factory will use\tthe specified resolver by default.\ta nullpointerexception is thrown if resolver is null.",
	"Method": "void setXPathFunctionResolver(XPathFunctionResolver resolver){\r\n    if (resolver == null) {\r\n        String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_XPATH_FUNCTION_RESOLVER, new Object[] { CLASS_NAME });\r\n        throw new NullPointerException(fmsg);\r\n    }\r\n    xPathFunctionResolver = resolver;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.setElementAt",
	"Comment": "sets the component at the specified index of this vector to be thespecified object. the previous component at that position is discarded.the index must be a value greater than or equal to 0 and lessthan the current size of the vector.",
	"Method": "void setElementAt(int node,int index){\r\n    if (!m_mutable)\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null));\r\n    super.setElementAt(node, index);\r\n}"
}, {
	"Path": "com.iluwatar.reactor.framework.NioReactor.stop",
	"Comment": "stops the reactor and related resources such as dispatcher.",
	"Method": "void stop(){\r\n    reactorMain.shutdownNow();\r\n    selector.wakeup();\r\n    reactorMain.awaitTermination(4, TimeUnit.SECONDS);\r\n    selector.close();\r\n    LOGGER.info(\"Reactor stopped\");\r\n}"
}, {
	"Path": "org.apache.xpath.axes.WalkingIterator.clone",
	"Comment": "get a cloned walkingiterator that holds the sameposition as this iterator.",
	"Method": "Object clone(){\r\n    WalkingIterator clone = (WalkingIterator) super.clone();\r\n    if (null != m_firstWalker) {\r\n        clone.m_firstWalker = m_firstWalker.cloneDeep(clone, null);\r\n    }\r\n    return clone;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.DOM3SerializerImpl.getErrorHandler",
	"Comment": "returns a domerrorhandler set on the dom level 3 serializer.this interface is a public api.",
	"Method": "DOMErrorHandler getErrorHandler(){\r\n    return fErrorHandler;\r\n}"
}, {
	"Path": "hudson.node_monitors.AbstractNodeMonitorDescriptor.get",
	"Comment": "obtains the monitoring result currently available, or null if no data is available.if no data is available, a background task to collect data will be started.",
	"Method": "T get(Computer c){\r\n    if (record == null || !record.data.containsKey(c)) {\r\n        triggerUpdate();\r\n        return null;\r\n    }\r\n    return record.data.get(c);\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.filesystem.AbsoluteUnixPath.resolve",
	"Comment": "resolves this path against another relative unix path in string form.",
	"Method": "AbsoluteUnixPath resolve(RelativeUnixPath relativeUnixPath,AbsoluteUnixPath resolve,Path relativePath,AbsoluteUnixPath resolve,String relativeUnixPath){\r\n    return resolve(RelativeUnixPath.get(relativeUnixPath));\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.getWhatToShow",
	"Comment": "this attribute determines which node types are presented via theiterator. the available set of constants is defined in thenodefilter interface. for nodesets, the mask has beenhardcoded to show all nodes except entityreference nodes, which haveno equivalent in the xpath data model.",
	"Method": "int getWhatToShow(){\r\n    return NodeFilter.SHOW_ALL & ~NodeFilter.SHOW_ENTITY_REFERENCE;\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.COM.COMUtils.comIsInitialized",
	"Comment": "check if com was initialized correctly. the initialization status is not changed!this is a debug function, not for normal usage!",
	"Method": "boolean comIsInitialized(){\r\n    WinNT.HRESULT hr = Ole32.INSTANCE.CoInitializeEx(Pointer.NULL, Ole32.COINIT_MULTITHREADED);\r\n    if (hr.equals(W32Errors.S_OK)) {\r\n        Ole32.INSTANCE.CoUninitialize();\r\n        return false;\r\n    } else if (hr.equals(W32Errors.S_FALSE)) {\r\n        Ole32.INSTANCE.CoUninitialize();\r\n        return true;\r\n    } else if (hr.intValue() == W32Errors.RPC_E_CHANGED_MODE) {\r\n        return true;\r\n    }\r\n    COMUtils.checkRC(hr);\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.getOutputProperty",
	"Comment": "get the value of an output property,the explicit value, if any, otherwise thedefault value, if any, otherwise null.",
	"Method": "String getOutputProperty(String name){\r\n    String val = getOutputPropertyNonDefault(name);\r\n    if (val == null)\r\n        val = getOutputPropertyDefault(name);\r\n    return val;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.Stylesheet.getStylesheetParent",
	"Comment": "get the parent of the stylesheet.this will be null if thisis the root stylesheet.",
	"Method": "Stylesheet getStylesheetParent(){\r\n    return m_stylesheetParent;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerImpl.postExceptionFromThread",
	"Comment": "from a secondary thread, post the exception, so thatit can be picked up from the main thread.",
	"Method": "void postExceptionFromThread(Exception e){\r\n    m_exceptionThrown = e;\r\n    ;\r\n    synchronized (this) {\r\n        notifyAll();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.asIterator",
	"Comment": "given an select expression and a context, evaluate the xpathand return the resulting iterator.",
	"Method": "DTMIterator asIterator(XPathContext xctxt,int contextNode){\r\n    XNodeSet iter = new XNodeSet((LocPathIterator) m_clones.getInstance());\r\n    iter.setRoot(contextNode, xctxt);\r\n    return iter;\r\n}"
}, {
	"Path": "hudson.model.View.isAutomaticRefreshEnabled",
	"Comment": "enables or disables automatic refreshes of the view.by default, automatic refreshes are enabled.",
	"Method": "boolean isAutomaticRefreshEnabled(){\r\n    return true;\r\n}"
}, {
	"Path": "lib.form.ExpandableTextboxTest.evaluateAsHtml",
	"Comment": "evaluates the literal jelly script passed as a parameter as html and returns the page.",
	"Method": "HtmlPage evaluateAsHtml(String jellyScript){\r\n    JenkinsRule.WebClient wc = j.createWebClient();\r\n    WebRequest req = new WebRequest(wc.createCrumbedUrl(\"eval\"), POST);\r\n    req.setEncodingType(null);\r\n    req.setRequestBody(\"<j:jelly xmlns:j='jelly:core' xmlns:st='jelly:stapler' xmlns:l='/lib/layout' xmlns:f='/lib/form'>\" + jellyScript + \"<\/j:jelly>\");\r\n    Page page = wc.getPage(req);\r\n    return (HtmlPage) page;\r\n}"
}, {
	"Path": "hudson.model.Executor.hasStopPermission",
	"Comment": "checks if the current user has a permission to stop this build.",
	"Method": "boolean hasStopPermission(){\r\n    lock.readLock().lock();\r\n    try {\r\n        return executable != null && getParentOf(executable).getOwnerTask().hasAbortPermission();\r\n    } finally {\r\n        lock.readLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "hudson.diagnosis.OldDataMonitor.doUpgrade",
	"Comment": "save all or some of the files to persist data in the new forms.remove those items from the data map.",
	"Method": "HttpResponse doUpgrade(StaplerRequest req,StaplerResponse rsp){\r\n    final String thruVerParam = req.getParameter(\"thruVer\");\r\n    final VersionNumber thruVer = thruVerParam.equals(\"all\") ? null : new VersionNumber(thruVerParam);\r\n    saveAndRemoveEntries(new Predicate<Map.Entry<SaveableReference, VersionRange>>() {\r\n        @Override\r\n        public boolean apply(Map.Entry<SaveableReference, VersionRange> entry) {\r\n            VersionNumber version = entry.getValue().max;\r\n            return version != null && (thruVer == null || !version.isNewerThan(thruVer));\r\n        }\r\n    });\r\n    return HttpResponses.forwardToPreviousPage();\r\n}"
}, {
	"Path": "hudson.diagnosis.OldDataMonitor.doUpgrade",
	"Comment": "save all or some of the files to persist data in the new forms.remove those items from the data map.",
	"Method": "HttpResponse doUpgrade(StaplerRequest req,StaplerResponse rsp){\r\n    VersionNumber version = entry.getValue().max;\r\n    return version != null && (thruVer == null || !version.isNewerThan(thruVer));\r\n}"
}, {
	"Path": "hudson.lifecycle.WindowsServiceLifecycle.rewriteHudsonWar",
	"Comment": "on windows, jenkins.war is locked, so we place a new version under a special name,which is picked up by the service wrapper upon restart.",
	"Method": "void rewriteHudsonWar(File by){\r\n    File dest = getHudsonWar();\r\n    if (dest == null)\r\n        throw new IOException(\"jenkins.war location is not known.\");\r\n    File bak = new File(dest.getPath() + \".bak\");\r\n    if (!by.equals(bak))\r\n        FileUtils.copyFile(dest, bak);\r\n    String baseName = dest.getName();\r\n    baseName = baseName.substring(0, baseName.indexOf('.'));\r\n    File baseDir = getBaseDir();\r\n    File copyFiles = new File(baseDir, baseName + \".copies\");\r\n    try (FileWriter w = new FileWriter(copyFiles, true)) {\r\n        w.write(by.getAbsolutePath() + '>' + getHudsonWar().getAbsolutePath() + '\\n');\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.popElemTemplateElement",
	"Comment": "get the current xsltelementprocessor from the top of the stack.",
	"Method": "ElemTemplateElement popElemTemplateElement(){\r\n    return (ElemTemplateElement) m_elems.pop();\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.createLocalPseudoVarDecl",
	"Comment": "create a psuedo variable reference that will represent the shared redundent xpath, for a local reduction.",
	"Method": "ElemVariable createLocalPseudoVarDecl(QName uniquePseudoVarName,ElemTemplateElement psuedoVarRecipient,LocPathIterator lpi){\r\n    ElemVariable psuedoVar = new ElemVariablePsuedo();\r\n    XPath xpath = new XPath(lpi);\r\n    psuedoVar.setSelect(xpath);\r\n    psuedoVar.setName(uniquePseudoVarName);\r\n    ElemVariable var = addVarDeclToElem(psuedoVarRecipient, lpi, psuedoVar);\r\n    lpi.exprSetParent(var);\r\n    return var;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToUnknownStream.setSourceLocator",
	"Comment": "this method is used to set the source locator, which might be used togenerated an error message.",
	"Method": "void setSourceLocator(SourceLocator locator){\r\n    m_handler.setSourceLocator(locator);\r\n}"
}, {
	"Path": "hudson.util.ProcessKillingVeto._all",
	"Comment": "as classloading is lazy, the classes referenced in this method will not be resolveduntil the first time the method is invoked, so we use this method to guard access to jenkins jvm only classes.",
	"Method": "List<ProcessKillingVeto> _all(){\r\n    return ExtensionList.lookup(ProcessKillingVeto.class);\r\n}"
}, {
	"Path": "jadx.core.dex.nodes.MethodNode.isArgsOverload",
	"Comment": "return true if exists method with same name and arguments count",
	"Method": "boolean isArgsOverload(){\r\n    int argsCount = mthInfo.getArgumentsTypes().size();\r\n    if (argsCount == 0) {\r\n        return false;\r\n    }\r\n    String name = getName();\r\n    for (MethodNode method : parentClass.getMethods()) {\r\n        MethodInfo otherMthInfo = method.mthInfo;\r\n        if (this != method && otherMthInfo.getArgumentsTypes().size() == argsCount && otherMthInfo.getName().equals(name)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "redis.clients.jedis.BinaryJedis.getbit",
	"Comment": "returns the bit value at offset in the string value stored at key",
	"Method": "Boolean getbit(byte[] key,long offset){\r\n    checkIsInMultiOrPipeline();\r\n    client.getbit(key, offset);\r\n    return client.getIntegerReply() == 1;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.OutputProperties.getQNameProperty",
	"Comment": "searches for the qname property with the specified key in the property list.if the key is not found in this property list, the default property list,and its defaults, recursively, are then checked. the method returnsnull if the property is not found.",
	"Method": "QName getQNameProperty(QName key,QName getQNameProperty,String key,QName getQNameProperty,String key,Properties props){\r\n    String s = props.getProperty(key);\r\n    if (null != s)\r\n        return QName.getQNameFromString(s);\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "hudson.model.DependencyGraph.getTransitiveDownstream",
	"Comment": "gets all the direct and indirect downstream dependencies of the given project.",
	"Method": "Set<AbstractProject> getTransitiveDownstream(AbstractProject src){\r\n    return getTransitive(forward, src, false);\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XStringForChars.getChars",
	"Comment": "copies characters from this string into the destination characterarray.",
	"Method": "void getChars(int srcBegin,int srcEnd,char dst,int dstBegin){\r\n    System.arraycopy((char[]) m_obj, m_start + srcBegin, dst, dstBegin, srcEnd);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.getNextAttributeIdentity",
	"Comment": "given a node identity for an attribute, advance to the next attribute.",
	"Method": "int getNextAttributeIdentity(int identity){\r\n    while (DTM.NULL != (identity = getNextNodeIdentity(identity))) {\r\n        int type = _type(identity);\r\n        if (type == DTM.ATTRIBUTE_NODE) {\r\n            return identity;\r\n        } else if (type != DTM.NAMESPACE_NODE) {\r\n            break;\r\n        }\r\n    }\r\n    return DTM.NULL;\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.Compiler.assertion",
	"Comment": "tell the user of an assertion error, and probably throw anexception.",
	"Method": "void assertion(boolean b,java.lang.String msg){\r\n    if (!b) {\r\n        java.lang.String fMsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION, new Object[] { msg });\r\n        throw new RuntimeException(fMsg);\r\n    }\r\n}"
}, {
	"Path": "jadx.core.utils.BlockUtils.skipSyntheticPredecessor",
	"Comment": "return predecessor of synthetic block or same block otherwise.",
	"Method": "BlockNode skipSyntheticPredecessor(BlockNode block){\r\n    if (block.isSynthetic() && block.getPredecessors().size() == 1) {\r\n        return block.getPredecessors().get(0);\r\n    }\r\n    return block;\r\n}"
}, {
	"Path": "com.iluwatar.queue.load.leveling.TaskGenerator.run",
	"Comment": "each taskgenerator thread will submit all the messages to the queue.after every message submission taskgenerator thread will sleep for 1 second.",
	"Method": "void run(){\r\n    int count = this.msgCount;\r\n    try {\r\n        while (count > 0) {\r\n            String statusMsg = \"Message-\" + count + \" submitted by \" + Thread.currentThread().getName();\r\n            this.submit(new Message(statusMsg));\r\n            LOGGER.info(statusMsg);\r\n            count--;\r\n            Thread.sleep(1000);\r\n        }\r\n    } catch (Exception e) {\r\n        LOGGER.error(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.getClassFilename",
	"Comment": "converts the class dot notation to a filesystem equivalent forsearching purposes.",
	"Method": "String getClassFilename(String classname){\r\n    return classname.replace('.', '/') + \".class\";\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.getVarStack",
	"Comment": "get the variable stack, which is in charge of variables andparameters.",
	"Method": "VariableStack getVarStack(){\r\n    return m_variableStacks;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.popProcessor",
	"Comment": "pop the current xsltelementprocessor from the top of the stack.",
	"Method": "XSLTElementProcessor popProcessor(){\r\n    return (XSLTElementProcessor) m_processors.pop();\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.doException",
	"Comment": "end point that intentionally throws an exception to test the error behaviour.",
	"Method": "void doException(){\r\n    throw new RuntimeException();\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToUnknownStream.isFirstElemHTML",
	"Comment": "determine if the firts element in the document isor this uses the cached first element name, first element prefix and thecached namespaces from previous method calls",
	"Method": "boolean isFirstElemHTML(){\r\n    boolean isHTML;\r\n    isHTML = getLocalNameUnknown(m_firstElementName).equalsIgnoreCase(\"html\");\r\n    if (isHTML && m_firstElementURI != null && !EMPTYSTRING.equals(m_firstElementURI)) {\r\n        isHTML = false;\r\n    }\r\n    if (isHTML && m_namespacePrefix != null) {\r\n        final int max = m_namespacePrefix.size();\r\n        for (int i = 0; i < max; i++) {\r\n            final String prefix = (String) m_namespacePrefix.elementAt(i);\r\n            final String uri = (String) m_namespaceURI.elementAt(i);\r\n            if (m_firstElementPrefix != null && m_firstElementPrefix.equals(prefix) && !EMPTYSTRING.equals(uri)) {\r\n                isHTML = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return isHTML;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.setTail",
	"Comment": "set the tail of the stack to the given node.special purpose method for transformerimpl, pushelemtemplateelement.performance critical.",
	"Method": "void setTail(Node n){\r\n    m_map[m_firstFree - 1] = n;\r\n}"
}, {
	"Path": "org.apache.xalan.xslt.ObjectFactory.findClassLoader",
	"Comment": "figure out which classloader to use.for jdk 1.2 and later usethe context classloader.",
	"Method": "ClassLoader findClassLoader(){\r\n    SecuritySupport ss = SecuritySupport.getInstance();\r\n    ClassLoader context = ss.getContextClassLoader();\r\n    ClassLoader system = ss.getSystemClassLoader();\r\n    ClassLoader chain = system;\r\n    while (true) {\r\n        if (context == chain) {\r\n            ClassLoader current = ObjectFactory.class.getClassLoader();\r\n            chain = system;\r\n            while (true) {\r\n                if (current == chain) {\r\n                    return system;\r\n                }\r\n                if (chain == null) {\r\n                    break;\r\n                }\r\n                chain = ss.getParentClassLoader(chain);\r\n            }\r\n            return current;\r\n        }\r\n        if (chain == null) {\r\n            break;\r\n        }\r\n        chain = ss.getParentClassLoader(chain);\r\n    }\r\n    ;\r\n    return context;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprIterator.getAnalysisBits",
	"Comment": "get the analysis bits for this walker, as defined in the walkerfactory.",
	"Method": "int getAnalysisBits(){\r\n    if (null != m_expr && m_expr instanceof PathComponent) {\r\n        return ((PathComponent) m_expr).getAnalysisBits();\r\n    }\r\n    return WalkerFactory.BIT_FILTER;\r\n}"
}, {
	"Path": "com.sun.jna.contrib.demo.FilteredTextField.setBalloonDuration",
	"Comment": "sets the time in milliseconds that the balloon is visible beforedisappearing.this is the maximum time that the balloon will be visible,as other events can also make the balloon disappear.",
	"Method": "void setBalloonDuration(Integer duration){\r\n    balloonDuration = duration;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.TransformerFactoryImpl.newTemplates",
	"Comment": "process the source into a templates object, which is likelya compiled representation of the source. this templates objectmay then be used concurrently across multiple threads.creatinga templates object allows the transformerfactory to do detailedperformance optimization of transformation instructions, withoutpenalizing runtime transformation.",
	"Method": "Templates newTemplates(Source source){\r\n    String baseID = source.getSystemId();\r\n    if (null != baseID) {\r\n        baseID = SystemIDResolver.getAbsoluteURI(baseID);\r\n    }\r\n    if (source instanceof DOMSource) {\r\n        DOMSource dsource = (DOMSource) source;\r\n        Node node = dsource.getNode();\r\n        if (null != node)\r\n            return processFromNode(node, baseID);\r\n        else {\r\n            String messageStr = XSLMessages.createMessage(XSLTErrorResources.ER_ILLEGAL_DOMSOURCE_INPUT, null);\r\n            throw new IllegalArgumentException(messageStr);\r\n        }\r\n    }\r\n    TemplatesHandler builder = newTemplatesHandler();\r\n    builder.setSystemId(baseID);\r\n    try {\r\n        InputSource isource = SAXSource.sourceToInputSource(source);\r\n        isource.setSystemId(baseID);\r\n        XMLReader reader = null;\r\n        if (source instanceof SAXSource)\r\n            reader = ((SAXSource) source).getXMLReader();\r\n        if (null == reader) {\r\n            try {\r\n                javax.xml.parsers.SAXParserFactory factory = javax.xml.parsers.SAXParserFactory.newInstance();\r\n                factory.setNamespaceAware(true);\r\n                if (m_isSecureProcessing) {\r\n                    try {\r\n                        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\r\n                    } catch (org.xml.sax.SAXException se) {\r\n                    }\r\n                }\r\n                javax.xml.parsers.SAXParser jaxpParser = factory.newSAXParser();\r\n                reader = jaxpParser.getXMLReader();\r\n            } catch (javax.xml.parsers.ParserConfigurationException ex) {\r\n                throw new org.xml.sax.SAXException(ex);\r\n            } catch (javax.xml.parsers.FactoryConfigurationError ex1) {\r\n                throw new org.xml.sax.SAXException(ex1.toString());\r\n            } catch (NoSuchMethodError ex2) {\r\n            } catch (AbstractMethodError ame) {\r\n            }\r\n        }\r\n        if (null == reader)\r\n            reader = XMLReaderFactory.createXMLReader();\r\n        reader.setContentHandler(builder);\r\n        reader.parse(isource);\r\n    } catch (org.xml.sax.SAXException se) {\r\n        if (m_errorListener != null) {\r\n            try {\r\n                m_errorListener.fatalError(new TransformerException(se));\r\n            } catch (TransformerConfigurationException ex1) {\r\n                throw ex1;\r\n            } catch (TransformerException ex1) {\r\n                throw new TransformerConfigurationException(ex1);\r\n            }\r\n        } else {\r\n            throw new TransformerConfigurationException(se.getMessage(), se);\r\n        }\r\n    } catch (Exception e) {\r\n        if (m_errorListener != null) {\r\n            try {\r\n                m_errorListener.fatalError(new TransformerException(e));\r\n                return null;\r\n            } catch (TransformerConfigurationException ex1) {\r\n                throw ex1;\r\n            } catch (TransformerException ex1) {\r\n                throw new TransformerConfigurationException(ex1);\r\n            }\r\n        } else {\r\n            throw new TransformerConfigurationException(e.getMessage(), e);\r\n        }\r\n    }\r\n    return builder.getTemplates();\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncExtFunction.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    if (xctxt.isSecureProcessing())\r\n        throw new javax.xml.transform.TransformerException(XPATHMessages.createXPATHMessage(XPATHErrorResources.ER_EXTENSION_FUNCTION_CANNOT_BE_INVOKED, new Object[] { toString() }));\r\n    XObject result;\r\n    Vector argVec = new Vector();\r\n    int nArgs = m_argVec.size();\r\n    for (int i = 0; i < nArgs; i++) {\r\n        Expression arg = (Expression) m_argVec.elementAt(i);\r\n        XObject xobj = arg.execute(xctxt);\r\n        xobj.allowDetachToRelease(false);\r\n        argVec.addElement(xobj);\r\n    }\r\n    ExtensionsProvider extProvider = (ExtensionsProvider) xctxt.getOwnerObject();\r\n    Object val = extProvider.extFunction(this, argVec);\r\n    if (null != val) {\r\n        result = XObject.create(val, xctxt);\r\n    } else {\r\n        result = new XNull();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.createGlobalPseudoVarDecl",
	"Comment": "create a psuedo variable reference that will represent the shared redundent xpath, for a local reduction.",
	"Method": "ElemVariable createGlobalPseudoVarDecl(QName uniquePseudoVarName,StylesheetRoot stylesheetRoot,LocPathIterator lpi){\r\n    ElemVariable psuedoVar = new ElemVariable();\r\n    psuedoVar.setIsTopLevel(true);\r\n    XPath xpath = new XPath(lpi);\r\n    psuedoVar.setSelect(xpath);\r\n    psuedoVar.setName(uniquePseudoVarName);\r\n    Vector globalVars = stylesheetRoot.getVariablesAndParamsComposed();\r\n    psuedoVar.setIndex(globalVars.size());\r\n    globalVars.addElement(psuedoVar);\r\n    return psuedoVar;\r\n}"
}, {
	"Path": "hudson.model.Descriptor.getCategory",
	"Comment": "define the global configuration category the global config of this descriptor is in.",
	"Method": "GlobalConfigurationCategory getCategory(){\r\n    return GlobalConfigurationCategory.get(GlobalConfigurationCategory.Unclassified.class);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.FuncFormatNumb.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    ElemTemplateElement templElem = (ElemTemplateElement) xctxt.getNamespaceContext();\r\n    StylesheetRoot ss = templElem.getStylesheetRoot();\r\n    java.text.DecimalFormat formatter = null;\r\n    java.text.DecimalFormatSymbols dfs = null;\r\n    double num = getArg0().execute(xctxt).num();\r\n    String patternStr = getArg1().execute(xctxt).str();\r\n    if (patternStr.indexOf(0x00A4) > 0)\r\n        ss.error(XSLTErrorResources.ER_CURRENCY_SIGN_ILLEGAL);\r\n    try {\r\n        Expression arg2Expr = getArg2();\r\n        if (null != arg2Expr) {\r\n            String dfName = arg2Expr.execute(xctxt).str();\r\n            QName qname = new QName(dfName, xctxt.getNamespaceContext());\r\n            dfs = ss.getDecimalFormatComposed(qname);\r\n            if (null == dfs) {\r\n                warn(// \"not found!!!\r\n                xctxt, XSLTErrorResources.WG_NO_DECIMALFORMAT_DECLARATION, new Object[] { dfName });\r\n            } else {\r\n                formatter = new java.text.DecimalFormat();\r\n                formatter.setDecimalFormatSymbols(dfs);\r\n                formatter.applyLocalizedPattern(patternStr);\r\n            }\r\n        }\r\n        if (null == formatter) {\r\n            dfs = ss.getDecimalFormatComposed(new QName(\"\"));\r\n            if (dfs != null) {\r\n                formatter = new java.text.DecimalFormat();\r\n                formatter.setDecimalFormatSymbols(dfs);\r\n                formatter.applyLocalizedPattern(patternStr);\r\n            } else {\r\n                dfs = new java.text.DecimalFormatSymbols(java.util.Locale.US);\r\n                dfs.setInfinity(Constants.ATTRVAL_INFINITY);\r\n                dfs.setNaN(Constants.ATTRVAL_NAN);\r\n                formatter = new java.text.DecimalFormat();\r\n                formatter.setDecimalFormatSymbols(dfs);\r\n                if (null != patternStr)\r\n                    formatter.applyLocalizedPattern(patternStr);\r\n            }\r\n        }\r\n        return new XString(formatter.format(num));\r\n    } catch (Exception iae) {\r\n        templElem.error(XSLTErrorResources.ER_MALFORMED_FORMAT_STRING, new Object[] { patternStr });\r\n        return XString.EMPTYSTRING;\r\n    }\r\n}"
}, {
	"Path": "jenkins.security.UpdateSiteWarningsMonitor.doForward",
	"Comment": "redirects the user to the plugin manager or security configuration",
	"Method": "HttpResponse doForward(String fix,String configure){\r\n    if (fix != null) {\r\n        return HttpResponses.redirectViaContextPath(\"pluginManager\");\r\n    }\r\n    if (configure != null) {\r\n        return HttpResponses.redirectViaContextPath(\"configureSecurity\");\r\n    }\r\n    return HttpResponses.redirectViaContextPath(\"/\");\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.lazy.LazyFluentIterable.filter",
	"Comment": "filters the contents of iterable using the given predicate, leaving only the ones which satisfythe predicate.",
	"Method": "FluentIterable<E> filter(Predicate<? super E> predicate){\r\n    return new LazyFluentIterable<E>() {\r\n        @Override\r\n        public Iterator<E> iterator() {\r\n            return new DecoratingIterator<E>(iterable.iterator()) {\r\n                @Override\r\n                public E computeNext() {\r\n                    while (fromIterator.hasNext()) {\r\n                        E candidate = fromIterator.next();\r\n                        if (predicate.test(candidate)) {\r\n                            return candidate;\r\n                        }\r\n                    }\r\n                    return null;\r\n                }\r\n            };\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.lazy.LazyFluentIterable.filter",
	"Comment": "filters the contents of iterable using the given predicate, leaving only the ones which satisfythe predicate.",
	"Method": "FluentIterable<E> filter(Predicate<? super E> predicate){\r\n    return new DecoratingIterator<E>(iterable.iterator()) {\r\n        @Override\r\n        public E computeNext() {\r\n            while (fromIterator.hasNext()) {\r\n                E candidate = fromIterator.next();\r\n                if (predicate.test(candidate)) {\r\n                    return candidate;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.lazy.LazyFluentIterable.filter",
	"Comment": "filters the contents of iterable using the given predicate, leaving only the ones which satisfythe predicate.",
	"Method": "FluentIterable<E> filter(Predicate<? super E> predicate){\r\n    while (fromIterator.hasNext()) {\r\n        E candidate = fromIterator.next();\r\n        if (predicate.test(candidate)) {\r\n            return candidate;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "hudson.model.AbstractBuild.getDependencyChanges",
	"Comment": "gets the changes in the dependency between the given build and this build.",
	"Method": "Map<AbstractProject, DependencyChange> getDependencyChanges(AbstractBuild from){\r\n    if (from == null)\r\n        return Collections.emptyMap();\r\n    FingerprintAction n = this.getAction(FingerprintAction.class);\r\n    FingerprintAction o = from.getAction(FingerprintAction.class);\r\n    if (n == null || o == null)\r\n        return Collections.emptyMap();\r\n    Map<AbstractProject, Integer> ndep = n.getDependencies(true);\r\n    Map<AbstractProject, Integer> odep = o.getDependencies(true);\r\n    Map<AbstractProject, DependencyChange> r = new HashMap<AbstractProject, DependencyChange>();\r\n    for (Map.Entry<AbstractProject, Integer> entry : odep.entrySet()) {\r\n        AbstractProject p = entry.getKey();\r\n        Integer oldNumber = entry.getValue();\r\n        Integer newNumber = ndep.get(p);\r\n        if (newNumber != null && oldNumber.compareTo(newNumber) < 0) {\r\n            r.put(p, new DependencyChange(p, oldNumber, newNumber));\r\n        }\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "org.apache.xml.utils.DOM2Helper.getLocalNameOfNode",
	"Comment": "returns the local name of the given node, as defined by thexml namespaces specification. this is prepared to handle documentsbuilt using dom level 1 methods by falling back upon explicitlyparsing the node name.",
	"Method": "String getLocalNameOfNode(Node n){\r\n    String name = n.getLocalName();\r\n    return (null == name) ? super.getLocalNameOfNode(n) : name;\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.StepPattern.getProximityPosition",
	"Comment": "get the proximity position index of the current node based on thisnode test.",
	"Method": "int getProximityPosition(XPathContext xctxt,int predPos,boolean findLast,int getProximityPosition,XPathContext xctxt){\r\n    return getProximityPosition(xctxt, xctxt.getPredicatePos(), false);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.createXPath",
	"Comment": "process an expression string into an xpath.must be public for access by the avt class.",
	"Method": "XPath createXPath(String str,ElemTemplateElement owningTemplate){\r\n    ErrorListener handler = m_stylesheetProcessor.getErrorListener();\r\n    XPath xpath = new XPath(str, owningTemplate, this, XPath.SELECT, handler, m_funcTable);\r\n    xpath.callVisitors(xpath, new ExpressionVisitor(getStylesheetRoot()));\r\n    return xpath;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerIdentityImpl.getOutputProperty",
	"Comment": "get an output property that is in effect for thetransformation.the property specified may be a propertythat was set with setoutputproperty, or it may be aproperty specified in the stylesheet.",
	"Method": "String getOutputProperty(String name){\r\n    String value = null;\r\n    OutputProperties props = m_outputFormat;\r\n    value = props.getProperty(name);\r\n    if (null == value) {\r\n        if (!OutputProperties.isLegalPropertyKey(name))\r\n            throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[] { name }));\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.apache.xalan.xslt.ObjectFactory.newInstance",
	"Comment": "create an instance of a class using the specified classloader",
	"Method": "Object newInstance(String className,ClassLoader cl,boolean doFallback){\r\n    try {\r\n        Class providerClass = findProviderClass(className, cl, doFallback);\r\n        Object instance = providerClass.newInstance();\r\n        debugPrintln(\"created new instance of \" + providerClass + \" using ClassLoader: \" + cl);\r\n        return instance;\r\n    } catch (ClassNotFoundException x) {\r\n        throw new ConfigurationError(\"Provider \" + className + \" not found\", x);\r\n    } catch (Exception x) {\r\n        throw new ConfigurationError(\"Provider \" + className + \" could not be instantiated: \" + x, x);\r\n    }\r\n}"
}, {
	"Path": "hudson.model.DependencyGraphTest.testTriggerJob",
	"Comment": "tests triggering downstream projects with dependencygraph.dependency",
	"Method": "void testTriggerJob(){\r\n    setQuietPeriod(3);\r\n    Project p = createFreeStyleProject(), down1 = createFreeStyleProject(), down2 = createFreeStyleProject();\r\n    p.getPublishersList().add(new BuildTrigger(Collections.singletonList(down1), Result.SUCCESS));\r\n    p.getBuildersList().add(new TestDeclarer(Result.UNSTABLE, down2));\r\n    jenkins.rebuildDependencyGraph();\r\n    Build b = (Build) p.scheduleBuild2(0, new Cause.UserCause()).get();\r\n    String log = getLog(b);\r\n    Queue.Item q = jenkins.getQueue().getItem(down1);\r\n    assertNull(\"down1 should not be triggered: \" + log, q);\r\n    assertNull(\"down1 should not be triggered: \" + log, down1.getLastBuild());\r\n    q = jenkins.getQueue().getItem(down2);\r\n    assertNotNull(\"down2 should be in queue (quiet period): \" + log, q);\r\n    Run r = (Run) q.getFuture().get(60, TimeUnit.SECONDS);\r\n    assertNotNull(\"down2 should be triggered: \" + log, r);\r\n    assertNotNull(\"down2 should have MailMessageIdAction\", r.getAction(MailMessageIdAction.class));\r\n    p.getBuildersList().replace(new TestDeclarer(Result.SUCCESS, down2));\r\n    jenkins.rebuildDependencyGraph();\r\n    b = (Build) p.scheduleBuild2(0, new Cause.UserCause()).get();\r\n    log = getLog(b);\r\n    q = jenkins.getQueue().getItem(down2);\r\n    assertNull(\"down2 should not be triggered: \" + log, q);\r\n    assertEquals(\"down2 should not be triggered: \" + log, 1, down2.getLastBuild().getNumber());\r\n    q = jenkins.getQueue().getItem(down1);\r\n    assertNotNull(\"down1 should be in queue (quiet period): \" + log, q);\r\n    r = (Run) q.getFuture().get(60, TimeUnit.SECONDS);\r\n    assertNotNull(\"down1 should be triggered\", r);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.getNamespaceURI",
	"Comment": "returns the uri of an element or attribute. note that default namespacesdo not apply directly to attributes.",
	"Method": "String getNamespaceURI(String qname,boolean isElement){\r\n    String uri = EMPTYSTRING;\r\n    int col = qname.lastIndexOf(':');\r\n    final String prefix = (col > 0) ? qname.substring(0, col) : EMPTYSTRING;\r\n    if (!EMPTYSTRING.equals(prefix) || isElement) {\r\n        if (m_prefixMap != null) {\r\n            uri = m_prefixMap.lookupNamespace(prefix);\r\n            if (uri == null && !prefix.equals(XMLNS_PREFIX)) {\r\n                throw new RuntimeException(Utils.messages.createMessage(MsgKey.ER_NAMESPACE_PREFIX, new Object[] { qname.substring(0, col) }));\r\n            }\r\n        }\r\n    }\r\n    return uri;\r\n}"
}, {
	"Path": "hudson.model.ParameterValue.getValue",
	"Comment": "returns the most natural java object that represents the actual value, likeboolean, string, etc.",
	"Method": "Object getValue(){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.getDocumentSystemIdentifier",
	"Comment": "return the system identifier of the document entity. ifit is not known, the value of this property is unknown.",
	"Method": "String getDocumentSystemIdentifier(int nodeHandle){\r\n    return m_documentBaseURI;\r\n}"
}, {
	"Path": "hudson.model.ApiSecurity1129Test.checkWrapperParam",
	"Comment": "check the response for a xml api with the wrapper param specified. at least the statucode or the responsemessageshould be indicated.",
	"Method": "void checkWrapperParam(String wrapper,Integer statusCode,String responseMessage){\r\n    if (statusCode == null && responseMessage == null) {\r\n        fail(\"You should check at least one, the statusCode or the responseMessage when testing the wrapper param\");\r\n    }\r\n    JenkinsRule.WebClient wc = j.createWebClient();\r\n    wc.getOptions().setThrowExceptionOnFailingStatusCode(false);\r\n    WebResponse response = wc.goTo(String.format(\"whoAmI/api/xml?xpath=*&wrapper=%s\", wrapper), null).getWebResponse();\r\n    if (response != null) {\r\n        if (statusCode != null) {\r\n            assertEquals(statusCode.intValue(), response.getStatusCode());\r\n        }\r\n        if (responseMessage != null) {\r\n            assertEquals(responseMessage, response.getContentAsString());\r\n        }\r\n    } else {\r\n        fail(\"The response shouldn't be null\");\r\n    }\r\n}"
}, {
	"Path": "hudson.util.PluginServletFilter.hasFilter",
	"Comment": "checks whether the given filter is already registered in the chain.",
	"Method": "boolean hasFilter(Filter filter){\r\n    Jenkins j = Jenkins.getInstanceOrNull();\r\n    PluginServletFilter container = null;\r\n    if (j != null) {\r\n        container = getInstance(j.servletContext);\r\n    }\r\n    if (j == null || container == null) {\r\n        return LEGACY.contains(filter);\r\n    } else {\r\n        return container.list.contains(filter);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.NamespaceSupport2.popContext",
	"Comment": "revert to the previous namespace context.normally, you should pop the context at the end of eachxml element.after popping the context, all namespace prefixmappings that were previously in force are restored.you must not attempt to declare additional namespaceprefixes after popping a context, unless you push anothercontext first.",
	"Method": "void popContext(){\r\n    Context2 parentContext = currentContext.getParent();\r\n    if (parentContext == null)\r\n        throw new EmptyStackException();\r\n    else\r\n        currentContext = parentContext;\r\n}"
}, {
	"Path": "hudson.model.Queue.getCauseOfBlockageForTask",
	"Comment": "checks if the given task knows the reasons to be blocked or it needs some unavailable resources",
	"Method": "CauseOfBlockage getCauseOfBlockageForTask(Task task){\r\n    CauseOfBlockage causeOfBlockage = task.getCauseOfBlockage();\r\n    if (causeOfBlockage != null) {\r\n        return task.getCauseOfBlockage();\r\n    }\r\n    if (!canRun(task.getResourceList())) {\r\n        ResourceActivity r = getBlockingActivity(task);\r\n        if (r != null) {\r\n            if (r == task)\r\n                return CauseOfBlockage.fromMessage(Messages._Queue_InProgress());\r\n            return CauseOfBlockage.fromMessage(Messages._Queue_BlockedBy(r.getDisplayName()));\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "hudson.model.listeners.RunListener.register",
	"Comment": "registers this object as an active listener so that it can start gettingcallbacks invoked.",
	"Method": "void register(){\r\n    all().add(this);\r\n}"
}, {
	"Path": "jenkins.security.s2m.CallableRejectionConfig.describe",
	"Comment": "return the object that helps the ui rendering by providing the details.",
	"Method": "List<RejectedCallable> describe(){\r\n    List<RejectedCallable> l = new ArrayList<RejectedCallable>();\r\n    for (Class c : get()) {\r\n        if (!whitelist.contains(c.getName()))\r\n            l.add(new RejectedCallable(c));\r\n    }\r\n    return l;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.LSSerializerImpl.getInputEncoding",
	"Comment": "determines the input encoding of the document node to serialize.if the document nodeis not a dom level 3 node, then null is returned.",
	"Method": "String getInputEncoding(Node nodeArg){\r\n    Document doc = null;\r\n    if (nodeArg != null) {\r\n        if (nodeArg.getNodeType() == Node.DOCUMENT_NODE) {\r\n            doc = (Document) nodeArg;\r\n        } else {\r\n            doc = nodeArg.getOwnerDocument();\r\n        }\r\n        if (doc != null && doc.getImplementation().hasFeature(\"Core\", \"3.0\")) {\r\n            return doc.getInputEncoding();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "redis.clients.jedis.BinaryJedis.flushDB",
	"Comment": "delete all the keys of the currently selected db. this command never fails.",
	"Method": "String flushDB(){\r\n    checkIsInMultiOrPipeline();\r\n    client.flushDB();\r\n    return client.getStatusCodeReply();\r\n}"
}, {
	"Path": "hudson.model.DownloadService.generateFragment",
	"Comment": "builds up an html fragment that starts all the download jobs.",
	"Method": "String generateFragment(){\r\n    if (!DownloadSettings.usePostBack()) {\r\n        return \"\";\r\n    }\r\n    if (neverUpdate)\r\n        return \"\";\r\n    if (doesNotSupportPostMessage())\r\n        return \"\";\r\n    StringBuilder buf = new StringBuilder();\r\n    if (Jenkins.getInstance().hasPermission(Jenkins.READ)) {\r\n        long now = System.currentTimeMillis();\r\n        for (Downloadable d : Downloadable.all()) {\r\n            if (d.getDue() < now && d.lastAttempt + 10 * 1000 < now) {\r\n                buf.append(\"<script>\").append(\"Behaviour.addLoadEvent(function() {\").append(\"  downloadService.download(\").append(QuotedStringTokenizer.quote(d.getId())).append(',').append(QuotedStringTokenizer.quote(mapHttps(d.getUrl()))).append(',').append(\"{version:\" + QuotedStringTokenizer.quote(Jenkins.VERSION) + '}').append(',').append(QuotedStringTokenizer.quote(Stapler.getCurrentRequest().getContextPath() + '/' + getUrl() + \"/byId/\" + d.getId() + \"/postBack\")).append(',').append(\"null);\").append(\"});\").append(\"<\/script>\");\r\n                d.lastAttempt = now;\r\n            }\r\n        }\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemLiteralResult.accept",
	"Comment": "accept a visitor and call the appropriate method for this class.",
	"Method": "boolean accept(XSLTVisitor visitor){\r\n    return visitor.visitLiteralResultElement(this);\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncGenerateId.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    int which = getArg0AsNode(xctxt);\r\n    if (DTM.NULL != which) {\r\n        return new XString(\"N\" + Integer.toHexString(which).toUpperCase());\r\n    } else\r\n        return XString.EMPTYSTRING;\r\n}"
}, {
	"Path": "org.apache.xml.utils.SAXSourceLocator.getSystemId",
	"Comment": "return the system identifier for the current document event.the return value is the system identifier of the documententity or of the external parsed entity in which the markuptriggering the event appears.if the system identifier is a url, the parser must resolve itfully before passing it to the application.",
	"Method": "String getSystemId(){\r\n    return (null == m_locator) ? super.getSystemId() : m_locator.getSystemId();\r\n}"
}, {
	"Path": "org.apache.xpath.axes.AttributeIterator.getNextNode",
	"Comment": "get the next node via getfirstattribute && getnextattribute.",
	"Method": "int getNextNode(){\r\n    m_lastFetched = (DTM.NULL == m_lastFetched) ? m_cdtm.getFirstAttribute(m_context) : m_cdtm.getNextAttribute(m_lastFetched);\r\n    return m_lastFetched;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncNot.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    return m_arg0.execute(xctxt).bool() ? XBoolean.S_FALSE : XBoolean.S_TRUE;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.FileUtilTest.testExtractClassesJarFromAarFile",
	"Comment": "verify that a classes.jar file is extracted from an android aar file.",
	"Method": "void testExtractClassesJarFromAarFile(){\r\n    File aarFile = new File(getResourceAsFile(\"hello.aar\"));\r\n    File classesJar = options.fileUtil().extractClassesJarFromAarFile(aarFile);\r\n    assertTrue(classesJar.exists());\r\n    try (ZipFile zfile = new ZipFile(classesJar)) {\r\n        assertNotNull(zfile.getEntry(\"com/example/hello/Hello.class\"));\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.api.DockerDaemonImage.named",
	"Comment": "instantiate with the image reference to tag the built image with. this is the name that showsup on the docker daemon.",
	"Method": "DockerDaemonImage named(ImageReference imageReference,DockerDaemonImage named,String imageReference){\r\n    return named(ImageReference.parse(imageReference));\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.Messages.createMessage",
	"Comment": "creates a message from the specified key and replacementarguments, localized to the given locale.",
	"Method": "String createMessage(String msgKey,Object args){\r\n    if (m_resourceBundle == null)\r\n        m_resourceBundle = loadResourceBundle(m_resourceBundleName);\r\n    if (m_resourceBundle != null) {\r\n        return createMsg(m_resourceBundle, msgKey, args);\r\n    } else\r\n        return \"Could not load the resource bundles: \" + m_resourceBundleName;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerIdentityImpl.getErrorListener",
	"Comment": "get the error event handler in effect for the transformation.",
	"Method": "ErrorListener getErrorListener(){\r\n    return m_errorListener;\r\n}"
}, {
	"Path": "hudson.util.ChunkedOutputStream.finish",
	"Comment": "must be called to ensure the internal cache is flushed and the closing chunk is written.",
	"Method": "void finish(){\r\n    if (!wroteLastChunk) {\r\n        flushCache();\r\n        writeClosingChunk();\r\n        wroteLastChunk = true;\r\n    }\r\n}"
}, {
	"Path": "redis.clients.jedis.BinaryJedis.dbSize",
	"Comment": "return the number of keys in the currently selected database.",
	"Method": "Long dbSize(){\r\n    checkIsInMultiOrPipeline();\r\n    client.dbSize();\r\n    return client.getIntegerReply();\r\n}"
}, {
	"Path": "hudson.model.AsyncPeriodicWork.getNormalLoggingLevel",
	"Comment": "returns the logging level at which normal messages are displayed.",
	"Method": "Level getNormalLoggingLevel(){\r\n    return Level.INFO;\r\n}"
}, {
	"Path": "hudson.model.Items.verifyItemDoesNotAlreadyExist",
	"Comment": "securely check for the existence of an item before trying to create one with the same name.",
	"Method": "void verifyItemDoesNotAlreadyExist(ItemGroup<?> parent,String newName,Item variant){\r\n    Item existing;\r\n    try (ACLContext ctxt = ACL.as(ACL.SYSTEM)) {\r\n        existing = parent.getItem(newName);\r\n    }\r\n    if (existing != null && existing != variant) {\r\n        if (existing.hasPermission(Item.DISCOVER)) {\r\n            String prefix = parent.getFullName();\r\n            throw new IllegalArgumentException((prefix.isEmpty() ? \"\" : prefix + \"/\") + newName + \" already exists\");\r\n        } else {\r\n            throw new Failure(\"\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "hudson.XmlFile.sniffEncoding",
	"Comment": "parses the beginning of the file and determines the encoding.",
	"Method": "String sniffEncoding(){\r\n    class Eureka extends SAXException {\r\n        final String encoding;\r\n        public Eureka(String encoding) {\r\n            this.encoding = encoding;\r\n        }\r\n    }\r\n    try (InputStream in = Files.newInputStream(file.toPath())) {\r\n        InputSource input = new InputSource(file.toURI().toASCIIString());\r\n        input.setByteStream(in);\r\n        JAXP.newSAXParser().parse(input, new DefaultHandler() {\r\n            private Locator loc;\r\n            @Override\r\n            public void setDocumentLocator(Locator locator) {\r\n                this.loc = locator;\r\n            }\r\n            @Override\r\n            public void startDocument() throws SAXException {\r\n                attempt();\r\n            }\r\n            @Override\r\n            public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\r\n                attempt();\r\n                throw new Eureka(null);\r\n            }\r\n            private void attempt() throws Eureka {\r\n                if (loc == null)\r\n                    return;\r\n                if (loc instanceof Locator2) {\r\n                    Locator2 loc2 = (Locator2) loc;\r\n                    String e = loc2.getEncoding();\r\n                    if (e != null)\r\n                        throw new Eureka(e);\r\n                }\r\n            }\r\n        });\r\n        throw new AssertionError();\r\n    } catch (Eureka e) {\r\n        if (e.encoding != null)\r\n            return e.encoding;\r\n        return \"UTF-8\";\r\n    } catch (SAXException e) {\r\n        throw new IOException(\"Failed to detect encoding of \" + file, e);\r\n    } catch (InvalidPathException e) {\r\n        throw new IOException(e);\r\n    } catch (ParserConfigurationException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}"
}, {
	"Path": "hudson.XmlFile.sniffEncoding",
	"Comment": "parses the beginning of the file and determines the encoding.",
	"Method": "String sniffEncoding(){\r\n    this.loc = locator;\r\n}"
}, {
	"Path": "hudson.XmlFile.sniffEncoding",
	"Comment": "parses the beginning of the file and determines the encoding.",
	"Method": "String sniffEncoding(){\r\n    attempt();\r\n}"
}, {
	"Path": "hudson.XmlFile.sniffEncoding",
	"Comment": "parses the beginning of the file and determines the encoding.",
	"Method": "String sniffEncoding(){\r\n    attempt();\r\n    throw new Eureka(null);\r\n}"
}, {
	"Path": "hudson.XmlFile.sniffEncoding",
	"Comment": "parses the beginning of the file and determines the encoding.",
	"Method": "String sniffEncoding(){\r\n    if (loc == null)\r\n        return;\r\n    if (loc instanceof Locator2) {\r\n        Locator2 loc2 = (Locator2) loc;\r\n        String e = loc2.getEncoding();\r\n        if (e != null)\r\n            throw new Eureka(e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.AbsPathChecker.checkAbsolute",
	"Comment": "process the locpathiterator to see if it contains variables \tor functions that may make it context dependent.",
	"Method": "boolean checkAbsolute(LocPathIterator path){\r\n    m_isAbs = true;\r\n    path.callVisitors(null, this);\r\n    return m_isAbs;\r\n}"
}, {
	"Path": "com.iluwatar.bridge.WeaponTest.testBasicWeaponActions",
	"Comment": "invoke the basic actions of the given weapon, and test if the underlying enchantment implementationis invoked",
	"Method": "void testBasicWeaponActions(Weapon weapon){\r\n    assertNotNull(weapon);\r\n    Enchantment enchantment = weapon.getEnchantment();\r\n    assertNotNull(enchantment);\r\n    assertNotNull(weapon.getEnchantment());\r\n    weapon.swing();\r\n    verify(enchantment).apply();\r\n    verifyNoMoreInteractions(enchantment);\r\n    weapon.wield();\r\n    verify(enchantment).onActivate();\r\n    verifyNoMoreInteractions(enchantment);\r\n    weapon.unwield();\r\n    verify(enchantment).onDeactivate();\r\n    verifyNoMoreInteractions(enchantment);\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FunctionOneArg.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    if (null != m_arg0)\r\n        m_arg0.fixupVariables(vars, globalsSize);\r\n}"
}, {
	"Path": "com.iluwatar.model.view.controller.GiantControllerTest.testSetNourishment",
	"Comment": "verify if the controller passes the nourishment level through to the model and vice versa",
	"Method": "void testSetNourishment(){\r\n    final GiantModel model = mock(GiantModel.class);\r\n    final GiantView view = mock(GiantView.class);\r\n    final GiantController controller = new GiantController(model, view);\r\n    verifyZeroInteractions(model, view);\r\n    for (final Nourishment nourishment : Nourishment.values()) {\r\n        controller.setNourishment(nourishment);\r\n        verify(model).setNourishment(nourishment);\r\n        verifyZeroInteractions(view);\r\n    }\r\n    controller.getNourishment();\r\n    verify(model).getNourishment();\r\n    verifyNoMoreInteractions(model, view);\r\n}"
}, {
	"Path": "hudson.model.AbstractProject.getResourceList",
	"Comment": "list of necessary resources to perform the build of this project.",
	"Method": "ResourceList getResourceList(){\r\n    final Set<ResourceActivity> resourceActivities = getResourceActivities();\r\n    final List<ResourceList> resourceLists = new ArrayList<ResourceList>(1 + resourceActivities.size());\r\n    for (ResourceActivity activity : resourceActivities) {\r\n        if (activity != this && activity != null) {\r\n            resourceLists.add(activity.getResourceList());\r\n        }\r\n    }\r\n    return ResourceList.union(resourceLists);\r\n}"
}, {
	"Path": "com.iluwatar.async.method.invocation.App.callback",
	"Comment": "creates a simple callback that logs the complete status of the async result.",
	"Method": "AsyncCallback<T> callback(String name){\r\n    return (value, ex) -> {\r\n        if (ex.isPresent()) {\r\n            log(name + \" failed: \" + ex.map(Exception::getMessage).orElse(\"\"));\r\n        } else {\r\n            log(name + \": \" + value);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "hudson.cli.CommandDuringBuild.getCurrentlyBuilding",
	"Comment": "this method makes sense only when called from within the build kicked by jenkins.we use the environment variables that jenkins sets to determine the build that is being run.",
	"Method": "Run getCurrentlyBuilding(){\r\n    Run r = optCurrentlyBuilding();\r\n    if (r == null)\r\n        throw new IllegalStateException(\"This CLI command works only when invoked from inside a build\");\r\n    return r;\r\n}"
}, {
	"Path": "com.iluwatar.builder.HeroTest.testBuildHero",
	"Comment": "test if the hero build by the builder has the correct attributes, as requested",
	"Method": "void testBuildHero(){\r\n    final String heroName = \"Sir Lancelot\";\r\n    final Hero hero = new Hero.Builder(Profession.WARRIOR, heroName).withArmor(Armor.CHAIN_MAIL).withWeapon(Weapon.SWORD).withHairType(HairType.LONG_CURLY).withHairColor(HairColor.BLOND).build();\r\n    assertNotNull(hero);\r\n    assertNotNull(hero.toString());\r\n    assertEquals(Profession.WARRIOR, hero.getProfession());\r\n    assertEquals(heroName, hero.getName());\r\n    assertEquals(Armor.CHAIN_MAIL, hero.getArmor());\r\n    assertEquals(Weapon.SWORD, hero.getWeapon());\r\n    assertEquals(HairType.LONG_CURLY, hero.getHairType());\r\n    assertEquals(HairColor.BLOND, hero.getHairColor());\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.endPrefixMapping",
	"Comment": "receive notification of the end of a namespace mapping.by default, do nothing.application writers may override thismethod in a subclass to take specific actions at the end ofeach prefix mapping.",
	"Method": "void endPrefixMapping(String prefix){\r\n    if (DEBUG)\r\n        System.out.println(\"endPrefixMapping: prefix: \" + prefix);\r\n    if (null == prefix)\r\n        prefix = \"\";\r\n    int index = m_contextIndexes.peek() - 1;\r\n    do {\r\n        index = m_prefixMappings.indexOf(prefix, ++index);\r\n    } while ((index >= 0) && ((index & 0x01) == 0x01));\r\n    if (index > -1) {\r\n        m_prefixMappings.setElementAt(\"%@$#^@#\", index);\r\n        m_prefixMappings.setElementAt(\"%@$#^@#\", index + 1);\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.observer.generic.ObserverTest.testObserver",
	"Comment": "verify if the weather has the expected influence on the observer",
	"Method": "void testObserver(WeatherType weather,String response){\r\n    final O observer = this.factory.get();\r\n    assertEquals(0, appender.getLogSize());\r\n    observer.update(null, weather);\r\n    assertEquals(response, appender.getLastMessage());\r\n    assertEquals(1, appender.getLogSize());\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.StepPattern.calcTargetString",
	"Comment": "calculate the local name or psuedo name of the node that this pattern will test,for hash table lookup optimization.",
	"Method": "void calcTargetString(){\r\n    int whatToShow = getWhatToShow();\r\n    switch(whatToShow) {\r\n        case DTMFilter.SHOW_COMMENT:\r\n            m_targetString = PsuedoNames.PSEUDONAME_COMMENT;\r\n            break;\r\n        case DTMFilter.SHOW_TEXT:\r\n        case DTMFilter.SHOW_CDATA_SECTION:\r\n        case (DTMFilter.SHOW_TEXT | DTMFilter.SHOW_CDATA_SECTION):\r\n            m_targetString = PsuedoNames.PSEUDONAME_TEXT;\r\n            break;\r\n        case DTMFilter.SHOW_ALL:\r\n            m_targetString = PsuedoNames.PSEUDONAME_ANY;\r\n            break;\r\n        case DTMFilter.SHOW_DOCUMENT:\r\n        case DTMFilter.SHOW_DOCUMENT | DTMFilter.SHOW_DOCUMENT_FRAGMENT:\r\n            m_targetString = PsuedoNames.PSEUDONAME_ROOT;\r\n            break;\r\n        case DTMFilter.SHOW_ELEMENT:\r\n            if (this.WILD == m_name)\r\n                m_targetString = PsuedoNames.PSEUDONAME_ANY;\r\n            else\r\n                m_targetString = m_name;\r\n            break;\r\n        default:\r\n            m_targetString = PsuedoNames.PSEUDONAME_ANY;\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.QName.isXMLNSDecl",
	"Comment": "this function tells if a raw attribute name is axmlns attribute.",
	"Method": "boolean isXMLNSDecl(String attRawName){\r\n    return (attRawName.startsWith(\"xmlns\") && (attRawName.equals(\"xmlns\") || attRawName.startsWith(\"xmlns:\")));\r\n}"
}, {
	"Path": "org.apache.xpath.operations.Equals.bool",
	"Comment": "execute a binary operation by calling execute on each of the operands,and then calling the operate method on the derived class.",
	"Method": "boolean bool(XPathContext xctxt){\r\n    XObject left = m_left.execute(xctxt, true);\r\n    XObject right = m_right.execute(xctxt, true);\r\n    boolean result = left.equals(right) ? true : false;\r\n    left.detach();\r\n    right.detach();\r\n    return result;\r\n}"
}, {
	"Path": "hudson.node_monitors.AbstractNodeMonitorDescriptor.markOnline",
	"Comment": "utility method to mark the computer online for derived classes.",
	"Method": "boolean markOnline(Computer c){\r\n    if (isIgnored() || c.isOnline())\r\n        return false;\r\n    c.setTemporarilyOffline(false, null);\r\n    return true;\r\n}"
}, {
	"Path": "hudson.model.QueueTest.recover_from_legacy_list",
	"Comment": "make sure the queue can be reconstructed from a list queue.xml.prior to the queue.state class, the queue items were just persisted as a list.",
	"Method": "void recover_from_legacy_list(){\r\n    Queue q = r.jenkins.getQueue();\r\n    assertEquals(1, q.getItems().length);\r\n    assertEquals(3, Queue.WaitingItem.getCurrentCounterValue());\r\n}"
}, {
	"Path": "com.iluwatar.promise.App.calculateLowestFrequencyChar",
	"Comment": "calculate the lowest frequency character and when that promise is fulfilled,consume the result in a consumer",
	"Method": "void calculateLowestFrequencyChar(){\r\n    lowestFrequencyChar().thenAccept(charFrequency -> {\r\n        LOGGER.info(\"Char with lowest frequency is: {}\", charFrequency);\r\n        taskCompleted();\r\n    });\r\n}"
}, {
	"Path": "org.apache.xalan.templates.TemplateList.insertAssociationIntoList",
	"Comment": "insert the given templatesubpatternassociation into the the linkedlist.sort by import precedence, then priority, then by document order.",
	"Method": "TemplateSubPatternAssociation insertAssociationIntoList(TemplateSubPatternAssociation head,TemplateSubPatternAssociation item,boolean isWildCardInsert){\r\n    double priority = getPriorityOrScore(item);\r\n    double workPriority;\r\n    int importLevel = item.getImportLevel();\r\n    int docOrder = item.getDocOrderPos();\r\n    TemplateSubPatternAssociation insertPoint = head;\r\n    TemplateSubPatternAssociation next;\r\n    boolean insertBefore;\r\n    while (true) {\r\n        next = insertPoint.getNext();\r\n        if (null == next)\r\n            break;\r\n        else {\r\n            workPriority = getPriorityOrScore(next);\r\n            if (importLevel > next.getImportLevel())\r\n                break;\r\n            else if (importLevel < next.getImportLevel())\r\n                insertPoint = next;\r\n            else if (priority > workPriority)\r\n                break;\r\n            else if (priority < workPriority)\r\n                insertPoint = next;\r\n            else if (docOrder >= next.getDocOrderPos())\r\n                break;\r\n            else\r\n                insertPoint = next;\r\n        }\r\n    }\r\n    if ((null == next) || (insertPoint == head)) {\r\n        workPriority = getPriorityOrScore(insertPoint);\r\n        if (importLevel > insertPoint.getImportLevel())\r\n            insertBefore = true;\r\n        else if (importLevel < insertPoint.getImportLevel())\r\n            insertBefore = false;\r\n        else if (priority > workPriority)\r\n            insertBefore = true;\r\n        else if (priority < workPriority)\r\n            insertBefore = false;\r\n        else if (docOrder >= insertPoint.getDocOrderPos())\r\n            insertBefore = true;\r\n        else\r\n            insertBefore = false;\r\n    } else\r\n        insertBefore = false;\r\n    if (isWildCardInsert) {\r\n        if (insertBefore) {\r\n            item.setNext(insertPoint);\r\n            String key = insertPoint.getTargetString();\r\n            item.setTargetString(key);\r\n            putHead(key, item);\r\n            return item;\r\n        } else {\r\n            item.setNext(next);\r\n            insertPoint.setNext(item);\r\n            return head;\r\n        }\r\n    } else {\r\n        if (insertBefore) {\r\n            item.setNext(insertPoint);\r\n            if (insertPoint.isWild() || item.isWild())\r\n                m_wildCardPatterns = item;\r\n            else\r\n                putHead(item.getTargetString(), item);\r\n            return item;\r\n        } else {\r\n            item.setNext(next);\r\n            insertPoint.setNext(item);\r\n            return head;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprIteratorSimple.callPredicateVisitors",
	"Comment": "this will traverse the heararchy, calling the visitor for each member.if the called visitor method returns false, the subtree should not be called.",
	"Method": "void callPredicateVisitors(XPathVisitor visitor){\r\n    m_expr.callVisitors(new filterExprOwner(), visitor);\r\n    super.callPredicateVisitors(visitor);\r\n}"
}, {
	"Path": "jenkins.install.SetupWizard.getPlatformPluginList",
	"Comment": "gets the suggested plugin list from the update sites, falling back to a local version",
	"Method": "JSONArray getPlatformPluginList(){\r\n    Jenkins.get().checkPermission(Jenkins.ADMINISTER);\r\n    JSONArray initialPluginList = null;\r\n    updateSiteList: for (UpdateSite updateSite : Jenkins.get().getUpdateCenter().getSiteList()) {\r\n        String updateCenterJsonUrl = updateSite.getUrl();\r\n        String suggestedPluginUrl = updateCenterJsonUrl.replace(\"/update-center.json\", \"/platform-plugins.json\");\r\n        try {\r\n            URLConnection connection = ProxyConfiguration.open(new URL(suggestedPluginUrl));\r\n            try {\r\n                if (connection instanceof HttpURLConnection) {\r\n                    int responseCode = ((HttpURLConnection) connection).getResponseCode();\r\n                    if (HttpURLConnection.HTTP_OK != responseCode) {\r\n                        throw new HttpRetryException(\"Invalid response code (\" + responseCode + \") from URL: \" + suggestedPluginUrl, responseCode);\r\n                    }\r\n                }\r\n                String initialPluginJson = IOUtils.toString(connection.getInputStream(), \"utf-8\");\r\n                initialPluginList = JSONArray.fromObject(initialPluginJson);\r\n                break updateSiteList;\r\n            } catch (Exception e) {\r\n                LOGGER.log(Level.FINE, e.getMessage(), e);\r\n                continue updateSiteList;\r\n            }\r\n        } catch (Exception e) {\r\n            LOGGER.log(Level.FINE, e.getMessage(), e);\r\n        }\r\n    }\r\n    if (initialPluginList == null) {\r\n        try {\r\n            ClassLoader cl = getClass().getClassLoader();\r\n            URL localPluginData = cl.getResource(\"jenkins/install/platform-plugins.json\");\r\n            String initialPluginJson = IOUtils.toString(localPluginData.openStream(), \"utf-8\");\r\n            initialPluginList = JSONArray.fromObject(initialPluginJson);\r\n        } catch (Exception e) {\r\n            LOGGER.log(Level.SEVERE, e.getMessage(), e);\r\n        }\r\n    }\r\n    return initialPluginList;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.OutputProperties.getQNameProperties",
	"Comment": "searches for the list of qname properties with the specified key inthe property list.if the key is not found in this property list, the default property list,and its defaults, recursively, are then checked. the method returnsnull if the property is not found.",
	"Method": "Vector getQNameProperties(QName key,Vector getQNameProperties,String key,Vector getQNameProperties,String key,Properties props){\r\n    String s = props.getProperty(key);\r\n    if (null != s) {\r\n        Vector v = new Vector();\r\n        int l = s.length();\r\n        boolean inCurly = false;\r\n        FastStringBuffer buf = new FastStringBuffer();\r\n        for (int i = 0; i < l; i++) {\r\n            char c = s.charAt(i);\r\n            if (Character.isWhitespace(c)) {\r\n                if (!inCurly) {\r\n                    if (buf.length() > 0) {\r\n                        QName qname = QName.getQNameFromString(buf.toString());\r\n                        v.addElement(qname);\r\n                        buf.reset();\r\n                    }\r\n                    continue;\r\n                }\r\n            } else if ('{' == c)\r\n                inCurly = true;\r\n            else if ('}' == c)\r\n                inCurly = false;\r\n            buf.append(c);\r\n        }\r\n        if (buf.length() > 0) {\r\n            QName qname = QName.getQNameFromString(buf.toString());\r\n            v.addElement(qname);\r\n            buf.reset();\r\n        }\r\n        return v;\r\n    } else\r\n        return null;\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.getConfiguredParent",
	"Comment": "gets the parent as has been specified in the constructor or viasetparent.",
	"Method": "ClassLoader getConfiguredParent(){\r\n    return parent;\r\n}"
}, {
	"Path": "org.apache.xalan.extensions.ExtensionsTable.get",
	"Comment": "get an extensionhandler object that represents thegiven namespace.",
	"Method": "ExtensionHandler get(String extns){\r\n    return (ExtensionHandler) m_extensionFunctionNamespaces.get(extns);\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.doScriptText",
	"Comment": "run arbitrary groovy script and return result as plain text.",
	"Method": "void doScriptText(StaplerRequest req,StaplerResponse rsp){\r\n    _doScript(req, rsp, req.getView(this, \"_scriptText.jelly\"), FilePath.localChannel, getACL());\r\n}"
}, {
	"Path": "hudson.PluginWrapper.hasUpdate",
	"Comment": "returns true if this plugin has update in the update center.this method is conservative in the sense that if the version number is incomprehensible,it always returns false.",
	"Method": "boolean hasUpdate(){\r\n    return getUpdateInfo() != null;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.XMLChar.isContent",
	"Comment": "returns true if the specified character can be considered content.",
	"Method": "boolean isContent(int c){\r\n    return (c < 0x10000 && (CHARS[c] & MASK_CONTENT) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "com.iluwatar.reactor.framework.SameThreadDispatcher.onChannelReadEvent",
	"Comment": "dispatches the read event in the context of caller thread. note this is a blocking call. it returns only after the associated handler has handled the readevent.",
	"Method": "void onChannelReadEvent(AbstractNioChannel channel,Object readObject,SelectionKey key){\r\n    channel.getHandler().handleChannelRead(channel, readObject, key);\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.getCertificates",
	"Comment": "get the certificates for a given jar entry, if it is indeed a jar.",
	"Method": "Certificate[] getCertificates(File container,String entry){\r\n    if (container.isDirectory()) {\r\n        return null;\r\n    }\r\n    JarFile jarFile = (JarFile) jarFiles.get(container);\r\n    if (jarFile == null) {\r\n        return null;\r\n    }\r\n    JarEntry ent = jarFile.getJarEntry(entry);\r\n    return ent == null ? null : ent.getCertificates();\r\n}"
}, {
	"Path": "hudson.Functions.getCheckUrl",
	"Comment": "determines the form validation check url. see textbox.jelly",
	"Method": "String getCheckUrl(String userDefined,Object descriptor,String field){\r\n    if (userDefined != null || field == null)\r\n        return userDefined;\r\n    if (descriptor instanceof Descriptor) {\r\n        Descriptor d = (Descriptor) descriptor;\r\n        return d.getCheckUrl(field);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.XSLTAttributeDef.getSetterMethodName",
	"Comment": "return a string that should represent the setter method.the setter method name will be created algorithmically thefirst time this method is accessed, and then cached for returnby subsequent invocations of this method.",
	"Method": "String getSetterMethodName(){\r\n    if (null == m_setterString) {\r\n        if (m_foreignAttr == this) {\r\n            return S_FOREIGNATTR_SETTER;\r\n        } else if (m_name.equals(\"*\")) {\r\n            m_setterString = \"addLiteralResultAttribute\";\r\n            return m_setterString;\r\n        }\r\n        StringBuffer outBuf = new StringBuffer();\r\n        outBuf.append(\"set\");\r\n        if ((m_namespace != null) && m_namespace.equals(Constants.S_XMLNAMESPACEURI)) {\r\n            outBuf.append(\"Xml\");\r\n        }\r\n        int n = m_name.length();\r\n        for (int i = 0; i < n; i++) {\r\n            char c = m_name.charAt(i);\r\n            if ('-' == c) {\r\n                i++;\r\n                c = m_name.charAt(i);\r\n                c = Character.toUpperCase(c);\r\n            } else if (0 == i) {\r\n                c = Character.toUpperCase(c);\r\n            }\r\n            outBuf.append(c);\r\n        }\r\n        m_setterString = outBuf.toString();\r\n    }\r\n    return m_setterString;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.DOMErrorHandlerImpl.handleError",
	"Comment": "implementation of domerrorhandler.handleerror thatadds copy of error to list for later retrieval.",
	"Method": "boolean handleError(DOMError error){\r\n    boolean fail = true;\r\n    String severity = null;\r\n    if (error.getSeverity() == DOMError.SEVERITY_WARNING) {\r\n        fail = false;\r\n        severity = \"[Warning]\";\r\n    } else if (error.getSeverity() == DOMError.SEVERITY_ERROR) {\r\n        severity = \"[Error]\";\r\n    } else if (error.getSeverity() == DOMError.SEVERITY_FATAL_ERROR) {\r\n        severity = \"[Fatal Error]\";\r\n    }\r\n    System.err.println(severity + \": \" + error.getMessage() + \"\\t\");\r\n    System.err.println(\"Type : \" + error.getType() + \"\\t\" + \"Related Data: \" + error.getRelatedData() + \"\\t\" + \"Related Exception: \" + error.getRelatedException());\r\n    return fail;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.FuncDocument.checkNumberArgs",
	"Comment": "overide the superclass method to allow one or two arguments.",
	"Method": "void checkNumberArgs(int argNum){\r\n    if ((argNum < 1) || (argNum > 2))\r\n        reportWrongNumberArgs();\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.maven.JibPluginConfiguration.getUser",
	"Comment": "gets the username or uid which the process in the container should run as.",
	"Method": "String getUser(){\r\n    if (System.getProperty(PropertyNames.CONTAINER_USER) != null) {\r\n        return System.getProperty(PropertyNames.CONTAINER_USER);\r\n    }\r\n    return container.user;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.configuration.DockerHealthCheck.getInterval",
	"Comment": "gets the optional healthcheck interval. a missing command means that it will be inherited fromthe base image.",
	"Method": "Optional<Duration> getInterval(){\r\n    return Optional.ofNullable(interval);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.findElementFromIndex",
	"Comment": "find the first matching element from the index at or after thegiven node.",
	"Method": "int findElementFromIndex(int nsIndex,int lnIndex,int firstPotential){\r\n    int[][][] indexes = m_elemIndexes;\r\n    if (null != indexes && nsIndex < indexes.length) {\r\n        int[][] lnIndexs = indexes[nsIndex];\r\n        if (null != lnIndexs && lnIndex < lnIndexs.length) {\r\n            int[] elems = lnIndexs[lnIndex];\r\n            if (null != elems) {\r\n                int pos = findGTE(elems, 1, elems[0], firstPotential);\r\n                if (pos > -1) {\r\n                    return elems[pos];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return NOTPROCESSED;\r\n}"
}, {
	"Path": "hudson.search.Search.find",
	"Comment": "performs a search and returns the match, or null if no match was foundor more than one match was found.",
	"Method": "SuggestedItem find(SearchIndex index,String query,SuggestedItem find,SearchIndex index,String query,SearchableModelObject searchContext,List<SuggestedItem> find,Mode m,SearchIndex index,String tokenList,SearchableModelObject searchContext){\r\n    TokenList tokens = new TokenList(tokenList);\r\n    if (tokens.length() == 0)\r\n        return Collections.emptyList();\r\n    List<SuggestedItem>[] paths = new List[tokens.length() + 1];\r\n    for (int i = 1; i <= tokens.length(); i++) paths[i] = new ArrayList<SuggestedItem>();\r\n    List<SearchItem> items = new ArrayList<SearchItem>();\r\n    LOGGER.log(Level.FINE, \"tokens={0}\", tokens);\r\n    int w = 1;\r\n    for (String token : tokens.subSequence(0)) {\r\n        items.clear();\r\n        m.find(index, token, items);\r\n        for (SearchItem si : items) {\r\n            paths[w].add(SuggestedItem.build(searchContext, si));\r\n            LOGGER.log(Level.FINE, \"found search item: {0}\", si.getSearchName());\r\n        }\r\n        w++;\r\n    }\r\n    for (int j = 1; j < tokens.length(); j++) {\r\n        w = 1;\r\n        for (String token : tokens.subSequence(j)) {\r\n            for (SuggestedItem r : paths[j]) {\r\n                items.clear();\r\n                m.find(r.item.getSearchIndex(), token, items);\r\n                for (SearchItem i : items) paths[j + w].add(new SuggestedItem(r, i));\r\n            }\r\n            w++;\r\n        }\r\n    }\r\n    return paths[tokens.length()];\r\n}"
}, {
	"Path": "com.iluwatar.business.delegate.BusinessDelegateTest.setup",
	"Comment": "this method sets up the instance variables of this test class. it is executed before theexecution of every test.",
	"Method": "void setup(){\r\n    ejbService = spy(new EjbService());\r\n    jmsService = spy(new JmsService());\r\n    businessLookup = spy(new BusinessLookup());\r\n    businessLookup.setEjbService(ejbService);\r\n    businessLookup.setJmsService(jmsService);\r\n    businessDelegate = spy(new BusinessDelegate());\r\n    businessDelegate.setLookupService(businessLookup);\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.api.JibContainerBuilder.addVolume",
	"Comment": "adds a directory that may hold an externally mounted volume.",
	"Method": "JibContainerBuilder addVolume(AbsoluteUnixPath volume){\r\n    containerConfigurationBuilder.addVolume(volume);\r\n    return this;\r\n}"
}, {
	"Path": "org.apache.xml.utils.SuballocatedIntVector.indexOf",
	"Comment": "searches for the first occurence of the given argument,beginning the search at index, and testing for equalityusing the equals method.",
	"Method": "int indexOf(int elem,int index,int indexOf,int elem){\r\n    return indexOf(elem, 0);\r\n}"
}, {
	"Path": "org.apache.xml.utils.IntVector.lastIndexOf",
	"Comment": "searches for the first occurence of the given argument,beginning the search at index, and testing for equalityusing the equals method.",
	"Method": "int lastIndexOf(int elem){\r\n    for (int i = (m_firstFree - 1); i >= 0; i--) {\r\n        if (m_map[i] == elem)\r\n            return i;\r\n    }\r\n    return java.lang.Integer.MIN_VALUE;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.LSSerializerImpl.setFilter",
	"Comment": "set a lsserilizerfilter on the lsserializer.when set, the filter iscalled before each node is serialized which depending on its implementiondetermines if the node is to be serialized or not.",
	"Method": "void setFilter(LSSerializerFilter filter){\r\n    fSerializerFilter = filter;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.OutputProperties.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.Version.getMaintenanceVersionNum",
	"Comment": "maintenance drop number.optional identifier used to designate maintenance drop applied to a specific release and contains fixes for defects reported. it maintains compatibility with the release and contains no api changes. when missing, it designates the final and complete development drop for a release.",
	"Method": "int getMaintenanceVersionNum(){\r\n    return 1;\r\n}"
}, {
	"Path": "hudson.util.ChunkedOutputStream.close",
	"Comment": "finishes writing to the underlying stream, but does not close the underlying stream.",
	"Method": "void close(){\r\n    finish();\r\n    super.close();\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ObjectFactory.findClassLoader",
	"Comment": "figure out which classloader to use.for jdk 1.2 and later usethe context classloader.",
	"Method": "ClassLoader findClassLoader(){\r\n    SecuritySupport ss = SecuritySupport.getInstance();\r\n    ClassLoader context = ss.getContextClassLoader();\r\n    ClassLoader system = ss.getSystemClassLoader();\r\n    ClassLoader chain = system;\r\n    while (true) {\r\n        if (context == chain) {\r\n            ClassLoader current = ObjectFactory.class.getClassLoader();\r\n            chain = system;\r\n            while (true) {\r\n                if (current == chain) {\r\n                    return system;\r\n                }\r\n                if (chain == null) {\r\n                    break;\r\n                }\r\n                chain = ss.getParentClassLoader(chain);\r\n            }\r\n            return current;\r\n        }\r\n        if (chain == null) {\r\n            break;\r\n        }\r\n        chain = ss.getParentClassLoader(chain);\r\n    }\r\n    ;\r\n    return context;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemApplyTemplates.setIsDefaultTemplate",
	"Comment": "set if this belongs to a default template,in which case it will act different withregard to processing modes.",
	"Method": "void setIsDefaultTemplate(boolean b){\r\n    m_isDefaultTemplate = b;\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.FluentIterable.copyToList",
	"Comment": "utility method that iterates over iterable and adds the contents to a list.",
	"Method": "List<E> copyToList(Iterable<E> iterable){\r\n    List<E> copy = new ArrayList();\r\n    Iterator<E> iterator = iterable.iterator();\r\n    while (iterator.hasNext()) {\r\n        copy.add(iterator.next());\r\n    }\r\n    return copy;\r\n}"
}, {
	"Path": "hudson.console.ConsoleAnnotatorFactory.doScriptJs",
	"Comment": "serves the javascript file associated with this console annotator factory.",
	"Method": "void doScriptJs(StaplerRequest req,StaplerResponse rsp){\r\n    rsp.serveFile(req, getResource(\"/script.js\"), TimeUnit.DAYS.toMillis(1));\r\n}"
}, {
	"Path": "hudson.security.SecurityRealm.getSecurityComponents",
	"Comment": "use this function to get the security components, without necessarilyrecreating them.",
	"Method": "SecurityComponents getSecurityComponents(){\r\n    if (this.securityComponents == null) {\r\n        this.securityComponents = this.createSecurityComponents();\r\n    }\r\n    return this.securityComponents;\r\n}"
}, {
	"Path": "com.iluwatar.bridge.SwordTest.testSword",
	"Comment": "invoke all possible actions on the weapon and check if the actions are executed on the actualunderlying weapon implementation.",
	"Method": "void testSword(){\r\n    final Sword sword = spy(new Sword(mock(FlyingEnchantment.class)));\r\n    testBasicWeaponActions(sword);\r\n}"
}, {
	"Path": "hudson.security.csrf.CrumbIssuer.validateCrumb",
	"Comment": "validate a previously created crumb against information in the current request.",
	"Method": "boolean validateCrumb(ServletRequest request,boolean validateCrumb,ServletRequest request,MultipartFormDataParser parser,boolean validateCrumb,ServletRequest request,String salt,String crumb){\r\n    CrumbIssuerDescriptor<CrumbIssuer> desc = getDescriptor();\r\n    String crumbField = desc.getCrumbRequestField();\r\n    String crumbSalt = desc.getCrumbSalt();\r\n    return validateCrumb(request, crumbSalt, parser.get(crumbField));\r\n}"
}, {
	"Path": "org.apache.xpath.XPath.bool",
	"Comment": "given an expression and a context, evaluate the xpathand return the result.",
	"Method": "boolean bool(XPathContext xctxt,int contextNode,PrefixResolver namespaceContext){\r\n    xctxt.pushNamespaceContext(namespaceContext);\r\n    xctxt.pushCurrentNodeAndExpression(contextNode, contextNode);\r\n    try {\r\n        return m_mainExp.bool(xctxt);\r\n    } catch (TransformerException te) {\r\n        te.setLocator(this.getLocator());\r\n        ErrorListener el = xctxt.getErrorListener();\r\n        if (null != el) {\r\n            el.error(te);\r\n        } else\r\n            throw te;\r\n    } catch (Exception e) {\r\n        while (e instanceof org.apache.xml.utils.WrappedRuntimeException) {\r\n            e = ((org.apache.xml.utils.WrappedRuntimeException) e).getException();\r\n        }\r\n        String msg = e.getMessage();\r\n        if (msg == null || msg.length() == 0) {\r\n            msg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_XPATH_ERROR, null);\r\n        }\r\n        TransformerException te = new TransformerException(msg, getLocator(), e);\r\n        ErrorListener el = xctxt.getErrorListener();\r\n        if (null != el) {\r\n            el.fatalError(te);\r\n        } else\r\n            throw te;\r\n    } finally {\r\n        xctxt.popNamespaceContext();\r\n        xctxt.popCurrentNodeAndExpression();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.iluwatar.queue.load.leveling.ServiceExecutor.run",
	"Comment": "the serviceexecutor thread will retrieve each message and process it.",
	"Method": "void run(){\r\n    try {\r\n        while (!Thread.currentThread().isInterrupted()) {\r\n            Message msg = msgQueue.retrieveMsg();\r\n            if (null != msg) {\r\n                LOGGER.info(msg.toString() + \" is served.\");\r\n            } else {\r\n                LOGGER.info(\"Service Executor: Waiting for Messages to serve .. \");\r\n            }\r\n            Thread.sleep(1000);\r\n        }\r\n    } catch (Exception e) {\r\n        LOGGER.error(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.tls.DateFormatCallableTestMultiThread.testCounterExceptions",
	"Comment": "test number of exceptions in the list after the run of dateformatrunnalbe. a correct run should deliver no exceptions",
	"Method": "void testCounterExceptions(){\r\n    for (int i = 0; i < result.length; i++) {\r\n        assertEquals(expectedCounterExceptions, result[i].getExceptionList().size());\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemCallTemplate.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n    int length = getParamElemCount();\r\n    for (int i = 0; i < length; i++) {\r\n        ElemWithParam ewp = getParamElem(i);\r\n        ewp.compose(sroot);\r\n    }\r\n    if ((null != m_templateName) && (null == m_template)) {\r\n        m_template = this.getStylesheetRoot().getTemplateComposed(m_templateName);\r\n        if (null == m_template) {\r\n            String themsg = XSLMessages.createMessage(XSLTErrorResources.ER_ELEMTEMPLATEELEM_ERR, new Object[] { m_templateName });\r\n            throw new TransformerException(themsg, this);\r\n        }\r\n        length = getParamElemCount();\r\n        for (int i = 0; i < length; i++) {\r\n            ElemWithParam ewp = getParamElem(i);\r\n            ewp.m_index = -1;\r\n            int etePos = 0;\r\n            for (ElemTemplateElement ete = m_template.getFirstChildElem(); null != ete; ete = ete.getNextSiblingElem()) {\r\n                if (ete.getXSLToken() == Constants.ELEMNAME_PARAMVARIABLE) {\r\n                    ElemParam ep = (ElemParam) ete;\r\n                    if (ep.getName().equals(ewp.getName())) {\r\n                        ewp.m_index = etePos;\r\n                    }\r\n                } else\r\n                    break;\r\n                etePos++;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.squareup.javapoet.LineWrapper.close",
	"Comment": "flush any outstanding text and forbid future writes to this line wrapper.",
	"Method": "void close(){\r\n    if (nextFlush != null)\r\n        flush(nextFlush);\r\n    closed = true;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.notationDecl",
	"Comment": "receive notification of a notation declaration.by default, do nothing.application writers may override thismethod in a subclass if they wish to keep track of the notationsdeclared in a document.",
	"Method": "void notationDecl(String name,String publicId,String systemId){\r\n    getCurrentProcessor().notationDecl(this, name, publicId, systemId);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.VarNameCollector.doesOccur",
	"Comment": "tell if the given qualified name occurs in \tthe list of qualified names collected.",
	"Method": "boolean doesOccur(QName refName){\r\n    return m_refs.contains(refName);\r\n}"
}, {
	"Path": "hudson.model.ProjectTest.testUnrestrictedJobNoLabelByCloudNoQueue",
	"Comment": "job is restricted, but label can not be provided by any cloud, only normal slaves. then job will not submit, because no slave is available.",
	"Method": "void testUnrestrictedJobNoLabelByCloudNoQueue(){\r\n    assertTrue(j.jenkins.clouds.isEmpty());\r\n    Slave s1 = j.createOnlineSlave();\r\n    FreeStyleProject proj = j.createFreeStyleProject(\"JENKINS-21394-noqueue\");\r\n    proj.setAssignedLabel(s1.getSelfLabel());\r\n    RequiresWorkspaceSCM requiresWorkspaceScm = new RequiresWorkspaceSCM(true);\r\n    proj.setScm(requiresWorkspaceScm);\r\n    j.buildAndAssertSuccess(proj);\r\n    Slave s2 = j.createSlave();\r\n    proj.setAssignedLabel(s2.getSelfLabel());\r\n    requiresWorkspaceScm.hasChange = true;\r\n    PollingResult pr = proj.poll(j.createTaskListener());\r\n    assertFalse(pr.hasChanges());\r\n    SCMTrigger t = new SCMTrigger(\"@daily\", true);\r\n    t.start(proj, true);\r\n    proj.addTrigger(t);\r\n    t.new Runner().run();\r\n    HtmlPage log = j.createWebClient().getPage(proj, \"scmPollLog\");\r\n    String logastext = log.asText();\r\n    assertTrue(logastext.contains(\"(\" + AbstractProject.WorkspaceOfflineReason.all_suitable_nodes_are_offline.name() + \")\"));\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.CountersTable.getCounters",
	"Comment": "get the list of counters that corresponds tothe given elemnumber object.",
	"Method": "Vector getCounters(ElemNumber numberElem){\r\n    Vector counters = (Vector) this.get(numberElem);\r\n    return (null == counters) ? putElemNumber(numberElem) : counters;\r\n}"
}, {
	"Path": "org.apache.xml.utils.QName.getPrefixFromXMLNSDecl",
	"Comment": "this function tells if a raw attribute name is axmlns attribute.",
	"Method": "String getPrefixFromXMLNSDecl(String attRawName){\r\n    int index = attRawName.indexOf(':');\r\n    return (index >= 0) ? attRawName.substring(index + 1) : \"\";\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.api.JibContainerBuilder.setVolumes",
	"Comment": "sets the directories that may hold externally mounted volumes.",
	"Method": "JibContainerBuilder setVolumes(Set<AbsoluteUnixPath> volumes,JibContainerBuilder setVolumes,AbsoluteUnixPath volumes){\r\n    return setVolumes(new HashSet(Arrays.asList(volumes)));\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetComposed.isAggregatedType",
	"Comment": "tell if this can be cast to a stylesheetcomposed, meaning, youcan ask questions from getxxxcomposed functions.",
	"Method": "boolean isAggregatedType(){\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.Stylesheet.getStylesheetComposed",
	"Comment": "get the owning aggregated stylesheet, or thisstylesheet if it is aggregated.",
	"Method": "StylesheetComposed getStylesheetComposed(){\r\n    Stylesheet sheet = this;\r\n    while (!sheet.isAggregatedType()) {\r\n        sheet = sheet.getStylesheetParent();\r\n    }\r\n    return (StylesheetComposed) sheet;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprIterator.getNextNode",
	"Comment": "get the next node via getnextxxx.bottlenecked for derived class override.",
	"Method": "int getNextNode(){\r\n    if (null != m_exprObj) {\r\n        m_lastFetched = m_exprObj.nextNode();\r\n    } else\r\n        m_lastFetched = DTM.NULL;\r\n    return m_lastFetched;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemExtensionCall.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n    m_extns = this.getNamespace();\r\n    m_decl = getElemExtensionDecl(sroot, m_extns);\r\n    if (m_decl == null)\r\n        sroot.getExtensionNamespacesManager().registerExtension(m_extns);\r\n}"
}, {
	"Path": "hudson.model.AbstractProject.setQuietPeriod",
	"Comment": "sets the custom quiet period of this project, or revert to the global default if null is given.",
	"Method": "void setQuietPeriod(Integer seconds){\r\n    this.quietPeriod = seconds;\r\n    save();\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMAxisIterNodeList.item",
	"Comment": "returns the indexth item in the collection. if index is greater than or equal to the number of nodes in the list, this returns null.",
	"Method": "Node item(int index){\r\n    if (m_iter != null) {\r\n        int node;\r\n        int count = m_cachedNodes.size();\r\n        if (count > index) {\r\n            node = m_cachedNodes.elementAt(index);\r\n            return m_dtm.getNode(node);\r\n        } else if (m_last == -1) {\r\n            while (((node = m_iter.next()) != DTMAxisIterator.END) && count <= index) {\r\n                m_cachedNodes.addElement(node);\r\n                count++;\r\n            }\r\n            if (node == DTMAxisIterator.END) {\r\n                m_last = count;\r\n            } else {\r\n                return m_dtm.getNode(node);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "jenkins.slaves.RemotingWorkDirSettings.isUseAgentRootDir",
	"Comment": "indicates that agent root directory should be used as work directory.",
	"Method": "boolean isUseAgentRootDir(){\r\n    return workDirPath == null;\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XStringForFSB.getChars",
	"Comment": "copies characters from this string into the destination characterarray.",
	"Method": "void getChars(int srcBegin,int srcEnd,char dst,int dstBegin){\r\n    int n = srcEnd - srcBegin;\r\n    if (n > m_length)\r\n        n = m_length;\r\n    if (n > (dst.length - dstBegin))\r\n        n = (dst.length - dstBegin);\r\n    int end = srcBegin + m_start + n;\r\n    int d = dstBegin;\r\n    FastStringBuffer fsb = fsb();\r\n    for (int i = srcBegin + m_start; i < end; i++) {\r\n        dst[d++] = fsb.charAt(i);\r\n    }\r\n}"
}, {
	"Path": "hudson.model.AsyncAperiodicWork.getLogFile",
	"Comment": "determines the log file that records the result of this task.",
	"Method": "File getLogFile(){\r\n    return new File(getLogsRoot(), \"/tasks/\" + name + \".log\");\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.tar.TarStreamBuilder.writeEntriesAsTarArchive",
	"Comment": "writes each entry in the filesystem to the tarball archive stream.",
	"Method": "void writeEntriesAsTarArchive(OutputStream tarByteStream){\r\n    try (TarArchiveOutputStream tarArchiveOutputStream = new TarArchiveOutputStream(tarByteStream, StandardCharsets.UTF_8.name())) {\r\n        tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);\r\n        for (Map.Entry<TarArchiveEntry, Blob> entry : archiveMap.entrySet()) {\r\n            tarArchiveOutputStream.putArchiveEntry(entry.getKey());\r\n            entry.getValue().writeTo(tarArchiveOutputStream);\r\n            tarArchiveOutputStream.closeArchiveEntry();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.reactor.framework.AbstractNioChannel.flush",
	"Comment": "called from the context of reactor thread when the key becomes writable. the channel writes thewhole pending block of data at once.",
	"Method": "void flush(SelectionKey key){\r\n    Queue<Object> pendingWrites = channelToPendingWrites.get(key.channel());\r\n    while (true) {\r\n        Object pendingWrite = pendingWrites.poll();\r\n        if (pendingWrite == null) {\r\n            reactor.changeOps(key, SelectionKey.OP_READ);\r\n            break;\r\n        }\r\n        doWrite(pendingWrite, key);\r\n    }\r\n}"
}, {
	"Path": "redis.clients.jedis.BinaryJedis.auth",
	"Comment": "request for authentication in a password protected redis server. a redis server can beinstructed to require a password before to allow clients to issue commands. this is done usingthe requirepass directive in the redis configuration file. if the password given by the clientis correct the server replies with an ok status code reply and starts accepting commands fromthe client. otherwise an error is returned and the clients needs to try a new password. notethat for the high performance nature of redis it is possible to try a lot of passwords inparallel in very short time, so make sure to generate a strong and very long password so thatthis attack is infeasible.",
	"Method": "String auth(String password){\r\n    checkIsInMultiOrPipeline();\r\n    client.auth(password);\r\n    return client.getStatusCodeReply();\r\n}"
}, {
	"Path": "ciphers.AES.mixColumnsDec",
	"Comment": "applies the inverse rijndael mixcolumns for decryption to the input and\treturns the result.",
	"Method": "BigInteger mixColumnsDec(BigInteger ciphertext){\r\n    int[] cells = splitBlockIntoCells(ciphertext);\r\n    int[] outputCells = new int[16];\r\n    for (int i = 0; i < 4; i++) {\r\n        int[] row = { cells[i * 4], cells[i * 4 + 1], cells[i * 4 + 2], cells[i * 4 + 3] };\r\n        outputCells[i * 4] = MULT14[row[0]] ^ MULT11[row[1]] ^ MULT13[row[2]] ^ MULT9[row[3]];\r\n        outputCells[i * 4 + 1] = MULT9[row[0]] ^ MULT14[row[1]] ^ MULT11[row[2]] ^ MULT13[row[3]];\r\n        outputCells[i * 4 + 2] = MULT13[row[0]] ^ MULT9[row[1]] ^ MULT14[row[2]] ^ MULT11[row[3]];\r\n        outputCells[i * 4 + 3] = MULT11[row[0]] ^ MULT13[row[1]] ^ MULT9[row[2]] ^ MULT14[row[3]];\r\n    }\r\n    return mergeCellsIntoBlock(outputCells);\r\n}"
}, {
	"Path": "org.apache.xpath.res.XPATHErrorResources.getResourceSuffix",
	"Comment": "return the resource file suffic for the indicated localefor most locales, this will be based the language code.howeverfor chinese, we do distinguish between taiwan and prc",
	"Method": "String getResourceSuffix(Locale locale){\r\n    String suffix = \"_\" + locale.getLanguage();\r\n    String country = locale.getCountry();\r\n    if (country.equals(\"TW\"))\r\n        suffix += \"_\" + country;\r\n    return suffix;\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.getJDK",
	"Comment": "gets the jdk installation of the given name, or returns null.",
	"Method": "JDK getJDK(String name){\r\n    if (name == null) {\r\n        List<JDK> jdks = getJDKs();\r\n        if (jdks.size() == 1)\r\n            return jdks.get(0);\r\n        return null;\r\n    }\r\n    for (JDK j : getJDKs()) {\r\n        if (j.getName().equals(name))\r\n            return j;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "hudson.cli.DisablePluginCommandTest.canDisableDependentPluginWrongOrderStrategyAll",
	"Comment": "can disable a plugin with a mandatory dependent plugin before its dependent plugin withstrategy",
	"Method": "void canDisableDependentPluginWrongOrderStrategyAll(){\r\n    assertThat(disablePluginsCLiCommand(\"dependee\", \"mandatory-depender\", \"-strategy\", \"all\"), succeeded());\r\n    assertPluginDisabled(\"mandatory-depender\");\r\n    assertPluginDisabled(\"dependee\");\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ObjectFactory.findJarServiceProviderName",
	"Comment": "find the name of service provider using jar service provider mechanism",
	"Method": "String findJarServiceProviderName(String factoryId){\r\n    SecuritySupport ss = SecuritySupport.getInstance();\r\n    String serviceId = SERVICES_PATH + factoryId;\r\n    InputStream is = null;\r\n    ClassLoader cl = findClassLoader();\r\n    is = ss.getResourceAsStream(cl, serviceId);\r\n    if (is == null) {\r\n        ClassLoader current = ObjectFactory.class.getClassLoader();\r\n        if (cl != current) {\r\n            cl = current;\r\n            is = ss.getResourceAsStream(cl, serviceId);\r\n        }\r\n    }\r\n    if (is == null) {\r\n        return null;\r\n    }\r\n    debugPrintln(\"found jar resource=\" + serviceId + \" using ClassLoader: \" + cl);\r\n    BufferedReader rd;\r\n    try {\r\n        rd = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n    } catch (java.io.UnsupportedEncodingException e) {\r\n        rd = new BufferedReader(new InputStreamReader(is));\r\n    }\r\n    String factoryClassName = null;\r\n    try {\r\n        factoryClassName = rd.readLine();\r\n    } catch (IOException x) {\r\n        return null;\r\n    } finally {\r\n        try {\r\n            rd.close();\r\n        } catch (IOException exc) {\r\n        }\r\n    }\r\n    if (factoryClassName != null && !\"\".equals(factoryClassName)) {\r\n        debugPrintln(\"found in resource, value=\" + factoryClassName);\r\n        return factoryClassName;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.ExtendedType.equals",
	"Comment": "test if this extendedtype object is equal to the given extendedtype.",
	"Method": "boolean equals(ExtendedType other){\r\n    try {\r\n        return other.nodetype == this.nodetype && other.localName.equals(this.localName) && other.namespace.equals(this.namespace);\r\n    } catch (NullPointerException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.documentIsEmpty",
	"Comment": "return true if nothing has been sent to this result tree yet.this is not a public api.",
	"Method": "boolean documentIsEmpty(){\r\n    return m_docIsEmpty && (m_elemContext.m_currentElemDepth == 0);\r\n}"
}, {
	"Path": "com.iluwatar.hexagonal.mongo.MongoConnectionPropertiesLoader.load",
	"Comment": "try to load connection properties from file.fall back to default connection properties.",
	"Method": "void load(){\r\n    String host = DEFAULT_HOST;\r\n    int port = DEFAULT_PORT;\r\n    String path = System.getProperty(\"hexagonal.properties.path\");\r\n    Properties properties = new Properties();\r\n    if (path != null) {\r\n        try (FileInputStream fin = new FileInputStream(path)) {\r\n            properties.load(fin);\r\n            host = properties.getProperty(\"mongo-host\");\r\n            port = Integer.parseInt(properties.getProperty(\"mongo-port\"));\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    System.setProperty(\"mongo-host\", host);\r\n    System.setProperty(\"mongo-port\", String.format(\"%d\", port));\r\n}"
}, {
	"Path": "hudson.model.queue.WorkUnit.getExecutable",
	"Comment": "if the execution has already started, return the executable that was created.",
	"Method": "Executable getExecutable(){\r\n    return executable;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerIdentityImpl.endPrefixMapping",
	"Comment": "receive notification of the end of a namespace mapping.by default, do nothing.application writers may override thismethod in a subclass to take specific actions at the end ofeach prefix mapping.",
	"Method": "void endPrefixMapping(String prefix){\r\n    flushStartDoc();\r\n    m_resultContentHandler.endPrefixMapping(prefix);\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.lazy.LazyFluentIterable.last",
	"Comment": "can be used to collect objects from the iterable. is a terminating operation. this operation ismemory intensive, because the contents of this iterable are collected into a list, when thenext object is requested.",
	"Method": "Optional<E> last(FluentIterable<E> last,int count){\r\n    return new LazyFluentIterable<E>() {\r\n        @Override\r\n        public Iterator<E> iterator() {\r\n            return new DecoratingIterator<E>(iterable.iterator()) {\r\n                private int stopIndex;\r\n                private int totalElementsCount;\r\n                private List<E> list;\r\n                private int currentIndex;\r\n                @Override\r\n                public E computeNext() {\r\n                    initialize();\r\n                    E candidate = null;\r\n                    while (currentIndex < stopIndex && fromIterator.hasNext()) {\r\n                        currentIndex++;\r\n                        fromIterator.next();\r\n                    }\r\n                    if (currentIndex >= stopIndex && fromIterator.hasNext()) {\r\n                        candidate = fromIterator.next();\r\n                    }\r\n                    return candidate;\r\n                }\r\n                private void initialize() {\r\n                    if (list == null) {\r\n                        list = new ArrayList();\r\n                        Iterator<E> newIterator = iterable.iterator();\r\n                        while (newIterator.hasNext()) {\r\n                            list.add(newIterator.next());\r\n                        }\r\n                        totalElementsCount = list.size();\r\n                        stopIndex = totalElementsCount - count;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.lazy.LazyFluentIterable.last",
	"Comment": "can be used to collect objects from the iterable. is a terminating operation. this operation ismemory intensive, because the contents of this iterable are collected into a list, when thenext object is requested.",
	"Method": "Optional<E> last(FluentIterable<E> last,int count){\r\n    return new DecoratingIterator<E>(iterable.iterator()) {\r\n        private int stopIndex;\r\n        private int totalElementsCount;\r\n        private List<E> list;\r\n        private int currentIndex;\r\n        @Override\r\n        public E computeNext() {\r\n            initialize();\r\n            E candidate = null;\r\n            while (currentIndex < stopIndex && fromIterator.hasNext()) {\r\n                currentIndex++;\r\n                fromIterator.next();\r\n            }\r\n            if (currentIndex >= stopIndex && fromIterator.hasNext()) {\r\n                candidate = fromIterator.next();\r\n            }\r\n            return candidate;\r\n        }\r\n        private void initialize() {\r\n            if (list == null) {\r\n                list = new ArrayList();\r\n                Iterator<E> newIterator = iterable.iterator();\r\n                while (newIterator.hasNext()) {\r\n                    list.add(newIterator.next());\r\n                }\r\n                totalElementsCount = list.size();\r\n                stopIndex = totalElementsCount - count;\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.lazy.LazyFluentIterable.last",
	"Comment": "can be used to collect objects from the iterable. is a terminating operation. this operation ismemory intensive, because the contents of this iterable are collected into a list, when thenext object is requested.",
	"Method": "Optional<E> last(FluentIterable<E> last,int count){\r\n    initialize();\r\n    E candidate = null;\r\n    while (currentIndex < stopIndex && fromIterator.hasNext()) {\r\n        currentIndex++;\r\n        fromIterator.next();\r\n    }\r\n    if (currentIndex >= stopIndex && fromIterator.hasNext()) {\r\n        candidate = fromIterator.next();\r\n    }\r\n    return candidate;\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.lazy.LazyFluentIterable.last",
	"Comment": "can be used to collect objects from the iterable. is a terminating operation. this operation ismemory intensive, because the contents of this iterable are collected into a list, when thenext object is requested.",
	"Method": "Optional<E> last(FluentIterable<E> last,int count){\r\n    if (list == null) {\r\n        list = new ArrayList();\r\n        Iterator<E> newIterator = iterable.iterator();\r\n        while (newIterator.hasNext()) {\r\n            list.add(newIterator.next());\r\n        }\r\n        totalElementsCount = list.size();\r\n        stopIndex = totalElementsCount - count;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.operations.Operation.execute",
	"Comment": "execute a binary operation by calling execute on each of the operands,and then calling the operate method on the derived class.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    XObject left = m_left.execute(xctxt, true);\r\n    XObject right = m_right.execute(xctxt, true);\r\n    XObject result = operate(left, right);\r\n    left.detach();\r\n    right.detach();\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.cloneWithReset",
	"Comment": "get a cloned iterator, and reset its state to the beginning of theiteration.",
	"Method": "DTMIterator cloneWithReset(){\r\n    NodeSetDTM clone = (NodeSetDTM) clone();\r\n    clone.reset();\r\n    return clone;\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.doEval",
	"Comment": "evaluates the jelly script submitted by the client.this is useful for system administration as well as unit testing.",
	"Method": "void doEval(StaplerRequest req,StaplerResponse rsp){\r\n    checkPermission(RUN_SCRIPTS);\r\n    try {\r\n        MetaClass mc = WebApp.getCurrent().getMetaClass(getClass());\r\n        Script script = mc.classLoader.loadTearOff(JellyClassLoaderTearOff.class).createContext().compileScript(new InputSource(req.getReader()));\r\n        new JellyRequestDispatcher(this, script).forward(req, rsp);\r\n    } catch (JellyException e) {\r\n        throw new ServletException(e);\r\n    }\r\n}"
}, {
	"Path": "hudson.cli.CLI.close",
	"Comment": "shuts down the channel and closes the underlying connection.",
	"Method": "void close(){\r\n    channel.close();\r\n    channel.join();\r\n    if (ownsPool)\r\n        pool.shutdown();\r\n    for (Closeable c : closables) c.close();\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.getStylesheetRoot",
	"Comment": "return the stylesheet root that this handler is constructing.",
	"Method": "StylesheetRoot getStylesheetRoot(){\r\n    if (m_stylesheetRoot != null) {\r\n        m_stylesheetRoot.setOptimizer(m_optimize);\r\n        m_stylesheetRoot.setIncremental(m_incremental);\r\n        m_stylesheetRoot.setSource_location(m_source_location);\r\n    }\r\n    return m_stylesheetRoot;\r\n}"
}, {
	"Path": "org.apache.xpath.XPath.assertion",
	"Comment": "tell the user of an assertion error, and probably throw anexception.",
	"Method": "void assertion(boolean b,String msg){\r\n    if (!b) {\r\n        String fMsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION, new Object[] { msg });\r\n        throw new RuntimeException(fMsg);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.pushImportSource",
	"Comment": "push the source of an import href onto the stylesheet stack,obtained from a uriresolver, null if there is no uriresolver,or if that resolver returned null.",
	"Method": "void pushImportSource(Source sourceFromURIResolver){\r\n    m_importSourceStack.push(sourceFromURIResolver);\r\n}"
}, {
	"Path": "org.apache.xpath.functions.Function.reportWrongNumberArgs",
	"Comment": "constructs and throws a wrongnumberargexception with the appropriatemessage for this function object.this method is meant to be overloadedby derived classes so that the message will be as specific as possible.",
	"Method": "void reportWrongNumberArgs(){\r\n    throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(\"zero\", null));\r\n}"
}, {
	"Path": "hudson.console.ConsoleAnnotatorFactory.hasScript",
	"Comment": "returns true if this descriptor has a javascript to be inserted on applicable console page.",
	"Method": "boolean hasScript(){\r\n    return getResource(\"/script.js\") != null;\r\n}"
}, {
	"Path": "hudson.Functions.reverse",
	"Comment": "reverses a collection so that it can be easily walked in reverse order.",
	"Method": "Iterable<T> reverse(Collection<T> collection){\r\n    List<T> list = new ArrayList<T>(collection);\r\n    Collections.reverse(list);\r\n    return list;\r\n}"
}, {
	"Path": "hudson.widgets.BuildHistoryWidget.getQueuedItem",
	"Comment": "returns the first queue item if the owner is scheduled for execution in the queue.",
	"Method": "Item getQueuedItem(){\r\n    return Jenkins.getInstance().getQueue().getItem(owner);\r\n}"
}, {
	"Path": "com.iluwatar.command.CommandTest.testCommand",
	"Comment": "this test verifies that when the wizard casts spells on the goblin. the wizard keeps track ofthe previous spells cast, so it is easy to undo them. in addition, it also verifies that thewizard keeps track of the spells undone, so they can be redone.",
	"Method": "void testCommand(){\r\n    Wizard wizard = new Wizard();\r\n    Goblin goblin = new Goblin();\r\n    wizard.castSpell(new ShrinkSpell(), goblin);\r\n    verifyGoblin(goblin, GOBLIN, Size.SMALL, Visibility.VISIBLE);\r\n    wizard.castSpell(new InvisibilitySpell(), goblin);\r\n    verifyGoblin(goblin, GOBLIN, Size.SMALL, Visibility.INVISIBLE);\r\n    wizard.undoLastSpell();\r\n    verifyGoblin(goblin, GOBLIN, Size.SMALL, Visibility.VISIBLE);\r\n    wizard.undoLastSpell();\r\n    verifyGoblin(goblin, GOBLIN, Size.NORMAL, Visibility.VISIBLE);\r\n    wizard.redoLastSpell();\r\n    verifyGoblin(goblin, GOBLIN, Size.SMALL, Visibility.VISIBLE);\r\n    wizard.redoLastSpell();\r\n    verifyGoblin(goblin, GOBLIN, Size.SMALL, Visibility.INVISIBLE);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetRoot.canStripWhiteSpace",
	"Comment": "get information about whether or not whitespace can be stripped.",
	"Method": "boolean canStripWhiteSpace(){\r\n    return (null != m_whiteSpaceInfoList);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.isAbsolute",
	"Comment": "tell if the given locpathiterator is relative to an absolute path, i.e. in not dependent on the context.",
	"Method": "boolean isAbsolute(LocPathIterator path){\r\n    int analysis = path.getAnalysisBits();\r\n    boolean isAbs = (WalkerFactory.isSet(analysis, WalkerFactory.BIT_ROOT) || WalkerFactory.isSet(analysis, WalkerFactory.BIT_ANY_DESCENDANT_FROM_ROOT));\r\n    if (isAbs) {\r\n        isAbs = m_absPathChecker.checkAbsolute(path);\r\n    }\r\n    return isAbs;\r\n}"
}, {
	"Path": "hudson.model.Queue.makeFlyWeightTaskBuildable",
	"Comment": "this method checks if the flyweight task can be run on any of the available executors",
	"Method": "Runnable makeFlyWeightTaskBuildable(BuildableItem p){\r\n    if (p.task instanceof FlyweightTask) {\r\n        Jenkins h = Jenkins.getInstance();\r\n        Label lbl = p.getAssignedLabel();\r\n        if (lbl != null && lbl.equals(h.getSelfLabel())) {\r\n            if (h.canTake(p) == null) {\r\n                return createFlyWeightTaskRunnable(p, h.toComputer());\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        Map<Node, Integer> hashSource = new HashMap<Node, Integer>(h.getNodes().size());\r\n        hashSource.put(h, Math.max(h.getNumExecutors() * 100, 1));\r\n        for (Node n : h.getNodes()) {\r\n            hashSource.put(n, n.getNumExecutors() * 100);\r\n        }\r\n        ConsistentHash<Node> hash = new ConsistentHash<Node>(NODE_HASH);\r\n        hash.addAll(hashSource);\r\n        String fullDisplayName = p.task.getFullDisplayName();\r\n        for (Node n : hash.list(fullDisplayName)) {\r\n            final Computer c = n.toComputer();\r\n            if (c == null || c.isOffline()) {\r\n                continue;\r\n            }\r\n            if (lbl != null && !lbl.contains(n)) {\r\n                continue;\r\n            }\r\n            if (n.canTake(p) != null) {\r\n                continue;\r\n            }\r\n            return createFlyWeightTaskRunnable(p, c);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "hudson.model.ManagementLink.getRequiresConfirmation",
	"Comment": "allows implementations to request that this link show a confirmation dialog, and use post if confirmed.suitable for links which perform an action rather than simply displaying a page.",
	"Method": "boolean getRequiresConfirmation(){\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.findNamespaceContext",
	"Comment": "retrieve list of namespace declaration locationsactive at this node. list is an suballocatedintvector whoseentries are the namespace node handles declared at that id.%review% directly managed arrays rather than vectors?%review% handles or ids? given usage, i think handles.",
	"Method": "SuballocatedIntVector findNamespaceContext(int elementNodeIndex){\r\n    if (null != m_namespaceDeclSetElements) {\r\n        int wouldBeAt = findInSortedSuballocatedIntVector(m_namespaceDeclSetElements, elementNodeIndex);\r\n        if (wouldBeAt >= 0)\r\n            return (SuballocatedIntVector) m_namespaceDeclSets.elementAt(wouldBeAt);\r\n        if (wouldBeAt == -1)\r\n            return null;\r\n        wouldBeAt = -1 - wouldBeAt;\r\n        int candidate = m_namespaceDeclSetElements.elementAt(--wouldBeAt);\r\n        int ancestor = _parent(elementNodeIndex);\r\n        if (wouldBeAt == 0 && candidate < ancestor) {\r\n            int rootHandle = getDocumentRoot(makeNodeHandle(elementNodeIndex));\r\n            int rootID = makeNodeIdentity(rootHandle);\r\n            int uppermostNSCandidateID;\r\n            if (getNodeType(rootHandle) == DTM.DOCUMENT_NODE) {\r\n                int ch = _firstch(rootID);\r\n                uppermostNSCandidateID = (ch != DTM.NULL) ? ch : rootID;\r\n            } else {\r\n                uppermostNSCandidateID = rootID;\r\n            }\r\n            if (candidate == uppermostNSCandidateID) {\r\n                return (SuballocatedIntVector) m_namespaceDeclSets.elementAt(wouldBeAt);\r\n            }\r\n        }\r\n        while (wouldBeAt >= 0 && ancestor > 0) {\r\n            if (candidate == ancestor) {\r\n                return (SuballocatedIntVector) m_namespaceDeclSets.elementAt(wouldBeAt);\r\n            } else if (candidate < ancestor) {\r\n                do {\r\n                    ancestor = _parent(ancestor);\r\n                } while (candidate < ancestor);\r\n            } else if (wouldBeAt > 0) {\r\n                candidate = m_namespaceDeclSetElements.elementAt(--wouldBeAt);\r\n            } else\r\n                break;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "hudson.model.FreestyleJobPublisherTest.testFreestyleWithIOExceptionPublisher",
	"Comment": "execute all publishers even one of them throws any exceptions.",
	"Method": "void testFreestyleWithIOExceptionPublisher(){\r\n    FreeStyleProject p = j.createFreeStyleProject();\r\n    p.getPublishersList().add(new TrueFalsePublisher(true));\r\n    p.getPublishersList().add(new IOExceptionPublisher());\r\n    p.getPublishersList().add(new ResultWriterPublisher(\"result.txt\"));\r\n    final ArtifactArchiver artifactArchiver = new ArtifactArchiver(\"result.txt\");\r\n    artifactArchiver.setOnlyIfSuccessful(false);\r\n    p.getPublishersList().add(artifactArchiver);\r\n    FreeStyleBuild b = p.scheduleBuild2(0).get();\r\n    assertEquals(\"Build must fail, because we used FalsePublisher\", b.getResult(), Result.FAILURE);\r\n    j.assertLogContains(\"\\tat hudson.model.utils.IOExceptionPublisher\", b);\r\n    j.assertLogContains(\"Threw IOException from publisher!\", b);\r\n    File file = new File(b.getArtifactsDir(), \"result.txt\");\r\n    assertTrue(\"ArtifactArchiver is executed even prior publisher fails\", file.exists());\r\n    assertTrue(\"Third publisher must see FAILURE status\", FileUtils.readFileToString(file).equals(Result.FAILURE.toString()));\r\n}"
}, {
	"Path": "hudson.model.ParametersAction.substitute",
	"Comment": "performs a variable substitution to the given text and return it.",
	"Method": "String substitute(AbstractBuild<?, ?> build,String text){\r\n    return Util.replaceMacro(text, createVariableResolver(build));\r\n}"
}, {
	"Path": "hudson.FilePath.writeToTar",
	"Comment": "writes to a tar stream and stores obtained files to the base dir.",
	"Method": "Integer writeToTar(File baseDir,DirScanner scanner,OutputStream out){\r\n    Archiver tw = ArchiverFactory.TAR.create(out);\r\n    try {\r\n        scanner.scan(baseDir, reading(tw));\r\n    } finally {\r\n        tw.close();\r\n    }\r\n    return tw.countEntries();\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncTranslate.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    String theFirstString = m_arg0.execute(xctxt).str();\r\n    String theSecondString = m_arg1.execute(xctxt).str();\r\n    String theThirdString = m_arg2.execute(xctxt).str();\r\n    int theFirstStringLength = theFirstString.length();\r\n    int theThirdStringLength = theThirdString.length();\r\n    StringBuffer sbuffer = new StringBuffer();\r\n    for (int i = 0; i < theFirstStringLength; i++) {\r\n        char theCurrentChar = theFirstString.charAt(i);\r\n        int theIndex = theSecondString.indexOf(theCurrentChar);\r\n        if (theIndex < 0) {\r\n            sbuffer.append(theCurrentChar);\r\n        } else if (theIndex < theThirdStringLength) {\r\n            sbuffer.append(theThirdString.charAt(theIndex));\r\n        } else {\r\n        }\r\n    }\r\n    return new XString(sbuffer.toString());\r\n}"
}, {
	"Path": "com.iluwatar.balking.WashingMachine.endOfWashing",
	"Comment": "method responsible of ending the washingby changing machine state",
	"Method": "void endOfWashing(){\r\n    washingMachineState = WashingMachineState.ENABLED;\r\n    LOGGER.info(\"{}: Washing completed.\", Thread.currentThread().getId());\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToHTMLStream.makeHHString",
	"Comment": "make an integer into an hh hex value.does no checking on the size of the input, since this is only meant to be used locally by writeattruri.",
	"Method": "String makeHHString(int i){\r\n    String s = Integer.toHexString(i).toUpperCase();\r\n    if (s.length() == 1) {\r\n        s = \"0\" + s;\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.gradle.SingleProjectIntegrationTest.assertDockerInspect",
	"Comment": "asserts that the test project has the required exposed ports, labels and volumes.",
	"Method": "void assertDockerInspect(String imageReference){\r\n    String dockerInspect = new Command(\"docker\", \"inspect\", imageReference).run();\r\n    Assert.assertThat(dockerInspect, CoreMatchers.containsString(\"            \\\"Volumes\\\": {\\n\" + \"                \\\"/var/log\\\": {},\\n\" + \"                \\\"/var/log2\\\": {}\\n\" + \"            },\"));\r\n    Assert.assertThat(dockerInspect, CoreMatchers.containsString(\"            \\\"ExposedPorts\\\": {\\n\" + \"                \\\"1000/tcp\\\": {},\\n\" + \"                \\\"2000/udp\\\": {},\\n\" + \"                \\\"2001/udp\\\": {},\\n\" + \"                \\\"2002/udp\\\": {},\\n\" + \"                \\\"2003/udp\\\": {}\"));\r\n    Assert.assertThat(dockerInspect, CoreMatchers.containsString(\"            \\\"Labels\\\": {\\n\" + \"                \\\"key1\\\": \\\"value1\\\",\\n\" + \"                \\\"key2\\\": \\\"value2\\\"\\n\" + \"            }\"));\r\n}"
}, {
	"Path": "hudson.model.NodeTest.testGetAssignedLabelMultipleSlaves",
	"Comment": "create two projects which have the same label and verify that both are accounted for when getting a countof the jobs tied to the current label.",
	"Method": "void testGetAssignedLabelMultipleSlaves(){\r\n    final Node node1 = j.createOnlineSlave();\r\n    node1.setLabelString(\"label1\");\r\n    final Node node2 = j.createOnlineSlave();\r\n    node1.setLabelString(\"label1\");\r\n    MavenModuleSet project = j.jenkins.createProject(MavenModuleSet.class, \"p1\");\r\n    final Label label = j.jenkins.getLabel(\"label1\");\r\n    project.setAssignedLabel(label);\r\n    j.assertBuildStatus(Result.FAILURE, project.scheduleBuild2(0).get());\r\n    MavenModuleSet project2 = j.jenkins.createProject(MavenModuleSet.class, \"p2\");\r\n    project2.setAssignedLabel(label);\r\n    j.assertBuildStatus(Result.FAILURE, project2.scheduleBuild2(0).get());\r\n    label.reset();\r\n    assertEquals(\"Two jobs should be tied to this label.\", 2, label.getTiedJobCount());\r\n}"
}, {
	"Path": "com.iluwatar.command.CommandTest.verifyGoblin",
	"Comment": "this method asserts that the passed goblin object has the name as expectedname, size asexpectedsize and visibility as expectedvisibility.",
	"Method": "void verifyGoblin(Goblin goblin,String expectedName,Size expectedSize,Visibility expectedVisibility){\r\n    assertEquals(expectedName, goblin.toString(), \"Goblin's name must be same as expectedName\");\r\n    assertEquals(expectedSize, goblin.getSize(), \"Goblin's size must be same as expectedSize\");\r\n    assertEquals(expectedVisibility, goblin.getVisibility(), \"Goblin's visibility must be same as expectedVisibility\");\r\n}"
}, {
	"Path": "org.apache.xml.utils.SuballocatedIntVector.lastIndexOf",
	"Comment": "searches for the first occurence of the given argument,beginning the search at index, and testing for equalityusing the equals method.",
	"Method": "int lastIndexOf(int elem){\r\n    int boffset = m_firstFree & m_MASK;\r\n    for (int index = m_firstFree >>> m_SHIFT; index >= 0; --index) {\r\n        int[] block = m_map[index];\r\n        if (block != null)\r\n            for (int offset = boffset; offset >= 0; --offset) if (block[offset] == elem)\r\n                return offset + index * m_blocksize;\r\n        boffset = 0;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "hudson.util.BootFailure.loadAttempts",
	"Comment": "parses the boot attempt file carefully so as not to cause the entire hook script to fail to execute.",
	"Method": "List<Date> loadAttempts(File home){\r\n    List<Date> dates = new ArrayList<Date>();\r\n    if (home != null) {\r\n        File f = getBootFailureFile(home);\r\n        try {\r\n            if (f.exists()) {\r\n                try (BufferedReader failureFileReader = new BufferedReader(new FileReader(f))) {\r\n                    String line;\r\n                    while ((line = failureFileReader.readLine()) != null) {\r\n                        try {\r\n                            dates.add(new Date(line));\r\n                        } catch (Exception e) {\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            LOGGER.log(Level.WARNING, \"Failed to parse \" + f, e);\r\n        }\r\n    }\r\n    return dates;\r\n}"
}, {
	"Path": "org.apache.xpath.res.XPATHMessages.createXPATHMessage",
	"Comment": "creates a message from the specified key and replacementarguments, localized to the given locale.",
	"Method": "String createXPATHMessage(String msgKey,Object args){\r\n    return createXPATHMsg(XPATHBundle, msgKey, args);\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.COM.Helper.extractClasspathFileToReal",
	"Comment": "extract data contained in classpath into a system accessible target file.",
	"Method": "void extractClasspathFileToReal(String localPath,File target){\r\n    InputStream is = null;\r\n    OutputStream os = null;\r\n    try {\r\n        is = Helper.class.getResourceAsStream(localPath);\r\n        os = new FileOutputStream(target);\r\n        int read;\r\n        byte[] buffer = new byte[20480];\r\n        while ((read = is.read(buffer)) > 0) {\r\n            os.write(buffer, 0, read);\r\n        }\r\n    } finally {\r\n        if (is != null) {\r\n            try {\r\n                is.close();\r\n            } catch (Exception ex) {\r\n            }\r\n        }\r\n        if (os != null) {\r\n            try {\r\n                os.close();\r\n            } catch (Exception ex) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.axes.NodeSequence.hasCache",
	"Comment": "if the iterator needs to cache nodes as they are fetched,then this method returns true.",
	"Method": "boolean hasCache(){\r\n    final NodeVector nv = getVector();\r\n    return (nv != null);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.XMLChar.isValidJavaEncoding",
	"Comment": "returns true if the encoding name is a valid java encoding.this method does not verify that there is a decoder availablefor this encoding, only that the characters are valid for anjava encoding name.",
	"Method": "boolean isValidJavaEncoding(String javaEncoding){\r\n    if (javaEncoding != null) {\r\n        int length = javaEncoding.length();\r\n        if (length > 0) {\r\n            for (int i = 1; i < length; i++) {\r\n                char c = javaEncoding.charAt(i);\r\n                if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') && (c < '0' || c > '9') && c != '.' && c != '_' && c != '-') {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "hudson.util.ProcessTree.get",
	"Comment": "gets the process given a specific id, or null if no such process exists.",
	"Method": "OSProcess get(int pid,OSProcess get,Process proc,ProcessTree get,OSProcess get,Process proc,OSProcess get,Process proc,OSProcess get,Process proc){\r\n    if (!enabled)\r\n        return DEFAULT;\r\n    if (vetoersExist == null) {\r\n        try {\r\n            VirtualChannel channelToMaster = SlaveComputer.getChannelToMaster();\r\n            if (channelToMaster != null) {\r\n                vetoersExist = channelToMaster.call(new DoVetoersExist());\r\n            }\r\n        } catch (Exception e) {\r\n            LOGGER.log(Level.WARNING, \"Error while determining if vetoers exist\", e);\r\n        }\r\n    }\r\n    boolean vetoes = (vetoersExist == null ? true : vetoersExist);\r\n    try {\r\n        if (File.pathSeparatorChar == ';')\r\n            return new Windows(vetoes);\r\n        String os = Util.fixNull(System.getProperty(\"os.name\"));\r\n        if (os.equals(\"Linux\"))\r\n            return new Linux(vetoes);\r\n        if (os.equals(\"AIX\"))\r\n            return new AIX(vetoes);\r\n        if (os.equals(\"SunOS\"))\r\n            return new Solaris(vetoes);\r\n        if (os.equals(\"Mac OS X\"))\r\n            return new Darwin(vetoes);\r\n    } catch (LinkageError e) {\r\n        LOGGER.log(Level.WARNING, \"Failed to load winp. Reverting to the default\", e);\r\n        enabled = false;\r\n    }\r\n    return DEFAULT;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemWithParam.appendChild",
	"Comment": "add a child to the child list. if the select attributeis present, an error will be raised.",
	"Method": "ElemTemplateElement appendChild(ElemTemplateElement elem){\r\n    if (m_selectPattern != null) {\r\n        error(XSLTErrorResources.ER_CANT_HAVE_CONTENT_AND_SELECT, new Object[] { \"xsl:\" + this.getNodeName() });\r\n        return null;\r\n    }\r\n    return super.appendChild(elem);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.findGTE",
	"Comment": "find the first index that occurs in the list that is greater than orequal to the given value.",
	"Method": "int findGTE(int[] list,int start,int len,int value){\r\n    int low = start;\r\n    int high = start + (len - 1);\r\n    int end = high;\r\n    while (low <= high) {\r\n        int mid = (low + high) / 2;\r\n        int c = list[mid];\r\n        if (c > value)\r\n            high = mid - 1;\r\n        else if (c < value)\r\n            low = mid + 1;\r\n        else\r\n            return mid;\r\n    }\r\n    return (low <= end && list[low] > value) ? low : -1;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.builder.Timer.lap",
	"Comment": "captures the time since last lap or creation, and resets the start time.",
	"Method": "Duration lap(){\r\n    Instant now = clock.instant();\r\n    Duration duration = Duration.between(lapStartTime, now);\r\n    lapStartTime = now;\r\n    return duration;\r\n}"
}, {
	"Path": "hudson.model.UsageStatistics.getStatData",
	"Comment": "gets the encrypted usage stat data to be sent to the hudson server.",
	"Method": "String getStatData(){\r\n    Jenkins j = Jenkins.getInstance();\r\n    JSONObject o = new JSONObject();\r\n    o.put(\"stat\", 1);\r\n    o.put(\"install\", j.getLegacyInstanceId());\r\n    o.put(\"servletContainer\", j.servletContext.getServerInfo());\r\n    o.put(\"version\", Jenkins.VERSION);\r\n    List<JSONObject> nodes = new ArrayList<JSONObject>();\r\n    for (Computer c : j.getComputers()) {\r\n        JSONObject n = new JSONObject();\r\n        if (c.getNode() == j) {\r\n            n.put(\"master\", true);\r\n            n.put(\"jvm-vendor\", System.getProperty(\"java.vm.vendor\"));\r\n            n.put(\"jvm-name\", System.getProperty(\"java.vm.name\"));\r\n            n.put(\"jvm-version\", System.getProperty(\"java.version\"));\r\n        }\r\n        n.put(\"executors\", c.getNumExecutors());\r\n        DescriptorImpl descriptor = j.getDescriptorByType(DescriptorImpl.class);\r\n        n.put(\"os\", descriptor.get(c));\r\n        nodes.add(n);\r\n    }\r\n    o.put(\"nodes\", nodes);\r\n    List<JSONObject> plugins = new ArrayList<JSONObject>();\r\n    for (PluginWrapper pw : j.getPluginManager().getPlugins()) {\r\n        if (!pw.isActive())\r\n            continue;\r\n        JSONObject p = new JSONObject();\r\n        p.put(\"name\", pw.getShortName());\r\n        p.put(\"version\", pw.getVersion());\r\n        plugins.add(p);\r\n    }\r\n    o.put(\"plugins\", plugins);\r\n    JSONObject jobs = new JSONObject();\r\n    TopLevelItemDescriptor[] descriptors = Items.all().toArray(new TopLevelItemDescriptor[0]);\r\n    int[] counts = new int[descriptors.length];\r\n    for (TopLevelItem item : j.allItems(TopLevelItem.class)) {\r\n        TopLevelItemDescriptor d = item.getDescriptor();\r\n        for (int i = 0; i < descriptors.length; i++) {\r\n            if (d == descriptors[i]) {\r\n                counts[i]++;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < descriptors.length; i++) {\r\n        jobs.put(descriptors[i].getJsonSafeClassName(), counts[i]);\r\n    }\r\n    o.put(\"jobs\", jobs);\r\n    try {\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n        try (OutputStream cipheros = new CombinedCipherOutputStream(baos, getKey(), \"AES\");\r\n            OutputStream zipos = new GZIPOutputStream(cipheros);\r\n            OutputStreamWriter w = new OutputStreamWriter(zipos, \"UTF-8\")) {\r\n            o.write(w);\r\n        }\r\n        return new String(Base64.encode(baos.toByteArray()));\r\n    } catch (GeneralSecurityException e) {\r\n        throw new Error(e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprWalker.detach",
	"Comment": "detaches the walker from the set which it iterated over, releasingany computational resources and placing the iterator in the invalidstate.",
	"Method": "void detach(){\r\n    super.detach();\r\n    if (m_canDetachNodeset) {\r\n        m_exprObj.detach();\r\n    }\r\n    m_exprObj = null;\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.addLoaderPackageRoot",
	"Comment": "adds a package root to the list of packages which must be loaded usingthis loader.all subpackages are also included.",
	"Method": "void addLoaderPackageRoot(String packageRoot){\r\n    loaderPackages.addElement(packageRoot + (packageRoot.endsWith(\".\") ? \"\" : \".\"));\r\n}"
}, {
	"Path": "org.apache.xpath.operations.Operation.setLeftRight",
	"Comment": "set the left and right operand expressions for this operation.",
	"Method": "void setLeftRight(Expression l,Expression r){\r\n    m_left = l;\r\n    m_right = r;\r\n    l.exprSetParent(this);\r\n    r.exprSetParent(this);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.pushStylesheet",
	"Comment": "push the current stylesheet being constructed. if no other stylesheetshave been pushed onto the stack, assume the argument is a stylesheetroot, and also set the stylesheet root member.",
	"Method": "void pushStylesheet(Stylesheet s){\r\n    if (m_stylesheets.size() == 0)\r\n        m_stylesheetRoot = (StylesheetRoot) s;\r\n    m_stylesheets.push(s);\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.StepPattern.checkProximityPosition",
	"Comment": "new method to check whether the current node satisfies a position predicate",
	"Method": "boolean checkProximityPosition(XPathContext xctxt,int predPos,DTM dtm,int context,int pos){\r\n    try {\r\n        DTMAxisTraverser traverser = dtm.getAxisTraverser(Axis.PRECEDINGSIBLING);\r\n        for (int child = traverser.first(context); DTM.NULL != child; child = traverser.next(context, child)) {\r\n            try {\r\n                xctxt.pushCurrentNode(child);\r\n                if (NodeTest.SCORE_NONE != super.execute(xctxt, child)) {\r\n                    boolean pass = true;\r\n                    try {\r\n                        xctxt.pushSubContextList(this);\r\n                        for (int i = 0; i < predPos; i++) {\r\n                            xctxt.pushPredicatePos(i);\r\n                            try {\r\n                                XObject pred = m_predicates[i].execute(xctxt);\r\n                                try {\r\n                                    if (XObject.CLASS_NUMBER == pred.getType()) {\r\n                                        throw new Error(\"Why: Should never have been called\");\r\n                                    } else if (!pred.boolWithSideEffects()) {\r\n                                        pass = false;\r\n                                        break;\r\n                                    }\r\n                                } finally {\r\n                                    pred.detach();\r\n                                }\r\n                            } finally {\r\n                                xctxt.popPredicatePos();\r\n                            }\r\n                        }\r\n                    } finally {\r\n                        xctxt.popSubContextList();\r\n                    }\r\n                    if (pass)\r\n                        pos--;\r\n                    if (pos < 1)\r\n                        return false;\r\n                }\r\n            } finally {\r\n                xctxt.popCurrentNode();\r\n            }\r\n        }\r\n    } catch (javax.xml.transform.TransformerException se) {\r\n        throw new java.lang.RuntimeException(se.getMessage());\r\n    }\r\n    return (pos == 1);\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.OpMap.getNextOpPos",
	"Comment": "given an operation position, return the end position, i.e. thebeginning of the next operation.",
	"Method": "int getNextOpPos(int opPos,int getNextOpPos,int[] opMap,int opPos){\r\n    return opPos + opMap[opPos + 1];\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FunctionDef1Arg.getArg0AsNumber",
	"Comment": "execute the first argument expression that is expected to return anumber.if the argument is null, then get the number value from thecurrent context node.",
	"Method": "double getArg0AsNumber(XPathContext xctxt){\r\n    if (null == m_arg0) {\r\n        int currentNode = xctxt.getCurrentNode();\r\n        if (DTM.NULL == currentNode)\r\n            return 0;\r\n        else {\r\n            DTM dtm = xctxt.getDTM(currentNode);\r\n            XMLString str = dtm.getStringValue(currentNode);\r\n            return str.toDouble();\r\n        }\r\n    } else\r\n        return m_arg0.execute(xctxt).num();\r\n}"
}, {
	"Path": "hudson.XMLFileTest.silentlyMigrateConfigsTest",
	"Comment": "this test validates that xml v1.0 configs silently get migrated to xml v1.1 when they are persisted",
	"Method": "void silentlyMigrateConfigsTest(){\r\n    j.jenkins.save();\r\n    assertThat(j.jenkins.getLabelString(), is(\"I am a label\"));\r\n    File configFile = new File(j.jenkins.getRootDir(), \"config.xml\");\r\n    assertThat(configFile.exists(), is(true));\r\n    try (BufferedReader config = new BufferedReader(new FileReader(configFile))) {\r\n        assertThat(config.readLine(), is(\"<?xml version='1.1' encoding='UTF-8'?>\"));\r\n        config.close();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.TemplateSubPatternAssociation.getImportLevel",
	"Comment": "return the import level associated with the stylesheet into whichthis template is composed.",
	"Method": "int getImportLevel(){\r\n    return m_template.getStylesheetComposed().getImportCountComposed();\r\n}"
}, {
	"Path": "org.apache.xml.utils.SAXSourceLocator.getPublicId",
	"Comment": "return the public identifier for the current document event.the return value is the public identifier of the documententity or of the external parsed entity in which the markuptriggering the event appears.",
	"Method": "String getPublicId(){\r\n    return (null == m_locator) ? super.getPublicId() : m_locator.getPublicId();\r\n}"
}, {
	"Path": "hudson.util.StreamTaskListener.closeQuietly",
	"Comment": "closes this listener and swallows any exceptions, if raised.",
	"Method": "void closeQuietly(){\r\n    try {\r\n        close();\r\n    } catch (IOException e) {\r\n        LOGGER.log(Level.WARNING, \"Failed to close\", e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToSAXHandler.setTransformState",
	"Comment": "pass in a reference to a transformstate object, whichcan be used during sax contenthandler events to obtaininformation about he state of the transformation. thismethod will be calledbefore each startdocument event.",
	"Method": "void setTransformState(TransformStateSetter ts){\r\n    this.m_state = ts;\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLStringDefault.toUpperCase",
	"Comment": "converts all of the characters in this string to uppercase using the rules of the given locale.",
	"Method": "XMLString toUpperCase(Locale locale,XMLString toUpperCase){\r\n    return new XMLStringDefault(m_str.toUpperCase());\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.registry.RegistryAuthenticator.authenticate",
	"Comment": "sends the authentication request and retrieves the bearer authorization token.",
	"Method": "Authorization authenticate(String scope){\r\n    try {\r\n        URL authenticationUrl = getAuthenticationUrl(scope);\r\n        try (Connection connection = Connection.getConnectionFactory().apply(authenticationUrl)) {\r\n            Request.Builder requestBuilder = Request.builder().setHttpTimeout(JibSystemProperties.getHttpTimeout());\r\n            if (authorization != null) {\r\n                requestBuilder.setAuthorization(authorization);\r\n            }\r\n            Response response = connection.get(requestBuilder.build());\r\n            String responseString = Blobs.writeToString(response.getBody());\r\n            AuthenticationResponseTemplate responseJson = JsonTemplateMapper.readJson(responseString, AuthenticationResponseTemplate.class);\r\n            if (responseJson.getToken() == null) {\r\n                throw new RegistryAuthenticationFailedException(registryEndpointRequestProperties.getServerUrl(), registryEndpointRequestProperties.getImageName(), \"Did not get token in authentication response from \" + authenticationUrl);\r\n            }\r\n            return Authorizations.withBearerToken(responseJson.getToken());\r\n        }\r\n    } catch (IOException ex) {\r\n        throw new RegistryAuthenticationFailedException(registryEndpointRequestProperties.getServerUrl(), registryEndpointRequestProperties.getImageName(), ex);\r\n    }\r\n}"
}, {
	"Path": "hudson.model.AbstractItem.isNameEditable",
	"Comment": "controls whether the default rename action is available for this item.",
	"Method": "boolean isNameEditable(){\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.addOrReplaceDecls",
	"Comment": "add or replace this namespace declaration in listof namespaces in scope for this element.",
	"Method": "void addOrReplaceDecls(XMLNSDecl newDecl){\r\n    int n = m_prefixTable.size();\r\n    for (int i = n - 1; i >= 0; i--) {\r\n        XMLNSDecl decl = (XMLNSDecl) m_prefixTable.get(i);\r\n        if (decl.getPrefix().equals(newDecl.getPrefix())) {\r\n            return;\r\n        }\r\n    }\r\n    m_prefixTable.add(newDecl);\r\n}"
}, {
	"Path": "com.iluwatar.queue.load.leveling.MessageQueue.retrieveMsg",
	"Comment": "all the messages will be retrieved by the serviceexecutor by calling this method and process them.retrieves and removes the head of this queue, or returns null if this queue is empty.",
	"Method": "Message retrieveMsg(){\r\n    Message retrievedMsg = null;\r\n    try {\r\n        retrievedMsg = blkQueue.poll();\r\n    } catch (Exception e) {\r\n        LOGGER.error(e.getMessage());\r\n    }\r\n    return retrievedMsg;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.getPrefixResolver",
	"Comment": "return the saved reference to the prefix resolver thatwas in effect when this iterator was created.",
	"Method": "PrefixResolver getPrefixResolver(){\r\n    if (null == m_prefixResolver) {\r\n        m_prefixResolver = (PrefixResolver) getExpressionOwner();\r\n    }\r\n    return m_prefixResolver;\r\n}"
}, {
	"Path": "com.iluwatar.promise.Promise.fulfillExceptionally",
	"Comment": "fulfills the promise with exception due to error in execution.",
	"Method": "void fulfillExceptionally(Exception exception){\r\n    super.fulfillExceptionally(exception);\r\n    handleException(exception);\r\n    postFulfillment();\r\n}"
}, {
	"Path": "com.iluwatar.objectmother.RoyaltyObjectMother.createSoberUnhappyKing",
	"Comment": "method to create a sober and unhappy king. the standard parameters are set.",
	"Method": "King createSoberUnhappyKing(){\r\n    return new King();\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerIdentityImpl.getTransformer",
	"Comment": "get the transformer associated with this handler, whichis needed in order to set parameters and output properties.",
	"Method": "Transformer getTransformer(){\r\n    return this;\r\n}"
}, {
	"Path": "hudson.UtilTest.testEncodeSpaces",
	"Comment": "test that strings that contain spaces are correctly url encoded.",
	"Method": "void testEncodeSpaces(){\r\n    final String urlWithSpaces = \"http://hudson/job/Hudson Job\";\r\n    String encoded = Util.encode(urlWithSpaces);\r\n    assertEquals(encoded, \"http://hudson/job/Hudson Job\");\r\n}"
}, {
	"Path": "hudson.slaves.RetentionStrategy.isManualLaunchAllowed",
	"Comment": "this method is called to determine whether manual launching of the agent is allowed at this point in time.",
	"Method": "boolean isManualLaunchAllowed(T c){\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.setWriter",
	"Comment": "specifies a writer to which the document should be serialized.this method should not be called while the serializer is inthe process of serializing a document.",
	"Method": "void setWriter(Writer writer){\r\n    setWriterInternal(writer, true);\r\n}"
}, {
	"Path": "hudson.util.ChunkedOutputStream.flushCacheWithAppend",
	"Comment": "writes the cache and buffertoappend to the underlying streamas one large chunk",
	"Method": "void flushCacheWithAppend(byte bufferToAppend,int off,int len){\r\n    byte[] chunkHeader = (Integer.toHexString(cachePosition + len) + \"\\r\\n\").getBytes(\"US-ASCII\");\r\n    stream.write(chunkHeader, 0, chunkHeader.length);\r\n    stream.write(cache, 0, cachePosition);\r\n    stream.write(bufferToAppend, off, len);\r\n    stream.write(ENDCHUNK, 0, ENDCHUNK.length);\r\n    cachePosition = 0;\r\n}"
}, {
	"Path": "jenkins.util.Timer.get",
	"Comment": "returns the scheduled executor service used by all timed tasks in jenkins.",
	"Method": "ScheduledExecutorService get(){\r\n    if (executorService == null) {\r\n        executorService = new ImpersonatingScheduledExecutorService(new ErrorLoggingScheduledThreadPoolExecutor(10, new NamingThreadFactory(new ClassLoaderSanityThreadFactory(new DaemonThreadFactory()), \"jenkins.util.Timer\")), ACL.SYSTEM);\r\n    }\r\n    return executorService;\r\n}"
}, {
	"Path": "com.sun.jna.contrib.demo.FilteredTextField.addCharacters",
	"Comment": "adds the character array to the list used for entry validation.",
	"Method": "void addCharacters(Character[] characters){\r\n    for (int i = 0; i < characters.length; i++) {\r\n        addCharacter(characters[i]);\r\n    }\r\n}"
}, {
	"Path": "hudson.cli.OnlineNodeCommandTest.startBlockingAndFinishingBuild",
	"Comment": "start a project with an infinite build step and wait until signal to finish",
	"Method": "Future<FreeStyleBuild> startBlockingAndFinishingBuild(FreeStyleProject project,OneShotEvent finish){\r\n    final OneShotEvent block = new OneShotEvent();\r\n    project.getBuildersList().add(new BlockingAndFinishingBuilder(block, finish));\r\n    Future<FreeStyleBuild> r = project.scheduleBuild2(0);\r\n    block.block();\r\n    assertTrue(project.getLastBuild().isBuilding());\r\n    return r;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.processAttributes",
	"Comment": "process the attributes, which means to write out the currentlycollected attributes to the writer. the attributes are notcleared by this method",
	"Method": "void processAttributes(java.io.Writer writer,int nAttrs){\r\n    String encoding = getEncoding();\r\n    for (int i = 0; i < nAttrs; i++) {\r\n        final String name = m_attributes.getQName(i);\r\n        final String value = m_attributes.getValue(i);\r\n        writer.write(' ');\r\n        writer.write(name);\r\n        writer.write(\"=\\\"\");\r\n        writeAttrString(writer, value, encoding);\r\n        writer.write('\\\"');\r\n    }\r\n}"
}, {
	"Path": "hudson.model.Node.getLabelCloud",
	"Comment": "return the possibly empty tag cloud for the labels of this node.",
	"Method": "TagCloud<LabelAtom> getLabelCloud(){\r\n    return new TagCloud<LabelAtom>(getAssignedLabels(), new WeightFunction<LabelAtom>() {\r\n        public float weight(LabelAtom item) {\r\n            return item.getTiedJobCount();\r\n        }\r\n    });\r\n}"
}, {
	"Path": "hudson.model.Node.getLabelCloud",
	"Comment": "return the possibly empty tag cloud for the labels of this node.",
	"Method": "TagCloud<LabelAtom> getLabelCloud(){\r\n    return item.getTiedJobCount();\r\n}"
}, {
	"Path": "hudson.PluginManager.containsHpiJpi",
	"Comment": "contains operation that considers xxx.hpi and xxx.jpi as equalthis is necessary since the bundled plugins are still called .hpi",
	"Method": "boolean containsHpiJpi(Collection<String> bundledPlugins,String name){\r\n    return bundledPlugins.contains(name.replaceAll(\"\\\\.hpi\", \".jpi\")) || bundledPlugins.contains(name.replaceAll(\"\\\\.jpi\", \".hpi\"));\r\n}"
}, {
	"Path": "redis.clients.jedis.BinaryJedis.move",
	"Comment": "move the specified key from the currently selected db to the specified destination db. notethat this command returns 1 only if the key was successfully moved, and 0 if the target key wasalready there or if the source key was not found at all, so it is possible to use move as alocking primitive.",
	"Method": "Long move(byte[] key,int dbIndex){\r\n    checkIsInMultiOrPipeline();\r\n    client.move(key, dbIndex);\r\n    return client.getIntegerReply();\r\n}"
}, {
	"Path": "com.iluwatar.retry.FindCustomerTest.resultAfterExceptions",
	"Comment": "should first throw the given exceptions, then return the given result.",
	"Method": "void resultAfterExceptions(){\r\n    final BusinessOperation<String> op = new FindCustomer(\"123\", new CustomerNotFoundException(\"not found\"), new DatabaseNotAvailableException(\"not available\"));\r\n    try {\r\n        op.perform();\r\n    } catch (CustomerNotFoundException e) {\r\n    }\r\n    try {\r\n        op.perform();\r\n    } catch (DatabaseNotAvailableException e) {\r\n    }\r\n    assertThat(op.perform(), is(\"123\"));\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.getSourceTreeManager",
	"Comment": "get the sourcetreemanager associated with this execution context.",
	"Method": "SourceTreeManager getSourceTreeManager(){\r\n    return m_sourceTreeManager;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.TemplateSubPatternAssociation.getDocOrderPos",
	"Comment": "return the position of the template in documentorder in the stylesheet.",
	"Method": "int getDocOrderPos(){\r\n    return m_template.getUid();\r\n}"
}, {
	"Path": "org.apache.xpath.functions.ObjectFactory.newInstance",
	"Comment": "create an instance of a class using the specified classloader",
	"Method": "Object newInstance(String className,ClassLoader cl,boolean doFallback){\r\n    try {\r\n        Class providerClass = findProviderClass(className, cl, doFallback);\r\n        Object instance = providerClass.newInstance();\r\n        debugPrintln(\"created new instance of \" + providerClass + \" using ClassLoader: \" + cl);\r\n        return instance;\r\n    } catch (ClassNotFoundException x) {\r\n        throw new ConfigurationError(\"Provider \" + className + \" not found\", x);\r\n    } catch (Exception x) {\r\n        throw new ConfigurationError(\"Provider \" + className + \" could not be instantiated: \" + x, x);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemVariable.isPsuedoVar",
	"Comment": "tell if this is a psuedo variable reference, declared by xalan instead of by the user.",
	"Method": "boolean isPsuedoVar(){\r\n    java.lang.String ns = m_qname.getNamespaceURI();\r\n    if ((null != ns) && ns.equals(RedundentExprEliminator.PSUEDOVARNAMESPACE)) {\r\n        if (m_qname.getLocalName().startsWith(\"#\"))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xml.utils.XML11Char.isXML11Valid",
	"Comment": "returns true if the specified character is valid. this methodalso checks the surrogate character range from 0x10000 to 0x10ffff.if the program chooses to apply the mask directly to thexml11chars array, then they are responsible for checkingthe surrogate character range.",
	"Method": "boolean isXML11Valid(int c){\r\n    return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_VALID) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncExtElementAvailable.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    String prefix;\r\n    String namespace;\r\n    String methName;\r\n    String fullName = m_arg0.execute(xctxt).str();\r\n    int indexOfNSSep = fullName.indexOf(':');\r\n    if (indexOfNSSep < 0) {\r\n        prefix = \"\";\r\n        namespace = Constants.S_XSLNAMESPACEURL;\r\n        methName = fullName;\r\n    } else {\r\n        prefix = fullName.substring(0, indexOfNSSep);\r\n        namespace = xctxt.getNamespaceContext().getNamespaceForPrefix(prefix);\r\n        if (null == namespace)\r\n            return XBoolean.S_FALSE;\r\n        methName = fullName.substring(indexOfNSSep + 1);\r\n    }\r\n    if (namespace.equals(Constants.S_XSLNAMESPACEURL) || namespace.equals(Constants.S_BUILTIN_EXTENSIONS_URL)) {\r\n        try {\r\n            TransformerImpl transformer = (TransformerImpl) xctxt.getOwnerObject();\r\n            return transformer.getStylesheet().getAvailableElements().containsKey(new QName(namespace, methName)) ? XBoolean.S_TRUE : XBoolean.S_FALSE;\r\n        } catch (Exception e) {\r\n            return XBoolean.S_FALSE;\r\n        }\r\n    } else {\r\n        ExtensionsProvider extProvider = (ExtensionsProvider) xctxt.getOwnerObject();\r\n        return extProvider.elementAvailable(namespace, methName) ? XBoolean.S_TRUE : XBoolean.S_FALSE;\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.privateclassdata.ImmutableStewTest.testDrink",
	"Comment": "verify if tasting the stew actually removes one of each ingredient",
	"Method": "void testDrink(){\r\n    final Stew stew = new Stew(1, 2, 3, 4);\r\n    stew.mix();\r\n    assertEquals(\"Mixing the stew we find: 1 potatoes, 2 carrots, 3 meat and 4 peppers\", appender.getLastMessage());\r\n    stew.taste();\r\n    assertEquals(\"Tasting the stew\", appender.getLastMessage());\r\n    stew.mix();\r\n    assertEquals(\"Mixing the stew we find: 0 potatoes, 1 carrots, 2 meat and 3 peppers\", appender.getLastMessage());\r\n}"
}, {
	"Path": "org.apache.xpath.compiler.XPathParser.setErrorHandler",
	"Comment": "allow an application to register an error event handler, where syntax errors will be sent.if the error listener is not set, syntax errors will be sent to system.err.",
	"Method": "void setErrorHandler(ErrorListener handler){\r\n    m_errorListener = handler;\r\n}"
}, {
	"Path": "org.apache.xpath.operations.Variable.getAnalysisBits",
	"Comment": "get the analysis bits for this walker, as defined in the walkerfactory.",
	"Method": "int getAnalysisBits(){\r\n    org.apache.xalan.templates.ElemVariable vvar = getElemVariable();\r\n    if (null != vvar) {\r\n        XPath xpath = vvar.getSelect();\r\n        if (null != xpath) {\r\n            Expression expr = xpath.getExpression();\r\n            if (null != expr && expr instanceof PathComponent) {\r\n                return ((PathComponent) expr).getAnalysisBits();\r\n            }\r\n        }\r\n    }\r\n    return WalkerFactory.BIT_FILTER;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplate.getPublicId",
	"Comment": "return the public identifier for the current document event.this will be the public identifier",
	"Method": "String getPublicId(){\r\n    return m_publicId;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.getDocumentEncoding",
	"Comment": "return the name of the character encoding scheme in which the document entity is expressed.",
	"Method": "String getDocumentEncoding(int nodeHandle){\r\n    return null;\r\n}"
}, {
	"Path": "com.iluwatar.doubledispatch.CollisionTest.testCollision",
	"Comment": "collide the tested item with the other given item and verify if the damage and fire state is asexpected",
	"Method": "void testCollision(GameObject other,boolean otherDamaged,boolean otherOnFire,boolean thisDamaged,boolean thisOnFire,String description){\r\n    Objects.requireNonNull(other);\r\n    Objects.requireNonNull(getTestedObject());\r\n    final O tested = getTestedObject();\r\n    tested.collision(other);\r\n    testOnFire(other, tested, otherOnFire);\r\n    testDamaged(other, tested, otherDamaged);\r\n    testOnFire(tested, other, thisOnFire);\r\n    testDamaged(tested, other, thisDamaged);\r\n}"
}, {
	"Path": "org.apache.xml.utils.NodeVector.peepOrNull",
	"Comment": "return the node at the top of the stack without popping the stack.special purpose method for transformerimpl, pushelemtemplateelement.performance critical.",
	"Method": "int peepOrNull(){\r\n    return ((null != m_map) && (m_firstFree > 0)) ? m_map[m_firstFree - 1] : DTM.NULL;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetRoot.setTemplateListComposed",
	"Comment": "mutator method to set the templatelist associated with thisstylesheetroot.this method should only be used by the compiler.normally,the template list is built during the recompose process and should not bealtered by the user.",
	"Method": "void setTemplateListComposed(TemplateList templateList){\r\n    m_templateList = templateList;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.KeyIterator.getName",
	"Comment": "get the key name from a key declaration this iterator will process",
	"Method": "QName getName(){\r\n    return m_name;\r\n}"
}, {
	"Path": "hudson.model.AbstractProject.checkAndRecord",
	"Comment": "helper method for getdownstreamrelationship.for each given build, find the build number range of the given project and put that into the map.",
	"Method": "void checkAndRecord(AbstractProject that,TreeMap<Integer, RangeSet> r,Collection<R> builds){\r\n    for (R build : builds) {\r\n        RangeSet rs = build.getDownstreamRelationship(that);\r\n        if (rs == null || rs.isEmpty())\r\n            continue;\r\n        int n = build.getNumber();\r\n        RangeSet value = r.get(n);\r\n        if (value == null)\r\n            r.put(n, rs);\r\n        else\r\n            value.add(rs);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.VariableStack.getLocalVariable",
	"Comment": "get a local variable or parameter in the current stack frame.",
	"Method": "XObject getLocalVariable(XPathContext xctxt,int index,XObject getLocalVariable,int index,int frame,XObject getLocalVariable,XPathContext xctxt,int index,boolean destructiveOK){\r\n    index += _currentFrameBottom;\r\n    XObject val = _stackFrames[index];\r\n    if (null == val)\r\n        throw new TransformerException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_VARIABLE_ACCESSED_BEFORE_BIND, null), xctxt.getSAXLocator());\r\n    if (val.getType() == XObject.CLASS_UNRESOLVEDVARIABLE)\r\n        return (_stackFrames[index] = val.execute(xctxt));\r\n    return destructiveOK ? val : val.getFresh();\r\n}"
}, {
	"Path": "org.apache.xml.utils.SuballocatedIntVector.setElementAt",
	"Comment": "sets the component at the specified index of this vector to be thespecified object. the previous component at that position is discarded.the index must be a value greater than or equal to 0 and lessthan the current size of the vector.",
	"Method": "void setElementAt(int value,int at){\r\n    if (at < m_blocksize)\r\n        m_map0[at] = value;\r\n    else {\r\n        int index = at >>> m_SHIFT;\r\n        int offset = at & m_MASK;\r\n        if (index >= m_map.length) {\r\n            int newsize = index + m_numblocks;\r\n            int[][] newMap = new int[newsize][];\r\n            System.arraycopy(m_map, 0, newMap, 0, m_map.length);\r\n            m_map = newMap;\r\n        }\r\n        int[] block = m_map[index];\r\n        if (null == block)\r\n            block = m_map[index] = new int[m_blocksize];\r\n        block[offset] = value;\r\n    }\r\n    if (at >= m_firstFree)\r\n        m_firstFree = at + 1;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.ProcessorExsltFunction.startElement",
	"Comment": "start an elemexsltfunction. verify that it is top level and that it has a name attribute with anamespace.",
	"Method": "void startElement(StylesheetHandler handler,String uri,String localName,String rawName,Attributes attributes){\r\n    String msg = \"\";\r\n    if (!(handler.getElemTemplateElement() instanceof Stylesheet)) {\r\n        msg = \"func:function element must be top level.\";\r\n        handler.error(msg, new SAXException(msg));\r\n    }\r\n    super.startElement(handler, uri, localName, rawName, attributes);\r\n    String val = attributes.getValue(\"name\");\r\n    int indexOfColon = val.indexOf(\":\");\r\n    if (indexOfColon > 0) {\r\n    } else {\r\n        msg = \"func:function name must have namespace\";\r\n        handler.error(msg, new SAXException(msg));\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.DOM3TreeWalker.isValidQName",
	"Comment": "taken from org.apache.xerces.dom.coredocumentimplchecks if the given qualified name is legal with respectto the version of xml to which this document must conform.",
	"Method": "boolean isValidQName(String prefix,String local,boolean xml11Version){\r\n    if (local == null)\r\n        return false;\r\n    boolean validNCName = false;\r\n    if (!xml11Version) {\r\n        validNCName = (prefix == null || XMLChar.isValidNCName(prefix)) && XMLChar.isValidNCName(local);\r\n    } else {\r\n        validNCName = (prefix == null || XML11Char.isXML11ValidNCName(prefix)) && XML11Char.isXML11ValidNCName(local);\r\n    }\r\n    return validNCName;\r\n}"
}, {
	"Path": "hudson.util.CompressedFile.compress",
	"Comment": "asynchronously schedules the compression of this file.once the file is compressed, the original will be removed andthe further reading will be done from the compressed stream.",
	"Method": "void compress(){\r\n    compressionThread.submit(new Runnable() {\r\n        public void run() {\r\n            try {\r\n                try (InputStream in = read();\r\n                    OutputStream os = Files.newOutputStream(gz.toPath());\r\n                    OutputStream out = new GZIPOutputStream(os)) {\r\n                    org.apache.commons.io.IOUtils.copy(in, out);\r\n                }\r\n                file.delete();\r\n            } catch (IOException e) {\r\n                LOGGER.log(Level.WARNING, \"Failed to compress \" + file, e);\r\n                gz.delete();\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "hudson.util.CompressedFile.compress",
	"Comment": "asynchronously schedules the compression of this file.once the file is compressed, the original will be removed andthe further reading will be done from the compressed stream.",
	"Method": "void compress(){\r\n    try {\r\n        try (InputStream in = read();\r\n            OutputStream os = Files.newOutputStream(gz.toPath());\r\n            OutputStream out = new GZIPOutputStream(os)) {\r\n            org.apache.commons.io.IOUtils.copy(in, out);\r\n        }\r\n        file.delete();\r\n    } catch (IOException e) {\r\n        LOGGER.log(Level.WARNING, \"Failed to compress \" + file, e);\r\n        gz.delete();\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.doubledispatch.CollisionTest.testDamaged",
	"Comment": "test if the damage state of the target matches the expected state after colliding with thegiven object",
	"Method": "void testDamaged(GameObject target,GameObject other,boolean expectedDamage){\r\n    final String targetName = target.getClass().getSimpleName();\r\n    final String otherName = other.getClass().getSimpleName();\r\n    final String errorMessage = expectedDamage ? \"Expected [\" + targetName + \"] to be damaged after colliding with [\" + otherName + \"] but it was not!\" : \"Expected [\" + targetName + \"] not to be damaged after colliding with [\" + otherName + \"] but it was!\";\r\n    assertEquals(expectedDamage, target.isDamaged(), errorMessage);\r\n}"
}, {
	"Path": "hudson.model.Executor.newImpersonatingProxy",
	"Comment": "creates a proxy object that executes the callee in the context that impersonatesthis executor. useful to export an object to a remote channel.",
	"Method": "T newImpersonatingProxy(Class<T> type,T core){\r\n    return new InterceptingProxy() {\r\n        protected Object call(Object o, Method m, Object[] args) throws Throwable {\r\n            final Executor old = IMPERSONATION.get();\r\n            IMPERSONATION.set(Executor.this);\r\n            try {\r\n                return m.invoke(o, args);\r\n            } finally {\r\n                IMPERSONATION.set(old);\r\n            }\r\n        }\r\n    }.wrap(type, core);\r\n}"
}, {
	"Path": "hudson.model.Executor.newImpersonatingProxy",
	"Comment": "creates a proxy object that executes the callee in the context that impersonatesthis executor. useful to export an object to a remote channel.",
	"Method": "T newImpersonatingProxy(Class<T> type,T core){\r\n    final Executor old = IMPERSONATION.get();\r\n    IMPERSONATION.set(Executor.this);\r\n    try {\r\n        return m.invoke(o, args);\r\n    } finally {\r\n        IMPERSONATION.set(old);\r\n    }\r\n}"
}, {
	"Path": "redis.clients.jedis.BinaryJedis.bgsave",
	"Comment": "asynchronously save the db on disk.save the db in background. the ok code is immediately returned. redis forks, the parentcontinues to server the clients, the child saves the db on disk then exit. a client my be ableto check if the operation succeeded using the lastsave command.",
	"Method": "String bgsave(){\r\n    client.bgsave();\r\n    return client.getStatusCodeReply();\r\n}"
}, {
	"Path": "org.apache.xml.utils.ObjectVector.lastIndexOf",
	"Comment": "searches for the first occurence of the given argument,beginning the search at index, and testing for equalityusing the equals method.",
	"Method": "int lastIndexOf(Object elem){\r\n    for (int i = (m_firstFree - 1); i >= 0; i--) {\r\n        if (m_map[i] == elem)\r\n            return i;\r\n    }\r\n    return java.lang.Integer.MIN_VALUE;\r\n}"
}, {
	"Path": "org.apache.xml.utils.NodeVector.setElementAt",
	"Comment": "sets the component at the specified index of this vector to be thespecified object. the previous component at that position is discarded.the index must be a value greater than or equal to 0 and lessthan the current size of the vector.",
	"Method": "void setElementAt(int node,int index){\r\n    if (null == m_map) {\r\n        m_map = new int[m_blocksize];\r\n        m_mapSize = m_blocksize;\r\n    }\r\n    if (index == -1)\r\n        addElement(node);\r\n    m_map[index] = node;\r\n}"
}, {
	"Path": "com.iluwatar.tls.DateFormatCallableTest.testCounterDateValues",
	"Comment": "test number of dates in the list after the run of dateformatrunnalbe. a correct run should deliver 5 date values",
	"Method": "void testCounterDateValues(){\r\n    assertEquals(expectedCounterDateValues, result.getDateList().size());\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.WrappedRuntimeException.getException",
	"Comment": "get the checked exception that this runtime exception wraps.",
	"Method": "Exception getException(){\r\n    return m_exception;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemNumber.getZeroString",
	"Comment": "get a string value for zero, which is not really defined by the 1.0 spec, thought i think it might be cleared up by the erreta.",
	"Method": "String getZeroString(){\r\n    return \"\" + 0;\r\n}"
}, {
	"Path": "org.apache.xml.utils.DOMHelper.getDOMFactory",
	"Comment": "retrieve the factory object required to create dom nodesin the result tree.",
	"Method": "Document getDOMFactory(){\r\n    if (null == this.m_DOMFactory) {\r\n        this.m_DOMFactory = createDocument();\r\n    }\r\n    return this.m_DOMFactory;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncStartsWith.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    return m_arg0.execute(xctxt).xstr().startsWith(m_arg1.execute(xctxt).xstr()) ? XBoolean.S_TRUE : XBoolean.S_FALSE;\r\n}"
}, {
	"Path": "com.sun.jna.platform.dnd.DragHandler.getAcceptableDropAction",
	"Comment": "returns the first available action supported by source and target.",
	"Method": "int getAcceptableDropAction(int targetActions){\r\n    return reduce(supportedActions & targetActions);\r\n}"
}, {
	"Path": "hudson.util.JVMBuilder.classpath",
	"Comment": "returns a builder object for creating classpath arguments.",
	"Method": "ClasspathBuilder classpath(){\r\n    return classpath;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.peepTailSub1",
	"Comment": "return the node one position from the tail without popping.special purpose method for transformerimpl, pushelemtemplateelement.performance critical.",
	"Method": "Node peepTailSub1(){\r\n    return m_map[m_firstFree - 2];\r\n}"
}, {
	"Path": "jadx.core.dex.visitors.ClassModifier.modifySyntheticMethod",
	"Comment": "remove synthetic constructor and redirect calls to existing constructor",
	"Method": "void modifySyntheticMethod(ClassNode cls,MethodNode mth,List<RegisterArg> args){\r\n    List<InsnNode> insns = mth.getBasicBlocks().get(0).getInstructions();\r\n    if (insns.size() == 1 && insns.get(0).getType() == InsnType.CONSTRUCTOR) {\r\n        ConstructorInsn constr = (ConstructorInsn) insns.get(0);\r\n        if (constr.isThis() && !args.isEmpty()) {\r\n            RegisterArg firstArg = args.get(0);\r\n            if (firstArg.getType().equals(cls.getParentClass().getClassInfo().getType())) {\r\n                firstArg.add(AFlag.SKIP_ARG);\r\n            }\r\n            for (RegisterArg arg : args) {\r\n                SSAVar sVar = arg.getSVar();\r\n                if (sVar != null && sVar.getUseCount() == 0) {\r\n                    arg.add(AFlag.SKIP_ARG);\r\n                }\r\n            }\r\n            mth.add(AFlag.DONT_GENERATE);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.simple.SimpleFluentIterable.asList",
	"Comment": "collects all remaining objects of this iterable into a list.",
	"Method": "List<E> asList(){\r\n    return toList(iterable.iterator());\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.UnsequencedExpressionRewriterTest.testConditionalAccess",
	"Comment": "is not a modification, it might have been modified by the condition.",
	"Method": "void testConditionalAccess(){\r\n    String translation = translateSourceFile(\"class Test { boolean foo(int i, int j) { return i < j; }\" + \" boolean test1(boolean b, int i) { return b || foo(i, i++); }\" + \" boolean test2(boolean b, int i) { return b ? foo(i, i++) : false; } }\", \"Test\", \"Test.m\");\r\n    assertTranslatedLines(translation, \"jboolean unseq$1;\", \"if (!(unseq$1 = b)) {\", \"  jint unseq$2 = i;\", \"  unseq$1 = (unseq$1 || [self fooWithInt:unseq$2 withInt:i++]);\", \"}\", \"return unseq$1;\");\r\n    assertTranslatedLines(translation, \"jboolean unseq$1;\", \"if (b) {\", \"  jint unseq$2 = i;\", \"  unseq$1 = [self fooWithInt:unseq$2 withInt:i++];\", \"}\", \"else {\", \"  unseq$1 = false;\", \"}\", \"return unseq$1;\");\r\n}"
}, {
	"Path": "org.apache.xalan.processor.TransformerFactoryImpl.setAttribute",
	"Comment": "allows the user to set specific attributes on the underlyingimplementation.",
	"Method": "void setAttribute(String name,Object value){\r\n    if (name.equals(FEATURE_INCREMENTAL)) {\r\n        if (value instanceof Boolean) {\r\n            m_incremental = ((Boolean) value).booleanValue();\r\n        } else if (value instanceof String) {\r\n            m_incremental = (new Boolean((String) value)).booleanValue();\r\n        } else {\r\n            throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_BAD_VALUE, new Object[] { name, value }));\r\n        }\r\n    } else if (name.equals(FEATURE_OPTIMIZE)) {\r\n        if (value instanceof Boolean) {\r\n            m_optimize = ((Boolean) value).booleanValue();\r\n        } else if (value instanceof String) {\r\n            m_optimize = (new Boolean((String) value)).booleanValue();\r\n        } else {\r\n            throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_BAD_VALUE, new Object[] { name, value }));\r\n        }\r\n    } else if (name.equals(FEATURE_SOURCE_LOCATION)) {\r\n        if (value instanceof Boolean) {\r\n            m_source_location = ((Boolean) value).booleanValue();\r\n        } else if (value instanceof String) {\r\n            m_source_location = (new Boolean((String) value)).booleanValue();\r\n        } else {\r\n            throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_BAD_VALUE, new Object[] { name, value }));\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_NOT_SUPPORTED, new Object[] { name }));\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMNodeListBase.item",
	"Comment": "returns the indexth item in the collection. if index is greater than or equal to the number of nodes in the list, this returns null.",
	"Method": "Node item(int index){\r\n    return null;\r\n}"
}, {
	"Path": "com.iluwatar.event.queue.Audio.update",
	"Comment": "this method uses the update method pattern.it takes the audio from the queue and plays it",
	"Method": "void update(){\r\n    if (headIndex == tailIndex) {\r\n        return;\r\n    }\r\n    Clip clip = null;\r\n    try {\r\n        AudioInputStream audioStream = getPendingAudio()[headIndex].getStream();\r\n        headIndex++;\r\n        clip = AudioSystem.getClip();\r\n        clip.open(audioStream);\r\n        clip.start();\r\n    } catch (LineUnavailableException e) {\r\n        LOGGER.trace(\"Error occoured while loading the audio: The line is unavailable\", e);\r\n    } catch (IOException e) {\r\n        LOGGER.trace(\"Input/Output error while loading the audio\", e);\r\n    } catch (IllegalArgumentException e) {\r\n        LOGGER.trace(\"The system doesn't support the sound: \" + e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "redis.clients.jedis.util.Pool.getNumIdle",
	"Comment": "returns the number of instances currently idle in this pool.",
	"Method": "int getNumIdle(){\r\n    if (poolInactive()) {\r\n        return -1;\r\n    }\r\n    return this.internalPool.getNumIdle();\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.exprGetChild",
	"Comment": "this method returns a child node.the children are numbered from zero, left to right.",
	"Method": "ExpressionNode exprGetChild(int i){\r\n    return (ExpressionNode) item(i);\r\n}"
}, {
	"Path": "org.apache.xml.res.XMLMessages.createMsg",
	"Comment": "creates a message from the specified key and replacementarguments, localized to the given locale.",
	"Method": "String createMsg(ListResourceBundle fResourceBundle,String msgKey,Object args){\r\n    String fmsg = null;\r\n    boolean throwex = false;\r\n    String msg = null;\r\n    if (msgKey != null)\r\n        msg = fResourceBundle.getString(msgKey);\r\n    if (msg == null) {\r\n        msg = fResourceBundle.getString(BAD_CODE);\r\n        throwex = true;\r\n    }\r\n    if (args != null) {\r\n        try {\r\n            int n = args.length;\r\n            for (int i = 0; i < n; i++) {\r\n                if (null == args[i])\r\n                    args[i] = \"\";\r\n            }\r\n            fmsg = java.text.MessageFormat.format(msg, args);\r\n        } catch (Exception e) {\r\n            fmsg = fResourceBundle.getString(FORMAT_FAILED);\r\n            fmsg += \" \" + msg;\r\n        }\r\n    } else\r\n        fmsg = msg;\r\n    if (throwex) {\r\n        throw new RuntimeException(fmsg);\r\n    }\r\n    return fmsg;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.TemplateSubPatternAssociation.setNext",
	"Comment": "set the next element on this associationlist, which should be equal or less in priority tothis association, and, if equal priority, should occurbefore this template in document order.",
	"Method": "void setNext(TemplateSubPatternAssociation mp){\r\n    m_next = mp;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.setSourceLocation",
	"Comment": "store the source location of the current node.this method must be calledas every node is added to the dtm or for no node.",
	"Method": "void setSourceLocation(){\r\n    m_sourceSystemId.addElement(m_locator.getSystemId());\r\n    m_sourceLine.addElement(m_locator.getLineNumber());\r\n    m_sourceColumn.addElement(m_locator.getColumnNumber());\r\n    if (m_sourceSystemId.size() != m_size) {\r\n        String msg = \"CODING ERROR in Source Location: \" + m_size + \" != \" + m_sourceSystemId.size();\r\n        System.err.println(msg);\r\n        throw new RuntimeException(msg);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.ExpandedNameTable.getExpandedTypeID",
	"Comment": "given a type, return an expanded name id.any additional nodes that arecreated that have this expanded name will use this id.",
	"Method": "int getExpandedTypeID(String namespace,String localName,int type,int getExpandedTypeID,String namespace,String localName,int type,boolean searchOnly,int getExpandedTypeID,int type){\r\n    return type;\r\n}"
}, {
	"Path": "jenkins.util.xstream.XStreamDOMTest.escapeHandling",
	"Comment": "regardless of how we read xml into xstreamdom, xstreamdom should retain the raw xml infoset,which means escaped names.",
	"Method": "void escapeHandling(){\r\n    String input = getTestData(\"XStreamDOMTest.data3.xml\");\r\n    XStreamDOM dom = XStreamDOM.from(new StringReader(input));\r\n    List<XStreamDOM> children = dom.getChildren().get(0).getChildren().get(0).getChildren();\r\n    assertNamesAreEscaped(children);\r\n    Foo foo = (Foo) xs.fromXML(new StringReader(input));\r\n    assertNamesAreEscaped(foo.bar.getChildren());\r\n    StringWriter sw = new StringWriter();\r\n    dom.writeTo(sw);\r\n    assertTrue(sw.toString().contains(\"bar_-bar\"));\r\n    assertTrue(sw.toString().contains(\"zot__bar\"));\r\n    String s = xs.toXML(foo);\r\n    assertTrue(s.contains(\"bar_-bar\"));\r\n    assertTrue(s.contains(\"zot__bar\"));\r\n}"
}, {
	"Path": "ciphers.AES.shiftRowsDec",
	"Comment": "cell permutation step for decryption . shifts cells within the rows of the\tinput and returns the result.",
	"Method": "BigInteger shiftRowsDec(BigInteger ciphertext){\r\n    int[] cells = splitBlockIntoCells(ciphertext);\r\n    int[] output = new int[16];\r\n    output[0] = cells[0];\r\n    output[4] = cells[4];\r\n    output[8] = cells[8];\r\n    output[12] = cells[12];\r\n    output[1] = cells[13];\r\n    output[5] = cells[1];\r\n    output[9] = cells[5];\r\n    output[13] = cells[9];\r\n    output[2] = cells[10];\r\n    output[6] = cells[14];\r\n    output[10] = cells[2];\r\n    output[14] = cells[6];\r\n    output[3] = cells[7];\r\n    output[7] = cells[11];\r\n    output[11] = cells[15];\r\n    output[15] = cells[3];\r\n    return mergeCellsIntoBlock(output);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetRoot.shouldStripWhiteSpace",
	"Comment": "get information about whether or not an element should strip whitespace.",
	"Method": "boolean shouldStripWhiteSpace(XPathContext support,int targetElement){\r\n    if (null != m_whiteSpaceInfoList) {\r\n        while (DTM.NULL != targetElement) {\r\n            DTM dtm = support.getDTM(targetElement);\r\n            WhiteSpaceInfo info = (WhiteSpaceInfo) m_whiteSpaceInfoList.getTemplate(support, targetElement, null, false, dtm);\r\n            if (null != info)\r\n                return info.getShouldStripSpace();\r\n            int parent = dtm.getParent(targetElement);\r\n            if (DTM.NULL != parent && DTM.ELEMENT_NODE == dtm.getNodeType(parent))\r\n                targetElement = parent;\r\n            else\r\n                targetElement = DTM.NULL;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.iluwatar.multiton.NazgulEnumTest.testTheSameObjectIsReturnedWithMultipleCalls",
	"Comment": "check that multiple calls to any one of the instances in the multiton returns only that one particular instance, and do that for all instances in multiton",
	"Method": "void testTheSameObjectIsReturnedWithMultipleCalls(){\r\n    for (int i = 0; i < NazgulEnum.values().length; i++) {\r\n        NazgulEnum instance1 = NazgulEnum.values()[i];\r\n        NazgulEnum instance2 = NazgulEnum.values()[i];\r\n        NazgulEnum instance3 = NazgulEnum.values()[i];\r\n        assertSame(instance1, instance2);\r\n        assertSame(instance1, instance3);\r\n        assertSame(instance2, instance3);\r\n    }\r\n}"
}, {
	"Path": "hudson.model.Queue.getItem",
	"Comment": "gets the information about the queue item for the given project.",
	"Method": "Item getItem(long id,Item getItem,Task t){\r\n    Snapshot snapshot = this.snapshot;\r\n    for (Item item : snapshot.blockedProjects) {\r\n        if (item.task.equals(t))\r\n            return item;\r\n    }\r\n    for (Item item : snapshot.buildables) {\r\n        if (item.task.equals(t))\r\n            return item;\r\n    }\r\n    for (Item item : snapshot.pendings) {\r\n        if (item.task.equals(t))\r\n            return item;\r\n    }\r\n    for (Item item : snapshot.waitingList) {\r\n        if (item.task.equals(t)) {\r\n            return item;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.characters",
	"Comment": "this method gets the nodes value as a string and uses that string as ifit were an input character notification.",
	"Method": "void characters(org.w3c.dom.Node node){\r\n    flushPending();\r\n    String data = node.getNodeValue();\r\n    if (data != null) {\r\n        final int length = data.length();\r\n        if (length > m_charsBuff.length) {\r\n            m_charsBuff = new char[length * 2 + 1];\r\n        }\r\n        data.getChars(0, length, m_charsBuff, 0);\r\n        characters(m_charsBuff, 0, length);\r\n    }\r\n}"
}, {
	"Path": "hudson.model.Executor.getAsynchronousExecution",
	"Comment": "if currently running in asynchronous mode, returns that handle.",
	"Method": "AsynchronousExecution getAsynchronousExecution(){\r\n    lock.readLock().lock();\r\n    try {\r\n        return asynchronousExecution;\r\n    } finally {\r\n        lock.readLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.StepPattern.callSubtreeVisitors",
	"Comment": "call the visitors on the subtree.factored out from callvisitors so it may be called by derived classes.",
	"Method": "void callSubtreeVisitors(XPathVisitor visitor){\r\n    if (null != m_predicates) {\r\n        int n = m_predicates.length;\r\n        for (int i = 0; i < n; i++) {\r\n            ExpressionOwner predOwner = new PredOwner(i);\r\n            if (visitor.visitPredicate(predOwner, m_predicates[i])) {\r\n                m_predicates[i].callVisitors(predOwner, visitor);\r\n            }\r\n        }\r\n    }\r\n    if (null != m_relativePathPattern) {\r\n        m_relativePathPattern.callVisitors(this, visitor);\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.unitofwork.StudentRepository.commit",
	"Comment": "all unitofwork operations are batched and executed together on commit only.",
	"Method": "void commit(){\r\n    if (context == null || context.size() == 0) {\r\n        return;\r\n    }\r\n    LOGGER.info(\"Commit started\");\r\n    if (context.containsKey(IUnitOfWork.INSERT)) {\r\n        commitInsert();\r\n    }\r\n    if (context.containsKey(IUnitOfWork.MODIFY)) {\r\n        commitModify();\r\n    }\r\n    if (context.containsKey(IUnitOfWork.DELETE)) {\r\n        commitDelete();\r\n    }\r\n    LOGGER.info(\"Commit finished.\");\r\n}"
}, {
	"Path": "jenkins.org.apache.commons.validator.routines.UrlValidator.isValidPath",
	"Comment": "returns true if the path is valid.a null value is considered invalid.",
	"Method": "boolean isValidPath(String path){\r\n    if (path == null) {\r\n        return false;\r\n    }\r\n    if (!PATH_PATTERN.matcher(path).matches()) {\r\n        return false;\r\n    }\r\n    try {\r\n        URI uri = new URI(null, null, path, null);\r\n        String norm = uri.normalize().getPath();\r\n        if (norm.startsWith(\"/../\") || norm.equals(\"/..\")) {\r\n            return false;\r\n        }\r\n    } catch (URISyntaxException e) {\r\n        return false;\r\n    }\r\n    int slash2Count = countToken(\"//\", path);\r\n    if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xpath.jaxp.XPathFactoryImpl.isObjectModelSupported",
	"Comment": "is specified object model supported by this xpathfactory?",
	"Method": "boolean isObjectModelSupported(String objectModel){\r\n    if (objectModel == null) {\r\n        String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_OBJECT_MODEL_NULL, new Object[] { this.getClass().getName() });\r\n        throw new NullPointerException(fmsg);\r\n    }\r\n    if (objectModel.length() == 0) {\r\n        String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_OBJECT_MODEL_EMPTY, new Object[] { this.getClass().getName() });\r\n        throw new IllegalArgumentException(fmsg);\r\n    }\r\n    if (objectModel.equals(XPathFactory.DEFAULT_OBJECT_MODEL_URI)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "hudson.model.DependencyGraph.getComputationalData",
	"Comment": "gets temporary data which is needed for building up the dependency graph.",
	"Method": "T getComputationalData(Class<T> key){\r\n    @SuppressWarnings(\"unchecked\")\r\n    T result = (T) this.computationalData.get(key);\r\n    return result;\r\n}"
}, {
	"Path": "hudson.cli.DisablePluginCommandTest.returnCodeFirstErrorIsNoSuchPlugin",
	"Comment": "the return code is the first error distinct of 0 found during the process. in this case no such plugin.",
	"Method": "void returnCodeFirstErrorIsNoSuchPlugin(){\r\n    CLICommandInvoker.Result result = disablePluginsCLiCommand(\"badplugin\", \"dependee\");\r\n    assertThat(result, failedWith(RETURN_CODE_NO_SUCH_PLUGIN));\r\n    assertPluginEnabled(\"dependee\");\r\n}"
}, {
	"Path": "org.java_websocket.AbstractWebSocket.setConnectionLostTimeout",
	"Comment": "setter for the interval checking for lost connectionsa value lower or equal 0 results in the check to be deactivated",
	"Method": "void setConnectionLostTimeout(int connectionLostTimeout){\r\n    this.connectionLostTimeout = connectionLostTimeout;\r\n    if (this.connectionLostTimeout <= 0) {\r\n        log.trace(\"Connection lost timer stopped\");\r\n        cancelConnectionLostTimer();\r\n        return;\r\n    }\r\n    if (this.websocketRunning) {\r\n        log.trace(\"Connection lost timer restarted\");\r\n        try {\r\n            ArrayList<WebSocket> connections = new ArrayList<WebSocket>(getConnections());\r\n            WebSocketImpl webSocketImpl;\r\n            for (WebSocket conn : connections) {\r\n                if (conn instanceof WebSocketImpl) {\r\n                    webSocketImpl = (WebSocketImpl) conn;\r\n                    webSocketImpl.updateLastPong();\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            log.error(\"Exception during connection lost restart\", e);\r\n        }\r\n        restartConnectionLostTimer();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLChar.supplemental",
	"Comment": "returns true the supplemental character corresponding to the givensurrogates.",
	"Method": "int supplemental(char h,char l){\r\n    return (h - 0xD800) * 0x400 + (l - 0xDC00) + 0x10000;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.DTMManager.getSource_location",
	"Comment": "get a flag indicating whether the transformation phase shouldkeep track of line and column numbers for the input sourcedocument.",
	"Method": "boolean getSource_location(){\r\n    return m_source_location;\r\n}"
}, {
	"Path": "hudson.model.AbstractItem.renameTo",
	"Comment": "renames this item.not all the items need to support this operation, but if you decide to do so,you can use this method.",
	"Method": "void renameTo(String newName){\r\n    final ItemGroup parent = getParent();\r\n    String oldName = this.name;\r\n    String oldFullName = getFullName();\r\n    synchronized (parent) {\r\n        synchronized (this) {\r\n            if (newName == null)\r\n                throw new IllegalArgumentException(\"New name is not given\");\r\n            if (this.name.equals(newName))\r\n                return;\r\n            Items.verifyItemDoesNotAlreadyExist(parent, newName, this);\r\n            File oldRoot = this.getRootDir();\r\n            doSetName(newName);\r\n            File newRoot = this.getRootDir();\r\n            boolean success = false;\r\n            try {\r\n                boolean interrupted = false;\r\n                boolean renamed = false;\r\n                for (int retry = 0; retry < 5; retry++) {\r\n                    if (oldRoot.renameTo(newRoot)) {\r\n                        renamed = true;\r\n                        break;\r\n                    }\r\n                    try {\r\n                        Thread.sleep(500);\r\n                    } catch (InterruptedException e) {\r\n                        interrupted = true;\r\n                    }\r\n                }\r\n                if (interrupted)\r\n                    Thread.currentThread().interrupt();\r\n                if (!renamed) {\r\n                    Copy cp = new Copy();\r\n                    cp.setProject(new org.apache.tools.ant.Project());\r\n                    cp.setTodir(newRoot);\r\n                    FileSet src = new FileSet();\r\n                    src.setDir(oldRoot);\r\n                    cp.addFileset(src);\r\n                    cp.setOverwrite(true);\r\n                    cp.setPreserveLastModified(true);\r\n                    cp.setFailOnError(false);\r\n                    cp.execute();\r\n                    try {\r\n                        Util.deleteRecursive(oldRoot);\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n                success = true;\r\n            } finally {\r\n                if (!success)\r\n                    doSetName(oldName);\r\n            }\r\n            parent.onRenamed(this, oldName, newName);\r\n        }\r\n    }\r\n    ItemListener.fireLocationChange(this, oldFullName);\r\n}"
}, {
	"Path": "hudson.model.Executor.isParking",
	"Comment": "returns true if this executor is waiting for a task to execute.",
	"Method": "boolean isParking(){\r\n    lock.readLock().lock();\r\n    try {\r\n        return !started;\r\n    } finally {\r\n        lock.readLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.api.TarImage.named",
	"Comment": "configures the output tarball archive with an image reference to set as its tag.",
	"Method": "Builder named(ImageReference imageReference,Builder named,String imageReference){\r\n    return named(ImageReference.parse(imageReference));\r\n}"
}, {
	"Path": "hudson.model.Descriptor.getGlobalPropertyType",
	"Comment": "obtains the property type of the given field of this descriptor.",
	"Method": "PropertyType getGlobalPropertyType(String field){\r\n    if (globalPropertyTypes == null)\r\n        globalPropertyTypes = buildPropertyTypes(getClass());\r\n    return globalPropertyTypes.get(field);\r\n}"
}, {
	"Path": "hudson.model.queue.SubTask.getLastBuiltOn",
	"Comment": "if the previous execution of this task run on a certain nodeand this task prefers to run on the same node, return that.otherwise null.",
	"Method": "Node getLastBuiltOn(){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerImpl.popCurrentTemplateRuleIsNull",
	"Comment": "push true if the current template rule is null, falseotherwise.",
	"Method": "void popCurrentTemplateRuleIsNull(){\r\n    m_currentTemplateRuleIsNull.pop();\r\n}"
}, {
	"Path": "jadx.core.dex.visitors.ModVisitor.replaceInsn",
	"Comment": "replace insn by index i in block,\tfor proper copy attributes, assume attributes are not overlap",
	"Method": "void replaceInsn(BlockNode block,int i,InsnNode insn){\r\n    InsnNode prevInsn = block.getInstructions().get(i);\r\n    insn.copyAttributesFrom(prevInsn);\r\n    insn.setSourceLine(prevInsn.getSourceLine());\r\n    block.getInstructions().set(i, insn);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.ExpandedNameTable.initExtendedTypes",
	"Comment": "initialize the vector of extended types with the basic dom node types.",
	"Method": "void initExtendedTypes(){\r\n    m_extendedTypes = new ExtendedType[m_initialSize];\r\n    for (int i = 0; i < DTM.NTYPES; i++) {\r\n        m_extendedTypes[i] = m_defaultExtendedTypes[i];\r\n        m_table[i] = new HashEntry(m_defaultExtendedTypes[i], i, i, null);\r\n    }\r\n    m_nextType = DTM.NTYPES;\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XStringForFSB.object",
	"Comment": "since this object is incomplete without the length and the offset, we have to convert to a string when this function is called.",
	"Method": "Object object(){\r\n    return str();\r\n}"
}, {
	"Path": "hudson.AbstractMarkupText.addHyperlinkLowKey",
	"Comment": "inserts an a tag that surrounds the given position.but this hyperlink is less visible.",
	"Method": "void addHyperlinkLowKey(int startPos,int endPos,String url){\r\n    addMarkup(startPos, endPos, \"<a class='lowkey' href='\" + url + \"'>\", \"<\/a>\");\r\n}"
}, {
	"Path": "hudson.model.AbstractItem.getRelativeDisplayNameFrom",
	"Comment": "gets the display name of the current item relative to the given group.",
	"Method": "String getRelativeDisplayNameFrom(ItemGroup p){\r\n    return Functions.getRelativeDisplayNameFrom(this, p);\r\n}"
}, {
	"Path": "com.iluwatar.eda.framework.EventDispatcherTest.testEventDriverPattern",
	"Comment": "this unit test should register events and event handlers correctly with the event dispatcherand events should be dispatched accordingly.",
	"Method": "void testEventDriverPattern(){\r\n    EventDispatcher dispatcher = spy(new EventDispatcher());\r\n    UserCreatedEventHandler userCreatedEventHandler = spy(new UserCreatedEventHandler());\r\n    UserUpdatedEventHandler userUpdatedEventHandler = spy(new UserUpdatedEventHandler());\r\n    dispatcher.registerHandler(UserCreatedEvent.class, userCreatedEventHandler);\r\n    dispatcher.registerHandler(UserUpdatedEvent.class, userUpdatedEventHandler);\r\n    User user = new User(\"iluwatar\");\r\n    UserCreatedEvent userCreatedEvent = new UserCreatedEvent(user);\r\n    UserUpdatedEvent userUpdatedEvent = new UserUpdatedEvent(user);\r\n    dispatcher.dispatch(userCreatedEvent);\r\n    verify(userCreatedEventHandler).onEvent(userCreatedEvent);\r\n    verify(dispatcher).dispatch(userCreatedEvent);\r\n    dispatcher.dispatch(userUpdatedEvent);\r\n    verify(userUpdatedEventHandler).onEvent(userUpdatedEvent);\r\n    verify(dispatcher).dispatch(userUpdatedEvent);\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.simple.SimpleFluentIterable.map",
	"Comment": "transforms this fluentiterable into a new one containing objects of the type t.",
	"Method": "FluentIterable<T> map(Function<? super E, T> function){\r\n    List<T> temporaryList = new ArrayList();\r\n    Iterator<E> iterator = iterator();\r\n    while (iterator.hasNext()) {\r\n        temporaryList.add(function.apply(iterator.next()));\r\n    }\r\n    return from(temporaryList);\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncExtFunction.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frameindexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    if (null != m_argVec) {\r\n        int nArgs = m_argVec.size();\r\n        for (int i = 0; i < nArgs; i++) {\r\n            Expression arg = (Expression) m_argVec.elementAt(i);\r\n            arg.fixupVariables(vars, globalsSize);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XObject.boolWithSideEffects",
	"Comment": "cast result object to a boolean, but allow side effects, such as the incrementing of an iterator.",
	"Method": "boolean boolWithSideEffects(){\r\n    return bool();\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.image.DescriptorDigest.equals",
	"Comment": "two digest objects are equal if their digest strings are equal.",
	"Method": "boolean equals(Object obj){\r\n    if (obj instanceof DescriptorDigest) {\r\n        return hash.equals(((DescriptorDigest) obj).hash);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.WhiteSpaceInfo.getShouldStripSpace",
	"Comment": "return true if this element specifies that the node thatmatches the match pattern should be stripped, otherwisethe space should be preserved.",
	"Method": "boolean getShouldStripSpace(){\r\n    return m_shouldStripSpace;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.PredicatedNodeTest.setPredicateCount",
	"Comment": "set the number of predicates that this walker has.this does more that one would think, as it creates a new predicate array of the size of the count argument, and copies count predicates into the new one from the old, and then reassigns the predicates value.all this to keep from having to have a predicate count value.",
	"Method": "void setPredicateCount(int count){\r\n    if (count > 0) {\r\n        Expression[] newPredicates = new Expression[count];\r\n        for (int i = 0; i < count; i++) {\r\n            newPredicates[i] = m_predicates[i];\r\n        }\r\n        m_predicates = newPredicates;\r\n    } else\r\n        m_predicates = null;\r\n}"
}, {
	"Path": "hudson.PluginWrapper.isEnabled",
	"Comment": "if true, the plugin is going to be activated next timejenkins runs.",
	"Method": "boolean isEnabled(){\r\n    return !disableFile.exists();\r\n}"
}, {
	"Path": "hudson.Functions.getAvatar",
	"Comment": "returns an avatar image url for the specified user and preferred image size",
	"Method": "String getAvatar(User user,String avatarSize){\r\n    return UserAvatarResolver.resolve(user, avatarSize);\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncSubstringBefore.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    String s1 = m_arg0.execute(xctxt).str();\r\n    String s2 = m_arg1.execute(xctxt).str();\r\n    int index = s1.indexOf(s2);\r\n    return (-1 == index) ? XString.EMPTYSTRING : new XString(s1.substring(0, index));\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.getDocumentVersion",
	"Comment": "return a string representing the xml version of the document. thisproperty is derived from the xml declaration optionally present at thebeginning of the document entity, and has no value if there is no xmldeclaration.",
	"Method": "String getDocumentVersion(int documentHandle){\r\n    return null;\r\n}"
}, {
	"Path": "jenkins.install.InstallUtilTest.test_getLastExecVersion",
	"Comment": "test jenkins startup sequences and the changes to the startup type..",
	"Method": "void test_getLastExecVersion(){\r\n    Main.isUnitTest = true;\r\n    InstallUtil.getConfigFile().delete();\r\n    Assert.assertEquals(\"1.0\", InstallUtil.getLastExecVersion());\r\n    setStoredVersion(\"9.123\");\r\n    Assert.assertEquals(\"9.123\", InstallUtil.getLastExecVersion());\r\n}"
}, {
	"Path": "hudson.model.RunMapTest.runtimeExceptionInUnmarshalling",
	"Comment": "testing if the lazy loading can gracefully tolerate a runtimeexception during unmarshalling.",
	"Method": "void runtimeExceptionInUnmarshalling(){\r\n    FreeStyleProject p = r.createFreeStyleProject();\r\n    FreeStyleBuild b = r.assertBuildStatusSuccess(p.scheduleBuild2(0));\r\n    b.addAction(new BombAction());\r\n    b.save();\r\n    p._getRuns().purgeCache();\r\n    b = p.getBuildByNumber(b.number);\r\n    assertNotNull(b);\r\n    assertNull(b.getAction(BombAction.class));\r\n    assertTrue(bombed);\r\n}"
}, {
	"Path": "hudson.cli.CliPort.getIdentity",
	"Comment": "gets the public part of the rsa key that represents the server identity.",
	"Method": "PublicKey getIdentity(){\r\n    if (identity == null)\r\n        return null;\r\n    byte[] image = Base64.decodeBase64(identity);\r\n    return KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(image));\r\n}"
}, {
	"Path": "org.apache.xalan.templates.XMLNSDecl.getIsExcluded",
	"Comment": "tell if this declaration should be excluded from theresult namespace.",
	"Method": "boolean getIsExcluded(){\r\n    return m_isExcluded;\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.popExpressionState",
	"Comment": "pop the current context node, expression node, and prefix resolver.",
	"Method": "void popExpressionState(){\r\n    m_currentNodes.quickPop(1);\r\n    m_currentExpressionNodes.quickPop(1);\r\n    m_prefixResolvers.pop();\r\n}"
}, {
	"Path": "hudson.model.Actionable.getActions",
	"Comment": "gets all actions of a specified type that contributed to this object.",
	"Method": "List<Action> getActions(List<T> getActions,Class<T> type){\r\n    List<T> _actions = Util.filter(getActions(), type);\r\n    for (TransientActionFactory<?> taf : TransientActionFactory.factoriesFor(getClass(), type)) {\r\n        _actions.addAll(Util.filter(createFor(taf), type));\r\n    }\r\n    return Collections.unmodifiableList(_actions);\r\n}"
}, {
	"Path": "hudson.cli.DisablePluginCommandTest.canDisablePluginWithOptionalDependerStrategyNone",
	"Comment": "can disable a plugin with an optional dependent plugin.with strategy none.",
	"Method": "void canDisablePluginWithOptionalDependerStrategyNone(){\r\n    assertThat(disablePluginsCLiCommand(\"-strategy\", \"NONE\", \"dependee\"), succeeded());\r\n    assertPluginDisabled(\"dependee\");\r\n}"
}, {
	"Path": "hudson.PluginManager.createPluginStrategy",
	"Comment": "creates a hudson.pluginstrategy, looking at the corresponding system property.",
	"Method": "PluginStrategy createPluginStrategy(){\r\n    String strategyName = SystemProperties.getString(PluginStrategy.class.getName());\r\n    if (strategyName != null) {\r\n        try {\r\n            Class<?> klazz = getClass().getClassLoader().loadClass(strategyName);\r\n            Object strategy = klazz.getConstructor(PluginManager.class).newInstance(this);\r\n            if (strategy instanceof PluginStrategy) {\r\n                LOGGER.info(\"Plugin strategy: \" + strategyName);\r\n                return (PluginStrategy) strategy;\r\n            } else {\r\n                LOGGER.warning(\"Plugin strategy (\" + strategyName + \") is not an instance of hudson.PluginStrategy\");\r\n            }\r\n        } catch (ClassNotFoundException e) {\r\n            LOGGER.warning(\"Plugin strategy class not found: \" + strategyName);\r\n        } catch (Exception e) {\r\n            LOGGER.log(WARNING, \"Could not instantiate plugin strategy: \" + strategyName + \". Falling back to ClassicPluginStrategy\", e);\r\n        }\r\n        LOGGER.info(\"Falling back to ClassicPluginStrategy\");\r\n    }\r\n    return new ClassicPluginStrategy(this);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.DOM3SerializerImpl.setErrorHandler",
	"Comment": "sets a domerrorhandler on the dom level 3 serializer.this interface is a public api.",
	"Method": "void setErrorHandler(DOMErrorHandler handler){\r\n    fErrorHandler = handler;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.UnionPathIterator.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    for (int i = 0; i < m_exprs.length; i++) {\r\n        m_exprs[i].fixupVariables(vars, globalsSize);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XString.getChars",
	"Comment": "copies characters from this string into the destination characterarray.",
	"Method": "void getChars(int srcBegin,int srcEnd,char dst,int dstBegin){\r\n    str().getChars(srcBegin, srcEnd, dst, dstBegin);\r\n}"
}, {
	"Path": "org.apache.xpath.operations.Variable.setIndex",
	"Comment": "set the index for the variable into the stack.for advanced use only. you must know what you are doing to use this.",
	"Method": "void setIndex(int index){\r\n    m_index = index;\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.releaseDTMXRTreeFrags",
	"Comment": "cleans dtmxrtreefrag objects by removing references to dtm and xpathcontext objects.",
	"Method": "void releaseDTMXRTreeFrags(){\r\n    if (m_DTMXRTreeFrags == null) {\r\n        return;\r\n    }\r\n    final Iterator iter = (m_DTMXRTreeFrags.values()).iterator();\r\n    while (iter.hasNext()) {\r\n        DTMXRTreeFrag frag = (DTMXRTreeFrag) iter.next();\r\n        frag.destruct();\r\n        iter.remove();\r\n    }\r\n    m_DTMXRTreeFrags = null;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncExtFunctionAvailable.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    String prefix;\r\n    String namespace;\r\n    String methName;\r\n    String fullName = m_arg0.execute(xctxt).str();\r\n    int indexOfNSSep = fullName.indexOf(':');\r\n    if (indexOfNSSep < 0) {\r\n        prefix = \"\";\r\n        namespace = Constants.S_XSLNAMESPACEURL;\r\n        methName = fullName;\r\n    } else {\r\n        prefix = fullName.substring(0, indexOfNSSep);\r\n        namespace = xctxt.getNamespaceContext().getNamespaceForPrefix(prefix);\r\n        if (null == namespace)\r\n            return XBoolean.S_FALSE;\r\n        methName = fullName.substring(indexOfNSSep + 1);\r\n    }\r\n    if (namespace.equals(Constants.S_XSLNAMESPACEURL)) {\r\n        try {\r\n            if (null == m_functionTable)\r\n                m_functionTable = new FunctionTable();\r\n            return m_functionTable.functionAvailable(methName) ? XBoolean.S_TRUE : XBoolean.S_FALSE;\r\n        } catch (Exception e) {\r\n            return XBoolean.S_FALSE;\r\n        }\r\n    } else {\r\n        ExtensionsProvider extProvider = (ExtensionsProvider) xctxt.getOwnerObject();\r\n        return extProvider.functionAvailable(namespace, methName) ? XBoolean.S_TRUE : XBoolean.S_FALSE;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncString.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    return (XString) getArg0AsString(xctxt);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.XSLTAttributeDef.getPrimativeClass",
	"Comment": "get the primative type for the class, if thereis one.if the class is a double, for instance,this will return double.class.if the class is not oneof the 9 primative types, it will return the sameclass that was passed in.",
	"Method": "Class getPrimativeClass(Object obj){\r\n    if (obj instanceof XPath)\r\n        return XPath.class;\r\n    Class cl = obj.getClass();\r\n    if (cl == Double.class) {\r\n        cl = double.class;\r\n    }\r\n    if (cl == Float.class) {\r\n        cl = float.class;\r\n    } else if (cl == Boolean.class) {\r\n        cl = boolean.class;\r\n    } else if (cl == Byte.class) {\r\n        cl = byte.class;\r\n    } else if (cl == Character.class) {\r\n        cl = char.class;\r\n    } else if (cl == Short.class) {\r\n        cl = short.class;\r\n    } else if (cl == Integer.class) {\r\n        cl = int.class;\r\n    } else if (cl == Long.class) {\r\n        cl = long.class;\r\n    }\r\n    return cl;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ObjectFactory.newInstance",
	"Comment": "create an instance of a class using the specified classloader",
	"Method": "Object newInstance(String className,ClassLoader cl,boolean doFallback){\r\n    try {\r\n        Class providerClass = findProviderClass(className, cl, doFallback);\r\n        Object instance = providerClass.newInstance();\r\n        debugPrintln(\"created new instance of \" + providerClass + \" using ClassLoader: \" + cl);\r\n        return instance;\r\n    } catch (ClassNotFoundException x) {\r\n        throw new ConfigurationError(\"Provider \" + className + \" not found\", x);\r\n    } catch (Exception x) {\r\n        throw new ConfigurationError(\"Provider \" + className + \" could not be instantiated: \" + x, x);\r\n    }\r\n}"
}, {
	"Path": "org.java_websocket.client.WebSocketClient.connect",
	"Comment": "initiates the websocket connection. this method does not block.",
	"Method": "void connect(){\r\n    if (connectReadThread != null)\r\n        throw new IllegalStateException(\"WebSocketClient objects are not reuseable\");\r\n    connectReadThread = new Thread(this);\r\n    connectReadThread.setName(\"WebSocketConnectReadThread-\" + connectReadThread.getId());\r\n    connectReadThread.start();\r\n}"
}, {
	"Path": "hudson.model.CauseAction.getCauses",
	"Comment": "lists all causes of this build.note that the current implementation does not preserve insertion order of duplicates.",
	"Method": "List<Cause> getCauses(){\r\n    List<Cause> r = new ArrayList();\r\n    for (Map.Entry<Cause, Integer> entry : causeBag.entrySet()) {\r\n        r.addAll(Collections.nCopies(entry.getValue(), entry.getKey()));\r\n    }\r\n    return Collections.unmodifiableList(r);\r\n}"
}, {
	"Path": "org.apache.xpath.axes.ChildTestIterator.getNextNode",
	"Comment": "get the next node via getnextxxx.bottlenecked for derived class override.",
	"Method": "int getNextNode(){\r\n    if (true) {\r\n        m_lastFetched = (DTM.NULL == m_lastFetched) ? m_traverser.first(m_context) : m_traverser.next(m_context, m_lastFetched);\r\n    }\r\n    return m_lastFetched;\r\n}"
}, {
	"Path": "hudson.model.DependencyGraph.compare",
	"Comment": "compare two projects based on the topological order defined by this dependency graph",
	"Method": "int compare(AbstractProject o1,AbstractProject o2){\r\n    return topologicalOrder.compare(o1, o2);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.RedundentExprEliminator.matchAndEliminatePartialPaths",
	"Comment": "for a given path, see if there are any partitial matches in the list, and, if there are, replace those partial paths with psuedo variable refs,and create the psuedo variable decl.",
	"Method": "MultistepExprHolder matchAndEliminatePartialPaths(MultistepExprHolder testee,MultistepExprHolder head,boolean isGlobal,int lengthToTest,ElemTemplateElement varScope){\r\n    if (null == testee.m_exprOwner)\r\n        return head;\r\n    WalkingIterator iter1 = (WalkingIterator) testee.m_exprOwner.getExpression();\r\n    if (partialIsVariable(testee, lengthToTest))\r\n        return head;\r\n    MultistepExprHolder matchedPaths = null;\r\n    MultistepExprHolder matchedPathsTail = null;\r\n    MultistepExprHolder meh = head;\r\n    while (null != meh) {\r\n        if ((meh != testee) && (null != meh.m_exprOwner)) {\r\n            WalkingIterator iter2 = (WalkingIterator) meh.m_exprOwner.getExpression();\r\n            if (stepsEqual(iter1, iter2, lengthToTest)) {\r\n                if (null == matchedPaths) {\r\n                    try {\r\n                        matchedPaths = (MultistepExprHolder) testee.clone();\r\n                        testee.m_exprOwner = null;\r\n                    } catch (CloneNotSupportedException cnse) {\r\n                    }\r\n                    matchedPathsTail = matchedPaths;\r\n                    matchedPathsTail.m_next = null;\r\n                }\r\n                try {\r\n                    matchedPathsTail.m_next = (MultistepExprHolder) meh.clone();\r\n                    meh.m_exprOwner = null;\r\n                } catch (CloneNotSupportedException cnse) {\r\n                }\r\n                matchedPathsTail = matchedPathsTail.m_next;\r\n                matchedPathsTail.m_next = null;\r\n            }\r\n        }\r\n        meh = meh.m_next;\r\n    }\r\n    int matchCount = 0;\r\n    if (null != matchedPaths) {\r\n        ElemTemplateElement root = isGlobal ? varScope : findCommonAncestor(matchedPaths);\r\n        WalkingIterator sharedIter = (WalkingIterator) matchedPaths.m_exprOwner.getExpression();\r\n        WalkingIterator newIter = createIteratorFromSteps(sharedIter, lengthToTest);\r\n        ElemVariable var = createPseudoVarDecl(root, newIter, isGlobal);\r\n        if (DIAGNOSE_MULTISTEPLIST)\r\n            System.err.println(\"Created var: \" + var.getName() + (isGlobal ? \"(Global)\" : \"\"));\r\n        while (null != matchedPaths) {\r\n            ExpressionOwner owner = matchedPaths.m_exprOwner;\r\n            WalkingIterator iter = (WalkingIterator) owner.getExpression();\r\n            if (DIAGNOSE_MULTISTEPLIST)\r\n                diagnoseLineNumber(iter);\r\n            LocPathIterator newIter2 = changePartToRef(var.getName(), iter, lengthToTest, isGlobal);\r\n            owner.setExpression(newIter2);\r\n            matchedPaths = matchedPaths.m_next;\r\n        }\r\n    }\r\n    if (DIAGNOSE_MULTISTEPLIST)\r\n        diagnoseMultistepList(matchCount, lengthToTest, isGlobal);\r\n    return head;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMAxisIteratorBase.isDocOrdered",
	"Comment": "returns true if all the nodes in the iteration well be returned in document order.",
	"Method": "boolean isDocOrdered(){\r\n    return true;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.tar.TarStreamBuilderTest.verifyBlobWithCompression",
	"Comment": "creates a compressed blob from the tarstreambuilder and verifies it.",
	"Method": "void verifyBlobWithCompression(){\r\n    Blob blob = testTarStreamBuilder.toBlob();\r\n    ByteArrayOutputStream tarByteOutputStream = new ByteArrayOutputStream();\r\n    OutputStream compressorStream = new GZIPOutputStream(tarByteOutputStream);\r\n    blob.writeTo(compressorStream);\r\n    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(tarByteOutputStream.toByteArray());\r\n    InputStream tarByteInputStream = new GZIPInputStream(byteArrayInputStream);\r\n    TarArchiveInputStream tarArchiveInputStream = new TarArchiveInputStream(tarByteInputStream);\r\n    verifyTarArchive(tarArchiveInputStream);\r\n}"
}, {
	"Path": "com.sun.jna.platform.linux.XAttrUtil.lGetXAttrBytes",
	"Comment": "get extended attribute value but in case of symbolic link get the value from the linkitself instead of linked file.",
	"Method": "byte[] lGetXAttrBytes(String path,String name){\r\n    ssize_t retval;\r\n    byte[] valueMem;\r\n    int eno = 0;\r\n    do {\r\n        retval = XAttr.INSTANCE.lgetxattr(path, name, (byte[]) null, size_t.ZERO);\r\n        if (retval.longValue() < 0) {\r\n            eno = Native.getLastError();\r\n            throw new IOException(\"errno: \" + eno);\r\n        }\r\n        valueMem = new byte[retval.intValue()];\r\n        retval = XAttr.INSTANCE.lgetxattr(path, name, valueMem, new size_t(valueMem.length));\r\n        if (retval.longValue() < 0) {\r\n            eno = Native.getLastError();\r\n            if (eno != XAttr.ERANGE) {\r\n                throw new IOException(\"errno: \" + eno);\r\n            }\r\n        }\r\n    } while (retval.longValue() < 0 && eno == XAttr.ERANGE);\r\n    return valueMem;\r\n}"
}, {
	"Path": "hudson.security.csrf.CrumbIssuerDescriptor.getCrumbRequestField",
	"Comment": "gets the request parameter name that contains the crumb generated from aprevious response.",
	"Method": "String getCrumbRequestField(){\r\n    return crumbRequestField;\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XNumber.getTypeString",
	"Comment": "given a request type, return the equivalent string.for diagnostic purposes.",
	"Method": "String getTypeString(){\r\n    return \"#NUMBER\";\r\n}"
}, {
	"Path": "com.winterbe.java8.samples.misc.CheckedFunctions.consumer",
	"Comment": "return a consumer which rethrows possible checked exceptions as runtime exception.",
	"Method": "Consumer<T> consumer(CheckedConsumer<T> consumer){\r\n    return input -> {\r\n        try {\r\n            consumer.accept(input);\r\n        } catch (Exception e) {\r\n            if (e instanceof RuntimeException) {\r\n                throw (RuntimeException) e;\r\n            }\r\n            throw new RuntimeException(e);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLChar.isValid",
	"Comment": "returns true if the specified character is valid. this methodalso checks the surrogate character range from 0x10000 to 0x10ffff.if the program chooses to apply the mask directly to thechars array, then they are responsible for checkingthe surrogate character range.",
	"Method": "boolean isValid(int c){\r\n    return (c < 0x10000 && (CHARS[c] & MASK_VALID) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "hudson.model.UpdateSite.getMetadataUrlForDownloadable",
	"Comment": "url which exposes the metadata location in a specific update site.",
	"Method": "String getMetadataUrlForDownloadable(String downloadable){\r\n    String siteUrl = getUrl();\r\n    String updateSiteMetadataUrl = null;\r\n    int baseUrlEnd = siteUrl.indexOf(\"update-center.json\");\r\n    if (baseUrlEnd != -1) {\r\n        String siteBaseUrl = siteUrl.substring(0, baseUrlEnd);\r\n        updateSiteMetadataUrl = siteBaseUrl + \"updates/\" + downloadable;\r\n    } else {\r\n        LOGGER.log(Level.WARNING, \"Url {0} does not look like an update center:\", siteUrl);\r\n    }\r\n    return updateSiteMetadataUrl;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.json.JsonTemplateMapper.readJsonFromFileWithLock",
	"Comment": "deserializes a json file via a json object template with a shared lock on the file",
	"Method": "T readJsonFromFileWithLock(Path jsonFile,Class<T> templateClass){\r\n    FileChannel channel = FileChannel.open(jsonFile, StandardOpenOption.READ);\r\n    channel.lock(0, Long.MAX_VALUE, true);\r\n    try (InputStream inputStream = Channels.newInputStream(channel)) {\r\n        return objectMapper.readValue(inputStream, templateClass);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.VariableStack.getGlobalVariable",
	"Comment": "get a global variable or parameter from the global stack frame.",
	"Method": "XObject getGlobalVariable(XPathContext xctxt,int index,XObject getGlobalVariable,XPathContext xctxt,int index,boolean destructiveOK){\r\n    XObject val = _stackFrames[index];\r\n    if (val.getType() == XObject.CLASS_UNRESOLVEDVARIABLE)\r\n        return (_stackFrames[index] = val.execute(xctxt));\r\n    return destructiveOK ? val : val.getFresh();\r\n}"
}, {
	"Path": "hudson.Functions.rawHtml",
	"Comment": "used for arguments to internationalized expressions to avoid escape",
	"Method": "Object rawHtml(Object o){\r\n    return o == null ? null : new RawHtmlArgument(o);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToXMLSAXHandler.namespaceAfterStartElement",
	"Comment": "send a namespace declaration in the output document. the namespacedeclaration will not be include if the namespace is already in scopewith the same prefix.",
	"Method": "void namespaceAfterStartElement(String prefix,String uri){\r\n    startPrefixMapping(prefix, uri, false);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.NamespaceMappings.popNamespaces",
	"Comment": "pop, or undeclare all namespace definitions that are currentlydeclared at the given element depth, or deepter.",
	"Method": "void popNamespaces(int elemDepth,ContentHandler saxHandler){\r\n    while (true) {\r\n        if (m_nodeStack.isEmpty())\r\n            return;\r\n        MappingRecord map = (MappingRecord) (m_nodeStack.peek());\r\n        int depth = map.m_declarationDepth;\r\n        if (elemDepth < 1 || map.m_declarationDepth < elemDepth)\r\n            break;\r\n        MappingRecord nm1 = (MappingRecord) m_nodeStack.pop();\r\n        String prefix = map.m_prefix;\r\n        Stack prefixStack = getPrefixStack(prefix);\r\n        MappingRecord nm2 = (MappingRecord) prefixStack.peek();\r\n        if (nm1 == nm2) {\r\n            prefixStack.pop();\r\n            if (saxHandler != null) {\r\n                try {\r\n                    saxHandler.endPrefixMapping(prefix);\r\n                } catch (SAXException e) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "hudson.util.spring.BeanBuilder.manageListIfNecessary",
	"Comment": "checks whether there are any runtime refs inside the list and\tconverts it to a managedlist if necessary",
	"Method": "Object manageListIfNecessary(List<Object> value){\r\n    boolean containsRuntimeRefs = false;\r\n    for (ListIterator<Object> i = value.listIterator(); i.hasNext(); ) {\r\n        Object e = i.next();\r\n        if (e instanceof RuntimeBeanReference) {\r\n            containsRuntimeRefs = true;\r\n        }\r\n        if (e instanceof BeanConfiguration) {\r\n            BeanConfiguration c = (BeanConfiguration) e;\r\n            i.set(c.getBeanDefinition());\r\n            containsRuntimeRefs = true;\r\n        }\r\n    }\r\n    if (containsRuntimeRefs) {\r\n        List tmp = new ManagedList();\r\n        tmp.addAll(value);\r\n        value = tmp;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.SerializerSwitcher.getOutputPropertyNoDefault",
	"Comment": "get the value of a property, without using the default properties.this can be used to test if a property has been explicitly set by the stylesheet or user.",
	"Method": "String getOutputPropertyNoDefault(String qnameString,Properties props){\r\n    String value = (String) props.get(qnameString);\r\n    return value;\r\n}"
}, {
	"Path": "com.iluwatar.promise.Promise.thenApply",
	"Comment": "returns a new promise that, when this promise is fulfilled normally, is fulfilled with result of this promise as argument to the function provided.",
	"Method": "Promise<V> thenApply(Function<? super T, V> func){\r\n    Promise<V> dest = new Promise();\r\n    fulfillmentAction = new TransformAction<V>(this, dest, func);\r\n    return dest;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.indexOf",
	"Comment": "searches for the first occurence of the given argument,beginning the search at index, and testing for equalityusing the equals method.",
	"Method": "int indexOf(Node elem,int index,int indexOf,Node elem){\r\n    runTo(-1);\r\n    if (null == m_map)\r\n        return -1;\r\n    for (int i = 0; i < m_firstFree; i++) {\r\n        Node node = m_map[i];\r\n        if ((null != node) && node.equals(elem))\r\n            return i;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.iluwatar.tls.DateFormatCallableTestIncorrectDateFormat.testCounterExceptions",
	"Comment": "test number of exceptions in the list after the run of dateformatrunnalbe. a correct run should deliver 5 exceptions",
	"Method": "void testCounterExceptions(){\r\n    assertEquals(expectedCounterExceptions, result.getExceptionList().size());\r\n}"
}, {
	"Path": "org.apache.xpath.patterns.StepPattern.getTargetString",
	"Comment": "get the local name or psuedo name of the node that this pattern will test,for hash table lookup optimization.",
	"Method": "String getTargetString(){\r\n    return m_targetString;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprIteratorSimple.getAnalysisBits",
	"Comment": "get the analysis bits for this walker, as defined in the walkerfactory.",
	"Method": "int getAnalysisBits(){\r\n    if (null != m_expr && m_expr instanceof PathComponent) {\r\n        return ((PathComponent) m_expr).getAnalysisBits();\r\n    }\r\n    return WalkerFactory.BIT_FILTER;\r\n}"
}, {
	"Path": "org.apache.xml.utils.ObjectVector.indexOf",
	"Comment": "searches for the first occurence of the given argument,beginning the search at index, and testing for equalityusing the equals method.",
	"Method": "int indexOf(Object elem,int index,int indexOf,Object elem){\r\n    for (int i = 0; i < m_firstFree; i++) {\r\n        if (m_map[i] == elem)\r\n            return i;\r\n    }\r\n    return java.lang.Integer.MIN_VALUE;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.getTemplates",
	"Comment": "when this object is used as a contenthandler or contenthandler, it willcreate a templates object, which the caller can get oncethe sax events have been completed.",
	"Method": "Templates getTemplates(){\r\n    return getStylesheetRoot();\r\n}"
}, {
	"Path": "com.iluwatar.converter.ConverterTest.testCollectionConversion",
	"Comment": "test whether converting a collection of users to dto users and then converting them back to domainusers returns an equal collection.",
	"Method": "void testCollectionConversion(){\r\n    ArrayList<User> users = Lists.newArrayList(new User(\"Camile\", \"Tough\", false, \"124sad\"), new User(\"Marti\", \"Luther\", true, \"42309fd\"), new User(\"Kate\", \"Smith\", true, \"if0243\"));\r\n    List<User> fromDtos = userConverter.createFromDtos(userConverter.createFromEntities(users));\r\n    assertEquals(users, fromDtos);\r\n}"
}, {
	"Path": "org.apache.xpath.VariableStack.setGlobalVariable",
	"Comment": "set a global variable or parameter in the global stack frame.",
	"Method": "void setGlobalVariable(int index,XObject val){\r\n    _stackFrames[index] = val;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.popStylesheet",
	"Comment": "pop the last stylesheet pushed, and return the stylesheet that thishandler is constructing, and set the last popped stylesheet member.also pop the stylesheet locator stack.",
	"Method": "Stylesheet popStylesheet(){\r\n    if (!m_stylesheetLocatorStack.isEmpty())\r\n        m_stylesheetLocatorStack.pop();\r\n    if (!m_stylesheets.isEmpty())\r\n        m_lastPoppedStylesheet = (Stylesheet) m_stylesheets.pop();\r\n    return m_lastPoppedStylesheet;\r\n}"
}, {
	"Path": "jenkins.security.apitoken.ApiTokenStats.load",
	"Comment": "loads the data from the disk into the new object.if the file is not present, a fresh new instance is created.",
	"Method": "ApiTokenStats load(File parent){\r\n    XmlFile file = getConfigFile(parent);\r\n    ApiTokenStats apiTokenStats;\r\n    if (file.exists()) {\r\n        try {\r\n            apiTokenStats = (ApiTokenStats) file.unmarshal(ApiTokenStats.class);\r\n        } catch (IOException e) {\r\n            LOGGER.log(Level.WARNING, \"Failed to load \" + file, e);\r\n            apiTokenStats = new ApiTokenStats();\r\n        }\r\n    } else {\r\n        apiTokenStats = new ApiTokenStats();\r\n    }\r\n    apiTokenStats.setParent(parent);\r\n    return apiTokenStats;\r\n}"
}, {
	"Path": "com.iluwatar.async.method.invocation.App.lazyval",
	"Comment": "creates a callable that lazily evaluates to given value with artificial delay.",
	"Method": "Callable<T> lazyval(T value,long delayMillis){\r\n    return () -> {\r\n        Thread.sleep(delayMillis);\r\n        log(\"Task completed with: \" + value);\r\n        return value;\r\n    };\r\n}"
}, {
	"Path": "org.apache.xpath.axes.MatchPatternIterator.setRoot",
	"Comment": "initialize the context values for this expressionafter it is cloned.",
	"Method": "void setRoot(int context,Object environment){\r\n    super.setRoot(context, environment);\r\n    m_traverser = m_cdtm.getAxisTraverser(m_superAxis);\r\n}"
}, {
	"Path": "jenkins.install.SetupWizard.doCompleteInstall",
	"Comment": "remove the setupwizard filter, ensure all updates are written to disk, etc",
	"Method": "HttpResponse doCompleteInstall(){\r\n    completeSetup();\r\n    return HttpResponses.okJSON();\r\n}"
}, {
	"Path": "org.apache.xml.utils.BoolStack.popAndTop",
	"Comment": "removes the object at the top of this stack and returns thenext object at the top as the value of this function.",
	"Method": "boolean popAndTop(){\r\n    m_index--;\r\n    return (m_index >= 0) ? m_values[m_index] : false;\r\n}"
}, {
	"Path": "org.apache.xalan.processor.XSLTAttributeDef.getErrorType",
	"Comment": "get the type of error message to use if the attribute value is invalid.",
	"Method": "int getErrorType(){\r\n    return m_errorType;\r\n}"
}, {
	"Path": "org.apache.xml.utils.UnImplNode.isSupported",
	"Comment": "tests whether the dom implementation implements a specific feature andthat feature is supported by this node.",
	"Method": "boolean isSupported(String feature,String version){\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xalan.extensions.ExtensionsTable.addExtensionNamespace",
	"Comment": "register an extension namespace handler. this handler providesfunctions for testing whether a function is known within thenamespace and also for invoking the functions.",
	"Method": "void addExtensionNamespace(String uri,ExtensionHandler extNS){\r\n    m_extensionFunctionNamespaces.put(uri, extNS);\r\n}"
}, {
	"Path": "hudson.model.AbstractProject.getTransitiveDownstreamProjects",
	"Comment": "gets all the downstream projects including transitive downstream projects.",
	"Method": "Set<AbstractProject> getTransitiveDownstreamProjects(){\r\n    return Jenkins.getInstance().getDependencyGraph().getTransitiveDownstream(this);\r\n}"
}, {
	"Path": "org.apache.xpath.operations.And.execute",
	"Comment": "and two expressions and return the boolean result. overridesuperclass method for optimization purposes.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    XObject expr1 = m_left.execute(xctxt);\r\n    if (expr1.bool()) {\r\n        XObject expr2 = m_right.execute(xctxt);\r\n        return expr2.bool() ? XBoolean.S_TRUE : XBoolean.S_FALSE;\r\n    } else\r\n        return XBoolean.S_FALSE;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.isDocOrdered",
	"Comment": "returns true if all the nodes in the iteration well be returned in document order.",
	"Method": "boolean isDocOrdered(){\r\n    return true;\r\n}"
}, {
	"Path": "jadx.tests.integration.debuginfo.TestVariablesNames.test",
	"Comment": "parameter register reused in variables assign with different types and names\tno variables names in debug info",
	"Method": "void test(){\r\n    ClassNode cls = getClassNodeFromSmaliWithPath(\"debuginfo\", \"TestVariablesNames\");\r\n    String code = cls.getCode().toString();\r\n    assertThat(code, containsOne(\"f1(str);\"));\r\n    assertThat(code, containsOne(\"f2(i2, \\\"i\\\" + i2);\"));\r\n    assertThat(code, containsOne(\"f3(d, \\\"d\\\" + d);\"));\r\n}"
}, {
	"Path": "hudson.model.DownloadServiceTest.setUp",
	"Comment": "makes sure that javascript on the client side for handling submission works.",
	"Method": "void setUp(){\r\n    super.setUp();\r\n    if (jenkins == null) {\r\n        return;\r\n    }\r\n    job = new Downloadable(\"test\", \"UNUSED\");\r\n    Downloadable.all().add(job);\r\n    DownloadSettings.get().setUseBrowser(true);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.AttributesImplSerializer.getIndex",
	"Comment": "this method gets the index of an attribute given its uri and locanname.",
	"Method": "int getIndex(String qname,int getIndex,String uri,String localName){\r\n    int index;\r\n    if (super.getLength() < MAX) {\r\n        index = super.getIndex(uri, localName);\r\n        return index;\r\n    }\r\n    m_buff.setLength(0);\r\n    m_buff.append('{').append(uri).append('}').append(localName);\r\n    String key = m_buff.toString();\r\n    Integer i = (Integer) m_indexFromQName.get(key);\r\n    if (i == null)\r\n        index = -1;\r\n    else\r\n        index = i.intValue();\r\n    return index;\r\n}"
}, {
	"Path": "jadx.core.utils.BlockUtils.traverseWhileDominates",
	"Comment": "search for first node which not dominated by dom, starting from start",
	"Method": "BlockNode traverseWhileDominates(BlockNode dom,BlockNode start){\r\n    for (BlockNode node : start.getCleanSuccessors()) {\r\n        if (!node.isDominator(dom)) {\r\n            return node;\r\n        } else {\r\n            BlockNode out = traverseWhileDominates(dom, node);\r\n            if (out != null) {\r\n                return out;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "hudson.ExtensionList.clearLegacyInstances",
	"Comment": "exposed for the test harness to clear all legacy extension instances.",
	"Method": "void clearLegacyInstances(){\r\n    staticLegacyInstances.clear();\r\n}"
}, {
	"Path": "com.iluwatar.semaphore.Customer.run",
	"Comment": "the customer repeatedly takes fruit from the fruitshop until no fruitremains.",
	"Method": "void run(){\r\n    while (fruitShop.countFruit() > 0) {\r\n        FruitBowl bowl = fruitShop.takeBowl();\r\n        Fruit fruit;\r\n        if (bowl != null && (fruit = bowl.take()) != null) {\r\n            LOGGER.info(\"{} took an {}\", name, fruit);\r\n            fruitBowl.put(fruit);\r\n            fruitShop.returnBowl(bowl);\r\n        }\r\n    }\r\n    LOGGER.info(\"{} took {}\", name, fruitBowl);\r\n}"
}, {
	"Path": "org.apache.xml.utils.SuballocatedIntVector.elementAt",
	"Comment": "get the nth element. this is often at the innermost loop of anapplication, so performance is critical.",
	"Method": "int elementAt(int i){\r\n    if (i < m_blocksize)\r\n        return m_map0[i];\r\n    return m_map[i >>> m_SHIFT][i & m_MASK];\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XRTreeFragSelectWrapper.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    ((Expression) m_obj).fixupVariables(vars, globalsSize);\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.getDTMManager",
	"Comment": "get an instance of the dtmmanager.since a node iterator may be passed without a dtmmanager, this allows the caller to easily get the dtmmanager using just the iterator.",
	"Method": "DTMManager getDTMManager(){\r\n    return m_manager;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.removeAllElements",
	"Comment": "inserts the specified node in this vector at the specified index.each component in this vector with an index greater or equal tothe specified index is shifted upward to have an index one greaterthan the value it had previously.",
	"Method": "void removeAllElements(){\r\n    if (null == m_map)\r\n        return;\r\n    for (int i = 0; i < m_firstFree; i++) {\r\n        m_map[i] = null;\r\n    }\r\n    m_firstFree = 0;\r\n}"
}, {
	"Path": "hudson.util.ClasspathBuilder.addAll",
	"Comment": "adds all the files that matches the given glob in the directory.",
	"Method": "ClasspathBuilder addAll(FilePath base,String glob){\r\n    for (FilePath item : base.list(glob)) add(item);\r\n    return this;\r\n}"
}, {
	"Path": "hudson.WebAppMain.recordBootAttempt",
	"Comment": "to assist boot failure script, record the number of boot attempts.this file gets deleted in case of successful boot.",
	"Method": "void recordBootAttempt(File home){\r\n    try (OutputStream o = Files.newOutputStream(BootFailure.getBootFailureFile(home).toPath(), StandardOpenOption.CREATE, StandardOpenOption.APPEND)) {\r\n        o.write((new Date().toString() + System.getProperty(\"line.separator\", \"\\n\")).toString().getBytes());\r\n    } catch (IOException | InvalidPathException e) {\r\n        LOGGER.log(WARNING, \"Failed to record boot attempts\", e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.res.XResourceBundle.getResourceSuffix",
	"Comment": "return the resource file suffic for the indicated localefor most locales, this will be based the language code.howeverfor chinese, we do distinguish between taiwan and prc",
	"Method": "String getResourceSuffix(Locale locale){\r\n    String lang = locale.getLanguage();\r\n    String country = locale.getCountry();\r\n    String variant = locale.getVariant();\r\n    String suffix = \"_\" + locale.getLanguage();\r\n    if (lang.equals(\"zh\"))\r\n        suffix += \"_\" + country;\r\n    if (country.equals(\"JP\"))\r\n        suffix += \"_\" + country + \"_\" + variant;\r\n    return suffix;\r\n}"
}, {
	"Path": "com.iluwatar.lazy.loading.AbstractHolderTest.testGetHeavy",
	"Comment": "this test shows that the heavy field is not instantiated until the method getheavy is called",
	"Method": "void testGetHeavy(){\r\n    assertTimeout(ofMillis(3000), () -> {\r\n        assertNull(getInternalHeavyValue());\r\n        assertNotNull(getHeavy());\r\n        assertNotNull(getInternalHeavyValue());\r\n        assertSame(getHeavy(), getInternalHeavyValue());\r\n    });\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToStream.ensureAttributesNamespaceIsDeclared",
	"Comment": "makes sure that the namespace uri for the given qualified attribute nameis declared.",
	"Method": "String ensureAttributesNamespaceIsDeclared(String ns,String localName,String rawName){\r\n    if (ns != null && ns.length() > 0) {\r\n        int index = 0;\r\n        String prefixFromRawName = (index = rawName.indexOf(\":\")) < 0 ? \"\" : rawName.substring(0, index);\r\n        if (index > 0) {\r\n            String uri = m_prefixMap.lookupNamespace(prefixFromRawName);\r\n            if (uri != null && uri.equals(ns)) {\r\n                return null;\r\n            } else {\r\n                this.startPrefixMapping(prefixFromRawName, ns, false);\r\n                this.addAttribute(\"http://www.w3.org/2000/xmlns/\", prefixFromRawName, \"xmlns:\" + prefixFromRawName, \"CDATA\", ns, false);\r\n                return prefixFromRawName;\r\n            }\r\n        } else {\r\n            String prefix = m_prefixMap.lookupPrefix(ns);\r\n            if (prefix == null) {\r\n                prefix = m_prefixMap.generateNextPrefix();\r\n                this.startPrefixMapping(prefix, ns, false);\r\n                this.addAttribute(\"http://www.w3.org/2000/xmlns/\", prefix, \"xmlns:\" + prefix, \"CDATA\", ns, false);\r\n            }\r\n            return prefix;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "hudson.security.HudsonPrivateSecurityRealm.loginAndTakeBack",
	"Comment": "lets the current user silently login as the given user and report back accordingly.",
	"Method": "void loginAndTakeBack(StaplerRequest req,StaplerResponse rsp,User u){\r\n    HttpSession session = req.getSession(false);\r\n    if (session != null) {\r\n        session.invalidate();\r\n    }\r\n    req.getSession(true);\r\n    Authentication a = new UsernamePasswordAuthenticationToken(u.getId(), req.getParameter(\"password1\"));\r\n    a = this.getSecurityComponents().manager.authenticate(a);\r\n    SecurityContextHolder.getContext().setAuthentication(a);\r\n    SecurityListener.fireLoggedIn(u.getId());\r\n    req.getView(this, \"success.jelly\").forward(req, rsp);\r\n}"
}, {
	"Path": "jenkins.slaves.RemotingVersionInfo.getEmbeddedVersion",
	"Comment": "returns a version which is embedded into the jenkins core.note that this version may differ from one which is being really used in jenkins.",
	"Method": "VersionNumber getEmbeddedVersion(){\r\n    return EMBEDDED_VERSION;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.hasTextLitOnly",
	"Comment": "tell if this element only has one text child, for optimization purposes.",
	"Method": "boolean hasTextLitOnly(){\r\n    return m_hasTextLitOnly;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncLast.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    XNumber xnum = new XNumber((double) getCountOfContextNodeList(xctxt));\r\n    return xnum;\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.addSystemPackageRoot",
	"Comment": "adds a package root to the list of packages which must be loaded on theparent loader.all subpackages are also included.",
	"Method": "void addSystemPackageRoot(String packageRoot){\r\n    systemPackages.addElement(packageRoot + (packageRoot.endsWith(\".\") ? \"\" : \".\"));\r\n}"
}, {
	"Path": "org.apache.xpath.functions.Function2Args.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    super.fixupVariables(vars, globalsSize);\r\n    if (null != m_arg1)\r\n        m_arg1.fixupVariables(vars, globalsSize);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMNodeIterator.detach",
	"Comment": "detaches the nodeiterator from the set which it iterated over,releasing any computational resources and placing the iterator inthe invalid state.",
	"Method": "void detach(){\r\n    valid = false;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemVariable.recompose",
	"Comment": "this function is called during recomposition tocontrol how this element is composed.",
	"Method": "void recompose(StylesheetRoot root){\r\n    root.recomposeVariables(this);\r\n}"
}, {
	"Path": "jenkins.util.MemoryReductionUtil.getPresizedMutableMap",
	"Comment": "returns a mutable hashmap presized to hold the given number of elements without needing to resize.",
	"Method": "Map getPresizedMutableMap(int elementCount){\r\n    return new HashMap(preallocatedHashmapCapacity(elementCount));\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.addPathComponent",
	"Comment": "add a path component.this simply adds the file, unlike addpathelementit does not open jar files and load files fromtheir classpath entry in the manifest file.",
	"Method": "void addPathComponent(File file){\r\n    if (pathComponents.contains(file)) {\r\n        return;\r\n    }\r\n    pathComponents.addElement(file);\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.COM.util.Factory.appendStacktrace",
	"Comment": "append the stack trace available via caughtexception to the stack traceof tobethrown. the combined stack trace is reassigned to tobethrown",
	"Method": "void appendStacktrace(Exception caughtException,Throwable toBeThrown){\r\n    StackTraceElement[] upperTrace = caughtException.getStackTrace();\r\n    StackTraceElement[] lowerTrace = toBeThrown.getStackTrace();\r\n    StackTraceElement[] trace = new StackTraceElement[upperTrace.length + lowerTrace.length];\r\n    System.arraycopy(upperTrace, 0, trace, lowerTrace.length, upperTrace.length);\r\n    System.arraycopy(lowerTrace, 0, trace, 0, lowerTrace.length);\r\n    toBeThrown.setStackTrace(trace);\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLStringDefault.lastIndexOf",
	"Comment": "returns the index within this string of the last occurrence ofthe specified substring.",
	"Method": "int lastIndexOf(int ch,int lastIndexOf,int ch,int fromIndex,int lastIndexOf,String str,int lastIndexOf,String str,int fromIndex){\r\n    return m_str.lastIndexOf(str, fromIndex);\r\n}"
}, {
	"Path": "hudson.model.Run.getTimestampString",
	"Comment": "gets the string that says how long since this build has started.",
	"Method": "String getTimestampString(){\r\n    long duration = new GregorianCalendar().getTimeInMillis() - timestamp;\r\n    return Util.getPastTimeString(duration);\r\n}"
}, {
	"Path": "org.java_websocket.SSLSocketChannel2.read",
	"Comment": "blocks when in blocking mode until at least one byte has been decoded.when not in blocking mode 0 may be returned.",
	"Method": "int read(ByteBuffer dst){\r\n    while (true) {\r\n        if (!dst.hasRemaining())\r\n            return 0;\r\n        if (!isHandShakeComplete()) {\r\n            if (isBlocking()) {\r\n                while (!isHandShakeComplete()) {\r\n                    processHandshake();\r\n                }\r\n            } else {\r\n                processHandshake();\r\n                if (!isHandShakeComplete()) {\r\n                    return 0;\r\n                }\r\n            }\r\n        }\r\n        int purged = readRemaining(dst);\r\n        if (purged != 0)\r\n            return purged;\r\n        assert (inData.position() == 0);\r\n        inData.clear();\r\n        if (!inCrypt.hasRemaining())\r\n            inCrypt.clear();\r\n        else\r\n            inCrypt.compact();\r\n        if (isBlocking() || readEngineResult.getStatus() == Status.BUFFER_UNDERFLOW)\r\n            if (socketChannel.read(inCrypt) == -1) {\r\n                return -1;\r\n            }\r\n        inCrypt.flip();\r\n        unwrap();\r\n        int transfered = transfereTo(inData, dst);\r\n        if (transfered == 0 && isBlocking()) {\r\n            continue;\r\n        }\r\n        return transfered;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.DOM2Helper.supportsSAX",
	"Comment": "returns true if the dom implementation handled by this helpersupports the sax contenthandler interface.",
	"Method": "boolean supportsSAX(){\r\n    return true;\r\n}"
}, {
	"Path": "hudson.model.DependencyGraph.putComputationalData",
	"Comment": "adds data which is useful for the time when the dependency graph is built up.all this data will be cleaned once the dependency graph creation has finished.",
	"Method": "void putComputationalData(Class<T> key,T value){\r\n    this.computationalData.put(key, value);\r\n}"
}, {
	"Path": "hudson.PluginManager.disablePlugins",
	"Comment": "disable a list of plugins using a strategy for their dependants plugins.",
	"Method": "List<PluginWrapper.PluginDisableResult> disablePlugins(PluginWrapper.PluginDisableStrategy strategy,List<String> plugins){\r\n    List<PluginWrapper.PluginDisableResult> results = new ArrayList(plugins.size());\r\n    for (String pluginName : plugins) {\r\n        PluginWrapper plugin = this.getPlugin(pluginName);\r\n        if (plugin == null) {\r\n            results.add(new PluginWrapper.PluginDisableResult(pluginName, PluginWrapper.PluginDisableStatus.NO_SUCH_PLUGIN, Messages.PluginWrapper_NoSuchPlugin(pluginName)));\r\n        } else {\r\n            results.add(plugin.disable(strategy));\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.CharInfo.setASCIIattrDirty",
	"Comment": "if the character is in the ascii range thenmark it as needing replacement witha string on output if it occurs in a attribute value.",
	"Method": "void setASCIIattrDirty(int j){\r\n    if (0 <= j && j < ASCII_MAX) {\r\n        shouldMapAttrChar_ASCII[j] = true;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncExtFunction.exprSetParent",
	"Comment": "set the parent node.for an extension function, we also need to set the parentnode for all argument expressions.",
	"Method": "void exprSetParent(ExpressionNode n){\r\n    super.exprSetParent(n);\r\n    int nArgs = m_argVec.size();\r\n    for (int i = 0; i < nArgs; i++) {\r\n        Expression arg = (Expression) m_argVec.elementAt(i);\r\n        arg.exprSetParent(n);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.XML11Char.isXML11Content",
	"Comment": "returns true if the specified character can be considered content in an external parsed entity.",
	"Method": "boolean isXML11Content(int c){\r\n    return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_CONTENT) != 0) || (0x10000 <= c && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "hudson.model.ParameterDefinition.copyWithDefaultValue",
	"Comment": "create a new instance of this parameter definition and use the passedparameter value as the default value.",
	"Method": "ParameterDefinition copyWithDefaultValue(ParameterValue defaultValue){\r\n    return this;\r\n}"
}, {
	"Path": "Searches.IterativeBinarySearch.find",
	"Comment": "this method implements an iterative version of binary search algorithm",
	"Method": "int find(T[] array,T key){\r\n    int l, r, k, cmp;\r\n    l = 0;\r\n    r = array.length - 1;\r\n    while (l <= r) {\r\n        k = (l + r) / 2;\r\n        cmp = key.compareTo(array[k]);\r\n        if (cmp == 0) {\r\n            return k;\r\n        } else if (cmp < 0) {\r\n            r = --k;\r\n        } else {\r\n            l = ++k;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "hudson.views.ListViewColumn.shownByDefault",
	"Comment": "whether this column will be shown by default.the default implementation is true.",
	"Method": "boolean shownByDefault(){\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.accept",
	"Comment": "accept a visitor and call the appropriate method for this class.",
	"Method": "boolean accept(XSLTVisitor visitor){\r\n    return visitor.visitInstruction(this);\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncSubstringAfter.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    XMLString s1 = m_arg0.execute(xctxt).xstr();\r\n    XMLString s2 = m_arg1.execute(xctxt).xstr();\r\n    int index = s1.indexOf(s2);\r\n    return (-1 == index) ? XString.EMPTYSTRING : (XString) s1.substring(index + s2.length());\r\n}"
}, {
	"Path": "org.apache.xpath.axes.NodeSequence.cacheComplete",
	"Comment": "if this nodesequence has a cache, and that cache is fully populated then this method returns true, otherwiseif there is no cache or it is not complete it returns false.",
	"Method": "boolean cacheComplete(){\r\n    final boolean complete;\r\n    if (m_cache != null) {\r\n        complete = m_cache.isComplete();\r\n    } else {\r\n        complete = false;\r\n    }\r\n    return complete;\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.getNode",
	"Comment": "gets the agent node of the give name, hooked under this jenkins.",
	"Method": "Node getNode(String name){\r\n    return nodes.getNode(name);\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerIdentityImpl.setErrorListener",
	"Comment": "set the error event listener in effect for the transformation.",
	"Method": "void setErrorListener(ErrorListener listener){\r\n    if (listener == null)\r\n        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_NULL_ERROR_HANDLER, null));\r\n    else\r\n        m_errorListener = listener;\r\n}"
}, {
	"Path": "ciphers.AES.decrypt",
	"Comment": "decrypts the ciphertext with the key and returns the result",
	"Method": "BigInteger decrypt(BigInteger cipherText,BigInteger key){\r\n    BigInteger[] roundKeys = keyExpansion(key);\r\n    cipherText = addRoundKey(cipherText, roundKeys[10]);\r\n    cipherText = shiftRowsDec(cipherText);\r\n    cipherText = subBytesDec(cipherText);\r\n    for (int i = 9; i > 0; i--) {\r\n        cipherText = addRoundKey(cipherText, roundKeys[i]);\r\n        cipherText = mixColumnsDec(cipherText);\r\n        cipherText = shiftRowsDec(cipherText);\r\n        cipherText = subBytesDec(cipherText);\r\n    }\r\n    cipherText = addRoundKey(cipherText, roundKeys[0]);\r\n    return cipherText;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.TemplateList.setNamedTemplates",
	"Comment": "set table of named templates.these are keyed on string macro names, and holding valuesthat are template elements in the xsl dom tree.",
	"Method": "void setNamedTemplates(Hashtable v){\r\n    m_namedTemplates = v;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.getPrefixTable",
	"Comment": "return a table that contains all prefixes availablewithin this element context.",
	"Method": "List getPrefixTable(){\r\n    return m_prefixTable;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.StylesheetRoot.getExtensions",
	"Comment": "get the vector of extension namespaces. used to providethe extensions table access to a list of extensionnamespaces encountered during composition of a stylesheet.",
	"Method": "Vector getExtensions(){\r\n    return m_extNsMgr != null ? m_extNsMgr.getExtensions() : null;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.setOutputPropertyDefault",
	"Comment": "set the default value for an output property, but this doesnot impact any explicitly set value.",
	"Method": "void setOutputPropertyDefault(String name,String val){\r\n    setProp(name, val, true);\r\n}"
}, {
	"Path": "com.iluwatar.model.view.controller.GiantModelTest.testSetFatigue",
	"Comment": "verify if the fatigue level is set properly though the constructor and setter",
	"Method": "void testSetFatigue(){\r\n    final GiantModel model = new GiantModel(Health.HEALTHY, Fatigue.ALERT, Nourishment.SATURATED);\r\n    assertEquals(Fatigue.ALERT, model.getFatigue());\r\n    for (final Fatigue fatigue : Fatigue.values()) {\r\n        model.setFatigue(fatigue);\r\n        assertEquals(fatigue, model.getFatigue());\r\n        assertEquals(\"The giant looks healthy, \" + fatigue.toString() + \" and saturated.\", model.toString());\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.TemplateList.getNamedTemplates",
	"Comment": "get table of named templates.these are keyed on template names, and holding valuesthat are template elements.",
	"Method": "Hashtable getNamedTemplates(){\r\n    return m_namedTemplates;\r\n}"
}, {
	"Path": "hudson.PluginManagerCheckUpdateCenterTest.updateSiteWrongJsonTest",
	"Comment": "check if the page contains the right message after checking an update site with an url that returns a wrong json.",
	"Method": "void updateSiteWrongJsonTest(){\r\n    checkUpdateSite(Jenkins.get().getRootUrl() + \"updateSiteWrongJson/getJson\", \"JSONException: Unquotted string 'wrongjson'\", false);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.getDeclaredPrefixes",
	"Comment": "return a table that contains all prefixes availablewithin this element context.",
	"Method": "List getDeclaredPrefixes(){\r\n    return m_declaredPrefixes;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.addNode",
	"Comment": "add a node to the nodesetdtm. not all types of nodesetdtms support thisoperation",
	"Method": "void addNode(int n){\r\n    if (!m_mutable)\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null));\r\n    this.addElement(n);\r\n}"
}, {
	"Path": "hudson.model.Computer.getWorkspaceList",
	"Comment": "gets the object that coordinates the workspace allocation on this computer.",
	"Method": "WorkspaceList getWorkspaceList(){\r\n    return workspaceList;\r\n}"
}, {
	"Path": "hudson.model.AbstractProjectTest.pollingAndBuildExclusion",
	"Comment": "unless the concurrent build option is enabled, polling and build shouldbe mutually exclusive to avoid allocating unnecessary workspaces.",
	"Method": "void pollingAndBuildExclusion(){\r\n    final OneShotEvent sync = new OneShotEvent();\r\n    final FreeStyleProject p = j.createFreeStyleProject();\r\n    FreeStyleBuild b1 = j.buildAndAssertSuccess(p);\r\n    p.setScm(new NullSCM() {\r\n        @Override\r\n        public boolean pollChanges(AbstractProject project, Launcher launcher, FilePath workspace, TaskListener listener) {\r\n            try {\r\n                sync.block();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return true;\r\n        }\r\n        private Object writeReplace() {\r\n            return new Object();\r\n        }\r\n        @Override\r\n        public boolean requiresWorkspaceForPolling() {\r\n            return true;\r\n        }\r\n        @Override\r\n        public SCMDescriptor<?> getDescriptor() {\r\n            return new SCMDescriptor<SCM>(null) {\r\n            };\r\n        }\r\n    });\r\n    Thread t = new Thread() {\r\n        @Override\r\n        public void run() {\r\n            p.pollSCMChanges(StreamTaskListener.fromStdout());\r\n        }\r\n    };\r\n    try {\r\n        t.start();\r\n        Future<FreeStyleBuild> f = p.scheduleBuild2(0);\r\n        Thread.sleep(3000);\r\n        sync.signal();\r\n        FreeStyleBuild b2 = j.assertBuildStatusSuccess(f);\r\n        assertEquals(b1.getWorkspace(), b2.getWorkspace());\r\n    } finally {\r\n        t.interrupt();\r\n    }\r\n}"
}, {
	"Path": "hudson.model.AbstractProjectTest.pollingAndBuildExclusion",
	"Comment": "unless the concurrent build option is enabled, polling and build shouldbe mutually exclusive to avoid allocating unnecessary workspaces.",
	"Method": "void pollingAndBuildExclusion(){\r\n    try {\r\n        sync.block();\r\n    } catch (InterruptedException e) {\r\n        e.printStackTrace();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "hudson.model.AbstractProjectTest.pollingAndBuildExclusion",
	"Comment": "unless the concurrent build option is enabled, polling and build shouldbe mutually exclusive to avoid allocating unnecessary workspaces.",
	"Method": "void pollingAndBuildExclusion(){\r\n    return new Object();\r\n}"
}, {
	"Path": "hudson.model.AbstractProjectTest.pollingAndBuildExclusion",
	"Comment": "unless the concurrent build option is enabled, polling and build shouldbe mutually exclusive to avoid allocating unnecessary workspaces.",
	"Method": "void pollingAndBuildExclusion(){\r\n    return true;\r\n}"
}, {
	"Path": "hudson.model.AbstractProjectTest.pollingAndBuildExclusion",
	"Comment": "unless the concurrent build option is enabled, polling and build shouldbe mutually exclusive to avoid allocating unnecessary workspaces.",
	"Method": "void pollingAndBuildExclusion(){\r\n    return new SCMDescriptor<SCM>(null) {\r\n    };\r\n}"
}, {
	"Path": "hudson.model.AbstractProjectTest.pollingAndBuildExclusion",
	"Comment": "unless the concurrent build option is enabled, polling and build shouldbe mutually exclusive to avoid allocating unnecessary workspaces.",
	"Method": "void pollingAndBuildExclusion(){\r\n    p.pollSCMChanges(StreamTaskListener.fromStdout());\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMManagerDefault.getDTM",
	"Comment": "return the dtm object containing a representation of this node.",
	"Method": "DTM getDTM(Source source,boolean unique,DTMWSFilter whiteSpaceFilter,boolean incremental,boolean doIndexing,DTM getDTM,int nodeHandle){\r\n    try {\r\n        return m_dtms[nodeHandle >>> IDENT_DTM_NODE_BITS];\r\n    } catch (java.lang.ArrayIndexOutOfBoundsException e) {\r\n        if (nodeHandle == DTM.NULL)\r\n            return null;\r\n        else\r\n            throw e;\r\n    }\r\n}"
}, {
	"Path": "hudson.lifecycle.WindowsInstallerLink.copy",
	"Comment": "copies a single resource into the target folder, by the given name, and handle errors gracefully.",
	"Method": "void copy(StaplerRequest req,StaplerResponse rsp,File dir,URL src,String name){\r\n    try {\r\n        FileUtils.copyURLToFile(src, new File(dir, name));\r\n    } catch (IOException e) {\r\n        LOGGER.log(Level.SEVERE, \"Failed to copy \" + name, e);\r\n        sendError(\"Failed to copy \" + name + \": \" + e.getMessage(), req, rsp);\r\n        throw new AbortException();\r\n    }\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.loadResource",
	"Comment": "returns a stream to read the requested resource name from this loader.",
	"Method": "InputStream loadResource(String name){\r\n    InputStream stream = null;\r\n    Enumeration e = pathComponents.elements();\r\n    while (e.hasMoreElements() && stream == null) {\r\n        File pathComponent = (File) e.nextElement();\r\n        stream = getResourceStream(pathComponent, name);\r\n    }\r\n    return stream;\r\n}"
}, {
	"Path": "jenkins.security.apitoken.ApiTokenStats.keepLastUpdatedUnique",
	"Comment": "in case of duplicate entries, we keep only the last updated element",
	"Method": "void keepLastUpdatedUnique(){\r\n    Map<String, SingleTokenStats> temp = new HashMap();\r\n    this.tokenStats.forEach(candidate -> {\r\n        SingleTokenStats current = temp.get(candidate.tokenUuid);\r\n        if (current == null) {\r\n            temp.put(candidate.tokenUuid, candidate);\r\n        } else {\r\n            int comparison = SingleTokenStats.COMP_BY_LAST_USE_THEN_COUNTER.compare(current, candidate);\r\n            if (comparison < 0) {\r\n                temp.put(candidate.tokenUuid, candidate);\r\n            }\r\n        }\r\n    });\r\n    this.tokenStats = new ArrayList(temp.values());\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM2.getNextNamespaceNode2",
	"Comment": "return the next namespace node following the given base node.",
	"Method": "int getNextNamespaceNode2(int baseID){\r\n    int type;\r\n    while ((type = _type2(++baseID)) == DTM.ATTRIBUTE_NODE) ;\r\n    if (type == DTM.NAMESPACE_NODE)\r\n        return baseID;\r\n    else\r\n        return NULL;\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XString.isSpace",
	"Comment": "returns whether the specified ch conforms to the xml 1.0 definitionof whitespace.refer to the definition of s for details.",
	"Method": "boolean isSpace(char ch){\r\n    return XMLCharacterRecognizer.isWhiteSpace(ch);\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.util.PackageInfoLookupTest.testReflectionSupportInJarFile",
	"Comment": "verify that reflectionsupport annotation can be parsed from a compiled jar file.",
	"Method": "void testReflectionSupportInJarFile(){\r\n    String jarFilePath = getResourceAsFile(\"packageInfoLookupTest.jar\");\r\n    options.fileUtil().getClassPathEntries().add(jarFilePath);\r\n    CompilationUnit unit = translateType(\"com.google.test.packageInfoLookupTest.A\", \"package com.google.test.packageInfoLookupTest; public class A {}\");\r\n    PackageInfoLookup packageInfoLookup = unit.getEnv().options().getPackageInfoLookup();\r\n    assertSame(ReflectionSupport.Level.FULL, packageInfoLookup.getReflectionSupportLevel(unit.getPackage().getName().toString()));\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.DOM3SerializerImpl.setNodeFilter",
	"Comment": "sets a lsserializerfilter on the dom level 3 serializer to filter nodesduring serialization.this interface is a public api.",
	"Method": "void setNodeFilter(LSSerializerFilter filter){\r\n    fSerializerFilter = filter;\r\n}"
}, {
	"Path": "jenkins.model.IdStrategy.legacyFilenameOf",
	"Comment": "converts an id into a name for use as a filename.legacy implementation used only for migrating old style config files to the new implementation.",
	"Method": "String legacyFilenameOf(String id,String legacyFilenameOf,String id,String legacyFilenameOf,String id){\r\n    return filenameOf(id);\r\n}"
}, {
	"Path": "com.sun.jna.platform.dnd.DragHandler.dragGestureRecognized",
	"Comment": "called when a user drag gesture is recognized.this method is responsible for initiating the drag operation.",
	"Method": "void dragGestureRecognized(DragGestureEvent e){\r\n    if ((e.getDragAction() & supportedActions) != 0 && canDrag(e)) {\r\n        setModifiers(e.getTriggerEvent().getModifiersEx() & KEY_MASK);\r\n        Transferable transferable = getTransferable(e);\r\n        if (transferable == null)\r\n            return;\r\n        try {\r\n            Point srcOffset = new Point(0, 0);\r\n            Icon icon = getDragIcon(e, srcOffset);\r\n            Point origin = e.getDragOrigin();\r\n            imageOffset = new Point(srcOffset.x - origin.x, srcOffset.y - origin.y);\r\n            Icon dragIcon = scaleDragIcon(icon, imageOffset);\r\n            Cursor cursor = null;\r\n            if (dragIcon != null && DragSource.isDragImageSupported()) {\r\n                GraphicsConfiguration gc = e.getComponent().getGraphicsConfiguration();\r\n                e.startDrag(cursor, createDragImage(gc, dragIcon), imageOffset, transferable, this);\r\n            } else {\r\n                if (dragIcon != null) {\r\n                    Point screen = dragSource.getLocationOnScreen();\r\n                    screen.translate(origin.x, origin.y);\r\n                    Point cursorOffset = new Point(-imageOffset.x, -imageOffset.y);\r\n                    ghost = new GhostedDragImage(dragSource, dragIcon, getImageLocation(screen), cursorOffset);\r\n                    ghost.setAlpha(ghostAlpha);\r\n                }\r\n                e.startDrag(cursor, transferable, this);\r\n            }\r\n            dragStarted(e);\r\n            moved = false;\r\n            e.getDragSource().addDragSourceMotionListener(this);\r\n            DragHandler.transferable = transferable;\r\n        } catch (InvalidDnDOperationException ex) {\r\n            if (ghost != null) {\r\n                ghost.dispose();\r\n                ghost = null;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jna.CalcAndroidVersion.setTargetProperty",
	"Comment": "targetproperty receives the name of the property, that should take thenew property",
	"Method": "void setTargetProperty(String targetProperty){\r\n    this.targetProperty = targetProperty;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.getPrefix",
	"Comment": "get a prefix either from the qname or from the uri mapping, or just makeone up!",
	"Method": "String getPrefix(int nodeHandle,String getPrefix,String qname,String uri){\r\n    String prefix;\r\n    int uriIndex = -1;\r\n    if (null != uri && uri.length() > 0) {\r\n        do {\r\n            uriIndex = m_prefixMappings.indexOf(uri, ++uriIndex);\r\n        } while ((uriIndex & 0x01) == 0);\r\n        if (uriIndex >= 0) {\r\n            prefix = (String) m_prefixMappings.elementAt(uriIndex - 1);\r\n        } else if (null != qname) {\r\n            int indexOfNSSep = qname.indexOf(':');\r\n            if (qname.equals(\"xmlns\"))\r\n                prefix = \"\";\r\n            else if (qname.startsWith(\"xmlns:\"))\r\n                prefix = qname.substring(indexOfNSSep + 1);\r\n            else\r\n                prefix = (indexOfNSSep > 0) ? qname.substring(0, indexOfNSSep) : null;\r\n        } else {\r\n            prefix = null;\r\n        }\r\n    } else if (null != qname) {\r\n        int indexOfNSSep = qname.indexOf(':');\r\n        if (indexOfNSSep > 0) {\r\n            if (qname.startsWith(\"xmlns:\"))\r\n                prefix = qname.substring(indexOfNSSep + 1);\r\n            else\r\n                prefix = qname.substring(0, indexOfNSSep);\r\n        } else {\r\n            if (qname.equals(\"xmlns\"))\r\n                prefix = \"\";\r\n            else\r\n                prefix = null;\r\n        }\r\n    } else {\r\n        prefix = null;\r\n    }\r\n    return prefix;\r\n}"
}, {
	"Path": "hudson.cli.DisablePluginCommand.printIndented",
	"Comment": "print indented the arguments with the format passed beginning with the indent passed.",
	"Method": "void printIndented(int indent,String format,String arguments){\r\n    if (indent == 0) {\r\n        stdout.format(format + \"%n\", (Object[]) arguments);\r\n    } else {\r\n        String[] newArgs = new String[arguments.length + 1];\r\n        newArgs[0] = \" \";\r\n        System.arraycopy(arguments, 0, newArgs, 1, arguments.length);\r\n        String f = \"%\" + indent + \"s\" + format + \"%n\";\r\n        stdout.format(f, newArgs);\r\n    }\r\n}"
}, {
	"Path": "com.google.devtools.treeshaker.UnusedCodeTracker.traverseMethod",
	"Comment": "traverses the method invocation graph created by elementreferencemapper, and marks all methodsthat are reachable from the inputrootset. also covers all methods that possibly override thesecalled methods.",
	"Method": "void traverseMethod(String methodID){\r\n    MethodReferenceNode node = (MethodReferenceNode) elementReferenceMap.get(methodID);\r\n    if (node == null) {\r\n        ErrorUtil.warning(\"Encountered .class method while accessing: \" + methodID);\r\n        return;\r\n    }\r\n    if (node.reachable) {\r\n        return;\r\n    }\r\n    node.reachable = true;\r\n    markParentClasses(ElementUtil.getDeclaringClass(node.methodElement));\r\n    for (String invokedMethodID : node.invokedMethods) {\r\n        traverseMethod(invokedMethodID);\r\n    }\r\n    for (String overrideMethodID : node.overridingMethods) {\r\n        traverseMethod(overrideMethodID);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.setSourceLocator",
	"Comment": "this method is used to set the source locator, which might be used togenerated an error message.",
	"Method": "void setSourceLocator(SourceLocator locator){\r\n    m_sourceLocator = locator;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprWalker.getAnalysisBits",
	"Comment": "get the analysis bits for this walker, as defined in the walkerfactory.",
	"Method": "int getAnalysisBits(){\r\n    if (null != m_expr && m_expr instanceof PathComponent) {\r\n        return ((PathComponent) m_expr).getAnalysisBits();\r\n    }\r\n    return WalkerFactory.BIT_FILTER;\r\n}"
}, {
	"Path": "jenkins.widgets.HistoryPageFilter.setSearchString",
	"Comment": "set the search string used to narrow the filtered set of builds.",
	"Method": "void setSearchString(String searchString){\r\n    this.searchString = searchString;\r\n}"
}, {
	"Path": "Sorts.SortUtils.less",
	"Comment": "this method checks if first element is less then the other element",
	"Method": "boolean less(T v,T w){\r\n    return v.compareTo(w) < 0;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.PredicatedNodeTest.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    super.fixupVariables(vars, globalsSize);\r\n    int nPredicates = getPredicateCount();\r\n    for (int i = 0; i < nPredicates; i++) {\r\n        m_predicates[i].fixupVariables(vars, globalsSize);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.getManager",
	"Comment": "query which dtmmanager this dtm is currently being handled by.\t %revew% should this become part of the base dtm api?",
	"Method": "DTMManager getManager(){\r\n    return m_mgr;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprIteratorSimple.executeFilterExpr",
	"Comment": "execute the expression.meant for reuse by other filterexpr iterators that are not derived from this object.",
	"Method": "XNodeSet executeFilterExpr(int context,XPathContext xctxt,PrefixResolver prefixResolver,boolean isTopLevel,int stackFrame,Expression expr){\r\n    PrefixResolver savedResolver = xctxt.getNamespaceContext();\r\n    XNodeSet result = null;\r\n    try {\r\n        xctxt.pushCurrentNode(context);\r\n        xctxt.setNamespaceContext(prefixResolver);\r\n        if (isTopLevel) {\r\n            VariableStack vars = xctxt.getVarStack();\r\n            int savedStart = vars.getStackFrame();\r\n            vars.setStackFrame(stackFrame);\r\n            result = (org.apache.xpath.objects.XNodeSet) expr.execute(xctxt);\r\n            result.setShouldCacheNodes(true);\r\n            vars.setStackFrame(savedStart);\r\n        } else\r\n            result = (org.apache.xpath.objects.XNodeSet) expr.execute(xctxt);\r\n    } catch (javax.xml.transform.TransformerException se) {\r\n        throw new org.apache.xml.utils.WrappedRuntimeException(se);\r\n    } finally {\r\n        xctxt.popCurrentNode();\r\n        xctxt.setNamespaceContext(savedResolver);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.xpath.Expression.asIteratorRaw",
	"Comment": "given an select expression and a context, evaluate the xpathand return the resulting iterator, but do not clone.",
	"Method": "DTMIterator asIteratorRaw(XPathContext xctxt,int contextNode){\r\n    try {\r\n        xctxt.pushCurrentNodeAndExpression(contextNode, contextNode);\r\n        XNodeSet nodeset = (XNodeSet) execute(xctxt);\r\n        return nodeset.iterRaw();\r\n    } finally {\r\n        xctxt.popCurrentNodeAndExpression();\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.previousNode",
	"Comment": "returns the previous node in the set and moves the position of theiterator backwards in the set.",
	"Method": "Node previousNode(){\r\n    if (!m_cacheNodes)\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_CANNOT_ITERATE, null));\r\n    if ((m_next - 1) > 0) {\r\n        m_next--;\r\n        return this.elementAt(m_next);\r\n    } else\r\n        return null;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.XUnresolvedVariable.getTypeString",
	"Comment": "given a request type, return the equivalent string.for diagnostic purposes.",
	"Method": "String getTypeString(){\r\n    return \"XUnresolvedVariable (\" + object().getClass().getName() + \")\";\r\n}"
}, {
	"Path": "org.apache.xpath.axes.OneStepIteratorForward.setRoot",
	"Comment": "initialize the context values for this expressionafter it is cloned.",
	"Method": "void setRoot(int context,Object environment){\r\n    super.setRoot(context, environment);\r\n    m_traverser = m_cdtm.getAxisTraverser(m_axis);\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.isDocOrdered",
	"Comment": "returns true if all the nodes in the iteration well be returned in document order.",
	"Method": "boolean isDocOrdered(){\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.Encodings.isRecognizedEncoding",
	"Comment": "determines if the encoding specified was recognized by theserializer or not.",
	"Method": "boolean isRecognizedEncoding(String encoding){\r\n    EncodingInfo ei;\r\n    String normalizedEncoding = encoding.toUpperCase();\r\n    ei = (EncodingInfo) _encodingTableKeyJava.get(normalizedEncoding);\r\n    if (ei == null)\r\n        ei = (EncodingInfo) _encodingTableKeyMime.get(normalizedEncoding);\r\n    if (ei != null)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "hudson.model.ProjectTest.testRestrictedLabelOnSlaveYesQueue",
	"Comment": "job is restricted. label is on slave that can be started in cloud. job is submitted to queue, which spawns an on demand slave.",
	"Method": "void testRestrictedLabelOnSlaveYesQueue(){\r\n    FreeStyleProject proj = j.createFreeStyleProject(\"JENKINS-21394-yesqueue\");\r\n    RequiresWorkspaceSCM requiresWorkspaceScm = new RequiresWorkspaceSCM(true);\r\n    proj.setScm(requiresWorkspaceScm);\r\n    j.jenkins.setNumExecutors(0);\r\n    DummyCloudImpl2 c2 = new DummyCloudImpl2(j, 0);\r\n    c2.label = new LabelAtom(\"test-cloud-label\");\r\n    j.jenkins.clouds.add(c2);\r\n    proj.setAssignedLabel(c2.label);\r\n    SCMTrigger t = new SCMTrigger(\"@daily\", true);\r\n    t.start(proj, true);\r\n    proj.addTrigger(t);\r\n    t.new Runner().run();\r\n    Thread.sleep(1000);\r\n    assertEquals(1, j.jenkins.getQueue().getItems().length);\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.image.DescriptorDigestTest.createGoodHash",
	"Comment": "creates a 32 byte hexademical string to fit valid hash pattern.",
	"Method": "String createGoodHash(char character){\r\n    StringBuilder goodHashBuffer = new StringBuilder(64);\r\n    for (int i = 0; i < 64; i++) {\r\n        goodHashBuffer.append(character);\r\n    }\r\n    return goodHashBuffer.toString();\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.addNodes",
	"Comment": "copy nodelist members into this nodelist, adding indocument order.null references are not added.",
	"Method": "void addNodes(DTMIterator iterator){\r\n    if (!m_mutable)\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null));\r\n    if (null != iterator) {\r\n        int obj;\r\n        while (DTM.NULL != (obj = iterator.nextNode())) {\r\n            addElement(obj);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "hudson.util.jna.Kernel32Utils.waitForExitProcess",
	"Comment": "given the process handle, waits for its completion and returns the exit code.",
	"Method": "int waitForExitProcess(Pointer hProcess){\r\n    while (true) {\r\n        if (Thread.interrupted())\r\n            throw new InterruptedException();\r\n        Kernel32.INSTANCE.WaitForSingleObject(hProcess, 1000);\r\n        IntByReference exitCode = new IntByReference();\r\n        exitCode.setValue(-1);\r\n        Kernel32.INSTANCE.GetExitCodeProcess(hProcess, exitCode);\r\n        int v = exitCode.getValue();\r\n        if (v != Kernel32.STILL_ACTIVE) {\r\n            return v;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.processor.ProcessorGlobalVariableDecl.appendAndPush",
	"Comment": "append the current template element to the currenttemplate element, and then push it onto the current templateelement stack.",
	"Method": "void appendAndPush(StylesheetHandler handler,ElemTemplateElement elem){\r\n    handler.pushElemTemplateElement(elem);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.isSupported",
	"Comment": "tests whether dtm dom implementation implements a specific feature andthat feature is supported by this node.",
	"Method": "boolean isSupported(String feature,String version){\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplateElement.getLineNumber",
	"Comment": "return the line number where the current document event ends.note that this is the line position of the first characterafter the text associated with the document event.",
	"Method": "int getLineNumber(){\r\n    return m_lineNumber;\r\n}"
}, {
	"Path": "com.iluwatar.promise.Utility.downloadFile",
	"Comment": "downloads the contents from the given urlstring, and stores it in a temporary directory.",
	"Method": "String downloadFile(String urlString){\r\n    LOGGER.info(\"Downloading contents from url: {}\", urlString);\r\n    URL url = new URL(urlString);\r\n    File file = File.createTempFile(\"promise_pattern\", null);\r\n    try (Reader reader = new InputStreamReader(url.openStream());\r\n        BufferedReader bufferedReader = new BufferedReader(reader);\r\n        FileWriter writer = new FileWriter(file)) {\r\n        for (String line; (line = bufferedReader.readLine()) != null; ) {\r\n            writer.write(line);\r\n            writer.write(\"\\n\");\r\n        }\r\n        LOGGER.info(\"File downloaded at: {}\", file.getAbsolutePath());\r\n        return file.getAbsolutePath();\r\n    } catch (IOException ex) {\r\n        throw ex;\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.Arg.equals",
	"Comment": "equality function specialized for the variable name.if the argument is not a qname, it will deligate to the super class.",
	"Method": "boolean equals(Object obj){\r\n    if (obj instanceof QName) {\r\n        return m_qname.equals(obj);\r\n    } else\r\n        return super.equals(obj);\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.executeCharsToContentHandler",
	"Comment": "execute an expression in the xpath runtime context, and return theresult of the expression.",
	"Method": "void executeCharsToContentHandler(XPathContext xctxt,org.xml.sax.ContentHandler handler){\r\n    LocPathIterator clone = (LocPathIterator) m_clones.getInstance();\r\n    int current = xctxt.getCurrentNode();\r\n    clone.setRoot(current, xctxt);\r\n    int node = clone.nextNode();\r\n    DTM dtm = clone.getDTM(node);\r\n    clone.detach();\r\n    if (node != DTM.NULL) {\r\n        dtm.dispatchCharactersEvents(node, handler, false);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncNormalizeSpace.executeCharsToContentHandler",
	"Comment": "execute an expression in the xpath runtime context, and return the result of the expression.",
	"Method": "void executeCharsToContentHandler(XPathContext xctxt,ContentHandler handler){\r\n    if (Arg0IsNodesetExpr()) {\r\n        int node = getArg0AsNode(xctxt);\r\n        if (DTM.NULL != node) {\r\n            DTM dtm = xctxt.getDTM(node);\r\n            dtm.dispatchCharactersEvents(node, handler, true);\r\n        }\r\n    } else {\r\n        XObject obj = execute(xctxt);\r\n        obj.dispatchCharactersEvents(handler);\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.partialresponse.App.main",
	"Comment": "method as act client and request to server for video details.",
	"Method": "void main(String[] args){\r\n    Map<Integer, Video> videos = new HashMap();\r\n    videos.put(1, new Video(1, \"Avatar\", 178, \"epic science fiction film\", \"James Cameron\", \"English\"));\r\n    videos.put(2, new Video(2, \"Godzilla Resurgence\", 120, \"Action & drama movie|\", \"Hideaki Anno\", \"Japanese\"));\r\n    videos.put(3, new Video(3, \"Interstellar\", 169, \"Adventure & Sci-Fi\", \"Christopher Nolan\", \"English\"));\r\n    VideoResource videoResource = new VideoResource(new FieldJsonMapper(), videos);\r\n    LOGGER.info(\"Retrieving full response from server:-\");\r\n    LOGGER.info(\"Get all video information:\");\r\n    String videoDetails = videoResource.getDetails(1);\r\n    LOGGER.info(videoDetails);\r\n    LOGGER.info(\"----------------------------------------------------------\");\r\n    LOGGER.info(\"Retrieving partial response from server:-\");\r\n    LOGGER.info(\"Get video @id, @title, @director:\");\r\n    String specificFieldsDetails = videoResource.getDetails(3, \"id\", \"title\", \"director\");\r\n    LOGGER.info(specificFieldsDetails);\r\n    LOGGER.info(\"Get video @id, @length:\");\r\n    String videoLength = videoResource.getDetails(3, \"id\", \"length\");\r\n    LOGGER.info(videoLength);\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XNodeSetForDOM.object",
	"Comment": "return the original dom object that the user passed in.for use primarilyby the extension mechanism.",
	"Method": "Object object(){\r\n    return m_origObj;\r\n}"
}, {
	"Path": "jenkins.model.PeepholePermalink.exists",
	"Comment": "file.exists returns false for a link with a missing target, so for java 6 compatibility we have to use this circuitous method to see if it was created.",
	"Method": "boolean exists(File link){\r\n    File[] kids = link.getParentFile().listFiles();\r\n    return kids != null && Arrays.asList(kids).contains(link);\r\n}"
}, {
	"Path": "redis.clients.jedis.util.RedisInputStream.ensureFill",
	"Comment": "this methods assumes there are required bytes to be read. if we cannot read anymore bytes anexception is thrown to quickly ascertain that the stream was smaller than expected.",
	"Method": "void ensureFill(){\r\n    if (count >= limit) {\r\n        try {\r\n            limit = in.read(buf);\r\n            count = 0;\r\n            if (limit == -1) {\r\n                throw new JedisConnectionException(\"Unexpected end of stream.\");\r\n            }\r\n        } catch (IOException e) {\r\n            throw new JedisConnectionException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.gradle.FilesTaskTest.verifyTaskSuccess",
	"Comment": "verifies that the files task succeeded and returns the list of paths it prints out.",
	"Method": "List<Path> verifyTaskSuccess(TestProject project,String moduleName){\r\n    String taskName = \":\" + (moduleName == null ? \"\" : moduleName + \":\") + JibPlugin.FILES_TASK_NAME;\r\n    BuildResult buildResult = project.build(taskName, \"-q\");\r\n    BuildTask jibTask = buildResult.task(taskName);\r\n    Assert.assertNotNull(jibTask);\r\n    Assert.assertEquals(TaskOutcome.SUCCESS, jibTask.getOutcome());\r\n    return Splitter.on(System.lineSeparator()).omitEmptyStrings().splitToList(buildResult.getOutput()).stream().map(Paths::get).collect(Collectors.toList());\r\n}"
}, {
	"Path": "hudson.cli.CommandDuringBuild.optCurrentlyBuilding",
	"Comment": "if the command is currently running inside a build, return it. otherwise null.",
	"Method": "Run optCurrentlyBuilding(){\r\n    try {\r\n        CLICommand c = CLICommand.getCurrent();\r\n        if (c == null)\r\n            throw new IllegalStateException(\"Not executing a CLI command\");\r\n        String[] envs = c.checkChannel().call(new GetCharacteristicEnvironmentVariables());\r\n        if (envs[0] == null || envs[1] == null)\r\n            return null;\r\n        Job j = Jenkins.getActiveInstance().getItemByFullName(envs[0], Job.class);\r\n        if (j == null)\r\n            throw new IllegalArgumentException(\"No such job: \" + envs[0]);\r\n        try {\r\n            Run r = j.getBuildByNumber(Integer.parseInt(envs[1]));\r\n            if (r == null)\r\n                throw new IllegalArgumentException(\"No such build #\" + envs[1] + \" in \" + envs[0]);\r\n            if (!r.isBuilding()) {\r\n                throw new IllegalStateException(r + \" is not currently being built\");\r\n            }\r\n            return r;\r\n        } catch (NumberFormatException e) {\r\n            throw new IllegalArgumentException(\"Invalid build number: \" + envs[1]);\r\n        }\r\n    } catch (IOException | InterruptedException e) {\r\n        throw new IllegalArgumentException(\"Failed to identify the build being executed\", e);\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.registry.AuthenticationMethodRetriever.handleResponse",
	"Comment": "the request did not error, meaning that the registry does not require authentication.",
	"Method": "RegistryAuthenticator handleResponse(Response response){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemExsltFunction.compose",
	"Comment": "called after everything else has beenrecomposed, and allows the function to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n    String namespace = getName().getNamespace();\r\n    String handlerClass = sroot.getExtensionHandlerClass();\r\n    Object[] args = { namespace, sroot };\r\n    ExtensionNamespaceSupport extNsSpt = new ExtensionNamespaceSupport(namespace, handlerClass, args);\r\n    sroot.getExtensionNamespacesManager().registerExtension(extNsSpt);\r\n    if (!(namespace.equals(Constants.S_EXSLT_FUNCTIONS_URL))) {\r\n        namespace = Constants.S_EXSLT_FUNCTIONS_URL;\r\n        args = new Object[] { namespace, sroot };\r\n        extNsSpt = new ExtensionNamespaceSupport(namespace, handlerClass, args);\r\n        sroot.getExtensionNamespacesManager().registerExtension(extNsSpt);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemPI.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n    java.util.Vector vnames = sroot.getComposeState().getVariableNames();\r\n    if (null != m_name_atv)\r\n        m_name_atv.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncId.getNodesByID",
	"Comment": "fill in a list with nodes that match a space delimited list if id id references.",
	"Method": "StringVector getNodesByID(XPathContext xctxt,int docContext,String refval,StringVector usedrefs,NodeSetDTM nodeSet,boolean mayBeMore){\r\n    if (null != refval) {\r\n        String ref = null;\r\n        StringTokenizer tokenizer = new StringTokenizer(refval);\r\n        boolean hasMore = tokenizer.hasMoreTokens();\r\n        DTM dtm = xctxt.getDTM(docContext);\r\n        while (hasMore) {\r\n            ref = tokenizer.nextToken();\r\n            hasMore = tokenizer.hasMoreTokens();\r\n            if ((null != usedrefs) && usedrefs.contains(ref)) {\r\n                ref = null;\r\n                continue;\r\n            }\r\n            int node = dtm.getElementById(ref);\r\n            if (DTM.NULL != node)\r\n                nodeSet.addNodeInDocOrder(node, xctxt);\r\n            if ((null != ref) && (hasMore || mayBeMore)) {\r\n                if (null == usedrefs)\r\n                    usedrefs = new StringVector();\r\n                usedrefs.addElement(ref);\r\n            }\r\n        }\r\n    }\r\n    return usedrefs;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.utils.XMLChar.isValidIANAEncoding",
	"Comment": "returns true if the encoding name is a valid iana encoding.this method does not verify that there is a decoder availablefor this encoding, only that the characters are valid for aniana encoding name.",
	"Method": "boolean isValidIANAEncoding(String ianaEncoding){\r\n    if (ianaEncoding != null) {\r\n        int length = ianaEncoding.length();\r\n        if (length > 0) {\r\n            char c = ianaEncoding.charAt(0);\r\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\r\n                for (int i = 1; i < length; i++) {\r\n                    c = ianaEncoding.charAt(i);\r\n                    if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') && (c < '0' || c > '9') && c != '.' && c != '_' && c != '-') {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xml.utils.XML11Char.isXML11Space",
	"Comment": "returns true if the specified character is a space characteras amdended in the xml 1.1 specification.",
	"Method": "boolean isXML11Space(int c){\r\n    return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_SPACE) != 0);\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.registry.ManifestPusherIntegrationTest.testPush",
	"Comment": "tests manifest pushing. this test is a comprehensive test of push and pull.",
	"Method": "void testPush(){\r\n    localRegistry.pullAndPushToLocal(\"busybox\", \"busybox\");\r\n    Blob testLayerBlob = Blobs.from(\"crepecake\");\r\n    DescriptorDigest testLayerBlobDigest = DescriptorDigest.fromHash(\"52a9e4d4ba4333ce593707f98564fee1e6d898db0d3602408c0b2a6a424d357c\");\r\n    Blob testContainerConfigurationBlob = Blobs.from(\"12345\");\r\n    DescriptorDigest testContainerConfigurationBlobDigest = DescriptorDigest.fromHash(\"5994471abb01112afcc18159f6cc74b4f511b99806da59b3caf5a9c173cacfc5\");\r\n    V22ManifestTemplate expectedManifestTemplate = new V22ManifestTemplate();\r\n    expectedManifestTemplate.addLayer(9, testLayerBlobDigest);\r\n    expectedManifestTemplate.setContainerConfiguration(5, testContainerConfigurationBlobDigest);\r\n    RegistryClient registryClient = RegistryClient.factory(EVENT_DISPATCHER, \"localhost:5000\", \"testimage\").setAllowInsecureRegistries(true).newRegistryClient();\r\n    Assert.assertFalse(registryClient.pushBlob(testLayerBlobDigest, testLayerBlob, null));\r\n    Assert.assertFalse(registryClient.pushBlob(testContainerConfigurationBlobDigest, testContainerConfigurationBlob, null));\r\n    DescriptorDigest imageDigest = registryClient.pushManifest(expectedManifestTemplate, \"latest\");\r\n    V22ManifestTemplate manifestTemplate = registryClient.pullManifest(\"latest\", V22ManifestTemplate.class);\r\n    Assert.assertEquals(1, manifestTemplate.getLayers().size());\r\n    Assert.assertEquals(testLayerBlobDigest, manifestTemplate.getLayers().get(0).getDigest());\r\n    Assert.assertEquals(testContainerConfigurationBlobDigest, manifestTemplate.getContainerConfiguration().getDigest());\r\n    V22ManifestTemplate manifestTemplateByDigest = registryClient.pullManifest(imageDigest.toString(), V22ManifestTemplate.class);\r\n    Assert.assertEquals(JsonTemplateMapper.toBlob(manifestTemplate).writeTo(ByteStreams.nullOutputStream()).getDigest(), JsonTemplateMapper.toBlob(manifestTemplateByDigest).writeTo(ByteStreams.nullOutputStream()).getDigest());\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.CountersTable.countNode",
	"Comment": "count forward until the given node is found, or untilwe have looked to the given amount.",
	"Method": "int countNode(XPathContext support,ElemNumber numberElem,int node){\r\n    int count = 0;\r\n    Vector counters = getCounters(numberElem);\r\n    int nCounters = counters.size();\r\n    int target = numberElem.getTargetNode(support, node);\r\n    if (DTM.NULL != target) {\r\n        for (int i = 0; i < nCounters; i++) {\r\n            Counter counter = (Counter) counters.elementAt(i);\r\n            count = counter.getPreviouslyCounted(support, target);\r\n            if (count > 0)\r\n                return count;\r\n        }\r\n        count = 0;\r\n        if (m_newFound == null)\r\n            m_newFound = new NodeSetDTM(support.getDTMManager());\r\n        for (; DTM.NULL != target; target = numberElem.getPreviousNode(support, target)) {\r\n            if (0 != count) {\r\n                for (int i = 0; i < nCounters; i++) {\r\n                    Counter counter = (Counter) counters.elementAt(i);\r\n                    int cacheLen = counter.m_countNodes.size();\r\n                    if ((cacheLen > 0) && (counter.m_countNodes.elementAt(cacheLen - 1) == target)) {\r\n                        count += (cacheLen + counter.m_countNodesStartCount);\r\n                        if (cacheLen > 0)\r\n                            appendBtoFList(counter.m_countNodes, m_newFound);\r\n                        m_newFound.removeAllElements();\r\n                        return count;\r\n                    }\r\n                }\r\n            }\r\n            m_newFound.addElement(target);\r\n            count++;\r\n        }\r\n        Counter counter = new Counter(numberElem, new NodeSetDTM(support.getDTMManager()));\r\n        m_countersMade++;\r\n        appendBtoFList(counter.m_countNodes, m_newFound);\r\n        m_newFound.removeAllElements();\r\n        counters.addElement(counter);\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "hudson.model.UpdateSite.getUpdates",
	"Comment": "returns the list of plugins that are updates to currently installed ones.",
	"Method": "List<Plugin> getUpdates(){\r\n    Data data = getData();\r\n    if (data == null)\r\n        return Collections.emptyList();\r\n    List<Plugin> r = new ArrayList<Plugin>();\r\n    for (PluginWrapper pw : Jenkins.getInstance().getPluginManager().getPlugins()) {\r\n        Plugin p = pw.getUpdateInfo();\r\n        if (p != null)\r\n            r.add(p);\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprIterator.setRoot",
	"Comment": "initialize the context values for this expressionafter it is cloned.",
	"Method": "void setRoot(int context,Object environment){\r\n    super.setRoot(context, environment);\r\n    m_exprObj = FilterExprIteratorSimple.executeFilterExpr(context, m_execContext, getPrefixResolver(), getIsTopLevel(), m_stackFrame, m_expr);\r\n}"
}, {
	"Path": "com.iluwatar.tls.DateFormatCallableTestMultiThread.setup",
	"Comment": "run callable and prepare results for usage in the test methods",
	"Method": "void setup(){\r\n    DateFormatCallable callableDf = new DateFormatCallable(\"dd/MM/yyyy\", \"15/12/2015\");\r\n    ExecutorService executor = Executors.newCachedThreadPool();\r\n    Future<Result> futureResult1 = executor.submit(callableDf);\r\n    Future<Result> futureResult2 = executor.submit(callableDf);\r\n    Future<Result> futureResult3 = executor.submit(callableDf);\r\n    Future<Result> futureResult4 = executor.submit(callableDf);\r\n    try {\r\n        result[0] = futureResult1.get();\r\n        result[1] = futureResult2.get();\r\n        result[2] = futureResult3.get();\r\n        result[3] = futureResult4.get();\r\n        for (int i = 0; i < result.length; i++) {\r\n            createdDateValues[i] = convertDatesToString(result[i]);\r\n        }\r\n    } catch (Exception e) {\r\n        fail(\"Setup failed: \" + e);\r\n    }\r\n    executor.shutdown();\r\n}"
}, {
	"Path": "hudson.model.Run.onLoad",
	"Comment": "called after the build is loaded and the object is added to the build list.",
	"Method": "void onLoad(){\r\n    for (Action a : getAllActions()) {\r\n        if (a instanceof RunAction2) {\r\n            try {\r\n                ((RunAction2) a).onLoad(this);\r\n            } catch (RuntimeException x) {\r\n                LOGGER.log(WARNING, \"failed to load \" + a + \" from \" + getDataFile(), x);\r\n                removeAction(a);\r\n            }\r\n        } else if (a instanceof RunAction) {\r\n            ((RunAction) a).onLoad();\r\n        }\r\n    }\r\n    if (artifactManager != null) {\r\n        artifactManager.onLoad(this);\r\n    }\r\n}"
}, {
	"Path": "hudson.triggers.SafeTimerTask.getLogsRoot",
	"Comment": "the root path that should be used to put logs related to the tasks running in jenkins.",
	"Method": "File getLogsRoot(){\r\n    String tagsLogsPath = SystemProperties.getString(LOGS_ROOT_PATH_PROPERTY);\r\n    if (tagsLogsPath == null) {\r\n        return new File(Jenkins.get().getRootDir(), \"logs\");\r\n    } else {\r\n        Level logLevel = Level.INFO;\r\n        if (ALREADY_LOGGED) {\r\n            logLevel = Level.FINE;\r\n        }\r\n        LOGGER.log(logLevel, \"Using non default root path for tasks logging: {0}. (Beware: no automated migration if you change or remove it again)\", LOGS_ROOT_PATH_PROPERTY);\r\n        ALREADY_LOGGED = true;\r\n        return new File(tagsLogsPath);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.ObjectFactory.newInstance",
	"Comment": "create an instance of a class using the specified classloader",
	"Method": "Object newInstance(String className,ClassLoader cl,boolean doFallback){\r\n    try {\r\n        Class providerClass = findProviderClass(className, cl, doFallback);\r\n        Object instance = providerClass.newInstance();\r\n        debugPrintln(\"created new instance of \" + providerClass + \" using ClassLoader: \" + cl);\r\n        return instance;\r\n    } catch (ClassNotFoundException x) {\r\n        throw new ConfigurationError(\"Provider \" + className + \" not found\", x);\r\n    } catch (Exception x) {\r\n        throw new ConfigurationError(\"Provider \" + className + \" could not be instantiated: \" + x, x);\r\n    }\r\n}"
}, {
	"Path": "hudson.widgets.BuildHistoryWidget.getQueuedItems",
	"Comment": "returns the queue item if the owner is scheduled for execution in the queue, in reverse order",
	"Method": "List<Item> getQueuedItems(){\r\n    LinkedList<Item> list = new LinkedList<Item>();\r\n    for (Item item : Jenkins.getInstance().getQueue().getItems()) {\r\n        if (item.task == owner) {\r\n            list.addFirst(item);\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.DTMManager.getIncremental",
	"Comment": "get a flag indicating whether an incremental transform is desired",
	"Method": "boolean getIncremental(){\r\n    return m_incremental;\r\n}"
}, {
	"Path": "hudson.util.IsOverriddenTest.isOverriddenTest",
	"Comment": "test that a method is found by isoverridden even when it is inherited from an intermediate class.",
	"Method": "void isOverriddenTest(){\r\n    assertTrue(Util.isOverridden(Base.class, Derived.class, \"method\"));\r\n    assertTrue(Util.isOverridden(Base.class, Intermediate.class, \"method\"));\r\n    assertFalse(Util.isOverridden(Base.class, Base.class, \"method\"));\r\n    assertTrue(Util.isOverridden(Base.class, Intermediate.class, \"setX\", Object.class));\r\n    assertTrue(Util.isOverridden(Base.class, Intermediate.class, \"getX\"));\r\n}"
}, {
	"Path": "org.apache.xml.utils.NodeVector.popPair",
	"Comment": "pop a pair of nodes from the tail of the stack.special purpose method for transformerimpl, pushelemtemplateelement.performance critical.",
	"Method": "void popPair(){\r\n    m_firstFree -= 2;\r\n    m_map[m_firstFree] = DTM.NULL;\r\n    m_map[m_firstFree + 1] = DTM.NULL;\r\n}"
}, {
	"Path": "org.apache.xml.utils.SuballocatedIntVector.setSize",
	"Comment": "set the length of the list. this will only work to truncate the list, andeven then it has not been heavily tested and may not be trustworthy.",
	"Method": "void setSize(int sz){\r\n    if (m_firstFree > sz)\r\n        m_firstFree = sz;\r\n}"
}, {
	"Path": "hudson.cli.CLI.getCliTcpPort",
	"Comment": "if the server advertises cli endpoint, returns its location.",
	"Method": "CliPort getCliTcpPort(URL url){\r\n    if (url.getHost() == null || url.getHost().length() == 0) {\r\n        throw new IOException(\"Invalid URL: \" + url);\r\n    }\r\n    URLConnection head = url.openConnection();\r\n    try {\r\n        head.connect();\r\n    } catch (IOException e) {\r\n        throw (IOException) new IOException(\"Failed to connect to \" + url).initCause(e);\r\n    }\r\n    String h = head.getHeaderField(\"X-Jenkins-CLI-Host\");\r\n    if (h == null)\r\n        h = head.getURL().getHost();\r\n    String p1 = head.getHeaderField(\"X-Jenkins-CLI-Port\");\r\n    if (p1 == null)\r\n        p1 = head.getHeaderField(\"X-Hudson-CLI-Port\");\r\n    String p2 = head.getHeaderField(\"X-Jenkins-CLI2-Port\");\r\n    String identity = head.getHeaderField(\"X-Instance-Identity\");\r\n    flushURLConnection(head);\r\n    if (p1 == null && p2 == null) {\r\n        verifyJenkinsConnection(head);\r\n        throw new IOException(\"No X-Jenkins-CLI2-Port among \" + head.getHeaderFields().keySet());\r\n    }\r\n    if (p2 != null)\r\n        return new CliPort(new InetSocketAddress(h, Integer.parseInt(p2)), identity, 2);\r\n    else\r\n        return new CliPort(new InetSocketAddress(h, Integer.parseInt(p1)), identity, 1);\r\n}"
}, {
	"Path": "hudson.model.DependencyGraph.getTransitiveUpstream",
	"Comment": "gets all the direct and indirect upstream dependencies of the given project.",
	"Method": "Set<AbstractProject> getTransitiveUpstream(AbstractProject src){\r\n    return getTransitive(backward, src, true);\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerImpl.pushElemAttributeSet",
	"Comment": "push an executing attribute set, so we can check forrecursive attribute definitions.",
	"Method": "void pushElemAttributeSet(ElemAttributeSet attrSet){\r\n    m_attrSetStack.push(attrSet);\r\n}"
}, {
	"Path": "org.apache.xpath.axes.OneStepIterator.getNextNode",
	"Comment": "get the next node via getfirstattribute && getnextattribute.",
	"Method": "int getNextNode(){\r\n    return m_lastFetched = m_iterator.next();\r\n}"
}, {
	"Path": "hudson.model.FreestyleJobPublisherTest.testFreestyleWithFalsePublisher",
	"Comment": "execute all publishers even one of publishers return false.",
	"Method": "void testFreestyleWithFalsePublisher(){\r\n    FreeStyleProject p = j.createFreeStyleProject();\r\n    p.getPublishersList().add(new TrueFalsePublisher(true));\r\n    p.getPublishersList().add(new TrueFalsePublisher(false));\r\n    p.getPublishersList().add(new ResultWriterPublisher(\"result.txt\"));\r\n    final ArtifactArchiver artifactArchiver = new ArtifactArchiver(\"result.txt\");\r\n    artifactArchiver.setOnlyIfSuccessful(false);\r\n    p.getPublishersList().add(artifactArchiver);\r\n    FreeStyleBuild b = p.scheduleBuild2(0).get();\r\n    assertEquals(\"Build must fail, because we used FalsePublisher\", b.getResult(), Result.FAILURE);\r\n    File file = new File(b.getArtifactsDir(), \"result.txt\");\r\n    assertTrue(\"ArtifactArchiver is executed even prior publisher fails\", file.exists());\r\n    assertTrue(\"Publisher, after publisher with return false status, must see FAILURE status\", FileUtils.readFileToString(file).equals(Result.FAILURE.toString()));\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.LSSerializerImpl.canSetParameter",
	"Comment": "checks if setting a parameter to a specific value is supported.",
	"Method": "boolean canSetParameter(String name,Object value){\r\n    if (value instanceof Boolean) {\r\n        if (name.equalsIgnoreCase(DOMConstants.DOM_CDATA_SECTIONS) || name.equalsIgnoreCase(DOMConstants.DOM_COMMENTS) || name.equalsIgnoreCase(DOMConstants.DOM_ENTITIES) || name.equalsIgnoreCase(DOMConstants.DOM_INFOSET) || name.equalsIgnoreCase(DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE) || name.equalsIgnoreCase(DOMConstants.DOM_NAMESPACES) || name.equalsIgnoreCase(DOMConstants.DOM_NAMESPACE_DECLARATIONS) || name.equalsIgnoreCase(DOMConstants.DOM_SPLIT_CDATA) || name.equalsIgnoreCase(DOMConstants.DOM_WELLFORMED) || name.equalsIgnoreCase(DOMConstants.DOM_DISCARD_DEFAULT_CONTENT) || name.equalsIgnoreCase(DOMConstants.DOM_FORMAT_PRETTY_PRINT) || name.equalsIgnoreCase(DOMConstants.DOM_XMLDECL)) {\r\n            return true;\r\n        } else if (name.equalsIgnoreCase(DOMConstants.DOM_CANONICAL_FORM) || name.equalsIgnoreCase(DOMConstants.DOM_CHECK_CHAR_NORMALIZATION) || name.equalsIgnoreCase(DOMConstants.DOM_DATATYPE_NORMALIZATION) || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE_IF_SCHEMA) || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE)) {\r\n            return !((Boolean) value).booleanValue();\r\n        } else if (name.equalsIgnoreCase(DOMConstants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS)) {\r\n            return ((Boolean) value).booleanValue();\r\n        }\r\n    } else if (name.equalsIgnoreCase(DOMConstants.DOM_ERROR_HANDLER) && value == null || value instanceof DOMErrorHandler) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.isSupported",
	"Comment": "tests whether dtm dom implementation implements a specific feature andthat feature is supported by this node.",
	"Method": "boolean isSupported(String feature,String version){\r\n    return false;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.maven.JibPluginConfiguration.getUseCurrentTimestamp",
	"Comment": "gets whether or not to use the current timestamp for the container build.",
	"Method": "boolean getUseCurrentTimestamp(){\r\n    if (System.getProperty(PropertyNames.CONTAINER_USE_CURRENT_TIMESTAMP) != null) {\r\n        return Boolean.getBoolean(PropertyNames.CONTAINER_USE_CURRENT_TIMESTAMP);\r\n    }\r\n    return container.useCurrentTimestamp;\r\n}"
}, {
	"Path": "hudson.cli.QuietDownCommandTest.get",
	"Comment": "will try to get the result and retry for some time before failing.",
	"Method": "void get(FutureTask exec_task){\r\n    await().atMost(10, TimeUnit.SECONDS).until(exec_task::isDone);\r\n}"
}, {
	"Path": "com.iluwatar.mediator.PartyMemberTest.testAct",
	"Comment": "verify if a member action triggers the expected interactions with the party class",
	"Method": "void testAct(Supplier<PartyMember> memberSupplier){\r\n    final PartyMember member = memberSupplier.get();\r\n    member.act(Action.GOLD);\r\n    assertEquals(0, appender.getLogSize());\r\n    final Party party = mock(Party.class);\r\n    member.joinedParty(party);\r\n    assertEquals(member.toString() + \" joins the party\", appender.getLastMessage());\r\n    for (final Action action : Action.values()) {\r\n        member.act(action);\r\n        assertEquals(member.toString() + \" \" + action.toString(), appender.getLastMessage());\r\n        verify(party).act(member, action);\r\n    }\r\n    assertEquals(Action.values().length + 1, appender.getLogSize());\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemTemplate.recompose",
	"Comment": "this function is called during recomposition tocontrol how this element is composed.",
	"Method": "void recompose(StylesheetRoot root){\r\n    root.recomposeTemplates(this);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.AVT.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    if (null != m_parts) {\r\n        int n = m_parts.size();\r\n        for (int i = 0; i < n; i++) {\r\n            AVTPart part = (AVTPart) m_parts.elementAt(i);\r\n            part.fixupVariables(vars, globalsSize);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.balking.WashingMachine.wash",
	"Comment": "method responsible for washingif the object is in appropriate state",
	"Method": "void wash(){\r\n    synchronized (this) {\r\n        LOGGER.info(\"{}: Actual machine state: {}\", Thread.currentThread().getName(), getWashingMachineState());\r\n        if (washingMachineState == WashingMachineState.WASHING) {\r\n            LOGGER.error(\"ERROR: Cannot wash if the machine has been already washing!\");\r\n            return;\r\n        }\r\n        washingMachineState = WashingMachineState.WASHING;\r\n    }\r\n    LOGGER.info(\"{}: Doing the washing\", Thread.currentThread().getName());\r\n    this.delayProvider.executeAfterDelay(50, TimeUnit.MILLISECONDS, this::endOfWashing);\r\n}"
}, {
	"Path": "hudson.node_monitors.AbstractNodeMonitorDescriptor.monitor",
	"Comment": "performs monitoring of the given computer object.this method is invoked periodically to perform the monitoring of the computer.",
	"Method": "T monitor(Computer c,Map<Computer, T> monitor){\r\n    Map<Computer, T> data = new HashMap<Computer, T>();\r\n    for (Computer c : Jenkins.getInstance().getComputers()) {\r\n        try {\r\n            Thread.currentThread().setName(\"Monitoring \" + c.getDisplayName() + \" for \" + getDisplayName());\r\n            if (c.getChannel() == null)\r\n                data.put(c, null);\r\n            else\r\n                data.put(c, monitor(c));\r\n        } catch (RuntimeException e) {\r\n            LOGGER.log(Level.WARNING, \"Failed to monitor \" + c.getDisplayName() + \" for \" + getDisplayName(), e);\r\n        } catch (IOException e) {\r\n            LOGGER.log(Level.WARNING, \"Failed to monitor \" + c.getDisplayName() + \" for \" + getDisplayName(), e);\r\n        } catch (InterruptedException e) {\r\n            throw (InterruptedException) new InterruptedException(\"Node monitoring \" + c.getDisplayName() + \" for \" + getDisplayName() + \" aborted.\").initCause(e);\r\n        }\r\n    }\r\n    return data;\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.getExpressionContext",
	"Comment": "the the expression context for extensions for this context.",
	"Method": "ExpressionContext getExpressionContext(){\r\n    return expressionContext;\r\n}"
}, {
	"Path": "hudson.cli.FlightRecorderInputStream.clear",
	"Comment": "rewinds the record buffer and forget everything that was recorded.",
	"Method": "void clear(){\r\n    recorder = new ByteArrayRingBuffer(BUFFER_SIZE);\r\n}"
}, {
	"Path": "hudson.model.EnvironmentContributingActionTest.testOverrideAbstractBuildAndCallDeprecatedMethod",
	"Comment": "if someone wants to use overridden deprecated method, it would still work.",
	"Method": "void testOverrideAbstractBuildAndCallDeprecatedMethod(){\r\n    AbstractBuild abstractBuild = mock(AbstractBuild.class);\r\n    OverrideAbstractBuild overrideRun = new OverrideAbstractBuild();\r\n    overrideRun.buildEnvVars(abstractBuild, envVars);\r\n    assertTrue(overrideRun.wasDeprecatedMethodCalled());\r\n}"
}, {
	"Path": "hudson.FilePath.copyRecursiveTo",
	"Comment": "copies files according to a specified scanner to a target node.",
	"Method": "int copyRecursiveTo(FilePath target,int copyRecursiveTo,String fileMask,FilePath target,int copyRecursiveTo,String fileMask,String excludes,FilePath target,int copyRecursiveTo,DirScanner scanner,FilePath target,String description){\r\n    if (this.channel == target.channel) {\r\n        return act(new CopyRecursiveLocal(target, scanner));\r\n    } else if (this.channel == null) {\r\n        final Pipe pipe = Pipe.createLocalToRemote();\r\n        Future<Void> future = target.actAsync(new ReadToTar(pipe, description));\r\n        Future<Integer> future2 = actAsync(new WriteToTar(scanner, pipe));\r\n        try {\r\n            future.get();\r\n            return future2.get();\r\n        } catch (ExecutionException e) {\r\n            Throwable cause = e.getCause();\r\n            if (cause == null)\r\n                cause = e;\r\n            throw cause instanceof IOException ? (IOException) cause : new IOException(cause);\r\n        }\r\n    } else {\r\n        final Pipe pipe = Pipe.createRemoteToLocal();\r\n        Future<Integer> future = actAsync(new CopyRecursiveRemoteToLocal(pipe, scanner));\r\n        try {\r\n            readFromTar(remote + '/' + description, new File(target.remote), TarCompression.GZIP.extract(pipe.getIn()));\r\n        } catch (IOException e) {\r\n            try {\r\n                future.get(3, TimeUnit.SECONDS);\r\n                throw e;\r\n            } catch (ExecutionException x) {\r\n                e.addSuppressed(x);\r\n                throw e;\r\n            } catch (TimeoutException ignored) {\r\n                throw e;\r\n            }\r\n        }\r\n        try {\r\n            return future.get();\r\n        } catch (ExecutionException e) {\r\n            Throwable cause = e.getCause();\r\n            if (cause == null)\r\n                cause = e;\r\n            throw cause instanceof IOException ? (IOException) cause : new IOException(cause);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "hudson.util.FormValidation.validateExecutable",
	"Comment": "makes sure that the given string points to an executable file.",
	"Method": "FormValidation validateExecutable(String exe,FormValidation validateExecutable,String exe,FileValidator exeValidator){\r\n    if (!Jenkins.getInstance().hasPermission(Jenkins.ADMINISTER))\r\n        return ok();\r\n    exe = fixEmpty(exe);\r\n    if (exe == null)\r\n        return ok();\r\n    if (exe.indexOf(File.separatorChar) >= 0) {\r\n        File f = new File(exe);\r\n        if (f.exists())\r\n            return exeValidator.validate(f);\r\n        File fexe = new File(exe + \".exe\");\r\n        if (fexe.exists())\r\n            return exeValidator.validate(fexe);\r\n        return error(\"There's no such file: \" + exe);\r\n    }\r\n    String path = EnvVars.masterEnvVars.get(\"PATH\");\r\n    String tokenizedPath = \"\";\r\n    String delimiter = null;\r\n    if (path != null) {\r\n        for (String _dir : Util.tokenize(path.replace(\"\\\\\", \"\\\\\\\\\"), File.pathSeparator)) {\r\n            if (delimiter == null) {\r\n                delimiter = \", \";\r\n            } else {\r\n                tokenizedPath += delimiter;\r\n            }\r\n            tokenizedPath += _dir.replace('\\\\', '/');\r\n            File dir = new File(_dir);\r\n            File f = new File(dir, exe);\r\n            if (f.exists())\r\n                return exeValidator.validate(f);\r\n            File fexe = new File(dir, exe + \".exe\");\r\n            if (fexe.exists())\r\n                return exeValidator.validate(fexe);\r\n        }\r\n        tokenizedPath += \".\";\r\n    } else {\r\n        tokenizedPath = \"unavailable.\";\r\n    }\r\n    return error(\"There's no such executable \" + exe + \" in PATH: \" + tokenizedPath);\r\n}"
}, {
	"Path": "com.sun.jna.platform.linux.XAttrUtil.lListXAttr",
	"Comment": "list extended attributes on file but in case of symbolic link get extended attributes ofthe link itself instead of linked file.",
	"Method": "Collection<String> lListXAttr(String path,Collection<String> lListXAttr,String path,String encoding){\r\n    ssize_t retval;\r\n    byte[] listMem;\r\n    int eno = 0;\r\n    do {\r\n        retval = XAttr.INSTANCE.llistxattr(path, (byte[]) null, size_t.ZERO);\r\n        if (retval.longValue() < 0) {\r\n            eno = Native.getLastError();\r\n            throw new IOException(\"errno: \" + eno);\r\n        }\r\n        listMem = new byte[retval.intValue()];\r\n        retval = XAttr.INSTANCE.llistxattr(path, listMem, new size_t(listMem.length));\r\n        if (retval.longValue() < 0) {\r\n            eno = Native.getLastError();\r\n            if (eno != XAttr.ERANGE) {\r\n                throw new IOException(\"errno: \" + eno);\r\n            }\r\n        }\r\n    } while (retval.longValue() < 0 && eno == XAttr.ERANGE);\r\n    return splitBufferToStrings(listMem, encoding);\r\n}"
}, {
	"Path": "com.iluwatar.queue.load.leveling.MessageQueue.submitMsg",
	"Comment": "all the taskgenerator threads will call this method to insert themessages in to the blocking queue.",
	"Method": "void submitMsg(Message msg){\r\n    try {\r\n        if (null != msg) {\r\n            blkQueue.add(msg);\r\n        }\r\n    } catch (Exception e) {\r\n        LOGGER.error(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "hudson.ExceptionTest.testAjaxError",
	"Comment": "makes sure that an ajax handler error results in a fatal problem in the unit test.",
	"Method": "void testAjaxError(){\r\n    WebClient webClient = createWebClient();\r\n    WebClientUtil.ExceptionListener exceptionListener = WebClientUtil.addExceptionListener(webClient);\r\n    webClient.goTo(\"/self/ajaxError\");\r\n    ScriptException e = exceptionListener.getExpectedScriptException();\r\n    Assert.assertTrue(e.getMessage().contains(\"simulated error\"));\r\n}"
}, {
	"Path": "org.java_websocket.client.WebSocketClient.setSocket",
	"Comment": "accepts bound and unbound sockets.\tthis method must be called before connect.\tif the given socket is not yet bound it will be bound to the uri specified in the constructor.",
	"Method": "void setSocket(Socket socket){\r\n    if (this.socket != null) {\r\n        throw new IllegalStateException(\"socket has already been set\");\r\n    }\r\n    this.socket = socket;\r\n}"
}, {
	"Path": "org.apache.xpath.CachedXPathAPI.selectSingleNode",
	"Comment": "use an xpath string to select a single node.xpath namespace prefixes are resolved from the namespacenode.",
	"Method": "Node selectSingleNode(Node contextNode,String str,Node selectSingleNode,Node contextNode,String str,Node namespaceNode){\r\n    NodeIterator nl = selectNodeIterator(contextNode, str, namespaceNode);\r\n    return nl.nextNode();\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.setTailSub1",
	"Comment": "set the given node one position from the tail.special purpose method for transformerimpl, pushelemtemplateelement.performance critical.",
	"Method": "void setTailSub1(Node n){\r\n    m_map[m_firstFree - 2] = n;\r\n}"
}, {
	"Path": "hudson.cli.CLICommand.getClientSystemProperty",
	"Comment": "convenience method for subtypes to obtain the system property of the client.",
	"Method": "String getClientSystemProperty(String name){\r\n    return checkChannel().call(new GetSystemProperty(name));\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncDoclocation.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    int whereNode = getArg0AsNode(xctxt);\r\n    String fileLocation = null;\r\n    if (DTM.NULL != whereNode) {\r\n        DTM dtm = xctxt.getDTM(whereNode);\r\n        if (DTM.DOCUMENT_FRAGMENT_NODE == dtm.getNodeType(whereNode)) {\r\n            whereNode = dtm.getFirstChild(whereNode);\r\n        }\r\n        if (DTM.NULL != whereNode) {\r\n            fileLocation = dtm.getDocumentBaseURI();\r\n        }\r\n    }\r\n    return new XString((null != fileLocation) ? fileLocation : \"\");\r\n}"
}, {
	"Path": "hudson.model.AsyncPeriodicWork.getSlowLoggingLevel",
	"Comment": "returns the logging level at which previous task still executing messages is displayed.",
	"Method": "Level getSlowLoggingLevel(){\r\n    return getNormalLoggingLevel();\r\n}"
}, {
	"Path": "org.apache.xpath.axes.OneStepIteratorForward.getNextNode",
	"Comment": "get the next node via getfirstattribute && getnextattribute.",
	"Method": "int getNextNode(){\r\n    m_lastFetched = (DTM.NULL == m_lastFetched) ? m_traverser.first(m_context) : m_traverser.next(m_context, m_lastFetched);\r\n    return m_lastFetched;\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XStringForFSB.concat",
	"Comment": "concatenates the specified string to the end of this string.",
	"Method": "XMLString concat(String str){\r\n    return new XString(str().concat(str));\r\n}"
}, {
	"Path": "org.java_websocket.WebSocketImpl.decodeHandshake",
	"Comment": "returns whether the handshake phase has is completed.\tin case of a broken handshake this will be never the case.",
	"Method": "boolean decodeHandshake(ByteBuffer socketBufferNew){\r\n    ByteBuffer socketBuffer;\r\n    if (tmpHandshakeBytes.capacity() == 0) {\r\n        socketBuffer = socketBufferNew;\r\n    } else {\r\n        if (tmpHandshakeBytes.remaining() < socketBufferNew.remaining()) {\r\n            ByteBuffer buf = ByteBuffer.allocate(tmpHandshakeBytes.capacity() + socketBufferNew.remaining());\r\n            tmpHandshakeBytes.flip();\r\n            buf.put(tmpHandshakeBytes);\r\n            tmpHandshakeBytes = buf;\r\n        }\r\n        tmpHandshakeBytes.put(socketBufferNew);\r\n        tmpHandshakeBytes.flip();\r\n        socketBuffer = tmpHandshakeBytes;\r\n    }\r\n    socketBuffer.mark();\r\n    try {\r\n        HandshakeState handshakestate;\r\n        try {\r\n            if (role == Role.SERVER) {\r\n                if (draft == null) {\r\n                    for (Draft d : knownDrafts) {\r\n                        d = d.copyInstance();\r\n                        try {\r\n                            d.setParseMode(role);\r\n                            socketBuffer.reset();\r\n                            Handshakedata tmphandshake = d.translateHandshake(socketBuffer);\r\n                            if (!(tmphandshake instanceof ClientHandshake)) {\r\n                                log.trace(\"Closing due to wrong handshake\");\r\n                                closeConnectionDueToWrongHandshake(new InvalidDataException(CloseFrame.PROTOCOL_ERROR, \"wrong http function\"));\r\n                                return false;\r\n                            }\r\n                            ClientHandshake handshake = (ClientHandshake) tmphandshake;\r\n                            handshakestate = d.acceptHandshakeAsServer(handshake);\r\n                            if (handshakestate == HandshakeState.MATCHED) {\r\n                                resourceDescriptor = handshake.getResourceDescriptor();\r\n                                ServerHandshakeBuilder response;\r\n                                try {\r\n                                    response = wsl.onWebsocketHandshakeReceivedAsServer(this, d, handshake);\r\n                                } catch (InvalidDataException e) {\r\n                                    log.trace(\"Closing due to wrong handshake. Possible handshake rejection\", e);\r\n                                    closeConnectionDueToWrongHandshake(e);\r\n                                    return false;\r\n                                } catch (RuntimeException e) {\r\n                                    log.error(\"Closing due to internal server error\", e);\r\n                                    wsl.onWebsocketError(this, e);\r\n                                    closeConnectionDueToInternalServerError(e);\r\n                                    return false;\r\n                                }\r\n                                write(d.createHandshake(d.postProcessHandshakeResponseAsServer(handshake, response)));\r\n                                draft = d;\r\n                                open(handshake);\r\n                                return true;\r\n                            }\r\n                        } catch (InvalidHandshakeException e) {\r\n                        }\r\n                    }\r\n                    if (draft == null) {\r\n                        log.trace(\"Closing due to protocol error: no draft matches\");\r\n                        closeConnectionDueToWrongHandshake(new InvalidDataException(CloseFrame.PROTOCOL_ERROR, \"no draft matches\"));\r\n                    }\r\n                    return false;\r\n                } else {\r\n                    Handshakedata tmphandshake = draft.translateHandshake(socketBuffer);\r\n                    if (!(tmphandshake instanceof ClientHandshake)) {\r\n                        log.trace(\"Closing due to protocol error: wrong http function\");\r\n                        flushAndClose(CloseFrame.PROTOCOL_ERROR, \"wrong http function\", false);\r\n                        return false;\r\n                    }\r\n                    ClientHandshake handshake = (ClientHandshake) tmphandshake;\r\n                    handshakestate = draft.acceptHandshakeAsServer(handshake);\r\n                    if (handshakestate == HandshakeState.MATCHED) {\r\n                        open(handshake);\r\n                        return true;\r\n                    } else {\r\n                        log.trace(\"Closing due to protocol error: the handshake did finally not match\");\r\n                        close(CloseFrame.PROTOCOL_ERROR, \"the handshake did finally not match\");\r\n                    }\r\n                    return false;\r\n                }\r\n            } else if (role == Role.CLIENT) {\r\n                draft.setParseMode(role);\r\n                Handshakedata tmphandshake = draft.translateHandshake(socketBuffer);\r\n                if (!(tmphandshake instanceof ServerHandshake)) {\r\n                    log.trace(\"Closing due to protocol error: wrong http function\");\r\n                    flushAndClose(CloseFrame.PROTOCOL_ERROR, \"wrong http function\", false);\r\n                    return false;\r\n                }\r\n                ServerHandshake handshake = (ServerHandshake) tmphandshake;\r\n                handshakestate = draft.acceptHandshakeAsClient(handshakerequest, handshake);\r\n                if (handshakestate == HandshakeState.MATCHED) {\r\n                    try {\r\n                        wsl.onWebsocketHandshakeReceivedAsClient(this, handshakerequest, handshake);\r\n                    } catch (InvalidDataException e) {\r\n                        log.trace(\"Closing due to invalid data exception. Possible handshake rejection\", e);\r\n                        flushAndClose(e.getCloseCode(), e.getMessage(), false);\r\n                        return false;\r\n                    } catch (RuntimeException e) {\r\n                        log.error(\"Closing since client was never connected\", e);\r\n                        wsl.onWebsocketError(this, e);\r\n                        flushAndClose(CloseFrame.NEVER_CONNECTED, e.getMessage(), false);\r\n                        return false;\r\n                    }\r\n                    open(handshake);\r\n                    return true;\r\n                } else {\r\n                    log.trace(\"Closing due to protocol error: draft {} refuses handshake\", draft);\r\n                    close(CloseFrame.PROTOCOL_ERROR, \"draft \" + draft + \" refuses handshake\");\r\n                }\r\n            }\r\n        } catch (InvalidHandshakeException e) {\r\n            log.trace(\"Closing due to invalid handshake\", e);\r\n            close(e);\r\n        }\r\n    } catch (IncompleteHandshakeException e) {\r\n        if (tmpHandshakeBytes.capacity() == 0) {\r\n            socketBuffer.reset();\r\n            int newsize = e.getPreferredSize();\r\n            if (newsize == 0) {\r\n                newsize = socketBuffer.capacity() + 16;\r\n            } else {\r\n                assert (e.getPreferredSize() >= socketBuffer.remaining());\r\n            }\r\n            tmpHandshakeBytes = ByteBuffer.allocate(newsize);\r\n            tmpHandshakeBytes.put(socketBufferNew);\r\n        } else {\r\n            tmpHandshakeBytes.position(tmpHandshakeBytes.limit());\r\n            tmpHandshakeBytes.limit(tmpHandshakeBytes.capacity());\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "hudson.model.Run.compareTo",
	"Comment": "ordering based on build numbers.if numbers are equal order based on names of parent projects.",
	"Method": "int compareTo(RunT that){\r\n    final int res = this.number - that.number;\r\n    if (res == 0)\r\n        return this.getParent().getFullName().compareTo(that.getParent().getFullName());\r\n    return res;\r\n}"
}, {
	"Path": "hudson.scm.SCM.getType",
	"Comment": "type of this scm.exposed so that the client of the remote api can tell what scm this is.",
	"Method": "String getType(){\r\n    return getClass().getName();\r\n}"
}, {
	"Path": "org.apache.xpath.axes.AxesWalker.getPrevWalker",
	"Comment": "get the previous walker reference in the location step chain.",
	"Method": "AxesWalker getPrevWalker(){\r\n    return m_prevWalker;\r\n}"
}, {
	"Path": "hudson.util.DescribableList.toMap",
	"Comment": "creates a detached map from the current snapshot of the data, keyed from a descriptor to an instance.",
	"Method": "Map<D, T> toMap(){\r\n    return (Map) Descriptor.toMap(data);\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.getResourceStream",
	"Comment": "returns an inputstream to a given resource in the given file which mayeither be a directory or a zip file.",
	"Method": "InputStream getResourceStream(File file,String resourceName){\r\n    try {\r\n        JarFile jarFile = (JarFile) jarFiles.get(file);\r\n        if (jarFile == null && file.isDirectory()) {\r\n            File resource = new File(file, resourceName);\r\n            if (resource.exists()) {\r\n                return Files.newInputStream(resource.toPath());\r\n            }\r\n        } else {\r\n            if (jarFile == null) {\r\n                if (file.exists()) {\r\n                    jarFile = new JarFile(file);\r\n                    jarFiles.put(file, jarFile);\r\n                } else {\r\n                    return null;\r\n                }\r\n                jarFile = (JarFile) jarFiles.get(file);\r\n            }\r\n            JarEntry entry = jarFile.getJarEntry(resourceName);\r\n            if (entry != null) {\r\n                return jarFile.getInputStream(entry);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        log(\"Ignoring Exception \" + e.getClass().getName() + \": \" + e.getMessage() + \" reading resource \" + resourceName + \" from \" + file, Project.MSG_VERBOSE);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMNodeList.item",
	"Comment": "returns the indexth item in the collection. if index is greater than or equal to the number of nodes in the list, this returns null.",
	"Method": "Node item(int index){\r\n    if (m_iter != null) {\r\n        int handle = m_iter.item(index);\r\n        if (handle == DTM.NULL) {\r\n            return null;\r\n        }\r\n        return m_iter.getDTM(handle).getNode(handle);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.iluwatar.tls.DateFormatCallableTest.testDateValues",
	"Comment": "test date values after the run of dateformatrunnalbe. a correct run should deliver 5 times 15.12.2015",
	"Method": "void testDateValues(){\r\n    assertEquals(expectedDateValues, createdDateValues);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.NamespaceMappings.popNamespace",
	"Comment": "undeclare the namespace that is currently pointed to by a given prefix",
	"Method": "boolean popNamespace(String prefix){\r\n    if (prefix.startsWith(XML_PREFIX)) {\r\n        return false;\r\n    }\r\n    Stack stack;\r\n    if ((stack = getPrefixStack(prefix)) != null) {\r\n        stack.pop();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.setLocalNameTable",
	"Comment": "set a reference pointer to the element name symbol table.%review% should this really be public? changing it whiledtm is in use would be a disaster.",
	"Method": "void setLocalNameTable(DTMStringPool poolRef){\r\n    m_localNames = poolRef;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncPosition.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    double pos = (double) getPositionInContextNodeList(xctxt);\r\n    return new XNumber(pos);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMNamedNodeMap.item",
	"Comment": "returns the indexth item in the map. if indexis greater than or equal to the number of nodes in this map, thisreturns null.",
	"Method": "Node item(int i){\r\n    int count = 0;\r\n    for (int n = dtm.getFirstAttribute(element); n != -1; n = dtm.getNextAttribute(n)) {\r\n        if (count == i)\r\n            return dtm.getNode(n);\r\n        else\r\n            ++count;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xpath.XPathAPI.selectSingleNode",
	"Comment": "use an xpath string to select a single node.xpath namespace prefixes are resolved from the namespacenode.",
	"Method": "Node selectSingleNode(Node contextNode,String str,Node selectSingleNode,Node contextNode,String str,Node namespaceNode){\r\n    NodeIterator nl = selectNodeIterator(contextNode, str, namespaceNode);\r\n    return nl.nextNode();\r\n}"
}, {
	"Path": "hudson.console.ConsoleAnnotatorTest.pollingOutput",
	"Comment": "makes sure that annotations in the polling output is handled correctly.",
	"Method": "void pollingOutput(){\r\n    FreeStyleProject p = r.createFreeStyleProject();\r\n    p.setScm(new PollingSCM());\r\n    SCMTrigger t = new SCMTrigger(\"@daily\");\r\n    t.start(p, true);\r\n    p.addTrigger(t);\r\n    r.buildAndAssertSuccess(p);\r\n    t.new Runner().run();\r\n    HtmlPage log = r.createWebClient().getPage(p, \"scmPollLog\");\r\n    String text = log.asText();\r\n    assertTrue(text, text.contains(\"$$$hello from polling\"));\r\n}"
}, {
	"Path": "hudson.util.IOUtils.readFirstLine",
	"Comment": "read the first line of the given stream, close it, and return that line.",
	"Method": "String readFirstLine(InputStream is,String encoding){\r\n    try (BufferedReader reader = new BufferedReader(encoding == null ? new InputStreamReader(is) : new InputStreamReader(is, encoding))) {\r\n        return reader.readLine();\r\n    }\r\n}"
}, {
	"Path": "hudson.security.ACL.hasPermission",
	"Comment": "checks if the current security principal has this permission.",
	"Method": "boolean hasPermission(Permission p,boolean hasPermission,Authentication a,Permission permission){\r\n    Authentication a = Jenkins.getAuthentication();\r\n    if (a == SYSTEM) {\r\n        return true;\r\n    }\r\n    return hasPermission(a, p);\r\n}"
}, {
	"Path": "hudson.cli.Connection.encryptConnection",
	"Comment": "upgrades a connection with transport encryption by the specified symmetric cipher.",
	"Method": "Connection encryptConnection(SecretKey sessionKey,String algorithm){\r\n    Cipher cout = Cipher.getInstance(algorithm);\r\n    cout.init(Cipher.ENCRYPT_MODE, sessionKey, new IvParameterSpec(sessionKey.getEncoded()));\r\n    CipherOutputStream o = new CipherOutputStream(out, cout);\r\n    Cipher cin = Cipher.getInstance(algorithm);\r\n    cin.init(Cipher.DECRYPT_MODE, sessionKey, new IvParameterSpec(sessionKey.getEncoded()));\r\n    CipherInputStream i = new CipherInputStream(in, cin);\r\n    return new Connection(i, o);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.StylesheetHandler.assertion",
	"Comment": "assert that a condition is true.if it is not true, throw an error.",
	"Method": "void assertion(boolean condition,String msg){\r\n    if (!condition)\r\n        throw new RuntimeException(msg);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.NodeLocator.toString",
	"Comment": "tostring returns a string representation of thisnodelocator instance.",
	"Method": "String toString(){\r\n    return \"file '\" + m_systemId + \"', line #\" + m_lineNumber + \", column #\" + m_columnNumber;\r\n}"
}, {
	"Path": "jenkins.util.VirtualFile.readLink",
	"Comment": "if this file is a symlink, returns the link target.the default implementation always returns null.some implementations may not support symlinks under any conditions.",
	"Method": "String readLink(String readLink,String readLink){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xml.utils.NamespaceSupport2.reset",
	"Comment": "reset this namespace support object for reuse.it is necessary to invoke this method before reusing thenamespace support object for a new session.",
	"Method": "void reset(){\r\n    currentContext = new Context2(null);\r\n    currentContext.declarePrefix(\"xml\", XMLNS);\r\n}"
}, {
	"Path": "hudson.model.Queue.getItems",
	"Comment": "gets the information about the queue item for the given project.",
	"Method": "Item[] getItems(List<Item> getItems,Task t){\r\n    Snapshot snapshot = this.snapshot;\r\n    List<Item> result = new ArrayList<Item>();\r\n    for (Item item : snapshot.blockedProjects) {\r\n        if (item.task.equals(t)) {\r\n            result.add(item);\r\n        }\r\n    }\r\n    for (Item item : snapshot.buildables) {\r\n        if (item.task.equals(t)) {\r\n            result.add(item);\r\n        }\r\n    }\r\n    for (Item item : snapshot.pendings) {\r\n        if (item.task.equals(t)) {\r\n            result.add(item);\r\n        }\r\n    }\r\n    for (Item item : snapshot.waitingList) {\r\n        if (item.task.equals(t)) {\r\n            result.add(item);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "hudson.model.ApiTest.xPathDocumentFunction",
	"Comment": "test that calling the xml api with the xpath document function fails.",
	"Method": "void xPathDocumentFunction(){\r\n    File f = new File(j.jenkins.getRootDir(), \"queue.xml\");\r\n    JenkinsRule.WebClient client = j.createWebClient();\r\n    try {\r\n        client.goTo(\"api/xml?xpath=document(\\\"\" + f.getAbsolutePath() + \"\\\")\", \"application/xml\");\r\n        fail(\"Should become 500 error\");\r\n    } catch (com.gargoylesoftware.htmlunit.FailingHttpStatusCodeException e) {\r\n        String contentAsString = e.getResponse().getContentAsString();\r\n        j.assertStringContains(contentAsString, \"Illegal function: document\");\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.maven.MavenSettingsServerCredentials.isEncrypted",
	"Comment": "return true if the given string appears to have been encrypted with the mavenpassword encryption. such passwords appear between unescaped braces.",
	"Method": "boolean isEncrypted(String password){\r\n    Matcher matcher = ENCRYPTED_STRING_PATTERN.matcher(password);\r\n    return matcher.matches() || matcher.find();\r\n}"
}, {
	"Path": "hudson.markup.MarkupFormatter.translate",
	"Comment": "given the text, converts that to html according to whatever markup rules implicit in the implementation class.multiple threads can call this method concurrently with different inputs.",
	"Method": "void translate(String markup,Writer output,String translate,String markup){\r\n    StringWriter w = new StringWriter();\r\n    translate(markup, w);\r\n    return w.toString();\r\n}"
}, {
	"Path": "org.apache.xalan.processor.ProcessorTemplate.appendAndPush",
	"Comment": "append the current template element to the currenttemplate element, and then push it onto the current templateelement stack.",
	"Method": "void appendAndPush(StylesheetHandler handler,ElemTemplateElement elem){\r\n    super.appendAndPush(handler, elem);\r\n    elem.setDOMBackPointer(handler.getOriginatingNode());\r\n    handler.getStylesheet().setTemplate((ElemTemplate) elem);\r\n}"
}, {
	"Path": "hudson.model.TopLevelItemDescriptor.checkApplicableIn",
	"Comment": "checks if this top level item is applicable within the specified item group.this is just a convenience function.",
	"Method": "void checkApplicableIn(ItemGroup parent){\r\n    if (!isApplicableIn(parent)) {\r\n        throw new AccessDeniedException(Messages.TopLevelItemDescriptor_NotApplicableIn(getDisplayName(), parent.getFullDisplayName()));\r\n    }\r\n}"
}, {
	"Path": "hudson.model.FreeStyleProjectTest.customWorkspaceAllocation",
	"Comment": "custom workspace and concurrent build had a bad interaction.",
	"Method": "void customWorkspaceAllocation(){\r\n    FreeStyleProject f = j.createFreeStyleProject();\r\n    File d = j.createTmpDir();\r\n    f.setCustomWorkspace(d.getPath());\r\n    j.buildAndAssertSuccess(f);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemLiteralResult.getLocalName",
	"Comment": "get the local name of the literal result element.note that after resolveprefixtables has been called, this willreturn the aliased name prefix, not the original stylesheetnamespace prefix.",
	"Method": "String getLocalName(String getLocalName){\r\n    return m_localName;\r\n}"
}, {
	"Path": "hudson.model.User.delete",
	"Comment": "deletes the data directory and removes this user from hudson.",
	"Method": "void delete(){\r\n    final IdStrategy strategy = idStrategy();\r\n    byNameLock.readLock().lock();\r\n    try {\r\n        AllUsers.byName().remove(strategy.keyFor(id));\r\n    } finally {\r\n        byNameLock.readLock().unlock();\r\n    }\r\n    Util.deleteRecursive(new File(getRootDir(), strategy.filenameOf(id)));\r\n    UserDetailsCache.get().invalidate(strategy.keyFor(id));\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLStringDefault.toLowerCase",
	"Comment": "converts all of the characters in this string to lowercase using the rules of the default locale, which is returnedby locale.getdefault.",
	"Method": "XMLString toLowerCase(Locale locale,XMLString toLowerCase){\r\n    return new XMLStringDefault(m_str.toLowerCase());\r\n}"
}, {
	"Path": "com.iluwatar.mutex.Thief.run",
	"Comment": "in the run method the thief repeatedly tries to take a bean until noneare left.",
	"Method": "void run(){\r\n    int beans = 0;\r\n    while (jar.takeBean()) {\r\n        beans = beans + 1;\r\n        LOGGER.info(\"{} took a bean.\", name);\r\n    }\r\n    LOGGER.info(\"{} took {} beans.\", name, beans);\r\n}"
}, {
	"Path": "jenkins.org.apache.commons.validator.routines.UrlValidator.getInstance",
	"Comment": "returns the singleton instance of this class with default schemes and options.",
	"Method": "UrlValidator getInstance(){\r\n    return DEFAULT_URL_VALIDATOR;\r\n}"
}, {
	"Path": "com.iluwatar.fluentinterface.fluentiterable.simple.SimpleFluentIterable.last",
	"Comment": "can be used to collect objects from the iterable. is a terminating operation.",
	"Method": "Optional<E> last(FluentIterable<E> last,int count){\r\n    int remainingElementsCount = getRemainingElementsCount();\r\n    Iterator<E> iterator = iterator();\r\n    int currentIndex = 0;\r\n    while (iterator.hasNext()) {\r\n        iterator.next();\r\n        if (currentIndex < remainingElementsCount - count) {\r\n            iterator.remove();\r\n        }\r\n        currentIndex++;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "hudson.cli.Connection.fold",
	"Comment": "given a byte array that contains arbitrary number of bytes, digests or expands those bits into the specifiednumber of bytes without loss of entropy.cryptographic utility code.",
	"Method": "byte[] fold(byte[] bytes,int size){\r\n    byte[] r = new byte[size];\r\n    for (int i = Math.max(bytes.length, size) - 1; i >= 0; i--) {\r\n        r[i % r.length] ^= bytes[i % bytes.length];\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "org.apache.xpath.axes.FilterExprIteratorSimple.setRoot",
	"Comment": "initialize the context values for this expressionafter it is cloned.",
	"Method": "void setRoot(int context,Object environment){\r\n    super.setRoot(context, environment);\r\n    m_exprObj = executeFilterExpr(context, m_execContext, getPrefixResolver(), getIsTopLevel(), m_stackFrame, m_expr);\r\n}"
}, {
	"Path": "jenkins.model.RunIdMigrator.created",
	"Comment": "called when a job is first created.just saves an empty marker indicating that this job needs no migration.",
	"Method": "void created(File dir){\r\n    save(dir);\r\n}"
}, {
	"Path": "org.apache.xalan.templates.KeyDeclaration.compose",
	"Comment": "this function is called after everything else has beenrecomposed, and allows the template to set remainingvalues that may be based on some other property thatdepends on recomposition.",
	"Method": "void compose(StylesheetRoot sroot){\r\n    super.compose(sroot);\r\n    java.util.Vector vnames = sroot.getComposeState().getVariableNames();\r\n    if (null != m_matchPattern)\r\n        m_matchPattern.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());\r\n    if (null != m_use)\r\n        m_use.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());\r\n}"
}, {
	"Path": "org.apache.xpath.Expression.asIterator",
	"Comment": "given an select expression and a context, evaluate the xpathand return the resulting iterator.",
	"Method": "DTMIterator asIterator(XPathContext xctxt,int contextNode){\r\n    try {\r\n        xctxt.pushCurrentNodeAndExpression(contextNode, contextNode);\r\n        return execute(xctxt).iter();\r\n    } finally {\r\n        xctxt.popCurrentNodeAndExpression();\r\n    }\r\n}"
}, {
	"Path": "jenkins.model.Jenkins.getSecurity",
	"Comment": "returns the constant that captures the three basic security modes in jenkins.",
	"Method": "SecurityMode getSecurity(){\r\n    SecurityRealm realm = securityRealm;\r\n    if (realm == SecurityRealm.NO_AUTHENTICATION)\r\n        return SecurityMode.UNSECURED;\r\n    if (realm instanceof LegacySecurityRealm)\r\n        return SecurityMode.LEGACY;\r\n    return SecurityMode.SECURED;\r\n}"
}, {
	"Path": "hudson.model.UpdateSite.doPostBack",
	"Comment": "this is the endpoint that receives the update center data file from the browser.",
	"Method": "FormValidation doPostBack(StaplerRequest req){\r\n    DownloadSettings.checkPostBackAccess();\r\n    return updateData(IOUtils.toString(req.getInputStream(), \"UTF-8\"), true);\r\n}"
}, {
	"Path": "com.iluwatar.servicelocator.ServiceCache.getService",
	"Comment": "get the service from the cache. null if no service is found matching the name",
	"Method": "Service getService(String serviceName){\r\n    Service cachedService = null;\r\n    for (String serviceJndiName : serviceCache.keySet()) {\r\n        if (serviceJndiName.equals(serviceName)) {\r\n            cachedService = serviceCache.get(serviceJndiName);\r\n            LOGGER.info(\"(cache call) Fetched service {}({}) from cache... !\", cachedService.getName(), cachedService.getId());\r\n        }\r\n    }\r\n    return cachedService;\r\n}"
}, {
	"Path": "hudson.util.StackedAreaRenderer2.getItemPaint",
	"Comment": "override this method to specify the color to draw the given area.",
	"Method": "Paint getItemPaint(int row,int column){\r\n    return super.getItemPaint(row, column);\r\n}"
}, {
	"Path": "org.apache.xalan.processor.ProcessorInclude.getBaseURIOfIncludedStylesheet",
	"Comment": "get the base uri of the included or imported stylesheet,if the user provided a uriresolver, then get the sourceobject for the stylsheet from it, and get the systemid from that source object, otherwise try to recover byusing the systeidresolver to figure out the base uri.",
	"Method": "String getBaseURIOfIncludedStylesheet(StylesheetHandler handler,Source s){\r\n    String baseURI;\r\n    String idFromUriResolverSource;\r\n    if (s != null && (idFromUriResolverSource = s.getSystemId()) != null) {\r\n        baseURI = idFromUriResolverSource;\r\n    } else {\r\n        baseURI = SystemIDResolver.getAbsoluteURI(getHref(), handler.getBaseIdentifier());\r\n    }\r\n    return baseURI;\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLChar.isSupplemental",
	"Comment": "returns true if the specified character is a supplemental character.",
	"Method": "boolean isSupplemental(int c){\r\n    return (c >= 0x10000 && c <= 0x10FFFF);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.dom3.DOMErrorImpl.getType",
	"Comment": "returns a string indicating which related data is expected in relateddata.",
	"Method": "String getType(){\r\n    return fType;\r\n}"
}, {
	"Path": "hudson.model.Executor.recordCauseOfInterruption",
	"Comment": "report cause of interruption and record it to the build, if available.",
	"Method": "void recordCauseOfInterruption(Run<?, ?> build,TaskListener listener){\r\n    List<CauseOfInterruption> r;\r\n    lock.writeLock().lock();\r\n    try {\r\n        if (causes.isEmpty())\r\n            return;\r\n        r = new ArrayList<CauseOfInterruption>(causes);\r\n        causes.clear();\r\n    } finally {\r\n        lock.writeLock().unlock();\r\n    }\r\n    build.addAction(new InterruptedBuildAction(r));\r\n    for (CauseOfInterruption c : r) c.print(listener);\r\n}"
}, {
	"Path": "org.apache.xpath.axes.LocPathIterator.setRoot",
	"Comment": "initialize the context values for this expressionafter it is cloned.",
	"Method": "void setRoot(int context,Object environment){\r\n    m_context = context;\r\n    XPathContext xctxt = (XPathContext) environment;\r\n    m_execContext = xctxt;\r\n    m_cdtm = xctxt.getDTM(context);\r\n    m_currentContextNode = context;\r\n    if (null == m_prefixResolver)\r\n        m_prefixResolver = xctxt.getNamespaceContext();\r\n    m_lastFetched = DTM.NULL;\r\n    m_foundLast = false;\r\n    m_pos = 0;\r\n    m_length = -1;\r\n    if (m_isTopLevel)\r\n        this.m_stackFrame = xctxt.getVarStack().getStackFrame();\r\n}"
}, {
	"Path": "hudson.console.ConsoleAnnotationDescriptor.hasStylesheet",
	"Comment": "returns true if this descriptor has a stylesheet to be inserted on applicable console page.",
	"Method": "boolean hasStylesheet(){\r\n    return hasResource(\"/style.css\") != null;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.fireStartElem",
	"Comment": "report the start element trace event. this trace method needs to becalled just before the attributes are cleared.",
	"Method": "void fireStartElem(String elemName){\r\n    if (m_tracer != null) {\r\n        flushMyWriter();\r\n        m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_STARTELEMENT, elemName, m_attributes);\r\n    }\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemNumber.tradAlphaCount",
	"Comment": "convert a long integer into traditional alphabetic counting, in other wordscount using the traditional numbering.",
	"Method": "String tradAlphaCount(long val,XResourceBundle thisBundle){\r\n    if (val > Long.MAX_VALUE) {\r\n        this.error(XSLTErrorResources.ER_NUMBER_TOO_BIG);\r\n        return XSLTErrorResources.ERROR_STRING;\r\n    }\r\n    char[] table = null;\r\n    int lookupIndex = 1;\r\n    char[] buf = new char[100];\r\n    int charPos;\r\n    charPos = 0;\r\n    IntArrayWrapper groups = (IntArrayWrapper) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_NUMBERGROUPS);\r\n    StringArrayWrapper tables = (StringArrayWrapper) (thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_NUM_TABLES));\r\n    String numbering = thisBundle.getString(org.apache.xml.utils.res.XResourceBundle.LANG_NUMBERING);\r\n    if (numbering.equals(org.apache.xml.utils.res.XResourceBundle.LANG_MULT_ADD)) {\r\n        String mult_order = thisBundle.getString(org.apache.xml.utils.res.XResourceBundle.MULT_ORDER);\r\n        LongArrayWrapper multiplier = (LongArrayWrapper) (thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_MULTIPLIER));\r\n        CharArrayWrapper zeroChar = (CharArrayWrapper) thisBundle.getObject(\"zero\");\r\n        int i = 0;\r\n        while (i < multiplier.getLength() && val < multiplier.getLong(i)) {\r\n            i++;\r\n        }\r\n        do {\r\n            if (i >= multiplier.getLength())\r\n                break;\r\n            if (val < multiplier.getLong(i)) {\r\n                if (zeroChar.getLength() == 0) {\r\n                    i++;\r\n                } else {\r\n                    if (buf[charPos - 1] != zeroChar.getChar(0))\r\n                        buf[charPos++] = zeroChar.getChar(0);\r\n                    i++;\r\n                }\r\n            } else if (val >= multiplier.getLong(i)) {\r\n                long mult = val / multiplier.getLong(i);\r\n                val = val % multiplier.getLong(i);\r\n                int k = 0;\r\n                while (k < groups.getLength()) {\r\n                    lookupIndex = 1;\r\n                    if (mult / groups.getInt(k) <= 0)\r\n                        k++;\r\n                    else {\r\n                        CharArrayWrapper THEletters = (CharArrayWrapper) thisBundle.getObject(tables.getString(k));\r\n                        table = new char[THEletters.getLength() + 1];\r\n                        int j;\r\n                        for (j = 0; j < THEletters.getLength(); j++) {\r\n                            table[j + 1] = THEletters.getChar(j);\r\n                        }\r\n                        table[0] = THEletters.getChar(j - 1);\r\n                        lookupIndex = (int) mult / groups.getInt(k);\r\n                        if (lookupIndex == 0 && mult == 0)\r\n                            break;\r\n                        char multiplierChar = ((CharArrayWrapper) (thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_MULTIPLIER_CHAR))).getChar(i);\r\n                        if (lookupIndex < table.length) {\r\n                            if (mult_order.equals(org.apache.xml.utils.res.XResourceBundle.MULT_PRECEDES)) {\r\n                                buf[charPos++] = multiplierChar;\r\n                                buf[charPos++] = table[lookupIndex];\r\n                            } else {\r\n                                if (lookupIndex == 1 && i == multiplier.getLength() - 1) {\r\n                                } else\r\n                                    buf[charPos++] = table[lookupIndex];\r\n                                buf[charPos++] = multiplierChar;\r\n                            }\r\n                            break;\r\n                        } else\r\n                            return XSLTErrorResources.ERROR_STRING;\r\n                    }\r\n                }\r\n                i++;\r\n            }\r\n        } while (i < multiplier.getLength());\r\n    }\r\n    int count = 0;\r\n    String tableName;\r\n    while (count < groups.getLength()) {\r\n        if (val / groups.getInt(count) <= 0)\r\n            count++;\r\n        else {\r\n            CharArrayWrapper theletters = (CharArrayWrapper) thisBundle.getObject(tables.getString(count));\r\n            table = new char[theletters.getLength() + 1];\r\n            int j;\r\n            for (j = 0; j < theletters.getLength(); j++) {\r\n                table[j + 1] = theletters.getChar(j);\r\n            }\r\n            table[0] = theletters.getChar(j - 1);\r\n            lookupIndex = (int) val / groups.getInt(count);\r\n            val = val % groups.getInt(count);\r\n            if (lookupIndex == 0 && val == 0)\r\n                break;\r\n            if (lookupIndex < table.length) {\r\n                buf[charPos++] = table[lookupIndex];\r\n            } else\r\n                return XSLTErrorResources.ERROR_STRING;\r\n            count++;\r\n        }\r\n    }\r\n    return new String(buf, 0, charPos);\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.removeElementAt",
	"Comment": "deletes the component at the specified index. each component inthis vector with an index greater or equal to the specifiedindex is shifted downward to have an index one smaller thanthe value it had previously.",
	"Method": "void removeElementAt(int i){\r\n    if (null == m_map)\r\n        return;\r\n    if (i >= m_firstFree)\r\n        throw new ArrayIndexOutOfBoundsException(i + \" >= \" + m_firstFree);\r\n    else if (i < 0)\r\n        throw new ArrayIndexOutOfBoundsException(i);\r\n    if (i < m_firstFree - 1)\r\n        System.arraycopy(m_map, i + 1, m_map, i, m_firstFree - i - 1);\r\n    m_firstFree--;\r\n    m_map[m_firstFree] = null;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncConcat.checkNumberArgs",
	"Comment": "check that the number of arguments passed to this function is correct.",
	"Method": "void checkNumberArgs(int argNum){\r\n    if (argNum < 2)\r\n        reportWrongNumberArgs();\r\n}"
}, {
	"Path": "com.iluwatar.collectionpipeline.FunctionalProgramming.getSedanCarsOwnedSortedByDate",
	"Comment": "method to get all sedan cars belonging to a group of persons sorted by year of manufacture",
	"Method": "List<Car> getSedanCarsOwnedSortedByDate(List<Person> persons){\r\n    return persons.stream().map(Person::getCars).flatMap(List::stream).filter(car -> Category.SEDAN.equals(car.getCategory())).sorted(Comparator.comparing(Car::getYear)).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.apache.xpath.axes.AxesWalker.init",
	"Comment": "initialize an axeswalker during the parse of the xpath expression.",
	"Method": "void init(Compiler compiler,int opPos,int stepType){\r\n    initPredicateInfo(compiler, opPos);\r\n}"
}, {
	"Path": "org.apache.xml.serializer.Encodings.isLowUTF16Surrogate",
	"Comment": "return true if the character is the low member of a surrogate pair.this is not a public api.",
	"Method": "boolean isLowUTF16Surrogate(char ch){\r\n    return ('?' <= ch && ch <= '?');\r\n}"
}, {
	"Path": "jenkins.util.AntClassLoader.forceLoadSystemClass",
	"Comment": "loads a class through this class loader but defer to the parent classloader.this ensures that instances of the returned class will be compatiblewith instances which have already been loaded on the parentloader.",
	"Method": "Class forceLoadSystemClass(String classname){\r\n    log(\"force system loading \" + classname, Project.MSG_DEBUG);\r\n    Class theClass = findLoadedClass(classname);\r\n    if (theClass == null) {\r\n        theClass = findBaseClass(classname);\r\n    }\r\n    return theClass;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.ToUnknownStream.getNamespaceMappings",
	"Comment": "get the current namespace mappings.simply returns the mappings of the wrapped handler.",
	"Method": "NamespaceMappings getNamespaceMappings(){\r\n    NamespaceMappings mappings = null;\r\n    if (m_handler != null) {\r\n        mappings = m_handler.getNamespaceMappings();\r\n    }\r\n    return mappings;\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSetDTM.removeElementAt",
	"Comment": "deletes the component at the specified index. each component inthis vector with an index greater or equal to the specifiedindex is shifted downward to have an index one smaller thanthe value it had previously.",
	"Method": "void removeElementAt(int i){\r\n    if (!m_mutable)\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null));\r\n    super.removeElementAt(i);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.setNsNameTable",
	"Comment": "set a reference pointer to the namespace uri symbol table.%review% should this really be public? changing it whiledtm is in use would be a disaster.",
	"Method": "void setNsNameTable(DTMStringPool poolRef){\r\n    m_nsNames = poolRef;\r\n}"
}, {
	"Path": "org.apache.xml.utils.UnImplNode.getDomConfig",
	"Comment": "the configuration used when document.normalizedocument isinvoked.",
	"Method": "DOMConfiguration getDomConfig(){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.migrateTo",
	"Comment": "migrate a dtm built with an old dtmmanager to a new dtmmanager. after the migration, the new dtmmanager will treat the dtm as one that is built by itself. this is used to support dtm sharing between multiple transformations.",
	"Method": "void migrateTo(DTMManager mgr){\r\n    m_mgr = mgr;\r\n    if (mgr instanceof DTMManagerDefault)\r\n        m_mgrDefault = (DTMManagerDefault) mgr;\r\n}"
}, {
	"Path": "org.apache.xalan.templates.OutputProperties.clone",
	"Comment": "clone this outputproperties, including a clone of the wrapped propertiesreference.",
	"Method": "Object clone(){\r\n    try {\r\n        OutputProperties cloned = (OutputProperties) super.clone();\r\n        cloned.m_properties = (Properties) cloned.m_properties.clone();\r\n        return cloned;\r\n    } catch (CloneNotSupportedException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "hudson.util.BootFailure.getBootFailureFile",
	"Comment": "this file captures failed boot attempts.every time we try to boot, we add the timestamp to this file,then when we boot, the file gets deleted.",
	"Method": "File getBootFailureFile(File home){\r\n    return new File(home, \"failed-boot-attempts.txt\");\r\n}"
}, {
	"Path": "org.apache.xpath.NodeSet.getCurrentNode",
	"Comment": "return the last fetched node.needed to support the unionpathiterator.",
	"Method": "Node getCurrentNode(){\r\n    if (!m_cacheNodes)\r\n        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_CANNOT_INDEX, null));\r\n    int saved = m_next;\r\n    Node n = (m_next < m_firstFree) ? elementAt(m_next) : null;\r\n    m_next = saved;\r\n    return n;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.Function.execute",
	"Comment": "execute an xpath function object.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    System.out.println(\"Error! Function.execute should not be called!\");\r\n    return null;\r\n}"
}, {
	"Path": "hudson.views.ListViewColumn.getColumnCaption",
	"Comment": "returns the name of the column that explains what this column means",
	"Method": "String getColumnCaption(){\r\n    return getDescriptor().getDisplayName();\r\n}"
}, {
	"Path": "org.apache.xalan.extensions.ObjectFactory.findClassLoader",
	"Comment": "figure out which classloader to use.for jdk 1.2 and later usethe context classloader.",
	"Method": "ClassLoader findClassLoader(){\r\n    return Thread.currentThread().getContextClassLoader();\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.getURIResolver",
	"Comment": "get the uriresolver associated with this execution context.",
	"Method": "URIResolver getURIResolver(){\r\n    return m_uriResolver;\r\n}"
}, {
	"Path": "com.iluwatar.object.pool.OliphauntPoolTest.testSubsequentCheckinCheckout",
	"Comment": "use the same object 100 times subsequently. this should not take much time since the heavyobject instantiation is done only once. verify if we get the same object each time.",
	"Method": "void testSubsequentCheckinCheckout(){\r\n    assertTimeout(ofMillis(5000), () -> {\r\n        final OliphauntPool pool = new OliphauntPool();\r\n        assertEquals(\"Pool available=0 inUse=0\", pool.toString());\r\n        final Oliphaunt expectedOliphaunt = pool.checkOut();\r\n        assertEquals(\"Pool available=0 inUse=1\", pool.toString());\r\n        pool.checkIn(expectedOliphaunt);\r\n        assertEquals(\"Pool available=1 inUse=0\", pool.toString());\r\n        for (int i = 0; i < 100; i++) {\r\n            final Oliphaunt oliphaunt = pool.checkOut();\r\n            assertEquals(\"Pool available=0 inUse=1\", pool.toString());\r\n            assertSame(expectedOliphaunt, oliphaunt);\r\n            assertEquals(expectedOliphaunt.getId(), oliphaunt.getId());\r\n            assertEquals(expectedOliphaunt.toString(), oliphaunt.toString());\r\n            pool.checkIn(oliphaunt);\r\n            assertEquals(\"Pool available=1 inUse=0\", pool.toString());\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.apache.xpath.functions.Function3Args.fixupVariables",
	"Comment": "this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time.",
	"Method": "void fixupVariables(java.util.Vector vars,int globalsSize){\r\n    super.fixupVariables(vars, globalsSize);\r\n    if (null != m_arg2)\r\n        m_arg2.fixupVariables(vars, globalsSize);\r\n}"
}, {
	"Path": "org.java_websocket.WebSocketAdapter.onWebsocketHandshakeReceivedAsServer",
	"Comment": "this default implementation does not do anything. go ahead and overwrite it.",
	"Method": "ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer(WebSocket conn,Draft draft,ClientHandshake request){\r\n    return new HandshakeImpl1Server();\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerIdentityImpl.setResult",
	"Comment": "enables the user of the transformerhandler to set theto set the result for the transformation.",
	"Method": "void setResult(Result result){\r\n    if (null == result)\r\n        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_RESULT_NULL, null));\r\n    m_result = result;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.migrateTo",
	"Comment": "migrate a dtm built with an old dtmmanager to a new dtmmanager. after the migration, the new dtmmanager will treat the dtm as one that is built by itself. this is used to support dtm sharing between multiple transformations.",
	"Method": "void migrateTo(DTMManager manager){\r\n    super.migrateTo(manager);\r\n    int numDTMs = m_dtmIdent.size();\r\n    int dtmId = m_mgrDefault.getFirstFreeDTMID();\r\n    int nodeIndex = 0;\r\n    for (int i = 0; i < numDTMs; i++) {\r\n        m_dtmIdent.setElementAt(dtmId << DTMManager.IDENT_DTM_NODE_BITS, i);\r\n        m_mgrDefault.addDTM(this, dtmId, nodeIndex);\r\n        dtmId++;\r\n        nodeIndex += (1 << DTMManager.IDENT_DTM_NODE_BITS);\r\n    }\r\n}"
}, {
	"Path": "hudson.model.listeners.SaveableListener.register",
	"Comment": "registers this object as an active listener so that it can start gettingcallbacks invoked.",
	"Method": "void register(){\r\n    all().add(this);\r\n}"
}, {
	"Path": "hudson.Util.wrapToErrorSpan",
	"Comment": "wraps with the error icon and the css class to render error message.",
	"Method": "String wrapToErrorSpan(String s){\r\n    s = \"<span class=error style='display:inline-block'>\" + s + \"<\/span>\";\r\n    return s;\r\n}"
}, {
	"Path": "org.apache.xml.utils.IntStack.pop",
	"Comment": "removes the object at the top of this stack and returns thatobject as the value of this function.",
	"Method": "int pop(){\r\n    return m_map[--m_firstFree];\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XNumber.isStableNumber",
	"Comment": "tell if this expression returns a stable number that will not change during iterations within the expression.this is used to determine if a proximity position predicate can indicate that no more searching has to occur.",
	"Method": "boolean isStableNumber(){\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FuncConcat.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    StringBuffer sb = new StringBuffer();\r\n    sb.append(m_arg0.execute(xctxt).str());\r\n    sb.append(m_arg1.execute(xctxt).str());\r\n    if (null != m_arg2)\r\n        sb.append(m_arg2.execute(xctxt).str());\r\n    if (null != m_args) {\r\n        for (int i = 0; i < m_args.length; i++) {\r\n            sb.append(m_args[i].execute(xctxt).str());\r\n        }\r\n    }\r\n    return new XString(sb.toString());\r\n}"
}, {
	"Path": "org.apache.xpath.XPathContext.assertion",
	"Comment": "tell the user of an assertion error, and probably throw anexception.",
	"Method": "void assertion(boolean b,String msg){\r\n    if (!b) {\r\n        ErrorListener errorHandler = getErrorListener();\r\n        if (errorHandler != null) {\r\n            errorHandler.fatalError(new TransformerException(XSLMessages.createMessage(XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION, new Object[] { msg }), (SAXSourceLocator) this.getSAXLocator()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.xml.utils.IntVector.insertElementAt",
	"Comment": "inserts the specified node in this vector at the specified index.each component in this vector with an index greater or equal tothe specified index is shifted upward to have an index one greaterthan the value it had previously.",
	"Method": "void insertElementAt(int value,int at){\r\n    if ((m_firstFree + 1) >= m_mapSize) {\r\n        m_mapSize += m_blocksize;\r\n        int[] newMap = new int[m_mapSize];\r\n        System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);\r\n        m_map = newMap;\r\n    }\r\n    if (at <= (m_firstFree - 1)) {\r\n        System.arraycopy(m_map, at, m_map, at + 1, m_firstFree - at);\r\n    }\r\n    m_map[at] = value;\r\n    m_firstFree++;\r\n}"
}, {
	"Path": "org.apache.xml.utils.XMLStringDefault.concat",
	"Comment": "concatenates the specified string to the end of this string.",
	"Method": "XMLString concat(String str){\r\n    return new XMLStringDefault(m_str.concat(str));\r\n}"
}, {
	"Path": "hudson.model.Executor.getTimestampString",
	"Comment": "gets the string that says how long since this build has started.",
	"Method": "String getTimestampString(){\r\n    return Util.getPastTimeString(getElapsedTime());\r\n}"
}, {
	"Path": "hudson.UtilTest.mkfiles",
	"Comment": "creates multiple files, each containing their filename as text content.",
	"Method": "void mkfiles(File files){\r\n    for (File f : files) FileUtils.write(f, f.getName());\r\n}"
}, {
	"Path": "com.iluwatar.adapter.AdapterPatternTest.setup",
	"Comment": "this method runs before the test execution and sets the bean objects in the beans map.",
	"Method": "void setup(){\r\n    beans = new HashMap();\r\n    FishingBoatAdapter fishingBoatAdapter = spy(new FishingBoatAdapter());\r\n    beans.put(FISHING_BEAN, fishingBoatAdapter);\r\n    Captain captain = new Captain();\r\n    captain.setRowingBoat((FishingBoatAdapter) beans.get(FISHING_BEAN));\r\n    beans.put(ROWING_BEAN, captain);\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDocumentImpl.getNextNamespaceNode",
	"Comment": "given a namespace handle, advance to the next namespace. %tbd% this method does not match the current signature inthe dtm interface.fix it, or justify changing the dtmapi.",
	"Method": "int getNextNamespaceNode(int baseHandle,int namespaceHandle,boolean inScope){\r\n    return NULL;\r\n}"
}, {
	"Path": "com.iluwatar.mute.App.useOfMute",
	"Comment": "typically used when the api declares some exception but cannot do so. usually a signature mistake.in this example out is not supposed to throw exception as it is abytearrayoutputstream. so we utilize mute, which will throw assertionerror if unexpectedexception occurs.",
	"Method": "void useOfMute(){\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    Mute.mute(() -> out.write(\"Hello\".getBytes()));\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.dom2dtm.DOM2DTMdefaultNamespaceDeclarationNode.compareDocumentPosition",
	"Comment": "compares a node with this node with regard to their position in thedocument.",
	"Method": "short compareDocumentPosition(Node other){\r\n    return 0;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.sax2dtm.SAX2DTM.getNamespaceURI",
	"Comment": "get a prefix either from the qname or from the uri mapping, or just makeone up!",
	"Method": "String getNamespaceURI(int nodeHandle,String getNamespaceURI,String prefix){\r\n    String uri = \"\";\r\n    int prefixIndex = m_contextIndexes.peek() - 1;\r\n    if (null == prefix)\r\n        prefix = \"\";\r\n    do {\r\n        prefixIndex = m_prefixMappings.indexOf(prefix, ++prefixIndex);\r\n    } while ((prefixIndex >= 0) && (prefixIndex & 0x01) == 0x01);\r\n    if (prefixIndex > -1) {\r\n        uri = (String) m_prefixMappings.elementAt(prefixIndex + 1);\r\n    }\r\n    return uri;\r\n}"
}, {
	"Path": "hudson.Util.isRelativePath",
	"Comment": "a mostly accurate check of whether a path is a relative path or not. this is designed to take a path againstan unknown operating system so may give invalid results.",
	"Method": "boolean isRelativePath(String path){\r\n    if (path.startsWith(\"/\"))\r\n        return false;\r\n    if (path.startsWith(\"\\\\\\\\\") && path.length() > 3 && path.indexOf('\\\\', 3) != -1)\r\n        return false;\r\n    if (path.length() >= 3 && ':' == path.charAt(1)) {\r\n        char p = path.charAt(0);\r\n        if (('A' <= p && p <= 'Z') || ('a' <= p && p <= 'z')) {\r\n            return path.charAt(2) != '\\\\' && path.charAt(2) != '/';\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.xml.serializer.SerializerBase.setNamespaceMappings",
	"Comment": "used only by transformersnapshotimpl to restore the serialization to a previous state.",
	"Method": "void setNamespaceMappings(NamespaceMappings mappings){\r\n    m_prefixMap = mappings;\r\n}"
}, {
	"Path": "org.apache.xml.dtm.ref.DTMDefaultBase.getDocumentVersion",
	"Comment": "return a string representing the xml version of the document. thisproperty is derived from the xml declaration optionally present at thebeginning of the document entity, and has no value if there is no xmldeclaration.",
	"Method": "String getDocumentVersion(int documentHandle){\r\n    return null;\r\n}"
}, {
	"Path": "jadx.gui.treemodel.JSources.getHierarchyPackages",
	"Comment": "convert packages list to hierarchical packages representation",
	"Method": "List<JPackage> getHierarchyPackages(List<JavaPackage> packages){\r\n    Map<String, JPackage> pkgMap = new HashMap();\r\n    for (JavaPackage pkg : packages) {\r\n        addPackage(pkgMap, new JPackage(pkg));\r\n    }\r\n    boolean repeat;\r\n    do {\r\n        repeat = false;\r\n        for (JPackage pkg : pkgMap.values()) {\r\n            if (pkg.getInnerPackages().size() == 1 && pkg.getClasses().isEmpty()) {\r\n                JPackage innerPkg = pkg.getInnerPackages().get(0);\r\n                pkg.getInnerPackages().clear();\r\n                pkg.getInnerPackages().addAll(innerPkg.getInnerPackages());\r\n                pkg.getClasses().addAll(innerPkg.getClasses());\r\n                pkg.setName(pkg.getName() + \".\" + innerPkg.getName());\r\n                innerPkg.getInnerPackages().clear();\r\n                innerPkg.getClasses().clear();\r\n                repeat = true;\r\n                break;\r\n            }\r\n        }\r\n    } while (repeat);\r\n    for (Iterator<Map.Entry<String, JPackage>> it = pkgMap.entrySet().iterator(); it.hasNext(); ) {\r\n        JPackage pkg = it.next().getValue();\r\n        if (pkg.getInnerPackages().isEmpty() && pkg.getClasses().isEmpty()) {\r\n            it.remove();\r\n        }\r\n    }\r\n    Set<JPackage> innerPackages = Collections.newSetFromMap(new IdentityHashMap<JPackage, Boolean>());\r\n    for (JPackage pkg : pkgMap.values()) {\r\n        innerPackages.addAll(pkg.getInnerPackages());\r\n    }\r\n    List<JPackage> rootPkgs = new ArrayList();\r\n    for (JPackage pkg : pkgMap.values()) {\r\n        if (!innerPackages.contains(pkg)) {\r\n            rootPkgs.add(pkg);\r\n        }\r\n    }\r\n    Collections.sort(rootPkgs);\r\n    return rootPkgs;\r\n}"
}, {
	"Path": "com.iluwatar.converter.ConverterTest.testCustomConverter",
	"Comment": "tests the custom users converter. thanks to java8 lambdas, converter can be easily andcleanly instantiated allowing various different conversion strategies to be implemented.",
	"Method": "void testCustomConverter(){\r\n    Converter<UserDto, User> converter = new Converter(userDto -> new User(userDto.getFirstName(), userDto.getLastName(), userDto.isActive(), String.valueOf(new Random().nextInt())), user -> new UserDto(user.getFirstName(), user.getLastName(), user.isActive(), user.getFirstName().toLowerCase() + user.getLastName().toLowerCase() + \"@whatever.com\"));\r\n    User u1 = new User(\"John\", \"Doe\", false, \"12324\");\r\n    UserDto userDto = converter.convertFromEntity(u1);\r\n    assertEquals(\"johndoe@whatever.com\", userDto.getEmail());\r\n}"
}, {
	"Path": "hudson.model.UpdateCenter.doIncompleteInstallStatus",
	"Comment": "called to determine if there was an incomplete installation, what the statuses of the plugins are",
	"Method": "HttpResponse doIncompleteInstallStatus(){\r\n    try {\r\n        Map<String, String> jobs = InstallUtil.getPersistedInstallStatus();\r\n        if (jobs == null) {\r\n            jobs = Collections.emptyMap();\r\n        }\r\n        return HttpResponses.okJSON(jobs);\r\n    } catch (Exception e) {\r\n        return HttpResponses.errorJSON(String.format(\"ERROR: %s\", e.getMessage()));\r\n    }\r\n}"
}, {
	"Path": "hudson.PluginManagerCheckUpdateCenterTest.updateSiteRightJsonTest",
	"Comment": "check if the page contains the right message after checking an update site that returns a well defined json.",
	"Method": "void updateSiteRightJsonTest(){\r\n    boolean oldValueSignatureCheck = DownloadService.signatureCheck;\r\n    try {\r\n        DownloadService.signatureCheck = false;\r\n        checkUpdateSite(Jenkins.get().getRootUrl() + \"updateSiteRightJson/update-center.json\", \"\", true);\r\n    } finally {\r\n        DownloadService.signatureCheck = oldValueSignatureCheck;\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.tar.TarStreamBuilderTest.verifyBlobWithoutCompression",
	"Comment": "creates an uncompressed blob from the tarstreambuilder and verifies it.",
	"Method": "void verifyBlobWithoutCompression(){\r\n    Blob blob = testTarStreamBuilder.toBlob();\r\n    ByteArrayOutputStream tarByteOutputStream = new ByteArrayOutputStream();\r\n    blob.writeTo(tarByteOutputStream);\r\n    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(tarByteOutputStream.toByteArray());\r\n    TarArchiveInputStream tarArchiveInputStream = new TarArchiveInputStream(byteArrayInputStream);\r\n    verifyTarArchive(tarArchiveInputStream);\r\n}"
}, {
	"Path": "hudson.cli.CLICommand.getClientEnvironmentVariable",
	"Comment": "convenience method for subtypes to obtain environment variables of the client.",
	"Method": "String getClientEnvironmentVariable(String name){\r\n    return checkChannel().call(new GetEnvironmentVariable(name));\r\n}"
}, {
	"Path": "org.apache.xalan.templates.ElemLiteralResult.getPrefix",
	"Comment": "get the prefix part of the raw name of the literal result element.",
	"Method": "String getPrefix(String getPrefix){\r\n    int len = m_rawName.length() - m_localName.length() - 1;\r\n    return (len > 0) ? m_rawName.substring(0, len) : \"\";\r\n}"
}, {
	"Path": "com.iluwatar.reactor.framework.NioReactor.dispatchReadEvent",
	"Comment": "uses the application provided dispatcher to dispatch events to application handler.",
	"Method": "void dispatchReadEvent(SelectionKey key,Object readObject){\r\n    dispatcher.onChannelReadEvent((AbstractNioChannel) key.attachment(), readObject, key);\r\n}"
}, {
	"Path": "jenkins.model.IdStrategy.idFromFilename",
	"Comment": "converts a filename into the corresponding id.this may contain filesystem unsafe characters.",
	"Method": "String idFromFilename(String filename,String idFromFilename,String filename,String idFromFilename,String filename){\r\n    return filename;\r\n}"
}, {
	"Path": "com.google.devtools.j2objc.translate.RewriterTest.testArrayInitializerRewrite",
	"Comment": "verify that array initializers are rewritten as method calls.",
	"Method": "void testArrayInitializerRewrite(){\r\n    String translation = translateSourceFile(\"public class Test { void test() { int[] a = { 1, 2, 3 }; char b[] = { '4', '5' }; } }\", \"Test\", \"Test.m\");\r\n    assertTranslatedLines(translation, \"IOSIntArray *a = [IOSIntArray arrayWithInts:(jint[]){ 1, 2, 3 } count:3];\", \"IOSCharArray *b = [IOSCharArray arrayWithChars:(jchar[]){ '4', '5' } count:2];\");\r\n}"
}, {
	"Path": "com.iluwatar.tolerantreader.RainbowFishSerializerTest.testWriteV1ReadV1",
	"Comment": "verify if a fish, written as version 1 can be read back as version 1",
	"Method": "void testWriteV1ReadV1(){\r\n    final File outputFile = this.testFolder.newFile();\r\n    RainbowFishSerializer.writeV1(V1, outputFile.getPath());\r\n    final RainbowFish fish = RainbowFishSerializer.readV1(outputFile.getPath());\r\n    assertNotSame(V1, fish);\r\n    assertEquals(V1.getName(), fish.getName());\r\n    assertEquals(V1.getAge(), fish.getAge());\r\n    assertEquals(V1.getLengthMeters(), fish.getLengthMeters());\r\n    assertEquals(V1.getWeightTons(), fish.getWeightTons());\r\n}"
}, {
	"Path": "org.apache.xpath.Expression.asNode",
	"Comment": "return the first node out of the nodeset, if this expression isa nodeset expression.",
	"Method": "int asNode(XPathContext xctxt){\r\n    DTMIterator iter = execute(xctxt).iter();\r\n    return iter.nextNode();\r\n}"
}, {
	"Path": "org.apache.xalan.templates.FuncDocument.execute",
	"Comment": "execute the function.the function must returna valid object.",
	"Method": "XObject execute(XPathContext xctxt){\r\n    int context = xctxt.getCurrentNode();\r\n    DTM dtm = xctxt.getDTM(context);\r\n    int docContext = dtm.getDocumentRoot(context);\r\n    XObject arg = (XObject) this.getArg0().execute(xctxt);\r\n    String base = \"\";\r\n    Expression arg1Expr = this.getArg1();\r\n    if (null != arg1Expr) {\r\n        XObject arg2 = arg1Expr.execute(xctxt);\r\n        if (XObject.CLASS_NODESET == arg2.getType()) {\r\n            int baseNode = arg2.iter().nextNode();\r\n            if (baseNode == DTM.NULL) {\r\n                warn(xctxt, XSLTErrorResources.WG_EMPTY_SECOND_ARG, null);\r\n                XNodeSet nodes = new XNodeSet(xctxt.getDTMManager());\r\n                return nodes;\r\n            } else {\r\n                DTM baseDTM = xctxt.getDTM(baseNode);\r\n                base = baseDTM.getDocumentBaseURI();\r\n            }\r\n        } else {\r\n            arg2.iter();\r\n        }\r\n    } else {\r\n        assertion(null != xctxt.getNamespaceContext(), \"Namespace context can not be null!\");\r\n        base = xctxt.getNamespaceContext().getBaseIdentifier();\r\n    }\r\n    XNodeSet nodes = new XNodeSet(xctxt.getDTMManager());\r\n    NodeSetDTM mnl = nodes.mutableNodeset();\r\n    DTMIterator iterator = (XObject.CLASS_NODESET == arg.getType()) ? arg.iter() : null;\r\n    int pos = DTM.NULL;\r\n    while ((null == iterator) || (DTM.NULL != (pos = iterator.nextNode()))) {\r\n        XMLString ref = (null != iterator) ? xctxt.getDTM(pos).getStringValue(pos) : arg.xstr();\r\n        if (null == arg1Expr && DTM.NULL != pos) {\r\n            DTM baseDTM = xctxt.getDTM(pos);\r\n            base = baseDTM.getDocumentBaseURI();\r\n        }\r\n        if (null == ref)\r\n            continue;\r\n        if (DTM.NULL == docContext) {\r\n            error(xctxt, XSLTErrorResources.ER_NO_CONTEXT_OWNERDOC, null);\r\n        }\r\n        int indexOfColon = ref.indexOf(':');\r\n        int indexOfSlash = ref.indexOf('/');\r\n        if ((indexOfColon != -1) && (indexOfSlash != -1) && (indexOfColon < indexOfSlash)) {\r\n            base = null;\r\n        }\r\n        int newDoc = getDoc(xctxt, context, ref.toString(), base);\r\n        if (DTM.NULL != newDoc) {\r\n            if (!mnl.contains(newDoc)) {\r\n                mnl.addElement(newDoc);\r\n            }\r\n        }\r\n        if (null == iterator || newDoc == DTM.NULL)\r\n            break;\r\n    }\r\n    return nodes;\r\n}"
}, {
	"Path": "com.google.cloud.tools.jib.registry.LocalRegistry.pullAndPushToLocal",
	"Comment": "pulls an image and pushes it to the local registry under a new tag.",
	"Method": "void pullAndPushToLocal(String from,String to){\r\n    login();\r\n    new Command(\"docker\", \"pull\", from).run();\r\n    new Command(\"docker\", \"tag\", from, \"localhost:\" + port + \"/\" + to).run();\r\n    new Command(\"docker\", \"push\", \"localhost:\" + port + \"/\" + to).run();\r\n    logout();\r\n}"
}, {
	"Path": "org.apache.xalan.transformer.TransformerHandlerImpl.setResult",
	"Comment": "enables the user of the transformerhandler to set theto set the result for the transformation.",
	"Method": "void setResult(Result result){\r\n    if (null == result)\r\n        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_RESULT_NULL, null));\r\n    try {\r\n        SerializationHandler xoh = m_transformer.createSerializationHandler(result);\r\n        m_transformer.setSerializationHandler(xoh);\r\n    } catch (javax.xml.transform.TransformerException te) {\r\n        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_RESULT_COULD_NOT_BE_SET, null));\r\n    }\r\n    m_result = result;\r\n}"
}, {
	"Path": "org.apache.xpath.functions.FunctionDef1Arg.getArg0AsString",
	"Comment": "execute the first argument expression that is expected to return astring.if the argument is null, then get the string value from thecurrent context node.",
	"Method": "XMLString getArg0AsString(XPathContext xctxt){\r\n    if (null == m_arg0) {\r\n        int currentNode = xctxt.getCurrentNode();\r\n        if (DTM.NULL == currentNode)\r\n            return XString.EMPTYSTRING;\r\n        else {\r\n            DTM dtm = xctxt.getDTM(currentNode);\r\n            return dtm.getStringValue(currentNode);\r\n        }\r\n    } else\r\n        return m_arg0.execute(xctxt).xstr();\r\n}"
}, {
	"Path": "org.apache.xpath.objects.XString.equals",
	"Comment": "compares this string to the specified object.the result is true if and only if the argument is notnull and is a string object that representsthe same sequence of characters as this object.",
	"Method": "boolean equals(XObject obj2,boolean equals,String obj2,boolean equals,XMLString obj2,boolean equals,Object obj2){\r\n    if (null == obj2)\r\n        return false;\r\n    else if (obj2 instanceof XNodeSet)\r\n        return obj2.equals(this);\r\n    else if (obj2 instanceof XNumber)\r\n        return obj2.equals(this);\r\n    else\r\n        return str().equals(obj2.toString());\r\n}"
}, {
	"Path": "com.iluwatar.factorykit.factorykit.FactoryKitTest.verifyWeapon",
	"Comment": "this method asserts that the weapon object that is passed is an instance of the clazz",
	"Method": "void verifyWeapon(Weapon weapon,Class<?> clazz){\r\n    assertTrue(clazz.isInstance(weapon), \"Weapon must be an object of: \" + clazz.getName());\r\n}"
}]