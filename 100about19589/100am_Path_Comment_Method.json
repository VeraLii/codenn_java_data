[{
	"Path": "java.nio.LongBuffer.allocate",
	"Comment": "creates a long buffer based on a newly allocated long array.",
	"Method": "LongBuffer allocate(int capacity){\r\n    if (capacity < 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return BufferFactory.newLongBuffer(capacity);\r\n}"
}, {
	"Path": "org.junit.runner.notification.RunNotifier.fireTestStarted",
	"Comment": "invoke to tell listeners that an atomic test is about to start.",
	"Method": "void fireTestStarted(Description description){\r\n    if (pleaseStop) {\r\n        throw new StoppedByUserException();\r\n    }\r\n    new SafeNotifier() {\r\n        @Override\r\n        protected void notifyListener(RunListener each) throws Exception {\r\n            each.testStarted(description);\r\n        }\r\n    }.run();\r\n}"
}, {
	"Path": "org.junit.runner.notification.RunNotifier.fireTestStarted",
	"Comment": "invoke to tell listeners that an atomic test is about to start.",
	"Method": "void fireTestStarted(Description description){\r\n    each.testStarted(description);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.getChar",
	"Comment": "finds the child with the specified index and returns it as a char.",
	"Method": "char getChar(String name,char defaultValue,char getChar,String name,char getChar,int index){\r\n    JsonValue child = get(index);\r\n    if (child == null)\r\n        throw new IllegalArgumentException(\"Indexed value not found: \" + name);\r\n    return child.asChar();\r\n}"
}, {
	"Path": "java.nio.ByteBuffer.allocateDirect",
	"Comment": "creates a direct byte buffer based on a newly allocated memory block.",
	"Method": "ByteBuffer allocateDirect(int capacity){\r\n    if (capacity < 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return BufferFactory.newDirectByteBuffer(capacity);\r\n}"
}, {
	"Path": "com.rey.material.app.Dialog.titleTextAppearance",
	"Comment": "sets the text color, size, style of the title view from the specified textappearance resource.",
	"Method": "Dialog titleTextAppearance(int resId){\r\n    mTitle.setTextAppearance(getContext(), resId);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Polyline.getVertices",
	"Comment": "returns vertices without scaling or rotation and without being offset by the polyline position.",
	"Method": "float[] getVertices(){\r\n    return localVertices;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox.getSelection",
	"Comment": "get the set of selected items, useful when multiple items are selected",
	"Method": "ArraySelection<T> getSelection(){\r\n    return selection;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.StringBuilder.deleteCharAt",
	"Comment": "deletes the character at the specified index. shifts any remaining characters to the left.",
	"Method": "StringBuilder deleteCharAt(int index){\r\n    deleteCharAt0(index);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.setBullet",
	"Comment": "should this body be treated like a bullet for continuous collision detection?",
	"Method": "void setBullet(boolean flag){\r\n    body.setBullet(flag);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Container.height",
	"Comment": "sets the minheight, prefheight, and maxheight to the specified value.",
	"Method": "Container<T> height(Value height,Container<T> height,float height){\r\n    height(new Fixed(height));\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.maps.tiled.renderers.OrthoCachedTiledMapRenderer.setOverCache",
	"Comment": "sets the percentage of the view that is cached in each direction. default is 0.5.\teg, 0.75 will cache 75% of the width of the view to the left and right of the view, and 75% of the height of the view above\tand below the view.",
	"Method": "void setOverCache(float overCache){\r\n    this.overCache = overCache;\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.MaterialCalendarView.onTouchEvent",
	"Comment": "pass all touch events to the pager so scrolling works on the edges of the calendar view.",
	"Method": "boolean onTouchEvent(MotionEvent event){\r\n    return pager.dispatchTouchEvent(event);\r\n}"
}, {
	"Path": "java.nio.FloatBuffer.allocate",
	"Comment": "creates a float buffer based on a newly allocated float array.",
	"Method": "FloatBuffer allocate(int capacity){\r\n    if (capacity < 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return BufferFactory.newFloatBuffer(capacity);\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar.onResize",
	"Comment": "this method is called when the dimensions of the parent element change. subclasses should override this method as needed.\tmove the text to the center of the progress bar.",
	"Method": "void onResize(int width,int height){\r\n    if (textVisible) {\r\n        int textWidth = DOM.getElementPropertyInt(textElement, \"offsetWidth\");\r\n        int left = (width / 2) - (textWidth / 2);\r\n        DOM.setStyleAttribute(textElement, \"left\", left + \"px\");\r\n    }\r\n}"
}, {
	"Path": "com.codahale.metrics.health.SharedHealthCheckRegistries.setDefault",
	"Comment": "sets the provided registry as the default one under the provided name",
	"Method": "HealthCheckRegistry setDefault(String name,HealthCheckRegistry setDefault,String name,HealthCheckRegistry healthCheckRegistry){\r\n    if (defaultRegistryName.compareAndSet(null, name)) {\r\n        add(name, healthCheckRegistry);\r\n        return healthCheckRegistry;\r\n    }\r\n    throw new IllegalStateException(\"Default health check registry is already set.\");\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntIntMap.findKey",
	"Comment": "returns the key for the specified value, or null if it is not in the map. note this traverses the entire map and compares\tevery value, which may be an expensive operation.",
	"Method": "int findKey(int value,int notFound){\r\n    if (hasZeroValue && zeroValue == value)\r\n        return 0;\r\n    int[] keyTable = this.keyTable, valueTable = this.valueTable;\r\n    for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != 0 && valueTable[i] == value)\r\n        return keyTable[i];\r\n    return notFound;\r\n}"
}, {
	"Path": "org.junit.runner.Request.filterWith",
	"Comment": "returns a request that only contains those tests that should run whenfilter is applied",
	"Method": "Request filterWith(Filter filter,Request filterWith,Description desiredDescription){\r\n    return filterWith(Filter.matchMethodDescription(desiredDescription));\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ArrayMap.truncate",
	"Comment": "reduces the size of the arrays to the specified size. if the arrays are already smaller than the specified size, no action\tis taken.",
	"Method": "void truncate(int newSize){\r\n    if (size <= newSize)\r\n        return;\r\n    for (int i = newSize; i < size; i++) {\r\n        keys[i] = null;\r\n        values[i] = null;\r\n    }\r\n    size = newSize;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar.setMaxProgress",
	"Comment": "set the maximum progress. if the minimum progress is more than the current progress, the current progress is adjusted to be\twithin the new range.",
	"Method": "void setMaxProgress(double maxProgress){\r\n    this.maxProgress = maxProgress;\r\n    curProgress = Math.min(curProgress, maxProgress);\r\n    resetProgress();\r\n}"
}, {
	"Path": "com.rey.material.widget.SnackBar.actionClickListener",
	"Comment": "set the listener will be called when the actionbutton is clicked.",
	"Method": "SnackBar actionClickListener(OnActionClickListener listener){\r\n    mActionClickListener = listener;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.SharedLibraryLoader.getExtractedFile",
	"Comment": "returns a path to a file that can be written. tries multiple locations and verifies writing succeeds.",
	"Method": "File getExtractedFile(String dirName,String fileName){\r\n    File idealFile = new File(System.getProperty(\"java.io.tmpdir\") + \"/libgdx\" + System.getProperty(\"user.name\") + \"/\" + dirName, fileName);\r\n    if (canWrite(idealFile))\r\n        return idealFile;\r\n    try {\r\n        File file = File.createTempFile(dirName, null);\r\n        if (file.delete()) {\r\n            file = new File(file, fileName);\r\n            if (canWrite(file))\r\n                return file;\r\n        }\r\n    } catch (IOException ignored) {\r\n    }\r\n    File file = new File(System.getProperty(\"user.home\") + \"/.libgdx/\" + dirName, fileName);\r\n    if (canWrite(file))\r\n        return file;\r\n    file = new File(\".temp/\" + dirName, fileName);\r\n    if (canWrite(file))\r\n        return file;\r\n    if (System.getenv(\"APP_SANDBOX_CONTAINER_ID\") != null)\r\n        return idealFile;\r\n    return null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.DragListener.isDragging",
	"Comment": "returns true if a touch has been dragged outside the tap square.",
	"Method": "boolean isDragging(){\r\n    return dragging;\r\n}"
}, {
	"Path": "com.rey.material.app.Dialog.neutralActionClickListener",
	"Comment": "set a listener will be called when neutral action button is clicked.",
	"Method": "Dialog neutralActionClickListener(View.OnClickListener listener){\r\n    mNeutralAction.setOnClickListener(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Table.pad",
	"Comment": "sets the padtop, padleft, padbottom, and padright around the table to the specified value.",
	"Method": "Table pad(Value pad,Table pad,Value top,Value left,Value bottom,Value right,Table pad,float pad,Table pad,float top,float left,float bottom,float right){\r\n    padTop = new Fixed(top);\r\n    padLeft = new Fixed(left);\r\n    padBottom = new Fixed(bottom);\r\n    padRight = new Fixed(right);\r\n    sizeInvalid = true;\r\n    return this;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.view.BezelImageView.setSelectorColor",
	"Comment": "sets the color of the selector to be draw over thecircularimageview. be sure to provide some opacity.",
	"Method": "void setSelectorColor(int selectorColor){\r\n    this.mSelectorColor = selectorColor;\r\n    this.mSelectorFilter = new PorterDuffColorFilter(Color.argb(mSelectorAlpha, Color.red(mSelectorColor), Color.green(mSelectorColor), Color.blue(mSelectorColor)), PorterDuff.Mode.SRC_ATOP);\r\n    this.invalidate();\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18.setPreserveEGLContextOnPause",
	"Comment": "control whether the egl context is preserved when the glsurfaceview is paused andresumed.if set to true, then the egl context may be preserved when the glsurfaceview is paused.whether the egl context is actually preserved or not depends upon whether theandroid device that the program is running on can support an arbitrary number of eglcontexts or not. devices that can only support a limited number of egl contexts mustrelease theegl context in order to allow multiple applications to share the gpu.if set to false, the egl context will be released when the glsurfaceview is paused,and recreated when the glsurfaceview is resumed.the default is false.",
	"Method": "void setPreserveEGLContextOnPause(boolean preserveOnPause){\r\n    mPreserveEGLContextOnPause = preserveOnPause;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox.setScrollingDisabled",
	"Comment": "disables scrolling of the list shown when the select box is open.",
	"Method": "void setScrollingDisabled(boolean y){\r\n    selectBoxList.setScrollingDisabled(true, y);\r\n    invalidateHierarchy();\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator.setDownscale",
	"Comment": "sets the factor by which to downscale the image during processing.\tthe output image will be smaller than the input image by this factor, rounded downwards.\t for greater accuracy, images to be used as input for a distance field are often\tgenerated at higher resolution.",
	"Method": "void setDownscale(int downscale){\r\n    if (downscale <= 0)\r\n        throw new IllegalArgumentException(\"downscale must be positive\");\r\n    this.downscale = downscale;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.TextureAtlas.dispose",
	"Comment": "releases all resources associated with this textureatlas instance. this releases all the textures backing all textureregions\tand sprites, which should no longer be used after calling dispose.",
	"Method": "void dispose(){\r\n    for (Texture texture : textures) texture.dispose();\r\n    textures.clear();\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Skin.getDrawable",
	"Comment": "returns a registered drawable. if no drawable is found but a region, ninepatch, or sprite exists with the name, then the\tappropriate drawable is created and stored in the skin.",
	"Method": "Drawable getDrawable(String name){\r\n    Drawable drawable = optional(name, Drawable.class);\r\n    if (drawable != null)\r\n        return drawable;\r\n    try {\r\n        TextureRegion textureRegion = getRegion(name);\r\n        if (textureRegion instanceof AtlasRegion) {\r\n            AtlasRegion region = (AtlasRegion) textureRegion;\r\n            if (region.splits != null)\r\n                drawable = new NinePatchDrawable(getPatch(name));\r\n            else if (region.rotate || region.packedWidth != region.originalWidth || region.packedHeight != region.originalHeight)\r\n                drawable = new SpriteDrawable(getSprite(name));\r\n        }\r\n        if (drawable == null)\r\n            drawable = new TextureRegionDrawable(textureRegion);\r\n    } catch (GdxRuntimeException ignored) {\r\n    }\r\n    if (drawable == null) {\r\n        NinePatch patch = optional(name, NinePatch.class);\r\n        if (patch != null)\r\n            drawable = new NinePatchDrawable(patch);\r\n        else {\r\n            Sprite sprite = optional(name, Sprite.class);\r\n            if (sprite != null)\r\n                drawable = new SpriteDrawable(sprite);\r\n            else\r\n                throw new GdxRuntimeException(\"No Drawable, NinePatch, TextureRegion, Texture, or Sprite registered with name: \" + name);\r\n        }\r\n    }\r\n    if (drawable instanceof BaseDrawable)\r\n        ((BaseDrawable) drawable).setName(name);\r\n    add(name, drawable, Drawable.class);\r\n    return drawable;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.ShaderProgram.dispose",
	"Comment": "disposes all resources associated with this shader. must be called when the shader is no longer used.",
	"Method": "void dispose(){\r\n    GL20 gl = Gdx.gl20;\r\n    gl.glUseProgram(0);\r\n    gl.glDeleteShader(vertexShaderHandle);\r\n    gl.glDeleteShader(fragmentShaderHandle);\r\n    gl.glDeleteProgram(program);\r\n    if (shaders.get(Gdx.app) != null)\r\n        shaders.get(Gdx.app).removeValue(this, true);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Table.getColumnWidth",
	"Comment": "returns the width of the specified column, or 0 if the table layout has not been validated.",
	"Method": "float getColumnWidth(int columnIndex){\r\n    if (columnWidth == null)\r\n        return 0;\r\n    return columnWidth[columnIndex];\r\n}"
}, {
	"Path": "junit.textui.ResultPrinter.elapsedTimeAsString",
	"Comment": "returns the formatted string of the elapsed time.duplicated from basetestrunner. fix it.",
	"Method": "String elapsedTimeAsString(long runTime){\r\n    return NumberFormat.getInstance().format((double) runTime / 1000);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.AccountHeader.setSelectionSecondLine",
	"Comment": "set this to define the second line in the selection area if there is no profilenote this will block any values from profiles!",
	"Method": "void setSelectionSecondLine(String selectionSecondLine){\r\n    mAccountHeaderBuilder.mSelectionSecondLine = selectionSecondLine;\r\n    mAccountHeaderBuilder.updateHeaderAndList();\r\n}"
}, {
	"Path": "org.jsoup.select.Elements.eachAttr",
	"Comment": "get the attribute value for each of the matched elements. if an element does not have this attribute, no value isincluded in the result set for that element.",
	"Method": "List<String> eachAttr(String attributeKey){\r\n    List<String> attrs = new ArrayList(size());\r\n    for (Element element : this) {\r\n        if (element.hasAttr(attributeKey))\r\n            attrs.add(element.attr(attributeKey));\r\n    }\r\n    return attrs;\r\n}"
}, {
	"Path": "lombok.javac.JavacAST.statementTypes",
	"Comment": "for javac, both jcexpression and jcstatement are considered as valid children types.",
	"Method": "Collection<Class<? extends JCTree>> statementTypes(){\r\n    Collection<Class<? extends JCTree>> collection = new ArrayList<Class<? extends JCTree>>(3);\r\n    collection.add(JCStatement.class);\r\n    collection.add(JCExpression.class);\r\n    collection.add(JCCatch.class);\r\n    return collection;\r\n}"
}, {
	"Path": "java.nio.ShortBuffer.array",
	"Comment": "returns the short array which this buffer is based on, if there is one.",
	"Method": "short[] array(){\r\n    return protectedArray();\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.MiniDrawer.getOnMiniDrawerItemOnClickListener",
	"Comment": "the defined fastadapter.onclicklistener which completely replaces the original behavior",
	"Method": "OnClickListener getOnMiniDrawerItemOnClickListener(){\r\n    return mOnMiniDrawerItemOnClickListener;\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.MaterialCalendarView.setOnDateChangedListener",
	"Comment": "sets the listener to be notified upon selected date changes.",
	"Method": "void setOnDateChangedListener(OnDateSelectedListener listener){\r\n    this.listener = listener;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar.isVertical",
	"Comment": "true if the progress bar is vertical, false if it is horizontal.",
	"Method": "boolean isVertical(){\r\n    return vertical;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.roundPositive",
	"Comment": "returns the closest integer to the specified float. this method will only properly round floats that are positive.",
	"Method": "int roundPositive(float value){\r\n    return (int) (value + 0.5f);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IdentityMap.containsValue",
	"Comment": "returns true if the specified value is in the map. note this traverses the entire map and compares every value, which may be\tan expensive operation.",
	"Method": "boolean containsValue(Object value,boolean identity){\r\n    V[] valueTable = this.valueTable;\r\n    if (value == null) {\r\n        K[] keyTable = this.keyTable;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != null && valueTable[i] == null)\r\n            return true;\r\n    } else if (identity) {\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (valueTable[i] == value)\r\n            return true;\r\n    } else {\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (value.equals(valueTable[i]))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.Animation.getKeyFrame",
	"Comment": "returns a frame based on the so called state time. this is the amount of seconds an object has spent in the\tstate this animation instance represents, e.g. running, jumping and so on. the mode specifies whether the animation is\tlooping or not.",
	"Method": "T getKeyFrame(float stateTime,boolean looping,T getKeyFrame,float stateTime){\r\n    int frameNumber = getKeyFrameIndex(stateTime);\r\n    return keyFrames[frameNumber];\r\n}"
}, {
	"Path": "org.jsoup.nodes.Attributes.equals",
	"Comment": "checks if these attributes are equal to another set of attributes, by comparing the two sets",
	"Method": "boolean equals(Object o){\r\n    if (this == o)\r\n        return true;\r\n    if (o == null || getClass() != o.getClass())\r\n        return false;\r\n    Attributes that = (Attributes) o;\r\n    if (size != that.size)\r\n        return false;\r\n    if (!Arrays.equals(keys, that.keys))\r\n        return false;\r\n    return Arrays.equals(vals, that.vals);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.decals.Decal.newDecal",
	"Comment": "creates a decal using the region for texturing and the specified blending parameters for blending",
	"Method": "Decal newDecal(TextureRegion textureRegion,Decal newDecal,TextureRegion textureRegion,boolean hasTransparency,Decal newDecal,float width,float height,TextureRegion textureRegion,Decal newDecal,float width,float height,TextureRegion textureRegion,boolean hasTransparency,Decal newDecal,float width,float height,TextureRegion textureRegion,int srcBlendFactor,int dstBlendFactor,Decal newDecal,float width,float height,TextureRegion textureRegion,int srcBlendFactor,int dstBlendFactor,DecalMaterial material){\r\n    Decal decal = new Decal(material);\r\n    decal.setTextureRegion(textureRegion);\r\n    decal.setBlending(srcBlendFactor, dstBlendFactor);\r\n    decal.dimensions.x = width;\r\n    decal.dimensions.y = height;\r\n    decal.setColor(1, 1, 1, 1);\r\n    return decal;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Group.setCullingArea",
	"Comment": "children completely outside of this rectangle will not be drawn. this is only valid for use with unrotated and unscaled\tactors.",
	"Method": "void setCullingArea(Rectangle cullingArea){\r\n    this.cullingArea = cullingArea;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup.wrapSpace",
	"Comment": "sets the horizontal space between columns when wrap is enabled.",
	"Method": "VerticalGroup wrapSpace(float wrapSpace){\r\n    this.wrapSpace = wrapSpace;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleController.init",
	"Comment": "initialize the controller. all the sub systems will be initialized and binded to the controller. must be called before any\tother method.",
	"Method": "void init(){\r\n    bind();\r\n    if (particles != null) {\r\n        end();\r\n        particleChannels.resetIds();\r\n    }\r\n    allocateChannels(emitter.maxParticleCount);\r\n    emitter.init();\r\n    for (Influencer influencer : influencers) influencer.init();\r\n    renderer.init();\r\n}"
}, {
	"Path": "com.sun.jna.Memory.getLong",
	"Comment": "indirect the native pointer to malloc space, a lapointer.getlong.but this method performs a boundschecks to ensure that the indirection does not cause memory outside themalloced space to be accessed.",
	"Method": "long getLong(long offset){\r\n    boundsCheck(offset, 8);\r\n    return super.getLong(offset);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Table.getRowHeight",
	"Comment": "returns the height of the specified row, or 0 if the table layout has not been validated.",
	"Method": "float getRowHeight(int rowIndex){\r\n    if (rowHeight == null)\r\n        return 0;\r\n    return rowHeight[rowIndex];\r\n}"
}, {
	"Path": "org.jsoup.nodes.NodeUtils.parser",
	"Comment": "get the parser that was used to make this node, or the default html parser if it has no parent.",
	"Method": "Parser parser(Node node){\r\n    Document doc = node.ownerDocument();\r\n    return doc != null && doc.parser() != null ? doc.parser() : new Parser(new HtmlTreeBuilder());\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getEllipsize",
	"Comment": "returns where, if anywhere, words that are longer than the viewis wide should be ellipsized.",
	"Method": "TruncateAt getEllipsize(){\r\n    return mInputView.getEllipsize();\r\n}"
}, {
	"Path": "java.nio.FloatBuffer.arrayOffset",
	"Comment": "returns the offset of the float array which this buffer is based on, if there is one.\tthe offset is the index of the array and corresponds to the zero position of the buffer.",
	"Method": "int arrayOffset(){\r\n    return protectedArrayOffset();\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Fixture.getBody",
	"Comment": "get the parent body of this fixture. this is null if the fixture is not attached.",
	"Method": "Body getBody(){\r\n    return body;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio.forget",
	"Comment": "removes the disposed sound from the least recently played list",
	"Method": "void forget(OpenALSound sound){\r\n    for (int i = 0; i < recentSounds.length; i++) {\r\n        if (recentSounds[i] == sound)\r\n            recentSounds[i] = null;\r\n    }\r\n}"
}, {
	"Path": "java.nio.CharBuffer.toString",
	"Comment": "returns a string representing the current remaining chars of this buffer.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = position; i < limit; i++) {\r\n        sb.append(get(i));\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.COM.util.ObjectFactory.createProxy",
	"Comment": "creates a proxyobject for the given interface and idispatch pointer.",
	"Method": "T createProxy(Class<T> comInterface,IDispatch dispatch){\r\n    assert COMUtils.comIsInitialized() : \"COM not initialized\";\r\n    ProxyObject jop = new ProxyObject(comInterface, dispatch, this);\r\n    Object proxy = Proxy.newProxyInstance(comInterface.getClassLoader(), new Class<?>[] { comInterface }, jop);\r\n    T result = comInterface.cast(proxy);\r\n    return result;\r\n}"
}, {
	"Path": "java.nio.Buffer.limit",
	"Comment": "sets the limit of this buffer.\tif the current position in the buffer is in excess of newlimit then, on returning from this call, it will have\tbeen adjusted to be equivalent to newlimit. if the mark is set and is greater than the new limit, then it is\tcleared.",
	"Method": "int limit(Buffer limit,int newLimit){\r\n    if (newLimit < 0 || newLimit > capacity) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    limit = newLimit;\r\n    if (position > newLimit) {\r\n        position = newLimit;\r\n    }\r\n    if ((mark != UNSET_MARK) && (mark > newLimit)) {\r\n        mark = UNSET_MARK;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Intersector.isPointInTriangle",
	"Comment": "returns whether the given point is inside the triangle. this assumes that the point is on the plane of the triangle. no\tcheck is performed that this is the case.",
	"Method": "boolean isPointInTriangle(Vector3 point,Vector3 t1,Vector3 t2,Vector3 t3,boolean isPointInTriangle,Vector2 p,Vector2 a,Vector2 b,Vector2 c,boolean isPointInTriangle,float px,float py,float ax,float ay,float bx,float by,float cx,float cy){\r\n    float px1 = px - ax;\r\n    float py1 = py - ay;\r\n    boolean side12 = (bx - ax) * py1 - (by - ay) * px1 > 0;\r\n    if ((cx - ax) * py1 - (cy - ay) * px1 > 0 == side12)\r\n        return false;\r\n    if ((cx - bx) * (py - by) - (cy - by) * (px - bx) > 0 != side12)\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox.setSelected",
	"Comment": "sets the selection to only the passed item, if it is a possible choice, else selects the first item.",
	"Method": "void setSelected(T item){\r\n    if (items.contains(item, false))\r\n        selection.set(item);\r\n    else if (items.size > 0)\r\n        selection.set(items.first());\r\n    else\r\n        selection.clear();\r\n}"
}, {
	"Path": "com.badlogic.gdx.assets.AssetManager.contains",
	"Comment": "returns true if an asset with the specified name and type is loading, queued to be loaded, or has been loaded.",
	"Method": "boolean contains(String fileName,boolean contains,String fileName,Class type){\r\n    if (tasks.size() > 0) {\r\n        AssetDescriptor assetDesc = tasks.firstElement().assetDesc;\r\n        if (assetDesc.type == type && assetDesc.fileName.equals(fileName))\r\n            return true;\r\n    }\r\n    for (int i = 0; i < loadQueue.size; i++) {\r\n        AssetDescriptor assetDesc = loadQueue.get(i);\r\n        if (assetDesc.type == type && assetDesc.fileName.equals(fileName))\r\n            return true;\r\n    }\r\n    return isLoaded(fileName, type);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withSliderBackgroundColor",
	"Comment": "set the background color for the slider.this is the view containing the list.",
	"Method": "DrawerBuilder withSliderBackgroundColor(int sliderBackgroundColor){\r\n    this.mSliderBackgroundColor = sliderBackgroundColor;\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jna.NativeLibrary.getLinuxLdPaths",
	"Comment": "get the library paths from ldconfig cache. tested against ldconfig 2.13.",
	"Method": "ArrayList<String> getLinuxLdPaths(){\r\n    ArrayList<String> ldPaths = new ArrayList<String>();\r\n    BufferedReader reader = null;\r\n    try {\r\n        Process process = Runtime.getRuntime().exec(\"/sbin/ldconfig -p\");\r\n        reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\r\n        String buffer;\r\n        while ((buffer = reader.readLine()) != null) {\r\n            int startPath = buffer.indexOf(\" => \");\r\n            int endPath = buffer.lastIndexOf('/');\r\n            if (startPath != -1 && endPath != -1 && startPath < endPath) {\r\n                String path = buffer.substring(startPath + 4, endPath);\r\n                if (!ldPaths.contains(path)) {\r\n                    ldPaths.add(path);\r\n                }\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n    } finally {\r\n        if (reader != null) {\r\n            try {\r\n                reader.close();\r\n            } catch (IOException e) {\r\n            }\r\n        }\r\n    }\r\n    return ldPaths;\r\n}"
}, {
	"Path": "java.nio.FloatBuffer.array",
	"Comment": "returns the float array which this buffer is based on, if there is one.",
	"Method": "float[] array(){\r\n    return protectedArray();\r\n}"
}, {
	"Path": "java.nio.LongBuffer.arrayOffset",
	"Comment": "returns the offset of the long array which this buffer is based on, if there is one.\tthe offset is the index of the array and corresponds to the zero position of the buffer.",
	"Method": "int arrayOffset(){\r\n    return protectedArrayOffset();\r\n}"
}, {
	"Path": "com.badlogic.gdx.jnigen.FileDescriptor.writeBytes",
	"Comment": "writes the specified bytes to the file. parent directories will be created if necessary.",
	"Method": "void writeBytes(byte[] bytes,boolean append){\r\n    OutputStream output = write(append);\r\n    try {\r\n        output.write(bytes);\r\n    } catch (IOException ex) {\r\n        throw new RuntimeException(\"Error writing file: \" + file + \" (\" + type + \")\", ex);\r\n    } finally {\r\n        try {\r\n            output.close();\r\n        } catch (IOException ignored) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Action.setPool",
	"Comment": "sets the pool that the action will be returned to when removed from the actor.",
	"Method": "void setPool(Pool pool){\r\n    this.pool = pool;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader.save",
	"Comment": "saves the effect to the given file contained in the passed in parameter.",
	"Method": "void save(ParticleEffect effect,ParticleEffectSaveParameter parameter){\r\n    ResourceData<ParticleEffect> data = new ResourceData<ParticleEffect>(effect);\r\n    effect.save(parameter.manager, data);\r\n    if (parameter.batches != null) {\r\n        for (ParticleBatch<?> batch : parameter.batches) {\r\n            boolean save = false;\r\n            for (ParticleController controller : effect.getControllers()) {\r\n                if (controller.renderer.isCompatible(batch)) {\r\n                    save = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (save)\r\n                batch.save(parameter.manager, data);\r\n        }\r\n    }\r\n    Json json = new Json();\r\n    json.toJson(data, parameter.file);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.asCharArray",
	"Comment": "returns the children of this value as a newly allocated char array.",
	"Method": "char[] asCharArray(){\r\n    if (type != ValueType.array)\r\n        throw new IllegalStateException(\"Value is not an array: \" + type);\r\n    char[] array = new char[size];\r\n    int i = 0;\r\n    for (JsonValue value = child; value != null; value = value.next, i++) {\r\n        char v;\r\n        switch(value.type) {\r\n            case stringValue:\r\n                v = value.stringValue.length() == 0 ? 0 : value.stringValue.charAt(0);\r\n                break;\r\n            case doubleValue:\r\n                v = (char) value.doubleValue;\r\n                break;\r\n            case longValue:\r\n                v = (char) value.longValue;\r\n                break;\r\n            case booleanValue:\r\n                v = value.longValue != 0 ? (char) 1 : 0;\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Value cannot be converted to char: \" + value.type);\r\n        }\r\n        array[i] = v;\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.model.SecondaryDrawerItem.getColor",
	"Comment": "helper method to decide for the correct coloroverwrite to get the correct secondary color",
	"Method": "int getColor(Context ctx){\r\n    int color;\r\n    if (this.isEnabled()) {\r\n        color = ColorHolder.color(getTextColor(), ctx, R.attr.material_drawer_secondary_text, R.color.material_drawer_secondary_text);\r\n    } else {\r\n        color = ColorHolder.color(getDisabledTextColor(), ctx, R.attr.material_drawer_hint_text, R.color.material_drawer_hint_text);\r\n    }\r\n    return color;\r\n}"
}, {
	"Path": "com.sun.jna.CallbackReference.getNativeFunctionPointer",
	"Comment": "if the callback is one we generated to wrap a native function pointer,return that.otherwise return null.",
	"Method": "Pointer getNativeFunctionPointer(Callback cb){\r\n    if (Proxy.isProxyClass(cb.getClass())) {\r\n        Object handler = Proxy.getInvocationHandler(cb);\r\n        if (handler instanceof NativeFunctionHandler) {\r\n            return ((NativeFunctionHandler) handler).getPointer();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.TimSort.gallopRight",
	"Comment": "like gallopleft, except that if the range contains an element equal to key, gallopright returns the index after the\trightmost equal element.",
	"Method": "int gallopRight(T key,T[] a,int base,int len,int hint,Comparator<? super T> c){\r\n    if (DEBUG)\r\n        assert len > 0 && hint >= 0 && hint < len;\r\n    int ofs = 1;\r\n    int lastOfs = 0;\r\n    if (c.compare(key, a[base + hint]) < 0) {\r\n        int maxOfs = hint + 1;\r\n        while (ofs < maxOfs && c.compare(key, a[base + hint - ofs]) < 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        int tmp = lastOfs;\r\n        lastOfs = hint - ofs;\r\n        ofs = hint - tmp;\r\n    } else {\r\n        int maxOfs = len - hint;\r\n        while (ofs < maxOfs && c.compare(key, a[base + hint + ofs]) >= 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        lastOfs += hint;\r\n        ofs += hint;\r\n    }\r\n    if (DEBUG)\r\n        assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;\r\n    lastOfs++;\r\n    while (lastOfs < ofs) {\r\n        int m = lastOfs + ((ofs - lastOfs) >>> 1);\r\n        if (c.compare(key, a[base + m]) < 0)\r\n            ofs = m;\r\n        else\r\n            lastOfs = m + 1;\r\n    }\r\n    if (DEBUG)\r\n        assert lastOfs == ofs;\r\n    return ofs;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane.updateVisualScroll",
	"Comment": "sets the visual scroll amount equal to the scroll amount. this can be used when setting the scroll amount without\tanimating.",
	"Method": "void updateVisualScroll(){\r\n    visualAmountX = amountX;\r\n    visualAmountY = amountY;\r\n}"
}, {
	"Path": "lombok.javac.handlers.JavacHandlerUtil.createListOfNonExistentFields",
	"Comment": "given a list of field names and a node referring to a type, finds each name in the list that does not match a field within the type.",
	"Method": "List<Integer> createListOfNonExistentFields(List<String> list,JavacNode type,boolean excludeStandard,boolean excludeTransient){\r\n    boolean[] matched = new boolean[list.size()];\r\n    for (JavacNode child : type.down()) {\r\n        if (list.isEmpty())\r\n            break;\r\n        if (child.getKind() != Kind.FIELD)\r\n            continue;\r\n        JCVariableDecl field = (JCVariableDecl) child.get();\r\n        if (excludeStandard) {\r\n            if ((field.mods.flags & Flags.STATIC) != 0)\r\n                continue;\r\n            if (field.name.toString().startsWith(\"$\"))\r\n                continue;\r\n        }\r\n        if (excludeTransient && (field.mods.flags & Flags.TRANSIENT) != 0)\r\n            continue;\r\n        int idx = list.indexOf(child.getName());\r\n        if (idx > -1)\r\n            matched[idx] = true;\r\n    }\r\n    ListBuffer<Integer> problematic = new ListBuffer<Integer>();\r\n    for (int i = 0; i < list.size(); i++) {\r\n        if (!matched[i])\r\n            problematic.append(i);\r\n    }\r\n    return problematic.toList();\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.createBody",
	"Comment": "create a rigid body given a definition. no reference to the definition is retained.",
	"Method": "Body createBody(BodyDef def){\r\n    org.jbox2d.dynamics.BodyDef bd = new org.jbox2d.dynamics.BodyDef();\r\n    bd.active = def.active;\r\n    bd.allowSleep = def.allowSleep;\r\n    bd.angle = def.angle;\r\n    bd.angularDamping = def.angularDamping;\r\n    bd.angularVelocity = def.angularVelocity;\r\n    bd.awake = def.awake;\r\n    bd.bullet = def.bullet;\r\n    bd.fixedRotation = def.fixedRotation;\r\n    bd.gravityScale = def.gravityScale;\r\n    bd.linearDamping = def.linearDamping;\r\n    bd.linearVelocity.set(def.linearVelocity.x, def.linearVelocity.y);\r\n    bd.position.set(def.position.x, def.position.y);\r\n    if (def.type == BodyType.DynamicBody)\r\n        bd.type = org.jbox2d.dynamics.BodyType.DYNAMIC;\r\n    if (def.type == BodyType.StaticBody)\r\n        bd.type = org.jbox2d.dynamics.BodyType.STATIC;\r\n    if (def.type == BodyType.KinematicBody)\r\n        bd.type = org.jbox2d.dynamics.BodyType.KINEMATIC;\r\n    org.jbox2d.dynamics.Body b = world.createBody(bd);\r\n    Body body = new Body(this, b);\r\n    bodies.put(b, body);\r\n    return body;\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.Secur32Util.getUserNameEx",
	"Comment": "retrieves the name of the user or other security principal associated \twith the calling thread.",
	"Method": "String getUserNameEx(int format){\r\n    char[] buffer = new char[128];\r\n    IntByReference len = new IntByReference(buffer.length);\r\n    boolean result = Secur32.INSTANCE.GetUserNameEx(format, buffer, len);\r\n    if (!result) {\r\n        int rc = Kernel32.INSTANCE.GetLastError();\r\n        switch(rc) {\r\n            case W32Errors.ERROR_MORE_DATA:\r\n                buffer = new char[len.getValue() + 1];\r\n                break;\r\n            default:\r\n                throw new Win32Exception(Native.getLastError());\r\n        }\r\n        result = Secur32.INSTANCE.GetUserNameEx(format, buffer, len);\r\n    }\r\n    if (!result) {\r\n        throw new Win32Exception(Native.getLastError());\r\n    }\r\n    return Native.toString(buffer);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Cell.getComputedPadRight",
	"Comment": "the actual amount of combined padding and spacing from the last layout.",
	"Method": "float getComputedPadRight(){\r\n    return computedPadRight;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectIntMap.containsValue",
	"Comment": "returns true if the specified value is in the map. note this traverses the entire map and compares every value, which may be\tan expensive operation.",
	"Method": "boolean containsValue(int value){\r\n    K[] keyTable = this.keyTable;\r\n    int[] valueTable = this.valueTable;\r\n    for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != null && valueTable[i] == value)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.junit.runner.JUnitCore.run",
	"Comment": "run all the tests contained in junit 3.8.x test. here for backward compatibility.",
	"Method": "Result run(Class<?> classes,Result run,Computer computer,Class<?> classes,Result run,Request request,Result run,junit.framework.Test test,Result run,Runner runner){\r\n    Result result = new Result();\r\n    RunListener listener = result.createListener();\r\n    notifier.addFirstListener(listener);\r\n    try {\r\n        notifier.fireTestRunStarted(runner.getDescription());\r\n        runner.run(notifier);\r\n        notifier.fireTestRunFinished(result);\r\n    } finally {\r\n        removeListener(listener);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "java.nio.ByteBuffer.put",
	"Comment": "write a byte to the specified index of this buffer without changing the position.",
	"Method": "ByteBuffer put(byte b,ByteBuffer put,byte[] src,ByteBuffer put,byte[] src,int off,int len,ByteBuffer put,ByteBuffer src,ByteBuffer put,int index,byte b){\r\n    if (src == this) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (src.remaining() > remaining()) {\r\n        throw new BufferOverflowException();\r\n    }\r\n    byte[] contents = new byte[src.remaining()];\r\n    src.get(contents);\r\n    put(contents);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.joints.WeldJointDef.initialize",
	"Comment": "initialize the bodies, anchors, and reference angle using a world anchor point.",
	"Method": "void initialize(Body body1,Body body2,Vector2 anchor){\r\n    this.bodyA = body1;\r\n    this.bodyB = body2;\r\n    this.localAnchorA.set(body1.getLocalPoint(anchor));\r\n    this.localAnchorB.set(body2.getLocalPoint(anchor));\r\n    referenceAngle = body2.getAngle() - body1.getAngle();\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getTotalPaddingStart",
	"Comment": "returns the total start padding of the view, including the startdrawable if any.",
	"Method": "int getTotalPaddingStart(){\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1)\r\n        return getPaddingStart() + mInputView.getTotalPaddingStart();\r\n    return getTotalPaddingLeft();\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Vector3.crs",
	"Comment": "sets this vector to the cross product between it and the other vector.",
	"Method": "Vector3 crs(Vector3 vector,Vector3 crs,float x,float y,float z){\r\n    return this.set(this.y * z - this.z * y, this.z * x - this.x * z, this.x * y - this.y * x);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Camera.rotateAround",
	"Comment": "rotates the direction and up vector of this camera by the given angle around the given axis, with the axis attached to given\tpoint. the direction and up vector will not be orthogonalized.",
	"Method": "void rotateAround(Vector3 point,Vector3 axis,float angle){\r\n    tmpVec.set(point);\r\n    tmpVec.sub(position);\r\n    translate(tmpVec);\r\n    rotate(axis, angle);\r\n    tmpVec.rotate(axis, angle);\r\n    translate(-tmpVec.x, -tmpVec.y, -tmpVec.z);\r\n}"
}, {
	"Path": "java.nio.ShortBuffer.put",
	"Comment": "writes shorts from the given short array, starting from the specified offset, to the current position and increases the\tposition by the number of shorts written.",
	"Method": "ShortBuffer put(short s,ShortBuffer put,short[] src,ShortBuffer put,short[] src,int off,int len,ShortBuffer put,ShortBuffer src,ShortBuffer put,int index,short s){\r\n    if (src == this) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (src.remaining() > remaining()) {\r\n        throw new BufferOverflowException();\r\n    }\r\n    short[] contents = new short[src.remaining()];\r\n    src.get(contents);\r\n    put(contents);\r\n    return this;\r\n}"
}, {
	"Path": "com.rey.material.app.Recurring.setPeriod",
	"Comment": "set the period of this recurring obj. depend on repeat mode, the unit can be days, weeks, months or years.",
	"Method": "void setPeriod(int period){\r\n    mPeriod = period;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Mesh.setVertices",
	"Comment": "sets the vertices of this mesh. the attributes are assumed to be given in float format.",
	"Method": "Mesh setVertices(float[] vertices,Mesh setVertices,float[] vertices,int offset,int count){\r\n    this.vertices.setVertices(vertices, offset, count);\r\n    return this;\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.MaterialCalendarView.state",
	"Comment": "preserve the current parameters of the material calendar view.",
	"Method": "State state(){\r\n    return state;\r\n}"
}, {
	"Path": "org.junit.experimental.max.MaxCore.storedLocally",
	"Comment": "create a new maxcore from a serialized file stored at storedresults",
	"Method": "MaxCore storedLocally(File storedResults){\r\n    return new MaxCore(storedResults);\r\n}"
}, {
	"Path": "com.badlogic.gdx.files.FileHandle.reader",
	"Comment": "returns a buffered reader for reading this file as characters.",
	"Method": "Reader reader(Reader reader,String charset,BufferedReader reader,int bufferSize,BufferedReader reader,int bufferSize,String charset){\r\n    try {\r\n        return new BufferedReader(new InputStreamReader(read(), charset), bufferSize);\r\n    } catch (UnsupportedEncodingException ex) {\r\n        throw new GdxRuntimeException(\"Error reading file: \" + this, ex);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectMap.get",
	"Comment": "returns the value for the specified key, or the default value if the key is not in the map.",
	"Method": "V get(K key,V get,K key,V defaultValue){\r\n    int hashCode = key.hashCode();\r\n    int index = hashCode & mask;\r\n    if (!key.equals(keyTable[index])) {\r\n        index = hash2(hashCode);\r\n        if (!key.equals(keyTable[index])) {\r\n            index = hash3(hashCode);\r\n            if (!key.equals(keyTable[index]))\r\n                return getStash(key, defaultValue);\r\n        }\r\n    }\r\n    return valueTable[index];\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper.reader",
	"Comment": "returns a buffered reader for reading this file as characters.",
	"Method": "Reader reader(Reader reader,String charset,BufferedReader reader,int bufferSize,BufferedReader reader,int bufferSize,String charset){\r\n    try {\r\n        return new BufferedReader(new InputStreamReader(read(), charset), bufferSize);\r\n    } catch (UnsupportedEncodingException ex) {\r\n        throw new GdxRuntimeException(\"Error reading file: \" + this, ex);\r\n    }\r\n}"
}, {
	"Path": "org.jsoup.integration.UrlConnectTest.postHtmlFile",
	"Comment": "test fetching a form, and submitting it with a file attached.",
	"Method": "void postHtmlFile(){\r\n    Document index = Jsoup.connect(\"http://direct.infohound.net/tidy/\").get();\r\n    FormElement form = index.select(\"[name=tidy]\").forms().get(0);\r\n    Connection post = form.submit();\r\n    File uploadFile = ParseTest.getFile(\"/htmltests/google-ipod.html\");\r\n    FileInputStream stream = new FileInputStream(uploadFile);\r\n    Connection.KeyVal fileData = post.data(\"_file\");\r\n    fileData.value(\"check.html\");\r\n    fileData.inputStream(stream);\r\n    Connection.Response res;\r\n    try {\r\n        res = post.execute();\r\n    } finally {\r\n        stream.close();\r\n    }\r\n    Document out = res.parse();\r\n    assertTrue(out.text().contains(\"HTML Tidy Complete\"));\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect.setScale",
	"Comment": "changes the height of the gradient by a percentage. the gradient is normally the height of most glyphs in the font.",
	"Method": "void setScale(float scale){\r\n    this.scale = scale;\r\n}"
}, {
	"Path": "com.badlogic.gdx.jnigen.FileDescriptor.reader",
	"Comment": "returns a buffered reader for reading this file as characters.",
	"Method": "Reader reader(Reader reader,String charset,BufferedReader reader,int bufferSize,BufferedReader reader,int bufferSize,String charset){\r\n    try {\r\n        return new BufferedReader(new InputStreamReader(read(), charset), bufferSize);\r\n    } catch (UnsupportedEncodingException ex) {\r\n        throw new RuntimeException(\"Error reading file: \" + this, ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jna.Structure.getAutoRead",
	"Comment": "returns whether the structure is read from native memory aftera native function call.",
	"Method": "boolean getAutoRead(){\r\n    return this.autoRead;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntIntMap.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "void ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded >= threshold)\r\n        resize(MathUtils.nextPowerOfTwo((int) Math.ceil(sizeNeeded / loadFactor)));\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener.cancel",
	"Comment": "if a touch down is being monitored, the drag and touch up events are ignored until the next touch up.",
	"Method": "void cancel(){\r\n    if (pressedPointer == -1)\r\n        return;\r\n    cancelled = true;\r\n    pressed = false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.add",
	"Comment": "add the x,y,z,w components of the passed in quaternion to the ones of this quaternion",
	"Method": "Quaternion add(Quaternion quaternion,Quaternion add,float qx,float qy,float qz,float qw){\r\n    this.x += qx;\r\n    this.y += qy;\r\n    this.z += qz;\r\n    this.w += qw;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.utils.AnimationController.setAnimation",
	"Comment": "set the active animation, replacing any current animation.",
	"Method": "AnimationDesc setAnimation(String id,AnimationDesc setAnimation,String id,int loopCount,AnimationDesc setAnimation,String id,AnimationListener listener,AnimationDesc setAnimation,String id,int loopCount,AnimationListener listener,AnimationDesc setAnimation,String id,int loopCount,float speed,AnimationListener listener,AnimationDesc setAnimation,String id,float offset,float duration,int loopCount,float speed,AnimationListener listener,AnimationDesc setAnimation,Animation anim,float offset,float duration,int loopCount,float speed,AnimationListener listener,AnimationDesc setAnimation,AnimationDesc anim){\r\n    if (current == null)\r\n        current = anim;\r\n    else {\r\n        if (!allowSameAnimation && anim != null && current.animation == anim.animation)\r\n            anim.time = current.time;\r\n        else\r\n            removeAnimation(current.animation);\r\n        animationPool.free(current);\r\n        current = anim;\r\n    }\r\n    justChangedAnimation = true;\r\n    return anim;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Matrix4.set",
	"Comment": "sets the matrix to a rotation matrix representing the translation and quaternion.",
	"Method": "Matrix4 set(Matrix4 matrix,Matrix4 set,float[] values,Matrix4 set,Quaternion quaternion,Matrix4 set,float quaternionX,float quaternionY,float quaternionZ,float quaternionW,Matrix4 set,Vector3 position,Quaternion orientation,Matrix4 set,float translationX,float translationY,float translationZ,float quaternionX,float quaternionY,float quaternionZ,float quaternionW,Matrix4 set,Vector3 position,Quaternion orientation,Vector3 scale,Matrix4 set,float translationX,float translationY,float translationZ,float quaternionX,float quaternionY,float quaternionZ,float quaternionW,float scaleX,float scaleY,float scaleZ,Matrix4 set,Vector3 xAxis,Vector3 yAxis,Vector3 zAxis,Vector3 pos,Matrix4 set,Matrix3 mat,Matrix4 set,Affine2 affine){\r\n    val[M00] = affine.m00;\r\n    val[M10] = affine.m10;\r\n    val[M20] = 0;\r\n    val[M30] = 0;\r\n    val[M01] = affine.m01;\r\n    val[M11] = affine.m11;\r\n    val[M21] = 0;\r\n    val[M31] = 0;\r\n    val[M02] = 0;\r\n    val[M12] = 0;\r\n    val[M22] = 1;\r\n    val[M32] = 0;\r\n    val[M03] = affine.m02;\r\n    val[M13] = affine.m12;\r\n    val[M23] = 0;\r\n    val[M33] = 1;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.getLinearVelocityFromLocalPoint",
	"Comment": "get the world velocity of a local point.\tnote that the same vector2 instance is returned each time this method is called.",
	"Method": "Vector2 getLinearVelocityFromLocalPoint(Vector2 localPoint){\r\n    tmp.set(localPoint.x, localPoint.y);\r\n    Vec2 lv = body.getLinearVelocityFromLocalPoint(tmp);\r\n    return linVelLoc.set(lv.x, lv.y);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.GridPoint3.set",
	"Comment": "sets the coordinates of this 3d grid point to that of another.",
	"Method": "GridPoint3 set(GridPoint3 point,GridPoint3 set,int x,int y,int z){\r\n    this.x = x;\r\n    this.y = y;\r\n    this.z = z;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.getPitch",
	"Comment": "get the pitch euler angle in degrees, which is the rotation around the x axis. requires that this quaternion is normalized.",
	"Method": "float getPitch(){\r\n    return getPitchRad() * MathUtils.radiansToDegrees;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.UBJsonReader.parse",
	"Comment": "parses the ubjson from the given stream. \tfor best performance you should provide buffered streams to this method!",
	"Method": "JsonValue parse(InputStream input,JsonValue parse,FileHandle file,JsonValue parse,DataInputStream din,JsonValue parse,DataInputStream din,byte type){\r\n    if (type == '[')\r\n        return parseArray(din);\r\n    else if (type == '{')\r\n        return parseObject(din);\r\n    else if (type == 'Z')\r\n        return new JsonValue(JsonValue.ValueType.nullValue);\r\n    else if (type == 'T')\r\n        return new JsonValue(true);\r\n    else if (type == 'F')\r\n        return new JsonValue(false);\r\n    else if (type == 'B')\r\n        return new JsonValue((long) readUChar(din));\r\n    else if (type == 'U')\r\n        return new JsonValue((long) readUChar(din));\r\n    else if (type == 'i')\r\n        return new JsonValue(oldFormat ? (long) din.readShort() : (long) din.readByte());\r\n    else if (type == 'I')\r\n        return new JsonValue(oldFormat ? (long) din.readInt() : (long) din.readShort());\r\n    else if (type == 'l')\r\n        return new JsonValue((long) din.readInt());\r\n    else if (type == 'L')\r\n        return new JsonValue(din.readLong());\r\n    else if (type == 'd')\r\n        return new JsonValue(din.readFloat());\r\n    else if (type == 'D')\r\n        return new JsonValue(din.readDouble());\r\n    else if (type == 's' || type == 'S')\r\n        return new JsonValue(parseString(din, type));\r\n    else if (type == 'a' || type == 'A')\r\n        return parseData(din, type);\r\n    else if (type == 'C')\r\n        return new JsonValue(din.readChar());\r\n    else\r\n        throw new GdxRuntimeException(\"Unrecognized data type\");\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.utils.AnimationController.animate",
	"Comment": "changes the current animation by blending the new on top of the old during the transition time.",
	"Method": "AnimationDesc animate(String id,float transitionTime,AnimationDesc animate,String id,AnimationListener listener,float transitionTime,AnimationDesc animate,String id,int loopCount,AnimationListener listener,float transitionTime,AnimationDesc animate,String id,int loopCount,float speed,AnimationListener listener,float transitionTime,AnimationDesc animate,String id,float offset,float duration,int loopCount,float speed,AnimationListener listener,float transitionTime,AnimationDesc animate,Animation anim,float offset,float duration,int loopCount,float speed,AnimationListener listener,float transitionTime,AnimationDesc animate,AnimationDesc anim,float transitionTime){\r\n    if (current == null)\r\n        current = anim;\r\n    else if (inAction)\r\n        queue(anim, transitionTime);\r\n    else if (!allowSameAnimation && anim != null && current.animation == anim.animation) {\r\n        anim.time = current.time;\r\n        animationPool.free(current);\r\n        current = anim;\r\n    } else {\r\n        if (previous != null) {\r\n            removeAnimation(previous.animation);\r\n            animationPool.free(previous);\r\n        }\r\n        previous = current;\r\n        current = anim;\r\n        transitionCurrentTime = 0f;\r\n        transitionTargetTime = transitionTime;\r\n    }\r\n    return anim;\r\n}"
}, {
	"Path": "com.sun.jna.PointerType.equals",
	"Comment": "instances of pointertype with identical pointers compareequal by default.",
	"Method": "boolean equals(Object o){\r\n    if (o == this) {\r\n        return true;\r\n    }\r\n    if (o instanceof PointerType) {\r\n        Pointer p = ((PointerType) o).getPointer();\r\n        if (pointer == null) {\r\n            return p == null;\r\n        }\r\n        return pointer.equals(p);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.lerp",
	"Comment": "linearly interpolates between fromvalue to tovalue on progress position.",
	"Method": "float lerp(float fromValue,float toValue,float progress){\r\n    return fromValue + (toValue - fromValue) * progress;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.getPaddingRight",
	"Comment": "returns the padding to the right of a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "int getPaddingRight(){\r\n    return paddingRight;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.GwtFileHandle.deleteDirectory",
	"Comment": "deletes this file or directory and all children, recursively.",
	"Method": "boolean deleteDirectory(){\r\n    throw new GdxRuntimeException(\"Cannot delete an internal file: \" + file);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.setDestructionListener",
	"Comment": "register a destruction listener. the listener is owned by you and must remain in scope.",
	"Method": "void setDestructionListener(DestructionListener listener){\r\n    m_destructionListener = listener;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.GlyphLayout.adjustLastGlyph",
	"Comment": "adjusts the xadvance of the last glyph to use its width instead of xadvance.",
	"Method": "void adjustLastGlyph(BitmapFontData fontData,GlyphRun run){\r\n    Glyph last = run.glyphs.peek();\r\n    if (last.fixedWidth)\r\n        return;\r\n    float width = (last.width + last.xoffset) * fontData.scaleX - fontData.padRight;\r\n    run.width += width - run.xAdvances.peek();\r\n    run.xAdvances.set(run.xAdvances.size - 1, width);\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.Kernel32Util.getFileAttributes",
	"Comment": "retrieves file system attributes for a specified file or directory.",
	"Method": "int getFileAttributes(String fileName){\r\n    int fileAttributes = Kernel32.INSTANCE.GetFileAttributes(fileName);\r\n    if (fileAttributes == WinBase.INVALID_FILE_ATTRIBUTES) {\r\n        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n    }\r\n    return fileAttributes;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.Constructor.getParameterTypes",
	"Comment": "returns an array of class objects that represent the formal parameter types, in declaration order, of the constructor.",
	"Method": "Class[] getParameterTypes(){\r\n    return constructor.getParameterTypes();\r\n}"
}, {
	"Path": "java.nio.IntBuffer.toString",
	"Comment": "returns a string represents of the state of this int buffer.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(getClass().getName());\r\n    sb.append(\", status: capacity=\");\r\n    sb.append(capacity());\r\n    sb.append(\" position=\");\r\n    sb.append(position());\r\n    sb.append(\" limit=\");\r\n    sb.append(limit());\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.rey.material.widget.ListPopupWindow.setHorizontalOffset",
	"Comment": "set the horizontal offset of this popup from its anchor view in pixels.",
	"Method": "void setHorizontalOffset(int offset){\r\n    mDropDownHorizontalOffset = offset;\r\n}"
}, {
	"Path": "com.sun.jna.Native.loadLibraryInstance",
	"Comment": "attempts to force initialization of an instance of the library interfaceby loading a public static field of the requisite type.returns whether an instance variable was instantiated.expects that lock on libraries is already held",
	"Method": "void loadLibraryInstance(Class<?> cls){\r\n    if (cls != null && !libraries.containsKey(cls)) {\r\n        try {\r\n            Field[] fields = cls.getFields();\r\n            for (int i = 0; i < fields.length; i++) {\r\n                Field field = fields[i];\r\n                if (field.getType() == cls && Modifier.isStatic(field.getModifiers())) {\r\n                    libraries.put(cls, new WeakReference<Object>(field.get(null)));\r\n                    break;\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            throw new IllegalArgumentException(\"Could not access instance of \" + cls + \" (\" + e + \")\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.getElementsByAttributeValueEnding",
	"Comment": "find elements that have attributes that end with the value suffix. case insensitive.",
	"Method": "Elements getElementsByAttributeValueEnding(String key,String valueSuffix){\r\n    return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectFloatMap.containsValue",
	"Comment": "returns true if the specified value is in the map. note this traverses the entire map and compares every value, which may be\tan expensive operation.",
	"Method": "boolean containsValue(float value){\r\n    K[] keyTable = this.keyTable;\r\n    float[] valueTable = this.valueTable;\r\n    for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != null && valueTable[i] == value)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.BitmapFontCache.translate",
	"Comment": "sets the position of the text, relative to its current position.",
	"Method": "void translate(float xAmount,float yAmount){\r\n    if (xAmount == 0 && yAmount == 0)\r\n        return;\r\n    if (integer) {\r\n        xAmount = Math.round(xAmount);\r\n        yAmount = Math.round(yAmount);\r\n    }\r\n    x += xAmount;\r\n    y += yAmount;\r\n    float[][] pageVertices = this.pageVertices;\r\n    for (int i = 0, n = pageVertices.length; i < n; i++) {\r\n        float[] vertices = pageVertices[i];\r\n        for (int ii = 0, nn = idx[i]; ii < nn; ii += 5) {\r\n            vertices[ii] += xAmount;\r\n            vertices[ii + 1] += yAmount;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Matrix4.setToTranslationAndScaling",
	"Comment": "sets this matrix to a translation and scaling matrix by first overwriting it with an identity and then setting the\ttranslation vector in the 4th column and the scaling vector in the diagonal.",
	"Method": "Matrix4 setToTranslationAndScaling(Vector3 translation,Vector3 scaling,Matrix4 setToTranslationAndScaling,float translationX,float translationY,float translationZ,float scalingX,float scalingY,float scalingZ){\r\n    idt();\r\n    val[M03] = translationX;\r\n    val[M13] = translationY;\r\n    val[M23] = translationZ;\r\n    val[M00] = scalingX;\r\n    val[M11] = scalingY;\r\n    val[M22] = scalingZ;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.BooleanArray.removeRange",
	"Comment": "removes the items between the specified indices, inclusive.",
	"Method": "void removeRange(int start,int end){\r\n    if (end >= size)\r\n        throw new IndexOutOfBoundsException(\"end can't be >= size: \" + end + \" >= \" + size);\r\n    if (start > end)\r\n        throw new IndexOutOfBoundsException(\"start can't be > end: \" + start + \" > \" + end);\r\n    boolean[] items = this.items;\r\n    int count = end - start + 1;\r\n    if (ordered)\r\n        System.arraycopy(items, start + count, items, start, size - (start + count));\r\n    else {\r\n        int lastIndex = this.size - 1;\r\n        for (int i = 0; i < count; i++) items[start + i] = items[lastIndex - i];\r\n    }\r\n    size -= count;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.viewport.Viewport.unproject",
	"Comment": "transforms the specified screen coordinate to world coordinates.",
	"Method": "Vector2 unproject(Vector2 screenCoords,Vector3 unproject,Vector3 screenCoords){\r\n    camera.unproject(screenCoords, screenX, screenY, screenWidth, screenHeight);\r\n    return screenCoords;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ShortArray.removeRange",
	"Comment": "removes the items between the specified indices, inclusive.",
	"Method": "void removeRange(int start,int end){\r\n    if (end >= size)\r\n        throw new IndexOutOfBoundsException(\"end can't be >= size: \" + end + \" >= \" + size);\r\n    if (start > end)\r\n        throw new IndexOutOfBoundsException(\"start can't be > end: \" + start + \" > \" + end);\r\n    short[] items = this.items;\r\n    int count = end - start + 1;\r\n    if (ordered)\r\n        System.arraycopy(items, start + count, items, start, size - (start + count));\r\n    else {\r\n        int lastIndex = this.size - 1;\r\n        for (int i = 0; i < count; i++) items[start + i] = items[lastIndex - i];\r\n    }\r\n    size -= count;\r\n}"
}, {
	"Path": "com.sun.jna.Structure.getAutoWrite",
	"Comment": "returns whether the structure is written to native memory prior to a nativefunction call.",
	"Method": "boolean getAutoWrite(){\r\n    return this.autoWrite;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Array.truncate",
	"Comment": "reduces the size of the array to the specified size. if the array is already smaller than the specified size, no action is",
	"Method": "void truncate(int newSize){\r\n    if (newSize < 0)\r\n        throw new IllegalArgumentException(\"newSize must be >= 0: \" + newSize);\r\n    if (size <= newSize)\r\n        return;\r\n    for (int i = newSize; i < size; i++) items[i] = null;\r\n    size = newSize;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.AccountHeader.setSelectionFirstLine",
	"Comment": "set this to define the first line in the selection area if there is no profilenote this will block any values from profiles!",
	"Method": "void setSelectionFirstLine(String selectionFirstLine){\r\n    mAccountHeaderBuilder.mSelectionFirstLine = selectionFirstLine;\r\n    mAccountHeaderBuilder.updateHeaderAndList();\r\n}"
}, {
	"Path": "org.jsoup.select.Elements.is",
	"Comment": "test if any of the matched elements match the supplied query.",
	"Method": "boolean is(String query){\r\n    Evaluator eval = QueryParser.parse(query);\r\n    for (Element e : this) {\r\n        if (e.is(eval))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.assets.AssetManager.taskFailed",
	"Comment": "called when a task throws an exception during loading. the default implementation rethrows the exception. a subclass may\tsupress the default implementation when loading assets where loading failure is recoverable.",
	"Method": "void taskFailed(AssetDescriptor assetDesc,RuntimeException ex){\r\n    throw ex;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.actions.Actions.alpha",
	"Comment": "transitions from the alpha at the time this action starts to the specified alpha.",
	"Method": "AlphaAction alpha(float a,AlphaAction alpha,float a,float duration,AlphaAction alpha,float a,float duration,Interpolation interpolation){\r\n    AlphaAction action = action(AlphaAction.class);\r\n    action.setAlpha(a);\r\n    action.setDuration(duration);\r\n    action.setInterpolation(interpolation);\r\n    return action;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Json.copyFields",
	"Comment": "each field on the to object is set to the value for the field with the same name on the from\tobject. the to object must have at least all the fields of the from object with the same name and",
	"Method": "void copyFields(Object from,Object to){\r\n    ObjectMap<String, FieldMetadata> toFields = getFields(from.getClass());\r\n    for (ObjectMap.Entry<String, FieldMetadata> entry : getFields(from.getClass())) {\r\n        FieldMetadata toField = toFields.get(entry.key);\r\n        Field fromField = entry.value.field;\r\n        if (toField == null)\r\n            throw new SerializationException(\"To object is missing field\" + entry.key);\r\n        try {\r\n            toField.field.set(to, fromField.get(from));\r\n        } catch (ReflectionException ex) {\r\n            throw new SerializationException(\"Error copying field: \" + fromField.getName(), ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.controllers.Controllers.getListeners",
	"Comment": "returns all listeners currently registered. modifying this array will result in undefined behaviour.",
	"Method": "Array<ControllerListener> getListeners(){\r\n    initialize();\r\n    return getManager().getListeners();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.Field.getType",
	"Comment": "returns a class object that identifies the declared type for the field.",
	"Method": "Class getType(){\r\n    return field.getType();\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.getWorldVector",
	"Comment": "get the world coordinates of a vector given the local coordinates.",
	"Method": "Vec2 getWorldVector(Vec2 localVector){\r\n    Vec2 out = new Vec2();\r\n    getWorldVectorToOut(localVector, out);\r\n    return out;\r\n}"
}, {
	"Path": "org.jbox2d.callbacks.DebugDraw.getScreenToWorld",
	"Comment": "takes the screen coordinates and returns the world coordinates.",
	"Method": "Vec2 getScreenToWorld(Vec2 argScreen,Vec2 getScreenToWorld,float screenX,float screenY){\r\n    Vec2 screen = new Vec2(screenX, screenY);\r\n    viewportTransform.getScreenToWorld(screen, screen);\r\n    return screen;\r\n}"
}, {
	"Path": "lombok.core.AST.buildWithField",
	"Comment": "buildtree implementation that uses reflection to find all child nodes by way of inspecting\tthe fields.",
	"Method": "Collection<L> buildWithField(Class<L> nodeType,N statement,FieldAccess fa){\r\n    List<L> list = new ArrayList<L>();\r\n    buildWithField0(nodeType, statement, fa, list);\r\n    return list;\r\n}"
}, {
	"Path": "java.nio.CharBuffer.put",
	"Comment": "writes chars of the given string to the current position of this buffer, and increases the position by the number of chars\twritten.",
	"Method": "CharBuffer put(char c,CharBuffer put,char[] src,CharBuffer put,char[] src,int off,int len,CharBuffer put,CharBuffer src,CharBuffer put,int index,char c,CharBuffer put,String str,CharBuffer put,String str,int start,int end){\r\n    int length = str.length();\r\n    if (start < 0 || end < start || end > length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (end - start > remaining()) {\r\n        throw new BufferOverflowException();\r\n    }\r\n    for (int i = start; i < end; i++) {\r\n        put(str.charAt(i));\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jna.Native.extractFromResourcePath",
	"Comment": "attempt to extract a native library from the resource path using thegiven class loader.",
	"Method": "File extractFromResourcePath(String name,File extractFromResourcePath,String name,ClassLoader loader){\r\n    final Level DEBUG = (DEBUG_LOAD || (DEBUG_JNA_LOAD && name.contains(\"jnidispatch\"))) ? Level.INFO : Level.FINE;\r\n    if (loader == null) {\r\n        loader = Thread.currentThread().getContextClassLoader();\r\n        if (loader == null) {\r\n            loader = Native.class.getClassLoader();\r\n        }\r\n    }\r\n    LOG.log(DEBUG, \"Looking in classpath from {0} for {1}\", new Object[] { loader, name });\r\n    String libname = name.startsWith(\"/\") ? name : NativeLibrary.mapSharedLibraryName(name);\r\n    String resourcePath = name.startsWith(\"/\") ? name : Platform.RESOURCE_PREFIX + \"/\" + libname;\r\n    if (resourcePath.startsWith(\"/\")) {\r\n        resourcePath = resourcePath.substring(1);\r\n    }\r\n    URL url = loader.getResource(resourcePath);\r\n    if (url == null && resourcePath.startsWith(Platform.RESOURCE_PREFIX)) {\r\n        url = loader.getResource(libname);\r\n    }\r\n    if (url == null) {\r\n        String path = System.getProperty(\"java.class.path\");\r\n        if (loader instanceof URLClassLoader) {\r\n            path = Arrays.asList(((URLClassLoader) loader).getURLs()).toString();\r\n        }\r\n        throw new IOException(\"Native library (\" + resourcePath + \") not found in resource path (\" + path + \")\");\r\n    }\r\n    LOG.log(DEBUG, \"Found library resource at {0}\", url);\r\n    File lib = null;\r\n    if (url.getProtocol().toLowerCase().equals(\"file\")) {\r\n        try {\r\n            lib = new File(new URI(url.toString()));\r\n        } catch (URISyntaxException e) {\r\n            lib = new File(url.getPath());\r\n        }\r\n        LOG.log(DEBUG, \"Looking in {0}\", lib.getAbsolutePath());\r\n        if (!lib.exists()) {\r\n            throw new IOException(\"File URL \" + url + \" could not be properly decoded\");\r\n        }\r\n    } else if (!Boolean.getBoolean(\"jna.nounpack\")) {\r\n        InputStream is = loader.getResourceAsStream(resourcePath);\r\n        if (is == null) {\r\n            throw new IOException(\"Can't obtain InputStream for \" + resourcePath);\r\n        }\r\n        FileOutputStream fos = null;\r\n        try {\r\n            File dir = getTempDir();\r\n            lib = File.createTempFile(JNA_TMPLIB_PREFIX, Platform.isWindows() ? \".dll\" : null, dir);\r\n            if (!Boolean.getBoolean(\"jnidispatch.preserve\")) {\r\n                lib.deleteOnExit();\r\n            }\r\n            LOG.log(DEBUG, \"Extracting library to {0}\", lib.getAbsolutePath());\r\n            fos = new FileOutputStream(lib);\r\n            int count;\r\n            byte[] buf = new byte[1024];\r\n            while ((count = is.read(buf, 0, buf.length)) > 0) {\r\n                fos.write(buf, 0, count);\r\n            }\r\n        } catch (IOException e) {\r\n            throw new IOException(\"Failed to create temporary file for \" + name + \" library: \" + e.getMessage());\r\n        } finally {\r\n            try {\r\n                is.close();\r\n            } catch (IOException e) {\r\n            }\r\n            if (fos != null) {\r\n                try {\r\n                    fos.close();\r\n                } catch (IOException e) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return lib;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getCompoundPaddingLeft",
	"Comment": "returns the left padding of the view, plus space for the leftdrawable if any.",
	"Method": "int getCompoundPaddingLeft(){\r\n    return mInputView.getCompoundPaddingLeft();\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.DelaunayTriangulator.computeTriangles",
	"Comment": "triangulates the given point cloud to a list of triangle indices that make up the delaunay triangulation.",
	"Method": "ShortArray computeTriangles(FloatArray points,boolean sorted,ShortArray computeTriangles,float[] polygon,boolean sorted,ShortArray computeTriangles,float[] points,int offset,int count,boolean sorted){\r\n    ShortArray triangles = this.triangles;\r\n    triangles.clear();\r\n    if (count < 6)\r\n        return triangles;\r\n    triangles.ensureCapacity(count);\r\n    if (!sorted) {\r\n        if (sortedPoints == null || sortedPoints.length < count)\r\n            sortedPoints = new float[count];\r\n        System.arraycopy(points, offset, sortedPoints, 0, count);\r\n        points = sortedPoints;\r\n        offset = 0;\r\n        sort(points, count);\r\n    }\r\n    int end = offset + count;\r\n    float xmin = points[0], ymin = points[1];\r\n    float xmax = xmin, ymax = ymin;\r\n    for (int i = offset + 2; i < end; i++) {\r\n        float value = points[i];\r\n        if (value < xmin)\r\n            xmin = value;\r\n        if (value > xmax)\r\n            xmax = value;\r\n        i++;\r\n        value = points[i];\r\n        if (value < ymin)\r\n            ymin = value;\r\n        if (value > ymax)\r\n            ymax = value;\r\n    }\r\n    float dx = xmax - xmin, dy = ymax - ymin;\r\n    float dmax = (dx > dy ? dx : dy) * 20f;\r\n    float xmid = (xmax + xmin) / 2f, ymid = (ymax + ymin) / 2f;\r\n    float[] superTriangle = this.superTriangle;\r\n    superTriangle[0] = xmid - dmax;\r\n    superTriangle[1] = ymid - dmax;\r\n    superTriangle[2] = xmid;\r\n    superTriangle[3] = ymid + dmax;\r\n    superTriangle[4] = xmid + dmax;\r\n    superTriangle[5] = ymid - dmax;\r\n    IntArray edges = this.edges;\r\n    edges.ensureCapacity(count / 2);\r\n    BooleanArray complete = this.complete;\r\n    complete.clear();\r\n    complete.ensureCapacity(count);\r\n    triangles.add(end);\r\n    triangles.add(end + 2);\r\n    triangles.add(end + 4);\r\n    complete.add(false);\r\n    for (int pointIndex = offset; pointIndex < end; pointIndex += 2) {\r\n        float x = points[pointIndex], y = points[pointIndex + 1];\r\n        short[] trianglesArray = triangles.items;\r\n        boolean[] completeArray = complete.items;\r\n        for (int triangleIndex = triangles.size - 1; triangleIndex >= 0; triangleIndex -= 3) {\r\n            int completeIndex = triangleIndex / 3;\r\n            if (completeArray[completeIndex])\r\n                continue;\r\n            int p1 = trianglesArray[triangleIndex - 2];\r\n            int p2 = trianglesArray[triangleIndex - 1];\r\n            int p3 = trianglesArray[triangleIndex];\r\n            float x1, y1, x2, y2, x3, y3;\r\n            if (p1 >= end) {\r\n                int i = p1 - end;\r\n                x1 = superTriangle[i];\r\n                y1 = superTriangle[i + 1];\r\n            } else {\r\n                x1 = points[p1];\r\n                y1 = points[p1 + 1];\r\n            }\r\n            if (p2 >= end) {\r\n                int i = p2 - end;\r\n                x2 = superTriangle[i];\r\n                y2 = superTriangle[i + 1];\r\n            } else {\r\n                x2 = points[p2];\r\n                y2 = points[p2 + 1];\r\n            }\r\n            if (p3 >= end) {\r\n                int i = p3 - end;\r\n                x3 = superTriangle[i];\r\n                y3 = superTriangle[i + 1];\r\n            } else {\r\n                x3 = points[p3];\r\n                y3 = points[p3 + 1];\r\n            }\r\n            switch(circumCircle(x, y, x1, y1, x2, y2, x3, y3)) {\r\n                case COMPLETE:\r\n                    completeArray[completeIndex] = true;\r\n                    break;\r\n                case INSIDE:\r\n                    edges.add(p1);\r\n                    edges.add(p2);\r\n                    edges.add(p2);\r\n                    edges.add(p3);\r\n                    edges.add(p3);\r\n                    edges.add(p1);\r\n                    triangles.removeIndex(triangleIndex);\r\n                    triangles.removeIndex(triangleIndex - 1);\r\n                    triangles.removeIndex(triangleIndex - 2);\r\n                    complete.removeIndex(completeIndex);\r\n                    break;\r\n            }\r\n        }\r\n        int[] edgesArray = edges.items;\r\n        for (int i = 0, n = edges.size; i < n; i += 2) {\r\n            int p1 = edgesArray[i];\r\n            if (p1 == -1)\r\n                continue;\r\n            int p2 = edgesArray[i + 1];\r\n            boolean skip = false;\r\n            for (int ii = i + 2; ii < n; ii += 2) {\r\n                if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\r\n                    skip = true;\r\n                    edgesArray[ii] = -1;\r\n                }\r\n            }\r\n            if (skip)\r\n                continue;\r\n            triangles.add(p1);\r\n            triangles.add(edgesArray[i + 1]);\r\n            triangles.add(pointIndex);\r\n            complete.add(false);\r\n        }\r\n        edges.clear();\r\n    }\r\n    short[] trianglesArray = triangles.items;\r\n    for (int i = triangles.size - 1; i >= 0; i -= 3) {\r\n        if (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\r\n            triangles.removeIndex(i);\r\n            triangles.removeIndex(i - 1);\r\n            triangles.removeIndex(i - 2);\r\n        }\r\n    }\r\n    if (!sorted) {\r\n        short[] originalIndicesArray = originalIndices.items;\r\n        for (int i = 0, n = triangles.size; i < n; i++) trianglesArray[i] = (short) (originalIndicesArray[trianglesArray[i] / 2] * 2);\r\n    }\r\n    if (offset == 0) {\r\n        for (int i = 0, n = triangles.size; i < n; i++) trianglesArray[i] = (short) (trianglesArray[i] / 2);\r\n    } else {\r\n        for (int i = 0, n = triangles.size; i < n; i++) trianglesArray[i] = (short) ((trianglesArray[i] - offset) / 2);\r\n    }\r\n    return triangles;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Group.addActorAfter",
	"Comment": "adds an actor as a child of this group immediately after another child actor, removing it from its previous parent. if the\tactor is already a child of this group, no changes are made.",
	"Method": "void addActorAfter(Actor actorAfter,Actor actor){\r\n    if (actor.parent != null) {\r\n        if (actor.parent == this)\r\n            return;\r\n        actor.parent.removeActor(actor, false);\r\n    }\r\n    int index = children.indexOf(actorAfter, true);\r\n    if (index == children.size)\r\n        children.add(actor);\r\n    else\r\n        children.insert(index + 1, actor);\r\n    actor.setParent(this);\r\n    actor.setStage(getStage());\r\n    childrenChanged();\r\n}"
}, {
	"Path": "com.badlogic.gdx.jnigen.FileDescriptor.writer",
	"Comment": "returns a writer for writing to this file. parent directories will be created if necessary.",
	"Method": "Writer writer(boolean append,Writer writer,boolean append,String charset){\r\n    if (type == FileType.Classpath)\r\n        throw new RuntimeException(\"Cannot write to a classpath file: \" + file);\r\n    parent().mkdirs();\r\n    try {\r\n        FileOutputStream output = new FileOutputStream(file(), append);\r\n        if (charset == null)\r\n            return new OutputStreamWriter(output);\r\n        else\r\n            return new OutputStreamWriter(output, charset);\r\n    } catch (IOException ex) {\r\n        if (file().isDirectory())\r\n            throw new RuntimeException(\"Cannot open a stream to a directory: \" + file + \" (\" + type + \")\", ex);\r\n        throw new RuntimeException(\"Error writing file: \" + file + \" (\" + type + \")\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.asShortArray",
	"Comment": "returns the children of this value as a newly allocated short array.",
	"Method": "short[] asShortArray(){\r\n    if (type != ValueType.array)\r\n        throw new IllegalStateException(\"Value is not an array: \" + type);\r\n    short[] array = new short[size];\r\n    int i = 0;\r\n    for (JsonValue value = child; value != null; value = value.next, i++) {\r\n        short v;\r\n        switch(value.type) {\r\n            case stringValue:\r\n                v = Short.parseShort(value.stringValue);\r\n                break;\r\n            case doubleValue:\r\n                v = (short) value.doubleValue;\r\n                break;\r\n            case longValue:\r\n                v = (short) value.longValue;\r\n                break;\r\n            case booleanValue:\r\n                v = value.longValue != 0 ? (short) 1 : 0;\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Value cannot be converted to short: \" + value.type);\r\n        }\r\n        array[i] = v;\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.MotorJoint.getLinearOffset",
	"Comment": "get the target linear offset, in frame a, in meters. do not modify.",
	"Method": "void getLinearOffset(Vec2 out,Vec2 getLinearOffset){\r\n    return m_linearOffset;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.setAutoClearForces",
	"Comment": "set flag to control automatic clearing of forces after each time step.",
	"Method": "void setAutoClearForces(boolean flag){\r\n    if (flag) {\r\n        m_flags |= CLEAR_FORCES;\r\n    } else {\r\n        m_flags &= ~CLEAR_FORCES;\r\n    }\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.setTextScaleX",
	"Comment": "sets the extent by which text should be stretched horizontally.",
	"Method": "void setTextScaleX(float size){\r\n    mInputView.setTextScaleX(size);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO.invalidate",
	"Comment": "invalidates the vertexbufferobject so a new opengl buffer handle is created. use this in case of a context loss.",
	"Method": "void invalidate(){\r\n    bufferHandle = Gdx.gl30.glGenBuffer();\r\n    createVAO();\r\n    isDirty = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.IndexBufferObject.dispose",
	"Comment": "disposes this indexbufferobject and all its associated opengl resources.",
	"Method": "void dispose(){\r\n    Gdx.gl20.glBindBuffer(GL20.GL_ELEMENT_ARRAY_BUFFER, 0);\r\n    Gdx.gl20.glDeleteBuffer(bufferHandle);\r\n    bufferHandle = 0;\r\n    BufferUtils.disposeUnsafeByteBuffer(byteBuffer);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withActivity",
	"Comment": "sets the activity which will be generated for the generationthe activity is required and will be used to inflate the content in.after generation it is set to null to prevent a memory leak.",
	"Method": "DrawerBuilder withActivity(Activity activity){\r\n    this.mRootView = (ViewGroup) activity.findViewById(android.R.id.content);\r\n    this.mActivity = activity;\r\n    this.mLayoutManager = new LinearLayoutManager(mActivity);\r\n    return this;\r\n}"
}, {
	"Path": "com.codahale.metrics.Snapshot.get98thPercentile",
	"Comment": "returns the value at the 98th percentile in the distribution.",
	"Method": "double get98thPercentile(){\r\n    return getValue(0.98);\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getShowSoftInputOnFocus",
	"Comment": "returns whether the soft input method will be made visible when thistextview gets focused. the default is true.",
	"Method": "boolean getShowSoftInputOnFocus(){\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\r\n        return mInputView.getShowSoftInputOnFocus();\r\n    return true;\r\n}"
}, {
	"Path": "com.rey.material.app.ToolbarManager.notifyNavigationStateChanged",
	"Comment": "notify the current state of navigation icon is invalid. it should update the state immediately without showing animation.",
	"Method": "void notifyNavigationStateChanged(){\r\n    if (mNavigationManager != null)\r\n        mNavigationManager.notifyStateChanged();\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.setPosition",
	"Comment": "the world position of the body. avoid creating bodies at the origin since this can lead to manyoverlapping shapes.",
	"Method": "void setPosition(Vec2 position){\r\n    this.position = position;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18.onAttachedToWindow",
	"Comment": "this method is used as part of the view class and is not normallycalled or subclassed by clients of glsurfaceview.",
	"Method": "void onAttachedToWindow(){\r\n    super.onAttachedToWindow();\r\n    if (LOG_ATTACH_DETACH) {\r\n        Log.d(TAG, \"onAttachedToWindow reattach =\" + mDetached);\r\n    }\r\n    if (mDetached && (mRenderer != null)) {\r\n        int renderMode = RENDERMODE_CONTINUOUSLY;\r\n        if (mGLThread != null) {\r\n            renderMode = mGLThread.getRenderMode();\r\n        }\r\n        mGLThread = new GLThread(mThisWeakRef);\r\n        if (renderMode != RENDERMODE_CONTINUOUSLY) {\r\n            mGLThread.setRenderMode(renderMode);\r\n        }\r\n        mGLThread.start();\r\n    }\r\n    mDetached = false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.collision.btBroadphaseProxy.obtain",
	"Comment": "reuses a previous freed instance or creates a new instance and set it to reflect the specified native object",
	"Method": "btBroadphaseProxy obtain(long cPtr,boolean own){\r\n    final btBroadphaseProxy result = pool.obtain();\r\n    result.reset(cPtr, own);\r\n    return result;\r\n}"
}, {
	"Path": "lombok.core.AST.replaceStatementInNode",
	"Comment": "uses reflection to find the given direct child on the given statement, and replace it with a new child.",
	"Method": "boolean replaceStatementInNode(N statement,N oldN,N newN){\r\n    for (FieldAccess fa : fieldsOf(statement.getClass())) {\r\n        if (replaceStatementInField(fa, statement, oldN, newN))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleController.bind",
	"Comment": "bind the sub systems to the controller called once during the init phase.",
	"Method": "void bind(){\r\n    emitter.set(this);\r\n    for (Influencer influencer : influencers) influencer.set(this);\r\n    renderer.set(this);\r\n}"
}, {
	"Path": "java.nio.ByteBuffer.arrayOffset",
	"Comment": "returns the offset of the byte array which this buffer is based on, if there is one.\tthe offset is the index of the array which corresponds to the zero position of the buffer.",
	"Method": "int arrayOffset(){\r\n    return protectedArrayOffset();\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Fixture.setUserData",
	"Comment": "set the user data. use this to store your application specific data.",
	"Method": "void setUserData(Object data){\r\n    m_userData = data;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup.pad",
	"Comment": "sets the padtop, padleft, padbottom, and padright to the specified value.",
	"Method": "HorizontalGroup pad(float pad,HorizontalGroup pad,float top,float left,float bottom,float right){\r\n    padTop = top;\r\n    padLeft = left;\r\n    padBottom = bottom;\r\n    padRight = right;\r\n    return this;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.AccountHeaderBuilder.withThreeSmallProfileImages",
	"Comment": "enable the extended profile icon view with 3 small header images instead of two",
	"Method": "AccountHeaderBuilder withThreeSmallProfileImages(boolean threeSmallProfileImages){\r\n    this.mThreeSmallProfileImages = threeSmallProfileImages;\r\n    return this;\r\n}"
}, {
	"Path": "org.junit.experimental.max.MaxCore.forFolder",
	"Comment": "create a new maxcore from a serialized file stored at storedresults",
	"Method": "MaxCore forFolder(String folderName){\r\n    return storedLocally(new File(folderName));\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.SerializationException.causedBy",
	"Comment": "returns true if any of the exceptions that caused this exception are of the specified type.",
	"Method": "boolean causedBy(Class type,boolean causedBy,Throwable ex,Class type){\r\n    Throwable cause = ex.getCause();\r\n    if (cause == null || cause == ex)\r\n        return false;\r\n    if (type.isAssignableFrom(cause.getClass()))\r\n        return true;\r\n    return causedBy(cause, type);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.setAngularDamping",
	"Comment": "angular damping is use to reduce the angular velocity. the damping parameter can be larger than1.0f but the damping effect becomes sensitive to the time step when the damping parameter islarge.",
	"Method": "void setAngularDamping(float angularDamping){\r\n    this.angularDamping = angularDamping;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Attribute.isBooleanAttribute",
	"Comment": "checks if this attribute name is defined as a boolean attribute in html5",
	"Method": "boolean isBooleanAttribute(boolean isBooleanAttribute,String key){\r\n    return Arrays.binarySearch(booleanAttributes, key) >= 0;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Cell.space",
	"Comment": "sets the spacetop, spaceleft, spacebottom, and spaceright to the specified value.",
	"Method": "Cell<T> space(Value space,Cell<T> space,Value top,Value left,Value bottom,Value right,Cell<T> space,float space,Cell<T> space,float top,float left,float bottom,float right){\r\n    if (top < 0)\r\n        throw new IllegalArgumentException(\"top cannot be < 0.\");\r\n    if (left < 0)\r\n        throw new IllegalArgumentException(\"left cannot be < 0.\");\r\n    if (bottom < 0)\r\n        throw new IllegalArgumentException(\"bottom cannot be < 0.\");\r\n    if (right < 0)\r\n        throw new IllegalArgumentException(\"right cannot be < 0.\");\r\n    space(new Fixed(top), new Fixed(left), new Fixed(bottom), new Fixed(right));\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.getWorldPoint",
	"Comment": "get the world coordinates of a point given the local coordinates.",
	"Method": "Vector2 getWorldPoint(Vector2 localPoint){\r\n    tmp.set(localPoint.x, localPoint.y);\r\n    Vec2 wp = body.getWorldPoint(tmp);\r\n    return worldPoint.set(wp.x, wp.y);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable.tint",
	"Comment": "creates a new drawable that renders the same as this drawable tinted the specified color.",
	"Method": "NinePatchDrawable tint(Color tint){\r\n    NinePatchDrawable drawable = new NinePatchDrawable(this);\r\n    drawable.patch = new NinePatch(drawable.getPatch(), tint);\r\n    return drawable;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.model.BaseDrawerItem.getTextColorStateList",
	"Comment": "helper to get the colorstatelist for the text and remembering it so we do not have to recreate it all the time",
	"Method": "ColorStateList getTextColorStateList(int color,int selectedTextColor){\r\n    if (colorStateList == null || color + selectedTextColor != colorStateList.first) {\r\n        colorStateList = new Pair(color + selectedTextColor, DrawerUIUtils.getTextColorStateList(color, selectedTextColor));\r\n    }\r\n    return colorStateList.second;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.getAngularDamping",
	"Comment": "angular damping is use to reduce the angular velocity. the damping parameter can be larger than1.0f but the damping effect becomes sensitive to the time step when the damping parameter islarge.",
	"Method": "float getAngularDamping(){\r\n    return angularDamping;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectFloatMap.findKey",
	"Comment": "returns the key for the specified value, or null if it is not in the map. note this traverses the entire map and compares\tevery value, which may be an expensive operation.",
	"Method": "K findKey(float value){\r\n    K[] keyTable = this.keyTable;\r\n    float[] valueTable = this.valueTable;\r\n    for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != null && valueTable[i] == value)\r\n        return keyTable[i];\r\n    return null;\r\n}"
}, {
	"Path": "org.jbox2d.common.Mat22.abs",
	"Comment": "return the matrix composed of the absolute values of all elements.",
	"Method": "Mat22 abs(Mat22 abs,Mat22 R){\r\n    return R.abs();\r\n}"
}, {
	"Path": "com.badlogic.gdx.tests.NinePatchTest.newNinePatch",
	"Comment": "make a basic ninepatch with different colors in each of the nine patches",
	"Method": "NinePatch newNinePatch(){\r\n    final int patchSize = 8;\r\n    final int pixmapSize = patchSize * 3;\r\n    TextureRegion tr = newPatchPix(patchSize, pixmapSize);\r\n    return new NinePatch(tr, patchSize, patchSize, patchSize, patchSize);\r\n}"
}, {
	"Path": "java.nio.ShortBuffer.allocate",
	"Comment": "creates a short buffer based on a newly allocated short array.",
	"Method": "ShortBuffer allocate(int capacity){\r\n    if (capacity < 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return BufferFactory.newShortBuffer(capacity);\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.setIncludeFontPadding",
	"Comment": "set whether the textview includes extra top and bottom padding to makeroom for accents that go above the normal ascent and descent.the default is true.",
	"Method": "void setIncludeFontPadding(boolean includepad){\r\n    mInputView.setIncludeFontPadding(includepad);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withHeader",
	"Comment": "add a header to the drawerbuilder listview defined by a resource.",
	"Method": "DrawerBuilder withHeader(View headerView,DrawerBuilder withHeader,int headerViewRes){\r\n    if (mActivity == null) {\r\n        throw new RuntimeException(\"please pass an activity first to use this call\");\r\n    }\r\n    if (headerViewRes != -1) {\r\n        this.mHeaderView = mActivity.getLayoutInflater().inflate(headerViewRes, null, false);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.DistanceJoint.getReactionForce",
	"Comment": "get the reaction force given the inverse time step. unit is n.",
	"Method": "void getReactionForce(float inv_dt,Vec2 argOut){\r\n    argOut.x = m_impulse * m_u.x * inv_dt;\r\n    argOut.y = m_impulse * m_u.y * inv_dt;\r\n}"
}, {
	"Path": "com.rey.material.widget.ListPopupWindow.setAnimationStyle",
	"Comment": "set an animation style to use when the popup window is shown or dismissed.",
	"Method": "void setAnimationStyle(int animationStyle){\r\n    mPopup.setAnimationStyle(animationStyle);\r\n}"
}, {
	"Path": "com.sun.jna.Function.concatenateVarArgs",
	"Comment": "concatenate varargs with normal args to obtain a simple argumentarray.",
	"Method": "Object[] concatenateVarArgs(Object[] inArgs){\r\n    if (inArgs != null && inArgs.length > 0) {\r\n        Object lastArg = inArgs[inArgs.length - 1];\r\n        Class<?> argType = lastArg != null ? lastArg.getClass() : null;\r\n        if (argType != null && argType.isArray()) {\r\n            Object[] varArgs = (Object[]) lastArg;\r\n            for (int i = 0; i < varArgs.length; i++) {\r\n                if (varArgs[i] instanceof Float) {\r\n                    varArgs[i] = (double) (Float) varArgs[i];\r\n                }\r\n            }\r\n            Object[] fullArgs = new Object[inArgs.length + varArgs.length];\r\n            System.arraycopy(inArgs, 0, fullArgs, 0, inArgs.length - 1);\r\n            System.arraycopy(varArgs, 0, fullArgs, inArgs.length - 1, varArgs.length);\r\n            fullArgs[fullArgs.length - 1] = null;\r\n            inArgs = fullArgs;\r\n        }\r\n    }\r\n    return inArgs;\r\n}"
}, {
	"Path": "junit.framework.TestResult.addFailure",
	"Comment": "adds a failure to the list of failures. the passed in exceptioncaused the failure.",
	"Method": "void addFailure(Test test,AssertionFailedError e){\r\n    fFailures.add(new TestFailure(test, e));\r\n    for (TestListener each : cloneListeners()) {\r\n        each.addFailure(test, e);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Polygon.contains",
	"Comment": "returns whether an x, y pair is contained within the polygon.",
	"Method": "boolean contains(float x,float y,boolean contains,Vector2 point){\r\n    return contains(point.x, point.y);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withKeepStickyItemsVisible",
	"Comment": "toggles if the sticky footer should stay visible upon switching to the profile listusing this with stickydraweritems can lead to the selection not being updated correctly. use with care",
	"Method": "DrawerBuilder withKeepStickyItemsVisible(boolean keepStickyItemsVisible){\r\n    this.mKeepStickyItemsVisible = keepStickyItemsVisible;\r\n    return this;\r\n}"
}, {
	"Path": "java.nio.Buffer.rewind",
	"Comment": "rewinds this buffer.\tthe position is set to zero, and the mark is cleared. the content of this buffer is not changed.",
	"Method": "Buffer rewind(){\r\n    position = 0;\r\n    mark = UNSET_MARK;\r\n    return this;\r\n}"
}, {
	"Path": "java.nio.BufferFactory.newLongBuffer",
	"Comment": "returns a new long buffer based on the specified long array.",
	"Method": "LongBuffer newLongBuffer(int capacity,LongBuffer newLongBuffer,long array){\r\n    return new ReadWriteLongArrayBuffer(array);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Vector3.rotateRad",
	"Comment": "rotates this vector by the given angle in radians around the given axis.",
	"Method": "Vector3 rotateRad(float radians,float axisX,float axisY,float axisZ,Vector3 rotateRad,Vector3 axis,float radians){\r\n    tmpMat.setToRotationRad(axis, radians);\r\n    return this.mul(tmpMat);\r\n}"
}, {
	"Path": "com.squareup.leakcanary.FailTestOnLeakRunListener.skipLeakDetectionReason",
	"Comment": "can be overridden to skip leak detection based on the description provided when a testis started. returns null to continue leak detection, or a string describing the reason forskipping otherwise.",
	"Method": "String skipLeakDetectionReason(Description description){\r\n    return null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.applyTorque",
	"Comment": "apply a torque. this affects the angular velocity without affecting the linear velocity of the center of mass. this wakes up\tthe body.",
	"Method": "void applyTorque(float torque,boolean wake){\r\n    body.applyTorque(torque);\r\n}"
}, {
	"Path": "com.sun.jna.Native.load",
	"Comment": "load a library interface from the given shared library, providingthe explicit interface class and a map of options for the library.if no library options are detected the map is interpreted as a mapof java method names to native function names.if name is null, attempts to map onto the current process.native libraries loaded via this method may be found inseveral locations.",
	"Method": "T load(Class<T> interfaceClass,T load,Class<T> interfaceClass,Map<String, ?> options,T load,String name,Class<T> interfaceClass,T load,String name,Class<T> interfaceClass,Map<String, ?> options){\r\n    if (!Library.class.isAssignableFrom(interfaceClass)) {\r\n        throw new IllegalArgumentException(\"Interface (\" + interfaceClass.getSimpleName() + \")\" + \" of library=\" + name + \" does not extend \" + Library.class.getSimpleName());\r\n    }\r\n    Library.Handler handler = new Library.Handler(name, interfaceClass, options);\r\n    ClassLoader loader = interfaceClass.getClassLoader();\r\n    Object proxy = Proxy.newProxyInstance(loader, new Class[] { interfaceClass }, handler);\r\n    cacheOptions(interfaceClass, options, proxy);\r\n    return interfaceClass.cast(proxy);\r\n}"
}, {
	"Path": "java.nio.BufferFactory.newDoubleBuffer",
	"Comment": "returns a new array based double buffer with the specified capacity.",
	"Method": "DoubleBuffer newDoubleBuffer(double array,DoubleBuffer newDoubleBuffer,int capacity){\r\n    return new ReadWriteDoubleArrayBuffer(capacity);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener.isOver",
	"Comment": "returns true if the mouse or touch is over the actor or pressed and within the tap square.",
	"Method": "boolean isOver(Actor actor,float x,float y,boolean isOver){\r\n    return over || pressed;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getEditableText",
	"Comment": "return the text the textview is displaying as an editable object.ifthe text is not editable, null is returned.",
	"Method": "Editable getEditableText(){\r\n    return mInputView.getEditableText();\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.model.Node.extendBoundingBox",
	"Comment": "extends the bounding box with the bounds of this node. this is a potential slow operation, it is advised to cache the\tresult.",
	"Method": "BoundingBox extendBoundingBox(BoundingBox out,BoundingBox extendBoundingBox,BoundingBox out,boolean transform){\r\n    final int partCount = parts.size;\r\n    for (int i = 0; i < partCount; i++) {\r\n        final NodePart part = parts.get(i);\r\n        if (part.enabled) {\r\n            final MeshPart meshPart = part.meshPart;\r\n            if (transform)\r\n                meshPart.mesh.extendBoundingBox(out, meshPart.offset, meshPart.size, globalTransform);\r\n            else\r\n                meshPart.mesh.extendBoundingBox(out, meshPart.offset, meshPart.size);\r\n        }\r\n    }\r\n    final int childCount = children.size;\r\n    for (int i = 0; i < childCount; i++) children.get(i).extendBoundingBox(out);\r\n    return out;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.newInstance",
	"Comment": "creates a new instance of the class represented by the supplied class.",
	"Method": "T newInstance(Class<T> c){\r\n    try {\r\n        return c.newInstance();\r\n    } catch (InstantiationException e) {\r\n        throw new ReflectionException(\"Could not instantiate instance of class: \" + c.getName(), e);\r\n    } catch (IllegalAccessException e) {\r\n        throw new ReflectionException(\"Could not instantiate instance of class: \" + c.getName(), e);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.PooledLinkedList.add",
	"Comment": "adds the specified object to the end of the list regardless of iteration status",
	"Method": "void add(T object){\r\n    Item<T> item = pool.obtain();\r\n    item.payload = object;\r\n    item.next = null;\r\n    item.prev = null;\r\n    if (head == null) {\r\n        head = item;\r\n        tail = item;\r\n        size++;\r\n        return;\r\n    }\r\n    item.prev = tail;\r\n    tail.next = item;\r\n    tail = item;\r\n    size++;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.iosrobovm.IOSApplication.getBounds",
	"Comment": "gl view spans whole screen, that is, even under the status bar. ios can also rotate the screen, which is not handled\tconsistently over ios versions. this method returns, in pixels, rectangle in which libgdx draws.",
	"Method": "CGRect getBounds(){\r\n    final CGRect screenBounds = UIScreen.getMainScreen().getBounds();\r\n    final CGRect statusBarFrame = uiApp.getStatusBarFrame();\r\n    final UIInterfaceOrientation statusBarOrientation = uiApp.getStatusBarOrientation();\r\n    double statusBarHeight = Math.min(statusBarFrame.getWidth(), statusBarFrame.getHeight());\r\n    double screenWidth = screenBounds.getWidth();\r\n    double screenHeight = screenBounds.getHeight();\r\n    switch(statusBarOrientation) {\r\n        case LandscapeLeft:\r\n        case LandscapeRight:\r\n            if (screenHeight > screenWidth) {\r\n                debug(\"IOSApplication\", \"Switching reported width and height (w=\" + screenWidth + \" h=\" + screenHeight + \")\");\r\n                double tmp = screenHeight;\r\n                screenHeight = screenWidth;\r\n                screenWidth = tmp;\r\n            }\r\n    }\r\n    screenWidth *= displayScaleFactor;\r\n    screenHeight *= displayScaleFactor;\r\n    if (statusBarHeight != 0.0) {\r\n        debug(\"IOSApplication\", \"Status bar is visible (height = \" + statusBarHeight + \")\");\r\n        statusBarHeight *= displayScaleFactor;\r\n        screenHeight -= statusBarHeight;\r\n    } else {\r\n        debug(\"IOSApplication\", \"Status bar is not visible\");\r\n    }\r\n    debug(\"IOSApplication\", \"Total computed bounds are w=\" + screenWidth + \" h=\" + screenHeight);\r\n    return lastScreenBounds = new CGRect(0.0, statusBarHeight, screenWidth, screenHeight);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.BitmapFontCache.getX",
	"Comment": "returns the x position of the cached string, relative to the position when the string was cached.",
	"Method": "float getX(){\r\n    return x;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.BitmapFontCache.getY",
	"Comment": "returns the y position of the cached string, relative to the position when the string was cached.",
	"Method": "float getY(){\r\n    return y;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane.setFlingTime",
	"Comment": "for flick scroll, sets the amount of time in seconds that a fling will continue to scroll. default is 1.",
	"Method": "void setFlingTime(float flingTime){\r\n    this.flingTime = flingTime;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getCompoundPaddingEnd",
	"Comment": "returns the end padding of the view, plus space for the enddrawable if any.",
	"Method": "int getCompoundPaddingEnd(){\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1)\r\n        return mInputView.getCompoundPaddingEnd();\r\n    return mInputView.getCompoundPaddingRight();\r\n}"
}, {
	"Path": "org.jbox2d.callbacks.DebugDraw.getWorldToScreen",
	"Comment": "takes the world coordinates and returns the screen coordinates.",
	"Method": "Vec2 getWorldToScreen(Vec2 argWorld,Vec2 getWorldToScreen,float worldX,float worldY){\r\n    Vec2 argScreen = new Vec2(worldX, worldY);\r\n    viewportTransform.getWorldToScreen(argScreen, argScreen);\r\n    return argScreen;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.getInertia",
	"Comment": "get the rotational inertia of the body about the local origin.",
	"Method": "float getInertia(){\r\n    return body.getInertia();\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.model.AbstractDrawerItem.isAutoExpanding",
	"Comment": "overwrite this method and return true if the item should auto expand on click, false if you want to disable this",
	"Method": "boolean isAutoExpanding(){\r\n    return true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ShortArray.setSize",
	"Comment": "sets the array size, leaving any values beyond the current size undefined.",
	"Method": "short[] setSize(int newSize){\r\n    if (newSize < 0)\r\n        throw new IllegalArgumentException(\"newSize must be >= 0: \" + newSize);\r\n    if (newSize > items.length)\r\n        resize(Math.max(8, newSize));\r\n    size = newSize;\r\n    return items;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Pixmap.fillCircle",
	"Comment": "fills a circle with the center at x,y and a radius using the current color.",
	"Method": "void fillCircle(int x,int y,int radius){\r\n    pixmap.fillCircle(x, y, radius, color);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.GLVersion.isVersionEqualToOrHigher",
	"Comment": "checks to see if the current gl connection version is higher, or equal to the provided test versions.",
	"Method": "boolean isVersionEqualToOrHigher(int testMajorVersion,int testMinorVersion){\r\n    return majorVersion > testMajorVersion || (majorVersion == testMajorVersion && minorVersion >= testMinorVersion);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntMap.shrink",
	"Comment": "reduces the size of the backing arrays to be the specified capacity or less. if the capacity is already less, nothing is\tdone. if the map contains more items than the specified capacity, the next highest power of two capacity is used instead.",
	"Method": "void shrink(int maximumCapacity){\r\n    if (maximumCapacity < 0)\r\n        throw new IllegalArgumentException(\"maximumCapacity must be >= 0: \" + maximumCapacity);\r\n    if (size > maximumCapacity)\r\n        maximumCapacity = size;\r\n    if (capacity <= maximumCapacity)\r\n        return;\r\n    maximumCapacity = MathUtils.nextPowerOfTwo(maximumCapacity);\r\n    resize(maximumCapacity);\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.convertSelectionToString",
	"Comment": "converts the selected item from the drop down list into a sequenceof character that can be used in the edit box.",
	"Method": "CharSequence convertSelectionToString(Object selectedItem,CharSequence convertSelectionToString,Object selectedItem,CharSequence convertSelectionToString,Object selectedItem){\r\n    switch(mAutoCompleteMode) {\r\n        case AUTOCOMPLETE_MODE_SINGLE:\r\n            return ((InternalAutoCompleteTextView) mInputView).superConvertSelectionToString(selectedItem);\r\n        case AUTOCOMPLETE_MODE_MULTI:\r\n            return ((InternalMultiAutoCompleteTextView) mInputView).superConvertSelectionToString(selectedItem);\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Mesh.invalidateAllMeshes",
	"Comment": "invalidates all meshes so the next time they are rendered new vbo handles are generated.",
	"Method": "void invalidateAllMeshes(Application app){\r\n    Array<Mesh> meshesArray = meshes.get(app);\r\n    if (meshesArray == null)\r\n        return;\r\n    for (int i = 0; i < meshesArray.size; i++) {\r\n        meshesArray.get(i).vertices.invalidate();\r\n        meshesArray.get(i).indices.invalidate();\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ByteArray.setSize",
	"Comment": "sets the array size, leaving any values beyond the current size undefined.",
	"Method": "byte[] setSize(int newSize){\r\n    if (newSize < 0)\r\n        throw new IllegalArgumentException(\"newSize must be >= 0: \" + newSize);\r\n    if (newSize > items.length)\r\n        resize(Math.max(8, newSize));\r\n    size = newSize;\r\n    return items;\r\n}"
}, {
	"Path": "lombok.javac.apt.LombokProcessor.getJavacProcessingEnvironment",
	"Comment": "this class casts the given processing environment to a javacprocessingenvironment. in case of\tgradle incremental compilation, the delegate processingenvironment of the gradle wrapper is returned.",
	"Method": "JavacProcessingEnvironment getJavacProcessingEnvironment(Object procEnv){\r\n    if (procEnv instanceof JavacProcessingEnvironment)\r\n        return (JavacProcessingEnvironment) procEnv;\r\n    for (Class<?> procEnvClass = procEnv.getClass(); procEnvClass != null; procEnvClass = procEnvClass.getSuperclass()) {\r\n        try {\r\n            return getJavacProcessingEnvironment(tryGetDelegateField(procEnvClass, procEnv));\r\n        } catch (final Exception e) {\r\n        }\r\n    }\r\n    processingEnv.getMessager().printMessage(Kind.WARNING, \"Can't get the delegate of the gradle IncrementalProcessingEnvironment. Lombok won't work.\");\r\n    return null;\r\n}"
}, {
	"Path": "com.rey.material.widget.ListPopupWindow.setDropDownGravity",
	"Comment": "set the gravity of the dropdown list. this is commonly used toset gravity to start or end for alignment with the anchor.",
	"Method": "void setDropDownGravity(int gravity){\r\n    mDropDownGravity = gravity;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.Method.getReturnType",
	"Comment": "returns a class object that represents the formal return type of the method.",
	"Method": "Class getReturnType(){\r\n    return method.getReturnType();\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getTotalPaddingRight",
	"Comment": "returns the total right padding of the view, including the rightdrawable if any.",
	"Method": "int getTotalPaddingRight(){\r\n    return getPaddingRight() + mInputView.getTotalPaddingRight();\r\n}"
}, {
	"Path": "java.nio.ShortBuffer.arrayOffset",
	"Comment": "returns the offset of the short array which this buffer is based on, if there is one.\tthe offset is the index of the array corresponding to the zero position of the buffer.",
	"Method": "int arrayOffset(){\r\n    return protectedArrayOffset();\r\n}"
}, {
	"Path": "org.junit.runner.Description.createTestDescription",
	"Comment": "create a description of a single test named name in the class clazz.generally, this will be a leaf description.",
	"Method": "Description createTestDescription(String className,String name,Annotation annotations,Description createTestDescription,Class<?> clazz,String name,Annotation annotations,Description createTestDescription,Class<?> clazz,String name,Description createTestDescription,String className,String name,Serializable uniqueId){\r\n    return new Description(null, formatDisplayName(name, className), uniqueId);\r\n}"
}, {
	"Path": "com.codahale.metrics.graphite.GraphiteSanitize.sanitize",
	"Comment": "trims the string and replaces all whitespace characters with the provided symbol",
	"Method": "String sanitize(String string){\r\n    return WHITESPACE.matcher(string.trim()).replaceAll(DASH);\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.nextElementSiblings",
	"Comment": "get each of the sibling elements that come after this element.",
	"Method": "Elements nextElementSiblings(Elements nextElementSiblings,boolean next){\r\n    Elements els = new Elements();\r\n    if (parentNode == null)\r\n        return els;\r\n    els.add(this);\r\n    return next ? els.nextAll() : els.prevAll();\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.getElementsByIndexEquals",
	"Comment": "find elements whose sibling index is equal to the supplied index.",
	"Method": "Elements getElementsByIndexEquals(int index){\r\n    return Collector.collect(new Evaluator.IndexEquals(index), this);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect.setBatch",
	"Comment": "assign one batch, among those passed in, to each controller. the batch must be compatible with the controller to be\tassigned.",
	"Method": "void setBatch(Array<ParticleBatch<?>> batches){\r\n    for (ParticleController controller : controllers) {\r\n        for (ParticleBatch<?> batch : batches) if (controller.renderer.setBatch(batch))\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Intersector.intersectSegmentRectangle",
	"Comment": "determines whether the given rectangle and segment intersect",
	"Method": "boolean intersectSegmentRectangle(float startX,float startY,float endX,float endY,Rectangle rectangle,boolean intersectSegmentRectangle,Vector2 start,Vector2 end,Rectangle rectangle){\r\n    return intersectSegmentRectangle(start.x, start.y, end.x, end.y, rectangle);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.FloatArray.random",
	"Comment": "returns a random item from the array, or zero if the array is empty.",
	"Method": "float random(){\r\n    if (size == 0)\r\n        return 0;\r\n    return items[MathUtils.random(0, size - 1)];\r\n}"
}, {
	"Path": "com.sun.jna.Pointer.getString",
	"Comment": "copy native memory to a java string using the requested encoding.",
	"Method": "String getString(long offset,String getString,long offset,String encoding,String getString,long bOff,String encoding){\r\n    return Native.getString(this, offset, encoding);\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.Secur32Util.getSecurityPackages",
	"Comment": "get the security packages installed on the current computer.",
	"Method": "SecurityPackage[] getSecurityPackages(){\r\n    IntByReference pcPackages = new IntByReference();\r\n    PSecPkgInfo pPackageInfo = new PSecPkgInfo();\r\n    int rc = Secur32.INSTANCE.EnumerateSecurityPackages(pcPackages, pPackageInfo);\r\n    if (W32Errors.SEC_E_OK != rc) {\r\n        throw new Win32Exception(rc);\r\n    }\r\n    SecPkgInfo[] packagesInfo = pPackageInfo.toArray(pcPackages.getValue());\r\n    ArrayList<SecurityPackage> packages = new ArrayList<SecurityPackage>(pcPackages.getValue());\r\n    for (SecPkgInfo packageInfo : packagesInfo) {\r\n        SecurityPackage securityPackage = new SecurityPackage();\r\n        securityPackage.name = packageInfo.Name.toString();\r\n        securityPackage.comment = packageInfo.Comment.toString();\r\n        packages.add(securityPackage);\r\n    }\r\n    rc = Secur32.INSTANCE.FreeContextBuffer(pPackageInfo.pPkgInfo.getPointer());\r\n    if (W32Errors.SEC_E_OK != rc) {\r\n        throw new Win32Exception(rc);\r\n    }\r\n    return packages.toArray(new SecurityPackage[0]);\r\n}"
}, {
	"Path": "com.sun.jna.Memory.getChar",
	"Comment": "indirect the native pointer to malloc space, a lapointer.getbyte.but this method performs a boundschecks to ensure that the indirection does not cause memory outside themalloced space to be accessed.",
	"Method": "char getChar(long offset){\r\n    boundsCheck(offset, 1);\r\n    return super.getChar(offset);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.Drawer.setActionBarDrawerToggle",
	"Comment": "add a custom actionbardrawertoggle which will be used in combination with this drawer.",
	"Method": "void setActionBarDrawerToggle(ActionBarDrawerToggle actionBarDrawerToggle){\r\n    this.mDrawerBuilder.mActionBarDrawerToggleEnabled = true;\r\n    this.mDrawerBuilder.mActionBarDrawerToggle = actionBarDrawerToggle;\r\n    this.mDrawerBuilder.handleDrawerNavigation(null, false);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect.load",
	"Comment": "loads all the assets required by all the controllers inside this effect.",
	"Method": "void load(AssetManager assetManager,ResourceData data){\r\n    int i = 0;\r\n    for (ParticleController controller : controllers) {\r\n        controller.load(assetManager, data);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.TextField.setMessageText",
	"Comment": "sets the text that will be drawn in the text field if no text has been entered.",
	"Method": "void setMessageText(String messageText){\r\n    this.messageText = messageText;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.collision.btBroadphasePair.obtain",
	"Comment": "reuses a previous freed instance or creates a new instance and set it to reflect the specified native object",
	"Method": "btBroadphasePair obtain(long cPtr,boolean own){\r\n    final btBroadphasePair result = pool.obtain();\r\n    result.reset(cPtr, own);\r\n    return result;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.I18NBundle.format",
	"Comment": "gets the string with the specified key from this bundle or one of its parent after replacing the given arguments if they\toccur.",
	"Method": "String format(String key,Object args){\r\n    return formatter.format(get(key), args);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.StringBuilder.lastIndexOf",
	"Comment": "searches for the index of the specified character. the search for the character starts at the specified offset and moves\ttowards the beginning.",
	"Method": "int lastIndexOf(String string,int lastIndexOf,String subString,int start){\r\n    int subCount = subString.length();\r\n    if (subCount <= length && start >= 0) {\r\n        if (subCount > 0) {\r\n            if (start > length - subCount) {\r\n                start = length - subCount;\r\n            }\r\n            char firstChar = subString.charAt(0);\r\n            while (true) {\r\n                int i = start;\r\n                boolean found = false;\r\n                for (; i >= 0; --i) {\r\n                    if (chars[i] == firstChar) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!found) {\r\n                    return -1;\r\n                }\r\n                int o1 = i, o2 = 0;\r\n                while (++o2 < subCount && chars[++o1] == subString.charAt(o2)) {\r\n                }\r\n                if (o2 == subCount) {\r\n                    return i;\r\n                }\r\n                start = i - 1;\r\n            }\r\n        }\r\n        return start < length ? start : length;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getTotalPaddingEnd",
	"Comment": "returns the total end padding of the view, including the enddrawable if any.",
	"Method": "int getTotalPaddingEnd(){\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1)\r\n        return getPaddingEnd() + mInputView.getTotalPaddingEnd();\r\n    return getTotalPaddingRight();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntArray.setSize",
	"Comment": "sets the array size, leaving any values beyond the current size undefined.",
	"Method": "int[] setSize(int newSize){\r\n    if (newSize < 0)\r\n        throw new IllegalArgumentException(\"newSize must be >= 0: \" + newSize);\r\n    if (newSize > items.length)\r\n        resize(Math.max(8, newSize));\r\n    size = newSize;\r\n    return items;\r\n}"
}, {
	"Path": "java.nio.LongBuffer.get",
	"Comment": "reads longs from the current position into the specified long array, starting from the specified offset, and increase the\tposition by the number of longs read.",
	"Method": "long get(LongBuffer get,long[] dest,LongBuffer get,long[] dest,int off,int len,long get,int index){\r\n    int length = dest.length;\r\n    if (off < 0 || len < 0 || (long) len + (long) off > length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (len > remaining()) {\r\n        throw new BufferUnderflowException();\r\n    }\r\n    for (int i = off; i < off + len; i++) {\r\n        dest[i] = get();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "lombok.Lombok.preventNullAnalysis",
	"Comment": "returns the parameter directly.\tthis method can be used to prevent a static analyzer to determine the nullness of the passed parameter.",
	"Method": "T preventNullAnalysis(T value){\r\n    return value;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.isBullet",
	"Comment": "is this a fast moving body that should be prevented from tunneling through other moving bodies?note that all bodies are prevented from tunneling through kinematic and static bodies. thissetting is only considered on dynamic bodies.",
	"Method": "boolean isBullet(){\r\n    return bullet;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.ParticleEmitter.getBoundingBox",
	"Comment": "returns the bounding box for all active particles. z axis will always be zero.",
	"Method": "BoundingBox getBoundingBox(){\r\n    if (bounds == null)\r\n        bounds = new BoundingBox();\r\n    Particle[] particles = this.particles;\r\n    boolean[] active = this.active;\r\n    BoundingBox bounds = this.bounds;\r\n    bounds.inf();\r\n    for (int i = 0, n = active.length; i < n; i++) if (active[i]) {\r\n        Rectangle r = particles[i].getBoundingRectangle();\r\n        bounds.ext(r.x, r.y, 0);\r\n        bounds.ext(r.x + r.width, r.y + r.height, 0);\r\n    }\r\n    return bounds;\r\n}"
}, {
	"Path": "com.rey.material.widget.ListPopupWindow.getAnimationStyle",
	"Comment": "returns the animation style that will be used when the popup window is shown or dismissed.",
	"Method": "int getAnimationStyle(){\r\n    return mPopup.getAnimationStyle();\r\n}"
}, {
	"Path": "com.codahale.metrics.health.HealthCheckRegistry.runHealthChecks",
	"Comment": "runs the registered health checks matching the filter in parallel and returns a map of the results.",
	"Method": "SortedMap<String, HealthCheck.Result> runHealthChecks(SortedMap<String, HealthCheck.Result> runHealthChecks,HealthCheckFilter filter,SortedMap<String, HealthCheck.Result> runHealthChecks,ExecutorService executor,SortedMap<String, HealthCheck.Result> runHealthChecks,ExecutorService executor,HealthCheckFilter filter){\r\n    final Map<String, Future<HealthCheck.Result>> futures = new HashMap();\r\n    for (final Map.Entry<String, HealthCheck> entry : healthChecks.entrySet()) {\r\n        final String name = entry.getKey();\r\n        final HealthCheck healthCheck = entry.getValue();\r\n        if (filter.matches(name, healthCheck)) {\r\n            futures.put(name, executor.submit(() -> healthCheck.execute()));\r\n        }\r\n    }\r\n    final SortedMap<String, HealthCheck.Result> results = new TreeMap();\r\n    for (Map.Entry<String, Future<Result>> entry : futures.entrySet()) {\r\n        try {\r\n            results.put(entry.getKey(), entry.getValue().get());\r\n        } catch (Exception e) {\r\n            LOGGER.warn(\"Error executing health check {}\", entry.getKey(), e);\r\n            results.put(entry.getKey(), HealthCheck.Result.unhealthy(e));\r\n        }\r\n    }\r\n    return Collections.unmodifiableSortedMap(results);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Vector2.epsilonEquals",
	"Comment": "compares this vector with the other vector, using the supplied epsilon for fuzzy equality testing.",
	"Method": "boolean epsilonEquals(Vector2 other,float epsilon,boolean epsilonEquals,float x,float y,float epsilon,boolean epsilonEquals,Vector2 other,boolean epsilonEquals,float x,float y){\r\n    return epsilonEquals(x, y, MathUtils.FLOAT_ROUNDING_ERROR);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Array.random",
	"Comment": "returns a random item from the array, or null if the array is empty.",
	"Method": "T random(){\r\n    if (size == 0)\r\n        return null;\r\n    return items[MathUtils.random(0, size - 1)];\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Group.localToDescendantCoordinates",
	"Comment": "converts coordinates for this group to those of a descendant actor. the descendant does not need to be a direct child.",
	"Method": "Vector2 localToDescendantCoordinates(Actor descendant,Vector2 localCoords){\r\n    Group parent = descendant.parent;\r\n    if (parent == null)\r\n        throw new IllegalArgumentException(\"Child is not a descendant: \" + descendant);\r\n    if (parent != this)\r\n        localToDescendantCoordinates(parent, localCoords);\r\n    descendant.parentToLocalCoordinates(localCoords);\r\n    return localCoords;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectMap.put",
	"Comment": "returns the old value associated with the specified key, or null.",
	"Method": "V put(K key,V value){\r\n    if (key == null)\r\n        throw new IllegalArgumentException(\"key cannot be null.\");\r\n    K[] keyTable = this.keyTable;\r\n    int hashCode = key.hashCode();\r\n    int index1 = hashCode & mask;\r\n    K key1 = keyTable[index1];\r\n    if (key.equals(key1)) {\r\n        V oldValue = valueTable[index1];\r\n        valueTable[index1] = value;\r\n        return oldValue;\r\n    }\r\n    int index2 = hash2(hashCode);\r\n    K key2 = keyTable[index2];\r\n    if (key.equals(key2)) {\r\n        V oldValue = valueTable[index2];\r\n        valueTable[index2] = value;\r\n        return oldValue;\r\n    }\r\n    int index3 = hash3(hashCode);\r\n    K key3 = keyTable[index3];\r\n    if (key.equals(key3)) {\r\n        V oldValue = valueTable[index3];\r\n        valueTable[index3] = value;\r\n        return oldValue;\r\n    }\r\n    for (int i = capacity, n = i + stashSize; i < n; i++) {\r\n        if (key.equals(keyTable[i])) {\r\n            V oldValue = valueTable[i];\r\n            valueTable[i] = value;\r\n            return oldValue;\r\n        }\r\n    }\r\n    if (key1 == null) {\r\n        keyTable[index1] = key;\r\n        valueTable[index1] = value;\r\n        if (size++ >= threshold)\r\n            resize(capacity << 1);\r\n        return null;\r\n    }\r\n    if (key2 == null) {\r\n        keyTable[index2] = key;\r\n        valueTable[index2] = value;\r\n        if (size++ >= threshold)\r\n            resize(capacity << 1);\r\n        return null;\r\n    }\r\n    if (key3 == null) {\r\n        keyTable[index3] = key;\r\n        valueTable[index3] = value;\r\n        if (size++ >= threshold)\r\n            resize(capacity << 1);\r\n        return null;\r\n    }\r\n    push(key, value, index1, key1, index2, key2, index3, key3);\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.GuidTest.testGUIDFromBinary2",
	"Comment": "loads a guid from a byte array via the constructor and verify that the\tguid returned has the expected values in each byte.",
	"Method": "void testGUIDFromBinary2(){\r\n    byte[] sourceGuidBArr = new byte[] { (byte) 0xA5, (byte) 0xDC, (byte) 0xBF, (byte) 0x10, (byte) 0x65, (byte) 0x30, (byte) 0x11, (byte) 0xD2, (byte) 0x90, (byte) 0x1F, (byte) 0x00, (byte) 0xC0, (byte) 0x4F, (byte) 0xB9, (byte) 0x51, (byte) 0xED };\r\n    GUID targetGuid = new GUID(sourceGuidBArr);\r\n    byte[] targetGuidBArr = targetGuid.toByteArray();\r\n    for (int i = 0; i < sourceGuidBArr.length; i++) {\r\n        assertEquals(targetGuidBArr[i], sourceGuidBArr[i]);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.TextField.next",
	"Comment": "focuses the next textfield. if none is found, the keyboard is hidden. does nothing if the text field is not in a stage.",
	"Method": "void next(boolean up){\r\n    Stage stage = getStage();\r\n    if (stage == null)\r\n        return;\r\n    TextField current = this;\r\n    Vector2 currentCoords = current.getParent().localToStageCoordinates(tmp2.set(current.getX(), current.getY()));\r\n    Vector2 bestCoords = tmp1;\r\n    while (true) {\r\n        TextField textField = current.findNextTextField(stage.getActors(), null, bestCoords, currentCoords, up);\r\n        if (textField == null) {\r\n            if (up)\r\n                currentCoords.set(Float.MIN_VALUE, Float.MIN_VALUE);\r\n            else\r\n                currentCoords.set(Float.MAX_VALUE, Float.MAX_VALUE);\r\n            textField = current.findNextTextField(stage.getActors(), null, bestCoords, currentCoords, up);\r\n        }\r\n        if (textField == null) {\r\n            Gdx.input.setOnscreenKeyboardVisible(false);\r\n            break;\r\n        }\r\n        if (stage.setKeyboardFocus(textField)) {\r\n            textField.selectAll();\r\n            break;\r\n        }\r\n        current = textField;\r\n        currentCoords.set(bestCoords);\r\n    }\r\n}"
}, {
	"Path": "org.jsoup.nodes.Entities.isBaseNamedEntity",
	"Comment": "check if the input is a known named entity in the base entity set.",
	"Method": "boolean isBaseNamedEntity(String name){\r\n    return base.codepointForName(name) != empty;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Cell.getComputedPadBottom",
	"Comment": "the actual amount of combined padding and spacing from the last layout.",
	"Method": "float getComputedPadBottom(){\r\n    return computedPadBottom;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withSliderBackgroundDrawable",
	"Comment": "set the background drawable for the slider.this is the view containing the list.",
	"Method": "DrawerBuilder withSliderBackgroundDrawable(Drawable sliderBackgroundDrawable){\r\n    this.mSliderBackgroundDrawable = sliderBackgroundDrawable;\r\n    return this;\r\n}"
}, {
	"Path": "com.github.florent37.materialviewpager.MaterialViewPager.setImageDrawable",
	"Comment": "change the header displayed image with a fademay remove picasso",
	"Method": "void setImageDrawable(Drawable drawable,int fadeDuration){\r\n    if (drawable != null) {\r\n        final ImageView headerBackgroundImage = (ImageView) findViewById(R.id.materialviewpager_imageHeader);\r\n        if (headerBackgroundImage != null) {\r\n            ViewCompat.setAlpha(headerBackgroundImage, settings.headerAlpha);\r\n            MaterialViewPagerImageHelper.setImageDrawable(headerBackgroundImage, drawable, fadeDuration);\r\n            setImageHeaderDarkLayerAlpha();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.GwtFileHandle.length",
	"Comment": "returns the length in bytes of this file, or 0 if this file is a directory, does not exist, or the size cannot otherwise be\tdetermined.",
	"Method": "long length(){\r\n    return preloader.length(file);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ShortArray.shrink",
	"Comment": "reduces the size of the backing array to the size of the actual items. this is useful to release memory when many items\thave been removed, or if it is known that more items will not be added.",
	"Method": "short[] shrink(){\r\n    if (items.length != size)\r\n        resize(size);\r\n    return items;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectSet.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "void ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded >= threshold)\r\n        resize(MathUtils.nextPowerOfTwo((int) Math.ceil(sizeNeeded / loadFactor)));\r\n}"
}, {
	"Path": "org.jsoup.select.Elements.prev",
	"Comment": "get the immediate previous element sibling of each element in this list, filtered by the query.",
	"Method": "Elements prev(Elements prev,String query){\r\n    return siblings(query, false, false);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.LongMap.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "void ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded >= threshold)\r\n        resize(MathUtils.nextPowerOfTwo((int) Math.ceil(sizeNeeded / loadFactor)));\r\n}"
}, {
	"Path": "java.nio.IntBuffer.arrayOffset",
	"Comment": "returns the offset of the int array which this buffer is based on, if there is one.\tthe offset is the index of the array corresponds to the zero position of the buffer.",
	"Method": "int arrayOffset(){\r\n    return protectedArrayOffset();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.CharArray.random",
	"Comment": "returns a random item from the array, or zero if the array is empty.",
	"Method": "char random(){\r\n    if (size == 0)\r\n        return 0;\r\n    return items[MathUtils.random(0, size - 1)];\r\n}"
}, {
	"Path": "com.rey.material.widget.ListPopupWindow.performItemClick",
	"Comment": "perform an item click operation on the specified list adapter position.",
	"Method": "boolean performItemClick(int position){\r\n    if (isShowing()) {\r\n        if (mItemClickListener != null) {\r\n            final DropDownListView list = mDropDownList;\r\n            final View child = list.getChildAt(position - list.getFirstVisiblePosition());\r\n            final ListAdapter adapter = list.getAdapter();\r\n            mItemClickListener.onItemClick(list, child, position, adapter.getItemId(position));\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.addDrawerItems",
	"Comment": "add a initial draweritem or a draweritem arrayfor the drawer",
	"Method": "DrawerBuilder addDrawerItems(IDrawerItem drawerItems){\r\n    this.getItemAdapter().add(drawerItems);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Matrix4.setFromEulerAngles",
	"Comment": "sets this matrix to a rotation matrix from the given euler angles.",
	"Method": "Matrix4 setFromEulerAngles(float yaw,float pitch,float roll){\r\n    quat.setEulerAngles(yaw, pitch, roll);\r\n    return set(quat);\r\n}"
}, {
	"Path": "com.rey.material.widget.CheckBox.setCheckedImmediately",
	"Comment": "change the checked state of this button immediately without showing animation.",
	"Method": "void setCheckedImmediately(boolean checked){\r\n    if (getButtonDrawable() instanceof CheckBoxDrawable) {\r\n        CheckBoxDrawable drawable = (CheckBoxDrawable) getButtonDrawable();\r\n        drawable.setAnimEnable(false);\r\n        setChecked(checked);\r\n        drawable.setAnimEnable(true);\r\n    } else\r\n        setChecked(checked);\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.MaterialCalendarView.selectRange",
	"Comment": "select a fresh range of date including first day and last day.",
	"Method": "void selectRange(CalendarDay firstDay,CalendarDay lastDay){\r\n    if (firstDay == null || lastDay == null) {\r\n        return;\r\n    } else if (firstDay.isAfter(lastDay)) {\r\n        adapter.selectRange(lastDay, firstDay);\r\n        dispatchOnRangeSelected(adapter.getSelectedDates());\r\n    } else {\r\n        adapter.selectRange(firstDay, lastDay);\r\n        dispatchOnRangeSelected(adapter.getSelectedDates());\r\n    }\r\n}"
}, {
	"Path": "java.nio.CharBuffer.append",
	"Comment": "writes the given char to the current position and increases the position by 1.",
	"Method": "CharBuffer append(char c,CharBuffer append,CharSequence csq,CharBuffer append,CharSequence csq,int start,int end){\r\n    if (csq == null) {\r\n        csq = \"null\";\r\n    }\r\n    CharSequence cs = csq.subSequence(start, end);\r\n    if (cs.length() > 0) {\r\n        return put(cs.toString());\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.PrismaticJointDef.initialize",
	"Comment": "initialize the bodies, anchors, axis, and reference angle using the world anchor and worldaxis.",
	"Method": "void initialize(Body b1,Body b2,Vec2 anchor,Vec2 axis){\r\n    bodyA = b1;\r\n    bodyB = b2;\r\n    bodyA.getLocalPointToOut(anchor, localAnchorA);\r\n    bodyB.getLocalPointToOut(anchor, localAnchorB);\r\n    bodyA.getLocalVectorToOut(axis, localAxisA);\r\n    referenceAngle = bodyB.getAngle() - bodyA.getAngle();\r\n}"
}, {
	"Path": "com.rey.material.widget.Switch.setCheckedImmediately",
	"Comment": "change the checked state of this switch immediately without showing animation.",
	"Method": "void setCheckedImmediately(boolean checked){\r\n    if (mChecked != checked) {\r\n        mChecked = checked;\r\n        if (mOnCheckedChangeListener != null)\r\n            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);\r\n    }\r\n    mThumbPosition = mChecked ? 1f : 0f;\r\n    invalidate();\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.joints.PrismaticJointDef.initialize",
	"Comment": "initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.",
	"Method": "void initialize(Body bodyA,Body bodyB,Vector2 anchor,Vector2 axis){\r\n    this.bodyA = bodyA;\r\n    this.bodyB = bodyB;\r\n    localAnchorA.set(bodyA.getLocalPoint(anchor));\r\n    localAnchorB.set(bodyB.getLocalPoint(anchor));\r\n    localAxisA.set(bodyA.getLocalVector(axis));\r\n    referenceAngle = bodyB.getAngle() - bodyA.getAngle();\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.setDebugDraw",
	"Comment": "register a routine for debug drawing. the debug draw functions are called inside withworld.drawdebugdata method. the debug draw object is owned by you and must remain in scope.",
	"Method": "void setDebugDraw(DebugDraw debugDraw){\r\n    m_debugDraw = debugDraw;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.appendTo",
	"Comment": "add this element to the supplied parent element, as its next child.",
	"Method": "Element appendTo(Element parent){\r\n    Validate.notNull(parent);\r\n    parent.appendChild(this);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectIntMap.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "void ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded >= threshold)\r\n        resize(MathUtils.nextPowerOfTwo((int) Math.ceil(sizeNeeded / loadFactor)));\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Cell.height",
	"Comment": "sets the minheight, prefheight, and maxheight to the specified value.",
	"Method": "Cell<T> height(Value height,Cell<T> height,float height){\r\n    height(new Fixed(height));\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.Model.extendBoundingBox",
	"Comment": "extends the bounding box with the bounds of this model instance. this is a potential slow operation, it is advised to cache\tthe result.",
	"Method": "BoundingBox extendBoundingBox(BoundingBox out){\r\n    final int n = nodes.size;\r\n    for (int i = 0; i < n; i++) nodes.get(i).extendBoundingBox(out);\r\n    return out;\r\n}"
}, {
	"Path": "com.squareup.leakcanary.LeakTraceElement.getFieldReferenceValue",
	"Comment": "returns the string value of the first field reference that has the provided referencename, ornull if no field reference with that name was found.",
	"Method": "String getFieldReferenceValue(String referenceName){\r\n    for (LeakReference fieldReference : fieldReferences) {\r\n        if (fieldReference.name.equals(referenceName)) {\r\n            return fieldReference.value;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.applyForce",
	"Comment": "apply a force at a world point. if the force is not applied at the center of mass, it willgenerate a torque and affect the angular velocity. this wakes up the body.",
	"Method": "void applyForce(Vec2 force,Vec2 point){\r\n    if (m_type != BodyType.DYNAMIC) {\r\n        return;\r\n    }\r\n    if (isAwake() == false) {\r\n        setAwake(true);\r\n    }\r\n    m_force.x += force.x;\r\n    m_force.y += force.y;\r\n    m_torque += (point.x - m_sweep.c.x) * force.y - (point.y - m_sweep.c.y) * force.x;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Table.columnDefaults",
	"Comment": "gets the cell values that will be used as the defaults for all cells in the specified column. columns are indexed starting",
	"Method": "Cell columnDefaults(int column){\r\n    Cell cell = columnDefaults.size > column ? columnDefaults.get(column) : null;\r\n    if (cell == null) {\r\n        cell = obtainCell();\r\n        cell.clear();\r\n        if (column >= columnDefaults.size) {\r\n            for (int i = columnDefaults.size; i < column; i++) columnDefaults.add(null);\r\n            columnDefaults.add(cell);\r\n        } else\r\n            columnDefaults.set(column, cell);\r\n    }\r\n    return cell;\r\n}"
}, {
	"Path": "lombok.core.AST.clearState",
	"Comment": "clears the registry that avoids endless loops, and empties the node map. the existing node map\tobject is left untouched, and instead a new map is created.",
	"Method": "void clearState(){\r\n    identityDetector = new IdentityHashMap<N, N>();\r\n    nodeMap = new IdentityHashMap<N, L>();\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.lwjgl.LwjglAWTCanvas.isActive",
	"Comment": "returns true when the frame containing the canvas is the foreground window.",
	"Method": "boolean isActive(){\r\n    Component root = SwingUtilities.getRoot(canvas);\r\n    return root instanceof Frame ? ((Frame) root).isActive() : true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane.isScrollY",
	"Comment": "returns true if the widget is larger than the scroll pane vertically.",
	"Method": "boolean isScrollY(){\r\n    return scrollY;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane.isScrollX",
	"Comment": "returns true if the widget is larger than the scroll pane horizontally.",
	"Method": "boolean isScrollX(){\r\n    return scrollX;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.joints.RevoluteJointDef.initialize",
	"Comment": "initialize the bodies, anchors, and reference angle using a world anchor point.",
	"Method": "void initialize(Body bodyA,Body bodyB,Vector2 anchor){\r\n    this.bodyA = bodyA;\r\n    this.bodyB = bodyB;\r\n    localAnchorA.set(bodyA.getLocalPoint(anchor));\r\n    localAnchorB.set(bodyB.getLocalPoint(anchor));\r\n    referenceAngle = bodyB.getAngle() - bodyA.getAngle();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Pool.freeAll",
	"Comment": "puts the specified objects in the pool. null objects within the array are silently ignored.\tthe pool does not check if an object is already freed, so the same object must not be freed multiple times.",
	"Method": "void freeAll(Array<T> objects){\r\n    if (objects == null)\r\n        throw new IllegalArgumentException(\"objects cannot be null.\");\r\n    Array<T> freeObjects = this.freeObjects;\r\n    int max = this.max;\r\n    for (int i = 0; i < objects.size; i++) {\r\n        T object = objects.get(i);\r\n        if (object == null)\r\n            continue;\r\n        if (freeObjects.size < max)\r\n            freeObjects.add(object);\r\n        reset(object);\r\n    }\r\n    peak = Math.max(peak, freeObjects.size);\r\n}"
}, {
	"Path": "com.sun.jna.Function.equals",
	"Comment": "two function pointers are equal if they share the same peer addressand calling convention.",
	"Method": "boolean equals(Object o){\r\n    if (o == this)\r\n        return true;\r\n    if (o == null)\r\n        return false;\r\n    if (o.getClass() == getClass()) {\r\n        Function other = (Function) o;\r\n        return other.callFlags == this.callFlags && other.options.equals(this.options) && other.peer == this.peer;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Fixture.getBody",
	"Comment": "get the parent body of this fixture. this is null if the fixture is not attached.",
	"Method": "Body getBody(){\r\n    return m_body;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.model.AbstractDrawerItem.failedToRecycle",
	"Comment": "is called when the viewholder is in a transient state. return true if you want to reusethat view anyways",
	"Method": "boolean failedToRecycle(VH holder){\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.getLong",
	"Comment": "finds the child with the specified index and returns it as a long.",
	"Method": "long getLong(String name,long defaultValue,long getLong,String name,long getLong,int index){\r\n    JsonValue child = get(index);\r\n    if (child == null)\r\n        throw new IllegalArgumentException(\"Indexed value not found: \" + name);\r\n    return child.asLong();\r\n}"
}, {
	"Path": "org.jsoup.parser.Tag.preserveWhitespace",
	"Comment": "get if this tag should preserve whitespace within child text nodes.",
	"Method": "boolean preserveWhitespace(){\r\n    return preserveWhitespace;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.setFixedRotation",
	"Comment": "set this body to have fixed rotation. this causes the mass to be reset.",
	"Method": "void setFixedRotation(boolean flag){\r\n    if (flag) {\r\n        m_flags |= e_fixedRotationFlag;\r\n    } else {\r\n        m_flags &= ~e_fixedRotationFlag;\r\n    }\r\n    resetMassData();\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.setLineSpacing",
	"Comment": "sets line spacing for this textview.each line will have its heightmultiplied by mult and have add added to it.",
	"Method": "void setLineSpacing(float add,float mult){\r\n    mInputView.setLineSpacing(add, mult);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Actor.setVisible",
	"Comment": "if false, the actor will not be drawn and will not receive touch events. default is true.",
	"Method": "void setVisible(boolean visible){\r\n    this.visible = visible;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.joints.WheelJoint.getJointSpeed",
	"Comment": "get the current joint translation speed, usually in meters per second.",
	"Method": "float getJointSpeed(){\r\n    return joint.getJointSpeed();\r\n}"
}, {
	"Path": "org.mockito.AdditionalMatchers.find",
	"Comment": "string argument that contains a substring that matches the given regularexpression.",
	"Method": "String find(String regex){\r\n    reportMatcher(new Find(regex));\r\n    return null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Rectangle.getCenter",
	"Comment": "calculates the center of the rectangle. results are located in the given vector2",
	"Method": "Vector2 getCenter(Vector2 vector){\r\n    vector.x = x + width / 2;\r\n    vector.y = y + height / 2;\r\n    return vector;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.getElementsByAttribute",
	"Comment": "find elements that have a named attribute set. case insensitive.",
	"Method": "Elements getElementsByAttribute(String key){\r\n    Validate.notEmpty(key);\r\n    key = key.trim();\r\n    return Collector.collect(new Evaluator.Attribute(key), this);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Array.removeRange",
	"Comment": "removes the items between the specified indices, inclusive.",
	"Method": "void removeRange(int start,int end){\r\n    if (end >= size)\r\n        throw new IndexOutOfBoundsException(\"end can't be >= size: \" + end + \" >= \" + size);\r\n    if (start > end)\r\n        throw new IndexOutOfBoundsException(\"start can't be > end: \" + start + \" > \" + end);\r\n    T[] items = this.items;\r\n    int count = end - start + 1;\r\n    if (ordered)\r\n        System.arraycopy(items, start + count, items, start, size - (start + count));\r\n    else {\r\n        int lastIndex = this.size - 1;\r\n        for (int i = 0; i < count; i++) items[start + i] = items[lastIndex - i];\r\n    }\r\n    size -= count;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.setOnKeyListener",
	"Comment": "register a callback to be invoked when a hardware key is pressed in this view.key presses in software input methods will generally not trigger the methods ofthis listener.",
	"Method": "void setOnKeyListener(OnKeyListener l){\r\n    mInputView.setOnKeyListener(l);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20.createDefaultShader",
	"Comment": "returns a new instance of the default shader used by spritebatch for gl2 when no shader is specified.",
	"Method": "ShaderProgram createDefaultShader(boolean hasNormals,boolean hasColors,int numTexCoords){\r\n    String vertexShader = createVertexShader(hasNormals, hasColors, numTexCoords);\r\n    String fragmentShader = createFragmentShader(hasNormals, hasColors, numTexCoords);\r\n    ShaderProgram program = new ShaderProgram(vertexShader, fragmentShader);\r\n    return program;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerUtils.getDrawerItem",
	"Comment": "gets the draweritem with the specific identifier from a draweritem list",
	"Method": "IDrawerItem getDrawerItem(List<IDrawerItem> drawerItems,long identifier,IDrawerItem getDrawerItem,List<IDrawerItem> drawerItems,Object tag){\r\n    if (tag != null) {\r\n        for (IDrawerItem drawerItem : drawerItems) {\r\n            if (tag.equals(drawerItem.getTag())) {\r\n                return drawerItem;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Document.normaliseStructure",
	"Comment": "merge multipleorcontents into one, delete the remainder, and ensure they are owned by",
	"Method": "void normaliseStructure(String tag,Element htmlEl){\r\n    Elements elements = this.getElementsByTag(tag);\r\n    Element master = elements.first();\r\n    if (elements.size() > 1) {\r\n        List<Node> toMove = new ArrayList();\r\n        for (int i = 1; i < elements.size(); i++) {\r\n            Node dupe = elements.get(i);\r\n            toMove.addAll(dupe.ensureChildNodes());\r\n            dupe.remove();\r\n        }\r\n        for (Node dupe : toMove) master.appendChild(dupe);\r\n    }\r\n    if (!master.parent().equals(htmlEl)) {\r\n        htmlEl.appendChild(master);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.getLocalVector",
	"Comment": "gets a local vector given a world vector.\tnote that the same vector2 instance is returned each time this method is called.",
	"Method": "Vector2 getLocalVector(Vector2 worldVector){\r\n    tmp.set(worldVector.x, worldVector.y);\r\n    Vec2 lv = body.getLocalVector(tmp);\r\n    return localVector.set(lv.x, lv.y);\r\n}"
}, {
	"Path": "com.sun.jna.Native.markTemporaryFile",
	"Comment": "perform cleanup of automatically unpacked native shared library.",
	"Method": "void markTemporaryFile(File file){\r\n    try {\r\n        File marker = new File(file.getParentFile(), file.getName() + \".x\");\r\n        marker.createNewFile();\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntFloatMap.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "void ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded >= threshold)\r\n        resize(MathUtils.nextPowerOfTwo((int) Math.ceil(sizeNeeded / loadFactor)));\r\n}"
}, {
	"Path": "com.badlogic.gdx.assets.AssetManager.unload",
	"Comment": "removes the asset and all its dependencies, if they are not used by other assets.",
	"Method": "void unload(String fileName){\r\n    if (tasks.size() > 0) {\r\n        AssetLoadingTask currAsset = tasks.firstElement();\r\n        if (currAsset.assetDesc.fileName.equals(fileName)) {\r\n            currAsset.cancel = true;\r\n            log.info(\"Unload (from tasks): \" + fileName);\r\n            return;\r\n        }\r\n    }\r\n    int foundIndex = -1;\r\n    for (int i = 0; i < loadQueue.size; i++) {\r\n        if (loadQueue.get(i).fileName.equals(fileName)) {\r\n            foundIndex = i;\r\n            break;\r\n        }\r\n    }\r\n    if (foundIndex != -1) {\r\n        toLoad--;\r\n        loadQueue.removeIndex(foundIndex);\r\n        log.info(\"Unload (from queue): \" + fileName);\r\n        return;\r\n    }\r\n    Class type = assetTypes.get(fileName);\r\n    if (type == null)\r\n        throw new GdxRuntimeException(\"Asset not loaded: \" + fileName);\r\n    RefCountedContainer assetRef = assets.get(type).get(fileName);\r\n    assetRef.decRefCount();\r\n    if (assetRef.getRefCount() <= 0) {\r\n        log.info(\"Unload (dispose): \" + fileName);\r\n        if (assetRef.getObject(Object.class) instanceof Disposable)\r\n            ((Disposable) assetRef.getObject(Object.class)).dispose();\r\n        assetTypes.remove(fileName);\r\n        assets.get(type).remove(fileName);\r\n    } else {\r\n        log.info(\"Unload (decrement): \" + fileName);\r\n    }\r\n    Array<String> dependencies = assetDependencies.get(fileName);\r\n    if (dependencies != null) {\r\n        for (String dependency : dependencies) {\r\n            if (isLoaded(dependency))\r\n                unload(dependency);\r\n        }\r\n    }\r\n    if (assetRef.getRefCount() <= 0) {\r\n        assetDependencies.remove(fileName);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.ModelInstance.extendBoundingBox",
	"Comment": "extends the bounding box with the bounds of this model instance. this is a potential slow operation, it is advised to cache\tthe result.",
	"Method": "BoundingBox extendBoundingBox(BoundingBox out){\r\n    final int n = nodes.size;\r\n    for (int i = 0; i < n; i++) nodes.get(i).extendBoundingBox(out);\r\n    return out;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.Sprite.flip",
	"Comment": "boolean parameters x,y are not setting a state, but performing a flip",
	"Method": "void flip(boolean x,boolean y){\r\n    super.flip(x, y);\r\n    float[] vertices = Sprite.this.vertices;\r\n    if (x) {\r\n        float temp = vertices[U1];\r\n        vertices[U1] = vertices[U3];\r\n        vertices[U3] = temp;\r\n        temp = vertices[U2];\r\n        vertices[U2] = vertices[U4];\r\n        vertices[U4] = temp;\r\n    }\r\n    if (y) {\r\n        float temp = vertices[V1];\r\n        vertices[V1] = vertices[V3];\r\n        vertices[V3] = temp;\r\n        temp = vertices[V2];\r\n        vertices[V2] = vertices[V4];\r\n        vertices[V4] = temp;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jna.Native.loadLibrary",
	"Comment": "provided for improved compatibility between jna 4.x and 5.x",
	"Method": "T loadLibrary(Class<T> interfaceClass,T loadLibrary,Class<T> interfaceClass,Map<String, ?> options,T loadLibrary,String name,Class<T> interfaceClass,T loadLibrary,String name,Class<T> interfaceClass,Map<String, ?> options){\r\n    if (!Library.class.isAssignableFrom(interfaceClass)) {\r\n        throw new IllegalArgumentException(\"Interface (\" + interfaceClass.getSimpleName() + \")\" + \" of library=\" + name + \" does not extend \" + Library.class.getSimpleName());\r\n    }\r\n    Library.Handler handler = new Library.Handler(name, interfaceClass, options);\r\n    ClassLoader loader = interfaceClass.getClassLoader();\r\n    Object proxy = Proxy.newProxyInstance(loader, new Class[] { interfaceClass }, handler);\r\n    cacheOptions(interfaceClass, options, proxy);\r\n    return interfaceClass.cast(proxy);\r\n}"
}, {
	"Path": "org.jbox2d.collision.Collision.collidePolygonAndCircle",
	"Comment": "compute the collision manifold between a polygon and a circle.",
	"Method": "void collidePolygonAndCircle(Manifold manifold,PolygonShape polygon,Transform xfA,CircleShape circle,Transform xfB){\r\n    manifold.pointCount = 0;\r\n    final Vec2 circlep = circle.m_p;\r\n    final Rot xfBq = xfB.q;\r\n    final Rot xfAq = xfA.q;\r\n    final float cx = (xfBq.c * circlep.x - xfBq.s * circlep.y) + xfB.p.x;\r\n    final float cy = (xfBq.s * circlep.x + xfBq.c * circlep.y) + xfB.p.y;\r\n    final float px = cx - xfA.p.x;\r\n    final float py = cy - xfA.p.y;\r\n    final float cLocalx = (xfAq.c * px + xfAq.s * py);\r\n    final float cLocaly = (-xfAq.s * px + xfAq.c * py);\r\n    int normalIndex = 0;\r\n    float separation = -Float.MAX_VALUE;\r\n    final float radius = polygon.m_radius + circle.m_radius;\r\n    final int vertexCount = polygon.m_count;\r\n    float s;\r\n    final Vec2[] vertices = polygon.m_vertices;\r\n    final Vec2[] normals = polygon.m_normals;\r\n    for (int i = 0; i < vertexCount; i++) {\r\n        final Vec2 vertex = vertices[i];\r\n        final float tempx = cLocalx - vertex.x;\r\n        final float tempy = cLocaly - vertex.y;\r\n        s = normals[i].x * tempx + normals[i].y * tempy;\r\n        if (s > radius) {\r\n            return;\r\n        }\r\n        if (s > separation) {\r\n            separation = s;\r\n            normalIndex = i;\r\n        }\r\n    }\r\n    final int vertIndex1 = normalIndex;\r\n    final int vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;\r\n    final Vec2 v1 = vertices[vertIndex1];\r\n    final Vec2 v2 = vertices[vertIndex2];\r\n    if (separation < Settings.EPSILON) {\r\n        manifold.pointCount = 1;\r\n        manifold.type = ManifoldType.FACE_A;\r\n        final Vec2 normal = normals[normalIndex];\r\n        manifold.localNormal.x = normal.x;\r\n        manifold.localNormal.y = normal.y;\r\n        manifold.localPoint.x = (v1.x + v2.x) * .5f;\r\n        manifold.localPoint.y = (v1.y + v2.y) * .5f;\r\n        final ManifoldPoint mpoint = manifold.points[0];\r\n        mpoint.localPoint.x = circlep.x;\r\n        mpoint.localPoint.y = circlep.y;\r\n        mpoint.id.zero();\r\n        return;\r\n    }\r\n    final float tempX = cLocalx - v1.x;\r\n    final float tempY = cLocaly - v1.y;\r\n    final float temp2X = v2.x - v1.x;\r\n    final float temp2Y = v2.y - v1.y;\r\n    final float u1 = tempX * temp2X + tempY * temp2Y;\r\n    final float temp3X = cLocalx - v2.x;\r\n    final float temp3Y = cLocaly - v2.y;\r\n    final float temp4X = v1.x - v2.x;\r\n    final float temp4Y = v1.y - v2.y;\r\n    final float u2 = temp3X * temp4X + temp3Y * temp4Y;\r\n    if (u1 <= 0f) {\r\n        final float dx = cLocalx - v1.x;\r\n        final float dy = cLocaly - v1.y;\r\n        if (dx * dx + dy * dy > radius * radius) {\r\n            return;\r\n        }\r\n        manifold.pointCount = 1;\r\n        manifold.type = ManifoldType.FACE_A;\r\n        manifold.localNormal.x = cLocalx - v1.x;\r\n        manifold.localNormal.y = cLocaly - v1.y;\r\n        manifold.localNormal.normalize();\r\n        manifold.localPoint.set(v1);\r\n        manifold.points[0].localPoint.set(circlep);\r\n        manifold.points[0].id.zero();\r\n    } else if (u2 <= 0.0f) {\r\n        final float dx = cLocalx - v2.x;\r\n        final float dy = cLocaly - v2.y;\r\n        if (dx * dx + dy * dy > radius * radius) {\r\n            return;\r\n        }\r\n        manifold.pointCount = 1;\r\n        manifold.type = ManifoldType.FACE_A;\r\n        manifold.localNormal.x = cLocalx - v2.x;\r\n        manifold.localNormal.y = cLocaly - v2.y;\r\n        manifold.localNormal.normalize();\r\n        manifold.localPoint.set(v2);\r\n        manifold.points[0].localPoint.set(circlep);\r\n        manifold.points[0].id.zero();\r\n    } else {\r\n        final float fcx = (v1.x + v2.x) * .5f;\r\n        final float fcy = (v1.y + v2.y) * .5f;\r\n        final float tx = cLocalx - fcx;\r\n        final float ty = cLocaly - fcy;\r\n        final Vec2 normal = normals[vertIndex1];\r\n        separation = tx * normal.x + ty * normal.y;\r\n        if (separation > radius) {\r\n            return;\r\n        }\r\n        manifold.pointCount = 1;\r\n        manifold.type = ManifoldType.FACE_A;\r\n        manifold.localNormal.set(normals[vertIndex1]);\r\n        manifold.localPoint.x = fcx;\r\n        manifold.localPoint.y = fcy;\r\n        manifold.points[0].localPoint.set(circlep);\r\n        manifold.points[0].id.zero();\r\n    }\r\n}"
}, {
	"Path": "com.rey.material.widget.ListPopupWindow.setVerticalOffset",
	"Comment": "set the vertical offset of this popup from its anchor view in pixels.",
	"Method": "void setVerticalOffset(int offset){\r\n    mDropDownVerticalOffset = offset;\r\n    mDropDownVerticalOffsetSet = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.TooltipManager.showAction",
	"Comment": "called when tooltip is shown. default implementation sets actions to animate showing.",
	"Method": "void showAction(Tooltip tooltip){\r\n    float actionTime = animations ? (time > 0 ? 0.5f : 0.15f) : 0.1f;\r\n    tooltip.container.setTransform(true);\r\n    tooltip.container.getColor().a = 0.2f;\r\n    tooltip.container.setScale(0.05f);\r\n    tooltip.container.addAction(parallel(fadeIn(actionTime, fade), scaleTo(1, 1, actionTime, Interpolation.fade)));\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleController.activateParticles",
	"Comment": "generally called by the emitter. this method will notify all the sub systems that a given amount of particles has been\tactivated.",
	"Method": "void activateParticles(int startIndex,int count){\r\n    emitter.activateParticles(startIndex, count);\r\n    for (Influencer influencer : influencers) influencer.activateParticles(startIndex, count);\r\n}"
}, {
	"Path": "org.jsoup.nodes.Document.findFirstElementByTagName",
	"Comment": "fast method to get first by tag name, used for html, head, body finders",
	"Method": "Element findFirstElementByTagName(String tag,Node node){\r\n    if (node.nodeName().equals(tag))\r\n        return (Element) node;\r\n    else {\r\n        int size = node.childNodeSize();\r\n        for (int i = 0; i < size; i++) {\r\n            Element found = findFirstElementByTagName(tag, node.childNode(i));\r\n            if (found != null)\r\n                return found;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.files.FileHandle.writer",
	"Comment": "returns a writer for writing to this file. parent directories will be created if necessary.",
	"Method": "Writer writer(boolean append,Writer writer,boolean append,String charset){\r\n    if (type == FileType.Classpath)\r\n        throw new GdxRuntimeException(\"Cannot write to a classpath file: \" + file);\r\n    if (type == FileType.Internal)\r\n        throw new GdxRuntimeException(\"Cannot write to an internal file: \" + file);\r\n    parent().mkdirs();\r\n    try {\r\n        FileOutputStream output = new FileOutputStream(file(), append);\r\n        if (charset == null)\r\n            return new OutputStreamWriter(output);\r\n        else\r\n            return new OutputStreamWriter(output, charset);\r\n    } catch (IOException ex) {\r\n        if (file().isDirectory())\r\n            throw new GdxRuntimeException(\"Cannot open a stream to a directory: \" + file + \" (\" + type + \")\", ex);\r\n        throw new GdxRuntimeException(\"Error writing file: \" + file + \" (\" + type + \")\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Rectangle.setCenter",
	"Comment": "moves this rectangle so that its center point is located at a given position",
	"Method": "Rectangle setCenter(float x,float y,Rectangle setCenter,Vector2 position){\r\n    setPosition(position.x - width / 2, position.y - height / 2);\r\n    return this;\r\n}"
}, {
	"Path": "java.nio.IntBuffer.get",
	"Comment": "reads ints from the current position into the specified int array, starting from the specified offset, and increases the\tposition by the number of ints read.",
	"Method": "int get(IntBuffer get,int[] dest,IntBuffer get,int[] dest,int off,int len,int get,int index){\r\n    int length = dest.length;\r\n    if (off < 0 || len < 0 || (long) len + (long) off > length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (len > remaining()) {\r\n        throw new BufferUnderflowException();\r\n    }\r\n    for (int i = off; i < off + len; i++) {\r\n        dest[i] = get();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.setContactListener",
	"Comment": "register a contact event listener. the listener is owned by you and must remain in scope.",
	"Method": "void setContactListener(ContactListener listener){\r\n    m_contactManager.m_contactListener = listener;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Json.setElementType",
	"Comment": "sets the type of elements in a collection. when the element type is known, the class for each element in the collection\tdoes not need to be written unless different from the element type.",
	"Method": "void setElementType(Class type,String fieldName,Class elementType){\r\n    ObjectMap<String, FieldMetadata> fields = getFields(type);\r\n    FieldMetadata metadata = fields.get(fieldName);\r\n    if (metadata == null)\r\n        throw new SerializationException(\"Field not found: \" + fieldName + \" (\" + type.getName() + \")\");\r\n    metadata.elementType = elementType;\r\n}"
}, {
	"Path": "java.nio.BufferFactory.newFloatBuffer",
	"Comment": "returns a new array based float buffer with the specified capacity.",
	"Method": "FloatBuffer newFloatBuffer(float array,FloatBuffer newFloatBuffer,int capacity){\r\n    return new ReadWriteFloatArrayBuffer(capacity);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.ShaderProgram.invalidateAllShaderPrograms",
	"Comment": "invalidates all shaders so the next time they are used new handles are generated",
	"Method": "void invalidateAllShaderPrograms(Application app){\r\n    if (Gdx.gl20 == null)\r\n        return;\r\n    Array<ShaderProgram> shaderArray = shaders.get(app);\r\n    if (shaderArray == null)\r\n        return;\r\n    for (int i = 0; i < shaderArray.size; i++) {\r\n        shaderArray.get(i).invalidated = true;\r\n        shaderArray.get(i).checkManaged();\r\n    }\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.resetStickyFooterSelection",
	"Comment": "simple helper method to reset the selection of the sticky footer",
	"Method": "void resetStickyFooterSelection(){\r\n    if (mStickyFooterView instanceof LinearLayout) {\r\n        for (int i = 0; i < (mStickyFooterView).getChildCount(); i++) {\r\n            (mStickyFooterView).getChildAt(i).setActivated(false);\r\n            (mStickyFooterView).getChildAt(i).setSelected(false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop.setTouchOffset",
	"Comment": "sets an offset in stage coordinates from the touch position which is used to determine the drop location. default is",
	"Method": "void setTouchOffset(float touchOffsetX,float touchOffsetY){\r\n    this.touchOffsetX = touchOffsetX;\r\n    this.touchOffsetY = touchOffsetY;\r\n}"
}, {
	"Path": "org.junit.rules.TemporaryFolder.newFile",
	"Comment": "returns a new fresh file with a random name under the temporary folder.",
	"Method": "File newFile(String fileName,File newFile){\r\n    return File.createTempFile(TMP_PREFIX, null, getRoot());\r\n}"
}, {
	"Path": "lombok.javac.handlers.JavacHandlerUtil.injectField",
	"Comment": "adds the given new field declaration to the provided type ast node.\talso takes care of updating the javacast.",
	"Method": "JavacNode injectField(JavacNode typeNode,JCVariableDecl field,JavacNode injectField,JavacNode typeNode,JCVariableDecl field,boolean addGenerated,JavacNode injectField,JavacNode typeNode,JCVariableDecl field,boolean addGenerated,boolean specialEnumHandling){\r\n    JCClassDecl type = (JCClassDecl) typeNode.get();\r\n    if (addGenerated) {\r\n        addSuppressWarningsAll(field.mods, typeNode, field.pos, getGeneratedBy(field), typeNode.getContext());\r\n        addGenerated(field.mods, typeNode, field.pos, getGeneratedBy(field), typeNode.getContext());\r\n    }\r\n    List<JCTree> insertAfter = null;\r\n    List<JCTree> insertBefore = type.defs;\r\n    while (true) {\r\n        boolean skip = false;\r\n        if (insertBefore.head instanceof JCVariableDecl) {\r\n            JCVariableDecl f = (JCVariableDecl) insertBefore.head;\r\n            if ((!specialEnumHandling && isEnumConstant(f)) || isGenerated(f))\r\n                skip = true;\r\n        } else if (insertBefore.head instanceof JCMethodDecl) {\r\n            if ((((JCMethodDecl) insertBefore.head).mods.flags & GENERATEDCONSTR) != 0)\r\n                skip = true;\r\n        }\r\n        if (skip) {\r\n            insertAfter = insertBefore;\r\n            insertBefore = insertBefore.tail;\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n    List<JCTree> fieldEntry = List.<JCTree>of(field);\r\n    fieldEntry.tail = insertBefore;\r\n    if (insertAfter == null) {\r\n        type.defs = fieldEntry;\r\n    } else {\r\n        insertAfter.tail = fieldEntry;\r\n    }\r\n    return typeNode.add(field, Kind.FIELD);\r\n}"
}, {
	"Path": "java.nio.FloatBuffer.put",
	"Comment": "writes floats from the given float array, starting from the specified offset, to the current position and increases the\tposition by the number of floats written.",
	"Method": "FloatBuffer put(float f,FloatBuffer put,float[] src,FloatBuffer put,float[] src,int off,int len,FloatBuffer put,FloatBuffer src,FloatBuffer put,int index,float f){\r\n    if (src == this) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (src.remaining() > remaining()) {\r\n        throw new BufferOverflowException();\r\n    }\r\n    float[] contents = new float[src.remaining()];\r\n    src.get(contents);\r\n    put(contents);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineEffect.setStroke",
	"Comment": "sets the stroke to use for the outline. if this is set, the other outline settings are ignored.",
	"Method": "void setStroke(Stroke stroke){\r\n    this.stroke = stroke;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.BitmapFont.usesIntegerPositions",
	"Comment": "checks whether this font uses integer positions for drawing.",
	"Method": "boolean usesIntegerPositions(){\r\n    return integer;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.setAwake",
	"Comment": "set the sleep state of the body. a sleeping body has very low cpu cost.",
	"Method": "void setAwake(boolean flag){\r\n    body.setAwake(flag);\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.setOnFocusChangeListener",
	"Comment": "register a callback to be invoked when focus of this view changed.",
	"Method": "void setOnFocusChangeListener(OnFocusChangeListener l){\r\n    mInputView.setOnFocusChangeListener(l);\r\n}"
}, {
	"Path": "com.rey.material.widget.RippleManager.onCreate",
	"Comment": "should be called in the construction method of view to create a rippledrawable.",
	"Method": "void onCreate(View v,Context context,AttributeSet attrs,int defStyleAttr,int defStyleRes){\r\n    if (v.isInEditMode())\r\n        return;\r\n    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RippleView, defStyleAttr, defStyleRes);\r\n    int rippleStyle = a.getResourceId(R.styleable.RippleView_rd_style, 0);\r\n    RippleDrawable drawable = null;\r\n    if (rippleStyle != 0)\r\n        drawable = new RippleDrawable.Builder(context, rippleStyle).backgroundDrawable(getBackground(v)).build();\r\n    else {\r\n        boolean rippleEnable = a.getBoolean(R.styleable.RippleView_rd_enable, false);\r\n        if (rippleEnable)\r\n            drawable = new RippleDrawable.Builder(context, attrs, defStyleAttr, defStyleRes).backgroundDrawable(getBackground(v)).build();\r\n    }\r\n    a.recycle();\r\n    if (drawable != null)\r\n        ViewUtil.setBackground(v, drawable);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withStickyDrawerItems",
	"Comment": "set the initial list of idraweritems for the stickydrawerfooter",
	"Method": "DrawerBuilder withStickyDrawerItems(List<IDrawerItem> stickyDrawerItems){\r\n    this.mStickyDrawerItems = stickyDrawerItems;\r\n    return this;\r\n}"
}, {
	"Path": "com.codahale.metrics.WeightedSnapshot.getStdDev",
	"Comment": "returns the weighted standard deviation of the values in the snapshot.",
	"Method": "double getStdDev(){\r\n    if (values.length <= 1) {\r\n        return 0;\r\n    }\r\n    final double mean = getMean();\r\n    double variance = 0;\r\n    for (int i = 0; i < values.length; i++) {\r\n        final double diff = values[i] - mean;\r\n        variance += normWeights[i] * diff * diff;\r\n    }\r\n    return Math.sqrt(variance);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntArray.shrink",
	"Comment": "reduces the size of the backing array to the size of the actual items. this is useful to release memory when many items\thave been removed, or if it is known that more items will not be added.",
	"Method": "int[] shrink(){\r\n    if (items.length != size)\r\n        resize(size);\r\n    return items;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.LongMap.findKey",
	"Comment": "returns the key for the specified value, or notfound if it is not in the map. note this traverses the entire map\tand compares every value, which may be an expensive operation.",
	"Method": "long findKey(Object value,boolean identity,long notFound){\r\n    V[] valueTable = this.valueTable;\r\n    if (value == null) {\r\n        if (hasZeroValue && zeroValue == null)\r\n            return 0;\r\n        long[] keyTable = this.keyTable;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != EMPTY && valueTable[i] == null)\r\n            return keyTable[i];\r\n    } else if (identity) {\r\n        if (value == zeroValue)\r\n            return 0;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (valueTable[i] == value)\r\n            return keyTable[i];\r\n    } else {\r\n        if (hasZeroValue && value.equals(zeroValue))\r\n            return 0;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (value.equals(valueTable[i]))\r\n            return keyTable[i];\r\n    }\r\n    return notFound;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph.isMissing",
	"Comment": "returns true if the font does not have a glyph for this codepoint.",
	"Method": "boolean isMissing(){\r\n    return isMissing;\r\n}"
}, {
	"Path": "lombok.javac.handlers.HandleSuperBuilder.generateBuilderImplClass",
	"Comment": "creates and returns the concrete builder implementation class and injects it into the annotated class.",
	"Method": "JavacNode generateBuilderImplClass(JavacNode source,JavacNode tdParent,String builderImplClass,String builderAbstractClass,List<JCTypeParameter> typeParams){\r\n    JavacTreeMaker maker = tdParent.getTreeMaker();\r\n    JCModifiers mods = maker.Modifiers(Flags.STATIC | Flags.PRIVATE | Flags.FINAL);\r\n    JCExpression extending = maker.Ident(tdParent.toName(builderAbstractClass));\r\n    ListBuffer<JCTypeParameter> allTypeParams = new ListBuffer<JCTypeParameter>();\r\n    allTypeParams.addAll(copyTypeParams(source, typeParams));\r\n    JCExpression annotatedClass = maker.Ident(tdParent.toName(tdParent.getName()));\r\n    if (typeParams.nonEmpty()) {\r\n        annotatedClass = maker.TypeApply(annotatedClass, getTypeParamExpressions(typeParams, maker).toList());\r\n    }\r\n    JCExpression builderImplClassExpression = maker.Ident(tdParent.toName(builderImplClass));\r\n    if (typeParams.nonEmpty()) {\r\n        builderImplClassExpression = maker.TypeApply(builderImplClassExpression, getTypeParamExpressions(typeParams, maker).toList());\r\n    }\r\n    ListBuffer<JCExpression> typeParamsForBuilder = getTypeParamExpressions(typeParams, maker);\r\n    typeParamsForBuilder.add(annotatedClass);\r\n    typeParamsForBuilder.add(builderImplClassExpression);\r\n    extending = maker.TypeApply(extending, typeParamsForBuilder.toList());\r\n    JCClassDecl builder = maker.ClassDef(mods, tdParent.toName(builderImplClass), copyTypeParams(source, typeParams), extending, List.<JCExpression>nil(), List.<JCTree>nil());\r\n    return injectType(tdParent, builder);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.BitmapFontCache.setAlphas",
	"Comment": "sets the alpha component of all text currently in the cache. does not affect subsequently added text.",
	"Method": "void setAlphas(float alpha){\r\n    int alphaBits = ((int) (254 * alpha)) << 24;\r\n    float prev = 0, newColor = 0;\r\n    for (int j = 0, length = pageVertices.length; j < length; j++) {\r\n        float[] vertices = pageVertices[j];\r\n        for (int i = 2, n = idx[j]; i < n; i += 5) {\r\n            float c = vertices[i];\r\n            if (c == prev && i != 2) {\r\n                vertices[i] = newColor;\r\n            } else {\r\n                prev = c;\r\n                int rgba = NumberUtils.floatToIntColor(c);\r\n                rgba = (rgba & 0x00FFFFFF) | alphaBits;\r\n                newColor = NumberUtils.intToFloatColor(rgba);\r\n                vertices[i] = newColor;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.append",
	"Comment": "add inner html to this element. the supplied html will be parsed, and each node appended to the end of the children.",
	"Method": "Element append(String html){\r\n    Validate.notNull(html);\r\n    List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\r\n    addChildren(nodes.toArray(new Node[nodes.size()]));\r\n    return this;\r\n}"
}, {
	"Path": "com.rey.material.widget.ListPopupWindow.setAdapter",
	"Comment": "sets the adapter that provides the data and the views to represent the datain this popup window.",
	"Method": "void setAdapter(ListAdapter adapter){\r\n    if (mObserver == null) {\r\n        mObserver = new PopupDataSetObserver();\r\n    } else if (mAdapter != null) {\r\n        mAdapter.unregisterDataSetObserver(mObserver);\r\n    }\r\n    mAdapter = adapter;\r\n    if (mAdapter != null) {\r\n        adapter.registerDataSetObserver(mObserver);\r\n    }\r\n    if (mDropDownList != null) {\r\n        mDropDownList.setAdapter(mAdapter);\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.isBullet",
	"Comment": "is this body treated like a bullet for continuous collision detection?",
	"Method": "boolean isBullet(){\r\n    return (m_flags & e_bulletFlag) == e_bulletFlag;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup.canCheck",
	"Comment": "called when a button is checked or unchecked. if overridden, generally changing button checked states should not be done\tfrom within this method.",
	"Method": "boolean canCheck(T button,boolean newState){\r\n    if (button.isChecked == newState)\r\n        return false;\r\n    if (!newState) {\r\n        if (checkedButtons.size <= minCheckCount)\r\n            return false;\r\n        checkedButtons.removeValue(button, true);\r\n    } else {\r\n        if (maxCheckCount != -1 && checkedButtons.size >= maxCheckCount) {\r\n            if (uncheckLast) {\r\n                int old = minCheckCount;\r\n                minCheckCount = 0;\r\n                lastChecked.setChecked(false);\r\n                minCheckCount = old;\r\n            } else\r\n                return false;\r\n        }\r\n        checkedButtons.add(button);\r\n        lastChecked = button;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.StringBuilder.replace",
	"Comment": "replaces the specified subsequence in this builder with the specified string.",
	"Method": "StringBuilder replace(int start,int end,String str,StringBuilder replace,String find,String replace,StringBuilder replace,char find,String replace){\r\n    int replaceLength = replace.length();\r\n    int index = 0;\r\n    while (true) {\r\n        while (true) {\r\n            if (index == length)\r\n                return this;\r\n            if (chars[index] == find)\r\n                break;\r\n            index++;\r\n        }\r\n        replace0(index, index + 1, replace);\r\n        index += replaceLength;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jna.Structure.size",
	"Comment": "efficiently calculate the size of the given structure subclass.",
	"Method": "int size(int size,int size,Class<? extends Structure> type,int size,Class<T> type,T value){\r\n    LayoutInfo info;\r\n    synchronized (layoutInfo) {\r\n        info = layoutInfo.get(type);\r\n    }\r\n    int sz = (info != null && !info.variable) ? info.size : CALCULATE_SIZE;\r\n    if (sz == CALCULATE_SIZE) {\r\n        if (value == null) {\r\n            value = newInstance(type, PLACEHOLDER_MEMORY);\r\n        }\r\n        sz = value.size();\r\n    }\r\n    return sz;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Texture.invalidateAllTextures",
	"Comment": "invalidate all managed textures. this is an internal method. do not use it!",
	"Method": "void invalidateAllTextures(Application app){\r\n    Array<Texture> managedTextureArray = managedTextures.get(app);\r\n    if (managedTextureArray == null)\r\n        return;\r\n    if (assetManager == null) {\r\n        for (int i = 0; i < managedTextureArray.size; i++) {\r\n            Texture texture = managedTextureArray.get(i);\r\n            texture.reload();\r\n        }\r\n    } else {\r\n        assetManager.finishLoading();\r\n        Array<Texture> textures = new Array<Texture>(managedTextureArray);\r\n        for (Texture texture : textures) {\r\n            String fileName = assetManager.getAssetFileName(texture);\r\n            if (fileName == null) {\r\n                texture.reload();\r\n            } else {\r\n                final int refCount = assetManager.getReferenceCount(fileName);\r\n                assetManager.setReferenceCount(fileName, 0);\r\n                texture.glHandle = 0;\r\n                TextureParameter params = new TextureParameter();\r\n                params.textureData = texture.getTextureData();\r\n                params.minFilter = texture.getMinFilter();\r\n                params.magFilter = texture.getMagFilter();\r\n                params.wrapU = texture.getUWrap();\r\n                params.wrapV = texture.getVWrap();\r\n                params.genMipMaps = texture.data.useMipMaps();\r\n                params.texture = texture;\r\n                params.loadedCallback = new LoadedCallback() {\r\n                    @Override\r\n                    public void finishedLoading(AssetManager assetManager, String fileName, Class type) {\r\n                        assetManager.setReferenceCount(fileName, refCount);\r\n                    }\r\n                };\r\n                assetManager.unload(fileName);\r\n                texture.glHandle = Gdx.gl.glGenTexture();\r\n                assetManager.load(fileName, Texture.class, params);\r\n            }\r\n        }\r\n        managedTextureArray.clear();\r\n        managedTextureArray.addAll(textures);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Texture.invalidateAllTextures",
	"Comment": "invalidate all managed textures. this is an internal method. do not use it!",
	"Method": "void invalidateAllTextures(Application app){\r\n    assetManager.setReferenceCount(fileName, refCount);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch.setAlignMode",
	"Comment": "sets the current align mode. it will reallocate internal data, use only when necessary.",
	"Method": "void setAlignMode(AlignMode mode){\r\n    if (mode != this.mode) {\r\n        this.mode = mode;\r\n        if (useGPU) {\r\n            initRenderData();\r\n            allocRenderables(bufferedParticlesCount);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.LongArray.shrink",
	"Comment": "reduces the size of the backing array to the size of the actual items. this is useful to release memory when many items\thave been removed, or if it is known that more items will not be added.",
	"Method": "long[] shrink(){\r\n    if (items.length != size)\r\n        resize(size);\r\n    return items;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withSelectedItem",
	"Comment": "set this to the identifier of the item, you would love to select upon start",
	"Method": "DrawerBuilder withSelectedItem(long selectedItemIdentifier){\r\n    this.mSelectedItemIdentifier = selectedItemIdentifier;\r\n    return this;\r\n}"
}, {
	"Path": "org.jsoup.parser.Parser.parseFragment",
	"Comment": "parse a fragment of html into a list of nodes. the context element, if supplied, supplies parsing context.",
	"Method": "List<Node> parseFragment(String fragmentHtml,Element context,String baseUri,List<Node> parseFragment,String fragmentHtml,Element context,String baseUri,ParseErrorList errorList){\r\n    HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\r\n    Parser parser = new Parser(treeBuilder);\r\n    parser.errors = errorList;\r\n    return treeBuilder.parseFragment(fragmentHtml, context, baseUri, parser);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable.tint",
	"Comment": "creates a new drawable that renders the same as this drawable tinted the specified color.",
	"Method": "Drawable tint(Color tint){\r\n    Sprite sprite;\r\n    if (region instanceof AtlasRegion)\r\n        sprite = new AtlasSprite((AtlasRegion) region);\r\n    else\r\n        sprite = new Sprite(region);\r\n    sprite.setColor(tint);\r\n    sprite.setSize(getMinWidth(), getMinHeight());\r\n    SpriteDrawable drawable = new SpriteDrawable(sprite);\r\n    drawable.setLeftWidth(getLeftWidth());\r\n    drawable.setRightWidth(getRightWidth());\r\n    drawable.setTopHeight(getTopHeight());\r\n    drawable.setBottomHeight(getBottomHeight());\r\n    return drawable;\r\n}"
}, {
	"Path": "org.junit.runner.notification.ConcurrentRunNotifierTest.reportConcurrentFailuresAfterAddListener",
	"Comment": "verifies that listeners added while tests are run concurrently arenotified about test failures.",
	"Method": "void reportConcurrentFailuresAfterAddListener(){\r\n    new AbstractConcurrentFailuresTest() {\r\n        @Override\r\n        protected void addListener(ExaminedListener listener) {\r\n            fNotifier.addListener(listener);\r\n        }\r\n    }.test();\r\n}"
}, {
	"Path": "org.junit.runner.notification.ConcurrentRunNotifierTest.reportConcurrentFailuresAfterAddListener",
	"Comment": "verifies that listeners added while tests are run concurrently arenotified about test failures.",
	"Method": "void reportConcurrentFailuresAfterAddListener(){\r\n    fNotifier.addListener(listener);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.Drawer.updateName",
	"Comment": "update the name for a specific draweritemidentified by its id",
	"Method": "void updateName(long identifier,StringHolder name){\r\n    IDrawerItem drawerItem = getDrawerItem(identifier);\r\n    if (drawerItem instanceof Nameable) {\r\n        Nameable pdi = (Nameable) drawerItem;\r\n        pdi.withName(name);\r\n        updateItem((IDrawerItem) pdi);\r\n    }\r\n}"
}, {
	"Path": "com.github.florent37.materialviewpager.MaterialViewPagerHelper.register",
	"Comment": "register an materialviewpageranimator attached to an activity into the concurrenthashmap",
	"Method": "void register(Context context,MaterialViewPagerAnimator animator){\r\n    hashMap.put(context, animator);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ArrayMap.shrink",
	"Comment": "reduces the size of the backing arrays to the size of the actual number of entries. this is useful to release memory when\tmany items have been removed, or if it is known that more entries will not be added.",
	"Method": "void shrink(){\r\n    if (keys.length == size)\r\n        return;\r\n    resize(size);\r\n}"
}, {
	"Path": "lombok.installer.OsUtils.getDrivesOnWindows",
	"Comment": "returns all drive letters on windows that represent fixed disks.\tfloppy drives, optical drives, usb sticks, and network drives should all be excluded.",
	"Method": "List<String> getDrivesOnWindows(){\r\n    loadWindowsDriveInfoLib();\r\n    List<String> drives = new ArrayList<String>();\r\n    WindowsDriveInfo info = new WindowsDriveInfo();\r\n    for (String drive : info.getLogicalDrives()) {\r\n        if (info.isFixedDisk(drive))\r\n            drives.add(drive);\r\n    }\r\n    return drives;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.widgets.ResizableWidgetCollection.setResizeCheckingEnabled",
	"Comment": "set whether or not resize checking is enabled. if disabled, elements will still be resized on window events, but the timer\twill not check their dimensions periodically.",
	"Method": "void setResizeCheckingEnabled(boolean enabled){\r\n    if (enabled && !resizeCheckingEnabled) {\r\n        resizeCheckingEnabled = true;\r\n        if (windowHandler == null) {\r\n            windowHandler = Window.addResizeHandler(this);\r\n        }\r\n        resizeCheckTimer.schedule(resizeCheckDelay);\r\n    } else if (!enabled && resizeCheckingEnabled) {\r\n        resizeCheckingEnabled = false;\r\n        if (windowHandler != null) {\r\n            windowHandler.removeHandler();\r\n            windowHandler = null;\r\n        }\r\n        resizeCheckTimer.cancel();\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.controllers.mappings.Ouya.isRunningOnOuya",
	"Comment": "to allow users to have a single check to see if running on the ouya that also consideres the simulation flag",
	"Method": "boolean isRunningOnOuya(){\r\n    return runningOnOuya || simulateRunningOnOuya;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.AccountHeaderBuilder.withTypeface",
	"Comment": "define the typeface which will be used for all textviews in the accountheader",
	"Method": "AccountHeaderBuilder withTypeface(Typeface typeface){\r\n    this.mTypeface = typeface;\r\n    return this;\r\n}"
}, {
	"Path": "org.jsoup.parser.Parser.xmlParser",
	"Comment": "create a new xml parser. this parser assumes no knowledge of the incoming tags and does not treat it as html,rather creates a simple tree directly from the input.",
	"Method": "Parser xmlParser(){\r\n    return new Parser(new XmlTreeBuilder());\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.collision.Ray.set",
	"Comment": "sets the starting position and direction from the given ray",
	"Method": "Ray set(Vector3 origin,Vector3 direction,Ray set,float x,float y,float z,float dx,float dy,float dz,Ray set,Ray ray){\r\n    this.origin.set(ray.origin);\r\n    this.direction.set(ray.direction);\r\n    return this;\r\n}"
}, {
	"Path": "org.junit.runner.Computer.serial",
	"Comment": "returns a new default computer, which runs tests in serial order",
	"Method": "Computer serial(){\r\n    return new Computer();\r\n}"
}, {
	"Path": "java.nio.Buffer.position",
	"Comment": "sets the position of this buffer.\tif the mark is set and it is greater than the new position, then it is cleared.",
	"Method": "int position(Buffer position,int newPosition){\r\n    if (newPosition < 0 || newPosition > limit) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    position = newPosition;\r\n    if ((mark != UNSET_MARK) && (mark > position)) {\r\n        mark = UNSET_MARK;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.BitmapFontCache.getColor",
	"Comment": "returns the color used for subsequently added text. modifying the color affects text subsequently added to the cache, but\tdoes not affect existing text currently in the cache.",
	"Method": "Color getColor(){\r\n    return color;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window.setPosition",
	"Comment": "sets the position of the window in logical coordinates. all monitors\tspan a virtual surface together. the coordinates are relative to\tthe first monitor in the virtual surface.",
	"Method": "void setPosition(int x,int y){\r\n    GLFW.glfwSetWindowPos(windowHandle, x, y);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Skin.find",
	"Comment": "returns the name of the specified style object, or null if it is not in the skin. this compares potentially every style\tobject in the skin of the same type as the specified style, which may be a somewhat expensive operation.",
	"Method": "String find(Object resource){\r\n    if (resource == null)\r\n        throw new IllegalArgumentException(\"style cannot be null.\");\r\n    ObjectMap<String, Object> typeResources = resources.get(resource.getClass());\r\n    if (typeResources == null)\r\n        return null;\r\n    return typeResources.findKey(resource, true);\r\n}"
}, {
	"Path": "com.sun.jna.NativeLibrary.getFile",
	"Comment": "returns the file on disk corresponding to this nativelibrary instance.if this nativelibrary represents the current process, this function will return null.",
	"Method": "File getFile(){\r\n    if (libraryPath == null)\r\n        return null;\r\n    return new File(libraryPath);\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.setPaddingBottom",
	"Comment": "sets the padding below a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "void setPaddingBottom(int paddingBottom){\r\n    this.paddingBottom = paddingBottom;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.collision.btCollisionObjectWrapper.obtainForArgument",
	"Comment": "obtains a temporary instance, used for callback methods with one or more btmanifoldpoint arguments",
	"Method": "btCollisionObjectWrapper obtainForArgument(long swigCPtr,boolean owner){\r\n    btCollisionObjectWrapper instance = argumentInstances[argumentIndex = (argumentIndex + 1) & 3];\r\n    instance.reset(swigCPtr, owner);\r\n    return instance;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.FloatArray.removeAll",
	"Comment": "removes from this array all of elements contained in the specified array.",
	"Method": "boolean removeAll(FloatArray array){\r\n    int size = this.size;\r\n    int startSize = size;\r\n    float[] items = this.items;\r\n    for (int i = 0, n = array.size; i < n; i++) {\r\n        float item = array.get(i);\r\n        for (int ii = 0; ii < size; ii++) {\r\n            if (item == items[ii]) {\r\n                removeIndex(ii);\r\n                size--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return size != startSize;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Matrix4.setToTranslation",
	"Comment": "sets this matrix to a translation matrix, overwriting it first by an identity matrix and then setting the 4th column to the\ttranslation vector.",
	"Method": "Matrix4 setToTranslation(Vector3 vector,Matrix4 setToTranslation,float x,float y,float z){\r\n    idt();\r\n    val[M03] = x;\r\n    val[M13] = y;\r\n    val[M23] = z;\r\n    return this;\r\n}"
}, {
	"Path": "org.junit.runner.Result.getAssumptionFailureCount",
	"Comment": "returns the number of tests skipped because of an assumption failure",
	"Method": "int getAssumptionFailureCount(){\r\n    if (assumptionFailureCount == null) {\r\n        throw new UnsupportedOperationException(\"Result was serialized from a version of JUnit that doesn't support this method\");\r\n    }\r\n    return assumptionFailureCount.get();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonWriter.setQuoteLongValues",
	"Comment": "when true, quotes long, double, biginteger, bigdecimal types to prevent truncation in languages like javascript and php.\tthis is not necessary when using libgdx, which handles these types without truncation. default is false.",
	"Method": "void setQuoteLongValues(boolean quoteLongValues){\r\n    this.quoteLongValues = quoteLongValues;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.createJoint",
	"Comment": "create a joint to constrain bodies together. no reference to the definition is retained. this may cause the connected bodies\tto cease colliding.",
	"Method": "Joint createJoint(JointDef def){\r\n    org.jbox2d.dynamics.joints.JointDef jd = def.toJBox2d();\r\n    org.jbox2d.dynamics.joints.Joint j = world.createJoint(jd);\r\n    Joint joint = null;\r\n    if (def.type == JointType.DistanceJoint)\r\n        joint = new DistanceJoint(this, (org.jbox2d.dynamics.joints.DistanceJoint) j);\r\n    if (def.type == JointType.FrictionJoint)\r\n        joint = new FrictionJoint(this, (org.jbox2d.dynamics.joints.FrictionJoint) j);\r\n    if (def.type == JointType.GearJoint)\r\n        joint = new GearJoint(this, (org.jbox2d.dynamics.joints.GearJoint) j, ((GearJointDef) def).joint1, ((GearJointDef) def).joint2);\r\n    if (def.type == JointType.MotorJoint)\r\n        joint = new MotorJoint(this, (org.jbox2d.dynamics.joints.MotorJoint) j);\r\n    if (def.type == JointType.MouseJoint)\r\n        joint = new MouseJoint(this, (org.jbox2d.dynamics.joints.MouseJoint) j);\r\n    if (def.type == JointType.PrismaticJoint)\r\n        joint = new PrismaticJoint(this, (org.jbox2d.dynamics.joints.PrismaticJoint) j);\r\n    if (def.type == JointType.PulleyJoint)\r\n        joint = new PulleyJoint(this, (org.jbox2d.dynamics.joints.PulleyJoint) j);\r\n    if (def.type == JointType.RevoluteJoint)\r\n        joint = new RevoluteJoint(this, (org.jbox2d.dynamics.joints.RevoluteJoint) j);\r\n    if (def.type == JointType.RopeJoint)\r\n        joint = new RopeJoint(this, (org.jbox2d.dynamics.joints.RopeJoint) j);\r\n    if (def.type == JointType.WeldJoint)\r\n        joint = new WeldJoint(this, (org.jbox2d.dynamics.joints.WeldJoint) j);\r\n    if (def.type == JointType.WheelJoint)\r\n        joint = new WheelJoint(this, (org.jbox2d.dynamics.joints.WheelJoint) j);\r\n    if (joint == null)\r\n        throw new GdxRuntimeException(\"Joint type '\" + def.type + \"' not yet supported by GWT backend\");\r\n    joints.put(j, joint);\r\n    return joint;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Queue.clear",
	"Comment": "removes all values from this queue. values in backing array are set to null to prevent memory leak, so this operates in",
	"Method": "void clear(){\r\n    if (size == 0)\r\n        return;\r\n    final T[] values = this.values;\r\n    final int head = this.head;\r\n    final int tail = this.tail;\r\n    if (head < tail) {\r\n        for (int i = head; i < tail; i++) {\r\n            values[i] = null;\r\n        }\r\n    } else {\r\n        for (int i = head; i < values.length; i++) {\r\n            values[i] = null;\r\n        }\r\n        for (int i = 0; i < tail; i++) {\r\n            values[i] = null;\r\n        }\r\n    }\r\n    this.head = 0;\r\n    this.tail = 0;\r\n    this.size = 0;\r\n}"
}, {
	"Path": "lombok.eclipse.handlers.EclipseHandlerUtil.generateNullCheck",
	"Comment": "generates a new statement that checks if the given variable is null, and if so, throws a specified exception with the\tvariable name as message.",
	"Method": "Statement generateNullCheck(AbstractVariableDeclaration variable,EclipseNode sourceNode){\r\n    NullCheckExceptionType exceptionType = sourceNode.getAst().readConfiguration(ConfigurationKeys.NON_NULL_EXCEPTION_TYPE);\r\n    if (exceptionType == null)\r\n        exceptionType = NullCheckExceptionType.NULL_POINTER_EXCEPTION;\r\n    ASTNode source = sourceNode.get();\r\n    int pS = source.sourceStart, pE = source.sourceEnd;\r\n    long p = (long) pS << 32 | pE;\r\n    if (isPrimitive(variable.type))\r\n        return null;\r\n    AllocationExpression exception = new AllocationExpression();\r\n    setGeneratedBy(exception, source);\r\n    int partCount = 1;\r\n    String exceptionTypeStr = exceptionType.getExceptionType();\r\n    for (int i = 0; i < exceptionTypeStr.length(); i++) if (exceptionTypeStr.charAt(i) == '.')\r\n        partCount++;\r\n    long[] ps = new long[partCount];\r\n    Arrays.fill(ps, 0L);\r\n    exception.type = new QualifiedTypeReference(fromQualifiedName(exceptionTypeStr), ps);\r\n    setGeneratedBy(exception.type, source);\r\n    exception.arguments = new Expression[] { new StringLiteral(exceptionType.toExceptionMessage(new String(variable.name)).toCharArray(), pS, pE, 0) };\r\n    setGeneratedBy(exception.arguments[0], source);\r\n    ThrowStatement throwStatement = new ThrowStatement(exception, pS, pE);\r\n    setGeneratedBy(throwStatement, source);\r\n    SingleNameReference varName = new SingleNameReference(variable.name, p);\r\n    setGeneratedBy(varName, source);\r\n    NullLiteral nullLiteral = new NullLiteral(pS, pE);\r\n    setGeneratedBy(nullLiteral, source);\r\n    EqualExpression equalExpression = new EqualExpression(varName, nullLiteral, OperatorIds.EQUAL_EQUAL);\r\n    equalExpression.sourceStart = pS;\r\n    equalExpression.statementEnd = equalExpression.sourceEnd = pE;\r\n    setGeneratedBy(equalExpression, source);\r\n    Block throwBlock = new Block(0);\r\n    throwBlock.statements = new Statement[] { throwStatement };\r\n    throwBlock.sourceStart = pS;\r\n    throwBlock.sourceEnd = pE;\r\n    setGeneratedBy(throwBlock, source);\r\n    IfStatement ifStatement = new IfStatement(equalExpression, throwBlock, 0, 0);\r\n    setGeneratedBy(ifStatement, source);\r\n    return ifStatement;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.model.Node.addChild",
	"Comment": "adds the specified node as the currently last child of this node. if the node is already a child of another node, then it is\tremoved from its current parent.",
	"Method": "int addChild(T child){\r\n    return insertChild(-1, child);\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.FileProcessor.setOutputSuffix",
	"Comment": "sets the suffix for output files, replacing the extension of the input file.",
	"Method": "FileProcessor setOutputSuffix(String outputSuffix){\r\n    this.outputSuffix = outputSuffix;\r\n    return this;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withCustomView",
	"Comment": "pass a custom view if you need a completely custom drawercontent",
	"Method": "DrawerBuilder withCustomView(View customView){\r\n    this.mCustomView = customView;\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jna.Native.cacheOptions",
	"Comment": "take note of options used for a given library mapping, to facilitatelooking them up later.",
	"Method": "Map<String, Object> cacheOptions(Class<?> cls,Map<String, ?> options,Object proxy){\r\n    Map<String, Object> libOptions = new HashMap<String, Object>(options);\r\n    libOptions.put(_OPTION_ENCLOSING_LIBRARY, cls);\r\n    typeOptions.put(cls, libOptions);\r\n    if (proxy != null) {\r\n        libraries.put(cls, new WeakReference<Object>(proxy));\r\n    }\r\n    if (!cls.isInterface() && Library.class.isAssignableFrom(cls)) {\r\n        Class<?>[] ifaces = cls.getInterfaces();\r\n        for (Class<?> ifc : ifaces) {\r\n            if (Library.class.isAssignableFrom(ifc)) {\r\n                cacheOptions(ifc, libOptions, proxy);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return libOptions;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane.cancel",
	"Comment": "if currently scrolling by tracking a touch down, stop scrolling.",
	"Method": "void cancel(){\r\n    draggingPointer = -1;\r\n    touchScrollH = false;\r\n    touchScrollV = false;\r\n    flickScrollListener.getGestureDetector().cancel();\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.setBullet",
	"Comment": "is this a fast moving body that should be prevented from tunneling through other moving bodies?note that all bodies are prevented from tunneling through kinematic and static bodies. thissetting is only considered on dynamic bodies.",
	"Method": "void setBullet(boolean bullet){\r\n    this.bullet = bullet;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener.longPress",
	"Comment": "if true is returned, additional gestures will not be triggered. no event is provided because this event is triggered by\ttime passing, not by an inputevent.",
	"Method": "boolean longPress(Actor actor,float x,float y){\r\n    return false;\r\n}"
}, {
	"Path": "junit.framework.TestSuite.getName",
	"Comment": "returns the name of the suite. not alltest suites have a name and this methodcan return null.",
	"Method": "String getName(){\r\n    return fName;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.isAllowSleep",
	"Comment": "set this flag to false if this body should never fall asleep. note that this increases cpuusage.",
	"Method": "boolean isAllowSleep(){\r\n    return allowSleep;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Matrix4.rotate",
	"Comment": "postmultiplies this matrix by the rotation between two vectors.",
	"Method": "Matrix4 rotate(Vector3 axis,float degrees,Matrix4 rotate,float axisX,float axisY,float axisZ,float degrees,Matrix4 rotate,Quaternion rotation,Matrix4 rotate,Vector3 v1,Vector3 v2){\r\n    return rotate(quat.setFromCross(v1, v2));\r\n}"
}, {
	"Path": "org.jsoup.parser.CharacterReader.nextIndexOf",
	"Comment": "returns the number of characters between the current position and the next instance of the input sequence",
	"Method": "int nextIndexOf(char c,int nextIndexOf,CharSequence seq){\r\n    bufferUp();\r\n    char startChar = seq.charAt(0);\r\n    for (int offset = bufPos; offset < bufLength; offset++) {\r\n        if (startChar != charBuf[offset])\r\n            while (++offset < bufLength && startChar != charBuf[offset]) {\r\n            }\r\n        int i = offset + 1;\r\n        int last = i + seq.length() - 1;\r\n        if (offset < bufLength && last <= bufLength) {\r\n            for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) {\r\n            }\r\n            if (i == last)\r\n                return offset - bufPos;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getHint",
	"Comment": "returns the hint that is displayed when the text of the textviewis empty.",
	"Method": "CharSequence getHint(){\r\n    return mInputView.getHint();\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.Kernel32Util.getPrivateProfileInt",
	"Comment": "retrieves an integer associated with a key in the specified section of aninitialization file.",
	"Method": "int getPrivateProfileInt(String appName,String keyName,int defaultValue,String fileName){\r\n    return Kernel32.INSTANCE.GetPrivateProfileInt(appName, keyName, defaultValue, fileName);\r\n}"
}, {
	"Path": "com.sun.jna.CallbackReference.findCallbackClass",
	"Comment": "find the first instance of an interface which implements the callbackinterface or an interface derived from callback, which defines anappropriate callback method.",
	"Method": "Class<?> findCallbackClass(Class<?> type){\r\n    if (!Callback.class.isAssignableFrom(type)) {\r\n        throw new IllegalArgumentException(type.getName() + \" is not derived from com.sun.jna.Callback\");\r\n    }\r\n    if (type.isInterface()) {\r\n        return type;\r\n    }\r\n    Class<?>[] ifaces = type.getInterfaces();\r\n    for (int i = 0; i < ifaces.length; i++) {\r\n        if (Callback.class.isAssignableFrom(ifaces[i])) {\r\n            try {\r\n                getCallbackMethod(ifaces[i]);\r\n                return ifaces[i];\r\n            } catch (IllegalArgumentException e) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (Callback.class.isAssignableFrom(type.getSuperclass())) {\r\n        return findCallbackClass(type.getSuperclass());\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.setBullet",
	"Comment": "should this body be treated like a bullet for continuous collision detection?",
	"Method": "void setBullet(boolean flag){\r\n    if (flag) {\r\n        m_flags |= e_bulletFlag;\r\n    } else {\r\n        m_flags &= ~e_bulletFlag;\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio.retain",
	"Comment": "retains a list of the most recently played sounds and stops the sound played least recently if necessary for a new sound to",
	"Method": "void retain(OpenALSound sound,boolean stop){\r\n    mostRecetSound++;\r\n    mostRecetSound %= recentSounds.length;\r\n    if (stop) {\r\n        if (recentSounds[mostRecetSound] != null)\r\n            recentSounds[mostRecetSound].stop();\r\n    }\r\n    recentSounds[mostRecetSound] = sound;\r\n}"
}, {
	"Path": "org.junit.runner.notification.RunNotifier.pleaseStop",
	"Comment": "ask that the tests run stop before starting the next test. phrased politely becausethe test currently running will not be interrupted. it seems a little odd to put thisfunctionality here, but the runnotifier is the only object guaranteedto be shared amongst the many runners involved.",
	"Method": "void pleaseStop(){\r\n    pleaseStop = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Polygon.getTransformedVertices",
	"Comment": "calculates and returns the vertices of the polygon after scaling, rotation, and positional translations have been applied,\tas they are position within the world.",
	"Method": "float[] getTransformedVertices(){\r\n    if (!dirty)\r\n        return worldVertices;\r\n    dirty = false;\r\n    final float[] localVertices = this.localVertices;\r\n    if (worldVertices == null || worldVertices.length != localVertices.length)\r\n        worldVertices = new float[localVertices.length];\r\n    final float[] worldVertices = this.worldVertices;\r\n    final float positionX = x;\r\n    final float positionY = y;\r\n    final float originX = this.originX;\r\n    final float originY = this.originY;\r\n    final float scaleX = this.scaleX;\r\n    final float scaleY = this.scaleY;\r\n    final boolean scale = scaleX != 1 || scaleY != 1;\r\n    final float rotation = this.rotation;\r\n    final float cos = MathUtils.cosDeg(rotation);\r\n    final float sin = MathUtils.sinDeg(rotation);\r\n    for (int i = 0, n = localVertices.length; i < n; i += 2) {\r\n        float x = localVertices[i] - originX;\r\n        float y = localVertices[i + 1] - originY;\r\n        if (scale) {\r\n            x *= scaleX;\r\n            y *= scaleY;\r\n        }\r\n        if (rotation != 0) {\r\n            float oldX = x;\r\n            x = cos * x - sin * y;\r\n            y = sin * oldX + cos * y;\r\n        }\r\n        worldVertices[i] = positionX + x + originX;\r\n        worldVertices[i + 1] = positionY + y + originY;\r\n    }\r\n    return worldVertices;\r\n}"
}, {
	"Path": "com.codahale.metrics.UniformSnapshot.getStdDev",
	"Comment": "returns the standard deviation of the values in the snapshot.",
	"Method": "double getStdDev(){\r\n    if (values.length <= 1) {\r\n        return 0;\r\n    }\r\n    final double mean = getMean();\r\n    double sum = 0;\r\n    for (long value : values) {\r\n        final double diff = value - mean;\r\n        sum += diff * diff;\r\n    }\r\n    final double variance = sum / (values.length - 1);\r\n    return Math.sqrt(variance);\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect.generateGaussianBlurKernels",
	"Comment": "generate the blur kernels which will be repeatedly applied when blurring images",
	"Method": "float[][] generateGaussianBlurKernels(int level){\r\n    float[][] pascalsTriangle = generatePascalsTriangle(level);\r\n    float[][] gaussianTriangle = new float[pascalsTriangle.length][];\r\n    for (int i = 0; i < gaussianTriangle.length; i++) {\r\n        float total = 0.0f;\r\n        gaussianTriangle[i] = new float[pascalsTriangle[i].length];\r\n        for (int j = 0; j < pascalsTriangle[i].length; j++) total += pascalsTriangle[i][j];\r\n        float coefficient = 1 / total;\r\n        for (int j = 0; j < pascalsTriangle[i].length; j++) gaussianTriangle[i][j] = coefficient * pascalsTriangle[i][j];\r\n    }\r\n    return gaussianTriangle;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.WindowedMean.clear",
	"Comment": "clears this windowedmean. the class will only return meaningful values after enough data has been added again.",
	"Method": "void clear(){\r\n    added_values = 0;\r\n    last_value = 0;\r\n    for (int i = 0; i < values.length; i++) values[i] = 0;\r\n    dirty = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.IndexBufferObject.bind",
	"Comment": "binds this indexbufferobject for rendering with gldrawelements.",
	"Method": "void bind(){\r\n    if (bufferHandle == 0)\r\n        throw new GdxRuntimeException(\"No buffer allocated!\");\r\n    Gdx.gl20.glBindBuffer(GL20.GL_ELEMENT_ARRAY_BUFFER, bufferHandle);\r\n    if (isDirty) {\r\n        byteBuffer.limit(buffer.limit() * 2);\r\n        Gdx.gl20.glBufferData(GL20.GL_ELEMENT_ARRAY_BUFFER, byteBuffer.limit(), byteBuffer, usage);\r\n        isDirty = false;\r\n    }\r\n    isBound = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.actions.Actions.fadeIn",
	"Comment": "transitions from the alpha at the time this action starts to an alpha of 1.",
	"Method": "AlphaAction fadeIn(float duration,AlphaAction fadeIn,float duration,Interpolation interpolation){\r\n    AlphaAction action = action(AlphaAction.class);\r\n    action.setAlpha(1);\r\n    action.setDuration(duration);\r\n    action.setInterpolation(interpolation);\r\n    return action;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.decals.Decal.lookAt",
	"Comment": "sets the rotation of the decal to face the given point. useful for billboarding.",
	"Method": "void lookAt(Vector3 position,Vector3 up){\r\n    dir.set(position).sub(this.position).nor();\r\n    setRotation(dir, up);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Json.setSerializer",
	"Comment": "registers a serializer to use for the specified type instead of the default behavior of serializing all of an objects\tfields.",
	"Method": "void setSerializer(Class<T> type,Serializer<T> serializer){\r\n    classToSerializer.put(type, serializer);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.collision.btCollisionObject.addInstance",
	"Comment": "add the instance to the managed instances.\tyou should avoid using this method. this method is intended for internal purposes only.",
	"Method": "void addInstance(btCollisionObject obj){\r\n    instances.put(getCPtr(obj), obj);\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.getFontFile",
	"Comment": "returns the path to the ttf file for this unicodefont, or null. if this unicodefont was created without specifying the ttf\tfile, it will try to determine the path using sun classes. if this fails, null is returned.",
	"Method": "String getFontFile(){\r\n    if (ttfFileRef == null) {\r\n        try {\r\n            Object font2D;\r\n            try {\r\n                font2D = Class.forName(\"sun.font.FontUtilities\").getDeclaredMethod(\"getFont2D\", new Class[] { Font.class }).invoke(null, new Object[] { font });\r\n            } catch (Throwable ignored) {\r\n                font2D = Class.forName(\"sun.font.FontManager\").getDeclaredMethod(\"getFont2D\", new Class[] { Font.class }).invoke(null, new Object[] { font });\r\n            }\r\n            Field platNameField = Class.forName(\"sun.font.PhysicalFont\").getDeclaredField(\"platName\");\r\n            platNameField.setAccessible(true);\r\n            ttfFileRef = (String) platNameField.get(font2D);\r\n        } catch (Throwable ignored) {\r\n        }\r\n        if (ttfFileRef == null)\r\n            ttfFileRef = \"\";\r\n    }\r\n    if (ttfFileRef.length() == 0)\r\n        return null;\r\n    return ttfFileRef;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.isMemberClass",
	"Comment": "returns true if the class or interface represented by the supplied class is a member class.",
	"Method": "boolean isMemberClass(Class c){\r\n    return c.isMemberClass();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntSet.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "void ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded >= threshold)\r\n        resize(MathUtils.nextPowerOfTwo((int) Math.ceil(sizeNeeded / loadFactor)));\r\n}"
}, {
	"Path": "com.sun.jna.Memory.setPointer",
	"Comment": "indirect the native pointer to malloc space, a lapointer.setpointer.but this method performsa bounds checks to ensure that the indirection does not cause memoryoutside the malloced space to be accessed.",
	"Method": "void setPointer(long offset,Pointer value){\r\n    boundsCheck(offset, Native.POINTER_SIZE);\r\n    super.setPointer(offset, value);\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.getElementsByAttributeValueContaining",
	"Comment": "find elements that have attributes whose value contains the match string. case insensitive.",
	"Method": "Elements getElementsByAttributeValueContaining(String key,String match){\r\n    return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.W32ServiceManager.enumServicesStatusExProcess",
	"Comment": "enumerates services in the specified service control manager database.the name and status of each service are provided, along with additionaldata based on the specified information level.",
	"Method": "ENUM_SERVICE_STATUS_PROCESS[] enumServicesStatusExProcess(int dwServiceType,int dwServiceState,String groupName){\r\n    IntByReference pcbBytesNeeded = new IntByReference(0);\r\n    IntByReference lpServicesReturned = new IntByReference(0);\r\n    IntByReference lpResumeHandle = new IntByReference(0);\r\n    Advapi32.INSTANCE.EnumServicesStatusEx(_handle, Winsvc.SC_ENUM_PROCESS_INFO, dwServiceType, dwServiceState, Pointer.NULL, 0, pcbBytesNeeded, lpServicesReturned, lpResumeHandle, groupName);\r\n    int lastError = Kernel32.INSTANCE.GetLastError();\r\n    if (lastError != WinError.ERROR_MORE_DATA) {\r\n        throw new Win32Exception(lastError);\r\n    }\r\n    Memory buffer = new Memory(pcbBytesNeeded.getValue());\r\n    boolean result = Advapi32.INSTANCE.EnumServicesStatusEx(_handle, Winsvc.SC_ENUM_PROCESS_INFO, dwServiceType, dwServiceState, buffer, (int) buffer.size(), pcbBytesNeeded, lpServicesReturned, lpResumeHandle, groupName);\r\n    if (!result) {\r\n        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n    }\r\n    if (lpServicesReturned.getValue() == 0) {\r\n        return new Winsvc.ENUM_SERVICE_STATUS_PROCESS[0];\r\n    }\r\n    ENUM_SERVICE_STATUS_PROCESS status = Structure.newInstance(ENUM_SERVICE_STATUS_PROCESS.class, buffer);\r\n    status.read();\r\n    return (ENUM_SERVICE_STATUS_PROCESS[]) status.toArray(lpServicesReturned.getValue());\r\n}"
}, {
	"Path": "org.junit.rules.Timeout.getTimeout",
	"Comment": "gets the timeout configured for this rule, in the given units.",
	"Method": "long getTimeout(TimeUnit unit,long getTimeout){\r\n    return unit.convert(timeout, timeUnit);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.collision.BoundingBox.mul",
	"Comment": "multiplies the bounding box by the given matrix. this is achieved by multiplying the 8 corner points and then calculating\tthe minimum and maximum vectors from the transformed points.",
	"Method": "BoundingBox mul(Matrix4 transform){\r\n    final float x0 = min.x, y0 = min.y, z0 = min.z, x1 = max.x, y1 = max.y, z1 = max.z;\r\n    inf();\r\n    ext(tmpVector.set(x0, y0, z0).mul(transform));\r\n    ext(tmpVector.set(x0, y0, z1).mul(transform));\r\n    ext(tmpVector.set(x0, y1, z0).mul(transform));\r\n    ext(tmpVector.set(x0, y1, z1).mul(transform));\r\n    ext(tmpVector.set(x1, y0, z0).mul(transform));\r\n    ext(tmpVector.set(x1, y0, z1).mul(transform));\r\n    ext(tmpVector.set(x1, y1, z0).mul(transform));\r\n    ext(tmpVector.set(x1, y1, z1).mul(transform));\r\n    return this;\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.MaterialCalendarView.enableView",
	"Comment": "used for enabling or disabling views, while also changing the alpha.",
	"Method": "void enableView(View view,boolean enable){\r\n    view.setEnabled(enable);\r\n    view.setAlpha(enable ? 1f : 0.1f);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.CharArray.truncate",
	"Comment": "reduces the size of the array to the specified size. if the array is already smaller than the specified size, no action is",
	"Method": "void truncate(int newSize){\r\n    if (size > newSize)\r\n        size = newSize;\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.Shell32Util.getSpecialFolderPath",
	"Comment": "retrieves the path of a special folder, identified by its csidl.",
	"Method": "String getSpecialFolderPath(int csidl,boolean create){\r\n    final char[] pszPath = new char[WinDef.MAX_PATH];\r\n    if (!Shell32.INSTANCE.SHGetSpecialFolderPath(null, pszPath, csidl, create))\r\n        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n    return Native.toString(pszPath);\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getCompoundDrawablePadding",
	"Comment": "returns the padding between the compound drawables and the text.",
	"Method": "int getCompoundDrawablePadding(){\r\n    return mInputView.getCompoundDrawablePadding();\r\n}"
}, {
	"Path": "com.sun.jna.Structure.sortFields",
	"Comment": "sort the structure fields according to the given array of names.",
	"Method": "void sortFields(List<Field> fields,List<String> names){\r\n    for (int i = 0; i < names.size(); i++) {\r\n        String name = names.get(i);\r\n        for (int f = 0; f < fields.size(); f++) {\r\n            Field field = fields.get(f);\r\n            if (name.equals(field.getName())) {\r\n                Collections.swap(fields, i, f);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.rey.material.widget.CheckedTextView.setOnCheckedChangeListener",
	"Comment": "set a listener will be called when the checked state is changed.",
	"Method": "void setOnCheckedChangeListener(OnCheckedChangeListener listener){\r\n    mOnCheckedChangeListener = listener;\r\n}"
}, {
	"Path": "com.sun.jna.platform.WindowUtilsTest.xtestWindowDisposeBug",
	"Comment": "test for accumulation of windows with repetitive setting of mask",
	"Method": "void xtestWindowDisposeBug(){\r\n    final JFrame w = new JFrame(getName());\r\n    w.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n    w.getContentPane().add(new JLabel(getName()));\r\n    WindowUtils.setWindowMask(w, new Area(new Rectangle(600, 20)));\r\n    w.pack();\r\n    w.setSize(600, 600);\r\n    w.setResizable(false);\r\n    w.setVisible(true);\r\n    final Shape mask = new Rectangle(0, 0, w.getWidth(), w.getHeight());\r\n    while (true) {\r\n        System.gc();\r\n        Thread.sleep(50);\r\n        SwingUtilities.invokeLater(new Runnable() {\r\n            public void run() {\r\n                WindowUtils.setWindowMask(w, mask);\r\n                Window[] owned = w.getOwnedWindows();\r\n                System.err.println(owned.length + \": \" + Arrays.asList(w.getOwnedWindows()));\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.sun.jna.platform.WindowUtilsTest.xtestWindowDisposeBug",
	"Comment": "test for accumulation of windows with repetitive setting of mask",
	"Method": "void xtestWindowDisposeBug(){\r\n    WindowUtils.setWindowMask(w, mask);\r\n    Window[] owned = w.getOwnedWindows();\r\n    System.err.println(owned.length + \": \" + Arrays.asList(w.getOwnedWindows()));\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.joints.PulleyJointDef.initialize",
	"Comment": "initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.",
	"Method": "void initialize(Body bodyA,Body bodyB,Vector2 groundAnchorA,Vector2 groundAnchorB,Vector2 anchorA,Vector2 anchorB,float ratio){\r\n    this.bodyA = bodyA;\r\n    this.bodyB = bodyB;\r\n    this.groundAnchorA.set(groundAnchorA);\r\n    this.groundAnchorB.set(groundAnchorB);\r\n    this.localAnchorA.set(bodyA.getLocalPoint(anchorA));\r\n    this.localAnchorB.set(bodyB.getLocalPoint(anchorB));\r\n    lengthA = anchorA.dst(groundAnchorA);\r\n    lengthB = anchorB.dst(groundAnchorB);\r\n    this.ratio = ratio;\r\n    float C = lengthA + ratio * lengthB;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Attributes.copyOf",
	"Comment": "simple implementation of arrays.copy, for support of android api 8.",
	"Method": "String[] copyOf(String[] orig,int size){\r\n    final String[] copy = new String[size];\r\n    System.arraycopy(orig, 0, copy, 0, Math.min(orig.length, size));\r\n    return copy;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.collision.BoundingBox.inf",
	"Comment": "sets the minimum and maximum vector to positive and negative infinity.",
	"Method": "BoundingBox inf(){\r\n    min.set(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY);\r\n    max.set(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY);\r\n    cnt.set(0, 0, 0);\r\n    dim.set(0, 0, 0);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IdentityMap.findKey",
	"Comment": "returns the key for the specified value, or null if it is not in the map. note this traverses the entire map and compares\tevery value, which may be an expensive operation.",
	"Method": "K findKey(Object value,boolean identity){\r\n    V[] valueTable = this.valueTable;\r\n    if (value == null) {\r\n        K[] keyTable = this.keyTable;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != null && valueTable[i] == null)\r\n            return keyTable[i];\r\n    } else if (identity) {\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (valueTable[i] == value)\r\n            return keyTable[i];\r\n    } else {\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (value.equals(valueTable[i]))\r\n            return keyTable[i];\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.squareup.leakcanary.internal.LeakCanaryInternals.classSimpleName",
	"Comment": "extracts the class simple name out of a string containing a fully qualified class name.",
	"Method": "String classSimpleName(String className){\r\n    int separator = className.lastIndexOf('.');\r\n    if (separator == -1) {\r\n        return className;\r\n    } else {\r\n        return className.substring(separator + 1);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper.length",
	"Comment": "returns the length in bytes of this file, or 0 if this file is a directory, does not exist, or the size cannot otherwise be\tdetermined.",
	"Method": "long length(){\r\n    return file().length();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.BooleanArray.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "boolean[] ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded > items.length)\r\n        resize(Math.max(8, sizeNeeded));\r\n    return items;\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.MaterialCalendarView.setOnRangeSelectedListener",
	"Comment": "sets the listener to be notified upon a range has been selected.",
	"Method": "void setOnRangeSelectedListener(OnRangeSelectedListener listener){\r\n    this.rangeListener = listener;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.WeldJointDef.initialize",
	"Comment": "initialize the bodies, anchors, and reference angle using a world anchor point.",
	"Method": "void initialize(Body bA,Body bB,Vec2 anchor){\r\n    bodyA = bA;\r\n    bodyB = bB;\r\n    bodyA.getLocalPointToOut(anchor, localAnchorA);\r\n    bodyB.getLocalPointToOut(anchor, localAnchorB);\r\n    referenceAngle = bodyB.getAngle() - bodyA.getAngle();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.GdxNativesLoader.load",
	"Comment": "loads the libgdx native libraries if they have not already been loaded.",
	"Method": "void load(){\r\n    if (nativesLoaded)\r\n        return;\r\n    nativesLoaded = true;\r\n    if (disableNativesLoading)\r\n        return;\r\n    new SharedLibraryLoader().load(\"gdx\");\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.resetMassData",
	"Comment": "this resets the mass properties to the sum of the mass properties of the fixtures. thisnormally does not need to be called unless you called setmassdata to override the mass and youlater want to reset the mass.",
	"Method": "void resetMassData(){\r\n    m_mass = 0.0f;\r\n    m_invMass = 0.0f;\r\n    m_I = 0.0f;\r\n    m_invI = 0.0f;\r\n    m_sweep.localCenter.setZero();\r\n    if (m_type == BodyType.STATIC || m_type == BodyType.KINEMATIC) {\r\n        m_sweep.c0.set(m_xf.p);\r\n        m_sweep.c.set(m_xf.p);\r\n        m_sweep.a0 = m_sweep.a;\r\n        return;\r\n    }\r\n    assert (m_type == BodyType.DYNAMIC);\r\n    final Vec2 localCenter = m_world.getPool().popVec2();\r\n    localCenter.setZero();\r\n    final Vec2 temp = m_world.getPool().popVec2();\r\n    final MassData massData = pmd;\r\n    for (Fixture f = m_fixtureList; f != null; f = f.m_next) {\r\n        if (f.m_density == 0.0f) {\r\n            continue;\r\n        }\r\n        f.getMassData(massData);\r\n        m_mass += massData.mass;\r\n        temp.set(massData.center).mulLocal(massData.mass);\r\n        localCenter.addLocal(temp);\r\n        m_I += massData.I;\r\n    }\r\n    if (m_mass > 0.0f) {\r\n        m_invMass = 1.0f / m_mass;\r\n        localCenter.mulLocal(m_invMass);\r\n    } else {\r\n        m_mass = 1.0f;\r\n        m_invMass = 1.0f;\r\n    }\r\n    if (m_I > 0.0f && (m_flags & e_fixedRotationFlag) == 0) {\r\n        m_I -= m_mass * Vec2.dot(localCenter, localCenter);\r\n        assert (m_I > 0.0f);\r\n        m_invI = 1.0f / m_I;\r\n    } else {\r\n        m_I = 0.0f;\r\n        m_invI = 0.0f;\r\n    }\r\n    Vec2 oldCenter = m_world.getPool().popVec2();\r\n    oldCenter.set(m_sweep.c);\r\n    m_sweep.localCenter.set(localCenter);\r\n    Transform.mulToOutUnsafe(m_xf, m_sweep.localCenter, m_sweep.c0);\r\n    m_sweep.c.set(m_sweep.c0);\r\n    temp.set(m_sweep.c).subLocal(oldCenter);\r\n    final Vec2 temp2 = oldCenter;\r\n    Vec2.crossToOutUnsafe(m_angularVelocity, temp, temp2);\r\n    m_linearVelocity.addLocal(temp2);\r\n    m_world.getPool().pushVec2(3);\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.MaterialCalendarView.setTitleAnimationOrientation",
	"Comment": "change the title animation orientation to have a different look and feel.",
	"Method": "void setTitleAnimationOrientation(int orientation){\r\n    titleChanger.setOrientation(orientation);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.getSimpleName",
	"Comment": "returns the simple name of the underlying class as supplied in the source code.",
	"Method": "String getSimpleName(Class c){\r\n    return c.getSimpleName();\r\n}"
}, {
	"Path": "com.rey.material.widget.Switch.setOnCheckedChangeListener",
	"Comment": "set a listener will be called when the checked state is changed.",
	"Method": "void setOnCheckedChangeListener(OnCheckedChangeListener listener){\r\n    mOnCheckedChangeListener = listener;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.shouldCollide",
	"Comment": "this is used to prevent connected bodies from colliding. it may lie, depending on thecollideconnected flag.",
	"Method": "boolean shouldCollide(Body other){\r\n    if (m_type != BodyType.DYNAMIC && other.m_type != BodyType.DYNAMIC) {\r\n        return false;\r\n    }\r\n    for (JointEdge jn = m_jointList; jn != null; jn = jn.next) {\r\n        if (jn.other == other) {\r\n            if (jn.joint.getCollideConnected() == false) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ImageButton.updateImage",
	"Comment": "updates the image with the appropriate drawable from the style before it is drawn.",
	"Method": "void updateImage(){\r\n    Drawable drawable = null;\r\n    if (isDisabled() && style.imageDisabled != null)\r\n        drawable = style.imageDisabled;\r\n    else if (isPressed() && style.imageDown != null)\r\n        drawable = style.imageDown;\r\n    else if (isChecked && style.imageChecked != null)\r\n        drawable = (style.imageCheckedOver != null && isOver()) ? style.imageCheckedOver : style.imageChecked;\r\n    else if (isOver() && style.imageOver != null)\r\n        drawable = style.imageOver;\r\n    else if (style.imageUp != null)\r\n        drawable = style.imageUp;\r\n    image.setDrawable(drawable);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Tree.drawBackground",
	"Comment": "called to draw the background. default implementation draws the style background drawable.",
	"Method": "void drawBackground(Batch batch,float parentAlpha){\r\n    if (style.background != null) {\r\n        Color color = getColor();\r\n        batch.setColor(color.r, color.g, color.b, color.a * parentAlpha);\r\n        style.background.draw(batch, getX(), getY(), getWidth(), getHeight());\r\n    }\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.setCompoundDrawablePadding",
	"Comment": "sets the size of the padding between the compound drawables andthe text.",
	"Method": "void setCompoundDrawablePadding(int pad){\r\n    mInputView.setCompoundDrawablePadding(pad);\r\n    if (mDividerCompoundPadding) {\r\n        mDivider.setPadding(mInputView.getTotalPaddingLeft(), mInputView.getTotalPaddingRight());\r\n        if (mLabelEnable)\r\n            mLabelView.setPadding(mDivider.getPaddingLeft(), mLabelView.getPaddingTop(), mDivider.getPaddingRight(), mLabelView.getPaddingBottom());\r\n        if (mSupportMode != SUPPORT_MODE_NONE)\r\n            mSupportView.setPadding(mDivider.getPaddingLeft(), mSupportView.getPaddingTop(), mDivider.getPaddingRight(), mSupportView.getPaddingBottom());\r\n    }\r\n}"
}, {
	"Path": "java.nio.ByteBuffer.array",
	"Comment": "returns the byte array which this buffer is based on, if there is one.",
	"Method": "byte[] array(){\r\n    return protectedArray();\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.contacts.Contact.getManifold",
	"Comment": "get the contact manifold. do not set the point count to zero. instead call disable.",
	"Method": "Manifold getManifold(){\r\n    return m_manifold;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.iosrobovm.IOSInput.setKeyboardCloseOnReturnKey",
	"Comment": "set the keyboard to close when the uitextfield return key is pressed",
	"Method": "void setKeyboardCloseOnReturnKey(boolean shouldClose){\r\n    keyboardCloseOnReturn = shouldClose;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.getWorldPoint",
	"Comment": "get the world coordinates of a point given the local coordinates.",
	"Method": "Vec2 getWorldPoint(Vec2 localPoint){\r\n    Vec2 v = new Vec2();\r\n    getWorldPointToOut(localPoint, v);\r\n    return v;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.setFromMatrix",
	"Comment": "sets the quaternion from the given rotation matrix, which must not contain scaling.",
	"Method": "Quaternion setFromMatrix(boolean normalizeAxes,Matrix4 matrix,Quaternion setFromMatrix,Matrix4 matrix,Quaternion setFromMatrix,boolean normalizeAxes,Matrix3 matrix,Quaternion setFromMatrix,Matrix3 matrix){\r\n    return setFromMatrix(false, matrix);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Color.abgr8888ToColor",
	"Comment": "sets the color components using the specified float value in the format abgb8888.",
	"Method": "void abgr8888ToColor(Color color,float value){\r\n    int c = NumberUtils.floatToIntColor(value);\r\n    color.a = ((c & 0xff000000) >>> 24) / 255f;\r\n    color.b = ((c & 0x00ff0000) >>> 16) / 255f;\r\n    color.g = ((c & 0x0000ff00) >>> 8) / 255f;\r\n    color.r = ((c & 0x000000ff)) / 255f;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.PolygonSprite.translateY",
	"Comment": "sets the y position relative to the current position where the sprite will be drawn. if origin, rotation, or scale are\tchanged, it is slightly more efficient to translate after those operations.",
	"Method": "void translateY(float yAmount){\r\n    y += yAmount;\r\n    if (dirty)\r\n        return;\r\n    final float[] vertices = this.vertices;\r\n    for (int i = 1; i < vertices.length; i += Sprite.VERTEX_SIZE) vertices[i] += yAmount;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.PolygonSprite.translateX",
	"Comment": "sets the x position relative to the current position where the sprite will be drawn. if origin, rotation, or scale are\tchanged, it is slightly more efficient to translate after those operations.",
	"Method": "void translateX(float xAmount){\r\n    this.x += xAmount;\r\n    if (dirty)\r\n        return;\r\n    final float[] vertices = this.vertices;\r\n    for (int i = 0; i < vertices.length; i += Sprite.VERTEX_SIZE) vertices[i] += xAmount;\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.MaterialCalendarView.dispatchOnRangeSelected",
	"Comment": "dispatch a range of days to a range listener, if set, ordered chronologically.",
	"Method": "void dispatchOnRangeSelected(List<CalendarDay> days){\r\n    if (rangeListener != null) {\r\n        rangeListener.onRangeSelected(MaterialCalendarView.this, days);\r\n    }\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.setRawInputType",
	"Comment": "directly change the content type integer of the text view, withoutmodifying any other state.",
	"Method": "void setRawInputType(int type){\r\n    mInputView.setRawInputType(type);\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect.setBlurKernelSize",
	"Comment": "sets how many neighboring pixels are used to blur the shadow. set to 0 for no blur.",
	"Method": "void setBlurKernelSize(int blurKernelSize){\r\n    this.blurKernelSize = blurKernelSize;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tiledmappacker.TiledMapPacker.processSubdirectories",
	"Comment": "looks for subdirectories inside parenthandle, processes maps in subdirectory, repeat.",
	"Method": "void processSubdirectories(FileHandle currentDir,Settings texturePackerSettings){\r\n    File parentPath = new File(currentDir.path());\r\n    File[] directories = parentPath.listFiles(new DirFilter());\r\n    for (File directory : directories) {\r\n        currentDir = new FileHandle(directory.getCanonicalPath());\r\n        File[] mapFilesInCurrentDir = directory.listFiles(new TmxFilter());\r\n        for (File mapFile : mapFilesInCurrentDir) {\r\n            processSingleMap(mapFile, currentDir, texturePackerSettings);\r\n        }\r\n        processSubdirectories(currentDir, texturePackerSettings);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jna.Memory.getInt",
	"Comment": "indirect the native pointer to malloc space, a lapointer.getint.but this method performs a boundschecks to ensure that the indirection does not cause memory outside themalloced space to be accessed.",
	"Method": "int getInt(long offset){\r\n    boundsCheck(offset, 4);\r\n    return super.getInt(offset);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.ConvexHull.sortWithIndices",
	"Comment": "sorts x,y pairs of values by the x value, then the y value and stores unsorted original indices.",
	"Method": "void sortWithIndices(float[] values,int count,boolean yDown){\r\n    int pointCount = count / 2;\r\n    originalIndices.clear();\r\n    originalIndices.ensureCapacity(pointCount);\r\n    short[] originalIndicesArray = originalIndices.items;\r\n    for (short i = 0; i < pointCount; i++) originalIndicesArray[i] = i;\r\n    int lower = 0;\r\n    int upper = count - 1;\r\n    IntArray stack = quicksortStack;\r\n    stack.add(lower);\r\n    stack.add(upper - 1);\r\n    while (stack.size > 0) {\r\n        upper = stack.pop();\r\n        lower = stack.pop();\r\n        if (upper <= lower)\r\n            continue;\r\n        int i = quicksortPartitionWithIndices(values, lower, upper, yDown, originalIndicesArray);\r\n        if (i - lower > upper - i) {\r\n            stack.add(lower);\r\n            stack.add(i - 2);\r\n        }\r\n        stack.add(i + 2);\r\n        stack.add(upper);\r\n        if (upper - i >= i - lower) {\r\n            stack.add(lower);\r\n            stack.add(i - 2);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ComparableTimSort.ensureCapacity",
	"Comment": "ensures that the external array tmp has at least the specified number of elements, increasing its size if necessary. the\tsize increases exponentially to ensure amortized linear time complexity.",
	"Method": "Object[] ensureCapacity(int minCapacity){\r\n    tmpCount = Math.max(tmpCount, minCapacity);\r\n    if (tmp.length < minCapacity) {\r\n        int newSize = minCapacity;\r\n        newSize |= newSize >> 1;\r\n        newSize |= newSize >> 2;\r\n        newSize |= newSize >> 4;\r\n        newSize |= newSize >> 8;\r\n        newSize |= newSize >> 16;\r\n        newSize++;\r\n        if (newSize < 0)\r\n            newSize = minCapacity;\r\n        else\r\n            newSize = Math.min(newSize, a.length >>> 1);\r\n        Object[] newArray = new Object[newSize];\r\n        tmp = newArray;\r\n    }\r\n    return tmp;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.getAngleAroundRad",
	"Comment": "get the angle in radians of the rotation around the specified axis. the axis must be normalized.",
	"Method": "float getAngleAroundRad(float axisX,float axisY,float axisZ,float getAngleAroundRad,Vector3 axis){\r\n    return getAngleAroundRad(axis.x, axis.y, axis.z);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntMap.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "void ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded >= threshold)\r\n        resize(MathUtils.nextPowerOfTwo((int) Math.ceil(sizeNeeded / loadFactor)));\r\n}"
}, {
	"Path": "lombok.javac.handlers.JavacHandlerUtil.annotationTypeMatches",
	"Comment": "checks if the annotation ast node provided is likely to be an instance of the provided annotation type.",
	"Method": "boolean annotationTypeMatches(Class<? extends Annotation> type,JavacNode node,boolean annotationTypeMatches,String type,JavacNode node){\r\n    if (node.getKind() != Kind.ANNOTATION)\r\n        return false;\r\n    return typeMatches(type, node, ((JCAnnotation) node.get()).annotationType);\r\n}"
}, {
	"Path": "com.codahale.metrics.MetricRegistry.name",
	"Comment": "concatenates a class name and elements to form a dotted name, eliding any null values orempty strings.",
	"Method": "String name(String name,String names,String name,Class<?> klass,String names){\r\n    return name(klass.getName(), names);\r\n}"
}, {
	"Path": "com.rey.material.app.DatePickerDialog.onDateChangedListener",
	"Comment": "set the listener will be called when the selected date is changed.",
	"Method": "DatePickerDialog onDateChangedListener(OnDateChangedListener listener){\r\n    mOnDateChangedListener = listener;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData.dispose",
	"Comment": "disposes this indexbufferobject and all its associated opengl resources.",
	"Method": "void dispose(){\r\n    GL20 gl = Gdx.gl20;\r\n    gl.glBindBuffer(GL20.GL_ELEMENT_ARRAY_BUFFER, 0);\r\n    gl.glDeleteBuffer(bufferHandle);\r\n    bufferHandle = 0;\r\n}"
}, {
	"Path": "com.sun.jna.Structure.setStringEncoding",
	"Comment": "set the desired encoding to use when writing string fields to nativememory.",
	"Method": "void setStringEncoding(String encoding){\r\n    this.encoding = encoding;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Frustum.sphereInFrustumWithoutNearFar",
	"Comment": "returns whether the given sphere is in the frustum not checking whether it is behind the near and far clipping plane.",
	"Method": "boolean sphereInFrustumWithoutNearFar(Vector3 center,float radius,boolean sphereInFrustumWithoutNearFar,float x,float y,float z,float radius){\r\n    for (int i = 2; i < 6; i++) if ((planes[i].normal.x * x + planes[i].normal.y * y + planes[i].normal.z * z) < (-radius - planes[i].d))\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "lombok.installer.IdeLocation.canonical",
	"Comment": "returns a full path to the provided file.\treturns the canonical path, unless that is not available, in which case it returns the absolute path.",
	"Method": "String canonical(File p){\r\n    try {\r\n        return p.getCanonicalPath();\r\n    } catch (IOException e) {\r\n        String x = p.getAbsolutePath();\r\n        return x == null ? p.getPath() : x;\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParallelArray.addChannel",
	"Comment": "adds and returns a channel described by the channel descriptor parameter. if a channel with the same id already exists, no\tallocation is performed and that channel is returned. otherwise a new channel is allocated and initialized with the\tinitializer.",
	"Method": "T addChannel(ChannelDescriptor channelDescriptor,T addChannel,ChannelDescriptor channelDescriptor,ChannelInitializer<T> initializer){\r\n    T channel = getChannel(channelDescriptor);\r\n    if (channel == null) {\r\n        channel = allocateChannel(channelDescriptor);\r\n        if (initializer != null)\r\n            initializer.init(channel);\r\n        arrays.add(channel);\r\n    }\r\n    return channel;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.lwjgl3.audio.OggInputStream.init",
	"Comment": "initialise the streams and thread involved in the streaming of ogg data",
	"Method": "void init(){\r\n    initVorbis();\r\n    readPCM();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Sort.instance",
	"Comment": "returns a sort instance for convenience. multiple threads must not use this instance at the same time.",
	"Method": "Sort instance(){\r\n    if (instance == null)\r\n        instance = new Sort();\r\n    return instance;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData.invalidate",
	"Comment": "invalidates the vertexbufferobject so a new opengl buffer handle is created. use this in case of a context loss.",
	"Method": "void invalidate(){\r\n    bufferHandle = createBufferObject();\r\n    isDirty = true;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.getElementsByAttributeValueMatching",
	"Comment": "find elements that have attributes whose values match the supplied regular expression.",
	"Method": "Elements getElementsByAttributeValueMatching(String key,Pattern pattern,Elements getElementsByAttributeValueMatching,String key,String regex){\r\n    Pattern pattern;\r\n    try {\r\n        pattern = Pattern.compile(regex);\r\n    } catch (PatternSyntaxException e) {\r\n        throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\r\n    }\r\n    return getElementsByAttributeValueMatching(key, pattern);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.util.DrawerUIUtils.getDrawerItemBackground",
	"Comment": "helper to create a statelistdrawable for the drawer item background",
	"Method": "StateListDrawable getDrawerItemBackground(int selected_color){\r\n    ColorDrawable clrActive = new ColorDrawable(selected_color);\r\n    StateListDrawable states = new StateListDrawable();\r\n    states.addState(new int[] { android.R.attr.state_selected }, clrActive);\r\n    return states;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Matrix4.setFromEulerAnglesRad",
	"Comment": "sets this matrix to a rotation matrix from the given euler angles.",
	"Method": "Matrix4 setFromEulerAnglesRad(float yaw,float pitch,float roll){\r\n    quat.setEulerAnglesRad(yaw, pitch, roll);\r\n    return set(quat);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.TextureArray.clearAllTextureArrays",
	"Comment": "clears all managed texturearrays. this is an internal method. do not use it!",
	"Method": "void clearAllTextureArrays(Application app){\r\n    managedTextureArrays.remove(app);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.I18NBundle.get",
	"Comment": "gets a string for the given key from this bundle or one of its parents.",
	"Method": "String get(String key){\r\n    String result = properties.get(key);\r\n    if (result == null) {\r\n        if (parent != null)\r\n            result = parent.get(key);\r\n        if (result == null) {\r\n            if (exceptionOnMissingKey)\r\n                throw new MissingResourceException(\"Can't find bundle key \" + key, this.getClass().getName(), key);\r\n            else\r\n                return \"???\" + key + \"???\";\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.getComponentType",
	"Comment": "returns the class representing the component type of an array. if this class does not represent an array class this method returns null.",
	"Method": "Class getComponentType(Class c){\r\n    return c.getComponentType();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Queue.removeValue",
	"Comment": "removes the first instance of the specified value in the queue.",
	"Method": "boolean removeValue(T value,boolean identity){\r\n    int index = indexOf(value, identity);\r\n    if (index == -1)\r\n        return false;\r\n    removeIndex(index);\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.jna.Memory.getShort",
	"Comment": "indirect the native pointer to malloc space, a lapointer.getshort.but this method performs a boundschecks to ensure that the indirection does not cause memory outside themalloced space to be accessed.",
	"Method": "short getShort(long offset){\r\n    boundsCheck(offset, 2);\r\n    return super.getShort(offset);\r\n}"
}, {
	"Path": "lombok.core.AnnotationValues.toFQ",
	"Comment": "credit goes to petr jiricka of sun for highlighting the problems with the earlier version of this method.",
	"Method": "String toFQ(String typeName){\r\n    String prefix = typeName.indexOf('.') > -1 ? typeName.substring(0, typeName.indexOf('.')) : typeName;\r\n    {\r\n        LombokNode<?, ?, ?> n = ast;\r\n        walkThroughCU: while (n != null) {\r\n            if (n.getKind() == Kind.TYPE) {\r\n                String simpleName = n.getName();\r\n                if (prefix.equals(simpleName)) {\r\n                    List<String> outerNames = new ArrayList<String>();\r\n                    while (true) {\r\n                        n = n.up();\r\n                        if (n == null || n.getKind() == Kind.COMPILATION_UNIT)\r\n                            break;\r\n                        if (n.getKind() == Kind.TYPE)\r\n                            outerNames.add(n.getName());\r\n                        break walkThroughCU;\r\n                    }\r\n                    StringBuilder result = new StringBuilder();\r\n                    if (ast.getPackageDeclaration() != null)\r\n                        result.append(ast.getPackageDeclaration());\r\n                    if (result.length() > 0)\r\n                        result.append('.');\r\n                    Collections.reverse(outerNames);\r\n                    for (String outerName : outerNames) result.append(outerName).append('.');\r\n                    result.append(typeName);\r\n                    return result.toString();\r\n                }\r\n            }\r\n            n = n.up();\r\n        }\r\n    }\r\n    {\r\n        if (prefix.equals(typeName)) {\r\n            String fqn = ast.getImportList().getFullyQualifiedNameForSimpleName(typeName);\r\n            if (fqn != null)\r\n                return fqn;\r\n        }\r\n    }\r\n    {\r\n        for (String potential : ast.getImportList().applyNameToStarImports(\"java\", typeName)) {\r\n            try {\r\n                Class<?> c = Class.forName(potential);\r\n                if (c != null)\r\n                    return c.getName();\r\n            } catch (Throwable t) {\r\n            }\r\n        }\r\n    }\r\n    {\r\n        if (typeName.indexOf('.') == -1)\r\n            return inLocalPackage(ast, typeName);\r\n    }\r\n    {\r\n        char firstChar = typeName.charAt(0);\r\n        if (Character.isTitleCase(firstChar) || Character.isUpperCase(firstChar)) {\r\n            return inLocalPackage(ast, typeName);\r\n        }\r\n        return typeName;\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Timer.stop",
	"Comment": "stops the timer, tasks will not be executed and time that passes will not be applied to the task delays.",
	"Method": "void stop(){\r\n    synchronized (threadLock) {\r\n        thread().instances.removeValue(this, true);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Base64Coder.decode",
	"Comment": "decodes a byte array from base64 format. no blanks or line breaks are allowed within the base64 encoded input data.",
	"Method": "byte[] decode(String s,byte[] decode,String s,CharMap inverseCharMap,byte[] decode,char[] in,byte[] inverseCharMap,byte[] decode,char[] in,CharMap inverseCharMap,byte[] decode,char[] in,byte[] decode,char[] in,int iOff,int iLen,CharMap inverseCharMap,byte[] decode,char[] in,int iOff,int iLen,byte[] inverseCharMap){\r\n    if (iLen % 4 != 0) {\r\n        throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n    }\r\n    while (iLen > 0 && in[iOff + iLen - 1] == '=') {\r\n        iLen--;\r\n    }\r\n    int oLen = (iLen * 3) / 4;\r\n    byte[] out = new byte[oLen];\r\n    int ip = iOff;\r\n    int iEnd = iOff + iLen;\r\n    int op = 0;\r\n    while (ip < iEnd) {\r\n        int i0 = in[ip++];\r\n        int i1 = in[ip++];\r\n        int i2 = ip < iEnd ? in[ip++] : 'A';\r\n        int i3 = ip < iEnd ? in[ip++] : 'A';\r\n        if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127) {\r\n            throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n        }\r\n        int b0 = inverseCharMap[i0];\r\n        int b1 = inverseCharMap[i1];\r\n        int b2 = inverseCharMap[i2];\r\n        int b3 = inverseCharMap[i3];\r\n        if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0) {\r\n            throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n        }\r\n        int o0 = (b0 << 2) | (b1 >>> 4);\r\n        int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);\r\n        int o2 = ((b2 & 3) << 6) | b3;\r\n        out[op++] = (byte) o0;\r\n        if (op < oLen) {\r\n            out[op++] = (byte) o1;\r\n        }\r\n        if (op < oLen) {\r\n            out[op++] = (byte) o2;\r\n        }\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.GwtApplication.getNoWebGLSupportWidget",
	"Comment": "override this method to return a custom widget informing the that their browser lacks support of webgl.",
	"Method": "Widget getNoWebGLSupportWidget(){\r\n    return new Label(\"Sorry, your browser doesn't seem to support WebGL\");\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.DayView.setDayFormatterContentDescription",
	"Comment": "set the new content description formatter and reformat the current content description.",
	"Method": "void setDayFormatterContentDescription(DayFormatter formatter){\r\n    this.contentDescriptionFormatter = formatter == null ? this.formatter : formatter;\r\n    setContentDescription(getContentDescriptionLabel());\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper.createGLSurfaceView",
	"Comment": "getholder in created glsurfaceview and glsurfaceviewapi18 instances",
	"Method": "View createGLSurfaceView(AndroidApplicationBase application,ResolutionStrategy resolutionStrategy){\r\n    if (!checkGL20())\r\n        throw new GdxRuntimeException(\"Libgdx requires OpenGL ES 2.0\");\r\n    EGLConfigChooser configChooser = getEglConfigChooser();\r\n    int sdkVersion = android.os.Build.VERSION.SDK_INT;\r\n    if (sdkVersion <= 10 && config.useGLSurfaceView20API18) {\r\n        GLSurfaceView20API18 view = new GLSurfaceView20API18(application.getContext(), resolutionStrategy) {\r\n            @Override\r\n            public SurfaceHolder getHolder() {\r\n                return getSurfaceHolder();\r\n            }\r\n            public void onDestroy() {\r\n                onDetachedFromWindow();\r\n            }\r\n        };\r\n        if (configChooser != null)\r\n            view.setEGLConfigChooser(configChooser);\r\n        else\r\n            view.setEGLConfigChooser(config.r, config.g, config.b, config.a, config.depth, config.stencil);\r\n        view.setRenderer(this);\r\n        return view;\r\n    } else {\r\n        GLSurfaceView20 view = new GLSurfaceView20(application.getContext(), resolutionStrategy) {\r\n            @Override\r\n            public SurfaceHolder getHolder() {\r\n                return getSurfaceHolder();\r\n            }\r\n            public void onDestroy() {\r\n                onDetachedFromWindow();\r\n            }\r\n        };\r\n        if (configChooser != null)\r\n            view.setEGLConfigChooser(configChooser);\r\n        else\r\n            view.setEGLConfigChooser(config.r, config.g, config.b, config.a, config.depth, config.stencil);\r\n        view.setRenderer(this);\r\n        return view;\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper.createGLSurfaceView",
	"Comment": "getholder in created glsurfaceview and glsurfaceviewapi18 instances",
	"Method": "View createGLSurfaceView(AndroidApplicationBase application,ResolutionStrategy resolutionStrategy){\r\n    return getSurfaceHolder();\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper.createGLSurfaceView",
	"Comment": "getholder in created glsurfaceview and glsurfaceviewapi18 instances",
	"Method": "View createGLSurfaceView(AndroidApplicationBase application,ResolutionStrategy resolutionStrategy){\r\n    onDetachedFromWindow();\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper.createGLSurfaceView",
	"Comment": "getholder in created glsurfaceview and glsurfaceviewapi18 instances",
	"Method": "View createGLSurfaceView(AndroidApplicationBase application,ResolutionStrategy resolutionStrategy){\r\n    return getSurfaceHolder();\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper.createGLSurfaceView",
	"Comment": "getholder in created glsurfaceview and glsurfaceviewapi18 instances",
	"Method": "View createGLSurfaceView(AndroidApplicationBase application,ResolutionStrategy resolutionStrategy){\r\n    onDetachedFromWindow();\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.getElementsByAttributeValueNot",
	"Comment": "find elements that either do not have this attribute, or have it with a different value. case insensitive.",
	"Method": "Elements getElementsByAttributeValueNot(String key,String value){\r\n    return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window.focusWindow",
	"Comment": "brings the window to front and sets input focus. the window should already be visible and not iconified.",
	"Method": "void focusWindow(){\r\n    GLFW.glfwFocusWindow(windowHandle);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IdentityMap.shrink",
	"Comment": "reduces the size of the backing arrays to be the specified capacity or less. if the capacity is already less, nothing is\tdone. if the map contains more items than the specified capacity, the next highest power of two capacity is used instead.",
	"Method": "void shrink(int maximumCapacity){\r\n    if (maximumCapacity < 0)\r\n        throw new IllegalArgumentException(\"maximumCapacity must be >= 0: \" + maximumCapacity);\r\n    if (size > maximumCapacity)\r\n        maximumCapacity = size;\r\n    if (capacity <= maximumCapacity)\r\n        return;\r\n    maximumCapacity = MathUtils.nextPowerOfTwo(maximumCapacity);\r\n    resize(maximumCapacity);\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.COM.util.ObjectFactory.getRunningObjectTable",
	"Comment": "coinitialize must be called be fore this method. either explicitly or\timplicitly via other methods.",
	"Method": "IRunningObjectTable getRunningObjectTable(){\r\n    assert COMUtils.comIsInitialized() : \"COM not initialized\";\r\n    final PointerByReference rotPtr = new PointerByReference();\r\n    HRESULT hr = Ole32.INSTANCE.GetRunningObjectTable(new WinDef.DWORD(0), rotPtr);\r\n    COMUtils.checkRC(hr);\r\n    com.sun.jna.platform.win32.COM.RunningObjectTable raw = new com.sun.jna.platform.win32.COM.RunningObjectTable(rotPtr.getValue());\r\n    IRunningObjectTable rot = new RunningObjectTable(raw, this);\r\n    return rot;\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.Kernel32Util.getPrivateProfileString",
	"Comment": "retrieves a string from the specified section in an initialization file.",
	"Method": "String getPrivateProfileString(String lpAppName,String lpKeyName,String lpDefault,String lpFileName){\r\n    final char[] buffer = new char[1024];\r\n    Kernel32.INSTANCE.GetPrivateProfileString(lpAppName, lpKeyName, lpDefault, buffer, new DWORD(buffer.length), lpFileName);\r\n    return Native.toString(buffer);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.addStickyDrawerItems",
	"Comment": "add a initial draweritem or a draweritem array for the stickydrawerfooter",
	"Method": "DrawerBuilder addStickyDrawerItems(IDrawerItem stickyDrawerItems){\r\n    if (this.mStickyDrawerItems == null) {\r\n        this.mStickyDrawerItems = new ArrayList();\r\n    }\r\n    Collections.addAll(this.mStickyDrawerItems, stickyDrawerItems);\r\n    return this;\r\n}"
}, {
	"Path": "java.nio.BufferFactory.newShortBuffer",
	"Comment": "returns a new short buffer based on the specified short array.",
	"Method": "ShortBuffer newShortBuffer(int capacity,ShortBuffer newShortBuffer,short array){\r\n    return new ReadWriteShortArrayBuffer(array);\r\n}"
}, {
	"Path": "com.badlogic.gdx.tests.bullet.OcclusionCullingTest.addRandomOccludee",
	"Comment": "adds an occludee entity of random type at a random place on the ground.",
	"Method": "BulletEntity addRandomOccludee(boolean dynamic){\r\n    BulletEntity entity = world.add(getRandomOccludeeType(dynamic), 0, 0, 0);\r\n    entity.setColor(Color.WHITE);\r\n    float rotationY = rng.nextFloat() * 360f;\r\n    Vector3 position = tmpV1;\r\n    int maxDstX = (int) (GROUND_DIM.x * 0.49f);\r\n    position.x = rng.nextInt(maxDstX) * ((rng.nextBoolean()) ? 1 : -1);\r\n    position.z = rng.nextInt(maxDstX) * ((rng.nextBoolean()) ? 1 : -1);\r\n    position.y = entity.boundingBox.getDimensions(tmpV2).y * 0.5f;\r\n    entity.modelInstance.transform.setToRotation(Vector3.Y, rotationY).setTranslation(position);\r\n    entity.body.setWorldTransform(entity.modelInstance.transform);\r\n    return entity;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData.bind",
	"Comment": "binds this indexbufferobject for rendering with gldrawelements.",
	"Method": "void bind(){\r\n    if (bufferHandle == 0)\r\n        throw new GdxRuntimeException(\"IndexBufferObject cannot be used after it has been disposed.\");\r\n    Gdx.gl20.glBindBuffer(GL20.GL_ELEMENT_ARRAY_BUFFER, bufferHandle);\r\n    if (isDirty) {\r\n        byteBuffer.limit(buffer.limit() * 2);\r\n        Gdx.gl20.glBufferSubData(GL20.GL_ELEMENT_ARRAY_BUFFER, 0, byteBuffer.limit(), byteBuffer);\r\n        isDirty = false;\r\n    }\r\n    isBound = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.isAnnotation",
	"Comment": "determines if the supplied class object represents an annotation type.",
	"Method": "boolean isAnnotation(Class c){\r\n    return c.isAnnotation();\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.BulletBase.takeOwnership",
	"Comment": "take ownership of the native instance, causing the native object to be deleted when this object gets out of scope.",
	"Method": "void takeOwnership(){\r\n    swigCMemOwn = true;\r\n}"
}, {
	"Path": "org.junit.runner.Description.createSuiteDescription",
	"Comment": "create a description named name.generally, you will add children to this description.",
	"Method": "Description createSuiteDescription(String name,Annotation annotations,Description createSuiteDescription,String name,Serializable uniqueId,Annotation annotations,Description createSuiteDescription,Class<?> testClass,Description createSuiteDescription,Class<?> testClass,Annotation annotations){\r\n    return new Description(testClass, testClass.getName(), annotations);\r\n}"
}, {
	"Path": "com.badlogic.gdx.net.HttpParametersUtils.convertHttpParameters",
	"Comment": "useful method to convert a map of key,value pairs to a string to be used as part of a get or post content.",
	"Method": "String convertHttpParameters(Map<String, String> parameters){\r\n    Set<String> keySet = parameters.keySet();\r\n    StringBuilder convertedParameters = new StringBuilder();\r\n    for (String name : keySet) {\r\n        convertedParameters.append(encode(name, defaultEncoding));\r\n        convertedParameters.append(nameValueSeparator);\r\n        convertedParameters.append(encode(parameters.get(name), defaultEncoding));\r\n        convertedParameters.append(parameterSeparator);\r\n    }\r\n    if (convertedParameters.length() > 0)\r\n        convertedParameters.deleteCharAt(convertedParameters.length() - 1);\r\n    return convertedParameters.toString();\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.MiniDrawer.withDrawer",
	"Comment": "provide the drawer which will be used as datasource for the draweritems",
	"Method": "MiniDrawer withDrawer(Drawer drawer){\r\n    this.mDrawer = drawer;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Plane.testPoint",
	"Comment": "returns on which side the given point lies relative to the plane and its normal. planeside.front refers to the side the\tplane normal points to.",
	"Method": "PlaneSide testPoint(Vector3 point,PlaneSide testPoint,float x,float y,float z){\r\n    float dist = normal.dot(x, y, z) + d;\r\n    if (dist == 0)\r\n        return PlaneSide.OnPlane;\r\n    else if (dist < 0)\r\n        return PlaneSide.Back;\r\n    else\r\n        return PlaneSide.Front;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.MiniDrawer.withInnerShadow",
	"Comment": "set to true if you want to show the innershadow on the minidrawer",
	"Method": "MiniDrawer withInnerShadow(boolean innerShadow){\r\n    this.mInnerShadow = innerShadow;\r\n    return this;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.step",
	"Comment": "take a time step. this performs collision detection, integration, and constraint solution.",
	"Method": "void step(float dt,int velocityIterations,int positionIterations){\r\n    stepTimer.reset();\r\n    tempTimer.reset();\r\n    if ((m_flags & NEW_FIXTURE) == NEW_FIXTURE) {\r\n        m_contactManager.findNewContacts();\r\n        m_flags &= ~NEW_FIXTURE;\r\n    }\r\n    m_flags |= LOCKED;\r\n    step.dt = dt;\r\n    step.velocityIterations = velocityIterations;\r\n    step.positionIterations = positionIterations;\r\n    if (dt > 0.0f) {\r\n        step.inv_dt = 1.0f / dt;\r\n    } else {\r\n        step.inv_dt = 0.0f;\r\n    }\r\n    step.dtRatio = m_inv_dt0 * dt;\r\n    step.warmStarting = m_warmStarting;\r\n    m_profile.stepInit.record(tempTimer.getMilliseconds());\r\n    tempTimer.reset();\r\n    m_contactManager.collide();\r\n    m_profile.collide.record(tempTimer.getMilliseconds());\r\n    if (m_stepComplete && step.dt > 0.0f) {\r\n        tempTimer.reset();\r\n        m_particleSystem.solve(step);\r\n        m_profile.solveParticleSystem.record(tempTimer.getMilliseconds());\r\n        tempTimer.reset();\r\n        solve(step);\r\n        m_profile.solve.record(tempTimer.getMilliseconds());\r\n    }\r\n    if (m_continuousPhysics && step.dt > 0.0f) {\r\n        tempTimer.reset();\r\n        solveTOI(step);\r\n        m_profile.solveTOI.record(tempTimer.getMilliseconds());\r\n    }\r\n    if (step.dt > 0.0f) {\r\n        m_inv_dt0 = step.inv_dt;\r\n    }\r\n    if ((m_flags & CLEAR_FORCES) == CLEAR_FORCES) {\r\n        clearForces();\r\n    }\r\n    m_flags &= ~LOCKED;\r\n    m_profile.step.record(stepTimer.getMilliseconds());\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.AndroidLiveWallpaperService.getSurfaceHolder",
	"Comment": "getter for surfaceholder object, surface holder is required to restore gl context in glsurfaceview",
	"Method": "SurfaceHolder getSurfaceHolder(){\r\n    if (DEBUG)\r\n        Log.d(TAG, \" > AndroidLiveWallpaperService - getSurfaceHolder()\");\r\n    synchronized (sync) {\r\n        if (linkedEngine == null)\r\n            return null;\r\n        else\r\n            return linkedEngine.getSurfaceHolder();\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Fixture.getUserData",
	"Comment": "get the user data that was assigned in the fixture definition. use this to store yourapplication specific data.",
	"Method": "Object getUserData(){\r\n    return m_userData;\r\n}"
}, {
	"Path": "org.jsoup.helper.DataUtil.readToByteBuffer",
	"Comment": "read the input stream into a byte buffer. to deal with slow input streams, you may interrupt the thread thismethod is executing on. the data read until being interrupted will be available.",
	"Method": "ByteBuffer readToByteBuffer(InputStream inStream,int maxSize){\r\n    Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\r\n    final ConstrainableInputStream input = ConstrainableInputStream.wrap(inStream, bufferSize, maxSize);\r\n    return input.readToByteBuffer(maxSize);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem.begin",
	"Comment": "must be called one time per frame before any particle effect drawing operation will occur.",
	"Method": "void begin(){\r\n    for (ParticleBatch<?> batch : batches) batch.begin();\r\n}"
}, {
	"Path": "com.sun.jna.platform.WindowUtilsTest.assertPixelColor",
	"Comment": "verfies that the specified pixel within the image has the expected color component values.",
	"Method": "void assertPixelColor(BufferedImage img,int x,int y,int expectedRed,int expectedGreen,int expectedBlue){\r\n    int rgb = img.getRGB(x, y);\r\n    int r = (rgb >> 16) & 0xFF;\r\n    int g = (rgb >> 8) & 0xFF;\r\n    int b = (rgb & 0xFF);\r\n    assertEquals(expectedRed, r);\r\n    assertEquals(expectedGreen, g);\r\n    assertEquals(expectedBlue, b);\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar.setMinProgress",
	"Comment": "set the minimum progress. if the minimum progress is more than the current progress, the current progress is adjusted to be\twithin the new range.",
	"Method": "void setMinProgress(double minProgress){\r\n    this.minProgress = minProgress;\r\n    curProgress = Math.max(curProgress, minProgress);\r\n    resetProgress();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.FloatArray.truncate",
	"Comment": "reduces the size of the array to the specified size. if the array is already smaller than the specified size, no action is",
	"Method": "void truncate(int newSize){\r\n    if (size > newSize)\r\n        size = newSize;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Actor.setParent",
	"Comment": "called by the framework when an actor is added to or removed from a group.",
	"Method": "void setParent(Group parent){\r\n    this.parent = parent;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withRootView",
	"Comment": "sets the rootview which will host the drawerlayoutthe content of this view will be extracted and added as the new content inside the drawerlayout",
	"Method": "DrawerBuilder withRootView(ViewGroup rootView,DrawerBuilder withRootView,int rootViewRes){\r\n    if (mActivity == null) {\r\n        throw new RuntimeException(\"please pass an activity first to use this call\");\r\n    }\r\n    return withRootView((ViewGroup) mActivity.findViewById(rootViewRes));\r\n}"
}, {
	"Path": "com.badlogic.gdx.tests.g3d.voxel.VoxelChunk.calculateVertices",
	"Comment": "creates a mesh out of the chunk, returning the number of indices produced",
	"Method": "int calculateVertices(float[] vertices){\r\n    int i = 0;\r\n    int vertexOffset = 0;\r\n    for (int y = 0; y < height; y++) {\r\n        for (int z = 0; z < depth; z++) {\r\n            for (int x = 0; x < width; x++, i++) {\r\n                byte voxel = voxels[i];\r\n                if (voxel == 0)\r\n                    continue;\r\n                if (y < height - 1) {\r\n                    if (voxels[i + topOffset] == 0)\r\n                        vertexOffset = createTop(offset, x, y, z, vertices, vertexOffset);\r\n                } else {\r\n                    vertexOffset = createTop(offset, x, y, z, vertices, vertexOffset);\r\n                }\r\n                if (y > 0) {\r\n                    if (voxels[i + bottomOffset] == 0)\r\n                        vertexOffset = createBottom(offset, x, y, z, vertices, vertexOffset);\r\n                } else {\r\n                    vertexOffset = createBottom(offset, x, y, z, vertices, vertexOffset);\r\n                }\r\n                if (x > 0) {\r\n                    if (voxels[i + leftOffset] == 0)\r\n                        vertexOffset = createLeft(offset, x, y, z, vertices, vertexOffset);\r\n                } else {\r\n                    vertexOffset = createLeft(offset, x, y, z, vertices, vertexOffset);\r\n                }\r\n                if (x < width - 1) {\r\n                    if (voxels[i + rightOffset] == 0)\r\n                        vertexOffset = createRight(offset, x, y, z, vertices, vertexOffset);\r\n                } else {\r\n                    vertexOffset = createRight(offset, x, y, z, vertices, vertexOffset);\r\n                }\r\n                if (z > 0) {\r\n                    if (voxels[i + frontOffset] == 0)\r\n                        vertexOffset = createFront(offset, x, y, z, vertices, vertexOffset);\r\n                } else {\r\n                    vertexOffset = createFront(offset, x, y, z, vertices, vertexOffset);\r\n                }\r\n                if (z < depth - 1) {\r\n                    if (voxels[i + backOffset] == 0)\r\n                        vertexOffset = createBack(offset, x, y, z, vertices, vertexOffset);\r\n                } else {\r\n                    vertexOffset = createBack(offset, x, y, z, vertices, vertexOffset);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return vertexOffset / VERTEX_SIZE;\r\n}"
}, {
	"Path": "org.junit.runners.model.FrameworkMember.handlePossibleShadowedMember",
	"Comment": "check if this member is shadowed by any of the given members. if itis, the other member is removed.",
	"Method": "T handlePossibleShadowedMember(List<T> members){\r\n    for (int i = members.size() - 1; i >= 0; i--) {\r\n        T otherMember = members.get(i);\r\n        if (isShadowedBy(otherMember)) {\r\n            if (otherMember.isBridgeMethod()) {\r\n                members.remove(i);\r\n                return otherMember;\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n    return self();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ShortArray.truncate",
	"Comment": "reduces the size of the array to the specified size. if the array is already smaller than the specified size, no action is",
	"Method": "void truncate(int newSize){\r\n    if (size > newSize)\r\n        size = newSize;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Bits.containsAll",
	"Comment": "returns true if this bit set is a super set of the specified set, i.e. it has all bits set to true that are also set to true\tin the specified bitset.",
	"Method": "boolean containsAll(Bits other){\r\n    long[] bits = this.bits;\r\n    long[] otherBits = other.bits;\r\n    int otherBitsLength = otherBits.length;\r\n    int bitsLength = bits.length;\r\n    for (int i = bitsLength; i < otherBitsLength; i++) {\r\n        if (otherBits[i] != 0) {\r\n            return false;\r\n        }\r\n    }\r\n    for (int i = Math.min(bitsLength, otherBitsLength) - 1; i >= 0; i--) {\r\n        if ((bits[i] & otherBits[i]) != otherBits[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.MiniDrawer.withEnableProfileClick",
	"Comment": "set to false if you do not want the profile image to toggle to the normal drawers profile selection",
	"Method": "MiniDrawer withEnableProfileClick(boolean enableProfileClick){\r\n    this.mEnableProfileClick = enableProfileClick;\r\n    return this;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.Drawer.updateIcon",
	"Comment": "update the name for a specific draweritemidentified by its id",
	"Method": "void updateIcon(long identifier,ImageHolder image){\r\n    IDrawerItem drawerItem = getDrawerItem(identifier);\r\n    if (drawerItem instanceof Iconable) {\r\n        Iconable pdi = (Iconable) drawerItem;\r\n        pdi.withIcon(image);\r\n        updateItem((IDrawerItem) pdi);\r\n    }\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getExtendedPaddingBottom",
	"Comment": "returns the extended bottom padding of the view, including both thebottom drawable if any and any extra space to keep more than maxlinesof text from showing.it is only valid to call this after measuring.",
	"Method": "int getExtendedPaddingBottom(){\r\n    return mInputView.getExtendedPaddingBottom();\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.loadGlyphs",
	"Comment": "loads up to the specified number of queued glyphs to the backing textures. this is typically called from the game loop to\tload glyphs on the fly that were requested for display but have not yet been loaded.",
	"Method": "boolean loadGlyphs(boolean loadGlyphs,int maxGlyphsToLoad){\r\n    if (queuedGlyphs.isEmpty())\r\n        return false;\r\n    if (effects.isEmpty())\r\n        throw new IllegalStateException(\"The UnicodeFont must have at least one effect before any glyphs can be loaded.\");\r\n    for (Iterator iter = queuedGlyphs.iterator(); iter.hasNext(); ) {\r\n        Glyph glyph = (Glyph) iter.next();\r\n        int codePoint = glyph.getCodePoint();\r\n        if (glyph.isMissing()) {\r\n            if (missingGlyph != null) {\r\n                if (glyph != missingGlyph)\r\n                    iter.remove();\r\n                continue;\r\n            }\r\n            missingGlyph = glyph;\r\n        }\r\n    }\r\n    Collections.sort(queuedGlyphs, heightComparator);\r\n    for (Iterator iter = glyphPages.iterator(); iter.hasNext(); ) {\r\n        GlyphPage glyphPage = (GlyphPage) iter.next();\r\n        maxGlyphsToLoad -= glyphPage.loadGlyphs(queuedGlyphs, maxGlyphsToLoad);\r\n        if (maxGlyphsToLoad == 0 || queuedGlyphs.isEmpty())\r\n            return true;\r\n    }\r\n    while (!queuedGlyphs.isEmpty()) {\r\n        GlyphPage glyphPage = new GlyphPage(this, glyphPageWidth, glyphPageHeight);\r\n        glyphPages.add(glyphPage);\r\n        maxGlyphsToLoad -= glyphPage.loadGlyphs(queuedGlyphs, maxGlyphsToLoad);\r\n        if (maxGlyphsToLoad == 0)\r\n            return true;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup.setMinCheckCount",
	"Comment": "sets the minimum number of buttons that must be checked. default is 1.",
	"Method": "void setMinCheckCount(int minCheckCount){\r\n    this.minCheckCount = minCheckCount;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Vector3.traMul",
	"Comment": "multiplies the vector by the transpose of the given matrix.",
	"Method": "Vector3 traMul(Matrix4 matrix,Vector3 traMul,Matrix3 matrix){\r\n    final float[] l_mat = matrix.val;\r\n    return set(x * l_mat[Matrix3.M00] + y * l_mat[Matrix3.M10] + z * l_mat[Matrix3.M20], x * l_mat[Matrix3.M01] + y * l_mat[Matrix3.M11] + z * l_mat[Matrix3.M21], x * l_mat[Matrix3.M02] + y * l_mat[Matrix3.M12] + z * l_mat[Matrix3.M22]);\r\n}"
}, {
	"Path": "java.util.StringTokenizer.countTokens",
	"Comment": "returns the number of unprocessed tokens remaining in the string.",
	"Method": "int countTokens(){\r\n    int count = 0;\r\n    boolean inToken = false;\r\n    for (int i = position, length = string.length(); i < length; i++) {\r\n        if (delimiters.indexOf(string.charAt(i), 0) >= 0) {\r\n            if (returnDelimiters)\r\n                count++;\r\n            if (inToken) {\r\n                count++;\r\n                inToken = false;\r\n            }\r\n        } else {\r\n            inToken = true;\r\n        }\r\n    }\r\n    if (inToken)\r\n        count++;\r\n    return count;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.UBJsonWriter.value",
	"Comment": "appends the object to the stream, if it is a known value type. this is a convenience method that calls through to the\tappropriate value method.",
	"Method": "UBJsonWriter value(byte value,UBJsonWriter value,short value,UBJsonWriter value,int value,UBJsonWriter value,long value,UBJsonWriter value,float value,UBJsonWriter value,double value,UBJsonWriter value,boolean value,UBJsonWriter value,char value,UBJsonWriter value,String value,UBJsonWriter value,byte[] values,UBJsonWriter value,short[] values,UBJsonWriter value,int[] values,UBJsonWriter value,long[] values,UBJsonWriter value,float[] values,UBJsonWriter value,double[] values,UBJsonWriter value,boolean[] values,UBJsonWriter value,char[] values,UBJsonWriter value,String[] values,UBJsonWriter value,JsonValue value,UBJsonWriter value,Object object,UBJsonWriter value){\r\n    checkName();\r\n    out.writeByte('Z');\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ArrayReflection.get",
	"Comment": "returns the value of the indexed component in the supplied array.",
	"Method": "Object get(Object array,int index){\r\n    return java.lang.reflect.Array.get(array, index);\r\n}"
}, {
	"Path": "org.jsoup.internal.ConstrainableInputStream.wrap",
	"Comment": "if this inputstream is not already a constrainableinputstream, let it be one.",
	"Method": "ConstrainableInputStream wrap(InputStream in,int bufferSize,int maxSize){\r\n    return in instanceof ConstrainableInputStream ? (ConstrainableInputStream) in : new ConstrainableInputStream(in, bufferSize, maxSize);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.isAbstract",
	"Comment": "determines if the supplied class object represents an abstract type.",
	"Method": "boolean isAbstract(Class c){\r\n    return Modifier.isAbstract(c.getModifiers());\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.LongArray.removeRange",
	"Comment": "removes the items between the specified indices, inclusive.",
	"Method": "void removeRange(int start,int end){\r\n    if (end >= size)\r\n        throw new IndexOutOfBoundsException(\"end can't be >= size: \" + end + \" >= \" + size);\r\n    if (start > end)\r\n        throw new IndexOutOfBoundsException(\"start can't be > end: \" + start + \" > \" + end);\r\n    long[] items = this.items;\r\n    int count = end - start + 1;\r\n    if (ordered)\r\n        System.arraycopy(items, start + count, items, start, size - (start + count));\r\n    else {\r\n        int lastIndex = this.size - 1;\r\n        for (int i = 0; i < count; i++) items[start + i] = items[lastIndex - i];\r\n    }\r\n    size -= count;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.BulletBase.releaseOwnership",
	"Comment": "release ownership of the native instance, causing the native object not to be deleted when this object gets out of scope.",
	"Method": "void releaseOwnership(){\r\n    swigCMemOwn = false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Cell.getComputedPadLeft",
	"Comment": "the actual amount of combined padding and spacing from the last layout.",
	"Method": "float getComputedPadLeft(){\r\n    return computedPadLeft;\r\n}"
}, {
	"Path": "com.sun.jna.Pointer.readArray",
	"Comment": "read memory starting at offset into the array with element type cls.",
	"Method": "void readArray(long offset,Object o,Class<?> cls){\r\n    int length = 0;\r\n    length = Array.getLength(o);\r\n    Object result = o;\r\n    if (cls == byte.class) {\r\n        read(offset, (byte[]) result, 0, length);\r\n    } else if (cls == short.class) {\r\n        read(offset, (short[]) result, 0, length);\r\n    } else if (cls == char.class) {\r\n        read(offset, (char[]) result, 0, length);\r\n    } else if (cls == int.class) {\r\n        read(offset, (int[]) result, 0, length);\r\n    } else if (cls == long.class) {\r\n        read(offset, (long[]) result, 0, length);\r\n    } else if (cls == float.class) {\r\n        read(offset, (float[]) result, 0, length);\r\n    } else if (cls == double.class) {\r\n        read(offset, (double[]) result, 0, length);\r\n    } else if (Pointer.class.isAssignableFrom(cls)) {\r\n        read(offset, (Pointer[]) result, 0, length);\r\n    } else if (Structure.class.isAssignableFrom(cls)) {\r\n        Structure[] sarray = (Structure[]) result;\r\n        if (Structure.ByReference.class.isAssignableFrom(cls)) {\r\n            Pointer[] parray = getPointerArray(offset, sarray.length);\r\n            for (int i = 0; i < sarray.length; i++) {\r\n                sarray[i] = Structure.updateStructureByReference((Class<Structure>) cls, sarray[i], parray[i]);\r\n            }\r\n        } else {\r\n            Structure first = sarray[0];\r\n            if (first == null) {\r\n                first = Structure.newInstance((Class<Structure>) cls, share(offset));\r\n                first.conditionalAutoRead();\r\n                sarray[0] = first;\r\n            } else {\r\n                first.useMemory(this, (int) offset, true);\r\n                first.read();\r\n            }\r\n            Structure[] tmp = first.toArray(sarray.length);\r\n            for (int i = 1; i < sarray.length; i++) {\r\n                if (sarray[i] == null) {\r\n                    sarray[i] = tmp[i];\r\n                } else {\r\n                    sarray[i].useMemory(this, (int) (offset + i * sarray[i].size()), true);\r\n                    sarray[i].read();\r\n                }\r\n            }\r\n        }\r\n    } else if (NativeMapped.class.isAssignableFrom(cls)) {\r\n        NativeMapped[] array = (NativeMapped[]) result;\r\n        NativeMappedConverter tc = NativeMappedConverter.getInstance(cls);\r\n        int size = Native.getNativeSize(result.getClass(), result) / array.length;\r\n        for (int i = 0; i < array.length; i++) {\r\n            Object value = getValue(offset + size * i, tc.nativeType(), array[i]);\r\n            array[i] = (NativeMapped) tc.fromNative(value, new FromNativeContext(cls));\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException(\"Reading array of \" + cls + \" from memory not supported\");\r\n    }\r\n}"
}, {
	"Path": "com.codahale.metrics.EWMA.fifteenMinuteEWMA",
	"Comment": "creates a new ewma which is equivalent to the unix fifteen minute load average and whichexpects to be ticked every 5 seconds.",
	"Method": "EWMA fifteenMinuteEWMA(){\r\n    return new EWMA(M15_ALPHA, INTERVAL, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.WevtapiUtil.EvtGetExtendedStatus",
	"Comment": "gets a text message that contains the extended error information for the current error.",
	"Method": "String EvtGetExtendedStatus(){\r\n    int errorCode;\r\n    IntByReference buffUsed = new IntByReference();\r\n    errorCode = Wevtapi.INSTANCE.EvtGetExtendedStatus(0, null, buffUsed);\r\n    if (errorCode != WinError.ERROR_SUCCESS && errorCode != WinError.ERROR_INSUFFICIENT_BUFFER) {\r\n        throw new Win32Exception(errorCode);\r\n    }\r\n    if (buffUsed.getValue() == 0) {\r\n        return \"\";\r\n    }\r\n    char[] mem = new char[buffUsed.getValue()];\r\n    errorCode = Wevtapi.INSTANCE.EvtGetExtendedStatus(mem.length, mem, buffUsed);\r\n    if (errorCode != WinError.ERROR_SUCCESS) {\r\n        throw new Win32Exception(errorCode);\r\n    }\r\n    return Native.toString(mem);\r\n}"
}, {
	"Path": "lombok.bytecode.ClassFileMetaData.usesMethod",
	"Comment": "checks if the constant pool contains a reference to a given method.",
	"Method": "boolean usesMethod(String className,String methodName,boolean usesMethod,String className,String methodName,String descriptor){\r\n    int classIndex = findClass(className);\r\n    if (classIndex == NOT_FOUND)\r\n        return false;\r\n    int nameAndTypeIndex = findNameAndType(methodName, descriptor);\r\n    if (nameAndTypeIndex == NOT_FOUND)\r\n        return false;\r\n    for (int i = 1; i < maxPoolSize; i++) {\r\n        if (isMethod(i) && readValue(offsets[i]) == classIndex && readValue(offsets[i] + 2) == nameAndTypeIndex)\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jna.Structure.newInstance",
	"Comment": "create a new structure instance of the given type, initialized withthe given memory.",
	"Method": "T newInstance(Class<T> type,long init,T newInstance,Class<T> type,Pointer init,T newInstance,Class<T> type){\r\n    T s = Klass.newInstance(type);\r\n    if (s instanceof ByValue) {\r\n        s.allocateMemory();\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "com.rey.material.widget.SnackBar.actionId",
	"Comment": "set the actionid of this snackbar. used to determine the current action of this snackbar.",
	"Method": "SnackBar actionId(int id){\r\n    mActionId = id;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.effects.EffectUtil.optionValue",
	"Comment": "returns a value that represents a fixed number of options. all options are strings.",
	"Method": "Value optionValue(String name,String currentValue,String[][] options,String description){\r\n    return new DefaultValue(name, currentValue.toString()) {\r\n        public void showDialog() {\r\n            int selectedIndex = -1;\r\n            DefaultComboBoxModel model = new DefaultComboBoxModel();\r\n            for (int i = 0; i < options.length; i++) {\r\n                model.addElement(options[i][0]);\r\n                if (getValue(i).equals(currentValue))\r\n                    selectedIndex = i;\r\n            }\r\n            JComboBox comboBox = new JComboBox(model);\r\n            comboBox.setSelectedIndex(selectedIndex);\r\n            if (showValueDialog(comboBox, description))\r\n                value = getValue(comboBox.getSelectedIndex());\r\n        }\r\n        private String getValue(int i) {\r\n            if (options[i].length == 1)\r\n                return options[i][0];\r\n            return options[i][1];\r\n        }\r\n        public String toString() {\r\n            for (int i = 0; i < options.length; i++) if (getValue(i).equals(value))\r\n                return options[i][0].toString();\r\n            return \"\";\r\n        }\r\n        public Object getObject() {\r\n            return value;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.effects.EffectUtil.optionValue",
	"Comment": "returns a value that represents a fixed number of options. all options are strings.",
	"Method": "Value optionValue(String name,String currentValue,String[][] options,String description){\r\n    int selectedIndex = -1;\r\n    DefaultComboBoxModel model = new DefaultComboBoxModel();\r\n    for (int i = 0; i < options.length; i++) {\r\n        model.addElement(options[i][0]);\r\n        if (getValue(i).equals(currentValue))\r\n            selectedIndex = i;\r\n    }\r\n    JComboBox comboBox = new JComboBox(model);\r\n    comboBox.setSelectedIndex(selectedIndex);\r\n    if (showValueDialog(comboBox, description))\r\n        value = getValue(comboBox.getSelectedIndex());\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.effects.EffectUtil.optionValue",
	"Comment": "returns a value that represents a fixed number of options. all options are strings.",
	"Method": "Value optionValue(String name,String currentValue,String[][] options,String description){\r\n    if (options[i].length == 1)\r\n        return options[i][0];\r\n    return options[i][1];\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.effects.EffectUtil.optionValue",
	"Comment": "returns a value that represents a fixed number of options. all options are strings.",
	"Method": "Value optionValue(String name,String currentValue,String[][] options,String description){\r\n    for (int i = 0; i < options.length; i++) if (getValue(i).equals(value))\r\n        return options[i][0].toString();\r\n    return \"\";\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.effects.EffectUtil.optionValue",
	"Comment": "returns a value that represents a fixed number of options. all options are strings.",
	"Method": "Value optionValue(String name,String currentValue,String[][] options,String description){\r\n    return value;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.Drawer.getSlider",
	"Comment": "get the slider layout of the current drawer.this is the layout containing the listview",
	"Method": "ScrimInsetsRelativeLayout getSlider(){\r\n    return mDrawerBuilder.mSliderLayout;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.length",
	"Comment": "returns the length, in characters, of the text managed by this textview",
	"Method": "int length(){\r\n    return mInputView.length();\r\n}"
}, {
	"Path": "com.badlogic.gdx.assets.AssetManager.getLoader",
	"Comment": "returns the loader for the given type and the specified filename. if no loader exists for the specific filename, the\tdefault loader for that type is returned.",
	"Method": "AssetLoader getLoader(Class<T> type,AssetLoader getLoader,Class<T> type,String fileName){\r\n    final ObjectMap<String, AssetLoader> loaders = this.loaders.get(type);\r\n    if (loaders == null || loaders.size < 1)\r\n        return null;\r\n    if (fileName == null)\r\n        return loaders.get(\"\");\r\n    AssetLoader result = null;\r\n    int l = -1;\r\n    for (ObjectMap.Entry<String, AssetLoader> entry : loaders.entries()) {\r\n        if (entry.key.length() > l && fileName.endsWith(entry.key)) {\r\n            result = entry.value;\r\n            l = entry.key.length();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.Drawer.setFullscreen",
	"Comment": "set the insetsframelayout to display the content in fullscreenunder the statusbar and navigationbar",
	"Method": "void setFullscreen(boolean fullscreen){\r\n    if (mDrawerBuilder.mMaterialize != null) {\r\n        mDrawerBuilder.mMaterialize.setFullscreen(fullscreen);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.decals.PluggableGroupStrategy.plugIn",
	"Comment": "set the plug used for a specific group. the plug will automatically be invoked.",
	"Method": "void plugIn(GroupPlug plug,int group){\r\n    plugs.put(group, plug);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ShortArray.removeAll",
	"Comment": "removes from this array all of elements contained in the specified array.",
	"Method": "boolean removeAll(ShortArray array){\r\n    int size = this.size;\r\n    int startSize = size;\r\n    short[] items = this.items;\r\n    for (int i = 0, n = array.size; i < n; i++) {\r\n        short item = array.get(i);\r\n        for (int ii = 0; ii < size; ii++) {\r\n            if (item == items[ii]) {\r\n                removeIndex(ii);\r\n                size--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return size != startSize;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.getRoll",
	"Comment": "get the roll euler angle in degrees, which is the rotation around the z axis. requires that this quaternion is normalized.",
	"Method": "float getRoll(){\r\n    return getRollRad() * MathUtils.radiansToDegrees;\r\n}"
}, {
	"Path": "com.badlogic.gdx.assets.AssetManager.isFinished",
	"Comment": "returns true when all assets are loaded. can be called from any thread.",
	"Method": "boolean isFinished(){\r\n    return loadQueue.size == 0 && tasks.size() == 0;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.TextField.setPasswordMode",
	"Comment": "if true, the text in this text field will be shown as bullet characters.",
	"Method": "void setPasswordMode(boolean passwordMode){\r\n    this.passwordMode = passwordMode;\r\n    updateDisplayText();\r\n}"
}, {
	"Path": "com.squareup.leakcanary.LeakTraceElement.isInstanceOf",
	"Comment": "returns true if this element is an instance of the provided class name, false otherwise.",
	"Method": "boolean isInstanceOf(Class<?> expectedClass,boolean isInstanceOf,String expectedClassName){\r\n    for (String className : classHierarchy) {\r\n        if (className.equals(expectedClassName)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jna.Memory.align",
	"Comment": "provide a view onto this structure with the given alignment.",
	"Method": "Memory align(int byteBoundary){\r\n    if (byteBoundary <= 0) {\r\n        throw new IllegalArgumentException(\"Byte boundary must be positive: \" + byteBoundary);\r\n    }\r\n    for (int i = 0; i < 32; i++) {\r\n        if (byteBoundary == (1 << i)) {\r\n            long mask = ~((long) byteBoundary - 1);\r\n            if ((peer & mask) != peer) {\r\n                long newPeer = (peer + byteBoundary - 1) & mask;\r\n                long newSize = peer + size - newPeer;\r\n                if (newSize <= 0) {\r\n                    throw new IllegalArgumentException(\"Insufficient memory to align to the requested boundary\");\r\n                }\r\n                return (Memory) share(newPeer - peer, newSize);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Byte boundary must be a power of two\");\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.model.ProfileDrawerItem.getTextColorStateList",
	"Comment": "helper to get the colorstatelist for the text and remembering it so we do not have to recreate it all the time",
	"Method": "ColorStateList getTextColorStateList(int color,int selectedTextColor){\r\n    if (colorStateList == null || color + selectedTextColor != colorStateList.first) {\r\n        colorStateList = new Pair(color + selectedTextColor, DrawerUIUtils.getTextColorStateList(color, selectedTextColor));\r\n    }\r\n    return colorStateList.second;\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.Win32ServiceDemo.init",
	"Comment": "initialize the service, connect to the servicecontrolmanager.",
	"Method": "void init(){\r\n    serviceMain = new ServiceMain();\r\n    SERVICE_TABLE_ENTRY entry = new SERVICE_TABLE_ENTRY();\r\n    entry.lpServiceName = serviceName;\r\n    entry.lpServiceProc = serviceMain;\r\n    Advapi32.INSTANCE.StartServiceCtrlDispatcher((SERVICE_TABLE_ENTRY[]) entry.toArray(2));\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Cubemap.clearAllCubemaps",
	"Comment": "clears all managed cubemaps. this is an internal method. do not use it!",
	"Method": "void clearAllCubemaps(Application app){\r\n    managedCubemaps.remove(app);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Queue.resize",
	"Comment": "resize backing array. newsize must be bigger than current size.",
	"Method": "void resize(int newSize){\r\n    final T[] values = this.values;\r\n    final int head = this.head;\r\n    final int tail = this.tail;\r\n    @SuppressWarnings(\"unchecked\")\r\n    final T[] newArray = (T[]) ArrayReflection.newInstance(values.getClass().getComponentType(), newSize);\r\n    if (head < tail) {\r\n        System.arraycopy(values, head, newArray, 0, tail - head);\r\n    } else if (size > 0) {\r\n        final int rest = values.length - head;\r\n        System.arraycopy(values, head, newArray, 0, rest);\r\n        System.arraycopy(values, 0, newArray, rest, tail);\r\n    }\r\n    this.values = newArray;\r\n    this.head = 0;\r\n    this.tail = size;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.collision.btBroadphasePair.free",
	"Comment": "delete the native object if required and allow the instance to be reused by the obtain method",
	"Method": "void free(btBroadphasePair inst){\r\n    inst.dispose();\r\n    pool.free(inst);\r\n}"
}, {
	"Path": "java.nio.DoubleBuffer.array",
	"Comment": "returns the double array which this buffer is based on, if there is one.",
	"Method": "double[] array(){\r\n    return protectedArray();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.BooleanArray.truncate",
	"Comment": "reduces the size of the array to the specified size. if the array is already smaller than the specified size, no action is",
	"Method": "void truncate(int newSize){\r\n    if (size > newSize)\r\n        size = newSize;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.getLinearVelocityFromWorldPoint",
	"Comment": "get the world linear velocity of a world point attached to this body.",
	"Method": "Vector2 getLinearVelocityFromWorldPoint(Vector2 worldPoint){\r\n    tmp.set(worldPoint.x, worldPoint.y);\r\n    Vec2 lv = body.getLinearVelocityFromWorldPoint(tmp);\r\n    return linVelWorld.set(lv.x, lv.y);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.isArray",
	"Comment": "determines if the supplied class object represents an array class.",
	"Method": "boolean isArray(Class c){\r\n    return c.isArray();\r\n}"
}, {
	"Path": "com.sun.jna.Structure.readField",
	"Comment": "force a read of the given field from native memory.the java fieldwill be updated from the current contents of native memory.",
	"Method": "Object readField(String name,Object readField,StructField structField){\r\n    int offset = structField.offset;\r\n    Class<?> fieldType = structField.type;\r\n    FromNativeConverter readConverter = structField.readConverter;\r\n    if (readConverter != null) {\r\n        fieldType = readConverter.nativeType();\r\n    }\r\n    Object currentValue = (Structure.class.isAssignableFrom(fieldType) || Callback.class.isAssignableFrom(fieldType) || (Platform.HAS_BUFFERS && Buffer.class.isAssignableFrom(fieldType)) || Pointer.class.isAssignableFrom(fieldType) || NativeMapped.class.isAssignableFrom(fieldType) || fieldType.isArray()) ? getFieldValue(structField.field) : null;\r\n    Object result;\r\n    if (fieldType == String.class) {\r\n        Pointer p = memory.getPointer(offset);\r\n        result = p == null ? null : p.getString(0, encoding);\r\n    } else {\r\n        result = memory.getValue(offset, fieldType, currentValue);\r\n    }\r\n    if (readConverter != null) {\r\n        result = readConverter.fromNative(result, structField.context);\r\n        if (currentValue != null && currentValue.equals(result)) {\r\n            result = currentValue;\r\n        }\r\n    }\r\n    if (fieldType.equals(String.class) || fieldType.equals(WString.class)) {\r\n        nativeStrings.put(structField.name + \".ptr\", memory.getPointer(offset));\r\n        nativeStrings.put(structField.name + \".val\", result);\r\n    }\r\n    setFieldValue(structField.field, result, true);\r\n    return result;\r\n}"
}, {
	"Path": "com.badlogic.gdx.jnigen.AntScriptGenerator.generate",
	"Comment": "creates a master build script and one build script for each target to generated native shared libraries.",
	"Method": "void generate(BuildConfig config,BuildTarget targets){\r\n    if (!config.libsDir.exists()) {\r\n        if (!config.libsDir.mkdirs())\r\n            throw new RuntimeException(\"Couldn't create directory for shared library files in '\" + config.libsDir + \"'\");\r\n    }\r\n    if (!config.jniDir.exists()) {\r\n        if (!config.jniDir.mkdirs())\r\n            throw new RuntimeException(\"Couldn't create native code directory '\" + config.jniDir + \"'\");\r\n    }\r\n    copyJniHeaders(config.jniDir.path());\r\n    if (config.jniDir.child(\"memcpy_wrap.c\").exists() == false) {\r\n        new FileDescriptor(\"com/badlogic/gdx/jnigen/resources/scripts/memcpy_wrap.c\", FileType.Classpath).copyTo(config.jniDir.child(\"memcpy_wrap.c\"));\r\n    }\r\n    ArrayList<String> buildFiles = new ArrayList<String>();\r\n    ArrayList<String> libsDirs = new ArrayList<String>();\r\n    ArrayList<String> sharedLibFiles = new ArrayList<String>();\r\n    for (BuildTarget target : targets) {\r\n        String buildFile = generateBuildTargetTemplate(config, target);\r\n        FileDescriptor libsDir = new FileDescriptor(getLibsDirectory(config, target));\r\n        if (!libsDir.exists()) {\r\n            if (!libsDir.mkdirs())\r\n                throw new RuntimeException(\"Couldn't create libs directory '\" + libsDir + \"'\");\r\n        }\r\n        String buildFileName = \"build-\" + target.os.toString().toLowerCase() + (target.is64Bit ? \"64\" : \"32\") + \".xml\";\r\n        if (target.buildFileName != null)\r\n            buildFileName = target.buildFileName;\r\n        config.jniDir.child(buildFileName).writeString(buildFile, false);\r\n        System.out.println(\"Wrote target '\" + target.os + (target.is64Bit ? \"64\" : \"\") + \"' build script '\" + config.jniDir.child(buildFileName) + \"'\");\r\n        if (!target.excludeFromMasterBuildFile) {\r\n            if (target.os != TargetOs.MacOsX && target.os != TargetOs.IOS) {\r\n                buildFiles.add(buildFileName);\r\n            }\r\n            String sharedLibFilename = target.libName;\r\n            if (sharedLibFilename == null)\r\n                sharedLibFilename = getSharedLibFilename(target.os, target.is64Bit, config.sharedLibName);\r\n            sharedLibFiles.add(sharedLibFilename);\r\n            if (target.os != TargetOs.Android && target.os != TargetOs.IOS) {\r\n                libsDirs.add(\"../\" + libsDir.path().replace('\\\\', '/'));\r\n            }\r\n        }\r\n    }\r\n    String template = new FileDescriptor(\"com/badlogic/gdx/jnigen/resources/scripts/build.xml.template\", FileType.Classpath).readString();\r\n    StringBuilder clean = new StringBuilder();\r\n    StringBuilder compile = new StringBuilder();\r\n    StringBuilder pack = new StringBuilder();\r\n    for (int i = 0; i < buildFiles.size(); i++) {\r\n        clean.append(\"\\t\\t<ant antfile=\\\"\" + buildFiles.get(i) + \"\\\" target=\\\"clean\\\"/>\\n\");\r\n        compile.append(\"\\t\\t<ant antfile=\\\"\" + buildFiles.get(i) + \"\\\"/>\\n\");\r\n    }\r\n    for (int i = 0; i < libsDirs.size(); i++) {\r\n        pack.append(\"\\t\\t\\t<fileset dir=\\\"\" + libsDirs.get(i) + \"\\\" includes=\\\"\" + sharedLibFiles.get(i) + \"\\\"/>\\n\");\r\n    }\r\n    if (config.sharedLibs != null) {\r\n        for (String sharedLib : config.sharedLibs) {\r\n            pack.append(\"\\t\\t\\t<fileset dir=\\\"\" + sharedLib + \"\\\"/>\\n\");\r\n        }\r\n    }\r\n    template = template.replace(\"%projectName%\", config.sharedLibName + \"-natives\");\r\n    template = template.replace(\"<clean/>\", clean.toString());\r\n    template = template.replace(\"<compile/>\", compile.toString());\r\n    template = template.replace(\"%packFile%\", \"../\" + config.libsDir.path().replace('\\\\', '/') + \"/\" + config.sharedLibName + \"-natives.jar\");\r\n    template = template.replace(\"<pack/>\", pack);\r\n    config.jniDir.child(\"build.xml\").writeString(template, false);\r\n    System.out.println(\"Wrote master build script '\" + config.jniDir.child(\"build.xml\") + \"'\");\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.getPaddingTop",
	"Comment": "returns the padding above a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "int getPaddingTop(){\r\n    return paddingTop;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tests.NinePatchTest.newMidlessPatch",
	"Comment": "make a ninepatch with no middle band, just top three and bottom three.",
	"Method": "NinePatch newMidlessPatch(){\r\n    final int patchSize = 8;\r\n    final int fullPatchHeight = patchSize * 2;\r\n    final int fullPatchWidth = patchSize * 3;\r\n    final int pixmapDim = MathUtils.nextPowerOfTwo(Math.max(fullPatchWidth, fullPatchHeight));\r\n    Pixmap testPatch = new Pixmap(pixmapDim, pixmapDim, Pixmap.Format.RGBA8888);\r\n    testPatch.setColor(1, 1, 1, 0);\r\n    testPatch.fill();\r\n    for (int x = 0; x < fullPatchWidth; x += patchSize) {\r\n        for (int y = 0; y < fullPatchHeight; y += patchSize) {\r\n            testPatch.setColor(x / (float) fullPatchWidth, y / (float) fullPatchHeight, 1.0f, 1.0f);\r\n            testPatch.fillRectangle(x, y, patchSize, patchSize);\r\n        }\r\n    }\r\n    return new NinePatch(new TextureRegion(new Texture(testPatch), fullPatchWidth, fullPatchHeight), patchSize, patchSize, patchSize, patchSize);\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getTotalPaddingBottom",
	"Comment": "returns the total bottom padding of the view, including the bottomdrawable if any, the extra space to keep more than maxlinesfrom showing, and the vertical offset for gravity, if any.",
	"Method": "int getTotalPaddingBottom(){\r\n    return getPaddingBottom() + mInputView.getTotalPaddingBottom() + (mSupportMode != SUPPORT_MODE_NONE ? mSupportView.getHeight() : 0);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Stage.getDebugColor",
	"Comment": "the default color that can be used by actors to draw debug lines.",
	"Method": "Color getDebugColor(){\r\n    return debugColor;\r\n}"
}, {
	"Path": "com.sun.jna.Native.isCompatibleVersion",
	"Comment": "version string must have the structure ..a bugfix change in the native code increments revision, the minor isincremented for backwards compatible changes and the major versionis changed for backwards incompatbile changes.",
	"Method": "boolean isCompatibleVersion(String expectedVersion,String nativeVersion){\r\n    String[] expectedVersionParts = expectedVersion.split(\"\\\\.\");\r\n    String[] nativeVersionParts = nativeVersion.split(\"\\\\.\");\r\n    if (expectedVersionParts.length < 3 || nativeVersionParts.length < 3) {\r\n        return false;\r\n    }\r\n    int expectedMajor = Integer.parseInt(expectedVersionParts[0]);\r\n    int nativeMajor = Integer.parseInt(nativeVersionParts[0]);\r\n    int expectedMinor = Integer.parseInt(expectedVersionParts[1]);\r\n    int nativeMinor = Integer.parseInt(nativeVersionParts[1]);\r\n    if (expectedMajor != nativeMajor) {\r\n        return false;\r\n    }\r\n    if (expectedMinor > nativeMinor) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane.setScrollingDisabled",
	"Comment": "disables scrolling in a direction. the widget will be sized to the flickscrollpane in the disabled direction.",
	"Method": "void setScrollingDisabled(boolean x,boolean y){\r\n    disableX = x;\r\n    disableY = y;\r\n    invalidate();\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.actions.Actions.fadeOut",
	"Comment": "transitions from the alpha at the time this action starts to an alpha of 0.",
	"Method": "AlphaAction fadeOut(float duration,AlphaAction fadeOut,float duration,Interpolation interpolation){\r\n    AlphaAction action = action(AlphaAction.class);\r\n    action.setAlpha(0);\r\n    action.setDuration(duration);\r\n    action.setInterpolation(interpolation);\r\n    return action;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.isAnnotationPresent",
	"Comment": "returns true if the supplied class includes an annotation of the given type.",
	"Method": "boolean isAnnotationPresent(Class c,Class<? extends java.lang.annotation.Annotation> annotationType){\r\n    return c.isAnnotationPresent(annotationType);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer.bind",
	"Comment": "makes the frame buffer current so everything gets drawn to it.",
	"Method": "void bind(){\r\n    Gdx.gl20.glBindFramebuffer(GL20.GL_FRAMEBUFFER, framebufferHandle);\r\n}"
}, {
	"Path": "org.jsoup.nodes.TextNode.splitText",
	"Comment": "split this text node into two nodes at the specified string offset. after splitting, this node will contain theoriginal text up to the offset, and will have a new text node sibling containing the text after the offset.",
	"Method": "TextNode splitText(int offset){\r\n    final String text = coreValue();\r\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\r\n    Validate.isTrue(offset < text.length(), \"Split offset must not be greater than current text length\");\r\n    String head = text.substring(0, offset);\r\n    String tail = text.substring(offset);\r\n    text(head);\r\n    TextNode tailNode = new TextNode(tail);\r\n    if (parent() != null)\r\n        parent().addChildren(siblingIndex() + 1, tailNode);\r\n    return tailNode;\r\n}"
}, {
	"Path": "org.jsoup.parser.CharacterReader.cacheString",
	"Comment": "caches short strings, as a flywheel pattern, to reduce gc load. just for this doc, to prevent leaks.simplistic, and on hash collisions just falls back to creating a new string, vs a full hashmap with entry list.that saves both having to create objects as hash keys, and running through the entry list, at the expense ofsome more duplicates.",
	"Method": "String cacheString(char[] charBuf,String[] stringCache,int start,int count){\r\n    if (count > maxStringCacheLen)\r\n        return new String(charBuf, start, count);\r\n    if (count < 1)\r\n        return \"\";\r\n    int hash = 0;\r\n    int offset = start;\r\n    for (int i = 0; i < count; i++) {\r\n        hash = 31 * hash + charBuf[offset++];\r\n    }\r\n    final int index = hash & stringCache.length - 1;\r\n    String cached = stringCache[index];\r\n    if (cached == null) {\r\n        cached = new String(charBuf, start, count);\r\n        stringCache[index] = cached;\r\n    } else {\r\n        if (rangeEquals(charBuf, start, count, cached)) {\r\n            return cached;\r\n        } else {\r\n            cached = new String(charBuf, start, count);\r\n            stringCache[index] = cached;\r\n        }\r\n    }\r\n    return cached;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.model.Node.calculateLocalTransform",
	"Comment": "calculates the local transform based on the translation, scale and rotation",
	"Method": "Matrix4 calculateLocalTransform(){\r\n    if (!isAnimated)\r\n        localTransform.set(translation, rotation, scale);\r\n    return localTransform;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.getElementsContainingText",
	"Comment": "find elements that contain the specified string. the search is case insensitive. the text may appear directlyin the element, or in any of its descendants.",
	"Method": "Elements getElementsContainingText(String searchText){\r\n    return Collector.collect(new Evaluator.ContainsText(searchText), this);\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getCompoundPaddingRight",
	"Comment": "returns the right padding of the view, plus space for the rightdrawable if any.",
	"Method": "int getCompoundPaddingRight(){\r\n    return mInputView.getCompoundPaddingRight();\r\n}"
}, {
	"Path": "com.rey.material.widget.SnackBar.actionTextAppearance",
	"Comment": "sets the text color, size, style of the actionbutton from the specified textappearance resource.",
	"Method": "SnackBar actionTextAppearance(int resId){\r\n    if (resId != 0)\r\n        mAction.setTextAppearance(getContext(), resId);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.getEnumConstants",
	"Comment": "returns the elements of this enum class or null if this class object does not represent an enum type.",
	"Method": "Object[] getEnumConstants(Class c){\r\n    return c.getEnumConstants();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectFloatMap.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "void ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded >= threshold)\r\n        resize(MathUtils.nextPowerOfTwo((int) Math.ceil(sizeNeeded / loadFactor)));\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.mul",
	"Comment": "multiplies the components of this quaternion with the given scalar.",
	"Method": "Quaternion mul(Quaternion other,Quaternion mul,float x,float y,float z,float w,Quaternion mul,float scalar){\r\n    this.x *= scalar;\r\n    this.y *= scalar;\r\n    this.z *= scalar;\r\n    this.w *= scalar;\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jna.Union.getFieldOrder",
	"Comment": "unions do not need a field order, so automatically provide a value tosatisfy checking in the structure superclass.",
	"Method": "List<String> getFieldOrder(){\r\n    List<Field> flist = getFieldList();\r\n    List<String> list = new ArrayList<String>(flist.size());\r\n    for (Field f : flist) {\r\n        list.add(f.getName());\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect.save",
	"Comment": "saves all the assets required by all the controllers inside this effect.",
	"Method": "void save(AssetManager assetManager,ResourceData data){\r\n    for (ParticleController controller : controllers) {\r\n        controller.save(assetManager, data);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.tests.bullet.OcclusionBuffer.drawBox",
	"Comment": "draws a bounding box to the depth buffer, or queries the depth buffer at the pixels the box occupies, depending on policy.",
	"Method": "boolean drawBox(Vector3[] vertices,Policy policy){\r\n    for (int i = 0; i < 8; i++) {\r\n        Vector3 v = vertices[i];\r\n        tmpVertices[i].set(v.x, v.y, v.z, 1).mul(projectionMatrix);\r\n    }\r\n    if (policy.evaluate(tmpVertices))\r\n        return true;\r\n    for (int i = 0; i < WINDING.length; ) {\r\n        quad[0].set(tmpVertices[WINDING[i++]]);\r\n        quad[1].set(tmpVertices[WINDING[i++]]);\r\n        quad[2].set(tmpVertices[WINDING[i++]]);\r\n        quad[3].set(tmpVertices[WINDING[i++]]);\r\n        int numVertices = clipQuad(quad, clippedQuad);\r\n        for (int j = 0; j < numVertices; j++) {\r\n            Quaternion q = clippedQuad[j];\r\n            q.z = 1 / q.w;\r\n            vertices[j].set(q.x * q.z, q.y * q.z, q.z);\r\n        }\r\n        for (int j = 2; j < numVertices; j++) {\r\n            if (drawTriangle(vertices[0], vertices[j - 1], vertices[j], policy))\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.collision.BoundingBox.ext",
	"Comment": "extends this bounding box by the given transformed bounding box.",
	"Method": "BoundingBox ext(Vector3 point,BoundingBox ext,BoundingBox a_bounds,BoundingBox ext,Vector3 center,float radius,BoundingBox ext,BoundingBox bounds,Matrix4 transform,BoundingBox ext,float x,float y,float z){\r\n    return this.set(min.set(min(min.x, x), min(min.y, y), min(min.z, z)), max.set(max(max.x, x), max(max.y, y), max(max.z, z)));\r\n}"
}, {
	"Path": "java.nio.Buffer.flip",
	"Comment": "flips this buffer.\tthe limit is set to the current position, then the position is set to zero, and the mark is cleared.\tthe content of this buffer is not changed.",
	"Method": "Buffer flip(){\r\n    limit = position;\r\n    position = 0;\r\n    mark = UNSET_MARK;\r\n    return this;\r\n}"
}, {
	"Path": "java.nio.CharBuffer.array",
	"Comment": "returns the char array which this buffer is based on, if there is one.",
	"Method": "char[] array(){\r\n    return protectedArray();\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.getWorldCenter",
	"Comment": "get the world position of the center of mass.\tnote that the same vector2 instance is returned each time this method is called.",
	"Method": "Vector2 getWorldCenter(){\r\n    Vec2 wc = body.getWorldCenter();\r\n    return worldCenter.set(wc.x, wc.y);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.asFloatArray",
	"Comment": "returns the children of this value as a newly allocated float array.",
	"Method": "float[] asFloatArray(){\r\n    if (type != ValueType.array)\r\n        throw new IllegalStateException(\"Value is not an array: \" + type);\r\n    float[] array = new float[size];\r\n    int i = 0;\r\n    for (JsonValue value = child; value != null; value = value.next, i++) {\r\n        float v;\r\n        switch(value.type) {\r\n            case stringValue:\r\n                v = Float.parseFloat(value.stringValue);\r\n                break;\r\n            case doubleValue:\r\n                v = (float) value.doubleValue;\r\n                break;\r\n            case longValue:\r\n                v = (float) value.longValue;\r\n                break;\r\n            case booleanValue:\r\n                v = value.longValue != 0 ? 1 : 0;\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Value cannot be converted to float: \" + value.type);\r\n        }\r\n        array[i] = v;\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "com.rey.material.widget.ListPopupWindow.setOnItemClickListener",
	"Comment": "sets a listener to receive events when a list item is clicked.",
	"Method": "void setOnItemClickListener(AdapterView.OnItemClickListener clickListener){\r\n    mItemClickListener = clickListener;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.BitmapFont.getLineHeight",
	"Comment": "returns the line height, which is the distance from one line of text to the next.",
	"Method": "float getLineHeight(){\r\n    return data.lineHeight;\r\n}"
}, {
	"Path": "junit.framework.TestSuite.getTestConstructor",
	"Comment": "gets a constructor which takes a single string asits argument or a no arg constructor.",
	"Method": "Constructor<?> getTestConstructor(Class<?> theClass){\r\n    try {\r\n        return theClass.getConstructor(String.class);\r\n    } catch (NoSuchMethodException e) {\r\n    }\r\n    return theClass.getConstructor();\r\n}"
}, {
	"Path": "com.badlogic.gdx.jnigen.JniGenSharedLibraryLoader.setSharedLibraryFinder",
	"Comment": "setting a sharedlibraryfinder enables you to load libraries according to a nondefault natives jar layout or library names.",
	"Method": "void setSharedLibraryFinder(SharedLibraryFinder libraryFinder){\r\n    this.libraryFinder = libraryFinder;\r\n    if (nativesJar != null) {\r\n        try {\r\n            nativesZip = new ZipFile(nativesJar);\r\n        } catch (IOException e) {\r\n            nativesZip = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.VertexAttribute.equals",
	"Comment": "tests to determine if the passed object was created with the same parameters",
	"Method": "boolean equals(Object obj,boolean equals,VertexAttribute other){\r\n    return other != null && usage == other.usage && numComponents == other.numComponents && type == other.type && normalized == other.normalized && alias.equals(other.alias) && unit == other.unit;\r\n}"
}, {
	"Path": "com.squareup.leakcanary.HeapAnalyzer.deduplicateGcRoots",
	"Comment": "pruning duplicates reduces memory pressure from hprof bloat added in marshmallow.",
	"Method": "void deduplicateGcRoots(Snapshot snapshot){\r\n    final THashMap<String, RootObj> uniqueRootMap = new THashMap();\r\n    final Collection<RootObj> gcRoots = snapshot.getGCRoots();\r\n    for (RootObj root : gcRoots) {\r\n        String key = generateRootKey(root);\r\n        if (!uniqueRootMap.containsKey(key)) {\r\n            uniqueRootMap.put(key, root);\r\n        }\r\n    }\r\n    gcRoots.clear();\r\n    uniqueRootMap.forEach(new TObjectProcedure<String>() {\r\n        @Override\r\n        public boolean execute(String key) {\r\n            return gcRoots.add(uniqueRootMap.get(key));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.squareup.leakcanary.HeapAnalyzer.deduplicateGcRoots",
	"Comment": "pruning duplicates reduces memory pressure from hprof bloat added in marshmallow.",
	"Method": "void deduplicateGcRoots(Snapshot snapshot){\r\n    return gcRoots.add(uniqueRootMap.get(key));\r\n}"
}, {
	"Path": "com.rey.material.app.Dialog.positiveActionClickListener",
	"Comment": "set a listener will be called when positive action button is clicked.",
	"Method": "Dialog positiveActionClickListener(View.OnClickListener listener){\r\n    mPositiveAction.setOnClickListener(listener);\r\n    return this;\r\n}"
}, {
	"Path": "java.nio.LongBuffer.put",
	"Comment": "writes longs from the given long array, starting from the specified offset, to the current position and increases the\tposition by the number of longs written.",
	"Method": "LongBuffer put(long l,LongBuffer put,long[] src,LongBuffer put,long[] src,int off,int len,LongBuffer put,LongBuffer src,LongBuffer put,int index,long l){\r\n    if (src == this) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (src.remaining() > remaining()) {\r\n        throw new BufferOverflowException();\r\n    }\r\n    long[] contents = new long[src.remaining()];\r\n    src.get(contents);\r\n    put(contents);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Cell.pad",
	"Comment": "sets the padtop, padleft, padbottom, and padright to the specified value.",
	"Method": "Cell<T> pad(Value pad,Cell<T> pad,Value top,Value left,Value bottom,Value right,Cell<T> pad,float pad,Cell<T> pad,float top,float left,float bottom,float right){\r\n    pad(new Fixed(top), new Fixed(left), new Fixed(bottom), new Fixed(right));\r\n    return this;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.Drawer.addItemsAtPosition",
	"Comment": "add new items to the current draweritem list at a specific position",
	"Method": "void addItemsAtPosition(int position,IDrawerItem drawerItems){\r\n    mDrawerBuilder.getItemAdapter().add(position, drawerItems);\r\n}"
}, {
	"Path": "com.sun.jna.Native.loadNativeDispatchLibraryFromClasspath",
	"Comment": "attempts to load the native library resource from the filesystem,extracting the jna stub library from jna.jar if not already available.",
	"Method": "void loadNativeDispatchLibraryFromClasspath(){\r\n    try {\r\n        String libName = \"/com/sun/jna/\" + Platform.RESOURCE_PREFIX + \"/\" + System.mapLibraryName(\"jnidispatch\").replace(\".dylib\", \".jnilib\");\r\n        File lib = extractFromResourcePath(libName, Native.class.getClassLoader());\r\n        if (lib == null) {\r\n            if (lib == null) {\r\n                throw new UnsatisfiedLinkError(\"Could not find JNA native support\");\r\n            }\r\n        }\r\n        LOG.log(DEBUG_JNA_LOAD_LEVEL, \"Trying {0}\", lib.getAbsolutePath());\r\n        System.setProperty(\"jnidispatch.path\", lib.getAbsolutePath());\r\n        System.load(lib.getAbsolutePath());\r\n        jnidispatchPath = lib.getAbsolutePath();\r\n        LOG.log(DEBUG_JNA_LOAD_LEVEL, \"Found jnidispatch at {0}\", jnidispatchPath);\r\n        if (isUnpacked(lib) && !Boolean.getBoolean(\"jnidispatch.preserve\")) {\r\n            deleteLibrary(lib);\r\n        }\r\n    } catch (IOException e) {\r\n        throw new UnsatisfiedLinkError(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.setCursorVisible",
	"Comment": "set whether the cursor is visible. the default is true. note that this property onlymakes sense for editable textview.",
	"Method": "void setCursorVisible(boolean visible){\r\n    mInputView.setCursorVisible(visible);\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.GuidTest.testGUIDFromBinary",
	"Comment": "loads a guid from a byte array and verify that the guid returned has the\texpected values in each byte.",
	"Method": "void testGUIDFromBinary(){\r\n    byte[] sourceGuidBArr = new byte[] { (byte) 0xA5, (byte) 0xDC, (byte) 0xBF, (byte) 0x10, (byte) 0x65, (byte) 0x30, (byte) 0x11, (byte) 0xD2, (byte) 0x90, (byte) 0x1F, (byte) 0x00, (byte) 0xC0, (byte) 0x4F, (byte) 0xB9, (byte) 0x51, (byte) 0xED };\r\n    GUID targetGuid = GUID.fromBinary(sourceGuidBArr);\r\n    byte[] targetGuidBArr = targetGuid.toByteArray();\r\n    for (int i = 0; i < sourceGuidBArr.length; i++) {\r\n        assertEquals(targetGuidBArr[i], sourceGuidBArr[i]);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.W32Service.waitForNonPendingState",
	"Comment": "wait for the state to change to something other than a pending state.",
	"Method": "void waitForNonPendingState(){\r\n    SERVICE_STATUS_PROCESS status = queryStatus();\r\n    int previousCheckPoint = status.dwCheckPoint;\r\n    int checkpointStartTickCount = Kernel32.INSTANCE.GetTickCount();\r\n    while (isPendingState(status.dwCurrentState)) {\r\n        if (status.dwCheckPoint != previousCheckPoint) {\r\n            previousCheckPoint = status.dwCheckPoint;\r\n            checkpointStartTickCount = Kernel32.INSTANCE.GetTickCount();\r\n        }\r\n        if (Kernel32.INSTANCE.GetTickCount() - checkpointStartTickCount > status.dwWaitHint) {\r\n            throw new RuntimeException(\"Timeout waiting for service to change to a non-pending state.\");\r\n        }\r\n        int dwWaitTime = status.dwWaitHint / 10;\r\n        if (dwWaitTime < 1000)\r\n            dwWaitTime = 1000;\r\n        else if (dwWaitTime > 10000)\r\n            dwWaitTime = 10000;\r\n        try {\r\n            Thread.sleep(dwWaitTime);\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        status = queryStatus();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.GuidTest.testGUIDFromString2",
	"Comment": "loads a guid from string via the constructor and verify that the guid\treturned has the expected values in each byte.",
	"Method": "void testGUIDFromString2(){\r\n    String sourceGuidStr = \"{A5DCBF10-6530-11D2-901F-00C04FB951ED}\";\r\n    GUID targetGuid = new GUID(sourceGuidStr);\r\n    assertEquals(targetGuid.toGuidString(), sourceGuidStr);\r\n}"
}, {
	"Path": "com.sun.jna.MethodParameterContext.getMethod",
	"Comment": "get the method in the library instance the function was called from.",
	"Method": "Method getMethod(){\r\n    return method;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.AccountHeader.getHeaderBackgroundView",
	"Comment": "returns the header background view so the dev can set everything on it",
	"Method": "ImageView getHeaderBackgroundView(){\r\n    return mAccountHeaderBuilder.mAccountHeaderBackground;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.contacts.Contact.mixRestitution",
	"Comment": "restitution mixing law. the idea is allow for anything to bounce off an inelastic surface. forexample, a superball bounces on anything.",
	"Method": "float mixRestitution(float restitution1,float restitution2){\r\n    return restitution1 > restitution2 ? restitution1 : restitution2;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Cell.getComputedPadTop",
	"Comment": "the actual amount of combined padding and spacing from the last layout.",
	"Method": "float getComputedPadTop(){\r\n    return computedPadTop;\r\n}"
}, {
	"Path": "com.rey.material.app.ToolbarManager.notifyNavigationStateProgressChanged",
	"Comment": "notify the progress of animation between 2 states changed. use this function to sync the progress with another animation.",
	"Method": "void notifyNavigationStateProgressChanged(boolean isBackState,float progress){\r\n    if (mNavigationManager != null)\r\n        mNavigationManager.notifyStateProgressChanged(isBackState, progress);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.DistanceJoint.getReactionTorque",
	"Comment": "get the reaction torque given the inverse time step. unit is nm. this is always zero for adistance joint.",
	"Method": "float getReactionTorque(float inv_dt){\r\n    return 0.0f;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.getElementsByTag",
	"Comment": "finds elements, including and recursively under this element, with the specified tag name.",
	"Method": "Elements getElementsByTag(String tagName){\r\n    Validate.notEmpty(tagName);\r\n    tagName = normalize(tagName);\r\n    return Collector.collect(new Evaluator.Tag(tagName), this);\r\n}"
}, {
	"Path": "junit.textui.TestRunner.start",
	"Comment": "starts a test run. analyzes the command line arguments and runs the giventest suite.",
	"Method": "TestResult start(String[] args){\r\n    String testCase = \"\";\r\n    String method = \"\";\r\n    boolean wait = false;\r\n    for (int i = 0; i < args.length; i++) {\r\n        if (args[i].equals(\"-wait\")) {\r\n            wait = true;\r\n        } else if (args[i].equals(\"-c\")) {\r\n            testCase = extractClassName(args[++i]);\r\n        } else if (args[i].equals(\"-m\")) {\r\n            String arg = args[++i];\r\n            int lastIndex = arg.lastIndexOf('.');\r\n            testCase = arg.substring(0, lastIndex);\r\n            method = arg.substring(lastIndex + 1);\r\n        } else if (args[i].equals(\"-v\")) {\r\n            System.err.println(\"JUnit \" + Version.id() + \" by Kent Beck and Erich Gamma\");\r\n        } else {\r\n            testCase = args[i];\r\n        }\r\n    }\r\n    if (testCase.equals(\"\")) {\r\n        throw new Exception(\"Usage: TestRunner [-wait] testCaseName, where name is the name of the TestCase class\");\r\n    }\r\n    try {\r\n        if (!method.equals(\"\")) {\r\n            return runSingleMethod(testCase, method, wait);\r\n        }\r\n        Test suite = getTest(testCase);\r\n        return doRun(suite, wait);\r\n    } catch (Exception e) {\r\n        throw new Exception(\"Could not create and run test suite: \" + e);\r\n    }\r\n}"
}, {
	"Path": "org.junit.experimental.results.ResultMatchers.hasSingleFailureMatching",
	"Comment": "matches if the result has exactly one failure matching the given matcher.",
	"Method": "Matcher<PrintableResult> hasSingleFailureMatching(Matcher<Throwable> matcher){\r\n    return new TypeSafeMatcher<PrintableResult>() {\r\n        @Override\r\n        public boolean matchesSafely(PrintableResult item) {\r\n            return item.failureCount() == 1 && matcher.matches(item.failures().get(0).getException());\r\n        }\r\n        public void describeTo(Description description) {\r\n            description.appendText(\"has failure with exception matching \");\r\n            matcher.describeTo(description);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.junit.experimental.results.ResultMatchers.hasSingleFailureMatching",
	"Comment": "matches if the result has exactly one failure matching the given matcher.",
	"Method": "Matcher<PrintableResult> hasSingleFailureMatching(Matcher<Throwable> matcher){\r\n    return item.failureCount() == 1 && matcher.matches(item.failures().get(0).getException());\r\n}"
}, {
	"Path": "org.junit.experimental.results.ResultMatchers.hasSingleFailureMatching",
	"Comment": "matches if the result has exactly one failure matching the given matcher.",
	"Method": "Matcher<PrintableResult> hasSingleFailureMatching(Matcher<Throwable> matcher){\r\n    description.appendText(\"has failure with exception matching \");\r\n    matcher.describeTo(description);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ArrayReflection.set",
	"Comment": "sets the value of the indexed component in the supplied array to the supplied value.",
	"Method": "void set(Object array,int index,Object value){\r\n    java.lang.reflect.Array.set(array, index, value);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Polygon.rotate",
	"Comment": "applies additional rotation to the polygon by the supplied degrees.",
	"Method": "void rotate(float degrees){\r\n    rotation += degrees;\r\n    dirty = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Actor.firstAscendant",
	"Comment": "returns this actor or the first ascendant of this actor that is assignable with the specified type, or null if none were",
	"Method": "T firstAscendant(Class<T> type){\r\n    if (type == null)\r\n        throw new IllegalArgumentException(\"actor cannot be null.\");\r\n    Actor actor = this;\r\n    do {\r\n        if (ClassReflection.isInstance(type, actor))\r\n            return (T) actor;\r\n        actor = actor.parent;\r\n    } while (actor != null);\r\n    return null;\r\n}"
}, {
	"Path": "com.rey.material.app.SimpleDialog.messageTextAppearance",
	"Comment": "sets the text color, size, style of the message view from the specified textappearance resource.",
	"Method": "SimpleDialog messageTextAppearance(int resId){\r\n    if (mMessageTextAppearanceId != resId) {\r\n        mMessageTextAppearanceId = resId;\r\n        if (mMessage != null)\r\n            mMessage.setTextAppearance(getContext(), mMessageTextAppearanceId);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.rey.material.app.ToolbarManager.createMenu",
	"Comment": "this funcction should be called in oncreateoptionsmenu of activity or fragment to inflate a new menu.",
	"Method": "void createMenu(int menuId){\r\n    mToolbar.inflateMenu(menuId);\r\n    mMenuDataChanged = true;\r\n    if (mAppCompatDelegate == null)\r\n        onPrepareMenu();\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.setGravity",
	"Comment": "sets the horizontal alignment of the text and thevertical gravity that will be used when there is extra spacein the textview beyond what is required for the text itself.",
	"Method": "void setGravity(int gravity){\r\n    mInputView.setGravity(gravity);\r\n}"
}, {
	"Path": "com.codahale.metrics.jvm.ThreadDeadlockDetector.getDeadlockedThreads",
	"Comment": "returns a set of diagnostic stack traces for any deadlocked threads. if no threads aredeadlocked, returns an empty set.",
	"Method": "Set<String> getDeadlockedThreads(){\r\n    final long[] ids = threads.findDeadlockedThreads();\r\n    if (ids != null) {\r\n        final Set<String> deadlocks = new HashSet();\r\n        for (ThreadInfo info : threads.getThreadInfo(ids, MAX_STACK_TRACE_DEPTH)) {\r\n            final StringBuilder stackTrace = new StringBuilder();\r\n            for (StackTraceElement element : info.getStackTrace()) {\r\n                stackTrace.append(\"\\t at \").append(element.toString()).append(String.format(\"%n\"));\r\n            }\r\n            deadlocks.add(String.format(\"%s locked on %s (owned by %s):%n%s\", info.getThreadName(), info.getLockName(), info.getLockOwnerName(), stackTrace.toString()));\r\n        }\r\n        return Collections.unmodifiableSet(deadlocks);\r\n    }\r\n    return Collections.emptySet();\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Plane.isFrontFacing",
	"Comment": "returns whether the plane is facing the direction vector. think of the direction vector as the direction a camera looks in.\tthis method will return true if the front side of the plane determined by its normal faces the camera.",
	"Method": "boolean isFrontFacing(Vector3 direction){\r\n    float dot = normal.dot(direction);\r\n    return dot <= 0;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.LongMap.containsValue",
	"Comment": "returns true if the specified value is in the map. note this traverses the entire map and compares every value, which may\tbe an expensive operation.",
	"Method": "boolean containsValue(Object value,boolean identity){\r\n    V[] valueTable = this.valueTable;\r\n    if (value == null) {\r\n        if (hasZeroValue && zeroValue == null)\r\n            return true;\r\n        long[] keyTable = this.keyTable;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != EMPTY && valueTable[i] == null)\r\n            return true;\r\n    } else if (identity) {\r\n        if (value == zeroValue)\r\n            return true;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (valueTable[i] == value)\r\n            return true;\r\n    } else {\r\n        if (hasZeroValue && value.equals(zeroValue))\r\n            return true;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (value.equals(valueTable[i]))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.collision.btDbvtNode.internalTemp",
	"Comment": "obtains a temporary instance, used by native methods that return a btdbvtnode instance",
	"Method": "btDbvtNode internalTemp(long cPtr,boolean own){\r\n    temp.reset(cPtr, own);\r\n    return temp;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectIntMap.findKey",
	"Comment": "returns the key for the specified value, or null if it is not in the map. note this traverses the entire map and compares\tevery value, which may be an expensive operation.",
	"Method": "K findKey(int value){\r\n    K[] keyTable = this.keyTable;\r\n    int[] valueTable = this.valueTable;\r\n    for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != null && valueTable[i] == value)\r\n        return keyTable[i];\r\n    return null;\r\n}"
}, {
	"Path": "org.junit.runner.Request.method",
	"Comment": "create a request that, when processed, will run a single test.this is done by filtering out all other tests. this method is used to support rerunningsingle tests.",
	"Method": "Request method(Class<?> clazz,String methodName){\r\n    Description method = Description.createTestDescription(clazz, methodName);\r\n    return Request.aClass(clazz).filterWith(method);\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.setFilters",
	"Comment": "sets the list of input filters that will be used if the buffer iseditable. has no effect otherwise.",
	"Method": "void setFilters(InputFilter[] filters){\r\n    mInputView.setFilters(filters);\r\n}"
}, {
	"Path": "com.rey.material.widget.SnackBar.ellipsize",
	"Comment": "causes words in the text that are longer than the view is wide to be ellipsized instead of broken in the middle.",
	"Method": "SnackBar ellipsize(TruncateAt at){\r\n    mText.setEllipsize(at);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.LongArray.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "long[] ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded > items.length)\r\n        resize(Math.max(8, sizeNeeded));\r\n    return items;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.asBooleanArray",
	"Comment": "returns the children of this value as a newly allocated boolean array.",
	"Method": "boolean[] asBooleanArray(){\r\n    if (type != ValueType.array)\r\n        throw new IllegalStateException(\"Value is not an array: \" + type);\r\n    boolean[] array = new boolean[size];\r\n    int i = 0;\r\n    for (JsonValue value = child; value != null; value = value.next, i++) {\r\n        boolean v;\r\n        switch(value.type) {\r\n            case stringValue:\r\n                v = Boolean.parseBoolean(value.stringValue);\r\n                break;\r\n            case doubleValue:\r\n                v = value.doubleValue == 0;\r\n                break;\r\n            case longValue:\r\n                v = value.longValue == 0;\r\n                break;\r\n            case booleanValue:\r\n                v = value.longValue != 0;\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Value cannot be converted to boolean: \" + value.type);\r\n        }\r\n        array[i] = v;\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect.translate",
	"Comment": "applies the translation to the current transformation matrix of each controller.",
	"Method": "void translate(Vector3 translation){\r\n    for (int i = 0, n = controllers.size; i < n; i++) controllers.get(i).translate(translation);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.BulletBase.release",
	"Comment": "release a previously obtained reference, causing the object to be disposed when this was the last reference.",
	"Method": "void release(){\r\n    if (--refCount <= 0 && Bullet.useRefCounting)\r\n        dispose();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.hasChild",
	"Comment": "returns true if a child with the specified name exists and has a child.",
	"Method": "boolean hasChild(String name){\r\n    return getChild(name) != null;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.setSleepingAllowed",
	"Comment": "you can disable sleeping on this body. if you disable sleeping, the body will be woken.",
	"Method": "void setSleepingAllowed(boolean flag){\r\n    if (flag) {\r\n        m_flags |= e_autoSleepFlag;\r\n    } else {\r\n        m_flags &= ~e_autoSleepFlag;\r\n        setAwake(true);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.DragListener.cancel",
	"Comment": "if a drag is in progress, no further drag methods will be called until a new drag is started.",
	"Method": "void cancel(){\r\n    dragging = false;\r\n    pressedPointer = -1;\r\n}"
}, {
	"Path": "org.junit.rules.TemporaryFolder.tryDelete",
	"Comment": "tries to delete all files and folders under the temporary folder andreturns whether deletion was successful or not.",
	"Method": "boolean tryDelete(){\r\n    if (folder == null) {\r\n        return true;\r\n    }\r\n    return recursiveDelete(folder);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Polyline.getLength",
	"Comment": "returns the euclidean length of the polyline without scaling",
	"Method": "float getLength(){\r\n    if (!calculateLength)\r\n        return length;\r\n    calculateLength = false;\r\n    length = 0;\r\n    for (int i = 0, n = localVertices.length - 2; i < n; i += 2) {\r\n        float x = localVertices[i + 2] - localVertices[i];\r\n        float y = localVertices[i + 1] - localVertices[i + 3];\r\n        length += (float) Math.sqrt(x * x + y * y);\r\n    }\r\n    return length;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.getContactList",
	"Comment": "get the world contact list. with the returned contact, use contact.getnext to get the nextcontact in the world list. a null contact indicates the end of the list.",
	"Method": "Contact getContactList(){\r\n    return m_contactManager.m_contactList;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.Attributes.same",
	"Comment": "check if this collection has the same attributes as the other collection. if comparevalues is true, it also compares the\tvalues of each attribute.",
	"Method": "boolean same(Attributes other,boolean compareValues,boolean same,Attributes other){\r\n    return same(other, false);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup.expand",
	"Comment": "when true and wrap is false, the rows will take up the entire horizontal group height.",
	"Method": "HorizontalGroup expand(HorizontalGroup expand,boolean expand){\r\n    this.expand = expand;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.SharedLibraryLoader.load",
	"Comment": "loads a shared library for the platform the application is running on.",
	"Method": "void load(String libraryName){\r\n    if (isIos)\r\n        return;\r\n    synchronized (SharedLibraryLoader.class) {\r\n        if (isLoaded(libraryName))\r\n            return;\r\n        String platformName = mapLibraryName(libraryName);\r\n        try {\r\n            if (isAndroid)\r\n                System.loadLibrary(platformName);\r\n            else\r\n                loadFile(platformName);\r\n            setLoaded(libraryName);\r\n        } catch (Throwable ex) {\r\n            throw new GdxRuntimeException(\"Couldn't load shared library '\" + platformName + \"' for target: \" + System.getProperty(\"os.name\") + (is64Bit ? \", 64-bit\" : \", 32-bit\"), ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.Method.isVarArgs",
	"Comment": "return true if the method takes a variable number of arguments.",
	"Method": "boolean isVarArgs(){\r\n    return method.isVarArgs();\r\n}"
}, {
	"Path": "com.badlogic.gdx.tests.lwjgl.LwjglTestStarter.main",
	"Comment": "runs a libgdx test.\tif no arguments are provided on the command line, shows a list of tests to choose from.\tif an argument is present, the test with that name will immediately be run.",
	"Method": "void main(String[] argv){\r\n    if (argv.length > 0) {\r\n        if (runTest(argv[0])) {\r\n            return;\r\n        }\r\n    }\r\n    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\r\n    new LwjglTestStarter();\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.getPaddingLeft",
	"Comment": "returns the padding to the left of a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "int getPaddingLeft(){\r\n    return paddingLeft;\r\n}"
}, {
	"Path": "com.sun.jna.Structure.getFieldTypeInfo",
	"Comment": "override to supply native type information for the given field.",
	"Method": "Pointer getFieldTypeInfo(StructField f){\r\n    Class<?> type = f.type;\r\n    Object value = getFieldValue(f.field);\r\n    if (typeMapper != null) {\r\n        ToNativeConverter nc = typeMapper.getToNativeConverter(type);\r\n        if (nc != null) {\r\n            type = nc.nativeType();\r\n            value = nc.toNative(value, new ToNativeContext());\r\n        }\r\n    }\r\n    return FFIType.get(value, type);\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.setTransformationMethod",
	"Comment": "sets the transformation that is applied to the text that thistextview is displaying.",
	"Method": "void setTransformationMethod(TransformationMethod method){\r\n    mInputView.setTransformationMethod(method);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.destroyJoint",
	"Comment": "destroy a joint. this may cause the connected bodies to begin colliding.",
	"Method": "void destroyJoint(Joint j){\r\n    assert (isLocked() == false);\r\n    if (isLocked()) {\r\n        return;\r\n    }\r\n    boolean collideConnected = j.getCollideConnected();\r\n    if (j.m_prev != null) {\r\n        j.m_prev.m_next = j.m_next;\r\n    }\r\n    if (j.m_next != null) {\r\n        j.m_next.m_prev = j.m_prev;\r\n    }\r\n    if (j == m_jointList) {\r\n        m_jointList = j.m_next;\r\n    }\r\n    Body bodyA = j.getBodyA();\r\n    Body bodyB = j.getBodyB();\r\n    bodyA.setAwake(true);\r\n    bodyB.setAwake(true);\r\n    if (j.m_edgeA.prev != null) {\r\n        j.m_edgeA.prev.next = j.m_edgeA.next;\r\n    }\r\n    if (j.m_edgeA.next != null) {\r\n        j.m_edgeA.next.prev = j.m_edgeA.prev;\r\n    }\r\n    if (j.m_edgeA == bodyA.m_jointList) {\r\n        bodyA.m_jointList = j.m_edgeA.next;\r\n    }\r\n    j.m_edgeA.prev = null;\r\n    j.m_edgeA.next = null;\r\n    if (j.m_edgeB.prev != null) {\r\n        j.m_edgeB.prev.next = j.m_edgeB.next;\r\n    }\r\n    if (j.m_edgeB.next != null) {\r\n        j.m_edgeB.next.prev = j.m_edgeB.prev;\r\n    }\r\n    if (j.m_edgeB == bodyB.m_jointList) {\r\n        bodyB.m_jointList = j.m_edgeB.next;\r\n    }\r\n    j.m_edgeB.prev = null;\r\n    j.m_edgeB.next = null;\r\n    Joint.destroy(j);\r\n    assert (m_jointCount > 0);\r\n    --m_jointCount;\r\n    if (collideConnected == false) {\r\n        ContactEdge edge = bodyB.getContactList();\r\n        while (edge != null) {\r\n            if (edge.other == bodyA) {\r\n                edge.contact.flagForFiltering();\r\n            }\r\n            edge = edge.next;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Skin.addRegions",
	"Comment": "adds all named texture regions from the atlas. the atlas will not be automatically disposed when the skin is disposed.",
	"Method": "void addRegions(TextureAtlas atlas){\r\n    Array<AtlasRegion> regions = atlas.getRegions();\r\n    for (int i = 0, n = regions.size; i < n; i++) {\r\n        AtlasRegion region = regions.get(i);\r\n        String name = region.name;\r\n        if (region.index != -1) {\r\n            name += \"_\" + region.index;\r\n        }\r\n        add(name, region, TextureRegion.class);\r\n    }\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.didTouchFocusSelect",
	"Comment": "returns true, only while processing a touch gesture, if the initialtouch down event caused focus to move to the text view and as a resultits selection changed.only valid while processing the touch gestureof interest, in an editable text view.",
	"Method": "boolean didTouchFocusSelect(){\r\n    return mInputView.didTouchFocusSelect();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntIntMap.shrink",
	"Comment": "reduces the size of the backing arrays to be the specified capacity or less. if the capacity is already less, nothing is\tdone. if the map contains more items than the specified capacity, the next highest power of two capacity is used instead.",
	"Method": "void shrink(int maximumCapacity){\r\n    if (maximumCapacity < 0)\r\n        throw new IllegalArgumentException(\"maximumCapacity must be >= 0: \" + maximumCapacity);\r\n    if (size > maximumCapacity)\r\n        maximumCapacity = size;\r\n    if (capacity <= maximumCapacity)\r\n        return;\r\n    maximumCapacity = MathUtils.nextPowerOfTwo(maximumCapacity);\r\n    resize(maximumCapacity);\r\n}"
}, {
	"Path": "lombok.eclipse.handlers.EclipseHandlerUtil.createAnnotation",
	"Comment": "provides annotationvalues with the data it needs to do its thing.",
	"Method": "AnnotationValues<A> createAnnotation(Class<A> type,EclipseNode annotationNode){\r\n    final Annotation annotation = (Annotation) annotationNode.get();\r\n    Map<String, AnnotationValue> values = new HashMap<String, AnnotationValue>();\r\n    MemberValuePair[] memberValuePairs = annotation.memberValuePairs();\r\n    if (memberValuePairs != null)\r\n        for (final MemberValuePair pair : memberValuePairs) {\r\n            List<String> raws = new ArrayList<String>();\r\n            List<Object> expressionValues = new ArrayList<Object>();\r\n            List<Object> guesses = new ArrayList<Object>();\r\n            Expression[] expressions = null;\r\n            char[] n = pair.name;\r\n            String mName = (n == null || n.length == 0) ? \"value\" : new String(pair.name);\r\n            final Expression rhs = pair.value;\r\n            if (rhs instanceof ArrayInitializer) {\r\n                expressions = ((ArrayInitializer) rhs).expressions;\r\n            } else if (rhs != null) {\r\n                expressions = new Expression[] { rhs };\r\n            }\r\n            if (expressions != null)\r\n                for (Expression ex : expressions) {\r\n                    StringBuffer sb = new StringBuffer();\r\n                    ex.print(0, sb);\r\n                    raws.add(sb.toString());\r\n                    expressionValues.add(ex);\r\n                    guesses.add(calculateValue(ex));\r\n                }\r\n            final Expression[] exprs = expressions;\r\n            values.put(mName, new AnnotationValue(annotationNode, raws, expressionValues, guesses, true) {\r\n                @Override\r\n                public void setError(String message, int valueIdx) {\r\n                    Expression ex;\r\n                    if (valueIdx == -1)\r\n                        ex = rhs;\r\n                    else\r\n                        ex = exprs != null ? exprs[valueIdx] : null;\r\n                    if (ex == null)\r\n                        ex = annotation;\r\n                    int sourceStart = ex.sourceStart;\r\n                    int sourceEnd = ex.sourceEnd;\r\n                    annotationNode.addError(message, sourceStart, sourceEnd);\r\n                }\r\n                @Override\r\n                public void setWarning(String message, int valueIdx) {\r\n                    Expression ex;\r\n                    if (valueIdx == -1)\r\n                        ex = rhs;\r\n                    else\r\n                        ex = exprs != null ? exprs[valueIdx] : null;\r\n                    if (ex == null)\r\n                        ex = annotation;\r\n                    int sourceStart = ex.sourceStart;\r\n                    int sourceEnd = ex.sourceEnd;\r\n                    annotationNode.addWarning(message, sourceStart, sourceEnd);\r\n                }\r\n            });\r\n        }\r\n    for (Method m : type.getDeclaredMethods()) {\r\n        if (!Modifier.isPublic(m.getModifiers()))\r\n            continue;\r\n        String name = m.getName();\r\n        if (!values.containsKey(name)) {\r\n            values.put(name, new AnnotationValue(annotationNode, new ArrayList<String>(), new ArrayList<Object>(), new ArrayList<Object>(), false) {\r\n                @Override\r\n                public void setError(String message, int valueIdx) {\r\n                    annotationNode.addError(message);\r\n                }\r\n                @Override\r\n                public void setWarning(String message, int valueIdx) {\r\n                    annotationNode.addWarning(message);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    return new AnnotationValues<A>(type, values, annotationNode);\r\n}"
}, {
	"Path": "lombok.eclipse.handlers.EclipseHandlerUtil.createAnnotation",
	"Comment": "provides annotationvalues with the data it needs to do its thing.",
	"Method": "AnnotationValues<A> createAnnotation(Class<A> type,EclipseNode annotationNode){\r\n    Expression ex;\r\n    if (valueIdx == -1)\r\n        ex = rhs;\r\n    else\r\n        ex = exprs != null ? exprs[valueIdx] : null;\r\n    if (ex == null)\r\n        ex = annotation;\r\n    int sourceStart = ex.sourceStart;\r\n    int sourceEnd = ex.sourceEnd;\r\n    annotationNode.addError(message, sourceStart, sourceEnd);\r\n}"
}, {
	"Path": "lombok.eclipse.handlers.EclipseHandlerUtil.createAnnotation",
	"Comment": "provides annotationvalues with the data it needs to do its thing.",
	"Method": "AnnotationValues<A> createAnnotation(Class<A> type,EclipseNode annotationNode){\r\n    Expression ex;\r\n    if (valueIdx == -1)\r\n        ex = rhs;\r\n    else\r\n        ex = exprs != null ? exprs[valueIdx] : null;\r\n    if (ex == null)\r\n        ex = annotation;\r\n    int sourceStart = ex.sourceStart;\r\n    int sourceEnd = ex.sourceEnd;\r\n    annotationNode.addWarning(message, sourceStart, sourceEnd);\r\n}"
}, {
	"Path": "lombok.eclipse.handlers.EclipseHandlerUtil.createAnnotation",
	"Comment": "provides annotationvalues with the data it needs to do its thing.",
	"Method": "AnnotationValues<A> createAnnotation(Class<A> type,EclipseNode annotationNode){\r\n    annotationNode.addError(message);\r\n}"
}, {
	"Path": "lombok.eclipse.handlers.EclipseHandlerUtil.createAnnotation",
	"Comment": "provides annotationvalues with the data it needs to do its thing.",
	"Method": "AnnotationValues<A> createAnnotation(Class<A> type,EclipseNode annotationNode){\r\n    annotationNode.addWarning(message);\r\n}"
}, {
	"Path": "com.sun.jna.Pointer.getByteBuffer",
	"Comment": "get a bytebuffer mapped to the memory pointed to by the pointer,ensuring the buffer uses native byte order.",
	"Method": "ByteBuffer getByteBuffer(long offset,long length,ByteBuffer getByteBuffer,long offset,long length){\r\n    return Native.getDirectByteBuffer(this, this.peer, offset, length).order(ByteOrder.nativeOrder());\r\n}"
}, {
	"Path": "java.nio.ByteBuffer.toString",
	"Comment": "returns a string representing the state of this byte buffer.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(getClass().getName());\r\n    sb.append(\", status: capacity=\");\r\n    sb.append(capacity());\r\n    sb.append(\" position=\");\r\n    sb.append(position());\r\n    sb.append(\" limit=\");\r\n    sb.append(limit());\r\n    return sb.toString();\r\n}"
}, {
	"Path": "junit.framework.TestFailure.exceptionMessage",
	"Comment": "returns a string containing the message from the thrown exception.",
	"Method": "String exceptionMessage(){\r\n    return thrownException().getMessage();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Base64Coder.encode",
	"Comment": "encodes a byte array into base64 format. no blanks or line breaks are inserted in the output.",
	"Method": "char[] encode(byte[] in,char[] encode,byte[] in,CharMap charMap,char[] encode,byte[] in,char[] charMap,char[] encode,byte[] in,int iLen,char[] encode,byte[] in,int iOff,int iLen,CharMap charMap,char[] encode,byte[] in,int iOff,int iLen,char[] charMap){\r\n    int oDataLen = (iLen * 4 + 2) / 3;\r\n    int oLen = ((iLen + 2) / 3) * 4;\r\n    char[] out = new char[oLen];\r\n    int ip = iOff;\r\n    int iEnd = iOff + iLen;\r\n    int op = 0;\r\n    while (ip < iEnd) {\r\n        int i0 = in[ip++] & 0xff;\r\n        int i1 = ip < iEnd ? in[ip++] & 0xff : 0;\r\n        int i2 = ip < iEnd ? in[ip++] & 0xff : 0;\r\n        int o0 = i0 >>> 2;\r\n        int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\r\n        int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\r\n        int o3 = i2 & 0x3F;\r\n        out[op++] = charMap[o0];\r\n        out[op++] = charMap[o1];\r\n        out[op] = op < oDataLen ? charMap[o2] : '=';\r\n        op++;\r\n        out[op] = op < oDataLen ? charMap[o3] : '=';\r\n        op++;\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.getPitchRad",
	"Comment": "get the pitch euler angle in radians, which is the rotation around the x axis. requires that this quaternion is normalized.",
	"Method": "float getPitchRad(){\r\n    final int pole = getGimbalPole();\r\n    return pole == 0 ? (float) Math.asin(MathUtils.clamp(2f * (w * x - z * y), -1f, 1f)) : (float) pole * MathUtils.PI * 0.5f;\r\n}"
}, {
	"Path": "com.sun.jna.Memory.setLong",
	"Comment": "indirect the native pointer to malloc space, a lapointer.setlong.but this method performs a boundschecks to ensure that the indirection does not cause memory outside themalloced space to be accessed.",
	"Method": "void setLong(long offset,long value){\r\n    boundsCheck(offset, 8);\r\n    super.setLong(offset, value);\r\n}"
}, {
	"Path": "java.nio.IntBuffer.put",
	"Comment": "writes ints from the given int array, starting from the specified offset, to the current position and increases the position\tby the number of ints written.",
	"Method": "IntBuffer put(int i,IntBuffer put,int[] src,IntBuffer put,int[] src,int off,int len,IntBuffer put,IntBuffer src,IntBuffer put,int index,int i){\r\n    if (src == this) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (src.remaining() > remaining()) {\r\n        throw new BufferOverflowException();\r\n    }\r\n    int[] contents = new int[src.remaining()];\r\n    src.get(contents);\r\n    put(contents);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.PolygonSprite.setBounds",
	"Comment": "sets the position and size of the sprite when drawn, before scaling and rotation are applied. if origin, rotation, or scale\tare changed, it is slightly more efficient to set the bounds after those operations.",
	"Method": "void setBounds(float x,float y,float width,float height){\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n    dirty = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.ArraySelection.changed",
	"Comment": "called after the selection changes, clears the range start item.",
	"Method": "void changed(){\r\n    rangeStart = null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Polyline.getTransformedVertices",
	"Comment": "returns vertices scaled, rotated, and offset by the polygon position.",
	"Method": "float[] getTransformedVertices(){\r\n    if (!dirty)\r\n        return worldVertices;\r\n    dirty = false;\r\n    final float[] localVertices = this.localVertices;\r\n    if (worldVertices == null || worldVertices.length < localVertices.length)\r\n        worldVertices = new float[localVertices.length];\r\n    final float[] worldVertices = this.worldVertices;\r\n    final float positionX = x;\r\n    final float positionY = y;\r\n    final float originX = this.originX;\r\n    final float originY = this.originY;\r\n    final float scaleX = this.scaleX;\r\n    final float scaleY = this.scaleY;\r\n    final boolean scale = scaleX != 1 || scaleY != 1;\r\n    final float rotation = this.rotation;\r\n    final float cos = MathUtils.cosDeg(rotation);\r\n    final float sin = MathUtils.sinDeg(rotation);\r\n    for (int i = 0, n = localVertices.length; i < n; i += 2) {\r\n        float x = localVertices[i] - originX;\r\n        float y = localVertices[i + 1] - originY;\r\n        if (scale) {\r\n            x *= scaleX;\r\n            y *= scaleY;\r\n        }\r\n        if (rotation != 0) {\r\n            float oldX = x;\r\n            x = cos * x - sin * y;\r\n            y = sin * oldX + cos * y;\r\n        }\r\n        worldVertices[i] = positionX + x + originX;\r\n        worldVertices[i + 1] = positionY + y + originY;\r\n    }\r\n    return worldVertices;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.LongArray.truncate",
	"Comment": "reduces the size of the array to the specified size. if the array is already smaller than the specified size, no action is",
	"Method": "void truncate(int newSize){\r\n    if (size > newSize)\r\n        size = newSize;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.AccountHeaderBuilder.withSelectionListEnabledForSingleProfile",
	"Comment": "enable or disable the selection list if there is only a single profile",
	"Method": "AccountHeaderBuilder withSelectionListEnabledForSingleProfile(boolean selectionListEnabledForSingleProfile){\r\n    this.mSelectionListEnabledForSingleProfile = selectionListEnabledForSingleProfile;\r\n    return this;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withStickyFooterDivider",
	"Comment": "set this to true if you want the divider above the sticky footer",
	"Method": "DrawerBuilder withStickyFooterDivider(boolean stickyFooterDivider){\r\n    this.mStickyFooterDivider = stickyFooterDivider;\r\n    return this;\r\n}"
}, {
	"Path": "org.jsoup.internal.StringUtil.resolve",
	"Comment": "create a new absolute url, from a provided existing absolute url and a relative url component.",
	"Method": "URL resolve(URL base,String relUrl,String resolve,String baseUrl,String relUrl){\r\n    URL base;\r\n    try {\r\n        try {\r\n            base = new URL(baseUrl);\r\n        } catch (MalformedURLException e) {\r\n            URL abs = new URL(relUrl);\r\n            return abs.toExternalForm();\r\n        }\r\n        return resolve(base, relUrl).toExternalForm();\r\n    } catch (MalformedURLException e) {\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Intersector.distanceLinePoint",
	"Comment": "returns the distance between the given line and point. note the specified line is not a line segment.",
	"Method": "float distanceLinePoint(float startX,float startY,float endX,float endY,float pointX,float pointY){\r\n    float normalLength = (float) Math.sqrt((endX - startX) * (endX - startX) + (endY - startY) * (endY - startY));\r\n    return Math.abs((pointX - startX) * (endY - startY) - (pointY - startY) * (endX - startX)) / normalLength;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.buildView",
	"Comment": "build the drawers content only. this will still return a result object, but only with the content set. no inflating of a drawerlayout.",
	"Method": "Drawer buildView(){\r\n    mSliderLayout = (ScrimInsetsRelativeLayout) mActivity.getLayoutInflater().inflate(R.layout.material_drawer_slider, mDrawerLayout, false);\r\n    mSliderLayout.setBackgroundColor(UIUtils.getThemeColorFromAttrOrRes(mActivity, R.attr.material_drawer_background, R.color.material_drawer_background));\r\n    DrawerLayout.LayoutParams params = (DrawerLayout.LayoutParams) mSliderLayout.getLayoutParams();\r\n    if (params != null) {\r\n        params.gravity = mDrawerGravity;\r\n        params = DrawerUtils.processDrawerLayoutParams(this, params);\r\n        mSliderLayout.setLayoutParams(params);\r\n    }\r\n    createContent();\r\n    Drawer result = new Drawer(this);\r\n    if (mAccountHeader != null) {\r\n        mAccountHeader.setDrawer(result);\r\n    }\r\n    if (mSavedInstance != null && mSavedInstance.getBoolean(Drawer.BUNDLE_DRAWER_CONTENT_SWITCHED, false)) {\r\n        mAccountHeader.toggleSelectionList(mActivity);\r\n    }\r\n    handleShowOnLaunch();\r\n    if (!mAppended && mGenerateMiniDrawer) {\r\n        mMiniDrawer = new MiniDrawer().withDrawer(result).withAccountHeader(mAccountHeader);\r\n    }\r\n    mActivity = null;\r\n    return result;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Matrix3.trn",
	"Comment": "adds a translational component to the matrix in the 3rd column. the other columns are untouched.",
	"Method": "Matrix3 trn(Vector2 vector,Matrix3 trn,float x,float y,Matrix3 trn,Vector3 vector){\r\n    val[M02] += vector.x;\r\n    val[M12] += vector.y;\r\n    return this;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.FixtureDef.getShape",
	"Comment": "the shape, this must be set. the shape will be cloned, so you can create the shape on thestack.",
	"Method": "Shape getShape(){\r\n    return shape;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.asLongArray",
	"Comment": "returns the children of this value as a newly allocated long array.",
	"Method": "long[] asLongArray(){\r\n    if (type != ValueType.array)\r\n        throw new IllegalStateException(\"Value is not an array: \" + type);\r\n    long[] array = new long[size];\r\n    int i = 0;\r\n    for (JsonValue value = child; value != null; value = value.next, i++) {\r\n        long v;\r\n        switch(value.type) {\r\n            case stringValue:\r\n                v = Long.parseLong(value.stringValue);\r\n                break;\r\n            case doubleValue:\r\n                v = (long) value.doubleValue;\r\n                break;\r\n            case longValue:\r\n                v = value.longValue;\r\n                break;\r\n            case booleanValue:\r\n                v = value.longValue != 0 ? 1 : 0;\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Value cannot be converted to long: \" + value.type);\r\n        }\r\n        array[i] = v;\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.getElementsByAttributeValueStarting",
	"Comment": "find elements that have attributes that start with the value prefix. case insensitive.",
	"Method": "Elements getElementsByAttributeValueStarting(String key,String valuePrefix){\r\n    return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\r\n}"
}, {
	"Path": "com.sun.jna.CallbackThreadInitializer.getThreadGroup",
	"Comment": "returns the desired threadgroup for thread, or null for the default.",
	"Method": "ThreadGroup getThreadGroup(Callback cb){\r\n    return group;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper.writer",
	"Comment": "returns a writer for writing to this file. parent directories will be created if necessary.",
	"Method": "Writer writer(boolean append,Writer writer,boolean append,String charset){\r\n    if (type == FileType.Classpath)\r\n        throw new GdxRuntimeException(\"Cannot write to a classpath file: \" + file);\r\n    if (type == FileType.Internal)\r\n        throw new GdxRuntimeException(\"Cannot write to an internal file: \" + file);\r\n    parent().mkdirs();\r\n    try {\r\n        FileOutputStream output = new FileOutputStream(file(), append);\r\n        if (charset == null)\r\n            return new OutputStreamWriter(output);\r\n        else\r\n            return new OutputStreamWriter(output, charset);\r\n    } catch (IOException ex) {\r\n        if (file().isDirectory())\r\n            throw new GdxRuntimeException(\"Cannot open a stream to a directory: \" + file + \" (\" + type + \")\", ex);\r\n        throw new GdxRuntimeException(\"Error writing file: \" + file + \" (\" + type + \")\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.jsoup.parser.Tag.isFormSubmittable",
	"Comment": "get if this tag represents an element that should be submitted with a form. e.g. input, option",
	"Method": "boolean isFormSubmittable(){\r\n    return formSubmit;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.collision.btDbvtAabbMm.internalTemp",
	"Comment": "obtains a temporary instance, used by native methods that return a btdbvtaabbmm instance",
	"Method": "btDbvtAabbMm internalTemp(long cPtr,boolean own){\r\n    temp.reset(cPtr, own);\r\n    return temp;\r\n}"
}, {
	"Path": "com.sun.jna.Memory.getPointer",
	"Comment": "indirect the native pointer to malloc space, a lapointer.getpointer.but this method performsa bounds checks to ensure that the indirection does not cause memoryoutside the malloced space to be accessed.",
	"Method": "Pointer getPointer(long offset){\r\n    boundsCheck(offset, Native.POINTER_SIZE);\r\n    return super.getPointer(offset);\r\n}"
}, {
	"Path": "com.badlogic.gdx.jnigen.BuildTarget.newDefaultTarget",
	"Comment": "creates a new default buildtarget for the given os, using common default values.",
	"Method": "BuildTarget newDefaultTarget(BuildTarget.TargetOs type,boolean is64Bit){\r\n    if (type == TargetOs.Windows && !is64Bit) {\r\n        return new BuildTarget(TargetOs.Windows, false, new String[] { \"**/*.c\" }, new String[0], new String[] { \"**/*.cpp\" }, new String[0], new String[0], \"i686-w64-mingw32-\", \"-c -Wall -O2 -mfpmath=sse -msse2 -fmessage-length=0 -m32\", \"-c -Wall -O2 -mfpmath=sse -msse2 -fmessage-length=0 -m32\", \"-Wl,--kill-at -shared -m32 -static -static-libgcc -static-libstdc++\");\r\n    }\r\n    if (type == TargetOs.Windows && is64Bit) {\r\n        return new BuildTarget(TargetOs.Windows, true, new String[] { \"**/*.c\" }, new String[0], new String[] { \"**/*.cpp\" }, new String[0], new String[0], \"x86_64-w64-mingw32-\", \"-c -Wall -O2 -mfpmath=sse -msse2 -fmessage-length=0 -m64\", \"-c -Wall -O2 -mfpmath=sse -msse2 -fmessage-length=0 -m64\", \"-Wl,--kill-at -shared -static -static-libgcc -static-libstdc++ -m64\");\r\n    }\r\n    if (type == TargetOs.Linux && !is64Bit) {\r\n        return new BuildTarget(TargetOs.Linux, false, new String[] { \"**/*.c\" }, new String[0], new String[] { \"**/*.cpp\" }, new String[0], new String[0], \"\", \"-c -Wall -O2 -mfpmath=sse -msse -fmessage-length=0 -m32 -fPIC\", \"-c -Wall -O2 -mfpmath=sse -msse -fmessage-length=0 -m32 -fPIC\", \"-shared -m32\");\r\n    }\r\n    if (type == TargetOs.Linux && is64Bit) {\r\n        return new BuildTarget(TargetOs.Linux, true, new String[] { \"**/*.c\" }, new String[0], new String[] { \"**/*.cpp\" }, new String[0], new String[0], \"\", \"-c -Wall -O2 -mfpmath=sse -msse -fmessage-length=0 -m64 -fPIC\", \"-c -Wall -O2 -mfpmath=sse -msse -fmessage-length=0 -m64 -fPIC\", \"-shared -m64 -Wl,-wrap,memcpy\");\r\n    }\r\n    if (type == TargetOs.MacOsX && !is64Bit) {\r\n        BuildTarget mac = new BuildTarget(TargetOs.MacOsX, false, new String[] { \"**/*.c\" }, new String[0], new String[] { \"**/*.cpp\" }, new String[0], new String[0], \"\", \"-c -Wall -O2 -arch i386 -DFIXED_POINT -fmessage-length=0 -fPIC -mmacosx-version-min=10.5\", \"-c -Wall -O2 -arch i386 -DFIXED_POINT -fmessage-length=0 -fPIC -mmacosx-version-min=10.5\", \"-shared -arch i386 -mmacosx-version-min=10.5\");\r\n        return mac;\r\n    }\r\n    if (type == TargetOs.MacOsX && is64Bit) {\r\n        BuildTarget mac = new BuildTarget(TargetOs.MacOsX, true, new String[] { \"**/*.c\" }, new String[0], new String[] { \"**/*.cpp\" }, new String[0], new String[0], \"\", \"-c -Wall -O2 -arch x86_64 -DFIXED_POINT -fmessage-length=0 -fPIC -mmacosx-version-min=10.5\", \"-c -Wall -O2 -arch x86_64 -DFIXED_POINT -fmessage-length=0 -fPIC -mmacosx-version-min=10.5\", \"-shared -arch x86_64 -mmacosx-version-min=10.5\");\r\n        return mac;\r\n    }\r\n    if (type == TargetOs.Android) {\r\n        BuildTarget android = new BuildTarget(TargetOs.Android, false, new String[] { \"**/*.c\" }, new String[0], new String[] { \"**/*.cpp\" }, new String[0], new String[0], \"\", \"-O2 -Wall -D__ANDROID__\", \"-O2 -Wall -D__ANDROID__\", \"-lm\");\r\n        return android;\r\n    }\r\n    if (type == TargetOs.IOS) {\r\n        BuildTarget ios = new BuildTarget(TargetOs.IOS, false, new String[] { \"**/*.c\" }, new String[0], new String[] { \"**/*.cpp\" }, new String[0], new String[0], \"\", \"-c -Wall -O2\", \"-c -Wall -O2\", \"rcs\");\r\n        return ios;\r\n    }\r\n    throw new RuntimeException(\"Unknown target type\");\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane.getScrollX",
	"Comment": "returns the x scroll position in pixels, where 0 is the left of the scroll pane.",
	"Method": "float getScrollX(){\r\n    return amountX;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane.getScrollY",
	"Comment": "returns the y scroll position in pixels, where 0 is the top of the scroll pane.",
	"Method": "float getScrollY(){\r\n    return amountY;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper.moveTo",
	"Comment": "moves this file to the specified file, overwriting the file if it already exists.",
	"Method": "void moveTo(FileWrapper dest){\r\n    if (type == FileType.Classpath)\r\n        throw new GdxRuntimeException(\"Cannot move a classpath file: \" + file);\r\n    if (type == FileType.Internal)\r\n        throw new GdxRuntimeException(\"Cannot move an internal file: \" + file);\r\n    copyTo(dest);\r\n    delete();\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Group.addActorAt",
	"Comment": "adds an actor as a child of this group at a specific index, removing it from its previous parent. if the actor is already a\tchild of this group, no changes are made.",
	"Method": "void addActorAt(int index,Actor actor){\r\n    if (actor.parent != null) {\r\n        if (actor.parent == this)\r\n            return;\r\n        actor.parent.removeActor(actor, false);\r\n    }\r\n    if (index >= children.size)\r\n        children.add(actor);\r\n    else\r\n        children.insert(index, actor);\r\n    actor.setParent(this);\r\n    actor.setStage(getStage());\r\n    childrenChanged();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.FloatArray.setSize",
	"Comment": "sets the array size, leaving any values beyond the current size undefined.",
	"Method": "float[] setSize(int newSize){\r\n    if (newSize < 0)\r\n        throw new IllegalArgumentException(\"newSize must be >= 0: \" + newSize);\r\n    if (newSize > items.length)\r\n        resize(Math.max(8, newSize));\r\n    size = newSize;\r\n    return items;\r\n}"
}, {
	"Path": "org.junit.tests.junit3compatibility.SuiteMethodTest.descriptionAndRunNotificationsAreConsistent",
	"Comment": "when executing as junit 3, ignored tests are stripped out before execution",
	"Method": "void descriptionAndRunNotificationsAreConsistent(){\r\n    Result result = JUnitCore.runClasses(CompatibilityTest.class);\r\n    assertEquals(0, result.getIgnoreCount());\r\n    Description description = Request.aClass(CompatibilityTest.class).getRunner().getDescription();\r\n    assertEquals(0, description.getChildren().size());\r\n}"
}, {
	"Path": "lombok.eclipse.EclipseAST.buildArguments",
	"Comment": "arguments are a kind of localdeclaration. they can definitely contain lombok annotations, so we care about them.",
	"Method": "Collection<EclipseNode> buildArguments(Argument[] children){\r\n    List<EclipseNode> childNodes = new ArrayList<EclipseNode>();\r\n    if (children != null)\r\n        for (LocalDeclaration local : children) {\r\n            addIfNotNull(childNodes, buildLocal(local, Kind.ARGUMENT));\r\n        }\r\n    return childNodes;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Matrix4.avg",
	"Comment": "averages the given transforms and stores the result in this matrix. translations and scales are lerped while rotations are\tslerped. does not destroy the data contained in t.",
	"Method": "Matrix4 avg(Matrix4 other,float w,Matrix4 avg,Matrix4[] t,Matrix4 avg,Matrix4[] t,float[] w){\r\n    tmpVec.set(t[0].getScale(tmpUp).scl(w[0]));\r\n    quat.set(t[0].getRotation(quat2).exp(w[0]));\r\n    tmpForward.set(t[0].getTranslation(tmpUp).scl(w[0]));\r\n    for (int i = 1; i < t.length; i++) {\r\n        tmpVec.add(t[i].getScale(tmpUp).scl(w[i]));\r\n        quat.mul(t[i].getRotation(quat2).exp(w[i]));\r\n        tmpForward.add(t[i].getTranslation(tmpUp).scl(w[i]));\r\n    }\r\n    quat.nor();\r\n    setToScaling(tmpVec);\r\n    rotate(quat);\r\n    setTranslation(tmpForward);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint.getMotorForce",
	"Comment": "get the current motor force given the inverse time step, usually in n.",
	"Method": "float getMotorForce(float invDt){\r\n    return joint.getMotorForce(invDt);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.asStringArray",
	"Comment": "returns the children of this value as a newly allocated string array.",
	"Method": "String[] asStringArray(){\r\n    if (type != ValueType.array)\r\n        throw new IllegalStateException(\"Value is not an array: \" + type);\r\n    String[] array = new String[size];\r\n    int i = 0;\r\n    for (JsonValue value = child; value != null; value = value.next, i++) {\r\n        String v;\r\n        switch(value.type) {\r\n            case stringValue:\r\n                v = value.stringValue;\r\n                break;\r\n            case doubleValue:\r\n                v = stringValue != null ? stringValue : Double.toString(value.doubleValue);\r\n                break;\r\n            case longValue:\r\n                v = stringValue != null ? stringValue : Long.toString(value.longValue);\r\n                break;\r\n            case booleanValue:\r\n                v = value.longValue != 0 ? \"true\" : \"false\";\r\n                break;\r\n            case nullValue:\r\n                v = null;\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Value cannot be converted to string: \" + value.type);\r\n        }\r\n        array[i] = v;\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.getElementsByAttributeValue",
	"Comment": "find elements that have an attribute with the specific value. case insensitive.",
	"Method": "Elements getElementsByAttributeValue(String key,String value){\r\n    return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.Field.getDeclaringClass",
	"Comment": "returns the class object representing the class or interface that declares the field.",
	"Method": "Class getDeclaringClass(){\r\n    return field.getDeclaringClass();\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Pixmap.fillTriangle",
	"Comment": "fills a triangle with vertices at x1,y1 and x2,y2 and x3,y3 using the current color.",
	"Method": "void fillTriangle(int x1,int y1,int x2,int y2,int x3,int y3){\r\n    pixmap.fillTriangle(x1, y1, x2, y2, x3, y3, color);\r\n}"
}, {
	"Path": "com.sun.jna.Native.loadNativeDispatchLibrary",
	"Comment": "loads the jna stub library.first tries jna.boot.library.path, then the system path, then from thejar file.",
	"Method": "void loadNativeDispatchLibrary(){\r\n    if (!Boolean.getBoolean(\"jna.nounpack\")) {\r\n        try {\r\n            removeTemporaryFiles();\r\n        } catch (IOException e) {\r\n            LOG.log(Level.WARNING, \"JNA Warning: IOException removing temporary files\", e);\r\n        }\r\n    }\r\n    String libName = System.getProperty(\"jna.boot.library.name\", \"jnidispatch\");\r\n    String bootPath = System.getProperty(\"jna.boot.library.path\");\r\n    if (bootPath != null) {\r\n        StringTokenizer dirs = new StringTokenizer(bootPath, File.pathSeparator);\r\n        while (dirs.hasMoreTokens()) {\r\n            String dir = dirs.nextToken();\r\n            File file = new File(new File(dir), System.mapLibraryName(libName).replace(\".dylib\", \".jnilib\"));\r\n            String path = file.getAbsolutePath();\r\n            LOG.log(DEBUG_JNA_LOAD_LEVEL, \"Looking in {0}\", path);\r\n            if (file.exists()) {\r\n                try {\r\n                    LOG.log(DEBUG_JNA_LOAD_LEVEL, \"Trying {0}\", path);\r\n                    System.setProperty(\"jnidispatch.path\", path);\r\n                    System.load(path);\r\n                    jnidispatchPath = path;\r\n                    LOG.log(DEBUG_JNA_LOAD_LEVEL, \"Found jnidispatch at {0}\", path);\r\n                    return;\r\n                } catch (UnsatisfiedLinkError ex) {\r\n                }\r\n            }\r\n            if (Platform.isMac()) {\r\n                String orig, ext;\r\n                if (path.endsWith(\"dylib\")) {\r\n                    orig = \"dylib\";\r\n                    ext = \"jnilib\";\r\n                } else {\r\n                    orig = \"jnilib\";\r\n                    ext = \"dylib\";\r\n                }\r\n                path = path.substring(0, path.lastIndexOf(orig)) + ext;\r\n                LOG.log(DEBUG_JNA_LOAD_LEVEL, \"Looking in {0}\", path);\r\n                if (new File(path).exists()) {\r\n                    try {\r\n                        LOG.log(DEBUG_JNA_LOAD_LEVEL, \"Trying {0}\", path);\r\n                        System.setProperty(\"jnidispatch.path\", path);\r\n                        System.load(path);\r\n                        jnidispatchPath = path;\r\n                        LOG.log(DEBUG_JNA_LOAD_LEVEL, \"Found jnidispatch at {0}\", path);\r\n                        return;\r\n                    } catch (UnsatisfiedLinkError ex) {\r\n                        LOG.log(Level.WARNING, \"File found at \" + path + \" but not loadable: \" + ex.getMessage(), ex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    String jnaNosys = System.getProperty(\"jna.nosys\", \"true\");\r\n    if ((!Boolean.parseBoolean(jnaNosys)) || Platform.isAndroid()) {\r\n        try {\r\n            LOG.log(DEBUG_JNA_LOAD_LEVEL, \"Trying (via loadLibrary) {0}\", libName);\r\n            System.loadLibrary(libName);\r\n            LOG.log(DEBUG_JNA_LOAD_LEVEL, \"Found jnidispatch on system path\");\r\n            return;\r\n        } catch (UnsatisfiedLinkError e) {\r\n        }\r\n    }\r\n    if (!Boolean.getBoolean(\"jna.noclasspath\")) {\r\n        loadNativeDispatchLibraryFromClasspath();\r\n    } else {\r\n        throw new UnsatisfiedLinkError(\"Unable to locate JNA native support library\");\r\n    }\r\n}"
}, {
	"Path": "org.jsoup.nodes.Attribute.createFromEncoded",
	"Comment": "create a new attribute from an unencoded key and a html attribute encoded value.",
	"Method": "Attribute createFromEncoded(String unencodedKey,String encodedValue){\r\n    String value = Entities.unescape(encodedValue, true);\r\n    return new Attribute(unencodedKey, value, null);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.setParticleDamping",
	"Comment": "damping is used to reduce the velocity of particles. the damping parameter can be larger than1.0f but the damping effect becomes sensitive to the time step when the damping parameter islarge.",
	"Method": "void setParticleDamping(float damping){\r\n    m_particleSystem.setParticleDamping(damping);\r\n}"
}, {
	"Path": "com.badlogic.gdx.tests.bullet.OcclusionBuffer.drawBB",
	"Comment": "renders a bounding box to the depth buffer. does not need to be axis aligned, but will use the translation, rotation and\tscale from the matrix parameter.",
	"Method": "void drawBB(Matrix4 worldTransform,Vector3 halfExt){\r\n    Vector3 center = tmpV1.setZero();\r\n    setAABBVertices(center, halfExt, box);\r\n    worldTransform.getTranslation(center);\r\n    for (Vector3 vertex : box) {\r\n        vertex.rot(worldTransform);\r\n        vertex.add(center);\r\n    }\r\n    drawBox(box, Policy.DRAW);\r\n}"
}, {
	"Path": "org.jsoup.nodes.FormElement.elements",
	"Comment": "get the list of form control elements associated with this form.",
	"Method": "Elements elements(){\r\n    return elements;\r\n}"
}, {
	"Path": "org.junit.runner.notification.RunNotifier.fireTestAssumptionFailed",
	"Comment": "invoke to tell listeners that an atomic test flagged that it assumedsomething false.",
	"Method": "void fireTestAssumptionFailed(Failure failure){\r\n    new SafeNotifier() {\r\n        @Override\r\n        protected void notifyListener(RunListener each) throws Exception {\r\n            each.testAssumptionFailure(failure);\r\n        }\r\n    }.run();\r\n}"
}, {
	"Path": "org.junit.runner.notification.RunNotifier.fireTestAssumptionFailed",
	"Comment": "invoke to tell listeners that an atomic test flagged that it assumedsomething false.",
	"Method": "void fireTestAssumptionFailed(Failure failure){\r\n    each.testAssumptionFailure(failure);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.getBodyList",
	"Comment": "get the world body list. with the returned body, use body.getnext to get the next body in theworld list. a null body indicates the end of the list.",
	"Method": "Body getBodyList(){\r\n    return m_bodyList;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Intersector.intersectLines",
	"Comment": "intersects the two lines and returns the intersection point in intersection.",
	"Method": "boolean intersectLines(Vector2 p1,Vector2 p2,Vector2 p3,Vector2 p4,Vector2 intersection,boolean intersectLines,float x1,float y1,float x2,float y2,float x3,float y3,float x4,float y4,Vector2 intersection){\r\n    float d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\r\n    if (d == 0)\r\n        return false;\r\n    if (intersection != null) {\r\n        float ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / d;\r\n        intersection.set(x1 + (x2 - x1) * ua, y1 + (y2 - y1) * ua);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Bits.and",
	"Comment": "performs a logical and of this target bit set with the argument bit set. this bit set is modified so that each bit in\tit has the value true if and only if it both initially had the value true and the corresponding bit in the bit set argument\talso had the value true.",
	"Method": "void and(Bits other){\r\n    int commonWords = Math.min(bits.length, other.bits.length);\r\n    for (int i = 0; commonWords > i; i++) {\r\n        bits[i] &= other.bits[i];\r\n    }\r\n    if (bits.length > commonWords) {\r\n        for (int i = commonWords, s = bits.length; s > i; i++) {\r\n            bits[i] = 0L;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Bits.intersects",
	"Comment": "returns true if the specified bitset has any bits set to true that are also set to true in this bitset.",
	"Method": "boolean intersects(Bits other){\r\n    long[] bits = this.bits;\r\n    long[] otherBits = other.bits;\r\n    for (int i = Math.min(bits.length, otherBits.length) - 1; i >= 0; i--) {\r\n        if ((bits[i] & otherBits[i]) != 0) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Stage.disableDebug",
	"Comment": "disables debug on all actors recursively except the specified actor and any children.",
	"Method": "void disableDebug(Actor actor,Actor except){\r\n    if (actor == except)\r\n        return;\r\n    actor.setDebug(false);\r\n    if (actor instanceof Group) {\r\n        SnapshotArray<Actor> children = ((Group) actor).children;\r\n        for (int i = 0, n = children.size; i < n; i++) disableDebug(children.get(i), except);\r\n    }\r\n}"
}, {
	"Path": "com.codahale.metrics.Snapshot.get75thPercentile",
	"Comment": "returns the value at the 75th percentile in the distribution.",
	"Method": "double get75thPercentile(){\r\n    return getValue(0.75);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Ellipse.contains",
	"Comment": "checks whether or not this ellipse contains the given point.",
	"Method": "boolean contains(float x,float y,boolean contains,Vector2 point){\r\n    return contains(point.x, point.y);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.model.AbstractDrawerItem.getViewHolder",
	"Comment": "this method returns the viewholder for our item, using the provided view.",
	"Method": "VH getViewHolder(ViewGroup parent,VH getViewHolder,View v){\r\n    return getViewHolder(LayoutInflater.from(parent.getContext()).inflate(getLayoutRes(), parent, false));\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.setType",
	"Comment": "set the type of this body. this may alter the mass and velocity.",
	"Method": "void setType(BodyType type){\r\n    assert (m_world.isLocked() == false);\r\n    if (m_world.isLocked() == true) {\r\n        return;\r\n    }\r\n    if (m_type == type) {\r\n        return;\r\n    }\r\n    m_type = type;\r\n    resetMassData();\r\n    if (m_type == BodyType.STATIC) {\r\n        m_linearVelocity.setZero();\r\n        m_angularVelocity = 0.0f;\r\n        m_sweep.a0 = m_sweep.a;\r\n        m_sweep.c0.set(m_sweep.c);\r\n        synchronizeFixtures();\r\n    }\r\n    setAwake(true);\r\n    m_force.setZero();\r\n    m_torque = 0.0f;\r\n    ContactEdge ce = m_contactList;\r\n    while (ce != null) {\r\n        ContactEdge ce0 = ce;\r\n        ce = ce.next;\r\n        m_world.m_contactManager.destroy(ce0.contact);\r\n    }\r\n    m_contactList = null;\r\n    BroadPhase broadPhase = m_world.m_contactManager.m_broadPhase;\r\n    for (Fixture f = m_fixtureList; f != null; f = f.m_next) {\r\n        int proxyCount = f.m_proxyCount;\r\n        for (int i = 0; i < proxyCount; ++i) {\r\n            broadPhase.touchProxy(f.m_proxies[i].proxyId);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Queue.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "void ensureCapacity(int additional){\r\n    final int needed = size + additional;\r\n    if (values.length < needed) {\r\n        resize(needed);\r\n    }\r\n}"
}, {
	"Path": "org.jsoup.nodes.Document.parser",
	"Comment": "set the parser used to create this document. this parser is then used when further parsing within this documentis required.",
	"Method": "Parser parser(Document parser,Parser parser){\r\n    this.parser = parser;\r\n    return this;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getGravity",
	"Comment": "returns the horizontal and vertical alignment of this textview.",
	"Method": "int getGravity(){\r\n    return mInputView.getGravity();\r\n}"
}, {
	"Path": "java.nio.FloatBuffer.get",
	"Comment": "reads floats from the current position into the specified float array, starting from the specified offset, and increases the\tposition by the number of floats read.",
	"Method": "float get(FloatBuffer get,float[] dest,FloatBuffer get,float[] dest,int off,int len,float get,int index){\r\n    int length = dest.length;\r\n    if (off < 0 || len < 0 || (long) off + (long) len > length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (len > remaining()) {\r\n        throw new BufferUnderflowException();\r\n    }\r\n    for (int i = off; i < off + len; i++) {\r\n        dest[i] = get();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jna.platform.WindowUtils.getWindowLocationAndSize",
	"Comment": "requests the location and size of the window associated with the\tspecified window handle.",
	"Method": "Rectangle getWindowLocationAndSize(HWND hwnd,Rectangle getWindowLocationAndSize,HWND hwnd,Rectangle getWindowLocationAndSize,HWND hwnd){\r\n    return getInstance().getWindowLocationAndSize(hwnd);\r\n}"
}, {
	"Path": "com.sun.jna.PointerType.hashCode",
	"Comment": "the hash code for a pointertype is the same as that forits pointer.",
	"Method": "int hashCode(){\r\n    return pointer != null ? pointer.hashCode() : 0;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.ContactManager.collide",
	"Comment": "this is the top level collision call for the time step. here all the narrow phase collision isprocessed for the world contact list.",
	"Method": "void collide(){\r\n    Contact c = m_contactList;\r\n    while (c != null) {\r\n        Fixture fixtureA = c.getFixtureA();\r\n        Fixture fixtureB = c.getFixtureB();\r\n        int indexA = c.getChildIndexA();\r\n        int indexB = c.getChildIndexB();\r\n        Body bodyA = fixtureA.getBody();\r\n        Body bodyB = fixtureB.getBody();\r\n        if ((c.m_flags & Contact.FILTER_FLAG) == Contact.FILTER_FLAG) {\r\n            if (bodyB.shouldCollide(bodyA) == false) {\r\n                Contact cNuke = c;\r\n                c = cNuke.getNext();\r\n                destroy(cNuke);\r\n                continue;\r\n            }\r\n            if (m_contactFilter != null && m_contactFilter.shouldCollide(fixtureA, fixtureB) == false) {\r\n                Contact cNuke = c;\r\n                c = cNuke.getNext();\r\n                destroy(cNuke);\r\n                continue;\r\n            }\r\n            c.m_flags &= ~Contact.FILTER_FLAG;\r\n        }\r\n        boolean activeA = bodyA.isAwake() && bodyA.m_type != BodyType.STATIC;\r\n        boolean activeB = bodyB.isAwake() && bodyB.m_type != BodyType.STATIC;\r\n        if (activeA == false && activeB == false) {\r\n            c = c.getNext();\r\n            continue;\r\n        }\r\n        int proxyIdA = fixtureA.m_proxies[indexA].proxyId;\r\n        int proxyIdB = fixtureB.m_proxies[indexB].proxyId;\r\n        boolean overlap = m_broadPhase.testOverlap(proxyIdA, proxyIdB);\r\n        if (overlap == false) {\r\n            Contact cNuke = c;\r\n            c = cNuke.getNext();\r\n            destroy(cNuke);\r\n            continue;\r\n        }\r\n        c.update(m_contactListener);\r\n        c = c.getNext();\r\n    }\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getCompoundPaddingStart",
	"Comment": "returns the start padding of the view, plus space for the startdrawable if any.",
	"Method": "int getCompoundPaddingStart(){\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1)\r\n        return mInputView.getCompoundPaddingStart();\r\n    return mInputView.getCompoundPaddingLeft();\r\n}"
}, {
	"Path": "org.junit.rules.ErrorCollector.addError",
	"Comment": "adds a throwable to the table.execution continues, but the test will fail at the end.",
	"Method": "void addError(Throwable error){\r\n    if (error == null) {\r\n        throw new NullPointerException(\"Error cannot be null\");\r\n    }\r\n    if (error instanceof AssumptionViolatedException) {\r\n        AssertionError e = new AssertionError(error.getMessage());\r\n        e.initCause(error);\r\n        errors.add(e);\r\n    } else {\r\n        errors.add(error);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Vector2.crs",
	"Comment": "calculates the 2d cross product between this and the given vector.",
	"Method": "float crs(Vector2 v,float crs,float x,float y){\r\n    return this.x * y - this.y * x;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox.getScrollPane",
	"Comment": "returns the scroll pane containing the list that is shown when the select box is open.",
	"Method": "ScrollPane getScrollPane(){\r\n    return selectBoxList;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.MiniDrawer.withOnMiniDrawerItemClickListener",
	"Comment": "define the onminidraweritemclicklistener called before any logic in the minidrawer is run, allows you to intercept the default behavior",
	"Method": "MiniDrawer withOnMiniDrawerItemClickListener(OnMiniDrawerItemClickListener onMiniDrawerItemClickListener){\r\n    this.mOnMiniDrawerItemClickListener = onMiniDrawerItemClickListener;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.files.FileHandle.readString",
	"Comment": "reads the entire file into a string using the specified charset.",
	"Method": "String readString(String readString,String charset){\r\n    StringBuilder output = new StringBuilder(estimateLength());\r\n    InputStreamReader reader = null;\r\n    try {\r\n        if (charset == null)\r\n            reader = new InputStreamReader(read());\r\n        else\r\n            reader = new InputStreamReader(read(), charset);\r\n        char[] buffer = new char[256];\r\n        while (true) {\r\n            int length = reader.read(buffer);\r\n            if (length == -1)\r\n                break;\r\n            output.append(buffer, 0, length);\r\n        }\r\n    } catch (IOException ex) {\r\n        throw new GdxRuntimeException(\"Error reading layout file: \" + this, ex);\r\n    } finally {\r\n        StreamUtils.closeQuietly(reader);\r\n    }\r\n    return output.toString();\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withCloseOnClick",
	"Comment": "set this to false if the drawer should stay opened after an item was clicked",
	"Method": "DrawerBuilder withCloseOnClick(boolean closeOnClick){\r\n    this.mCloseOnClick = closeOnClick;\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jna.Structure.initializeTypeMapper",
	"Comment": "initialize the type mapper for this structure.if null, the default mapper for thedefining class will be used.",
	"Method": "void initializeTypeMapper(TypeMapper mapper){\r\n    if (mapper == null) {\r\n        mapper = Native.getTypeMapper(getClass());\r\n    }\r\n    this.typeMapper = mapper;\r\n    layoutChanged();\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleController.mul",
	"Comment": "postmultiplies the current transformation with the given matrix.",
	"Method": "void mul(Matrix4 transform){\r\n    this.transform.mul(transform);\r\n    this.transform.getScale(scale);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.collision.BoundingBox.set",
	"Comment": "sets the bounding box minimum and maximum vector from the given points.",
	"Method": "BoundingBox set(BoundingBox bounds,BoundingBox set,Vector3 minimum,Vector3 maximum,BoundingBox set,Vector3[] points,BoundingBox set,List<Vector3> points){\r\n    this.inf();\r\n    for (Vector3 l_point : points) this.ext(l_point);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ByteArray.shrink",
	"Comment": "reduces the size of the backing array to the size of the actual items. this is useful to release memory when many items\thave been removed, or if it is known that more items will not be added.",
	"Method": "byte[] shrink(){\r\n    if (items.length != size)\r\n        resize(size);\r\n    return items;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tests.bullet.OcclusionBuffer.drawDebugTexture",
	"Comment": "draw the depth buffer to a texture. slow, should only be used for debugging purposes.",
	"Method": "TextureRegion drawDebugTexture(){\r\n    if (debugPixmap == null) {\r\n        debugPixmap = new Pixmap(bufferWidth, bufferHeight, Pixmap.Format.RGBA8888);\r\n        debugTexture = new Texture(debugPixmap);\r\n        debugTextureRegion = new TextureRegion(debugTexture);\r\n        debugTextureRegion.flip(false, true);\r\n    }\r\n    debugPixmap.setColor(Color.BLACK);\r\n    debugPixmap.fill();\r\n    float minDepth = Float.POSITIVE_INFINITY;\r\n    float maxDepth = Float.NEGATIVE_INFINITY;\r\n    buffer.clear();\r\n    while (buffer.position() < buffer.capacity()) {\r\n        float depth = MathUtils.clamp(buffer.get(), 0, Float.POSITIVE_INFINITY);\r\n        minDepth = Math.min(depth, minDepth);\r\n        maxDepth = Math.max(depth, maxDepth);\r\n    }\r\n    float extent = 1 / (maxDepth - minDepth);\r\n    buffer.clear();\r\n    for (int x = 0; x < bufferWidth; x++) {\r\n        for (int y = 0; y < bufferHeight; y++) {\r\n            float depth = MathUtils.clamp(buffer.get(x + y * bufferWidth), 0, Float.POSITIVE_INFINITY);\r\n            float c = depth * extent;\r\n            debugPixmap.drawPixel(x, y, Color.rgba8888(c, c, c, 1));\r\n        }\r\n    }\r\n    debugTexture.draw(debugPixmap, 0, 0);\r\n    return debugTextureRegion;\r\n}"
}, {
	"Path": "com.rey.material.app.Dialog.positiveActionTextAppearance",
	"Comment": "sets the text color, size, style of positive action button from the specified textappearance resource.",
	"Method": "Dialog positiveActionTextAppearance(int resId){\r\n    mPositiveAction.setTextAppearance(getContext(), resId);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.getLocalCenter",
	"Comment": "get the local position of the center of mass.\tnote that the same vector2 instance is returned each time this method is called.",
	"Method": "Vector2 getLocalCenter(){\r\n    Vec2 lc = body.getLocalCenter();\r\n    localCenter.set(lc.x, lc.y);\r\n    return localCenter;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Intersector.nearestSegmentPoint",
	"Comment": "returns a point on the segment nearest to the specified point.",
	"Method": "Vector2 nearestSegmentPoint(Vector2 start,Vector2 end,Vector2 point,Vector2 nearest,Vector2 nearestSegmentPoint,float startX,float startY,float endX,float endY,float pointX,float pointY,Vector2 nearest){\r\n    final float xDiff = endX - startX;\r\n    final float yDiff = endY - startY;\r\n    float length2 = xDiff * xDiff + yDiff * yDiff;\r\n    if (length2 == 0)\r\n        return nearest.set(startX, startY);\r\n    float t = ((pointX - startX) * (endX - startX) + (pointY - startY) * (endY - startY)) / length2;\r\n    if (t < 0)\r\n        return nearest.set(startX, startY);\r\n    if (t > 1)\r\n        return nearest.set(endX, endY);\r\n    return nearest.set(startX + t * (endX - startX), startY + t * (endY - startY));\r\n}"
}, {
	"Path": "com.rey.material.app.SimpleDialog.itemTextAppearance",
	"Comment": "sets the text color, size, style of the item view from the specified textappearance resource.",
	"Method": "SimpleDialog itemTextAppearance(int resId){\r\n    if (mItemTextAppearance != resId) {\r\n        mItemTextAppearance = resId;\r\n        if (mAdapter != null)\r\n            mAdapter.notifyDataSetChanged();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jna.Structure.validate",
	"Comment": "indicate whether the given structure class can be created by jna.",
	"Method": "void validate(Class<? extends Structure> cls){\r\n    try {\r\n        cls.getConstructor();\r\n        return;\r\n    } catch (NoSuchMethodException e) {\r\n    } catch (SecurityException e) {\r\n    }\r\n    throw new IllegalArgumentException(\"No suitable constructor found for class: \" + cls.getName());\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.SpriteBatch.createDefaultShader",
	"Comment": "returns a new instance of the default shader used by spritebatch for gl2 when no shader is specified.",
	"Method": "ShaderProgram createDefaultShader(){\r\n    // \r\n    String vertexShader = \"attribute vec4 \" + ShaderProgram.POSITION_ATTRIBUTE + \";\\n\" + \"attribute vec4 \" + ShaderProgram.COLOR_ATTRIBUTE + \";\\n\" + \"attribute vec2 \" + ShaderProgram.TEXCOORD_ATTRIBUTE + \"0;\\n\" + \"uniform mat4 u_projTrans;\\n\" + \"varying vec4 v_color;\\n\" + \"varying vec2 v_texCoords;\\n\" + \"\\n\" + \"void main()\\n\" + \"{\\n\" + \"   v_color = \" + ShaderProgram.COLOR_ATTRIBUTE + \";\\n\" + \"   v_color.a = v_color.a * (255.0/254.0);\\n\" + \"   v_texCoords = \" + ShaderProgram.TEXCOORD_ATTRIBUTE + \"0;\\n\" + \"   gl_Position =  u_projTrans * \" + ShaderProgram.POSITION_ATTRIBUTE + \";\\n\" + \"}\\n\";\r\n    String fragmentShader = \"#ifdef GL_ES\\n\" + \"#define LOWP lowp\\n\" + \"precision mediump float;\\n\" + \"#else\\n\" + \"#define LOWP \\n\" + \"#endif\\n\" + \"varying LOWP vec4 v_color;\\n\" + \"varying vec2 v_texCoords;\\n\" + \"uniform sampler2D u_texture;\\n\" + \"void main()\\n\" + \"{\\n\" + \"  gl_FragColor = v_color * texture2D(u_texture, v_texCoords);\\n\" + \"}\";\r\n    ShaderProgram shader = new ShaderProgram(vertexShader, fragmentShader);\r\n    if (!shader.isCompiled())\r\n        throw new IllegalArgumentException(\"Error compiling shader: \" + shader.getLog());\r\n    return shader;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.Selection.choose",
	"Comment": "selects or deselects the specified item based on how the selection is configured, whether ctrl is currently pressed, etc.\tthis is typically invoked by user interaction.",
	"Method": "void choose(T item){\r\n    if (item == null)\r\n        throw new IllegalArgumentException(\"item cannot be null.\");\r\n    if (isDisabled)\r\n        return;\r\n    snapshot();\r\n    try {\r\n        if ((toggle || (!required && selected.size == 1) || UIUtils.ctrl()) && selected.contains(item)) {\r\n            if (required && selected.size == 1)\r\n                return;\r\n            selected.remove(item);\r\n            lastSelected = null;\r\n        } else {\r\n            boolean modified = false;\r\n            if (!multiple || (!toggle && !UIUtils.ctrl())) {\r\n                if (selected.size == 1 && selected.contains(item))\r\n                    return;\r\n                modified = selected.size > 0;\r\n                selected.clear();\r\n            }\r\n            if (!selected.add(item) && !modified)\r\n                return;\r\n            lastSelected = item;\r\n        }\r\n        if (fireChangeEvent())\r\n            revert();\r\n        else\r\n            changed();\r\n    } finally {\r\n        cleanup();\r\n    }\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.MiniDrawer.getDrawerItems",
	"Comment": "returns always the original draweritems and not the switched content",
	"Method": "List<IDrawerItem> getDrawerItems(){\r\n    return mDrawer.getOriginalDrawerItems() != null ? mDrawer.getOriginalDrawerItems() : mDrawer.getDrawerItems();\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Vector3.dst2",
	"Comment": "returns the squared distance between this point and the given point",
	"Method": "float dst2(float x1,float y1,float z1,float x2,float y2,float z2,float dst2,Vector3 point,float dst2,float x,float y,float z){\r\n    final float a = x - this.x;\r\n    final float b = y - this.y;\r\n    final float c = z - this.z;\r\n    return a * a + b * b + c * c;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ComparableTimSort.gallopRight",
	"Comment": "like gallopleft, except that if the range contains an element equal to key, gallopright returns the index after the\trightmost equal element.",
	"Method": "int gallopRight(Comparable<Object> key,Object[] a,int base,int len,int hint){\r\n    if (DEBUG)\r\n        assert len > 0 && hint >= 0 && hint < len;\r\n    int ofs = 1;\r\n    int lastOfs = 0;\r\n    if (key.compareTo(a[base + hint]) < 0) {\r\n        int maxOfs = hint + 1;\r\n        while (ofs < maxOfs && key.compareTo(a[base + hint - ofs]) < 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        int tmp = lastOfs;\r\n        lastOfs = hint - ofs;\r\n        ofs = hint - tmp;\r\n    } else {\r\n        int maxOfs = len - hint;\r\n        while (ofs < maxOfs && key.compareTo(a[base + hint + ofs]) >= 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        lastOfs += hint;\r\n        ofs += hint;\r\n    }\r\n    if (DEBUG)\r\n        assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;\r\n    lastOfs++;\r\n    while (lastOfs < ofs) {\r\n        int m = lastOfs + ((ofs - lastOfs) >>> 1);\r\n        if (key.compareTo(a[base + m]) < 0)\r\n            ofs = m;\r\n        else\r\n            lastOfs = m + 1;\r\n    }\r\n    if (DEBUG)\r\n        assert lastOfs == ofs;\r\n    return ofs;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.ZipResourceFile.getInputStream",
	"Comment": "getinputstream returns an assetfiledescriptor.autocloseinputstream\tassociated with the asset that is contained in the zip file, or a\tstandard zipinputstream if necessary to uncompress the file",
	"Method": "InputStream getInputStream(String assetPath){\r\n    ZipEntryRO entry = mHashMap.get(assetPath);\r\n    if (null != entry) {\r\n        if (entry.isUncompressed()) {\r\n            return entry.getAssetFileDescriptor().createInputStream();\r\n        } else {\r\n            ZipFile zf = mZipFiles.get(entry.getZipFile());\r\n            if (null == zf) {\r\n                zf = new ZipFile(entry.getZipFile(), ZipFile.OPEN_READ);\r\n                mZipFiles.put(entry.getZipFile(), zf);\r\n            }\r\n            ZipEntry zi = zf.getEntry(assetPath);\r\n            if (null != zi)\r\n                return zf.getInputStream(zi);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Table.getCell",
	"Comment": "returns the cell for the specified actor in this table, or null.",
	"Method": "Cell<T> getCell(T actor){\r\n    Array<Cell> cells = this.cells;\r\n    for (int i = 0, n = cells.size; i < n; i++) {\r\n        Cell c = cells.get(i);\r\n        if (c.actor == actor)\r\n            return c;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "lombok.javac.HandlerLibrary.load",
	"Comment": "creates a new handlerlibrary that will report any problems or errors to the provided messager,\tthen uses spi discovery to load all annotation and visitor based handlers so that future calls\tto the handle methods will defer to these handlers.",
	"Method": "HandlerLibrary load(Messager messager,Trees trees){\r\n    HandlerLibrary library = new HandlerLibrary(messager);\r\n    try {\r\n        loadAnnotationHandlers(library, trees);\r\n        loadVisitorHandlers(library, trees);\r\n    } catch (IOException e) {\r\n        System.err.println(\"Lombok isn't running due to misconfigured SPI files: \" + e);\r\n    }\r\n    library.calculatePriorities();\r\n    return library;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withSliderBackgroundColorRes",
	"Comment": "set the background color for the slider from a resource.this is the view containing the list.",
	"Method": "DrawerBuilder withSliderBackgroundColorRes(int sliderBackgroundColorRes){\r\n    this.mSliderBackgroundColorRes = sliderBackgroundColorRes;\r\n    return this;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.AccountHeaderBuilder.withCloseDrawerOnProfileListClick",
	"Comment": "define if the drawer should close if the user clicks on a profile item if the selection list is shown",
	"Method": "AccountHeaderBuilder withCloseDrawerOnProfileListClick(boolean closeDrawerOnProfileListClick){\r\n    this.mCloseDrawerOnProfileListClick = closeDrawerOnProfileListClick;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.ShaderProgram.compileShaders",
	"Comment": "loads and compiles the shaders, creates a new program and links the shaders.",
	"Method": "void compileShaders(String vertexShader,String fragmentShader){\r\n    vertexShaderHandle = loadShader(GL20.GL_VERTEX_SHADER, vertexShader);\r\n    fragmentShaderHandle = loadShader(GL20.GL_FRAGMENT_SHADER, fragmentShader);\r\n    if (vertexShaderHandle == -1 || fragmentShaderHandle == -1) {\r\n        isCompiled = false;\r\n        return;\r\n    }\r\n    program = linkProgram(createProgram());\r\n    if (program == -1) {\r\n        isCompiled = false;\r\n        return;\r\n    }\r\n    isCompiled = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Pixmap.drawCircle",
	"Comment": "draws a circle outline with the center at x,y and a radius using the current color and stroke width.",
	"Method": "void drawCircle(int x,int y,int radius){\r\n    pixmap.drawCircle(x, y, radius, color);\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.setPaddingLeft",
	"Comment": "sets the padding to the left of a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "void setPaddingLeft(int paddingLeft){\r\n    this.paddingLeft = paddingLeft;\r\n}"
}, {
	"Path": "com.badlogic.gdx.jnigen.FileDescriptor.readString",
	"Comment": "reads the entire file into a string using the specified charset.",
	"Method": "String readString(String readString,String charset){\r\n    StringBuilder output = new StringBuilder(512);\r\n    InputStreamReader reader = null;\r\n    try {\r\n        if (charset == null)\r\n            reader = new InputStreamReader(read());\r\n        else\r\n            reader = new InputStreamReader(read(), charset);\r\n        char[] buffer = new char[256];\r\n        while (true) {\r\n            int length = reader.read(buffer);\r\n            if (length == -1)\r\n                break;\r\n            output.append(buffer, 0, length);\r\n        }\r\n    } catch (IOException ex) {\r\n        throw new RuntimeException(\"Error reading layout file: \" + this, ex);\r\n    } finally {\r\n        try {\r\n            if (reader != null)\r\n                reader.close();\r\n        } catch (IOException ignored) {\r\n        }\r\n    }\r\n    return output.toString();\r\n}"
}, {
	"Path": "com.rey.material.widget.Slider.setPrimaryColor",
	"Comment": "changes the primary color and invalidates the view to force a redraw.",
	"Method": "void setPrimaryColor(int color){\r\n    mPrimaryColor = color;\r\n    invalidate();\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.GuidTest.testGUIDFromString",
	"Comment": "loads a guid from string and verify that the guid returned has the\texpected values in each byte.",
	"Method": "void testGUIDFromString(){\r\n    String sourceGuidStr = \"{A5DCBF10-6530-11D2-901F-00C04FB951ED}\";\r\n    GUID targetGuid = GUID.fromString(sourceGuidStr);\r\n    assertEquals(targetGuid.toGuidString(), sourceGuidStr);\r\n}"
}, {
	"Path": "com.codahale.metrics.MetricRegistry.getTimers",
	"Comment": "returns a map of all the timers in the registry and their names which match the given filter.",
	"Method": "SortedMap<String, Timer> getTimers(SortedMap<String, Timer> getTimers,MetricFilter filter){\r\n    return getMetrics(Timer.class, filter);\r\n}"
}, {
	"Path": "java.nio.BufferFactory.newIntBuffer",
	"Comment": "returns a new array based int buffer with the specified capacity.",
	"Method": "IntBuffer newIntBuffer(int capacity,IntBuffer newIntBuffer,int array){\r\n    return new ReadWriteIntArrayBuffer(array);\r\n}"
}, {
	"Path": "com.github.florent37.materialviewpager.MaterialViewPagerAnimator.setColor",
	"Comment": "change the color of the statusbackground, toolbar, toolbarlayout and pagertitlestripwith a color transition animation",
	"Method": "void setColor(int color,int duration){\r\n    final ValueAnimator colorAnim = ObjectAnimator.ofInt(mHeader.headerBackground, \"backgroundColor\", settings.color, color);\r\n    colorAnim.setEvaluator(new ArgbEvaluator());\r\n    colorAnim.setDuration(duration);\r\n    colorAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r\n        @Override\r\n        public void onAnimationUpdate(ValueAnimator animation) {\r\n            final int animatedValue = (Integer) animation.getAnimatedValue();\r\n            int colorAlpha = colorWithAlpha(animatedValue, lastPercent);\r\n            mHeader.headerBackground.setBackgroundColor(colorAlpha);\r\n            mHeader.statusBackground.setBackgroundColor(colorAlpha);\r\n            mHeader.toolbar.setBackgroundColor(colorAlpha);\r\n            mHeader.toolbarLayoutBackground.setBackgroundColor(colorAlpha);\r\n            mHeader.mPagerSlidingTabStrip.setBackgroundColor(colorAlpha);\r\n            settings.color = animatedValue;\r\n        }\r\n    });\r\n    colorAnim.start();\r\n}"
}, {
	"Path": "com.github.florent37.materialviewpager.MaterialViewPagerAnimator.setColor",
	"Comment": "change the color of the statusbackground, toolbar, toolbarlayout and pagertitlestripwith a color transition animation",
	"Method": "void setColor(int color,int duration){\r\n    final int animatedValue = (Integer) animation.getAnimatedValue();\r\n    int colorAlpha = colorWithAlpha(animatedValue, lastPercent);\r\n    mHeader.headerBackground.setBackgroundColor(colorAlpha);\r\n    mHeader.statusBackground.setBackgroundColor(colorAlpha);\r\n    mHeader.toolbar.setBackgroundColor(colorAlpha);\r\n    mHeader.toolbarLayoutBackground.setBackgroundColor(colorAlpha);\r\n    mHeader.mPagerSlidingTabStrip.setBackgroundColor(colorAlpha);\r\n    settings.color = animatedValue;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.getPosition",
	"Comment": "get the world body origin position.\tnote that the same vector2 instance is returned each time this method is called.",
	"Method": "Vector2 getPosition(){\r\n    Vec2 pos = body.getPosition();\r\n    position.set(pos.x, pos.y);\r\n    return position;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntArray.truncate",
	"Comment": "reduces the size of the array to the specified size. if the array is already smaller than the specified size, no action is",
	"Method": "void truncate(int newSize){\r\n    if (size > newSize)\r\n        size = newSize;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.iosmoe.IOSApplication.addViewControllerListener",
	"Comment": "add a listener to handle events from the libgdx root view controller",
	"Method": "void addViewControllerListener(IOSViewControllerListener listener){\r\n    viewControllerListener = listener;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem.end",
	"Comment": "must be called one time per frame at the end of all drawing operations.",
	"Method": "void end(){\r\n    for (ParticleBatch<?> batch : batches) batch.end();\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Group.swapActor",
	"Comment": "swaps two actors. returns false if the swap did not occur because the actors are not children of this group.",
	"Method": "boolean swapActor(int first,int second,boolean swapActor,Actor first,Actor second){\r\n    int firstIndex = children.indexOf(first, true);\r\n    int secondIndex = children.indexOf(second, true);\r\n    if (firstIndex == -1 || secondIndex == -1)\r\n        return false;\r\n    children.swap(firstIndex, secondIndex);\r\n    return true;\r\n}"
}, {
	"Path": "org.junit.runners.model.TestClass.collectAnnotatedFieldValues",
	"Comment": "finds the fields annotated with the specified annotation and having the specified type,retrieves the values and passes those to the specified consumer.",
	"Method": "void collectAnnotatedFieldValues(Object test,Class<? extends Annotation> annotationClass,Class<T> valueClass,MemberValueConsumer<T> consumer){\r\n    for (FrameworkField each : getAnnotatedFields(annotationClass)) {\r\n        try {\r\n            Object fieldValue = each.get(test);\r\n            if (valueClass.isInstance(fieldValue)) {\r\n                consumer.accept(each, valueClass.cast(fieldValue));\r\n            }\r\n        } catch (IllegalAccessException e) {\r\n            throw new RuntimeException(\"How did getFields return a field we couldn't access?\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.isEqual",
	"Comment": "returns true if a is nearly equal to b. the function uses the default floating error tolerance.",
	"Method": "boolean isEqual(float a,float b,boolean isEqual,float a,float b,float tolerance){\r\n    return Math.abs(a - b) <= tolerance;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.Sprite.getVertices",
	"Comment": "returns the packed vertices, colors, and texture coordinates for this sprite.",
	"Method": "float[] getVertices(){\r\n    if (dirty) {\r\n        dirty = false;\r\n        float[] vertices = this.vertices;\r\n        float localX = -originX;\r\n        float localY = -originY;\r\n        float localX2 = localX + width;\r\n        float localY2 = localY + height;\r\n        float worldOriginX = this.x - localX;\r\n        float worldOriginY = this.y - localY;\r\n        if (scaleX != 1 || scaleY != 1) {\r\n            localX *= scaleX;\r\n            localY *= scaleY;\r\n            localX2 *= scaleX;\r\n            localY2 *= scaleY;\r\n        }\r\n        if (rotation != 0) {\r\n            final float cos = MathUtils.cosDeg(rotation);\r\n            final float sin = MathUtils.sinDeg(rotation);\r\n            final float localXCos = localX * cos;\r\n            final float localXSin = localX * sin;\r\n            final float localYCos = localY * cos;\r\n            final float localYSin = localY * sin;\r\n            final float localX2Cos = localX2 * cos;\r\n            final float localX2Sin = localX2 * sin;\r\n            final float localY2Cos = localY2 * cos;\r\n            final float localY2Sin = localY2 * sin;\r\n            final float x1 = localXCos - localYSin + worldOriginX;\r\n            final float y1 = localYCos + localXSin + worldOriginY;\r\n            vertices[X1] = x1;\r\n            vertices[Y1] = y1;\r\n            final float x2 = localXCos - localY2Sin + worldOriginX;\r\n            final float y2 = localY2Cos + localXSin + worldOriginY;\r\n            vertices[X2] = x2;\r\n            vertices[Y2] = y2;\r\n            final float x3 = localX2Cos - localY2Sin + worldOriginX;\r\n            final float y3 = localY2Cos + localX2Sin + worldOriginY;\r\n            vertices[X3] = x3;\r\n            vertices[Y3] = y3;\r\n            vertices[X4] = x1 + (x3 - x2);\r\n            vertices[Y4] = y3 - (y2 - y1);\r\n        } else {\r\n            final float x1 = localX + worldOriginX;\r\n            final float y1 = localY + worldOriginY;\r\n            final float x2 = localX2 + worldOriginX;\r\n            final float y2 = localY2 + worldOriginY;\r\n            vertices[X1] = x1;\r\n            vertices[Y1] = y1;\r\n            vertices[X2] = x1;\r\n            vertices[Y2] = y2;\r\n            vertices[X3] = x2;\r\n            vertices[Y3] = y2;\r\n            vertices[X4] = x2;\r\n            vertices[Y4] = y1;\r\n        }\r\n    }\r\n    return vertices;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.destroyBody",
	"Comment": "destroy a rigid body given a definition. no reference to the definition is retained. this function is locked during\tcallbacks.",
	"Method": "void destroyBody(Body body){\r\n    JointEdge jointEdge = body.body.getJointList();\r\n    while (jointEdge != null) {\r\n        JointEdge next = jointEdge.next;\r\n        world.destroyJoint(jointEdge.joint);\r\n        joints.remove(jointEdge.joint);\r\n        jointEdge = next;\r\n    }\r\n    world.destroyBody(body.body);\r\n    bodies.remove(body.body);\r\n    for (Fixture fixture : body.fixtures) {\r\n        fixtures.remove(fixture.fixture);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Polygon.scale",
	"Comment": "applies additional scaling to the polygon by the supplied amount.",
	"Method": "void scale(float amount){\r\n    this.scaleX += amount;\r\n    this.scaleY += amount;\r\n    dirty = true;\r\n}"
}, {
	"Path": "com.sun.jna.Memory.setInt",
	"Comment": "indirect the native pointer to malloc space, a lapointer.setint.but this method performs a boundschecks to ensure that the indirection does not cause memory outside themalloced space to be accessed.",
	"Method": "void setInt(long offset,int value){\r\n    boundsCheck(offset, 4);\r\n    super.setInt(offset, value);\r\n}"
}, {
	"Path": "org.jbox2d.common.OBBViewportTransform.getTransform",
	"Comment": "gets the transform of the viewport, transforms around the center. not a copy.",
	"Method": "Mat22 getTransform(){\r\n    return box.R;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getCompoundPaddingBottom",
	"Comment": "returns the bottom padding of the view, plus space for the bottomdrawable if any.",
	"Method": "int getCompoundPaddingBottom(){\r\n    return mInputView.getCompoundPaddingBottom();\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineEffect.setJoin",
	"Comment": "sets how the corners of the outline are drawn. this is usually only noticeable at large outline widths.",
	"Method": "void setJoin(int join){\r\n    this.join = join;\r\n}"
}, {
	"Path": "org.junit.runners.model.TestClass.collectAnnotatedMethodValues",
	"Comment": "finds the methods annotated with the specified annotation and returning the specified type,invokes it and pass the return value to the specified consumer.",
	"Method": "void collectAnnotatedMethodValues(Object test,Class<? extends Annotation> annotationClass,Class<T> valueClass,MemberValueConsumer<T> consumer){\r\n    for (FrameworkMethod each : getAnnotatedMethods(annotationClass)) {\r\n        try {\r\n            if (valueClass.isAssignableFrom(each.getReturnType())) {\r\n                Object fieldValue = each.invokeExplosively(test);\r\n                consumer.accept(each, valueClass.cast(fieldValue));\r\n            }\r\n        } catch (Throwable e) {\r\n            throw new RuntimeException(\"Exception in \" + each.getName(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.getElementsByIndexGreaterThan",
	"Comment": "find elements whose sibling index is greater than the supplied index.",
	"Method": "Elements getElementsByIndexGreaterThan(int index){\r\n    return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Color.mul",
	"Comment": "multiplies all components of this color with the given value.",
	"Method": "Color mul(Color color,Color mul,float value,Color mul,float r,float g,float b,float a){\r\n    this.r *= r;\r\n    this.g *= g;\r\n    this.b *= b;\r\n    this.a *= a;\r\n    return clamp();\r\n}"
}, {
	"Path": "com.codahale.metrics.Snapshot.get95thPercentile",
	"Comment": "returns the value at the 95th percentile in the distribution.",
	"Method": "double get95thPercentile(){\r\n    return getValue(0.95);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.app.drawerItems.CustomUrlBasePrimaryDrawerItem.bindViewHelper",
	"Comment": "a helper method to have the logic for all secondarydraweritems only once",
	"Method": "void bindViewHelper(CustomBaseViewHolder viewHolder){\r\n    Context ctx = viewHolder.itemView.getContext();\r\n    viewHolder.itemView.setId(hashCode());\r\n    viewHolder.itemView.setSelected(isSelected());\r\n    int selectedColor = getSelectedColor(ctx);\r\n    int color = getColor(ctx);\r\n    int selectedTextColor = getSelectedTextColor(ctx);\r\n    themeDrawerItem(ctx, viewHolder.view, selectedColor, isSelectedBackgroundAnimated());\r\n    StringHolder.applyTo(this.getName(), viewHolder.name);\r\n    StringHolder.applyToOrHide(this.getDescription(), viewHolder.description);\r\n    viewHolder.name.setTextColor(getTextColorStateList(color, selectedTextColor));\r\n    ColorHolder.applyToOr(getDescriptionTextColor(), viewHolder.description, getTextColorStateList(color, selectedTextColor));\r\n    if (getTypeface() != null) {\r\n        viewHolder.name.setTypeface(getTypeface());\r\n        viewHolder.description.setTypeface(getTypeface());\r\n    }\r\n    DrawerImageLoader.getInstance().cancelImage(viewHolder.icon);\r\n    viewHolder.icon.setImageBitmap(null);\r\n    ImageHolder.applyTo(icon, viewHolder.icon, \"customUrlItem\");\r\n    DrawerUIUtils.setDrawerVerticalPadding(viewHolder.view);\r\n}"
}, {
	"Path": "org.jbox2d.collision.shapes.Shape.getRadius",
	"Comment": "the radius of the underlying shape. this can refer to different things depending on the shapeimplementation",
	"Method": "float getRadius(){\r\n    return m_radius;\r\n}"
}, {
	"Path": "com.sun.jna.CallbackThreadInitializer.getName",
	"Comment": "returns the desired name for this thread, or null for the default.",
	"Method": "String getName(Callback cb){\r\n    return name;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Node.siblingIndex",
	"Comment": "get the list index of this node in its node sibling list. i.e. if this is the first nodesibling, returns 0.",
	"Method": "int siblingIndex(){\r\n    return siblingIndex;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.BooleanArray.setSize",
	"Comment": "sets the array size, leaving any values beyond the current size undefined.",
	"Method": "boolean[] setSize(int newSize){\r\n    if (newSize < 0)\r\n        throw new IllegalArgumentException(\"newSize must be >= 0: \" + newSize);\r\n    if (newSize > items.length)\r\n        resize(Math.max(8, newSize));\r\n    size = newSize;\r\n    return items;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getCompoundDrawables",
	"Comment": "returns drawables for the left, top, right, and bottom borders.",
	"Method": "Drawable[] getCompoundDrawables(){\r\n    return mInputView.getCompoundDrawables();\r\n}"
}, {
	"Path": "com.codahale.metrics.Snapshot.get99thPercentile",
	"Comment": "returns the value at the 99th percentile in the distribution.",
	"Method": "double get99thPercentile(){\r\n    return getValue(0.99);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Fixture.getShape",
	"Comment": "get the child shape. you can modify the child shape, however you should not change the numberof vertices because this will crash some collision caching mechanisms.",
	"Method": "Shape getShape(){\r\n    return m_shape;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleController.draw",
	"Comment": "updates the renderer used by this controller, usually this means the particles will be draw inside a batch.",
	"Method": "void draw(){\r\n    if (particles.size > 0) {\r\n        renderer.update();\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.CharArray.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "char[] ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded > items.length)\r\n        resize(Math.max(8, sizeNeeded));\r\n    return items;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.trace",
	"Comment": "returns a human readable string representing the path from the root of the json object graph to this value.",
	"Method": "String trace(){\r\n    if (parent == null) {\r\n        if (type == ValueType.array)\r\n            return \"[]\";\r\n        if (type == ValueType.object)\r\n            return \"{}\";\r\n        return \"\";\r\n    }\r\n    String trace;\r\n    if (parent.type == ValueType.array) {\r\n        trace = \"[]\";\r\n        int i = 0;\r\n        for (JsonValue child = parent.child; child != null; child = child.next, i++) {\r\n            if (child == this) {\r\n                trace = \"[\" + i + \"]\";\r\n                break;\r\n            }\r\n        }\r\n    } else if (name.indexOf('.') != -1)\r\n        trace = \".\\\"\" + name.replace(\"\\\"\", \"\\\\\\\"\") + \"\\\"\";\r\n    else\r\n        trace = '.' + name;\r\n    return parent.trace() + trace;\r\n}"
}, {
	"Path": "org.jbox2d.callbacks.ContactFilter.shouldCollide",
	"Comment": "return true if contact calculations should be performed between these two shapes.",
	"Method": "boolean shouldCollide(Fixture fixtureA,Fixture fixtureB){\r\n    Filter filterA = fixtureA.getFilterData();\r\n    Filter filterB = fixtureB.getFilterData();\r\n    if (filterA.groupIndex == filterB.groupIndex && filterA.groupIndex != 0) {\r\n        return filterA.groupIndex > 0;\r\n    }\r\n    boolean collide = (filterA.maskBits & filterB.categoryBits) != 0 && (filterA.categoryBits & filterB.maskBits) != 0;\r\n    return collide;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.RevoluteJointDef.initialize",
	"Comment": "initialize the bodies, anchors, and reference angle using the world anchor.",
	"Method": "void initialize(Body b1,Body b2,Vec2 anchor){\r\n    bodyA = b1;\r\n    bodyB = b2;\r\n    bodyA.getLocalPointToOut(anchor, localAnchorA);\r\n    bodyB.getLocalPointToOut(anchor, localAnchorB);\r\n    referenceAngle = bodyB.getAngle() - bodyA.getAngle();\r\n}"
}, {
	"Path": "com.sun.jna.Memory.setByte",
	"Comment": "indirect the native pointer to malloc space, a lapointer.setbyte.but this method performs a boundschecks to ensure that the indirection does not cause memory outside themalloced space to be accessed.",
	"Method": "void setByte(long offset,byte value){\r\n    boundsCheck(offset, 1);\r\n    super.setByte(offset, value);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectSet.add",
	"Comment": "returns true if the key was not already in the set. if this set already contains the key, the call leaves the set unchanged\tand returns false.",
	"Method": "boolean add(T key){\r\n    if (key == null)\r\n        throw new IllegalArgumentException(\"key cannot be null.\");\r\n    T[] keyTable = this.keyTable;\r\n    int hashCode = key.hashCode();\r\n    int index1 = hashCode & mask;\r\n    T key1 = keyTable[index1];\r\n    if (key.equals(key1))\r\n        return false;\r\n    int index2 = hash2(hashCode);\r\n    T key2 = keyTable[index2];\r\n    if (key.equals(key2))\r\n        return false;\r\n    int index3 = hash3(hashCode);\r\n    T key3 = keyTable[index3];\r\n    if (key.equals(key3))\r\n        return false;\r\n    for (int i = capacity, n = i + stashSize; i < n; i++) if (key.equals(keyTable[i]))\r\n        return false;\r\n    if (key1 == null) {\r\n        keyTable[index1] = key;\r\n        if (size++ >= threshold)\r\n            resize(capacity << 1);\r\n        return true;\r\n    }\r\n    if (key2 == null) {\r\n        keyTable[index2] = key;\r\n        if (size++ >= threshold)\r\n            resize(capacity << 1);\r\n        return true;\r\n    }\r\n    if (key3 == null) {\r\n        keyTable[index3] = key;\r\n        if (size++ >= threshold)\r\n            resize(capacity << 1);\r\n        return true;\r\n    }\r\n    push(key, index1, key1, index2, key2, index3, key3);\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.AbstractWin32TestSupport.checkCOMRegistered",
	"Comment": "return true if the supplied uuid can be found in the registry.",
	"Method": "boolean checkCOMRegistered(String uuid){\r\n    WinReg.HKEYByReference phkKey = null;\r\n    try {\r\n        phkKey = Advapi32Util.registryGetKey(WinReg.HKEY_CLASSES_ROOT, \"Interface\\\\\" + uuid, WinNT.KEY_READ);\r\n        if (phkKey != null) {\r\n            return true;\r\n        }\r\n    } catch (Win32Exception ex) {\r\n    } finally {\r\n        if (phkKey != null && phkKey.getValue() != null) {\r\n            Advapi32Util.registryCloseKey(phkKey.getValue());\r\n        }\r\n    }\r\n    try {\r\n        phkKey = Advapi32Util.registryGetKey(WinReg.HKEY_CLASSES_ROOT, \"CLSID\\\\\" + uuid, WinNT.KEY_READ);\r\n        if (phkKey != null) {\r\n            return true;\r\n        }\r\n    } catch (Win32Exception ex) {\r\n    } finally {\r\n        if (phkKey != null && phkKey.getValue() != null) {\r\n            Advapi32Util.registryCloseKey(phkKey.getValue());\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Group.clear",
	"Comment": "removes all children, actions, and listeners from this group.",
	"Method": "void clear(){\r\n    super.clear();\r\n    clearChildren();\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withSelectedItemByPosition",
	"Comment": "set this to the index of the item, you would love to select upon start",
	"Method": "DrawerBuilder withSelectedItemByPosition(int selectedItemPosition){\r\n    this.mSelectedItemPosition = selectedItemPosition;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.asByteArray",
	"Comment": "returns the children of this value as a newly allocated byte array.",
	"Method": "byte[] asByteArray(){\r\n    if (type != ValueType.array)\r\n        throw new IllegalStateException(\"Value is not an array: \" + type);\r\n    byte[] array = new byte[size];\r\n    int i = 0;\r\n    for (JsonValue value = child; value != null; value = value.next, i++) {\r\n        byte v;\r\n        switch(value.type) {\r\n            case stringValue:\r\n                v = Byte.parseByte(value.stringValue);\r\n                break;\r\n            case doubleValue:\r\n                v = (byte) value.doubleValue;\r\n                break;\r\n            case longValue:\r\n                v = (byte) value.longValue;\r\n                break;\r\n            case booleanValue:\r\n                v = value.longValue != 0 ? (byte) 1 : 0;\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Value cannot be converted to byte: \" + value.type);\r\n        }\r\n        array[i] = v;\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Vector3.rot",
	"Comment": "multiplies this vector by the first three columns of the matrix, essentially only applying rotation and scaling.",
	"Method": "Vector3 rot(Matrix4 matrix){\r\n    final float[] l_mat = matrix.val;\r\n    return this.set(x * l_mat[Matrix4.M00] + y * l_mat[Matrix4.M01] + z * l_mat[Matrix4.M02], x * l_mat[Matrix4.M10] + y * l_mat[Matrix4.M11] + z * l_mat[Matrix4.M12], x * l_mat[Matrix4.M20] + y * l_mat[Matrix4.M21] + z * l_mat[Matrix4.M22]);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Tree.getIndentSpacing",
	"Comment": "returns the amount of horizontal space for indentation level.",
	"Method": "float getIndentSpacing(){\r\n    return indentSpacing;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.handleShowOnLaunch",
	"Comment": "helper method to handle when the drawer should be shown on launch",
	"Method": "void handleShowOnLaunch(){\r\n    if (mActivity != null && mDrawerLayout != null) {\r\n        if (mShowDrawerOnFirstLaunch || mShowDrawerUntilDraggedOpened) {\r\n            final SharedPreferences preferences = mSharedPreferences != null ? mSharedPreferences : PreferenceManager.getDefaultSharedPreferences(mActivity);\r\n            if (mShowDrawerOnFirstLaunch && !preferences.getBoolean(Drawer.PREF_USER_LEARNED_DRAWER, false)) {\r\n                mDrawerLayout.openDrawer(mSliderLayout);\r\n                SharedPreferences.Editor editor = preferences.edit();\r\n                editor.putBoolean(Drawer.PREF_USER_LEARNED_DRAWER, true);\r\n                editor.apply();\r\n            } else if (mShowDrawerUntilDraggedOpened && !preferences.getBoolean(Drawer.PREF_USER_OPENED_DRAWER_BY_DRAGGING, false)) {\r\n                mDrawerLayout.openDrawer(mSliderLayout);\r\n                mDrawerLayout.addDrawerListener(new DrawerLayout.SimpleDrawerListener() {\r\n                    boolean hasBeenDragged = false;\r\n                    @Override\r\n                    public void onDrawerStateChanged(int newState) {\r\n                        if (newState == DrawerLayout.STATE_DRAGGING) {\r\n                            hasBeenDragged = true;\r\n                        } else if (newState == DrawerLayout.STATE_IDLE) {\r\n                            if (hasBeenDragged && mDrawerLayout.isDrawerOpen(mDrawerGravity)) {\r\n                                SharedPreferences.Editor editor = preferences.edit();\r\n                                editor.putBoolean(Drawer.PREF_USER_OPENED_DRAWER_BY_DRAGGING, true);\r\n                                editor.apply();\r\n                            } else {\r\n                                hasBeenDragged = false;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.handleShowOnLaunch",
	"Comment": "helper method to handle when the drawer should be shown on launch",
	"Method": "void handleShowOnLaunch(){\r\n    if (newState == DrawerLayout.STATE_DRAGGING) {\r\n        hasBeenDragged = true;\r\n    } else if (newState == DrawerLayout.STATE_IDLE) {\r\n        if (hasBeenDragged && mDrawerLayout.isDrawerOpen(mDrawerGravity)) {\r\n            SharedPreferences.Editor editor = preferences.edit();\r\n            editor.putBoolean(Drawer.PREF_USER_OPENED_DRAWER_BY_DRAGGING, true);\r\n            editor.apply();\r\n        } else {\r\n            hasBeenDragged = false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.ParticleEmitter.scaleMotion",
	"Comment": "permanently scales the speed of the emitter by scaling all its ranged values related to motion.",
	"Method": "void scaleMotion(float scale){\r\n    if (scale == 1f)\r\n        return;\r\n    for (RangedNumericValue value : getMotionValues()) value.scale(scale);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleController.killParticles",
	"Comment": "generally called by the emitter. this method will notify all the sub systems that a given amount of particles has been\tkilled.",
	"Method": "void killParticles(int startIndex,int count){\r\n    emitter.killParticles(startIndex, count);\r\n    for (Influencer influencer : influencers) influencer.killParticles(startIndex, count);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.GeometryUtils.fromBarycoord",
	"Comment": "returns an interpolated value given the barycentric coordinates of a point in a triangle and the values at each vertex.",
	"Method": "Vector2 fromBarycoord(Vector2 barycentric,Vector2 a,Vector2 b,Vector2 c,Vector2 interpolatedOut,float fromBarycoord,Vector2 barycentric,float a,float b,float c){\r\n    float u = 1 - barycentric.x - barycentric.y;\r\n    return u * a + barycentric.x * b + barycentric.y * c;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.getBoolean",
	"Comment": "finds the child with the specified index and returns it as a boolean.",
	"Method": "boolean getBoolean(String name,boolean defaultValue,boolean getBoolean,String name,boolean getBoolean,int index){\r\n    JsonValue child = get(index);\r\n    if (child == null)\r\n        throw new IllegalArgumentException(\"Indexed value not found: \" + name);\r\n    return child.asBoolean();\r\n}"
}, {
	"Path": "com.squareup.leakcanary.HahaHelper.asString",
	"Comment": "given a string instance from the heap dump, this returns its actual string value.",
	"Method": "String asString(Object stringObject){\r\n    checkNotNull(stringObject, \"stringObject\");\r\n    Instance instance = (Instance) stringObject;\r\n    List<ClassInstance.FieldValue> values = classInstanceValues(instance);\r\n    Integer count = fieldValue(values, \"count\");\r\n    checkNotNull(count, \"count\");\r\n    if (count == 0) {\r\n        return \"\";\r\n    }\r\n    Object value = fieldValue(values, \"value\");\r\n    checkNotNull(value, \"value\");\r\n    Integer offset;\r\n    ArrayInstance array;\r\n    if (isCharArray(value)) {\r\n        array = (ArrayInstance) value;\r\n        offset = 0;\r\n        if (hasField(values, \"offset\")) {\r\n            offset = fieldValue(values, \"offset\");\r\n            checkNotNull(offset, \"offset\");\r\n        }\r\n        char[] chars = array.asCharArray(offset, count);\r\n        return new String(chars);\r\n    } else if (isByteArray(value)) {\r\n        array = (ArrayInstance) value;\r\n        try {\r\n            Method asRawByteArray = ArrayInstance.class.getDeclaredMethod(\"asRawByteArray\", int.class, int.class);\r\n            asRawByteArray.setAccessible(true);\r\n            byte[] rawByteArray = (byte[]) asRawByteArray.invoke(array, 0, count);\r\n            return new String(rawByteArray, Charset.forName(\"UTF-8\"));\r\n        } catch (NoSuchMethodException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (IllegalAccessException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (InvocationTargetException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    } else {\r\n        throw new UnsupportedOperationException(\"Could not find char array in \" + instance);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.getAscent",
	"Comment": "gets the distance from the baseline to the y drawing location.",
	"Method": "int getAscent(){\r\n    return ascent;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.collision.btManifoldPoint.obtainForArgument",
	"Comment": "obtains a temporary instance, used for callback methods with one or more btmanifoldpoint arguments",
	"Method": "btManifoldPoint obtainForArgument(long swigCPtr,boolean owner){\r\n    btManifoldPoint instance = argumentInstances[argumentIndex = (argumentIndex + 1) & 3];\r\n    instance.reset(swigCPtr, owner);\r\n    return instance;\r\n}"
}, {
	"Path": "lombok.javac.handlers.HandleSuperBuilder.generateBuilderBasedConstructor",
	"Comment": "generates a constructor that has a builder as the only parameter.\tthe values from the builder are used to initialize the fields of new instances.",
	"Method": "void generateBuilderBasedConstructor(JavacNode typeNode,List<JCTypeParameter> typeParams,java.util.List<BuilderFieldData> builderFields,JavacNode source,String builderClassName,boolean callBuilderBasedSuperConstructor){\r\n    JavacTreeMaker maker = typeNode.getTreeMaker();\r\n    AccessLevel level = AccessLevel.PROTECTED;\r\n    ListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\r\n    Name builderVariableName = typeNode.toName(BUILDER_VARIABLE_NAME);\r\n    for (BuilderFieldData bfd : builderFields) {\r\n        JCExpression rhs;\r\n        if (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {\r\n            bfd.singularData.getSingularizer().appendBuildCode(bfd.singularData, bfd.originalFieldNode, bfd.type, statements, bfd.name, \"b\");\r\n            rhs = maker.Ident(bfd.singularData.getPluralName());\r\n        } else {\r\n            rhs = maker.Select(maker.Ident(builderVariableName), bfd.name);\r\n        }\r\n        JCFieldAccess fieldInThis = maker.Select(maker.Ident(typeNode.toName(\"this\")), bfd.rawName);\r\n        JCStatement assign = maker.Exec(maker.Assign(fieldInThis, rhs));\r\n        if (bfd.nameOfSetFlag != null) {\r\n            JCFieldAccess setField = maker.Select(maker.Ident(builderVariableName), bfd.nameOfSetFlag);\r\n            fieldInThis = maker.Select(maker.Ident(typeNode.toName(\"this\")), bfd.rawName);\r\n            JCAssign assignDefault = maker.Assign(fieldInThis, maker.Apply(typeParameterNames(maker, ((JCClassDecl) typeNode.get()).typarams), maker.Select(maker.Ident(((JCClassDecl) typeNode.get()).name), bfd.nameOfDefaultProvider), List.<JCExpression>nil()));\r\n            statements.append(maker.If(setField, assign, maker.Exec(assignDefault)));\r\n        } else {\r\n            statements.append(assign);\r\n        }\r\n        if (hasNonNullAnnotations(bfd.originalFieldNode)) {\r\n            JCStatement nullCheck = generateNullCheck(maker, bfd.originalFieldNode, source);\r\n            if (nullCheck != null)\r\n                statements.append(nullCheck);\r\n        }\r\n    }\r\n    JCModifiers mods = maker.Modifiers(toJavacModifier(level), List.<JCAnnotation>nil());\r\n    ListBuffer<JCVariableDecl> params = new ListBuffer<JCVariableDecl>();\r\n    long flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, typeNode.getContext());\r\n    Name builderClassname = typeNode.toName(builderClassName);\r\n    ListBuffer<JCExpression> typeParamsForBuilderParameter = getTypeParamExpressions(typeParams, maker);\r\n    JCWildcard wildcard = maker.Wildcard(maker.TypeBoundKind(BoundKind.UNBOUND), null);\r\n    typeParamsForBuilderParameter.add(wildcard);\r\n    wildcard = maker.Wildcard(maker.TypeBoundKind(BoundKind.UNBOUND), null);\r\n    typeParamsForBuilderParameter.add(wildcard);\r\n    JCTypeApply paramType = maker.TypeApply(maker.Ident(builderClassname), typeParamsForBuilderParameter.toList());\r\n    JCVariableDecl param = maker.VarDef(maker.Modifiers(flags), builderVariableName, paramType, null);\r\n    params.append(param);\r\n    if (callBuilderBasedSuperConstructor) {\r\n        JCMethodInvocation callToSuperConstructor = maker.Apply(List.<JCExpression>nil(), maker.Ident(typeNode.toName(\"super\")), List.<JCExpression>of(maker.Ident(builderVariableName)));\r\n        statements.prepend(maker.Exec(callToSuperConstructor));\r\n    }\r\n    JCMethodDecl constr = recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName(\"<init>\"), null, List.<JCTypeParameter>nil(), params.toList(), List.<JCExpression>nil(), maker.Block(0L, statements.toList()), null), source.get(), typeNode.getContext());\r\n    injectMethod(typeNode, constr, null, Javac.createVoidType(typeNode.getSymbolTable(), CTC_VOID));\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.createBody",
	"Comment": "create a rigid body given a definition. no reference to the definition is retained.",
	"Method": "Body createBody(BodyDef def){\r\n    assert (isLocked() == false);\r\n    if (isLocked()) {\r\n        return null;\r\n    }\r\n    Body b = new Body(def, this);\r\n    b.m_prev = null;\r\n    b.m_next = m_bodyList;\r\n    if (m_bodyList != null) {\r\n        m_bodyList.m_prev = b;\r\n    }\r\n    m_bodyList = b;\r\n    ++m_bodyCount;\r\n    return b;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Actor.getStage",
	"Comment": "returns the stage that this actor is currently in, or null if not in a stage.",
	"Method": "Stage getStage(){\r\n    return stage;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Dialog.button",
	"Comment": "adds a text button to the button table. the dialog must have been constructed with a skin to use this method.",
	"Method": "Dialog button(String text,Dialog button,String text,Object object,Dialog button,String text,Object object,TextButtonStyle buttonStyle,Dialog button,Button button,Dialog button,Button button,Object object){\r\n    buttonTable.add(button);\r\n    setObject(button, object);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.setAutoClearForces",
	"Comment": "set flag to control automatic clearing of forces after each time step.",
	"Method": "void setAutoClearForces(boolean flag){\r\n    world.setAutoClearForces(flag);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withSliderBackgroundDrawableRes",
	"Comment": "set the background drawable for the slider from a resource.this is the view containing the list.",
	"Method": "DrawerBuilder withSliderBackgroundDrawableRes(int sliderBackgroundDrawableRes){\r\n    this.mSliderBackgroundDrawableRes = sliderBackgroundDrawableRes;\r\n    return this;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.getLinearVelocityFromWorldPoint",
	"Comment": "get the world linear velocity of a world point attached to this body.",
	"Method": "Vec2 getLinearVelocityFromWorldPoint(Vec2 worldPoint){\r\n    Vec2 out = new Vec2();\r\n    getLinearVelocityFromWorldPointToOut(worldPoint, out);\r\n    return out;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParallelArray.removeElement",
	"Comment": "removes the element at the given index and swaps it with the last available element",
	"Method": "void removeElement(int index){\r\n    int last = size - 1;\r\n    for (Channel strideArray : arrays) {\r\n        strideArray.swap(index, last);\r\n    }\r\n    size = last;\r\n}"
}, {
	"Path": "java.nio.LongBuffer.toString",
	"Comment": "returns a string representing the state of this long buffer.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(getClass().getName());\r\n    sb.append(\", status: capacity=\");\r\n    sb.append(capacity());\r\n    sb.append(\" position=\");\r\n    sb.append(position());\r\n    sb.append(\" limit=\");\r\n    sb.append(limit());\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.rey.material.app.SimpleDialog.onSelectionChangedListener",
	"Comment": "set a listener will be called when the checked state of a item is changed.",
	"Method": "SimpleDialog onSelectionChangedListener(OnSelectionChangedListener listener){\r\n    mOnSelectionChangedListener = listener;\r\n    return this;\r\n}"
}, {
	"Path": "lombok.eclipse.Eclipse.isPrimitive",
	"Comment": "checks if the given type reference represents a primitive type.",
	"Method": "boolean isPrimitive(TypeReference ref){\r\n    if (ref.dimensions() > 0)\r\n        return false;\r\n    return PRIMITIVE_TYPE_NAME_PATTERN.matcher(toQualifiedName(ref.getTypeName())).matches();\r\n}"
}, {
	"Path": "com.codahale.metrics.SharedMetricRegistries.setDefault",
	"Comment": "sets the provided registry as the default one under the provided name",
	"Method": "MetricRegistry setDefault(String name,MetricRegistry setDefault,String name,MetricRegistry metricRegistry){\r\n    if (defaultRegistryName.compareAndSet(null, name)) {\r\n        add(name, metricRegistry);\r\n        return metricRegistry;\r\n    }\r\n    throw new IllegalStateException(\"Default metric registry name is already set.\");\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getTotalPaddingTop",
	"Comment": "returns the total top padding of the view, including the topdrawable if any, the extra space to keep more than maxlinesfrom showing, and the vertical offset for gravity, if any.",
	"Method": "int getTotalPaddingTop(){\r\n    return getPaddingTop() + mInputView.getTotalPaddingTop() + (mLabelEnable ? mLabelView.getHeight() : 0);\r\n}"
}, {
	"Path": "org.jsoup.internal.StringUtil.releaseBuilder",
	"Comment": "release a borrowed builder. care must be taken not to use the builder after it has been returned, as itscontents may be changed by this method, or by a concurrent thread.",
	"Method": "String releaseBuilder(StringBuilder sb){\r\n    Validate.notNull(sb);\r\n    String string = sb.toString();\r\n    if (sb.length() > MaxCachedBuilderSize)\r\n        sb = new StringBuilder(MaxCachedBuilderSize);\r\n    else\r\n        sb.delete(0, sb.length());\r\n    synchronized (builders) {\r\n        builders.push(sb);\r\n        while (builders.size() > MaxIdleBuilders) {\r\n            builders.pop();\r\n        }\r\n    }\r\n    return string;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar.generateText",
	"Comment": "generate the text to display within the progress bar. override this function to change the default progress percent to a\tmore informative message, such as the number of kilobytes downloaded.",
	"Method": "String generateText(double curProgress){\r\n    if (textFormatter != null) {\r\n        return textFormatter.getText(this, curProgress);\r\n    } else {\r\n        return (int) (100 * getPercent()) + \"%\";\r\n    }\r\n}"
}, {
	"Path": "com.sun.jna.Pointer.share",
	"Comment": "provide a view of this memory using the given offset to calculate a new base address.",
	"Method": "Pointer share(long offset,Pointer share,long offset,long sz,Pointer share,long offset,long size){\r\n    if (offset == 0L) {\r\n        return this;\r\n    }\r\n    return new Pointer(peer + offset);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Table.defaults",
	"Comment": "the cell values that will be used as the defaults for all cells.",
	"Method": "Cell defaults(){\r\n    return cellDefaults;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.SharedLibraryLoader.canWrite",
	"Comment": "returns true if the parent directories of the file can be created and the file can be written.",
	"Method": "boolean canWrite(File file){\r\n    File parent = file.getParentFile();\r\n    File testFile;\r\n    if (file.exists()) {\r\n        if (!file.canWrite() || !canExecute(file))\r\n            return false;\r\n        testFile = new File(parent, UUID.randomUUID().toString());\r\n    } else {\r\n        parent.mkdirs();\r\n        if (!parent.isDirectory())\r\n            return false;\r\n        testFile = file;\r\n    }\r\n    try {\r\n        new FileOutputStream(testFile).close();\r\n        if (!canExecute(testFile))\r\n            return false;\r\n        return true;\r\n    } catch (Throwable ex) {\r\n        return false;\r\n    } finally {\r\n        testFile.delete();\r\n    }\r\n}"
}, {
	"Path": "java.nio.BufferFactory.newDirectByteBuffer",
	"Comment": "returns a new direct byte buffer with the specified capacity.",
	"Method": "ByteBuffer newDirectByteBuffer(int capacity){\r\n    return new DirectReadWriteByteBuffer(capacity);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.decals.DecalBatch.initialize",
	"Comment": "initializes the batch with the given amount of decal objects the buffer is able to hold when full.",
	"Method": "void initialize(int size){\r\n    vertices = new float[size * Decal.SIZE];\r\n    Mesh.VertexDataType vertexDataType = Mesh.VertexDataType.VertexArray;\r\n    if (Gdx.gl30 != null) {\r\n        vertexDataType = Mesh.VertexDataType.VertexBufferObjectWithVAO;\r\n    }\r\n    mesh = new Mesh(vertexDataType, false, size * 4, size * 6, new VertexAttribute(VertexAttributes.Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(VertexAttributes.Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE), new VertexAttribute(VertexAttributes.Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + \"0\"));\r\n    short[] indices = new short[size * 6];\r\n    int v = 0;\r\n    for (int i = 0; i < indices.length; i += 6, v += 4) {\r\n        indices[i] = (short) (v);\r\n        indices[i + 1] = (short) (v + 2);\r\n        indices[i + 2] = (short) (v + 1);\r\n        indices[i + 3] = (short) (v + 1);\r\n        indices[i + 4] = (short) (v + 2);\r\n        indices[i + 5] = (short) (v + 3);\r\n    }\r\n    mesh.setIndices(indices);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withFullscreen",
	"Comment": "set to true if the used theme has a translucent statusbarand navigationbar and you want to manage the padding on your own.",
	"Method": "DrawerBuilder withFullscreen(boolean fullscreen){\r\n    this.mFullscreen = fullscreen;\r\n    if (fullscreen) {\r\n        withTranslucentStatusBar(true);\r\n        withTranslucentNavigationBar(false);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gwtref.client.Method.invoke",
	"Comment": "invokes the method on the given object. ignores the object if this is a static method. throws an illegalargumentexception if\tthe parameters do not match.",
	"Method": "Object invoke(Object obj,Object params){\r\n    if (parameters.length != (params != null ? params.length : 0))\r\n        throw new IllegalArgumentException(\"Parameter mismatch\");\r\n    return ReflectionCache.invoke(this, obj, params);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.model.Node.calculateBoundingBox",
	"Comment": "calculate the bounding box of this node. this is a potential slow operation, it is advised to cache the result.",
	"Method": "BoundingBox calculateBoundingBox(BoundingBox out,BoundingBox calculateBoundingBox,BoundingBox out,boolean transform){\r\n    out.inf();\r\n    return extendBoundingBox(out, transform);\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.texturepacker.TextureUnpacker.extractNinePatch",
	"Comment": "extract a ninepatch from a texture atlas, according to the android specification.",
	"Method": "BufferedImage extractNinePatch(BufferedImage page,Region region,File outputDirFile){\r\n    BufferedImage splitImage = extractImage(page, region, outputDirFile, NINEPATCH_PADDING);\r\n    Graphics2D g2 = splitImage.createGraphics();\r\n    g2.setColor(Color.BLACK);\r\n    int startX = region.splits[0] + NINEPATCH_PADDING;\r\n    int endX = region.width - region.splits[1] + NINEPATCH_PADDING - 1;\r\n    int startY = region.splits[2] + NINEPATCH_PADDING;\r\n    int endY = region.height - region.splits[3] + NINEPATCH_PADDING - 1;\r\n    if (endX >= startX)\r\n        g2.drawLine(startX, 0, endX, 0);\r\n    if (endY >= startY)\r\n        g2.drawLine(0, startY, 0, endY);\r\n    if (region.pads != null) {\r\n        int padStartX = region.pads[0] + NINEPATCH_PADDING;\r\n        int padEndX = region.width - region.pads[1] + NINEPATCH_PADDING - 1;\r\n        int padStartY = region.pads[2] + NINEPATCH_PADDING;\r\n        int padEndY = region.height - region.pads[3] + NINEPATCH_PADDING - 1;\r\n        g2.drawLine(padStartX, splitImage.getHeight() - 1, padEndX, splitImage.getHeight() - 1);\r\n        g2.drawLine(splitImage.getWidth() - 1, padStartY, splitImage.getWidth() - 1, padEndY);\r\n    }\r\n    g2.dispose();\r\n    return splitImage;\r\n}"
}, {
	"Path": "com.rey.material.app.Dialog.neutralActionTextAppearance",
	"Comment": "sets the text color, size, style of neutral action button from the specified textappearance resource.",
	"Method": "Dialog neutralActionTextAppearance(int resId){\r\n    mNeutralAction.setTextAppearance(getContext(), resId);\r\n    return this;\r\n}"
}, {
	"Path": "org.junit.runner.notification.Failure.getTrimmedTrace",
	"Comment": "gets a the printed form of the exception, with a trimmed version of the stack trace.this method will attempt to filter out frames of the stack trace that are belowthe test method call.",
	"Method": "String getTrimmedTrace(){\r\n    return Throwables.getTrimmedStackTrace(getException());\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.destroyBody",
	"Comment": "destroy a rigid body given a definition. no reference to the definition is retained. thisfunction is locked during callbacks.",
	"Method": "void destroyBody(Body body){\r\n    assert (m_bodyCount > 0);\r\n    assert (isLocked() == false);\r\n    if (isLocked()) {\r\n        return;\r\n    }\r\n    JointEdge je = body.m_jointList;\r\n    while (je != null) {\r\n        JointEdge je0 = je;\r\n        je = je.next;\r\n        if (m_destructionListener != null) {\r\n            m_destructionListener.sayGoodbye(je0.joint);\r\n        }\r\n        destroyJoint(je0.joint);\r\n        body.m_jointList = je;\r\n    }\r\n    body.m_jointList = null;\r\n    ContactEdge ce = body.m_contactList;\r\n    while (ce != null) {\r\n        ContactEdge ce0 = ce;\r\n        ce = ce.next;\r\n        m_contactManager.destroy(ce0.contact);\r\n    }\r\n    body.m_contactList = null;\r\n    Fixture f = body.m_fixtureList;\r\n    while (f != null) {\r\n        Fixture f0 = f;\r\n        f = f.m_next;\r\n        if (m_destructionListener != null) {\r\n            m_destructionListener.sayGoodbye(f0);\r\n        }\r\n        f0.destroyProxies(m_contactManager.m_broadPhase);\r\n        f0.destroy();\r\n        body.m_fixtureList = f;\r\n        body.m_fixtureCount -= 1;\r\n    }\r\n    body.m_fixtureList = null;\r\n    body.m_fixtureCount = 0;\r\n    if (body.m_prev != null) {\r\n        body.m_prev.m_next = body.m_next;\r\n    }\r\n    if (body.m_next != null) {\r\n        body.m_next.m_prev = body.m_prev;\r\n    }\r\n    if (body == m_bodyList) {\r\n        m_bodyList = body.m_next;\r\n    }\r\n    --m_bodyCount;\r\n}"
}, {
	"Path": "com.codahale.metrics.MetricRegistry.getMeters",
	"Comment": "returns a map of all the meters in the registry and their names which match the given filter.",
	"Method": "SortedMap<String, Meter> getMeters(SortedMap<String, Meter> getMeters,MetricFilter filter){\r\n    return getMetrics(Meter.class, filter);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.FloatArray.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "float[] ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded > items.length)\r\n        resize(Math.max(8, sizeNeeded));\r\n    return items;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.floorPositive",
	"Comment": "returns the largest integer less than or equal to the specified float. this method will only properly floor floats that are\tpositive. note this method simply casts the float to int.",
	"Method": "int floorPositive(float value){\r\n    return (int) value;\r\n}"
}, {
	"Path": "com.rey.material.widget.SnackBar.textAppearance",
	"Comment": "sets the text color, size, style from the specified textappearance resource.",
	"Method": "SnackBar textAppearance(int resId){\r\n    if (resId != 0)\r\n        mText.setTextAppearance(getContext(), resId);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ByteArray.random",
	"Comment": "returns a random item from the array, or zero if the array is empty.",
	"Method": "byte random(){\r\n    if (size == 0)\r\n        return 0;\r\n    return items[MathUtils.random(0, size - 1)];\r\n}"
}, {
	"Path": "com.rey.material.widget.TabPageIndicator.setOnPageChangeListener",
	"Comment": "set a listener will be called when the current page is changed.",
	"Method": "void setOnPageChangeListener(ViewPager.OnPageChangeListener listener){\r\n    mListener = listener;\r\n}"
}, {
	"Path": "org.junit.runners.model.InitializationError.getCauses",
	"Comment": "returns one or more throwables that led to this initialization error.",
	"Method": "List<Throwable> getCauses(){\r\n    return fErrors;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Matrix3.scl",
	"Comment": "scale this matrix using the x and y components of the vector but leave the rest of the matrix alone.",
	"Method": "Matrix3 scl(float scale,Matrix3 scl,Vector2 scale,Matrix3 scl,Vector3 scale){\r\n    val[M00] *= scale.x;\r\n    val[M11] *= scale.y;\r\n    return this;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.getPosition",
	"Comment": "the world position of the body. avoid creating bodies at the origin since this can lead to manyoverlapping shapes.",
	"Method": "Vec2 getPosition(){\r\n    return position;\r\n}"
}, {
	"Path": "com.badlogic.gdx.assets.AssetManager.update",
	"Comment": "updates the assetmanager continuously for the specified number of milliseconds, yielding the cpu to the loading thread\tbetween updates. this may block for less time if all loading tasks are complete. this may block for more time if the portion\tof a single task that happens in the gl thread takes a long time.",
	"Method": "boolean update(boolean update,int millis){\r\n    long endTime = TimeUtils.millis() + millis;\r\n    while (true) {\r\n        boolean done = update();\r\n        if (done || TimeUtils.millis() > endTime)\r\n            return done;\r\n        ThreadUtils.yield();\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.iosmoe.IOSApplication.getBounds",
	"Comment": "gl view spans whole screen, that is, even under the status bar. ios can also rotate the screen, which is not handled\tconsistently over ios versions. this method returns, in pixels, rectangle in which libgdx draws.",
	"Method": "CGRect getBounds(){\r\n    final CGRect screenBounds = getOriginalBounds();\r\n    final long statusBarOrientation = getStatusBarOrientation();\r\n    double screenWidth = screenBounds.size().width();\r\n    double screenHeight = screenBounds.size().height();\r\n    if (statusBarOrientation == UIInterfaceOrientation.LandscapeLeft || statusBarOrientation == UIInterfaceOrientation.LandscapeRight) {\r\n        if (screenHeight > screenWidth) {\r\n            debug(\"IOSApplication\", \"Switching reported width and height (w=\" + screenWidth + \" h=\" + screenHeight + \")\");\r\n            double tmp = screenHeight;\r\n            screenHeight = screenWidth;\r\n            screenWidth = tmp;\r\n        }\r\n    }\r\n    screenWidth *= displayScaleFactor;\r\n    screenHeight *= displayScaleFactor;\r\n    double statusBarHeight = getStatusBarHeight(screenHeight);\r\n    debug(\"IOSApplication\", \"Total computed bounds are w=\" + screenWidth + \" h=\" + screenHeight);\r\n    return lastScreenBounds = new CGRect(new CGPoint(0, statusBarHeight), new CGSize(screenWidth, screenHeight));\r\n}"
}, {
	"Path": "lombok.javac.JavacAST.removeDeferredErrors",
	"Comment": "attempts to remove any compiler errors generated by java whose reporting position is located anywhere between the start and end of the supplied node.",
	"Method": "void removeDeferredErrors(JavacNode node){\r\n    DiagnosticPosition pos = node.get().pos();\r\n    JCCompilationUnit top = (JCCompilationUnit) top().get();\r\n    removeFromDeferredDiagnostics(pos.getStartPosition(), Javac.getEndPosition(pos, top));\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.ceilPositive",
	"Comment": "returns the smallest integer greater than or equal to the specified float. this method will only properly ceil floats that\tare positive.",
	"Method": "int ceilPositive(float value){\r\n    return (int) (value + CEIL);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.PolygonSprite.getVertices",
	"Comment": "returns the packed vertices, colors, and texture coordinates for this sprite.",
	"Method": "float[] getVertices(){\r\n    if (!dirty)\r\n        return vertices;\r\n    dirty = false;\r\n    final float originX = this.originX;\r\n    final float originY = this.originY;\r\n    final float scaleX = this.scaleX;\r\n    final float scaleY = this.scaleY;\r\n    final PolygonRegion region = this.region;\r\n    final float[] vertices = this.vertices;\r\n    final float[] regionVertices = region.vertices;\r\n    final float worldOriginX = x + originX;\r\n    final float worldOriginY = y + originY;\r\n    final float sX = width / region.region.getRegionWidth();\r\n    final float sY = height / region.region.getRegionHeight();\r\n    final float cos = MathUtils.cosDeg(rotation);\r\n    final float sin = MathUtils.sinDeg(rotation);\r\n    float fx, fy;\r\n    for (int i = 0, v = 0, n = regionVertices.length; i < n; i += 2, v += 5) {\r\n        fx = (regionVertices[i] * sX - originX) * scaleX;\r\n        fy = (regionVertices[i + 1] * sY - originY) * scaleY;\r\n        vertices[v] = cos * fx - sin * fy + worldOriginX;\r\n        vertices[v + 1] = sin * fx + cos * fy + worldOriginY;\r\n    }\r\n    return vertices;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Bits.nextClearBit",
	"Comment": "returns the index of the first bit that is set to false that occurs on or after the specified starting index.",
	"Method": "int nextClearBit(int fromIndex){\r\n    long[] bits = this.bits;\r\n    int word = fromIndex >>> 6;\r\n    int bitsLength = bits.length;\r\n    if (word >= bitsLength)\r\n        return bits.length << 6;\r\n    long bitsAtWord = bits[word];\r\n    for (int i = fromIndex & 0x3f; i < 64; i++) {\r\n        if ((bitsAtWord & (1L << (i & 0x3F))) == 0L) {\r\n            return (word << 6) + i;\r\n        }\r\n    }\r\n    for (word++; word < bitsLength; word++) {\r\n        if (word == 0) {\r\n            return word << 6;\r\n        }\r\n        bitsAtWord = bits[word];\r\n        for (int i = 0; i < 64; i++) {\r\n            if ((bitsAtWord & (1L << (i & 0x3F))) == 0L) {\r\n                return (word << 6) + i;\r\n            }\r\n        }\r\n    }\r\n    return bits.length << 6;\r\n}"
}, {
	"Path": "org.jbox2d.collision.Collision.findMaxSeparation",
	"Comment": "find the max separation between poly1 and poly2 using edge normals from poly1.",
	"Method": "void findMaxSeparation(EdgeResults results,PolygonShape poly1,Transform xf1,PolygonShape poly2,Transform xf2){\r\n    int count1 = poly1.m_count;\r\n    int count2 = poly2.m_count;\r\n    Vec2[] n1s = poly1.m_normals;\r\n    Vec2[] v1s = poly1.m_vertices;\r\n    Vec2[] v2s = poly2.m_vertices;\r\n    Transform.mulTransToOutUnsafe(xf2, xf1, xf);\r\n    final Rot xfq = xf.q;\r\n    int bestIndex = 0;\r\n    float maxSeparation = -Float.MAX_VALUE;\r\n    for (int i = 0; i < count1; i++) {\r\n        Rot.mulToOutUnsafe(xfq, n1s[i], n);\r\n        Transform.mulToOutUnsafe(xf, v1s[i], v1);\r\n        float si = Float.MAX_VALUE;\r\n        for (int j = 0; j < count2; ++j) {\r\n            Vec2 v2sj = v2s[j];\r\n            float sij = n.x * (v2sj.x - v1.x) + n.y * (v2sj.y - v1.y);\r\n            if (sij < si) {\r\n                si = sij;\r\n            }\r\n        }\r\n        if (si > maxSeparation) {\r\n            maxSeparation = si;\r\n            bestIndex = i;\r\n        }\r\n    }\r\n    results.edgeIndex = bestIndex;\r\n    results.separation = maxSeparation;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Fixture.testPoint",
	"Comment": "test a point for containment in this fixture. this only works for convex shapes.",
	"Method": "boolean testPoint(Vec2 p){\r\n    return m_shape.testPoint(m_body.m_xf, p);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.MiniDrawer.withAccountHeader",
	"Comment": "provide the accountheader which will be used as the datasource for the profiles",
	"Method": "MiniDrawer withAccountHeader(AccountHeader accountHeader){\r\n    this.mAccountHeader = accountHeader;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.getPaddingBottom",
	"Comment": "returns the padding below a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "int getPaddingBottom(){\r\n    return paddingBottom;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Intersector.intersectRayTriangles",
	"Comment": "intersects the given ray with list of triangles. returns the nearest intersection point in intersection",
	"Method": "boolean intersectRayTriangles(Ray ray,float[] triangles,Vector3 intersection,boolean intersectRayTriangles,Ray ray,float[] vertices,short[] indices,int vertexSize,Vector3 intersection,boolean intersectRayTriangles,Ray ray,List<Vector3> triangles,Vector3 intersection){\r\n    float min_dist = Float.MAX_VALUE;\r\n    boolean hit = false;\r\n    if (triangles.size() % 3 != 0)\r\n        throw new RuntimeException(\"triangle list size is not a multiple of 3\");\r\n    for (int i = 0; i < triangles.size() - 2; i += 3) {\r\n        boolean result = intersectRayTriangle(ray, triangles.get(i), triangles.get(i + 1), triangles.get(i + 2), tmp);\r\n        if (result) {\r\n            float dist = ray.origin.dst2(tmp);\r\n            if (dist < min_dist) {\r\n                min_dist = dist;\r\n                best.set(tmp);\r\n                hit = true;\r\n            }\r\n        }\r\n    }\r\n    if (!hit)\r\n        return false;\r\n    else {\r\n        if (intersection != null)\r\n            intersection.set(best);\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.bringPointIntoView",
	"Comment": "move the point, specified by the offset, into the view if it is needed.this has to be called after layout. returns true if anything changed.",
	"Method": "boolean bringPointIntoView(int offset){\r\n    return mInputView.bringPointIntoView(offset);\r\n}"
}, {
	"Path": "com.rey.material.widget.ListPopupWindow.setListItemExpandMax",
	"Comment": "the maximum number of list items that can be visible and still havethe list expand when touched.",
	"Method": "void setListItemExpandMax(int max){\r\n    mListItemExpandMaximum = max;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Mesh.getVertices",
	"Comment": "copies the specified vertices from the mesh to the float array. the float array must be large enough to hold count vertices.",
	"Method": "float[] getVertices(float[] vertices,float[] getVertices,int srcOffset,float[] vertices,float[] getVertices,int srcOffset,int count,float[] vertices,float[] getVertices,int srcOffset,int count,float[] vertices,int destOffset){\r\n    final int max = getNumVertices() * getVertexSize() / 4;\r\n    if (count == -1) {\r\n        count = max - srcOffset;\r\n        if (count > vertices.length - destOffset)\r\n            count = vertices.length - destOffset;\r\n    }\r\n    if (srcOffset < 0 || count <= 0 || (srcOffset + count) > max || destOffset < 0 || destOffset >= vertices.length)\r\n        throw new IndexOutOfBoundsException();\r\n    if ((vertices.length - destOffset) < count)\r\n        throw new IllegalArgumentException(\"not enough room in vertices array, has \" + vertices.length + \" floats, needs \" + count);\r\n    int pos = getVerticesBuffer().position();\r\n    getVerticesBuffer().position(srcOffset);\r\n    getVerticesBuffer().get(vertices, destOffset, count);\r\n    getVerticesBuffer().position(pos);\r\n    return vertices;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.getLinearDamping",
	"Comment": "linear damping is use to reduce the linear velocity. the damping parameter can be larger than1.0f but the damping effect becomes sensitive to the time step when the damping parameter islarge.",
	"Method": "float getLinearDamping(){\r\n    return linearDamping;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.FloatArray.removeRange",
	"Comment": "removes the items between the specified indices, inclusive.",
	"Method": "void removeRange(int start,int end){\r\n    if (end >= size)\r\n        throw new IndexOutOfBoundsException(\"end can't be >= size: \" + end + \" >= \" + size);\r\n    if (start > end)\r\n        throw new IndexOutOfBoundsException(\"start can't be > end: \" + start + \" > \" + end);\r\n    float[] items = this.items;\r\n    int count = end - start + 1;\r\n    if (ordered)\r\n        System.arraycopy(items, start + count, items, start, size - (start + count));\r\n    else {\r\n        int lastIndex = this.size - 1;\r\n        for (int i = 0; i < count; i++) items[start + i] = items[lastIndex - i];\r\n    }\r\n    size -= count;\r\n}"
}, {
	"Path": "com.sun.jna.CallbackReference.getCallback",
	"Comment": "return a callback associated with the given function pointer.if the pointer refers to a java callback trampoline, return the originaljava callback.otherwise, return a proxy to the native functionpointer.",
	"Method": "Callback getCallback(Class<?> type,Pointer p,Callback getCallback,Class<?> type,Pointer p,boolean direct,Callback getCallback,Callback getCallback){\r\n    return get();\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.resetMassData",
	"Comment": "this resets the mass properties to the sum of the mass properties of the fixtures. this normally does not need to be called\tunless you called setmassdata to override the mass and you later want to reset the mass.",
	"Method": "void resetMassData(){\r\n    body.resetMassData();\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.AccountHeaderBuilder.withSelectionSecondLine",
	"Comment": "set this to define the second line in the selection area if there is no profilenote this will block any values from profiles!",
	"Method": "AccountHeaderBuilder withSelectionSecondLine(String selectionSecondLine){\r\n    this.mSelectionSecondLine = selectionSecondLine;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.List.setSelected",
	"Comment": "sets the selection to only the passed item, if it is a possible choice.",
	"Method": "void setSelected(T item){\r\n    if (items.contains(item, false))\r\n        selection.set(item);\r\n    else if (selection.getRequired() && items.size > 0)\r\n        selection.set(items.first());\r\n    else\r\n        selection.clear();\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Matrix3.set",
	"Comment": "sets this 3x3 matrix to the top left 3x3 corner of the provided 4x4 matrix.",
	"Method": "Matrix3 set(Matrix3 mat,Matrix3 set,Affine2 affine,Matrix3 set,Matrix4 mat,Matrix3 set,float[] values){\r\n    System.arraycopy(values, 0, val, 0, val.length);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.RepeatablePolygonSprite.offset",
	"Comment": "offsets polygon to 0 coordinate for ease of calculations, later offset is put back on final render",
	"Method": "float[] offset(float[] vertices){\r\n    offset.set(vertices[0], vertices[1]);\r\n    for (int i = 0; i < vertices.length - 1; i += 2) {\r\n        if (offset.x > vertices[i]) {\r\n            offset.x = vertices[i];\r\n        }\r\n        if (offset.y > vertices[i + 1]) {\r\n            offset.y = vertices[i + 1];\r\n        }\r\n    }\r\n    for (int i = 0; i < vertices.length; i += 2) {\r\n        vertices[i] -= offset.x;\r\n        vertices[i + 1] -= offset.y;\r\n    }\r\n    return vertices;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.collision.BoundingBox.contains",
	"Comment": "returns whether the given vector is contained in this bounding box.",
	"Method": "boolean contains(BoundingBox b,boolean contains,Vector3 v){\r\n    return min.x <= v.x && max.x >= v.x && min.y <= v.y && max.y >= v.y && min.z <= v.z && max.z >= v.z;\r\n}"
}, {
	"Path": "com.rey.material.app.Dialog.negativeActionClickListener",
	"Comment": "set a listener will be called when negative action button is clicked.",
	"Method": "Dialog negativeActionClickListener(View.OnClickListener listener){\r\n    mNegativeAction.setOnClickListener(listener);\r\n    return this;\r\n}"
}, {
	"Path": "junit.runner.BaseTestRunner.processArguments",
	"Comment": "processes the command line arguments andreturns the name of the suite class to run or null",
	"Method": "String processArguments(String[] args){\r\n    String suiteName = null;\r\n    for (int i = 0; i < args.length; i++) {\r\n        if (args[i].equals(\"-noloading\")) {\r\n            setLoading(false);\r\n        } else if (args[i].equals(\"-nofilterstack\")) {\r\n            fgFilterStack = false;\r\n        } else if (args[i].equals(\"-c\")) {\r\n            if (args.length > i + 1) {\r\n                suiteName = extractClassName(args[i + 1]);\r\n            } else {\r\n                System.out.println(\"Missing Test class name\");\r\n            }\r\n            i++;\r\n        } else {\r\n            suiteName = args[i];\r\n        }\r\n    }\r\n    return suiteName;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withFooter",
	"Comment": "add a footer to the drawerbuilder listview defined by a resource.",
	"Method": "DrawerBuilder withFooter(View footerView,DrawerBuilder withFooter,int footerViewRes){\r\n    if (mActivity == null) {\r\n        throw new RuntimeException(\"please pass an activity first to use this call\");\r\n    }\r\n    if (footerViewRes != -1) {\r\n        this.mFooterView = mActivity.getLayoutInflater().inflate(footerViewRes, null, false);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "junit.samples.money.Money.add",
	"Comment": "adds a money to this money. forwards the request to the addmoney helper.",
	"Method": "IMoney add(IMoney m){\r\n    return m.addMoney(this);\r\n}"
}, {
	"Path": "java.nio.CharBuffer.allocate",
	"Comment": "creates a char buffer based on a newly allocated char array.",
	"Method": "CharBuffer allocate(int capacity){\r\n    if (capacity < 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return BufferFactory.newCharBuffer(capacity);\r\n}"
}, {
	"Path": "com.orhanobut.logger.Logger.log",
	"Comment": "general log function that accepts all configurations as parameter",
	"Method": "void log(int priority,String tag,String message,Throwable throwable){\r\n    printer.log(priority, tag, message, throwable);\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.getElementsMatchingOwnText",
	"Comment": "find elements whose text matches the supplied regular expression.",
	"Method": "Elements getElementsMatchingOwnText(Pattern pattern,Elements getElementsMatchingOwnText,String regex){\r\n    Pattern pattern;\r\n    try {\r\n        pattern = Pattern.compile(regex);\r\n    } catch (PatternSyntaxException e) {\r\n        throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\r\n    }\r\n    return getElementsMatchingOwnText(pattern);\r\n}"
}, {
	"Path": "java.nio.CharBuffer.charAt",
	"Comment": "returns the character located at the specified index in the buffer. the index value is referenced from the current buffer\tposition.",
	"Method": "char charAt(int index){\r\n    if (index < 0 || index >= remaining()) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    return get(position + index);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.decals.Decal.getPosition",
	"Comment": "returns the position of this decal. the returned vector should under no circumstances be modified.",
	"Method": "Vector3 getPosition(){\r\n    return position;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withGenerateMiniDrawer",
	"Comment": "define if the drawerbuilder should also generate a minidrawer for th",
	"Method": "DrawerBuilder withGenerateMiniDrawer(boolean generateMiniDrawer){\r\n    this.mGenerateMiniDrawer = generateMiniDrawer;\r\n    return this;\r\n}"
}, {
	"Path": "org.jsoup.parser.Tokeniser.unescapeEntities",
	"Comment": "utility method to consume reader and unescape entities found within.",
	"Method": "String unescapeEntities(boolean inAttribute){\r\n    StringBuilder builder = StringUtil.borrowBuilder();\r\n    while (!reader.isEmpty()) {\r\n        builder.append(reader.consumeTo('&'));\r\n        if (reader.matches('&')) {\r\n            reader.consume();\r\n            int[] c = consumeCharacterReference(null, inAttribute);\r\n            if (c == null || c.length == 0)\r\n                builder.append('&');\r\n            else {\r\n                builder.appendCodePoint(c[0]);\r\n                if (c.length == 2)\r\n                    builder.appendCodePoint(c[1]);\r\n            }\r\n        }\r\n    }\r\n    return StringUtil.releaseBuilder(builder);\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph.getShape",
	"Comment": "the shape to use to draw this glyph. this is set to null after the glyph is stored in a glyphpage.",
	"Method": "Shape getShape(){\r\n    return shape;\r\n}"
}, {
	"Path": "lombok.javac.handlers.JavacHandlerUtil.generateNullCheck",
	"Comment": "generates a new statement that checks if the given variable is null, and if so, throws a configured exception with the\tvariable name as message.",
	"Method": "JCStatement generateNullCheck(JavacTreeMaker maker,JavacNode variable,JavacNode source,JCStatement generateNullCheck,JavacTreeMaker maker,JavacNode variable,JCVariableDecl varDecl,JavacNode source){\r\n    NullCheckExceptionType exceptionType = source.getAst().readConfiguration(ConfigurationKeys.NON_NULL_EXCEPTION_TYPE);\r\n    if (exceptionType == null)\r\n        exceptionType = NullCheckExceptionType.NULL_POINTER_EXCEPTION;\r\n    if (isPrimitive(varDecl.vartype))\r\n        return null;\r\n    Name fieldName = varDecl.name;\r\n    JCExpression exType = genTypeRef(variable, exceptionType.getExceptionType());\r\n    JCExpression exception = maker.NewClass(null, List.<JCExpression>nil(), exType, List.<JCExpression>of(maker.Literal(exceptionType.toExceptionMessage(fieldName.toString()))), null);\r\n    JCStatement throwStatement = maker.Throw(exception);\r\n    JCBlock throwBlock = maker.Block(0, List.of(throwStatement));\r\n    return maker.If(maker.Binary(CTC_EQUAL, maker.Ident(fieldName), maker.Literal(CTC_BOT, null)), throwBlock, null);\r\n}"
}, {
	"Path": "com.sun.jna.CallbackThreadInitializer.isDaemon",
	"Comment": "returns whether the callback thread should be a daemon thread.",
	"Method": "boolean isDaemon(Callback cb){\r\n    return daemon;\r\n}"
}, {
	"Path": "org.jsoup.select.Elements.nextAll",
	"Comment": "get each of the following element siblings of each element in this list, that match the query.",
	"Method": "Elements nextAll(Elements nextAll,String query){\r\n    return siblings(query, true, true);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.GridPoint2.set",
	"Comment": "sets the coordinates of this 2d grid point to that of another.",
	"Method": "GridPoint2 set(GridPoint2 point,GridPoint2 set,int x,int y){\r\n    this.x = x;\r\n    this.y = y;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.GwtFileHandle.writer",
	"Comment": "returns a writer for writing to this file. parent directories will be created if necessary.",
	"Method": "Writer writer(boolean append,Writer writer,boolean append,String charset){\r\n    throw new GdxRuntimeException(\"Cannot write to files in GWT backend\");\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch.initRenderData",
	"Comment": "allocates all the require rendering resources like renderables,shaders,meshes according to the current batch configuration.",
	"Method": "void initRenderData(){\r\n    setVertexData();\r\n    clearRenderablesPool();\r\n    allocShader();\r\n    resetCapacity();\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect.setOffset",
	"Comment": "sets the pixel offset to move the gradient up or down. the gradient is normally centered on the glyph.",
	"Method": "void setOffset(int offset){\r\n    this.offset = offset;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.dispose",
	"Comment": "releases all resources used by this unicodefont. this method should be called when this unicodefont instance is no longer\tneeded.",
	"Method": "void dispose(){\r\n    for (Iterator iter = glyphPages.iterator(); iter.hasNext(); ) {\r\n        GlyphPage page = (GlyphPage) iter.next();\r\n        page.getTexture().dispose();\r\n    }\r\n    if (bitmapFont != null) {\r\n        bitmapFont.dispose();\r\n        generator.dispose();\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Skin.getTiledDrawable",
	"Comment": "returns a registered tiled drawable. if no tiled drawable is found but a region exists with the name, a tiled drawable is\tcreated from the region and stored in the skin.",
	"Method": "TiledDrawable getTiledDrawable(String name){\r\n    TiledDrawable tiled = optional(name, TiledDrawable.class);\r\n    if (tiled != null)\r\n        return tiled;\r\n    tiled = new TiledDrawable(getRegion(name));\r\n    tiled.setName(name);\r\n    add(name, tiled, TiledDrawable.class);\r\n    return tiled;\r\n}"
}, {
	"Path": "com.codahale.metrics.EWMA.tick",
	"Comment": "mark the passage of time and decay the current rate accordingly.",
	"Method": "void tick(){\r\n    final long count = uncounted.sumThenReset();\r\n    final double instantRate = count / interval;\r\n    if (initialized) {\r\n        final double oldRate = this.rate;\r\n        rate = oldRate + (alpha * (instantRate - oldRate));\r\n    } else {\r\n        rate = instantRate;\r\n        initialized = true;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jna.Structure.getNativeSize",
	"Comment": "return the native size of the given java type, from the perspective ofthis structure.",
	"Method": "int getNativeSize(Class<?> nativeType,int getNativeSize,Class<?> nativeType,Object value){\r\n    return Native.getNativeSize(nativeType, value);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.decals.Decal.getVertices",
	"Comment": "returns the vertices backing this sprite.\tthe returned value should under no circumstances be modified.",
	"Method": "float[] getVertices(){\r\n    return vertices;\r\n}"
}, {
	"Path": "org.junit.runners.ParentRunner.setScheduler",
	"Comment": "sets a scheduler that determines the order and parallelizationof children.highly experimental feature that may change.",
	"Method": "void setScheduler(RunnerScheduler scheduler){\r\n    this.scheduler = scheduler;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.Method.invoke",
	"Comment": "invokes the underlying method on the supplied object with the supplied parameters.",
	"Method": "Object invoke(Object obj,Object args){\r\n    try {\r\n        return method.invoke(obj, args);\r\n    } catch (IllegalArgumentException e) {\r\n        throw new ReflectionException(\"Illegal argument(s) supplied to method: \" + getName(), e);\r\n    } catch (IllegalAccessException e) {\r\n        throw new ReflectionException(\"Illegal access to method: \" + getName(), e);\r\n    } catch (InvocationTargetException e) {\r\n        throw new ReflectionException(\"Exception occurred in method: \" + getName(), e);\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.common.Vec2.normalize",
	"Comment": "normalize this vector and return the length before normalization. alters this vector.",
	"Method": "float normalize(){\r\n    float length = length();\r\n    if (length < Settings.EPSILON) {\r\n        return 0f;\r\n    }\r\n    float invLength = 1.0f / length;\r\n    x *= invLength;\r\n    y *= invLength;\r\n    return length;\r\n}"
}, {
	"Path": "lombok.eclipse.handlers.EclipseHandlerUtil.makeMarkerAnnotation",
	"Comment": "create an annotation of the given name, and is marked as being generated by the given source.",
	"Method": "MarkerAnnotation makeMarkerAnnotation(char[][] name,ASTNode source){\r\n    long pos = (long) source.sourceStart << 32 | source.sourceEnd;\r\n    TypeReference typeRef = new QualifiedTypeReference(name, new long[] { pos, pos, pos });\r\n    setGeneratedBy(typeRef, source);\r\n    MarkerAnnotation ann = new MarkerAnnotation(typeRef, (int) (pos >> 32));\r\n    ann.declarationSourceEnd = ann.sourceEnd = ann.statementEnd = (int) pos;\r\n    setGeneratedBy(ann, source);\r\n    return ann;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tests.CollectionsTest.assertNotEquals",
	"Comment": "checks that the two values are not equal, and emits a warning if their hashcodes are equal.",
	"Method": "void assertNotEquals(Object a,Object b){\r\n    if (a.equals(b))\r\n        throw new GdxRuntimeException(\"!equals() failed: \" + a + \" == \" + b);\r\n    if (b.equals(a))\r\n        throw new GdxRuntimeException(\"!equals() failed (not symmetric): \" + b + \" == \" + a);\r\n    if (a.hashCode() == b.hashCode())\r\n        System.out.println(\"Warning: hashCode() may be incorrect: \" + a + \" == \" + b);\r\n}"
}, {
	"Path": "org.jsoup.integration.UrlConnectTest.testUnsafeFail",
	"Comment": "verify that security disabling feature works properly.1. try to hit url with invalid certificate and evaluate that exception is thrown",
	"Method": "void testUnsafeFail(){\r\n    String url = WEBSITE_WITH_INVALID_CERTIFICATE;\r\n    Jsoup.connect(url).execute();\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.setFromAxisRad",
	"Comment": "sets the quaternion components from the given axis and angle around that axis.",
	"Method": "Quaternion setFromAxisRad(Vector3 axis,float radians,Quaternion setFromAxisRad,float x,float y,float z,float radians){\r\n    float d = Vector3.len(x, y, z);\r\n    if (d == 0f)\r\n        return idt();\r\n    d = 1f / d;\r\n    float l_ang = radians < 0 ? MathUtils.PI2 - (-radians % MathUtils.PI2) : radians % MathUtils.PI2;\r\n    float l_sin = (float) Math.sin(l_ang / 2);\r\n    float l_cos = (float) Math.cos(l_ang / 2);\r\n    return this.set(d * x * l_sin, d * y * l_sin, d * z * l_sin, l_cos).nor();\r\n}"
}, {
	"Path": "com.badlogic.gdx.tests.g3d.HeightField.heightColorsToMap",
	"Comment": "simply creates an array containing only all the red components of the data.",
	"Method": "float[] heightColorsToMap(ByteBuffer data,Pixmap.Format format,int width,int height){\r\n    final int bytesPerColor = (format == Format.RGB888 ? 3 : (format == Format.RGBA8888 ? 4 : 0));\r\n    if (bytesPerColor == 0)\r\n        throw new GdxRuntimeException(\"Unsupported format, should be either RGB8 or RGBA8\");\r\n    if (data.remaining() < (width * height * bytesPerColor))\r\n        throw new GdxRuntimeException(\"Incorrect map size\");\r\n    final int startPos = data.position();\r\n    byte[] source = null;\r\n    int sourceOffset = 0;\r\n    if (data.hasArray() && !data.isReadOnly()) {\r\n        source = data.array();\r\n        sourceOffset = data.arrayOffset() + startPos;\r\n    } else {\r\n        source = new byte[width * height * bytesPerColor];\r\n        data.get(source);\r\n        data.position(startPos);\r\n    }\r\n    float[] dest = new float[width * height];\r\n    for (int i = 0; i < dest.length; ++i) {\r\n        int v = source[sourceOffset + i * bytesPerColor];\r\n        v = v < 0 ? 256 + v : v;\r\n        dest[i] = (float) v / 255f;\r\n    }\r\n    return dest;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getFreezesText",
	"Comment": "return whether this text view is including its entire text contentsin frozen icicles.",
	"Method": "boolean getFreezesText(){\r\n    return mInputView.getFreezesText();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.QuickSelect.medianOfThreePivot",
	"Comment": "median of three has the potential to outperform a random pivot, especially for partially sorted arrays",
	"Method": "int medianOfThreePivot(int leftIdx,int rightIdx){\r\n    T left = array[leftIdx];\r\n    int midIdx = (leftIdx + rightIdx) / 2;\r\n    T mid = array[midIdx];\r\n    T right = array[rightIdx];\r\n    if (comp.compare(left, mid) > 0) {\r\n        if (comp.compare(mid, right) > 0) {\r\n            return midIdx;\r\n        } else if (comp.compare(left, right) > 0) {\r\n            return rightIdx;\r\n        } else {\r\n            return leftIdx;\r\n        }\r\n    } else {\r\n        if (comp.compare(left, right) > 0) {\r\n            return leftIdx;\r\n        } else if (comp.compare(mid, right) > 0) {\r\n            return rightIdx;\r\n        } else {\r\n            return midIdx;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.toMatrix",
	"Comment": "fills a 4x4 matrix with the rotation matrix represented by this quaternion.",
	"Method": "void toMatrix(float[] matrix){\r\n    final float xx = x * x;\r\n    final float xy = x * y;\r\n    final float xz = x * z;\r\n    final float xw = x * w;\r\n    final float yy = y * y;\r\n    final float yz = y * z;\r\n    final float yw = y * w;\r\n    final float zz = z * z;\r\n    final float zw = z * w;\r\n    matrix[Matrix4.M00] = 1 - 2 * (yy + zz);\r\n    matrix[Matrix4.M01] = 2 * (xy - zw);\r\n    matrix[Matrix4.M02] = 2 * (xz + yw);\r\n    matrix[Matrix4.M03] = 0;\r\n    matrix[Matrix4.M10] = 2 * (xy + zw);\r\n    matrix[Matrix4.M11] = 1 - 2 * (xx + zz);\r\n    matrix[Matrix4.M12] = 2 * (yz - xw);\r\n    matrix[Matrix4.M13] = 0;\r\n    matrix[Matrix4.M20] = 2 * (xz - yw);\r\n    matrix[Matrix4.M21] = 2 * (yz + xw);\r\n    matrix[Matrix4.M22] = 1 - 2 * (xx + yy);\r\n    matrix[Matrix4.M23] = 0;\r\n    matrix[Matrix4.M30] = 0;\r\n    matrix[Matrix4.M31] = 0;\r\n    matrix[Matrix4.M32] = 0;\r\n    matrix[Matrix4.M33] = 1;\r\n}"
}, {
	"Path": "java.nio.ByteBuffer.allocate",
	"Comment": "creates a byte buffer based on a newly allocated byte array.",
	"Method": "ByteBuffer allocate(int capacity){\r\n    if (capacity < 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return BufferFactory.newByteBuffer(capacity);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.PolygonSprite.translate",
	"Comment": "sets the position relative to the current position where the sprite will be drawn. if origin, rotation, or scale are\tchanged, it is slightly more efficient to translate after those operations.",
	"Method": "void translate(float xAmount,float yAmount){\r\n    x += xAmount;\r\n    y += yAmount;\r\n    if (dirty)\r\n        return;\r\n    final float[] vertices = this.vertices;\r\n    for (int i = 0; i < vertices.length; i += Sprite.VERTEX_SIZE) {\r\n        vertices[i] += xAmount;\r\n        vertices[i + 1] += yAmount;\r\n    }\r\n}"
}, {
	"Path": "java.nio.BufferFactory.newByteBuffer",
	"Comment": "returns a new array based byte buffer with the specified capacity.",
	"Method": "ByteBuffer newByteBuffer(byte array,ByteBuffer newByteBuffer,int capacity){\r\n    return new ReadWriteHeapByteBuffer(capacity);\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.Kernel32Util.getResource",
	"Comment": "gets the specified resource out of the specified executable file",
	"Method": "byte[] getResource(String path,String type,String name){\r\n    HMODULE target = Kernel32.INSTANCE.LoadLibraryEx(path, null, Kernel32.LOAD_LIBRARY_AS_DATAFILE);\r\n    if (target == null) {\r\n        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n    }\r\n    Win32Exception err = null;\r\n    Pointer start = null;\r\n    int length = 0;\r\n    byte[] results = null;\r\n    try {\r\n        Pointer t = null;\r\n        try {\r\n            t = new Pointer(Long.parseLong(type));\r\n        } catch (NumberFormatException e) {\r\n            t = new Memory(Native.WCHAR_SIZE * (type.length() + 1));\r\n            t.setWideString(0, type);\r\n        }\r\n        Pointer n = null;\r\n        try {\r\n            n = new Pointer(Long.parseLong(name));\r\n        } catch (NumberFormatException e) {\r\n            n = new Memory(Native.WCHAR_SIZE * (name.length() + 1));\r\n            n.setWideString(0, name);\r\n        }\r\n        HRSRC hrsrc = Kernel32.INSTANCE.FindResource(target, n, t);\r\n        if (hrsrc == null) {\r\n            throw new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n        }\r\n        HANDLE loaded = Kernel32.INSTANCE.LoadResource(target, hrsrc);\r\n        if (loaded == null) {\r\n            throw new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n        }\r\n        length = Kernel32.INSTANCE.SizeofResource(target, hrsrc);\r\n        if (length == 0) {\r\n            throw new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n        }\r\n        start = Kernel32.INSTANCE.LockResource(loaded);\r\n        if (start == null) {\r\n            throw new IllegalStateException(\"LockResource returned null.\");\r\n        }\r\n        results = start.getByteArray(0, length);\r\n    } catch (Win32Exception we) {\r\n        err = we;\r\n    } finally {\r\n        if (target != null) {\r\n            if (!Kernel32.INSTANCE.FreeLibrary(target)) {\r\n                Win32Exception we = new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n                if (err != null) {\r\n                    we.addSuppressedReflected(err);\r\n                }\r\n                throw we;\r\n            }\r\n        }\r\n    }\r\n    if (err != null) {\r\n        throw err;\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.setFromAxis",
	"Comment": "sets the quaternion components from the given axis and angle around that axis.",
	"Method": "Quaternion setFromAxis(Vector3 axis,float degrees,Quaternion setFromAxis,float x,float y,float z,float degrees){\r\n    return setFromAxisRad(x, y, z, degrees * MathUtils.degreesToRadians);\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.DayView.setDayFormatter",
	"Comment": "set the new label formatter and reformat the current label. this preserves current spans.",
	"Method": "void setDayFormatter(DayFormatter formatter){\r\n    this.contentDescriptionFormatter = contentDescriptionFormatter == this.formatter ? formatter : contentDescriptionFormatter;\r\n    this.formatter = formatter == null ? DayFormatter.DEFAULT : formatter;\r\n    CharSequence currentLabel = getText();\r\n    Object[] spans = null;\r\n    if (currentLabel instanceof Spanned) {\r\n        spans = ((Spanned) currentLabel).getSpans(0, currentLabel.length(), Object.class);\r\n    }\r\n    SpannableString newLabel = new SpannableString(getLabel());\r\n    if (spans != null) {\r\n        for (Object span : spans) {\r\n            newLabel.setSpan(span, 0, newLabel.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\r\n        }\r\n    }\r\n    setText(newLabel);\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.iosmoe.IOSInput.setKeyboardCloseOnReturnKey",
	"Comment": "set the keyboard to close when the uitextfield return key is pressed",
	"Method": "void setKeyboardCloseOnReturnKey(boolean shouldClose){\r\n    keyboardCloseOnReturn = shouldClose;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.Field.getElementType",
	"Comment": "if the type of the field is parameterized, returns the class object representing the parameter type at the specified index,\tnull otherwise.",
	"Method": "Class getElementType(int index){\r\n    Type genericType = field.getGenericType();\r\n    if (genericType instanceof ParameterizedType) {\r\n        Type[] actualTypes = ((ParameterizedType) genericType).getActualTypeArguments();\r\n        if (actualTypes.length - 1 >= index) {\r\n            Type actualType = actualTypes[index];\r\n            if (actualType instanceof Class)\r\n                return (Class) actualType;\r\n            else if (actualType instanceof ParameterizedType)\r\n                return (Class) ((ParameterizedType) actualType).getRawType();\r\n            else if (actualType instanceof GenericArrayType) {\r\n                Type componentType = ((GenericArrayType) actualType).getGenericComponentType();\r\n                if (componentType instanceof Class)\r\n                    return ArrayReflection.newInstance((Class) componentType, 0).getClass();\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.getInt",
	"Comment": "finds the child with the specified index and returns it as an int.",
	"Method": "int getInt(String name,int defaultValue,int getInt,String name,int getInt,int index){\r\n    JsonValue child = get(index);\r\n    if (child == null)\r\n        throw new IllegalArgumentException(\"Indexed value not found: \" + name);\r\n    return child.asInt();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectMap.shrink",
	"Comment": "reduces the size of the backing arrays to be the specified capacity or less. if the capacity is already less, nothing is\tdone. if the map contains more items than the specified capacity, the next highest power of two capacity is used instead.",
	"Method": "void shrink(int maximumCapacity){\r\n    if (maximumCapacity < 0)\r\n        throw new IllegalArgumentException(\"maximumCapacity must be >= 0: \" + maximumCapacity);\r\n    if (size > maximumCapacity)\r\n        maximumCapacity = size;\r\n    if (capacity <= maximumCapacity)\r\n        return;\r\n    maximumCapacity = MathUtils.nextPowerOfTwo(maximumCapacity);\r\n    resize(maximumCapacity);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.isBullet",
	"Comment": "is this body treated like a bullet for continuous collision detection?",
	"Method": "boolean isBullet(){\r\n    return body.isBullet();\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.getWorldVector",
	"Comment": "get the world coordinates of a vector given the local coordinates.",
	"Method": "Vector2 getWorldVector(Vector2 localVector){\r\n    tmp.set(localVector.x, localVector.y);\r\n    Vec2 wv = body.getWorldVector(tmp);\r\n    return worldVector.set(wv.x, wv.y);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.TimSort.mergeForceCollapse",
	"Comment": "merges all runs on the stack until only one remains. this method is called once, to complete the sort.",
	"Method": "void mergeForceCollapse(){\r\n    while (stackSize > 1) {\r\n        int n = stackSize - 2;\r\n        if (n > 0 && runLen[n - 1] < runLen[n + 1])\r\n            n--;\r\n        mergeAt(n);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jna.Memory.getDouble",
	"Comment": "indirect the native pointer to malloc space, a lapointer.getdouble.but this method performs abounds check to ensure that the indirection does not cause memoryoutside the malloced space to be accessed.",
	"Method": "double getDouble(long offset){\r\n    boundsCheck(offset, 8);\r\n    return super.getDouble(offset);\r\n}"
}, {
	"Path": "com.squareup.leakcanary.FailTestOnLeakRunListener.reportLeaks",
	"Comment": "can be overridden to report leaks in a different way or do additional reporting.",
	"Method": "void reportLeaks(InstrumentationLeakResults results){\r\n    if (!results.detectedLeaks.isEmpty()) {\r\n        String message = checkNotNull(buildLeakDetectedMessage(results.detectedLeaks), \"buildLeakDetectedMessage\");\r\n        bundle.putString(InstrumentationResultPrinter.REPORT_KEY_STACK, message);\r\n        getInstrumentation().sendStatus(REPORT_VALUE_RESULT_FAILURE, bundle);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.getYawRad",
	"Comment": "get the yaw euler angle in radians, which is the rotation around the y axis. requires that this quaternion is normalized.",
	"Method": "float getYawRad(){\r\n    return getGimbalPole() == 0 ? MathUtils.atan2(2f * (y * w + x * z), 1f - 2f * (y * y + x * x)) : 0f;\r\n}"
}, {
	"Path": "com.sun.jna.NativeLibrary.getProcess",
	"Comment": "returns an instance of nativelibrary which refers to the currentprocess.this is useful for accessing functions which were alreadymapped by some other mechanism, without having to reference or evenknow the exact name of the native library.",
	"Method": "NativeLibrary getProcess(NativeLibrary getProcess,Map<String, ?> options){\r\n    return getInstance(null, options);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.isStaticClass",
	"Comment": "returns true if the class or interface represented by the supplied class is a static class.",
	"Method": "boolean isStaticClass(Class c){\r\n    return Modifier.isStatic(c.getModifiers());\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.joints.DistanceJointDef.initialize",
	"Comment": "initialize the bodies, anchors, and length using the world anchors.",
	"Method": "void initialize(Body bodyA,Body bodyB,Vector2 anchorA,Vector2 anchorB){\r\n    this.bodyA = bodyA;\r\n    this.bodyB = bodyB;\r\n    this.localAnchorA.set(bodyA.getLocalPoint(anchorA));\r\n    this.localAnchorB.set(bodyB.getLocalPoint(anchorB));\r\n    this.length = anchorA.dst(anchorB);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.createJoint",
	"Comment": "create a joint to constrain bodies together. no reference to the definition is retained. thismay cause the connected bodies to cease colliding.",
	"Method": "Joint createJoint(JointDef def){\r\n    assert (isLocked() == false);\r\n    if (isLocked()) {\r\n        return null;\r\n    }\r\n    Joint j = Joint.create(this, def);\r\n    j.m_prev = null;\r\n    j.m_next = m_jointList;\r\n    if (m_jointList != null) {\r\n        m_jointList.m_prev = j;\r\n    }\r\n    m_jointList = j;\r\n    ++m_jointCount;\r\n    j.m_edgeA.joint = j;\r\n    j.m_edgeA.other = j.getBodyB();\r\n    j.m_edgeA.prev = null;\r\n    j.m_edgeA.next = j.getBodyA().m_jointList;\r\n    if (j.getBodyA().m_jointList != null) {\r\n        j.getBodyA().m_jointList.prev = j.m_edgeA;\r\n    }\r\n    j.getBodyA().m_jointList = j.m_edgeA;\r\n    j.m_edgeB.joint = j;\r\n    j.m_edgeB.other = j.getBodyA();\r\n    j.m_edgeB.prev = null;\r\n    j.m_edgeB.next = j.getBodyB().m_jointList;\r\n    if (j.getBodyB().m_jointList != null) {\r\n        j.getBodyB().m_jointList.prev = j.m_edgeB;\r\n    }\r\n    j.getBodyB().m_jointList = j.m_edgeB;\r\n    Body bodyA = def.bodyA;\r\n    Body bodyB = def.bodyB;\r\n    if (def.collideConnected == false) {\r\n        ContactEdge edge = bodyB.getContactList();\r\n        while (edge != null) {\r\n            if (edge.other == bodyA) {\r\n                edge.contact.flagForFiltering();\r\n            }\r\n            edge = edge.next;\r\n        }\r\n    }\r\n    return j;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.viewport.ScreenViewport.setUnitsPerPixel",
	"Comment": "sets the number of pixels for each world unit. eg, a scale of 2.5 means there are 2.5 world units for every 1 screen pixel.\tdefault is 1.",
	"Method": "void setUnitsPerPixel(float unitsPerPixel){\r\n    this.unitsPerPixel = unitsPerPixel;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.getFixtureList",
	"Comment": "get the list of all fixtures attached to this body. do not modify the list!",
	"Method": "Array<Fixture> getFixtureList(){\r\n    return fixtures;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Json.setUsePrototypes",
	"Comment": "when true, field values that are identical to a newly constructed instance are not written. default is true.",
	"Method": "void setUsePrototypes(boolean usePrototypes){\r\n    this.usePrototypes = usePrototypes;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.Drawer.getDrawerBuilder",
	"Comment": "the protected getter of the mdrawerbuilderonly used internally to prevent the default behavior of some public methods",
	"Method": "DrawerBuilder getDrawerBuilder(){\r\n    return this.mDrawerBuilder;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.getDouble",
	"Comment": "finds the child with the specified index and returns it as a double.",
	"Method": "double getDouble(String name,double defaultValue,double getDouble,String name,double getDouble,int index){\r\n    JsonValue child = get(index);\r\n    if (child == null)\r\n        throw new IllegalArgumentException(\"Indexed value not found: \" + name);\r\n    return child.asDouble();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectMap.findKey",
	"Comment": "returns the key for the specified value, or null if it is not in the map. note this traverses the entire map and compares\tevery value, which may be an expensive operation.",
	"Method": "K findKey(Object value,boolean identity){\r\n    V[] valueTable = this.valueTable;\r\n    if (value == null) {\r\n        K[] keyTable = this.keyTable;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != null && valueTable[i] == null)\r\n            return keyTable[i];\r\n    } else if (identity) {\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (valueTable[i] == value)\r\n            return keyTable[i];\r\n    } else {\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (value.equals(valueTable[i]))\r\n            return keyTable[i];\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.ShapeRenderer.scale",
	"Comment": "multiplies the current transformation matrix by a scale matrix.",
	"Method": "void scale(float scaleX,float scaleY,float scaleZ){\r\n    transformMatrix.scale(scaleX, scaleY, scaleZ);\r\n    matrixDirty = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.step",
	"Comment": "take a time step. this performs collision detection, integration, and constraint solution.",
	"Method": "void step(float timeStep,int velocityIterations,int positionIterations){\r\n    world.step(timeStep, velocityIterations, positionIterations);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.contacts.Contact.flagForFiltering",
	"Comment": "flag this contact for filtering. filtering will occur the next time step.",
	"Method": "void flagForFiltering(){\r\n    m_flags |= FILTER_FLAG;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.GwtFileHandle.readString",
	"Comment": "reads the entire file into a string using the specified charset.",
	"Method": "String readString(String readString,String charset){\r\n    if (preloader.isText(file))\r\n        return preloader.texts.get(file);\r\n    try {\r\n        return new String(readBytes(), \"UTF-8\");\r\n    } catch (UnsupportedEncodingException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ByteArray.truncate",
	"Comment": "reduces the size of the array to the specified size. if the array is already smaller than the specified size, no action is",
	"Method": "void truncate(int newSize){\r\n    if (size > newSize)\r\n        size = newSize;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.isInterface",
	"Comment": "determines if the supplied class object represents an interface type.",
	"Method": "boolean isInterface(Class c){\r\n    return c.isInterface();\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.widgets.ResizableWidgetCollection.checkWidgetSize",
	"Comment": "check to see if any widgets have been resized and call their handlers appropriately.",
	"Method": "void checkWidgetSize(){\r\n    for (Map.Entry<ResizableWidget, ResizableWidgetInfo> entry : widgets.entrySet()) {\r\n        ResizableWidget widget = entry.getKey();\r\n        ResizableWidgetInfo info = entry.getValue();\r\n        if (info.updateSizes()) {\r\n            if (info.getOffsetWidth() > 0 && info.getOffsetHeight() > 0 && widget.isAttached()) {\r\n                widget.onResize(info.getOffsetWidth(), info.getOffsetHeight());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.LongMap.shrink",
	"Comment": "reduces the size of the backing arrays to be the specified capacity or less. if the capacity is already less, nothing is\tdone. if the map contains more items than the specified capacity, the next highest power of two capacity is used instead.",
	"Method": "void shrink(int maximumCapacity){\r\n    if (maximumCapacity < 0)\r\n        throw new IllegalArgumentException(\"maximumCapacity must be >= 0: \" + maximumCapacity);\r\n    if (size > maximumCapacity)\r\n        maximumCapacity = size;\r\n    if (capacity <= maximumCapacity)\r\n        return;\r\n    maximumCapacity = MathUtils.nextPowerOfTwo(maximumCapacity);\r\n    resize(maximumCapacity);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.TextureAtlas.createSprite",
	"Comment": "returns the first region found with the specified name and index as a sprite. this method uses string comparison to find the\tregion and constructs a new sprite, so the result should be cached rather than calling this method multiple times.",
	"Method": "Sprite createSprite(String name,Sprite createSprite,String name,int index){\r\n    for (int i = 0, n = regions.size; i < n; i++) {\r\n        AtlasRegion region = regions.get(i);\r\n        if (!region.name.equals(name))\r\n            continue;\r\n        if (region.index != index)\r\n            continue;\r\n        return newSprite(regions.get(i));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.setContactListener",
	"Comment": "register a contact event listener. the listener is owned by you and must remain in scope.",
	"Method": "void setContactListener(ContactListener listener){\r\n    if (listener != null) {\r\n        world.setContactListener(new org.jbox2d.callbacks.ContactListener() {\r\n            @Override\r\n            public void beginContact(org.jbox2d.dynamics.contacts.Contact contact) {\r\n                tmpContact.contact = contact;\r\n                listener.beginContact(tmpContact);\r\n            }\r\n            @Override\r\n            public void endContact(org.jbox2d.dynamics.contacts.Contact contact) {\r\n                tmpContact.contact = contact;\r\n                listener.endContact(tmpContact);\r\n            }\r\n            @Override\r\n            public void preSolve(org.jbox2d.dynamics.contacts.Contact contact, org.jbox2d.collision.Manifold oldManifold) {\r\n                tmpContact.contact = contact;\r\n                tmpManifold.manifold = oldManifold;\r\n                listener.preSolve(tmpContact, tmpManifold);\r\n            }\r\n            @Override\r\n            public void postSolve(org.jbox2d.dynamics.contacts.Contact contact, org.jbox2d.callbacks.ContactImpulse impulse) {\r\n                tmpContact.contact = contact;\r\n                tmpImpulse.impulse = impulse;\r\n                listener.postSolve(tmpContact, tmpImpulse);\r\n            }\r\n        });\r\n    } else {\r\n        world.setContactListener(null);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.setContactListener",
	"Comment": "register a contact event listener. the listener is owned by you and must remain in scope.",
	"Method": "void setContactListener(ContactListener listener){\r\n    tmpContact.contact = contact;\r\n    listener.beginContact(tmpContact);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.setContactListener",
	"Comment": "register a contact event listener. the listener is owned by you and must remain in scope.",
	"Method": "void setContactListener(ContactListener listener){\r\n    tmpContact.contact = contact;\r\n    listener.endContact(tmpContact);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.setContactListener",
	"Comment": "register a contact event listener. the listener is owned by you and must remain in scope.",
	"Method": "void setContactListener(ContactListener listener){\r\n    tmpContact.contact = contact;\r\n    tmpManifold.manifold = oldManifold;\r\n    listener.preSolve(tmpContact, tmpManifold);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.setContactListener",
	"Comment": "register a contact event listener. the listener is owned by you and must remain in scope.",
	"Method": "void setContactListener(ContactListener listener){\r\n    tmpContact.contact = contact;\r\n    tmpImpulse.impulse = impulse;\r\n    listener.postSolve(tmpContact, tmpImpulse);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.StringBuilder.capacity",
	"Comment": "returns the number of characters that can be held without growing.",
	"Method": "int capacity(){\r\n    return chars.length;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectMap.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "void ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded >= threshold)\r\n        resize(MathUtils.nextPowerOfTwo((int) Math.ceil(sizeNeeded / loadFactor)));\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch.setUseGpu",
	"Comment": "sets the current align mode. it will reallocate internal data, use only when necessary.",
	"Method": "void setUseGpu(boolean useGPU){\r\n    if (this.useGPU != useGPU) {\r\n        this.useGPU = useGPU;\r\n        initRenderData();\r\n        allocRenderables(bufferedParticlesCount);\r\n    }\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.AccountHeaderBuilder.onProfileImageClick",
	"Comment": "calls the monaccountheaderprofileimagelistener and continues with the actions afterwards",
	"Method": "void onProfileImageClick(View v,boolean current){\r\n    IProfile profile = (IProfile) v.getTag(R.id.material_drawer_profile_header);\r\n    boolean consumed = false;\r\n    if (mOnAccountHeaderProfileImageListener != null) {\r\n        consumed = mOnAccountHeaderProfileImageListener.onProfileImageClick(v, profile, current);\r\n    }\r\n    if (!consumed) {\r\n        onProfileClick(v, current);\r\n    }\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.Drawer.updateBadge",
	"Comment": "update the badge for a specific draweritemidentified by its id",
	"Method": "void updateBadge(long identifier,StringHolder badge){\r\n    IDrawerItem drawerItem = getDrawerItem(identifier);\r\n    if (drawerItem instanceof Badgeable) {\r\n        Badgeable badgeable = (Badgeable) drawerItem;\r\n        badgeable.withBadge(badge);\r\n        updateItem((IDrawerItem) badgeable);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Array.resize",
	"Comment": "creates a new backing array with the specified size containing the current items.",
	"Method": "T[] resize(int newSize){\r\n    T[] items = this.items;\r\n    T[] newItems = (T[]) ArrayReflection.newInstance(items.getClass().getComponentType(), newSize);\r\n    System.arraycopy(items, 0, newItems, 0, Math.min(size, newItems.length));\r\n    this.items = newItems;\r\n    return newItems;\r\n}"
}, {
	"Path": "lombok.eclipse.handlers.EclipseHandlerUtil.warning",
	"Comment": "generates a warning in the eclipse error log. note that most people never look at it!",
	"Method": "void warning(String message,Throwable ex){\r\n    ProblemReporter.warning(message, ex);\r\n}"
}, {
	"Path": "com.squareup.leakcanary.LeakCanary.leakInfo",
	"Comment": "returns a string representation of the result of a heap analysis.",
	"Method": "String leakInfo(Context context,HeapDump heapDump,AnalysisResult result,boolean detailed){\r\n    PackageManager packageManager = context.getPackageManager();\r\n    String packageName = context.getPackageName();\r\n    PackageInfo packageInfo;\r\n    try {\r\n        packageInfo = packageManager.getPackageInfo(packageName, 0);\r\n    } catch (PackageManager.NameNotFoundException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    String versionName = packageInfo.versionName;\r\n    int versionCode = packageInfo.versionCode;\r\n    String info = \"In \" + packageName + \":\" + versionName + \":\" + versionCode + \".\\n\";\r\n    String detailedString = \"\";\r\n    if (result.leakFound) {\r\n        if (result.excludedLeak) {\r\n            info += \"* EXCLUDED LEAK.\\n\";\r\n        }\r\n        info += \"* \" + result.className;\r\n        if (!heapDump.referenceName.equals(\"\")) {\r\n            info += \" (\" + heapDump.referenceName + \")\";\r\n        }\r\n        info += \" has leaked:\\n\" + result.leakTrace.toString() + \"\\n\";\r\n        if (result.retainedHeapSize != AnalysisResult.RETAINED_HEAP_SKIPPED) {\r\n            info += \"* Retaining: \" + formatShortFileSize(context, result.retainedHeapSize) + \".\\n\";\r\n        }\r\n        if (detailed) {\r\n            detailedString = \"\\n* Details:\\n\" + result.leakTrace.toDetailedString();\r\n        }\r\n    } else if (result.failure != null) {\r\n        info += \"* FAILURE in \" + LIBRARY_VERSION + \" \" + GIT_SHA + \":\" + Log.getStackTraceString(result.failure) + \"\\n\";\r\n    } else {\r\n        info += \"* NO LEAK FOUND.\\n\\n\";\r\n    }\r\n    if (detailed) {\r\n        detailedString += \"* Excluded Refs:\\n\" + heapDump.excludedRefs;\r\n    }\r\n    info += \"* Reference Key: \" + heapDump.referenceKey + \"\\n\" + \"* Device: \" + Build.MANUFACTURER + \" \" + Build.BRAND + \" \" + Build.MODEL + \" \" + Build.PRODUCT + \"\\n\" + \"* Android Version: \" + Build.VERSION.RELEASE + \" API: \" + Build.VERSION.SDK_INT + \" LeakCanary: \" + LIBRARY_VERSION + \" \" + GIT_SHA + \"\\n\" + \"* Durations: watch=\" + heapDump.watchDurationMs + \"ms, gc=\" + heapDump.gcDurationMs + \"ms, heap dump=\" + heapDump.heapDumpDurationMs + \"ms, analysis=\" + result.analysisDurationMs + \"ms\" + \"\\n\" + detailedString;\r\n    return info;\r\n}"
}, {
	"Path": "com.sun.jna.platform.WindowUtils.getAllWindows",
	"Comment": "requests a list of all currently available desktop windows.",
	"Method": "List<DesktopWindow> getAllWindows(boolean onlyVisibleWindows,List<DesktopWindow> getAllWindows,boolean onlyVisibleWindows,List<DesktopWindow> getAllWindows,boolean onlyVisibleWindows){\r\n    return getInstance().getAllWindows(onlyVisibleWindows);\r\n}"
}, {
	"Path": "org.junit.runner.Request.aClass",
	"Comment": "create a request that, when processed, will run all the testsin a class. the odd name is necessary because class is a reserved word.",
	"Method": "Request aClass(Class<?> clazz){\r\n    return new ClassRequest(clazz);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Json.writeFields",
	"Comment": "writes all fields of the specified object to the current json object.",
	"Method": "void writeFields(Object object){\r\n    Class type = object.getClass();\r\n    Object[] defaultValues = getDefaultValues(type);\r\n    OrderedMap<String, FieldMetadata> fields = getFields(type);\r\n    int i = 0;\r\n    for (FieldMetadata metadata : new OrderedMapValues<FieldMetadata>(fields)) {\r\n        Field field = metadata.field;\r\n        if (readDeprecated && ignoreDeprecated && field.isAnnotationPresent(Deprecated.class))\r\n            continue;\r\n        try {\r\n            Object value = field.get(object);\r\n            if (defaultValues != null) {\r\n                Object defaultValue = defaultValues[i++];\r\n                if (value == null && defaultValue == null)\r\n                    continue;\r\n                if (value != null && defaultValue != null) {\r\n                    if (value.equals(defaultValue))\r\n                        continue;\r\n                    if (value.getClass().isArray() && defaultValue.getClass().isArray()) {\r\n                        equals1[0] = value;\r\n                        equals2[0] = defaultValue;\r\n                        if (Arrays.deepEquals(equals1, equals2))\r\n                            continue;\r\n                    }\r\n                }\r\n            }\r\n            if (debug)\r\n                System.out.println(\"Writing field: \" + field.getName() + \" (\" + type.getName() + \")\");\r\n            writer.name(field.getName());\r\n            writeValue(value, field.getType(), metadata.elementType);\r\n        } catch (ReflectionException ex) {\r\n            throw new SerializationException(\"Error accessing field: \" + field.getName() + \" (\" + type.getName() + \")\", ex);\r\n        } catch (SerializationException ex) {\r\n            ex.addTrace(field + \" (\" + type.getName() + \")\");\r\n            throw ex;\r\n        } catch (Exception runtimeEx) {\r\n            SerializationException ex = new SerializationException(runtimeEx);\r\n            ex.addTrace(field + \" (\" + type.getName() + \")\");\r\n            throw ex;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.nextPowerOfTwo",
	"Comment": "returns the next power of two. returns the specified value if the value is already a power of two.",
	"Method": "int nextPowerOfTwo(int value){\r\n    if (value == 0)\r\n        return 1;\r\n    value--;\r\n    value |= value >> 1;\r\n    value |= value >> 2;\r\n    value |= value >> 4;\r\n    value |= value >> 8;\r\n    value |= value >> 16;\r\n    return value + 1;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup.setUncheckLast",
	"Comment": "if true, when the maximum number of buttons are checked and an additional button is checked, the last button to be checked\tis unchecked so that the maximum is not exceeded. if false, additional buttons beyond the maximum are not allowed to be\tchecked. default is true.",
	"Method": "void setUncheckLast(boolean uncheckLast){\r\n    this.uncheckLast = uncheckLast;\r\n}"
}, {
	"Path": "org.junit.internal.matchers.ThrowableCauseMatcher.hasCause",
	"Comment": "returns a matcher that verifies that the outer exception has a cause for which the supplied matcherevaluates to true.",
	"Method": "Matcher<T> hasCause(Matcher<?> matcher){\r\n    return new ThrowableCauseMatcher<T>(matcher);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.LongArray.setSize",
	"Comment": "sets the array size, leaving any values beyond the current size undefined.",
	"Method": "long[] setSize(int newSize){\r\n    if (newSize < 0)\r\n        throw new IllegalArgumentException(\"newSize must be >= 0: \" + newSize);\r\n    if (newSize > items.length)\r\n        resize(Math.max(8, newSize));\r\n    size = newSize;\r\n    return items;\r\n}"
}, {
	"Path": "java.nio.DoubleBuffer.get",
	"Comment": "reads doubles from the current position into the specified double array, starting from the specified offset, and increases\tthe position by the number of doubles read.",
	"Method": "double get(DoubleBuffer get,double[] dest,DoubleBuffer get,double[] dest,int off,int len,double get,int index){\r\n    int length = dest.length;\r\n    if (off < 0 || len < 0 || (long) off + (long) len > length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (len > remaining()) {\r\n        throw new BufferUnderflowException();\r\n    }\r\n    for (int i = off; i < off + len; i++) {\r\n        dest[i] = get();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.extractText",
	"Comment": "if this textview contains editable content, extract a portion of itbased on the information in request in to outtext.",
	"Method": "boolean extractText(ExtractedTextRequest request,ExtractedText outText){\r\n    return mInputView.extractText(request, outText);\r\n}"
}, {
	"Path": "com.rey.material.widget.TimePicker.setOnTimeChangedListener",
	"Comment": "set a listener will be called when the selected time is changed.",
	"Method": "void setOnTimeChangedListener(OnTimeChangedListener listener){\r\n    mOnTimeChangedListener = listener;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.BitmapFont.getDescent",
	"Comment": "returns the descent, which is the distance from the bottom of the glyph that extends the lowest to the baseline. this\tnumber is negative.",
	"Method": "float getDescent(){\r\n    return data.descent;\r\n}"
}, {
	"Path": "com.sun.jna.Memory.setChar",
	"Comment": "indirect the native pointer to malloc space, a lapointer.setchar.but this method performs a boundschecks to ensure that the indirection does not cause memory outside themalloced space to be accessed.",
	"Method": "void setChar(long offset,char value){\r\n    boundsCheck(offset, Native.WCHAR_SIZE);\r\n    super.setChar(offset, value);\r\n}"
}, {
	"Path": "org.jsoup.parser.Tag.isFormListed",
	"Comment": "get if this tag represents a control associated with a form. e.g. input, textarea, output",
	"Method": "boolean isFormListed(){\r\n    return formList;\r\n}"
}, {
	"Path": "com.rey.material.app.ThemeManager.registerOnThemeChangedListener",
	"Comment": "register a listener will be called when current theme changed.",
	"Method": "void registerOnThemeChangedListener(OnThemeChangedListener listener){\r\n    if (mDispatcher != null)\r\n        mDispatcher.registerListener(listener);\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.MaterialCalendarView.getCurrentDate",
	"Comment": "get the current first day of the month in month mode, or the first visible day of thecurrently visible week.for example, in week mode, if the week is july 29th, 2018 to august 4th, 2018,this will return july 29th, 2018. if in month mode and the month is august, then this methodwill return august 1st, 2018.",
	"Method": "CalendarDay getCurrentDate(){\r\n    return adapter.getItem(pager.getCurrentItem());\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Stage.unfocus",
	"Comment": "removes the touch, keyboard, and scroll focus for the specified actor and any descendants.",
	"Method": "void unfocus(Actor actor){\r\n    cancelTouchFocus(actor);\r\n    if (scrollFocus != null && scrollFocus.isDescendantOf(actor))\r\n        setScrollFocus(null);\r\n    if (keyboardFocus != null && keyboardFocus.isDescendantOf(actor))\r\n        setKeyboardFocus(null);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.setUserData",
	"Comment": "set the user data. use this to store your application specific data.",
	"Method": "void setUserData(Object data){\r\n    m_userData = data;\r\n}"
}, {
	"Path": "com.codahale.metrics.Snapshot.get999thPercentile",
	"Comment": "returns the value at the 99.9th percentile in the distribution.",
	"Method": "double get999thPercentile(){\r\n    return getValue(0.999);\r\n}"
}, {
	"Path": "com.sun.jna.NativeLibrary.addSearchPath",
	"Comment": "add a path to search for the specified library, ahead of any systempaths.this is similar to setting jna.library.path, butonly extends the search path for a single library.",
	"Method": "void addSearchPath(String libraryName,String path){\r\n    synchronized (searchPaths) {\r\n        List<String> customPaths = searchPaths.get(libraryName);\r\n        if (customPaths == null) {\r\n            customPaths = Collections.synchronizedList(new ArrayList<String>());\r\n            searchPaths.put(libraryName, customPaths);\r\n        }\r\n        customPaths.add(path);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.SharedLibraryLoader.mapLibraryName",
	"Comment": "maps a platform independent library name to a platform dependent name.",
	"Method": "String mapLibraryName(String libraryName){\r\n    if (isWindows)\r\n        return libraryName + (is64Bit ? \"64.dll\" : \".dll\");\r\n    if (isLinux)\r\n        return \"lib\" + libraryName + (isARM ? \"arm\" + abi : \"\") + (is64Bit ? \"64.so\" : \".so\");\r\n    if (isMac)\r\n        return \"lib\" + libraryName + (is64Bit ? \"64.dylib\" : \".dylib\");\r\n    return libraryName;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.PooledLinkedList.remove",
	"Comment": "removes the current list item based on the iterator position.",
	"Method": "void remove(){\r\n    if (curr == null)\r\n        return;\r\n    size--;\r\n    pool.free(curr);\r\n    Item<T> c = curr;\r\n    Item<T> n = curr.next;\r\n    Item<T> p = curr.prev;\r\n    curr = null;\r\n    if (size == 0) {\r\n        head = null;\r\n        tail = null;\r\n        return;\r\n    }\r\n    if (c == head) {\r\n        n.prev = null;\r\n        head = n;\r\n        return;\r\n    }\r\n    if (c == tail) {\r\n        p.next = null;\r\n        tail = p;\r\n        return;\r\n    }\r\n    p.next = n;\r\n    n.prev = p;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withItemAnimator",
	"Comment": "defines the itemanimator to be used in conjunction with the recyclerview",
	"Method": "DrawerBuilder withItemAnimator(RecyclerView.ItemAnimator itemAnimator){\r\n    mItemAnimator = itemAnimator;\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jna.platform.WindowUtils.getWindowIcon",
	"Comment": "obtains the set icon for the window associated with the specified\twindow handle.",
	"Method": "BufferedImage getWindowIcon(HWND hwnd,BufferedImage getWindowIcon,HWND hwnd,BufferedImage getWindowIcon,HWND hwnd){\r\n    return getInstance().getWindowIcon(hwnd);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Array.removeValue",
	"Comment": "removes the first instance of the specified value in the array.",
	"Method": "boolean removeValue(T value,boolean identity){\r\n    T[] items = this.items;\r\n    if (identity || value == null) {\r\n        for (int i = 0, n = size; i < n; i++) {\r\n            if (items[i] == value) {\r\n                removeIndex(i);\r\n                return true;\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = 0, n = size; i < n; i++) {\r\n            if (value.equals(items[i])) {\r\n                removeIndex(i);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator.setColor",
	"Comment": "sets the color to be used for the output image. its alpha component is ignored.\tdefaults to white, which is convenient for multiplying by a color value at runtime.",
	"Method": "void setColor(Color color){\r\n    this.color = color;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.BitmapFont.getCapHeight",
	"Comment": "returns the cap height, which is the distance from the top of most uppercase characters to the baseline. since the drawing\tposition is the cap height of the first line, the cap height can be used to get the location of the baseline.",
	"Method": "float getCapHeight(){\r\n    return data.capHeight;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Matrix4.setToLookAt",
	"Comment": "sets this matrix to a look at matrix with the given position, target and up vector.",
	"Method": "Matrix4 setToLookAt(Vector3 direction,Vector3 up,Matrix4 setToLookAt,Vector3 position,Vector3 target,Vector3 up){\r\n    tmpVec.set(target).sub(position);\r\n    setToLookAt(tmpVec, up);\r\n    this.mul(tmpMat.setToTranslation(-position.x, -position.y, -position.z));\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Bits.andNot",
	"Comment": "clears all of the bits in this bit set whose corresponding bit is set in the specified bit set.",
	"Method": "void andNot(Bits other){\r\n    for (int i = 0, j = bits.length, k = other.bits.length; i < j && i < k; i++) {\r\n        bits[i] &= ~other.bits[i];\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Mesh.calculateRadius",
	"Comment": "calculates the squared radius of the bounding sphere around the specified center for the specified part.",
	"Method": "float calculateRadius(float centerX,float centerY,float centerZ,int offset,int count,Matrix4 transform,float calculateRadius,Vector3 center,int offset,int count,Matrix4 transform,float calculateRadius,float centerX,float centerY,float centerZ,int offset,int count,float calculateRadius,Vector3 center,int offset,int count,float calculateRadius,float centerX,float centerY,float centerZ,float calculateRadius,Vector3 center){\r\n    return calculateRadius(center.x, center.y, center.z, 0, getNumIndices(), null);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup.expand",
	"Comment": "when true and wrap is false, the columns will take up the entire vertical group width.",
	"Method": "VerticalGroup expand(VerticalGroup expand,boolean expand){\r\n    this.expand = expand;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Cell.size",
	"Comment": "sets the minwidth, prefwidth, maxwidth, minheight, prefheight, and maxheight to the specified values.",
	"Method": "Cell<T> size(Value size,Cell<T> size,Value width,Value height,Cell<T> size,float size,Cell<T> size,float width,float height){\r\n    size(new Fixed(width), new Fixed(height));\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Actor.isDescendantOf",
	"Comment": "returns true if this actor is the same as or is the descendant of the specified actor.",
	"Method": "boolean isDescendantOf(Actor actor){\r\n    if (actor == null)\r\n        throw new IllegalArgumentException(\"actor cannot be null.\");\r\n    Actor parent = this;\r\n    while (true) {\r\n        if (parent == actor)\r\n            return true;\r\n        parent = parent.parent;\r\n        if (parent == null)\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "org.jsoup.nodes.Attributes.hashCode",
	"Comment": "calculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.",
	"Method": "int hashCode(){\r\n    int result = size;\r\n    result = 31 * result + Arrays.hashCode(keys);\r\n    result = 31 * result + Arrays.hashCode(vals);\r\n    return result;\r\n}"
}, {
	"Path": "lombok.eclipse.handlers.EclipseHandlerUtil.typeMatches",
	"Comment": "checks if the given typereference node is likely to be a reference to the provided class.",
	"Method": "boolean typeMatches(Class<?> type,EclipseNode node,TypeReference typeRef,boolean typeMatches,String type,EclipseNode node,TypeReference typeRef){\r\n    if (typeRef == null || typeRef.getTypeName() == null || typeRef.getTypeName().length == 0)\r\n        return false;\r\n    String lastPartA = new String(typeRef.getTypeName()[typeRef.getTypeName().length - 1]);\r\n    int lastIndex = type.lastIndexOf('.');\r\n    String lastPartB = lastIndex == -1 ? type : type.substring(lastIndex + 1);\r\n    if (!lastPartA.equals(lastPartB))\r\n        return false;\r\n    String typeName = toQualifiedName(typeRef.getTypeName());\r\n    TypeResolver resolver = new TypeResolver(node.getImportList());\r\n    return resolver.typeMatches(node, type, typeName);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.MiniDrawer.onProfileClick",
	"Comment": "call this method to trigger the onprofileclick on the minidrawer",
	"Method": "void onProfileClick(){\r\n    if (mCrossFader != null) {\r\n        if (mCrossFader.isCrossfaded()) {\r\n            mCrossFader.crossfade();\r\n        }\r\n    }\r\n    if (mAccountHeader != null) {\r\n        IProfile profile = mAccountHeader.getActiveProfile();\r\n        if (profile instanceof IDrawerItem) {\r\n            mItemAdapter.set(0, generateMiniDrawerItem((IDrawerItem) profile));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.Sprite.setOriginBasedPosition",
	"Comment": "sets the position where the sprite will be drawn, relative to its current origin.",
	"Method": "void setOriginBasedPosition(float x,float y){\r\n    setPosition(x - this.originX, y - this.originY);\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.setPaddingTop",
	"Comment": "sets the padding above a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "void setPaddingTop(int paddingTop){\r\n    this.paddingTop = paddingTop;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getCompoundPaddingTop",
	"Comment": "returns the top padding of the view, plus space for the topdrawable if any.",
	"Method": "int getCompoundPaddingTop(){\r\n    return mInputView.getCompoundPaddingTop();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.isAssignableFrom",
	"Comment": "determines if the class or interface represented by first class parameter is either the same as, or is a superclass or\tsuperinterface of, the class or interface represented by the second class parameter.",
	"Method": "boolean isAssignableFrom(Class c1,Class c2){\r\n    return c1.isAssignableFrom(c2);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer.render",
	"Comment": "this assumes that the projection matrix has already been set.",
	"Method": "void render(World world,Matrix4 projMatrix){\r\n    renderer.setProjectionMatrix(projMatrix);\r\n    renderBodies(world);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer.getColorBufferTexture",
	"Comment": "convenience method to return the first texture attachment present in the fbo",
	"Method": "T getColorBufferTexture(){\r\n    return textureAttachments.first();\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.getElementsByIndexLessThan",
	"Comment": "find elements whose sibling index is less than the supplied index.",
	"Method": "Elements getElementsByIndexLessThan(int index){\r\n    return Collector.collect(new Evaluator.IndexLessThan(index), this);\r\n}"
}, {
	"Path": "org.jbox2d.collision.shapes.Shape.getType",
	"Comment": "get the type of this shape. you can use this to down cast to the concrete shape.",
	"Method": "ShapeType getType(){\r\n    return m_type;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.decals.Decal.transformVertices",
	"Comment": "transforms the position component of the vertices using properties such as position, scale, etc.",
	"Method": "void transformVertices(){\r\n    float x, y, z, w;\r\n    float tx, ty;\r\n    if (transformationOffset != null) {\r\n        tx = -transformationOffset.x;\r\n        ty = -transformationOffset.y;\r\n    } else {\r\n        tx = ty = 0;\r\n    }\r\n    x = (vertices[X1] + tx) * scale.x;\r\n    y = (vertices[Y1] + ty) * scale.y;\r\n    z = vertices[Z1];\r\n    vertices[X1] = rotation.w * x + rotation.y * z - rotation.z * y;\r\n    vertices[Y1] = rotation.w * y + rotation.z * x - rotation.x * z;\r\n    vertices[Z1] = rotation.w * z + rotation.x * y - rotation.y * x;\r\n    w = -rotation.x * x - rotation.y * y - rotation.z * z;\r\n    rotation.conjugate();\r\n    x = vertices[X1];\r\n    y = vertices[Y1];\r\n    z = vertices[Z1];\r\n    vertices[X1] = w * rotation.x + x * rotation.w + y * rotation.z - z * rotation.y;\r\n    vertices[Y1] = w * rotation.y + y * rotation.w + z * rotation.x - x * rotation.z;\r\n    vertices[Z1] = w * rotation.z + z * rotation.w + x * rotation.y - y * rotation.x;\r\n    rotation.conjugate();\r\n    vertices[X1] += position.x - tx;\r\n    vertices[Y1] += position.y - ty;\r\n    vertices[Z1] += position.z;\r\n    x = (vertices[X2] + tx) * scale.x;\r\n    y = (vertices[Y2] + ty) * scale.y;\r\n    z = vertices[Z2];\r\n    vertices[X2] = rotation.w * x + rotation.y * z - rotation.z * y;\r\n    vertices[Y2] = rotation.w * y + rotation.z * x - rotation.x * z;\r\n    vertices[Z2] = rotation.w * z + rotation.x * y - rotation.y * x;\r\n    w = -rotation.x * x - rotation.y * y - rotation.z * z;\r\n    rotation.conjugate();\r\n    x = vertices[X2];\r\n    y = vertices[Y2];\r\n    z = vertices[Z2];\r\n    vertices[X2] = w * rotation.x + x * rotation.w + y * rotation.z - z * rotation.y;\r\n    vertices[Y2] = w * rotation.y + y * rotation.w + z * rotation.x - x * rotation.z;\r\n    vertices[Z2] = w * rotation.z + z * rotation.w + x * rotation.y - y * rotation.x;\r\n    rotation.conjugate();\r\n    vertices[X2] += position.x - tx;\r\n    vertices[Y2] += position.y - ty;\r\n    vertices[Z2] += position.z;\r\n    x = (vertices[X3] + tx) * scale.x;\r\n    y = (vertices[Y3] + ty) * scale.y;\r\n    z = vertices[Z3];\r\n    vertices[X3] = rotation.w * x + rotation.y * z - rotation.z * y;\r\n    vertices[Y3] = rotation.w * y + rotation.z * x - rotation.x * z;\r\n    vertices[Z3] = rotation.w * z + rotation.x * y - rotation.y * x;\r\n    w = -rotation.x * x - rotation.y * y - rotation.z * z;\r\n    rotation.conjugate();\r\n    x = vertices[X3];\r\n    y = vertices[Y3];\r\n    z = vertices[Z3];\r\n    vertices[X3] = w * rotation.x + x * rotation.w + y * rotation.z - z * rotation.y;\r\n    vertices[Y3] = w * rotation.y + y * rotation.w + z * rotation.x - x * rotation.z;\r\n    vertices[Z3] = w * rotation.z + z * rotation.w + x * rotation.y - y * rotation.x;\r\n    rotation.conjugate();\r\n    vertices[X3] += position.x - tx;\r\n    vertices[Y3] += position.y - ty;\r\n    vertices[Z3] += position.z;\r\n    x = (vertices[X4] + tx) * scale.x;\r\n    y = (vertices[Y4] + ty) * scale.y;\r\n    z = vertices[Z4];\r\n    vertices[X4] = rotation.w * x + rotation.y * z - rotation.z * y;\r\n    vertices[Y4] = rotation.w * y + rotation.z * x - rotation.x * z;\r\n    vertices[Z4] = rotation.w * z + rotation.x * y - rotation.y * x;\r\n    w = -rotation.x * x - rotation.y * y - rotation.z * z;\r\n    rotation.conjugate();\r\n    x = vertices[X4];\r\n    y = vertices[Y4];\r\n    z = vertices[Z4];\r\n    vertices[X4] = w * rotation.x + x * rotation.w + y * rotation.z - z * rotation.y;\r\n    vertices[Y4] = w * rotation.y + y * rotation.w + z * rotation.x - x * rotation.z;\r\n    vertices[Z4] = w * rotation.z + z * rotation.w + x * rotation.y - y * rotation.x;\r\n    rotation.conjugate();\r\n    vertices[X4] += position.x - tx;\r\n    vertices[Y4] += position.y - ty;\r\n    vertices[Z4] += position.z;\r\n    updated = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.GwtFileHandle.reader",
	"Comment": "returns a buffered reader for reading this file as characters.",
	"Method": "Reader reader(Reader reader,String charset,BufferedReader reader,int bufferSize,BufferedReader reader,int bufferSize,String charset){\r\n    return new BufferedReader(reader(charset), bufferSize);\r\n}"
}, {
	"Path": "com.sun.jna.Native.isUnpacked",
	"Comment": "identify temporary files unpacked from classpath jar files.",
	"Method": "boolean isUnpacked(File file){\r\n    return file.getName().startsWith(JNA_TMPLIB_PREFIX);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.Constructor.getDeclaringClass",
	"Comment": "returns the class object representing the class or interface that declares the constructor.",
	"Method": "Class getDeclaringClass(){\r\n    return constructor.getDeclaringClass();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonWriter.json",
	"Comment": "writes the specified json value, without quoting or escaping.",
	"Method": "JsonWriter json(String json,JsonWriter json,String name,String json){\r\n    return name(name).json(json);\r\n}"
}, {
	"Path": "com.badlogic.gdx.assets.AssetManager.dispose",
	"Comment": "disposes all assets in the manager and stops all asynchronous loading.",
	"Method": "void dispose(){\r\n    log.debug(\"Disposing.\");\r\n    clear();\r\n    executor.dispose();\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.MaterialCalendarView.canGoForward",
	"Comment": "whether the pager can page forward, meaning the future month is enabled.",
	"Method": "boolean canGoForward(){\r\n    return pager.getCurrentItem() < (adapter.getCount() - 1);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.FixtureDef.isSensor",
	"Comment": "a sensor shape collects contact information but never generates a collision response.",
	"Method": "boolean isSensor(){\r\n    return isSensor;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.BitmapFontCache.tint",
	"Comment": "tints all text currently in the cache. does not affect subsequently added text.",
	"Method": "void tint(Color tint){\r\n    float newTint = tint.toFloatBits();\r\n    if (currentTint == newTint)\r\n        return;\r\n    currentTint = newTint;\r\n    int[] tempGlyphCount = this.tempGlyphCount;\r\n    for (int i = 0, n = tempGlyphCount.length; i < n; i++) tempGlyphCount[i] = 0;\r\n    for (int i = 0, n = layouts.size; i < n; i++) {\r\n        GlyphLayout layout = layouts.get(i);\r\n        for (int ii = 0, nn = layout.runs.size; ii < nn; ii++) {\r\n            GlyphRun run = layout.runs.get(ii);\r\n            Array<Glyph> glyphs = run.glyphs;\r\n            float colorFloat = tempColor.set(run.color).mul(tint).toFloatBits();\r\n            for (int iii = 0, nnn = glyphs.size; iii < nnn; iii++) {\r\n                Glyph glyph = glyphs.get(iii);\r\n                int page = glyph.page;\r\n                int offset = tempGlyphCount[page] * 20 + 2;\r\n                tempGlyphCount[page]++;\r\n                float[] vertices = pageVertices[page];\r\n                for (int v = 0; v < 20; v += 5) vertices[offset + v] = colorFloat;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.randomBoolean",
	"Comment": "returns true if a random value between 0 and 1 is less than the specified value.",
	"Method": "boolean randomBoolean(boolean randomBoolean,float chance){\r\n    return MathUtils.random() < chance;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph.getYOffset",
	"Comment": "the distance from drawing y location to top of this glyph, causing the glyph to sit on the baseline.",
	"Method": "int getYOffset(){\r\n    return yOffset;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.Drawer.getCurrentStickyFooterSelectedPosition",
	"Comment": "get the current position of the selected sticky footer element",
	"Method": "int getCurrentStickyFooterSelectedPosition(){\r\n    return mDrawerBuilder.mCurrentStickyFooterSelection;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.joints.FrictionJointDef.initialize",
	"Comment": "initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.",
	"Method": "void initialize(Body bodyA,Body bodyB,Vector2 anchor){\r\n    this.bodyA = bodyA;\r\n    this.bodyB = bodyB;\r\n    localAnchorA.set(bodyA.getLocalPoint(anchor));\r\n    localAnchorB.set(bodyB.getLocalPoint(anchor));\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.AccountHeaderBuilder.withOnAccountHeaderItemLongClickListener",
	"Comment": "the on long click listener to be fired on profile longclick inside the list",
	"Method": "AccountHeaderBuilder withOnAccountHeaderItemLongClickListener(AccountHeader.OnAccountHeaderItemLongClickListener onAccountHeaderItemLongClickListener){\r\n    this.mOnAccountHeaderItemLongClickListener = onAccountHeaderItemLongClickListener;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.Method.getParameterTypes",
	"Comment": "returns an array of class objects that represent the formal parameter types, in declaration order, of the method.",
	"Method": "Class[] getParameterTypes(){\r\n    return method.getParameterTypes();\r\n}"
}, {
	"Path": "lombok.core.LombokNode.up",
	"Comment": "returns the structurally significant node that encloses this one.",
	"Method": "L up(){\r\n    L result = parent;\r\n    while (result != null && !result.isStructurallySignificant) result = result.parent;\r\n    return result;\r\n}"
}, {
	"Path": "com.rey.material.app.BottomSheetDialog.dimAmount",
	"Comment": "set the dim amount of the region outside this bottomsheetdialog.",
	"Method": "BottomSheetDialog dimAmount(float amount){\r\n    Window window = getWindow();\r\n    if (amount > 0f) {\r\n        window.addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND);\r\n        WindowManager.LayoutParams lp = window.getAttributes();\r\n        lp.dimAmount = amount;\r\n        window.setAttributes(lp);\r\n    } else\r\n        window.clearFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ArrayReflection.newInstance",
	"Comment": "creates a new array with the specified component type and length.",
	"Method": "Object newInstance(Class c,int size){\r\n    return java.lang.reflect.Array.newInstance(c, size);\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getIncludeFontPadding",
	"Comment": "gets whether the textview includes extra top and bottom padding to makeroom for accents that go above the normal ascent and descent.",
	"Method": "boolean getIncludeFontPadding(){\r\n    return Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN && mInputView.getIncludeFontPadding();\r\n}"
}, {
	"Path": "com.sun.jna.platform.WindowUtils.getProcessFilePath",
	"Comment": "detects the full file path of the process associated with the specified\twindow handle.",
	"Method": "String getProcessFilePath(HWND hwnd,String getProcessFilePath,HWND hwnd,String getProcessFilePath,HWND hwnd){\r\n    return getInstance().getProcessFilePath(hwnd);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.OrthographicCamera.rotate",
	"Comment": "rotates the camera by the given angle around the direction vector. the direction and up vector will not be orthogonalized.",
	"Method": "void rotate(float angle){\r\n    rotate(direction, angle);\r\n}"
}, {
	"Path": "lombok.javac.handlers.JavacHandlerUtil.typeMatches",
	"Comment": "checks if the given typereference node is likely to be a reference to the provided class.",
	"Method": "boolean typeMatches(Class<?> type,JavacNode node,JCTree typeNode,boolean typeMatches,String type,JavacNode node,JCTree typeNode){\r\n    String typeName = typeNode.toString();\r\n    TypeResolver resolver = new TypeResolver(node.getImportList());\r\n    return resolver.typeMatches(node, type, typeName);\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.MaterialCalendarView.canGoBack",
	"Comment": "whether the pager can page backward, meaning the previous month is enabled.",
	"Method": "boolean canGoBack(){\r\n    return pager.getCurrentItem() > 0;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.createParticleGroup",
	"Comment": "create a particle group whose properties have been defined. no reference to the definition isretained.",
	"Method": "ParticleGroup createParticleGroup(ParticleGroupDef def){\r\n    assert (isLocked() == false);\r\n    if (isLocked()) {\r\n        return null;\r\n    }\r\n    ParticleGroup g = m_particleSystem.createParticleGroup(def);\r\n    return g;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Group.findActor",
	"Comment": "returns the first actor found with the specified name. note this recursively compares the name of every actor in the",
	"Method": "T findActor(String name){\r\n    Array<Actor> children = this.children;\r\n    for (int i = 0, n = children.size; i < n; i++) if (name.equals(children.get(i).getName()))\r\n        return (T) children.get(i);\r\n    for (int i = 0, n = children.size; i < n; i++) {\r\n        Actor child = children.get(i);\r\n        if (child instanceof Group) {\r\n            Actor actor = ((Group) child).findActor(name);\r\n            if (actor != null)\r\n                return (T) actor;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Fixture.setFilterData",
	"Comment": "set the contact filtering data. this is an expensive operation and should not be calledfrequently. this will not update contacts until the next time step when either parent body isawake. this automatically calls refilter.",
	"Method": "void setFilterData(Filter filter){\r\n    m_filter.set(filter);\r\n    refilter();\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.TooltipManager.hideAction",
	"Comment": "called when tooltip is hidden. default implementation sets actions to animate hiding and to remove the actor from the stage\twhen the actions are complete. a subclass must at least remove the actor.",
	"Method": "void hideAction(Tooltip tooltip){\r\n    tooltip.container.addAction(sequence(parallel(alpha(0.2f, 0.2f, fade), scaleTo(0.05f, 0.05f, 0.2f, Interpolation.fade)), removeActor()));\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withSystemUIHidden",
	"Comment": "set to true if you use your app in complete fullscreen modewith hidden statusbar and navigationbar",
	"Method": "DrawerBuilder withSystemUIHidden(boolean systemUIHidden){\r\n    this.mSystemUIHidden = systemUIHidden;\r\n    if (systemUIHidden) {\r\n        withFullscreen(systemUIHidden);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.destroyJoint",
	"Comment": "destroy a joint. this may cause the connected bodies to begin colliding.",
	"Method": "void destroyJoint(Joint joint){\r\n    joint.setUserData(null);\r\n    world.destroyJoint(joint.joint);\r\n    joints.remove(joint.joint);\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper.readString",
	"Comment": "reads the entire file into a string using the specified charset.",
	"Method": "String readString(String readString,String charset){\r\n    int fileLength = (int) length();\r\n    if (fileLength == 0)\r\n        fileLength = 512;\r\n    StringBuilder output = new StringBuilder(fileLength);\r\n    InputStreamReader reader = null;\r\n    try {\r\n        if (charset == null)\r\n            reader = new InputStreamReader(read());\r\n        else\r\n            reader = new InputStreamReader(read(), charset);\r\n        char[] buffer = new char[256];\r\n        while (true) {\r\n            int length = reader.read(buffer);\r\n            if (length == -1)\r\n                break;\r\n            output.append(buffer, 0, length);\r\n        }\r\n    } catch (IOException ex) {\r\n        throw new GdxRuntimeException(\"Error reading layout file: \" + this, ex);\r\n    } finally {\r\n        StreamUtils.closeQuietly(reader);\r\n    }\r\n    return output.toString();\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Tree.setIconSpacing",
	"Comment": "sets the amount of horizontal space between the node actors and icons.",
	"Method": "void setIconSpacing(float left,float right){\r\n    this.iconSpacingLeft = left;\r\n    this.iconSpacingRight = right;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.forName",
	"Comment": "returns the class object associated with the class or interface with the supplied string name.",
	"Method": "Class forName(String name){\r\n    try {\r\n        return Class.forName(name);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new ReflectionException(\"Class not found: \" + name, e);\r\n    }\r\n}"
}, {
	"Path": "com.rey.material.app.Dialog.actionTextAppearance",
	"Comment": "sets the text color, size, style of all action buttons from the specified textappearance resource.",
	"Method": "Dialog actionTextAppearance(int resId){\r\n    positiveActionTextAppearance(resId);\r\n    negativeActionTextAppearance(resId);\r\n    neutralActionTextAppearance(resId);\r\n    return this;\r\n}"
}, {
	"Path": "com.squareup.leakcanary.HahaHelper.valueAsString",
	"Comment": "this returns a string representation of any object or value passed in.",
	"Method": "String valueAsString(Object value){\r\n    String stringValue;\r\n    if (value == null) {\r\n        stringValue = \"null\";\r\n    } else if (value instanceof ClassInstance) {\r\n        String valueClassName = ((ClassInstance) value).getClassObj().getClassName();\r\n        if (valueClassName.equals(String.class.getName())) {\r\n            stringValue = '\"' + asString(value) + '\"';\r\n        } else {\r\n            stringValue = value.toString();\r\n        }\r\n    } else {\r\n        stringValue = value.toString();\r\n    }\r\n    return stringValue;\r\n}"
}, {
	"Path": "com.badlogic.gdx.assets.loaders.SkinLoader.newSkin",
	"Comment": "override to allow subclasses of skin to be loaded or the skin instance to be configured.",
	"Method": "Skin newSkin(TextureAtlas atlas){\r\n    return new Skin(atlas);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.isFixedRotation",
	"Comment": "should this body be prevented from rotating? useful for characters.",
	"Method": "boolean isFixedRotation(){\r\n    return fixedRotation;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.Drawer.isDrawerOpen",
	"Comment": "get the current state of the drawer.true if the drawer is currently open.",
	"Method": "boolean isDrawerOpen(){\r\n    if (mDrawerBuilder.mDrawerLayout != null && mDrawerBuilder.mSliderLayout != null) {\r\n        return mDrawerBuilder.mDrawerLayout.isDrawerOpen(mDrawerBuilder.mDrawerGravity);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jna.Memory.setFloat",
	"Comment": "indirect the native pointer to malloc space, a lapointer.setfloat.but this method performs a boundschecks to ensure that the indirection does not cause memory outside themalloced space to be accessed.",
	"Method": "void setFloat(long offset,float value){\r\n    boundsCheck(offset, 4);\r\n    super.setFloat(offset, value);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.Sprite.setBounds",
	"Comment": "sets the position and size of the sprite when drawn, before scaling and rotation are applied. if origin, rotation, or scale\tare changed, it is slightly more efficient to set the bounds after those operations.",
	"Method": "void setBounds(float x,float y,float width,float height){\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n    if (dirty)\r\n        return;\r\n    float x2 = x + width;\r\n    float y2 = y + height;\r\n    float[] vertices = this.vertices;\r\n    vertices[X1] = x;\r\n    vertices[Y1] = y;\r\n    vertices[X2] = x;\r\n    vertices[Y2] = y2;\r\n    vertices[X3] = x2;\r\n    vertices[Y3] = y2;\r\n    vertices[X4] = x2;\r\n    vertices[Y4] = y;\r\n    if (rotation != 0 || scaleX != 1 || scaleY != 1)\r\n        dirty = true;\r\n}"
}, {
	"Path": "com.sun.jna.Memory.getFloat",
	"Comment": "indirect the native pointer to malloc space, a lapointer.getfloat.but this method performs a boundschecks to ensure that the indirection does not cause memory outside themalloced space to be accessed.",
	"Method": "float getFloat(long offset){\r\n    boundsCheck(offset, 4);\r\n    return super.getFloat(offset);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.DragListener.getDeltaY",
	"Comment": "returns the amount on the y axis that the touch has been dragged since the last drag event.",
	"Method": "float getDeltaY(){\r\n    return dragY - dragLastY;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.DragListener.getDeltaX",
	"Comment": "returns the amount on the x axis that the touch has been dragged since the last drag event.",
	"Method": "float getDeltaX(){\r\n    return dragX - dragLastX;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ArrayMap.ensureCapacity",
	"Comment": "increases the size of the backing arrays to accommodate the specified number of additional entries. useful before adding\tmany entries to avoid multiple backing array resizes.",
	"Method": "void ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded >= keys.length)\r\n        resize(Math.max(8, sizeNeeded));\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Polygon.getScaleX",
	"Comment": "returns the total horizontal scaling applied to the polygon.",
	"Method": "float getScaleX(){\r\n    return scaleX;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Color.toString",
	"Comment": "returns the color encoded as hex string with the format rrggbbaa.",
	"Method": "String toString(){\r\n    String value = Integer.toHexString(((int) (255 * r) << 24) | ((int) (255 * g) << 16) | ((int) (255 * b) << 8) | ((int) (255 * a)));\r\n    while (value.length() < 8) value = \"0\" + value;\r\n    return value;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener.setVisualPressed",
	"Comment": "if true, sets the visual pressed time to now. if false, clears the visual pressed time.",
	"Method": "void setVisualPressed(boolean visualPressed){\r\n    if (visualPressed)\r\n        visualPressedTime = TimeUtils.millis() + (long) (visualPressedDuration * 1000);\r\n    else\r\n        visualPressedTime = 0;\r\n}"
}, {
	"Path": "com.rey.material.widget.SnackBar.removeOnDismiss",
	"Comment": "indicate that this snackbar should remove itself from parent view after being dismissed.",
	"Method": "SnackBar removeOnDismiss(boolean b){\r\n    mRemoveOnDismiss = b;\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jna.Structure.typeInfoField",
	"Comment": "keep track of the largest aggregate field of the union to use forffi type information.",
	"Method": "StructField typeInfoField(){\r\n    LayoutInfo info;\r\n    synchronized (layoutInfo) {\r\n        info = layoutInfo.get(getClass());\r\n    }\r\n    if (info != null) {\r\n        return info.typeInfoField;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jna.Structure.layoutChanged",
	"Comment": "call whenever a structure setting is changed which might affect itsmemory layout.",
	"Method": "void layoutChanged(){\r\n    if (this.size != CALCULATE_SIZE) {\r\n        this.size = CALCULATE_SIZE;\r\n        if (this.memory instanceof AutoAllocated) {\r\n            this.memory = null;\r\n        }\r\n        ensureAllocated();\r\n    }\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withFireOnInitialOnClick",
	"Comment": "set this to true if you love to get an initial onclick event after the build method is called",
	"Method": "DrawerBuilder withFireOnInitialOnClick(boolean fireOnInitialOnClick){\r\n    this.mFireInitialOnClick = fireOnInitialOnClick;\r\n    return this;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.FixtureDef.setSensor",
	"Comment": "a sensor shape collects contact information but never generates a collision response.",
	"Method": "void setSensor(boolean isSensor){\r\n    this.isSensor = isSensor;\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.WinspoolUtil.getAllPrinterInfo2",
	"Comment": "returns printers that are physically attached to the local machine as\twell as remote printers to which it has a network connection.",
	"Method": "PRINTER_INFO_2[] getAllPrinterInfo2(){\r\n    return getPrinterInfo2(Winspool.PRINTER_ENUM_LOCAL | Winspool.PRINTER_ENUM_CONNECTIONS);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.batches.BufferedParticleBatch.ensureCapacity",
	"Comment": "ensure the batch can contain the passed in amount of particles",
	"Method": "void ensureCapacity(int capacity){\r\n    if (currentCapacity >= capacity)\r\n        return;\r\n    sorter.ensureCapacity(capacity);\r\n    allocParticlesData(capacity);\r\n    currentCapacity = capacity;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Group.addActor",
	"Comment": "adds an actor as a child of this group, removing it from its previous parent. if the actor is already a child of this\tgroup, no changes are made.",
	"Method": "void addActor(Actor actor){\r\n    if (actor.parent != null) {\r\n        if (actor.parent == this)\r\n            return;\r\n        actor.parent.removeActor(actor, false);\r\n    }\r\n    children.add(actor);\r\n    actor.setParent(this);\r\n    actor.setStage(getStage());\r\n    childrenChanged();\r\n}"
}, {
	"Path": "com.badlogic.gdx.files.FileHandle.moveTo",
	"Comment": "moves this file to the specified file, overwriting the file if it already exists.",
	"Method": "void moveTo(FileHandle dest){\r\n    switch(type) {\r\n        case Classpath:\r\n            throw new GdxRuntimeException(\"Cannot move a classpath file: \" + file);\r\n        case Internal:\r\n            throw new GdxRuntimeException(\"Cannot move an internal file: \" + file);\r\n        case Absolute:\r\n        case External:\r\n            if (file().renameTo(dest.file()))\r\n                return;\r\n    }\r\n    copyTo(dest);\r\n    delete();\r\n    if (exists() && isDirectory())\r\n        deleteDirectory();\r\n}"
}, {
	"Path": "org.junit.runner.Result.getRunTime",
	"Comment": "returns the number of milliseconds it took to run the entire suite to run",
	"Method": "long getRunTime(){\r\n    return runTime.get();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.asIntArray",
	"Comment": "returns the children of this value as a newly allocated int array.",
	"Method": "int[] asIntArray(){\r\n    if (type != ValueType.array)\r\n        throw new IllegalStateException(\"Value is not an array: \" + type);\r\n    int[] array = new int[size];\r\n    int i = 0;\r\n    for (JsonValue value = child; value != null; value = value.next, i++) {\r\n        int v;\r\n        switch(value.type) {\r\n            case stringValue:\r\n                v = Integer.parseInt(value.stringValue);\r\n                break;\r\n            case doubleValue:\r\n                v = (int) value.doubleValue;\r\n                break;\r\n            case longValue:\r\n                v = (int) value.longValue;\r\n                break;\r\n            case booleanValue:\r\n                v = value.longValue != 0 ? 1 : 0;\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Value cannot be converted to int: \" + value.type);\r\n        }\r\n        array[i] = v;\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.VertexAttributes.getOffset",
	"Comment": "returns the offset for the first vertexattribute with the specified usage.",
	"Method": "int getOffset(int usage,int defaultIfNotFound,int getOffset,int usage){\r\n    return getOffset(usage, 0);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntFloatMap.shrink",
	"Comment": "reduces the size of the backing arrays to be the specified capacity or less. if the capacity is already less, nothing is\tdone. if the map contains more items than the specified capacity, the next highest power of two capacity is used instead.",
	"Method": "void shrink(int maximumCapacity){\r\n    if (maximumCapacity < 0)\r\n        throw new IllegalArgumentException(\"maximumCapacity must be >= 0: \" + maximumCapacity);\r\n    if (size > maximumCapacity)\r\n        maximumCapacity = size;\r\n    if (capacity <= maximumCapacity)\r\n        return;\r\n    maximumCapacity = MathUtils.nextPowerOfTwo(maximumCapacity);\r\n    resize(maximumCapacity);\r\n}"
}, {
	"Path": "com.codahale.metrics.MetricRegistry.getGauges",
	"Comment": "returns a map of all the gauges in the registry and their names which match the given filter.",
	"Method": "SortedMap<String, Gauge> getGauges(SortedMap<String, Gauge> getGauges,MetricFilter filter){\r\n    return getMetrics(Gauge.class, filter);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.getAngleAround",
	"Comment": "get the angle in degrees of the rotation around the specified axis. the axis must be normalized.",
	"Method": "float getAngleAround(float axisX,float axisY,float axisZ,float getAngleAround,Vector3 axis){\r\n    return getAngleAround(axis.x, axis.y, axis.z);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Actor.addCaptureListener",
	"Comment": "adds a listener that is only notified during the capture phase.",
	"Method": "boolean addCaptureListener(EventListener listener){\r\n    if (listener == null)\r\n        throw new IllegalArgumentException(\"listener cannot be null.\");\r\n    if (!captureListeners.contains(listener, true))\r\n        captureListeners.add(listener);\r\n    return true;\r\n}"
}, {
	"Path": "java.nio.DoubleBuffer.arrayOffset",
	"Comment": "returns the offset of the double array which this buffer is based on, if there is one.\tthe offset is the index of the array corresponding to the zero position of the buffer.",
	"Method": "int arrayOffset(){\r\n    return protectedArrayOffset();\r\n}"
}, {
	"Path": "org.jsoup.select.Elements.next",
	"Comment": "get the immediate next element sibling of each element in this list, filtered by the query.",
	"Method": "Elements next(Elements next,String query){\r\n    return siblings(query, true, false);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ByteArray.removeRange",
	"Comment": "removes the items between the specified indices, inclusive.",
	"Method": "void removeRange(int start,int end){\r\n    if (end >= size)\r\n        throw new IndexOutOfBoundsException(\"end can't be >= size: \" + end + \" >= \" + size);\r\n    if (start > end)\r\n        throw new IndexOutOfBoundsException(\"start can't be > end: \" + start + \" > \" + end);\r\n    byte[] items = this.items;\r\n    int count = end - start + 1;\r\n    if (ordered)\r\n        System.arraycopy(items, start + count, items, start, size - (start + count));\r\n    else {\r\n        int lastIndex = this.size - 1;\r\n        for (int i = 0; i < count; i++) items[start + i] = items[lastIndex - i];\r\n    }\r\n    size -= count;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Rectangle.merge",
	"Comment": "merges this rectangle with a list of points. the rectangle should not have negative width or negative height.",
	"Method": "Rectangle merge(Rectangle rect,Rectangle merge,float x,float y,Rectangle merge,Vector2 vec,Rectangle merge,Vector2[] vecs){\r\n    float minX = x;\r\n    float maxX = x + width;\r\n    float minY = y;\r\n    float maxY = y + height;\r\n    for (int i = 0; i < vecs.length; ++i) {\r\n        Vector2 v = vecs[i];\r\n        minX = Math.min(minX, v.x);\r\n        maxX = Math.max(maxX, v.x);\r\n        minY = Math.min(minY, v.y);\r\n        maxY = Math.max(maxY, v.y);\r\n    }\r\n    x = minX;\r\n    width = maxX - minX;\r\n    y = minY;\r\n    height = maxY - minY;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Intersector.intersectSegmentCircleDisplace",
	"Comment": "checks whether the line segment and the circle intersect and returns by how much and in what direction the line has to move\taway from the circle to not intersect.",
	"Method": "float intersectSegmentCircleDisplace(Vector2 start,Vector2 end,Vector2 point,float radius,Vector2 displacement){\r\n    float u = (point.x - start.x) * (end.x - start.x) + (point.y - start.y) * (end.y - start.y);\r\n    float d = start.dst(end);\r\n    u /= d * d;\r\n    if (u < 0 || u > 1)\r\n        return Float.POSITIVE_INFINITY;\r\n    tmp.set(end.x, end.y, 0).sub(start.x, start.y, 0);\r\n    tmp2.set(start.x, start.y, 0).add(tmp.scl(u));\r\n    d = tmp2.dst(point.x, point.y, 0);\r\n    if (d < radius) {\r\n        displacement.set(point).sub(tmp2.x, tmp2.y).nor();\r\n        return d;\r\n    } else\r\n        return Float.POSITIVE_INFINITY;\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.MaterialCalendarView.onDateUnselected",
	"Comment": "called by the adapter for cases when changes in state result in dates being unselected",
	"Method": "void onDateUnselected(CalendarDay date){\r\n    dispatchOnDateSelected(date, false);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withDisplayBelowStatusBar",
	"Comment": "sets that the slider of this drawer should be displayed below the statusbar even with a translucentstatusbar",
	"Method": "DrawerBuilder withDisplayBelowStatusBar(boolean displayBelowStatusBar){\r\n    this.mDisplayBelowStatusBar = displayBelowStatusBar;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntSet.shrink",
	"Comment": "reduces the size of the backing arrays to be the specified capacity or less. if the capacity is already less, nothing is\tdone. if the set contains more items than the specified capacity, the next highest power of two capacity is used instead.",
	"Method": "void shrink(int maximumCapacity){\r\n    if (maximumCapacity < 0)\r\n        throw new IllegalArgumentException(\"maximumCapacity must be >= 0: \" + maximumCapacity);\r\n    if (size > maximumCapacity)\r\n        maximumCapacity = size;\r\n    if (capacity <= maximumCapacity)\r\n        return;\r\n    maximumCapacity = MathUtils.nextPowerOfTwo(maximumCapacity);\r\n    resize(maximumCapacity);\r\n}"
}, {
	"Path": "lombok.installer.eclipse.EclipseProductLocation.getUninstallDirs",
	"Comment": "returns directories that may contain lombok.jar files that need to be deleted.",
	"Method": "List<File> getUninstallDirs(){\r\n    List<File> result = new ArrayList<File>();\r\n    File x = new File(name);\r\n    if (!x.isDirectory())\r\n        x = x.getParentFile();\r\n    if (x.isDirectory())\r\n        result.add(x);\r\n    result.add(eclipseIniPath.getParentFile());\r\n    return result;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withAdapterWrapper",
	"Comment": "defines a adapter which wraps the main adapter used in the recyclerview to allow extended navigation and other stuff",
	"Method": "DrawerBuilder withAdapterWrapper(RecyclerView.Adapter adapterWrapper){\r\n    if (mAdapter == null) {\r\n        throw new RuntimeException(\"this adapter has to be set in conjunction to a normal adapter which is used inside this wrapper adapter\");\r\n    }\r\n    this.mAdapterWrapper = adapterWrapper;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Plane.distance",
	"Comment": "calculates the shortest signed distance between the plane and the given point.",
	"Method": "float distance(Vector3 point){\r\n    return normal.dot(point) + d;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.profiling.GLProfiler.reset",
	"Comment": "will reset the statistical information which has been collected so far. this should be called after every frame.\terror listener is kept as it is.",
	"Method": "void reset(){\r\n    glInterceptor.reset();\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.collision.btBroadphaseProxy.free",
	"Comment": "delete the native object if required and allow the instance to be reused by the obtain method",
	"Method": "void free(btBroadphaseProxy inst){\r\n    inst.dispose();\r\n    pool.free(inst);\r\n}"
}, {
	"Path": "lombok.bytecode.ClassFileMetaData.usesField",
	"Comment": "checks if the constant pool contains a reference to a given field, either for writing or reading.",
	"Method": "boolean usesField(String className,String fieldName){\r\n    int classIndex = findClass(className);\r\n    if (classIndex == NOT_FOUND)\r\n        return false;\r\n    int fieldNameIndex = findUtf8(fieldName);\r\n    if (fieldNameIndex == NOT_FOUND)\r\n        return false;\r\n    for (int i = 1; i < maxPoolSize; i++) {\r\n        if (types[i] == FIELD && readValue(offsets[i]) == classIndex) {\r\n            int nameAndTypeIndex = readValue(offsets[i] + 2);\r\n            if (readValue(offsets[nameAndTypeIndex]) == fieldNameIndex)\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData.invalidate",
	"Comment": "invalidates the indexbufferobject so a new opengl buffer handle is created. use this in case of a context loss.",
	"Method": "void invalidate(){\r\n    bufferHandle = createBufferObject();\r\n    isDirty = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.BitmapFont.getRegions",
	"Comment": "returns the array of textureregions that represents each texture page of glyphs.",
	"Method": "Array<TextureRegion> getRegions(){\r\n    return regions;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane.setOverscroll",
	"Comment": "for flick scroll, if true the widget can be scrolled slightly past its bounds and will animate back to its bounds when\tscrolling is stopped. default is true.",
	"Method": "void setOverscroll(boolean overscrollX,boolean overscrollY){\r\n    this.overscrollX = overscrollX;\r\n    this.overscrollY = overscrollY;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.PixmapPacker.pack",
	"Comment": "inserts the pixmap without a name. it cannot be looked up by name.",
	"Method": "Rectangle pack(Pixmap image,Rectangle pack,String name,Pixmap image,Page pack,PixmapPacker packer,String name,Rectangle rect,Page pack,PixmapPacker packer,String name,Rectangle rect,Page pack,PixmapPacker packer,String name,Rectangle rect){\r\n    if (disposed)\r\n        return null;\r\n    if (name != null && getRect(name) != null)\r\n        throw new GdxRuntimeException(\"Pixmap has already been packed with name: \" + name);\r\n    boolean isPatch = name != null && name.endsWith(\".9\");\r\n    PixmapPackerRectangle rect;\r\n    Pixmap pixmapToDispose = null;\r\n    if (isPatch) {\r\n        rect = new PixmapPackerRectangle(0, 0, image.getWidth() - 2, image.getHeight() - 2);\r\n        pixmapToDispose = new Pixmap(image.getWidth() - 2, image.getHeight() - 2, image.getFormat());\r\n        rect.splits = getSplits(image);\r\n        rect.pads = getPads(image, rect.splits);\r\n        pixmapToDispose.drawPixmap(image, 0, 0, 1, 1, image.getWidth() - 1, image.getHeight() - 1);\r\n        image = pixmapToDispose;\r\n        name = name.split(\"\\\\.\")[0];\r\n    } else {\r\n        if (stripWhitespaceX || stripWhitespaceY) {\r\n            int originalWidth = image.getWidth();\r\n            int originalHeight = image.getHeight();\r\n            int top = 0;\r\n            int bottom = image.getHeight();\r\n            if (stripWhitespaceY) {\r\n                outer: for (int y = 0; y < image.getHeight(); y++) {\r\n                    for (int x = 0; x < image.getWidth(); x++) {\r\n                        int pixel = image.getPixel(x, y);\r\n                        int alpha = ((pixel & 0x000000ff));\r\n                        if (alpha > alphaThreshold)\r\n                            break outer;\r\n                    }\r\n                    top++;\r\n                }\r\n                outer: for (int y = image.getHeight(); --y >= top; ) {\r\n                    for (int x = 0; x < image.getWidth(); x++) {\r\n                        int pixel = image.getPixel(x, y);\r\n                        int alpha = ((pixel & 0x000000ff));\r\n                        if (alpha > alphaThreshold)\r\n                            break outer;\r\n                    }\r\n                    bottom--;\r\n                }\r\n            }\r\n            int left = 0;\r\n            int right = image.getWidth();\r\n            if (stripWhitespaceX) {\r\n                outer: for (int x = 0; x < image.getWidth(); x++) {\r\n                    for (int y = top; y < bottom; y++) {\r\n                        int pixel = image.getPixel(x, y);\r\n                        int alpha = ((pixel & 0x000000ff));\r\n                        if (alpha > alphaThreshold)\r\n                            break outer;\r\n                    }\r\n                    left++;\r\n                }\r\n                outer: for (int x = image.getWidth(); --x >= left; ) {\r\n                    for (int y = top; y < bottom; y++) {\r\n                        int pixel = image.getPixel(x, y);\r\n                        int alpha = ((pixel & 0x000000ff));\r\n                        if (alpha > alphaThreshold)\r\n                            break outer;\r\n                    }\r\n                    right--;\r\n                }\r\n            }\r\n            int newWidth = right - left;\r\n            int newHeight = bottom - top;\r\n            pixmapToDispose = new Pixmap(newWidth, newHeight, image.getFormat());\r\n            pixmapToDispose.drawPixmap(image, 0, 0, left, top, newWidth, newHeight);\r\n            image = pixmapToDispose;\r\n            rect = new PixmapPackerRectangle(0, 0, newWidth, newHeight, left, top, originalWidth, originalHeight);\r\n        } else {\r\n            rect = new PixmapPackerRectangle(0, 0, image.getWidth(), image.getHeight());\r\n        }\r\n    }\r\n    if (rect.getWidth() > pageWidth || rect.getHeight() > pageHeight) {\r\n        if (name == null)\r\n            throw new GdxRuntimeException(\"Page size too small for pixmap.\");\r\n        throw new GdxRuntimeException(\"Page size too small for pixmap: \" + name);\r\n    }\r\n    Page page = packStrategy.pack(this, name, rect);\r\n    if (name != null) {\r\n        page.rects.put(name, rect);\r\n        page.addedRects.add(name);\r\n    }\r\n    int rectX = (int) rect.x, rectY = (int) rect.y, rectWidth = (int) rect.width, rectHeight = (int) rect.height;\r\n    if (packToTexture && !duplicateBorder && page.texture != null && !page.dirty) {\r\n        page.texture.bind();\r\n        Gdx.gl.glTexSubImage2D(page.texture.glTarget, 0, rectX, rectY, rectWidth, rectHeight, image.getGLFormat(), image.getGLType(), image.getPixels());\r\n    } else\r\n        page.dirty = true;\r\n    page.image.setBlending(Blending.None);\r\n    page.image.drawPixmap(image, rectX, rectY);\r\n    if (duplicateBorder) {\r\n        int imageWidth = image.getWidth(), imageHeight = image.getHeight();\r\n        page.image.drawPixmap(image, 0, 0, 1, 1, rectX - 1, rectY - 1, 1, 1);\r\n        page.image.drawPixmap(image, imageWidth - 1, 0, 1, 1, rectX + rectWidth, rectY - 1, 1, 1);\r\n        page.image.drawPixmap(image, 0, imageHeight - 1, 1, 1, rectX - 1, rectY + rectHeight, 1, 1);\r\n        page.image.drawPixmap(image, imageWidth - 1, imageHeight - 1, 1, 1, rectX + rectWidth, rectY + rectHeight, 1, 1);\r\n        page.image.drawPixmap(image, 0, 0, imageWidth, 1, rectX, rectY - 1, rectWidth, 1);\r\n        page.image.drawPixmap(image, 0, imageHeight - 1, imageWidth, 1, rectX, rectY + rectHeight, rectWidth, 1);\r\n        page.image.drawPixmap(image, 0, 0, 1, imageHeight, rectX - 1, rectY, 1, rectHeight);\r\n        page.image.drawPixmap(image, imageWidth - 1, 0, 1, imageHeight, rectX + rectWidth, rectY, 1, rectHeight);\r\n    }\r\n    if (pixmapToDispose != null) {\r\n        pixmapToDispose.dispose();\r\n    }\r\n    return rect;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.CharArray.setSize",
	"Comment": "sets the array size, leaving any values beyond the current size undefined.",
	"Method": "char[] setSize(int newSize){\r\n    if (newSize < 0)\r\n        throw new IllegalArgumentException(\"newSize must be >= 0: \" + newSize);\r\n    if (newSize > items.length)\r\n        resize(Math.max(8, newSize));\r\n    size = newSize;\r\n    return items;\r\n}"
}, {
	"Path": "com.badlogic.gdx.files.FileHandle.delete",
	"Comment": "deletes this file or empty directory and returns success. will not delete a directory that has children.",
	"Method": "boolean delete(){\r\n    if (type == FileType.Classpath)\r\n        throw new GdxRuntimeException(\"Cannot delete a classpath file: \" + file);\r\n    if (type == FileType.Internal)\r\n        throw new GdxRuntimeException(\"Cannot delete an internal file: \" + file);\r\n    return file().delete();\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.setAwake",
	"Comment": "set the sleep state of the body. a sleeping body has very low cpu cost.",
	"Method": "void setAwake(boolean flag){\r\n    if (flag) {\r\n        if ((m_flags & e_awakeFlag) == 0) {\r\n            m_flags |= e_awakeFlag;\r\n            m_sleepTime = 0.0f;\r\n        }\r\n    } else {\r\n        m_flags &= ~e_awakeFlag;\r\n        m_sleepTime = 0.0f;\r\n        m_linearVelocity.setZero();\r\n        m_angularVelocity = 0.0f;\r\n        m_force.setZero();\r\n        m_torque = 0.0f;\r\n    }\r\n}"
}, {
	"Path": "com.rey.material.app.Dialog.negativeActionTextAppearance",
	"Comment": "sets the text color, size, style of negative action button from the specified textappearance resource.",
	"Method": "Dialog negativeActionTextAppearance(int resId){\r\n    mNegativeAction.setTextAppearance(getContext(), resId);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.SortedIntList.iterator",
	"Comment": "returns an iterator to traverse the list.\tonly one iterator can be active per list at any given time.",
	"Method": "java.util.Iterator<Node<E>> iterator(){\r\n    if (iterator == null) {\r\n        iterator = new Iterator();\r\n    }\r\n    return iterator.reset();\r\n}"
}, {
	"Path": "com.sun.jna.Pointer.writeArray",
	"Comment": "write memory starting at offset from the array with element type cls.",
	"Method": "void writeArray(long offset,Object value,Class<?> cls){\r\n    if (cls == byte.class) {\r\n        byte[] buf = (byte[]) value;\r\n        write(offset, buf, 0, buf.length);\r\n    } else if (cls == short.class) {\r\n        short[] buf = (short[]) value;\r\n        write(offset, buf, 0, buf.length);\r\n    } else if (cls == char.class) {\r\n        char[] buf = (char[]) value;\r\n        write(offset, buf, 0, buf.length);\r\n    } else if (cls == int.class) {\r\n        int[] buf = (int[]) value;\r\n        write(offset, buf, 0, buf.length);\r\n    } else if (cls == long.class) {\r\n        long[] buf = (long[]) value;\r\n        write(offset, buf, 0, buf.length);\r\n    } else if (cls == float.class) {\r\n        float[] buf = (float[]) value;\r\n        write(offset, buf, 0, buf.length);\r\n    } else if (cls == double.class) {\r\n        double[] buf = (double[]) value;\r\n        write(offset, buf, 0, buf.length);\r\n    } else if (Pointer.class.isAssignableFrom(cls)) {\r\n        Pointer[] buf = (Pointer[]) value;\r\n        write(offset, buf, 0, buf.length);\r\n    } else if (Structure.class.isAssignableFrom(cls)) {\r\n        Structure[] sbuf = (Structure[]) value;\r\n        if (Structure.ByReference.class.isAssignableFrom(cls)) {\r\n            Pointer[] buf = new Pointer[sbuf.length];\r\n            for (int i = 0; i < sbuf.length; i++) {\r\n                if (sbuf[i] == null) {\r\n                    buf[i] = null;\r\n                } else {\r\n                    buf[i] = sbuf[i].getPointer();\r\n                    sbuf[i].write();\r\n                }\r\n            }\r\n            write(offset, buf, 0, buf.length);\r\n        } else {\r\n            Structure first = sbuf[0];\r\n            if (first == null) {\r\n                first = Structure.newInstance((Class<Structure>) cls, share(offset));\r\n                sbuf[0] = first;\r\n            } else {\r\n                first.useMemory(this, (int) offset, true);\r\n            }\r\n            first.write();\r\n            Structure[] tmp = first.toArray(sbuf.length);\r\n            for (int i = 1; i < sbuf.length; i++) {\r\n                if (sbuf[i] == null) {\r\n                    sbuf[i] = tmp[i];\r\n                } else {\r\n                    sbuf[i].useMemory(this, (int) (offset + i * sbuf[i].size()), true);\r\n                }\r\n                sbuf[i].write();\r\n            }\r\n        }\r\n    } else if (NativeMapped.class.isAssignableFrom(cls)) {\r\n        NativeMapped[] buf = (NativeMapped[]) value;\r\n        NativeMappedConverter tc = NativeMappedConverter.getInstance(cls);\r\n        Class<?> nativeType = tc.nativeType();\r\n        int size = Native.getNativeSize(value.getClass(), value) / buf.length;\r\n        for (int i = 0; i < buf.length; i++) {\r\n            Object element = tc.toNative(buf[i], new ToNativeContext());\r\n            setValue(offset + i * size, element, nativeType);\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException(\"Writing array of \" + cls + \" to memory not supported\");\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.AndroidGraphics.setupGL",
	"Comment": "this instantiates the gl10, gl11 and gl20 instances. includes the check for certain devices that pretend to support gl11 but\tfuck up vertex buffer objects. this includes the pixelflinger which segfaults when buffers are deleted as well as the\tmotorola cliq and the samsung behold ii.",
	"Method": "void setupGL(javax.microedition.khronos.opengles.GL10 gl){\r\n    String versionString = gl.glGetString(GL10.GL_VERSION);\r\n    String vendorString = gl.glGetString(GL10.GL_VENDOR);\r\n    String rendererString = gl.glGetString(GL10.GL_RENDERER);\r\n    glVersion = new GLVersion(Application.ApplicationType.Android, versionString, vendorString, rendererString);\r\n    if (config.useGL30 && glVersion.getMajorVersion() > 2) {\r\n        if (gl30 != null)\r\n            return;\r\n        gl20 = gl30 = new AndroidGL30();\r\n        Gdx.gl = gl30;\r\n        Gdx.gl20 = gl30;\r\n        Gdx.gl30 = gl30;\r\n    } else {\r\n        if (gl20 != null)\r\n            return;\r\n        gl20 = new AndroidGL20();\r\n        Gdx.gl = gl20;\r\n        Gdx.gl20 = gl20;\r\n    }\r\n    Gdx.app.log(LOG_TAG, \"OGL renderer: \" + gl.glGetString(GL10.GL_RENDERER));\r\n    Gdx.app.log(LOG_TAG, \"OGL vendor: \" + gl.glGetString(GL10.GL_VENDOR));\r\n    Gdx.app.log(LOG_TAG, \"OGL version: \" + gl.glGetString(GL10.GL_VERSION));\r\n    Gdx.app.log(LOG_TAG, \"OGL extensions: \" + gl.glGetString(GL10.GL_EXTENSIONS));\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.setType",
	"Comment": "set the type of this body. this may alter the mass and velocity.",
	"Method": "void setType(BodyType type){\r\n    org.jbox2d.dynamics.BodyType t = org.jbox2d.dynamics.BodyType.DYNAMIC;\r\n    if (type == BodyType.DynamicBody)\r\n        t = org.jbox2d.dynamics.BodyType.DYNAMIC;\r\n    if (type == BodyType.KinematicBody)\r\n        t = org.jbox2d.dynamics.BodyType.KINEMATIC;\r\n    if (type == BodyType.StaticBody)\r\n        t = org.jbox2d.dynamics.BodyType.STATIC;\r\n    body.setType(t);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane.setScrollBarPositions",
	"Comment": "set the position of the vertical and horizontal scroll bars.",
	"Method": "void setScrollBarPositions(boolean bottom,boolean right){\r\n    hScrollOnBottom = bottom;\r\n    vScrollOnRight = right;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController.end",
	"Comment": "end applying multiple animations to the instance and update it to reflect the changes.",
	"Method": "void end(){\r\n    if (!applying)\r\n        throw new GdxRuntimeException(\"You must call begin() first\");\r\n    for (Entry<Node, Transform> entry : transforms.entries()) {\r\n        entry.value.toMatrix4(entry.key.localTransform);\r\n        transformPool.free(entry.value);\r\n    }\r\n    transforms.clear();\r\n    target.calculateTransforms();\r\n    applying = false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton.updateImage",
	"Comment": "updates the image with the appropriate drawable from the style before it is drawn.",
	"Method": "void updateImage(){\r\n    Drawable drawable = null;\r\n    if (isDisabled() && style.imageDisabled != null)\r\n        drawable = style.imageDisabled;\r\n    else if (isPressed() && style.imageDown != null)\r\n        drawable = style.imageDown;\r\n    else if (isChecked && style.imageChecked != null)\r\n        drawable = (style.imageCheckedOver != null && isOver()) ? style.imageCheckedOver : style.imageChecked;\r\n    else if (isOver() && style.imageOver != null)\r\n        drawable = style.imageOver;\r\n    else if (style.imageUp != null)\r\n        drawable = style.imageUp;\r\n    image.setDrawable(drawable);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ShortArray.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "short[] ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded > items.length)\r\n        resize(Math.max(8, sizeNeeded));\r\n    return items;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.getAutoClearForces",
	"Comment": "get the flag that controls automatic clearing of forces after each time step.",
	"Method": "boolean getAutoClearForces(){\r\n    return (m_flags & CLEAR_FORCES) == CLEAR_FORCES;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getMarqueeRepeatLimit",
	"Comment": "gets the number of times the marquee animation is repeated. only meaningful if thetextview has marquee enabled.",
	"Method": "int getMarqueeRepeatLimit(){\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN)\r\n        return mInputView.getMarqueeRepeatLimit();\r\n    return -1;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Json.addClassTag",
	"Comment": "sets a tag to use instead of the fully qualifier class name. this can make the json easier to read.",
	"Method": "void addClassTag(String tag,Class type){\r\n    tagToClass.put(tag, type);\r\n    classToTag.put(type, tag);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer.begin",
	"Comment": "binds the frame buffer and sets the viewport accordingly, so everything gets drawn to it.",
	"Method": "void begin(){\r\n    bind();\r\n    setFrameBufferViewport();\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Camera.normalizeUp",
	"Comment": "normalizes the up vector by first calculating the right vector via a cross product between direction and up, and then\trecalculating the up vector via a cross product between right and direction.",
	"Method": "void normalizeUp(){\r\n    tmpVec.set(direction).crs(up).nor();\r\n    up.set(tmpVec).crs(direction).nor();\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio.retain",
	"Comment": "retains a list of the most recently played sounds and stops the sound played least recently if necessary for a new sound to",
	"Method": "void retain(OpenALSound sound,boolean stop){\r\n    mostRecetSound++;\r\n    mostRecetSound %= recentSounds.length;\r\n    if (stop) {\r\n        if (recentSounds[mostRecetSound] != null)\r\n            recentSounds[mostRecetSound].stop();\r\n    }\r\n    recentSounds[mostRecetSound] = sound;\r\n}"
}, {
	"Path": "com.google.gwt.webgl.client.WebGLRenderingContext.getContext",
	"Comment": "returns a webgl context for the given canvas element. returns null if no 3d context is available.",
	"Method": "WebGLRenderingContext getContext(CanvasElement canvas,WebGLRenderingContext getContext,CanvasElement canvas,WebGLContextAttributes attributes){\r\n    return getContext(canvas, WebGLContextAttributes.create());\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.MiniDrawer.withOnMiniDrawerItemLongClickListener",
	"Comment": "define an onlongclicklistener for the minidrawer item adapter",
	"Method": "MiniDrawer withOnMiniDrawerItemLongClickListener(OnLongClickListener<IDrawerItem> onMiniDrawerItemLongClickListener){\r\n    this.mOnMiniDrawerItemLongClickListener = onMiniDrawerItemLongClickListener;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleController.replaceInfluencer",
	"Comment": "replaces the influencer of the given type with the one passed as parameter.",
	"Method": "boolean replaceInfluencer(Class<K> type,K newInfluencer){\r\n    int index = findIndex(type);\r\n    if (index > -1) {\r\n        influencers.insert(index, newInfluencer);\r\n        influencers.removeIndex(index + 1);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.model.SecondaryToggleDrawerItem.getColor",
	"Comment": "helper method to decide for the correct coloroverwrite to get the correct secondary color",
	"Method": "int getColor(Context ctx){\r\n    int color;\r\n    if (this.isEnabled()) {\r\n        color = ColorHolder.color(getTextColor(), ctx, R.attr.material_drawer_secondary_text, R.color.material_drawer_secondary_text);\r\n    } else {\r\n        color = ColorHolder.color(getDisabledTextColor(), ctx, R.attr.material_drawer_hint_text, R.color.material_drawer_hint_text);\r\n    }\r\n    return color;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.MiniDrawer.withCrossFader",
	"Comment": "provide the crossfader implementation which is used with this minidrawer",
	"Method": "MiniDrawer withCrossFader(ICrossfader crossFader){\r\n    this.mCrossFader = crossFader;\r\n    return this;\r\n}"
}, {
	"Path": "com.rey.material.app.Dialog.showDivider",
	"Comment": "indicate that dialog should show divider when the content is longer than container view.",
	"Method": "Dialog showDivider(boolean show){\r\n    mCardView.setShowDivider(show);\r\n    return this;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withActionBarDrawerToggle",
	"Comment": "add a custom actionbardrawertoggle which will be used in combination with this drawer.",
	"Method": "DrawerBuilder withActionBarDrawerToggle(boolean actionBarDrawerToggleEnabled,DrawerBuilder withActionBarDrawerToggle,ActionBarDrawerToggle actionBarDrawerToggle){\r\n    this.mActionBarDrawerToggleEnabled = true;\r\n    this.mActionBarDrawerToggle = actionBarDrawerToggle;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.TextureAtlas.addRegion",
	"Comment": "adds a region to the atlas. the texture for the specified region will be disposed when the atlas is disposed.",
	"Method": "AtlasRegion addRegion(String name,Texture texture,int x,int y,int width,int height,AtlasRegion addRegion,String name,TextureRegion textureRegion){\r\n    return addRegion(name, textureRegion.texture, textureRegion.getRegionX(), textureRegion.getRegionY(), textureRegion.getRegionWidth(), textureRegion.getRegionHeight());\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.model.Node.addChildren",
	"Comment": "adds the specified nodes as the currently last child of this node. if the node is already a child of another node, then it\tis removed from its current parent.",
	"Method": "int addChildren(Iterable<T> nodes){\r\n    return insertChildren(-1, nodes);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.BitmapFontCache.setPosition",
	"Comment": "sets the position of the text, relative to the position when the cached text was created.",
	"Method": "void setPosition(float x,float y){\r\n    translate(x - this.x, y - this.y);\r\n}"
}, {
	"Path": "lombok.delombok.FormatPreferences.fillEmpties",
	"Comment": "if true, empty lines should still be appropriately indented. if false, empty lines should be completely blank.",
	"Method": "boolean fillEmpties(){\r\n    return filledEmpties == null ? false : filledEmpties;\r\n}"
}, {
	"Path": "java.nio.LongBuffer.array",
	"Comment": "returns the long array which this buffer is based on, if there is one.",
	"Method": "long[] array(){\r\n    return protectedArray();\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.getUserData",
	"Comment": "get the user data pointer that was provided in the body definition.",
	"Method": "Object getUserData(){\r\n    return m_userData;\r\n}"
}, {
	"Path": "java.io.Writer.checkError",
	"Comment": "returns true if this writer has encountered and suppressed an error. used by printwriters as an alternative to checked\texceptions.",
	"Method": "boolean checkError(){\r\n    return false;\r\n}"
}, {
	"Path": "org.junit.internal.TextListener.elapsedTimeAsString",
	"Comment": "returns the formatted string of the elapsed time. duplicated frombasetestrunner. fix it.",
	"Method": "String elapsedTimeAsString(long runTime){\r\n    return NumberFormat.getInstance().format((double) runTime / 1000);\r\n}"
}, {
	"Path": "java.nio.BufferFactory.newCharBuffer",
	"Comment": "returns a new array based char buffer with the specified capacity.",
	"Method": "CharBuffer newCharBuffer(char array,CharBuffer newCharBuffer,CharSequence chseq,CharBuffer newCharBuffer,int capacity){\r\n    return new ReadWriteCharArrayBuffer(capacity);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Vector3.sub",
	"Comment": "subtracts the given value from all components of this vector",
	"Method": "Vector3 sub(Vector3 a_vec,Vector3 sub,float x,float y,float z,Vector3 sub,float value){\r\n    return this.set(this.x - value, this.y - value, this.z - value);\r\n}"
}, {
	"Path": "org.junit.rules.TemporaryFolder.newFolder",
	"Comment": "returns a new fresh folder with a random name under the temporary folder.",
	"Method": "File newFolder(String path,File newFolder,String paths,File newFolder){\r\n    return createTemporaryFolderIn(getRoot());\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.Kernel32Util.getFileType",
	"Comment": "retrieves the result of getfiletype, provided the file exists.",
	"Method": "int getFileType(String fileName){\r\n    File f = new File(fileName);\r\n    if (!f.exists()) {\r\n        throw new FileNotFoundException(fileName);\r\n    }\r\n    HANDLE hFile = null;\r\n    Win32Exception err = null;\r\n    try {\r\n        hFile = Kernel32.INSTANCE.CreateFile(fileName, WinNT.GENERIC_READ, WinNT.FILE_SHARE_READ, new WinBase.SECURITY_ATTRIBUTES(), WinNT.OPEN_EXISTING, WinNT.FILE_ATTRIBUTE_NORMAL, new HANDLEByReference().getValue());\r\n        if (WinBase.INVALID_HANDLE_VALUE.equals(hFile)) {\r\n            throw new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n        }\r\n        int type = Kernel32.INSTANCE.GetFileType(hFile);\r\n        switch(type) {\r\n            case WinNT.FILE_TYPE_UNKNOWN:\r\n                int rc = Kernel32.INSTANCE.GetLastError();\r\n                switch(rc) {\r\n                    case WinError.NO_ERROR:\r\n                        break;\r\n                    default:\r\n                        throw new Win32Exception(rc);\r\n                }\r\n            default:\r\n                return type;\r\n        }\r\n    } catch (Win32Exception e) {\r\n        err = e;\r\n        throw err;\r\n    } finally {\r\n        try {\r\n            closeHandle(hFile);\r\n        } catch (Win32Exception e) {\r\n            if (err == null) {\r\n                err = e;\r\n            } else {\r\n                err.addSuppressedReflected(e);\r\n            }\r\n        }\r\n        if (err != null) {\r\n            throw err;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop.setDragTime",
	"Comment": "time in milliseconds that a drag must take before a drop will be considered valid. this ignores an accidental drag and drop\tthat was meant to be a click. default is 250.",
	"Method": "void setDragTime(int dragMillis){\r\n    this.dragTime = dragMillis;\r\n}"
}, {
	"Path": "java.nio.CharBuffer.get",
	"Comment": "reads chars from the current position into the specified char array, starting from the specified offset, and increases the\tposition by the number of chars read.",
	"Method": "char get(CharBuffer get,char[] dest,CharBuffer get,char[] dest,int off,int len,char get,int index){\r\n    int length = dest.length;\r\n    if ((off < 0) || (len < 0) || (long) off + (long) len > length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (len > remaining()) {\r\n        throw new BufferUnderflowException();\r\n    }\r\n    for (int i = off; i < off + len; i++) {\r\n        dest[i] = get();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.Model.calculateBoundingBox",
	"Comment": "calculate the bounding box of this model instance. this is a potential slow operation, it is advised to cache the result.",
	"Method": "BoundingBox calculateBoundingBox(BoundingBox out){\r\n    out.inf();\r\n    return extendBoundingBox(out);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.IndexBufferObject.invalidate",
	"Comment": "invalidates the indexbufferobject so a new opengl buffer handle is created. use this in case of a context loss.",
	"Method": "void invalidate(){\r\n    bufferHandle = Gdx.gl20.glGenBuffer();\r\n    isDirty = true;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.setShowSoftInputOnFocus",
	"Comment": "sets whether the soft input method will be made visible when thistextview gets focused. the default is true.",
	"Method": "void setShowSoftInputOnFocus(boolean show){\r\n    mInputView.setShowSoftInputOnFocus(show);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.QueryAABB",
	"Comment": "query the world for all fixtures that potentially overlap the provided aabb.",
	"Method": "void QueryAABB(QueryCallback callback,float lowerX,float lowerY,float upperX,float upperY){\r\n    aabb.lowerBound.set(lowerX, lowerY);\r\n    aabb.upperBound.set(upperX, upperY);\r\n    world.queryAABB(new org.jbox2d.callbacks.QueryCallback() {\r\n        @Override\r\n        public boolean reportFixture(org.jbox2d.dynamics.Fixture f) {\r\n            Fixture fixture = fixtures.get(f);\r\n            return callback.reportFixture(fixture);\r\n        }\r\n    }, aabb);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.QueryAABB",
	"Comment": "query the world for all fixtures that potentially overlap the provided aabb.",
	"Method": "void QueryAABB(QueryCallback callback,float lowerX,float lowerY,float upperX,float upperY){\r\n    Fixture fixture = fixtures.get(f);\r\n    return callback.reportFixture(fixture);\r\n}"
}, {
	"Path": "com.badlogic.gdx.tests.CollectionsTest.assertEquals",
	"Comment": "checks that the two values are equal, and that their hashcodes are equal.",
	"Method": "void assertEquals(Object a,Object b){\r\n    if (!a.equals(b))\r\n        throw new GdxRuntimeException(\"equals() failed: \" + a + \" != \" + b);\r\n    if (!b.equals(a))\r\n        throw new GdxRuntimeException(\"equals() failed (not symmetric): \" + b + \" != \" + a);\r\n    if (a.hashCode() != b.hashCode())\r\n        throw new GdxRuntimeException(\"hashCode() failed: \" + a + \" != \" + b);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.getString",
	"Comment": "finds the child with the specified index and returns it as a string.",
	"Method": "String getString(String name,String defaultValue,String getString,String name,String getString,int index){\r\n    JsonValue child = get(index);\r\n    if (child == null)\r\n        throw new IllegalArgumentException(\"Indexed value not found: \" + name);\r\n    return child.asString();\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.model.BaseDescribeableDrawerItem.bindViewHelper",
	"Comment": "a helper method to have the logic for all secondarydraweritems only once",
	"Method": "void bindViewHelper(BaseViewHolder viewHolder){\r\n    Context ctx = viewHolder.itemView.getContext();\r\n    viewHolder.itemView.setId(hashCode());\r\n    viewHolder.itemView.setSelected(isSelected());\r\n    viewHolder.itemView.setEnabled(isEnabled());\r\n    int selectedColor = getSelectedColor(ctx);\r\n    int color = getColor(ctx);\r\n    ColorStateList selectedTextColor = getTextColorStateList(color, getSelectedTextColor(ctx));\r\n    int iconColor = getIconColor(ctx);\r\n    int selectedIconColor = getSelectedIconColor(ctx);\r\n    themeDrawerItem(ctx, viewHolder.view, selectedColor, isSelectedBackgroundAnimated());\r\n    StringHolder.applyTo(this.getName(), viewHolder.name);\r\n    StringHolder.applyToOrHide(this.getDescription(), viewHolder.description);\r\n    viewHolder.name.setTextColor(selectedTextColor);\r\n    ColorHolder.applyToOr(getDescriptionTextColor(), viewHolder.description, selectedTextColor);\r\n    if (getTypeface() != null) {\r\n        viewHolder.name.setTypeface(getTypeface());\r\n        viewHolder.description.setTypeface(getTypeface());\r\n    }\r\n    Drawable icon = ImageHolder.decideIcon(getIcon(), ctx, iconColor, isIconTinted(), 1);\r\n    if (icon != null) {\r\n        Drawable selectedIcon = ImageHolder.decideIcon(getSelectedIcon(), ctx, selectedIconColor, isIconTinted(), 1);\r\n        ImageHolder.applyMultiIconTo(icon, iconColor, selectedIcon, selectedIconColor, isIconTinted(), viewHolder.icon);\r\n    } else {\r\n        ImageHolder.applyDecidedIconOrSetGone(getIcon(), viewHolder.icon, iconColor, isIconTinted(), 1);\r\n    }\r\n    DrawerUIUtils.setDrawerVerticalPadding(viewHolder.view, level);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.collision.btDbvtAabbMm.obtainForArgument",
	"Comment": "obtains a temporary instance, used for callback methods with one or more btdbvtaabbmm arguments",
	"Method": "btDbvtAabbMm obtainForArgument(long swigCPtr,boolean owner){\r\n    btDbvtAabbMm instance = argumentInstances[argumentIndex = (argumentIndex + 1) & 3];\r\n    instance.reset(swigCPtr, owner);\r\n    return instance;\r\n}"
}, {
	"Path": "org.junit.tests.experimental.max.MaxStarterTest.preferNewTestsOverTestsThatFailed",
	"Comment": "which order they run, you just want them both to be early in the sequence",
	"Method": "void preferNewTestsOverTestsThatFailed(){\r\n    Request one = Request.method(TwoTests.class, \"dontSucceed\");\r\n    fMax.run(one);\r\n    Request two = Request.aClass(TwoTests.class);\r\n    List<Description> things = fMax.sortedLeavesForTest(two);\r\n    Description succeed = Description.createTestDescription(TwoTests.class, \"succeed\");\r\n    assertEquals(succeed, things.get(0));\r\n    assertEquals(2, things.size());\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.setAllowSleep",
	"Comment": "set this flag to false if this body should never fall asleep. note that this increases cpuusage.",
	"Method": "void setAllowSleep(boolean allowSleep){\r\n    this.allowSleep = allowSleep;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Texture.clearAllTextures",
	"Comment": "clears all managed textures. this is an internal method. do not use it!",
	"Method": "void clearAllTextures(Application app){\r\n    managedTextures.remove(app);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Actor.getColor",
	"Comment": "returns the color the actor will be tinted when drawn. the returned instance can be modified to change the color.",
	"Method": "Color getColor(){\r\n    return color;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.GeometryUtils.barycoordInsideTriangle",
	"Comment": "returns true if the barycentric coordinates are inside the triangle.",
	"Method": "boolean barycoordInsideTriangle(Vector2 barycentric){\r\n    return barycentric.x >= 0 && barycentric.y >= 0 && barycentric.x + barycentric.y <= 1;\r\n}"
}, {
	"Path": "com.codahale.metrics.EWMA.fiveMinuteEWMA",
	"Comment": "creates a new ewma which is equivalent to the unix five minute load average and which expectsto be ticked every 5 seconds.",
	"Method": "EWMA fiveMinuteEWMA(){\r\n    return new EWMA(M5_ALPHA, INTERVAL, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.getAutoClearForces",
	"Comment": "get the flag that controls automatic clearing of forces after each time step.",
	"Method": "boolean getAutoClearForces(){\r\n    return world.getAutoClearForces();\r\n}"
}, {
	"Path": "com.badlogic.gdx.jnigen.FileDescriptor.moveTo",
	"Comment": "moves this file to the specified file, overwriting the file if it already exists.",
	"Method": "void moveTo(FileDescriptor dest){\r\n    if (type == FileType.Classpath)\r\n        throw new RuntimeException(\"Cannot move a classpath file: \" + file);\r\n    copyTo(dest);\r\n    delete();\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Stage.removeTouchFocus",
	"Comment": "removes the listener from being notified for all touchdragged and touchup events for the specified pointer and button. note\tthe listener may never receive a touchup event if this method is used.",
	"Method": "void removeTouchFocus(EventListener listener,Actor listenerActor,Actor target,int pointer,int button){\r\n    SnapshotArray<TouchFocus> touchFocuses = this.touchFocuses;\r\n    for (int i = touchFocuses.size - 1; i >= 0; i--) {\r\n        TouchFocus focus = touchFocuses.get(i);\r\n        if (focus.listener == listener && focus.listenerActor == listenerActor && focus.target == target && focus.pointer == pointer && focus.button == button) {\r\n            touchFocuses.removeIndex(i);\r\n            Pools.free(focus);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.CumulativeDistribution.value",
	"Comment": "finds the value whose interval contains the given probability\tbinary search algorithm is used to find the value.",
	"Method": "T value(float probability,T value){\r\n    return value(MathUtils.random());\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.DelaunayTriangulator.trim",
	"Comment": "removes all triangles with a centroid outside the specified hull, which may be concave. note some triangulations may have\ttriangles whose centroid is inside the hull but a portion is outside.",
	"Method": "void trim(ShortArray triangles,float[] points,float[] hull,int offset,int count){\r\n    short[] trianglesArray = triangles.items;\r\n    for (int i = triangles.size - 1; i >= 0; i -= 3) {\r\n        int p1 = trianglesArray[i - 2] * 2;\r\n        int p2 = trianglesArray[i - 1] * 2;\r\n        int p3 = trianglesArray[i] * 2;\r\n        GeometryUtils.triangleCentroid(points[p1], points[p1 + 1], points[p2], points[p2 + 1], points[p3], points[p3 + 1], centroid);\r\n        if (!Intersector.isPointInPolygon(hull, offset, count, centroid.x, centroid.y)) {\r\n            triangles.removeIndex(i);\r\n            triangles.removeIndex(i - 1);\r\n            triangles.removeIndex(i - 2);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.getFloat",
	"Comment": "finds the child with the specified index and returns it as a float.",
	"Method": "float getFloat(String name,float defaultValue,float getFloat,String name,float getFloat,int index){\r\n    JsonValue child = get(index);\r\n    if (child == null)\r\n        throw new IllegalArgumentException(\"Indexed value not found: \" + name);\r\n    return child.asFloat();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IdentityMap.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "void ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded >= threshold)\r\n        resize(MathUtils.nextPowerOfTwo((int) Math.ceil(sizeNeeded / loadFactor)));\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.texturepacker.ImageProcessor.stripWhitespace",
	"Comment": "strips whitespace and returns the rect, or null if the image should be ignored.",
	"Method": "Rect stripWhitespace(BufferedImage source){\r\n    WritableRaster alphaRaster = source.getAlphaRaster();\r\n    if (alphaRaster == null || (!settings.stripWhitespaceX && !settings.stripWhitespaceY))\r\n        return new Rect(source, 0, 0, source.getWidth(), source.getHeight(), false);\r\n    final byte[] a = new byte[1];\r\n    int top = 0;\r\n    int bottom = source.getHeight();\r\n    if (settings.stripWhitespaceY) {\r\n        outer: for (int y = 0; y < source.getHeight(); y++) {\r\n            for (int x = 0; x < source.getWidth(); x++) {\r\n                alphaRaster.getDataElements(x, y, a);\r\n                int alpha = a[0];\r\n                if (alpha < 0)\r\n                    alpha += 256;\r\n                if (alpha > settings.alphaThreshold)\r\n                    break outer;\r\n            }\r\n            top++;\r\n        }\r\n        outer: for (int y = source.getHeight(); --y >= top; ) {\r\n            for (int x = 0; x < source.getWidth(); x++) {\r\n                alphaRaster.getDataElements(x, y, a);\r\n                int alpha = a[0];\r\n                if (alpha < 0)\r\n                    alpha += 256;\r\n                if (alpha > settings.alphaThreshold)\r\n                    break outer;\r\n            }\r\n            bottom--;\r\n        }\r\n        if (settings.duplicatePadding) {\r\n            if (top > 0)\r\n                top--;\r\n            if (bottom < source.getHeight())\r\n                bottom++;\r\n        }\r\n    }\r\n    int left = 0;\r\n    int right = source.getWidth();\r\n    if (settings.stripWhitespaceX) {\r\n        outer: for (int x = 0; x < source.getWidth(); x++) {\r\n            for (int y = top; y < bottom; y++) {\r\n                alphaRaster.getDataElements(x, y, a);\r\n                int alpha = a[0];\r\n                if (alpha < 0)\r\n                    alpha += 256;\r\n                if (alpha > settings.alphaThreshold)\r\n                    break outer;\r\n            }\r\n            left++;\r\n        }\r\n        outer: for (int x = source.getWidth(); --x >= left; ) {\r\n            for (int y = top; y < bottom; y++) {\r\n                alphaRaster.getDataElements(x, y, a);\r\n                int alpha = a[0];\r\n                if (alpha < 0)\r\n                    alpha += 256;\r\n                if (alpha > settings.alphaThreshold)\r\n                    break outer;\r\n            }\r\n            right--;\r\n        }\r\n        if (settings.duplicatePadding) {\r\n            if (left > 0)\r\n                left--;\r\n            if (right < source.getWidth())\r\n                right++;\r\n        }\r\n    }\r\n    int newWidth = right - left;\r\n    int newHeight = bottom - top;\r\n    if (newWidth <= 0 || newHeight <= 0) {\r\n        if (settings.ignoreBlankImages)\r\n            return null;\r\n        else\r\n            return new Rect(emptyImage, 0, 0, 1, 1, false);\r\n    }\r\n    return new Rect(source, left, top, newWidth, newHeight, false);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.Selection.getLastSelected",
	"Comment": "makes a best effort to return the last item selected, else returns an arbitrary item or null if the selection is empty.",
	"Method": "T getLastSelected(){\r\n    if (lastSelected != null) {\r\n        return lastSelected;\r\n    } else if (selected.size > 0) {\r\n        return selected.first();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Cubemap.invalidateAllCubemaps",
	"Comment": "invalidate all managed cubemaps. this is an internal method. do not use it!",
	"Method": "void invalidateAllCubemaps(Application app){\r\n    Array<Cubemap> managedCubemapArray = managedCubemaps.get(app);\r\n    if (managedCubemapArray == null)\r\n        return;\r\n    if (assetManager == null) {\r\n        for (int i = 0; i < managedCubemapArray.size; i++) {\r\n            Cubemap cubemap = managedCubemapArray.get(i);\r\n            cubemap.reload();\r\n        }\r\n    } else {\r\n        assetManager.finishLoading();\r\n        Array<Cubemap> cubemaps = new Array<Cubemap>(managedCubemapArray);\r\n        for (Cubemap cubemap : cubemaps) {\r\n            String fileName = assetManager.getAssetFileName(cubemap);\r\n            if (fileName == null) {\r\n                cubemap.reload();\r\n            } else {\r\n                final int refCount = assetManager.getReferenceCount(fileName);\r\n                assetManager.setReferenceCount(fileName, 0);\r\n                cubemap.glHandle = 0;\r\n                CubemapParameter params = new CubemapParameter();\r\n                params.cubemapData = cubemap.getCubemapData();\r\n                params.minFilter = cubemap.getMinFilter();\r\n                params.magFilter = cubemap.getMagFilter();\r\n                params.wrapU = cubemap.getUWrap();\r\n                params.wrapV = cubemap.getVWrap();\r\n                params.cubemap = cubemap;\r\n                params.loadedCallback = new LoadedCallback() {\r\n                    @Override\r\n                    public void finishedLoading(AssetManager assetManager, String fileName, Class type) {\r\n                        assetManager.setReferenceCount(fileName, refCount);\r\n                    }\r\n                };\r\n                assetManager.unload(fileName);\r\n                cubemap.glHandle = Gdx.gl.glGenTexture();\r\n                assetManager.load(fileName, Cubemap.class, params);\r\n            }\r\n        }\r\n        managedCubemapArray.clear();\r\n        managedCubemapArray.addAll(cubemaps);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Cubemap.invalidateAllCubemaps",
	"Comment": "invalidate all managed cubemaps. this is an internal method. do not use it!",
	"Method": "void invalidateAllCubemaps(Application app){\r\n    assetManager.setReferenceCount(fileName, refCount);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.decals.Decal.getRotation",
	"Comment": "returns the rotation. the returned quaternion should under no circumstances be modified.",
	"Method": "Quaternion getRotation(){\r\n    return rotation;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.ShapeRenderer.rotate",
	"Comment": "multiplies the current transformation matrix by a rotation matrix.",
	"Method": "void rotate(float axisX,float axisY,float axisZ,float degrees){\r\n    transformMatrix.rotate(axisX, axisY, axisZ, degrees);\r\n    matrixDirty = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Actor.isAscendantOf",
	"Comment": "returns true if this actor is the same as or is the ascendant of the specified actor.",
	"Method": "boolean isAscendantOf(Actor actor){\r\n    if (actor == null)\r\n        throw new IllegalArgumentException(\"actor cannot be null.\");\r\n    while (true) {\r\n        if (actor == this)\r\n            return true;\r\n        actor = actor.parent;\r\n        if (actor == null)\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.FixtureDef.setShape",
	"Comment": "the shape, this must be set. the shape will be cloned, so you can create the shape on thestack.",
	"Method": "void setShape(Shape shape){\r\n    this.shape = shape;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.elementSiblingIndex",
	"Comment": "get the list index of this element in its element sibling list. i.e. if this is the first elementsibling, returns 0.",
	"Method": "int elementSiblingIndex(){\r\n    if (parent() == null)\r\n        return 0;\r\n    return indexInList(this, parent().childElementsList());\r\n}"
}, {
	"Path": "com.rey.material.app.ToolbarManager.notifyNavigationStateInvalidated",
	"Comment": "notify the current state of navigation icon is invalid. it should update the state immediately without showing animation.",
	"Method": "void notifyNavigationStateInvalidated(){\r\n    if (mNavigationManager != null)\r\n        mNavigationManager.notifyStateInvalidated();\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18.surfaceChanged",
	"Comment": "this method is part of the surfaceholder.callback interface, and isnot normally called or subclassed by clients of glsurfaceview.",
	"Method": "void surfaceChanged(SurfaceHolder holder,int format,int w,int h){\r\n    mGLThread.onWindowResize(w, h);\r\n}"
}, {
	"Path": "java.nio.ByteBuffer.get",
	"Comment": "returns the byte at the specified index and does not change the position.",
	"Method": "byte get(ByteBuffer get,byte[] dest,ByteBuffer get,byte[] dest,int off,int len,byte get,int index){\r\n    int length = dest.length;\r\n    if ((off < 0) || (len < 0) || ((long) off + (long) len > length)) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (len > remaining()) {\r\n        throw new BufferUnderflowException();\r\n    }\r\n    for (int i = off; i < off + len; i++) {\r\n        dest[i] = get();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codahale.metrics.MetricRegistry.getHistograms",
	"Comment": "returns a map of all the histograms in the registry and their names which match the givenfilter.",
	"Method": "SortedMap<String, Histogram> getHistograms(SortedMap<String, Histogram> getHistograms,MetricFilter filter){\r\n    return getMetrics(Histogram.class, filter);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Mesh.calculateRadiusSquared",
	"Comment": "calculates the squared radius of the bounding sphere around the specified center for the specified part.",
	"Method": "float calculateRadiusSquared(float centerX,float centerY,float centerZ,int offset,int count,Matrix4 transform){\r\n    int numIndices = getNumIndices();\r\n    if (offset < 0 || count < 1 || offset + count > numIndices)\r\n        throw new GdxRuntimeException(\"Not enough indices\");\r\n    final FloatBuffer verts = vertices.getBuffer();\r\n    final ShortBuffer index = indices.getBuffer();\r\n    final VertexAttribute posAttrib = getVertexAttribute(Usage.Position);\r\n    final int posoff = posAttrib.offset / 4;\r\n    final int vertexSize = vertices.getAttributes().vertexSize / 4;\r\n    final int end = offset + count;\r\n    float result = 0;\r\n    switch(posAttrib.numComponents) {\r\n        case 1:\r\n            for (int i = offset; i < end; i++) {\r\n                final int idx = index.get(i) * vertexSize + posoff;\r\n                tmpV.set(verts.get(idx), 0, 0);\r\n                if (transform != null)\r\n                    tmpV.mul(transform);\r\n                final float r = tmpV.sub(centerX, centerY, centerZ).len2();\r\n                if (r > result)\r\n                    result = r;\r\n            }\r\n            break;\r\n        case 2:\r\n            for (int i = offset; i < end; i++) {\r\n                final int idx = index.get(i) * vertexSize + posoff;\r\n                tmpV.set(verts.get(idx), verts.get(idx + 1), 0);\r\n                if (transform != null)\r\n                    tmpV.mul(transform);\r\n                final float r = tmpV.sub(centerX, centerY, centerZ).len2();\r\n                if (r > result)\r\n                    result = r;\r\n            }\r\n            break;\r\n        case 3:\r\n            for (int i = offset; i < end; i++) {\r\n                final int idx = index.get(i) * vertexSize + posoff;\r\n                tmpV.set(verts.get(idx), verts.get(idx + 1), verts.get(idx + 2));\r\n                if (transform != null)\r\n                    tmpV.mul(transform);\r\n                final float r = tmpV.sub(centerX, centerY, centerZ).len2();\r\n                if (r > result)\r\n                    result = r;\r\n            }\r\n            break;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Array.removeAll",
	"Comment": "removes from this array all of elements contained in the specified array.",
	"Method": "boolean removeAll(Array<? extends T> array,boolean identity){\r\n    int size = this.size;\r\n    int startSize = size;\r\n    T[] items = this.items;\r\n    if (identity) {\r\n        for (int i = 0, n = array.size; i < n; i++) {\r\n            T item = array.get(i);\r\n            for (int ii = 0; ii < size; ii++) {\r\n                if (item == items[ii]) {\r\n                    removeIndex(ii);\r\n                    size--;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = 0, n = array.size; i < n; i++) {\r\n            T item = array.get(i);\r\n            for (int ii = 0; ii < size; ii++) {\r\n                if (item.equals(items[ii])) {\r\n                    removeIndex(ii);\r\n                    size--;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return size != startSize;\r\n}"
}, {
	"Path": "com.badlogic.gdx.jnigen.FileDescriptor.length",
	"Comment": "returns the length in bytes of this file, or 0 if this file is a directory, does not exist, or the size cannot otherwise be\tdetermined.",
	"Method": "long length(){\r\n    if (type == FileType.Classpath || !file.exists()) {\r\n        InputStream input = read();\r\n        try {\r\n            return input.available();\r\n        } catch (Exception ignored) {\r\n        } finally {\r\n            try {\r\n                input.close();\r\n            } catch (IOException ignored) {\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    return file().length();\r\n}"
}, {
	"Path": "org.jbox2d.collision.shapes.PolygonShape.validate",
	"Comment": "validate convexity. this is a very time consuming operation.",
	"Method": "boolean validate(){\r\n    for (int i = 0; i < m_count; ++i) {\r\n        int i1 = i;\r\n        int i2 = i < m_count - 1 ? i1 + 1 : 0;\r\n        Vec2 p = m_vertices[i1];\r\n        Vec2 e = pool1.set(m_vertices[i2]).subLocal(p);\r\n        for (int j = 0; j < m_count; ++j) {\r\n            if (j == i1 || j == i2) {\r\n                continue;\r\n            }\r\n            Vec2 v = pool2.set(m_vertices[j]).subLocal(p);\r\n            float c = Vec2.cross(e, v);\r\n            if (c < 0.0f) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "lombok.javac.handlers.JavacHandlerUtil.getFieldType",
	"Comment": "returns the type of the field, unless a getter exists for this field, in which case the return type of the getter is returned.",
	"Method": "JCExpression getFieldType(JavacNode field,FieldAccess fieldAccess){\r\n    if (field.getKind() == Kind.METHOD)\r\n        return ((JCMethodDecl) field.get()).restype;\r\n    boolean lookForGetter = lookForGetter(field, fieldAccess);\r\n    GetterMethod getter = lookForGetter ? findGetter(field) : null;\r\n    if (getter == null) {\r\n        return ((JCVariableDecl) field.get()).vartype;\r\n    }\r\n    return getter.type;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.TextureAtlas.findRegion",
	"Comment": "returns the first region found with the specified name and index. this method uses string comparison to find the region, so\tthe result should be cached rather than calling this method multiple times.",
	"Method": "AtlasRegion findRegion(String name,AtlasRegion findRegion,String name,int index){\r\n    for (int i = 0, n = regions.size; i < n; i++) {\r\n        AtlasRegion region = regions.get(i);\r\n        if (!region.name.equals(name))\r\n            continue;\r\n        if (region.index != index)\r\n            continue;\r\n        return region;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codahale.metrics.graphite.PickledGraphite.writeMetrics",
	"Comment": "1. run the pickler script to package all the pending metrics into a single message2. send the message to graphite3. clear out the list of metrics",
	"Method": "void writeMetrics(){\r\n    if (metrics.size() > 0) {\r\n        try {\r\n            byte[] payload = pickleMetrics(metrics);\r\n            byte[] header = ByteBuffer.allocate(4).putInt(payload.length).array();\r\n            @SuppressWarnings(\"resource\")\r\n            OutputStream outputStream = socket.getOutputStream();\r\n            outputStream.write(header);\r\n            outputStream.write(payload);\r\n            outputStream.flush();\r\n            if (LOGGER.isDebugEnabled()) {\r\n                LOGGER.debug(\"Wrote {} metrics\", metrics.size());\r\n            }\r\n        } catch (IOException e) {\r\n            this.failures++;\r\n            throw e;\r\n        } finally {\r\n            metrics.clear();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Pixmap.drawLine",
	"Comment": "draws a line between the given coordinates using the currently set color.",
	"Method": "void drawLine(int x,int y,int x2,int y2){\r\n    pixmap.drawLine(x, y, x2, y2, color);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.util.DrawerUIUtils.isSystemBarOnBottom",
	"Comment": "helper to check if the system bar is on the bottom of the screen",
	"Method": "boolean isSystemBarOnBottom(Context ctx){\r\n    WindowManager wm = (WindowManager) ctx.getSystemService(Context.WINDOW_SERVICE);\r\n    DisplayMetrics metrics = new DisplayMetrics();\r\n    wm.getDefaultDisplay().getMetrics(metrics);\r\n    Configuration cfg = ctx.getResources().getConfiguration();\r\n    boolean canMove = (metrics.widthPixels != metrics.heightPixels && cfg.smallestScreenWidthDp < 600);\r\n    return (!canMove || metrics.widthPixels < metrics.heightPixels);\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getExtendedPaddingTop",
	"Comment": "returns the extended top padding of the view, including both thetop drawable if any and any extra space to keep more than maxlinesof text from showing.it is only valid to call this after measuring.",
	"Method": "int getExtendedPaddingTop(){\r\n    return mInputView.getExtendedPaddingTop();\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Vector3.rotate",
	"Comment": "rotates this vector by the given angle in degrees around the given axis.",
	"Method": "Vector3 rotate(float degrees,float axisX,float axisY,float axisZ,Vector3 rotate,Vector3 axis,float degrees){\r\n    tmpMat.setToRotation(axis, degrees);\r\n    return this.mul(tmpMat);\r\n}"
}, {
	"Path": "com.sun.jna.Union.findField",
	"Comment": "returns the field in this union with the same type as type,if any, null otherwise.",
	"Method": "StructField findField(Class<?> type){\r\n    ensureAllocated();\r\n    for (StructField f : fields().values()) {\r\n        if (f.type.isAssignableFrom(type)) {\r\n            return f;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntArray.random",
	"Comment": "returns a random item from the array, or zero if the array is empty.",
	"Method": "int random(){\r\n    if (size == 0)\r\n        return 0;\r\n    return items[MathUtils.random(0, size - 1)];\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withToolbar",
	"Comment": "sets the toolbar which should be used in combination with the drawerthis will handle the actionbardrawertoggle for you.do not set this if you are in a sub activity and want to handle the back arrow on your own",
	"Method": "DrawerBuilder withToolbar(Toolbar toolbar){\r\n    this.mToolbar = toolbar;\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jna.Memory.getByte",
	"Comment": "indirect the native pointer to malloc space, a lapointer.getbyte.but this method performs a boundschecks to ensure that the indirection does not cause memory outside themalloced space to be accessed.",
	"Method": "byte getByte(long offset){\r\n    boundsCheck(offset, 1);\r\n    return super.getByte(offset);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ComparableTimSort.mergeForceCollapse",
	"Comment": "merges all runs on the stack until only one remains. this method is called once, to complete the sort.",
	"Method": "void mergeForceCollapse(){\r\n    while (stackSize > 1) {\r\n        int n = stackSize - 2;\r\n        if (n > 0 && runLen[n - 1] < runLen[n + 1])\r\n            n--;\r\n        mergeAt(n);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jna.CallbackThreadInitializer.detach",
	"Comment": "returns whether the thread should be detached from the vm after thecallback exits, if the thread was not already attached to begin with.",
	"Method": "boolean detach(Callback cb){\r\n    return detach;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.setFixedRotation",
	"Comment": "should this body be prevented from rotating? useful for characters.",
	"Method": "void setFixedRotation(boolean fixedRotation){\r\n    this.fixedRotation = fixedRotation;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.AccountHeaderBuilder.withAccountHeader",
	"Comment": "you can pass a custom layout for the drawer lib. see the drawer.xml in layouts of this lib on github",
	"Method": "AccountHeaderBuilder withAccountHeader(View accountHeader,AccountHeaderBuilder withAccountHeader,int resLayout){\r\n    if (mActivity == null) {\r\n        throw new RuntimeException(\"please pass an activity first to use this call\");\r\n    }\r\n    if (resLayout != -1) {\r\n        this.mAccountHeaderContainer = mActivity.getLayoutInflater().inflate(resLayout, null, false);\r\n    } else {\r\n        if (mCompactStyle) {\r\n            this.mAccountHeaderContainer = mActivity.getLayoutInflater().inflate(R.layout.material_drawer_compact_header, null, false);\r\n        } else {\r\n            this.mAccountHeaderContainer = mActivity.getLayoutInflater().inflate(R.layout.material_drawer_header, null, false);\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Cell.width",
	"Comment": "sets the minwidth, prefwidth, and maxwidth to the specified value.",
	"Method": "Cell<T> width(Value width,Cell<T> width,float width){\r\n    width(new Fixed(width));\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.Sprite.translate",
	"Comment": "sets the position relative to the current position where the sprite will be drawn. if origin, rotation, or scale are\tchanged, it is slightly more efficient to translate after those operations.",
	"Method": "void translate(float xAmount,float yAmount){\r\n    x += xAmount;\r\n    y += yAmount;\r\n    if (dirty)\r\n        return;\r\n    float[] vertices = this.vertices;\r\n    vertices[X1] += xAmount;\r\n    vertices[Y1] += yAmount;\r\n    vertices[X2] += xAmount;\r\n    vertices[Y2] += yAmount;\r\n    vertices[X3] += xAmount;\r\n    vertices[Y3] += yAmount;\r\n    vertices[X4] += xAmount;\r\n    vertices[Y4] += yAmount;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.SpriteCache.clear",
	"Comment": "invalidates all cache ids and resets the spritecache so new caches can be added.",
	"Method": "void clear(){\r\n    caches.clear();\r\n    mesh.getVerticesBuffer().clear().flip();\r\n}"
}, {
	"Path": "com.sun.jna.Function.getFunction",
	"Comment": "obtain a function representing a nativefunction.the allocated instance represents a pointer to the named nativefunction from the named library.",
	"Method": "Function getFunction(String libraryName,String functionName,Function getFunction,String libraryName,String functionName,int callFlags,Function getFunction,String libraryName,String functionName,int callFlags,String encoding,Function getFunction,Pointer p,Function getFunction,Pointer p,int callFlags,Function getFunction,Pointer p,int callFlags,String encoding){\r\n    return new Function(p, callFlags, encoding);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.collision.btManifoldPoint.obtainTemp",
	"Comment": "obtains a temporary instance, used by native methods that return a btmanifoldpoint instance",
	"Method": "btManifoldPoint obtainTemp(long cPtr,boolean own){\r\n    temp.reset(cPtr, own);\r\n    return temp;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.GeometryUtils.triangleCircumcenter",
	"Comment": "returns the circumcenter of the triangle. the input points must not be colinear.",
	"Method": "Vector2 triangleCircumcenter(float x1,float y1,float x2,float y2,float x3,float y3,Vector2 circumcenter){\r\n    float dx21 = x2 - x1, dy21 = y2 - y1;\r\n    float dx32 = x3 - x2, dy32 = y3 - y2;\r\n    float dx13 = x1 - x3, dy13 = y1 - y3;\r\n    float det = dx32 * dy21 - dx21 * dy32;\r\n    if (Math.abs(det) < MathUtils.FLOAT_ROUNDING_ERROR)\r\n        throw new IllegalArgumentException(\"Triangle points must not be colinear.\");\r\n    det *= 2;\r\n    float sqr1 = x1 * x1 + y1 * y1, sqr2 = x2 * x2 + y2 * y2, sqr3 = x3 * x3 + y3 * y3;\r\n    circumcenter.set((sqr1 * dy32 + sqr2 * dy13 + sqr3 * dy21) / det, -(sqr1 * dx32 + sqr2 * dx13 + sqr3 * dx21) / det);\r\n    return circumcenter;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.AccountHeaderBuilder.withSelectionFirstLine",
	"Comment": "set this to define the first line in the selection area if there is no profilenote this will block any values from profiles!",
	"Method": "AccountHeaderBuilder withSelectionFirstLine(String selectionFirstLine){\r\n    this.mSelectionFirstLine = selectionFirstLine;\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.W32Service.queryStatus",
	"Comment": "retrieves the current status of the specified service based on the specified information level.",
	"Method": "SERVICE_STATUS_PROCESS queryStatus(){\r\n    IntByReference size = new IntByReference();\r\n    Advapi32.INSTANCE.QueryServiceStatusEx(_handle, SC_STATUS_TYPE.SC_STATUS_PROCESS_INFO, null, 0, size);\r\n    SERVICE_STATUS_PROCESS status = new SERVICE_STATUS_PROCESS(size.getValue());\r\n    if (!Advapi32.INSTANCE.QueryServiceStatusEx(_handle, SC_STATUS_TYPE.SC_STATUS_PROCESS_INFO, status, status.size(), size)) {\r\n        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n    }\r\n    return status;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Color.valueOf",
	"Comment": "returns a new color from a hex string with the format rrggbbaa.",
	"Method": "Color valueOf(String hex){\r\n    hex = hex.charAt(0) == '#' ? hex.substring(1) : hex;\r\n    int r = Integer.valueOf(hex.substring(0, 2), 16);\r\n    int g = Integer.valueOf(hex.substring(2, 4), 16);\r\n    int b = Integer.valueOf(hex.substring(4, 6), 16);\r\n    int a = hex.length() != 8 ? 255 : Integer.valueOf(hex.substring(6, 8), 16);\r\n    return new Color(r / 255f, g / 255f, b / 255f, a / 255f);\r\n}"
}, {
	"Path": "org.junit.runner.JUnitCore.main",
	"Comment": "run the tests contained in the classes named in the args.if all tests run successfully, exit with a status of 0. otherwise exit with a status of 1.write feedback while tests are running and writestack traces for all failed tests after the tests all complete.",
	"Method": "void main(String args){\r\n    Result result = new JUnitCore().runMain(new RealSystem(), args);\r\n    System.exit(result.wasSuccessful() ? 0 : 1);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator.scaleToFitSquare",
	"Comment": "uses max advance, ascender and descender of font to calculate real height that makes any n glyphs to fit in given pixel\twidth and height.",
	"Method": "int scaleToFitSquare(int width,int height,int numChars){\r\n    return Math.min(scaleForPixelHeight(height), scaleForPixelWidth(width, numChars));\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.lerpAngle",
	"Comment": "linearly interpolates between two angles in radians. takes into account that angles wrap at two pi and always takes the\tdirection with the smallest delta angle.",
	"Method": "float lerpAngle(float fromRadians,float toRadians,float progress){\r\n    float delta = ((toRadians - fromRadians + PI2 + PI) % PI2) - PI;\r\n    return (fromRadians + delta * progress + PI2) % PI2;\r\n}"
}, {
	"Path": "org.jsoup.internal.StringUtil.appendNormalisedWhitespace",
	"Comment": "after normalizing the whitespace within a string, appends it to a string builder.",
	"Method": "void appendNormalisedWhitespace(StringBuilder accum,String string,boolean stripLeading){\r\n    boolean lastWasWhite = false;\r\n    boolean reachedNonWhite = false;\r\n    int len = string.length();\r\n    int c;\r\n    for (int i = 0; i < len; i += Character.charCount(c)) {\r\n        c = string.codePointAt(i);\r\n        if (isActuallyWhitespace(c)) {\r\n            if ((stripLeading && !reachedNonWhite) || lastWasWhite)\r\n                continue;\r\n            accum.append(' ');\r\n            lastWasWhite = true;\r\n        } else if (!isInvisibleChar(c)) {\r\n            accum.appendCodePoint(c);\r\n            lastWasWhite = false;\r\n            reachedNonWhite = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.WevtapiUtil.EvtRender",
	"Comment": "renders an xml fragment based on the rendering context that you specify.",
	"Method": "Memory EvtRender(EVT_HANDLE context,EVT_HANDLE fragment,int flags,IntByReference propertyCount){\r\n    boolean result;\r\n    IntByReference buffUsed = new IntByReference();\r\n    result = Wevtapi.INSTANCE.EvtRender(context, fragment, flags, 0, null, buffUsed, propertyCount);\r\n    int errorCode = Kernel32.INSTANCE.GetLastError();\r\n    if ((!result) && errorCode != Kernel32.ERROR_INSUFFICIENT_BUFFER) {\r\n        throw new Win32Exception(errorCode);\r\n    }\r\n    Memory mem = new Memory(buffUsed.getValue());\r\n    result = Wevtapi.INSTANCE.EvtRender(context, fragment, flags, (int) mem.size(), mem, buffUsed, propertyCount);\r\n    if (!result) {\r\n        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n    }\r\n    return mem;\r\n}"
}, {
	"Path": "junit.framework.TestSuite.createTest",
	"Comment": "...as the moon sets over the early morning merlin, oregonmountains, our intrepid adventurers type...",
	"Method": "Test createTest(Class<?> theClass,String name){\r\n    Constructor<?> constructor;\r\n    try {\r\n        constructor = getTestConstructor(theClass);\r\n    } catch (NoSuchMethodException e) {\r\n        return warning(\"Class \" + theClass.getName() + \" has no public constructor TestCase(String name) or TestCase()\");\r\n    }\r\n    Object test;\r\n    try {\r\n        if (constructor.getParameterTypes().length == 0) {\r\n            test = constructor.newInstance(new Object[0]);\r\n            if (test instanceof TestCase) {\r\n                ((TestCase) test).setName(name);\r\n            }\r\n        } else {\r\n            test = constructor.newInstance(new Object[] { name });\r\n        }\r\n    } catch (InstantiationException e) {\r\n        return (warning(\"Cannot instantiate test case: \" + name + \" (\" + Throwables.getStacktrace(e) + \")\"));\r\n    } catch (InvocationTargetException e) {\r\n        return (warning(\"Exception in constructor: \" + name + \" (\" + Throwables.getStacktrace(e.getTargetException()) + \")\"));\r\n    } catch (IllegalAccessException e) {\r\n        return (warning(\"Cannot access test case: \" + name + \" (\" + Throwables.getStacktrace(e) + \")\"));\r\n    }\r\n    return (Test) test;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.Sprite.setCenterX",
	"Comment": "sets the x position so that it is centered on the given x parameter",
	"Method": "void setCenterX(float x){\r\n    setX(x - width / 2);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.Sprite.setCenterY",
	"Comment": "sets the y position so that it is centered on the given y parameter",
	"Method": "void setCenterY(float y){\r\n    setY(y - height / 2);\r\n}"
}, {
	"Path": "com.rey.material.widget.YearPicker.setOnYearChangedListener",
	"Comment": "set a listener will be called when the selected year value is changed.",
	"Method": "void setOnYearChangedListener(OnYearChangedListener listener){\r\n    mOnYearChangedListener = listener;\r\n}"
}, {
	"Path": "com.sun.jna.Structure.getFieldValue",
	"Comment": "obtain the value currently in the java field.does not read fromnative memory.",
	"Method": "Object getFieldValue(Field field){\r\n    try {\r\n        return field.get(this);\r\n    } catch (Exception e) {\r\n        throw new Error(\"Exception reading field '\" + field.getName() + \"' in \" + getClass(), e);\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.setParticleRadius",
	"Comment": "change the particle radius. you should set this only once, on world start. if you change theradius during execution, existing particles may explode, shrink, or behave unexpectedly.",
	"Method": "void setParticleRadius(float radius){\r\n    m_particleSystem.setParticleRadius(radius);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectIntMap.shrink",
	"Comment": "reduces the size of the backing arrays to be the specified capacity or less. if the capacity is already less, nothing is\tdone. if the map contains more items than the specified capacity, the next highest power of two capacity is used instead.",
	"Method": "void shrink(int maximumCapacity){\r\n    if (maximumCapacity < 0)\r\n        throw new IllegalArgumentException(\"maximumCapacity must be >= 0: \" + maximumCapacity);\r\n    if (size > maximumCapacity)\r\n        maximumCapacity = size;\r\n    if (capacity <= maximumCapacity)\r\n        return;\r\n    maximumCapacity = MathUtils.nextPowerOfTwo(maximumCapacity);\r\n    resize(maximumCapacity);\r\n}"
}, {
	"Path": "com.codahale.metrics.EWMA.oneMinuteEWMA",
	"Comment": "creates a new ewma which is equivalent to the unix one minute load average and which expectsto be ticked every 5 seconds.",
	"Method": "EWMA oneMinuteEWMA(){\r\n    return new EWMA(M1_ALPHA, INTERVAL, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.Method.getDeclaringClass",
	"Comment": "returns the class object representing the class or interface that declares the method.",
	"Method": "Class getDeclaringClass(){\r\n    return method.getDeclaringClass();\r\n}"
}, {
	"Path": "com.rey.material.app.ThemeManager.unregisterOnThemeChangedListener",
	"Comment": "unregister a listener from be called when current theme changed.",
	"Method": "void unregisterOnThemeChangedListener(OnThemeChangedListener listener){\r\n    if (mDispatcher != null)\r\n        mDispatcher.unregisterListener(listener);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.BooleanArray.removeAll",
	"Comment": "removes from this array all of elements contained in the specified array.",
	"Method": "boolean removeAll(BooleanArray array){\r\n    int size = this.size;\r\n    int startSize = size;\r\n    boolean[] items = this.items;\r\n    for (int i = 0, n = array.size; i < n; i++) {\r\n        boolean item = array.get(i);\r\n        for (int ii = 0; ii < size; ii++) {\r\n            if (item == items[ii]) {\r\n                removeIndex(ii);\r\n                size--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return size != startSize;\r\n}"
}, {
	"Path": "com.rey.material.widget.SnackBar.duration",
	"Comment": "set the duration this snackbar will be shown before dismissing.",
	"Method": "SnackBar duration(long duration){\r\n    mDuration = duration;\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jna.Memory.setDouble",
	"Comment": "indirect the native pointer to malloc space, a lapointer.setdouble.but this method performs abounds checks to ensure that the indirection does not cause memoryoutside the malloced space to be accessed.",
	"Method": "void setDouble(long offset,double value){\r\n    boundsCheck(offset, 8);\r\n    super.setDouble(offset, value);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.LongArray.removeAll",
	"Comment": "removes from this array all of elements contained in the specified array.",
	"Method": "boolean removeAll(LongArray array){\r\n    int size = this.size;\r\n    int startSize = size;\r\n    long[] items = this.items;\r\n    for (int i = 0, n = array.size; i < n; i++) {\r\n        long item = array.get(i);\r\n        for (int ii = 0; ii < size; ii++) {\r\n            if (item == items[ii]) {\r\n                removeIndex(ii);\r\n                size--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return size != startSize;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.BooleanArray.shrink",
	"Comment": "reduces the size of the backing array to the size of the actual items. this is useful to release memory when many items\thave been removed, or if it is known that more items will not be added.",
	"Method": "boolean[] shrink(){\r\n    if (items.length != size)\r\n        resize(size);\r\n    return items;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.Camera.transform",
	"Comment": "transform the position, direction and up vector by the given matrix",
	"Method": "void transform(Matrix4 transform){\r\n    position.mul(transform);\r\n    rotate(transform);\r\n}"
}, {
	"Path": "java.nio.ShortBuffer.get",
	"Comment": "reads shorts from the current position into the specified short array, starting from the specified offset, and increases the\tposition by the number of shorts read.",
	"Method": "short get(ShortBuffer get,short[] dest,ShortBuffer get,short[] dest,int off,int len,short get,int index){\r\n    int length = dest.length;\r\n    if (off < 0 || len < 0 || (long) off + (long) len > length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (len > remaining()) {\r\n        throw new BufferUnderflowException();\r\n    }\r\n    for (int i = off; i < off + len; i++) {\r\n        dest[i] = get();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "lombok.installer.eclipse.EclipseProductLocationProvider.create",
	"Comment": "create a new eclipselocation by pointing at either the directory contains the eclipse executable, or the executable itself,\tor an eclipse.ini file.",
	"Method": "IdeLocation create(String path){\r\n    return create0(path);\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.AndroidFragmentApplication.isAnyParentFragmentRemoving",
	"Comment": "iterates over nested fragments hierarchy and returns true if one of the fragment is in the removal process",
	"Method": "boolean isAnyParentFragmentRemoving(){\r\n    Fragment fragment = getParentFragment();\r\n    while (fragment != null) {\r\n        if (fragment.isRemoving())\r\n            return true;\r\n        fragment = fragment.getParentFragment();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jna.platform.WindowUtilsTest.getPixelColor",
	"Comment": "extracts the values of the color components at the specified pixel.",
	"Method": "int[] getPixelColor(BufferedImage img,int x,int y){\r\n    int rgb = img.getRGB(x, y);\r\n    int r = (rgb >> 16) & 0xFF;\r\n    int g = (rgb >> 8) & 0xFF;\r\n    int b = (rgb & 0xFF);\r\n    return new int[] { r, g, b };\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.getDescent",
	"Comment": "gets the distance from the baseline to the bottom of most alphanumeric characters with descenders.",
	"Method": "int getDescent(){\r\n    return descent;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Intersector.intersectSegmentCircle",
	"Comment": "returns whether the given line segment intersects the given circle.",
	"Method": "boolean intersectSegmentCircle(Vector2 start,Vector2 end,Vector2 center,float squareRadius){\r\n    tmp.set(end.x - start.x, end.y - start.y, 0);\r\n    tmp1.set(center.x - start.x, center.y - start.y, 0);\r\n    float l = tmp.len();\r\n    float u = tmp1.dot(tmp.nor());\r\n    if (u <= 0) {\r\n        tmp2.set(start.x, start.y, 0);\r\n    } else if (u >= l) {\r\n        tmp2.set(end.x, end.y, 0);\r\n    } else {\r\n        tmp3.set(tmp.scl(u));\r\n        tmp2.set(tmp3.x + start.x, tmp3.y + start.y, 0);\r\n    }\r\n    float x = center.x - tmp2.x;\r\n    float y = center.y - tmp2.y;\r\n    return x * x + y * y <= squareRadius;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Slider.setSnapToValues",
	"Comment": "will make this progress bar snap to the specified values, if the knob is within the threshold.",
	"Method": "void setSnapToValues(float[] values,float threshold){\r\n    this.snapValues = values;\r\n    this.threshold = threshold;\r\n}"
}, {
	"Path": "java.nio.ShortBuffer.toString",
	"Comment": "returns a string representing the state of this short buffer.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(getClass().getName());\r\n    sb.append(\", status: capacity=\");\r\n    sb.append(capacity());\r\n    sb.append(\" position=\");\r\n    sb.append(position());\r\n    sb.append(\" limit=\");\r\n    sb.append(limit());\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.junit.internal.StackTracesTest.message",
	"Comment": "returns a matcher that matches the message line in a stack trace.",
	"Method": "StringMatcher message(String message){\r\n    return new ExceptionMessageMatcher(message);\r\n}"
}, {
	"Path": "org.junit.runner.Request.classes",
	"Comment": "create a request that, when processed, will run all the testsin a set of classes with the default computer.",
	"Method": "Request classes(Computer computer,Class<?> classes,Request classes,Class<?> classes){\r\n    return classes(JUnitCore.defaultComputer(), classes);\r\n}"
}, {
	"Path": "com.rey.material.widget.ListPopupWindow.setOnItemSelectedListener",
	"Comment": "sets a listener to receive events when a list item is selected.",
	"Method": "void setOnItemSelectedListener(AdapterView.OnItemSelectedListener selectedListener){\r\n    mItemSelectedListener = selectedListener;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.append",
	"Comment": "call this method to append a new drawerbuilder to a existing drawer.",
	"Method": "Drawer append(Drawer result){\r\n    if (mUsed) {\r\n        throw new RuntimeException(\"you must not reuse a DrawerBuilder builder\");\r\n    }\r\n    if (mDrawerGravity == null) {\r\n        throw new RuntimeException(\"please set the gravity for the drawer\");\r\n    }\r\n    mUsed = true;\r\n    mAppended = true;\r\n    mDrawerLayout = result.getDrawerLayout();\r\n    mSliderLayout = (ScrimInsetsRelativeLayout) mActivity.getLayoutInflater().inflate(R.layout.material_drawer_slider, mDrawerLayout, false);\r\n    mSliderLayout.setBackgroundColor(UIUtils.getThemeColorFromAttrOrRes(mActivity, R.attr.material_drawer_background, R.color.material_drawer_background));\r\n    DrawerLayout.LayoutParams params = (DrawerLayout.LayoutParams) mSliderLayout.getLayoutParams();\r\n    params.gravity = mDrawerGravity;\r\n    params = DrawerUtils.processDrawerLayoutParams(this, params);\r\n    mSliderLayout.setLayoutParams(params);\r\n    mSliderLayout.setId(R.id.material_drawer_slider_layout);\r\n    mDrawerLayout.addView(mSliderLayout, 1);\r\n    createContent();\r\n    Drawer appendedResult = new Drawer(this);\r\n    if (mSavedInstance != null && mSavedInstance.getBoolean(Drawer.BUNDLE_DRAWER_CONTENT_SWITCHED_APPENDED, false)) {\r\n        mAccountHeader.toggleSelectionList(mActivity);\r\n    }\r\n    mActivity = null;\r\n    return appendedResult;\r\n}"
}, {
	"Path": "com.codahale.metrics.WeightedSnapshot.getMean",
	"Comment": "returns the weighted arithmetic mean of the values in the snapshot.",
	"Method": "double getMean(){\r\n    if (values.length == 0) {\r\n        return 0;\r\n    }\r\n    double sum = 0;\r\n    for (int i = 0; i < values.length; i++) {\r\n        sum += values[i] * normWeights[i];\r\n    }\r\n    return sum;\r\n}"
}, {
	"Path": "com.rey.material.widget.ListPopupWindow.setContentWidth",
	"Comment": "sets the width of the popup window by the size of its content. the final width may belarger to accommodate styled window dressing.",
	"Method": "void setContentWidth(int width){\r\n    Drawable popupBackground = mPopup.getBackground();\r\n    if (popupBackground != null) {\r\n        popupBackground.getPadding(mTempRect);\r\n        mDropDownWidth = mTempRect.left + mTempRect.right + width;\r\n    } else {\r\n        setWidth(width);\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Fixture.getType",
	"Comment": "get the type of the child shape. you can use this to down cast to the concrete shape.",
	"Method": "ShapeType getType(){\r\n    return m_shape.getType();\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.ShapeRenderer.setAutoShapeType",
	"Comment": "if true, when drawing a shape cannot be performed with the current shape type, the batch is flushed and the shape type is\tchanged automatically. this can increase the number of batch flushes if care is not taken to draw the same type of shapes\ttogether. default is false.",
	"Method": "void setAutoShapeType(boolean autoShapeType){\r\n    this.autoShapeType = autoShapeType;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Actor.getUserObject",
	"Comment": "returns an application specific object for convenience, or null.",
	"Method": "Object getUserObject(){\r\n    return userObject;\r\n}"
}, {
	"Path": "com.sun.jna.Structure.setAutoRead",
	"Comment": "set whether the structure is read from native memory aftera native function call.",
	"Method": "void setAutoRead(boolean auto){\r\n    this.autoRead = auto;\r\n}"
}, {
	"Path": "java.nio.DoubleBuffer.allocate",
	"Comment": "creates a double buffer based on a newly allocated double array.",
	"Method": "DoubleBuffer allocate(int capacity){\r\n    if (capacity < 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return BufferFactory.newDoubleBuffer(capacity);\r\n}"
}, {
	"Path": "lombok.core.AST.setTop",
	"Comment": "set the node object that wraps the internal compilation unit node.",
	"Method": "void setTop(L top){\r\n    this.top = top;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.UBJsonWriter.flush",
	"Comment": "flushes the underlying stream. this forces any buffered output bytes to be written out to the stream.",
	"Method": "void flush(){\r\n    out.flush();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Array.shrink",
	"Comment": "reduces the size of the backing array to the size of the actual items. this is useful to release memory when many items\thave been removed, or if it is known that more items will not be added.",
	"Method": "T[] shrink(){\r\n    if (items.length != size)\r\n        resize(size);\r\n    return items;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Intersector.intersectSegments",
	"Comment": "intersects the two line segments and returns the intersection point in intersection.",
	"Method": "boolean intersectSegments(Vector2 p1,Vector2 p2,Vector2 p3,Vector2 p4,Vector2 intersection,boolean intersectSegments,float x1,float y1,float x2,float y2,float x3,float y3,float x4,float y4,Vector2 intersection){\r\n    float d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\r\n    if (d == 0)\r\n        return false;\r\n    float yd = y1 - y3;\r\n    float xd = x1 - x3;\r\n    float ua = ((x4 - x3) * yd - (y4 - y3) * xd) / d;\r\n    if (ua < 0 || ua > 1)\r\n        return false;\r\n    float ub = ((x2 - x1) * yd - (y2 - y1) * xd) / d;\r\n    if (ub < 0 || ub > 1)\r\n        return false;\r\n    if (intersection != null)\r\n        intersection.set(x1 + (x2 - x1) * ua, y1 + (y2 - y1) * ua);\r\n    return true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.GwtFileHandle.moveTo",
	"Comment": "moves this file to the specified file, overwriting the file if it already exists.",
	"Method": "void moveTo(FileHandle dest){\r\n    throw new GdxRuntimeException(\"Cannot move an internal file: \" + file);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.AccountHeader.setDrawer",
	"Comment": "set the drawer for the accountheader so we can use it for the select",
	"Method": "void setDrawer(Drawer drawer){\r\n    mAccountHeaderBuilder.mDrawer = drawer;\r\n}"
}, {
	"Path": "org.jbox2d.common.OBBViewportTransform.setTransform",
	"Comment": "sets the transform of the viewport. transforms about the center.",
	"Method": "void setTransform(Mat22 transform){\r\n    box.R.set(transform);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectFloatMap.shrink",
	"Comment": "reduces the size of the backing arrays to be the specified capacity or less. if the capacity is already less, nothing is\tdone. if the map contains more items than the specified capacity, the next highest power of two capacity is used instead.",
	"Method": "void shrink(int maximumCapacity){\r\n    if (maximumCapacity < 0)\r\n        throw new IllegalArgumentException(\"maximumCapacity must be >= 0: \" + maximumCapacity);\r\n    if (size > maximumCapacity)\r\n        maximumCapacity = size;\r\n    if (capacity <= maximumCapacity)\r\n        return;\r\n    maximumCapacity = MathUtils.nextPowerOfTwo(maximumCapacity);\r\n    resize(maximumCapacity);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.TextureArray.invalidateAllTextureArrays",
	"Comment": "invalidate all managed texturearrays. this is an internal method. do not use it!",
	"Method": "void invalidateAllTextureArrays(Application app){\r\n    Array<TextureArray> managedTextureArray = managedTextureArrays.get(app);\r\n    if (managedTextureArray == null)\r\n        return;\r\n    for (int i = 0; i < managedTextureArray.size; i++) {\r\n        TextureArray textureArray = managedTextureArray.get(i);\r\n        textureArray.reload();\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.StringBuilder.indexOf",
	"Comment": "searches for the index of the specified character. the search for the character starts at the specified offset and moves\ttowards the end.",
	"Method": "int indexOf(String string,int indexOf,String subString,int start){\r\n    if (start < 0) {\r\n        start = 0;\r\n    }\r\n    int subCount = subString.length();\r\n    if (subCount == 0)\r\n        return start < length || start == 0 ? start : length;\r\n    int maxIndex = length - subCount;\r\n    if (start > maxIndex)\r\n        return -1;\r\n    char firstChar = subString.charAt(0);\r\n    while (true) {\r\n        int i = start;\r\n        boolean found = false;\r\n        for (; i <= maxIndex; i++) {\r\n            if (chars[i] == firstChar) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found)\r\n            return -1;\r\n        int o1 = i, o2 = 0;\r\n        while (++o2 < subCount && chars[++o1] == subString.charAt(o2)) {\r\n        }\r\n        if (o2 == subCount)\r\n            return i;\r\n        start = i + 1;\r\n    }\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.MiniDrawer.withIncludeSecondaryDrawerItems",
	"Comment": "set to true if you also want to display secondarydraweritems",
	"Method": "MiniDrawer withIncludeSecondaryDrawerItems(boolean includeSecondaryDrawerItems){\r\n    this.mIncludeSecondaryDrawerItems = includeSecondaryDrawerItems;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18.getRenderMode",
	"Comment": "get the current rendering mode. may be calledfrom any thread. must not be called before a renderer has been set.",
	"Method": "int getRenderMode(int getRenderMode){\r\n    return mGLThread.getRenderMode();\r\n}"
}, {
	"Path": "com.badlogic.gdx.files.FileHandle.deleteDirectory",
	"Comment": "deletes this file or directory and all children, recursively.",
	"Method": "boolean deleteDirectory(){\r\n    emptyDirectory(file, false);\r\n    return file.delete();\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable.tint",
	"Comment": "creates a new drawable that renders the same as this drawable tinted the specified color.",
	"Method": "SpriteDrawable tint(Color tint){\r\n    Sprite newSprite;\r\n    if (sprite instanceof AtlasSprite)\r\n        newSprite = new AtlasSprite((AtlasSprite) sprite);\r\n    else\r\n        newSprite = new Sprite(sprite);\r\n    newSprite.setColor(tint);\r\n    newSprite.setSize(getMinWidth(), getMinHeight());\r\n    SpriteDrawable drawable = new SpriteDrawable(newSprite);\r\n    drawable.setLeftWidth(getLeftWidth());\r\n    drawable.setRightWidth(getRightWidth());\r\n    drawable.setTopHeight(getTopHeight());\r\n    drawable.setBottomHeight(getBottomHeight());\r\n    return drawable;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.PulleyJointDef.initialize",
	"Comment": "initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.",
	"Method": "void initialize(Body b1,Body b2,Vec2 ga1,Vec2 ga2,Vec2 anchor1,Vec2 anchor2,float r){\r\n    bodyA = b1;\r\n    bodyB = b2;\r\n    groundAnchorA = ga1;\r\n    groundAnchorB = ga2;\r\n    localAnchorA = bodyA.getLocalPoint(anchor1);\r\n    localAnchorB = bodyB.getLocalPoint(anchor2);\r\n    Vec2 d1 = anchor1.sub(ga1);\r\n    lengthA = d1.length();\r\n    Vec2 d2 = anchor2.sub(ga2);\r\n    lengthB = d2.length();\r\n    ratio = r;\r\n    assert (ratio > Settings.EPSILON);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Skin.getRegion",
	"Comment": "returns a registered texture region. if no region is found but a texture exists with the name, a region is created from the\ttexture and stored in the skin.",
	"Method": "TextureRegion getRegion(String name){\r\n    TextureRegion region = optional(name, TextureRegion.class);\r\n    if (region != null)\r\n        return region;\r\n    Texture texture = optional(name, Texture.class);\r\n    if (texture == null)\r\n        throw new GdxRuntimeException(\"No TextureRegion or Texture registered with name: \" + name);\r\n    region = new TextureRegion(texture);\r\n    add(name, region, TextureRegion.class);\r\n    return region;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter.setEmissionMode",
	"Comment": "sets emission mode. emission mode does not affect already emitted particles.",
	"Method": "void setEmissionMode(EmissionMode emissionMode){\r\n    this.emissionMode = emissionMode;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane.getMouseWheelX",
	"Comment": "returns the amount to scroll horizontally when the mouse wheel is scrolled.",
	"Method": "float getMouseWheelX(){\r\n    return Math.min(areaWidth, Math.max(areaWidth * 0.9f, maxX * 0.1f) / 4);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.model.ProfileSettingDrawerItem.withEmail",
	"Comment": "note we reuse the iprofile here to allow custom items within the accountswitcher. there is an alias method withdescription for this",
	"Method": "ProfileSettingDrawerItem withEmail(String email){\r\n    this.description = new StringHolder(email);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.getGlyph",
	"Comment": "returns the glyph for the specified codepoint. if the glyph does not exist yet, it is created and queued to be loaded.",
	"Method": "Glyph getGlyph(int glyphCode,int codePoint,Rectangle bounds,GlyphVector vector,int index){\r\n    if (glyphCode < 0 || glyphCode >= MAX_GLYPH_CODE) {\r\n        return new Glyph(codePoint, bounds, vector, index, this) {\r\n            public boolean isMissing() {\r\n                return true;\r\n            }\r\n        };\r\n    }\r\n    int pageIndex = glyphCode / PAGE_SIZE;\r\n    int glyphIndex = glyphCode & (PAGE_SIZE - 1);\r\n    Glyph glyph = null;\r\n    Glyph[] page = glyphs[pageIndex];\r\n    if (page != null) {\r\n        glyph = page[glyphIndex];\r\n        if (glyph != null)\r\n            return glyph;\r\n    } else\r\n        page = glyphs[pageIndex] = new Glyph[PAGE_SIZE];\r\n    glyph = page[glyphIndex] = new Glyph(codePoint, bounds, vector, index, this);\r\n    queuedGlyphs.add(glyph);\r\n    return glyph;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.getGlyph",
	"Comment": "returns the glyph for the specified codepoint. if the glyph does not exist yet, it is created and queued to be loaded.",
	"Method": "Glyph getGlyph(int glyphCode,int codePoint,Rectangle bounds,GlyphVector vector,int index){\r\n    return true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint.getJointSpeed",
	"Comment": "get the current joint translation speed, usually in meters per second.",
	"Method": "float getJointSpeed(){\r\n    return joint.getJointSpeed();\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane.getMouseWheelY",
	"Comment": "returns the amount to scroll vertically when the mouse wheel is scrolled.",
	"Method": "float getMouseWheelY(){\r\n    return Math.min(areaHeight, Math.max(areaHeight * 0.9f, maxY * 0.1f) / 4);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.model.AbstractDrawerItem.generateView",
	"Comment": "generates a view by the defined layoutres and pass the layoutparams from the parent",
	"Method": "View generateView(Context ctx,View generateView,Context ctx,ViewGroup parent){\r\n    VH viewHolder = getViewHolder(LayoutInflater.from(ctx).inflate(getLayoutRes(), parent, false));\r\n    bindView(viewHolder, Collections.emptyList());\r\n    return viewHolder.itemView;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.CharArray.removeRange",
	"Comment": "removes the items between the specified indices, inclusive.",
	"Method": "void removeRange(int start,int end){\r\n    if (end >= size)\r\n        throw new IndexOutOfBoundsException(\"end can't be >= size: \" + end + \" >= \" + size);\r\n    if (start > end)\r\n        throw new IndexOutOfBoundsException(\"start can't be > end: \" + start + \" > \" + end);\r\n    char[] items = this.items;\r\n    int count = end - start + 1;\r\n    if (ordered)\r\n        System.arraycopy(items, start + count, items, start, size - (start + count));\r\n    else {\r\n        int lastIndex = this.size - 1;\r\n        for (int i = 0; i < count; i++) items[start + i] = items[lastIndex - i];\r\n    }\r\n    size -= count;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Timer.postTask",
	"Comment": "schedules a task to occur once as soon as possible, but not sooner than the start of the next frame.",
	"Method": "Task postTask(Task task){\r\n    return scheduleTask(task, 0, 0, 0);\r\n}"
}, {
	"Path": "lombok.eclipse.handlers.EclipseHandlerUtil.createListOfNonExistentFields",
	"Comment": "given a list of field names and a node referring to a type, finds each name in the list that does not match a field within the type.",
	"Method": "List<Integer> createListOfNonExistentFields(List<String> list,EclipseNode type,boolean excludeStandard,boolean excludeTransient){\r\n    boolean[] matched = new boolean[list.size()];\r\n    for (EclipseNode child : type.down()) {\r\n        if (list.isEmpty())\r\n            break;\r\n        if (child.getKind() != Kind.FIELD)\r\n            continue;\r\n        if (excludeStandard) {\r\n            if ((((FieldDeclaration) child.get()).modifiers & ClassFileConstants.AccStatic) != 0)\r\n                continue;\r\n            if (child.getName().startsWith(\"$\"))\r\n                continue;\r\n        }\r\n        if (excludeTransient && (((FieldDeclaration) child.get()).modifiers & ClassFileConstants.AccTransient) != 0)\r\n            continue;\r\n        int idx = list.indexOf(child.getName());\r\n        if (idx > -1)\r\n            matched[idx] = true;\r\n    }\r\n    List<Integer> problematic = new ArrayList<Integer>();\r\n    for (int i = 0; i < list.size(); i++) {\r\n        if (!matched[i])\r\n            problematic.add(i);\r\n    }\r\n    return problematic;\r\n}"
}, {
	"Path": "java.nio.CharBuffer.arrayOffset",
	"Comment": "returns the offset of the char array which this buffer is based on, if there is one.\tthe offset is the index of the array corresponds to the zero position of the buffer.",
	"Method": "int arrayOffset(){\r\n    return protectedArrayOffset();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntArray.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "int[] ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded > items.length)\r\n        resize(Math.max(8, sizeNeeded));\r\n    return items;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.TimSort.ensureCapacity",
	"Comment": "ensures that the external array tmp has at least the specified number of elements, increasing its size if necessary. the\tsize increases exponentially to ensure amortized linear time complexity.",
	"Method": "T[] ensureCapacity(int minCapacity){\r\n    tmpCount = Math.max(tmpCount, minCapacity);\r\n    if (tmp.length < minCapacity) {\r\n        int newSize = minCapacity;\r\n        newSize |= newSize >> 1;\r\n        newSize |= newSize >> 2;\r\n        newSize |= newSize >> 4;\r\n        newSize |= newSize >> 8;\r\n        newSize |= newSize >> 16;\r\n        newSize++;\r\n        if (newSize < 0)\r\n            newSize = minCapacity;\r\n        else\r\n            newSize = Math.min(newSize, a.length >>> 1);\r\n        T[] newArray = (T[]) new Object[newSize];\r\n        tmp = newArray;\r\n    }\r\n    return tmp;\r\n}"
}, {
	"Path": "org.jsoup.safety.Whitelist.isSafeAttribute",
	"Comment": "test if the supplied attribute is allowed by this whitelist for this tag",
	"Method": "boolean isSafeAttribute(String tagName,Element el,Attribute attr){\r\n    TagName tag = TagName.valueOf(tagName);\r\n    AttributeKey key = AttributeKey.valueOf(attr.getKey());\r\n    Set<AttributeKey> okSet = attributes.get(tag);\r\n    if (okSet != null && okSet.contains(key)) {\r\n        if (protocols.containsKey(tag)) {\r\n            Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag);\r\n            return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key));\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    Map<AttributeKey, AttributeValue> enforcedSet = enforcedAttributes.get(tag);\r\n    if (enforcedSet != null) {\r\n        Attributes expect = getEnforcedAttributes(tagName);\r\n        String attrKey = attr.getKey();\r\n        if (expect.hasKeyIgnoreCase(attrKey)) {\r\n            return expect.getIgnoreCase(attrKey).equals(attr.getValue());\r\n        }\r\n    }\r\n    return !tagName.equals(\":all\") && isSafeAttribute(\":all\", el, attr);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.collision.btCollisionObject.removeInstance",
	"Comment": "remove the instance to the managed instances.\tbe careful using this method. this method is intended for internal purposes only.",
	"Method": "void removeInstance(btCollisionObject obj){\r\n    instances.remove(getCPtr(obj));\r\n}"
}, {
	"Path": "org.jsoup.select.Elements.prevAll",
	"Comment": "get each of the previous element siblings of each element in this list, that match the query.",
	"Method": "Elements prevAll(Elements prevAll,String query){\r\n    return siblings(query, false, true);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ParticleController.translate",
	"Comment": "postmultiplies the current transformation with a translation matrix represented by the given translation.",
	"Method": "void translate(Vector3 translation){\r\n    this.transform.translate(translation);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.lerpAngleDeg",
	"Comment": "linearly interpolates between two angles in degrees. takes into account that angles wrap at 360 degrees and always takes\tthe direction with the smallest delta angle.",
	"Method": "float lerpAngleDeg(float fromDegrees,float toDegrees,float progress){\r\n    float delta = ((toDegrees - fromDegrees + 360 + 180) % 360) - 180;\r\n    return (fromDegrees + delta * progress + 360) % 360;\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.Kernel32Util.QueryFullProcessImageName",
	"Comment": "this function retrieves the full path of the executable file of a given process.",
	"Method": "String QueryFullProcessImageName(HANDLE hProcess,int dwFlags){\r\n    char[] path = new char[WinDef.MAX_PATH];\r\n    IntByReference lpdwSize = new IntByReference(path.length);\r\n    if (Kernel32.INSTANCE.QueryFullProcessImageName(hProcess, 0, path, lpdwSize))\r\n        return new String(path).substring(0, lpdwSize.getValue());\r\n    throw new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.getLeading",
	"Comment": "gets the extra distance between the descent of one line of text to the ascent of the next.",
	"Method": "int getLeading(){\r\n    return leading;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.asDoubleArray",
	"Comment": "returns the children of this value as a newly allocated double array.",
	"Method": "double[] asDoubleArray(){\r\n    if (type != ValueType.array)\r\n        throw new IllegalStateException(\"Value is not an array: \" + type);\r\n    double[] array = new double[size];\r\n    int i = 0;\r\n    for (JsonValue value = child; value != null; value = value.next, i++) {\r\n        double v;\r\n        switch(value.type) {\r\n            case stringValue:\r\n                v = Double.parseDouble(value.stringValue);\r\n                break;\r\n            case doubleValue:\r\n                v = value.doubleValue;\r\n                break;\r\n            case longValue:\r\n                v = (double) value.longValue;\r\n                break;\r\n            case booleanValue:\r\n                v = value.longValue != 0 ? 1 : 0;\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Value cannot be converted to double: \" + value.type);\r\n        }\r\n        array[i] = v;\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "lombok.eclipse.HandlerLibrary.load",
	"Comment": "creates a new handlerlibrary.errors will be reported to the eclipse error log.\tthen uses spi discovery to load all annotation and visitor based handlers so that future calls\tto the handle methods will defer to these handlers.",
	"Method": "HandlerLibrary load(){\r\n    HandlerLibrary lib = new HandlerLibrary();\r\n    loadAnnotationHandlers(lib);\r\n    loadVisitorHandlers(lib);\r\n    lib.calculatePriorities();\r\n    return lib;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Actor.localToAscendantCoordinates",
	"Comment": "converts coordinates for this actor to those of a parent actor. the ascendant does not need to be a direct parent.",
	"Method": "Vector2 localToAscendantCoordinates(Actor ascendant,Vector2 localCoords){\r\n    Actor actor = this;\r\n    do {\r\n        actor.localToParentCoordinates(localCoords);\r\n        actor = actor.parent;\r\n        if (actor == ascendant)\r\n            break;\r\n    } while (actor != null);\r\n    return localCoords;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Affine2.set",
	"Comment": "copies the values from the provided affine matrix to this matrix.",
	"Method": "Affine2 set(Affine2 other,Affine2 set,Matrix3 matrix,Affine2 set,Matrix4 matrix){\r\n    float[] other = matrix.val;\r\n    m00 = other[Matrix4.M00];\r\n    m01 = other[Matrix4.M01];\r\n    m02 = other[Matrix4.M03];\r\n    m10 = other[Matrix4.M10];\r\n    m11 = other[Matrix4.M11];\r\n    m12 = other[Matrix4.M13];\r\n    return this;\r\n}"
}, {
	"Path": "lombok.eclipse.handlers.EclipseHandlerUtil.annotationTypeMatches",
	"Comment": "checks if the provided annotation type is likely to be the intended type for the given annotation node.\tthis is a guess, but a decent one.",
	"Method": "boolean annotationTypeMatches(Class<? extends java.lang.annotation.Annotation> type,EclipseNode node,boolean annotationTypeMatches,String type,EclipseNode node){\r\n    if (node.getKind() != Kind.ANNOTATION)\r\n        return false;\r\n    return typeMatches(type, node, ((Annotation) node.get()).type);\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.lwjgl.audio.OggInputStream.init",
	"Comment": "initialise the streams and thread involved in the streaming of ogg data",
	"Method": "void init(){\r\n    initVorbis();\r\n    readPCM();\r\n}"
}, {
	"Path": "com.badlogic.gdx.tiledmappacker.TiledMapPacker.main",
	"Comment": "processes a directory of tile maps, compressing each tile set contained in any map once.",
	"Method": "void main(String[] args){\r\n    final Settings texturePackerSettings = new Settings();\r\n    texturePackerSettings.paddingX = 2;\r\n    texturePackerSettings.paddingY = 2;\r\n    texturePackerSettings.edgePadding = true;\r\n    texturePackerSettings.duplicatePadding = true;\r\n    texturePackerSettings.bleed = true;\r\n    texturePackerSettings.alias = true;\r\n    texturePackerSettings.useIndexes = true;\r\n    final TiledMapPackerSettings packerSettings = new TiledMapPackerSettings();\r\n    if (args.length == 0) {\r\n        printUsage();\r\n        System.exit(0);\r\n    } else if (args.length == 1) {\r\n        inputDir = new File(args[0]);\r\n        outputDir = new File(inputDir, \"../output/\");\r\n    } else if (args.length == 2) {\r\n        inputDir = new File(args[0]);\r\n        outputDir = new File(args[1]);\r\n    } else {\r\n        inputDir = new File(args[0]);\r\n        outputDir = new File(args[1]);\r\n        processExtraArgs(args, packerSettings);\r\n    }\r\n    TiledMapPacker packer = new TiledMapPacker(packerSettings);\r\n    LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();\r\n    config.forceExit = false;\r\n    config.width = 100;\r\n    config.height = 50;\r\n    config.title = \"TiledMapPacker\";\r\n    new LwjglApplication(new ApplicationListener() {\r\n        @Override\r\n        public void resume() {\r\n        }\r\n        @Override\r\n        public void resize(int width, int height) {\r\n        }\r\n        @Override\r\n        public void render() {\r\n        }\r\n        @Override\r\n        public void pause() {\r\n        }\r\n        @Override\r\n        public void dispose() {\r\n        }\r\n        @Override\r\n        public void create() {\r\n            TiledMapPacker packer = new TiledMapPacker(packerSettings);\r\n            if (!inputDir.exists()) {\r\n                System.out.println(inputDir.getAbsolutePath());\r\n                throw new RuntimeException(\"Input directory does not exist: \" + inputDir);\r\n            }\r\n            try {\r\n                packer.processInputDir(texturePackerSettings);\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(\"Error processing map: \" + e.getMessage());\r\n            }\r\n            System.out.println(\"Finished processing.\");\r\n            Gdx.app.exit();\r\n        }\r\n    }, config);\r\n}"
}, {
	"Path": "com.badlogic.gdx.tiledmappacker.TiledMapPacker.main",
	"Comment": "processes a directory of tile maps, compressing each tile set contained in any map once.",
	"Method": "void main(String[] args){\r\n}"
}, {
	"Path": "com.badlogic.gdx.tiledmappacker.TiledMapPacker.main",
	"Comment": "processes a directory of tile maps, compressing each tile set contained in any map once.",
	"Method": "void main(String[] args){\r\n}"
}, {
	"Path": "com.badlogic.gdx.tiledmappacker.TiledMapPacker.main",
	"Comment": "processes a directory of tile maps, compressing each tile set contained in any map once.",
	"Method": "void main(String[] args){\r\n}"
}, {
	"Path": "com.badlogic.gdx.tiledmappacker.TiledMapPacker.main",
	"Comment": "processes a directory of tile maps, compressing each tile set contained in any map once.",
	"Method": "void main(String[] args){\r\n}"
}, {
	"Path": "com.badlogic.gdx.tiledmappacker.TiledMapPacker.main",
	"Comment": "processes a directory of tile maps, compressing each tile set contained in any map once.",
	"Method": "void main(String[] args){\r\n}"
}, {
	"Path": "com.badlogic.gdx.tiledmappacker.TiledMapPacker.main",
	"Comment": "processes a directory of tile maps, compressing each tile set contained in any map once.",
	"Method": "void main(String[] args){\r\n    TiledMapPacker packer = new TiledMapPacker(packerSettings);\r\n    if (!inputDir.exists()) {\r\n        System.out.println(inputDir.getAbsolutePath());\r\n        throw new RuntimeException(\"Input directory does not exist: \" + inputDir);\r\n    }\r\n    try {\r\n        packer.processInputDir(texturePackerSettings);\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(\"Error processing map: \" + e.getMessage());\r\n    }\r\n    System.out.println(\"Finished processing.\");\r\n    Gdx.app.exit();\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.model.Node.calculateTransforms",
	"Comment": "calculates the local and world transform of this node and optionally all its children.",
	"Method": "void calculateTransforms(boolean recursive){\r\n    calculateLocalTransform();\r\n    calculateWorldTransform();\r\n    if (recursive) {\r\n        for (Node child : children) {\r\n            child.calculateTransforms(true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.rey.material.widget.RadioButton.setCheckedImmediately",
	"Comment": "change the checked state of this button immediately without showing animation.",
	"Method": "void setCheckedImmediately(boolean checked){\r\n    if (getButtonDrawable() instanceof RadioButtonDrawable) {\r\n        RadioButtonDrawable drawable = (RadioButtonDrawable) getButtonDrawable();\r\n        drawable.setAnimEnable(false);\r\n        setChecked(checked);\r\n        drawable.setAnimEnable(true);\r\n    } else\r\n        setChecked(checked);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.BooleanArray.random",
	"Comment": "returns a random item from the array, or false if the array is empty.",
	"Method": "boolean random(){\r\n    if (size == 0)\r\n        return false;\r\n    return items[MathUtils.random(0, size - 1)];\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.PixmapPacker.getPageIndex",
	"Comment": "returns the index of the page containing the given packed rectangle.",
	"Method": "int getPageIndex(String name){\r\n    for (int i = 0; i < pages.size; i++) {\r\n        Rectangle rect = pages.get(i).rects.get(name);\r\n        if (rect != null)\r\n            return i;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.sun.jna.Native.setCallbackExceptionHandler",
	"Comment": "set the default handler invoked when a callback throws an uncaughtexception.if the given handler is null, the defaulthandler will be reinstated.",
	"Method": "void setCallbackExceptionHandler(UncaughtExceptionHandler eh){\r\n    callbackExceptionHandler = eh == null ? DEFAULT_HANDLER : eh;\r\n}"
}, {
	"Path": "com.badlogic.gdx.input.GestureDetector.cancel",
	"Comment": "no further gesture events will be triggered for the current touch, if any.",
	"Method": "void cancel(){\r\n    longPressTask.cancel();\r\n    longPressFired = true;\r\n}"
}, {
	"Path": "org.jsoup.nodes.FormElement.formData",
	"Comment": "get the data that this form submits. the returned list is a copy of the data, and changes to the contents of thelist will not be reflected in the dom.",
	"Method": "List<Connection.KeyVal> formData(){\r\n    ArrayList<Connection.KeyVal> data = new ArrayList();\r\n    for (Element el : elements) {\r\n        if (!el.tag().isFormSubmittable())\r\n            continue;\r\n        if (el.hasAttr(\"disabled\"))\r\n            continue;\r\n        String name = el.attr(\"name\");\r\n        if (name.length() == 0)\r\n            continue;\r\n        String type = el.attr(\"type\");\r\n        if (\"select\".equals(el.tagName())) {\r\n            Elements options = el.select(\"option[selected]\");\r\n            boolean set = false;\r\n            for (Element option : options) {\r\n                data.add(HttpConnection.KeyVal.create(name, option.val()));\r\n                set = true;\r\n            }\r\n            if (!set) {\r\n                Element option = el.select(\"option\").first();\r\n                if (option != null)\r\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\r\n            }\r\n        } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\r\n            if (el.hasAttr(\"checked\")) {\r\n                final String val = el.val().length() > 0 ? el.val() : \"on\";\r\n                data.add(HttpConnection.KeyVal.create(name, val));\r\n            }\r\n        } else {\r\n            data.add(HttpConnection.KeyVal.create(name, el.val()));\r\n        }\r\n    }\r\n    return data;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.GwtFileHandle.delete",
	"Comment": "deletes this file or empty directory and returns success. will not delete a directory that has children.",
	"Method": "boolean delete(){\r\n    throw new GdxRuntimeException(\"Cannot delete an internal file: \" + file);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.set",
	"Comment": "sets the quaternion components from the given axis and angle around that axis.",
	"Method": "Quaternion set(float x,float y,float z,float w,Quaternion set,Quaternion quaternion,Quaternion set,Vector3 axis,float angle){\r\n    return setFromAxis(axis.x, axis.y, axis.z, angle);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Base64Coder.decodeString",
	"Comment": "decodes a string from base64 format. no blanks or line breaks are allowed within the base64 encoded input data.",
	"Method": "String decodeString(String s,String decodeString,String s,boolean useUrlSafeEncoding){\r\n    return new String(decode(s.toCharArray(), useUrlSafeEncoding ? urlsafeMap.decodingMap : regularMap.decodingMap));\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.setHorizontallyScrolling",
	"Comment": "sets whether the text should be allowed to be wider than theview is.if false, it will be wrapped to the width of the view.",
	"Method": "void setHorizontallyScrolling(boolean whether){\r\n    mInputView.setHorizontallyScrolling(whether);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.getLinearVelocity",
	"Comment": "get the linear velocity of the center of mass.\tnote that the same vector2 instance is returned each time this method is called.",
	"Method": "Vector2 getLinearVelocity(){\r\n    Vec2 lv = body.getLinearVelocity();\r\n    linearVelocity.set(lv.x, lv.y);\r\n    return linearVelocity;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.contacts.Contact.mixFriction",
	"Comment": "friction mixing law. the idea is to allow either fixture to drive the restitution to zero. forexample, anything slides on ice.",
	"Method": "float mixFriction(float friction1,float friction2){\r\n    return MathUtils.sqrt(friction1 * friction2);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Container.size",
	"Comment": "sets the minwidth, prefwidth, maxwidth, minheight, prefheight, and maxheight to the specified values.",
	"Method": "Container<T> size(Value size,Container<T> size,Value width,Value height,Container<T> size,float size,Container<T> size,float width,float height){\r\n    size(new Fixed(width), new Fixed(height));\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar.resetProgress",
	"Comment": "reset the progress text based on the current min and max progress range.",
	"Method": "void resetProgress(){\r\n    setProgress(getProgress());\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator.generateGlyphAndBitmap",
	"Comment": "returns null if glyph was not found. if there is nothing to render, for example with various space characters, then bitmap\tis null.",
	"Method": "GlyphAndBitmap generateGlyphAndBitmap(int c,int size,boolean flip){\r\n    setPixelSizes(0, size);\r\n    SizeMetrics fontMetrics = face.getSize().getMetrics();\r\n    int baseline = FreeType.toInt(fontMetrics.getAscender());\r\n    if (face.getCharIndex(c) == 0) {\r\n        return null;\r\n    }\r\n    if (!loadChar(c)) {\r\n        throw new GdxRuntimeException(\"Unable to load character!\");\r\n    }\r\n    GlyphSlot slot = face.getGlyph();\r\n    Bitmap bitmap;\r\n    if (bitmapped) {\r\n        bitmap = slot.getBitmap();\r\n    } else if (!slot.renderGlyph(FreeType.FT_RENDER_MODE_NORMAL)) {\r\n        bitmap = null;\r\n    } else {\r\n        bitmap = slot.getBitmap();\r\n    }\r\n    GlyphMetrics metrics = slot.getMetrics();\r\n    Glyph glyph = new Glyph();\r\n    if (bitmap != null) {\r\n        glyph.width = bitmap.getWidth();\r\n        glyph.height = bitmap.getRows();\r\n    } else {\r\n        glyph.width = 0;\r\n        glyph.height = 0;\r\n    }\r\n    glyph.xoffset = slot.getBitmapLeft();\r\n    glyph.yoffset = flip ? -slot.getBitmapTop() + baseline : -(glyph.height - slot.getBitmapTop()) - baseline;\r\n    glyph.xadvance = FreeType.toInt(metrics.getHoriAdvance());\r\n    glyph.srcX = 0;\r\n    glyph.srcY = 0;\r\n    glyph.id = c;\r\n    GlyphAndBitmap result = new GlyphAndBitmap();\r\n    result.glyph = glyph;\r\n    result.bitmap = bitmap;\r\n    return result;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.TextArea.updateCurrentLine",
	"Comment": "updates the current line, checking the cursor position in the text",
	"Method": "void updateCurrentLine(){\r\n    int index = calculateCurrentLineIndex(cursor);\r\n    int line = index / 2;\r\n    if (index % 2 == 0 || index + 1 >= linesBreak.size || cursor != linesBreak.items[index] || linesBreak.items[index + 1] != linesBreak.items[index]) {\r\n        if (line < linesBreak.size / 2 || text.length() == 0 || text.charAt(text.length() - 1) == ENTER_ANDROID || text.charAt(text.length() - 1) == ENTER_DESKTOP) {\r\n            cursorLine = line;\r\n        }\r\n    }\r\n    updateFirstLineShowing();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ObjectSet.shrink",
	"Comment": "reduces the size of the backing arrays to be the specified capacity or less. if the capacity is already less, nothing is\tdone. if the set contains more items than the specified capacity, the next highest power of two capacity is used instead.",
	"Method": "void shrink(int maximumCapacity){\r\n    if (maximumCapacity < 0)\r\n        throw new IllegalArgumentException(\"maximumCapacity must be >= 0: \" + maximumCapacity);\r\n    if (size > maximumCapacity)\r\n        maximumCapacity = size;\r\n    if (capacity <= maximumCapacity)\r\n        return;\r\n    maximumCapacity = MathUtils.nextPowerOfTwo(maximumCapacity);\r\n    resize(maximumCapacity);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.CharArray.shrink",
	"Comment": "reduces the size of the backing array to the size of the actual items. this is useful to release memory when many items\thave been removed, or if it is known that more items will not be added.",
	"Method": "char[] shrink(){\r\n    if (items.length != size)\r\n        resize(size);\r\n    return items;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Event.setBubbles",
	"Comment": "if true, after the event is fired on the target actor, it will also be fired on each of the parent actors, all the way to\tthe root.",
	"Method": "void setBubbles(boolean bubbles){\r\n    this.bubbles = bubbles;\r\n}"
}, {
	"Path": "com.rey.material.widget.ListPopupWindow.setOnDismissListener",
	"Comment": "set a listener to receive a callback when the popup is dismissed.",
	"Method": "void setOnDismissListener(PopupWindow.OnDismissListener listener){\r\n    mPopup.setOnDismissListener(listener);\r\n}"
}, {
	"Path": "junit.framework.TestFailure.trace",
	"Comment": "returns a string containing the stack trace of the errorthrown by testfailure.",
	"Method": "String trace(){\r\n    return Throwables.getStacktrace(thrownException());\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.particles.ResourceData.createSaveData",
	"Comment": "creates and adds a new and unique savedata object to the save data map",
	"Method": "SaveData createSaveData(SaveData createSaveData,String key){\r\n    SaveData saveData = new SaveData(this);\r\n    if (uniqueData.containsKey(key))\r\n        throw new RuntimeException(\"Key already used, data must be unique, use a different key\");\r\n    uniqueData.put(key, saveData);\r\n    return saveData;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.destroyFixture",
	"Comment": "internal method for fixture destruction with notifying custom\tcontact listener",
	"Method": "void destroyFixture(Body body,Fixture fixture){\r\n    jniDestroyFixture(addr, body.addr, fixture.addr);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.ShapeRenderer.translate",
	"Comment": "multiplies the current transformation matrix by a translation matrix.",
	"Method": "void translate(float x,float y,float z){\r\n    transformMatrix.translate(x, y, z);\r\n    matrixDirty = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.FloatArray.shrink",
	"Comment": "reduces the size of the backing array to the size of the actual items. this is useful to release memory when many items\thave been removed, or if it is known that more items will not be added.",
	"Method": "float[] shrink(){\r\n    if (items.length != size)\r\n        resize(size);\r\n    return items;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.iosrobovm.IOSApplication.addViewControllerListener",
	"Comment": "add a listener to handle events from the libgdx root view controller",
	"Method": "void addViewControllerListener(IOSViewControllerListener listener){\r\n    viewControllerListener = listener;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.getYOffset",
	"Comment": "returns the distance from the y drawing location to the top most pixel of the specified text.",
	"Method": "int getYOffset(String text){\r\n    if (text == null)\r\n        throw new IllegalArgumentException(\"text cannot be null.\");\r\n    if (renderType == RenderType.FreeType && bitmapFont != null)\r\n        return (int) bitmapFont.getAscent();\r\n    int index = text.indexOf('\\n');\r\n    if (index != -1)\r\n        text = text.substring(0, index);\r\n    char[] chars = text.toCharArray();\r\n    GlyphVector vector = font.layoutGlyphVector(GlyphPage.renderContext, chars, 0, chars.length, Font.LAYOUT_LEFT_TO_RIGHT);\r\n    int yOffset = ascent + vector.getPixelBounds(null, 0, 0).y;\r\n    return yOffset;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.isEnum",
	"Comment": "determines if the supplied class object represents an enum type.",
	"Method": "boolean isEnum(Class c){\r\n    return c.isEnum();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.getByte",
	"Comment": "finds the child with the specified index and returns it as a byte.",
	"Method": "byte getByte(String name,byte defaultValue,byte getByte,String name,byte getByte,int index){\r\n    JsonValue child = get(index);\r\n    if (child == null)\r\n        throw new IllegalArgumentException(\"Indexed value not found: \" + name);\r\n    return child.asByte();\r\n}"
}, {
	"Path": "com.rey.material.app.Dialog.dismissImmediately",
	"Comment": "dismiss dialog immediately without showing out animation.",
	"Method": "void dismissImmediately(){\r\n    super.dismiss();\r\n    if (mHandler != null)\r\n        mHandler.removeCallbacks(mDismissAction);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Container.pad",
	"Comment": "sets the padtop, padleft, padbottom, and padright to the specified value.",
	"Method": "Container<T> pad(Value pad,Container<T> pad,Value top,Value left,Value bottom,Value right,Container<T> pad,float pad,Container<T> pad,float top,float left,float bottom,float right){\r\n    padTop = new Fixed(top);\r\n    padLeft = new Fixed(left);\r\n    padBottom = new Fixed(bottom);\r\n    padRight = new Fixed(right);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Group.addActorBefore",
	"Comment": "adds an actor as a child of this group immediately before another child actor, removing it from its previous parent. if the\tactor is already a child of this group, no changes are made.",
	"Method": "void addActorBefore(Actor actorBefore,Actor actor){\r\n    if (actor.parent != null) {\r\n        if (actor.parent == this)\r\n            return;\r\n        actor.parent.removeActor(actor, false);\r\n    }\r\n    int index = children.indexOf(actorBefore, true);\r\n    children.insert(index, actor);\r\n    actor.setParent(this);\r\n    actor.setStage(getStage());\r\n    childrenChanged();\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.BitmapFont.getAscent",
	"Comment": "returns the ascent, which is the distance from the cap height to the top of the tallest glyph.",
	"Method": "float getAscent(){\r\n    return data.ascent;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.model.SecondarySwitchDrawerItem.getColor",
	"Comment": "helper method to decide for the correct coloroverwrite to get the correct secondary color",
	"Method": "int getColor(Context ctx){\r\n    int color;\r\n    if (this.isEnabled()) {\r\n        color = ColorHolder.color(getTextColor(), ctx, R.attr.material_drawer_secondary_text, R.color.material_drawer_secondary_text);\r\n    } else {\r\n        color = ColorHolder.color(getDisabledTextColor(), ctx, R.attr.material_drawer_hint_text, R.color.material_drawer_hint_text);\r\n    }\r\n    return color;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.getYaw",
	"Comment": "get the yaw euler angle in degrees, which is the rotation around the y axis. requires that this quaternion is normalized.",
	"Method": "float getYaw(){\r\n    return getYawRad() * MathUtils.radiansToDegrees;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.viewport.Viewport.project",
	"Comment": "transforms the specified world coordinate to screen coordinates.",
	"Method": "Vector2 project(Vector2 worldCoords,Vector3 project,Vector3 worldCoords){\r\n    camera.project(worldCoords, screenX, screenY, screenWidth, screenHeight);\r\n    return worldCoords;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.siblingElements",
	"Comment": "get sibling elements. if the element has no sibling elements, returns an empty list. an element is not a siblingof itself, so will not be included in the returned list.",
	"Method": "Elements siblingElements(){\r\n    if (parentNode == null)\r\n        return new Elements(0);\r\n    List<Element> elements = parent().childElementsList();\r\n    Elements siblings = new Elements(elements.size() - 1);\r\n    for (Element el : elements) if (el != this)\r\n        siblings.add(el);\r\n    return siblings;\r\n}"
}, {
	"Path": "lombok.eclipse.handlers.HandleSuperBuilder.generateBuilderBasedConstructor",
	"Comment": "generates a constructor that has a builder as the only parameter.\tthe values from the builder are used to initialize the fields of new instances.",
	"Method": "void generateBuilderBasedConstructor(EclipseNode typeNode,TypeParameter[] typeParams,List<BuilderFieldData> builderFields,EclipseNode sourceNode,String builderClassName,boolean callBuilderBasedSuperConstructor){\r\n    ASTNode source = sourceNode.get();\r\n    TypeDeclaration typeDeclaration = ((TypeDeclaration) typeNode.get());\r\n    long p = (long) source.sourceStart << 32 | source.sourceEnd;\r\n    ConstructorDeclaration constructor = new ConstructorDeclaration(((CompilationUnitDeclaration) typeNode.top().get()).compilationResult);\r\n    constructor.modifiers = toEclipseModifier(AccessLevel.PROTECTED);\r\n    constructor.selector = typeDeclaration.name;\r\n    if (callBuilderBasedSuperConstructor) {\r\n        constructor.constructorCall = new ExplicitConstructorCall(ExplicitConstructorCall.Super);\r\n        constructor.constructorCall.arguments = new Expression[] { new SingleNameReference(BUILDER_VARIABLE_NAME, p) };\r\n    } else {\r\n        constructor.constructorCall = new ExplicitConstructorCall(ExplicitConstructorCall.ImplicitSuper);\r\n    }\r\n    constructor.constructorCall.sourceStart = source.sourceStart;\r\n    constructor.constructorCall.sourceEnd = source.sourceEnd;\r\n    constructor.thrownExceptions = null;\r\n    constructor.typeParameters = null;\r\n    constructor.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;\r\n    constructor.bodyStart = constructor.declarationSourceStart = constructor.sourceStart = source.sourceStart;\r\n    constructor.bodyEnd = constructor.declarationSourceEnd = constructor.sourceEnd = source.sourceEnd;\r\n    TypeReference[] wildcards = new TypeReference[] { new Wildcard(Wildcard.UNBOUND), new Wildcard(Wildcard.UNBOUND) };\r\n    TypeReference builderType = new ParameterizedSingleTypeReference(builderClassName.toCharArray(), mergeToTypeReferences(typeParams, wildcards), 0, p);\r\n    constructor.arguments = new Argument[] { new Argument(BUILDER_VARIABLE_NAME, p, builderType, Modifier.FINAL) };\r\n    List<Statement> statements = new ArrayList<Statement>();\r\n    for (BuilderFieldData fieldNode : builderFields) {\r\n        char[] fieldName = removePrefixFromField(fieldNode.originalFieldNode);\r\n        FieldReference fieldInThis = new FieldReference(fieldNode.rawName, p);\r\n        int s = (int) (p >> 32);\r\n        int e = (int) p;\r\n        fieldInThis.receiver = new ThisReference(s, e);\r\n        Expression assignmentExpr;\r\n        if (fieldNode.singularData != null && fieldNode.singularData.getSingularizer() != null) {\r\n            fieldNode.singularData.getSingularizer().appendBuildCode(fieldNode.singularData, typeNode, statements, fieldNode.name, BUILDER_VARIABLE_NAME_STRING);\r\n            assignmentExpr = new SingleNameReference(fieldNode.name, p);\r\n        } else {\r\n            char[][] variableInBuilder = new char[][] { BUILDER_VARIABLE_NAME, fieldName };\r\n            long[] positions = new long[] { p, p };\r\n            assignmentExpr = new QualifiedNameReference(variableInBuilder, positions, s, e);\r\n        }\r\n        Statement assignment = new Assignment(fieldInThis, assignmentExpr, (int) p);\r\n        if (fieldNode.nameOfSetFlag != null) {\r\n            char[][] setVariableInBuilder = new char[][] { BUILDER_VARIABLE_NAME, fieldNode.nameOfSetFlag };\r\n            long[] positions = new long[] { p, p };\r\n            QualifiedNameReference setVariableInBuilderRef = new QualifiedNameReference(setVariableInBuilder, positions, s, e);\r\n            MessageSend defaultMethodCall = new MessageSend();\r\n            defaultMethodCall.sourceStart = source.sourceStart;\r\n            defaultMethodCall.sourceEnd = source.sourceEnd;\r\n            defaultMethodCall.receiver = new SingleNameReference(((TypeDeclaration) typeNode.get()).name, 0L);\r\n            defaultMethodCall.selector = fieldNode.nameOfDefaultProvider;\r\n            defaultMethodCall.typeArguments = typeParameterNames(((TypeDeclaration) typeNode.get()).typeParameters);\r\n            Statement defaultAssignment = new Assignment(fieldInThis, defaultMethodCall, (int) p);\r\n            IfStatement ifBlockForDefault = new IfStatement(setVariableInBuilderRef, assignment, defaultAssignment, s, e);\r\n            statements.add(ifBlockForDefault);\r\n        } else {\r\n            statements.add(assignment);\r\n        }\r\n        if (hasNonNullAnnotations(fieldNode.originalFieldNode)) {\r\n            Statement nullCheck = generateNullCheck((FieldDeclaration) fieldNode.originalFieldNode.get(), sourceNode);\r\n            if (nullCheck != null)\r\n                statements.add(nullCheck);\r\n        }\r\n    }\r\n    constructor.statements = statements.isEmpty() ? null : statements.toArray(new Statement[statements.size()]);\r\n    constructor.traverse(new SetGeneratedByVisitor(source), typeDeclaration.scope);\r\n    injectMethod(typeNode, constructor);\r\n}"
}, {
	"Path": "com.rey.material.app.TimePickerDialog.onTimeChangedListener",
	"Comment": "set a listener will be called when the selected time is changed.",
	"Method": "TimePickerDialog onTimeChangedListener(OnTimeChangedListener listener){\r\n    mTimePickerLayout.setOnTimeChangedListener(listener);\r\n    return this;\r\n}"
}, {
	"Path": "org.junit.tests.junit3compatibility.JUnit38ClassRunnerTest.filterNoTestsRemain",
	"Comment": "test that notestsremainexception is thrown when all methods have been filtered.",
	"Method": "void filterNoTestsRemain(){\r\n    JUnit38ClassRunner runner = new JUnit38ClassRunner(OneTest.class);\r\n    runner.filter(new RejectAllTestsFilter());\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.DrawerBuilder.withStickyHeader",
	"Comment": "add a sticky header below the drawerbuilder listview defined by a resource.",
	"Method": "DrawerBuilder withStickyHeader(View stickyHeader,DrawerBuilder withStickyHeader,int stickyHeaderRes){\r\n    if (mActivity == null) {\r\n        throw new RuntimeException(\"please pass an activity first to use this call\");\r\n    }\r\n    if (stickyHeaderRes != -1) {\r\n        this.mStickyHeaderView = mActivity.getLayoutInflater().inflate(stickyHeaderRes, null, false);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener.getTapCount",
	"Comment": "returns the number of taps within the tap count interval for the most recent click event.",
	"Method": "int getTapCount(){\r\n    return tapCount;\r\n}"
}, {
	"Path": "java.nio.IntBuffer.array",
	"Comment": "returns the int array which this buffer is based on, if there is one.",
	"Method": "int[] array(){\r\n    return protectedArray();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntFloatMap.findKey",
	"Comment": "returns the key for the specified value, or null if it is not in the map. note this traverses the entire map and compares\tevery value, which may be an expensive operation.",
	"Method": "int findKey(float value,int notFound){\r\n    if (hasZeroValue && zeroValue == value)\r\n        return 0;\r\n    int[] keyTable = this.keyTable;\r\n    float[] valueTable = this.valueTable;\r\n    for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != 0 && valueTable[i] == value)\r\n        return keyTable[i];\r\n    return notFound;\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getInputExtras",
	"Comment": "retrieve the input extras currently associated with the text view, whichcan be viewed as well as modified.",
	"Method": "Bundle getInputExtras(boolean create){\r\n    return mInputView.getInputExtras(create);\r\n}"
}, {
	"Path": "org.jsoup.nodes.Attributes.put",
	"Comment": "set a new boolean attribute, remove attribute if value is false.",
	"Method": "Attributes put(String key,String value,Attributes put,String key,boolean value,Attributes put,Attribute attribute,String put,String key,String value){\r\n    Validate.notNull(attribute);\r\n    put(attribute.getKey(), attribute.getValue());\r\n    attribute.parent = this;\r\n    return this;\r\n}"
}, {
	"Path": "junit.framework.TestResult.addError",
	"Comment": "adds an error to the list of errors. the passed in exceptioncaused the error.",
	"Method": "void addError(Test test,Throwable e){\r\n    fErrors.add(new TestFailure(test, e));\r\n    for (TestListener each : cloneListeners()) {\r\n        each.addError(test, e);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.World.deactivateBody",
	"Comment": "internal method for body deactivation with notifying custom\tcontact listener",
	"Method": "void deactivateBody(Body body){\r\n    jniDeactivateBody(addr, body.addr);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer.invalidateAllFrameBuffers",
	"Comment": "invalidates all frame buffers. this can be used when the opengl context is lost to rebuild all managed frame buffers. this\tassumes that the texture attached to this buffer has already been rebuild! use with care.",
	"Method": "void invalidateAllFrameBuffers(Application app){\r\n    if (Gdx.gl20 == null)\r\n        return;\r\n    Array<GLFrameBuffer> bufferArray = buffers.get(app);\r\n    if (bufferArray == null)\r\n        return;\r\n    for (int i = 0; i < bufferArray.size; i++) {\r\n        bufferArray.get(i).build();\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Vector3.set",
	"Comment": "sets the components from the array. the array must have at least 3 elements",
	"Method": "Vector3 set(float x,float y,float z,Vector3 set,Vector3 vector,Vector3 set,float[] values,Vector3 set,Vector2 vector,float z){\r\n    return this.set(vector.x, vector.y, z);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.collision.Ray.mul",
	"Comment": "multiplies the ray by the given matrix. use this to transform a ray into another coordinate system.",
	"Method": "Ray mul(Matrix4 matrix){\r\n    tmp.set(origin).add(direction);\r\n    tmp.mul(matrix);\r\n    origin.mul(matrix);\r\n    direction.set(tmp.sub(origin));\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ByteArray.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding many\titems to avoid multiple backing array resizes.",
	"Method": "byte[] ensureCapacity(int additionalCapacity){\r\n    if (additionalCapacity < 0)\r\n        throw new IllegalArgumentException(\"additionalCapacity must be >= 0: \" + additionalCapacity);\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded > items.length)\r\n        resize(Math.max(8, sizeNeeded));\r\n    return items;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Matrix4.trn",
	"Comment": "adds a translational component to the matrix in the 4th column. the other columns are untouched.",
	"Method": "Matrix4 trn(Vector3 vector,Matrix4 trn,float x,float y,float z){\r\n    val[M03] += x;\r\n    val[M13] += y;\r\n    val[M23] += z;\r\n    return this;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.getElementsMatchingText",
	"Comment": "find elements whose text matches the supplied regular expression.",
	"Method": "Elements getElementsMatchingText(Pattern pattern,Elements getElementsMatchingText,String regex){\r\n    Pattern pattern;\r\n    try {\r\n        pattern = Pattern.compile(regex);\r\n    } catch (PatternSyntaxException e) {\r\n        throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\r\n    }\r\n    return getElementsMatchingText(pattern);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.getJointList",
	"Comment": "get the list of all joints attached to this body. do not modify the list!",
	"Method": "Array<JointEdge> getJointList(){\r\n    org.jbox2d.dynamics.joints.JointEdge jointEdge = body.getJointList();\r\n    joints.clear();\r\n    while (jointEdge != null) {\r\n        JointEdge edge = new JointEdge(world.bodies.get(jointEdge.other), world.joints.get(jointEdge.joint));\r\n        joints.add(edge);\r\n        jointEdge = jointEdge.next;\r\n    }\r\n    return joints;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.applyTorque",
	"Comment": "apply a torque. this affects the angular velocity without affecting the linear velocity of thecenter of mass. this wakes up the body.",
	"Method": "void applyTorque(float torque){\r\n    if (m_type != BodyType.DYNAMIC) {\r\n        return;\r\n    }\r\n    if (isAwake() == false) {\r\n        setAwake(true);\r\n    }\r\n    m_torque += torque;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Tree.getClickListener",
	"Comment": "returns the click listener the tree uses for clicking on nodes and the over node.",
	"Method": "ClickListener getClickListener(){\r\n    return clickListener;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.getChild",
	"Comment": "finds the child with the specified name and returns its first child.",
	"Method": "JsonValue getChild(String name){\r\n    JsonValue child = get(name);\r\n    return child == null ? null : child.child;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.BitmapFont.setFixedWidthGlyphs",
	"Comment": "makes the specified glyphs fixed width. this can be useful to make the numbers in a font fixed width. eg, when horizontally\tcentering a score or loading percentage text, it will not jump around as different numbers are shown.",
	"Method": "void setFixedWidthGlyphs(CharSequence glyphs){\r\n    BitmapFontData data = this.data;\r\n    int maxAdvance = 0;\r\n    for (int index = 0, end = glyphs.length(); index < end; index++) {\r\n        Glyph g = data.getGlyph(glyphs.charAt(index));\r\n        if (g != null && g.xadvance > maxAdvance)\r\n            maxAdvance = g.xadvance;\r\n    }\r\n    for (int index = 0, end = glyphs.length(); index < end; index++) {\r\n        Glyph g = data.getGlyph(glyphs.charAt(index));\r\n        if (g == null)\r\n            continue;\r\n        g.xoffset += Math.round((maxAdvance - g.xadvance) / 2);\r\n        g.xadvance = maxAdvance;\r\n        g.kerning = null;\r\n        g.fixedWidth = true;\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.Field.isAnnotationPresent",
	"Comment": "returns true if the field includes an annotation of the provided class type.",
	"Method": "boolean isAnnotationPresent(Class<? extends java.lang.annotation.Annotation> annotationType){\r\n    return field.isAnnotationPresent(annotationType);\r\n}"
}, {
	"Path": "com.badlogic.gdx.files.FileHandle.length",
	"Comment": "returns the length in bytes of this file, or 0 if this file is a directory, does not exist, or the size cannot otherwise be\tdetermined.",
	"Method": "long length(){\r\n    if (type == FileType.Classpath || (type == FileType.Internal && !file.exists())) {\r\n        InputStream input = read();\r\n        try {\r\n            return input.available();\r\n        } catch (Exception ignored) {\r\n        } finally {\r\n            StreamUtils.closeQuietly(input);\r\n        }\r\n        return 0;\r\n    }\r\n    return file().length();\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.setPaddingAdvanceX",
	"Comment": "sets the additional amount to offset glyphs on the x axis. this is typically set to a negative number when left or right\tpadding is used so that glyphs are not spaced too far apart.",
	"Method": "void setPaddingAdvanceX(int paddingAdvanceX){\r\n    this.paddingAdvanceX = paddingAdvanceX;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.setPaddingAdvanceY",
	"Comment": "sets the additional amount to offset a line of text on the y axis. this is typically set to a negative number when top or\tbottom padding is used so that lines of text are not spaced too far apart.",
	"Method": "void setPaddingAdvanceY(int paddingAdvanceY){\r\n    this.paddingAdvanceY = paddingAdvanceY;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup.pad",
	"Comment": "sets the padtop, padleft, padbottom, and padright to the specified value.",
	"Method": "VerticalGroup pad(float pad,VerticalGroup pad,float top,float left,float bottom,float right){\r\n    padTop = top;\r\n    padLeft = left;\r\n    padBottom = bottom;\r\n    padRight = right;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.tests.bullet.OcclusionBuffer.setProjectionMatrix",
	"Comment": "sets the projection matrix to be used for rendering. usually this will be set to camera.combined.",
	"Method": "void setProjectionMatrix(Matrix4 matrix){\r\n    projectionMatrix.set(matrix);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Actor.localToActorCoordinates",
	"Comment": "converts coordinates for this actor to those of another actor, which can be anywhere in the stage.",
	"Method": "Vector2 localToActorCoordinates(Actor actor,Vector2 localCoords){\r\n    localToStageCoordinates(localCoords);\r\n    return actor.stageToLocalCoordinates(localCoords);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.SharedLibraryLoader.loadFile",
	"Comment": "extracts the source file and calls system.load. attemps to extract and load from multiple locations. throws runtime\texception if all fail.",
	"Method": "void loadFile(String sourcePath,Throwable loadFile,String sourcePath,String sourceCrc,File extractedFile){\r\n    try {\r\n        System.load(extractFile(sourcePath, sourceCrc, extractedFile).getAbsolutePath());\r\n        return null;\r\n    } catch (Throwable ex) {\r\n        return ex;\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntIntMap.containsValue",
	"Comment": "returns true if the specified value is in the map. note this traverses the entire map and compares every value, which may be\tan expensive operation.",
	"Method": "boolean containsValue(int value){\r\n    if (hasZeroValue && zeroValue == value)\r\n        return true;\r\n    int[] keyTable = this.keyTable, valueTable = this.valueTable;\r\n    for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != 0 && valueTable[i] == value)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.ClassReflection.isPrimitive",
	"Comment": "determines if the supplied class object represents a primitive type.",
	"Method": "boolean isPrimitive(Class c){\r\n    return c.isPrimitive();\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont.getPaddingAdvanceY",
	"Comment": "gets the additional amount to offset a line of text on the y axis.",
	"Method": "int getPaddingAdvanceY(){\r\n    return paddingAdvanceY;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Vector3.epsilonEquals",
	"Comment": "compares this vector with the other vector, using the supplied epsilon for fuzzy equality testing.",
	"Method": "boolean epsilonEquals(Vector3 other,float epsilon,boolean epsilonEquals,float x,float y,float z,float epsilon,boolean epsilonEquals,Vector3 other,boolean epsilonEquals,float x,float y,float z){\r\n    return epsilonEquals(x, y, z, MathUtils.FLOAT_ROUNDING_ERROR);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Timer.scheduleTask",
	"Comment": "schedules a task to occur once after the specified delay and then a number of additional times at the specified interval.",
	"Method": "Task scheduleTask(Task task,float delaySeconds,Task scheduleTask,Task task,float delaySeconds,float intervalSeconds,Task scheduleTask,Task task,float delaySeconds,float intervalSeconds,int repeatCount){\r\n    synchronized (this) {\r\n        synchronized (task) {\r\n            if (task.timer != null)\r\n                throw new IllegalArgumentException(\"The same task may not be scheduled twice.\");\r\n            task.timer = this;\r\n            task.executeTimeMillis = System.nanoTime() / 1000000 + (long) (delaySeconds * 1000);\r\n            task.intervalMillis = (long) (intervalSeconds * 1000);\r\n            task.repeatCount = repeatCount;\r\n            tasks.add(task);\r\n        }\r\n    }\r\n    synchronized (threadLock) {\r\n        threadLock.notifyAll();\r\n    }\r\n    return task;\r\n}"
}, {
	"Path": "org.jsoup.helper.DataUtil.load",
	"Comment": "parses a document from an input steam, using the provided parser.",
	"Method": "Document load(File in,String charsetName,String baseUri,Document load,InputStream in,String charsetName,String baseUri,Document load,InputStream in,String charsetName,String baseUri,Parser parser){\r\n    return parseInputStream(in, charsetName, baseUri, parser);\r\n}"
}, {
	"Path": "com.codahale.metrics.MetricRegistry.getCounters",
	"Comment": "returns a map of all the counters in the registry and their names which match the givenfilter.",
	"Method": "SortedMap<String, Counter> getCounters(SortedMap<String, Counter> getCounters,MetricFilter filter){\r\n    return getMetrics(Counter.class, filter);\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Body.setSleepingAllowed",
	"Comment": "you can disable sleeping on this body. if you disable sleeping, the",
	"Method": "void setSleepingAllowed(boolean flag){\r\n    body.setSleepingAllowed(flag);\r\n}"
}, {
	"Path": "com.rey.material.widget.DatePicker.setOnDateChangedListener",
	"Comment": "set the listener will be called when the selected date is changed.",
	"Method": "void setOnDateChangedListener(OnDateChangedListener listener){\r\n    mOnDateChangedListener = listener;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Base64Coder.encodeLines",
	"Comment": "encodes a byte array into base 64 format and breaks the output into lines.",
	"Method": "String encodeLines(byte[] in,String encodeLines,byte[] in,int iOff,int iLen,int lineLen,String lineSeparator,CharMap charMap,String encodeLines,byte[] in,int iOff,int iLen,int lineLen,String lineSeparator,char[] charMap){\r\n    int blockLen = (lineLen * 3) / 4;\r\n    if (blockLen <= 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    int lines = (iLen + blockLen - 1) / blockLen;\r\n    int bufLen = ((iLen + 2) / 3) * 4 + lines * lineSeparator.length();\r\n    StringBuilder buf = new StringBuilder(bufLen);\r\n    int ip = 0;\r\n    while (ip < iLen) {\r\n        int l = Math.min(iLen - ip, blockLen);\r\n        buf.append(encode(in, iOff + ip, l, charMap));\r\n        buf.append(lineSeparator);\r\n        ip += l;\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.prependElement",
	"Comment": "create a new element by tag name, and add it as the first child.",
	"Method": "Element prependElement(String tagName){\r\n    Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());\r\n    prependChild(child);\r\n    return child;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.getMassData",
	"Comment": "get the mass data of the body. the rotational inertia is relative to the center of mass.",
	"Method": "void getMassData(MassData data){\r\n    data.mass = m_mass;\r\n    data.I = m_I + m_mass * (m_sweep.localCenter.x * m_sweep.localCenter.x + m_sweep.localCenter.y * m_sweep.localCenter.y);\r\n    data.center.x = m_sweep.localCenter.x;\r\n    data.center.y = m_sweep.localCenter.y;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.I18NBundle.createBundle",
	"Comment": "creates a new bundle using the specified basefilehandle, locale and encoding.",
	"Method": "I18NBundle createBundle(FileHandle baseFileHandle,I18NBundle createBundle,FileHandle baseFileHandle,Locale locale,I18NBundle createBundle,FileHandle baseFileHandle,String encoding,I18NBundle createBundle,FileHandle baseFileHandle,Locale locale,String encoding){\r\n    return createBundleImpl(baseFileHandle, locale, encoding);\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Stage.cancelTouchFocusExcept",
	"Comment": "cancels touch focus for all listeners except the specified listener.",
	"Method": "void cancelTouchFocusExcept(EventListener exceptListener,Actor exceptActor){\r\n    InputEvent event = Pools.obtain(InputEvent.class);\r\n    event.setStage(this);\r\n    event.setType(InputEvent.Type.touchUp);\r\n    event.setStageX(Integer.MIN_VALUE);\r\n    event.setStageY(Integer.MIN_VALUE);\r\n    SnapshotArray<TouchFocus> touchFocuses = this.touchFocuses;\r\n    TouchFocus[] items = touchFocuses.begin();\r\n    for (int i = 0, n = touchFocuses.size; i < n; i++) {\r\n        TouchFocus focus = items[i];\r\n        if (focus.listener == exceptListener && focus.listenerActor == exceptActor)\r\n            continue;\r\n        if (!touchFocuses.removeValue(focus, true))\r\n            continue;\r\n        event.setTarget(focus.target);\r\n        event.setListenerActor(focus.listenerActor);\r\n        event.setPointer(focus.pointer);\r\n        event.setButton(focus.button);\r\n        focus.listener.handle(event);\r\n    }\r\n    touchFocuses.end();\r\n    Pools.free(event);\r\n}"
}, {
	"Path": "com.rey.material.widget.Slider.setSecondaryColor",
	"Comment": "changes the secondary color and invalidates the view to force a redraw.",
	"Method": "void setSecondaryColor(int color){\r\n    mSecondaryColor = color;\r\n    invalidate();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.LongArray.random",
	"Comment": "returns a random item from the array, or zero if the array is empty.",
	"Method": "long random(){\r\n    if (size == 0)\r\n        return 0;\r\n    return items[MathUtils.random(0, size - 1)];\r\n}"
}, {
	"Path": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect.setBlurPasses",
	"Comment": "sets the number of times to apply a blur to the shadow. set to 0 for no blur.",
	"Method": "void setBlurPasses(int blurPasses){\r\n    this.blurPasses = blurPasses;\r\n}"
}, {
	"Path": "java.nio.DoubleBuffer.put",
	"Comment": "write a double to the specified index of this buffer and the position is not changed.",
	"Method": "DoubleBuffer put(double d,DoubleBuffer put,double[] src,DoubleBuffer put,double[] src,int off,int len,DoubleBuffer put,DoubleBuffer src,DoubleBuffer put,int index,double d){\r\n    if (src == this) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (src.remaining() > remaining()) {\r\n        throw new BufferOverflowException();\r\n    }\r\n    double[] doubles = new double[src.remaining()];\r\n    src.get(doubles);\r\n    put(doubles);\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Bits.or",
	"Comment": "performs a logical or of this bit set with the bit set argument. this bit set is modified so that a bit in it has the\tvalue true if and only if it either already had the value true or the corresponding bit in the bit set argument has the\tvalue true.",
	"Method": "void or(Bits other){\r\n    int commonWords = Math.min(bits.length, other.bits.length);\r\n    for (int i = 0; commonWords > i; i++) {\r\n        bits[i] |= other.bits[i];\r\n    }\r\n    if (commonWords < other.bits.length) {\r\n        checkCapacity(other.bits.length);\r\n        for (int i = commonWords, s = other.bits.length; s > i; i++) {\r\n            bits[i] = other.bits[i];\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.joints.MotorJointDef.initialize",
	"Comment": "initialize the bodies and offsets using the current transforms.",
	"Method": "void initialize(Body body1,Body body2){\r\n    this.bodyA = body1;\r\n    this.bodyB = body2;\r\n    this.linearOffset.set(bodyA.getLocalPoint(bodyB.getPosition()));\r\n    this.angularOffset = bodyB.getAngle() - bodyA.getAngle();\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.DistanceJointDef.initialize",
	"Comment": "initialize the bodies, anchors, and length using the world anchors.",
	"Method": "void initialize(Body b1,Body b2,Vec2 anchor1,Vec2 anchor2){\r\n    bodyA = b1;\r\n    bodyB = b2;\r\n    localAnchorA.set(bodyA.getLocalPoint(anchor1));\r\n    localAnchorB.set(bodyB.getLocalPoint(anchor2));\r\n    Vec2 d = anchor2.sub(anchor1);\r\n    length = d.length();\r\n}"
}, {
	"Path": "org.junit.internal.Throwables.getTrimmedStackTrace",
	"Comment": "gets a trimmed version of the stack trace of the given exception. stack traceelements that are below the test method are filtered out.",
	"Method": "String getTrimmedStackTrace(Throwable exception){\r\n    List<String> trimmedStackTraceLines = getTrimmedStackTraceLines(exception);\r\n    if (trimmedStackTraceLines.isEmpty()) {\r\n        return getFullStackTrace(exception);\r\n    }\r\n    StringBuilder result = new StringBuilder(exception.toString());\r\n    appendStackTraceLines(trimmedStackTraceLines, result);\r\n    appendStackTraceLines(getCauseStackTraceLines(exception), result);\r\n    return result.toString();\r\n}"
}, {
	"Path": "com.sun.jna.Structure.setAutoWrite",
	"Comment": "set whether the structure is written to native memory prior to a nativefunction call.",
	"Method": "void setAutoWrite(boolean auto){\r\n    this.autoWrite = auto;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.model.AbstractDrawerItem.withSubItems",
	"Comment": "an array of subitemsmake sure the subitems provided already have identifiers",
	"Method": "T withSubItems(List<IDrawerItem> subItems,T withSubItems,IDrawerItem subItems){\r\n    if (mSubItems == null) {\r\n        mSubItems = new ArrayList();\r\n    }\r\n    for (IDrawerItem subItem : subItems) {\r\n        subItem.withParent(this);\r\n    }\r\n    Collections.addAll(mSubItems, subItems);\r\n    return (T) this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.VertexBufferObject.invalidate",
	"Comment": "invalidates the vertexbufferobject so a new opengl buffer handle is created. use this in case of a context loss.",
	"Method": "void invalidate(){\r\n    bufferHandle = Gdx.gl20.glGenBuffer();\r\n    isDirty = true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntFloatMap.containsValue",
	"Comment": "returns true if the specified value is in the map. note this traverses the entire map and compares every value, which may be\tan expensive operation.",
	"Method": "boolean containsValue(float value,boolean containsValue,float value,float epsilon){\r\n    if (hasZeroValue && Math.abs(zeroValue - value) <= epsilon)\r\n        return true;\r\n    float[] valueTable = this.valueTable;\r\n    for (int i = capacity + stashSize; i-- > 0; ) if (Math.abs(valueTable[i] - value) <= epsilon)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.Actor.setStage",
	"Comment": "called by the framework when this actor or any parent is added to a group that is in the stage.",
	"Method": "void setStage(Stage stage){\r\n    this.stage = stage;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntMap.containsValue",
	"Comment": "returns true if the specified value is in the map. note this traverses the entire map and compares every value, which may\tbe an expensive operation.",
	"Method": "boolean containsValue(Object value,boolean identity){\r\n    V[] valueTable = this.valueTable;\r\n    if (value == null) {\r\n        if (hasZeroValue && zeroValue == null)\r\n            return true;\r\n        int[] keyTable = this.keyTable;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != EMPTY && valueTable[i] == null)\r\n            return true;\r\n    } else if (identity) {\r\n        if (value == zeroValue)\r\n            return true;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (valueTable[i] == value)\r\n            return true;\r\n    } else {\r\n        if (hasZeroValue && value.equals(zeroValue))\r\n            return true;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (value.equals(valueTable[i]))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntMap.findKey",
	"Comment": "returns the key for the specified value, or notfound if it is not in the map. note this traverses the entire map\tand compares every value, which may be an expensive operation.",
	"Method": "int findKey(Object value,boolean identity,int notFound){\r\n    V[] valueTable = this.valueTable;\r\n    if (value == null) {\r\n        if (hasZeroValue && zeroValue == null)\r\n            return 0;\r\n        int[] keyTable = this.keyTable;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != EMPTY && valueTable[i] == null)\r\n            return keyTable[i];\r\n    } else if (identity) {\r\n        if (value == zeroValue)\r\n            return 0;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (valueTable[i] == value)\r\n            return keyTable[i];\r\n    } else {\r\n        if (hasZeroValue && value.equals(zeroValue))\r\n            return 0;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (value.equals(valueTable[i]))\r\n            return keyTable[i];\r\n    }\r\n    return notFound;\r\n}"
}, {
	"Path": "org.jsoup.parser.Parser.htmlParser",
	"Comment": "create a new html parser. this parser treats input as html5, and enforces the creation of a normalised document,based on a knowledge of the semantics of the incoming tags.",
	"Method": "Parser htmlParser(){\r\n    return new Parser(new HtmlTreeBuilder());\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.SharedLibraryLoader.extractFile",
	"Comment": "extracts the specified file to the specified directory if it does not already exist or the crc does not match. if file\textraction fails and the file exists at java.library.path, that file is returned.",
	"Method": "File extractFile(String sourcePath,String dirName,File extractFile,String sourcePath,String sourceCrc,File extractedFile){\r\n    String extractedCrc = null;\r\n    if (extractedFile.exists()) {\r\n        try {\r\n            extractedCrc = crc(new FileInputStream(extractedFile));\r\n        } catch (FileNotFoundException ignored) {\r\n        }\r\n    }\r\n    if (extractedCrc == null || !extractedCrc.equals(sourceCrc)) {\r\n        InputStream input = null;\r\n        FileOutputStream output = null;\r\n        try {\r\n            input = readFile(sourcePath);\r\n            extractedFile.getParentFile().mkdirs();\r\n            output = new FileOutputStream(extractedFile);\r\n            byte[] buffer = new byte[4096];\r\n            while (true) {\r\n                int length = input.read(buffer);\r\n                if (length == -1)\r\n                    break;\r\n                output.write(buffer, 0, length);\r\n            }\r\n        } catch (IOException ex) {\r\n            throw new GdxRuntimeException(\"Error extracting file: \" + sourcePath + \"\\nTo: \" + extractedFile.getAbsolutePath(), ex);\r\n        } finally {\r\n            StreamUtils.closeQuietly(input);\r\n            StreamUtils.closeQuietly(output);\r\n        }\r\n    }\r\n    return extractedFile;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Skin.getAll",
	"Comment": "returns the name to resource mapping for the specified type, or null if no resources of that type exist.",
	"Method": "ObjectMap<String, T> getAll(Class<T> type){\r\n    return (ObjectMap<String, T>) resources.get(type);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer.unbind",
	"Comment": "unbinds the framebuffer, all drawing will be performed to the normal framebuffer from here on.",
	"Method": "void unbind(){\r\n    Gdx.gl20.glBindFramebuffer(GL20.GL_FRAMEBUFFER, defaultFramebufferHandle);\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.model.AbstractDrawerItem.withPostOnBindViewListener",
	"Comment": "add this listener and hook in if you want to modify a draweritems view without creating a custom drawer item",
	"Method": "T withPostOnBindViewListener(OnPostBindViewListener onPostBindViewListener){\r\n    this.mOnPostBindViewListener = onPostBindViewListener;\r\n    return (T) this;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.MiniDrawer.withEnableSelectedMiniDrawerItemBackground",
	"Comment": "set to true if you want to display the background for the minidraweritem",
	"Method": "MiniDrawer withEnableSelectedMiniDrawerItemBackground(boolean enableSelectedMiniDrawerItemBackground){\r\n    this.mEnableSelectedMiniDrawerItemBackground = enableSelectedMiniDrawerItemBackground;\r\n    return this;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.setLinearDamping",
	"Comment": "linear damping is use to reduce the linear velocity. the damping parameter can be larger than1.0f but the damping effect becomes sensitive to the time step when the damping parameter islarge.",
	"Method": "void setLinearDamping(float linearDamping){\r\n    this.linearDamping = linearDamping;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.CharArray.removeAll",
	"Comment": "removes from this array all of elements contained in the specified array.",
	"Method": "boolean removeAll(CharArray array){\r\n    int size = this.size;\r\n    int startSize = size;\r\n    char[] items = this.items;\r\n    for (int i = 0, n = array.size; i < n; i++) {\r\n        char item = array.get(i);\r\n        for (int ii = 0; ii < size; ii++) {\r\n            if (item == items[ii]) {\r\n                removeIndex(ii);\r\n                size--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return size != startSize;\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.ui.Dialog.text",
	"Comment": "adds a label to the content table. the dialog must have been constructed with a skin to use this method.",
	"Method": "Dialog text(String text,Dialog text,String text,LabelStyle labelStyle,Dialog text,Label label){\r\n    contentTable.add(label);\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jna.Structure.updateStructureByReference",
	"Comment": "only keep the original structure if its native address is unchanged.otherwise replace it with a new object.",
	"Method": "T updateStructureByReference(Class<T> type,T s,Pointer address){\r\n    if (address == null) {\r\n        s = null;\r\n    } else {\r\n        if (s == null || !address.equals(s.getPointer())) {\r\n            Structure s1 = reading().get(address);\r\n            if (s1 != null && type.equals(s1.getClass())) {\r\n                s = (T) s1;\r\n                s.autoRead();\r\n            } else {\r\n                s = newInstance(type, address);\r\n                s.conditionalAutoRead();\r\n            }\r\n        } else {\r\n            s.autoRead();\r\n        }\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18.onDetachedFromWindow",
	"Comment": "this method is used as part of the view class and is not normallycalled or subclassed by clients of glsurfaceview.must not be called before a renderer has been set.",
	"Method": "void onDetachedFromWindow(){\r\n    if (LOG_ATTACH_DETACH) {\r\n        Log.d(TAG, \"onDetachedFromWindow\");\r\n    }\r\n    if (mGLThread != null) {\r\n        mGLThread.requestExitAndWait();\r\n    }\r\n    mDetached = true;\r\n    super.onDetachedFromWindow();\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop.setTapSquareSize",
	"Comment": "sets the distance a touch must travel before being considered a drag.",
	"Method": "void setTapSquareSize(float halfTapSquareSize){\r\n    tapSquareSize = halfTapSquareSize;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.Quaternion.getRollRad",
	"Comment": "get the roll euler angle in radians, which is the rotation around the z axis. requires that this quaternion is normalized.",
	"Method": "float getRollRad(){\r\n    final int pole = getGimbalPole();\r\n    return pole == 0 ? MathUtils.atan2(2f * (w * z + y * x), 1f - 2f * (x * x + z * z)) : (float) pole * 2f * MathUtils.atan2(y, w);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.JsonValue.getShort",
	"Comment": "finds the child with the specified index and returns it as a short.",
	"Method": "short getShort(String name,short defaultValue,short getShort,String name,short getShort,int index){\r\n    JsonValue child = get(index);\r\n    if (child == null)\r\n        throw new IllegalArgumentException(\"Indexed value not found: \" + name);\r\n    return child.asShort();\r\n}"
}, {
	"Path": "com.github.florent37.materialviewpager.MaterialViewPagerAnimator.dispatchScrollOffset",
	"Comment": "when notified for scroll, dispatch it to all registered scrollables",
	"Method": "void dispatchScrollOffset(Object source,float yOffset){\r\n    if (scrollViewList != null) {\r\n        for (Object scroll : scrollViewList) {\r\n            if (scroll != null && scroll != source) {\r\n                setScrollOffset(scroll, yOffset);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jsoup.nodes.Document.location",
	"Comment": "get the url this document was parsed from. if the starting url is a redirect,this will return the final url from which the document was served from.",
	"Method": "String location(){\r\n    return location;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.box2d.Fixture.setFilterData",
	"Comment": "set the contact filtering data. this will not update contacts until the next time step when either parent body is active and\tawake. this automatically calls refilter.",
	"Method": "void setFilterData(Filter filter){\r\n    org.jbox2d.dynamics.Filter f = new org.jbox2d.dynamics.Filter();\r\n    f.categoryBits = filter.categoryBits;\r\n    f.groupIndex = filter.groupIndex;\r\n    f.maskBits = filter.maskBits;\r\n    fixture.setFilterData(f);\r\n}"
}, {
	"Path": "com.prolificinteractive.materialcalendarview.MaterialCalendarView.invalidateDecorators",
	"Comment": "invalidate decorators after one has changed internally. that is, if a decorator mutates, youshould call this method to update the widget.",
	"Method": "void invalidateDecorators(){\r\n    adapter.invalidateDecorators();\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.Kernel32Util.getResourceNames",
	"Comment": "gets a list of all resources from the specified executable file",
	"Method": "Map<String, List<String>> getResourceNames(String path){\r\n    HMODULE target = Kernel32.INSTANCE.LoadLibraryEx(path, null, Kernel32.LOAD_LIBRARY_AS_DATAFILE);\r\n    if (target == null) {\r\n        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n    }\r\n    final List<String> types = new ArrayList<String>();\r\n    final Map<String, List<String>> result = new LinkedHashMap<String, List<String>>();\r\n    WinBase.EnumResTypeProc ertp = new WinBase.EnumResTypeProc() {\r\n        @Override\r\n        public boolean invoke(HMODULE module, Pointer type, Pointer lParam) {\r\n            if (Pointer.nativeValue(type) <= 65535) {\r\n                types.add(Pointer.nativeValue(type) + \"\");\r\n            } else {\r\n                types.add(type.getWideString(0));\r\n            }\r\n            return true;\r\n        }\r\n    };\r\n    WinBase.EnumResNameProc ernp = new WinBase.EnumResNameProc() {\r\n        @Override\r\n        public boolean invoke(HMODULE module, Pointer type, Pointer name, Pointer lParam) {\r\n            String typeName = \"\";\r\n            if (Pointer.nativeValue(type) <= 65535) {\r\n                typeName = Pointer.nativeValue(type) + \"\";\r\n            } else {\r\n                typeName = type.getWideString(0);\r\n            }\r\n            if (Pointer.nativeValue(name) < 65535) {\r\n                result.get(typeName).add(Pointer.nativeValue(name) + \"\");\r\n            } else {\r\n                result.get(typeName).add(name.getWideString(0));\r\n            }\r\n            return true;\r\n        }\r\n    };\r\n    Win32Exception err = null;\r\n    try {\r\n        if (!Kernel32.INSTANCE.EnumResourceTypes(target, ertp, null)) {\r\n            throw new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n        }\r\n        for (final String typeName : types) {\r\n            result.put(typeName, new ArrayList<String>());\r\n            Pointer pointer = null;\r\n            try {\r\n                pointer = new Pointer(Long.parseLong(typeName));\r\n            } catch (NumberFormatException e) {\r\n                pointer = new Memory(Native.WCHAR_SIZE * (typeName.length() + 1));\r\n                pointer.setWideString(0, typeName);\r\n            }\r\n            boolean callResult = Kernel32.INSTANCE.EnumResourceNames(target, pointer, ernp, null);\r\n            if (!callResult) {\r\n                throw new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n            }\r\n        }\r\n    } catch (Win32Exception e) {\r\n        err = e;\r\n    } finally {\r\n        if (target != null) {\r\n            if (!Kernel32.INSTANCE.FreeLibrary(target)) {\r\n                Win32Exception we = new Win32Exception(Kernel32.INSTANCE.GetLastError());\r\n                if (err != null) {\r\n                    we.addSuppressedReflected(err);\r\n                }\r\n                throw we;\r\n            }\r\n        }\r\n    }\r\n    if (err != null) {\r\n        throw err;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.Kernel32Util.getResourceNames",
	"Comment": "gets a list of all resources from the specified executable file",
	"Method": "Map<String, List<String>> getResourceNames(String path){\r\n    if (Pointer.nativeValue(type) <= 65535) {\r\n        types.add(Pointer.nativeValue(type) + \"\");\r\n    } else {\r\n        types.add(type.getWideString(0));\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.jna.platform.win32.Kernel32Util.getResourceNames",
	"Comment": "gets a list of all resources from the specified executable file",
	"Method": "Map<String, List<String>> getResourceNames(String path){\r\n    String typeName = \"\";\r\n    if (Pointer.nativeValue(type) <= 65535) {\r\n        typeName = Pointer.nativeValue(type) + \"\";\r\n    } else {\r\n        typeName = type.getWideString(0);\r\n    }\r\n    if (Pointer.nativeValue(name) < 65535) {\r\n        result.get(typeName).add(Pointer.nativeValue(name) + \"\");\r\n    } else {\r\n        result.get(typeName).add(name.getWideString(0));\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jsoup.nodes.Element.insertChildren",
	"Comment": "inserts the given child nodes into this element at the specified index. current nodes will be shifted to theright. the inserted nodes will be moved from their current parent. to prevent moving, copy the nodes first.",
	"Method": "Element insertChildren(int index,Collection<? extends Node> children,Element insertChildren,int index,Node children){\r\n    Validate.notNull(children, \"Children collection to be inserted must not be null.\");\r\n    int currentSize = childNodeSize();\r\n    if (index < 0)\r\n        index += currentSize + 1;\r\n    Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\r\n    addChildren(index, children);\r\n    return this;\r\n}"
}, {
	"Path": "com.mikepenz.materialdrawer.MiniDrawer.onItemClick",
	"Comment": "call this method to trigger the onitemclick on the minidrawer",
	"Method": "boolean onItemClick(IDrawerItem selectedDrawerItem,boolean onItemClick,View view,int position,IDrawerItem drawerItem,int type){\r\n    if (selectedDrawerItem.isSelectable()) {\r\n        if (mCrossFader != null) {\r\n            if (mCrossFader.isCrossfaded()) {\r\n                mCrossFader.crossfade();\r\n            }\r\n        }\r\n        setSelection(selectedDrawerItem.getIdentifier());\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener.isPressed",
	"Comment": "returns true if a touch is over the actor or within the tap square.",
	"Method": "boolean isPressed(){\r\n    return pressed;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ByteArray.removeAll",
	"Comment": "removes from this array all of elements contained in the specified array.",
	"Method": "boolean removeAll(ByteArray array){\r\n    int size = this.size;\r\n    int startSize = size;\r\n    byte[] items = this.items;\r\n    for (int i = 0, n = array.size; i < n; i++) {\r\n        int item = array.get(i);\r\n        for (int ii = 0; ii < size; ii++) {\r\n            if (item == items[ii]) {\r\n                removeIndex(ii);\r\n                size--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return size != startSize;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.TextureAtlas.createSprites",
	"Comment": "returns all regions in the atlas as sprites. this method creates a new sprite for each region, so the result should be\tstored rather than calling this method multiple times.",
	"Method": "Array<Sprite> createSprites(Array<Sprite> createSprites,String name){\r\n    Array<Sprite> matched = new Array(Sprite.class);\r\n    for (int i = 0, n = regions.size; i < n; i++) {\r\n        AtlasRegion region = regions.get(i);\r\n        if (region.name.equals(name))\r\n            matched.add(newSprite(region));\r\n    }\r\n    return matched;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.utils.AnimationController.queue",
	"Comment": "queue an animation to be applied when the current is finished. if current is continuous it will be synced on next loop.",
	"Method": "AnimationDesc queue(String id,int loopCount,float speed,AnimationListener listener,float transitionTime,AnimationDesc queue,String id,float offset,float duration,int loopCount,float speed,AnimationListener listener,float transitionTime,AnimationDesc queue,Animation anim,float offset,float duration,int loopCount,float speed,AnimationListener listener,float transitionTime,AnimationDesc queue,AnimationDesc anim,float transitionTime){\r\n    if (current == null || current.loopCount == 0)\r\n        animate(anim, transitionTime);\r\n    else {\r\n        if (queued != null)\r\n            animationPool.free(queued);\r\n        queued = anim;\r\n        queuedTransitionTime = transitionTime;\r\n        if (current.loopCount < 0)\r\n            current.loopCount = 1;\r\n    }\r\n    return anim;\r\n}"
}, {
	"Path": "com.badlogic.gdx.physics.bullet.collision.btDbvtNode.obtainForArgument",
	"Comment": "obtains a temporary instance, used for callback methods with one or more btdbvtnode arguments",
	"Method": "btDbvtNode obtainForArgument(long swigCPtr,boolean owner){\r\n    btDbvtNode instance = argumentInstances[argumentIndex = (argumentIndex + 1) & 3];\r\n    instance.reset(swigCPtr, owner);\r\n    return instance;\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.android.AndroidLiveWallpaperService.onCreateEngine",
	"Comment": "one of wallpaper engines is starting. do not override this method, service manages them internally.",
	"Method": "Engine onCreateEngine(){\r\n    if (DEBUG)\r\n        Log.d(TAG, \" > AndroidLiveWallpaperService - onCreateEngine()\");\r\n    Log.i(TAG, \"engine created\");\r\n    return new AndroidWallpaperEngine();\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.getTotalPaddingLeft",
	"Comment": "returns the total left padding of the view, including the leftdrawable if any.",
	"Method": "int getTotalPaddingLeft(){\r\n    return getPaddingLeft() + mInputView.getTotalPaddingLeft();\r\n}"
}, {
	"Path": "com.rey.material.widget.EditText.setSelectAllOnFocus",
	"Comment": "set the textview so that when it takes focus, all the text isselected.",
	"Method": "void setSelectAllOnFocus(boolean selectAllOnFocus){\r\n    mInputView.setSelectAllOnFocus(selectAllOnFocus);\r\n}"
}, {
	"Path": "com.sun.jna.Memory.setShort",
	"Comment": "indirect the native pointer to malloc space, a lapointer.setshort.but this method performs a boundschecks to ensure that the indirection does not cause memory outside themalloced space to be accessed.",
	"Method": "void setShort(long offset,short value){\r\n    boundsCheck(offset, 2);\r\n    super.setShort(offset, value);\r\n}"
}, {
	"Path": "lombok.javac.handlers.HandleConstructor.fieldsNeedingExplicitDefaults",
	"Comment": "return each field which is final and has no initializer, and which is not already a parameter.",
	"Method": "List<JavacNode> fieldsNeedingExplicitDefaults(JavacNode typeNode,List<JavacNode> fieldsToParam){\r\n    ListBuffer<JavacNode> out = new ListBuffer<JavacNode>();\r\n    top: for (JavacNode node : typeNode.down()) {\r\n        if (node.getKind() != Kind.FIELD)\r\n            continue top;\r\n        JCVariableDecl varDecl = (JCVariableDecl) node.get();\r\n        if (varDecl.init != null)\r\n            continue top;\r\n        if ((varDecl.mods.flags & Flags.FINAL) == 0)\r\n            continue top;\r\n        if ((varDecl.mods.flags & Flags.STATIC) != 0)\r\n            continue top;\r\n        for (JavacNode ftp : fieldsToParam) if (node == ftp)\r\n            continue top;\r\n        if (JavacHandlerUtil.hasAnnotation(Builder.Default.class, node))\r\n            continue top;\r\n        out.append(node);\r\n    }\r\n    return out.toList();\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.reflect.Method.isAnnotationPresent",
	"Comment": "returns true if the method includes an annotation of the provided class type.",
	"Method": "boolean isAnnotationPresent(Class<? extends java.lang.annotation.Annotation> annotationType){\r\n    return method.isAnnotationPresent(annotationType);\r\n}"
}, {
	"Path": "org.jbox2d.collision.Collision.getPointStates",
	"Comment": "compute the point states given two manifolds. the states pertain to the transition frommanifold1 to manifold2. so state1 is either persist or remove while state2 is either add orpersist.",
	"Method": "void getPointStates(PointState[] state1,PointState[] state2,Manifold manifold1,Manifold manifold2){\r\n    for (int i = 0; i < Settings.maxManifoldPoints; i++) {\r\n        state1[i] = PointState.NULL_STATE;\r\n        state2[i] = PointState.NULL_STATE;\r\n    }\r\n    for (int i = 0; i < manifold1.pointCount; i++) {\r\n        ContactID id = manifold1.points[i].id;\r\n        state1[i] = PointState.REMOVE_STATE;\r\n        for (int j = 0; j < manifold2.pointCount; j++) {\r\n            if (manifold2.points[j].id.isEqual(id)) {\r\n                state1[i] = PointState.PERSIST_STATE;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < manifold2.pointCount; i++) {\r\n        ContactID id = manifold2.points[i].id;\r\n        state2[i] = PointState.ADD_STATE;\r\n        for (int j = 0; j < manifold1.pointCount; j++) {\r\n            if (manifold1.points[j].id.isEqual(id)) {\r\n                state2[i] = PointState.PERSIST_STATE;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio.forget",
	"Comment": "removes the disposed sound from the least recently played list",
	"Method": "void forget(OpenALSound sound){\r\n    for (int i = 0; i < recentSounds.length; i++) {\r\n        if (recentSounds[i] == sound)\r\n            recentSounds[i] = null;\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.SharedLibraryLoader.extractFileTo",
	"Comment": "extracts the specified file into the temp directory if it does not already exist or the crc does not match. if file\textraction fails and the file exists at java.library.path, that file is returned.",
	"Method": "void extractFileTo(String sourcePath,File dir){\r\n    extractFile(sourcePath, crc(readFile(sourcePath)), new File(dir, new File(sourcePath).getName()));\r\n}"
}, {
	"Path": "java.nio.FloatBuffer.toString",
	"Comment": "returns a string representing the state of this float buffer.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(getClass().getName());\r\n    sb.append(\", status: capacity=\");\r\n    sb.append(capacity());\r\n    sb.append(\" position=\");\r\n    sb.append(position());\r\n    sb.append(\" limit=\");\r\n    sb.append(limit());\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.NinePatch.setPadding",
	"Comment": "set the padding for content inside this ninepatch. by default the padding is set to match the exterior of the ninepatch, so\tthe content should fit exactly within the middle patch.",
	"Method": "void setPadding(float left,float right,float top,float bottom){\r\n    this.padLeft = left;\r\n    this.padRight = right;\r\n    this.padTop = top;\r\n    this.padBottom = bottom;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController.applyAnimations",
	"Comment": "apply two animations, blending the second onto to first using weight.",
	"Method": "void applyAnimations(Animation anim1,float time1,Animation anim2,float time2,float weight){\r\n    if (anim2 == null || weight == 0.f)\r\n        applyAnimation(anim1, time1);\r\n    else if (anim1 == null || weight == 1.f)\r\n        applyAnimation(anim2, time2);\r\n    else if (applying)\r\n        throw new GdxRuntimeException(\"Call end() first\");\r\n    else {\r\n        begin();\r\n        apply(anim1, time1, 1.f);\r\n        apply(anim2, time2, weight);\r\n        end();\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ArrayMap.getKey",
	"Comment": "returns the key for the specified value. note this does a comparison of each value in reverse order until the specified\tvalue is found.",
	"Method": "K getKey(V value,boolean identity){\r\n    Object[] values = this.values;\r\n    int i = size - 1;\r\n    if (identity || value == null) {\r\n        for (; i >= 0; i--) if (values[i] == value)\r\n            return keys[i];\r\n    } else {\r\n        for (; i >= 0; i--) if (value.equals(values[i]))\r\n            return keys[i];\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jbox2d.collision.shapes.Shape.setRadius",
	"Comment": "sets the radius of the underlying shape. this can refer to different things depending on theimplementation",
	"Method": "void setRadius(float radius){\r\n    this.m_radius = radius;\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.ShortArray.random",
	"Comment": "returns a random item from the array, or zero if the array is empty.",
	"Method": "short random(){\r\n    if (size == 0)\r\n        return 0;\r\n    return items[MathUtils.random(0, size - 1)];\r\n}"
}, {
	"Path": "org.jsoup.internal.StringUtil.isNumeric",
	"Comment": "tests if a string is numeric, i.e. contains only digit characters",
	"Method": "boolean isNumeric(String string){\r\n    if (string == null || string.length() == 0)\r\n        return false;\r\n    int l = string.length();\r\n    for (int i = 0; i < l; i++) {\r\n        if (!Character.isDigit(string.codePointAt(i)))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.squareup.leakcanary.AbstractAnalysisResultService.onAnalysisResultFailure",
	"Comment": "called when there was an error saving or loading the analysis result. this will be called froma background intent service thread.",
	"Method": "void onAnalysisResultFailure(String failureMessage){\r\n    CanaryLog.d(failureMessage);\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.Sprite.translateY",
	"Comment": "sets the y position relative to the current position where the sprite will be drawn. if origin, rotation, or scale are\tchanged, it is slightly more efficient to translate after those operations.",
	"Method": "void translateY(float yAmount){\r\n    y += yAmount;\r\n    if (dirty)\r\n        return;\r\n    float[] vertices = this.vertices;\r\n    vertices[Y1] += yAmount;\r\n    vertices[Y2] += yAmount;\r\n    vertices[Y3] += yAmount;\r\n    vertices[Y4] += yAmount;\r\n}"
}, {
	"Path": "com.badlogic.gdx.graphics.g2d.Sprite.translateX",
	"Comment": "sets the x position relative to the current position where the sprite will be drawn. if origin, rotation, or scale are\tchanged, it is slightly more efficient to translate after those operations.",
	"Method": "void translateX(float xAmount){\r\n    this.x += xAmount;\r\n    if (dirty)\r\n        return;\r\n    float[] vertices = this.vertices;\r\n    vertices[X1] += xAmount;\r\n    vertices[X2] += xAmount;\r\n    vertices[X3] += xAmount;\r\n    vertices[X4] += xAmount;\r\n}"
}, {
	"Path": "com.squareup.leakcanary.RefWatcherBuilder.computeRetainedHeapSize",
	"Comment": "whether leakcanary should compute the retained heap size when a leak is detected. false bydefault, because computing the retained heap size takes a long time.",
	"Method": "T computeRetainedHeapSize(boolean computeRetainedHeapSize){\r\n    heapDumpBuilder.computeRetainedHeapSize(computeRetainedHeapSize);\r\n    return self();\r\n}"
}, {
	"Path": "lombok.core.AnnotationValues.of",
	"Comment": "creates a new annotation wrapper with all default values, and using the provided ast as lookup anchor for\tclass literals.",
	"Method": "AnnotationValues<A> of(Class<A> type,AnnotationValues<A> of,Class<A> type,LombokNode<?, ?, ?> ast){\r\n    return new AnnotationValues<A>(type, Collections.<String, AnnotationValue>emptyMap(), ast);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.IntArray.removeAll",
	"Comment": "removes from this array all of elements contained in the specified array.",
	"Method": "boolean removeAll(IntArray array){\r\n    int size = this.size;\r\n    int startSize = size;\r\n    int[] items = this.items;\r\n    for (int i = 0, n = array.size; i < n; i++) {\r\n        int item = array.get(i);\r\n        for (int ii = 0; ii < size; ii++) {\r\n            if (item == items[ii]) {\r\n                removeIndex(ii);\r\n                size--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return size != startSize;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.setParticleGravityScale",
	"Comment": "change the particle gravity scale. adjusts the effect of the global gravity vector onparticles. default value is 1.0f.",
	"Method": "void setParticleGravityScale(float gravityScale){\r\n    m_particleSystem.setParticleGravityScale(gravityScale);\r\n}"
}]