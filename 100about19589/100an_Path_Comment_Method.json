[{
	"Path": "com.github.mikephil.charting.components.Legend.isDrawInsideEnabled",
	"Comment": "returns whether the legend will draw inside the chart or outside",
	"Method": "boolean isDrawInsideEnabled(){\r\n    return mDrawInside;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.PieDataSet.isUsingSliceColorAsValueLineColor",
	"Comment": "when valueposition is outsideslice, use slice colors as line color if true",
	"Method": "boolean isUsingSliceColorAsValueLineColor(){\r\n    return mUsingSliceColorAsValueLineColor;\r\n}"
}, {
	"Path": "com.squareup.moshi.LinkedHashTreeMap.find",
	"Comment": "returns the node at or adjacent to the given key, creating it if requested.",
	"Method": "Node<K, V> find(K key,boolean create){\r\n    Comparator<? super K> comparator = this.comparator;\r\n    Node<K, V>[] table = this.table;\r\n    int hash = secondaryHash(key.hashCode());\r\n    int index = hash & (table.length - 1);\r\n    Node<K, V> nearest = table[index];\r\n    int comparison = 0;\r\n    if (nearest != null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Comparable<Object> comparableKey = (comparator == NATURAL_ORDER) ? (Comparable<Object>) key : null;\r\n        while (true) {\r\n            comparison = (comparableKey != null) ? comparableKey.compareTo(nearest.key) : comparator.compare(key, nearest.key);\r\n            if (comparison == 0) {\r\n                return nearest;\r\n            }\r\n            Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\r\n            if (child == null) {\r\n                break;\r\n            }\r\n            nearest = child;\r\n        }\r\n    }\r\n    if (!create) {\r\n        return null;\r\n    }\r\n    Node<K, V> header = this.header;\r\n    Node<K, V> created;\r\n    if (nearest == null) {\r\n        if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\r\n            throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\r\n        }\r\n        created = new Node(nearest, key, hash, header, header.prev);\r\n        table[index] = created;\r\n    } else {\r\n        created = new Node(nearest, key, hash, header, header.prev);\r\n        if (comparison < 0) {\r\n            nearest.left = created;\r\n        } else {\r\n            nearest.right = created;\r\n        }\r\n        rebalance(nearest, true);\r\n    }\r\n    if (size++ > threshold) {\r\n        doubleCapacity();\r\n    }\r\n    modCount++;\r\n    return created;\r\n}"
}, {
	"Path": "com.google.refine.clustering.binning.Metaphone3.StringAt",
	"Comment": "determines if one of the substrings sent in is the same as\twhat is at the specified position in the string being encoded.",
	"Method": "boolean StringAt(int start,int length,String compareStrings){\r\n    if ((start < 0) || (start > (m_length - 1)) || ((start + length - 1) > (m_length - 1))) {\r\n        return false;\r\n    }\r\n    String target = m_inWord.substring(start, (start + length));\r\n    for (String strFragment : compareStrings) {\r\n        if (target.equals(strFragment)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.google.refine.ProjectManager.getProject",
	"Comment": "gets the required project from the data storeif project does not already exist in memory, it is loaded from the data store",
	"Method": "Project getProject(long id){\r\n    synchronized (this) {\r\n        if (_projects.containsKey(id)) {\r\n            return _projects.get(id);\r\n        } else {\r\n            Project project = loadProject(id);\r\n            if (project != null) {\r\n                _projects.put(id, project);\r\n            }\r\n            return project;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.io.ResolverUtil.addIfMatching",
	"Comment": "add the class designated by the fully qualified class name provided to the set ofresolved classes if and only if it is approved by the test supplied.",
	"Method": "void addIfMatching(Test test,String fqn){\r\n    try {\r\n        String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');\r\n        ClassLoader loader = getClassLoader();\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Checking to see if class \" + externalName + \" matches criteria [\" + test + \"]\");\r\n        }\r\n        Class<?> type = loader.loadClass(externalName);\r\n        if (test.matches(type)) {\r\n            matches.add((Class<T>) type);\r\n        }\r\n    } catch (Throwable t) {\r\n        log.warn(\"Could not examine class '\" + fqn + \"'\" + \" due to a \" + t.getClass().getName() + \" with message: \" + t.getMessage());\r\n    }\r\n}"
}, {
	"Path": "okhttp3.mockwebserver.MockWebServer.takeRequest",
	"Comment": "awaits the next http request, removes it, and returns it. callers should use this to verify therequest was sent as intended. this method will block until the request is available, possiblyforever.",
	"Method": "RecordedRequest takeRequest(RecordedRequest takeRequest,long timeout,TimeUnit unit){\r\n    return requestQueue.poll(timeout, unit);\r\n}"
}, {
	"Path": "com.google.refine.model.Project.getProcessManager",
	"Comment": "todo make the processmanager variable private, and force all calls through this method",
	"Method": "ProcessManager getProcessManager(){\r\n    return this.processManager;\r\n}"
}, {
	"Path": "okhttp3.android.HttpResponseCacheTest.openUrl",
	"Comment": "this mimics the android httphandler, which is found in the okhttp3 package.",
	"Method": "URLConnection openUrl(HttpUrl url){\r\n    ResponseCache responseCache = ResponseCache.getDefault();\r\n    AndroidInternal.setResponseCache(urlFactory, responseCache);\r\n    return urlFactory.open(url.url());\r\n}"
}, {
	"Path": "com.github.mikephil.charting.highlight.BarHighlighter.getStackedHighlight",
	"Comment": "this method creates the highlight object that also indicates which value of a stacked barentry has beenselected.",
	"Method": "Highlight getStackedHighlight(Highlight high,IBarDataSet set,float xVal,float yVal){\r\n    BarEntry entry = set.getEntryForXValue(xVal, yVal);\r\n    if (entry == null)\r\n        return null;\r\n    if (entry.getYVals() == null) {\r\n        return high;\r\n    } else {\r\n        Range[] ranges = entry.getRanges();\r\n        if (ranges.length > 0) {\r\n            int stackIndex = getClosestStackIndex(ranges, yVal);\r\n            MPPointD pixels = mChart.getTransformer(set.getAxisDependency()).getPixelForValues(high.getX(), ranges[stackIndex].to);\r\n            Highlight stackedHigh = new Highlight(entry.getX(), entry.getY(), (float) pixels.x, (float) pixels.y, high.getDataSetIndex(), stackIndex, high.getAxis());\r\n            MPPointD.recycleInstance(pixels);\r\n            return stackedHigh;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarChart.setDrawValueAboveBar",
	"Comment": "if set to true, all values are drawn above their bars, instead of below their top.",
	"Method": "void setDrawValueAboveBar(boolean enabled){\r\n    mDrawValueAboveBar = enabled;\r\n}"
}, {
	"Path": "org.mockito.internal.util.concurrent.WeakConcurrentMap.approximateSize",
	"Comment": "returns the approximate size of this map where the returned number is at least as big as the actual number of entries.",
	"Method": "int approximateSize(int approximateSize){\r\n    return target.size();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.PieDataSet.getValueLinePart1OffsetPercentage",
	"Comment": "when valueposition is outsideslice, indicates offset as percentage out of the slice size",
	"Method": "float getValueLinePart1OffsetPercentage(){\r\n    return mValueLinePart1OffsetPercentage;\r\n}"
}, {
	"Path": "okhttp3.internal.http2.FrameLogTest.allFormattedFlagsWithValidBits",
	"Comment": "ensures that valid flag combinations appear visually correct, and invalid show in hex.thisalso demonstrates how sparse the lookup table is.",
	"Method": "void allFormattedFlagsWithValidBits(){\r\n    List<String> formattedFlags = new ArrayList(0x40);\r\n    for (byte i = 0; i < 0x40; i++) formattedFlags.add(Http2.formatFlags(TYPE_HEADERS, i));\r\n    assertEquals(Arrays.asList(\"\", \"END_STREAM\", \"00000010\", \"00000011\", \"END_HEADERS\", \"END_STREAM|END_HEADERS\", \"00000110\", \"00000111\", \"PADDED\", \"END_STREAM|PADDED\", \"00001010\", \"00001011\", \"00001100\", \"END_STREAM|END_HEADERS|PADDED\", \"00001110\", \"00001111\", \"00010000\", \"00010001\", \"00010010\", \"00010011\", \"00010100\", \"00010101\", \"00010110\", \"00010111\", \"00011000\", \"00011001\", \"00011010\", \"00011011\", \"00011100\", \"00011101\", \"00011110\", \"00011111\", \"PRIORITY\", \"END_STREAM|PRIORITY\", \"00100010\", \"00100011\", \"END_HEADERS|PRIORITY\", \"END_STREAM|END_HEADERS|PRIORITY\", \"00100110\", \"00100111\", \"00101000\", \"END_STREAM|PRIORITY|PADDED\", \"00101010\", \"00101011\", \"00101100\", \"END_STREAM|END_HEADERS|PRIORITY|PADDED\", \"00101110\", \"00101111\", \"00110000\", \"00110001\", \"00110010\", \"00110011\", \"00110100\", \"00110101\", \"00110110\", \"00110111\", \"00111000\", \"00111001\", \"00111010\", \"00111011\", \"00111100\", \"00111101\", \"00111110\", \"00111111\"), formattedFlags);\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.date.NowTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "org.mockito.internal.util.reflection.InstanceField.annotation",
	"Comment": "returns the annotation instance for the given annotation type.",
	"Method": "A annotation(Class<A> annotationClass){\r\n    return field.getAnnotation(annotationClass);\r\n}"
}, {
	"Path": "okhttp3.internal.connection.RealConnection.createTunnel",
	"Comment": "to make an https connection over an http proxy, send an unencrypted connect request to createthe proxy connection. this may need to be retried if the proxy requires authorization.",
	"Method": "Request createTunnel(int readTimeout,int writeTimeout,Request tunnelRequest,HttpUrl url){\r\n    String requestLine = \"CONNECT \" + Util.hostHeader(url, true) + \" HTTP/1.1\";\r\n    while (true) {\r\n        Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink);\r\n        source.timeout().timeout(readTimeout, MILLISECONDS);\r\n        sink.timeout().timeout(writeTimeout, MILLISECONDS);\r\n        tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);\r\n        tunnelConnection.finishRequest();\r\n        Response response = tunnelConnection.readResponseHeaders(false).request(tunnelRequest).build();\r\n        long contentLength = HttpHeaders.contentLength(response);\r\n        if (contentLength == -1L) {\r\n            contentLength = 0L;\r\n        }\r\n        Source body = tunnelConnection.newFixedLengthSource(contentLength);\r\n        Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);\r\n        body.close();\r\n        switch(response.code()) {\r\n            case HTTP_OK:\r\n                if (!source.buffer().exhausted() || !sink.buffer().exhausted()) {\r\n                    throw new IOException(\"TLS tunnel buffered too many bytes!\");\r\n                }\r\n                return null;\r\n            case HTTP_PROXY_AUTH:\r\n                tunnelRequest = route.address().proxyAuthenticator().authenticate(route, response);\r\n                if (tunnelRequest == null)\r\n                    throw new IOException(\"Failed to authenticate with proxy\");\r\n                if (\"close\".equalsIgnoreCase(response.header(\"Connection\"))) {\r\n                    return tunnelRequest;\r\n                }\r\n                break;\r\n            default:\r\n                throw new IOException(\"Unexpected response code for CONNECT: \" + response.code());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.DataSet.toSimpleString",
	"Comment": "returns a simple string representation of the dataset with the type andthe number of entries.",
	"Method": "String toSimpleString(){\r\n    StringBuffer buffer = new StringBuffer();\r\n    buffer.append(\"DataSet, label: \" + (getLabel() == null ? \"\" : getLabel()) + \", entries: \" + mValues.size() + \"\\n\");\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "org.openrefine.wikidata.updates.ItemUpdateBuilder.addDescription",
	"Comment": "adds a description to the item. it will override any existing description inthis language.",
	"Method": "ItemUpdateBuilder addDescription(MonolingualTextValue description){\r\n    Validate.isTrue(!built, \"ItemUpdate has already been built\");\r\n    descriptions.add(description);\r\n    return this;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.AxisBase.setDrawGridLines",
	"Comment": "set this to true to enable drawing the grid lines for this axis.",
	"Method": "void setDrawGridLines(boolean enabled){\r\n    mDrawGridLines = enabled;\r\n}"
}, {
	"Path": "org.openrefine.wikidata.schema.WbStringVariableTest.testDoubleInteger",
	"Comment": "test that floating point numbers with no decimal part are also converted",
	"Method": "void testDoubleInteger(){\r\n    evaluatesTo(Datamodel.makeStringValue(\"45\"), new Cell(45.0, null));\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.common.util.apache.IntHashMap.get",
	"Comment": "returns the value to which the specified key is mapped in this map.",
	"Method": "T get(int key){\r\n    Entry<T>[] tab = table;\r\n    int hash = key;\r\n    int index = (hash & 0x7FFFFFFF) % tab.length;\r\n    for (Entry<T> e = tab[index]; e != null; e = e.next) {\r\n        if (e.hash == hash) {\r\n            return e.value;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "okhttp3.mockwebserver.Dispatcher.peek",
	"Comment": "returns an early guess of the next response, used for policy on how an incoming request shouldbe received. the default implementation returns an empty response. mischievous implementationscan return other values to test http edge cases, such as unhappy socket policies or throttledrequest bodies.",
	"Method": "MockResponse peek(){\r\n    return new MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.Legend.setXEntrySpace",
	"Comment": "sets the space between the legend entries on a horizontal axis in pixels,converts to dp internally",
	"Method": "void setXEntrySpace(float space){\r\n    mXEntrySpace = space;\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testCallWithResultSet1Annotated",
	"Comment": "this test shows how to use an input parameter and return a result set froma stored procedure.this test shows using a single value parameter.this test shows using annotations for stored procedures",
	"Method": "void testCallWithResultSet1Annotated(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        Name name = spMapper.getNameAnnotated(1);\r\n        assertNotNull(name);\r\n        assertEquals(\"Wilma\", name.getFirstName());\r\n    }\r\n}"
}, {
	"Path": "com.squareup.moshi.adapters.Iso8601Utils.indexOfNonDigit",
	"Comment": "returns the index of the first character in the string that is not a digit, starting atoffset.",
	"Method": "int indexOfNonDigit(String string,int offset){\r\n    for (int i = offset; i < string.length(); i++) {\r\n        char c = string.charAt(i);\r\n        if (c < '0' || c > '9')\r\n            return i;\r\n    }\r\n    return string.length();\r\n}"
}, {
	"Path": "okhttp3.Address.hostnameVerifier",
	"Comment": "returns the hostname verifier, or null if this is not an https address.",
	"Method": "HostnameVerifier hostnameVerifier(){\r\n    return hostnameVerifier;\r\n}"
}, {
	"Path": "okhttp3.mockwebserver.RecordedRequest.getHandshake",
	"Comment": "returns the tls handshake of the connection that carried this request, or null if the requestwas received without tls.",
	"Method": "Handshake getHandshake(){\r\n    return handshake;\r\n}"
}, {
	"Path": "okhttp3.URLConnectionTest.gzipEncodingEnabledByDefault",
	"Comment": "this test checks whether connections are gzipped by default. this behavior in not required bythe api, so a failure of this test does not imply a bug in the implementation.",
	"Method": "void gzipEncodingEnabledByDefault(){\r\n    server.enqueue(new MockResponse().setBody(gzip(\"ABCABCABC\")).addHeader(\"Content-Encoding: gzip\"));\r\n    URLConnection connection = urlFactory.open(server.url(\"/\").url());\r\n    assertEquals(\"ABCABCABC\", readAscii(connection.getInputStream(), Integer.MAX_VALUE));\r\n    assertNull(connection.getContentEncoding());\r\n    assertEquals(-1, connection.getContentLength());\r\n    RecordedRequest request = server.takeRequest();\r\n    assertEquals(\"gzip\", request.getHeader(\"Accept-Encoding\"));\r\n}"
}, {
	"Path": "okhttp3.internal.http2.HttpOverHttp2Test.settingsLimitsMaxConcurrentStreams",
	"Comment": "push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests andconfirm that the third concurrent request prepared a new connection.",
	"Method": "void settingsLimitsMaxConcurrentStreams(){\r\n    Settings settings = new Settings();\r\n    settings.set(Settings.MAX_CONCURRENT_STREAMS, 2);\r\n    server.enqueue(new MockResponse().withSettings(settings));\r\n    Call call = client.newCall(new Request.Builder().url(server.url(\"/\")).build());\r\n    Response response = call.execute();\r\n    assertEquals(\"\", response.body().string());\r\n    server.enqueue(new MockResponse().setBody(\"ABC\"));\r\n    server.enqueue(new MockResponse().setBody(\"DEF\"));\r\n    server.enqueue(new MockResponse().setBody(\"GHI\"));\r\n    Call call1 = client.newCall(new Request.Builder().url(server.url(\"/\")).build());\r\n    Response response1 = call1.execute();\r\n    Call call2 = client.newCall(new Request.Builder().url(server.url(\"/\")).build());\r\n    Response response2 = call2.execute();\r\n    Call call3 = client.newCall(new Request.Builder().url(server.url(\"/\")).build());\r\n    Response response3 = call3.execute();\r\n    assertEquals(\"ABC\", response1.body().string());\r\n    assertEquals(\"DEF\", response2.body().string());\r\n    assertEquals(\"GHI\", response3.body().string());\r\n    assertEquals(0, server.takeRequest().getSequenceNumber());\r\n    assertEquals(1, server.takeRequest().getSequenceNumber());\r\n    assertEquals(2, server.takeRequest().getSequenceNumber());\r\n    assertEquals(0, server.takeRequest().getSequenceNumber());\r\n}"
}, {
	"Path": "permissions.dispatcher.PermissionUtils.hasSelfPermissions",
	"Comment": "returns true if the activity or fragment has access to all given permissions.",
	"Method": "boolean hasSelfPermissions(Context context,String permissions){\r\n    for (String permission : permissions) {\r\n        if (permissionExists(permission) && !hasSelfPermission(context, permission)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.Legend.setFormLineWidth",
	"Comment": "sets the line width in dp for forms that consist of lines, default 3f",
	"Method": "void setFormLineWidth(float size){\r\n    mFormLineWidth = size;\r\n}"
}, {
	"Path": "okhttp3.internal.cache.CacheInterceptor.combine",
	"Comment": "combines cached headers with a network headers as defined by rfc 7234, 4.3.4.",
	"Method": "Headers combine(Headers cachedHeaders,Headers networkHeaders){\r\n    Headers.Builder result = new Headers.Builder();\r\n    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {\r\n        String fieldName = cachedHeaders.name(i);\r\n        String value = cachedHeaders.value(i);\r\n        if (\"Warning\".equalsIgnoreCase(fieldName) && value.startsWith(\"1\")) {\r\n            continue;\r\n        }\r\n        if (isContentSpecificHeader(fieldName) || !isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {\r\n            Internal.instance.addLenient(result, fieldName, value);\r\n        }\r\n    }\r\n    for (int i = 0, size = networkHeaders.size(); i < size; i++) {\r\n        String fieldName = networkHeaders.name(i);\r\n        if (!isContentSpecificHeader(fieldName) && isEndToEnd(fieldName)) {\r\n            Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));\r\n        }\r\n    }\r\n    return result.build();\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testCallWithResultSet3_a1",
	"Comment": "this test shows how to use a input and output parameters and return aresult set from a stored procedure.this test shows using a map parameter.this test shows using annotations for stored procedures",
	"Method": "void testCallWithResultSet3_a1(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        Map<String, Object> parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 2);\r\n        List<Name> names = spMapper.getNamesAnnotated(parms);\r\n        assertEquals(2, parms.get(\"totalRows\"));\r\n        assertEquals(2, names.size());\r\n        parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 3);\r\n        names = spMapper.getNamesAnnotated(parms);\r\n        assertEquals(1, names.size());\r\n        assertEquals(1, parms.get(\"totalRows\"));\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testCallWithResultSet3_a2",
	"Comment": "this test shows how to use a input and output parameters and return aresult set from a stored procedure.this test shows using a map parameter.this test shows using annotations for stored procedures and using aresultmap in xml",
	"Method": "void testCallWithResultSet3_a2(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        Map<String, Object> parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 2);\r\n        List<Name> names = spMapper.getNamesAnnotatedWithXMLResultMap(parms);\r\n        assertEquals(2, parms.get(\"totalRows\"));\r\n        assertEquals(2, names.size());\r\n        parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 3);\r\n        names = spMapper.getNamesAnnotatedWithXMLResultMap(parms);\r\n        assertEquals(1, names.size());\r\n        assertEquals(1, parms.get(\"totalRows\"));\r\n    }\r\n}"
}, {
	"Path": "org.openrefine.wikidata.qa.QAWarningStore.getWarnings",
	"Comment": "returns the list of aggregated warnings, ordered by decreasing severity",
	"Method": "List<QAWarning> getWarnings(){\r\n    List<QAWarning> result = new ArrayList(map.values());\r\n    Collections.sort(result);\r\n    return result;\r\n}"
}, {
	"Path": "com.squareup.moshi.adapters.Iso8601Utils.checkOffset",
	"Comment": "check if the expected character exist at the given offset in the value.",
	"Method": "boolean checkOffset(String value,int offset,char expected){\r\n    return (offset < value.length()) && (value.charAt(offset) == expected);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.Utils.getDecimals",
	"Comment": "returns the appropriate number of decimals to be used for the providednumber.",
	"Method": "int getDecimals(float number){\r\n    float i = roundToNextSignificant(number);\r\n    if (Float.isInfinite(i))\r\n        return 0;\r\n    return (int) Math.ceil(-Math.log10(i)) + 2;\r\n}"
}, {
	"Path": "com.google.refine.clustering.binning.Metaphone3.SkipVowels",
	"Comment": "skips over vowels in a string. has exceptions for skipping consonants that\twill not be encoded.",
	"Method": "int SkipVowels(int at){\r\n    if (at < 0) {\r\n        return 0;\r\n    }\r\n    if (at >= m_length) {\r\n        return m_length;\r\n    }\r\n    char it = CharAt(at);\r\n    while (IsVowel(it) || (it == 'W')) {\r\n        if (StringAt(at, 4, \"WICZ\", \"WITZ\", \"WIAK\", \"\") || StringAt((at - 1), 5, \"EWSKI\", \"EWSKY\", \"OWSKI\", \"OWSKY\", \"\") || (StringAt(at, 5, \"WICKI\", \"WACKI\", \"\") && ((at + 4) == m_last))) {\r\n            break;\r\n        }\r\n        at++;\r\n        if (((CharAt(at - 1) == 'W') && (CharAt(at) == 'H')) && !(StringAt(at, 3, \"HOP\", \"\") || StringAt(at, 4, \"HIDE\", \"HARD\", \"HEAD\", \"HAWK\", \"HERD\", \"HOOK\", \"HAND\", \"HOLE\", \"\") || StringAt(at, 5, \"HEART\", \"HOUSE\", \"HOUND\", \"\") || StringAt(at, 6, \"HAMMER\", \"\"))) {\r\n            at++;\r\n        }\r\n        if (at > (m_length - 1)) {\r\n            break;\r\n        }\r\n        it = CharAt(at);\r\n    }\r\n    return at;\r\n}"
}, {
	"Path": "org.apache.ibatis.datasource.pooled.PooledDataSource.setPoolPingConnectionsNotUsedFor",
	"Comment": "if a connection has not been used in this many milliseconds, ping thedatabase to make sure the connection is still good.",
	"Method": "void setPoolPingConnectionsNotUsedFor(int milliseconds){\r\n    this.poolPingConnectionsNotUsedFor = milliseconds;\r\n    forceCloseAll();\r\n}"
}, {
	"Path": "com.squareup.moshi.Moshi.newBuilder",
	"Comment": "returns a new builder containing all custom factories used by the current instance.",
	"Method": "Moshi.Builder newBuilder(){\r\n    int fullSize = factories.size();\r\n    int tailSize = BUILT_IN_FACTORIES.size();\r\n    List<JsonAdapter.Factory> customFactories = factories.subList(0, fullSize - tailSize);\r\n    return new Builder().addAll(customFactories);\r\n}"
}, {
	"Path": "org.mockito.internal.util.reflection.Fields.declaredFieldsOf",
	"Comment": "instance fields declared in the class of the given instance.",
	"Method": "InstanceFields declaredFieldsOf(Object instance){\r\n    List<InstanceField> instanceFields = new ArrayList<InstanceField>();\r\n    instanceFields.addAll(instanceFieldsIn(instance, instance.getClass().getDeclaredFields()));\r\n    return new InstanceFields(instance, instanceFields);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.isDragYEnabled",
	"Comment": "returns true if dragging on the y axis is enabled for the chart, false if not.",
	"Method": "boolean isDragYEnabled(){\r\n    return mDragYEnabled;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.ChartData.getDataSetForEntry",
	"Comment": "returns the dataset that contains the provided entry, or null, if nodataset contains this entry.",
	"Method": "T getDataSetForEntry(Entry e){\r\n    if (e == null)\r\n        return null;\r\n    for (int i = 0; i < mDataSets.size(); i++) {\r\n        T set = mDataSets.get(i);\r\n        for (int j = 0; j < set.getEntryCount(); j++) {\r\n            if (e.equalTo(set.getEntryForXValue(e.getX(), e.getY())))\r\n                return set;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openrefine.wikidata.updates.ItemUpdateBuilder.addAliases",
	"Comment": "adds a list of aliases to the item. they will be added to any existingaliases in each language.",
	"Method": "ItemUpdateBuilder addAliases(Set<MonolingualTextValue> aliases){\r\n    Validate.isTrue(!built, \"ItemUpdate has already been built\");\r\n    this.aliases.addAll(aliases);\r\n    return this;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.ChartData.setValueFormatter",
	"Comment": "sets a custom ivalueformatter for all datasets this data object contains.",
	"Method": "void setValueFormatter(ValueFormatter f){\r\n    if (f == null)\r\n        return;\r\n    else {\r\n        for (IDataSet set : mDataSets) {\r\n            set.setValueFormatter(f);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mockito.internal.runners.RunnerFactory.create",
	"Comment": "creates runner implementation with provided listener supplier",
	"Method": "InternalRunner create(Class<?> klass,InternalRunner create,Class<?> klass,Supplier<MockitoTestListener> listenerSupplier){\r\n    try {\r\n        String runnerClassName = \"org.mockito.internal.runners.DefaultInternalRunner\";\r\n        return new RunnerProvider().newInstance(runnerClassName, klass, listenerSupplier);\r\n    } catch (InvocationTargetException e) {\r\n        if (!hasTestMethods(klass)) {\r\n            throw new MockitoException(\"\\n\" + \"\\n\" + \"No tests found in \" + klass.getSimpleName() + \"\\n\" + \"Is the method annotated with @Test?\\n\" + \"Is the method public?\\n\", e);\r\n        }\r\n        throw e;\r\n    } catch (Throwable t) {\r\n        throw new MockitoException(\"\\n\" + \"\\n\" + \"MockitoRunner can only be used with JUnit 4.5 or higher.\\n\" + \"You can upgrade your JUnit version or write your own Runner (please consider contributing your runner to the Mockito community).\\n\" + \"Bear in mind that you can still enjoy all features of the framework without using runners (they are completely optional).\\n\" + \"If you get this error despite using JUnit 4.5 or higher then please report this error to the mockito mailing list.\\n\", t);\r\n    }\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvi.layout.MviRelativeLayout.getMvpDelegate",
	"Comment": "get the mvp delegate. this is internally used for creating presenter, attaching and detachingview from presenter etc.please note that only one instance of mvp delegate should be used per android.view.viewinstance.only override this method if you really know what you are doing.",
	"Method": "ViewGroupMviDelegate<V, P> getMvpDelegate(){\r\n    if (mvpDelegate == null) {\r\n        mvpDelegate = new ViewGroupMviDelegateImpl<V, P>(this, this, true);\r\n    }\r\n    return mvpDelegate;\r\n}"
}, {
	"Path": "org.mockito.internal.junit.UniversalTestListener.setListenerDirty",
	"Comment": "marks listener as dirty, scheduled for cleanup when the next session starts",
	"Method": "void setListenerDirty(){\r\n    this.listenerDirty = true;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.Transformer.generateTransformedValuesBubble",
	"Comment": "transforms an list of entry into a float array containing the x andy values transformed with all matrices for the bubblechart.",
	"Method": "float[] generateTransformedValuesBubble(IBubbleDataSet data,float phaseY,int from,int to){\r\n    final int count = (to - from + 1) * 2;\r\n    if (valuePointsForGenerateTransformedValuesBubble.length != count) {\r\n        valuePointsForGenerateTransformedValuesBubble = new float[count];\r\n    }\r\n    float[] valuePoints = valuePointsForGenerateTransformedValuesBubble;\r\n    for (int j = 0; j < count; j += 2) {\r\n        Entry e = data.getEntryForIndex(j / 2 + from);\r\n        if (e != null) {\r\n            valuePoints[j] = e.getX();\r\n            valuePoints[j + 1] = e.getY() * phaseY;\r\n        } else {\r\n            valuePoints[j] = 0;\r\n            valuePoints[j + 1] = 0;\r\n        }\r\n    }\r\n    getValueToPixelMatrix().mapPoints(valuePoints);\r\n    return valuePoints;\r\n}"
}, {
	"Path": "org.apache.ibatis.io.ResolverUtil.setClassLoader",
	"Comment": "sets an explicit classloader that should be used when scanning for classes. if noneis set then the context classloader will be used.",
	"Method": "void setClassLoader(ClassLoader classloader){\r\n    this.classloader = classloader;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.BaseDataSet.notifyDataSetChanged",
	"Comment": "use this method to tell the data set that the underlying data has changed.",
	"Method": "void notifyDataSetChanged(){\r\n    calcMinMax();\r\n}"
}, {
	"Path": "okhttp3.Address.dns",
	"Comment": "returns the service that will be used to resolve ip addresses for hostnames.",
	"Method": "Dns dns(){\r\n    return dns;\r\n}"
}, {
	"Path": "okhttp3.Cookie.httpOnly",
	"Comment": "returns true if this cookie should be limited to only http apis. in web browsers this preventsthe cookie from being accessible to scripts.",
	"Method": "boolean httpOnly(Builder httpOnly){\r\n    return httpOnly;\r\n}"
}, {
	"Path": "okhttp3.internal.http2.HpackDecodeTestBase.createStories",
	"Comment": "reads all stories in the folders provided, asserts if no story found.",
	"Method": "Collection<Story[]> createStories(String[] interopTests){\r\n    List<Story[]> result = new ArrayList();\r\n    for (String interopTestName : interopTests) {\r\n        List<Story> stories = HpackJsonUtil.readStories(interopTestName);\r\n        if (stories.isEmpty()) {\r\n            fail(\"No stories for: \" + interopTestName);\r\n        }\r\n        for (Story story : stories) {\r\n            result.add(new Story[] { story });\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.PieChart.getMinAngleForSlices",
	"Comment": "the minimum angle slices on the chart are rendered with, default is 0f.",
	"Method": "float getMinAngleForSlices(){\r\n    return mMinAngleForSlices;\r\n}"
}, {
	"Path": "org.openrefine.wikidata.updates.ItemUpdate.getAddedStatements",
	"Comment": "added statements are recorded as a list because their order of insertionmatters.",
	"Method": "List<Statement> getAddedStatements(){\r\n    return addedStatements;\r\n}"
}, {
	"Path": "org.apache.ibatis.datasource.pooled.PooledConnection.getCheckoutTimestamp",
	"Comment": "getter for the timestamp that this connection was checked out",
	"Method": "long getCheckoutTimestamp(){\r\n    return checkoutTimestamp;\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testCallLowHighWithResultSet",
	"Comment": "this test shows using a two named parameters.this test shows using annotations for stored procedures and using aresultmap in xml",
	"Method": "void testCallLowHighWithResultSet(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        List<Name> names = spMapper.getNamesAnnotatedLowHighWithXMLResultMap(1, 1);\r\n        assertEquals(1, names.size());\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.xml.ParseXmlTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.YAxis.setSpaceBottom",
	"Comment": "sets the bottom axis space in percent of the full range. default 10f",
	"Method": "void setSpaceBottom(float percent){\r\n    mSpacePercentBottom = percent;\r\n}"
}, {
	"Path": "okhttp3.URLConnectionTest.unexpectedExceptionAsync",
	"Comment": "confirm that runtime exceptions thrown inside of okhttp propagate to the caller.",
	"Method": "void unexpectedExceptionAsync(){\r\n    urlFactory.setClient(urlFactory.client().newBuilder().dns(new Dns() {\r\n        @Override\r\n        public List<InetAddress> lookup(String hostname) {\r\n            throw new RuntimeException(\"boom!\");\r\n        }\r\n    }).build());\r\n    server.enqueue(new MockResponse());\r\n    HttpURLConnection connection = urlFactory.open(server.url(\"/\").url());\r\n    try {\r\n        connection.connect();\r\n        fail();\r\n    } catch (RuntimeException expected) {\r\n        assertEquals(\"boom!\", expected.getMessage());\r\n    }\r\n}"
}, {
	"Path": "okhttp3.URLConnectionTest.unexpectedExceptionAsync",
	"Comment": "confirm that runtime exceptions thrown inside of okhttp propagate to the caller.",
	"Method": "void unexpectedExceptionAsync(){\r\n    throw new RuntimeException(\"boom!\");\r\n}"
}, {
	"Path": "com.google.refine.commands.recon.GuessTypesOfColumnCommand.guessTypes",
	"Comment": "run relevance searches for the first n cells in the given column andcount the types of the results. return a sorted list of types, from mostfrequent to least.",
	"Method": "List<TypeGroup> guessTypes(Project project,Column column,String serviceUrl){\r\n    Map<String, TypeGroup> map = new HashMap<String, TypeGroup>();\r\n    int cellIndex = column.getCellIndex();\r\n    List<String> samples = new ArrayList<String>(SAMPLE_SIZE);\r\n    Set<String> sampleSet = new HashSet<String>();\r\n    for (Row row : project.rows) {\r\n        Object value = row.getCellValue(cellIndex);\r\n        if (ExpressionUtils.isNonBlankData(value)) {\r\n            String s = value.toString().trim();\r\n            if (!sampleSet.contains(s)) {\r\n                samples.add(s);\r\n                sampleSet.add(s);\r\n                if (samples.size() >= SAMPLE_SIZE) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Map<String, IndividualQuery> queryMap = new HashMap();\r\n    for (int i = 0; i < samples.size(); i++) {\r\n        queryMap.put(\"q\" + i, new IndividualQuery(samples.get(i), 3));\r\n    }\r\n    String queriesString = ParsingUtilities.defaultWriter.writeValueAsString(queryMap);\r\n    try {\r\n        URL url = new URL(serviceUrl);\r\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\r\n        {\r\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\r\n            connection.setConnectTimeout(30000);\r\n            connection.setDoOutput(true);\r\n            DataOutputStream dos = new DataOutputStream(connection.getOutputStream());\r\n            try {\r\n                String body = \"queries=\" + ParsingUtilities.encode(queriesString);\r\n                dos.writeBytes(body);\r\n            } finally {\r\n                dos.flush();\r\n                dos.close();\r\n            }\r\n            connection.connect();\r\n        }\r\n        if (connection.getResponseCode() >= 400) {\r\n            InputStream is = connection.getErrorStream();\r\n            throw new IOException(\"Failed  - code:\" + Integer.toString(connection.getResponseCode()) + \" message: \" + is == null ? \"\" : ParsingUtilities.inputStreamToString(is));\r\n        } else {\r\n            InputStream is = connection.getInputStream();\r\n            try {\r\n                String s = ParsingUtilities.inputStreamToString(is);\r\n                ObjectNode o = ParsingUtilities.evaluateJsonStringToObjectNode(s);\r\n                Iterator<JsonNode> iterator = o.iterator();\r\n                while (iterator.hasNext()) {\r\n                    JsonNode o2 = iterator.next();\r\n                    if (!(o2.has(\"result\") && o2.get(\"result\") instanceof ArrayNode)) {\r\n                        continue;\r\n                    }\r\n                    ArrayNode results = (ArrayNode) o2.get(\"result\");\r\n                    List<ReconResult> reconResults = ParsingUtilities.mapper.convertValue(results, new TypeReference<List<ReconResult>>() {\r\n                    });\r\n                    int count = reconResults.size();\r\n                    for (int j = 0; j < count; j++) {\r\n                        ReconResult result = reconResults.get(j);\r\n                        double score = 1.0 / (1 + j);\r\n                        List<ReconType> types = result.types;\r\n                        int typeCount = types.size();\r\n                        for (int t = 0; t < typeCount; t++) {\r\n                            ReconType type = types.get(t);\r\n                            double score2 = score * (typeCount - t) / typeCount;\r\n                            if (map.containsKey(type.id)) {\r\n                                TypeGroup tg = map.get(type.id);\r\n                                tg.score += score2;\r\n                                tg.count++;\r\n                            } else {\r\n                                map.put(type.id, new TypeGroup(type.id, type.name, score2));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } finally {\r\n                is.close();\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        logger.error(\"Failed to guess cell types for load\\n\" + queriesString, e);\r\n        throw e;\r\n    }\r\n    List<TypeGroup> types = new ArrayList<TypeGroup>(map.values());\r\n    Collections.sort(types, new Comparator<TypeGroup>() {\r\n        @Override\r\n        public int compare(TypeGroup o1, TypeGroup o2) {\r\n            int c = Math.min(SAMPLE_SIZE, o2.count) - Math.min(SAMPLE_SIZE, o1.count);\r\n            if (c != 0) {\r\n                return c;\r\n            }\r\n            return (int) Math.signum(o2.score / o2.count - o1.score / o1.count);\r\n        }\r\n    });\r\n    return types;\r\n}"
}, {
	"Path": "com.google.refine.commands.recon.GuessTypesOfColumnCommand.guessTypes",
	"Comment": "run relevance searches for the first n cells in the given column andcount the types of the results. return a sorted list of types, from mostfrequent to least.",
	"Method": "List<TypeGroup> guessTypes(Project project,Column column,String serviceUrl){\r\n    int c = Math.min(SAMPLE_SIZE, o2.count) - Math.min(SAMPLE_SIZE, o1.count);\r\n    if (c != 0) {\r\n        return c;\r\n    }\r\n    return (int) Math.signum(o2.score / o2.count - o1.score / o1.count);\r\n}"
}, {
	"Path": "org.mockito.configuration.MockitoConfiguration.overrideAnnotationEngine",
	"Comment": "for testing purposes, allow to override the annotation engine",
	"Method": "void overrideAnnotationEngine(AnnotationEngine engine){\r\n    this.overriddenEngine = engine;\r\n}"
}, {
	"Path": "org.mockito.configuration.MockitoConfiguration.overrideEnableClassCache",
	"Comment": "for testing purposes, allow to override the annotation engine",
	"Method": "void overrideEnableClassCache(boolean enableClassCache){\r\n    this.enableClassCache = enableClassCache;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.Utils.convertPixelsToDp",
	"Comment": "this method converts device specific pixels to density independentpixels. needs utils to be initialized before usage.",
	"Method": "float convertPixelsToDp(float px){\r\n    if (mMetrics == null) {\r\n        Log.e(\"MPChartLib-Utils\", \"Utils NOT INITIALIZED. You need to call Utils.init(...) at least once before\" + \" calling Utils.convertPixelsToDp(...). Otherwise conversion does not\" + \" take place.\");\r\n        return px;\r\n    }\r\n    return px / mMetrics.density;\r\n}"
}, {
	"Path": "okhttp3.AndroidShimResponseCache.delete",
	"Comment": "uninstalls the cache and deletes all of its stored contents.",
	"Method": "void delete(){\r\n    delegate.delete();\r\n}"
}, {
	"Path": "org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer.important",
	"Comment": "helper to be used by subclasses to emit simple important warnings",
	"Method": "void important(String type){\r\n    addIssue(type, null, QAWarning.Severity.IMPORTANT, 1);\r\n}"
}, {
	"Path": "org.openrefine.wikidata.schema.entityvalues.ReconEntityIdValue.getReconInternalId",
	"Comment": "returns the integer used internally in openrefine to identify the new item.",
	"Method": "long getReconInternalId(){\r\n    return getRecon().id;\r\n}"
}, {
	"Path": "org.mockito.Mockito.mockingDetails",
	"Comment": "returns a mockingdetails instance that enables inspecting a particular object for mockito related information.can be used to find out if given object is a mockito mockor to find out if a given mock is a spy or mock.in future mockito versions mockingdetails may grow and provide other useful information about the mock,e.g. invocations, stubbing info, etc.",
	"Method": "MockingDetails mockingDetails(Object toInspect){\r\n    return MOCKITO_CORE.mockingDetails(toInspect);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.PieChart.isUsePercentValuesEnabled",
	"Comment": "returns true if using percentage values is enabled for the chart.",
	"Method": "boolean isUsePercentValuesEnabled(){\r\n    return mUsePercentValues;\r\n}"
}, {
	"Path": "org.openrefine.wikidata.qa.scrutinizers.EditScrutinizer.critical",
	"Comment": "helper to be used by subclasses to emit simple critical warnings",
	"Method": "void critical(String type){\r\n    addIssue(type, null, QAWarning.Severity.CRITICAL, 1);\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.strings.SmartSplitTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number ofargs",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.ScatterDataSet.setScatterShapeSize",
	"Comment": "sets the size in density pixels the drawn scattershape will have. thisonly applies for non custom shapes.",
	"Method": "void setScatterShapeSize(float size){\r\n    mShapeSize = size;\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.sample.mail.base.presenter.BaseRxLcePresenter.subscribe",
	"Comment": "subscribes the presenter himself as subscriber on the observable",
	"Method": "void subscribe(Observable<M> observable,boolean pullToRefresh){\r\n    if (isViewAttached()) {\r\n        getView().showLoading(pullToRefresh);\r\n    }\r\n    unsubscribe();\r\n    subscriber = new Subscriber<M>() {\r\n        private boolean ptr = pullToRefresh;\r\n        @Override\r\n        public void onCompleted() {\r\n            BaseRxLcePresenter.this.onCompleted();\r\n        }\r\n        @Override\r\n        public void onError(Throwable e) {\r\n            BaseRxLcePresenter.this.onError(e, ptr);\r\n        }\r\n        @Override\r\n        public void onNext(M m) {\r\n            BaseRxLcePresenter.this.onNext(m);\r\n        }\r\n    };\r\n    observable.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(subscriber);\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.sample.mail.base.presenter.BaseRxLcePresenter.subscribe",
	"Comment": "subscribes the presenter himself as subscriber on the observable",
	"Method": "void subscribe(Observable<M> observable,boolean pullToRefresh){\r\n    BaseRxLcePresenter.this.onCompleted();\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.sample.mail.base.presenter.BaseRxLcePresenter.subscribe",
	"Comment": "subscribes the presenter himself as subscriber on the observable",
	"Method": "void subscribe(Observable<M> observable,boolean pullToRefresh){\r\n    BaseRxLcePresenter.this.onError(e, ptr);\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.sample.mail.base.presenter.BaseRxLcePresenter.subscribe",
	"Comment": "subscribes the presenter himself as subscriber on the observable",
	"Method": "void subscribe(Observable<M> observable,boolean pullToRefresh){\r\n    BaseRxLcePresenter.this.onNext(m);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.BarDataSet.calcEntryCountIncludingStacks",
	"Comment": "calculates the total number of entries this dataset represents, includingstacks. all values belonging to a stack are calculated separately.",
	"Method": "void calcEntryCountIncludingStacks(List<BarEntry> yVals){\r\n    mEntryCountStacks = 0;\r\n    for (int i = 0; i < yVals.size(); i++) {\r\n        float[] vals = yVals.get(i).getYVals();\r\n        if (vals == null)\r\n            mEntryCountStacks++;\r\n        else\r\n            mEntryCountStacks += vals.length;\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.CombinedChart.setDrawBarShadow",
	"Comment": "if set to true, a grey area is drawn behind each bar that indicates themaximum value. enabling his will reduce performance by about 50%.",
	"Method": "void setDrawBarShadow(boolean enabled){\r\n    mDrawBarShadow = enabled;\r\n}"
}, {
	"Path": "okhttp3.mockwebserver.MockResponse.addHeader",
	"Comment": "adds a new header with the name and value. this may be used to add multiple headers with thesame name.",
	"Method": "MockResponse addHeader(String header,MockResponse addHeader,String name,Object value){\r\n    headers.add(name, String.valueOf(value));\r\n    return this;\r\n}"
}, {
	"Path": "okhttp3.URLConnectionTest.connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache",
	"Comment": "tolerate bad https proxy response when using httpresponsecache. android bug 6754912.",
	"Method": "void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache(){\r\n    initResponseCache();\r\n    server.useHttps(handshakeCertificates.sslSocketFactory(), true);\r\n    MockResponse badProxyResponse = new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).setBody(\"bogus proxy connect response content\");\r\n    server.enqueue(badProxyResponse);\r\n    server.enqueue(new MockResponse().setBody(\"response\"));\r\n    urlFactory.setClient(urlFactory.client().newBuilder().sslSocketFactory(handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager()).connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS)).hostnameVerifier(new RecordingHostnameVerifier()).proxy(server.toProxyAddress()).build());\r\n    URL url = new URL(\"https://android.com/foo\");\r\n    connection = urlFactory.open(url);\r\n    assertContent(\"response\", connection);\r\n    RecordedRequest connect = server.takeRequest();\r\n    assertEquals(\"CONNECT android.com:443 HTTP/1.1\", connect.getRequestLine());\r\n    assertEquals(\"android.com:443\", connect.getHeader(\"Host\"));\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.PieRadarChartBase.getRawRotationAngle",
	"Comment": "gets the raw version of the current rotation angle of the pie chart thereturned value could be any value, negative or positive, outside of the360 degrees. this is used when working with rotation direction, mainly bygestures and animations.",
	"Method": "float getRawRotationAngle(){\r\n    return mRawRotationAngle;\r\n}"
}, {
	"Path": "okhttp3.Route.requiresTunnel",
	"Comment": "returns true if this route tunnels https through an http proxy. see rfc 2817, section 5.2.",
	"Method": "boolean requiresTunnel(){\r\n    return address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.PieChart.setCenterText",
	"Comment": "sets the text string that is displayed in the center of the piechart.",
	"Method": "void setCenterText(CharSequence text){\r\n    if (text == null)\r\n        mCenterText = \"\";\r\n    else\r\n        mCenterText = text;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.PieRadarChartBase.isRotationEnabled",
	"Comment": "returns true if rotation of the chart by touch is enabled, false if not.",
	"Method": "boolean isRotationEnabled(){\r\n    return mRotateEnabled;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.ViewPortHandler.limitTransAndScale",
	"Comment": "limits the maximum scale and x translation of the given matrix",
	"Method": "void limitTransAndScale(Matrix matrix,RectF content){\r\n    matrix.getValues(matrixBuffer);\r\n    float curTransX = matrixBuffer[Matrix.MTRANS_X];\r\n    float curScaleX = matrixBuffer[Matrix.MSCALE_X];\r\n    float curTransY = matrixBuffer[Matrix.MTRANS_Y];\r\n    float curScaleY = matrixBuffer[Matrix.MSCALE_Y];\r\n    mScaleX = Math.min(Math.max(mMinScaleX, curScaleX), mMaxScaleX);\r\n    mScaleY = Math.min(Math.max(mMinScaleY, curScaleY), mMaxScaleY);\r\n    float width = 0f;\r\n    float height = 0f;\r\n    if (content != null) {\r\n        width = content.width();\r\n        height = content.height();\r\n    }\r\n    float maxTransX = -width * (mScaleX - 1f);\r\n    mTransX = Math.min(Math.max(curTransX, maxTransX - mTransOffsetX), mTransOffsetX);\r\n    float maxTransY = height * (mScaleY - 1f);\r\n    mTransY = Math.max(Math.min(curTransY, maxTransY + mTransOffsetY), -mTransOffsetY);\r\n    matrixBuffer[Matrix.MTRANS_X] = mTransX;\r\n    matrixBuffer[Matrix.MSCALE_X] = mScaleX;\r\n    matrixBuffer[Matrix.MTRANS_Y] = mTransY;\r\n    matrixBuffer[Matrix.MSCALE_Y] = mScaleY;\r\n    matrix.setValues(matrixBuffer);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.renderer.DataRenderer.getPaintHighlight",
	"Comment": "returns the paint object this renderer uses for drawing highlightindicators.",
	"Method": "Paint getPaintHighlight(){\r\n    return mHighlightPaint;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.getViewPortHandler",
	"Comment": "returns the viewporthandler of the chart that is responsible for thecontent area of the chart and its offsets and dimensions.",
	"Method": "ViewPortHandler getViewPortHandler(){\r\n    return mViewPortHandler;\r\n}"
}, {
	"Path": "okhttp3.internal.platform.Platform.getSelectedProtocol",
	"Comment": "returns the negotiated protocol, or null if no protocol was negotiated.",
	"Method": "String getSelectedProtocol(SSLSocket socket){\r\n    return null;\r\n}"
}, {
	"Path": "okhttp3.internal.connection.RealConnection.connectSocket",
	"Comment": "does all the work necessary to build a full http or https connection on a raw socket.",
	"Method": "void connectSocket(int connectTimeout,int readTimeout,Call call,EventListener eventListener){\r\n    Proxy proxy = route.proxy();\r\n    Address address = route.address();\r\n    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy);\r\n    eventListener.connectStart(call, route.socketAddress(), proxy);\r\n    rawSocket.setSoTimeout(readTimeout);\r\n    try {\r\n        Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);\r\n    } catch (ConnectException e) {\r\n        ConnectException ce = new ConnectException(\"Failed to connect to \" + route.socketAddress());\r\n        ce.initCause(e);\r\n        throw ce;\r\n    }\r\n    try {\r\n        source = Okio.buffer(Okio.source(rawSocket));\r\n        sink = Okio.buffer(Okio.sink(rawSocket));\r\n    } catch (NullPointerException npe) {\r\n        if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) {\r\n            throw new IOException(npe);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.common.util.jsr166.ConcurrentWeakHashMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this one.these mappings replace any mappings that this map had for any of thekeys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> m){\r\n    for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) put(e.getKey(), e.getValue());\r\n}"
}, {
	"Path": "okhttp3.Headers.of",
	"Comment": "returns headers for the alternating header names and values. there must be an even number ofarguments, and they must alternate between header names and values.",
	"Method": "Headers of(String namesAndValues,Headers of,Map<String, String> headers){\r\n    if (headers == null)\r\n        throw new NullPointerException(\"headers == null\");\r\n    String[] namesAndValues = new String[headers.size() * 2];\r\n    int i = 0;\r\n    for (Map.Entry<String, String> header : headers.entrySet()) {\r\n        if (header.getKey() == null || header.getValue() == null) {\r\n            throw new IllegalArgumentException(\"Headers cannot be null\");\r\n        }\r\n        String name = header.getKey().trim();\r\n        String value = header.getValue().trim();\r\n        checkName(name);\r\n        checkValue(value, name);\r\n        namesAndValues[i] = name;\r\n        namesAndValues[i + 1] = value;\r\n        i += 2;\r\n    }\r\n    return new Headers(namesAndValues);\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.ActivityMviDelegateImpl.retainPresenterInstance",
	"Comment": "determines whether or not a presenter instance should be kept",
	"Method": "boolean retainPresenterInstance(boolean keepPresenterInstance,Activity activity){\r\n    return keepPresenterInstance && (activity.isChangingConfigurations() || !activity.isFinishing());\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.sample.mvi.view.home.HomeViewRobot.arrayToString",
	"Comment": "simple helper function to print the content of an array as a string",
	"Method": "String arrayToString(Object[] array){\r\n    StringBuffer buffer = new StringBuffer();\r\n    for (Object o : array) {\r\n        buffer.append(o.toString());\r\n        buffer.append(\"\\n\");\r\n    }\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.Description.getPosition",
	"Comment": "returns the customized position of the description, or null if none set.",
	"Method": "MPPointF getPosition(){\r\n    return mPosition;\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.MvpFragment.getMvpDelegate",
	"Comment": "gets the mvp delegate. this is internally used for creating presenter, attaching anddetaching view from presenter.please note that only one instance of mvp delegate should be used per fragment instance.only override this method if you really know what you are doing.",
	"Method": "FragmentMvpDelegate<V, P> getMvpDelegate(){\r\n    if (mvpDelegate == null) {\r\n        mvpDelegate = new FragmentMvpDelegateImpl(this, this, true, true);\r\n    }\r\n    return mvpDelegate;\r\n}"
}, {
	"Path": "com.google.refine.clustering.binning.Metaphone3.Encode_WITZ_WICZ",
	"Comment": "encode polish patronymic suffix, mapping\talternate spellings to the same encoding,\tand including easern european pronounciation\tto the american so that both forms can\tbe found in a genealogy search",
	"Method": "boolean Encode_WITZ_WICZ(){\r\n    if (((m_current + 3) == m_last) && StringAt(m_current, 4, \"WICZ\", \"WITZ\", \"\")) {\r\n        if (m_encodeVowels) {\r\n            if ((m_primary.length() > 0) && m_primary.charAt(m_primary.length() - 1) == 'A') {\r\n                MetaphAdd(\"TS\", \"FAX\");\r\n            } else {\r\n                MetaphAdd(\"ATS\", \"FAX\");\r\n            }\r\n        } else {\r\n            MetaphAdd(\"TS\", \"FX\");\r\n        }\r\n        m_current += 4;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "okhttp3.internal.cache.DiskLruCache.size",
	"Comment": "returns the number of bytes currently being used to store the values in this cache. this may begreater than the max size if a background deletion is pending.",
	"Method": "long size(){\r\n    initialize();\r\n    return size;\r\n}"
}, {
	"Path": "org.mockitoutil.async.AsyncTesting.runAfter",
	"Comment": "schedules execution of runnable with some delay.starts thread immediately and returns.the thread will execute the runnable after given delay in millis.",
	"Method": "void runAfter(int delayMillis,Runnable runnable){\r\n    if (threads.size() == MAX_THREADS) {\r\n        throw new RuntimeException(\"Please don't schedule any more threads. Figure out how to test the code with minimum amount of threads\");\r\n    }\r\n    Thread t = new Thread() {\r\n        public void run() {\r\n            try {\r\n                Thread.sleep(delayMillis);\r\n                runnable.run();\r\n            } catch (Exception e) {\r\n                boolean cleanStop = e instanceof InterruptedException && stopping;\r\n                if (!cleanStop) {\r\n                    problems.add(e);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    System.out.println(\"[AsyncTesting] Starting thread that will execute the runnable after \" + delayMillis + \" millis. Threads so far: \" + threads.size());\r\n    threads.add(t);\r\n    t.start();\r\n}"
}, {
	"Path": "org.mockitoutil.async.AsyncTesting.runAfter",
	"Comment": "schedules execution of runnable with some delay.starts thread immediately and returns.the thread will execute the runnable after given delay in millis.",
	"Method": "void runAfter(int delayMillis,Runnable runnable){\r\n    try {\r\n        Thread.sleep(delayMillis);\r\n        runnable.run();\r\n    } catch (Exception e) {\r\n        boolean cleanStop = e instanceof InterruptedException && stopping;\r\n        if (!cleanStop) {\r\n            problems.add(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvi.layout.MviLinearLayout.getMvpDelegate",
	"Comment": "get the mvp delegate. this is internally used for creating presenter, attaching and detachingview from presenter etc.please note that only one instance of mvp delegate should be used per android.view.viewinstance.only override this method if you really know what you are doing.",
	"Method": "ViewGroupMviDelegate<V, P> getMvpDelegate(){\r\n    if (mvpDelegate == null) {\r\n        mvpDelegate = new ViewGroupMviDelegateImpl<V, P>(this, this, true);\r\n    }\r\n    return mvpDelegate;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.ComponentBase.getTextSize",
	"Comment": "returns the text size that is currently set for the labels, in pixels",
	"Method": "float getTextSize(){\r\n    return mTextSize;\r\n}"
}, {
	"Path": "okhttp3.Response.isRedirect",
	"Comment": "returns true if this response redirects to another resource.",
	"Method": "boolean isRedirect(){\r\n    switch(code) {\r\n        case HTTP_PERM_REDIRECT:\r\n        case HTTP_TEMP_REDIRECT:\r\n        case HTTP_MULT_CHOICE:\r\n        case HTTP_MOVED_PERM:\r\n        case HTTP_MOVED_TEMP:\r\n        case HTTP_SEE_OTHER:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.isClipValuesToContentEnabled",
	"Comment": "when enabled, the values will be clipped to contentrect,otherwise they can bleed outside the content rect.",
	"Method": "boolean isClipValuesToContentEnabled(){\r\n    return mClipValuesToContent;\r\n}"
}, {
	"Path": "okhttp3.Handshake.localPrincipal",
	"Comment": "returns the local principle, or null if this peer is anonymous.",
	"Method": "Principal localPrincipal(){\r\n    return !localCertificates.isEmpty() ? ((X509Certificate) localCertificates.get(0)).getSubjectX500Principal() : null;\r\n}"
}, {
	"Path": "org.mockito.internal.verification.Description.verify",
	"Comment": "performs verification using the wrapped verification mode implementation.prepends the custom failure message if verification fails.",
	"Method": "void verify(VerificationData data){\r\n    try {\r\n        verification.verify(data);\r\n    } catch (MockitoAssertionError e) {\r\n        throw new MockitoAssertionError(e, description);\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.tests.importers.TsvCsvImporterTests.CSV_TSV_or_AutoDetermine",
	"Comment": "used for parameterized testing for both separatorparser and tsvcsvparser.",
	"Method": "Object[][] CSV_TSV_or_AutoDetermine(){\r\n    return new Object[][] { { \",\" }, { \"\\t\" }, { null } };\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.ObjectPool.setReplenishPercentage",
	"Comment": "set the percentage of the pool to replenish on empty.valid values are between0.00f and 1.00f",
	"Method": "void setReplenishPercentage(float percentage){\r\n    float p = percentage;\r\n    if (p > 1) {\r\n        p = 1;\r\n    } else if (p < 0f) {\r\n        p = 0f;\r\n    }\r\n    this.replenishPercentage = p;\r\n}"
}, {
	"Path": "okhttp3.mockwebserver.MockResponse.withWebSocketUpgrade",
	"Comment": "attempts to perform a web socket upgrade on the connection. this will overwrite any previouslyset status or body.",
	"Method": "MockResponse withWebSocketUpgrade(WebSocketListener listener){\r\n    setStatus(\"HTTP/1.1 101 Switching Protocols\");\r\n    setHeader(\"Connection\", \"Upgrade\");\r\n    setHeader(\"Upgrade\", \"websocket\");\r\n    body = null;\r\n    webSocketListener = listener;\r\n    return this;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.setMarker",
	"Comment": "sets the marker that is displayed when a value is clicked on the chart",
	"Method": "void setMarker(IMarker marker){\r\n    mMarker = marker;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.ChartData.getMaxEntryCountSet",
	"Comment": "returns the dataset object with the maximum number of entries or null if there are no datasets.",
	"Method": "T getMaxEntryCountSet(){\r\n    if (mDataSets == null || mDataSets.isEmpty())\r\n        return null;\r\n    T max = mDataSets.get(0);\r\n    for (T set : mDataSets) {\r\n        if (set.getEntryCount() > max.getEntryCount())\r\n            max = set;\r\n    }\r\n    return max;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.listener.BarLineChartTouchListener.midPoint",
	"Comment": "determines the center point between two pointer touch points.",
	"Method": "void midPoint(MPPointF point,MotionEvent event){\r\n    float x = event.getX(0) + event.getX(1);\r\n    float y = event.getY(0) + event.getY(1);\r\n    point.x = (x / 2f);\r\n    point.y = (y / 2f);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.isHighlightPerTapEnabled",
	"Comment": "returns true if values can be highlighted via tap gesture, false if not.",
	"Method": "boolean isHighlightPerTapEnabled(){\r\n    return mHighLightPerTapEnabled;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.listener.PieRadarChartTouchListener.updateGestureRotation",
	"Comment": "updates the view rotation depending on the given touch position, alsotakes the starting angle into consideration",
	"Method": "void updateGestureRotation(float x,float y){\r\n    mChart.setRotationAngle(mChart.getAngleForPoint(x, y) - mStartAngle);\r\n}"
}, {
	"Path": "org.mockitoutil.ConcurrentTesting.concurrently",
	"Comment": "starts all supplied runnables and then waits for all of them to complete.runnables are executed concurrently.",
	"Method": "void concurrently(Runnable runnables){\r\n    List<Thread> threads = new LinkedList<Thread>();\r\n    for (Runnable r : runnables) {\r\n        Thread t = new Thread(r);\r\n        t.start();\r\n        threads.add(t);\r\n    }\r\n    for (Thread t : threads) {\r\n        t.join();\r\n    }\r\n}"
}, {
	"Path": "org.openrefine.wikidata.schema.WikibaseSchema.evaluateItemDocuments",
	"Comment": "evaluates all item documents in a particular expression context. thisspecifies, among others, a row where the values of the variables will beread.",
	"Method": "List<ItemUpdate> evaluateItemDocuments(ExpressionContext ctxt){\r\n    List<ItemUpdate> result = new ArrayList();\r\n    for (WbItemDocumentExpr expr : itemDocumentExprs) {\r\n        try {\r\n            result.add(expr.evaluate(ctxt));\r\n        } catch (SkipSchemaExpressionException e) {\r\n            continue;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.strings.DiffTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.strings.ToFromConversionTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonReader.failOnUnknown",
	"Comment": "returns true if this parser forbids skipping names and values.",
	"Method": "boolean failOnUnknown(){\r\n    return failOnUnknown;\r\n}"
}, {
	"Path": "okhttp3.internal.platform.Platform.findPlatform",
	"Comment": "attempt to match the host runtime to a capable platform implementation.",
	"Method": "Platform findPlatform(){\r\n    Platform android = AndroidPlatform.buildIfSupported();\r\n    if (android != null) {\r\n        return android;\r\n    }\r\n    if (isConscryptPreferred()) {\r\n        Platform conscrypt = ConscryptPlatform.buildIfSupported();\r\n        if (conscrypt != null) {\r\n            return conscrypt;\r\n        }\r\n    }\r\n    Platform jdk9 = Jdk9Platform.buildIfSupported();\r\n    if (jdk9 != null) {\r\n        return jdk9;\r\n    }\r\n    Platform jdkWithJettyBoot = JdkWithJettyBootPlatform.buildIfSupported();\r\n    if (jdkWithJettyBoot != null) {\r\n        return jdkWithJettyBoot;\r\n    }\r\n    return new Platform();\r\n}"
}, {
	"Path": "org.apache.ibatis.builder.xml.XMLIncludeTransformer.getVariablesContext",
	"Comment": "read placeholders and their values from include node definition.",
	"Method": "Properties getVariablesContext(Node node,Properties inheritedVariablesContext){\r\n    Map<String, String> declaredProperties = null;\r\n    NodeList children = node.getChildNodes();\r\n    for (int i = 0; i < children.getLength(); i++) {\r\n        Node n = children.item(i);\r\n        if (n.getNodeType() == Node.ELEMENT_NODE) {\r\n            String name = getStringAttribute(n, \"name\");\r\n            String value = PropertyParser.parse(getStringAttribute(n, \"value\"), inheritedVariablesContext);\r\n            if (declaredProperties == null) {\r\n                declaredProperties = new HashMap();\r\n            }\r\n            if (declaredProperties.put(name, value) != null) {\r\n                throw new BuilderException(\"Variable \" + name + \" defined twice in the same include definition\");\r\n            }\r\n        }\r\n    }\r\n    if (declaredProperties == null) {\r\n        return inheritedVariablesContext;\r\n    } else {\r\n        Properties newProperties = new Properties();\r\n        newProperties.putAll(inheritedVariablesContext);\r\n        newProperties.putAll(declaredProperties);\r\n        return newProperties;\r\n    }\r\n}"
}, {
	"Path": "okhttp3.ConnectionCoalescingTest.alternativeThenCommon",
	"Comment": "test connecting to an alternative host then common name, although only subject alternativenames are used if present no special consideration of common name.",
	"Method": "void alternativeThenCommon(){\r\n    server.enqueue(new MockResponse().setResponseCode(200));\r\n    server.enqueue(new MockResponse().setResponseCode(200));\r\n    HttpUrl sanUrl = url.newBuilder().host(\"san.com\").build();\r\n    assert200Http2Response(execute(sanUrl), \"san.com\");\r\n    assert200Http2Response(execute(url), server.getHostName());\r\n    assertEquals(1, client.connectionPool().connectionCount());\r\n}"
}, {
	"Path": "org.mockito.internal.verification.DescriptionTest.verification_failure_should_prepend_expected_message",
	"Comment": "test of verify method, of class description. this test validates that the custom message is prepended to theerror message when verification fails.",
	"Method": "void verification_failure_should_prepend_expected_message(){\r\n    String failureMessage = \"message should be prepended to the original message\";\r\n    String exceptionMessage = \"original error message\";\r\n    String expectedResult = failureMessage + \"\\n\" + exceptionMessage;\r\n    MockitoAssertionError error = new MockitoAssertionError(exceptionMessage);\r\n    doThrow(error).when(mockVerificationMode).verify(mockVerificationData);\r\n    Description instance = new Description(mockVerificationMode, failureMessage);\r\n    try {\r\n        instance.verify(mockVerificationData);\r\n        verify(mockVerificationMode).verify(mockVerificationData);\r\n        fail(\"Should not have made it this far\");\r\n    } catch (MockitoAssertionError e) {\r\n        assertEquals(expectedResult, e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.mockito.internal.util.reflection.GenericTypeExtractor.extractGeneric",
	"Comment": "attempts to extract generic parameter type of given type.if there is no generic parameter it returns object.class",
	"Method": "Class<?> extractGeneric(Type type){\r\n    if (type instanceof ParameterizedType) {\r\n        Type[] genericTypes = ((ParameterizedType) type).getActualTypeArguments();\r\n        if (genericTypes.length > 0 && genericTypes[0] instanceof Class) {\r\n            return (Class<?>) genericTypes[0];\r\n        }\r\n    }\r\n    return Object.class;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.CombinedChart.setDrawValueAboveBar",
	"Comment": "if set to true, all values are drawn above their bars, instead of belowtheir top.",
	"Method": "void setDrawValueAboveBar(boolean enabled){\r\n    mDrawValueAboveBar = enabled;\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testCallWithResultSet4_a1",
	"Comment": "this test shows how to use a input and output parameters and return aresult set from a stored procedure.this test shows using a map parameter.this test shows using annotations for stored procedures",
	"Method": "void testCallWithResultSet4_a1(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        Map<String, Object> parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 2);\r\n        List<Name> names = spMapper.getNamesAnnotated(parms);\r\n        assertEquals(2, parms.get(\"totalRows\"));\r\n        assertEquals(2, names.size());\r\n        parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 2);\r\n        names = spMapper.getNamesAnnotated(parms);\r\n        assertEquals(2, names.size());\r\n        assertEquals(2, parms.get(\"totalRows\"));\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testCallWithResultSet4_a2",
	"Comment": "this test shows how to use a input and output parameters and return aresult set from a stored procedure.this test shows using a map parameter.this test shows using annotations for stored procedures and using aresultmap in xml",
	"Method": "void testCallWithResultSet4_a2(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        Map<String, Object> parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 2);\r\n        List<Name> names = spMapper.getNamesAnnotatedWithXMLResultMap(parms);\r\n        assertEquals(2, parms.get(\"totalRows\"));\r\n        assertEquals(2, names.size());\r\n        parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 2);\r\n        names = spMapper.getNamesAnnotatedWithXMLResultMap(parms);\r\n        assertEquals(2, names.size());\r\n        assertEquals(2, parms.get(\"totalRows\"));\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.getOnTouchListener",
	"Comment": "returns an instance of the currently active touch listener.",
	"Method": "ChartTouchListener getOnTouchListener(){\r\n    return mChartTouchListener;\r\n}"
}, {
	"Path": "okhttp3.android.HttpResponseCache.delete",
	"Comment": "uninstalls the cache and deletes all of its stored contents.",
	"Method": "void delete(){\r\n    if (ResponseCache.getDefault() == this) {\r\n        ResponseCache.setDefault(null);\r\n    }\r\n    shimResponseCache.delete();\r\n}"
}, {
	"Path": "org.apache.ibatis.io.VFS.getMethod",
	"Comment": "get a method by name and parameter types. if the method is not found then return null.",
	"Method": "Method getMethod(Class<?> clazz,String methodName,Class<?> parameterTypes){\r\n    if (clazz == null) {\r\n        return null;\r\n    }\r\n    try {\r\n        return clazz.getMethod(methodName, parameterTypes);\r\n    } catch (SecurityException e) {\r\n        log.error(\"Security exception looking for method \" + clazz.getName() + \".\" + methodName + \".  Cause: \" + e);\r\n        return null;\r\n    } catch (NoSuchMethodException e) {\r\n        log.error(\"Method not found \" + clazz.getName() + \".\" + methodName + \".\" + methodName + \".  Cause: \" + e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "okhttp3.internal.connection.StreamAllocation.findHealthyConnection",
	"Comment": "finds a connection and returns it if it is healthy. if it is unhealthy the process is repeateduntil a healthy connection is found.",
	"Method": "RealConnection findHealthyConnection(int connectTimeout,int readTimeout,int writeTimeout,int pingIntervalMillis,boolean connectionRetryEnabled,boolean doExtensiveHealthChecks){\r\n    while (true) {\r\n        RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled);\r\n        synchronized (connectionPool) {\r\n            if (candidate.successCount == 0) {\r\n                return candidate;\r\n            }\r\n        }\r\n        if (!candidate.isHealthy(doExtensiveHealthChecks)) {\r\n            noNewStreams();\r\n            continue;\r\n        }\r\n        return candidate;\r\n    }\r\n}"
}, {
	"Path": "okhttp3.internal.ws.WebSocketHttpTest.unacknowledgedPingFailsConnection",
	"Comment": "configure the websocket to send pings every 500 ms. artificially prevent the server fromresponding to pings. the client should give up when attempting to send its 2nd ping, at about1000 ms.",
	"Method": "void unacknowledgedPingFailsConnection(){\r\n    client = client.newBuilder().pingInterval(500, TimeUnit.MILLISECONDS).build();\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    webServer.enqueue(new MockResponse().withWebSocketUpgrade(new WebSocketListener() {\r\n        @Override\r\n        public void onOpen(WebSocket webSocket, Response response) {\r\n            try {\r\n                latch.await();\r\n            } catch (InterruptedException e) {\r\n                throw new AssertionError(e);\r\n            }\r\n        }\r\n    }));\r\n    long openAtNanos = System.nanoTime();\r\n    newWebSocket();\r\n    clientListener.assertOpen();\r\n    clientListener.assertFailure(SocketTimeoutException.class, \"sent ping but didn't receive pong within 500ms (after 0 successful ping/pongs)\");\r\n    latch.countDown();\r\n    long elapsedUntilFailure = System.nanoTime() - openAtNanos;\r\n    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);\r\n}"
}, {
	"Path": "okhttp3.internal.ws.WebSocketHttpTest.unacknowledgedPingFailsConnection",
	"Comment": "configure the websocket to send pings every 500 ms. artificially prevent the server fromresponding to pings. the client should give up when attempting to send its 2nd ping, at about1000 ms.",
	"Method": "void unacknowledgedPingFailsConnection(){\r\n    try {\r\n        latch.await();\r\n    } catch (InterruptedException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.zoomAndCenterAnimated",
	"Comment": "zooms by the specified scale factor to the specified values on the specified axis.",
	"Method": "void zoomAndCenterAnimated(float scaleX,float scaleY,float xValue,float yValue,AxisDependency axis,long duration){\r\n    MPPointD origin = getValuesByTouchPoint(mViewPortHandler.contentLeft(), mViewPortHandler.contentTop(), axis);\r\n    Runnable job = AnimatedZoomJob.getInstance(mViewPortHandler, this, getTransformer(axis), getAxis(axis), mXAxis.mAxisRange, scaleX, scaleY, mViewPortHandler.getScaleX(), mViewPortHandler.getScaleY(), xValue, yValue, (float) origin.x, (float) origin.y, duration);\r\n    addViewportJob(job);\r\n    MPPointD.recycleInstance(origin);\r\n}"
}, {
	"Path": "org.mockito.internal.configuration.plugins.DefaultMockitoPlugins.create",
	"Comment": "creates an instance of given plugin type, using specific implementation class.",
	"Method": "T create(Class<T> pluginType,String className){\r\n    if (className == null) {\r\n        throw new IllegalStateException(\"No default implementation for requested Mockito plugin type: \" + pluginType.getName() + \"\\n\" + \"Is this a valid Mockito plugin type? If yes, please report this problem to Mockito team.\\n\" + \"Otherwise, please check if you are passing valid plugin type.\\n\" + \"Examples of valid plugin types: MockMaker, StackTraceCleanerProvider.\");\r\n    }\r\n    try {\r\n        return pluginType.cast(Class.forName(className).newInstance());\r\n    } catch (Exception e) {\r\n        throw new IllegalStateException(\"Internal problem occurred, please report it. \" + \"Mockito is unable to load the default implementation of class that is a part of Mockito distribution. \" + \"Failed to load \" + pluginType, e);\r\n    }\r\n}"
}, {
	"Path": "org.openrefine.wikidata.schema.WbNameDescExpr.contributeTo",
	"Comment": "evaluates the expression and adds the result to the item update.",
	"Method": "void contributeTo(ItemUpdateBuilder item,ExpressionContext ctxt){\r\n    try {\r\n        MonolingualTextValue val = getValue().evaluate(ctxt);\r\n        switch(getType()) {\r\n            case LABEL:\r\n                item.addLabel(val);\r\n                break;\r\n            case DESCRIPTION:\r\n                item.addDescription(val);\r\n                break;\r\n            case ALIAS:\r\n                item.addAlias(val);\r\n                break;\r\n        }\r\n    } catch (SkipSchemaExpressionException e) {\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "org.mockito.internal.util.concurrent.WeakConcurrentSet.approximateSize",
	"Comment": "returns the approximate size of this set where the returned number is at least as big as the actual number of entries.",
	"Method": "int approximateSize(){\r\n    return target.approximateSize();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.Legend.getFormLineWidth",
	"Comment": "returns the line width in dp for drawing forms that consist of lines",
	"Method": "float getFormLineWidth(){\r\n    return mFormLineWidth;\r\n}"
}, {
	"Path": "okhttp3.AndroidInternal.setResponseCache",
	"Comment": "sets the response cache to be used to read and write cached responses.",
	"Method": "void setResponseCache(OkUrlFactory okUrlFactory,ResponseCache responseCache){\r\n    OkHttpClient.Builder builder = okUrlFactory.client().newBuilder();\r\n    if (responseCache instanceof OkCacheContainer) {\r\n        OkCacheContainer okCacheContainer = (OkCacheContainer) responseCache;\r\n        builder.cache(okCacheContainer.getCache());\r\n    } else {\r\n        builder.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);\r\n    }\r\n    okUrlFactory.setClient(builder.build());\r\n}"
}, {
	"Path": "org.mockito.internal.stubbing.InvocationContainerImpl.addAnswer",
	"Comment": "adds new stubbed answer and returns the invocation matcher the answer was added to.",
	"Method": "void addAnswer(Answer answer,Strictness stubbingStrictness,StubbedInvocationMatcher addAnswer,Answer answer,boolean isConsecutive,Strictness stubbingStrictness){\r\n    Invocation invocation = invocationForStubbing.getInvocation();\r\n    mockingProgress().stubbingCompleted();\r\n    if (answer instanceof ValidableAnswer) {\r\n        ((ValidableAnswer) answer).validateFor(invocation);\r\n    }\r\n    synchronized (stubbed) {\r\n        if (isConsecutive) {\r\n            stubbed.getFirst().addAnswer(answer);\r\n        } else {\r\n            Strictness effectiveStrictness = stubbingStrictness != null ? stubbingStrictness : this.mockStrictness;\r\n            stubbed.addFirst(new StubbedInvocationMatcher(answer, invocationForStubbing, effectiveStrictness));\r\n        }\r\n        return stubbed.getFirst();\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.BaseDataSet.setGradientColor",
	"Comment": "sets the start and end color for gradient color, only color that should be used for this dataset.",
	"Method": "void setGradientColor(int startColor,int endColor){\r\n    mGradientColor = new GradientColor(startColor, endColor);\r\n}"
}, {
	"Path": "org.openrefine.wikidata.schema.WbExpressionTest.evaluatesTo",
	"Comment": "test that a particular expression evaluates to some object.",
	"Method": "void evaluatesTo(T expected,WbExpression<T> expression){\r\n    try {\r\n        T result = expression.evaluate(ctxt);\r\n        Assert.assertEquals(expected, result);\r\n    } catch (SkipSchemaExpressionException e) {\r\n        Assert.fail(\"Value was skipped by evaluator\");\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.CrossFunctionTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.setRendererRightYAxis",
	"Comment": "sets a custom axis renderer for the right acis and overwrites the existing one.",
	"Method": "void setRendererRightYAxis(YAxisRenderer rendererRightYAxis){\r\n    mAxisRendererRight = rendererRightYAxis;\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.MvpActivity.getMvpDelegate",
	"Comment": "get the mvp delegate. this is internally used for creating presenter, attaching and detachingview from presenter.please note that only one instance of mvp delegate should be used per activityinstance.only override this method if you really know what you are doing.",
	"Method": "ActivityMvpDelegate<V, P> getMvpDelegate(){\r\n    if (mvpDelegate == null) {\r\n        mvpDelegate = new ActivityMvpDelegateImpl(this, this, true);\r\n    }\r\n    return mvpDelegate;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.valuesToHighlight",
	"Comment": "returns true if there are values to highlight, false if there are novalues to highlight. checks if the highlight array is null, has a lengthof zero or if the first object is null.",
	"Method": "boolean valuesToHighlight(){\r\n    return mIndicesToHighlight == null || mIndicesToHighlight.length <= 0 || mIndicesToHighlight[0] == null ? false : true;\r\n}"
}, {
	"Path": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest.getClassOrSkipTest",
	"Comment": "tries to load the given class. if the class is not found, the complete test is skipped.",
	"Method": "Class<?> getClassOrSkipTest(String className){\r\n    try {\r\n        return Class.forName(className);\r\n    } catch (ClassNotFoundException e) {\r\n        Assume.assumeNoException(\"JVM does not support \" + className, e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.io.ClassLoaderWrapper.getResourceAsURL",
	"Comment": "get a resource from the classpath, starting with a specific class loader",
	"Method": "URL getResourceAsURL(String resource,URL getResourceAsURL,String resource,ClassLoader classLoader,URL getResourceAsURL,String resource,ClassLoader[] classLoader){\r\n    URL url;\r\n    for (ClassLoader cl : classLoader) {\r\n        if (null != cl) {\r\n            url = cl.getResource(resource);\r\n            if (null == url) {\r\n                url = cl.getResource(\"/\" + resource);\r\n            }\r\n            if (null != url) {\r\n                return url;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "okhttp3.Cookie.parseAll",
	"Comment": "returns all of the cookies from a set of http response headers.",
	"Method": "List<Cookie> parseAll(HttpUrl url,Headers headers){\r\n    List<String> cookieStrings = headers.values(\"Set-Cookie\");\r\n    List<Cookie> cookies = null;\r\n    for (int i = 0, size = cookieStrings.size(); i < size; i++) {\r\n        Cookie cookie = Cookie.parse(url, cookieStrings.get(i));\r\n        if (cookie == null)\r\n            continue;\r\n        if (cookies == null)\r\n            cookies = new ArrayList();\r\n        cookies.add(cookie);\r\n    }\r\n    return cookies != null ? Collections.unmodifiableList(cookies) : Collections.<Cookie>emptyList();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.Description.setText",
	"Comment": "sets the text to be shown as the description.never set this to null as this will cause nullpointer exception when drawing with android canvas.",
	"Method": "void setText(String text){\r\n    this.text = text;\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonReader.readJsonValue",
	"Comment": "returns the value of the next token, consuming it. the result may be a string, number, boolean,null, map, or list, according to the json structure.",
	"Method": "Object readJsonValue(){\r\n    switch(peek()) {\r\n        case BEGIN_ARRAY:\r\n            List<Object> list = new ArrayList();\r\n            beginArray();\r\n            while (hasNext()) {\r\n                list.add(readJsonValue());\r\n            }\r\n            endArray();\r\n            return list;\r\n        case BEGIN_OBJECT:\r\n            Map<String, Object> map = new LinkedHashTreeMap();\r\n            beginObject();\r\n            while (hasNext()) {\r\n                String name = nextName();\r\n                Object value = readJsonValue();\r\n                Object replaced = map.put(name, value);\r\n                if (replaced != null) {\r\n                    throw new JsonDataException(\"Map key '\" + name + \"' has multiple values at path \" + getPath() + \": \" + replaced + \" and \" + value);\r\n                }\r\n            }\r\n            endObject();\r\n            return map;\r\n        case STRING:\r\n            return nextString();\r\n        case NUMBER:\r\n            return nextDouble();\r\n        case BOOLEAN:\r\n            return nextBoolean();\r\n        case NULL:\r\n            return nextNull();\r\n        default:\r\n            throw new IllegalStateException(\"Expected a value but was \" + peek() + \" at path \" + getPath());\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.date.DatePartTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "okhttp3.android.HttpResponseCache.flush",
	"Comment": "force buffered operations to the filesystem. this ensures that responses written to the cachewill be available the next time the cache is opened, even if this process is killed.",
	"Method": "void flush(){\r\n    try {\r\n        shimResponseCache.flush();\r\n    } catch (IOException ignored) {\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.RadarChart.setWebLineWidthInner",
	"Comment": "sets the width of the web lines that are in between the lines coming fromthe center.",
	"Method": "void setWebLineWidthInner(float width){\r\n    mInnerWebLineWidth = Utils.convertDpToPixel(width);\r\n}"
}, {
	"Path": "com.google.refine.expr.functions.math.FactN.factorial",
	"Comment": "calculates the factorial of an integer, i, for a decreasing step of n.e.g. a double factorial would have a step of 2.returns 1 for zero and negative integers.",
	"Method": "long factorial(long i,long step){\r\n    if (i < 0) {\r\n        throw new IllegalArgumentException(\"Can't compute the factorial of a negative number\");\r\n    } else if (i <= 1) {\r\n        return 1;\r\n    } else {\r\n        long result = i * FactN.factorial(i - step, step);\r\n        if (result < 0) {\r\n            throw new ArithmeticException(\"Integer overflow computing factorial\");\r\n        }\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.mockitousage.stubbing.DeepStubbingTest.withSimplePrimitive",
	"Comment": "test that deep stubbing work with primitive expected values",
	"Method": "void withSimplePrimitive(){\r\n    int a = 32;\r\n    SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\r\n    when(sf.createSocket().getPort()).thenReturn(a);\r\n    assertEquals(a, sf.createSocket().getPort());\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.layout.MvpRelativeLayout.getMvpDelegate",
	"Comment": "get the mvp delegate. this is internally used for creating presenter, attaching and detachingview from presenter etc.please note that only one instance of mvp delegate should be used per android.view.viewinstance.only override this method if you really know what you are doing.",
	"Method": "ViewGroupMvpDelegate<V, P> getMvpDelegate(){\r\n    if (mvpDelegate == null) {\r\n        mvpDelegate = new ViewGroupMvpDelegateImpl(this, this, true);\r\n    }\r\n    return mvpDelegate;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.YAxis.isUseAutoScaleMaxRestriction",
	"Comment": "returns true if autoscale restriction for axis max value is enabled",
	"Method": "boolean isUseAutoScaleMaxRestriction(){\r\n    return mUseAutoScaleRestrictionMax;\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.viewstate.lce.data.ArrayListLceViewState.getClassLoader",
	"Comment": "the class loader used for deserializing the list of parcelable items",
	"Method": "ClassLoader getClassLoader(){\r\n    return getClass().getClassLoader();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.setVisibleYRange",
	"Comment": "limits the maximum and minimum y range that can be visible by pinching and zooming.",
	"Method": "void setVisibleYRange(float minYRange,float maxYRange,AxisDependency axis){\r\n    float minScale = getAxisRange(axis) / minYRange;\r\n    float maxScale = getAxisRange(axis) / maxYRange;\r\n    mViewPortHandler.setMinMaxScaleY(minScale, maxScale);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.LineDataSet.setDrawCircles",
	"Comment": "set this to true to enable the drawing of circle indicators for thisdataset, default true",
	"Method": "void setDrawCircles(boolean enabled){\r\n    this.mDrawCircles = enabled;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.getDataSetByTouchPoint",
	"Comment": "returns the dataset object displayed at the touched position of the chart",
	"Method": "IBarLineScatterCandleBubbleDataSet getDataSetByTouchPoint(float x,float y){\r\n    Highlight h = getHighlightByTouchPoint(x, y);\r\n    if (h != null) {\r\n        return mData.getDataSetByIndex(h.getDataSetIndex());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.mockito.internal.util.reflection.GenericTypeExtractor.findGenericInterface",
	"Comment": "finds generic interface implementation based on the source class and the target interface.returns null if not found. recurses the interface hierarchy.",
	"Method": "Type findGenericInterface(Class<?> sourceClass,Class<?> targetBaseInterface){\r\n    for (int i = 0; i < sourceClass.getInterfaces().length; i++) {\r\n        Class<?> inter = sourceClass.getInterfaces()[i];\r\n        if (inter == targetBaseInterface) {\r\n            return sourceClass.getGenericInterfaces()[0];\r\n        } else {\r\n            Type deeper = findGenericInterface(inter, targetBaseInterface);\r\n            if (deeper != null) {\r\n                return deeper;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.CoalesceTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.ContainsFunctionTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.Transformer.prepareMatrixValuePx",
	"Comment": "prepares the matrix that transforms values to pixels. calculates thescale factors from the charts size and offsets.",
	"Method": "void prepareMatrixValuePx(float xChartMin,float deltaX,float deltaY,float yChartMin){\r\n    float scaleX = (float) ((mViewPortHandler.contentWidth()) / deltaX);\r\n    float scaleY = (float) ((mViewPortHandler.contentHeight()) / deltaY);\r\n    if (Float.isInfinite(scaleX)) {\r\n        scaleX = 0;\r\n    }\r\n    if (Float.isInfinite(scaleY)) {\r\n        scaleY = 0;\r\n    }\r\n    mMatrixValueToPx.reset();\r\n    mMatrixValueToPx.postTranslate(-xChartMin, -yChartMin);\r\n    mMatrixValueToPx.postScale(scaleX, -scaleY);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.YAxis.getSpaceTop",
	"Comment": "returns the top axis space in percent of the full range. default 10f",
	"Method": "float getSpaceTop(){\r\n    return mSpacePercentTop;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.renderer.LegendRenderer.getLabelPaint",
	"Comment": "returns the paint object used for drawing the legend labels.",
	"Method": "Paint getLabelPaint(){\r\n    return mLegendLabelPaint;\r\n}"
}, {
	"Path": "okhttp3.mockwebserver.MockWebServer.setBodyLimit",
	"Comment": "sets the number of bytes of the post body to keep in memory to the given limit.",
	"Method": "void setBodyLimit(long maxBodyLength){\r\n    this.bodyLimit = maxBodyLength;\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.common.util.BitFieldUtils.setBit",
	"Comment": "returns v, with the bit at position set to 1 or 0 depending on value.",
	"Method": "byte setBit(byte v,int position,boolean value,short setBit,short v,int position,boolean value,int setBit,int v,int position,boolean value,long setBit,long v,int position,boolean value){\r\n    if (value)\r\n        return v | (1L << position);\r\n    else\r\n        return clearBit(v, position);\r\n}"
}, {
	"Path": "org.mockito.internal.exceptions.stacktrace.StackTraceFilter.findSourceFile",
	"Comment": "finds the source file of the target stack trace.returns the default value if source file cannot be found.",
	"Method": "String findSourceFile(StackTraceElement[] target,String defaultValue){\r\n    for (StackTraceElement e : target) {\r\n        if (CLEANER.isIn(e)) {\r\n            return e.getFileName();\r\n        }\r\n    }\r\n    return defaultValue;\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.lce.MvpLceActivity.animateLoadingViewIn",
	"Comment": "override this method if you want to provide your own animation for showing the loading view",
	"Method": "void animateLoadingViewIn(){\r\n    LceAnimator.showLoading(loadingView, contentView, errorView);\r\n}"
}, {
	"Path": "org.mockitoutil.ThrowableAssert.assertThat",
	"Comment": "executes provided runnable, expects it to throw an exception.then, it offers ways to assert on the expected exception.",
	"Method": "ThrowableAssert assertThat(Runnable runnable){\r\n    return new ThrowableAssert(runnable);\r\n}"
}, {
	"Path": "okhttp3.internal.cache.DiskLruCache.getMaxSize",
	"Comment": "returns the maximum number of bytes that this cache should use to store its data.",
	"Method": "long getMaxSize(){\r\n    return maxSize;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.getPaint",
	"Comment": "returns the paint object associated with the provided constant.",
	"Method": "Paint getPaint(int which){\r\n    switch(which) {\r\n        case PAINT_INFO:\r\n            return mInfoPaint;\r\n        case PAINT_DESCRIPTION:\r\n            return mDescPaint;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "okhttp3.mockwebserver.MockResponse.getPushPromises",
	"Comment": "returns the streams the server will push with this response.",
	"Method": "List<PushPromise> getPushPromises(){\r\n    return promises;\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.strings.TrimTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.clustering.binning.Metaphone3.Encode_Greek_X",
	"Comment": "encode x when from greek roots where it is usually pronounced as s",
	"Method": "boolean Encode_Greek_X(){\r\n    if (StringAt((m_current + 1), 3, \"YLO\", \"YLE\", \"ENO\", \"\") || StringAt((m_current + 1), 4, \"ANTH\", \"\")) {\r\n        MetaphAdd(\"S\");\r\n        m_current++;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.common.util.BitFieldUtils.testBit",
	"Comment": "bitfield utilities.returns true if the bit at position is set in v.",
	"Method": "boolean testBit(byte v,int position,boolean testBit,short v,int position,boolean testBit,int v,int position,boolean testBit,long v,int position){\r\n    return (v & (1L << position)) != 0L;\r\n}"
}, {
	"Path": "okhttp3.ConnectionCoalescingTest.skipsWhenCertificatePinningFails",
	"Comment": "certificate pinning used and not a match will avoid coalescing and try to connect.",
	"Method": "void skipsWhenCertificatePinningFails(){\r\n    CertificatePinner pinner = new CertificatePinner.Builder().add(\"san.com\", \"sha1/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=\").build();\r\n    client = client.newBuilder().certificatePinner(pinner).build();\r\n    server.enqueue(new MockResponse().setResponseCode(200));\r\n    assert200Http2Response(execute(url), server.getHostName());\r\n    HttpUrl sanUrl = url.newBuilder().host(\"san.com\").build();\r\n    try {\r\n        execute(sanUrl);\r\n        fail(\"expected a failed attempt to connect\");\r\n    } catch (IOException expected) {\r\n    }\r\n}"
}, {
	"Path": "org.mockito.internal.util.concurrent.WeakConcurrentMap.defaultValue",
	"Comment": "creates a default value. there is no guarantee that the requested value will be set as a once it is createdin case that another thread requests a value for a key concurrently.",
	"Method": "V defaultValue(K key){\r\n    return null;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.renderer.BarLineScatterCandleBubbleRenderer.isInBoundsX",
	"Comment": "checks if the provided entry object is in bounds for drawing considering the current animation phase.",
	"Method": "boolean isInBoundsX(Entry e,IBarLineScatterCandleBubbleDataSet set){\r\n    if (e == null)\r\n        return false;\r\n    float entryIndex = set.getEntryIndex(e);\r\n    if (e == null || entryIndex >= set.getEntryCount() * mAnimator.getPhaseX()) {\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "okhttp3.InterceptorTest.interceptorMakesAnUnrelatedRequest",
	"Comment": "make sure interceptors can interact with the okhttp client.",
	"Method": "void interceptorMakesAnUnrelatedRequest(){\r\n    server.enqueue(new MockResponse().setBody(\"a\"));\r\n    server.enqueue(new MockResponse().setBody(\"b\"));\r\n    client = client.newBuilder().addInterceptor(new Interceptor() {\r\n        @Override\r\n        public Response intercept(Chain chain) throws IOException {\r\n            if (chain.request().url().encodedPath().equals(\"/b\")) {\r\n                Request requestA = new Request.Builder().url(server.url(\"/a\")).build();\r\n                Response responseA = client.newCall(requestA).execute();\r\n                assertEquals(\"a\", responseA.body().string());\r\n            }\r\n            return chain.proceed(chain.request());\r\n        }\r\n    }).build();\r\n    Request requestB = new Request.Builder().url(server.url(\"/b\")).build();\r\n    Response responseB = client.newCall(requestB).execute();\r\n    assertEquals(\"b\", responseB.body().string());\r\n}"
}, {
	"Path": "okhttp3.InterceptorTest.interceptorMakesAnUnrelatedRequest",
	"Comment": "make sure interceptors can interact with the okhttp client.",
	"Method": "void interceptorMakesAnUnrelatedRequest(){\r\n    if (chain.request().url().encodedPath().equals(\"/b\")) {\r\n        Request requestA = new Request.Builder().url(server.url(\"/a\")).build();\r\n        Response responseA = client.newCall(requestA).execute();\r\n        assertEquals(\"a\", responseA.body().string());\r\n    }\r\n    return chain.proceed(chain.request());\r\n}"
}, {
	"Path": "org.openrefine.wikidata.updates.ItemUpdate.normalizeLabelsAndAliases",
	"Comment": "this should only be used when creating a new item. this ensures that we neveradd an alias without adding a label in the same language.",
	"Method": "ItemUpdate normalizeLabelsAndAliases(){\r\n    Set<String> labelLanguages = labels.stream().map(l -> l.getLanguageCode()).collect(Collectors.toSet());\r\n    Set<MonolingualTextValue> filteredAliases = new HashSet();\r\n    Set<MonolingualTextValue> newLabels = new HashSet(labels);\r\n    for (MonolingualTextValue alias : aliases) {\r\n        if (!labelLanguages.contains(alias.getLanguageCode())) {\r\n            labelLanguages.add(alias.getLanguageCode());\r\n            newLabels.add(alias);\r\n        } else {\r\n            filteredAliases.add(alias);\r\n        }\r\n    }\r\n    return new ItemUpdate(qid, addedStatements, deletedStatements, newLabels, descriptions, filteredAliases);\r\n}"
}, {
	"Path": "org.mockito.junit.MockitoJUnit.collector",
	"Comment": "creates a rule instance that can perform lazy verifications.",
	"Method": "VerificationCollector collector(){\r\n    return new VerificationCollectorImpl();\r\n}"
}, {
	"Path": "org.apache.ibatis.io.ResolverUtil.getClassLoader",
	"Comment": "returns the classloader that will be used for scanning for classes. if no explicitclassloader has been set by the calling, the context class loader will be used.",
	"Method": "ClassLoader getClassLoader(){\r\n    return classloader == null ? Thread.currentThread().getContextClassLoader() : classloader;\r\n}"
}, {
	"Path": "okhttp3.CallTest.preemptiveProxyAuthentication",
	"Comment": "confirm that we can send authentication information without being prompted first.",
	"Method": "void preemptiveProxyAuthentication(){\r\n    server.useHttps(handshakeCertificates.sslSocketFactory(), true);\r\n    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());\r\n    server.enqueue(new MockResponse().setBody(\"encrypted response from the origin server\"));\r\n    final String credential = Credentials.basic(\"jesse\", \"password1\");\r\n    client = client.newBuilder().sslSocketFactory(handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager()).proxy(server.toProxyAddress()).hostnameVerifier(new RecordingHostnameVerifier()).proxyAuthenticator(new Authenticator() {\r\n        @Override\r\n        public Request authenticate(Route route, Response response) {\r\n            assertEquals(\"CONNECT\", response.request().method());\r\n            assertEquals(HttpURLConnection.HTTP_PROXY_AUTH, response.code());\r\n            assertEquals(\"android.com\", response.request().url().host());\r\n            List<Challenge> challenges = response.challenges();\r\n            assertEquals(\"OkHttp-Preemptive\", challenges.get(0).scheme());\r\n            return response.request().newBuilder().header(\"Proxy-Authorization\", credential).build();\r\n        }\r\n    }).build();\r\n    Request request = new Request.Builder().url(\"https://android.com/foo\").build();\r\n    executeSynchronously(request).assertSuccessful();\r\n    RecordedRequest connect = server.takeRequest();\r\n    assertEquals(\"CONNECT\", connect.getMethod());\r\n    assertEquals(credential, connect.getHeader(\"Proxy-Authorization\"));\r\n    assertEquals(\"/\", connect.getPath());\r\n    RecordedRequest get = server.takeRequest();\r\n    assertEquals(\"GET\", get.getMethod());\r\n    assertNull(get.getHeader(\"Proxy-Authorization\"));\r\n    assertEquals(\"/foo\", get.getPath());\r\n}"
}, {
	"Path": "okhttp3.CallTest.preemptiveProxyAuthentication",
	"Comment": "confirm that we can send authentication information without being prompted first.",
	"Method": "void preemptiveProxyAuthentication(){\r\n    assertEquals(\"CONNECT\", response.request().method());\r\n    assertEquals(HttpURLConnection.HTTP_PROXY_AUTH, response.code());\r\n    assertEquals(\"android.com\", response.request().url().host());\r\n    List<Challenge> challenges = response.challenges();\r\n    assertEquals(\"OkHttp-Preemptive\", challenges.get(0).scheme());\r\n    return response.request().newBuilder().header(\"Proxy-Authorization\", credential).build();\r\n}"
}, {
	"Path": "okhttp3.AndroidShimResponseCache.getNetworkCount",
	"Comment": "returns the number of http requests that required the network to either supply a response orvalidate a locally cached response.",
	"Method": "int getNetworkCount(){\r\n    return delegate.networkCount();\r\n}"
}, {
	"Path": "com.google.refine.ProjectManager.isValidUserMetadataDefinition",
	"Comment": "a valid user meta data definition should have name and display property",
	"Method": "boolean isValidUserMetadataDefinition(ObjectNode placeHolderJsonObj){\r\n    return (placeHolderJsonObj != null && placeHolderJsonObj.has(\"name\") && placeHolderJsonObj.has(\"display\"));\r\n}"
}, {
	"Path": "org.mockito.internal.util.reflection.FieldInitializer.initialize",
	"Comment": "initialize field if not initialized and return the actual instance.",
	"Method": "FieldInitializationReport initialize(){\r\n    final AccessibilityChanger changer = new AccessibilityChanger();\r\n    changer.enableAccess(field);\r\n    try {\r\n        return acquireFieldInstance();\r\n    } catch (IllegalAccessException e) {\r\n        throw new MockitoException(\"Problems initializing field '\" + field.getName() + \"' of type '\" + field.getType().getSimpleName() + \"'\", e);\r\n    } finally {\r\n        changer.safelyDisableAccess(field);\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.isDragEnabled",
	"Comment": "returns true if dragging is enabled for the chart, false if not.",
	"Method": "boolean isDragEnabled(){\r\n    return mDragXEnabled || mDragYEnabled;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.YAxis.setSpaceTop",
	"Comment": "sets the top axis space in percent of the full range. default 10f",
	"Method": "void setSpaceTop(float percent){\r\n    mSpacePercentTop = percent;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.BubbleData.setHighlightCircleWidth",
	"Comment": "sets the width of the circle that surrounds the bubble when highlightedfor all dataset objects this data object contains, in dp.",
	"Method": "void setHighlightCircleWidth(float width){\r\n    for (IBubbleDataSet set : mDataSets) {\r\n        set.setHighlightCircleWidth(width);\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.datasource.pooled.PooledConnection.getCheckoutTime",
	"Comment": "getter for the time that this connection has been checked out",
	"Method": "long getCheckoutTime(){\r\n    return System.currentTimeMillis() - checkoutTimestamp;\r\n}"
}, {
	"Path": "okhttp3.android.HttpResponseCache.getNetworkCount",
	"Comment": "returns the number of http requests that required the network to either supply a response orvalidate a locally cached response.",
	"Method": "int getNetworkCount(){\r\n    return shimResponseCache.getNetworkCount();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.AxisBase.setGridLineWidth",
	"Comment": "sets the width of the grid lines that are drawn away from each axislabel.",
	"Method": "void setGridLineWidth(float width){\r\n    mGridLineWidth = Utils.convertDpToPixel(width);\r\n}"
}, {
	"Path": "org.mockitousage.stubbing.DeepStubbingTest.withPatternPrimitive",
	"Comment": "test that deep stubbing work with primitive expected values withpattern method arguments",
	"Method": "void withPatternPrimitive(){\r\n    int a = 12, b = 23, c = 34;\r\n    SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\r\n    when(sf.createSocket(eq(\"stackoverflow.com\"), eq(80)).getPort()).thenReturn(a);\r\n    when(sf.createSocket(eq(\"google.com\"), anyInt()).getPort()).thenReturn(b);\r\n    when(sf.createSocket(eq(\"stackoverflow.com\"), eq(8080)).getPort()).thenReturn(c);\r\n    assertEquals(b, sf.createSocket(\"google.com\", 80).getPort());\r\n    assertEquals(c, sf.createSocket(\"stackoverflow.com\", 8080).getPort());\r\n    assertEquals(a, sf.createSocket(\"stackoverflow.com\", 80).getPort());\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.AxisBase.setGranularity",
	"Comment": "set a minimum interval for the axis when zooming in. the axis is not allowed to go belowthat limit. this can be used to avoid label duplicating when zooming in.",
	"Method": "void setGranularity(float granularity){\r\n    mGranularity = granularity;\r\n    mGranularityEnabled = true;\r\n}"
}, {
	"Path": "okhttp3.HttpUrlTest.hostIPv6Builder",
	"Comment": "the builder permits square braces but does not require them.",
	"Method": "void hostIPv6Builder(){\r\n    HttpUrl base = parse(\"http://example.com/\");\r\n    assertEquals(\"http://[::1]/\", base.newBuilder().host(\"[::1]\").build().toString());\r\n    assertEquals(\"http://[::1]/\", base.newBuilder().host(\"[::0001]\").build().toString());\r\n    assertEquals(\"http://[::1]/\", base.newBuilder().host(\"::1\").build().toString());\r\n    assertEquals(\"http://[::1]/\", base.newBuilder().host(\"::0001\").build().toString());\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.strings.FingerprintTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "org.mockito.internal.util.reflection.Fields.allDeclaredFieldsOf",
	"Comment": "instance fields declared in the class and superclasses of the given instance.",
	"Method": "InstanceFields allDeclaredFieldsOf(Object instance){\r\n    List<InstanceField> instanceFields = new ArrayList<InstanceField>();\r\n    for (Class<?> clazz = instance.getClass(); clazz != Object.class; clazz = clazz.getSuperclass()) {\r\n        instanceFields.addAll(instanceFieldsIn(instance, clazz.getDeclaredFields()));\r\n    }\r\n    return new InstanceFields(instance, instanceFields);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.ComponentBase.getTypeface",
	"Comment": "returns the typeface used for the labels, returns null if none is set",
	"Method": "Typeface getTypeface(){\r\n    return mTypeface;\r\n}"
}, {
	"Path": "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter.anotherCandidateMatchesMockName",
	"Comment": "in this case we have to check whether we have conflicting namingfields. e.g. 2 fields of the same type, but we have to make surewe match on the correct name.therefore we have to go through all other fields and make surewhenever we find a field that does match its name with the mockname, we should take that field instead.",
	"Method": "boolean anotherCandidateMatchesMockName(Collection<Object> mocks,Field candidateFieldToBeInjected,List<Field> allRemainingCandidateFields){\r\n    String mockName = getMockName(mocks.iterator().next()).toString();\r\n    for (Field otherCandidateField : allRemainingCandidateFields) {\r\n        if (!otherCandidateField.equals(candidateFieldToBeInjected) && otherCandidateField.getType().equals(candidateFieldToBeInjected.getType()) && otherCandidateField.getName().equals(mockName)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.html.ParseHtmlTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.executor.BatchExecutorException.getFailingStatementId",
	"Comment": "returns the statement id of the statement that caused the failure",
	"Method": "String getFailingStatementId(){\r\n    return batchResult.getMappedStatement().getId();\r\n}"
}, {
	"Path": "com.google.refine.browsing.filters.ExpressionTimeComparisonRowFilter.checkValue",
	"Comment": "not really needed for operation, just to make extending the abstract class possible",
	"Method": "boolean checkValue(Object v,boolean checkValue,double d,boolean checkValue,long d){\r\n    return false;\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.bootstrap.util.spring.PropertyPlaceholderHelper.substringMatch",
	"Comment": "copy org.springframework.util.stringutilstest whether the given string matches the given substringat the given index.",
	"Method": "boolean substringMatch(CharSequence str,int index,CharSequence substring){\r\n    for (int j = 0; j < substring.length(); j++) {\r\n        int i = index + j;\r\n        if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.ChartData.getEntryCount",
	"Comment": "returns the total entry count across all dataset objects this data object contains.",
	"Method": "int getEntryCount(){\r\n    int count = 0;\r\n    for (T set : mDataSets) {\r\n        count += set.getEntryCount();\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.BarDataSet.calcStackSize",
	"Comment": "calculates the maximum stacksize that occurs in the entries array of thisdataset",
	"Method": "void calcStackSize(List<BarEntry> yVals){\r\n    for (int i = 0; i < yVals.size(); i++) {\r\n        float[] vals = yVals.get(i).getYVals();\r\n        if (vals != null && vals.length > mStackSize)\r\n            mStackSize = vals.length;\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.AxisBase.getGridLineWidth",
	"Comment": "returns the width of the grid lines that are drawn away from each axislabel.",
	"Method": "float getGridLineWidth(){\r\n    return mGridLineWidth;\r\n}"
}, {
	"Path": "okhttp3.Dispatcher.queuedCalls",
	"Comment": "returns a snapshot of the calls currently awaiting execution.",
	"Method": "List<Call> queuedCalls(){\r\n    List<Call> result = new ArrayList();\r\n    for (AsyncCall asyncCall : readyAsyncCalls) {\r\n        result.add(asyncCall.get());\r\n    }\r\n    return Collections.unmodifiableList(result);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.Utils.getSizeOfRotatedRectangleByDegrees",
	"Comment": "returns a recyclable fsize instance.represents size of a rotated rectangle by degrees.",
	"Method": "FSize getSizeOfRotatedRectangleByDegrees(FSize rectangleSize,float degrees,FSize getSizeOfRotatedRectangleByDegrees,float rectangleWidth,float rectangleHeight,float degrees){\r\n    final float radians = degrees * FDEG2RAD;\r\n    return getSizeOfRotatedRectangleByRadians(rectangleWidth, rectangleHeight, radians);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.renderer.PieChartRenderer.getSliceSpace",
	"Comment": "calculates the slicespace to use based on visible values and their size compared to the set slicespace.",
	"Method": "float getSliceSpace(IPieDataSet dataSet){\r\n    if (!dataSet.isAutomaticallyDisableSliceSpacingEnabled())\r\n        return dataSet.getSliceSpace();\r\n    float spaceSizeRatio = dataSet.getSliceSpace() / mViewPortHandler.getSmallestContentExtension();\r\n    float minValueRatio = dataSet.getYMin() / mChart.getData().getYValueSum() * 2;\r\n    float sliceSpace = spaceSizeRatio > minValueRatio ? 0f : dataSet.getSliceSpace();\r\n    return sliceSpace;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.Description.setPosition",
	"Comment": "sets a custom position for the description text in pixels on the screen.",
	"Method": "void setPosition(float x,float y){\r\n    if (mPosition == null) {\r\n        mPosition = MPPointF.getInstance(x, y);\r\n    } else {\r\n        mPosition.x = x;\r\n        mPosition.y = y;\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.clustering.binning.Metaphone3.Interpolate_Vowel_When_Cons_L_At_End",
	"Comment": "cases where an l follows d, g, or t at the\tend have a schwa pronounced before the l",
	"Method": "void Interpolate_Vowel_When_Cons_L_At_End(){\r\n    if (m_encodeVowels == true) {\r\n        if ((m_current == m_last) && StringAt((m_current - 1), 1, \"D\", \"G\", \"T\", \"\")) {\r\n            MetaphAdd(\"A\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.common.util.jsr166.ConcurrentWeakHashMap.segmentFor",
	"Comment": "returns the segment that should be used for key with given hash",
	"Method": "Segment<K, V> segmentFor(int hash){\r\n    return segments[(hash >>> segmentShift) & segmentMask];\r\n}"
}, {
	"Path": "org.mockito.internal.util.Primitives.isPrimitiveOrWrapper",
	"Comment": "indicates if the given class is primitive type or a primitive wrapper.",
	"Method": "boolean isPrimitiveOrWrapper(Class<?> type){\r\n    return PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.containsKey(type);\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvi.MviActivity.getMvpDelegate",
	"Comment": "get the mvp delegate. this is internally used for creating presenter, attaching and detachingviewstate from presenter.please note that only one instance of mvp delegate should be used per activityinstance.only override this method if you really know what you are doing.",
	"Method": "ActivityMviDelegate<V, P> getMvpDelegate(){\r\n    if (mvpDelegate == null) {\r\n        mvpDelegate = new ActivityMviDelegateImpl<V, P>(this, this);\r\n    }\r\n    return mvpDelegate;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.ChartData.isHighlightEnabled",
	"Comment": "returns true if highlighting of all underlying values is enabled, falseif not.",
	"Method": "boolean isHighlightEnabled(){\r\n    for (IDataSet set : mDataSets) {\r\n        if (!set.isHighlightEnabled())\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.ibatis.datasource.pooled.PooledConnection.setCheckoutTimestamp",
	"Comment": "setter for the timestamp that this connection was checked out",
	"Method": "void setCheckoutTimestamp(long timestamp){\r\n    this.checkoutTimestamp = timestamp;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.Legend.setDrawInside",
	"Comment": "sets whether the legend will draw inside the chart or outside",
	"Method": "void setDrawInside(boolean value){\r\n    mDrawInside = value;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.LineDataSet.setCircleColor",
	"Comment": "sets the one and only color that should be used for this dataset.internally, this recreates the colors array and adds the specified color.",
	"Method": "void setCircleColor(int color){\r\n    resetCircleColors();\r\n    mCircleColors.add(color);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.listener.BarLineChartTouchListener.getTrans",
	"Comment": "returns a recyclable mppointf instance.returns the correct translation depending on the provided x and y touchpoints",
	"Method": "MPPointF getTrans(float x,float y){\r\n    ViewPortHandler vph = mChart.getViewPortHandler();\r\n    float xTrans = x - vph.offsetLeft();\r\n    float yTrans = 0f;\r\n    if (inverted()) {\r\n        yTrans = -(y - vph.offsetTop());\r\n    } else {\r\n        yTrans = -(mChart.getMeasuredHeight() - y - vph.offsetBottom());\r\n    }\r\n    return MPPointF.getInstance(xTrans, yTrans);\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.booleans.BooleanTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.InterProjectModel.getJoin",
	"Comment": "compute the projectjoin based on combination key, return the cached one from the hashmap if already computed",
	"Method": "ProjectJoin getJoin(String fromProject,String fromColumn,String toProject,String toColumn){\r\n    String key = fromProject + \";\" + fromColumn + \";\" + toProject + \";\" + toColumn;\r\n    if (!_joins.containsKey(key)) {\r\n        ProjectJoin join = new ProjectJoin(ProjectManager.singleton.getProjectID(fromProject), fromColumn, ProjectManager.singleton.getProjectID(toProject), toColumn);\r\n        computeJoin(join);\r\n        synchronized (_joins) {\r\n            _joins.put(key, join);\r\n        }\r\n    }\r\n    return _joins.get(key);\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testGetNamesAndItems",
	"Comment": "this test shows how to call procedures that return multiple result sets",
	"Method": "void testGetNamesAndItems(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        List<List<?>> results = spMapper.getNamesAndItems();\r\n        assertEquals(2, results.size());\r\n        assertEquals(4, results.get(0).size());\r\n        assertEquals(3, results.get(1).size());\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testCallWithResultSet2_a2",
	"Comment": "this test shows how to use a input and output parameters and return aresult set from a stored procedure.this test shows using a single value parameter.this test shows using annotations for stored procedures and using aresultmap in xml",
	"Method": "void testCallWithResultSet2_a2(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        Map<String, Object> parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 1);\r\n        List<Name> names = spMapper.getNamesAnnotatedWithXMLResultMap(parms);\r\n        assertEquals(3, names.size());\r\n        assertEquals(3, parms.get(\"totalRows\"));\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testCallWithResultSet2_a1",
	"Comment": "this test shows how to use a input and output parameters and return aresult set from a stored procedure.this test shows using a single value parameter.this test shows using annotations for stored procedures",
	"Method": "void testCallWithResultSet2_a1(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        Map<String, Object> parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 1);\r\n        List<Name> names = spMapper.getNamesAnnotated(parms);\r\n        assertEquals(3, names.size());\r\n        assertEquals(3, parms.get(\"totalRows\"));\r\n    }\r\n}"
}, {
	"Path": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.reflectionEquals",
	"Comment": "this method uses reflection to determine if the two objectsare equal.it uses accessibleobject.setaccessible to gain access to privatefields. this means that it will throw a security exception if run undera security manager, if the permissions are not set up correctly. it is alsonot as efficient as testing explicitly.if the testtransients parameter is set to true, transientmembers will be tested, otherwise they are ignored, as they are likelyderived fields, and not part of the value of the object.static fields will not be included. superclass fields will be appendedup to and including the specified superclass. a null superclass is treatedas java.lang.object.",
	"Method": "boolean reflectionEquals(Object lhs,Object rhs,boolean reflectionEquals,Object lhs,Object rhs,String[] excludeFields,boolean reflectionEquals,Object lhs,Object rhs,boolean testTransients,boolean reflectionEquals,Object lhs,Object rhs,boolean testTransients,Class<?> reflectUpToClass,boolean reflectionEquals,Object lhs,Object rhs,boolean testTransients,Class<?> reflectUpToClass,String[] excludeFields){\r\n    if (lhs == rhs) {\r\n        return true;\r\n    }\r\n    if (lhs == null || rhs == null) {\r\n        return false;\r\n    }\r\n    Class<?> lhsClass = lhs.getClass();\r\n    Class<?> rhsClass = rhs.getClass();\r\n    Class<?> testClass;\r\n    if (lhsClass.isInstance(rhs)) {\r\n        testClass = lhsClass;\r\n        if (!rhsClass.isInstance(lhs)) {\r\n            testClass = rhsClass;\r\n        }\r\n    } else if (rhsClass.isInstance(lhs)) {\r\n        testClass = rhsClass;\r\n        if (!lhsClass.isInstance(rhs)) {\r\n            testClass = lhsClass;\r\n        }\r\n    } else {\r\n        return false;\r\n    }\r\n    EqualsBuilder equalsBuilder = new EqualsBuilder();\r\n    try {\r\n        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\r\n        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\r\n            testClass = testClass.getSuperclass();\r\n            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\r\n        }\r\n    } catch (IllegalArgumentException e) {\r\n        return false;\r\n    }\r\n    return equalsBuilder.isEquals();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.PieChart.setUsePercentValues",
	"Comment": "if this is enabled, values inside the piechart are drawn in percent andnot with their original value. values provided for the ivalueformatter toformat are then provided in percent.",
	"Method": "void setUsePercentValues(boolean enabled){\r\n    mUsePercentValues = enabled;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.BaseDataSet.resetColors",
	"Comment": "resets all colors of this dataset and recreates the colors array.",
	"Method": "void resetColors(){\r\n    if (mColors == null) {\r\n        mColors = new ArrayList<Integer>();\r\n    }\r\n    mColors.clear();\r\n}"
}, {
	"Path": "okhttp3.mockwebserver.RecordedRequest.getSequenceNumber",
	"Comment": "returns the index of this request on its http connection. since a single http connection mayserve multiple requests, each request is assigned its own sequence number.",
	"Method": "int getSequenceNumber(){\r\n    return sequenceNumber;\r\n}"
}, {
	"Path": "org.apache.ibatis.datasource.pooled.PooledDataSource.setPoolMaximumCheckoutTime",
	"Comment": "the maximum time a connection can be used before itgiven away again.",
	"Method": "void setPoolMaximumCheckoutTime(int poolMaximumCheckoutTime){\r\n    this.poolMaximumCheckoutTime = poolMaximumCheckoutTime;\r\n    forceCloseAll();\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonWriter.checkStack",
	"Comment": "before pushing a value on the stack this confirms that the stack has capacity.",
	"Method": "boolean checkStack(){\r\n    if (stackSize != scopes.length)\r\n        return false;\r\n    if (stackSize == 256) {\r\n        throw new JsonDataException(\"Nesting too deep at \" + getPath() + \": circular reference?\");\r\n    }\r\n    scopes = Arrays.copyOf(scopes, scopes.length * 2);\r\n    pathNames = Arrays.copyOf(pathNames, pathNames.length * 2);\r\n    pathIndices = Arrays.copyOf(pathIndices, pathIndices.length * 2);\r\n    if (this instanceof JsonValueWriter) {\r\n        ((JsonValueWriter) this).stack = Arrays.copyOf(((JsonValueWriter) this).stack, ((JsonValueWriter) this).stack.length * 2);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonUtf8Writer.beforeValue",
	"Comment": "inserts any necessary separators and whitespace before a literal value,inline array, or inline object. also adjusts the stack to expect either aclosing bracket or another element.",
	"Method": "void beforeValue(){\r\n    switch(peekScope()) {\r\n        case NONEMPTY_DOCUMENT:\r\n            if (!lenient) {\r\n                throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n            }\r\n        case EMPTY_DOCUMENT:\r\n            replaceTop(NONEMPTY_DOCUMENT);\r\n            break;\r\n        case EMPTY_ARRAY:\r\n            replaceTop(NONEMPTY_ARRAY);\r\n            newline();\r\n            break;\r\n        case NONEMPTY_ARRAY:\r\n            sink.writeByte(',');\r\n            newline();\r\n            break;\r\n        case DANGLING_NAME:\r\n            sink.writeUtf8(separator);\r\n            replaceTop(NONEMPTY_OBJECT);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n}"
}, {
	"Path": "okhttp3.Address.url",
	"Comment": "returns a url with the hostname and port of the origin server. the path, query, and fragment ofthis url are always empty, since they are not significant for planning a route.",
	"Method": "HttpUrl url(){\r\n    return url;\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonReaderTest.selectNameNecessaryEscaping",
	"Comment": "select does match necessarily escaping. the decoded value is used in the path.",
	"Method": "void selectNameNecessaryEscaping(){\r\n    JsonReader.Options options = JsonReader.Options.of(\"\\n\", \"\", \"\\\"\");\r\n    JsonReader reader = newReader(\"{\\\"\\\\n\\\": 5,\\\"\\\\\\": 5, \\\"\\\\\\\"\\\": 5}\");\r\n    reader.beginObject();\r\n    assertEquals(0, reader.selectName(options));\r\n    assertEquals(5, reader.nextInt());\r\n    assertEquals(\"$.\\n\", reader.getPath());\r\n    assertEquals(1, reader.selectName(options));\r\n    assertEquals(5, reader.nextInt());\r\n    assertEquals(\"$.\", reader.getPath());\r\n    assertEquals(2, reader.selectName(options));\r\n    assertEquals(5, reader.nextInt());\r\n    assertEquals(\"$.\\\"\", reader.getPath());\r\n    reader.endObject();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.centerViewToAnimated",
	"Comment": "this will move the center of the current viewport to the specifiedx and y value animated.",
	"Method": "void centerViewToAnimated(float xValue,float yValue,AxisDependency axis,long duration){\r\n    MPPointD bounds = getValuesByTouchPoint(mViewPortHandler.contentLeft(), mViewPortHandler.contentTop(), axis);\r\n    float yInView = getAxisRange(axis) / mViewPortHandler.getScaleY();\r\n    float xInView = getXAxis().mAxisRange / mViewPortHandler.getScaleX();\r\n    Runnable job = AnimatedMoveViewJob.getInstance(mViewPortHandler, xValue - xInView / 2f, yValue + yInView / 2f, getTransformer(axis), this, (float) bounds.x, (float) bounds.y, duration);\r\n    addViewportJob(job);\r\n    MPPointD.recycleInstance(bounds);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.ChartData.notifyDataChanged",
	"Comment": "call this method to let the chartdata know that the underlying data haschanged. calling this performs all necessary recalculations needed whenthe contained data has changed.",
	"Method": "void notifyDataChanged(){\r\n    calcMinMax();\r\n}"
}, {
	"Path": "org.apache.ibatis.io.VFS.list",
	"Comment": "recursively list the full resource path of all the resources that are children of all theresources found at the specified path.",
	"Method": "List<String> list(URL url,String forPath,List<String> list,String path){\r\n    List<String> names = new ArrayList();\r\n    for (URL url : getResources(path)) {\r\n        names.addAll(list(url, path));\r\n    }\r\n    return names;\r\n}"
}, {
	"Path": "org.openrefine.wikidata.schema.ExpressionContext.getCellByName",
	"Comment": "retrieves a cell in the current row, by column name. if the column does notexist, null is returned.",
	"Method": "Cell getCellByName(String name){\r\n    Column column = columnModel.getColumnByName(name);\r\n    if (column != null) {\r\n        int idx = column.getCellIndex();\r\n        return row.getCell(idx);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.FunctionTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.MvpDialogFragment.getMvpDelegate",
	"Comment": "get the mvp delegate. this is internally used for creating presenter, attaching anddetaching view from presenter.please note that only one instance of mvp delegate should be used per fragmentinstance.only override this method if you really know what you are doing.",
	"Method": "FragmentMvpDelegate<V, P> getMvpDelegate(){\r\n    if (mvpDelegate == null) {\r\n        mvpDelegate = new FragmentMvpDelegateImpl(this, this, true, true);\r\n    }\r\n    return mvpDelegate;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.listener.ChartTouchListener.getLastGesture",
	"Comment": "returns the last gesture that has been performed on the chart.",
	"Method": "ChartGesture getLastGesture(){\r\n    return mLastGesture;\r\n}"
}, {
	"Path": "org.openrefine.wikidata.updates.ItemUpdateBuilder.deleteStatement",
	"Comment": "mark a statement for deletion. if no such statement exists, nothing will bedeleted.",
	"Method": "ItemUpdateBuilder deleteStatement(Statement statement){\r\n    Validate.isTrue(!built, \"ItemUpdate has already been built\");\r\n    deletedStatements.add(statement);\r\n    return this;\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.lenient",
	"Comment": "returns a json adapter equal to this, but is lenient when reading and writing.",
	"Method": "JsonAdapter<T> lenient(){\r\n    final JsonAdapter<T> delegate = this;\r\n    return new JsonAdapter<T>() {\r\n        @Override\r\n        @Nullable\r\n        public T fromJson(JsonReader reader) throws IOException {\r\n            boolean lenient = reader.isLenient();\r\n            reader.setLenient(true);\r\n            try {\r\n                return delegate.fromJson(reader);\r\n            } finally {\r\n                reader.setLenient(lenient);\r\n            }\r\n        }\r\n        @Override\r\n        public void toJson(JsonWriter writer, @Nullable T value) throws IOException {\r\n            boolean lenient = writer.isLenient();\r\n            writer.setLenient(true);\r\n            try {\r\n                delegate.toJson(writer, value);\r\n            } finally {\r\n                writer.setLenient(lenient);\r\n            }\r\n        }\r\n        @Override\r\n        boolean isLenient() {\r\n            return true;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return delegate + \".lenient()\";\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.lenient",
	"Comment": "returns a json adapter equal to this, but is lenient when reading and writing.",
	"Method": "JsonAdapter<T> lenient(){\r\n    boolean lenient = reader.isLenient();\r\n    reader.setLenient(true);\r\n    try {\r\n        return delegate.fromJson(reader);\r\n    } finally {\r\n        reader.setLenient(lenient);\r\n    }\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.lenient",
	"Comment": "returns a json adapter equal to this, but is lenient when reading and writing.",
	"Method": "JsonAdapter<T> lenient(){\r\n    boolean lenient = writer.isLenient();\r\n    writer.setLenient(true);\r\n    try {\r\n        delegate.toJson(writer, value);\r\n    } finally {\r\n        writer.setLenient(lenient);\r\n    }\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.lenient",
	"Comment": "returns a json adapter equal to this, but is lenient when reading and writing.",
	"Method": "JsonAdapter<T> lenient(){\r\n    return true;\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.lenient",
	"Comment": "returns a json adapter equal to this, but is lenient when reading and writing.",
	"Method": "JsonAdapter<T> lenient(){\r\n    return delegate + \".lenient()\";\r\n}"
}, {
	"Path": "com.github.mikephil.charting.renderer.AxisRenderer.computeAxisValues",
	"Comment": "sets up the axis values. computes the desired number of labels between the two given extremes.",
	"Method": "void computeAxisValues(float min,float max){\r\n    float yMin = min;\r\n    float yMax = max;\r\n    int labelCount = mAxis.getLabelCount();\r\n    double range = Math.abs(yMax - yMin);\r\n    if (labelCount == 0 || range <= 0 || Double.isInfinite(range)) {\r\n        mAxis.mEntries = new float[] {};\r\n        mAxis.mCenteredEntries = new float[] {};\r\n        mAxis.mEntryCount = 0;\r\n        return;\r\n    }\r\n    double rawInterval = range / labelCount;\r\n    double interval = Utils.roundToNextSignificant(rawInterval);\r\n    if (mAxis.isGranularityEnabled())\r\n        interval = interval < mAxis.getGranularity() ? mAxis.getGranularity() : interval;\r\n    double intervalMagnitude = Utils.roundToNextSignificant(Math.pow(10, (int) Math.log10(interval)));\r\n    int intervalSigDigit = (int) (interval / intervalMagnitude);\r\n    if (intervalSigDigit > 5) {\r\n        interval = Math.floor(10 * intervalMagnitude);\r\n    }\r\n    int n = mAxis.isCenterAxisLabelsEnabled() ? 1 : 0;\r\n    if (mAxis.isForceLabelsEnabled()) {\r\n        interval = (float) range / (float) (labelCount - 1);\r\n        mAxis.mEntryCount = labelCount;\r\n        if (mAxis.mEntries.length < labelCount) {\r\n            mAxis.mEntries = new float[labelCount];\r\n        }\r\n        float v = min;\r\n        for (int i = 0; i < labelCount; i++) {\r\n            mAxis.mEntries[i] = v;\r\n            v += interval;\r\n        }\r\n        n = labelCount;\r\n    } else {\r\n        double first = interval == 0.0 ? 0.0 : Math.ceil(yMin / interval) * interval;\r\n        if (mAxis.isCenterAxisLabelsEnabled()) {\r\n            first -= interval;\r\n        }\r\n        double last = interval == 0.0 ? 0.0 : Utils.nextUp(Math.floor(yMax / interval) * interval);\r\n        double f;\r\n        int i;\r\n        if (interval != 0.0) {\r\n            for (f = first; f <= last; f += interval) {\r\n                ++n;\r\n            }\r\n        }\r\n        mAxis.mEntryCount = n;\r\n        if (mAxis.mEntries.length < n) {\r\n            mAxis.mEntries = new float[n];\r\n        }\r\n        for (f = first, i = 0; i < n; f += interval, ++i) {\r\n            if (f == 0.0)\r\n                f = 0.0;\r\n            mAxis.mEntries[i] = (float) f;\r\n        }\r\n    }\r\n    if (interval < 1) {\r\n        mAxis.mDecimals = (int) Math.ceil(-Math.log10(interval));\r\n    } else {\r\n        mAxis.mDecimals = 0;\r\n    }\r\n    if (mAxis.isCenterAxisLabelsEnabled()) {\r\n        if (mAxis.mCenteredEntries.length < n) {\r\n            mAxis.mCenteredEntries = new float[n];\r\n        }\r\n        float offset = (float) interval / 2f;\r\n        for (int i = 0; i < n; i++) {\r\n            mAxis.mCenteredEntries[i] = mAxis.mEntries[i] + offset;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.executor.statement.StatementUtil.applyTransactionTimeout",
	"Comment": "apply a transaction timeout.update a query timeout to apply a transaction timeout.",
	"Method": "void applyTransactionTimeout(Statement statement,Integer queryTimeout,Integer transactionTimeout){\r\n    if (transactionTimeout == null) {\r\n        return;\r\n    }\r\n    Integer timeToLiveOfQuery = null;\r\n    if (queryTimeout == null || queryTimeout == 0) {\r\n        timeToLiveOfQuery = transactionTimeout;\r\n    } else if (transactionTimeout < queryTimeout) {\r\n        timeToLiveOfQuery = transactionTimeout;\r\n    }\r\n    if (timeToLiveOfQuery != null) {\r\n        statement.setQueryTimeout(timeToLiveOfQuery);\r\n    }\r\n}"
}, {
	"Path": "org.mockito.internal.util.io.IOUtil.close",
	"Comment": "closes the target. does nothing when target is null. is not silent and exceptions are rethrown.",
	"Method": "void close(Closeable closeable){\r\n    if (closeable != null) {\r\n        try {\r\n            closeable.close();\r\n        } catch (IOException e) {\r\n            throw new MockitoException(\"Problems closing stream: \" + closeable, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.clustering.binning.Metaphone3.SlavoGermanic",
	"Comment": "detect names or words that begin with spellings\ttypical of german or slavic words, for the purpose\tof choosing alternate pronunciations correctly",
	"Method": "boolean SlavoGermanic(){\r\n    if (StringAt(0, 3, \"SCH\", \"\") || StringAt(0, 2, \"SW\", \"\") || (CharAt(0) == 'J') || (CharAt(0) == 'W')) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "okhttp3.ConnectionCoalescingTest.prefersExistingCompatible",
	"Comment": "check we would use an existing connection to a later dns result instead of connecting to thefirst dns result for the first time.",
	"Method": "void prefersExistingCompatible(){\r\n    server.enqueue(new MockResponse().setResponseCode(200));\r\n    server.enqueue(new MockResponse().setResponseCode(200));\r\n    final AtomicInteger connectCount = new AtomicInteger();\r\n    EventListener listener = new EventListener() {\r\n        @Override\r\n        public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {\r\n            connectCount.getAndIncrement();\r\n        }\r\n    };\r\n    client = client.newBuilder().eventListener(listener).build();\r\n    assert200Http2Response(execute(url), server.getHostName());\r\n    HttpUrl sanUrl = url.newBuilder().host(\"san.com\").build();\r\n    dns.set(\"san.com\", Arrays.asList(InetAddress.getByAddress(\"san.com\", new byte[] { 0, 0, 0, 0 }), serverIps.get(0)));\r\n    assert200Http2Response(execute(sanUrl), \"san.com\");\r\n    assertEquals(1, client.connectionPool().connectionCount());\r\n    assertEquals(1, connectCount.get());\r\n}"
}, {
	"Path": "okhttp3.ConnectionCoalescingTest.prefersExistingCompatible",
	"Comment": "check we would use an existing connection to a later dns result instead of connecting to thefirst dns result for the first time.",
	"Method": "void prefersExistingCompatible(){\r\n    connectCount.getAndIncrement();\r\n}"
}, {
	"Path": "com.google.refine.ProjectManager.getProjectMetadata",
	"Comment": "gets the project metadata from memoryrequires that the metadata has already been loaded from the data store",
	"Method": "ProjectMetadata getProjectMetadata(long id,ProjectMetadata getProjectMetadata,String name){\r\n    for (ProjectMetadata pm : _projectsMetadata.values()) {\r\n        if (pm.getName().equals(name)) {\r\n            return pm;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.strings.RangeTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.io.ProjectMetadataUtilities.recover",
	"Comment": "reconstruct the project metadata on a best efforts basis.the name isgone, so build something descriptive from the column names.recover thecreation and modification times based on whatever files are available.",
	"Method": "ProjectMetadata recover(File projectDir,long id){\r\n    ProjectMetadata pm = null;\r\n    Project p = ProjectUtilities.load(projectDir, id);\r\n    if (p != null) {\r\n        List<String> columnNames = p.columnModel.getColumnNames();\r\n        String tempName = \"<recovered project> - \" + columnNames.size() + \" cols X \" + p.rows.size() + \" rows - \" + StringUtils.join(columnNames, '|');\r\n        p.dispose();\r\n        long ctime = System.currentTimeMillis();\r\n        long mtime = 0;\r\n        File dataFile = new File(projectDir, \"data.zip\");\r\n        ctime = mtime = dataFile.lastModified();\r\n        File historyDir = new File(projectDir, \"history\");\r\n        File[] files = historyDir.listFiles();\r\n        if (files != null) {\r\n            for (File f : files) {\r\n                long time = f.lastModified();\r\n                ctime = Math.min(ctime, time);\r\n                mtime = Math.max(mtime, time);\r\n            }\r\n        }\r\n        pm = new ProjectMetadata(LocalDateTime.ofInstant(Instant.ofEpochMilli(ctime), ZoneId.systemDefault()), LocalDateTime.ofInstant(Instant.ofEpochMilli(mtime), ZoneId.systemDefault()), tempName);\r\n        logger.error(\"Partially recovered missing metadata project in directory \" + projectDir + \" - \" + tempName);\r\n    }\r\n    return pm;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarChart.isDrawValueAboveBarEnabled",
	"Comment": "returns true if drawing values above bars is enabled, false if not",
	"Method": "boolean isDrawValueAboveBarEnabled(){\r\n    return mDrawValueAboveBar;\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.bootstrap.context.SpanId.getRandom",
	"Comment": "if you need to change random implementation, modify this method.",
	"Method": "Random getRandom(){\r\n    return ThreadLocalRandomUtils.current();\r\n}"
}, {
	"Path": "okhttp3.android.HttpResponseCache.maxSize",
	"Comment": "returns the maximum number of bytes that this cache should use to store its data.",
	"Method": "long maxSize(){\r\n    return shimResponseCache.maxSize();\r\n}"
}, {
	"Path": "org.mockito.internal.invocation.InvocationBuilder.toInvocation",
	"Comment": "build the invocationif the method was not specified, use imethods methods.",
	"Method": "Invocation toInvocation(){\r\n    if (method == null) {\r\n        if (argTypes == null) {\r\n            argTypes = new LinkedList<Class<?>>();\r\n            for (Object arg : args) {\r\n                if (arg == null) {\r\n                    argTypes.add(Object.class);\r\n                } else {\r\n                    argTypes.add(arg.getClass());\r\n                }\r\n            }\r\n        }\r\n        try {\r\n            method = IMethods.class.getMethod(methodName, argTypes.toArray(new Class[argTypes.size()]));\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"builder only creates invocations of IMethods interface\", e);\r\n        }\r\n    }\r\n    Invocation i = new InterceptedInvocation(new MockStrongReference<Object>(mock, false), new SerializableMethod(method), args, NO_OP, location == null ? new LocationImpl() : location, 1);\r\n    if (verified) {\r\n        i.markVerified();\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "okhttp3.ConnectionCoalescingTest.commonThenAlternative",
	"Comment": "test connecting to the main host then an alternative, although only subject alternative namesare used if present no special consideration of common name.",
	"Method": "void commonThenAlternative(){\r\n    server.enqueue(new MockResponse().setResponseCode(200));\r\n    server.enqueue(new MockResponse().setResponseCode(200));\r\n    assert200Http2Response(execute(url), server.getHostName());\r\n    HttpUrl sanUrl = url.newBuilder().host(\"san.com\").build();\r\n    assert200Http2Response(execute(sanUrl), \"san.com\");\r\n    assertEquals(1, client.connectionPool().connectionCount());\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.Legend.setYEntrySpace",
	"Comment": "sets the space between the legend entries on a vertical axis in pixels,converts to dp internally",
	"Method": "void setYEntrySpace(float space){\r\n    mYEntrySpace = space;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.isDragXEnabled",
	"Comment": "returns true if dragging on the x axis is enabled for the chart, false if not.",
	"Method": "boolean isDragXEnabled(){\r\n    return mDragXEnabled;\r\n}"
}, {
	"Path": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.reflectionAppend",
	"Comment": "appends the fields and values defined by the given object of thegiven class.",
	"Method": "void reflectionAppend(Object lhs,Object rhs,Class<?> clazz,EqualsBuilder builder,boolean useTransients,String[] excludeFields){\r\n    Field[] fields = clazz.getDeclaredFields();\r\n    List<String> excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.<String>emptyList();\r\n    AccessibleObject.setAccessible(fields, true);\r\n    for (int i = 0; i < fields.length && builder.isEquals; i++) {\r\n        Field f = fields[i];\r\n        if (!excludedFieldList.contains(f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) {\r\n            try {\r\n                builder.append(f.get(lhs), f.get(rhs));\r\n            } catch (IllegalAccessException e) {\r\n                throw new InternalError(\"Unexpected IllegalAccessException\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "okhttp3.Cookie.secure",
	"Comment": "returns true if this cookie should be limited to only https requests.",
	"Method": "boolean secure(Builder secure){\r\n    return secure;\r\n}"
}, {
	"Path": "org.openrefine.wikidata.updates.scheduler.PointerExtractor.extractPointers",
	"Comment": "extracts all the new entities mentioned by this list of snak groups.",
	"Method": "Set<ReconItemIdValue> extractPointers(Statement statement,Set<ReconItemIdValue> extractPointers,List<SnakGroup> snakGroups,Set<ReconItemIdValue> extractPointers,SnakGroup snakGroup,Set<ReconItemIdValue> extractPointers,Snak snak,Set<ReconItemIdValue> extractPointers,Value value){\r\n    if (value == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    Set<ReconItemIdValue> pointers = value.accept(this);\r\n    if (pointers == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    return pointers;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.PieData.getDataSet",
	"Comment": "returns the dataset this piedata object represents. a piedata object canonly contain one dataset.",
	"Method": "IPieDataSet getDataSet(){\r\n    return mDataSets.get(0);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.Transformer.rectToPixelPhase",
	"Comment": "transform a rectangle with all matrices with potential animation phases.",
	"Method": "void rectToPixelPhase(RectF r,float phaseY){\r\n    r.top *= phaseY;\r\n    r.bottom *= phaseY;\r\n    mMatrixValueToPx.mapRect(r);\r\n    mViewPortHandler.getMatrixTouch().mapRect(r);\r\n    mMatrixOffset.mapRect(r);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.PieChart.isDrawEntryLabelsEnabled",
	"Comment": "returns true if drawing the entry labels is enabled, false if not.",
	"Method": "boolean isDrawEntryLabelsEnabled(){\r\n    return mDrawEntryLabels;\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.common.trace.DefaultServiceType.isUser",
	"Comment": "return true when the service type is user or can not be identified",
	"Method": "boolean isUser(){\r\n    return this == ServiceType.USER;\r\n}"
}, {
	"Path": "okhttp3.InterceptorTest.interceptorMakesAnUnrelatedAsyncRequest",
	"Comment": "make sure interceptors can interact with the okhttp client asynchronously.",
	"Method": "void interceptorMakesAnUnrelatedAsyncRequest(){\r\n    server.enqueue(new MockResponse().setBody(\"a\"));\r\n    server.enqueue(new MockResponse().setBody(\"b\"));\r\n    client = client.newBuilder().addInterceptor(new Interceptor() {\r\n        @Override\r\n        public Response intercept(Chain chain) throws IOException {\r\n            if (chain.request().url().encodedPath().equals(\"/b\")) {\r\n                Request requestA = new Request.Builder().url(server.url(\"/a\")).build();\r\n                try {\r\n                    RecordingCallback callbackA = new RecordingCallback();\r\n                    client.newCall(requestA).enqueue(callbackA);\r\n                    callbackA.await(requestA.url()).assertBody(\"a\");\r\n                } catch (Exception e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n            return chain.proceed(chain.request());\r\n        }\r\n    }).build();\r\n    Request requestB = new Request.Builder().url(server.url(\"/b\")).build();\r\n    RecordingCallback callbackB = new RecordingCallback();\r\n    client.newCall(requestB).enqueue(callbackB);\r\n    callbackB.await(requestB.url()).assertBody(\"b\");\r\n}"
}, {
	"Path": "okhttp3.InterceptorTest.interceptorMakesAnUnrelatedAsyncRequest",
	"Comment": "make sure interceptors can interact with the okhttp client asynchronously.",
	"Method": "void interceptorMakesAnUnrelatedAsyncRequest(){\r\n    if (chain.request().url().encodedPath().equals(\"/b\")) {\r\n        Request requestA = new Request.Builder().url(server.url(\"/a\")).build();\r\n        try {\r\n            RecordingCallback callbackA = new RecordingCallback();\r\n            client.newCall(requestA).enqueue(callbackA);\r\n            callbackA.await(requestA.url()).assertBody(\"a\");\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n    return chain.proceed(chain.request());\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.Legend.isWordWrapEnabled",
	"Comment": "if this is set, then word wrapping the legend is enabled. this means thelegend will not be cut off if too long.",
	"Method": "boolean isWordWrapEnabled(){\r\n    return mWordWrapEnabled;\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testCallWithResultSet1_a2",
	"Comment": "this test shows how to use an input parameter and return a result set froma stored procedure.this test shows using a single value parameter.this test shows using annotations for stored procedures and using aresultmap in xml",
	"Method": "void testCallWithResultSet1_a2(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        Name name = spMapper.getNameAnnotatedWithXMLResultMap(1);\r\n        assertNotNull(name);\r\n        assertEquals(\"Wilma\", name.getFirstName());\r\n    }\r\n}"
}, {
	"Path": "okhttp3.internal.connection.RouteSelector.connectFailed",
	"Comment": "clients should invoke this method when they encounter a connectivity failure on a connectionreturned by this route selector.",
	"Method": "void connectFailed(Route failedRoute,IOException failure){\r\n    if (failedRoute.proxy().type() != Proxy.Type.DIRECT && address.proxySelector() != null) {\r\n        address.proxySelector().connectFailed(address.url().uri(), failedRoute.proxy().address(), failure);\r\n    }\r\n    routeDatabase.failed(failedRoute);\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonReader.getPath",
	"Comment": "returns a jsonpath tothe current location in the json value.",
	"Method": "String getPath(){\r\n    return JsonScope.getPath(stackSize, scopes, pathNames, pathIndices);\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testGetNamesWithArray_a2",
	"Comment": "this test shows how to use the array jdbc type with mybatis.this test shows using annotations for stored procedures and using aresultmap in xml",
	"Method": "void testGetNamesWithArray_a2(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        Array array = sqlSession.getConnection().createArrayOf(\"int\", new Integer[] { 1, 2, 5 });\r\n        Map<String, Object> parms = new HashMap<String, Object>();\r\n        parms.put(\"ids\", array);\r\n        List<Name> names = spMapper.getNamesWithArrayAnnotatedWithXMLResultMap(parms);\r\n        Object[] returnedIds = (Object[]) parms.get(\"returnedIds\");\r\n        assertEquals(4, returnedIds.length);\r\n        assertEquals(3, parms.get(\"requestedRows\"));\r\n        assertEquals(2, names.size());\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testGetNamesWithArray_a1",
	"Comment": "this test shows how to use the array jdbc type with mybatis.this test shows using annotations for stored procedures",
	"Method": "void testGetNamesWithArray_a1(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        Array array = sqlSession.getConnection().createArrayOf(\"int\", new Integer[] { 1, 2, 5 });\r\n        Map<String, Object> parms = new HashMap<String, Object>();\r\n        parms.put(\"ids\", array);\r\n        List<Name> names = spMapper.getNamesWithArrayAnnotated(parms);\r\n        Object[] returnedIds = (Object[]) parms.get(\"returnedIds\");\r\n        assertEquals(4, returnedIds.length);\r\n        assertEquals(3, parms.get(\"requestedRows\"));\r\n        assertEquals(2, names.size());\r\n    }\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.common.util.apache.IntHashMap.put",
	"Comment": "maps the specified key to the specifiedvalue in this hashtable. the key cannot benull. the value can be retrieved by calling the get methodwith a key that is equal to the original key.",
	"Method": "T put(int key,T value){\r\n    Entry<T>[] tab = table;\r\n    int hash = key;\r\n    int index = (hash & 0x7FFFFFFF) % tab.length;\r\n    for (Entry<T> e = tab[index]; e != null; e = e.next) {\r\n        if (e.hash == hash) {\r\n            T old = e.value;\r\n            e.value = value;\r\n            return old;\r\n        }\r\n    }\r\n    if (count >= threshold) {\r\n        rehash();\r\n        tab = table;\r\n        index = (hash & 0x7FFFFFFF) % tab.length;\r\n    }\r\n    Entry<T> e = new Entry<T>(hash, key, value, tab[index]);\r\n    tab[index] = e;\r\n    count++;\r\n    return null;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.getData",
	"Comment": "returns the chartdata object that has been set for the chart.",
	"Method": "T getData(){\r\n    return mData;\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.layout.MvpFrameLayout.getMvpDelegate",
	"Comment": "get the mvp delegate. this is internally used for creating presenter, attaching and detachingview from presenter etc.please note that only one instance of mvp delegate should be used per android.view.viewinstance.only override this method if you really know what you are doing.",
	"Method": "ViewGroupMvpDelegate<V, P> getMvpDelegate(){\r\n    if (mvpDelegate == null) {\r\n        mvpDelegate = new ViewGroupMvpDelegateImpl(this, this, true);\r\n    }\r\n    return mvpDelegate;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.renderer.LineRadarRenderer.clipPathSupported",
	"Comment": "clip path with hardware acceleration only working properly on api level 18 and above.",
	"Method": "boolean clipPathSupported(){\r\n    return Utils.getSDKInt() >= 18;\r\n}"
}, {
	"Path": "okhttp3.internal.connection.RealConnection.isHealthy",
	"Comment": "returns true if this connection is ready to host new streams.",
	"Method": "boolean isHealthy(boolean doExtensiveChecks){\r\n    if (socket.isClosed() || socket.isInputShutdown() || socket.isOutputShutdown()) {\r\n        return false;\r\n    }\r\n    if (http2Connection != null) {\r\n        return !http2Connection.isShutdown();\r\n    }\r\n    if (doExtensiveChecks) {\r\n        try {\r\n            int readTimeout = socket.getSoTimeout();\r\n            try {\r\n                socket.setSoTimeout(1);\r\n                if (source.exhausted()) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            } finally {\r\n                socket.setSoTimeout(readTimeout);\r\n            }\r\n        } catch (SocketTimeoutException ignored) {\r\n        } catch (IOException e) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.google.refine.ProjectManager.getProjectID",
	"Comment": "tries to find the project id when given a project namerequires that all project metadata exists has been loaded to memory from the data store",
	"Method": "long getProjectID(String name){\r\n    for (Entry<Long, ProjectMetadata> entry : _projectsMetadata.entrySet()) {\r\n        if (entry.getValue().getName().equals(name)) {\r\n            return entry.getKey();\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.PieChart.setDrawCenterText",
	"Comment": "set this to true to draw the text that is displayed in the center of thepie chart",
	"Method": "void setDrawCenterText(boolean enabled){\r\n    this.mDrawCenterText = enabled;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.getMarkerPosition",
	"Comment": "returns the actual position in pixels of the markerview for the givenhighlight object.",
	"Method": "float[] getMarkerPosition(Highlight high){\r\n    return new float[] { high.getDrawX(), high.getDrawY() };\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.AxisBase.resetAxisMaximum",
	"Comment": "by calling this method, any custom maximum value that has been previously set is reseted,and the calculation isdone automatically.",
	"Method": "void resetAxisMaximum(){\r\n    mCustomAxisMax = false;\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.bootstrap.plugin.proxy.ProxyHttpHeader.getDurationTimeMicroseconds",
	"Comment": "the time from when the request was received to the time the headers are sent on the wire.",
	"Method": "int getDurationTimeMicroseconds(){\r\n    return durationTimeMicroseconds;\r\n}"
}, {
	"Path": "com.google.refine.commands.Command.logRequests",
	"Comment": "whether each request to this command should be logged. for some commandsthat can get called too frequently, such as getprocessescommand, loggingis very distracting.",
	"Method": "boolean logRequests(){\r\n    return true;\r\n}"
}, {
	"Path": "okhttp3.internal.connection.StreamAllocation.noNewStreams",
	"Comment": "forbid new streams from being created on the connection that hosts this allocation.",
	"Method": "void noNewStreams(){\r\n    Socket socket;\r\n    Connection releasedConnection;\r\n    synchronized (connectionPool) {\r\n        releasedConnection = connection;\r\n        socket = deallocate(true, false, false);\r\n        if (connection != null)\r\n            releasedConnection = null;\r\n    }\r\n    closeQuietly(socket);\r\n    if (releasedConnection != null) {\r\n        eventListener.connectionReleased(call, releasedConnection);\r\n    }\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonWriter.replaceTop",
	"Comment": "replace the value on the top of the stack with the given value.",
	"Method": "void replaceTop(int topOfStack){\r\n    scopes[stackSize - 1] = topOfStack;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.RadarChart.getFactor",
	"Comment": "returns the factor that is needed to transform values into pixels.",
	"Method": "float getFactor(){\r\n    RectF content = mViewPortHandler.getContentRect();\r\n    return Math.min(content.width() / 2f, content.height() / 2f) / mYAxis.mAxisRange;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.renderer.YAxisRendererHorizontalBarChart.renderLimitLines",
	"Comment": "draws the limitlines associated with this axis to the screen.this is the standard xaxis renderer using the yaxis limit lines.",
	"Method": "void renderLimitLines(Canvas c){\r\n    List<LimitLine> limitLines = mYAxis.getLimitLines();\r\n    if (limitLines == null || limitLines.size() <= 0)\r\n        return;\r\n    float[] pts = mRenderLimitLinesBuffer;\r\n    pts[0] = 0;\r\n    pts[1] = 0;\r\n    pts[2] = 0;\r\n    pts[3] = 0;\r\n    Path limitLinePath = mRenderLimitLinesPathBuffer;\r\n    limitLinePath.reset();\r\n    for (int i = 0; i < limitLines.size(); i++) {\r\n        LimitLine l = limitLines.get(i);\r\n        if (!l.isEnabled())\r\n            continue;\r\n        int clipRestoreCount = c.save();\r\n        mLimitLineClippingRect.set(mViewPortHandler.getContentRect());\r\n        mLimitLineClippingRect.inset(-l.getLineWidth(), 0.f);\r\n        c.clipRect(mLimitLineClippingRect);\r\n        pts[0] = l.getLimit();\r\n        pts[2] = l.getLimit();\r\n        mTrans.pointValuesToPixel(pts);\r\n        pts[1] = mViewPortHandler.contentTop();\r\n        pts[3] = mViewPortHandler.contentBottom();\r\n        limitLinePath.moveTo(pts[0], pts[1]);\r\n        limitLinePath.lineTo(pts[2], pts[3]);\r\n        mLimitLinePaint.setStyle(Paint.Style.STROKE);\r\n        mLimitLinePaint.setColor(l.getLineColor());\r\n        mLimitLinePaint.setPathEffect(l.getDashPathEffect());\r\n        mLimitLinePaint.setStrokeWidth(l.getLineWidth());\r\n        c.drawPath(limitLinePath, mLimitLinePaint);\r\n        limitLinePath.reset();\r\n        String label = l.getLabel();\r\n        if (label != null && !label.equals(\"\")) {\r\n            mLimitLinePaint.setStyle(l.getTextStyle());\r\n            mLimitLinePaint.setPathEffect(null);\r\n            mLimitLinePaint.setColor(l.getTextColor());\r\n            mLimitLinePaint.setTypeface(l.getTypeface());\r\n            mLimitLinePaint.setStrokeWidth(0.5f);\r\n            mLimitLinePaint.setTextSize(l.getTextSize());\r\n            float xOffset = l.getLineWidth() + l.getXOffset();\r\n            float yOffset = Utils.convertDpToPixel(2f) + l.getYOffset();\r\n            final LimitLine.LimitLabelPosition position = l.getLabelPosition();\r\n            if (position == LimitLine.LimitLabelPosition.RIGHT_TOP) {\r\n                final float labelLineHeight = Utils.calcTextHeight(mLimitLinePaint, label);\r\n                mLimitLinePaint.setTextAlign(Align.LEFT);\r\n                c.drawText(label, pts[0] + xOffset, mViewPortHandler.contentTop() + yOffset + labelLineHeight, mLimitLinePaint);\r\n            } else if (position == LimitLine.LimitLabelPosition.RIGHT_BOTTOM) {\r\n                mLimitLinePaint.setTextAlign(Align.LEFT);\r\n                c.drawText(label, pts[0] + xOffset, mViewPortHandler.contentBottom() - yOffset, mLimitLinePaint);\r\n            } else if (position == LimitLine.LimitLabelPosition.LEFT_TOP) {\r\n                mLimitLinePaint.setTextAlign(Align.RIGHT);\r\n                final float labelLineHeight = Utils.calcTextHeight(mLimitLinePaint, label);\r\n                c.drawText(label, pts[0] - xOffset, mViewPortHandler.contentTop() + yOffset + labelLineHeight, mLimitLinePaint);\r\n            } else {\r\n                mLimitLinePaint.setTextAlign(Align.RIGHT);\r\n                c.drawText(label, pts[0] - xOffset, mViewPortHandler.contentBottom() - yOffset, mLimitLinePaint);\r\n            }\r\n        }\r\n        c.restoreToCount(clipRestoreCount);\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.io.JBoss6VFS.checkNotNull",
	"Comment": "verifies that the provided object reference is null. if it is null, then this vfs is markedas invalid for the current environment.",
	"Method": "T checkNotNull(T object){\r\n    if (object == null) {\r\n        setInvalid();\r\n    }\r\n    return object;\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvi.MviBasePresenter.subscribeViewStateConsumerActually",
	"Comment": "actually subscribes the view as consumer to the internally view relay.",
	"Method": "void subscribeViewStateConsumerActually(V view){\r\n    if (view == null) {\r\n        throw new NullPointerException(\"View is null\");\r\n    }\r\n    if (viewStateConsumer == null) {\r\n        throw new NullPointerException(ViewStateConsumer.class.getSimpleName() + \" is null. This is a Mosby internal bug. Please file an issue at https://github.com/sockeqwe/mosby/issues\");\r\n    }\r\n    viewRelayConsumerDisposable = viewStateBehaviorSubject.subscribe(new Consumer<VS>() {\r\n        @Override\r\n        public void accept(VS vs) throws Exception {\r\n            viewStateConsumer.accept(view, vs);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvi.MviBasePresenter.subscribeViewStateConsumerActually",
	"Comment": "actually subscribes the view as consumer to the internally view relay.",
	"Method": "void subscribeViewStateConsumerActually(V view){\r\n    viewStateConsumer.accept(view, vs);\r\n}"
}, {
	"Path": "okhttp3.mockwebserver.MockWebServer.getRequestCount",
	"Comment": "returns the number of http requests received thus far by this server. this may exceed thenumber of http connections when connection reuse is in practice.",
	"Method": "int getRequestCount(){\r\n    return requestCount.get();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.getEntryByTouchPoint",
	"Comment": "returns the entry object displayed at the touched position of the chart",
	"Method": "Entry getEntryByTouchPoint(float x,float y){\r\n    Highlight h = getHighlightByTouchPoint(x, y);\r\n    if (h != null) {\r\n        return mData.getEntryForHighlight(h);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.ibatis.mapping.ParameterMapping.getJdbcType",
	"Comment": "used in the unknowntypehandler in case there is no handler for the property type",
	"Method": "JdbcType getJdbcType(){\r\n    return jdbcType;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.BarEntry.getY",
	"Comment": "returns the value of this barentry. if the entry is stacked, it returns the positive sum of all values.",
	"Method": "float getY(){\r\n    return super.getY();\r\n}"
}, {
	"Path": "okhttp3.internal.http2.HpackTest.tooLargeToHPackIsStillEmitted",
	"Comment": "hpack has a max header table size, which can be smaller than the max header message. ensure thelarger header content is not lost.",
	"Method": "void tooLargeToHPackIsStillEmitted(){\r\n    bytesIn.writeByte(0x21);\r\n    bytesIn.writeByte(0x00);\r\n    bytesIn.writeByte(0x0a);\r\n    bytesIn.writeUtf8(\"custom-key\");\r\n    bytesIn.writeByte(0x0d);\r\n    bytesIn.writeUtf8(\"custom-header\");\r\n    hpackReader.readHeaders();\r\n    assertEquals(0, hpackReader.headerCount);\r\n    assertEquals(headerEntries(\"custom-key\", \"custom-header\"), hpackReader.getAndResetHeaderList());\r\n}"
}, {
	"Path": "okhttp3.CallTest.readTimeoutFails",
	"Comment": "make a request with two routes. the first route will fail because the null server connects butnever responds. the manual retry will succeed.",
	"Method": "void readTimeoutFails(){\r\n    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));\r\n    server2.enqueue(new MockResponse().setBody(\"success!\"));\r\n    RecordingProxySelector proxySelector = new RecordingProxySelector();\r\n    proxySelector.proxies.add(server.toProxyAddress());\r\n    proxySelector.proxies.add(server2.toProxyAddress());\r\n    client = client.newBuilder().proxySelector(proxySelector).readTimeout(100, TimeUnit.MILLISECONDS).build();\r\n    Request request = new Request.Builder().url(\"http://android.com/\").build();\r\n    executeSynchronously(request).assertFailure(SocketTimeoutException.class);\r\n    executeSynchronously(request).assertCode(200).assertBody(\"success!\");\r\n}"
}, {
	"Path": "okhttp3.RequestTest.crudVerbs",
	"Comment": "common verbs used for apis such as github, aws, and google cloud.",
	"Method": "void crudVerbs(){\r\n    MediaType contentType = MediaType.get(\"application/json\");\r\n    RequestBody body = RequestBody.create(contentType, \"{}\");\r\n    Request get = new Request.Builder().url(\"http://localhost/api\").get().build();\r\n    assertEquals(\"GET\", get.method());\r\n    assertNull(get.body());\r\n    Request head = new Request.Builder().url(\"http://localhost/api\").head().build();\r\n    assertEquals(\"HEAD\", head.method());\r\n    assertNull(head.body());\r\n    Request delete = new Request.Builder().url(\"http://localhost/api\").delete().build();\r\n    assertEquals(\"DELETE\", delete.method());\r\n    assertEquals(0L, delete.body().contentLength());\r\n    Request post = new Request.Builder().url(\"http://localhost/api\").post(body).build();\r\n    assertEquals(\"POST\", post.method());\r\n    assertEquals(body, post.body());\r\n    Request put = new Request.Builder().url(\"http://localhost/api\").put(body).build();\r\n    assertEquals(\"PUT\", put.method());\r\n    assertEquals(body, put.body());\r\n    Request patch = new Request.Builder().url(\"http://localhost/api\").patch(body).build();\r\n    assertEquals(\"PATCH\", patch.method());\r\n    assertEquals(body, patch.body());\r\n}"
}, {
	"Path": "okhttp3.CertificatePinnerTest.sameKeypairSamePin",
	"Comment": "multiple certificates generated from the same keypair have the same pin.",
	"Method": "void sameKeypairSamePin(){\r\n    HeldCertificate heldCertificateA2 = new HeldCertificate.Builder().keyPair(certA1.keyPair()).serialNumber(101L).build();\r\n    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate());\r\n    HeldCertificate heldCertificateB2 = new HeldCertificate.Builder().keyPair(certB1.keyPair()).serialNumber(201L).build();\r\n    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate());\r\n    assertTrue(certA1Sha256Pin.equals(keypairACertificate2Pin));\r\n    assertTrue(certB1Sha256Pin.equals(keypairBCertificate2Pin));\r\n    assertFalse(certA1Sha256Pin.equals(certB1Sha256Pin));\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.lce.MvpLceDialogFragment.animateLoadingViewIn",
	"Comment": "override this method if you want to provide your own animation for showing the loading view",
	"Method": "void animateLoadingViewIn(){\r\n    LceAnimator.showLoading(loadingView, contentView, errorView);\r\n}"
}, {
	"Path": "okhttp3.android.HttpResponseCache.close",
	"Comment": "uninstalls the cache and releases any active resources. stored contents will remain on thefilesystem.",
	"Method": "void close(){\r\n    if (ResponseCache.getDefault() == this) {\r\n        ResponseCache.setDefault(null);\r\n    }\r\n    shimResponseCache.close();\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.common.util.NetUtils.getLocalV4IpList",
	"Comment": "returns a list of ip addresses on this machine that is accessible from a remote source.if no network interfaces can be found on this machine, returns an empty list.",
	"Method": "List<String> getLocalV4IpList(){\r\n    Enumeration<NetworkInterface> interfaces = null;\r\n    try {\r\n        interfaces = NetworkInterface.getNetworkInterfaces();\r\n    } catch (SocketException ignore) {\r\n    }\r\n    if (interfaces == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    List<String> result = new ArrayList<String>();\r\n    while (interfaces.hasMoreElements()) {\r\n        NetworkInterface current = interfaces.nextElement();\r\n        if (isSkipIp(current)) {\r\n            continue;\r\n        }\r\n        Enumeration<InetAddress> addresses = current.getInetAddresses();\r\n        while (addresses.hasMoreElements()) {\r\n            InetAddress address = addresses.nextElement();\r\n            if (address.isLoopbackAddress() || !(address instanceof Inet4Address)) {\r\n                continue;\r\n            }\r\n            if (validationIpV4FormatAddress(address.getHostAddress())) {\r\n                result.add(address.getHostAddress());\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "okhttp3.AndroidShimResponseCache.close",
	"Comment": "uninstalls the cache and releases any active resources. stored contents will remain on thefilesystem.",
	"Method": "void close(){\r\n    delegate.close();\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testGetNamesAndItems_a2",
	"Comment": "this test shows how to call procedures that return multiple result setsthis test shows using annotations for stored procedures and referring tomultiple resultmaps in xml",
	"Method": "void testGetNamesAndItems_a2(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        List<List<?>> results = spMapper.getNamesAndItemsAnnotatedWithXMLResultMap();\r\n        assertEquals(2, results.size());\r\n        assertEquals(4, results.get(0).size());\r\n        assertEquals(3, results.get(1).size());\r\n    }\r\n}"
}, {
	"Path": "org.openrefine.wikidata.updates.ItemUpdateBuilder.addStatement",
	"Comment": "mark a statement for insertion. if it matches an existing statement, it willupdate the statement instead.",
	"Method": "ItemUpdateBuilder addStatement(Statement statement){\r\n    Validate.isTrue(!built, \"ItemUpdate has already been built\");\r\n    addedStatements.add(statement);\r\n    return this;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.Transformer.generateTransformedValuesCandle",
	"Comment": "transforms an list of entry into a float array containing the x andy values transformed with all matrices for the candlestickchart.",
	"Method": "float[] generateTransformedValuesCandle(ICandleDataSet data,float phaseX,float phaseY,int from,int to){\r\n    final int count = (int) ((to - from) * phaseX + 1) * 2;\r\n    if (valuePointsForGenerateTransformedValuesCandle.length != count) {\r\n        valuePointsForGenerateTransformedValuesCandle = new float[count];\r\n    }\r\n    float[] valuePoints = valuePointsForGenerateTransformedValuesCandle;\r\n    for (int j = 0; j < count; j += 2) {\r\n        CandleEntry e = data.getEntryForIndex(j / 2 + from);\r\n        if (e != null) {\r\n            valuePoints[j] = e.getX();\r\n            valuePoints[j + 1] = e.getHigh() * phaseY;\r\n        } else {\r\n            valuePoints[j] = 0;\r\n            valuePoints[j + 1] = 0;\r\n        }\r\n    }\r\n    getValueToPixelMatrix().mapPoints(valuePoints);\r\n    return valuePoints;\r\n}"
}, {
	"Path": "okhttp3.internal.ws.RealWebSocket.loopReader",
	"Comment": "receive frames until there are no more. invoked only by the reader thread.",
	"Method": "void loopReader(){\r\n    while (receivedCloseCode == -1) {\r\n        reader.processNextFrame();\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.FileUtils.saveToSdCard",
	"Comment": "saves an array of entries to the specified location on the sdcard",
	"Method": "void saveToSdCard(List<Entry> entries,String path){\r\n    File sdcard = Environment.getExternalStorageDirectory();\r\n    File saved = new File(sdcard, path);\r\n    if (!saved.exists()) {\r\n        try {\r\n            saved.createNewFile();\r\n        } catch (IOException e) {\r\n            Log.e(LOG, e.toString());\r\n        }\r\n    }\r\n    try {\r\n        BufferedWriter buf = new BufferedWriter(new FileWriter(saved, true));\r\n        for (Entry e : entries) {\r\n            buf.append(e.getY() + \"#\" + e.getX());\r\n            buf.newLine();\r\n        }\r\n        buf.close();\r\n    } catch (IOException e) {\r\n        Log.e(LOG, e.toString());\r\n    }\r\n}"
}, {
	"Path": "org.openrefine.wikidata.schema.WbVariableExpr.setColumnName",
	"Comment": "changes the column name used by the variable. this is useful fordeserialization, as well as updates when column names change.",
	"Method": "void setColumnName(String columnName){\r\n    this.columnName = columnName;\r\n}"
}, {
	"Path": "org.openrefine.wikidata.schema.WbStringVariableTest.testTrailingWhitespace",
	"Comment": "the evaluator cleans up leading and trailing whitespace, but not duplicate spaces",
	"Method": "void testTrailingWhitespace(){\r\n    evaluatesTo(Datamodel.makeStringValue(\"dirty\"), \"dirty \\t\");\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.getHighlighted",
	"Comment": "returns the array of currently highlighted values. this might a null orempty array if nothing is highlighted.",
	"Method": "Highlight[] getHighlighted(){\r\n    return mIndicesToHighlight;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.getRenderer",
	"Comment": "returns the renderer object the chart uses for drawing data.",
	"Method": "DataRenderer getRenderer(){\r\n    return mRenderer;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.listener.PieRadarChartTouchListener.setGestureStartAngle",
	"Comment": "sets the starting angle of the rotation, this is only used by the touchlistener, x and y is the touch position",
	"Method": "void setGestureStartAngle(float x,float y){\r\n    mStartAngle = mChart.getAngleForPoint(x, y) - mChart.getRawRotationAngle();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.BaseDataSet.setGradientColors",
	"Comment": "sets the start and end color for gradient colors, only color that should be used for this dataset.",
	"Method": "void setGradientColors(List<GradientColor> gradientColors){\r\n    this.mGradientColors = gradientColors;\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.common.util.jsr166.ConcurrentReferenceHashMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this one.these mappings replace any mappings that this map had for any of thekeys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> m){\r\n    for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) put(e.getKey(), e.getValue());\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.PieChart.setDrawRoundedSlices",
	"Comment": "sets whether to draw slices in a curved fashion, only works if drawing the hole is enabledand if the slices are not drawn under the hole.",
	"Method": "void setDrawRoundedSlices(boolean enabled){\r\n    mDrawRoundedSlices = enabled;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.YAxis.needsOffset",
	"Comment": "returns true if this axis needs horizontal offset, false if no offset is needed.",
	"Method": "boolean needsOffset(){\r\n    if (isEnabled() && isDrawLabelsEnabled() && getLabelPosition() == YAxisLabelPosition.OUTSIDE_CHART)\r\n        return true;\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "org.openrefine.wikidata.updates.ItemUpdateBuilder.addAlias",
	"Comment": "adds an alias to the item. it will be added to any existing aliases in thatlanguage.",
	"Method": "ItemUpdateBuilder addAlias(MonolingualTextValue alias){\r\n    Validate.isTrue(!built, \"ItemUpdate has already been built\");\r\n    aliases.add(alias);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.strings.StringCaseTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.PieChart.setDrawSlicesUnderHole",
	"Comment": "enable or disable the visibility of the inner tips of the slices behind the hole",
	"Method": "void setDrawSlicesUnderHole(boolean enable){\r\n    mDrawSlicesUnderHole = enable;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.setNoDataText",
	"Comment": "sets the text that informs the user that there is no data available withwhich to draw the chart.",
	"Method": "void setNoDataText(String text){\r\n    mNoDataText = text;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.Transformer.generateTransformedValuesScatter",
	"Comment": "transforms an list of entry into a float array containing the x andy values transformed with all matrices for the scatterchart.",
	"Method": "float[] generateTransformedValuesScatter(IScatterDataSet data,float phaseX,float phaseY,int from,int to){\r\n    final int count = (int) ((to - from) * phaseX + 1) * 2;\r\n    if (valuePointsForGenerateTransformedValuesScatter.length != count) {\r\n        valuePointsForGenerateTransformedValuesScatter = new float[count];\r\n    }\r\n    float[] valuePoints = valuePointsForGenerateTransformedValuesScatter;\r\n    for (int j = 0; j < count; j += 2) {\r\n        Entry e = data.getEntryForIndex(j / 2 + from);\r\n        if (e != null) {\r\n            valuePoints[j] = e.getX();\r\n            valuePoints[j + 1] = e.getY() * phaseY;\r\n        } else {\r\n            valuePoints[j] = 0;\r\n            valuePoints[j + 1] = 0;\r\n        }\r\n    }\r\n    getValueToPixelMatrix().mapPoints(valuePoints);\r\n    return valuePoints;\r\n}"
}, {
	"Path": "okhttp3.internal.http2.Http2Stream.getErrorCode",
	"Comment": "returns the reason why this stream was closed, or null if it closed normally or has not yetbeen closed.",
	"Method": "ErrorCode getErrorCode(){\r\n    return errorCode;\r\n}"
}, {
	"Path": "com.google.refine.io.FileProjectManager.loadProjectMetadata",
	"Comment": "import an external project that has been received as a .tar file, expanded, andcopied into our workspace directory.",
	"Method": "boolean loadProjectMetadata(long projectID){\r\n    synchronized (this) {\r\n        ProjectMetadata metadata = ProjectMetadataUtilities.load(getProjectDir(projectID));\r\n        if (metadata == null) {\r\n            metadata = ProjectMetadataUtilities.recover(getProjectDir(projectID), projectID);\r\n        }\r\n        if (metadata != null) {\r\n            _projectsMetadata.put(projectID, metadata);\r\n            if (_projectsTags == null) {\r\n                _projectsTags = new HashMap<String, Integer>();\r\n            }\r\n            if (metadata != null && metadata.getTags() != null) {\r\n                for (String tag : metadata.getTags()) {\r\n                    if (_projectsTags.containsKey(tag)) {\r\n                        _projectsTags.put(tag, _projectsTags.get(tag) + 1);\r\n                    } else {\r\n                        _projectsTags.put(tag, 1);\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.viewstate.lce.data.ParcelableListLceViewState.getClassLoader",
	"Comment": "the class loader used for deserializing the list of parcelable items",
	"Method": "ClassLoader getClassLoader(){\r\n    return getClass().getClassLoader();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.PieRadarChartBase.distanceToCenter",
	"Comment": "returns the distance of a certain point on the chart to the center of thechart.",
	"Method": "float distanceToCenter(float x,float y){\r\n    MPPointF c = getCenterOffsets();\r\n    float dist = 0f;\r\n    float xDist = 0f;\r\n    float yDist = 0f;\r\n    if (x > c.x) {\r\n        xDist = x - c.x;\r\n    } else {\r\n        xDist = c.x - x;\r\n    }\r\n    if (y > c.y) {\r\n        yDist = y - c.y;\r\n    } else {\r\n        yDist = c.y - y;\r\n    }\r\n    dist = (float) Math.sqrt(Math.pow(xDist, 2.0) + Math.pow(yDist, 2.0));\r\n    MPPointF.recycleInstance(c);\r\n    return dist;\r\n}"
}, {
	"Path": "okhttp3.mockwebserver.MockWebServer.noClientAuth",
	"Comment": "configure the server to not perform ssl authentication of the client. this leavesauthentication to another layer such as in an http cookie or header. this is the default andmost common configuration.",
	"Method": "void noClientAuth(){\r\n    this.clientAuth = CLIENT_AUTH_NONE;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.Legend.setFormLineDashEffect",
	"Comment": "sets the line dash path effect used for shapes that consist of lines.",
	"Method": "void setFormLineDashEffect(DashPathEffect dashPathEffect){\r\n    mFormLineDashEffect = dashPathEffect;\r\n}"
}, {
	"Path": "okhttp3.internal.ws.WebSocketRecorder.setNextEventDelegate",
	"Comment": "sets a delegate for handling the next callback to this listener. cleared after invoked.",
	"Method": "void setNextEventDelegate(WebSocketListener delegate){\r\n    this.delegate = delegate;\r\n}"
}, {
	"Path": "okhttp3.internal.sse.ServerSentEventReader.skipNameAndDivider",
	"Comment": "consumes the field name of the specified length and the optional colon and its optionaltrailing space. returns the number of bytes skipped.",
	"Method": "long skipNameAndDivider(long length){\r\n    source.skip(length);\r\n    if (source.buffer().getByte(0) == ':') {\r\n        source.skip(1L);\r\n        length++;\r\n        if (source.buffer().getByte(0) == ' ') {\r\n            source.skip(1);\r\n            length++;\r\n        }\r\n    }\r\n    return length;\r\n}"
}, {
	"Path": "okhttp3.Challenge.charset",
	"Comment": "returns the charset that should be used to encode the credentials.",
	"Method": "Charset charset(){\r\n    String charset = authParams.get(\"charset\");\r\n    if (charset != null) {\r\n        try {\r\n            return Charset.forName(charset);\r\n        } catch (Exception ignore) {\r\n        }\r\n    }\r\n    return ISO_8859_1;\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.common.util.jsr166.ConcurrentWeakHashMap.put",
	"Comment": "maps the specified key to the specified value in this table.neither the key nor the value can be null. the value can be retrieved by calling the get methodwith a key that is equal to the original key.",
	"Method": "V put(K key,int hash,V value,boolean onlyIfAbsent,V put,K key,V value){\r\n    if (value == null)\r\n        throw new NullPointerException();\r\n    int hash = hash(key.hashCode());\r\n    return segmentFor(hash).put(key, hash, value, false);\r\n}"
}, {
	"Path": "org.mockito.internal.junit.UnusedStubbingsFinder.getUnusedStubbings",
	"Comment": "gets all unused stubbings for given set of mock objects, in order.stubbings explicitily marked as lenient are not included.",
	"Method": "UnusedStubbings getUnusedStubbings(Iterable<Object> mocks){\r\n    Set<Stubbing> stubbings = AllInvocationsFinder.findStubbings(mocks);\r\n    List<Stubbing> unused = filter(stubbings, new Filter<Stubbing>() {\r\n        public boolean isOut(Stubbing s) {\r\n            return !UnusedStubbingReporting.shouldBeReported(s);\r\n        }\r\n    });\r\n    return new UnusedStubbings(unused);\r\n}"
}, {
	"Path": "org.mockito.internal.junit.UnusedStubbingsFinder.getUnusedStubbings",
	"Comment": "gets all unused stubbings for given set of mock objects, in order.stubbings explicitily marked as lenient are not included.",
	"Method": "UnusedStubbings getUnusedStubbings(Iterable<Object> mocks){\r\n    return !UnusedStubbingReporting.shouldBeReported(s);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.ScatterDataSet.setShapeRenderer",
	"Comment": "sets a new ishaperenderer responsible for drawing this dataset.this can also be used to set a custom ishaperenderer aside from the default ones.",
	"Method": "void setShapeRenderer(IShapeRenderer shapeRenderer){\r\n    mShapeRenderer = shapeRenderer;\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.nullSafe",
	"Comment": "returns a json adapter equal to this json adapter, but with support for reading and writingnulls.",
	"Method": "JsonAdapter<T> nullSafe(){\r\n    final JsonAdapter<T> delegate = this;\r\n    return new JsonAdapter<T>() {\r\n        @Override\r\n        @Nullable\r\n        public T fromJson(JsonReader reader) throws IOException {\r\n            if (reader.peek() == JsonReader.Token.NULL) {\r\n                return reader.nextNull();\r\n            } else {\r\n                return delegate.fromJson(reader);\r\n            }\r\n        }\r\n        @Override\r\n        public void toJson(JsonWriter writer, @Nullable T value) throws IOException {\r\n            if (value == null) {\r\n                writer.nullValue();\r\n            } else {\r\n                delegate.toJson(writer, value);\r\n            }\r\n        }\r\n        @Override\r\n        boolean isLenient() {\r\n            return delegate.isLenient();\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return delegate + \".nullSafe()\";\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.nullSafe",
	"Comment": "returns a json adapter equal to this json adapter, but with support for reading and writingnulls.",
	"Method": "JsonAdapter<T> nullSafe(){\r\n    if (reader.peek() == JsonReader.Token.NULL) {\r\n        return reader.nextNull();\r\n    } else {\r\n        return delegate.fromJson(reader);\r\n    }\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.nullSafe",
	"Comment": "returns a json adapter equal to this json adapter, but with support for reading and writingnulls.",
	"Method": "JsonAdapter<T> nullSafe(){\r\n    if (value == null) {\r\n        writer.nullValue();\r\n    } else {\r\n        delegate.toJson(writer, value);\r\n    }\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.nullSafe",
	"Comment": "returns a json adapter equal to this json adapter, but with support for reading and writingnulls.",
	"Method": "JsonAdapter<T> nullSafe(){\r\n    return delegate.isLenient();\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.nullSafe",
	"Comment": "returns a json adapter equal to this json adapter, but with support for reading and writingnulls.",
	"Method": "JsonAdapter<T> nullSafe(){\r\n    return delegate + \".nullSafe()\";\r\n}"
}, {
	"Path": "org.mockito.internal.util.reflection.AccessibilityChanger.enableAccess",
	"Comment": "changes the accessibleobject accessibility and returns true if accessibility was changed",
	"Method": "void enableAccess(AccessibleObject accessibleObject){\r\n    wasAccessible = accessibleObject.isAccessible();\r\n    accessibleObject.setAccessible(true);\r\n}"
}, {
	"Path": "okhttp3.InterceptorTest.interceptorThrowsRuntimeExceptionSynchronous",
	"Comment": "when an interceptor throws an unexpected exception, synchronous callers can catch it and dealwith it.",
	"Method": "void interceptorThrowsRuntimeExceptionSynchronous(boolean network){\r\n    addInterceptor(network, new Interceptor() {\r\n        @Override\r\n        public Response intercept(Chain chain) throws IOException {\r\n            throw new RuntimeException(\"boom!\");\r\n        }\r\n    });\r\n    Request request = new Request.Builder().url(server.url(\"/\")).build();\r\n    try {\r\n        client.newCall(request).execute();\r\n        fail();\r\n    } catch (RuntimeException expected) {\r\n        assertEquals(\"boom!\", expected.getMessage());\r\n    }\r\n}"
}, {
	"Path": "okhttp3.InterceptorTest.interceptorThrowsRuntimeExceptionSynchronous",
	"Comment": "when an interceptor throws an unexpected exception, synchronous callers can catch it and dealwith it.",
	"Method": "void interceptorThrowsRuntimeExceptionSynchronous(boolean network){\r\n    throw new RuntimeException(\"boom!\");\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.delegate.ActivityMvpDelegateImpl.retainPresenterInstance",
	"Comment": "determines whether or not a presenter instance should be kept",
	"Method": "boolean retainPresenterInstance(boolean keepPresenterInstance,Activity activity){\r\n    return keepPresenterInstance && (activity.isChangingConfigurations() || !activity.isFinishing());\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.LineDataSet.getCircleSize",
	"Comment": "this function is deprecated because of unclarity. use getcircleradius instead.",
	"Method": "float getCircleSize(){\r\n    return getCircleRadius();\r\n}"
}, {
	"Path": "org.mockito.internal.util.reflection.FieldInitializationReport.fieldWasInitialized",
	"Comment": "indicate whether the field was created during the process or not.",
	"Method": "boolean fieldWasInitialized(){\r\n    return wasInitialized;\r\n}"
}, {
	"Path": "okhttp3.InterceptorTest.interceptorThrowsRuntimeExceptionAsynchronous",
	"Comment": "when an interceptor throws an unexpected exception, asynchronous callers are left hanging. theexception goes to the uncaught exception handler.",
	"Method": "void interceptorThrowsRuntimeExceptionAsynchronous(boolean network){\r\n    addInterceptor(network, new Interceptor() {\r\n        @Override\r\n        public Response intercept(Chain chain) throws IOException {\r\n            throw new RuntimeException(\"boom!\");\r\n        }\r\n    });\r\n    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();\r\n    client = client.newBuilder().dispatcher(new Dispatcher(executor)).build();\r\n    Request request = new Request.Builder().url(server.url(\"/\")).build();\r\n    client.newCall(request).enqueue(callback);\r\n    assertEquals(\"boom!\", executor.takeException().getMessage());\r\n}"
}, {
	"Path": "okhttp3.InterceptorTest.interceptorThrowsRuntimeExceptionAsynchronous",
	"Comment": "when an interceptor throws an unexpected exception, asynchronous callers are left hanging. theexception goes to the uncaught exception handler.",
	"Method": "void interceptorThrowsRuntimeExceptionAsynchronous(boolean network){\r\n    throw new RuntimeException(\"boom!\");\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.AxisBase.setCenterAxisLabels",
	"Comment": "centers the axis labels instead of drawing them at their original position.this is useful especially for grouped barchart.",
	"Method": "void setCenterAxisLabels(boolean enabled){\r\n    mCenterAxisLabels = enabled;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.highlightValues",
	"Comment": "highlights the values at the given indices in the given datasets. providenull or an empty array to undo all highlighting. this should be used toprogrammatically highlight values.this methodcall the listener.",
	"Method": "void highlightValues(Highlight[] highs){\r\n    mIndicesToHighlight = highs;\r\n    setLastHighlighted(highs);\r\n    invalidate();\r\n}"
}, {
	"Path": "okhttp3.RecordedResponse.cacheResponse",
	"Comment": "asserts that the current response used the cache and returns the cache response.",
	"Method": "RecordedResponse cacheResponse(){\r\n    Response cacheResponse = response.cacheResponse();\r\n    assertNotNull(cacheResponse);\r\n    assertNull(cacheResponse.body());\r\n    return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null, null);\r\n}"
}, {
	"Path": "org.openrefine.wikidata.updates.ItemUpdateBuilder.addLabels",
	"Comment": "adds a list of labels to the item. it will override any existing label ineach language.",
	"Method": "ItemUpdateBuilder addLabels(Set<MonolingualTextValue> labels){\r\n    Validate.isTrue(!built, \"ItemUpdate has already been built\");\r\n    this.labels.addAll(labels);\r\n    return this;\r\n}"
}, {
	"Path": "okhttp3.TestUtil.defaultClient",
	"Comment": "returns an okhttpclient for all tests to use as a starting point.the shared instance allows all tests to share a single connection pool, which prevents idleconnections from consuming unnecessary resources while connections wait to be evicted.this client is also configured to be slightly more deterministic, returning a single ipaddress for all hosts, regardless of the actual number of ip addresses reported by dns.",
	"Method": "OkHttpClient defaultClient(){\r\n    return // Prevent unexpected fallback addresses.\r\n    new OkHttpClient.Builder().connectionPool(connectionPool).dispatcher(dispatcher).dns(SINGLE_INET_ADDRESS_DNS).build();\r\n}"
}, {
	"Path": "org.mockito.internal.util.io.IOUtil.closeQuietly",
	"Comment": "closes the target. does nothing when target is null. is silent.",
	"Method": "void closeQuietly(Closeable closeable){\r\n    try {\r\n        close(closeable);\r\n    } catch (MockitoException ignored) {\r\n    }\r\n}"
}, {
	"Path": "okhttp3.android.HttpResponseCache.install",
	"Comment": "creates a new http response cache and sets it as the system default cache.",
	"Method": "HttpResponseCache install(File directory,long maxSize){\r\n    ResponseCache installed = ResponseCache.getDefault();\r\n    if (installed instanceof HttpResponseCache) {\r\n        HttpResponseCache installedResponseCache = (HttpResponseCache) installed;\r\n        AndroidShimResponseCache trueResponseCache = installedResponseCache.shimResponseCache;\r\n        if (trueResponseCache.isEquivalent(directory, maxSize)) {\r\n            return installedResponseCache;\r\n        } else {\r\n            trueResponseCache.close();\r\n        }\r\n    }\r\n    AndroidShimResponseCache trueResponseCache = AndroidShimResponseCache.create(directory, maxSize);\r\n    HttpResponseCache newResponseCache = new HttpResponseCache(trueResponseCache);\r\n    ResponseCache.setDefault(newResponseCache);\r\n    return newResponseCache;\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.lce.MvpLceFragment.animateLoadingViewIn",
	"Comment": "override this method if you want to provide your own animation for showing the loading view",
	"Method": "void animateLoadingViewIn(){\r\n    LceAnimator.showLoading(loadingView, contentView, errorView);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.BaseEntry.getData",
	"Comment": "returns the data, additional information that this entry represents, ornull, if no data has been specified.",
	"Method": "Object getData(){\r\n    return mData;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.ChartData.getColors",
	"Comment": "returns all colors used across all dataset objects this objectrepresents.",
	"Method": "int[] getColors(){\r\n    if (mDataSets == null)\r\n        return null;\r\n    int clrcnt = 0;\r\n    for (int i = 0; i < mDataSets.size(); i++) {\r\n        clrcnt += mDataSets.get(i).getColors().size();\r\n    }\r\n    int[] colors = new int[clrcnt];\r\n    int cnt = 0;\r\n    for (int i = 0; i < mDataSets.size(); i++) {\r\n        List<Integer> clrs = mDataSets.get(i).getColors();\r\n        for (Integer clr : clrs) {\r\n            colors[cnt] = clr;\r\n            cnt++;\r\n        }\r\n    }\r\n    return colors;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.ObjectPool.create",
	"Comment": "returns an objectpool instance, of a given starting capacity, that recycles instances of a given poolable object.",
	"Method": "ObjectPool create(int withCapacity,Poolable object){\r\n    ObjectPool result = new ObjectPool(withCapacity, object);\r\n    result.poolId = ids;\r\n    ids++;\r\n    return result;\r\n}"
}, {
	"Path": "org.mockito.internal.configuration.injection.scanner.MockScanner.scan",
	"Comment": "scan and prepare mocks for the given testclassinstance and clazz in the type hierarchy.",
	"Method": "Set<Object> scan(){\r\n    Set<Object> mocks = newMockSafeHashSet();\r\n    for (Field field : clazz.getDeclaredFields()) {\r\n        FieldReader fieldReader = new FieldReader(instance, field);\r\n        Object mockInstance = preparedMock(fieldReader.read(), field);\r\n        if (mockInstance != null) {\r\n            mocks.add(mockInstance);\r\n        }\r\n    }\r\n    return mocks;\r\n}"
}, {
	"Path": "org.mockito.internal.util.collections.Iterables.firstOf",
	"Comment": "returns first element of provided iterable or fails fast when iterable is empty.",
	"Method": "T firstOf(Iterable<T> iterable){\r\n    Iterator<T> iterator = iterable.iterator();\r\n    if (!iterator.hasNext()) {\r\n        throw new IllegalArgumentException(\"Cannot provide 1st element from empty iterable: \" + iterable);\r\n    }\r\n    return iterator.next();\r\n}"
}, {
	"Path": "okhttp3.OkHttpClientTest.cloneSharesStatefulInstances",
	"Comment": "when copying the client, stateful things like the connection pool are shared across allclients.",
	"Method": "void cloneSharesStatefulInstances(){\r\n    OkHttpClient client = defaultClient();\r\n    OkHttpClient a = client.newBuilder().build();\r\n    assertNotNull(a.dispatcher());\r\n    assertNotNull(a.connectionPool());\r\n    assertNotNull(a.sslSocketFactory());\r\n    OkHttpClient b = client.newBuilder().build();\r\n    assertSame(a.dispatcher(), b.dispatcher());\r\n    assertSame(a.connectionPool(), b.connectionPool());\r\n    assertSame(a.sslSocketFactory(), b.sslSocketFactory());\r\n}"
}, {
	"Path": "com.google.refine.clustering.binning.Metaphone3.Encode",
	"Comment": "encodes input string to one or two key values according to metaphone 3 rules.",
	"Method": "void Encode(){\r\n    flag_AL_inversion = false;\r\n    m_current = 0;\r\n    m_primary.setLength(0);\r\n    m_secondary.setLength(0);\r\n    if (m_length < 1) {\r\n        return;\r\n    }\r\n    m_last = m_length - 1;\r\n    while (!(m_primary.length() > m_metaphLength) && !(m_secondary.length() > m_metaphLength)) {\r\n        if (m_current >= m_length) {\r\n            break;\r\n        }\r\n        switch(CharAt(m_current)) {\r\n            case 'B':\r\n                Encode_B();\r\n                break;\r\n            case '':\r\n            case '':\r\n                MetaphAdd(\"S\");\r\n                m_current++;\r\n                break;\r\n            case 'C':\r\n                Encode_C();\r\n                break;\r\n            case 'D':\r\n                Encode_D();\r\n                break;\r\n            case 'F':\r\n                Encode_F();\r\n                break;\r\n            case 'G':\r\n                Encode_G();\r\n                break;\r\n            case 'H':\r\n                Encode_H();\r\n                break;\r\n            case 'J':\r\n                Encode_J();\r\n                break;\r\n            case 'K':\r\n                Encode_K();\r\n                break;\r\n            case 'L':\r\n                Encode_L();\r\n                break;\r\n            case 'M':\r\n                Encode_M();\r\n                break;\r\n            case 'N':\r\n                Encode_N();\r\n                break;\r\n            case '':\r\n                MetaphAdd(\"N\");\r\n                m_current++;\r\n                break;\r\n            case 'P':\r\n                Encode_P();\r\n                break;\r\n            case 'Q':\r\n                Encode_Q();\r\n                break;\r\n            case 'R':\r\n                Encode_R();\r\n                break;\r\n            case 'S':\r\n                Encode_S();\r\n                break;\r\n            case 'T':\r\n                Encode_T();\r\n                break;\r\n            case '':\r\n            case '':\r\n                MetaphAdd(\"0\");\r\n                m_current++;\r\n                break;\r\n            case 'V':\r\n                Encode_V();\r\n                break;\r\n            case 'W':\r\n                Encode_W();\r\n                break;\r\n            case 'X':\r\n                Encode_X();\r\n                break;\r\n            case '':\r\n                MetaphAdd(\"X\");\r\n                m_current++;\r\n                break;\r\n            case '':\r\n                MetaphAdd(\"S\");\r\n                m_current++;\r\n                break;\r\n            case 'Z':\r\n                Encode_Z();\r\n                break;\r\n            default:\r\n                if (IsVowel(CharAt(m_current))) {\r\n                    Encode_Vowels();\r\n                    break;\r\n                }\r\n                m_current++;\r\n        }\r\n    }\r\n    if (m_primary.length() > m_metaphLength) {\r\n        m_primary.setLength(m_metaphLength);\r\n    }\r\n    if (m_secondary.length() > m_metaphLength) {\r\n        m_secondary.setLength(m_metaphLength);\r\n    }\r\n    if ((m_primary.toString()).equals(m_secondary.toString())) {\r\n        m_secondary.setLength(0);\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.Legend.getMaximumEntryHeight",
	"Comment": "returns the maximum height in pixels across all legend labels",
	"Method": "float getMaximumEntryHeight(Paint p){\r\n    float max = 0f;\r\n    for (LegendEntry entry : mEntries) {\r\n        String label = entry.label;\r\n        if (label == null)\r\n            continue;\r\n        float length = (float) Utils.calcTextHeight(p, label);\r\n        if (length > max)\r\n            max = length;\r\n    }\r\n    return max;\r\n}"
}, {
	"Path": "org.apache.ibatis.io.DefaultVFS.isJar",
	"Comment": "returns true if the resource located at the given url is a jar file.",
	"Method": "boolean isJar(URL url,boolean isJar,URL url,byte[] buffer){\r\n    InputStream is = null;\r\n    try {\r\n        is = url.openStream();\r\n        is.read(buffer, 0, JAR_MAGIC.length);\r\n        if (Arrays.equals(buffer, JAR_MAGIC)) {\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"Found JAR: \" + url);\r\n            }\r\n            return true;\r\n        }\r\n    } catch (Exception e) {\r\n    } finally {\r\n        if (is != null) {\r\n            try {\r\n                is.close();\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.renderer.LegendRenderer.computeLegend",
	"Comment": "prepares the legend and calculates all needed forms, labels and colors.",
	"Method": "void computeLegend(ChartData<?> data){\r\n    if (!mLegend.isLegendCustom()) {\r\n        computedEntries.clear();\r\n        for (int i = 0; i < data.getDataSetCount(); i++) {\r\n            IDataSet dataSet = data.getDataSetByIndex(i);\r\n            List<Integer> clrs = dataSet.getColors();\r\n            int entryCount = dataSet.getEntryCount();\r\n            if (dataSet instanceof IBarDataSet && ((IBarDataSet) dataSet).isStacked()) {\r\n                IBarDataSet bds = (IBarDataSet) dataSet;\r\n                String[] sLabels = bds.getStackLabels();\r\n                for (int j = 0; j < clrs.size() && j < bds.getStackSize(); j++) {\r\n                    computedEntries.add(new LegendEntry(sLabels[j % sLabels.length], dataSet.getForm(), dataSet.getFormSize(), dataSet.getFormLineWidth(), dataSet.getFormLineDashEffect(), clrs.get(j)));\r\n                }\r\n                if (bds.getLabel() != null) {\r\n                    computedEntries.add(new LegendEntry(dataSet.getLabel(), Legend.LegendForm.NONE, Float.NaN, Float.NaN, null, ColorTemplate.COLOR_NONE));\r\n                }\r\n            } else if (dataSet instanceof IPieDataSet) {\r\n                IPieDataSet pds = (IPieDataSet) dataSet;\r\n                for (int j = 0; j < clrs.size() && j < entryCount; j++) {\r\n                    computedEntries.add(new LegendEntry(pds.getEntryForIndex(j).getLabel(), dataSet.getForm(), dataSet.getFormSize(), dataSet.getFormLineWidth(), dataSet.getFormLineDashEffect(), clrs.get(j)));\r\n                }\r\n                if (pds.getLabel() != null) {\r\n                    computedEntries.add(new LegendEntry(dataSet.getLabel(), Legend.LegendForm.NONE, Float.NaN, Float.NaN, null, ColorTemplate.COLOR_NONE));\r\n                }\r\n            } else if (dataSet instanceof ICandleDataSet && ((ICandleDataSet) dataSet).getDecreasingColor() != ColorTemplate.COLOR_NONE) {\r\n                int decreasingColor = ((ICandleDataSet) dataSet).getDecreasingColor();\r\n                int increasingColor = ((ICandleDataSet) dataSet).getIncreasingColor();\r\n                computedEntries.add(new LegendEntry(null, dataSet.getForm(), dataSet.getFormSize(), dataSet.getFormLineWidth(), dataSet.getFormLineDashEffect(), decreasingColor));\r\n                computedEntries.add(new LegendEntry(dataSet.getLabel(), dataSet.getForm(), dataSet.getFormSize(), dataSet.getFormLineWidth(), dataSet.getFormLineDashEffect(), increasingColor));\r\n            } else {\r\n                for (int j = 0; j < clrs.size() && j < entryCount; j++) {\r\n                    String label;\r\n                    if (j < clrs.size() - 1 && j < entryCount - 1) {\r\n                        label = null;\r\n                    } else {\r\n                        label = data.getDataSetByIndex(i).getLabel();\r\n                    }\r\n                    computedEntries.add(new LegendEntry(label, dataSet.getForm(), dataSet.getFormSize(), dataSet.getFormLineWidth(), dataSet.getFormLineDashEffect(), clrs.get(j)));\r\n                }\r\n            }\r\n        }\r\n        if (mLegend.getExtraEntries() != null) {\r\n            Collections.addAll(computedEntries, mLegend.getExtraEntries());\r\n        }\r\n        mLegend.setEntries(computedEntries);\r\n    }\r\n    Typeface tf = mLegend.getTypeface();\r\n    if (tf != null)\r\n        mLegendLabelPaint.setTypeface(tf);\r\n    mLegendLabelPaint.setTextSize(mLegend.getTextSize());\r\n    mLegendLabelPaint.setColor(mLegend.getTextColor());\r\n    mLegend.calculateDimensions(mLegendLabelPaint, mViewPortHandler);\r\n}"
}, {
	"Path": "okhttp3.AndroidShimResponseCache.maxSize",
	"Comment": "returns the maximum number of bytes that this cache should use to store its data.",
	"Method": "long maxSize(){\r\n    return delegate.maxSize();\r\n}"
}, {
	"Path": "okhttp3.Response.handshake",
	"Comment": "returns the tls handshake of the connection that carried this response, or null if the responsewas received without tls.",
	"Method": "Handshake handshake(Builder handshake,Handshake handshake){\r\n    return handshake;\r\n}"
}, {
	"Path": "okhttp3.internal.huc.OkHttpURLConnection.getResponse",
	"Comment": "aggressively tries to get the final http response, potentially making many http requests in theprocess in order to cope with redirects and authentication.",
	"Method": "Response getResponse(boolean networkResponseOnError){\r\n    synchronized (lock) {\r\n        if (response != null)\r\n            return response;\r\n        if (callFailure != null) {\r\n            if (networkResponseOnError && networkResponse != null)\r\n                return networkResponse;\r\n            throw propagate(callFailure);\r\n        }\r\n    }\r\n    Call call = buildCall();\r\n    networkInterceptor.proceed();\r\n    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) call.request().body();\r\n    if (requestBody != null)\r\n        requestBody.outputStream().close();\r\n    if (executed) {\r\n        synchronized (lock) {\r\n            try {\r\n                while (response == null && callFailure == null) {\r\n                    lock.wait();\r\n                }\r\n            } catch (InterruptedException e) {\r\n                Thread.currentThread().interrupt();\r\n                throw new InterruptedIOException();\r\n            }\r\n        }\r\n    } else {\r\n        executed = true;\r\n        try {\r\n            onResponse(call, call.execute());\r\n        } catch (IOException e) {\r\n            onFailure(call, e);\r\n        }\r\n    }\r\n    synchronized (lock) {\r\n        if (callFailure != null)\r\n            throw propagate(callFailure);\r\n        if (response != null)\r\n            return response;\r\n    }\r\n    throw new AssertionError();\r\n}"
}, {
	"Path": "org.openrefine.wikidata.schema.entityvalues.ReconEntityIdValue.getRecon",
	"Comment": "returns the reconciliation object corresponding to this entity.",
	"Method": "Recon getRecon(){\r\n    return _recon;\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.MvpNullObjectBasePresenter.isSubTypeOfMvpView",
	"Comment": "scans the interface inheritance hierarchy and checks if on the root is mvpview.class",
	"Method": "boolean isSubTypeOfMvpView(Class<?> klass){\r\n    if (klass.equals(MvpView.class)) {\r\n        return true;\r\n    }\r\n    Class[] superInterfaces = klass.getInterfaces();\r\n    for (int i = 0; i < superInterfaces.length; i++) {\r\n        if (isSubTypeOfMvpView(superInterfaces[i])) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.getDefaultValueFormatter",
	"Comment": "returns the default ivalueformatter that has been determined by the chartconsidering the provided minimum and maximum values.",
	"Method": "ValueFormatter getDefaultValueFormatter(){\r\n    return mDefaultValueFormatter;\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.common.util.jsr166.ConcurrentReferenceHashMap.put",
	"Comment": "maps the specified key to the specified value in this table.neither the key nor the value can be null. the value can be retrieved by calling the get methodwith a key that is equal to the original key.",
	"Method": "V put(K key,int hash,V value,boolean onlyIfAbsent,V put,K key,V value){\r\n    if (value == null)\r\n        throw new NullPointerException();\r\n    int hash = hashOf(key);\r\n    return segmentFor(hash).put(key, hash, value, false);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.Transformer.generateTransformedValuesLine",
	"Comment": "transforms an list of entry into a float array containing the x andy values transformed with all matrices for the linechart.",
	"Method": "float[] generateTransformedValuesLine(ILineDataSet data,float phaseX,float phaseY,int min,int max){\r\n    final int count = ((int) ((max - min) * phaseX) + 1) * 2;\r\n    if (valuePointsForGenerateTransformedValuesLine.length != count) {\r\n        valuePointsForGenerateTransformedValuesLine = new float[count];\r\n    }\r\n    float[] valuePoints = valuePointsForGenerateTransformedValuesLine;\r\n    for (int j = 0; j < count; j += 2) {\r\n        Entry e = data.getEntryForIndex(j / 2 + min);\r\n        if (e != null) {\r\n            valuePoints[j] = e.getX();\r\n            valuePoints[j + 1] = e.getY() * phaseY;\r\n        } else {\r\n            valuePoints[j] = 0;\r\n            valuePoints[j + 1] = 0;\r\n        }\r\n    }\r\n    getValueToPixelMatrix().mapPoints(valuePoints);\r\n    return valuePoints;\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvi.MviFragment.getMvpDelegate",
	"Comment": "get the mvp delegate. this is internally used for creating presenter, attaching and detachingviewstate from presenter.please note that only one instance of mvp delegate should be used per fragmentinstance.only override this method if you really know what you are doing.",
	"Method": "FragmentMviDelegate<V, P> getMvpDelegate(){\r\n    if (mvpDelegate == null) {\r\n        mvpDelegate = new FragmentMviDelegateImpl<V, P>(this, this);\r\n    }\r\n    return mvpDelegate;\r\n}"
}, {
	"Path": "com.google.refine.clustering.binning.Metaphone3.GetKeyLength",
	"Comment": "retrieves maximum number of characters currently allocated for encoded key.",
	"Method": "int GetKeyLength(){\r\n    return m_metaphLength;\r\n}"
}, {
	"Path": "org.openrefine.wikidata.updates.ItemUpdateBuilder.addLabel",
	"Comment": "adds a label to the item. it will override any existing label in thislanguage.",
	"Method": "ItemUpdateBuilder addLabel(MonolingualTextValue label){\r\n    Validate.isTrue(!built, \"ItemUpdate has already been built\");\r\n    labels.add(label);\r\n    return this;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.PieRadarChartBase.getRotationAngle",
	"Comment": "gets a normalized version of the current rotation angle of the pie chart,which will always be between 0.0360.0",
	"Method": "float getRotationAngle(){\r\n    return mRotationAngle;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.Legend.calculateDimensions",
	"Comment": "calculates the dimensions of the legend. this includes the maximum widthand height of a single entry, as well as the total width and height ofthe legend.",
	"Method": "void calculateDimensions(Paint labelpaint,ViewPortHandler viewPortHandler){\r\n    float defaultFormSize = Utils.convertDpToPixel(mFormSize);\r\n    float stackSpace = Utils.convertDpToPixel(mStackSpace);\r\n    float formToTextSpace = Utils.convertDpToPixel(mFormToTextSpace);\r\n    float xEntrySpace = Utils.convertDpToPixel(mXEntrySpace);\r\n    float yEntrySpace = Utils.convertDpToPixel(mYEntrySpace);\r\n    boolean wordWrapEnabled = mWordWrapEnabled;\r\n    LegendEntry[] entries = mEntries;\r\n    int entryCount = entries.length;\r\n    mTextWidthMax = getMaximumEntryWidth(labelpaint);\r\n    mTextHeightMax = getMaximumEntryHeight(labelpaint);\r\n    switch(mOrientation) {\r\n        case VERTICAL:\r\n            {\r\n                float maxWidth = 0f, maxHeight = 0f, width = 0f;\r\n                float labelLineHeight = Utils.getLineHeight(labelpaint);\r\n                boolean wasStacked = false;\r\n                for (int i = 0; i < entryCount; i++) {\r\n                    LegendEntry e = entries[i];\r\n                    boolean drawingForm = e.form != LegendForm.NONE;\r\n                    float formSize = Float.isNaN(e.formSize) ? defaultFormSize : Utils.convertDpToPixel(e.formSize);\r\n                    String label = e.label;\r\n                    if (!wasStacked)\r\n                        width = 0.f;\r\n                    if (drawingForm) {\r\n                        if (wasStacked)\r\n                            width += stackSpace;\r\n                        width += formSize;\r\n                    }\r\n                    if (label != null) {\r\n                        if (drawingForm && !wasStacked)\r\n                            width += formToTextSpace;\r\n                        else if (wasStacked) {\r\n                            maxWidth = Math.max(maxWidth, width);\r\n                            maxHeight += labelLineHeight + yEntrySpace;\r\n                            width = 0.f;\r\n                            wasStacked = false;\r\n                        }\r\n                        width += Utils.calcTextWidth(labelpaint, label);\r\n                        if (i < entryCount - 1)\r\n                            maxHeight += labelLineHeight + yEntrySpace;\r\n                    } else {\r\n                        wasStacked = true;\r\n                        width += formSize;\r\n                        if (i < entryCount - 1)\r\n                            width += stackSpace;\r\n                    }\r\n                    maxWidth = Math.max(maxWidth, width);\r\n                }\r\n                mNeededWidth = maxWidth;\r\n                mNeededHeight = maxHeight;\r\n                break;\r\n            }\r\n        case HORIZONTAL:\r\n            {\r\n                float labelLineHeight = Utils.getLineHeight(labelpaint);\r\n                float labelLineSpacing = Utils.getLineSpacing(labelpaint) + yEntrySpace;\r\n                float contentWidth = viewPortHandler.contentWidth() * mMaxSizePercent;\r\n                float maxLineWidth = 0.f;\r\n                float currentLineWidth = 0.f;\r\n                float requiredWidth = 0.f;\r\n                int stackedStartIndex = -1;\r\n                mCalculatedLabelBreakPoints.clear();\r\n                mCalculatedLabelSizes.clear();\r\n                mCalculatedLineSizes.clear();\r\n                for (int i = 0; i < entryCount; i++) {\r\n                    LegendEntry e = entries[i];\r\n                    boolean drawingForm = e.form != LegendForm.NONE;\r\n                    float formSize = Float.isNaN(e.formSize) ? defaultFormSize : Utils.convertDpToPixel(e.formSize);\r\n                    String label = e.label;\r\n                    mCalculatedLabelBreakPoints.add(false);\r\n                    if (stackedStartIndex == -1) {\r\n                        requiredWidth = 0.f;\r\n                    } else {\r\n                        requiredWidth += stackSpace;\r\n                    }\r\n                    if (label != null) {\r\n                        mCalculatedLabelSizes.add(Utils.calcTextSize(labelpaint, label));\r\n                        requiredWidth += drawingForm ? formToTextSpace + formSize : 0.f;\r\n                        requiredWidth += mCalculatedLabelSizes.get(i).width;\r\n                    } else {\r\n                        mCalculatedLabelSizes.add(FSize.getInstance(0.f, 0.f));\r\n                        requiredWidth += drawingForm ? formSize : 0.f;\r\n                        if (stackedStartIndex == -1) {\r\n                            stackedStartIndex = i;\r\n                        }\r\n                    }\r\n                    if (label != null || i == entryCount - 1) {\r\n                        float requiredSpacing = currentLineWidth == 0.f ? 0.f : xEntrySpace;\r\n                        if (!wordWrapEnabled || currentLineWidth == 0.f || (contentWidth - currentLineWidth >= requiredSpacing + requiredWidth)) {\r\n                            currentLineWidth += requiredSpacing + requiredWidth;\r\n                        } else {\r\n                            mCalculatedLineSizes.add(FSize.getInstance(currentLineWidth, labelLineHeight));\r\n                            maxLineWidth = Math.max(maxLineWidth, currentLineWidth);\r\n                            mCalculatedLabelBreakPoints.set(stackedStartIndex > -1 ? stackedStartIndex : i, true);\r\n                            currentLineWidth = requiredWidth;\r\n                        }\r\n                        if (i == entryCount - 1) {\r\n                            mCalculatedLineSizes.add(FSize.getInstance(currentLineWidth, labelLineHeight));\r\n                            maxLineWidth = Math.max(maxLineWidth, currentLineWidth);\r\n                        }\r\n                    }\r\n                    stackedStartIndex = label != null ? -1 : stackedStartIndex;\r\n                }\r\n                mNeededWidth = maxLineWidth;\r\n                mNeededHeight = labelLineHeight * (float) (mCalculatedLineSizes.size()) + labelLineSpacing * (float) (mCalculatedLineSizes.size() == 0 ? 0 : (mCalculatedLineSizes.size() - 1));\r\n                break;\r\n            }\r\n    }\r\n    mNeededHeight += mYOffset;\r\n    mNeededWidth += mXOffset;\r\n}"
}, {
	"Path": "com.google.refine.history.History.addEntry",
	"Comment": "adds a historyentry to the list of past historiesadding a new entry clears all currently held future histories",
	"Method": "void addEntry(HistoryEntry entry){\r\n    Project project = ProjectManager.singleton.getProject(_projectID);\r\n    synchronized (project) {\r\n        synchronized (this) {\r\n            entry.apply(project);\r\n            _pastEntries.add(entry);\r\n            setModified();\r\n            List<HistoryEntry> futureEntries = _futureEntries;\r\n            _futureEntries = new ArrayList<HistoryEntry>();\r\n            for (HistoryEntry entry2 : futureEntries) {\r\n                try {\r\n                    entry2.delete();\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.ChartData.addEntry",
	"Comment": "adds an entry to the dataset at the specified index.entries are added to the end of the list.",
	"Method": "void addEntry(Entry e,int dataSetIndex){\r\n    if (mDataSets.size() > dataSetIndex && dataSetIndex >= 0) {\r\n        IDataSet set = mDataSets.get(dataSetIndex);\r\n        if (!set.addEntry(e))\r\n            return;\r\n        calcMinMax(e, set.getAxisDependency());\r\n    } else {\r\n        Log.e(\"addEntry\", \"Cannot add Entry because dataSetIndex too high or too low.\");\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.isAnyAxisInverted",
	"Comment": "returns true if either the left or the right or both axes are inverted.",
	"Method": "boolean isAnyAxisInverted(){\r\n    if (mAxisLeft.isInverted())\r\n        return true;\r\n    if (mAxisRight.isInverted())\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.mockito.internal.matchers.apachecommons.EqualsBuilder.isEquals",
	"Comment": "returns true if the fields that have been checkedare all equal.",
	"Method": "boolean isEquals(){\r\n    return this.isEquals;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.PieDataSet.isAutomaticallyDisableSliceSpacingEnabled",
	"Comment": "when enabled, slice spacing will be 0.0 when the smallest value is going to besmaller than the slice spacing itself.",
	"Method": "boolean isAutomaticallyDisableSliceSpacingEnabled(){\r\n    return mAutomaticallyDisableSliceSpacing;\r\n}"
}, {
	"Path": "org.openrefine.wikidata.updates.scheduler.UpdateSequence.add",
	"Comment": "adds a new update to the list, merging it with any existing one with the samesubject.",
	"Method": "void add(ItemUpdate update){\r\n    ItemIdValue subject = update.getItemId();\r\n    if (index.containsKey(subject)) {\r\n        int i = index.get(subject);\r\n        ItemUpdate oldUpdate = updates.get(i);\r\n        updates.set(i, oldUpdate.merge(update));\r\n    } else {\r\n        index.put(subject, updates.size());\r\n        updates.add(update);\r\n    }\r\n}"
}, {
	"Path": "okhttp3.AndroidShimResponseCache.flush",
	"Comment": "force buffered operations to the filesystem. this ensures that responses written to the cachewill be available the next time the cache is opened, even if this process is killed.",
	"Method": "void flush(){\r\n    delegate.flush();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.getAnimator",
	"Comment": "returns the animator responsible for animating chart values.",
	"Method": "ChartAnimator getAnimator(){\r\n    return mAnimator;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.PieDataSet.isValueLineVariableLength",
	"Comment": "when valueposition is outsideslice, this allows variable line length",
	"Method": "boolean isValueLineVariableLength(){\r\n    return mValueLineVariableLength;\r\n}"
}, {
	"Path": "org.mockito.internal.verification.VerificationModeFactory.description",
	"Comment": "verification mode will prepend the specified failure message if verification fails with the given implementation.",
	"Method": "VerificationMode description(VerificationMode mode,String description){\r\n    return new Description(mode, description);\r\n}"
}, {
	"Path": "org.openrefine.wikidata.qa.WikidataConstraintFetcher.getSingleConstraint",
	"Comment": "returns a single constraint for a particular type and a property, or null ifthere is no such constraint",
	"Method": "List<SnakGroup> getSingleConstraint(PropertyIdValue pid,String qid){\r\n    Statement statement = getConstraintsByType(pid, qid).findFirst().orElse(null);\r\n    if (statement != null) {\r\n        return statement.getClaim().getQualifiers();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "okhttp3.internal.cache.DiskLruCache.setMaxSize",
	"Comment": "changes the maximum number of bytes the cache can store and queues a job to trim the existingstore, if necessary.",
	"Method": "void setMaxSize(long maxSize){\r\n    this.maxSize = maxSize;\r\n    if (initialized) {\r\n        executor.execute(cleanupRunnable);\r\n    }\r\n}"
}, {
	"Path": "okhttp3.CacheTest.testGoldenCacheHttpsResponseOkHttp27",
	"Comment": "exercise the cache format in okhttp 2.7 and all earlier releases.",
	"Method": "void testGoldenCacheHttpsResponseOkHttp27(){\r\n    HttpUrl url = server.url(\"/\");\r\n    String urlKey = Cache.key(url);\r\n    String prefix = Platform.get().getPrefix();\r\n    String entryMetadata = \"\" + \"\" + url + \"\\n\" + \"GET\\n\" + \"0\\n\" + \"HTTP/1.1 200 OK\\n\" + \"4\\n\" + \"Content-Length: 3\\n\" + prefix + \"-Received-Millis: \" + System.currentTimeMillis() + \"\\n\" + prefix + \"-Sent-Millis: \" + System.currentTimeMillis() + \"\\n\" + \"Cache-Control: max-age=60\\n\" + \"\\n\" + \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\\n\" + \"1\\n\" + \"MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx\" + \"MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ\" + \"AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac\" + \"AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1\" + \"AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2\" + \"mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl\" + \"593hD55E4+lY22JZiVQyjsQhe6I=\\n\" + \"0\\n\";\r\n    String entryBody = \"abc\";\r\n    String journalBody = \"\" + \"libcore.io.DiskLruCache\\n\" + \"1\\n\" + \"201105\\n\" + \"2\\n\" + \"\\n\" + \"DIRTY \" + urlKey + \"\\n\" + \"CLEAN \" + urlKey + \" \" + entryMetadata.length() + \" \" + entryBody.length() + \"\\n\";\r\n    writeFile(cache.directory(), urlKey + \".0\", entryMetadata);\r\n    writeFile(cache.directory(), urlKey + \".1\", entryBody);\r\n    writeFile(cache.directory(), \"journal\", journalBody);\r\n    cache.close();\r\n    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);\r\n    client = client.newBuilder().cache(cache).build();\r\n    Response response = get(url);\r\n    assertEquals(entryBody, response.body().string());\r\n    assertEquals(\"3\", response.header(\"Content-Length\"));\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonWriter.getIndent",
	"Comment": "returns a string containing only whitespace, used for each level ofindentation. if empty, the encoded document will be compact.",
	"Method": "String getIndent(){\r\n    return indent != null ? indent : \"\";\r\n}"
}, {
	"Path": "org.mockito.internal.configuration.injection.scanner.MockScanner.addPreparedMocks",
	"Comment": "add the scanned and prepared mock instance to the given collection.the preparation of mocks consists only in defining a mockname if not already set.",
	"Method": "void addPreparedMocks(Set<Object> mocks){\r\n    mocks.addAll(scan());\r\n}"
}, {
	"Path": "com.github.mikephil.charting.renderer.AxisRenderer.getTransformer",
	"Comment": "returns the transformer object used for transforming the axis values.",
	"Method": "Transformer getTransformer(){\r\n    return mTrans;\r\n}"
}, {
	"Path": "okhttp3.internal.ws.WebSocketWriter.newMessageSink",
	"Comment": "stream a message payload as a series of frames. this allows control frames to be interleavedbetween parts of the message.",
	"Method": "Sink newMessageSink(int formatOpcode,long contentLength){\r\n    if (activeWriter) {\r\n        throw new IllegalStateException(\"Another message writer is active. Did you call close()?\");\r\n    }\r\n    activeWriter = true;\r\n    frameSink.formatOpcode = formatOpcode;\r\n    frameSink.contentLength = contentLength;\r\n    frameSink.isFirstFrame = true;\r\n    frameSink.closed = false;\r\n    return frameSink;\r\n}"
}, {
	"Path": "okhttp3.internal.huc.JavaApiConverter.createOkBody",
	"Comment": "creates an okhttp response.body containing the supplied information.",
	"Method": "ResponseBody createOkBody(Headers okHeaders,CacheResponse cacheResponse,ResponseBody createOkBody,URLConnection urlConnection){\r\n    if (!urlConnection.getDoInput()) {\r\n        return null;\r\n    }\r\n    final BufferedSource body = Okio.buffer(Okio.source(urlConnection.getInputStream()));\r\n    return new ResponseBody() {\r\n        @Override\r\n        public MediaType contentType() {\r\n            String contentTypeHeader = urlConnection.getContentType();\r\n            return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);\r\n        }\r\n        @Override\r\n        public long contentLength() {\r\n            String s = urlConnection.getHeaderField(\"Content-Length\");\r\n            return stringToLong(s);\r\n        }\r\n        @Override\r\n        public BufferedSource source() {\r\n            return body;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "okhttp3.internal.huc.JavaApiConverter.createOkBody",
	"Comment": "creates an okhttp response.body containing the supplied information.",
	"Method": "ResponseBody createOkBody(Headers okHeaders,CacheResponse cacheResponse,ResponseBody createOkBody,URLConnection urlConnection){\r\n    String contentTypeHeader = urlConnection.getContentType();\r\n    return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);\r\n}"
}, {
	"Path": "okhttp3.internal.huc.JavaApiConverter.createOkBody",
	"Comment": "creates an okhttp response.body containing the supplied information.",
	"Method": "ResponseBody createOkBody(Headers okHeaders,CacheResponse cacheResponse,ResponseBody createOkBody,URLConnection urlConnection){\r\n    String s = urlConnection.getHeaderField(\"Content-Length\");\r\n    return stringToLong(s);\r\n}"
}, {
	"Path": "okhttp3.internal.huc.JavaApiConverter.createOkBody",
	"Comment": "creates an okhttp response.body containing the supplied information.",
	"Method": "ResponseBody createOkBody(Headers okHeaders,CacheResponse cacheResponse,ResponseBody createOkBody,URLConnection urlConnection){\r\n    return body;\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testCallWithResultSet4",
	"Comment": "this test shows how to use a input and output parameters and return aresult set from a stored procedure.this test shows using a map parameter.",
	"Method": "void testCallWithResultSet4(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        Map<String, Object> parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 2);\r\n        List<Name> names = spMapper.getNames(parms);\r\n        assertEquals(2, parms.get(\"totalRows\"));\r\n        assertEquals(2, names.size());\r\n        parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 2);\r\n        names = spMapper.getNames(parms);\r\n        assertEquals(2, names.size());\r\n        assertEquals(2, parms.get(\"totalRows\"));\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testCallWithResultSet3",
	"Comment": "this test shows how to use a input and output parameters and return aresult set from a stored procedure.this test shows using a map parameter.",
	"Method": "void testCallWithResultSet3(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        Map<String, Object> parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 2);\r\n        List<Name> names = spMapper.getNames(parms);\r\n        assertEquals(2, parms.get(\"totalRows\"));\r\n        assertEquals(2, names.size());\r\n        parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 3);\r\n        names = spMapper.getNames(parms);\r\n        assertEquals(1, names.size());\r\n        assertEquals(1, parms.get(\"totalRows\"));\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testCallWithResultSet2",
	"Comment": "this test shows how to use a input and output parameters and return aresult set from a stored procedure.this test shows using a single value parameter.",
	"Method": "void testCallWithResultSet2(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        Map<String, Object> parms = new HashMap<String, Object>();\r\n        parms.put(\"lowestId\", 1);\r\n        List<Name> names = spMapper.getNames(parms);\r\n        assertEquals(3, names.size());\r\n        assertEquals(3, parms.get(\"totalRows\"));\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.renderer.XAxisRendererHorizontalBarChart.renderLimitLines",
	"Comment": "draws the limitlines associated with this axis to the screen.\tthis is the standard yaxis renderer using the xaxis limit lines.",
	"Method": "void renderLimitLines(Canvas c){\r\n    List<LimitLine> limitLines = mXAxis.getLimitLines();\r\n    if (limitLines == null || limitLines.size() <= 0)\r\n        return;\r\n    float[] pts = mRenderLimitLinesBuffer;\r\n    pts[0] = 0;\r\n    pts[1] = 0;\r\n    Path limitLinePath = mRenderLimitLinesPathBuffer;\r\n    limitLinePath.reset();\r\n    for (int i = 0; i < limitLines.size(); i++) {\r\n        LimitLine l = limitLines.get(i);\r\n        if (!l.isEnabled())\r\n            continue;\r\n        int clipRestoreCount = c.save();\r\n        mLimitLineClippingRect.set(mViewPortHandler.getContentRect());\r\n        mLimitLineClippingRect.inset(0.f, -l.getLineWidth());\r\n        c.clipRect(mLimitLineClippingRect);\r\n        mLimitLinePaint.setStyle(Paint.Style.STROKE);\r\n        mLimitLinePaint.setColor(l.getLineColor());\r\n        mLimitLinePaint.setStrokeWidth(l.getLineWidth());\r\n        mLimitLinePaint.setPathEffect(l.getDashPathEffect());\r\n        pts[1] = l.getLimit();\r\n        mTrans.pointValuesToPixel(pts);\r\n        limitLinePath.moveTo(mViewPortHandler.contentLeft(), pts[1]);\r\n        limitLinePath.lineTo(mViewPortHandler.contentRight(), pts[1]);\r\n        c.drawPath(limitLinePath, mLimitLinePaint);\r\n        limitLinePath.reset();\r\n        String label = l.getLabel();\r\n        if (label != null && !label.equals(\"\")) {\r\n            mLimitLinePaint.setStyle(l.getTextStyle());\r\n            mLimitLinePaint.setPathEffect(null);\r\n            mLimitLinePaint.setColor(l.getTextColor());\r\n            mLimitLinePaint.setStrokeWidth(0.5f);\r\n            mLimitLinePaint.setTextSize(l.getTextSize());\r\n            final float labelLineHeight = Utils.calcTextHeight(mLimitLinePaint, label);\r\n            float xOffset = Utils.convertDpToPixel(4f) + l.getXOffset();\r\n            float yOffset = l.getLineWidth() + labelLineHeight + l.getYOffset();\r\n            final LimitLine.LimitLabelPosition position = l.getLabelPosition();\r\n            if (position == LimitLine.LimitLabelPosition.RIGHT_TOP) {\r\n                mLimitLinePaint.setTextAlign(Align.RIGHT);\r\n                c.drawText(label, mViewPortHandler.contentRight() - xOffset, pts[1] - yOffset + labelLineHeight, mLimitLinePaint);\r\n            } else if (position == LimitLine.LimitLabelPosition.RIGHT_BOTTOM) {\r\n                mLimitLinePaint.setTextAlign(Align.RIGHT);\r\n                c.drawText(label, mViewPortHandler.contentRight() - xOffset, pts[1] + yOffset, mLimitLinePaint);\r\n            } else if (position == LimitLine.LimitLabelPosition.LEFT_TOP) {\r\n                mLimitLinePaint.setTextAlign(Align.LEFT);\r\n                c.drawText(label, mViewPortHandler.contentLeft() + xOffset, pts[1] - yOffset + labelLineHeight, mLimitLinePaint);\r\n            } else {\r\n                mLimitLinePaint.setTextAlign(Align.LEFT);\r\n                c.drawText(label, mViewPortHandler.offsetLeft() + xOffset, pts[1] + yOffset, mLimitLinePaint);\r\n            }\r\n        }\r\n        c.restoreToCount(clipRestoreCount);\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.submitted.sptests.SPTest.testCallWithResultSet1",
	"Comment": "this test shows how to use an input parameter and return a result set froma stored procedure.this test shows using a single value parameter.",
	"Method": "void testCallWithResultSet1(){\r\n    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {\r\n        SPMapper spMapper = sqlSession.getMapper(SPMapper.class);\r\n        Name name = spMapper.getName(1);\r\n        assertNotNull(name);\r\n        assertEquals(\"Wilma\", name.getFirstName());\r\n    }\r\n}"
}, {
	"Path": "okhttp3.RecordedResponse.priorResponse",
	"Comment": "asserts that the current response was redirected and returns the prior response.",
	"Method": "RecordedResponse priorResponse(){\r\n    Response priorResponse = response.priorResponse();\r\n    assertNotNull(priorResponse);\r\n    assertNull(priorResponse.body());\r\n    return new RecordedResponse(priorResponse.request(), priorResponse, null, null, null);\r\n}"
}, {
	"Path": "org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin",
	"Comment": "scans the classpath for given plugintype. if not found, default class is used.",
	"Method": "T loadPlugin(Class<T> pluginType,Object loadPlugin,Class<PreferredType> preferredPluginType,Class<AlternateType> alternatePluginType){\r\n    try {\r\n        PreferredType preferredPlugin = initializer.loadImpl(preferredPluginType);\r\n        if (preferredPlugin != null) {\r\n            return preferredPlugin;\r\n        } else if (alternatePluginType != null) {\r\n            AlternateType alternatePlugin = initializer.loadImpl(alternatePluginType);\r\n            if (alternatePlugin != null) {\r\n                return alternatePlugin;\r\n            }\r\n        }\r\n        return plugins.getDefaultPlugin(preferredPluginType);\r\n    } catch (final Throwable t) {\r\n        return Proxy.newProxyInstance(preferredPluginType.getClassLoader(), new Class<?>[] { preferredPluginType }, new InvocationHandler() {\r\n            @Override\r\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n                throw new IllegalStateException(\"Could not initialize plugin: \" + preferredPluginType + \" (alternate: \" + alternatePluginType + \")\", t);\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin",
	"Comment": "scans the classpath for given plugintype. if not found, default class is used.",
	"Method": "T loadPlugin(Class<T> pluginType,Object loadPlugin,Class<PreferredType> preferredPluginType,Class<AlternateType> alternatePluginType){\r\n    throw new IllegalStateException(\"Could not initialize plugin: \" + preferredPluginType + \" (alternate: \" + alternatePluginType + \")\", t);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.AxisBase.resetAxisMinimum",
	"Comment": "by calling this method, any custom minimum value that has been previously set is reseted,and the calculation isdone automatically.",
	"Method": "void resetAxisMinimum(){\r\n    mCustomAxisMin = false;\r\n}"
}, {
	"Path": "com.google.refine.importers.tree.XmlImportUtilities.detectRecordElement",
	"Comment": "seeks for recurring element in a parsed documentwhich are likely candidates for being data records",
	"Method": "List<String> detectRecordElement(TreeReader parser,String tag,String[] detectRecordElement,TreeReader parser,RecordElementCandidate detectRecordElement,TreeReader parser,String[] path){\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"detectRecordElement(TreeReader, String[])\");\r\n    }\r\n    List<RecordElementCandidate> descendantCandidates = new ArrayList<RecordElementCandidate>();\r\n    Map<String, Integer> immediateChildCandidateMap = new HashMap<String, Integer>();\r\n    try {\r\n        while (parser.hasNext()) {\r\n            Token eventType = parser.next();\r\n            if (eventType == Token.EndEntity) {\r\n                break;\r\n            } else if (eventType == Token.StartEntity) {\r\n                String tagName = parser.getFieldName();\r\n                immediateChildCandidateMap.put(tagName, immediateChildCandidateMap.containsKey(tagName) ? immediateChildCandidateMap.get(tagName) + 1 : 1);\r\n                String[] path2 = new String[path.length + 1];\r\n                System.arraycopy(path, 0, path2, 0, path.length);\r\n                path2[path.length] = tagName;\r\n                RecordElementCandidate c = detectRecordElement(parser, path2);\r\n                if (c != null) {\r\n                    descendantCandidates.add(c);\r\n                }\r\n            }\r\n        }\r\n    } catch (TreeReaderException e) {\r\n        e.printStackTrace();\r\n    }\r\n    if (immediateChildCandidateMap.size() > 0) {\r\n        List<RecordElementCandidate> immediateChildCandidates = new ArrayList<RecordElementCandidate>(immediateChildCandidateMap.size());\r\n        for (Entry<String, Integer> entry : immediateChildCandidateMap.entrySet()) {\r\n            int count = entry.getValue();\r\n            if (count > 1) {\r\n                String[] path2 = new String[path.length + 1];\r\n                System.arraycopy(path, 0, path2, 0, path.length);\r\n                path2[path.length] = entry.getKey();\r\n                RecordElementCandidate candidate = new RecordElementCandidate();\r\n                candidate.path = path2;\r\n                candidate.count = count;\r\n                immediateChildCandidates.add(candidate);\r\n            }\r\n        }\r\n        if (immediateChildCandidates.size() > 0 && immediateChildCandidates.size() < 5) {\r\n            sortRecordElementCandidates(immediateChildCandidates);\r\n            RecordElementCandidate ourCandidate = immediateChildCandidates.get(0);\r\n            if (logger.isTraceEnabled()) {\r\n                logger.trace(\"ourCandidate.count : \" + ourCandidate.count + \"; immediateChildCandidates.size() : \" + immediateChildCandidates.size());\r\n            }\r\n            if (ourCandidate.count / immediateChildCandidates.size() > 5) {\r\n                return ourCandidate;\r\n            }\r\n            descendantCandidates.add(ourCandidate);\r\n        }\r\n    }\r\n    if (descendantCandidates.size() > 0) {\r\n        sortRecordElementCandidates(descendantCandidates);\r\n        RecordElementCandidate candidate = descendantCandidates.get(0);\r\n        if (candidate.count / descendantCandidates.size() > 5) {\r\n            return candidate;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.FindFunctionTests.invoke",
	"Comment": "lookup a control function by name and invoke it with a variable number of args",
	"Method": "Object invoke(String name,Object args){\r\n    Function function = ControlFunctionRegistry.getFunction(name);\r\n    if (function == null) {\r\n        throw new IllegalArgumentException(\"Unknown function \" + name);\r\n    }\r\n    if (args == null) {\r\n        return function.call(bindings, new Object[0]);\r\n    } else {\r\n        return function.call(bindings, args);\r\n    }\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvi.layout.MviFrameLayout.getMviDelegate",
	"Comment": "get the mvp delegate. this is internally used for creating presenter, attaching and detachingview from presenter etc.please note that only one instance of mvp delegate should be used per android.view.viewinstance.only override this method if you really know what you are doing.",
	"Method": "ViewGroupMviDelegate<V, P> getMviDelegate(){\r\n    if (mvpDelegate == null) {\r\n        mvpDelegate = new ViewGroupMviDelegateImpl(this, this, true);\r\n    }\r\n    return mvpDelegate;\r\n}"
}, {
	"Path": "org.mockito.internal.invocation.finder.AllInvocationsFinder.findStubbings",
	"Comment": "gets all stubbings from mocks. invocations are ordered earlier first.",
	"Method": "Set<Stubbing> findStubbings(Iterable<?> mocks){\r\n    Set<Stubbing> stubbings = new TreeSet<Stubbing>(new StubbingComparator());\r\n    for (Object mock : mocks) {\r\n        Collection<? extends Stubbing> fromSingleMock = new DefaultMockingDetails(mock).getStubbings();\r\n        stubbings.addAll(fromSingleMock);\r\n    }\r\n    return stubbings;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.PieDataSet.setAutomaticallyDisableSliceSpacing",
	"Comment": "when enabled, slice spacing will be 0.0 when the smallest value is going to besmaller than the slice spacing itself.",
	"Method": "void setAutomaticallyDisableSliceSpacing(boolean autoDisable){\r\n    mAutomaticallyDisableSliceSpacing = autoDisable;\r\n}"
}, {
	"Path": "okhttp3.Cookie.persistent",
	"Comment": "returns true if this cookie does not expire at the end of the current session.",
	"Method": "boolean persistent(){\r\n    return persistent;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.Utils.convertDpToPixel",
	"Comment": "this method converts dp unit to equivalent pixels, depending on devicedensity. needs utils to be initialized before usage.",
	"Method": "float convertDpToPixel(float dp){\r\n    if (mMetrics == null) {\r\n        Log.e(\"MPChartLib-Utils\", \"Utils NOT INITIALIZED. You need to call Utils.init(...) at least once before\" + \" calling Utils.convertDpToPixel(...). Otherwise conversion does not \" + \"take place.\");\r\n        return dp;\r\n    }\r\n    return dp * mMetrics.density;\r\n}"
}, {
	"Path": "okhttp3.internal.http1.Http1Codec.writeRequest",
	"Comment": "returns bytes of a request header for sending on an http transport.",
	"Method": "void writeRequest(Headers headers,String requestLine){\r\n    if (state != STATE_IDLE)\r\n        throw new IllegalStateException(\"state: \" + state);\r\n    sink.writeUtf8(requestLine).writeUtf8(\"\\r\\n\");\r\n    for (int i = 0, size = headers.size(); i < size; i++) {\r\n        sink.writeUtf8(headers.name(i)).writeUtf8(\": \").writeUtf8(headers.value(i)).writeUtf8(\"\\r\\n\");\r\n    }\r\n    sink.writeUtf8(\"\\r\\n\");\r\n    state = STATE_OPEN_REQUEST_BODY;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.ObjectPool.getPoolCount",
	"Comment": "returns the number of objects remaining in the pool, for diagnostic purposes.",
	"Method": "int getPoolCount(){\r\n    return this.objectsPointer + 1;\r\n}"
}, {
	"Path": "okhttp3.RecordedResponse.networkResponse",
	"Comment": "asserts that the current response used the network and returns the network response.",
	"Method": "RecordedResponse networkResponse(){\r\n    Response networkResponse = response.networkResponse();\r\n    assertNotNull(networkResponse);\r\n    assertNull(networkResponse.body());\r\n    return new RecordedResponse(networkResponse.request(), networkResponse, null, null, null);\r\n}"
}, {
	"Path": "org.mockito.internal.util.reflection.FieldInitializationReport.fieldWasInitializedUsingContructorArgs",
	"Comment": "indicate whether the field was created using constructor args.",
	"Method": "boolean fieldWasInitializedUsingContructorArgs(){\r\n    return wasInitializedUsingConstructorArgs;\r\n}"
}, {
	"Path": "org.mockito.internal.util.reflection.GenericMetadataSupport.registerAllTypeVariables",
	"Comment": "registers the type variables for the given type and all of its superclasses and superinterfaces.",
	"Method": "void registerAllTypeVariables(Type classType){\r\n    Queue<Type> typesToRegister = new LinkedList<Type>();\r\n    Set<Type> registeredTypes = new HashSet<Type>();\r\n    typesToRegister.add(classType);\r\n    while (!typesToRegister.isEmpty()) {\r\n        Type typeToRegister = typesToRegister.poll();\r\n        if (typeToRegister == null || registeredTypes.contains(typeToRegister)) {\r\n            continue;\r\n        }\r\n        registerTypeVariablesOn(typeToRegister);\r\n        registeredTypes.add(typeToRegister);\r\n        Class<?> rawType = extractRawTypeOf(typeToRegister);\r\n        typesToRegister.add(rawType.getGenericSuperclass());\r\n        typesToRegister.addAll(Arrays.asList(rawType.getGenericInterfaces()));\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.YAxis.getSpaceBottom",
	"Comment": "returns the bottom axis space in percent of the full range. default 10f",
	"Method": "float getSpaceBottom(){\r\n    return mSpacePercentBottom;\r\n}"
}, {
	"Path": "okhttp3.internal.cache.DiskLruCache.processJournal",
	"Comment": "computes the initial size and collects garbage as a part of opening the cache. dirty entriesare assumed to be inconsistent and will be deleted.",
	"Method": "void processJournal(){\r\n    fileSystem.delete(journalFileTmp);\r\n    for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {\r\n        Entry entry = i.next();\r\n        if (entry.currentEditor == null) {\r\n            for (int t = 0; t < valueCount; t++) {\r\n                size += entry.lengths[t];\r\n            }\r\n        } else {\r\n            entry.currentEditor = null;\r\n            for (int t = 0; t < valueCount; t++) {\r\n                fileSystem.delete(entry.cleanFiles[t]);\r\n                fileSystem.delete(entry.dirtyFiles[t]);\r\n            }\r\n            i.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "okhttp3.URLConnectionTest.unexpectedExceptionSync",
	"Comment": "confirm that runtime exceptions thrown inside of okhttp propagate to the caller.",
	"Method": "void unexpectedExceptionSync(){\r\n    urlFactory.setClient(urlFactory.client().newBuilder().dns(new Dns() {\r\n        @Override\r\n        public List<InetAddress> lookup(String hostname) {\r\n            throw new RuntimeException(\"boom!\");\r\n        }\r\n    }).build());\r\n    server.enqueue(new MockResponse());\r\n    HttpURLConnection connection = urlFactory.open(server.url(\"/\").url());\r\n    try {\r\n        connection.getResponseCode();\r\n        fail();\r\n    } catch (RuntimeException expected) {\r\n        assertEquals(\"boom!\", expected.getMessage());\r\n    }\r\n}"
}, {
	"Path": "okhttp3.URLConnectionTest.unexpectedExceptionSync",
	"Comment": "confirm that runtime exceptions thrown inside of okhttp propagate to the caller.",
	"Method": "void unexpectedExceptionSync(){\r\n    throw new RuntimeException(\"boom!\");\r\n}"
}, {
	"Path": "com.google.refine.extension.gdata.FusionTableHandler.insertRows",
	"Comment": "insert a set of rows and optionally return the ids of the new rows.",
	"Method": "Long insertRows(Fusiontables service,String tableId,AbstractInputStreamContent mediaContent){\r\n    ImportRows importRows = service.table().importRows(tableId, mediaContent);\r\n    importRows.setIsStrict(false);\r\n    FusiontablesImport response = importRows.execute();\r\n    return response.getNumRowsReceived();\r\n}"
}, {
	"Path": "org.openrefine.wikidata.updates.ItemUpdate.merge",
	"Comment": "merges all the changes in other into this instance. both updates should havethe same subject.",
	"Method": "ItemUpdate merge(ItemUpdate other){\r\n    Validate.isTrue(qid.equals(other.getItemId()));\r\n    List<Statement> newAddedStatements = new ArrayList(addedStatements);\r\n    for (Statement statement : other.getAddedStatements()) {\r\n        if (!newAddedStatements.contains(statement)) {\r\n            newAddedStatements.add(statement);\r\n        }\r\n    }\r\n    Set<Statement> newDeletedStatements = new HashSet(deletedStatements);\r\n    newDeletedStatements.addAll(other.getDeletedStatements());\r\n    Set<MonolingualTextValue> newLabels = new HashSet(labels);\r\n    newLabels.addAll(other.getLabels());\r\n    Set<MonolingualTextValue> newDescriptions = new HashSet(descriptions);\r\n    newDescriptions.addAll(other.getDescriptions());\r\n    Set<MonolingualTextValue> newAliases = new HashSet(aliases);\r\n    newAliases.addAll(other.getAliases());\r\n    return new ItemUpdate(qid, newAddedStatements, newDeletedStatements, newLabels, newDescriptions, newAliases);\r\n}"
}, {
	"Path": "okhttp3.ConnectionCoalescingTest.skipsWhenHostnameVerifierUsed",
	"Comment": "skips coalescing when hostname verifier is overridden since the intention of the hostnameverification is a black box.",
	"Method": "void skipsWhenHostnameVerifierUsed(){\r\n    HostnameVerifier verifier = new HostnameVerifier() {\r\n        @Override\r\n        public boolean verify(String s, SSLSession sslSession) {\r\n            return true;\r\n        }\r\n    };\r\n    client = client.newBuilder().hostnameVerifier(verifier).build();\r\n    server.enqueue(new MockResponse().setResponseCode(200));\r\n    server.enqueue(new MockResponse().setResponseCode(200));\r\n    assert200Http2Response(execute(url), server.getHostName());\r\n    HttpUrl sanUrl = url.newBuilder().host(\"san.com\").build();\r\n    assert200Http2Response(execute(sanUrl), \"san.com\");\r\n    assertEquals(2, client.connectionPool().connectionCount());\r\n}"
}, {
	"Path": "okhttp3.ConnectionCoalescingTest.skipsWhenHostnameVerifierUsed",
	"Comment": "skips coalescing when hostname verifier is overridden since the intention of the hostnameverification is a black box.",
	"Method": "void skipsWhenHostnameVerifierUsed(){\r\n    return true;\r\n}"
}, {
	"Path": "com.navercorp.pinpoint.common.util.jsr166.ConcurrentReferenceHashMap.segmentFor",
	"Comment": "returns the segment that should be used for key with given hash",
	"Method": "Segment<K, V> segmentFor(int hash){\r\n    return segments[(hash >>> segmentShift) & segmentMask];\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.getTransformer",
	"Comment": "returns the transformer class that contains all matrices and isresponsible for transforming values into pixels on the screen andbackwards.",
	"Method": "Transformer getTransformer(AxisDependency which){\r\n    if (which == AxisDependency.LEFT)\r\n        return mLeftAxisTransformer;\r\n    else\r\n        return mRightAxisTransformer;\r\n}"
}, {
	"Path": "okhttp3.Headers.getDate",
	"Comment": "returns the last value corresponding to the specified field parsed as an http date, or null ifeither the field is absent or cannot be parsed as a date.",
	"Method": "Date getDate(String name){\r\n    String value = get(name);\r\n    return value != null ? HttpDate.parse(value) : null;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.renderer.XAxisRenderer.drawGridLine",
	"Comment": "draws the grid line at the specified position using the provided path.",
	"Method": "void drawGridLine(Canvas c,float x,float y,Path gridLinePath){\r\n    gridLinePath.moveTo(x, mViewPortHandler.contentBottom());\r\n    gridLinePath.lineTo(x, mViewPortHandler.contentTop());\r\n    c.drawPath(gridLinePath, mGridPaint);\r\n    gridLinePath.reset();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.PieDataSet.getValueLinePart2Length",
	"Comment": "when valueposition is outsideslice, indicates length of second half of the line",
	"Method": "float getValueLinePart2Length(){\r\n    return mValueLinePart2Length;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.listener.BarLineChartTouchListener.performZoom",
	"Comment": "performs the all operations necessary for pinch and axis zoom.",
	"Method": "void performZoom(MotionEvent event){\r\n    if (event.getPointerCount() >= 2) {\r\n        OnChartGestureListener l = mChart.getOnChartGestureListener();\r\n        float totalDist = spacing(event);\r\n        if (totalDist > mMinScalePointerDistance) {\r\n            MPPointF t = getTrans(mTouchPointCenter.x, mTouchPointCenter.y);\r\n            ViewPortHandler h = mChart.getViewPortHandler();\r\n            if (mTouchMode == PINCH_ZOOM) {\r\n                mLastGesture = ChartGesture.PINCH_ZOOM;\r\n                float scale = totalDist / mSavedDist;\r\n                boolean isZoomingOut = (scale < 1);\r\n                boolean canZoomMoreX = isZoomingOut ? h.canZoomOutMoreX() : h.canZoomInMoreX();\r\n                boolean canZoomMoreY = isZoomingOut ? h.canZoomOutMoreY() : h.canZoomInMoreY();\r\n                float scaleX = (mChart.isScaleXEnabled()) ? scale : 1f;\r\n                float scaleY = (mChart.isScaleYEnabled()) ? scale : 1f;\r\n                if (canZoomMoreY || canZoomMoreX) {\r\n                    mMatrix.set(mSavedMatrix);\r\n                    mMatrix.postScale(scaleX, scaleY, t.x, t.y);\r\n                    if (l != null)\r\n                        l.onChartScale(event, scaleX, scaleY);\r\n                }\r\n            } else if (mTouchMode == X_ZOOM && mChart.isScaleXEnabled()) {\r\n                mLastGesture = ChartGesture.X_ZOOM;\r\n                float xDist = getXDist(event);\r\n                float scaleX = xDist / mSavedXDist;\r\n                boolean isZoomingOut = (scaleX < 1);\r\n                boolean canZoomMoreX = isZoomingOut ? h.canZoomOutMoreX() : h.canZoomInMoreX();\r\n                if (canZoomMoreX) {\r\n                    mMatrix.set(mSavedMatrix);\r\n                    mMatrix.postScale(scaleX, 1f, t.x, t.y);\r\n                    if (l != null)\r\n                        l.onChartScale(event, scaleX, 1f);\r\n                }\r\n            } else if (mTouchMode == Y_ZOOM && mChart.isScaleYEnabled()) {\r\n                mLastGesture = ChartGesture.Y_ZOOM;\r\n                float yDist = getYDist(event);\r\n                float scaleY = yDist / mSavedYDist;\r\n                boolean isZoomingOut = (scaleY < 1);\r\n                boolean canZoomMoreY = isZoomingOut ? h.canZoomOutMoreY() : h.canZoomInMoreY();\r\n                if (canZoomMoreY) {\r\n                    mMatrix.set(mSavedMatrix);\r\n                    mMatrix.postScale(1f, scaleY, t.x, t.y);\r\n                    if (l != null)\r\n                        l.onChartScale(event, 1f, scaleY);\r\n                }\r\n            }\r\n            MPPointF.recycleInstance(t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "okhttp3.internal.cache2.RelayTest.sourceReader",
	"Comment": "returns a callable that reads all of source, closes it, and returns the bytes.",
	"Method": "Callable<ByteString> sourceReader(Source source){\r\n    return new Callable<ByteString>() {\r\n        @Override\r\n        public ByteString call() throws Exception {\r\n            Buffer buffer = new Buffer();\r\n            while (source.read(buffer, 16384) != -1) {\r\n            }\r\n            source.close();\r\n            return buffer.readByteString();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "okhttp3.internal.cache2.RelayTest.sourceReader",
	"Comment": "returns a callable that reads all of source, closes it, and returns the bytes.",
	"Method": "Callable<ByteString> sourceReader(Source source){\r\n    Buffer buffer = new Buffer();\r\n    while (source.read(buffer, 16384) != -1) {\r\n    }\r\n    source.close();\r\n    return buffer.readByteString();\r\n}"
}, {
	"Path": "org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces.toAnswer",
	"Comment": "construct an answer from a three parameter answer interface",
	"Method": "Answer<T> toAnswer(Answer1<T, A> answer,Answer<Void> toAnswer,VoidAnswer1<A> answer,Answer<T> toAnswer,Answer2<T, A, B> answer,Answer<Void> toAnswer,VoidAnswer2<A, B> answer,Answer<T> toAnswer,Answer3<T, A, B, C> answer,Answer<Void> toAnswer,VoidAnswer3<A, B, C> answer,Answer<T> toAnswer,Answer4<T, A, B, C, D> answer,Answer<Void> toAnswer,VoidAnswer4<A, B, C, D> answer,Answer<T> toAnswer,Answer5<T, A, B, C, D, E> answer,Answer<Void> toAnswer,VoidAnswer5<A, B, C, D, E> answer){\r\n    return new Answer<Void>() {\r\n        @SuppressWarnings(\"unchecked\")\r\n        public Void answer(InvocationOnMock invocation) throws Throwable {\r\n            answer.answer((A) invocation.getArgument(0), (B) invocation.getArgument(1), (C) invocation.getArgument(2), (D) invocation.getArgument(3), (E) invocation.getArgument(4));\r\n            return null;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces.toAnswer",
	"Comment": "construct an answer from a three parameter answer interface",
	"Method": "Answer<T> toAnswer(Answer1<T, A> answer,Answer<Void> toAnswer,VoidAnswer1<A> answer,Answer<T> toAnswer,Answer2<T, A, B> answer,Answer<Void> toAnswer,VoidAnswer2<A, B> answer,Answer<T> toAnswer,Answer3<T, A, B, C> answer,Answer<Void> toAnswer,VoidAnswer3<A, B, C> answer,Answer<T> toAnswer,Answer4<T, A, B, C, D> answer,Answer<Void> toAnswer,VoidAnswer4<A, B, C, D> answer,Answer<T> toAnswer,Answer5<T, A, B, C, D, E> answer,Answer<Void> toAnswer,VoidAnswer5<A, B, C, D, E> answer){\r\n    answer.answer((A) invocation.getArgument(0), (B) invocation.getArgument(1), (C) invocation.getArgument(2), (D) invocation.getArgument(3), (E) invocation.getArgument(4));\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.ibatis.io.VFS.getClass",
	"Comment": "get a class by name. if the class is not found then return null.",
	"Method": "Class<?> getClass(String className){\r\n    try {\r\n        return Thread.currentThread().getContextClassLoader().loadClass(className);\r\n    } catch (ClassNotFoundException e) {\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Class not found: \" + className);\r\n        }\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "okhttp3.mockwebserver.RecordedRequest.getBody",
	"Comment": "returns the body of this post request. this may be truncated.",
	"Method": "Buffer getBody(){\r\n    return body;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.renderer.BarLineScatterCandleBubbleRenderer.shouldDrawValues",
	"Comment": "returns true if the dataset values should be drawn, false if not.",
	"Method": "boolean shouldDrawValues(IDataSet set){\r\n    return set.isVisible() && (set.isDrawValuesEnabled() || set.isDrawIconsEnabled());\r\n}"
}, {
	"Path": "com.google.refine.expr.MetaParser.registerLanguageParser",
	"Comment": "languageprefix will be stored in the meta model as an identifier. so be careful when change it as it will break the backward compatibility for the old project",
	"Method": "void registerLanguageParser(String languagePrefix,String name,LanguageSpecificParser parser,String defaultExpression){\r\n    s_languages.put(languagePrefix, new LanguageInfo(name, parser, defaultExpression));\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonWriter.setSerializeNulls",
	"Comment": "sets whether object members are serialized when their value is null.this has no impact on array elements. the default is false.",
	"Method": "void setSerializeNulls(boolean serializeNulls){\r\n    this.serializeNulls = serializeNulls;\r\n}"
}, {
	"Path": "okhttp3.internal.Util.inet6AddressToAscii",
	"Comment": "encodes an ipv6 address in canonical form according to rfc 5952.",
	"Method": "String inet6AddressToAscii(byte[] address){\r\n    int longestRunOffset = -1;\r\n    int longestRunLength = 0;\r\n    for (int i = 0; i < address.length; i += 2) {\r\n        int currentRunOffset = i;\r\n        while (i < 16 && address[i] == 0 && address[i + 1] == 0) {\r\n            i += 2;\r\n        }\r\n        int currentRunLength = i - currentRunOffset;\r\n        if (currentRunLength > longestRunLength && currentRunLength >= 4) {\r\n            longestRunOffset = currentRunOffset;\r\n            longestRunLength = currentRunLength;\r\n        }\r\n    }\r\n    Buffer result = new Buffer();\r\n    for (int i = 0; i < address.length; ) {\r\n        if (i == longestRunOffset) {\r\n            result.writeByte(':');\r\n            i += longestRunLength;\r\n            if (i == 16)\r\n                result.writeByte(':');\r\n        } else {\r\n            if (i > 0)\r\n                result.writeByte(':');\r\n            int group = (address[i] & 0xff) << 8 | address[i + 1] & 0xff;\r\n            result.writeHexadecimalUnsignedLong(group);\r\n            i += 2;\r\n        }\r\n    }\r\n    return result.readUtf8();\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvi.MviDialogFragment.getMvpDelegate",
	"Comment": "get the mvp delegate. this is internally used for creating presenter, attaching and detachingviewstate from presenter.please note that only one instance of mvp delegate should be used per fragmentinstance.only override this method if you really know what you are doing.",
	"Method": "FragmentMviDelegate<V, P> getMvpDelegate(){\r\n    if (mvpDelegate == null) {\r\n        mvpDelegate = new FragmentMviDelegateImpl<V, P>(this, this);\r\n    }\r\n    return mvpDelegate;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.getLegend",
	"Comment": "returns the legend object of the chart. this method can be used to get aninstance of the legend in order to customize the automatically generatedlegend.",
	"Method": "Legend getLegend(){\r\n    return mLegend;\r\n}"
}, {
	"Path": "com.squareup.moshi.adapters.PolymorphicJsonAdapterFactoryTest.unportableTypes",
	"Comment": "longs that do not have an exact double representation are problematic for json. it is a badidea to use json for these values! but moshi tries to retain long precision where possible.",
	"Method": "void unportableTypes(){\r\n    Moshi moshi = new Moshi.Builder().add(PolymorphicJsonAdapterFactory.of(Message.class, \"type\").withSubtype(MessageWithUnportableTypes.class, \"unportable\")).build();\r\n    JsonAdapter<Message> adapter = moshi.adapter(Message.class);\r\n    assertThat(adapter.toJson(new MessageWithUnportableTypes(9007199254740993L))).isEqualTo(\"{\\\"type\\\":\\\"unportable\\\",\\\"long_value\\\":9007199254740993}\");\r\n    MessageWithUnportableTypes decoded = (MessageWithUnportableTypes) adapter.fromJson(\"{\\\"type\\\":\\\"unportable\\\",\\\"long_value\\\":9007199254740993}\");\r\n    assertThat(decoded.long_value).isEqualTo(9007199254740993L);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.listener.BarLineChartTouchListener.inverted",
	"Comment": "returns true if the current touch situation should be interpreted as inverted, false if not.",
	"Method": "boolean inverted(){\r\n    return (mClosestDataSetToTouch == null && mChart.isAnyAxisInverted()) || (mClosestDataSetToTouch != null && mChart.isInverted(mClosestDataSetToTouch.getAxisDependency()));\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.Utils.getSizeOfRotatedRectangleByRadians",
	"Comment": "returns a recyclable fsize instance.represents size of a rotated rectangle by radians.",
	"Method": "FSize getSizeOfRotatedRectangleByRadians(FSize rectangleSize,float radians,FSize getSizeOfRotatedRectangleByRadians,float rectangleWidth,float rectangleHeight,float radians){\r\n    return FSize.getInstance(Math.abs(rectangleWidth * (float) Math.cos(radians)) + Math.abs(rectangleHeight * (float) Math.sin(radians)), Math.abs(rectangleWidth * (float) Math.sin(radians)) + Math.abs(rectangleHeight * (float) Math.cos(radians)));\r\n}"
}, {
	"Path": "org.mockito.internal.util.reflection.SuperTypesLastSorterTest.assertSortConsistently",
	"Comment": "assert that these fields sort in the same order no matter which orderthey start in.",
	"Method": "void assertSortConsistently(Field a,Field b,Field c){\r\n    Field[][] initialOrderings = { { a, b, c }, { a, c, b }, { b, a, c }, { b, c, a }, { c, a, b }, { c, b, a } };\r\n    Set<List<Field>> results = new HashSet<List<Field>>();\r\n    for (Field[] o : initialOrderings) {\r\n        results.add(sortSuperTypesLast(Arrays.asList(o)));\r\n    }\r\n    assertThat(results).hasSize(1);\r\n}"
}, {
	"Path": "com.google.refine.expr.functions.strings.Range.createRange",
	"Comment": "creates a range from the given range values with the given step.the generated range is either an increasing sequence or a decreasing sequence, and each number in the sequence differs from the next number by the step value.",
	"Method": "Object createRange(int start,int stop,int step){\r\n    if ((start > stop && step > 0) || (start < stop && step < 0) || step == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    int rangeSize = (int) (Math.ceil(((double) Math.abs(start - stop)) / Math.abs(step)));\r\n    Integer[] generatedRange = new Integer[rangeSize];\r\n    for (int i = 0; i < rangeSize; i++) {\r\n        generatedRange[i] = start + step * i;\r\n    }\r\n    return generatedRange;\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonWriter.getPath",
	"Comment": "returns a jsonpath tothe current location in the json value.",
	"Method": "String getPath(){\r\n    return JsonScope.getPath(stackSize, scopes, pathNames, pathIndices);\r\n}"
}, {
	"Path": "org.apache.ibatis.io.DefaultVFS.findJarForResource",
	"Comment": "attempts to deconstruct the given url to find a jar file containing the resource referencedby the url. that is, assuming the url references a jar entry, this method will return a urlthat references the jar file containing the entry. if the jar cannot be located, then thismethod returns null.",
	"Method": "URL findJarForResource(URL url){\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Find JAR URL: \" + url);\r\n    }\r\n    try {\r\n        for (; ; ) {\r\n            url = new URL(url.getFile());\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"Inner URL: \" + url);\r\n            }\r\n        }\r\n    } catch (MalformedURLException e) {\r\n    }\r\n    StringBuilder jarUrl = new StringBuilder(url.toExternalForm());\r\n    int index = jarUrl.lastIndexOf(\".jar\");\r\n    if (index >= 0) {\r\n        jarUrl.setLength(index + 4);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Extracted JAR URL: \" + jarUrl);\r\n        }\r\n    } else {\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Not a JAR: \" + jarUrl);\r\n        }\r\n        return null;\r\n    }\r\n    try {\r\n        URL testUrl = new URL(jarUrl.toString());\r\n        if (isJar(testUrl)) {\r\n            return testUrl;\r\n        } else {\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"Not a JAR: \" + jarUrl);\r\n            }\r\n            jarUrl.replace(0, jarUrl.length(), testUrl.getFile());\r\n            File file = new File(jarUrl.toString());\r\n            if (!file.exists()) {\r\n                try {\r\n                    file = new File(URLEncoder.encode(jarUrl.toString(), \"UTF-8\"));\r\n                } catch (UnsupportedEncodingException e) {\r\n                    throw new RuntimeException(\"Unsupported encoding?  UTF-8?  That's unpossible.\");\r\n                }\r\n            }\r\n            if (file.exists()) {\r\n                if (log.isDebugEnabled()) {\r\n                    log.debug(\"Trying real file: \" + file.getAbsolutePath());\r\n                }\r\n                testUrl = file.toURI().toURL();\r\n                if (isJar(testUrl)) {\r\n                    return testUrl;\r\n                }\r\n            }\r\n        }\r\n    } catch (MalformedURLException e) {\r\n        log.warn(\"Invalid JAR URL: \" + jarUrl);\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Not a JAR: \" + jarUrl);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.layout.MvpLinearLayout.getMvpDelegate",
	"Comment": "get the mvp delegate. this is internally used for creating presenter, attaching and detachingview from presenter etc.please note that only one instance of mvp delegate should be used per android.view.viewinstance.only override this method if you really know what you are doing.",
	"Method": "ViewGroupMvpDelegate<V, P> getMvpDelegate(){\r\n    if (mvpDelegate == null) {\r\n        mvpDelegate = new ViewGroupMvpDelegateImpl(this, this, true);\r\n    }\r\n    return mvpDelegate;\r\n}"
}, {
	"Path": "okhttp3.internal.connection.StreamAllocation.findConnection",
	"Comment": "returns a connection to host a new stream. this prefers the existing connection if it exists,then the pool, finally building a new connection.",
	"Method": "RealConnection findConnection(int connectTimeout,int readTimeout,int writeTimeout,int pingIntervalMillis,boolean connectionRetryEnabled){\r\n    boolean foundPooledConnection = false;\r\n    RealConnection result = null;\r\n    Route selectedRoute = null;\r\n    Connection releasedConnection;\r\n    Socket toClose;\r\n    synchronized (connectionPool) {\r\n        if (released)\r\n            throw new IllegalStateException(\"released\");\r\n        if (codec != null)\r\n            throw new IllegalStateException(\"codec != null\");\r\n        if (canceled)\r\n            throw new IOException(\"Canceled\");\r\n        releasedConnection = this.connection;\r\n        toClose = releaseIfNoNewStreams();\r\n        if (this.connection != null) {\r\n            result = this.connection;\r\n            releasedConnection = null;\r\n        }\r\n        if (!reportedAcquired) {\r\n            releasedConnection = null;\r\n        }\r\n        if (result == null) {\r\n            Internal.instance.get(connectionPool, address, this, null);\r\n            if (connection != null) {\r\n                foundPooledConnection = true;\r\n                result = connection;\r\n            } else {\r\n                selectedRoute = route;\r\n            }\r\n        }\r\n    }\r\n    closeQuietly(toClose);\r\n    if (releasedConnection != null) {\r\n        eventListener.connectionReleased(call, releasedConnection);\r\n    }\r\n    if (foundPooledConnection) {\r\n        eventListener.connectionAcquired(call, result);\r\n    }\r\n    if (result != null) {\r\n        return result;\r\n    }\r\n    boolean newRouteSelection = false;\r\n    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {\r\n        newRouteSelection = true;\r\n        routeSelection = routeSelector.next();\r\n    }\r\n    synchronized (connectionPool) {\r\n        if (canceled)\r\n            throw new IOException(\"Canceled\");\r\n        if (newRouteSelection) {\r\n            List<Route> routes = routeSelection.getAll();\r\n            for (int i = 0, size = routes.size(); i < size; i++) {\r\n                Route route = routes.get(i);\r\n                Internal.instance.get(connectionPool, address, this, route);\r\n                if (connection != null) {\r\n                    foundPooledConnection = true;\r\n                    result = connection;\r\n                    this.route = route;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (!foundPooledConnection) {\r\n            if (selectedRoute == null) {\r\n                selectedRoute = routeSelection.next();\r\n            }\r\n            route = selectedRoute;\r\n            refusedStreamCount = 0;\r\n            result = new RealConnection(connectionPool, selectedRoute);\r\n            acquire(result, false);\r\n        }\r\n    }\r\n    if (foundPooledConnection) {\r\n        eventListener.connectionAcquired(call, result);\r\n        return result;\r\n    }\r\n    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener);\r\n    routeDatabase().connected(result.route());\r\n    Socket socket = null;\r\n    synchronized (connectionPool) {\r\n        reportedAcquired = true;\r\n        Internal.instance.put(connectionPool, result);\r\n        if (result.isMultiplexed()) {\r\n            socket = Internal.instance.deduplicate(connectionPool, address, this);\r\n            result = connection;\r\n        }\r\n    }\r\n    closeQuietly(socket);\r\n    eventListener.connectionAcquired(call, result);\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.ibatis.io.JBoss6VFS.checkReturnType",
	"Comment": "verifies that the return type of a method is what it is expected to be. if it is not, thenthis vfs is marked as invalid for the current environment.",
	"Method": "void checkReturnType(Method method,Class<?> expected){\r\n    if (method != null && !expected.isAssignableFrom(method.getReturnType())) {\r\n        log.error(\"Method \" + method.getClass().getName() + \".\" + method.getName() + \"(..) should return \" + expected.getName() + \" but returns \" + method.getReturnType().getName() + \" instead.\");\r\n        setInvalid();\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.clustering.binning.Metaphone3.Encode_X_To_H",
	"Comment": "encode special case where americans know the\tproper mexican indian pronounciation of this name",
	"Method": "boolean Encode_X_To_H(){\r\n    if (StringAt((m_current - 2), 6, \"OAXACA\", \"\") || StringAt((m_current - 3), 7, \"QUIXOTE\", \"\")) {\r\n        MetaphAdd(\"H\");\r\n        m_current++;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.Legend.getXEntrySpace",
	"Comment": "returns the space between the legend entries on a horizontal axis inpixels",
	"Method": "float getXEntrySpace(){\r\n    return mXEntrySpace;\r\n}"
}, {
	"Path": "okhttp3.internal.cache.DiskLruCache.journalRebuildRequired",
	"Comment": "we only rebuild the journal when it will halve the size of the journal and eliminate at least2000 ops.",
	"Method": "boolean journalRebuildRequired(){\r\n    final int redundantOpCompactThreshold = 2000;\r\n    return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries.size();\r\n}"
}, {
	"Path": "okhttp3.CipherSuiteTest.instancesAreInterned_survivesGarbageCollection",
	"Comment": "tests that interned ciphersuite instances remain the case across garbage collections, even ifthe string used to construct them is no longer strongly referenced outside of the ciphersuite.",
	"Method": "void instancesAreInterned_survivesGarbageCollection(){\r\n    CipherSuite cs = forJavaName(new String(\"FakeCipherSuite_instancesAreInterned\"));\r\n    System.gc();\r\n    assertSame(cs, forJavaName(new String(cs.javaName())));\r\n}"
}, {
	"Path": "okhttp3.internal.connection.RouteSelector.resetNextInetSocketAddress",
	"Comment": "prepares the socket addresses to attempt for the current proxy or host.",
	"Method": "void resetNextInetSocketAddress(Proxy proxy){\r\n    inetSocketAddresses = new ArrayList();\r\n    String socketHost;\r\n    int socketPort;\r\n    if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) {\r\n        socketHost = address.url().host();\r\n        socketPort = address.url().port();\r\n    } else {\r\n        SocketAddress proxyAddress = proxy.address();\r\n        if (!(proxyAddress instanceof InetSocketAddress)) {\r\n            throw new IllegalArgumentException(\"Proxy.address() is not an \" + \"InetSocketAddress: \" + proxyAddress.getClass());\r\n        }\r\n        InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;\r\n        socketHost = getHostString(proxySocketAddress);\r\n        socketPort = proxySocketAddress.getPort();\r\n    }\r\n    if (socketPort < 1 || socketPort > 65535) {\r\n        throw new SocketException(\"No route to \" + socketHost + \":\" + socketPort + \"; port is out of range\");\r\n    }\r\n    if (proxy.type() == Proxy.Type.SOCKS) {\r\n        inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));\r\n    } else {\r\n        eventListener.dnsStart(call, socketHost);\r\n        List<InetAddress> addresses = address.dns().lookup(socketHost);\r\n        if (addresses.isEmpty()) {\r\n            throw new UnknownHostException(address.dns() + \" returned no addresses for \" + socketHost);\r\n        }\r\n        eventListener.dnsEnd(call, socketHost, addresses);\r\n        for (int i = 0, size = addresses.size(); i < size; i++) {\r\n            InetAddress inetAddress = addresses.get(i);\r\n            inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mockito.internal.util.Primitives.defaultValue",
	"Comment": "returns the boxed default value for a primitive or a primitive wrapper.",
	"Method": "T defaultValue(Class<T> primitiveOrWrapperType){\r\n    return (T) PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.get(primitiveOrWrapperType);\r\n}"
}, {
	"Path": "okhttp3.internal.http2.Http2ConnectionTest.awaitWatchdogIdle",
	"Comment": "returns true when all work currently in progress by the watchdog have completed. this methodcreates more work for the watchdog and waits for that work to be executed. when it is, we knowwork that preceded this call is complete.",
	"Method": "void awaitWatchdogIdle(){\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    AsyncTimeout watchdogJob = new AsyncTimeout() {\r\n        @Override\r\n        protected void timedOut() {\r\n            latch.countDown();\r\n        }\r\n    };\r\n    watchdogJob.deadlineNanoTime(System.nanoTime());\r\n    watchdogJob.enter();\r\n    latch.await();\r\n}"
}, {
	"Path": "okhttp3.internal.http2.Http2ConnectionTest.awaitWatchdogIdle",
	"Comment": "returns true when all work currently in progress by the watchdog have completed. this methodcreates more work for the watchdog and waits for that work to be executed. when it is, we knowwork that preceded this call is complete.",
	"Method": "void awaitWatchdogIdle(){\r\n    latch.countDown();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.PieDataSet.getValueLinePart1Length",
	"Comment": "when valueposition is outsideslice, indicates length of first half of the line",
	"Method": "float getValueLinePart1Length(){\r\n    return mValueLinePart1Length;\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.viewstate.lce.data.CastedArrayListLceViewState.getClassLoader",
	"Comment": "the class loader used for deserializing the list of parcelable items",
	"Method": "ClassLoader getClassLoader(){\r\n    return getClass().getClassLoader();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.formatter.LargeValueFormatter.setAppendix",
	"Comment": "set an appendix text to be added at the end of the formatted value.",
	"Method": "void setAppendix(String appendix){\r\n    this.mText = appendix;\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonWriter.getSerializeNulls",
	"Comment": "returns true if object members are serialized when their value is null.this has no impact on array elements. the default is false.",
	"Method": "boolean getSerializeNulls(){\r\n    return serializeNulls;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.setClipValuesToContent",
	"Comment": "when enabled, the values will be clipped to contentrect,otherwise they can bleed outside the content rect.",
	"Method": "void setClipValuesToContent(boolean enabled){\r\n    mClipValuesToContent = enabled;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.ChartData.removeEntry",
	"Comment": "removes the entry object closest to the given dataset at thespecified index. returns true if an entry was removed, false if no entrywas found that meets the specified requirements.",
	"Method": "boolean removeEntry(Entry e,int dataSetIndex,boolean removeEntry,float xValue,int dataSetIndex){\r\n    if (dataSetIndex >= mDataSets.size())\r\n        return false;\r\n    IDataSet dataSet = mDataSets.get(dataSetIndex);\r\n    Entry e = dataSet.getEntryForXValue(xValue, Float.NaN);\r\n    if (e == null)\r\n        return false;\r\n    return removeEntry(e, dataSetIndex);\r\n}"
}, {
	"Path": "org.mockito.internal.configuration.injection.MockInjectionStrategy.thenTry",
	"Comment": "enqueue next injection strategy.the implementation should take care of the actual calling if required.",
	"Method": "MockInjectionStrategy thenTry(MockInjectionStrategy strategy){\r\n    if (nextStrategy != null) {\r\n        nextStrategy.thenTry(strategy);\r\n    } else {\r\n        nextStrategy = strategy;\r\n    }\r\n    return strategy;\r\n}"
}, {
	"Path": "com.google.refine.tests.RefineTest.cleanupProjectsAndJobs",
	"Comment": "cleans up the projects and jobs created with createcsvproject",
	"Method": "void cleanupProjectsAndJobs(){\r\n    for (ImportingJob job : importingJobs) {\r\n        ImportingManager.disposeJob(job.id);\r\n    }\r\n    for (Project project : projects) {\r\n        ProjectManager.singleton.deleteProject(project.id);\r\n    }\r\n    servlet = null;\r\n}"
}, {
	"Path": "okhttp3.internal.connection.RealConnection.connectTunnel",
	"Comment": "does all the work to build an https connection over a proxy tunnel. the catch here is that aproxy server can issue an auth challenge and then close the connection.",
	"Method": "void connectTunnel(int connectTimeout,int readTimeout,int writeTimeout,Call call,EventListener eventListener){\r\n    Request tunnelRequest = createTunnelRequest();\r\n    HttpUrl url = tunnelRequest.url();\r\n    for (int i = 0; i < MAX_TUNNEL_ATTEMPTS; i++) {\r\n        connectSocket(connectTimeout, readTimeout, call, eventListener);\r\n        tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);\r\n        if (tunnelRequest == null)\r\n            break;\r\n        closeQuietly(rawSocket);\r\n        rawSocket = null;\r\n        sink = null;\r\n        source = null;\r\n        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null);\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.clustering.binning.Metaphone3.GetMaximumKeyLength",
	"Comment": "retrieves maximum number of characters allowed for encoded key.",
	"Method": "int GetMaximumKeyLength(){\r\n    return (int) MAX_KEY_ALLOCATION;\r\n}"
}, {
	"Path": "org.openrefine.wikidata.qa.WikidataConstraintFetcher.getConstraintsByType",
	"Comment": "gets the list of constraints of a particular type for a property",
	"Method": "Stream<Statement> getConstraintsByType(PropertyIdValue pid,String qid){\r\n    Stream<Statement> allConstraints = getConstraintStatements(pid).stream().filter(s -> s.getValue() != null && ((EntityIdValue) s.getValue()).getId().equals(qid)).filter(s -> !StatementRank.DEPRECATED.equals(s.getRank()));\r\n    return allConstraints;\r\n}"
}, {
	"Path": "okhttp3.CallTest.httpProxyAuthenticate",
	"Comment": "confirm that the proxy authenticator works for unencrypted http proxies.",
	"Method": "void httpProxyAuthenticate(){\r\n    server.enqueue(new MockResponse().setResponseCode(407).addHeader(\"Proxy-Authenticate: Basic realm=\\\"localhost\\\"\"));\r\n    server.enqueue(new MockResponse().setBody(\"response body\"));\r\n    client = client.newBuilder().proxy(server.toProxyAddress()).proxyAuthenticator(new RecordingOkAuthenticator(\"password\", \"Basic\")).build();\r\n    Request request = new Request.Builder().url(\"http://android.com/foo\").build();\r\n    Response response = client.newCall(request).execute();\r\n    assertEquals(\"response body\", response.body().string());\r\n    RecordedRequest get1 = server.takeRequest();\r\n    assertEquals(\"GET http://android.com/foo HTTP/1.1\", get1.getRequestLine());\r\n    assertNull(get1.getHeader(\"Proxy-Authorization\"));\r\n    RecordedRequest get2 = server.takeRequest();\r\n    assertEquals(\"GET http://android.com/foo HTTP/1.1\", get2.getRequestLine());\r\n    assertEquals(\"password\", get2.getHeader(\"Proxy-Authorization\"));\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.isKeepPositionOnRotation",
	"Comment": "returns true if keeping the position on rotation is enabled and false if not.",
	"Method": "boolean isKeepPositionOnRotation(){\r\n    return mKeepPositionOnRotation;\r\n}"
}, {
	"Path": "com.google.refine.model.Row.dup",
	"Comment": "copy a row and return the copy. note that this is a shallow copy, soif the contents of cells are changed in the original, they will bebe changed in the duplicate.",
	"Method": "Row dup(){\r\n    Row row = new Row(cells.size());\r\n    row.flagged = flagged;\r\n    row.starred = starred;\r\n    row.cells.addAll(cells);\r\n    return row;\r\n}"
}, {
	"Path": "okhttp3.CertificateChainCleanerTest.chainOfLength",
	"Comment": "returns a chain starting at the leaf certificate and progressing to the root.",
	"Method": "List<HeldCertificate> chainOfLength(int length){\r\n    List<HeldCertificate> result = new ArrayList();\r\n    for (int i = 1; i <= length; i++) {\r\n        result.add(0, new HeldCertificate.Builder().signedBy(!result.isEmpty() ? result.get(0) : null).serialNumber(i).build());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.formatter.ValueFormatter.getFormattedValue",
	"Comment": "called when drawing any label, used to change numbers into formatted strings.",
	"Method": "String getFormattedValue(float value,AxisBase axis,String getFormattedValue,float value,Entry entry,int dataSetIndex,ViewPortHandler viewPortHandler,String getFormattedValue,float value){\r\n    return String.valueOf(value);\r\n}"
}, {
	"Path": "okhttp3.internal.cache.DiskLruCache.rebuildJournal",
	"Comment": "creates a new journal that omits redundant information. this replaces the current journal if itexists.",
	"Method": "void rebuildJournal(){\r\n    if (journalWriter != null) {\r\n        journalWriter.close();\r\n    }\r\n    BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp));\r\n    try {\r\n        writer.writeUtf8(MAGIC).writeByte('\\n');\r\n        writer.writeUtf8(VERSION_1).writeByte('\\n');\r\n        writer.writeDecimalLong(appVersion).writeByte('\\n');\r\n        writer.writeDecimalLong(valueCount).writeByte('\\n');\r\n        writer.writeByte('\\n');\r\n        for (Entry entry : lruEntries.values()) {\r\n            if (entry.currentEditor != null) {\r\n                writer.writeUtf8(DIRTY).writeByte(' ');\r\n                writer.writeUtf8(entry.key);\r\n                writer.writeByte('\\n');\r\n            } else {\r\n                writer.writeUtf8(CLEAN).writeByte(' ');\r\n                writer.writeUtf8(entry.key);\r\n                entry.writeLengths(writer);\r\n                writer.writeByte('\\n');\r\n            }\r\n        }\r\n    } finally {\r\n        writer.close();\r\n    }\r\n    if (fileSystem.exists(journalFile)) {\r\n        fileSystem.rename(journalFile, journalFileBackup);\r\n    }\r\n    fileSystem.rename(journalFileTmp, journalFile);\r\n    fileSystem.delete(journalFileBackup);\r\n    journalWriter = newJournalWriter();\r\n    hasJournalErrors = false;\r\n    mostRecentRebuildFailed = false;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.ChartData.removeDataSet",
	"Comment": "removes the dataset at the given index in the dataset array from the dataobject. also recalculates all minimum and maximum values. returns true ifa dataset was removed, false if no dataset could be removed.",
	"Method": "boolean removeDataSet(T d,boolean removeDataSet,int index){\r\n    if (index >= mDataSets.size() || index < 0)\r\n        return false;\r\n    T set = mDataSets.get(index);\r\n    return removeDataSet(set);\r\n}"
}, {
	"Path": "org.apache.ibatis.io.JBoss6VFS.initialize",
	"Comment": "find all the classes and methods that are required to access the jboss 6 vfs.",
	"Method": "void initialize(){\r\n    if (valid == null) {\r\n        valid = Boolean.TRUE;\r\n        VFS.VFS = checkNotNull(getClass(\"org.jboss.vfs.VFS\"));\r\n        VirtualFile.VirtualFile = checkNotNull(getClass(\"org.jboss.vfs.VirtualFile\"));\r\n        VFS.getChild = checkNotNull(getMethod(VFS.VFS, \"getChild\", URL.class));\r\n        VirtualFile.getChildrenRecursively = checkNotNull(getMethod(VirtualFile.VirtualFile, \"getChildrenRecursively\"));\r\n        VirtualFile.getPathNameRelativeTo = checkNotNull(getMethod(VirtualFile.VirtualFile, \"getPathNameRelativeTo\", VirtualFile.VirtualFile));\r\n        checkReturnType(VFS.getChild, VirtualFile.VirtualFile);\r\n        checkReturnType(VirtualFile.getChildrenRecursively, List.class);\r\n        checkReturnType(VirtualFile.getPathNameRelativeTo, String.class);\r\n    }\r\n}"
}, {
	"Path": "org.mockito.internal.invocation.finder.AllInvocationsFinder.find",
	"Comment": "gets all invocations from mocks. invocations are ordered earlier first.",
	"Method": "List<Invocation> find(Iterable<?> mocks){\r\n    Set<Invocation> invocationsInOrder = new TreeSet<Invocation>(new InvocationComparator());\r\n    for (Object mock : mocks) {\r\n        Collection<Invocation> fromSingleMock = new DefaultMockingDetails(mock).getInvocations();\r\n        invocationsInOrder.addAll(fromSingleMock);\r\n    }\r\n    return new LinkedList<Invocation>(invocationsInOrder);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.PieChart.isDrawSlicesUnderHoleEnabled",
	"Comment": "returns true if the inner tips of the slices are visible behind the hole,false if not.",
	"Method": "boolean isDrawSlicesUnderHoleEnabled(){\r\n    return mDrawSlicesUnderHole;\r\n}"
}, {
	"Path": "okhttp3.ConnectionCoalescingTest.skipsWhenDnsDontMatch",
	"Comment": "if the existing connection matches a san but not a match for dns then skip.",
	"Method": "void skipsWhenDnsDontMatch(){\r\n    server.enqueue(new MockResponse().setResponseCode(200));\r\n    assert200Http2Response(execute(url), server.getHostName());\r\n    HttpUrl differentDnsUrl = url.newBuilder().host(\"differentdns.com\").build();\r\n    try {\r\n        execute(differentDnsUrl);\r\n        fail(\"expected a failed attempt to connect\");\r\n    } catch (IOException expected) {\r\n    }\r\n}"
}, {
	"Path": "okhttp3.internal.tls.CertificatePinnerChainValidationTest.pinRootNotPresentInChain",
	"Comment": "the pinner should pull the root certificate from the trust manager.",
	"Method": "void pinRootNotPresentInChain(){\r\n    HeldCertificate rootCa = new HeldCertificate.Builder().serialNumber(1L).certificateAuthority(1).commonName(\"root\").build();\r\n    HeldCertificate intermediateCa = new HeldCertificate.Builder().signedBy(rootCa).certificateAuthority(0).serialNumber(2L).commonName(\"intermediate_ca\").build();\r\n    HeldCertificate certificate = new HeldCertificate.Builder().signedBy(intermediateCa).serialNumber(3L).commonName(server.getHostName()).build();\r\n    CertificatePinner certificatePinner = new CertificatePinner.Builder().add(server.getHostName(), CertificatePinner.pin(rootCa.certificate())).build();\r\n    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder().addTrustedCertificate(rootCa.certificate()).build();\r\n    OkHttpClient client = defaultClient().newBuilder().sslSocketFactory(handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager()).hostnameVerifier(new RecordingHostnameVerifier()).certificatePinner(certificatePinner).build();\r\n    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder().heldCertificate(certificate, intermediateCa.certificate()).build();\r\n    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);\r\n    server.enqueue(new MockResponse().setBody(\"abc\").setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));\r\n    Call call1 = client.newCall(new Request.Builder().url(server.url(\"/\")).build());\r\n    Response response1 = call1.execute();\r\n    assertEquals(\"abc\", response1.body().string());\r\n    server.enqueue(new MockResponse().setBody(\"def\").setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));\r\n    Call call2 = client.newCall(new Request.Builder().url(server.url(\"/\")).build());\r\n    Response response2 = call2.execute();\r\n    assertEquals(\"def\", response2.body().string());\r\n}"
}, {
	"Path": "com.github.mikephil.charting.renderer.XAxisRenderer.renderLimitLines",
	"Comment": "draws the limitlines associated with this axis to the screen.",
	"Method": "void renderLimitLines(Canvas c){\r\n    List<LimitLine> limitLines = mXAxis.getLimitLines();\r\n    if (limitLines == null || limitLines.size() <= 0)\r\n        return;\r\n    float[] position = mRenderLimitLinesBuffer;\r\n    position[0] = 0;\r\n    position[1] = 0;\r\n    for (int i = 0; i < limitLines.size(); i++) {\r\n        LimitLine l = limitLines.get(i);\r\n        if (!l.isEnabled())\r\n            continue;\r\n        int clipRestoreCount = c.save();\r\n        mLimitLineClippingRect.set(mViewPortHandler.getContentRect());\r\n        mLimitLineClippingRect.inset(-l.getLineWidth(), 0.f);\r\n        c.clipRect(mLimitLineClippingRect);\r\n        position[0] = l.getLimit();\r\n        position[1] = 0.f;\r\n        mTrans.pointValuesToPixel(position);\r\n        renderLimitLineLine(c, l, position);\r\n        renderLimitLineLabel(c, l, position, 2.f + l.getYOffset());\r\n        c.restoreToCount(clipRestoreCount);\r\n    }\r\n}"
}, {
	"Path": "org.apache.ibatis.io.ClassLoaderWrapper.getResourceAsStream",
	"Comment": "get a resource from the classpath, starting with a specific class loader",
	"Method": "InputStream getResourceAsStream(String resource,InputStream getResourceAsStream,String resource,ClassLoader classLoader,InputStream getResourceAsStream,String resource,ClassLoader[] classLoader){\r\n    for (ClassLoader cl : classLoader) {\r\n        if (null != cl) {\r\n            InputStream returnValue = cl.getResourceAsStream(resource);\r\n            if (null == returnValue) {\r\n                returnValue = cl.getResourceAsStream(\"/\" + resource);\r\n            }\r\n            if (null != returnValue) {\r\n                return returnValue;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.refine.expr.MetaParser.parse",
	"Comment": "parse an expression that might have a language prefix into an evaluable.expressions without valid prefixes or without any prefix are assumed to begrel expressions.",
	"Method": "Evaluable parse(String s){\r\n    String language = \"grel\";\r\n    int colon = s.indexOf(':');\r\n    if (colon >= 0) {\r\n        language = s.substring(0, colon).toLowerCase();\r\n        if (\"gel\".equals(language)) {\r\n            language = \"grel\";\r\n        }\r\n    }\r\n    LanguageInfo info = s_languages.get(language.toLowerCase());\r\n    if (info != null) {\r\n        return info.parser.parse(s.substring(colon + 1));\r\n    } else {\r\n        return parseGREL(s);\r\n    }\r\n}"
}, {
	"Path": "com.google.refine.tests.RefineTest.createCSVProject",
	"Comment": "helper to create a project from a csv encoded as a file. not muchcontrol is given on the import options, because this method is intendedto be a quick way to create a project for a test. for more control overthe import, just call the importer directly.the projects created via this method and their importing jobs will be disposed ofat the end of each test.",
	"Method": "Project createCSVProject(String input,Project createCSVProject,String projectName,String input){\r\n    Project project = new Project();\r\n    ProjectMetadata metadata = new ProjectMetadata();\r\n    metadata.setName(projectName);\r\n    ObjectNode options = mock(ObjectNode.class);\r\n    prepareImportOptions(options, \",\", -1, 0, 0, 1, false, false);\r\n    ImportingJob job = ImportingManager.createJob();\r\n    SeparatorBasedImporter importer = new SeparatorBasedImporter();\r\n    List<Exception> exceptions = new ArrayList<Exception>();\r\n    importer.parseOneFile(project, metadata, job, \"filesource\", new StringReader(input), -1, options, exceptions);\r\n    project.update();\r\n    ProjectManager.singleton.registerProject(project, metadata);\r\n    projects.add(project);\r\n    importingJobs.add(job);\r\n    return project;\r\n}"
}, {
	"Path": "com.google.refine.history.HistoryEntry.apply",
	"Comment": "apply a change to a project.in most cases you should already hold the project lockbefore calling this method to prevent deadlocks.",
	"Method": "void apply(Project project){\r\n    if (getChange() == null) {\r\n        ProjectManager.singleton.getHistoryEntryManager().loadChange(this);\r\n    }\r\n    synchronized (project) {\r\n        getChange().apply(project);\r\n        try {\r\n            _manager.saveChange(this);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            getChange().revert(project);\r\n            throw new RuntimeException(\"Failed to apply change\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.FileUtils.loadEntriesFromAssets",
	"Comment": "loads an array of entries from a textfile from the assets folder.",
	"Method": "List<Entry> loadEntriesFromAssets(AssetManager am,String path){\r\n    List<Entry> entries = new ArrayList<Entry>();\r\n    BufferedReader reader = null;\r\n    try {\r\n        reader = new BufferedReader(new InputStreamReader(am.open(path), \"UTF-8\"));\r\n        String line = reader.readLine();\r\n        while (line != null) {\r\n            String[] split = line.split(\"#\");\r\n            if (split.length <= 2) {\r\n                entries.add(new Entry(Float.parseFloat(split[1]), Float.parseFloat(split[0])));\r\n            } else {\r\n                float[] vals = new float[split.length - 1];\r\n                for (int i = 0; i < vals.length; i++) {\r\n                    vals[i] = Float.parseFloat(split[i]);\r\n                }\r\n                entries.add(new BarEntry(Integer.parseInt(split[split.length - 1]), vals));\r\n            }\r\n            line = reader.readLine();\r\n        }\r\n    } catch (IOException e) {\r\n        Log.e(LOG, e.toString());\r\n    } finally {\r\n        if (reader != null) {\r\n            try {\r\n                reader.close();\r\n            } catch (IOException e) {\r\n                Log.e(LOG, e.toString());\r\n            }\r\n        }\r\n    }\r\n    return entries;\r\n}"
}, {
	"Path": "okhttp3.internal.http2.Http2Connection.shutdown",
	"Comment": "degrades this connection such that new streams can neither be created locally, nor acceptedfrom the remote peer. existing streams are not impacted. this is intended to permit an endpointto gracefully stop accepting new requests without harming previously established streams.",
	"Method": "void shutdown(ErrorCode statusCode){\r\n    synchronized (writer) {\r\n        int lastGoodStreamId;\r\n        synchronized (this) {\r\n            if (shutdown) {\r\n                return;\r\n            }\r\n            shutdown = true;\r\n            lastGoodStreamId = this.lastGoodStreamId;\r\n        }\r\n        writer.goAway(lastGoodStreamId, statusCode, Util.EMPTY_BYTE_ARRAY);\r\n    }\r\n}"
}, {
	"Path": "org.openrefine.wikidata.updates.ItemUpdateBuilder.addDescriptions",
	"Comment": "adds a list of descriptions to the item. it will override any existingdescription in each language.",
	"Method": "ItemUpdateBuilder addDescriptions(Set<MonolingualTextValue> descriptions){\r\n    Validate.isTrue(!built, \"ItemUpdate has already been built\");\r\n    this.descriptions.addAll(descriptions);\r\n    return this;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.setRendererLeftYAxis",
	"Comment": "sets a custom axis renderer for the left axis and overwrites the existing one.",
	"Method": "void setRendererLeftYAxis(YAxisRenderer rendererLeftYAxis){\r\n    mAxisRendererLeft = rendererLeftYAxis;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.PieChart.getHoleRadius",
	"Comment": "returns the size of the hole radius in percent of the total radius.",
	"Method": "float getHoleRadius(){\r\n    return mHoleRadiusPercent;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.Chart.setData",
	"Comment": "sets a new data object for the chart. the data object contains all valuesand information needed for displaying.",
	"Method": "void setData(T data){\r\n    mData = data;\r\n    mOffsetsCalculated = false;\r\n    if (data == null) {\r\n        return;\r\n    }\r\n    setupDefaultFormatter(data.getYMin(), data.getYMax());\r\n    for (IDataSet set : mData.getDataSets()) {\r\n        if (set.needsFormatter() || set.getValueFormatter() == mDefaultValueFormatter)\r\n            set.setValueFormatter(mDefaultValueFormatter);\r\n    }\r\n    notifyDataSetChanged();\r\n    if (mLogEnabled)\r\n        Log.i(LOG_TAG, \"Data is set.\");\r\n}"
}, {
	"Path": "okhttp3.internal.cache.DiskLruCacheTest.readAndWriteOverlapsMaintainConsistency",
	"Comment": "each read sees a snapshot of the file at the time read was called. this means that two reads ofthe same key can see different data.",
	"Method": "void readAndWriteOverlapsMaintainConsistency(){\r\n    DiskLruCache.Editor v1Creator = cache.edit(\"k1\");\r\n    setString(v1Creator, 0, \"AAaa\");\r\n    setString(v1Creator, 1, \"BBbb\");\r\n    v1Creator.commit();\r\n    DiskLruCache.Snapshot snapshot1 = cache.get(\"k1\");\r\n    BufferedSource inV1 = Okio.buffer(snapshot1.getSource(0));\r\n    assertEquals('A', inV1.readByte());\r\n    assertEquals('A', inV1.readByte());\r\n    DiskLruCache.Editor v1Updater = cache.edit(\"k1\");\r\n    setString(v1Updater, 0, \"CCcc\");\r\n    setString(v1Updater, 1, \"DDdd\");\r\n    v1Updater.commit();\r\n    DiskLruCache.Snapshot snapshot2 = cache.get(\"k1\");\r\n    assertSnapshotValue(snapshot2, 0, \"CCcc\");\r\n    assertSnapshotValue(snapshot2, 1, \"DDdd\");\r\n    snapshot2.close();\r\n    assertEquals('a', inV1.readByte());\r\n    assertEquals('a', inV1.readByte());\r\n    assertSnapshotValue(snapshot1, 1, \"BBbb\");\r\n    snapshot1.close();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.ChartData.contains",
	"Comment": "checks if this data object contains the specified dataset. returns trueif so, false if not.",
	"Method": "boolean contains(T dataSet){\r\n    for (T set : mDataSets) {\r\n        if (set.equals(dataSet))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.mvp.delegate.FragmentMvpViewStateDelegateImpl.restorePresenterOrRecreateNewPresenterAfterProcessDeath",
	"Comment": "creates the presenter instance if not able to reuse presenter from presentermanager",
	"Method": "P restorePresenterOrRecreateNewPresenterAfterProcessDeath(){\r\n    P presenter;\r\n    if (keepPresenterInstanceDuringScreenOrientationChanges) {\r\n        if (mosbyViewId != null && (presenter = PresenterManager.getPresenter(getActivity(), mosbyViewId)) != null) {\r\n            if (DEBUG) {\r\n                Log.d(DEBUG_TAG, \"Reused presenter \" + presenter + \" for view \" + delegateCallback.getMvpView());\r\n            }\r\n            return presenter;\r\n        } else {\r\n            presenter = createViewIdAndPresenter();\r\n            if (DEBUG) {\r\n                Log.d(DEBUG_TAG, \"No presenter found although view Id was here: \" + mosbyViewId + \". Most likely this was caused by a process death. New Presenter created\" + presenter + \" for view \" + delegateCallback.getMvpView());\r\n            }\r\n            return presenter;\r\n        }\r\n    } else {\r\n        presenter = createViewIdAndPresenter();\r\n        if (DEBUG) {\r\n            Log.d(DEBUG_TAG, \"New presenter \" + presenter + \" for view \" + delegateCallback.getMvpView());\r\n        }\r\n        return presenter;\r\n    }\r\n}"
}, {
	"Path": "org.mockitoutil.TestBase.filterHashCode",
	"Comment": "filters out hashcode from the text. useful for writing assertions that contain the string representation of mock objects",
	"Method": "String filterHashCode(String text){\r\n    return text.replaceAll(\"hashCode: (\\\\d)+\\\\.\", \"hashCode: xxx.\");\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarChart.setDrawBarShadow",
	"Comment": "if set to true, a grey area is drawn behind each bar that indicates the maximum value. enabling his will reduceperformance by about 50%.",
	"Method": "void setDrawBarShadow(boolean enabled){\r\n    mDrawBarShadow = enabled;\r\n}"
}, {
	"Path": "okhttp3.Address.sslSocketFactory",
	"Comment": "returns the ssl socket factory, or null if this is not an https address.",
	"Method": "SSLSocketFactory sslSocketFactory(){\r\n    return sslSocketFactory;\r\n}"
}, {
	"Path": "okhttp3.Headers.get",
	"Comment": "returns the last value corresponding to the specified field, or null.",
	"Method": "String get(String name,String get,String[] namesAndValues,String name,String get,String name){\r\n    for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {\r\n        if (name.equalsIgnoreCase(namesAndValues[i])) {\r\n            return namesAndValues[i + 1];\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "okhttp3.logging.HttpLoggingInterceptor.isPlaintext",
	"Comment": "returns true if the body in question probably contains human readable text. uses a small sampleof code points to detect unicode control characters commonly used in binary file signatures.",
	"Method": "boolean isPlaintext(Buffer buffer){\r\n    try {\r\n        Buffer prefix = new Buffer();\r\n        long byteCount = buffer.size() < 64 ? buffer.size() : 64;\r\n        buffer.copyTo(prefix, 0, byteCount);\r\n        for (int i = 0; i < 16; i++) {\r\n            if (prefix.exhausted()) {\r\n                break;\r\n            }\r\n            int codePoint = prefix.readUtf8CodePoint();\r\n            if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    } catch (EOFException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.hannesdorfmann.mosby3.sample.mvi.businesslogic.searchengine.SearchEngine.isProductMatchingSearchCriteria",
	"Comment": "filters those items that contains the search query text in name, description or category",
	"Method": "boolean isProductMatchingSearchCriteria(Product product,String searchQueryText){\r\n    String[] words = searchQueryText.split(\" \");\r\n    for (String w : words) {\r\n        if (product.getName().contains(w))\r\n            return true;\r\n        if (product.getDescription().contains(w))\r\n            return true;\r\n        if (product.getCategory().contains(w))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.ibatis.reflection.Reflector.getType",
	"Comment": "gets the name of the class the instance provides information for",
	"Method": "Class<?> getType(){\r\n    return type;\r\n}"
}, {
	"Path": "permissions.dispatcher.sample.contacts.ContactsFragment.loadContact",
	"Comment": "restart the loader to query the contacts content provider to display the first contact.",
	"Method": "void loadContact(){\r\n    getLoaderManager().restartLoader(0, null, this);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.utils.Utils.formatNumber",
	"Comment": "formats the given number to the given number of decimals, and returns thenumber as a string, maximum 35 characters.",
	"Method": "String formatNumber(float number,int digitCount,boolean separateThousands,String formatNumber,float number,int digitCount,boolean separateThousands,char separateChar){\r\n    char[] out = new char[35];\r\n    boolean neg = false;\r\n    if (number == 0) {\r\n        return \"0\";\r\n    }\r\n    boolean zero = false;\r\n    if (number < 1 && number > -1) {\r\n        zero = true;\r\n    }\r\n    if (number < 0) {\r\n        neg = true;\r\n        number = -number;\r\n    }\r\n    if (digitCount > POW_10.length) {\r\n        digitCount = POW_10.length - 1;\r\n    }\r\n    number *= POW_10[digitCount];\r\n    long lval = Math.round(number);\r\n    int ind = out.length - 1;\r\n    int charCount = 0;\r\n    boolean decimalPointAdded = false;\r\n    while (lval != 0 || charCount < (digitCount + 1)) {\r\n        int digit = (int) (lval % 10);\r\n        lval = lval / 10;\r\n        out[ind--] = (char) (digit + '0');\r\n        charCount++;\r\n        if (charCount == digitCount) {\r\n            out[ind--] = ',';\r\n            charCount++;\r\n            decimalPointAdded = true;\r\n        } else if (separateThousands && lval != 0 && charCount > digitCount) {\r\n            if (decimalPointAdded) {\r\n                if ((charCount - digitCount) % 4 == 0) {\r\n                    out[ind--] = separateChar;\r\n                    charCount++;\r\n                }\r\n            } else {\r\n                if ((charCount - digitCount) % 4 == 3) {\r\n                    out[ind--] = separateChar;\r\n                    charCount++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (zero) {\r\n        out[ind--] = '0';\r\n        charCount += 1;\r\n    }\r\n    if (neg) {\r\n        out[ind--] = '-';\r\n        charCount += 1;\r\n    }\r\n    int start = out.length - charCount;\r\n    return String.valueOf(out, start, out.length - start);\r\n}"
}, {
	"Path": "org.apache.ibatis.executor.resultset.ResultSetWrapper.getTypeHandler",
	"Comment": "gets the type handler to use when reading the result set.tries to get from the typehandlerregistry by searching for the property type.if not found it gets the column jdbc type and tries to get a handler for it.",
	"Method": "TypeHandler<?> getTypeHandler(Class<?> propertyType,String columnName){\r\n    TypeHandler<?> handler = null;\r\n    Map<Class<?>, TypeHandler<?>> columnHandlers = typeHandlerMap.get(columnName);\r\n    if (columnHandlers == null) {\r\n        columnHandlers = new HashMap();\r\n        typeHandlerMap.put(columnName, columnHandlers);\r\n    } else {\r\n        handler = columnHandlers.get(propertyType);\r\n    }\r\n    if (handler == null) {\r\n        JdbcType jdbcType = getJdbcType(columnName);\r\n        handler = typeHandlerRegistry.getTypeHandler(propertyType, jdbcType);\r\n        if (handler == null || handler instanceof UnknownTypeHandler) {\r\n            final int index = columnNames.indexOf(columnName);\r\n            final Class<?> javaType = resolveClass(classNames.get(index));\r\n            if (javaType != null && jdbcType != null) {\r\n                handler = typeHandlerRegistry.getTypeHandler(javaType, jdbcType);\r\n            } else if (javaType != null) {\r\n                handler = typeHandlerRegistry.getTypeHandler(javaType);\r\n            } else if (jdbcType != null) {\r\n                handler = typeHandlerRegistry.getTypeHandler(jdbcType);\r\n            }\r\n        }\r\n        if (handler == null || handler instanceof UnknownTypeHandler) {\r\n            handler = new ObjectTypeHandler();\r\n        }\r\n        columnHandlers.put(propertyType, handler);\r\n    }\r\n    return handler;\r\n}"
}, {
	"Path": "okhttp3.internal.JavaNetHeaders.toMultimap",
	"Comment": "returns an immutable map containing each field to its list of values.",
	"Method": "Map<String, List<String>> toMultimap(Headers headers,String valueForNullKey){\r\n    Map<String, List<String>> result = new TreeMap(FIELD_NAME_COMPARATOR);\r\n    for (int i = 0, size = headers.size(); i < size; i++) {\r\n        String fieldName = headers.name(i);\r\n        String value = headers.value(i);\r\n        List<String> allValues = new ArrayList();\r\n        List<String> otherValues = result.get(fieldName);\r\n        if (otherValues != null) {\r\n            allValues.addAll(otherValues);\r\n        }\r\n        allValues.add(value);\r\n        result.put(fieldName, Collections.unmodifiableList(allValues));\r\n    }\r\n    if (valueForNullKey != null) {\r\n        result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));\r\n    }\r\n    return Collections.unmodifiableMap(result);\r\n}"
}, {
	"Path": "com.google.refine.tests.expr.functions.CrossFunctionTests.crossFunctionOneToManyTest",
	"Comment": "to demonstrate that the cross function can join multiple rows.",
	"Method": "void crossFunctionOneToManyTest(){\r\n    Row row = ((Row) ((WrappedRow) ((HasFieldsListImpl) invoke(\"cross\", \"john\", \"My Address Book\", \"friend\")).get(1)).row);\r\n    String address = row.getCell(1).value.toString();\r\n    Assert.assertEquals(address, \"999 XXXXXX St.\");\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.Legend.getYEntrySpace",
	"Comment": "returns the space between the legend entries on a vertical axis in pixels",
	"Method": "float getYEntrySpace(){\r\n    return mYEntrySpace;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.BarLineChartBase.setAutoScaleMinMaxEnabled",
	"Comment": "flag that indicates if auto scaling on the y axis is enabled. this isespecially interesting for charts displaying financial data.",
	"Method": "void setAutoScaleMinMaxEnabled(boolean enabled){\r\n    mAutoScaleMinMaxEnabled = enabled;\r\n}"
}, {
	"Path": "com.github.mikephil.charting.data.ScatterDataSet.setScatterShape",
	"Comment": "sets the scattershape this dataset should be drawn with. this will search for an available ishaperenderer and set thisrenderer for the dataset.",
	"Method": "void setScatterShape(ScatterChart.ScatterShape shape){\r\n    mShapeRenderer = getRendererForShape(shape);\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.serializeNulls",
	"Comment": "returns a json adapter equal to this json adapter, but that serializes nulls when encodingjson.",
	"Method": "JsonAdapter<T> serializeNulls(){\r\n    final JsonAdapter<T> delegate = this;\r\n    return new JsonAdapter<T>() {\r\n        @Override\r\n        @Nullable\r\n        public T fromJson(JsonReader reader) throws IOException {\r\n            return delegate.fromJson(reader);\r\n        }\r\n        @Override\r\n        public void toJson(JsonWriter writer, @Nullable T value) throws IOException {\r\n            boolean serializeNulls = writer.getSerializeNulls();\r\n            writer.setSerializeNulls(true);\r\n            try {\r\n                delegate.toJson(writer, value);\r\n            } finally {\r\n                writer.setSerializeNulls(serializeNulls);\r\n            }\r\n        }\r\n        @Override\r\n        boolean isLenient() {\r\n            return delegate.isLenient();\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return delegate + \".serializeNulls()\";\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.serializeNulls",
	"Comment": "returns a json adapter equal to this json adapter, but that serializes nulls when encodingjson.",
	"Method": "JsonAdapter<T> serializeNulls(){\r\n    return delegate.fromJson(reader);\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.serializeNulls",
	"Comment": "returns a json adapter equal to this json adapter, but that serializes nulls when encodingjson.",
	"Method": "JsonAdapter<T> serializeNulls(){\r\n    boolean serializeNulls = writer.getSerializeNulls();\r\n    writer.setSerializeNulls(true);\r\n    try {\r\n        delegate.toJson(writer, value);\r\n    } finally {\r\n        writer.setSerializeNulls(serializeNulls);\r\n    }\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.serializeNulls",
	"Comment": "returns a json adapter equal to this json adapter, but that serializes nulls when encodingjson.",
	"Method": "JsonAdapter<T> serializeNulls(){\r\n    return delegate.isLenient();\r\n}"
}, {
	"Path": "com.squareup.moshi.JsonAdapter.serializeNulls",
	"Comment": "returns a json adapter equal to this json adapter, but that serializes nulls when encodingjson.",
	"Method": "JsonAdapter<T> serializeNulls(){\r\n    return delegate + \".serializeNulls()\";\r\n}"
}, {
	"Path": "okhttp3.slack.OAuthSessionFactory.dispatch",
	"Comment": "when the browser hits the redirect url, use the provided code to ask slack for a session.",
	"Method": "MockResponse dispatch(RecordedRequest request){\r\n    HttpUrl requestUrl = mockWebServer.url(request.getPath());\r\n    String code = requestUrl.queryParameter(\"code\");\r\n    String stateString = requestUrl.queryParameter(\"state\");\r\n    ByteString state = stateString != null ? ByteString.decodeBase64(stateString) : null;\r\n    Listener listener;\r\n    synchronized (this) {\r\n        listener = listeners.get(state);\r\n    }\r\n    if (code == null || listener == null) {\r\n        return new MockResponse().setResponseCode(404).setBody(\"unexpected request\");\r\n    }\r\n    try {\r\n        OAuthSession session = slackApi.exchangeCode(code, redirectUrl());\r\n        listener.sessionGranted(session);\r\n    } catch (IOException e) {\r\n        return new MockResponse().setResponseCode(400).setBody(\"code exchange failed: \" + e.getMessage());\r\n    }\r\n    synchronized (this) {\r\n        listeners.remove(state);\r\n    }\r\n    return new MockResponse().setResponseCode(302).addHeader(\"Location\", \"https://twitter.com/CuteEmergency/status/789457462864863232\");\r\n}"
}, {
	"Path": "com.google.refine.tests.model.RowTests.saveRowWithRecordIndex",
	"Comment": "this way of serializing a row with indices is now deprecated, see getrowscommand.",
	"Method": "void saveRowWithRecordIndex(){\r\n    Row row = new Row(5);\r\n    row.setCell(0, new Cell(\"I'm not empty\", null));\r\n    when(options.containsKey(\"rowIndex\")).thenReturn(true);\r\n    when(options.get(\"rowIndex\")).thenReturn(0);\r\n    when(options.containsKey(\"recordIndex\")).thenReturn(true);\r\n    when(options.get(\"recordIndex\")).thenReturn(1);\r\n    row.save(writer, options);\r\n}"
}, {
	"Path": "com.github.mikephil.charting.charts.RadarChart.getSliceAngle",
	"Comment": "returns the angle that each slice in the radar chart occupies.",
	"Method": "float getSliceAngle(){\r\n    return 360f / (float) mData.getMaxEntryCountSet().getEntryCount();\r\n}"
}, {
	"Path": "com.github.mikephil.charting.components.YAxis.isUseAutoScaleMinRestriction",
	"Comment": "returns true if autoscale restriction for axis min value is enabled",
	"Method": "boolean isUseAutoScaleMinRestriction(){\r\n    return mUseAutoScaleRestrictionMin;\r\n}"
}, {
	"Path": "okhttp3.internal.SocketRecorder.sslSocketFactory",
	"Comment": "returns an sslsocketfactory whose sockets will record all transmitted bytes.",
	"Method": "SSLSocketFactory sslSocketFactory(SSLSocketFactory delegate){\r\n    return new DelegatingSSLSocketFactory(delegate) {\r\n        @Override\r\n        protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {\r\n            RecordedSocket recordedSocket = new RecordedSocket();\r\n            recordedSockets.add(recordedSocket);\r\n            return new RecordingSSLSocket(sslSocket, recordedSocket);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "okhttp3.internal.SocketRecorder.sslSocketFactory",
	"Comment": "returns an sslsocketfactory whose sockets will record all transmitted bytes.",
	"Method": "SSLSocketFactory sslSocketFactory(SSLSocketFactory delegate){\r\n    RecordedSocket recordedSocket = new RecordedSocket();\r\n    recordedSockets.add(recordedSocket);\r\n    return new RecordingSSLSocket(sslSocket, recordedSocket);\r\n}"
}, {
	"Path": "org.mockito.internal.util.reflection.SuperTypesLastSorter.sortSuperTypesLast",
	"Comment": "return a new collection with the fields sorted first by name,then with any fields moved after their supertypes.",
	"Method": "List<Field> sortSuperTypesLast(Collection<? extends Field> unsortedFields){\r\n    List<Field> fields = new ArrayList<Field>(unsortedFields);\r\n    Collections.sort(fields, compareFieldsByName);\r\n    int i = 0;\r\n    while (i < fields.size() - 1) {\r\n        Field f = fields.get(i);\r\n        Class<?> ft = f.getType();\r\n        int newPos = i;\r\n        for (int j = i + 1; j < fields.size(); j++) {\r\n            Class<?> t = fields.get(j).getType();\r\n            if (ft != t && ft.isAssignableFrom(t)) {\r\n                newPos = j;\r\n            }\r\n        }\r\n        if (newPos == i) {\r\n            i++;\r\n        } else {\r\n            fields.remove(i);\r\n            fields.add(newPos, f);\r\n        }\r\n    }\r\n    return fields;\r\n}"
}]