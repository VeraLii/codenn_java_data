[{
	"Path": "com.facebook.presto.sql.planner.SubqueryPlanner.tryResolveMissingExpression",
	"Comment": "checks if give reference expression can resolved within given plan.",
	"Method": "Optional<Expression> tryResolveMissingExpression(PlanBuilder subPlan,Expression expression){\r\n    Expression rewritten = subPlan.rewrite(expression);\r\n    if (rewritten != expression) {\r\n        return Optional.of(rewritten);\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.setEndValue",
	"Comment": "set the rest value to determine the displacement for the spring",
	"Method": "Spring setEndValue(double endValue){\r\n    if (mEndValue == endValue && isAtRest()) {\r\n        return this;\r\n    }\r\n    mStartValue = getCurrentValue();\r\n    mEndValue = endValue;\r\n    mSpringSystem.activateSpring(this.getId());\r\n    for (SpringListener listener : mListeners) {\r\n        listener.onSpringEndStateChange(this);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "io.realm.ManagedOrderedRealmCollectionTests.sort_manyDifferentCharacters",
	"Comment": "no sorting order defined. there are korean, arabic and chinese characters.",
	"Method": "void sort_manyDifferentCharacters(){\r\n    if (isSnapshot(collectionClass)) {\r\n        thrown.expect(UnsupportedOperationException.class);\r\n    }\r\n    OrderedRealmCollection<AllJavaTypes> collection = createStringCollection(realm, collectionClass, \"단위\", \"테스�?\", \"وحدة\", \"اختبار\", \"单位\", \"试验\", \"單位\", \"測試\");\r\n    collection.sort(AllJavaTypes.FIELD_STRING);\r\n    assertEquals(8, collection.size());\r\n    collection.sort(AllJavaTypes.FIELD_STRING, Sort.DESCENDING);\r\n    assertEquals(8, collection.size());\r\n}"
}, {
	"Path": "io.realm.log.RealmLog.log",
	"Comment": "formats the message, parses the stacktrace of given throwable and passes them to nativelog.",
	"Method": "void log(int level,Throwable throwable,String message,Object args){\r\n    if (level < getLevel()) {\r\n        return;\r\n    }\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    if (message != null && args != null && args.length > 0) {\r\n        message = String.format(Locale.US, message, args);\r\n    }\r\n    if (throwable != null) {\r\n        stringBuilder.append(Log.getStackTraceString(throwable));\r\n    }\r\n    if (message != null) {\r\n        if (throwable != null) {\r\n            stringBuilder.append(\"\\n\");\r\n        }\r\n        stringBuilder.append(message);\r\n    }\r\n    nativeLog(level, REALM_JAVA_TAG, throwable, stringBuilder.toString());\r\n}"
}, {
	"Path": "com.facebook.presto.spi.block.BlockUtil.compactArray",
	"Comment": "returns an array containing elements in the specified range of the specified array.if the range matches the entire array, the input array will be returned.otherwise, a copy will be returned.",
	"Method": "boolean[] compactArray(boolean[] array,int index,int length,byte[] compactArray,byte[] array,int index,int length,short[] compactArray,short[] array,int index,int length,int[] compactArray,int[] array,int index,int length,long[] compactArray,long[] array,int index,int length){\r\n    if (index == 0 && length == array.length) {\r\n        return array;\r\n    }\r\n    return Arrays.copyOfRange(array, index, index + length);\r\n}"
}, {
	"Path": "io.realm.services.RemoteProcessService.currentLine",
	"Comment": "calls this function to return the string of current class and line number.",
	"Method": "String currentLine(){\r\n    StackTraceElement element = new Throwable().getStackTrace()[1];\r\n    return element.getClassName() + \" line \" + element.getLineNumber() + \": \";\r\n}"
}, {
	"Path": "com.facebook.presto.raptor.util.DatabaseUtil.mySqlErrorCodeMatches",
	"Comment": "check if an exception is caused by a mysql exception of certain error code",
	"Method": "boolean mySqlErrorCodeMatches(Exception e,int errorCode){\r\n    return Throwables.getCausalChain(e).stream().filter(SQLException.class::isInstance).map(SQLException.class::cast).filter(t -> t.getErrorCode() == errorCode).map(Throwable::getStackTrace).anyMatch(isMySQLException());\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.openPreNullWithRequired",
	"Comment": "change the schema version, no migration is needed. but then, null cannot be used as a value.",
	"Method": "void openPreNullWithRequired(){\r\n    configFactory.copyRealmFromAssets(context, \"string-only-required-pre-null-0.82.2.realm\", Realm.DEFAULT_REALM_NAME);\r\n    RealmConfiguration realmConfig = configFactory.createConfigurationBuilder().schemaVersion(0).schema(StringOnlyRequired.class).build();\r\n    Realm realm = Realm.getInstance(realmConfig);\r\n    StringOnlyRequired stringOnlyRequired = realm.where(StringOnlyRequired.class).findFirst();\r\n    assertNotNull(stringOnlyRequired);\r\n    assertEquals(\"String_set_with_0.82.2\", stringOnlyRequired.getChars());\r\n    realm.beginTransaction();\r\n    try {\r\n        stringOnlyRequired.setChars(null);\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n        assertThat(expected.getMessage(), CoreMatchers.containsString(\"Trying to set non-nullable field 'chars' to null.\"));\r\n    }\r\n    realm.cancelTransaction();\r\n    realm.close();\r\n}"
}, {
	"Path": "com.facebook.rebound.SpringChain.setControlSpringIndex",
	"Comment": "set the index of the control spring. this spring will drive the positions of all the springsbefore and after it in the list when moved.",
	"Method": "SpringChain setControlSpringIndex(int i){\r\n    mControlSpringIndex = i;\r\n    Spring controlSpring = mSprings.get(mControlSpringIndex);\r\n    if (controlSpring == null) {\r\n        return null;\r\n    }\r\n    for (Spring spring : mSpringSystem.getAllSprings()) {\r\n        spring.setSpringConfig(mAttachmentSpringConfig);\r\n    }\r\n    getControlSpring().setSpringConfig(mMainSpringConfig);\r\n    return this;\r\n}"
}, {
	"Path": "org.redisson.config.SentinelServersConfig.setMasterName",
	"Comment": "master server name used by redis sentinel servers and master change monitoring task.",
	"Method": "SentinelServersConfig setMasterName(String masterName){\r\n    this.masterName = masterName;\r\n    return this;\r\n}"
}, {
	"Path": "org.redisson.config.BaseConfig.setClientName",
	"Comment": "setup connection name during connection initvia client setname command",
	"Method": "T setClientName(String clientName){\r\n    this.clientName = clientName;\r\n    return (T) this;\r\n}"
}, {
	"Path": "io.realm.RealmTests.copyToRealm_convertsNullToDefaultValue",
	"Comment": "checks that if a field has a null value, it gets converted to the default value for that type.",
	"Method": "void copyToRealm_convertsNullToDefaultValue(){\r\n    realm.beginTransaction();\r\n    AllTypes realmTypes = realm.copyToRealm(new AllTypes());\r\n    realm.commitTransaction();\r\n    assertEquals(\"\", realmTypes.getColumnString());\r\n    assertEquals(new Date(0), realmTypes.getColumnDate());\r\n    assertArrayEquals(new byte[0], realmTypes.getColumnBinary());\r\n    assertNotNull(realmTypes.getColumnRealmList());\r\n    assertNotNull(realmTypes.getColumnStringList());\r\n    assertNotNull(realmTypes.getColumnBinaryList());\r\n    assertNotNull(realmTypes.getColumnBooleanList());\r\n    assertNotNull(realmTypes.getColumnLongList());\r\n    assertNotNull(realmTypes.getColumnDoubleList());\r\n    assertNotNull(realmTypes.getColumnFloatList());\r\n    assertNotNull(realmTypes.getColumnDateList());\r\n}"
}, {
	"Path": "io.realm.ObjectServerError.getException",
	"Comment": "returns the underlying exception causing this error, if any.",
	"Method": "Throwable getException(){\r\n    return exception;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanCreateSchema",
	"Comment": "check if identity is allowed to create the specified schema in this catalog.",
	"Method": "void checkCanCreateSchema(ConnectorTransactionHandle transactionHandle,Identity identity,String schemaName){\r\n    denyCreateSchema(schemaName);\r\n}"
}, {
	"Path": "com.facebook.presto.block.AbstractTestBlock.assertBlockPosition",
	"Comment": "expectedvaluetype is required since otherwise the expected value type is unknown when expectedvalue is null.",
	"Method": "void assertBlockPosition(Block block,Supplier<BlockBuilder> newBlockBuilder,int position,T expectedValue,Class<?> expectedValueType){\r\n    assertPositionValue(block, position, expectedValue);\r\n    assertPositionValue(block.getSingleValueBlock(position), 0, expectedValue);\r\n    assertPositionValue(block.getRegion(position, 1), 0, expectedValue);\r\n    assertPositionValue(block.getRegion(0, position + 1), position, expectedValue);\r\n    assertPositionValue(block.getRegion(position, block.getPositionCount() - position), 0, expectedValue);\r\n    assertPositionValue(copyBlockViaBlockSerde(block.getRegion(position, 1)), 0, expectedValue);\r\n    assertPositionValue(copyBlockViaBlockSerde(block.getRegion(0, position + 1)), position, expectedValue);\r\n    assertPositionValue(copyBlockViaBlockSerde(block.getRegion(position, block.getPositionCount() - position)), 0, expectedValue);\r\n    assertPositionValue(copyBlockViaWritePositionTo(block.getRegion(position, 1), newBlockBuilder), 0, expectedValue);\r\n    assertPositionValue(copyBlockViaWritePositionTo(block.getRegion(0, position + 1), newBlockBuilder), position, expectedValue);\r\n    assertPositionValue(copyBlockViaWritePositionTo(block.getRegion(position, block.getPositionCount() - position), newBlockBuilder), 0, expectedValue);\r\n    if (expectedValueType.isArray() || expectedValueType == List.class || expectedValueType == Map.class) {\r\n        assertPositionValue(copyBlockViaWriteStructure(block.getRegion(position, 1), newBlockBuilder), 0, expectedValue);\r\n        assertPositionValue(copyBlockViaWriteStructure(block.getRegion(0, position + 1), newBlockBuilder), position, expectedValue);\r\n        assertPositionValue(copyBlockViaWriteStructure(block.getRegion(position, block.getPositionCount() - position), newBlockBuilder), 0, expectedValue);\r\n    }\r\n    assertPositionValue(block.copyRegion(position, 1), 0, expectedValue);\r\n    assertPositionValue(block.copyRegion(0, position + 1), position, expectedValue);\r\n    assertPositionValue(block.copyRegion(position, block.getPositionCount() - position), 0, expectedValue);\r\n    assertPositionValue(block.copyPositions(new int[] { position }, 0, 1), 0, expectedValue);\r\n}"
}, {
	"Path": "com.facebook.rebound.playground.examples.scrollview.SpringScrollView.computeVerticalScrollRange",
	"Comment": "the scroll range of a scroll view is the overall height of all of itschildren.",
	"Method": "int computeVerticalScrollRange(){\r\n    final int count = getChildCount();\r\n    final int contentHeight = getHeight() - getPaddingBottom() - getPaddingTop();\r\n    if (count == 0) {\r\n        return contentHeight;\r\n    }\r\n    int scrollRange = getChildAt(0).getBottom();\r\n    final int scrollY = getScrollY();\r\n    final int overscrollBottom = Math.max(0, scrollRange - contentHeight);\r\n    if (scrollY < 0) {\r\n        scrollRange -= scrollY;\r\n    } else if (scrollY > overscrollBottom) {\r\n        scrollRange += scrollY - overscrollBottom;\r\n    }\r\n    return scrollRange;\r\n}"
}, {
	"Path": "io.realm.processor.ClassMetaData.generate",
	"Comment": "builds the meta data structures for this class. any errors or messages will beposted on the provided messager.",
	"Method": "boolean generate(ModuleMetaData moduleMetaData){\r\n    Element enclosingElement = classType.getEnclosingElement();\r\n    if (!enclosingElement.getKind().equals(ElementKind.PACKAGE)) {\r\n        Utils.error(\"The RealmClass annotation does not support nested classes.\", classType);\r\n        return false;\r\n    }\r\n    TypeElement parentElement = (TypeElement) Utils.getSuperClass(classType);\r\n    if (!parentElement.toString().equals(\"java.lang.Object\") && !parentElement.toString().equals(\"io.realm.RealmObject\")) {\r\n        Utils.error(\"Valid model classes must either extend RealmObject or implement RealmModel.\", classType);\r\n        return false;\r\n    }\r\n    PackageElement packageElement = (PackageElement) enclosingElement;\r\n    packageName = packageElement.getQualifiedName().toString();\r\n    String qualifiedClassName = packageName + \".\" + javaClassName;\r\n    NameConverter moduleClassNameFormatter = moduleMetaData.getClassNameFormatter(qualifiedClassName);\r\n    defaultFieldNameFormatter = moduleMetaData.getFieldNameFormatter(qualifiedClassName);\r\n    RealmClass realmClassAnnotation = classType.getAnnotation(RealmClass.class);\r\n    if (!realmClassAnnotation.name().isEmpty()) {\r\n        internalClassName = realmClassAnnotation.name();\r\n    } else if (!realmClassAnnotation.value().isEmpty()) {\r\n        internalClassName = realmClassAnnotation.value();\r\n    } else {\r\n        internalClassName = moduleClassNameFormatter.convert(javaClassName);\r\n    }\r\n    if (internalClassName.length() > MAX_CLASSNAME_LENGTH) {\r\n        Utils.error(String.format(Locale.US, \"Internal class name is too long. Class '%s' \" + \"is converted to '%s', which is longer than the maximum allowed of %d characters\", javaClassName, internalClassName, 57));\r\n        return false;\r\n    }\r\n    if (realmClassAnnotation.fieldNamingPolicy() != RealmNamingPolicy.NO_POLICY) {\r\n        defaultFieldNameFormatter = Utils.getNameFormatter(realmClassAnnotation.fieldNamingPolicy());\r\n    }\r\n    if (!categorizeClassElements()) {\r\n        return false;\r\n    }\r\n    if (!checkCollectionTypes()) {\r\n        return false;\r\n    }\r\n    if (!checkReferenceTypes()) {\r\n        return false;\r\n    }\r\n    if (!checkDefaultConstructor()) {\r\n        return false;\r\n    }\r\n    if (!checkForFinalFields()) {\r\n        return false;\r\n    }\r\n    if (!checkForVolatileFields()) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.realm.RealmJsonNullPrimaryKeyTests.data",
	"Comment": "parameters for testing null primary key value. primarykey field is explicitly null.",
	"Method": "Iterable<Object[]> data(){\r\n    return Arrays.asList(new Object[][] { { PrimaryKeyAsBoxedByte.class, \"OhThisIsNullKey?!\", \"{ \\\"id\\\":null, \\\"name\\\":\\\"OhThisIsNullKey?!\\\" }\" }, { PrimaryKeyAsBoxedShort.class, \"YouBetItIsNullKey\", \"{ \\\"id\\\":null, \\\"name\\\":\\\"YouBetItIsNullKey\\\" }\" }, { PrimaryKeyAsBoxedInteger.class, \"Gosh Didnt KnowIt\", \"{ \\\"id\\\":null, \\\"name\\\":\\\"Gosh Didnt KnowIt\\\" }\" }, { PrimaryKeyAsBoxedLong.class, \"?YOUNOWKNOWRIGHT?\", \"{ \\\"id\\\":null, \\\"name\\\":\\\"?YOUNOWKNOWRIGHT?\\\" }\" }, { PrimaryKeyAsString.class, \"4299121\", \"{ \\\"name\\\":null, \\\"id\\\":4299121  }\" } });\r\n}"
}, {
	"Path": "io.realm.RealmQuery.contains",
	"Comment": "condition that value of field contains the specified substring.",
	"Method": "RealmQuery<E> contains(String fieldName,String value,RealmQuery<E> contains,String fieldName,String value,Case casing){\r\n    realm.checkIfValid();\r\n    FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);\r\n    this.query.contains(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);\r\n    return this;\r\n}"
}, {
	"Path": "org.redisson.config.Config.useReplicatedServers",
	"Comment": "init replicated servers configuration.most used with azure redis cache or aws elasticache",
	"Method": "ReplicatedServersConfig useReplicatedServers(ReplicatedServersConfig useReplicatedServers,ReplicatedServersConfig config){\r\n    checkClusterServersConfig();\r\n    checkMasterSlaveServersConfig();\r\n    checkSentinelServersConfig();\r\n    checkSingleServerConfig();\r\n    checkElasticacheServersConfig();\r\n    if (replicatedServersConfig == null) {\r\n        replicatedServersConfig = new ReplicatedServersConfig();\r\n    }\r\n    return replicatedServersConfig;\r\n}"
}, {
	"Path": "com.facebook.presto.rcfile.RcFileDecoderUtils.findFirstSyncPosition",
	"Comment": "find the beginning of the first full sync sequence that starts within the specified range.",
	"Method": "long findFirstSyncPosition(RcFileDataSource dataSource,long offset,long length,long syncFirst,long syncSecond){\r\n    requireNonNull(dataSource, \"dataSource is null\");\r\n    checkArgument(offset >= 0, \"offset is negative\");\r\n    checkArgument(length >= 1, \"length must be at least 1\");\r\n    checkArgument(offset + length <= dataSource.getSize(), \"offset plus length is greater than data size\");\r\n    Slice sync = Slices.allocate(SIZE_OF_INT + SIZE_OF_LONG + SIZE_OF_LONG);\r\n    sync.setInt(0, 0xFFFF_FFFF);\r\n    sync.setLong(SIZE_OF_INT, syncFirst);\r\n    sync.setLong(SIZE_OF_INT + SIZE_OF_LONG, syncSecond);\r\n    byte[] buffer = new byte[toIntExact(min(1 << 22, length + (SYNC_SEQUENCE_LENGTH - 1)))];\r\n    Slice bufferSlice = Slices.wrappedBuffer(buffer);\r\n    for (long position = 0; position < length; position += bufferSlice.length() - (SYNC_SEQUENCE_LENGTH - 1)) {\r\n        int bufferSize = toIntExact(min(buffer.length, length + (SYNC_SEQUENCE_LENGTH - 1) - position));\r\n        bufferSize = toIntExact(min(bufferSize, dataSource.getSize() - offset - position));\r\n        dataSource.readFully(offset + position, buffer, 0, bufferSize);\r\n        int index = bufferSlice.indexOf(sync);\r\n        if (index >= 0) {\r\n            if (position + index < length) {\r\n                long startOfSyncSequence = offset + position + index;\r\n                return startOfSyncSequence;\r\n            } else {\r\n                return -1;\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "io.realm.objectserver.ProgressListenerTests.uploadListener_worksEvenIfCrashed",
	"Comment": "make sure that a progresslistener continues to report the correct thing, even if it crashed",
	"Method": "void uploadListener_worksEvenIfCrashed(){\r\n    final AtomicInteger transferCompleted = new AtomicInteger(0);\r\n    final CountDownLatch testDone = new CountDownLatch(1);\r\n    final SyncConfiguration config = createSyncConfig();\r\n    Realm realm = Realm.getInstance(config);\r\n    writeSampleData(realm);\r\n    SyncSession session = SyncManager.getSession(config);\r\n    session.addUploadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {\r\n        @Override\r\n        public void onChange(Progress progress) {\r\n            if (progress.isTransferComplete()) {\r\n                switch(transferCompleted.incrementAndGet()) {\r\n                    case 1:\r\n                        Realm realm = Realm.getInstance(config);\r\n                        writeSampleData(realm);\r\n                        realm.close();\r\n                        throw new RuntimeException(\"Crashing the changelistener\");\r\n                    case 2:\r\n                        assertTransferComplete(progress, true);\r\n                        testDone.countDown();\r\n                        break;\r\n                    default:\r\n                        fail(\"Unsupported number of transfers completed: \" + transferCompleted.get());\r\n                }\r\n            }\r\n        }\r\n    });\r\n    TestHelper.awaitOrFail(testDone);\r\n    realm.close();\r\n}"
}, {
	"Path": "io.realm.objectserver.ProgressListenerTests.uploadListener_worksEvenIfCrashed",
	"Comment": "make sure that a progresslistener continues to report the correct thing, even if it crashed",
	"Method": "void uploadListener_worksEvenIfCrashed(){\r\n    if (progress.isTransferComplete()) {\r\n        switch(transferCompleted.incrementAndGet()) {\r\n            case 1:\r\n                Realm realm = Realm.getInstance(config);\r\n                writeSampleData(realm);\r\n                realm.close();\r\n                throw new RuntimeException(\"Crashing the changelistener\");\r\n            case 2:\r\n                assertTransferComplete(progress, true);\r\n                testDone.countDown();\r\n                break;\r\n            default:\r\n                fail(\"Unsupported number of transfers completed: \" + transferCompleted.get());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.connector.thrift.util.RebindSafeMBeanServer.registerMBean",
	"Comment": "delegates to the wrapped mbean server, but if a mbean is already registeredwith the specified name, the existing instance is returned.",
	"Method": "ObjectInstance registerMBean(Object object,ObjectName name){\r\n    while (true) {\r\n        try {\r\n            return mbeanServer.registerMBean(object, name);\r\n        } catch (InstanceAlreadyExistsException ignored) {\r\n        }\r\n        try {\r\n            ObjectInstance objectInstance = mbeanServer.getObjectInstance(name);\r\n            log.debug(\"%s already bound to %s\", name, objectInstance);\r\n            return objectInstance;\r\n        } catch (InstanceNotFoundException ignored) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.ObjectChangeSetTests.changeDifferentFieldOneAfterAnother",
	"Comment": "contains an invalid local ref which has been released before.",
	"Method": "void changeDifferentFieldOneAfterAnother(){\r\n    Realm realm = looperThread.getRealm();\r\n    AllTypes allTypes = realm.where(AllTypes.class).findFirst();\r\n    final AtomicBoolean stringChanged = new AtomicBoolean(false);\r\n    final AtomicBoolean longChanged = new AtomicBoolean(false);\r\n    final AtomicBoolean floatChanged = new AtomicBoolean(false);\r\n    allTypes.addChangeListener(new RealmObjectChangeListener<RealmModel>() {\r\n        @Override\r\n        public void onChange(RealmModel object, ObjectChangeSet changeSet) {\r\n            assertEquals(1, changeSet.getChangedFields().length);\r\n            if (changeSet.isFieldChanged(AllTypes.FIELD_STRING)) {\r\n                assertFalse(stringChanged.get());\r\n                stringChanged.set(true);\r\n            } else if (changeSet.isFieldChanged(AllTypes.FIELD_LONG)) {\r\n                assertFalse(longChanged.get());\r\n                longChanged.set(true);\r\n            } else if (changeSet.isFieldChanged(AllTypes.FIELD_FLOAT)) {\r\n                assertTrue(stringChanged.get());\r\n                assertTrue(longChanged.get());\r\n                assertFalse(floatChanged.get());\r\n                floatChanged.set(true);\r\n                looperThread.testComplete();\r\n            } else {\r\n                fail();\r\n            }\r\n        }\r\n    });\r\n    realm.beginTransaction();\r\n    allTypes.setColumnString(\"42\");\r\n    realm.commitTransaction();\r\n    realm.beginTransaction();\r\n    allTypes.setColumnLong(42);\r\n    realm.commitTransaction();\r\n    realm.beginTransaction();\r\n    allTypes.setColumnFloat(42.0f);\r\n    realm.commitTransaction();\r\n}"
}, {
	"Path": "io.realm.ObjectChangeSetTests.changeDifferentFieldOneAfterAnother",
	"Comment": "contains an invalid local ref which has been released before.",
	"Method": "void changeDifferentFieldOneAfterAnother(){\r\n    assertEquals(1, changeSet.getChangedFields().length);\r\n    if (changeSet.isFieldChanged(AllTypes.FIELD_STRING)) {\r\n        assertFalse(stringChanged.get());\r\n        stringChanged.set(true);\r\n    } else if (changeSet.isFieldChanged(AllTypes.FIELD_LONG)) {\r\n        assertFalse(longChanged.get());\r\n        longChanged.set(true);\r\n    } else if (changeSet.isFieldChanged(AllTypes.FIELD_FLOAT)) {\r\n        assertTrue(stringChanged.get());\r\n        assertTrue(longChanged.get());\r\n        assertFalse(floatChanged.get());\r\n        floatChanged.set(true);\r\n        looperThread.testComplete();\r\n    } else {\r\n        fail();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.operator.SortedPositionLinks.lowerBound",
	"Comment": "find the first element in position links that is not smaller than probeposition",
	"Method": "int lowerBound(JoinFilterFunction searchFunction,int[] links,int first,int last,int probePosition,Page allProbeChannelsPage){\r\n    int middle;\r\n    int step;\r\n    int count = last - first;\r\n    while (count > 0) {\r\n        step = count / 2;\r\n        middle = first + step;\r\n        if (!applySearchFunction(searchFunction, links, middle, probePosition, allProbeChannelsPage)) {\r\n            first = ++middle;\r\n            count -= step + 1;\r\n        } else {\r\n            count = step;\r\n        }\r\n    }\r\n    return first;\r\n}"
}, {
	"Path": "io.realm.internal.objectserver.Token.expiresMs",
	"Comment": "returns when this token expires. timestamp is in utc milliseconds.",
	"Method": "long expiresMs(){\r\n    long expiresMs = expiresSec * 1000;\r\n    if (expiresMs < expiresSec) {\r\n        return Long.MAX_VALUE;\r\n    } else {\r\n        return expiresMs;\r\n    }\r\n}"
}, {
	"Path": "org.redisson.config.BaseConfig.setConnectTimeout",
	"Comment": "timeout during connecting to any redis server.default is 10000 milliseconds.",
	"Method": "T setConnectTimeout(int connectTimeout){\r\n    this.connectTimeout = connectTimeout;\r\n    return (T) this;\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.notSettingRequiredForNotNullableThrows",
	"Comment": "if a required field was nullable before, a realmmigrationneededexception should be thrown.",
	"Method": "void notSettingRequiredForNotNullableThrows(){\r\n    String[] notNullableFields = { NullTypes.FIELD_STRING_NOT_NULL, NullTypes.FIELD_BYTES_NOT_NULL, NullTypes.FIELD_BOOLEAN_NOT_NULL, NullTypes.FIELD_BYTE_NOT_NULL, NullTypes.FIELD_SHORT_NOT_NULL, NullTypes.FIELD_INTEGER_NOT_NULL, NullTypes.FIELD_LONG_NOT_NULL, NullTypes.FIELD_FLOAT_NOT_NULL, NullTypes.FIELD_DOUBLE_NOT_NULL, NullTypes.FIELD_DATE_NOT_NULL };\r\n    for (final String field : notNullableFields) {\r\n        final RealmMigration migration = new RealmMigration() {\r\n            @Override\r\n            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {\r\n                if (oldVersion == 0) {\r\n                    RealmObjectSchema nullTypesSchema = realm.getSchema().get(NullTypes.CLASS_NAME);\r\n                    if (field.equals(NullTypes.FIELD_STRING_NOT_NULL)) {\r\n                        nullTypesSchema.addField(field, String.class);\r\n                    } else if (field.equals(NullTypes.FIELD_BYTES_NOT_NULL)) {\r\n                        nullTypesSchema.addField(field, byte[].class);\r\n                    } else if (field.equals(NullTypes.FIELD_BOOLEAN_NOT_NULL)) {\r\n                        nullTypesSchema.addField(field, Boolean.class);\r\n                    } else if (field.equals(NullTypes.FIELD_BYTE_NOT_NULL) || field.equals(NullTypes.FIELD_SHORT_NOT_NULL) || field.equals(NullTypes.FIELD_INTEGER_NOT_NULL) || field.equals(NullTypes.FIELD_LONG_NOT_NULL)) {\r\n                        nullTypesSchema.addField(field, Integer.class);\r\n                    } else if (field.equals(NullTypes.FIELD_FLOAT_NOT_NULL)) {\r\n                        nullTypesSchema.addField(field, Float.class);\r\n                    } else if (field.equals(NullTypes.FIELD_DOUBLE_NOT_NULL)) {\r\n                        nullTypesSchema.addField(field, Double.class);\r\n                    } else if (field.equals(NullTypes.FIELD_DATE_NOT_NULL)) {\r\n                        nullTypesSchema.addField(field, Date.class);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        @SuppressWarnings(\"unchecked\")\r\n        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder().schemaVersion(1).name(field).schema(NullTypes.class).migration(migration).build();\r\n        Realm.deleteRealm(realmConfig);\r\n        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realmConfig);\r\n        TestHelper.initNullTypesTableExcludes(dynamicRealm, field);\r\n        dynamicRealm.close();\r\n        try {\r\n            realm = Realm.getInstance(realmConfig);\r\n            fail(\"Failed on \" + field);\r\n        } catch (RealmMigrationNeededException e) {\r\n            assertThat(e.getMessage(), CoreMatchers.containsString(String.format(Locale.US, \"Property 'NullTypes.%s' has been made required\", field)));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.notSettingRequiredForNotNullableThrows",
	"Comment": "if a required field was nullable before, a realmmigrationneededexception should be thrown.",
	"Method": "void notSettingRequiredForNotNullableThrows(){\r\n    if (oldVersion == 0) {\r\n        RealmObjectSchema nullTypesSchema = realm.getSchema().get(NullTypes.CLASS_NAME);\r\n        if (field.equals(NullTypes.FIELD_STRING_NOT_NULL)) {\r\n            nullTypesSchema.addField(field, String.class);\r\n        } else if (field.equals(NullTypes.FIELD_BYTES_NOT_NULL)) {\r\n            nullTypesSchema.addField(field, byte[].class);\r\n        } else if (field.equals(NullTypes.FIELD_BOOLEAN_NOT_NULL)) {\r\n            nullTypesSchema.addField(field, Boolean.class);\r\n        } else if (field.equals(NullTypes.FIELD_BYTE_NOT_NULL) || field.equals(NullTypes.FIELD_SHORT_NOT_NULL) || field.equals(NullTypes.FIELD_INTEGER_NOT_NULL) || field.equals(NullTypes.FIELD_LONG_NOT_NULL)) {\r\n            nullTypesSchema.addField(field, Integer.class);\r\n        } else if (field.equals(NullTypes.FIELD_FLOAT_NOT_NULL)) {\r\n            nullTypesSchema.addField(field, Float.class);\r\n        } else if (field.equals(NullTypes.FIELD_DOUBLE_NOT_NULL)) {\r\n            nullTypesSchema.addField(field, Double.class);\r\n        } else if (field.equals(NullTypes.FIELD_DATE_NOT_NULL)) {\r\n            nullTypesSchema.addField(field, Date.class);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.PermissionManager.acceptOffer",
	"Comment": "accepts a permission offer sent by another user. once this offer is accepted successfully, the permissionsdescribed by the token will be granted.",
	"Method": "RealmAsyncTask acceptOffer(String offerToken,AcceptOfferCallback callback){\r\n    checkIfValid();\r\n    checkCallbackNotNull(callback);\r\n    if (Util.isEmptyString(offerToken)) {\r\n        throw new IllegalArgumentException(\"Non-empty 'offerToken' required.\");\r\n    }\r\n    return addTask(new AcceptOfferAsyncTask(this, offerToken, callback));\r\n}"
}, {
	"Path": "io.realm.internal.objectstore.OsObjectBuilder.updateExistingObject",
	"Comment": "updates any existing object if it exists, otherwise creates a new one.the builder is automatically closed after calling this method.",
	"Method": "void updateExistingObject(){\r\n    try {\r\n        nativeCreateOrUpdate(sharedRealmPtr, tablePtr, builderPtr, true, ignoreFieldsWithSameValue);\r\n    } finally {\r\n        close();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.sql.planner.iterative.Lookup.resolve",
	"Comment": "resolves a node by materializing groupreference nodesrepresenting symbolic references to other nodes. this methodis deprecated since is assumes group contains only one node.if the node is not a groupreference, it returns theargument as is.",
	"Method": "PlanNode resolve(PlanNode node){\r\n    if (node instanceof GroupReference) {\r\n        return resolveGroup(node).collect(toOptional()).get();\r\n    }\r\n    return node;\r\n}"
}, {
	"Path": "io.realm.SyncUser.getManagementRealmUrl",
	"Comment": "creates the url to the permission realm based on the authentication url.",
	"Method": "String getManagementRealmUrl(URL authUrl){\r\n    String scheme = \"realm\";\r\n    if (authUrl.getProtocol().equalsIgnoreCase(\"https\")) {\r\n        scheme = \"realms\";\r\n    }\r\n    try {\r\n        return new URI(scheme, authUrl.getUserInfo(), authUrl.getHost(), authUrl.getPort(), \"/~/__management\", null, null).toString();\r\n    } catch (URISyntaxException e) {\r\n        throw new IllegalArgumentException(\"Could not create URL to the management Realm\", e);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spi.block.ArrayBlock.createArrayBlockInternal",
	"Comment": "create an array block directly without per element validations.",
	"Method": "ArrayBlock createArrayBlockInternal(int arrayOffset,int positionCount,boolean[] valueIsNull,int[] offsets,Block values){\r\n    validateConstructorArguments(arrayOffset, positionCount, valueIsNull, offsets, values);\r\n    return new ArrayBlock(arrayOffset, positionCount, valueIsNull, offsets, values);\r\n}"
}, {
	"Path": "io.realm.instrumentation.MockActivityManager.onStop",
	"Comment": "call onstop on the activity, this help closing any open open realm",
	"Method": "void onStop(){\r\n    instance.onStop();\r\n}"
}, {
	"Path": "io.realm.OrderedCollectionChangeSetTests.initialChangeSet_findAll",
	"Comment": "the change set should be empty when the async query returns at the first time.",
	"Method": "void initialChangeSet_findAll(){\r\n    if (type == ObservablesType.REALM_LIST) {\r\n        looperThread.testComplete();\r\n        return;\r\n    }\r\n    Realm realm = looperThread.getRealm();\r\n    populateData(realm, 10);\r\n    final RealmResults<Dog> results = realm.where(Dog.class).sort(Dog.FIELD_AGE).findAll();\r\n    looperThread.keepStrongReference(results);\r\n    results.addChangeListener((collection, changeSet) -> {\r\n        assertSame(collection, results);\r\n        assertEquals(11, collection.size());\r\n        assertTrue(changeSet.isCompleteResult());\r\n        assertEquals(OrderedCollectionChangeSet.State.UPDATE, changeSet.getState());\r\n        assertEquals(1, changeSet.getInsertions().length);\r\n        looperThread.testComplete();\r\n    });\r\n    realm.executeTransaction(r -> {\r\n        r.createObject(Dog.class);\r\n    });\r\n}"
}, {
	"Path": "com.facebook.presto.sql.planner.iterative.rule.AddIntermediateAggregations.recurseToPartial",
	"Comment": "recurse through a series of preceding exchangenodes and projectnodes to find the preceding partial aggregation",
	"Method": "Optional<PlanNode> recurseToPartial(PlanNode node,Lookup lookup,PlanNodeIdAllocator idAllocator){\r\n    if (node instanceof AggregationNode && ((AggregationNode) node).getStep() == AggregationNode.Step.PARTIAL) {\r\n        return Optional.of(addGatheringIntermediate((AggregationNode) node, idAllocator));\r\n    }\r\n    if (!(node instanceof ExchangeNode) && !(node instanceof ProjectNode)) {\r\n        return Optional.empty();\r\n    }\r\n    ImmutableList.Builder<PlanNode> builder = ImmutableList.builder();\r\n    for (PlanNode source : node.getSources()) {\r\n        Optional<PlanNode> planNode = recurseToPartial(lookup.resolve(source), lookup, idAllocator);\r\n        if (!planNode.isPresent()) {\r\n            return Optional.empty();\r\n        }\r\n        builder.add(planNode.get());\r\n    }\r\n    return Optional.of(node.replaceChildren(builder.build()));\r\n}"
}, {
	"Path": "io.realm.internal.OsObject.createWithPrimaryKey",
	"Comment": "create an object in the given table which has a primary key column defined, and set the primary key with givenvalue.",
	"Method": "UncheckedRow createWithPrimaryKey(Table table,Object primaryKeyValue){\r\n    long primaryKeyColumnIndex = getAndVerifyPrimaryKeyColumnIndex(table);\r\n    RealmFieldType type = table.getColumnType(primaryKeyColumnIndex);\r\n    final OsSharedRealm sharedRealm = table.getSharedRealm();\r\n    if (type == RealmFieldType.STRING) {\r\n        if (primaryKeyValue != null && !(primaryKeyValue instanceof String)) {\r\n            throw new IllegalArgumentException(\"Primary key value is not a String: \" + primaryKeyValue);\r\n        }\r\n        return new UncheckedRow(sharedRealm.context, table, nativeCreateNewObjectWithStringPrimaryKey(sharedRealm.getNativePtr(), table.getNativePtr(), primaryKeyColumnIndex, (String) primaryKeyValue));\r\n    } else if (type == RealmFieldType.INTEGER) {\r\n        long value = primaryKeyValue == null ? 0 : Long.parseLong(primaryKeyValue.toString());\r\n        return new UncheckedRow(sharedRealm.context, table, nativeCreateNewObjectWithLongPrimaryKey(sharedRealm.getNativePtr(), table.getNativePtr(), primaryKeyColumnIndex, value, primaryKeyValue == null));\r\n    } else {\r\n        throw new RealmException(\"Cannot check for duplicate rows for unsupported primary key type: \" + type);\r\n    }\r\n}"
}, {
	"Path": "io.realm.SyncManager.sslVerifyCallback",
	"Comment": "the underlying java api we need to call to validate the certificate chain.",
	"Method": "boolean sslVerifyCallback(String serverAddress,String pemData,int depth){\r\n    try {\r\n        if (ROS_CERTIFICATES_CHAIN == null) {\r\n            ROS_CERTIFICATES_CHAIN = new HashMap();\r\n            TRUST_MANAGER = systemDefaultTrustManager();\r\n            CERTIFICATE_FACTORY = CertificateFactory.getInstance(\"X.509\");\r\n        }\r\n        if (!ROS_CERTIFICATES_CHAIN.containsKey(serverAddress)) {\r\n            ROS_CERTIFICATES_CHAIN.put(serverAddress, new ArrayList<String>());\r\n        }\r\n        ROS_CERTIFICATES_CHAIN.get(serverAddress).add(pemData);\r\n        if (depth == 0) {\r\n            List<String> pemChain = ROS_CERTIFICATES_CHAIN.get(serverAddress);\r\n            int n = pemChain.size();\r\n            X509Certificate[] chain = new X509Certificate[n];\r\n            for (String pem : pemChain) {\r\n                chain[--n] = buildCertificateFromPEM(pem);\r\n            }\r\n            try {\r\n                TRUST_MANAGER.checkClientTrusted(chain, \"RSA\");\r\n                boolean isValid = OkHostnameVerifier.INSTANCE.verify(serverAddress, chain[0]);\r\n                if (isValid) {\r\n                    return true;\r\n                } else {\r\n                    RealmLog.error(\"Can not verify the hostname for the host: \" + serverAddress);\r\n                    return false;\r\n                }\r\n            } catch (CertificateException e) {\r\n                RealmLog.error(e, \"Can not validate SSL chain certificate for the host: \" + serverAddress);\r\n                return false;\r\n            } finally {\r\n                ROS_CERTIFICATES_CHAIN.remove(serverAddress);\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    } catch (Exception e) {\r\n        RealmLog.error(e, \"Error during certificate validation for host: \" + serverAddress);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorMetadata.grantTablePrivileges",
	"Comment": "grants the specified privilege to the specified user on the specified table",
	"Method": "void grantTablePrivileges(ConnectorSession session,SchemaTableName tableName,Set<Privilege> privileges,String grantee,boolean grantOption){\r\n    throw new PrestoException(NOT_SUPPORTED, \"This connector does not support grants\");\r\n}"
}, {
	"Path": "io.realm.SyncedRealmMigrationTests.breakingSchemaChange_throws",
	"Comment": "check that a realm cannot be opened if it contain breaking schema changes, like changing a primary key",
	"Method": "void breakingSchemaChange_throws(){\r\n    SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), \"http://foo.com/auth\").schema(PrimaryKeyAsString.class).build();\r\n    OsObjectSchemaInfo expectedObjectSchema = new OsObjectSchemaInfo.Builder(PrimaryKeyAsString.CLASS_NAME, 2, 0).addPersistedProperty(PrimaryKeyAsString.FIELD_PRIMARY_KEY, RealmFieldType.STRING, false, true, false).addPersistedProperty(PrimaryKeyAsString.FIELD_ID, RealmFieldType.INTEGER, true, true, true).build();\r\n    List<OsObjectSchemaInfo> list = new ArrayList<OsObjectSchemaInfo>();\r\n    list.add(expectedObjectSchema);\r\n    OsSchemaInfo schemaInfo = new OsSchemaInfo(list);\r\n    OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(config).schemaInfo(schemaInfo);\r\n    OsSharedRealm.getInstance(configBuilder).close();\r\n    thrown.expectMessage(CoreMatchers.containsString(\"The following changes cannot be made in additive-only schema mode:\"));\r\n    thrown.expect(IllegalStateException.class);\r\n    Realm.getInstance(config);\r\n}"
}, {
	"Path": "io.realm.RealmConfiguration.getCompactOnLaunchCallback",
	"Comment": "returns a callback to determine if the realm file should be compacted before being returned to the user.",
	"Method": "CompactOnLaunchCallback getCompactOnLaunchCallback(){\r\n    return compactOnLaunch;\r\n}"
}, {
	"Path": "io.realm.rule.RunInLooperThread.isRuleUsed",
	"Comment": "returns true if the current test being run is using this rule.",
	"Method": "boolean isRuleUsed(){\r\n    return ruleBeingUsed;\r\n}"
}, {
	"Path": "com.facebook.presto.sql.analyzer.RelationType.withAlias",
	"Comment": "creates a new tuple descriptor with the relation, and, optionally, the columns aliased.",
	"Method": "RelationType withAlias(String relationAlias,List<String> columnAliases){\r\n    if (columnAliases != null) {\r\n        checkArgument(columnAliases.size() == visibleFields.size(), \"Column alias list has %s entries but '%s' has %s columns available\", columnAliases.size(), relationAlias, visibleFields.size());\r\n    }\r\n    ImmutableList.Builder<Field> fieldsBuilder = ImmutableList.builder();\r\n    for (int i = 0; i < allFields.size(); i++) {\r\n        Field field = allFields.get(i);\r\n        Optional<String> columnAlias = field.getName();\r\n        if (columnAliases == null) {\r\n            fieldsBuilder.add(Field.newQualified(QualifiedName.of(relationAlias), columnAlias, field.getType(), field.isHidden(), field.getOriginTable(), field.getOriginColumnName(), field.isAliased()));\r\n        } else if (!field.isHidden()) {\r\n            columnAlias = Optional.of(columnAliases.get(i));\r\n            fieldsBuilder.add(Field.newQualified(QualifiedName.of(relationAlias), columnAlias, field.getType(), false, field.getOriginTable(), field.getOriginColumnName(), field.isAliased()));\r\n        }\r\n    }\r\n    return new RelationType(fieldsBuilder.build());\r\n}"
}, {
	"Path": "io.realm.ManagedRealmCollectionTests.aggregates_deleteLastRow",
	"Comment": "aggregates methods ignore the invalid rows and return the correct result.",
	"Method": "void aggregates_deleteLastRow(){\r\n    assertTrue(TEST_SIZE > 3);\r\n    assertEquals(TEST_SIZE, collection.size());\r\n    realm.beginTransaction();\r\n    realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, TEST_SIZE - 1).findFirst().deleteFromRealm();\r\n    realm.commitTransaction();\r\n    int sizeAfterRemove = TEST_SIZE - 1;\r\n    assertEquals(0, collection.min(AllJavaTypes.FIELD_LONG).intValue());\r\n    assertEquals(sizeAfterRemove - 1, collection.max(AllJavaTypes.FIELD_LONG).intValue());\r\n    assertEquals((sizeAfterRemove - 1) * sizeAfterRemove / 2, collection.sum(AllJavaTypes.FIELD_LONG).intValue());\r\n    double average = Math.PI + (sizeAfterRemove - 1.0) * 0.5;\r\n    assertEquals(average, collection.average(AllJavaTypes.FIELD_DOUBLE), 0.0001);\r\n    assertEquals(new Date(YEAR_MILLIS * 20 * (sizeAfterRemove / 2 - 1)), collection.maxDate(AllJavaTypes.FIELD_DATE));\r\n    assertEquals(new Date(-YEAR_MILLIS * 20 * TEST_SIZE / 2), collection.minDate(AllJavaTypes.FIELD_DATE));\r\n}"
}, {
	"Path": "io.realm.Realm.getGlobalInstanceCount",
	"Comment": "returns the current number of open realm instances across all threads in current process that are using thisconfiguration. this includes both dynamic and normal realms.",
	"Method": "int getGlobalInstanceCount(RealmConfiguration configuration){\r\n    final AtomicInteger globalCount = new AtomicInteger(0);\r\n    RealmCache.invokeWithGlobalRefCount(configuration, new RealmCache.Callback() {\r\n        @Override\r\n        public void onResult(int count) {\r\n            globalCount.set(count);\r\n        }\r\n    });\r\n    return globalCount.get();\r\n}"
}, {
	"Path": "io.realm.Realm.getGlobalInstanceCount",
	"Comment": "returns the current number of open realm instances across all threads in current process that are using thisconfiguration. this includes both dynamic and normal realms.",
	"Method": "int getGlobalInstanceCount(RealmConfiguration configuration){\r\n    globalCount.set(count);\r\n}"
}, {
	"Path": "io.realm.processor.RealmNameTest.compareProcessedDefaultClassFile",
	"Comment": "check the effect of module default on a class with no settings itself",
	"Method": "void compareProcessedDefaultClassFile(){\r\n    ASSERT.about(javaSources()).that(Arrays.asList(JavaFileObjects.forResource(\"some/test/NamePolicyModule.java\"), JavaFileObjects.forResource(\"some/test/NamePolicyModuleDefaults.java\"))).processedWith(new RealmProcessor()).compilesWithoutError().and().generatesSources(JavaFileObjects.forResource(\"io/realm/some_test_NamePolicyModuleDefaultsRealmProxy.java\"));\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.systemShouldAdvance",
	"Comment": "check if this spring should be advanced by the system. the rule is if the spring iscurrently at rest and it was at rest in the previous advance, the system can skip this spring",
	"Method": "boolean systemShouldAdvance(){\r\n    return !isAtRest() || !wasAtRest();\r\n}"
}, {
	"Path": "com.facebook.presto.sql.planner.SubPlan.getAllFragments",
	"Comment": "flattens the subplan and returns all planfragments in the tree",
	"Method": "List<PlanFragment> getAllFragments(){\r\n    ImmutableList.Builder<PlanFragment> fragments = ImmutableList.builder();\r\n    fragments.add(getFragment());\r\n    for (SubPlan child : getChildren()) {\r\n        fragments.addAll(child.getAllFragments());\r\n    }\r\n    return fragments.build();\r\n}"
}, {
	"Path": "io.realm.OrderedRealmCollectionSnapshot.deleteFromRealm",
	"Comment": "deletes the object at the given index from the realm. the object at the given index will become invalid. justreturns if the object is invalid already.",
	"Method": "void deleteFromRealm(int location){\r\n    realm.checkIfValidAndInTransaction();\r\n    UncheckedRow row = osResults.getUncheckedRow(location);\r\n    if (row.isAttached()) {\r\n        osResults.delete(location);\r\n    }\r\n}"
}, {
	"Path": "io.realm.MutableRealmObjectSchema.getColumnIndices",
	"Comment": "returns a field descriptor based on the internal field names found in the realm file.",
	"Method": "FieldDescriptor getColumnIndices(String internalColumnNameDescription,RealmFieldType validColumnTypes){\r\n    return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), internalColumnNameDescription, validColumnTypes);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.predicate.TupleDomain.overlaps",
	"Comment": "returns true only if there exists a strict intersection between the tupledomains.i.e. there exists some potential tuple that would be allowable in both tupledomains.",
	"Method": "boolean overlaps(TupleDomain<T> other){\r\n    return !this.intersect(other).isNone();\r\n}"
}, {
	"Path": "io.realm.examples.securetokenandroidkeystore.MainActivity.buildSyncConf",
	"Comment": "build syncconfiguration with a user store to store encrypted token.",
	"Method": "void buildSyncConf(){\r\n    SyncCredentials credentials = SyncCredentials.usernamePassword(\"username\", \"password\");\r\n    final String urlAuth = \"http://objectserver.realm.io:9080/auth\";\r\n    final String url = \"realm://objectserver.realm.io/default\";\r\n    SyncUser.logInAsync(credentials, urlAuth, new SyncUser.Callback<SyncUser>() {\r\n        @Override\r\n        public void onSuccess(SyncUser user) {\r\n            SyncConfiguration secureConfig = new SyncConfiguration.Builder(user, url).build();\r\n            Realm realm = Realm.getInstance(secureConfig);\r\n        }\r\n        @Override\r\n        public void onError(ObjectServerError error) {\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.realm.examples.securetokenandroidkeystore.MainActivity.buildSyncConf",
	"Comment": "build syncconfiguration with a user store to store encrypted token.",
	"Method": "void buildSyncConf(){\r\n    SyncConfiguration secureConfig = new SyncConfiguration.Builder(user, url).build();\r\n    Realm realm = Realm.getInstance(secureConfig);\r\n}"
}, {
	"Path": "io.realm.examples.securetokenandroidkeystore.MainActivity.buildSyncConf",
	"Comment": "build syncconfiguration with a user store to store encrypted token.",
	"Method": "void buildSyncConf(){\r\n}"
}, {
	"Path": "org.redisson.executor.CronExpression.setCalendarHour",
	"Comment": "advance the calendar to the particular hour paying particular attentionto daylight saving problems.",
	"Method": "void setCalendarHour(Calendar cal,int hour){\r\n    cal.set(java.util.Calendar.HOUR_OF_DAY, hour);\r\n    if (cal.get(java.util.Calendar.HOUR_OF_DAY) != hour && hour != 24) {\r\n        cal.set(java.util.Calendar.HOUR_OF_DAY, hour + 1);\r\n    }\r\n}"
}, {
	"Path": "io.realm.internal.Table.hasSameSchema",
	"Comment": "compares the schema of the current instance of table with another instance.",
	"Method": "boolean hasSameSchema(Table table){\r\n    if (table == null) {\r\n        throw new IllegalArgumentException(\"The argument cannot be null\");\r\n    }\r\n    return nativeHasSameSchema(this.nativePtr, table.nativePtr);\r\n}"
}, {
	"Path": "com.facebook.rebound.AnimationQueue.addAllValues",
	"Comment": "add a collection of values to the pending animation value queue",
	"Method": "void addAllValues(Collection<Double> values){\r\n    mPendingQueue.addAll(values);\r\n    runIfIdle();\r\n}"
}, {
	"Path": "io.realm.OrderedRealmCollectionImpl.deleteLastFromRealm",
	"Comment": "removes the last object in the list. this also deletes the object from the underlying realm.",
	"Method": "boolean deleteLastFromRealm(){\r\n    realm.checkIfValidAndInTransaction();\r\n    return osResults.deleteLast();\r\n}"
}, {
	"Path": "io.realm.internal.CheckedRow.setNull",
	"Comment": "sets null to a row pointer with checking if a column is nullable, except when the column typeis binary.",
	"Method": "void setNull(long columnIndex){\r\n    RealmFieldType columnType = getColumnType(columnIndex);\r\n    if (columnType == RealmFieldType.BINARY) {\r\n        super.setBinaryByteArray(columnIndex, null);\r\n    } else {\r\n        super.setNull(columnIndex);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.rebound.playground.examples.scrollview.SpringScrollView.findFocusableViewInBounds",
	"Comment": "finds the next focusable component that fits in the specified bounds.",
	"Method": "View findFocusableViewInBounds(boolean topFocus,int top,int bottom){\r\n    List<View> focusables = getFocusables(View.FOCUS_FORWARD);\r\n    View focusCandidate = null;\r\n    boolean foundFullyContainedFocusable = false;\r\n    int count = focusables.size();\r\n    for (int i = 0; i < count; i++) {\r\n        View view = focusables.get(i);\r\n        int viewTop = view.getTop();\r\n        int viewBottom = view.getBottom();\r\n        if (top < viewBottom && viewTop < bottom) {\r\n            final boolean viewIsFullyContained = (top < viewTop) && (viewBottom < bottom);\r\n            if (focusCandidate == null) {\r\n                focusCandidate = view;\r\n                foundFullyContainedFocusable = viewIsFullyContained;\r\n            } else {\r\n                final boolean viewIsCloserToBoundary = (topFocus && viewTop < focusCandidate.getTop()) || (!topFocus && viewBottom > focusCandidate.getBottom());\r\n                if (foundFullyContainedFocusable) {\r\n                    if (viewIsFullyContained && viewIsCloserToBoundary) {\r\n                        focusCandidate = view;\r\n                    }\r\n                } else {\r\n                    if (viewIsFullyContained) {\r\n                        focusCandidate = view;\r\n                        foundFullyContainedFocusable = true;\r\n                    } else if (viewIsCloserToBoundary) {\r\n                        focusCandidate = view;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return focusCandidate;\r\n}"
}, {
	"Path": "com.facebook.presto.sql.tree.ExpressionTreeRewriter.defaultRewrite",
	"Comment": "invoke the default rewrite logic explicitly. specifically, it skips the invocation of the expression rewriter for the provided node.",
	"Method": "T defaultRewrite(T node,C context){\r\n    return (T) visitor.process(node, new Context(context, true));\r\n}"
}, {
	"Path": "io.realm.BaseRealm.compactRealm",
	"Comment": "compacts the realm file defined by the given configuration.",
	"Method": "boolean compactRealm(RealmConfiguration configuration){\r\n    OsSharedRealm sharedRealm = OsSharedRealm.getInstance(configuration);\r\n    Boolean result = sharedRealm.compact();\r\n    sharedRealm.close();\r\n    return result;\r\n}"
}, {
	"Path": "com.facebook.presto.sql.planner.plan.TableScanNode.getCurrentConstraint",
	"Comment": "a tupledomain that represents a predicate that every row this tablescan nodeproduces is guaranteed to satisfy.this guarantee can have different origins.for example, it may be successful predicate push down, or inherent guarantee provided by the underlying data.",
	"Method": "TupleDomain<ColumnHandle> getCurrentConstraint(){\r\n    checkState(currentConstraint != null, \"currentConstraint should only be used in planner. It is not transported to workers.\");\r\n    return currentConstraint;\r\n}"
}, {
	"Path": "com.facebook.presto.resourceGroups.ResourceGroupSpec.sameConfig",
	"Comment": "subgroups not included, used to determine whether a group needs to be reconfigured",
	"Method": "boolean sameConfig(ResourceGroupSpec other){\r\n    if (other == null) {\r\n        return false;\r\n    }\r\n    return (name.equals(other.name) && softMemoryLimit.equals(other.softMemoryLimit) && maxQueued == other.maxQueued && softConcurrencyLimit.equals(other.softConcurrencyLimit) && hardConcurrencyLimit == other.hardConcurrencyLimit && schedulingPolicy.equals(other.schedulingPolicy) && schedulingWeight.equals(other.schedulingWeight) && jmxExport.equals(other.jmxExport) && softCpuLimit.equals(other.softCpuLimit) && hardCpuLimit.equals(other.hardCpuLimit));\r\n}"
}, {
	"Path": "io.realm.internal.RealmNotifier.willSendNotifications",
	"Comment": "realm version. this will be triggered even if no change listeners are registered.",
	"Method": "void willSendNotifications(){\r\n    for (int i = 0; i < startSendingNotificationsCallbacks.size(); i++) {\r\n        startSendingNotificationsCallbacks.get(i).run();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.sql.planner.EqualityInference.getCanonical",
	"Comment": "returns the most preferrable expression to be used as the canonical expression",
	"Method": "Expression getCanonical(Iterable<Expression> expressions){\r\n    if (Iterables.isEmpty(expressions)) {\r\n        return null;\r\n    }\r\n    return CANONICAL_ORDERING.min(expressions);\r\n}"
}, {
	"Path": "io.realm.OrderedCollectionChangeSetTests.changes_then_delete",
	"Comment": "change some objects then delete them. only deletion changes should be sent.",
	"Method": "void changes_then_delete(){\r\n    Realm realm = looperThread.getRealm();\r\n    populateData(realm, 10);\r\n    ChangesCheck changesCheck = new ChangesCheck() {\r\n        @Override\r\n        public void check(OrderedCollectionChangeSet changeSet) {\r\n            checkRanges(changeSet.getDeletionRanges(), 0, 2, 5, 1);\r\n            assertArrayEquals(changeSet.getDeletions(), new int[] { 0, 1, 5 });\r\n            assertEquals(0, changeSet.getInsertionRanges().length);\r\n            assertEquals(0, changeSet.getInsertions().length);\r\n            assertEquals(0, changeSet.getChangeRanges().length);\r\n            assertEquals(0, changeSet.getChanges().length);\r\n            looperThread.testComplete();\r\n        }\r\n    };\r\n    registerCheckListener(realm, changesCheck);\r\n    realm.beginTransaction();\r\n    modifyObjects(realm, 0, 1, 5);\r\n    deleteObjects(realm, 0, 1, 5);\r\n    realm.commitTransaction();\r\n}"
}, {
	"Path": "io.realm.OrderedCollectionChangeSetTests.changes_then_delete",
	"Comment": "change some objects then delete them. only deletion changes should be sent.",
	"Method": "void changes_then_delete(){\r\n    checkRanges(changeSet.getDeletionRanges(), 0, 2, 5, 1);\r\n    assertArrayEquals(changeSet.getDeletions(), new int[] { 0, 1, 5 });\r\n    assertEquals(0, changeSet.getInsertionRanges().length);\r\n    assertEquals(0, changeSet.getInsertions().length);\r\n    assertEquals(0, changeSet.getChangeRanges().length);\r\n    assertEquals(0, changeSet.getChanges().length);\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanDropSchema",
	"Comment": "check if identity is allowed to drop the specified schema in this catalog.",
	"Method": "void checkCanDropSchema(ConnectorTransactionHandle transactionHandle,Identity identity,String schemaName){\r\n    denyDropSchema(schemaName);\r\n}"
}, {
	"Path": "io.realm.permissions.PermissionOffer.isOfferCreated",
	"Comment": "checks if the request was successfully handled by the realm object server.",
	"Method": "boolean isOfferCreated(){\r\n    return !Util.isEmptyString(token);\r\n}"
}, {
	"Path": "io.realm.SyncCredentials.getIdentityProvider",
	"Comment": "returns the provider used by the object server to validate these credentials.",
	"Method": "String getIdentityProvider(){\r\n    return identityProvider;\r\n}"
}, {
	"Path": "io.realm.MutableRealmIntegerTests.compareTo_unmanaged",
	"Comment": "be absolutely certain that we can actually compare two longs.",
	"Method": "void compareTo_unmanaged(){\r\n    MutableRealmInteger ri1 = MutableRealmInteger.valueOf(0);\r\n    MutableRealmInteger ri2 = MutableRealmInteger.valueOf(Long.MAX_VALUE);\r\n    assertEquals(-1, ri1.compareTo(ri2));\r\n    ri2.decrement(Long.MAX_VALUE);\r\n    assertEquals(0, ri1.compareTo(ri2));\r\n    ri2.decrement(Long.MAX_VALUE);\r\n    assertEquals(1, ri1.compareTo(ri2));\r\n}"
}, {
	"Path": "com.facebook.presto.operator.TaskContext.initialize",
	"Comment": "another thread, which will cause unsafe publication of this instance.",
	"Method": "void initialize(){\r\n    taskStateMachine.addStateChangeListener(this::updateStatsIfDone);\r\n}"
}, {
	"Path": "com.facebook.presto.orc.TupleDomainOrcPredicate.checkInBloomFilter",
	"Comment": "checks whether a value part of the effective predicate is likely to be part of this bloom filter",
	"Method": "boolean checkInBloomFilter(BloomFilter bloomFilter,Object predicateValue,Type sqlType){\r\n    if (sqlType == TINYINT || sqlType == SMALLINT || sqlType == INTEGER || sqlType == BIGINT) {\r\n        return bloomFilter.testLong(((Number) predicateValue).longValue());\r\n    }\r\n    if (sqlType == DOUBLE) {\r\n        return bloomFilter.testDouble((Double) predicateValue);\r\n    }\r\n    if (sqlType instanceof VarcharType || sqlType instanceof VarbinaryType) {\r\n        return bloomFilter.test(((Slice) predicateValue).getBytes());\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.realm.permissions.PermissionOffer.getToken",
	"Comment": "returns the offer token if this offer was successfully created.",
	"Method": "String getToken(){\r\n    return token;\r\n}"
}, {
	"Path": "org.redisson.config.BaseConfig.setPassword",
	"Comment": "password for redis authentication. should be null if not neededdefault is null",
	"Method": "T setPassword(String password){\r\n    this.password = password;\r\n    return (T) this;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.filterSchemas",
	"Comment": "filter the list of schemas in a catalog to those visible to the identity.",
	"Method": "Set<String> filterSchemas(Identity identity,String catalogName,Set<String> schemaNames){\r\n    return Collections.emptySet();\r\n}"
}, {
	"Path": "com.facebook.presto.operator.OperatorContext.recordRawInput",
	"Comment": "record the amount of physical bytes that were read by an operator.this metric is valid only for source operators.",
	"Method": "void recordRawInput(long sizeInBytes){\r\n    rawInputDataSize.update(sizeInBytes);\r\n}"
}, {
	"Path": "io.realm.PermissionManager.getInstance",
	"Comment": "return a thread confined, reference counted instance of the permissionmanager.",
	"Method": "PermissionManager getInstance(SyncUser syncUser){\r\n    synchronized (cacheLock) {\r\n        String userId = syncUser.getIdentity();\r\n        ThreadLocal<Cache> threadLocalCache = cache.get(userId);\r\n        if (threadLocalCache == null) {\r\n            threadLocalCache = new ThreadLocal<Cache>() {\r\n                @Override\r\n                protected Cache initialValue() {\r\n                    return new Cache();\r\n                }\r\n            };\r\n            cache.put(userId, threadLocalCache);\r\n        }\r\n        Cache c = threadLocalCache.get();\r\n        if (c.instanceCounter == 0) {\r\n            c.pm = new PermissionManager(syncUser);\r\n        }\r\n        c.instanceCounter++;\r\n        return c.pm;\r\n    }\r\n}"
}, {
	"Path": "io.realm.PermissionManager.getInstance",
	"Comment": "return a thread confined, reference counted instance of the permissionmanager.",
	"Method": "PermissionManager getInstance(SyncUser syncUser){\r\n    return new Cache();\r\n}"
}, {
	"Path": "io.realm.CollectionTests.populatePartialNullRowsForNumericTesting",
	"Comment": "creates a number of objects that mix null and real values for number type fields.",
	"Method": "void populatePartialNullRowsForNumericTesting(Realm realm){\r\n    NullTypes nullTypes1 = new NullTypes();\r\n    nullTypes1.setId(1);\r\n    nullTypes1.setFieldIntegerNull(1);\r\n    nullTypes1.setFieldFloatNull(2F);\r\n    nullTypes1.setFieldDoubleNull(3D);\r\n    nullTypes1.setFieldBooleanNull(true);\r\n    nullTypes1.setFieldStringNull(\"4\");\r\n    nullTypes1.setFieldDateNull(new Date(12345));\r\n    NullTypes nullTypes2 = new NullTypes();\r\n    nullTypes2.setId(2);\r\n    NullTypes nullTypes3 = new NullTypes();\r\n    nullTypes3.setId(3);\r\n    nullTypes3.setFieldIntegerNull(0);\r\n    nullTypes3.setFieldFloatNull(0F);\r\n    nullTypes3.setFieldDoubleNull(0D);\r\n    nullTypes3.setFieldBooleanNull(false);\r\n    nullTypes3.setFieldStringNull(\"0\");\r\n    nullTypes3.setFieldDateNull(new Date(0));\r\n    realm.beginTransaction();\r\n    realm.copyToRealm(nullTypes1);\r\n    realm.copyToRealm(nullTypes2);\r\n    realm.copyToRealm(nullTypes3);\r\n    realm.commitTransaction();\r\n}"
}, {
	"Path": "io.realm.SyncSession.authenticateRealm",
	"Comment": "authenticate by getting access tokens for the specific realm",
	"Method": "void authenticateRealm(AuthenticationServer authServer){\r\n    if (networkRequest != null) {\r\n        networkRequest.cancel();\r\n    }\r\n    clearScheduledAccessTokenRefresh();\r\n    onGoingAccessTokenQuery.set(true);\r\n    Future<?> task = SyncManager.NETWORK_POOL_EXECUTOR.submit(new ExponentialBackoffTask<AuthenticateResponse>() {\r\n        @Override\r\n        protected AuthenticateResponse execute() {\r\n            if (!isClosed && !Thread.currentThread().isInterrupted()) {\r\n                return // refresh token in fact\r\n                authServer.loginToRealm(getUser().getRefreshToken(), resolvedRealmURI, getUser().getAuthenticationUrl());\r\n            }\r\n            return null;\r\n        }\r\n        @Override\r\n        protected void onSuccess(AuthenticateResponse response) {\r\n            RealmLog.debug(\"Session[%s]: Access token acquired\", configuration.getPath());\r\n            if (!isClosed && !Thread.currentThread().isInterrupted()) {\r\n                URI realmUrl = configuration.getServerUrl();\r\n                getUser().addRealm(configuration, response.getAccessToken());\r\n                if (nativeRefreshAccessToken(configuration.getPath(), response.getAccessToken().value(), realmUrl.toString())) {\r\n                    scheduleRefreshAccessToken(authServer, response.getAccessToken().expiresMs());\r\n                } else {\r\n                    onGoingAccessTokenQuery.set(false);\r\n                }\r\n            }\r\n        }\r\n        @Override\r\n        protected void onError(AuthenticateResponse response) {\r\n            onGoingAccessTokenQuery.set(false);\r\n            RealmLog.debug(\"Session[%s]: Failed to get access token (%s)\", configuration.getPath(), response.getError().getErrorCode());\r\n            if (!isClosed && !Thread.currentThread().isInterrupted() && !(response.getError().getException() instanceof InterruptedIOException)) {\r\n                errorHandler.onError(SyncSession.this, response.getError());\r\n            }\r\n        }\r\n    });\r\n    networkRequest = new RealmAsyncTaskImpl(task, SyncManager.NETWORK_POOL_EXECUTOR);\r\n}"
}, {
	"Path": "io.realm.SyncSession.authenticateRealm",
	"Comment": "authenticate by getting access tokens for the specific realm",
	"Method": "void authenticateRealm(AuthenticationServer authServer){\r\n    if (!isClosed && !Thread.currentThread().isInterrupted()) {\r\n        return // refresh token in fact\r\n        authServer.loginToRealm(getUser().getRefreshToken(), resolvedRealmURI, getUser().getAuthenticationUrl());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.realm.SyncSession.authenticateRealm",
	"Comment": "authenticate by getting access tokens for the specific realm",
	"Method": "void authenticateRealm(AuthenticationServer authServer){\r\n    RealmLog.debug(\"Session[%s]: Access token acquired\", configuration.getPath());\r\n    if (!isClosed && !Thread.currentThread().isInterrupted()) {\r\n        URI realmUrl = configuration.getServerUrl();\r\n        getUser().addRealm(configuration, response.getAccessToken());\r\n        if (nativeRefreshAccessToken(configuration.getPath(), response.getAccessToken().value(), realmUrl.toString())) {\r\n            scheduleRefreshAccessToken(authServer, response.getAccessToken().expiresMs());\r\n        } else {\r\n            onGoingAccessTokenQuery.set(false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.SyncSession.authenticateRealm",
	"Comment": "authenticate by getting access tokens for the specific realm",
	"Method": "void authenticateRealm(AuthenticationServer authServer){\r\n    onGoingAccessTokenQuery.set(false);\r\n    RealmLog.debug(\"Session[%s]: Failed to get access token (%s)\", configuration.getPath(), response.getError().getErrorCode());\r\n    if (!isClosed && !Thread.currentThread().isInterrupted() && !(response.getError().getException() instanceof InterruptedIOException)) {\r\n        errorHandler.onError(SyncSession.this, response.getError());\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.sql.analyzer.RelationType.joinWith",
	"Comment": "creates a new tuple descriptor containing all fields from this tuple descriptorand all fields from the specified tuple descriptor.",
	"Method": "RelationType joinWith(RelationType other){\r\n    List<Field> fields = ImmutableList.<Field>builder().addAll(this.allFields).addAll(other.allFields).build();\r\n    return new RelationType(fields);\r\n}"
}, {
	"Path": "io.realm.SyncSession.refreshAccessToken",
	"Comment": "authenticate by getting access tokens for the specific realm",
	"Method": "void refreshAccessToken(AuthenticationServer authServer){\r\n    clearScheduledAccessTokenRefresh();\r\n    Future<?> task = SyncManager.NETWORK_POOL_EXECUTOR.submit(new ExponentialBackoffTask<AuthenticateResponse>() {\r\n        @Override\r\n        protected AuthenticateResponse execute() {\r\n            if (!isClosed && !Thread.currentThread().isInterrupted()) {\r\n                return authServer.refreshUser(getUser().getRefreshToken(), resolvedRealmURI, getUser().getAuthenticationUrl());\r\n            }\r\n            return null;\r\n        }\r\n        @Override\r\n        protected void onSuccess(AuthenticateResponse response) {\r\n            synchronized (SyncSession.this) {\r\n                if (!isClosed && !Thread.currentThread().isInterrupted() && !refreshTokenNetworkRequest.isCancelled()) {\r\n                    RealmLog.debug(\"Access Token refreshed successfully, Sync URL: \" + configuration.getServerUrl());\r\n                    URI realmUrl = configuration.getServerUrl();\r\n                    if (nativeRefreshAccessToken(configuration.getPath(), response.getAccessToken().value(), realmUrl.toString())) {\r\n                        getUser().addRealm(configuration, response.getAccessToken());\r\n                        scheduleRefreshAccessToken(authServer, response.getAccessToken().expiresMs());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        @Override\r\n        protected void onError(AuthenticateResponse response) {\r\n            if (!isClosed && !Thread.currentThread().isInterrupted()) {\r\n                onGoingAccessTokenQuery.set(false);\r\n                RealmLog.error(\"Unrecoverable error, while refreshing the access Token (\" + response.getError().toString() + \") reschedule will not happen\");\r\n            }\r\n        }\r\n    });\r\n    refreshTokenNetworkRequest = new RealmAsyncTaskImpl(task, SyncManager.NETWORK_POOL_EXECUTOR);\r\n}"
}, {
	"Path": "io.realm.SyncSession.refreshAccessToken",
	"Comment": "authenticate by getting access tokens for the specific realm",
	"Method": "void refreshAccessToken(AuthenticationServer authServer){\r\n    if (!isClosed && !Thread.currentThread().isInterrupted()) {\r\n        return authServer.refreshUser(getUser().getRefreshToken(), resolvedRealmURI, getUser().getAuthenticationUrl());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.realm.SyncSession.refreshAccessToken",
	"Comment": "authenticate by getting access tokens for the specific realm",
	"Method": "void refreshAccessToken(AuthenticationServer authServer){\r\n    synchronized (SyncSession.this) {\r\n        if (!isClosed && !Thread.currentThread().isInterrupted() && !refreshTokenNetworkRequest.isCancelled()) {\r\n            RealmLog.debug(\"Access Token refreshed successfully, Sync URL: \" + configuration.getServerUrl());\r\n            URI realmUrl = configuration.getServerUrl();\r\n            if (nativeRefreshAccessToken(configuration.getPath(), response.getAccessToken().value(), realmUrl.toString())) {\r\n                getUser().addRealm(configuration, response.getAccessToken());\r\n                scheduleRefreshAccessToken(authServer, response.getAccessToken().expiresMs());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.SyncSession.refreshAccessToken",
	"Comment": "authenticate by getting access tokens for the specific realm",
	"Method": "void refreshAccessToken(AuthenticationServer authServer){\r\n    if (!isClosed && !Thread.currentThread().isInterrupted()) {\r\n        onGoingAccessTokenQuery.set(false);\r\n        RealmLog.error(\"Unrecoverable error, while refreshing the access Token (\" + response.getError().toString() + \") reschedule will not happen\");\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spi.block.Block.mayHaveNull",
	"Comment": "is it possible the block may have a null value?if false, the block can not containa null, but if true, the block may or may not have a null.",
	"Method": "boolean mayHaveNull(){\r\n    return true;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.ConnectorTablePartitioning.getPartitioningColumns",
	"Comment": "the columns used to partition the table across the worker nodes.an empty list meansthe table is entirely contained on a single worker.if the table is node partitioned, the connector guarantees that each combination of values forthe distributed columns will be contained within a single worker.",
	"Method": "List<ColumnHandle> getPartitioningColumns(){\r\n    return partitioningColumns;\r\n}"
}, {
	"Path": "io.realm.Realm.getLocalInstanceCount",
	"Comment": "returns the current number of open realm instances on the thread calling this method. this include bothdynamic and normal realms.",
	"Method": "int getLocalInstanceCount(RealmConfiguration configuration){\r\n    return RealmCache.getLocalThreadCount(configuration);\r\n}"
}, {
	"Path": "com.facebook.presto.connector.thrift.api.PrestoThriftSplit.getSplitId",
	"Comment": "encodes all the information needed to identify a batch of rows to return to presto.for a basic scan, includes schema name, table name, and output constraint.for an index scan, includes schema name, table name, set of keys to lookup and output constraint.",
	"Method": "PrestoThriftId getSplitId(){\r\n    return splitId;\r\n}"
}, {
	"Path": "io.realm.permissions.UserCondition.getKey",
	"Comment": "returns the they in the users metadata that is used for evaluating this condition.",
	"Method": "String getKey(){\r\n    return key;\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.migrationException_realmListChanged",
	"Comment": "check if the realmlist type change can trigger a realmmigrationneededexception.",
	"Method": "void migrationException_realmListChanged(){\r\n    RealmConfiguration config = configFactory.createConfiguration();\r\n    Realm.getInstance(configFactory.createConfiguration()).close();\r\n    DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);\r\n    dynamicRealm.beginTransaction();\r\n    RealmObjectSchema dogSchema = dynamicRealm.getSchema().get(Dog.CLASS_NAME);\r\n    RealmObjectSchema ownerSchema = dynamicRealm.getSchema().get(CatOwner.CLASS_NAME);\r\n    ownerSchema.removeField(CatOwner.FIELD_CATS);\r\n    ownerSchema.addRealmListField(CatOwner.FIELD_CATS, dogSchema);\r\n    dynamicRealm.commitTransaction();\r\n    dynamicRealm.close();\r\n    try {\r\n        realm = Realm.getInstance(config);\r\n        fail();\r\n    } catch (RealmMigrationNeededException ignored) {\r\n        assertThat(ignored.getMessage(), CoreMatchers.containsString(\"Property 'CatOwner.cats' has been changed from 'array<Dog>' to 'array<Cat>'\"));\r\n    }\r\n}"
}, {
	"Path": "io.realm.internal.Util.toSet",
	"Comment": "converts a var arg argument list to a set ignoring any duplicates and null values.",
	"Method": "Set<T> toSet(T items){\r\n    if (items == null) {\r\n        return Collections.emptySet();\r\n    } else {\r\n        Set<T> set = new LinkedHashSet();\r\n        for (int i = 0; i < items.length; i++) {\r\n            T item = items[i];\r\n            if (item != null) {\r\n                set.add(item);\r\n            }\r\n        }\r\n        return set;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.matching.PropertyPattern.upcast",
	"Comment": "this expresses the fact that propertypattern is covariant on t.",
	"Method": "PropertyPattern<F, T> upcast(PropertyPattern<F, ? extends T> propertyPattern){\r\n    return (PropertyPattern<F, T>) propertyPattern;\r\n}"
}, {
	"Path": "io.realm.RealmQuery.alwaysFalse",
	"Comment": "this predicate will never match, resulting in the query always returning 0 results.",
	"Method": "RealmQuery<E> alwaysFalse(){\r\n    realm.checkIfValid();\r\n    query.alwaysFalse();\r\n    return this;\r\n}"
}, {
	"Path": "io.realm.internal.fields.FieldDescriptor.verifyInternalColumnType",
	"Comment": "verify that the named link column, in the named table, of the specified type, is one of the legal internal column types.",
	"Method": "void verifyInternalColumnType(String tableName,String columnName,RealmFieldType columnType){\r\n    verifyColumnType(tableName, columnName, columnType, validInternalColumnTypes);\r\n}"
}, {
	"Path": "com.facebook.presto.operator.RowNumberOperator.updateMemoryReservation",
	"Comment": "the following implementation is a hybrid model, where the push model is going to call the pull model causing reentrancy",
	"Method": "boolean updateMemoryReservation(){\r\n    long memorySizeInBytes = groupByHash.map(GroupByHash::getEstimatedSize).orElse(0L) + partitionRowCount.sizeOf();\r\n    localUserMemoryContext.setBytes(memorySizeInBytes);\r\n    return operatorContext.isWaitingForMemory().isDone();\r\n}"
}, {
	"Path": "io.realm.RealmNullPrimaryKeyTests.addPrimaryKeyObjectToTestRealm",
	"Comment": "adds a primarykey object to a realm with values for its primarykey field and secondary field.",
	"Method": "RealmObject addPrimaryKeyObjectToTestRealm(Realm testRealm){\r\n    RealmObject obj = (RealmObject) testClazz.getConstructor(primaryKeyFieldType, secondaryFieldType).newInstance(null, secondaryFieldValue);\r\n    testRealm.beginTransaction();\r\n    testRealm.copyToRealm(obj);\r\n    testRealm.commitTransaction();\r\n    return obj;\r\n}"
}, {
	"Path": "io.realm.processor.ModuleMetaData.getAllModules",
	"Comment": "returns all module classes and the realmobjects they know of.",
	"Method": "Map<String, Set<ClassMetaData>> getAllModules(){\r\n    Map<String, Set<ClassMetaData>> allModules = new LinkedHashMap();\r\n    allModules.putAll(modules);\r\n    allModules.putAll(libraryModules);\r\n    return allModules;\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.findFirstAsync_initialEmptyRow",
	"Comment": "when there is no object match the query condition, findfirstasync should return with an invalid row.",
	"Method": "void findFirstAsync_initialEmptyRow(){\r\n    Realm realm = looperThread.getRealm();\r\n    final AllTypes firstAsync = realm.where(AllTypes.class).findFirstAsync();\r\n    looperThread.keepStrongReference(firstAsync);\r\n    firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {\r\n        @Override\r\n        public void onChange(AllTypes object) {\r\n            assertTrue(firstAsync.isLoaded());\r\n            assertFalse(firstAsync.isValid());\r\n            looperThread.testComplete();\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.findFirstAsync_initialEmptyRow",
	"Comment": "when there is no object match the query condition, findfirstasync should return with an invalid row.",
	"Method": "void findFirstAsync_initialEmptyRow(){\r\n    assertTrue(firstAsync.isLoaded());\r\n    assertFalse(firstAsync.isValid());\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "io.realm.RealmTests.closeRealmInChangeListener",
	"Comment": "tests if close can be called from realm change listener when there is no other listeners.",
	"Method": "void closeRealmInChangeListener(){\r\n    final Realm realm = looperThread.getRealm();\r\n    final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {\r\n        @Override\r\n        public void onChange(Realm object) {\r\n            if (realm.where(AllTypes.class).count() == 1) {\r\n                realm.removeChangeListener(this);\r\n                realm.close();\r\n                looperThread.testComplete();\r\n            }\r\n        }\r\n    };\r\n    realm.addChangeListener(listener);\r\n    realm.executeTransactionAsync(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            realm.createObject(AllTypes.class);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.realm.RealmTests.closeRealmInChangeListener",
	"Comment": "tests if close can be called from realm change listener when there is no other listeners.",
	"Method": "void closeRealmInChangeListener(){\r\n    if (realm.where(AllTypes.class).count() == 1) {\r\n        realm.removeChangeListener(this);\r\n        realm.close();\r\n        looperThread.testComplete();\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmTests.closeRealmInChangeListener",
	"Comment": "tests if close can be called from realm change listener when there is no other listeners.",
	"Method": "void closeRealmInChangeListener(){\r\n    realm.createObject(AllTypes.class);\r\n}"
}, {
	"Path": "io.realm.internal.OsSharedRealm.invalidateIterators",
	"Comment": "invalidates all iterators when a remote change notification is received.",
	"Method": "void invalidateIterators(){\r\n    for (WeakReference<OsResults.Iterator> iteratorRef : iterators) {\r\n        OsResults.Iterator iterator = iteratorRef.get();\r\n        if (iterator != null) {\r\n            iterator.invalidate();\r\n        }\r\n    }\r\n    iterators.clear();\r\n}"
}, {
	"Path": "com.facebook.presto.spi.ConnectorTableLayout.getPredicate",
	"Comment": "a tupledomain that represents a predicate that every row this tablescan nodeproduces is guaranteed to satisfy.this guarantee can have different origins.for example, it may be successful predicate push down, or inherent guarantee provided by the underlying data.",
	"Method": "TupleDomain<ColumnHandle> getPredicate(){\r\n    return predicate;\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.migration_backlinkedSourceFieldWrongType",
	"Comment": "table validation should fail if the backlinked column points to a field of the wrong type.",
	"Method": "void migration_backlinkedSourceFieldWrongType(){\r\n    final String realmName = \"backlinks-sourceFieldWrongType.realm\";\r\n    RealmConfiguration realmConfig = configFactory.createConfigurationBuilder().name(realmName).schema(BacklinksTarget.class, BacklinksSource.class).build();\r\n    OsObjectSchemaInfo targetSchemaInfo = new OsObjectSchemaInfo.Builder(\"BacklinksTarget\", 1, 1).addPersistedProperty(\"id\", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED).addComputedLinkProperty(\"parents\", \"BacklinksSource\", \"child\").build();\r\n    OsObjectSchemaInfo sourceSchemaInfo = new OsObjectSchemaInfo.Builder(\"BacklinksSource\", 2, 0).addPersistedProperty(\"name\", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED).addPersistedLinkProperty(\"child\", RealmFieldType.OBJECT, \"BacklinksSource\").build();\r\n    Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap = new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>();\r\n    infoMap.put(BacklinksTarget.class, targetSchemaInfo);\r\n    infoMap.put(BacklinksSource.class, sourceSchemaInfo);\r\n    RealmProxyMediator mediator = spy(realmConfig.getSchemaMediator());\r\n    when(mediator.getExpectedObjectSchemaInfoMap()).thenReturn(infoMap);\r\n    RealmConfiguration spyConfig = spy(realmConfig);\r\n    when(spyConfig.getSchemaMediator()).thenReturn(mediator);\r\n    try {\r\n        Realm localRealm = Realm.getInstance(spyConfig);\r\n        localRealm.close();\r\n        fail();\r\n    } catch (IllegalStateException expected) {\r\n        assertThat(expected.getMessage(), CoreMatchers.containsString(\"Property 'BacklinksSource.child' declared as origin of linking objects property 'BacklinksTarget.parents' links to type 'BacklinksSource'\"));\r\n    }\r\n}"
}, {
	"Path": "io.realm.internal.Table.convertColumnToNotNullable",
	"Comment": "converts a column to be not nullable. null values will be converted to default values.",
	"Method": "void convertColumnToNotNullable(long columnIndex){\r\n    if (sharedRealm.isSyncRealm()) {\r\n        throw new IllegalStateException(\"This method is only available for non-synchronized Realms\");\r\n    }\r\n    nativeConvertColumnToNotNullable(nativePtr, columnIndex, isPrimaryKey(columnIndex));\r\n}"
}, {
	"Path": "io.realm.RealmObjectTests.invalidSurrogates",
	"Comment": "both high and low should lead to an illegalargumentexception.",
	"Method": "void invalidSurrogates(){\r\n    String high = \"Invalid high surrogate ??\";\r\n    String low = \"Invalid low surrogate ??\";\r\n    realm.beginTransaction();\r\n    realm.delete(AllTypes.class);\r\n    realm.commitTransaction();\r\n    realm.beginTransaction();\r\n    try {\r\n        AllTypes highSurrogate = realm.createObject(AllTypes.class);\r\n        highSurrogate.setColumnString(high);\r\n        fail();\r\n    } catch (IllegalArgumentException ignored) {\r\n    }\r\n    realm.cancelTransaction();\r\n    realm.beginTransaction();\r\n    try {\r\n        AllTypes lowSurrogate = realm.createObject(AllTypes.class);\r\n        lowSurrogate.setColumnString(low);\r\n        fail();\r\n    } catch (IllegalArgumentException ignored) {\r\n    }\r\n    realm.cancelTransaction();\r\n}"
}, {
	"Path": "com.facebook.presto.sql.planner.EqualityInference.getScopedCanonical",
	"Comment": "returns a canonical expression that is fully contained by the symbolscope and that is equivalentto the specified expression. returns null if unable to to find a canonical.",
	"Method": "Expression getScopedCanonical(Expression expression,Predicate<Symbol> symbolScope){\r\n    Expression canonicalIndex = canonicalMap.get(expression);\r\n    if (canonicalIndex == null) {\r\n        return null;\r\n    }\r\n    return getCanonical(filter(equalitySets.get(canonicalIndex), symbolToExpressionPredicate(symbolScope)));\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_notSentAfterUnregisterListenerModelObject",
	"Comment": "a listener registered on the backlinked object should not be called after the listener is removed",
	"Method": "void notification_notSentAfterUnregisterListenerModelObject(){\r\n    final Realm looperThreadRealm = looperThread.getRealm();\r\n    looperThreadRealm.beginTransaction();\r\n    AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);\r\n    looperThreadRealm.commitTransaction();\r\n    RealmChangeListener<AllJavaTypes> listener = new RealmChangeListener<AllJavaTypes>() {\r\n        @Override\r\n        public void onChange(AllJavaTypes object) {\r\n            fail(\"Not expecting notification after unregister\");\r\n        }\r\n    };\r\n    child.addChangeListener(listener);\r\n    child.removeChangeListener(listener);\r\n    looperThreadRealm.beginTransaction();\r\n    AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);\r\n    parent.setFieldObject(child);\r\n    looperThreadRealm.commitTransaction();\r\n    verifyPostConditions(looperThreadRealm, new PostConditions() {\r\n        @Override\r\n        public void run(Realm realm) {\r\n            assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());\r\n        }\r\n    }, child, parent);\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_notSentAfterUnregisterListenerModelObject",
	"Comment": "a listener registered on the backlinked object should not be called after the listener is removed",
	"Method": "void notification_notSentAfterUnregisterListenerModelObject(){\r\n    fail(\"Not expecting notification after unregister\");\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_notSentAfterUnregisterListenerModelObject",
	"Comment": "a listener registered on the backlinked object should not be called after the listener is removed",
	"Method": "void notification_notSentAfterUnregisterListenerModelObject(){\r\n    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());\r\n}"
}, {
	"Path": "com.facebook.presto.sql.InterpretedFunctionInvoker.invoke",
	"Comment": "arguments must be the native container type for the corresponding sql types.returns a value in the native container type corresponding to the declared sql return type",
	"Method": "Object invoke(Signature function,ConnectorSession session,Object arguments,Object invoke,Signature function,ConnectorSession session,List<Object> arguments){\r\n    ScalarFunctionImplementation implementation = registry.getScalarFunctionImplementation(function);\r\n    MethodHandle method = implementation.getMethodHandle();\r\n    method = bindInstanceFactory(method, implementation);\r\n    if (method.type().parameterCount() > 0 && method.type().parameterType(0) == ConnectorSession.class) {\r\n        method = method.bindTo(session);\r\n    }\r\n    List<Object> actualArguments = new ArrayList();\r\n    for (int i = 0; i < arguments.size(); i++) {\r\n        Object argument = arguments.get(i);\r\n        ArgumentProperty argumentProperty = implementation.getArgumentProperty(i);\r\n        if (argumentProperty.getArgumentType() == VALUE_TYPE) {\r\n            if (implementation.getArgumentProperty(i).getNullConvention() == USE_NULL_FLAG) {\r\n                boolean isNull = argument == null;\r\n                if (isNull) {\r\n                    argument = Defaults.defaultValue(method.type().parameterType(actualArguments.size()));\r\n                }\r\n                actualArguments.add(argument);\r\n                actualArguments.add(isNull);\r\n            } else {\r\n                actualArguments.add(argument);\r\n            }\r\n        } else {\r\n            argument = asInterfaceInstance(argumentProperty.getLambdaInterface(), (MethodHandle) argument);\r\n            actualArguments.add(argument);\r\n        }\r\n    }\r\n    try {\r\n        return method.invokeWithArguments(actualArguments);\r\n    } catch (Throwable throwable) {\r\n        throw propagate(throwable);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.sql.planner.EqualityInference.nonInferrableConjuncts",
	"Comment": "provides a convenience iterable of expression conjuncts which have not been added to the inference",
	"Method": "Iterable<Expression> nonInferrableConjuncts(Expression expression){\r\n    return filter(extractConjuncts(expression), not(isInferenceCandidate()));\r\n}"
}, {
	"Path": "io.realm.objectserver.ProcessCommitTests.expectSimpleCommit",
	"Comment": "2. get the notification, check if the change in a is received.",
	"Method": "void expectSimpleCommit(){\r\n    looperThread.runAfterTest(remoteService.afterRunnable);\r\n    remoteService.createHandler(Looper.myLooper());\r\n    final SyncUser user = UserFactory.getInstance().createDefaultUser(Constants.AUTH_URL);\r\n    String realmUrl = Constants.SYNC_SERVER_URL;\r\n    final SyncConfiguration syncConfig = user.createConfiguration(realmUrl).fullSynchronization().modules(new ProcessCommitTestsModule()).directory(looperThread.getRoot()).build();\r\n    final Realm realm = Realm.getInstance(syncConfig);\r\n    final RealmResults<ProcessInfo> all = realm.where(ProcessInfo.class).findAll();\r\n    looperThread.keepStrongReference(all);\r\n    all.addChangeListener(new RealmChangeListener<RealmResults<ProcessInfo>>() {\r\n        @Override\r\n        public void onChange(RealmResults<ProcessInfo> element) {\r\n            assertEquals(1, all.size());\r\n            assertEquals(\"Background_Process1\", all.get(0).getName());\r\n            realm.close();\r\n            user.logOut();\r\n            remoteService.triggerServiceStep(SimpleCommitRemoteService.stepB_closeRealmAndLogOut);\r\n            looperThread.testComplete();\r\n        }\r\n    });\r\n    remoteService.triggerServiceStep(SimpleCommitRemoteService.stepA_openRealmAndCreateOneObject);\r\n}"
}, {
	"Path": "io.realm.objectserver.ProcessCommitTests.expectSimpleCommit",
	"Comment": "2. get the notification, check if the change in a is received.",
	"Method": "void expectSimpleCommit(){\r\n    assertEquals(1, all.size());\r\n    assertEquals(\"Background_Process1\", all.get(0).getName());\r\n    realm.close();\r\n    user.logOut();\r\n    remoteService.triggerServiceStep(SimpleCommitRemoteService.stepB_closeRealmAndLogOut);\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "io.realm.DynamicRealmTests.initializeDynamicRealm",
	"Comment": "initializes a dynamic realm used by the async tests and keeps it ref in the looperthread.",
	"Method": "DynamicRealm initializeDynamicRealm(){\r\n    RealmConfiguration defaultConfig = looperThread.getConfiguration();\r\n    final DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);\r\n    populateTestRealm(dynamicRealm, 10);\r\n    looperThread.keepStrongReference(dynamicRealm);\r\n    return dynamicRealm;\r\n}"
}, {
	"Path": "io.realm.objectserver.utils.HttpUtils.startSyncServer",
	"Comment": "start the sync server. if the server has been started before, stop it first.",
	"Method": "void startSyncServer(){\r\n    Request request = new Request.Builder().url(START_SERVER).build();\r\n    Response response = client.newCall(request).execute();\r\n    if (!response.isSuccessful())\r\n        throw new IOException(\"Unexpected code \" + response);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.LocalProperty.withConstants",
	"Comment": "simplfies this localproperty provided that the specified inputs are constants",
	"Method": "Optional<LocalProperty<E>> withConstants(Set<E> constants){\r\n    Set<E> set = new HashSet(getColumns());\r\n    set.removeAll(constants);\r\n    if (set.isEmpty()) {\r\n        return Optional.empty();\r\n    }\r\n    return Optional.of(constrain(set));\r\n}"
}, {
	"Path": "io.realm.RealmConfigurationTests.schemaDoesNotContainAllDefinedObjectShouldThrow",
	"Comment": "only dog is included in the schema definition, but in order to create dog, the owner has to be defined as well.",
	"Method": "void schemaDoesNotContainAllDefinedObjectShouldThrow(){\r\n    RealmConfiguration config = configFactory.createConfigurationBuilder().directory(configFactory.getRoot()).schema(Dog.class).build();\r\n    thrown.expect(IllegalStateException.class);\r\n    realm = Realm.getInstance(config);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.block.Block.getLoadedBlock",
	"Comment": "returns a block that assures all data is in memory.may return the same block if all block data is already in memory.this allows streaming data sources to skip sections that are notaccessed in a query.",
	"Method": "Block getLoadedBlock(){\r\n    return this;\r\n}"
}, {
	"Path": "org.redisson.config.ClusterServersConfig.setScanInterval",
	"Comment": "redis cluster scan interval in millisecondsdefault is 5000",
	"Method": "ClusterServersConfig setScanInterval(int scanInterval){\r\n    this.scanInterval = scanInterval;\r\n    return this;\r\n}"
}, {
	"Path": "io.realm.RealmObjectSchemaTests.checkAddedAndRemovable",
	"Comment": "checks that field is actually added and that it can be removed again.",
	"Method": "void checkAddedAndRemovable(String fieldName){\r\n    assertTrue(schema.hasField(fieldName));\r\n    schema.removeField(fieldName);\r\n    assertFalse(schema.hasField(fieldName));\r\n}"
}, {
	"Path": "com.facebook.presto.spi.block.MapBlock.fromKeyValueBlock",
	"Comment": "create a map block directly from columnar nulls, keys, values, and offsets into the keys and values.a null map must have no entries.",
	"Method": "MapBlock fromKeyValueBlock(Optional<boolean[]> mapIsNull,int[] offsets,Block keyBlock,Block valueBlock,MapType mapType,MethodHandle keyBlockNativeEquals,MethodHandle keyNativeHashCode,MethodHandle keyBlockHashCode){\r\n    validateConstructorArguments(0, offsets.length - 1, mapIsNull.orElse(null), offsets, keyBlock, valueBlock, mapType.getKeyType(), keyBlockNativeEquals, keyNativeHashCode);\r\n    int mapCount = offsets.length - 1;\r\n    return createMapBlockInternal(0, mapCount, mapIsNull, offsets, keyBlock, valueBlock, Optional.empty(), mapType.getKeyType(), keyBlockNativeEquals, keyNativeHashCode, keyBlockHashCode);\r\n}"
}, {
	"Path": "io.realm.OrderedCollectionChangeSetTests.initialChangeSet_findAllAsync",
	"Comment": "the change set should be empty when the async query returns at the first time.",
	"Method": "void initialChangeSet_findAllAsync(){\r\n    if (type == ObservablesType.REALM_LIST) {\r\n        looperThread.testComplete();\r\n        return;\r\n    }\r\n    Realm realm = looperThread.getRealm();\r\n    populateData(realm, 10);\r\n    final RealmResults<Dog> results = realm.where(Dog.class).sort(Dog.FIELD_AGE).findAllAsync();\r\n    looperThread.keepStrongReference(results);\r\n    results.addChangeListener((collection, changeSet) -> {\r\n        assertSame(collection, results);\r\n        assertEquals(10, collection.size());\r\n        assertTrue(changeSet.isCompleteResult());\r\n        assertEquals(OrderedCollectionChangeSet.State.INITIAL, changeSet.getState());\r\n        assertEquals(0, changeSet.getInsertions().length);\r\n        assertEquals(0, changeSet.getChanges().length);\r\n        assertEquals(0, changeSet.getDeletions().length);\r\n        looperThread.testComplete();\r\n    });\r\n}"
}, {
	"Path": "io.realm.TestHelper.waitRealmThreadExecutorFinish",
	"Comment": "waits and checks if all tasks in baserealm.asynctaskexecutor can be finished in 5 seconds, otherwise fails the test.",
	"Method": "void waitRealmThreadExecutorFinish(){\r\n    int counter = 50;\r\n    while (counter > 0) {\r\n        if (BaseRealm.asyncTaskExecutor.getActiveCount() == 0) {\r\n            return;\r\n        }\r\n        try {\r\n            Thread.sleep(100);\r\n        } catch (InterruptedException e) {\r\n            fail(e.getMessage());\r\n        }\r\n        counter--;\r\n    }\r\n    fail(\"'BaseRealm.asyncTaskExecutor' is not finished in \" + counter / 10.0D + \" seconds\");\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_onDeleteRealmResults",
	"Comment": "a listener registered on the backlinked object should be called when a backlinked object is deleted",
	"Method": "void notification_onDeleteRealmResults(){\r\n    final Realm looperThreadRealm = looperThread.getRealm();\r\n    looperThreadRealm.beginTransaction();\r\n    AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);\r\n    AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);\r\n    parent.setFieldObject(child);\r\n    looperThreadRealm.commitTransaction();\r\n    final AtomicInteger counter = new AtomicInteger(0);\r\n    RealmChangeListener<RealmResults<AllJavaTypes>> listener = new RealmChangeListener<RealmResults<AllJavaTypes>>() {\r\n        @Override\r\n        public void onChange(RealmResults<AllJavaTypes> object) {\r\n            counter.incrementAndGet();\r\n        }\r\n    };\r\n    child.getObjectParents().addChangeListener(listener);\r\n    looperThreadRealm.beginTransaction();\r\n    looperThreadRealm.where(AllJavaTypes.class).equalTo(\"fieldId\", 1).findAll().deleteAllFromRealm();\r\n    looperThreadRealm.commitTransaction();\r\n    verifyPostConditions(looperThreadRealm, new PostConditions() {\r\n        @Override\r\n        public void run(Realm realm) {\r\n            assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());\r\n            assertEquals(1, counter.get());\r\n        }\r\n    }, child, parent);\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_onDeleteRealmResults",
	"Comment": "a listener registered on the backlinked object should be called when a backlinked object is deleted",
	"Method": "void notification_onDeleteRealmResults(){\r\n    counter.incrementAndGet();\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_onDeleteRealmResults",
	"Comment": "a listener registered on the backlinked object should be called when a backlinked object is deleted",
	"Method": "void notification_onDeleteRealmResults(){\r\n    assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());\r\n    assertEquals(1, counter.get());\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorMetadata.getViews",
	"Comment": "gets the view data for views that match the specified table prefix.",
	"Method": "Map<SchemaTableName, ConnectorViewDefinition> getViews(ConnectorSession session,SchemaTablePrefix prefix){\r\n    return emptyMap();\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanSelectFromColumns",
	"Comment": "check if identity is allowed to select from the specified columns in a relation.the column set can be empty.",
	"Method": "void checkCanSelectFromColumns(Identity identity,CatalogSchemaTableName table,Set<String> columns){\r\n    denySelectColumns(table.toString(), columns);\r\n}"
}, {
	"Path": "io.realm.SessionTests.errorHandler_useBackupSyncConfigurationForClientReset",
	"Comment": "check that we can use the backup syncconfiguration to open the realm.",
	"Method": "void errorHandler_useBackupSyncConfigurationForClientReset(){\r\n    SyncUser user = createTestUser();\r\n    String url = \"realm://objectserver.realm.io/default\";\r\n    final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url).schema(StringOnly.class).errorHandler((session, error) -> {\r\n        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\r\n            fail(\"Wrong error \" + error.toString());\r\n            return;\r\n        }\r\n        final ClientResetRequiredError handler = (ClientResetRequiredError) error;\r\n        looperThread.closeTestRealms();\r\n        handler.executeClientReset();\r\n        assertFalse(handler.getOriginalFile().exists());\r\n        assertTrue(handler.getBackupFile().exists());\r\n        RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();\r\n        assertNotNull(backupRealmConfiguration);\r\n        assertFalse(backupRealmConfiguration.isSyncConfiguration());\r\n        assertTrue(backupRealmConfiguration.isRecoveryConfiguration());\r\n        Realm backupRealm = Realm.getInstance(backupRealmConfiguration);\r\n        assertFalse(backupRealm.isEmpty());\r\n        assertEquals(1, backupRealm.where(StringOnly.class).count());\r\n        assertEquals(\"Foo\", backupRealm.where(StringOnly.class).findAll().first().getChars());\r\n        backupRealm.close();\r\n        DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);\r\n        dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME);\r\n        RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();\r\n        assertEquals(1, all.size());\r\n        assertEquals(\"Foo\", all.first().getString(StringOnly.FIELD_CHARS));\r\n        dynamicRealm.close();\r\n        looperThread.testComplete();\r\n    }).modules(new StringOnlyModule()).build();\r\n    Realm realm = Realm.getInstance(config);\r\n    realm.beginTransaction();\r\n    realm.createObject(StringOnly.class).setChars(\"Foo\");\r\n    realm.commitTransaction();\r\n    looperThread.addTestRealm(realm);\r\n    SyncManager.simulateClientReset(SyncManager.getOrCreateSession(config, null));\r\n}"
}, {
	"Path": "io.realm.util.ExceptionHolder.checkFailure",
	"Comment": "checks if an exception has been set and fails the unit test if that is the case.",
	"Method": "void checkFailure(){\r\n    if (exception != null) {\r\n        StringWriter stacktrace = new StringWriter();\r\n        exception.printStackTrace(new PrintWriter(stacktrace));\r\n        fail(stacktrace.toString());\r\n    }\r\n}"
}, {
	"Path": "io.realm.sync.permissions.ClassPrivileges.canCreate",
	"Comment": "returns whether or not this user is allowed to create objects of this type.",
	"Method": "boolean canCreate(){\r\n    return canCreate;\r\n}"
}, {
	"Path": "io.realm.RealmInterprocessTest.getServiceInfo",
	"Comment": "use getremoteprocessinfo if you want to check the existence of remote process.",
	"Method": "ActivityManager.RunningServiceInfo getServiceInfo(){\r\n    ActivityManager manager = (ActivityManager) getContext().getSystemService(Context.ACTIVITY_SERVICE);\r\n    List<ActivityManager.RunningServiceInfo> serviceInfoList = manager.getRunningServices(Integer.MAX_VALUE);\r\n    for (ActivityManager.RunningServiceInfo service : serviceInfoList) {\r\n        if (RemoteProcessService.class.getName().equals(service.service.getClassName())) {\r\n            return service;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.realm.SyncSession.getAccessToken",
	"Comment": "return the access token for the realm this session is connected to.",
	"Method": "String getAccessToken(AuthenticationServer authServer,String refreshToken){\r\n    if (getUser().isRealmAuthenticated(configuration)) {\r\n        Token accessToken = getUser().getAccessToken(configuration);\r\n        if (!onGoingAccessTokenQuery.getAndSet(true)) {\r\n            scheduleRefreshAccessToken(authServer, accessToken.expiresMs());\r\n        }\r\n        return accessToken.value();\r\n    } else {\r\n        if (!Util.isEmptyString(refreshToken)) {\r\n            try {\r\n                JSONObject refreshTokenJSON = new JSONObject(refreshToken);\r\n                Token newRefreshToken = Token.from(refreshTokenJSON.getJSONObject(\"userToken\"));\r\n                if (newRefreshToken.hashCode() != getUser().getRefreshToken().hashCode()) {\r\n                    RealmLog.debug(\"Session[%s]: Access token updated\", configuration.getPath());\r\n                    getUser().setRefreshToken(newRefreshToken);\r\n                }\r\n            } catch (JSONException e) {\r\n                RealmLog.error(e, \"Session[%s]: Can not parse the refresh_token into a valid JSONObject: \", configuration.getPath());\r\n            }\r\n        }\r\n        if (!onGoingAccessTokenQuery.get() && NetworkStateReceiver.isOnline(SyncObjectServerFacade.getApplicationContext())) {\r\n            authenticateRealm(authServer);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.redisson.config.Config.useCustomServers",
	"Comment": "this is an extension point to supply custom connection manager.",
	"Method": "void useCustomServers(ConnectionManager connectionManager){\r\n    this.connectionManager = connectionManager;\r\n}"
}, {
	"Path": "io.realm.internal.async.RealmThreadPoolExecutor.beforeExecute",
	"Comment": "method invoked prior to executing the given runnable to pause execution of the thread.",
	"Method": "void beforeExecute(Thread t,Runnable r){\r\n    super.beforeExecute(t, r);\r\n    pauseLock.lock();\r\n    try {\r\n        while (isPaused) {\r\n            unpaused.await();\r\n        }\r\n    } catch (InterruptedException ie) {\r\n        t.interrupt();\r\n    } finally {\r\n        pauseLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmObjectSchema.getFieldType",
	"Comment": "returns the type used by the underlying storage engine to represent this field.",
	"Method": "RealmFieldType getFieldType(String fieldName){\r\n    long columnIndex = getColumnIndex(fieldName);\r\n    return table.getColumnType(columnIndex);\r\n}"
}, {
	"Path": "org.redisson.config.BaseMasterSlaveServersConfig.setSubscriptionMode",
	"Comment": "set node type used for subscription operation.default is master",
	"Method": "T setSubscriptionMode(SubscriptionMode subscriptionMode){\r\n    this.subscriptionMode = subscriptionMode;\r\n    return (T) this;\r\n}"
}, {
	"Path": "com.facebook.presto.operator.MarkDistinctOperator.updateMemoryReservation",
	"Comment": "the following implementation is a hybrid model, where the push model is going to call the pull model causing reentrancy",
	"Method": "boolean updateMemoryReservation(){\r\n    localUserMemoryContext.setBytes(markDistinctHash.getEstimatedSize());\r\n    return operatorContext.isWaitingForMemory().isDone();\r\n}"
}, {
	"Path": "io.realm.BaseRealm.writeCopyTo",
	"Comment": "writes a compacted copy of the realm to the given destination file.the destination file cannot already exist.note that if this is called from within a transaction it writes the current data, and not the data as it was whenthe last transaction was committed.",
	"Method": "void writeCopyTo(File destination){\r\n    if (destination == null) {\r\n        throw new IllegalArgumentException(\"The destination argument cannot be null\");\r\n    }\r\n    checkIfValid();\r\n    sharedRealm.writeCopy(destination, null);\r\n}"
}, {
	"Path": "io.realm.SyncTestUtils.restoreEnvironmentAfterTest",
	"Comment": "tries to restore the environment as best as possible after a test.",
	"Method": "void restoreEnvironmentAfterTest(){\r\n    UserFactory.logoutAllUsers();\r\n    RealmLog.setLevel(originalLogLevel);\r\n    if (BaseRealm.applicationContext != null) {\r\n        SyncManager.reset();\r\n        BaseRealm.applicationContext = null;\r\n    }\r\n    deleteRosFiles();\r\n    Realm.init(InstrumentationRegistry.getTargetContext());\r\n}"
}, {
	"Path": "io.realm.ImmutableRealmObjectSchema.getColumnIndices",
	"Comment": "returns a field descriptor based on java field names found in model classes.",
	"Method": "FieldDescriptor getColumnIndices(String publicJavaNameDescription,RealmFieldType validColumnTypes){\r\n    return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), publicJavaNameDescription, validColumnTypes);\r\n}"
}, {
	"Path": "io.realm.SyncUser.createUrl",
	"Comment": "infer the url to the default realm based on the server used to login the user",
	"Method": "String createUrl(SyncUser user){\r\n    URL url = user.getAuthenticationUrl();\r\n    String protocol = url.getProtocol();\r\n    String host = url.getHost();\r\n    int port = url.getPort();\r\n    if (port != -1) {\r\n        host += \":\" + port;\r\n    }\r\n    if (protocol.equalsIgnoreCase(\"https\")) {\r\n        protocol = \"realms\";\r\n    } else {\r\n        protocol = \"realm\";\r\n    }\r\n    return protocol + \"://\" + host + \"/default\";\r\n}"
}, {
	"Path": "io.realm.RealmQuery.distinct",
	"Comment": "selects a distinct set of objects of a specific class. when multiple distinct fields aregiven, all unique combinations of values in the fields will be returned. in case of multiplematches, it is undefined which object is returned. unless the result is sorted, then thefirst object will be returned.",
	"Method": "RealmQuery<E> distinct(String fieldName,RealmQuery<E> distinct,String firstFieldName,String remainingFieldNames){\r\n    realm.checkIfValid();\r\n    QueryDescriptor distinctDescriptor;\r\n    if (remainingFieldNames.length == 0) {\r\n        distinctDescriptor = QueryDescriptor.getInstanceForDistinct(getSchemaConnector(), table, firstFieldName);\r\n    } else {\r\n        String[] fieldNames = new String[1 + remainingFieldNames.length];\r\n        fieldNames[0] = firstFieldName;\r\n        System.arraycopy(remainingFieldNames, 0, fieldNames, 1, remainingFieldNames.length);\r\n        distinctDescriptor = QueryDescriptor.getInstanceForDistinct(getSchemaConnector(), table, fieldNames);\r\n    }\r\n    queryDescriptors.appendDistinct(distinctDescriptor);\r\n    return this;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.filterCatalogs",
	"Comment": "filter the list of catalogs to those visible to the identity.",
	"Method": "Set<String> filterCatalogs(Identity identity,Set<String> catalogs){\r\n    return Collections.emptySet();\r\n}"
}, {
	"Path": "com.facebook.presto.raptor.storage.organization.CompactionSetCreator.createCompactionSets",
	"Comment": "all shards provided to this method will be considered for creating a compaction set.",
	"Method": "Set<OrganizationSet> createCompactionSets(Table tableInfo,Collection<ShardIndexInfo> shards){\r\n    Collection<Collection<ShardIndexInfo>> shardsByDaysBuckets = getShardsByDaysBuckets(tableInfo, shards, temporalFunction);\r\n    ImmutableSet.Builder<OrganizationSet> compactionSets = ImmutableSet.builder();\r\n    for (Collection<ShardIndexInfo> shardInfos : shardsByDaysBuckets) {\r\n        compactionSets.addAll(buildCompactionSets(tableInfo, ImmutableSet.copyOf(shardInfos)));\r\n    }\r\n    return compactionSets.build();\r\n}"
}, {
	"Path": "io.realm.RealmSchema.getSchemaForClass",
	"Comment": "returns an immutable realmobjectschema for internal usage only.",
	"Method": "RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz,RealmObjectSchema getSchemaForClass,String className){\r\n    String tableName = Table.getTableNameForClass(className);\r\n    RealmObjectSchema dynamicSchema = dynamicClassToSchema.get(tableName);\r\n    if (dynamicSchema == null || !dynamicSchema.getTable().isValid() || !dynamicSchema.getClassName().equals(className)) {\r\n        if (!realm.getSharedRealm().hasTable(tableName)) {\r\n            throw new IllegalArgumentException(\"The class \" + className + \" doesn't exist in this Realm.\");\r\n        }\r\n        dynamicSchema = new ImmutableRealmObjectSchema(realm, this, realm.getSharedRealm().getTable(tableName));\r\n        dynamicClassToSchema.put(tableName, dynamicSchema);\r\n    }\r\n    return dynamicSchema;\r\n}"
}, {
	"Path": "com.facebook.presto.orc.TestStructStreamReader.testReaderLowerCasesFieldNamesFromType",
	"Comment": "reader has fields with upper case characters, writer has same names downcased.",
	"Method": "void testReaderLowerCasesFieldNamesFromType(){\r\n    List<String> readerFields = new ArrayList(Arrays.asList(\"field_A\", \"field_B\", \"field_C\"));\r\n    List<String> writerFields = new ArrayList(Arrays.asList(\"field_a\", \"field_b\", \"field_c\"));\r\n    List<String> writerData = new ArrayList(Arrays.asList(\"fieldAValue\", \"fieldBValue\", \"fieldCValue\"));\r\n    Type readerType = getType(readerFields);\r\n    Type writerType = getType(writerFields);\r\n    write(tempFile, writerType, writerData);\r\n    RowBlock readBlock = read(tempFile, readerType);\r\n    List actual = (List) readerType.getObjectValue(SESSION, readBlock, 0);\r\n    assertEquals(actual.size(), readerFields.size());\r\n    assertEquals(actual.get(0), \"fieldAValue\");\r\n    assertEquals(actual.get(1), \"fieldBValue\");\r\n    assertEquals(actual.get(2), \"fieldCValue\");\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.interpolate",
	"Comment": "linear interpolation between the previous and current physics state based on the amount oftimestep remaining after processing the rendering delta time in timestep sized chunks.",
	"Method": "void interpolate(double alpha){\r\n    mCurrentState.position = mCurrentState.position * alpha + mPreviousState.position * (1 - alpha);\r\n    mCurrentState.velocity = mCurrentState.velocity * alpha + mPreviousState.velocity * (1 - alpha);\r\n}"
}, {
	"Path": "org.redisson.api.LocalCachedMapOptions.timeToLive",
	"Comment": "sets time to live for each map entry in cache.if value equals to 0 then timeout is not applied",
	"Method": "LocalCachedMapOptions<K, V> timeToLive(long timeToLiveInMillis,LocalCachedMapOptions<K, V> timeToLive,long timeToLive,TimeUnit timeUnit){\r\n    return timeToLive(timeUnit.toMillis(timeToLive));\r\n}"
}, {
	"Path": "io.realm.ProxyState.checkValidObject",
	"Comment": "check that object is a valid and managed object by this realm.used by proxy classes to verify input.",
	"Method": "void checkValidObject(RealmModel value){\r\n    if (!RealmObject.isValid(value) || !RealmObject.isManaged(value)) {\r\n        throw new IllegalArgumentException(\"'value' is not a valid managed object.\");\r\n    }\r\n    if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != getRealm$realm()) {\r\n        throw new IllegalArgumentException(\"'value' belongs to a different Realm.\");\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spi.block.BlockUtil.compactSlice",
	"Comment": "returns a slice containing values in the specified range of the specified slice.if the range matches the entire slice, the input slice will be returned.otherwise, a copy will be returned.",
	"Method": "Slice compactSlice(Slice slice,int index,int length){\r\n    if (slice.isCompact() && index == 0 && length == slice.length()) {\r\n        return slice;\r\n    }\r\n    return Slices.copyOf(slice, index, length);\r\n}"
}, {
	"Path": "com.facebook.presto.sql.planner.plan.TableScanNode.getEnforcedConstraint",
	"Comment": "a tupledomain that represents a predicate that has been successfully pushed intothis tablescan node. in other words, predicates that were removed from filtersabove the tablescan node because the tablescan node can guarantee it.this field is used to make sure that predicates which were previously pushed downdo not get lost in subsequent refinements of the table layout.",
	"Method": "TupleDomain<ColumnHandle> getEnforcedConstraint(){\r\n    checkState(enforcedConstraint != null, \"enforcedConstraint should only be used in planner. It is not transported to workers.\");\r\n    return enforcedConstraint;\r\n}"
}, {
	"Path": "io.realm.OrderedCollectionChangeSetTests.createObjects",
	"Comment": "creates dogs objects with columnlong set to the value elements in indices array.",
	"Method": "void createObjects(Realm realm,int indices){\r\n    for (int index : indices) {\r\n        Dog dog = realm.createObject(Dog.class);\r\n        dog.setAge(index);\r\n        if (type == ObservablesType.REALM_LIST) {\r\n            Owner owner = realm.where(Owner.class).findFirst();\r\n            assertNotNull(owner);\r\n            RealmList<Dog> dogs = owner.getDogs();\r\n            boolean added = false;\r\n            for (int i = 0; i < dogs.size(); i++) {\r\n                if (dog.getAge() <= dogs.get(i).getAge()) {\r\n                    dogs.add(i, dog);\r\n                    added = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!added) {\r\n                dogs.add(dog);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmModelTests.realmModelWithRealmModelField",
	"Comment": "tests the behaviour of a realmmodel, containing a realmmodel field.",
	"Method": "void realmModelWithRealmModelField(){\r\n    RealmModelWithRealmModelField realmModelWithRealmModelField = new RealmModelWithRealmModelField();\r\n    AllTypesRealmModel allTypePojo = new AllTypesRealmModel();\r\n    allTypePojo.columnLong = 42;\r\n    realmModelWithRealmModelField.setAllTypesRealmModel(allTypePojo);\r\n    realm.beginTransaction();\r\n    realm.copyToRealm(realmModelWithRealmModelField);\r\n    realm.commitTransaction();\r\n    RealmResults<RealmModelWithRealmModelField> all = realm.where(RealmModelWithRealmModelField.class).findAll();\r\n    assertEquals(1, all.size());\r\n    assertEquals(42, all.first().getAllTypesRealmModel().columnLong);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanDropTable",
	"Comment": "check if identity is allowed to drop the specified table in a catalog.",
	"Method": "void checkCanDropTable(Identity identity,CatalogSchemaTableName table){\r\n    denyDropTable(table.toString());\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.getRestSpeedThreshold",
	"Comment": "returns the speed at which the spring should be considered at rest in pixels per second",
	"Method": "double getRestSpeedThreshold(){\r\n    return mRestSpeedThreshold;\r\n}"
}, {
	"Path": "io.realm.BaseRealm.getPath",
	"Comment": "returns the canonical path to where this realm is persisted on disk.",
	"Method": "String getPath(){\r\n    return configuration.getPath();\r\n}"
}, {
	"Path": "com.facebook.presto.connector.thrift.ThriftMetadata.getTableMetadataInternal",
	"Comment": "this method makes actual thrift request and should be called only by cache load method",
	"Method": "Optional<ThriftTableMetadata> getTableMetadataInternal(SchemaTableName schemaTableName){\r\n    requireNonNull(schemaTableName, \"schemaTableName is null\");\r\n    PrestoThriftNullableTableMetadata thriftTableMetadata = getTableMetadata(schemaTableName);\r\n    if (thriftTableMetadata.getTableMetadata() == null) {\r\n        return Optional.empty();\r\n    }\r\n    ThriftTableMetadata tableMetadata = new ThriftTableMetadata(thriftTableMetadata.getTableMetadata(), typeManager);\r\n    if (!Objects.equals(schemaTableName, tableMetadata.getSchemaTableName())) {\r\n        throw new PrestoException(THRIFT_SERVICE_INVALID_RESPONSE, \"Requested and actual table names are different\");\r\n    }\r\n    return Optional.of(tableMetadata);\r\n}"
}, {
	"Path": "org.redisson.RedissonNode.create",
	"Comment": "create redisson node instance with provided config and redisson instance",
	"Method": "RedissonNode create(RedissonNodeConfig config,RedissonNode create,RedissonNodeConfig config,RedissonClient redisson){\r\n    return new RedissonNode(config, redisson);\r\n}"
}, {
	"Path": "io.realm.RealmTests.close_differentThread",
	"Comment": "tests close realm in another thread different from where it is created.",
	"Method": "void close_differentThread(){\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    final AssertionFailedError[] threadAssertionError = new AssertionFailedError[1];\r\n    final Thread thatThread = new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                realm.close();\r\n                threadAssertionError[0] = new AssertionFailedError(\"Close realm in a different thread should throw IllegalStateException.\");\r\n            } catch (IllegalStateException ignored) {\r\n            }\r\n            latch.countDown();\r\n        }\r\n    });\r\n    thatThread.start();\r\n    TestHelper.awaitOrFail(latch);\r\n    if (threadAssertionError[0] != null) {\r\n        throw threadAssertionError[0];\r\n    }\r\n    realm.checkIfValid();\r\n    realm.close();\r\n    realm = null;\r\n}"
}, {
	"Path": "io.realm.RealmTests.close_differentThread",
	"Comment": "tests close realm in another thread different from where it is created.",
	"Method": "void close_differentThread(){\r\n    try {\r\n        realm.close();\r\n        threadAssertionError[0] = new AssertionFailedError(\"Close realm in a different thread should throw IllegalStateException.\");\r\n    } catch (IllegalStateException ignored) {\r\n    }\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.realm.internal.TableQuery.validateQuery",
	"Comment": "checks in core if query syntax is valid. throws exception, if not.",
	"Method": "void validateQuery(){\r\n    if (!queryValidated) {\r\n        String invalidMessage = nativeValidateQuery(nativePtr);\r\n        if (invalidMessage.equals(\"\")) {\r\n            queryValidated = true;\r\n        } else {\r\n            throw new UnsupportedOperationException(invalidMessage);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.permissions.PermissionOffer.mayWrite",
	"Comment": "returns whether or not the user accepting this offer is granted write permission.",
	"Method": "boolean mayWrite(){\r\n    return mayWrite;\r\n}"
}, {
	"Path": "com.facebook.presto.sql.analyzer.RelationType.getAllFields",
	"Comment": "gets all fields including hidden fields.no assumptions should be made about the order of the fields returned from this method.to obtain the index of a field, call indexof.",
	"Method": "Collection<Field> getAllFields(){\r\n    return ImmutableSet.copyOf(allFields);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanRenameColumn",
	"Comment": "check if identity is allowed to rename a column in the specified table in this catalog.",
	"Method": "void checkCanRenameColumn(ConnectorTransactionHandle transactionHandle,Identity identity,SchemaTableName tableName){\r\n    denyRenameColumn(tableName.toString());\r\n}"
}, {
	"Path": "com.facebook.presto.tests.AbstractTestIndexedQueries.testProbeNullInReadahead",
	"Comment": "assure nulls in probe readahead does not leak into connectors.",
	"Method": "void testProbeNullInReadahead(){\r\n    assertQuery(\"select count(*) from (values (1), (cast(null as bigint))) x(orderkey) join orders using (orderkey)\", \"select count(*) from orders where orderkey = 1\");\r\n}"
}, {
	"Path": "io.realm.BaseRealm.deleteAll",
	"Comment": "deletes all objects from this realm.if the realm is a partially synchronized realm, all subscriptions will be cleared as well.",
	"Method": "void deleteAll(){\r\n    checkIfValid();\r\n    if (sharedRealm.isPartial()) {\r\n        throw new IllegalStateException(DELETE_NOT_SUPPORTED_UNDER_PARTIAL_SYNC);\r\n    }\r\n    boolean isPartialRealm = sharedRealm.isPartial();\r\n    for (RealmObjectSchema objectSchema : getSchema().getAll()) {\r\n        getSchema().getTable(objectSchema.getClassName()).clear(isPartialRealm);\r\n    }\r\n}"
}, {
	"Path": "org.redisson.executor.CronExpression.getTimeZone",
	"Comment": "returns the time zone for which this cronexpression will be resolved.",
	"Method": "TimeZone getTimeZone(){\r\n    if (timeZone == null) {\r\n        timeZone = TimeZone.getDefault();\r\n    }\r\n    return timeZone;\r\n}"
}, {
	"Path": "com.facebook.presto.orc.reader.MapFlatStreamReader.copyStreamDescriptorWithSequence",
	"Comment": "creates streamdescriptor which is a copy of this one with the value of sequence changed tothe value passed in.recursively calls itself on the nested streams.",
	"Method": "StreamDescriptor copyStreamDescriptorWithSequence(StreamDescriptor streamDescriptor,int sequence){\r\n    List<StreamDescriptor> streamDescriptors = streamDescriptor.getNestedStreams().stream().map(stream -> copyStreamDescriptorWithSequence(stream, sequence)).collect(toImmutableList());\r\n    return new StreamDescriptor(streamDescriptor.getStreamName(), streamDescriptor.getStreamId(), streamDescriptor.getFieldName(), streamDescriptor.getStreamType(), streamDescriptor.getOrcDataSource(), streamDescriptors, sequence);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.predicate.TupleDomain.fromFixedValues",
	"Comment": "convert a map of columns to values into the tupledomain which requiresthose columns to be fixed to those values. null is allowed as a fixed value.",
	"Method": "TupleDomain<T> fromFixedValues(Map<T, NullableValue> fixedValues){\r\n    return TupleDomain.withColumnDomains(fixedValues.entrySet().stream().collect(toMap(Map.Entry::getKey, entry -> {\r\n        Type type = entry.getValue().getType();\r\n        Object value = entry.getValue().getValue();\r\n        return value == null ? Domain.onlyNull(type) : Domain.singleValue(type, value);\r\n    })));\r\n}"
}, {
	"Path": "io.realm.RealmResults.setList",
	"Comment": "replaces the realmlist at the given field on all objects in this collection.",
	"Method": "void setList(String fieldName,RealmList<T> list){\r\n    checkNonEmptyFieldName(fieldName);\r\n    fieldName = mapFieldNameToInternalName(fieldName);\r\n    realm.checkIfValidAndInTransaction();\r\n    if (list == null) {\r\n        throw new IllegalArgumentException(\"Non-null 'list' required\");\r\n    }\r\n    RealmFieldType columnType = realm.getSchema().getSchemaForClass(osResults.getTable().getClassName()).getFieldType(fieldName);\r\n    switch(columnType) {\r\n        case LIST:\r\n            checkTypeOfListElements(list, RealmModel.class);\r\n            checkRealmObjectConstraints(fieldName, (RealmModel) list.first(null));\r\n            osResults.setModelList(fieldName, (RealmList<? extends RealmModel>) list);\r\n            break;\r\n        case INTEGER_LIST:\r\n            Class<?> listType = getListType(list);\r\n            if (listType.equals(Integer.class)) {\r\n                osResults.setIntegerList(fieldName, (RealmList<Integer>) list);\r\n            } else if (listType.equals(Long.class)) {\r\n                osResults.setLongList(fieldName, (RealmList<Long>) list);\r\n            } else if (listType.equals(Short.class)) {\r\n                osResults.setShortList(fieldName, (RealmList<Short>) list);\r\n            } else if (listType.equals(Byte.class)) {\r\n                osResults.setByteList(fieldName, (RealmList<Byte>) list);\r\n            } else {\r\n                throw new IllegalArgumentException(String.format(\"List contained the wrong type of elements. \" + \"Elements that can be mapped to Integers was expected, but the actual type is '%s'\", listType));\r\n            }\r\n            break;\r\n        case BOOLEAN_LIST:\r\n            checkTypeOfListElements(list, Boolean.class);\r\n            osResults.setBooleanList(fieldName, (RealmList<Boolean>) list);\r\n            break;\r\n        case STRING_LIST:\r\n            checkTypeOfListElements(list, String.class);\r\n            osResults.setStringList(fieldName, (RealmList<String>) list);\r\n            break;\r\n        case BINARY_LIST:\r\n            checkTypeOfListElements(list, byte[].class);\r\n            osResults.setByteArrayList(fieldName, (RealmList<byte[]>) list);\r\n            break;\r\n        case DATE_LIST:\r\n            checkTypeOfListElements(list, Date.class);\r\n            osResults.setDateList(fieldName, (RealmList<Date>) list);\r\n            break;\r\n        case FLOAT_LIST:\r\n            checkTypeOfListElements(list, Float.class);\r\n            osResults.setFloatList(fieldName, (RealmList<Float>) list);\r\n            break;\r\n        case DOUBLE_LIST:\r\n            checkTypeOfListElements(list, Double.class);\r\n            osResults.setDoubleList(fieldName, (RealmList<Double>) list);\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(String.format(\"Field '%s' is not a list but a %s\", fieldName, columnType));\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmModelTests.realmObjectWithRealmModelField",
	"Comment": "tests the behaviour of a realmobject, containing a realmmodel field.",
	"Method": "void realmObjectWithRealmModelField(){\r\n    RealmObjectWithRealmModelField realmObjectWithRealmModelField = new RealmObjectWithRealmModelField();\r\n    AllTypesRealmModel allTypePojo = new AllTypesRealmModel();\r\n    allTypePojo.columnLong = 42;\r\n    realmObjectWithRealmModelField.setAllTypesRealmModel(allTypePojo);\r\n    realm.beginTransaction();\r\n    realm.copyToRealm(realmObjectWithRealmModelField);\r\n    realm.commitTransaction();\r\n    RealmResults<RealmObjectWithRealmModelField> all = realm.where(RealmObjectWithRealmModelField.class).findAll();\r\n    assertEquals(1, all.size());\r\n    assertEquals(42, all.first().getAllTypesRealmModel().columnLong);\r\n}"
}, {
	"Path": "io.realm.SyncUserTests.fromJson_WorkWithRemovedObjectServerUser",
	"Comment": "makes sure we can still deserialize a valid syncuser from the old format.",
	"Method": "void fromJson_WorkWithRemovedObjectServerUser(){\r\n    String oldSyncUserJSON = \"{\\\"authUrl\\\":\\\"http:\\\\/\\\\/192.168.1.151:9080\\\\/auth\\\",\\\"userToken\\\":{\\\"token\\\":\\\"eyJpZGVudGl0eSI6IjY4OWQ5MGMxNDIyYTIwMmZkNTljNDYwM2M0ZTRmNmNjIiwiZXhwaXJlcyI6MTgxNjM1ODE4NCwiYXBwX2lkIjoiaW8ucmVhbG0ucmVhbG10YXNrcyIsImFjY2VzcyI6WyJyZWZyZXNoIl0sImlzX2FkbWluIjpmYWxzZSwic2FsdCI6MC4yMTEwMjQyNDgwOTEyMzg1NH0=:lEDa83o1zu8rkwdZVpTyunLHh1wmjxPPSGmZQNxdEM7xDmpbiU7V+8dgDWGevJNHMFluNDAOmrcAOI9TLfhI4rMDl70NI1K9rv\\\\/Aeq5uIOzq\\\\/Gf7JTeTUKY5Z7yRoppd8NArlNBKesLFxzdLRlfm1hflF9wH23xQXA19yUZ67JIlkhDPL5e3bau8O3Pr\\\\/St0unW3KzPOiZUk1l9KRrs2iMCCiXCfq4rf6rp7B2M7rBUMQm68GnB1Ot7l1CblxEWcREcbpyhBKTWIOFRGMwg2TW\\\\/zRR3cRNglx+ZC4FOeO0mfkX+nf+slyFODAnQkOzPZcGO8xc3I1emafX58Wl\\\\/Guw==\\\",\\\"token_data\\\":{\\\"identity\\\":\\\"689d90c1422a202fd59c4603c4e4f6cc\\\",\\\"path\\\":\\\"\\\",\\\"expires\\\":1816358184,\\\"access\\\":[\\\"unknown\\\"],\\\"is_admin\\\":false}},\\\"realms\\\":[]}\";\r\n    SyncUser syncUser = SyncUser.fromJson(oldSyncUserJSON);\r\n    Token refreshToken = syncUser.getRefreshToken();\r\n    assertNotNull(refreshToken);\r\n    Calendar calendar = Calendar.getInstance();\r\n    calendar.setTimeInMillis(refreshToken.expiresMs());\r\n    int day = calendar.get(Calendar.DAY_OF_MONTH);\r\n    int month = calendar.get(Calendar.MONTH);\r\n    int year = calendar.get(Calendar.YEAR);\r\n    assertEquals(23, day);\r\n    assertEquals(Calendar.JULY, month);\r\n    assertEquals(2027, year);\r\n    assertEquals(\"http://192.168.1.151:9080/auth\", syncUser.getAuthenticationUrl().toString());\r\n}"
}, {
	"Path": "com.facebook.presto.spi.Page.getLoadedPage",
	"Comment": "returns a page that assures all data is in memory.may return the same page if all page data is already in memory.this allows streaming data sources to skip sections that are notaccessed in a query.",
	"Method": "Page getLoadedPage(){\r\n    boolean allLoaded = true;\r\n    Block[] loadedBlocks = new Block[blocks.length];\r\n    for (int i = 0; i < blocks.length; i++) {\r\n        loadedBlocks[i] = blocks[i].getLoadedBlock();\r\n        if (loadedBlocks[i] != blocks[i]) {\r\n            allLoaded = false;\r\n        }\r\n    }\r\n    if (allLoaded) {\r\n        return this;\r\n    }\r\n    return new Page(loadedBlocks);\r\n}"
}, {
	"Path": "io.realm.DynamicRealmTests.deleteRealm_throwsIfTypedRealmIsOpen",
	"Comment": "test that realms can only be deleted after all typed and dynamic instances are closed.",
	"Method": "void deleteRealm_throwsIfTypedRealmIsOpen(){\r\n    realm.close();\r\n    Realm typedRealm = Realm.getInstance(defaultConfig);\r\n    DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);\r\n    dynamicRealm.close();\r\n    try {\r\n        Realm.deleteRealm(defaultConfig);\r\n        fail();\r\n    } catch (IllegalStateException ignored) {\r\n    }\r\n    typedRealm.close();\r\n    assertTrue(Realm.deleteRealm(defaultConfig));\r\n}"
}, {
	"Path": "io.realm.SyncConfiguration.syncClientValidateSsl",
	"Comment": "whether the realm object server certificate should be validated in orderto establish a valid tls connection.",
	"Method": "boolean syncClientValidateSsl(){\r\n    return syncClientValidateSsl;\r\n}"
}, {
	"Path": "io.realm.DynamicRealmObject.setValue",
	"Comment": "automatically finds the appropriate setter based on the objects type.",
	"Method": "void setValue(String fieldName,Object value){\r\n    Class<?> valueClass = value.getClass();\r\n    if (valueClass == Boolean.class) {\r\n        setBoolean(fieldName, (Boolean) value);\r\n    } else if (valueClass == Short.class) {\r\n        setShort(fieldName, (Short) value);\r\n    } else if (valueClass == Integer.class) {\r\n        setInt(fieldName, (Integer) value);\r\n    } else if (valueClass == Long.class) {\r\n        setLong(fieldName, (Long) value);\r\n    } else if (valueClass == Byte.class) {\r\n        setByte(fieldName, (Byte) value);\r\n    } else if (valueClass == Float.class) {\r\n        setFloat(fieldName, (Float) value);\r\n    } else if (valueClass == Double.class) {\r\n        setDouble(fieldName, (Double) value);\r\n    } else if (valueClass == String.class) {\r\n        setString(fieldName, (String) value);\r\n    } else if (value instanceof Date) {\r\n        setDate(fieldName, (Date) value);\r\n    } else if (value instanceof byte[]) {\r\n        setBlob(fieldName, (byte[]) value);\r\n    } else if (valueClass == DynamicRealmObject.class) {\r\n        setObject(fieldName, (DynamicRealmObject) value);\r\n    } else if (valueClass == RealmList.class) {\r\n        RealmList<?> list = (RealmList<?>) value;\r\n        setList(fieldName, list);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Value is of an type not supported: \" + value.getClass());\r\n    }\r\n}"
}, {
	"Path": "io.realm.SyncUser.isRealmAuthenticated",
	"Comment": "checks if the user has access to the given realm. being authenticated means that theuser is known by the realm object server and have been granted access to the given realm.authenticating will happen automatically as part of opening a realm.",
	"Method": "boolean isRealmAuthenticated(SyncConfiguration configuration){\r\n    Token token = realms.get(configuration);\r\n    return token != null && token.expiresMs() > System.currentTimeMillis();\r\n}"
}, {
	"Path": "org.redisson.api.CronSchedule.dailyAtHourAndMinute",
	"Comment": "creates cron expression which schedule task executionevery day at the given time",
	"Method": "CronSchedule dailyAtHourAndMinute(int hour,int minute){\r\n    String expression = String.format(\"0 %d %d ? * *\", minute, hour);\r\n    return of(expression);\r\n}"
}, {
	"Path": "io.realm.internal.android.ISO8601Utils.checkOffset",
	"Comment": "checks if the expected character exist at the given offset in the value.",
	"Method": "boolean checkOffset(String value,int offset,char expected){\r\n    return (offset < value.length()) && (value.charAt(offset) == expected);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanAddColumn",
	"Comment": "check if identity is allowed to add columns to the specified table in this catalog.",
	"Method": "void checkCanAddColumn(ConnectorTransactionHandle transactionHandle,Identity identity,SchemaTableName tableName){\r\n    denyAddColumn(tableName.toString());\r\n}"
}, {
	"Path": "com.facebook.presto.operator.aggregation.NumericHistogram.store",
	"Comment": "dump the entries in the queue back into the bucket arraysthe values are guaranteed to be sorted in increasing order after this method completes",
	"Method": "void store(PriorityQueue<Entry> queue){\r\n    nextIndex = 0;\r\n    for (Entry entry : queue) {\r\n        if (entry.isValid()) {\r\n            values[nextIndex] = entry.getValue();\r\n            weights[nextIndex] = entry.getWeight();\r\n            nextIndex++;\r\n        }\r\n    }\r\n    sort(values, weights, nextIndex);\r\n}"
}, {
	"Path": "io.realm.PermissionManager.close",
	"Comment": "closes the permissionmanager as well as any underlying realms.any active tasks in progress will be canceled.",
	"Method": "void close(){\r\n    checkIfValid();\r\n    synchronized (cacheLock) {\r\n        Cache cache = PermissionManager.cache.get(user.getIdentity()).get();\r\n        if (cache.instanceCounter > 1) {\r\n            cache.instanceCounter--;\r\n            return;\r\n        }\r\n        cache.instanceCounter = 0;\r\n        cache.pm = null;\r\n    }\r\n    closed = true;\r\n    delayedTasks.clear();\r\n    if (managementRealmOpenTask != null) {\r\n        managementRealmOpenTask.cancel();\r\n        managementRealmOpenTask = null;\r\n    }\r\n    if (permissionRealmOpenTask != null) {\r\n        permissionRealmOpenTask.cancel();\r\n        permissionRealmOpenTask = null;\r\n    }\r\n    if (defaultPermissionRealmOpenTask != null) {\r\n        defaultPermissionRealmOpenTask.cancel();\r\n        defaultPermissionRealmOpenTask = null;\r\n    }\r\n    if (managementRealm != null) {\r\n        managementRealm.close();\r\n    }\r\n    if (permissionRealm != null) {\r\n        permissionRealm.close();\r\n    }\r\n    if (defaultPermissionRealm != null) {\r\n        defaultPermissionRealm.close();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorMetadata.getInsertLayout",
	"Comment": "get the physical layout for a inserting into an existing table.",
	"Method": "Optional<ConnectorNewTableLayout> getInsertLayout(ConnectorSession session,ConnectorTableHandle tableHandle){\r\n    List<ConnectorTableLayout> layouts = getTableLayouts(session, tableHandle, new Constraint(TupleDomain.all(), map -> true), Optional.empty()).stream().map(ConnectorTableLayoutResult::getTableLayout).filter(layout -> layout.getTablePartitioning().isPresent()).collect(toList());\r\n    if (layouts.isEmpty()) {\r\n        return Optional.empty();\r\n    }\r\n    if (layouts.size() > 1) {\r\n        throw new PrestoException(NOT_SUPPORTED, \"Tables with multiple layouts can not be written\");\r\n    }\r\n    ConnectorTableLayout layout = layouts.get(0);\r\n    ConnectorPartitioningHandle partitioningHandle = layout.getTablePartitioning().get().getPartitioningHandle();\r\n    Map<ColumnHandle, String> columnNamesByHandle = getColumnHandles(session, tableHandle).entrySet().stream().collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));\r\n    List<String> partitionColumns = layout.getTablePartitioning().get().getPartitioningColumns().stream().map(columnNamesByHandle::get).collect(toList());\r\n    return Optional.of(new ConnectorNewTableLayout(partitioningHandle, partitionColumns));\r\n}"
}, {
	"Path": "io.realm.Realm.getSubscription",
	"Comment": "returns the first subscription that matches the given name.",
	"Method": "Subscription getSubscription(String name){\r\n    return where(Subscription.class).equalTo(\"name\", name).findFirst();\r\n}"
}, {
	"Path": "io.realm.OrderedRealmCollectionSnapshot.deleteLastFromRealm",
	"Comment": "deletes the last object from the realm. the last object will become invalid.",
	"Method": "boolean deleteLastFromRealm(){\r\n    realm.checkIfValidAndInTransaction();\r\n    UncheckedRow row = osResults.lastUncheckedRow();\r\n    return row != null && row.isAttached() && osResults.deleteLast();\r\n}"
}, {
	"Path": "io.realm.internal.util.Pair.create",
	"Comment": "convenience method for creating an appropriately typed pair.",
	"Method": "Pair<A, B> create(A a,B b){\r\n    return new Pair(a, b);\r\n}"
}, {
	"Path": "io.realm.PermissionManagerTests.createRemoteRealm",
	"Comment": "creates an empty remote realm on ros owned by the provided user",
	"Method": "String createRemoteRealm(SyncUser user,String realmName){\r\n    String url = Constants.AUTH_SERVER_URL + \"~/\" + realmName;\r\n    SyncConfiguration config = user.createConfiguration(url).name(realmName).schema(AllJavaTypes.class).sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY).build();\r\n    Realm realm = Realm.getInstance(config);\r\n    SyncSession session = SyncManager.getSession(config);\r\n    final CountDownLatch uploadLatch = new CountDownLatch(1);\r\n    session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {\r\n        @Override\r\n        public void onChange(Progress progress) {\r\n            if (progress.isTransferComplete()) {\r\n                uploadLatch.countDown();\r\n            }\r\n        }\r\n    });\r\n    TestHelper.awaitOrFail(uploadLatch);\r\n    realm.close();\r\n    return config.getServerUrl().toString();\r\n}"
}, {
	"Path": "io.realm.PermissionManagerTests.createRemoteRealm",
	"Comment": "creates an empty remote realm on ros owned by the provided user",
	"Method": "String createRemoteRealm(SyncUser user,String realmName){\r\n    if (progress.isTransferComplete()) {\r\n        uploadLatch.countDown();\r\n    }\r\n}"
}, {
	"Path": "org.redisson.config.Config.setKeepPubSubOrder",
	"Comment": "defines whether to keep pubsub messages handling in arrival order or handle messages concurrently. this setting applied only for pubsub messages per channel.default is true.",
	"Method": "Config setKeepPubSubOrder(boolean keepPubSubOrder){\r\n    this.keepPubSubOrder = keepPubSubOrder;\r\n    return this;\r\n}"
}, {
	"Path": "org.redisson.config.BaseConfig.setPingConnectionInterval",
	"Comment": "defines ping command sending interval per connection to redis.0 means disable.default is 0",
	"Method": "T setPingConnectionInterval(int pingConnectionInterval){\r\n    this.pingConnectionInterval = pingConnectionInterval;\r\n    return (T) this;\r\n}"
}, {
	"Path": "com.facebook.rebound.SpringConfig.fromBouncinessAndSpeed",
	"Comment": "map values from the origami pop animation patch, which are based on a bounciness and speedvalue.",
	"Method": "SpringConfig fromBouncinessAndSpeed(double bounciness,double speed){\r\n    BouncyConversion bouncyConversion = new BouncyConversion(speed, bounciness);\r\n    return fromOrigamiTensionAndFriction(bouncyConversion.getBouncyTension(), bouncyConversion.getBouncyFriction());\r\n}"
}, {
	"Path": "com.facebook.presto.sql.planner.TestLogicalPlanner.testCorrelatedInUncorrelatedFiltersPushDown",
	"Comment": "handling of correlated in pulls up everything possible to the generated outer join condition.this test ensures uncorrelated conditions are pushed back down.",
	"Method": "void testCorrelatedInUncorrelatedFiltersPushDown(){\r\n    assertPlan(\"SELECT orderkey, comment IN (SELECT clerk FROM orders s WHERE s.orderkey = o.orderkey AND s.orderkey < 7) FROM lineitem o\", anyTree(node(JoinNode.class, anyTree(tableScan(\"lineitem\")), anyTree(filter(\"orderkey < BIGINT '7'\", tableScan(\"orders\", ImmutableMap.of(\"orderkey\", \"orderkey\")))))));\r\n}"
}, {
	"Path": "io.realm.internal.ColumnInfo.getColumnIndex",
	"Comment": "returns the index, in the described table, for the named column.",
	"Method": "long getColumnIndex(String javaFieldName){\r\n    ColumnDetails details = indicesFromJavaFieldNames.get(javaFieldName);\r\n    return (details == null) ? -1 : details.columnIndex;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.block.BlockEncoding.replacementBlockForWrite",
	"Comment": "this method allows the implementor to specify a replacement object that will be serialized instead of the original one.",
	"Method": "Optional<Block> replacementBlockForWrite(Block block){\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanRenameTable",
	"Comment": "check if identity is allowed to rename the specified table in this catalog.",
	"Method": "void checkCanRenameTable(ConnectorTransactionHandle transactionHandle,Identity identity,SchemaTableName tableName,SchemaTableName newTableName){\r\n    denyRenameTable(tableName.toString(), newTableName.toString());\r\n}"
}, {
	"Path": "io.realm.MutableRealmIntegerTests.copyToIsLive",
	"Comment": "assure that changes to a mutablerealminteger acquired from a managed object are reflected in the object.",
	"Method": "void copyToIsLive(){\r\n    MutableRealmIntegerTypes obj = new MutableRealmIntegerTypes();\r\n    MutableRealmInteger unmanagedRI = obj.getColumnNullableMutableRealmInteger();\r\n    unmanagedRI.set(42L);\r\n    realm.beginTransaction();\r\n    MutableRealmInteger managedRI = realm.copyToRealm(obj).getColumnNullableMutableRealmInteger();\r\n    realm.commitTransaction();\r\n    realm.beginTransaction();\r\n    MutableRealmInteger ri = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();\r\n    ri.set(37);\r\n    ri.increment(17);\r\n    ri.decrement(7);\r\n    realm.commitTransaction();\r\n    assertEquals(Long.valueOf(42L), unmanagedRI.get());\r\n    assertEquals(Long.valueOf(47L), managedRI.get());\r\n}"
}, {
	"Path": "com.facebook.presto.spi.block.MapBlock.createMapBlockInternal",
	"Comment": "create a map block directly without per element validations.internal use by this package and com.facebook.presto.spi.type only.",
	"Method": "MapBlock createMapBlockInternal(int startOffset,int positionCount,Optional<boolean[]> mapIsNull,int[] offsets,Block keyBlock,Block valueBlock,Optional<int[]> hashTables,Type keyType,MethodHandle keyBlockNativeEquals,MethodHandle keyNativeHashCode,MethodHandle keyBlockHashCode){\r\n    validateConstructorArguments(startOffset, positionCount, mapIsNull.orElse(null), offsets, keyBlock, valueBlock, keyType, keyBlockNativeEquals, keyNativeHashCode);\r\n    return new MapBlock(startOffset, positionCount, mapIsNull.orElse(null), offsets, keyBlock, valueBlock, hashTables.orElse(null), keyType, keyBlockNativeEquals, keyNativeHashCode, keyBlockHashCode);\r\n}"
}, {
	"Path": "io.realm.internal.Table.findFirstNull",
	"Comment": "searches for first occurrence of null. beware that the order in the column is undefined.",
	"Method": "long findFirstNull(long columnIndex){\r\n    return nativeFindFirstNull(nativePtr, columnIndex);\r\n}"
}, {
	"Path": "io.realm.SyncConfiguration.getUrlPrefix",
	"Comment": "returns the url prefix used when establishing a sync connection to the realm object server.",
	"Method": "String getUrlPrefix(){\r\n    return syncUrlPrefix;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.filterTables",
	"Comment": "filter the list of tables and views to those visible to the identity.",
	"Method": "Set<SchemaTableName> filterTables(Identity identity,String catalogName,Set<SchemaTableName> tableNames){\r\n    return Collections.emptySet();\r\n}"
}, {
	"Path": "io.realm.RealmTests.closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject",
	"Comment": "tests if close can be called from realm change listener when there is a listener on empty realm object.",
	"Method": "void closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject(){\r\n    final Realm realm = looperThread.getRealm();\r\n    final RealmChangeListener<AllTypes> dummyListener = new RealmChangeListener<AllTypes>() {\r\n        @Override\r\n        public void onChange(AllTypes object) {\r\n        }\r\n    };\r\n    final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {\r\n        @Override\r\n        public void onChange(Realm object) {\r\n            if (realm.where(AllTypes.class).count() == 1) {\r\n                realm.removeChangeListener(this);\r\n                realm.close();\r\n                looperThread.postRunnable(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        looperThread.testComplete();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    };\r\n    realm.addChangeListener(listener);\r\n    final AllTypes allTypes = realm.where(AllTypes.class).findFirstAsync();\r\n    allTypes.addChangeListener(dummyListener);\r\n    realm.executeTransactionAsync(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            realm.createObject(AllTypes.class);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.realm.RealmTests.closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject",
	"Comment": "tests if close can be called from realm change listener when there is a listener on empty realm object.",
	"Method": "void closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject(){\r\n}"
}, {
	"Path": "io.realm.RealmTests.closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject",
	"Comment": "tests if close can be called from realm change listener when there is a listener on empty realm object.",
	"Method": "void closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject(){\r\n    if (realm.where(AllTypes.class).count() == 1) {\r\n        realm.removeChangeListener(this);\r\n        realm.close();\r\n        looperThread.postRunnable(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                looperThread.testComplete();\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmTests.closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject",
	"Comment": "tests if close can be called from realm change listener when there is a listener on empty realm object.",
	"Method": "void closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject(){\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "io.realm.RealmTests.closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject",
	"Comment": "tests if close can be called from realm change listener when there is a listener on empty realm object.",
	"Method": "void closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject(){\r\n    realm.createObject(AllTypes.class);\r\n}"
}, {
	"Path": "io.realm.examples.newsreader.model.Model.getInstance",
	"Comment": "this could be replaced by dependency injection for easier testing",
	"Method": "Model getInstance(){\r\n    if (instance == null) {\r\n        Repository repository = new Repository();\r\n        instance = new Model(repository);\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "io.realm.permissions.PermissionOffer.getRealmUrl",
	"Comment": "returns the realm url for which the permissions are granted.",
	"Method": "String getRealmUrl(){\r\n    return realmUrl;\r\n}"
}, {
	"Path": "io.realm.SyncManager.getAuthorizationHeaderName",
	"Comment": "returns the authentication header name used for the http request to the given url.",
	"Method": "String getAuthorizationHeaderName(URI objectServerUrl){\r\n    String host = objectServerUrl.getHost().toLowerCase(Locale.US);\r\n    String hostRestrictedHeader = hostRestrictedAuthorizationHeaderName.get(host);\r\n    return (hostRestrictedHeader != null) ? hostRestrictedHeader : globalAuthorizationHeaderName;\r\n}"
}, {
	"Path": "io.realm.RealmResults.setObject",
	"Comment": "sets a reference to another object on the given field in all of the objects in the collection.",
	"Method": "void setObject(String fieldName,RealmModel value){\r\n    checkNonEmptyFieldName(fieldName);\r\n    realm.checkIfValidAndInTransaction();\r\n    fieldName = mapFieldNameToInternalName(fieldName);\r\n    checkType(fieldName, RealmFieldType.OBJECT);\r\n    Row row = checkRealmObjectConstraints(fieldName, value);\r\n    osResults.setObject(fieldName, row);\r\n}"
}, {
	"Path": "io.realm.internal.Table.throwDuplicatePrimaryKeyException",
	"Comment": "throws a properly formatted exception when multiple objects with the same primary keyvalue is detected.",
	"Method": "void throwDuplicatePrimaryKeyException(Object value){\r\n    throw new RealmPrimaryKeyConstraintException(\"Value already exists: \" + value);\r\n}"
}, {
	"Path": "io.realm.MutableRealmIntegerTests.isLive",
	"Comment": "assure that changes to a mutablerealminteger acquired from a managed object are reflected in the object.",
	"Method": "void isLive(){\r\n    realm.beginTransaction();\r\n    realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger().set(42);\r\n    realm.commitTransaction();\r\n    MutableRealmInteger managedRI = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();\r\n    realm.beginTransaction();\r\n    MutableRealmInteger ri = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();\r\n    ri.set(37);\r\n    ri.increment(17);\r\n    ri.decrement(7);\r\n    realm.commitTransaction();\r\n    assertEquals(Long.valueOf(47), managedRI.get());\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.getEndValue",
	"Comment": "get the rest value used for determining the displacement of the spring",
	"Method": "double getEndValue(){\r\n    return mEndValue;\r\n}"
}, {
	"Path": "org.redisson.config.BaseMasterSlaveServersConfig.setFailedSlaveCheckInterval",
	"Comment": "redis slave node failing to execute commands is excluded from the internal list of available nodeswhen the time interval from the moment of first redis command execution failureon this server reaches slavefailsinterval value.default is 180000",
	"Method": "T setFailedSlaveCheckInterval(int slaveFailsInterval){\r\n    this.failedSlaveCheckInterval = slaveFailsInterval;\r\n    return (T) this;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorMetadata.revokeTablePrivileges",
	"Comment": "revokes the specified privilege on the specified table from the specified user",
	"Method": "void revokeTablePrivileges(ConnectorSession session,SchemaTableName tableName,Set<Privilege> privileges,String grantee,boolean grantOption){\r\n    throw new PrestoException(NOT_SUPPORTED, \"This connector does not support revokes\");\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanInsertIntoTable",
	"Comment": "check if identity is allowed to insert into the specified table in a catalog.",
	"Method": "void checkCanInsertIntoTable(Identity identity,CatalogSchemaTableName table){\r\n    denyInsertTable(table.toString());\r\n}"
}, {
	"Path": "io.realm.permissions.Permission.getPath",
	"Comment": "returns the path to the realm on the server effected by this permission. this is not the full url.",
	"Method": "String getPath(){\r\n    return path;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.Page.getSingleValuePage",
	"Comment": "gets the values at the specified position as a single element page.the method creates independentcopy of the data.",
	"Method": "Page getSingleValuePage(int position){\r\n    Block[] singleValueBlocks = new Block[this.blocks.length];\r\n    for (int i = 0; i < this.blocks.length; i++) {\r\n        singleValueBlocks[i] = this.blocks[i].getSingleValueBlock(position);\r\n    }\r\n    return new Page(1, singleValueBlocks);\r\n}"
}, {
	"Path": "io.realm.internal.async.RealmThreadPoolExecutor.newSingleThreadExecutor",
	"Comment": "creates a realmthreadpool with only 1 thread. this is primarily useful for testing.",
	"Method": "RealmThreadPoolExecutor newSingleThreadExecutor(){\r\n    return new RealmThreadPoolExecutor(1, 1);\r\n}"
}, {
	"Path": "io.realm.SyncUserTests.currentUser_returnsNullIfUserExpired",
	"Comment": "tests that the userstore does not return users that have expired",
	"Method": "void currentUser_returnsNullIfUserExpired(){\r\n    UserStore userStore = SyncManager.getUserStore();\r\n    userStore.put(createTestUser(Long.MIN_VALUE));\r\n    assertNull(SyncUser.current());\r\n}"
}, {
	"Path": "io.realm.RealmTests.closeRealmInChangeListenerWhenThereIsListenerOnResults",
	"Comment": "tests if close can be called from realm change listener when there is an listener on realmresults.",
	"Method": "void closeRealmInChangeListenerWhenThereIsListenerOnResults(){\r\n    final Realm realm = looperThread.getRealm();\r\n    final RealmChangeListener<RealmResults<AllTypes>> dummyListener = new RealmChangeListener<RealmResults<AllTypes>>() {\r\n        @Override\r\n        public void onChange(RealmResults<AllTypes> object) {\r\n        }\r\n    };\r\n    final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {\r\n        @Override\r\n        public void onChange(Realm object) {\r\n            if (realm.where(AllTypes.class).count() == 1) {\r\n                realm.removeChangeListener(this);\r\n                realm.close();\r\n                looperThread.postRunnable(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        looperThread.testComplete();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    };\r\n    realm.addChangeListener(listener);\r\n    RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();\r\n    results.addChangeListener(dummyListener);\r\n    realm.executeTransactionAsync(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            realm.createObject(AllTypes.class);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.realm.RealmTests.closeRealmInChangeListenerWhenThereIsListenerOnResults",
	"Comment": "tests if close can be called from realm change listener when there is an listener on realmresults.",
	"Method": "void closeRealmInChangeListenerWhenThereIsListenerOnResults(){\r\n}"
}, {
	"Path": "io.realm.RealmTests.closeRealmInChangeListenerWhenThereIsListenerOnResults",
	"Comment": "tests if close can be called from realm change listener when there is an listener on realmresults.",
	"Method": "void closeRealmInChangeListenerWhenThereIsListenerOnResults(){\r\n    if (realm.where(AllTypes.class).count() == 1) {\r\n        realm.removeChangeListener(this);\r\n        realm.close();\r\n        looperThread.postRunnable(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                looperThread.testComplete();\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmTests.closeRealmInChangeListenerWhenThereIsListenerOnResults",
	"Comment": "tests if close can be called from realm change listener when there is an listener on realmresults.",
	"Method": "void closeRealmInChangeListenerWhenThereIsListenerOnResults(){\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "io.realm.RealmTests.closeRealmInChangeListenerWhenThereIsListenerOnResults",
	"Comment": "tests if close can be called from realm change listener when there is an listener on realmresults.",
	"Method": "void closeRealmInChangeListenerWhenThereIsListenerOnResults(){\r\n    realm.createObject(AllTypes.class);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanDropView",
	"Comment": "check if identity is allowed to drop the specified view in a catalog.",
	"Method": "void checkCanDropView(Identity identity,CatalogSchemaTableName view){\r\n    denyDropView(view.toString());\r\n}"
}, {
	"Path": "io.realm.SyncConfigurationTests.multipleUsersReferenceSameRealm",
	"Comment": "own copy on the filesystem. this is e.g. what happens if a realm is shared using a permissionoffer.",
	"Method": "void multipleUsersReferenceSameRealm(){\r\n    SyncUser user1 = createNamedTestUser(\"user1\");\r\n    SyncUser user2 = createNamedTestUser(\"user2\");\r\n    String sharedUrl = \"realm://ros.realm.io/42/default\";\r\n    SyncConfiguration config1 = user1.createConfiguration(sharedUrl).modules(new StringOnlyModule()).build();\r\n    Realm realm1 = Realm.getInstance(config1);\r\n    SyncConfiguration config2 = user2.createConfiguration(sharedUrl).modules(new StringOnlyModule()).build();\r\n    Realm realm2 = null;\r\n    try {\r\n        realm2 = Realm.getInstance(config1);\r\n    } finally {\r\n        realm1.close();\r\n        if (realm2 != null) {\r\n            realm2.close();\r\n        }\r\n    }\r\n    assertNotEquals(config1.getPath(), config2.getPath());\r\n}"
}, {
	"Path": "io.realm.internal.android.ISO8601Utils.indexOfNonDigit",
	"Comment": "returns the index of the first character in the string that is not a digit, starting at offset.",
	"Method": "int indexOfNonDigit(String string,int offset){\r\n    for (int i = offset; i < string.length(); i++) {\r\n        char c = string.charAt(i);\r\n        if (c < '0' || c > '9') {\r\n            return i;\r\n        }\r\n    }\r\n    return string.length();\r\n}"
}, {
	"Path": "com.facebook.presto.sql.ExpressionUtils.removeDuplicates",
	"Comment": "removes duplicate deterministic expressions. preserves the relative orderof the expressions in the list.",
	"Method": "List<Expression> removeDuplicates(List<Expression> expressions){\r\n    Set<Expression> seen = new HashSet();\r\n    ImmutableList.Builder<Expression> result = ImmutableList.builder();\r\n    for (Expression expression : expressions) {\r\n        if (!DeterminismEvaluator.isDeterministic(expression)) {\r\n            result.add(expression);\r\n        } else if (!seen.contains(expression)) {\r\n            result.add(expression);\r\n            seen.add(expression);\r\n        }\r\n    }\r\n    return result.build();\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.setRestDisplacementThreshold",
	"Comment": "set the threshold of displacement from rest below which the spring should be considered at rest",
	"Method": "Spring setRestDisplacementThreshold(double displacementFromRestThreshold){\r\n    mDisplacementFromRestThreshold = displacementFromRestThreshold;\r\n    return this;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.Connector.isSingleStatementWritesOnly",
	"Comment": "true if the connector only supports write statements in independent transactions.",
	"Method": "boolean isSingleStatementWritesOnly(){\r\n    return false;\r\n}"
}, {
	"Path": "io.realm.RealmJsonTests.createOrUpdateObjectFromJson_streamNullValues",
	"Comment": "tests updating a existing object with json stream. only primary key in json.no value should be changed.",
	"Method": "void createOrUpdateObjectFromJson_streamNullValues(){\r\n    assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));\r\n    AllTypesPrimaryKey obj = new AllTypesPrimaryKey();\r\n    Date date = new Date(0);\r\n    obj.setColumnLong(1);\r\n    obj.setColumnBinary(new byte[] { 1 });\r\n    obj.setColumnBoolean(true);\r\n    obj.setColumnDate(date);\r\n    obj.setColumnDouble(1);\r\n    obj.setColumnFloat(1);\r\n    obj.setColumnString(\"1\");\r\n    realm.beginTransaction();\r\n    realm.copyToRealm(obj);\r\n    realm.commitTransaction();\r\n    InputStream in = TestHelper.loadJsonFromAssets(context, \"all_types_primary_key_field_only.json\");\r\n    realm.beginTransaction();\r\n    realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, in);\r\n    realm.commitTransaction();\r\n    in.close();\r\n    obj = realm.where(AllTypesPrimaryKey.class).findFirst();\r\n    assertEquals(\"1\", obj.getColumnString());\r\n    assertEquals(1L, obj.getColumnLong());\r\n    assertEquals(1F, obj.getColumnFloat(), 0F);\r\n    assertEquals(1D, obj.getColumnDouble(), 0D);\r\n    assertEquals(true, obj.isColumnBoolean());\r\n    assertEquals(date, obj.getColumnDate());\r\n    assertArrayEquals(new byte[] { 1 }, obj.getColumnBinary());\r\n    assertNull(obj.getColumnRealmObject());\r\n    assertEquals(0, obj.getColumnRealmList().size());\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanRenameSchema",
	"Comment": "check if identity is allowed to rename the specified schema in a catalog.",
	"Method": "void checkCanRenameSchema(Identity identity,CatalogSchemaName schema,String newSchemaName){\r\n    denyRenameSchema(schema.toString(), newSchemaName);\r\n}"
}, {
	"Path": "com.facebook.presto.operator.WindowOperator.findGroupEnd",
	"Comment": "assumes input grouped on relevant pageshashstrategy columns",
	"Method": "int findGroupEnd(Page page,PagesHashStrategy pagesHashStrategy,int startPosition,int findGroupEnd,PagesIndex pagesIndex,PagesHashStrategy pagesHashStrategy,int startPosition){\r\n    checkArgument(pagesIndex.getPositionCount() > 0, \"Must have at least one position\");\r\n    checkPositionIndex(startPosition, pagesIndex.getPositionCount(), \"startPosition out of bounds\");\r\n    return findEndPosition(startPosition, pagesIndex.getPositionCount(), (firstPosition, secondPosition) -> pagesIndex.positionEqualsPosition(pagesHashStrategy, firstPosition, secondPosition));\r\n}"
}, {
	"Path": "io.realm.examples.arch.utils.ContextUtils.findActivity",
	"Comment": "finds the activity inside the hierarchy of the provided context.",
	"Method": "T findActivity(Context context){\r\n    if (context instanceof Activity) {\r\n        return (T) context;\r\n    }\r\n    while (context != null && context instanceof ContextWrapper) {\r\n        context = ((ContextWrapper) context).getBaseContext();\r\n        if (context instanceof Activity) {\r\n            return (T) context;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"No activity found in context hierarchy.\");\r\n}"
}, {
	"Path": "io.realm.internal.Table.renameColumn",
	"Comment": "renames a column in the table. if the column is a primary key column, the corresponding entryin primarykeytable will be renamed accordingly.",
	"Method": "void renameColumn(long columnIndex,String newName){\r\n    verifyColumnName(newName);\r\n    final String oldName = nativeGetColumnName(nativePtr, columnIndex);\r\n    final String pkName = OsObjectStore.getPrimaryKeyForObject(sharedRealm, getClassName());\r\n    nativeRenameColumn(nativePtr, columnIndex, newName);\r\n    if (oldName.equals(pkName)) {\r\n        try {\r\n            OsObjectStore.setPrimaryKeyForObject(sharedRealm, getClassName(), newName);\r\n        } catch (Exception e) {\r\n            nativeRenameColumn(nativePtr, columnIndex, oldName);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.SyncUser.toJson",
	"Comment": "returns a json token representing this user.possession of this json token can potentially grant access to data stored on the realm object server, so itshould be treated as sensitive data.",
	"Method": "String toJson(){\r\n    JSONObject obj = new JSONObject();\r\n    try {\r\n        obj.put(\"authUrl\", authenticationUrl);\r\n        obj.put(\"userToken\", refreshToken.toJson());\r\n        return obj.toString();\r\n    } catch (JSONException e) {\r\n        throw new RuntimeException(\"Could not convert SyncUser to JSON\", e);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanSetCatalogSessionProperty",
	"Comment": "check if identity is allowed to set the specified property in a catalog.",
	"Method": "void checkCanSetCatalogSessionProperty(Identity identity,String catalogName,String propertyName){\r\n    denySetCatalogSessionProperty(propertyName);\r\n}"
}, {
	"Path": "io.realm.DynamicRealmObjectTests.callSetter",
	"Comment": "helper method for calling setters with different field names.",
	"Method": "void callSetter(DynamicRealmObject target,SupportedType type,List<String> fieldNames){\r\n    for (String fieldName : fieldNames) {\r\n        switch(type) {\r\n            case BOOLEAN:\r\n                target.setBoolean(fieldName, false);\r\n                break;\r\n            case SHORT:\r\n                target.setShort(fieldName, (short) 1);\r\n                break;\r\n            case INT:\r\n                target.setInt(fieldName, 1);\r\n                break;\r\n            case LONG:\r\n                target.setLong(fieldName, 1L);\r\n                break;\r\n            case BYTE:\r\n                target.setByte(fieldName, (byte) 4);\r\n                break;\r\n            case FLOAT:\r\n                target.setFloat(fieldName, 1.23f);\r\n                break;\r\n            case DOUBLE:\r\n                target.setDouble(fieldName, 1.23d);\r\n                break;\r\n            case STRING:\r\n                target.setString(fieldName, \"foo\");\r\n                break;\r\n            case BINARY:\r\n                target.setBlob(fieldName, new byte[] {});\r\n                break;\r\n            case DATE:\r\n                target.getDate(fieldName);\r\n                break;\r\n            case OBJECT:\r\n                target.setObject(fieldName, null);\r\n                target.setObject(fieldName, target);\r\n                break;\r\n            case LIST:\r\n                target.setList(fieldName, new RealmList<DynamicRealmObject>());\r\n                break;\r\n            case LIST_INTEGER:\r\n                target.setList(fieldName, new RealmList<Integer>(1));\r\n                break;\r\n            case LIST_STRING:\r\n                target.setList(fieldName, new RealmList<String>(\"foo\"));\r\n                break;\r\n            case LIST_BOOLEAN:\r\n                target.setList(fieldName, new RealmList<Boolean>(true));\r\n                break;\r\n            case LIST_FLOAT:\r\n                target.setList(fieldName, new RealmList<Float>(1.23F));\r\n                break;\r\n            case LIST_DOUBLE:\r\n                target.setList(fieldName, new RealmList<Double>(1.234D));\r\n                break;\r\n            case LIST_BINARY:\r\n                target.setList(fieldName, new RealmList<byte[]>(new byte[] {}));\r\n                break;\r\n            case LIST_DATE:\r\n                target.setList(fieldName, new RealmList<Date>(new Date()));\r\n                break;\r\n            default:\r\n                fail();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.internal.network.AuthenticateResponse.from",
	"Comment": "helper method for creating the proper authenticate response. this method will set the appropriate errordepending on any http response codes or io errors.",
	"Method": "AuthenticateResponse from(Response response,AuthenticateResponse from,String json,AuthenticateResponse from,ObjectServerError error,AuthenticateResponse from,Exception exception){\r\n    return AuthenticateResponse.from(new ObjectServerError(ErrorCode.fromException(exception), exception));\r\n}"
}, {
	"Path": "com.facebook.rebound.SpringSystem.create",
	"Comment": "create a new springsystem providing the appropriate constructor parameters to work properlyin an android environment.",
	"Method": "SpringSystem create(){\r\n    return new SpringSystem(AndroidSpringLooperFactory.createSpringLooper());\r\n}"
}, {
	"Path": "io.realm.ManagedOrderedRealmCollectionTests.mutableMethodsOutsideTransactions",
	"Comment": "due to implementation details both unsupportedoperation and illegalstate is accepted at this level.",
	"Method": "void mutableMethodsOutsideTransactions(){\r\n    for (OrderedCollectionMutatorMethod method : OrderedCollectionMutatorMethod.values()) {\r\n        Class<? extends Throwable> expected = IllegalStateException.class;\r\n        if (collectionClass == ManagedCollection.REALMRESULTS || isSnapshot(collectionClass)) {\r\n            switch(method) {\r\n                case ADD_INDEX:\r\n                case ADD_ALL_INDEX:\r\n                case SET:\r\n                case REMOVE_INDEX:\r\n                    expected = UnsupportedOperationException.class;\r\n                    break;\r\n                default:\r\n            }\r\n        }\r\n        try {\r\n            switch(method) {\r\n                case DELETE_INDEX:\r\n                    collection.deleteFromRealm(0);\r\n                    break;\r\n                case DELETE_FIRST:\r\n                    collection.deleteFirstFromRealm();\r\n                    break;\r\n                case DELETE_LAST:\r\n                    collection.deleteLastFromRealm();\r\n                    break;\r\n                case ADD_INDEX:\r\n                    collection.add(0, new AllJavaTypes());\r\n                    break;\r\n                case ADD_ALL_INDEX:\r\n                    collection.addAll(0, Collections.singletonList(new AllJavaTypes()));\r\n                    break;\r\n                case SET:\r\n                    collection.set(0, new AllJavaTypes());\r\n                    break;\r\n                case REMOVE_INDEX:\r\n                    collection.remove(0);\r\n                    break;\r\n            }\r\n            fail(\"Unknown method or it failed to throw: \" + method);\r\n        } catch (IllegalStateException e) {\r\n            assertEquals(expected, e.getClass());\r\n        } catch (UnsupportedOperationException e) {\r\n            assertEquals(expected, e.getClass());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.metadata.TestInformationSchemaMetadata.testInformationSchemaPredicatePushdown",
	"Comment": "tests information schema predicate pushdown when both schema and table name are specified.",
	"Method": "void testInformationSchemaPredicatePushdown(){\r\n    TransactionId transactionId = transactionManager.beginTransaction(false);\r\n    ImmutableMap.Builder<ColumnHandle, Domain> domains = new ImmutableMap.Builder();\r\n    domains.put(new InformationSchemaColumnHandle(\"table_schema\"), Domain.singleValue(VARCHAR, Slices.utf8Slice(\"test_schema\")));\r\n    domains.put(new InformationSchemaColumnHandle(\"table_name\"), Domain.singleValue(VARCHAR, Slices.utf8Slice(\"test_view\")));\r\n    Constraint<ColumnHandle> constraint = new Constraint(TupleDomain.withColumnDomains(domains.build()));\r\n    InformationSchemaMetadata informationSchemaMetadata = new InformationSchemaMetadata(\"test_catalog\", metadata);\r\n    List<ConnectorTableLayoutResult> layoutResults = informationSchemaMetadata.getTableLayouts(createNewSession(transactionId), new InformationSchemaTableHandle(\"test_catalog\", \"information_schema\", \"views\"), constraint, Optional.empty());\r\n    assertEquals(layoutResults.size(), 1);\r\n    ConnectorTableLayoutHandle handle = layoutResults.get(0).getTableLayout().getHandle();\r\n    assertTrue(handle instanceof InformationSchemaTableLayoutHandle);\r\n    InformationSchemaTableLayoutHandle tableHandle = (InformationSchemaTableLayoutHandle) handle;\r\n    assertEquals(tableHandle.getPrefixes(), ImmutableSet.of(new QualifiedTablePrefix(\"test_catalog\", \"test_schema\", \"test_view\")));\r\n}"
}, {
	"Path": "io.realm.BaseRealm.checkNotInSync",
	"Comment": "checks if the realm is not built with a syncrealmconfiguration.",
	"Method": "void checkNotInSync(){\r\n    if (configuration.isSyncConfiguration()) {\r\n        throw new IllegalArgumentException(\"You cannot perform changes to a schema. \" + \"Please update app and restart.\");\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spi.type.MapType.createMapBlockInternal",
	"Comment": "create a map block directly without per element validations.internal use by com.facebook.presto.spi.block only.",
	"Method": "Block createMapBlockInternal(TypeManager typeManager,Type keyType,int startOffset,int positionCount,Optional<boolean[]> mapIsNull,int[] offsets,Block keyBlock,Block valueBlock,Optional<int[]> hashTables){\r\n    MapType mapType = (MapType) typeManager.getType(new TypeSignature(StandardTypes.MAP, TypeSignatureParameter.of(keyType.getTypeSignature()), TypeSignatureParameter.of(BIGINT.getTypeSignature())));\r\n    return MapBlock.createMapBlockInternal(startOffset, positionCount, mapIsNull, offsets, keyBlock, valueBlock, hashTables, keyType, mapType.keyBlockNativeEquals, mapType.keyNativeHashCode, mapType.keyBlockHashCode);\r\n}"
}, {
	"Path": "io.realm.DynamicRealmTests.deleteRealm_ThrowsIfDynamicRealmIsOpen",
	"Comment": "tests that realms can only be deleted after all typed and dynamic instances are closed.",
	"Method": "void deleteRealm_ThrowsIfDynamicRealmIsOpen(){\r\n    realm.close();\r\n    Realm typedRealm = Realm.getInstance(defaultConfig);\r\n    DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);\r\n    typedRealm.close();\r\n    try {\r\n        Realm.deleteRealm(defaultConfig);\r\n        fail();\r\n    } catch (IllegalStateException ignored) {\r\n    }\r\n    dynamicRealm.close();\r\n    assertTrue(Realm.deleteRealm(defaultConfig));\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanDropSchema",
	"Comment": "check if identity is allowed to drop the specified schema in a catalog.",
	"Method": "void checkCanDropSchema(Identity identity,CatalogSchemaName schema){\r\n    denyDropSchema(schema.toString());\r\n}"
}, {
	"Path": "com.facebook.presto.orc.TestStructStreamReader.testValuesAreReadInCorrectly",
	"Comment": "reader and writer have the same fields. checks that fields are read in correctly",
	"Method": "void testValuesAreReadInCorrectly(){\r\n    List<String> readerFields = new ArrayList(Arrays.asList(\"field_a\", \"field_b\", \"field_c\"));\r\n    List<String> writerFields = new ArrayList(Arrays.asList(\"field_a\", \"field_b\", \"field_c\"));\r\n    List<String> writerData = new ArrayList(Arrays.asList(\"field_a_value\", \"field_b_value\", \"field_c_value\"));\r\n    Type readerType = getType(readerFields);\r\n    Type writerType = getType(writerFields);\r\n    write(tempFile, writerType, writerData);\r\n    RowBlock readBlock = read(tempFile, readerType);\r\n    List actual = (List) readerType.getObjectValue(SESSION, readBlock, 0);\r\n    assertEquals(actual.size(), readerFields.size());\r\n    assertEquals(actual.get(0), \"field_a_value\");\r\n    assertEquals(actual.get(1), \"field_b_value\");\r\n    assertEquals(actual.get(2), \"field_c_value\");\r\n}"
}, {
	"Path": "org.redisson.config.Config.setReferenceEnabled",
	"Comment": "config option for enabling redisson reference featuredefault value is true",
	"Method": "void setReferenceEnabled(boolean redissonReferenceEnabled){\r\n    this.referenceEnabled = redissonReferenceEnabled;\r\n}"
}, {
	"Path": "io.realm.RealmTests.init_waitForFilesDir",
	"Comment": "this is pretty hard to test, so forced to break encapsulation in this case.",
	"Method": "void init_waitForFilesDir(){\r\n    java.lang.reflect.Method m = Realm.class.getDeclaredMethod(\"checkFilesDirAvailable\", Context.class);\r\n    m.setAccessible(true);\r\n    Context mockContext = mock(Context.class);\r\n    when(mockContext.getFilesDir()).thenReturn(null);\r\n    try {\r\n        m.invoke(null, mockContext);\r\n        fail();\r\n    } catch (InvocationTargetException e) {\r\n        assertEquals(IllegalStateException.class, e.getCause().getClass());\r\n    }\r\n    mockContext = mock(Context.class);\r\n    when(mockContext.getFilesDir()).then(new Answer<File>() {\r\n        int calls = 0;\r\n        File userFolder = tmpFolder.newFolder();\r\n        @Override\r\n        public File answer(InvocationOnMock invocationOnMock) throws Throwable {\r\n            calls++;\r\n            return (calls > 5) ? userFolder : null;\r\n        }\r\n    });\r\n    assertNull(m.invoke(null, mockContext));\r\n}"
}, {
	"Path": "io.realm.RealmTests.init_waitForFilesDir",
	"Comment": "this is pretty hard to test, so forced to break encapsulation in this case.",
	"Method": "void init_waitForFilesDir(){\r\n    calls++;\r\n    return (calls > 5) ? userFolder : null;\r\n}"
}, {
	"Path": "io.realm.SyncConfiguration.isFullySynchronizedRealm",
	"Comment": "returns whether this configuration is for a fully synchronized realm or not.",
	"Method": "boolean isFullySynchronizedRealm(){\r\n    return !isPartial;\r\n}"
}, {
	"Path": "io.realm.sync.permissions.Role.addMember",
	"Comment": "adds a member to this role. must be done from within a write transaction.",
	"Method": "void addMember(String userId){\r\n    if (isManaged()) {\r\n        if (Util.isEmptyString(userId)) {\r\n            throw new IllegalArgumentException(\"Non-empty 'userId' required\");\r\n        }\r\n        Realm realm = getRealm();\r\n        PermissionUser user = realm.where(PermissionUser.class).equalTo(\"id\", userId).findFirst();\r\n        if (user == null) {\r\n            user = realm.createObject(PermissionUser.class, userId);\r\n        }\r\n        members.add(user);\r\n    } else {\r\n        throw new IllegalStateException(\"Can not add a member to a non managed Role\");\r\n    }\r\n}"
}, {
	"Path": "io.realm.BaseRealm.migrateRealm",
	"Comment": "migrates the realm file defined by the given configuration using the provided migration block.",
	"Method": "void migrateRealm(RealmConfiguration configuration,RealmMigration migration){\r\n    if (configuration == null) {\r\n        throw new IllegalArgumentException(\"RealmConfiguration must be provided\");\r\n    }\r\n    if (configuration.isSyncConfiguration()) {\r\n        throw new IllegalArgumentException(\"Manual migrations are not supported for synced Realms\");\r\n    }\r\n    if (migration == null && configuration.getMigration() == null) {\r\n        throw new RealmMigrationNeededException(configuration.getPath(), \"RealmMigration must be provided.\");\r\n    }\r\n    final AtomicBoolean fileNotFound = new AtomicBoolean(false);\r\n    RealmCache.invokeWithGlobalRefCount(configuration, new RealmCache.Callback() {\r\n        @Override\r\n        public void onResult(int count) {\r\n            if (count != 0) {\r\n                throw new IllegalStateException(\"Cannot migrate a Realm file that is already open: \" + configuration.getPath());\r\n            }\r\n            File realmFile = new File(configuration.getPath());\r\n            if (!realmFile.exists()) {\r\n                fileNotFound.set(true);\r\n                return;\r\n            }\r\n            RealmProxyMediator mediator = configuration.getSchemaMediator();\r\n            OsSchemaInfo schemaInfo = new OsSchemaInfo(mediator.getExpectedObjectSchemaInfoMap().values());\r\n            OsSharedRealm.MigrationCallback migrationCallback = null;\r\n            final RealmMigration migrationToBeApplied = migration != null ? migration : configuration.getMigration();\r\n            if (migrationToBeApplied != null) {\r\n                migrationCallback = createMigrationCallback(migrationToBeApplied);\r\n            }\r\n            OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(configuration).autoUpdateNotification(false).schemaInfo(schemaInfo).migrationCallback(migrationCallback);\r\n            OsSharedRealm sharedRealm = null;\r\n            try {\r\n                sharedRealm = OsSharedRealm.getInstance(configBuilder);\r\n            } finally {\r\n                if (sharedRealm != null) {\r\n                    sharedRealm.close();\r\n                }\r\n            }\r\n        }\r\n    });\r\n    if (fileNotFound.get()) {\r\n        throw new FileNotFoundException(\"Cannot migrate a Realm file which doesn't exist: \" + configuration.getPath());\r\n    }\r\n}"
}, {
	"Path": "io.realm.BaseRealm.migrateRealm",
	"Comment": "migrates the realm file defined by the given configuration using the provided migration block.",
	"Method": "void migrateRealm(RealmConfiguration configuration,RealmMigration migration){\r\n    if (count != 0) {\r\n        throw new IllegalStateException(\"Cannot migrate a Realm file that is already open: \" + configuration.getPath());\r\n    }\r\n    File realmFile = new File(configuration.getPath());\r\n    if (!realmFile.exists()) {\r\n        fileNotFound.set(true);\r\n        return;\r\n    }\r\n    RealmProxyMediator mediator = configuration.getSchemaMediator();\r\n    OsSchemaInfo schemaInfo = new OsSchemaInfo(mediator.getExpectedObjectSchemaInfoMap().values());\r\n    OsSharedRealm.MigrationCallback migrationCallback = null;\r\n    final RealmMigration migrationToBeApplied = migration != null ? migration : configuration.getMigration();\r\n    if (migrationToBeApplied != null) {\r\n        migrationCallback = createMigrationCallback(migrationToBeApplied);\r\n    }\r\n    OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(configuration).autoUpdateNotification(false).schemaInfo(schemaInfo).migrationCallback(migrationCallback);\r\n    OsSharedRealm sharedRealm = null;\r\n    try {\r\n        sharedRealm = OsSharedRealm.getInstance(configBuilder);\r\n    } finally {\r\n        if (sharedRealm != null) {\r\n            sharedRealm.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.redisson.api.LocalCachedMapOptions.maxIdle",
	"Comment": "sets max idle time for each map entry in cache.if value equals to 0 then timeout is not applied",
	"Method": "LocalCachedMapOptions<K, V> maxIdle(long maxIdleInMillis,LocalCachedMapOptions<K, V> maxIdle,long maxIdle,TimeUnit timeUnit){\r\n    return maxIdle(timeUnit.toMillis(maxIdle));\r\n}"
}, {
	"Path": "io.realm.processor.ModuleMetaData.postProcess",
	"Comment": "all model classes have now been processed and the final validation of modules can occur.any errors or messages will be posted on the provided messager.",
	"Method": "boolean postProcess(ClassCollection modelClasses){\r\n    for (String qualifiedModuleClassName : globalModules) {\r\n        Set<ClassMetaData> classData = new LinkedHashSet();\r\n        classData.addAll(modelClasses.getClasses());\r\n        defineModule(qualifiedModuleClassName, classData);\r\n    }\r\n    for (Map.Entry<String, Set<String>> module : specificClassesModules.entrySet()) {\r\n        String qualifiedModuleClassName = module.getKey();\r\n        Set<ClassMetaData> classData = new LinkedHashSet();\r\n        for (String qualifiedModelClassName : module.getValue()) {\r\n            if (!modelClasses.containsQualifiedClass(qualifiedModelClassName)) {\r\n                Utils.error(Utils.stripPackage(qualifiedModelClassName) + \" could not be added to the module. \" + \"Only classes extending RealmObject or implementing RealmModel, which are part of this project, can be added.\");\r\n                return false;\r\n            }\r\n            classData.add(modelClasses.getClassFromQualifiedName(qualifiedModelClassName));\r\n        }\r\n        defineModule(qualifiedModuleClassName, classData);\r\n    }\r\n    if (modules.size() > 0 && libraryModules.size() > 0) {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"Normal modules and library modules cannot be mixed in the same project.\");\r\n        sb.append('\\n');\r\n        sb.append(\"Normal module(s):\\n\");\r\n        for (String module : modules.keySet()) {\r\n            sb.append(\"  \");\r\n            sb.append(module);\r\n            sb.append('\\n');\r\n        }\r\n        sb.append(\"Library module(s):\\n\");\r\n        for (String module : libraryModules.keySet()) {\r\n            sb.append(\"  \");\r\n            sb.append(module);\r\n            sb.append('\\n');\r\n        }\r\n        Utils.error(sb.toString());\r\n        return false;\r\n    }\r\n    if (libraryModules.size() == 0 && modelClasses.size() > 0) {\r\n        shouldCreateDefaultModule = true;\r\n        String defaultModuleName = Constants.REALM_PACKAGE_NAME + \".\" + Constants.DEFAULT_MODULE_CLASS_NAME;\r\n        modules.put(defaultModuleName, modelClasses.getClasses());\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.realm.MutableRealmIntegerTests.updateOutsideTransactionThrows",
	"Comment": "assure that an attempt to change the value of a managed mutablerealminteger, outside a transaction, fails.",
	"Method": "void updateOutsideTransactionThrows(){\r\n    realm.beginTransaction();\r\n    realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger().set(42);\r\n    realm.commitTransaction();\r\n    MutableRealmInteger managedRI = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();\r\n    try {\r\n        managedRI.set(1);\r\n        fail(\"Setting a managed MutableRealmInteger outside a transaction should fail\");\r\n    } catch (IllegalStateException e) {\r\n        checkTransactionException(e);\r\n    }\r\n    try {\r\n        managedRI.increment(1);\r\n        fail(\"Incrementing a managed MutableRealmInteger outside a transaction should fail\");\r\n    } catch (IllegalStateException e) {\r\n        checkTransactionException(e);\r\n    }\r\n    try {\r\n        managedRI.decrement(1);\r\n        fail(\"Decrementing a managed MutableRealmInteger outside a transaction should fail\");\r\n    } catch (IllegalStateException e) {\r\n        checkTransactionException(e);\r\n    }\r\n}"
}, {
	"Path": "io.realm.SyncedRealmMigrationTests.moreFieldsThanExpectedIsAllowed",
	"Comment": "the remote realm containing more field than the local typed realm defined is allowed.",
	"Method": "void moreFieldsThanExpectedIsAllowed(){\r\n    SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), \"http://foo.com/auth\").schema(StringOnly.class).build();\r\n    Realm.getInstance(config).close();\r\n    DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);\r\n    dynamicRealm.beginTransaction();\r\n    RealmObjectSchema objectSchema = dynamicRealm.getSchema().get(StringOnly.CLASS_NAME);\r\n    objectSchema.addField(\"oneMoreField\", int.class);\r\n    dynamicRealm.commitTransaction();\r\n    dynamicRealm.close();\r\n    Realm realm = Realm.getInstance(config);\r\n    realm.close();\r\n}"
}, {
	"Path": "io.realm.RealmConfigurationTests.constructBuilder_differentDirSameName",
	"Comment": "it is allowed to create multiple realm with same name but in different directory.",
	"Method": "void constructBuilder_differentDirSameName(){\r\n    RealmConfiguration config1 = configFactory.createConfigurationBuilder().directory(configFactory.getRoot()).build();\r\n    RealmConfiguration config2 = configFactory.createConfigurationBuilder().directory(configFactory.newFolder()).build();\r\n    Realm realm1 = Realm.getInstance(config1);\r\n    Realm realm2 = Realm.getInstance(config2);\r\n    realm1.close();\r\n    realm2.close();\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.setCurrentValue",
	"Comment": "the full signature for setcurrentvalue includes the option of not setting the spring at restafter updating its currentvalue. passing setatrest false means that if the endvalue of thespring is not equal to the currentvalue, the physics system will start iterating to resolvethe spring to the end value. this is almost never the behavior that you want, so the defaultsetcurrentvalue signature passes true.",
	"Method": "Spring setCurrentValue(double currentValue,Spring setCurrentValue,double currentValue,boolean setAtRest){\r\n    mStartValue = currentValue;\r\n    mCurrentState.position = currentValue;\r\n    mSpringSystem.activateSpring(this.getId());\r\n    for (SpringListener listener : mListeners) {\r\n        listener.onSpringUpdate(this);\r\n    }\r\n    if (setAtRest) {\r\n        setAtRest();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "io.realm.RealmTests.waitForChange_blockSpecificThreadOnly",
	"Comment": "tests if waitforchange still blocks if stopwaitforchange has been called for a realm in a different thread.",
	"Method": "void waitForChange_blockSpecificThreadOnly(){\r\n    final CountDownLatch bgRealmsOpened = new CountDownLatch(2);\r\n    final CountDownLatch bgRealmsClosed = new CountDownLatch(2);\r\n    final AtomicBoolean bgRealmFirstWaitResult = new AtomicBoolean(true);\r\n    final AtomicBoolean bgRealmSecondWaitResult = new AtomicBoolean(false);\r\n    final AtomicLong bgRealmWaitForChangeResult = new AtomicLong(0);\r\n    final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();\r\n    Thread thread1 = new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            Realm realm = Realm.getInstance(realmConfig);\r\n            bgRealm.set(realm);\r\n            bgRealmsOpened.countDown();\r\n            bgRealmFirstWaitResult.set(realm.waitForChange());\r\n            realm.close();\r\n            bgRealmsClosed.countDown();\r\n        }\r\n    });\r\n    Thread thread2 = new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            Realm realm = Realm.getInstance(realmConfig);\r\n            bgRealmsOpened.countDown();\r\n            bgRealmSecondWaitResult.set(realm.waitForChange());\r\n            bgRealmWaitForChangeResult.set(realm.where(AllTypes.class).count());\r\n            realm.close();\r\n            bgRealmsClosed.countDown();\r\n        }\r\n    });\r\n    thread1.start();\r\n    thread2.start();\r\n    TestHelper.awaitOrFail(bgRealmsOpened);\r\n    bgRealm.get().stopWaitForChange();\r\n    Thread.sleep(500);\r\n    populateTestRealm();\r\n    TestHelper.awaitOrFail(bgRealmsClosed);\r\n    assertFalse(bgRealmFirstWaitResult.get());\r\n    assertTrue(bgRealmSecondWaitResult.get());\r\n    assertEquals(TEST_DATA_SIZE, bgRealmWaitForChangeResult.get());\r\n}"
}, {
	"Path": "io.realm.RealmTests.waitForChange_blockSpecificThreadOnly",
	"Comment": "tests if waitforchange still blocks if stopwaitforchange has been called for a realm in a different thread.",
	"Method": "void waitForChange_blockSpecificThreadOnly(){\r\n    Realm realm = Realm.getInstance(realmConfig);\r\n    bgRealm.set(realm);\r\n    bgRealmsOpened.countDown();\r\n    bgRealmFirstWaitResult.set(realm.waitForChange());\r\n    realm.close();\r\n    bgRealmsClosed.countDown();\r\n}"
}, {
	"Path": "io.realm.RealmTests.waitForChange_blockSpecificThreadOnly",
	"Comment": "tests if waitforchange still blocks if stopwaitforchange has been called for a realm in a different thread.",
	"Method": "void waitForChange_blockSpecificThreadOnly(){\r\n    Realm realm = Realm.getInstance(realmConfig);\r\n    bgRealmsOpened.countDown();\r\n    bgRealmSecondWaitResult.set(realm.waitForChange());\r\n    bgRealmWaitForChangeResult.set(realm.where(AllTypes.class).count());\r\n    realm.close();\r\n    bgRealmsClosed.countDown();\r\n}"
}, {
	"Path": "io.realm.TestHelper.getFailureLogger",
	"Comment": "returns a realmlogger that will fail if it is asked to log a message above a certain level.",
	"Method": "RealmLogger getFailureLogger(int failureLevel){\r\n    return new RealmLogger() {\r\n        private void failIfEqualOrAbove(int logLevel) {\r\n            if (logLevel >= failureLevel) {\r\n                fail(\"Message logged that was above valid level: \" + logLevel + \" >= \" + failureLevel);\r\n            }\r\n        }\r\n        @Override\r\n        public void log(int level, String tag, Throwable throwable, String message) {\r\n            failIfEqualOrAbove(level);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.realm.TestHelper.getFailureLogger",
	"Comment": "returns a realmlogger that will fail if it is asked to log a message above a certain level.",
	"Method": "RealmLogger getFailureLogger(int failureLevel){\r\n    if (logLevel >= failureLevel) {\r\n        fail(\"Message logged that was above valid level: \" + logLevel + \" >= \" + failureLevel);\r\n    }\r\n}"
}, {
	"Path": "io.realm.TestHelper.getFailureLogger",
	"Comment": "returns a realmlogger that will fail if it is asked to log a message above a certain level.",
	"Method": "RealmLogger getFailureLogger(int failureLevel){\r\n    failIfEqualOrAbove(level);\r\n}"
}, {
	"Path": "io.realm.RealmTests.copyToRealmOrUpdate_iterableChildObjects",
	"Comment": "tests that a collection of objects with references all gets copied.",
	"Method": "void copyToRealmOrUpdate_iterableChildObjects(){\r\n    DogPrimaryKey dog = new DogPrimaryKey(1, \"Snoop\");\r\n    AllTypesPrimaryKey allTypes1 = new AllTypesPrimaryKey();\r\n    allTypes1.setColumnLong(1);\r\n    allTypes1.setColumnRealmObject(dog);\r\n    AllTypesPrimaryKey allTypes2 = new AllTypesPrimaryKey();\r\n    allTypes1.setColumnLong(2);\r\n    allTypes2.setColumnRealmObject(dog);\r\n    realm.beginTransaction();\r\n    realm.copyToRealmOrUpdate(Arrays.asList(allTypes1, allTypes2));\r\n    realm.commitTransaction();\r\n    assertEquals(2, realm.where(AllTypesPrimaryKey.class).count());\r\n    assertEquals(1, realm.where(DogPrimaryKey.class).count());\r\n}"
}, {
	"Path": "io.realm.processor.ModuleMetaData.preProcess",
	"Comment": "builds all meta data structures that can be calculated before processing any model classes.any errors or messages will be posted on the provided messager.",
	"Method": "boolean preProcess(Set<? extends Element> moduleClasses){\r\n    Set<ModulePolicyInfo> globalModuleInfo = new HashSet();\r\n    Map<String, List<ModulePolicyInfo>> classSpecificModuleInfo = new HashMap();\r\n    for (Element classElement : moduleClasses) {\r\n        String classSimpleName = classElement.getSimpleName().toString();\r\n        if (!classElement.getKind().equals(ElementKind.CLASS)) {\r\n            Utils.error(\"The RealmModule annotation can only be applied to classes\", classElement);\r\n            return false;\r\n        }\r\n        RealmModule moduleAnnotation = classElement.getAnnotation(RealmModule.class);\r\n        Utils.note(\"Processing module \" + classSimpleName);\r\n        if (moduleAnnotation.allClasses() && hasCustomClassList(classElement)) {\r\n            Utils.error(\"Setting @RealmModule(allClasses=true) will override @RealmModule(classes={...}) in \" + classSimpleName);\r\n            return false;\r\n        }\r\n        if (!validateNamingPolicies(globalModuleInfo, classSpecificModuleInfo, (TypeElement) classElement, moduleAnnotation)) {\r\n            return false;\r\n        }\r\n        moduleAnnotations.put(((TypeElement) classElement).getQualifiedName().toString(), moduleAnnotation);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_notSentOnUnrelatedChangeRealmResults",
	"Comment": "a listener registered on the backlinked object should not called for an unrelated change",
	"Method": "void notification_notSentOnUnrelatedChangeRealmResults(){\r\n    final Realm looperThreadRealm = looperThread.getRealm();\r\n    looperThreadRealm.beginTransaction();\r\n    AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);\r\n    AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);\r\n    looperThreadRealm.commitTransaction();\r\n    RealmChangeListener<RealmResults<AllJavaTypes>> listener = new RealmChangeListener<RealmResults<AllJavaTypes>>() {\r\n        @Override\r\n        public void onChange(RealmResults<AllJavaTypes> object) {\r\n            fail(\"Not expecting notification after unregister\");\r\n        }\r\n    };\r\n    child.getObjectParents().addChangeListener(listener);\r\n    looperThreadRealm.beginTransaction();\r\n    looperThreadRealm.where(AllJavaTypes.class).equalTo(\"fieldId\", 1).findAll().deleteAllFromRealm();\r\n    looperThreadRealm.commitTransaction();\r\n    verifyPostConditions(looperThreadRealm, new PostConditions() {\r\n        @Override\r\n        public void run(Realm realm) {\r\n            assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());\r\n        }\r\n    }, child, parent);\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_notSentOnUnrelatedChangeRealmResults",
	"Comment": "a listener registered on the backlinked object should not called for an unrelated change",
	"Method": "void notification_notSentOnUnrelatedChangeRealmResults(){\r\n    fail(\"Not expecting notification after unregister\");\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_notSentOnUnrelatedChangeRealmResults",
	"Comment": "a listener registered on the backlinked object should not called for an unrelated change",
	"Method": "void notification_notSentOnUnrelatedChangeRealmResults(){\r\n    assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());\r\n}"
}, {
	"Path": "com.facebook.rebound.ui.SpringConfiguratorView.destroy",
	"Comment": "remove the configurator from its parent and clean up springs and listeners",
	"Method": "void destroy(){\r\n    ViewGroup parent = (ViewGroup) getParent();\r\n    if (parent != null) {\r\n        parent.removeView(this);\r\n    }\r\n    mRevealerSpring.destroy();\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.migrationRequired_throwsOriginalException",
	"Comment": "original realmmigrationneededexception is thrown instead of illegalargumentexception",
	"Method": "void migrationRequired_throwsOriginalException(){\r\n    RealmConfiguration config = // .migration() No migration block provided, but one is required\r\n    configFactory.createConfigurationBuilder().assetFile(\"default0.realm\").build();\r\n    Realm realm = null;\r\n    try {\r\n        realm = Realm.getInstance(config);\r\n        fail();\r\n    } catch (RealmMigrationNeededException ignored) {\r\n    } finally {\r\n        if (realm != null) {\r\n            realm.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spi.predicate.TupleDomain.isNone",
	"Comment": "returns true if no tuple could ever satisfy this tupledomain",
	"Method": "boolean isNone(){\r\n    return !domains.isPresent();\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanCreateTable",
	"Comment": "check if identity is allowed to create the specified table in this catalog.",
	"Method": "void checkCanCreateTable(ConnectorTransactionHandle transactionHandle,Identity identity,SchemaTableName tableName){\r\n    denyCreateTable(tableName.toString());\r\n}"
}, {
	"Path": "io.realm.processor.ClassMetaData.getInternalFieldName",
	"Comment": "returns the internal field name that matches the one in the java model class.",
	"Method": "String getInternalFieldName(String javaFieldName,String getInternalFieldName,VariableElement field,NameConverter defaultConverter){\r\n    RealmField nameAnnotation = field.getAnnotation(RealmField.class);\r\n    if (nameAnnotation != null) {\r\n        if (!nameAnnotation.name().isEmpty()) {\r\n            return nameAnnotation.name();\r\n        }\r\n        if (!nameAnnotation.value().isEmpty()) {\r\n            return nameAnnotation.value();\r\n        }\r\n        Utils.note(String.format(\"Empty internal name defined on @RealmField. \" + \"Falling back to named used by Java model class: %s\", field.getSimpleName()), field);\r\n        return field.getSimpleName().toString();\r\n    } else {\r\n        return defaultConverter.convert(field.getSimpleName().toString());\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmResults.setBlob",
	"Comment": "sets the binary value of the given field in all of the objects in the collection.",
	"Method": "void setBlob(String fieldName,byte[] value){\r\n    checkNonEmptyFieldName(fieldName);\r\n    realm.checkIfValidAndInTransaction();\r\n    fieldName = mapFieldNameToInternalName(fieldName);\r\n    checkType(fieldName, RealmFieldType.BINARY);\r\n    osResults.setBlob(fieldName, value);\r\n}"
}, {
	"Path": "io.realm.NotificationsTest.accessingSyncRealmResultsInsideAnotherResultListener",
	"Comment": "this can result in accessing detached rows and other errors.",
	"Method": "void accessingSyncRealmResultsInsideAnotherResultListener(){\r\n    final Realm realm = looperThread.getRealm();\r\n    final RealmResults<AllTypes> syncResults1 = realm.where(AllTypes.class).findAll();\r\n    final RealmResults<AllTypes> syncResults2 = realm.where(AllTypes.class).findAll();\r\n    looperThread.keepStrongReference(syncResults1);\r\n    syncResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {\r\n        @Override\r\n        public void onChange(RealmResults<AllTypes> element) {\r\n            assertEquals(1, syncResults1.size());\r\n            assertEquals(1, syncResults2.size());\r\n            looperThread.testComplete();\r\n        }\r\n    });\r\n    realm.beginTransaction();\r\n    realm.createObject(AllTypes.class);\r\n    realm.commitTransaction();\r\n}"
}, {
	"Path": "io.realm.NotificationsTest.accessingSyncRealmResultsInsideAnotherResultListener",
	"Comment": "this can result in accessing detached rows and other errors.",
	"Method": "void accessingSyncRealmResultsInsideAnotherResultListener(){\r\n    assertEquals(1, syncResults1.size());\r\n    assertEquals(1, syncResults2.size());\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "io.realm.RealmJsonTests.assertAllTypesPrimaryKeyUpdated",
	"Comment": "asserts that the list of alltypesprimarykey objects where inserted and updated properly.",
	"Method": "void assertAllTypesPrimaryKeyUpdated(){\r\n    assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());\r\n    AllTypesPrimaryKey obj = realm.where(AllTypesPrimaryKey.class).findFirst();\r\n    assertEquals(\"Bar\", obj.getColumnString());\r\n    assertEquals(2.23F, obj.getColumnFloat(), 0F);\r\n    assertEquals(2.234D, obj.getColumnDouble(), 0D);\r\n    assertEquals(true, obj.isColumnBoolean());\r\n    assertArrayEquals(new byte[] { 1, 2, 3 }, obj.getColumnBinary());\r\n    assertEquals(new Date(2000), obj.getColumnDate());\r\n    assertEquals(\"Dog4\", obj.getColumnRealmObject().getName());\r\n    assertEquals(2, obj.getColumnRealmList().size());\r\n    assertEquals(\"Dog5\", obj.getColumnRealmList().get(0).getName());\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.setRestSpeedThreshold",
	"Comment": "sets the speed at which the spring should be considered at rest.",
	"Method": "Spring setRestSpeedThreshold(double restSpeedThreshold){\r\n    mRestSpeedThreshold = restSpeedThreshold;\r\n    return this;\r\n}"
}, {
	"Path": "org.redisson.misc.HighwayHash.update",
	"Comment": "updates the hash with 32 bytes of data given as 4 longs. this function ismore efficient than updatepacket when you can use it.",
	"Method": "void update(long a0,long a1,long a2,long a3){\r\n    if (done) {\r\n        throw new IllegalStateException(\"Can compute a hash only once per instance\");\r\n    }\r\n    v1[0] += mul0[0] + a0;\r\n    v1[1] += mul0[1] + a1;\r\n    v1[2] += mul0[2] + a2;\r\n    v1[3] += mul0[3] + a3;\r\n    for (int i = 0; i < 4; ++i) {\r\n        mul0[i] ^= (v1[i] & 0xffffffffL) * (v0[i] >>> 32);\r\n        v0[i] += mul1[i];\r\n        mul1[i] ^= (v0[i] & 0xffffffffL) * (v1[i] >>> 32);\r\n    }\r\n    v0[0] += zipperMerge0(v1[1], v1[0]);\r\n    v0[1] += zipperMerge1(v1[1], v1[0]);\r\n    v0[2] += zipperMerge0(v1[3], v1[2]);\r\n    v0[3] += zipperMerge1(v1[3], v1[2]);\r\n    v1[0] += zipperMerge0(v0[1], v0[0]);\r\n    v1[1] += zipperMerge1(v0[1], v0[0]);\r\n    v1[2] += zipperMerge0(v0[3], v0[2]);\r\n    v1[3] += zipperMerge1(v0[3], v0[2]);\r\n}"
}, {
	"Path": "com.facebook.presto.orc.OrcRecordReader.getReaderPosition",
	"Comment": "return the row position within the stripes being read by this reader.this position will include rows that were never read due to row groupsthat are excluded due to row group statistics. thus, it will advancefaster than the number of rows actually read.",
	"Method": "long getReaderPosition(){\r\n    return currentPosition;\r\n}"
}, {
	"Path": "io.realm.RealmQuery.average",
	"Comment": "returns the average of a given field.does not support dotted field notation.",
	"Method": "double average(String fieldName){\r\n    realm.checkIfValid();\r\n    long columnIndex = schema.getAndCheckFieldIndex(fieldName);\r\n    switch(table.getColumnType(columnIndex)) {\r\n        case INTEGER:\r\n            return query.averageInt(columnIndex);\r\n        case DOUBLE:\r\n            return query.averageDouble(columnIndex);\r\n        case FLOAT:\r\n            return query.averageFloat(columnIndex);\r\n        default:\r\n            throw new IllegalArgumentException(String.format(Locale.US, TYPE_MISMATCH, fieldName, \"int, float or double\"));\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.orc.TestOrcReaderMemoryUsage.createSingleColumnFileWithNullValues",
	"Comment": "write a file that contains a number of rows with 1 bigint column, and some rows have null values.",
	"Method": "TempFile createSingleColumnFileWithNullValues(int rows){\r\n    Serializer serde = new OrcSerde();\r\n    TempFile tempFile = new TempFile();\r\n    FileSinkOperator.RecordWriter writer = createOrcRecordWriter(tempFile.getFile(), ORC_12, CompressionKind.NONE, BIGINT);\r\n    SettableStructObjectInspector objectInspector = createSettableStructObjectInspector(\"test\", BIGINT);\r\n    Object row = objectInspector.create();\r\n    StructField field = objectInspector.getAllStructFieldRefs().get(0);\r\n    for (int i = 0; i < rows; i++) {\r\n        if (i % 10 == 0) {\r\n            objectInspector.setStructFieldData(row, field, null);\r\n        } else {\r\n            objectInspector.setStructFieldData(row, field, (long) i);\r\n        }\r\n        Writable record = serde.serialize(row, objectInspector);\r\n        writer.write(record);\r\n    }\r\n    writer.close(false);\r\n    return tempFile;\r\n}"
}, {
	"Path": "io.realm.internal.OsResultsTests.addListener_triggeredByRefresh",
	"Comment": "local commit will trigger the listener first when begintransaction gets called then again when call refresh.",
	"Method": "void addListener_triggeredByRefresh(){\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where());\r\n    osResults.size();\r\n    osResults.addListener(osResults, new RealmChangeListener<OsResults>() {\r\n        @Override\r\n        public void onChange(OsResults element) {\r\n            assertEquals(1, latch.getCount());\r\n            latch.countDown();\r\n        }\r\n    });\r\n    addRowAsync(sharedRealm);\r\n    sharedRealm.waitForChange();\r\n    sharedRealm.refresh();\r\n    TestHelper.awaitOrFail(latch);\r\n}"
}, {
	"Path": "io.realm.internal.OsResultsTests.addListener_triggeredByRefresh",
	"Comment": "local commit will trigger the listener first when begintransaction gets called then again when call refresh.",
	"Method": "void addListener_triggeredByRefresh(){\r\n    assertEquals(1, latch.getCount());\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.realm.rule.RunInLooperThread.getRealm",
	"Comment": "get the test realm.set on test thread, accessed from main thread.valid only after the test thread has started.",
	"Method": "Realm getRealm(){\r\n    synchronized (lock) {\r\n        while (backgroundHandler == null) {\r\n            try {\r\n                lock.wait(WAIT_TIMEOUT_MS);\r\n            } catch (InterruptedException ignore) {\r\n                break;\r\n            }\r\n        }\r\n        return realm;\r\n    }\r\n}"
}, {
	"Path": "io.realm.objectserver.ObjectLevelPermissionIntegrationTests.getPrivileges_serverDefaults",
	"Comment": "check default privileges after being online for the first time",
	"Method": "void getPrivileges_serverDefaults(){\r\n    List schemaModule = Arrays.asList(new ObjectLevelTestModule());\r\n    SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);\r\n    SyncConfiguration syncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.DEFAULT_REALM).modules(schemaModule).build();\r\n    Realm realm = Realm.getInstance(syncConfig);\r\n    realm.where(AllJavaTypes.class).findAllAsync(\"keep-AllJavaTypes\");\r\n    realm.beginTransaction();\r\n    AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);\r\n    realm.commitTransaction();\r\n    assertEquals(1, realm.where(AllJavaTypes.class).count());\r\n    SyncManager.getSession(syncConfig).uploadAllLocalChanges();\r\n    SyncManager.getSession(syncConfig).downloadAllServerChanges();\r\n    realm.refresh();\r\n    RealmPrivileges realmPrivileges = realm.getPrivileges();\r\n    assertFullAccess(realmPrivileges);\r\n    ClassPrivileges classPrivileges = realm.getPrivileges(AllJavaTypes.class);\r\n    assertFullAccess(classPrivileges);\r\n    assertEquals(1, realm.where(AllJavaTypes.class).count());\r\n    ObjectPrivileges objectPrivileges = realm.getPrivileges(obj);\r\n    assertFullAccess(objectPrivileges);\r\n    realm.close();\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "com.facebook.presto.spi.predicate.SortedRangeSet.copyOf",
	"Comment": "provided ranges are unioned together to form the sortedrangeset",
	"Method": "SortedRangeSet copyOf(Type type,Iterable<Range> ranges,SortedRangeSet copyOf,Type type,List<Range> ranges){\r\n    return copyOf(type, (Iterable<Range>) ranges);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.filterTables",
	"Comment": "filter the list of tables and views to those visible to the identity.",
	"Method": "Set<SchemaTableName> filterTables(ConnectorTransactionHandle transactionHandle,Identity identity,Set<SchemaTableName> tableNames){\r\n    return emptySet();\r\n}"
}, {
	"Path": "com.facebook.presto.server.remotetask.HttpRemoteTask.failTask",
	"Comment": "move the task directly to the failed state if there was a failure in this task",
	"Method": "void failTask(Throwable cause){\r\n    TaskStatus taskStatus = getTaskStatus();\r\n    if (!taskStatus.getState().isDone()) {\r\n        log.debug(cause, \"Remote task %s failed with %s\", taskStatus.getSelf(), cause);\r\n    }\r\n    abort(failWith(getTaskStatus(), FAILED, ImmutableList.of(toFailure(cause))));\r\n}"
}, {
	"Path": "io.realm.sync.permissions.ClassPermissions.getName",
	"Comment": "returns the name of the class these permissions apply to. if this object is unmanagedthis name returned will be the simple name of the java class. if the object is managedit will be the internal name realm uses to represent the class.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanCreateViewWithSelectFromColumns",
	"Comment": "check if identity is allowed to create a view that selects from the specified columns in a relation.",
	"Method": "void checkCanCreateViewWithSelectFromColumns(ConnectorTransactionHandle transactionHandle,Identity identity,SchemaTableName tableName,Set<String> columnNames){\r\n    denyCreateViewWithSelect(tableName.toString(), identity);\r\n}"
}, {
	"Path": "io.realm.permissions.Permission.getUpdatedAt",
	"Comment": "returns the timestamp for when this permission object was last updated.",
	"Method": "Date getUpdatedAt(){\r\n    return updatedAt;\r\n}"
}, {
	"Path": "org.redisson.api.CronSchedule.of",
	"Comment": "creates cron expression object with defined expression string",
	"Method": "CronSchedule of(String expression){\r\n    return new CronSchedule(new CronExpression(expression));\r\n}"
}, {
	"Path": "com.facebook.presto.util.JsonUtil.parseJsonToSingleRowBlock",
	"Comment": "thus there will be single call to this method, so this method can be inlined.",
	"Method": "void parseJsonToSingleRowBlock(JsonParser parser,SingleRowBlockWriter singleRowBlockWriter,BlockBuilderAppender[] fieldAppenders,Optional<Map<String, Integer>> fieldNameToIndex){\r\n    if (parser.getCurrentToken() == START_ARRAY) {\r\n        for (int i = 0; i < fieldAppenders.length; i++) {\r\n            parser.nextToken();\r\n            fieldAppenders[i].append(parser, singleRowBlockWriter);\r\n        }\r\n        if (parser.nextToken() != JsonToken.END_ARRAY) {\r\n            throw new JsonCastException(format(\"Expected json array ending, but got %s\", parser.getText()));\r\n        }\r\n    } else {\r\n        verify(parser.getCurrentToken() == START_OBJECT);\r\n        if (!fieldNameToIndex.isPresent()) {\r\n            throw new JsonCastException(\"Cannot cast a JSON object to anonymous row type. Input must be a JSON array.\");\r\n        }\r\n        boolean[] fieldWritten = new boolean[fieldAppenders.length];\r\n        int numFieldsWritten = 0;\r\n        while (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            if (parser.currentToken() != FIELD_NAME) {\r\n                throw new JsonCastException(format(\"Expected a json field name, but got %s\", parser.getText()));\r\n            }\r\n            String fieldName = parser.getText().toLowerCase(Locale.ENGLISH);\r\n            Integer fieldIndex = fieldNameToIndex.get().get(fieldName);\r\n            parser.nextToken();\r\n            if (fieldIndex != null) {\r\n                if (fieldWritten[fieldIndex]) {\r\n                    throw new JsonCastException(\"Duplicate field: \" + fieldName);\r\n                }\r\n                fieldWritten[fieldIndex] = true;\r\n                numFieldsWritten++;\r\n                fieldAppenders[fieldIndex].append(parser, singleRowBlockWriter.getFieldBlockBuilder(fieldIndex));\r\n            } else {\r\n                parser.skipChildren();\r\n            }\r\n        }\r\n        if (numFieldsWritten != fieldAppenders.length) {\r\n            for (int i = 0; i < fieldWritten.length; i++) {\r\n                if (!fieldWritten[i]) {\r\n                    singleRowBlockWriter.getFieldBlockBuilder(i).appendNull();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync",
	"Comment": "starts asynchronously a transaction to insert one element.",
	"Method": "void executeTransactionAsync(){\r\n    final Realm realm = looperThread.getRealm();\r\n    assertEquals(0, realm.where(Owner.class).count());\r\n    realm.executeTransactionAsync(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            Owner owner = realm.createObject(Owner.class);\r\n            owner.setName(\"Owner\");\r\n        }\r\n    }, new Realm.Transaction.OnSuccess() {\r\n        @Override\r\n        public void onSuccess() {\r\n            assertEquals(1, realm.where(Owner.class).count());\r\n            assertEquals(\"Owner\", realm.where(Owner.class).findFirst().getName());\r\n            looperThread.testComplete();\r\n        }\r\n    }, new Realm.Transaction.OnError() {\r\n        @Override\r\n        public void onError(Throwable error) {\r\n            fail(error.getMessage());\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync",
	"Comment": "starts asynchronously a transaction to insert one element.",
	"Method": "void executeTransactionAsync(){\r\n    Owner owner = realm.createObject(Owner.class);\r\n    owner.setName(\"Owner\");\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync",
	"Comment": "starts asynchronously a transaction to insert one element.",
	"Method": "void executeTransactionAsync(){\r\n    assertEquals(1, realm.where(Owner.class).count());\r\n    assertEquals(\"Owner\", realm.where(Owner.class).findFirst().getName());\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync",
	"Comment": "starts asynchronously a transaction to insert one element.",
	"Method": "void executeTransactionAsync(){\r\n    fail(error.getMessage());\r\n}"
}, {
	"Path": "io.realm.RealmJsonAbsentPrimaryKeyTests.data",
	"Comment": "parameters for testing absent primary key value. primarykey field is absent.",
	"Method": "Iterable<Object[]> data(){\r\n    return Arrays.asList(new Object[][] { { PrimaryKeyAsBoxedByte.class, \"{ \\\"name\\\":\\\"HaHaHaHaHaHaHaHaH\\\" }\" }, { PrimaryKeyAsBoxedShort.class, \"{ \\\"name\\\":\\\"KeyValueTestIsFun\\\" }\" }, { PrimaryKeyAsBoxedInteger.class, \"{ \\\"name\\\":\\\"FunValueTestIsKey\\\" }\" }, { PrimaryKeyAsBoxedLong.class, \"{ \\\"name\\\":\\\"NameAsBoxedLong-!\\\" }\" }, { PrimaryKeyAsString.class, \"{ \\\"id\\\":2429214 }\" } });\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.setClassName_transferPrimaryKey",
	"Comment": "test to show that renaming a class does not effect the primary key.",
	"Method": "void setClassName_transferPrimaryKey(){\r\n    buildInitialMigrationSchema(MigrationClassRenamed.CLASS_NAME, true);\r\n    RealmMigration migration = new RealmMigration() {\r\n        @Override\r\n        public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {\r\n            realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).setClassName(MigrationClassRenamed.CLASS_NAME);\r\n        }\r\n    };\r\n    RealmConfiguration realmConfig = configFactory.createConfigurationBuilder().schemaVersion(1).schema(MigrationClassRenamed.class).migration(migration).build();\r\n    Realm realm = Realm.getInstance(realmConfig);\r\n    Table table = realm.getSchema().getTable(MigrationClassRenamed.class);\r\n    assertEquals(MigrationClassRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());\r\n    assertPKField(realm, MigrationClassRenamed.CLASS_NAME, MigrationClassRenamed.FIELD_PRIMARY, MigrationClassRenamed.DEFAULT_PRIMARY_INDEX);\r\n    assertNull(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME));\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.setClassName_transferPrimaryKey",
	"Comment": "test to show that renaming a class does not effect the primary key.",
	"Method": "void setClassName_transferPrimaryKey(){\r\n    realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).setClassName(MigrationClassRenamed.CLASS_NAME);\r\n}"
}, {
	"Path": "io.realm.RealmResultsTests.accessors_resultsBuiltOnDeletedLinkView_deletionAsARemoteCommit",
	"Comment": "4. the results change listener called, the results becomes empty.",
	"Method": "void accessors_resultsBuiltOnDeletedLinkView_deletionAsARemoteCommit(){\r\n    Realm realm = looperThread.getRealm();\r\n    RealmResults<Dog> dogs = populateRealmResultsOnLinkView(realm);\r\n    looperThread.keepStrongReference(dogs);\r\n    dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {\r\n        @Override\r\n        public void onChange(RealmResults<Dog> dogs) {\r\n            assertEquals(true, dogs.isValid());\r\n            assertEquals(true, dogs.isEmpty());\r\n            assertEquals(0, dogs.size());\r\n            try {\r\n                dogs.first();\r\n                fail();\r\n            } catch (IndexOutOfBoundsException ignored) {\r\n            }\r\n            assertEquals(0, dogs.sum(Dog.FIELD_AGE).intValue());\r\n            assertEquals(0f, dogs.sum(Dog.FIELD_HEIGHT).floatValue(), 0f);\r\n            assertEquals(0d, dogs.sum(Dog.FIELD_WEIGHT).doubleValue(), 0d);\r\n            assertEquals(0d, dogs.average(Dog.FIELD_AGE), 0d);\r\n            assertEquals(0d, dogs.average(Dog.FIELD_HEIGHT), 0d);\r\n            assertEquals(0d, dogs.average(Dog.FIELD_WEIGHT), 0d);\r\n            assertEquals(null, dogs.min(Dog.FIELD_AGE));\r\n            assertEquals(null, dogs.max(Dog.FIELD_AGE));\r\n            assertEquals(null, dogs.minDate(Dog.FIELD_BIRTHDAY));\r\n            assertEquals(null, dogs.maxDate(Dog.FIELD_BIRTHDAY));\r\n            assertEquals(0, dogs.where().findAll().size());\r\n            looperThread.testComplete();\r\n        }\r\n    });\r\n    realm.executeTransactionAsync(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            realm.where(Owner.class).findAll().deleteAllFromRealm();\r\n        }\r\n    });\r\n    assertEquals(true, dogs.isValid());\r\n    assertEquals(5, dogs.size());\r\n    assertEquals(5, dogs.where().findAll().size());\r\n}"
}, {
	"Path": "io.realm.RealmResultsTests.accessors_resultsBuiltOnDeletedLinkView_deletionAsARemoteCommit",
	"Comment": "4. the results change listener called, the results becomes empty.",
	"Method": "void accessors_resultsBuiltOnDeletedLinkView_deletionAsARemoteCommit(){\r\n    assertEquals(true, dogs.isValid());\r\n    assertEquals(true, dogs.isEmpty());\r\n    assertEquals(0, dogs.size());\r\n    try {\r\n        dogs.first();\r\n        fail();\r\n    } catch (IndexOutOfBoundsException ignored) {\r\n    }\r\n    assertEquals(0, dogs.sum(Dog.FIELD_AGE).intValue());\r\n    assertEquals(0f, dogs.sum(Dog.FIELD_HEIGHT).floatValue(), 0f);\r\n    assertEquals(0d, dogs.sum(Dog.FIELD_WEIGHT).doubleValue(), 0d);\r\n    assertEquals(0d, dogs.average(Dog.FIELD_AGE), 0d);\r\n    assertEquals(0d, dogs.average(Dog.FIELD_HEIGHT), 0d);\r\n    assertEquals(0d, dogs.average(Dog.FIELD_WEIGHT), 0d);\r\n    assertEquals(null, dogs.min(Dog.FIELD_AGE));\r\n    assertEquals(null, dogs.max(Dog.FIELD_AGE));\r\n    assertEquals(null, dogs.minDate(Dog.FIELD_BIRTHDAY));\r\n    assertEquals(null, dogs.maxDate(Dog.FIELD_BIRTHDAY));\r\n    assertEquals(0, dogs.where().findAll().size());\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "io.realm.RealmResultsTests.accessors_resultsBuiltOnDeletedLinkView_deletionAsARemoteCommit",
	"Comment": "4. the results change listener called, the results becomes empty.",
	"Method": "void accessors_resultsBuiltOnDeletedLinkView_deletionAsARemoteCommit(){\r\n    realm.where(Owner.class).findAll().deleteAllFromRealm();\r\n}"
}, {
	"Path": "io.realm.permissions.PermissionOffer.mayRead",
	"Comment": "returns whether or not the user accepting this offer is granted read permission.",
	"Method": "boolean mayRead(){\r\n    return mayRead;\r\n}"
}, {
	"Path": "io.realm.OrderedRealmCollectionImpl.deleteFirstFromRealm",
	"Comment": "removes the first object in the list. this also deletes the object from the underlying realm.",
	"Method": "boolean deleteFirstFromRealm(){\r\n    realm.checkIfValidAndInTransaction();\r\n    return osResults.deleteFirst();\r\n}"
}, {
	"Path": "io.realm.internal.Table.moveLastOver",
	"Comment": "removes a row from the specific index. if it is not the last row in the table, it then moves the last row intothe vacated slot.",
	"Method": "void moveLastOver(long rowIndex){\r\n    checkImmutable();\r\n    nativeMoveLastOver(nativePtr, rowIndex);\r\n}"
}, {
	"Path": "io.realm.SyncManager.getCustomRequestHeaders",
	"Comment": "returns all the custom headers added to requests to the given url.",
	"Method": "Map<String, String> getCustomRequestHeaders(URI serverSyncUrl){\r\n    Map<String, String> headers = new LinkedHashMap(globalCustomHeaders);\r\n    String host = serverSyncUrl.getHost().toLowerCase(Locale.US);\r\n    Map<String, String> hostHeaders = hostRestrictedCustomHeaders.get(host);\r\n    if (hostHeaders != null) {\r\n        for (Map.Entry<String, String> entry : hostHeaders.entrySet()) {\r\n            headers.put(entry.getKey(), entry.getValue());\r\n        }\r\n    }\r\n    return headers;\r\n}"
}, {
	"Path": "io.realm.SyncSessionTests.logBackResumeUpload",
	"Comment": "a realm that was opened before a user logged out should be able to resume uploading if the user logs back in.",
	"Method": "void logBackResumeUpload(){\r\n    final String uniqueName = UUID.randomUUID().toString();\r\n    SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, \"password\", true);\r\n    SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);\r\n    final SyncConfiguration syncConfiguration = configFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL).fullSynchronization().modules(new StringOnlyModule()).waitForInitialRemoteData().build();\r\n    final Realm realm = Realm.getInstance(syncConfiguration);\r\n    realm.executeTransaction(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            realm.createObject(StringOnly.class).setChars(\"1\");\r\n        }\r\n    });\r\n    final SyncSession session = SyncManager.getSession(syncConfiguration);\r\n    session.uploadAllLocalChanges();\r\n    user.logOut();\r\n    realm.executeTransaction(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            realm.createObject(StringOnly.class).setChars(\"2\");\r\n        }\r\n    });\r\n    final CountDownLatch testCompleted = new CountDownLatch(1);\r\n    final HandlerThread handlerThread = new HandlerThread(\"HandlerThread\");\r\n    handlerThread.start();\r\n    Looper looper = handlerThread.getLooper();\r\n    Handler handler = new Handler(looper);\r\n    handler.post(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);\r\n            SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), \"custom-admin-user\");\r\n            SyncUser adminUser = SyncUser.logIn(credentialsAdmin, Constants.AUTH_URL);\r\n            SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString()).modules(new StringOnlyModule()).fullSynchronization().waitForInitialRemoteData().build();\r\n            final Realm adminRealm = Realm.getInstance(adminConfig);\r\n            RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).sort(StringOnly.FIELD_CHARS).findAll();\r\n            RealmChangeListener<RealmResults<StringOnly>> realmChangeListener = new RealmChangeListener<RealmResults<StringOnly>>() {\r\n                @Override\r\n                public void onChange(RealmResults<StringOnly> stringOnlies) {\r\n                    if (stringOnlies.size() == 2) {\r\n                        Assert.assertEquals(\"1\", stringOnlies.get(0).getChars());\r\n                        Assert.assertEquals(\"2\", stringOnlies.get(1).getChars());\r\n                        handler.post(() -> {\r\n                            adminRealm.close();\r\n                            testCompleted.countDown();\r\n                            handlerThread.quit();\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            all.addChangeListener(realmChangeListener);\r\n            SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, \"password\", false);\r\n            SyncUser.logIn(credentials, Constants.AUTH_URL);\r\n        }\r\n    });\r\n    TestHelper.awaitOrFail(testCompleted);\r\n    realm.close();\r\n}"
}, {
	"Path": "io.realm.SyncSessionTests.logBackResumeUpload",
	"Comment": "a realm that was opened before a user logged out should be able to resume uploading if the user logs back in.",
	"Method": "void logBackResumeUpload(){\r\n    realm.createObject(StringOnly.class).setChars(\"1\");\r\n}"
}, {
	"Path": "io.realm.SyncSessionTests.logBackResumeUpload",
	"Comment": "a realm that was opened before a user logged out should be able to resume uploading if the user logs back in.",
	"Method": "void logBackResumeUpload(){\r\n    realm.createObject(StringOnly.class).setChars(\"2\");\r\n}"
}, {
	"Path": "io.realm.SyncSessionTests.logBackResumeUpload",
	"Comment": "a realm that was opened before a user logged out should be able to resume uploading if the user logs back in.",
	"Method": "void logBackResumeUpload(){\r\n    SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);\r\n    SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), \"custom-admin-user\");\r\n    SyncUser adminUser = SyncUser.logIn(credentialsAdmin, Constants.AUTH_URL);\r\n    SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString()).modules(new StringOnlyModule()).fullSynchronization().waitForInitialRemoteData().build();\r\n    final Realm adminRealm = Realm.getInstance(adminConfig);\r\n    RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).sort(StringOnly.FIELD_CHARS).findAll();\r\n    RealmChangeListener<RealmResults<StringOnly>> realmChangeListener = new RealmChangeListener<RealmResults<StringOnly>>() {\r\n        @Override\r\n        public void onChange(RealmResults<StringOnly> stringOnlies) {\r\n            if (stringOnlies.size() == 2) {\r\n                Assert.assertEquals(\"1\", stringOnlies.get(0).getChars());\r\n                Assert.assertEquals(\"2\", stringOnlies.get(1).getChars());\r\n                handler.post(() -> {\r\n                    adminRealm.close();\r\n                    testCompleted.countDown();\r\n                    handlerThread.quit();\r\n                });\r\n            }\r\n        }\r\n    };\r\n    all.addChangeListener(realmChangeListener);\r\n    SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, \"password\", false);\r\n    SyncUser.logIn(credentials, Constants.AUTH_URL);\r\n}"
}, {
	"Path": "io.realm.SyncSessionTests.logBackResumeUpload",
	"Comment": "a realm that was opened before a user logged out should be able to resume uploading if the user logs back in.",
	"Method": "void logBackResumeUpload(){\r\n    if (stringOnlies.size() == 2) {\r\n        Assert.assertEquals(\"1\", stringOnlies.get(0).getChars());\r\n        Assert.assertEquals(\"2\", stringOnlies.get(1).getChars());\r\n        handler.post(() -> {\r\n            adminRealm.close();\r\n            testCompleted.countDown();\r\n            handlerThread.quit();\r\n        });\r\n    }\r\n}"
}, {
	"Path": "io.realm.DynamicRealm.where",
	"Comment": "returns a realmquery, which can be used to query the provided class.",
	"Method": "RealmQuery<DynamicRealmObject> where(String className){\r\n    checkIfValid();\r\n    if (!sharedRealm.hasTable(Table.getTableNameForClass(className))) {\r\n        throw new IllegalArgumentException(\"Class does not exist in the Realm and cannot be queried: \" + className);\r\n    }\r\n    return RealmQuery.createDynamicQuery(this, className);\r\n}"
}, {
	"Path": "com.facebook.rebound.playground.examples.scrollview.SpringScrollView.setFillViewport",
	"Comment": "indicates this scrollview whether it should stretch its content height to fillthe viewport or not.",
	"Method": "void setFillViewport(boolean fillViewport){\r\n    if (fillViewport != mFillViewport) {\r\n        mFillViewport = fillViewport;\r\n        requestLayout();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.connector.thrift.api.PrestoThriftSplit.getHosts",
	"Comment": "identifies the set of hosts on which the rows are available. if empty, then the rowsare expected to be available on any host. the hosts in this list may be independentfrom the hosts used to serve metadata requests.",
	"Method": "List<PrestoThriftHostAddress> getHosts(){\r\n    return hosts;\r\n}"
}, {
	"Path": "com.facebook.presto.sql.tree.DereferenceExpression.getQualifiedName",
	"Comment": "if this dereferenceexpression looks like a qualifiedname, return qualifiedname.otherwise return null",
	"Method": "QualifiedName getQualifiedName(DereferenceExpression expression){\r\n    List<String> parts = tryParseParts(expression.base, expression.field.getValue().toLowerCase(Locale.ENGLISH));\r\n    return parts == null ? null : QualifiedName.of(parts);\r\n}"
}, {
	"Path": "com.facebook.presto.sql.gen.BytecodeGeneratorContext.generateCall",
	"Comment": "generates a function call with null handling, automatic binding of session parameter, etc.",
	"Method": "BytecodeNode generateCall(String name,ScalarFunctionImplementation function,List<BytecodeNode> arguments){\r\n    Optional<BytecodeNode> instance = Optional.empty();\r\n    if (function.getInstanceFactory().isPresent()) {\r\n        FieldDefinition field = cachedInstanceBinder.getCachedInstance(function.getInstanceFactory().get());\r\n        instance = Optional.of(scope.getThis().getField(field));\r\n    }\r\n    return generateInvocation(scope, name, function, instance, arguments, callSiteBinder);\r\n}"
}, {
	"Path": "io.realm.OrderedRealmCollectionSnapshot.deleteAllFromRealm",
	"Comment": "this deletes all objects in the collection from the underlying realm. all objects in the collection snapshotwill become invalid.",
	"Method": "boolean deleteAllFromRealm(){\r\n    return super.deleteAllFromRealm();\r\n}"
}, {
	"Path": "com.facebook.presto.spi.ConnectorTablePartitioning.getPartitioningHandle",
	"Comment": "a handle to the partitioning scheme used to divide the table across worker nodes.",
	"Method": "ConnectorPartitioningHandle getPartitioningHandle(){\r\n    return partitioningHandle;\r\n}"
}, {
	"Path": "com.facebook.presto.connector.thrift.api.PrestoThriftPageResult.getColumnBlocks",
	"Comment": "returns data in a columnar format.columns in this list must be in the order they were requested by the engine.",
	"Method": "List<PrestoThriftBlock> getColumnBlocks(){\r\n    return columnBlocks;\r\n}"
}, {
	"Path": "org.redisson.executor.CronExpression.setTimeZone",
	"Comment": "sets the time zone for whichthis cronexpression will be resolved.",
	"Method": "void setTimeZone(TimeZone timeZone){\r\n    this.timeZone = timeZone;\r\n}"
}, {
	"Path": "io.realm.RealmInterprocessTest.testCreateInitialRealm",
	"Comment": "a. service process opens realm, check if there is one and only one object.",
	"Method": "void testCreateInitialRealm(){\r\n    new InterprocessHandler(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            testRealm = Realm.getInstance(getConfiguration());\r\n            assertEquals(0, testRealm.where(AllTypes.class).count());\r\n            testRealm.beginTransaction();\r\n            testRealm.createObject(AllTypes.class);\r\n            testRealm.commitTransaction();\r\n            triggerServiceStep(RemoteProcessService.stepCreateInitialRealm_A);\r\n        }\r\n    }) {\r\n        @Override\r\n        public void handleMessage(Message msg) {\r\n            super.handleMessage(msg);\r\n            if (msg.what == RemoteProcessService.stepCreateInitialRealm_A.message) {\r\n                clearTimeoutFlag();\r\n                done();\r\n            } else {\r\n                assertTrue(false);\r\n            }\r\n        }\r\n    };\r\n    Looper.loop();\r\n}"
}, {
	"Path": "io.realm.RealmInterprocessTest.testCreateInitialRealm",
	"Comment": "a. service process opens realm, check if there is one and only one object.",
	"Method": "void testCreateInitialRealm(){\r\n    testRealm = Realm.getInstance(getConfiguration());\r\n    assertEquals(0, testRealm.where(AllTypes.class).count());\r\n    testRealm.beginTransaction();\r\n    testRealm.createObject(AllTypes.class);\r\n    testRealm.commitTransaction();\r\n    triggerServiceStep(RemoteProcessService.stepCreateInitialRealm_A);\r\n}"
}, {
	"Path": "io.realm.RealmInterprocessTest.testCreateInitialRealm",
	"Comment": "a. service process opens realm, check if there is one and only one object.",
	"Method": "void testCreateInitialRealm(){\r\n    super.handleMessage(msg);\r\n    if (msg.what == RemoteProcessService.stepCreateInitialRealm_A.message) {\r\n        clearTimeoutFlag();\r\n        done();\r\n    } else {\r\n        assertTrue(false);\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmTests.waitForChange_runWithRealmThread",
	"Comment": "waitforchange & stopwaitforchange within a simple thread wrapper.",
	"Method": "void waitForChange_runWithRealmThread(){\r\n    final CountDownLatch bgRealmStarted = new CountDownLatch(1);\r\n    final CountDownLatch bgRealmFished = new CountDownLatch(1);\r\n    final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(false);\r\n    final AtomicLong bgRealmResultSize = new AtomicLong(0);\r\n    RealmThread thread = new RealmThread(realmConfig, new RealmThread.RealmRunnable() {\r\n        @Override\r\n        public void run(Realm realm) {\r\n            bgRealmStarted.countDown();\r\n            bgRealmChangeResult.set(realm.waitForChange());\r\n            bgRealmResultSize.set(realm.where(AllTypes.class).count());\r\n            realm.close();\r\n            bgRealmFished.countDown();\r\n        }\r\n    });\r\n    thread.start();\r\n    TestHelper.awaitOrFail(bgRealmStarted);\r\n    populateTestRealm();\r\n    TestHelper.awaitOrFail(bgRealmFished);\r\n    assertTrue(bgRealmChangeResult.get());\r\n    assertEquals(TEST_DATA_SIZE, bgRealmResultSize.get());\r\n}"
}, {
	"Path": "io.realm.RealmTests.waitForChange_runWithRealmThread",
	"Comment": "waitforchange & stopwaitforchange within a simple thread wrapper.",
	"Method": "void waitForChange_runWithRealmThread(){\r\n    bgRealmStarted.countDown();\r\n    bgRealmChangeResult.set(realm.waitForChange());\r\n    bgRealmResultSize.set(realm.where(AllTypes.class).count());\r\n    realm.close();\r\n    bgRealmFished.countDown();\r\n}"
}, {
	"Path": "com.facebook.rebound.playground.examples.scrollview.SpringScrollView.scrollAndFocus",
	"Comment": "scrolls the view to make the area defined by top andbottom visible. this method attempts to give the focusto a component visible in this area. if no component can be focused inthe new visible area, the focus is reclaimed by this scrollview.",
	"Method": "boolean scrollAndFocus(int direction,int top,int bottom){\r\n    boolean handled = true;\r\n    int height = getHeight();\r\n    int containerTop = getScrollY();\r\n    int containerBottom = containerTop + height;\r\n    boolean up = direction == View.FOCUS_UP;\r\n    View newFocused = findFocusableViewInBounds(up, top, bottom);\r\n    if (newFocused == null) {\r\n        newFocused = this;\r\n    }\r\n    if (top >= containerTop && bottom <= containerBottom) {\r\n        handled = false;\r\n    } else {\r\n        int delta = up ? (top - containerTop) : (bottom - containerBottom);\r\n        doScrollY(delta);\r\n    }\r\n    if (newFocused != findFocus())\r\n        newFocused.requestFocus(direction);\r\n    return handled;\r\n}"
}, {
	"Path": "com.facebook.presto.server.PrestoSystemRequirements.verifySystemTimeIsReasonable",
	"Comment": "perform a sanity check to make sure that the year is reasonably current, to guard againstissues in third party libraries.",
	"Method": "void verifySystemTimeIsReasonable(){\r\n    int currentYear = DateTime.now().year().get();\r\n    if (currentYear < 2015) {\r\n        failRequirement(\"Presto requires the system time to be current (found year %s)\", currentYear);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spi.type.UnscaledDecimal128Arithmetic.subtractUnsigned",
	"Comment": "this method ignores signs of the left and right and assumes that left is greater then right",
	"Method": "void subtractUnsigned(Slice left,Slice right,Slice result,boolean resultNegative){\r\n    int l0 = getInt(left, 0);\r\n    int l1 = getInt(left, 1);\r\n    int l2 = getInt(left, 2);\r\n    int l3 = getInt(left, 3);\r\n    int r0 = getInt(right, 0);\r\n    int r1 = getInt(right, 1);\r\n    int r2 = getInt(right, 2);\r\n    int r3 = getInt(right, 3);\r\n    long intermediateResult;\r\n    intermediateResult = (l0 & LONG_MASK) - (r0 & LONG_MASK);\r\n    int z0 = (int) intermediateResult;\r\n    intermediateResult = (l1 & LONG_MASK) - (r1 & LONG_MASK) + (intermediateResult >> 32);\r\n    int z1 = (int) intermediateResult;\r\n    intermediateResult = (l2 & LONG_MASK) - (r2 & LONG_MASK) + (intermediateResult >> 32);\r\n    int z2 = (int) intermediateResult;\r\n    intermediateResult = (l3 & LONG_MASK) - (r3 & LONG_MASK) + (intermediateResult >> 32);\r\n    int z3 = (int) intermediateResult;\r\n    pack(result, z0, z1, z2, z3, resultNegative);\r\n    if ((intermediateResult >> 32) != 0) {\r\n        throw new IllegalStateException(format(\"Non empty carry over after subtracting [%d]. right > left?\", (intermediateResult >> 32)));\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spi.type.RowType.createWithTypeSignature",
	"Comment": "only rowparametrictype.createtype should call this method",
	"Method": "RowType createWithTypeSignature(TypeSignature typeSignature,List<Field> fields){\r\n    return new RowType(typeSignature, fields);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.ConnectorPageSink.getSystemMemoryUsage",
	"Comment": "get the total memory that needs to be reserved in the general memory pool.this memory should include any buffers, etc. that are used for reading data.",
	"Method": "long getSystemMemoryUsage(){\r\n    return 0;\r\n}"
}, {
	"Path": "io.realm.internal.permissions.PermissionChange.fromRequest",
	"Comment": "maps between a permissionrequest and a permissionchange object.",
	"Method": "PermissionChange fromRequest(PermissionRequest request){\r\n    UserCondition condition = request.getCondition();\r\n    AccessLevel level = request.getAccessLevel();\r\n    String realmUrl = request.getUrl();\r\n    String userId = \"\";\r\n    String metadataKey = null;\r\n    String metadataValue = null;\r\n    switch(condition.getType()) {\r\n        case USER_ID:\r\n            userId = condition.getValue();\r\n            break;\r\n        case METADATA:\r\n            metadataKey = condition.getKey();\r\n            metadataValue = condition.getValue();\r\n            break;\r\n    }\r\n    return new PermissionChange(realmUrl, userId, metadataKey, metadataValue, level.mayRead(), level.mayWrite(), level.mayManage());\r\n}"
}, {
	"Path": "io.realm.ClientResetRequiredError.getBackupFile",
	"Comment": "returns the location of the backed up realm file. the file will not be present until the client reset has beenfully executed.",
	"Method": "File getBackupFile(){\r\n    return backupFile;\r\n}"
}, {
	"Path": "io.realm.TestHelper.SHA512",
	"Comment": "creates sha512 hash of a string. can be used as password for encrypted realms.",
	"Method": "byte[] SHA512(String str){\r\n    try {\r\n        MessageDigest md = MessageDigest.getInstance(\"SHA-512\");\r\n        md.update(str.getBytes(UTF_8), 0, str.length());\r\n        return md.digest();\r\n    } catch (NoSuchAlgorithmException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanInsertIntoTable",
	"Comment": "check if identity is allowed to insert into the specified table in this catalog.",
	"Method": "void checkCanInsertIntoTable(ConnectorTransactionHandle transactionHandle,Identity identity,SchemaTableName tableName){\r\n    denyInsertTable(tableName.toString());\r\n}"
}, {
	"Path": "io.realm.sync.Subscription.getQueryDescription",
	"Comment": "returns a textual description of the query that created this subscription.",
	"Method": "String getQueryDescription(){\r\n    return query;\r\n}"
}, {
	"Path": "io.realm.DynamicRealmObjectTests.callGetter",
	"Comment": "helper method for calling getters with different field names.",
	"Method": "void callGetter(DynamicRealmObject target,SupportedType type,List<String> fieldNames){\r\n    for (String fieldName : fieldNames) {\r\n        switch(type) {\r\n            case BOOLEAN:\r\n                target.getBoolean(fieldName);\r\n                break;\r\n            case SHORT:\r\n                target.getShort(fieldName);\r\n                break;\r\n            case INT:\r\n                target.getInt(fieldName);\r\n                break;\r\n            case LONG:\r\n                target.getLong(fieldName);\r\n                break;\r\n            case BYTE:\r\n                target.getByte(fieldName);\r\n                break;\r\n            case FLOAT:\r\n                target.getFloat(fieldName);\r\n                break;\r\n            case DOUBLE:\r\n                target.getDouble(fieldName);\r\n                break;\r\n            case STRING:\r\n                target.getString(fieldName);\r\n                break;\r\n            case BINARY:\r\n                target.getBlob(fieldName);\r\n                break;\r\n            case DATE:\r\n                target.getDate(fieldName);\r\n                break;\r\n            case OBJECT:\r\n                target.getObject(fieldName);\r\n                break;\r\n            case LIST:\r\n            case LIST_INTEGER:\r\n            case LIST_STRING:\r\n            case LIST_BOOLEAN:\r\n            case LIST_FLOAT:\r\n            case LIST_DOUBLE:\r\n            case LIST_BINARY:\r\n            case LIST_DATE:\r\n                target.getList(fieldName);\r\n                break;\r\n            default:\r\n                fail();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.BulkInsertTests.insertOrUpdate_managedObject",
	"Comment": "inserting a managed object will result in it being copied or updated again.",
	"Method": "void insertOrUpdate_managedObject(){\r\n    AllJavaTypes obj = new AllJavaTypes();\r\n    obj.setFieldId(42);\r\n    obj.setFieldIgnored(\"cookie\");\r\n    obj.setFieldLong(42);\r\n    obj.setFieldString(\"obj1\");\r\n    realm.beginTransaction();\r\n    AllJavaTypes managedAllJavaTypes = realm.copyToRealm(obj);\r\n    realm.commitTransaction();\r\n    realm.beginTransaction();\r\n    AllJavaTypes filedObject = new AllJavaTypes();\r\n    filedObject.setFieldLong(8);\r\n    filedObject = realm.copyToRealm(filedObject);\r\n    managedAllJavaTypes.setFieldObject(filedObject);\r\n    managedAllJavaTypes.setFieldString(\"updated\");\r\n    realm.insertOrUpdate(managedAllJavaTypes);\r\n    realm.commitTransaction();\r\n    AllJavaTypes first = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 42).findFirst();\r\n    assertNotNull(first);\r\n    assertEquals(42, first.getFieldLong(), 0);\r\n    assertEquals(\"updated\", first.getFieldString());\r\n    assertNull(first.getFieldIgnored());\r\n    assertNotNull(first.getFieldObject());\r\n    assertEquals(8, first.getFieldObject().getFieldLong());\r\n    assertEquals(2, realm.where(AllJavaTypes.class).findAll().size());\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync_realmClosedOnSuccess",
	"Comment": "tests if the background realm is closed when transaction success returned.",
	"Method": "void executeTransactionAsync_realmClosedOnSuccess(){\r\n    final AtomicInteger counter = new AtomicInteger(100);\r\n    final Realm realm = looperThread.getRealm();\r\n    final RealmCache.Callback cacheCallback = new RealmCache.Callback() {\r\n        @Override\r\n        public void onResult(int count) {\r\n            assertEquals(1, count);\r\n            if (counter.decrementAndGet() == 0) {\r\n                realm.close();\r\n                looperThread.testComplete();\r\n            }\r\n        }\r\n    };\r\n    final Realm.Transaction.OnSuccess transactionCallback = new Realm.Transaction.OnSuccess() {\r\n        @Override\r\n        public void onSuccess() {\r\n            RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\r\n            if (counter.get() == 0) {\r\n                return;\r\n            }\r\n            realm.executeTransactionAsync(new Realm.Transaction() {\r\n                @Override\r\n                public void execute(Realm realm) {\r\n                }\r\n            }, this);\r\n        }\r\n    };\r\n    realm.executeTransactionAsync(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n        }\r\n    }, transactionCallback);\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync_realmClosedOnSuccess",
	"Comment": "tests if the background realm is closed when transaction success returned.",
	"Method": "void executeTransactionAsync_realmClosedOnSuccess(){\r\n    assertEquals(1, count);\r\n    if (counter.decrementAndGet() == 0) {\r\n        realm.close();\r\n        looperThread.testComplete();\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync_realmClosedOnSuccess",
	"Comment": "tests if the background realm is closed when transaction success returned.",
	"Method": "void executeTransactionAsync_realmClosedOnSuccess(){\r\n    RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\r\n    if (counter.get() == 0) {\r\n        return;\r\n    }\r\n    realm.executeTransactionAsync(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n        }\r\n    }, this);\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync_realmClosedOnSuccess",
	"Comment": "tests if the background realm is closed when transaction success returned.",
	"Method": "void executeTransactionAsync_realmClosedOnSuccess(){\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync_realmClosedOnSuccess",
	"Comment": "tests if the background realm is closed when transaction success returned.",
	"Method": "void executeTransactionAsync_realmClosedOnSuccess(){\r\n}"
}, {
	"Path": "io.realm.RealmQuery.endsWith",
	"Comment": "condition that the value of field ends with the specified substring.",
	"Method": "RealmQuery<E> endsWith(String fieldName,String value,RealmQuery<E> endsWith,String fieldName,String value,Case casing){\r\n    realm.checkIfValid();\r\n    FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);\r\n    this.query.endsWith(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);\r\n    return this;\r\n}"
}, {
	"Path": "io.realm.internal.objectserver.Token.expiresSec",
	"Comment": "returns when this token expires. timestamp is in utc seconds.",
	"Method": "long expiresSec(){\r\n    return expiresSec;\r\n}"
}, {
	"Path": "org.redisson.executor.TasksRunnerService.finish",
	"Comment": "check shutdown state. if taskscounter equals 0and executor in shutdown state, then set terminated state and notify terminationtopicnameif scheduledrequestid is not null thendelete scheduled task",
	"Method": "void finish(String requestId,Date nextDate){\r\n    String script = \"\";\r\n    if (nextDate == null) {\r\n        script += \"local scheduled = redis.call('zscore', KEYS[5], ARGV[3]);\" + \"if scheduled == false then \" + \"redis.call('hdel', KEYS[4], ARGV[3]); \" + \"end;\";\r\n    }\r\n    script += \"redis.call('zrem', KEYS[5], 'ff' .. ARGV[3]);\" + \"if redis.call('decr', KEYS[1]) == 0 then \" + \"redis.call('del', KEYS[1]);\" + \"if redis.call('get', KEYS[2]) == ARGV[1] then \" + \"redis.call('del', KEYS[6]);\" + \"redis.call('set', KEYS[2], ARGV[2]);\" + \"redis.call('publish', KEYS[3], ARGV[2]);\" + \"end;\" + \"end;\";\r\n    commandExecutor.evalWriteAsync(name, StringCodec.INSTANCE, RedisCommands.EVAL_VOID, script, Arrays.<Object>asList(tasksCounterName, statusName, terminationTopicName, tasksName, schedulerQueueName, tasksRetryIntervalName), RedissonExecutorService.SHUTDOWN_STATE, RedissonExecutorService.TERMINATED_STATE, requestId);\r\n}"
}, {
	"Path": "com.facebook.presto.sql.analyzer.RelationType.withOnlyVisibleFields",
	"Comment": "creates a new tuple descriptor containing only the visible fields.",
	"Method": "RelationType withOnlyVisibleFields(){\r\n    return new RelationType(visibleFields);\r\n}"
}, {
	"Path": "com.facebook.presto.block.BlockAssertions.createLongsBlock",
	"Comment": "this method makes it easy to create blocks without having to add an l to every value",
	"Method": "Block createLongsBlock(int values,Block createLongsBlock,Long values,Block createLongsBlock,Iterable<Long> values){\r\n    return createTypedLongsBlock(BIGINT, values);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorMetadata.resolveIndex",
	"Comment": "try to locate a table index that can lookup results by indexablecolumns and provide the requested outputcolumns.",
	"Method": "Optional<ConnectorResolvedIndex> resolveIndex(ConnectorSession session,ConnectorTableHandle tableHandle,Set<ColumnHandle> indexableColumns,Set<ColumnHandle> outputColumns,TupleDomain<ColumnHandle> tupleDomain){\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "com.facebook.presto.verifier.VerifyCommand.getQueryDatabase",
	"Comment": "override this method to use a different method of acquiring a database connection.",
	"Method": "ConnectionFactory getQueryDatabase(Injector injector){\r\n    VerifierConfig config = injector.getInstance(VerifierConfig.class);\r\n    return () -> DriverManager.getConnection(config.getQueryDatabase());\r\n}"
}, {
	"Path": "io.realm.RealmQuery.count",
	"Comment": "counts the number of objects that fulfill the query conditions.",
	"Method": "long count(){\r\n    realm.checkIfValid();\r\n    return lazyFindAll().size();\r\n}"
}, {
	"Path": "com.facebook.presto.verifier.VerifyCommand.getParserOptions",
	"Comment": "override this method to change the parser options used when parsing queries to decide if they match the allowed query types",
	"Method": "SqlParserOptions getParserOptions(){\r\n    return new SqlParserOptions();\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorMetadata.createView",
	"Comment": "create the specified view. the data for the view is opaque to the connector.",
	"Method": "void createView(ConnectorSession session,SchemaTableName viewName,String viewData,boolean replace){\r\n    throw new PrestoException(NOT_SUPPORTED, \"This connector does not support creating views\");\r\n}"
}, {
	"Path": "com.facebook.presto.orc.DictionaryCompressionOptimizer.selectDictionaryColumnToConvert",
	"Comment": "choose a dictionary column to convert to direct encoding.we do this by predicting the compression rationof the stripe if a singe column is flipped to direct.so for each column, we try to predict the row countwhen we will hit a stripe flush limit if that column were converted to direct.once we know the row count, wecalculate the predicted compression ratio.",
	"Method": "DictionaryCompressionProjection selectDictionaryColumnToConvert(int totalNonDictionaryBytes,int stripeRowCount){\r\n    checkState(!directConversionCandidates.isEmpty());\r\n    int totalNonDictionaryBytesPerRow = totalNonDictionaryBytes / stripeRowCount;\r\n    long totalDictionaryRawBytes = 0;\r\n    long totalDictionaryBytes = 0;\r\n    long totalDictionaryIndexBytes = 0;\r\n    long totalDictionaryRawBytesPerRow = 0;\r\n    long totalDictionaryBytesPerNewRow = 0;\r\n    long totalDictionaryIndexBytesPerRow = 0;\r\n    for (DictionaryColumnManager column : allWriters) {\r\n        if (!column.isDirectEncoded()) {\r\n            totalDictionaryRawBytes += column.getRawBytes();\r\n            totalDictionaryBytes += column.getDictionaryBytes();\r\n            totalDictionaryIndexBytes += column.getIndexBytes();\r\n            totalDictionaryRawBytesPerRow += column.getRawBytesPerRow();\r\n            totalDictionaryBytesPerNewRow += column.getDictionaryBytesPerFutureRow();\r\n            totalDictionaryIndexBytesPerRow += column.getIndexBytesPerRow();\r\n        }\r\n    }\r\n    long totalUncompressedBytesPerRow = totalNonDictionaryBytesPerRow + totalDictionaryRawBytesPerRow;\r\n    DictionaryCompressionProjection maxProjectedCompression = null;\r\n    for (DictionaryColumnManager column : directConversionCandidates) {\r\n        long currentRawBytes = totalNonDictionaryBytes + column.getRawBytes();\r\n        long currentDictionaryBytes = totalDictionaryBytes - column.getDictionaryBytes();\r\n        long currentIndexBytes = totalDictionaryIndexBytes - column.getIndexBytes();\r\n        long currentTotalBytes = currentRawBytes + currentDictionaryBytes + currentIndexBytes;\r\n        double rawBytesPerFutureRow = totalNonDictionaryBytesPerRow + column.getRawBytesPerRow();\r\n        double dictionaryBytesPerFutureRow = totalDictionaryBytesPerNewRow - column.getDictionaryBytesPerFutureRow();\r\n        double indexBytesPerFutureRow = totalDictionaryIndexBytesPerRow - column.getIndexBytesPerRow();\r\n        double totalBytesPerFutureRow = rawBytesPerFutureRow + dictionaryBytesPerFutureRow + indexBytesPerFutureRow;\r\n        long rowsToDictionaryMemoryLimit = (long) ((dictionaryMemoryMaxBytesLow - currentDictionaryBytes) / dictionaryBytesPerFutureRow);\r\n        long rowsToStripeMemoryLimit = (long) ((stripeMaxBytes - currentTotalBytes) / totalBytesPerFutureRow);\r\n        long rowsToStripeRowLimit = stripeMaxRowCount - stripeRowCount;\r\n        long rowsToLimit = Longs.min(rowsToDictionaryMemoryLimit, rowsToStripeMemoryLimit, rowsToStripeRowLimit);\r\n        long predictedUncompressedSizeAtLimit = totalNonDictionaryBytes + totalDictionaryRawBytes + (totalUncompressedBytesPerRow * rowsToLimit);\r\n        long predictedCompressedSizeAtLimit = (long) (currentTotalBytes + (totalBytesPerFutureRow * rowsToLimit));\r\n        double predictedCompressionRatioAtLimit = 1.0 * predictedUncompressedSizeAtLimit / predictedCompressedSizeAtLimit;\r\n        if (maxProjectedCompression == null || maxProjectedCompression.getPredictedFileCompressionRatio() < predictedCompressionRatioAtLimit) {\r\n            maxProjectedCompression = new DictionaryCompressionProjection(column, predictedCompressionRatioAtLimit);\r\n        }\r\n    }\r\n    return maxProjectedCompression;\r\n}"
}, {
	"Path": "com.facebook.presto.raptor.util.RebindSafeMBeanServer.registerMBean",
	"Comment": "delegates to the wrapped mbean server, but if a mbean is already registeredwith the specified name, the existing instance is returned.",
	"Method": "ObjectInstance registerMBean(Object object,ObjectName name){\r\n    while (true) {\r\n        try {\r\n            return mbeanServer.registerMBean(object, name);\r\n        } catch (InstanceAlreadyExistsException ignored) {\r\n        }\r\n        try {\r\n            ObjectInstance objectInstance = mbeanServer.getObjectInstance(name);\r\n            log.debug(\"%s already bound to %s\", name, objectInstance);\r\n            return objectInstance;\r\n        } catch (InstanceNotFoundException ignored) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.operator.TestDriver.testConcurrentClose",
	"Comment": "the race can be reproduced somewhat reliably when the invocationcount is 10k, but we use 1k iterations to cap the test runtime.",
	"Method": "void testConcurrentClose(){\r\n    List<Type> types = ImmutableList.of(VARCHAR, BIGINT, BIGINT);\r\n    OperatorContext operatorContext = driverContext.addOperatorContext(0, new PlanNodeId(\"test\"), \"values\");\r\n    ValuesOperator source = new ValuesOperator(operatorContext, rowPagesBuilder(types).addSequencePage(10, 20, 30, 40).build());\r\n    Operator sink = createSinkOperator(types);\r\n    Driver driver = Driver.createDriver(driverContext, source, sink);\r\n    scheduledExecutor.submit(() -> driver.processFor(new Duration(1, TimeUnit.NANOSECONDS)));\r\n    scheduledExecutor.submit(() -> driver.close());\r\n    while (!driverContext.isDone()) {\r\n        Uninterruptibles.sleepUninterruptibly(1, TimeUnit.MILLISECONDS);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.orc.DiskRange.span",
	"Comment": "returns the minimal diskrange that encloses both this diskrangeand otherdiskrange. if there was a gap between the ranges thenew range will cover that gap.",
	"Method": "DiskRange span(DiskRange otherDiskRange){\r\n    requireNonNull(otherDiskRange, \"otherDiskRange is null\");\r\n    long start = Math.min(this.offset, otherDiskRange.getOffset());\r\n    long end = Math.max(getEnd(), otherDiskRange.getEnd());\r\n    return new DiskRange(start, toIntExact(end - start));\r\n}"
}, {
	"Path": "com.facebook.presto.spi.block.RowBlock.createRowBlockInternal",
	"Comment": "create a row block directly without per element validations.",
	"Method": "RowBlock createRowBlockInternal(int startOffset,int positionCount,boolean[] rowIsNull,int[] fieldBlockOffsets,Block[] fieldBlocks){\r\n    validateConstructorArguments(startOffset, positionCount, rowIsNull, fieldBlockOffsets, fieldBlocks);\r\n    return new RowBlock(startOffset, positionCount, rowIsNull, fieldBlockOffsets, fieldBlocks);\r\n}"
}, {
	"Path": "com.facebook.rebound.SpringTest.testSpringDoesNotActivateAfterRest",
	"Comment": "this test for springlisteners has been formatted with a specific case that has been known topush a spring out of rest right after having gone to rest.",
	"Method": "void testSpringDoesNotActivateAfterRest(){\r\n    SpringListener listener = spy(new SimpleSpringListener());\r\n    mSpring.addListener(listener);\r\n    mSpring.setSpringConfig(new SpringConfig(628.4, 37.0)).setRestSpeedThreshold(0.005f).setRestDisplacementThreshold(0.005f).setCurrentValue(0f).setEndValue(1f);\r\n    InOrder inOrder = inOrder(listener);\r\n    float[] frameTimes = new float[] { 0.034f, 0.050f, 0.019f, 0.016f, 0.016f, 0.017f, 0.031f, 0.016f, 0.017f, 0.034f, 0.018f, 0.017f, 0.032f, 0.014f, 0.016f, 0.033f, 0.017f, 0.016f, 0.036f };\r\n    for (float frameTime : frameTimes) {\r\n        mSpring.advance(frameTime);\r\n    }\r\n    inOrder.verify(listener).onSpringEndStateChange(mSpring);\r\n    inOrder.verify(listener).onSpringActivate(mSpring);\r\n    inOrder.verify(listener, times(17)).onSpringUpdate(mSpring);\r\n    inOrder.verify(listener).onSpringAtRest(mSpring);\r\n    inOrder.verify(listener, never()).onSpringActivate(mSpring);\r\n    inOrder.verify(listener, never()).onSpringUpdate(mSpring);\r\n    inOrder.verify(listener, never()).onSpringAtRest(mSpring);\r\n}"
}, {
	"Path": "io.realm.permissions.PermissionRequest.getAccessLevel",
	"Comment": "returns the access level that users will be granted if the request is successful.",
	"Method": "AccessLevel getAccessLevel(){\r\n    return accessLevel;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.block.ArrayBlock.fromElementBlock",
	"Comment": "create an array block directly from columnar nulls, values, and offsets into the values.a null array must have no entries.",
	"Method": "Block fromElementBlock(int positionCount,Optional<boolean[]> valueIsNull,int[] arrayOffset,Block values){\r\n    validateConstructorArguments(0, positionCount, valueIsNull.orElse(null), arrayOffset, values);\r\n    for (int i = 0; i < positionCount; i++) {\r\n        int offset = arrayOffset[i];\r\n        int length = arrayOffset[i + 1] - offset;\r\n        if (length < 0) {\r\n            throw new IllegalArgumentException(format(\"Offset is not monotonically ascending. offsets[%s]=%s, offsets[%s]=%s\", i, arrayOffset[i], i + 1, arrayOffset[i + 1]));\r\n        }\r\n        if (valueIsNull.isPresent() && valueIsNull.get()[i] && length != 0) {\r\n            throw new IllegalArgumentException(\"A null array must have zero entries\");\r\n        }\r\n    }\r\n    return new ArrayBlock(0, positionCount, valueIsNull.orElse(null), arrayOffset, values);\r\n}"
}, {
	"Path": "com.facebook.presto.spiller.SpillSpaceTracker.reserve",
	"Comment": "reserves the given number of bytes to spill. if more than the maximum, throws an exception.",
	"Method": "ListenableFuture<?> reserve(long bytes){\r\n    checkArgument(bytes >= 0, \"bytes is negative\");\r\n    if ((currentBytes + bytes) >= maxBytes) {\r\n        throw exceededLocalLimit(succinctBytes(maxBytes));\r\n    }\r\n    currentBytes += bytes;\r\n    return NOT_BLOCKED;\r\n}"
}, {
	"Path": "io.realm.internal.util.Pair.hashCode",
	"Comment": "compute a hash code using the hash codes of the underlying objects.",
	"Method": "int hashCode(){\r\n    return (first == null ? 0 : first.hashCode()) ^ (second == null ? 0 : second.hashCode());\r\n}"
}, {
	"Path": "com.facebook.presto.sql.planner.optimizations.AddExchanges.matchedLayoutPreference",
	"Comment": "prefer the match result that satisfied the most requirements",
	"Method": "Comparator<List<Optional<LocalProperty<T>>>> matchedLayoutPreference(){\r\n    return (matchLayout1, matchLayout2) -> {\r\n        Iterator<Optional<LocalProperty<T>>> match1Iterator = matchLayout1.iterator();\r\n        Iterator<Optional<LocalProperty<T>>> match2Iterator = matchLayout2.iterator();\r\n        while (match1Iterator.hasNext() && match2Iterator.hasNext()) {\r\n            Optional<LocalProperty<T>> match1 = match1Iterator.next();\r\n            Optional<LocalProperty<T>> match2 = match2Iterator.next();\r\n            if (match1.isPresent() && match2.isPresent()) {\r\n                return Integer.compare(match1.get().getColumns().size(), match2.get().getColumns().size());\r\n            } else if (match1.isPresent()) {\r\n                return 1;\r\n            } else if (match2.isPresent()) {\r\n                return -1;\r\n            }\r\n        }\r\n        checkState(!match1Iterator.hasNext() && !match2Iterator.hasNext());\r\n        return 0;\r\n    };\r\n}"
}, {
	"Path": "io.realm.TestHelper.createTableWithAllColumnTypes",
	"Comment": "creates an empty table with 1 column of all our supported column types, currently 7 columns.",
	"Method": "Table createTableWithAllColumnTypes(OsSharedRealm sharedRealm,Table createTableWithAllColumnTypes,OsSharedRealm sharedRealm,String name){\r\n    boolean wasInTransaction = sharedRealm.isInTransaction();\r\n    if (!wasInTransaction) {\r\n        sharedRealm.beginTransaction();\r\n    }\r\n    try {\r\n        Table t = sharedRealm.createTable(name);\r\n        t.addColumn(RealmFieldType.BINARY, \"binary\");\r\n        t.addColumn(RealmFieldType.BOOLEAN, \"boolean\");\r\n        t.addColumn(RealmFieldType.DATE, \"date\");\r\n        t.addColumn(RealmFieldType.DOUBLE, \"double\");\r\n        t.addColumn(RealmFieldType.FLOAT, \"float\");\r\n        t.addColumn(RealmFieldType.INTEGER, \"long\");\r\n        t.addColumn(RealmFieldType.STRING, \"string\");\r\n        return t;\r\n    } catch (RuntimeException e) {\r\n        if (!wasInTransaction) {\r\n            sharedRealm.cancelTransaction();\r\n        }\r\n        throw e;\r\n    } finally {\r\n        if (!wasInTransaction && sharedRealm.isInTransaction()) {\r\n            sharedRealm.commitTransaction();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.internal.sync.PermissionHelper.findOrCreatePermissionForRole",
	"Comment": "finds or creates the permission object for a given role. creating objects if they cannotbe found.",
	"Method": "Permission findOrCreatePermissionForRole(RealmObject container,RealmList<Permission> permissions,String roleName){\r\n    if (!container.isManaged()) {\r\n        throw new IllegalStateException(\"'findOrCreate()' can only be called on managed objects.\");\r\n    }\r\n    Realm realm = container.getRealm();\r\n    if (!realm.isInTransaction()) {\r\n        throw new IllegalStateException(\"'findOrCreate()' can only be called inside a write transaction.\");\r\n    }\r\n    Permission permission = permissions.where().equalTo(\"role.name\", roleName).findFirst();\r\n    if (permission == null) {\r\n        Role role = realm.where(Role.class).equalTo(\"name\", roleName).findFirst();\r\n        if (role == null) {\r\n            role = realm.createObject(Role.class, roleName);\r\n        }\r\n        permission = realm.copyToRealm(new Permission.Builder(role).noPrivileges().build());\r\n        permissions.add(permission);\r\n    }\r\n    return permission;\r\n}"
}, {
	"Path": "io.realm.ClientResetRequiredError.getOriginalFile",
	"Comment": "returns the location of the original realm file. after the client reset has completed, the file at this locationwill be deleted.",
	"Method": "File getOriginalFile(){\r\n    return originalFile;\r\n}"
}, {
	"Path": "io.realm.permissions.UserCondition.getValue",
	"Comment": "returns the value that is used when matching users. the semantics of the value will be differentdepending on the type of key used.",
	"Method": "String getValue(){\r\n    return value;\r\n}"
}, {
	"Path": "org.redisson.client.RedisConnection.getChannel",
	"Comment": "access to netty channel.this method is provided to use in debug info only.",
	"Method": "Channel getChannel(){\r\n    return channel;\r\n}"
}, {
	"Path": "org.redisson.config.Config.setExecutor",
	"Comment": "use external executorservice. executorservice processes all listeners of rtopic, rremoteservice invocation handlersand rexecutorservice tasks.the caller is responsible for closing the executorservice.",
	"Method": "Config setExecutor(ExecutorService executor){\r\n    this.executor = executor;\r\n    return this;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanGrantTablePrivilege",
	"Comment": "check if identity is allowed to grant to any other user the specified privilege on the specified table.",
	"Method": "void checkCanGrantTablePrivilege(ConnectorTransactionHandle transactionHandle,Identity identity,Privilege privilege,SchemaTableName tableName,String grantee,boolean withGrantOption){\r\n    denyGrantTablePrivilege(privilege.toString(), tableName.toString());\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanCreateSchema",
	"Comment": "check if identity is allowed to create the specified schema in a catalog.",
	"Method": "void checkCanCreateSchema(Identity identity,CatalogSchemaName schema){\r\n    denyCreateSchema(schema.toString());\r\n}"
}, {
	"Path": "com.facebook.presto.spi.ConnectorPageSink.getCompletedBytes",
	"Comment": "gets the number of output bytes written by this page source so far.if size is not available, this method should return zero.",
	"Method": "long getCompletedBytes(){\r\n    return 0;\r\n}"
}, {
	"Path": "io.realm.internal.ObserverPairListTests.add_worksAfterClears",
	"Comment": "1. add 2. clear 3. add 4. check if the last listener can still be called.",
	"Method": "void add_worksAfterClears(){\r\n    final AtomicBoolean foreachCalled = new AtomicBoolean(false);\r\n    TestObserverPair pair = new TestObserverPair(ONE, testListener);\r\n    observerPairs.add(pair);\r\n    assertEquals(1, observerPairs.size());\r\n    observerPairs.clear();\r\n    observerPairs.add(pair);\r\n    assertEquals(1, observerPairs.size());\r\n    observerPairs.foreach(new ObserverPairList.Callback<TestObserverPair>() {\r\n        @Override\r\n        public void onCalled(TestObserverPair pair, Object observer) {\r\n            assertEquals(ONE, observer);\r\n            foreachCalled.set(true);\r\n        }\r\n    });\r\n    assertTrue(foreachCalled.get());\r\n}"
}, {
	"Path": "io.realm.internal.ObserverPairListTests.add_worksAfterClears",
	"Comment": "1. add 2. clear 3. add 4. check if the last listener can still be called.",
	"Method": "void add_worksAfterClears(){\r\n    assertEquals(ONE, observer);\r\n    foreachCalled.set(true);\r\n}"
}, {
	"Path": "io.realm.PermissionManager.revokeOffer",
	"Comment": "revokes an existing offer. this will prevent any other users from accepting it. users that already accepted it,will not be affected. revocation cannot happen until the device has talked to the server. the callback willnot be notified until this has happened.",
	"Method": "RealmAsyncTask revokeOffer(String offerToken,RevokeOfferCallback callback){\r\n    checkIfValid();\r\n    checkCallbackNotNull(callback);\r\n    return addTask(new RevokeOfferAsyncTask(this, offerToken, callback));\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.getCurrentDisplacementDistance",
	"Comment": "get the displacement of the springs current value from its rest value.",
	"Method": "double getCurrentDisplacementDistance(){\r\n    return getDisplacementDistanceForState(mCurrentState);\r\n}"
}, {
	"Path": "io.realm.SyncUser.getIdentity",
	"Comment": "returns the identity of this user on the realm object server. the identity is a guaranteed to be uniqueamong all users on the realm object server.",
	"Method": "String getIdentity(){\r\n    return identity;\r\n}"
}, {
	"Path": "com.facebook.presto.sql.planner.iterative.rule.MergeLimitWithDistinct.isDistinct",
	"Comment": "whether this node corresponds to a distinct operation in sql",
	"Method": "boolean isDistinct(AggregationNode node){\r\n    return node.getAggregations().isEmpty() && node.getOutputSymbols().size() == node.getGroupingKeys().size() && node.getOutputSymbols().containsAll(node.getGroupingKeys());\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_onCommitRealmResults",
	"Comment": "a listener registered on the backlinked field should be called when a commit adds a backlink",
	"Method": "void notification_onCommitRealmResults(){\r\n    final Realm looperThreadRealm = looperThread.getRealm();\r\n    looperThreadRealm.beginTransaction();\r\n    AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);\r\n    looperThreadRealm.commitTransaction();\r\n    final AtomicInteger counter = new AtomicInteger(0);\r\n    RealmChangeListener<RealmResults<AllJavaTypes>> listener = new RealmChangeListener<RealmResults<AllJavaTypes>>() {\r\n        @Override\r\n        public void onChange(RealmResults<AllJavaTypes> object) {\r\n            counter.incrementAndGet();\r\n        }\r\n    };\r\n    child.getObjectParents().addChangeListener(listener);\r\n    looperThreadRealm.beginTransaction();\r\n    AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);\r\n    parent.setFieldObject(child);\r\n    looperThreadRealm.commitTransaction();\r\n    verifyPostConditions(looperThreadRealm, new PostConditions() {\r\n        @Override\r\n        public void run(Realm realm) {\r\n            assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());\r\n            assertEquals(1, counter.get());\r\n        }\r\n    }, child, parent);\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_onCommitRealmResults",
	"Comment": "a listener registered on the backlinked field should be called when a commit adds a backlink",
	"Method": "void notification_onCommitRealmResults(){\r\n    counter.incrementAndGet();\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_onCommitRealmResults",
	"Comment": "a listener registered on the backlinked field should be called when a commit adds a backlink",
	"Method": "void notification_onCommitRealmResults(){\r\n    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());\r\n    assertEquals(1, counter.get());\r\n}"
}, {
	"Path": "io.realm.internal.fields.FieldDescriptor.parseFieldDescription",
	"Comment": "parse the passed field description into its components.this must be standard across implementations and is, therefore, implemented in the base class.",
	"Method": "List<String> parseFieldDescription(String fieldDescription){\r\n    if (fieldDescription == null || fieldDescription.equals(\"\")) {\r\n        throw new IllegalArgumentException(\"Invalid query: field name is empty\");\r\n    }\r\n    int lastDotIndex = fieldDescription.lastIndexOf(\".\");\r\n    if (lastDotIndex == fieldDescription.length() - 1) {\r\n        throw new IllegalArgumentException(\"Invalid query: field name must not end with a period ('.')\");\r\n    }\r\n    if (lastDotIndex > -1) {\r\n        return Arrays.asList(FIELD_SEPARATOR.split(fieldDescription));\r\n    } else {\r\n        return Collections.singletonList(fieldDescription);\r\n    }\r\n}"
}, {
	"Path": "io.realm.ObjectServerError.getErrorCode",
	"Comment": "returns the error code uniquely identifying this type of error.",
	"Method": "ErrorCode getErrorCode(){\r\n    return error;\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync_cancelTransactionInside",
	"Comment": "tests that an async transaction that throws when call canceltransaction manually.",
	"Method": "void executeTransactionAsync_cancelTransactionInside(){\r\n    final TestHelper.TestLogger testLogger = new TestHelper.TestLogger(LogLevel.DEBUG);\r\n    RealmLog.add(testLogger);\r\n    final Realm realm = looperThread.getRealm();\r\n    assertEquals(0, realm.where(Owner.class).count());\r\n    realm.executeTransactionAsync(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            Owner owner = realm.createObject(Owner.class);\r\n            owner.setName(\"Owner\");\r\n            realm.cancelTransaction();\r\n        }\r\n    }, new Realm.Transaction.OnSuccess() {\r\n        @Override\r\n        public void onSuccess() {\r\n            fail(\"Should not reach success if runtime exception is thrown in callback.\");\r\n        }\r\n    }, new Realm.Transaction.OnError() {\r\n        @Override\r\n        public void onError(Throwable error) {\r\n            assertTrue(testLogger.message.contains(\"Exception has been thrown: Can't commit a non-existing write transaction\"));\r\n            assertTrue(error instanceof IllegalStateException);\r\n            RealmLog.remove(testLogger);\r\n            looperThread.testComplete();\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync_cancelTransactionInside",
	"Comment": "tests that an async transaction that throws when call canceltransaction manually.",
	"Method": "void executeTransactionAsync_cancelTransactionInside(){\r\n    Owner owner = realm.createObject(Owner.class);\r\n    owner.setName(\"Owner\");\r\n    realm.cancelTransaction();\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync_cancelTransactionInside",
	"Comment": "tests that an async transaction that throws when call canceltransaction manually.",
	"Method": "void executeTransactionAsync_cancelTransactionInside(){\r\n    fail(\"Should not reach success if runtime exception is thrown in callback.\");\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync_cancelTransactionInside",
	"Comment": "tests that an async transaction that throws when call canceltransaction manually.",
	"Method": "void executeTransactionAsync_cancelTransactionInside(){\r\n    assertTrue(testLogger.message.contains(\"Exception has been thrown: Can't commit a non-existing write transaction\"));\r\n    assertTrue(error instanceof IllegalStateException);\r\n    RealmLog.remove(testLogger);\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanRevokeTablePrivilege",
	"Comment": "check if identity is allowed to revoke the specified privilege on the specified table from any user.",
	"Method": "void checkCanRevokeTablePrivilege(ConnectorTransactionHandle transactionHandle,Identity identity,Privilege privilege,SchemaTableName tableName,String revokee,boolean grantOptionFor){\r\n    denyRevokeTablePrivilege(privilege.toString(), tableName.toString());\r\n}"
}, {
	"Path": "org.redisson.executor.TasksRunnerService.asyncScheduledServiceAtFixed",
	"Comment": "creates remoteexecutorserviceasync with special executor which overrides requestid generationand uses current requestid. because recurring tasks should use the same requestid.",
	"Method": "RemoteExecutorServiceAsync asyncScheduledServiceAtFixed(String executorId,String requestId){\r\n    ScheduledTasksService scheduledRemoteService = new ScheduledTasksService(codec, redisson, name, commandExecutor, executorId, responses);\r\n    scheduledRemoteService.setTerminationTopicName(terminationTopicName);\r\n    scheduledRemoteService.setTasksCounterName(tasksCounterName);\r\n    scheduledRemoteService.setStatusName(statusName);\r\n    scheduledRemoteService.setSchedulerQueueName(schedulerQueueName);\r\n    scheduledRemoteService.setSchedulerChannelName(schedulerChannelName);\r\n    scheduledRemoteService.setTasksName(tasksName);\r\n    scheduledRemoteService.setRequestId(new RequestId(requestId));\r\n    scheduledRemoteService.setTasksRetryIntervalName(tasksRetryIntervalName);\r\n    RemoteExecutorServiceAsync asyncScheduledServiceAtFixed = scheduledRemoteService.get(RemoteExecutorServiceAsync.class, RemoteInvocationOptions.defaults().noAck().noResult());\r\n    return asyncScheduledServiceAtFixed;\r\n}"
}, {
	"Path": "io.realm.RealmObjectTests.addChangeListener_throwInsiderTransaction",
	"Comment": "object store will throw when adding change listener inside a transaction.",
	"Method": "void addChangeListener_throwInsiderTransaction(){\r\n    Realm realm = looperThread.getRealm();\r\n    realm.beginTransaction();\r\n    Dog dog = realm.createObject(Dog.class);\r\n    try {\r\n        dog.addChangeListener(new RealmChangeListener<Dog>() {\r\n            @Override\r\n            public void onChange(Dog element) {\r\n                fail();\r\n            }\r\n        });\r\n    } catch (IllegalStateException ignored) {\r\n    }\r\n    try {\r\n        dog.addChangeListener(new RealmObjectChangeListener<Dog>() {\r\n            @Override\r\n            public void onChange(Dog object, ObjectChangeSet changeSet) {\r\n                fail();\r\n            }\r\n        });\r\n    } catch (IllegalStateException ignored) {\r\n    }\r\n    realm.cancelTransaction();\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "io.realm.RealmObjectTests.addChangeListener_throwInsiderTransaction",
	"Comment": "object store will throw when adding change listener inside a transaction.",
	"Method": "void addChangeListener_throwInsiderTransaction(){\r\n    fail();\r\n}"
}, {
	"Path": "io.realm.RealmObjectTests.addChangeListener_throwInsiderTransaction",
	"Comment": "object store will throw when adding change listener inside a transaction.",
	"Method": "void addChangeListener_throwInsiderTransaction(){\r\n    fail();\r\n}"
}, {
	"Path": "org.redisson.api.TransactionOptions.syncSlavesTimeout",
	"Comment": "synchronization data timeout between redis master participating in transaction and its slaves.default is 5000 milliseconds",
	"Method": "TransactionOptions syncSlavesTimeout(long syncTimeout,TimeUnit syncUnit){\r\n    this.syncTimeout = syncUnit.toMillis(syncTimeout);\r\n    return this;\r\n}"
}, {
	"Path": "io.realm.BaseRealm.writeEncryptedCopyTo",
	"Comment": "writes a compacted and encrypted copy of the realm to the given destination file.the destination file cannot already exist.note that if this is called from within a transaction it writes the current data, and not the data as it was whenthe last transaction was committed.",
	"Method": "void writeEncryptedCopyTo(File destination,byte[] key){\r\n    if (destination == null) {\r\n        throw new IllegalArgumentException(\"The destination argument cannot be null\");\r\n    }\r\n    checkIfValid();\r\n    sharedRealm.writeCopy(destination, key);\r\n}"
}, {
	"Path": "io.realm.RealmConfiguration.isSyncConfiguration",
	"Comment": "checks if this configuration is a syncconfiguration instance.",
	"Method": "boolean isSyncConfiguration(){\r\n    return false;\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.localColumnIndices",
	"Comment": "creating a new realm b. global column indices will not work. they must be calculated for each realm.",
	"Method": "void localColumnIndices(){\r\n    String MIGRATED_REALM = \"migrated.realm\";\r\n    String NEW_REALM = \"new.realm\";\r\n    RealmConfiguration v1Config = configFactory.createConfigurationBuilder().name(MIGRATED_REALM).schema(StringOnly.class).schemaVersion(1).build();\r\n    Realm oldRealm = Realm.getInstance(v1Config);\r\n    oldRealm.close();\r\n    RealmMigration migration = new RealmMigration() {\r\n        @Override\r\n        public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {\r\n            RealmSchema schema = realm.getSchema();\r\n            schema.create(\"FieldOrder\").addField(\"field2\", int.class).addField(\"field1\", boolean.class);\r\n        }\r\n    };\r\n    RealmConfiguration v2Config = configFactory.createConfigurationBuilder().name(MIGRATED_REALM).schema(StringOnly.class, FieldOrder.class).schemaVersion(2).migration(migration).build();\r\n    oldRealm = Realm.getInstance(v2Config);\r\n    RealmConfiguration newConfig = configFactory.createConfigurationBuilder().name(NEW_REALM).schemaVersion(2).schema(StringOnly.class, FieldOrder.class).build();\r\n    Realm newRealm = Realm.getInstance(newConfig);\r\n    newRealm.close();\r\n    assertEquals(0, oldRealm.where(FieldOrder.class).equalTo(\"field1\", true).findAll().size());\r\n    oldRealm.close();\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.localColumnIndices",
	"Comment": "creating a new realm b. global column indices will not work. they must be calculated for each realm.",
	"Method": "void localColumnIndices(){\r\n    RealmSchema schema = realm.getSchema();\r\n    schema.create(\"FieldOrder\").addField(\"field2\", int.class).addField(\"field1\", boolean.class);\r\n}"
}, {
	"Path": "io.realm.TestHelper.addRowWithValues",
	"Comment": "appends the specified row to the end of the table. for internal testing usage only.",
	"Method": "long addRowWithValues(Table table,Object values){\r\n    long rowIndex = OsObject.createRow(table);\r\n    int columns = (int) table.getColumnCount();\r\n    if (columns != values.length) {\r\n        throw new IllegalArgumentException(\"The number of value parameters (\" + String.valueOf(values.length) + \") does not match the number of columns in the table (\" + String.valueOf(columns) + \").\");\r\n    }\r\n    RealmFieldType[] colTypes = new RealmFieldType[columns];\r\n    for (int columnIndex = 0; columnIndex < columns; columnIndex++) {\r\n        Object value = values[columnIndex];\r\n        RealmFieldType colType = table.getColumnType(columnIndex);\r\n        colTypes[columnIndex] = colType;\r\n        if (!colType.isValid(value)) {\r\n            String providedType;\r\n            if (value == null) {\r\n                providedType = \"null\";\r\n            } else {\r\n                providedType = value.getClass().toString();\r\n            }\r\n            throw new IllegalArgumentException(\"Invalid argument no \" + String.valueOf(1 + columnIndex) + \". Expected a value compatible with column type \" + colType + \", but got \" + providedType + \".\");\r\n        }\r\n    }\r\n    for (long columnIndex = 0; columnIndex < columns; columnIndex++) {\r\n        Object value = values[(int) columnIndex];\r\n        switch(colTypes[(int) columnIndex]) {\r\n            case BOOLEAN:\r\n                if (value == null) {\r\n                    table.setNull(columnIndex, rowIndex, false);\r\n                } else {\r\n                    table.setBoolean(columnIndex, rowIndex, (Boolean) value, false);\r\n                }\r\n                break;\r\n            case INTEGER:\r\n                if (value == null) {\r\n                    table.setNull(columnIndex, rowIndex, false);\r\n                } else {\r\n                    long longValue = ((Number) value).longValue();\r\n                    table.setLong(columnIndex, rowIndex, longValue, false);\r\n                }\r\n                break;\r\n            case FLOAT:\r\n                if (value == null) {\r\n                    table.setNull(columnIndex, rowIndex, false);\r\n                } else {\r\n                    table.setFloat(columnIndex, rowIndex, (Float) value, false);\r\n                }\r\n                break;\r\n            case DOUBLE:\r\n                if (value == null) {\r\n                    table.setNull(columnIndex, rowIndex, false);\r\n                } else {\r\n                    table.setDouble(columnIndex, rowIndex, (Double) value, false);\r\n                }\r\n                break;\r\n            case STRING:\r\n                if (value == null) {\r\n                    table.setNull(columnIndex, rowIndex, false);\r\n                } else {\r\n                    table.setString(columnIndex, rowIndex, (String) value, false);\r\n                }\r\n                break;\r\n            case DATE:\r\n                if (value == null) {\r\n                    table.setNull(columnIndex, rowIndex, false);\r\n                } else {\r\n                    table.setDate(columnIndex, rowIndex, (Date) value, false);\r\n                }\r\n                break;\r\n            case BINARY:\r\n                if (value == null) {\r\n                    table.setNull(columnIndex, rowIndex, false);\r\n                } else {\r\n                    table.setBinaryByteArray(columnIndex, rowIndex, (byte[]) value, false);\r\n                }\r\n                break;\r\n            default:\r\n                throw new RuntimeException(\"Unexpected columnType: \" + String.valueOf(colTypes[(int) columnIndex]));\r\n        }\r\n    }\r\n    return rowIndex;\r\n}"
}, {
	"Path": "io.realm.processor.RealmProcessor.postProcessModules",
	"Comment": "returns true of modules where successfully validated, false otherwise",
	"Method": "boolean postProcessModules(){\r\n    return moduleMetaData.postProcess(classCollection);\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync_asyncQuery",
	"Comment": "ensures that onsuccess is called with the correct realm version for async transaction.",
	"Method": "void executeTransactionAsync_asyncQuery(){\r\n    final Realm realm = looperThread.getRealm();\r\n    final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();\r\n    assertEquals(0, results.size());\r\n    realm.executeTransactionAsync(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            realm.createObject(AllTypes.class);\r\n        }\r\n    }, new Realm.Transaction.OnSuccess() {\r\n        @Override\r\n        public void onSuccess() {\r\n            assertEquals(1, realm.where(AllTypes.class).count());\r\n            if (results.isLoaded()) {\r\n                assertEquals(1, results.size());\r\n            } else {\r\n                assertEquals(0, results.size());\r\n            }\r\n            looperThread.testComplete();\r\n        }\r\n    }, new Realm.Transaction.OnError() {\r\n        @Override\r\n        public void onError(Throwable error) {\r\n            fail();\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync_asyncQuery",
	"Comment": "ensures that onsuccess is called with the correct realm version for async transaction.",
	"Method": "void executeTransactionAsync_asyncQuery(){\r\n    realm.createObject(AllTypes.class);\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync_asyncQuery",
	"Comment": "ensures that onsuccess is called with the correct realm version for async transaction.",
	"Method": "void executeTransactionAsync_asyncQuery(){\r\n    assertEquals(1, realm.where(AllTypes.class).count());\r\n    if (results.isLoaded()) {\r\n        assertEquals(1, results.size());\r\n    } else {\r\n        assertEquals(0, results.size());\r\n    }\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransactionAsync_asyncQuery",
	"Comment": "ensures that onsuccess is called with the correct realm version for async transaction.",
	"Method": "void executeTransactionAsync_asyncQuery(){\r\n    fail();\r\n}"
}, {
	"Path": "com.facebook.presto.spi.predicate.TupleDomain.extractFixedValues",
	"Comment": "extract all column constraints that require exactly one value or only null in their respective domains.returns an empty optional if the domain is none.",
	"Method": "Optional<Map<T, NullableValue>> extractFixedValues(TupleDomain<T> tupleDomain){\r\n    if (!tupleDomain.getDomains().isPresent()) {\r\n        return Optional.empty();\r\n    }\r\n    return Optional.of(tupleDomain.getDomains().get().entrySet().stream().filter(entry -> entry.getValue().isNullableSingleValue()).collect(toMap(Map.Entry::getKey, entry -> new NullableValue(entry.getValue().getType(), entry.getValue().getNullableSingleValue()))));\r\n}"
}, {
	"Path": "org.redisson.executor.CronExpression.isSatisfiedBy",
	"Comment": "indicates whether the given date satisfies the cron expression. note thatmilliseconds are ignored, so two dates falling on different millisecondsof the same second will always have the same result here.",
	"Method": "boolean isSatisfiedBy(Date date){\r\n    Calendar testDateCal = Calendar.getInstance(getTimeZone());\r\n    testDateCal.setTime(date);\r\n    testDateCal.set(Calendar.MILLISECOND, 0);\r\n    Date originalDate = testDateCal.getTime();\r\n    testDateCal.add(Calendar.SECOND, -1);\r\n    Date timeAfter = getTimeAfter(testDateCal.getTime());\r\n    return ((timeAfter != null) && (timeAfter.equals(originalDate)));\r\n}"
}, {
	"Path": "io.realm.SyncedRealmMigrationTests.addingFields_rebuildIndexes",
	"Comment": "check that indexes are being added if other fields are being added as well",
	"Method": "void addingFields_rebuildIndexes(){\r\n    SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), \"http://foo.com/auth\").schema(IndexedFields.class).schemaVersion(42).build();\r\n    String className = IndexedFields.class.getSimpleName();\r\n    DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);\r\n    RealmSchema schema = dynamicRealm.getSchema();\r\n    dynamicRealm.beginTransaction();\r\n    // No index\r\n    schema.create(className).addField(IndexedFields.FIELD_INDEXED_STRING, String.class);\r\n    dynamicRealm.setVersion(41);\r\n    dynamicRealm.commitTransaction();\r\n    dynamicRealm.close();\r\n    Realm realm = Realm.getInstance(config);\r\n    try {\r\n        assertTrue(realm.getSchema().get(className).hasField(IndexedFields.FIELD_NON_INDEXED_STRING));\r\n        assertTrue(realm.getSchema().get(className).hasIndex(IndexedFields.FIELD_INDEXED_STRING));\r\n    } finally {\r\n        realm.close();\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmCache.deleteRealmFileOnDisk",
	"Comment": "attempts to delete the underlying realm. any errors happening here will just beoutputted to logcat instead of thrown as this method is only called from other exceptionhandlers which have more important exceptions to show to the user.this method is not threadsafe. synchronization should happen outside it.",
	"Method": "void deleteRealmFileOnDisk(RealmConfiguration configuration){\r\n    int attempts = 5;\r\n    boolean success = false;\r\n    while (attempts > 0 && !success) {\r\n        try {\r\n            success = BaseRealm.deleteRealm(configuration);\r\n        } catch (IllegalStateException e) {\r\n            attempts--;\r\n            RealmLog.warn(\"Sync server still holds a reference to the Realm. It cannot be deleted. Retrying \" + attempts + \" more times\");\r\n            if (attempts > 0) {\r\n                SystemClock.sleep(15);\r\n            }\r\n        }\r\n    }\r\n    if (!success) {\r\n        RealmLog.error(\"Failed to delete the underlying Realm file: \" + configuration.getPath());\r\n    }\r\n}"
}, {
	"Path": "org.redisson.config.BaseConfig.setSslProvider",
	"Comment": "defines ssl provider used to handle ssl connections.default is jdk",
	"Method": "T setSslProvider(SslProvider sslProvider){\r\n    this.sslProvider = sslProvider;\r\n    return (T) this;\r\n}"
}, {
	"Path": "org.redisson.api.BatchOptions.responseTimeout",
	"Comment": "defines timeout for redis response. starts to countdown when redis command has been successfully sent.default is 3000 milliseconds",
	"Method": "BatchOptions responseTimeout(long timeout,TimeUnit unit){\r\n    this.responseTimeout = unit.toMillis(timeout);\r\n    return this;\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.queryingLinkHandover",
	"Comment": "this test makes sure that async queries update when using link.",
	"Method": "void queryingLinkHandover(){\r\n    final AtomicInteger numberOfInvocations = new AtomicInteger(0);\r\n    final Realm realm = looperThread.getRealm();\r\n    final RealmResults<Dog> allAsync = realm.where(Dog.class).equalTo(\"owner.name\", \"kiba\").findAllAsync();\r\n    looperThread.keepStrongReference(allAsync);\r\n    allAsync.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {\r\n        @Override\r\n        public void onChange(RealmResults<Dog> object) {\r\n            switch(numberOfInvocations.incrementAndGet()) {\r\n                case 1:\r\n                    assertEquals(0, allAsync.size());\r\n                    assertTrue(allAsync.isLoaded());\r\n                    assertTrue(allAsync.isValid());\r\n                    assertTrue(allAsync.isEmpty());\r\n                    new RealmBackgroundTask(realm.getConfiguration()) {\r\n                        @Override\r\n                        public void doInBackground(Realm realm) {\r\n                            realm.beginTransaction();\r\n                            Dog dog = realm.createObject(Dog.class);\r\n                            dog.setAge(10);\r\n                            dog.setName(\"Akamaru\");\r\n                            Owner kiba = realm.createObject(Owner.class);\r\n                            kiba.setName(\"kiba\");\r\n                            dog.setOwner(kiba);\r\n                            realm.commitTransaction();\r\n                        }\r\n                    }.awaitOrFail();\r\n                    break;\r\n                case 2:\r\n                    assertEquals(1, realm.where(Dog.class).count());\r\n                    assertEquals(1, realm.where(Owner.class).count());\r\n                    assertEquals(1, allAsync.size());\r\n                    assertTrue(allAsync.isLoaded());\r\n                    assertTrue(allAsync.isValid());\r\n                    assertFalse(allAsync.isEmpty());\r\n                    assertEquals(1, allAsync.size());\r\n                    assertEquals(\"Akamaru\", allAsync.get(0).getName());\r\n                    assertEquals(\"kiba\", allAsync.get(0).getOwner().getName());\r\n                    looperThread.testComplete();\r\n                    break;\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.queryingLinkHandover",
	"Comment": "this test makes sure that async queries update when using link.",
	"Method": "void queryingLinkHandover(){\r\n    switch(numberOfInvocations.incrementAndGet()) {\r\n        case 1:\r\n            assertEquals(0, allAsync.size());\r\n            assertTrue(allAsync.isLoaded());\r\n            assertTrue(allAsync.isValid());\r\n            assertTrue(allAsync.isEmpty());\r\n            new RealmBackgroundTask(realm.getConfiguration()) {\r\n                @Override\r\n                public void doInBackground(Realm realm) {\r\n                    realm.beginTransaction();\r\n                    Dog dog = realm.createObject(Dog.class);\r\n                    dog.setAge(10);\r\n                    dog.setName(\"Akamaru\");\r\n                    Owner kiba = realm.createObject(Owner.class);\r\n                    kiba.setName(\"kiba\");\r\n                    dog.setOwner(kiba);\r\n                    realm.commitTransaction();\r\n                }\r\n            }.awaitOrFail();\r\n            break;\r\n        case 2:\r\n            assertEquals(1, realm.where(Dog.class).count());\r\n            assertEquals(1, realm.where(Owner.class).count());\r\n            assertEquals(1, allAsync.size());\r\n            assertTrue(allAsync.isLoaded());\r\n            assertTrue(allAsync.isValid());\r\n            assertFalse(allAsync.isEmpty());\r\n            assertEquals(1, allAsync.size());\r\n            assertEquals(\"Akamaru\", allAsync.get(0).getName());\r\n            assertEquals(\"kiba\", allAsync.get(0).getOwner().getName());\r\n            looperThread.testComplete();\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.queryingLinkHandover",
	"Comment": "this test makes sure that async queries update when using link.",
	"Method": "void queryingLinkHandover(){\r\n    realm.beginTransaction();\r\n    Dog dog = realm.createObject(Dog.class);\r\n    dog.setAge(10);\r\n    dog.setName(\"Akamaru\");\r\n    Owner kiba = realm.createObject(Owner.class);\r\n    kiba.setName(\"kiba\");\r\n    dog.setOwner(kiba);\r\n    realm.commitTransaction();\r\n}"
}, {
	"Path": "io.realm.processor.ClassMetaData.getBasicTypeFields",
	"Comment": "returns all persistable fields that contain a basic type, this include lists of primitives.",
	"Method": "List<RealmFieldElement> getBasicTypeFields(){\r\n    return Collections.unmodifiableList(basicTypeFields);\r\n}"
}, {
	"Path": "com.facebook.rebound.SpringChain.create",
	"Comment": "factory method for creating a new springchain with the provided springconfig.",
	"Method": "SpringChain create(SpringChain create,int mainTension,int mainFriction,int attachmentTension,int attachmentFriction){\r\n    return new SpringChain(mainTension, mainFriction, attachmentTension, attachmentFriction);\r\n}"
}, {
	"Path": "io.realm.Realm.getDefaultModule",
	"Comment": "returns the default realm module. this module contains all realm classes in the current project, but not thosefrom library or project dependencies. realm classes in these should be exposed using their own module.",
	"Method": "Object getDefaultModule(){\r\n    String moduleName = \"io.realm.DefaultRealmModule\";\r\n    Class<?> clazz;\r\n    try {\r\n        clazz = Class.forName(moduleName);\r\n        Constructor<?> constructor = clazz.getDeclaredConstructors()[0];\r\n        constructor.setAccessible(true);\r\n        return constructor.newInstance();\r\n    } catch (ClassNotFoundException e) {\r\n        return null;\r\n    } catch (InvocationTargetException e) {\r\n        throw new RealmException(\"Could not create an instance of \" + moduleName, e);\r\n    } catch (InstantiationException e) {\r\n        throw new RealmException(\"Could not create an instance of \" + moduleName, e);\r\n    } catch (IllegalAccessException e) {\r\n        throw new RealmException(\"Could not create an instance of \" + moduleName, e);\r\n    }\r\n}"
}, {
	"Path": "org.redisson.api.CronSchedule.monthlyOnDayAndHourAndMinute",
	"Comment": "creates cron expression which schedule task executionevery given day of the month at the given time",
	"Method": "CronSchedule monthlyOnDayAndHourAndMinute(int dayOfMonth,int hour,int minute){\r\n    String expression = String.format(\"0 %d %d %d * ?\", minute, hour, dayOfMonth);\r\n    return of(expression);\r\n}"
}, {
	"Path": "com.facebook.presto.orc.OrcWriter.bufferFileFooter",
	"Comment": "collect the data for for the file footer.this is not the actual data, butinstead are functions that know how to write the data.",
	"Method": "List<OrcDataOutput> bufferFileFooter(){\r\n    List<OrcDataOutput> outputData = new ArrayList();\r\n    Metadata metadata = new Metadata(closedStripes.stream().map(ClosedStripe::getStatistics).collect(toList()));\r\n    Slice metadataSlice = metadataWriter.writeMetadata(metadata);\r\n    outputData.add(createDataOutput(metadataSlice));\r\n    long numberOfRows = closedStripes.stream().mapToLong(stripe -> stripe.getStripeInformation().getNumberOfRows()).sum();\r\n    List<ColumnStatistics> fileStats = toFileStats(closedStripes.stream().map(ClosedStripe::getStatistics).map(StripeStatistics::getColumnStatistics).collect(toList()));\r\n    recordValidation(validation -> validation.setFileStatistics(fileStats));\r\n    Map<String, Slice> userMetadata = this.userMetadata.entrySet().stream().collect(Collectors.toMap(Entry::getKey, entry -> utf8Slice(entry.getValue())));\r\n    Footer footer = new Footer(numberOfRows, rowGroupMaxRowCount, closedStripes.stream().map(ClosedStripe::getStripeInformation).collect(toList()), orcTypes, fileStats, userMetadata);\r\n    closedStripes.clear();\r\n    closedStripesRetainedBytes = 0;\r\n    Slice footerSlice = metadataWriter.writeFooter(footer);\r\n    outputData.add(createDataOutput(footerSlice));\r\n    recordValidation(validation -> validation.setVersion(metadataWriter.getOrcMetadataVersion()));\r\n    Slice postscriptSlice = metadataWriter.writePostscript(footerSlice.length(), metadataSlice.length(), compression, maxCompressionBufferSize);\r\n    outputData.add(createDataOutput(postscriptSlice));\r\n    outputData.add(createDataOutput(Slices.wrappedBuffer((byte) postscriptSlice.length())));\r\n    return outputData;\r\n}"
}, {
	"Path": "com.facebook.presto.sql.analyzer.RelationType.getVisibleFields",
	"Comment": "gets only the visible fields.no assumptions should be made about the order of the fields returned from this method.to obtain the index of a field, call indexof.",
	"Method": "Collection<Field> getVisibleFields(){\r\n    return visibleFields;\r\n}"
}, {
	"Path": "com.facebook.presto.orc.OrcRecordReader.getReaderRowCount",
	"Comment": "returns the total number of rows that can possibly be read by this reader.this count may be fewer than the number of rows in the file if somestripes were excluded due to stripe statistics, but may be more thanthe number of rows read if some row groups are excluded due to statistics.",
	"Method": "long getReaderRowCount(){\r\n    return totalRowCount;\r\n}"
}, {
	"Path": "io.realm.internal.permissions.PermissionOfferResponse.isSuccessful",
	"Comment": "check if the request was successfully handled by the realm object server.",
	"Method": "boolean isSuccessful(){\r\n    return statusCode != null && statusCode == 0;\r\n}"
}, {
	"Path": "io.realm.NotificationsTest.doNotUseClosedHandler",
	"Comment": "prevents committransaction from accidentally posting messages to handlers which might reference a closed realm.",
	"Method": "void doNotUseClosedHandler(){\r\n    final CountDownLatch handlerNotified = new CountDownLatch(1);\r\n    final CountDownLatch backgroundThread1Started = new CountDownLatch(1);\r\n    final CountDownLatch backgroundThread2Closed = new CountDownLatch(1);\r\n    new Thread(\"thread1\") {\r\n        @Override\r\n        public void run() {\r\n            Looper.prepare();\r\n            final Realm realm = Realm.getInstance(realmConfig);\r\n            RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {\r\n                @Override\r\n                public void onChange(Realm object) {\r\n                    realm.close();\r\n                    handlerNotified.countDown();\r\n                }\r\n            };\r\n            realm.addChangeListener(listener);\r\n            backgroundThread1Started.countDown();\r\n            Looper.loop();\r\n        }\r\n    }.start();\r\n    new Thread(\"thread2\") {\r\n        @Override\r\n        public void run() {\r\n            Looper.prepare();\r\n            Realm realm = Realm.getInstance(realmConfig);\r\n            RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {\r\n                @Override\r\n                public void onChange(Realm object) {\r\n                    fail(\"This handler should not be notified\");\r\n                }\r\n            };\r\n            realm.addChangeListener(listener);\r\n            realm.close();\r\n            backgroundThread2Closed.countDown();\r\n            Looper.loop();\r\n        }\r\n    }.start();\r\n    TestHelper.awaitOrFail(backgroundThread1Started);\r\n    TestHelper.awaitOrFail(backgroundThread2Closed);\r\n    Realm realm = Realm.getInstance(realmConfig);\r\n    realm.beginTransaction();\r\n    realm.commitTransaction();\r\n    try {\r\n        if (!handlerNotified.await(TestHelper.SHORT_WAIT_SECS, TimeUnit.SECONDS)) {\r\n            fail(\"Handler didn't receive message\");\r\n        }\r\n    } finally {\r\n        realm.close();\r\n    }\r\n}"
}, {
	"Path": "io.realm.NotificationsTest.doNotUseClosedHandler",
	"Comment": "prevents committransaction from accidentally posting messages to handlers which might reference a closed realm.",
	"Method": "void doNotUseClosedHandler(){\r\n    Looper.prepare();\r\n    final Realm realm = Realm.getInstance(realmConfig);\r\n    RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {\r\n        @Override\r\n        public void onChange(Realm object) {\r\n            realm.close();\r\n            handlerNotified.countDown();\r\n        }\r\n    };\r\n    realm.addChangeListener(listener);\r\n    backgroundThread1Started.countDown();\r\n    Looper.loop();\r\n}"
}, {
	"Path": "io.realm.NotificationsTest.doNotUseClosedHandler",
	"Comment": "prevents committransaction from accidentally posting messages to handlers which might reference a closed realm.",
	"Method": "void doNotUseClosedHandler(){\r\n    realm.close();\r\n    handlerNotified.countDown();\r\n}"
}, {
	"Path": "io.realm.NotificationsTest.doNotUseClosedHandler",
	"Comment": "prevents committransaction from accidentally posting messages to handlers which might reference a closed realm.",
	"Method": "void doNotUseClosedHandler(){\r\n    Looper.prepare();\r\n    Realm realm = Realm.getInstance(realmConfig);\r\n    RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {\r\n        @Override\r\n        public void onChange(Realm object) {\r\n            fail(\"This handler should not be notified\");\r\n        }\r\n    };\r\n    realm.addChangeListener(listener);\r\n    realm.close();\r\n    backgroundThread2Closed.countDown();\r\n    Looper.loop();\r\n}"
}, {
	"Path": "io.realm.NotificationsTest.doNotUseClosedHandler",
	"Comment": "prevents committransaction from accidentally posting messages to handlers which might reference a closed realm.",
	"Method": "void doNotUseClosedHandler(){\r\n    fail(\"This handler should not be notified\");\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanDropColumn",
	"Comment": "check if identity is allowed to drop columns from the specified table in a catalog.",
	"Method": "void checkCanDropColumn(Identity identity,CatalogSchemaTableName table){\r\n    denyDropColumn(table.toString());\r\n}"
}, {
	"Path": "io.realm.RealmCache.createRealmOrGetFromCache",
	"Comment": "creates a new realm instance or get an existing instance for current thread.",
	"Method": "E createRealmOrGetFromCache(RealmConfiguration configuration,Class<E> realmClass){\r\n    RealmCache cache = getCache(configuration.getPath(), true);\r\n    return cache.doCreateRealmOrGetFromCache(configuration, realmClass);\r\n}"
}, {
	"Path": "io.realm.ManagedRealmCollectionTests.where_lessThanGreaterThan",
	"Comment": "tests to see if a particular item that does exist in the same realm does notexist in the result set of another query.",
	"Method": "void where_lessThanGreaterThan(){\r\n    RealmResults<AllJavaTypes> items = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, 1000).findAll();\r\n    AllJavaTypes anotherType = realm.where(AllJavaTypes.class).greaterThan(AllJavaTypes.FIELD_LONG, 1000).findFirst();\r\n    assertFalse(\"Should not be able to find item in another result list.\", items.contains(anotherType));\r\n}"
}, {
	"Path": "org.redisson.config.Config.setReferenceCodecProvider",
	"Comment": "reference objects codec provider used for codec registry and look up. org.redisson.codec.defaultreferencecodecprovider used by default.",
	"Method": "Config setReferenceCodecProvider(ReferenceCodecProvider codecProvider){\r\n    this.referenceCodecProvider = codecProvider;\r\n    return this;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorMetadata.listViews",
	"Comment": "list view names, possibly filtered by schema. an empty list is returned if none match.",
	"Method": "List<SchemaTableName> listViews(ConnectorSession session,String schemaNameOrNull,List<SchemaTableName> listViews,ConnectorSession session,Optional<String> schemaName){\r\n    return listViews(session, schemaName.orElse(null));\r\n}"
}, {
	"Path": "io.realm.RealmCacheTests.getInstance_shouldNotBeBlockedByTransactionInAnotherThread",
	"Comment": "other thread should not be blocked since we have cached the schemas already.",
	"Method": "void getInstance_shouldNotBeBlockedByTransactionInAnotherThread(){\r\n    Realm realm = Realm.getInstance(defaultConfig);\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    realm.beginTransaction();\r\n    Thread thread = new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            Realm realm = Realm.getInstance(defaultConfig);\r\n            realm.close();\r\n            latch.countDown();\r\n        }\r\n    });\r\n    thread.start();\r\n    TestHelper.awaitOrFail(latch);\r\n    realm.cancelTransaction();\r\n    realm.close();\r\n}"
}, {
	"Path": "io.realm.RealmCacheTests.getInstance_shouldNotBeBlockedByTransactionInAnotherThread",
	"Comment": "other thread should not be blocked since we have cached the schemas already.",
	"Method": "void getInstance_shouldNotBeBlockedByTransactionInAnotherThread(){\r\n    Realm realm = Realm.getInstance(defaultConfig);\r\n    realm.close();\r\n    latch.countDown();\r\n}"
}, {
	"Path": "com.facebook.presto.orc.stream.TestingBitPackingUtils.unpackGeneric",
	"Comment": "old implementation of bit unpacking code from hive orc reader",
	"Method": "void unpackGeneric(long[] buffer,int offset,int len,int bitSize,InputStream input){\r\n    int bitsLeft = 0;\r\n    int current = 0;\r\n    for (int i = offset; i < (offset + len); i++) {\r\n        long result = 0;\r\n        int bitsLeftToRead = bitSize;\r\n        while (bitsLeftToRead > bitsLeft) {\r\n            result <<= bitsLeft;\r\n            result |= current & ((1 << bitsLeft) - 1);\r\n            bitsLeftToRead -= bitsLeft;\r\n            current = input.read();\r\n            bitsLeft = 8;\r\n        }\r\n        if (bitsLeftToRead > 0) {\r\n            result <<= bitsLeftToRead;\r\n            bitsLeft -= bitsLeftToRead;\r\n            result |= (current >> bitsLeft) & ((1 << bitsLeftToRead) - 1);\r\n        }\r\n        buffer[i] = result;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spi.predicate.TupleDomain.intersect",
	"Comment": "returns the strict intersection of the tupledomains.the resulting tupledomain represents the set of tuples that would be validin both tupledomains.",
	"Method": "TupleDomain<T> intersect(TupleDomain<T> other){\r\n    if (this.isNone() || other.isNone()) {\r\n        return none();\r\n    }\r\n    Map<T, Domain> intersected = new HashMap(this.getDomains().get());\r\n    for (Map.Entry<T, Domain> entry : other.getDomains().get().entrySet()) {\r\n        Domain intersectionDomain = intersected.get(entry.getKey());\r\n        if (intersectionDomain == null) {\r\n            intersected.put(entry.getKey(), entry.getValue());\r\n        } else {\r\n            intersected.put(entry.getKey(), intersectionDomain.intersect(entry.getValue()));\r\n        }\r\n    }\r\n    return withColumnDomains(intersected);\r\n}"
}, {
	"Path": "io.realm.internal.fields.FieldDescriptor.setCompilationResults",
	"Comment": "store the results of compiling the field description.subclasses call this as the last action in",
	"Method": "void setCompilationResults(String finalClassName,String finalColumnName,RealmFieldType finalColumnType,long[] columnIndices,long[] nativeTablePointers){\r\n    if ((validFinalColumnTypes != null) && (validFinalColumnTypes.size() > 0)) {\r\n        verifyColumnType(finalClassName, finalColumnName, finalColumnType, validFinalColumnTypes);\r\n    }\r\n    this.finalColumnName = finalColumnName;\r\n    this.finalColumnType = finalColumnType;\r\n    this.columnIndices = columnIndices;\r\n    this.nativeTablePointers = nativeTablePointers;\r\n}"
}, {
	"Path": "com.facebook.presto.orc.stream.LongDecode.getClosestFixedBits",
	"Comment": "gets the closest supported fixed bit width for the specified bit width.",
	"Method": "int getClosestFixedBits(int width){\r\n    if (width == 0) {\r\n        return 1;\r\n    }\r\n    if (width >= 1 && width <= 24) {\r\n        return width;\r\n    } else if (width > 24 && width <= 26) {\r\n        return 26;\r\n    } else if (width > 26 && width <= 28) {\r\n        return 28;\r\n    } else if (width > 28 && width <= 30) {\r\n        return 30;\r\n    } else if (width > 30 && width <= 32) {\r\n        return 32;\r\n    } else if (width > 32 && width <= 40) {\r\n        return 40;\r\n    } else if (width > 40 && width <= 48) {\r\n        return 48;\r\n    } else if (width > 48 && width <= 56) {\r\n        return 56;\r\n    } else {\r\n        return 64;\r\n    }\r\n}"
}, {
	"Path": "io.realm.CustomRealmNameTests.modulePolicy_defaultPolicy",
	"Comment": "check that the module policy is used as the default for class and field names",
	"Method": "void modulePolicy_defaultPolicy(){\r\n    assertTrue(realm.getSchema().contains(\"default_policy_from_module\"));\r\n    RealmObjectSchema classSchema = realm.getSchema().get(\"default_policy_from_module\");\r\n    assertTrue(classSchema.hasField(\"camel_case\"));\r\n}"
}, {
	"Path": "io.realm.objectserver.EncryptedSynchronizedRealmTests.setEncryptionKey_differentClientsWithDifferentKeys",
	"Comment": "if client b encrypts its synced realm, client a should be able to access that realm with a different encryption key.",
	"Method": "void setEncryptionKey_differentClientsWithDifferentKeys(){\r\n    String username = UUID.randomUUID().toString();\r\n    String password = \"password\";\r\n    SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);\r\n    final byte[] randomKey = TestHelper.getRandomKey();\r\n    SyncConfiguration configWithEncryption = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM).fullSynchronization().modules(new StringOnlyModule()).waitForInitialRemoteData().errorHandler(new SyncSession.ErrorHandler() {\r\n        @Override\r\n        public void onError(SyncSession session, ObjectServerError error) {\r\n            fail(error.getErrorMessage());\r\n        }\r\n    }).encryptionKey(randomKey).build();\r\n    Realm realm = Realm.getInstance(configWithEncryption);\r\n    assertTrue(realm.isEmpty());\r\n    realm.beginTransaction();\r\n    realm.createObject(StringOnly.class).setChars(\"Hi Alice\");\r\n    realm.commitTransaction();\r\n    SyncManager.getSession(configWithEncryption).uploadAllLocalChanges();\r\n    realm.close();\r\n    SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);\r\n    SyncCredentials credentials = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), \"custom-admin-user\");\r\n    SyncUser adminUser = SyncUser.logIn(credentials, Constants.AUTH_URL);\r\n    final byte[] adminRandomKey = TestHelper.getRandomKey();\r\n    SyncConfiguration adminConfigWithEncryption = configurationFactory.createSyncConfigurationBuilder(adminUser, configWithEncryption.getServerUrl().toString()).fullSynchronization().modules(new StringOnlyModule()).waitForInitialRemoteData().errorHandler(new SyncSession.ErrorHandler() {\r\n        @Override\r\n        public void onError(SyncSession session, ObjectServerError error) {\r\n            fail(error.getErrorMessage());\r\n        }\r\n    }).encryptionKey(adminRandomKey).build();\r\n    Realm adminRealm = Realm.getInstance(adminConfigWithEncryption);\r\n    RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).findAll();\r\n    assertEquals(1, all.size());\r\n    assertEquals(\"Hi Alice\", all.get(0).getChars());\r\n    adminRealm.beginTransaction();\r\n    adminRealm.createObject(StringOnly.class).setChars(\"Hi Bob\");\r\n    adminRealm.commitTransaction();\r\n    SyncManager.getSession(adminConfigWithEncryption).uploadAllLocalChanges();\r\n    adminRealm.close();\r\n    realm = Realm.getInstance(configWithEncryption);\r\n    SyncManager.getSession(configWithEncryption).downloadAllServerChanges();\r\n    realm.refresh();\r\n    assertEquals(2, realm.where(StringOnly.class).count());\r\n    adminRealm = Realm.getInstance(adminConfigWithEncryption);\r\n    RealmResults<StringOnly> allSorted = realm.where(StringOnly.class).sort(StringOnly.FIELD_CHARS).findAll();\r\n    RealmResults<StringOnly> allSortedAdmin = adminRealm.where(StringOnly.class).sort(StringOnly.FIELD_CHARS).findAll();\r\n    assertEquals(\"Hi Alice\", allSorted.get(0).getChars());\r\n    assertEquals(\"Hi Bob\", allSorted.get(1).getChars());\r\n    assertEquals(\"Hi Alice\", allSortedAdmin.get(0).getChars());\r\n    assertEquals(\"Hi Bob\", allSortedAdmin.get(1).getChars());\r\n    adminRealm.close();\r\n    adminUser.logOut();\r\n    realm.close();\r\n    user.logOut();\r\n}"
}, {
	"Path": "io.realm.objectserver.EncryptedSynchronizedRealmTests.setEncryptionKey_differentClientsWithDifferentKeys",
	"Comment": "if client b encrypts its synced realm, client a should be able to access that realm with a different encryption key.",
	"Method": "void setEncryptionKey_differentClientsWithDifferentKeys(){\r\n    fail(error.getErrorMessage());\r\n}"
}, {
	"Path": "io.realm.objectserver.EncryptedSynchronizedRealmTests.setEncryptionKey_differentClientsWithDifferentKeys",
	"Comment": "if client b encrypts its synced realm, client a should be able to access that realm with a different encryption key.",
	"Method": "void setEncryptionKey_differentClientsWithDifferentKeys(){\r\n    fail(error.getErrorMessage());\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.getStartValue",
	"Comment": "get the displacement value from the last time setcurrentvalue was called.",
	"Method": "double getStartValue(){\r\n    return mStartValue;\r\n}"
}, {
	"Path": "io.realm.MutableRealmIntegerTests.compareTo_managed",
	"Comment": "be absolutely certain that we can actually compare two longs.",
	"Method": "void compareTo_managed(){\r\n    realm.beginTransaction();\r\n    MutableRealmInteger ri1 = realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger();\r\n    ri1.set(0);\r\n    MutableRealmInteger ri2 = realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger();\r\n    ri2.set(Long.MAX_VALUE);\r\n    realm.commitTransaction();\r\n    assertEquals(-1, ri1.compareTo(ri2));\r\n    realm.beginTransaction();\r\n    ri2.decrement(Long.MAX_VALUE);\r\n    realm.commitTransaction();\r\n    assertEquals(0, ri1.compareTo(ri2));\r\n    realm.beginTransaction();\r\n    ri2.decrement(Long.MAX_VALUE);\r\n    realm.commitTransaction();\r\n    assertEquals(1, ri1.compareTo(ri2));\r\n}"
}, {
	"Path": "io.realm.PermissionManagerTests.assertInitialPermissions",
	"Comment": "the initial set of permissions of ros is timing dependant. this method will identify the possible known startingstates and fail if neither of these can be verified.",
	"Method": "void assertInitialPermissions(RealmResults<Permission> permissions){\r\n    assertEquals(\"Unexpected count() for __permission Realm: \" + Arrays.toString(permissions.toArray()), 1, permissions.where().endsWith(\"path\", \"__permission\").count());\r\n    assertEquals(\"Unexpected count() for __management Realm: \" + Arrays.toString(permissions.toArray()), 1, permissions.where().endsWith(\"path\", \"__management\").count());\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanSelectFromColumns",
	"Comment": "check if identity is allowed to select from the specified columns in a relation.the column set can be empty.",
	"Method": "void checkCanSelectFromColumns(ConnectorTransactionHandle transactionHandle,Identity identity,SchemaTableName tableName,Set<String> columnNames){\r\n    denySelectColumns(tableName.toString(), columnNames);\r\n}"
}, {
	"Path": "com.facebook.rebound.SpringConfig.fromOrigamiTensionAndFriction",
	"Comment": "a helper to make creating a springconfig easier with values mapping to the origami values.",
	"Method": "SpringConfig fromOrigamiTensionAndFriction(double qcTension,double qcFriction){\r\n    return new SpringConfig(OrigamiValueConverter.tensionFromOrigamiValue(qcTension), OrigamiValueConverter.frictionFromOrigamiValue(qcFriction));\r\n}"
}, {
	"Path": "com.facebook.presto.operator.index.PageBuffer.add",
	"Comment": "adds a page to the buffer.returns a listenablefuture that is marked as done when the next page can be added.",
	"Method": "ListenableFuture<?> add(Page page){\r\n    checkState(!isFull(), \"PageBuffer is full!\");\r\n    pages.offer(page);\r\n    if (isFull()) {\r\n        if (settableFuture == null) {\r\n            settableFuture = SettableFuture.create();\r\n        }\r\n        return settableFuture;\r\n    }\r\n    return NOT_FULL;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanCreateViewWithSelectFromColumns",
	"Comment": "check if identity is allowed to create a view that selects from the specified columns in a relation.",
	"Method": "void checkCanCreateViewWithSelectFromColumns(Identity identity,CatalogSchemaTableName table,Set<String> columns){\r\n    denyCreateViewWithSelect(table.toString(), identity);\r\n}"
}, {
	"Path": "io.realm.DynamicRealmObject.getFieldType",
	"Comment": "returns the type used by the underlying storage engine to represent this field.",
	"Method": "RealmFieldType getFieldType(String fieldName){\r\n    proxyState.getRealm$realm().checkIfValid();\r\n    long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);\r\n    return proxyState.getRow$realm().getColumnType(columnIndex);\r\n}"
}, {
	"Path": "com.facebook.presto.operator.Driver.initialize",
	"Comment": "another thread, which will cause unsafe publication of this instance.",
	"Method": "void initialize(){\r\n    activeOperators.stream().map(Operator::getOperatorContext).forEach(operatorContext -> operatorContext.setMemoryRevocationRequestListener(() -> driverBlockedFuture.get().set(null)));\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.setAtRest",
	"Comment": "set the spring to be at rest by making its end value equal to its current value and settingvelocity to 0.",
	"Method": "Spring setAtRest(){\r\n    mEndValue = mCurrentState.position;\r\n    mTempState.position = mCurrentState.position;\r\n    mCurrentState.velocity = 0;\r\n    return this;\r\n}"
}, {
	"Path": "io.realm.RealmObjectTests.deleteFromRealm_removedFromResults",
	"Comment": "queries for an object, removes it and sees it has been removed from realm.",
	"Method": "void deleteFromRealm_removedFromResults(){\r\n    realm.beginTransaction();\r\n    realm.delete(Dog.class);\r\n    Dog dogToAdd = realm.createObject(Dog.class);\r\n    dogToAdd.setName(\"Rex\");\r\n    realm.commitTransaction();\r\n    assertEquals(1, realm.where(Dog.class).count());\r\n    Dog dogToRemove = realm.where(Dog.class).findFirst();\r\n    assertNotNull(dogToRemove);\r\n    realm.beginTransaction();\r\n    dogToRemove.deleteFromRealm();\r\n    realm.commitTransaction();\r\n    assertEquals(0, realm.where(Dog.class).count());\r\n    try {\r\n        dogToAdd.getName();\r\n        realm.close();\r\n        fail();\r\n    } catch (IllegalStateException ignored) {\r\n    }\r\n    try {\r\n        dogToRemove.getName();\r\n        realm.close();\r\n        fail();\r\n    } catch (IllegalStateException ignored) {\r\n    }\r\n    realm.close();\r\n}"
}, {
	"Path": "io.realm.CustomRealmNameTests.fieldName_overrideModulePolicy",
	"Comment": "check that a explicitly setting a field name overrides a module field name policy",
	"Method": "void fieldName_overrideModulePolicy(){\r\n    RealmObjectSchema classSchema = realm.getSchema().get(FieldNameOverrideClassPolicy.CLASS_NAME);\r\n    assertTrue(classSchema.hasField(FieldNameOverrideClassPolicy.FIELD_CAMEL_CASE));\r\n}"
}, {
	"Path": "io.realm.internal.android.ISO8601Utils.parseInt",
	"Comment": "parses an integer located between 2 given offsets in a string",
	"Method": "int parseInt(String value,int beginIndex,int endIndex){\r\n    if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\r\n        throw new NumberFormatException(value);\r\n    }\r\n    int i = beginIndex;\r\n    int result = 0;\r\n    int digit;\r\n    if (i < endIndex) {\r\n        digit = Character.digit(value.charAt(i++), 10);\r\n        if (digit < 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\r\n        }\r\n        result = -digit;\r\n    }\r\n    while (i < endIndex) {\r\n        digit = Character.digit(value.charAt(i++), 10);\r\n        if (digit < 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\r\n        }\r\n        result *= 10;\r\n        result -= digit;\r\n    }\r\n    return -result;\r\n}"
}, {
	"Path": "com.facebook.presto.orc.stream.LongDecode.decodeBitWidth",
	"Comment": "decodes the ordinal fixed bit value to actual fixed bit width value.",
	"Method": "int decodeBitWidth(int n){\r\n    if (n >= ONE.ordinal() && n <= TWENTY_FOUR.ordinal()) {\r\n        return n + 1;\r\n    } else if (n == TWENTY_SIX.ordinal()) {\r\n        return 26;\r\n    } else if (n == TWENTY_EIGHT.ordinal()) {\r\n        return 28;\r\n    } else if (n == THIRTY.ordinal()) {\r\n        return 30;\r\n    } else if (n == THIRTY_TWO.ordinal()) {\r\n        return 32;\r\n    } else if (n == FORTY.ordinal()) {\r\n        return 40;\r\n    } else if (n == FORTY_EIGHT.ordinal()) {\r\n        return 48;\r\n    } else if (n == FIFTY_SIX.ordinal()) {\r\n        return 56;\r\n    } else {\r\n        return 64;\r\n    }\r\n}"
}, {
	"Path": "io.realm.CustomRealmNameTests.className_overrideModuleClassPolicy",
	"Comment": "check that explicit class name override both module and class policies",
	"Method": "void className_overrideModuleClassPolicy(){\r\n    assertTrue(realm.getSchema().contains(ClassNameOverrideModulePolicy.CLASS_NAME));\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanCreateView",
	"Comment": "check if identity is allowed to create the specified view in this catalog.",
	"Method": "void checkCanCreateView(ConnectorTransactionHandle transactionHandle,Identity identity,SchemaTableName viewName){\r\n    denyCreateView(viewName.toString());\r\n}"
}, {
	"Path": "org.redisson.api.CronSchedule.weeklyOnDayAndHourAndMinute",
	"Comment": "creates cron expression which schedule task executionevery given days of the week at the given time.use calendar object constants to define day.",
	"Method": "CronSchedule weeklyOnDayAndHourAndMinute(int hour,int minute,Integer daysOfWeek){\r\n    if (daysOfWeek == null || daysOfWeek.length == 0) {\r\n        throw new IllegalArgumentException(\"You must specify at least one day of week.\");\r\n    }\r\n    String expression = String.format(\"0 %d %d ? * %d\", minute, hour, daysOfWeek[0]);\r\n    for (int i = 1; i < daysOfWeek.length; i++) {\r\n        expression = expression + \",\" + daysOfWeek[i];\r\n    }\r\n    return of(expression);\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.renamePrimaryKeyFieldInMigration",
	"Comment": "renaming the class should also rename the the class entry in the pk metadata table that tracks primary keys.",
	"Method": "void renamePrimaryKeyFieldInMigration(){\r\n    buildInitialMigrationSchema(MigrationFieldRenamed.CLASS_NAME, false);\r\n    RealmMigration migration = new RealmMigration() {\r\n        @Override\r\n        public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {\r\n            realm.getSchema().get(MigrationFieldRenamed.CLASS_NAME).renameField(MigrationPrimaryKey.FIELD_PRIMARY, MigrationFieldRenamed.FIELD_PRIMARY);\r\n        }\r\n    };\r\n    RealmConfiguration realmConfig = configFactory.createConfigurationBuilder().schemaVersion(1).schema(MigrationFieldRenamed.class).migration(migration).build();\r\n    Realm realm = Realm.getInstance(realmConfig);\r\n    Table table = realm.getSchema().getTable(MigrationFieldRenamed.class);\r\n    assertEquals(MigrationFieldRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());\r\n    assertPKField(realm, MigrationFieldRenamed.CLASS_NAME, MigrationFieldRenamed.FIELD_PRIMARY, MigrationFieldRenamed.DEFAULT_PRIMARY_INDEX);\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.renamePrimaryKeyFieldInMigration",
	"Comment": "renaming the class should also rename the the class entry in the pk metadata table that tracks primary keys.",
	"Method": "void renamePrimaryKeyFieldInMigration(){\r\n    realm.getSchema().get(MigrationFieldRenamed.CLASS_NAME).renameField(MigrationPrimaryKey.FIELD_PRIMARY, MigrationFieldRenamed.FIELD_PRIMARY);\r\n}"
}, {
	"Path": "io.realm.processor.Utils.getSimpleColumnInfoClassName",
	"Comment": "returns a simple reference to the columninfo class inside this model class, i.e. the packagename is not prefixed.",
	"Method": "String getSimpleColumnInfoClassName(String qualifiedModelClassName){\r\n    String simpleModelClassName = Utils.stripPackage(qualifiedModelClassName);\r\n    return Utils.getProxyClassName(qualifiedModelClassName) + \".\" + simpleModelClassName + \"ColumnInfo\";\r\n}"
}, {
	"Path": "org.redisson.api.BatchResult.getSyncedSlaves",
	"Comment": "returns synchronized slaves amount involved during batch execution",
	"Method": "int getSyncedSlaves(){\r\n    return syncedSlaves;\r\n}"
}, {
	"Path": "io.realm.RealmTests.copyToRealmOrUpdate_defaultValuesOverrideExistingData",
	"Comment": "checks that an unmanaged object with only default values can override data.",
	"Method": "void copyToRealmOrUpdate_defaultValuesOverrideExistingData(){\r\n    realm.executeTransaction(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            AllTypesPrimaryKey obj = new AllTypesPrimaryKey();\r\n            obj.setColumnString(\"Foo\");\r\n            obj.setColumnLong(1);\r\n            obj.setColumnFloat(1.23F);\r\n            obj.setColumnDouble(1.234D);\r\n            obj.setColumnBoolean(false);\r\n            obj.setColumnBinary(new byte[] { 1, 2, 3 });\r\n            obj.setColumnDate(new Date(1000));\r\n            obj.setColumnRealmObject(new DogPrimaryKey(1, \"Dog1\"));\r\n            obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, \"Dog2\")));\r\n            realm.copyToRealm(obj);\r\n            AllTypesPrimaryKey obj2 = new AllTypesPrimaryKey();\r\n            obj2.setColumnLong(1);\r\n            realm.copyToRealmOrUpdate(obj2);\r\n        }\r\n    });\r\n    assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());\r\n    AllTypesPrimaryKey obj = realm.where(AllTypesPrimaryKey.class).findFirst();\r\n    assertNull(obj.getColumnString());\r\n    assertEquals(1, obj.getColumnLong());\r\n    assertEquals(0.0F, obj.getColumnFloat(), 0);\r\n    assertEquals(0.0D, obj.getColumnDouble(), 0);\r\n    assertEquals(false, obj.isColumnBoolean());\r\n    assertNull(obj.getColumnBinary());\r\n    assertNull(obj.getColumnDate());\r\n    assertNull(obj.getColumnRealmObject());\r\n    assertEquals(0, obj.getColumnRealmList().size());\r\n}"
}, {
	"Path": "io.realm.RealmTests.copyToRealmOrUpdate_defaultValuesOverrideExistingData",
	"Comment": "checks that an unmanaged object with only default values can override data.",
	"Method": "void copyToRealmOrUpdate_defaultValuesOverrideExistingData(){\r\n    AllTypesPrimaryKey obj = new AllTypesPrimaryKey();\r\n    obj.setColumnString(\"Foo\");\r\n    obj.setColumnLong(1);\r\n    obj.setColumnFloat(1.23F);\r\n    obj.setColumnDouble(1.234D);\r\n    obj.setColumnBoolean(false);\r\n    obj.setColumnBinary(new byte[] { 1, 2, 3 });\r\n    obj.setColumnDate(new Date(1000));\r\n    obj.setColumnRealmObject(new DogPrimaryKey(1, \"Dog1\"));\r\n    obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, \"Dog2\")));\r\n    realm.copyToRealm(obj);\r\n    AllTypesPrimaryKey obj2 = new AllTypesPrimaryKey();\r\n    obj2.setColumnLong(1);\r\n    realm.copyToRealmOrUpdate(obj2);\r\n}"
}, {
	"Path": "io.realm.SyncedRealmMigrationTests.differentSchemaVersions_rebuildIndexes",
	"Comment": "check that indexes are being added if the schema version is different",
	"Method": "void differentSchemaVersions_rebuildIndexes(){\r\n    SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), \"http://foo.com/auth\").schema(IndexedFields.class).schemaVersion(42).build();\r\n    String className = IndexedFields.class.getSimpleName();\r\n    DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);\r\n    RealmSchema schema = dynamicRealm.getSchema();\r\n    dynamicRealm.beginTransaction();\r\n    // No index\r\n    schema.create(className).addField(IndexedFields.FIELD_INDEXED_STRING, String.class).addField(IndexedFields.FIELD_NON_INDEXED_STRING, String.class);\r\n    dynamicRealm.setVersion(43);\r\n    dynamicRealm.commitTransaction();\r\n    dynamicRealm.close();\r\n    Realm realm = Realm.getInstance(config);\r\n    try {\r\n        RealmObjectSchema indexedFieldsSchema = realm.getSchema().get(className);\r\n        assertNotNull(indexedFieldsSchema);\r\n        assertTrue(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_INDEXED_STRING));\r\n        assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_NON_INDEXED_STRING));\r\n    } finally {\r\n        realm.close();\r\n    }\r\n}"
}, {
	"Path": "io.realm.processor.ClassMetaData.categorizeClassElements",
	"Comment": "returns true if all elements could be categorized and false otherwise.",
	"Method": "boolean categorizeClassElements(){\r\n    for (Element element : classType.getEnclosedElements()) {\r\n        ElementKind elementKind = element.getKind();\r\n        switch(elementKind) {\r\n            case CONSTRUCTOR:\r\n                if (Utils.isDefaultConstructor(element)) {\r\n                    hasDefaultConstructor = true;\r\n                }\r\n                break;\r\n            case FIELD:\r\n                if (!categorizeField(element)) {\r\n                    return false;\r\n                }\r\n                break;\r\n            default:\r\n        }\r\n    }\r\n    if (fields.size() == 0) {\r\n        Utils.error(String.format(Locale.US, \"Class \\\"%s\\\" must contain at least 1 persistable field.\", javaClassName));\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.realm.ObjectChangeSetTests.moreFieldsChangedThanLocalRefTableSize",
	"Comment": "when there are more than 512 fields change, the jni local ref table size limitation may be reached.",
	"Method": "void moreFieldsChangedThanLocalRefTableSize(){\r\n    final String CLASS_NAME = \"ManyFields\";\r\n    final int FIELD_COUNT = 1024;\r\n    RealmConfiguration config = looperThread.createConfiguration(\"many_fields\");\r\n    final DynamicRealm realm = DynamicRealm.getInstance(config);\r\n    realm.beginTransaction();\r\n    RealmSchema schema = realm.getSchema();\r\n    RealmObjectSchema objectSchema = schema.create(CLASS_NAME);\r\n    for (int i = 0; i < FIELD_COUNT; i++) {\r\n        objectSchema.addField(\"field\" + i, int.class);\r\n    }\r\n    DynamicRealmObject obj = realm.createObject(CLASS_NAME);\r\n    realm.commitTransaction();\r\n    obj.addChangeListener(new RealmObjectChangeListener<DynamicRealmObject>() {\r\n        @Override\r\n        public void onChange(DynamicRealmObject object, ObjectChangeSet changeSet) {\r\n            assertEquals(FIELD_COUNT, changeSet.getChangedFields().length);\r\n            realm.close();\r\n            looperThread.testComplete();\r\n        }\r\n    });\r\n    realm.beginTransaction();\r\n    for (int i = 0; i < FIELD_COUNT; i++) {\r\n        obj.setInt(\"field\" + i, 42);\r\n    }\r\n    realm.commitTransaction();\r\n}"
}, {
	"Path": "io.realm.ObjectChangeSetTests.moreFieldsChangedThanLocalRefTableSize",
	"Comment": "when there are more than 512 fields change, the jni local ref table size limitation may be reached.",
	"Method": "void moreFieldsChangedThanLocalRefTableSize(){\r\n    assertEquals(FIELD_COUNT, changeSet.getChangedFields().length);\r\n    realm.close();\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "io.realm.internal.ObserverPairListTests.foreach_shouldRemoveWeakRefs",
	"Comment": "test if the observer is gced, the relevant listener should be removed when foreach called.",
	"Method": "void foreach_shouldRemoveWeakRefs(){\r\n    TestObserverPair pair = new TestObserverPair(ONE, new TestListener());\r\n    observerPairs.add(pair);\r\n    assertEquals(1, observerPairs.size());\r\n    observerPairs.foreach(new ObserverPairList.Callback<TestObserverPair>() {\r\n        @Override\r\n        public void onCalled(TestObserverPair pair, Object observer) {\r\n            pair.observerRef.clear();\r\n        }\r\n    });\r\n    assertEquals(1, observerPairs.size());\r\n    observerPairs.foreach(new ObserverPairList.Callback<TestObserverPair>() {\r\n        @Override\r\n        public void onCalled(TestObserverPair pair, Object observer) {\r\n            fail();\r\n        }\r\n    });\r\n    assertEquals(0, observerPairs.size());\r\n}"
}, {
	"Path": "io.realm.internal.ObserverPairListTests.foreach_shouldRemoveWeakRefs",
	"Comment": "test if the observer is gced, the relevant listener should be removed when foreach called.",
	"Method": "void foreach_shouldRemoveWeakRefs(){\r\n    pair.observerRef.clear();\r\n}"
}, {
	"Path": "io.realm.internal.ObserverPairListTests.foreach_shouldRemoveWeakRefs",
	"Comment": "test if the observer is gced, the relevant listener should be removed when foreach called.",
	"Method": "void foreach_shouldRemoveWeakRefs(){\r\n    fail();\r\n}"
}, {
	"Path": "com.facebook.presto.spi.predicate.Marker.isAdjacent",
	"Comment": "adjacency is defined by two markers being infinitesimally close to each other.this means they must share the same value and have adjacent bounds.",
	"Method": "boolean isAdjacent(Marker other){\r\n    checkTypeCompatibility(other);\r\n    if (isUpperUnbounded() || isLowerUnbounded() || other.isUpperUnbounded() || other.isLowerUnbounded()) {\r\n        return false;\r\n    }\r\n    if (type.compareTo(valueBlock.get(), 0, other.valueBlock.get(), 0) != 0) {\r\n        return false;\r\n    }\r\n    return (bound == Bound.EXACTLY && other.bound != Bound.EXACTLY) || (bound != Bound.EXACTLY && other.bound == Bound.EXACTLY);\r\n}"
}, {
	"Path": "com.facebook.presto.tests.datatype.DataType.binaryLiteral",
	"Comment": "formats bytes using sql standard format for binary string literal",
	"Method": "String binaryLiteral(byte[] value){\r\n    return \"X'\" + base16().encode(value) + \"'\";\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorMetadata.listTables",
	"Comment": "list table names, possibly filtered by schema. an empty list is returned if none match.",
	"Method": "List<SchemaTableName> listTables(ConnectorSession session,String schemaNameOrNull,List<SchemaTableName> listTables,ConnectorSession session,Optional<String> schemaName){\r\n    return listTables(session, schemaName.orElse(null));\r\n}"
}, {
	"Path": "com.facebook.presto.tests.hive.TestHiveTableStatistics.testStatisticsForAllDataTypes",
	"Comment": "this covers also stats calculation for unpartitioned table",
	"Method": "void testStatisticsForAllDataTypes(){\r\n    String tableNameInDatabase = mutableTablesState().get(ALL_TYPES_TABLE_NAME).getNameInDatabase();\r\n    onHive().executeQuery(\"ANALYZE TABLE \" + tableNameInDatabase + \" COMPUTE STATISTICS\");\r\n    assertThat(query(\"SHOW STATS FOR \" + tableNameInDatabase)).containsOnly(row(\"c_tinyint\", null, null, null, null, null, null), row(\"c_smallint\", null, null, null, null, null, null), row(\"c_int\", null, null, null, null, null, null), row(\"c_bigint\", null, null, null, null, null, null), row(\"c_float\", null, null, null, null, null, null), row(\"c_double\", null, null, null, null, null, null), row(\"c_decimal\", null, null, null, null, null, null), row(\"c_decimal_w_params\", null, null, null, null, null, null), row(\"c_timestamp\", null, null, null, null, null, null), row(\"c_date\", null, null, null, null, null, null), row(\"c_string\", null, null, null, null, null, null), row(\"c_varchar\", null, null, null, null, null, null), row(\"c_char\", null, null, null, null, null, null), row(\"c_boolean\", null, null, null, null, null, null), row(\"c_binary\", null, null, null, null, null, null), row(null, null, null, null, 2.0, null, null));\r\n    onHive().executeQuery(\"ANALYZE TABLE \" + tableNameInDatabase + \" COMPUTE STATISTICS FOR COLUMNS\");\r\n    // timestamp is shifted by hive.time-zone on read\r\n    assertThat(query(\"SHOW STATS FOR \" + tableNameInDatabase)).containsOnly(// timestamp is shifted by hive.time-zone on read\r\n    row(\"c_tinyint\", null, 2.0, 0.0, null, \"121\", \"127\"), // timestamp is shifted by hive.time-zone on read\r\n    row(\"c_smallint\", null, 2.0, 0.0, null, \"32761\", \"32767\"), // timestamp is shifted by hive.time-zone on read\r\n    row(\"c_int\", null, 2.0, 0.0, null, \"2147483641\", \"2147483647\"), // timestamp is shifted by hive.time-zone on read\r\n    row(\"c_bigint\", null, 2.0, 0.0, null, \"9223372036854775807\", \"9223372036854775807\"), // timestamp is shifted by hive.time-zone on read\r\n    row(\"c_float\", null, 2.0, 0.0, null, \"123.341\", \"123.345\"), // timestamp is shifted by hive.time-zone on read\r\n    row(\"c_double\", null, 2.0, 0.0, null, \"234.561\", \"235.567\"), // timestamp is shifted by hive.time-zone on read\r\n    row(\"c_decimal\", null, 2.0, 0.0, null, \"345.0\", \"346.0\"), row(\"c_decimal_w_params\", null, 2.0, 0.0, null, \"345.671\", \"345.678\"), row(\"c_timestamp\", null, 2.0, 0.0, null, null, null), row(\"c_date\", null, 2.0, 0.0, null, \"2015-05-09\", \"2015-06-10\"), row(\"c_string\", 22.0, 2.0, 0.0, null, null, null), row(\"c_varchar\", 20.0, 2.0, 0.0, null, null, null), row(\"c_char\", 12.0, 2.0, 0.0, null, null, null), row(\"c_boolean\", null, 2.0, 0.0, null, null, null), row(\"c_binary\", 23.0, null, 0.0, null, null, null), row(null, null, null, null, 2.0, null, null));\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanRenameColumn",
	"Comment": "check if identity is allowed to rename a column in the specified table in a catalog.",
	"Method": "void checkCanRenameColumn(Identity identity,CatalogSchemaTableName table){\r\n    denyRenameColumn(table.toString());\r\n}"
}, {
	"Path": "com.facebook.presto.operator.OperatorContext.recordRawInputWithTiming",
	"Comment": "record the amount of physical bytes that were read by an operator andthe time it took to read the data. this metric is valid only for source operators.",
	"Method": "void recordRawInputWithTiming(long sizeInBytes,long readNanos){\r\n    rawInputDataSize.update(sizeInBytes);\r\n    addInputTiming.record(readNanos, 0);\r\n}"
}, {
	"Path": "io.realm.Realm.getPrivileges",
	"Comment": "returns the privileges granted the current user for the given class.",
	"Method": "ClassPrivileges getPrivileges(Class<? extends RealmModel> clazz){\r\n    checkIfValid();\r\n    if (clazz == null) {\r\n        throw new IllegalArgumentException(\"Non-null 'clazz' required.\");\r\n    }\r\n    String className = configuration.getSchemaMediator().getSimpleClassName(clazz);\r\n    return new ClassPrivileges(sharedRealm.getClassPrivileges(className));\r\n}"
}, {
	"Path": "com.facebook.rebound.BaseSpringSystem.registerSpring",
	"Comment": "registers a spring to this basespringsystem so it can be iterated if active.",
	"Method": "void registerSpring(Spring spring){\r\n    if (spring == null) {\r\n        throw new IllegalArgumentException(\"spring is required\");\r\n    }\r\n    if (mSpringRegistry.containsKey(spring.getId())) {\r\n        throw new IllegalArgumentException(\"spring is already registered\");\r\n    }\r\n    mSpringRegistry.put(spring.getId(), spring);\r\n}"
}, {
	"Path": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics.getMinAverageValueSizeInBytes",
	"Comment": "the minimum average value sizes.the actual average value size is no less than the return value.it provides a lower bound of the size of data to be loaded",
	"Method": "long getMinAverageValueSizeInBytes(){\r\n    return minAverageValueSizeInBytes;\r\n}"
}, {
	"Path": "com.facebook.presto.operator.OperatorContext.recordProcessedInput",
	"Comment": "record the size in bytes of input blocks that were processed by an operator.this metric is valid only for source operators.",
	"Method": "void recordProcessedInput(long sizeInBytes,long positions){\r\n    inputDataSize.update(sizeInBytes);\r\n    inputPositions.update(positions);\r\n}"
}, {
	"Path": "io.realm.SyncManager.addAuthenticationListener",
	"Comment": "sets a global authentication listener that will be notified about user events likelogin and logout.",
	"Method": "void addAuthenticationListener(AuthenticationListener listener){\r\n    if (listener == null) {\r\n        throw new IllegalArgumentException(\"Non-null 'listener' required.\");\r\n    }\r\n    authListeners.add(listener);\r\n}"
}, {
	"Path": "io.realm.RealmQuery.in",
	"Comment": "in comparison. this allows you to test if objects match any value in an array of values.",
	"Method": "RealmQuery<E> in(String fieldName,String[] values,RealmQuery<E> in,String fieldName,String[] values,Case casing,RealmQuery<E> in,String fieldName,Byte[] values,RealmQuery<E> in,String fieldName,Short[] values,RealmQuery<E> in,String fieldName,Integer[] values,RealmQuery<E> in,String fieldName,Long[] values,RealmQuery<E> in,String fieldName,Double[] values,RealmQuery<E> in,String fieldName,Float[] values,RealmQuery<E> in,String fieldName,Boolean[] values,RealmQuery<E> in,String fieldName,Date[] values){\r\n    realm.checkIfValid();\r\n    if (values == null || values.length == 0) {\r\n        alwaysFalse();\r\n        return this;\r\n    } else {\r\n        beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);\r\n        for (int i = 1; i < values.length; i++) {\r\n            orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);\r\n        }\r\n        return endGroupWithoutThreadValidation();\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmQuery.beginsWith",
	"Comment": "condition that the value of field begins with the specified substring.",
	"Method": "RealmQuery<E> beginsWith(String fieldName,String value,RealmQuery<E> beginsWith,String fieldName,String value,Case casing){\r\n    realm.checkIfValid();\r\n    FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);\r\n    this.query.beginsWith(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);\r\n    return this;\r\n}"
}, {
	"Path": "io.realm.ManagedRealmCollectionTests.mutableMethodsOutsideTransactions",
	"Comment": "due to implementation details both unsupportedoperation and illegalstate is accepted at this level.",
	"Method": "void mutableMethodsOutsideTransactions(){\r\n    for (CollectionMutatorMethod method : CollectionMutatorMethod.values()) {\r\n        Class<? extends Throwable> expected = IllegalStateException.class;\r\n        if (collectionClass == ManagedCollection.REALMRESULTS || isSnapshot(collectionClass)) {\r\n            switch(method) {\r\n                case ADD_OBJECT:\r\n                case ADD_ALL_OBJECTS:\r\n                case CLEAR:\r\n                case REMOVE_OBJECT:\r\n                case REMOVE_ALL:\r\n                case RETAIN_ALL:\r\n                    expected = UnsupportedOperationException.class;\r\n                    break;\r\n                default:\r\n            }\r\n        }\r\n        try {\r\n            switch(method) {\r\n                case DELETE_ALL:\r\n                    collection.deleteAllFromRealm();\r\n                    break;\r\n                case ADD_OBJECT:\r\n                    collection.add(new AllJavaTypes());\r\n                    break;\r\n                case ADD_ALL_OBJECTS:\r\n                    collection.addAll(Collections.singletonList(new AllJavaTypes()));\r\n                    break;\r\n                case CLEAR:\r\n                    collection.clear();\r\n                    break;\r\n                case REMOVE_OBJECT:\r\n                    collection.remove(new AllJavaTypes());\r\n                    break;\r\n                case REMOVE_ALL:\r\n                    collection.removeAll(Collections.singletonList(new AllJavaTypes()));\r\n                    break;\r\n                case RETAIN_ALL:\r\n                    collection.retainAll(Collections.singletonList(new AllJavaTypes()));\r\n                    break;\r\n            }\r\n            fail(\"Unknown method or it failed to throw: \" + method);\r\n        } catch (IllegalStateException e) {\r\n            assertEquals(expected, e.getClass());\r\n        } catch (UnsupportedOperationException e) {\r\n            assertEquals(expected, e.getClass());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.processor.RealmNameTest.compileModuleWithNamePolicyFile",
	"Comment": "check that things compile if there is only a module with name policies defined",
	"Method": "void compileModuleWithNamePolicyFile(){\r\n    ASSERT.about(javaSource()).that(JavaFileObjects.forResource(\"some/test/NamePolicyModule.java\")).processedWith(new RealmProcessor()).compilesWithoutError();\r\n}"
}, {
	"Path": "io.realm.OrderedRealmCollectionSnapshot.deleteFirstFromRealm",
	"Comment": "deletes the first object from the realm. the first object will become invalid.",
	"Method": "boolean deleteFirstFromRealm(){\r\n    realm.checkIfValidAndInTransaction();\r\n    UncheckedRow row = osResults.firstUncheckedRow();\r\n    return row != null && row.isAttached() && osResults.deleteFirst();\r\n}"
}, {
	"Path": "com.facebook.presto.spi.ConnectorTableLayout.getColumns",
	"Comment": "the columns from the original table provided by this layout. a layout may provide only a subset of columns.",
	"Method": "Optional<List<ColumnHandle>> getColumns(){\r\n    return columns;\r\n}"
}, {
	"Path": "io.realm.CustomRealmNameTests.classFieldPolicy_overrideModuleFieldPolicy",
	"Comment": "check that field name policies on classes override those from modules",
	"Method": "void classFieldPolicy_overrideModuleFieldPolicy(){\r\n    assertTrue(realm.getSchema().contains(ClassWithPolicy.CLASS_NAME));\r\n    RealmObjectSchema classSchema = realm.getSchema().get(ClassWithPolicy.CLASS_NAME);\r\n    for (String field : ClassWithPolicy.ALL_FIELDS) {\r\n        assertTrue(field + \" was not found.\", classSchema.hasField(field));\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spiller.SingleStreamSpiller.spill",
	"Comment": "initiate spilling of single page. returns completed future once spilling has finished.next spill can be initiated as soon as previous one completes.",
	"Method": "ListenableFuture<?> spill(Iterator<Page> page,ListenableFuture<?> spill,Page page){\r\n    return spill(singletonIterator(page));\r\n}"
}, {
	"Path": "io.realm.internal.Table.getColumnName",
	"Comment": "returns the name of a column identified by columnindex. notice that the index is zero based.",
	"Method": "String getColumnName(long columnIndex){\r\n    return nativeGetColumnName(nativePtr, columnIndex);\r\n}"
}, {
	"Path": "io.realm.RealmTests.setter_updateField",
	"Comment": "todo does this test something meaningfull not tested elsewhere?",
	"Method": "void setter_updateField(){\r\n    realm.beginTransaction();\r\n    OwnerPrimaryKey owner = realm.createObject(OwnerPrimaryKey.class, 1);\r\n    owner.setName(\"Jack\");\r\n    Dog rex = realm.createObject(Dog.class);\r\n    rex.setName(\"Rex\");\r\n    Dog fido = realm.createObject(Dog.class);\r\n    fido.setName(\"Fido\");\r\n    owner.getDogs().add(rex);\r\n    owner.getDogs().add(fido);\r\n    assertEquals(2, owner.getDogs().size());\r\n    owner.setName(\"Peter\");\r\n    assertEquals(2, owner.getDogs().size());\r\n    OwnerPrimaryKey owner2 = realm.copyToRealmOrUpdate(owner);\r\n    assertEquals(2, owner.getDogs().size());\r\n    assertEquals(2, owner2.getDogs().size());\r\n    realm.commitTransaction();\r\n}"
}, {
	"Path": "org.redisson.config.BaseConfig.setTimeout",
	"Comment": "redis server response timeout. starts to countdown when redis command has been successfully sent.default is 3000 milliseconds",
	"Method": "T setTimeout(int timeout){\r\n    this.timeout = timeout;\r\n    return (T) this;\r\n}"
}, {
	"Path": "io.realm.Realm.copyToRealm",
	"Comment": "copies a collection of realmobjects to the realm instance and returns their copy. any further changes to theoriginal realmobjects will not be reflected in the realm copies. this is a deep copy i.e., all referenced objectswill be copied. objects already in this realm will be ignored.please note, copying an object will copy all field values. any unset field in the objects and child objects will beset to their default value if not provided.",
	"Method": "E copyToRealm(E object,ImportFlag flags,List<E> copyToRealm,Iterable<E> objects,ImportFlag flags){\r\n    if (objects == null) {\r\n        return new ArrayList();\r\n    }\r\n    ArrayList realmObjects;\r\n    if (objects instanceof Collection) {\r\n        realmObjects = new ArrayList(((Collection) objects).size());\r\n    } else {\r\n        realmObjects = new ArrayList();\r\n    }\r\n    Map<RealmModel, RealmObjectProxy> cache = new HashMap();\r\n    for (E object : objects) {\r\n        checkNotNullObject(object);\r\n        realmObjects.add(copyOrUpdate(object, false, cache, Util.toSet(flags)));\r\n    }\r\n    return realmObjects;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorMetadata.listTablePrivileges",
	"Comment": "list the table privileges granted to the specified grantee for the tables that have the specified prefix",
	"Method": "List<GrantInfo> listTablePrivileges(ConnectorSession session,SchemaTablePrefix prefix){\r\n    return emptyList();\r\n}"
}, {
	"Path": "io.realm.OrderedRealmCollectionTests.methods_indexOutOfBounds",
	"Comment": "checks that all relevant methods throw a correct indexoutofbounds",
	"Method": "void methods_indexOutOfBounds(){\r\n    collection = createEmptyCollection(realm, collectionClass);\r\n    for (ListMethod method : ListMethod.values()) {\r\n        realm.beginTransaction();\r\n        try {\r\n            switch(method) {\r\n                case ADD_INDEX:\r\n                    collection.add(1, new AllJavaTypes());\r\n                    break;\r\n                case ADD_ALL_INDEX:\r\n                    collection.addAll(1, Collections.singleton(new AllJavaTypes()));\r\n                    break;\r\n                case GET_INDEX:\r\n                    collection.get(1);\r\n                    break;\r\n                case LIST_ITERATOR_INDEX:\r\n                    collection.listIterator(1);\r\n                    break;\r\n                case REMOVE_INDEX:\r\n                    collection.remove(1);\r\n                    break;\r\n                case SET:\r\n                    collection.set(1, new AllJavaTypes());\r\n                    break;\r\n                case SUBLIST:\r\n                    collection.subList(1, 2);\r\n                    break;\r\n                case FIRST:\r\n                case LAST:\r\n                case INDEX_OF:\r\n                case LAST_INDEX_OF:\r\n                case LIST_ITERATOR:\r\n                    continue;\r\n            }\r\n            fail(method + \" did not throw an exception\");\r\n        } catch (IndexOutOfBoundsException ignored) {\r\n        } catch (UnsupportedOperationException ignored) {\r\n        } finally {\r\n            realm.cancelTransaction();\r\n        }\r\n    }\r\n    for (OrderedRealmCollectionMethod method : OrderedRealmCollectionMethod.values()) {\r\n        realm.beginTransaction();\r\n        try {\r\n            switch(method) {\r\n                case DELETE_INDEX:\r\n                    collection.deleteFromRealm(1);\r\n                    break;\r\n                case DELETE_FIRST:\r\n                case DELETE_LAST:\r\n                case SORT:\r\n                case SORT_FIELD:\r\n                case SORT_2FIELDS:\r\n                case SORT_MULTI:\r\n                case CREATE_SNAPSHOT:\r\n                    continue;\r\n            }\r\n            fail(method + \" did not throw an exception\");\r\n        } catch (IndexOutOfBoundsException ignored) {\r\n        } catch (UnsupportedOperationException ignored) {\r\n        } finally {\r\n            realm.cancelTransaction();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.rebound.ui.SpringConfiguratorView.generateHierarchy",
	"Comment": "programmatically build up the view hierarchy to avoid the need for resources.",
	"Method": "View generateHierarchy(Context context){\r\n    Resources resources = getResources();\r\n    FrameLayout.LayoutParams params;\r\n    int fivePx = dpToPx(5, resources);\r\n    int tenPx = dpToPx(10, resources);\r\n    int twentyPx = dpToPx(20, resources);\r\n    TableLayout.LayoutParams tableLayoutParams = new TableLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1f);\r\n    tableLayoutParams.setMargins(0, 0, fivePx, 0);\r\n    LinearLayout seekWrapper;\r\n    FrameLayout root = new FrameLayout(context);\r\n    params = createLayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, dpToPx(300, resources));\r\n    root.setLayoutParams(params);\r\n    FrameLayout container = new FrameLayout(context);\r\n    params = createMatchParams();\r\n    params.setMargins(0, twentyPx, 0, 0);\r\n    container.setLayoutParams(params);\r\n    container.setBackgroundColor(Color.argb(100, 0, 0, 0));\r\n    root.addView(container);\r\n    mSpringSelectorSpinner = new Spinner(context, Spinner.MODE_DIALOG);\r\n    params = createMatchWrapParams();\r\n    params.gravity = Gravity.TOP;\r\n    params.setMargins(tenPx, tenPx, tenPx, 0);\r\n    mSpringSelectorSpinner.setLayoutParams(params);\r\n    container.addView(mSpringSelectorSpinner);\r\n    LinearLayout linearLayout = new LinearLayout(context);\r\n    params = createMatchWrapParams();\r\n    params.setMargins(0, 0, 0, dpToPx(80, resources));\r\n    params.gravity = Gravity.BOTTOM;\r\n    linearLayout.setLayoutParams(params);\r\n    linearLayout.setOrientation(LinearLayout.VERTICAL);\r\n    container.addView(linearLayout);\r\n    seekWrapper = new LinearLayout(context);\r\n    params = createMatchWrapParams();\r\n    params.setMargins(tenPx, tenPx, tenPx, twentyPx);\r\n    seekWrapper.setPadding(tenPx, tenPx, tenPx, tenPx);\r\n    seekWrapper.setLayoutParams(params);\r\n    seekWrapper.setOrientation(LinearLayout.HORIZONTAL);\r\n    linearLayout.addView(seekWrapper);\r\n    mTensionSeekBar = new SeekBar(context);\r\n    mTensionSeekBar.setLayoutParams(tableLayoutParams);\r\n    seekWrapper.addView(mTensionSeekBar);\r\n    mTensionLabel = new TextView(getContext());\r\n    mTensionLabel.setTextColor(mTextColor);\r\n    params = createLayoutParams(dpToPx(50, resources), ViewGroup.LayoutParams.MATCH_PARENT);\r\n    mTensionLabel.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);\r\n    mTensionLabel.setLayoutParams(params);\r\n    mTensionLabel.setMaxLines(1);\r\n    seekWrapper.addView(mTensionLabel);\r\n    seekWrapper = new LinearLayout(context);\r\n    params = createMatchWrapParams();\r\n    params.setMargins(tenPx, tenPx, tenPx, twentyPx);\r\n    seekWrapper.setPadding(tenPx, tenPx, tenPx, tenPx);\r\n    seekWrapper.setLayoutParams(params);\r\n    seekWrapper.setOrientation(LinearLayout.HORIZONTAL);\r\n    linearLayout.addView(seekWrapper);\r\n    mFrictionSeekBar = new SeekBar(context);\r\n    mFrictionSeekBar.setLayoutParams(tableLayoutParams);\r\n    seekWrapper.addView(mFrictionSeekBar);\r\n    mFrictionLabel = new TextView(getContext());\r\n    mFrictionLabel.setTextColor(mTextColor);\r\n    params = createLayoutParams(dpToPx(50, resources), ViewGroup.LayoutParams.MATCH_PARENT);\r\n    mFrictionLabel.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);\r\n    mFrictionLabel.setLayoutParams(params);\r\n    mFrictionLabel.setMaxLines(1);\r\n    seekWrapper.addView(mFrictionLabel);\r\n    View nub = new View(context);\r\n    params = createLayoutParams(dpToPx(60, resources), dpToPx(40, resources));\r\n    params.gravity = Gravity.TOP | Gravity.CENTER;\r\n    nub.setLayoutParams(params);\r\n    nub.setOnTouchListener(new OnNubTouchListener());\r\n    nub.setBackgroundColor(Color.argb(255, 0, 164, 209));\r\n    root.addView(nub);\r\n    return root;\r\n}"
}, {
	"Path": "com.facebook.rebound.playground.examples.OrigamiExample.handleClick",
	"Comment": "on click we just move the springs end state from 0 to 1. this allows the spring to act muchlike an origami switch.",
	"Method": "void handleClick(View view){\r\n    if (mSpring.getEndValue() == 0) {\r\n        mSpring.setEndValue(1);\r\n    } else {\r\n        mSpring.setEndValue(0);\r\n    }\r\n}"
}, {
	"Path": "io.realm.SyncUser.logOut",
	"Comment": "this is a fire and forget, end user should not worry about the state of the async query",
	"Method": "void logOut(){\r\n    synchronized (Realm.class) {\r\n        if (!SyncManager.getUserStore().isActive(identity, authenticationUrl.toString())) {\r\n            return;\r\n        }\r\n        SyncManager.getUserStore().remove(identity, authenticationUrl.toString());\r\n        for (SyncConfiguration syncConfiguration : realms.keySet()) {\r\n            try {\r\n                SyncSession session = SyncManager.getSession(syncConfiguration);\r\n                session.clearScheduledAccessTokenRefresh();\r\n            } catch (IllegalStateException e) {\r\n                if (!e.getMessage().contains(\"No SyncSession found\")) {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        realms.clear();\r\n        final AuthenticationServer server = SyncManager.getAuthServer();\r\n        final Token refreshTokenToBeRevoked = refreshToken;\r\n        ThreadPoolExecutor networkPoolExecutor = SyncManager.NETWORK_POOL_EXECUTOR;\r\n        networkPoolExecutor.submit(new ExponentialBackoffTask<LogoutResponse>(3) {\r\n            @Override\r\n            protected LogoutResponse execute() {\r\n                return server.logout(refreshTokenToBeRevoked, getAuthenticationUrl());\r\n            }\r\n            @Override\r\n            protected void onSuccess(LogoutResponse response) {\r\n                SyncManager.notifyUserLoggedOut(SyncUser.this);\r\n            }\r\n            @Override\r\n            protected void onError(LogoutResponse response) {\r\n                RealmLog.error(\"Failed to log user out.\\n\" + response.getError().toString());\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "io.realm.SyncUser.logOut",
	"Comment": "this is a fire and forget, end user should not worry about the state of the async query",
	"Method": "void logOut(){\r\n    return server.logout(refreshTokenToBeRevoked, getAuthenticationUrl());\r\n}"
}, {
	"Path": "io.realm.SyncUser.logOut",
	"Comment": "this is a fire and forget, end user should not worry about the state of the async query",
	"Method": "void logOut(){\r\n    SyncManager.notifyUserLoggedOut(SyncUser.this);\r\n}"
}, {
	"Path": "io.realm.SyncUser.logOut",
	"Comment": "this is a fire and forget, end user should not worry about the state of the async query",
	"Method": "void logOut(){\r\n    RealmLog.error(\"Failed to log user out.\\n\" + response.getError().toString());\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanGrantTablePrivilege",
	"Comment": "check if identity is allowed to grant the specified privilege to the grantee on the specified table.",
	"Method": "void checkCanGrantTablePrivilege(Identity identity,Privilege privilege,CatalogSchemaTableName table,String grantee,boolean withGrantOption){\r\n    denyGrantTablePrivilege(privilege.toString(), table.toString());\r\n}"
}, {
	"Path": "com.facebook.rebound.SpringChain.addSpring",
	"Comment": "add a spring to the chain that will callback to the provided listener.",
	"Method": "SpringChain addSpring(SpringListener listener){\r\n    Spring spring = mSpringSystem.createSpring().addListener(this).setSpringConfig(mAttachmentSpringConfig);\r\n    mSprings.add(spring);\r\n    mListeners.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "io.realm.SessionTests.errorHandler_useClientResetEncrypted",
	"Comment": "make sure the backup file realm is encrypted with the same key as the original synced realm.",
	"Method": "void errorHandler_useClientResetEncrypted(){\r\n    SyncUser user = createTestUser();\r\n    String url = \"realm://objectserver.realm.io/default\";\r\n    final byte[] randomKey = TestHelper.getRandomKey();\r\n    final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url).encryptionKey(randomKey).modules(new StringOnlyModule()).errorHandler((session, error) -> {\r\n        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\r\n            fail(\"Wrong error \" + error.toString());\r\n            return;\r\n        }\r\n        final ClientResetRequiredError handler = (ClientResetRequiredError) error;\r\n        looperThread.closeTestRealms();\r\n        handler.executeClientReset();\r\n        RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();\r\n        Realm backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);\r\n        assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());\r\n        RealmResults<StringOnly> allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();\r\n        assertEquals(\"Foo\", allSorted.get(0).getChars());\r\n        backupEncryptedRealm.close();\r\n        String backupFile = handler.getBackupFile().getAbsolutePath();\r\n        backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, new StringOnlyModule());\r\n        backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);\r\n        assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());\r\n        allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();\r\n        assertEquals(\"Foo\", allSorted.get(0).getChars());\r\n        backupEncryptedRealm.close();\r\n        try {\r\n            Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), new StringOnlyModule()));\r\n            fail(\"Expected to throw when using wrong encryption key\");\r\n        } catch (RealmFileException expected) {\r\n        }\r\n        looperThread.testComplete();\r\n    }).build();\r\n    Realm realm = Realm.getInstance(config);\r\n    realm.beginTransaction();\r\n    realm.createObject(StringOnly.class).setChars(\"Foo\");\r\n    realm.commitTransaction();\r\n    looperThread.addTestRealm(realm);\r\n    SyncManager.simulateClientReset(SyncManager.getOrCreateSession(config, null));\r\n}"
}, {
	"Path": "com.facebook.presto.orc.stream.BooleanInputStream.getUnsetBits",
	"Comment": "sets the vector element to true for the batchsize number of elements starting at offsetif the bit is not set.",
	"Method": "int getUnsetBits(int batchSize,boolean[] vector,int getUnsetBits,int batchSize,boolean[] vector,int offset,int getUnsetBits,int batchSize){\r\n    int count = 0;\r\n    for (int i = 0; i < batchSize; i++) {\r\n        count += nextBit() ? 0 : 1;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "io.realm.internal.network.OkHttpAuthenticationServer.loginUser",
	"Comment": "authenticate the given credentials on the specified realm authentication server.",
	"Method": "AuthenticateResponse loginUser(SyncCredentials credentials,URL authenticationUrl){\r\n    try {\r\n        String requestBody = AuthenticateRequest.userLogin(credentials).toJson();\r\n        return authenticate(authenticationUrl, requestBody);\r\n    } catch (Exception e) {\r\n        return AuthenticateResponse.from(e);\r\n    }\r\n}"
}, {
	"Path": "io.realm.sync.permissions.Role.removeMember",
	"Comment": "removes a member from this role. must be done from within a write transaction.",
	"Method": "boolean removeMember(String userId){\r\n    PermissionUser user = getRealm().where(PermissionUser.class).equalTo(\"id\", userId).findFirst();\r\n    if (user != null) {\r\n        return members.remove(user);\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.orc.TestStructStreamReader.testReaderLowerCasesFieldNamesFromStream",
	"Comment": "the writer has fields with upper case characters, reader has same names downcased.",
	"Method": "void testReaderLowerCasesFieldNamesFromStream(){\r\n    List<String> readerFields = new ArrayList(Arrays.asList(\"field_a\", \"field_b\", \"field_c\"));\r\n    List<String> writerFields = new ArrayList(Arrays.asList(\"field_A\", \"field_B\", \"field_C\"));\r\n    List<String> writerData = new ArrayList(Arrays.asList(\"fieldAValue\", \"fieldBValue\", \"fieldCValue\"));\r\n    Type readerType = getType(readerFields);\r\n    Type writerType = getType(writerFields);\r\n    write(tempFile, writerType, writerData);\r\n    RowBlock readBlock = read(tempFile, readerType);\r\n    List actual = (List) readerType.getObjectValue(SESSION, readBlock, 0);\r\n    assertEquals(actual.size(), readerFields.size());\r\n    assertEquals(actual.get(0), \"fieldAValue\");\r\n    assertEquals(actual.get(1), \"fieldBValue\");\r\n    assertEquals(actual.get(2), \"fieldCValue\");\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.basic_singleBacklinkObject",
	"Comment": "setting the linked object field creates the correct backlink",
	"Method": "void basic_singleBacklinkObject(){\r\n    realm.beginTransaction();\r\n    AllJavaTypes child = realm.createObject(AllJavaTypes.class, 1);\r\n    AllJavaTypes parent = realm.createObject(AllJavaTypes.class, 2);\r\n    parent.setFieldObject(child);\r\n    realm.commitTransaction();\r\n    assertEquals(1, child.getObjectParents().size());\r\n    assertTrue(child.getObjectParents().contains(parent));\r\n}"
}, {
	"Path": "io.realm.internal.network.ExponentialBackoffTask.shouldAbortTask",
	"Comment": "return true if based on the task result that this task will never complete",
	"Method": "boolean shouldAbortTask(T response){\r\n    if (Thread.interrupted()) {\r\n        return true;\r\n    } else if (!response.isValid()) {\r\n        return response.getError().getErrorCode() != ErrorCode.IO_EXCEPTION;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.redisson.api.PendingEntry.getIdleTime",
	"Comment": "returns milliseconds amount have passed since the last time the message was delivered to some consumer",
	"Method": "long getIdleTime(){\r\n    return idleTime;\r\n}"
}, {
	"Path": "com.facebook.rebound.SpringLooper.setSpringSystem",
	"Comment": "set the basespringsystem that the springlooper will call back to.",
	"Method": "void setSpringSystem(BaseSpringSystem springSystem){\r\n    mSpringSystem = springSystem;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.block.BenchmarkComputePosition.computePositionWithMask",
	"Comment": "this reduction function requires the hashtablesize to be power of 2.",
	"Method": "long computePositionWithMask(){\r\n    return (int) hashcode & (hashTableSize - 1);\r\n}"
}, {
	"Path": "io.realm.processor.ClassMetaData.getInternalClassName",
	"Comment": "returns the name that realm core uses when saving data from this java class.",
	"Method": "String getInternalClassName(){\r\n    return internalClassName;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.session.PropertyMetadata.decode",
	"Comment": "decodes the sql type object value to the java type of the property.",
	"Method": "T decode(Object value){\r\n    return decoder.apply(value);\r\n}"
}, {
	"Path": "io.realm.SyncCredentials.usernamePassword",
	"Comment": "creates credentials based on a login with username and password. these credentials will only be verifiedby the object server.the user is not created if she does not exist.",
	"Method": "SyncCredentials usernamePassword(String username,String password,boolean createUser,SyncCredentials usernamePassword,String username,String password){\r\n    return usernamePassword(username, password, false);\r\n}"
}, {
	"Path": "io.realm.internal.async.RealmThreadPoolExecutor.newDefaultExecutor",
	"Comment": "creates a default realmthreadpool that is bounded by the number of available cores.",
	"Method": "RealmThreadPoolExecutor newDefaultExecutor(){\r\n    return new RealmThreadPoolExecutor(CORE_POOL_SIZE, CORE_POOL_SIZE);\r\n}"
}, {
	"Path": "io.realm.internal.OsSharedRealm.addPendingRow",
	"Comment": "add pending row to the list when it is created. it should be called in the pendingrow constructor.",
	"Method": "void addPendingRow(PendingRow pendingRow){\r\n    pendingRows.add(new WeakReference<PendingRow>(pendingRow));\r\n}"
}, {
	"Path": "io.realm.SyncSession.notifySessionError",
	"Comment": "this callback will happen on the thread running the sync client.",
	"Method": "void notifySessionError(int errorCode,String errorMessage){\r\n    if (errorHandler == null) {\r\n        return;\r\n    }\r\n    ErrorCode errCode = ErrorCode.fromInt(errorCode);\r\n    if (errCode == ErrorCode.CLIENT_RESET) {\r\n        RealmConfiguration backupRealmConfiguration = SyncConfiguration.forRecovery(errorMessage, configuration.getEncryptionKey(), configuration.getSchemaMediator());\r\n        errorHandler.onError(this, new ClientResetRequiredError(errCode, \"A Client Reset is required. \" + \"Read more here: https://realm.io/docs/realm-object-server/#client-recovery-from-a-backup.\", configuration, backupRealmConfiguration));\r\n    } else {\r\n        errorHandler.onError(this, new ObjectServerError(errCode, errorMessage));\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.memory.TestMemoryTracking.assertLocalMemoryAllocations",
	"Comment": "the local allocations are reflected only at that level and all the way up to the pools",
	"Method": "void assertLocalMemoryAllocations(MemoryTrackingContext memoryTrackingContext,long expectedPoolMemory,long expectedContextUserMemory,long expectedContextSystemMemory){\r\n    assertEquals(memoryTrackingContext.getUserMemory(), expectedContextUserMemory, \"User memory verification failed\");\r\n    assertEquals(memoryPool.getReservedBytes(), expectedPoolMemory, \"Memory pool verification failed\");\r\n    assertEquals(memoryTrackingContext.localSystemMemoryContext().getBytes(), expectedContextSystemMemory, \"Local system memory verification failed\");\r\n}"
}, {
	"Path": "com.facebook.presto.operator.OperatorContext.updatePeakMemoryReservations",
	"Comment": "listen to all memory allocations and update the peak memory reservations accordingly",
	"Method": "void updatePeakMemoryReservations(){\r\n    long userMemory = operatorMemoryContext.getUserMemory();\r\n    long systemMemory = operatorMemoryContext.getSystemMemory();\r\n    long totalMemory = userMemory + systemMemory;\r\n    peakUserMemoryReservation.accumulateAndGet(userMemory, Math::max);\r\n    peakSystemMemoryReservation.accumulateAndGet(systemMemory, Math::max);\r\n    peakTotalMemoryReservation.accumulateAndGet(totalMemory, Math::max);\r\n}"
}, {
	"Path": "org.redisson.config.Config.isReferenceEnabled",
	"Comment": "config option indicate whether redisson reference feature is enabled.default value is true",
	"Method": "boolean isReferenceEnabled(){\r\n    return referenceEnabled;\r\n}"
}, {
	"Path": "io.realm.RealmList.where",
	"Comment": "returns a realmquery, which can be used to query for specific objects of this class.",
	"Method": "RealmQuery<E> where(){\r\n    if (isManaged()) {\r\n        checkValidRealm();\r\n        if (!osListOperator.forRealmModel()) {\r\n            throw new UnsupportedOperationException(ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE);\r\n        }\r\n        return RealmQuery.createQueryFromList(this);\r\n    } else {\r\n        throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);\r\n    }\r\n}"
}, {
	"Path": "io.realm.rule.RunInLooperThread.setBackgroundHandler",
	"Comment": "storing the handler is the gate that indicates that the test thread has started.",
	"Method": "void setBackgroundHandler(Handler backgroundHandler){\r\n    synchronized (lock) {\r\n        this.backgroundHandler = backgroundHandler;\r\n        lock.notifyAll();\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.orc.OrcWriter.bufferStripeData",
	"Comment": "collect the data for for the stripe.this is not the actual data, butinstead are functions that know how to write the data.",
	"Method": "List<OrcDataOutput> bufferStripeData(long stripeStartOffset,FlushReason flushReason){\r\n    if (stripeRowCount == 0) {\r\n        verify(flushReason == CLOSED, \"An empty stripe is not allowed\");\r\n        columnWriters.forEach(ColumnWriter::close);\r\n        return ImmutableList.of();\r\n    }\r\n    if (rowGroupRowCount > 0) {\r\n        finishRowGroup();\r\n    }\r\n    dictionaryCompressionOptimizer.finalOptimize(bufferedBytes);\r\n    columnWriters.forEach(ColumnWriter::close);\r\n    List<OrcDataOutput> outputData = new ArrayList();\r\n    List<Stream> allStreams = new ArrayList(columnWriters.size() * 3);\r\n    long indexLength = 0;\r\n    for (ColumnWriter columnWriter : columnWriters) {\r\n        for (StreamDataOutput indexStream : columnWriter.getIndexStreams(metadataWriter)) {\r\n            outputData.add(indexStream);\r\n            allStreams.add(indexStream.getStream());\r\n            indexLength += indexStream.size();\r\n        }\r\n    }\r\n    long dataLength = 0;\r\n    List<StreamDataOutput> dataStreams = new ArrayList(columnWriters.size() * 2);\r\n    for (ColumnWriter columnWriter : columnWriters) {\r\n        List<StreamDataOutput> streams = columnWriter.getDataStreams();\r\n        dataStreams.addAll(streams);\r\n        dataLength += streams.stream().mapToLong(StreamDataOutput::size).sum();\r\n    }\r\n    Collections.sort(dataStreams);\r\n    for (StreamDataOutput dataStream : dataStreams) {\r\n        outputData.add(dataStream);\r\n        allStreams.add(dataStream.getStream());\r\n    }\r\n    Map<Integer, ColumnEncoding> columnEncodings = new HashMap();\r\n    columnWriters.forEach(columnWriter -> columnEncodings.putAll(columnWriter.getColumnEncodings()));\r\n    Map<Integer, ColumnStatistics> columnStatistics = new HashMap();\r\n    columnWriters.forEach(columnWriter -> columnStatistics.putAll(columnWriter.getColumnStripeStatistics()));\r\n    columnEncodings.put(0, new ColumnEncoding(DIRECT, 0));\r\n    columnStatistics.put(0, new ColumnStatistics((long) stripeRowCount, 0, null, null, null, null, null, null, null, null));\r\n    StripeFooter stripeFooter = new StripeFooter(allStreams, toDenseList(columnEncodings, orcTypes.size()));\r\n    Slice footer = metadataWriter.writeStripeFooter(stripeFooter);\r\n    outputData.add(createDataOutput(footer));\r\n    StripeStatistics statistics = new StripeStatistics(toDenseList(columnStatistics, orcTypes.size()));\r\n    recordValidation(validation -> validation.addStripeStatistics(stripeStartOffset, statistics));\r\n    StripeInformation stripeInformation = new StripeInformation(stripeRowCount, stripeStartOffset, indexLength, dataLength, footer.length());\r\n    ClosedStripe closedStripe = new ClosedStripe(stripeInformation, statistics);\r\n    closedStripes.add(closedStripe);\r\n    closedStripesRetainedBytes += closedStripe.getRetainedSizeInBytes();\r\n    recordValidation(validation -> validation.addStripe(stripeInformation.getNumberOfRows()));\r\n    stats.recordStripeWritten(flushReason, stripeInformation.getTotalLength(), stripeInformation.getNumberOfRows(), dictionaryCompressionOptimizer.getDictionaryMemoryBytes());\r\n    return outputData;\r\n}"
}, {
	"Path": "com.facebook.presto.sql.planner.plan.SetOperationNode.outputSymbolMap",
	"Comment": "returns the input to output symbol mapping for the given source channel.a single input symbol can map to multiple output symbols, thus requiring a multimap.",
	"Method": "Multimap<Symbol, SymbolReference> outputSymbolMap(int sourceIndex){\r\n    return Multimaps.transformValues(FluentIterable.from(getOutputSymbols()).toMap(outputToSourceSymbolFunction(sourceIndex)).asMultimap().inverse(), Symbol::toSymbolReference);\r\n}"
}, {
	"Path": "io.realm.internal.RealmNotifier.close",
	"Comment": "called when close ossharedrealm to clean up any event left in to queue.",
	"Method": "void close(){\r\n    removeAllChangeListeners();\r\n    startSendingNotificationsCallbacks.clear();\r\n    finishedSendingNotificationsCallbacks.clear();\r\n}"
}, {
	"Path": "io.realm.examples.intro.model.Person.getName",
	"Comment": "or if you like you can even have public fields and no accessors! see dog.java and cat.java",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "io.realm.RealmConfiguration.getPath",
	"Comment": "returns the absolute path to where the realm file will be saved.",
	"Method": "String getPath(){\r\n    return canonicalPath;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.HostAddress.getPortOrDefault",
	"Comment": "returns the current port number, with a default if no port is defined.",
	"Method": "int getPortOrDefault(int defaultPort){\r\n    return hasPort() ? port : defaultPort;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.predicate.TupleDomain.contains",
	"Comment": "returns true only if the this tupledomain contains all possible tuples that would be allowable bythe other tupledomain.",
	"Method": "boolean contains(TupleDomain<T> other){\r\n    return other.isNone() || columnWiseUnion(this, other).equals(this);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanSetCatalogSessionProperty",
	"Comment": "check if identity is allowed to set the specified property in this catalog.",
	"Method": "void checkCanSetCatalogSessionProperty(ConnectorTransactionHandle transactionHandle,Identity identity,String propertyName){\r\n    denySetCatalogSessionProperty(propertyName);\r\n}"
}, {
	"Path": "com.facebook.presto.orc.TestOrcReaderMemoryUsage.createSingleColumnVarcharFile",
	"Comment": "write a file that contains a number of rows with 1 varchar column, and all values are not null.",
	"Method": "TempFile createSingleColumnVarcharFile(int count,int length){\r\n    Serializer serde = new OrcSerde();\r\n    TempFile tempFile = new TempFile();\r\n    FileSinkOperator.RecordWriter writer = createOrcRecordWriter(tempFile.getFile(), ORC_12, CompressionKind.NONE, VARCHAR);\r\n    SettableStructObjectInspector objectInspector = createSettableStructObjectInspector(\"test\", VARCHAR);\r\n    Object row = objectInspector.create();\r\n    StructField field = objectInspector.getAllStructFieldRefs().get(0);\r\n    for (int i = 0; i < count; i++) {\r\n        objectInspector.setStructFieldData(row, field, Strings.repeat(\"0\", length));\r\n        Writable record = serde.serialize(row, objectInspector);\r\n        writer.write(record);\r\n    }\r\n    writer.close(false);\r\n    return tempFile;\r\n}"
}, {
	"Path": "com.facebook.presto.orc.OrcRecordReader.getFileRowCount",
	"Comment": "returns the total number of rows in the file. this count includes rowsfor stripes that were completely excluded due to stripe statistics.",
	"Method": "long getFileRowCount(){\r\n    return fileRowCount;\r\n}"
}, {
	"Path": "io.realm.PermissionManager.isClosed",
	"Comment": "checks if this permissionmanager is closed or not. if it is closed, all methods will report back an error.",
	"Method": "boolean isClosed(){\r\n    if (threadId != Thread.currentThread().getId()) {\r\n        throw new IllegalStateException(\"PermissionManager was accessed from the wrong thread. It can only be \" + \"accessed on the thread it was created on.\");\r\n    }\r\n    return closed;\r\n}"
}, {
	"Path": "io.realm.RealmNullPrimaryKeyTests.updatePrimaryKeyObject",
	"Comment": "updates existing null primarykey object with a new updating value.",
	"Method": "void updatePrimaryKeyObject(Realm testRealm,RealmObject realmObject){\r\n    if (testClazz.equals(PrimaryKeyAsString.class)) {\r\n        ((PrimaryKeyAsString) realmObject).setId((long) updatingFieldValue);\r\n    } else {\r\n        ((NullPrimaryKey) realmObject).setName(updatingFieldValue);\r\n    }\r\n    testRealm.beginTransaction();\r\n    testRealm.copyToRealmOrUpdate(realmObject);\r\n    testRealm.commitTransaction();\r\n}"
}, {
	"Path": "io.realm.TestHelper.resetRealmThreadExecutor",
	"Comment": "this will first wait for finishing all tasks in baserealm.asynctaskexecutor, throws if time out.then reset the baserealm.asynctaskexecutor to the default value.",
	"Method": "void resetRealmThreadExecutor(){\r\n    waitRealmThreadExecutorFinish();\r\n    replaceRealmThreadExecutor(RealmThreadPoolExecutor.newDefaultExecutor());\r\n}"
}, {
	"Path": "io.realm.SyncUserTests.login_withAccessToken",
	"Comment": "test that a login with an access token logs the user in directly without touching the network",
	"Method": "void login_withAccessToken(){\r\n    AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);\r\n    when(authServer.loginUser(any(SyncCredentials.class), any(URL.class))).thenThrow(new AssertionError(\"Server contacted.\"));\r\n    AuthenticationServer originalServer = SyncManager.getAuthServer();\r\n    SyncManager.setAuthServerImpl(authServer);\r\n    try {\r\n        SyncCredentials credentials = SyncCredentials.accessToken(\"foo\", \"bar\");\r\n        SyncUser user = SyncUser.logIn(credentials, \"http://ros.realm.io/auth\");\r\n        assertTrue(user.isValid());\r\n    } finally {\r\n        SyncManager.setAuthServerImpl(originalServer);\r\n    }\r\n}"
}, {
	"Path": "io.realm.processor.ClassMetaData.getObjectReferenceFields",
	"Comment": "returns all persistable fields that reference other realm objects.",
	"Method": "List<RealmFieldElement> getObjectReferenceFields(){\r\n    return Collections.unmodifiableList(objectReferenceFields);\r\n}"
}, {
	"Path": "io.realm.RealmSchema.refresh",
	"Comment": "called when schema changed. clear all cached tables and refresh column indices.",
	"Method": "void refresh(){\r\n    if (columnIndices != null) {\r\n        columnIndices.refresh();\r\n    }\r\n    dynamicClassToTable.clear();\r\n    classToTable.clear();\r\n    classToSchema.clear();\r\n    dynamicClassToSchema.clear();\r\n}"
}, {
	"Path": "io.realm.PermissionManager.getPermissions",
	"Comment": "retrieves the list of permissions for all realms available to this user.",
	"Method": "RealmAsyncTask getPermissions(PermissionsCallback callback){\r\n    checkIfValid();\r\n    checkCallbackNotNull(callback);\r\n    return addTask(new GetPermissionsAsyncTask(this, callback));\r\n}"
}, {
	"Path": "com.facebook.rebound.SpringChain.getControlSpring",
	"Comment": "retrieve the control spring so you can manipulate it to drive the positions of the othersprings.",
	"Method": "Spring getControlSpring(){\r\n    return mSprings.get(mControlSpringIndex);\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.setOvershootClampingEnabled",
	"Comment": "force the spring to clamp at its end value to avoid overshooting the target value.",
	"Method": "Spring setOvershootClampingEnabled(boolean overshootClampingEnabled){\r\n    mOvershootClampingEnabled = overshootClampingEnabled;\r\n    return this;\r\n}"
}, {
	"Path": "io.realm.RealmQuery.subscribe",
	"Comment": "creates an anonymous subscription from this query or returns the existing subscription ifone already existed.",
	"Method": "Subscription subscribe(Subscription subscribe,String name){\r\n    realm.checkIfValid();\r\n    if (realm instanceof DynamicRealm) {\r\n        throw new IllegalStateException(\"'subscribe' is not supported for queries on Dynamic Realms.\");\r\n    }\r\n    if (osList != null) {\r\n        throw new IllegalStateException(\"Cannot create subscriptions for queries based on a 'RealmList. Subscribe to the object holding the list instead.'\");\r\n    }\r\n    if (TextUtils.isEmpty(name)) {\r\n        throw new IllegalArgumentException(\"Non-empty 'name' required.\");\r\n    }\r\n    long rowIndex = nativeSubscribe(realm.getSharedRealm().getNativePtr(), name, query.getNativePtr(), queryDescriptors.getNativePtr());\r\n    CheckedRow row = ((Realm) realm).getTable(Subscription.class).getCheckedRow(rowIndex);\r\n    return realm.get(Subscription.class, null, row);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.ConnectorTableLayout.getTablePartitioning",
	"Comment": "the partitioning of the table across the worker nodes.if the table is node partitioned, the connector guarantees that each combination of values forthe distributed columns will be contained within a single worker.",
	"Method": "Optional<ConnectorTablePartitioning> getTablePartitioning(){\r\n    return tablePartitioning;\r\n}"
}, {
	"Path": "io.realm.SyncManager.reset",
	"Comment": "resets the syncmanger and clear all existing users.this will also terminate all sessions.only call this method when testing.",
	"Method": "void reset(){\r\n    nativeReset();\r\n    sessions.clear();\r\n    hostRestrictedAuthorizationHeaderName.clear();\r\n    globalAuthorizationHeaderName = \"Authorization\";\r\n    hostRestrictedCustomHeaders.clear();\r\n    globalCustomHeaders.clear();\r\n    authServer.clearCustomHeaderSettings();\r\n}"
}, {
	"Path": "io.realm.MutableRealmIntegerTests.copyFromIsNotLive",
	"Comment": "assure that a mutablerealminteger acquired from an unmanaged object is not affected by changes in the realm.",
	"Method": "void copyFromIsNotLive(){\r\n    realm.beginTransaction();\r\n    realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger().set(42L);\r\n    realm.commitTransaction();\r\n    MutableRealmIntegerTypes obj = realm.where(MutableRealmIntegerTypes.class).findFirst();\r\n    MutableRealmInteger managedRI = obj.getColumnNullableMutableRealmInteger();\r\n    MutableRealmInteger unmanagedRI = realm.copyFromRealm(obj).getColumnNullableMutableRealmInteger();\r\n    realm.beginTransaction();\r\n    MutableRealmInteger ri = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();\r\n    ri.set(37);\r\n    ri.increment(17);\r\n    ri.decrement(7);\r\n    realm.commitTransaction();\r\n    assertEquals(Long.valueOf(42L), unmanagedRI.get());\r\n    assertEquals(Long.valueOf(47L), managedRI.get());\r\n}"
}, {
	"Path": "org.redisson.api.TransactionOptions.responseTimeout",
	"Comment": "defines timeout for redis response. starts to countdown when transaction has been successfully sent.default is 3000 milliseconds",
	"Method": "TransactionOptions responseTimeout(long timeout,TimeUnit unit){\r\n    this.responseTimeout = unit.toMillis(timeout);\r\n    return this;\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransaction_async_realmClosedOnError",
	"Comment": "tests if the background realm is closed when transaction error returned.",
	"Method": "void executeTransaction_async_realmClosedOnError(){\r\n    final AtomicInteger counter = new AtomicInteger(100);\r\n    final Realm realm = looperThread.getRealm();\r\n    final RealmCache.Callback cacheCallback = new RealmCache.Callback() {\r\n        @Override\r\n        public void onResult(int count) {\r\n            assertEquals(1, count);\r\n            if (counter.decrementAndGet() == 0) {\r\n                realm.close();\r\n                looperThread.testComplete();\r\n            }\r\n        }\r\n    };\r\n    final Realm.Transaction.OnError transactionCallback = new Realm.Transaction.OnError() {\r\n        @Override\r\n        public void onError(Throwable error) {\r\n            RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\r\n            if (counter.get() == 0) {\r\n                return;\r\n            }\r\n            realm.executeTransactionAsync(new Realm.Transaction() {\r\n                @Override\r\n                public void execute(Realm realm) {\r\n                    throw new RuntimeException(\"Dummy exception\");\r\n                }\r\n            }, this);\r\n        }\r\n    };\r\n    realm.executeTransactionAsync(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            throw new RuntimeException(\"Dummy exception\");\r\n        }\r\n    }, transactionCallback);\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransaction_async_realmClosedOnError",
	"Comment": "tests if the background realm is closed when transaction error returned.",
	"Method": "void executeTransaction_async_realmClosedOnError(){\r\n    assertEquals(1, count);\r\n    if (counter.decrementAndGet() == 0) {\r\n        realm.close();\r\n        looperThread.testComplete();\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransaction_async_realmClosedOnError",
	"Comment": "tests if the background realm is closed when transaction error returned.",
	"Method": "void executeTransaction_async_realmClosedOnError(){\r\n    RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\r\n    if (counter.get() == 0) {\r\n        return;\r\n    }\r\n    realm.executeTransactionAsync(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            throw new RuntimeException(\"Dummy exception\");\r\n        }\r\n    }, this);\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransaction_async_realmClosedOnError",
	"Comment": "tests if the background realm is closed when transaction error returned.",
	"Method": "void executeTransaction_async_realmClosedOnError(){\r\n    throw new RuntimeException(\"Dummy exception\");\r\n}"
}, {
	"Path": "io.realm.RealmAsyncQueryTests.executeTransaction_async_realmClosedOnError",
	"Comment": "tests if the background realm is closed when transaction error returned.",
	"Method": "void executeTransaction_async_realmClosedOnError(){\r\n    throw new RuntimeException(\"Dummy exception\");\r\n}"
}, {
	"Path": "io.realm.RealmQueryTests.lessThanOrEqual_nullValuesInRow",
	"Comment": "queries with lessthanorequalto and table has null values in row.",
	"Method": "void lessThanOrEqual_nullValuesInRow(){\r\n    TestHelper.populateTestRealmForNullTests(realm);\r\n    assertEquals(1, realm.where(NullTypes.class).lessThanOrEqualTo(NullTypes.FIELD_INTEGER_NULL, 1).count());\r\n    assertEquals(1, realm.where(NullTypes.class).lessThanOrEqualTo(NullTypes.FIELD_LONG_NULL, 1L).count());\r\n    assertEquals(1, realm.where(NullTypes.class).lessThanOrEqualTo(NullTypes.FIELD_FLOAT_NULL, 1F).count());\r\n    assertEquals(1, realm.where(NullTypes.class).lessThanOrEqualTo(NullTypes.FIELD_DOUBLE_NULL, 1D).count());\r\n    assertEquals(1, realm.where(NullTypes.class).lessThanOrEqualTo(NullTypes.FIELD_DATE_NULL, new Date(9999)).count());\r\n}"
}, {
	"Path": "io.realm.internal.Table.setString",
	"Comment": "sets a string value to a cell of table, pointed by column and row index.",
	"Method": "void setString(long columnIndex,long rowIndex,String value,boolean isDefault){\r\n    checkImmutable();\r\n    if (value == null) {\r\n        nativeSetNull(nativePtr, columnIndex, rowIndex, isDefault);\r\n    } else {\r\n        nativeSetString(nativePtr, columnIndex, rowIndex, value, isDefault);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanRenameSchema",
	"Comment": "check if identity is allowed to rename the specified schema in this catalog.",
	"Method": "void checkCanRenameSchema(ConnectorTransactionHandle transactionHandle,Identity identity,String schemaName,String newSchemaName){\r\n    denyRenameSchema(schemaName, newSchemaName);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanDropView",
	"Comment": "check if identity is allowed to drop the specified view in this catalog.",
	"Method": "void checkCanDropView(ConnectorTransactionHandle transactionHandle,Identity identity,SchemaTableName viewName){\r\n    denyDropView(viewName.toString());\r\n}"
}, {
	"Path": "io.realm.internal.ColumnInfo.getInternalFieldName",
	"Comment": "returns the internal field name that corresponds to the name found in the java model class.",
	"Method": "String getInternalFieldName(String javaFieldName){\r\n    return javaFieldNameToInternalNames.get(javaFieldName);\r\n}"
}, {
	"Path": "io.realm.RealmQueryTests.greaterThanOrEqualTo_nullValuesInRow",
	"Comment": "queries with greaterthanorequalto and table has null values in row.",
	"Method": "void greaterThanOrEqualTo_nullValuesInRow(){\r\n    TestHelper.populateTestRealmForNullTests(realm);\r\n    assertEquals(1, realm.where(NullTypes.class).greaterThanOrEqualTo(NullTypes.FIELD_INTEGER_NULL, 3).count());\r\n    assertEquals(1, realm.where(NullTypes.class).greaterThanOrEqualTo(NullTypes.FIELD_LONG_NULL, 3L).count());\r\n    assertEquals(1, realm.where(NullTypes.class).greaterThanOrEqualTo(NullTypes.FIELD_FLOAT_NULL, 3F).count());\r\n    assertEquals(1, realm.where(NullTypes.class).greaterThanOrEqualTo(NullTypes.FIELD_DOUBLE_NULL, 3D).count());\r\n    assertEquals(1, realm.where(NullTypes.class).greaterThanOrEqualTo(NullTypes.FIELD_DATE_NULL, new Date(10000)).count());\r\n}"
}, {
	"Path": "io.realm.ObjectServerError.getErrorMessage",
	"Comment": "returns a more detailed error message about the cause of this error.",
	"Method": "String getErrorMessage(){\r\n    return errorMessage;\r\n}"
}, {
	"Path": "io.realm.processor.RealmProcessor.preProcessModules",
	"Comment": "returns true if modules were processed successfully, false otherwise",
	"Method": "boolean preProcessModules(RoundEnvironment roundEnv){\r\n    moduleMetaData = new ModuleMetaData();\r\n    return moduleMetaData.preProcess(roundEnv.getElementsAnnotatedWith(RealmModule.class));\r\n}"
}, {
	"Path": "io.realm.internal.objectstore.OsObjectBuilder.getNativePtr",
	"Comment": "returns the underlying native pointer representing this builder.",
	"Method": "long getNativePtr(){\r\n    return builderPtr;\r\n}"
}, {
	"Path": "io.realm.objectserver.utils.UserFactory.createUniqueUser",
	"Comment": "create a unique user, using the standard authentification url used by the test server.",
	"Method": "SyncUser createUniqueUser(SyncUser createUniqueUser,String authUrl){\r\n    String uniqueName = UUID.randomUUID().toString();\r\n    return createUser(uniqueName);\r\n}"
}, {
	"Path": "com.facebook.presto.sql.planner.plan.ChildReplacer.replaceChildren",
	"Comment": "return an identical copy of the given node with its children replaced",
	"Method": "PlanNode replaceChildren(PlanNode node,List<PlanNode> children){\r\n    for (int i = 0; i < node.getSources().size(); i++) {\r\n        if (children.get(i) != node.getSources().get(i)) {\r\n            return node.replaceChildren(children);\r\n        }\r\n    }\r\n    return node;\r\n}"
}, {
	"Path": "com.facebook.presto.operator.DistinctLimitOperator.updateMemoryReservation",
	"Comment": "the following implementation is a hybrid model, where the push model is going to call the pull model causing reentrancy",
	"Method": "boolean updateMemoryReservation(){\r\n    localUserMemoryContext.setBytes(groupByHash.getEstimatedSize());\r\n    return operatorContext.isWaitingForMemory().isDone();\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorMetadata.getStatisticsCollectionMetadata",
	"Comment": "describes statistics that must be collected during a write.",
	"Method": "TableStatisticsMetadata getStatisticsCollectionMetadata(ConnectorSession session,ConnectorTableMetadata tableMetadata){\r\n    return TableStatisticsMetadata.empty();\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanCreateTable",
	"Comment": "check if identity is allowed to create the specified table in a catalog.",
	"Method": "void checkCanCreateTable(Identity identity,CatalogSchemaTableName table){\r\n    denyCreateTable(table.toString());\r\n}"
}, {
	"Path": "io.realm.TestHelper.getRandomKey",
	"Comment": "returns a random key from the given seed. used by encrypted realms.",
	"Method": "byte[] getRandomKey(byte[] getRandomKey,long seed){\r\n    byte[] key = new byte[64];\r\n    new Random(seed).nextBytes(key);\r\n    return key;\r\n}"
}, {
	"Path": "io.realm.DynamicRealmObject.checkIsPrimaryKey",
	"Comment": "checks if the given field is primary key field. throws if it is a pk field.",
	"Method": "void checkIsPrimaryKey(String fieldName){\r\n    RealmObjectSchema objectSchema = proxyState.getRealm$realm().getSchema().getSchemaForClass(getType());\r\n    if (objectSchema.hasPrimaryKey() && objectSchema.getPrimaryKey().equals(fieldName)) {\r\n        throw new IllegalArgumentException(String.format(Locale.US, \"Primary key field '%s' cannot be changed after object was created.\", fieldName));\r\n    }\r\n}"
}, {
	"Path": "io.realm.internal.core.QueryDescriptor.checkFieldType",
	"Comment": "could do this in the field descriptor, but this provides a better error message",
	"Method": "void checkFieldType(FieldDescriptor descriptor,Set<RealmFieldType> legalTerminalTypes,String message,String fieldDescriptions){\r\n    if (!legalTerminalTypes.contains(descriptor.getFinalColumnType())) {\r\n        throw new IllegalArgumentException(String.format(Locale.US, \"%s on '%s' field '%s' in '%s'.\", message, descriptor.getFinalColumnType(), descriptor.getFinalColumnName(), fieldDescriptions));\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.resourceGroups.db.DbResourceGroupConfigurationManager.populateFromDbHelper",
	"Comment": "populate temporary data structures to build resource group specs and selectors from db",
	"Method": "void populateFromDbHelper(Map<Long, ResourceGroupSpecBuilder> recordMap,Set<Long> rootGroupIds,Map<Long, ResourceGroupIdTemplate> resourceGroupIdTemplateMap,Map<Long, Set<Long>> subGroupIdsToBuild){\r\n    List<ResourceGroupSpecBuilder> records = dao.getResourceGroups(environment);\r\n    for (ResourceGroupSpecBuilder record : records) {\r\n        recordMap.put(record.getId(), record);\r\n        if (!record.getParentId().isPresent()) {\r\n            rootGroupIds.add(record.getId());\r\n            resourceGroupIdTemplateMap.put(record.getId(), new ResourceGroupIdTemplate(record.getNameTemplate().toString()));\r\n        } else {\r\n            subGroupIdsToBuild.computeIfAbsent(record.getParentId().get(), k -> new HashSet()).add(record.getId());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.operator.MergeHashSort.merge",
	"Comment": "rows with same hash value are guaranteed to be in the same result page.",
	"Method": "WorkProcessor<Page> merge(List<Type> keyTypes,List<Type> allTypes,List<WorkProcessor<Page>> channels,DriverYieldSignal driverYieldSignal){\r\n    InterpretedHashGenerator hashGenerator = createHashGenerator(keyTypes);\r\n    return mergeSortedPages(channels, createHashPageWithPositionComparator(hashGenerator), IntStream.range(0, allTypes.size()).boxed().collect(toImmutableList()), allTypes, keepSameHashValuesWithinSinglePage(hashGenerator), true, memoryContext, driverYieldSignal);\r\n}"
}, {
	"Path": "io.realm.log.RealmLog.add",
	"Comment": "adds a logger implementation that will be notified on log events.",
	"Method": "void add(RealmLogger logger){\r\n    if (logger == null) {\r\n        throw new IllegalArgumentException(\"A non-null logger has to be provided\");\r\n    }\r\n    nativeAddLogger(logger);\r\n}"
}, {
	"Path": "io.realm.SyncSessionTests.downloadChangesWhenRealmOutOfScope",
	"Comment": "a realm that was opened before a user logged out should be able to resume downloading if the user logs back in.",
	"Method": "void downloadChangesWhenRealmOutOfScope(){\r\n    final String uniqueName = UUID.randomUUID().toString();\r\n    SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, \"password\", true);\r\n    SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);\r\n    final SyncConfiguration syncConfiguration = configFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL).fullSynchronization().modules(new StringOnlyModule()).build();\r\n    Realm realm = Realm.getInstance(syncConfiguration);\r\n    realm.beginTransaction();\r\n    realm.createObject(StringOnly.class).setChars(\"1\");\r\n    realm.commitTransaction();\r\n    SyncSession session = SyncManager.getSession(syncConfiguration);\r\n    session.uploadAllLocalChanges();\r\n    user.logOut();\r\n    credentials = SyncCredentials.usernamePassword(uniqueName, \"password\", false);\r\n    SyncUser.logIn(credentials, Constants.AUTH_URL);\r\n    final CountDownLatch backgroundUpload = new CountDownLatch(1);\r\n    final HandlerThread handlerThread = new HandlerThread(\"HandlerThread\");\r\n    handlerThread.start();\r\n    Looper looper = handlerThread.getLooper();\r\n    Handler handler = new Handler(looper);\r\n    handler.post(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);\r\n            SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), \"custom-admin-user\");\r\n            SyncUser adminUser = SyncUser.logIn(credentialsAdmin, Constants.AUTH_URL);\r\n            SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString()).fullSynchronization().modules(new StringOnlyModule()).waitForInitialRemoteData().build();\r\n            final Realm adminRealm = Realm.getInstance(adminConfig);\r\n            adminRealm.beginTransaction();\r\n            adminRealm.createObject(StringOnly.class).setChars(\"2\");\r\n            adminRealm.createObject(StringOnly.class).setChars(\"3\");\r\n            adminRealm.commitTransaction();\r\n            try {\r\n                SyncManager.getSession(adminConfig).uploadAllLocalChanges();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n                fail(e.getMessage());\r\n            }\r\n            adminRealm.close();\r\n            backgroundUpload.countDown();\r\n            handlerThread.quit();\r\n        }\r\n    });\r\n    TestHelper.awaitOrFail(backgroundUpload, 60);\r\n    session.downloadAllServerChanges();\r\n    realm.refresh();\r\n    assertEquals(3, realm.where(StringOnly.class).count());\r\n    realm.close();\r\n}"
}, {
	"Path": "io.realm.SyncSessionTests.downloadChangesWhenRealmOutOfScope",
	"Comment": "a realm that was opened before a user logged out should be able to resume downloading if the user logs back in.",
	"Method": "void downloadChangesWhenRealmOutOfScope(){\r\n    SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);\r\n    SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), \"custom-admin-user\");\r\n    SyncUser adminUser = SyncUser.logIn(credentialsAdmin, Constants.AUTH_URL);\r\n    SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString()).fullSynchronization().modules(new StringOnlyModule()).waitForInitialRemoteData().build();\r\n    final Realm adminRealm = Realm.getInstance(adminConfig);\r\n    adminRealm.beginTransaction();\r\n    adminRealm.createObject(StringOnly.class).setChars(\"2\");\r\n    adminRealm.createObject(StringOnly.class).setChars(\"3\");\r\n    adminRealm.commitTransaction();\r\n    try {\r\n        SyncManager.getSession(adminConfig).uploadAllLocalChanges();\r\n    } catch (InterruptedException e) {\r\n        e.printStackTrace();\r\n        fail(e.getMessage());\r\n    }\r\n    adminRealm.close();\r\n    backgroundUpload.countDown();\r\n    handlerThread.quit();\r\n}"
}, {
	"Path": "com.facebook.presto.operator.OperatorContext.requestMemoryRevoking",
	"Comment": "returns how much revocable memory will be revoked by the operator",
	"Method": "long requestMemoryRevoking(){\r\n    long revokedMemory = 0L;\r\n    Runnable listener = null;\r\n    synchronized (this) {\r\n        if (!isMemoryRevokingRequested() && operatorMemoryContext.getRevocableMemory() > 0) {\r\n            memoryRevokingRequested = true;\r\n            revokedMemory = operatorMemoryContext.getRevocableMemory();\r\n            listener = memoryRevocationRequestListener;\r\n        }\r\n    }\r\n    if (listener != null) {\r\n        runListener(listener);\r\n    }\r\n    return revokedMemory;\r\n}"
}, {
	"Path": "org.redisson.misc.HighwayHash.updateRemainder",
	"Comment": "updates the hash with the last 1 to 31 bytes of the data. you must useupdatepacket first per 32 bytes of the data, if and only if 1 to 31 bytesof the data are not processed after that, updateremainder must be used forthose final bytes.",
	"Method": "void updateRemainder(byte[] bytes,int pos,int size_mod32){\r\n    if (pos < 0) {\r\n        throw new IllegalArgumentException(String.format(\"Pos (%s) must be positive\", pos));\r\n    }\r\n    if (size_mod32 < 0 || size_mod32 >= 32) {\r\n        throw new IllegalArgumentException(String.format(\"size_mod32 (%s) must be between 0 and 31\", size_mod32));\r\n    }\r\n    if (pos + size_mod32 > bytes.length) {\r\n        throw new IllegalArgumentException(\"bytes must have at least size_mod32 bytes after pos\");\r\n    }\r\n    int size_mod4 = size_mod32 & 3;\r\n    int remainder = size_mod32 & ~3;\r\n    byte[] packet = new byte[32];\r\n    for (int i = 0; i < 4; ++i) {\r\n        v0[i] += ((long) size_mod32 << 32) + size_mod32;\r\n    }\r\n    rotate32By(size_mod32, v1);\r\n    for (int i = 0; i < remainder; i++) {\r\n        packet[i] = bytes[pos + i];\r\n    }\r\n    if ((size_mod32 & 16) != 0) {\r\n        for (int i = 0; i < 4; i++) {\r\n            packet[28 + i] = bytes[pos + remainder + i + size_mod4 - 4];\r\n        }\r\n    } else {\r\n        if (size_mod4 != 0) {\r\n            packet[16 + 0] = bytes[pos + remainder + 0];\r\n            packet[16 + 1] = bytes[pos + remainder + (size_mod4 >>> 1)];\r\n            packet[16 + 2] = bytes[pos + remainder + (size_mod4 - 1)];\r\n        }\r\n    }\r\n    updatePacket(packet, 0);\r\n}"
}, {
	"Path": "io.realm.internal.TableQuery.count",
	"Comment": "returns only the number of matching objects.this method is very fast compared to evaluating a query completely, but it does notgoes around any logic implemented in object store and other parts of the api that workson query results. so the primary use case for this method is testing.",
	"Method": "long count(long start,long end,long limit,long count){\r\n    validateQuery();\r\n    return nativeCount(nativePtr, 0, Table.INFINITE, Table.INFINITE);\r\n}"
}, {
	"Path": "io.realm.processor.ModuleMetaData.checkAndReportPolicyConflict",
	"Comment": "check for name policy conflicts and report the error if found.",
	"Method": "boolean checkAndReportPolicyConflict(ModulePolicyInfo moduleInfo,ModulePolicyInfo otherModuleInfo,boolean checkAndReportPolicyConflict,String className,ModulePolicyInfo moduleInfo,ModulePolicyInfo otherModuleInfo){\r\n    boolean foundErrors = false;\r\n    RealmNamingPolicy classPolicy = moduleInfo.classNamePolicy;\r\n    RealmNamingPolicy otherClassPolicy = otherModuleInfo.classNamePolicy;\r\n    if (classPolicy != RealmNamingPolicy.NO_POLICY && otherClassPolicy != RealmNamingPolicy.NO_POLICY && classPolicy != otherClassPolicy) {\r\n        Utils.error(String.format(\"The modules %s and %s disagree on the class naming policy%s: %s vs. %s. \" + \"They same policy must be used.\", moduleInfo.qualifiedModuleClassName, otherModuleInfo.qualifiedModuleClassName, (className != null) ? \" for \" + className : \"\", classPolicy, otherClassPolicy));\r\n        foundErrors = true;\r\n    }\r\n    RealmNamingPolicy fieldPolicy = moduleInfo.fieldNamePolicy;\r\n    RealmNamingPolicy otherFieldPolicy = otherModuleInfo.fieldNamePolicy;\r\n    if (fieldPolicy != RealmNamingPolicy.NO_POLICY && otherFieldPolicy != RealmNamingPolicy.NO_POLICY && fieldPolicy != otherFieldPolicy) {\r\n        Utils.error(String.format(\"The modules %s and %s disagree on the field naming policy%s: %s vs. %s. \" + \"They same policy should be used.\", moduleInfo.qualifiedModuleClassName, otherModuleInfo.qualifiedModuleClassName, (className != null) ? \" for \" + className : \"\", fieldPolicy, otherFieldPolicy));\r\n        foundErrors = true;\r\n    }\r\n    return foundErrors;\r\n}"
}, {
	"Path": "io.realm.SyncedRealmMigrationTests.sameSchemaVersion_doNotRebuildIndexes",
	"Comment": "check that indexes are not being added if the schema version is the same",
	"Method": "void sameSchemaVersion_doNotRebuildIndexes(){\r\n    SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), \"http://foo.com/auth\").schema(IndexedFields.class).schemaVersion(42).build();\r\n    String className = IndexedFields.class.getSimpleName();\r\n    DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);\r\n    RealmSchema schema = dynamicRealm.getSchema();\r\n    dynamicRealm.beginTransaction();\r\n    // No index\r\n    schema.create(className).addField(IndexedFields.FIELD_INDEXED_STRING, String.class).addField(IndexedFields.FIELD_NON_INDEXED_STRING, String.class);\r\n    dynamicRealm.setVersion(42);\r\n    dynamicRealm.commitTransaction();\r\n    dynamicRealm.close();\r\n    Realm realm = Realm.getInstance(config);\r\n    RealmObjectSchema indexedFieldsSchema = realm.getSchema().get(className);\r\n    try {\r\n        assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_INDEXED_STRING));\r\n        assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_NON_INDEXED_STRING));\r\n    } finally {\r\n        realm.close();\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmQueryTests.isNull_listFieldThrows",
	"Comment": "calling isnull on fields with the realmlist type will trigger an exception.",
	"Method": "void isNull_listFieldThrows(){\r\n    try {\r\n        realm.where(Owner.class).isNull(\"dogs\");\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n        assertEquals(\"Illegal Argument: RealmList(dogs) is not nullable.\", expected.getMessage());\r\n    }\r\n    try {\r\n        realm.where(Cat.class).isNull(\"owner.dogs\");\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n        assertEquals(\"Illegal Argument: RealmList(dogs) is not nullable.\", expected.getMessage());\r\n    }\r\n}"
}, {
	"Path": "io.realm.Realm.getSubscriptions",
	"Comment": "returns a list of all known subscriptions, regardless of their status.",
	"Method": "RealmResults<Subscription> getSubscriptions(RealmResults<Subscription> getSubscriptions,String pattern){\r\n    if (Util.isEmptyString(pattern)) {\r\n        throw new IllegalArgumentException(\"Non-empty 'pattern' required\");\r\n    }\r\n    return where(Subscription.class).like(\"name\", pattern).findAll();\r\n}"
}, {
	"Path": "io.realm.DynamicRealm.getPrivileges",
	"Comment": "returns the privileges granted the current user for the given class.",
	"Method": "ClassPrivileges getPrivileges(String className){\r\n    checkIfValid();\r\n    if (Util.isEmptyString(className)) {\r\n        throw new IllegalArgumentException(\"Non-empty 'className' required.\");\r\n    }\r\n    if (!schema.contains(className)) {\r\n        throw new RealmException(\"Class '\" + className + \"' is not part of the schema for this Realm\");\r\n    }\r\n    return new ClassPrivileges(sharedRealm.getClassPrivileges(className));\r\n}"
}, {
	"Path": "io.realm.permissions.PermissionOffer.mayManage",
	"Comment": "returns whether or not the user accepting this offer is granted manage permission. this will allow this userto also grant or remove permission for other users on this realm.",
	"Method": "boolean mayManage(){\r\n    return mayManage;\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.settingRequiredForNullableThrows",
	"Comment": "if a field is not required but was not nullable before, a realmmigrationneededexception should be thrown.",
	"Method": "void settingRequiredForNullableThrows(){\r\n    String[] notNullableFields = { NullTypes.FIELD_STRING_NULL, NullTypes.FIELD_BYTES_NULL, NullTypes.FIELD_BOOLEAN_NULL, NullTypes.FIELD_BYTE_NULL, NullTypes.FIELD_SHORT_NULL, NullTypes.FIELD_INTEGER_NULL, NullTypes.FIELD_LONG_NULL, NullTypes.FIELD_FLOAT_NULL, NullTypes.FIELD_DOUBLE_NULL, NullTypes.FIELD_DATE_NULL };\r\n    for (final String field : notNullableFields) {\r\n        final RealmMigration migration = new RealmMigration() {\r\n            @Override\r\n            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {\r\n                if (oldVersion == 0) {\r\n                    RealmObjectSchema nullTypesSchema = realm.getSchema().get(NullTypes.CLASS_NAME);\r\n                    if (field.equals(NullTypes.FIELD_STRING_NULL)) {\r\n                        nullTypesSchema.addField(field, String.class, FieldAttribute.REQUIRED);\r\n                    } else if (field.equals(NullTypes.FIELD_BYTES_NULL)) {\r\n                        nullTypesSchema.addField(field, byte[].class, FieldAttribute.REQUIRED);\r\n                    } else if (field.equals(NullTypes.FIELD_BOOLEAN_NULL)) {\r\n                        nullTypesSchema.addField(field, boolean.class);\r\n                    } else if (field.equals(NullTypes.FIELD_BYTE_NULL) || field.equals(NullTypes.FIELD_SHORT_NULL) || field.equals(NullTypes.FIELD_INTEGER_NULL) || field.equals(NullTypes.FIELD_LONG_NULL)) {\r\n                        nullTypesSchema.addField(field, int.class);\r\n                    } else if (field.equals(NullTypes.FIELD_FLOAT_NULL)) {\r\n                        nullTypesSchema.addField(field, float.class);\r\n                    } else if (field.equals(NullTypes.FIELD_DOUBLE_NULL)) {\r\n                        nullTypesSchema.addField(field, double.class);\r\n                    } else if (field.equals(NullTypes.FIELD_DATE_NULL)) {\r\n                        nullTypesSchema.addField(field, Date.class, FieldAttribute.REQUIRED);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        @SuppressWarnings(\"unchecked\")\r\n        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder().schemaVersion(1).name(field).schema(NullTypes.class).migration(migration).build();\r\n        Realm.deleteRealm(realmConfig);\r\n        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realmConfig);\r\n        TestHelper.initNullTypesTableExcludes(dynamicRealm, field);\r\n        dynamicRealm.close();\r\n        try {\r\n            realm = Realm.getInstance(realmConfig);\r\n            fail(\"Failed on \" + field);\r\n        } catch (RealmMigrationNeededException e) {\r\n            assertThat(e.getMessage(), CoreMatchers.containsString(String.format(Locale.US, \"Property 'NullTypes.%s' has been made optional\", field)));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.settingRequiredForNullableThrows",
	"Comment": "if a field is not required but was not nullable before, a realmmigrationneededexception should be thrown.",
	"Method": "void settingRequiredForNullableThrows(){\r\n    if (oldVersion == 0) {\r\n        RealmObjectSchema nullTypesSchema = realm.getSchema().get(NullTypes.CLASS_NAME);\r\n        if (field.equals(NullTypes.FIELD_STRING_NULL)) {\r\n            nullTypesSchema.addField(field, String.class, FieldAttribute.REQUIRED);\r\n        } else if (field.equals(NullTypes.FIELD_BYTES_NULL)) {\r\n            nullTypesSchema.addField(field, byte[].class, FieldAttribute.REQUIRED);\r\n        } else if (field.equals(NullTypes.FIELD_BOOLEAN_NULL)) {\r\n            nullTypesSchema.addField(field, boolean.class);\r\n        } else if (field.equals(NullTypes.FIELD_BYTE_NULL) || field.equals(NullTypes.FIELD_SHORT_NULL) || field.equals(NullTypes.FIELD_INTEGER_NULL) || field.equals(NullTypes.FIELD_LONG_NULL)) {\r\n            nullTypesSchema.addField(field, int.class);\r\n        } else if (field.equals(NullTypes.FIELD_FLOAT_NULL)) {\r\n            nullTypesSchema.addField(field, float.class);\r\n        } else if (field.equals(NullTypes.FIELD_DOUBLE_NULL)) {\r\n            nullTypesSchema.addField(field, double.class);\r\n        } else if (field.equals(NullTypes.FIELD_DATE_NULL)) {\r\n            nullTypesSchema.addField(field, Date.class, FieldAttribute.REQUIRED);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.facebook.presto.spi.type.UnscaledDecimal128Arithmetic.addUnsignedReturnOverflow",
	"Comment": "this method ignores signs of the left and right. returns overflow value.",
	"Method": "long addUnsignedReturnOverflow(Slice left,Slice right,Slice result,boolean resultNegative){\r\n    int l0 = getInt(left, 0);\r\n    int l1 = getInt(left, 1);\r\n    int l2 = getInt(left, 2);\r\n    int l3 = getInt(left, 3);\r\n    int r0 = getInt(right, 0);\r\n    int r1 = getInt(right, 1);\r\n    int r2 = getInt(right, 2);\r\n    int r3 = getInt(right, 3);\r\n    long intermediateResult;\r\n    intermediateResult = (l0 & LONG_MASK) + (r0 & LONG_MASK);\r\n    int z0 = (int) intermediateResult;\r\n    intermediateResult = (l1 & LONG_MASK) + (r1 & LONG_MASK) + (intermediateResult >>> 32);\r\n    int z1 = (int) intermediateResult;\r\n    intermediateResult = (l2 & LONG_MASK) + (r2 & LONG_MASK) + (intermediateResult >>> 32);\r\n    int z2 = (int) intermediateResult;\r\n    intermediateResult = (l3 & LONG_MASK) + (r3 & LONG_MASK) + (intermediateResult >>> 32);\r\n    int z3 = (int) intermediateResult & (~SIGN_INT_MASK);\r\n    pack(result, z0, z1, z2, z3, resultNegative);\r\n    return intermediateResult >> 31;\r\n}"
}, {
	"Path": "io.realm.RealmQueryTests.isNotNull_listFieldThrows",
	"Comment": "calling isnotnull on fields with the realmlist type will trigger an exception.",
	"Method": "void isNotNull_listFieldThrows(){\r\n    try {\r\n        realm.where(Owner.class).isNotNull(\"dogs\");\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n        assertEquals(\"Illegal Argument: RealmList(dogs) is not nullable.\", expected.getMessage());\r\n    }\r\n    try {\r\n        realm.where(Cat.class).isNotNull(\"owner.dogs\");\r\n        fail();\r\n    } catch (IllegalArgumentException expected) {\r\n        assertEquals(\"Illegal Argument: RealmList(dogs) is not nullable.\", expected.getMessage());\r\n    }\r\n}"
}, {
	"Path": "io.realm.SyncManager.setAuthServerImpl",
	"Comment": "sets the auth server implementation used when validating credentials.",
	"Method": "void setAuthServerImpl(AuthenticationServer authServerImpl){\r\n    authServer = authServerImpl;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.block.BlockBuilder.beginBlockEntry",
	"Comment": "return a writer to the current entry. the caller can operate on the returned caller to incrementally build the object. this is generally more efficient thanbuilding the object elsewhere and call writeobject afterwards because a large chunk of memory could potentially be unnecessarily copied in this process.",
	"Method": "BlockBuilder beginBlockEntry(){\r\n    throw new UnsupportedOperationException(getClass().getName());\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.modifyPrimaryKeyFieldTypeToIntegerInMigration",
	"Comment": "this is to test how pk type can change to nullable integer in migration.",
	"Method": "void modifyPrimaryKeyFieldTypeToIntegerInMigration(){\r\n    final String TEMP_FIELD_ID = \"temp_id\";\r\n    buildInitialMigrationSchema(MigrationFieldTypeToInteger.CLASS_NAME, false);\r\n    createObjectsWithOldPrimaryKey(MigrationFieldTypeToInteger.CLASS_NAME, true);\r\n    RealmMigration migration = new RealmMigration() {\r\n        @Override\r\n        public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {\r\n            realm.getSchema().get(MigrationFieldTypeToInteger.CLASS_NAME).addField(\"temp_id\", Integer.class).transform(new RealmObjectSchema.Function() {\r\n                @Override\r\n                public void apply(DynamicRealmObject obj) {\r\n                    String fieldValue = obj.getString(MigrationPrimaryKey.FIELD_PRIMARY);\r\n                    if (fieldValue != null && fieldValue.length() != 0) {\r\n                        obj.setInt(TEMP_FIELD_ID, Integer.valueOf(fieldValue));\r\n                    } else {\r\n                        obj.setNull(TEMP_FIELD_ID);\r\n                    }\r\n                }\r\n            }).removeField(MigrationPrimaryKey.FIELD_PRIMARY).renameField(TEMP_FIELD_ID, MigrationFieldTypeToInteger.FIELD_PRIMARY).addPrimaryKey(MigrationFieldTypeToInteger.FIELD_PRIMARY);\r\n        }\r\n    };\r\n    RealmConfiguration realmConfig = configFactory.createConfigurationBuilder().schemaVersion(1).schema(MigrationFieldTypeToInteger.class).migration(migration).build();\r\n    Realm realm = Realm.getInstance(realmConfig);\r\n    Table table = realm.getSchema().getTable(MigrationFieldTypeToInteger.class);\r\n    assertEquals(MigrationFieldTypeToInteger.DEFAULT_FIELDS_COUNT, table.getColumnCount());\r\n    assertPKField(realm, MigrationFieldTypeToInteger.CLASS_NAME, MigrationFieldTypeToInteger.FIELD_PRIMARY, MigrationFieldTypeToInteger.DEFAULT_PRIMARY_INDEX);\r\n    assertEquals(2, realm.where(MigrationFieldTypeToInteger.class).count());\r\n    assertEquals(1, realm.where(MigrationFieldTypeToInteger.class).equalTo(MigrationFieldTypeToInteger.FIELD_PRIMARY, Integer.valueOf(12)).count());\r\n    assertEquals(1, realm.where(MigrationFieldTypeToInteger.class).equalTo(MigrationFieldTypeToInteger.FIELD_PRIMARY, (Integer) null).count());\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.modifyPrimaryKeyFieldTypeToIntegerInMigration",
	"Comment": "this is to test how pk type can change to nullable integer in migration.",
	"Method": "void modifyPrimaryKeyFieldTypeToIntegerInMigration(){\r\n    realm.getSchema().get(MigrationFieldTypeToInteger.CLASS_NAME).addField(\"temp_id\", Integer.class).transform(new RealmObjectSchema.Function() {\r\n        @Override\r\n        public void apply(DynamicRealmObject obj) {\r\n            String fieldValue = obj.getString(MigrationPrimaryKey.FIELD_PRIMARY);\r\n            if (fieldValue != null && fieldValue.length() != 0) {\r\n                obj.setInt(TEMP_FIELD_ID, Integer.valueOf(fieldValue));\r\n            } else {\r\n                obj.setNull(TEMP_FIELD_ID);\r\n            }\r\n        }\r\n    }).removeField(MigrationPrimaryKey.FIELD_PRIMARY).renameField(TEMP_FIELD_ID, MigrationFieldTypeToInteger.FIELD_PRIMARY).addPrimaryKey(MigrationFieldTypeToInteger.FIELD_PRIMARY);\r\n}"
}, {
	"Path": "io.realm.RealmMigrationTests.modifyPrimaryKeyFieldTypeToIntegerInMigration",
	"Comment": "this is to test how pk type can change to nullable integer in migration.",
	"Method": "void modifyPrimaryKeyFieldTypeToIntegerInMigration(){\r\n    String fieldValue = obj.getString(MigrationPrimaryKey.FIELD_PRIMARY);\r\n    if (fieldValue != null && fieldValue.length() != 0) {\r\n        obj.setInt(TEMP_FIELD_ID, Integer.valueOf(fieldValue));\r\n    } else {\r\n        obj.setNull(TEMP_FIELD_ID);\r\n    }\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_notSentAfterUnregisterListenerRealmResults",
	"Comment": "a listener registered on the backlinked field should not be called after the listener is removed",
	"Method": "void notification_notSentAfterUnregisterListenerRealmResults(){\r\n    final Realm looperThreadRealm = looperThread.getRealm();\r\n    looperThreadRealm.beginTransaction();\r\n    AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);\r\n    looperThreadRealm.commitTransaction();\r\n    RealmChangeListener<RealmResults<AllJavaTypes>> listener = new RealmChangeListener<RealmResults<AllJavaTypes>>() {\r\n        @Override\r\n        public void onChange(RealmResults<AllJavaTypes> object) {\r\n            fail(\"Not expecting notification after unregister\");\r\n        }\r\n    };\r\n    RealmResults<AllJavaTypes> objParents = child.getObjectParents();\r\n    objParents.addChangeListener(listener);\r\n    objParents.removeChangeListener(listener);\r\n    looperThreadRealm.beginTransaction();\r\n    AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);\r\n    parent.setFieldObject(child);\r\n    looperThreadRealm.commitTransaction();\r\n    verifyPostConditions(looperThreadRealm, new PostConditions() {\r\n        @Override\r\n        public void run(Realm realm) {\r\n            assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());\r\n        }\r\n    }, child, parent);\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_notSentAfterUnregisterListenerRealmResults",
	"Comment": "a listener registered on the backlinked field should not be called after the listener is removed",
	"Method": "void notification_notSentAfterUnregisterListenerRealmResults(){\r\n    fail(\"Not expecting notification after unregister\");\r\n}"
}, {
	"Path": "io.realm.LinkingObjectsManagedTests.notification_notSentAfterUnregisterListenerRealmResults",
	"Comment": "a listener registered on the backlinked field should not be called after the listener is removed",
	"Method": "void notification_notSentAfterUnregisterListenerRealmResults(){\r\n    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanDropTable",
	"Comment": "check if identity is allowed to drop the specified table in this catalog.",
	"Method": "void checkCanDropTable(ConnectorTransactionHandle transactionHandle,Identity identity,SchemaTableName tableName){\r\n    denyDropTable(tableName.toString());\r\n}"
}, {
	"Path": "com.facebook.presto.spi.block.RowBlock.fromFieldBlocks",
	"Comment": "create a row block directly from columnar nulls and field blocks.",
	"Method": "Block fromFieldBlocks(int positionCount,Optional<boolean[]> rowIsNull,Block[] fieldBlocks){\r\n    int[] fieldBlockOffsets = new int[positionCount + 1];\r\n    for (int position = 0; position < positionCount; position++) {\r\n        fieldBlockOffsets[position + 1] = fieldBlockOffsets[position] + (rowIsNull.isPresent() && rowIsNull.get()[position] ? 0 : 1);\r\n    }\r\n    validateConstructorArguments(0, positionCount, rowIsNull.orElse(null), fieldBlockOffsets, fieldBlocks);\r\n    return new RowBlock(0, positionCount, rowIsNull.orElse(null), fieldBlockOffsets, fieldBlocks);\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.getRestDisplacementThreshold",
	"Comment": "get the threshold of displacement from rest below which the spring should be considered at rest",
	"Method": "double getRestDisplacementThreshold(){\r\n    return mDisplacementFromRestThreshold;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanCreateView",
	"Comment": "check if identity is allowed to create the specified view in a catalog.",
	"Method": "void checkCanCreateView(Identity identity,CatalogSchemaTableName view){\r\n    denyCreateView(view.toString());\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanDropColumn",
	"Comment": "check if identity is allowed to drop columns from the specified table in this catalog.",
	"Method": "void checkCanDropColumn(ConnectorTransactionHandle transactionHandle,Identity identity,SchemaTableName tableName){\r\n    denyDropColumn(tableName.toString());\r\n}"
}, {
	"Path": "com.facebook.presto.memory.TestMemoryTracking.assertOperatorMemoryAllocations",
	"Comment": "the allocations that are done at the operator level are reflected at that level and all the way up to the pools",
	"Method": "void assertOperatorMemoryAllocations(MemoryTrackingContext memoryTrackingContext,long expectedUserMemory,long expectedSystemMemory,long expectedRevocableMemory){\r\n    assertEquals(memoryTrackingContext.getUserMemory(), expectedUserMemory, \"User memory verification failed\");\r\n    assertEquals(memoryPool.getReservedBytes(), expectedUserMemory + expectedSystemMemory, \"Memory pool verification failed\");\r\n    assertEquals(memoryTrackingContext.getSystemMemory(), expectedSystemMemory, \"System memory verification failed\");\r\n    assertEquals(memoryTrackingContext.getRevocableMemory(), expectedRevocableMemory, \"Revocable memory verification failed\");\r\n}"
}, {
	"Path": "com.facebook.rebound.playground.examples.scrollview.SpringScrollView.executeKeyEvent",
	"Comment": "you can call this function yourself to have the scroll view performscrolling from a key event, just as if the event had been dispatched toit by the view hierarchy.",
	"Method": "boolean executeKeyEvent(KeyEvent event){\r\n    mTempRect.setEmpty();\r\n    if (!canScroll()) {\r\n        if (isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK) {\r\n            View currentFocused = findFocus();\r\n            if (currentFocused == this)\r\n                currentFocused = null;\r\n            View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, View.FOCUS_DOWN);\r\n            return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);\r\n        }\r\n        return false;\r\n    }\r\n    boolean handled = false;\r\n    if (event.getAction() == KeyEvent.ACTION_DOWN) {\r\n        switch(event.getKeyCode()) {\r\n            case KeyEvent.KEYCODE_DPAD_UP:\r\n                if (!event.isAltPressed()) {\r\n                    handled = arrowScroll(View.FOCUS_UP);\r\n                } else {\r\n                    handled = fullScroll(View.FOCUS_UP);\r\n                }\r\n                break;\r\n            case KeyEvent.KEYCODE_DPAD_DOWN:\r\n                if (!event.isAltPressed()) {\r\n                    handled = arrowScroll(View.FOCUS_DOWN);\r\n                } else {\r\n                    handled = fullScroll(View.FOCUS_DOWN);\r\n                }\r\n                break;\r\n            case KeyEvent.KEYCODE_SPACE:\r\n                pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);\r\n                break;\r\n        }\r\n    }\r\n    return handled;\r\n}"
}, {
	"Path": "io.realm.SyncManager.notifyConnectionListeners",
	"Comment": "called from native code. this method is not allowed to throw as it would be swallowedby the native sync client thread. instead log all exceptions to logcat.",
	"Method": "void notifyConnectionListeners(String localRealmPath,long oldState,long newState){\r\n    SyncSession session = sessions.get(localRealmPath);\r\n    if (session != null) {\r\n        try {\r\n            session.notifyConnectionListeners(ConnectionState.fromNativeValue(oldState), ConnectionState.fromNativeValue(newState));\r\n        } catch (Exception exception) {\r\n            RealmLog.error(exception);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmResultsTests.accessors_resultsBuiltOnDeletedLinkView_deletionAsALocalCommit",
	"Comment": "4. the results change listener called, the results becomes empty.",
	"Method": "void accessors_resultsBuiltOnDeletedLinkView_deletionAsALocalCommit(){\r\n    Realm realm = looperThread.getRealm();\r\n    RealmResults<Dog> dogs = populateRealmResultsOnLinkView(realm);\r\n    looperThread.keepStrongReference(dogs);\r\n    dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {\r\n        @Override\r\n        public void onChange(RealmResults<Dog> dogs) {\r\n            assertEquals(true, dogs.isValid());\r\n            assertEquals(true, dogs.isEmpty());\r\n            assertEquals(0, dogs.size());\r\n            try {\r\n                dogs.first();\r\n                fail();\r\n            } catch (IndexOutOfBoundsException ignored) {\r\n            }\r\n            assertEquals(0, dogs.sum(Dog.FIELD_AGE).intValue());\r\n            assertEquals(0f, dogs.sum(Dog.FIELD_HEIGHT).floatValue(), 0f);\r\n            assertEquals(0d, dogs.sum(Dog.FIELD_WEIGHT).doubleValue(), 0d);\r\n            assertEquals(0d, dogs.average(Dog.FIELD_AGE), 0d);\r\n            assertEquals(0d, dogs.average(Dog.FIELD_HEIGHT), 0d);\r\n            assertEquals(0d, dogs.average(Dog.FIELD_WEIGHT), 0d);\r\n            assertEquals(null, dogs.min(Dog.FIELD_AGE));\r\n            assertEquals(null, dogs.max(Dog.FIELD_AGE));\r\n            assertEquals(null, dogs.minDate(Dog.FIELD_BIRTHDAY));\r\n            assertEquals(null, dogs.maxDate(Dog.FIELD_BIRTHDAY));\r\n            assertEquals(0, dogs.where().findAll().size());\r\n            looperThread.testComplete();\r\n        }\r\n    });\r\n    realm.executeTransaction(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            realm.where(Owner.class).findAll().deleteAllFromRealm();\r\n        }\r\n    });\r\n    assertEquals(true, dogs.isValid());\r\n    assertEquals(0, dogs.size());\r\n    assertEquals(0, dogs.where().findAll().size());\r\n}"
}, {
	"Path": "io.realm.RealmResultsTests.accessors_resultsBuiltOnDeletedLinkView_deletionAsALocalCommit",
	"Comment": "4. the results change listener called, the results becomes empty.",
	"Method": "void accessors_resultsBuiltOnDeletedLinkView_deletionAsALocalCommit(){\r\n    assertEquals(true, dogs.isValid());\r\n    assertEquals(true, dogs.isEmpty());\r\n    assertEquals(0, dogs.size());\r\n    try {\r\n        dogs.first();\r\n        fail();\r\n    } catch (IndexOutOfBoundsException ignored) {\r\n    }\r\n    assertEquals(0, dogs.sum(Dog.FIELD_AGE).intValue());\r\n    assertEquals(0f, dogs.sum(Dog.FIELD_HEIGHT).floatValue(), 0f);\r\n    assertEquals(0d, dogs.sum(Dog.FIELD_WEIGHT).doubleValue(), 0d);\r\n    assertEquals(0d, dogs.average(Dog.FIELD_AGE), 0d);\r\n    assertEquals(0d, dogs.average(Dog.FIELD_HEIGHT), 0d);\r\n    assertEquals(0d, dogs.average(Dog.FIELD_WEIGHT), 0d);\r\n    assertEquals(null, dogs.min(Dog.FIELD_AGE));\r\n    assertEquals(null, dogs.max(Dog.FIELD_AGE));\r\n    assertEquals(null, dogs.minDate(Dog.FIELD_BIRTHDAY));\r\n    assertEquals(null, dogs.maxDate(Dog.FIELD_BIRTHDAY));\r\n    assertEquals(0, dogs.where().findAll().size());\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "io.realm.RealmResultsTests.accessors_resultsBuiltOnDeletedLinkView_deletionAsALocalCommit",
	"Comment": "4. the results change listener called, the results becomes empty.",
	"Method": "void accessors_resultsBuiltOnDeletedLinkView_deletionAsALocalCommit(){\r\n    realm.where(Owner.class).findAll().deleteAllFromRealm();\r\n}"
}, {
	"Path": "io.realm.internal.objectstore.OsObjectBuilder.createNewObject",
	"Comment": "create a new object.the builder is automatically closed after calling this method.",
	"Method": "UncheckedRow createNewObject(){\r\n    UncheckedRow row;\r\n    try {\r\n        long rowPtr = nativeCreateOrUpdate(sharedRealmPtr, tablePtr, builderPtr, false, false);\r\n        row = new UncheckedRow(context, table, rowPtr);\r\n    } finally {\r\n        close();\r\n    }\r\n    return row;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanRevokeTablePrivilege",
	"Comment": "check if identity is allowed to revoke the specified privilege on the specified table from the revokee.",
	"Method": "void checkCanRevokeTablePrivilege(Identity identity,Privilege privilege,CatalogSchemaTableName table,String revokee,boolean grantOptionFor){\r\n    denyRevokeTablePrivilege(privilege.toString(), table.toString());\r\n}"
}, {
	"Path": "io.realm.internal.TableIndexAndDistinctTest.shouldTestSettingIndexOnMultipleColumns",
	"Comment": "checks that index can be set on multiple columns, with the string.",
	"Method": "void shouldTestSettingIndexOnMultipleColumns(){\r\n    Table t = TestHelper.createTable(sharedRealm, \"temp\", new TestHelper.AdditionalTableSetup() {\r\n        @Override\r\n        public void execute(Table t) {\r\n            t.addColumn(RealmFieldType.STRING, \"col1\");\r\n            t.addColumn(RealmFieldType.STRING, \"col2\");\r\n            t.addColumn(RealmFieldType.STRING, \"col3\");\r\n            t.addColumn(RealmFieldType.STRING, \"col4\");\r\n            t.addColumn(RealmFieldType.STRING, \"col5\");\r\n            TestHelper.addRowWithValues(t, \"row1\", \"row2\", \"row3\", \"row4\", \"row5\");\r\n            TestHelper.addRowWithValues(t, \"row1\", \"row2\", \"row3\", \"row4\", \"row5\");\r\n            TestHelper.addRowWithValues(t, \"row1\", \"row2\", \"row3\", \"row4\", \"row5\");\r\n            TestHelper.addRowWithValues(t, \"row1\", \"row2\", \"row3\", \"row4\", \"row5\");\r\n            TestHelper.addRowWithValues(t, \"row1\", \"row2\", \"row3\", \"row4\", \"row5\");\r\n        }\r\n    });\r\n    for (long c = 0; c < t.getColumnCount(); c++) {\r\n        t.addSearchIndex(c);\r\n        assertEquals(true, t.hasSearchIndex(c));\r\n    }\r\n}"
}, {
	"Path": "io.realm.internal.TableIndexAndDistinctTest.shouldTestSettingIndexOnMultipleColumns",
	"Comment": "checks that index can be set on multiple columns, with the string.",
	"Method": "void shouldTestSettingIndexOnMultipleColumns(){\r\n    t.addColumn(RealmFieldType.STRING, \"col1\");\r\n    t.addColumn(RealmFieldType.STRING, \"col2\");\r\n    t.addColumn(RealmFieldType.STRING, \"col3\");\r\n    t.addColumn(RealmFieldType.STRING, \"col4\");\r\n    t.addColumn(RealmFieldType.STRING, \"col5\");\r\n    TestHelper.addRowWithValues(t, \"row1\", \"row2\", \"row3\", \"row4\", \"row5\");\r\n    TestHelper.addRowWithValues(t, \"row1\", \"row2\", \"row3\", \"row4\", \"row5\");\r\n    TestHelper.addRowWithValues(t, \"row1\", \"row2\", \"row3\", \"row4\", \"row5\");\r\n    TestHelper.addRowWithValues(t, \"row1\", \"row2\", \"row3\", \"row4\", \"row5\");\r\n    TestHelper.addRowWithValues(t, \"row1\", \"row2\", \"row3\", \"row4\", \"row5\");\r\n}"
}, {
	"Path": "io.realm.RealmCacheTests.typedRealmAndDynamicRealmShareTheSameCache",
	"Comment": "the dynamicrealm and realm with the same realm path should share the same realmcache",
	"Method": "void typedRealmAndDynamicRealmShareTheSameCache(){\r\n    final String DB_NAME = \"same_name.realm\";\r\n    RealmConfiguration config1 = configFactory.createConfigurationBuilder().name(DB_NAME).build();\r\n    RealmConfiguration config2 = configFactory.createConfigurationBuilder().name(DB_NAME).initialData(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            fail();\r\n        }\r\n    }).build();\r\n    DynamicRealm dynamicRealm = DynamicRealm.getInstance(config1);\r\n    Realm realm = null;\r\n    try {\r\n        realm = Realm.getInstance(config2);\r\n        fail();\r\n    } catch (IllegalArgumentException ignored) {\r\n    } finally {\r\n        dynamicRealm.close();\r\n        if (realm != null) {\r\n            realm.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.RealmCacheTests.typedRealmAndDynamicRealmShareTheSameCache",
	"Comment": "the dynamicrealm and realm with the same realm path should share the same realmcache",
	"Method": "void typedRealmAndDynamicRealmShareTheSameCache(){\r\n    fail();\r\n}"
}, {
	"Path": "io.realm.RealmTests.copyToRealmOrUpdate_referencesNotDeleted",
	"Comment": "tests that if references to objects are removed, the objects are still in the realm.",
	"Method": "void copyToRealmOrUpdate_referencesNotDeleted(){\r\n    realm.executeTransaction(new Realm.Transaction() {\r\n        @Override\r\n        public void execute(Realm realm) {\r\n            AllTypesPrimaryKey obj = new AllTypesPrimaryKey();\r\n            obj.setColumnLong(1);\r\n            obj.setColumnRealmObject(new DogPrimaryKey(1, \"Dog1\"));\r\n            obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, \"Dog2\")));\r\n            realm.copyToRealm(obj);\r\n            AllTypesPrimaryKey obj2 = new AllTypesPrimaryKey();\r\n            obj2.setColumnLong(1);\r\n            obj2.setColumnRealmObject(new DogPrimaryKey(3, \"Dog3\"));\r\n            obj2.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(4, \"Dog4\")));\r\n            realm.copyToRealmOrUpdate(obj2);\r\n        }\r\n    });\r\n    assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());\r\n    assertEquals(4, realm.where(DogPrimaryKey.class).count());\r\n}"
}, {
	"Path": "io.realm.RealmTests.copyToRealmOrUpdate_referencesNotDeleted",
	"Comment": "tests that if references to objects are removed, the objects are still in the realm.",
	"Method": "void copyToRealmOrUpdate_referencesNotDeleted(){\r\n    AllTypesPrimaryKey obj = new AllTypesPrimaryKey();\r\n    obj.setColumnLong(1);\r\n    obj.setColumnRealmObject(new DogPrimaryKey(1, \"Dog1\"));\r\n    obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, \"Dog2\")));\r\n    realm.copyToRealm(obj);\r\n    AllTypesPrimaryKey obj2 = new AllTypesPrimaryKey();\r\n    obj2.setColumnLong(1);\r\n    obj2.setColumnRealmObject(new DogPrimaryKey(3, \"Dog3\"));\r\n    obj2.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(4, \"Dog4\")));\r\n    realm.copyToRealmOrUpdate(obj2);\r\n}"
}, {
	"Path": "io.realm.TestHelper.exitOrThrow",
	"Comment": "cleans resource, shutdowns the executor service and throws any background exception.",
	"Method": "void exitOrThrow(ExecutorService executorService,CountDownLatch testFinishedSignal,LooperTest test){\r\n    try {\r\n        TestHelper.awaitOrFail(testFinishedSignal);\r\n    } finally {\r\n        Looper looper = test.getLooper();\r\n        if (looper != null) {\r\n            looper.quit();\r\n        }\r\n        executorService.shutdownNow();\r\n        Throwable fault = test.getAssertionError();\r\n        if (fault != null) {\r\n            throw fault;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.realm.Realm.where",
	"Comment": "returns a typed realmquery, which can be used to query for specific objects of this type",
	"Method": "RealmQuery<E> where(Class<E> clazz){\r\n    checkIfValid();\r\n    return RealmQuery.createQuery(this, clazz);\r\n}"
}, {
	"Path": "io.realm.internal.TableQuery.find",
	"Comment": "returns the table row index for the first element matching the query.",
	"Method": "long find(long fromTableRow,long find){\r\n    validateQuery();\r\n    return nativeFind(nativePtr, 0);\r\n}"
}, {
	"Path": "com.facebook.presto.orc.metadata.statistics.StringStatisticsBuilder.addStringStatistics",
	"Comment": "this method can only be used in merging stats.it assumes min or max could be nulls.",
	"Method": "void addStringStatistics(long valueCount,StringStatistics value){\r\n    requireNonNull(value, \"value is null\");\r\n    checkArgument(valueCount > 0, \"valueCount is 0\");\r\n    checkArgument(value.getMin() != null || value.getMax() != null, \"min and max cannot both be null\");\r\n    if (nonNullValueCount == 0) {\r\n        checkState(minimum == null && maximum == null);\r\n        minimum = value.getMin();\r\n        maximum = value.getMax();\r\n    } else {\r\n        if (minimum != null && (value.getMin() == null || minimum.compareTo(value.getMin()) > 0)) {\r\n            minimum = value.getMin();\r\n        }\r\n        if (maximum != null && (value.getMax() == null || maximum.compareTo(value.getMax()) < 0)) {\r\n            maximum = value.getMax();\r\n        }\r\n    }\r\n    nonNullValueCount += valueCount;\r\n    sum = addExact(sum, value.getSum());\r\n}"
}, {
	"Path": "io.realm.RealmListTests.add_unmanagedPrimaryKeyObjectToManagedList",
	"Comment": "makes sure that unmanaged objects with a primary key are added using copytorealmorupdate.",
	"Method": "void add_unmanagedPrimaryKeyObjectToManagedList(){\r\n    realm.beginTransaction();\r\n    realm.copyToRealm(new CyclicTypePrimaryKey(2, \"original\"));\r\n    RealmList<CyclicTypePrimaryKey> children = realm.copyToRealm(new CyclicTypePrimaryKey(1)).getObjects();\r\n    children.add(new CyclicTypePrimaryKey(2, \"new\"));\r\n    realm.commitTransaction();\r\n    assertEquals(1, realm.where(CyclicTypePrimaryKey.class).equalTo(\"id\", 1).findFirst().getObjects().size());\r\n    assertEquals(\"new\", realm.where(CyclicTypePrimaryKey.class).equalTo(\"id\", 2).findFirst().getName());\r\n}"
}, {
	"Path": "com.facebook.presto.spi.security.SystemAccessControl.checkCanAccessCatalog",
	"Comment": "check if identity is allowed to access the specified catalog",
	"Method": "void checkCanAccessCatalog(Identity identity,String catalogName){\r\n    denyCatalogAccess(catalogName);\r\n}"
}, {
	"Path": "com.facebook.presto.spi.connector.ConnectorAccessControl.checkCanDeleteFromTable",
	"Comment": "check if identity is allowed to delete from the specified table in this catalog.",
	"Method": "void checkCanDeleteFromTable(ConnectorTransactionHandle transactionHandle,Identity identity,SchemaTableName tableName){\r\n    denyDeleteTable(tableName.toString());\r\n}"
}, {
	"Path": "io.realm.RealmConfigurationTests.inMemory_differentDurabilityThrows",
	"Comment": "creates realm instances with same name but different durabilities is not allowed.",
	"Method": "void inMemory_differentDurabilityThrows(){\r\n    RealmConfiguration config1 = configFactory.createConfigurationBuilder().directory(configFactory.getRoot()).inMemory().build();\r\n    RealmConfiguration config2 = configFactory.createConfigurationBuilder().directory(configFactory.getRoot()).build();\r\n    Realm realm1 = Realm.getInstance(config1);\r\n    try {\r\n        Realm.getInstance(config2);\r\n        fail();\r\n    } catch (IllegalArgumentException ignored) {\r\n    } finally {\r\n        realm1.close();\r\n    }\r\n    realm1 = Realm.getInstance(config2);\r\n    try {\r\n        Realm.getInstance(config1);\r\n        fail();\r\n    } catch (IllegalArgumentException ignored) {\r\n    } finally {\r\n        realm1.close();\r\n    }\r\n}"
}, {
	"Path": "org.redisson.config.BaseConfig.setIdleConnectionTimeout",
	"Comment": "if pooled connection not used for a timeout timeand current connections amount bigger than minimum idle connections pool size,then it will closed and removed from pool.",
	"Method": "T setIdleConnectionTimeout(int idleConnectionTimeout){\r\n    this.idleConnectionTimeout = idleConnectionTimeout;\r\n    return (T) this;\r\n}"
}, {
	"Path": "com.facebook.presto.spi.predicate.SortedRangeSet.of",
	"Comment": "provided ranges are unioned together to form the sortedrangeset",
	"Method": "SortedRangeSet of(Type type,Object first,Object rest,SortedRangeSet of,Range first,Range rest){\r\n    List<Range> rangeList = new ArrayList(rest.length + 1);\r\n    rangeList.add(first);\r\n    for (Range range : rest) {\r\n        rangeList.add(range);\r\n    }\r\n    return copyOf(first.getType(), rangeList);\r\n}"
}, {
	"Path": "com.facebook.presto.sql.planner.optimizations.LocalProperties.normalize",
	"Comment": "normalizes the local properties by removing redundant symbols, but retains the original local property positions",
	"Method": "List<Optional<LocalProperty<T>>> normalize(List<? extends LocalProperty<T>> localProperties){\r\n    List<Optional<LocalProperty<T>>> normalizedProperties = new ArrayList(localProperties.size());\r\n    Set<T> constants = new HashSet();\r\n    for (LocalProperty<T> localProperty : localProperties) {\r\n        normalizedProperties.add(localProperty.withConstants(constants));\r\n        constants.addAll(localProperty.getColumns());\r\n    }\r\n    return normalizedProperties;\r\n}"
}, {
	"Path": "io.realm.internal.RealmNotifierTests.addChangeListener_byLocalChanges",
	"Comment": "callback is immediately called when committransaction for local changes.",
	"Method": "void addChangeListener_byLocalChanges(){\r\n    final AtomicBoolean commitReturns = new AtomicBoolean(false);\r\n    OsSharedRealm sharedRealm = getSharedRealm(looperThread.getConfiguration());\r\n    sharedRealm.realmNotifier.addChangeListener(sharedRealm, new RealmChangeListener<OsSharedRealm>() {\r\n        @Override\r\n        public void onChange(OsSharedRealm sharedRealm) {\r\n            assertFalse(commitReturns.get());\r\n            sharedRealm.close();\r\n            looperThread.testComplete();\r\n        }\r\n    });\r\n    sharedRealm.beginTransaction();\r\n    sharedRealm.commitTransaction();\r\n    commitReturns.set(true);\r\n}"
}, {
	"Path": "io.realm.internal.RealmNotifierTests.addChangeListener_byLocalChanges",
	"Comment": "callback is immediately called when committransaction for local changes.",
	"Method": "void addChangeListener_byLocalChanges(){\r\n    assertFalse(commitReturns.get());\r\n    sharedRealm.close();\r\n    looperThread.testComplete();\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.wasAtRest",
	"Comment": "check if the spring was at rest in the prior iteration. this is used for ensuring the endingcallbacks are fired as the spring comes to a rest.",
	"Method": "boolean wasAtRest(){\r\n    return mWasAtRest;\r\n}"
}]