[{
	"Path": "org.robolectric.res.android.NativeObjRegistry.getNativeObjectId",
	"Comment": "retrieve the native id for given object. assigns a new unique id to the object if notpreviously registered.",
	"Method": "long getNativeObjectId(T o){\r\n    checkNotNull(o);\r\n    Long nativeId = nativeObjToIdMap.inverse().get(o);\r\n    if (nativeId == null) {\r\n        nativeId = nextId;\r\n        if (debug) {\r\n            System.out.printf(\"NativeObjRegistry %s: register %d -> %s%n\", name, nativeId, o);\r\n        }\r\n        nativeObjToIdMap.put(nativeId, o);\r\n        nextId++;\r\n    }\r\n    return nativeId;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.frameToBeAvailableAndSwitchToIt",
	"Comment": "an expectation for checking whether the given frame is available to switch to.if the frameis available it switches the given driver to the specified webelement.",
	"Method": "ExpectedCondition<WebDriver> frameToBeAvailableAndSwitchToIt(String frameLocator,ExpectedCondition<WebDriver> frameToBeAvailableAndSwitchToIt,By locator,ExpectedCondition<WebDriver> frameToBeAvailableAndSwitchToIt,int frameLocator,ExpectedCondition<WebDriver> frameToBeAvailableAndSwitchToIt,WebElement frameLocator){\r\n    return new ExpectedCondition<WebDriver>() {\r\n        @Override\r\n        public WebDriver apply(WebDriver driver) {\r\n            try {\r\n                return driver.switchTo().frame(frameLocator);\r\n            } catch (NoSuchFrameException e) {\r\n                return null;\r\n            }\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"frame to be available: \" + frameLocator;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.frameToBeAvailableAndSwitchToIt",
	"Comment": "an expectation for checking whether the given frame is available to switch to.if the frameis available it switches the given driver to the specified webelement.",
	"Method": "ExpectedCondition<WebDriver> frameToBeAvailableAndSwitchToIt(String frameLocator,ExpectedCondition<WebDriver> frameToBeAvailableAndSwitchToIt,By locator,ExpectedCondition<WebDriver> frameToBeAvailableAndSwitchToIt,int frameLocator,ExpectedCondition<WebDriver> frameToBeAvailableAndSwitchToIt,WebElement frameLocator){\r\n    try {\r\n        return driver.switchTo().frame(frameLocator);\r\n    } catch (NoSuchFrameException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.frameToBeAvailableAndSwitchToIt",
	"Comment": "an expectation for checking whether the given frame is available to switch to.if the frameis available it switches the given driver to the specified webelement.",
	"Method": "ExpectedCondition<WebDriver> frameToBeAvailableAndSwitchToIt(String frameLocator,ExpectedCondition<WebDriver> frameToBeAvailableAndSwitchToIt,By locator,ExpectedCondition<WebDriver> frameToBeAvailableAndSwitchToIt,int frameLocator,ExpectedCondition<WebDriver> frameToBeAvailableAndSwitchToIt,WebElement frameLocator){\r\n    return \"frame to be available: \" + frameLocator;\r\n}"
}, {
	"Path": "io.reactivex.processors.UnicastProcessor.create",
	"Comment": "creates an unicastprocessor with the given internal buffer capacity hint.",
	"Method": "UnicastProcessor<T> create(UnicastProcessor<T> create,int capacityHint,UnicastProcessor<T> create,boolean delayError,UnicastProcessor<T> create,int capacityHint,Runnable onCancelled,UnicastProcessor<T> create,int capacityHint,Runnable onCancelled,boolean delayError){\r\n    ObjectHelper.requireNonNull(onCancelled, \"onTerminate\");\r\n    return new UnicastProcessor<T>(capacityHint, onCancelled, delayError);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowDropBoxManagerTest.dataNotExpected_timestampSameAsEntry",
	"Comment": "checks that we retrieve the first entry after the specified time.",
	"Method": "void dataNotExpected_timestampSameAsEntry(){\r\n    shadowDropBoxManager.addData(TAG, 1, DATA);\r\n    assertThat(manager.getNextEntry(null, 1)).isNull();\r\n}"
}, {
	"Path": "org.openqa.selenium.safari.SafariOptions.setUseTechnologyPreview",
	"Comment": "instruct the safaridriver to use the safari technology preview if true, otherwise use therelease version of safari. defaults to using the release version of safari.",
	"Method": "SafariOptions setUseTechnologyPreview(boolean useTechnologyPreview){\r\n    options.put(Option.TECHNOLOGY_PREVIEW, useTechnologyPreview);\r\n    super.setCapability(BROWSER_NAME, useTechnologyPreview ? SAFARI_TECH_PREVIEW : \"safari\");\r\n    return this;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableReplay.create",
	"Comment": "creates a operatorreplay instance to replay values of the given source observable.",
	"Method": "ConnectableFlowable<T> create(Flowable<T> source,int bufferSize,ConnectableFlowable<T> create,Flowable<T> source,long maxAge,TimeUnit unit,Scheduler scheduler,ConnectableFlowable<T> create,Flowable<T> source,long maxAge,TimeUnit unit,Scheduler scheduler,int bufferSize,ConnectableFlowable<T> create,Flowable<T> source,Callable<? extends ReplayBuffer<T>> bufferFactory){\r\n    final AtomicReference<ReplaySubscriber<T>> curr = new AtomicReference<ReplaySubscriber<T>>();\r\n    Publisher<T> onSubscribe = new ReplayPublisher<T>(curr, bufferFactory);\r\n    return RxJavaPlugins.onAssembly(new FlowableReplay<T>(onSubscribe, source, curr, bufferFactory));\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.presenceOfNestedElementsLocatedBy",
	"Comment": "an expectation for checking child webelement as a part of parent element to present",
	"Method": "ExpectedCondition<List<WebElement>> presenceOfNestedElementsLocatedBy(By parent,By childLocator){\r\n    return new ExpectedCondition<List<WebElement>>() {\r\n        @Override\r\n        public List<WebElement> apply(WebDriver driver) {\r\n            List<WebElement> allChildren = driver.findElement(parent).findElements(childLocator);\r\n            return allChildren.isEmpty() ? null : allChildren;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"visibility of element located by %s -> %s\", parent, childLocator);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.presenceOfNestedElementsLocatedBy",
	"Comment": "an expectation for checking child webelement as a part of parent element to present",
	"Method": "ExpectedCondition<List<WebElement>> presenceOfNestedElementsLocatedBy(By parent,By childLocator){\r\n    List<WebElement> allChildren = driver.findElement(parent).findElements(childLocator);\r\n    return allChildren.isEmpty() ? null : allChildren;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.presenceOfNestedElementsLocatedBy",
	"Comment": "an expectation for checking child webelement as a part of parent element to present",
	"Method": "ExpectedCondition<List<WebElement>> presenceOfNestedElementsLocatedBy(By parent,By childLocator){\r\n    return String.format(\"visibility of element located by %s -> %s\", parent, childLocator);\r\n}"
}, {
	"Path": "org.robolectric.integration_tests.axt.IntentsTest.testIntendedSuccess_truth",
	"Comment": "variant of testintendedsuccess that uses truth apis.in this form the test verifies that only a single intent was sent.",
	"Method": "void testIntendedSuccess_truth(){\r\n    Intent i = new Intent();\r\n    i.setAction(Intent.ACTION_VIEW);\r\n    i.putExtra(\"ignoreextra\", \"\");\r\n    i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\r\n    getTargetContext().startActivity(i);\r\n    assertThat(Iterables.getOnlyElement(getIntents())).hasAction(Intent.ACTION_VIEW);\r\n}"
}, {
	"Path": "io.reactivex.subjects.MaybeSubject.getThrowable",
	"Comment": "returns the terminal error if this maybesubject has been terminated with an error, null otherwise.",
	"Method": "Throwable getThrowable(){\r\n    if (observers.get() == TERMINATED) {\r\n        return error;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.reactivex.observers.BaseTestConsumer.assertResult",
	"Comment": "assert that the upstream signalled the specified values in order andcompleted normally.",
	"Method": "U assertResult(T values){\r\n    return assertSubscribed().assertValues(values).assertNoErrors().assertComplete();\r\n}"
}, {
	"Path": "io.reactivex.processors.AsyncProcessor.add",
	"Comment": "tries to add the given subscriber to the subscribers array atomicallyor returns false if the processor has terminated.",
	"Method": "boolean add(AsyncSubscription<T> ps){\r\n    for (; ; ) {\r\n        AsyncSubscription<T>[] a = subscribers.get();\r\n        if (a == TERMINATED) {\r\n            return false;\r\n        }\r\n        int n = a.length;\r\n        @SuppressWarnings(\"unchecked\")\r\n        AsyncSubscription<T>[] b = new AsyncSubscription[n + 1];\r\n        System.arraycopy(a, 0, b, 0, n);\r\n        b[n] = ps;\r\n        if (subscribers.compareAndSet(a, b)) {\r\n            return true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.res.android.AttributeResolution9.ApkAssetsCookieToJavaCookie",
	"Comment": "java asset cookies have 0 as an invalid cookie, but typedarray expects0.",
	"Method": "int ApkAssetsCookieToJavaCookie(ApkAssetsCookie cookie){\r\n    return cookie.intValue() != kInvalidCookie ? (cookie.intValue() + 1) : -1;\r\n}"
}, {
	"Path": "io.reactivex.disposables.CompositeDisposable.addAll",
	"Comment": "atomically adds the given array of disposables to the container ordisposes them all if the container has been disposed.",
	"Method": "boolean addAll(Disposable ds){\r\n    ObjectHelper.requireNonNull(ds, \"ds is null\");\r\n    if (!disposed) {\r\n        synchronized (this) {\r\n            if (!disposed) {\r\n                OpenHashSet<Disposable> set = resources;\r\n                if (set == null) {\r\n                    set = new OpenHashSet<Disposable>(ds.length + 1);\r\n                    resources = set;\r\n                }\r\n                for (Disposable d : ds) {\r\n                    ObjectHelper.requireNonNull(d, \"d is null\");\r\n                    set.add(d);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    for (Disposable d : ds) {\r\n        d.dispose();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.animateScaleAndCenter",
	"Comment": "creates a scale animation builder, that when started will animate a zoom in or out. if this would move the imagebeyond the panning limits, the image is automatically panned during the animation.",
	"Method": "AnimationBuilder animateScaleAndCenter(float scale,PointF sCenter){\r\n    if (!isReady()) {\r\n        return null;\r\n    }\r\n    return new AnimationBuilder(scale, sCenter);\r\n}"
}, {
	"Path": "org.robolectric.manifest.AndroidManifest.initMetaData",
	"Comment": "allows shadowpackagemanager to providea resource index for initialising the resource attributes in all the metadata elements",
	"Method": "void initMetaData(ResourceTable resourceTable){\r\n    if (!packageNameIsOverridden()) {\r\n        parseAndroidManifest();\r\n    }\r\n    if (applicationMetaData != null) {\r\n        applicationMetaData.init(resourceTable, packageName);\r\n    }\r\n    for (PackageItemData receiver : receivers) {\r\n        receiver.getMetaData().init(resourceTable, packageName);\r\n    }\r\n    for (ServiceData service : serviceDatas.values()) {\r\n        service.getMetaData().init(resourceTable, packageName);\r\n    }\r\n    for (ContentProviderData providerData : providers) {\r\n        providerData.getMetaData().init(resourceTable, packageName);\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.io.TemporaryFilesystem.deleteTempDir",
	"Comment": "delete a temporary directory that we were responsible for creating.",
	"Method": "void deleteTempDir(File file){\r\n    if (!shouldReap()) {\r\n        return;\r\n    }\r\n    if (temporaryFiles.remove(file)) {\r\n        FileHandler.delete(file);\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.parallel.ParallelFlowable.doOnRequest",
	"Comment": "call the specified consumer with the request amount if any rail receives a request.",
	"Method": "ParallelFlowable<T> doOnRequest(LongConsumer onRequest){\r\n    ObjectHelper.requireNonNull(onRequest, \"onRequest is null\");\r\n    return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this, Functions.emptyConsumer(), Functions.emptyConsumer(), Functions.emptyConsumer(), Functions.EMPTY_ACTION, Functions.EMPTY_ACTION, Functions.emptyConsumer(), onRequest, Functions.EMPTY_ACTION));\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowAccessibilityNodeInfo.setDrawingOrder",
	"Comment": "sets the drawing order of the view corresponding to this node.",
	"Method": "void setDrawingOrder(int drawingOrder){\r\n    this.drawingOrder = drawingOrder;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableMergeDelayErrorTest.mergeIterable",
	"Comment": "this is pretty much a clone of testmergelist but with the overloaded mergedelayerror for iterables",
	"Method": "void mergeIterable(){\r\n    final Flowable<String> f1 = Flowable.unsafeCreate(new TestSynchronousFlowable());\r\n    final Flowable<String> f2 = Flowable.unsafeCreate(new TestSynchronousFlowable());\r\n    List<Flowable<String>> listOfFlowables = new ArrayList<Flowable<String>>();\r\n    listOfFlowables.add(f1);\r\n    listOfFlowables.add(f2);\r\n    Flowable<String> m = Flowable.mergeDelayError(listOfFlowables);\r\n    m.subscribe(stringSubscriber);\r\n    verify(stringSubscriber, never()).onError(any(Throwable.class));\r\n    verify(stringSubscriber, times(1)).onComplete();\r\n    verify(stringSubscriber, times(2)).onNext(\"hello\");\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowBluetoothDevice.getFetchUuidsWithSdpCount",
	"Comment": "returns the number of times fetchuuidswithsdp has been called.",
	"Method": "int getFetchUuidsWithSdpCount(){\r\n    return fetchUuidsWithSdpCount;\r\n}"
}, {
	"Path": "io.reactivex.processors.MulticastProcessor.start",
	"Comment": "initializes this processor by setting an upstream subscription thatignores request amounts, uses a fixed bufferand allows using the onxxx and offer methodsafterwards.",
	"Method": "void start(){\r\n    if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) {\r\n        queue = new SpscArrayQueue<T>(bufferSize);\r\n    }\r\n}"
}, {
	"Path": "com.vondear.rxtool.module.photomagic.RxMagic.getImageCacheFile",
	"Comment": "returns a mfile with a cache audio name in the private cache directory.",
	"Method": "File getImageCacheFile(Context context,String suffix){\r\n    if (TextUtils.isEmpty(mTargetDir)) {\r\n        mTargetDir = getImageCacheDir(context).getAbsolutePath();\r\n    }\r\n    String cacheBuilder = mTargetDir + \"/\" + System.currentTimeMillis() + (int) (Math.random() * 1000) + (TextUtils.isEmpty(suffix) ? \".jpg\" : suffix);\r\n    return new File(cacheBuilder);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowActivity.getLastRequestedPermission",
	"Comment": "gets the last permission request submitted to this activity.",
	"Method": "PermissionsRequest getLastRequestedPermission(){\r\n    return lastRequestedPermission;\r\n}"
}, {
	"Path": "org.robolectric.RuntimeEnvironment.isMainThread",
	"Comment": "tests if the current thread is currently set as the main thread.",
	"Method": "boolean isMainThread(Thread thread,boolean isMainThread){\r\n    return isMainThread(Thread.currentThread());\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.visibilityOfAllElements",
	"Comment": "an expectation for checking that all elements present on the web page that match the locatorare visible. visibility means that the elements are not only displayed but also have a heightand width that is greater than 0.",
	"Method": "ExpectedCondition<List<WebElement>> visibilityOfAllElements(WebElement elements,ExpectedCondition<List<WebElement>> visibilityOfAllElements,List<WebElement> elements){\r\n    return new ExpectedCondition<List<WebElement>>() {\r\n        @Override\r\n        public List<WebElement> apply(WebDriver driver) {\r\n            for (WebElement element : elements) {\r\n                if (!element.isDisplayed()) {\r\n                    return null;\r\n                }\r\n            }\r\n            return elements.size() > 0 ? elements : null;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"visibility of all \" + elements;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.visibilityOfAllElements",
	"Comment": "an expectation for checking that all elements present on the web page that match the locatorare visible. visibility means that the elements are not only displayed but also have a heightand width that is greater than 0.",
	"Method": "ExpectedCondition<List<WebElement>> visibilityOfAllElements(WebElement elements,ExpectedCondition<List<WebElement>> visibilityOfAllElements,List<WebElement> elements){\r\n    for (WebElement element : elements) {\r\n        if (!element.isDisplayed()) {\r\n            return null;\r\n        }\r\n    }\r\n    return elements.size() > 0 ? elements : null;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.visibilityOfAllElements",
	"Comment": "an expectation for checking that all elements present on the web page that match the locatorare visible. visibility means that the elements are not only displayed but also have a heightand width that is greater than 0.",
	"Method": "ExpectedCondition<List<WebElement>> visibilityOfAllElements(WebElement elements,ExpectedCondition<List<WebElement>> visibilityOfAllElements,List<WebElement> elements){\r\n    return \"visibility of all \" + elements;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.javaScriptThrowsNoExceptions",
	"Comment": "an expectation to check if js executable.useful whenyou know that there should be a javascript value or something at the stage.",
	"Method": "ExpectedCondition<Boolean> javaScriptThrowsNoExceptions(String javaScript){\r\n    return new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            try {\r\n                ((JavascriptExecutor) driver).executeScript(javaScript);\r\n                return true;\r\n            } catch (WebDriverException e) {\r\n                return false;\r\n            }\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"js %s to be executable\", javaScript);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.javaScriptThrowsNoExceptions",
	"Comment": "an expectation to check if js executable.useful whenyou know that there should be a javascript value or something at the stage.",
	"Method": "ExpectedCondition<Boolean> javaScriptThrowsNoExceptions(String javaScript){\r\n    try {\r\n        ((JavascriptExecutor) driver).executeScript(javaScript);\r\n        return true;\r\n    } catch (WebDriverException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.javaScriptThrowsNoExceptions",
	"Comment": "an expectation to check if js executable.useful whenyou know that there should be a javascript value or something at the stage.",
	"Method": "ExpectedCondition<Boolean> javaScriptThrowsNoExceptions(String javaScript){\r\n    return String.format(\"js %s to be executable\", javaScript);\r\n}"
}, {
	"Path": "org.robolectric.shadows.LegacyManifestParser.metaDataToBundle",
	"Comment": "goes through the meta data and puts each value in to a bundle as the correct type.note that this will convert resource identifiers specified via the value attribute as well.",
	"Method": "Bundle metaDataToBundle(Map<String, Object> meta){\r\n    if (meta.size() == 0) {\r\n        return null;\r\n    }\r\n    Bundle bundle = new Bundle();\r\n    for (Map.Entry<String, Object> entry : meta.entrySet()) {\r\n        String key = entry.getKey();\r\n        Object value = entry.getValue();\r\n        if (Boolean.class.isInstance(value)) {\r\n            bundle.putBoolean(key, (Boolean) value);\r\n        } else if (Float.class.isInstance(value)) {\r\n            bundle.putFloat(key, (Float) value);\r\n        } else if (Integer.class.isInstance(value)) {\r\n            bundle.putInt(key, (Integer) value);\r\n        } else {\r\n            bundle.putString(key, value == null ? null : value.toString());\r\n        }\r\n    }\r\n    return bundle;\r\n}"
}, {
	"Path": "io.reactivex.parallel.ParallelFlowable.compose",
	"Comment": "allows composing operators, in assembly time, on top of this parallelflowableand returns another parallelflowable with composed features.",
	"Method": "ParallelFlowable<U> compose(ParallelTransformer<T, U> composer){\r\n    return RxJavaPlugins.onAssembly(ObjectHelper.requireNonNull(composer, \"composer is null\").apply(this));\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableZipTest.testAggregatorSimple",
	"Comment": "testing internal private logic due to the complexity so i want to use tdd to test as a i build it rather than relying purely on the overall functionality expected by the public methods.",
	"Method": "void testAggregatorSimple(){\r\n    PublishSubject<String> r1 = PublishSubject.create();\r\n    PublishSubject<String> r2 = PublishSubject.create();\r\n    Observer<String> observer = TestHelper.mockObserver();\r\n    Observable.zip(r1, r2, zipr2).subscribe(observer);\r\n    r1.onNext(\"hello\");\r\n    r2.onNext(\"world\");\r\n    InOrder inOrder = inOrder(observer);\r\n    verify(observer, never()).onError(any(Throwable.class));\r\n    verify(observer, never()).onComplete();\r\n    inOrder.verify(observer, times(1)).onNext(\"helloworld\");\r\n    r1.onNext(\"hello \");\r\n    r2.onNext(\"again\");\r\n    verify(observer, never()).onError(any(Throwable.class));\r\n    verify(observer, never()).onComplete();\r\n    inOrder.verify(observer, times(1)).onNext(\"hello again\");\r\n    r1.onComplete();\r\n    r2.onComplete();\r\n    inOrder.verify(observer, never()).onNext(anyString());\r\n    verify(observer, times(1)).onComplete();\r\n}"
}, {
	"Path": "io.reactivex.subjects.MaybeSubject.hasValue",
	"Comment": "returns true if this maybesubject was terminated with a success value.",
	"Method": "boolean hasValue(){\r\n    return observers.get() == TERMINATED && value != null;\r\n}"
}, {
	"Path": "org.robolectric.res.android.LoadedArsc.CreateEmpty",
	"Comment": "create an empty loadedarsc. this is used when an apk has no resources.arsc.",
	"Method": "LoadedArsc CreateEmpty(){\r\n    return new LoadedArsc();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableGroupByTest.testUnsubscribeOnNestedTakeAndAsyncInfiniteStream",
	"Comment": "we will only take 1 group with 20 events from it and then unsubscribe.",
	"Method": "void testUnsubscribeOnNestedTakeAndAsyncInfiniteStream(){\r\n    final AtomicInteger subscribeCounter = new AtomicInteger();\r\n    final AtomicInteger sentEventCounter = new AtomicInteger();\r\n    doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream(ASYNC_INFINITE_OBSERVABLE_OF_EVENT(2, subscribeCounter, sentEventCounter), subscribeCounter);\r\n    Thread.sleep(500);\r\n    assertEquals(39, sentEventCounter.get());\r\n}"
}, {
	"Path": "org.robolectric.integration_tests.axt.ActivityTestRuleTest.launchActivity_bundle",
	"Comment": "starting an activity with options is currently not supported, so check that received bundle isalways null in both modes.",
	"Method": "void launchActivity_bundle(){\r\n    TranscriptActivity activity = rule.launchActivity(null);\r\n    assertThat(activity.receivedBundle).isNull();\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.onDraw",
	"Comment": "draw method should not be called until the view has dimensions so the first calls are used as triggers to calculatethe scaling and tiling required. once the view is setup, tiles are displayed as they are loaded.",
	"Method": "void onDraw(Canvas canvas){\r\n    super.onDraw(canvas);\r\n    createPaints();\r\n    if (sWidth == 0 || sHeight == 0 || getWidth() == 0 || getHeight() == 0) {\r\n        return;\r\n    }\r\n    if (tileMap == null && decoder != null) {\r\n        initialiseBaseLayer(getMaxBitmapDimensions(canvas));\r\n    }\r\n    if (!checkReady()) {\r\n        return;\r\n    }\r\n    preDraw();\r\n    if (anim != null) {\r\n        float scaleBefore = scale;\r\n        if (vTranslateBefore == null) {\r\n            vTranslateBefore = new PointF(0, 0);\r\n        }\r\n        vTranslateBefore.set(vTranslate);\r\n        long scaleElapsed = System.currentTimeMillis() - anim.time;\r\n        boolean finished = scaleElapsed > anim.duration;\r\n        scaleElapsed = Math.min(scaleElapsed, anim.duration);\r\n        scale = ease(anim.easing, scaleElapsed, anim.scaleStart, anim.scaleEnd - anim.scaleStart, anim.duration);\r\n        float vFocusNowX = ease(anim.easing, scaleElapsed, anim.vFocusStart.x, anim.vFocusEnd.x - anim.vFocusStart.x, anim.duration);\r\n        float vFocusNowY = ease(anim.easing, scaleElapsed, anim.vFocusStart.y, anim.vFocusEnd.y - anim.vFocusStart.y, anim.duration);\r\n        vTranslate.x -= sourceToViewX(anim.sCenterEnd.x) - vFocusNowX;\r\n        vTranslate.y -= sourceToViewY(anim.sCenterEnd.y) - vFocusNowY;\r\n        fitToBounds(finished || (anim.scaleStart == anim.scaleEnd));\r\n        sendStateChanged(scaleBefore, vTranslateBefore, anim.origin);\r\n        refreshRequiredTiles(finished);\r\n        if (finished) {\r\n            if (anim.listener != null) {\r\n                try {\r\n                    anim.listener.onComplete();\r\n                } catch (Exception e) {\r\n                    Log.w(TAG, \"Error thrown by animation listener\", e);\r\n                }\r\n            }\r\n            anim = null;\r\n        }\r\n        invalidate();\r\n    }\r\n    if (tileMap != null && isBaseLayerReady()) {\r\n        int sampleSize = Math.min(fullImageSampleSize, calculateInSampleSize(scale));\r\n        boolean hasMissingTiles = false;\r\n        for (Map.Entry<Integer, List<Tile>> tileMapEntry : tileMap.entrySet()) {\r\n            if (tileMapEntry.getKey() == sampleSize) {\r\n                for (Tile tile : tileMapEntry.getValue()) {\r\n                    if (tile.visible && (tile.loading || tile.bitmap == null)) {\r\n                        hasMissingTiles = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (Map.Entry<Integer, List<Tile>> tileMapEntry : tileMap.entrySet()) {\r\n            if (tileMapEntry.getKey() == sampleSize || hasMissingTiles) {\r\n                for (Tile tile : tileMapEntry.getValue()) {\r\n                    sourceToViewRect(tile.sRect, tile.vRect);\r\n                    if (!tile.loading && tile.bitmap != null) {\r\n                        if (tileBgPaint != null) {\r\n                            canvas.drawRect(tile.vRect, tileBgPaint);\r\n                        }\r\n                        if (matrix == null) {\r\n                            matrix = new Matrix();\r\n                        }\r\n                        matrix.reset();\r\n                        setMatrixArray(srcArray, 0, 0, tile.bitmap.getWidth(), 0, tile.bitmap.getWidth(), tile.bitmap.getHeight(), 0, tile.bitmap.getHeight());\r\n                        if (getRequiredRotation() == ORIENTATION_0) {\r\n                            setMatrixArray(dstArray, tile.vRect.left, tile.vRect.top, tile.vRect.right, tile.vRect.top, tile.vRect.right, tile.vRect.bottom, tile.vRect.left, tile.vRect.bottom);\r\n                        } else if (getRequiredRotation() == ORIENTATION_90) {\r\n                            setMatrixArray(dstArray, tile.vRect.right, tile.vRect.top, tile.vRect.right, tile.vRect.bottom, tile.vRect.left, tile.vRect.bottom, tile.vRect.left, tile.vRect.top);\r\n                        } else if (getRequiredRotation() == ORIENTATION_180) {\r\n                            setMatrixArray(dstArray, tile.vRect.right, tile.vRect.bottom, tile.vRect.left, tile.vRect.bottom, tile.vRect.left, tile.vRect.top, tile.vRect.right, tile.vRect.top);\r\n                        } else if (getRequiredRotation() == ORIENTATION_270) {\r\n                            setMatrixArray(dstArray, tile.vRect.left, tile.vRect.bottom, tile.vRect.left, tile.vRect.top, tile.vRect.right, tile.vRect.top, tile.vRect.right, tile.vRect.bottom);\r\n                        }\r\n                        matrix.setPolyToPoly(srcArray, 0, dstArray, 0, 4);\r\n                        canvas.drawBitmap(tile.bitmap, matrix, bitmapPaint);\r\n                        if (debug) {\r\n                            canvas.drawRect(tile.vRect, debugPaint);\r\n                        }\r\n                    } else if (tile.loading && debug) {\r\n                        canvas.drawText(\"LOADING\", tile.vRect.left + 5, tile.vRect.top + 35, debugPaint);\r\n                    }\r\n                    if (tile.visible && debug) {\r\n                        canvas.drawText(\"ISS \" + tile.sampleSize + \" RECT \" + tile.sRect.top + \",\" + tile.sRect.left + \",\" + tile.sRect.bottom + \",\" + tile.sRect.right, tile.vRect.left + 5, tile.vRect.top + 15, debugPaint);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else if (bitmap != null) {\r\n        float xScale = scale, yScale = scale;\r\n        if (bitmapIsPreview) {\r\n            xScale = scale * ((float) sWidth / bitmap.getWidth());\r\n            yScale = scale * ((float) sHeight / bitmap.getHeight());\r\n        }\r\n        if (matrix == null) {\r\n            matrix = new Matrix();\r\n        }\r\n        matrix.reset();\r\n        matrix.postScale(xScale, yScale);\r\n        matrix.postRotate(getRequiredRotation());\r\n        matrix.postTranslate(vTranslate.x, vTranslate.y);\r\n        if (getRequiredRotation() == ORIENTATION_180) {\r\n            matrix.postTranslate(scale * sWidth, scale * sHeight);\r\n        } else if (getRequiredRotation() == ORIENTATION_90) {\r\n            matrix.postTranslate(scale * sHeight, 0);\r\n        } else if (getRequiredRotation() == ORIENTATION_270) {\r\n            matrix.postTranslate(0, scale * sWidth);\r\n        }\r\n        if (tileBgPaint != null) {\r\n            if (sRect == null) {\r\n                sRect = new RectF();\r\n            }\r\n            sRect.set(0f, 0f, bitmapIsPreview ? bitmap.getWidth() : sWidth, bitmapIsPreview ? bitmap.getHeight() : sHeight);\r\n            matrix.mapRect(sRect);\r\n            canvas.drawRect(sRect, tileBgPaint);\r\n        }\r\n        canvas.drawBitmap(bitmap, matrix, bitmapPaint);\r\n    }\r\n    if (debug) {\r\n        canvas.drawText(\"Scale: \" + String.format(Locale.ENGLISH, \"%.2f\", scale), 5, 15, debugPaint);\r\n        canvas.drawText(\"Translate: \" + String.format(Locale.ENGLISH, \"%.2f\", vTranslate.x) + \":\" + String.format(Locale.ENGLISH, \"%.2f\", vTranslate.y), 5, 35, debugPaint);\r\n        PointF center = getCenter();\r\n        canvas.drawText(\"Source center: \" + String.format(Locale.ENGLISH, \"%.2f\", center.x) + \":\" + String.format(Locale.ENGLISH, \"%.2f\", center.y), 5, 55, debugPaint);\r\n        debugPaint.setStrokeWidth(2f);\r\n        if (anim != null) {\r\n            PointF vCenterStart = sourceToViewCoord(anim.sCenterStart);\r\n            PointF vCenterEndRequested = sourceToViewCoord(anim.sCenterEndRequested);\r\n            PointF vCenterEnd = sourceToViewCoord(anim.sCenterEnd);\r\n            canvas.drawCircle(vCenterStart.x, vCenterStart.y, 10, debugPaint);\r\n            debugPaint.setColor(Color.RED);\r\n            canvas.drawCircle(vCenterEndRequested.x, vCenterEndRequested.y, 20, debugPaint);\r\n            debugPaint.setColor(Color.BLUE);\r\n            canvas.drawCircle(vCenterEnd.x, vCenterEnd.y, 25, debugPaint);\r\n            debugPaint.setColor(Color.CYAN);\r\n            canvas.drawCircle(getWidth() / 2, getHeight() / 2, 30, debugPaint);\r\n        }\r\n        if (vCenterStart != null) {\r\n            debugPaint.setColor(Color.RED);\r\n            canvas.drawCircle(vCenterStart.x, vCenterStart.y, 20, debugPaint);\r\n        }\r\n        if (quickScaleSCenter != null) {\r\n            debugPaint.setColor(Color.BLUE);\r\n            canvas.drawCircle(sourceToViewX(quickScaleSCenter.x), sourceToViewY(quickScaleSCenter.y), 35, debugPaint);\r\n        }\r\n        if (quickScaleVStart != null) {\r\n            debugPaint.setColor(Color.CYAN);\r\n            canvas.drawCircle(quickScaleVStart.x, quickScaleVStart.y, 30, debugPaint);\r\n        }\r\n        debugPaint.setColor(Color.MAGENTA);\r\n        debugPaint.setStrokeWidth(1f);\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.chrome.ChromeOptions.setBinary",
	"Comment": "sets the path to the chrome executable. this path should exist on themachine which will launch chrome. the path should either be absolute orrelative to the location of running chromedriver server.",
	"Method": "ChromeOptions setBinary(File path,ChromeOptions setBinary,String path){\r\n    binary = checkNotNull(path);\r\n    return this;\r\n}"
}, {
	"Path": "com.vondear.rxtool.RxMigrationHelper.reflectMethod",
	"Comment": "dao class already define the sql exec method, so just invoke it",
	"Method": "void reflectMethod(StandardDatabase db,String methodName,boolean isExists,Class<? extends AbstractDao<?, ?>> daoClasses){\r\n    if (daoClasses.length < 1) {\r\n        return;\r\n    }\r\n    try {\r\n        for (Class cls : daoClasses) {\r\n            Method method = cls.getDeclaredMethod(methodName, Database.class, boolean.class);\r\n            method.invoke(null, db, isExists);\r\n        }\r\n    } catch (NoSuchMethodException e) {\r\n        e.printStackTrace();\r\n    } catch (InvocationTargetException e) {\r\n        e.printStackTrace();\r\n    } catch (IllegalAccessException e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowUserManager.getApplicationRestrictions",
	"Comment": "compared to real android, there is no check that the package name matches the applicationpackage name and the method returns instantly.",
	"Method": "Bundle getApplicationRestrictions(String packageName){\r\n    Bundle bundle = applicationRestrictions.get(packageName);\r\n    return bundle != null ? bundle : new Bundle();\r\n}"
}, {
	"Path": "io.reactivex.disposables.Disposables.fromAction",
	"Comment": "construct a disposable by wrapping a action that isexecuted exactly once when the disposable is disposed.",
	"Method": "Disposable fromAction(Action run){\r\n    ObjectHelper.requireNonNull(run, \"run is null\");\r\n    return new ActionDisposable(run);\r\n}"
}, {
	"Path": "io.reactivex.Completable.test",
	"Comment": "creates a testobserver optionally in cancelled state, then subscribes it to this completable.",
	"Method": "TestObserver<Void> test(TestObserver<Void> test,boolean cancelled){\r\n    TestObserver<Void> to = new TestObserver<Void>();\r\n    if (cancelled) {\r\n        to.cancel();\r\n    }\r\n    subscribe(to);\r\n    return to;\r\n}"
}, {
	"Path": "org.robolectric.android.controller.ActivityController.setup",
	"Comment": "calls the same lifecycle methods on the activity called by android when an activity is restored from previously saved state.",
	"Method": "ActivityController<T> setup(ActivityController<T> setup,Bundle savedInstanceState){\r\n    return create(savedInstanceState).start().restoreInstanceState(savedInstanceState).postCreate(savedInstanceState).resume().visible();\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.ImageSource.tilingDisabled",
	"Comment": "disable tiling of the image. this does not apply to preview images which are always loaded as a single bitmap,and tiling cannot be disabled when displaying a region of the source image.",
	"Method": "ImageSource tilingDisabled(){\r\n    return tiling(false);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    final AtomicInteger eventCounter = new AtomicInteger();\r\n    final AtomicInteger subscribeCounter = new AtomicInteger();\r\n    final AtomicInteger groupCounter = new AtomicInteger();\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    final int count = 100;\r\n    final int groupCount = 2;\r\n    Observable<Event> es = Observable.unsafeCreate(new ObservableSource<Event>() {\r\n        @Override\r\n        public void subscribe(final Observer<? super Event> observer) {\r\n            observer.onSubscribe(Disposables.empty());\r\n            System.out.println(\"*** Subscribing to EventStream ***\");\r\n            subscribeCounter.incrementAndGet();\r\n            new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    for (int i = 0; i < count; i++) {\r\n                        Event e = new Event();\r\n                        e.source = i % groupCount;\r\n                        e.message = \"Event-\" + i;\r\n                        observer.onNext(e);\r\n                    }\r\n                    observer.onComplete();\r\n                }\r\n            }).start();\r\n        }\r\n    });\r\n    es.groupBy(new Function<Event, Integer>() {\r\n        @Override\r\n        public Integer apply(Event e) {\r\n            return e.source;\r\n        }\r\n    }).flatMap(new Function<GroupedObservable<Integer, Event>, Observable<String>>() {\r\n        @Override\r\n        public Observable<String> apply(GroupedObservable<Integer, Event> eventGroupedObservable) {\r\n            System.out.println(\"GroupedObservable Key: \" + eventGroupedObservable.getKey());\r\n            groupCounter.incrementAndGet();\r\n            return eventGroupedObservable.map(new Function<Event, String>() {\r\n                @Override\r\n                public String apply(Event event) {\r\n                    return \"Source: \" + event.source + \"  Message: \" + event.message;\r\n                }\r\n            });\r\n        }\r\n    }).subscribe(new DefaultObserver<String>() {\r\n        @Override\r\n        public void onComplete() {\r\n            latch.countDown();\r\n        }\r\n        @Override\r\n        public void onError(Throwable e) {\r\n            e.printStackTrace();\r\n            latch.countDown();\r\n        }\r\n        @Override\r\n        public void onNext(String outputMessage) {\r\n            System.out.println(outputMessage);\r\n            eventCounter.incrementAndGet();\r\n        }\r\n    });\r\n    latch.await(5000, TimeUnit.MILLISECONDS);\r\n    assertEquals(1, subscribeCounter.get());\r\n    assertEquals(groupCount, groupCounter.get());\r\n    assertEquals(count, eventCounter.get());\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    observer.onSubscribe(Disposables.empty());\r\n    System.out.println(\"*** Subscribing to EventStream ***\");\r\n    subscribeCounter.incrementAndGet();\r\n    new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            for (int i = 0; i < count; i++) {\r\n                Event e = new Event();\r\n                e.source = i % groupCount;\r\n                e.message = \"Event-\" + i;\r\n                observer.onNext(e);\r\n            }\r\n            observer.onComplete();\r\n        }\r\n    }).start();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    for (int i = 0; i < count; i++) {\r\n        Event e = new Event();\r\n        e.source = i % groupCount;\r\n        e.message = \"Event-\" + i;\r\n        observer.onNext(e);\r\n    }\r\n    observer.onComplete();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    return e.source;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    System.out.println(\"GroupedObservable Key: \" + eventGroupedObservable.getKey());\r\n    groupCounter.incrementAndGet();\r\n    return eventGroupedObservable.map(new Function<Event, String>() {\r\n        @Override\r\n        public String apply(Event event) {\r\n            return \"Source: \" + event.source + \"  Message: \" + event.message;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    return \"Source: \" + event.source + \"  Message: \" + event.message;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    e.printStackTrace();\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    System.out.println(outputMessage);\r\n    eventCounter.incrementAndGet();\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.calculateInSampleSize",
	"Comment": "calculates sample size to fit the source image in given bounds.",
	"Method": "int calculateInSampleSize(float scale){\r\n    if (minimumTileDpi > 0) {\r\n        DisplayMetrics metrics = getResources().getDisplayMetrics();\r\n        float averageDpi = (metrics.xdpi + metrics.ydpi) / 2;\r\n        scale = (minimumTileDpi / averageDpi) * scale;\r\n    }\r\n    int reqWidth = (int) (sWidth() * scale);\r\n    int reqHeight = (int) (sHeight() * scale);\r\n    int inSampleSize = 1;\r\n    if (reqWidth == 0 || reqHeight == 0) {\r\n        return 32;\r\n    }\r\n    if (sHeight() > reqHeight || sWidth() > reqWidth) {\r\n        final int heightRatio = Math.round((float) sHeight() / (float) reqHeight);\r\n        final int widthRatio = Math.round((float) sWidth() / (float) reqWidth);\r\n        inSampleSize = heightRatio < widthRatio ? heightRatio : widthRatio;\r\n    }\r\n    int power = 1;\r\n    while (power * 2 < inSampleSize) {\r\n        power = power * 2;\r\n    }\r\n    return power;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.ImageSource.region",
	"Comment": "use a region of the source image. region must be set independently for the full size image and the preview ifyou are using one.",
	"Method": "ImageSource region(Rect sRegion){\r\n    this.sRegion = sRegion;\r\n    setInvariants();\r\n    return this;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowMediaPlayer.invokeInfoListener",
	"Comment": "allows test cases to directly simulate invocation of the oninfo event.",
	"Method": "void invokeInfoListener(int what,int extra){\r\n    if (infoListener != null) {\r\n        infoListener.onInfo(player, what, extra);\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.android.internal.ParallelUniverse.createTestDataDirRootPath",
	"Comment": "create a file system safe directory path name for the current test.",
	"Method": "String createTestDataDirRootPath(Method method){\r\n    return method.getClass().getSimpleName() + \"_\" + method.getName().replaceAll(\"[^a-zA-Z0-9.-]\", \"_\");\r\n}"
}, {
	"Path": "io.reactivex.processors.PublishProcessor.add",
	"Comment": "tries to add the given subscriber to the subscribers array atomicallyor returns false if this processor has terminated.",
	"Method": "boolean add(PublishSubscription<T> ps){\r\n    for (; ; ) {\r\n        PublishSubscription<T>[] a = subscribers.get();\r\n        if (a == TERMINATED) {\r\n            return false;\r\n        }\r\n        int n = a.length;\r\n        @SuppressWarnings(\"unchecked\")\r\n        PublishSubscription<T>[] b = new PublishSubscription[n + 1];\r\n        System.arraycopy(a, 0, b, 0, n);\r\n        b[n] = ps;\r\n        if (subscribers.compareAndSet(a, b)) {\r\n            return true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vondear.rxui.view.wheelhorizontal.WheelRecycler.addView",
	"Comment": "adds view to specified cache. creates a cache list if it is null.",
	"Method": "List<View> addView(View view,List<View> cache){\r\n    if (cache == null) {\r\n        cache = new LinkedList<View>();\r\n    }\r\n    cache.add(view);\r\n    return cache;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.dialog.wheel.WheelView.isCyclic",
	"Comment": "tests if wheel is cyclic. that means before the 1st item there is shown the last one",
	"Method": "boolean isCyclic(){\r\n    return isCyclic;\r\n}"
}, {
	"Path": "org.openqa.selenium.logging.LogLevelMapping.normalize",
	"Comment": "normalizes the given level to one of those supported by selenium.",
	"Method": "Level normalize(Level level){\r\n    if (levelMap.containsKey(level.intValue())) {\r\n        return levelMap.get(level.intValue());\r\n    } else if (level.intValue() >= Level.SEVERE.intValue()) {\r\n        return Level.SEVERE;\r\n    } else if (level.intValue() >= Level.WARNING.intValue()) {\r\n        return Level.WARNING;\r\n    } else if (level.intValue() >= Level.INFO.intValue()) {\r\n        return Level.INFO;\r\n    } else {\r\n        return Level.FINE;\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testUnsubscribeOnNestedTakeAndAsyncInfiniteStream",
	"Comment": "we will only take 1 group with 20 events from it and then unsubscribe.",
	"Method": "void testUnsubscribeOnNestedTakeAndAsyncInfiniteStream(){\r\n    final AtomicInteger subscribeCounter = new AtomicInteger();\r\n    final AtomicInteger sentEventCounter = new AtomicInteger();\r\n    doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream(ASYNC_INFINITE_OBSERVABLE_OF_EVENT(2, subscribeCounter, sentEventCounter), subscribeCounter);\r\n    Thread.sleep(500);\r\n    assertEquals(39, sentEventCounter.get());\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableSwitchTest.testIssue2654",
	"Comment": "the upstream producer hijacked the switch producer stopping the requests aimed at the inner observables.",
	"Method": "void testIssue2654(){\r\n    Observable<String> oneItem = Observable.just(\"Hello\").mergeWith(Observable.<String>never());\r\n    Observable<String> src = oneItem.switchMap(new Function<String, Observable<String>>() {\r\n        @Override\r\n        public Observable<String> apply(final String s) {\r\n            return Observable.just(s).mergeWith(Observable.interval(10, TimeUnit.MILLISECONDS).map(new Function<Long, String>() {\r\n                @Override\r\n                public String apply(Long i) {\r\n                    return s + \" \" + i;\r\n                }\r\n            })).take(250);\r\n        }\r\n    }).share();\r\n    TestObserver<String> to = new TestObserver<String>() {\r\n        @Override\r\n        public void onNext(String t) {\r\n            super.onNext(t);\r\n            if (valueCount() == 250) {\r\n                onComplete();\r\n                dispose();\r\n            }\r\n        }\r\n    };\r\n    src.subscribe(to);\r\n    to.awaitTerminalEvent(10, TimeUnit.SECONDS);\r\n    System.out.println(\"> testIssue2654: \" + to.valueCount());\r\n    to.assertTerminated();\r\n    to.assertNoErrors();\r\n    Assert.assertEquals(250, to.valueCount());\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableSwitchTest.testIssue2654",
	"Comment": "the upstream producer hijacked the switch producer stopping the requests aimed at the inner observables.",
	"Method": "void testIssue2654(){\r\n    return Observable.just(s).mergeWith(Observable.interval(10, TimeUnit.MILLISECONDS).map(new Function<Long, String>() {\r\n        @Override\r\n        public String apply(Long i) {\r\n            return s + \" \" + i;\r\n        }\r\n    })).take(250);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableSwitchTest.testIssue2654",
	"Comment": "the upstream producer hijacked the switch producer stopping the requests aimed at the inner observables.",
	"Method": "void testIssue2654(){\r\n    return s + \" \" + i;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableSwitchTest.testIssue2654",
	"Comment": "the upstream producer hijacked the switch producer stopping the requests aimed at the inner observables.",
	"Method": "void testIssue2654(){\r\n    super.onNext(t);\r\n    if (valueCount() == 250) {\r\n        onComplete();\r\n        dispose();\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowAppTask.finishAndRemoveTask",
	"Comment": "for tests, marks the task as finished. task is not finished when created initially.",
	"Method": "void finishAndRemoveTask(){\r\n    this.isFinished = true;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableConcatTest.testSimpleAsyncConcat",
	"Comment": "simple concat of 2 asynchronous observables ensuring it emits in correct order.",
	"Method": "void testSimpleAsyncConcat(){\r\n    Subscriber<String> subscriber = TestHelper.mockSubscriber();\r\n    TestObservable<String> o1 = new TestObservable<String>(\"one\", \"two\", \"three\");\r\n    TestObservable<String> o2 = new TestObservable<String>(\"four\", \"five\", \"six\");\r\n    Flowable.concat(Flowable.unsafeCreate(o1), Flowable.unsafeCreate(o2)).subscribe(subscriber);\r\n    try {\r\n        o1.t.join();\r\n        o2.t.join();\r\n    } catch (Throwable e) {\r\n        throw new RuntimeException(\"failed waiting on threads\");\r\n    }\r\n    InOrder inOrder = inOrder(subscriber);\r\n    inOrder.verify(subscriber, times(1)).onNext(\"one\");\r\n    inOrder.verify(subscriber, times(1)).onNext(\"two\");\r\n    inOrder.verify(subscriber, times(1)).onNext(\"three\");\r\n    inOrder.verify(subscriber, times(1)).onNext(\"four\");\r\n    inOrder.verify(subscriber, times(1)).onNext(\"five\");\r\n    inOrder.verify(subscriber, times(1)).onNext(\"six\");\r\n}"
}, {
	"Path": "com.github.scribejava.core.oauth.OAuth10aService.getAuthorizationUrl",
	"Comment": "returns the url where you should redirect your users to authenticate your application.",
	"Method": "String getAuthorizationUrl(OAuth1RequestToken requestToken){\r\n    return api.getAuthorizationUrl(requestToken);\r\n}"
}, {
	"Path": "io.reactivex.observers.BaseTestConsumer.assertFailureAndMessage",
	"Comment": "assert that the upstream signalled the specified values in order,then failed with a specific class or subclass of throwableand with the given exact error message.",
	"Method": "U assertFailureAndMessage(Class<? extends Throwable> error,String message,T values){\r\n    return assertSubscribed().assertValues(values).assertError(error).assertErrorMessage(message).assertNotComplete();\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.onTouchEvent",
	"Comment": "handle touch events. one finger pans, and two finger pinch and zoom plus panning.",
	"Method": "boolean onTouchEvent(MotionEvent event){\r\n    if (anim != null && !anim.interruptible) {\r\n        requestDisallowInterceptTouchEvent(true);\r\n        return true;\r\n    } else {\r\n        if (anim != null && anim.listener != null) {\r\n            try {\r\n                anim.listener.onInterruptedByUser();\r\n            } catch (Exception e) {\r\n                Log.w(TAG, \"Error thrown by animation listener\", e);\r\n            }\r\n        }\r\n        anim = null;\r\n    }\r\n    if (vTranslate == null) {\r\n        return true;\r\n    }\r\n    if (!isQuickScaling && (detector == null || detector.onTouchEvent(event))) {\r\n        isZooming = false;\r\n        isPanning = false;\r\n        maxTouchCount = 0;\r\n        return true;\r\n    }\r\n    if (vTranslateStart == null) {\r\n        vTranslateStart = new PointF(0, 0);\r\n    }\r\n    if (vTranslateBefore == null) {\r\n        vTranslateBefore = new PointF(0, 0);\r\n    }\r\n    if (vCenterStart == null) {\r\n        vCenterStart = new PointF(0, 0);\r\n    }\r\n    float scaleBefore = scale;\r\n    vTranslateBefore.set(vTranslate);\r\n    boolean handled = onTouchEventInternal(event);\r\n    sendStateChanged(scaleBefore, vTranslateBefore, ORIGIN_TOUCH);\r\n    return handled || super.onTouchEvent(event);\r\n}"
}, {
	"Path": "com.morihacky.android.rxjava.fragments.RotationPersist1WorkerFragment.onCreate",
	"Comment": "this method will only be called once when the retained fragment is first created.",
	"Method": "void onCreate(Bundle savedInstanceState){\r\n    super.onCreate(savedInstanceState);\r\n    setRetainInstance(true);\r\n    if (_storedIntsFlowable != null) {\r\n        return;\r\n    }\r\n    Flowable<Integer> intsObservable = Flowable.interval(1, TimeUnit.SECONDS).map(Long::intValue).take(20);\r\n    _storedIntsFlowable = intsObservable.publish();\r\n    _storedIntsDisposable = _storedIntsFlowable.connect();\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.urlMatches",
	"Comment": "expectation for the url to match a specific regular expression",
	"Method": "ExpectedCondition<Boolean> urlMatches(String regex){\r\n    return new ExpectedCondition<Boolean>() {\r\n        private String currentUrl;\r\n        private Pattern pattern;\r\n        private Matcher matcher;\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            currentUrl = driver.getCurrentUrl();\r\n            pattern = Pattern.compile(regex);\r\n            matcher = pattern.matcher(currentUrl);\r\n            return matcher.find();\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"url to match the regex \\\"%s\\\". Current url: \\\"%s\\\"\", regex, currentUrl);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.urlMatches",
	"Comment": "expectation for the url to match a specific regular expression",
	"Method": "ExpectedCondition<Boolean> urlMatches(String regex){\r\n    currentUrl = driver.getCurrentUrl();\r\n    pattern = Pattern.compile(regex);\r\n    matcher = pattern.matcher(currentUrl);\r\n    return matcher.find();\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.urlMatches",
	"Comment": "expectation for the url to match a specific regular expression",
	"Method": "ExpectedCondition<Boolean> urlMatches(String regex){\r\n    return String.format(\"url to match the regex \\\"%s\\\". Current url: \\\"%s\\\"\", regex, currentUrl);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowLooper.reset",
	"Comment": "causes all enqueued tasks to be discarded, and pause state to be reset",
	"Method": "void reset(){\r\n    shadowOf(realObject.getQueue()).reset();\r\n    resetScheduler();\r\n    quit = false;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.attributeToBe",
	"Comment": "an expectation for checking given webelement has attribute with a specific value",
	"Method": "ExpectedCondition<Boolean> attributeToBe(By locator,String attribute,String value,ExpectedCondition<Boolean> attributeToBe,WebElement element,String attribute,String value){\r\n    return new ExpectedCondition<Boolean>() {\r\n        private String currentValue = null;\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            currentValue = element.getAttribute(attribute);\r\n            if (currentValue == null || currentValue.isEmpty()) {\r\n                currentValue = element.getCssValue(attribute);\r\n            }\r\n            return value.equals(currentValue);\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(attribute + \" to be \\\"%s\\\". Current \" + attribute + \": \\\"%s\\\"\", value, currentValue);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.attributeToBe",
	"Comment": "an expectation for checking given webelement has attribute with a specific value",
	"Method": "ExpectedCondition<Boolean> attributeToBe(By locator,String attribute,String value,ExpectedCondition<Boolean> attributeToBe,WebElement element,String attribute,String value){\r\n    currentValue = element.getAttribute(attribute);\r\n    if (currentValue == null || currentValue.isEmpty()) {\r\n        currentValue = element.getCssValue(attribute);\r\n    }\r\n    return value.equals(currentValue);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.attributeToBe",
	"Comment": "an expectation for checking given webelement has attribute with a specific value",
	"Method": "ExpectedCondition<Boolean> attributeToBe(By locator,String attribute,String value,ExpectedCondition<Boolean> attributeToBe,WebElement element,String attribute,String value){\r\n    return String.format(attribute + \" to be \\\"%s\\\". Current \" + attribute + \": \\\"%s\\\"\", value, currentValue);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowMediaPlayer.invokeSeekCompleteListener",
	"Comment": "allows test cases to simulate seek completion by invoking callback.",
	"Method": "void invokeSeekCompleteListener(){\r\n    int duration = getMediaInfo().duration;\r\n    setCurrentPosition(pendingSeek > duration ? duration : pendingSeek < 0 ? 0 : pendingSeek);\r\n    pendingSeek = -1;\r\n    if (state == STARTED) {\r\n        doStart();\r\n    }\r\n    if (seekCompleteListener == null) {\r\n        return;\r\n    }\r\n    seekCompleteListener.onSeekComplete(player);\r\n}"
}, {
	"Path": "org.robolectric.shadows.NativeBitSet64.firstMarkedBit",
	"Comment": "finds the first marked bit in the set. result is undefined if all bits are unmarked.",
	"Method": "int firstMarkedBit(){\r\n    for (int n = 0; n < 64; n++) {\r\n        if (hasBit(n)) {\r\n            return n;\r\n        }\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "org.robolectric.android.AccessibilityUtil.setThrowExceptionForErrors",
	"Comment": "control whether or not to throw exceptions when accessibility errors are found.",
	"Method": "void setThrowExceptionForErrors(boolean throwExceptionForErrors){\r\n    initializeValidator();\r\n    validator.setThrowExceptionForErrors(throwExceptionForErrors);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableReplayTest.testIssue2191_UnsubscribeSource",
	"Comment": "test the basic expectation of operatormulticast via replay",
	"Method": "void testIssue2191_UnsubscribeSource(){\r\n    Consumer<Integer> sourceNext = mock(Consumer.class);\r\n    Action sourceCompleted = mock(Action.class);\r\n    Action sourceUnsubscribed = mock(Action.class);\r\n    Subscriber<Integer> spiedSubscriberBeforeConnect = TestHelper.mockSubscriber();\r\n    Subscriber<Integer> spiedSubscriberAfterConnect = TestHelper.mockSubscriber();\r\n    Flowable<Integer> source = Flowable.just(1, 2);\r\n    ConnectableFlowable<Integer> replay = source.doOnNext(sourceNext).doOnCancel(sourceUnsubscribed).doOnComplete(sourceCompleted).replay();\r\n    replay.subscribe(spiedSubscriberBeforeConnect);\r\n    replay.subscribe(spiedSubscriberBeforeConnect);\r\n    replay.connect();\r\n    replay.subscribe(spiedSubscriberAfterConnect);\r\n    replay.subscribe(spiedSubscriberAfterConnect);\r\n    verify(spiedSubscriberBeforeConnect, times(2)).onSubscribe((Subscription) any());\r\n    verify(spiedSubscriberAfterConnect, times(2)).onSubscribe((Subscription) any());\r\n    verify(sourceNext, times(1)).accept(1);\r\n    verify(sourceNext, times(1)).accept(2);\r\n    verify(sourceCompleted, times(1)).run();\r\n    verifyObserverMock(spiedSubscriberBeforeConnect, 2, 4);\r\n    verifyObserverMock(spiedSubscriberAfterConnect, 2, 4);\r\n    verify(sourceUnsubscribed, never()).run();\r\n    verifyNoMoreInteractions(sourceNext);\r\n    verifyNoMoreInteractions(sourceCompleted);\r\n    verifyNoMoreInteractions(sourceUnsubscribed);\r\n    verifyNoMoreInteractions(spiedSubscriberBeforeConnect);\r\n    verifyNoMoreInteractions(spiedSubscriberAfterConnect);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableReplay.observeOn",
	"Comment": "child observers will observe the events of the connectableobservable on thespecified scheduler.",
	"Method": "ConnectableObservable<T> observeOn(ConnectableObservable<T> co,Scheduler scheduler){\r\n    final Observable<T> observable = co.observeOn(scheduler);\r\n    return RxJavaPlugins.onAssembly(new Replay<T>(co, observable));\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowUserManager.addUserProfile",
	"Comment": "adds a profile associated for the user that the calling process is running on.the user is assigned an arbitrary unique serial number.",
	"Method": "long addUserProfile(UserHandle userHandle){\r\n    long serialNumber = nextUserSerial++;\r\n    userProfiles.put(userHandle, serialNumber);\r\n    return serialNumber;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableOnErrorResumeNextViaFunctionTest.testFunctionThrowsError",
	"Comment": "test that when a function throws an exception this is propagated through onerror.",
	"Method": "void testFunctionThrowsError(){\r\n    Subscription s = mock(Subscription.class);\r\n    TestObservable w = new TestObservable(s, \"one\");\r\n    Function<Throwable, Observable<String>> resume = new Function<Throwable, Observable<String>>() {\r\n        @Override\r\n        public Observable<String> apply(Throwable t1) {\r\n            throw new RuntimeException(\"exception from function\");\r\n        }\r\n    };\r\n    Observable<String> o = Observable.unsafeCreate(w).onErrorResumeNext(resume);\r\n    Observer<String> observer = TestHelper.mockObserver();\r\n    o.subscribe(observer);\r\n    try {\r\n        w.t.join();\r\n    } catch (InterruptedException e) {\r\n        fail(e.getMessage());\r\n    }\r\n    verify(observer, times(1)).onNext(\"one\");\r\n    verify(observer, times(1)).onError(any(Throwable.class));\r\n    verify(observer, times(0)).onComplete();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableOnErrorResumeNextViaFunctionTest.testFunctionThrowsError",
	"Comment": "test that when a function throws an exception this is propagated through onerror.",
	"Method": "void testFunctionThrowsError(){\r\n    throw new RuntimeException(\"exception from function\");\r\n}"
}, {
	"Path": "io.reactivex.internal.functions.ObjectHelper.equals",
	"Comment": "compares two potentially null objects with each other using object.equals.",
	"Method": "boolean equals(Object o1,Object o2){\r\n    return o1 == o2 || (o1 != null && o1.equals(o2));\r\n}"
}, {
	"Path": "org.robolectric.RobolectricTestRunner.getTestLifecycleClass",
	"Comment": "an instance of the returned class will be created for each test invocation.custom testrunner subclasses may wish to override this method to provide alternate configuration.",
	"Method": "Class<? extends TestLifecycle> getTestLifecycleClass(){\r\n    return DefaultTestLifecycle.class;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.getMaxBitmapDimensions",
	"Comment": "in sdk 14 and above, use canvas max bitmap width and height instead of the default 2048, to avoid redundant tiling.",
	"Method": "Point getMaxBitmapDimensions(Canvas canvas){\r\n    int maxWidth = 2048;\r\n    int maxHeight = 2048;\r\n    if (VERSION.SDK_INT >= 14) {\r\n        try {\r\n            maxWidth = (Integer) Canvas.class.getMethod(\"getMaximumBitmapWidth\").invoke(canvas);\r\n            maxHeight = (Integer) Canvas.class.getMethod(\"getMaximumBitmapHeight\").invoke(canvas);\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return new Point(Math.min(maxWidth, maxTileWidth), Math.min(maxHeight, maxTileHeight));\r\n}"
}, {
	"Path": "org.robolectric.Robolectric.flushForegroundThreadScheduler",
	"Comment": "execute all runnables that have been enqueued on the foreground scheduler.",
	"Method": "void flushForegroundThreadScheduler(){\r\n    getForegroundThreadScheduler().advanceToLastPostedRunnable();\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowNotificationManager.setNotificationPolicy",
	"Comment": "currently does not support checking for granted policy access.",
	"Method": "void setNotificationPolicy(Policy policy){\r\n    notificationPolicy = policy;\r\n}"
}, {
	"Path": "org.openqa.selenium.ie.InternetExplorerOptions.useShellWindowsApiToAttachToIe",
	"Comment": "use the windows shellwindows api when attaching to internet explorer.",
	"Method": "InternetExplorerOptions useShellWindowsApiToAttachToIe(){\r\n    return amend(FORCE_WINDOW_SHELL_API, true);\r\n}"
}, {
	"Path": "org.openqa.selenium.ie.InternetExplorerOptions.destructivelyEnsureCleanSession",
	"Comment": "clear the internet explorer cache before launching the browser. when set clears the systemcache for all instances of internet explorer, even those already running when the driveninstance is launched.",
	"Method": "InternetExplorerOptions destructivelyEnsureCleanSession(){\r\n    return amend(IE_ENSURE_CLEAN_SESSION, true);\r\n}"
}, {
	"Path": "io.reactivex.flowable.FlowableSubscriberTest.testRequestFromFinalSubscribeWithRequestValue",
	"Comment": "should request n for whatever the final subscriber asks for.",
	"Method": "void testRequestFromFinalSubscribeWithRequestValue(){\r\n    TestSubscriber<String> s = new TestSubscriber<String>(0L);\r\n    s.request(10);\r\n    final AtomicLong r = new AtomicLong();\r\n    s.onSubscribe(new Subscription() {\r\n        @Override\r\n        public void request(long n) {\r\n            r.set(n);\r\n        }\r\n        @Override\r\n        public void cancel() {\r\n        }\r\n    });\r\n    assertEquals(10, r.get());\r\n}"
}, {
	"Path": "io.reactivex.flowable.FlowableSubscriberTest.testRequestFromFinalSubscribeWithRequestValue",
	"Comment": "should request n for whatever the final subscriber asks for.",
	"Method": "void testRequestFromFinalSubscribeWithRequestValue(){\r\n    r.set(n);\r\n}"
}, {
	"Path": "io.reactivex.flowable.FlowableSubscriberTest.testRequestFromFinalSubscribeWithRequestValue",
	"Comment": "should request n for whatever the final subscriber asks for.",
	"Method": "void testRequestFromFinalSubscribeWithRequestValue(){\r\n}"
}, {
	"Path": "io.reactivex.internal.observers.DeferredScalarDisposable.tryDispose",
	"Comment": "try disposing this disposable and return true if the current thread succeeded.",
	"Method": "boolean tryDispose(){\r\n    return getAndSet(DISPOSED) != DISPOSED;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowNotificationManager.setInterruptionFilter",
	"Comment": "currently does not support checking for granted policy access.",
	"Method": "void setInterruptionFilter(int interruptionFilter){\r\n    currentInteruptionFilter = interruptionFilter;\r\n}"
}, {
	"Path": "org.robolectric.internal.bytecode.ClassInstrumentor.makeClassPublic",
	"Comment": "replaces protected and private class modifiers with public.",
	"Method": "void makeClassPublic(ClassNode clazz){\r\n    clazz.access = (clazz.access | Opcodes.ACC_PUBLIC) & ~(Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowSoundPool.load",
	"Comment": "filedescriptor which would make it difficult to check if a given sound has been placed.",
	"Method": "int load(String path,int priority,int load,Context context,int resId,int priority){\r\n    int soundId = soundIds.getAndIncrement();\r\n    idToRes.put(soundId, resId);\r\n    return soundId;\r\n}"
}, {
	"Path": "retrofit2.adapter.rxjava.RxJavaCallAdapterFactory.create",
	"Comment": "returns an instance which creates synchronous observables that do not operate on any schedulerby default.",
	"Method": "RxJavaCallAdapterFactory create(){\r\n    return new RxJavaCallAdapterFactory(null, false);\r\n}"
}, {
	"Path": "io.reactivex.internal.functions.Functions.castFunction",
	"Comment": "returns a function that cast the incoming values via a class object.",
	"Method": "Function<T, U> castFunction(Class<U> target){\r\n    return new CastToClass<T, U>(target);\r\n}"
}, {
	"Path": "org.robolectric.util.Scheduler.advanceBy",
	"Comment": "run all runnables that are scheduled to run in the next time interval.",
	"Method": "boolean advanceBy(long interval,boolean advanceBy,long amount,TimeUnit unit){\r\n    long endingTime = currentTime + unit.toMillis(amount);\r\n    return advanceTo(endingTime);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableReplayTest.testIssue2191_SchedulerUnsubscribe",
	"Comment": "specifically test interaction with a scheduler with subscribeon.",
	"Method": "void testIssue2191_SchedulerUnsubscribe(){\r\n    Consumer<Integer> sourceNext = mock(Consumer.class);\r\n    Action sourceCompleted = mock(Action.class);\r\n    Action sourceUnsubscribed = mock(Action.class);\r\n    final Scheduler mockScheduler = mock(Scheduler.class);\r\n    final Disposable mockSubscription = mock(Disposable.class);\r\n    Worker spiedWorker = workerSpy(mockSubscription);\r\n    Subscriber<Integer> mockObserverBeforeConnect = TestHelper.mockSubscriber();\r\n    Subscriber<Integer> mockObserverAfterConnect = TestHelper.mockSubscriber();\r\n    when(mockScheduler.createWorker()).thenReturn(spiedWorker);\r\n    ConnectableFlowable<Integer> replay = Flowable.just(1, 2, 3).doOnNext(sourceNext).doOnCancel(sourceUnsubscribed).doOnComplete(sourceCompleted).subscribeOn(mockScheduler).replay();\r\n    replay.subscribe(mockObserverBeforeConnect);\r\n    replay.subscribe(mockObserverBeforeConnect);\r\n    replay.connect();\r\n    replay.subscribe(mockObserverAfterConnect);\r\n    replay.subscribe(mockObserverAfterConnect);\r\n    verify(mockObserverBeforeConnect, times(2)).onSubscribe((Subscription) any());\r\n    verify(mockObserverAfterConnect, times(2)).onSubscribe((Subscription) any());\r\n    verify(sourceNext, times(1)).accept(1);\r\n    verify(sourceNext, times(1)).accept(2);\r\n    verify(sourceNext, times(1)).accept(3);\r\n    verify(sourceCompleted, times(1)).run();\r\n    verify(mockScheduler, times(1)).createWorker();\r\n    verify(spiedWorker, times(1)).schedule((Runnable) notNull());\r\n    verifyObserverMock(mockObserverBeforeConnect, 2, 6);\r\n    verifyObserverMock(mockObserverAfterConnect, 2, 6);\r\n    verify(spiedWorker, times(1)).dispose();\r\n    verify(sourceUnsubscribed, never()).run();\r\n    verifyNoMoreInteractions(sourceNext);\r\n    verifyNoMoreInteractions(sourceCompleted);\r\n    verifyNoMoreInteractions(sourceUnsubscribed);\r\n    verifyNoMoreInteractions(spiedWorker);\r\n    verifyNoMoreInteractions(mockSubscription);\r\n    verifyNoMoreInteractions(mockScheduler);\r\n    verifyNoMoreInteractions(mockObserverBeforeConnect);\r\n    verifyNoMoreInteractions(mockObserverAfterConnect);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.FluentWait.withMessage",
	"Comment": "sets the message to be evaluated and displayed when time expires.",
	"Method": "FluentWait<T> withMessage(String message,FluentWait<T> withMessage,Supplier<String> messageSupplier){\r\n    this.messageSupplier = messageSupplier;\r\n    return this;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.wheelhorizontal.AbstractWheel.isCyclic",
	"Comment": "tests if spinnerwheel is cyclic. that means before the 1st item there is shown the last one",
	"Method": "boolean isCyclic(){\r\n    return mIsCyclic;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowCamera.invokePreviewCallback",
	"Comment": "allows test cases to invoke the preview callback, to simulate a frame of camera data.",
	"Method": "void invokePreviewCallback(byte[] data){\r\n    if (previewCallback != null) {\r\n        previewCallback.onPreviewFrame(data, realCamera);\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowMediaPlayer.getDurationRaw",
	"Comment": "retrieves the current duration without doing the state checking that theemulated version does.",
	"Method": "int getDurationRaw(){\r\n    return getMediaInfo().duration;\r\n}"
}, {
	"Path": "io.reactivex.subjects.SingleSubject.getThrowable",
	"Comment": "returns the terminal error if this singlesubject has been terminated with an error, null otherwise.",
	"Method": "Throwable getThrowable(){\r\n    if (observers.get() == TERMINATED) {\r\n        return error;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openqa.selenium.remote.http.HttpRequest.getQueryParameter",
	"Comment": "get a query parameter. the implementation will take care of decoding from the percent encoding.",
	"Method": "String getQueryParameter(String name){\r\n    return queryParameters.get(name).stream().findFirst().orElse(null);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowNotificationManager.deleteNotificationChannelGroup",
	"Comment": "delete a notification channel group and all notification channels associated with the group.this method will not notify any notificationlistenerservice of resulting changes tonotification channel groups nor to notification channels.",
	"Method": "void deleteNotificationChannelGroup(String channelGroupId){\r\n    if (getNotificationChannelGroup(channelGroupId) != null) {\r\n        for (Object channel : getNotificationChannels()) {\r\n            String groupId = ReflectionHelpers.callInstanceMethod(channel, \"getGroup\");\r\n            if (channelGroupId.equals(groupId)) {\r\n                String channelId = ReflectionHelpers.callInstanceMethod(channel, \"getId\");\r\n                deleteNotificationChannel(channelId);\r\n            }\r\n        }\r\n        notificationChannelGroups.remove(channelGroupId);\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.internal.functions.Functions.justFunction",
	"Comment": "returns a function that ignores its parameter and returns the given value.",
	"Method": "Function<T, U> justFunction(U value){\r\n    return new JustValue<T, U>(value);\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.setZoomEnabled",
	"Comment": "enable or disable zoom gesture detection. disabling zoom locks the the current scale.",
	"Method": "void setZoomEnabled(boolean zoomEnabled){\r\n    this.zoomEnabled = zoomEnabled;\r\n}"
}, {
	"Path": "com.github.scribejava.core.oauth.OAuth20Service.getAccessToken",
	"Comment": "start the request to retrieve the access token. the optionally provided callback will be called with the tokenwhen it is available.",
	"Method": "OAuth2AccessToken getAccessToken(String code,OAuth2AccessToken getAccessToken,String code,String pkceCodeVerifier,Future<OAuth2AccessToken> getAccessToken,String code,OAuthAsyncRequestCallback<OAuth2AccessToken> callback,String pkceCodeVerifier,Future<OAuth2AccessToken> getAccessToken,String code,OAuthAsyncRequestCallback<OAuth2AccessToken> callback){\r\n    return getAccessToken(code, callback, null);\r\n}"
}, {
	"Path": "com.vondear.rxui.view.dialog.wheel.WheelRecycle.addView",
	"Comment": "adds view to specified cache. creates a cache list if it is null.",
	"Method": "List<View> addView(View view,List<View> cache){\r\n    if (cache == null) {\r\n        cache = new LinkedList<View>();\r\n    }\r\n    cache.add(view);\r\n    return cache;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.ImageSource.tilingEnabled",
	"Comment": "enable tiling of the image. this does not apply to preview images which are always loaded as a single bitmap.,and tiling cannot be disabled when displaying a region of the source image.",
	"Method": "ImageSource tilingEnabled(){\r\n    return tiling(true);\r\n}"
}, {
	"Path": "com.vondear.camera.SizeMap.remove",
	"Comment": "removes the specified aspect ratio and all sizes associated with it.",
	"Method": "void remove(AspectRatio ratio){\r\n    mRatios.remove(ratio);\r\n}"
}, {
	"Path": "org.openqa.selenium.logging.LoggingPreferences.addPreferences",
	"Comment": "adds the given logging preferences giving them precedence over existingpreferences.",
	"Method": "LoggingPreferences addPreferences(LoggingPreferences prefs){\r\n    if (prefs == null) {\r\n        return this;\r\n    }\r\n    for (String logType : prefs.getEnabledLogTypes()) {\r\n        enable(logType, prefs.getLevel(logType));\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.openqa.selenium.ie.InternetExplorerOptions.useCreateProcessApiToLaunchIe",
	"Comment": "force the use of the windows createprocess api when launching internet explorer.",
	"Method": "InternetExplorerOptions useCreateProcessApiToLaunchIe(){\r\n    return amend(FORCE_CREATE_PROCESS, true);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableReplay.create",
	"Comment": "creates a operatorreplay instance to replay values of the given source observable.",
	"Method": "ConnectableObservable<T> create(ObservableSource<T> source,int bufferSize,ConnectableObservable<T> create,ObservableSource<T> source,long maxAge,TimeUnit unit,Scheduler scheduler,ConnectableObservable<T> create,ObservableSource<T> source,long maxAge,TimeUnit unit,Scheduler scheduler,int bufferSize,ConnectableObservable<T> create,ObservableSource<T> source,BufferSupplier<T> bufferFactory){\r\n    final AtomicReference<ReplayObserver<T>> curr = new AtomicReference<ReplayObserver<T>>();\r\n    ObservableSource<T> onSubscribe = new ReplaySource<T>(curr, bufferFactory);\r\n    return RxJavaPlugins.onAssembly(new ObservableReplay<T>(onSubscribe, source, curr, bufferFactory));\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableSwitchTest.testIssue2654",
	"Comment": "the upstream producer hijacked the switch producer stopping the requests aimed at the inner observables.",
	"Method": "void testIssue2654(){\r\n    Flowable<String> oneItem = Flowable.just(\"Hello\").mergeWith(Flowable.<String>never());\r\n    Flowable<String> src = oneItem.switchMap(new Function<String, Flowable<String>>() {\r\n        @Override\r\n        public Flowable<String> apply(final String s) {\r\n            return Flowable.just(s).mergeWith(Flowable.interval(10, TimeUnit.MILLISECONDS).map(new Function<Long, String>() {\r\n                @Override\r\n                public String apply(Long i) {\r\n                    return s + \" \" + i;\r\n                }\r\n            })).take(250);\r\n        }\r\n    }).share();\r\n    TestSubscriber<String> ts = new TestSubscriber<String>() {\r\n        @Override\r\n        public void onNext(String t) {\r\n            super.onNext(t);\r\n            if (valueCount() == 250) {\r\n                onComplete();\r\n                dispose();\r\n            }\r\n        }\r\n    };\r\n    src.subscribe(ts);\r\n    ts.awaitTerminalEvent(10, TimeUnit.SECONDS);\r\n    System.out.println(\"> testIssue2654: \" + ts.valueCount());\r\n    ts.assertTerminated();\r\n    ts.assertNoErrors();\r\n    Assert.assertEquals(250, ts.valueCount());\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableSwitchTest.testIssue2654",
	"Comment": "the upstream producer hijacked the switch producer stopping the requests aimed at the inner observables.",
	"Method": "void testIssue2654(){\r\n    return Flowable.just(s).mergeWith(Flowable.interval(10, TimeUnit.MILLISECONDS).map(new Function<Long, String>() {\r\n        @Override\r\n        public String apply(Long i) {\r\n            return s + \" \" + i;\r\n        }\r\n    })).take(250);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableSwitchTest.testIssue2654",
	"Comment": "the upstream producer hijacked the switch producer stopping the requests aimed at the inner observables.",
	"Method": "void testIssue2654(){\r\n    return s + \" \" + i;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableSwitchTest.testIssue2654",
	"Comment": "the upstream producer hijacked the switch producer stopping the requests aimed at the inner observables.",
	"Method": "void testIssue2654(){\r\n    super.onNext(t);\r\n    if (valueCount() == 250) {\r\n        onComplete();\r\n        dispose();\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.internal.util.Pow2.roundToPowerOfTwo",
	"Comment": "find the next larger positive power of two value up from the given value. if value is a power of two thenthis value will be returned.",
	"Method": "int roundToPowerOfTwo(int value){\r\n    return 1 << (32 - Integer.numberOfLeadingZeros(value - 1));\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.setBitmapDecoderFactory",
	"Comment": "swap the default bitmap decoder implementation for one of your own. you must do this before setting the image file orasset, and you cannot use a custom decoder when using layout xml to set an asset name.",
	"Method": "void setBitmapDecoderFactory(DecoderFactory<? extends ImageDecoder> bitmapDecoderFactory){\r\n    if (bitmapDecoderFactory == null) {\r\n        throw new IllegalArgumentException(\"Decoder factory cannot be set to null\");\r\n    }\r\n    this.bitmapDecoderFactory = bitmapDecoderFactory;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.popupwindows.tools.RxPopupViewCoordinatesFinder.getYCenteringOffset",
	"Comment": "calculate the amount of movement need to be taken inorder to center tipon y axis",
	"Method": "int getYCenteringOffset(View tipView,RxPopupView rxPopupView){\r\n    return (rxPopupView.getAnchorView().getHeight() - tipView.getMeasuredHeight()) / 2;\r\n}"
}, {
	"Path": "org.openqa.selenium.remote.http.HttpResponse.getTargetHost",
	"Comment": "returns the host this response was received from, or null if it was not set.",
	"Method": "String getTargetHost(){\r\n    return (String) getAttribute(HTTP_TARGET_HOST);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.FluentWait.timeoutException",
	"Comment": "throws a timeout exception. this method may be overridden to throw an exception that isidiomatic for a particular test infrastructure, such as an assertionerror in junit4.",
	"Method": "RuntimeException timeoutException(String message,Throwable lastException){\r\n    throw new TimeoutException(message, lastException);\r\n}"
}, {
	"Path": "io.reactivex.processors.SerializedProcessor.emitLoop",
	"Comment": "loops until all notifications in the queue has been processed.",
	"Method": "void emitLoop(){\r\n    for (; ; ) {\r\n        AppendOnlyLinkedArrayList<Object> q;\r\n        synchronized (this) {\r\n            q = queue;\r\n            if (q == null) {\r\n                emitting = false;\r\n                return;\r\n            }\r\n            queue = null;\r\n        }\r\n        q.accept(actual);\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textToBePresentInElementLocated",
	"Comment": "an expectation for checking if the given text is present in the element that matches the givenlocator.",
	"Method": "ExpectedCondition<Boolean> textToBePresentInElementLocated(By locator,String text){\r\n    return new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            try {\r\n                String elementText = driver.findElement(locator).getText();\r\n                return elementText.contains(text);\r\n            } catch (StaleElementReferenceException e) {\r\n                return null;\r\n            }\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"text ('%s') to be present in element found by %s\", text, locator);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textToBePresentInElementLocated",
	"Comment": "an expectation for checking if the given text is present in the element that matches the givenlocator.",
	"Method": "ExpectedCondition<Boolean> textToBePresentInElementLocated(By locator,String text){\r\n    try {\r\n        String elementText = driver.findElement(locator).getText();\r\n        return elementText.contains(text);\r\n    } catch (StaleElementReferenceException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textToBePresentInElementLocated",
	"Comment": "an expectation for checking if the given text is present in the element that matches the givenlocator.",
	"Method": "ExpectedCondition<Boolean> textToBePresentInElementLocated(By locator,String text){\r\n    return String.format(\"text ('%s') to be present in element found by %s\", text, locator);\r\n}"
}, {
	"Path": "org.robolectric.shadows.NativeBitSet64.getIndexOfBit",
	"Comment": "gets the index of the specified bit in the set, which is the number of marked bits that appearbefore the specified bit.",
	"Method": "int getIndexOfBit(int n){\r\n    int numMarkedBits = 0;\r\n    for (int i = 0; i < n; i++) {\r\n        if (hasBit(i)) {\r\n            numMarkedBits++;\r\n        }\r\n    }\r\n    return numMarkedBits;\r\n}"
}, {
	"Path": "io.reactivex.subjects.CompletableSubject.hasThrowable",
	"Comment": "returns true if this completablesubject has been terminated with an error.",
	"Method": "boolean hasThrowable(){\r\n    return observers.get() == TERMINATED && error != null;\r\n}"
}, {
	"Path": "org.openqa.selenium.opera.OperaOptions.setBinary",
	"Comment": "sets the path to the opera executable. this path should exist on themachine which will launch opera. the path should either be absolute orrelative to the location of running operadriver server.",
	"Method": "OperaOptions setBinary(File path,OperaOptions setBinary,String path){\r\n    binary = checkNotNull(path);\r\n    return this;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowMediaPlayer.setCurrentPosition",
	"Comment": "sets the current position, bypassing the normal state checking. use withcare.",
	"Method": "void setCurrentPosition(int position){\r\n    startOffset = position;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableObserveOnTest.testObserveOnWithThreadPoolScheduler",
	"Comment": "confirm that running on a threadpoolscheduler allows multiple threads but is still ordered.",
	"Method": "void testObserveOnWithThreadPoolScheduler(){\r\n    final AtomicInteger count = new AtomicInteger();\r\n    final int _multiple = 99;\r\n    Flowable.range(1, 100000).map(new Function<Integer, Integer>() {\r\n        @Override\r\n        public Integer apply(Integer t1) {\r\n            return t1 * _multiple;\r\n        }\r\n    }).observeOn(Schedulers.computation()).blockingForEach(new Consumer<Integer>() {\r\n        @Override\r\n        public void accept(Integer t1) {\r\n            assertEquals(count.incrementAndGet() * _multiple, t1.intValue());\r\n            String name = Thread.currentThread().getName();\r\n            assertFalse(\"Wrong thread name: \" + name, name.startsWith(\"Rx\"));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableObserveOnTest.testObserveOnWithThreadPoolScheduler",
	"Comment": "confirm that running on a threadpoolscheduler allows multiple threads but is still ordered.",
	"Method": "void testObserveOnWithThreadPoolScheduler(){\r\n    return t1 * _multiple;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableObserveOnTest.testObserveOnWithThreadPoolScheduler",
	"Comment": "confirm that running on a threadpoolscheduler allows multiple threads but is still ordered.",
	"Method": "void testObserveOnWithThreadPoolScheduler(){\r\n    assertEquals(count.incrementAndGet() * _multiple, t1.intValue());\r\n    String name = Thread.currentThread().getName();\r\n    assertFalse(\"Wrong thread name: \" + name, name.startsWith(\"Rx\"));\r\n}"
}, {
	"Path": "io.reactivex.internal.subscriptions.BooleanSubscription.isCancelled",
	"Comment": "returns true if this booleansubscription has been cancelled.",
	"Method": "boolean isCancelled(){\r\n    return get();\r\n}"
}, {
	"Path": "org.openqa.selenium.interactions.touch.TouchActions.singleTap",
	"Comment": "allows the execution of single tap on the screen, analogous to click using a mouse.",
	"Method": "TouchActions singleTap(WebElement onElement){\r\n    action.addAction(new SingleTapAction(touchScreen, (Locatable) onElement));\r\n    return this;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.elementToBeClickable",
	"Comment": "an expectation for checking an element is visible and enabled such that you can click it.",
	"Method": "ExpectedCondition<WebElement> elementToBeClickable(By locator,ExpectedCondition<WebElement> elementToBeClickable,WebElement element){\r\n    return new ExpectedCondition<WebElement>() {\r\n        @Override\r\n        public WebElement apply(WebDriver driver) {\r\n            WebElement visibleElement = visibilityOf(element).apply(driver);\r\n            try {\r\n                if (visibleElement != null && visibleElement.isEnabled()) {\r\n                    return visibleElement;\r\n                }\r\n                return null;\r\n            } catch (StaleElementReferenceException e) {\r\n                return null;\r\n            }\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"element to be clickable: \" + element;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.elementToBeClickable",
	"Comment": "an expectation for checking an element is visible and enabled such that you can click it.",
	"Method": "ExpectedCondition<WebElement> elementToBeClickable(By locator,ExpectedCondition<WebElement> elementToBeClickable,WebElement element){\r\n    WebElement visibleElement = visibilityOf(element).apply(driver);\r\n    try {\r\n        if (visibleElement != null && visibleElement.isEnabled()) {\r\n            return visibleElement;\r\n        }\r\n        return null;\r\n    } catch (StaleElementReferenceException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.elementToBeClickable",
	"Comment": "an expectation for checking an element is visible and enabled such that you can click it.",
	"Method": "ExpectedCondition<WebElement> elementToBeClickable(By locator,ExpectedCondition<WebElement> elementToBeClickable,WebElement element){\r\n    return \"element to be clickable: \" + element;\r\n}"
}, {
	"Path": "io.reactivex.observers.TestObserver.hasSubscription",
	"Comment": "returns true if this testobserver received a subscription.",
	"Method": "boolean hasSubscription(){\r\n    return upstream.get() != null;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableOnErrorReturnTest.testFunctionThrowsError",
	"Comment": "test that when a function throws an exception this is propagated through onerror.",
	"Method": "void testFunctionThrowsError(){\r\n    TestObservable f = new TestObservable(\"one\");\r\n    Observable<String> w = Observable.unsafeCreate(f);\r\n    final AtomicReference<Throwable> capturedException = new AtomicReference<Throwable>();\r\n    Observable<String> observable = w.onErrorReturn(new Function<Throwable, String>() {\r\n        @Override\r\n        public String apply(Throwable e) {\r\n            capturedException.set(e);\r\n            throw new RuntimeException(\"exception from function\");\r\n        }\r\n    });\r\n    Observer<String> observer = TestHelper.mockObserver();\r\n    observable.subscribe(observer);\r\n    try {\r\n        f.t.join();\r\n    } catch (InterruptedException e) {\r\n        fail(e.getMessage());\r\n    }\r\n    verify(observer, times(1)).onNext(\"one\");\r\n    verify(observer, times(1)).onError(any(Throwable.class));\r\n    verify(observer, times(0)).onComplete();\r\n    assertNotNull(capturedException.get());\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableOnErrorReturnTest.testFunctionThrowsError",
	"Comment": "test that when a function throws an exception this is propagated through onerror.",
	"Method": "void testFunctionThrowsError(){\r\n    capturedException.set(e);\r\n    throw new RuntimeException(\"exception from function\");\r\n}"
}, {
	"Path": "io.reactivex.disposables.Disposables.fromSubscription",
	"Comment": "construct a disposable by wrapping a subscription that iscancelled exactly once when the disposable is disposed.",
	"Method": "Disposable fromSubscription(Subscription subscription){\r\n    ObjectHelper.requireNonNull(subscription, \"subscription is null\");\r\n    return new SubscriptionDisposable(subscription);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableConcatTest.testSimpleAsyncConcat",
	"Comment": "simple concat of 2 asynchronous observables ensuring it emits in correct order.",
	"Method": "void testSimpleAsyncConcat(){\r\n    Observer<String> observer = TestHelper.mockObserver();\r\n    TestObservable<String> o1 = new TestObservable<String>(\"one\", \"two\", \"three\");\r\n    TestObservable<String> o2 = new TestObservable<String>(\"four\", \"five\", \"six\");\r\n    Observable.concat(Observable.unsafeCreate(o1), Observable.unsafeCreate(o2)).subscribe(observer);\r\n    try {\r\n        o1.t.join();\r\n        o2.t.join();\r\n    } catch (Throwable e) {\r\n        throw new RuntimeException(\"failed waiting on threads\");\r\n    }\r\n    InOrder inOrder = inOrder(observer);\r\n    inOrder.verify(observer, times(1)).onNext(\"one\");\r\n    inOrder.verify(observer, times(1)).onNext(\"two\");\r\n    inOrder.verify(observer, times(1)).onNext(\"three\");\r\n    inOrder.verify(observer, times(1)).onNext(\"four\");\r\n    inOrder.verify(observer, times(1)).onNext(\"five\");\r\n    inOrder.verify(observer, times(1)).onNext(\"six\");\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowParcel.nativeReadBlob",
	"Comment": "nativereadblob was introduced in lollipop, thus no need for a int nativeptr variant",
	"Method": "byte[] nativeReadBlob(long nativePtr){\r\n    return nativeCreateByteArray(nativePtr);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.and",
	"Comment": "an expectation with the logical and condition of the given list of conditions.each condition is checked until all of them return true or not null",
	"Method": "ExpectedCondition<Boolean> and(ExpectedCondition<?> conditions){\r\n    return new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            for (ExpectedCondition<?> condition : conditions) {\r\n                Object result = condition.apply(driver);\r\n                if (result instanceof Boolean) {\r\n                    if (Boolean.FALSE.equals(result)) {\r\n                        return false;\r\n                    }\r\n                }\r\n                if (result == null) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            StringBuilder message = new StringBuilder(\"all conditions to be valid: \");\r\n            Joiner.on(\" && \").appendTo(message, conditions);\r\n            return message.toString();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.and",
	"Comment": "an expectation with the logical and condition of the given list of conditions.each condition is checked until all of them return true or not null",
	"Method": "ExpectedCondition<Boolean> and(ExpectedCondition<?> conditions){\r\n    for (ExpectedCondition<?> condition : conditions) {\r\n        Object result = condition.apply(driver);\r\n        if (result instanceof Boolean) {\r\n            if (Boolean.FALSE.equals(result)) {\r\n                return false;\r\n            }\r\n        }\r\n        if (result == null) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.and",
	"Comment": "an expectation with the logical and condition of the given list of conditions.each condition is checked until all of them return true or not null",
	"Method": "ExpectedCondition<Boolean> and(ExpectedCondition<?> conditions){\r\n    StringBuilder message = new StringBuilder(\"all conditions to be valid: \");\r\n    Joiner.on(\" && \").appendTo(message, conditions);\r\n    return message.toString();\r\n}"
}, {
	"Path": "io.reactivex.subjects.PublishSubject.add",
	"Comment": "tries to add the given subscriber to the subscribers array atomicallyor returns false if the subject has terminated.",
	"Method": "boolean add(PublishDisposable<T> ps){\r\n    for (; ; ) {\r\n        PublishDisposable<T>[] a = subscribers.get();\r\n        if (a == TERMINATED) {\r\n            return false;\r\n        }\r\n        int n = a.length;\r\n        @SuppressWarnings(\"unchecked\")\r\n        PublishDisposable<T>[] b = new PublishDisposable[n + 1];\r\n        System.arraycopy(a, 0, b, 0, n);\r\n        b[n] = ps;\r\n        if (subscribers.compareAndSet(a, b)) {\r\n            return true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.MutableCapabilities.merge",
	"Comment": "merge the extra capabilities provided into this desiredcapabilities instance. if capabilitieswith the same name exist in this instance, they will be overridden by the values from theextracapabilities object.",
	"Method": "MutableCapabilities merge(Capabilities extraCapabilities){\r\n    if (extraCapabilities == null) {\r\n        return this;\r\n    }\r\n    extraCapabilities.asMap().forEach(this::setCapability);\r\n    return this;\r\n}"
}, {
	"Path": "org.openqa.selenium.remote.RemoteWebDriver.setFileDetector",
	"Comment": "set the file detector to be used when sending keyboard input. by default, this is set to a filedetector that does nothing.",
	"Method": "void setFileDetector(FileDetector detector){\r\n    if (detector == null) {\r\n        throw new WebDriverException(\"You may not set a file detector that is null\");\r\n    }\r\n    fileDetector = detector;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowAppWidgetManager.setAlwaysRecreateViewsDuringUpdate",
	"Comment": "enables testing of widget behavior when all of the views are recreated on everyupdate. this is useful for ensuring that your widget will behave correctly evenif it is restarted by the os between events.",
	"Method": "void setAlwaysRecreateViewsDuringUpdate(boolean alwaysRecreate){\r\n    alwaysRecreateViewsDuringUpdate = alwaysRecreate;\r\n}"
}, {
	"Path": "org.robolectric.util.ReflectionHelpers.callInstanceMethod",
	"Comment": "reflectively call an instance method on an object on a specific class.",
	"Method": "R callInstanceMethod(Object instance,String methodName,ClassParameter<?> classParameters,R callInstanceMethod,Class<?> cl,Object instance,String methodName,ClassParameter<?> classParameters){\r\n    try {\r\n        final Class<?>[] classes = ClassParameter.getClasses(classParameters);\r\n        final Object[] values = ClassParameter.getValues(classParameters);\r\n        Method method = cl.getDeclaredMethod(methodName, classes);\r\n        method.setAccessible(true);\r\n        if (Modifier.isStatic(method.getModifiers())) {\r\n            throw new IllegalArgumentException(method + \" is static\");\r\n        }\r\n        return (R) method.invoke(instance, values);\r\n    } catch (InvocationTargetException e) {\r\n        if (e.getTargetException() instanceof RuntimeException) {\r\n            throw (RuntimeException) e.getTargetException();\r\n        }\r\n        if (e.getTargetException() instanceof Error) {\r\n            throw (Error) e.getTargetException();\r\n        }\r\n        throw new RuntimeException(e.getTargetException());\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowAudioManager.requestAudioFocus",
	"Comment": "provides a mock like interface for the requestaudiofocus method by storing the requestobject for later inspection and returning the value specified in setnextfocusrequestresponse.",
	"Method": "int requestAudioFocus(android.media.AudioManager.OnAudioFocusChangeListener l,int streamType,int durationHint,int requestAudioFocus,android.media.AudioFocusRequest audioFocusRequest){\r\n    lastAudioFocusRequest = new AudioFocusRequest(audioFocusRequest);\r\n    return nextResponseValue;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableOnErrorReturnTest.testFunctionThrowsError",
	"Comment": "test that when a function throws an exception this is propagated through onerror.",
	"Method": "void testFunctionThrowsError(){\r\n    TestFlowable f = new TestFlowable(\"one\");\r\n    Flowable<String> w = Flowable.unsafeCreate(f);\r\n    final AtomicReference<Throwable> capturedException = new AtomicReference<Throwable>();\r\n    Flowable<String> flowable = w.onErrorReturn(new Function<Throwable, String>() {\r\n        @Override\r\n        public String apply(Throwable e) {\r\n            capturedException.set(e);\r\n            throw new RuntimeException(\"exception from function\");\r\n        }\r\n    });\r\n    Subscriber<String> subscriber = TestHelper.mockSubscriber();\r\n    flowable.subscribe(subscriber);\r\n    try {\r\n        f.t.join();\r\n    } catch (InterruptedException e) {\r\n        fail(e.getMessage());\r\n    }\r\n    verify(subscriber, times(1)).onNext(\"one\");\r\n    verify(subscriber, times(1)).onError(any(Throwable.class));\r\n    verify(subscriber, times(0)).onComplete();\r\n    assertNotNull(capturedException.get());\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableOnErrorReturnTest.testFunctionThrowsError",
	"Comment": "test that when a function throws an exception this is propagated through onerror.",
	"Method": "void testFunctionThrowsError(){\r\n    capturedException.set(e);\r\n    throw new RuntimeException(\"exception from function\");\r\n}"
}, {
	"Path": "io.reactivex.internal.schedulers.NewThreadWorker.schedulePeriodicallyDirect",
	"Comment": "schedules the given runnable periodically on the underlying executor directlyand returns its future wrapped into a disposable.",
	"Method": "Disposable schedulePeriodicallyDirect(Runnable run,long initialDelay,long period,TimeUnit unit){\r\n    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\r\n    if (period <= 0L) {\r\n        InstantPeriodicTask periodicWrapper = new InstantPeriodicTask(decoratedRun, executor);\r\n        try {\r\n            Future<?> f;\r\n            if (initialDelay <= 0L) {\r\n                f = executor.submit(periodicWrapper);\r\n            } else {\r\n                f = executor.schedule(periodicWrapper, initialDelay, unit);\r\n            }\r\n            periodicWrapper.setFirst(f);\r\n        } catch (RejectedExecutionException ex) {\r\n            RxJavaPlugins.onError(ex);\r\n            return EmptyDisposable.INSTANCE;\r\n        }\r\n        return periodicWrapper;\r\n    }\r\n    ScheduledDirectPeriodicTask task = new ScheduledDirectPeriodicTask(decoratedRun);\r\n    try {\r\n        Future<?> f = executor.scheduleAtFixedRate(task, initialDelay, period, unit);\r\n        task.setFuture(f);\r\n        return task;\r\n    } catch (RejectedExecutionException ex) {\r\n        RxJavaPlugins.onError(ex);\r\n        return EmptyDisposable.INSTANCE;\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowAccessibilityNodeInfo.getDrawingOrder",
	"Comment": "returns the drawing order of the view corresponding to this node.",
	"Method": "int getDrawingOrder(){\r\n    return drawingOrder;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowAudioManager.abandonAudioFocusRequest",
	"Comment": "provides a mock like interface for the abandonaudiofocusrequest method by storing the requestobject for later inspection and returning the value specified in setnextfocusrequestresponse.",
	"Method": "int abandonAudioFocusRequest(android.media.AudioFocusRequest audioFocusRequest){\r\n    lastAbandonedAudioFocusRequest = audioFocusRequest;\r\n    return nextResponseValue;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.isReady",
	"Comment": "call to find whether the view is initialised, has dimensions, and will display an image onthe next draw. if a preview has been provided, it may be the preview that will be displayedand the full size image may still be loading. if no preview was provided, this is called oncethe base layer tiles of the full size image are loaded.",
	"Method": "boolean isReady(){\r\n    return readySent;\r\n}"
}, {
	"Path": "org.robolectric.shadows.CachedPathIteratorFactory.getPointAtLength",
	"Comment": "returns the estimated position along a path of the given length.",
	"Method": "void getPointAtLength(int type,float[] coords,float lastX,float lastY,float t,float[] point){\r\n    if (type == PathIterator.SEG_LINETO) {\r\n        point[0] = lastX + (coords[0] - lastX) * t;\r\n        point[1] = lastY + (coords[1] - lastY) * t;\r\n        return;\r\n    }\r\n    float[] curve = new float[8];\r\n    int lastPointIndex = (getNumberOfPoints(type) - 1) * 2;\r\n    System.arraycopy(coords, 0, curve, 2, coords.length);\r\n    curve[0] = lastX;\r\n    curve[1] = lastY;\r\n    if (type == PathIterator.SEG_CUBICTO) {\r\n        cubicCurveSegment(curve, 0f, t);\r\n    } else {\r\n        quadCurveSegment(curve, 0f, t);\r\n    }\r\n    point[0] = curve[2 + lastPointIndex];\r\n    point[1] = curve[2 + lastPointIndex + 1];\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableReplay.multicastSelector",
	"Comment": "given a connectable observable factory, it multicasts over the generatedconnectableobservable via a selector function.",
	"Method": "Observable<R> multicastSelector(Callable<? extends ConnectableObservable<U>> connectableFactory,Function<? super Observable<U>, ? extends ObservableSource<R>> selector){\r\n    return RxJavaPlugins.onAssembly(new MulticastReplay<R, U>(connectableFactory, selector));\r\n}"
}, {
	"Path": "org.robolectric.util.Scheduler.areAnyRunnable",
	"Comment": "determine if any enqueued runnables are enqueued before the current time.",
	"Method": "boolean areAnyRunnable(){\r\n    return nextTaskIsScheduledBefore(currentTime);\r\n}"
}, {
	"Path": "com.vondear.rxui.view.dialog.RxDialogWheelYearMonthDay.updateDays",
	"Comment": "updates mdayview wheel. sets max mdays according to selected mmonthview and myearview",
	"Method": "void updateDays(WheelView year,WheelView month,WheelView day){\r\n    mCalendar.set(Calendar.YEAR, beginYear + year.getCurrentItem());\r\n    mCalendar.set(Calendar.MONTH, month.getCurrentItem());\r\n    int maxDay = mCalendar.getActualMaximum(Calendar.DAY_OF_MONTH);\r\n    int maxDays = RxTimeTool.getDaysByYearMonth(beginYear + year.getCurrentItem(), month.getCurrentItem() + 1);\r\n    day.setViewAdapter(new DateNumericAdapter(mContext, 1, maxDays, mCalendar.get(Calendar.DAY_OF_MONTH) - 1));\r\n    int curDay = Math.min(maxDays, day.getCurrentItem() + 1);\r\n    day.setCurrentItem(curDay - 1, true);\r\n}"
}, {
	"Path": "org.robolectric.shadows.httpclient.DefaultRequestDirector.releaseConnection",
	"Comment": "returns the connection back to the connection managerand prepares for retrieving a new connection duringthe next request.",
	"Method": "void releaseConnection(){\r\n    try {\r\n        managedConn.releaseConnection();\r\n    } catch (IOException ignored) {\r\n        this.log.debug(\"IOException releasing connection\", ignored);\r\n    }\r\n    managedConn = null;\r\n}"
}, {
	"Path": "org.robolectric.res.android.Chunk.header_size",
	"Comment": "returns the size of the header. caller need not worry about endianness.",
	"Method": "int header_size(){\r\n    return dtohs(device_chunk_.headerSize);\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.checkReady",
	"Comment": "check whether view and image dimensions are known and either a preview, full size image orbase layer tiles are loaded. first time, send ready event to listener. the next draw willdisplay an image.",
	"Method": "boolean checkReady(){\r\n    boolean ready = getWidth() > 0 && getHeight() > 0 && sWidth > 0 && sHeight > 0 && (bitmap != null || isBaseLayerReady());\r\n    if (!readySent && ready) {\r\n        preDraw();\r\n        readySent = true;\r\n        onReady();\r\n        if (onImageEventListener != null) {\r\n            onImageEventListener.onReady();\r\n        }\r\n    }\r\n    return ready;\r\n}"
}, {
	"Path": "org.openqa.selenium.safari.SafariOptions.setAutomaticInspection",
	"Comment": "instruct the safaridriver to enable the automatic inspection if true, otherwise disablethe automatic inspection. defaults to disabling the automatic inspection.",
	"Method": "SafariOptions setAutomaticInspection(boolean automaticInspection){\r\n    setCapability(Option.AUTOMATIC_INSPECTION, automaticInspection);\r\n    return this;\r\n}"
}, {
	"Path": "io.reactivex.subjects.AsyncSubject.add",
	"Comment": "tries to add the given subscriber to the subscribers array atomicallyor returns false if the subject has terminated.",
	"Method": "boolean add(AsyncDisposable<T> ps){\r\n    for (; ; ) {\r\n        AsyncDisposable<T>[] a = subscribers.get();\r\n        if (a == TERMINATED) {\r\n            return false;\r\n        }\r\n        int n = a.length;\r\n        @SuppressWarnings(\"unchecked\")\r\n        AsyncDisposable<T>[] b = new AsyncDisposable[n + 1];\r\n        System.arraycopy(a, 0, b, 0, n);\r\n        b[n] = ps;\r\n        if (subscribers.compareAndSet(a, b)) {\r\n            return true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.subjects.SingleSubject.hasValue",
	"Comment": "returns true if this singlesubject was terminated with a success value.",
	"Method": "boolean hasValue(){\r\n    return observers.get() == TERMINATED && value != null;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.numberOfElementsToBeLessThan",
	"Comment": "an expectation for checking number of webelements with given locator being less than definednumber",
	"Method": "ExpectedCondition<List<WebElement>> numberOfElementsToBeLessThan(By locator,Integer number){\r\n    return new ExpectedCondition<List<WebElement>>() {\r\n        private Integer currentNumber = 0;\r\n        @Override\r\n        public List<WebElement> apply(WebDriver webDriver) {\r\n            List<WebElement> elements = webDriver.findElements(locator);\r\n            currentNumber = elements.size();\r\n            return currentNumber < number ? elements : null;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"number of elements found by %s to be less than \\\"%s\\\". Current number: \\\"%s\\\"\", locator, number, currentNumber);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.numberOfElementsToBeLessThan",
	"Comment": "an expectation for checking number of webelements with given locator being less than definednumber",
	"Method": "ExpectedCondition<List<WebElement>> numberOfElementsToBeLessThan(By locator,Integer number){\r\n    List<WebElement> elements = webDriver.findElements(locator);\r\n    currentNumber = elements.size();\r\n    return currentNumber < number ? elements : null;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.numberOfElementsToBeLessThan",
	"Comment": "an expectation for checking number of webelements with given locator being less than definednumber",
	"Method": "ExpectedCondition<List<WebElement>> numberOfElementsToBeLessThan(By locator,Integer number){\r\n    return String.format(\"number of elements found by %s to be less than \\\"%s\\\". Current number: \\\"%s\\\"\", locator, number, currentNumber);\r\n}"
}, {
	"Path": "io.reactivex.disposables.CompositeDisposable.add",
	"Comment": "adds a disposable to this container or disposes it if thecontainer has been disposed.",
	"Method": "boolean add(Disposable d){\r\n    ObjectHelper.requireNonNull(d, \"d is null\");\r\n    if (!disposed) {\r\n        synchronized (this) {\r\n            if (!disposed) {\r\n                OpenHashSet<Disposable> set = resources;\r\n                if (set == null) {\r\n                    set = new OpenHashSet<Disposable>();\r\n                    resources = set;\r\n                }\r\n                set.add(d);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    d.dispose();\r\n    return false;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableReplayTest.testIssue2191_SchedulerUnsubscribeOnError",
	"Comment": "specifically test interaction with a scheduler with subscribeon.",
	"Method": "void testIssue2191_SchedulerUnsubscribeOnError(){\r\n    Consumer<Integer> sourceNext = mock(Consumer.class);\r\n    Action sourceCompleted = mock(Action.class);\r\n    Consumer<Throwable> sourceError = mock(Consumer.class);\r\n    Action sourceUnsubscribed = mock(Action.class);\r\n    final Scheduler mockScheduler = mock(Scheduler.class);\r\n    final Disposable mockSubscription = mock(Disposable.class);\r\n    Worker spiedWorker = workerSpy(mockSubscription);\r\n    Subscriber<Integer> mockObserverBeforeConnect = TestHelper.mockSubscriber();\r\n    Subscriber<Integer> mockObserverAfterConnect = TestHelper.mockSubscriber();\r\n    when(mockScheduler.createWorker()).thenReturn(spiedWorker);\r\n    Function<Integer, Integer> mockFunc = mock(Function.class);\r\n    IllegalArgumentException illegalArgumentException = new IllegalArgumentException();\r\n    when(mockFunc.apply(1)).thenReturn(1);\r\n    when(mockFunc.apply(2)).thenThrow(illegalArgumentException);\r\n    ConnectableFlowable<Integer> replay = Flowable.just(1, 2, 3).map(mockFunc).doOnNext(sourceNext).doOnCancel(sourceUnsubscribed).doOnComplete(sourceCompleted).doOnError(sourceError).subscribeOn(mockScheduler).replay();\r\n    replay.subscribe(mockObserverBeforeConnect);\r\n    replay.subscribe(mockObserverBeforeConnect);\r\n    replay.connect();\r\n    replay.subscribe(mockObserverAfterConnect);\r\n    replay.subscribe(mockObserverAfterConnect);\r\n    verify(mockObserverBeforeConnect, times(2)).onSubscribe((Subscription) any());\r\n    verify(mockObserverAfterConnect, times(2)).onSubscribe((Subscription) any());\r\n    verify(mockScheduler, times(1)).createWorker();\r\n    verify(spiedWorker, times(1)).schedule((Runnable) notNull());\r\n    verify(sourceNext, times(1)).accept(1);\r\n    verify(sourceError, times(1)).accept(illegalArgumentException);\r\n    verifyObserver(mockObserverBeforeConnect, 2, 2, illegalArgumentException);\r\n    verifyObserver(mockObserverAfterConnect, 2, 2, illegalArgumentException);\r\n    verify(spiedWorker, times(1)).dispose();\r\n    verify(sourceUnsubscribed, never()).run();\r\n    verifyNoMoreInteractions(sourceNext);\r\n    verifyNoMoreInteractions(sourceCompleted);\r\n    verifyNoMoreInteractions(sourceError);\r\n    verifyNoMoreInteractions(sourceUnsubscribed);\r\n    verifyNoMoreInteractions(spiedWorker);\r\n    verifyNoMoreInteractions(mockSubscription);\r\n    verifyNoMoreInteractions(mockScheduler);\r\n    verifyNoMoreInteractions(mockObserverBeforeConnect);\r\n    verifyNoMoreInteractions(mockObserverAfterConnect);\r\n}"
}, {
	"Path": "org.robolectric.internal.bytecode.ClassInstrumentor.makeMethodPrivate",
	"Comment": "replaces protected and public class modifiers with private.",
	"Method": "void makeMethodPrivate(MethodNode method){\r\n    method.access = (method.access | Opcodes.ACC_PRIVATE) & ~(Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED);\r\n}"
}, {
	"Path": "io.reactivex.internal.util.EndConsumerHelper.reportDoubleSubscription",
	"Comment": "report a protocolviolationexception with a personalized message referencingthe simple type name of the consumer class and report it viarxjavaplugins.onerror.",
	"Method": "void reportDoubleSubscription(Class<?> consumer){\r\n    RxJavaPlugins.onError(new ProtocolViolationException(composeMessage(consumer.getName())));\r\n}"
}, {
	"Path": "io.reactivex.observable.ObservableErrorHandlingTests.testOnNextError",
	"Comment": "test that an error from a user provided observer.onnext is handled and emitted to the onerror.",
	"Method": "void testOnNextError(){\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    final AtomicReference<Throwable> caughtError = new AtomicReference<Throwable>();\r\n    Observable<Long> o = Observable.interval(50, TimeUnit.MILLISECONDS);\r\n    Observer<Long> observer = new DefaultObserver<Long>() {\r\n        @Override\r\n        public void onComplete() {\r\n            System.out.println(\"completed\");\r\n            latch.countDown();\r\n        }\r\n        @Override\r\n        public void onError(Throwable e) {\r\n            System.out.println(\"error: \" + e);\r\n            caughtError.set(e);\r\n            latch.countDown();\r\n        }\r\n        @Override\r\n        public void onNext(Long args) {\r\n            throw new RuntimeException(\"forced failure\");\r\n        }\r\n    };\r\n    o.safeSubscribe(observer);\r\n    latch.await(2000, TimeUnit.MILLISECONDS);\r\n    assertNotNull(caughtError.get());\r\n}"
}, {
	"Path": "io.reactivex.observable.ObservableErrorHandlingTests.testOnNextError",
	"Comment": "test that an error from a user provided observer.onnext is handled and emitted to the onerror.",
	"Method": "void testOnNextError(){\r\n    System.out.println(\"completed\");\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.reactivex.observable.ObservableErrorHandlingTests.testOnNextError",
	"Comment": "test that an error from a user provided observer.onnext is handled and emitted to the onerror.",
	"Method": "void testOnNextError(){\r\n    System.out.println(\"error: \" + e);\r\n    caughtError.set(e);\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.reactivex.observable.ObservableErrorHandlingTests.testOnNextError",
	"Comment": "test that an error from a user provided observer.onnext is handled and emitted to the onerror.",
	"Method": "void testOnNextError(){\r\n    throw new RuntimeException(\"forced failure\");\r\n}"
}, {
	"Path": "org.openqa.selenium.io.TemporaryFilesystem.shouldReap",
	"Comment": "returns true if we should be reaping profiles. used to control tempfile deletion.",
	"Method": "boolean shouldReap(){\r\n    String reap = System.getProperty(\"webdriver.reap_profile\", \"true\");\r\n    return Boolean.valueOf(reap);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowArscAssetManager9.ApkAssetsCookieToJavaCookie",
	"Comment": "java asset cookies have 0 as an invalid cookie, but typedarray expects0.",
	"Method": "int ApkAssetsCookieToJavaCookie(ApkAssetsCookie cookie){\r\n    return cookie.intValue() != kInvalidCookie ? (cookie.intValue() + 1) : -1;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowUsbManager.hasPermission",
	"Comment": "returns true if the caller has permission to access the device.",
	"Method": "boolean hasPermission(UsbDevice device){\r\n    return hasPermissionForPackage(device, RuntimeEnvironment.application.getPackageName());\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowAbsListView.getSmoothScrolledPosition",
	"Comment": "robolectric accessor for the last smoothscrolledposition",
	"Method": "int getSmoothScrolledPosition(){\r\n    return smoothScrolledPosition;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.setDoubleTapZoomStyle",
	"Comment": "set the type of zoom animation to be used for double taps. see static fields.",
	"Method": "void setDoubleTapZoomStyle(int doubleTapZoomStyle){\r\n    if (!VALID_ZOOM_STYLES.contains(doubleTapZoomStyle)) {\r\n        throw new IllegalArgumentException(\"Invalid zoom style: \" + doubleTapZoomStyle);\r\n    }\r\n    this.doubleTapZoomStyle = doubleTapZoomStyle;\r\n}"
}, {
	"Path": "retrofit2.converter.moshi.MoshiConverterFactory.withNullSerialization",
	"Comment": "return a new factory which includes null values into the serialized json.",
	"Method": "MoshiConverterFactory withNullSerialization(){\r\n    return new MoshiConverterFactory(moshi, lenient, failOnUnknown, true);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textMatches",
	"Comment": "an expectation for checking webelement with given locator has text with a value as a part of",
	"Method": "ExpectedCondition<Boolean> textMatches(By locator,Pattern pattern){\r\n    return new ExpectedCondition<Boolean>() {\r\n        private String currentValue = null;\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            try {\r\n                currentValue = driver.findElement(locator).getText();\r\n                return pattern.matcher(currentValue).find();\r\n            } catch (Exception e) {\r\n                return false;\r\n            }\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"text found by %s to match pattern \\\"%s\\\". Current text: \\\"%s\\\"\", locator, pattern.pattern(), currentValue);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textMatches",
	"Comment": "an expectation for checking webelement with given locator has text with a value as a part of",
	"Method": "ExpectedCondition<Boolean> textMatches(By locator,Pattern pattern){\r\n    try {\r\n        currentValue = driver.findElement(locator).getText();\r\n        return pattern.matcher(currentValue).find();\r\n    } catch (Exception e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textMatches",
	"Comment": "an expectation for checking webelement with given locator has text with a value as a part of",
	"Method": "ExpectedCondition<Boolean> textMatches(By locator,Pattern pattern){\r\n    return String.format(\"text found by %s to match pattern \\\"%s\\\". Current text: \\\"%s\\\"\", locator, pattern.pattern(), currentValue);\r\n}"
}, {
	"Path": "io.reactivex.subscribers.DisposableSubscriber.onStart",
	"Comment": "called once the single upstream subscription is set via onsubscribe.",
	"Method": "void onStart(){\r\n    upstream.get().request(Long.MAX_VALUE);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowMediaRouter.isBluetoothRouteSelected",
	"Comment": "returns whether the bluetooth a2dp route is the currently selected route.",
	"Method": "boolean isBluetoothRouteSelected(int type){\r\n    return realObject.getSelectedRoute(type).equals(getBluetoothA2dpRoute());\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.onTilesInited",
	"Comment": "called by worker task when decoder is ready and image size and exif orientation is known.",
	"Method": "void onTilesInited(ImageRegionDecoder decoder,int sWidth,int sHeight,int sOrientation){\r\n    debug(\"onTilesInited sWidth=%d, sHeight=%d, sOrientation=%d\", sWidth, sHeight, orientation);\r\n    if (this.sWidth > 0 && this.sHeight > 0 && (this.sWidth != sWidth || this.sHeight != sHeight)) {\r\n        reset(false);\r\n        if (bitmap != null) {\r\n            if (!bitmapIsCached) {\r\n                bitmap.recycle();\r\n            }\r\n            bitmap = null;\r\n            if (onImageEventListener != null && bitmapIsCached) {\r\n                onImageEventListener.onPreviewReleased();\r\n            }\r\n            bitmapIsPreview = false;\r\n            bitmapIsCached = false;\r\n        }\r\n    }\r\n    this.decoder = decoder;\r\n    this.sWidth = sWidth;\r\n    this.sHeight = sHeight;\r\n    this.sOrientation = sOrientation;\r\n    checkReady();\r\n    if (!checkImageLoaded() && maxTileWidth > 0 && maxTileWidth != TILE_SIZE_AUTO && maxTileHeight > 0 && maxTileHeight != TILE_SIZE_AUTO && getWidth() > 0 && getHeight() > 0) {\r\n        initialiseBaseLayer(new Point(maxTileWidth, maxTileHeight));\r\n    }\r\n    invalidate();\r\n    requestLayout();\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.hasImage",
	"Comment": "check if an image has been set. the image may not have been loaded and displayed yet.",
	"Method": "boolean hasImage(){\r\n    return uri != null || bitmap != null;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowView.visualize",
	"Comment": "returns a textual representation of the appearance of the object.",
	"Method": "String visualize(View view){\r\n    Canvas canvas = new Canvas();\r\n    view.draw(canvas);\r\n    ShadowCanvas shadowCanvas = Shadow.extract(canvas);\r\n    return shadowCanvas.getDescription();\r\n}"
}, {
	"Path": "org.openqa.selenium.Proxy.setSocksUsername",
	"Comment": "specifies a username for the socks proxy. supported by socks v5 and above.",
	"Method": "Proxy setSocksUsername(String username){\r\n    verifyProxyTypeCompatibility(ProxyType.MANUAL);\r\n    this.proxyType = ProxyType.MANUAL;\r\n    this.socksUsername = username;\r\n    return this;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.dialog.wheel.WheelView.rebuildItems",
	"Comment": "rebuilds wheel items if necessary. caches all unused items.",
	"Method": "boolean rebuildItems(){\r\n    boolean updated = false;\r\n    ItemsRange range = getItemsRange();\r\n    if (itemsLayout != null) {\r\n        int first = recycle.recycleItems(itemsLayout, firstItem, range);\r\n        updated = firstItem != first;\r\n        firstItem = first;\r\n    } else {\r\n        createItemsLayout();\r\n        updated = true;\r\n    }\r\n    if (!updated) {\r\n        updated = firstItem != range.getFirst() || itemsLayout.getChildCount() != range.getCount();\r\n    }\r\n    if (firstItem > range.getFirst() && firstItem <= range.getLast()) {\r\n        for (int i = firstItem - 1; i >= range.getFirst(); i--) {\r\n            if (!addViewItem(i, true)) {\r\n                break;\r\n            }\r\n            firstItem = i;\r\n        }\r\n    } else {\r\n        firstItem = range.getFirst();\r\n    }\r\n    int first = firstItem;\r\n    for (int i = itemsLayout.getChildCount(); i < range.getCount(); i++) {\r\n        if (!addViewItem(firstItem + i, false) && itemsLayout.getChildCount() == 0) {\r\n            first++;\r\n        }\r\n    }\r\n    firstItem = first;\r\n    return updated;\r\n}"
}, {
	"Path": "org.robolectric.integration_tests.axt.InstrumentationRegistryTest.checkInstances",
	"Comment": "verifies that each test gets a new instrumentation and context, by comparing against instancesstored by prior test.",
	"Method": "void checkInstances(){\r\n    if (priorInstrumentation == null) {\r\n        priorInstrumentation = InstrumentationRegistry.getInstrumentation();\r\n        priorContext = InstrumentationRegistry.getTargetContext();\r\n    } else {\r\n        assertThat(priorInstrumentation).isNotEqualTo(InstrumentationRegistry.getInstrumentation());\r\n        assertThat(priorContext).isNotEqualTo(InstrumentationRegistry.getTargetContext());\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableScanTest.testSeedFactory",
	"Comment": "this uses the public api collect which uses scan under the covers.",
	"Method": "void testSeedFactory(){\r\n    Observable<List<Integer>> o = Observable.range(1, 10).collect(new Callable<List<Integer>>() {\r\n        @Override\r\n        public List<Integer> call() {\r\n            return new ArrayList<Integer>();\r\n        }\r\n    }, new BiConsumer<List<Integer>, Integer>() {\r\n        @Override\r\n        public void accept(List<Integer> list, Integer t2) {\r\n            list.add(t2);\r\n        }\r\n    }).toObservable().takeLast(1);\r\n    assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), o.blockingSingle());\r\n    assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), o.blockingSingle());\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableScanTest.testSeedFactory",
	"Comment": "this uses the public api collect which uses scan under the covers.",
	"Method": "void testSeedFactory(){\r\n    return new ArrayList<Integer>();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableScanTest.testSeedFactory",
	"Comment": "this uses the public api collect which uses scan under the covers.",
	"Method": "void testSeedFactory(){\r\n    list.add(t2);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowArscAssetManager.loadResourceBagValue",
	"Comment": "returns true if the resource was found, filling in mretstringblock andmretdata.",
	"Method": "int loadResourceBagValue(int ident,int bagEntryId,TypedValue outValue,boolean resolve){\r\n    CppAssetManager am = assetManagerForJavaObject();\r\n    if (am == null) {\r\n        return 0;\r\n    }\r\n    final ResTable res = am.getResources();\r\n    return loadResourceBagValueInternal(ident, bagEntryId, outValue, resolve, res);\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.setRegionDecoderClass",
	"Comment": "swap the default region decoder implementation for one of your own. you must do this before setting the image file orasset, and you cannot use a custom decoder when using layout xml to set an asset name. your class must have apublic default constructor.",
	"Method": "void setRegionDecoderClass(Class<? extends ImageRegionDecoder> regionDecoderClass){\r\n    if (regionDecoderClass == null) {\r\n        throw new IllegalArgumentException(\"Decoder class cannot be set to null\");\r\n    }\r\n    this.regionDecoderFactory = new CompatDecoderFactory(regionDecoderClass);\r\n}"
}, {
	"Path": "io.reactivex.flowable.FlowableErrorHandlingTests.testOnNextErrorAcrossThread",
	"Comment": "test that an error from a user provided observer.onnextis handled and emitted to the onerror.even when done across thread boundaries with observeon",
	"Method": "void testOnNextErrorAcrossThread(){\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    final AtomicReference<Throwable> caughtError = new AtomicReference<Throwable>();\r\n    Flowable<Long> f = Flowable.interval(50, TimeUnit.MILLISECONDS);\r\n    Subscriber<Long> subscriber = new DefaultSubscriber<Long>() {\r\n        @Override\r\n        public void onComplete() {\r\n            System.out.println(\"completed\");\r\n            latch.countDown();\r\n        }\r\n        @Override\r\n        public void onError(Throwable e) {\r\n            System.out.println(\"error: \" + e);\r\n            caughtError.set(e);\r\n            latch.countDown();\r\n        }\r\n        @Override\r\n        public void onNext(Long args) {\r\n            throw new RuntimeException(\"forced failure\");\r\n        }\r\n    };\r\n    f.observeOn(Schedulers.newThread()).safeSubscribe(subscriber);\r\n    latch.await(2000, TimeUnit.MILLISECONDS);\r\n    assertNotNull(caughtError.get());\r\n}"
}, {
	"Path": "io.reactivex.flowable.FlowableErrorHandlingTests.testOnNextErrorAcrossThread",
	"Comment": "test that an error from a user provided observer.onnextis handled and emitted to the onerror.even when done across thread boundaries with observeon",
	"Method": "void testOnNextErrorAcrossThread(){\r\n    System.out.println(\"completed\");\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.reactivex.flowable.FlowableErrorHandlingTests.testOnNextErrorAcrossThread",
	"Comment": "test that an error from a user provided observer.onnextis handled and emitted to the onerror.even when done across thread boundaries with observeon",
	"Method": "void testOnNextErrorAcrossThread(){\r\n    System.out.println(\"error: \" + e);\r\n    caughtError.set(e);\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.reactivex.flowable.FlowableErrorHandlingTests.testOnNextErrorAcrossThread",
	"Comment": "test that an error from a user provided observer.onnextis handled and emitted to the onerror.even when done across thread boundaries with observeon",
	"Method": "void testOnNextErrorAcrossThread(){\r\n    throw new RuntimeException(\"forced failure\");\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableGroupByTest.testUnsubscribeOnNestedTakeAndSyncInfiniteStream",
	"Comment": "we will only take 1 group with 20 events from it and then unsubscribe.",
	"Method": "void testUnsubscribeOnNestedTakeAndSyncInfiniteStream(){\r\n    final AtomicInteger subscribeCounter = new AtomicInteger();\r\n    final AtomicInteger sentEventCounter = new AtomicInteger();\r\n    doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream(SYNC_INFINITE_OBSERVABLE_OF_EVENT(2, subscribeCounter, sentEventCounter), subscribeCounter);\r\n    Thread.sleep(500);\r\n    assertEquals(39, sentEventCounter.get());\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableObserveOnTest.testObserveOnWithNewThreadScheduler",
	"Comment": "confirm that running on a newthreadscheduler uses the same thread for the entire stream.",
	"Method": "void testObserveOnWithNewThreadScheduler(){\r\n    final AtomicInteger count = new AtomicInteger();\r\n    final int _multiple = 99;\r\n    Flowable.range(1, 100000).map(new Function<Integer, Integer>() {\r\n        @Override\r\n        public Integer apply(Integer t1) {\r\n            return t1 * _multiple;\r\n        }\r\n    }).observeOn(Schedulers.newThread()).blockingForEach(new Consumer<Integer>() {\r\n        @Override\r\n        public void accept(Integer t1) {\r\n            assertEquals(count.incrementAndGet() * _multiple, t1.intValue());\r\n            String name = Thread.currentThread().getName();\r\n            assertFalse(\"Wrong thread name: \" + name, name.startsWith(\"Rx\"));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableObserveOnTest.testObserveOnWithNewThreadScheduler",
	"Comment": "confirm that running on a newthreadscheduler uses the same thread for the entire stream.",
	"Method": "void testObserveOnWithNewThreadScheduler(){\r\n    return t1 * _multiple;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableObserveOnTest.testObserveOnWithNewThreadScheduler",
	"Comment": "confirm that running on a newthreadscheduler uses the same thread for the entire stream.",
	"Method": "void testObserveOnWithNewThreadScheduler(){\r\n    assertEquals(count.incrementAndGet() * _multiple, t1.intValue());\r\n    String name = Thread.currentThread().getName();\r\n    assertFalse(\"Wrong thread name: \" + name, name.startsWith(\"Rx\"));\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.visibilityOfNestedElementsLocatedBy",
	"Comment": "an expectation for checking child webelement as a part of parent element to be visible",
	"Method": "ExpectedCondition<List<WebElement>> visibilityOfNestedElementsLocatedBy(By parent,By childLocator,ExpectedCondition<List<WebElement>> visibilityOfNestedElementsLocatedBy,WebElement element,By childLocator){\r\n    return new ExpectedCondition<List<WebElement>>() {\r\n        @Override\r\n        public List<WebElement> apply(WebDriver webDriver) {\r\n            List<WebElement> allChildren = element.findElements(childLocator);\r\n            if (!allChildren.isEmpty() && allChildren.get(0).isDisplayed()) {\r\n                return allChildren;\r\n            }\r\n            return null;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"visibility of element located by %s -> %s\", element, childLocator);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.visibilityOfNestedElementsLocatedBy",
	"Comment": "an expectation for checking child webelement as a part of parent element to be visible",
	"Method": "ExpectedCondition<List<WebElement>> visibilityOfNestedElementsLocatedBy(By parent,By childLocator,ExpectedCondition<List<WebElement>> visibilityOfNestedElementsLocatedBy,WebElement element,By childLocator){\r\n    List<WebElement> allChildren = element.findElements(childLocator);\r\n    if (!allChildren.isEmpty() && allChildren.get(0).isDisplayed()) {\r\n        return allChildren;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.visibilityOfNestedElementsLocatedBy",
	"Comment": "an expectation for checking child webelement as a part of parent element to be visible",
	"Method": "ExpectedCondition<List<WebElement>> visibilityOfNestedElementsLocatedBy(By parent,By childLocator,ExpectedCondition<List<WebElement>> visibilityOfNestedElementsLocatedBy,WebElement element,By childLocator){\r\n    return String.format(\"visibility of element located by %s -> %s\", element, childLocator);\r\n}"
}, {
	"Path": "io.reactivex.internal.subscriptions.DeferredScalarSubscription.complete",
	"Comment": "completes this subscription by indicating the given value shouldbe emitted when the first request arrives.make sure this is called exactly once.",
	"Method": "void complete(T v){\r\n    int state = get();\r\n    for (; ; ) {\r\n        if (state == FUSED_EMPTY) {\r\n            value = v;\r\n            lazySet(FUSED_READY);\r\n            Subscriber<? super T> a = downstream;\r\n            a.onNext(v);\r\n            if (get() != CANCELLED) {\r\n                a.onComplete();\r\n            }\r\n            return;\r\n        }\r\n        if ((state & ~HAS_REQUEST_NO_VALUE) != 0) {\r\n            return;\r\n        }\r\n        if (state == HAS_REQUEST_NO_VALUE) {\r\n            lazySet(HAS_REQUEST_HAS_VALUE);\r\n            Subscriber<? super T> a = downstream;\r\n            a.onNext(v);\r\n            if (get() != CANCELLED) {\r\n                a.onComplete();\r\n            }\r\n            return;\r\n        }\r\n        value = v;\r\n        if (compareAndSet(NO_REQUEST_NO_VALUE, NO_REQUEST_HAS_VALUE)) {\r\n            return;\r\n        }\r\n        state = get();\r\n        if (state == CANCELLED) {\r\n            value = null;\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowContentResolver.getContentObservers",
	"Comment": "returns the content observers registered for updates under the given uri.will be empty if no observer is registered.",
	"Method": "Collection<ContentObserver> getContentObservers(Uri uri){\r\n    ArrayList<ContentObserver> observers = new ArrayList(1);\r\n    for (ContentObserverEntry entry : contentObservers) {\r\n        if (entry.matches(uri)) {\r\n            observers.add(entry.observer);\r\n        }\r\n    }\r\n    return observers;\r\n}"
}, {
	"Path": "org.robolectric.manifest.AndroidManifest.getBroadcastReceiver",
	"Comment": "returns data for the broadcast receiver with the provided name from this manifest. if noreceiver with the class name can be found, returns null.",
	"Method": "BroadcastReceiverData getBroadcastReceiver(String className){\r\n    parseAndroidManifest();\r\n    for (BroadcastReceiverData receiver : receivers) {\r\n        if (receiver.getName().equals(className)) {\r\n            return receiver;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowView.checkedPerformClick",
	"Comment": "utility method for clicking on views exposing testing scenarios that are not possible when using the actual app.",
	"Method": "boolean checkedPerformClick(){\r\n    if (!realView.isShown()) {\r\n        throw new RuntimeException(\"View is not visible and cannot be clicked\");\r\n    }\r\n    if (!realView.isEnabled()) {\r\n        throw new RuntimeException(\"View is not enabled and cannot be clicked\");\r\n    }\r\n    AccessibilityUtil.checkViewIfCheckingEnabled(realView);\r\n    return realView.performClick();\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.visibilityOfAllElementsLocatedBy",
	"Comment": "an expectation for checking that all elements present on the web page that match the locatorare visible. visibility means that the elements are not only displayed but also have a heightand width that is greater than 0.",
	"Method": "ExpectedCondition<List<WebElement>> visibilityOfAllElementsLocatedBy(By locator){\r\n    return new ExpectedCondition<List<WebElement>>() {\r\n        @Override\r\n        public List<WebElement> apply(WebDriver driver) {\r\n            List<WebElement> elements = driver.findElements(locator);\r\n            for (WebElement element : elements) {\r\n                if (!element.isDisplayed()) {\r\n                    return null;\r\n                }\r\n            }\r\n            return elements.size() > 0 ? elements : null;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"visibility of all elements located by \" + locator;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.visibilityOfAllElementsLocatedBy",
	"Comment": "an expectation for checking that all elements present on the web page that match the locatorare visible. visibility means that the elements are not only displayed but also have a heightand width that is greater than 0.",
	"Method": "ExpectedCondition<List<WebElement>> visibilityOfAllElementsLocatedBy(By locator){\r\n    List<WebElement> elements = driver.findElements(locator);\r\n    for (WebElement element : elements) {\r\n        if (!element.isDisplayed()) {\r\n            return null;\r\n        }\r\n    }\r\n    return elements.size() > 0 ? elements : null;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.visibilityOfAllElementsLocatedBy",
	"Comment": "an expectation for checking that all elements present on the web page that match the locatorare visible. visibility means that the elements are not only displayed but also have a heightand width that is greater than 0.",
	"Method": "ExpectedCondition<List<WebElement>> visibilityOfAllElementsLocatedBy(By locator){\r\n    return \"visibility of all elements located by \" + locator;\r\n}"
}, {
	"Path": "io.reactivex.internal.functions.ObjectHelper.requireNonNull",
	"Comment": "verifies if the object is not null and returns it or throws a nullpointerexceptionwith the given message.",
	"Method": "T requireNonNull(T object,String message,long requireNonNull,long value,String message){\r\n    throw new InternalError(\"Null check on a primitive: \" + message);\r\n}"
}, {
	"Path": "io.reactivex.subjects.CompletableSubject.getThrowable",
	"Comment": "returns the terminal error if this completablesubject has been terminated with an error, null otherwise.",
	"Method": "Throwable getThrowable(){\r\n    if (observers.get() == TERMINATED) {\r\n        return error;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.reactivex.parallel.ParallelFlowable.fromArray",
	"Comment": "wraps multiple publishers into a parallelflowable which runs themin parallel and unordered.",
	"Method": "ParallelFlowable<T> fromArray(Publisher<T> publishers){\r\n    if (publishers.length == 0) {\r\n        throw new IllegalArgumentException(\"Zero publishers not supported\");\r\n    }\r\n    return RxJavaPlugins.onAssembly(new ParallelFromArray<T>(publishers));\r\n}"
}, {
	"Path": "org.redisson.spring.cache.CacheConfig.setMaxSize",
	"Comment": "set max size of map. superfluous elements are evicted using lru algorithm.",
	"Method": "void setMaxSize(int maxSize){\r\n    this.maxSize = maxSize;\r\n}"
}, {
	"Path": "io.reactivex.Completable.toNpe",
	"Comment": "creates a nullpointerexception instance and sets the given throwable as its initial cause.",
	"Method": "NullPointerException toNpe(Throwable ex){\r\n    NullPointerException npe = new NullPointerException(\"Actually not, but can't pass out an exception otherwise...\");\r\n    npe.initCause(ex);\r\n    return npe;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowStateListDrawable.getDrawableForState",
	"Comment": "non android accessor to retrieve drawable added for a specific state.",
	"Method": "Drawable getDrawableForState(int[] stateSet){\r\n    return stateToDrawable.get(createStateList(stateSet));\r\n}"
}, {
	"Path": "io.reactivex.internal.subscribers.BlockingBaseSubscriber.blockingGet",
	"Comment": "block until the first value arrives and return it, otherwisereturn null for an empty source and rethrow any exception.",
	"Method": "T blockingGet(){\r\n    if (getCount() != 0) {\r\n        try {\r\n            BlockingHelper.verifyNonBlocking();\r\n            await();\r\n        } catch (InterruptedException ex) {\r\n            Subscription s = this.upstream;\r\n            this.upstream = SubscriptionHelper.CANCELLED;\r\n            if (s != null) {\r\n                s.cancel();\r\n            }\r\n            throw ExceptionHelper.wrapOrThrow(ex);\r\n        }\r\n    }\r\n    Throwable e = error;\r\n    if (e != null) {\r\n        throw ExceptionHelper.wrapOrThrow(e);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.robolectric.shadows.CachedPathIteratorFactory.getNumberOfPoints",
	"Comment": "returns the number of points stored in a coordinates array for the given segment type.",
	"Method": "int getNumberOfPoints(int segmentType){\r\n    switch(segmentType) {\r\n        case PathIterator.SEG_QUADTO:\r\n            return 2;\r\n        case PathIterator.SEG_CUBICTO:\r\n            return 3;\r\n        case PathIterator.SEG_CLOSE:\r\n            return 0;\r\n        default:\r\n            return 1;\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.internal.subscriptions.DeferredScalarSubscription.tryCancel",
	"Comment": "atomically sets a cancelled state and returns true ifthe current thread did it successfully.",
	"Method": "boolean tryCancel(){\r\n    return getAndSet(CANCELLED) != CANCELLED;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.doubleTapZoom",
	"Comment": "double tap zoom handler triggered from gesture detector or on touch, depending on whetherquick scale is enabled.",
	"Method": "void doubleTapZoom(PointF sCenter,PointF vFocus){\r\n    if (!panEnabled) {\r\n        if (sRequestedCenter != null) {\r\n            sCenter.x = sRequestedCenter.x;\r\n            sCenter.y = sRequestedCenter.y;\r\n        } else {\r\n            sCenter.x = sWidth() / 2;\r\n            sCenter.y = sHeight() / 2;\r\n        }\r\n    }\r\n    float doubleTapZoomScale = Math.min(maxScale, RxScaleImageView.this.doubleTapZoomScale);\r\n    boolean zoomIn = scale <= doubleTapZoomScale * 0.9;\r\n    float targetScale = zoomIn ? doubleTapZoomScale : minScale();\r\n    if (doubleTapZoomStyle == ZOOM_FOCUS_CENTER_IMMEDIATE) {\r\n        setScaleAndCenter(targetScale, sCenter);\r\n    } else if (doubleTapZoomStyle == ZOOM_FOCUS_CENTER || !zoomIn || !panEnabled) {\r\n        new AnimationBuilder(targetScale, sCenter).withInterruptible(false).withDuration(doubleTapZoomDuration).withOrigin(ORIGIN_DOUBLE_TAP_ZOOM).start();\r\n    } else if (doubleTapZoomStyle == ZOOM_FOCUS_FIXED) {\r\n        new AnimationBuilder(targetScale, sCenter, vFocus).withInterruptible(false).withDuration(doubleTapZoomDuration).withOrigin(ORIGIN_DOUBLE_TAP_ZOOM).start();\r\n    }\r\n    invalidate();\r\n}"
}, {
	"Path": "com.thoughtworks.selenium.SeleneseTestCase.checkForVerificationErrors",
	"Comment": "asserts that there were no verification errors during the current test, failing immediately ifany are found",
	"Method": "void checkForVerificationErrors(){\r\n    stb.checkForVerificationErrors();\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.or",
	"Comment": "an expectation with the logical or condition of the given list of conditions.each condition is checked until at least one of them returns true or not null.",
	"Method": "ExpectedCondition<Boolean> or(ExpectedCondition<?> conditions){\r\n    return new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            RuntimeException lastException = null;\r\n            for (ExpectedCondition<?> condition : conditions) {\r\n                try {\r\n                    Object result = condition.apply(driver);\r\n                    if (result != null) {\r\n                        if (result instanceof Boolean) {\r\n                            if (Boolean.TRUE.equals(result)) {\r\n                                return true;\r\n                            }\r\n                        } else {\r\n                            return true;\r\n                        }\r\n                    }\r\n                } catch (RuntimeException e) {\r\n                    lastException = e;\r\n                }\r\n            }\r\n            if (lastException != null) {\r\n                throw lastException;\r\n            }\r\n            return false;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            StringBuilder message = new StringBuilder(\"at least one condition to be valid: \");\r\n            Joiner.on(\" || \").appendTo(message, conditions);\r\n            return message.toString();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.or",
	"Comment": "an expectation with the logical or condition of the given list of conditions.each condition is checked until at least one of them returns true or not null.",
	"Method": "ExpectedCondition<Boolean> or(ExpectedCondition<?> conditions){\r\n    RuntimeException lastException = null;\r\n    for (ExpectedCondition<?> condition : conditions) {\r\n        try {\r\n            Object result = condition.apply(driver);\r\n            if (result != null) {\r\n                if (result instanceof Boolean) {\r\n                    if (Boolean.TRUE.equals(result)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    return true;\r\n                }\r\n            }\r\n        } catch (RuntimeException e) {\r\n            lastException = e;\r\n        }\r\n    }\r\n    if (lastException != null) {\r\n        throw lastException;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.or",
	"Comment": "an expectation with the logical or condition of the given list of conditions.each condition is checked until at least one of them returns true or not null.",
	"Method": "ExpectedCondition<Boolean> or(ExpectedCondition<?> conditions){\r\n    StringBuilder message = new StringBuilder(\"at least one condition to be valid: \");\r\n    Joiner.on(\" || \").appendTo(message, conditions);\r\n    return message.toString();\r\n}"
}, {
	"Path": "org.openqa.selenium.safari.SafariDriver.newWindow",
	"Comment": "open either a new tab or window, depending on what is requested, and return the window handlewithout switching to it.",
	"Method": "String newWindow(WindowType type){\r\n    Response response = execute(\"SAFARI_NEW_WINDOW\", ImmutableMap.of(\"newTab\", type == WindowType.TAB));\r\n    return (String) response.getValue();\r\n}"
}, {
	"Path": "org.robolectric.shadows.NativeBitSet64.clearFirstMarkedBit",
	"Comment": "finds the first marked bit in the set and clears it. returns the bit index. result is undefinedif all bits are unmarked.",
	"Method": "int clearFirstMarkedBit(){\r\n    int n = firstMarkedBit();\r\n    clearBit(n);\r\n    return n;\r\n}"
}, {
	"Path": "retrofit2.mock.NetworkBehavior.calculateDelay",
	"Comment": "get the delay that should be used for delaying a response in accordance with configuredbehavior.",
	"Method": "long calculateDelay(TimeUnit unit){\r\n    float delta = variancePercent / 100f;\r\n    float lowerBound = 1f - delta;\r\n    float upperBound = 1f + delta;\r\n    float bound = upperBound - lowerBound;\r\n    float delayPercent = lowerBound + (random.nextFloat() * bound);\r\n    long callDelayMs = (long) (delayMs * delayPercent);\r\n    return MILLISECONDS.convert(callDelayMs, unit);\r\n}"
}, {
	"Path": "io.reactivex.internal.disposables.ArrayCompositeDisposable.replaceResource",
	"Comment": "replaces the resource at the specified index and returns the old resource.",
	"Method": "Disposable replaceResource(int index,Disposable resource){\r\n    for (; ; ) {\r\n        Disposable o = get(index);\r\n        if (o == DisposableHelper.DISPOSED) {\r\n            resource.dispose();\r\n            return null;\r\n        }\r\n        if (compareAndSet(index, o, resource)) {\r\n            return o;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservablePublish.create",
	"Comment": "creates a operatorpublish instance to publish values of the given source observable.",
	"Method": "ConnectableObservable<T> create(ObservableSource<T> source){\r\n    final AtomicReference<PublishObserver<T>> curr = new AtomicReference<PublishObserver<T>>();\r\n    ObservableSource<T> onSubscribe = new PublishSource<T>(curr);\r\n    return RxJavaPlugins.onAssembly(new ObservablePublish<T>(onSubscribe, source, curr));\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowCanvas.visualize",
	"Comment": "returns a textual representation of the appearance of the object.",
	"Method": "String visualize(Canvas canvas){\r\n    ShadowCanvas shadowCanvas = Shadow.extract(canvas);\r\n    return shadowCanvas.getDescription();\r\n}"
}, {
	"Path": "retrofit2.HttpException.response",
	"Comment": "the full http response. this may be null if the exception was serialized.",
	"Method": "Response<?> response(){\r\n    return response;\r\n}"
}, {
	"Path": "org.robolectric.util.SchedulerTest.schedulerWithManyRunnables",
	"Comment": "tests for quadractic or exponential behavior in the scheduler, and stable sorting",
	"Method": "void schedulerWithManyRunnables(){\r\n    Random random = new Random(0);\r\n    Map<Integer, List<Integer>> orderCheck = new TreeMap();\r\n    List<Integer> actualOrder = new ArrayList();\r\n    for (int i = 0; i < 20_000; i++) {\r\n        int delay = random.nextInt(10);\r\n        List<Integer> list = orderCheck.get(delay);\r\n        if (list == null) {\r\n            list = new ArrayList();\r\n            orderCheck.put(delay, list);\r\n        }\r\n        list.add(i);\r\n        final int localI = i;\r\n        scheduler.postDelayed(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                actualOrder.add(localI);\r\n            }\r\n        }, delay);\r\n    }\r\n    assertThat(actualOrder).isEmpty();\r\n    scheduler.advanceToLastPostedRunnable();\r\n    assertThat(actualOrder).isEqualTo(ImmutableList.copyOf(Iterables.concat(orderCheck.values())));\r\n}"
}, {
	"Path": "org.robolectric.util.SchedulerTest.schedulerWithManyRunnables",
	"Comment": "tests for quadractic or exponential behavior in the scheduler, and stable sorting",
	"Method": "void schedulerWithManyRunnables(){\r\n    actualOrder.add(localI);\r\n}"
}, {
	"Path": "io.reactivex.parallel.ParallelFlowable.collect",
	"Comment": "collect the elements in each rail into a collection supplied via a collectionsupplierand collected into with a collector action, emitting the collection at the end.",
	"Method": "ParallelFlowable<C> collect(Callable<? extends C> collectionSupplier,BiConsumer<? super C, ? super T> collector){\r\n    ObjectHelper.requireNonNull(collectionSupplier, \"collectionSupplier is null\");\r\n    ObjectHelper.requireNonNull(collector, \"collector is null\");\r\n    return RxJavaPlugins.onAssembly(new ParallelCollect<T, C>(this, collectionSupplier, collector));\r\n}"
}, {
	"Path": "org.robolectric.shadows.httpclient.FakeHttpLayer.addHttpResponse",
	"Comment": "as a consumer of the fake http call, you should never call this method. this should be used solelyby components that exercises http calls.",
	"Method": "void addHttpResponse(HttpResponse response){\r\n    this.httpResponses.add(response);\r\n}"
}, {
	"Path": "org.openqa.selenium.interactions.Actions.release",
	"Comment": "releases the depressed left mouse button at the current mouse location.",
	"Method": "Actions release(WebElement target,Actions release){\r\n    if (isBuildingActions()) {\r\n        action.addAction(new ButtonReleaseAction(jsonMouse, null));\r\n    }\r\n    return tick(defaultMouse.createPointerUp(Button.LEFT.asArg()));\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowAbsListView.getLastSmoothScrollByDistance",
	"Comment": "robolectric accessor for the last smoothscrollby distance",
	"Method": "int getLastSmoothScrollByDistance(){\r\n    return lastSmoothScrollByDistance;\r\n}"
}, {
	"Path": "io.reactivex.disposables.SerialDisposable.get",
	"Comment": "returns the currently contained disposable or null if this container is empty.",
	"Method": "Disposable get(){\r\n    Disposable d = resource.get();\r\n    if (d == DisposableHelper.DISPOSED) {\r\n        return Disposables.disposed();\r\n    }\r\n    return d;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.initialiseTileMap",
	"Comment": "once source image and view dimensions are known, creates a map of sample size to tile grid.",
	"Method": "void initialiseTileMap(Point maxTileDimensions){\r\n    debug(\"initialiseTileMap maxTileDimensions=%dx%d\", maxTileDimensions.x, maxTileDimensions.y);\r\n    this.tileMap = new LinkedHashMap();\r\n    int sampleSize = fullImageSampleSize;\r\n    int xTiles = 1;\r\n    int yTiles = 1;\r\n    while (true) {\r\n        int sTileWidth = sWidth() / xTiles;\r\n        int sTileHeight = sHeight() / yTiles;\r\n        int subTileWidth = sTileWidth / sampleSize;\r\n        int subTileHeight = sTileHeight / sampleSize;\r\n        while (subTileWidth + xTiles + 1 > maxTileDimensions.x || (subTileWidth > getWidth() * 1.25 && sampleSize < fullImageSampleSize)) {\r\n            xTiles += 1;\r\n            sTileWidth = sWidth() / xTiles;\r\n            subTileWidth = sTileWidth / sampleSize;\r\n        }\r\n        while (subTileHeight + yTiles + 1 > maxTileDimensions.y || (subTileHeight > getHeight() * 1.25 && sampleSize < fullImageSampleSize)) {\r\n            yTiles += 1;\r\n            sTileHeight = sHeight() / yTiles;\r\n            subTileHeight = sTileHeight / sampleSize;\r\n        }\r\n        List<Tile> tileGrid = new ArrayList(xTiles * yTiles);\r\n        for (int x = 0; x < xTiles; x++) {\r\n            for (int y = 0; y < yTiles; y++) {\r\n                Tile tile = new Tile();\r\n                tile.sampleSize = sampleSize;\r\n                tile.visible = sampleSize == fullImageSampleSize;\r\n                tile.sRect = new Rect(x * sTileWidth, y * sTileHeight, x == xTiles - 1 ? sWidth() : (x + 1) * sTileWidth, y == yTiles - 1 ? sHeight() : (y + 1) * sTileHeight);\r\n                tile.vRect = new Rect(0, 0, 0, 0);\r\n                tile.fileSRect = new Rect(tile.sRect);\r\n                tileGrid.add(tile);\r\n            }\r\n        }\r\n        tileMap.put(sampleSize, tileGrid);\r\n        if (sampleSize == 1) {\r\n            break;\r\n        } else {\r\n            sampleSize /= 2;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.getExifOrientation",
	"Comment": "helper method for load tasks. examines the exif info on the image file to determine the orientation.this will only work for external files, not assets, resources or other uris.",
	"Method": "int getExifOrientation(Context context,String sourceUri){\r\n    int exifOrientation = ORIENTATION_0;\r\n    if (sourceUri.startsWith(ContentResolver.SCHEME_CONTENT)) {\r\n        Cursor cursor = null;\r\n        try {\r\n            String[] columns = { MediaStore.Images.Media.ORIENTATION };\r\n            cursor = context.getContentResolver().query(Uri.parse(sourceUri), columns, null, null, null);\r\n            if (cursor != null) {\r\n                if (cursor.moveToFirst()) {\r\n                    int orientation = cursor.getInt(0);\r\n                    if (VALID_ORIENTATIONS.contains(orientation) && orientation != ORIENTATION_USE_EXIF) {\r\n                        exifOrientation = orientation;\r\n                    } else {\r\n                        Log.w(TAG, \"Unsupported orientation: \" + orientation);\r\n                    }\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            Log.w(TAG, \"Could not get orientation of image from media store\");\r\n        } finally {\r\n            if (cursor != null) {\r\n                cursor.close();\r\n            }\r\n        }\r\n    } else if (sourceUri.startsWith(ImageSource.FILE_SCHEME) && !sourceUri.startsWith(ImageSource.ASSET_SCHEME)) {\r\n        try {\r\n            ExifInterface exifInterface = new ExifInterface(sourceUri.substring(ImageSource.FILE_SCHEME.length() - 1));\r\n            int orientationAttr = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);\r\n            if (orientationAttr == ExifInterface.ORIENTATION_NORMAL || orientationAttr == ExifInterface.ORIENTATION_UNDEFINED) {\r\n                exifOrientation = ORIENTATION_0;\r\n            } else if (orientationAttr == ExifInterface.ORIENTATION_ROTATE_90) {\r\n                exifOrientation = ORIENTATION_90;\r\n            } else if (orientationAttr == ExifInterface.ORIENTATION_ROTATE_180) {\r\n                exifOrientation = ORIENTATION_180;\r\n            } else if (orientationAttr == ExifInterface.ORIENTATION_ROTATE_270) {\r\n                exifOrientation = ORIENTATION_270;\r\n            } else {\r\n                Log.w(TAG, \"Unsupported EXIF orientation: \" + orientationAttr);\r\n            }\r\n        } catch (Exception e) {\r\n            Log.w(TAG, \"Could not get EXIF orientation of image\");\r\n        }\r\n    }\r\n    return exifOrientation;\r\n}"
}, {
	"Path": "io.reactivex.internal.subscriptions.ArrayCompositeSubscription.replaceResource",
	"Comment": "replaces the resource at the specified index and returns the old resource.",
	"Method": "Subscription replaceResource(int index,Subscription resource){\r\n    for (; ; ) {\r\n        Subscription o = get(index);\r\n        if (o == SubscriptionHelper.CANCELLED) {\r\n            if (resource != null) {\r\n                resource.cancel();\r\n            }\r\n            return null;\r\n        }\r\n        if (compareAndSet(index, o, resource)) {\r\n            return o;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.checkImageLoaded",
	"Comment": "check whether either the full size bitmap or base layer tiles are loaded. first time, send imageloaded event to listener.",
	"Method": "boolean checkImageLoaded(){\r\n    boolean imageLoaded = isBaseLayerReady();\r\n    if (!imageLoadedSent && imageLoaded) {\r\n        preDraw();\r\n        imageLoadedSent = true;\r\n        onImageLoaded();\r\n        if (onImageEventListener != null) {\r\n            onImageEventListener.onImageLoaded();\r\n        }\r\n    }\r\n    return imageLoaded;\r\n}"
}, {
	"Path": "com.vondear.rxfeature.module.scaner.CameraManager.init",
	"Comment": "initializes this static object with the context of the calling activity.",
	"Method": "void init(Context context){\r\n    if (cameraManager == null) {\r\n        cameraManager = new CameraManager(context);\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.remote.DesiredCapabilities.merge",
	"Comment": "merges the extra capabilities provided into this desiredcapabilities instance. if capabilitieswith the same name exist in this instance, they will be overridden by the values from theextracapabilities object.",
	"Method": "DesiredCapabilities merge(Capabilities extraCapabilities){\r\n    super.merge(extraCapabilities);\r\n    return this;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.limitedSCenter",
	"Comment": "given a requested source center and scale, calculate what the actual center will have to be to keep the image inpan limits, keeping the requested center as near to the middle of the screen as allowed.",
	"Method": "PointF limitedSCenter(float sCenterX,float sCenterY,float scale,PointF sTarget){\r\n    PointF vTranslate = vTranslateForSCenter(sCenterX, sCenterY, scale);\r\n    int vxCenter = getPaddingLeft() + (getWidth() - getPaddingRight() - getPaddingLeft()) / 2;\r\n    int vyCenter = getPaddingTop() + (getHeight() - getPaddingBottom() - getPaddingTop()) / 2;\r\n    float sx = (vxCenter - vTranslate.x) / scale;\r\n    float sy = (vyCenter - vTranslate.y) / scale;\r\n    sTarget.set(sx, sy);\r\n    return sTarget;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowServiceTest.onDestroyRemovesNotification",
	"Comment": "according to spec, if the foreground notification is not removed earlier,then it will be removed when the service is destroyed.",
	"Method": "void onDestroyRemovesNotification(){\r\n    Notification n = notBuilder.build();\r\n    service.startForeground(21, n);\r\n    service.onDestroy();\r\n    assertThat(shadowOf(nm2).getNotification(21)).isNull();\r\n}"
}, {
	"Path": "io.reactivex.subjects.SerializedSubject.emitLoop",
	"Comment": "loops until all notifications in the queue has been processed.",
	"Method": "void emitLoop(){\r\n    for (; ; ) {\r\n        AppendOnlyLinkedArrayList<Object> q;\r\n        synchronized (this) {\r\n            q = queue;\r\n            if (q == null) {\r\n                emitting = false;\r\n                return;\r\n            }\r\n            queue = null;\r\n        }\r\n        q.forEachWhile(this);\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.invisibilityOfAllElements",
	"Comment": "an expectation for checking all elements from given list to be invisible",
	"Method": "ExpectedCondition<Boolean> invisibilityOfAllElements(WebElement elements,ExpectedCondition<Boolean> invisibilityOfAllElements,List<WebElement> elements){\r\n    return new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver webDriver) {\r\n            return elements.stream().allMatch(ExpectedConditions::isInvisible);\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"invisibility of all elements \" + elements;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.invisibilityOfAllElements",
	"Comment": "an expectation for checking all elements from given list to be invisible",
	"Method": "ExpectedCondition<Boolean> invisibilityOfAllElements(WebElement elements,ExpectedCondition<Boolean> invisibilityOfAllElements,List<WebElement> elements){\r\n    return elements.stream().allMatch(ExpectedConditions::isInvisible);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.invisibilityOfAllElements",
	"Comment": "an expectation for checking all elements from given list to be invisible",
	"Method": "ExpectedCondition<Boolean> invisibilityOfAllElements(WebElement elements,ExpectedCondition<Boolean> invisibilityOfAllElements,List<WebElement> elements){\r\n    return \"invisibility of all elements \" + elements;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableFromIterableTest.testRawIterable",
	"Comment": "this tests the path that can not optimize based on size so must use setproducer.",
	"Method": "void testRawIterable(){\r\n    Iterable<String> it = new Iterable<String>() {\r\n        @Override\r\n        public Iterator<String> iterator() {\r\n            return new Iterator<String>() {\r\n                int i;\r\n                @Override\r\n                public boolean hasNext() {\r\n                    return i < 3;\r\n                }\r\n                @Override\r\n                public String next() {\r\n                    return String.valueOf(++i);\r\n                }\r\n                @Override\r\n                public void remove() {\r\n                }\r\n            };\r\n        }\r\n    };\r\n    Flowable<String> flowable = Flowable.fromIterable(it);\r\n    Subscriber<String> subscriber = TestHelper.mockSubscriber();\r\n    flowable.subscribe(subscriber);\r\n    verify(subscriber, times(1)).onNext(\"1\");\r\n    verify(subscriber, times(1)).onNext(\"2\");\r\n    verify(subscriber, times(1)).onNext(\"3\");\r\n    verify(subscriber, Mockito.never()).onError(any(Throwable.class));\r\n    verify(subscriber, times(1)).onComplete();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableFromIterableTest.testRawIterable",
	"Comment": "this tests the path that can not optimize based on size so must use setproducer.",
	"Method": "void testRawIterable(){\r\n    return new Iterator<String>() {\r\n        int i;\r\n        @Override\r\n        public boolean hasNext() {\r\n            return i < 3;\r\n        }\r\n        @Override\r\n        public String next() {\r\n            return String.valueOf(++i);\r\n        }\r\n        @Override\r\n        public void remove() {\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableFromIterableTest.testRawIterable",
	"Comment": "this tests the path that can not optimize based on size so must use setproducer.",
	"Method": "void testRawIterable(){\r\n    return i < 3;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableFromIterableTest.testRawIterable",
	"Comment": "this tests the path that can not optimize based on size so must use setproducer.",
	"Method": "void testRawIterable(){\r\n    return String.valueOf(++i);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableFromIterableTest.testRawIterable",
	"Comment": "this tests the path that can not optimize based on size so must use setproducer.",
	"Method": "void testRawIterable(){\r\n}"
}, {
	"Path": "io.reactivex.internal.observers.BlockingMultiObserver.blockingGetError",
	"Comment": "block until the latch is counted down and return the error received orwhen the wait is interrupted or times out, null otherwise.",
	"Method": "Throwable blockingGetError(Throwable blockingGetError,long timeout,TimeUnit unit){\r\n    if (getCount() != 0) {\r\n        try {\r\n            BlockingHelper.verifyNonBlocking();\r\n            if (!await(timeout, unit)) {\r\n                dispose();\r\n                throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit)));\r\n            }\r\n        } catch (InterruptedException ex) {\r\n            dispose();\r\n            throw ExceptionHelper.wrapOrThrow(ex);\r\n        }\r\n    }\r\n    return error;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.vTranslateForSCenter",
	"Comment": "get the translation required to place a given source coordinate at the center of the screen, with the centeradjusted for asymmetric padding. accepts the desired scale as an argument, so this is independent of currenttranslate and scale. the result is fitted to bounds, putting the image point as near to the screen center as permitted.",
	"Method": "PointF vTranslateForSCenter(float sCenterX,float sCenterY,float scale){\r\n    int vxCenter = getPaddingLeft() + (getWidth() - getPaddingRight() - getPaddingLeft()) / 2;\r\n    int vyCenter = getPaddingTop() + (getHeight() - getPaddingBottom() - getPaddingTop()) / 2;\r\n    if (satTemp == null) {\r\n        satTemp = new ScaleAndTranslate(0, new PointF(0, 0));\r\n    }\r\n    satTemp.scale = scale;\r\n    satTemp.vTranslate.set(vxCenter - (sCenterX * scale), vyCenter - (sCenterY * scale));\r\n    fitToBounds(true, satTemp);\r\n    return satTemp.vTranslate;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableReplay.observeOn",
	"Comment": "child subscribers will observe the events of the connectableobservable on thespecified scheduler.",
	"Method": "ConnectableFlowable<T> observeOn(ConnectableFlowable<T> cf,Scheduler scheduler){\r\n    final Flowable<T> flowable = cf.observeOn(scheduler);\r\n    return RxJavaPlugins.onAssembly(new ConnectableFlowableReplay<T>(cf, flowable));\r\n}"
}, {
	"Path": "org.robolectric.android.internal.LocalActivityInvoker.getIntentForActivity",
	"Comment": "getting stripped from androidx.test.monitor maven artifact",
	"Method": "Intent getIntentForActivity(Class<? extends Activity> activityClass){\r\n    Intent intent = Intent.makeMainActivity(new ComponentName(getTargetContext(), activityClass));\r\n    if (getTargetContext().getPackageManager().resolveActivity(intent, 0) != null) {\r\n        return intent;\r\n    }\r\n    return Intent.makeMainActivity(new ComponentName(getContext(), activityClass));\r\n}"
}, {
	"Path": "org.robolectric.shadows.ResourceHelper.parseFloatAttribute",
	"Comment": "parse a float attribute and return the parsed value into a given typedvalue.",
	"Method": "boolean parseFloatAttribute(String attribute,String value,TypedValue outValue,boolean requireUnit){\r\n    assert requireUnit == false || attribute != null;\r\n    value = value.trim();\r\n    int len = value.length();\r\n    if (len <= 0) {\r\n        return false;\r\n    }\r\n    char[] buf = value.toCharArray();\r\n    for (int i = 0; i < len; i++) {\r\n        if (buf[i] > 255) {\r\n            return false;\r\n        }\r\n    }\r\n    if (buf[0] < '0' && buf[0] > '9' && buf[0] != '.' && buf[0] != '-') {\r\n        return false;\r\n    }\r\n    Matcher m = sFloatPattern.matcher(value);\r\n    if (m.matches()) {\r\n        String f_str = m.group(1);\r\n        String end = m.group(2);\r\n        float f;\r\n        try {\r\n            f = Float.parseFloat(f_str);\r\n        } catch (NumberFormatException e) {\r\n            return false;\r\n        }\r\n        if (end.length() > 0 && end.charAt(0) != ' ') {\r\n            if (parseUnit(end, outValue, sFloatOut)) {\r\n                computeTypedValue(outValue, f, sFloatOut[0]);\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        end = end.trim();\r\n        if (end.length() == 0) {\r\n            if (outValue != null) {\r\n                outValue.assetCookie = 0;\r\n                outValue.string = null;\r\n                if (requireUnit == false) {\r\n                    outValue.type = TypedValue.TYPE_FLOAT;\r\n                    outValue.data = Float.floatToIntBits(f);\r\n                } else {\r\n                    applyUnit(sUnitNames[1], outValue, sFloatOut);\r\n                    computeTypedValue(outValue, f, sFloatOut[0]);\r\n                    System.out.println(String.format(\"Dimension \\\"%1$s\\\" in attribute \\\"%2$s\\\" is missing unit!\", value, attribute));\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "retrofit2.RetrofitTest.argumentCapture",
	"Comment": "confirm that retrofit encodes parameters when the call is executed, and not earlier.",
	"Method": "void argumentCapture(){\r\n    AtomicInteger i = new AtomicInteger();\r\n    server.enqueue(new MockResponse().setBody(\"a\"));\r\n    server.enqueue(new MockResponse().setBody(\"b\"));\r\n    Retrofit retrofit = new Retrofit.Builder().baseUrl(server.url(\"/\")).addConverterFactory(new ToStringConverterFactory()).build();\r\n    MutableParameters mutableParameters = retrofit.create(MutableParameters.class);\r\n    i.set(100);\r\n    Call<String> call1 = mutableParameters.method(i);\r\n    i.set(101);\r\n    Response<String> response1 = call1.execute();\r\n    i.set(102);\r\n    assertEquals(\"a\", response1.body());\r\n    assertEquals(\"/?i=101\", server.takeRequest().getPath());\r\n    i.set(200);\r\n    Call<String> call2 = call1.clone();\r\n    i.set(201);\r\n    Response<String> response2 = call2.execute();\r\n    i.set(202);\r\n    assertEquals(\"b\", response2.body());\r\n    assertEquals(\"/?i=201\", server.takeRequest().getPath());\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.not",
	"Comment": "an expectation with the logical opposite condition of the given condition.note that if the condition you are inverting throws an exception that is caught by the ignoredexceptions, the inversion will not take place and lead to confusing results.",
	"Method": "ExpectedCondition<Boolean> not(ExpectedCondition<?> condition){\r\n    return new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            Object result = condition.apply(driver);\r\n            return result == null || result.equals(Boolean.FALSE);\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"condition to not be valid: \" + condition;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.not",
	"Comment": "an expectation with the logical opposite condition of the given condition.note that if the condition you are inverting throws an exception that is caught by the ignoredexceptions, the inversion will not take place and lead to confusing results.",
	"Method": "ExpectedCondition<Boolean> not(ExpectedCondition<?> condition){\r\n    Object result = condition.apply(driver);\r\n    return result == null || result.equals(Boolean.FALSE);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.not",
	"Comment": "an expectation with the logical opposite condition of the given condition.note that if the condition you are inverting throws an exception that is caught by the ignoredexceptions, the inversion will not take place and lead to confusing results.",
	"Method": "ExpectedCondition<Boolean> not(ExpectedCondition<?> condition){\r\n    return \"condition to not be valid: \" + condition;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.attributeContains",
	"Comment": "an expectation for checking webelement with given locator has attribute which contains specificvalue",
	"Method": "ExpectedCondition<Boolean> attributeContains(WebElement element,String attribute,String value,ExpectedCondition<Boolean> attributeContains,By locator,String attribute,String value){\r\n    return new ExpectedCondition<Boolean>() {\r\n        private String currentValue = null;\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            return getAttributeOrCssValue(driver.findElement(locator), attribute).map(seen -> seen.contains(value)).orElse(false);\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"value found by %s to contain \\\"%s\\\". Current value: \\\"%s\\\"\", locator, value, currentValue);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.attributeContains",
	"Comment": "an expectation for checking webelement with given locator has attribute which contains specificvalue",
	"Method": "ExpectedCondition<Boolean> attributeContains(WebElement element,String attribute,String value,ExpectedCondition<Boolean> attributeContains,By locator,String attribute,String value){\r\n    return getAttributeOrCssValue(driver.findElement(locator), attribute).map(seen -> seen.contains(value)).orElse(false);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.attributeContains",
	"Comment": "an expectation for checking webelement with given locator has attribute which contains specificvalue",
	"Method": "ExpectedCondition<Boolean> attributeContains(WebElement element,String attribute,String value,ExpectedCondition<Boolean> attributeContains,By locator,String attribute,String value){\r\n    return String.format(\"value found by %s to contain \\\"%s\\\". Current value: \\\"%s\\\"\", locator, value, currentValue);\r\n}"
}, {
	"Path": "io.reactivex.disposables.CompositeDisposable.remove",
	"Comment": "removes and disposes the given disposable if it is part of thiscontainer.",
	"Method": "boolean remove(Disposable d){\r\n    if (delete(d)) {\r\n        d.dispose();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.reactivex.processors.MulticastProcessor.create",
	"Comment": "constructs a fresh instance with the given prefetch amount and no refcount behavior.",
	"Method": "MulticastProcessor<T> create(MulticastProcessor<T> create,boolean refCount,MulticastProcessor<T> create,int bufferSize,MulticastProcessor<T> create,int bufferSize,boolean refCount){\r\n    return new MulticastProcessor<T>(bufferSize, refCount);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowMotionEvent.transform",
	"Comment": "shadow this directly as opposed to nativetransform because need access to shadowmatrix",
	"Method": "void transform(Matrix matrix){\r\n    checkNotNull(matrix);\r\n    NativeInput.MotionEvent event = getNativeMotionEvent();\r\n    ShadowMatrix shadowMatrix = Shadow.extract(matrix);\r\n    float[] m = new float[9];\r\n    shadowMatrix.getValues(m);\r\n    event.transform(m);\r\n}"
}, {
	"Path": "io.reactivex.internal.functions.ObjectHelper.verifyPositive",
	"Comment": "validate that the given value is positive or report an illegalargumentexception withthe parameter name.",
	"Method": "int verifyPositive(int value,String paramName,long verifyPositive,long value,String paramName){\r\n    if (value <= 0L) {\r\n        throw new IllegalArgumentException(paramName + \" > 0 required but it was \" + value);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.openqa.selenium.lift.HamcrestWebDriverTestCase.type",
	"Comment": "type characters into an element of the page, typically an input field",
	"Method": "void type(String text,Finder<WebElement, WebDriver> inputFinder){\r\n    context.type(text, inputFinder);\r\n}"
}, {
	"Path": "io.reactivex.internal.observers.BlockingBaseObserver.blockingGet",
	"Comment": "block until the first value arrives and return it, otherwisereturn null for an empty source and rethrow any exception.",
	"Method": "T blockingGet(){\r\n    if (getCount() != 0) {\r\n        try {\r\n            BlockingHelper.verifyNonBlocking();\r\n            await();\r\n        } catch (InterruptedException ex) {\r\n            dispose();\r\n            throw ExceptionHelper.wrapOrThrow(ex);\r\n        }\r\n    }\r\n    Throwable e = error;\r\n    if (e != null) {\r\n        throw ExceptionHelper.wrapOrThrow(e);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.robolectric.manifest.MetaData.getColor",
	"Comment": "returns the color value represented by the given string value",
	"Method": "int getColor(String value){\r\n    if (value != null) {\r\n        if (value.startsWith(\"#\") == false) {\r\n            throw new NumberFormatException(String.format(\"Color value '%s' must start with #\", value));\r\n        }\r\n        value = value.substring(1);\r\n        if (value.length() > 8) {\r\n            throw new NumberFormatException(String.format(\"Color value '%s' is too long. Format is either\" + \"#AARRGGBB, #RRGGBB, #RGB, or #ARGB\", value));\r\n        }\r\n        if (value.length() == 3) {\r\n            char[] color = new char[8];\r\n            color[0] = color[1] = 'F';\r\n            color[2] = color[3] = value.charAt(0);\r\n            color[4] = color[5] = value.charAt(1);\r\n            color[6] = color[7] = value.charAt(2);\r\n            value = new String(color);\r\n        } else if (value.length() == 4) {\r\n            char[] color = new char[8];\r\n            color[0] = color[1] = value.charAt(0);\r\n            color[2] = color[3] = value.charAt(1);\r\n            color[4] = color[5] = value.charAt(2);\r\n            color[6] = color[7] = value.charAt(3);\r\n            value = new String(color);\r\n        } else if (value.length() == 6) {\r\n            value = \"FF\" + value;\r\n        }\r\n        return (int) Long.parseLong(value, 16);\r\n    }\r\n    throw new NumberFormatException();\r\n}"
}, {
	"Path": "org.robolectric.shadows.httpclient.FakeHttp.getSentHttpRequest",
	"Comment": "accessor to obtain http requests made during the current test in the order in which they were made.",
	"Method": "HttpRequest getSentHttpRequest(int index){\r\n    return getFakeHttpLayer().getSentHttpRequestInfo(index).getHttpRequest();\r\n}"
}, {
	"Path": "io.reactivex.subscribers.SerializedSubscriberTest.testNotificationDelay",
	"Comment": "test that a notification does not get delayed in the queue waiting for the next event to push it through.",
	"Method": "void testNotificationDelay(){\r\n    ExecutorService tp1 = Executors.newFixedThreadPool(1);\r\n    ExecutorService tp2 = Executors.newFixedThreadPool(1);\r\n    try {\r\n        int n = 10;\r\n        for (int i = 0; i < n; i++) {\r\n            final CountDownLatch firstOnNext = new CountDownLatch(1);\r\n            final CountDownLatch onNextCount = new CountDownLatch(2);\r\n            final CountDownLatch latch = new CountDownLatch(1);\r\n            final CountDownLatch running = new CountDownLatch(2);\r\n            TestSubscriber<String> ts = new TestSubscriber<String>(new DefaultSubscriber<String>() {\r\n                @Override\r\n                public void onComplete() {\r\n                }\r\n                @Override\r\n                public void onError(Throwable e) {\r\n                }\r\n                @Override\r\n                public void onNext(String t) {\r\n                    firstOnNext.countDown();\r\n                    try {\r\n                        latch.await();\r\n                    } catch (InterruptedException e) {\r\n                    }\r\n                }\r\n            });\r\n            Subscriber<String> subscriber = serializedSubscriber(ts);\r\n            Future<?> f1 = tp1.submit(new OnNextThread(subscriber, 1, onNextCount, running));\r\n            Future<?> f2 = tp2.submit(new OnNextThread(subscriber, 1, onNextCount, running));\r\n            running.await();\r\n            firstOnNext.await();\r\n            Thread t1 = ts.lastThread();\r\n            System.out.println(\"first onNext on thread: \" + t1);\r\n            latch.countDown();\r\n            waitOnThreads(f1, f2);\r\n            assertEquals(2, ts.valueCount());\r\n            Thread t2 = ts.lastThread();\r\n            System.out.println(\"second onNext on thread: \" + t2);\r\n            assertSame(t1, t2);\r\n            System.out.println(ts.values());\r\n            subscriber.onComplete();\r\n            System.out.println(ts.values());\r\n        }\r\n    } finally {\r\n        tp1.shutdown();\r\n        tp2.shutdown();\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.subscribers.SerializedSubscriberTest.testNotificationDelay",
	"Comment": "test that a notification does not get delayed in the queue waiting for the next event to push it through.",
	"Method": "void testNotificationDelay(){\r\n}"
}, {
	"Path": "io.reactivex.subscribers.SerializedSubscriberTest.testNotificationDelay",
	"Comment": "test that a notification does not get delayed in the queue waiting for the next event to push it through.",
	"Method": "void testNotificationDelay(){\r\n}"
}, {
	"Path": "io.reactivex.subscribers.SerializedSubscriberTest.testNotificationDelay",
	"Comment": "test that a notification does not get delayed in the queue waiting for the next event to push it through.",
	"Method": "void testNotificationDelay(){\r\n    firstOnNext.countDown();\r\n    try {\r\n        latch.await();\r\n    } catch (InterruptedException e) {\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.res.android.NativeObjRegistry.getNativeObject",
	"Comment": "retrieve the native object for given id. throws if object with that id cannot be found",
	"Method": "T getNativeObject(long nativeId){\r\n    T object = nativeObjToIdMap.get(nativeId);\r\n    if (object != null) {\r\n        return object;\r\n    } else {\r\n        throw new NullPointerException(String.format(\"Could not find object with nativeId: %d. Currently registered ids: %s\", nativeId, nativeObjToIdMap.keySet()));\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.ResourceHelper.getColor",
	"Comment": "returns the color value represented by the given string value",
	"Method": "int getColor(String value){\r\n    if (value != null) {\r\n        if (value.startsWith(\"#\") == false) {\r\n            throw new NumberFormatException(String.format(\"Color value '%s' must start with #\", value));\r\n        }\r\n        value = value.substring(1);\r\n        if (value.length() > 8) {\r\n            throw new NumberFormatException(String.format(\"Color value '%s' is too long. Format is either\" + \"#AARRGGBB, #RRGGBB, #RGB, or #ARGB\", value));\r\n        }\r\n        if (value.length() == 3) {\r\n            char[] color = new char[8];\r\n            color[0] = color[1] = 'F';\r\n            color[2] = color[3] = value.charAt(0);\r\n            color[4] = color[5] = value.charAt(1);\r\n            color[6] = color[7] = value.charAt(2);\r\n            value = new String(color);\r\n        } else if (value.length() == 4) {\r\n            char[] color = new char[8];\r\n            color[0] = color[1] = value.charAt(0);\r\n            color[2] = color[3] = value.charAt(1);\r\n            color[4] = color[5] = value.charAt(2);\r\n            color[6] = color[7] = value.charAt(3);\r\n            value = new String(color);\r\n        } else if (value.length() == 6) {\r\n            value = \"FF\" + value;\r\n        }\r\n        return (int) Long.parseLong(value, 16);\r\n    }\r\n    throw new NumberFormatException();\r\n}"
}, {
	"Path": "org.openqa.selenium.interactions.touch.TouchActions.scroll",
	"Comment": "creates a scroll gesture that starts on a particular screen location.",
	"Method": "TouchActions scroll(WebElement onElement,int xOffset,int yOffset,TouchActions scroll,int xOffset,int yOffset){\r\n    action.addAction(new ScrollAction(touchScreen, xOffset, yOffset));\r\n    return this;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.urlContains",
	"Comment": "an expectation for the url of the current page to contain specific text.",
	"Method": "ExpectedCondition<Boolean> urlContains(String fraction){\r\n    return new ExpectedCondition<Boolean>() {\r\n        private String currentUrl = \"\";\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            currentUrl = driver.getCurrentUrl();\r\n            return currentUrl != null && currentUrl.contains(fraction);\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"url to contain \\\"%s\\\". Current url: \\\"%s\\\"\", fraction, currentUrl);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.urlContains",
	"Comment": "an expectation for the url of the current page to contain specific text.",
	"Method": "ExpectedCondition<Boolean> urlContains(String fraction){\r\n    currentUrl = driver.getCurrentUrl();\r\n    return currentUrl != null && currentUrl.contains(fraction);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.urlContains",
	"Comment": "an expectation for the url of the current page to contain specific text.",
	"Method": "ExpectedCondition<Boolean> urlContains(String fraction){\r\n    return String.format(\"url to contain \\\"%s\\\". Current url: \\\"%s\\\"\", fraction, currentUrl);\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.setRegionDecoderFactory",
	"Comment": "swap the default region decoder implementation for one of your own. you must do this before setting the image file orasset, and you cannot use a custom decoder when using layout xml to set an asset name.",
	"Method": "void setRegionDecoderFactory(DecoderFactory<? extends ImageRegionDecoder> regionDecoderFactory){\r\n    if (regionDecoderFactory == null) {\r\n        throw new IllegalArgumentException(\"Decoder factory cannot be set to null\");\r\n    }\r\n    this.regionDecoderFactory = regionDecoderFactory;\r\n}"
}, {
	"Path": "io.reactivex.subscribers.TestSubscriber.assertSubscribed",
	"Comment": "assert that the onsubscribe method was called exactly once.",
	"Method": "TestSubscriber<T> assertSubscribed(){\r\n    if (upstream.get() == null) {\r\n        throw fail(\"Not subscribed!\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.ImageSource.resource",
	"Comment": "create an instance from a resource. the correct resource for the device screen resolution will be used.",
	"Method": "ImageSource resource(int resId){\r\n    return new ImageSource(resId);\r\n}"
}, {
	"Path": "org.robolectric.internal.bytecode.OldClassInstrumentor.interceptInvokeVirtualMethodWithoutInvokeDynamic",
	"Comment": "intercepts the method without using the invokedynamic bytecode instruction.should be called through interceptinvokevirtualmethod, not directly.",
	"Method": "void interceptInvokeVirtualMethodWithoutInvokeDynamic(MutableClass mutableClass,ListIterator<AbstractInsnNode> instructions,MethodInsnNode targetMethod){\r\n    boolean isStatic = targetMethod.getOpcode() == Opcodes.INVOKESTATIC;\r\n    instructions.remove();\r\n    Type[] argumentTypes = Type.getArgumentTypes(targetMethod.desc);\r\n    instructions.add(new LdcInsnNode(argumentTypes.length));\r\n    instructions.add(new TypeInsnNode(Opcodes.ANEWARRAY, \"java/lang/Object\"));\r\n    for (int i = argumentTypes.length - 1; i >= 0; i--) {\r\n        Type type = argumentTypes[i];\r\n        int argWidth = type.getSize();\r\n        if (argWidth == 1) {\r\n            instructions.add(new InsnNode(Opcodes.DUP_X1));\r\n            instructions.add(new InsnNode(Opcodes.SWAP));\r\n            instructions.add(new LdcInsnNode(i));\r\n            instructions.add(new InsnNode(Opcodes.SWAP));\r\n            box(type, instructions);\r\n            instructions.add(new InsnNode(Opcodes.AASTORE));\r\n        } else if (argWidth == 2) {\r\n            instructions.add(new InsnNode(Opcodes.DUP_X2));\r\n            instructions.add(new InsnNode(Opcodes.DUP_X2));\r\n            instructions.add(new InsnNode(Opcodes.POP));\r\n            box(type, instructions);\r\n            instructions.add(new LdcInsnNode(i));\r\n            instructions.add(new InsnNode(Opcodes.SWAP));\r\n            instructions.add(new InsnNode(Opcodes.AASTORE));\r\n        }\r\n    }\r\n    if (isStatic) {\r\n        instructions.add(new InsnNode(Opcodes.ACONST_NULL));\r\n        instructions.add(new InsnNode(Opcodes.SWAP));\r\n    }\r\n    instructions.add(new LdcInsnNode(targetMethod.owner + \"/\" + targetMethod.name + targetMethod.desc));\r\n    instructions.add(new InsnNode(Opcodes.DUP_X2));\r\n    instructions.add(new InsnNode(Opcodes.POP));\r\n    instructions.add(new LdcInsnNode(mutableClass.classType));\r\n    instructions.add(new MethodInsnNode(Opcodes.INVOKESTATIC, Type.getType(RobolectricInternals.class).getInternalName(), \"intercept\", \"(Ljava/lang/String;Ljava/lang/Object;[Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;\", false));\r\n    final Type returnType = Type.getReturnType(targetMethod.desc);\r\n    switch(returnType.getSort()) {\r\n        case ARRAY:\r\n        case OBJECT:\r\n            String remappedType = mutableClass.config.mappedTypeName(returnType.getInternalName());\r\n            instructions.add(new TypeInsnNode(Opcodes.CHECKCAST, remappedType));\r\n            break;\r\n        case VOID:\r\n            instructions.add(new InsnNode(Opcodes.POP));\r\n            break;\r\n        case Type.LONG:\r\n            instructions.add(new TypeInsnNode(Opcodes.CHECKCAST, Type.getInternalName(Long.class)));\r\n            instructions.add(new MethodInsnNode(Opcodes.INVOKEVIRTUAL, Type.getInternalName(Long.class), \"longValue\", Type.getMethodDescriptor(Type.LONG_TYPE), false));\r\n            break;\r\n        case Type.FLOAT:\r\n            instructions.add(new TypeInsnNode(Opcodes.CHECKCAST, Type.getInternalName(Float.class)));\r\n            instructions.add(new MethodInsnNode(Opcodes.INVOKEVIRTUAL, Type.getInternalName(Float.class), \"floatValue\", Type.getMethodDescriptor(Type.FLOAT_TYPE), false));\r\n            break;\r\n        case Type.DOUBLE:\r\n            instructions.add(new TypeInsnNode(Opcodes.CHECKCAST, Type.getInternalName(Double.class)));\r\n            instructions.add(new MethodInsnNode(Opcodes.INVOKEVIRTUAL, Type.getInternalName(Double.class), \"doubleValue\", Type.getMethodDescriptor(Type.DOUBLE_TYPE), false));\r\n            break;\r\n        case Type.BOOLEAN:\r\n            instructions.add(new TypeInsnNode(Opcodes.CHECKCAST, Type.getInternalName(Boolean.class)));\r\n            instructions.add(new MethodInsnNode(Opcodes.INVOKEVIRTUAL, Type.getInternalName(Boolean.class), \"booleanValue\", Type.getMethodDescriptor(Type.BOOLEAN_TYPE), false));\r\n            break;\r\n        case Type.INT:\r\n            instructions.add(new TypeInsnNode(Opcodes.CHECKCAST, Type.getInternalName(Integer.class)));\r\n            instructions.add(new MethodInsnNode(Opcodes.INVOKEVIRTUAL, Type.getInternalName(Integer.class), \"intValue\", Type.getMethodDescriptor(Type.INT_TYPE), false));\r\n            break;\r\n        case Type.SHORT:\r\n            instructions.add(new TypeInsnNode(Opcodes.CHECKCAST, Type.getInternalName(Short.class)));\r\n            instructions.add(new MethodInsnNode(Opcodes.INVOKEVIRTUAL, Type.getInternalName(Short.class), \"shortValue\", Type.getMethodDescriptor(Type.SHORT_TYPE), false));\r\n            break;\r\n        case Type.BYTE:\r\n            instructions.add(new TypeInsnNode(Opcodes.CHECKCAST, Type.getInternalName(Byte.class)));\r\n            instructions.add(new MethodInsnNode(Opcodes.INVOKEVIRTUAL, Type.getInternalName(Byte.class), \"byteValue\", Type.getMethodDescriptor(Type.BYTE_TYPE), false));\r\n            break;\r\n        default:\r\n            throw new RuntimeException(\"Not implemented: \" + getClass().getName() + \" cannot intercept methods with return type \" + returnType.getClassName());\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.parallel.ParallelFlowable.validate",
	"Comment": "validates the number of subscribers and returns true if their numbermatches the parallelism level of this parallelflowable.",
	"Method": "boolean validate(Subscriber<?>[] subscribers){\r\n    int p = parallelism();\r\n    if (subscribers.length != p) {\r\n        Throwable iae = new IllegalArgumentException(\"parallelism = \" + p + \", subscribers = \" + subscribers.length);\r\n        for (Subscriber<?> s : subscribers) {\r\n            EmptySubscription.error(iae, s);\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.openqa.selenium.remote.service.DriverService.start",
	"Comment": "starts this service if it is not already running. this method will block until the server hasbeen fully started and is ready to handle commands.",
	"Method": "void start(){\r\n    lock.lock();\r\n    try {\r\n        if (process != null) {\r\n            return;\r\n        }\r\n        process = new CommandLine(this.executable, args.toArray(new String[] {}));\r\n        process.setEnvironmentVariables(environment);\r\n        process.copyOutputTo(getOutputStream());\r\n        process.executeAsync();\r\n        waitUntilAvailable();\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.animateScale",
	"Comment": "creates a scale animation builder, that when started will animate a zoom in or out. if this would move the imagebeyond the panning limits, the image is automatically panned during the animation.",
	"Method": "AnimationBuilder animateScale(float scale){\r\n    if (!isReady()) {\r\n        return null;\r\n    }\r\n    return new AnimationBuilder(scale);\r\n}"
}, {
	"Path": "org.openqa.selenium.logging.SessionLogHandler.getSessionLogs",
	"Comment": "creates a session logs map, with session logs mapped to session ids, givena raw session log map as a json object.",
	"Method": "Map<String, SessionLogs> getSessionLogs(Map<String, Object> rawSessionMap){\r\n    Map<String, SessionLogs> sessionLogsMap = new HashMap();\r\n    for (Map.Entry<String, Object> entry : rawSessionMap.entrySet()) {\r\n        String sessionId = entry.getKey();\r\n        if (!(entry.getValue() instanceof Map)) {\r\n            throw new InvalidArgumentException(\"Expected value to be an object: \" + entry.getValue());\r\n        }\r\n        @SuppressWarnings(\"unchecked\")\r\n        Map<String, Object> value = (Map<String, Object>) entry.getValue();\r\n        SessionLogs sessionLogs = SessionLogs.fromJSON(value);\r\n        sessionLogsMap.put(sessionId, sessionLogs);\r\n    }\r\n    return sessionLogsMap;\r\n}"
}, {
	"Path": "com.thoughtworks.selenium.SeleneseTestBase.checkForVerificationErrors",
	"Comment": "asserts that there were no verification errors during the current test, failing immediately ifany are found",
	"Method": "void checkForVerificationErrors(){\r\n    String verificationErrorString = verificationErrors.toString();\r\n    clearVerificationErrors();\r\n    if (!\"\".equals(verificationErrorString)) {\r\n        fail(verificationErrorString);\r\n    }\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.isBaseLayerReady",
	"Comment": "checks whether the base layer of tiles or full size bitmap is ready.",
	"Method": "boolean isBaseLayerReady(){\r\n    if (bitmap != null && !bitmapIsPreview) {\r\n        return true;\r\n    } else if (tileMap != null) {\r\n        boolean baseLayerReady = true;\r\n        for (Map.Entry<Integer, List<Tile>> tileMapEntry : tileMap.entrySet()) {\r\n            if (tileMapEntry.getKey() == fullImageSampleSize) {\r\n                for (Tile tile : tileMapEntry.getValue()) {\r\n                    if (tile.loading || tile.bitmap == null) {\r\n                        baseLayerReady = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return baseLayerReady;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.reactivex.processors.PublishProcessorTest.testReSubscribe",
	"Comment": "should be able to unsubscribe all subscribers, have it stop emitting, then subscribe new ones and it start emitting again.",
	"Method": "void testReSubscribe(){\r\n    final PublishProcessor<Integer> pp = PublishProcessor.create();\r\n    Subscriber<Integer> subscriber1 = TestHelper.mockSubscriber();\r\n    TestSubscriber<Integer> ts = new TestSubscriber<Integer>(subscriber1);\r\n    pp.subscribe(ts);\r\n    pp.onNext(1);\r\n    InOrder inOrder1 = inOrder(subscriber1);\r\n    inOrder1.verify(subscriber1, times(1)).onNext(1);\r\n    inOrder1.verifyNoMoreInteractions();\r\n    ts.dispose();\r\n    pp.onNext(2);\r\n    Subscriber<Integer> subscriber2 = TestHelper.mockSubscriber();\r\n    TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>(subscriber2);\r\n    pp.subscribe(ts2);\r\n    pp.onNext(3);\r\n    InOrder inOrder2 = inOrder(subscriber2);\r\n    inOrder2.verify(subscriber2, times(1)).onNext(3);\r\n    inOrder2.verifyNoMoreInteractions();\r\n    ts2.dispose();\r\n}"
}, {
	"Path": "io.reactivex.subscribers.TestSubscriber.hasSubscription",
	"Comment": "returns true if this testsubscriber received a subscription.",
	"Method": "boolean hasSubscription(){\r\n    return upstream.get() != null;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.setDebug",
	"Comment": "enables visual debugging, showing tile boundaries and sizes.",
	"Method": "void setDebug(boolean debug){\r\n    this.debug = debug;\r\n}"
}, {
	"Path": "org.robolectric.shadows.httpclient.FakeHttp.getNextSentHttpRequest",
	"Comment": "accessor to obtain http requests made during the current test in the order in which they were made.",
	"Method": "HttpRequest getNextSentHttpRequest(){\r\n    HttpRequestInfo httpRequestInfo = getFakeHttpLayer().getNextSentHttpRequestInfo();\r\n    return httpRequestInfo == null ? null : httpRequestInfo.getHttpRequest();\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.setTileBackgroundColor",
	"Comment": "set a solid color to render behind tiles, useful for displaying transparent pngs.",
	"Method": "void setTileBackgroundColor(int tileBgColor){\r\n    if (Color.alpha(tileBgColor) == 0) {\r\n        tileBgPaint = null;\r\n    } else {\r\n        tileBgPaint = new Paint();\r\n        tileBgPaint.setStyle(Style.FILL);\r\n        tileBgPaint.setColor(tileBgColor);\r\n    }\r\n    invalidate();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableReplay.multicastSelector",
	"Comment": "given a connectable observable factory, it multicasts over the generatedconnectableobservable via a selector function.",
	"Method": "Flowable<R> multicastSelector(Callable<? extends ConnectableFlowable<U>> connectableFactory,Function<? super Flowable<U>, ? extends Publisher<R>> selector){\r\n    return new MulticastFlowable<R, U>(connectableFactory, selector);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textToBe",
	"Comment": "an expectation for checking webelement with given locator has specific text",
	"Method": "ExpectedCondition<Boolean> textToBe(By locator,String value){\r\n    return new ExpectedCondition<Boolean>() {\r\n        private String currentValue = null;\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            try {\r\n                currentValue = driver.findElement(locator).getText();\r\n                return currentValue.equals(value);\r\n            } catch (Exception e) {\r\n                return false;\r\n            }\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"element found by %s to have text \\\"%s\\\". Current text: \\\"%s\\\"\", locator, value, currentValue);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textToBe",
	"Comment": "an expectation for checking webelement with given locator has specific text",
	"Method": "ExpectedCondition<Boolean> textToBe(By locator,String value){\r\n    try {\r\n        currentValue = driver.findElement(locator).getText();\r\n        return currentValue.equals(value);\r\n    } catch (Exception e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textToBe",
	"Comment": "an expectation for checking webelement with given locator has specific text",
	"Method": "ExpectedCondition<Boolean> textToBe(By locator,String value){\r\n    return String.format(\"element found by %s to have text \\\"%s\\\". Current text: \\\"%s\\\"\", locator, value, currentValue);\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.setPanEnabled",
	"Comment": "enable or disable pan gesture detection. disabling pan causes the image to be centered.",
	"Method": "void setPanEnabled(boolean panEnabled){\r\n    this.panEnabled = panEnabled;\r\n    if (!panEnabled && vTranslate != null) {\r\n        vTranslate.x = (getWidth() / 2) - (scale * (sWidth() / 2));\r\n        vTranslate.y = (getHeight() / 2) - (scale * (sHeight() / 2));\r\n        if (isReady()) {\r\n            refreshRequiredTiles(true);\r\n            invalidate();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.internal.util.ExceptionHelper.throwIfThrowable",
	"Comment": "workaround for java 6 not supporting throwing a final throwable from a catch block.",
	"Method": "Exception throwIfThrowable(Throwable e){\r\n    if (e instanceof Exception) {\r\n        return (Exception) e;\r\n    }\r\n    throw (E) e;\r\n}"
}, {
	"Path": "io.reactivex.Notification.createOnNext",
	"Comment": "constructs an onnext notification containing the given value.",
	"Method": "Notification<T> createOnNext(T value){\r\n    ObjectHelper.requireNonNull(value, \"value is null\");\r\n    return new Notification<T>(value);\r\n}"
}, {
	"Path": "io.reactivex.observers.SerializedObserverTest.testNotificationDelay",
	"Comment": "test that a notification does not get delayed in the queue waiting for the next event to push it through.",
	"Method": "void testNotificationDelay(){\r\n    ExecutorService tp1 = Executors.newFixedThreadPool(1);\r\n    ExecutorService tp2 = Executors.newFixedThreadPool(1);\r\n    try {\r\n        int n = 10;\r\n        for (int i = 0; i < n; i++) {\r\n            final CountDownLatch firstOnNext = new CountDownLatch(1);\r\n            final CountDownLatch onNextCount = new CountDownLatch(2);\r\n            final CountDownLatch latch = new CountDownLatch(1);\r\n            final CountDownLatch running = new CountDownLatch(2);\r\n            TestObserver<String> to = new TestObserver<String>(new DefaultObserver<String>() {\r\n                @Override\r\n                public void onComplete() {\r\n                }\r\n                @Override\r\n                public void onError(Throwable e) {\r\n                }\r\n                @Override\r\n                public void onNext(String t) {\r\n                    firstOnNext.countDown();\r\n                    try {\r\n                        latch.await();\r\n                    } catch (InterruptedException e) {\r\n                    }\r\n                }\r\n            });\r\n            Observer<String> o = serializedObserver(to);\r\n            Future<?> f1 = tp1.submit(new OnNextThread(o, 1, onNextCount, running));\r\n            Future<?> f2 = tp2.submit(new OnNextThread(o, 1, onNextCount, running));\r\n            running.await();\r\n            firstOnNext.await();\r\n            Thread t1 = to.lastThread();\r\n            System.out.println(\"first onNext on thread: \" + t1);\r\n            latch.countDown();\r\n            waitOnThreads(f1, f2);\r\n            assertEquals(2, to.valueCount());\r\n            Thread t2 = to.lastThread();\r\n            System.out.println(\"second onNext on thread: \" + t2);\r\n            assertSame(t1, t2);\r\n            System.out.println(to.values());\r\n            o.onComplete();\r\n            System.out.println(to.values());\r\n        }\r\n    } finally {\r\n        tp1.shutdown();\r\n        tp2.shutdown();\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.observers.SerializedObserverTest.testNotificationDelay",
	"Comment": "test that a notification does not get delayed in the queue waiting for the next event to push it through.",
	"Method": "void testNotificationDelay(){\r\n}"
}, {
	"Path": "io.reactivex.observers.SerializedObserverTest.testNotificationDelay",
	"Comment": "test that a notification does not get delayed in the queue waiting for the next event to push it through.",
	"Method": "void testNotificationDelay(){\r\n}"
}, {
	"Path": "io.reactivex.observers.SerializedObserverTest.testNotificationDelay",
	"Comment": "test that a notification does not get delayed in the queue waiting for the next event to push it through.",
	"Method": "void testNotificationDelay(){\r\n    firstOnNext.countDown();\r\n    try {\r\n        latch.await();\r\n    } catch (InterruptedException e) {\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.disposables.Disposables.fromFuture",
	"Comment": "construct a disposable by wrapping a future that iscancelled exactly once when the disposable is disposed.",
	"Method": "Disposable fromFuture(Future<?> future,Disposable fromFuture,Future<?> future,boolean allowInterrupt){\r\n    ObjectHelper.requireNonNull(future, \"future is null\");\r\n    return new FutureDisposable(future, allowInterrupt);\r\n}"
}, {
	"Path": "org.openqa.selenium.remote.http.AbstractHttpResponseCodec.encode",
	"Comment": "encodes the given response as a http response message. this method is guaranteed not to throw.",
	"Method": "HttpResponse encode(Supplier<HttpResponse> factory,Response response){\r\n    int status = response.getStatus() == ErrorCodes.SUCCESS ? HTTP_OK : HTTP_INTERNAL_ERROR;\r\n    byte[] data = json.toJson(getValueToEncode(response)).getBytes(UTF_8);\r\n    HttpResponse httpResponse = factory.get();\r\n    httpResponse.setStatus(status);\r\n    httpResponse.setHeader(CACHE_CONTROL, \"no-cache\");\r\n    httpResponse.setHeader(EXPIRES, \"Thu, 01 Jan 1970 00:00:00 GMT\");\r\n    httpResponse.setHeader(CONTENT_LENGTH, String.valueOf(data.length));\r\n    httpResponse.setHeader(CONTENT_TYPE, JSON_UTF_8.toString());\r\n    httpResponse.setContent(data);\r\n    return httpResponse;\r\n}"
}, {
	"Path": "org.robolectric.res.android.Chunk.type",
	"Comment": "returns the type of the chunk. caller need not worry about endianness.",
	"Method": "int type(){\r\n    return dtohs(device_chunk_.type);\r\n}"
}, {
	"Path": "io.reactivex.single.SingleTest.testUnsubscribe2",
	"Comment": "assert that unsubscribe propagates when passing in a singleobserver and not a subscriber.",
	"Method": "void testUnsubscribe2(){\r\n    final SerialDisposable sd = new SerialDisposable();\r\n    SingleObserver<String> ts = new SingleObserver<String>() {\r\n        @Override\r\n        public void onSubscribe(Disposable d) {\r\n            sd.replace(d);\r\n        }\r\n        @Override\r\n        public void onSuccess(String value) {\r\n        }\r\n        @Override\r\n        public void onError(Throwable error) {\r\n        }\r\n    };\r\n    final AtomicBoolean unsubscribed = new AtomicBoolean();\r\n    final AtomicBoolean interrupted = new AtomicBoolean();\r\n    final CountDownLatch latch = new CountDownLatch(2);\r\n    Single<String> s1 = Single.unsafeCreate(new SingleSource<String>() {\r\n        @Override\r\n        public void subscribe(final SingleObserver<? super String> observer) {\r\n            SerialDisposable sd = new SerialDisposable();\r\n            observer.onSubscribe(sd);\r\n            final Thread t = new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    try {\r\n                        Thread.sleep(5000);\r\n                        observer.onSuccess(\"success\");\r\n                    } catch (InterruptedException e) {\r\n                        interrupted.set(true);\r\n                        latch.countDown();\r\n                    }\r\n                }\r\n            });\r\n            sd.replace(Disposables.fromRunnable(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    unsubscribed.set(true);\r\n                    t.interrupt();\r\n                    latch.countDown();\r\n                }\r\n            }));\r\n            t.start();\r\n        }\r\n    });\r\n    s1.subscribe(ts);\r\n    Thread.sleep(100);\r\n    sd.dispose();\r\n    if (latch.await(1000, TimeUnit.MILLISECONDS)) {\r\n        assertTrue(unsubscribed.get());\r\n        assertTrue(interrupted.get());\r\n    } else {\r\n        fail(\"timed out waiting for latch\");\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.single.SingleTest.testUnsubscribe2",
	"Comment": "assert that unsubscribe propagates when passing in a singleobserver and not a subscriber.",
	"Method": "void testUnsubscribe2(){\r\n    sd.replace(d);\r\n}"
}, {
	"Path": "io.reactivex.single.SingleTest.testUnsubscribe2",
	"Comment": "assert that unsubscribe propagates when passing in a singleobserver and not a subscriber.",
	"Method": "void testUnsubscribe2(){\r\n}"
}, {
	"Path": "io.reactivex.single.SingleTest.testUnsubscribe2",
	"Comment": "assert that unsubscribe propagates when passing in a singleobserver and not a subscriber.",
	"Method": "void testUnsubscribe2(){\r\n}"
}, {
	"Path": "io.reactivex.single.SingleTest.testUnsubscribe2",
	"Comment": "assert that unsubscribe propagates when passing in a singleobserver and not a subscriber.",
	"Method": "void testUnsubscribe2(){\r\n    SerialDisposable sd = new SerialDisposable();\r\n    observer.onSubscribe(sd);\r\n    final Thread t = new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                Thread.sleep(5000);\r\n                observer.onSuccess(\"success\");\r\n            } catch (InterruptedException e) {\r\n                interrupted.set(true);\r\n                latch.countDown();\r\n            }\r\n        }\r\n    });\r\n    sd.replace(Disposables.fromRunnable(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            unsubscribed.set(true);\r\n            t.interrupt();\r\n            latch.countDown();\r\n        }\r\n    }));\r\n    t.start();\r\n}"
}, {
	"Path": "io.reactivex.single.SingleTest.testUnsubscribe2",
	"Comment": "assert that unsubscribe propagates when passing in a singleobserver and not a subscriber.",
	"Method": "void testUnsubscribe2(){\r\n    try {\r\n        Thread.sleep(5000);\r\n        observer.onSuccess(\"success\");\r\n    } catch (InterruptedException e) {\r\n        interrupted.set(true);\r\n        latch.countDown();\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.single.SingleTest.testUnsubscribe2",
	"Comment": "assert that unsubscribe propagates when passing in a singleobserver and not a subscriber.",
	"Method": "void testUnsubscribe2(){\r\n    unsubscribed.set(true);\r\n    t.interrupt();\r\n    latch.countDown();\r\n}"
}, {
	"Path": "org.openqa.selenium.remote.RemoteWebDriverBuilder.oneOf",
	"Comment": "clears the current set of alternative browsers and instead sets the list of possible choices tothe arguments given to this method.",
	"Method": "RemoteWebDriverBuilder oneOf(Capabilities maybeThis,Capabilities orOneOfThese){\r\n    options.clear();\r\n    addAlternative(maybeThis);\r\n    for (Capabilities anOrOneOfThese : orOneOfThese) {\r\n        addAlternative(anOrOneOfThese);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.setOnImageEventListener",
	"Comment": "add a listener allowing notification of load and error events.",
	"Method": "void setOnImageEventListener(OnImageEventListener onImageEventListener){\r\n    this.onImageEventListener = onImageEventListener;\r\n}"
}, {
	"Path": "org.robolectric.manifest.BroadcastReceiverData.getAllAttributes",
	"Comment": "get the map for all attributes defined for the broadcast receiver.",
	"Method": "Map<String, String> getAllAttributes(){\r\n    return attributes;\r\n}"
}, {
	"Path": "io.reactivex.internal.functions.Functions.identity",
	"Comment": "returns an identity function that simply returns its argument.",
	"Method": "Function<T, T> identity(){\r\n    return (Function<T, T>) IDENTITY;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableMergeTest.testError1",
	"Comment": "unit test from operationmergedelayerror backported here to show how these use cases work with normal merge.",
	"Method": "void testError1(){\r\n    final Observable<String> o1 = Observable.unsafeCreate(new TestErrorObservable(\"four\", null, \"six\"));\r\n    final Observable<String> o2 = Observable.unsafeCreate(new TestErrorObservable(\"one\", \"two\", \"three\"));\r\n    Observable<String> m = Observable.merge(o1, o2);\r\n    m.subscribe(stringObserver);\r\n    verify(stringObserver, times(1)).onError(any(NullPointerException.class));\r\n    verify(stringObserver, never()).onComplete();\r\n    verify(stringObserver, times(0)).onNext(\"one\");\r\n    verify(stringObserver, times(0)).onNext(\"two\");\r\n    verify(stringObserver, times(0)).onNext(\"three\");\r\n    verify(stringObserver, times(1)).onNext(\"four\");\r\n    verify(stringObserver, times(0)).onNext(\"five\");\r\n    verify(stringObserver, times(0)).onNext(\"six\");\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableMergeTest.testError2",
	"Comment": "unit test from operationmergedelayerror backported here to show how these use cases work with normal merge.",
	"Method": "void testError2(){\r\n    final Observable<String> o1 = Observable.unsafeCreate(new TestErrorObservable(\"one\", \"two\", \"three\"));\r\n    final Observable<String> o2 = Observable.unsafeCreate(new TestErrorObservable(\"four\", null, \"six\"));\r\n    final Observable<String> o3 = Observable.unsafeCreate(new TestErrorObservable(\"seven\", \"eight\", null));\r\n    final Observable<String> o4 = Observable.unsafeCreate(new TestErrorObservable(\"nine\"));\r\n    Observable<String> m = Observable.merge(o1, o2, o3, o4);\r\n    m.subscribe(stringObserver);\r\n    verify(stringObserver, times(1)).onError(any(NullPointerException.class));\r\n    verify(stringObserver, never()).onComplete();\r\n    verify(stringObserver, times(1)).onNext(\"one\");\r\n    verify(stringObserver, times(1)).onNext(\"two\");\r\n    verify(stringObserver, times(1)).onNext(\"three\");\r\n    verify(stringObserver, times(1)).onNext(\"four\");\r\n    verify(stringObserver, times(0)).onNext(\"five\");\r\n    verify(stringObserver, times(0)).onNext(\"six\");\r\n    verify(stringObserver, times(0)).onNext(\"seven\");\r\n    verify(stringObserver, times(0)).onNext(\"eight\");\r\n    verify(stringObserver, times(0)).onNext(\"nine\");\r\n}"
}, {
	"Path": "org.openqa.selenium.firefox.FirefoxBinary.locateFirefoxBinaryFromSystemProperty",
	"Comment": "locates the firefox binary from a system property. will throw an exception if the binary cannotbe found.",
	"Method": "Executable locateFirefoxBinaryFromSystemProperty(){\r\n    String binaryName = System.getProperty(FirefoxDriver.SystemProperty.BROWSER_BINARY);\r\n    if (binaryName == null)\r\n        return null;\r\n    File binary = new File(binaryName);\r\n    if (binary.exists() && !binary.isDirectory())\r\n        return new Executable(binary);\r\n    Platform current = Platform.getCurrent();\r\n    if (current.is(WINDOWS)) {\r\n        if (!binaryName.endsWith(\".exe\")) {\r\n            binaryName += \".exe\";\r\n        }\r\n    } else if (current.is(MAC)) {\r\n        if (!binaryName.endsWith(\".app\")) {\r\n            binaryName += \".app\";\r\n        }\r\n        binaryName += \"/Contents/MacOS/firefox-bin\";\r\n    }\r\n    binary = new File(binaryName);\r\n    if (binary.exists())\r\n        return new Executable(binary);\r\n    throw new WebDriverException(String.format(\"'%s' property set, but unable to locate the requested binary: %s\", FirefoxDriver.SystemProperty.BROWSER_BINARY, binaryName));\r\n}"
}, {
	"Path": "com.github.scribejava.core.oauth.OAuth20Service.getAuthorizationUrl",
	"Comment": "returns the url where you should redirect your users to authenticate your application.",
	"Method": "String getAuthorizationUrl(String getAuthorizationUrl,Map<String, String> additionalParams,String getAuthorizationUrl,PKCE pkce,String getAuthorizationUrl,Map<String, String> additionalParams,PKCE pkce){\r\n    final Map<String, String> params;\r\n    if (pkce == null) {\r\n        params = additionalParams;\r\n    } else {\r\n        params = additionalParams == null ? new HashMap<String, String>() : new HashMap(additionalParams);\r\n        params.putAll(pkce.getAuthorizationUrlParams());\r\n    }\r\n    return api.getAuthorizationUrl(getResponseType(), getApiKey(), getCallback(), getScope(), getState(), params);\r\n}"
}, {
	"Path": "org.openqa.selenium.remote.http.HttpRequest.addQueryParameter",
	"Comment": "set a query parameter, adding to existing values if present. the implementation will ensurethat the name and value are properly encoded.",
	"Method": "void addQueryParameter(String name,String value){\r\n    queryParameters.put(Objects.requireNonNull(name, \"Name must be set\"), Objects.requireNonNull(value, \"Value must be set\"));\r\n}"
}, {
	"Path": "io.reactivex.schedulers.NewThreadSchedulerTest.npeRegression",
	"Comment": "regression test to ensure there is no npe when the worker has been disposed.",
	"Method": "void npeRegression(){\r\n    Scheduler s = getScheduler();\r\n    NewThreadWorker w = (NewThreadWorker) s.createWorker();\r\n    w.dispose();\r\n    w.scheduleActual(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n        }\r\n    }, 0, TimeUnit.MILLISECONDS, null);\r\n}"
}, {
	"Path": "io.reactivex.schedulers.NewThreadSchedulerTest.npeRegression",
	"Comment": "regression test to ensure there is no npe when the worker has been disposed.",
	"Method": "void npeRegression(){\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated",
	"Comment": "an expectation for checking that an element is present on the dom of a page. this does notnecessarily mean that the element is visible.",
	"Method": "ExpectedCondition<WebElement> presenceOfElementLocated(By locator){\r\n    return new ExpectedCondition<WebElement>() {\r\n        @Override\r\n        public WebElement apply(WebDriver driver) {\r\n            return driver.findElement(locator);\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"presence of element located by: \" + locator;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated",
	"Comment": "an expectation for checking that an element is present on the dom of a page. this does notnecessarily mean that the element is visible.",
	"Method": "ExpectedCondition<WebElement> presenceOfElementLocated(By locator){\r\n    return driver.findElement(locator);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated",
	"Comment": "an expectation for checking that an element is present on the dom of a page. this does notnecessarily mean that the element is visible.",
	"Method": "ExpectedCondition<WebElement> presenceOfElementLocated(By locator){\r\n    return \"presence of element located by: \" + locator;\r\n}"
}, {
	"Path": "org.openqa.selenium.UnhandledAlertException.getAlert",
	"Comment": "used for serialising. some of the drivers return the alert text like this.",
	"Method": "Map<String, String> getAlert(){\r\n    HashMap<String, String> toReturn = new HashMap();\r\n    toReturn.put(\"text\", getAlertText());\r\n    return Collections.unmodifiableMap(toReturn);\r\n}"
}, {
	"Path": "org.robolectric.manifest.ServiceData.isExported",
	"Comment": "returns whether this service is exported by checking the xml attribute.",
	"Method": "boolean isExported(){\r\n    boolean defaultValue = !intentFilters.isEmpty();\r\n    return (attributes.containsKey(EXPORTED) ? Boolean.parseBoolean(attributes.get(EXPORTED)) : defaultValue);\r\n}"
}, {
	"Path": "org.robolectric.internal.bytecode.ClassInstrumentor.makeMethodPublic",
	"Comment": "replaces protected and private method modifiers with public.",
	"Method": "void makeMethodPublic(MethodNode method){\r\n    method.access = (method.access | Opcodes.ACC_PUBLIC) & ~(Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE);\r\n}"
}, {
	"Path": "io.reactivex.observable.ObservableErrorHandlingTests.testOnNextErrorAcrossThread",
	"Comment": "test that an error from a user provided observer.onnext is handled and emitted to the onerroreven when done across thread boundaries with observeon.",
	"Method": "void testOnNextErrorAcrossThread(){\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    final AtomicReference<Throwable> caughtError = new AtomicReference<Throwable>();\r\n    Observable<Long> o = Observable.interval(50, TimeUnit.MILLISECONDS);\r\n    Observer<Long> observer = new DefaultObserver<Long>() {\r\n        @Override\r\n        public void onComplete() {\r\n            System.out.println(\"completed\");\r\n            latch.countDown();\r\n        }\r\n        @Override\r\n        public void onError(Throwable e) {\r\n            System.out.println(\"error: \" + e);\r\n            caughtError.set(e);\r\n            latch.countDown();\r\n        }\r\n        @Override\r\n        public void onNext(Long args) {\r\n            throw new RuntimeException(\"forced failure\");\r\n        }\r\n    };\r\n    o.observeOn(Schedulers.newThread()).safeSubscribe(observer);\r\n    latch.await(2000, TimeUnit.MILLISECONDS);\r\n    assertNotNull(caughtError.get());\r\n}"
}, {
	"Path": "io.reactivex.observable.ObservableErrorHandlingTests.testOnNextErrorAcrossThread",
	"Comment": "test that an error from a user provided observer.onnext is handled and emitted to the onerroreven when done across thread boundaries with observeon.",
	"Method": "void testOnNextErrorAcrossThread(){\r\n    System.out.println(\"completed\");\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.reactivex.observable.ObservableErrorHandlingTests.testOnNextErrorAcrossThread",
	"Comment": "test that an error from a user provided observer.onnext is handled and emitted to the onerroreven when done across thread boundaries with observeon.",
	"Method": "void testOnNextErrorAcrossThread(){\r\n    System.out.println(\"error: \" + e);\r\n    caughtError.set(e);\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.reactivex.observable.ObservableErrorHandlingTests.testOnNextErrorAcrossThread",
	"Comment": "test that an error from a user provided observer.onnext is handled and emitted to the onerroreven when done across thread boundaries with observeon.",
	"Method": "void testOnNextErrorAcrossThread(){\r\n    throw new RuntimeException(\"forced failure\");\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.refreshRequiredTiles",
	"Comment": "loads the optimum tiles for display at the current scale and translate, so the screen can be filled with tilesthat are at least as high resolution as the screen. frees up bitmaps that are now off the screen.",
	"Method": "void refreshRequiredTiles(boolean load){\r\n    if (decoder == null || tileMap == null) {\r\n        return;\r\n    }\r\n    int sampleSize = Math.min(fullImageSampleSize, calculateInSampleSize(scale));\r\n    for (Map.Entry<Integer, List<Tile>> tileMapEntry : tileMap.entrySet()) {\r\n        for (Tile tile : tileMapEntry.getValue()) {\r\n            if (tile.sampleSize < sampleSize || (tile.sampleSize > sampleSize && tile.sampleSize != fullImageSampleSize)) {\r\n                tile.visible = false;\r\n                if (tile.bitmap != null) {\r\n                    tile.bitmap.recycle();\r\n                    tile.bitmap = null;\r\n                }\r\n            }\r\n            if (tile.sampleSize == sampleSize) {\r\n                if (tileVisible(tile)) {\r\n                    tile.visible = true;\r\n                    if (!tile.loading && tile.bitmap == null && load) {\r\n                        TileLoadTask task = new TileLoadTask(this, decoder, tile);\r\n                        execute(task);\r\n                    }\r\n                } else if (tile.sampleSize != fullImageSampleSize) {\r\n                    tile.visible = false;\r\n                    if (tile.bitmap != null) {\r\n                        tile.bitmap.recycle();\r\n                        tile.bitmap = null;\r\n                    }\r\n                }\r\n            } else if (tile.sampleSize == fullImageSampleSize) {\r\n                tile.visible = true;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vondear.rxtool.module.photomagic.RxMagic.getImageCacheDir",
	"Comment": "returns a directory with the given name in the private cache directory of the application touse to store retrieved media and thumbnails.",
	"Method": "File getImageCacheDir(Context context,File getImageCacheDir,Context context,String cacheName){\r\n    File cacheDir = context.getExternalCacheDir();\r\n    if (cacheDir != null) {\r\n        File result = new File(cacheDir, cacheName);\r\n        if (!result.mkdirs() && (!result.exists() || !result.isDirectory())) {\r\n            return null;\r\n        }\r\n        return result;\r\n    }\r\n    if (Log.isLoggable(TAG, Log.ERROR)) {\r\n        Log.e(TAG, \"default disk cache dir is null\");\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.presenceOfAllElementsLocatedBy",
	"Comment": "an expectation for checking that there is at least one element present on a web page.",
	"Method": "ExpectedCondition<List<WebElement>> presenceOfAllElementsLocatedBy(By locator){\r\n    return new ExpectedCondition<List<WebElement>>() {\r\n        @Override\r\n        public List<WebElement> apply(WebDriver driver) {\r\n            List<WebElement> elements = driver.findElements(locator);\r\n            return elements.size() > 0 ? elements : null;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"presence of any elements located by \" + locator;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.presenceOfAllElementsLocatedBy",
	"Comment": "an expectation for checking that there is at least one element present on a web page.",
	"Method": "ExpectedCondition<List<WebElement>> presenceOfAllElementsLocatedBy(By locator){\r\n    List<WebElement> elements = driver.findElements(locator);\r\n    return elements.size() > 0 ? elements : null;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.presenceOfAllElementsLocatedBy",
	"Comment": "an expectation for checking that there is at least one element present on a web page.",
	"Method": "ExpectedCondition<List<WebElement>> presenceOfAllElementsLocatedBy(By locator){\r\n    return \"presence of any elements located by \" + locator;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testUnsubscribeOnNestedTakeAndSyncInfiniteStream",
	"Comment": "we will only take 1 group with 20 events from it and then unsubscribe.",
	"Method": "void testUnsubscribeOnNestedTakeAndSyncInfiniteStream(){\r\n    final AtomicInteger subscribeCounter = new AtomicInteger();\r\n    final AtomicInteger sentEventCounter = new AtomicInteger();\r\n    doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream(SYNC_INFINITE_OBSERVABLE_OF_EVENT(2, subscribeCounter, sentEventCounter), subscribeCounter);\r\n    Thread.sleep(500);\r\n    assertEquals(39, sentEventCounter.get());\r\n}"
}, {
	"Path": "com.vondear.rxfeature.module.alipay.Base64.removeWhiteSpace",
	"Comment": "remove whitespace from mime containing encoded base64 data.",
	"Method": "int removeWhiteSpace(char[] data){\r\n    if (data == null) {\r\n        return 0;\r\n    }\r\n    int newSize = 0;\r\n    int len = data.length;\r\n    for (int i = 0; i < len; i++) {\r\n        if (!isWhiteSpace(data[i])) {\r\n            data[newSize++] = data[i];\r\n        }\r\n    }\r\n    return newSize;\r\n}"
}, {
	"Path": "com.vondear.rxfeature.module.scaner.CameraManager.buildLuminanceSource",
	"Comment": "a factory method to build the appropriate luminancesource object based on the formatof the preview buffers, as described by camera.parameters.",
	"Method": "PlanarYUVLuminanceSource buildLuminanceSource(byte[] data,int width,int height){\r\n    Rect rect = getFramingRectInPreview();\r\n    int previewFormat = configManager.getPreviewFormat();\r\n    String previewFormatString = configManager.getPreviewFormatString();\r\n    switch(previewFormat) {\r\n        case PixelFormat.YCbCr_420_SP:\r\n        case PixelFormat.YCbCr_422_SP:\r\n            return new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top, rect.width(), rect.height());\r\n        default:\r\n            if (\"yuv420p\".equals(previewFormatString)) {\r\n                return new PlanarYUVLuminanceSource(data, width, height, rect.left, rect.top, rect.width(), rect.height());\r\n            }\r\n    }\r\n    throw new IllegalArgumentException(\"Unsupported picture format: \" + previewFormat + '/' + previewFormatString);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.elementSelectionStateToBe",
	"Comment": "an expectation for checking if the given element is selected.",
	"Method": "ExpectedCondition<Boolean> elementSelectionStateToBe(WebElement element,boolean selected,ExpectedCondition<Boolean> elementSelectionStateToBe,By locator,boolean selected){\r\n    return new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            try {\r\n                WebElement element = driver.findElement(locator);\r\n                return element.isSelected() == selected;\r\n            } catch (StaleElementReferenceException e) {\r\n                return null;\r\n            }\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"element found by %s to %sbe selected\", locator, (selected ? \"\" : \"not \"));\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.elementSelectionStateToBe",
	"Comment": "an expectation for checking if the given element is selected.",
	"Method": "ExpectedCondition<Boolean> elementSelectionStateToBe(WebElement element,boolean selected,ExpectedCondition<Boolean> elementSelectionStateToBe,By locator,boolean selected){\r\n    try {\r\n        WebElement element = driver.findElement(locator);\r\n        return element.isSelected() == selected;\r\n    } catch (StaleElementReferenceException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.elementSelectionStateToBe",
	"Comment": "an expectation for checking if the given element is selected.",
	"Method": "ExpectedCondition<Boolean> elementSelectionStateToBe(WebElement element,boolean selected,ExpectedCondition<Boolean> elementSelectionStateToBe,By locator,boolean selected){\r\n    return String.format(\"element found by %s to %sbe selected\", locator, (selected ? \"\" : \"not \"));\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.numberOfElementsToBeMoreThan",
	"Comment": "an expectation for checking number of webelements with given locator being more than defined number",
	"Method": "ExpectedCondition<List<WebElement>> numberOfElementsToBeMoreThan(By locator,Integer number){\r\n    return new ExpectedCondition<List<WebElement>>() {\r\n        private Integer currentNumber = 0;\r\n        @Override\r\n        public List<WebElement> apply(WebDriver webDriver) {\r\n            List<WebElement> elements = webDriver.findElements(locator);\r\n            currentNumber = elements.size();\r\n            return currentNumber > number ? elements : null;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"number of elements found by %s to be more than \\\"%s\\\". Current number: \\\"%s\\\"\", locator, number, currentNumber);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.numberOfElementsToBeMoreThan",
	"Comment": "an expectation for checking number of webelements with given locator being more than defined number",
	"Method": "ExpectedCondition<List<WebElement>> numberOfElementsToBeMoreThan(By locator,Integer number){\r\n    List<WebElement> elements = webDriver.findElements(locator);\r\n    currentNumber = elements.size();\r\n    return currentNumber > number ? elements : null;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.numberOfElementsToBeMoreThan",
	"Comment": "an expectation for checking number of webelements with given locator being more than defined number",
	"Method": "ExpectedCondition<List<WebElement>> numberOfElementsToBeMoreThan(By locator,Integer number){\r\n    return String.format(\"number of elements found by %s to be more than \\\"%s\\\". Current number: \\\"%s\\\"\", locator, number, currentNumber);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.attributeToBeNotEmpty",
	"Comment": "an expectation for checking webelement any non empty value for given attribute",
	"Method": "ExpectedCondition<Boolean> attributeToBeNotEmpty(WebElement element,String attribute){\r\n    return driver -> getAttributeOrCssValue(element, attribute).isPresent();\r\n}"
}, {
	"Path": "org.robolectric.integration_tests.axt.EspressoTest.typeText_espresso",
	"Comment": "perform the equivalent of settext except using espresso apis",
	"Method": "void typeText_espresso(){\r\n    onView(withId(R.id.text)).perform(ViewActions.typeText(\"\\\"new TEXT!#$%&'*+-/=?^_`{|}~@robolectric.org\"));\r\n    onView(withId(R.id.text)).check(matches(withText(\"\\\"new TEXT!#$%&'*+-/=?^_`{|}~@robolectric.org\")));\r\n}"
}, {
	"Path": "org.robolectric.res.android.LoadedArsc.GetPackages",
	"Comment": "returns a vector of loadedpackage pointers, representing the packages in this loadedarsc.",
	"Method": "List<LoadedPackage> GetPackages(){\r\n    return packages_;\r\n}"
}, {
	"Path": "io.reactivex.subjects.SingleSubject.getValue",
	"Comment": "returns the success value if this singlesubject was terminated with a success value.",
	"Method": "T getValue(){\r\n    if (observers.get() == TERMINATED) {\r\n        return value;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.robolectric.internal.bytecode.ClassInstrumentor.rewriteMethodBody",
	"Comment": "filters methods that might need special treatment because of various reasons",
	"Method": "void rewriteMethodBody(MutableClass mutableClass,MethodNode callingMethod){\r\n    ListIterator<AbstractInsnNode> instructions = callingMethod.instructions.iterator();\r\n    while (instructions.hasNext()) {\r\n        AbstractInsnNode node = instructions.next();\r\n        switch(node.getOpcode()) {\r\n            case Opcodes.NEW:\r\n                TypeInsnNode newInsnNode = (TypeInsnNode) node;\r\n                newInsnNode.desc = mutableClass.config.mappedTypeName(newInsnNode.desc);\r\n                break;\r\n            case Opcodes.GETFIELD:\r\n            case Opcodes.PUTFIELD:\r\n            case Opcodes.GETSTATIC:\r\n            case Opcodes.PUTSTATIC:\r\n                FieldInsnNode fieldInsnNode = (FieldInsnNode) node;\r\n                fieldInsnNode.desc = mutableClass.config.mappedTypeName(fieldInsnNode.desc);\r\n                break;\r\n            case Opcodes.INVOKESTATIC:\r\n            case Opcodes.INVOKEINTERFACE:\r\n            case Opcodes.INVOKESPECIAL:\r\n            case Opcodes.INVOKEVIRTUAL:\r\n                MethodInsnNode targetMethod = (MethodInsnNode) node;\r\n                targetMethod.desc = mutableClass.config.remapParams(targetMethod.desc);\r\n                if (isGregorianCalendarBooleanConstructor(targetMethod)) {\r\n                    replaceGregorianCalendarBooleanConstructor(instructions, targetMethod);\r\n                } else if (mutableClass.config.shouldIntercept(targetMethod)) {\r\n                    interceptInvokeVirtualMethod(mutableClass, instructions, targetMethod);\r\n                }\r\n                break;\r\n            case Opcodes.INVOKEDYNAMIC:\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableFromIterableTest.testRawIterable",
	"Comment": "this tests the path that can not optimize based on size so must use setproducer.",
	"Method": "void testRawIterable(){\r\n    Iterable<String> it = new Iterable<String>() {\r\n        @Override\r\n        public Iterator<String> iterator() {\r\n            return new Iterator<String>() {\r\n                int i;\r\n                @Override\r\n                public boolean hasNext() {\r\n                    return i < 3;\r\n                }\r\n                @Override\r\n                public String next() {\r\n                    return String.valueOf(++i);\r\n                }\r\n                @Override\r\n                public void remove() {\r\n                }\r\n            };\r\n        }\r\n    };\r\n    Observable<String> o = Observable.fromIterable(it);\r\n    Observer<String> observer = TestHelper.mockObserver();\r\n    o.subscribe(observer);\r\n    verify(observer, times(1)).onNext(\"1\");\r\n    verify(observer, times(1)).onNext(\"2\");\r\n    verify(observer, times(1)).onNext(\"3\");\r\n    verify(observer, Mockito.never()).onError(any(Throwable.class));\r\n    verify(observer, times(1)).onComplete();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableFromIterableTest.testRawIterable",
	"Comment": "this tests the path that can not optimize based on size so must use setproducer.",
	"Method": "void testRawIterable(){\r\n    return new Iterator<String>() {\r\n        int i;\r\n        @Override\r\n        public boolean hasNext() {\r\n            return i < 3;\r\n        }\r\n        @Override\r\n        public String next() {\r\n            return String.valueOf(++i);\r\n        }\r\n        @Override\r\n        public void remove() {\r\n        }\r\n    };\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableFromIterableTest.testRawIterable",
	"Comment": "this tests the path that can not optimize based on size so must use setproducer.",
	"Method": "void testRawIterable(){\r\n    return i < 3;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableFromIterableTest.testRawIterable",
	"Comment": "this tests the path that can not optimize based on size so must use setproducer.",
	"Method": "void testRawIterable(){\r\n    return String.valueOf(++i);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableFromIterableTest.testRawIterable",
	"Comment": "this tests the path that can not optimize based on size so must use setproducer.",
	"Method": "void testRawIterable(){\r\n}"
}, {
	"Path": "org.openqa.selenium.net.NetworkUtils.obtainLoopbackIp4Address",
	"Comment": "returns a single address that is guaranteed to resolve to an ipv4 representation of localhostthis may either be a hostname or an ip address, dependending if we can guarantee what that thehostname will resolve to ip4.",
	"Method": "String obtainLoopbackIp4Address(){\r\n    final NetworkInterface networkInterface = getLoopBackAndIp4Only();\r\n    if (networkInterface != null) {\r\n        return networkInterface.getIp4LoopbackOnly().getHostName();\r\n    }\r\n    final String ipOfIp4LoopBack = getIpOfLoopBackIp4();\r\n    if (ipOfIp4LoopBack != null) {\r\n        return ipOfIp4LoopBack;\r\n    }\r\n    if (Platform.getCurrent().is(Platform.UNIX)) {\r\n        NetworkInterface linuxLoopback = networkInterfaceProvider.getLoInterface();\r\n        if (linuxLoopback != null) {\r\n            final InetAddress netAddress = linuxLoopback.getIp4LoopbackOnly();\r\n            if (netAddress != null) {\r\n                return netAddress.getHostAddress();\r\n            }\r\n        }\r\n    }\r\n    throw new WebDriverException(\"Unable to resolve local loopback address, please file an issue with the full message of this error:\\n\" + getNetWorkDiags() + \"\\n==== End of error message\");\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowServiceTest.stopForegroundDoesntRemoveNotificationUnlessAsked",
	"Comment": "according to spec, if the foreground notification is not removed earlier,then it will be removed when the service is destroyed.",
	"Method": "void stopForegroundDoesntRemoveNotificationUnlessAsked(){\r\n    Notification n = notBuilder.build();\r\n    service.startForeground(21, n);\r\n    service.stopForeground(false);\r\n    assertThat(shadowOf(nm2).getNotification(21)).isSameAs(n);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowAppTask.moveToFront",
	"Comment": "for tests, marks the task as moved to the front. task is created and marked as not moved to thefront.",
	"Method": "void moveToFront(){\r\n    this.hasMovedToFront = true;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.pagefactory.AjaxElementLocator.sleepFor",
	"Comment": "by default, we sleep for 250ms between polls. you may override this method in order to changehow it sleeps.",
	"Method": "long sleepFor(long sleepFor,long sleepFor){\r\n    return 250;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ResourceHelper2.parseFloatAttribute",
	"Comment": "parse a float attribute and return the parsed value into a given typedvalue.",
	"Method": "boolean parseFloatAttribute(String attribute,String value,TypedValue outValue,boolean requireUnit){\r\n    value = value.trim();\r\n    int len = value.length();\r\n    if (len <= 0) {\r\n        return false;\r\n    }\r\n    char[] buf = value.toCharArray();\r\n    for (int i = 0; i < len; i++) {\r\n        if (buf[i] > 255) {\r\n            return false;\r\n        }\r\n    }\r\n    if (buf[0] < '0' && buf[0] > '9' && buf[0] != '.' && buf[0] != '-') {\r\n        return false;\r\n    }\r\n    Matcher m = sFloatPattern.matcher(value);\r\n    if (m.matches()) {\r\n        String f_str = m.group(1);\r\n        String end = m.group(2);\r\n        float f;\r\n        try {\r\n            f = Float.parseFloat(f_str);\r\n        } catch (NumberFormatException e) {\r\n            return false;\r\n        }\r\n        if (end.length() > 0 && end.charAt(0) != ' ') {\r\n            if (parseUnit(end, outValue, sFloatOut)) {\r\n                computeTypedValue(outValue, f, sFloatOut[0], end);\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        end = end.trim();\r\n        if (end.length() == 0) {\r\n            if (outValue != null) {\r\n                outValue.assetCookie = 0;\r\n                outValue.string = null;\r\n                if (requireUnit == false) {\r\n                    outValue.type = TypedValue.TYPE_FLOAT;\r\n                    outValue.data = Float.floatToIntBits(f);\r\n                } else {\r\n                    applyUnit(sUnitNames[1], outValue, sFloatOut);\r\n                    computeTypedValue(outValue, f, sFloatOut[0], \"dp\");\r\n                    System.out.println(String.format(\"Dimension \\\"%1$s\\\" in attribute \\\"%2$s\\\" is missing unit!\", value, attribute == null ? \"(unknown)\" : attribute));\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.reactivex.observers.BaseTestConsumer.assertErrorMessage",
	"Comment": "assert that there is a single error and it has the given message.",
	"Method": "U assertErrorMessage(String message){\r\n    int s = errors.size();\r\n    if (s == 0) {\r\n        throw fail(\"No errors\");\r\n    } else if (s == 1) {\r\n        Throwable e = errors.get(0);\r\n        String errorMessage = e.getMessage();\r\n        if (!ObjectHelper.equals(message, errorMessage)) {\r\n            throw fail(\"Error message differs; exptected: \" + message + \" but was: \" + errorMessage);\r\n        }\r\n    } else {\r\n        throw fail(\"Multiple errors\");\r\n    }\r\n    return (U) this;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.ImageSource.tiling",
	"Comment": "enable or disable tiling of the image. this does not apply to preview images which are always loaded as a single bitmap,and tiling cannot be disabled when displaying a region of the source image.",
	"Method": "ImageSource tiling(boolean tile){\r\n    this.tile = tile;\r\n    return this;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ResourceHelper.getColorType",
	"Comment": "returns the typedvalue color type represented by the given string value",
	"Method": "int getColorType(String value){\r\n    if (value != null && value.startsWith(\"#\")) {\r\n        switch(value.length()) {\r\n            case 4:\r\n                return TypedValue.TYPE_INT_COLOR_RGB4;\r\n            case 5:\r\n                return TypedValue.TYPE_INT_COLOR_ARGB4;\r\n            case 7:\r\n                return TypedValue.TYPE_INT_COLOR_RGB8;\r\n            case 9:\r\n                return TypedValue.TYPE_INT_COLOR_ARGB8;\r\n        }\r\n    }\r\n    return TypedValue.TYPE_INT_COLOR_ARGB8;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textToBePresentInElementValue",
	"Comment": "an expectation for checking if the given text is present in the specified elements valueattribute.",
	"Method": "ExpectedCondition<Boolean> textToBePresentInElementValue(WebElement element,String text,ExpectedCondition<Boolean> textToBePresentInElementValue,By locator,String text){\r\n    return new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            try {\r\n                String elementText = driver.findElement(locator).getAttribute(\"value\");\r\n                if (elementText != null) {\r\n                    return elementText.contains(text);\r\n                }\r\n                return false;\r\n            } catch (StaleElementReferenceException e) {\r\n                return null;\r\n            }\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"text ('%s') to be the value of element located by %s\", text, locator);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textToBePresentInElementValue",
	"Comment": "an expectation for checking if the given text is present in the specified elements valueattribute.",
	"Method": "ExpectedCondition<Boolean> textToBePresentInElementValue(WebElement element,String text,ExpectedCondition<Boolean> textToBePresentInElementValue,By locator,String text){\r\n    try {\r\n        String elementText = driver.findElement(locator).getAttribute(\"value\");\r\n        if (elementText != null) {\r\n            return elementText.contains(text);\r\n        }\r\n        return false;\r\n    } catch (StaleElementReferenceException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textToBePresentInElementValue",
	"Comment": "an expectation for checking if the given text is present in the specified elements valueattribute.",
	"Method": "ExpectedCondition<Boolean> textToBePresentInElementValue(WebElement element,String text,ExpectedCondition<Boolean> textToBePresentInElementValue,By locator,String text){\r\n    return String.format(\"text ('%s') to be the value of element located by %s\", text, locator);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowAccessibilityNodeInfo.equals",
	"Comment": "equality check based on reference equality of the views from which these instances werecreated, or the equality of their assigned ids.",
	"Method": "boolean equals(Object object,boolean equals,Object object,boolean equals,Object other){\r\n    if (!(object instanceof AccessibilityNodeInfo)) {\r\n        return false;\r\n    }\r\n    final AccessibilityNodeInfo info = (AccessibilityNodeInfo) object;\r\n    final ShadowAccessibilityNodeInfo otherShadow = Shadow.extract(info);\r\n    if (this.view != null) {\r\n        return this.view == otherShadow.view;\r\n    }\r\n    if (this.mOriginNodeId != 0) {\r\n        return this.mOriginNodeId == otherShadow.mOriginNodeId;\r\n    }\r\n    throw new IllegalStateException(\"Node has neither an ID nor View\");\r\n}"
}, {
	"Path": "io.reactivex.disposables.Disposables.fromRunnable",
	"Comment": "construct a disposable by wrapping a runnable that isexecuted exactly once when the disposable is disposed.",
	"Method": "Disposable fromRunnable(Runnable run){\r\n    ObjectHelper.requireNonNull(run, \"run is null\");\r\n    return new RunnableDisposable(run);\r\n}"
}, {
	"Path": "io.reactivex.subjects.PublishSubject.remove",
	"Comment": "atomically removes the given subscriber if it is subscribed to the subject.",
	"Method": "void remove(PublishDisposable<T> ps){\r\n    for (; ; ) {\r\n        PublishDisposable<T>[] a = subscribers.get();\r\n        if (a == TERMINATED || a == EMPTY) {\r\n            return;\r\n        }\r\n        int n = a.length;\r\n        int j = -1;\r\n        for (int i = 0; i < n; i++) {\r\n            if (a[i] == ps) {\r\n                j = i;\r\n                break;\r\n            }\r\n        }\r\n        if (j < 0) {\r\n            return;\r\n        }\r\n        PublishDisposable<T>[] b;\r\n        if (n == 1) {\r\n            b = EMPTY;\r\n        } else {\r\n            b = new PublishDisposable[n - 1];\r\n            System.arraycopy(a, 0, b, 0, j);\r\n            System.arraycopy(a, j + 1, b, j, n - j - 1);\r\n        }\r\n        if (subscribers.compareAndSet(a, b)) {\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.github.scribejava.core.builder.api.DefaultApi10a.getAuthorizationUrl",
	"Comment": "returns the url where you should redirect your users to authenticate your application.",
	"Method": "String getAuthorizationUrl(OAuth1RequestToken requestToken){\r\n    final ParameterList parameters = new ParameterList();\r\n    parameters.add(OAuthConstants.TOKEN, requestToken.getToken());\r\n    return parameters.appendTo(getAuthorizationBaseUrl());\r\n}"
}, {
	"Path": "org.robolectric.manifest.AndroidManifest.getAllManifests",
	"Comment": "returns all transitively reachable manifests, including this one, in order and withoutduplicates.",
	"Method": "List<AndroidManifest> getAllManifests(){\r\n    Set<AndroidManifest> seenManifests = new HashSet();\r\n    List<AndroidManifest> uniqueManifests = new ArrayList();\r\n    addTransitiveManifests(seenManifests, uniqueManifests);\r\n    return uniqueManifests;\r\n}"
}, {
	"Path": "org.robolectric.RobolectricTestRunner.getManifestFactory",
	"Comment": "detects which build system is in use and returns the appropriate manifestfactory implementation.custom testrunner subclasses may wish to override this method to provide alternate configuration.",
	"Method": "ManifestFactory getManifestFactory(Config config){\r\n    Properties buildSystemApiProperties = getBuildSystemApiProperties();\r\n    if (buildSystemApiProperties != null) {\r\n        return new DefaultManifestFactory(buildSystemApiProperties);\r\n    }\r\n    if (BuckManifestFactory.isBuck()) {\r\n        return new BuckManifestFactory();\r\n    } else {\r\n        return new MavenManifestFactory();\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.httpclient.FakeHttp.httpRequestWasMade",
	"Comment": "accessor to find out if http requests were made during the current test.",
	"Method": "boolean httpRequestWasMade(boolean httpRequestWasMade,String uri){\r\n    return getFakeHttpLayer().hasRequestMatchingRule(new FakeHttpLayer.UriRequestMatcher(uri));\r\n}"
}, {
	"Path": "io.reactivex.subjects.PublishSubjectTest.testReSubscribe",
	"Comment": "should be able to unsubscribe all subscribers, have it stop emitting, then subscribe new ones and it start emitting again.",
	"Method": "void testReSubscribe(){\r\n    final PublishSubject<Integer> ps = PublishSubject.create();\r\n    Observer<Integer> o1 = TestHelper.mockObserver();\r\n    TestObserver<Integer> to = new TestObserver<Integer>(o1);\r\n    ps.subscribe(to);\r\n    ps.onNext(1);\r\n    InOrder inOrder1 = inOrder(o1);\r\n    inOrder1.verify(o1, times(1)).onNext(1);\r\n    inOrder1.verifyNoMoreInteractions();\r\n    to.dispose();\r\n    ps.onNext(2);\r\n    Observer<Integer> o2 = TestHelper.mockObserver();\r\n    TestObserver<Integer> to2 = new TestObserver<Integer>(o2);\r\n    ps.subscribe(to2);\r\n    ps.onNext(3);\r\n    InOrder inOrder2 = inOrder(o2);\r\n    inOrder2.verify(o2, times(1)).onNext(3);\r\n    inOrder2.verifyNoMoreInteractions();\r\n    to2.dispose();\r\n}"
}, {
	"Path": "io.reactivex.internal.subscriptions.AsyncSubscription.setResource",
	"Comment": "sets a new resource and disposes the currently held resource.",
	"Method": "boolean setResource(Disposable r){\r\n    return DisposableHelper.set(resource, r);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowUsbManager.addOrUpdateUsbDevice",
	"Comment": "adds a usb device into available usb devices map with permission value. if the usb devicealready exists, updates the usb device with new permission value.",
	"Method": "void addOrUpdateUsbDevice(UsbDevice usbDevice,boolean hasPermission){\r\n    Preconditions.checkNotNull(usbDevice);\r\n    Preconditions.checkNotNull(usbDevice.getDeviceName());\r\n    usbDevices.put(usbDevice.getDeviceName(), usbDevice);\r\n    if (hasPermission) {\r\n        grantPermission(usbDevice);\r\n    } else {\r\n        revokePermission(usbDevice, RuntimeEnvironment.application.getPackageName());\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.processors.AsyncProcessor.remove",
	"Comment": "atomically removes the given subscriber if it is subscribed to this processor.",
	"Method": "void remove(AsyncSubscription<T> ps){\r\n    for (; ; ) {\r\n        AsyncSubscription<T>[] a = subscribers.get();\r\n        int n = a.length;\r\n        if (n == 0) {\r\n            return;\r\n        }\r\n        int j = -1;\r\n        for (int i = 0; i < n; i++) {\r\n            if (a[i] == ps) {\r\n                j = i;\r\n                break;\r\n            }\r\n        }\r\n        if (j < 0) {\r\n            return;\r\n        }\r\n        AsyncSubscription<T>[] b;\r\n        if (n == 1) {\r\n            b = EMPTY;\r\n        } else {\r\n            b = new AsyncSubscription[n - 1];\r\n            System.arraycopy(a, 0, b, 0, j);\r\n            System.arraycopy(a, j + 1, b, j, n - j - 1);\r\n        }\r\n        if (subscribers.compareAndSet(a, b)) {\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textToBePresentInElement",
	"Comment": "an expectation for checking if the given text is present in the specified element.",
	"Method": "ExpectedCondition<Boolean> textToBePresentInElement(WebElement element,String text){\r\n    return new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            try {\r\n                String elementText = element.getText();\r\n                return elementText.contains(text);\r\n            } catch (StaleElementReferenceException e) {\r\n                return null;\r\n            }\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"text ('%s') to be present in element %s\", text, element);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textToBePresentInElement",
	"Comment": "an expectation for checking if the given text is present in the specified element.",
	"Method": "ExpectedCondition<Boolean> textToBePresentInElement(WebElement element,String text){\r\n    try {\r\n        String elementText = element.getText();\r\n        return elementText.contains(text);\r\n    } catch (StaleElementReferenceException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.textToBePresentInElement",
	"Comment": "an expectation for checking if the given text is present in the specified element.",
	"Method": "ExpectedCondition<Boolean> textToBePresentInElement(WebElement element,String text){\r\n    return String.format(\"text ('%s') to be present in element %s\", text, element);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableReplayTest.testIssue2191_SchedulerUnsubscribeOnError",
	"Comment": "specifically test interaction with a scheduler with subscribeon.",
	"Method": "void testIssue2191_SchedulerUnsubscribeOnError(){\r\n    Consumer<Integer> sourceNext = mock(Consumer.class);\r\n    Action sourceCompleted = mock(Action.class);\r\n    Consumer<Throwable> sourceError = mock(Consumer.class);\r\n    Action sourceUnsubscribed = mock(Action.class);\r\n    final TestScheduler mockScheduler = new TestScheduler();\r\n    Observer<Integer> mockObserverBeforeConnect = TestHelper.mockObserver();\r\n    Observer<Integer> mockObserverAfterConnect = TestHelper.mockObserver();\r\n    Function<Integer, Integer> mockFunc = mock(Function.class);\r\n    IllegalArgumentException illegalArgumentException = new IllegalArgumentException();\r\n    when(mockFunc.apply(1)).thenReturn(1);\r\n    when(mockFunc.apply(2)).thenThrow(illegalArgumentException);\r\n    ConnectableObservable<Integer> replay = Observable.just(1, 2, 3).map(mockFunc).doOnNext(sourceNext).doOnDispose(sourceUnsubscribed).doOnComplete(sourceCompleted).doOnError(sourceError).subscribeOn(mockScheduler).replay();\r\n    replay.subscribe(mockObserverBeforeConnect);\r\n    replay.connect();\r\n    replay.subscribe(mockObserverAfterConnect);\r\n    verify(mockObserverBeforeConnect).onSubscribe((Disposable) any());\r\n    verify(mockObserverAfterConnect).onSubscribe((Disposable) any());\r\n    mockScheduler.advanceTimeBy(1, TimeUnit.SECONDS);\r\n    verify(sourceNext, times(1)).accept(1);\r\n    verify(sourceError, times(1)).accept(illegalArgumentException);\r\n    verifyObserver(mockObserverBeforeConnect, 1, 1, illegalArgumentException);\r\n    verifyObserver(mockObserverAfterConnect, 1, 1, illegalArgumentException);\r\n    verifyNoMoreInteractions(sourceNext);\r\n    verifyNoMoreInteractions(sourceCompleted);\r\n    verifyNoMoreInteractions(sourceError);\r\n    verifyNoMoreInteractions(sourceUnsubscribed);\r\n    verifyNoMoreInteractions(mockObserverBeforeConnect);\r\n    verifyNoMoreInteractions(mockObserverAfterConnect);\r\n}"
}, {
	"Path": "org.robolectric.util.Util.readBytes",
	"Comment": "this method consumes an input stream and returns its content.",
	"Method": "byte[] readBytes(InputStream is){\r\n    try (ByteArrayOutputStream bos = new ByteArrayOutputStream(is.available())) {\r\n        copy(is, bos);\r\n        return bos.toByteArray();\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.subscribers.DisposableSubscriber.request",
	"Comment": "requests the specified amount from the upstream if its subscription is set viaonsubscribe already.note that calling this method before a subscription is set via onsubscribeleads to nullpointerexception and meant to be called from inside onstart oronnext.",
	"Method": "void request(long n){\r\n    upstream.get().request(n);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testExceptionIfSubscribeToChildMoreThanOnce",
	"Comment": "assert we get an illegalstateexception if trying to subscribe to an inner groupedflowable more than once.",
	"Method": "void testExceptionIfSubscribeToChildMoreThanOnce(){\r\n    Flowable<Integer> source = Flowable.just(0);\r\n    final AtomicReference<GroupedFlowable<Integer, Integer>> inner = new AtomicReference<GroupedFlowable<Integer, Integer>>();\r\n    Flowable<GroupedFlowable<Integer, Integer>> m = source.groupBy(identity, dbl);\r\n    m.subscribe(new Consumer<GroupedFlowable<Integer, Integer>>() {\r\n        @Override\r\n        public void accept(GroupedFlowable<Integer, Integer> t1) {\r\n            inner.set(t1);\r\n        }\r\n    });\r\n    inner.get().subscribe();\r\n    Subscriber<Integer> subscriber2 = TestHelper.mockSubscriber();\r\n    inner.get().subscribe(subscriber2);\r\n    verify(subscriber2, never()).onComplete();\r\n    verify(subscriber2, never()).onNext(anyInt());\r\n    verify(subscriber2).onError(any(IllegalStateException.class));\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testExceptionIfSubscribeToChildMoreThanOnce",
	"Comment": "assert we get an illegalstateexception if trying to subscribe to an inner groupedflowable more than once.",
	"Method": "void testExceptionIfSubscribeToChildMoreThanOnce(){\r\n    inner.set(t1);\r\n}"
}, {
	"Path": "io.reactivex.internal.util.EndConsumerHelper.validate",
	"Comment": "ensures that the upstream subscription is null and returns true, otherwisecancels the next subscription and if the upstream is not the sharedcancelled instance, reports a protocolviolationexception due tomultiple subscribe attempts.",
	"Method": "boolean validate(Disposable upstream,Disposable next,Class<?> observer,boolean validate,Subscription upstream,Subscription next,Class<?> subscriber){\r\n    ObjectHelper.requireNonNull(next, \"next is null\");\r\n    if (upstream != null) {\r\n        next.cancel();\r\n        if (upstream != SubscriptionHelper.CANCELLED) {\r\n            reportDoubleSubscription(subscriber);\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.robolectric.junit.rules.ExpectedLogMessagesRule.expectLogMessage",
	"Comment": "adds an expected log statement. if this log is not printed during test execution, the test casewill fail. do not use this to suppress failures. use this to test that expected error cases inyour code cause log messages to be printed.",
	"Method": "void expectLogMessage(int level,String tag,String message){\r\n    checkTag(tag);\r\n    expectedLogs.add(new LogItem(level, tag, message, null));\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowTextToSpeech.speak",
	"Comment": "speaks the string using the specified queuing strategy and speech parameters.",
	"Method": "int speak(String text,int queueMode,HashMap<String, String> params,int speak,CharSequence text,int queueMode,Bundle params,String utteranceId){\r\n    stopped = false;\r\n    lastSpokenText = text.toString();\r\n    this.queueMode = queueMode;\r\n    if (RuntimeEnvironment.getApiLevel() >= ICE_CREAM_SANDWICH_MR1) {\r\n        if (utteranceId != null) {\r\n            Handler handler = new Handler(Looper.getMainLooper());\r\n            handler.post(() -> {\r\n                UtteranceProgressListener utteranceProgressListener = getUtteranceProgressListener();\r\n                if (utteranceProgressListener != null) {\r\n                    utteranceProgressListener.onStart(utteranceId);\r\n                }\r\n                handler.post(() -> {\r\n                    UtteranceProgressListener utteranceProgressListener2 = getUtteranceProgressListener();\r\n                    if (utteranceProgressListener2 != null) {\r\n                        utteranceProgressListener2.onDone(utteranceId);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n    return TextToSpeech.SUCCESS;\r\n}"
}, {
	"Path": "io.reactivex.Scheduler.scheduleDirect",
	"Comment": "schedules the execution of the given task with the given time delay.this method is safe to be called from multiple threads but there are noordering guarantees between tasks.",
	"Method": "Disposable scheduleDirect(Runnable run,Disposable scheduleDirect,Runnable run,long delay,TimeUnit unit){\r\n    final Worker w = createWorker();\r\n    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\r\n    DisposeTask task = new DisposeTask(decoratedRun, w);\r\n    w.schedule(task, delay, unit);\r\n    return task;\r\n}"
}, {
	"Path": "io.reactivex.processors.MulticastProcessor.offer",
	"Comment": "tries to offer an item into the internal queue and returns falseif the queue is full.",
	"Method": "boolean offer(T t){\r\n    if (once.get()) {\r\n        return false;\r\n    }\r\n    ObjectHelper.requireNonNull(t, \"offer called with null. Null values are generally not allowed in 2.x operators and sources.\");\r\n    if (fusionMode == QueueSubscription.NONE) {\r\n        if (queue.offer(t)) {\r\n            drain();\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.openqa.selenium.remote.service.DriverService.stop",
	"Comment": "stops this service if it is currently running. this method will attempt to block until theserver has been fully shutdown.",
	"Method": "void stop(){\r\n    lock.lock();\r\n    WebDriverException toThrow = null;\r\n    try {\r\n        if (process == null) {\r\n            return;\r\n        }\r\n        if (hasShutdownEndpoint()) {\r\n            try {\r\n                URL killUrl = new URL(url.toString() + \"/shutdown\");\r\n                new UrlChecker().waitUntilUnavailable(3, SECONDS, killUrl);\r\n            } catch (MalformedURLException e) {\r\n                toThrow = new WebDriverException(e);\r\n            } catch (UrlChecker.TimeoutException e) {\r\n                toThrow = new WebDriverException(\"Timed out waiting for driver server to shutdown.\", e);\r\n            }\r\n        }\r\n        process.destroy();\r\n    } finally {\r\n        process = null;\r\n        lock.unlock();\r\n    }\r\n    if (toThrow != null) {\r\n        throw toThrow;\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.Notification.createOnComplete",
	"Comment": "returns the empty and stateless shared instance of a notification representingan oncomplete signal.",
	"Method": "Notification<T> createOnComplete(){\r\n    return (Notification<T>) COMPLETE;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowLegacyAssetManager.getFileFromZip",
	"Comment": "extract an asset from a zipped up assets provided by the build system, this is required because there is noway to get a filedescriptor from a zip entry. this is a temporary measure for bazel which can be removedonce binary resources are supported.",
	"Method": "File getFileFromZip(File file){\r\n    File fileFromZip = null;\r\n    String pathString = file.getPath();\r\n    String zipFile = pathString.substring(pathString.lastIndexOf(\":\") + 1, pathString.indexOf(\"!\"));\r\n    String filePathInsideZip = pathString.split(\"!\", 0)[1].substring(1);\r\n    byte[] buffer = new byte[1024];\r\n    try {\r\n        File outputDir = Files.createTempDirectory(\"robolectric_assets\").toFile();\r\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile));\r\n        ZipEntry ze = zis.getNextEntry();\r\n        while (ze != null) {\r\n            String currentFilename = ze.getName();\r\n            if (!currentFilename.equals(filePathInsideZip)) {\r\n                ze = zis.getNextEntry();\r\n                continue;\r\n            }\r\n            fileFromZip = new File(outputDir + File.separator + currentFilename);\r\n            new File(fileFromZip.getParent()).mkdirs();\r\n            FileOutputStream fos = new FileOutputStream(fileFromZip);\r\n            int len;\r\n            while ((len = zis.read(buffer)) > 0) {\r\n                fos.write(buffer, 0, len);\r\n            }\r\n            fos.close();\r\n            break;\r\n        }\r\n        zis.closeEntry();\r\n        zis.close();\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    return fileFromZip;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableScanTest.testSeedFactory",
	"Comment": "this uses the public api collect which uses scan under the covers.",
	"Method": "void testSeedFactory(){\r\n    Single<List<Integer>> o = Flowable.range(1, 10).collect(new Callable<List<Integer>>() {\r\n        @Override\r\n        public List<Integer> call() {\r\n            return new ArrayList<Integer>();\r\n        }\r\n    }, new BiConsumer<List<Integer>, Integer>() {\r\n        @Override\r\n        public void accept(List<Integer> list, Integer t2) {\r\n            list.add(t2);\r\n        }\r\n    });\r\n    assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), o.blockingGet());\r\n    assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), o.blockingGet());\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableScanTest.testSeedFactory",
	"Comment": "this uses the public api collect which uses scan under the covers.",
	"Method": "void testSeedFactory(){\r\n    return new ArrayList<Integer>();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableScanTest.testSeedFactory",
	"Comment": "this uses the public api collect which uses scan under the covers.",
	"Method": "void testSeedFactory(){\r\n    list.add(t2);\r\n}"
}, {
	"Path": "io.reactivex.schedulers.Timed.time",
	"Comment": "returns the contained time value in the time unit specified.",
	"Method": "long time(long time,TimeUnit unit){\r\n    return unit.convert(time, this.unit);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowDevicePolicyManager.setOrganizationName",
	"Comment": "sets organization name.the api can only be called by profile owner since android n and can be called by both ofprofile owner and device owner since android o.",
	"Method": "void setOrganizationName(ComponentName admin,CharSequence name){\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n        enforceDeviceOwnerOrProfileOwner(admin);\r\n    } else {\r\n        enforceProfileOwner(admin);\r\n    }\r\n    if (TextUtils.isEmpty(name)) {\r\n        organizationName = null;\r\n    } else {\r\n        organizationName = name;\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableCache.replay",
	"Comment": "replays the contents of this cache to the given consumer based on itscurrent state and number of items requested by it.",
	"Method": "void replay(CacheSubscription<T> consumer){\r\n    if (consumer.getAndIncrement() != 0) {\r\n        return;\r\n    }\r\n    int missed = 1;\r\n    long index = consumer.index;\r\n    int offset = consumer.offset;\r\n    Node<T> node = consumer.node;\r\n    AtomicLong requested = consumer.requested;\r\n    Subscriber<? super T> downstream = consumer.downstream;\r\n    int capacity = capacityHint;\r\n    for (; ; ) {\r\n        boolean sourceDone = done;\r\n        boolean empty = size == index;\r\n        if (sourceDone && empty) {\r\n            consumer.node = null;\r\n            Throwable ex = error;\r\n            if (ex != null) {\r\n                downstream.onError(ex);\r\n            } else {\r\n                downstream.onComplete();\r\n            }\r\n            return;\r\n        }\r\n        if (!empty) {\r\n            long consumerRequested = requested.get();\r\n            if (consumerRequested == Long.MIN_VALUE) {\r\n                consumer.node = null;\r\n                return;\r\n            }\r\n            if (consumerRequested != index) {\r\n                if (offset == capacity) {\r\n                    node = node.next;\r\n                    offset = 0;\r\n                }\r\n                downstream.onNext(node.values[offset]);\r\n                offset++;\r\n                index++;\r\n                continue;\r\n            }\r\n        }\r\n        consumer.index = index;\r\n        consumer.offset = offset;\r\n        consumer.node = node;\r\n        missed = consumer.addAndGet(-missed);\r\n        if (missed == 0) {\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableObserveOnTest.testObserveOnWithThreadPoolScheduler",
	"Comment": "confirm that running on a threadpoolscheduler allows multiple threads but is still ordered.",
	"Method": "void testObserveOnWithThreadPoolScheduler(){\r\n    final AtomicInteger count = new AtomicInteger();\r\n    final int _multiple = 99;\r\n    Observable.range(1, 100000).map(new Function<Integer, Integer>() {\r\n        @Override\r\n        public Integer apply(Integer t1) {\r\n            return t1 * _multiple;\r\n        }\r\n    }).observeOn(Schedulers.computation()).blockingForEach(new Consumer<Integer>() {\r\n        @Override\r\n        public void accept(Integer t1) {\r\n            assertEquals(count.incrementAndGet() * _multiple, t1.intValue());\r\n            String name = Thread.currentThread().getName();\r\n            assertFalse(\"Wrong thread name: \" + name, name.startsWith(\"Rx\"));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableObserveOnTest.testObserveOnWithThreadPoolScheduler",
	"Comment": "confirm that running on a threadpoolscheduler allows multiple threads but is still ordered.",
	"Method": "void testObserveOnWithThreadPoolScheduler(){\r\n    return t1 * _multiple;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableObserveOnTest.testObserveOnWithThreadPoolScheduler",
	"Comment": "confirm that running on a threadpoolscheduler allows multiple threads but is still ordered.",
	"Method": "void testObserveOnWithThreadPoolScheduler(){\r\n    assertEquals(count.incrementAndGet() * _multiple, t1.intValue());\r\n    String name = Thread.currentThread().getName();\r\n    assertFalse(\"Wrong thread name: \" + name, name.startsWith(\"Rx\"));\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableZipTest.testAggregatorSimple",
	"Comment": "testing internal private logic due to the complexity so i want to use tdd to test as a i build it rather than relying purely on the overall functionality expected by the public methods.",
	"Method": "void testAggregatorSimple(){\r\n    PublishProcessor<String> r1 = PublishProcessor.create();\r\n    PublishProcessor<String> r2 = PublishProcessor.create();\r\n    Subscriber<String> subscriber = TestHelper.mockSubscriber();\r\n    Flowable.zip(r1, r2, zipr2).subscribe(subscriber);\r\n    r1.onNext(\"hello\");\r\n    r2.onNext(\"world\");\r\n    InOrder inOrder = inOrder(subscriber);\r\n    verify(subscriber, never()).onError(any(Throwable.class));\r\n    verify(subscriber, never()).onComplete();\r\n    inOrder.verify(subscriber, times(1)).onNext(\"helloworld\");\r\n    r1.onNext(\"hello \");\r\n    r2.onNext(\"again\");\r\n    verify(subscriber, never()).onError(any(Throwable.class));\r\n    verify(subscriber, never()).onComplete();\r\n    inOrder.verify(subscriber, times(1)).onNext(\"hello again\");\r\n    r1.onComplete();\r\n    r2.onComplete();\r\n    inOrder.verify(subscriber, never()).onNext(anyString());\r\n    verify(subscriber, times(1)).onComplete();\r\n}"
}, {
	"Path": "io.reactivex.internal.subscribers.SinglePostCompleteSubscriber.complete",
	"Comment": "signals the given value and an oncomplete if the downstream is ready to receive the final value.",
	"Method": "void complete(R n){\r\n    long p = produced;\r\n    if (p != 0) {\r\n        BackpressureHelper.produced(this, p);\r\n    }\r\n    for (; ; ) {\r\n        long r = get();\r\n        if ((r & COMPLETE_MASK) != 0) {\r\n            onDrop(n);\r\n            return;\r\n        }\r\n        if ((r & REQUEST_MASK) != 0) {\r\n            lazySet(COMPLETE_MASK + 1);\r\n            downstream.onNext(n);\r\n            downstream.onComplete();\r\n            return;\r\n        }\r\n        value = n;\r\n        if (compareAndSet(0, COMPLETE_MASK)) {\r\n            return;\r\n        }\r\n        value = null;\r\n    }\r\n}"
}, {
	"Path": "com.github.scribejava.core.oauth.OAuth10aService.getAccessTokenAsync",
	"Comment": "start the request to retrieve the access token. the optionally provided callback will be called with the tokenwhen it is available.",
	"Method": "Future<OAuth1AccessToken> getAccessTokenAsync(OAuth1RequestToken requestToken,String oauthVerifier,Future<OAuth1AccessToken> getAccessTokenAsync,OAuth1RequestToken requestToken,String oauthVerifier,OAuthAsyncRequestCallback<OAuth1AccessToken> callback){\r\n    log(\"async obtaining access token from %s\", api.getAccessTokenEndpoint());\r\n    final OAuthRequest request = prepareAccessTokenRequest(requestToken, oauthVerifier);\r\n    return execute(request, callback, new OAuthRequest.ResponseConverter<OAuth1AccessToken>() {\r\n        @Override\r\n        public OAuth1AccessToken convert(Response response) throws IOException {\r\n            return getApi().getAccessTokenExtractor().extract(response);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.github.scribejava.core.oauth.OAuth10aService.getAccessTokenAsync",
	"Comment": "start the request to retrieve the access token. the optionally provided callback will be called with the tokenwhen it is available.",
	"Method": "Future<OAuth1AccessToken> getAccessTokenAsync(OAuth1RequestToken requestToken,String oauthVerifier,Future<OAuth1AccessToken> getAccessTokenAsync,OAuth1RequestToken requestToken,String oauthVerifier,OAuthAsyncRequestCallback<OAuth1AccessToken> callback){\r\n    return getApi().getAccessTokenExtractor().extract(response);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.invisibilityOfElementWithText",
	"Comment": "an expectation for checking that an element with text is either invisible or not present on thedom.",
	"Method": "ExpectedCondition<Boolean> invisibilityOfElementWithText(By locator,String text){\r\n    return new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            try {\r\n                return !driver.findElement(locator).getText().equals(text);\r\n            } catch (NoSuchElementException e) {\r\n                return true;\r\n            } catch (StaleElementReferenceException e) {\r\n                return true;\r\n            }\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"element containing '%s' to no longer be visible: %s\", text, locator);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.invisibilityOfElementWithText",
	"Comment": "an expectation for checking that an element with text is either invisible or not present on thedom.",
	"Method": "ExpectedCondition<Boolean> invisibilityOfElementWithText(By locator,String text){\r\n    try {\r\n        return !driver.findElement(locator).getText().equals(text);\r\n    } catch (NoSuchElementException e) {\r\n        return true;\r\n    } catch (StaleElementReferenceException e) {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.invisibilityOfElementWithText",
	"Comment": "an expectation for checking that an element with text is either invisible or not present on thedom.",
	"Method": "ExpectedCondition<Boolean> invisibilityOfElementWithText(By locator,String text){\r\n    return String.format(\"element containing '%s' to no longer be visible: %s\", text, locator);\r\n}"
}, {
	"Path": "io.reactivex.processors.MulticastProcessor.startUnbounded",
	"Comment": "initializes this processor by setting an upstream subscription thatignores request amounts, uses an unbounded bufferand allows using the onxxx and offer methodsafterwards.",
	"Method": "void startUnbounded(){\r\n    if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) {\r\n        queue = new SpscLinkedArrayQueue<T>(bufferSize);\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowParcel.nativeWriteBlob",
	"Comment": "nativewriteblob was introduced in lollipop, thus no need for a int nativeptr variant",
	"Method": "void nativeWriteBlob(long nativePtr,byte[] b,int offset,int len){\r\n    nativeWriteByteArray(nativePtr, b, offset, len);\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.onTileLoaded",
	"Comment": "called by worker task when a tile has loaded. redraws the view.",
	"Method": "void onTileLoaded(){\r\n    debug(\"onTileLoaded\");\r\n    checkReady();\r\n    checkImageLoaded();\r\n    if (isBaseLayerReady() && bitmap != null) {\r\n        if (!bitmapIsCached) {\r\n            bitmap.recycle();\r\n        }\r\n        bitmap = null;\r\n        if (onImageEventListener != null && bitmapIsCached) {\r\n            onImageEventListener.onPreviewReleased();\r\n        }\r\n        bitmapIsPreview = false;\r\n        bitmapIsCached = false;\r\n    }\r\n    invalidate();\r\n}"
}, {
	"Path": "com.vondear.rxfeature.module.scaner.CameraManager.getFramingRect",
	"Comment": "calculates the framing rect which the ui should draw to show the user where to place thebarcode. this target helps with alignment as well as forces the user to hold the devicefar enough away to ensure the image will be in focus.",
	"Method": "Rect getFramingRect(){\r\n    try {\r\n        Point screenResolution = configManager.getScreenResolution();\r\n        if (camera == null) {\r\n            return null;\r\n        }\r\n        int leftOffset = (screenResolution.x - FRAME_WIDTH) / 2;\r\n        int topOffset;\r\n        if (FRAME_MARGINTOP != -1) {\r\n            topOffset = FRAME_MARGINTOP;\r\n        } else {\r\n            topOffset = (screenResolution.y - FRAME_HEIGHT) / 2;\r\n        }\r\n        framingRect = new Rect(leftOffset, topOffset, leftOffset + FRAME_WIDTH, topOffset + FRAME_HEIGHT);\r\n        return framingRect;\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowEventLog.writeEvent",
	"Comment": "writes an event log message, returning an approximation of the bytes written.",
	"Method": "int writeEvent(int tag,String str,int writeEvent,int tag,Object list,int writeEvent,int tag,int value,int writeEvent,int tag,float value,int writeEvent,int tag,long value){\r\n    addEvent(new EventBuilder(tag, value).build());\r\n    return Integer.BYTES + Long.BYTES;\r\n}"
}, {
	"Path": "org.openqa.selenium.logging.LogEntry.getTimestamp",
	"Comment": "gets the timestamp of the log statement in milliseconds since unix epoch.",
	"Method": "long getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableConcatTest.testConcatUnsubscribe",
	"Comment": "test unsubscribing the concatenated observable in a single thread.",
	"Method": "void testConcatUnsubscribe(){\r\n    final CountDownLatch callOnce = new CountDownLatch(1);\r\n    final CountDownLatch okToContinue = new CountDownLatch(1);\r\n    final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\");\r\n    final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, \"four\", \"five\", \"six\");\r\n    Observer<String> observer = TestHelper.mockObserver();\r\n    TestObserver<String> to = new TestObserver<String>(observer);\r\n    final Observable<String> concat = Observable.concat(Observable.unsafeCreate(w1), Observable.unsafeCreate(w2));\r\n    try {\r\n        concat.subscribe(to);\r\n        callOnce.await();\r\n        to.dispose();\r\n        okToContinue.countDown();\r\n        w1.t.join();\r\n        w2.t.join();\r\n    } catch (Throwable e) {\r\n        e.printStackTrace();\r\n        fail(e.getMessage());\r\n    }\r\n    InOrder inOrder = inOrder(observer);\r\n    inOrder.verify(observer, times(1)).onNext(\"one\");\r\n    inOrder.verify(observer, times(1)).onNext(\"two\");\r\n    inOrder.verify(observer, times(1)).onNext(\"three\");\r\n    inOrder.verify(observer, times(1)).onNext(\"four\");\r\n    inOrder.verify(observer, never()).onNext(\"five\");\r\n    inOrder.verify(observer, never()).onNext(\"six\");\r\n    inOrder.verify(observer, never()).onComplete();\r\n}"
}, {
	"Path": "com.thoughtworks.selenium.webdriven.JavascriptLibrary.getSeleniumScript",
	"Comment": "loads the named selenium script and returns it wrapped in an anonymous function.",
	"Method": "String getSeleniumScript(String name){\r\n    String rawFunction = readScript(PREFIX + name);\r\n    return String.format(\"function() { return (%s).apply(null, arguments);}\", rawFunction);\r\n}"
}, {
	"Path": "com.morihacky.android.rxjava.fragments.RotationPersist2WorkerFragment.onCreate",
	"Comment": "this method will only be called once when the retained fragment is first created.",
	"Method": "void onCreate(Bundle savedInstanceState){\r\n    super.onCreate(savedInstanceState);\r\n    _intStream = PublishProcessor.create();\r\n    _lifeCycleStream = PublishProcessor.create();\r\n    setRetainInstance(true);\r\n    _intStream.takeUntil(_lifeCycleStream);\r\n    Flowable.interval(1, TimeUnit.SECONDS).map(Long::intValue).take(20).subscribe(_intStream);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableReplayTest.testIssue2191_SchedulerUnsubscribe",
	"Comment": "specifically test interaction with a scheduler with subscribeon.",
	"Method": "void testIssue2191_SchedulerUnsubscribe(){\r\n    Consumer<Integer> sourceNext = mock(Consumer.class);\r\n    Action sourceCompleted = mock(Action.class);\r\n    Action sourceUnsubscribed = mock(Action.class);\r\n    final TestScheduler mockScheduler = new TestScheduler();\r\n    Observer<Integer> mockObserverBeforeConnect = TestHelper.mockObserver();\r\n    Observer<Integer> mockObserverAfterConnect = TestHelper.mockObserver();\r\n    ConnectableObservable<Integer> replay = Observable.just(1, 2, 3).doOnNext(sourceNext).doOnDispose(sourceUnsubscribed).doOnComplete(sourceCompleted).subscribeOn(mockScheduler).replay();\r\n    replay.subscribe(mockObserverBeforeConnect);\r\n    replay.connect();\r\n    replay.subscribe(mockObserverAfterConnect);\r\n    verify(mockObserverBeforeConnect).onSubscribe((Disposable) any());\r\n    verify(mockObserverAfterConnect).onSubscribe((Disposable) any());\r\n    mockScheduler.advanceTimeBy(1, TimeUnit.SECONDS);\r\n    verify(sourceNext, times(1)).accept(1);\r\n    verify(sourceNext, times(1)).accept(2);\r\n    verify(sourceNext, times(1)).accept(3);\r\n    verify(sourceCompleted, times(1)).run();\r\n    verifyObserverMock(mockObserverBeforeConnect, 1, 3);\r\n    verifyObserverMock(mockObserverAfterConnect, 1, 3);\r\n    verifyNoMoreInteractions(sourceNext);\r\n    verifyNoMoreInteractions(sourceCompleted);\r\n    verifyNoMoreInteractions(sourceUnsubscribed);\r\n    verifyNoMoreInteractions(mockObserverBeforeConnect);\r\n    verifyNoMoreInteractions(mockObserverAfterConnect);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowMediaRouter.removeBluetoothRoute",
	"Comment": "removes the bluetooth a2dp route, simulating disconnecting the bluetooth device.",
	"Method": "void removeBluetoothRoute(){\r\n    updateBluetoothAudioRoute(null);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowPathMeasure.getLength",
	"Comment": "return the total length of the current contour, or 0 if no path is associated with this measureobject.",
	"Method": "float getLength(){\r\n    if (mOriginalPathIterator == null) {\r\n        return 0;\r\n    }\r\n    return mOriginalPathIterator.iterator().getTotalLength();\r\n}"
}, {
	"Path": "io.reactivex.subjects.UnicastSubject.create",
	"Comment": "creates an unicastsubject with the given internal buffer capacity hint.",
	"Method": "UnicastSubject<T> create(UnicastSubject<T> create,int capacityHint,UnicastSubject<T> create,int capacityHint,Runnable onTerminate,UnicastSubject<T> create,int capacityHint,Runnable onTerminate,boolean delayError,UnicastSubject<T> create,boolean delayError){\r\n    return new UnicastSubject<T>(bufferSize(), delayError);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowSQLiteConnection.convertSQLWithLocalizedUnicodeCollator",
	"Comment": "convert sql with phrase collate localized or collate unicode to collate nocase.",
	"Method": "String convertSQLWithLocalizedUnicodeCollator(String sql){\r\n    Matcher matcher = COLLATE_LOCALIZED_UNICODE_PATTERN.matcher(sql);\r\n    return matcher.replaceAll(\" COLLATE NOCASE\");\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableReplay.createFrom",
	"Comment": "creates a replaying connectableobservable with an unbounded buffer.",
	"Method": "ConnectableObservable<T> createFrom(ObservableSource<? extends T> source){\r\n    return create(source, DEFAULT_UNBOUNDED_FACTORY);\r\n}"
}, {
	"Path": "io.reactivex.single.SingleTest.testUnsubscribeViaReturnedSubscription",
	"Comment": "assert that unsubscribe propagates when passing in a singleobserver and not a subscriber.",
	"Method": "void testUnsubscribeViaReturnedSubscription(){\r\n    final AtomicBoolean unsubscribed = new AtomicBoolean();\r\n    final AtomicBoolean interrupted = new AtomicBoolean();\r\n    final CountDownLatch latch = new CountDownLatch(2);\r\n    Single<String> s1 = Single.unsafeCreate(new SingleSource<String>() {\r\n        @Override\r\n        public void subscribe(final SingleObserver<? super String> observer) {\r\n            SerialDisposable sd = new SerialDisposable();\r\n            observer.onSubscribe(sd);\r\n            final Thread t = new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    try {\r\n                        Thread.sleep(5000);\r\n                        observer.onSuccess(\"success\");\r\n                    } catch (InterruptedException e) {\r\n                        interrupted.set(true);\r\n                        latch.countDown();\r\n                    }\r\n                }\r\n            });\r\n            sd.replace(Disposables.fromRunnable(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    unsubscribed.set(true);\r\n                    t.interrupt();\r\n                    latch.countDown();\r\n                }\r\n            }));\r\n            t.start();\r\n        }\r\n    });\r\n    Disposable subscription = s1.subscribe();\r\n    Thread.sleep(100);\r\n    subscription.dispose();\r\n    if (latch.await(1000, TimeUnit.MILLISECONDS)) {\r\n        assertTrue(unsubscribed.get());\r\n        assertTrue(interrupted.get());\r\n    } else {\r\n        fail(\"timed out waiting for latch\");\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.single.SingleTest.testUnsubscribeViaReturnedSubscription",
	"Comment": "assert that unsubscribe propagates when passing in a singleobserver and not a subscriber.",
	"Method": "void testUnsubscribeViaReturnedSubscription(){\r\n    SerialDisposable sd = new SerialDisposable();\r\n    observer.onSubscribe(sd);\r\n    final Thread t = new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                Thread.sleep(5000);\r\n                observer.onSuccess(\"success\");\r\n            } catch (InterruptedException e) {\r\n                interrupted.set(true);\r\n                latch.countDown();\r\n            }\r\n        }\r\n    });\r\n    sd.replace(Disposables.fromRunnable(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            unsubscribed.set(true);\r\n            t.interrupt();\r\n            latch.countDown();\r\n        }\r\n    }));\r\n    t.start();\r\n}"
}, {
	"Path": "io.reactivex.single.SingleTest.testUnsubscribeViaReturnedSubscription",
	"Comment": "assert that unsubscribe propagates when passing in a singleobserver and not a subscriber.",
	"Method": "void testUnsubscribeViaReturnedSubscription(){\r\n    try {\r\n        Thread.sleep(5000);\r\n        observer.onSuccess(\"success\");\r\n    } catch (InterruptedException e) {\r\n        interrupted.set(true);\r\n        latch.countDown();\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.single.SingleTest.testUnsubscribeViaReturnedSubscription",
	"Comment": "assert that unsubscribe propagates when passing in a singleobserver and not a subscriber.",
	"Method": "void testUnsubscribeViaReturnedSubscription(){\r\n    unsubscribed.set(true);\r\n    t.interrupt();\r\n    latch.countDown();\r\n}"
}, {
	"Path": "org.robolectric.shadows.httpclient.FakeHttp.getSentHttpRequestInfo",
	"Comment": "accessor to obtain metadata for an http request made during the current test in the order in which they were made.",
	"Method": "HttpRequestInfo getSentHttpRequestInfo(int index){\r\n    return getFakeHttpLayer().getSentHttpRequestInfo(index);\r\n}"
}, {
	"Path": "org.openqa.selenium.remote.http.HttpMessage.consumeContentStream",
	"Comment": "get the underlying content stream, bypassing the caching mechanisms that allow it to be readagain.",
	"Method": "InputStream consumeContentStream(){\r\n    return content;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableReplay.createFrom",
	"Comment": "creates a replaying connectableobservable with an unbounded buffer.",
	"Method": "ConnectableFlowable<T> createFrom(Flowable<? extends T> source){\r\n    return create(source, DEFAULT_UNBOUNDED_FACTORY);\r\n}"
}, {
	"Path": "com.vondear.rxfeature.module.scaner.CameraConfigurationManager.initFromCameraParameters",
	"Comment": "reads, one time, values from the camera that are needed by the app.",
	"Method": "void initFromCameraParameters(Camera camera){\r\n    Camera.Parameters parameters = camera.getParameters();\r\n    previewFormat = parameters.getPreviewFormat();\r\n    previewFormatString = parameters.get(\"preview-format\");\r\n    Log.d(TAG, \"Default preview format: \" + previewFormat + '/' + previewFormatString);\r\n    WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\r\n    Display display = manager.getDefaultDisplay();\r\n    screenResolution = new Point(display.getWidth(), display.getHeight());\r\n    Log.d(TAG, \"Screen resolution: \" + screenResolution);\r\n    Point screenResolutionForCamera = new Point();\r\n    screenResolutionForCamera.x = screenResolution.x;\r\n    screenResolutionForCamera.y = screenResolution.y;\r\n    if (screenResolution.x < screenResolution.y) {\r\n        screenResolutionForCamera.x = screenResolution.y;\r\n        screenResolutionForCamera.y = screenResolution.x;\r\n    }\r\n    Log.i(\"#########\", \"screenX:\" + screenResolutionForCamera.x + \"   screenY:\" + screenResolutionForCamera.y);\r\n    cameraResolution = getCameraResolution(parameters, screenResolutionForCamera);\r\n    Log.d(TAG, \"Camera resolution: \" + screenResolution);\r\n}"
}, {
	"Path": "org.robolectric.RuntimeEnvironment.getQualifiers",
	"Comment": "returns a qualifier string describing the given configuration and display metrics.",
	"Method": "String getQualifiers(String getQualifiers,Configuration configuration,DisplayMetrics displayMetrics){\r\n    return ConfigurationV25.resourceQualifierString(configuration, displayMetrics);\r\n}"
}, {
	"Path": "org.robolectric.shadows.httpclient.DefaultRequestDirector.createTunnelToProxy",
	"Comment": "creates a tunnel to an intermediate proxy.this method is not implemented in this class.it just throws an exception here.",
	"Method": "boolean createTunnelToProxy(HttpRoute route,int hop,HttpContext context){\r\n    throw new UnsupportedOperationException(\"Proxy chains are not supported.\");\r\n}"
}, {
	"Path": "io.reactivex.observers.BaseTestConsumer.fail",
	"Comment": "fail with the given message and add the sequence of errors as suppressed ones.note this is deliberately the only fail method. most of the times an assertionwould fail but it is possible it was due to an exception somewhere. this constructwill capture those potential errors and report it along with the original failure.",
	"Method": "AssertionError fail(String message){\r\n    StringBuilder b = new StringBuilder(64 + message.length());\r\n    b.append(message);\r\n    b.append(\" (\").append(\"latch = \").append(done.getCount()).append(\", \").append(\"values = \").append(values.size()).append(\", \").append(\"errors = \").append(errors.size()).append(\", \").append(\"completions = \").append(completions);\r\n    if (timeout) {\r\n        b.append(\", timeout!\");\r\n    }\r\n    if (isDisposed()) {\r\n        b.append(\", disposed!\");\r\n    }\r\n    CharSequence tag = this.tag;\r\n    if (tag != null) {\r\n        b.append(\", tag = \").append(tag);\r\n    }\r\n    b.append(')');\r\n    AssertionError ae = new AssertionError(b.toString());\r\n    if (!errors.isEmpty()) {\r\n        if (errors.size() == 1) {\r\n            ae.initCause(errors.get(0));\r\n        } else {\r\n            CompositeException ce = new CompositeException(errors);\r\n            ae.initCause(ce);\r\n        }\r\n    }\r\n    return ae;\r\n}"
}, {
	"Path": "io.reactivex.disposables.CompositeDisposable.clear",
	"Comment": "atomically clears the container, then disposes all the previously contained disposables.",
	"Method": "void clear(){\r\n    if (disposed) {\r\n        return;\r\n    }\r\n    OpenHashSet<Disposable> set;\r\n    synchronized (this) {\r\n        if (disposed) {\r\n            return;\r\n        }\r\n        set = resources;\r\n        resources = null;\r\n    }\r\n    dispose(set);\r\n}"
}, {
	"Path": "io.reactivex.internal.util.AppendOnlyLinkedArrayList.accept",
	"Comment": "interprets the contents as notificationlite objects and callsthe appropriate observer method.",
	"Method": "boolean accept(Subscriber<? super U> subscriber,boolean accept,Observer<? super U> observer){\r\n    Object[] a = head;\r\n    final int c = capacity;\r\n    while (a != null) {\r\n        for (int i = 0; i < c; i++) {\r\n            Object o = a[i];\r\n            if (o == null) {\r\n                break;\r\n            }\r\n            if (NotificationLite.acceptFull(o, observer)) {\r\n                return true;\r\n            }\r\n        }\r\n        a = (Object[]) a[c];\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.reactivex.processors.PublishProcessor.remove",
	"Comment": "atomically removes the given subscriber if it is subscribed to this processor.",
	"Method": "void remove(PublishSubscription<T> ps){\r\n    for (; ; ) {\r\n        PublishSubscription<T>[] a = subscribers.get();\r\n        if (a == TERMINATED || a == EMPTY) {\r\n            return;\r\n        }\r\n        int n = a.length;\r\n        int j = -1;\r\n        for (int i = 0; i < n; i++) {\r\n            if (a[i] == ps) {\r\n                j = i;\r\n                break;\r\n            }\r\n        }\r\n        if (j < 0) {\r\n            return;\r\n        }\r\n        PublishSubscription<T>[] b;\r\n        if (n == 1) {\r\n            b = EMPTY;\r\n        } else {\r\n            b = new PublishSubscription[n - 1];\r\n            System.arraycopy(a, 0, b, 0, j);\r\n            System.arraycopy(a, j + 1, b, j, n - j - 1);\r\n        }\r\n        if (subscribers.compareAndSet(a, b)) {\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableCache.replay",
	"Comment": "replays the contents of this cache to the given consumer based on itscurrent state and number of items requested by it.",
	"Method": "void replay(CacheDisposable<T> consumer){\r\n    if (consumer.getAndIncrement() != 0) {\r\n        return;\r\n    }\r\n    int missed = 1;\r\n    long index = consumer.index;\r\n    int offset = consumer.offset;\r\n    Node<T> node = consumer.node;\r\n    Observer<? super T> downstream = consumer.downstream;\r\n    int capacity = capacityHint;\r\n    for (; ; ) {\r\n        if (consumer.disposed) {\r\n            consumer.node = null;\r\n            return;\r\n        }\r\n        boolean sourceDone = done;\r\n        boolean empty = size == index;\r\n        if (sourceDone && empty) {\r\n            consumer.node = null;\r\n            Throwable ex = error;\r\n            if (ex != null) {\r\n                downstream.onError(ex);\r\n            } else {\r\n                downstream.onComplete();\r\n            }\r\n            return;\r\n        }\r\n        if (!empty) {\r\n            if (offset == capacity) {\r\n                node = node.next;\r\n                offset = 0;\r\n            }\r\n            downstream.onNext(node.values[offset]);\r\n            offset++;\r\n            index++;\r\n            continue;\r\n        }\r\n        consumer.index = index;\r\n        consumer.offset = offset;\r\n        consumer.node = node;\r\n        missed = consumer.addAndGet(-missed);\r\n        if (missed == 0) {\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowTrace.getPreviousSections",
	"Comment": "returns a queue of all the previously active trace sections.",
	"Method": "Queue<String> getPreviousSections(){\r\n    synchronized (lock) {\r\n        return new ArrayDeque(previousSections);\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.internal.schedulers.NewThreadWorker.scheduleDirect",
	"Comment": "schedules the given runnable on the underlying executor directly andreturns its future wrapped into a disposable.",
	"Method": "Disposable scheduleDirect(Runnable run,long delayTime,TimeUnit unit){\r\n    ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run));\r\n    try {\r\n        Future<?> f;\r\n        if (delayTime <= 0L) {\r\n            f = executor.submit(task);\r\n        } else {\r\n            f = executor.schedule(task, delayTime, unit);\r\n        }\r\n        task.setFuture(f);\r\n        return task;\r\n    } catch (RejectedExecutionException ex) {\r\n        RxJavaPlugins.onError(ex);\r\n        return EmptyDisposable.INSTANCE;\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowViewTest.checkedClick_withA11yChecksAnnotation_shouldThrow",
	"Comment": "this test will throw an exception because the accessibility checks depend on theandroidsupport library. if the support library is included at some point, a single test fromaccessibilityutiltest could be moved here to make sure the accessibility checking is run.",
	"Method": "void checkedClick_withA11yChecksAnnotation_shouldThrow(){\r\n    shadowOf(view).checkedPerformClick();\r\n}"
}, {
	"Path": "org.openqa.selenium.logging.LocalLogs.getCombinedLogsHolder",
	"Comment": "see documentation of compositelocallogs about the difference between the firstlocallogs instance and the second one.",
	"Method": "LocalLogs getCombinedLogsHolder(LocalLogs predefinedTypeLogger,LocalLogs allTypesLogger){\r\n    return new CompositeLocalLogs(predefinedTypeLogger, allTypesLogger);\r\n}"
}, {
	"Path": "org.robolectric.res.FileFsFile.from",
	"Comment": "construct an filefsfile from a series of path components. path components that arenull or empty string will be ignored.",
	"Method": "FileFsFile from(String paths){\r\n    File file = null;\r\n    for (String path : paths) {\r\n        if (path != null && path.length() > 0) {\r\n            for (String part : path.split(Pattern.quote(FILE_SEPARATOR), 0)) {\r\n                if (file != null && part.equals(\".\"))\r\n                    continue;\r\n                file = (file == null) ? new File(part) : new File(file, part);\r\n            }\r\n        }\r\n    }\r\n    return new FileFsFile(file);\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowAppWidgetManager.createWidgets",
	"Comment": "creates a bunch of widgets by inflating the same layout multiple times.",
	"Method": "int[] createWidgets(Class<? extends AppWidgetProvider> appWidgetProviderClass,int widgetLayoutId,int howManyToCreate){\r\n    AppWidgetProvider appWidgetProvider = ReflectionHelpers.callConstructor(appWidgetProviderClass);\r\n    int[] newWidgetIds = new int[howManyToCreate];\r\n    for (int i = 0; i < howManyToCreate; i++) {\r\n        View widgetView = createWidgetView(widgetLayoutId);\r\n        int myWidgetId = nextWidgetId++;\r\n        widgetInfos.put(myWidgetId, new WidgetInfo(widgetView, widgetLayoutId, appWidgetProvider));\r\n        newWidgetIds[i] = myWidgetId;\r\n    }\r\n    appWidgetProvider.onUpdate(context, realAppWidgetManager, newWidgetIds);\r\n    return newWidgetIds;\r\n}"
}, {
	"Path": "io.reactivex.flowable.FlowableErrorHandlingTests.testOnNextError",
	"Comment": "test that an error from a user provided observer.onnextis handled and emitted to the onerror.",
	"Method": "void testOnNextError(){\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    final AtomicReference<Throwable> caughtError = new AtomicReference<Throwable>();\r\n    Flowable<Long> f = Flowable.interval(50, TimeUnit.MILLISECONDS);\r\n    Subscriber<Long> subscriber = new DefaultSubscriber<Long>() {\r\n        @Override\r\n        public void onComplete() {\r\n            System.out.println(\"completed\");\r\n            latch.countDown();\r\n        }\r\n        @Override\r\n        public void onError(Throwable e) {\r\n            System.out.println(\"error: \" + e);\r\n            caughtError.set(e);\r\n            latch.countDown();\r\n        }\r\n        @Override\r\n        public void onNext(Long args) {\r\n            throw new RuntimeException(\"forced failure\");\r\n        }\r\n    };\r\n    f.safeSubscribe(subscriber);\r\n    latch.await(2000, TimeUnit.MILLISECONDS);\r\n    assertNotNull(caughtError.get());\r\n}"
}, {
	"Path": "io.reactivex.flowable.FlowableErrorHandlingTests.testOnNextError",
	"Comment": "test that an error from a user provided observer.onnextis handled and emitted to the onerror.",
	"Method": "void testOnNextError(){\r\n    System.out.println(\"completed\");\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.reactivex.flowable.FlowableErrorHandlingTests.testOnNextError",
	"Comment": "test that an error from a user provided observer.onnextis handled and emitted to the onerror.",
	"Method": "void testOnNextError(){\r\n    System.out.println(\"error: \" + e);\r\n    caughtError.set(e);\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.reactivex.flowable.FlowableErrorHandlingTests.testOnNextError",
	"Comment": "test that an error from a user provided observer.onnextis handled and emitted to the onerror.",
	"Method": "void testOnNextError(){\r\n    throw new RuntimeException(\"forced failure\");\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.setBitmapDecoderClass",
	"Comment": "swap the default bitmap decoder implementation for one of your own. you must do this before setting the image file orasset, and you cannot use a custom decoder when using layout xml to set an asset name. your class must have apublic default constructor.",
	"Method": "void setBitmapDecoderClass(Class<? extends ImageDecoder> bitmapDecoderClass){\r\n    if (bitmapDecoderClass == null) {\r\n        throw new IllegalArgumentException(\"Decoder class cannot be set to null\");\r\n    }\r\n    this.bitmapDecoderFactory = new CompatDecoderFactory(bitmapDecoderClass);\r\n}"
}, {
	"Path": "io.reactivex.internal.disposables.ArrayCompositeDisposable.setResource",
	"Comment": "sets the resource at the specified index and disposes the old resource.",
	"Method": "boolean setResource(int index,Disposable resource){\r\n    for (; ; ) {\r\n        Disposable o = get(index);\r\n        if (o == DisposableHelper.DISPOSED) {\r\n            resource.dispose();\r\n            return false;\r\n        }\r\n        if (compareAndSet(index, o, resource)) {\r\n            if (o != null) {\r\n                o.dispose();\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vondear.rxui.view.wheelhorizontal.AbstractWheel.rebuildItems",
	"Comment": "rebuilds spinnerwheel items if necessary. caches all unused items.",
	"Method": "boolean rebuildItems(){\r\n    boolean updated;\r\n    ItemsRange range = getItemsRange();\r\n    if (mItemsLayout != null) {\r\n        int first = mRecycler.recycleItems(mItemsLayout, mFirstItemIdx, range);\r\n        updated = mFirstItemIdx != first;\r\n        mFirstItemIdx = first;\r\n    } else {\r\n        createItemsLayout();\r\n        updated = true;\r\n    }\r\n    if (!updated) {\r\n        updated = mFirstItemIdx != range.getFirst() || mItemsLayout.getChildCount() != range.getCount();\r\n    }\r\n    if (mFirstItemIdx > range.getFirst() && mFirstItemIdx <= range.getLast()) {\r\n        for (int i = mFirstItemIdx - 1; i >= range.getFirst(); i--) {\r\n            if (!addItemView(i, true)) {\r\n                break;\r\n            }\r\n            mFirstItemIdx = i;\r\n        }\r\n    } else {\r\n        mFirstItemIdx = range.getFirst();\r\n    }\r\n    int first = mFirstItemIdx;\r\n    for (int i = mItemsLayout.getChildCount(); i < range.getCount(); i++) {\r\n        if (!addItemView(mFirstItemIdx + i, false) && mItemsLayout.getChildCount() == 0) {\r\n            first++;\r\n        }\r\n    }\r\n    mFirstItemIdx = first;\r\n    return updated;\r\n}"
}, {
	"Path": "com.github.scribejava.core.builder.api.DefaultApi20.getAuthorizationUrl",
	"Comment": "returns the url where you should redirect your users to authenticate your application.",
	"Method": "String getAuthorizationUrl(String responseType,String apiKey,String callback,String scope,String state,Map<String, String> additionalParams){\r\n    final ParameterList parameters = new ParameterList(additionalParams);\r\n    parameters.add(OAuthConstants.RESPONSE_TYPE, responseType);\r\n    parameters.add(OAuthConstants.CLIENT_ID, apiKey);\r\n    if (callback != null) {\r\n        parameters.add(OAuthConstants.REDIRECT_URI, callback);\r\n    }\r\n    if (scope != null) {\r\n        parameters.add(OAuthConstants.SCOPE, scope);\r\n    }\r\n    if (state != null) {\r\n        parameters.add(OAuthConstants.STATE, state);\r\n    }\r\n    return parameters.appendTo(getAuthorizationBaseUrl());\r\n}"
}, {
	"Path": "io.reactivex.subjects.CompletableSubject.hasComplete",
	"Comment": "returns true if this completablesubject has been completed.",
	"Method": "boolean hasComplete(){\r\n    return observers.get() == TERMINATED && error == null;\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.onSizeChanged",
	"Comment": "on resize, preserve center and scale. various behaviours are possible, override this method to use another.",
	"Method": "void onSizeChanged(int w,int h,int oldw,int oldh){\r\n    debug(\"onSizeChanged %dx%d -> %dx%d\", oldw, oldh, w, h);\r\n    PointF sCenter = getCenter();\r\n    if (readySent && sCenter != null) {\r\n        this.anim = null;\r\n        this.pendingScale = scale;\r\n        this.sPendingCenter = sCenter;\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.elementToBeSelected",
	"Comment": "an expectation for checking if the given element is selected.",
	"Method": "ExpectedCondition<Boolean> elementToBeSelected(WebElement element,ExpectedCondition<Boolean> elementToBeSelected,By locator){\r\n    return elementSelectionStateToBe(locator, true);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.invisibilityOfElementLocated",
	"Comment": "an expectation for checking that an element is either invisible or not present on the dom.",
	"Method": "ExpectedCondition<Boolean> invisibilityOfElementLocated(By locator){\r\n    return new ExpectedCondition<Boolean>() {\r\n        @Override\r\n        public Boolean apply(WebDriver driver) {\r\n            try {\r\n                return !(driver.findElement(locator).isDisplayed());\r\n            } catch (NoSuchElementException e) {\r\n                return true;\r\n            } catch (StaleElementReferenceException e) {\r\n                return true;\r\n            }\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"element to no longer be visible: \" + locator;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.invisibilityOfElementLocated",
	"Comment": "an expectation for checking that an element is either invisible or not present on the dom.",
	"Method": "ExpectedCondition<Boolean> invisibilityOfElementLocated(By locator){\r\n    try {\r\n        return !(driver.findElement(locator).isDisplayed());\r\n    } catch (NoSuchElementException e) {\r\n        return true;\r\n    } catch (StaleElementReferenceException e) {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.invisibilityOfElementLocated",
	"Comment": "an expectation for checking that an element is either invisible or not present on the dom.",
	"Method": "ExpectedCondition<Boolean> invisibilityOfElementLocated(By locator){\r\n    return \"element to no longer be visible: \" + locator;\r\n}"
}, {
	"Path": "org.robolectric.Robolectric.flushBackgroundThreadScheduler",
	"Comment": "execute all runnables that have been enqueued on the background scheduler.",
	"Method": "void flushBackgroundThreadScheduler(){\r\n    getBackgroundThreadScheduler().advanceToLastPostedRunnable();\r\n}"
}, {
	"Path": "io.reactivex.internal.functions.Functions.naturalOrder",
	"Comment": "returns a natural order comparator which casts the parameters to comparable.",
	"Method": "Comparator<T> naturalOrder(){\r\n    return (Comparator<T>) NATURAL_COMPARATOR;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableMergeTest.testError2",
	"Comment": "unit test from operationmergedelayerror backported here to show how these use cases work with normal merge.",
	"Method": "void testError2(){\r\n    final Flowable<String> f1 = Flowable.unsafeCreate(new TestErrorFlowable(\"one\", \"two\", \"three\"));\r\n    final Flowable<String> f2 = Flowable.unsafeCreate(new TestErrorFlowable(\"four\", null, \"six\"));\r\n    final Flowable<String> f3 = Flowable.unsafeCreate(new TestErrorFlowable(\"seven\", \"eight\", null));\r\n    final Flowable<String> f4 = Flowable.unsafeCreate(new TestErrorFlowable(\"nine\"));\r\n    Flowable<String> m = Flowable.merge(f1, f2, f3, f4);\r\n    m.subscribe(stringSubscriber);\r\n    verify(stringSubscriber, times(1)).onError(any(NullPointerException.class));\r\n    verify(stringSubscriber, never()).onComplete();\r\n    verify(stringSubscriber, times(1)).onNext(\"one\");\r\n    verify(stringSubscriber, times(1)).onNext(\"two\");\r\n    verify(stringSubscriber, times(1)).onNext(\"three\");\r\n    verify(stringSubscriber, times(1)).onNext(\"four\");\r\n    verify(stringSubscriber, times(0)).onNext(\"five\");\r\n    verify(stringSubscriber, times(0)).onNext(\"six\");\r\n    verify(stringSubscriber, times(0)).onNext(\"seven\");\r\n    verify(stringSubscriber, times(0)).onNext(\"eight\");\r\n    verify(stringSubscriber, times(0)).onNext(\"nine\");\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableMergeTest.testError1",
	"Comment": "unit test from operationmergedelayerror backported here to show how these use cases work with normal merge.",
	"Method": "void testError1(){\r\n    final Flowable<String> f1 = Flowable.unsafeCreate(new TestErrorFlowable(\"four\", null, \"six\"));\r\n    final Flowable<String> f2 = Flowable.unsafeCreate(new TestErrorFlowable(\"one\", \"two\", \"three\"));\r\n    Flowable<String> m = Flowable.merge(f1, f2);\r\n    m.subscribe(stringSubscriber);\r\n    verify(stringSubscriber, times(1)).onError(any(NullPointerException.class));\r\n    verify(stringSubscriber, never()).onComplete();\r\n    verify(stringSubscriber, times(0)).onNext(\"one\");\r\n    verify(stringSubscriber, times(0)).onNext(\"two\");\r\n    verify(stringSubscriber, times(0)).onNext(\"three\");\r\n    verify(stringSubscriber, times(1)).onNext(\"four\");\r\n    verify(stringSubscriber, times(0)).onNext(\"five\");\r\n    verify(stringSubscriber, times(0)).onNext(\"six\");\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.getRequiredRotation",
	"Comment": "determines the rotation to be applied to tiles, based on exif orientation or chosen setting.",
	"Method": "int getRequiredRotation(){\r\n    if (orientation == ORIENTATION_USE_EXIF) {\r\n        return sOrientation;\r\n    } else {\r\n        return orientation;\r\n    }\r\n}"
}, {
	"Path": "io.reactivex.validators.MaybeNo2Dot0Since.findSource",
	"Comment": "given a base reactive type name, try to find its source in the current runtimepath and return a file to it or null if not found.",
	"Method": "File findSource(String baseClassName){\r\n    URL u = MaybeNo2Dot0Since.class.getResource(MaybeNo2Dot0Since.class.getSimpleName() + \".class\");\r\n    String path = new File(u.toURI()).toString().replace('\\\\', '/');\r\n    int i = path.indexOf(\"/RxJava\");\r\n    if (i < 0) {\r\n        System.out.println(\"Can't find the base RxJava directory\");\r\n        return null;\r\n    }\r\n    int j = path.indexOf(\"/\", i + 6);\r\n    String p = path.substring(0, j + 1) + \"src/main/java/io/reactivex/\" + baseClassName + \".java\";\r\n    File f = new File(p);\r\n    if (!f.canRead()) {\r\n        System.out.println(\"Can't read \" + p);\r\n        return null;\r\n    }\r\n    return f;\r\n}"
}, {
	"Path": "com.thoughtworks.selenium.BrowserConfigurationOptions.set",
	"Comment": "sets the given key to the given value unless the value is null. in that case, no entry for thekey is made.",
	"Method": "BrowserConfigurationOptions set(String key,String value){\r\n    if (value != null) {\r\n        options.put(key, value);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowUsbManager.hasPermissionForPackage",
	"Comment": "returns true if the given package has permission to access the device.",
	"Method": "boolean hasPermissionForPackage(UsbDevice device,String packageName){\r\n    List<UsbDevice> usbDevices = grantedPermissions.get(packageName);\r\n    return usbDevices != null && usbDevices.contains(device);\r\n}"
}, {
	"Path": "io.reactivex.subjects.AsyncSubject.remove",
	"Comment": "atomically removes the given subscriber if it is subscribed to the subject.",
	"Method": "void remove(AsyncDisposable<T> ps){\r\n    for (; ; ) {\r\n        AsyncDisposable<T>[] a = subscribers.get();\r\n        int n = a.length;\r\n        if (n == 0) {\r\n            return;\r\n        }\r\n        int j = -1;\r\n        for (int i = 0; i < n; i++) {\r\n            if (a[i] == ps) {\r\n                j = i;\r\n                break;\r\n            }\r\n        }\r\n        if (j < 0) {\r\n            return;\r\n        }\r\n        AsyncDisposable<T>[] b;\r\n        if (n == 1) {\r\n            b = EMPTY;\r\n        } else {\r\n            b = new AsyncDisposable[n - 1];\r\n            System.arraycopy(a, 0, b, 0, j);\r\n            System.arraycopy(a, j + 1, b, j, n - j - 1);\r\n        }\r\n        if (subscribers.compareAndSet(a, b)) {\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowApplicationPackageManager.getUserBadgedIcon",
	"Comment": "adds a profile badge to the icon.this implementation just returns the unbadged icon, as some default implementations add aninternal resource to the icon that is unavailable to robolectric.",
	"Method": "Drawable getUserBadgedIcon(Drawable icon,UserHandle user){\r\n    return icon;\r\n}"
}, {
	"Path": "io.reactivex.internal.subscriptions.AsyncSubscription.replaceResource",
	"Comment": "replaces the currently held resource with the given new one without disposing the old.",
	"Method": "boolean replaceResource(Disposable r){\r\n    return DisposableHelper.replace(resource, r);\r\n}"
}, {
	"Path": "retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory.create",
	"Comment": "returns an instance which creates synchronous observables that do not operate on any schedulerby default.",
	"Method": "RxJava2CallAdapterFactory create(){\r\n    return new RxJava2CallAdapterFactory(null, false);\r\n}"
}, {
	"Path": "org.robolectric.RuntimeEnvironment.getMainThread",
	"Comment": "retrieves the main thread. the main thread is the thread to which the main looper is attached.defaults to the thread that initialises the runtimeenvironment class.",
	"Method": "Thread getMainThread(){\r\n    return mainThread;\r\n}"
}, {
	"Path": "org.robolectric.manifest.BroadcastReceiverData.isExported",
	"Comment": "returns whether this broadcast receiver is exported by checking the xml attribute.",
	"Method": "boolean isExported(){\r\n    boolean defaultValue = !intentFilters.isEmpty();\r\n    return (attributes.containsKey(EXPORTED) ? Boolean.parseBoolean(attributes.get(EXPORTED)) : defaultValue);\r\n}"
}, {
	"Path": "org.robolectric.android.XmlResourceParserImpl.navigateToNextNode",
	"Comment": "navigate to the next node after a node and all of hischildren have been explored.if the node has unexplored siblings navigate to thenext sibling. otherwise return to its parent.",
	"Method": "int navigateToNextNode(Node node){\r\n    Node nextNode = node.getNextSibling();\r\n    if (nextNode != null) {\r\n        return processNextNodeType(nextNode);\r\n    } else {\r\n        if (document.getDocumentElement().equals(node)) {\r\n            currentNode = null;\r\n            return END_DOCUMENT;\r\n        }\r\n        currentNode = node.getParentNode();\r\n        return END_TAG;\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowApplicationPackageManager.hasProfileOwnerOrDeviceOwnerOnCurrentUser",
	"Comment": "returns whether the current user profile has a profile owner or a device owner.",
	"Method": "boolean hasProfileOwnerOrDeviceOwnerOnCurrentUser(){\r\n    DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);\r\n    return devicePolicyManager.getProfileOwner() != null || (UserHandle.of(UserHandle.myUserId()).isSystem() && devicePolicyManager.getDeviceOwner() != null);\r\n}"
}, {
	"Path": "org.openqa.selenium.remote.service.DriverService.isRunning",
	"Comment": "checks whether the driver child process is currently running.",
	"Method": "boolean isRunning(){\r\n    lock.lock();\r\n    try {\r\n        return process != null && process.isRunning();\r\n    } catch (IllegalThreadStateException e) {\r\n        return true;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.visibilityOf",
	"Comment": "an expectation for checking that an element, known to be present on the dom of a page, isvisible. visibility means that the element is not only displayed but also has a height andwidth that is greater than 0.",
	"Method": "ExpectedCondition<WebElement> visibilityOf(WebElement element){\r\n    return new ExpectedCondition<WebElement>() {\r\n        @Override\r\n        public WebElement apply(WebDriver driver) {\r\n            return elementIfVisible(element);\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"visibility of \" + element;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.visibilityOf",
	"Comment": "an expectation for checking that an element, known to be present on the dom of a page, isvisible. visibility means that the element is not only displayed but also has a height andwidth that is greater than 0.",
	"Method": "ExpectedCondition<WebElement> visibilityOf(WebElement element){\r\n    return elementIfVisible(element);\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.visibilityOf",
	"Comment": "an expectation for checking that an element, known to be present on the dom of a page, isvisible. visibility means that the element is not only displayed but also has a height andwidth that is greater than 0.",
	"Method": "ExpectedCondition<WebElement> visibilityOf(WebElement element){\r\n    return \"visibility of \" + element;\r\n}"
}, {
	"Path": "org.openqa.selenium.Proxy.setSocksPassword",
	"Comment": "specifies a password for the socks proxy. supported by socks v5 and above.",
	"Method": "Proxy setSocksPassword(String password){\r\n    verifyProxyTypeCompatibility(ProxyType.MANUAL);\r\n    this.proxyType = ProxyType.MANUAL;\r\n    this.socksPassword = password;\r\n    return this;\r\n}"
}, {
	"Path": "org.robolectric.res.ResourceTableFactory.newResourceTable",
	"Comment": "creates an application resource table which can be constructed with multiple resources pathsrepresenting overlayed resource libraries.",
	"Method": "PackageResourceTable newResourceTable(String packageName,ResourcePath resourcePaths){\r\n    return PerfStatsCollector.getInstance().measure(\"load legacy app resources\", () -> {\r\n        PackageResourceTable resourceTable = new PackageResourceTable(packageName);\r\n        for (ResourcePath resourcePath : resourcePaths) {\r\n            if (resourcePath.getRClass() != null) {\r\n                addRClassValues(resourceTable, resourcePath.getRClass());\r\n            }\r\n        }\r\n        for (ResourcePath resourcePath : resourcePaths) {\r\n            parseResourceFiles(resourcePath, resourceTable);\r\n        }\r\n        return resourceTable;\r\n    });\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.numberOfElementsToBe",
	"Comment": "an expectation for checking number of webelements with given locator",
	"Method": "ExpectedCondition<List<WebElement>> numberOfElementsToBe(By locator,Integer number){\r\n    return new ExpectedCondition<List<WebElement>>() {\r\n        private Integer currentNumber = 0;\r\n        @Override\r\n        public List<WebElement> apply(WebDriver webDriver) {\r\n            List<WebElement> elements = webDriver.findElements(locator);\r\n            currentNumber = elements.size();\r\n            return currentNumber.equals(number) ? elements : null;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"number of elements found by %s to be \\\"%s\\\". Current number: \\\"%s\\\"\", locator, number, currentNumber);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.numberOfElementsToBe",
	"Comment": "an expectation for checking number of webelements with given locator",
	"Method": "ExpectedCondition<List<WebElement>> numberOfElementsToBe(By locator,Integer number){\r\n    List<WebElement> elements = webDriver.findElements(locator);\r\n    currentNumber = elements.size();\r\n    return currentNumber.equals(number) ? elements : null;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.ExpectedConditions.numberOfElementsToBe",
	"Comment": "an expectation for checking number of webelements with given locator",
	"Method": "ExpectedCondition<List<WebElement>> numberOfElementsToBe(By locator,Integer number){\r\n    return String.format(\"number of elements found by %s to be \\\"%s\\\". Current number: \\\"%s\\\"\", locator, number, currentNumber);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowablePublish.create",
	"Comment": "creates a operatorpublish instance to publish values of the given source observable.",
	"Method": "ConnectableFlowable<T> create(Flowable<T> source,int bufferSize){\r\n    final AtomicReference<PublishSubscriber<T>> curr = new AtomicReference<PublishSubscriber<T>>();\r\n    Publisher<T> onSubscribe = new FlowablePublisher<T>(curr, bufferSize);\r\n    return RxJavaPlugins.onAssembly(new FlowablePublish<T>(onSubscribe, source, curr, bufferSize));\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    final AtomicInteger eventCounter = new AtomicInteger();\r\n    final AtomicInteger subscribeCounter = new AtomicInteger();\r\n    final AtomicInteger groupCounter = new AtomicInteger();\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    final int count = 100;\r\n    final int groupCount = 2;\r\n    Flowable<Event> es = Flowable.unsafeCreate(new Publisher<Event>() {\r\n        @Override\r\n        public void subscribe(final Subscriber<? super Event> subscriber) {\r\n            subscriber.onSubscribe(new BooleanSubscription());\r\n            System.out.println(\"*** Subscribing to EventStream ***\");\r\n            subscribeCounter.incrementAndGet();\r\n            new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    for (int i = 0; i < count; i++) {\r\n                        Event e = new Event();\r\n                        e.source = i % groupCount;\r\n                        e.message = \"Event-\" + i;\r\n                        subscriber.onNext(e);\r\n                    }\r\n                    subscriber.onComplete();\r\n                }\r\n            }).start();\r\n        }\r\n    });\r\n    es.groupBy(new Function<Event, Integer>() {\r\n        @Override\r\n        public Integer apply(Event e) {\r\n            return e.source;\r\n        }\r\n    }).flatMap(new Function<GroupedFlowable<Integer, Event>, Flowable<String>>() {\r\n        @Override\r\n        public Flowable<String> apply(GroupedFlowable<Integer, Event> eventGroupedFlowable) {\r\n            System.out.println(\"GroupedFlowable Key: \" + eventGroupedFlowable.getKey());\r\n            groupCounter.incrementAndGet();\r\n            return eventGroupedFlowable.map(new Function<Event, String>() {\r\n                @Override\r\n                public String apply(Event event) {\r\n                    return \"Source: \" + event.source + \"  Message: \" + event.message;\r\n                }\r\n            });\r\n        }\r\n    }).subscribe(new DefaultSubscriber<String>() {\r\n        @Override\r\n        public void onComplete() {\r\n            latch.countDown();\r\n        }\r\n        @Override\r\n        public void onError(Throwable e) {\r\n            e.printStackTrace();\r\n            latch.countDown();\r\n        }\r\n        @Override\r\n        public void onNext(String outputMessage) {\r\n            System.out.println(outputMessage);\r\n            eventCounter.incrementAndGet();\r\n        }\r\n    });\r\n    latch.await(5000, TimeUnit.MILLISECONDS);\r\n    assertEquals(1, subscribeCounter.get());\r\n    assertEquals(groupCount, groupCounter.get());\r\n    assertEquals(count, eventCounter.get());\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    subscriber.onSubscribe(new BooleanSubscription());\r\n    System.out.println(\"*** Subscribing to EventStream ***\");\r\n    subscribeCounter.incrementAndGet();\r\n    new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            for (int i = 0; i < count; i++) {\r\n                Event e = new Event();\r\n                e.source = i % groupCount;\r\n                e.message = \"Event-\" + i;\r\n                subscriber.onNext(e);\r\n            }\r\n            subscriber.onComplete();\r\n        }\r\n    }).start();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    for (int i = 0; i < count; i++) {\r\n        Event e = new Event();\r\n        e.source = i % groupCount;\r\n        e.message = \"Event-\" + i;\r\n        subscriber.onNext(e);\r\n    }\r\n    subscriber.onComplete();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    return e.source;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    System.out.println(\"GroupedFlowable Key: \" + eventGroupedFlowable.getKey());\r\n    groupCounter.incrementAndGet();\r\n    return eventGroupedFlowable.map(new Function<Event, String>() {\r\n        @Override\r\n        public String apply(Event event) {\r\n            return \"Source: \" + event.source + \"  Message: \" + event.message;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    return \"Source: \" + event.source + \"  Message: \" + event.message;\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    e.printStackTrace();\r\n    latch.countDown();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableGroupByTest.testGroupedEventStream",
	"Comment": "assert that only a single subscription to a stream occurs and that all events are received.",
	"Method": "void testGroupedEventStream(){\r\n    System.out.println(outputMessage);\r\n    eventCounter.incrementAndGet();\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.FluentWait.ignoreAll",
	"Comment": "configures this instance to ignore specific types of exceptions while waiting for a condition.any exceptions not whitelisted will be allowed to propagate, terminating the wait.",
	"Method": "FluentWait<T> ignoreAll(Collection<Class<? extends K>> types){\r\n    ignoredExceptions.addAll(types);\r\n    return this;\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowSharedPreferencesTest.commit_multipleTimes",
	"Comment": "tests a sequence of operations in sharedprefereces that would previously cause a deadlock.",
	"Method": "void commit_multipleTimes(){\r\n    SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);\r\n    sharedPreferences.edit().putBoolean(\"foo\", true).apply();\r\n    sharedPreferences.edit().putBoolean(\"bar\", true).commit();\r\n    assertTrue(sharedPreferences.getBoolean(\"foo\", false));\r\n    assertTrue(sharedPreferences.getBoolean(\"bar\", false));\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableOnErrorResumeNextViaFunctionTest.testFunctionThrowsError",
	"Comment": "test that when a function throws an exception this is propagated through onerror.",
	"Method": "void testFunctionThrowsError(){\r\n    Subscription s = mock(Subscription.class);\r\n    TestFlowable w = new TestFlowable(s, \"one\");\r\n    Function<Throwable, Flowable<String>> resume = new Function<Throwable, Flowable<String>>() {\r\n        @Override\r\n        public Flowable<String> apply(Throwable t1) {\r\n            throw new RuntimeException(\"exception from function\");\r\n        }\r\n    };\r\n    Flowable<String> flowable = Flowable.unsafeCreate(w).onErrorResumeNext(resume);\r\n    Subscriber<String> subscriber = TestHelper.mockSubscriber();\r\n    flowable.subscribe(subscriber);\r\n    try {\r\n        w.t.join();\r\n    } catch (InterruptedException e) {\r\n        fail(e.getMessage());\r\n    }\r\n    verify(subscriber, times(1)).onNext(\"one\");\r\n    verify(subscriber, times(1)).onError(any(Throwable.class));\r\n    verify(subscriber, times(0)).onComplete();\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.flowable.FlowableOnErrorResumeNextViaFunctionTest.testFunctionThrowsError",
	"Comment": "test that when a function throws an exception this is propagated through onerror.",
	"Method": "void testFunctionThrowsError(){\r\n    throw new RuntimeException(\"exception from function\");\r\n}"
}, {
	"Path": "com.vondear.rxui.view.ticker.RxTickerColumnManager.setText",
	"Comment": "tell the column manager the new target text that it should display.",
	"Method": "void setText(char[] text){\r\n    if (characterList == null) {\r\n        throw new IllegalStateException(\"Need to call setCharacterList(char[]) first.\");\r\n    }\r\n    for (int i = 0; i < mRxTickerColumns.size(); ) {\r\n        final RxTickerColumn rxTickerColumn = mRxTickerColumns.get(i);\r\n        if (rxTickerColumn.getCurrentWidth() > 0) {\r\n            i++;\r\n        } else {\r\n            mRxTickerColumns.remove(i);\r\n        }\r\n    }\r\n    final int[] actions = RxLevenshteinUtils.computeColumnActions(getCurrentText(), text);\r\n    int columnIndex = 0;\r\n    int textIndex = 0;\r\n    for (int i = 0; i < actions.length; i++) {\r\n        switch(actions[i]) {\r\n            case RxLevenshteinUtils.ACTION_INSERT:\r\n                mRxTickerColumns.add(columnIndex, new RxTickerColumn(characterList, characterIndicesMap, metrics));\r\n            case RxLevenshteinUtils.ACTION_SAME:\r\n                mRxTickerColumns.get(columnIndex).setTargetChar(text[textIndex]);\r\n                columnIndex++;\r\n                textIndex++;\r\n                break;\r\n            case RxLevenshteinUtils.ACTION_DELETE:\r\n                mRxTickerColumns.get(columnIndex).setTargetChar(RxTickerUtils.EMPTY_CHAR);\r\n                columnIndex++;\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"Unknown action: \" + actions[i]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vondear.rxui.view.scaleimage.RxScaleImageView.resetScaleAndCenter",
	"Comment": "fully zoom out and return the image to the middle of the screen. this might be useful if you have a view pagerand want images to be reset when the user has moved to another page.",
	"Method": "void resetScaleAndCenter(){\r\n    this.anim = null;\r\n    this.pendingScale = limitedScale(0);\r\n    if (isReady()) {\r\n        this.sPendingCenter = new PointF(sWidth() / 2, sHeight() / 2);\r\n    } else {\r\n        this.sPendingCenter = new PointF(0, 0);\r\n    }\r\n    invalidate();\r\n}"
}, {
	"Path": "com.github.scribejava.core.model.Response.getStream",
	"Comment": "obtains the meaningful stream of the httpurlconnection, either inputstream or errorinputstream, depending on thestatus code",
	"Method": "InputStream getStream(){\r\n    return stream;\r\n}"
}, {
	"Path": "io.reactivex.Notification.getValue",
	"Comment": "returns the contained value if this notification is an onnextsignal, null otherwise.",
	"Method": "T getValue(){\r\n    Object o = value;\r\n    if (o != null && !NotificationLite.isError(o)) {\r\n        return (T) value;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openqa.selenium.support.ui.Select.deselectAll",
	"Comment": "clear all selected entries. this is only valid when the select supports multiple selections.",
	"Method": "void deselectAll(){\r\n    if (!isMultiple()) {\r\n        throw new UnsupportedOperationException(\"You may only deselect all options of a multi-select\");\r\n    }\r\n    for (WebElement option : getOptions()) {\r\n        setSelected(option, false);\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.remote.RemoteWebDriver.log",
	"Comment": "override this to be notified at key points in the execution of a command.",
	"Method": "void log(SessionId sessionId,String commandName,Object toLog,When when){\r\n    if (!logger.isLoggable(level)) {\r\n        return;\r\n    }\r\n    String text = String.valueOf(toLog);\r\n    if (commandName.equals(DriverCommand.EXECUTE_SCRIPT) || commandName.equals(DriverCommand.EXECUTE_ASYNC_SCRIPT)) {\r\n        if (text.length() > 100 && Boolean.getBoolean(\"webdriver.remote.shorten_log_messages\")) {\r\n            text = text.substring(0, 100) + \"...\";\r\n        }\r\n    }\r\n    switch(when) {\r\n        case BEFORE:\r\n            logger.log(level, \"Executing: \" + commandName + \" \" + text);\r\n            break;\r\n        case AFTER:\r\n            logger.log(level, \"Executed: \" + text);\r\n            break;\r\n        case EXCEPTION:\r\n            logger.log(level, \"Exception: \" + text);\r\n            break;\r\n        default:\r\n            logger.log(level, text);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.robolectric.shadows.ShadowPowerManager.getLatestWakeLock",
	"Comment": "retrieves the most recent wakelock registered by the application",
	"Method": "PowerManager.WakeLock getLatestWakeLock(){\r\n    ShadowApplication shadowApplication = Shadow.extract(RuntimeEnvironment.application);\r\n    return shadowApplication.getLatestWakeLock();\r\n}"
}, {
	"Path": "org.robolectric.shadows.httpclient.FakeHttpLayer.getLastHttpResponse",
	"Comment": "helper method that returns the latest received response from the server.",
	"Method": "HttpResponse getLastHttpResponse(){\r\n    if (httpResponses.isEmpty())\r\n        return null;\r\n    return httpResponses.get(httpResponses.size() - 1);\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableGroupByTest.testExceptionIfSubscribeToChildMoreThanOnce",
	"Comment": "assert we get an illegalstateexception if trying to subscribe to an inner groupedobservable more than once.",
	"Method": "void testExceptionIfSubscribeToChildMoreThanOnce(){\r\n    Observable<Integer> source = Observable.just(0);\r\n    final AtomicReference<GroupedObservable<Integer, Integer>> inner = new AtomicReference<GroupedObservable<Integer, Integer>>();\r\n    Observable<GroupedObservable<Integer, Integer>> m = source.groupBy(identity, dbl);\r\n    m.subscribe(new Consumer<GroupedObservable<Integer, Integer>>() {\r\n        @Override\r\n        public void accept(GroupedObservable<Integer, Integer> t1) {\r\n            inner.set(t1);\r\n        }\r\n    });\r\n    inner.get().subscribe();\r\n    Observer<Integer> o2 = TestHelper.mockObserver();\r\n    inner.get().subscribe(o2);\r\n    verify(o2, never()).onComplete();\r\n    verify(o2, never()).onNext(anyInt());\r\n    verify(o2).onError(any(IllegalStateException.class));\r\n}"
}, {
	"Path": "io.reactivex.internal.operators.observable.ObservableGroupByTest.testExceptionIfSubscribeToChildMoreThanOnce",
	"Comment": "assert we get an illegalstateexception if trying to subscribe to an inner groupedobservable more than once.",
	"Method": "void testExceptionIfSubscribeToChildMoreThanOnce(){\r\n    inner.set(t1);\r\n}"
}]