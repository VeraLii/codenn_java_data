[{
	"Path": "spark.resource.ClassPathResource.createRelative",
	"Comment": "this implementation creates a classpathresource, applying the given pathrelative to the path of the underlying resource of this descriptor.",
	"Method": "Resource createRelative(String relativePath){\r\n    String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\r\n    return new ClassPathResource(pathToUse, this.classLoader, this.clazz);\r\n}"
}, {
	"Path": "spark.Service.webSocketIdleTimeoutMillis",
	"Comment": "sets the max idle timeout in milliseconds for websocket connections.",
	"Method": "Service webSocketIdleTimeoutMillis(int timeoutMillis){\r\n    if (initialized) {\r\n        throwBeforeRouteMappingException();\r\n    }\r\n    if (isRunningFromServlet()) {\r\n        throw new IllegalStateException(\"WebSockets are only supported in the embedded server\");\r\n    }\r\n    webSocketIdleTimeoutMillis = Optional.of(timeoutMillis);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.test.autoconfigure.web.servlet.WebDriverScope.registerWith",
	"Comment": "register this scope with the specified context and reassign appropriate bean\tdefinitions to used it.",
	"Method": "void registerWith(ConfigurableApplicationContext context){\r\n    if (!ClassUtils.isPresent(WEB_DRIVER_CLASS, null)) {\r\n        return;\r\n    }\r\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\r\n    if (beanFactory.getRegisteredScope(NAME) == null) {\r\n        beanFactory.registerScope(NAME, new WebDriverScope());\r\n    }\r\n    context.addBeanFactoryPostProcessor(WebDriverScope::postProcessBeanFactory);\r\n}"
}, {
	"Path": "org.b3log.solo.processor.console.AdminConsole.showAdminPreferenceFunction",
	"Comment": "shows administrator preference function with the specified context.",
	"Method": "void showAdminPreferenceFunction(HTTPRequestContext context){\r\n    final AbstractFreeMarkerRenderer renderer = new ConsoleRenderer();\r\n    context.setRenderer(renderer);\r\n    final String templateName = \"admin-preference.ftl\";\r\n    renderer.setTemplateName(templateName);\r\n    final Locale locale = Latkes.getLocale();\r\n    final Map<String, String> langs = langPropsService.getAll(locale);\r\n    final Map<String, Object> dataModel = renderer.getDataModel();\r\n    dataModel.putAll(langs);\r\n    dataModel.put(Option.ID_C_LOCALE_STRING, locale.toString());\r\n    final JSONObject preference = preferenceQueryService.getPreference();\r\n    final StringBuilder timeZoneIdOptions = new StringBuilder();\r\n    final String[] availableIDs = TimeZone.getAvailableIDs();\r\n    for (int i = 0; i < availableIDs.length; i++) {\r\n        final String id = availableIDs[i];\r\n        String option;\r\n        if (id.equals(preference.optString(Option.ID_C_TIME_ZONE_ID))) {\r\n            option = \"<option value=\\\"\" + id + \"\\\" selected=\\\"true\\\">\" + id + \"<\/option>\";\r\n        } else {\r\n            option = \"<option value=\\\"\" + id + \"\\\">\" + id + \"<\/option>\";\r\n        }\r\n        timeZoneIdOptions.append(option);\r\n    }\r\n    dataModel.put(\"timeZoneIdOptions\", timeZoneIdOptions.toString());\r\n    fireFreeMarkerActionEvent(templateName, dataModel);\r\n}"
}, {
	"Path": "spark.Request.session",
	"Comment": "returns the current session associated with this request, or if there isno current session and create is true, returnsa new session.",
	"Method": "Session session(Session session,boolean create){\r\n    if (session == null || !validSession) {\r\n        HttpSession httpSession = servletRequest.getSession(create);\r\n        if (httpSession != null) {\r\n            validSession(true);\r\n            session = new Session(httpSession, this);\r\n        } else {\r\n            session = null;\r\n        }\r\n    }\r\n    return session;\r\n}"
}, {
	"Path": "spark.utils.IOUtils.toByteArray",
	"Comment": "get the contents of an inputstream as a bytearraythis method buffers the input internally, so there is no need to use abufferedinputstream.",
	"Method": "byte[] toByteArray(InputStream input){\r\n    ByteArrayOutputStream os = new ByteArrayOutputStream();\r\n    byte[] buf = new byte[1024];\r\n    for (int n = input.read(buf); n != -1; n = input.read(buf)) {\r\n        os.write(buf, 0, n);\r\n    }\r\n    return os.toByteArray();\r\n}"
}, {
	"Path": "org.openqa.grid.internal.utils.DefaultCapabilityMatcherTest.specificPlatformMatchingTestWithDeprecatedPlatformCapability",
	"Comment": "todo remove test when capabilitytype.platform is removed from code base",
	"Method": "void specificPlatformMatchingTestWithDeprecatedPlatformCapability(){\r\n    Map<String, Object> requested = ImmutableMap.of(CapabilityType.PLATFORM, Platform.XP);\r\n    assertTrue(matcher.matches(ImmutableMap.of(CapabilityType.PLATFORM, \"xp\"), requested));\r\n    assertFalse(matcher.matches(ImmutableMap.of(CapabilityType.PLATFORM, \"WINDOWS\"), requested));\r\n    assertFalse(matcher.matches(ImmutableMap.of(CapabilityType.PLATFORM, \"windows VISTA\"), requested));\r\n    assertFalse(matcher.matches(ImmutableMap.of(CapabilityType.PLATFORM, \"windows 7\"), requested));\r\n    assertFalse(matcher.matches(ImmutableMap.of(CapabilityType.PLATFORM, \"linux\"), requested));\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.tunnel.payload.HttpTunnelPayload.writeTo",
	"Comment": "write the content of this payload to the given target channel.",
	"Method": "void writeTo(WritableByteChannel channel){\r\n    Assert.notNull(channel, \"Channel must not be null\");\r\n    while (this.data.hasRemaining()) {\r\n        channel.write(this.data);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.addArticleInternal",
	"Comment": "adds the specified article for internal invocation purposes.",
	"Method": "String addArticleInternal(JSONObject article){\r\n    String ret = article.optString(Keys.OBJECT_ID);\r\n    if (StringUtils.isBlank(ret)) {\r\n        ret = Ids.genTimeMillisId();\r\n        article.put(Keys.OBJECT_ID, ret);\r\n    }\r\n    try {\r\n        String tagsString = article.optString(Article.ARTICLE_TAGS_REF);\r\n        tagsString = Tag.formatTags(tagsString);\r\n        if (StringUtils.isBlank(tagsString)) {\r\n            throw new ServiceException(langPropsService.get(\"tagsEmptyLabel\"));\r\n        }\r\n        article.put(Article.ARTICLE_TAGS_REF, tagsString);\r\n        final String[] tagTitles = tagsString.split(\",\");\r\n        final JSONArray tags = tag(tagTitles, article);\r\n        article.put(Article.ARTICLE_COMMENT_COUNT, 0);\r\n        article.put(Article.ARTICLE_VIEW_COUNT, 0);\r\n        final JSONObject preference = preferenceQueryService.getPreference();\r\n        if (!article.has(Article.ARTICLE_CREATED)) {\r\n            article.put(Article.ARTICLE_CREATED, System.currentTimeMillis());\r\n        }\r\n        article.put(Article.ARTICLE_UPDATED, article.optLong(Article.ARTICLE_CREATED));\r\n        article.put(Article.ARTICLE_PUT_TOP, false);\r\n        addTagArticleRelation(tags, article);\r\n        statisticMgmtService.incBlogArticleCount();\r\n        if (article.optBoolean(Article.ARTICLE_IS_PUBLISHED)) {\r\n            statisticMgmtService.incPublishedBlogArticleCount();\r\n        }\r\n        archiveDate(article);\r\n        final String permalink = getPermalinkForAddArticle(article);\r\n        article.put(Article.ARTICLE_PERMALINK, permalink);\r\n        final String signId = article.optString(Article.ARTICLE_SIGN_ID, \"1\");\r\n        article.put(Article.ARTICLE_SIGN_ID, signId);\r\n        article.put(Article.ARTICLE_HAD_BEEN_PUBLISHED, false);\r\n        if (article.optBoolean(Article.ARTICLE_IS_PUBLISHED)) {\r\n            article.put(Article.ARTICLE_HAD_BEEN_PUBLISHED, true);\r\n        }\r\n        article.put(Article.ARTICLE_RANDOM_DOUBLE, Math.random());\r\n        final boolean postToCommunity = article.optBoolean(Common.POST_TO_COMMUNITY, true);\r\n        article.remove(Common.POST_TO_COMMUNITY);\r\n        final JSONObject author = userRepository.get(article.optString(Article.ARTICLE_AUTHOR_ID));\r\n        final int userArticleCnt = author.optInt(UserExt.USER_ARTICLE_COUNT);\r\n        author.put(UserExt.USER_ARTICLE_COUNT, userArticleCnt + 1);\r\n        if (article.optBoolean(Article.ARTICLE_IS_PUBLISHED)) {\r\n            author.put(UserExt.USER_PUBLISHED_ARTICLE_COUNT, author.optInt(UserExt.USER_PUBLISHED_ARTICLE_COUNT) + 1);\r\n        }\r\n        userRepository.update(author.optString(Keys.OBJECT_ID), author);\r\n        if (!article.has(Article.ARTICLE_EDITOR_TYPE)) {\r\n            article.put(Article.ARTICLE_EDITOR_TYPE, preference.optString(Option.ID_C_EDITOR_TYPE));\r\n        }\r\n        articleRepository.add(article);\r\n        article.put(Common.POST_TO_COMMUNITY, postToCommunity);\r\n        if (article.optBoolean(Article.ARTICLE_IS_PUBLISHED)) {\r\n            final JSONObject eventData = new JSONObject();\r\n            eventData.put(Article.ARTICLE, article);\r\n            eventManager.fireEventSynchronously(new Event(EventTypes.ADD_ARTICLE, eventData));\r\n        }\r\n        article.remove(Common.POST_TO_COMMUNITY);\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Adds an article failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.endpoint.Sanitizer.setKeysToSanitize",
	"Comment": "keys that should be sanitized. keys can be simple strings that the property ends\twith or regular expressions.",
	"Method": "void setKeysToSanitize(String keysToSanitize){\r\n    Assert.notNull(keysToSanitize, \"KeysToSanitize must not be null\");\r\n    this.keysToSanitize = new Pattern[keysToSanitize.length];\r\n    for (int i = 0; i < keysToSanitize.length; i++) {\r\n        this.keysToSanitize[i] = getPattern(keysToSanitize[i]);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.setMessageWriters",
	"Comment": "configure http message writers to serialize the response body with.",
	"Method": "void setMessageWriters(List<HttpMessageWriter<?>> messageWriters){\r\n    Assert.notNull(messageWriters, \"'messageWriters' must not be null\");\r\n    this.messageWriters = messageWriters;\r\n}"
}, {
	"Path": "org.springframework.boot.diagnostics.FailureAnalysis.getAction",
	"Comment": "returns the action, if any, to be taken to address the failure.",
	"Method": "String getAction(){\r\n    return this.action;\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.server.AbstractServletWebServerFactory.shouldRegisterJspServlet",
	"Comment": "returns whether or not the jsp servlet should be registered with the web server.",
	"Method": "boolean shouldRegisterJspServlet(){\r\n    return this.jsp != null && this.jsp.getRegistered() && ClassUtils.isPresent(this.jsp.getClassName(), getClass().getClassLoader());\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.kafka.KafkaProperties.buildProducerProperties",
	"Comment": "create an initial map of producer properties from the state of this instance.\tthis allows you to add additional properties, if necessary, and override the\tdefault kafkaproducerfactory bean.",
	"Method": "Map<String, Object> buildProducerProperties(){\r\n    Map<String, Object> properties = buildCommonProperties();\r\n    properties.putAll(this.producer.buildProperties());\r\n    return properties;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.isExtensionExposed",
	"Comment": "determine if an extension bean should be exposed. subclasses can override this\tmethod to provide additional logic.",
	"Method": "boolean isExtensionExposed(EndpointBean endpointBean,ExtensionBean extensionBean,boolean isExtensionExposed,Object extensionBean){\r\n    return true;\r\n}"
}, {
	"Path": "org.b3log.solo.processor.ArticleProcessor.getArticlesPagedCurrentPageNum",
	"Comment": "gets the request page number from the specified request uri.",
	"Method": "int getArticlesPagedCurrentPageNum(String requestURI){\r\n    final String pageNumString = requestURI.substring((Latkes.getContextPath() + \"/articles/\").length());\r\n    return Requests.getCurrentPageNum(pageNumString);\r\n}"
}, {
	"Path": "spark.Routable.createRouteImpl",
	"Comment": "create route implementation or use default response transformer",
	"Method": "RouteImpl createRouteImpl(String path,String acceptType,Route route,RouteImpl createRouteImpl,String path,Route route){\r\n    if (defaultResponseTransformer != null) {\r\n        return ResponseTransformerRouteImpl.create(path, route, defaultResponseTransformer);\r\n    }\r\n    return RouteImpl.create(path, route);\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BindException.getName",
	"Comment": "return the name of the configuration property being bound.",
	"Method": "ConfigurationPropertyName getName(){\r\n    return this.name;\r\n}"
}, {
	"Path": "org.b3log.solo.processor.console.AdminConsole.showAdminFunctions",
	"Comment": "shows administrator functions with the specified context.",
	"Method": "void showAdminFunctions(HTTPRequestContext context){\r\n    final HttpServletRequest request = context.getRequest();\r\n    final AbstractFreeMarkerRenderer renderer = new ConsoleRenderer();\r\n    context.setRenderer(renderer);\r\n    final String requestURI = request.getRequestURI();\r\n    final String templateName = StringUtils.substringBetween(requestURI, Latkes.getContextPath() + '/', \".\") + \".ftl\";\r\n    LOGGER.log(Level.TRACE, \"Admin function[templateName={0}]\", templateName);\r\n    renderer.setTemplateName(templateName);\r\n    final Locale locale = Latkes.getLocale();\r\n    final Map<String, String> langs = langPropsService.getAll(locale);\r\n    final Map<String, Object> dataModel = renderer.getDataModel();\r\n    dataModel.put(\"supportExport\", Latkes.RuntimeDatabase.MYSQL == Latkes.getRuntimeDatabase() || Latkes.RuntimeDatabase.H2 == Latkes.getRuntimeDatabase());\r\n    dataModel.putAll(langs);\r\n    Keys.fillRuntime(dataModel);\r\n    dataModel.put(Option.ID_C_LOCALE_STRING, locale.toString());\r\n    fireFreeMarkerActionEvent(templateName, dataModel);\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.tunnel.payload.HttpTunnelPayload.logOutgoing",
	"Comment": "log incoming payload information at trace level to aid diagnostics.",
	"Method": "void logOutgoing(){\r\n    log(\"> \");\r\n}"
}, {
	"Path": "org.b3log.solo.processor.SkinRenderer.isPJAX",
	"Comment": "determines whether the specified request is sending with pjax.",
	"Method": "boolean isPJAX(HttpServletRequest request){\r\n    final boolean pjax = Boolean.valueOf(request.getHeader(\"X-PJAX\"));\r\n    final String pjaxContainer = request.getHeader(\"X-PJAX-Container\");\r\n    return pjax && StringUtils.isNotBlank(pjaxContainer);\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.ServletRegistrationBean.configure",
	"Comment": "configure registration settings. subclasses can override this method to perform\tadditional configuration if required.",
	"Method": "void configure(ServletRegistration.Dynamic registration){\r\n    super.configure(registration);\r\n    String[] urlMapping = StringUtils.toStringArray(this.urlMappings);\r\n    if (urlMapping.length == 0 && this.alwaysMapUrl) {\r\n        urlMapping = DEFAULT_MAPPINGS;\r\n    }\r\n    if (!ObjectUtils.isEmpty(urlMapping)) {\r\n        registration.addMapping(urlMapping);\r\n    }\r\n    registration.setLoadOnStartup(this.loadOnStartup);\r\n    if (this.multipartConfig != null) {\r\n        registration.setMultipartConfig(this.multipartConfig);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.ServletRegistrationBean.getUrlMappings",
	"Comment": "return a mutable collection of the url mappings, as defined in the servlet\tspecification, for the servlet.",
	"Method": "Collection<String> getUrlMappings(){\r\n    return this.urlMappings;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationmetadata.ConfigurationMetadataSource.getGroupId",
	"Comment": "the identifier of the group to which this source is associated.",
	"Method": "String getGroupId(){\r\n    return this.groupId;\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.isNotEqualToJson",
	"Comment": "verifies that the actual value is not equal to the specified json resource.",
	"Method": "JsonContentAssert isNotEqualToJson(CharSequence expected,JsonContentAssert isNotEqualToJson,String path,Class<?> resourceLoadClass,JsonContentAssert isNotEqualToJson,byte[] expected,JsonContentAssert isNotEqualToJson,File expected,JsonContentAssert isNotEqualToJson,InputStream expected,JsonContentAssert isNotEqualToJson,Resource expected,JsonContentAssert isNotEqualToJson,CharSequence expected,JSONCompareMode compareMode,JsonContentAssert isNotEqualToJson,String path,Class<?> resourceLoadClass,JSONCompareMode compareMode,JsonContentAssert isNotEqualToJson,byte[] expected,JSONCompareMode compareMode,JsonContentAssert isNotEqualToJson,File expected,JSONCompareMode compareMode,JsonContentAssert isNotEqualToJson,InputStream expected,JSONCompareMode compareMode,JsonContentAssert isNotEqualToJson,Resource expected,JSONCompareMode compareMode,JsonContentAssert isNotEqualToJson,CharSequence expected,JSONComparator comparator,JsonContentAssert isNotEqualToJson,String path,Class<?> resourceLoadClass,JSONComparator comparator,JsonContentAssert isNotEqualToJson,byte[] expected,JSONComparator comparator,JsonContentAssert isNotEqualToJson,File expected,JSONComparator comparator,JsonContentAssert isNotEqualToJson,InputStream expected,JSONComparator comparator,JsonContentAssert isNotEqualToJson,Resource expected,JSONComparator comparator){\r\n    String expectedJson = this.loader.getJson(expected);\r\n    return assertNotPassed(compare(expectedJson, comparator));\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleQueryService.getArticlesByTag",
	"Comment": "gets a list of published articles with the specified tag id, current page number and page size.",
	"Method": "List<JSONObject> getArticlesByTag(String tagId,int currentPageNum,int pageSize){\r\n    try {\r\n        JSONObject result = tagArticleRepository.getByTagId(tagId, currentPageNum, pageSize);\r\n        final JSONArray tagArticleRelations = result.getJSONArray(Keys.RESULTS);\r\n        if (0 == tagArticleRelations.length()) {\r\n            return Collections.emptyList();\r\n        }\r\n        final Set<String> articleIds = new HashSet();\r\n        for (int i = 0; i < tagArticleRelations.length(); i++) {\r\n            final JSONObject tagArticleRelation = tagArticleRelations.getJSONObject(i);\r\n            final String articleId = tagArticleRelation.getString(Article.ARTICLE + \"_\" + Keys.OBJECT_ID);\r\n            articleIds.add(articleId);\r\n        }\r\n        final List<JSONObject> ret = new ArrayList();\r\n        final Query query = new Query().setFilter(new PropertyFilter(Keys.OBJECT_ID, FilterOperator.IN, articleIds)).setPageCount(1).index(Article.ARTICLE_PERMALINK);\r\n        result = articleRepository.get(query);\r\n        final JSONArray articles = result.getJSONArray(Keys.RESULTS);\r\n        for (int i = 0; i < articles.length(); i++) {\r\n            final JSONObject article = articles.getJSONObject(i);\r\n            if (!article.getBoolean(Article.ARTICLE_IS_PUBLISHED)) {\r\n                continue;\r\n            }\r\n            article.put(ARTICLE_CREATE_TIME, article.getLong(ARTICLE_CREATED));\r\n            article.put(ARTICLE_T_CREATE_DATE, new Date(article.getLong(ARTICLE_CREATED)));\r\n            article.put(Article.ARTICLE_T_UPDATE_DATE, new Date(article.optLong(ARTICLE_UPDATED)));\r\n            ret.add(article);\r\n        }\r\n        return ret;\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Gets articles by tag[id=\" + tagId + \"] failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleQueryService.markdown",
	"Comment": "converts the content and abstract for the specified article to html if it is saved by markdown editor.",
	"Method": "void markdown(JSONObject article){\r\n    if (\"CodeMirror-Markdown\".equals(article.optString(ARTICLE_EDITOR_TYPE))) {\r\n        Stopwatchs.start(\"Markdown Article[id=\" + article.optString(Keys.OBJECT_ID) + \"]\");\r\n        Stopwatchs.start(\"Content\");\r\n        String content = article.optString(ARTICLE_CONTENT);\r\n        content = Emotions.convert(content);\r\n        content = Markdowns.toHTML(content);\r\n        article.put(ARTICLE_CONTENT, content);\r\n        Stopwatchs.end();\r\n        String abstractContent = article.optString(ARTICLE_ABSTRACT);\r\n        if (StringUtils.isNotBlank(abstractContent)) {\r\n            Stopwatchs.start(\"Abstract\");\r\n            abstractContent = Emotions.convert(abstractContent);\r\n            abstractContent = Markdowns.toHTML(abstractContent);\r\n            article.put(ARTICLE_ABSTRACT, abstractContent);\r\n            Stopwatchs.end();\r\n        }\r\n        Stopwatchs.end();\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleQueryService.setArticleRepository",
	"Comment": "sets the article repository with the specified article repository.",
	"Method": "void setArticleRepository(ArticleRepository articleRepository){\r\n    this.articleRepository = articleRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.Bindable.getAnnotations",
	"Comment": "return any associated annotations that could affect binding.",
	"Method": "Annotation[] getAnnotations(){\r\n    return this.annotations;\r\n}"
}, {
	"Path": "spark.embeddedserver.EmbeddedServers.create",
	"Comment": "creates an embedded server of type corresponding to the provided identifier.",
	"Method": "EmbeddedServer create(Object identifier,Routes routeMatcher,StaticFilesConfiguration staticFilesConfiguration,boolean multipleHandlers,EmbeddedServer create,Object identifier,Routes routeMatcher,ExceptionMapper exceptionMapper,StaticFilesConfiguration staticFilesConfiguration,boolean multipleHandlers){\r\n    EmbeddedServerFactory factory = factories.get(identifier);\r\n    if (factory != null) {\r\n        return factory.create(routeMatcher, staticFilesConfiguration, exceptionMapper, multipleHandlers);\r\n    } else {\r\n        throw new RuntimeException(\"No embedded server matching the identifier\");\r\n    }\r\n}"
}, {
	"Path": "spark.Session.removeAttribute",
	"Comment": "removes the object bound with the specified name from this session.",
	"Method": "void removeAttribute(String name){\r\n    session.removeAttribute(name);\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleQueryService.getArticlesByAuthorId",
	"Comment": "gets published articles by the specified author id, current page number and page size.",
	"Method": "List<JSONObject> getArticlesByAuthorId(String authorId,int currentPageNum,int pageSize){\r\n    try {\r\n        final JSONObject result = articleRepository.getByAuthorId(authorId, currentPageNum, pageSize);\r\n        final JSONArray articles = result.getJSONArray(Keys.RESULTS);\r\n        final List<JSONObject> ret = new ArrayList();\r\n        for (int i = 0; i < articles.length(); i++) {\r\n            final JSONObject article = articles.getJSONObject(i);\r\n            article.put(ARTICLE_CREATE_TIME, article.getLong(ARTICLE_CREATED));\r\n            article.put(ARTICLE_T_CREATE_DATE, new Date(article.optLong(ARTICLE_CREATED)));\r\n            article.put(Article.ARTICLE_T_UPDATE_DATE, new Date(article.optLong(ARTICLE_UPDATED)));\r\n            ret.add(article);\r\n        }\r\n        return ret;\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Gets articles by author email failed [authorId=\" + authorId + \", currentPageNum=\" + currentPageNum + \", pageSize=\" + pageSize + \"]\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.processor.ArticleProcessor.getTagArticlesPagedCurrentPageNum",
	"Comment": "gets the request page number from the specified request uri.",
	"Method": "int getTagArticlesPagedCurrentPageNum(String requestURI){\r\n    return Requests.getCurrentPageNum(StringUtils.substringAfterLast(requestURI, \"/\"));\r\n}"
}, {
	"Path": "org.b3log.solo.service.StatisticQueryService.setOptionQueryService",
	"Comment": "sets the option query service with the specified option query service.",
	"Method": "void setOptionQueryService(OptionQueryService optionQueryService){\r\n    this.optionQueryService = optionQueryService;\r\n}"
}, {
	"Path": "org.b3log.solo.service.OptionQueryService.getOptions",
	"Comment": "gets options with the specified category.all options with the specified category will be merged into one json object as the return value.",
	"Method": "JSONObject getOptions(String category){\r\n    try {\r\n        return optionRepository.getOptions(category);\r\n    } catch (final Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.processor.ArticleProcessor.prepareShowArchiveArticles",
	"Comment": "prepares the specified data model for rendering archive articles.",
	"Method": "String prepareShowArchiveArticles(JSONObject preference,Map<String, Object> dataModel,List<JSONObject> articles,int currentPageNum,int pageCount,String archiveDateString,JSONObject archiveDate){\r\n    final int pageSize = preference.getInt(Option.ID_C_ARTICLE_LIST_DISPLAY_COUNT);\r\n    final int windowSize = preference.getInt(Option.ID_C_ARTICLE_LIST_PAGINATION_WINDOW_SIZE);\r\n    final List<Integer> pageNums = Paginator.paginate(currentPageNum, pageSize, pageCount, windowSize);\r\n    dataModel.put(Article.ARTICLES, articles);\r\n    final String previousPageNum = Integer.toString(currentPageNum > 1 ? currentPageNum - 1 : 0);\r\n    dataModel.put(Pagination.PAGINATION_PREVIOUS_PAGE_NUM, \"0\".equals(previousPageNum) ? \"\" : previousPageNum);\r\n    if (pageCount == currentPageNum + 1) {\r\n        dataModel.put(Pagination.PAGINATION_NEXT_PAGE_NUM, \"\");\r\n    } else {\r\n        dataModel.put(Pagination.PAGINATION_NEXT_PAGE_NUM, currentPageNum + 1);\r\n    }\r\n    dataModel.put(Pagination.PAGINATION_CURRENT_PAGE_NUM, currentPageNum);\r\n    dataModel.put(Pagination.PAGINATION_FIRST_PAGE_NUM, pageNums.get(0));\r\n    dataModel.put(Pagination.PAGINATION_LAST_PAGE_NUM, pageNums.get(pageNums.size() - 1));\r\n    dataModel.put(Pagination.PAGINATION_PAGE_COUNT, pageCount);\r\n    dataModel.put(Pagination.PAGINATION_PAGE_NUMS, pageNums);\r\n    dataModel.put(Common.PATH, \"/archives/\" + archiveDateString);\r\n    dataModel.put(Keys.OBJECT_ID, archiveDate.getString(Keys.OBJECT_ID));\r\n    final long time = archiveDate.getLong(ArchiveDate.ARCHIVE_TIME);\r\n    final String dateString = DateFormatUtils.format(time, \"yyyy/MM\");\r\n    final String[] dateStrings = dateString.split(\"/\");\r\n    final String year = dateStrings[0];\r\n    final String month = dateStrings[1];\r\n    archiveDate.put(ArchiveDate.ARCHIVE_DATE_YEAR, year);\r\n    final String language = Locales.getLanguage(preference.getString(Option.ID_C_LOCALE_STRING));\r\n    String ret;\r\n    if (\"en\".equals(language)) {\r\n        archiveDate.put(ArchiveDate.ARCHIVE_DATE_MONTH, Dates.EN_MONTHS.get(month));\r\n        ret = Dates.EN_MONTHS.get(month) + \" \" + year;\r\n    } else {\r\n        archiveDate.put(ArchiveDate.ARCHIVE_DATE_MONTH, month);\r\n        ret = year + \" \" + dataModel.get(\"yearLabel\") + \" \" + month + \" \" + dataModel.get(\"monthLabel\");\r\n    }\r\n    dataModel.put(ArchiveDate.ARCHIVE_DATE, archiveDate);\r\n    return ret;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationprocessor.json.JSONTokener.syntaxError",
	"Comment": "returns an exception containing the given message plus the current position and the\tentire input string.",
	"Method": "JSONException syntaxError(String message){\r\n    return new JSONException(message + this);\r\n}"
}, {
	"Path": "spark.staticfiles.StaticFilesConfiguration.consume",
	"Comment": "attempt consuming using either static resource handlers or jar resource handlers",
	"Method": "boolean consume(HttpServletRequest httpRequest,HttpServletResponse httpResponse){\r\n    try {\r\n        if (consumeWithFileResourceHandlers(httpRequest, httpResponse)) {\r\n            return true;\r\n        }\r\n    } catch (DirectoryTraversal.DirectoryTraversalDetection directoryTraversalDetection) {\r\n        httpResponse.setStatus(400);\r\n        httpResponse.getWriter().write(\"Bad request\");\r\n        httpResponse.getWriter().flush();\r\n        LOG.warn(directoryTraversalDetection.getMessage() + \" directory traversal detection for path: \" + httpRequest.getPathInfo());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.b3log.solo.cache.OptionCache.getCategory",
	"Comment": "gets merged options as a json object for the specified category",
	"Method": "JSONObject getCategory(String category){\r\n    JSONObject ret = categoryCache.get(category);\r\n    if (null == ret) {\r\n        return null;\r\n    }\r\n    return Solos.clone(ret);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.isIncludeStackTrace",
	"Comment": "determine if the stacktrace attribute should be included.",
	"Method": "boolean isIncludeStackTrace(HttpServletRequest request,MediaType produces){\r\n    IncludeStacktrace include = getErrorProperties().getIncludeStacktrace();\r\n    if (include == IncludeStacktrace.ALWAYS) {\r\n        return true;\r\n    }\r\n    if (include == IncludeStacktrace.ON_TRACE_PARAM) {\r\n        return getTraceParameter(request);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.b3log.solo.service.InitService.setArchiveDateRepository",
	"Comment": "sets archive date repository with the specified archive date repository.",
	"Method": "void setArchiveDateRepository(ArchiveDateRepository archiveDateRepository){\r\n    this.archiveDateRepository = archiveDateRepository;\r\n}"
}, {
	"Path": "org.b3log.solo.service.InitService.initAdmin",
	"Comment": "initializes administrator with the specified request json object, and then logins it.",
	"Method": "void initAdmin(JSONObject requestJSONObject){\r\n    LOGGER.debug(\"Initializing admin....\");\r\n    final JSONObject admin = new JSONObject();\r\n    admin.put(User.USER_NAME, requestJSONObject.getString(User.USER_NAME));\r\n    admin.put(User.USER_EMAIL, requestJSONObject.getString(User.USER_EMAIL));\r\n    admin.put(User.USER_URL, Latkes.getServePath());\r\n    admin.put(User.USER_ROLE, Role.ADMIN_ROLE);\r\n    admin.put(User.USER_PASSWORD, DigestUtils.md5Hex(requestJSONObject.getString(User.USER_PASSWORD)));\r\n    admin.put(UserExt.USER_ARTICLE_COUNT, 0);\r\n    admin.put(UserExt.USER_PUBLISHED_ARTICLE_COUNT, 0);\r\n    String avatar = requestJSONObject.optString(UserExt.USER_AVATAR);\r\n    if (StringUtils.isBlank(avatar)) {\r\n        avatar = Solos.getGravatarURL(requestJSONObject.getString(User.USER_EMAIL), \"128\");\r\n    }\r\n    admin.put(UserExt.USER_AVATAR, avatar);\r\n    userRepository.add(admin);\r\n    LOGGER.debug(\"Initialized admin\");\r\n}"
}, {
	"Path": "org.springframework.boot.util.LambdaSafe.callbacks",
	"Comment": "start a call to callback instances, dealing with common generic type concerns and\texceptions.",
	"Method": "Callbacks<C, A> callbacks(Class<C> callbackType,Collection<? extends C> callbackInstances,A argument,Object additionalArguments){\r\n    Assert.notNull(callbackType, \"CallbackType must not be null\");\r\n    Assert.notNull(callbackInstances, \"CallbackInstances must not be null\");\r\n    return new Callbacks(callbackType, callbackInstances, argument, additionalArguments);\r\n}"
}, {
	"Path": "spark.route.Routes.remove",
	"Comment": "removes a particular route from the collection of those that have been previously routed.search for a previously established routes using the given path and removes any matches that are found.",
	"Method": "boolean remove(String path,String httpMethod,boolean remove,String path){\r\n    if (StringUtils.isEmpty(path)) {\r\n        throw new IllegalArgumentException(\"path cannot be null or blank\");\r\n    }\r\n    return removeRoute((HttpMethod) null, path);\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.setStatisticMgmtService",
	"Comment": "sets the statistic management service with the specified statistic management service.",
	"Method": "void setStatisticMgmtService(StatisticMgmtService statisticMgmtService){\r\n    this.statisticMgmtService = statisticMgmtService;\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.incViewCount",
	"Comment": "increments the view count of the article specified by the given article id.",
	"Method": "void incViewCount(String articleId){\r\n    JSONObject article;\r\n    try {\r\n        article = articleRepository.get(articleId);\r\n        if (null == article) {\r\n            return;\r\n        }\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Gets article [id=\" + articleId + \"] failed\", e);\r\n        return;\r\n    }\r\n    final Transaction transaction = articleRepository.beginTransaction();\r\n    try {\r\n        article.put(Article.ARTICLE_VIEW_COUNT, article.getInt(Article.ARTICLE_VIEW_COUNT) + 1);\r\n        articleRepository.update(articleId, article);\r\n        transaction.commit();\r\n    } catch (final Exception e) {\r\n        if (transaction.isActive()) {\r\n            transaction.rollback();\r\n        }\r\n        LOGGER.log(Level.WARN, \"Updates article view count failed\");\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "spark.resource.AbstractResource.contentLength",
	"Comment": "this implementation reads the entire inputstream to calculate thecontent length. subclasses will almost always be able to providea more optimal version of this, e.g. checking a file length.",
	"Method": "long contentLength(){\r\n    InputStream is = this.getInputStream();\r\n    Assert.state(is != null, \"resource input stream must not be null\");\r\n    try {\r\n        long size = 0;\r\n        byte[] buf = new byte[255];\r\n        int read;\r\n        while ((read = is.read(buf)) != -1) {\r\n            size += read;\r\n        }\r\n        return size;\r\n    } finally {\r\n        try {\r\n            is.close();\r\n        } catch (IOException ex) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.repository.CategoryRepository.getUnder",
	"Comment": "gets the under category of the category specified by the given id.",
	"Method": "JSONObject getUnder(String id){\r\n    final JSONObject category = get(id);\r\n    if (null == category) {\r\n        return null;\r\n    }\r\n    final Query query = new Query().setFilter(new PropertyFilter(Category.CATEGORY_ORDER, FilterOperator.GREATER_THAN, category.optInt(Category.CATEGORY_ORDER))).addSort(Category.CATEGORY_ORDER, SortDirection.ASCENDING).setCurrentPageNum(1).setPageSize(1);\r\n    final JSONObject result = get(query);\r\n    final JSONArray array = result.optJSONArray(Keys.RESULTS);\r\n    if (1 != array.length()) {\r\n        return null;\r\n    }\r\n    return array.optJSONObject(0);\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.web.mappings.servlet.FilterRegistrationMappingDescription.getUrlPatternMappings",
	"Comment": "returns the url pattern mappings for the registered filter.",
	"Method": "Collection<String> getUrlPatternMappings(){\r\n    return this.getRegistration().getUrlPatternMappings();\r\n}"
}, {
	"Path": "org.springframework.boot.logging.DeferredLog.replay",
	"Comment": "replay from a source log to a destination log when the source is deferred.",
	"Method": "Log replay(Log source,Class<?> destination,Log replay,Log source,Log destination){\r\n    if (source instanceof DeferredLog) {\r\n        ((DeferredLog) source).replayTo(destination);\r\n    }\r\n    return destination;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.autoconfigure.cloudfoundry.CloudFoundryAuthorizationException.getStatusCode",
	"Comment": "return the status code that should be returned to the client.",
	"Method": "HttpStatus getStatusCode(){\r\n    return getReason().getStatus();\r\n}"
}, {
	"Path": "org.springframework.boot.cli.compiler.grape.RepositoryConfiguration.getSnapshotsEnabled",
	"Comment": "return if the repository should enable access to snapshots.",
	"Method": "boolean getSnapshotsEnabled(){\r\n    return this.snapshotsEnabled;\r\n}"
}, {
	"Path": "org.b3log.solo.repository.CommentRepository.getComments",
	"Comment": "gets comments with the specified on id, current page number andpage size.",
	"Method": "List<JSONObject> getComments(String onId,int currentPageNum,int pageSize){\r\n    final Query query = new Query().addSort(Keys.OBJECT_ID, SortDirection.DESCENDING).setFilter(new PropertyFilter(Comment.COMMENT_ON_ID, FilterOperator.EQUAL, onId)).setCurrentPageNum(currentPageNum).setPageSize(pageSize).setPageCount(1);\r\n    return getList(query);\r\n}"
}, {
	"Path": "org.springframework.boot.cli.command.init.ProjectGenerationRequest.getType",
	"Comment": "the type of project to generate. should match one of the advertized type that the\tservice supports. if not set, the default is retrieved from the service metadata.",
	"Method": "String getType(){\r\n    return this.type;\r\n}"
}, {
	"Path": "spark.resource.AbstractResource.createRelative",
	"Comment": "this implementation throws a filenotfoundexception, assumingthat relative resources cannot be created for this resource.",
	"Method": "Resource createRelative(String relativePath){\r\n    throw new FileNotFoundException(\"Cannot create a relative resource for \" + getDescription());\r\n}"
}, {
	"Path": "org.b3log.solo.AbstractTestCase.beforeClass",
	"Comment": "before class.initializes latke runtimeinstantiates repositories",
	"Method": "void beforeClass(){\r\n    Latkes.init();\r\n    Latkes.setLocale(Locale.SIMPLIFIED_CHINESE);\r\n    final Collection<Class<?>> classes = Discoverer.discover(\"org.b3log.solo\");\r\n    BeanManager.start(classes);\r\n    beanManager = BeanManager.getInstance();\r\n    final Connection connection = Connections.getConnection();\r\n    connection.createStatement().execute(\"DROP ALL OBJECTS\");\r\n    connection.close();\r\n    JdbcRepositories.initAllTables();\r\n}"
}, {
	"Path": "org.springframework.boot.SpringBootExceptionHandler.isLogConfigurationMessage",
	"Comment": "check if the exception is a log configuration message, i.e. the log call might not\thave actually output anything.",
	"Method": "boolean isLogConfigurationMessage(Throwable ex){\r\n    if (ex instanceof InvocationTargetException) {\r\n        return isLogConfigurationMessage(ex.getCause());\r\n    }\r\n    String message = ex.getMessage();\r\n    if (message != null) {\r\n        for (String candidate : LOG_CONFIGURATION_MESSAGES) {\r\n            if (message.contains(candidate)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.b3log.solo.service.PreferenceMgmtService.updateReplyNotificationTemplate",
	"Comment": "updates the reply notification template with the specified reply notification template.",
	"Method": "void updateReplyNotificationTemplate(JSONObject replyNotificationTemplate){\r\n    final Transaction transaction = optionRepository.beginTransaction();\r\n    try {\r\n        final JSONObject bodyOpt = optionRepository.get(Option.ID_C_REPLY_NOTI_TPL_BODY);\r\n        bodyOpt.put(Option.OPTION_VALUE, replyNotificationTemplate.optString(\"body\"));\r\n        optionRepository.update(Option.ID_C_REPLY_NOTI_TPL_BODY, bodyOpt);\r\n        final JSONObject subjectOpt = optionRepository.get(Option.ID_C_REPLY_NOTI_TPL_SUBJECT);\r\n        subjectOpt.put(Option.OPTION_VALUE, replyNotificationTemplate.optString(\"subject\"));\r\n        optionRepository.update(Option.ID_C_REPLY_NOTI_TPL_SUBJECT, subjectOpt);\r\n        transaction.commit();\r\n    } catch (final Exception e) {\r\n        if (transaction.isActive()) {\r\n            transaction.rollback();\r\n        }\r\n        LOGGER.log(Level.ERROR, \"Updates reply notification failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.kafka.ConcurrentKafkaListenerContainerFactoryConfigurer.configure",
	"Comment": "configure the specified kafka listener container factory. the factory can be\tfurther tuned and default settings can be overridden.",
	"Method": "void configure(ConcurrentKafkaListenerContainerFactory<Object, Object> listenerFactory,ConsumerFactory<Object, Object> consumerFactory){\r\n    listenerFactory.setConsumerFactory(consumerFactory);\r\n    configureListenerFactory(listenerFactory);\r\n    configureContainer(listenerFactory.getContainerProperties());\r\n}"
}, {
	"Path": "org.springframework.boot.type.classreading.ConcurrentReferenceCachingMetadataReaderFactory.clearCache",
	"Comment": "clear the entire metadatareader cache, removing all cached class metadata.",
	"Method": "void clearCache(){\r\n    this.cache.clear();\r\n}"
}, {
	"Path": "org.b3log.solo.service.PageQueryService.setPageRepository",
	"Comment": "set the page repository with the specified page repository.",
	"Method": "void setPageRepository(PageRepository pageRepository){\r\n    this.pageRepository = pageRepository;\r\n}"
}, {
	"Path": "org.b3log.solo.service.PageMgmtService.setPageRepository",
	"Comment": "set the page repository with the specified page repository.",
	"Method": "void setPageRepository(PageRepository pageRepository){\r\n    this.pageRepository = pageRepository;\r\n}"
}, {
	"Path": "spark.resource.AbstractResource.exists",
	"Comment": "this implementation checks whether a file can be opened,falling back to whether an inputstream can be opened.this will cover both directories and content resources.",
	"Method": "boolean exists(){\r\n    try {\r\n        return getFile().exists();\r\n    } catch (IOException ex) {\r\n        try {\r\n            InputStream is = getInputStream();\r\n            is.close();\r\n            return true;\r\n        } catch (Throwable isEx) {\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.getPermalinkForAddArticle",
	"Comment": "gets article permalink for adding article with the specified article.",
	"Method": "String getPermalinkForAddArticle(JSONObject article){\r\n    final long date = article.optLong(Article.ARTICLE_CREATED);\r\n    String ret = article.optString(Article.ARTICLE_PERMALINK);\r\n    if (StringUtils.isBlank(ret)) {\r\n        ret = \"/articles/\" + DateFormatUtils.format(date, \"yyyy/MM/dd\") + \"/\" + article.optString(Keys.OBJECT_ID) + \".html\";\r\n    }\r\n    if (!ret.startsWith(\"/\")) {\r\n        ret = \"/\" + ret;\r\n    }\r\n    if (PermalinkQueryService.invalidArticlePermalinkFormat(ret)) {\r\n        throw new ServiceException(langPropsService.get(\"invalidPermalinkFormatLabel\"));\r\n    }\r\n    if (permalinkQueryService.exist(ret)) {\r\n        throw new ServiceException(langPropsService.get(\"duplicatedPermalinkLabel\"));\r\n    }\r\n    return ret.replaceAll(\" \", \"-\");\r\n}"
}, {
	"Path": "spark.utils.urldecoding.TypeUtil.parseInt",
	"Comment": "parse an int from a substring.negative numbers are not handled.",
	"Method": "int parseInt(String s,int offset,int length,int base){\r\n    int value = 0;\r\n    if (length < 0) {\r\n        length = s.length() - offset;\r\n    }\r\n    for (int i = 0; i < length; i++) {\r\n        char c = s.charAt(offset + i);\r\n        int digit = convertHexDigit((int) c);\r\n        if (digit < 0 || digit >= base) {\r\n            throw new NumberFormatException(s.substring(offset, offset + length));\r\n        }\r\n        value = value * base + digit;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.extractingJsonPathStringValue",
	"Comment": "extract the string value at the given json path for further object assertions.",
	"Method": "AbstractCharSequenceAssert<?, String> extractingJsonPathStringValue(CharSequence expression,Object args){\r\n    return Assertions.assertThat(extractingJsonPathValue(expression, args, String.class, \"a string\"));\r\n}"
}, {
	"Path": "org.springframework.boot.builder.SpringApplicationBuilder.main",
	"Comment": "fixes the main application class that is used to anchor the startup messages.",
	"Method": "SpringApplicationBuilder main(Class<?> mainApplicationClass){\r\n    this.application.setMainApplicationClass(mainApplicationClass);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.setMessageReaders",
	"Comment": "configure http message readers to deserialize the request body with.",
	"Method": "void setMessageReaders(List<HttpMessageReader<?>> messageReaders){\r\n    Assert.notNull(messageReaders, \"'messageReaders' must not be null\");\r\n    this.messageReaders = messageReaders;\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.restart.Restarter.relaunch",
	"Comment": "relaunch the application using the specified classloader.",
	"Method": "Throwable relaunch(ClassLoader classLoader){\r\n    RestartLauncher launcher = new RestartLauncher(classLoader, this.mainClassName, this.args, this.exceptionHandler);\r\n    launcher.start();\r\n    launcher.join();\r\n    return launcher.getError();\r\n}"
}, {
	"Path": "org.b3log.solo.service.OptionMgmtService.setOptionRepository",
	"Comment": "sets the option repository with the specified option repository.",
	"Method": "void setOptionRepository(OptionRepository optionRepository){\r\n    this.optionRepository = optionRepository;\r\n}"
}, {
	"Path": "spark.ExceptionMapper.getHandler",
	"Comment": "returns the handler associated with the provided exception class",
	"Method": "ExceptionHandlerImpl getHandler(Class<? extends Exception> exceptionClass,ExceptionHandlerImpl getHandler,Exception exception){\r\n    return this.getHandler(exception.getClass());\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport.recordExclusions",
	"Comment": "records the names of the classes that have been excluded from condition evaluation.",
	"Method": "void recordExclusions(Collection<String> exclusions){\r\n    Assert.notNull(exclusions, \"exclusions must not be null\");\r\n    this.exclusions.addAll(exclusions);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.couchbase.CouchbaseConfiguration.initializeEnvironmentBuilder",
	"Comment": "initialize an environment builder based on the specified settings.",
	"Method": "DefaultCouchbaseEnvironment.Builder initializeEnvironmentBuilder(CouchbaseProperties properties){\r\n    CouchbaseProperties.Endpoints endpoints = properties.getEnv().getEndpoints();\r\n    CouchbaseProperties.Timeouts timeouts = properties.getEnv().getTimeouts();\r\n    DefaultCouchbaseEnvironment.Builder builder = DefaultCouchbaseEnvironment.builder();\r\n    if (timeouts.getConnect() != null) {\r\n        builder = builder.connectTimeout(timeouts.getConnect().toMillis());\r\n    }\r\n    builder = builder.keyValueServiceConfig(KeyValueServiceConfig.create(endpoints.getKeyValue()));\r\n    if (timeouts.getKeyValue() != null) {\r\n        builder = builder.kvTimeout(timeouts.getKeyValue().toMillis());\r\n    }\r\n    if (timeouts.getQuery() != null) {\r\n        builder = builder.queryTimeout(timeouts.getQuery().toMillis());\r\n        builder = builder.queryServiceConfig(getQueryServiceConfig(endpoints));\r\n        builder = builder.viewServiceConfig(getViewServiceConfig(endpoints));\r\n    }\r\n    if (timeouts.getSocketConnect() != null) {\r\n        builder = builder.socketConnectTimeout((int) timeouts.getSocketConnect().toMillis());\r\n    }\r\n    if (timeouts.getView() != null) {\r\n        builder = builder.viewTimeout(timeouts.getView().toMillis());\r\n    }\r\n    CouchbaseProperties.Ssl ssl = properties.getEnv().getSsl();\r\n    if (ssl.getEnabled()) {\r\n        builder = builder.sslEnabled(true);\r\n        if (ssl.getKeyStore() != null) {\r\n            builder = builder.sslKeystoreFile(ssl.getKeyStore());\r\n        }\r\n        if (ssl.getKeyStorePassword() != null) {\r\n            builder = builder.sslKeystorePassword(ssl.getKeyStorePassword());\r\n        }\r\n    }\r\n    return builder;\r\n}"
}, {
	"Path": "spark.resource.ClassPathResource.hashCode",
	"Comment": "this implementation returns the hash code of the underlyingclass path location.",
	"Method": "int hashCode(){\r\n    return this.path.hashCode();\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.context.properties.ConfigurationPropertiesReportEndpoint.sanitize",
	"Comment": "sanitize all unwanted configuration properties to avoid leaking of sensitive\tinformation.",
	"Method": "Map<String, Object> sanitize(String prefix,Map<String, Object> map,List<Object> sanitize,String prefix,List<Object> list){\r\n    List<Object> sanitized = new ArrayList();\r\n    for (Object item : list) {\r\n        if (item instanceof Map) {\r\n            sanitized.add(sanitize(prefix, (Map<String, Object>) item));\r\n        } else if (item instanceof List) {\r\n            sanitized.add(sanitize(prefix, (List<Object>) item));\r\n        } else {\r\n            sanitized.add(this.sanitizer.sanitize(prefix, item));\r\n        }\r\n    }\r\n    return sanitized;\r\n}"
}, {
	"Path": "org.b3log.solo.processor.console.PreferenceConsole.isInvalid",
	"Comment": "checks whether the specified preference is invalid and sets the specified response object.",
	"Method": "boolean isInvalid(JSONObject preference,JSONObject responseObject){\r\n    responseObject.put(Keys.STATUS_CODE, false);\r\n    final StringBuilder errMsgBuilder = new StringBuilder('[' + langPropsService.get(\"paramSettingsLabel\"));\r\n    errMsgBuilder.append(\" - \");\r\n    String input = preference.optString(Option.ID_C_EXTERNAL_RELEVANT_ARTICLES_DISPLAY_CNT);\r\n    if (!isNonNegativeInteger(input)) {\r\n        errMsgBuilder.append(langPropsService.get(\"externalRelevantArticlesDisplayCntLabel\")).append(\"]  \").append(langPropsService.get(\"nonNegativeIntegerOnlyLabel\"));\r\n        responseObject.put(Keys.MSG, errMsgBuilder.toString());\r\n        return true;\r\n    }\r\n    input = preference.optString(Option.ID_C_RELEVANT_ARTICLES_DISPLAY_CNT);\r\n    if (!isNonNegativeInteger(input)) {\r\n        errMsgBuilder.append(langPropsService.get(\"relevantArticlesDisplayCntLabel\")).append(\"]  \").append(langPropsService.get(\"nonNegativeIntegerOnlyLabel\"));\r\n        responseObject.put(Keys.MSG, errMsgBuilder.toString());\r\n        return true;\r\n    }\r\n    input = preference.optString(Option.ID_C_RANDOM_ARTICLES_DISPLAY_CNT);\r\n    if (!isNonNegativeInteger(input)) {\r\n        errMsgBuilder.append(langPropsService.get(\"randomArticlesDisplayCntLabel\")).append(\"]  \").append(langPropsService.get(\"nonNegativeIntegerOnlyLabel\"));\r\n        responseObject.put(Keys.MSG, errMsgBuilder.toString());\r\n        return true;\r\n    }\r\n    input = preference.optString(Option.ID_C_MOST_COMMENT_ARTICLE_DISPLAY_CNT);\r\n    if (!isNonNegativeInteger(input)) {\r\n        errMsgBuilder.append(langPropsService.get(\"indexMostCommentArticleDisplayCntLabel\")).append(\"]  \").append(langPropsService.get(\"nonNegativeIntegerOnlyLabel\"));\r\n        responseObject.put(Keys.MSG, errMsgBuilder.toString());\r\n        return true;\r\n    }\r\n    input = preference.optString(Option.ID_C_MOST_VIEW_ARTICLE_DISPLAY_CNT);\r\n    if (!isNonNegativeInteger(input)) {\r\n        errMsgBuilder.append(langPropsService.get(\"indexMostViewArticleDisplayCntLabel\")).append(\"]  \").append(langPropsService.get(\"nonNegativeIntegerOnlyLabel\"));\r\n        responseObject.put(Keys.MSG, errMsgBuilder.toString());\r\n        return true;\r\n    }\r\n    input = preference.optString(Option.ID_C_RECENT_COMMENT_DISPLAY_CNT);\r\n    if (!isNonNegativeInteger(input)) {\r\n        errMsgBuilder.append(langPropsService.get(\"indexRecentCommentDisplayCntLabel\")).append(\"]  \").append(langPropsService.get(\"nonNegativeIntegerOnlyLabel\"));\r\n        responseObject.put(Keys.MSG, errMsgBuilder.toString());\r\n        return true;\r\n    }\r\n    input = preference.optString(Option.ID_C_MOST_USED_TAG_DISPLAY_CNT);\r\n    if (!isNonNegativeInteger(input)) {\r\n        errMsgBuilder.append(langPropsService.get(\"indexTagDisplayCntLabel\")).append(\"]  \").append(langPropsService.get(\"nonNegativeIntegerOnlyLabel\"));\r\n        responseObject.put(Keys.MSG, errMsgBuilder.toString());\r\n        return true;\r\n    }\r\n    input = preference.optString(Option.ID_C_ARTICLE_LIST_DISPLAY_COUNT);\r\n    if (!isNonNegativeInteger(input)) {\r\n        errMsgBuilder.append(langPropsService.get(\"pageSizeLabel\")).append(\"]  \").append(langPropsService.get(\"nonNegativeIntegerOnlyLabel\"));\r\n        responseObject.put(Keys.MSG, errMsgBuilder.toString());\r\n        return true;\r\n    }\r\n    input = preference.optString(Option.ID_C_ARTICLE_LIST_PAGINATION_WINDOW_SIZE);\r\n    if (!isNonNegativeInteger(input)) {\r\n        errMsgBuilder.append(langPropsService.get(\"windowSizeLabel\")).append(\"]  \").append(langPropsService.get(\"nonNegativeIntegerOnlyLabel\"));\r\n        responseObject.put(Keys.MSG, errMsgBuilder.toString());\r\n        return true;\r\n    }\r\n    input = preference.optString(Option.ID_C_FEED_OUTPUT_CNT);\r\n    if (!isNonNegativeInteger(input)) {\r\n        errMsgBuilder.append(langPropsService.get(\"feedOutputCntLabel\")).append(\"]  \").append(langPropsService.get(\"nonNegativeIntegerOnlyLabel\"));\r\n        responseObject.put(Keys.MSG, errMsgBuilder.toString());\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.DynamicRegistrationBean.getOrDeduceName",
	"Comment": "deduces the name for this registration. will return user specified name or fallback\tto convention based naming.",
	"Method": "String getOrDeduceName(Object value){\r\n    return (this.name != null) ? this.name : Conventions.getVariableName(value);\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.livereload.LiveReloadServerTests.main",
	"Comment": "useful main method for manual testing against a real browser.",
	"Method": "void main(String[] args){\r\n    LiveReloadServer server = new LiveReloadServer();\r\n    server.start();\r\n    while (true) {\r\n        try {\r\n            Thread.sleep(1000);\r\n        } catch (InterruptedException ex) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n        server.triggerReload();\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.processor.ArticleProcessor.getArchivesArticlesPagedCurrentPageNum",
	"Comment": "gets the request page number from the specified request uri.",
	"Method": "int getArchivesArticlesPagedCurrentPageNum(String requestURI){\r\n    return Requests.getCurrentPageNum(StringUtils.substringAfterLast(requestURI, \"/\"));\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BindResult.orElseCreate",
	"Comment": "return the object that was bound, or a new instance of the specified class if no\tvalue has been bound.",
	"Method": "T orElseCreate(Class<? extends T> type){\r\n    Assert.notNull(type, \"Type must not be null\");\r\n    return (this.value != null) ? this.value : BeanUtils.instantiateClass(type);\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BindResult.map",
	"Comment": "apply the provided mapping function to the bound value, or return an updated\tunbound result if no value has been bound.",
	"Method": "BindResult<U> map(Function<? super T, ? extends U> mapper){\r\n    Assert.notNull(mapper, \"Mapper must not be null\");\r\n    return of((this.value != null) ? mapper.apply(this.value) : null);\r\n}"
}, {
	"Path": "spark.resource.AbstractResource.getURL",
	"Comment": "this implementation throws a filenotfoundexception, assumingthat the resource cannot be resolved to a url.",
	"Method": "URL getURL(){\r\n    throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL\");\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.jdbc.DataSourceProperties.determineUsername",
	"Comment": "determine the username to use based on this configuration and the environment.",
	"Method": "String determineUsername(){\r\n    if (StringUtils.hasText(this.username)) {\r\n        return this.username;\r\n    }\r\n    if (EmbeddedDatabaseConnection.isEmbedded(determineDriverClassName())) {\r\n        return \"sa\";\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.b3log.solo.service.PageMgmtService.changeOrder",
	"Comment": "changes the order of a page specified by the given page id with the specified direction.",
	"Method": "void changeOrder(String pageId,String direction){\r\n    final Transaction transaction = pageRepository.beginTransaction();\r\n    try {\r\n        final JSONObject srcPage = pageRepository.get(pageId);\r\n        final int srcPageOrder = srcPage.getInt(Page.PAGE_ORDER);\r\n        JSONObject targetPage;\r\n        if (\"up\".equals(direction)) {\r\n            targetPage = pageRepository.getUpper(pageId);\r\n        } else {\r\n            targetPage = pageRepository.getUnder(pageId);\r\n        }\r\n        if (null == targetPage) {\r\n            if (transaction.isActive()) {\r\n                transaction.rollback();\r\n            }\r\n            LOGGER.log(Level.WARN, \"Cant not find the target page of source page[order={0}]\", srcPageOrder);\r\n            return;\r\n        }\r\n        srcPage.put(Page.PAGE_ORDER, targetPage.getInt(Page.PAGE_ORDER));\r\n        targetPage.put(Page.PAGE_ORDER, srcPageOrder);\r\n        pageRepository.update(srcPage.getString(Keys.OBJECT_ID), srcPage);\r\n        pageRepository.update(targetPage.getString(Keys.OBJECT_ID), targetPage);\r\n        transaction.commit();\r\n    } catch (final Exception e) {\r\n        if (transaction.isActive()) {\r\n            transaction.rollback();\r\n        }\r\n        LOGGER.log(Level.ERROR, \"Changes page's order failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.PluginMgmtService.setLangPropsService",
	"Comment": "sets the language service with the specified language service.",
	"Method": "void setLangPropsService(LangPropsService langPropsService){\r\n    this.langPropsService = langPropsService;\r\n}"
}, {
	"Path": "org.springframework.boot.SpringApplication.getMainApplicationClass",
	"Comment": "returns the main application class that has been deduced or explicitly configured.",
	"Method": "Class<?> getMainApplicationClass(){\r\n    return this.mainApplicationClass;\r\n}"
}, {
	"Path": "org.openqa.grid.web.servlet.RegistrationServletTest.testInvalidV2Registration",
	"Comment": "tests that the registration request servlet throws an error for a request without a proxyconfiguration",
	"Method": "void testInvalidV2Registration(){\r\n    requestWithoutConfig.put(\"capabilities\", singletonList(new FirefoxOptions()));\r\n    requestWithoutConfig.put(\"id\", \"http://dummynode:1111\");\r\n    assertThatExceptionOfType(GridConfigurationException.class).isThrownBy(() -> sendCommand(\"POST\", \"/\", requestWithoutConfig));\r\n}"
}, {
	"Path": "spark.resource.ClassPathResource.getURL",
	"Comment": "this implementation returns a url for the underlying class path resource.",
	"Method": "URL getURL(){\r\n    URL url;\r\n    if (this.clazz != null) {\r\n        url = this.clazz.getResource(this.path);\r\n    } else {\r\n        url = this.classLoader.getResource(this.path);\r\n    }\r\n    if (url == null) {\r\n        throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL because it does not exist\");\r\n    }\r\n    return url;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationprocessor.json.JSONObject.names",
	"Comment": "returns an array containing the string names in this object. this method returns\tnull if this object contains no mappings.",
	"Method": "JSONArray names(){\r\n    return this.nameValuePairs.isEmpty() ? null : new JSONArray(new ArrayList(this.nameValuePairs.keySet()));\r\n}"
}, {
	"Path": "org.springframework.boot.configurationmetadata.ConfigurationMetadataGroup.getId",
	"Comment": "return the id of the group, used as a common prefix for all properties associated\tto it.",
	"Method": "String getId(){\r\n    return this.id;\r\n}"
}, {
	"Path": "org.springframework.boot.web.embedded.netty.NettyReactiveWebServerFactory.setLifecycleTimeout",
	"Comment": "set the maximum amount of time that should be waited when starting or stopping the\tserver.",
	"Method": "void setLifecycleTimeout(Duration lifecycleTimeout){\r\n    this.lifecycleTimeout = lifecycleTimeout;\r\n}"
}, {
	"Path": "spark.http.matching.Halt.modify",
	"Comment": "modifies the http response and body based on the provided haltexception.",
	"Method": "void modify(HttpServletResponse httpResponse,Body body,HaltException halt){\r\n    httpResponse.setStatus(halt.statusCode());\r\n    if (halt.body() != null) {\r\n        body.set(halt.body());\r\n    } else {\r\n        body.set(\"\");\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.UserQueryService.setUserMgmtService",
	"Comment": "sets the user management service with the specified user management service.",
	"Method": "void setUserMgmtService(UserMgmtService userMgmtService){\r\n    this.userMgmtService = userMgmtService;\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.AbstractJsonMarshalTester.parseObject",
	"Comment": "return the object created from parsing the specific json string.",
	"Method": "T parseObject(byte[] jsonBytes,T parseObject,String jsonString){\r\n    verify();\r\n    return parse(jsonString).getObject();\r\n}"
}, {
	"Path": "org.springframework.boot.builder.SpringApplicationBuilder.parent",
	"Comment": "add an already running parent context to an existing application.",
	"Method": "SpringApplicationBuilder parent(Class<?> sources,SpringApplicationBuilder parent,ConfigurableApplicationContext parent){\r\n    this.parent = new SpringApplicationBuilder();\r\n    this.parent.context = parent;\r\n    this.parent.running.set(true);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.jta.atomikos.AtomikosProperties.setLogBaseDir",
	"Comment": "specifies the directory in which the log files should be stored. defaults to the\tcurrent working directory. this directory should be a stable storage like a san,\traid or at least backed up location. the transactions logs files are as important\tas the data themselves to guarantee consistency in case of failures.",
	"Method": "void setLogBaseDir(String logBaseDir){\r\n    this.logBaseDir = logBaseDir;\r\n}"
}, {
	"Path": "org.springframework.boot.web.embedded.jetty.JettyServletWebServerFactory.getMimeTypeConfiguration",
	"Comment": "create a configuration object that adds mime type mappings.",
	"Method": "Configuration getMimeTypeConfiguration(){\r\n    return new AbstractConfiguration() {\r\n        @Override\r\n        public void configure(WebAppContext context) throws Exception {\r\n            MimeTypes mimeTypes = context.getMimeTypes();\r\n            for (MimeMappings.Mapping mapping : getMimeMappings()) {\r\n                mimeTypes.addMimeMapping(mapping.getExtension(), mapping.getMimeType());\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.springframework.boot.web.embedded.jetty.JettyServletWebServerFactory.getMimeTypeConfiguration",
	"Comment": "create a configuration object that adds mime type mappings.",
	"Method": "Configuration getMimeTypeConfiguration(){\r\n    MimeTypes mimeTypes = context.getMimeTypes();\r\n    for (MimeMappings.Mapping mapping : getMimeMappings()) {\r\n        mimeTypes.addMimeMapping(mapping.getExtension(), mapping.getMimeType());\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport.recordEvaluationCandidates",
	"Comment": "records the names of the classes that are candidates for condition evaluation.",
	"Method": "void recordEvaluationCandidates(List<String> evaluationCandidates){\r\n    Assert.notNull(evaluationCandidates, \"evaluationCandidates must not be null\");\r\n    this.unconditionalClasses.addAll(evaluationCandidates);\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.isEndpointExposed",
	"Comment": "determine if an endpoint bean should be exposed. subclasses can override this\tmethod to provide additional logic.",
	"Method": "boolean isEndpointExposed(EndpointBean endpointBean,boolean isEndpointExposed,Object endpointBean){\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BeanPropertyName.toDashedForm",
	"Comment": "return the specified java bean property name in dashed form.",
	"Method": "String toDashedForm(String name,String toDashedForm,String name,int start){\r\n    StringBuilder result = new StringBuilder();\r\n    char[] chars = name.replace(\"_\", \"-\").toCharArray();\r\n    for (int i = start; i < chars.length; i++) {\r\n        char ch = chars[i];\r\n        if (Character.isUpperCase(ch) && result.length() > 0 && result.charAt(result.length() - 1) != '-') {\r\n            result.append(\"-\");\r\n        }\r\n        result.append(Character.toLowerCase(ch));\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentMgmtService.setArticleMgmtService",
	"Comment": "sets the article management service with the specified article management service.",
	"Method": "void setArticleMgmtService(ArticleMgmtService articleMgmtService){\r\n    this.articleMgmtService = articleMgmtService;\r\n}"
}, {
	"Path": "org.b3log.solo.repository.CommentRepository.removeForUnpublishedArticles",
	"Comment": "removes comments of unpublished articles for the specified comments.",
	"Method": "void removeForUnpublishedArticles(List<JSONObject> comments){\r\n    LOGGER.debug(\"Removing unpublished articles' comments....\");\r\n    final Iterator<JSONObject> iterator = comments.iterator();\r\n    while (iterator.hasNext()) {\r\n        final JSONObject comment = iterator.next();\r\n        final String commentOnType = comment.optString(Comment.COMMENT_ON_TYPE);\r\n        if (Article.ARTICLE.equals(commentOnType)) {\r\n            final String articleId = comment.optString(Comment.COMMENT_ON_ID);\r\n            if (!articleRepository.isPublished(articleId)) {\r\n                iterator.remove();\r\n            }\r\n        }\r\n    }\r\n    LOGGER.debug(\"Removed unpublished articles' comments....\");\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.server.AbstractServletWebServerFactory.isRegisterDefaultServlet",
	"Comment": "flag to indicate that the default servlet should be registered.",
	"Method": "boolean isRegisterDefaultServlet(){\r\n    return this.registerDefaultServlet;\r\n}"
}, {
	"Path": "org.b3log.solo.service.PageMgmtService.setStatisticMgmtService",
	"Comment": "sets the statistic management service with the specified statistic management service.",
	"Method": "void setStatisticMgmtService(StatisticMgmtService statisticMgmtService){\r\n    this.statisticMgmtService = statisticMgmtService;\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.setTagMgmtService",
	"Comment": "sets tag management service with the specified tag management service.",
	"Method": "void setTagMgmtService(TagMgmtService tagMgmtService){\r\n    this.tagMgmtService = tagMgmtService;\r\n}"
}, {
	"Path": "spark.CustomErrorPages.existsFor",
	"Comment": "verifies that a custom error page exists for the given status code",
	"Method": "boolean existsFor(int status){\r\n    return CustomErrorPages.getInstance().customPages.containsKey(status);\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.restart.Restarter.clearInstance",
	"Comment": "clear the instance. primarily provided for tests and not usually used in\tapplication code.",
	"Method": "void clearInstance(){\r\n    synchronized (INSTANCE_MONITOR) {\r\n        instance = null;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport.getExclusions",
	"Comment": "returns the names of the classes that have been excluded from condition evaluation.",
	"Method": "List<String> getExclusions(){\r\n    return Collections.unmodifiableList(this.exclusions);\r\n}"
}, {
	"Path": "org.b3log.solo.service.InitService.setLangPropsService",
	"Comment": "sets the language service with the specified language service.",
	"Method": "void setLangPropsService(LangPropsService langPropsService){\r\n    this.langPropsService = langPropsService;\r\n}"
}, {
	"Path": "org.b3log.solo.service.StatisticMgmtService.setArticleRepository",
	"Comment": "sets the article repository with the specified article repository.",
	"Method": "void setArticleRepository(ArticleRepository articleRepository){\r\n    this.articleRepository = articleRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.autoconfigure.metrics.MeterValue.getValue",
	"Comment": "return the underlying value of the sla in form suitable to apply to the given meter\ttype.",
	"Method": "Long getValue(Type meterType){\r\n    if (meterType == Type.DISTRIBUTION_SUMMARY) {\r\n        return getDistributionSummaryValue();\r\n    }\r\n    if (meterType == Type.TIMER) {\r\n        return getTimerValue();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.tunnel.server.HttpTunnelServer.getServerThread",
	"Comment": "returns the active server thread, creating and starting it if necessary.",
	"Method": "ServerThread getServerThread(){\r\n    synchronized (this) {\r\n        if (this.serverThread == null) {\r\n            ByteChannel channel = this.serverConnection.open(this.longPollTimeout);\r\n            this.serverThread = new ServerThread(channel);\r\n            this.serverThread.start();\r\n        }\r\n        return this.serverThread;\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.repository.ArticleRepository.getByAuthorId",
	"Comment": "gets published articles by the specified author id, current page number and page size.",
	"Method": "JSONObject getByAuthorId(String authorId,int currentPageNum,int pageSize){\r\n    final Query query = new Query().setFilter(CompositeFilterOperator.and(new PropertyFilter(Article.ARTICLE_AUTHOR_ID, FilterOperator.EQUAL, authorId), new PropertyFilter(Article.ARTICLE_IS_PUBLISHED, FilterOperator.EQUAL, true))).addSort(Article.ARTICLE_UPDATED, SortDirection.DESCENDING).addSort(Article.ARTICLE_PUT_TOP, SortDirection.DESCENDING).setCurrentPageNum(currentPageNum).setPageSize(pageSize).setPageCount(1);\r\n    return get(query);\r\n}"
}, {
	"Path": "org.springframework.boot.diagnostics.AbstractFailureAnalyzer.getCauseType",
	"Comment": "return the cause type being handled by the analyzer. by default the class generic\tis used.",
	"Method": "Class<? extends T> getCauseType(){\r\n    return (Class<? extends T>) ResolvableType.forClass(AbstractFailureAnalyzer.class, getClass()).resolveGeneric();\r\n}"
}, {
	"Path": "org.b3log.solo.util.Skins.getSkinTemplate",
	"Comment": "gets a skins template with the specified request and template name.",
	"Method": "Template getSkinTemplate(HttpServletRequest request,String templateName){\r\n    String templateDirName = (String) request.getAttribute(Keys.TEMAPLTE_DIR_NAME);\r\n    if (StringUtils.isBlank(templateDirName)) {\r\n        templateDirName = Option.DefaultPreference.DEFAULT_SKIN_DIR_NAME;\r\n    }\r\n    try {\r\n        return Skins.TEMPLATE_CFG.getTemplate(\"skins/\" + templateDirName + \"/\" + templateName);\r\n    } catch (final IOException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.repository.CategoryRepository.getUpper",
	"Comment": "gets the upper category of the category specified by the given id.",
	"Method": "JSONObject getUpper(String id){\r\n    final JSONObject category = get(id);\r\n    if (null == category) {\r\n        return null;\r\n    }\r\n    final Query query = new Query().setFilter(new PropertyFilter(Category.CATEGORY_ORDER, FilterOperator.LESS_THAN, category.optInt(Category.CATEGORY_ORDER))).addSort(Category.CATEGORY_ORDER, SortDirection.DESCENDING).setCurrentPageNum(1).setPageSize(1);\r\n    final JSONObject result = get(query);\r\n    final JSONArray array = result.optJSONArray(Keys.RESULTS);\r\n    if (1 != array.length()) {\r\n        return null;\r\n    }\r\n    return array.optJSONObject(0);\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.web.mappings.servlet.RegistrationMappingDescription.getClassName",
	"Comment": "returns the class name of the registered filter or servlet.",
	"Method": "String getClassName(){\r\n    return this.registration.getClassName();\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.ConfigurationPropertiesTests.removeSystemProperties",
	"Comment": "strict tests need a known set of properties so we remove system items which may be\tenvironment specific.",
	"Method": "void removeSystemProperties(){\r\n    MutablePropertySources sources = this.context.getEnvironment().getPropertySources();\r\n    sources.remove(\"systemProperties\");\r\n    sources.remove(\"systemEnvironment\");\r\n}"
}, {
	"Path": "org.b3log.solo.service.PermalinkQueryService.setArticleRepository",
	"Comment": "sets the article repository with the specified article repository.",
	"Method": "void setArticleRepository(ArticleRepository articleRepository){\r\n    this.articleRepository = articleRepository;\r\n}"
}, {
	"Path": "org.b3log.solo.processor.ArticleProcessor.prepareShowAuthorArticles",
	"Comment": "prepares the specified data model for rendering author articles.",
	"Method": "void prepareShowAuthorArticles(List<Integer> pageNums,Map<String, Object> dataModel,int pageCount,int currentPageNum,List<JSONObject> articles,JSONObject author){\r\n    if (0 != pageNums.size()) {\r\n        dataModel.put(Pagination.PAGINATION_FIRST_PAGE_NUM, pageNums.get(0));\r\n        dataModel.put(Pagination.PAGINATION_LAST_PAGE_NUM, pageNums.get(pageNums.size() - 1));\r\n    }\r\n    dataModel.put(Pagination.PAGINATION_PAGE_COUNT, pageCount);\r\n    dataModel.put(Pagination.PAGINATION_PAGE_NUMS, pageNums);\r\n    dataModel.put(Pagination.PAGINATION_CURRENT_PAGE_NUM, currentPageNum);\r\n    final String previousPageNum = Integer.toString(currentPageNum > 1 ? currentPageNum - 1 : 0);\r\n    dataModel.put(Pagination.PAGINATION_PREVIOUS_PAGE_NUM, \"0\".equals(previousPageNum) ? \"\" : previousPageNum);\r\n    if (pageCount == currentPageNum + 1) {\r\n        dataModel.put(Pagination.PAGINATION_NEXT_PAGE_NUM, \"\");\r\n    } else {\r\n        dataModel.put(Pagination.PAGINATION_NEXT_PAGE_NUM, currentPageNum + 1);\r\n    }\r\n    dataModel.put(Article.ARTICLES, articles);\r\n    final String authorId = author.optString(Keys.OBJECT_ID);\r\n    dataModel.put(Common.PATH, \"/authors/\" + authorId);\r\n    dataModel.put(Keys.OBJECT_ID, authorId);\r\n    dataModel.put(Common.AUTHOR_NAME, author.optString(User.USER_NAME));\r\n    final String userAvatar = author.optString(UserExt.USER_AVATAR);\r\n    if (StringUtils.isNotBlank(userAvatar)) {\r\n        dataModel.put(Common.AUTHOR_THUMBNAIL_URL, userAvatar);\r\n    } else {\r\n        final String thumbnailURL = Solos.getGravatarURL(author.optString(User.USER_EMAIL), \"128\");\r\n        dataModel.put(Common.AUTHOR_THUMBNAIL_URL, thumbnailURL);\r\n    }\r\n    dataModel.put(Pagination.PAGINATION_CURRENT_PAGE_NUM, currentPageNum);\r\n}"
}, {
	"Path": "spark.QueryParamsMap.value",
	"Comment": "returns the value for this key. if this key has nested elements and does not have a value returns null.",
	"Method": "String value(String value,String keys){\r\n    return get(keys).value();\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.Bindable.getAnnotation",
	"Comment": "return a single associated annotations that could affect binding.",
	"Method": "A getAnnotation(Class<A> type){\r\n    for (Annotation annotation : this.annotations) {\r\n        if (type.isInstance(annotation)) {\r\n            return (A) annotation;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.validation.ValidationErrors.getBoundProperties",
	"Comment": "return the properties that were bound before validation failed.",
	"Method": "Set<ConfigurationProperty> getBoundProperties(){\r\n    return this.boundProperties;\r\n}"
}, {
	"Path": "spark.resource.ClassPathResource.equals",
	"Comment": "this implementation compares the underlying class path locations.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == this) {\r\n        return true;\r\n    }\r\n    if (obj instanceof ClassPathResource) {\r\n        ClassPathResource otherRes = (ClassPathResource) obj;\r\n        ClassLoader thisLoader = this.classLoader;\r\n        ClassLoader otherLoader = otherRes.classLoader;\r\n        return (this.path.equals(otherRes.path) && thisLoader.equals(otherLoader) && this.clazz.equals(otherRes.clazz));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "spark.RouteImpl.render",
	"Comment": "this method should render the given element into something that can be send through response element.by default this method returns the result of calling tostring method in given element, but can be overridden.",
	"Method": "Object render(Object element){\r\n    return element;\r\n}"
}, {
	"Path": "spark.Spark.webSocketIdleTimeoutMillis",
	"Comment": "sets the max idle timeout in milliseconds for websocket connections.",
	"Method": "void webSocketIdleTimeoutMillis(int timeoutMillis){\r\n    getInstance().webSocketIdleTimeoutMillis(timeoutMillis);\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleQueryService.setArchiveDateArticleRepository",
	"Comment": "sets archive date article repository with the specified archive date article repository.",
	"Method": "void setArchiveDateArticleRepository(ArchiveDateArticleRepository archiveDateArticleRepository){\r\n    this.archiveDateArticleRepository = archiveDateArticleRepository;\r\n}"
}, {
	"Path": "org.b3log.solo.model.Comment.getCommentSharpURLForArticle",
	"Comment": "gets comment sharp url with the specified article and comment id.",
	"Method": "String getCommentSharpURLForArticle(JSONObject article,String commentId){\r\n    return article.getString(Article.ARTICLE_PERMALINK) + \"#\" + commentId;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.audit.AuditEvent.getPrincipal",
	"Comment": "returns the user principal responsible for the event or an empty string if the\tprincipal is not available.",
	"Method": "String getPrincipal(){\r\n    return this.principal;\r\n}"
}, {
	"Path": "org.b3log.solo.util.Solos.getGravatarURL",
	"Comment": "gets the gravatar url for the specified email with the specified size.",
	"Method": "String getGravatarURL(String email,String size){\r\n    return GRAVATAR + DigestUtils.md5Hex(email) + \"?s=\" + size;\r\n}"
}, {
	"Path": "org.b3log.solo.service.OptionQueryService.setOptionRepository",
	"Comment": "sets the option repository with the specified option repository.",
	"Method": "void setOptionRepository(OptionRepository optionRepository){\r\n    this.optionRepository = optionRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.server.AbstractServletWebServerFactory.getDocumentRoot",
	"Comment": "returns the document root which will be used by the web context to serve static\tfiles.",
	"Method": "File getDocumentRoot(){\r\n    return this.documentRoot.getDirectory();\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.updateArticlesRandomValue",
	"Comment": "updates the random values of articles fetched with the specified updatecount.",
	"Method": "void updateArticlesRandomValue(int updateCnt){\r\n    final Transaction transaction = articleRepository.beginTransaction();\r\n    try {\r\n        final List<JSONObject> randomArticles = articleRepository.getRandomly(updateCnt);\r\n        for (final JSONObject article : randomArticles) {\r\n            article.put(Article.ARTICLE_RANDOM_DOUBLE, Math.random());\r\n            articleRepository.update(article.getString(Keys.OBJECT_ID), article);\r\n        }\r\n        transaction.commit();\r\n    } catch (final Exception e) {\r\n        if (transaction.isActive()) {\r\n            transaction.rollback();\r\n        }\r\n        LOGGER.log(Level.WARN, \"Updates article random value failed\");\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "spark.Spark.defaultResponseTransformer",
	"Comment": "set the default response transformer. all requests not using a custom transformer will use this one",
	"Method": "void defaultResponseTransformer(ResponseTransformer transformer){\r\n    getInstance().defaultResponseTransformer(transformer);\r\n}"
}, {
	"Path": "org.openqa.grid.internal.utils.DefaultCapabilityMatcherTest.unknownPlatformMatchingTestWithDeprecatedPlatformCapability",
	"Comment": "todo remove test when capabilitytype.platform is removed from code base",
	"Method": "void unknownPlatformMatchingTestWithDeprecatedPlatformCapability(){\r\n    Map<String, Object> requested = ImmutableMap.of(CapabilityType.PLATFORM, \"ms-dos\");\r\n    assertTrue(matcher.matches(ImmutableMap.of(CapabilityType.PLATFORM, \"ms-dos\"), requested));\r\n    assertFalse(matcher.matches(ImmutableMap.of(CapabilityType.PLATFORM, \"windows\"), requested));\r\n    assertFalse(matcher.matches(ImmutableMap.of(CapabilityType.PLATFORM, \"PS/2\"), requested));\r\n}"
}, {
	"Path": "org.openqa.grid.web.servlet.RegistrationServletTest.testV3Registration",
	"Comment": "tests that the registration request servlet can process a v3 registrationrequest",
	"Method": "void testV3Registration(){\r\n    final GridNodeConfiguration config = new GridNodeConfiguration();\r\n    config.id = \"http://dummynode:3456\";\r\n    final RegistrationRequest request = RegistrationRequest.build(config);\r\n    request.getConfiguration().proxy = null;\r\n    final FakeHttpServletResponse response = sendCommand(\"POST\", \"/\", request.toJson());\r\n    waitForServletToAddProxy();\r\n    assertEquals(HttpServletResponse.SC_OK, response.getStatus());\r\n    assertEquals(((RegistrationServlet) servlet).getRegistry().getAllProxies().size(), 1);\r\n    final RemoteProxy proxy = ((RegistrationServlet) servlet).getRegistry().getAllProxies().getProxyById(request.getConfiguration().id);\r\n    assertNotNull(proxy);\r\n    assertEquals(request.getConfiguration().capabilities.size(), proxy.getConfig().capabilities.size());\r\n    assertEquals(request.getConfiguration().registerCycle, proxy.getConfig().registerCycle);\r\n    assertEquals(request.getConfiguration().id, proxy.getConfig().id);\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentMgmtService.setArticleRepository",
	"Comment": "sets the article repository with the specified article repository.",
	"Method": "void setArticleRepository(ArticleRepository articleRepository){\r\n    this.articleRepository = articleRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.source.ConfigurationPropertySource.withAliases",
	"Comment": "return a variant of this source that supports name aliases.",
	"Method": "ConfigurationPropertySource withAliases(ConfigurationPropertyNameAliases aliases){\r\n    return new AliasedConfigurationPropertySource(this, aliases);\r\n}"
}, {
	"Path": "spark.resource.ClassPathResource.exists",
	"Comment": "this implementation checks for the resolution of a resource url.",
	"Method": "boolean exists(){\r\n    URL url;\r\n    if (this.clazz != null) {\r\n        url = this.clazz.getResource(this.path);\r\n    } else {\r\n        url = this.classLoader.getResource(this.path);\r\n    }\r\n    return (url != null);\r\n}"
}, {
	"Path": "org.openqa.grid.internal.utils.DefaultCapabilityMatcherTest.shouldMatchRegularSafariOnlyWithDeprecatedPlatformCapability",
	"Comment": "todo remove test when capabilitytype.platform is removed from code base",
	"Method": "void shouldMatchRegularSafariOnlyWithDeprecatedPlatformCapability(){\r\n    Map<String, Object> requested = new SafariOptions().asMap();\r\n    Map<String, Object> tpNode = new HashMap();\r\n    tpNode.put(CapabilityType.BROWSER_NAME, BrowserType.SAFARI);\r\n    tpNode.put(CapabilityType.PLATFORM, Platform.MAC);\r\n    tpNode.put(\"technologyPreview\", true);\r\n    Map<String, Object> regularNode = new HashMap();\r\n    regularNode.put(CapabilityType.BROWSER_NAME, BrowserType.SAFARI);\r\n    regularNode.put(CapabilityType.PLATFORM, Platform.MAC);\r\n    assertFalse(matcher.matches(tpNode, requested));\r\n    assertTrue(matcher.matches(regularNode, requested));\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.setArchiveDateArticleRepository",
	"Comment": "sets archive date article repository with the specified archive date article repository.",
	"Method": "void setArchiveDateArticleRepository(ArchiveDateArticleRepository archiveDateArticleRepository){\r\n    this.archiveDateArticleRepository = archiveDateArticleRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.jdbc.DataSourceHealthIndicator.setQuery",
	"Comment": "set a specific validation query to use to validate a connection. if none is set, a\tdefault validation query is used.",
	"Method": "void setQuery(String query){\r\n    this.query = query;\r\n}"
}, {
	"Path": "org.b3log.solo.service.TagMgmtService.setTagQueryService",
	"Comment": "sets the tag query service with the specified tag query service.",
	"Method": "void setTagQueryService(TagQueryService tagQueryService){\r\n    this.tagQueryService = tagQueryService;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BindException.getProperty",
	"Comment": "return the configuration property name of the item that was being bound.",
	"Method": "ConfigurationProperty getProperty(){\r\n    return this.property;\r\n}"
}, {
	"Path": "org.b3log.solo.service.UserMgmtService.setUserRepository",
	"Comment": "sets the user repository with the specified user repository.",
	"Method": "void setUserRepository(UserRepository userRepository){\r\n    this.userRepository = userRepository;\r\n}"
}, {
	"Path": "org.b3log.solo.service.PageMgmtService.setCommentRepository",
	"Comment": "sets the comment repository with the specified comment repository.",
	"Method": "void setCommentRepository(CommentRepository commentRepository){\r\n    this.commentRepository = commentRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.BeanDefinitionLoader.setResourceLoader",
	"Comment": "set the resource loader to be used by the underlying readers and scanner.",
	"Method": "void setResourceLoader(ResourceLoader resourceLoader){\r\n    this.resourceLoader = resourceLoader;\r\n    this.xmlReader.setResourceLoader(resourceLoader);\r\n    this.scanner.setResourceLoader(resourceLoader);\r\n}"
}, {
	"Path": "org.springframework.boot.task.TaskExecutorBuilder.allowCoreThreadTimeOut",
	"Comment": "set whether core threads are allow to time out. when enabled, this enables dynamic\tgrowing and shrinking of the pool.",
	"Method": "TaskExecutorBuilder allowCoreThreadTimeOut(boolean allowCoreThreadTimeOut){\r\n    return new TaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize, allowCoreThreadTimeOut, this.keepAlive, this.threadNamePrefix, this.taskDecorator, this.customizers);\r\n}"
}, {
	"Path": "org.springframework.boot.util.LambdaSafe.callback",
	"Comment": "start a call to a single callback instance, dealing with common generic type\tconcerns and exceptions.",
	"Method": "Callback<C, A> callback(Class<C> callbackType,C callbackInstance,A argument,Object additionalArguments){\r\n    Assert.notNull(callbackType, \"CallbackType must not be null\");\r\n    Assert.notNull(callbackInstance, \"CallbackInstance must not be null\");\r\n    return new Callback(callbackType, callbackInstance, argument, additionalArguments);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.amqp.RabbitProperties.determinePort",
	"Comment": "returns the port from the first address, or the configured port if no addresses\thave been set.",
	"Method": "int determinePort(){\r\n    if (CollectionUtils.isEmpty(this.parsedAddresses)) {\r\n        return getPort();\r\n    }\r\n    Address address = this.parsedAddresses.get(0);\r\n    return address.port;\r\n}"
}, {
	"Path": "org.springframework.boot.builder.SpringApplicationBuilder.child",
	"Comment": "create a child application with the provided sources. default args and environment\tare copied down into the child, but everything else is a clean sheet.",
	"Method": "SpringApplicationBuilder child(Class<?> sources){\r\n    SpringApplicationBuilder child = new SpringApplicationBuilder();\r\n    child.sources(sources);\r\n    child.properties(this.defaultProperties).environment(this.environment).additionalProfiles(this.additionalProfiles);\r\n    child.parent = this;\r\n    web(WebApplicationType.NONE);\r\n    bannerMode(Banner.Mode.OFF);\r\n    this.application.addPrimarySources(this.sources);\r\n    return child;\r\n}"
}, {
	"Path": "org.springframework.boot.task.TaskExecutorBuilder.keepAlive",
	"Comment": "set the time limit for which threads may remain idle before being terminated.",
	"Method": "TaskExecutorBuilder keepAlive(Duration keepAlive){\r\n    return new TaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize, this.allowCoreThreadTimeOut, keepAlive, this.threadNamePrefix, this.taskDecorator, this.customizers);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.jdbc.DataSourceProperties.determineDriverClassName",
	"Comment": "determine the driver to use based on this configuration and the environment.",
	"Method": "String determineDriverClassName(){\r\n    if (StringUtils.hasText(this.driverClassName)) {\r\n        Assert.state(driverClassIsLoadable(), () -> \"Cannot load driver class: \" + this.driverClassName);\r\n        return this.driverClassName;\r\n    }\r\n    String driverClassName = null;\r\n    if (StringUtils.hasText(this.url)) {\r\n        driverClassName = DatabaseDriver.fromJdbcUrl(this.url).getDriverClassName();\r\n    }\r\n    if (!StringUtils.hasText(driverClassName)) {\r\n        driverClassName = this.embeddedDatabaseConnection.getDriverClassName();\r\n    }\r\n    if (!StringUtils.hasText(driverClassName)) {\r\n        throw new DataSourceBeanCreationException(\"Failed to determine a suitable driver class\", this, this.embeddedDatabaseConnection);\r\n    }\r\n    return driverClassName;\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.setPreferenceQueryService",
	"Comment": "sets the preference query service with the specified preference query service.",
	"Method": "void setPreferenceQueryService(PreferenceQueryService preferenceQueryService){\r\n    this.preferenceQueryService = preferenceQueryService;\r\n}"
}, {
	"Path": "org.b3log.solo.service.PermalinkQueryService.invalidArticlePermalinkFormat",
	"Comment": "checks whether the specified article permalink is invalid on format.",
	"Method": "boolean invalidArticlePermalinkFormat(String permalink){\r\n    if (StringUtils.isBlank(permalink)) {\r\n        return true;\r\n    }\r\n    if (matchDefaultArticlePermalinkFormat(permalink)) {\r\n        return false;\r\n    }\r\n    return invalidUserDefinedPermalinkFormat(permalink);\r\n}"
}, {
	"Path": "org.springframework.boot.context.config.ConfigFileApplicationListener.addPropertySources",
	"Comment": "add config file property sources to the specified environment.",
	"Method": "void addPropertySources(ConfigurableEnvironment environment,ResourceLoader resourceLoader){\r\n    RandomValuePropertySource.addToEnvironment(environment);\r\n    new Loader(environment, resourceLoader).load();\r\n}"
}, {
	"Path": "org.b3log.solo.service.InitService.setArticleRepository",
	"Comment": "sets the article repository with the specified article repository.",
	"Method": "void setArticleRepository(ArticleRepository articleRepository){\r\n    this.articleRepository = articleRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.http.HttpMessageConverters.getConverters",
	"Comment": "return an immutable list of the converters in the order that they will be\tregistered.",
	"Method": "List<HttpMessageConverter<?>> getConverters(){\r\n    return this.converters;\r\n}"
}, {
	"Path": "org.springframework.boot.BeanDefinitionLoader.setBeanNameGenerator",
	"Comment": "set the bean name generator to be used by the underlying readers and scanner.",
	"Method": "void setBeanNameGenerator(BeanNameGenerator beanNameGenerator){\r\n    this.annotatedReader.setBeanNameGenerator(beanNameGenerator);\r\n    this.xmlReader.setBeanNameGenerator(beanNameGenerator);\r\n    this.scanner.setBeanNameGenerator(beanNameGenerator);\r\n}"
}, {
	"Path": "org.b3log.solo.processor.TagProcessor.showTagArticles",
	"Comment": "shows articles related with a tag with the specified context.",
	"Method": "void showTagArticles(HTTPRequestContext context){\r\n    final AbstractFreeMarkerRenderer renderer = new SkinRenderer(context.getRequest());\r\n    context.setRenderer(renderer);\r\n    renderer.setTemplateName(\"tag-articles.ftl\");\r\n    final Map<String, Object> dataModel = renderer.getDataModel();\r\n    final HttpServletRequest request = context.getRequest();\r\n    final HttpServletResponse response = context.getResponse();\r\n    try {\r\n        String requestURI = request.getRequestURI();\r\n        if (!requestURI.endsWith(\"/\")) {\r\n            requestURI += \"/\";\r\n        }\r\n        String tagTitle = getTagTitle(requestURI);\r\n        final int currentPageNum = getCurrentPageNum(requestURI, tagTitle);\r\n        if (-1 == currentPageNum) {\r\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\r\n            return;\r\n        }\r\n        LOGGER.log(Level.DEBUG, \"Tag[title={0}, currentPageNum={1}]\", tagTitle, currentPageNum);\r\n        tagTitle = URLDecoder.decode(tagTitle, \"UTF-8\");\r\n        final JSONObject result = tagQueryService.getTagByTitle(tagTitle);\r\n        if (null == result) {\r\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\r\n            return;\r\n        }\r\n        final JSONObject tag = result.getJSONObject(Tag.TAG);\r\n        final String tagId = tag.getString(Keys.OBJECT_ID);\r\n        final JSONObject preference = preferenceQueryService.getPreference();\r\n        Skins.fillLangs(preference.optString(Option.ID_C_LOCALE_STRING), (String) request.getAttribute(Keys.TEMAPLTE_DIR_NAME), dataModel);\r\n        final int pageSize = preference.getInt(Option.ID_C_ARTICLE_LIST_DISPLAY_COUNT);\r\n        final int windowSize = preference.getInt(Option.ID_C_ARTICLE_LIST_PAGINATION_WINDOW_SIZE);\r\n        final List<JSONObject> articles = articleQueryService.getArticlesByTag(tagId, currentPageNum, pageSize);\r\n        if (articles.isEmpty()) {\r\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\r\n            return;\r\n        }\r\n        dataModelService.setArticlesExProperties(request, articles, preference);\r\n        final int tagArticleCount = tag.getInt(Tag.TAG_PUBLISHED_REFERENCE_COUNT);\r\n        final int pageCount = (int) Math.ceil((double) tagArticleCount / (double) pageSize);\r\n        LOGGER.log(Level.TRACE, \"Paginate tag-articles [currentPageNum={0}, pageSize={1}, pageCount={2}, windowSize={3}]\", currentPageNum, pageSize, pageCount, windowSize);\r\n        final List<Integer> pageNums = Paginator.paginate(currentPageNum, pageSize, pageCount, windowSize);\r\n        LOGGER.log(Level.TRACE, \"tag-articles [pageNums={0}]\", pageNums);\r\n        fillPagination(dataModel, pageCount, currentPageNum, articles, pageNums);\r\n        dataModel.put(Common.PATH, \"/tags/\" + URLEncoder.encode(tagTitle, \"UTF-8\"));\r\n        dataModel.put(Keys.OBJECT_ID, tagId);\r\n        dataModel.put(Tag.TAG, tag);\r\n        dataModelService.fillCommon(request, response, dataModel, preference);\r\n        statisticMgmtService.incBlogViewCount(request, response);\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, e.getMessage(), e);\r\n        context.sendError(HttpServletResponse.SC_NOT_FOUND);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.context.annotation.Configurations.sort",
	"Comment": "sort configuration classes into the order that they should be applied.",
	"Method": "Collection<Class<?>> sort(Collection<Class<?>> classes){\r\n    return classes;\r\n}"
}, {
	"Path": "org.b3log.solo.service.UserMgmtService.setLangPropsService",
	"Comment": "sets the language service with the specified language service.",
	"Method": "void setLangPropsService(LangPropsService langPropsService){\r\n    this.langPropsService = langPropsService;\r\n}"
}, {
	"Path": "org.springframework.boot.builder.SpringApplicationBuilder.addCommandLineProperties",
	"Comment": "flag to indicate that command line arguments should be added to the environment.",
	"Method": "SpringApplicationBuilder addCommandLineProperties(boolean addCommandLineProperties){\r\n    this.application.setAddCommandLineProperties(addCommandLineProperties);\r\n    return this;\r\n}"
}, {
	"Path": "org.b3log.solo.service.PermalinkQueryService.setPageRepository",
	"Comment": "set the page repository with the specified page repository.",
	"Method": "void setPageRepository(PageRepository pageRepository){\r\n    this.pageRepository = pageRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.SpringApplication.logStartupInfo",
	"Comment": "called to log startup information, subclasses may override to add additional\tlogging.",
	"Method": "void logStartupInfo(boolean isRoot){\r\n    if (isRoot) {\r\n        new StartupInfoLogger(this.mainApplicationClass).logStarting(getApplicationLog());\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.processor.TagProcessor.getCurrentPageNum",
	"Comment": "gets the request page number from the specified request uri and tag title.",
	"Method": "int getCurrentPageNum(String requestURI,String tagTitle){\r\n    if (StringUtils.isBlank(tagTitle)) {\r\n        return -1;\r\n    }\r\n    final String pageNumString = requestURI.substring((Latkes.getContextPath() + \"/tags/\" + tagTitle + \"/\").length());\r\n    return Requests.getCurrentPageNum(pageNumString);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.condition.ResourceCondition.getResourceOutcome",
	"Comment": "check if one of the default resource locations actually exists.",
	"Method": "ConditionOutcome getResourceOutcome(ConditionContext context,AnnotatedTypeMetadata metadata){\r\n    List<String> found = new ArrayList();\r\n    for (String location : this.resourceLocations) {\r\n        Resource resource = context.getResourceLoader().getResource(location);\r\n        if (resource != null && resource.exists()) {\r\n            found.add(location);\r\n        }\r\n    }\r\n    if (found.isEmpty()) {\r\n        ConditionMessage message = startConditionMessage().didNotFind(\"resource\", \"resources\").items(Style.QUOTE, Arrays.asList(this.resourceLocations));\r\n        return ConditionOutcome.noMatch(message);\r\n    }\r\n    ConditionMessage message = startConditionMessage().found(\"resource\", \"resources\").items(Style.QUOTE, found);\r\n    return ConditionOutcome.match(message);\r\n}"
}, {
	"Path": "org.b3log.solo.processor.CategoryProcessor.getCurrentPageNum",
	"Comment": "gets the request page number from the specified request uri and category uri.",
	"Method": "int getCurrentPageNum(String requestURI,String categoryURI){\r\n    if (StringUtils.isBlank(categoryURI)) {\r\n        return -1;\r\n    }\r\n    final String pageNumString = requestURI.substring((Latkes.getContextPath() + \"/category/\" + categoryURI + \"/\").length());\r\n    return Requests.getCurrentPageNum(pageNumString);\r\n}"
}, {
	"Path": "org.b3log.solo.processor.ArticleProcessor.getAuthorsArticlesPagedCurrentPageNum",
	"Comment": "gets the request page number from the specified request uri.",
	"Method": "int getAuthorsArticlesPagedCurrentPageNum(String requestURI){\r\n    return Requests.getCurrentPageNum(StringUtils.substringAfterLast(requestURI, \"/\"));\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentQueryService.setArticleRepository",
	"Comment": "sets the article repository with the specified article repository.",
	"Method": "void setArticleRepository(ArticleRepository articleRepository){\r\n    this.articleRepository = articleRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactoryTests.tomcatEngineNames",
	"Comment": "jmx mbean names clash if you get more than one engine with the same name...",
	"Method": "void tomcatEngineNames(){\r\n    TomcatServletWebServerFactory factory = getFactory();\r\n    this.webServer = factory.getWebServer();\r\n    factory.setPort(0);\r\n    TomcatWebServer tomcatWebServer = (TomcatWebServer) factory.getWebServer();\r\n    String firstName = ((TomcatWebServer) this.webServer).getTomcat().getEngine().getName();\r\n    String secondName = tomcatWebServer.getTomcat().getEngine().getName();\r\n    assertThat(firstName).as(\"Tomcat engines must have different names\").isNotEqualTo(secondName);\r\n    tomcatWebServer.stop();\r\n}"
}, {
	"Path": "org.b3log.solo.filter.PermalinkFilter.dispatchToArticleOrPageProcessor",
	"Comment": "dispatches the specified request to the specified article or pageprocessor with the specified response.",
	"Method": "void dispatchToArticleOrPageProcessor(ServletRequest request,ServletResponse response,JSONObject article,JSONObject page){\r\n    final HTTPRequestContext context = new HTTPRequestContext();\r\n    context.setRequest((HttpServletRequest) request);\r\n    context.setResponse((HttpServletResponse) response);\r\n    if (null != article) {\r\n        request.setAttribute(Article.ARTICLE, article);\r\n        request.setAttribute(Keys.HttpRequest.REQUEST_URI, Latkes.getContextPath() + \"/article\");\r\n    } else {\r\n        request.setAttribute(Page.PAGE, page);\r\n        request.setAttribute(Keys.HttpRequest.REQUEST_URI, Latkes.getContextPath() + \"/page\");\r\n    }\r\n    request.setAttribute(Keys.HttpRequest.REQUEST_METHOD, HTTPRequestMethod.GET.name());\r\n    final HttpControl httpControl = new HttpControl(DispatcherServlet.HANDLERS.iterator(), context);\r\n    try {\r\n        httpControl.nextHandler();\r\n    } catch (final Exception e) {\r\n        context.setRenderer(new HTTP500Renderer(e));\r\n    }\r\n    DispatcherServlet.result(context);\r\n}"
}, {
	"Path": "org.springframework.boot.cli.command.init.ServiceCapabilitiesReportGenerator.generate",
	"Comment": "generate a report for the specified service. the report contains the available\tcapabilities as advertised by the root endpoint.",
	"Method": "String generate(String url){\r\n    Object content = this.initializrService.loadServiceCapabilities(url);\r\n    if (content instanceof InitializrServiceMetadata) {\r\n        return generateHelp(url, (InitializrServiceMetadata) content);\r\n    }\r\n    return content.toString();\r\n}"
}, {
	"Path": "org.springframework.boot.cli.command.init.ProjectGenerationRequest.getDependencies",
	"Comment": "the identifiers of the dependencies to include in the project.",
	"Method": "List<String> getDependencies(){\r\n    return this.dependencies;\r\n}"
}, {
	"Path": "spark.resource.AbstractResource.toString",
	"Comment": "this implementation returns the description of this resource.",
	"Method": "String toString(){\r\n    return getDescription();\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.setUserRepository",
	"Comment": "sets the user repository with the specified user repository.",
	"Method": "void setUserRepository(UserRepository userRepository){\r\n    this.userRepository = userRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.classpath.ClassPathChangedEvent.isRestartRequired",
	"Comment": "return if an application restart is required due to the change.",
	"Method": "boolean isRestartRequired(){\r\n    return this.restartRequired;\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.tagExists",
	"Comment": "determines whether the specified tag title exists in the specified tags.",
	"Method": "boolean tagExists(String tagTitle,List<JSONObject> tags){\r\n    for (final JSONObject tag : tags) {\r\n        if (tag.getString(Tag.TAG_TITLE).equals(tagTitle)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "spark.resource.ExternalResource.isDirectory",
	"Comment": "tests whether the file denoted by this abstract pathname is adirectory.",
	"Method": "boolean isDirectory(){\r\n    return file.isDirectory();\r\n}"
}, {
	"Path": "spark.resource.ExternalResource.getURL",
	"Comment": "this implementation returns a url for the underlying class path resource.",
	"Method": "URL getURL(){\r\n    return file.toURI().toURL();\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.extractingJsonPathValue",
	"Comment": "extract the value at the given json path for further object assertions.",
	"Method": "AbstractObjectAssert<?, Object> extractingJsonPathValue(CharSequence expression,Object args,T extractingJsonPathValue,CharSequence expression,Object[] args,Class<T> type,String expectedDescription){\r\n    JsonPathValue value = new JsonPathValue(expression, args);\r\n    if (value.getValue(false) != null) {\r\n        value.assertHasValue(type, expectedDescription);\r\n    }\r\n    return (T) value.getValue(false);\r\n}"
}, {
	"Path": "spark.Spark.initExceptionHandler",
	"Comment": "overrides default exception handler during initialization phase",
	"Method": "void initExceptionHandler(Consumer<Exception> initExceptionHandler){\r\n    getInstance().initExceptionHandler(initExceptionHandler);\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.AbstractFilterRegistrationBean.addUrlPatterns",
	"Comment": "add url patterns, as defined in the servlet specification, that the filter will be\tregistered against.",
	"Method": "void addUrlPatterns(String urlPatterns){\r\n    Assert.notNull(urlPatterns, \"UrlPatterns must not be null\");\r\n    Collections.addAll(this.urlPatterns, urlPatterns);\r\n}"
}, {
	"Path": "org.b3log.solo.service.LinkQueryService.setLinkRepository",
	"Comment": "sets the link repository with the specified link repository.",
	"Method": "void setLinkRepository(LinkRepository linkRepository){\r\n    this.linkRepository = linkRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.loader.tools.Library.isUnpackRequired",
	"Comment": "return if the file cannot be used directly as a nested jar and needs to be\tunpacked.",
	"Method": "boolean isUnpackRequired(){\r\n    return this.unpackRequired;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationmetadata.Deprecation.getReplacement",
	"Comment": "the full name of the property that replaces the related deprecated property, if",
	"Method": "String getReplacement(){\r\n    return this.replacement;\r\n}"
}, {
	"Path": "org.b3log.solo.processor.ArticleProcessor.getAuthorCurrentPageNum",
	"Comment": "gets the request page number from the specified request uri and author id.",
	"Method": "int getAuthorCurrentPageNum(String requestURI,String authorId){\r\n    final String pageNumString = StringUtils.substring(requestURI, (Latkes.getContextPath() + \"/authors/\" + authorId + \"/\").length());\r\n    return Requests.getCurrentPageNum(pageNumString);\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleQueryService.getArticleContent",
	"Comment": "gets article contents with the specified article id.invoking this method dose not effect on article view count.",
	"Method": "String getArticleContent(HttpServletRequest request,String articleId){\r\n    if (StringUtils.isBlank(articleId)) {\r\n        return null;\r\n    }\r\n    try {\r\n        final JSONObject article = articleRepository.get(articleId);\r\n        if (null == article) {\r\n            return null;\r\n        }\r\n        if (Solos.needViewPwd(request, article)) {\r\n            final String content = langPropsService.get(\"articleContentPwd\");\r\n            article.put(ARTICLE_CONTENT, content);\r\n        } else if (\"CodeMirror-Markdown\".equals(article.optString(ARTICLE_EDITOR_TYPE))) {\r\n            Stopwatchs.start(\"Get Article Content [Markdown]\");\r\n            String content = article.optString(ARTICLE_CONTENT);\r\n            content = Emotions.convert(content);\r\n            content = Markdowns.toHTML(content);\r\n            article.put(ARTICLE_CONTENT, content);\r\n            Stopwatchs.end();\r\n        }\r\n        return article.getString(Article.ARTICLE_CONTENT);\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Gets article content failed[articleId=\" + articleId + \"]\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.PageMgmtService.setPermalinkQueryService",
	"Comment": "sets the permalink query service with the specified permalink query service.",
	"Method": "void setPermalinkQueryService(PermalinkQueryService permalinkQueryService){\r\n    this.permalinkQueryService = permalinkQueryService;\r\n}"
}, {
	"Path": "spark.embeddedserver.jetty.SocketConnectorFactory.createSecureSocketConnector",
	"Comment": "creates a ssl jetty socket jetty. keystore required, truststoreoptional. if truststore not specified keystore will be reused.",
	"Method": "ServerConnector createSecureSocketConnector(Server server,String host,int port,SslStores sslStores){\r\n    Assert.notNull(server, \"'server' must not be null\");\r\n    Assert.notNull(host, \"'host' must not be null\");\r\n    Assert.notNull(sslStores, \"'sslStores' must not be null\");\r\n    SslContextFactory sslContextFactory = new SslContextFactory(sslStores.keystoreFile());\r\n    if (sslStores.keystorePassword() != null) {\r\n        sslContextFactory.setKeyStorePassword(sslStores.keystorePassword());\r\n    }\r\n    if (sslStores.certAlias() != null) {\r\n        sslContextFactory.setCertAlias(sslStores.certAlias());\r\n    }\r\n    if (sslStores.trustStoreFile() != null) {\r\n        sslContextFactory.setTrustStorePath(sslStores.trustStoreFile());\r\n    }\r\n    if (sslStores.trustStorePassword() != null) {\r\n        sslContextFactory.setTrustStorePassword(sslStores.trustStorePassword());\r\n    }\r\n    if (sslStores.needsClientCert()) {\r\n        sslContextFactory.setNeedClientAuth(true);\r\n        sslContextFactory.setWantClientAuth(true);\r\n    }\r\n    HttpConnectionFactory httpConnectionFactory = createHttpConnectionFactory();\r\n    ServerConnector connector = new ServerConnector(server, sslContextFactory, httpConnectionFactory);\r\n    initializeConnector(connector, host, port);\r\n    return connector;\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.AbstractFilterRegistrationBean.setServletNames",
	"Comment": "set servlet names that the filter will be registered against. this will replace any\tpreviously specified servlet names.",
	"Method": "void setServletNames(Collection<String> servletNames){\r\n    Assert.notNull(servletNames, \"ServletNames must not be null\");\r\n    this.servletNames = new LinkedHashSet(servletNames);\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleQueryService.setPreferenceQueryService",
	"Comment": "sets the preference query service with the specified preference query service.",
	"Method": "void setPreferenceQueryService(PreferenceQueryService preferenceQueryService){\r\n    this.preferenceQueryService = preferenceQueryService;\r\n}"
}, {
	"Path": "org.b3log.solo.processor.console.AdminConsole.fireFreeMarkerActionEvent",
	"Comment": "fires freemarker action event with the host template name and data model.",
	"Method": "void fireFreeMarkerActionEvent(String hostTemplateName,Map<String, Object> dataModel){\r\n    final ViewLoadEventData data = new ViewLoadEventData();\r\n    data.setViewName(hostTemplateName);\r\n    data.setDataModel(dataModel);\r\n    eventManager.fireEventSynchronously(new Event(Keys.FREEMARKER_ACTION, data));\r\n    if (StringUtils.isBlank((String) dataModel.get(Plugin.PLUGINS))) {\r\n        dataModel.put(Plugin.PLUGINS, \"\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.configurationmetadata.SimpleConfigurationMetadataRepository.include",
	"Comment": "merge the content of the specified repository to this repository.",
	"Method": "void include(ConfigurationMetadataRepository repository){\r\n    for (ConfigurationMetadataGroup group : repository.getAllGroups().values()) {\r\n        ConfigurationMetadataGroup existingGroup = this.allGroups.get(group.getId());\r\n        if (existingGroup == null) {\r\n            this.allGroups.put(group.getId(), group);\r\n        } else {\r\n            group.getProperties().forEach((name, value) -> putIfAbsent(existingGroup.getProperties(), name, value));\r\n            group.getSources().forEach((name, value) -> putIfAbsent(existingGroup.getSources(), name, value));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.model.Tag.exists",
	"Comment": "checks the specified title exists in the specified title set.",
	"Method": "boolean exists(Set<String> titles,String title){\r\n    for (final String setTitle : titles) {\r\n        if (setTitle.equalsIgnoreCase(title)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.openqa.grid.internal.utils.DefaultCapabilityMatcherTest.shouldMatchWhenNodeHasDeprecatedPlatformCapability",
	"Comment": "todo remove test when capabilitytype.platform is removed from code base",
	"Method": "void shouldMatchWhenNodeHasDeprecatedPlatformCapability(){\r\n    Map<String, Object> requested = new FirefoxOptions().asMap();\r\n    requested.put(CapabilityType.PLATFORM_NAME, Platform.ANY);\r\n    Map<String, Object> node = new HashMap();\r\n    node.put(CapabilityType.BROWSER_NAME, BrowserType.FIREFOX);\r\n    node.put(CapabilityType.PLATFORM, Platform.LINUX);\r\n    assertTrue(matcher.matches(node, requested));\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.restart.DefaultRestartInitializer.isMain",
	"Comment": "returns if the thread is for a main invocation. by default checks the name of the\tthread and the context classloader.",
	"Method": "boolean isMain(Thread thread){\r\n    return thread.getName().equals(\"main\") && thread.getContextClassLoader().getClass().getName().contains(\"AppClassLoader\");\r\n}"
}, {
	"Path": "org.b3log.solo.service.CategoryMgmtService.changeOrder",
	"Comment": "changes the order of a category specified by the given category id with the specified direction.",
	"Method": "void changeOrder(String categoryId,String direction){\r\n    final Transaction transaction = categoryRepository.beginTransaction();\r\n    try {\r\n        final JSONObject srcCategory = categoryRepository.get(categoryId);\r\n        final int srcCategoryOrder = srcCategory.getInt(Category.CATEGORY_ORDER);\r\n        JSONObject targetCategory;\r\n        if (\"up\".equals(direction)) {\r\n            targetCategory = categoryRepository.getUpper(categoryId);\r\n        } else {\r\n            targetCategory = categoryRepository.getUnder(categoryId);\r\n        }\r\n        if (null == targetCategory) {\r\n            if (transaction.isActive()) {\r\n                transaction.rollback();\r\n            }\r\n            LOGGER.log(Level.WARN, \"Cant not find the target category of source category [order={0}]\", srcCategoryOrder);\r\n            return;\r\n        }\r\n        srcCategory.put(Category.CATEGORY_ORDER, targetCategory.getInt(Category.CATEGORY_ORDER));\r\n        targetCategory.put(Category.CATEGORY_ORDER, srcCategoryOrder);\r\n        categoryRepository.update(srcCategory.getString(Keys.OBJECT_ID), srcCategory);\r\n        categoryRepository.update(targetCategory.getString(Keys.OBJECT_ID), targetCategory);\r\n        transaction.commit();\r\n    } catch (final Exception e) {\r\n        if (transaction.isActive()) {\r\n            transaction.rollback();\r\n        }\r\n        LOGGER.log(Level.ERROR, \"Changes category's order failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.InitService.setUserRepository",
	"Comment": "sets the user repository with the specified user repository.",
	"Method": "void setUserRepository(UserRepository userRepository){\r\n    this.userRepository = userRepository;\r\n}"
}, {
	"Path": "org.b3log.solo.SoloServletListener.loadPreference",
	"Comment": "loads preference.loads preference from repository, loads skins from skin directory then sets it into preference if the skinschanged.",
	"Method": "void loadPreference(){\r\n    Stopwatchs.start(\"Load Preference\");\r\n    LOGGER.debug(\"Loading preference....\");\r\n    final PreferenceQueryService preferenceQueryService = beanManager.getReference(PreferenceQueryService.class);\r\n    JSONObject preference;\r\n    try {\r\n        preference = preferenceQueryService.getPreference();\r\n        if (null == preference) {\r\n            return;\r\n        }\r\n        final PreferenceMgmtService preferenceMgmtService = beanManager.getReference(PreferenceMgmtService.class);\r\n        preferenceMgmtService.loadSkins(preference);\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, e.getMessage(), e);\r\n        System.exit(-1);\r\n    }\r\n    Stopwatchs.end();\r\n}"
}, {
	"Path": "org.springframework.boot.cli.CliTester.clearUrlHandler",
	"Comment": "the tomcaturlstreamhandlerfactory fails if the factory is already set, use\treflection to reset it.",
	"Method": "void clearUrlHandler(){\r\n    try {\r\n        Field field = URL.class.getDeclaredField(\"factory\");\r\n        field.setAccessible(true);\r\n        field.set(null, null);\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.setArchiveDateRepository",
	"Comment": "sets archive date repository with the specified archive date repository.",
	"Method": "void setArchiveDateRepository(ArchiveDateRepository archiveDateRepository){\r\n    this.archiveDateRepository = archiveDateRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationprocessor.json.JSONStringer.replaceTop",
	"Comment": "replace the value on the top of the stack with the given value.",
	"Method": "void replaceTop(Scope topOfStack){\r\n    this.stack.set(this.stack.size() - 1, topOfStack);\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.autoconfigure.cloudfoundry.CloudFoundryAuthorizationException.getReason",
	"Comment": "return the reason why the authorization exception was thrown.",
	"Method": "Reason getReason(){\r\n    return this.reason;\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.tunnel.server.HttpTunnelServer.setDisconnectTimeout",
	"Comment": "set the maximum amount of time to wait for a client before closing the connection.",
	"Method": "void setDisconnectTimeout(long disconnectTimeout){\r\n    Assert.isTrue(disconnectTimeout > 0, \"DisconnectTimeout must be a positive value\");\r\n    this.disconnectTimeout = disconnectTimeout;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationprocessor.json.JSONStringer.beforeValue",
	"Comment": "inserts any necessary separators and whitespace before a literal value, inline\tarray, or inline object. also adjusts the stack to expect either a closing bracket\tor another element.",
	"Method": "void beforeValue(){\r\n    if (this.stack.isEmpty()) {\r\n        return;\r\n    }\r\n    Scope context = peek();\r\n    if (context == Scope.EMPTY_ARRAY) {\r\n        replaceTop(Scope.NONEMPTY_ARRAY);\r\n        newline();\r\n    } else if (context == Scope.NONEMPTY_ARRAY) {\r\n        this.out.append(',');\r\n        newline();\r\n    } else if (context == Scope.DANGLING_KEY) {\r\n        this.out.append(this.indent == null ? \":\" : \": \");\r\n        replaceTop(Scope.NONEMPTY_OBJECT);\r\n    } else if (context != Scope.NULL) {\r\n        throw new JSONException(\"Nesting problem\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.cli.command.shell.ShellPrompts.popPrompt",
	"Comment": "pop a previously pushed prompt, returning to the previous value.",
	"Method": "void popPrompt(){\r\n    if (!this.prompts.isEmpty()) {\r\n        this.prompts.pop();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.autoconfigure.metrics.ServiceLevelAgreementBoundary.getValue",
	"Comment": "return the underlying value of the sla in form suitable to apply to the given meter\ttype.",
	"Method": "Long getValue(Meter.Type meterType){\r\n    return this.value.getValue(meterType);\r\n}"
}, {
	"Path": "org.b3log.solo.util.Solos.isAdminLoggedIn",
	"Comment": "checks whether the current request is made by logged in administrator.",
	"Method": "boolean isAdminLoggedIn(HttpServletRequest request,HttpServletResponse response){\r\n    final JSONObject user = getCurrentUser(request, response);\r\n    if (null == user) {\r\n        return false;\r\n    }\r\n    return Role.ADMIN_ROLE.equals(user.optString(User.USER_ROLE));\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.getExclusions",
	"Comment": "return any exclusions that limit the candidate configurations.",
	"Method": "Set<String> getExclusions(AnnotationMetadata metadata,AnnotationAttributes attributes,Set<String> getExclusions){\r\n    Set<String> excluded = new LinkedHashSet();\r\n    excluded.addAll(asList(attributes, \"exclude\"));\r\n    excluded.addAll(Arrays.asList(attributes.getStringArray(\"excludeName\")));\r\n    excluded.addAll(getExcludeAutoConfigurationsProperty());\r\n    return excluded;\r\n}"
}, {
	"Path": "org.b3log.solo.service.StatisticMgmtService.setOptionRepository",
	"Comment": "sets the option repository with the specified option repository.",
	"Method": "void setOptionRepository(OptionRepository optionRepository){\r\n    this.optionRepository = optionRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.source.ConfigurationPropertySource.getUnderlyingSource",
	"Comment": "return the underlying source that is actually providing the properties.",
	"Method": "Object getUnderlyingSource(){\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BindHandler.onSuccess",
	"Comment": "called when binding of an element ends with a successful result. implementations\tmay change the ultimately returned result or perform addition validation.",
	"Method": "Object onSuccess(ConfigurationPropertyName name,Bindable<?> target,BindContext context,Object result){\r\n    return result;\r\n}"
}, {
	"Path": "org.b3log.solo.repository.ArticleRepository.getMostCommentArticles",
	"Comment": "gets most commented and published articles with the specified number.",
	"Method": "List<JSONObject> getMostCommentArticles(int num){\r\n    final Query query = new Query().addSort(Article.ARTICLE_COMMENT_COUNT, SortDirection.DESCENDING).addSort(Article.ARTICLE_UPDATED, SortDirection.DESCENDING).setFilter(new PropertyFilter(Article.ARTICLE_IS_PUBLISHED, FilterOperator.EQUAL, true)).setCurrentPageNum(1).setPageSize(num).setPageCount(1);\r\n    return getList(query);\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.extractingJsonPathBooleanValue",
	"Comment": "extract the boolean value at the given json path for further object assertions.",
	"Method": "AbstractBooleanAssert<?> extractingJsonPathBooleanValue(CharSequence expression,Object args){\r\n    return Assertions.assertThat(extractingJsonPathValue(expression, args, Boolean.class, \"a boolean\"));\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.jms.DefaultJmsListenerContainerFactoryConfigurer.configure",
	"Comment": "configure the specified jms listener container factory. the factory can be further\ttuned and default settings can be overridden.",
	"Method": "void configure(DefaultJmsListenerContainerFactory factory,ConnectionFactory connectionFactory){\r\n    Assert.notNull(factory, \"Factory must not be null\");\r\n    Assert.notNull(connectionFactory, \"ConnectionFactory must not be null\");\r\n    factory.setConnectionFactory(connectionFactory);\r\n    factory.setPubSubDomain(this.jmsProperties.isPubSubDomain());\r\n    if (this.transactionManager != null) {\r\n        factory.setTransactionManager(this.transactionManager);\r\n    } else {\r\n        factory.setSessionTransacted(true);\r\n    }\r\n    if (this.destinationResolver != null) {\r\n        factory.setDestinationResolver(this.destinationResolver);\r\n    }\r\n    if (this.messageConverter != null) {\r\n        factory.setMessageConverter(this.messageConverter);\r\n    }\r\n    JmsProperties.Listener listener = this.jmsProperties.getListener();\r\n    factory.setAutoStartup(listener.isAutoStartup());\r\n    if (listener.getAcknowledgeMode() != null) {\r\n        factory.setSessionAcknowledgeMode(listener.getAcknowledgeMode().getMode());\r\n    }\r\n    String concurrency = listener.formatConcurrency();\r\n    if (concurrency != null) {\r\n        factory.setConcurrency(concurrency);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.repository.ArticleRepository.getMostViewCountArticles",
	"Comment": "gets most view count and published articles with the specified number.",
	"Method": "List<JSONObject> getMostViewCountArticles(int num){\r\n    final Query query = new Query().addSort(Article.ARTICLE_VIEW_COUNT, SortDirection.DESCENDING).addSort(Article.ARTICLE_UPDATED, SortDirection.DESCENDING).setFilter(new PropertyFilter(Article.ARTICLE_IS_PUBLISHED, FilterOperator.EQUAL, true)).setCurrentPageNum(1).setPageSize(num).setPageCount(1);\r\n    return getList(query);\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentMgmtService.setCommentRepository",
	"Comment": "sets the comment repository with the specified comment repository.",
	"Method": "void setCommentRepository(CommentRepository commentRepository){\r\n    this.commentRepository = commentRepository;\r\n}"
}, {
	"Path": "org.b3log.solo.repository.ArchiveDateRepository.removeForUnpublishedArticles",
	"Comment": "removes archive dates of unpublished articles from the specified archivedates.",
	"Method": "void removeForUnpublishedArticles(List<JSONObject> archiveDates){\r\n    final Iterator<JSONObject> iterator = archiveDates.iterator();\r\n    while (iterator.hasNext()) {\r\n        final JSONObject archiveDate = iterator.next();\r\n        if (0 == archiveDate.optInt(ArchiveDate.ARCHIVE_DATE_PUBLISHED_ARTICLE_COUNT)) {\r\n            iterator.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.builder.SpringApplicationBuilder.beanNameGenerator",
	"Comment": "bean name generator for automatically generated bean names in the application\tcontext.",
	"Method": "SpringApplicationBuilder beanNameGenerator(BeanNameGenerator beanNameGenerator){\r\n    this.application.setBeanNameGenerator(beanNameGenerator);\r\n    return this;\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.setStatisticQueryService",
	"Comment": "sets the statistic query service with the specified statistic query service.",
	"Method": "void setStatisticQueryService(StatisticQueryService statisticQueryService){\r\n    this.statisticQueryService = statisticQueryService;\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleQueryService.setUserRepository",
	"Comment": "sets the user repository with the specified user repository.",
	"Method": "void setUserRepository(UserRepository userRepository){\r\n    this.userRepository = userRepository;\r\n}"
}, {
	"Path": "org.openqa.grid.internal.utils.DefaultCapabilityMatcherTest.smokeTestWithDeprecatedPlatformCapability",
	"Comment": "todo remove test when capabilitytype.platform is removed from code base",
	"Method": "void smokeTestWithDeprecatedPlatformCapability(){\r\n    Map<String, Object> firefox = ImmutableMap.of(CapabilityType.BROWSER_NAME, \"B\", CapabilityType.PLATFORM, \"XP\");\r\n    Map<String, Object> tl = new HashMap<String, Object>() {\r\n        {\r\n            put(CapabilityType.APPLICATION_NAME, \"A\");\r\n            put(CapabilityType.VERSION, null);\r\n        }\r\n    };\r\n    Map<String, Object> firefox2 = ImmutableMap.of(CapabilityType.BROWSER_NAME, \"B\", CapabilityType.PLATFORM, \"win7\", CapabilityType.VERSION, \"3.6\");\r\n    Map<String, Object> tl2 = ImmutableMap.of(CapabilityType.APPLICATION_NAME, \"A\", CapabilityType.VERSION, \"8.5.100.7\");\r\n    assertTrue(matcher.matches(tl, tl));\r\n    assertFalse(matcher.matches(tl, tl2));\r\n    assertTrue(matcher.matches(tl2, tl));\r\n    assertTrue(matcher.matches(tl2, tl2));\r\n    assertTrue(matcher.matches(firefox, firefox));\r\n    assertFalse(matcher.matches(firefox, firefox2));\r\n    assertFalse(matcher.matches(firefox2, firefox));\r\n    assertTrue(matcher.matches(firefox2, firefox2));\r\n    assertFalse(matcher.matches(tl, null));\r\n    assertFalse(matcher.matches(null, null));\r\n    assertFalse(matcher.matches(tl, firefox));\r\n    assertFalse(matcher.matches(firefox, tl2));\r\n}"
}, {
	"Path": "org.springframework.boot.logging.LoggingSystem.get",
	"Comment": "detect and return the logging system in use. supports logback and java logging.",
	"Method": "LoggingSystem get(ClassLoader classLoader,LoggingSystem get,ClassLoader classLoader,String loggingSystemClass){\r\n    try {\r\n        Class<?> systemClass = ClassUtils.forName(loggingSystemClass, classLoader);\r\n        return (LoggingSystem) systemClass.getConstructor(ClassLoader.class).newInstance(classLoader);\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}"
}, {
	"Path": "spark.util.SparkTestUtil.getTrustStoreLocation",
	"Comment": "return jvm param set truststore location, or keystore location if notset. if keystore not set either, returns default",
	"Method": "String getTrustStoreLocation(){\r\n    String trustStoreLoc = System.getProperty(\"javax.net.ssl.trustStore\");\r\n    return trustStoreLoc == null ? getKeyStoreLocation() : trustStoreLoc;\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleQueryService.markdowns",
	"Comment": "converts the content and abstract for each of the specified articles to html if that is saved by markdown editor.",
	"Method": "void markdowns(List<JSONObject> articles){\r\n    for (final JSONObject article : articles) {\r\n        markdown(article);\r\n    }\r\n}"
}, {
	"Path": "spark.Spark.modelAndView",
	"Comment": "constructs a modelandview with the provided model and view name",
	"Method": "ModelAndView modelAndView(Object model,String viewName){\r\n    return new ModelAndView(model, viewName);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.jdbc.DataSourceProperties.determinePassword",
	"Comment": "determine the password to use based on this configuration and the environment.",
	"Method": "String determinePassword(){\r\n    if (StringUtils.hasText(this.password)) {\r\n        return this.password;\r\n    }\r\n    if (EmbeddedDatabaseConnection.isEmbedded(determineDriverClassName())) {\r\n        return \"\";\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.AbstractJsonMarshalTester.readObject",
	"Comment": "read from the specified reader to create an object of the specified type.",
	"Method": "T readObject(String resourcePath,T readObject,File file,T readObject,InputStream inputStream,T readObject,Resource resource,T readObject,Reader reader,T readObject,InputStream inputStream,ResolvableType type,T readObject,Reader reader,ResolvableType type){\r\n    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\r\n    return readObject(reader, type);\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.ServletRegistrationBean.addUrlMappings",
	"Comment": "add url mappings, as defined in the servlet specification, for the servlet.",
	"Method": "void addUrlMappings(String urlMappings){\r\n    Assert.notNull(urlMappings, \"UrlMappings must not be null\");\r\n    this.urlMappings.addAll(Arrays.asList(urlMappings));\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.livereload.LiveReloadServer.start",
	"Comment": "start the livereload server and accept incoming connections.",
	"Method": "int start(){\r\n    synchronized (this.monitor) {\r\n        Assert.state(!isStarted(), \"Server already started\");\r\n        logger.debug(\"Starting live reload server on port \" + this.port);\r\n        this.serverSocket = new ServerSocket(this.port);\r\n        int localPort = this.serverSocket.getLocalPort();\r\n        this.listenThread = this.threadFactory.newThread(this::acceptConnections);\r\n        this.listenThread.setDaemon(true);\r\n        this.listenThread.setName(\"Live Reload Server\");\r\n        this.listenThread.start();\r\n        return localPort;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.servlet.DispatcherServletPath.getPrefix",
	"Comment": "return a cleaned up version of the path that can be used as a prefix for urls. the\tresulting path will have path will not have a trailing slash.",
	"Method": "String getPrefix(){\r\n    String result = getPath();\r\n    int index = result.indexOf('*');\r\n    if (index != -1) {\r\n        result = result.substring(0, index);\r\n    }\r\n    if (result.endsWith(\"/\")) {\r\n        result = result.substring(0, result.length() - 1);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "spark.embeddedserver.jetty.EmbeddedJettyFactory.withThreadPool",
	"Comment": "sets optional thread pool for jetty server.this is useful for overriding the default thread poolbehaviour for example io.dropwizard.metrics.jetty9.instrumentedqueuedthreadpool.",
	"Method": "EmbeddedJettyFactory withThreadPool(ThreadPool threadPool){\r\n    this.threadPool = threadPool;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.loader.jar.Handler.setUseFastConnectionExceptions",
	"Comment": "set if a generic static exception can be thrown when a url cannot be connected.\tthis optimization is used during class loading to save creating lots of exceptions\twhich are then swallowed.",
	"Method": "void setUseFastConnectionExceptions(boolean useFastConnectionExceptions){\r\n    JarURLConnection.setUseFastExceptions(useFastConnectionExceptions);\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleQueryService.setStatisticQueryService",
	"Comment": "sets the statistic query service with the specified statistic query service.",
	"Method": "void setStatisticQueryService(StatisticQueryService statisticQueryService){\r\n    this.statisticQueryService = statisticQueryService;\r\n}"
}, {
	"Path": "org.b3log.solo.service.StatisticMgmtService.setLangPropsService",
	"Comment": "sets the language service with the specified language service.",
	"Method": "void setLangPropsService(LangPropsService langPropsService){\r\n    this.langPropsService = langPropsService;\r\n}"
}, {
	"Path": "org.b3log.solo.service.TagQueryService.removeForUnpublishedArticles",
	"Comment": "removes tags of unpublished articles from the specified tags.",
	"Method": "void removeForUnpublishedArticles(List<JSONObject> tags){\r\n    final Iterator<JSONObject> iterator = tags.iterator();\r\n    while (iterator.hasNext()) {\r\n        final JSONObject tag = iterator.next();\r\n        if (0 == tag.getInt(Tag.TAG_PUBLISHED_REFERENCE_COUNT)) {\r\n            iterator.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.processor.IndexProcessor.getCurrentPageNum",
	"Comment": "gets the request page number from the specified request uri.",
	"Method": "int getCurrentPageNum(String requestURI){\r\n    final String pageNumString = StringUtils.substringAfterLast(requestURI, \"/\");\r\n    return Requests.getCurrentPageNum(pageNumString);\r\n}"
}, {
	"Path": "org.springframework.boot.builder.SpringApplicationBuilder.logStartupInfo",
	"Comment": "flag to indicate the startup information should be logged.",
	"Method": "SpringApplicationBuilder logStartupInfo(boolean logStartupInfo){\r\n    this.application.setLogStartupInfo(logStartupInfo);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.trace.http.InMemoryHttpTraceRepository.setReverse",
	"Comment": "flag to say that the repository lists traces in reverse order.",
	"Method": "void setReverse(boolean reverse){\r\n    synchronized (this.traces) {\r\n        this.reverse = reverse;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.task.TaskExecutorBuilder.threadNamePrefix",
	"Comment": "set the prefix to use for the names of newly created threads.",
	"Method": "TaskExecutorBuilder threadNamePrefix(String threadNamePrefix){\r\n    return new TaskExecutorBuilder(this.queueCapacity, this.corePoolSize, this.maxPoolSize, this.allowCoreThreadTimeOut, this.keepAlive, threadNamePrefix, this.taskDecorator, this.customizers);\r\n}"
}, {
	"Path": "spark.embeddedserver.NotSupportedException.raise",
	"Comment": "raises a notsupportedexception for the provided class name and feature name.",
	"Method": "void raise(String clazz,String feature){\r\n    throw new NotSupportedException(clazz, feature);\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleQueryService.getArticlesByArchiveDate",
	"Comment": "gets a list of published articles with the specified archive date id, current page number and page size.",
	"Method": "List<JSONObject> getArticlesByArchiveDate(String archiveDateId,int currentPageNum,int pageSize){\r\n    try {\r\n        JSONObject result = archiveDateArticleRepository.getByArchiveDateId(archiveDateId, currentPageNum, pageSize);\r\n        final JSONArray relations = result.getJSONArray(Keys.RESULTS);\r\n        if (0 == relations.length()) {\r\n            return Collections.emptyList();\r\n        }\r\n        final Set<String> articleIds = new HashSet();\r\n        for (int i = 0; i < relations.length(); i++) {\r\n            final JSONObject relation = relations.getJSONObject(i);\r\n            final String articleId = relation.getString(Article.ARTICLE + \"_\" + Keys.OBJECT_ID);\r\n            articleIds.add(articleId);\r\n        }\r\n        final List<JSONObject> ret = new ArrayList();\r\n        final Query query = new Query().setFilter(new PropertyFilter(Keys.OBJECT_ID, FilterOperator.IN, articleIds)).setPageCount(1).index(Article.ARTICLE_PERMALINK);\r\n        result = articleRepository.get(query);\r\n        final JSONArray articles = result.getJSONArray(Keys.RESULTS);\r\n        for (int i = 0; i < articles.length(); i++) {\r\n            final JSONObject article = articles.getJSONObject(i);\r\n            if (!article.getBoolean(Article.ARTICLE_IS_PUBLISHED)) {\r\n                continue;\r\n            }\r\n            article.put(ARTICLE_CREATE_TIME, article.getLong(ARTICLE_CREATED));\r\n            article.put(ARTICLE_T_CREATE_DATE, new Date(article.getLong(ARTICLE_CREATED)));\r\n            article.put(Article.ARTICLE_T_UPDATE_DATE, new Date(article.optLong(ARTICLE_UPDATED)));\r\n            ret.add(article);\r\n        }\r\n        return ret;\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Gets articles by archive date[id=\" + archiveDateId + \"] failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.openqa.selenium.grid.sessionmap.SessionMapTest.removingASessionThatDoesNotExistIsNotAnError",
	"Comment": "this is because multiple areas within the grid may all try and remove a session.",
	"Method": "void removingASessionThatDoesNotExistIsNotAnError(){\r\n    remote.remove(id);\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.decTagRefCount",
	"Comment": "decrements reference count of every tag of an article specified by thegiven article id.",
	"Method": "void decTagRefCount(String articleId){\r\n    try {\r\n        final List<JSONObject> tags = tagRepository.getByArticleId(articleId);\r\n        final JSONObject article = articleRepository.get(articleId);\r\n        for (final JSONObject tag : tags) {\r\n            final String tagId = tag.getString(Keys.OBJECT_ID);\r\n            final int refCnt = tag.getInt(Tag.TAG_REFERENCE_COUNT);\r\n            tag.put(Tag.TAG_REFERENCE_COUNT, refCnt - 1);\r\n            final int publishedRefCnt = tag.getInt(Tag.TAG_PUBLISHED_REFERENCE_COUNT);\r\n            if (article.getBoolean(Article.ARTICLE_IS_PUBLISHED)) {\r\n                tag.put(Tag.TAG_PUBLISHED_REFERENCE_COUNT, publishedRefCnt - 1);\r\n            } else {\r\n                tag.put(Tag.TAG_PUBLISHED_REFERENCE_COUNT, publishedRefCnt);\r\n            }\r\n            tagRepository.update(tagId, tag);\r\n            LOGGER.log(Level.TRACE, \"Deced tag[title={0}, refCnt={1}, publishedRefCnt={2}] of article[id={3}]\", tag.getString(Tag.TAG_TITLE), tag.getInt(Tag.TAG_REFERENCE_COUNT), tag.getInt(Tag.TAG_PUBLISHED_REFERENCE_COUNT), articleId);\r\n        }\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Decs tag references count of article[id\" + articleId + \"] failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n    LOGGER.log(Level.DEBUG, \"Deced all tag reference count of article[id={0}]\", articleId);\r\n}"
}, {
	"Path": "org.openqa.grid.internal.utils.DefaultCapabilityMatcherTest.shouldMatchWhenRequestedHasDeprecatedPlatformCapability",
	"Comment": "todo remove test when capabilitytype.platform is removed from code base",
	"Method": "void shouldMatchWhenRequestedHasDeprecatedPlatformCapability(){\r\n    Map<String, Object> requested = new FirefoxOptions().asMap();\r\n    requested.put(CapabilityType.PLATFORM, Platform.ANY);\r\n    Map<String, Object> node = new HashMap();\r\n    node.put(CapabilityType.BROWSER_NAME, BrowserType.FIREFOX);\r\n    node.put(CapabilityType.PLATFORM_NAME, Platform.LINUX);\r\n    assertTrue(matcher.matches(node, requested));\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.setArticleQueryService",
	"Comment": "sets the article query service with the specified article query service.",
	"Method": "void setArticleQueryService(ArticleQueryService articleQueryService){\r\n    this.articleQueryService = articleQueryService;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.kafka.KafkaProperties.buildAdminProperties",
	"Comment": "create an initial map of admin properties from the state of this instance.\tthis allows you to add additional properties, if necessary, and override the\tdefault kafkaadmin bean.",
	"Method": "Map<String, Object> buildAdminProperties(){\r\n    Map<String, Object> properties = buildCommonProperties();\r\n    properties.putAll(this.admin.buildProperties());\r\n    return properties;\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentMgmtService.sendNotificationMail",
	"Comment": "sends a notification mail to administrator for notifying the specified article or page received the specifiedcomment and original comment.",
	"Method": "void sendNotificationMail(JSONObject articleOrPage,JSONObject comment,JSONObject originalComment,JSONObject preference){\r\n    if (!Solos.isConfigured()) {\r\n        return;\r\n    }\r\n    final String commentEmail = comment.getString(Comment.COMMENT_EMAIL);\r\n    final String commentId = comment.getString(Keys.OBJECT_ID);\r\n    final String commentContent = comment.getString(Comment.COMMENT_CONTENT);\r\n    final String adminEmail = preference.getString(Option.ID_C_ADMIN_EMAIL);\r\n    if (adminEmail.equalsIgnoreCase(commentEmail)) {\r\n        LOGGER.log(Level.DEBUG, \"Do not send comment notification mail to admin itself[{0}]\", adminEmail);\r\n        return;\r\n    }\r\n    if (Latkes.getServePath().contains(\"localhost\") || Strings.isIPv4(Latkes.getServePath())) {\r\n        LOGGER.log(Level.INFO, \"Solo runs on local server, so should not send mail\");\r\n        return;\r\n    }\r\n    if (null != originalComment && comment.has(Comment.COMMENT_ORIGINAL_COMMENT_ID)) {\r\n        final String originalEmail = originalComment.getString(Comment.COMMENT_EMAIL);\r\n        if (originalEmail.equalsIgnoreCase(adminEmail)) {\r\n            LOGGER.log(Level.DEBUG, \"Do not send comment notification mail to admin while the specified comment[{0}] is an reply\", commentId);\r\n            return;\r\n        }\r\n    }\r\n    final String blogTitle = preference.getString(Option.ID_C_BLOG_TITLE);\r\n    boolean isArticle = true;\r\n    String title = articleOrPage.optString(Article.ARTICLE_TITLE);\r\n    if (StringUtils.isBlank(title)) {\r\n        title = articleOrPage.getString(Page.PAGE_TITLE);\r\n        isArticle = false;\r\n    }\r\n    final String commentSharpURL = comment.getString(Comment.COMMENT_SHARP_URL);\r\n    final MailService.Message message = new MailService.Message();\r\n    message.setFrom(adminEmail);\r\n    message.addRecipient(adminEmail);\r\n    String mailSubject;\r\n    String articleOrPageURL;\r\n    String mailBody;\r\n    if (isArticle) {\r\n        mailSubject = blogTitle + \": New comment on article [\" + title + \"]\";\r\n        articleOrPageURL = Latkes.getServePath() + articleOrPage.getString(Article.ARTICLE_PERMALINK);\r\n        mailBody = COMMENT_MAIL_HTML_BODY.replace(\"{articleOrPage}\", \"Article\");\r\n    } else {\r\n        mailSubject = blogTitle + \": New comment on page [\" + title + \"]\";\r\n        articleOrPageURL = Latkes.getServePath() + articleOrPage.getString(Page.PAGE_PERMALINK);\r\n        mailBody = COMMENT_MAIL_HTML_BODY.replace(\"{articleOrPage}\", \"Page\");\r\n    }\r\n    message.setSubject(mailSubject);\r\n    final String commentName = comment.getString(Comment.COMMENT_NAME);\r\n    final String commentURL = comment.getString(Comment.COMMENT_URL);\r\n    String commenter;\r\n    if (!\"http://\".equals(commentURL)) {\r\n        commenter = \"<a target=\\\"_blank\\\" \" + \"href=\\\"\" + commentURL + \"\\\">\" + commentName + \"<\/a>\";\r\n    } else {\r\n        commenter = commentName;\r\n    }\r\n    mailBody = mailBody.replace(\"{articleOrPageURL}\", articleOrPageURL).replace(\"{title}\", title).replace(\"{commentContent}\", commentContent).replace(\"{commentSharpURL}\", Latkes.getServePath() + commentSharpURL).replace(\"{commenter}\", commenter);\r\n    message.setHtmlBody(mailBody);\r\n    LOGGER.log(Level.DEBUG, \"Sending a mail[mailSubject={0}, mailBody=[{1}] to admin[email={2}]\", mailSubject, mailBody, adminEmail);\r\n    mailService.send(message);\r\n}"
}, {
	"Path": "spark.util.SparkTestUtil.getKeystorePassword",
	"Comment": "return jvm param set keystore password or default if not set.",
	"Method": "String getKeystorePassword(){\r\n    String password = System.getProperty(\"javax.net.ssl.keyStorePassword\");\r\n    return password == null ? \"password\" : password;\r\n}"
}, {
	"Path": "org.springframework.boot.security.reactive.ApplicationContextServerWebExchangeMatcher.matches",
	"Comment": "decides whether the rule implemented by the strategy matches the supplied exchange.",
	"Method": "Mono<MatchResult> matches(ServerWebExchange exchange,Mono<MatchResult> matches,ServerWebExchange exchange,Supplier<C> context){\r\n    return matches(exchange, getContext(exchange));\r\n}"
}, {
	"Path": "org.b3log.solo.service.PluginMgmtService.setPluginRepository",
	"Comment": "sets the plugin repository with the specified plugin repository.",
	"Method": "void setPluginRepository(PluginRepository pluginRepository){\r\n    this.pluginRepository = pluginRepository;\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleQueryService.canAccessArticle",
	"Comment": "can the specified user access an article specified by the given article id?",
	"Method": "boolean canAccessArticle(String articleId,JSONObject user){\r\n    if (StringUtils.isBlank(articleId)) {\r\n        return false;\r\n    }\r\n    if (null == user) {\r\n        return false;\r\n    }\r\n    if (Role.ADMIN_ROLE.equals(user.optString(User.USER_ROLE))) {\r\n        return true;\r\n    }\r\n    final JSONObject article = articleRepository.get(articleId);\r\n    final String currentUserId = user.getString(Keys.OBJECT_ID);\r\n    return article.getString(Article.ARTICLE_AUTHOR_ID).equals(currentUserId);\r\n}"
}, {
	"Path": "org.b3log.solo.processor.LoginProcessor.isPwdExpired",
	"Comment": "whether user is going to update an expired password out of 24 hours.",
	"Method": "boolean isPwdExpired(){\r\n    return false;\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentQueryService.setPageRepository",
	"Comment": "set the page repository with the specified page repository.",
	"Method": "void setPageRepository(PageRepository pageRepository){\r\n    this.pageRepository = pageRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.info.GitProperties.coerceToEpoch",
	"Comment": "attempt to convert the specified value to epoch time. git properties information\tare known to be specified either as epoch time in seconds or using a specific date\tformat.",
	"Method": "String coerceToEpoch(String s){\r\n    Long epoch = parseEpochSecond(s);\r\n    if (epoch != null) {\r\n        return String.valueOf(epoch);\r\n    }\r\n    SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\");\r\n    try {\r\n        return String.valueOf(format.parse(s).getTime());\r\n    } catch (ParseException ex) {\r\n        return s;\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.decArchiveDatePublishedRefCount",
	"Comment": "decrements reference count of archive date of an published article specified by the given article id.",
	"Method": "void decArchiveDatePublishedRefCount(String articleId){\r\n    final JSONObject archiveDateArticleRelation = archiveDateArticleRepository.getByArticleId(articleId);\r\n    final String archiveDateId = archiveDateArticleRelation.getString(ArchiveDate.ARCHIVE_DATE + \"_\" + Keys.OBJECT_ID);\r\n    final JSONObject archiveDate = archiveDateRepository.get(archiveDateId);\r\n    archiveDate.put(ArchiveDate.ARCHIVE_DATE_PUBLISHED_ARTICLE_COUNT, archiveDate.getInt(ArchiveDate.ARCHIVE_DATE_PUBLISHED_ARTICLE_COUNT) - 1);\r\n    archiveDateRepository.update(archiveDateId, archiveDate);\r\n}"
}, {
	"Path": "spark.Service.exception",
	"Comment": "maps an exception handler to be executed when an exception occurs during routing",
	"Method": "void exception(Class<T> exceptionClass,ExceptionHandler<? super T> handler){\r\n    ExceptionHandlerImpl wrapper = new ExceptionHandlerImpl<T>(exceptionClass) {\r\n        @Override\r\n        public void handle(T exception, Request request, Response response) {\r\n            handler.handle(exception, request, response);\r\n        }\r\n    };\r\n    exceptionMapper.map(exceptionClass, wrapper);\r\n}"
}, {
	"Path": "spark.Service.exception",
	"Comment": "maps an exception handler to be executed when an exception occurs during routing",
	"Method": "void exception(Class<T> exceptionClass,ExceptionHandler<? super T> handler){\r\n    handler.handle(exception, request, response);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.amqp.RabbitProperties.determineHost",
	"Comment": "returns the host from the first address, or the configured host if no addresses\thave been set.",
	"Method": "String determineHost(){\r\n    if (CollectionUtils.isEmpty(this.parsedAddresses)) {\r\n        return getHost();\r\n    }\r\n    return this.parsedAddresses.get(0).host;\r\n}"
}, {
	"Path": "org.b3log.solo.service.PluginQueryService.setPluginRepository",
	"Comment": "sets the plugin repository with the specified plugin repository.",
	"Method": "void setPluginRepository(PluginRepository pluginRepository){\r\n    this.pluginRepository = pluginRepository;\r\n}"
}, {
	"Path": "org.b3log.solo.service.UpgradeService.notifyUserByEmail",
	"Comment": "send an email to the user who upgrades solo with a discontinuous version.",
	"Method": "void notifyUserByEmail(){\r\n    if (!Solos.isConfigured()) {\r\n        return;\r\n    }\r\n    final String adminEmail = preferenceQueryService.getPreference().getString(Option.ID_C_ADMIN_EMAIL);\r\n    final MailService.Message message = new MailService.Message();\r\n    message.setFrom(adminEmail);\r\n    message.addRecipient(adminEmail);\r\n    message.setSubject(langPropsService.get(\"skipVersionMailSubject\"));\r\n    message.setHtmlBody(langPropsService.get(\"skipVersionMailBody\"));\r\n    MAIL_SVC.send(message);\r\n    LOGGER.info(\"Send an email to the user who upgrades Solo with a discontinuous version.\");\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.AbstractFilterRegistrationBean.configure",
	"Comment": "configure registration settings. subclasses can override this method to perform\tadditional configuration if required.",
	"Method": "void configure(FilterRegistration.Dynamic registration){\r\n    super.configure(registration);\r\n    EnumSet<DispatcherType> dispatcherTypes = this.dispatcherTypes;\r\n    if (dispatcherTypes == null) {\r\n        dispatcherTypes = EnumSet.of(DispatcherType.REQUEST);\r\n    }\r\n    Set<String> servletNames = new LinkedHashSet();\r\n    for (ServletRegistrationBean<?> servletRegistrationBean : this.servletRegistrationBeans) {\r\n        servletNames.add(servletRegistrationBean.getServletName());\r\n    }\r\n    servletNames.addAll(this.servletNames);\r\n    if (servletNames.isEmpty() && this.urlPatterns.isEmpty()) {\r\n        registration.addMappingForUrlPatterns(dispatcherTypes, this.matchAfter, DEFAULT_URL_MAPPINGS);\r\n    } else {\r\n        if (!servletNames.isEmpty()) {\r\n            registration.addMappingForServletNames(dispatcherTypes, this.matchAfter, StringUtils.toStringArray(servletNames));\r\n        }\r\n        if (!this.urlPatterns.isEmpty()) {\r\n            registration.addMappingForUrlPatterns(dispatcherTypes, this.matchAfter, StringUtils.toStringArray(this.urlPatterns));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.kafka.KafkaProperties.buildStreamsProperties",
	"Comment": "create an initial map of streams properties from the state of this instance.\tthis allows you to add additional properties, if necessary.",
	"Method": "Map<String, Object> buildStreamsProperties(){\r\n    Map<String, Object> properties = buildCommonProperties();\r\n    properties.putAll(this.streams.buildProperties());\r\n    return properties;\r\n}"
}, {
	"Path": "org.b3log.solo.service.PageMgmtService.setLangPropsService",
	"Comment": "sets the language service with the specified language service.",
	"Method": "void setLangPropsService(LangPropsService langPropsService){\r\n    this.langPropsService = langPropsService;\r\n}"
}, {
	"Path": "org.b3log.solo.service.LinkMgmtService.changeOrder",
	"Comment": "changes the order of a link specified by the given link id with the specified direction.",
	"Method": "void changeOrder(String linkId,String direction){\r\n    final Transaction transaction = linkRepository.beginTransaction();\r\n    try {\r\n        final JSONObject srcLink = linkRepository.get(linkId);\r\n        final int srcLinkOrder = srcLink.getInt(Link.LINK_ORDER);\r\n        JSONObject targetLink = null;\r\n        if (\"up\".equals(direction)) {\r\n            targetLink = linkRepository.getUpper(linkId);\r\n        } else {\r\n            targetLink = linkRepository.getUnder(linkId);\r\n        }\r\n        if (null == targetLink) {\r\n            if (transaction.isActive()) {\r\n                transaction.rollback();\r\n            }\r\n            LOGGER.log(Level.WARN, \"Cant not find the target link of source link[order={0}]\", srcLinkOrder);\r\n            return;\r\n        }\r\n        srcLink.put(Link.LINK_ORDER, targetLink.getInt(Link.LINK_ORDER));\r\n        targetLink.put(Link.LINK_ORDER, srcLinkOrder);\r\n        linkRepository.update(srcLink.getString(Keys.OBJECT_ID), srcLink);\r\n        linkRepository.update(targetLink.getString(Keys.OBJECT_ID), targetLink);\r\n        transaction.commit();\r\n    } catch (final Exception e) {\r\n        if (transaction.isActive()) {\r\n            transaction.rollback();\r\n        }\r\n        LOGGER.log(Level.ERROR, \"Changes link's order failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.web.mappings.servlet.FilterRegistrationMappingDescription.getServletNameMappings",
	"Comment": "returns the servlet name mappings for the registered filter.",
	"Method": "Collection<String> getServletNameMappings(){\r\n    return this.getRegistration().getServletNameMappings();\r\n}"
}, {
	"Path": "org.springframework.boot.ant.FindMainClass.setMainClass",
	"Comment": "set the main class, which will cause the search to be bypassed.",
	"Method": "void setMainClass(String mainClass){\r\n    this.mainClass = mainClass;\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.extractingJsonPathNumberValue",
	"Comment": "extract the number value at the given json path for further object assertions.",
	"Method": "AbstractObjectAssert<?, Number> extractingJsonPathNumberValue(CharSequence expression,Object args){\r\n    return Assertions.assertThat(extractingJsonPathValue(expression, args, Number.class, \"a number\"));\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.AbstractFilterRegistrationBean.setUrlPatterns",
	"Comment": "set the url patterns that the filter will be registered against. this will replace\tany previously specified url patterns.",
	"Method": "void setUrlPatterns(Collection<String> urlPatterns){\r\n    Assert.notNull(urlPatterns, \"UrlPatterns must not be null\");\r\n    this.urlPatterns = new LinkedHashSet(urlPatterns);\r\n}"
}, {
	"Path": "org.springframework.boot.SpringApplication.registerLoggedException",
	"Comment": "register that the given exception has been logged. by default, if the running in\tthe main thread, this method will suppress additional printing of the stacktrace.",
	"Method": "void registerLoggedException(Throwable exception){\r\n    SpringBootExceptionHandler handler = getSpringBootExceptionHandler();\r\n    if (handler != null) {\r\n        handler.registerLoggedException(exception);\r\n    }\r\n}"
}, {
	"Path": "org.openqa.grid.internal.utils.DefaultCapabilityMatcherTest.genericPlatformMatchingTestWithDeprecatedPlatformCapability",
	"Comment": "todo remove test when capabilitytype.platform is removed from code base",
	"Method": "void genericPlatformMatchingTestWithDeprecatedPlatformCapability(){\r\n    Map<String, Object> requested = ImmutableMap.of(CapabilityType.PLATFORM, Platform.WINDOWS);\r\n    assertTrue(matcher.matches(ImmutableMap.of(CapabilityType.PLATFORM, \"WINDOWS\"), requested));\r\n    assertTrue(matcher.matches(ImmutableMap.of(CapabilityType.PLATFORM, \"xp\"), requested));\r\n    assertTrue(matcher.matches(ImmutableMap.of(CapabilityType.PLATFORM, \"windows VISTA\"), requested));\r\n    assertTrue(matcher.matches(ImmutableMap.of(CapabilityType.PLATFORM, \"windows 7\"), requested));\r\n    assertFalse(matcher.matches(ImmutableMap.of(CapabilityType.PLATFORM, \"linux\"), requested));\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleQueryService.setTagArticleRepository",
	"Comment": "sets the tag article repository with the specified tag article repository.",
	"Method": "void setTagArticleRepository(TagArticleRepository tagArticleRepository){\r\n    this.tagArticleRepository = tagArticleRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.context.annotation.Configurations.merge",
	"Comment": "merge configurations from another source of the same type.",
	"Method": "Configurations merge(Configurations other,Configurations merge,Set<Class<?>> mergedClasses){\r\n    Set<Class<?>> mergedClasses = new LinkedHashSet(getClasses());\r\n    mergedClasses.addAll(other.getClasses());\r\n    return merge(mergedClasses);\r\n}"
}, {
	"Path": "spark.resource.ClassPathResource.getDescription",
	"Comment": "this implementation returns a description that includes the class path location.",
	"Method": "String getDescription(){\r\n    StringBuilder builder = new StringBuilder(\"class path resource [\");\r\n    String pathToUse = path;\r\n    if (this.clazz != null && !pathToUse.startsWith(\"/\")) {\r\n        builder.append(ClassUtils.classPackageAsResourcePath(this.clazz));\r\n        builder.append('/');\r\n    }\r\n    if (pathToUse.startsWith(\"/\")) {\r\n        pathToUse = pathToUse.substring(1);\r\n    }\r\n    builder.append(pathToUse);\r\n    builder.append(']');\r\n    return builder.toString();\r\n}"
}, {
	"Path": "spark.resource.ClassPathResource.getFilename",
	"Comment": "this implementation returns the name of the file that this class pathresource refers to.",
	"Method": "String getFilename(){\r\n    return StringUtils.getFilename(this.path);\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet.CloudFoundrySecurityService.getAccessLevel",
	"Comment": "return the access level that should be granted to the given token.",
	"Method": "AccessLevel getAccessLevel(String token,String applicationId){\r\n    try {\r\n        URI uri = getPermissionsUri(applicationId);\r\n        RequestEntity<?> request = RequestEntity.get(uri).header(\"Authorization\", \"bearer \" + token).build();\r\n        Map<?, ?> body = this.restTemplate.exchange(request, Map.class).getBody();\r\n        if (Boolean.TRUE.equals(body.get(\"read_sensitive_data\"))) {\r\n            return AccessLevel.FULL;\r\n        }\r\n        return AccessLevel.RESTRICTED;\r\n    } catch (HttpClientErrorException ex) {\r\n        if (ex.getStatusCode().equals(HttpStatus.FORBIDDEN)) {\r\n            throw new CloudFoundryAuthorizationException(Reason.ACCESS_DENIED, \"Access denied\");\r\n        }\r\n        throw new CloudFoundryAuthorizationException(Reason.INVALID_TOKEN, \"Invalid token\", ex);\r\n    } catch (HttpServerErrorException ex) {\r\n        throw new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE, \"Cloud controller not reachable\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.isEqualToJson",
	"Comment": "verifies that the actual value is equal to the specified json resource.",
	"Method": "JsonContentAssert isEqualToJson(CharSequence expected,JsonContentAssert isEqualToJson,String path,Class<?> resourceLoadClass,JsonContentAssert isEqualToJson,byte[] expected,JsonContentAssert isEqualToJson,File expected,JsonContentAssert isEqualToJson,InputStream expected,JsonContentAssert isEqualToJson,Resource expected,JsonContentAssert isEqualToJson,CharSequence expected,JSONCompareMode compareMode,JsonContentAssert isEqualToJson,String path,Class<?> resourceLoadClass,JSONCompareMode compareMode,JsonContentAssert isEqualToJson,byte[] expected,JSONCompareMode compareMode,JsonContentAssert isEqualToJson,File expected,JSONCompareMode compareMode,JsonContentAssert isEqualToJson,InputStream expected,JSONCompareMode compareMode,JsonContentAssert isEqualToJson,Resource expected,JSONCompareMode compareMode,JsonContentAssert isEqualToJson,CharSequence expected,JSONComparator comparator,JsonContentAssert isEqualToJson,String path,Class<?> resourceLoadClass,JSONComparator comparator,JsonContentAssert isEqualToJson,byte[] expected,JSONComparator comparator,JsonContentAssert isEqualToJson,File expected,JSONComparator comparator,JsonContentAssert isEqualToJson,InputStream expected,JSONComparator comparator,JsonContentAssert isEqualToJson,Resource expected,JSONComparator comparator){\r\n    String expectedJson = this.loader.getJson(expected);\r\n    return assertNotFailed(compare(expectedJson, comparator));\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.AbstractFilterRegistrationBean.getUrlPatterns",
	"Comment": "return a mutable collection of url patterns, as defined in the servlet\tspecification, that the filter will be registered against.",
	"Method": "Collection<String> getUrlPatterns(){\r\n    return this.urlPatterns;\r\n}"
}, {
	"Path": "org.b3log.solo.service.PluginMgmtService.refresh",
	"Comment": "updates datastore plugin descriptions with the specified plugins.",
	"Method": "void refresh(List<AbstractPlugin> plugins){\r\n    if (!initService.isInited()) {\r\n        return;\r\n    }\r\n    final List<JSONObject> persistedPlugins = pluginRepository.getList(new Query());\r\n    try {\r\n        for (final JSONObject oldPluginDesc : persistedPlugins) {\r\n            final String descId = oldPluginDesc.getString(Keys.OBJECT_ID);\r\n            final AbstractPlugin plugin = get(plugins, descId);\r\n            pluginRepository.remove(descId);\r\n            if (null != plugin) {\r\n                final String status = oldPluginDesc.getString(Plugin.PLUGIN_STATUS);\r\n                final String setting = oldPluginDesc.optString(Plugin.PLUGIN_SETTING);\r\n                plugin.setStatus(PluginStatus.valueOf(status));\r\n                try {\r\n                    if (StringUtils.isNotBlank(setting)) {\r\n                        plugin.setSetting(new JSONObject(setting));\r\n                    }\r\n                } catch (final JSONException e) {\r\n                    LOGGER.log(Level.WARN, \"the formatter of the old config failed to convert to json\", e);\r\n                }\r\n            }\r\n        }\r\n        for (final AbstractPlugin plugin : plugins) {\r\n            final JSONObject pluginDesc = plugin.toJSONObject();\r\n            pluginRepository.add(pluginDesc);\r\n            LOGGER.log(Level.TRACE, \"Refreshed plugin[{0}]\", pluginDesc);\r\n        }\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Refresh plugins failed\", e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.DynamicRegistrationBean.isAsyncSupported",
	"Comment": "returns if asynchronous operations are supported for this registration.",
	"Method": "boolean isAsyncSupported(){\r\n    return this.asyncSupported;\r\n}"
}, {
	"Path": "org.springframework.boot.test.context.SpringBootTestContextBootstrapper.processPropertySourceProperties",
	"Comment": "post process the property source properties, adding or removing elements as\trequired.",
	"Method": "void processPropertySourceProperties(MergedContextConfiguration mergedConfig,List<String> propertySourceProperties){\r\n    Class<?> testClass = mergedConfig.getTestClass();\r\n    String[] properties = getProperties(testClass);\r\n    if (!ObjectUtils.isEmpty(properties)) {\r\n        propertySourceProperties.addAll(0, Arrays.asList(properties));\r\n    }\r\n    if (getWebEnvironment(testClass) == WebEnvironment.RANDOM_PORT) {\r\n        propertySourceProperties.add(\"server.port=0\");\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.CategoryQueryService.containTag",
	"Comment": "whether a tag specified by the given tag title in a category specified by the given category id.",
	"Method": "boolean containTag(String tagTitle,String categoryId){\r\n    try {\r\n        final JSONObject category = categoryRepository.get(categoryId);\r\n        if (null == category) {\r\n            return true;\r\n        }\r\n        final JSONObject tag = tagRepository.getByTitle(tagTitle);\r\n        if (null == tag) {\r\n            return true;\r\n        }\r\n        final Query query = new Query().setFilter(CompositeFilterOperator.and(new PropertyFilter(Category.CATEGORY + \"_\" + Keys.OBJECT_ID, FilterOperator.EQUAL, categoryId), new PropertyFilter(Tag.TAG + \"_\" + Keys.OBJECT_ID, FilterOperator.EQUAL, tag.optString(Keys.OBJECT_ID))));\r\n        return categoryTagRepository.count(query) > 0;\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Check category tag [tagTitle=\" + tagTitle + \", categoryId=\" + categoryId + \"] failed\", e);\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.servlet.JerseyApplicationPath.getPrefix",
	"Comment": "return a cleaned up version of the path that can be used as a prefix for urls. the\tresulting path will have path will not have a trailing slash.",
	"Method": "String getPrefix(){\r\n    String result = getPath();\r\n    int index = result.indexOf('*');\r\n    if (index != -1) {\r\n        result = result.substring(0, index);\r\n    }\r\n    if (result.endsWith(\"/\")) {\r\n        result = result.substring(0, result.length() - 1);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.setCommentRepository",
	"Comment": "sets the comment repository with the specified comment repository.",
	"Method": "void setCommentRepository(CommentRepository commentRepository){\r\n    this.commentRepository = commentRepository;\r\n}"
}, {
	"Path": "spark.ExceptionMapper.map",
	"Comment": "maps the given handler to the provided exception type. if a handler was already registered to the same type, thehandler is overwritten.",
	"Method": "void map(Class<? extends Exception> exceptionClass,ExceptionHandlerImpl handler){\r\n    this.exceptionMap.put(exceptionClass, handler);\r\n}"
}, {
	"Path": "spark.embeddedserver.EmbeddedServers.add",
	"Comment": "adds an embedded server factory for the provided identifier.",
	"Method": "void add(Object identifier,EmbeddedServerFactory factory){\r\n    factories.put(identifier, factory);\r\n}"
}, {
	"Path": "org.b3log.solo.model.Comment.getCommentSharpURLForPage",
	"Comment": "gets comment sharp url with the specified page and comment id.",
	"Method": "String getCommentSharpURLForPage(JSONObject page,String commentId){\r\n    return page.getString(Page.PAGE_PERMALINK) + \"#\" + commentId;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BindResult.orElseThrow",
	"Comment": "return the object that was bound, or throw an exception to be created by the\tprovided supplier if no value has been bound.",
	"Method": "T orElseThrow(Supplier<? extends X> exceptionSupplier){\r\n    if (this.value == null) {\r\n        throw exceptionSupplier.get();\r\n    }\r\n    return this.value;\r\n}"
}, {
	"Path": "org.openqa.grid.web.servlet.RegistrationServletTest.testLegacyV2Registration",
	"Comment": "tests that the registration request servlet can process a v2 registrationrequest whichcontains servlets as a comma separated string.",
	"Method": "void testLegacyV2Registration(){\r\n    Map<String, Object> config = new TreeMap();\r\n    config.put(\"servlets\", \"foo,bar,baz\");\r\n    config.put(\"registerCycle\", 30001);\r\n    config.put(\"proxy\", null);\r\n    grid2Request.put(\"configuration\", config);\r\n    grid2Request.put(\"capabilities\", singletonList(new FirefoxOptions()));\r\n    String id = \"http://dummynode:1234\";\r\n    grid2Request.put(\"id\", id);\r\n    final FakeHttpServletResponse response = sendCommand(\"POST\", \"/\", grid2Request);\r\n    waitForServletToAddProxy();\r\n    assertEquals(HttpServletResponse.SC_OK, response.getStatus());\r\n    assertEquals(((RegistrationServlet) servlet).getRegistry().getAllProxies().size(), 1);\r\n    final RemoteProxy proxy = ((RegistrationServlet) servlet).getRegistry().getAllProxies().getProxyById(id);\r\n    assertNotNull(proxy);\r\n    assertEquals(3, proxy.getConfig().servlets.size());\r\n    assertEquals(1, proxy.getConfig().capabilities.size());\r\n    assertEquals(30001, proxy.getConfig().registerCycle.intValue());\r\n    assertEquals(id, proxy.getConfig().id);\r\n}"
}, {
	"Path": "org.b3log.solo.service.DataModelService.fillMinified",
	"Comment": "fills minified directory and file postfix for static javascript, css.",
	"Method": "void fillMinified(Map<String, Object> dataModel){\r\n    switch(Latkes.getRuntimeMode()) {\r\n        case DEVELOPMENT:\r\n            dataModel.put(Common.MINI_POSTFIX, \"\");\r\n            break;\r\n        case PRODUCTION:\r\n            dataModel.put(Common.MINI_POSTFIX, Common.MINI_POSTFIX_VALUE);\r\n            break;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.PreferenceMgmtService.loadSkins",
	"Comment": "loads skins for the specified preference and initializes templates loading.if the skins directory has been changed, persists the change into preference.",
	"Method": "void loadSkins(JSONObject preference){\r\n    Stopwatchs.start(\"Load Skins\");\r\n    LOGGER.debug(\"Loading skins....\");\r\n    final Set<String> skinDirNames = getSkinDirNames();\r\n    LOGGER.log(Level.DEBUG, \"Loaded skins[dirNames={0}]\", skinDirNames);\r\n    final JSONArray skinArray = new JSONArray();\r\n    for (final String dirName : skinDirNames) {\r\n        final JSONObject skin = new JSONObject();\r\n        final String name = Latkes.getSkinName(dirName);\r\n        if (null == name) {\r\n            LOGGER.log(Level.WARN, \"The directory [{0}] does not contain any skin, ignored it\", dirName);\r\n            continue;\r\n        }\r\n        skin.put(SKIN_NAME, name);\r\n        skin.put(SKIN_DIR_NAME, dirName);\r\n        skinArray.put(skin);\r\n    }\r\n    final String currentSkinDirName = preference.optString(SKIN_DIR_NAME);\r\n    final String skinName = preference.optString(SKIN_NAME);\r\n    LOGGER.log(Level.DEBUG, \"Current skin[name={0}]\", skinName);\r\n    if (!skinDirNames.contains(currentSkinDirName)) {\r\n        LOGGER.log(Level.WARN, \"Configured skin [dirName={0}] can not find, try to use \" + \"default skin [dirName=\" + Option.DefaultPreference.DEFAULT_SKIN_DIR_NAME + \"] instead.\", currentSkinDirName);\r\n        if (!skinDirNames.contains(Option.DefaultPreference.DEFAULT_SKIN_DIR_NAME)) {\r\n            LOGGER.log(Level.ERROR, \"Can not find default skin [dirName=\" + Option.DefaultPreference.DEFAULT_SKIN_DIR_NAME + \"], please redeploy your Solo and make sure contains the default skin. If you are using git, try to re-pull with 'git pull --recurse-submodules'\");\r\n            System.exit(-1);\r\n        }\r\n        preference.put(SKIN_DIR_NAME, Option.DefaultPreference.DEFAULT_SKIN_DIR_NAME);\r\n        preference.put(SKIN_NAME, Latkes.getSkinName(Option.DefaultPreference.DEFAULT_SKIN_DIR_NAME));\r\n        updatePreference(preference);\r\n    }\r\n    final String skinsString = skinArray.toString();\r\n    if (!skinsString.equals(preference.getString(SKINS))) {\r\n        LOGGER.debug(\"The skins directory has been changed, persists the change into preference\");\r\n        preference.put(SKINS, skinsString);\r\n        updatePreference(preference);\r\n    }\r\n    LOGGER.debug(\"Loaded skins....\");\r\n    Stopwatchs.end();\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.endpoint.invoker.cache.CachingOperationInvoker.getTimeToLive",
	"Comment": "return the maximum time in milliseconds that a response can be cached.",
	"Method": "long getTimeToLive(){\r\n    return this.timeToLive;\r\n}"
}, {
	"Path": "org.springframework.boot.builder.ParentContextCloserApplicationListener.createContextCloserListener",
	"Comment": "subclasses may override to create their own subclass of contextcloserlistener. this\tstill enforces the use of a weak reference.",
	"Method": "ContextCloserListener createContextCloserListener(ConfigurableApplicationContext child){\r\n    return new ContextCloserListener(child);\r\n}"
}, {
	"Path": "org.springframework.boot.jta.atomikos.AtomikosProperties.setForceShutdownOnVmExit",
	"Comment": "specifies whether vm shutdown should trigger forced shutdown of the transaction\tcore. defaults to false.",
	"Method": "void setForceShutdownOnVmExit(boolean forceShutdownOnVmExit){\r\n    this.forceShutdownOnVmExit = forceShutdownOnVmExit;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.AggregateElementBinder.bind",
	"Comment": "bind the given name to a target bindable using optionally limited to a single\tsource.",
	"Method": "Object bind(ConfigurationPropertyName name,Bindable<?> target,Object bind,ConfigurationPropertyName name,Bindable<?> target,ConfigurationPropertySource source){\r\n    return bind(name, target, null);\r\n}"
}, {
	"Path": "org.springframework.boot.loader.tools.MainClassFinder.doWithMainClasses",
	"Comment": "perform the given callback operation on all main classes from the given jar.",
	"Method": "T doWithMainClasses(File rootFolder,MainClassCallback<T> callback,T doWithMainClasses,JarFile jarFile,String classesLocation,MainClassCallback<T> callback){\r\n    List<JarEntry> classEntries = getClassEntries(jarFile, classesLocation);\r\n    classEntries.sort(new ClassEntryComparator());\r\n    for (JarEntry entry : classEntries) {\r\n        try (InputStream inputStream = new BufferedInputStream(jarFile.getInputStream(entry))) {\r\n            ClassDescriptor classDescriptor = createClassDescriptor(inputStream);\r\n            if (classDescriptor != null && classDescriptor.isMainMethodFound()) {\r\n                String className = convertToClassName(entry.getName(), classesLocation);\r\n                T result = callback.doWith(new MainClass(className, classDescriptor.getAnnotationNames()));\r\n                if (result != null) {\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.getPermalinkForUpdateArticle",
	"Comment": "gets article permalink for updating article with the specified old article, article, created at.",
	"Method": "String getPermalinkForUpdateArticle(JSONObject oldArticle,JSONObject article,long created){\r\n    final String articleId = article.getString(Keys.OBJECT_ID);\r\n    String ret = article.optString(ARTICLE_PERMALINK).trim();\r\n    final String oldPermalink = oldArticle.getString(ARTICLE_PERMALINK);\r\n    if (!oldPermalink.equals(ret)) {\r\n        if (StringUtils.isBlank(ret)) {\r\n            ret = \"/articles/\" + DateFormatUtils.format(created, \"yyyy/MM/dd\") + \"/\" + articleId + \".html\";\r\n        }\r\n        if (!ret.startsWith(\"/\")) {\r\n            ret = \"/\" + ret;\r\n        }\r\n        if (PermalinkQueryService.invalidArticlePermalinkFormat(ret)) {\r\n            throw new ServiceException(langPropsService.get(\"invalidPermalinkFormatLabel\"));\r\n        }\r\n        if (!oldPermalink.equals(ret) && permalinkQueryService.exist(ret)) {\r\n            throw new ServiceException(langPropsService.get(\"duplicatedPermalinkLabel\"));\r\n        }\r\n    }\r\n    return ret.replaceAll(\" \", \"-\");\r\n}"
}, {
	"Path": "org.springframework.boot.context.annotation.Configurations.getClasses",
	"Comment": "return the classes from all the specified configurations in the order that they\twould be registered.",
	"Method": "Set<Class<?>> getClasses(Class<?>[] getClasses,Configurations configurations,Class<?>[] getClasses,Collection<Configurations> configurations){\r\n    List<Configurations> ordered = new ArrayList(configurations);\r\n    ordered.sort(COMPARATOR);\r\n    List<Configurations> collated = collate(ordered);\r\n    LinkedHashSet<Class<?>> classes = collated.stream().flatMap(Configurations::streamClasses).collect(Collectors.toCollection(LinkedHashSet::new));\r\n    return ClassUtils.toClassArray(classes);\r\n}"
}, {
	"Path": "org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getTldSkipPatterns",
	"Comment": "returns a mutable set of the patterns that match jars to ignore for tld scanning.",
	"Method": "Set<String> getTldSkipPatterns(){\r\n    return this.tldSkipPatterns;\r\n}"
}, {
	"Path": "org.openqa.grid.internal.utils.DefaultCapabilityMatcherTest.shouldMatchSafariTechnologyPreviewOnlyWithDeprecatedPlatformCapability",
	"Comment": "todo remove test when capabilitytype.platform is removed from code base",
	"Method": "void shouldMatchSafariTechnologyPreviewOnlyWithDeprecatedPlatformCapability(){\r\n    Map<String, Object> requested = new SafariOptions().setUseTechnologyPreview(true).asMap();\r\n    Map<String, Object> tpNode = new HashMap();\r\n    tpNode.put(CapabilityType.BROWSER_NAME, \"Safari Technology Preview\");\r\n    tpNode.put(CapabilityType.PLATFORM, Platform.MAC);\r\n    tpNode.put(\"technologyPreview\", true);\r\n    Map<String, Object> regularNode = new HashMap();\r\n    regularNode.put(CapabilityType.BROWSER_NAME, BrowserType.SAFARI);\r\n    regularNode.put(CapabilityType.PLATFORM, Platform.MAC);\r\n    assertTrue(matcher.matches(tpNode, requested));\r\n    assertFalse(matcher.matches(regularNode, requested));\r\n}"
}, {
	"Path": "spark.Spark.exception",
	"Comment": "maps an exception handler to be executed when an exception occurs during routing",
	"Method": "void exception(Class<T> exceptionClass,ExceptionHandler<? super T> handler){\r\n    getInstance().exception(exceptionClass, handler);\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentQueryService.setCommentRepository",
	"Comment": "sets the comment repository with the specified comment repository.",
	"Method": "void setCommentRepository(CommentRepository commentRepository){\r\n    this.commentRepository = commentRepository;\r\n}"
}, {
	"Path": "spark.utils.IOUtils.toString",
	"Comment": "get the contents of an inputstream as a stringusing the default character encoding of the platform.this method buffers the input internally, so there is no need to use abufferedinputstream.",
	"Method": "String toString(InputStream input){\r\n    StringWriter sw = new StringWriter();\r\n    copy(input, sw);\r\n    return sw.toString();\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.ConfigurationPropertiesBindException.getAnnotation",
	"Comment": "return the configuration properties annotation that triggered the binding.",
	"Method": "ConfigurationProperties getAnnotation(){\r\n    return this.annotation;\r\n}"
}, {
	"Path": "org.b3log.solo.processor.BlogProcessor.getBlogInfo",
	"Comment": "gets blog information.time of the recent updated articlearticle countcomment counttag countserve pathstatic serve pathsolo versionruntime moderuntime databaselocaleadmin username",
	"Method": "void getBlogInfo(HTTPRequestContext context){\r\n    final JSONRenderer renderer = new JSONRenderer();\r\n    context.setRenderer(renderer);\r\n    final JSONObject jsonObject = new JSONObject();\r\n    renderer.setJSONObject(jsonObject);\r\n    jsonObject.put(\"recentArticleTime\", articleQueryService.getRecentArticleTime());\r\n    final JSONObject statistic = statisticQueryService.getStatistic();\r\n    jsonObject.put(\"articleCount\", statistic.getLong(Option.ID_C_STATISTIC_PUBLISHED_ARTICLE_COUNT));\r\n    jsonObject.put(\"commentCount\", statistic.getLong(Option.ID_C_STATISTIC_PUBLISHED_BLOG_COMMENT_COUNT));\r\n    jsonObject.put(\"tagCount\", tagQueryService.getTagCount());\r\n    jsonObject.put(\"servePath\", Latkes.getServePath());\r\n    jsonObject.put(\"staticServePath\", Latkes.getStaticServePath());\r\n    jsonObject.put(\"version\", SoloServletListener.VERSION);\r\n    jsonObject.put(\"runtimeMode\", Latkes.getRuntimeMode());\r\n    jsonObject.put(\"runtimeDatabase\", Latkes.getRuntimeDatabase());\r\n    jsonObject.put(\"locale\", Latkes.getLocale());\r\n    String userName = \"\";\r\n    try {\r\n        userName = userQueryService.getAdmin().optString(User.USER_NAME);\r\n    } catch (final Exception e) {\r\n    }\r\n    jsonObject.put(\"userName\", userName);\r\n    jsonObject.put(\"qiniuDomain\", \"\");\r\n    jsonObject.put(\"qiniuBucket\", \"\");\r\n    final JSONObject qiniu = optionQueryService.getOptions(Option.CATEGORY_C_QINIU);\r\n    if (null != qiniu) {\r\n        jsonObject.put(\"qiniuDomain\", qiniu.optString(Option.ID_C_QINIU_DOMAIN));\r\n        jsonObject.put(\"qiniuBucket\", qiniu.optString(Option.ID_C_QINIU_BUCKET));\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.setLangPropsService",
	"Comment": "sets the language service with the specified language service.",
	"Method": "void setLangPropsService(LangPropsService langPropsService){\r\n    this.langPropsService = langPropsService;\r\n}"
}, {
	"Path": "org.springframework.boot.system.ApplicationTemp.getDir",
	"Comment": "return the directory to be used for application specific temp files.",
	"Method": "File getDir(String subDir,File getDir){\r\n    if (this.dir == null) {\r\n        synchronized (this) {\r\n            byte[] hash = generateHash(this.sourceClass);\r\n            this.dir = new File(getTempDirectory(), toHexString(hash));\r\n            this.dir.mkdirs();\r\n            Assert.state(this.dir.exists(), () -> \"Unable to create temp directory \" + this.dir);\r\n        }\r\n    }\r\n    return this.dir;\r\n}"
}, {
	"Path": "org.springframework.boot.cli.command.init.ProjectGenerationRequest.isDetectType",
	"Comment": "whether or not the type should be detected based on the build and format value.",
	"Method": "boolean isDetectType(){\r\n    return this.detectType;\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.AbstractFilterRegistrationBean.getServletNames",
	"Comment": "return a mutable collection of servlet names that the filter will be registered\tagainst.",
	"Method": "Collection<String> getServletNames(){\r\n    return this.servletNames;\r\n}"
}, {
	"Path": "org.b3log.solo.service.TagMgmtService.decTagPublishedRefCount",
	"Comment": "decrements reference count of every tag of an published article specifiedby the given article id.",
	"Method": "void decTagPublishedRefCount(String articleId){\r\n    final List<JSONObject> tags = tagRepository.getByArticleId(articleId);\r\n    for (final JSONObject tag : tags) {\r\n        final String tagId = tag.getString(Keys.OBJECT_ID);\r\n        final int refCnt = tag.getInt(Tag.TAG_REFERENCE_COUNT);\r\n        tag.put(Tag.TAG_REFERENCE_COUNT, refCnt);\r\n        final int publishedRefCnt = tag.getInt(Tag.TAG_PUBLISHED_REFERENCE_COUNT);\r\n        tag.put(Tag.TAG_PUBLISHED_REFERENCE_COUNT, publishedRefCnt - 1);\r\n        tagRepository.update(tagId, tag);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.InitService.setArchiveDateArticleRepository",
	"Comment": "sets archive date article repository with the specified archive date article repository.",
	"Method": "void setArchiveDateArticleRepository(ArchiveDateArticleRepository archiveDateArticleRepository){\r\n    this.archiveDateArticleRepository = archiveDateArticleRepository;\r\n}"
}, {
	"Path": "org.b3log.solo.service.InitService.setCommentRepository",
	"Comment": "sets the comment repository with the specified comment repository.",
	"Method": "void setCommentRepository(CommentRepository commentRepository){\r\n    this.commentRepository = commentRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.AbstractFilterRegistrationBean.isMatchAfter",
	"Comment": "return if filter mappings should be matched after any declared filter mappings of\tthe servletcontext.",
	"Method": "boolean isMatchAfter(){\r\n    return this.matchAfter;\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentQueryService.getComments",
	"Comment": "gets comments with the specified request json object, request and response.",
	"Method": "JSONObject getComments(JSONObject requestJSONObject,List<JSONObject> getComments,String onId){\r\n    try {\r\n        final List<JSONObject> ret = new ArrayList();\r\n        final List<JSONObject> comments = commentRepository.getComments(onId, 1, Integer.MAX_VALUE);\r\n        for (final JSONObject comment : comments) {\r\n            comment.put(Comment.COMMENT_TIME, comment.optLong(Comment.COMMENT_CREATED));\r\n            comment.put(Comment.COMMENT_T_DATE, new Date(comment.optLong(Comment.COMMENT_CREATED)));\r\n            comment.put(\"commentDate2\", new Date(comment.optLong(Comment.COMMENT_CREATED)));\r\n            comment.put(Comment.COMMENT_NAME, comment.getString(Comment.COMMENT_NAME));\r\n            String url = comment.getString(Comment.COMMENT_URL);\r\n            if (StringUtils.contains(url, \"<\")) {\r\n                url = \"\";\r\n            }\r\n            comment.put(Comment.COMMENT_URL, url);\r\n            comment.put(Common.IS_REPLY, false);\r\n            final String thumbnailURL = comment.optString(Comment.COMMENT_THUMBNAIL_URL);\r\n            if (StringUtils.isBlank(thumbnailURL)) {\r\n                final String email = comment.optString(Comment.COMMENT_EMAIL);\r\n                comment.put(Comment.COMMENT_THUMBNAIL_URL, Solos.getGravatarURL(email, \"128\"));\r\n            }\r\n            if (StringUtils.isNotBlank(comment.optString(Comment.COMMENT_ORIGINAL_COMMENT_ID))) {\r\n                comment.put(Common.IS_REPLY, true);\r\n            }\r\n            String commentContent = comment.optString(Comment.COMMENT_CONTENT);\r\n            commentContent = Emotions.convert(commentContent);\r\n            commentContent = Markdowns.toHTML(commentContent);\r\n            commentContent = Jsoup.clean(commentContent, Whitelist.relaxed());\r\n            comment.put(Comment.COMMENT_CONTENT, commentContent);\r\n            String commentName = comment.optString(Comment.COMMENT_NAME);\r\n            commentName = Jsoup.clean(commentName, Whitelist.none());\r\n            comment.put(Comment.COMMENT_NAME, commentName);\r\n            ret.add(comment);\r\n        }\r\n        return ret;\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Gets comments failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "spark.resource.AbstractResource.lastModified",
	"Comment": "this implementation checks the timestamp of the underlying file,if available.",
	"Method": "long lastModified(){\r\n    long lastModified = getFileForLastModifiedCheck().lastModified();\r\n    if (lastModified == 0L) {\r\n        throw new FileNotFoundException(getDescription() + \" cannot be resolved in the file system for resolving its last-modified timestamp\");\r\n    }\r\n    return lastModified;\r\n}"
}, {
	"Path": "org.springframework.boot.SpringApplication.setWebApplicationType",
	"Comment": "sets the type of web application to be run. if not explicitly set the type of web\tapplication will be deduced based on the classpath.",
	"Method": "void setWebApplicationType(WebApplicationType webApplicationType){\r\n    Assert.notNull(webApplicationType, \"WebApplicationType must not be null\");\r\n    this.webApplicationType = webApplicationType;\r\n}"
}, {
	"Path": "org.b3log.solo.processor.SkinRenderer.genHTML",
	"Comment": "processes the specified freemarker template with the specified request, data model, pjax hacking.",
	"Method": "String genHTML(HttpServletRequest request,Map<String, Object> dataModel,Template template){\r\n    final boolean isPJAX = isPJAX(request);\r\n    dataModel.put(\"pjax\", isPJAX);\r\n    if (!isPJAX) {\r\n        return super.genHTML(request, dataModel, template);\r\n    }\r\n    final StringWriter stringWriter = new StringWriter();\r\n    template.setOutputEncoding(\"UTF-8\");\r\n    template.process(dataModel, stringWriter);\r\n    final long endTimeMillis = System.currentTimeMillis();\r\n    final String dateString = DateFormatUtils.format(endTimeMillis, \"yyyy/MM/dd HH:mm:ss\");\r\n    final long startTimeMillis = (Long) request.getAttribute(Keys.HttpRequest.START_TIME_MILLIS);\r\n    final String latke = String.format(\"\\n<!-- Generated by Latke (https://github.com/b3log/latke) in %1$dms, %2$s -->\", endTimeMillis - startTimeMillis, dateString);\r\n    final String pjaxContainer = request.getHeader(\"X-PJAX-Container\");\r\n    final String html = stringWriter.toString();\r\n    final String[] containers = StringUtils.substringsBetween(html, \"<!---- pjax {\" + pjaxContainer + \"} start ---->\", \"<!---- pjax {\" + pjaxContainer + \"} end ---->\");\r\n    if (null == containers) {\r\n        return html + latke;\r\n    }\r\n    return String.join(\"\", containers) + latke;\r\n}"
}, {
	"Path": "org.b3log.solo.service.PermalinkQueryService.invalidPagePermalinkFormat",
	"Comment": "checks whether the specified page permalink is invalid on format.",
	"Method": "boolean invalidPagePermalinkFormat(String permalink){\r\n    if (StringUtils.isBlank(permalink)) {\r\n        return true;\r\n    }\r\n    if (matchDefaultPagePermalinkFormat(permalink)) {\r\n        return false;\r\n    }\r\n    return invalidUserDefinedPermalinkFormat(permalink);\r\n}"
}, {
	"Path": "org.springframework.boot.web.context.WebServerPortFileWriter.getPortFile",
	"Comment": "return the actual port file that should be written for the given application\tcontext. the default implementation builds a file from the source file and the\tapplication context namespace if available.",
	"Method": "File getPortFile(ApplicationContext applicationContext){\r\n    String namespace = getServerNamespace(applicationContext);\r\n    if (StringUtils.isEmpty(namespace)) {\r\n        return this.file;\r\n    }\r\n    String name = this.file.getName();\r\n    String extension = StringUtils.getFilenameExtension(this.file.getName());\r\n    name = name.substring(0, name.length() - extension.length() - 1);\r\n    if (isUpperCase(name)) {\r\n        name = name + \"-\" + namespace.toUpperCase(Locale.ENGLISH);\r\n    } else {\r\n        name = name + \"-\" + namespace.toLowerCase(Locale.ENGLISH);\r\n    }\r\n    if (StringUtils.hasLength(extension)) {\r\n        name = name + \".\" + extension;\r\n    }\r\n    return new File(this.file.getParentFile(), name);\r\n}"
}, {
	"Path": "org.b3log.solo.service.UserQueryService.setUserRepository",
	"Comment": "sets the user repository with the specified user repository.",
	"Method": "void setUserRepository(UserRepository userRepository){\r\n    this.userRepository = userRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.task.TaskSchedulerBuilder.threadNamePrefix",
	"Comment": "set the prefix to use for the names of newly created threads.",
	"Method": "TaskSchedulerBuilder threadNamePrefix(String threadNamePrefix){\r\n    return new TaskSchedulerBuilder(this.poolSize, threadNamePrefix, this.customizers);\r\n}"
}, {
	"Path": "spark.Service.initExceptionHandler",
	"Comment": "overrides default exception handler during initialization phase",
	"Method": "void initExceptionHandler(Consumer<Exception> initExceptionHandler){\r\n    if (initialized) {\r\n        throwBeforeRouteMappingException();\r\n    }\r\n    this.initExceptionHandler = initExceptionHandler;\r\n}"
}, {
	"Path": "org.b3log.solo.service.LinkMgmtService.setLinkRepository",
	"Comment": "sets the link repository with the specified link repository.",
	"Method": "void setLinkRepository(LinkRepository linkRepository){\r\n    this.linkRepository = linkRepository;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive.ReactiveCloudFoundrySecurityService.getAccessLevel",
	"Comment": "return a mono of the access level that should be granted to the given token.",
	"Method": "Mono<AccessLevel> getAccessLevel(String token,String applicationId,AccessLevel getAccessLevel,Map<?, ?> body){\r\n    if (Boolean.TRUE.equals(body.get(\"read_sensitive_data\"))) {\r\n        return AccessLevel.FULL;\r\n    }\r\n    return AccessLevel.RESTRICTED;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.kafka.KafkaProperties.buildConsumerProperties",
	"Comment": "create an initial map of consumer properties from the state of this instance.\tthis allows you to add additional properties, if necessary, and override the\tdefault kafkaconsumerfactory bean.",
	"Method": "Map<String, Object> buildConsumerProperties(){\r\n    Map<String, Object> properties = buildCommonProperties();\r\n    properties.putAll(this.consumer.buildProperties());\r\n    return properties;\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.server.Jsp.getInitParameters",
	"Comment": "return the init parameters used to configure the jsp servlet.",
	"Method": "Map<String, String> getInitParameters(){\r\n    return this.initParameters;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationprocessor.json.JSONStringer.open",
	"Comment": "enters a new scope by appending any necessary whitespace and the given bracket.",
	"Method": "JSONStringer open(Scope empty,String openBracket){\r\n    if (this.stack.isEmpty() && this.out.length() > 0) {\r\n        throw new JSONException(\"Nesting problem: multiple top-level roots\");\r\n    }\r\n    beforeValue();\r\n    this.stack.add(empty);\r\n    this.out.append(openBracket);\r\n    return this;\r\n}"
}, {
	"Path": "spark.embeddedserver.jetty.EmbeddedJettyServer.withThreadPool",
	"Comment": "sets optional thread pool for jetty server.this is useful for overriding the default thread poolbehaviour for example io.dropwizard.metrics.jetty9.instrumentedqueuedthreadpool.",
	"Method": "EmbeddedJettyServer withThreadPool(ThreadPool threadPool){\r\n    this.threadPool = threadPool;\r\n    return this;\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleQueryService.isArticlePublished",
	"Comment": "determines an article specified by the given article id is published.",
	"Method": "boolean isArticlePublished(String articleId){\r\n    try {\r\n        return articleRepository.isPublished(articleId);\r\n    } catch (final RepositoryException e) {\r\n        LOGGER.log(Level.ERROR, \"Determines the article publish status failed[articleId=\" + articleId + \"]\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentMgmtService.removeArticleComment",
	"Comment": "removes a comment of an article with the specified comment id.",
	"Method": "void removeArticleComment(String commentId){\r\n    final Transaction transaction = commentRepository.beginTransaction();\r\n    try {\r\n        final JSONObject comment = commentRepository.get(commentId);\r\n        final String articleId = comment.getString(Comment.COMMENT_ON_ID);\r\n        commentRepository.remove(commentId);\r\n        decArticleCommentCount(articleId);\r\n        statisticMgmtService.decBlogCommentCount();\r\n        statisticMgmtService.decPublishedBlogCommentCount();\r\n        transaction.commit();\r\n    } catch (final Exception e) {\r\n        if (transaction.isActive()) {\r\n            transaction.rollback();\r\n        }\r\n        LOGGER.log(Level.ERROR, \"Removes a comment of an article failed\", e);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.extractingJsonPathMapValue",
	"Comment": "extract the map value at the given json path for further object assertions.",
	"Method": "MapAssert<K, V> extractingJsonPathMapValue(CharSequence expression,Object args){\r\n    return Assertions.assertThat(extractingJsonPathValue(expression, args, Map.class, \"a map\"));\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArchiveDateQueryService.setArchiveDateRepository",
	"Comment": "sets archive date repository with the specified archive date repository.",
	"Method": "void setArchiveDateRepository(ArchiveDateRepository archiveDateRepository){\r\n    this.archiveDateRepository = archiveDateRepository;\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.incArchiveDatePublishedRefCount",
	"Comment": "increments reference count of archive date of an published article specified by the given article id.",
	"Method": "void incArchiveDatePublishedRefCount(String articleId){\r\n    final JSONObject archiveDateArticleRelation = archiveDateArticleRepository.getByArticleId(articleId);\r\n    final String archiveDateId = archiveDateArticleRelation.getString(ArchiveDate.ARCHIVE_DATE + \"_\" + Keys.OBJECT_ID);\r\n    final JSONObject archiveDate = archiveDateRepository.get(archiveDateId);\r\n    archiveDate.put(ArchiveDate.ARCHIVE_DATE_PUBLISHED_ARTICLE_COUNT, archiveDate.getInt(ArchiveDate.ARCHIVE_DATE_PUBLISHED_ARTICLE_COUNT) + 1);\r\n    archiveDateRepository.update(archiveDateId, archiveDate);\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentMgmtService.setStatisticMgmtService",
	"Comment": "sets the statistic management service with the specified statistic management service.",
	"Method": "void setStatisticMgmtService(StatisticMgmtService statisticMgmtService){\r\n    this.statisticMgmtService = statisticMgmtService;\r\n}"
}, {
	"Path": "org.springframework.boot.configurationmetadata.ConfigurationMetadataSource.getType",
	"Comment": "the type of the source. usually this is the fully qualified name of a class that\tdefines configuration items. this class may or may not be available at runtime.",
	"Method": "String getType(){\r\n    return this.type;\r\n}"
}, {
	"Path": "spark.resource.ClassPathResource.getInputStream",
	"Comment": "this implementation opens an inputstream for the given class path resource.",
	"Method": "InputStream getInputStream(){\r\n    InputStream is;\r\n    if (this.clazz != null) {\r\n        is = this.clazz.getResourceAsStream(this.path);\r\n    } else {\r\n        is = this.classLoader.getResourceAsStream(this.path);\r\n    }\r\n    if (is == null) {\r\n        throw new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\r\n    }\r\n    return is;\r\n}"
}, {
	"Path": "org.springframework.boot.SpringApplication.setEnvironment",
	"Comment": "sets the underlying environment that should be used with the created application\tcontext.",
	"Method": "void setEnvironment(ConfigurableEnvironment environment){\r\n    this.isCustomEnvironment = true;\r\n    this.environment = environment;\r\n}"
}, {
	"Path": "org.springframework.boot.ExitCodeGenerators.getExitCode",
	"Comment": "get the final exit code that should be returned based on all contained generators.",
	"Method": "int getExitCode(int getExitCode){\r\n    int exitCode = 0;\r\n    for (ExitCodeGenerator generator : this.generators) {\r\n        try {\r\n            int value = generator.getExitCode();\r\n            if (value > 0 && value > exitCode || value < 0 && value < exitCode) {\r\n                exitCode = value;\r\n            }\r\n        } catch (Exception ex) {\r\n            exitCode = (exitCode != 0) ? exitCode : 1;\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n    return exitCode;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport.getConditionAndOutcomesBySource",
	"Comment": "returns condition outcomes from this report, grouped by the source.",
	"Method": "Map<String, ConditionAndOutcomes> getConditionAndOutcomesBySource(){\r\n    if (!this.addedAncestorOutcomes) {\r\n        this.outcomes.forEach((source, sourceOutcomes) -> {\r\n            if (!sourceOutcomes.isFullMatch()) {\r\n                addNoMatchOutcomeToAncestors(source);\r\n            }\r\n        });\r\n        this.addedAncestorOutcomes = true;\r\n    }\r\n    return Collections.unmodifiableMap(this.outcomes);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.getErrorAttributes",
	"Comment": "extract the error attributes from the current request, to be used to populate error\tviews or json payloads.",
	"Method": "Map<String, Object> getErrorAttributes(ServerRequest request,boolean includeStackTrace){\r\n    return this.errorAttributes.getErrorAttributes(request, includeStackTrace);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler.isTraceEnabled",
	"Comment": "check whether the trace attribute has been set on the given request.",
	"Method": "boolean isTraceEnabled(ServerRequest request){\r\n    String parameter = request.queryParam(\"trace\").orElse(\"false\");\r\n    return !\"false\".equalsIgnoreCase(parameter);\r\n}"
}, {
	"Path": "org.springframework.boot.configurationprocessor.TestProject.revert",
	"Comment": "restore source code of given class to its original contents.",
	"Method": "void revert(Class<?> type){\r\n    Assert.assertTrue(getSourceFile(type).exists());\r\n    copySources(type);\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.setTagArticleRepository",
	"Comment": "sets the tag article repository with the specified tag article repository.",
	"Method": "void setTagArticleRepository(TagArticleRepository tagArticleRepository){\r\n    this.tagArticleRepository = tagArticleRepository;\r\n}"
}, {
	"Path": "spark.http.matching.GeneralError.modify",
	"Comment": "modifies the http response and body based on the provided exception.",
	"Method": "void modify(HttpServletRequest httpRequest,HttpServletResponse httpResponse,Body body,RequestWrapper requestWrapper,ResponseWrapper responseWrapper,ExceptionMapper exceptionMapper,Exception e){\r\n    ExceptionHandlerImpl handler = exceptionMapper.getHandler(e);\r\n    if (handler != null) {\r\n        handler.handle(e, requestWrapper, responseWrapper);\r\n        String bodyAfterFilter = responseWrapper.getDelegate().body();\r\n        if (bodyAfterFilter != null) {\r\n            body.set(bodyAfterFilter);\r\n        }\r\n    } else {\r\n        LOG.error(\"\", e);\r\n        httpResponse.setStatus(500);\r\n        if (CustomErrorPages.existsFor(500)) {\r\n            requestWrapper.setDelegate(RequestResponseFactory.create(httpRequest));\r\n            responseWrapper.setDelegate(RequestResponseFactory.create(httpResponse));\r\n            body.set(CustomErrorPages.getFor(500, requestWrapper, responseWrapper));\r\n        } else {\r\n            body.set(CustomErrorPages.INTERNAL_ERROR);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.web.servlet.DynamicRegistrationBean.setName",
	"Comment": "set the name of this registration. if not specified the bean name will be used.",
	"Method": "void setName(String name){\r\n    Assert.hasLength(name, \"Name must not be empty\");\r\n    this.name = name;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BindHandler.onStart",
	"Comment": "called when binding of an element starts but before any result has been determined.",
	"Method": "Bindable<T> onStart(ConfigurationPropertyName name,Bindable<T> target,BindContext context){\r\n    return target;\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentMgmtService.setPreferenceQueryService",
	"Comment": "sets the preference query service with the specified preference query service.",
	"Method": "void setPreferenceQueryService(PreferenceQueryService preferenceQueryService){\r\n    this.preferenceQueryService = preferenceQueryService;\r\n}"
}, {
	"Path": "spark.Spark.init",
	"Comment": "initializes the spark server. should just be used when using the websockets functionality.",
	"Method": "void init(){\r\n    getInstance().init();\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.setPermalinkQueryService",
	"Comment": "sets the permalink query service with the specified permalink query service.",
	"Method": "void setPermalinkQueryService(PermalinkQueryService permalinkQueryService){\r\n    this.permalinkQueryService = permalinkQueryService;\r\n}"
}, {
	"Path": "org.b3log.solo.service.PluginMgmtService.get",
	"Comment": "gets a plugin in the specified plugins with the specified id.",
	"Method": "AbstractPlugin get(List<AbstractPlugin> plugins,String id){\r\n    if (null == id) {\r\n        throw new IllegalArgumentException(\"id must not be null\");\r\n    }\r\n    for (final AbstractPlugin plugin : plugins) {\r\n        if (id.equals(plugin.getId())) {\r\n            return plugin;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.boot.test.json.JsonContentAssert.extractingJsonPathArrayValue",
	"Comment": "extract the array value at the given json path for further object assertions.",
	"Method": "ListAssert<E> extractingJsonPathArrayValue(CharSequence expression,Object args){\r\n    return Assertions.assertThat(extractingJsonPathValue(expression, args, List.class, \"an array\"));\r\n}"
}, {
	"Path": "spark.utils.ClassUtils.registerCommonClasses",
	"Comment": "register the given common classes with the classutils cache.",
	"Method": "void registerCommonClasses(Class<?> commonClasses){\r\n    for (Class<?> clazz : commonClasses) {\r\n        commonClassCache.put(clazz.getName(), clazz);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.solo.processor.CategoryProcessor.showCategoryArticles",
	"Comment": "shows articles related with a category with the specified context.",
	"Method": "void showCategoryArticles(HTTPRequestContext context){\r\n    final AbstractFreeMarkerRenderer renderer = new SkinRenderer(context.getRequest());\r\n    context.setRenderer(renderer);\r\n    renderer.setTemplateName(\"category-articles.ftl\");\r\n    final Map<String, Object> dataModel = renderer.getDataModel();\r\n    final HttpServletRequest request = context.getRequest();\r\n    final HttpServletResponse response = context.getResponse();\r\n    try {\r\n        String requestURI = request.getRequestURI();\r\n        if (!requestURI.endsWith(\"/\")) {\r\n            requestURI += \"/\";\r\n        }\r\n        String categoryURI = getCategoryURI(requestURI);\r\n        final int currentPageNum = getCurrentPageNum(requestURI, categoryURI);\r\n        if (-1 == currentPageNum) {\r\n            context.sendError(HttpServletResponse.SC_NOT_FOUND);\r\n            return;\r\n        }\r\n        LOGGER.log(Level.DEBUG, \"Category [URI={0}, currentPageNum={1}]\", categoryURI, currentPageNum);\r\n        final JSONObject category = categoryQueryService.getByURI(categoryURI);\r\n        if (null == category) {\r\n            context.sendError(HttpServletResponse.SC_NOT_FOUND);\r\n            return;\r\n        }\r\n        dataModel.put(Category.CATEGORY, category);\r\n        final JSONObject preference = preferenceQueryService.getPreference();\r\n        final int pageSize = preference.getInt(Option.ID_C_ARTICLE_LIST_DISPLAY_COUNT);\r\n        final String categoryId = category.optString(Keys.OBJECT_ID);\r\n        final JSONObject result = articleQueryService.getCategoryArticles(categoryId, currentPageNum, pageSize);\r\n        final List<JSONObject> articles = (List<JSONObject>) result.opt(Article.ARTICLES);\r\n        final int pageCount = result.optJSONObject(Pagination.PAGINATION).optInt(Pagination.PAGINATION_PAGE_COUNT);\r\n        if (0 == pageCount) {\r\n            context.sendError(HttpServletResponse.SC_NOT_FOUND);\r\n            return;\r\n        }\r\n        Skins.fillLangs(preference.optString(Option.ID_C_LOCALE_STRING), (String) request.getAttribute(Keys.TEMAPLTE_DIR_NAME), dataModel);\r\n        dataModelService.setArticlesExProperties(request, articles, preference);\r\n        final List<Integer> pageNums = (List) result.optJSONObject(Pagination.PAGINATION).opt(Pagination.PAGINATION_PAGE_NUMS);\r\n        fillPagination(dataModel, pageCount, currentPageNum, articles, pageNums);\r\n        dataModel.put(Common.PATH, \"/category/\" + URLs.encode(categoryURI));\r\n        dataModelService.fillCommon(request, response, dataModel, preference);\r\n        statisticMgmtService.incBlogViewCount(request, response);\r\n    } catch (final ServiceException | JSONException e) {\r\n        LOGGER.log(Level.ERROR, e.getMessage(), e);\r\n        context.sendError(HttpServletResponse.SC_NOT_FOUND);\r\n    }\r\n}"
}, {
	"Path": "org.openqa.grid.internal.utils.DefaultCapabilityMatcherTest.nullEmptyValuesWithDeprecatedPlatformCapability",
	"Comment": "todo remove test when capabilitytype.platform is removed from code base",
	"Method": "void nullEmptyValuesWithDeprecatedPlatformCapability(){\r\n    Map<String, Object> requested = new HashMap();\r\n    requested.put(CapabilityType.BROWSER_NAME, BrowserType.FIREFOX);\r\n    requested.put(CapabilityType.PLATFORM, null);\r\n    requested.put(CapabilityType.VERSION, \"\");\r\n    Map<String, Object> node = new HashMap();\r\n    node.put(CapabilityType.BROWSER_NAME, BrowserType.FIREFOX);\r\n    node.put(CapabilityType.PLATFORM, Platform.LINUX);\r\n    node.put(CapabilityType.VERSION, \"3.6\");\r\n    assertTrue(matcher.matches(node, requested));\r\n}"
}, {
	"Path": "org.b3log.solo.processor.ArticleProcessor.getArchiveCurrentPageNum",
	"Comment": "gets the request page number from the specified request uri.",
	"Method": "int getArchiveCurrentPageNum(String requestURI){\r\n    final String pageNumString = StringUtils.substring(requestURI, (Latkes.getContextPath() + \"/archives/yyyy/MM/\").length());\r\n    return Requests.getCurrentPageNum(pageNumString);\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentMgmtService.addArticleComment",
	"Comment": "adds an article comment with the specified request json object.",
	"Method": "JSONObject addArticleComment(JSONObject requestJSONObject){\r\n    final JSONObject ret = new JSONObject();\r\n    ret.put(Common.IS_REPLY, false);\r\n    final Transaction transaction = commentRepository.beginTransaction();\r\n    try {\r\n        final String articleId = requestJSONObject.getString(Keys.OBJECT_ID);\r\n        final JSONObject article = articleRepository.get(articleId);\r\n        ret.put(Article.ARTICLE, article);\r\n        final String commentName = requestJSONObject.getString(Comment.COMMENT_NAME);\r\n        final String commentEmail = requestJSONObject.getString(Comment.COMMENT_EMAIL).trim().toLowerCase();\r\n        final String commentURL = requestJSONObject.optString(Comment.COMMENT_URL);\r\n        final String commentContent = requestJSONObject.getString(Comment.COMMENT_CONTENT);\r\n        final String originalCommentId = requestJSONObject.optString(Comment.COMMENT_ORIGINAL_COMMENT_ID);\r\n        ret.put(Comment.COMMENT_ORIGINAL_COMMENT_ID, originalCommentId);\r\n        final JSONObject comment = new JSONObject();\r\n        comment.put(Comment.COMMENT_ORIGINAL_COMMENT_ID, \"\");\r\n        comment.put(Comment.COMMENT_ORIGINAL_COMMENT_NAME, \"\");\r\n        JSONObject originalComment = null;\r\n        comment.put(Comment.COMMENT_NAME, commentName);\r\n        comment.put(Comment.COMMENT_EMAIL, commentEmail);\r\n        comment.put(Comment.COMMENT_URL, commentURL);\r\n        comment.put(Comment.COMMENT_CONTENT, commentContent);\r\n        comment.put(Comment.COMMENT_ORIGINAL_COMMENT_ID, requestJSONObject.optString(Comment.COMMENT_ORIGINAL_COMMENT_ID));\r\n        comment.put(Comment.COMMENT_ORIGINAL_COMMENT_NAME, requestJSONObject.optString(Comment.COMMENT_ORIGINAL_COMMENT_NAME));\r\n        final JSONObject preference = preferenceQueryService.getPreference();\r\n        final Date date = new Date();\r\n        comment.put(Comment.COMMENT_CREATED, date.getTime());\r\n        ret.put(Comment.COMMENT_T_DATE, DateFormatUtils.format(date, \"yyyy-MM-dd HH:mm:ss\"));\r\n        ret.put(\"commentDate2\", date);\r\n        ret.put(Common.COMMENTABLE, preference.getBoolean(Option.ID_C_COMMENTABLE) && article.getBoolean(Article.ARTICLE_COMMENTABLE));\r\n        ret.put(Common.PERMALINK, article.getString(Article.ARTICLE_PERMALINK));\r\n        ret.put(Comment.COMMENT_NAME, commentName);\r\n        String cmtContent = Emotions.convert(commentContent);\r\n        cmtContent = Markdowns.toHTML(cmtContent);\r\n        cmtContent = Jsoup.clean(cmtContent, Whitelist.relaxed());\r\n        ret.put(Comment.COMMENT_CONTENT, cmtContent);\r\n        ret.put(Comment.COMMENT_URL, commentURL);\r\n        if (StringUtils.isNotBlank(originalCommentId)) {\r\n            originalComment = commentRepository.get(originalCommentId);\r\n            if (null != originalComment) {\r\n                comment.put(Comment.COMMENT_ORIGINAL_COMMENT_ID, originalCommentId);\r\n                final String originalCommentName = originalComment.getString(Comment.COMMENT_NAME);\r\n                comment.put(Comment.COMMENT_ORIGINAL_COMMENT_NAME, originalCommentName);\r\n                ret.put(Comment.COMMENT_ORIGINAL_COMMENT_NAME, originalCommentName);\r\n                ret.put(Common.IS_REPLY, true);\r\n            } else {\r\n                LOGGER.log(Level.WARN, \"Not found orginal comment[id={0}] of reply[name={1}, content={2}]\", originalCommentId, commentName, commentContent);\r\n            }\r\n        }\r\n        setCommentThumbnailURL(comment);\r\n        ret.put(Comment.COMMENT_THUMBNAIL_URL, comment.getString(Comment.COMMENT_THUMBNAIL_URL));\r\n        comment.put(Comment.COMMENT_ON_ID, articleId);\r\n        comment.put(Comment.COMMENT_ON_TYPE, Article.ARTICLE);\r\n        final String commentId = Ids.genTimeMillisId();\r\n        comment.put(Keys.OBJECT_ID, commentId);\r\n        ret.put(Keys.OBJECT_ID, commentId);\r\n        final String commentSharpURL = Comment.getCommentSharpURLForArticle(article, commentId);\r\n        comment.put(Comment.COMMENT_SHARP_URL, commentSharpURL);\r\n        ret.put(Comment.COMMENT_SHARP_URL, commentSharpURL);\r\n        commentRepository.add(comment);\r\n        articleMgmtService.incArticleCommentCount(articleId);\r\n        statisticMgmtService.incBlogCommentCount();\r\n        statisticMgmtService.incPublishedBlogCommentCount();\r\n        try {\r\n            sendNotificationMail(article, comment, originalComment, preference);\r\n        } catch (final Exception e) {\r\n            LOGGER.log(Level.WARN, \"Send mail failed\", e);\r\n        }\r\n        final JSONObject eventData = new JSONObject();\r\n        eventData.put(Comment.COMMENT, comment);\r\n        eventData.put(Article.ARTICLE, article);\r\n        eventManager.fireEventSynchronously(new Event(EventTypes.ADD_COMMENT_TO_ARTICLE, eventData));\r\n        transaction.commit();\r\n    } catch (final Exception e) {\r\n        if (transaction.isActive()) {\r\n            transaction.rollback();\r\n        }\r\n        throw new ServiceException(e);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.endpoint.invoker.cache.CachingOperationInvoker.apply",
	"Comment": "apply caching configuration when appropriate to the given invoker.",
	"Method": "OperationInvoker apply(OperationInvoker invoker,long timeToLive){\r\n    if (timeToLive > 0) {\r\n        return new CachingOperationInvoker(invoker, timeToLive);\r\n    }\r\n    return invoker;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.autoconfigure.web.servlet.WebMvcEndpointChildContextConfiguration.errorEndpoint",
	"Comment": "the error controller is present but not mapped as an endpoint in this context\tbecause of the dispatcherservlet having had its handlermapping explicitly disabled.\tso we expose the same feature but only for machine endpoints.",
	"Method": "ManagementErrorEndpoint errorEndpoint(ErrorAttributes errorAttributes){\r\n    return new ManagementErrorEndpoint(errorAttributes);\r\n}"
}, {
	"Path": "org.b3log.solo.service.PreferenceMgmtService.setLangPropsService",
	"Comment": "sets the language service with the specified language service.",
	"Method": "void setLangPropsService(LangPropsService langPropsService){\r\n    this.langPropsService = langPropsService;\r\n}"
}, {
	"Path": "org.openqa.grid.web.servlet.RegistrationServletTest.testLegacyV3BetaRegistration",
	"Comment": "tests that the registration request servlet can process a v2 registrationrequest froma 3.x node.",
	"Method": "void testLegacyV3BetaRegistration(){\r\n    GridNodeConfiguration config = new GridNodeConfiguration();\r\n    config.capabilities.clear();\r\n    config.proxy = null;\r\n    grid3Request.put(\"configuration\", config);\r\n    grid3Request.put(\"capabilities\", singletonList(new FirefoxOptions()));\r\n    String id = \"http://dummynode:2345\";\r\n    grid3Request.put(\"id\", id);\r\n    final FakeHttpServletResponse response = sendCommand(\"POST\", \"/\", grid3Request);\r\n    waitForServletToAddProxy();\r\n    assertEquals(HttpServletResponse.SC_OK, response.getStatus());\r\n    assertEquals(((RegistrationServlet) servlet).getRegistry().getAllProxies().size(), 1);\r\n    final RemoteProxy proxy = ((RegistrationServlet) servlet).getRegistry().getAllProxies().getProxyById(id);\r\n    assertNotNull(proxy);\r\n    assertEquals(0, proxy.getConfig().servlets.size());\r\n    assertEquals(1, proxy.getConfig().capabilities.size());\r\n    assertEquals(config.registerCycle.intValue(), proxy.getConfig().registerCycle.intValue());\r\n    assertEquals(id, proxy.getConfig().id);\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.autoconfigure.metrics.test.MetricsRun.limitedTo",
	"Comment": "return a function that configures the run to be limited to the specified\timplementations.",
	"Method": "Function<T, T> limitedTo(Class<?> exportAutoConfigurations){\r\n    return (contextRunner) -> apply(contextRunner, exportAutoConfigurations);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport.getUnconditionalClasses",
	"Comment": "returns the names of the classes that were evaluated but were not conditional.",
	"Method": "Set<String> getUnconditionalClasses(){\r\n    Set<String> filtered = new HashSet(this.unconditionalClasses);\r\n    filtered.removeAll(this.exclusions);\r\n    return Collections.unmodifiableSet(filtered);\r\n}"
}, {
	"Path": "spark.CustomErrorPages.getFor",
	"Comment": "gets the custom error page for a given status code.if the customerror page is a route, the output of its handle method is returned.if the custom error page is a string, it is returned as an object.",
	"Method": "Object getFor(int status,Request request,Response response){\r\n    Object customRenderer = CustomErrorPages.getInstance().customPages.get(status);\r\n    Object customPage = CustomErrorPages.getInstance().getDefaultFor(status);\r\n    if (customRenderer instanceof String) {\r\n        customPage = customRenderer;\r\n    } else if (customRenderer instanceof Route) {\r\n        try {\r\n            customPage = ((Route) customRenderer).handle(request, response);\r\n        } catch (Exception e) {\r\n            LOG.warn(\"Custom error page handler for status code {} has thrown an exception: {}. Using default page instead.\", status, e.getMessage());\r\n        }\r\n    }\r\n    return customPage;\r\n}"
}, {
	"Path": "org.springframework.boot.builder.SpringApplicationBuilder.properties",
	"Comment": "default properties for the environment. multiple calls to this method are\tcumulative.",
	"Method": "SpringApplicationBuilder properties(String defaultProperties,SpringApplicationBuilder properties,Properties defaultProperties,SpringApplicationBuilder properties,Map<String, Object> defaults){\r\n    this.defaultProperties.putAll(defaults);\r\n    this.application.setDefaultProperties(this.defaultProperties);\r\n    if (this.parent != null) {\r\n        this.parent.properties(this.defaultProperties);\r\n        this.parent.environment(this.environment);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.boot.actuate.info.InfoPropertiesInfoContributor.getNestedMap",
	"Comment": "return the nested map with the specified key or empty map if the specified map\tcontains no mapping for the key.",
	"Method": "Map<String, Object> getNestedMap(Map<String, Object> map,String key){\r\n    Object value = map.get(key);\r\n    if (value == null) {\r\n        return Collections.emptyMap();\r\n    }\r\n    return (Map<String, Object>) value;\r\n}"
}, {
	"Path": "org.springframework.boot.SpringApplication.setBeanNameGenerator",
	"Comment": "sets the bean name generator that should be used when generating bean names.",
	"Method": "void setBeanNameGenerator(BeanNameGenerator beanNameGenerator){\r\n    this.beanNameGenerator = beanNameGenerator;\r\n}"
}, {
	"Path": "org.b3log.solo.cache.OptionCache.putCategory",
	"Comment": "puts the specified merged options with the specified category.",
	"Method": "void putCategory(String category,JSONObject mergedOptions){\r\n    categoryCache.put(category, mergedOptions);\r\n}"
}, {
	"Path": "org.springframework.boot.BeanDefinitionLoader.setEnvironment",
	"Comment": "set the environment to be used by the underlying readers and scanner.",
	"Method": "void setEnvironment(ConfigurableEnvironment environment){\r\n    this.annotatedReader.setEnvironment(environment);\r\n    this.xmlReader.setEnvironment(environment);\r\n    this.scanner.setEnvironment(environment);\r\n}"
}, {
	"Path": "spark.util.SparkTestUtil.getTrustStorePassword",
	"Comment": "return jvm param set truststore password or keystore password if not set.if still not set, will return default password",
	"Method": "String getTrustStorePassword(){\r\n    String password = System.getProperty(\"javax.net.ssl.trustStorePassword\");\r\n    return password == null ? getKeystorePassword() : password;\r\n}"
}, {
	"Path": "spark.Session.invalidate",
	"Comment": "invalidates this session then unbinds any objects bound to it.",
	"Method": "void invalidate(){\r\n    request.validSession(false);\r\n    session.invalidate();\r\n}"
}, {
	"Path": "org.springframework.boot.context.logging.LoggingApplicationListener.setSpringBootLogging",
	"Comment": "sets a custom logging level to be used for spring boot and related libraries.",
	"Method": "void setSpringBootLogging(LogLevel springBootLogging){\r\n    this.springBootLogging = springBootLogging;\r\n}"
}, {
	"Path": "org.springframework.boot.context.properties.bind.BindResult.ifBound",
	"Comment": "invoke the specified consumer with the bound value, or do nothing if no value has\tbeen bound.",
	"Method": "void ifBound(Consumer<? super T> consumer){\r\n    Assert.notNull(consumer, \"Consumer must not be null\");\r\n    if (this.value != null) {\r\n        consumer.accept(this.value);\r\n    }\r\n}"
}, {
	"Path": "spark.CustomErrorPages.getDefaultFor",
	"Comment": "returns the default error page for a given status code.guaranteed to never be null.",
	"Method": "String getDefaultFor(int status){\r\n    String defaultPage = defaultPages.get(status);\r\n    return (defaultPage != null) ? defaultPage : \"<html><body><h2>HTTP Status \" + status + \"<\/h2><\/body><\/html>\";\r\n}"
}, {
	"Path": "org.springframework.boot.test.web.client.TestRestTemplate.optionsForAllow",
	"Comment": "return the value of the allow header for the given uri.\turi template variables are expanded using the given map.",
	"Method": "Set<HttpMethod> optionsForAllow(String url,Object urlVariables,Set<HttpMethod> optionsForAllow,String url,Map<String, ?> urlVariables,Set<HttpMethod> optionsForAllow,URI url){\r\n    return this.restTemplate.optionsForAllow(applyRootUriIfNecessary(url));\r\n}"
}, {
	"Path": "org.b3log.solo.service.PageMgmtService.setPreferenceQueryService",
	"Comment": "sets the preference query service with the specified preference query service.",
	"Method": "void setPreferenceQueryService(PreferenceQueryService preferenceQueryService){\r\n    this.preferenceQueryService = preferenceQueryService;\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentMgmtService.setLangPropsService",
	"Comment": "sets the language service with the specified language service.",
	"Method": "void setLangPropsService(LangPropsService langPropsService){\r\n    this.langPropsService = langPropsService;\r\n}"
}, {
	"Path": "spark.resource.ExternalResource.getFilename",
	"Comment": "this implementation returns the name of the file that this externalresource refers to.",
	"Method": "String getFilename(){\r\n    return StringUtils.getFilename(getPath());\r\n}"
}, {
	"Path": "org.springframework.boot.test.web.client.TestRestTemplate.headForHeaders",
	"Comment": "retrieve all headers of the resource specified by the uri template.\turi template variables are expanded using the given map.",
	"Method": "HttpHeaders headForHeaders(String url,Object urlVariables,HttpHeaders headForHeaders,String url,Map<String, ?> urlVariables,HttpHeaders headForHeaders,URI url){\r\n    return this.restTemplate.headForHeaders(applyRootUriIfNecessary(url));\r\n}"
}, {
	"Path": "org.springframework.boot.configurationprocessor.json.JSONStringer.close",
	"Comment": "closes the current scope by appending any necessary whitespace and the given\tbracket.",
	"Method": "JSONStringer close(Scope empty,Scope nonempty,String closeBracket){\r\n    Scope context = peek();\r\n    if (context != nonempty && context != empty) {\r\n        throw new JSONException(\"Nesting problem\");\r\n    }\r\n    this.stack.remove(this.stack.size() - 1);\r\n    if (context == nonempty) {\r\n        newline();\r\n    }\r\n    this.out.append(closeBracket);\r\n    return this;\r\n}"
}, {
	"Path": "org.b3log.solo.service.ArticleMgmtService.topArticle",
	"Comment": "puts an article specified by the given article id to top or cancel top.",
	"Method": "void topArticle(String articleId,boolean top){\r\n    final Transaction transaction = articleRepository.beginTransaction();\r\n    try {\r\n        final JSONObject topArticle = articleRepository.get(articleId);\r\n        topArticle.put(ARTICLE_PUT_TOP, top);\r\n        articleRepository.update(articleId, topArticle);\r\n        transaction.commit();\r\n    } catch (final Exception e) {\r\n        if (transaction.isActive()) {\r\n            transaction.rollback();\r\n        }\r\n        LOGGER.log(Level.ERROR, \"Can't put the article[oId{0}] to top\", articleId);\r\n        throw new ServiceException(e);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.SpringApplication.getResourceLoader",
	"Comment": "the resourceloader that will be used in the applicationcontext.",
	"Method": "ResourceLoader getResourceLoader(){\r\n    return this.resourceLoader;\r\n}"
}, {
	"Path": "org.b3log.solo.repository.OptionRepository.getOptions",
	"Comment": "gets options with the specified category.all options with the specified category will be merged into one json object as the return value.",
	"Method": "JSONObject getOptions(String category){\r\n    final JSONObject cached = optionCache.getCategory(category);\r\n    if (null != cached) {\r\n        return cached;\r\n    }\r\n    final JSONObject ret = new JSONObject();\r\n    try {\r\n        final List<JSONObject> options = getList(new Query().setFilter(new PropertyFilter(Option.OPTION_CATEGORY, FilterOperator.EQUAL, category)));\r\n        if (0 == options.size()) {\r\n            return null;\r\n        }\r\n        options.stream().forEach(option -> ret.put(option.optString(Keys.OBJECT_ID), option.opt(Option.OPTION_VALUE)));\r\n        optionCache.putCategory(category, ret);\r\n        return ret;\r\n    } catch (final Exception e) {\r\n        throw new RepositoryException(e);\r\n    }\r\n}"
}, {
	"Path": "spark.resource.AbstractFileResolvingResource.getFile",
	"Comment": "this implementation returns a file reference for the underlying class pathresource, provided that it refers to a file in the file system.",
	"Method": "File getFile(){\r\n    URL url = getURL();\r\n    return ResourceUtils.getFile(url, getDescription());\r\n}"
}, {
	"Path": "org.springframework.boot.cli.command.init.InitializrService.executeProjectGenerationRequest",
	"Comment": "request the creation of the project using the specified url.",
	"Method": "CloseableHttpResponse executeProjectGenerationRequest(URI url){\r\n    return execute(new HttpGet(url), url, \"generate project\");\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentMgmtService.setPageRepository",
	"Comment": "set the page repository with the specified page repository.",
	"Method": "void setPageRepository(PageRepository pageRepository){\r\n    this.pageRepository = pageRepository;\r\n}"
}, {
	"Path": "org.b3log.solo.service.PageMgmtService.setStatisticQueryService",
	"Comment": "sets the statistic query service with the specified statistic query service.",
	"Method": "void setStatisticQueryService(StatisticQueryService statisticQueryService){\r\n    this.statisticQueryService = statisticQueryService;\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.jdbc.DataSourceProperties.determineUrl",
	"Comment": "determine the url to use based on this configuration and the environment.",
	"Method": "String determineUrl(){\r\n    if (StringUtils.hasText(this.url)) {\r\n        return this.url;\r\n    }\r\n    String databaseName = determineDatabaseName();\r\n    String url = (databaseName != null) ? this.embeddedDatabaseConnection.getUrl(databaseName) : null;\r\n    if (!StringUtils.hasText(url)) {\r\n        throw new DataSourceBeanCreationException(\"Failed to determine suitable jdbc url\", this, this.embeddedDatabaseConnection);\r\n    }\r\n    return url;\r\n}"
}, {
	"Path": "org.springframework.boot.devtools.tunnel.payload.HttpTunnelPayload.logIncoming",
	"Comment": "log incoming payload information at trace level to aid diagnostics.",
	"Method": "void logIncoming(){\r\n    log(\"< \");\r\n}"
}, {
	"Path": "org.b3log.solo.service.CommentQueryService.canAccessComment",
	"Comment": "can the specified user access a comment specified by the given comment id?",
	"Method": "boolean canAccessComment(String commentId,JSONObject user){\r\n    if (StringUtils.isBlank(commentId)) {\r\n        return false;\r\n    }\r\n    if (null == user) {\r\n        return false;\r\n    }\r\n    if (Role.ADMIN_ROLE.equals(user.optString(User.USER_ROLE))) {\r\n        return true;\r\n    }\r\n    final JSONObject comment = commentRepository.get(commentId);\r\n    if (null == comment) {\r\n        return false;\r\n    }\r\n    final String onId = comment.optString(Comment.COMMENT_ON_ID);\r\n    final String onType = comment.optString(Comment.COMMENT_ON_TYPE);\r\n    if (Page.PAGE.equals(onType)) {\r\n        return false;\r\n    }\r\n    final JSONObject article = articleRepository.get(onId);\r\n    if (null == article) {\r\n        return false;\r\n    }\r\n    final String currentUserId = user.getString(Keys.OBJECT_ID);\r\n    return article.getString(Article.ARTICLE_AUTHOR_ID).equals(currentUserId);\r\n}"
}, {
	"Path": "org.springframework.boot.autoconfigure.web.reactive.error.DefaultErrorWebExceptionHandler.isIncludeStackTrace",
	"Comment": "determine if the stacktrace attribute should be included.",
	"Method": "boolean isIncludeStackTrace(ServerRequest request,MediaType produces){\r\n    ErrorProperties.IncludeStacktrace include = this.errorProperties.getIncludeStacktrace();\r\n    if (include == ErrorProperties.IncludeStacktrace.ALWAYS) {\r\n        return true;\r\n    }\r\n    if (include == ErrorProperties.IncludeStacktrace.ON_TRACE_PARAM) {\r\n        return isTraceEnabled(request);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.b3log.solo.service.InitService.setTagArticleRepository",
	"Comment": "sets the tag article repository with the specified tag article repository.",
	"Method": "void setTagArticleRepository(TagArticleRepository tagArticleRepository){\r\n    this.tagArticleRepository = tagArticleRepository;\r\n}"
}, {
	"Path": "spark.resource.AbstractResource.getFile",
	"Comment": "this implementation throws a filenotfoundexception, assumingthat the resource cannot be resolved to an absolute file path.",
	"Method": "File getFile(){\r\n    throw new FileNotFoundException(getDescription() + \" cannot be resolved to absolute file path\");\r\n}"
}, {
	"Path": "org.springframework.boot.cli.command.init.ProjectGenerationRequest.generateUrl",
	"Comment": "generates the uri to use to generate a project represented by this request.",
	"Method": "URI generateUrl(InitializrServiceMetadata metadata){\r\n    try {\r\n        URIBuilder builder = new URIBuilder(this.serviceUrl);\r\n        StringBuilder sb = new StringBuilder();\r\n        if (builder.getPath() != null) {\r\n            sb.append(builder.getPath());\r\n        }\r\n        ProjectType projectType = determineProjectType(metadata);\r\n        this.type = projectType.getId();\r\n        sb.append(projectType.getAction());\r\n        builder.setPath(sb.toString());\r\n        if (!this.dependencies.isEmpty()) {\r\n            builder.setParameter(\"dependencies\", StringUtils.collectionToCommaDelimitedString(this.dependencies));\r\n        }\r\n        if (this.groupId != null) {\r\n            builder.setParameter(\"groupId\", this.groupId);\r\n        }\r\n        String resolvedArtifactId = resolveArtifactId();\r\n        if (resolvedArtifactId != null) {\r\n            builder.setParameter(\"artifactId\", resolvedArtifactId);\r\n        }\r\n        if (this.version != null) {\r\n            builder.setParameter(\"version\", this.version);\r\n        }\r\n        if (this.name != null) {\r\n            builder.setParameter(\"name\", this.name);\r\n        }\r\n        if (this.description != null) {\r\n            builder.setParameter(\"description\", this.description);\r\n        }\r\n        if (this.packageName != null) {\r\n            builder.setParameter(\"packageName\", this.packageName);\r\n        }\r\n        if (this.type != null) {\r\n            builder.setParameter(\"type\", projectType.getId());\r\n        }\r\n        if (this.packaging != null) {\r\n            builder.setParameter(\"packaging\", this.packaging);\r\n        }\r\n        if (this.javaVersion != null) {\r\n            builder.setParameter(\"javaVersion\", this.javaVersion);\r\n        }\r\n        if (this.language != null) {\r\n            builder.setParameter(\"language\", this.language);\r\n        }\r\n        if (this.bootVersion != null) {\r\n            builder.setParameter(\"bootVersion\", this.bootVersion);\r\n        }\r\n        return builder.build();\r\n    } catch (URISyntaxException ex) {\r\n        throw new ReportableException(\"Invalid service URL (\" + ex.getMessage() + \")\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.boot.security.servlet.ApplicationContextRequestMatcher.matches",
	"Comment": "decides whether the rule implemented by the strategy matches the supplied request.",
	"Method": "boolean matches(HttpServletRequest request,boolean matches,HttpServletRequest request,Supplier<C> context){\r\n    return matches(request, getContext(request));\r\n}"
}, {
	"Path": "org.b3log.solo.repository.ArticleRepository.isPublished",
	"Comment": "determines an article specified by the given article id is published.",
	"Method": "boolean isPublished(String articleId){\r\n    final JSONObject article = get(articleId);\r\n    if (null == article) {\r\n        return false;\r\n    }\r\n    return article.optBoolean(Article.ARTICLE_IS_PUBLISHED);\r\n}"
}]